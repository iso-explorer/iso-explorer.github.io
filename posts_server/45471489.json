post_cb({"45471734": {"ParentId": "45471489", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-08-02T22:01:17.457", "Score": "2", "LastEditorUserId": "2630032", "LastEditDate": "2017-08-02T22:07:47.033", "Id": "45471734", "OwnerUserId": "2630032", "Body": "<p>A difference arises because of short-circuit evaluation:\nConsider an expression of the form <code>(expr1 || expr2)</code>. Short-circuit means that if <code>expr1</code> evaluates to <code>true</code>, expression <code>expr2</code> will not get evaluated at all (cf. <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.log.or#1\" rel=\"nofollow noreferrer\">this online c++ standard draft</a>, ephasis are mine):</p>\n<blockquote>\n<p id=\"so_45471489_45471734_0\"><em>5.15 Logical OR operator</em></p>\n<p id=\"so_45471489_45471734_1\">The || operator groups left-to-right. The operands are both\n  contextually converted to bool (Clause [conv]). It returns true if\n  either of its operands is true, and false otherwise. Unlike |, ||\n  guarantees left-to-right evaluation; <strong>moreover, the second operand is\n  not evaluated if the first operand evaluates to true</strong>.</p>\n</blockquote>\n<p>Hence, in your expression <code>addedFacts || set.insert(x).second</code>, from the point where <code>addedFacts</code> becomes <code>true</code> the first time, expression <code>set.insert(x).second</code> will not get executed any more. I suppose that this is the \"wrong\" behaviour, as your <code>set</code> will not contain the respective <code>x</code>es then.</p>\n", "LastActivityDate": "2017-08-02T22:07:47.033"}, "45471587": {"ParentId": "45471489", "CommentCount": "0", "CreationDate": "2017-08-02T21:50:27.313", "OwnerUserId": "4442671", "PostTypeId": "2", "Id": "45471587", "Score": "3", "Body": "<pre><code>addedFacts = addedFacts || set.insert(x).second;\n</code></pre>\n<p>and </p>\n<pre><code>if (set.insert(x).second) {\n    addedFacts = true;\n}\n</code></pre>\n<p>Are definitely not the same thing. The first block of code is equivalent to:</p>\n<pre><code>if (!addedFacts) {\n    addedFacts = set.insert(x).second;\n}\n</code></pre>\n<p>the <code>!addedFacts</code> check makes a big difference.</p>\n", "LastActivityDate": "2017-08-02T21:50:27.313"}, "45471489": {"CommentCount": "1", "ViewCount": "64", "CreationDate": "2017-08-02T21:43:32.630", "LastActivityDate": "2017-08-02T22:07:47.033", "Title": "C++ difference in behavior between if statement setting condition to true and or-ing a condition in loop", "AcceptedAnswerId": "45471734", "PostTypeId": "1", "Id": "45471489", "Score": "1", "Body": "<p>I was working on Datalog interpreter for my CS class and I ran into a strange problem where my Rule evaluations took too many passes to complete. After looking at my code I made two modifications in the following that fixed my evaluations to execute in the correct number of passes:</p>\n<pre><code>//original form\nbool addedFacts = false;\nfor (X x: xs) {\n    addedFacts = addedFacts || set.insert(x).second;\n}\n//modified form\nbool addedFacts = false;\nfor (X x: xs) {\n    if (set.insert(x).second) {\n        addedFacts = true;\n    }\n}\n</code></pre>\n<p>To me these two code structures appear logically equivalent. Is there a reason why one executes correctly and one execute incorrectly/inefficiently?\nHere is a buildable example of the problem that was occurring:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing std::set;\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\nconst int CAP = 100;\n\nclass Rule {\npublic:\n    int factor;\n    Rule(int factor) {\n        this-&gt;factor = factor;\n    }\n    bool evaluateInefficient(set&lt;int&gt;&amp; facts) {\n        vector&lt;int&gt; data;\n        bool addedFacts = false;\n        for (int fact : facts) {\n            data.push_back(fact);\n        }\n        for (int datum : data) {\n            int newFact = datum * factor;\n            if (newFact &lt; CAP) {\n                addedFacts = addedFacts || facts.insert(newFact).second;\n            }\n        }\n        return addedFacts;\n    }\n    bool evaluate(set&lt;int&gt;&amp; facts) {\n        vector&lt;int&gt; data;\n        bool addedFacts = false;\n        for (int fact : facts) {\n            data.push_back(fact);\n        }\n        for (int datum : data) {\n            int newFact = datum * factor;\n            if (newFact &lt; CAP) {\n                if (facts.insert(newFact).second) {\n                    addedFacts = true;\n                }\n            }\n        }\n        return addedFacts;\n    }\n};\n\nint doublyInefficient(vector&lt;Rule&gt;&amp; rules) {\n    set&lt;int&gt; facts;\n    facts.insert(1);\n    bool addedFacts = true;\n    int passes = 0;\n    while (addedFacts) {\n        passes++;\n        addedFacts = false;\n        for (Rule rule : rules) {\n            addedFacts = addedFacts || rule.evaluateInefficient(facts);\n        }\n    }\n    return passes;\n}\n\nint singlyInefficient(vector&lt;Rule&gt;&amp; rules) {\n    set&lt;int&gt; facts;\n    facts.insert(1);\n    bool addedFacts = true;\n    int passes = 0;\n    while (addedFacts) {\n        passes++;\n        addedFacts = false;\n        for (Rule rule : rules) {\n            addedFacts = addedFacts || rule.evaluate(facts);\n        }\n    }\n    return passes;\n}\n\nint efficient(vector&lt;Rule&gt;&amp; rules) {\n    set&lt;int&gt; facts;\n    facts.insert(1);\n    bool addedFacts = true;\n    int passes = 0;\n    while (addedFacts) {\n        passes++;\n        addedFacts = false;\n        for (Rule rule : rules) {\n            if (rule.evaluate(facts)) {\n                addedFacts = true;\n            }\n        }\n    }\n    return passes;\n}\n\nint main(int argc, char* argv[]) {\n    //build the rules\n    vector&lt;Rule&gt; rules;\n    rules.push_back(Rule(2));\n    rules.push_back(Rule(3));\n    rules.push_back(Rule(5));\n    rules.push_back(Rule(7));\n    rules.push_back(Rule(11));\n    rules.push_back(Rule(13));\n    //Show three different codes that should (in my mind) take the same amount of passes over the rules but don't\n    cout &lt;&lt; \"Facts populated after \" &lt;&lt; doublyInefficient(rules) &lt;&lt; \" passes through the Rules.\" &lt;&lt; endl;\n    cout &lt;&lt; \"Facts populated after \" &lt;&lt; singlyInefficient(rules) &lt;&lt; \" passes through the Rules.\" &lt;&lt; endl;\n    cout &lt;&lt; \"Facts populated after \" &lt;&lt; efficient(rules) &lt;&lt; \" passes through the Rules.\" &lt;&lt; endl;\n    getchar();\n}\n</code></pre>\n<p>I get the following output when running in debug and release mode (32-bit) on visual studio 2017. To my knowledge the code is not optimized.</p>\n<pre><code>Facts populated after 61 passes through the Rules.\nFacts populated after 17 passes through the Rules.\nFacts populated after 7 passes through the Rules.\n</code></pre>\n", "Tags": "<c++><loops><if-statement><set><logical-or>", "OwnerUserId": "3285858", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_45471489_45471734_1": {"section_id": 6165, "quality": 0.90625, "length": 29}}, "n3337": {"so_45471489_45471734_1": {"section_id": 5926, "quality": 0.90625, "length": 29}}, "n4659": {"so_45471489_45471734_1": {"section_id": 7662, "quality": 0.90625, "length": 29}}}});