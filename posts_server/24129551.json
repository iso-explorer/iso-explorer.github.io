post_cb({"24129588": {"Id": "24129588", "PostTypeId": "2", "Body": "<p>No, it is not correct : name hiding occurs when a function with the same name is declared in the same scope : here <code>print</code> in <code>Derived</code> <strong>hides</strong> the <code>print</code> of <code>Base</code>.</p>\n<p>Arguments names/types are ignored in this (first) step of functions lookup.</p>\n<p>You can bring the declaration of the Base function within the Derived one with a <code>using</code> declaration:</p>\n<pre><code>using Base::print\n</code></pre>\n<p>If you do so, regular overload resolution will take place.</p>\n<p>For details about <em>why</em> hiding occurs in this Derived/Base situation, I suggest <a href=\"https://stackoverflow.com/questions/1628768/why-does-an-overridden-function-in-the-derived-class-hide-other-overloads-of-the\">this other SO post</a> that perfectly answers it.</p>\n<p>As for the standard, this particular rule is defined in section 3.3.1 :</p>\n<blockquote>\n<p id=\"so_24129551_24129588_0\"><strong>Name hiding</strong> [basic.scope.hiding]</p>\n<p id=\"so_24129551_24129588_1\">A name can be hidden by an explicit declaration of that same name in a nested declarative region\n  or derived class (10.2).</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-09T21:51:46.857", "Score": "3", "CreationDate": "2014-06-09T21:45:17.660", "ParentId": "24129551", "CommentCount": "2", "OwnerUserId": "3510483", "LastEditDate": "2017-05-23T12:05:09.013"}, "bq_ids": {"n4140": {"so_24129551_24129588_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7078}}, "n3337": {"so_24129551_24129588_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 6822}}, "n4659": {"so_24129551_24129588_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 8579}}}, "24129551": {"ViewCount": "115", "Body": "<p>What's going on here -- why does this not compile?</p>\n<pre><code>#include &lt;iostream&gt;\nclass Base {\n    void print(double d) {\n        std::cout &lt;&lt; \"Base: \" &lt;&lt; d &lt;&lt; std::endl;\n    }\n};\n\nclass Derived : public Base {\nvoid print(std::string const &amp; str) {\n        std::cout &lt;&lt; \"Derived: \" &lt;&lt; str &lt;&lt; std::endl;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    Derived d;\n    d.print(2.);\n    d.print(\"junk\");\n}\n</code></pre>\n<p>(Errors in both MinGW and VC11 with something equivalent to <code>No conversion from double to std::string</code>.)</p>\n<p>If I change the name of the print function in <code>Derived</code>, it compiles successfully, so clearly <code>Derived::print(string const &amp;)</code> is masking <code>Base::print(double)</code> somehow. But I was under the impression that the function signature included the argument type(s) and so this masking should occur here. Is that not correct in the case of base class methods?</p>\n", "AcceptedAnswerId": "24129588", "Title": "Compiler can't find base class method by ADL", "CreationDate": "2014-06-09T21:41:38.013", "Id": "24129551", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-06-09T21:51:46.857", "Score": "2", "OwnerUserId": "2170381", "Tags": "<c++><inheritance><argument-dependent-lookup>", "AnswerCount": "1"}});