post_cb({"bq_ids": {"n4140": {"so_41427305_41427432_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 2711}}, "n3337": {"so_41427305_41427432_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 2672}}, "n4659": {"so_41427305_41427432_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 3451}}}, "41427432": {"Id": "41427432", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41427305_41427432_0\">30.3.1.2 thread constructors</p>\n<pre><code>template &lt;class F, class ...Args&gt; \nexplicit thread(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_41427305_41427432_1\">Synchronization: The completion of the invocation of the constructor\n  synchronizes with the beginning of the invocation of the copy of <code>f</code>.</p>\n</blockquote>\n<p>In other words: when the thread function gets invoked, it is synchronized with everything that happened in the parent thread up until <code>std::thread</code> gets constructed, in the parent thread.</p>\n<p>No explicit memory barriers/fences, of this kind, are needed.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2017-01-02T14:08:48.967", "Score": "5", "CreationDate": "2017-01-02T13:05:33.617", "ParentId": "41427305", "CommentCount": "4", "OwnerUserId": "3943312", "LastEditDate": "2017-01-02T14:08:48.967"}, "41427305": {"ViewCount": "75", "Body": "<p>Consider this code (extracted from <a href=\"https://github.com/eidheim/Simple-Web-Server\" rel=\"nofollow noreferrer\">Simple-Web-Server</a>, but knowledge of the library shouldn't be necessary to answer this question):</p>\n<pre><code>HttpServer server;\nthread server_thread;\n\nserver.config.port = 8080;\nserver.default_resource[\"GET\"] = [](shared_ptr&lt;HttpServer::Response&gt; response, shared_ptr&lt;HttpServer::Request&gt; request) {\n    string content = \"Hello world!\"\n    *response &lt;&lt; \"HTTP/1.1 200 OK\\r\\nContent-Length: \" &lt;&lt; content.size() &lt;&lt; \"\\r\\n\\r\\n\" &lt;&lt; content;\n};\n\nserver_thread = thread([&amp;server]() {\n    server.start();\n});\n</code></pre>\n<p><code>HttpServer::default_resource</code> is a std::unordered_map, which, to my understanding, isn't thread-safe.  <code>port</code> is an unsigned short.</p>\n<p>Assuming my understanding of C++ memory fences is correct, <code>server</code>, as seen by the new thread, might not be in a valid state as the main thread might not have written the changes to <code>port</code> and <code>default_resource</code> to memory accessible from other threads.  As such, <code>server.start()</code> might not work properly.</p>\n<p>To fix this, I would have to change the code by adding to <code>atomic_thread_fence</code>s:</p>\n<pre><code>HttpServer server;\nthread server_thread;\n\nserver.config.port = 8080;\nserver.default_resource[\"GET\"] = [](shared_ptr&lt;HttpServer::Response&gt; response, shared_ptr&lt;HttpServer::Request&gt; request) {\n    string content = \"Hello world!\"\n    *response &lt;&lt; \"HTTP/1.1 200 OK\\r\\nContent-Length: \" &lt;&lt; content.size() &lt;&lt; \"\\r\\n\\r\\n\" &lt;&lt; content;\n};\n\natomic_thread_fence(memory_order_release);\n\nserver_thread = thread([&amp;server]() {\n    atomic_thread_fence(memory_order_acquire);\n    server.start();\n});\n</code></pre>\n<p>Is my understanding correct, and are both the <code>atomic_thread_fence</code>s necessary?</p>\n", "AcceptedAnswerId": "41427432", "Title": "Are memory fences required here?", "CreationDate": "2017-01-02T12:58:05.390", "Id": "41427305", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-01-02T14:08:48.967", "Score": "2", "OwnerUserId": "1021959", "Tags": "<c++><multithreading><memory-barriers>", "AnswerCount": "1"}});