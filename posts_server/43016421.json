post_cb({"bq_ids": {"n4140": {"so_43016421_43016421_0": {"length": 56, "quality": 0.7466666666666667, "section_id": 6005}}, "n3337": {"so_43016421_43016421_0": {"length": 56, "quality": 0.7466666666666667, "section_id": 5773}}, "n4659": {"so_43016421_43029686_0": {"length": 36, "quality": 0.8372093023255814, "section_id": 15}, "so_43016421_43016421_0": {"length": 61, "quality": 0.8133333333333334, "section_id": 7504}}}, "43029686": {"Id": "43029686", "PostTypeId": "2", "Body": "<p>Bear in mind that prvalues can be converted to xvalues via a temporary materialization conversion [conv.rval]:</p>\n<blockquote>\n<p id=\"so_43016421_43029686_0\">A prvalue of type <code>T</code> can be converted to an xvalue of type <code>T</code>. This conversion initializes a temporary object (15.2) of type <code>T</code> from the prvalue by evaluating the prvalue with the temporary object as its result\n  object, and produces an xvalue denoting the temporary object. <code>T</code> shall be a complete type. [<em>Note</em>: If <code>T</code> is a class type (or array thereof), it must have an accessible and non-deleted destructor; see 15.4. \u2014 <em>end note</em>] [<em>Example</em>:</p>\n<pre><code>struct X { int n; };\nint k = X().n;\n// OK, X() prvalue is converted to xvalue\n</code></pre>\n<p id=\"so_43016421_43029686_1\">\u2014 <em>end example</em>]</p>\n</blockquote>\n<p>Prior to the introduction of this new prvalue-to-glvalue conversion, C++14 did not have the restriction for the <em>postfix-expression</em> to be a glvalue.</p>\n<p>On that note, C++11 was the first revision to feature user-definable, unconstrained rvalue-to-lvalue conversions by means of the (then-)new rvalue reference type: <code>auto&amp;&amp; x = f();</code> makes the prvalue <code>f()</code> into an xvalue <code>x</code>.</p>\n", "LastActivityDate": "2017-03-26T13:59:37.583", "CommentCount": "8", "CreationDate": "2017-03-26T13:59:37.583", "ParentId": "43016421", "Score": "3", "OwnerUserId": "596781"}, "43016421": {"ViewCount": "132", "Body": "<p><a href=\"http://eel.is/c++draft/expr.ref#2\" rel=\"nofollow noreferrer\">[expr.ref]/2</a>:</p>\n<blockquote>\n<p id=\"so_43016421_43016421_0\">For the first option (dot) the first expression shall be a glvalue\n  having complete class type. For the second option (arrow) the first\n  expression shall be a prvalue having pointer to complete class type.\n  The expression E1-&gt;E2 is converted to the equivalent form (*(E1)).E2;\n  the remainder of [expr.ref] will address only the first option\n  (dot).<sup>68</sup> In either case, the id-expression shall name a member of the\n  class or of one of its base classes. [\u2009Note: Because the name of a\n  class is inserted in its class scope (Clause [class]), the name of a\n  class is also considered a nested member of that class. \u2009\u2014\u2009end note\u2009]\n  [\u2009Note: [basic.lookup.classref] describes how names are looked up\n  after the . and -&gt; operators. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>According to this paragraph, the lvalue-to-rvalue conversion is applied to <code>p</code> in the snippet below. But it is not applied to <code>a</code>. Why does the standard prescribe a glvalue for the first option (dot) and a prvalue for the second option (arrow)?</p>\n<pre><code>struct A{ void f() {} };\nA a;\nA* p = new A;\nint main() {\n    a.f();\n    p-&gt;f();\n}\n</code></pre>\n", "AcceptedAnswerId": "43029686", "Title": "Lvalue-to-rvalue conversion in [expr.ref]/2", "CreationDate": "2017-03-25T12:38:39.990", "Id": "43016421", "CommentCount": "11", "LastEditDate": "2017-03-25T18:10:54.693", "PostTypeId": "1", "LastEditorUserId": "5479741", "LastActivityDate": "2017-03-26T13:59:37.583", "Score": "0", "OwnerUserId": "5479741", "Tags": "<c++><language-lawyer><c++1z><lvalue-to-rvalue>", "AnswerCount": "1"}});