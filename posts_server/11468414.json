post_cb({"11468500": {"ParentId": "11468414", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You cannot use the capture feature from lambda when calling a simple function pointer. The standard states that a lambda function without a capture is convertible to a function pointer, though:</p>\n<blockquote>\n<p id=\"so_11468414_11468500_0\">5.1.2 (6) The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const\n  conversion function to pointer to function having the same parameter and return types as the closure type\u2019s\n  function call operator. The value returned by this conversion function shall be the address of a function\n  that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>For instance, this works:</p>\n<pre><code>signal(SIGTERM, [](int signum) { /* ... */ });\n</code></pre>\n<p>But not this:</p>\n<pre><code>signal(SIGTERM, [foo](int signum) { /* use foo here */ });\n</code></pre>\n<p>You could actually keep <code>sockfd1</code> and <code>sockfd2</code> as global variables and then, you could use them in the lambda function. But that is clearly not a good design. So it is better to use a <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\">RAII</a> design. And if the program is terminated the sockets will be closed anyway (as @Dani is pointing out).</p>\n", "OwnerUserId": "1135819", "LastEditorUserId": "1135819", "LastEditDate": "2012-07-13T12:37:34.410", "Id": "11468500", "Score": "13", "CreationDate": "2012-07-13T10:15:36.460", "LastActivityDate": "2012-07-13T12:37:34.410"}, "11468546": {"ParentId": "11468414", "CommentCount": "0", "Body": "<p>Sockets will always be closed when a program is closed, no need to worry about it.<br>\nIf you worry about logical resource handling, put it in destructors, but those won't be called when the user presses CTRL-C</br></p>\n", "OwnerUserId": "362589", "PostTypeId": "2", "Id": "11468546", "Score": "0", "CreationDate": "2012-07-13T10:18:58.920", "LastActivityDate": "2012-07-13T10:18:58.920"}, "bq_ids": {"n4140": {"so_11468414_11468500_0": {"section_id": 5965, "quality": 0.926829268292683, "length": 38}}, "n3337": {"so_11468414_11468500_0": {"section_id": 5734, "quality": 0.926829268292683, "length": 38}}, "n4659": {"so_11468414_11468500_0": {"section_id": 7456, "quality": 0.8292682926829268, "length": 34}}}, "11468414": {"CommentCount": "0", "ViewCount": "2715", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2012-07-13T10:10:02.907", "LastActivityDate": "2012-07-13T12:37:34.410", "Title": "Using Auto and Lambda to handle Signal?", "AcceptedAnswerId": "11468500", "LastEditDate": "2012-07-13T11:07:09.143", "Id": "11468414", "Score": "9", "Body": "<p>I have written this program that has a main function, inside which, I am creating two sockets, like this:</p>\n<pre><code>int sockfd1 = socket(AF_INET, SOCK_STREAM, 0);\nint sockfd2 = socket(AF_INET, SOCK_STREAM, 0);\n</code></pre>\n<p>Now I do some stuff with them, and when the user presses Ctrl+C to terminate the process, I want to make sure the sockets close properly, so I do this:</p>\n<pre><code>auto sigTermHandler = [&amp;] (int param) { close(sockfd1); close(sockfd2); };\nsignal(SIGTERM, sigTermHandler);\n</code></pre>\n<p>But this throws the following compilation error when compiled as <code>g++ -std=gnu++0x &lt;filename&gt;.cpp</code>:</p>\n<pre><code>error: cannot convert \u2018main(int, char**)::&lt;lambda(int)&gt;\u2019 to \u2018__sighandler_t {aka void (*)(int)}\u2019 for argument \u20182\u2019 to \u2018void (* signal(int, __sighandler_t))(int)\u2019\n</code></pre>\n<p>Is it not possible to use lambda this way to handle signals? Please advise.</p>\n<p>P.S. I know I could put that in a destructor, if I did proper OOP, but I am curious to see if this works.</p>\n", "Tags": "<c++><lambda><c++11><signals><posix>", "OwnerUserId": "1062484", "AnswerCount": "2"}});