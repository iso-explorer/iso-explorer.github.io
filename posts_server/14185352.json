post_cb({"bq_ids": {"n4140": {"so_14185352_14185499_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 24}, "so_14185352_14185499_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5469}}, "n3337": {"so_14185352_14185499_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5255}, "so_14185352_14185499_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 21}}, "n4659": {"so_14185352_14185499_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6903}, "so_14185352_14185499_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 24}}}, "14185499": {"Id": "14185499", "PostTypeId": "2", "Body": "<p>It's a compiler bug. According to \u00a77.2/9 and \u00a74.5/4:</p>\n<blockquote>\n<p id=\"so_14185352_14185499_0\">\u00a77.2/9:<br>\n  The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by integral promotion (4.5)  </br></p>\n<p id=\"so_14185352_14185499_1\">\u00a74.5/4:<br>\n  A prvalue of an unscoped enumeration type whose underlying type is \ufb01xed (7.2) can be converted to a prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is \ufb01xed can also be converted to a prvalue of the promoted underlying type. </br></p>\n</blockquote>\n<p>The last one should convert to <code>long long</code>, not <code>int</code>. <a href=\"https://stackoverflow.com/questions/14206403/why-does-a-value-of-an-enum-with-a-fixed-underlying-type-of-char-resolve-to-fct\">The <code>char</code> case is a point of contention</a>. (!)</p>\n<hr>\n<p>Test program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum charEnum : char      { A = 'A' };\nenum longEnum : long long { Tera = 1000000000000 };\n\nvoid fct(char val)      { std::cout &lt;&lt; \"fct(char)\"      &lt;&lt; std::endl; }\nvoid fct(int val)       { std::cout &lt;&lt; \"fct(int)\"       &lt;&lt; std::endl; }\nvoid fct(long long val) { std::cout &lt;&lt; \"fct(long long)\" &lt;&lt; std::endl; }\n\nint main() \n{\n    static_assert(sizeof(A)    == sizeof(char),      \"check charEnum size\");\n    static_assert(sizeof(Tera) == sizeof(long long), \"check longEnum size\");\n\n    fct('A');\n    fct(1);\n    fct(2ll);\n    fct(A);\n    fct(Tera);\n    fct((long long)Tera);\n}\n</code></pre>\n<p>MSVC2012NovCTP output:</p>\n<blockquote>\n<p id=\"so_14185352_14185499_2\">fct(char)<br>\n  fct(int)<br>\n  fct(long long)<br>\n  fct(int)<br>\n  fct(int)<br>\n  fct(long long)  </br></br></br></br></br></p>\n</blockquote>\n<p>g++ 4.7.1:</p>\n<blockquote>\n<p id=\"so_14185352_14185499_3\">fct(char)<br>\n  fct(int)<br>\n  fct(long long)<br>\n  fct(int)<br>\n  fct(long long)<br>\n  fct(long long)  </br></br></br></br></br></p>\n</blockquote>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-09T20:52:13.863", "Score": "8", "CreationDate": "2013-01-06T18:47:14.507", "ParentId": "14185352", "CommentCount": "9", "LastEditDate": "2017-05-23T11:48:59.200", "OwnerUserId": "87234"}, "14185352": {"ViewCount": "1033", "Body": "<p>C++11 introduced strongly typed enums, with the syntax <code>enum class</code>. These are not compatible with integer types and require explicit casts to obtain their numeric value. C++11 also introduces the ability to specify the storage class for weakly typed enums with the form <code>enum name : type {}</code>. This is fine up to here.</p>\n<p>But it looks like even if an weakly typed enum has a given storage class, the type of its items is still <code>int</code>. I tried with Visual Studio 2012, November CTP release. Consider the following code:</p>\n<pre><code>enum charEnum : char { A = 'A' };\nenum longEnum : long long { Tera = 1000000000000 };\n\nvoid fct(char val) {}\nvoid fct(int val) {}\nvoid fct(long long val) {}\n\nint main() \n{\n    static_assert(sizeof(A) == sizeof(char), \"check charEnum size\");\n    static_assert(sizeof(Tera) == sizeof(long long), \"check longEnum size\");\n    fct('A');  // calls fct(char)\n    fct(1);    // calls fct(int)\n    fct(2ll);  // calls fct(long long)\n    fct(A);    // calls fct(int) !\n    fct(Tera); // calls fct(int), with truncation !\n    fct((long long)Tera);  // calls fct(long long)\n    return 0;\n}\n</code></pre>\n<p>The overloaded function called for an enumeration value is always <code>fct(int)</code>, even if this results in a truncation of the value. Of course, with an explicit cast, we can call the overloaded function, but this was also possible in traditional C++03 syntax.</p>\n<p>Am I missing something obvious? Why is that? Is there a better workaround than an explicit cast?</p>\n", "AcceptedAnswerId": "14185499", "Title": "Underlying type of weak typed enum in C++11", "CreationDate": "2013-01-06T18:31:53.857", "Id": "14185352", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-06T18:51:18.753", "LastEditorUserId": "1008957", "LastActivityDate": "2013-01-09T20:52:13.863", "Score": "11", "OwnerUserId": "1008957", "Tags": "<c++><c++11>", "AnswerCount": "1"}});