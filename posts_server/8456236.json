post_cb({"8456236": {"ViewCount": "15236", "Body": "<p>If I want to process data in a <code>std::vector</code> with SSE, I need 16 byte alignment. How can I achieve that? Do I need to write my own allocator? Or does the default allocator already align to 16 byte boundaries?</p>\n", "AcceptedAnswerId": "8456491", "Title": "How is a vector's data aligned?", "CreationDate": "2011-12-10T11:38:29.970", "Id": "8456236", "CommentCount": "3", "FavoriteCount": "14", "PostTypeId": "1", "LastActivityDate": "2017-08-26T05:28:49.060", "Score": "30", "OwnerUserId": "252000", "Tags": "<c++><vector><alignment><sse><allocator>", "AnswerCount": "8"}, "8456253": {"Id": "8456253", "PostTypeId": "2", "Body": "<p>The Standard mandates that <code>new</code> and <code>new[]</code> return data aligned for <em>any</em> data type, which should include SSE. Whether or not MSVC actually follows that rule is another question.</p>\n", "LastActivityDate": "2011-12-10T11:41:10.343", "CommentCount": "7", "CreationDate": "2011-12-10T11:41:10.343", "ParentId": "8456236", "Score": "-1", "OwnerUserId": "298661"}, "8457115": {"Id": "8457115", "PostTypeId": "2", "Body": "<p>Write your own allocator. <code>allocate</code> and <code>deallocate</code> are the important ones. Here is one example:</p>\n<pre><code>pointer allocate( size_type size, const void * pBuff = 0 )\n{\n    char * p;\n\n    int difference;\n\n    if( size &gt; ( INT_MAX - 16 ) )\n        return NULL;\n\n    p = (char*)malloc( size + 16 );\n\n    if( !p )\n        return NULL;\n\n    difference = ( (-(int)p - 1 ) &amp; 15 ) + 1;\n\n    p += difference;\n    p[ -1 ] = (char)difference;\n\n    return (T*)p;\n}\n\nvoid deallocate( pointer p, size_type num )\n{\n    char * pBuffer = (char*)p;\n\n    free( (void*)(((char*)p) - pBuffer[ -1 ] ) );\n}\n</code></pre>\n", "LastActivityDate": "2011-12-10T14:17:14.657", "CommentCount": "3", "CreationDate": "2011-12-10T14:17:14.657", "ParentId": "8456236", "Score": "3", "OwnerUserId": "1090249"}, "8456491": {"Id": "8456491", "PostTypeId": "2", "Body": "<p>C++ standard requires allocation functions (<code>malloc()</code> and <code>operator new()</code>) to allocate memory suitably aligned for any <em>standard</em> type. As these functions don't receive the alignment requirement as an argument, on practice it means that the alignment for all allocations is the same and is the alignment of a standard type with the largest alignment requirement, which often is <code>long double</code> and/or <code>long long</code> (see <a href=\"http://www.boost.org/doc/libs/1_46_0/boost/type_traits/type_with_alignment.hpp\">boost max_align union</a>).</p>\n<p>Vector instructions, such as SSE and AVX, have stronger alignment requirements (16-byte aligned for 128-bit access and 32-byte aligned for 256-bit access) than that provided by the standard C++ allocation functions. <code>posix_memalign()</code> or <code>memalign()</code> can be used to satisfy such allocations with stronger alignment requirements.</p>\n", "LastActivityDate": "2011-12-10T12:27:53.280", "CommentCount": "0", "CreationDate": "2011-12-10T12:27:53.280", "ParentId": "8456236", "Score": "14", "OwnerUserId": "412080"}, "8456251": {"Id": "8456251", "PostTypeId": "2", "Body": "<p>Don't assume anything about STL containers. Their interface/behaviour is defined, but not what's behind them. If you need raw access, you'll have to write your own implementation that follows the rules you'd like to have.</p>\n", "LastActivityDate": "2011-12-10T11:40:32.973", "CommentCount": "5", "CreationDate": "2011-12-10T11:40:32.973", "ParentId": "8456236", "Score": "1", "OwnerUserId": "409744"}, "45833474": {"Id": "45833474", "PostTypeId": "2", "Body": "<p>Instead of writing your own allocator, as <a href=\"https://stackoverflow.com/a/8545389/8414561\">suggested before</a>, you can use <a href=\"http://www.boost.org/doc/libs/1_65_0/boost/align/aligned_allocator.hpp\" rel=\"nofollow noreferrer\"><code>boost::alignment::aligned_allocator</code></a> for <code>std::vector</code> like this:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;boost/align/aligned_allocator.hpp&gt;\n\ntemplate &lt;typename T&gt;\nusing aligned_vector = std::vector&lt;T, boost::alignment::aligned_allocator&lt;T, 16&gt;&gt;;\n</code></pre>\n", "LastActivityDate": "2017-08-23T07:37:38.283", "CommentCount": "0", "CreationDate": "2017-08-23T07:37:38.283", "ParentId": "8456236", "Score": "3", "OwnerUserId": "8414561"}, "bq_ids": {"n4140": {"so_8456236_8458776_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 7243}, "so_8456236_8458776_2": {"length": 32, "quality": 0.8648648648648649, "section_id": 6097}, "so_8456236_8458776_1": {"length": 23, "quality": 1.0, "section_id": 7244}, "so_8456236_8458776_3": {"length": 27, "quality": 0.9310344827586207, "section_id": 7241}}, "n3337": {"so_8456236_8458776_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6987}, "so_8456236_8458776_2": {"length": 32, "quality": 0.8648648648648649, "section_id": 5863}, "so_8456236_8458776_1": {"length": 23, "quality": 1.0, "section_id": 6988}, "so_8456236_8458776_3": {"length": 27, "quality": 0.9310344827586207, "section_id": 6985}}, "n4659": {"so_8456236_8458776_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 8752}, "so_8456236_8458776_2": {"length": 31, "quality": 0.8378378378378378, "section_id": 7594}, "so_8456236_8458776_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 8753}, "so_8456236_8458776_3": {"length": 26, "quality": 0.896551724137931, "section_id": 8750}}}, "8458776": {"Id": "8458776", "PostTypeId": "2", "Body": "<h2>Short Answer:</h2>\n<p>If <code>sizeof(T)*vector.size() &gt; 16</code> then Yes.<br>\n<sub>Assuming you vector uses normal allocators</sub></br></p>\n<p>Caveat: As long as <code>alignof(std::max_align_t) &gt;= 16</code> as this is the max alignment.</p>\n<h2>Long Answer:</h2>\n<p>Updated 25/Aug/2017 new standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">n4659</a></p>\n<p>If it is aligned for anything that is greater than 16 it is also aligned correctly for 16.</p>\n<h3>6.11 Alignment (Paragraph 4/5)</h3>\n<blockquote>\n<p id=\"so_8456236_8458776_0\">Alignments are represented as values of the type std::size_t. Valid alignments include only those values returned by an alignof expression for the fundamental types plus an additional implementation-defined set of values, which may be empty. Every alignment value shall be a non-negative integral power of two.</p>\n<p id=\"so_8456236_8458776_1\">Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement.</p>\n</blockquote>\n<p>new and new[] return values that are aligned so that objects are correctly aligned for their size:</p>\n<h3>8.3.4 New (paragraph 17)</h3>\n<blockquote>\n<p id=\"so_8456236_8458776_2\">[ Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage in which space for the object has been reserved. The block of storage is assumed to be appropriately aligned and of the requested size. The address of the created object will not necessarily be the same as that of the block if the object is an array. \u2014 end note ]</p>\n</blockquote>\n<p>Note most systems have a maximum alignment. Dynamically allocated memory does not need to be aligned to a value greater than this.</p>\n<h3>6.11 Alignment (paragraph 2)</h3>\n<blockquote>\n<p id=\"so_8456236_8458776_3\">A fundamental alignment is represented by an alignment less than or equal to the greatest alignment supported\n  by the implementation in all contexts, which is equal to alignof(std::max_align_t) (21.2). The alignment\n  required for a type might be different when it is used as the type of a complete object and when it is used as\n  the type of a subobject. </p>\n</blockquote>\n<p>Thus as long as your vector memory allocated is greater than 16 bytes it will be correctly aligned on 16 byte boundaries.</p>\n", "LastEditorUserId": "14065", "LastActivityDate": "2017-08-26T05:28:49.060", "Score": "3", "CreationDate": "2011-12-10T18:18:32.203", "ParentId": "8456236", "CommentCount": "12", "OwnerUserId": "14065", "LastEditDate": "2017-08-26T05:28:49.060"}, "8545389": {"Id": "8545389", "PostTypeId": "2", "Body": "<p>You should use a custom allocator with <code>std::</code> containers, such as <code>vector</code>. Can't remember who wrote the following one, but I used it for some time and it seems to work (you might have to change <code>_aligned_malloc</code> to <code>_mm_malloc</code>, depending on compiler/platform):</p>\n<pre><code>#ifndef ALIGNMENT_ALLOCATOR_H\n#define ALIGNMENT_ALLOCATOR_H\n\n#include &lt;stdlib.h&gt;\n#include &lt;malloc.h&gt;\n\ntemplate &lt;typename T, std::size_t N = 16&gt;\nclass AlignmentAllocator {\npublic:\n  typedef T value_type;\n  typedef std::size_t size_type;\n  typedef std::ptrdiff_t difference_type;\n\n  typedef T * pointer;\n  typedef const T * const_pointer;\n\n  typedef T &amp; reference;\n  typedef const T &amp; const_reference;\n\n  public:\n  inline AlignmentAllocator () throw () { }\n\n  template &lt;typename T2&gt;\n  inline AlignmentAllocator (const AlignmentAllocator&lt;T2, N&gt; &amp;) throw () { }\n\n  inline ~AlignmentAllocator () throw () { }\n\n  inline pointer adress (reference r) {\n    return &amp;r;\n  }\n\n  inline const_pointer adress (const_reference r) const {\n    return &amp;r;\n  }\n\n  inline pointer allocate (size_type n) {\n     return (pointer)_aligned_malloc(n*sizeof(value_type), N);\n  }\n\n  inline void deallocate (pointer p, size_type) {\n    _aligned_free (p);\n  }\n\n  inline void construct (pointer p, const value_type &amp; wert) {\n     new (p) value_type (wert);\n  }\n\n  inline void destroy (pointer p) {\n    p-&gt;~value_type ();\n  }\n\n  inline size_type max_size () const throw () {\n    return size_type (-1) / sizeof (value_type);\n  }\n\n  template &lt;typename T2&gt;\n  struct rebind {\n    typedef AlignmentAllocator&lt;T2, N&gt; other;\n  };\n\n  bool operator!=(const AlignmentAllocator&lt;T,N&gt;&amp; other) const  {\n    return !(*this == other);\n  }\n\n  // Returns true if and only if storage allocated from *this\n  // can be deallocated from other, and vice versa.\n  // Always returns true for stateless allocators.\n  bool operator==(const AlignmentAllocator&lt;T,N&gt;&amp; other) const {\n    return true;\n  }\n};\n\n#endif\n</code></pre>\n<p>Use it like this (change the 16 to another alignment, if needed):</p>\n<pre><code>std::vector&lt;T, AlignmentAllocator&lt;T, 16&gt; &gt; bla;\n</code></pre>\n<hr>\n<p>This, however, only makes sure the memory block <code>std::vector</code> uses is 16-bytes aligned. If <code>sizeof(T)</code> is not a multiple of 16, some of your elements will not be aligned. Depending on your data-type, this might be a non-issue. If <code>T</code> is <code>int</code> (4 bytes), only load elements whose index is a multiple of 4. If it's <code>double</code> (8 bytes), only multiples of 2, etc.</p>\n<p>The real issue is if you use classes as <code>T</code>, in which case you will have to specify your alignment requirements in the class itself (again, depending on compiler, this might be different; the example is for GCC):</p>\n<pre><code>class __attribute__ ((aligned (16))) Foo {\n    __attribute__ ((aligned (16))) double u[2];\n};\n</code></pre>\n<p>We're almost done! If you use <strong>Visual C++</strong> (at least, version 2010), you won't be able to use an <code>std::vector</code> with classes whose alignment you specified, because of <code>std::vector::resize</code>.</p>\n<p>When compiling, if you get the following error:</p>\n<pre><code>C:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\vector(870):\nerror C2719: '_Val': formal parameter with __declspec(align('16')) won't be aligned\n</code></pre>\n<p>You will have to hack your <code>stl::vector header</code> file:</p>\n<ol>\n<li>Locate the <code>vector</code> header file [C:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\vector]</li>\n<li>Locate the <code>void resize( _Ty _Val )</code> method [line 870 on VC2010]</li>\n<li>Change it to <code>void resize( const _Ty&amp; _Val )</code>.</li>\n</ol>\n</hr>", "LastEditorUserId": "1071136", "LastActivityDate": "2012-09-19T15:45:55.843", "Score": "23", "CreationDate": "2011-12-17T14:28:34.990", "ParentId": "8456236", "CommentCount": "2", "OwnerUserId": "1071136", "LastEditDate": "2012-09-19T15:45:55.843"}, "31387394": {"Id": "31387394", "PostTypeId": "2", "Body": "<p>Use <code>declspec(align(x,y))</code> as explained in vectorization tutorial for Intel, <a href=\"http://d3f8ykwhia686p.cloudfront.net/1live/intel/CompilerAutovectorizationGuide.pdf\" rel=\"nofollow\">http://d3f8ykwhia686p.cloudfront.net/1live/intel/CompilerAutovectorizationGuide.pdf</a></p>\n", "LastActivityDate": "2015-07-13T15:26:49.853", "CommentCount": "0", "CreationDate": "2015-07-13T15:26:49.853", "ParentId": "8456236", "Score": "0", "OwnerUserId": "1141493"}});