post_cb({"bq_ids": {"n4140": {"so_27508872_27509330_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 705}}, "n3337": {"so_27508872_27509330_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 695}}, "n4659": {"so_27508872_27509330_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 734}}}, "27508950": {"Id": "27508950", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27508872_27508950_0\">If <code>std::list</code> is a linked list then why is there a limit on how many elements you can have?</p>\n</blockquote>\n<p>Because the <code>max_size()</code> function is a requirement for all standard containers.</p>\n<blockquote>\n<p id=\"so_27508872_27508950_1\">Each element is a link to a new node and there's no limit on how many pointers you can have.</p>\n</blockquote>\n<p>Yes there is: the size must be representable by <code>size_type</code>, so a limit is that type's maximum value. There's probably no reason for it to be less than that.</p>\n", "LastActivityDate": "2014-12-16T16:09:39.693", "CommentCount": "3", "CreationDate": "2014-12-16T16:09:39.693", "ParentId": "27508872", "Score": "6", "OwnerUserId": "204847"}, "27509330": {"Id": "27509330", "PostTypeId": "2", "Body": "<p>The simple answer is because the standard says so:</p>\n<p>23.2.1 Requirements for containers <code>Table 96 \u2014 Container requirements</code> p. 747 for <strong><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">N4296</a></strong>:</p>\n<blockquote>\n<p id=\"so_27508872_27509330_0\"><code>a.max_size()</code>; <code>size_type</code>; <code>distance(begin(),end())</code> for the largest possible container</p>\n</blockquote>\n<p>This, most probably, comes from the fact that in c++ algorithms separated from the containers. Algorithms are written as templates, so they basically duck type code, they expect some contracts to be fulfilled (i.e. providing some API). There are algorithms written for all containers so they expect whatever is passed as a container to implement full API, even if sometimes a particular method does not have much <em>theoretical</em> sense it must be implemented.</p>\n<p>That said, <em>technically</em> there is an upper bound anyway so it's good idea to use it in such cases. Funnily enough, it is practically impossible to hit the limit you get from <code>std::list::max_size()</code> (i.e. you would run OOM), yet alone the theoretical infinity.</p>\n", "LastEditorUserId": "1133179", "LastActivityDate": "2014-12-17T10:24:10.820", "Score": "1", "CreationDate": "2014-12-16T16:28:14.950", "ParentId": "27508872", "CommentCount": "0", "LastEditDate": "2014-12-17T10:24:10.820", "OwnerUserId": "1133179"}, "27509080": {"Id": "27509080", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27508872_27509080_0\">there's no limit on how many pointers you can have</p>\n</blockquote>\n<p>There's a limit on how many distinct pointer values there can possibly be, based on the size of a pointer. For example, if a pointer occupies 64 bits in a particular implementation, then <code>max_size()</code> could safely return 2<sup>64</sup>-1. In fact it could be rather less than this, since each linked list node will be bigger than 1 byte.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2014-12-16T16:23:21.523", "Score": "3", "CreationDate": "2014-12-16T16:15:51.933", "ParentId": "27508872", "CommentCount": "0", "LastEditDate": "2014-12-16T16:23:21.523", "OwnerUserId": "13005"}, "27508872": {"ViewCount": "1301", "Body": "<p>If <code>std::list</code> is a linked list then why is there a limit on how many elements you can have? Each element is a link to a new node and there's no limit on how many pointers you can have.</p>\n", "AcceptedAnswerId": "27508950", "Title": "Why does std::list have a max size?", "CreationDate": "2014-12-16T16:06:32.483", "Id": "27508872", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-12-17T10:24:10.820", "Score": "4", "OwnerUserId": "1594090", "Tags": "<c++>", "AnswerCount": "3"}});