post_cb({"20685327": {"CommentCount": "3", "ViewCount": "783", "CreationDate": "2013-12-19T15:20:28.903", "LastActivityDate": "2013-12-19T15:37:40.363", "Title": "Can I remove elements in the std::string object while iterating over it", "PostTypeId": "1", "Id": "20685327", "Score": "3", "Body": "<p>Can I remove elements in the std::string object while iterating over it?</p>\n<pre><code>for (auto itr = str.rbegin(), rend = str.rend(); itr != str.rend() &amp;&amp; *itr == '0'; ++itr)\n{\n    str.pop_back();\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "1608835", "AnswerCount": "5"}, "20685704": {"ParentId": "20685327", "CommentCount": "0", "Body": "<p>According to the standard any use of <code>s.erase()</code> on a <code>std::basic_string</code> invalidates all pointers, references, and iterators to <code>s</code>. The relevant section in the standard is 21.4.1 [string.require] paragraph 6:</p>\n<blockquote>\n<p id=\"so_20685327_20685704_0\">References, pointers, and iterators referring to the elements of a <code>basic_string</code> sequence may be invalidated by the following uses of that <code>basic_string</code> object:</p>\n<ul>\n<li>as an argument to anys tandard library function taking a reference to non-<code>const</code> <code>basic_string</code> as`an argument. </li>\n<li>Calling non-<code>const</code> member functions, except <code>operator[]</code>, <code>at</code>, <code>front</code>, <code>back</code>, <code>begin</code>, <code>rbegin</code>, <code>end</code>, and <code>rend</code>.</li>\n</ul>\n</blockquote>\n<p>The alterantive is to use the result or the <code>erase()</code> to get back a valid iterator to the current position. Alternatively, you might want to use <code>erase()</code> in combination with <code>std::remove_if()</code> to first reshuffle the string efficiently and then remove the actual content.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "20685704", "Score": "0", "CreationDate": "2013-12-19T15:37:40.363", "LastActivityDate": "2013-12-19T15:37:40.363"}, "20685447": {"ParentId": "20685327", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, that's not allowed. Modifying the contents of the string invalidates any iterators, particularly <code>itr</code>.</p>\n<p>To remove trailing characters from a string, consider using <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/find_last_not_of\" rel=\"nofollow\"><code>find_last_not_of</code></a>:</p>\n<pre><code>auto ix = str.find_last_not_of('0');\nstr.resize(ix + 1);\n</code></pre>\n<p>Another option is to use the <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/erase\" rel=\"nofollow\"><code>erase</code></a> function, which will return the next iterator in the sequence, thereby avoiding having any invalid iterators.</p>\n<pre><code>for (auto itr = str.rbegin(); itr != str.rend() &amp;&amp; *itr == '0'; /*nothing*/)\n  itr = str.erase(itr);\n</code></pre>\n<p>That will erase the last character (as <code>pop_back</code> would) and safely advance the iterator, so you never actually have an invalid iterator anymore. The caveat is that you cannot you the <code>rend</code> iterator that you were calculating before, because it would be invalid; however, you weren't actually using it anyway.</p>\n", "OwnerUserId": "33732", "LastEditorUserId": "33732", "LastEditDate": "2013-12-19T15:31:30.247", "Id": "20685447", "Score": "4", "CreationDate": "2013-12-19T15:26:10.617", "LastActivityDate": "2013-12-19T15:31:30.247"}, "20685603": {"ParentId": "20685327", "CommentCount": "0", "Body": "<p>You can remove elements as you iterate over the string, <em>but</em> you need to write your loop slightly differently to do it safely. In this case, we only really care about the last character in the string, so we can do something like this:</p>\n<pre><code>for (auto itr = str.rbegin(); \n          itr != str.rend() &amp;&amp; *itr == '0'; \n          itr=str.rbegin())\n{\n    str.pop_back();\n}\n</code></pre>\n<p>Even though <code>itr</code> may be invalidated when we do <code>pop_back</code> on the string, we're re-fetching the value of <code>str.rbegin()</code> every iteration, and that's guaranteed to give a valid reverse iterator every time we call it. What we have left no longer really makes good use of a <code>for</code> loop though--we might about as well use a <code>while</code> loop:</p>\n<pre><code>while (str.rbegin() != str.rend() &amp;&amp; *str.rbegin() == '0')\n    str.pop_back();\n</code></pre>\n<p>I think I'd rather write it something like:</p>\n<pre><code>while (!str.empty() &amp;&amp; *str.rbegin() == '0')\n    str.pop_back();\n</code></pre>\n<p>...or (using a slightly cleaner equivalent of <code>*str.rbegin()</code>:</p>\n<pre><code>while (!str.empty() &amp;&amp; str.back() == '0')\n    str.pop_back();\n</code></pre>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "20685603", "Score": "2", "CreationDate": "2013-12-19T15:33:22.293", "LastActivityDate": "2013-12-19T15:33:22.293"}, "20685569": {"ParentId": "20685327", "CommentCount": "0", "Body": "<p>According to the Scripture, Chapter 21.4.1, verse 6:</p>\n<blockquote>\n<p id=\"so_20685327_20685569_0\">6 References, pointers, and iterators referring to the elements of a\n  basic_string sequence may be invalidated by the following uses of that\n  basic_string object: </p>\n<p id=\"so_20685327_20685569_1\">\u2014 as an argument to any standard library function\n  taking a reference to non-const basic_string as an argument. </p>\n<p id=\"so_20685327_20685569_2\">\u2014 Calling non-const member functions, except operator[], at, front, back, begin,\n  rbegin, end, and rend.</p>\n</blockquote>\n<p>So I would say \"no, not using pop_back\".</p>\n<p>But you can of course use the <code>erase</code> overload that returns an iterator and use that iterator instead of the one you erased, as for other containers.</p>\n", "OwnerUserId": "404970", "PostTypeId": "2", "Id": "20685569", "Score": "1", "CreationDate": "2013-12-19T15:32:04.090", "LastActivityDate": "2013-12-19T15:32:04.090"}, "bq_ids": {"n4140": {"so_20685327_20685569_2": {"section_id": 1567, "quality": 1.0, "length": 12}, "so_20685327_20685569_0": {"section_id": 1567, "quality": 1.0, "length": 13}, "so_20685327_20685704_0": {"section_id": 1567, "quality": 1.0, "length": 13}, "so_20685327_20685569_1": {"section_id": 1567, "quality": 1.0, "length": 8}}, "n3337": {"so_20685327_20685569_2": {"section_id": 1562, "quality": 1.0, "length": 12}, "so_20685327_20685569_0": {"section_id": 1562, "quality": 1.0, "length": 13}, "so_20685327_20685704_0": {"section_id": 1562, "quality": 1.0, "length": 13}, "so_20685327_20685569_1": {"section_id": 1562, "quality": 1.0, "length": 8}}, "n4659": {"so_20685327_20685569_1": {"section_id": 1716, "quality": 1.0, "length": 8}, "so_20685327_20685569_2": {"section_id": 1716, "quality": 1.0, "length": 12}, "so_20685327_20685569_0": {"section_id": 1716, "quality": 1.0, "length": 13}, "so_20685327_20685704_0": {"section_id": 1716, "quality": 1.0, "length": 13}, "so_20685327_20685412_0": {"section_id": 1740, "quality": 0.625, "length": 5}}}, "20685412": {"ParentId": "20685327", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>According to reference of <code>string::pop_back</code> <a href=\"http://www.cplusplus.com/reference/string/string/pop_back/\" rel=\"nofollow\">http://www.cplusplus.com/reference/string/string/pop_back/</a></p>\n<blockquote>\n<p id=\"so_20685327_20685412_0\">Any iterators, pointers and references related to this object may be\n  invalidated.</p>\n</blockquote>\n<p>So I guess you cannot do this in a for loop with iterators.</p>\n<p>You do this:</p>\n<pre><code>while ( str.size() &gt; 0 &amp;&amp; str[ str.size()-1] == '0' ] )\n  str.pop_back();\n</code></pre>\n<p>Or you can carry out your for loop using counters instead of iterators.</p>\n", "OwnerUserId": "1990169", "LastEditorUserId": "1990169", "LastEditDate": "2013-12-19T15:33:21.440", "Id": "20685412", "Score": "2", "CreationDate": "2013-12-19T15:24:20.470", "LastActivityDate": "2013-12-19T15:33:21.440"}});