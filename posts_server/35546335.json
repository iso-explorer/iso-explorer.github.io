post_cb({"35546797": {"ParentId": "35546335", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-02-22T06:06:43.567", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:40.193", "Id": "35546797", "OwnerUserId": "3510736", "Body": "<blockquote>\n<p id=\"so_35546335_35546797_0\">for snippet 2, why the non-const copy constructor here is valid? why non-const copy constructor was called, rather than the const one.</p>\n</blockquote>\n<p>Consider your code for this question, but with the change below with the comment <code>// (*)</code>:</p>\n<pre><code>int main(){\n    const C c1; // (*) &lt;- See change here\n    C c2 = c1;\n    return 0;\n}\n</code></pre>\n<p>This calls the <code>const</code> copy ctor version. It really has nothing to do with the function happening to be a constructor - if a function has two overloads, one taking a reference, and one a <code>const</code> reference, then non-const objects will be called with the first, and <code>const</code> objects with the second.</p>\n<blockquote>\n<p id=\"so_35546335_35546797_1\">for snippet 3, I know that copy constructor must use const reference to avoid infinite recursion. But Here class C has got C(const C&amp; c), C(C c) won't cause infinite recursion, why it still doesn't work?</p>\n</blockquote>\n<p>Consider the following code, and note that there is no invocation going on (the content of <code>main</code> is pretty much erased).</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass C{\npublic:\n    C(){}\n    C(const C&amp; c){\n        cout&lt;&lt;\"const copy constructor called\"&lt;&lt;endl;\n    }\n    C(C c){\n        cout&lt;&lt;\"non-const copy constructor called.\\t \"&lt;&lt;endl;\n    }\n};\nint main(){\n// Note that nothing is creating C instances at all.\nreturn 0;\n}\n</code></pre>\n<p>This results in the exact same error - the compiler simply refuses to compile a class with this interface, regardless of whether something is attempting to call it or not. </p>\n<p>Quoting from an answer to <a href=\"https://stackoverflow.com/questions/2685854/why-should-the-copy-constructor-accept-its-parameter-by-reference-in-c\">this question</a> \"it's forbidden by the standard in \u00a712.8/3:</p>\n<blockquote>\n<p id=\"so_35546335_35546797_2\">A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv- qualified) X and either there are no other parameters or else all other parameters have default arguments.</p>\n</blockquote>\n<p>\"</p>\n", "LastActivityDate": "2016-02-22T06:06:43.567"}, "35546705": {"ParentId": "35546335", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-02-22T06:00:13.830", "Score": "7", "LastEditorUserId": "3763293", "LastEditDate": "2016-02-22T10:26:35.080", "Id": "35546705", "OwnerUserId": "3763293", "Body": "<p><strong>Snippet 1</strong>: One standard copy constructor with <code>const T&amp;</code>. Happy world. </p>\n<p><strong>Snippet 2</strong>:</p>\n<p>What you have effectively done is overloaded the copy constructor - one that takes a reference <code>T&amp;</code> and the other that takes a constant reference <code>const T&amp;</code>. </p>\n<p>Please note: Any constructor for a class T that has one mandatory argument of type <code>T &amp;</code> or <code>const T &amp;</code> (it may also have further, defaulted arguments) is a copy constructor.</p>\n<p>So, for the compiler, it all just boils down to finding the <strong>Best Fit</strong> for overload resolution and it is done as:</p>\n<blockquote>\n<p id=\"so_35546335_35546705_0\">Standard conversion sequence S1 is a better conversion sequence than\n  standard conversion sequence S2 if:</p>\n<ul>\n<li>....</li>\n<li>S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same type except for top-level cv-qualifiers,\n  and the type to which the reference initialized by S2 refers is more\n  cv-qualified than the type to which the reference initialized by S1\n  refers.</li>\n</ul>\n</blockquote>\n<p>So writing </p>\n<pre><code>C c1;\nC c2 = c1;\n</code></pre>\n<p>will call the non-const copy constructor since it is a better match, but,</p>\n<p>writing,</p>\n<pre><code>const C c1;\nC c2 = c1;\n</code></pre>\n<p>will call the const copy constructor (you can check) since now the copy constructor with const is the only viable match.</p>\n<p>Snippet 3 is just plain wrong for the compiler. </p>\n<pre><code>C(C c){\n        cout&lt;&lt;\"non-const copy constructor called.\\t \"&lt;&lt;endl;\n    }\n</code></pre>\n<p>You can't have a method with a signature <code>C(C c)</code>. The compiler thinks that you are trying to write a copy constructor and missed writing the <code>&amp;</code> and hence reports the error. Remove it and it works fine. </p>\n<p>@Unless you have a very good reason, <strong>never ever use <code>C(C&amp; c)</code> for your copy constructor. Don't skip <code>const</code></strong> because mutating the object from which you are making a copy doesn't make much sense.</p>\n", "LastActivityDate": "2016-02-22T10:26:35.080"}, "35546335": {"CommentCount": "0", "ViewCount": "198", "CreationDate": "2016-02-22T05:26:39.487", "LastActivityDate": "2016-02-22T10:26:35.080", "Title": "what if C++ class contains both const reference and non-const reference copy constructor?", "AcceptedAnswerId": "35546705", "PostTypeId": "1", "Id": "35546335", "Score": "4", "Body": "<p><strong>snippet 1:</strong></p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass C{\npublic:\n    C(){}\n    C(const C&amp; c){\n        cout&lt;&lt;\"const copy constructor called\"&lt;&lt;endl;\n    }\n};\nint main(){\n    C c1;\n    C c2 = c1;\n    return 0;\n}\n</code></pre>\n<p><strong>output</strong>: const copy constructor called</p>\n<hr>\n<p>snippet 2:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass C{\npublic:\n    C(){}\n    C(const C&amp; c){\n        cout&lt;&lt;\"const copy constructor called\"&lt;&lt;endl;\n    }\n    C(C&amp; c){\n        cout&lt;&lt;\"non-const copy constructor called.\\t \"&lt;&lt;endl;\n    }\n};\nint main(){\n    C c1;\n    C c2 = c1;\n    return 0;\n}\n</code></pre>\n<p><strong>output</strong>: non-const copy constructor called</p>\n<hr>\n<p>snippet 3:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass C{\npublic:\n    C(){}\n    C(const C&amp; c){\n        cout&lt;&lt;\"const copy constructor called\"&lt;&lt;endl;\n    }\n    C(C c){\n        cout&lt;&lt;\"non-const copy constructor called.\\t \"&lt;&lt;endl;\n    }\n};\nint main(){\n    C c1;\n    C c2 = c1;\n    return 0;\n}\n</code></pre>\n<p><strong>output</strong>: error: copy constructor must pass its first argument by reference</p>\n<hr>\n<p>I am so confused about:</p>\n<ol>\n<li>for snippet 2, why the non-const copy constructor here is valid? why non-const copy constructor was called, rather than the const one.</li>\n<li>for snippet 3, I know that copy constructor must use const reference to avoid infinite recursion. But Here class C has got <code>C(const C&amp; c)</code>, <code>C(C c)</code> won't cause infinite recursion, why it still doesn't work?</li>\n</ol>\n</hr></hr></hr>", "Tags": "<c++><copy-constructor><const-reference>", "OwnerUserId": "5432806", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_35546335_35546797_2": {"section_id": 455, "quality": 0.9523809523809523, "length": 20}, "so_35546335_35546705_0": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_35546335_35546705_0": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}, "so_35546335_35546797_2": {"section_id": 446, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_35546335_35546705_0": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}, "so_35546335_35546797_2": {"section_id": 478, "quality": 0.9523809523809523, "length": 20}}}});