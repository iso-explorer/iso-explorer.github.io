post_cb({"29991776": {"Id": "29991776", "PostTypeId": "2", "Body": "<p>Use a helper function:</p>\n<pre><code>class b\n{\n    a x;\n    b() : x(complicated_computation()) { }\nprivate:\n    static int complicated_computation() {\n        return result_of_complicated_computations;\n    }\n};\n</code></pre>\n<p>And the default-constructor isn't deleted, but undeclared.</p>\n", "LastActivityDate": "2015-05-01T17:23:41.850", "Score": "4", "CreationDate": "2015-05-01T17:23:41.850", "ParentId": "29991719", "CommentCount": "0", "OwnerUserId": "701092"}, "29991719": {"ViewCount": "192", "Body": "<p>In C++, if I want to have a member of a class that has no default constructor, I need to explicitly initialize it like this:</p>\n<pre><code>class a\n{\n   a(int)\n   {\n   }\n};\n\nclass b\n{\n   a x;\n\n   b() : x(3)\n   {\n   }\n};\n</code></pre>\n<p>However, sometimes the initialization for, say, x, could not be so simple. It could either be a very very complicated formula or a whole, algorithmic function with fors and ifs that needs to be computed. I usually solve it like this:</p>\n<pre><code>class b\n{\n   a * x;\n   b()\n   {\n      // Do some very complicated computations\n      this-&gt;x = new a(result_of_complicated_computations);\n   }\n};\n</code></pre>\n<p>Which, however, forces me to delete the pointer at the moment of destruction, it slightly less performing and makes my code somehow untidy and ugly. I am really surprised that there is no way to compute parameters for constructors of members within the constructor of the class, without having to use this kind of tricks.</p>\n<p>Are there more elegant solutions to this?</p>\n", "AcceptedAnswerId": "29991776", "Title": "Initialize members with deleted default constructor", "CreationDate": "2015-05-01T17:20:53.217", "Id": "29991719", "CommentCount": "2", "LastEditDate": "2015-05-01T17:27:10.963", "PostTypeId": "1", "LastEditorUserId": "635608", "LastActivityDate": "2015-05-01T17:27:10.963", "Score": "-1", "OwnerUserId": "774236", "Tags": "<c++><constructor><member><default-constructor>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29991719_29991820_1": {"length": 30, "quality": 0.967741935483871, "section_id": 441}}, "n3337": {"so_29991719_29991820_1": {"length": 30, "quality": 0.967741935483871, "section_id": 432}}, "n4659": {"so_29991719_29991820_1": {"length": 28, "quality": 0.9032258064516129, "section_id": 461}}}, "29991820": {"Id": "29991820", "PostTypeId": "2", "Body": "<p>I don't get it. If you have:</p>\n<pre><code>class A\n{\nprivate:\n    //a lot of members\n\npublic:\n    A(/* complex object used for construction */)\n    : //initialize members\n    { }\n}\n</code></pre>\n<p>You can simply do:</p>\n<pre><code>class B\n{\nprivate:\n    A a;\n\npublic:\n    B()\n    : a(call_to_function_that_generates_this_complex_data())\n    { }\n};\n</code></pre>\n<p>You can even use your member functions during construction. But note, that:</p>\n<blockquote>\n<p id=\"so_29991719_29991820_0\"><strong>\u00a7 12.6.2.13:</strong></p>\n<p id=\"so_29991719_29991820_1\">Member functions (including virtual member functions,\n  10.3) can be called for an object under construction.(...) However, if these operations are performed in a ctor-initializer (or in a function\n  called directly or indirectly from a ctor-initializer) before all the\n  mem-initializers for base classes have completed, the result of the\n  operation is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2015-05-01T17:26:39.633", "Score": "0", "CreationDate": "2015-05-01T17:26:39.633", "ParentId": "29991719", "CommentCount": "0", "OwnerUserId": "2812864"}, "29991784": {"Id": "29991784", "PostTypeId": "2", "Body": "<p>Do the computations in a function:</p>\n<pre><code>static a complicated_computations();\nb() : x(complicated_computations()) {}\n</code></pre>\n", "LastActivityDate": "2015-05-01T17:24:09.863", "Score": "0", "CreationDate": "2015-05-01T17:24:09.863", "ParentId": "29991719", "CommentCount": "0", "OwnerUserId": "204847"}});