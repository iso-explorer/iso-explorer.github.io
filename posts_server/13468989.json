post_cb({"bq_ids": {"n4140": {"so_13468989_13471654_0": {"length": 9, "quality": 1.0, "section_id": 5977}, "so_13468989_13468989_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5975}}, "n3337": {"so_13468989_13471654_0": {"length": 9, "quality": 1.0, "section_id": 5745}, "so_13468989_13468989_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5743}}, "n4659": {"so_13468989_13471654_0": {"length": 9, "quality": 1.0, "section_id": 7474}, "so_13468989_13468989_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7475}}}, "13471423": {"Id": "13471423", "PostTypeId": "2", "Body": "<p>First, I can confirm your observation with gcc 4.6.3 and clang 3.0 on Ubuntu 12.04.</p>\n<p>I don't have the C++11 standard (only draft), so I cannot comment on that. But look at the, from my understanding, equivalent statements</p>\n<pre><code>constexpr int i = 5;\nconst int &amp;j = i;\nstd::integral_constant&lt;int, j&gt;();\n</code></pre>\n<p>Neither gcc, nor clang compiles this, because <code>j</code> is not an \"integral constant\".</p>\n", "LastEditorUserId": "1741542", "LastActivityDate": "2012-11-20T11:50:18.970", "Score": "0", "CreationDate": "2012-11-20T10:39:04.897", "ParentId": "13468989", "CommentCount": "2", "OwnerUserId": "1741542", "LastEditDate": "2012-11-20T11:50:18.970"}, "13471654": {"Id": "13471654", "PostTypeId": "2", "Body": "<p>The second <em>template-argument</em> to <code>std::integral_constant&lt; int, i &gt;</code> is for a <em>template-parameter</em> of <em>non-type</em> form, specifically of <em>integral or enumeration type</em> (14.3.2p1 bullet 1) and so must be a converted constant expression of type <code>int</code>.</p>\n<p>In a <em>lambda-expression</em>, implicit capture occurs when an entity is odr-used in the compound statement (5.1.2p11); use of a converted constant expression in an explicit template instantiation is not odr-use (3.2p3), so the first example is valid.</p>\n<p>In the second example, I think gcc is incorrect to reject it; 5.1.2p17 says in a note that:</p>\n<blockquote>\n<p id=\"so_13468989_13471654_0\">An <em>id-expression</em> that is not an odr-use refers to the original entity, never to a member of the closure type.</p>\n</blockquote>\n<p>Although the paragraph as a whole is discussing capture by copy, there's no reason not to apply this rule to capture by reference as well.  It's unsurprising that the standard is unclear on this; there's really no reason to capture an entity that can be used in a converted constant expression by reference.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-11-20T11:00:18.063", "Score": "10", "CreationDate": "2012-11-20T10:52:34.627", "ParentId": "13468989", "CommentCount": "4", "OwnerUserId": "567292", "LastEditDate": "2012-11-20T11:00:18.063"}, "13468989": {"ViewCount": "878", "Body": "<p>GCC 4.7.2 compiles this:</p>\n<pre><code>constexpr int i = 5;\n[]{ std::integral_constant&lt; int, i &gt;(); }; // nonstandard: i not captured\n</code></pre>\n<p>but not this:</p>\n<pre><code>constexpr int i = 5;\n[&amp;i]{ std::integral_constant&lt; int, i &gt;(); }; // GCC says i not constexpr\n</code></pre>\n<p>The latter example appears correct to me, according to C++11 \u00a75.1.2/15:</p>\n<blockquote>\n<p id=\"so_13468989_13468989_0\">An entity is captured by reference if it is implicitly or explicitly captured but not captured by copy. It is unspecified whether additional unnamed non-static data members are declared in the closure type for entities captured by reference.</p>\n</blockquote>\n<p>It seems the captured object <code>i</code> inside the lambda refers to the variable in the enclosing scope, which is <code>constexpr</code>, not merely a <code>const</code> reference.</p>\n<p>The standard explicitly says that the use of a by-value capture is transformed into a use of the corresponding member of the lambda object. And I think that 5.1.2 hints that my interpretation is correct.</p>\n<p>Is there anything that explicitly says that whether a capture by reference refers to the object in the enclosing scope or a reference?</p>\n", "AcceptedAnswerId": "13471654", "Title": "Lambda capturing constexpr object", "CreationDate": "2012-11-20T08:13:57.143", "Id": "13468989", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-11-20T11:50:18.970", "Score": "17", "OwnerUserId": "153285", "Tags": "<c++><c++11><lambda><constexpr>", "AnswerCount": "2"}});