post_cb({"7570535": {"ParentId": "7568611", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This may be over-engineered compared the original question, but please consider:</p>\n<pre><code>template &lt;typename T, class C, int index=0&gt; \n// C and index just to avoid ambiguity\nclass constant_member {\n    const T m;\n    constant_member (T m_) :m(m_) {}\n};\n\nclass base : virtual public constant_member&lt;int, base&gt; {\npublic:\n    base () : constant_member&lt;int, base&gt;(5) {}\n    int x () const { return constant_member&lt;int, base&gt;::m; }\n};\n\nclass der : public base {\npublic:\n    der () : constant_member&lt;int, base&gt;(10) {}\n};\n\nclass der2 : public der{\npublic:\n    der2 () {} // ill-formed: no match for \n               // constant_member&lt;int, base&gt;::constant_member() \n};\n</code></pre>\n<p>Comment: This is verbose, non-obvious (maybe impossible to understand for beginners), and it will be very inefficient to convert to <code>virtual</code> base class just to read a member variable. I am <em>not</em> really suggesting this as a real world solution.</p>\n", "OwnerUserId": "963864", "LastEditorUserId": "963864", "LastEditDate": "2011-09-27T15:41:11.010", "Id": "7570535", "Score": "0", "CreationDate": "2011-09-27T14:08:48.693", "LastActivityDate": "2011-09-27T15:41:11.010"}, "7568611": {"CommentCount": "8", "ViewCount": "1509", "CreationDate": "2011-09-27T11:49:43.247", "LastActivityDate": "2011-09-27T15:41:11.010", "Title": "initialisation of const member of base class into derive class", "AcceptedAnswerId": "7568637", "PostTypeId": "1", "Id": "7568611", "Score": "2", "Body": "<pre><code>public:\n    const int x;\n    base():x(5){}\n\n};\n\nclass der : public base {\npublic:\n    der():x(10){}\n};\n\nder d;\n</code></pre>\n<p>My aim is when instance of base class is created it will initialise x as 5 and when instance of der class is created it will initialise x as 10. But compiler is giving error.\nAs x is inherited from class base, why is it giving error?</p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "966379", "AnswerCount": "4"}, "7568733": {"ParentId": "7568611", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>This works.</p>\n<pre><code>class base {\npublic:\n    static const int x = 5;\n};\n\nclass der : public base {\npublic:\n    static const int x = 10;\n};\n</code></pre>\n<p>If you want to change x depending on your constructor, you have to make it non-static.</p>\n<p>A non-static const is the same as a non-const variable once compiled. If you want to enforce a member variable to be read-only, use non-static const. If you want to set a constant whose scope is restricted to a single class, use static const. </p>\n", "OwnerUserId": "964135", "LastEditorUserId": "964135", "LastEditDate": "2011-09-27T12:30:19.947", "Id": "7568733", "Score": "1", "CreationDate": "2011-09-27T11:59:13.937", "LastActivityDate": "2011-09-27T12:30:19.947"}, "7568714": {"ParentId": "7568611", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You can make this work with a little adjustment...</p>\n<pre><code>#include &lt;cassert&gt;\n\nclass base\n{\npublic:\n    const int x;\n    base()\n        :x(5)\n    {\n    }\n\nprotected:\n    base(const int default_x)\n        :x(default_x)\n    {\n    }\n};\n\nclass der: public base\n{\npublic:\n    der()\n        :base(10)\n    {\n    }\n};\n\nstruct der2: public base\n{\n    der2()\n        :base()\n    {\n    }\n};\n\nint main()\n{\n    base b;\n    assert(b.x == 5);\n    der d;\n    assert(d.x == 10);\n    der2 d2;\n    assert(d2.x == 5);\n    return d.x;\n}\n</code></pre>\n<p>This provides a constructor, accessible by derived classes, that can provide a default value with which to initialise <code>base.x</code>.</p>\n", "OwnerUserId": "78845", "LastEditorUserId": "78845", "LastEditDate": "2011-09-27T12:08:45.873", "Id": "7568714", "Score": "7", "CreationDate": "2011-09-27T11:57:52.597", "LastActivityDate": "2011-09-27T12:08:45.873"}, "bq_ids": {"n4140": {"so_7568611_7568637_0": {"section_id": 429, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_7568611_7568637_0": {"section_id": 421, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_7568611_7568637_0": {"section_id": 447, "quality": 0.9285714285714286, "length": 13}}}, "7568637": {"ParentId": "7568611", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You can't initialize a base class member in the initializer list for a constructor in the derived class. The initializer list can contain bases, and members in this class, but not members in bases.</p>\n<p>Admittedly, the standardese for this isn't entirely clear. 12.6.2/2 of C++03:</p>\n<blockquote>\n<p id=\"so_7568611_7568637_0\">Unless the mem-initializer-id names a nonstatic data member of the\n  constructor\u2019s class or a direct or virtual base of that class, the\n  mem-initializer is ill-formed.</p>\n</blockquote>\n<p>It means \"(a nonstatic data member of the constructor's class) or (a direct or virtual base)\". It doesn't mean \"a nonstatic data member of (the constructor's class or a direct or virtual base)\". The sentence is ambiguous, but if you took the second reading then you couldn't put bases in the initializer-list at all, and the very next sentence in the standard makes it clear that you can.</p>\n<p>As for why it's not allowed, that's a standard rationale question and I'm guessing at the motives of the authors of the standard. But basically because it's the base class's responsibility to initialize its own members, not the derived class's responsibility.</p>\n<p>Probably you should add an <code>int</code> constructor to <code>base</code>.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2011-09-27T12:16:50.707", "Id": "7568637", "Score": "4", "CreationDate": "2011-09-27T11:52:09.493", "LastActivityDate": "2011-09-27T12:16:50.707"}});