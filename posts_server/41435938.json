post_cb({"bq_ids": {"n4140": {"so_41435938_41435938_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5356}}, "n3337": {"so_41435938_41435938_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5153}}, "n4659": {"so_41435938_41435938_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 6781}}}, "41444748": {"Id": "41444748", "PostTypeId": "2", "Body": "<p>@molbdnilo's answer is correct. To add one detail: Your intuition would be correct and the compiler would prefer to avoid the array-to-pointer conversion by calling the template. But lvalue transformations (lvalue-to-rvalue, array-to-pointer, and function-to-pointer) are specifically ignored in overload ranking, according to [over.ics.rank] \u00a713.3.3.2/3.2.1.</p>\n<p>There is a <a href=\"http://coliru.stacked-crooked.com/a/0f7a6f3a05922751\" rel=\"nofollow noreferrer\">workaround</a>: add a fake <code>volatile</code> to restore the balance of overload preference. Just be sure to remove it by <code>const_cast</code> before using the parameter.</p>\n", "LastActivityDate": "2017-01-03T13:35:26.837", "CommentCount": "0", "CreationDate": "2017-01-03T13:35:26.837", "ParentId": "41435938", "Score": "1", "OwnerUserId": "153285"}, "41436094": {"Id": "41436094", "PostTypeId": "2", "Body": "<p>It does behave as expected, you just need to adjust your expectations ;-)</p>\n<p><code>const char[1]</code> and <code>const char (&amp;)[1]</code> are different types.</p>\n<p>The conversions to <code>const char*</code> (array-to-pointer conversion) and <code>const (&amp;char)[1]</code> (identity conversion) are both considered exact matches, but a non-template is a better match than a template.</p>\n<p>If you write a non-template size-specific overload,</p>\n<pre><code>void f(const char (&amp;arg)[1])\n</code></pre>\n<p>you will get an error that the function call is ambiguous.   </p>\n", "LastEditorUserId": "404970", "LastActivityDate": "2017-01-03T13:07:26.410", "Score": "8", "CreationDate": "2017-01-03T03:39:39.707", "ParentId": "41435938", "CommentCount": "1", "OwnerUserId": "404970", "LastEditDate": "2017-01-03T13:07:26.410"}, "41435938": {"ViewCount": "197", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(const char* arg)\n{\n    cout &lt;&lt; \"arg is a pointer\" &lt;&lt; endl;\n}\n\ntemplate&lt;size_t N&gt;\nvoid f(const char (&amp;arg)[N])\n{\n    cout &lt;&lt; \"arg is an array.\" &lt;&lt; endl;\n}\n\nint main()\n{\n    f(\"\");\n}\n</code></pre>\n<p>My compiler is clang 3.8.</p>\n<p>The output is:</p>\n<blockquote>\n<p id=\"so_41435938_41435938_0\"><strong>arg is a pointer</strong></p>\n</blockquote>\n<p>However, according to <a href=\"http://en.cppreference.com/w/cpp/language/string_literal\" rel=\"nofollow noreferrer\">cppreference.com</a>,</p>\n<blockquote>\n<p id=\"so_41435938_41435938_1\">The type of an unprefixed string literal is const char[].</p>\n</blockquote>\n<p><strong>Why does the overload resolution not behave as expected?</strong></p>\n", "AcceptedAnswerId": "41436094", "Title": "Why does clang take a string literal as a pointer rather than an array?", "CreationDate": "2017-01-03T03:21:03.653", "Id": "41435938", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-01-03T13:35:26.837", "Score": "7", "OwnerUserId": "508343", "Tags": "<c++><overloading><standards><string-literals>", "AnswerCount": "2"}});