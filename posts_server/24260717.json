post_cb({"24260717": {"CommentCount": "8", "AcceptedAnswerId": "24266689", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-17T09:52:07.793", "LastActivityDate": "2014-06-17T14:40:11.697", "LastEditDate": "2017-05-23T12:23:12.783", "ViewCount": "993", "FavoriteCount": "8", "Title": "Does a vector assignment invalidate the `reserve`?", "Id": "24260717", "Score": "35", "Body": "<p>Suppose I write</p>\n<pre><code>std::vector&lt;T&gt; littleVector(1);\nstd::vector&lt;T&gt; bigVector;\n\nbigVector.reserve(100);\nbigVector = littleVector;\n</code></pre>\n<p>Does the standard say that <code>bigVector</code> will still have 100 elements reserved? Or would I experience memory reallocation if I were to <code>push_back</code> 99 elements? Perhaps it even varies between STL implementations.</p>\n<p>This was previously discussed <a href=\"https://stackoverflow.com/questions/2663170/stdvector-capacity-after-copying\">here</a> but no Standard references were given.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "3415258", "AnswerCount": "3"}, "24264274": {"ParentId": "24260717", "CommentCount": "4", "Body": "<p>This depends on the allocator traits.</p>\n<p>Here's an excerpt from <a href=\"http://en.cppreference.com/w/cpp/container/vector/operator%3D\">http://en.cppreference.com/w/cpp/container/vector/operator%3D</a>:</p>\n<blockquote>\n<p id=\"so_24260717_24264274_0\">If std::allocator_traits::propagate_on_container_copy_assignment() is true, the target allocator is replaced by a copy of the source allocator. If the target and the source allocators do not compare equal, the target (*this) allocator is used to deallocate the memory, then other's allocator is used to allocate it before copying the elements.(since C++11)</p>\n</blockquote>\n<p>Basically, the memory is reallocated with the new allocator, if the allocators are incompatible (if they cannot deallocate each-other's memory.</p>\n<p>It shouldn't matter between vector implementations, but between allocator implementations (which makes sense).</p>\n", "OwnerUserId": "186997", "PostTypeId": "2", "Id": "24264274", "Score": "6", "CreationDate": "2014-06-17T12:48:37.607", "LastActivityDate": "2014-06-17T12:48:37.607"}, "24265402": {"ParentId": "24260717", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The only requirement on <code>operator=</code> for standard containers is that afterwards, <code>src == dst</code>, as specified in Table 96 (in 23.2, General Container Requirements). Furthermore, the same table specifies the meaning of <code>operator ==</code>:</p>\n<pre><code>distance(lhs.begin(), lhs.end()) == distance(rhs.begin(), rhs.end()) // same size\n  &amp;&amp; equal(lhs.begin(), lhs.end(), rhs.begin()) // element-wise equivalent\n</code></pre>\n<p>Note that this doesn't include capacity in any way. Nor does any other part of the standard mention capacity beyond the general invariant that <code>capacity() &gt;= size()</code>. The value of capacity after assignment is therefore unspecified, and the container is free to implement assignment whichever way it wants, as long as allocator requirements are kept.</p>\n<hr>\n<p>In general, you will find that implementations behave such that</p>\n<ul>\n<li>if the allocators compare equal and dst has sufficient capacity, it will retain its old storage,</li>\n<li>otherwise it will allocate just enough storage for the new elements, and</li>\n<li>in no case will care what the capacity of src is.</li>\n</ul>\n<p>Of course, move assignment is a different story. Since it is generally implemented by stealing the source storage, the capacity will be taken as well.</p>\n</hr>", "OwnerUserId": "8922", "LastEditorUserId": "8922", "LastEditDate": "2014-06-17T14:02:02.843", "Id": "24265402", "Score": "9", "CreationDate": "2014-06-17T13:40:20.557", "LastActivityDate": "2014-06-17T14:02:02.843"}, "bq_ids": {"n4140": {"so_24260717_24266689_0": {"section_id": 972, "quality": 0.90625, "length": 29}}, "n3337": {"so_24260717_24266689_0": {"section_id": 961, "quality": 0.96875, "length": 31}}, "n4659": {"so_24260717_24266689_0": {"section_id": 1034, "quality": 0.90625, "length": 29}}}, "24266689": {"ParentId": "24260717", "CommentCount": "4", "Body": "<p>Unfortunately, the standard underspecifies behavior on allocator-aware sequence container assignment, and indeed is strictly speaking inconsistent.</p>\n<p>We know (from Table 28 and from 23.2.1p7) that if <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</code> is <code>true</code> then the allocator is replaced on copy assignment. Further, from Tables 96 and 99 we find that the <em>complexity</em> of copy assignment is <em>linear</em>, and the <em>post-condition</em> on operation <code>a = t</code> is that <code>a == t</code>, i.e. (Table 96) that <code>distance(a.begin(), a.end()) == distance(t.begin(), t.end()) &amp;&amp; equal(a.begin(), a.end(), t.begin())</code>. From 23.2.1p7, after copy assignment, if the allocator propagates, then <code>a.get_allocator() == t.get_allocator()</code>.</p>\n<p>With regard to vector capacity, 23.3.6.3 <strong>[vector.capacity]</strong> has:</p>\n<blockquote>\n<p id=\"so_24260717_24266689_0\">5 - <em>Remarks:</em> Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. It is guaranteed that no reallocation takes place during insertions that happen after a call to <code>reserve()</code> until the time when an insertion would make the size of the vector greater than the value of <code>capacity()</code>.</p>\n</blockquote>\n<p>If we take <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#341\">library DR341</a> as a guide to reading the Standard:</p>\n<blockquote>\n<p id=\"so_24260717_24266689_1\">However, the wording of 23.3.6.3 [vector.capacity]paragraph 5 prevents the capacity of a vector being reduced, following a call to reserve(). This invalidates the idiom, as swap() is thus prevented from reducing the capacity. [...]</p>\n</blockquote>\n<p>DR341 was resolved by adding paragraphs into 23.3.6.3:</p>\n<blockquote>\n<p id=\"so_24260717_24266689_2\"><code>void swap(vector&lt;T,Allocator&gt;&amp; x);</code><br/>\n  7 - <em>Effects:</em> Exchanges the contents and <code>capacity()</code> of <code>*this</code> with that of <code>x</code>.<br/>\n  8 - <em>Complexity:</em> Constant time.</p>\n</blockquote>\n<p>The conclusion is that from the point of view of the Library committee, operations only modify <code>capacity()</code> if mentioned under 23.3.6.3.  Copy assignment is not mentioned under 23.3.6.3, and thus does not modify <code>capacity()</code>.  (Move assignment has the same issue, especially considering the proposed resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2321\">Library DR2321</a>.)</p>\n<p>Clearly, this is a defect in the Standard, as copy assignment propagating unequal allocators <em>must</em> result in reallocation, contradicting 23.3.6.3p5.</p>\n<p>We can expect and hope this defect to be resolved in favour of:</p>\n<ul>\n<li>non-reduced <code>capacity()</code> on non-allocator-modifying copy assignment;</li>\n<li>unspecified <code>capacity()</code> on allocator-modifying copy assignment;</li>\n<li>non-reduced <code>capacity()</code> on non-allocator-propagating move assignment;</li>\n<li>source-container <code>capacity()</code> on allocator-propagating move assignment.</li>\n</ul>\n<p>However, in the current situation and until this is clarified you would do well not to depend on any particular behavior.  Fortunately, there is a simple workaround that is guaranteed not to reduce <code>capacity()</code>:</p>\n<pre><code>bigVector.assign(littleVector.begin(), littleVector.end());\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "24266689", "Score": "18", "CreationDate": "2014-06-17T14:40:11.697", "LastActivityDate": "2014-06-17T14:40:11.697"}});