post_cb({"32068177": {"ParentId": "32067643", "CommentCount": "0", "Body": "<p>You could perhaps use partial specialization for that (if the warning bothers you), with inspiration from boost <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/utility/enable_if.html\" rel=\"nofollow\"><code>enable_if</code></a>:</p>\n<pre><code>template &lt;bool, unsigned N&gt;\nstruct umask32 {\n    static const uint32_t val = (uint32_t(1) &lt;&lt; N) - 1;\n};\n\ntemplate &lt;unsigned N&gt;\nstruct umask32&lt;true, N&gt; {\n    static const uint32_t val = ~uint32_t(0);\n};\n\ntemplate &lt;unsigned N&gt;\nuint32_t mask(uint32_t x) {\n    const uint32_t MASK = umask32&lt;(N &gt;= 32), N&gt;::val;\n    return x &amp; MASK;\n}\n</code></pre>\n<p>If <code>N&gt;=32</code> the second <code>umask32</code> struct will be used and otherwise the first and consequently avoid the code where you shift by <code>&gt;=32</code> bits.</p>\n", "OwnerUserId": "4498329", "PostTypeId": "2", "Id": "32068177", "Score": "3", "CreationDate": "2015-08-18T09:11:36.657", "LastActivityDate": "2015-08-18T09:11:36.657"}, "32068717": {"ParentId": "32067643", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You could define a version for <em>admitted</em> <code>N</code>, and another for <em>not admitted</em> ones:</p>\n<pre><code>using my_unsigned = unsigned;\n\ntemplate &lt;my_unsigned N, typename std::enable_if&lt;(N &lt; 8 * sizeof(my_unsigned))&gt;::type* = nullptr &gt;\nuint32_t mask(uint32_t x) {\n  const uint32_t MASK = (uint32_t(1) &lt;&lt; N) - 1;\n  return x &amp; MASK;\n}\n\ntemplate &lt;my_unsigned N, typename std::enable_if&lt;(N &gt;= 8 * sizeof(my_unsigned))&gt;::type* = nullptr &gt;\nuint32_t mask(uint32_t x) {\n  return x;\n}\n</code></pre>\n<p>Thanks to SFINAE, when <code>N &lt; 2^sizeof(unsigned)</code>, the first version will be instantiated, otherwise the compiler will pick the (dumb) second version.</p>\n", "OwnerUserId": "2508150", "LastEditorUserId": "2508150", "LastEditDate": "2015-08-18T09:40:19.827", "Id": "32068717", "Score": "0", "CreationDate": "2015-08-18T09:34:54.573", "LastActivityDate": "2015-08-18T09:40:19.827"}, "bq_ids": {"n4140": {"so_32067643_32067643_0": {"section_id": 6146, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_32067643_32067643_0": {"section_id": 5909, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_32067643_32067643_0": {"section_id": 7642, "quality": 0.9285714285714286, "length": 13}}}, "32067643": {"CommentCount": "7", "ViewCount": "133", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-08-18T08:44:48.453", "LastActivityDate": "2015-08-19T02:29:51.270", "Title": "Well-defined bit-shifting more than 32 bits w/o compiler warning", "LastEditDate": "2017-05-23T12:03:53.290", "Id": "32067643", "Score": "4", "Body": "<p>This is a silly question partly for fun.</p>\n<p>I have a \"well-defined\" (or \"saturated\"?) bit-mask function</p>\n<pre><code>template &lt;unsigned N&gt;\nuint32_t mask(uint32_t x) {\n  const uint32_t MASK = N &gt;= 32 ? ~uint32_t(0) : (uint32_t(1) &lt;&lt; N) - 1;\n  return x &amp; MASK;\n}\n</code></pre>\n<p>Expected behavior:</p>\n<pre><code>uint32_t x = ~uint32_t(0); // 0xFFFFFFFF\nmask&lt;8&gt;(x) =&gt; 0x000000FF\nmask&lt;24&gt;(x) =&gt; 0x00FFFFFF\nmask&lt;32&gt;(x) =&gt; 0xFFFFFFFF\nmask&lt;1234&gt;(x) =&gt; 0xFFFFFFFF\n</code></pre>\n<p>But I don't like to have an undefined code <code>uint32_t(1) &lt;&lt; 1234</code> within <code>mask&lt;1234&gt;()</code> though it is 100% harmless (it shouldn't be evaluated.)  I don't want to see compiler warnings.</p>\n<ul>\n<li><s><a href=\"https://stackoverflow.com/questions/7401888/why-doesnt-left-bit-shift-for-32-bit-integers-work-as-expected-when-used\">Why doesn't left bit-shift, \"&lt;&lt;\", for 32-bit integers work as expected when used more than 32 times?</a></s> See my update below</li>\n</ul>\n<p>Please suggest me some bit-twiddling tricks (and template meta-programming?) to get rid of <code>uint32_t(1) &lt;&lt; 1234</code>.</p>\n<p>I have GCC 4.9 that (partially) supports C++14 and is smart enough to do constant folding etc</p>\n<h2>Update</h2>\n<p>Quoted from the N4140 draft of the C++14 spec:</p>\n<p>5.8 Shift operators [expr.shift]</p>\n<blockquote>\n<p id=\"so_32067643_32067643_0\">The behavior is undefined if the right operand\n  is negative, or greater than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>Do you folks have any non-template solution?</p>\n", "Tags": "<c++><bit-manipulation><template-meta-programming>", "OwnerUserId": "1190965", "AnswerCount": "2"}});