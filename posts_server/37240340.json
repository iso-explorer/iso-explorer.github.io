post_cb({"37240340": {"CommentCount": "0", "AcceptedAnswerId": "37240483", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2016-05-15T15:47:39.687", "LastActivityDate": "2016-05-15T16:14:42.173", "LastEditDate": "2016-05-15T16:14:42.173", "ViewCount": "83", "FavoriteCount": "1", "Title": "Do identifier rules apply for operator overloading function?", "Id": "37240340", "Score": "3", "Body": "<p>According to the C++ identifier naming rules:</p>\n<blockquote>\n<p id=\"so_37240340_37240340_0\">A valid identifier is a sequence of one or more letters, digits, or underscore characters (_) and must start either with a letter or underscore. Spaces, punctuation marks, and symbols cannot be part of an identifier.</p>\n</blockquote>\n<p>But the name of a function for operator overloading can contain characters other than a letter, digit or underscore, like for example:</p>\n<pre><code>user_data_type operator+(const user_data_type &amp; t) const;\n</code></pre>\n<p>Is this an exception to the the identifier naming rules or does function names used for operator overloading not considered as an identifier?</p>\n", "Tags": "<c++>", "OwnerUserId": "6334179", "AnswerCount": "4"}, "37240483": {"ParentId": "37240340", "CommentCount": "3", "Body": "<p>From \u00a73.1</p>\n<blockquote>\n<p id=\"so_37240340_37240483_0\">A name is a use of an <b>identifier</b> (2.11), <b>operator-function-id</b> (13.5), literal-operator-id (13.5.8), conversion-function-\n  id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1).</p>\n</blockquote>\n<p>So, as you can see, there are rules for the <i>identifiers</i> (which are the variable/function names). But there are some exceptions, and operator overloading (<i>operator-function-id</i>) is one of them, which means different rules apply to them.</p>\n<p>From \u00a713.5:</p>\n<blockquote>\n<p id=\"so_37240340_37240483_1\">operator-function-id: <b>operator</b> <i>operator</i></p>\n<p id=\"so_37240340_37240483_2\"><i>operator</i>: one of</p>\n<ul>\n<li><p id=\"so_37240340_37240483_3\">new delete new[] delete[]</p></li>\n<li><p id=\"so_37240340_37240483_4\">+ - * / % \u02c6 &amp; | ~</p></li>\n<li><p id=\"so_37240340_37240483_5\">! = &lt; &gt; += -= *= /= %=</p></li>\n<li><p id=\"so_37240340_37240483_6\">\u02c6= &amp;= |= &lt;&lt; &gt;&gt; &gt;&gt;= &lt;&lt;= == !=</p></li>\n<li><p id=\"so_37240340_37240483_7\">&lt;= &gt;= &amp;&amp; || ++ -- , -&gt;* -&gt;</p></li>\n<li><p id=\"so_37240340_37240483_8\">( ) [ ]</p></li>\n</ul>\n</blockquote>\n<p>So, <code>operator+</code> is allowed, <code>operator-</code> also, basically <code>operator</code> + <code>any of the operators listed above</code>.</p>\n", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "37240483", "Score": "7", "CreationDate": "2016-05-15T16:00:05.700", "LastActivityDate": "2016-05-15T16:00:05.700"}, "37240429": {"ParentId": "37240340", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><a href=\"http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Lexical-Elements\" rel=\"nofollow\">The GNU C reference manual</a> states that </p>\n<blockquote>\n<p id=\"so_37240340_37240429_0\">there are five types of tokens: keywords, identifiers, constants,\n  operators, and separators</p>\n</blockquote>\n<p>thus operator is not an identifier.</p>\n<pre><code>user_data_type operator + (const user_data_type &amp; t) const;/*\n^^^^^          ^^^^^    ^\nidentifier     keyword  operator\n*/\n</code></pre>\n", "OwnerUserId": "3344612", "LastEditorUserId": "3344612", "LastEditDate": "2016-05-15T16:00:52.877", "Id": "37240429", "Score": "1", "CreationDate": "2016-05-15T15:55:05.473", "LastActivityDate": "2016-05-15T16:00:52.877"}, "37240482": {"ParentId": "37240340", "CommentCount": "0", "Body": "<p>Operator overload functions can only contain punctuation or symbols that are operators which can be overloaded. When using the keyword <code>operator</code> followed by a valid operator you are using a built-in feature of C rather than creating your own identifier.</p>\n", "OwnerUserId": "1344837", "PostTypeId": "2", "Id": "37240482", "Score": "1", "CreationDate": "2016-05-15T15:59:59.123", "LastActivityDate": "2016-05-15T15:59:59.123"}, "37240398": {"ParentId": "37240340", "CommentCount": "0", "Body": "<p><code>operator+</code> is not a normal identifier, it is an <em>operator-function-id</em> as defined in 13.5/1 in N4140. By definition, it consists of the word <code>operator</code> followed by an operator, the <code>+</code> in your example. By this rule, you can also write</p>\n<pre><code>operator +\n</code></pre>\n<p>or even</p>\n<pre><code>user_data_type\noperator\n\n\n+\n(const user_data_type &amp; t) const;\n</code></pre>\n<p>as again, <code>operator+</code> is not a normal identifier.</p>\n<p>The rule you cite does not apply here. </p>\n", "OwnerUserId": "3002139", "PostTypeId": "2", "Id": "37240398", "Score": "8", "CreationDate": "2016-05-15T15:52:44.263", "LastActivityDate": "2016-05-15T15:52:44.263"}, "bq_ids": {"n4140": {"so_37240340_37240429_0": {"section_id": 5327, "quality": 0.5555555555555556, "length": 5}, "so_37240340_37240483_3": {"section_id": 6089, "quality": 1.0, "length": 4}}, "n3337": {"so_37240340_37240429_0": {"section_id": 5124, "quality": 0.5555555555555556, "length": 5}, "so_37240340_37240483_3": {"section_id": 5857, "quality": 1.0, "length": 4}}, "n4659": {"so_37240340_37240429_0": {"section_id": 6748, "quality": 0.5555555555555556, "length": 5}, "so_37240340_37240483_3": {"section_id": 7585, "quality": 1.0, "length": 4}}}});