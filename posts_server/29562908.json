post_cb({"29563111": {"Id": "29563111", "PostTypeId": "2", "Body": "<p>There is an optimization called copy elision, described by the standard in \u00a712.8/31: </p>\n<blockquote>\n<p id=\"so_29562908_29563111_0\">This elision of copy/move operations, called <em>copy elision</em>, is\n  permitted in the following circumstances (which may be combined to\n  eliminate multiple copies):</p>\n<ul>\n<li><p id=\"so_29562908_29563111_1\">in a <code>return</code> statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-\n  unqualified type as the function return type, <strong>the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value</strong></p></li>\n<li><p id=\"so_29562908_29563111_2\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same\n  cv-unqualified type, <strong>the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move</strong></p></li>\n</ul>\n</blockquote>\n<p>Thus in the line</p>\n<pre><code>MyClass a = b + c;\n</code></pre>\n<p>The temporary object returned by <code>operator+</code> is <strong>directly constructed into <code>a</code></strong>, and no unnecessary copies/moves occur, not even in the <code>return</code> statement in <code>operator+</code>. A demonstration:</p>\n<pre><code>struct MyClass\n{\n    int i;\n\n    MyClass operator+( MyClass const&amp; m ) {\n        MyClass r = m.i + i;\n        return r;\n    }\n\n    MyClass(int i) : i(i) {std::cout &lt;&lt; \"Ctor!\\n\";}\n    // Move ctor not implicitly declared, see \u00a712.8/9\n    MyClass(MyClass const&amp;) {std::cout &lt;&lt; \"Copy-Ctor!\\n\";}\n    ~MyClass() {std::cout &lt;&lt; \"* Dtor!\\n\";}\n};\n\nint main() {\n    MyClass c{7}, b{3},\n            a = b + c;\n}\n</code></pre>\n<p>Output on any decent compiler:</p>\n<blockquote>\n<p id=\"so_29562908_29563111_3\">Ctor!<br> Ctor!<br> Ctor!<br>\n  * Dtor!<br>\n  * Dtor!<br>\n  * Dtor!</br></br></br></br></br></p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e396398e099e2a4e\" rel=\"nofollow\"><strong>Live on Coliru</strong></a></p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-04-10T13:51:17.443", "Score": "0", "CreationDate": "2015-04-10T13:46:04.167", "ParentId": "29562908", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-04-10T13:51:17.443"}, "29563037": {"Id": "29563037", "PostTypeId": "2", "Body": "<p>Most compilers will optimise this using <em>copy-elision</em>. The temporary created from calling <code>MyClass::operator+</code> will be constructed directly into <code>a</code> rather than calling the copy constructor.</p>\n<p>Also note that <code>MyClass a = ...</code> does not call the assignment operator, it calls the copy constructor. This is known as copy-initialization.</p>\n<p>Have a look <a href=\"https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization/12953150#12953150\">here</a> for more information on copy elision.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-10T13:42:48.927", "Score": "1", "CreationDate": "2015-04-10T13:42:48.927", "ParentId": "29562908", "CommentCount": "1", "OwnerUserId": "496161", "LastEditDate": "2017-05-23T10:27:08.297"}, "bq_ids": {"n4140": {"so_29562908_29563111_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}, "so_29562908_29563111_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 480}, "so_29562908_29563111_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 480}}, "n3337": {"so_29562908_29563111_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}, "so_29562908_29563111_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 471}, "so_29562908_29563111_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 471}}, "n4659": {"so_29562908_29563111_2": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}, "so_29562908_29563111_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 502}, "so_29562908_29563111_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}}}, "29562908": {"ViewCount": "297", "Body": "<p><strong>Whover downvoted me, mind explaining why? I thought it was a legitimate question, and all the answers have been very helpful.</strong> </p>\n<p>Theoretically, when I do <code>MyClass a = b + c</code>, it should first call <code>const MyClass operator+</code>, returning a <code>const MyClass</code> object, then call the assignment operator to create object a.</p>\n<p>It seems like I would copy stuff twice when returning a object and calling the assignment operator. Is this optimized in the compiler? If yes, how?  It seems more tricky if it involves casting. </p>\n<p>Let's assume we are talking about g++, which is pretty much the golden standard of c++ compilers. [EDIT: ok, let's say most commonly used] </p>\n<p>[EDIT:] Whoa, I didn't expect using const in return-by-value be criticized. I thought it was enouraged to use const when return-by-value for non-built-in types? I remember seeing it somewhere. </p>\n", "AcceptedAnswerId": "29563019", "Title": "Does c++ compiler optimize a = b + c", "CreationDate": "2015-04-10T13:36:33.800", "Id": "29562908", "CommentCount": "7", "LastEditDate": "2015-04-10T16:12:58.020", "PostTypeId": "1", "LastEditorUserId": "509205", "LastActivityDate": "2015-04-10T16:12:58.020", "Score": "-5", "OwnerUserId": "509205", "Tags": "<c++><operator-overloading><compiler-optimization>", "AnswerCount": "4"}, "29563019": {"Id": "29563019", "PostTypeId": "2", "Body": "<p>Copy-initialisation doesn't use the assignment operator, it uses the copy or move constructor. Since your operator foolishly returns a <code>const</code> object, moving is impossible, so it would use the copy constructor.</p>\n<p>However, initialising an object from a temporary is one of the situations where <em>copy elision</em> is allowed, so any decent compiler should do that, initialising <code>a</code> directly as the return value instead of creating a temporary.</p>\n", "LastActivityDate": "2015-04-10T13:42:18.307", "CommentCount": "3", "CreationDate": "2015-04-10T13:42:18.307", "ParentId": "29562908", "Score": "2", "OwnerUserId": "204847"}, "29563887": {"Id": "29563887", "PostTypeId": "2", "Body": "<p>To give a more direct idea of what you can expect, let's start with a simple class like this:</p>\n<pre><code>class Integer {\n    int a;\n    public:\n    Integer(int a) : a(a) {}\n\n    friend Integer operator+(Integer a, Integer b) {\n        return Integer(a.a + b.a);\n    }\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, Integer const &amp;i) {\n        return os &lt;&lt; i.a;\n    }\n};\n</code></pre>\n<p>For the sake of demonstration, let's add a <code>main</code> that reads some data from the outside world, creates a couple of Integer objects, and then prints out the result of adding them. The inputs and outputs will come from the outside world, so the compiler can't pull <em>too</em> fancy of tricks, and optimize everything out.</p>\n<pre><code>int main(int argc, char **argv) {\n    Integer a(atoi(argv[1])), b(atoi(argv[2]));\n    Integer c = a + b;    // Line 20\n    std::cout &lt;&lt; c;\n}\n</code></pre>\n<p>Note the <code>line 20</code> there--it becomes important below.</p>\n<p>Now, let's compile it up and see what code the compiler produces. Using VC++ we get this:</p>\n<p>[ normal \"stuff\" to set up entry to <code>main</code> elided ]</p>\n<pre><code>; Line 19\n    mov rcx, QWORD PTR [rdx+8]\n    mov rdi, rdx\n    call    atoi\n    mov rcx, QWORD PTR [rdi+16]\n    mov ebx, eax\n    call    atoi\n; Line 20\n    lea edx, DWORD PTR [rax+rbx]\n; Line 21\n    call    ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z ; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;\n</code></pre>\n<p>So even though we've created two Integer objects and added them using an overloaded operator that constructs and returns a third Integer object, the compiler has seen through all our subterfuge, and \"realized\" that what we're doing is just reading a couple of <code>int</code>s using <code>atoi</code>, adding them together, and printing out the <code>int</code> we get as a result.</p>\n<p>Having seen that, it eliminates the function call completely and doesn't call or return anything--it just reads two ints, adds them together, and prints out the result.</p>\n<p>Using gcc the result is pretty much the same:</p>\n<pre><code>movq    8(%rbx), %rcx\ncall    atoi                    ; &lt;--- get first item\nmovq    16(%rbx), %rcx\nmovl    %eax, %esi\ncall    atoi                    ; &lt;--- get second item\nmovq    .refptr._ZSt4cout(%rip), %rcx\nleal    (%rsi,%rax), %edx       ; &lt;--- the addition\ncall    _ZNSolsEi               ; &lt;--- print result\n</code></pre>\n<p>It's rearranged the code slightly, but ultimate does pretty much the same thing--all vestiges of our <code>Integer</code> class have disappeared.</p>\n<p>Let's compare that to what we get without using a class at all:</p>\n<pre><code>int main(int argc, char **argv) {\n    int a = atoi(argv[1]);\n    int b = atoi(argv[2]);\n    int c = a + b;\n    std::cout &lt;&lt; c;\n}\n</code></pre>\n<p>Using VC++, this produces the following:</p>\n<pre><code>; Line 5\n    mov rcx, QWORD PTR [rdx+8]\n    mov rdi, rdx\n    call    atoi\n; Line 6\n    mov rcx, QWORD PTR [rdi+16]\n    mov ebx, eax\n    call    atoi\n; Line 7\n    lea edx, DWORD PTR [rbx+rax]\n; Line 8\n    call    ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z ; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;\n</code></pre>\n<p>Other than the comments showing the line numbers from the original file, the code is <em>precisely</em> identical to what we got using the class.</p>\n<p>I won't waste the space to copy and paste the result from doing the same with g++; it also produces identical code regardless of whether we use our class and overloaded operator to do the addition or not.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2015-04-10T14:27:44.720", "Score": "0", "CreationDate": "2015-04-10T14:21:40.087", "ParentId": "29562908", "CommentCount": "0", "OwnerUserId": "179910", "LastEditDate": "2015-04-10T14:27:44.720"}});