post_cb({"39373762": {"Id": "39373762", "PostTypeId": "2", "Body": "<p>It is not safe to call new operator inside initialization list.\nif new fails the destructor of Array will not be called.\nhere is a similar question.\n<a href=\"https://stackoverflow.com/questions/9064298/are-there-any-issues-with-allocating-memory-within-constructor-initialization-li\">Are there any issues with allocating memory within constructor initialization lists?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-07T15:19:26.740", "Score": "-1", "CreationDate": "2016-09-07T15:19:26.740", "ParentId": "39373556", "CommentCount": "1", "OwnerUserId": "1643530", "LastEditDate": "2017-05-23T12:16:27.437"}, "39373556": {"ViewCount": "288", "Body": "<p>This is probably a simple question but I have this <code>template class</code>:</p>\n<pre><code>template&lt;typename Type&gt;\nclass Array {\n    size_t n;\n    Type* buff;\npublic:\n    Array(size_t n_): n(n_), buff(new Type[n]) {}\n};\n</code></pre>\n<p>The code is from a course pdf file where it says <code>buff(new Type[n])</code> is unsafe. I don't understand why it's unsafe, isn't size_t generally unsigned? Can I have an example where it could have a compile and/or run-time error?</p>\n", "Title": "unsafe template array constructor", "CreationDate": "2016-09-07T15:10:41.403", "LastActivityDate": "2016-09-07T21:54:09.297", "CommentCount": "2", "LastEditDate": "2016-09-07T15:12:38.393", "PostTypeId": "1", "LastEditorUserId": "6525260", "Id": "39373556", "Score": "10", "OwnerUserId": "2660756", "Tags": "<c++>", "AnswerCount": "5"}, "39373640": {"Id": "39373640", "PostTypeId": "2", "Body": "<p>The code is \"unsafe\" in the fact that it relies on <code>n</code> being constructed before <code>buff</code>.  This dependency adds brittleness to the code.</p>\n<p>When you construct the members of the class they are constructed in the order the are declared in the class, not how they are called in the member initialization list, so if the code was changed to</p>\n<pre><code>template&lt;typename Type&gt;\nclass Array {\n    Type* buff;\n    size_t n;\npublic:\n    Array(size_t n_): n(n_), buff(new Type[n]) {}\n};\n</code></pre>\n<p>Then when you do <code>buff(new Type[n])</code>, <code>n</code> is uninitialized and you have undefined behavior.</p>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2016-09-07T15:24:09.190", "Score": "12", "CreationDate": "2016-09-07T15:14:47.463", "ParentId": "39373556", "CommentCount": "4", "OwnerUserId": "4342498", "LastEditDate": "2016-09-07T15:24:09.190"}, "bq_ids": {"n4140": {"so_39373556_39379584_0": {"length": 15, "quality": 1.0, "section_id": 438}}, "n3337": {"so_39373556_39379584_0": {"length": 15, "quality": 1.0, "section_id": 429}}, "n4659": {"so_39373556_39379584_0": {"length": 15, "quality": 1.0, "section_id": 458}}}, "39374000": {"Id": "39374000", "PostTypeId": "2", "Body": "<p>First of all, you have a memory leak. But the question probably isn't about that. So let's assume you have a destructor that deallocates the array.</p>\n<pre><code>template&lt;typename Type&gt;\nclass Array {\n    size_t n;\n    Type* buff;\npublic:\n    Array(size_t n_): n(n_), buff(new Type[n]) {}\n    ~Array() { delete[] buff; }\n};\n</code></pre>\n<p>Now <em>this</em> particular code is perfectly safe. No exception can be thrown while assigning <code>n_</code>, the order of initialization is correct and <code>buff</code> is the only raw pointer in your class. However, as you start expanding your class and writing more classes, the risk of a memory leak increases.</p>\n<p>Imagine that you need to add one more members to the <code>class Array</code>:</p>\n<pre><code>template&lt;typename Type&gt;\nclass Array {\n    size_t n;\n    Type* buff;\n    SomethingElse xyz;\npublic:\n    Array(size_t n_): n(n_), buff(new Type[n_]), xyz(n_) {}\n    ~Array() { delete[] buff; }\n};\n</code></pre>\n<p>If the constructor of <code>SomethingElse</code> throws, the memory allocated for <code>buff</code> will leak, because the destructor <code>~Array()</code> will never be called.</p>\n<p>Modern C++ calls pointers such as <code>Type* buff</code> <em>raw pointers</em> because you are responsible for deallocating storage yourself (taking exceptions into account), and introduces tools such as <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow\"><code>std::unique_ptr</code></a> and <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\"><code>std::shared_ptr</code></a> that can take care of storage deallocation automatically.</p>\n<p>In modern C++ you could write your class like this:</p>\n<pre><code>template&lt;typename Type&gt;\nclass Array {\n    size_t n;\n    std::unique_ptr&lt;Type[]&gt; buff;\npublic:\n    Array(size_t n_): n(n_), buff(new Type[n_]) {}\n};\n</code></pre>\n<p>Notice the absence of a destructor. The <code>unique_ptr</code> will take care of calling <code>delete</code> for you.</p>\n<p>Note also no dependency on class members inside the initializer list (simply writing <code>new Type[n_]</code> instead of <code>new Type[n]</code> makes your code more robust)</p>\n", "LastEditorUserId": "485343", "LastActivityDate": "2016-09-07T20:16:55.320", "Score": "3", "CreationDate": "2016-09-07T15:30:57.673", "ParentId": "39373556", "CommentCount": "0", "OwnerUserId": "485343", "LastEditDate": "2016-09-07T20:16:55.320"}, "39379584": {"Id": "39379584", "PostTypeId": "2", "Body": "<p>C++98 Standard 12.6.2.5.4 (I don't expect new versions to have relaxed this).</p>\n<blockquote>\n<p id=\"so_39373556_39379584_0\">\u2014 Then, nonstatic data members shall be initialized in the order they\n  were declared in the class definition (again regardless of the order\n  of the mem-initializers).</p>\n</blockquote>\n<p>So the order of initialization is defined according to this.</p>\n<p>If you want an example of how to crash it simply make <code>sizeof(Type)*n</code> &gt; total memory in your system.</p>\n", "LastActivityDate": "2016-09-07T21:54:09.297", "CommentCount": "0", "CreationDate": "2016-09-07T21:54:09.297", "ParentId": "39373556", "Score": "0", "OwnerUserId": "4013258"}, "39373952": {"Id": "39373952", "PostTypeId": "2", "Body": "<p>First of all the order, the initializations for the constructor are executed is not determined by the order they are written down, but by the order the initialized fields appear in the code:</p>\n<pre><code>class Array {\n    size_t n;\n    Type* buff;\npublic:\n    Array(size_t n_): n(n_), buff(new Type[n]) {}\n};\n</code></pre>\n<p>Here first n will be initialized and then buff.</p>\n<pre><code>class Array {\n    Type* buff;\n    size_t n;\npublic:\n    Array(size_t n_): n(n_), buff(new Type[n]) {}\n};\n</code></pre>\n<p>Now first buff will be initialized and then n, so n has no defined value in that case.</p>\n<p>Using initialization lists for constructors is good practice, but be careful, that you don't create any assumptions on the order.</p>\n<p>Generally it is a good idea to refrain from owning raw pointers. If you use smart pointers instead, you can not forget to release the data.</p>\n<p>In the specific case, you might also want to use std::vector instead of a C-style array. That handles all the allocation, reallocation, releases, etc. in a thread safe manner for you. It seems like you are trying to write something like your own std::vector. Please only do that for educational purposes. Always prefer the standard implementation in production code. You probably won't get it better for quite a while. If you did, you would ask different questions here ;-)</p>\n", "LastActivityDate": "2016-09-07T15:28:23.760", "CommentCount": "1", "CreationDate": "2016-09-07T15:28:23.760", "ParentId": "39373556", "Score": "3", "OwnerUserId": "5053331"}});