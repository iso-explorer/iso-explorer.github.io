post_cb({"41176491": {"ParentId": "41176231", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes. The trick is to realize that despite the appearance, the portion of a structured binding declaration before the <code>[</code> doesn't apply to the names in the <em>identifier-list</em>. They apply instead to the variable introduced implicitly by the declaration. <a href=\"https://timsong-cpp.github.io/cppwp/dcl.struct.bind#1\" rel=\"nofollow noreferrer\">[dcl.struct.bind]/1</a>:</p>\n<blockquote>\n<p id=\"so_41176231_41176491_0\">First, a variable with a unique name <code>e</code> is introduced. If the\n  <em>assignment-expression</em> in the <em>initializer</em> has array type <code>A</code> and no <em>ref-qualifier</em> is present, <code>e</code> has type <code>cv A</code> and each element is copy-initialized or direct-initialized from the corresponding element\n  of the <em>assignment-expression</em> as specified by the form of the\n  <em>initializer</em>. Otherwise, <code>e</code> is defined as-if by</p>\n<p id=\"so_41176231_41176491_1\"><em>attribute-specifier-seq</em><sub>opt</sub> <em>decl-specifier-seq</em> <em>ref-qualifier</em><sub>opt</sub> <code>e</code> <em>initializer</em> ;</p>\n<p id=\"so_41176231_41176491_2\">where the declaration is never interpreted as a function declaration\n  and the parts of the declaration other than the <em>declarator-id</em> are\n  taken from the corresponding structured binding declaration.</p>\n</blockquote>\n<p>The names are then defined to either be aliases for the elements of <code>e</code> or references bound to the result of calling <code>get</code> on <code>e</code>.</p>\n<p>In your example, it's as if by (assuming that <code>f</code> returns a two-element <code>std::tuple</code>):</p>\n<pre><code>const auto&amp; e = f(); // 1\nusing E = remove_reference_t&lt;decltype((e))&gt;;\nstd::tuple_element&lt;0, E&gt;::type&amp; a = get&lt;0&gt;(e);\nstd::tuple_element&lt;1, E&gt;::type&amp; b = get&lt;1&gt;(e);\n</code></pre>\n<p>(Except that <code>decltype(a)</code> and <code>decltype(b)</code> gets the special treatment to hide their referenceness.)</p>\n<p>It should be pretty obvious that line #1 does extend the lifetime of <code>f</code>'s return value.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2017-03-16T14:31:02.510", "Id": "41176491", "Score": "17", "CreationDate": "2016-12-16T02:42:48.780", "LastActivityDate": "2017-03-16T14:31:02.510"}, "bq_ids": {"n4659": {"so_41176231_41176491_2": {"section_id": 4038, "quality": 1.0, "length": 16}, "so_41176231_41176231_1": {"section_id": 6867, "quality": 0.5625, "length": 9}, "so_41176231_41176491_0": {"section_id": 4038, "quality": 1.0, "length": 25}}}, "41176231": {"CommentCount": "0", "AcceptedAnswerId": "41176491", "LastEditDate": "2016-12-16T02:19:38.113", "LastEditorUserId": "1013719", "CreationDate": "2016-12-16T02:06:20.720", "LastActivityDate": "2017-03-16T14:31:02.510", "PostTypeId": "1", "ViewCount": "622", "FavoriteCount": "3", "Title": "Do const references in structured bindings extend the lifetime of the decomposed object?", "Id": "41176231", "OwnerUserId": "1013719", "Body": "<p>Does writing <code>const auto&amp; [a, b] = f();</code> guarantee extending the lifetime of the object returned from <code>f()</code>, or at least the objects <code>a</code> and <code>b</code> are bound to? Reading through <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r3.html\">the proposal</a> I don't see anything obvious in the language to make me sure that it does unless it's just covered by something else. However, the following doesn't extend the lifetime of the temporary, so I don't see how it would be covered:</p>\n<pre><code>const auto&amp; a = std::get&lt;0&gt;(f());\n</code></pre>\n<p>At the top of the paper it seems to suggest that it is covered</p>\n<blockquote>\n<p id=\"so_41176231_41176231_0\">the cv-qualifiers and ref-qualifier of the decomposition declaration are applied to the reference introduced for the initializer, not for the individual member aliases</p>\n</blockquote>\n<p>But in the proposed wording for the actual standard, the closest mention I see is below, though I'm not sure how to read it to get the guarantee I'm looking for:</p>\n<blockquote>\n<p id=\"so_41176231_41176231_1\">if e is an unparenthesized id-expression naming an lvalue or reference\n  introduced from the identifier-list of a decomposition declaration,\n  decltype(e) is the referenced type as given in the specification of\n  the decomposition declaration</p>\n</blockquote>\n<p>It seems that gcc and clang both extend the lifetime of the object returned until the end of the scope based on a <a href=\"http://melpon.org/wandbox/permlink/9OYdeZ2E5Og7UfEX\">wandbox experiment</a>. An <a href=\"http://melpon.org/wandbox/permlink/DfnkhCn2f8DCu5oH\">uglier one</a> implementing all the bells and whistles for my own type seems to extend the lifetime of the outer object and its other data members.</p>\n<p>Though almost certainly the authors' intent(s), I'd like to know for sure that the language guarantees this is safe.</p>\n", "Tags": "<c++><c++1z><structured-bindings>", "Score": "26", "AnswerCount": "1"}});