post_cb({"7157728": {"ViewCount": "232", "Body": "<pre><code>typedef struct {    \n    char c;\n    char cc[2];\n        short s;\n    char ccc;\n}stuck;\n</code></pre>\n<p>Should the above struct have a memory layout as this ?</p>\n<pre><code>1   2   3   4   5  6     7\n- c -  cc   -   s  - ccc -\n</code></pre>\n<p>or this ?</p>\n<pre><code>1    2   3   4    5   6   7     8 \n-    c   -   cc   -   s   - ccc -\n</code></pre>\n<p>I think the first should be better but why my VS09 compiler chooses the second ? (Is my layout correct by the way ?) Thank you</p>\n", "Title": "struct alignment question", "CreationDate": "2011-08-23T07:43:49.390", "LastActivityDate": "2011-08-23T08:42:47.233", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Id": "7157728", "Score": "0", "OwnerUserId": "885185", "Tags": "<c++><c>", "AnswerCount": "5"}, "7157859": {"Id": "7157859", "PostTypeId": "2", "Body": "<p>I think that your structure will have the following layout, at least on Windows:</p>\n<pre><code>typedef struct {    \n    char c;\n    char cc[2];\n    char __padding;\n    short s;\n    char ccc;\n    char __tail_padding;\n} stuck;\n</code></pre>\n<p>You could avoid the padding by reordering the structure members:</p>\n<pre><code>typedef struct {    \n    char c;\n    char cc[2];\n    char ccc;\n    short s;\n} stuck;\n</code></pre>\n", "LastEditorUserId": "341065", "LastActivityDate": "2011-08-23T08:33:14.040", "Score": "4", "CreationDate": "2011-08-23T07:57:03.480", "ParentId": "7157728", "CommentCount": "5", "LastEditDate": "2011-08-23T08:33:14.040", "OwnerUserId": "341065"}, "7157904": {"Id": "7157904", "PostTypeId": "2", "Body": "<p>Other than at the beginning of a structure, an implementation can put whatever padding it wants in your structures so there's no <em>right</em> way. From C99 <strong>6.7.2.1 Structure and union specifiers</strong>, paragraphs:</p>\n<blockquote>\n<p id=\"so_7157728_7157904_0\"><strong>/12:</strong><br>Each non-bit-field member of a structure or union object is aligned in an implementation-defined manner appropriate to its type.</br></p>\n<p id=\"so_7157728_7157904_1\"><strong>/13:</strong><br>There may be unnamed\n  padding within a structure object, but not at its beginning.</br></p>\n<p id=\"so_7157728_7157904_2\"><strong>/15:</strong><br>There may be unnamed padding at the end of a structure or union.</br></p>\n</blockquote>\n<p>Paragraph 13 also contains:</p>\n<blockquote>\n<p id=\"so_7157728_7157904_3\">Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared.</p>\n</blockquote>\n<p>This means that the fields within the structure cannot be re-ordered. And, in a large number of modern implementations (but this is <em>not</em> mandated by the standard), the alignment of an object is equal to its size. For example a 32-bit integer data type may have an alignment requirement of four (8-bit) bytes.</p>\n<p>Hence, a logical alignment would be:</p>\n<pre><code>offset  size  field\n------  ----  -----\n   0      1   char c;\n   1      2   char cc[2];\n   3      1   padding\n   4      2   short s;\n   6      1   char ccc;\n   7      1   padding\n</code></pre>\n<p>but, as stated, it may be something different. The final padding is to ensure that consecutive array elements are aligned correctly (since the <code>short</code> most likely has to be on a 2-byte boundary).</p>\n<p>There are a number of (non-portable) ways in which you may be able to control the padding. Many compilers have a <code>#pragma pack</code> option that you can use to control padding (although be careful: while some systems may just slow down when accessing unaligned data, some will actually dump core for an illegal access).</p>\n<p>Also, re-ordering the elements within the structure from largest to smallest tends to reduce padding as well since the larger elements tend to have stricter alignment requirements.</p>\n<p>These, and an even uglier \"solution\" are discussed more <a href=\"https://stackoverflow.com/questions/4301759/disable-structure-padding-in-c-without-using-pragma/4301778#4301778\">here</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-23T08:25:50.027", "Score": "2", "CreationDate": "2011-08-23T08:01:00.497", "ParentId": "7157728", "CommentCount": "3", "LastEditDate": "2017-05-23T12:19:52.960", "OwnerUserId": "14860"}, "7157752": {"Id": "7157752", "PostTypeId": "2", "Body": "<p>The compiler can't choose the second. The standard mandates that the first field must be aligned with the start of the structure.</p>\n<p>Are you using <code>offsetof</code> from <code>stddef.h</code> for finding this out ?</p>\n<p>6.7.2.1 - 13</p>\n<blockquote>\n<p id=\"so_7157728_7157752_0\">A pointer to a structure object, suitably converted, points to its\n  initial member (or if that member is a bit-\ufb01eld, then to the unit in\n  which it resides), and vice versa. <strong>There may be unnamed padding\n  within a structure object, but not at its beginning</strong>.</p>\n</blockquote>\n<p>It means that you can have</p>\n<pre><code>struct s {\n    int x;\n    char y;\n    double z;\n};\n\nstruct s obj;\nint *x = (int *)&amp;obj; /* Legal. */\n</code></pre>\n<p>Put another way</p>\n<pre><code>offsetof(s, x); /* Must yield 0. */\n</code></pre>\n", "LastEditorUserId": "714501", "LastActivityDate": "2011-08-23T07:51:15.983", "Score": "2", "CreationDate": "2011-08-23T07:46:04.100", "ParentId": "7157728", "CommentCount": "2", "LastEditDate": "2011-08-23T07:51:15.983", "OwnerUserId": "714501"}, "7158318": {"Id": "7158318", "PostTypeId": "2", "Body": "<p>Others have mentionned that padding may be introduced either between attributes or after the last attribute.</p>\n<p>The interesting thing though, I believe, is to understand <em>why</em>.</p>\n<p>Types usually have an <em>alignment</em>. This property precises which address are valid (or not) for a particular type. On some architecture, this is a loose requirement (if you do not respect it, you only incur some overhead), on others, violating it causes hardware exceptions.</p>\n<p>For example (arbitrary, as each platform define its own):</p>\n<ul>\n<li><code>char</code>: 1</li>\n<li><code>short</code> (16 bits): 2</li>\n<li><code>int</code> (32 bits): 4</li>\n<li><code>long int</code> (64 bits): 8</li>\n</ul>\n<p>A compound type will usually have as alignment the maximum of the alignment of its parts.</p>\n<hr>\n<p><strong>How does alignment influences padding ?</strong></p>\n<p>In order to respect the alignment of a type, some padding may be necessary, for example:</p>\n<pre><code>struct S { char a; int b; };\n\nalign(S) = max(align(a), align(b)) = max(1, 4) = 4\n</code></pre>\n<p>Thus we have:</p>\n<pre><code>// S allocated at address 0x16 (divisible by 4)\n0x16 a\n0x17 \n0x18\n0x19\n0x20 b\n0x21 b\n0x22 b\n0x23 b\n</code></pre>\n<p>Note that because <code>b</code> can only be allocated at an address also divisible by 4, there is some space between <code>a</code> and <code>b</code>, this space is called padding.</p>\n<hr>\n<p><strong>Where does padding comes from ?</strong></p>\n<p>Padding may have two different reasons:</p>\n<ul>\n<li>between attributes, it is caused by a difference in alignment (see above)</li>\n<li>at the end of the <code>struct</code>, it is caused by array requirements</li>\n</ul>\n<p>The array requirement is that elements of an array should be allocated without intervening padding. This allows one to use pointer arithmetic to navigate from an element to another:</p>\n<pre><code>+---+---+---+\n| S | S | S |\n+---+---+---+\n\nS* p = /**/;\np = p + 1; // &lt;=&gt; p = (S*)((void*)p + sizeof(S));\n</code></pre>\n<p>This means, however, than the structure <code>S</code> size needs be a multiple of <code>S</code> alignment.</p>\n<p>Example:</p>\n<pre><code>struct S { int a; char b; };\n\n+----+-+---+\n|  a |b| ? |\n+----+-+---+\n\na: offset 0, size 4\nb: offset 4, size 1\n?: offset 5, size 3 (padding)\n</code></pre>\n<hr>\n<p>Putting it altogether:</p>\n<pre><code>typedef struct {    \n    char a;\n    char b[2];\n    short s;\n    char c;\n} stuck;\n\n+-+--+-+--+-+-+\n|a| b|?|s |c|?|\n+-+--+-+--+-+-+\n</code></pre>\n<p>If you really wish to avoid padding, one (simple) trick (which does not involve addition nor substraction) is to simply order your attributes starting from the maximum alignment.</p>\n<pre><code>typedef struct {\n  short s;\n  char a;\n  char b[2];\n  char c;\n} stuck;\n\n+--+-+--+-+\n| s|a| b|c|\n+--+-+--+-+\n</code></pre>\n<p>It's a simple rule of thumb, especially as the alignment of basic types may change from platform to platform (32bits/64bits) whereas the relative order of the types is pretty stable (exception: the pointers).</p>\n</hr></hr></hr>", "LastActivityDate": "2011-08-23T08:42:47.233", "Score": "0", "CreationDate": "2011-08-23T08:42:47.233", "ParentId": "7157728", "CommentCount": "0", "OwnerUserId": "147192"}, "bq_ids": {"n4140": {"so_7157728_7157904_1": {"length": 7, "quality": 0.7, "section_id": 5879}}, "n3337": {"so_7157728_7157752_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 5650}, "so_7157728_7157904_1": {"length": 7, "quality": 0.7, "section_id": 5650}}, "n4659": {"so_7157728_7157904_1": {"length": 7, "quality": 0.7, "section_id": 7363}}}, "7157796": {"Id": "7157796", "PostTypeId": "2", "Body": "<p>While I do really understand your visual representation of the alignment, I can tell you that with VS you can achieve a packed structure by using 'pragma':</p>\n<pre><code>__pragma( pack(push, 1) )\nstruct { ... };\n__pragma( pack(pop) )\n</code></pre>\n<p>In general struct-alignment depends on the compiler used, the target-platform (and its address-size) and the weather, IOW in reality it is not well defined. </p>\n", "LastActivityDate": "2011-08-23T07:51:36.660", "Score": "1", "CreationDate": "2011-08-23T07:51:36.660", "ParentId": "7157728", "CommentCount": "0", "OwnerUserId": "880584"}});