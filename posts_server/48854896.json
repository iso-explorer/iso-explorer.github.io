post_cb({"bq_ids": {"n4140": {"so_48854896_48854896_0": {"length": 20, "quality": 0.8, "section_id": 5834}, "so_48854896_48859018_0": {"length": 15, "quality": 0.9375, "section_id": 5817}, "so_48854896_48859018_1": {"length": 14, "quality": 0.875, "section_id": 5817}}, "n3337": {"so_48854896_48854896_0": {"length": 22, "quality": 0.88, "section_id": 5605}, "so_48854896_48859018_0": {"length": 15, "quality": 0.9375, "section_id": 5588}, "so_48854896_48859018_1": {"length": 14, "quality": 0.875, "section_id": 5588}}, "n4659": {"so_48854896_48854896_0": {"length": 20, "quality": 0.8, "section_id": 7296}, "so_48854896_48859018_0": {"length": 14, "quality": 0.875, "section_id": 7278}, "so_48854896_48859018_1": {"length": 15, "quality": 0.9375, "section_id": 7278}}}, "48858796": {"Id": "48858796", "PostTypeId": "2", "Body": "<p>Find the answer myself. Quoted from first paragraph, Section 5.1.2 in <a href=\"https://www.manning.com/books/c-plus-plus-concurrency-in-action\" rel=\"nofollow noreferrer\">C++ Concurrency in Action</a>:</p>\n<blockquote>\n<p id=\"so_48854896_48858796_0\">[...] If neither thread is updating the memory location, you\u2019re fine;\n  read-only data doesn\u2019t need protection or synchronization. If either\n  thread is modifying the data, there\u2019s a potential for a race\n  condition, as described in chapter 3.</p>\n</blockquote>\n", "LastActivityDate": "2018-02-19T02:26:57.797", "Score": "1", "CreationDate": "2018-02-19T02:26:57.797", "ParentId": "48854896", "CommentCount": "0", "OwnerUserId": "1348273"}, "48855603": {"Id": "48855603", "PostTypeId": "2", "Body": "<p>So I suppose you are talking of the structure holding the counter and a pointer to the owned data:</p>\n<pre><code>template&lt;class ValueType&gt;\nstruct shared_counter{\n  std::atomic&lt;int&gt; count=0;\n  const std::unique_ptr&lt;ValueType&gt; ptr;\n  //Your question is: Does ptr should be atomic?\n  //... This is a dumb implementation, only focusing on the subject.\n  };\n</code></pre>\n<p>In practice, ptr does not need to be atomic because if reference counting is implemented appropriatly, all access to <code>ptr</code> will be sequenced before the desctruction of shared_counter.</p>\n<p>To ensure that, inside the destructor of a <code>shared_ptr</code> the counter is decremented through a read-modify-write with acquire-release memory order:</p>\n<pre><code>template&lt;class ValueType&gt;\nstruct shared_ptr{\n   shared_counter&lt;ValueType&gt;* counted_ptr;\n   //...\n   void reset(){\n     if (counted_ptr-&gt;count.fetch_sub(1,std::memory_order_acq_rel) == 1)\n       counter_ptr-&gt;~shared_counter&lt;ValueType&gt;();\n     counter_ptr=nullptr;\n     }\n   };\n</code></pre>\n<p>Thanks to this memory order, if the fetched value of count is 1 in thread A, this means that in all other threads where <em>other</em> shared_ptrs pointing to the same <code>shared_counter</code> will not access any more this <code>shared_counter</code>. The memory order ensure that accesses performed to this shared_counter in these other threads will happen before the fetch of the value 1 in thread A. (release in other thread -&gt; acquire in the thread that will call the destructor).</p>\n<p>So there is no need to have <code>ptr</code> to be atomic because the counter decrementation cause sufficient sequencing.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-02-18T19:23:56.327", "Score": "0", "CreationDate": "2018-02-18T19:17:53.697", "ParentId": "48854896", "CommentCount": "2", "OwnerUserId": "5632316", "LastEditDate": "2018-02-18T19:23:56.327"}, "48854896": {"ViewCount": "74", "Body": "<p>I encounter this question while trying to implement a shared pointer. Let's focus on the managed data pointer. Its lifetime can be divided into three stages:</p>\n<ol>\n<li>Construction where there is no concurrent access.</li>\n<li>Concurrent reads on it (no writes).</li>\n<li>Destruction where there is no concurrent access. This is guaranteed by reference counting.</li>\n</ol>\n<p>My question is, given this situation, is it necessary for the pointer to be atomic? I think it's equivalent to: will stage 2 lead to undefined behavior if the pointer is not atomic? Ideally, I want to hear an answer discussing from both a theoretical (language-lawyer) point of view and a practical point of view. For example, if not atomic, stage 2 may be undefined behavior theoretically, but is practically OK on actual platforms. For implementing shared pointer, if non-atomic is OK, the managed pointer can be <code>unique_ptr&lt;T&gt;</code>, otherwise it has to be <code>atomic&lt;T*&gt;</code>.</p>\n<p><strong>Update</strong></p>\n<p>I find the standard text (Section 1.10 p21):</p>\n<blockquote>\n<p id=\"so_48854896_48854896_0\">The execution of a program contains a data race if it contains two\n  conflicting actions in different threads, at least one of which is not\n  atomic, and neither happens before the other. Any such data race\n  results in undefined behavior.</p>\n</blockquote>\n<p>I guess concurrent reads do not classify as conflicting actions. Could somebody find some standard text about this to be sure?</p>\n", "AcceptedAnswerId": "48859018", "Title": "Concurrent reads on non-atomic variable", "CreationDate": "2018-02-18T18:02:36.487", "LastActivityDate": "2018-02-19T03:07:42.503", "CommentCount": "7", "LastEditDate": "2018-02-18T18:50:21.310", "PostTypeId": "1", "LastEditorUserId": "1348273", "Id": "48854896", "Score": "2", "OwnerUserId": "1348273", "Tags": "<c++><c++11><concurrency><language-lawyer><atomic>", "AnswerCount": "4"}, "48854930": {"Id": "48854930", "PostTypeId": "2", "Body": "<p>The rule is that if more than one thread accesses the same object at the same time and at least one of those threads is modifying the data, then you have a data race, and the behavior of the program is undefined. If nobody is modifying the object there is no problem from the concurrent accesses.</p>\n", "LastActivityDate": "2018-02-18T18:05:36.820", "Score": "3", "CreationDate": "2018-02-18T18:05:36.820", "ParentId": "48854896", "CommentCount": "2", "OwnerUserId": "1593860"}, "48859018": {"Id": "48859018", "PostTypeId": "2", "Body": "<p>Concurrent reads on any variable, whether atomic or not, do not constitute a data race, because of the definition of conflicting evaluations, found in <code>[intro.multithread]</code>:</p>\n<blockquote>\n<p id=\"so_48854896_48859018_0\">Two expression evaluations <em>conflict</em> if one of them modifies a memory location and the other one accesses or modifies the same memory location.</p>\n</blockquote>\n<p>Recently, this has moved to <code>[intro.races]</code> with a very subtle change in wording </p>\n<blockquote>\n<p id=\"so_48854896_48859018_1\">Two expression evaluations <em>conflict</em> if one of them modifies a memory location and the other one reads or modifies the same memory location.</p>\n</blockquote>\n<p>The change from <em>accesses</em> to <em>reads</em> took place between draft n4296 and n4431.  The splitting of the multithreading section took place between n4582 and n4604.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2018-02-19T03:07:42.503", "Score": "1", "CreationDate": "2018-02-19T03:01:40.427", "ParentId": "48854896", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2018-02-19T03:07:42.503"}});