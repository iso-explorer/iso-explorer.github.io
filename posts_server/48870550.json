post_cb({"48871232": {"Id": "48871232", "PostTypeId": "2", "Body": "<p>Clang is correct.</p>\n<p>Your confusion comes from:</p>\n<blockquote>\n<p id=\"so_48870550_48871232_0\">From <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow noreferrer\">cppreference</a> I would have suspected that both should result in the same (i.e. value initialization). </p>\n</blockquote>\n<p>No they have different effects. Note the notes in that page:</p>\n<blockquote>\n<p id=\"so_48870550_48871232_1\">In all cases, if the empty pair of braces {} is used and T is an aggregate type, aggregate-initialization is performed instead of value-initialization.</p>\n</blockquote>\n<p>That means when initialized with braced-init-list, for aggregate type, aggregate-initialization is preferred to be performed. With <code>A() : m_a{} {}</code>, and <code>m_a</code> is an array, which belongs to <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization#Explanation\" rel=\"nofollow noreferrer\">aggregate type</a>, then <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">aggregate initialization</a> is performed instead:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_48870550_48871232_2\">Each <code>direct public base, (since C++17)</code> array element, or non-static class member, in order of array subscript/appearance in the class definition, is <strong>copy-initialized</strong> from the corresponding clause of the initializer list.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_48870550_48871232_3\">If the number of initializer clauses is less than the number of members <code>and bases (since C++17)</code> or initializer list is completely empty, the remaining members <code>and bases (since C++17)</code> are initialized <code>by their default initializers, if provided in the class definition, and otherwise (since C++14)</code> by empty lists, in accordance with the usual list-initialization rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). </p>\n</blockquote>\n<p>That means, the remaining elements, i.e. all the 3 elements of <code>m_a</code> will be copy-initialized from the empty list; for empty list the default constructor of <code>S</code> will be considered but it's declared as <code>explicit</code>; the <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\">copy-initialization</a> won't invoke <code>explicit</code> constructors:</p>\n<blockquote>\n<p id=\"so_48870550_48871232_4\">copy-list-initialization (both explicit and non-explicit constructors are considered, but only non-explicit constructors may be called)</p>\n</blockquote>\n<hr>\n<p>On the other hand, <code>A() : m_a() {}</code> performs <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow noreferrer\">value initialization</a>, then</p>\n<blockquote>\n<p id=\"so_48870550_48871232_5\">3) if T is an array type, each element of the array is value-initialized;</p>\n</blockquote>\n<p>then</p>\n<blockquote>\n<p id=\"so_48870550_48871232_6\">1) if T is a class type with no default constructor or with a user-provided or deleted default constructor, the object is default-initialized;</p>\n</blockquote>\n<p>then the default constructor of <code>S</code> is invoked to initialize the elements of <code>m_a</code>. Whether it's <code>explicit</code> or not doesn't matter for <a href=\"http://en.cppreference.com/w/cpp/language/default_initialization\" rel=\"nofollow noreferrer\">default initialization</a>.</p>\n</hr>", "LastEditorUserId": "3309790", "LastActivityDate": "2018-02-20T03:54:00.243", "Score": "10", "CreationDate": "2018-02-19T17:26:50.527", "ParentId": "48870550", "CommentCount": "1", "OwnerUserId": "3309790", "LastEditDate": "2018-02-20T03:54:00.243"}, "48871317": {"Id": "48871317", "PostTypeId": "2", "Body": "<p>If I understand the standard correctly clang is correct.</p>\n<p>According to [dcl.init.aggr]/8.5.1:2</p>\n<blockquote>\n<p id=\"so_48870550_48871317_0\">When an aggregate is initialized by an initializer list, as specified\n  in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order. Each member is copy-initialized from the\n  corresponding initializer-clause.</p>\n</blockquote>\n<p>And further down in the same clause [dcl.init.aggr]/8.5.1:7</p>\n<blockquote>\n<p id=\"so_48870550_48871317_1\">If there are fewer initializer-clauses in the list than there are\n  members in the aggregate, then each member not explicitly initialized\n  shall be initialized from its brace-or-equal-initializer or, if there\n  is no brace-or-equal- initializer, from an empty initializer list</p>\n</blockquote>\n<p>According to the rules for list initialization [over.match.list]/13.3.1.7</p>\n<blockquote>\n<p id=\"so_48870550_48871317_2\">In copy-list-initialization, if an explicit constructor is chosen, the\n  initialization is ill-formed.</p>\n</blockquote>\n", "LastActivityDate": "2018-02-19T17:32:05.680", "Score": "0", "CreationDate": "2018-02-19T17:32:05.680", "ParentId": "48870550", "CommentCount": "0", "OwnerUserId": "3668462"}, "48870550": {"ViewCount": "601", "Body": "<pre><code>#include&lt;cstddef&gt;\n\ntemplate&lt;typename T, std::size_t N&gt;\nstruct A {\n    T m_a[N];\n    A() : m_a{} {}\n};\n\nstruct S {\n    explicit S(int i=4) {}\n};\n\nint main() {\n    A&lt;S, 3&gt; an;\n}\n</code></pre>\n<p>The above code compiles fine with MSVC (2017), but fails with clang 3.8.0 (Output of <code>clang++ --version &amp;&amp; clang++ -std=c++14 -Wall -pedantic main.cpp</code>):</p>\n<pre><code>clang version 3.8.0 (tags/RELEASE_380/final 263969)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /usr/local/bin\nmain.cpp:6:15: error: chosen constructor is explicit in copy-initialization\n    A() : m_a{} {}\n              ^\nmain.cpp:14:13: note: in instantiation of member function 'A&lt;S, 3&gt;::A' requested here\n    A&lt;S, 3&gt; an;\n            ^\nmain.cpp:10:14: note: constructor declared here\n    explicit S(int i=4) {}\n             ^\nmain.cpp:6:15: note: in implicit initialization of array element 0 with omitted initializer\n    A() : m_a{} {}\n              ^\n1 error generated.\n</code></pre>\n<p>clang 5.0 also refuses to compile this:</p>\n<pre><code>&lt;source&gt;:6:17: error: expected member name or ';' after declaration specifiers\n    A() : m_a{} {}\n                ^\n&lt;source&gt;:6:14: error: expected '('\n    A() : m_a{} {}\n             ^\n2 errors generated.\n</code></pre>\n<p>If I use simple parentheses in <code>A</code>s constructor to (i.e. <code>A() : m_a() {}</code>), it compiles fine. From <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"noreferrer\">cppreference</a> I would have suspected that both should result in the same (i.e. value initialization). Am I missing something or is this a bug in one of the compilers?</p>\n", "AcceptedAnswerId": "48873969", "Title": "Value initialization: MSVC vs clang", "CreationDate": "2018-02-19T16:43:51.210", "LastActivityDate": "2018-02-20T03:54:00.243", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2018-02-19T17:55:38.917", "LastEditorUserId": "3309790", "Id": "48870550", "Score": "16", "OwnerUserId": "255688", "Tags": "<c++><visual-studio><initialization><clang><language-lawyer>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_48870550_48871317_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 3299}, "so_48870550_48873969_5": {"length": 4, "quality": 1.0, "section_id": 3286}, "so_48870550_48873969_8": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_48870550_48871317_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 3304}, "so_48870550_48873969_1": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_48870550_48870851_3": {"length": 62, "quality": 0.9117647058823529, "section_id": 3296}, "so_48870550_48871317_2": {"length": 6, "quality": 1.0, "section_id": 599}, "so_48870550_48871232_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 3287}, "so_48870550_48870851_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 3299}, "so_48870550_48873969_3": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_48870550_48873969_4": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_48870550_48873969_6": {"length": 15, "quality": 0.7142857142857143, "section_id": 592}, "so_48870550_48871232_6": {"length": 10, "quality": 1.0, "section_id": 3287}, "so_48870550_48870851_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 3323}}, "n3337": {"so_48870550_48871317_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 3169}, "so_48870550_48873969_5": {"length": 4, "quality": 1.0, "section_id": 3156}, "so_48870550_48873969_1": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_48870550_48871317_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 3174}, "so_48870550_48873969_8": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_48870550_48870851_3": {"length": 62, "quality": 0.9117647058823529, "section_id": 3166}, "so_48870550_48871317_2": {"length": 6, "quality": 1.0, "section_id": 589}, "so_48870550_48871232_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 3157}, "so_48870550_48870851_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 3169}, "so_48870550_48873969_3": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_48870550_48873969_4": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_48870550_48873969_6": {"length": 15, "quality": 0.7142857142857143, "section_id": 582}, "so_48870550_48871232_6": {"length": 8, "quality": 0.8, "section_id": 3157}, "so_48870550_48870851_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 3193}}, "n4659": {"so_48870550_48871317_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 4065}, "so_48870550_48873969_3": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_48870550_48873969_1": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_48870550_48871317_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 4070}, "so_48870550_48873969_2": {"length": 8, "quality": 0.8, "section_id": 4070}, "so_48870550_48870851_3": {"length": 62, "quality": 0.9117647058823529, "section_id": 4058}, "so_48870550_48871317_2": {"length": 6, "quality": 1.0, "section_id": 622}, "so_48870550_48871232_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 4048}, "so_48870550_48870851_1": {"length": 9, "quality": 0.6, "section_id": 4065}, "so_48870550_48870851_2": {"length": 15, "quality": 0.7894736842105263, "section_id": 4070}, "so_48870550_48873969_6": {"length": 19, "quality": 0.9047619047619048, "section_id": 615}, "so_48870550_48871232_6": {"length": 10, "quality": 1.0, "section_id": 4049}, "so_48870550_48870851_0": {"length": 33, "quality": 0.8461538461538461, "section_id": 4089}}}, "48873969": {"Id": "48873969", "PostTypeId": "2", "Body": "<p>For <code>m_a{}</code>:</p>\n<ul>\n<li><p><a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#17.1\" rel=\"nofollow noreferrer\">[dcl.init]/17.1</a> sends us to <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.list\" rel=\"nofollow noreferrer\">[dcl.init.list]</a>, and <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.list#3.4\" rel=\"nofollow noreferrer\">[dcl.init.list]/3.4</a> says that we perform aggregate initialization on <code>m_a</code> per <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.aggr\" rel=\"nofollow noreferrer\">[dcl.init.aggr]</a>.</p>\n<blockquote>\n<p id=\"so_48870550_48873969_0\">The semantics of initializers are as follows. [...]</p>\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em> or is <code>=</code> <em>braced-init-list</em>, the object or reference is list-initialized.</li>\n<li>[...]</li>\n</ul>\n<hr>\n<p id=\"so_48870550_48873969_1\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>[...]</li>\n<li>Otherwise, if <code>T</code> is an aggregate, aggregate initialization is performed.</li>\n<li>[...]</li>\n</ul>\n</hr></blockquote></li>\n<li><p><a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.aggr#5.2\" rel=\"nofollow noreferrer\">[dcl.init.aggr]/5.2</a> says that we copy-initialize each element of <code>m_a</code> from an empty initializer list, i.e., <code>{}</code>.</p>\n<blockquote>\n<p id=\"so_48870550_48873969_2\">For a non-union aggregate, each element that is not an explicitly initialized element is initialized as follows:</p>\n<ul>\n<li>[...]</li>\n<li>Otherwise, if the element is not a reference, the element is copy-initialized from an empty initializer list ([dcl.init.list]).</li>\n<li>[...]</li>\n</ul>\n</blockquote></li>\n<li>This sends us back to <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#17.1\" rel=\"nofollow noreferrer\">[dcl.init]/17.1</a> for the initialization of each element, which again sends us to <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.list\" rel=\"nofollow noreferrer\">[dcl.init.list]</a>.</li>\n<li><p>This time we hit <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.list#3.5\" rel=\"nofollow noreferrer\">[dcl.init.list]/3.5</a>, which says that the element is value-initialized.</p>\n<blockquote>\n<p id=\"so_48870550_48873969_3\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>[...]</li>\n<li>Otherwise, if the initializer list has no elements and <code>T</code> is a class type with a default constructor, the object is value-initialized.</li>\n<li>[...]</li>\n</ul>\n</blockquote></li>\n<li><p>Which brings us to <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#8.1\" rel=\"nofollow noreferrer\">[dcl.init]/8.1</a>, which says that the element is default-initialized.</p>\n<blockquote>\n<p id=\"so_48870550_48873969_4\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type with either no default constructor ([class.ctor]) or a default constructor that is user-provided or deleted, then the object is default-initialized;</li>\n<li>[...]</li>\n</ul>\n</blockquote></li>\n<li><p>Which hits <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#7.1\" rel=\"nofollow noreferrer\">[dcl.init]/7.1</a>, which says we enumerate constructors per <a href=\"https://timsong-cpp.github.io/cppwp/over.match.ctor\" rel=\"nofollow noreferrer\">[over.match.ctor]</a> and perform overload resolution on the initializer <code>()</code>;</p>\n<blockquote>\n<p id=\"so_48870550_48873969_5\">To <em>default-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>If <code>T</code> is a (possibly cv-qualified) class type, constructors are considered. The applicable constructors are enumerated\n  ([over.match.ctor]), and the best one for the <em>initializer</em> <code>()</code> is\n  chosen through overload resolution. The constructor thus selected is\n  called, with an empty argument list, to initialize the object.</li>\n<li>[...]</li>\n</ul>\n</blockquote></li>\n<li><p>and [over.match.ctor] says:</p>\n<blockquote>\n<p id=\"so_48870550_48873969_6\">For direct-initialization <strong>or default-initialization that is not in the\n  context of copy-initialization</strong>, the candidate functions are all the\n  constructors of the class of the object being initialized. For\n  copy-initialization, the candidate functions are all the converting\n  constructors of that class.</p>\n</blockquote></li>\n<li><p>This default-initialization <em>is</em> in the context of copy-initialization, so the candidate functions are \"all the converting constructors of that class\".</p></li>\n<li>The explicit default constructor is not a converting constructor. As a result, there is no viable constructor. Hence overload resolution fails, and the program is ill-formed.</li>\n</ul>\n<p>For <code>m_a()</code>:</p>\n<ul>\n<li><p>We hit <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#17.4\" rel=\"nofollow noreferrer\">[dcl.init]/17.4</a>, which says that the array is value-initialized.</p>\n<blockquote>\n<p id=\"so_48870550_48873969_7\">The semantics of initializers are as follows. [...]</p>\n<ul>\n<li>[...]</li>\n<li>If the initializer is <code>()</code>, the object is value-initialized.</li>\n<li>[...]</li>\n</ul>\n</blockquote></li>\n<li><p>Which brings us to <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#8.3\" rel=\"nofollow noreferrer\">[dcl.init]/8.3</a>, which says that each element is value-initialized.</p>\n<blockquote>\n<p id=\"so_48870550_48873969_8\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>[...]</li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;</li>\n<li>[...]</li>\n</ul>\n</blockquote></li>\n<li><p>Which again brings us to <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#8.1\" rel=\"nofollow noreferrer\">[dcl.init]/8.1</a>, and then to <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#7.1\" rel=\"nofollow noreferrer\">[dcl.init]/7.1</a>, and so we again enumerate constructors per <a href=\"https://timsong-cpp.github.io/cppwp/over.match.ctor\" rel=\"nofollow noreferrer\">[over.match.ctor]</a> and perform overload resolution on the initializer <code>()</code>;</p></li>\n<li>This time, the default-initialization <em>is not</em> in the context of copy-initialization, so the candidate functions are \"all the constructors of the class of the object being initialized\".</li>\n<li>This time, the explicit default constructor <em>is</em> a candidate and selected by overload resolution. So the program is well-formed.</li>\n</ul>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2018-02-19T20:56:39.210", "Score": "3", "CreationDate": "2018-02-19T20:50:53.113", "ParentId": "48870550", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2018-02-19T20:56:39.210"}, "48870851": {"Id": "48870851", "PostTypeId": "2", "Body": "<p>This is explicitly ill-formed by the Standard (the question is, though, why?):</p>\n<p><code>m_a{}</code> list-initializes the <code>S::m_a</code>:</p>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/dcl.init#list-1\" rel=\"nofollow noreferrer\"><code>[dcl.init.list]/1</code></a></h3>\n<p id=\"so_48870550_48870851_0\"><em>List-initialization</em> is initialization of an object or reference from a <em>braced-init-list</em>.\n  Such an initializer is called an initializer list, and the comma-separated <em>initializer-clauses</em> of the <em>initializer-list</em> or <em>designated-initializer-clauses</em> of the <em>designated-initializer-list</em> are called the elements of the initializer list. An initializer list may be empty. List-initialization can occur in <em>direct-initialization</em> or <em>copy-initialization</em> contexts; <em>list-initialization</em> in a <em>direct-initialization</em> context is called <em>direct-list-initialization</em> and <em>list-initialization</em> in a <em>copy-initialization</em> context is called <em>copy-list-initialization</em>.</p>\n</blockquote>\n<p>As an array, <code>A&lt;S, 3&gt;::m_a</code> is an aggregate type (<a href=\"http://eel.is/c++draft/dcl.init.aggr\" rel=\"nofollow noreferrer\"><code>[dcl.init.aggr]/1</code></a>).</p>\n<blockquote id=\"so_48870550_48870851_1\">\n<h3><a href=\"http://eel.is/c++draft/dcl.init.aggr#3.3\" rel=\"nofollow noreferrer\"><code>[dcl.init.aggr]/3.3</code></a></h3>\n<ol start=\"3\">\n<li>When an aggregate is initialized by an initializer list as specified in [dcl.init.list], [...]<br>\n  3.3 the initializer list must be <code>{}</code>, and there are no explicitly initialized elements.</br></li>\n</ol>\n</blockquote>\n<p>following, since <em>there are no explicitly initialized elements</em>:</p>\n<blockquote id=\"so_48870550_48870851_2\">\n<h3><a href=\"http://eel.is/c++draft/dcl.init.aggr#5.2\" rel=\"nofollow noreferrer\"><code>[dcl.init.aggr]/5.2</code></a></h3>\n<ol start=\"5\">\n<li>For a non-union aggregate, each element that is not an explicitly initialized element is initialized as follows: [...]<br>\n  5.2 if the element is not a reference, the element is <em>copy-initialized</em> from an empty initializer list (<code>[dcl.init.list]</code>).</br></li>\n</ol>\n</blockquote>\n<p>Each <code>S</code> of <code>A&lt;S, 3&gt;::m_a</code> is, then, <em>copy-initialized</em>:</p>\n<blockquote id=\"so_48870550_48870851_3\">\n<h3><a href=\"http://eel.is/c++draft/dcl.init#17.6.3\" rel=\"nofollow noreferrer\"><code>[dcl.init]/17.6.3</code></a></h3>\n<ol start=\"17\">\n<li>The semantics of initializers are as follows.\n  The <em>destination type</em> is the type of the object or reference being initialized and the <em>source type</em> is the type of the initializer expression.\n  If the initializer is not a single (possibly parenthesized) expression, the source type is not defined. [...]<br>\n  17.6 If the destination type is a (possibly cv-qualified) class type: [...]<br>\n  17.6.3 Otherwise (i.e., for the remaining <em>copy-initialization</em> cases), user-defined <strong>conversion sequences that can convert</strong> from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in [over.match.copy], and the best one is chosen through overload resolution.\n  <strong>If the conversion cannot be done or is ambiguous, the initialization is ill-formed.</strong> </br></br></li>\n</ol>\n</blockquote>\n<p>Since the default constructor of <code>S</code> is explicit, it <em>cannot convert from the source type to the destination type</em> (<code>S</code>).</p>\n<p>The syntax using <code>m_a()</code> is, on the other hand, not <em>aggregate member initialization</em> and does not invoke <em>copy-initialization</em>.</p>\n", "LastEditorUserId": "5470596", "LastActivityDate": "2018-02-19T17:49:10.073", "Score": "2", "CreationDate": "2018-02-19T17:03:07.823", "ParentId": "48870550", "CommentCount": "8", "OwnerUserId": "5470596", "LastEditDate": "2018-02-19T17:49:10.073"}});