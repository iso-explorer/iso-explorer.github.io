post_cb({"37584243": {"ParentId": "37577080", "CommentCount": "0", "CreationDate": "2016-06-02T06:28:39.630", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "37584243", "Score": "2", "Body": "<p>There's one \"pathological\" case that comes to mind: non-copyable and non-movable objects. Such an object <em>cannot</em> be stored by value, so holding it by a reference is your only chance:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Immovable\n{\n    Immovable(int i) : i(i) {}\n\n    Immovable(const Immovable&amp;) = delete;\n    Immovable(Immovable&amp;&amp;) = delete;\n\n    const int i;\n};\n\n\nImmovable factory()\n{\n    return {42};\n}\n\n\nint main()\n{\n    const Immovable &amp;imm = factory();\n    std::cout &lt;&lt; imm.i;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/65e4cf017fa015e7\" rel=\"nofollow\">[Live example]</a></p>\n<p>On a less contrived note, you dismissed the \"heavy object\" optimisation by citing copy elision. Note, however, that copy elision is <em>optional.</em> You can never guarantee that the compiler will do it. Storing the temporary in a <code>const &amp;</code>, on the contrary, <em>guarantees</em> that no copying or moving will happen.</p>\n", "LastActivityDate": "2016-06-02T06:28:39.630"}, "37577080": {"CommentCount": "12", "ViewCount": "116", "PostTypeId": "1", "LastEditorUserId": "5241642", "CreationDate": "2016-06-01T19:19:27.123", "LastActivityDate": "2016-06-02T16:36:12.417", "Title": "What problems are solved by holding a Temporary using `const T &`?", "AcceptedAnswerId": "37577203", "LastEditDate": "2016-06-01T20:19:56.523", "Id": "37577080", "Score": "0", "Body": "<p>Like, if I write code that looks like the following:</p>\n<pre><code>const int &amp; const_value = 10;\n</code></pre>\n<p>What advantage am I gaining over code that would instead look like this:</p>\n<pre><code>int value = 10;\n</code></pre>\n<p>or</p>\n<pre><code>const int const_value = 10;\n</code></pre>\n<p>Even for a more complicated example, like</p>\n<pre><code>const enterprise::complicated_class_which_takes_time_to_construct &amp; obj = factory.create_instance();\n</code></pre>\n<p>Thanks to copy elision, both of the following code snippets shouldn't be significantly faster or less memory consuming.</p>\n<pre><code>enterprise::complicated_class_which_takes_time_to_construct obj = factory.create_instance();\n</code></pre>\n<p>or </p>\n<pre><code>const enterprise::complicated_class_which_takes_time_to_construct obj = factory.create_instance();\n</code></pre>\n<p>Is there something I'm missing that explains the use of this construct, or a hidden benefit I'm not accounting for?</p>\n<h1>Edit:</h1>\n<p>The answer provided by @nwp supplied the example of a factory method that looks like the following:</p>\n<pre><code>using cc = enterprise::complicated_class_which_takes_time_to_construct;\nstruct Factory{\n    const cc &amp;create_instance(){\n        static const cc instance;\n        return instance;\n    }\n} factory;\n</code></pre>\n<p>While this is a good example of why you'd need the exact <code>const reference</code> construct in general, it doesn't answer why it would be needed for dealing with temporaries, or why this particular construct would be better than just seating the temporary in a proper stack-allocated object, which the compiler should still be able to copy-elide in normal situations.</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "5241642", "AnswerCount": "3"}, "37585451": {"ParentId": "37577080", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-06-02T07:34:43.510", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:57.480", "Id": "37585451", "OwnerUserId": "464581", "Body": "<p>The rationale for the lifetime extension rule is known \u00b9(<a href=\"https://stackoverflow.com/questions/20546981/what-is-the-rationale-for-extending-the-lifetime-of-temporaries\">because Bjarne Stroustrup, the language creator, said so</a>) to be to have uniform simple rules. In particular, the lifetime of a temporary used as actual argument in a function call, is extended to the end of the full-expression, covering the lifetime of any reference that it's bound to. And the rule for local reference to <code>const</code>, or local rvalue reference, makes that aspect of the behavior the same.</p>\n<hr>\n<p>In C++03 one practical use case, as far as I know \u00b2<a href=\"http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758\" rel=\"nofollow noreferrer\">invented by Petru Marginean</a>, was to create a local object of an unknown automatically deduced type, like this:</p>\n<pre><code>Base const&amp; o = foo( arg1, arg2, arg3 );\n</code></pre>\n<p>This works when <code>Base</code> is an accessible base class of any possible <code>foo</code>  result type, because the lifetime extension mechanism does not slice: it extends the lifetime of the full temporary object. When <code>foo</code> returns a <code>T</code> it's a complete <code>T</code> object that has its lifetime extended. The compiler knows <code>T</code> even though the programmer may not necessarily know <code>T</code>.</p>\n<p>Of course, in C++11 and later one can instead, generally, use <code>auto</code>:</p>\n<pre><code> auto const o = foo( arg1, arg2, arg3 );\n</code></pre>\n<p>With return value optimization and/or moving this will be just as efficient as Marginean's trick, and it's more clear and simple.</p>\n<hr>\n<p>However, when the type <code>T</code> is non-movable <em>and</em> non-copyable, then binding to a reference with lifetime extension of the temporary, appears to be the only way to hold on to it, which is a second use case.</p>\n<hr>\n<p>Now, surprise?, the type <code>T</code> of the full temporary object needs not be derived from the statically known type. It's enough that compiler knows that you're holding a reference to <em>a part</em> of the temporary. Whether that part is a base class sub-object, or some other sub-object, doesn't matter, so you can do:</p>\n<pre><code>auto const&amp; part = foo( arg1, arg2, arg3 ).a_part;\n</code></pre>\n<p>Which is a third use case, which is only about not introducing an otherwise never used name for the complete object, keeping the code simple.</p>\n<hr>\n<p>Standardese about the hold-on-to-a-part (and thus the whole object) case:</p>\n<b>C++15 \u00a712.2/5</b> [class.temporary]\n\n<blockquote>\n<p id=\"so_37577080_37585451_0\"><strong>\u201d</strong> The temporary to which the reference is\n  bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except \u2026</p>\n</blockquote>\n<p>The exceptions include that a temporary used as actual argument in a function call, persists till the end of the full-expression, i.e. a bit longer than any formal argument reference that it's bound to.</p>\n<hr>\n<p><sup>\n\u00b9 In <a href=\"https://groups.google.com/d/msg/comp.lang.c++/nSlM8t2bUd0/h4I3x6kuMK4J\" rel=\"nofollow noreferrer\">an exchange with me in the Usenet group <em>comp.lang.c++</em></a>.<br>\n\u00b2 In the C++03 implementation of the <code>ScopeGuard</code> class, which was invented by Petru. In C++11 a <code>ScopeGuard</code> can be trivially implemented using <code>std::function</code> and <code>auto</code> in the client code's dceclaration.\n</br></sup></p>\n</hr></hr></hr></hr></hr>", "LastActivityDate": "2016-06-02T16:36:12.417"}, "bq_ids": {"n4140": {"so_37577080_37585451_0": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_37577080_37585451_0": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_37577080_37585451_0": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}}}, "37577203": {"ParentId": "37577080", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2016-06-01T19:25:46.683", "Score": "2", "LastEditorUserId": "3484570", "LastEditDate": "2016-06-02T07:40:15.040", "Id": "37577203", "OwnerUserId": "3484570", "Body": "<p>Imagine the factory is \"clever\" and does something like</p>\n<pre><code>using cc = enterprise::complicated_class_which_takes_time_to_construct;\nstruct Factory{\n    const cc &amp;create_instance(){\n        static const cc instance;\n        return instance;\n    }\n} factory;\n</code></pre>\n<p>and further assume <code>cc</code> is not copyable then the <code>const &amp;</code> version works while the other 2 don't. This is fairly common for classes that implement a cache and keep a local <code>map</code> of objects and you get a reference to the object inside the map.</p>\n<p>Edit:</p>\n<p>It is possible a coding guideline would say <em>Take return values from functions by <code>const &amp;</code></em>, because that works universally with values and references.</p>\n<pre><code>cc foo();\ncc &amp;foo();\nconst cc &amp;foo();\n</code></pre>\n<p>If you use <code>const cc &amp;var = foo();</code> it will work without an unnecessary copy in all the cases. Sometimes you get a temporary, sometimes you don't, but the code always does the right thing, freeing you to change the implementation and to not having to care about how the function you use returns its return-value. There is still the issue of having a <code>const</code> in there, so it is not the superior notation in all cases, but it is a viable design choice.</p>\n", "LastActivityDate": "2016-06-02T07:40:15.040"}});