post_cb({"bq_ids": {"n4140": {"so_27423497_27423497_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 3107}, "so_27423497_27423497_1": {"length": 15, "quality": 0.9375, "section_id": 3107}}, "n3337": {"so_27423497_27423497_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 2984}, "so_27423497_27423497_1": {"length": 15, "quality": 0.9375, "section_id": 2984}}, "n4659": {"so_27423497_27423497_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 3869}, "so_27423497_27423497_1": {"length": 15, "quality": 0.9375, "section_id": 3869}}}, "27423866": {"Id": "27423866", "PostTypeId": "2", "Body": "<p>A normal <code>std::future</code> is not threadsafe by itself. So yes it is UB, if you call modifying functions from multiple threads on a single <code>std::future</code> as you have a potential race condition. Though, calling <code>wait</code> from multiple threads is ok as it's const/non-modifying.</p>\n<p>However, if you really need to access the return value of a <code>std::future</code> from multiple threads you can first call <code>std::future::share</code> on the future to get a <a href=\"http://en.cppreference.com/w/cpp/thread/shared_future\" rel=\"noreferrer\"><code>std::shared_future</code></a> which you can copy to each thread and then each thread can call <code>get</code>. Note that it's important that each thread has its own <code>std::shared_future</code> object.</p>\n<p>You only need to check valid if it is somehow possible that your future might be invalid which is not the case for the normal usecases(<code>std::async</code> etc.) and proper usage(e.g.: not callig <code>get</code> twice).</p>\n", "LastEditorUserId": "893693", "LastActivityDate": "2014-12-11T13:56:57.057", "Score": "15", "CreationDate": "2014-12-11T13:20:01.583", "ParentId": "27423497", "CommentCount": "3", "OwnerUserId": "893693", "LastEditDate": "2014-12-11T13:56:57.057"}, "27423497": {"ViewCount": "2237", "Body": "<p>The C++11 standard says:</p>\n<blockquote>\n<p id=\"so_27423497_27423497_0\">30.6.6 Class template future</p>\n<p id=\"so_27423497_27423497_1\">(3) \"The effect of calling any member function other than the destructor,\n  the move-assignment operator, or valid on a future object for which\n  <code>valid() == false</code> is undefined.\"</p>\n</blockquote>\n<p>So, does it mean that the following code might encounter undefined behaviour?</p>\n<pre><code>void wait_for_future(std::future&lt;void&gt; &amp; f)\n{\n    if (f.valid()) {\n        // what if another thread meanwhile calls get() on f (which invalidates f)?\n        f.wait();\n    }\n    else {\n        return;\n    }\n}\n</code></pre>\n<p>Q1: Is this really a possible undefined behaviour?</p>\n<p>Q2: Is there any standard compliant way to avoid the possible undefined behaviour?</p>\n<p>Note that the standard has an interesting note [also in 30.6.6 (3)]:</p>\n<blockquote>\n<p id=\"so_27423497_27423497_2\">\"[Note: Implementations are encouraged\n  to detect this case and throw an object of type future_error with an\n  error condition of <code>future_errc::no_state</code>. \u2014endnote]\"</p>\n</blockquote>\n<p>Q3: Is it ok if I just rely on the standard's note and just use <code>f.wait()</code> without checking <code>f</code>'s validity?</p>\n<pre><code>void wait_for_future(std::future&lt;void&gt; &amp; f)\n{\n    try {\n        f.wait();\n    }\n    catch (std::future_error const &amp; err) {\n        return;\n    }\n}\n</code></pre>\n<h2>EDIT: Summary after receiving the answers and further research on the topic</h2>\n<p>As it turned out, the real problem with my example was <strong>not directly</strong> due to parallel modifications (a single modifying <code>get</code> was called from a single thread, the other thread called <code>valid</code> and <code>wait</code> which shall be safe).</p>\n<p>The real problem was that the <code>std::future</code> object's <code>get</code> function was accessed from a different thread, which is not the intended use case! The <code>std::future</code> object shall only be used from a single thread!</p>\n<p>The only other thread that is involved is the thread that sets the shared state: via return from the function passed to <code>std::async</code> or calling <code>set_value</code> on the related <code>std::promise</code> object, etc.</p>\n<p>More: even <code>wait</code>ing on an <code>std::future</code> object from another thread is not intended behaviour (due to the very same UB as in my example#1). We shall use <code>std::shared_future</code> for this use case, having each thread its own copy of an <code>std::shared_future</code> object. Note that all these are <strong>not</strong> through the same shared <code>std::future</code> object, but through separate (related) objects!</p>\n<p><strong>Bottom line:\nThese objects shall not be shared between threads. Use a separate (related) object in each thread.</strong></p>\n", "AcceptedAnswerId": "27423866", "Title": "Is there a safe way to call wait() on std::future?", "CreationDate": "2014-12-11T12:59:04.710", "Id": "27423497", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-12T08:47:05.540", "LastEditorUserId": "2547845", "LastActivityDate": "2014-12-12T08:47:05.540", "Score": "14", "OwnerUserId": "2547845", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "27423645": {"Id": "27423645", "PostTypeId": "2", "Body": "<p>Futures allow you to store the state from one thread and retrieve it from another. They don't provide any further thread safety.</p>\n<blockquote>\n<p id=\"so_27423497_27423645_0\">Is this really a possible undefined behaviour?</p>\n</blockquote>\n<p>If you have two threads trying to get the future's state without synchronisation, yes. I've no idea why you might do that though.</p>\n<blockquote>\n<p id=\"so_27423497_27423645_1\">Is there any standard compliant way to avoid the possible undefined behaviour?</p>\n</blockquote>\n<p>Only try to get the state from one thread; or, if you genuinely need to share it between threads, use a mutex or other synchronisation.</p>\n<blockquote>\n<p id=\"so_27423497_27423645_2\">Is it ok if I just rely on the standard's note</p>\n</blockquote>\n<p>If you known that the only implementations you need to support follow that recommendation, yes. But there should be no need.</p>\n<blockquote>\n<p id=\"so_27423497_27423645_3\">and just use <code>f.wait()</code> without checking <code>f</code>'s validity?</p>\n</blockquote>\n<p>If you're not doing any weird shenanigans with multiple threads accessing the future, then you can just assume that it's valid until you've retrieved the state (or moved it to another future).</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-12-11T13:49:53.873", "Score": "7", "CreationDate": "2014-12-11T13:07:04.593", "ParentId": "27423497", "CommentCount": "2", "OwnerUserId": "204847", "LastEditDate": "2014-12-11T13:49:53.873"}});