post_cb({"17988574": {"Id": "17988574", "PostTypeId": "2", "Body": "<p>Yes, the situation described in the OP is possible and will result in notifications being lost. Injecting a nice big time delay in the predicate function makes it easy to trigger. <a href=\"http://coliru.stacked-crooked.com/view?id=2fbdababa0a15f4afa9c45d8aaf1f70d-c944ac6b0eed3bfc48b1f78a894f6965\">Here's a demonstration at Coliru</a>. Notice how the program takes 10 seconds to complete (length of the timeout to <code>wait_for</code>) instead of 100 milliseconds (time when the producer inserts an item in the queue). The notification is lost.</p>\n<p>There is an assumption implicit in the design of condition variables that the state of the condition (return value of the predicate) cannot change while the associated mutex is locked. This is not true for this queue implementation since <code>push</code> can change the \"emptiness\" of the queue without holding <code>head_mutex</code>.</p>\n<p>\u00a730.5p3 specifies that <code>wait</code> has three atomic parts:</p>\n<blockquote id=\"so_17984552_17988574_0\">\n<ol>\n<li>the release of the mutex, and entry into the waiting state;</li>\n<li>the unblocking of the wait; and</li>\n<li>the reacquisition of the lock.</li>\n</ol>\n</blockquote>\n<p>Note that none of these mention checking of the predicate, if any was passed to <code>wait</code>. The behavior of <code>wait</code> with a predicate is described in \u00a730.5.1p15:</p>\n<blockquote>\n<p id=\"so_17984552_17988574_1\"><em>Effects:</em>\n<pre>while (!pred())\n      wait(lock);</pre></p>\n</blockquote>\n<p>Note that there is no guarantee here either that the predicate check and the <code>wait</code> are performed atomically. There <em>is</em> a pre-condition that <code>lock</code> is locked and it's associated mutex held by the calling thread.</p>\n<p>As far as <em>fixing</em> the container to avoid loss of notifications, I would change it to a single mutex implementation and be done with it. It's a bit of a stretch to call it fine-grained locking when the <code>push</code> and <code>pop</code> both end up taking the same mutex (<code>tail_mutex</code>) anyway.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2013-08-01T13:30:32.120", "Score": "7", "CreationDate": "2013-08-01T08:15:45.223", "ParentId": "17984552", "CommentCount": "1", "LastEditDate": "2013-08-01T13:30:32.120", "OwnerUserId": "923854"}, "17984717": {"Id": "17984717", "PostTypeId": "2", "Body": "<p><code>data_cond.wait()</code> checks the condition every time it is woken up.  So even though it may have already been checked, it will be checked again after <code>data_cond.notify_one()</code>.  At that point, there is data to be popped (because Thread 2 had just completed a push), and so it returns.  Read more <a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable/wait\" rel=\"nofollow\">here</a>.</p>\n<p>The only thing you should be worrying about is when you call <code>wait_and_pop</code> on an empty queue and then never push any more data onto it.  This code does not have a mechanism for timing out a wait and returning an error (or throwing an exception).</p>\n", "LastActivityDate": "2013-08-01T03:19:00.493", "Score": "0", "CreationDate": "2013-08-01T03:19:00.493", "ParentId": "17984552", "CommentCount": "7", "OwnerUserId": "1553090"}, "17984552": {"ViewCount": "1006", "Body": "<p>Here's a fine-grained locking queue introduced by Anthony Williams in  chapter 6.2.3 C++ Concurrency in Action.</p>\n<pre><code>/*\n    pop only need lock head_mutex and a small section of tail_mutex,push only need\n    tail_mutex mutex.maximum container concurrency.\n*/\ntemplate&lt;typename T&gt; class threadsafe_queue\n{\n    private:\n    struct node\n    {\n        std::shared_ptr&lt;T&gt; data;\n        std::unique_ptr&lt;node&gt; next;\n    }\n    std::mutex head_mutex;   //when change the head lock it.\n    std::unique_ptr&lt;node&gt; head;  \n    std::mutex tail_mutex;   //when change the tail lock it.\n    node* tail;\n    std::condition_variable data_cond;\n\n    node* get_tail()\n    {\n        std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex);\n        return tail;\n    }\n\n    public:\n    /* \n        create a dummy node\n    */\n    threadsafe_queue():\n        head(new node),tail(head.get())\n    {}\n\n    std::shared_ptr&lt;T&gt; wait_and_pop()\n    {\n        std::unique_lock&lt;std::mutex&gt; head_lock;\n        data_cond.wait(head_lock,[&amp;]{return head.get()!=get_tail();}); //#1\n        std::unique_ptr&lt;node&gt; old_head=std::move(head);\n        head=std::move(old_head-&gt;next);\n        return old_head;\n    }\n\n    void push(T new_value)\n    {\n        std::shared_ptr&lt;T&gt; new_data(\n        std::make_shared&lt;T&gt;(std::move(new_value)));\n        std::unique_ptr&lt;node&gt; p(new node);\n        {\n            std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex);\n            tail-&gt;data=new_data;\n            node* const new_tail=p.get();\n            tail-&gt;next=std::move(p);\n            tail=new_tail;\n        }\n        data_cond.notify_one();\n    }\n}\n</code></pre>\n<p>Here's the situation: There are two threads (<code>thread1</code> and <code>thread2</code>). <code>thread1</code> is doing a <code>wait_and_pop</code> and <code>thread2</code> is doing a <code>push</code>. The queue is empty.</p>\n<p><code>thread1</code> is in #2, had already checked <code>head.get()!=get_tail()</code> before <code>data_cond.wait()</code>. At this time its CPU period had run out. <code>thread2</code> begins.</p>\n<p><code>thread2</code> finished the <code>push</code> function and did <code>data_cond.notify_one()</code>. <code>thread1</code> begins again.</p>\n<p>Now <code>thread1</code> begins <code>data_cond.wait()</code>, but it waits forever.</p>\n<p>Would this situation possibly happen ?If so, how to get this container fixed ?</p>\n", "AcceptedAnswerId": "17988574", "Title": "fine-grained locking queue in c++", "CreationDate": "2013-08-01T03:01:27.160", "Id": "17984552", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-08-01T09:03:35.830", "LastEditorUserId": "2390083", "LastActivityDate": "2014-11-14T06:51:28.060", "Score": "3", "OwnerUserId": "987369", "Tags": "<c++><multithreading><concurrency><stl>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17984552_17988574_0": {"length": 10, "quality": 1.0, "section_id": 2979}}, "n3337": {"so_17984552_17988574_0": {"length": 10, "quality": 1.0, "section_id": 2849}}, "n4659": {"so_17984552_17988574_0": {"length": 10, "quality": 1.0, "section_id": 3738}}}});