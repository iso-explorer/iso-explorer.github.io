post_cb({"15126913": {"ParentId": "15126881", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>See <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\"><code>std::vector</code></a> </p>\n<blockquote>\n<p id=\"so_15126881_15126913_0\"><strong>Specializations</strong> </p>\n<p id=\"so_15126881_15126913_1\">The standard library provides a specialization of std::vector for the type bool, which is optimized for space efficiency.<br>\n  vector&lt;bool&gt; space-efficient dynamic bitset\n  (class template specialization)</br></p>\n</blockquote>\n<p>and from \"Working Draft C++, 2012-11-02\" </p>\n<blockquote>\n<p id=\"so_15126881_15126913_2\"><strong>23.3.7 Class vector [vector.bool]</strong><br>\n  1 To optimize space allocation, a specialization of vector for bool elements is provided:<br>\n  template &lt;class Allocator&gt; class vector&lt;bool, Allocator&gt; {<br>\n  ...<br>\n  }  </br></br></br></br></p>\n<p id=\"so_15126881_15126913_3\">3 There is no requirement that the data be stored as a contiguous allocation of bool values. A space-optimized representation of bits is recommended instead.</p>\n</blockquote>\n<p>So there is no requirement, but only a recommendation, to store the <code>bool</code> values as bits.</p>\n", "OwnerUserId": "1741542", "LastEditorUserId": "1741542", "LastEditDate": "2013-02-28T03:42:40.310", "Id": "15126913", "Score": "5", "CreationDate": "2013-02-28T03:31:05.910", "LastActivityDate": "2013-02-28T03:42:40.310"}, "15126881": {"CommentCount": "1", "ViewCount": "552", "CreationDate": "2013-02-28T03:26:47.597", "LastActivityDate": "2013-02-28T03:50:03.643", "Title": "Efficient use of boolean true and false in C++?", "AcceptedAnswerId": "15126901", "PostTypeId": "1", "Id": "15126881", "Score": "1", "Body": "<p>Would any compiler experts be able to comment on the efficient use of boolean values?  Specifically, is the compiler able to optimize a <code>std::vector&lt;boolean&gt;</code> to use minimal memory?  Is there an equivalent data structure that would?</p>\n<p>Back in the day, there were languages that had compilers that could compress an array of booleans to a representation of just one bit per boolean value.  Perhaps the best that could be done for C++ is to use <code>std::vector&lt;char&gt;</code> to store the boolean values for minimal memory usage?</p>\n<p>The use case here would be storing hundreds of millions of boolean values, where a single byte would save lots of space over 4 or more bytes per value and a single bit, even more.</p>\n", "Tags": "<c++><memory><optimization><compiler-construction><storage>", "OwnerUserId": "10578", "AnswerCount": "5"}, "15126991": {"ParentId": "15126881", "CommentCount": "0", "Body": "<p>As a standard-agnostic way of guaranteeing efficient storage, you could create your own <code>Bitvector</code> class. Essentially for every 8 <code>bool</code> values you only need to allocate a single <code>char</code> and then you can store each <code>bool</code> in a single bit. You can then use bit shifting techniques in the accessors/mutators to store/retrieve your individual bits.</p>\n<p>One such example is outlined in Ron Penton and Andr\u00e9 LaMothe's <a href=\"http://rads.stackoverflow.com/amzn/click/1931841942\" rel=\"nofollow\">Data Structures for Game Programmers</a> (which I'd also recommend as a general data structure reference). It's not too difficult to write your own though, and, though I haven't searched at great length, there are probably some further examples on the Internet.</p>\n", "OwnerUserId": "1618592", "PostTypeId": "2", "Id": "15126991", "Score": "0", "CreationDate": "2013-02-28T03:38:26.550", "LastActivityDate": "2013-02-28T03:38:26.550"}, "15127120": {"ParentId": "15126881", "CommentCount": "0", "Body": "<p>Note, that <code>vector&lt;bool&gt;</code> is not a container, however it pretends to be one and provides iterators.\nOne day that may cause confusion and errors if you treat it like a normal container, e.g. trying to get an address of elements.</p>\n<p>You may consider <code>std::bitset</code> or <a href=\"http://www.boost.org/doc/libs/1_53_0/libs/dynamic_bitset/dynamic_bitset.html\" rel=\"nofollow\">boost::dynamic_bitset</a> if you need to store 1 bit per Boolean value. These data structures do not pretend to be containers, so it is unlikely you make any errors when using any of them, especially in template code.</p>\n", "OwnerUserId": "1399622", "PostTypeId": "2", "Id": "15127120", "Score": "1", "CreationDate": "2013-02-28T03:50:03.643", "LastActivityDate": "2013-02-28T03:50:03.643"}, "15126901": {"ParentId": "15126881", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>std::vector for bool is a template specialization that does what you are asking for.</p>\n<p>You can read more <a href=\"http://www.cplusplus.com/reference/vector/vector-bool/\" rel=\"nofollow\">here</a>.</p>\n<p>You may also want to explore the standard <a href=\"http://www.cplusplus.com/reference/bitset/bitset/\" rel=\"nofollow\">bitset</a>.</p>\n", "OwnerUserId": "2105636", "LastEditorUserId": "2105636", "LastEditDate": "2013-02-28T03:35:03.453", "Id": "15126901", "Score": "1", "CreationDate": "2013-02-28T03:29:19.870", "LastActivityDate": "2013-02-28T03:35:03.453"}, "15126903": {"ParentId": "15126881", "CommentCount": "5", "Body": "<p>In what is widely considered to be a flaw in the standard, <a href=\"http://en.cppreference.com/w/cpp/container/vector_bool\" rel=\"nofollow\">std::vector</a> is specialised to use a single bit to represent each <code>bool</code> value.</p>\n<p>If that happens to be what you are looking for, then just use it.</p>\n", "OwnerUserId": "485561", "PostTypeId": "2", "Id": "15126903", "Score": "0", "CreationDate": "2013-02-28T03:29:48.140", "LastActivityDate": "2013-02-28T03:29:48.140"}, "bq_ids": {"n4140": {"so_15126881_15126913_3": {"section_id": 994, "quality": 1.0, "length": 13}}, "n3337": {"so_15126881_15126913_3": {"section_id": 979, "quality": 1.0, "length": 13}}, "n4659": {"so_15126881_15126913_3": {"section_id": 1057, "quality": 1.0, "length": 13}}}});