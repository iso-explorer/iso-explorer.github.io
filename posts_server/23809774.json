post_cb({"23814084": {"ParentId": "23809774", "CommentCount": "0", "CreationDate": "2014-05-22T17:58:22.513", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "23814084", "Score": "5", "Body": "<p>Since <code>T</code> is a template parameter, the expression <code>t</code> is type-dependent and hence <code>foo</code> is a dependent name in the function call <code>foo(t)</code>. [temp.dep.candidate] 14.6.4.2/1 says:</p>\n<blockquote>\n<p id=\"so_23809774_23814084_0\">For a function call that depends on a template parameter, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2, 3.4.3) except that:</p>\n<ul>\n<li><p id=\"so_23809774_23814084_1\">For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only function declarations from the template definition context are found.</p></li>\n<li><p id=\"so_23809774_23814084_2\">For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</p></li>\n</ul>\n<p id=\"so_23809774_23814084_3\">If the function name is an <em>unqualified-id</em> and the call would be ill-formed or would find a better match had the lookup within the associated namespaces considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just considering those declarations found in the template definition and template instantiation contexts, then the program has undefined behavior.</p>\n</blockquote>\n<p>When instantiating <code>S&lt;double&gt;::foobar</code>, <code>T</code> is obviously <code>double</code> and has no associated namespaces. So the only declarations of <code>foo</code> that will be found are those from the template definition context (<code>void foo(int)</code>) as described in the first bullet.</p>\n<p>When instantiating <code>S&lt;A&gt;::foobar</code>, <code>T</code> is <code>A</code>. Declarations of <code>foo</code> from both the definition context </p>\n<ul>\n<li><p><code>void foo(int)</code></p>\n<p><em>and</em> from <code>A</code>'s associated namespace (the global namespace) are found:</p></li>\n<li><p><code>inline void foo( A ) { std::cout &lt;&lt; \"foo(A)\" &lt;&lt; std::endl; }</code></p></li>\n<li><code>inline void foo( double ) { std::cout &lt;&lt; \"foo(double)\" &lt;&lt; std::endl; }</code></li>\n</ul>\n<p>Clearly <code>void foo(A)</code> is the best match.</p>\n", "LastActivityDate": "2014-05-22T17:58:22.513"}, "23810012": {"ParentId": "23809774", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-05-22T14:41:10.473", "Score": "5", "LastEditorUserId": "2617660", "LastEditDate": "2014-05-22T15:10:18.107", "Id": "23810012", "OwnerUserId": "2617660", "Body": "<p>Just define foo(double) before S :</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A { A(int){} };\n\nvoid foo( int ) { std::cout &lt;&lt; \"foo(int)\" &lt;&lt; std::endl; }\ninline void foo( double ) { std::cout &lt;&lt; \"foo(double)\" &lt;&lt; std::endl; } //here\ninline void foo( A ) { std::cout &lt;&lt; \"foo(A)\" &lt;&lt; std::endl; }\n\ntemplate&lt; typename T &gt;\nstruct S {\n   void bar() { foo( 5 ); }\n   void foobar() { T t = 5; foo(t); }\n};\n\nint main(int argc, char* argv[])\n{\n   S&lt;double&gt; s0;\n   s0.bar();\n   s0.foobar();\n\n   std::cout &lt;&lt; '\\n';\n\n   S&lt;A&gt; s1;\n   s1.bar();\n   s1.foobar();\n}\n</code></pre>\n<p>output : </p>\n<blockquote>\n<p id=\"so_23809774_23810012_0\">foo(int) foo(double)</p>\n<p id=\"so_23809774_23810012_1\">foo(int) foo(A)</p>\n</blockquote>\n<p>EDIT : \nSo S::foo is a non-dependent name and is resolved  when the template is defined \nand S::foobar is a dependant name and is resolved when when the template is instantiated.</p>\n<p>This is why <code>s1.foobar</code> can print A (because foo(A) is defined at this point)</p>\n", "LastActivityDate": "2014-05-22T15:10:18.107"}, "bq_ids": {"n4140": {"so_23809774_23814084_3": {"section_id": 224, "quality": 0.9487179487179487, "length": 37}, "so_23809774_23814084_0": {"section_id": 224, "quality": 0.5882352941176471, "length": 10}, "so_23809774_23814084_2": {"section_id": 224, "quality": 0.8888888888888888, "length": 16}, "so_23809774_23814084_1": {"section_id": 224, "quality": 0.6666666666666666, "length": 12}}, "n3337": {"so_23809774_23814084_3": {"section_id": 217, "quality": 1.0, "length": 39}, "so_23809774_23814084_0": {"section_id": 217, "quality": 0.7647058823529411, "length": 13}, "so_23809774_23814084_2": {"section_id": 217, "quality": 0.8888888888888888, "length": 16}, "so_23809774_23814084_1": {"section_id": 217, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_23809774_23814084_0": {"section_id": 232, "quality": 0.5882352941176471, "length": 10}, "so_23809774_23814084_1": {"section_id": 232, "quality": 0.6666666666666666, "length": 12}, "so_23809774_23814084_3": {"section_id": 232, "quality": 0.9487179487179487, "length": 37}, "so_23809774_23814084_2": {"section_id": 232, "quality": 0.8888888888888888, "length": 16}}}, "23809774": {"CommentCount": "0", "AcceptedAnswerId": "23814084", "CreationDate": "2014-05-22T14:30:59.297", "LastActivityDate": "2014-05-22T17:58:22.513", "PostTypeId": "1", "ViewCount": "78", "FavoriteCount": "1", "Title": "Two-phase name lookup: PODs vs. custom types", "Id": "23809774", "Score": "3", "Body": "<p>When compiling and running the code</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A { A(int){} };\n\nvoid foo( int ) { std::cout &lt;&lt; \"foo(int)\" &lt;&lt; std::endl; }\n\ntemplate&lt; typename T &gt;\nstruct S {\n   void bar() { foo( 5 ); }\n   void foobar() { T t = 5; foo(t); }\n};\n\ninline void foo( A ) { std::cout &lt;&lt; \"foo(A)\" &lt;&lt; std::endl; }\ninline void foo( double ) { std::cout &lt;&lt; \"foo(double)\" &lt;&lt; std::endl; }\n\nint main(int argc, char* argv[])\n{\n   S&lt;double&gt; s0;\n   s0.bar();\n   s0.foobar();\n\n   std::cout &lt;&lt; '\\n';\n\n   S&lt;A&gt; s1;\n   s1.bar();\n   s1.foobar();\n}\n</code></pre>\n<p>I get the output (using g++ 4.8, clang++ 3.2 or icpc 13.1)</p>\n<pre><code>foo(int)\nfoo(int)\n\nfoo(int)\nfoo(A)\n</code></pre>\n<p>While the last two lines make perfect sense to me considering the two-phase lookup rules, I would expect <code>foo(int) foo(double)</code> for the first two lines.</p>\n<p>It seems that in this case for the <code>foobar()</code> call <code>foo()</code> gets looked up before instantiation which should not be possible. Any hints?</p>\n", "Tags": "<c++><templates><name-lookup>", "OwnerUserId": "1323795", "AnswerCount": "2"}});