post_cb({"42428557": {"ParentId": "38158702", "CommentCount": "0", "Body": "<p>Yes. You're relying on, from [temp.arg.explicit]:</p>\n<blockquote>\n<p id=\"so_38158702_42428557_0\">A trailing template parameter pack (14.5.3) not otherwise deduced will be deduced to an empty sequence of template arguments.</p>\n</blockquote>\n<p>What constitutes a \"trailing template parameter pack\" is actually never quite defined properly, but all the compilers interpret <code>Is...</code> as such here. </p>\n<hr/>\n<p>That said, I wouldn't rely on this, not because it's incorrect but instead because it makes the code difficult to understand. Especially since in this case there's an easy way to pull out all the elements of a lambda: <code>std::apply()</code>:</p>\n<pre><code>template &lt;class... Ts&gt;\nvoid foo(std::tuple&lt;Ts...&gt; t) {\n    std::apply([](auto&amp;... args) {\n        (std::cout &lt;&lt; ... &lt;&lt; args);\n    }, t);\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42428557", "Score": "1", "CreationDate": "2017-02-24T00:10:01.763", "LastActivityDate": "2017-02-24T00:10:01.763"}, "bq_ids": {"n4140": {"so_38158702_42428557_0": {"section_id": 286, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_38158702_42428557_0": {"section_id": 277, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_38158702_42428557_0": {"section_id": 293, "quality": 0.9230769230769231, "length": 12}}}, "38158702": {"CommentCount": "7", "ViewCount": "139", "PostTypeId": "1", "LastEditorUserId": "4324224", "CreationDate": "2016-07-02T09:41:22.193", "LastActivityDate": "2017-02-24T00:10:01.763", "Title": "Can I rely on the fact the type of the parameter with a default value when involving parameter pack is deduced to an empty pack?", "AcceptedAnswerId": "42428557", "LastEditDate": "2016-07-02T19:56:25.067", "Id": "38158702", "Score": "4", "Body": "<p>Consider an example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;class... Ts, size_t... Is&gt;\nvoid foo(std::tuple&lt;Ts...&gt; t,\n         std::index_sequence&lt;Is...&gt; = {}) {\n   if (sizeof...(Ts) != sizeof...(Is)) {\n      foo(t, std::make_index_sequence&lt;sizeof...(Ts)&gt;{});\n      return;\n   }\n   (std::cout &lt;&lt; ... &lt;&lt; std::get&lt;Is&gt;(t));\n}\n\nint main() {\n   foo(std::make_tuple(1, 2, 3));\n}\n</code></pre>\n<p>I assume the type of the second parameter of a function <code>foo</code> will be by default deduced to <code>std::integral_sequence&lt;std::size_t&gt;</code> and as such I don't have to create helper function to use <code>Is...</code> indices to tuple elements but can call <code>foo</code> with the second parameter set to <code>std::make_index_sequence&lt;sizeof...(Ts)&gt;{}</code>.</p>\n<p>Can I rely on the fact the type of the parameter with a default value when involving parameter pack is deduced to an empty pack or may it cause undefined behaviour? </p>\n<p>Above code compiled using <code>g++-6</code> and <code>clang++-3.6</code> using <code>-std=c++1z</code> option is working as expected.</p>\n", "Tags": "<c++><templates><variadic-templates><c++1z><default-parameters>", "OwnerUserId": "4324224", "AnswerCount": "1"}});