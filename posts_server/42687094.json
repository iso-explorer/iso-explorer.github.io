post_cb({"42687094": {"ViewCount": "523", "Body": "<p>I was reading the C++ docs the other day and noticed that, although literal types must not have virtual members, this does not prevent them from <em>implementing</em> virtual members. Or at least that's what I understood.</p>\n<p>This is some piece of code I've been playing with:</p>\n<pre><code>#include &lt;cassert&gt;\n\n// Some forward declarations:\n\nenum class literal_id;\nstruct literal_base;\nstruct literal_a;\nstruct literal_b;\n\n// Now some definitions:\n\nenum class literal_id {\n    a, b \n};\n\nstruct literal_base {\n    virtual literal_id method() const noexcept = 0;\n};\n\nstruct literal_a : public literal_base {\n    constexpr literal_id method() const noexcept final { return literal_id::a; }\n    constexpr operator literal_b() const noexcept;\n};\n\nstruct literal_b : public literal_base {\n    constexpr literal_id method() const noexcept final { return literal_id::b; }\n    constexpr operator literal_a() const noexcept;\n};\n\nconstexpr literal_a::operator literal_b() const noexcept { return literal_b(); }\nconstexpr literal_b::operator literal_a() const noexcept { return literal_a(); }\n\n// Some test methods\n\nliteral_id process_literal_base(literal_base const&amp; l) { return l.method(); }\nconstexpr literal_id process_literal_a(literal_a const&amp; l) { return l.method(); }\nconstexpr literal_id process_literal_b(literal_b const&amp; l) { return l.method(); }\n\n// Some test variables\n\nconstexpr auto a = literal_a();\nconstexpr auto b = literal_b();\n\nint main() {\n    // Compile-time tests, all ok\n    static_assert(process_literal_a(b) == literal_id::a, \"\");\n    static_assert(process_literal_b(a) == literal_id::b, \"\");\n\n    // Runtime tests, all ok\n    assert(process_literal_base(a) == literal_id::a);\n    assert(process_literal_base(b) == literal_id::b);\n\n    return 0;\n}\n</code></pre>\n<p>Some remarks:</p>\n<ul>\n<li>I have a base class <code>literal_base</code> with an implicit (and therefore trivial) destructor, because none of its subclasses are supposed to have anything but a trivial destructor -- they are literal types, after all.</li>\n<li><code>literal_base</code> has a single <code>method</code> function used for testing, but the intention is for it to have as many <strong>pure virtual</strong> functions as needed (non-virtual final functions are also valid).</li>\n<li>Note that the <code>method</code> overrides in the subclasses are marked <code>final</code>, even though they are not marked <code>virtual</code>. This is just to silence the compiler, because those classes are supposed to either be leaf (in their inheritance tree) or have no overwritten functions. (All this has to do with pre-C++11 undefined behaviour semantics for final implementations of virtual functions, when the <code>final</code> specifier did not exist yet.)</li>\n<li>The <code>process_*</code> functions were created to help with asserting the correctness of the implementation at compile and runtime.</li>\n<li>I also played with value semantics, for no reason at all, and all was well :)</li>\n</ul>\n<p>Some relevant <a href=\"http://en.cppreference.com/w/cpp/concept/LiteralType\" rel=\"noreferrer\">definitions for literal types</a>:</p>\n<blockquote>\n<p id=\"so_42687094_42687094_0\">...\n  possibly cv-qualified class type that has all of the following properties:</p>\n<ul>\n<li>(1) has a trivial destructor. <strong>[[ they have (the subclasses of <code>literal_base</code>, I mean) ]]</strong></li>\n<li>(2) is either\n  \n  <ul>\n<li>(2.1) an aggregate type, <strong>[[ not applicable ]]</strong></li>\n<li>(2.2) a type with at least one constexpr (possibly template) constructor that is not a copy or move constructor, <strong>[[ it has, but just because none of the classes have an explicit constructor; but it's easy to achieve ]]</strong></li>\n<li>(2.3) a closure type (since C++17) <strong>[[ not applicable ]]</strong></li>\n</ul></li>\n<li>(3) for unions, at least one non-static data member is of non-volatile literal type, <strong>[[ not applicable ]]</strong></li>\n<li>(4) for non-unions, all non-static data members and base classes are of non-volatile literal types. (since C++17) <strong>[[ no <code>volatile</code> in the example, and neither should <code>volatile</code> be used in a real application; also, <code>literal_base</code>'s subclasses are supposed to be literal types, so this rule must (and can) be applied ]]</strong></li>\n<li>(5) all non-static data members and base classes are of non-volatile literal types. <strong>[[ same as (4), basically ]]</strong></li>\n</ul>\n</blockquote>\n<p>Now some <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"noreferrer\">definitions for constexpr functions</a>:</p>\n<blockquote id=\"so_42687094_42687094_1\">\n<ul>\n<li>it must not be virtual <strong>[[ none of the subclasses have virtual functions; all of them are final, and therefore their locations are known without the need for e.g. vtables ]]</strong></li>\n<li>(...)</li>\n</ul>\n</blockquote>\n<p>Am I right to assume all that? Is there anything about the specification I'm overlooking?</p>\n", "AcceptedAnswerId": "42687235", "Title": "Does this constexpr virtual function technique violate any C++11/C++14 rule?", "CreationDate": "2017-03-09T03:25:42.580", "LastActivityDate": "2017-03-09T05:18:53.027", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-03-09T05:00:36.417", "OwnerDisplayName": "Fl\u00e1vio Lisb\u00f4a", "LastEditorUserId": "1157100", "Id": "42687094", "Score": "7", "OwnerUserId": "3962396", "Tags": "<c++><c++11><c++14><constexpr><virtual-functions>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42687094_42687235_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5419}, "so_42687094_42687094_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 4706}}, "n3337": {"so_42687094_42687235_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5214}, "so_42687094_42687094_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 4515}}, "n4659": {"so_42687094_42687235_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6841}, "so_42687094_42687094_0": {"length": 7, "quality": 1.0, "section_id": 8717}}}, "42687235": {"Id": "42687235", "PostTypeId": "2", "Body": "<p>The rule in [dcl.constexpr] is pretty clear:</p>\n<blockquote>\n<p id=\"so_42687094_42687235_0\">The definition of a <code>constexpr</code> function shall satisfy the following requirements:<br>\n  \u2014 it shall not be virtual (10.3);</br></p>\n</blockquote>\n<p><code>literal_a::method</code> and <code>literal_b::method</code> are both <code>virtual</code> because each they override <code>literal_base::method</code>, which is <code>virtual</code>. Hence, they cannot be <code>constexpr.</code> It does not matter that they are <code>final</code>. The program is ill-formed.</p>\n<p>It <em>is</em> true that a literal type is allowed to have a <code>virtual</code> member function though. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-03-09T05:18:53.027", "Score": "10", "CreationDate": "2017-03-09T05:11:27.027", "ParentId": "42687094", "CommentCount": "0", "LastEditDate": "2017-03-09T05:18:53.027", "OwnerUserId": "2069064"}});