post_cb({"7295732": {"ParentId": "7295632", "CommentCount": "0", "Body": "<p>It's defined behavior. The value that ends up in <code>f</code> is unspecified if <code>k</code> is outside the range of values of <code>foo</code> and is the same as <code>k</code> if it is inside of the range of values of <code>foo</code>. </p>\n<p>The range of <code>foo</code> is <code>0 .. 2^(ld(n+2)+1) - 1</code>. That is, the values of a bitfield that can store all the values of your enum constants (enumerators).</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "7295732", "Score": "4", "CreationDate": "2011-09-03T20:32:12.997", "LastActivityDate": "2011-09-03T20:32:12.997"}, "7295699": {"ParentId": "7295632", "PostTypeId": "2", "CommentCount": "14", "Body": "<blockquote>\n<p id=\"so_7295632_7295699_0\">I had a compilation error. I understand that this is not valid because ++f might not be a valid foo enum.</p>\n</blockquote>\n<p>No. That is wrong interpretation of the error. It doesn't compile because there is no <code>operator++</code> defined for <code>foo</code> type.</p>\n<p>If you define <code>operator++</code> as:</p>\n<pre><code>foo &amp; operator++(foo &amp; f) \n{  \n   return f = foo(f+1); \n}\n</code></pre>\n<p>Then <code>++f</code> would compile and work : <a href=\"http://ideone.com/1GG09\" rel=\"nofollow\">http://ideone.com/1GG09</a></p>\n<p>And as for <code>foo(f+1)</code> (or <code>foo(k)</code>), then that is okay. Internally,<code>foo</code> is an integral type. And it's value can be anything which can be represented by the underlying integral type. </p>\n<p>\u00a77.2/6 says,</p>\n<blockquote>\n<p id=\"so_7295632_7295699_1\">For an enumeration where e<sub>min</sub> is the smallest enumerator and e<sub>max</sub> is the largest, the values of the enumeration are the values of the underlying type <strong>in the range b<sub>min</sub> to b<sub>max</sub></strong>, where b<sub>min</sub> and b<sub>max</sub> are, respectively, the smallest and largest values of the smallest bit-field that can store e<sub>min</sub> and e<sub>max</sub>) <strong>It is possible to define an enumeration that has values not defined by any of its enumerators.</strong></p>\n</blockquote>\n<hr>\n<p>EDIT:</p>\n<pre><code> foo f = foo(100); //what value will have f after this according to the standard\n</code></pre>\n<p>I think the behavior is <strong>unspecified</strong> here, as the Standard says in \u00a77.2/9,</p>\n<blockquote>\n<p id=\"so_7295632_7295699_2\">An expression of arithmetic or enumeration type can be converted to an enumeration type explicitly. The value is unchanged <em>if it is in the range of enumeration values</em> of the enumeration type; <strong>otherwise the resulting enumeration value is unspecified.</strong></p>\n</blockquote>\n<p>For enumeration range, see the previous quotation.</p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-09-03T20:57:47.627", "Id": "7295699", "Score": "7", "CreationDate": "2011-09-03T20:27:09.670", "LastActivityDate": "2011-09-03T20:57:47.627"}, "7295680": {"ParentId": "7295632", "CommentCount": "0", "Body": "<p>In that case <code>f</code> would have the value k but this doesn't correspond to a label in the <code>enum</code>. Think of the <code>enum</code> as an <code>unsigned int</code> as the data type (unless set otherwise) and the identifiers inside the <code>enum</code> as constants.</p>\n", "OwnerUserId": "918124", "PostTypeId": "2", "Id": "7295680", "Score": "0", "CreationDate": "2011-09-03T20:24:28.017", "LastActivityDate": "2011-09-03T20:24:28.017"}, "bq_ids": {"n4140": {"so_7295632_7295699_2": {"section_id": 6036, "quality": 0.6818181818181818, "length": 15}, "so_7295632_7295699_1": {"section_id": 5467, "quality": 0.5277777777777778, "length": 19}}, "n3337": {"so_7295632_7295699_2": {"section_id": 5804, "quality": 0.6818181818181818, "length": 15}, "so_7295632_7295699_1": {"section_id": 5253, "quality": 0.5277777777777778, "length": 19}}, "n4659": {"so_7295632_7295699_2": {"section_id": 7535, "quality": 0.6818181818181818, "length": 15}, "so_7295632_7295699_1": {"section_id": 6901, "quality": 0.5277777777777778, "length": 19}}}, "7295632": {"CommentCount": "0", "ViewCount": "232", "PostTypeId": "1", "LastEditorUserId": "336578", "CreationDate": "2011-09-03T20:15:55.287", "LastActivityDate": "2011-09-03T20:57:47.627", "Title": "Question about enums in C++", "AcceptedAnswerId": "7295699", "LastEditDate": "2011-09-03T20:33:06.190", "Id": "7295632", "Score": "4", "Body": "<p>I tried to use an enum in a for loop like this:</p>\n<pre><code>enum foo\n{\n    foo_0, \n    foo_1,\n    foo_2,\n    foo_3,\n    ...\n    foo_n,\n    foo_count\n};\n\nfor(foo f = foo_0; f &lt; foo_count; ++f) \n</code></pre>\n<p>and I had a compilation error. I understand that this is not valid because ++f might not be a valid foo enum - not in this case but in general case so I switched the for loop to this:</p>\n<pre><code>for(foo f = foo_0; f &lt; foo_count; f = foo(f+1)) \n</code></pre>\n<p>which compiles fine. But this rises the fallowing question. What happens if I have the fallowing statement?</p>\n<pre><code>foo f = foo(k); //k is not a valid foo value\n</code></pre>\n<p>Is this undefined behavior?</p>\n<p>EDIT: k is an int and it hasn't any corresponding value in foo</p>\n<p>EDIT2:</p>\n<pre><code>enum foo\n{\n    foo_0, \n    foo_1,\n    foo_2,\n    foo_3\n};\n\nfoo f = foo(100); //what value will have f after this according to the standard\n</code></pre>\n<p>Thanks for help!</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "336578", "AnswerCount": "3"}});