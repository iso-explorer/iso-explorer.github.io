post_cb({"18036138": {"CommentCount": "7", "ViewCount": "913", "CreationDate": "2013-08-03T18:50:41.727", "LastActivityDate": "2013-08-03T20:52:34.840", "Title": "Why does C-style cast behave differently than dynamic_cast?", "AcceptedAnswerId": "18037104", "PostTypeId": "1", "Id": "18036138", "Score": "0", "Body": "<p>I have the following class hierarchy:</p>\n<pre><code>class IControl\n{\n    virtual void SomeMethod() = 0; // Just to make IControl polymorphic.\n};\n\nclass ControlBase\n{\npublic:\n    virtual int GetType() = 0;\n};\n\nclass ControlImpl : public ControlBase, public IControl\n{\npublic:\n    virtual void SomeMethod() { }\n\n    virtual int GetType()\n    {\n        return 1;\n    }\n};\n</code></pre>\n<p>I have an <strong>IControl</strong> abstract class, and a <strong>ControlBase</strong> class. The ControlBase class does not inherit from IControl, but I know that every IControl-implementation will derive from ControlBase.</p>\n<p>I have the following test code in which I cast an <strong>IControl</strong>-reference to <strong>ControlBase</strong> (because I know it derives from it) with <strong>dynamic_cast</strong>, and also with <strong>C-style</strong> cast:</p>\n<pre><code>int main()\n{\n    ControlImpl stb;\n    IControl&amp; control = stb;\n\n    ControlBase&amp; testCB1 = dynamic_cast&lt;ControlBase&amp;&gt;(control);\n    ControlBase&amp; testCB2 = (ControlBase&amp;)control;\n    ControlBase* testCB3 = (ControlBase*)&amp;control;\n\n    std::cout &lt;&lt; &amp;testCB1 &lt;&lt; std::endl;\n    std::cout &lt;&lt; &amp;testCB2 &lt;&lt; std::endl;\n    std::cout &lt;&lt; testCB3 &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; testCB1.GetType() &lt;&lt; std::endl; // This properly prints \"1\".\n    std::cout &lt;&lt; testCB2.GetType() &lt;&lt; std::endl; // This prints some random number.\n    std::cout &lt;&lt; testCB3-&gt;GetType() &lt;&lt; std::endl; // This prints some random number.\n}\n</code></pre>\n<p>Only the dynamic_cast works properly, the other two casts give back slightly different memory addresses, and the GetType() function gives back incorrect values.</p>\n<p>What is the exact reason for this? Does the C-style cast end up using a <strong>reinterpret_cast</strong>? Is it related to how polymorphic objects are aligned in memory?</p>\n", "Tags": "<c++><inheritance><casting><polymorphism>", "OwnerUserId": "974733", "AnswerCount": "2"}, "18037215": {"ParentId": "18036138", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_18036138_18037215_0\">What is the exact reason for this?</p>\n</blockquote>\n<p>The exact reason is that <code>dynamic_cast</code> is guaranteed to work in this situation by the standard, while the other kinds invoke undefined behaviour.</p>\n<blockquote>\n<p id=\"so_18036138_18037215_1\">Does the C-style cast end up using a reinterpret_cast?</p>\n</blockquote>\n<p>Yes, in this case it does. (A side note: <strong>never ever</strong> use a C-style cast).</p>\n<blockquote>\n<p id=\"so_18036138_18037215_2\">Is it related to how polymorphic objects are aligned in memory?</p>\n</blockquote>\n<p>I would say it is related to the way polymorphic objects that use multiple inheritance are laid out in memory. In a language with single inheritance, <code>dynamic_cast</code> would not be necessary, as the base subobject address would coincide with the derived object address. In the multiple-inheritance case this is not so, as there are more than one base subobjects, and different base subobjects must have different addresses. </p>\n<p>Sometimes the compiler can calculate the offset between each subobjects address and the derived object address. If the offset is non-zero, the cast operation is then becomes a pointer addition or subtraction instead of a no-op. (In the case of virtual inheritance <em>upcast</em>, it's somewhat more complicated but the compiler can still do that).</p>\n<p>There is at least two cases when the compiler cannot do that:</p>\n<ol>\n<li>Cross-cast (that is, between two classes neither of which is a base class of the other). </li>\n<li>Downcast from a virtual base.</li>\n</ol>\n<p>In these cases <code>dynamic_cast</code> is the only way to cast.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "18037215", "Score": "3", "CreationDate": "2013-08-03T20:52:34.840", "LastActivityDate": "2013-08-03T20:52:34.840"}, "bq_ids": {"n4140": {"so_18036138_18037104_0": {"section_id": 6126, "quality": 1.0, "length": 18}}, "n3337": {"so_18036138_18037104_0": {"section_id": 5890, "quality": 1.0, "length": 18}}, "n4659": {"so_18036138_18037104_0": {"section_id": 7623, "quality": 1.0, "length": 18}}}, "18037104": {"ParentId": "18036138", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I think the class names in your example are a bit confusing. Let's call them <code>Interface</code>, <code>Base</code> and <code>Impl</code>. Note that <code>Interface</code> and <code>Base</code> are <em>unrelated</em>.</p>\n<p>The C++ Standard defines the C-style cast, called \"explicit type conversion (cast notation)\" in [expr.cast]. You can (and maybe should) read that whole paragraph to know exactly how the C-style cast is defined. For the example in the OP, the following is sufficient:</p>\n<p>A C-style can performs a conversion of one of [expr.cast]/4:</p>\n<ul>\n<li><code>const_cast</code></li>\n<li><code>static_cast</code></li>\n<li><code>static_cast</code> followed by <code>const_cast</code></li>\n<li><code>reinterpret_cast</code></li>\n<li><code>reinterpret_cast</code> followed by <code>const_cast</code></li>\n</ul>\n<p>The order of this list is important, because:</p>\n<blockquote>\n<p id=\"so_18036138_18037104_0\">If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears first in the list is used, even if a cast resulting from that interpretation is ill-formed.</p>\n</blockquote>\n<p>Let's examine your example</p>\n<pre><code>Impl impl;\nInterface* pIntfc = &amp;impl;\nBase* pBase = (Base*)pIntfc;\n</code></pre>\n<p>A <code>const_cast</code> cannot be used, the next element in the list is a <code>static_cast</code>. But the classes <code>Interface</code> and <code>Base</code> are <em>unrelated</em>, therefore <em>there is no <code>static_cast</code> that can convert from <code>Interface*</code> to <code>Base*</code></em>. Therefore, a <code>reinterpret_cast</code> is used.</p>\n<p><em><strong>Additional note:</strong></em></p> the actual answer to your question is: as there is no <code>dynamic_cast</code> in the list above, a C-style cast never behaves like a <code>dynamic_cast</code>.\n<hr>\n<p>How the actual address changes is not part of the definition of the C++ language, but we can make an example of how it could be implemented:</p>\n<p>Each object of a class with at least one virtual function (inherited or own) contains (read: <em>could contain</em>, in this example) a pointer to a vtable. If it inherits virtual functions from multiple classes, it contains multiple pointers to vtables. Because of empty base class optimization (no data members), an instance of <code>Impl</code> could look like this:</p>\n<pre>\n+=Impl=======================================+\n|                                            |\n|  +-Base---------+   +-Interface---------+  |\n|  | vtable_Base* |   | vtable_Interface* |  |\n|  +--------------+   +-------------------+  |\n|                                            |\n+============================================+\n</pre>\n<p>Now, the example:</p>\n<pre><code>     Impl  impl;\n\n     Impl* pImpl  = &amp;impl;\nInterface* pIntfc = pImpl;\n     Base* pBase  = pImpl;\n</code></pre>\n<pre>\n+=Impl=======================================+\n|                                            |\n|  +-Base---------+   +-Interface---------+  |\n|  | vtable_Base* |   | vtable_Interface* |  |\n|  +--------------+   +-------------------+  |\n|  ^                  ^                      |\n+==|==================|======================+\n^  |                  |\n|  +-- pBase          +-- pIntfc\n|\n+-- pimpl\n</pre>\n<p>If you instead do a <code>reinterpret_cast</code>, the result is implementation-defined, but it could result in something like this:</p>\n<pre><code>     Impl  impl;\n\n     Impl* pImpl  = &amp;impl;\nInterface* pIntfc = pImpl;\n     Base* pBase  = reinterpret_cast&lt;Base*&gt;(pIntfc);\n</code></pre>\n<pre>\n+=Impl=======================================+\n|                                            |\n|  +-Base---------+   +-Interface---------+  |\n|  | vtable_Base* |   | vtable_Interface* |  |\n|  +--------------+   +-------------------+  |\n|                     ^                      |\n+=====================|======================+\n^                     |\n|                     +-- pIntfc\n|                     |\n+-- pimpl             +-- pBase\n</pre>\n<p>I.e. the address is unchanged, <code>pBase</code> points to the <code>Interface</code> subobject of the <code>Impl</code> object.</p>\n<p>Note that dereferencing the pointer <code>pBase</code> takes us to UB-land already, the Standard doesn't specify what should happen. In this exemplary implementation, if you call <code>pBase-&gt;GetType()</code>, the <code>vtable_Interface*</code> is used, which contains the <code>SomeMethod</code> entry, and that function is called. This function doesn't return anything, so <em>in this example</em>, nasal demons are summoned and take over the world. Or some value is taken from the stack as a return value.</p>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-08-03T20:47:56.147", "Id": "18037104", "Score": "7", "CreationDate": "2013-08-03T20:41:00.413", "LastActivityDate": "2013-08-03T20:47:56.147"}});