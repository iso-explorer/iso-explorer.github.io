post_cb({"bq_ids": {"n4140": {"so_29932335_29932493_0": {"length": 19, "quality": 0.95, "section_id": 38}}, "n3337": {"so_29932335_29932493_0": {"length": 19, "quality": 0.95, "section_id": 35}}, "n4659": {"so_29932335_29932493_0": {"length": 19, "quality": 0.95, "section_id": 38}}}, "29932441": {"Id": "29932441", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29932335_29932441_0\">However, if I have a floating point value <code>f</code> such that <code>f == F(i)</code>, is <code>I(f)</code> well defined? In other words, is <code>I(F(i))</code> always defined behavior?</p>\n</blockquote>\n<p>No.</p>\n<p>Suppose that <code>I</code> is a signed two's complement 32 bit integer type, <code>F</code> is a 32 bit single precision floating point type, and <code>i</code> is the maximum positive integer. This is within the range of the floating point type, but it cannot be represented exactly as a floating point number. Some of those 32 bits are used for the exponent.</p>\n<p>Instead, the conversion from integer to floating point is implementation dependent, but typically is done by rounding to the closest representable value. That rounded value is one beyond the range of the integer type. The conversion back to integer fails (better said, it's undefined behavior).</p>\n", "LastEditorUserId": "774499", "LastActivityDate": "2015-04-29T00:47:53.623", "Score": "4", "CreationDate": "2015-04-29T00:45:32.567", "ParentId": "29932335", "CommentCount": "7", "OwnerUserId": "774499", "LastEditDate": "2015-04-29T00:47:53.623"}, "29932493": {"Id": "29932493", "PostTypeId": "2", "Body": "<p>No.</p>\n<p>It's possible that <code>i == std::numeric_limits&lt;I&gt;::max()</code>, but that <code>i</code> is not exactly representable in <code>F</code>.</p>\n<blockquote>\n<p id=\"so_29932335_29932493_0\">If the value being converted is in the range of values that can be represented but the value cannot be represented exactly, it is an implementation-defined choice of either the next lower or higher representable value.</p>\n</blockquote>\n<p>Since the next higher representable value may be chosen, it's possible that the result <code>F(i)</code> no longer fits into <code>I</code>, so conversion back would be undefined behavior.</p>\n", "LastActivityDate": "2015-04-29T00:52:05.167", "CommentCount": "1", "CreationDate": "2015-04-29T00:52:05.167", "ParentId": "29932335", "Score": "-1", "OwnerUserId": "565635"}, "29932553": {"Id": "29932553", "PostTypeId": "2", "Body": "<p>No. Regardless of the standard, you cannot expect that in general this conversion will return your original integer. It doesn't make sense mathematically. But if you read into what you quoted, the standard clearly indicates the possibility of a loss of precision upon converting from int to float. </p>\n<p>Suppose your types I and F use the same number of bits. All of the bits of I (save possibly one that stores the sign) are used to specify the absolute value of the number. On the other hand, in F, some bits are used to specify the exponent and some are used for the significand. The range will be greater because of the possible exponent. But the significand will have less precision because there are fewer bits devoted to its specification.</p>\n<p>Just as a test, I printed </p>\n<pre><code>std::numeric_limits&lt;int&gt;::max();\nstd::numeric_limits&lt;float&gt;::max();\n</code></pre>\n<p>I then converted the first number to float and back again. The max float had an exponent of 38, and the max int had 10 digits, so clearly float has a larger range. But upon converting the max int to float and back, I went from <code>2147473647</code> to <code>-2147473648</code>. So it seems the number was incremented by one unit and went around to the negative side.</p>\n<p>I didn't check how many bits are actually used for float on my system, but it at least demonstrates the loss of precision, and it shows that gcc \"rounded up\".</p>\n", "LastActivityDate": "2015-04-29T00:58:19.010", "CommentCount": "2", "CreationDate": "2015-04-29T00:58:19.010", "ParentId": "29932335", "Score": "-1", "OwnerUserId": "3930348"}, "29932335": {"ViewCount": "145", "Body": "<p>Let's say I have two arithmetic types, an integer one, <code>I</code>, and a floating point one, <code>F</code>. I also assume that <code>std::numeric_limits&lt;I&gt;::max()</code> is smaller than <code>std::numeric_limits&lt;F&gt;::max()</code>.</p>\n<p>Now, let's say I have a positive integer value <code>i</code>. Because the representable range of <code>F</code> is larger than <code>I</code>, <code>F(i)</code> should always be defined behavior.</p>\n<p>However, if I have a floating point value <code>f</code> such that <code>f == F(i)</code>, is <code>I(f)</code> well defined? In other words, is <code>I(F(i))</code> always defined behavior?</p>\n<hr>\n<p>Relevant section from the C++14 standard:</p>\n<blockquote>\n<p id=\"so_29932335_29932335_0\"><strong>4.9 Floating-integral conversions</strong> <strong>[conv.fpint]</strong></p>\n<ol>\n<li>A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates;\n  that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be\n  represented in the destination type. [ <em>Note:</em> If the destination type is <code>bool</code>, see 4.12. \u2014 <em>end note</em> ]</li>\n<li>A prvalue of an integer type or of an unscoped enumeration type can be converted to a prvalue of a floating\n  point type. The result is exact if possible. If the value being converted is in the range of values that can\n  be represented but the value cannot be represented exactly, it is an implementation-defined choice of either\n  the next lower or higher representable value. [ <em>Note:</em> Loss of precision occurs if the integral value cannot\n  be represented exactly as a value of the floating type. \u2014 <em>end note</em> ] If the value being converted is outside\n  the range of values that can be represented, the behavior is undefined. If the source type is <code>bool</code>, the value\n  <code>false</code> is converted to zero and the value <code>true</code> is converted to one.</li>\n</ol>\n</blockquote>\n</hr>", "AcceptedAnswerId": "29932493", "Title": "Is round-trip through floating point always defined behavior if floating point range is bigger?", "CreationDate": "2015-04-29T00:33:52.463", "Id": "29932335", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-04-29T00:58:19.010", "Score": "8", "OwnerUserId": "565635", "Tags": "<c++><language-lawyer><c++14><floating-point-conversion>", "AnswerCount": "3"}});