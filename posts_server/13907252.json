post_cb({"13912993": {"ParentId": "13907252", "CommentCount": "0", "Body": "<p>Although the standard doesn't explicitly mention whether the definition of a <code>constexpr</code> static member function is allowed to be separate from its declaration, it has the following example of a separate definition of a <code>constexpr</code> constructor, under 7.1.5p1:</p>\n<pre><code>struct pixel {\n  int x;\n  int y;\n  constexpr pixel(int); // OK: declaration\n};\nconstexpr pixel::pixel(int a)\n  : x(square(a)), y(square(a)) // OK: definition\n  { }\n</code></pre>\n<p>So it seems clear that <code>constexpr</code> functions can have separate declaration and definition.  Also in 7.1.5p1:</p>\n<blockquote>\n<p id=\"so_13907252_13912993_0\">If any declaration of a\n  function or function template has <code>constexpr</code> specifier, then all its declarations shall contain the <code>constexpr</code>\n  specifier.</p>\n</blockquote>\n<p>This implies that a <code>constexpr</code> function can have (multiple) non-definition declarations.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "13912993", "Score": "8", "CreationDate": "2012-12-17T11:11:40.960", "LastActivityDate": "2012-12-17T11:11:40.960"}, "13908445": {"ParentId": "13907252", "CommentCount": "0", "Body": "<p>I'm pretty sure that g++ is correct.  In fact this used to be a <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43947\" rel=\"nofollow\">bug</a> in g++.  I can't find a place in the standard that explicitly says that you can have a static constexpr declaration separate from the definition, but if you look in section 7.1.5 that talks about the constexpr specifier (<a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\">summarized here</a>), it doesn't rule it out, which generally means that it is allowed.</p>\n", "OwnerUserId": "1102885", "PostTypeId": "2", "Id": "13908445", "Score": "2", "CreationDate": "2012-12-17T04:54:03.863", "LastActivityDate": "2012-12-17T04:54:03.863"}, "17494592": {"ParentId": "13907252", "CommentCount": "0", "Body": "<p>This was a Clang bug (fixed in Clang 3.2). The problem was that Clang wasn't correctly handling the impact of implicit <code>const</code>ness when determining whether a redeclaration of a function matched a prior declaration. Consider:</p>\n<pre><code>struct A {\n  int f();                  // #1\n  constexpr int f() const;  // #2 (const is implicit in C++11 and can be omitted)\n  static constexpr int g(); // #3\n};\n\nint A::f() { return 1; }           // #4, matches #1\nconstexpr int A::f() { return 1; } // #5, matches #2, implicitly const\nconstexpr int A::g() { return 1; } // #6, matches #3, not implicitly const\n</code></pre>\n<p>When matching the out-of-class declaration #5 against members of <code>A</code>, the compiler has a problem: it doesn't know what type the new declaration of <code>A::f</code> has yet. If <code>A::f</code> is a non-static member function, then its type is <code>int () const</code>, and if it's a static member function then its type is <code>int ()</code> (no implicit <code>const</code>).</p>\n<p>Clang 3.1 didn't get this entirely right: it assumed that if a <code>constexpr</code> function were a member function then the <code>constexpr</code> made it implicitly <code>const</code>, which allows #4 and #5 to work, but breaks #6. Clang 3.2 fixes this by implementing the <code>constexpr</code>-implies-<code>const</code> rule twice: once in redeclaration matching (such that #5 is considered to redeclare #2 and not #1, even though it isn't yet implicitly <code>const</code>), and again once the prior declaration has been chosen (to add the implicit const to #5).</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "17494592", "Score": "10", "CreationDate": "2013-07-05T18:02:51.797", "LastActivityDate": "2013-07-05T18:02:51.797"}, "bq_ids": {"n4140": {"so_13907252_13912993_0": {"section_id": 5417, "quality": 1.0, "length": 13}}, "n3337": {"so_13907252_13912993_0": {"section_id": 5212, "quality": 1.0, "length": 13}}, "n4659": {"so_13907252_13912993_0": {"section_id": 6839, "quality": 1.0, "length": 13}}}, "13907252": {"CommentCount": "2", "ViewCount": "2199", "CreationDate": "2012-12-17T01:29:05.913", "LastActivityDate": "2013-07-05T18:02:51.797", "Title": "inline constexpr function definition legal or not? gcc (ok) vs clang (error)", "AcceptedAnswerId": "13912993", "PostTypeId": "1", "Id": "13907252", "Score": "15", "Body": "<p>My current program is rejected by clang but compiles fine with gcc. It boils down to the following simplified example: </p>\n<pre><code>struct A {\n  static constexpr inline int one();\n};\n\ninline constexpr int A::one() { return 1; }\n\nint main() {\n  return 0;\n}\n</code></pre>\n<p>g++ 4.7.2 compiles it without errors (<code>g++ -std=c++11 -Wall -g -o main example.cpp</code>). clang++ 3.1 rejects it:</p>\n<pre><code>$ clang++ -std=c++11 -Wall -g -o main example.cpp \nexample.cpp:6:25: error: conflicting types for 'one'\ninline constexpr int A::one() { return 1; }\n                        ^\nexample.cpp:3:31: note: previous declaration is here\n  static constexpr inline int one();\n                              ^\n1 error generated.\n</code></pre>\n<p>My bet is that gcc is right and and clang is wrong? The program should be legal C++11.</p>\n<p>Interesting sidenote. If <code>one</code> is implemented within the struct, clang no longer complains:</p>\n<pre><code>struct A {\n  static constexpr inline int one() { return 1; }\n}\n</code></pre>\n<p>gcc also accepts this variant. From my understanding, both versions should be identical according to the standard. Is it a clang bug or am I missing something?</p>\n", "Tags": "<c++><c++11><clang><language-lawyer>", "OwnerUserId": "783510", "AnswerCount": "3"}});