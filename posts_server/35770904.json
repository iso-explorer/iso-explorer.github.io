post_cb({"35772218": {"PostTypeId": "2", "ParentId": "35770904", "Body": "<p>\"Optimized out even though the <code>m_Current</code> member is marked as <em>mutable</em>\"</p>\n<p>This tells me that you're assuming the optimizer cares about <code>mutable</code>. It doesn't. <code>const</code> and <code>mutable</code> have been stripped by an earlier phase of compilation.</p>\n<p>Why then does the optimzier remove the two statements, <em>if they're inlined</em> ? I suspect that after inlining, the optimizer can prove that the two writes are a no-op, either as the <code>m_Current</code> variable must hold the right value already, <em>or</em> because the subsequent usage of <code>m_Current</code> makes it moot. Trivially the following case make those writes a no-op:</p>\n<pre><code>Lazy_Iterator LI = foo(); // Theoretically writes\n*LI = bar(); // Overwrites the previous value.\n</code></pre>\n", "CreationDate": "2016-03-03T12:28:35.020", "Score": "2", "CommentCount": "3", "Id": "35772218", "OwnerUserId": "15416", "LastActivityDate": "2016-03-03T12:28:35.020"}, "35772549": {"PostTypeId": "2", "ParentId": "35770904", "Body": "<p>There is a problem with difference between physical iterator held by <code>reverse_iterator</code> (what is returned by <code>.base()</code>) and logical value it points to: they are off-by-one. <s><a href=\"http://en.cppreference.com/w/cpp/iterator/reverse_iterator/operator*\" rel=\"nofollow\"><code>reverse_iterator</code> might do <code>return *(--internal_iterator);</code> on dereference</a>, which leaves you with dangling reference to internals of destroyed function-local temporary.</s></p>\n<p>After another reading of standard, I found out that it has additional requirements to avoid such scenario, read note.</p>\n<p>Also I found that GCC 4.9 standard library is non-compliant. It uses a temporary. So, I think it is a GCC bug.</p>\n<p>Edit: Standard quote </p>\n<blockquote>\n<p id=\"so_35770904_35772549_0\"><strong>24.5.1.3.4</strong> operator* \u00a0\u00a0\u00a0\u00a0[reverse.iter.op.star]  </p>\n<pre><code>reference operator*() const;\n</code></pre>\n<p id=\"so_35770904_35772549_1\"><em>1</em> Effects: </p>\n<pre><code>deref_tmp = current;  \n--deref_tmp; \nreturn *deref_tmp;\n</code></pre>\n<p id=\"so_35770904_35772549_2\"><em>2</em> <em>[ Note: This operation must use an auxiliary member variable rather than a temporary variable to avoid returning a reference that persists beyond the lifetime of its associated iterator. (See 24.2.) \u2014end note ]</em></p>\n</blockquote>\n<p>Follow-up reading: \n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198\" rel=\"nofollow\">Library Defect Report 198</a>.</p>\n<p>And <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51823#c17\" rel=\"nofollow\">it seems</a> that it is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3473.html#2204\" rel=\"nofollow\">returned to old behaviour</a>.</p>\n<p>Late edit: P0031 was voted in C++17 Working Draft. It states that <code>reverse_iterator</code> uses temporary, not member to hold intermediate value. </p>\n", "CreationDate": "2016-03-03T12:44:24.147", "Score": "2", "LastEditDate": "2016-03-04T11:41:39.583", "CommentCount": "5", "Id": "35772549", "OwnerUserId": "3410396", "LastEditorUserId": "3410396", "LastActivityDate": "2016-03-04T11:41:39.583"}, "35773067": {"PostTypeId": "2", "ParentId": "35770904", "Body": "<p>After a very profitable round of discussions the answer of Revolver_Ocelot pointed me to look further to the implementation of the reverse_iterators. According to his quote from the standards:</p>\n<blockquote>\n<p id=\"so_35770904_35773067_0\"><strong>24.5.1.3.4</strong> operator*     [reverse.iter.op.star]</p>\n<p id=\"so_35770904_35773067_1\"><code>reference operator*() const;</code> </p>\n<p id=\"so_35770904_35773067_2\">1 Effects:</p>\n<pre><code>deref_tmp = current;  \n--deref_tmp;  \nreturn *deref_tmp;\n</code></pre>\n<p id=\"so_35770904_35773067_3\"><em>2 [ Note: This operation must use an auxiliary member variable rather than a temporary variable to avoid\n  returning a reference that persists beyond the lifetime of its\n  associated iterator. (See 24.2.) \u2014end note ]</em></p>\n</blockquote>\n<p>Looking inside of the header stl_iterator.c of the standard library as implemented by GCC 4.9 in Debian 8:</p>\n<pre><code>  /**\n   *  @return  A reference to the value at @c --current\n   *\n   *  This requires that @c --current is dereferenceable.\n   *\n   *  @warning This implementation requires that for an iterator of the\n   *           underlying iterator type, @c x, a reference obtained by\n   *           @c *x remains valid after @c x has been modified or\n   *           destroyed. This is a bug: http://gcc.gnu.org/PR51823\n  */\n  reference\n  operator*() const\n  {\n_Iterator __tmp = current;\nreturn *--__tmp;\n  }\n</code></pre>\n<p>Notice the warning:</p>\n<blockquote>\n<p id=\"so_35770904_35773067_4\"><strong>Warning:</strong>\n  This implementation requires that for an iterator of the\n  underlying iterator type, @c x, a reference obtained by\n  @c *x remains valid after @c x has been modified or\n  destroyed. This is a bug: <a href=\"http://gcc.gnu.org/PR51823\" rel=\"nofollow\">http://gcc.gnu.org/PR51823</a></p>\n</blockquote>\n", "CreationDate": "2016-03-03T13:07:31.547", "Score": "0", "CommentCount": "0", "Id": "35773067", "OwnerUserId": "1469167", "LastActivityDate": "2016-03-03T13:07:31.547"}, "35770904": {"AcceptedAnswerId": "35772549", "OwnerUserId": "1469167", "LastActivityDate": "2016-03-04T11:41:39.583", "CreationDate": "2016-03-03T11:26:22.803", "Score": "4", "LastEditDate": "2016-03-03T12:35:06.800", "CommentCount": "8", "Title": "Compiler optimization breaks lazy iterator", "AnswerCount": "4", "PostTypeId": "1", "Tags": "<c++><optimization><iterator><lazy-evaluation><gcc4.9>", "Body": "<p>I wrote a custom container with its custom iterator. Due to the specific features of the container the iterator must be evaluated lazily. For the sake of the question the relevant part of the code is the dereferencing operator of the iterator which is implemented this way</p>\n<pre><code>template&lt;typename T&gt;\nstruct Container\n{\n  vector&lt;T&gt; m_Inner;\n\n  // This should calculate the appropriate value.\n  // In this example is taken from a vec but in \n  //the real use-case is calculated on request\n  T Value(int N)\n  { m_Inner.at(N); }\n}\n\ntemplate&lt;typename T&gt;\nstruct Lazy_Iterator\n{\n  mutable pair&lt;int, T&gt; m_Current;\n  int Index\n  Container&lt;T&gt;* C\n\n  Lazy_Iterator(const Container&amp; Cont, int N):\n    m_Current{Index, T{}}, Index{N}, C{&amp;Cont}\n  {      }\n\n  pair&lt;int, T&gt;&amp;\n  operator*() const // __attribute__((noinline)) (this cures the symptom)\n  {\n      m_Current.first = Index; /// Optimized out\n      m_Current.second = C-&gt;Value(Index); /// Optimized out\n      return m_Current;\n  }\n\n}\n</code></pre>\n<p>Because the iterator itself is a template, its functions can be freely inlined by the compiler.</p>\n<p>When I compile the code without optimizations the returned value is updated as expected. When I use the release compiler optimization (-O2 in GCC 4.9) in some cases the compiler optimizes out the lines that I marked as <em>Optimized out</em> even though the m_Current member is marked as mutable. As a consequence the return value does not match the value that the iterator should be pointing at.</p>\n<p>Is this an expected behavior? Do you know any portable way to specify that the content of that function should be evaluated even if it's marked const?</p>\n<p>I hope the question is exhaustive enough to be useful. Please advice if more details could be helpful in this case.</p>\n<p><strong>Edit:</strong></p>\n<p>To answer one comment, this is a potential usage taken from a small test program:</p>\n<pre><code>Container&lt;double&gt; myC;\nLazy_Iterator&lt;double&gt; It{myC, 0}\ncout &lt;&lt; \"Creation: \" &lt;&lt; it-&gt;first &lt;&lt; \" , \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\nauto it2 = it;\ncout &lt;&lt; \"Copy: \"&lt;&lt;  it2-&gt;first &lt;&lt; \" , \" &lt;&lt; it2-&gt;second &lt;&lt; endl;\n\ncout &lt;&lt; \"Pre-increment: \" &lt;&lt; (it++)-&gt;first &lt;&lt; \" , \" &lt;&lt; it-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Post-increment: \" &lt;&lt; (++it)-&gt;first &lt;&lt; \" , \" &lt;&lt; it-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Pre-decrement: \" &lt;&lt; (it--)-&gt;first &lt;&lt; \" , \" &lt;&lt; it-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Post-decrement: \" &lt;&lt; (--it)-&gt;first &lt;&lt; \" , \" &lt;&lt; it-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Iterator addition: \" &lt;&lt; (it+2)-&gt;first &lt;&lt; \" , \" &lt;&lt; (it+2)-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Iterator subtraction: \"&lt;&lt; (it-2)-&gt;first &lt;&lt; \" , \" &lt;&lt; (it-2)-&gt;second &lt;&lt; endl;\n\nreverse_iterator&lt;Lazy_Iterator&gt; rit{it};\ncout &lt;&lt; \"Reverse Iterator: \" &lt;&lt; rit-&gt;first &lt;&lt; \" , \" &lt;&lt; rit-&gt;second &lt;&lt; endl;\n\nauto rit2 = rit;\ncout &lt;&lt; \"Reverse Iterator copy: \" &lt;&lt; rit2-&gt;first &lt;&lt; \" , \" &lt;&lt; rit2-&gt;second &lt;&lt; endl;\n\ncout &lt;&lt; \"Rev Pre-increment: \" &lt;&lt; (rit++)-&gt;first &lt;&lt; \" , \" &lt;&lt; rit-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Rev Post-increment: \" &lt;&lt; (++rit)-&gt;first &lt;&lt; \" , \" &lt;&lt; rit-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Rev Pre-decrement: \" &lt;&lt; (rit--)-&gt;first &lt;&lt; \" , \" &lt;&lt; rit-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Rev Post-decrement: \" &lt;&lt; (--rit)-&gt;first &lt;&lt; \" , \" &lt;&lt; rit-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Rev Iterator addition: \" &lt;&lt; (rit+2)-&gt;first &lt;&lt; \" , \" &lt;&lt; (rit+2)-&gt;second &lt;&lt; endl;\ncout &lt;&lt; \"Rev Iterator subtraction: \"&lt;&lt; (rit-2)-&gt;first &lt;&lt; \" , \" &lt;&lt; (rit-2)-&gt;second &lt;&lt; endl;\n</code></pre>\n<p>The test results are as expected for all tests except the last two lines</p>\n<p><strong><em>The last two lines of the test break down when the optimization is turned on.</em></strong></p>\n<p>The system actually work well and is not so more dangerous than any other iterator. Of course it will fail if the container gets deleted under his nose and it's probably safer to use the returned value by copy and not just keep the reference around, but this is off-topic</p>\n", "Id": "35770904", "ViewCount": "157", "LastEditorUserId": "1469167"}, "bq_ids": {"n3337": {"so_35770904_35772549_2": {"quality": 0.8, "length": 20, "section_id": 5393}, "so_35770904_35773067_3": {"quality": 0.8, "length": 20, "section_id": 5393}}}, "35772188": {"PostTypeId": "2", "ParentId": "35770904", "Body": "<p>Provided you have to post a compilable snippet that reproduces that problem (actually I was not able to reproduce it with GCC 4.9) I think you have undefined behaviour and that is triggered by O2 (O2 enables optimizations that can break undefined behaviours). You should have a pointer to </p>\n<pre><code>Container&lt;T&gt; \n</code></pre>\n<p>inside the iterator.</p>\n<p>Anyway be aware that a lazy iterator breaks the contract of std's iterators, I think a better alternative is to make a regular container of <strong>lazy values</strong>, you could this way skip to create a custom container and iterator altogether ;)  (look to proxy pattern).</p>\n", "CreationDate": "2016-03-03T12:27:10.460", "Score": "1", "LastEditDate": "2016-03-03T13:16:56.513", "CommentCount": "2", "Id": "35772188", "OwnerUserId": "1829943", "LastEditorUserId": "1829943", "LastActivityDate": "2016-03-03T13:16:56.513"}});