post_cb({"32597412": {"ParentId": "32235765", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_32235765_32597412_0\">Declarations from namespaces associated with the types of the function arguments both from the instantiation context and from the definition context.</p>\n</blockquote>\n<p>Example with the following code which prints <code>B::foo</code> <a href=\"http://coliru.stacked-crooked.com/a/e7a45ccf89816a66\" rel=\"nofollow\">Demo</a></p>\n<pre><code>namespace A\n{\n    template &lt;typename T&gt;\n    void foo(const T&amp;) {std::cout &lt;&lt; \"A::foo\" &lt;&lt; std::endl;}\n\n    template &lt;typename T&gt;\n    void bar(const T&amp; t) {\n        foo(t); // thank to ADL, it will  also look at B::foo for B::S.\n    }\n}\n\nnamespace B\n{\n    struct S {};\n\n    void foo(const S&amp;) {std::cout &lt;&lt; \"B::foo\" &lt;&lt; std::endl;}\n}\n\nint main()\n{\n    B::S s;\n    A::bar(s);\n}\n</code></pre>\n<p>So when calling <code>?::foo(const B::S&amp;)</code>, the second bullet point adds <code>B::foo</code> to the list of overloads.</p>\n<blockquote>\n<p id=\"so_32235765_32597412_1\">why template-specialization works in this case</p>\n</blockquote>\n<p>There is only one function:</p>\n<pre><code>template&lt;&gt;\nvoid DoStuffUtilNamespace::doStuff&lt;MyClassThatCanDoStuff&gt;(MyClassThatCanDoStuff&amp; foo);\n</code></pre>\n<p>even if it is defined later.\nNote that the fact that there is a specialization should be known in the translation unit, else the program is ill formed (doesn't respect ODR).</p>\n<blockquote>\n<p id=\"so_32235765_32597412_2\">while overloading doesn't.</p>\n</blockquote>\n<p>You think:</p>\n<blockquote>\n<p id=\"so_32235765_32597412_3\">So I think that explains why <code>util.doStuffWithObjectRef(foo);</code> triggers the static assertion: <code>doStuff(MyClassThatCanDoStuff&amp;)</code> hasn't been declared at the point of definition of <code>UtilForDoingStuff::doStuffWithObjectRef&lt;UNKNOWN&gt;(UNKNOWN&amp;)</code>. And indeed moving the class <code>UtilForDoingStuff</code> definition after the <code>doStuff</code> overload has been defined seems to fix the issue.</p>\n</blockquote>\n<p>Exactly.</p>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "32597412", "Score": "0", "CreationDate": "2015-09-15T23:42:21.090", "LastActivityDate": "2015-09-15T23:42:21.090"}, "32244395": {"ParentId": "32235765", "CommentCount": "1", "Body": "<p>With template specialization I can get it work:</p>\n<pre><code>namespace DoStuffUtilNamespace\n{\n  template&lt;typename UNKNOWN&gt;\n  void doStuff(UNKNOWN&amp; foo)\n  {\n    static_assert(sizeof(UNKNOWN) == -1, \"CANNOT USE DEFAULT INSTANTIATION!\");\n  }\n}\n\nclass UtilForDoingStuff\n{\n  public:\n    template &lt;typename UNKNOWN&gt;\n      void doStuffWithObjectRef(UNKNOWN&amp; ref)\n      {\n        DoStuffUtilNamespace::doStuff(ref);\n      }\n};\n\nclass MyClassThatCanDoStuff { };\n\n\nnamespace DoStuffUtilNamespace\n{\n  using ::MyClassThatCanDoStuff;\n  template &lt;&gt; void doStuff&lt;MyClassThatCanDoStuff&gt;(MyClassThatCanDoStuff&amp; foo) { /* No assertion! */ }\n}\n\n\nint main()\n{\n  MyClassThatCanDoStuff foo;\n  DoStuffUtilNamespace::MyClassThatCanDoStuff scoped_foo; \n  UtilForDoingStuff util;\n\n  DoStuffUtilNamespace::doStuff(foo);         // Compiles\n  DoStuffUtilNamespace::doStuff(scoped_foo);  // Compiles\n  util.doStuffWithObjectRef(foo);             // Compiles\n  util.doStuffWithObjectRef(scoped_foo);      // Compiles\n}\n</code></pre>\n", "OwnerUserId": "5271927", "PostTypeId": "2", "Id": "32244395", "Score": "1", "CreationDate": "2015-08-27T08:32:59.887", "LastActivityDate": "2015-08-27T08:32:59.887"}, "bq_ids": {"n4140": {"so_32235765_32597412_0": {"section_id": 215, "quality": 1.0, "length": 11}, "so_32235765_32604022_4": {"section_id": 188, "quality": 0.9354838709677419, "length": 29}, "so_32235765_32604022_6": {"section_id": 214, "quality": 1.0, "length": 12}, "so_32235765_32604022_10": {"section_id": 7104, "quality": 0.9577464788732394, "length": 68}, "so_32235765_32235765_0": {"section_id": 215, "quality": 1.0, "length": 6}, "so_32235765_32235765_1": {"section_id": 215, "quality": 1.0, "length": 5}, "so_32235765_32604022_1": {"section_id": 7103, "quality": 0.8928571428571429, "length": 25}, "so_32235765_32235765_2": {"section_id": 215, "quality": 1.0, "length": 11}, "so_32235765_32604022_8": {"section_id": 7104, "quality": 0.9318181818181818, "length": 41}}, "n3337": {"so_32235765_32597412_0": {"section_id": 209, "quality": 1.0, "length": 11}, "so_32235765_32604022_4": {"section_id": 182, "quality": 0.8709677419354839, "length": 27}, "so_32235765_32604022_6": {"section_id": 208, "quality": 1.0, "length": 12}, "so_32235765_32604022_10": {"section_id": 6848, "quality": 0.9295774647887324, "length": 66}, "so_32235765_32604022_1": {"section_id": 6847, "quality": 0.8214285714285714, "length": 23}, "so_32235765_32235765_0": {"section_id": 209, "quality": 1.0, "length": 6}, "so_32235765_32235765_1": {"section_id": 209, "quality": 1.0, "length": 5}, "so_32235765_32235765_2": {"section_id": 209, "quality": 1.0, "length": 11}, "so_32235765_32604022_8": {"section_id": 6848, "quality": 0.9318181818181818, "length": 41}}, "n4659": {"so_32235765_32604022_4": {"section_id": 193, "quality": 0.9032258064516129, "length": 28}, "so_32235765_32597412_0": {"section_id": 223, "quality": 1.0, "length": 11}, "so_32235765_32604022_6": {"section_id": 222, "quality": 1.0, "length": 12}, "so_32235765_32604022_10": {"section_id": 8605, "quality": 0.9577464788732394, "length": 68}, "so_32235765_32604022_1": {"section_id": 8604, "quality": 0.8928571428571429, "length": 25}, "so_32235765_32235765_1": {"section_id": 223, "quality": 1.0, "length": 5}, "so_32235765_32235765_2": {"section_id": 223, "quality": 1.0, "length": 11}, "so_32235765_32604022_8": {"section_id": 8605, "quality": 0.8409090909090909, "length": 37}, "so_32235765_32235765_0": {"section_id": 223, "quality": 1.0, "length": 6}}}, "32604022": {"ParentId": "32235765", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_32235765_32604022_0\">With the namespace, <code>doStuff</code> is of course a dependent name.</p>\n</blockquote>\n<p>You are starting from the wrong premise.  There is no ADL for a qualified call like <code>DoStuffUtilNamespace::doStuff(ref)</code>. [basic.lookup.argdep]/p1, emphasis mine:</p>\n<blockquote>\n<p id=\"so_32235765_32604022_1\"><strong>When the <em>postfix-expression</em> in a function call (5.2.2) is an\n  <em>unqualified-id</em></strong>, other namespaces not considered during the usual\n  unqualified lookup (3.4.1) may be searched, and in those namespaces,\n  namespace-scope friend function or function template declarations\n  (11.3) not otherwise visible may be found.</p>\n</blockquote>\n<p><code>DoStuffUtilNamespace::doStuff</code> is a <em>qualified-id</em>, not an <em>unqualified-id</em>. ADL doesn't apply.</p>\n<p>For this reason, <code>DoStuffUtilNamespace::doStuff</code> is also not a dependent name. [temp.dep]/p1:</p>\n<blockquote>\n<p id=\"so_32235765_32604022_2\">In an expression of the form:</p>\n<blockquote>\n<p id=\"so_32235765_32604022_5\"><em>postfix-expression ( expression-list<sub>opt</sub>)</em></p>\n</blockquote>\n<p id=\"so_32235765_32604022_4\">where the <em>postfix-expression</em> is an <em>unqualified-id</em>, the\n  <em>unqualified-id</em> denotes a <em>dependent name</em> if [...]. If an operand of an operator is a type-dependent expression, the operator also denotes\n  a dependent name. Such names are unbound and are looked up at the\n  point of the template instantiation (14.6.4.1) in both the context of\n  the template definition and the context of the point of instantiation</p>\n</blockquote>\n<p>(The italicization of <em>dependent name</em> indicate that this paragraph is defining the term.)</p>\n<p>Instead, per [temp.nondep]/p1:</p>\n<blockquote>\n<p id=\"so_32235765_32604022_6\">Non-dependent names used in a template definition are found using the\n  usual name lookup and bound at the point they are used.</p>\n</blockquote>\n<p>which doesn't find your later overload declaration.</p>\n<hr>\n<p>Specialization works because it's still the same function template declaration that's used; you just supplied a different implementation than the default one.</p>\n<hr>\n<blockquote>\n<p id=\"so_32235765_32604022_7\">But what exactly does the standard mean by \"namespaces associated with\n  the types of the function arguments\"? Shouldn't the <code>using ::MyClassThatCanDoStuff</code> declaration, together\n  with the explicit scoping of the scoped_foo instance type within the\n  namespace, trigger argument-dependent lookup</p>\n</blockquote>\n<p>No. <em>using-declaration</em>s do not affect ADL. [basic.lookup.argdep]/p2, emphasis mine:</p>\n<blockquote>\n<p id=\"so_32235765_32604022_8\">For each argument type <code>T</code> in the function call, there is a set of\n  zero or more associated namespaces and a set of zero or more\n  associated classes to be considered. The sets of namespaces and\n  classes is determined entirely by the types of the function arguments\n  (and the namespace of any template template argument).\n  <strong>Typedef names and <em>using-declaration</em>s used to specify the types do not contribute to this set.</strong> The sets of namespaces and classes are\n  determined in the following way:</p>\n<ul>\n<li><p id=\"so_32235765_32604022_9\">If T is a fundamental type, [...]</p></li>\n<li><p id=\"so_32235765_32604022_10\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its\n  direct and indirect base classes. Its associated namespaces are the\n  innermost enclosing namespaces of its associated classes. Furthermore,\n  if T is a class template specialization, its associated namespaces and\n  classes also include: the namespaces and classes associated with the\n  types of the template arguments provided for template type parameters\n  (excluding template template parameters); the namespaces of which any\n  template template arguments are members; and the classes of which any\n  member templates used as template template arguments are members. [\n  <em>Note</em>: Non-type template arguments do not contribute to the set of associated namespaces. \u2014<em>end note</em> ]</p></li>\n<li><p id=\"so_32235765_32604022_11\">[...]</p></li>\n</ul>\n</blockquote>\n</hr></hr>", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-09-16T09:55:40.253", "Id": "32604022", "Score": "2", "CreationDate": "2015-09-16T08:59:48.070", "LastActivityDate": "2015-09-16T09:55:40.253"}, "32235765": {"CommentCount": "0", "ViewCount": "212", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-08-26T20:07:24.930", "LastActivityDate": "2015-09-16T09:55:40.253", "Title": "Namespace causes sub-optimal template overload resolution", "AcceptedAnswerId": "32604022", "LastEditDate": "2017-05-23T12:22:26.013", "Id": "32235765", "Score": "2", "Body": "<p>This is very similar to <a href=\"https://stackoverflow.com/q/18493826/1858225\">this question</a>, but I'm not sure the answer there is entirely applicable to the minimal code I've put together that demonstrates the issue. (My code does <em>not</em> use trailing-return types, and there are some other differences as well.) Additionally, the issue of whether MSVC's behavior is legal doesn't seem to be addressed.</p>\n<p>In short, I'm seeing the compiler select a generic function template instantiation rather than a more-specific overload when the function template is inside a namespace.</p>\n<p>Consider the following set of namespace and class definitions:</p>\n<pre><code>namespace DoStuffUtilNamespace\n{\n  template&lt;typename UNKNOWN&gt;\n  void doStuff(UNKNOWN&amp; foo)\n  {\n    static_assert(sizeof(UNKNOWN) == -1, \"CANNOT USE DEFAULT INSTANTIATION!\");\n  }\n}\n\nclass UtilForDoingStuff\n{\n  public:\n    template &lt;typename UNKNOWN&gt;\n      void doStuffWithObjectRef(UNKNOWN&amp; ref)\n      {\n        DoStuffUtilNamespace::doStuff(ref);\n      }\n};\n\nclass MyClassThatCanDoStuff { };\n\nnamespace DoStuffUtilNamespace\n{\n  using ::MyClassThatCanDoStuff;      // No effect.\n\n  void doStuff(MyClassThatCanDoStuff&amp; foo) { /* No assertion! */ }\n}\n</code></pre>\n<p>... and the following use-cases:</p>\n<pre><code>int main()\n{\n  MyClassThatCanDoStuff foo;\n  DoStuffUtilNamespace::MyClassThatCanDoStuff scoped_foo;\n  UtilForDoingStuff util;\n\n  DoStuffUtilNamespace::doStuff(foo);         // Compiles\n  DoStuffUtilNamespace::doStuff(scoped_foo);  // Compiles\n  util.doStuffWithObjectRef(foo);             // Triggers static assert\n  util.doStuffWithObjectRef(scoped_foo);      // Triggers static assert\n}\n</code></pre>\n<p>If the entire <code>DoStuffUtilNamespace</code> is eliminated and all its members are moved to global scope, this compiles fine with G++ and Clang++.</p>\n<p><em>With</em> the namespace, <code>doStuff</code> is of course a dependent name. According to the <a href=\"https://stackoverflow.com/a/18516246/1858225\">top-voted answer on the similar question</a>, the standard says:</p>\n<blockquote>\n<p id=\"so_32235765_32235765_0\">In resolving dependent names, names from the following sources are considered:</p>\n<ul>\n<li><p id=\"so_32235765_32235765_1\">Declarations that are visible at the point of definition of the template.</p></li>\n<li><p id=\"so_32235765_32235765_2\">Declarations from namespaces associated with the types of the function arguments both from the instantiation context and from the definition context.</p></li>\n</ul>\n</blockquote>\n<p>This seems a little odd to me; I don't understand why the first bullet point would specify that the declarations must be visible at the point of <em>definition</em> of the template rather than at the point of <em>instantiation</em>, since the second bullet point explicitly specifies that <em>some</em> declarations visible only at the point of instantiation <em>are</em> allowed. (If someone would like to offer a rationale, I'd appreciate it, but that's not my question because it's my understanding that questions of the form \"why did the standards committee decide X\" are off topic.)</p>\n<p>So I <em>think</em> that explains why <code>util.doStuffWithObjectRef(foo);</code> triggers the static assertion: <code>doStuff(MyClassThatCanDoStuff&amp;)</code> hasn't been declared at the point of definition of <code>UtilForDoingStuff::doStuffWithObjectRef&lt;UNKNOWN&gt;(UNKNOWN&amp;)</code>. And indeed moving the <code>class UtilForDoingStuff</code> definition <em>after</em> the <code>doStuff</code> overload has been defined seems to fix the issue.</p>\n<p>But what exactly does the standard mean by \"namespaces associated with the types of the function arguments\"? Shouldn't the <code>using ::MyClassThatCanDoStuff</code> declaration, together with the explicit scoping of the <code>scoped_foo</code> instance type within the namespace, trigger argument-dependent lookup, and shouldn't this look-up find the non-asserting definition of <code>doStuff()</code>?</p>\n<p>Also, the entire code is compiled without error using <code>clang++ -ftemplate-delayed-parsing</code>, which emulates MSVC's template-parsing behavior. This seems preferable, at least in this particular case, because the ability to add new declarations to a namespace at any time is one of the primary appeals of namespaces. But, as noted above, it doesn't quite seem to follow the letter of the law, according to the standard. Is it permissible, or is it an instance of non-conformance?</p>\n<p><strong>EDIT::</strong> As pointed out by KIIV, there is a workaround; the code compiles if template specialization is used instead of overloading. I would still like to know the answers to my questions about the standard.</p>\n", "Tags": "<c++><templates><namespaces><argument-dependent-lookup>", "OwnerUserId": "1858225", "AnswerCount": "3"}});