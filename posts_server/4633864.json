post_cb({"4633864": {"ViewCount": "9474", "Body": "<p>It is well known that the user can define stream manipulators like this:</p>\n<pre><code>ostream&amp; tab(ostream &amp; output)\n{\n    return output&lt;&lt; '\\t';\n} \n</code></pre>\n<p>And this can be used in <em>main()</em> like this:</p>\n<pre><code>cout&lt;&lt;'a'&lt;&lt;tab&lt;&lt;'b'&lt;&lt;'c'&lt;&lt;endl;\n</code></pre>\n<p>Please explain me how does this all work? If <em>operator&lt;&lt;</em> assumes as a second parameter a pointer to the function that takes and returns <strong>ostream &amp;</strong>, then please explain my why it is necessary? What would be wrong if the function does not take and return <strong>ostream &amp;</strong> but it was <em>void</em> instead of <em>ostream &amp;</em>? </p>\n<p>Also it is interesting why \u201cdec\u201d, \u201chex\u201d manipulators take effect until I don\u2019t change between them, but user defined manipulators should be always used in order to take effect for each streaming?</p>\n", "AcceptedAnswerId": "4633903", "Title": "How do the stream manipulators work?", "CreationDate": "2011-01-08T12:32:59.697", "Id": "4633864", "CommentCount": "10", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2015-08-07T17:44:32.053", "LastEditorUserId": "881229", "LastActivityDate": "2017-07-14T11:54:02.477", "Score": "17", "OwnerUserId": "163394", "Tags": "<c++><iostream><ostream>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_4633864_4633903_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 2293}}, "n3337": {"so_4633864_4633903_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 2280}}, "n4659": {"so_4633864_4633903_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 2566}}}, "6312665": {"Id": "6312665", "PostTypeId": "2", "Body": "<p>There is nothing wrong with it except there is no overloaded &lt;&lt; operator defined for it. The existing overloads for &lt;&lt; are expecting a manipulator with the signature <strong>ostream&amp; (*fp)(ostream&amp;)</strong>. </p>\n<p>If you gave it a manipulator with the type <strong>ostream&amp; (*fp)()</strong> you would get a compiler error since it <strong>does not</strong> have a definition for <strong>operator&lt;&lt;(ostream&amp;, ostream&amp; (*fp)())</strong>. If you wanted this functionality you would have to overload the &lt;&lt; operator to accept manipulators of this type.</p>\n<p>You would have to write a definition for this: <br>\n<strong>ostream&amp; ostream::operator&lt;&lt;(ostream&amp; (*m)())</strong></br></p>\n<p>Keep in mind here that nothing magical is happening here. The stream libraries rely heavily on <em>standard</em> C++ features: operator overloading, classes and references. </p>\n<p>Now that you know how you can create the functionality you described, here's why we don't: </p>\n<p>Without passing a reference to the stream we are trying to manipulate, we can't make modifications to the stream connected to final device (cin, out, err, fstream, etc). The function (modifier's are all just functions with fancy names) would either have to return a new ostream that had nothing to do with the one to the left of the &lt;&lt; operator, or through some very ugly mechanism, figure out which ostream it should connect with else everything to right of the modifier wont make it to the final device, but would rather be sent to whatever ostream the function/modifier returned.</p>\n<p>Think of streams like this</p>\n<pre><code>cout &lt;&lt; \"something here\" &lt;&lt; tab &lt;&lt; \"something else\"&lt;&lt; endl;\n</code></pre>\n<p>really means</p>\n<pre><code>(((cout &lt;&lt; \"something here\") &lt;&lt; tab ) &lt;&lt; \"something else\" ) &lt;&lt; endl);\n</code></pre>\n<p>where each set of parentheses does something to cout (write, modify etc) and then returns cout so the next set of parentheses can work on it. </p>\n<p>If your tab modifier/function did not take a reference to an ostream it would have to somehow guess what ostream was to left of the &lt;&lt; operator to perform its task. Were you working with cour, cerr, some file stream...? The internals of the function will never know unless they are handed that information some how, and why not that how be as simple as a reference to it.  </p>\n<p>Now to really drive the point home, let's look at what <strong>endl</strong> really is and which overloaded version of the &lt;&lt; operator we are using:</p>\n<p>This operator looks like this:</p>\n<pre><code>  ostream&amp; ostream::operator&lt;&lt;(ostream&amp; (*m)(ostream&amp;)) \n  {  \n      return (*m)(*this);\n  }\n</code></pre>\n<p>endl looks like this:</p>\n<pre><code>  ostream&amp; endl(ostream&amp; os)      \n  {  \n      os &lt;&lt; '\\n'; \n      os.flush();     \n      return os;\n  }\n</code></pre>\n<p>The purpose of endl is to add a newline and flush the stream, making sure all the contents of the stream\u2019s internal buffer have been written to the device. In order to do this, it first needs to write a '\\n' to this stream. It then needs to tell the stream to flush. The only way for endl to know which stream to write to and flush is for the operator to pass that information to the endl function when it calls it. It'd be like me telling you to wash my car, but never telling you which car is mine in the full parking lot. You'd never be able to get your job done. You need me to either hand you my car or I can wash it myself. </p>\n<p>I hope that clears things up</p>\n<p>PS - If you do happen to accidentally find my car, please wash it.</p>\n", "LastActivityDate": "2011-06-10T22:24:20.713", "CommentCount": "0", "CreationDate": "2011-06-10T22:24:20.713", "ParentId": "4633864", "Score": "7", "OwnerUserId": "444826"}, "4633903": {"Id": "4633903", "PostTypeId": "2", "Body": "<p>The standard defines the following <code>operator&lt;&lt;</code> overload in the <code>basic_ostream</code> class template:</p>\n<pre><code>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(\n    basic_ostream&lt;charT,traits&gt;&amp; (*pf) (basic_ostream&lt;charT,traits&gt;&amp;) );\n</code></pre>\n<blockquote>\n<p id=\"so_4633864_4633903_0\">Effects: None. Does not behave as a formatted output function (as described in 27.6.2.5.1).</p>\n<p id=\"so_4633864_4633903_1\">Returns: <code>pf(*this)</code>.</p>\n</blockquote>\n<p>The parameter is a pointer to a function taking and returning a reference to a <code>std::ostream</code>.</p>\n<p>This means that you can \"stream\" a function with this signature to an <code>ostream</code> object and it has the effect of calling that function on the stream. If you use the name of a function in an expression then it is (usually) converted to a pointer to that function.</p>\n<p><code>std::hex</code> is an <code>std::ios_base</code> manipulator defined as follows.</p>\n<pre><code>   ios_base&amp; hex(ios_base&amp; str);\n</code></pre>\n<blockquote>\n<p id=\"so_4633864_4633903_2\">Effects: Calls <code>str.setf(ios_base::hex, ios_base::basefield)</code>.</p>\n<p id=\"so_4633864_4633903_3\">Returns: str.</p>\n</blockquote>\n<p>This means that streaming <code>hex</code> to an <code>ostream</code> will set the output base formatting flags to output numbers in hexadecimal. The manipulator doesn't output anything itself.</p>\n", "LastEditorUserId": "180275", "LastActivityDate": "2017-07-14T11:54:02.477", "Score": "20", "CreationDate": "2011-01-08T12:43:02.430", "ParentId": "4633864", "CommentCount": "3", "OwnerUserId": "19563", "LastEditDate": "2017-07-14T11:54:02.477"}, "4633892": {"Id": "4633892", "PostTypeId": "2", "Body": "<p>Normally the stream manipulator sets some flags (or other settings) on the stream object, so that next time it is used, it will act according to the flags. The manipulator therefore returns the same object its passed. The <code>operator&lt;&lt;</code> overload that called the manipulator already has this object, of course, so as you noticed, the return value isn't strictly needed for that case. I think this covers all the standard manipulators - they all return their input.</p>\n<p>However, with the return value, the framework is flexible enough that a custom stream manipulator <em>could</em> return a different object, presumably a wrapper for the object its given. This other object would then be returned from <code>cout &lt;&lt; 'a' &lt;&lt; tab</code>, and could do something that the built-in <code>ostream</code> formatting settings don't support.</p>\n<p>Not sure how you'd arrange for this other object to be freed, though, so I don't know how practical this is. It might have to be something peculiar, like a proxy object that's managed by the <code>ostream</code> itself. Then the manipulator would only work for custom stream classes that actively support it, which isn't usually the point of manipulators.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-01-08T12:53:19.263", "Score": "4", "CreationDate": "2011-01-08T12:40:58.320", "ParentId": "4633864", "CommentCount": "0", "OwnerUserId": "13005", "LastEditDate": "2011-01-08T12:53:19.263"}});