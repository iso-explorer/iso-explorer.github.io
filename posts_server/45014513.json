post_cb({"45014642": {"ParentId": "45014513", "CommentCount": "3", "Body": "<p>No.</p>\n<blockquote>\n<p id=\"so_45014513_45014642_0\"><code>[C++11: 25.2.5/3]:</code> Each unordered associative container is parameterized by <code>Key</code>, by a function object type <code>Hash</code> that meets the <code>Hash</code> requirements (17.6.3.4) and acts as a hash function for argument values of type <code>Key</code>, and by <strong>a binary predicate <code>Pred</code> that induces an equivalence relation on values of type <code>Key</code></strong>. Additionally, <code>unordered_map</code> and <code>unordered_multimap</code> associate an arbitrary mapped type <code>T</code> with the <code>Key</code>.</p>\n</blockquote>\n<p>Table 17 tells us the <code>EqualityComparable</code> requirements:</p>\n<blockquote>\n<p id=\"so_45014513_45014642_1\"><code>==</code> is an equivalence relation, that is, it has the following properties:</p>\n<ul>\n<li>For all <code>a</code>, <code>a == a</code>.</li>\n<li><strong>If <code>a == b</code>, then <code>b == a</code>.</strong></li>\n<li>If <code>a == b</code> and <code>b == c</code>, then <code>a == c</code>.</li>\n</ul>\n</blockquote>\n<p><sup><em>(gah! comma splice!)</em></sup></p>\n<p>And note that the given semantics of the comparator makes no mention of which way around the operands are given:</p>\n<blockquote>\n<p id=\"so_45014513_45014642_2\"><code>[C++11: 25.2.5/5]:</code> Two values <code>k1</code> and <code>k2</code> of type <code>Key</code> are considered equivalent if the container\u2019s <code>key_equal</code> function object returns <code>true</code> when passed those values. <em>[..]</em></p>\n</blockquote>\n<p>Put simply, your program has undefined behaviour if it matters which order the arguments are supplied.</p>\n<p>This is not a C++ oddity, either; <a href=\"https://en.wikipedia.org/wiki/Equivalence_relation\" rel=\"noreferrer\">equivalence implies symmetry throughout mathematics</a>.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "45014642", "Score": "11", "CreationDate": "2017-07-10T14:25:09.227", "LastActivityDate": "2017-07-10T14:25:09.227"}, "45014513": {"CommentCount": "4", "CreationDate": "2017-07-10T14:19:24.893", "PostTypeId": "1", "AcceptedAnswerId": "45014642", "LastEditorUserId": "5497004", "LastActivityDate": "2017-07-11T05:48:31.480", "LastEditDate": "2017-07-11T05:48:31.480", "ViewCount": "112", "FavoriteCount": "2", "Title": "Does C++ guarantee the order of operands in comparisons made by standard containers?", "Id": "45014513", "Score": "2", "Body": "<p>TL;DR: I have a use case where it matters whether <code>WidgetEqualTo()(new_widget, widget_inside_container)</code> or <code>WidgetEqualTo()(widget_inside_container, new_widget)</code> is called.</p>\n<p>Identical Widgets may be re-created many times so I have a <code>WidgetPool</code> (for the purposes of this example, a global wrapper around <code>std::vector&lt;const Widget*&gt;</code>) and a smart constructor:</p>\n<pre><code>const Widget* combine(const Widget* a, const Widget* b) {\n  static std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; cache;\n  std::pair&lt;int, int&gt; ab = std::make_pair(a-&gt;id(), b-&gt;id());\n  const auto it = cache.find(ab);\n  if (it == cache.end()) {\n    // The Widget ctor sets this-&gt;id() to WidgetPool::size()\n    // and appends this to WidgetPool.\n    const Widget* result = new Widget(a, b);\n    cache[ab] = result-&gt;id();\n    return result;\n  } else {\n    return WidgetPool::get_widget(it-&gt;second);\n  }\n}\n</code></pre>\n<p>I also have a container where Widgets get inserted in the order of their creation.  Say, <code>std::unordered_set&lt;const Widget*, WidgetHash, WidgetEqualTo&gt;</code>, where <code>WidgetEqualTo</code> looks like this:</p>\n<pre><code>struct WidgetEqualTo {\n  bool operator()(const Widget* a, const Widget* b) const {\n    if (a == b) {\n      return true;\n    }\n    // My Widgets obey the associative law:\n    // tedious_comparison(new Widget(new Widget(p, q), r),\n    //                    new Widget(p, new Widget(q, r))) == true.\n    const bool are_equal = tedious_comparison(a, b);\n    if (are_equal) {\n      // Cache the result of the comparison.\n      // Retain the older Widget.\n      if (a-&gt;id() &lt; b-&gt;id()) {  // (***)\n        WidgetPool::set_widget(b-&gt;id(), a);\n        delete b;\n      } else {\n        WidgetPool::set_widget(a-&gt;id(), b);\n        delete a;\n      }\n    }\n    return are_equal;\n  }\n};\n</code></pre>\n<p>If <code>WidgetEqualTo()</code> were always called with <code>(new_element, element_already_inside_unordered_set)</code> or the other way around, I could remove one branch of the test marked with <code>(***)</code>.  FWIW, libstdc++ appears to call <code>WidgetEqualTo()(new_element, old_element)</code>.  Does the C++ standard guarantee this behavior?</p>\n", "Tags": "<c++><c++11><c++-standard-library><unordered-set>", "OwnerUserId": "5497004", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45014513_45014642_0": {"section_id": 755, "quality": 0.9, "length": 36}, "so_45014513_45014642_2": {"section_id": 757, "quality": 0.7058823529411765, "length": 12}, "so_45014513_45014642_1": {"section_id": 6276, "quality": 1.0, "length": 4}}, "n3337": {"so_45014513_45014642_0": {"section_id": 743, "quality": 0.9, "length": 36}, "so_45014513_45014642_2": {"section_id": 745, "quality": 0.8823529411764706, "length": 15}, "so_45014513_45014642_1": {"section_id": 6036, "quality": 1.0, "length": 4}}, "n4659": {"so_45014513_45014642_0": {"section_id": 815, "quality": 0.9, "length": 36}, "so_45014513_45014642_2": {"section_id": 817, "quality": 0.7058823529411765, "length": 12}, "so_45014513_45014642_1": {"section_id": 7783, "quality": 1.0, "length": 4}}}});