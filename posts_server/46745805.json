post_cb({"46748653": {"ParentId": "46745805", "LastEditDate": "2017-10-14T20:12:20.927", "CommentCount": "2", "CreationDate": "2017-10-14T19:45:18.407", "OwnerUserId": "2015579", "LastEditorUserId": "2015579", "PostTypeId": "2", "Id": "46748653", "Score": "2", "Body": "<p>My reading of the standard suggests that both these functions will result in UB.</p>\n<p>consider:</p>\n<pre><code>int main()\n{\n    long x = 10;\n    something_with_x(x*10);\n    double&amp; y = pseudo_cast_inplace&lt;double&gt;(x);\n    y = 20;\n    something_with_y(y*10);\n}\n</code></pre>\n<p>Because of the strict alias rule, it seems to me that there's nothing to stop the compiler from reordering instructions to produce code as-if:</p>\n<pre><code>int main()\n{\n    long x = 10;\n    double&amp; y = pseudo_cast_inplace&lt;double&gt;(x);\n    y = 20;\n    something_with_x(x*10);   // uh-oh!\n    something_with_y(y*10);\n}\n</code></pre>\n<p>I think the only legal way to write this is:</p>\n<pre><code>template &lt;typename T, typename U&gt;\ninline T pseudo_cast(U&amp;&amp; x)\n{\n    static_assert(sizeof(T) == sizeof(U));\n    T result;\n    std::memcpy(std::addressof(result), std::addressof(x), sizeof(T));\n    return result;\n}\n</code></pre>\n<p>Which in reality results in the exact same assembler output (i.e. none whatsoever - the entire function is elided, as are the variables themselves) - at least on gcc with -O2</p>\n", "LastActivityDate": "2017-10-14T20:12:20.927"}, "46746399": {"ParentId": "46745805", "CommentCount": "6", "Body": "<p>C++ does not allow a <code>double</code> to be constructed merely by copying the bytes. An object first needs to be constructed (which may leave its value uninitialised), and only after that can you fill in its bytes to produce a value. This was underspecified up to C++14, but the current draft of C++17 includes in [intro.object]:</p>\n<blockquote>\n<p id=\"so_46745805_46746399_0\">An <em>object</em> is created by a definition (6.1), by a <em>new-expression</em> (8.3.4), when implicitly changing the active member of a union (12.3), or when a temporary object is created (7.4, 15.2).</p>\n</blockquote>\n<p>Although constructing a <code>double</code> with default initialision does not perform any initialisation, the construction does still need to happen. Your first version includes this construction by declaring the local variable <code>T to;</code>. Your second version does not.</p>\n<p>You could modify your second version to use placement <code>new</code> to construct a <code>T</code> in the same location that previously held an <code>U</code> object, but in that case, when you pass <code>&amp;x</code> to <code>memmove</code>, it is no longer required to read the bytes that had made up <code>x</code>'s value, because the object <code>x</code> has already been destroyed by the earlier placement <code>new</code>.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "46746399", "Score": "3", "CreationDate": "2017-10-14T15:49:45.927", "LastActivityDate": "2017-10-14T15:49:45.927"}, "46747412": {"ParentId": "46745805", "CommentCount": "0", "Body": "<p>Accessing a <code>double</code> while the actual type is <code>uint64_t</code> is <em>undefined behavior</em> because compiler will never consider that an object of type <code>double</code> can share the address of an object of type <code>uint64_t</code> <a href=\"http://eel.is/c++draft/intro.object#8\" rel=\"nofollow noreferrer\">intro.object</a>:</p>\n<blockquote>\n<p id=\"so_46745805_46747412_0\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies.\n  Two objects <em>a</em> and <em>b</em> with overlapping lifetimes that are not bit-fields may have the same address if one is nested within the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they have distinct addresses.</p>\n</blockquote>\n", "OwnerUserId": "5632316", "PostTypeId": "2", "Id": "46747412", "Score": "0", "CreationDate": "2017-10-14T17:32:53.563", "LastActivityDate": "2017-10-14T17:32:53.563"}, "46745805": {"CommentCount": "16", "CreationDate": "2017-10-14T14:46:57.923", "PostTypeId": "1", "AcceptedAnswerId": "46746399", "LastEditorUserId": "1149664", "LastActivityDate": "2017-10-14T20:12:20.927", "LastEditDate": "2017-10-14T15:18:09.187", "ViewCount": "132", "FavoriteCount": "2", "Title": "memmove in-place change of effective type (type-punning)", "Id": "46745805", "Score": "4", "Body": "<p>In the following question: \n<a href=\"https://stackoverflow.com/questions/17789928/whats-a-proper-way-of-type-punning-a-float-to-an-int-and-vice-versa#\">What's a proper way of type-punning a float to an int and vice-versa?</a>, the conclusion is that the way to construct doubles from integer bits and vise versa is via <code>memcpy</code>.</p>\n<p>That's fine, and the <code>pseudo_cast</code> conversion method found there is:</p>\n<pre><code>template &lt;typename T, typename U&gt;\ninline T pseudo_cast(const U &amp;x)\n{\n    static_assert(sizeof(T) == sizeof(U));    \n    T to;\n    std::memcpy(&amp;to, &amp;x, sizeof(T));\n    return to;\n}\n</code></pre>\n<p>and I would use it like this:</p>\n<pre><code>int main(){\n  static_assert(std::numeric_limits&lt;double&gt;::is_iec559);\n  static_assert(sizeof(double)==sizeof(std::uint64_t));\n  std::uint64_t someMem = 4614253070214989087ULL;\n  std::cout &lt;&lt; pseudo_cast&lt;double&gt;(someMem) &lt;&lt; std::endl; // 3.14\n}\n</code></pre>\n<p>My interpretation from just reading the standard and cppreference is/was that is should also be possible to use <code>memmove</code> to change the <a href=\"http://en.cppreference.com/w/c/language/object#Effective_type\" rel=\"nofollow noreferrer\">effective type</a> in-place, like this:</p>\n<pre><code>template &lt;typename T, typename U&gt;\ninline T&amp; pseudo_cast_inplace(U&amp; x)\n{\n    static_assert(sizeof(T) == sizeof(U));\n    T* toP = reinterpret_cast&lt;T*&gt;(&amp;x);\n    std::memmove(toP, &amp;x, sizeof(T));\n    return *toP;\n}\n\ntemplate &lt;typename T, typename U&gt;\ninline T pseudo_cast2(U&amp; x)\n{\n    return pseudo_cast_inplace&lt;T&gt;(x); // return by value\n}\n</code></pre>\n<p>The reinterpret cast <em>in itself</em> is legal for any pointer (as long as cv is not violated, item 5 at <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">cppreference/reinterpret_cast</a>). Dereferencing however requires <code>memcpy</code> <em>or <code>memmove</code></em> (\u00a76.9.2), and T and U must be trivially copyable.</p>\n<p>Is this legal? It compiles and does the right thing with gcc and clang.\n<code>memmove</code> source and destinations are explicitly allowed to overlap, according \nto cppreference <a href=\"http://en.cppreference.com/w/cpp/string/byte/memmove\" rel=\"nofollow noreferrer\">std::memmove</a> and <a href=\"http://en.cppreference.com/w/c/string/byte/memmove\" rel=\"nofollow noreferrer\">memmove</a>,</p>\n<blockquote>\n<p id=\"so_46745805_46745805_0\">The objects may overlap: copying takes place as if the characters were\n  copied to a temporary character array and then the characters were\n  copied from the array to dest.</p>\n</blockquote>\n<hr>\n<p>Edit: originally the question had a trivial error (causing segfault) spotted by @hvd. Thank you! The question remains the same, is this legal?</p>\n</hr>", "Tags": "<c++><type-punning>", "OwnerUserId": "1149664", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_46745805_46747412_0": {"section_id": 5795, "quality": 0.8809523809523809, "length": 37}}, "n3337": {"so_46745805_46747412_0": {"section_id": 5568, "quality": 0.8809523809523809, "length": 37}}, "n4659": {"so_46745805_46746399_0": {"section_id": 7247, "quality": 0.7647058823529411, "length": 13}, "so_46745805_46747412_0": {"section_id": 7254, "quality": 0.9761904761904762, "length": 41}}}});