post_cb({"24000244": {"ViewCount": "230", "Body": "<p>There is a quote from 5.2.4/1 of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">N3797</a>, the C++14 final working draft:</p>\n<blockquote>\n<p id=\"so_24000244_24000244_0\">The use of a pseudo-destructor-name after a dot . or arrow -&gt; operator\n  represents the destructor <strong>for the non-class type</strong> denoted by type-name\n  or decltype-specifier.</p>\n</blockquote>\n<hr>\n<p><strong>Question</strong></p>\n<ul>\n<li>For what type we can consider <code>pseudo-destructor-name</code>, is it <em>enum-type</em> only?</li>\n</ul>\n</hr>", "AcceptedAnswerId": "24000642", "Title": "Does pseudo-destructor-name make a sense for non-class and non-enum type?", "CreationDate": "2014-06-02T17:38:57.883", "Id": "24000244", "CommentCount": "4", "LastEditDate": "2014-06-02T18:44:05.643", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorUserId": "1090079", "LastActivityDate": "2014-06-02T18:46:45.110", "Score": "2", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24000244_24000244_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6002}}, "n3337": {"so_24000244_24000244_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5770}}, "n4659": {"so_24000244_24000244_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7501}}}, "24000468": {"Id": "24000468", "PostTypeId": "2", "Body": "<p>Like the text says, it's for all types, except for class types. In those rare cases where you need to explicitly call the destructor, the possibility of a pseudo-destructor call makes it possible to not worry about whether the type is a class type. If it's a class type, you'll call the actual destructor; it won't be a pseudo-destructor call. If it's not a class type, the expression is safe and has no effect.</p>\n", "LastActivityDate": "2014-06-02T17:54:20.783", "CommentCount": "0", "CreationDate": "2014-06-02T17:54:20.783", "ParentId": "24000244", "Score": "0", "OwnerUserId": "743382"}, "24000642": {"Id": "24000642", "PostTypeId": "2", "Body": "<p><strong>Is it <em>enum-type</em> only?</strong></p>\n<p>No, the <em>pseudo-destructor-call</em> is valid on <strong>any</strong> type.</p>\n<hr>\n<p><strong>But, what about... this?</strong></p>\n<pre><code>enum Foo : int { ... };\ntypedef int Bar;\n\nFoo a; a.~Foo ();         // (1), legal\nint b; b.~Bar ();         // (2), legal\nint c; c.~decltype(c) (); // (3), legal\n\n\nint d; d.~int ();         // (4), ill-formed... why?\n</code></pre>\n<p><sup></sup></p>\n<p>It seems odd that <em>(4)</em> is ill-formed, all others are legal; isn't the intent to invoke a <em>psuedo-constructor-call</em> on an <code>int</code> in all cases?</p>\n<p>It seems quite obvious that we are not using a <em>decltype-specifier</em> in neither <em>(3)</em> or <em>(4)</em>, so the question is:</p>\n<ul>\n<li>What is a <em>type-name</em>, and how does its definition affect the previously written snippet?</li>\n</ul>\n<hr>\n<p>The definition of <em>type-name</em> is available at <code>[dcl.type.simple]p1</code>, and says that a <em>type-name</em> is;</p>\n<ul>\n<li>a <em>class-name</em>, or;</li>\n<li>an <em>enum-name</em>, or;</li>\n<li>a <em>typedef-name</em>, or;</li>\n<li>a <em>simple-template-id</em>.</li>\n</ul>\n<p>Notice that the above list does not include <em>fundamental types</em>, and this is why <em>(4)</em> is ill-formed, and <em>(3)</em> isn't; even though we are invoking a <em>pseudo-destructor-call</em> on an <code>int</code> in both cases. </p>\n<p><code>int</code> is the name of a type, but it isn't a <em>type-name</em>.</p>\n</hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2014-06-02T18:26:33.150", "Score": "6", "CreationDate": "2014-06-02T18:05:10.103", "ParentId": "24000244", "CommentCount": "0", "OwnerUserId": "1090079", "LastEditDate": "2014-06-02T18:26:33.150"}});