post_cb({"11046918": {"Id": "11046918", "PostTypeId": "2", "Body": "<p>In C++, you can grant access beyond <code>private</code> on four levels.</p>\n<ul>\n<li>completely <code>public</code> access (see pmr's answer)</li>\n<li>access within inheritance hierarchy (<code>protected</code>, irrelevant here)</li>\n<li>to a base template <code>friend</code> (see this answer)</li>\n<li>to a non-template or fully specialized <code>friend</code> (too weak to solve your use case)</li>\n</ul>\n<p><em>There is no middle way between the two latter kinds of friendship.</em></p>\n<p>From \u00a714.5.4 of the C++ standard:.</p>\n<blockquote>\n<p id=\"so_11041274_11046918_0\">Friend declarations shall not declare partial specializations.</p>\n</blockquote>\n<p>The following declaration will allow you to implement what you need.  It gives you a free hand to access any specialization of your template from any other specialization, but still only within <code>X</code>.  It is slightly more permissive than what you asked for.</p>\n<pre><code>template&lt;class T&gt; class X\n{\n    template&lt;class Any&gt; friend class X;\n    public:\n        ...\n};\n</code></pre>\n", "LastEditorUserId": "1235565", "LastActivityDate": "2012-09-04T10:27:00.287", "Score": "3", "CreationDate": "2012-06-15T08:11:25.497", "ParentId": "11041274", "CommentCount": "0", "LastEditDate": "2012-09-04T10:27:00.287", "OwnerUserId": "1235565"}, "bq_ids": {"n4140": {"so_11041274_11046918_0": {"length": 5, "quality": 1.0, "section_id": 133}}, "n3337": {"so_11041274_11046918_0": {"length": 5, "quality": 1.0, "section_id": 127}}, "n4659": {"so_11041274_11046918_0": {"length": 5, "quality": 1.0, "section_id": 137}}}, "11041274": {"ViewCount": "1809", "Body": "<p>is it possible to somehow make a partial template specification a friend class? I.e. consider you have the following template class</p>\n<pre><code>template &lt;class T&gt; class X{\n    T t;\n};\n</code></pre>\n<p>Now you have partial specializations, for example, for pointers</p>\n<pre><code>template &lt;class T&gt; class X&lt;T*&gt;{\n    T* t;\n};\n</code></pre>\n<p>What I want to accomplish is that every possible <code>X&lt;T*&gt;</code> is a friend class of <code>X&lt;S&gt;</code> for ANY <code>S</code>. I.e. <code>X&lt;A*&gt;</code> should be a friend of <code>X&lt;B&gt;</code>.</p>\n<p>Of course, I thought about a usual template friend declaration in X:</p>\n<pre><code>template &lt;class T&gt; class X{\n    template &lt;class S&gt; friend class X&lt;S*&gt;;\n}\n</code></pre>\n<p>However, this does not compile, g++ tells me this:</p>\n<p>test4.cpp:34:15: error: specialization of '<code>template&lt;class T&gt; class X</code>' must appear at namespace scope</p>\n<p>test4.cpp:34:21: error: partial specialization '<code>X&lt;S*&gt;</code>' declared 'friend'</p>\n<p>Is this not possible at all or is there some workaround?</p>\n<p>The reason why I am asking is that I need a constructor in <code>X&lt;T*&gt;</code> that creates this class from an arbitrary <code>X&lt;S&gt;</code> (<code>S</code> must be a subtype of <code>T</code>).</p>\n<p>The code looks like this:</p>\n<pre><code>template &lt;class T&gt; class X&lt;T*&gt;{\n    T* t;\n\n    template&lt;class S&gt;\n    X(X&lt;S&gt; x) : t(&amp;(x.t))  {} //Error, x.t is private\n}\n</code></pre>\n<p>Now, the compiler complains, of course, that <code>x.t</code> is not visibile in the constructor since it is private. This is why I need a partial specialization friend class.</p>\n", "AcceptedAnswerId": "11046918", "Title": "C++ Templates: Partial Template Specifications and Friend Classes", "CreationDate": "2012-06-14T21:00:50.973", "Id": "11041274", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-06-15T07:54:35.910", "LastEditorUserId": "1408611", "LastActivityDate": "2012-09-04T10:27:00.287", "Score": "7", "OwnerUserId": "1408611", "Tags": "<c++><templates><template-specialization><partial-specialization><friend-class>", "AnswerCount": "2"}, "11047047": {"Id": "11047047", "PostTypeId": "2", "Body": "<p>We can define a <code>getter</code> protected by a key defined in X.</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;class T&gt; class X{\n  T t;\npublic:\n  struct Key {\n    template&lt;typename S&gt;\n    Key(const X&lt;S&gt;&amp;) {\n      static_assert(std::is_pointer&lt;S&gt;::value, \"Not a pointer\");\n    }\n  };\n\n  const T&amp; get(Key) const { return t; }\n  T&amp; get(Key) { return t; }\n};\n\ntemplate &lt;class T&gt; class X&lt;T*&gt; {\n  T* t;\npublic:\n  template&lt;class S&gt;\n  X(X&lt;S&gt;&amp; x) : t(&amp;(x.get(typename X&lt;S&gt;::Key(*this))))  {}\n};\n\nint main()\n{\n  X&lt;int&gt; x1;\n  X&lt;int*&gt; x2(x1);\n  return 0;\n}\n</code></pre>\n<p>This still has some weakness. Everybody with an <code>X&lt;T*&gt;</code> can now use\n<code>get</code>. But this is so obfuscated by now, that no one is goiing to\nrealize that. I'd choose a simple public getter.</p>\n", "LastActivityDate": "2012-06-15T08:21:58.203", "Score": "1", "CreationDate": "2012-06-15T08:21:58.203", "ParentId": "11041274", "CommentCount": "3", "OwnerUserId": "105672"}});