post_cb({"bq_ids": {"n4140": {"so_16613688_16613816_0": {"length": 58, "quality": 0.9354838709677419, "section_id": 3344}}, "n3337": {"so_16613688_16613816_0": {"length": 58, "quality": 0.9354838709677419, "section_id": 3214}}}, "16613829": {"PostTypeId": "2", "Body": "<p>Yes you can count on this.</p>\n<p>When an exception is thrown during construction, all sub-objects/member objects that have been completely constructed will also be destroyed (mostly in reverse order of construction).</p>\n<p>That said, you should be aware that:</p>\n<ol>\n<li><code>auto_ptr</code> is deprecated -- I'd advise against using it in new code.</li>\n<li>Your use of <code>auto_ptr</code> seems semi-pointless anyway.</li>\n</ol>\n<p>Your current definition of HumBug seems to accomplish little that just having <code>foo</code> and <code>bar</code> as normal members (instead of <code>auto_ptr</code>s) wouldn't do just as well:</p>\n<pre><code>class HumBug { \n    Foo foo;\n    Bar bar;\npublic:\n     ~HumBug() { std::cout &lt;&lt; \"~HumBug\"; }\n};\n</code></pre>\n<p>Member objects are constructed in the order of their declaration in the class definition, so this will construct the <code>Foo</code> object, then attempt to construct the <code>Bar</code> object. When <code>Bar</code> throws, the <code>Foo</code> will be destroyed.</p>\n<p>As an aside, <code>using namespace std;</code> tends to be mostly frowned upon (though perhaps you were doing it only for the same of demonstration, where it's probably fine -- not recommended in real code though).</p>\n", "LastActivityDate": "2013-05-17T16:25:50.060", "Id": "16613829", "CommentCount": "2", "CreationDate": "2013-05-17T16:25:50.060", "ParentId": "16613688", "Score": "4", "OwnerUserId": "179910"}, "16613688": {"ViewCount": "195", "Body": "<p>I've been using C++ for years, but in an environment using what might be considered old fashioned. Specifically we did not use auto_ptr's and were not allowed to alloc memory in constructors. </p>\n<p>Moving on I thought I was getting the hang of things, until... See the following bit of code:</p>\n<pre><code>    #include &lt;memory&gt;\n    #include &lt;iostream&gt;\n\n    using namespace std;\n\n    class Foo\n        {\n        public:\n        int x;\n        ~Foo() { cout &lt;&lt; \"~Foo\" &lt;&lt; endl; }\n        };\n\n    class Bar\n        {\n        public:\n        Bar() { throw 0; }\n        ~Bar() { cout &lt;&lt; \"~Bar\" &lt;&lt; endl; }\n        int y;\n        };\n\n    class HumBug\n        {\n        public:\n            HumBug();\n            virtual ~HumBug();\n\n        auto_ptr&lt;Foo&gt; foo;\n        auto_ptr&lt;Bar&gt; bar;\n        };\n\n    HumBug::HumBug()\n        {\n        cout &lt;&lt; \"before foo\" &lt;&lt; endl;\n        foo = auto_ptr&lt;Foo&gt;(new Foo);\n        cout &lt;&lt; \"after foo\" &lt;&lt; endl;\n        bar = auto_ptr&lt;Bar&gt;(new Bar);\n        cout &lt;&lt; \"after bar\" &lt;&lt; endl;\n        }\n\n    HumBug::~HumBug()\n        {\n        cout &lt;&lt; \"~HumBug\" &lt;&lt; endl;\n        }\n\n    int main()\n        {\n        try \n            {\n            HumBug humbug;\n            }\n        catch (...)\n            {\n            }\n        return 0;\n        }\n</code></pre>\n<p>I understand that the destructor of HumBug won't be called, as the exception occurs during the call to the HumBug constructor. I was expecting that the Foo property created would leak. However valgrind says it is OK:</p>\n<pre><code>==4985== Memcheck, a memory error detector\n==4985== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.\n==4985== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info\n==4985== Command: ./a.out\n==4985== \nbefore foo\nafter foo\n~Foo\n==4985== \n==4985== HEAP SUMMARY:\n==4985==     in use at exit: 0 bytes in 0 blocks\n==4985==   total heap usage: 3 allocs, 3 frees, 108 bytes allocated\n==4985== \n==4985== All heap blocks were freed -- no leaks are possible\n==4985== \n==4985== For counts of detected and suppressed errors, rerun with: -v\n==4985== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n</code></pre>\n<p>Is it then that although the destructor is not called, the properties' are still reliably destroyed? I was thinking that for this to be reliably cleaned up, I'd have to rewrite HumBug's constructor as:</p>\n<pre><code>    HumBug::HumBug()\n        {\n        auto_ptr&lt;Foo&gt; new_foo (new Foo);\n        auto_ptr&lt;Bar&gt; new_bar (new Bar);\n        // no exceptions after this point\n        foo = new_foo;\n        bar = new_bar;\n        }\n</code></pre>\n<p>but it appears this is not the case.</p>\n<p>Can I rely on this?</p>\n", "Title": "On exceptions in C++ destructors, are all properties automatically destroyed", "CreationDate": "2013-05-17T16:16:03.897", "LastActivityDate": "2013-05-17T16:28:31.037", "CommentCount": "1", "LastEditDate": "2013-05-17T16:18:01.063", "PostTypeId": "1", "LastEditorUserId": "1171191", "Id": "16613688", "Score": "3", "OwnerUserId": "2336991", "Tags": "<c++><exception>", "AnswerCount": "3"}, "16613816": {"PostTypeId": "2", "Body": "<p>[except.ctor]/2:</p>\n<blockquote>\n<p id=\"so_16613688_16613816_0\">An object of any storage duration whose initialization or destruction is terminated by an exception <strong>will have destructors executed for all of its fully constructed subobjects</strong> (excluding the variant members of a union-like class), <strong>that is, for subobjects for which the principal constructor (12.6.2) has completed execution and the destructor has not yet begun execution</strong>. Similarly, if the non-delegating constructor for an object\n  has completed execution and a delegating constructor for that object exits with an exception, the object\u2019s destructor will be invoked. If the object was allocated in a new-expression, the matching deallocation function (3.7.4.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>The ctors of the subobjects will be called in the mem-initializer-list (yours is empty, therefore default-construction will occur). When the ctor body is entered, all members have already been successfully constructed, therefore, their dtors will be called.</p>\n", "LastActivityDate": "2013-05-17T16:25:14.167", "Id": "16613816", "CommentCount": "0", "CreationDate": "2013-05-17T16:25:14.167", "ParentId": "16613688", "Score": "4", "OwnerUserId": "420683"}, "16613872": {"PostTypeId": "2", "Body": "<p>Even though the destructor for HumBeg won't run, since HumBug was not fully constructed, the destructors for the embedded objects will since they were fully constructed. Both foo and bar are constructed and will release their objects if they have them.</p>\n", "LastActivityDate": "2013-05-17T16:28:31.037", "Id": "16613872", "CommentCount": "0", "CreationDate": "2013-05-17T16:28:31.037", "ParentId": "16613688", "Score": "1", "OwnerUserId": "677299"}});