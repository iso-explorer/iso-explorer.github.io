post_cb({"10436991": {"Id": "10436991", "PostTypeId": "2", "Body": "<p>The object you intend to throw (in this case <code>MyException</code>) must be successfully constructed <em>before</em> it can be thrown. So you're not throwing it yet, since it hasn't been constructed.</p>\n<p>So this will work, throwing the exception from within <code>MyException</code>'s constructor. You won't trigger the \"throwing an exception while handling an exception causes <code>std::terminate</code>\" issue.</p>\n", "LastActivityDate": "2012-05-03T18:07:35.980", "Score": "4", "CreationDate": "2012-05-03T18:07:35.980", "ParentId": "10436959", "CommentCount": "3", "OwnerUserId": "734069"}, "bq_ids": {"n4140": {"so_10436959_10437245_0": {"length": 15, "quality": 0.75, "section_id": 3340}}, "n3337": {"so_10436959_10437245_0": {"length": 19, "quality": 0.95, "section_id": 3210}}, "n4659": {"so_10436959_10437245_0": {"length": 14, "quality": 0.7, "section_id": 4142}}}, "10437495": {"Id": "10437495", "PostTypeId": "2", "Body": "<p>If you want to check invariants that should always be true, you should use assertions. Exceptions are meant for unusual situations that are expected to happen, like corner cases or bad user input.</p>\n<p>If you use exceptions to report bugs in your code, you could accidentally hide them with catch(...). This is especially important if you are writing library code, because then you never know if other people might catch and ignore the exception, even if it means that the system has reached an invalid state.</p>\n<p>Another advantage of assertions is that you can completely disable them if you want, such that they will no longer incur any performance penalties. This allows you to be really paranoid with those checks in your debug builds and still have a lightning fast release build.</p>\n", "LastActivityDate": "2012-05-03T18:44:51.637", "Score": "0", "CreationDate": "2012-05-03T18:44:51.637", "ParentId": "10436959", "CommentCount": "6", "OwnerUserId": "1372904"}, "10437245": {"Id": "10437245", "PostTypeId": "2", "Body": "<h2>15.1 Throwing an exception n3376</h2>\n<h3>Paragraph 7</h3>\n<blockquote>\n<p id=\"so_10436959_10437245_0\">If the exception handling mechanism, after completing evaluation of the expression to be thrown but before the exception is caught, calls a function that exits via an exception, std::terminate is called (15.5.1).</p>\n</blockquote>\n<p>This means that until the constructor (of the object being thrown in this case) completes nothing special is going to happen. But after the constructor completes any other uncought exception will result in <code>terminate()</code> being called.</p>\n<p>The standard goes on to provide an example:</p>\n<pre><code>struct C\n{\n       C() { }\n       C(const C&amp;) { throw 0; }\n};\n\nint main()\n{\n  try\n  {\n    throw C();   // calls std::terminate()\n  }\n  catch(C) { }\n}\n</code></pre>\n<p>Here terminate is called because the object is first created. But then the copy construction is called to copy the exception to the holding location (15.1.4). During this function call (copy construction) an uncaught exception is generated and thus terminate is called.</p>\n<p>So your code as shown should work as expected.</p>\n<ul>\n<li>Either: A <code>MyException</code> is generated with a good message and thrown</li>\n<li>Or: A <code>std::invalid_argument</code> is generated and thrown</li>\n</ul>\n", "LastActivityDate": "2012-05-03T18:24:37.563", "Score": "3", "CreationDate": "2012-05-03T18:24:37.563", "ParentId": "10436959", "CommentCount": "0", "OwnerUserId": "14065"}, "10436959": {"ViewCount": "677", "Body": "<p>I have an exception class:</p>\n<pre><code>class MyException : public std::exception\n{\npublic:\n    MyException( char* message )\n        : message_( message )\n    {\n        if( !message_ ) throw std::invalid_argument(\"message param must not be null\");\n    }\n};\n</code></pre>\n<p>And at my throw site:</p>\n<pre><code>try {\n    throw MyException( NULL );\n}\ncatch( std::exception const&amp; e ) {\n    std::cout &lt;&lt; e.what();\n}\n</code></pre>\n<p>(code was not compiled, so please excuse any errors)</p>\n<p>I'm wondering what will happen when I throw from a constructor while constructing due to another throw. I assume this is legal, and the catch will end up catching a <code>std::invalid_argument</code>, and the previous exception thrown (<code>MyException</code>) will be ignored or cancelled out.</p>\n<p>My goal with this design is to enforce invariants in my exception class. <code>message_</code> should never be NULL, and I don't want to have if conditions to check if it is null in my <code>what()</code> overload, so I check them in the constructor and throw if they are invalid.</p>\n<p>Is this correct, or is the behavior different?</p>\n", "AcceptedAnswerId": "10436991", "Title": "Throwing an exception while constructing object during a throw?", "CreationDate": "2012-05-03T18:05:18.293", "Id": "10436959", "CommentCount": "9", "PostTypeId": "1", "LastActivityDate": "2012-05-03T18:44:51.637", "Score": "3", "OwnerUserId": "157971", "Tags": "<c++><exception>", "AnswerCount": "3"}});