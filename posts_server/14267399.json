post_cb({"14267399": {"CommentCount": "4", "ViewCount": "6619", "PostTypeId": "1", "LastEditorUserId": "701092", "CreationDate": "2013-01-10T21:16:25.207", "LastActivityDate": "2013-01-10T22:36:37.607", "Title": "Can std::array be used in a constexpr class?", "AcceptedAnswerId": "14268348", "LastEditDate": "2013-01-10T21:28:08.200", "Id": "14267399", "Score": "24", "Body": "<p>I am currently creating a class with a <code>constexpr</code> constructor and I wonder if I can use an <code>std::array</code> to store the data of this class. Does the standard explicitly specify that an <code>std::array</code> has a <code>constexpr</code> constructor and that its contents can be accessed at compile-time ?</p>\n", "Tags": "<c++><arrays><c++11><constexpr>", "OwnerUserId": "882932", "AnswerCount": "2"}, "14268348": {"ParentId": "14267399", "CommentCount": "0", "Body": "<p>Because <code>std::array&lt;T, N&gt;</code> is an aggregate, it can be initialized as a <code>constexpr</code> if and only if the underlying type <code>T</code> has a <code>constexpr</code> constructor (when presented with each initializer you provide).</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "14268348", "Score": "20", "CreationDate": "2013-01-10T22:21:20.333", "LastActivityDate": "2013-01-10T22:21:20.333"}, "bq_ids": {"n4140": {"so_14267399_14267801_0": {"section_id": 370, "quality": 0.8448275862068966, "length": 49}}, "n3337": {"so_14267399_14267801_0": {"section_id": 360, "quality": 0.8448275862068966, "length": 49}}, "n4659": {"so_14267399_14267801_0": {"section_id": 384, "quality": 0.8448275862068966, "length": 49}}}, "14267801": {"ParentId": "14267399", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Based on the comment by @MarkGlisse: this <a href=\"http://liveworkspace.org/code/2yUyxm$13\" rel=\"noreferrer\">compiles</a></p>\n<pre><code>#include &lt;array&gt; \n#include &lt;iostream&gt;\n\ntemplate&lt;typename T, std::size_t N&gt; \nstruct X \n{ \n   constexpr X(const std::array&lt;T,N&gt;&amp; a):arr(a){} \n\n   private: \n   std::array&lt;T,N&gt; arr; \n}; \n\nconstexpr std::array&lt;int,2&gt; a {{ 13, 18 }}; \nconstexpr X&lt;int,2&gt; x = a;\n\nint main() \n{        \n}\n</code></pre>\n<p>I believe I have found the relevant quote from the Standard here:</p>\n<p><strong>12.1 Constructors [class.ctor]</strong></p>\n<blockquote>\n<p id=\"so_14267399_14267801_0\">6 A default constructor that is defaulted and not de\ufb01ned as deleted is\n  implicitly de\ufb01ned when it is odrused (3.2) to create an object of its\n  class type (1.8) or when it is explicitly defaulted after its \ufb01rst\n  declaration. The implicitly-de\ufb01ned default constructor performs the\n  set of initializations of the class that would be performed by a\n  user-written default constructor for that class with no\n  ctor-initializer (12.6.2) and an empty compound-statement. If that\n  user-written default constructor would be ill-formed, the program is\n  ill-formed. If that user-written default constructor would satisfy the\n  requirements of a constexpr constructor (7.1.5), the implicitly-de\ufb01ned\n  default constructor is constexpr.</p>\n</blockquote>\n<p>This looks essentially like @BenVoigt's answer.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-01-10T22:36:37.607", "Id": "14267801", "Score": "7", "CreationDate": "2013-01-10T21:43:23.563", "LastActivityDate": "2013-01-10T22:36:37.607"}});