post_cb({"25229748": {"CommentCount": "3", "ViewCount": "375", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-08-10T14:48:09.890", "LastActivityDate": "2014-08-10T15:06:54.240", "Title": "Memory overhead of wrapper classes", "LastEditDate": "2017-05-23T12:05:01.177", "Id": "25229748", "Score": "1", "Body": "<p>When using wrapper classes in C++, like</p>\n<pre><code>class myInt {\n  int _value;\npublic:\n  myInt( int value ) : _value( value );\n  int value() const { return _value; }\n\n}\n</code></pre>\n<p>, is there any memory overhead compared to a simple int?</p>\n<p><a href=\"https://stackoverflow.com/a/17793407/1682736\">This answer</a> says \"not if there's no virtual functions\", but I want to understand the exact reason.</p>\n<p>I looked into \u00a7 10.3 [class.virtual] of ISO/IEC 14882:2003, which say: \"A class that declares or inherits a virtual function is called a <em>polymorphic class</em>.\" I understand that objects of such a class do not need to have a vtable pointer in them.  </p>\n<p>But I don't understand how it follows from this that it does not have to have any memory overhead. I can create a class deriving from myInt, calling it, say, myDerivedInt. Can't I do a dynamic_cast from a myInt * to a myDerivedInt *? If not, why not?</p>\n", "Tags": "<c++><memory-management><wrapper>", "OwnerUserId": "1682736", "AnswerCount": "3"}, "25229897": {"ParentId": "25229748", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_25229748_25229897_0\">But I don't understand how it follows from this that it does not have to have any memory overhead</p>\n</blockquote>\n<p>Well, the only reason why memory overhead would be required is if something else has to be stored in the class. It has to contain an <code>int</code>, obviously, because that's its member. But it doesn't need a vtable pointer, and nothing else in the C++ standard mandates that anything else must be contained in the class. The class can be implemented without memory overhead not because the C++ standard says \"this can be done with no memory overhead\", but because it <em>doesn't</em> say \"in addition to the <code>int</code> member, the class must also contain \". It doesn't specify anything that would require overhead to be introduced, so because of that, the overhead can be avoided.</p>\n<p>And of course, when compilers <em>can</em> avoid additional overhead, they typically do so, so in practice such a class will have no memory overhead.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "25229897", "Score": "1", "CreationDate": "2014-08-10T15:06:54.240", "LastActivityDate": "2014-08-10T15:06:54.240"}, "25229810": {"ParentId": "25229748", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_25229748_25229810_0\">Is there any memory overhead compared to a simple \u20acint`?</p>\n</blockquote>\n<p>I would say not, but I don't know if it is guaranteed.</p>\n<blockquote>\n<p id=\"so_25229748_25229810_1\">I understand that objects of such a class do not need to have a vtable pointer in them.</p>\n</blockquote>\n<p>If the polymorphic class object is created on the stack, and its address is never taken, the compiler might figure out that its functions are never called virtually (dynamic-dispatch) and could remove the virtual table pointer from the stack. (This applies only on a per-case basis. Instances of the class in other places may include the vtable pointer). This kind of optimization would have very small impact, so I wouldn't worry about if it does or not. In general, a class which inherits from a class with a vtable, will also have a vtable pointer in its instances.</p>\n<blockquote>\n<p id=\"so_25229748_25229810_2\">Can't I do a <code>dynamic_cast</code> from a <code>myInt*</code> to a <code>myDerivedInt*</code>?</p>\n</blockquote>\n<p>No. Not if it doesn't have a vtable. In other words, if <code>myInt</code> doesn't have any virtual functions (or doesn't inherit from any class that does), then you cannot <code>dynamic_cast</code> from <code>MyInt*</code> to <code>MyDerivedInt*</code>. You can use <code>static_cast</code>, however.</p>\n<blockquote>\n<p id=\"so_25229748_25229810_3\">If not, why not?</p>\n</blockquote>\n<p>Because there is no vtable in <code>myInt</code>. The vtable stores the information needed for <code>dynamic_cast</code>.</p>\n", "OwnerUserId": "2068573", "LastEditorUserId": "701092", "LastEditDate": "2014-08-10T15:03:57.107", "Id": "25229810", "Score": "2", "CreationDate": "2014-08-10T14:55:26.063", "LastActivityDate": "2014-08-10T15:03:57.107"}, "bq_ids": {"n4140": {"so_25229748_25229749_0": {"section_id": 6016, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_25229748_25229749_0": {"section_id": 5784, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_25229748_25229749_0": {"section_id": 7515, "quality": 0.6666666666666666, "length": 4}}}, "25229749": {"ParentId": "25229748", "CommentCount": "0", "Body": "<p>OK, while writing this and finishing the last sentence, I found the answer: </p>\n<p>Clause 6 of \u00a7 5.2.7 [expr.dynamic.cast] says:</p>\n<blockquote>\n<p id=\"so_25229748_25229749_0\">Otherwise, v shall be a pointer to or an lvalue of a polymorphic type (10.3).</p>\n</blockquote>\n<p>I had actually looked \"polymorphic type\" in the index, but that only mentioned the occurence in 10.3 ...</p>\n", "OwnerUserId": "1682736", "PostTypeId": "2", "Id": "25229749", "Score": "0", "CreationDate": "2014-08-10T14:48:09.890", "LastActivityDate": "2014-08-10T14:48:09.890"}});