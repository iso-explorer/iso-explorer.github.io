post_cb({"bq_ids": {"n4140": {"so_6435521_6436660_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 446}}, "n3337": {"so_6435521_6436660_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 437}}, "n4659": {"so_6435521_6436660_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 468}}}, "6435541": {"Id": "6435541", "PostTypeId": "2", "Body": "<p>Once your <code>operator delete</code> overload gets the pointer, the pointed-to object has been destroyed (the <code>~Derived()</code> destructor has already been called).</p>\n<p>You can't treat it like a <code>Base</code> or <code>Derived</code> object at all anymore after it is destroyed because it isn't a <code>Base</code> or <code>Derived</code> object anymore.</p>\n", "LastActivityDate": "2011-06-22T05:57:59.243", "CommentCount": "0", "CreationDate": "2011-06-22T05:57:59.243", "ParentId": "6435521", "Score": "9", "OwnerUserId": "151292"}, "6435521": {"ViewCount": "792", "Body": "<p>I came across this:</p>\n<pre><code>struct Base {\n  void* operator new (size_t);\n  void operator delete (void*);\n  virtual ~Base () {}  // &lt;--- polymorphic\n};\nstruct Derived : Base {};\n\nvoid Base::operator delete (void *p)\n{\n  Base *pB = static_cast&lt;Base*&gt;(p);\n  if(dynamic_cast&lt;Derived*&gt;(pB) != 0)\n  { /* ... NOT reaching here ? ... */ }\n  free(p);\n}\n</code></pre>\n<p>Now if we do,</p>\n<pre><code>Base *p = new Derived;\ndelete p;\n</code></pre>\n<p>Surprisingly, the <a href=\"http://www.ideone.com/ZllE0\" rel=\"nofollow\">condition inside the Base::delete is not satisfied</a>\nAm I doing anything wrong ? Or casting from <code>void*</code> looses the information of <code>Derived*</code> ?</p>\n", "AcceptedAnswerId": "6435550", "Title": "Does dynamic_cast work inside overloaded operator delete?", "CreationDate": "2011-06-22T05:55:36.047", "Id": "6435521", "CommentCount": "3", "LastEditDate": "2012-05-10T12:51:56.053", "PostTypeId": "1", "LastEditorUserId": "50776", "LastActivityDate": "2012-05-10T12:51:56.053", "Score": "5", "OwnerUserId": "514235", "Tags": "<c++><operator-overloading><dynamic-cast>", "AnswerCount": "3"}, "6435550": {"Id": "6435550", "PostTypeId": "2", "Body": "<p>Function <code>operator delete</code> is a <em>raw-memory deallocation function</em>. It is invoked when the actual object (that used to reside in that memory) has already been destructed. I.e. by the time you get into <code>operator delete</code> you object has already been wiped out. The memory the pointer points to is essentially \"raw\", it no longer contains an object. Trying to use any polymorphic functionality on this raw memory is useless - it will not work.</p>\n<p>In more formal terms, according to the language standard the lifetime of an object with non-trivial destructor ends once its destructor starts. In your case all destructors have already done their work. The lifetime of the object is already over, while <code>dynamic_cast</code> requires a \"live\" object.</p>\n<p>P.S. Formally, it is permissible to use <code>dynamic_cast</code> in a destructor as long as some conditions are met (see 12.7/5), but when all destructors are finished (as in your case), <code>dynamic_cast</code> is no longer usable.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2011-06-22T06:04:52.763", "Score": "15", "CreationDate": "2011-06-22T05:59:27.880", "ParentId": "6435521", "CommentCount": "3", "OwnerUserId": "187690", "LastEditDate": "2011-06-22T06:04:52.763"}, "6436660": {"Id": "6436660", "PostTypeId": "2", "Body": "<p>As already mentioned by the other two answers, the type of an object changes as the destructors are being executed. Once a destructor completes, the object of that type does no longer exist, and only it's base subobjects exists (until their destructors complete).</p>\n<p>The reason for this answer is proposing an interesting experiment, what will the output of this code be? (Oh, well, all three answers already told you, but the experiment is interesting in itself):</p>\n<pre><code>#include &lt;iostream&gt;\nstruct base {\n    static void print_type( base const &amp; b ) {   // [1]\n        std::cout &lt;&lt; b.type() &lt;&lt; std::endl;\n    }\n    virtual std::string type() const {           // [2]\n        return \"base\";\n    }\n    virtual ~base() { print_type( *this ); }\n    base() {          print_type( *this ); }\n};\nstruct derived : base {\n    std::string type() const {\n        return \"derived\";\n    }\n    ~derived() {      print_type( *this ); }\n    derived()  {      print_type( *this ); }\n};\nstruct most_derived : derived {\n    std::string type() const {\n        return \"most_derived\";\n    }\n    ~most_derived() { print_type( *this ); }\n    most_derived()  { print_type( *this ); }\n};\nint main() {\n    most_derived md;\n    base::print_type( md );\n}\n</code></pre>\n<p>Notes:</p>\n<p>For extra fun, calls to <code>print_type</code> are also added in the constructor. The function serves as verification of the dynamic type of the object at that particular point in time. The function <code>print_type</code> (that could be a freestanding function, and implemented in a different translation unit --as to avoid the compiler from <em>seeing</em> inside it). While compiling the function, the compiler cannot know whether it is called from inside a constructor, destructor, or outside of any of them, so the generated code <em>must</em> use the dynamic dispatch mechanism, and will be dispatched to the <em>final overrider</em> at each point in time.</p>\n<p>As to the validity of the code is guaranteed by \u00a712.7/2:</p>\n<blockquote>\n<p id=\"so_6435521_6436660_0\">To explicitly or implicitly convert a pointer (an lvalue) referring to an object of class X to a pointer (reference) to a direct or indirect base class B of X, the construction of X and the construction of all of its direct or indirect bases that directly or indirectly derive from B shall have started and the destruction of these classes shall not have completed, otherwise the conversion results in undefined behavior. To form a pointer to (or access the value of) a direct nonstatic member of an object obj, the construction of obj shall have started and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing the member value) results in undefined behavior.</p>\n</blockquote>\n<p>Conversions to <code>base&amp;</code> on the call to <code>print_type</code> are valid as they are performed after the construction of <em>each</em> object has started, and before the destruction of <em>each</em> object has completed (<em>each</em> refers to each one of the subobjects of <code>most_derived</code> in the program).</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-06-22T08:05:39.303", "Score": "2", "CreationDate": "2011-06-22T07:55:17.343", "ParentId": "6435521", "CommentCount": "0", "OwnerUserId": "36565", "LastEditDate": "2011-06-22T08:05:39.303"}});