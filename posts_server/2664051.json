post_cb({"2664094": {"ParentId": "2664051", "CommentCount": "3", "Body": "<p>This is quite a strained out, but:</p>\n<p>Consider vector's allocator that could only allocate memory with, say, 4 KB granularity.  Then it wouldn't make sense to reallocate memory if a vector had capacity of 4096 and size of 4095 as this wouldn't conserve memory, yet waste some CPU time for copying elements.</p>\n", "OwnerUserId": "319799", "PostTypeId": "2", "Id": "2664094", "Score": "11", "CreationDate": "2010-04-18T21:46:01.057", "LastActivityDate": "2010-04-18T21:46:01.057"}, "2668535": {"ParentId": "2664051", "CommentCount": "1", "Body": "<p>The rounding ideas are indeed relevant, but rather indirectly. The question is \"what optimizations are intended to be allowed.\" That's making some assumptions about the standardization process wrt. optimizations. In general, the intent is to allow all non-observable optimizations and then some - such as copy elision where the not-calling of the copy ctor is observable. In this case, <code>capacity() != size()</code> might be an observable effect of an optimization, and the standard allows it.</p>\n<p>As for the reasons to add this latitude, I could also imagine ignoring a shrink request when <code>capacity()</code> is only 101% of <code>size()</code> - too little gains. There will never be a single precise reason, as the LWG consists of many people with many viewpoints. There just is (was) enough of a consensus that there are sufficient extra optimization opportunities created by granting this freedom.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "2668535", "Score": "4", "CreationDate": "2010-04-19T15:12:56.880", "LastActivityDate": "2010-04-19T15:12:56.880"}, "2664051": {"CommentCount": "2", "AcceptedAnswerId": "2664094", "OwnerDisplayName": "Roger Pate", "CreationDate": "2010-04-18T21:31:29.023", "LastActivityDate": "2010-04-24T10:58:38.957", "PostTypeId": "1", "ViewCount": "1407", "FavoriteCount": "2", "Title": "Why is shrink_to_fit non-binding?", "Id": "2664051", "Score": "15", "Body": "<p>The C++0x FCD states in 23.3.6.2 vector capacity:</p>\n<blockquote>\n<pre><code>void shrink_to_fit();\n</code></pre>\n<p id=\"so_2664051_2664051_0\">Remarks: shrink_to_fit is a non-binding request to reduce capacity() to size(). [Note: The request is non-binding to allow latitude for implementation-specific optimizations. \u2014end note]</p>\n</blockquote>\n<p>What optimizations are intended to be allowed?</p>\n", "Tags": "<c++><optimization><vector><c++11>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2664051_2664051_0": {"section_id": 975, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_2664051_2664051_0": {"section_id": 962, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_2664051_2664051_0": {"section_id": 1036, "quality": 0.7058823529411765, "length": 12}}}, "2704174": {"ParentId": "2664051", "CommentCount": "2", "Body": "<p>While is it already special, vector &lt;bool&gt; has to allocate in blocks of size 8. I also know some people are working on getting malloc to return the 'true size' of any allocated blocks, so if an allocated block would have introduced unavoidable waste, instead the vector usefully uses the space.</p>\n<p>As we move to 64-bit OSes, memory space suddenly becomes (famous last words) larger than anyone will ever get close to filling, so it becomes much more reasonable to allocate large blocks of virtual memory and fill them whenever. Moving objects around is expensive, and in practice a waste of time, as we are not moving things because physical memory is limited, just from one virtual place to another!</p>\n", "OwnerUserId": "27074", "PostTypeId": "2", "Id": "2704174", "Score": "0", "CreationDate": "2010-04-24T10:58:38.957", "LastActivityDate": "2010-04-24T10:58:38.957"}});