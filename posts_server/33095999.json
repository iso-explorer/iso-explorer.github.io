post_cb({"33096162": {"ParentId": "33095999", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>According to the draft standard <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">N4527</a> <em>7.1.5/3 The constexpr specifier [dcl.constexpr]</em> (<strong>Emphasis mine</strong>):</p>\n<blockquote>\n<p id=\"so_33095999_33096162_0\">The definition of a constexpr function shall satisfy the following\n  constraints:</p>\n<p id=\"so_33095999_33096162_1\">(3.1) \u2014 it shall not be virtual (10.3);</p>\n<p id=\"so_33095999_33096162_2\">(3.2) \u2014 its return type shall be a literal type;</p>\n<p id=\"so_33095999_33096162_3\">(3.3) \u2014 <strong>each of its parameter types shall be a literal type;</strong></p>\n<p id=\"so_33095999_33096162_4\">...</p>\n</blockquote>\n<p>Thus, calling <code>function(5,6);</code> satisfies the definition of a <code>constexpr</code> function and execution will take place at compile time.</p>\n<p>Moreover, you can test it by yourself by using <a href=\"http://en.cppreference.com/w/cpp/types/integral_constant\" rel=\"nofollow\">std::integral_constant</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nconstexpr int fun(int x, int y) {\n   return x + y;\n}\n\nint main() {\n    std::cout &lt;&lt; std::integral_constant&lt;int, fun(5, 6)&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2d03383926f7d102\" rel=\"nofollow\">LIVE DEMO</a></p>\n<p>If input parameters in <code>fun</code> are not <code>constexpr</code> compilation will fail.</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2015-10-13T07:35:48.393", "Id": "33096162", "Score": "2", "CreationDate": "2015-10-13T07:02:54.727", "LastActivityDate": "2015-10-13T07:35:48.393"}, "33100488": {"ParentId": "33095999", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>constexpr int fun(int x, int y) { return x+y; }\nfun(5,6) // &lt;&lt; constant expression?\n</code></pre>\n<p><strong>tl;dr</strong> </p>\n<p><code>5</code> and <code>6</code> are constant expressions. Thus <code>fun(5,6)</code> also is a constant expression and will be evaluated at compile time where this is mandatory (non-type templates for instance).</p>\n<p><strong>stuff...</strong>\nI had a quick look into the standard and I hope I didn't miss any important points.</p>\n<p>We already know from @42's answer: </p>\n<ul>\n<li><p>According to N4527 <code>int</code> is a valid paramter type for a <em>constexpr function</em> since it is a literal type (since it is a scalar type which is by \u00a73.9/10 of the same document a literal type). Therefore, <code>fun</code> is a valid constexpr function.</p></li>\n<li><p>It provides code that puts <code>fun(5,6)</code> into a context where a constant expression is required and it seems to be accepted by certain compilers.</p></li>\n</ul>\n<p>Now the question is whether this is valid, standard-conformant behaviour.</p>\n<p>\u00a75.20 from N4527 says:</p>\n<blockquote>\n<p id=\"so_33095999_33100488_0\">A conditional-expression e is a <em>core constant expression</em> unless the evaluation of e, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n<ul>\n<li>here comes a large list of things that prevent expressions from being core constant expression</li>\n</ul>\n</blockquote>\n<p>That list does not contain \"constexpr function with constant expression arguments\" which are therefore core constant expressions (unless they are undefined when used).</p>\n<p>Thus, if <code>5</code> and <code>6</code> are constant expressions, then <code>fun(5,6)</code> is a constant expression if <code>fun</code> is a valid <em>constexpr function</em> and is defined before using it. The given function satisfies the required constraints in \u00a77.1.5/3 and is a valid <em>constexpr function</em>.</p>\n<p>Both <code>5</code> and <code>6</code> are <em>integer literals</em> of type <code>int</code> as per \u00a72.13.2</p>\n<blockquote>\n<p id=\"so_33095999_33100488_1\">1) An integer literal is a sequence of digits that has no period or exponent part, with optional separating single quotes that are ignored when determining its value. [...]</p>\n<p id=\"so_33095999_33100488_2\">2) The type of an integer literal is the first of the corresponding list in Table 5 in which its value can be represented.</p>\n<p id=\"so_33095999_33100488_3\">Suffix: <code>none</code>, Decimal literal: <code>int</code>, <code>long int</code>, <code>long long int</code></p>\n</blockquote>\n<p>Now looking at \u00a75.20 again we see: both are constant expressions.</p>\n", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2015-10-13T13:48:41.507", "Id": "33100488", "Score": "2", "CreationDate": "2015-10-13T10:36:58.490", "LastActivityDate": "2015-10-13T13:48:41.507"}, "bq_ids": {"n4140": {"so_33095999_33096162_0": {"section_id": 5419, "quality": 0.8571428571428571, "length": 6}, "so_33095999_33100488_3": {"section_id": 5341, "quality": 0.7, "length": 7}, "so_33095999_33100488_2": {"section_id": 5341, "quality": 0.8333333333333334, "length": 10}, "so_33095999_33096162_3": {"section_id": 5419, "quality": 1.0, "length": 6}, "so_33095999_33100488_0": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_33095999_33100488_1": {"section_id": 5340, "quality": 1.0, "length": 16}, "so_33095999_33096162_2": {"section_id": 5419, "quality": 1.0, "length": 5}}, "n3337": {"so_33095999_33096162_0": {"section_id": 5214, "quality": 0.8571428571428571, "length": 6}, "so_33095999_33100488_3": {"section_id": 5138, "quality": 0.7, "length": 7}, "so_33095999_33096162_2": {"section_id": 5214, "quality": 1.0, "length": 5}, "so_33095999_33100488_2": {"section_id": 5138, "quality": 0.8333333333333334, "length": 10}, "so_33095999_33096162_3": {"section_id": 5214, "quality": 1.0, "length": 6}}, "n4659": {"so_33095999_33096162_0": {"section_id": 6841, "quality": 0.7142857142857143, "length": 5}, "so_33095999_33100488_3": {"section_id": 6762, "quality": 0.7, "length": 7}, "so_33095999_33100488_2": {"section_id": 6762, "quality": 0.8333333333333334, "length": 10}, "so_33095999_33096162_3": {"section_id": 6841, "quality": 1.0, "length": 6}, "so_33095999_33100488_0": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_33095999_33100488_1": {"section_id": 6761, "quality": 0.9375, "length": 15}, "so_33095999_33096162_2": {"section_id": 6841, "quality": 1.0, "length": 5}}}, "33095999": {"CommentCount": "3", "ViewCount": "715", "CreationDate": "2015-10-13T06:53:36.433", "LastActivityDate": "2015-10-13T13:48:41.507", "Title": "constexpr function and hardcoded arguments", "AcceptedAnswerId": "33100488", "PostTypeId": "1", "Id": "33095999", "Score": "2", "Body": "<p>So generally constexpr functions are functions, that are executed in compile time, when arguments passed to it are also constexpr so following:</p>\n<pre><code>constexpr int function(int x, int y){\n   return x+y;\n}\n</code></pre>\n<p>with arguments declared as follows:</p>\n<pre><code>constexpr int x = 5;\nconstexpr int y = 6;\n</code></pre>\n<p>will be executed in compile time, but with following declaration of arguments:</p>\n<pre><code>int x=5;\nint y=6;\n</code></pre>\n<p>It will not. I wonder what would happen if we call this function in a following way:</p>\n<pre><code>function(5,6);\n</code></pre>\n<p>From technical point of view 5 and 6 are rvalues but there is no way (I guess), that they can be casted to constexpr (if we can say generally about casting to constexpr), so in my opinion it will be executed in a runtime. However there is no practical reason to execute it in a run time as both x and y are known during compilation time.</p>\n<p>So my question is How is it in real life? Will this function be executed in run-time or compile time</p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "4764736", "AnswerCount": "2"}});