post_cb({"20984959": {"ParentId": "20984808", "CommentCount": "13", "CreationDate": "2014-01-08T00:43:33.590", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "20984959", "Score": "7", "Body": "<p>The pointer returned by placement new can be just as UB-causing as any other pointer when aliasing considerations are brought into it. It's your responsibility to ensure that the memory you placed the object into isn't aliased by anything it shouldn't be.</p>\n<p>In this case, you cannot assume that <code>uint8_t</code> is an alias for <code>char</code> and therefore has the special aliasing rules applied. In addition, it would be fairly pointless to use an array of <code>uint8_t</code> rather than <code>char</code> because <code>sizeof()</code> is in terms of <code>char</code>, not <code>uint8_t</code>. You'd have to compute the size yourself.</p>\n<p>In addition, <code>reinterpret_cast</code>'s effect is entirely implementation-defined, so the code certainly does not have a well-defined meaning.</p>\n<p>To implement low-level unpleasant memory hacks, the original memory needs to be only aliased by <code>char*</code>, <code>void*</code>, and <code>T*</code>, where <code>T</code> is the final destination type- in this case <code>int</code>, plus whatever else you can get from a <code>T*</code>, such as if <code>T</code> is a derived class and you convert that derived class pointer to a pointer to base. Anything else violates strict aliasing and hello nasal demons.</p>\n", "LastActivityDate": "2014-01-08T00:43:33.590"}, "20984808": {"CommentCount": "13", "ViewCount": "649", "PostTypeId": "1", "LastEditorUserId": "1232524", "CreationDate": "2014-01-08T00:26:31.390", "LastActivityDate": "2014-01-08T07:15:55.360", "Title": "C++ strict aliasing when not using pointer returned by placement new", "FavoriteCount": "3", "LastEditDate": "2014-01-08T00:57:22.240", "Id": "20984808", "Score": "8", "Body": "<p>Can this potentially cause undefined behaviour?</p>\n<pre><code>uint8_t storage[4];\n\n// We assume storage is properly aligned here.\nint32_t* intPtr = new((void*)storage) int32_t(4);\n\n// I know this is ok:\nint32_t value1 = *intPtr;\n*intPtr = 5;\n\n// But can one of the following cause UB?\nint32_t value2 = reinterpret_cast&lt;int32_t*&gt;(storage)[0];\nreinterpret_cast&lt;int32_t*&gt;(storage)[0] = 5;\n</code></pre>\n<hr>\n<p><code>char</code> has special rules for strict-aliasing. If I use <code>char</code> instead of  <code>uint8_t</code> is it still Undefined Behavior? What else changes?</p>\n<p>As member DeadMG pointed out, <code>reinterpret_cast</code> is implementation dependent. If I use a C-style cast <code>(int32_t*)storage</code> instead, what would change?</p>\n</hr>", "Tags": "<c++><language-lawyer><placement-new><strict-aliasing><type-punning>", "OwnerUserId": "1232524", "AnswerCount": "2"}, "20989131": {"ParentId": "20984808", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2014-01-08T07:10:40.390", "Score": "6", "LastEditorUserId": "726300", "LastEditDate": "2014-01-08T07:15:55.360", "Id": "20989131", "OwnerUserId": "726300", "Body": "<p>Your version using the usual placement new is indeed fine.</p>\n<p>There is an interpretation<sup>1</sup> of \u00a7\u00a7\u00a03.8/1 and 3.8/4 where objects of trivial types are able to \u2018vanish\u2019 and \u2018appear\u2019 on demand. This not a free pass that allows disregarding aliasing rules, so notice:</p>\n<pre><code>std::uint16_t storage[2];\nstatic_assert( /* std::uint16_t is not a character type */ );\nstatic_assert( /* storage is properly aligned for our purposes */ );\n\nauto read = *reinterpret_cast&lt;std::uint32_t*&gt;(&amp;storage);\n// At this point either we\u2019re attempting to read the value of an\n// std::uint16_t object through an std::uint32_t glvalue, a clear\n// strict aliasing violation;\n// or we\u2019re reading the indeterminate value of a new std::uint32_t\n// object freshly constructed in the same storage without effort\n// on our part\n</code></pre>\n<p>If on the other hand you swapped the casts around in your second snippet (i.e. reinterpret and write first), you\u2019re not entirely safe either. While under the interpretation you can justify the write to happen on a new <code>std::uint32_t</code> object that reuses the storage implicitly, the subsequent read is of the form</p>\n<pre><code>auto value2 = *reinterpret_cast&lt;int32_t*&gt;(storage);\n</code></pre>\n<p>and \u00a73.8/5 says (emphasis mine and extremely relevant):</p>\n<blockquote>\n<p id=\"so_20984808_20989131_0\">[\u2026] after the lifetime of an object has ended and <strong>before the storage which the object occupied is reused</strong> or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. [\u2026] such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type <code>void*</code>, is well-defined.</p>\n</blockquote>\n<p>\u00a73.8/6 is the same but in reference/glvalue form (arguably more relevant since we\u2019re reusing a name and not a pointer here, but the paragraph is imo harder to understand out of context). Also see \u00a73.8/7, which gives some limited leeway that I don\u2019t think applies in your case.</p>\n<p>To make things simpler, the remaining problem is this:</p>\n<pre><code>T object;\nobject.~T();\nnew (&amp;object) U_thats_really_different_from_T;\n&amp;object;                     // Is this allowed? What does it mean?\nstatic_cast&lt;void*&gt;(&amp;object); // Is this?\n</code></pre>\n<p>As it so happens if the type of the storage happens to involve a plain or unsigned character type (e.g. your <code>storage</code> really has type <code>unsigned char[4]</code>) then I\u2019d say you have a basis to justify forming a pointer/reference to the storage of the new object (possibly to be reinterpreted later). See e.g. \u00b6\u00b6\u00a05 and 6 again, which have an explicit escape clause for forming a pointer/reference/glvalue and \u00a71.8 <em>The C++ object model</em> that describes how an object involves a constituent array of bytes. The rules governing the pointer conversions should be straightforward and uncontroversial (at least by comparison\u2026).</p>\n<hr>\n<p><sup>1</sup>: it\u2019s hard to gauge how well this interpretation is received in the community \u2014 I\u2019ve seen it on the Boost mailing list, where there was some scepticism towards it</p>\n</hr>", "LastActivityDate": "2014-01-08T07:15:55.360"}, "bq_ids": {"n4140": {"so_20984808_20989131_0": {"section_id": 7193, "quality": 0.9722222222222222, "length": 35}}, "n3337": {"so_20984808_20989131_0": {"section_id": 6937, "quality": 0.9722222222222222, "length": 35}}, "n4659": {"so_20984808_20989131_0": {"section_id": 8702, "quality": 0.9444444444444444, "length": 34}}}});