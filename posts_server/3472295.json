post_cb({"3472295": {"CommentCount": "2", "AcceptedAnswerId": "3473784", "PostTypeId": "1", "LastEditorUserId": "216247", "CreationDate": "2010-08-12T21:43:56.783", "LastActivityDate": "2010-08-13T07:29:37.927", "LastEditDate": "2010-08-13T03:21:14.203", "ViewCount": "4947", "FavoriteCount": "3", "Title": "Use template template class argument as parameter", "Id": "3472295", "Score": "5", "Body": "<p>Modern C++ Design gives the following example:</p>\n<pre><code>template &lt;class T&gt; struct EnsureNotNull\n{\n    static void Check(T*&amp; ptr)\n    {\n      if (!ptr) ptr = GetDefaultValue();\n    }\n};\n\ntemplate\n&lt;\n   class T,\n   template &lt;class&gt; class CheckingPolicy = EnsureNotNull,\n   template &lt;class&gt; class ThreadingModel\n&gt;\nclass SmartPtr\n  : public CheckingPolicy&lt;T&gt;\n  , public ThreadingModel&lt;SmartPtr&gt;\n{\n...\n  T* operator-&gt;()\n  {\n    typename ThreadingModel&lt;SmartPtr&gt;::Lock guard(*this);\n    CheckingPolicy&lt;T&gt;::Check(pointee_);\n    return pointee_;\n  }\nprivate:\n  T* pointee_;\n};\n</code></pre>\n<p>I couldn't figure how ThreadingModel template would be constructed in a fashion that It could accept SmartPtr as parameter, in my mind some crazy recursion is going to happen. How can this be possible?</p>\n<p><strong>Edit:</strong></p>\n<p>I've tried Potatoswatter (sorry lol) comment:</p>\n<pre><code>template &lt;class SmartPtr&gt; struct SingleThreadingModel\n{\n  class Lock\n  {\n    public: \n      Lock(SmartPtr&amp;)\n      {\n      }\n  };\n};\n</code></pre>\n<p>but it did'nt worked.</p>\n<p>here is the error that gcc is giving me:</p>\n<pre><code>main.cpp:28:35: error: type/value mismatch at argument 1 in template parameter list for \u2018template&lt;class&gt; class ThreadingModel\u2019\nmain.cpp:28:35: error:   expected a type, got \u2018SmartPtr\u2019\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "216247", "AnswerCount": "2"}, "3473784": {"ParentId": "3472295", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You are trying to pass <code>SmartPtr</code> as a template <em>type</em> argument to <code>ThreadingModel</code>. <code>SmartPtr</code> however is a template, not a concrete type, and the <a href=\"http://books.google.de/books?id=EotSAwuBkJoC&amp;pg=PA126&amp;lpg=PA126&amp;dq=c%2B%2B+injected+class-name&amp;source=bl&amp;ots=iwOYJ9_hgh&amp;sig=7-6UMoMHZctldpOYPvDucV4bXE8&amp;hl=de&amp;ei=YMRkTLuvEeacOLC4gKoK&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CCkQ6AEwAw#v=onepage&amp;q=c%2B%2B%20injected%20class-name&amp;f=false\" rel=\"noreferrer\">injected class-name</a> is not available in the inheritance list.  </p>\n<p>Also note that you can't just use default arguments for template parameters in arbitrary positions (<em>\u00a714.1/11</em>): </p>\n<blockquote>\n<p id=\"so_3472295_3473784_0\">If a template-parameter has a default template-argument, all subsequent template-parameters shall have a default template-argument supplied.</p>\n</blockquote>\n<p>Your code with those issues fixed:</p>\n<pre><code>template\n&lt;\n  class T,\n  template &lt;class&gt; class ThreadingModel,\n  template &lt;class&gt; class CheckingPolicy = EnsureNotNull\n&gt;\nclass SmartPtr\n  : public CheckingPolicy&lt;T&gt;\n  , public ThreadingModel&lt;SmartPtr&lt;T, ThreadingModel, CheckingPolicy&gt; &gt; \n//                         ^ .... now passing a concrete class .... ^\n{\n    T* operator-&gt;() {\n        // the following use of SmartPtr is fine as it is the injected class-name:\n        typename ThreadingModel&lt;SmartPtr&gt;::Lock guard(*this);\n        // ...\n    }\n};\n</code></pre>\n<p>Note that while <em>Modern C++ Design</em> is an excellent book, it can't replace a good basic book on templates like <a href=\"http://www.josuttis.com/tmplbook/\" rel=\"noreferrer\">Vandevoorde/Josuttis</a>.</p>\n", "OwnerUserId": "168225", "LastEditorUserId": "168225", "LastEditDate": "2010-08-13T07:29:37.927", "Id": "3473784", "Score": "5", "CreationDate": "2010-08-13T03:57:10.153", "LastActivityDate": "2010-08-13T07:29:37.927"}, "bq_ids": {"n4140": {"so_3472295_3473784_0": {"section_id": 64, "quality": 0.8, "length": 8}}, "n3337": {"so_3472295_3473784_0": {"section_id": 59, "quality": 0.8, "length": 8}}, "n4659": {"so_3472295_3473784_0": {"section_id": 66, "quality": 0.8, "length": 8}}}, "3472398": {"ParentId": "3472295", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The recursion is OK because passing a specialization as a template parameter does not directly cause it to be instantiated.</p>\n<p>(<code>ThreadingModel&lt;SmartPtr&gt;</code> in the base list is just shorthand for <code>ThreadingModel&lt; SmartPtr&lt; T, CheckingPolicy, ThreadingModel &gt; &gt;</code> which uses the \"current specialization.\")</p>\n<p>I don't know what <code>ThreadingModel</code> is supposed to do, so I can't implement it, but it should have a declaration of the form</p>\n<pre><code>template&lt; class Client &gt; class MyThreading\n</code></pre>\n<p>and it cannot access anything inside <code>Client</code> outside of <code>MyThreading</code> member functions. If you use <code>Client</code> and <code>Client</code> depends on <code>MyThreading</code>, then infinite recursion does happen.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2010-08-12T23:20:19.750", "Id": "3472398", "Score": "0", "CreationDate": "2010-08-12T22:04:28.237", "LastActivityDate": "2010-08-12T23:20:19.750"}});