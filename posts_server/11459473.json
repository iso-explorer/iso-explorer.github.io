post_cb({"11459473": {"CommentCount": "2", "AcceptedAnswerId": "11460311", "CreationDate": "2012-07-12T19:45:12.537", "LastActivityDate": "2012-07-12T21:41:42.733", "PostTypeId": "1", "ViewCount": "1749", "FavoriteCount": "1", "Title": "Override virtual function of base classes, which do not share common interface", "Id": "11459473", "Score": "12", "Body": "<pre><code>#include &lt;iostream&gt;\nstruct B1\n{\n    virtual void method()=0;\n    virtual ~B1(){}\n};\n\nstruct B2\n{\n    virtual void method()=0;\n    virtual ~B2(){}\n};\n\nstruct D: B1, B2\n{\n    virtual void method()\n    {\n        std::cout &lt;&lt; \"D::method\\n\";\n    };\n};\n\nint main(int argc,char *argv[])\n{\n    D d;\n    B1 &amp;b1=d;\n    B2 &amp;b2=d;\n    b1.method();\n    b2.method();\n    return 0;\n}\n</code></pre>\n<p>Note, B1 and B2 do not share common interface.</p>\n<p>Is it this legal? If yes - in which standard? C++98/03/11 ?</p>\n<p>Both, msvc and gcc have compiled it OK.</p>\n<p>Previously I thought, that I have to use some common interface for such case (possible virtual inheritence).</p>\n<p>Does such situation have some special name?</p>\n<p>How it works in details, please? Maybe some ISO references?</p>\n", "Tags": "<c++><override><virtual><multiple-inheritance>", "OwnerUserId": "847305", "AnswerCount": "2"}, "11460311": {"ParentId": "11459473", "CommentCount": "8", "Body": "<p>Your code is well-formed:  <code>void D::method()</code> overrides both <code>void B1::method()</code> and <code>void B2::method()</code>.</p>\n<p>The specification states (C++11 \u00a710.3/2):</p>\n<blockquote>\n<p id=\"so_11459473_11460311_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list, cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it overrides <code>Base::vf</code>.</p>\n</blockquote>\n<p><code>B1</code> declares a virtual member function <code>void B1::method()</code>.  Class <code>D</code> is derived from <code>B1</code> and it also declares a member function with the same name (<code>method</code>), the same parameter list (no parameters), the same cv-qualification (no qualification) and the same ref-qualifier (no qualification).</p>\n<p>Therefore, <code>void D::method()</code> overrides <code>void B1::method()</code>.</p>\n<p>The same logic applies for <code>void B2::method()</code> (just substitute <code>B2</code> for <code>B1</code> in the above explanation), so <code>void D::method()</code> overrides both <code>void B1::method()</code> and <code>void B2::method()</code>.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "11460311", "Score": "7", "CreationDate": "2012-07-12T20:41:42.583", "LastActivityDate": "2012-07-12T20:41:42.583"}, "11459781": {"ParentId": "11459473", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>afaik this is legal in every standart. i'm not sure if it has it's own special name, but it is similar to the <a href=\"http://en.wikipedia.org/wiki/Diamond_problem\" rel=\"nofollow\">diamond problem</a> .</p>\n<p>if you override \"virtual void method()\" in D, then you override both the method in B1 and B2.</p>\n<p><strong>Edit:</strong></p>\n<p>to anwser why you do not have \"two different independed inherited virtual functions in D: B1::method and B2::method\":</p>\n<p>when overriding a method, you can can only specify the function name, return type and parameters, but you can not add signature details about which one you inherit from when overriding.</p>\n<p>imagine that it would be possible, then it could look something like this:</p>\n<pre><code>struct D: B1, B2\n{\n    virtual void B1::method()\n    {\n        std::cout &lt;&lt; \"D::method\\n\";\n    };\n    virtual void B2::method()\n    {\n        std::cout &lt;&lt; \"D::method\\n\";\n    };\n};\n</code></pre>\n<p><strong>but</strong> seeing this, you can already say that there is no possibility to have something like that, because when calling</p>\n<pre><code>objectD.method()\n</code></pre>\n<p>you can not specify which one you are calling. so even if there was a way to overload both, there is still the problem of distinguishing on the function call.</p>\n<p><strong>EDIT:</strong>\n\"can not specify which one you are calling.\" refers to, you can not specify whether you want to call a class D overload of B2::method or the B2 method itself. objectD.B2::method will always invoke the B2 (not overloaded) method (which in this case won't compile as B2 has no implementation)</p>\n", "OwnerUserId": "554028", "LastEditorUserId": "554028", "LastEditDate": "2012-07-12T21:41:42.733", "Id": "11459781", "Score": "1", "CreationDate": "2012-07-12T20:07:33.207", "LastActivityDate": "2012-07-12T21:41:42.733"}, "bq_ids": {"n4140": {"so_11459473_11460311_0": {"section_id": 7003, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_11459473_11460311_0": {"section_id": 6749, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_11459473_11460311_0": {"section_id": 8500, "quality": 0.967741935483871, "length": 30}}}});