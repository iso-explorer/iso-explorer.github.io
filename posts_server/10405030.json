post_cb({"10405129": {"ParentId": "10405030", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>\u00a723.2.5, paragraph 3, says:</p>\n<blockquote>\n<p id=\"so_10405030_10405129_0\">Each unordered associative container is parameterized by <code>Key</code>, by a function object type <code>Hash</code> that meets the Hash requirements (17.6.3.4) and acts as a hash function for argument values of type <code>Key</code>, and by a binary predicate <code>Pred</code> that induces an equivalence relation on values of type <code>Key</code>.</p>\n</blockquote>\n<p>Using <code>vector&lt;float&gt;</code> as <code>Key</code> and not providing explicit hash and equivalence predicate types means the default <code>std::hash&lt;vector&lt;float&gt;&gt;</code> and <code>std::equal_to&lt;vector&lt;float&gt;&gt;</code> will be used.</p>\n<p>The <code>std::equal_to</code> for the equivalence relation is fine, because there is an operator <code>==</code> for vectors, and that's what <code>std::equal_to</code> uses.</p>\n<p>There is however, no <code>std::hash&lt;vector&lt;float&gt;&gt;</code> specialization, and that's probably what the linker error you didn't show us says. You need to provide your own hasher for this to work.</p>\n<p>An easy way of writing such an hasher is to use <a href=\"http://www.boost.org/doc/html/hash/reference.html#boost.hash_range\"><code>boost::hash_range</code></a>:</p>\n<pre><code>template &lt;typename Container&gt; // we can make this generic for any container [1]\nstruct container_hash {\n    std::size_t operator()(Container const&amp; c) const {\n        return boost::hash_range(c.begin(), c.end());\n    }\n};\n</code></pre>\n<p>Then you can use: </p>\n<pre><code>std::unordered_map&lt;floatVector, int, container_hash&lt;floaVector&gt;&gt; map;\n</code></pre>\n<p>Of course, if you need different equality semantics in the map you need to define the hash and equivalence relation appropriately.</p>\n<hr>\n<p><sub>1. However, avoid this for hashing unordered containers, as different orders will produce different hashes, and the order in unordered container is not guaranteed.</sub></p>\n</hr>", "OwnerUserId": "46642", "LastEditorUserId": "636019", "LastEditDate": "2012-05-01T23:51:33.733", "Id": "10405129", "Score": "21", "CreationDate": "2012-05-01T22:13:25.297", "LastActivityDate": "2012-05-01T23:51:33.733"}, "10405030": {"CommentCount": "6", "AcceptedAnswerId": "10405129", "PostTypeId": "1", "LastEditorUserId": "1162647", "CreationDate": "2012-05-01T22:04:39.807", "LastActivityDate": "2012-05-01T23:51:33.733", "LastEditDate": "2012-05-01T22:12:03.923", "ViewCount": "7396", "FavoriteCount": "3", "Title": "C++ unordered_map fail when used with a vector as key", "Id": "10405030", "Score": "9", "Body": "<p>Background: I am comming from the Java world and I am fairly new to C++ or Qt.</p>\n<p>In order to play with unordered_map, I have written the following simple program:</p>\n<pre><code>#include &lt;QtCore/QCoreApplication&gt;\n#include &lt;QtCore&gt;\n#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nusing std::string;\nusing std::cout;\nusing std::endl;\ntypedef std::vector&lt;float&gt; floatVector;\n\nint main(int argc, char *argv[]) {\n    QCoreApplication a(argc, argv);\n\n    floatVector c(10);\n    floatVector b(10);\n\n    for (int i = 0; i &lt; 10; i++) {\n        c[i] = i + 1;\n        b[i] = i * 2;\n    }\n\n    std::unordered_map&lt;floatVector, int&gt; map;\n\n    map[b] = 135;\n    map[c] = 40;\n    map[c] = 32;\n\n    std::cout &lt;&lt; \"b -&gt; \" &lt;&lt; map[b] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"c -&gt; \" &lt;&lt; map[c] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Contains? -&gt; \" &lt;&lt; map.size() &lt;&lt; std::endl;\n\n    return a.exec();\n}\n</code></pre>\n<p>Unfortunately, I am running into the folowing error which isn't inspiring. There is not even a line number.</p>\n<blockquote>\n<p id=\"so_10405030_10405030_0\">:-1: error: collect2: ld returned 1 exit status</p>\n</blockquote>\n<p>Any idea of the origin of the problem?</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><qt><vector><c++11><unordered-map>", "OwnerUserId": "1162647", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_10405030_10405129_0": {"section_id": 755, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_10405030_10405129_0": {"section_id": 743, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_10405030_10405129_0": {"section_id": 815, "quality": 0.9666666666666667, "length": 29}}}});