post_cb({"37052522": {"ParentId": "37051199", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is not object slicing in any way.</p>\n<p>Object slicing is perfectly well defined by the C++ standard. It may be a violation of object-oriented design principles or whatever, but it is not a violation of C++ rules.</p>\n<p>This code violates <a href=\"http://eel.is/c++draft/expr#expr.add-6\" rel=\"nofollow\">5.7 [expr.add] paragraph 7</a>:</p>\n<blockquote>\n<p id=\"so_37051199_37052522_0\">For addition or subtraction, if the expressions <code>P</code> or <code>Q</code> have type \u201cpointer to <em>cv</em> <code>T</code>\u201d, where <code>T</code> is different from the cv-unqualified array element type, the behavior is undefined. [Note: In particular, a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type. \u2014end note].</p>\n</blockquote>\n<p>Array subscript operator is defined to be equivalent to pointer arithmetic, <a href=\"http://eel.is/c++draft/expr#expr.sub-1\" rel=\"nofollow\">5.2.1 [expr.sub] paragraph 1</a>:</p>\n<blockquote>\n<p id=\"so_37051199_37052522_1\">The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code></p>\n</blockquote>\n", "OwnerUserId": "775806", "LastEditorUserId": "3919155", "LastEditDate": "2016-05-06T07:58:29.303", "Id": "37052522", "Score": "11", "CreationDate": "2016-05-05T13:56:04.563", "LastActivityDate": "2016-05-06T07:58:29.303"}, "37051492": {"ParentId": "37051199", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is not slicing at all, rather it is undefined behavior because you are accessing a <code>Derived</code> object where none exists (unless you get lucky and the sizes line up, in which case it is still UB but might do something useful anyway).</p>\n<p>It's a simple case of failed pointer arithmetic.</p>\n", "OwnerUserId": "4323", "LastEditorUserId": "4323", "LastEditDate": "2016-05-11T01:39:21.583", "Id": "37051492", "Score": "26", "CreationDate": "2016-05-05T13:09:10.363", "LastActivityDate": "2016-05-11T01:39:21.583"}, "37052920": {"ParentId": "37051199", "PostTypeId": "2", "CommentCount": "6", "Body": "<h2>This is not object slicing.</h2>\n<p>As noted, indexing <code>myArray</code> does not cause object slicing, but results in undefined behavior caused by indexing into an array of <code>Derived</code> as if it were an array of <code>Base</code>.</p>\n<h2>A kind of \"array decay bug\".</h2>\n<p>The bug introduced at the assignment of <code>new Derived[42]</code> to <code>myArray</code> may be a variation of an <strong>array decay bug</strong>.</p>\n<p>In a true instance of this type of bug, there is an actual array:</p>\n<pre><code>Derived x[42];\nBase *myArray = x;\n</code></pre>\n<p>The problem is introduced because an array of <code>Derived</code> decays into a pointer to <code>Derived</code> with value equal to the address of its first element. The decay allows the pointer assignment to work properly. This decay behavior is inherited from C, which was a language design feature to allow arrays to be \"passed by reference\".</p>\n<p>This leads us to the even worse incarnation of this bug. This feature gives C and C++ semantics for arrays syntax that turn array function arguments into aliases for pointer arguments.</p>\n<pre><code>void foo (Base base_array[42]) {\n    //...\n}\n\nDerived d[42];\nfoo(d);          // Boom.\n</code></pre>\n<p>However, <code>new[]</code> is actually an overloaded operator that returns a pointer to the beginning of the allocated array object. So it is not a true instance of array decay (even though the array allocator is used). However, the bug symptoms are the same, and the intention of <code>new[]</code> is to get an array of <code>Derived</code>.</p>\n<h2>Detecting and avoiding the bug.</h2>\n<h3>Use a smart pointer.</h3>\n<p>This kind of problem can be avoided by using a smart pointer object instead of managing a raw pointer. For example, the analogous coding error with <code>unique_ptr</code> would look like:</p>\n<pre><code>std::unique_ptr&lt;Base[]&gt; myArray = new Derived[42];\n</code></pre>\n<p>This would yield a compile time error, because <code>unique_ptr</code>s constructor is <code>explicit</code></p>\n<h3>Use a container, and maybe <code>std::reference</code>.</h3>\n<p>Alternatively, you could avoid using <code>new[]</code>, and use <code>std::vector&lt;Derived&gt;</code>. Then, you would have forced yourself to design a different solution for sending this array to framework code that is only <code>Base</code> aware. Possibly, a template function.</p>\n<pre><code>void my_framework_code (Base &amp;object) {\n    //...\n}\n\ntemplate &lt;typename DERIVED&gt;\nvoid my_interface(std::vector&lt;DERIVED&gt; &amp;v) {\n    for (...) {\n        my_framework_code(v[i]);\n    }\n}\n</code></pre>\n<p>Or, by using <code>std::reference_wrapper&lt;Base&gt;</code>.</p>\n<pre><code>std::vector&lt;Derived&gt; v(42);\nstd::vector&lt;std::reference_wrapper&lt;Base&gt;&gt; myArray(v.begin(), v.end());\n</code></pre>\n", "OwnerUserId": "315052", "LastEditorUserId": "315052", "LastEditDate": "2016-05-11T21:29:22.870", "Id": "37052920", "Score": "19", "CreationDate": "2016-05-05T14:13:43.280", "LastActivityDate": "2016-05-11T21:29:22.870"}, "37051199": {"CommentCount": "14", "AcceptedAnswerId": "37052920", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2016-05-05T12:54:12.880", "LastActivityDate": "2016-05-12T07:41:39.630", "LastEditDate": "2016-05-12T07:41:39.630", "ViewCount": "1331", "FavoriteCount": "5", "Title": "Should this be called some special case of object slicing?", "Id": "37051199", "Score": "25", "Body": "<p>Let's say I have a class <code>Derived</code> which derives from class <code>Base</code> whereas <code>sizeof(Derived) &gt; sizeof(Base)</code>. Now, if one allocates an array of <code>Derived</code> like this:</p>\n<pre><code>Base * myArray = new Derived[42];\n</code></pre>\n<p>and then attempts to access the <code>n</code>-th object using</p>\n<pre><code>doSomethingWithBase(myArray[n]);\n</code></pre>\n<p>Then this is might likely (but not always) cause undefined behaviour due to accessing <code>Base</code> from an invalid location.</p>\n<p><strong>What is the correct term for such an programming error?</strong> Should it be considered a case of <a href=\"https://stackoverflow.com/questions/274626/what-is-object-slicing\">object slicing</a>?</p>\n", "Tags": "<c++><arrays><inheritance><terminology><pointer-arithmetic>", "OwnerUserId": "3919155", "AnswerCount": "4"}, "37051556": {"ParentId": "37051199", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is not a case of slicing, although it is very similar. Slicing is well defined. This is simply undefined behaviour (always, not just likely) due to illegal pointer arithmetic. </p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-05-05T13:25:11.280", "Id": "37051556", "Score": "8", "CreationDate": "2016-05-05T13:12:00.510", "LastActivityDate": "2016-05-05T13:25:11.280"}, "bq_ids": {"n4140": {"so_37051199_37052522_0": {"section_id": 6144, "quality": 0.875, "length": 28}, "so_37051199_37052522_1": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_37051199_37052522_1": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_37051199_37052522_0": {"section_id": 7640, "quality": 0.8125, "length": 26}, "so_37051199_37052522_1": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}}}});