post_cb({"11990794": {"CommentCount": "7", "ViewCount": "383", "PostTypeId": "1", "LastEditorUserId": "134841", "CreationDate": "2012-08-16T15:38:47.373", "LastActivityDate": "2015-04-30T14:00:52.577", "Title": "Is std::hash guaranteed to be same across stdlib distributions", "AcceptedAnswerId": "11990952", "LastEditDate": "2015-04-30T14:00:52.577", "Id": "11990794", "Score": "8", "Body": "<p>If I did <code>std::hash</code> using <code>libstdc++</code> and then did one on the upcoming <code>C++11</code> VS 2012 library - would they match?</p>\n<p>I assume that hash implementations are not part of the C++ specification and can vary by distribution?</p>\n", "Tags": "<c++><c++11><hash><stdhash>", "OwnerUserId": "192993", "AnswerCount": "3"}, "11990952": {"ParentId": "11990794", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard only says this:</p>\n<blockquote>\n<p id=\"so_11990794_11990952_0\">20.8.12 Class template hash The unordered associative containers defined in 23.5 use specializations of the class template hash as the\n  default hash function. For all object types Key for which there exists\n  a specialization hash, theinstantiation hash shall:</p>\n<ul>\n<li>satisfy the Hash requirements (17.6.3.4), with Key as the function call argument type, the DefaultConstructible requirements (Table 19),\n  the CopyAssignable requirements (Table 23),</li>\n<li>be swappable (17.6.3.2) for lvalues,</li>\n<li>provide two nested types result_type and argument_type which shall be synonyms for size_t and Key, respectively,</li>\n<li>satisfy the requirement that if k1 == k2 is true, h(k1) == h(k2) is also true, where h is an object of type hash and k1 and k2 are\n  objects of type Key.</li>\n</ul>\n</blockquote>\n<p>in 17.6.3.4, this is of most importance (table 26):</p>\n<blockquote>\n<p id=\"so_11990794_11990952_1\">Shall not throw exceptions. The value returned shall depend only on\n  the argument k. [ Note: Thus all evaluations of the expression h(k)\n  with the same value for k yield the same result. \u2014 end note ] [ Note:\n  For two different values t1 and t2, the probability that h(t1) and\n  h(t2) compare equal should be very small, approaching 1.0 / numeric_-\n  limits::max(). \u2014 end note ]</p>\n</blockquote>\n<p>So in general, no, the computation itself is not defined and the result is not required to be consistent over implementations. For that matter, even two different versions of the same library may give different results.</p>\n", "OwnerUserId": "243870", "LastEditorUserId": "243870", "LastEditDate": "2012-08-16T16:44:45.197", "Id": "11990952", "Score": "7", "CreationDate": "2012-08-16T15:47:51.893", "LastActivityDate": "2012-08-16T16:44:45.197"}, "11990944": {"ParentId": "11990794", "CommentCount": "1", "Body": "<p>No, this is not guaranteed. <code>std::hash</code> only has to respect the following conditions:</p>\n<blockquote id=\"so_11990794_11990944_0\">\n<ol>\n<li>Accepts a single parameter of type Key.</li>\n<li>Returns a value of type size_t that represents the hash value of the parameter.</li>\n<li>Does not throw exceptions when called.</li>\n<li>For two parameters k1 and k2 that are equal, std::hash()(k1) == std::hash()(k2).</li>\n<li>For two different parameters k1 and k2 that are not equal, the probability that std::hash()(k1) == std::hash()(k2) should\n  be very small, approaching 1.0/std::numeric_limits::max().</li>\n</ol>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/utility/hash\">http://en.cppreference.com/w/cpp/utility/hash</a></p>\n", "OwnerUserId": "1202136", "PostTypeId": "2", "Id": "11990944", "Score": "7", "CreationDate": "2012-08-16T15:47:22.397", "LastActivityDate": "2012-08-16T15:47:22.397"}, "bq_ids": {"n4140": {"so_11990794_11990952_1": {"section_id": 6288, "quality": 0.6486486486486487, "length": 24}, "so_11990794_11990952_0": {"section_id": 4689, "quality": 0.6551724137931034, "length": 19}, "so_11990794_11990992_1": {"section_id": 6288, "quality": 0.7575757575757576, "length": 25}}, "n3337": {"so_11990794_11990952_1": {"section_id": 6048, "quality": 0.6486486486486487, "length": 24}, "so_11990794_11990952_0": {"section_id": 4498, "quality": 0.6551724137931034, "length": 19}, "so_11990794_11990992_1": {"section_id": 6048, "quality": 0.7575757575757576, "length": 25}}, "n4659": {"so_11990794_11990952_1": {"section_id": 7795, "quality": 0.6486486486486487, "length": 24}, "so_11990794_11990992_1": {"section_id": 7795, "quality": 0.7575757575757576, "length": 25}}}, "11990992": {"ParentId": "11990794", "CommentCount": "0", "Body": "<p>The requirements (<strong>17.6.3.4 Hash requirements [hash.requirements]</strong>) on the value returned by a <code>Hash</code> function are:</p>\n<blockquote>\n<p id=\"so_11990794_11990992_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>Table 26 \u2014 Hash requirements [hash]</h3>\n<p id=\"so_11990794_11990992_1\">The value returned shall depend only on the argument <code>k</code>.\n  [ Note: Thus all evaluations of the expression <code>h(k)</code> with the\n  same value for <code>k</code> yield the same result. \u2014end note ] [ Note:\n  For two different values <code>t1</code> and <code>t2</code>, the probability that\n  <code>h(t1)</code> and <code>h(t2)</code> compare equal should be very small, approaching <code>1.0 / numeric_limits&lt;size_t&gt;::max()</code>. \u2014end note ]</p>\n</blockquote>\n<p>In practice, it's quite common that for integral types <code>std::hash(k)</code> would equal <code>k</code>, as that is the simplest possible implementation conformant with the standard.  For other types, anything is possible.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "11990992", "Score": "4", "CreationDate": "2012-08-16T15:50:04.593", "LastActivityDate": "2012-08-16T15:50:04.593"}});