post_cb({"31488534": {"Id": "31488534", "PostTypeId": "2", "Body": "<p>Unless you are returning a pointer or reference to a function which is ok, the alternative is returning a copy of a function. Now, think about what a copy of a function looks like, acts like, behaves like. That, first of all would be an array of bytes, which isn't allowed either, and second of all those bytes would be the equivalence of a piece of code literally returning a piece of code....nearly all heuristic virus scanners would consider that a virus because there would also be no way to verify the viability of the code being returned by the runtime system or even at compile time. Even if you could return an array, how would you return a function? The primary issue with returning an array (which would be a copy on the stack) is that the size is not known and so there's no way to remove it from the stack, and the same dilemma exists for functions (where the array would be the machine language binary code). Also, if you did return a function in that fashion, how would you turn around and call that function?</p>\n<p>To sum up, the notion of returning a function rather than a point to a function fails because the notion of that is a unknown size array of machine code placed (copied) onto the stack. It's not something the C or C++ was designed to allow, and with code there is now way to turn around and call that function, especially i you wanted to pass arguments.</p>\n<p>I hope this makes sense</p>\n", "LastActivityDate": "2015-07-18T06:35:05.553", "CommentCount": "0", "CreationDate": "2015-07-18T06:35:05.553", "ParentId": "31387238", "Score": "0", "OwnerUserId": "1792302"}, "31387444": {"Id": "31387444", "PostTypeId": "2", "Body": "<p>With <a href=\"https://en.wikipedia.org/wiki/C%2B%2B11\" rel=\"nofollow noreferrer\">C++11</a> (but not previous versions of C++) you can not only return C-like function pointers, but also C++ <a href=\"https://en.wikipedia.org/wiki/Closure_%28computer_programming%29\" rel=\"nofollow noreferrer\">closures</a>, notably with <a href=\"https://en.wikipedia.org/wiki/Anonymous_function\" rel=\"nofollow noreferrer\">anonymous functions</a>. See also <a href=\"http://en.cppreference.com/w/cpp/utility/functional/function\" rel=\"nofollow noreferrer\">std::function</a></p>\n<p>The standard disallows (<strong><em>semantically</em></strong>, not syntactically - so <strong>it is <em>not</em> a question of <em>grammar</em></strong> ; see <a href=\"https://stackoverflow.com/a/31387510/841108\">Barry's answer</a> for the citation) returning <em>functions</em> (and also disallow <code>sizeof</code> on functions!) but permits to return <em>function pointers</em>.</p>\n<p><sup>BTW, I don't think that you could return entire functions. What would that mean? How would you implement that? Practically speaking, a function is some code block, and its name is (like for arrays) a pointer to the start of the function's machine code.</sup></p>\n<p>A nice trick might be to build (using mechanisms <em>outside</em> of the C++ standard) a function at runtime (and then handling its function pointer). Some external libraries might permit that: you could use a JIT library (e.g. <a href=\"https://github.com/kobalicek/asmjit\" rel=\"nofollow noreferrer\">asmjit</a>, <a href=\"https://gcc.gnu.org/onlinedocs/jit/\" rel=\"nofollow noreferrer\">gccjit</a>, <a href=\"http://llvm.org/\" rel=\"nofollow noreferrer\">LLVM</a> ...) or simply generate C++ code, then compile and <a href=\"http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html\" rel=\"nofollow noreferrer\">dlopen</a> &amp; <a href=\"http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\" rel=\"nofollow noreferrer\">dlsym</a> it on POSIX systems, etc.</p>\n<p>PS. You are probably right in understanding that the C++11 <em>grammar</em> (the EBNF rules in the standard) does not disallow returning functions. It is a <em>semantic rule</em> stated in plain English which disallows that (it is <em>not</em> any grammar rule). I mean that the EBNF alone would allow:</p>\n<pre><code> // semantically wrong... but perhaps not syntactically\n typedef int sigfun_T(std::string);\n sigfun_T foobar(int);\n</code></pre>\n<p>and it is for <a href=\"https://en.wikipedia.org/wiki/Semantics_%28computer_science%29\" rel=\"nofollow noreferrer\">semantics</a> reasons (not because of EBNF rules) that a compiler is rightly rejecting the above code. Practically speaking, the <a href=\"https://en.wikipedia.org/wiki/Symbol_table\" rel=\"nofollow noreferrer\">symbol table</a> matters a lot to the C++ compiler (and it is <em>not</em> syntax or context-free grammar).</p>\n<p>The sad fact about C++ is that (for legacy reasons) its grammar (alone) is very ambiguous. Hence C++11 is difficult to read (for humans), difficult to write (for developers), difficult to parse (for compilers), ....</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-13T16:14:32.780", "Score": "6", "CreationDate": "2015-07-13T15:29:02.420", "ParentId": "31387238", "CommentCount": "17", "OwnerUserId": "841108", "LastEditDate": "2017-05-23T11:46:18.273"}, "bq_ids": {"n4140": {"so_31387238_31387510_1": {"length": 14, "quality": 0.6666666666666666, "section_id": 3238}, "so_31387238_31387510_0": {"length": 27, "quality": 1.0, "section_id": 3244}}, "n3337": {"so_31387238_31387510_1": {"length": 14, "quality": 0.6666666666666666, "section_id": 3111}, "so_31387238_31387510_0": {"length": 27, "quality": 1.0, "section_id": 3117}}, "n4659": {"so_31387238_31387510_1": {"length": 12, "quality": 0.5714285714285714, "section_id": 3993}, "so_31387238_31387510_0": {"length": 27, "quality": 1.0, "section_id": 4002}}}, "31387824": {"Id": "31387824", "PostTypeId": "2", "Body": "<p>Actually in C one cannot pass or return function. Only a pointer/address of the function can be passed/returned, which conceptually is pretty close. To be honest, thanks to possiblity of ommiting <code>&amp;</code> and <code>*</code> with function pointers one shouldn't really care if function or pointer is passed (unless it contains any static data). Here is simple function pointer declaration:</p>\n<pre><code>void (*foo)();\n</code></pre>\n<p>foo is pointer to function returning void and taking no arguments.</p>\n<p>In C++ it is not that much different. One can still use C-style function pointers or new useful <code>std::function</code> object for all callable creations. C++ also adds <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">lambda expressions</a> which are inline functions which work somehow similar to closures in functional languages. It allows you not to make all passed functions global.</p>\n<p>And finally - returning function pointer or <code>std::function</code> may seem ridiculous, but it really is not. For example, the state machine pattern is (in most cases) based on returning pointer to function handling next state or callable next state object.</p>\n", "LastActivityDate": "2015-07-13T15:47:30.223", "CommentCount": "0", "CreationDate": "2015-07-13T15:47:30.223", "ParentId": "31387238", "Score": "-1", "OwnerUserId": "3414900"}, "31387322": {"Id": "31387322", "PostTypeId": "2", "Body": "<p>The formal grammar of C actually disallows returning functions but, one can always return a function pointer which, for all intents and purposes, seems like what you want to do:</p>\n<pre><code>  int (*getFunc())(int, int) { \u2026 }\n</code></pre>\n<p>I am fixated in saying, the grammar, is a more fundamental explanation for the lack of support of such feature. The standard's rules are a latter concern.</p>\n<p>If the grammar does not provide for a way to accomplish something, I don't think it matters what the semantics or the standard says for any given context-free language.</p>\n", "LastEditorUserId": "99635", "LastActivityDate": "2015-07-13T16:02:38.910", "Score": "0", "CreationDate": "2015-07-13T15:23:05.757", "ParentId": "31387238", "CommentCount": "15", "OwnerUserId": "99635", "LastEditDate": "2015-07-13T16:02:38.910"}, "31387238": {"ViewCount": "8833", "Body": "<p>Where in the standard are functions returning functions disallowed? I understand they are conceptually ridiculous, but it seems to me that the grammar would allow them. According to this webpage, a \"<a href=\"http://en.cppreference.com/w/cpp/language/function\">noptr-declarator [is] any valid declarator</a>\" which would include the declarator of a function:</p>\n<pre><code>int f()();\n</code></pre>\n<hr>\n<p><strong>Regarding the syntax.</strong></p>\n<p>It seems to me that the syntax, as spelled out in [dcl.decl], allows</p>\n<pre><code>int f(char)(double)\n</code></pre>\n<p>which could be interpreted as <em>the function</em> <code>f</code> <em>that takes a</em> <code>char</code> <em>and returns a function with same signature as</em> <code>int g(double)</code>.</p>\n<pre><code>1    declarator:\n2       ptr-declarator\n3       noptr-declarator parameters-and-qualifiers trailing-return-type\n4    ptr-declarator:\n5        noptr-declarator\n6        ptr-operator ptr-declarator\n7    noptr-declarator:\n8        declarator-id attribute-specifier-seq opt\n9        noptr-declarator parameters-and-qualifiers\n10       noptr-declarator [ constant-expression opt ] attribute-specifier-seq opt\n11       ( ptr-declarator )\n12    parameters-and-qualifiers:\n13       ( parameter-declaration-clause ) cv-qualifier-seqAfter\n</code></pre>\n<p>Roughly speaking, after\n1-&gt;2, 2=4, 4-&gt;6, 4-&gt;6\nyou should have \n    ptr-operator ptr-operator ptr-operator\nThen, use 4-&gt;5, 5=7, 7-&gt;8 for the first declarator; use 4-&gt;5, 5=7, 7-&gt;9 for the second and third declarators. </p>\n</hr>", "AcceptedAnswerId": "31387510", "Title": "C++ function returning function", "CreationDate": "2015-07-13T15:18:32.367", "Id": "31387238", "CommentCount": "14", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2015-07-13T22:37:37.767", "LastEditorUserId": "2549876", "LastActivityDate": "2015-07-18T06:35:05.553", "Score": "23", "OwnerUserId": "2549876", "Tags": "<c++><c++11><standards><language-lawyer>", "AnswerCount": "5"}, "31387510": {"Id": "31387510", "PostTypeId": "2", "Body": "<p>From [dcl.fct], pretty explicitly:</p>\n<blockquote>\n<p id=\"so_31387238_31387510_0\"><strong>Functions shall not have a return type of type array or function</strong>, although they may have a return type of\n  type pointer or reference to such things. There shall be no arrays of functions, although there can be arrays\n  of pointers to functions.</p>\n</blockquote>\n<p>With C++11, you probably just want:</p>\n<pre><code>std::function&lt;int()&gt; f();\nstd::function&lt;int(double)&gt; f(char);\n</code></pre>\n<hr>\n<p>There is some confusion regarding the C++ grammar. The statement <code>int f(char)(double);</code> <em>can</em> be parsed according to the grammar. Here is a parse tree:</p>\n<p><img alt=\"grammar\" src=\"https://i.stack.imgur.com/ecsUK.png\"/></p>\n<p>Furthermore such a parse is even meaningful based on [dcl.fct]/1:</p>\n<blockquote>\n<p id=\"so_31387238_31387510_1\">In a declaration <code>T D</code> where <code>D</code> has the form<br>\n  \u00a0\u00a0\u00a0\u00a0<code>D1</code> ( <em>parameter-declaration-clause</em> ) <em>cv-qualifier-seq</em><sub>opt</sub><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>ref-qualifier</em><sub>opt</sub> <em>exception-specification</em><sub>opt</sub> <em>attribute-specifier-seq</em><sub>opt</sub><br>\n  and the type of the contained <em>declarator-id</em> in the declaration <code>T D1</code> is \u201c<em>derived-declarator-type-list</em> <code>T</code>\u201d, the\n  type of the <em>declarator-id</em> in <code>D</code> is \u201c<em>derived-declarator-type-list</em> function of (<em>parameter-declaration-clause</em> ) <em>cv-qualifier-seq</em><sub>opt</sub>\n<em>ref-qualifier</em><sub>opt</sub> returning <code>T</code>\u201d.</br></br></br></p>\n</blockquote>\n<p>In this example <code>T == int</code>, <code>D == f(char)(double)</code>, <code>D1 == f(char)</code>. The type of the <em>declarator-id</em> in <code>T D1</code> (<code>int f(char)</code>) is \"function of (char) returning int\". So <em>derived-declarator-type-list</em> is \"function of (char) returning\". Thus, the type of <code>f</code> would be read as \"function of (char) returning function of (double) returning int.\"</p>\n<p>It's ultimately much ado about nothing, as this is an explicitly disallowed declarator form. But not by the grammar. </p>\n</hr>", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-14T12:54:52.390", "Score": "50", "CreationDate": "2015-07-13T15:32:34.577", "ParentId": "31387238", "CommentCount": "15", "OwnerUserId": "2069064", "LastEditDate": "2015-07-14T12:54:52.390"}});