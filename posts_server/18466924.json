post_cb({"bq_ids": {"n4140": {"so_18466924_18467058_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 2711}}, "n3337": {"so_18466924_18467058_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 2672}}, "n4659": {"so_18466924_18467058_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 3451}}}, "18466924": {"ViewCount": "134", "Body": "<p>I create a global variable (C++) in main thread and set its value to X then to Y.\nAfter that I spawn multiple threads and read  from this variable.\nDo I have a guarantee that I will read Y ?</p>\n<p>If not, would read(shared)-mutex protection solve it ? (even though mutex can be always taken)</p>\n<p>What exactly forces caches of multiple processors to be synchronized?</p>\n", "Title": "Correctness of reading data from multiple threads", "CreationDate": "2013-08-27T13:30:57.117", "LastActivityDate": "2013-08-27T15:46:27.380", "CommentCount": "1", "PostTypeId": "1", "Id": "18466924", "Score": "2", "OwnerUserId": "61342", "Tags": "<c++><multithreading>", "AnswerCount": "2"}, "18467123": {"Id": "18467123", "PostTypeId": "2", "Body": "<p>If you spawn your threads <em>after</em> assigning <code>Y</code> to your variable, they will indeed see that value.</p>\n<blockquote>\n<p id=\"so_18466924_18467123_0\">would read(shared)-mutex protection solve it ?</p>\n</blockquote>\n<p>Mutexes are only required when you modify your variable concurrently (whether the other concurrent operations are read or write). If you never modify your variable concurrently (as is the case here), you don't need mutexes.</p>\n<blockquote>\n<p id=\"so_18466924_18467123_1\">What exactly forces caches of multiple processors to be synchronized?</p>\n</blockquote>\n<p>Typically, a write to a memory location will invalidate the corresponding cache entries on the other processors. When you access that variable again, the corresponding processor will repopulate the cache if needed.</p>\n", "LastActivityDate": "2013-08-27T13:39:23.190", "CommentCount": "0", "CreationDate": "2013-08-27T13:39:23.190", "ParentId": "18466924", "Score": "0", "OwnerUserId": "2070725"}, "18467058": {"Id": "18467058", "PostTypeId": "2", "Body": "<p>Starting a thread introduces an implicit memory barrier.</p>\n<p>C++11 guarantees this for constructing <code>std::threads</code> in \u00a730.3.1.2:</p>\n<blockquote>\n<p id=\"so_18466924_18467058_0\">Synchronization: The completion of the invocation of the constructor\n  synchronizes with the beginning of the invocation of the copy of f.</p>\n</blockquote>\n<p>Where f is the function being executed by the thread. Also see \u00a71.10 for the definition of <em>synchronizes with</em> (or take a look at <a href=\"http://preshing.com/20130823/the-synchronizes-with-relation\" rel=\"nofollow\">this blog post</a>).</p>\n<p>In layman's terms, it is safe to read the value from different threads concurrently and it is guaranteed that they will all read the latest, correct value. This of course is only true as long as no one performs any writes on that variable once you began starting threads. In that case you will need atomics or explicit locks (i.e. mutexes).</p>\n", "LastEditorUserId": "577603", "LastActivityDate": "2013-08-27T15:46:27.380", "Score": "4", "CreationDate": "2013-08-27T13:36:48.690", "ParentId": "18466924", "CommentCount": "4", "OwnerUserId": "577603", "LastEditDate": "2013-08-27T15:46:27.380"}});