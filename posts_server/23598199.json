post_cb({"23598338": {"Id": "23598338", "PostTypeId": "2", "Body": "<p>It should be <code>private_key() : rsa() {};</code></p>\n", "LastActivityDate": "2014-05-11T21:50:54.943", "CommentCount": "3", "CreationDate": "2014-05-11T21:50:54.943", "ParentId": "23598199", "Score": "1", "OwnerUserId": "3607250"}, "bq_ids": {"n4140": {"so_23598199_23598296_0": {"length": 15, "quality": 0.9375, "section_id": 429}}, "n3337": {"so_23598199_23598296_0": {"length": 15, "quality": 0.9375, "section_id": 421}}, "n4659": {"so_23598199_23598296_0": {"length": 15, "quality": 0.9375, "section_id": 447}}}, "23598199": {"ViewCount": "555", "Body": "<p>I have written some code to calculate the RSA cryptographic algorithm. The program uses classes and inheritance because I want to calculate a public and private key for multiple users. There is a parent class <code>rsa</code> and child classes <code>public_key</code> and <code>private_key</code>.</p>\n<p>When compiling the code below, I get many errors. All of them are about the derived classes not having the available fields in their respective constructors (see error message below code). However, these variables are defined with the <code>protected</code> access modifier in the parent class, so they should be accessible to the child class.</p>\n<p>One side note: I had the function <code>key</code> in both of the child classes, but I thought it would be better to put it once in the parent class, is this right?</p>\n<p>Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\nusing namespace std;\n\nclass rsa\n{\nprotected:\n    int p, q, d, m, n, f, e, c, end, k;\n\npublic:\n    rsa() : n(0), e(0), c(0), k(0), end(0), f(0)\n    { }\n\n    void set(int , int , int, int);\n\n    int key()\n    {\n        n = p * q;\n        f = (p - 1) * (q - 1);\n\n        for (k; end &lt; 1; k++)\n        {\n            if ((1 + k * f) % d == 0) \n            {\n                end = 2;\n                e = (1 + k * f) / d;\n            }\n        }\n\n        c = int(pow(m, e)) % n;\n\n        return c;\n    }\n};\n\nvoid rsa::set(int p_, int q_, int d_, int m_)\n{\n    p = p_;\n    q = q_;\n    d = d_;\n    m = m_;\n}\n\nclass public_key : public rsa\n{\npublic:\n    public_key() : n(0), e(0), c(0), k(0), end(0), f(0)\n    { }\n};\n\nclass private_key : public rsa\n{\npublic:\n    private_key() : n(0), e(0), c(0), k(0), end(0), f(0)\n    { }\n};\n\nint main()\n{\n    public_key usr1, usr2;\n    private_key usr1r, usr2r;\n\n    usr1.set(11, 5, 23, 9);\n    usr2.set(13, 7, 97, 6);\n    usr1r.set(17, 7, 51, 8);\n    usr2r.set(11, 17, 51, 4);\n\n    cout &lt;&lt; \"Public key of user 1: \" &lt;&lt; usr1.key() &lt;&lt; endl;\n    cout &lt;&lt; \"Public key o user 2: \" &lt;&lt; usr2.key() &lt;&lt; endl;\n\n    cin.get();\n\n    return 0;\n}\n</code></pre>\n<p>One of the errors:</p>\n<pre><code>error: class \u2018private_key\u2019 does not have any field named \u2018e\u2019\n   private_key () : n(0), e(0), c(0), k(0), end(0), f(0) {} ;\n</code></pre>\n<p>All the other errors are the same but the field name changes.</p>\n", "AcceptedAnswerId": "23598292", "Title": "C++ Protected Variables Not Inherited", "CreationDate": "2014-05-11T21:35:20.130", "Id": "23598199", "CommentCount": "5", "LastEditDate": "2014-05-12T02:01:54.153", "PostTypeId": "1", "LastEditorUserId": "1313439", "LastActivityDate": "2014-05-12T02:03:00.377", "Score": "0", "OwnerUserId": "2722899", "Tags": "<c++><class><inheritance><member><protected>", "AnswerCount": "3"}, "23598292": {"Id": "23598292", "PostTypeId": "2", "Body": "<p>The error has nothing to do with the access level of the members of class <code>rsa</code>. Even if you declare those members <code>public</code> you will still get the error. The problem is that a derived class's initialization list is run solely in the context of itself, you do not have access to base class members.</p>\n<p>You can however access base class members (that are <code>public</code> or <code>protected</code>) in the body of a derived class constructor. Ex:</p>\n<pre><code>class public_key : public rsa\n{\npublic:\n    public_key()\n    {\n        n = 0;\n        e = 0;\n        c = 0;\n        k = 0;\n        end = 0;\n        f = 0;\n    }\n};\n\nclass private_key : public rsa\n{\npublic:\n    private_key()\n    {\n        n = 0;\n        e = 0;\n        c = 0;\n        k = 0;\n        end = 0;\n        f = 0;\n    }\n};\n</code></pre>\n<p>Though the above code uses <em>assignment</em> instead of <em>initialization</em>, it does the exact same thing under the hood for primitive types, which all of those members are.</p>\n<p>Still, though the above code works, it is the wrong way of doing what you want. You have already written a constructor for class <code>rsa</code>, so one way to avoid duplicating code is to call your existing constructor from the initialization list.</p>\n<pre><code>class public_key : public rsa\n{\npublic:\n    public_key() : rsa()\n    { }\n};\n\nclass private_key : public rsa\n{\npublic:\n    private_key() : rsa()\n    { }\n};\n</code></pre>\n<p>However note that <code>rsa()</code> is the default constructor (since it has no parameters) so it will automatically be called by any constructor of the derived class (unless you specify some other <code>rsa</code> constructor in the initialization list).</p>\n<pre><code>class public_key : public rsa\n{\npublic:\n    public_key()\n    { } // rsa() will be called automatically\n};\n\nclass private_key : public rsa\n{\npublic:\n    private_key()\n    { } // rsa() will be called automatically\n};\n</code></pre>\n<p>But now that your derived class's have empty default constructors, you do not even need them (unless you plan to add more logic).</p>\n<pre><code>class public_key : public rsa\n{\npublic:\n    // rsa() will still be called automatically when declaring an instance of public_key\n};\n\nclass private_key : public rsa\n{\npublic:\n    // rsa() will still be called automatically when declaring an instance of private_key \n};\n</code></pre>\n<p>As to your side note on the <code>key()</code> function, if the implementation of <code>key()</code> was the same in both child classes then yes, you only need it once in the parent class. You should always avoid code duplication so even if a small part of <code>key()</code> needed to be customized for each child class, you are better off writing a virtual function in the base class that <code>key()</code> can call as part of the calculation. Then, in each child class, override the virtual function with whatever specialization is necessary. Thus all the shared code can remain in the parent class <code>key()</code> function.</p>\n", "LastEditorUserId": "1313439", "LastActivityDate": "2014-05-12T02:03:00.377", "Score": "5", "CreationDate": "2014-05-11T21:46:10.573", "ParentId": "23598199", "CommentCount": "2", "OwnerUserId": "1313439", "LastEditDate": "2014-05-12T02:03:00.377"}, "23598296": {"Id": "23598296", "PostTypeId": "2", "Body": "<p>According to the C++ Standard (12.6.2 Initializing bases and members, paragraph #2)</p>\n<blockquote>\n<p id=\"so_23598199_23598296_0\">Unless the mem-initializer-id names the constructor\u2019s class, a\n  non-static data member of the constructor\u2019s class, or a direct or\n  virtual base of that class, the mem-initializer is ill-formed.</p>\n</blockquote>\n<p>So mem-initializers of the derived classes in your program are ill-formed and the compiler issues an error.</p>\n<p>It is the base class constructor that should initialize its data members.</p>\n<p>There is no any sense to define the constructor of class for example public_key  the following way as</p>\n<pre><code>public_key () : n(0), e(0), c(0), k(0), end(0), f(0) {} ;\n</code></pre>\n<p>because at first the constructor of the base class will be called</p>\n<pre><code>rsa () : n(0), e(0), c(0), k(0), end(0), f(0) {};\n</code></pre>\n<p>and it will initialize the data members.</p>\n<p>So it is enough to write</p>\n<pre><code>rsa () {}\n</code></pre>\n<p>or</p>\n<pre><code>rsa () = default;\n</code></pre>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-05-11T21:53:42.123", "Score": "4", "CreationDate": "2014-05-11T21:46:32.400", "ParentId": "23598199", "CommentCount": "8", "OwnerUserId": "2877241", "LastEditDate": "2014-05-11T21:53:42.123"}});