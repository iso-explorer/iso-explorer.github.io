post_cb({"26829733": {"ParentId": "26793979", "CommentCount": "4", "Body": "<p>This overload:</p>\n<pre><code>template&lt;class T, size_t N&gt;\nvoid swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));\n</code></pre>\n<p>is not in scope until <code>;</code>, so <code>swap(*a, *b)</code> doesn't consider this overload. This is because of:</p>\n<blockquote>\n<p id=\"so_26793979_26829733_0\">3.3.2/1 The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer (if any) \u2026</p>\n</blockquote>\n<p>and the exception specification is part of the declarator.</p>\n", "OwnerUserId": "1804599", "PostTypeId": "2", "Id": "26829733", "Score": "11", "CreationDate": "2014-11-09T15:20:07.647", "LastActivityDate": "2014-11-09T15:20:07.647"}, "bq_ids": {"n4140": {"so_26793979_26829733_0": {"section_id": 7049, "quality": 0.7857142857142857, "length": 11}}, "n3337": {"so_26793979_26829733_0": {"section_id": 6794, "quality": 0.7857142857142857, "length": 11}}, "n4659": {"so_26793979_26829733_0": {"section_id": 8546, "quality": 0.7857142857142857, "length": 11}}}, "26793979": {"CommentCount": "4", "AcceptedAnswerId": "26829733", "PostTypeId": "1", "LastEditorUserId": "565635", "CreationDate": "2014-11-07T04:20:08.937", "LastActivityDate": "2014-11-09T15:20:07.647", "LastEditDate": "2014-11-07T05:27:30.457", "ViewCount": "501", "FavoriteCount": "6", "Title": "Why is swapping multidimensional arrays not noexcept?", "Id": "26793979", "Score": "20", "Body": "<p>I have the following snippet:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char** argv) {\n    int x[2][3];\n    int y[2][3];\n\n    using std::swap;\n    std::cout &lt;&lt; noexcept(swap(x, y)) &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>Using GCC 4.9.0, this prints <code>0</code>. I don't understand why.</p>\n<p>According to the standard there's two overloads for <code>std::swap</code>:</p>\n<pre><code>namespace std {\n    template&lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(\n        is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;\n        is_nothrow_move_assignable&lt;T&gt;::value\n    );\n\n    template&lt;class T, size_t N&gt;\n    void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));\n}\n</code></pre>\n<p>In my understanding the <code>noexcept</code> specifier for the array should work recursively for multidimensional arrays.</p>\n<p>Why is swapping multidimensional arrays not <code>noexcept</code>?</p>\n<hr>\n<p>While trying to find a minimal example that still behaves weirdly I came up with the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt; struct Specialized      : std::false_type {};\ntemplate&lt;&gt;        struct Specialized&lt;int&gt; : std::true_type  {};\n\ntemplate&lt;class T&gt;                void f(T&amp; a) noexcept(Specialized&lt;T&gt;::value);\ntemplate&lt;class T, std::size_t N&gt; void f(T (&amp;a)[N]) noexcept(noexcept(f(*a)));\n\nint main(int argc, char** argv) {\n    int x, y[1], z[1][1];\n\n    std::cout &lt;&lt; noexcept(f(x)) &lt;&lt; \" \"\n              &lt;&lt; noexcept(f(y)) &lt;&lt; \" \"\n              &lt;&lt; noexcept(f(z)) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Using GCC 4.9.0 this prints <code>1 1 0</code>, but again I don't understand why.</p>\n</hr>", "Tags": "<c++><swap><noexcept>", "OwnerUserId": "565635", "AnswerCount": "1"}});