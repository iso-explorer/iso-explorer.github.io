post_cb({"14909997": {"CommentCount": "11", "AcceptedAnswerId": "14909999", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2013-02-16T11:55:19.683", "LastActivityDate": "2015-02-21T23:47:35.390", "LastEditDate": "2015-02-18T22:18:32.550", "ViewCount": "21318", "FavoriteCount": "42", "Title": "Why aren't my include guards preventing recursive inclusion and multiple symbol definitions?", "Id": "14909997", "Score": "61", "Body": "<p>Two common questions about <a href=\"http://en.wikipedia.org/wiki/Include_guard\">include guards</a>:</p>\n<ol>\n<li><p><strong>FIRST QUESTION:</strong></p>\n<p>Why aren't include guards protecting my header files from <strong>mutual, recursive inclusion</strong>? I keep getting errors about non-existing symbols which are obviously there or even weirder syntax errors every time I write something like the following:</p>\n<p>\"a.h\"</p>\n<pre><code>#ifndef A_H\n#define A_H\n\n#include \"b.h\"\n\n...\n\n#endif // A_H\n</code></pre>\n<p>\"b.h\"</p>\n<pre><code>#ifndef B_H\n#define B_H\n\n#include \"a.h\"\n\n...\n\n#endif // B_H\n</code></pre>\n<p>\"main.cpp\"</p>\n<pre><code>#include \"a.h\"\nint main()\n{\n    ...\n}\n</code></pre>\n<p>Why do I get errors compiling \"main.cpp\"? What do I need to do to solve my problem?</p></li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><p><strong>SECOND QUESTION:</strong></p>\n<p>Why aren't include guards preventing <strong>multiple definitions</strong>? For instance, when my project contains two files that include the same header, sometimes the linker complains about some symbol being defined multiple times. For instance:</p>\n<p>\"header.h\"</p>\n<pre><code>#ifndef HEADER_H\n#define HEADER_H\n\nint f()\n{\n    return 0;\n}\n\n#endif // HEADER_H\n</code></pre>\n<p>\"source1.cpp\"</p>\n<pre><code>#include \"header.h\"\n...\n</code></pre>\n<p>\"source2.cpp\"</p>\n<pre><code>#include \"header.h\"\n...\n</code></pre>\n<p>Why is this happening? What do I need to do to solve my problem?</p></li>\n</ol>\n</hr>", "Tags": "<c++><header-files><c++-faq><include-guards>", "OwnerUserId": "1932150", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14909997_14909999_14": {"section_id": 7137, "quality": 0.9285714285714286, "length": 13}, "so_14909997_14909999_15": {"section_id": 7137, "quality": 0.9230769230769231, "length": 12}, "so_14909997_14909999_16": {"section_id": 7137, "quality": 1.0, "length": 4}, "so_14909997_14909999_8": {"section_id": 7041, "quality": 0.8888888888888888, "length": 32}, "so_14909997_14909999_10": {"section_id": 7043, "quality": 0.8888888888888888, "length": 48}, "so_14909997_14909999_2": {"section_id": 508, "quality": 0.8235294117647058, "length": 14}, "so_14909997_14909999_11": {"section_id": 7137, "quality": 1.0, "length": 31}}, "n3337": {"so_14909997_14909999_14": {"section_id": 6881, "quality": 0.9285714285714286, "length": 13}, "so_14909997_14909999_15": {"section_id": 6881, "quality": 0.9230769230769231, "length": 12}, "so_14909997_14909999_16": {"section_id": 6881, "quality": 1.0, "length": 4}, "so_14909997_14909999_8": {"section_id": 6786, "quality": 0.8888888888888888, "length": 32}, "so_14909997_14909999_10": {"section_id": 6788, "quality": 0.8888888888888888, "length": 48}, "so_14909997_14909999_2": {"section_id": 499, "quality": 0.8235294117647058, "length": 14}, "so_14909997_14909999_11": {"section_id": 6881, "quality": 1.0, "length": 31}}, "n4659": {"so_14909997_14909999_14": {"section_id": 8638, "quality": 0.9285714285714286, "length": 13}, "so_14909997_14909999_15": {"section_id": 8638, "quality": 0.9230769230769231, "length": 12}, "so_14909997_14909999_8": {"section_id": 8538, "quality": 0.8888888888888888, "length": 32}, "so_14909997_14909999_11": {"section_id": 8638, "quality": 1.0, "length": 31}, "so_14909997_14909999_10": {"section_id": 8540, "quality": 0.8888888888888888, "length": 48}, "so_14909997_14909999_2": {"section_id": 529, "quality": 0.8235294117647058, "length": 14}}}, "14909999": {"ParentId": "14909997", "PostTypeId": "2", "CommentCount": "14", "Body": "<blockquote>\n<p id=\"so_14909997_14909999_0\"><strong>FIRST QUESTION:</strong></p>\n<p id=\"so_14909997_14909999_1\">Why aren't include guards protecting my header files from <strong>mutual, recursive inclusion</strong>?</p>\n</blockquote>\n<p><strong>They are</strong>.</p>\n<p>What they are not helping with is <em>dependencies between the definitions of data structures in mutually-including headers</em>. To see what this means, let's start with a basic scenario and see why include guards do help with mutual inclusions.</p>\n<p>Suppose your mutually including <code>a.h</code> and <code>b.h</code> header files have trivial content, i.e. the ellipses in the code sections from the question's text are replaced with the empty string. In this situation, your <code>main.cpp</code> will happily compile. And this is only thanks to your include guards!</p>\n<p>If you're not convinced, try removing them:</p>\n<pre><code>//================================================\n// a.h\n\n#include \"b.h\"\n\n//================================================\n// b.h\n\n#include \"a.h\"\n\n//================================================\n// main.cpp\n//\n// Good luck getting this to compile...\n\n#include \"a.h\"\nint main()\n{\n    ...\n}\n</code></pre>\n<p>You'll notice that the compiler will report a failure when it reaches the inclusion depth limit. This limit is implementation-specific. Per Paragraph 16.2/6 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14909997_14909999_2\">A #include preprocessing directive may appear in a source file that has been read because of a #include directive in another file, <strong>up to an implementation-defined nesting limit</strong>.</p>\n</blockquote>\n<p><strong>So what's going on</strong>?</p>\n<ol>\n<li>When parsing <code>main.cpp</code>, the preprocessor will meet the directive <code>#include \"a.h\"</code>. This directive tells the preprocessor to process the header file <code>a.h</code>, take the result of that processing, and replace the string <code>#include \"a.h\"</code> with that result;</li>\n<li>While processing <code>a.h</code>, the preprocessor will meet the directive <code>#include \"b.h\"</code>, and the same mechanism applies: the preprocessor shall process the header file <code>b.h</code>, take the result of its processing, and replace the <code>#include</code> directive with that result;</li>\n<li>When processing <code>b.h</code>, the directive <code>#include \"a.h\"</code> will tell the preprocessor to process <code>a.h</code> and replace that directive with the result;</li>\n<li>The preprocessor will start parsing <code>a.h</code> again, will meet the <code>#include \"b.h\"</code> directive again, and this will set up a potentially infinite recursive process. When reaching the critical nesting level, the compiler will report an error.</li>\n</ol>\n<p><strong>When include guards are present</strong>, however, no infinite recursion will be set up in step 4. Let's see why:</p>\n<ol>\n<li>(<em>same as before</em>) When parsing <code>main.cpp</code>, the preprocessor will meet the directive <code>#include \"a.h\"</code>. This tells the preprocessor to process the header file <code>a.h</code>, take the result of that processing, and replace the string <code>#include \"a.h\"</code> with that result;</li>\n<li>While processing <code>a.h</code>, the preprocessor will meet the directive <code>#ifndef A_H</code>. Since the macro <code>A_H</code> has not yet been defined, it will keep processing the following text. The subsequent directive (<code>#defines A_H</code>) defines the macro <code>A_H</code>. Then, the preprocessor will meet the directive <code>#include \"b.h\"</code>: the preprocessor shall now process the header file <code>b.h</code>, take the result of its processing, and replace the <code>#include</code> directive with that result;</li>\n<li>When processing <code>b.h</code>, the preprocessor will meet the directive <code>#ifndef B_H</code>. Since the macro <code>B_H</code> has not yet been defined, it will keep processing the following text. The subsequent directive (<code>#defines B_H</code>) defines the macro <code>B_H</code>. Then, the directive <code>#include \"a.h\"</code> will tell the preprocessor to process <code>a.h</code> and replace the <code>#include</code> directive in <code>b.h</code> with the result of preprocessing <code>a.h</code>;</li>\n<li>The compiler will start preprocessing <code>a.h</code> again, and meet the <code>#ifndef A_H</code> directive again. However, during previous preprocessing, macro <code>A_H</code> has been defined. Therefore, the compiler will skip the following text this time until the matching <code>#endif</code> directive is found, and the output of this processing is the empty string (supposing nothing follows the <code>#endif</code> directive, of course). The preprocessor will therefore replace the <code>#include \"a.h\"</code> directive in <code>b.h</code> with the empty string, and will trace back the execution until it replaces the original <code>#include</code> directive in <code>main.cpp</code>.</li>\n</ol>\n<p>Thus, <strong>include guards do protect against mutual inclusion</strong>. However, they can't help with <em>dependencies between the definitions of your classes</em> in mutually-including files:</p>\n<pre><code>//================================================\n// a.h\n\n#ifndef A_H\n#define A_H\n\n#include \"b.h\"\n\nstruct A\n{\n};\n\n#endif // A_H\n\n//================================================\n// b.h\n\n#ifndef B_H\n#define B_H\n\n#include \"a.h\"\n\nstruct B\n{\n    A* pA;\n};\n\n#endif // B_H\n\n//================================================\n// main.cpp\n//\n// Good luck getting this to compile...\n\n#include \"a.h\"\nint main()\n{\n    ...\n}\n</code></pre>\n<p>Given the above headers, <code>main.cpp</code> will not compile.</p>\n<blockquote>\n<p id=\"so_14909997_14909999_3\">Why is this happening?</p>\n</blockquote>\n<p>To see what's going on, it is enough to go through steps 1-4 again. </p>\n<p>It is easy to see that the first three steps and most of the fourth step are unaffected by this change (just read through them to get convinced). However, something different happens at the end of step 4: after replacing the <code>#include \"a.h\"</code> directive in <code>b.h</code> with the empty string, the preprocessor will start parsing the content of <code>b.h</code> and, in particular, the  definition of <code>B</code>. Unfortunately, the definition of <code>B</code> mentions class <code>A</code>, which has never been met before exactly <em>because</em> of the inclusion guards! </p>\n<p>Declaring a member variable of a type which has not been previously declared is, of course, an error, and the compiler will politely point that out.</p>\n<blockquote>\n<p id=\"so_14909997_14909999_4\">What do I need to do to solve my problem?</p>\n</blockquote>\n<p>You need <a href=\"http://en.wikipedia.org/wiki/Forward_declaration\" rel=\"nofollow noreferrer\"><strong>forward declarations</strong></a>.</p>\n<p>In fact, the <em>definition</em> of class <code>A</code> is not required in order to define class <code>B</code>, because a <em>pointer</em> to <code>A</code> is being declared as a member variable, and not an object of type <code>A</code>. Since pointers have fixed size, the compiler won't need to know the exact layout of <code>A</code> nor to compute its size in order to properly define class <code>B</code>. Hence, it is enough to <strong>forward-declare</strong> class <code>A</code> in <code>b.h</code> and make the compiler aware of its existence:</p>\n<pre><code>//================================================\n// b.h\n\n#ifndef B_H\n#define B_H\n\n// Forward declaration of A: no need to #include \"a.h\"\nstruct A;\n\nstruct B\n{\n    A* pA;\n};\n\n#endif // B_H\n</code></pre>\n<p>Your <code>main.cpp</code> will now certainly compile. A couple of remarks:</p>\n<ol>\n<li>Not only breaking the mutual inclusion by replacing the <code>#include</code> directive with a forward declaration in <code>b.h</code> was enough to effectively express the dependency of <code>B</code> on <code>A</code>: using forward declarations whenever possible/practical is also considered to be a <strong>good programming practice</strong>, because it helps avoiding unnecessary inclusions, thus reducing the overall compilation time. However, after eliminating the mutual inclusion, <code>main.cpp</code> will have to be modified to <code>#include</code> both <code>a.h</code> and <code>b.h</code> (if the latter is needed at all), because <code>b.h</code> is no more indirectly <code>#include</code>d through <code>a.h</code>;</li>\n<li>While a forward declaration of class <code>A</code> is enough for the compiler to declare pointers to that class (or to use it in any other context where incomplete types are acceptable), dereferencing pointers to <code>A</code> (for instance to invoke a member function) or computing its size are <em>illegal</em> operations on incomplete types: if that is needed, the full definition of <code>A</code> needs to be available to the compiler, which means the header file that defines it must be included. This is why class definitions and the implementation of their member functions are usually split into a header file and an implementation file for that class (class <em>templates</em> are an exception to this rule): implementation files, which are never <code>#include</code>d by other files in the project, can safely <code>#include</code> all the necessary headers to make definitions visible. Header files, on the other hand, won't <code>#include</code> other header files <em>unless</em> they really need to do so (for instance, to make the definition of a <em>base class</em> visible), and will use forward-declarations whenever possible/practical.</li>\n</ol>\n<blockquote>\n<p id=\"so_14909997_14909999_5\"><strong>SECOND QUESTION:</strong></p>\n<p id=\"so_14909997_14909999_6\">Why aren't include guards preventing <strong>multiple definitions</strong>?</p>\n</blockquote>\n<p><strong>They are</strong>.</p>\n<p>What they are not protecting you from is multiple definitions <em>in separate translation units</em>. This is also explained in <a href=\"https://stackoverflow.com/questions/14425262/why-include-guards-do-not-prevent-multiple-function-definitions/14425299#14425299\"><strong>this Q&amp;A</strong></a> on StackOverflow.</p>\n<p>Too see that, try removing the include guards and compiling the following, modified version of <code>source1.cpp</code> (or <code>source2.cpp</code>, for what it matters):</p>\n<pre><code>//================================================\n// source1.cpp\n//\n// Good luck getting this to compile...\n\n#include \"header.h\"\n#include \"header.h\"\n\nint main()\n{\n    ...\n}\n</code></pre>\n<p>The compiler will certainly complain here about <code>f()</code> being redefined. That's obvious: its definition is being included twice! However, the above <code>source1.cpp</code> <strong>will compile without problems when <code>header.h</code> contains the proper include guards</strong>. That's expected. </p>\n<p>Still, even when the include guards are present and the compiler will stop bothering you with error message, the <em>linker</em> will insist on the fact that multiple definitions being found when merging the object code obtained from the compilation of <code>source1.cpp</code> and <code>source2.cpp</code>, and will refuse to generate your executable.</p>\n<blockquote>\n<p id=\"so_14909997_14909999_7\">Why is this happening?</p>\n</blockquote>\n<p>Basically, each <code>.cpp</code> file (the technical term in this context is <em>translation unit</em>) in your project is compiled separately and <em>independently</em>. When parsing a <code>.cpp</code> file, the preprocessor will process all the <code>#include</code> directives and expand all macro invocations it encounters, and the output of this pure text processing will be given in input to the compiler for translating it into object code. Once the compiler is done with producing the object code for one translation unit, it will proceed with the next one, and all the macro definitions that have been encountered while processing the previous translation unit will be forgotten. </p>\n<p>In fact, compiling a project with <code>n</code> translation units (<code>.cpp</code> files) is like executing the same program (the compiler) <code>n</code> times, each time with a different input: different executions of the same program <strong>won't share the state of the previous program execution(s)</strong>. Thus, each translation is performed independently and the preprocessor symbols encountered while compiling one translation unit will not be remembered when compiling other translation units (if you think about it for a moment, you will easily realize that this is actually a desirable behavior).</p>\n<p>Therefore, even though include guards help you preventing recursive mutual inclusions and <em>redundant</em> inclusions of the same header in one translation unit, they can't detect whether the same definition is included in <em>different</em> translation unit. </p>\n<p>Yet, when merging the object code generated from the compilation of all the <code>.cpp</code> files of your project, the linker <em>will</em> see that the same symbol is defined more than once, and since this violates the <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\"><strong>One Definition Rule</strong></a>. Per Paragraph 3.2/3 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14909997_14909999_8\">Every program shall contain exactly one definition of every <strong>non-inline</strong> function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). <strong>An inline function shall be defined in every translation unit in which it is odr-used</strong>.</p>\n</blockquote>\n<p>Hence, the linker will emit an error and refuse to generate the executable of your program.</p>\n<blockquote>\n<p id=\"so_14909997_14909999_9\">What do I need to do to solve my problem?</p>\n</blockquote>\n<p><em>If</em> you want to keep your function definition in a header file that is <code>#include</code>d by <em>multiple</em> translation units (notice, that no problem will arise if your header is <code>#include</code>d just by <em>one</em> translation unit), you need to use the <code>inline</code> keyword. </p>\n<p>Otherwise, you need to keep only the <em>declaration</em> of your function in <code>header.h</code>, putting its definition (body) into <em>one</em> separate <code>.cpp</code> file only (this is the classical approach).</p>\n<p>The <code>inline</code> keyword represents a non-binding request to the compiler to inline the function's body directly at the call site, rather than setting up a stack frame for a regular function call. Although the compiler doesn't have to fulfill your request, the <code>inline</code> keyword does succeed in telling the linker to tolerate multiple symbol definitions. According to Paragraph 3.2/5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14909997_14909999_10\"><strong>There can be more than one definition of a</strong> class type (Clause 9), enumeration type (7.2), <strong>inline function with external linkage</strong> (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements [...]</p>\n</blockquote>\n<p><strong>The above Paragraph basically lists all the definitions which are commonly put in header files</strong>, because they can be safely included in multiple translation units. All other definitions with external linkage, instead, belong in source files. </p>\n<p>Using the <code>static</code> keyword instead of the <code>inline</code> keyword also results in suppressing linker errors by giving your function <a href=\"https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage-in-c\"><strong>internal linkage</strong></a>, thus making each translation unit hold a private <em>copy</em> of that function (and of its local static variables). However, this eventually results in a larger executable, and the use of <code>inline</code> should be preferred in general.</p>\n<p>An alternative way of achieving the same result as with the <code>static</code> keyword is to put function <code>f()</code> in an <em>unnamed namespace</em>. Per Paragraph 3.5/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14909997_14909999_11\">An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage. All other namespaces have external linkage. A name having namespace scope that has not been given internal linkage above has the same linkage as the enclosing namespace if it is the name of:</p>\n<p id=\"so_14909997_14909999_12\">\u2014 a variable; or</p>\n<p id=\"so_14909997_14909999_13\">\u2014 <strong>a function</strong>; or</p>\n<p id=\"so_14909997_14909999_14\">\u2014 a named class (Clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage purposes (7.1.3); or</p>\n<p id=\"so_14909997_14909999_15\">\u2014 a named enumeration (7.2), or an unnamed enumeration defined in a typedef declaration in which the enumeration has the typedef name for linkage purposes (7.1.3); or</p>\n<p id=\"so_14909997_14909999_16\">\u2014 an enumerator belonging to an enumeration with linkage; or</p>\n<p id=\"so_14909997_14909999_17\">\u2014 a template.</p>\n</blockquote>\n<p>For the same reason mentioned above, the <code>inline</code> keyword should be preferred.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:23.107", "Id": "14909999", "Score": "116", "CreationDate": "2013-02-16T11:55:19.683", "LastActivityDate": "2013-02-19T15:21:14.683"}});