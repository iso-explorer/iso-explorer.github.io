post_cb({"bq_ids": {"n4140": {"so_38214379_38214522_0": {"section_id": 707, "quality": 1.0, "length": 18}}, "n3337": {"so_38214379_38214522_0": {"section_id": 697, "quality": 1.0, "length": 18}}, "n4659": {"so_38214379_38214522_0": {"section_id": 736, "quality": 1.0, "length": 18}}}, "38214545": {"ParentId": "38214379", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-07-05T23:48:07.817", "Score": "11", "LastEditorUserId": "981959", "LastEditDate": "2016-07-05T23:55:14.900", "Id": "38214545", "OwnerUserId": "981959", "Body": "<blockquote>\n<p id=\"so_38214379_38214545_0\">Should I protect <code>std::map::end</code> or is guaranteed that it always the same for one allocated container?</p>\n</blockquote>\n<p>Technically any call to a member function must be protected by a mutex if it could happen concurrently with any non-const member function. So if any thread could be inserting or erasing elements then it's not safe to call <code>end()</code> without locking the mutex.</p>\n<blockquote>\n<p id=\"so_38214379_38214545_1\">Can I use something like this <code>static auto const map_it_end = map1.end();</code> which is not protected by <code>std::mutex</code>?</p>\n</blockquote>\n<p>You can cache the past-the-end iterator in some cases, because the past-the-end iterator for a <code>std::map</code> is not invalidated by insertions and erasures, only potentially by swapping or moving the map.</p>\n<p>But why would you want to? The slow operation is <code>find()</code> not <code>end()</code>, so if you call <code>end()</code> while you still hold the mutex then it definitely works.</p>\n<p>If other threads could be erasing elements then you need to hold the mutex lock while you dereference the iterator returned by <code>find()</code> to be sure it isn't invalidated by another thread erasing the element it refers to. So again, making a call to <code>end()</code> isn't going to be a problem while you have the mutex locked already.</p>\n", "LastActivityDate": "2016-07-05T23:55:14.900"}, "38214522": {"ParentId": "38214379", "CommentCount": "1", "CreationDate": "2016-07-05T23:45:43.070", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "38214522", "Score": "2", "Body": "<p>I find nothing in <code>23.2 Container requirements</code> that specifies that <code>end()</code> always returns the same value, nor that it is thread safe. <code>end()</code> is defined as follows.</p>\n<blockquote>\n<p id=\"so_38214379_38214522_0\">begin() returns an iterator referring to the first element in the\n  container. end() returns an iterator which is the past-the-end value\n  for the container. If the container is empty, then begin() == end();</p>\n</blockquote>\n<p>This specification appears to cover <code>end()</code> for all containers. I find nothing in <code>23.4.4 Class template map</code> that supercedes this general container requirements. Actually, \"Past-the-end value\" is worded like that so it can reasonably be interpreted to mean that the value of <code>end()</code> could change depending on what/where is the last element in the container.</p>\n<p>And that would be the typical case for a <code>std::vector</code>. A typical <code>std::vector</code>'s <code>end()</code> value changes depending on the number of elements in the vector, for the obvious reasons. Nothing specifies that it has to, but that's typically the case. Going back to a <code>std::map</code>, one might expect that a given map's <code>end()</code> will always be same value, but nothing states that it has to, either.</p>\n<p>I would say that all access to a <code>std::map</code> must be protected by a mutex. Once a mutex is released, nothing about the map is valid any more. Can't assume that <code>end()</code> will remain a valid iterator, after the mutex gets released.</p>\n", "LastActivityDate": "2016-07-05T23:45:43.070"}, "38214379": {"CommentCount": "6", "AcceptedAnswerId": "38214545", "PostTypeId": "1", "LastEditorUserId": "1558037", "CreationDate": "2016-07-05T23:28:30.467", "LastActivityDate": "2016-07-05T23:55:14.900", "LastEditDate": "2016-07-05T23:39:45.887", "ViewCount": "623", "FavoriteCount": "2", "Title": "Is std::map::end thread-safe and is guaranteed that it always the same for the same container?", "Id": "38214379", "Score": "6", "Body": "<p>I use <code>std::map</code> and to get a single element I can use: <a href=\"http://www.cplusplus.com/reference/map/map/\" rel=\"nofollow\">http://www.cplusplus.com/reference/map/map/</a></p>\n<ul>\n<li><a href=\"http://www.cplusplus.com/reference/map/map/find/\" rel=\"nofollow\"><code>iterator find (const key_type&amp; k);</code></a></li>\n<li><a href=\"http://www.cplusplus.com/reference/map/map/at/\" rel=\"nofollow\"><code>mapped_type&amp; at (const key_type&amp; k);</code></a></li>\n<li><a href=\"http://www.cplusplus.com/reference/map/map/operator[]/\" rel=\"nofollow\"><code>mapped_type&amp; operator[] (const key_type&amp; k);</code></a></li>\n</ul>\n<p>also: <code>lower_bound()</code> or <code>equal_range()</code> - are same as <code>find()</code> in this case.</p>\n<p><strong>I can't use</strong>:</p>\n<ul>\n<li><code>at()</code> - because it throw an exception, and I measured 10 times the performance degradation</li>\n<li><code>operator[]</code> - because it insert an element if it non-exist, such behavior is unacceptable</li>\n</ul>\n<p><code>find()</code> - is what I want. But I use <code>std::map</code> in multi-thread program and protect it by lock <code>std::mutex</code>.</p>\n<p>There are also insertion and removal to <code>std::map</code> from the other threads.</p>\n<p>Should I protect <a href=\"http://www.cplusplus.com/reference/map/map/end/\" rel=\"nofollow\"><code>std::map::end</code></a> or is guaranteed that it always the same for one allocated container?</p>\n<p>Can I use something like this <code>static auto const map_it_end = map1.end();</code> which is not protected by <code>std::mutex</code>?</p>\n<p><a href=\"http://ideone.com/tATn0H\" rel=\"nofollow\">http://ideone.com/tATn0H</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n#include &lt;map&gt;\n\nstd::map&lt;std::string, std::string&gt; map1 ( {{\"apple\",\"red\"},{\"lemon\",\"yellow\"}} );\nstatic auto const map_it_end = map1.end();\nstd::mutex mtx1;\n\nvoid func() {\n    std::lock_guard&lt;std::mutex&gt; lock1(mtx1);\n\n    auto it1 = map1.find(\"apple\");\n    if(it1 != map_it_end)   // instead of: if(it1 != map1.end())\n        std::cout &lt;&lt; it1-&gt;second &lt;&lt; \", \";\n}\n\nint main ()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n    t1.join();\n    t2.join();\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://www.cplusplus.com/reference/map/map/end/\" rel=\"nofollow\">http://www.cplusplus.com/reference/map/map/end/</a></p>\n<blockquote>\n<p id=\"so_38214379_38214379_0\">Data races The container is accessed (neither the const nor the\n  non-const versions modify the container). No contained elements are\n  accessed by the call, but the iterator returned can be used to access\n  or modify elements. Concurrently accessing or modifying different\n  elements is safe.</p>\n</blockquote>\n", "Tags": "<c++><multithreading><c++11><concurrency><c++14>", "OwnerUserId": "1558037", "AnswerCount": "2"}});