post_cb({"24583508": {"Id": "24583508", "PostTypeId": "2", "Body": "<p>You can use C syntax <code>(int)(f&gt;&gt;31)</code>, it will work for both as this C-syntax is C++-compliant.</p>\n", "LastActivityDate": "2014-07-05T06:03:07.283", "CommentCount": "0", "CreationDate": "2014-07-05T06:03:07.283", "ParentId": "24583476", "Score": "4", "OwnerUserId": "719263"}, "bq_ids": {"n4140": {"so_24583476_24588157_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 6071}}, "n3337": {"so_24583476_24588157_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5839}}, "n4659": {"so_24583476_24588157_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 7567}}}, "24583504": {"Id": "24583504", "PostTypeId": "2", "Body": "<p>C doesn't support the C++ \"function-style\" casting. You need to write it like this</p>\n<pre><code>unsigned mask = -(int)(f &gt;&gt; 31) | 0x80000000;\n</code></pre>\n", "LastActivityDate": "2014-07-05T06:02:54.297", "CommentCount": "0", "CreationDate": "2014-07-05T06:02:54.297", "ParentId": "24583476", "Score": "8", "OwnerUserId": "995714"}, "24583476": {"ViewCount": "211", "Body": "<p>The following piece of code compiles with g++ and not gcc, and am stuck wondering why?</p>\n<pre><code>inline unsigned FloatFlip(unsigned f)\n{\n    unsigned mask = -int(f &gt;&gt; 31) | 0x80000000;\n    return f ^ mask;\n}\n</code></pre>\n<p>I would assume that in C++, \n    int(f &gt;&gt; 31) \nis a constructor but that leaves me wondering why its included in the code.Is  it necessary?</p>\n", "Title": "code compiles with g++ but not gcc", "CreationDate": "2014-07-05T05:59:00.900", "LastActivityDate": "2014-08-03T09:23:26.150", "CommentCount": "8", "PostTypeId": "1", "Id": "24583476", "Score": "1", "OwnerUserId": "2301022", "Tags": "<c++><c><gcc><g++>", "AnswerCount": "3"}, "24588157": {"Id": "24588157", "PostTypeId": "2", "Body": "<p>As the other answers discussed, <code>int(f &gt;&gt; 31)</code> is a C++ function-style cast, and it has the same meaning as the C-style <code>(int) (f &gt;&gt; 31)</code>. </p>\n<blockquote>\n<p id=\"so_24583476_24588157_0\">How is this cast important? </p>\n</blockquote>\n<p>Actually, this code looks like it's trying to be too clever. <code>f &gt;&gt; 31</code> retains only the highest-order bit in <code>f</code>, so it's either <code>1</code> or <code>0</code>. The code then casts it to an <code>int</code> and performs unary negation on it, giving you either <code>-1</code> or <code>0</code>, and finally bitwise-OR's the result with <code>0x80000000</code>, which sets the highest bit and then stores the result into <code>mask</code>. Assuming a two's complement system, <code>-1</code>'s representation is <code>0xFFFFFFFF</code> and so <code>mask</code> will become <code>0xFFFFFFFF</code> if the highest-order bit of <code>f</code> is set, and <code>0x80000000</code> otherwise.</p>\n<p>The problem, however, is that <code>int</code>s do not have to use two-complement. If the system is one's complement, for instance, <code>-1</code>'s representation would be <code>0xFFFFFFFE</code>, and if the system is sign-magnitude, <code>-1</code> would be <code>0x80000001</code>, and <code>mask</code> will have the wrong value.</p>\n<p>The irony is that unary negation for unsigned operands is well-defined to do what the author of this code presumably wanted to do, in \u00a75.3.1 [expr.unary.op]/p8 of the standard:</p>\n<blockquote>\n<p id=\"so_24583476_24588157_1\">The operand of the unary <code>-</code> operator shall have arithmetic or unscoped\n  enumeration type and the result is the negation of its operand.\n  Integral promotion is performed on integral or enumeration operands.\n  The negative of an unsigned quantity is computed by subtracting its\n  value from 2<sup>n</sup>, where n is the number of bits in the promoted operand.\n  The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>In other words, assuming 32-bit <code>int</code>s, <code>-1u</code> is defined to be <code>0xFFFFFFFFu</code>. The cast to <code>int</code> is not just superfluous, it actually causes the code to be nonportable.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-03T09:23:26.150", "Score": "0", "CreationDate": "2014-07-05T15:58:00.790", "ParentId": "24583476", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-08-03T09:23:26.150"}});