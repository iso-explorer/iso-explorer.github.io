post_cb({"26449031": {"ParentId": "26448637", "CommentCount": "1", "Body": "<p>In plain C, you can <code>#include &lt;float.h&gt;</code> which provides constants such as:</p>\n<pre><code>DBL_MAX\nDBL_MIN\n\nFLT_MAX\nFLT_MIN\n</code></pre>\n<p>and as well as how many bits &amp; digits the mantissa is, exponent range, etc. </p>\n<p>I'm always confused about which of the C++ reference site is the \"one you are allowed to post here and which is the one you're not supposed to, because you get comments about it\", but here's one found in google:\n<a href=\"http://www.cplusplus.com/reference/cfloat/\" rel=\"nofollow\">http://www.cplusplus.com/reference/cfloat/</a>\nSince this is rather a standard file, I expect there isn't that much difference anyway. Of course, this refers to the \"C++-ified version\", but the macros defined are the same for C.</p>\n<p>(Note that the C++ <code>limits</code> is typically implemented from the same constants that are found in <code>float.h</code> in some sense, directly or indirectly)</p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "26449031", "Score": "2", "CreationDate": "2014-10-19T09:10:10.477", "LastActivityDate": "2014-10-19T09:10:10.477"}, "26448992": {"ParentId": "26448637", "CommentCount": "0", "Body": "<p>The limits for built-in types are mostly constrained by the hardware limits. x64 CPUs usually use <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point\">IEEE 754</a> representations for their floating point data as defined in the FPA standard (hardware coprocessor).</p>\n<p>Anyway how things are internally represented and handled might vary as you noted</p>\n<blockquote>\n<p id=\"so_26448637_26448992_0\">The value representation of floating-point types is implementation-defined</p>\n</blockquote>\n<p>a compiler usually has knowledge (especially referring to the back-end which does the code generation) of the underlying target system and can therefore choose the right set of instructions when prompted with fp-arithmetic.</p>\n<p>You can always define a custom datatype that manages physical resources yourself. The term you're referring might be <a href=\"http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic\">Arbitrary precision arithmetic</a> (usually considerably slower, if your data fits in what the hardware offers, you should go for it).</p>\n<p>In particular cases (e.g. some embedded units where no FPU is available or a floating point operation cannot be performed) emulation might be used. This is cheaper (less transistors) although slower.</p>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26448992", "Score": "4", "CreationDate": "2014-10-19T09:04:59.677", "LastActivityDate": "2014-10-19T09:04:59.677"}, "26448637": {"CommentCount": "2", "AcceptedAnswerId": "26448992", "PostTypeId": "1", "LastEditorUserId": "777186", "CreationDate": "2014-10-19T08:10:48.873", "LastActivityDate": "2014-10-19T09:10:10.477", "AnswerCount": "3", "LastEditDate": "2014-10-19T08:54:54.203", "ViewCount": "1417", "FavoriteCount": "1", "Title": "How are upper and lower bounds for floating point numbers determined?", "Id": "26448637", "Score": "8", "Body": "<p>I have a question about the quote below (N3797, 3.9.1/8):</p>\n<blockquote>\n<p id=\"so_26448637_26448637_0\">The value representation of floating-point types is implementation-defined.</p>\n</blockquote>\n<p>As far as I understand it gives the implementation complete freedom in defining boundaries of <em>floating point numbers</em>. They are specified in <a href=\"http://www.cplusplus.com/reference/limits/numeric_limits/\"><strong><code>template&lt;class T&gt; class numeric_format</code></strong></a>. For instance,</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"double_max = \" &lt;&lt; std::numeric_limits&lt;double&gt;().max() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"double_min = \" &lt;&lt; std::numeric_limits&lt;double&gt;().min() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"float_max = \" &lt;&lt; std::numeric_limits&lt;float&gt;().max() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"float_min = \" &lt;&lt; std::numeric_limits&lt;float&gt;().min() &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8e33079859455a5d\"><strong>DEMO</strong></a></p>\n<p>My question is: Can upper and lower boundaries for floating point numbers be arbitrarily high or low, or are there restrictions? Does <em>pure C</em> also provide an implementation defined set of values for floating point numbers?</p>\n<p>I suspect it depends on the architecture we're working with.</p>\n", "Tags": "<c++><c><floating-point>", "OwnerDisplayName": "user2953119"}, "bq_ids": {"n4140": {"so_26448637_26448992_0": {"section_id": 7217, "quality": 0.6666666666666666, "length": 4}, "so_26448637_26448637_0": {"section_id": 7217, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_26448637_26448992_0": {"section_id": 6961, "quality": 0.6666666666666666, "length": 4}, "so_26448637_26448637_0": {"section_id": 6961, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_26448637_26448992_0": {"section_id": 8726, "quality": 0.6666666666666666, "length": 4}, "so_26448637_26448637_0": {"section_id": 8726, "quality": 0.6666666666666666, "length": 4}}}, "26448854": {"ParentId": "26448637", "CommentCount": "9", "Body": "<p>upper and lower boundaries depends on compilers implementation of floating point numbers. So its not just an user defined limit. rather its the mathematical constraint that depends on the memory layout as designed by the compiler for storing floating point numbers.</p>\n<p>If you want an <code>user-defined limit</code> you may use your custom integer class that overloads operators for numeric operations and applies your user defined limit before any operation.</p>\n", "OwnerUserId": "256007", "PostTypeId": "2", "Id": "26448854", "Score": "3", "CreationDate": "2014-10-19T08:44:05.230", "LastActivityDate": "2014-10-19T08:44:05.230"}});