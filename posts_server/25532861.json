post_cb({"bq_ids": {"n4140": {"so_25532861_25533333_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 91}}, "n3337": {"so_25532861_25533333_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 86}}}, "25532861": {"FavoriteCount": "1", "ViewCount": "65", "Id": "25532861", "AcceptedAnswerId": "25533333", "Score": "3", "Title": "Template instantiation does not \"do inheritance\"", "LastEditorUserId": "-1", "CommentCount": "0", "Body": "<p>The title is quoted from this SO <a href=\"https://stackoverflow.com/a/10707822/862351\">answer</a>. It is discussing using SFINAE to detect the existence of a member function with the given signature and points out a failing of the method in the accepted answer when dealing with inherited member functions. In particular, the explanation given is as follows</p>\n<blockquote>\n<p id=\"so_25532861_25532861_0\">If you are not already wise to this gotcha, then a look at of the definition of <code>std::shared_ptr&lt;T&gt;</code> in the header  will shed light. In that implementation, <code>std::shared_ptr&lt;T&gt;</code> is derived from a base class from which it inherits <code>operator*() const</code>. So the template instantiation <code>SFINAE&lt;U, &amp;U::operator*&gt;</code> that constitutes \"finding\" the operator for <code>U = std::shared_ptr&lt;T&gt;</code> will not happen, because <code>std::shared_ptr&lt;T&gt;</code> has no <code>operator*()</code> in its own right and template instantiation does not \"do inheritance\".</p>\n<p id=\"so_25532861_25532861_1\">This snag does not affect the well-known SFINAE approach, using \"The sizeof() Trick\", for detecting merely whether T has some member function mf (see e.g. this answer and comments).</p>\n</blockquote>\n<p>Using the terminology from the answer, what is the difference between using <code>T::mf</code> as a template argument to instantiate a type vs having the compiler determine it through a template function argument deduction? What does \"template instantiation does not do inheritance\" mean? And lastly, why doesn't this affect simply checking for existence of a member, like <a href=\"https://stackoverflow.com/a/257382/862351\">here</a>?</p>\n", "Tags": "<c++><templates><inheritance>", "CreationDate": "2014-08-27T16:53:48.723", "LastEditDate": "2017-05-23T12:13:23.197", "LastActivityDate": "2014-08-27T17:20:25.187", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "862351"}, "25533333": {"CommentCount": "0", "Body": "<p>Minimized example:</p>\n<pre><code>struct A {\n    void a() const;\n};\n\nstruct B : A {};\n\ntemplate&lt;typename U, void (U::*)() const&gt; struct SFINAE {};\ntemplate&lt;typename U&gt; void Test(SFINAE&lt;U, &amp;U::a&gt;*) { }\n\nint main(void)\n{\n    Test&lt;B&gt;(0); // doesn't compile\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/80cb9f00c36f3c30\" rel=\"nofollow\">Demo</a>.</p>\n<p>The problem is that when <code>B::a</code> is inherited from <code>A</code>, the type of <code>&amp;B::a</code> is actually \"pointer to member of <code>A</code>\" - and, while normally a pointer-to-member-of-base can be implicitly converted to pointer-to-member-of-derived, this conversion doesn't apply for non-type template arguments, per \u00a714.3.2 [temp.arg.nontype]/p5:</p>\n<blockquote>\n<p id=\"so_25532861_25533333_0\">The following conversions are performed on each expression used as a\n  non-type <em>template-argument</em>. If a non-type template-argument cannot\n  be converted to the type of the corresponding <em>template-parameter</em>\n  then the program is ill-formed.</p>\n<ul>\n<li>[...]</li>\n<li>For a non-type <em>template-parameter</em> of type pointer to member function,\n  if the template-argument is of type <code>std::nullptr_t</code>, the\n  null member pointer conversion (4.11) is applied; otherwise, no\n  conversions apply. If the <em>template-argument</em> represents a set of\n  overloaded member functions, the matching member function is selected\n  from the set (13.4).</li>\n</ul>\n</blockquote>\n", "CreationDate": "2014-08-27T17:20:25.187", "ParentId": "25532861", "Id": "25533333", "LastActivityDate": "2014-08-27T17:20:25.187", "PostTypeId": "2", "Score": "3", "OwnerUserId": "2756719"}});