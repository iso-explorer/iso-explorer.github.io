post_cb({"26682375": {"ParentId": "26681920", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-10-31T19:49:01.660", "Score": "4", "LastEditorUserId": "1774667", "LastEditDate": "2014-10-31T19:54:10.697", "Id": "26682375", "OwnerUserId": "1774667", "Body": "<p>The comma operator is not the same as the comma expression separator.</p>\n<p>The comma operator takes two expressions, evaluates the left hand side, discards it, evaluates the right hand side, and returns the result.</p>\n<p>The expression separator is used when you have a list of expressions, like a function call or initializer list.</p>\n<p><code>decltype(a,b,c)</code> is <code>decltype(</code> expression <code>)</code>, not <code>decltype(</code> expression-list <code>)</code>.  Which means that the <code>,</code> in your <code>decltype</code> is operator comma. </p>\n<p>In general, <code>...</code> expansion only works when the grammar allows a list of expressions.  The <code>,</code> \"generated\" is the expression separator, not the comma operator.</p>\n<p>I am not aware of a way you can emulate the behavior of the <code>,</code> operator, including execution order, using <code>...</code>.  If you don't care what order they are evaluated in, you can do:</p>\n<pre><code>template&lt;class T, class... Ts&gt;\nstruct last_type_helper{using type=T;};\ntemplate&lt;class T0, class T1, class... Ts&gt;\nstruct last_type_helper&lt;T0, T1, Ts...&gt;:last_type_helper&lt;T1, Ts...&gt;{}\ntemplate&lt;class... Ts&gt;\nusing last_type=typename last_type_helper&lt;Ts...&gt;::type;\n\ntemplate&lt;class T0&gt;\nT0&amp;&amp; last_expression( T0&amp;&amp; t0 ) { return std::forward&lt;T0&gt;(t0); }\ntemplate&lt;class T0, class...Ts&gt;\nauto last_expression( T0&amp;&amp; t0, Ts&amp;&amp;...ts )-&gt;last_type&lt;T0, Ts...&gt;&amp;&amp; {\n  return last_expression( std::forward&lt;Ts&gt;(ts)... );\n}\n</code></pre>\n<p>then</p>\n<pre><code>template&lt;class...Args&gt;\nauto g(Args&amp;&amp;...args) -&gt; decltype(last_expression(args...));\n</code></pre>\n<p>works, as does</p>\n<pre><code>template&lt;class...Args&gt;\nauto g(Args&amp;&amp;...args) -&gt; last_type&lt;Args...&gt;;\n</code></pre>\n<p>which puts the cart after the horse, no?</p>\n", "LastActivityDate": "2014-10-31T19:54:10.697"}, "26681920": {"CommentCount": "1", "ViewCount": "117", "PostTypeId": "1", "LastEditorUserId": "1774667", "CreationDate": "2014-10-31T19:16:44.717", "LastActivityDate": "2015-08-21T14:17:57.983", "Title": "Why does a pack expansion inside an unevaluated operand result in the last element?", "AcceptedAnswerId": "26682069", "LastEditDate": "2015-08-21T14:17:57.983", "Id": "26681920", "Score": "3", "Body": "<p>I can do this inside <code>decltype()</code>:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>auto g() -&gt; decltype(1, \"\", true, new int);\n</code></pre>\n<p>But not this:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template &lt;class... Args&gt;\nauto g(Args&amp;&amp;... args) -&gt; decltype(args...);\n</code></pre>\n<p>It fails because a pack expansion appears inside <code>decltype()</code> but I thought a pack expansion would result in a comma separated list of arguments. So the return type of <code>g(a, b, c)</code> would be <code>decltype(c)</code> because of how the comma operator works (it returns the last element). It works when you expand inside a function parameter list, template parameter list, initializer list, etc. But why here is this not the case?</p>\n", "Tags": "<c++><templates><c++11><variadic-templates><comma-operator>", "OwnerUserId": "1594090", "AnswerCount": "2"}, "26682069": {"ParentId": "26681920", "CommentCount": "0", "CreationDate": "2014-10-31T19:27:59.397", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "26682069", "Score": "5", "Body": "<p>Parameter packs are only expanded under certain circumstances. You can find them in the standard by searching for \"pack expansion\". For example,</p>\n<blockquote>\n<p id=\"so_26681920_26682069_0\">A function parameter pack is a pack expansion (14.5.3).</p>\n</blockquote>\n<p>(8.3.5/14).</p>\n<p>Unless it is explicitly specified somewhere that a pack expansion occurs in a particular context, it doesn't happen, and is usually forbidden by the grammar (<em>i.e.</em>, syntactically incorrect). For example, <code>decltype</code> requires an <em>expression</em> as its operand. <code>1, \"\", true, new int</code> is indeed an expression (the <code>,</code> is the comma operator) but <code>args...</code> is not an expression. However, <code>args...</code> is an <em>expression-list</em>, so it may be used, <em>e.g.</em>, in a function call.</p>\n", "LastActivityDate": "2014-10-31T19:27:59.397"}, "bq_ids": {"n4140": {"so_26681920_26682069_0": {"section_id": 121, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_26681920_26682069_0": {"section_id": 116, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_26681920_26682069_0": {"section_id": 125, "quality": 0.8333333333333334, "length": 5}}}});