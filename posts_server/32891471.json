post_cb({"32891471": {"CreationDate": "2015-10-01T15:31:44.653", "AcceptedAnswerId": "32892167", "Tags": "<c++><c++11><g++><clang><language-lawyer>", "Id": "32891471", "OwnerUserId": "673852", "Body": "<p>Consider the following code:</p>\n<pre><code>template&lt;int N&gt;\nclass Vector\n{\n};\n\n#include &lt;array&gt;\n\ntemplate&lt;int N&gt;\nvoid doWork(const Vector&lt;N&gt;&amp;, const std::array&lt;int,N&gt;&amp;)\n{\n}\n\nint main()\n{\n    std::array&lt;int,3&gt; arr;\n    Vector&lt;3&gt; vec;\n    doWork(vec,arr);\n}\n</code></pre>\n<p>Here <code>Vector</code> represents a class which is defined in a third-party library, and <code>std::array</code> is known to take its element count as <code>std::size_t</code>.</p>\n<p>I've tried compiling this with clang-3.6 and g++-5.1. Clang worked without any complaint, while g++ gives the following error:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:17:19: error: no matching function for call to \u2018doWork(Vector&lt;3&gt;&amp;, std::array&lt;int, 3ul&gt;&amp;)\u2019\n     doWork(vec,arr);\n                   ^\ntest.cpp:9:6: note: candidate: template&lt;int N&gt; void doWork(const Vector&lt;N&gt;&amp;, const std::array&lt;int, N&gt;&amp;)\n void doWork(const Vector&lt;N&gt;&amp;, const std::array&lt;int,N&gt;&amp;)\n      ^\ntest.cpp:9:6: note:   template argument deduction/substitution failed:\ntest.cpp:17:19: note:   mismatched types \u2018int\u2019 and \u2018long unsigned int\u2019\n     doWork(vec,arr);\n                   ^\ntest.cpp:17:19: note:   \u2018std::array&lt;int, 3ul&gt;\u2019 is not derived from \u2018const std::array&lt;int, N&gt;\u2019\n</code></pre>\n<p>I can work around this by doing a cast of <code>N</code> to <code>std::size_t</code> in second parameter of <code>doWork()</code> or calling <code>doWork&lt;3&gt;()</code>, but this wouldn't educate me.</p>\n<p>So I rather ask first: which compiler is right here? Am I really doing something wrong in the code (so clang is too permissive), or is it indeed valid C++ (so that g++ has a bug)?</p>\n", "CommentCount": "0", "PostTypeId": "1", "ViewCount": "326", "FavoriteCount": "1", "LastActivityDate": "2015-10-02T16:00:34.947", "LastEditorUserId": "1708801", "Title": "Template argument deduction: which compiler is right here?", "AnswerCount": "1", "Score": "9", "LastEditDate": "2015-10-01T16:09:57.927"}, "bq_ids": {"n3337": {"so_32891471_32892167_0": {"section_id": 338, "quality": 0.9285714285714286, "length": 26}}}, "32892167": {"CreationDate": "2015-10-01T16:09:38.437", "LastActivityDate": "2015-10-02T16:00:34.947", "LastEditorUserId": "1708801", "ParentId": "32891471", "Id": "32892167", "Score": "4", "Body": "<p>I believe gcc is correct here, if we go to the draft C++11 standard section <code>14.8.2.5</code> <em>[temp.deduct.type]</em> it says:</p>\n<blockquote>\n<p id=\"so_32891471_32892167_0\">If, in the declaration of a function template with a non-type\n  template-parameter, the non-type templateparameter is used in an\n  expression in the function parameter-list and, if the corresponding\n  template-argument is deduced, the template-argument type shall match\n  the type of the template-parameter exactly, except that a\n  template-argument deduced from an array bound may be of any integral\n  type.144 [ Example:</p>\n<pre><code>template&lt;int i&gt; class A { /* ... */ };\ntemplate&lt;short s&gt; void f(A&lt;s&gt;);\nvoid k1() {\nA&lt;1&gt; a;\nf(a); // error: deduction fails for conversion from int to short\nf&lt;1&gt;(a); // OK\n}\n</code></pre>\n<p id=\"so_32891471_32892167_1\">[...]</p>\n</blockquote>\n<p>and we can see if we change your code to this:</p>\n<pre><code>doWork&lt;3&gt;(vec,arr);\n</code></pre>\n<p>gcc does not issue an error and neither does clang.</p>\n<p>If we try this example:</p>\n<pre><code>template&lt;int N&gt;\nvoid doWorkB( std::array&lt;int,N&gt;&amp;)\n{\n}\n\n//...\n\ndoWorkB(arr);\n</code></pre>\n<p>clang now produces an error (<em><a href=\"http://melpon.org/wandbox/permlink/aOQcOilDY9K5m46X\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>note: candidate template ignored: substitution failure : deduced non-type template argument does not have the same type as the its corresponding template parameter ('unsigned long' vs 'int')\nvoid doWorkB( std::array&lt;int,N&gt;&amp;)\n     ^\n</code></pre>\n<p>Your original case also breaks in clang if we swap the parameter order:</p>\n<pre><code>void doWork( const std::array&lt;int,N&gt;&amp;, const Vector&lt;N&gt;&amp; )\n</code></pre>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1708801", "LastEditDate": "2015-10-02T16:00:34.947"}});