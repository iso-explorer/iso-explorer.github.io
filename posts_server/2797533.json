post_cb({"bq_ids": {"n4140": {"so_2797533_2797727_1": {"length": 101, "quality": 0.9901960784313726, "section_id": 269}, "so_2797533_2797727_0": {"length": 29, "quality": 1.0, "section_id": 268}}, "n3337": {"so_2797533_2797727_1": {"length": 101, "quality": 0.9901960784313726, "section_id": 260}, "so_2797533_2797727_0": {"length": 29, "quality": 1.0, "section_id": 259}}, "n4659": {"so_2797533_2797727_1": {"length": 101, "quality": 0.9901960784313726, "section_id": 276}, "so_2797533_2797727_0": {"length": 29, "quality": 1.0, "section_id": 275}}}, "2797564": {"Id": "2797564", "PostTypeId": "2", "Body": "<p>Thats pretty neat. I'm not sure if it is guaranteed to work everywhere though. It looks like what they're doing is having a deliberately undefined template method, and then defining a specialization tucked away in its own translation unit. They're depending on the compiler using the same name mangling for both the original class template method and the specialization, which is the bit I think is probably non-standard. The linker will then look for the method of the class template, but instead find the specialization.</p>\n<p>There are a few risks with this though. No one, not even the linker, will pick up multiple implementations of the method for example. The template methods will be marked selectany because template implies inline so if the linker sees multiple instances, instead of issuing an error it will pick whichever one is most convenient.</p>\n<p>Still a nice trick though, although unfortunately it does seem to be a lucky coincidence that it works.</p>\n", "LastActivityDate": "2010-05-09T12:01:45.647", "CommentCount": "1", "CreationDate": "2010-05-09T12:01:45.647", "ParentId": "2797533", "Score": "5", "OwnerUserId": "297809"}, "2797727": {"Id": "2797727", "PostTypeId": "2", "Body": "<p>Like @Steward suspected, it's not valid. Formally it's <em>effectively</em> causing undefined behavior, because the Standard rules that for a violation no diagnostic is required, which means the implementation can silently do anything it wants. At <code>14.7.3/6</code></p>\n<blockquote>\n<p id=\"so_2797533_2797727_0\">If a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. </p>\n</blockquote>\n<p>In practice at least on GCC, it's implicitly instantiating the primary template <code>Interface&lt;T&gt;</code> since the specialization wasn't declared and is not visible in <code>main</code>, and then calling <code>Interface&lt;T&gt;::foo</code>. If its definition is visible, it instatiates the primary definition of the member function (which is why when it is defined, it wouldn't work). </p>\n<p>Instantiated function name symbols have weak linkage because they could possibly be present multiple times in different object files, and have to be merged into one symbol in the final program. Contrary, members of explicit specializations that aren't templates anymore have strong linkage so they will dominate weak linkage symbols and make the call end up in the specialization. All this is implementation detail, and the Standard has no such notion of weak/strong linkage. You have to declare the specialization prior to creating the <code>special</code> object:</p>\n<pre><code>template &lt;&gt;\nstruct Interface&lt;Special&gt;;\n</code></pre>\n<p>The Standard lays it bare (emphasize by me)</p>\n<blockquote>\n<p id=\"so_2797533_2797727_1\">The placement of explicit specialization declarations for function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member class templates of class templates, member function templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, member function templates of member classes of class templates, etc., and the placement of partial specialization declarations of class templates, member class templates of non-template classes, member class templates of class templates, etc., can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below. <em>When writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation.</em></p>\n</blockquote>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-05-09T13:25:22.093", "Score": "10", "CreationDate": "2010-05-09T13:20:14.837", "ParentId": "2797533", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2010-05-09T13:25:22.093"}, "2797533": {"ViewCount": "937", "Body": "<p>A colleague of mine told me about a little piece of design he has used with his team that sent my mind boiling. It's a kind of <em>traits</em> class that they can specialize in an extremely decoupled way.</p>\n<p>I've had a hard time understanding how it could possibly work, and I am still unsure of the idea I have, so I thought I would ask for help here.</p>\n<p>We are talking g++ here, specifically the versions 3.4.2 and 4.3.2 (it seems to work with both).</p>\n<p>The idea is quite simple:</p>\n<p>1- Define the interface</p>\n<pre><code>// interface.h\ntemplate &lt;class T&gt;\nstruct Interface\n{\n  void foo(); // the method is not implemented, it could not work if it was\n};\n\n//\n// I do not think it is necessary\n// but they prefer free-standing methods with templates\n// because of the automatic argument deduction\n//\ntemplate &lt;class T&gt;\nvoid foo(Interface&lt;T&gt;&amp; interface) { interface.foo(); }\n</code></pre>\n<p>2- Define a class, and in the source file specialize the interface for this class (defining its methods)</p>\n<pre><code>// special.h\n\nclass Special {};\n\n\n// special.cpp\n\n#include \"interface.h\"\n#include \"special.h\"\n\n// \n// Note that this specialization is not visible outside of this translation unit\n//\ntemplate &lt;&gt;\nstruct Interface&lt;Special&gt;\n{\n  void foo() { std::cout &lt;&lt; \"Special\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>3- To use, it's simple too:</p>\n<pre><code>// main.cpp\n\n#include \"interface.h\"\n\nclass Special; // yes, it only costs a forward declaration\n               // which helps much in term of dependencies\n\nint main(int argc, char* argv[])\n{\n  Interface&lt;Special&gt; special;\n  foo(special);\n  return 0;\n};\n</code></pre>\n<p>It's an undefined symbol if no translation unit defined a specialization of <code>Interface</code> for <code>Special</code>.</p>\n<p>Now, I would have thought this would require the <code>export</code> keyword, which to my knowledge has never been implemented in g++ (and only implemented once in a C++ compiler, with its authors advising anyone not to, given the time and effort it took them).</p>\n<p>I suspect it's got something to do with the linker resolving the templates methods...</p>\n<ul>\n<li>Do you have ever met anything like this before ?</li>\n<li>Does it conform to the standard or do you think it's a fortunate coincidence it works ?</li>\n</ul>\n<p>I must admit I am quite puzzled by the construct...</p>\n", "AcceptedAnswerId": "2797727", "Title": "Undefined template methods trick?", "CreationDate": "2010-05-09T11:49:18.637", "Id": "2797533", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2010-05-09T12:27:08.750", "LastEditorUserId": "168225", "LastActivityDate": "2010-05-09T13:25:22.093", "Score": "13", "OwnerUserId": "147192", "Tags": "<c++><templates><g++><traits>", "AnswerCount": "2"}});