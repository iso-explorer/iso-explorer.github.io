post_cb({"20603750": {"ParentId": "20603335", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>For <code>v.emplace_back({41,42});</code>, see <a href=\"https://stackoverflow.com/q/20391632/1619294\">how to use std::vector::emplace_back for vector&lt;vector&lt;int&gt; &gt;?</a></p>\n<hr>\n<p><code>v.emplace_back(41,42);</code> does not work because of some rules in the standard (some emphasis mine):</p>\n<blockquote>\n<p id=\"so_20603335_20603750_0\">Table 101 \u2014 Optional sequence container operations</p>\n<p id=\"so_20603335_20603750_1\"><strong>Expression:</strong> <code>a.emplace_back(args)</code></p>\n<p id=\"so_20603335_20603750_2\"><strong>Return type:</strong> <code>void</code></p>\n<p id=\"so_20603335_20603750_3\"><strong>Operational semantics:</strong><br/>\n  Appends an object of type <code>T</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>.<br/><br/>\n<em>Requires:</em> T shall be <strong><em>EmplaceConstructible</em></strong> into <code>X</code> from <code>args</code>. For <code>vector</code>, T shall also be MoveInsertable into X.</p>\n</blockquote>\n<p>For a type to be <em><code>EmplaceConstructible</code></em>,</p>\n<blockquote>\n<p id=\"so_20603335_20603750_4\">\u00a7 23.2.1.13</p>\n<p id=\"so_20603335_20603750_5\">\u2014 T is <em>EmplaceConstructible</em> into <em>X</em> from args, for zero or more arguments args, means that the following expression is well-formed:</p>\n<p id=\"so_20603335_20603750_6\"><code>allocator_traits&lt;A&gt;::construct(m, p, args);</code></p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/memory/allocator_traits/construct\" rel=\"nofollow noreferrer\"><code>std::allocator_traits::construct()</code></a> in turn does (if possible) <code>a.construct(p, std::forward&lt;Args&gt;(args)...)</code> (where <code>a</code> is <code>m</code> in the <em>EmplaceConstructible</em> expression).</p>\n<p><code>a.construct()</code> here is <a href=\"http://en.cppreference.com/w/cpp/memory/allocator/construct\" rel=\"nofollow noreferrer\"><code>std::allocator::construct()</code></a>, which calls <code>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</code>. <strong>This is what causes the compile error.</strong></p>\n<p><code>U(std::forward&lt;Args&gt;(args)...)</code> (take note of the use of <strong>direct initialization</strong>) will find a constructor of <code>U</code> which accepts the forwarded arguments. However, in your case, <code>my_pair</code> is an aggregate type, which can only be initialized with braced-initialization syntax (aggregate initialization).</p>\n<hr>\n<p><code>v.emplace_back(my_pair{41,42});</code> works because it calls either the implicitly generated default copy constructor or move constructor (note that these two may not always be generated). A temporary <code>my_pair</code> is first constructed which goes through the same process as that of <code>v.emplace_back(41,42);</code>, only that the argument is an r-value <code>my_pair</code>.</p>\n<hr>\n<p><strong>ADDITIONAL 1:</strong> </p>\n<blockquote>\n<p id=\"so_20603335_20603750_7\">And why does push_back(T&amp;&amp;) work without addition of the struct's name?</p>\n</blockquote>\n<p>It's because of <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow noreferrer\"><code>push_back</code>'s signatures</a>. <code>push_back()</code>'s argument isn't deduced, which means by doing <code>push_back({1, 2})</code>, a temporary object with the type of the vector's element type is first created and initialized with <code>{1, 2}</code>. That temporary object will then be the one that is passed to <code>push_back(T&amp;&amp;)</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_20603335_20603750_8\">Should I just stick with push_back? Is there any reason to use emplace_back(structname{1,2,3}) instead of push_back({1,2,3}) because it will end up calling push_back(T&amp;&amp;) anyway, and is easier to type?</p>\n</blockquote>\n<p>Basically, <code>emplace*</code> functions is meant to optimize and remove the cost of creating temporaries and copying or move constructing objects when inserting them. However, for the case of aggregate data types where doing something like <code>emplace_back(1, 2, 3)</code> isn't possible, and the only way you could insert them is through creating a temporary then copying or moving, then by all means prefer the leaner syntax, and go for <code>push_back({1,2,3})</code>, where it would basically have the same performance as that of <code>emplace_back(structname{1,2,3})</code>.</p>\n</hr></hr></hr></hr>", "OwnerUserId": "1619294", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:38.363", "Id": "20603750", "Score": "8", "CreationDate": "2013-12-16T04:57:37.557", "LastActivityDate": "2013-12-16T05:15:36.097"}, "20603335": {"CommentCount": "1", "AcceptedAnswerId": "20603750", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-12-16T04:10:01.893", "LastActivityDate": "2013-12-16T05:15:36.097", "LastEditDate": "2017-05-23T12:17:39.967", "ViewCount": "4207", "FavoriteCount": "6", "Title": "c++11 emplace_back and push_back syntax with struct", "Id": "20603335", "Score": "14", "Body": "<p>I'm using MSVC, Visual Studio 2013.</p>\n<p>Suppose I have a struct:</p>\n<pre><code>struct my_pair {\n    int foo, bar;\n};\n</code></pre>\n<p>And I want to add a bunch of these efficiently, without too creating a temporary and then discarding it:</p>\n<pre><code>vector&lt;my_pair&gt; v;\nv.push_back(41, 42); // does not work              [a]\nv.push_back({41,42}); // works                     [b]\nv.emplace_back(41,42); // does not work            [c]\nv.emplace_back({41,42}); // does not work          [d]\nv.emplace_back(my_pair{41,42}); //works            [e]\n</code></pre>\n<p>Now if I add a constructor and copy constructor to my code:</p>\n<pre><code>my_pair(int foo_, int bar_) : foo(foo_), bar(bar_) \n{\n    cout &lt;&lt; \"in cstor\" &lt;&lt; endl;\n}\nmy_pair(const my_pair&amp; copy) : foo(copy.foo), bar(copy.bar)\n{\n    cout &lt;&lt; \"in copy cstor\" &lt;&lt; endl;\n}\n</code></pre>\n<p>Then the behavior changes:</p>\n<pre><code>v.push_back(41, 42); // does not work                              [f]\nv.push_back({41,42}); // displays \"in cstor\" and \"in copy cstor\"   [g]\nv.emplace_back(41,42); // displays \"in cstor\"                      [h]\nv.emplace_back({41,42}); // does not work                          [i]\nv.emplace_back(my_pair{41,42}); // \"in cstor\" and \"in copy cstor\"  [j]\n</code></pre>\n<p>If I add a move constructor:</p>\n<pre><code>my_pair(my_pair&amp;&amp; move_) : foo(move_.foo), bar(move_.bar)\n{\n    cout &lt;&lt; \"in move cstor\" &lt;&lt; endl;\n}\n</code></pre>\n<p>Then:</p>\n<pre><code>v.emplace_back(my_pair{41,42}); //displays \"in cstor\", \"in move cstor\"   [k]\nv.emplace_back({41,42}); // still does not work                          [l]\nv.push_back({41,42}); // displays \"in cstor\", \"in move cstor\"            [m]\n</code></pre>\n<p><strong>Questions:</strong> <br>\nfor <strong>[a,b]</strong> I understand the reason for working and not working.<br>\nfor <strong>[c]</strong>, it doesn't work because there is no constructor to forward the arguments to. <br>\nfor <strong>[d]</strong>, why doesn't this work like in the push case? <br>\nfor <strong>[e]</strong>, why does it work when the class name is added? <br>\nfor <strong>[h]</strong>, it seems like this is the most efficient code if there is a constructor that maps the arguments to the members <br>\nfor <strong>[j]</strong>, it seems like this is as bad as a push_back and with extra typing I'm not sure why anyone should do this over push_back <br>\nfor <strong>[k,m]</strong>, with the addition of a move constructor it seems like <code>push_back(T&amp;&amp;)</code> is being called which results in the same performance as emplace. But again, with the extra typing I'm not sure why anyone would do this.</br></br></br></br></br></br></br></p>\n<p>I read that MSVC doesn't add a move constructor for you:\n<a href=\"https://stackoverflow.com/questions/20595079/why-is-copy-constructor-called-in-call-to-stdvectoremplace-back\">Why is copy constructor called in call to std::vector::emplace_back()?</a></p>\n<p>What is the difference between <strong>[d,e]</strong> and why is emplace picky about it. And why does <code>push_back(T&amp;&amp;)</code> work without addition of the struct's name?</p>\n<p>I can only get the full benefits of emplace if I know that there is a constructor that takes each member as argument?</p>\n<p>Should I just stick with <code>push_back</code>? Is there any reason to use <code>emplace_back(structname{1,2,3})</code> instead of <code>push_back({1,2,3})</code> because it will end up calling <code>push_back(T&amp;&amp;)</code> anyway, and is easier to type?</p>\n<p>Third, how does <code>emplace_back(arg1,arg2,etc)</code>, do its magic to avoid the copy or move constructor completely?</p>\n", "Tags": "<c++><c++11><rvalue-reference>", "OwnerUserId": "1459782", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20603335_20603750_5": {"section_id": 715, "quality": 1.0, "length": 11}, "so_20603335_20603750_3": {"section_id": 735, "quality": 0.8125, "length": 13}, "so_20603335_20603750_0": {"section_id": 735, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_20603335_20603750_5": {"section_id": 704, "quality": 1.0, "length": 11}, "so_20603335_20603750_3": {"section_id": 724, "quality": 0.8125, "length": 13}, "so_20603335_20603750_0": {"section_id": 724, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_20603335_20603750_5": {"section_id": 745, "quality": 1.0, "length": 11}, "so_20603335_20603750_3": {"section_id": 764, "quality": 0.75, "length": 12}, "so_20603335_20603750_0": {"section_id": 764, "quality": 0.6666666666666666, "length": 4}}}});