post_cb({"bq_ids": {"n4140": {"so_40188047_40188186_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 7107}}, "n3337": {"so_40188047_40188186_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 6851}}, "n4659": {"so_40188047_40188186_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 8608}}}, "40188857": {"Id": "40188857", "PostTypeId": "2", "Body": "<p>Unfortunately, I believe there is no easy way to determine whether a type is defined or not when it is being compiled,  mainly due to dumbness of C++ Preprocessor.</p>\n<p>Also, <code>__has_include</code> is not in current C++ standard AND, relying on <code>#if __has_include (&lt;boost/shared_ptr.hpp&gt;)</code> can't solve your problem, because you can't say that if <code>&lt;boost/shared_ptr.hpp&gt;</code> is included your code, then your compiler doesn't have <code>std::shared_ptr</code>.</p>\n<p>3 Possible solutions:</p>\n<ol>\n<li><p>if you wants to deal with newer standrad library with boost, consider using <code>&lt;boost/config.hpp&gt;</code>. For example, <code>BOOST_NO_CXX11_SMART_PTR</code> macro will help to determine whether std librry has shared_ptr or not</p></li>\n<li><p>You can implement your own macros to check whether a compiler support some library or not, by checking various compiler versions. However, it wont' be easy job due to compiler options. (ex. <code>-std=c++03</code> vs <code>-std=c++11</code> of gcc)</p></li>\n<li><p>Your toolchain probably can check your compiler's feature and pass it to the compiler using macro. See if <a href=\"https://github.com/quickfix/quickfix/blob/master/configure.ac\" rel=\"nofollow\">configure.ac</a> for autoconf, <a href=\"https://ceres-solver.googlesource.com/ceres-solver/+/master/cmake/FindSharedPtr.cmake\" rel=\"nofollow\">FindSharedPtr.cmake</a> for CMake.</p></li>\n</ol>\n", "LastActivityDate": "2016-10-22T06:00:09.120", "Score": "0", "CreationDate": "2016-10-22T06:00:09.120", "ParentId": "40188047", "CommentCount": "0", "OwnerUserId": "3627572"}, "40188186": {"Id": "40188186", "PostTypeId": "2", "Body": "<p>If you want to use Boost (or any other library) only if it is available, you have to use the preprocessor. C++17 comes with a handy <a href=\"http://en.cppreference.com/w/cpp/preprocessor/include\" rel=\"nofollow\"><code>__has_include</code></a> macro. You'd use it like the following:</p>\n<pre><code>#if __has_inlcude &lt;boost/shared_ptr.hpp&gt;\n\n#include &lt;boost/shared_ptr.hpp&gt;\ntemplate&lt;typename T&gt;\nusing ptr = boost::shared_ptr&lt;T&gt;;\n\n#else\n\n#include &lt;memory&gt;\ntemplate&lt;typename T&gt;\nusing ptr = std::shared_ptr&lt;T&gt;;\n\n#end\n</code></pre>\n<p>You could also use <code>#if defined(BOOST_VERSION)</code> to support older compilers, but this relies on specific boost headers being already included and is brittle (you risk <code>ptr</code> pointing to different things between translation units)</p>\n<hr>\n<p>Here's some standardese (from N4140):</p>\n<blockquote>\n<p id=\"so_40188047_40188186_0\">\u00a73.4.3 [basic.lookup.qual]/1:</p>\n<p id=\"so_40188047_40188186_1\">The name of a class or namespace member or enumerator can be referred\n  to after the <code>::</code> scope resolution operator applied to a\n  nested-name-specifier that denotes its class, namespace, or\n  enumeration. If a <code>::</code> scope resolution operator in a\n  nested-name-specifier is not preceded by a decltype-specifier, lookup\n  of the name preceding that :: considers only namespaces, types, and\n  templates whose specializations are types. <em>If the name found does not\n  designate a namespace or a class, enumeration, or dependent type, the\n  program is ill-formed.</em></p>\n</blockquote>\n</hr>", "LastEditorUserId": "2456565", "LastActivityDate": "2016-10-22T06:15:44.223", "Score": "1", "CreationDate": "2016-10-22T04:02:45.040", "ParentId": "40188047", "CommentCount": "21", "LastEditDate": "2016-10-22T06:15:44.223", "OwnerUserId": "2456565"}, "40188047": {"ViewCount": "102", "Body": "<p>I want to implement some functionality if a certain type is defined. The problem is that if the type doesn't exist, the compiler rejects the code as invalid. Something like a template based ifdef. This would be used in a library which doesn't know what the other code includes, and I want to implement functionality automagically if some library is also included. Maybe it's the wrong approach, but I want to know if this can be done without ifdefs with default behavior.</p>\n<pre><code>template &lt;typename=std::enable_if&lt;type_exists&lt;some_type&gt;&gt;::type&gt;\nvoid function() {\n   // code using some_type\n}\ntemplate &lt;&gt;\nvoid function() {\n   // code using other_type\n}\n</code></pre>\n<p>This code would choose the first function if some_type exists, and the second function if some_type is undefined. The code assumes other_type exists.</p>\n<p>Another use case would be something like this.</p>\n<pre><code>template &lt;typename T, typename=std::enable_if&lt;type_exists&lt;boost::shared_ptr&lt;T&gt;&gt;&gt;::type&gt;\nusing ptr = boost::shared_ptr&lt;T&gt;;\ntemplate &lt;typename T&gt;\nusing ptr = std::shared_ptr&lt;T&gt;;\n</code></pre>\n<p>To prefer boost pointers IF the user of the library included boost, otherwise fall back to std::shared_ptr.</p>\n", "Title": "template specialization based on a type's existance", "CreationDate": "2016-10-22T03:35:35.547", "LastActivityDate": "2016-10-22T06:15:44.223", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "Id": "40188047", "Score": "1", "OwnerUserId": "2306145", "Tags": "<c++><templates>", "AnswerCount": "2"}});