post_cb({"18648361": {"LastActivityDate": "2013-09-06T01:21:10.367", "LastEditorUserId": "1774667", "ParentId": "18648069", "LastEditDate": "2013-09-06T01:21:10.367", "Id": "18648361", "Score": "12", "Body": "<p>GCC is right.  However, there is a relatively simple workaround:</p>\n<pre><code>#include \"assert.h\"\n\ninline void assert_helper( bool test ) {\n  assert(test);\n}\ninline constexpr bool constexpr_assert( bool test ) {\n  return test?true:(assert_helper(test),false);\n}\n\ntemplate&lt;typename T&gt; constexpr\ninline T getClamped(const T&amp; mValue, const T&amp; mMin, const T&amp; mMax)\n{\n  return constexpr_assert(mMin &lt; mMax), (mValue &lt; mMin ? mMin : (mValue &gt; mMax ? mMax : mValue));\n}\n</code></pre>\n<p>where we abuse the comma operator, twice.</p>\n<p>The first time because we want to have an <code>assert</code> that, when <code>true</code>, can be called from a <code>constexpr</code> function.  The second, so we can chain two functions into a single <code>constexpr</code> function.</p>\n<p>As a side benefit, if the <code>constexpr_assert</code> expression cannot be verified to be <code>true</code> at compile time, then the <code>getClamped</code> function is not <code>constexpr</code>.</p>\n<p>The <code>assert_helper</code> exists because the contents of <code>assert</code> are implementation defined when <code>NDEBUG</code> is true, so we cannot embed it into an expression (it could be a statement, not an expression).  It also guarantees that a failed <code>constexpr_assert</code> fails to be <code>constexpr</code> even if <code>assert</code> is <code>constexpr</code> (say, when <code>NDEBUG</code> is false).</p>\n<p>A downside to all of this is that your assert fires not at the line where the problem occurs, but 2 calls deeper.</p>\n", "CommentCount": "17", "PostTypeId": "2", "OwnerUserId": "1774667", "CreationDate": "2013-09-06T01:13:55.540"}, "39905866": {"LastActivityDate": "2016-10-06T21:25:27.343", "ParentId": "18648069", "Id": "39905866", "Score": "3", "Body": "<p>constexpr calculates in compile time. Non static assert in run-time.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "6101270", "CreationDate": "2016-10-06T21:25:27.343"}, "18648132": {"LastActivityDate": "2013-09-06T00:51:31.390", "LastEditorUserId": "721269", "ParentId": "18648069", "LastEditDate": "2013-09-06T00:51:31.390", "Id": "18648132", "Score": "1", "Body": "<p>g++ is right. Per the standard, a non-static <code>assert</code> is not permitted in a <code>constexpr</code> statement.</p>\n<blockquote>\n<p id=\"so_18648069_18648132_0\">... its function-body shall be a compound-statement that contains only:<br>\n   \u00a0    null statements,<br>\n   \u00a0    static_assert-declarations,<br>\n   \u00a0    typedef declarations and alias-declarations that do not define classes or enumerations,<br>\n   \u00a0    using-declarations,<br>\n   \u00a0    using-directives,<br>\n   \u00a0    and exactly one return statement.<br>\n   \u00a0 \u00a0 \u00a0 -- 7.1.5/3</br></br></br></br></br></br></br></p>\n</blockquote>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "721269", "CreationDate": "2013-09-06T00:42:12.687"}, "bq_ids": {"n3337": {"so_18648069_18648132_0": {"section_id": 5214, "quality": 0.95, "length": 19}}}, "39905554": {"LastActivityDate": "2016-10-06T21:19:48.963", "LastEditorUserId": "1858225", "ParentId": "18648069", "LastEditDate": "2016-10-06T21:19:48.963", "Id": "39905554", "Score": "3", "Body": "<p>As of C++14, this is no longer an issue; <code>g++</code> with the <code>-std=c++14</code> flag compiles and runs your code just fine.</p>\n<p>There are three drawbacks:</p>\n<ul>\n<li>As noted in your question, this <strong>does not work</strong> in C++11.</li>\n<li>The <code>assert</code> will, of course, never by triggered at compile time. Even adding a <code>static_assert</code> with the same condition won't work, since <code>mMin</code> and <code>mMax</code> are not considered constant expressions.</li>\n<li>Moreover, because the <code>assert</code> isn't triggered at compile time, but the function is <code>constexpr</code>, if the condition is <em>false</em> but the expression <em>is</em> evaluated at compile time (e.g. <code>constexpr auto foo = getClamped(1,2,0);</code>), the <code>assert</code> will <strong>never</strong> fire--meaning that the incorrect function arguments will not be caught.</li>\n</ul>\n<p>In a comment, user oliora links to an <a href=\"http://ericniebler.com/2014/09/27/assert-and-constexpr-in-cxx11/\" rel=\"nofollow\">interesting blog post by Eric Niebler</a> that describes multiple approaches that work in C++11 <strong>and</strong> can be triggered while compiling or at runtime as appropriate.</p>\n<p>In short, the strategies are:</p>\n<ul>\n<li><code>throw</code> an exception; to make it uncatchable (i.e. more like an <code>assert</code>), mark the <code>constexpr</code> function <code>nothrow</code>\n<ul>\n<li>Niebler does not call this out in his post, but the <code>throw</code> expression <strong>must</strong> be wrapped in some kind of larger logical expression that is <em>only</em> evaluated if the condition being <code>assert</code>ed is <code>false</code>, such as a ternary expression (which is what Niebler uses in his example). A standalone <code>if (condition) throw &lt;exception&gt;;</code> statement will <strong>not</strong> be permitted, even in C++14.</li>\n<li>Niebler also fails to note that, unlike <code>assert</code>, this approach <strong>does not</strong> depend on <code>NDEBUG</code>; release builds <strong>will</strong> trigger failures and crash.</li>\n</ul></li>\n<li>Throw a <em>custom</em> expression type whose constructor invokes <code>std::quick_exit</code>. This eliminates the need for <code>nothrow</code>.\n\n<ul>\n<li>Again, this won't be compiled out for release builds (unless you wrap the <code>quick_exit</code> call in <code>ifdef</code>'s).</li>\n</ul></li>\n<li>Wrap an actual <code>assert</code> inside a lambda, which is passed to a struct that takes an arbitrary callable (as a template parameter) and invokes it and then calls <code>std::quick_exit</code>, and then <code>throw</code> that struct. This one seems like severe overkill, but of course it generates a true assertion-failure message at runtime, which is nice.\n\n<ul>\n<li>This is the only approach that <strong>will not</strong> cause a release build to crash.</li>\n<li>oliora provides a <a href=\"https://gist.github.com/oliora/928424f7675d58fadf49c70fdba70d2f\" rel=\"nofollow\">variation of this approach</a> without the <code>throw</code> and the <code>quick_exit</code>. This seems much cleaner and saner.</li>\n</ul></li>\n</ul>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1858225", "CreationDate": "2016-10-06T21:00:55.710"}, "18648069": {"AcceptedAnswerId": "18648361", "Tags": "<c++><c++11><g++><assert><constexpr>", "AnswerCount": "4", "OwnerUserId": "598696", "Body": "<pre><code>template&lt;typename T&gt; constexpr inline \nT getClamped(const T&amp; mValue, const T&amp; mMin, const T&amp; mMax) \n{ \n     assert(mMin &lt; mMax); // remove this line to successfully compile\n     return mValue &lt; mMin ? mMin : (mValue &gt; mMax ? mMax : mValue); \n}\n</code></pre>\n<blockquote>\n<p id=\"so_18648069_18648069_0\"><em>error</em>: <strong>body of constexpr function</strong> 'constexpr T getClamped(const T&amp;, const T&amp;, const T&amp;) [with T = long unsigned int]' <strong>not a return-statement</strong></p>\n</blockquote>\n<p>Using <code>g++ 4.8.1</code>. <code>clang++ 3.4</code> doesn't complain.</p>\n<p>Who is right here? Any way I can make <code>g++</code> compile the code without using macros?</p>\n", "CommentCount": "8", "CreationDate": "2013-09-06T00:32:31.040", "PostTypeId": "1", "FavoriteCount": "4", "LastActivityDate": "2016-10-06T21:25:27.343", "Id": "18648069", "Title": "g++ doesn't compile constexpr function with assert in it", "Score": "6", "ViewCount": "1241"}});