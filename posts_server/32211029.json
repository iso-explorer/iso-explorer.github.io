post_cb({"32287727": {"ParentId": "32211029", "CommentCount": "0", "Body": "<p>TLDR: if you only use lambda to convert it to a function pointer (and only invoke it via that function pointer), it is always profitable to omit the closure object. Optimizations which enable this are inlining and dead code elimination. If you do use the lambda itself, it is still possible to optimize the closure away, but requires somewhat more aggressive interprocedural optimization.</p>\n<p>I will now try to show how that works under the hood. I will use GCC in my examples, because I'm more familiar with it. Other compilers should do something similar.</p>\n<p>Consider this code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntypedef int (* fnptr_t)(int);\nvoid use_fnptr(fnptr_t fn)\n{\n    printf(\"fn=%p, fn(1)=%d\\n\", fn, fn(1));\n}\n\nint main()\n{\n    auto lam = [] (int x) { return x + 1; };\n    use_fnptr((fnptr_t)lam);\n}\n</code></pre>\n<p>Now, I compile it and dump intermediate representation (for versions prior to 6, you should add <code>-std=c++11</code>):</p>\n<pre><code>g++ test.cc -fdump-tree-ssa\n</code></pre>\n<p>A little cleaned-up and edited (for brevity) dump looks like this:</p>\n<pre><code>// _ZZ4mainENKUliE_clEi\nmain()::&lt;lambda(int)&gt; (const struct __lambda0 * const __closure, int x)\n{\n    return x_1(D) + 1;\n}\n\n// _ZZ4mainENUliE_4_FUNEi\nstatic int main()::&lt;lambda(int)&gt;::_FUN(int) (int D.2780)\n{\n    return main()::&lt;lambda(int)&gt;::operator() (0B, _2(D));\n}\n\n// _ZZ4mainENKUliE_cvPFiiEEv\nmain()::&lt;lambda(int)&gt;::operator int (*)(int)() const (const struct __lambda0 * const this)\n{\n    return _FUN;\n}\n\nint main() ()\n{\n    struct __lambda0 lam;\n    int (*&lt;T5c1&gt;) (int) _3;\n    _3 = main()::&lt;lambda(int)&gt;::operator int (*)(int) (&amp;lam);\n    use_fnptr (_3);\n}\n</code></pre>\n<p>That is, lambda has 2 member functions: function call operator and a conversion operator and one static member function _FUN, which simply invokes lambda with <code>this</code> set to zero. <code>main</code> calls the conversion operator and passes the result to use_fnptr - exactly as it is written in the source code.</p>\n<p>I can write:</p>\n<pre><code>extern \"C\" int _ZZ4mainENKUliE_clEi(void *, int);\n\nint main()\n{\n    auto lam = [] (int x) { return x + 1; };\n    use_fnptr((fnptr_t)lam);\n    printf(\"%d %d %d\\n\", lam(10), _ZZ4mainENKUliE_clEi(&amp;lam, 11), __lambda0::_FUN(12));\n    printf(\"%p %p\\n\", &amp;__lambda0::_FUN, (fnptr_t)lam);\n   return 0;\n}\n</code></pre>\n<p>This program outputs:</p>\n<pre><code>fn=0x4005fc, fn(1)=2\n11 12 13\n0x4005fc 0x4005fc\n</code></pre>\n<p>Now, I think it's pretty obvious, that the compiler should inline lambda (_ZZ4mainENKUliE_clEi) into <code>_FUN</code> (_ZZ4mainENUliE_4_FUNEi), because <code>_FUN</code> is the only caller. And inline <code>operator int (*)(int)</code> into <code>main</code> (because this operator simply returns a constant). GCC does exactly this, when compiling with optimization (-O). You can check this like:</p>\n<pre><code>g++ test.cc -O -fdump-tree-einline\n</code></pre>\n<p>Dump file:</p>\n<pre><code>// Considering inline candidate main()::&lt;lambda(int)&gt;.\n//   Inlining main()::&lt;lambda(int)&gt; into static int main():&lt;lambda(int)&gt;::_FUN(int).\n\nstatic int main()::&lt;lambda(int)&gt;::_FUN(int) (int D.2822)\n{\n    return _2(D) + 1;\n}\n</code></pre>\n<p>The closure object is gone. Now, a more complicated case, when lambda itself is used (not a function pointer). Consider:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n#define PRINT(x)    printf(\"%d\", (x))\n#define PRINT1(x)   PRINT(x); PRINT(x); PRINT(x); PRINT(x);\n#define PRINT2(x)   do { PRINT1(x) PRINT1(x) PRINT1(x) PRINT1(x) } while(0)\n\n__attribute__((noinline)) void use_lambda(auto t)\n{\n    t(1);\n}\n\nint main()\n{\n    auto lam = [] (int x) { PRINT2(x); };\n    use_lambda(lam);\n    return 0;\n}\n</code></pre>\n<p>GCC will not inline lambda, because it is rather huge (that is what I used printf's for):</p>\n<pre><code>g++ test2.cc -O2 -fdump-ipa-inline -fdump-tree-einline -fdump-tree-esra\n</code></pre>\n<p>Early inliner's dump:</p>\n<pre><code>Considering inline candidate main()::&lt;lambda(int)&gt;\n  will not early inline: void use_lambda(auto:1) [with auto:1 = main()::&lt;lambda(int)&gt;]/16-&gt;main()::&lt;lambda(int)&gt;/19, growth 46 exceeds --param early-inlining-insns\n</code></pre>\n<p>But \"early interprocedural scalar replacement of aggregates\" pass will do what we want:</p>\n<pre><code>;; Function main()::&lt;lambda(int)&gt; (_ZZ4mainENKUliE_clEi, funcdef_no=14, decl_uid=2815, cgraph_uid=12, symbol_order=12)\nIPA param adjustments: 0. base_index: 0 - __closure, base: __closure, remove_param\n  1. base_index: 1 - x, base: x, copy_param\n</code></pre>\n<p>The first parameter (i.e., closure) is not used, and it gets removed. Unfortunately interprocedural SRA is not able to optimize away indirection, which is introduced for captured values (though there are cases when it would be obviously profitable), so there is still some room for enhancements.</p>\n", "OwnerUserId": "4142343", "PostTypeId": "2", "Id": "32287727", "Score": "5", "CreationDate": "2015-08-29T15:34:34.573", "LastActivityDate": "2015-08-29T15:34:34.573"}, "32211148": {"ParentId": "32211029", "CommentCount": "2", "Body": "<p>From <em>Lambda expressions</em> \u00a75.1.2 p6 (draft N4140)</p>\n<blockquote>\n<p id=\"so_32211029_32211148_0\">The closure type for a non-generic lambda-expression with no lambda-capture has a public non-virtual non-\n  explicit const conversion function to pointer to function with C ++ language linkage having the same\n  parameter and return types as the closure type\u2019s function call operator.</p>\n</blockquote>\n", "OwnerUserId": "996886", "PostTypeId": "2", "Id": "32211148", "Score": "7", "CreationDate": "2015-08-25T18:11:47.320", "LastActivityDate": "2015-08-25T18:11:47.320"}, "32324451": {"ParentId": "32211029", "CommentCount": "0", "Body": "<p>To give another kind of insight, let have a look to the code produced by clang when compiling the following snippet:</p>\n<pre><code>int (*f) = []() { return 0; }\n</code></pre>\n<p>If you compile this with:</p>\n<pre><code>clang++ -std=c++11 -S -o- -emit-llvm a.cc\n</code></pre>\n<p>You get the following LLVM bytecode for the lambda definition:</p>\n<pre><code>define internal i32 @\"_ZNK3$_0clEv\"(%class.anon* %this) #0 align 2 {\n  %1 = alloca %class.anon*, align 8\n  store %class.anon* %this, %class.anon** %1, align 8\n  %2 = load %class.anon** %1\n  ret i32 0\n}\n\ndefine internal i32 @\"_ZN3$_08__invokeEv\"() #1 align 2 {\n  %1 = call i32 @\"_ZNK3$_0clEv\"(%class.anon* undef)\n  ret i32 %1\n}\n</code></pre>\n<p>The first function takes an instance of <code>%class.anon*</code> and return 0: that's the call operator. The second creates an instance of this class (<code>undef</code>) and then call its call operator and return the value.</p>\n<p>When compiled with <code>-O2</code>, the whole lambda is turned into:</p>\n<pre><code>define internal i32 @\"_ZN3$_08__invokeEv\"() #0 align 2 {\n  ret i32 0\n}\n</code></pre>\n<p>So that's a single function that returns 0.</p>\n<blockquote>\n<p id=\"so_32211029_32324451_0\">I mentioned that a lambda translates into a function object, or into a function if that's convenient</p>\n</blockquote>\n<p>That's exactly what clang does! It transforms the lambda into a function object, and when possible optimize it to a function.</p>\n", "OwnerUserId": "5272893", "PostTypeId": "2", "Id": "32324451", "Score": "1", "CreationDate": "2015-09-01T05:54:54.393", "LastActivityDate": "2015-09-01T05:54:54.393"}, "32211786": {"ParentId": "32211029", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard quote has already been posted, I want to add some examples.\nYou can assign lambdas to function pointers as long as there are no captured variables:</p>\n<p>Legal:</p>\n<pre><code>int (*f)(int) = [] (int x) { return x + 1; };  // assign lambda to function pointer\nint z = f(3);  // use the function pointer\n</code></pre>\n<p>Illegal:</p>\n<pre><code>int y = 5;\nint (*g)(int) = [y] (int x) { return x + y; };  // error\n</code></pre>\n<p>Legal:</p>\n<pre><code>int y = 5;\nint z = ([y] (int x) { return x + y; })(2);  // use lambda directly\n</code></pre>\n<hr>\n<p>(Edit)<br>\nSince we can not ask Bjarne what he meant exactly, I want to try a few interpretations.</br></p>\n<p><strong>\"translate\" meaning \"convert\"</strong><br>\nThis is what I understood initially, but it is clear now that the question is not about this possible meaning.</br></p>\n<p><strong>\"translate\" as used in the C++ standard</strong>, meaning \"compile\" (more or less)<br>\nAs Sebastian Redl already commented, there are no function objects on the binary level. There is just opcodes and data, and the standard does not talk about, or specify, any binary formats.</br></p>\n<p><strong>\"translate\" meaning \"being semantically equivalent\"</strong><br>\nThis would imply that if A and B are semantically equivalent, the produced binary code for A and B could be the same. The rest of my answer uses this interpretation.</br></p>\n<p>A <strong>closure</strong> consists of two parts:</p>\n<ul>\n<li>the statements in the lambda body, \"code\"</li>\n<li>the captured variable values or references, \"data\"</li>\n</ul>\n<p>This is equivalent to a functor, as already stated in the question.</p>\n<p><strong>Functors</strong> can be seen as a subset of objects, because they have code and data, but only one member function: the call operator. So closures could be seen as semantically equivalent to a restricted form of objects.</p>\n<p>A <strong>function</strong> on the other hand, has no data associated with it. There are the arguments of course, but these must be supplied by the caller and can change from one invocation to the other. This is a semantic difference to a closure, where the bound variables can not be changed and are not supplied by the caller.</p>\n<p>A member function is not something independent, as it can not work without its object, so I think the question refers to a freestanding function.</p>\n<p><strong>So no, a lambda is in general not semantically equivalent to a function.</strong></p>\n<p>There is the obvious special case of a lambda with no captured variables, where the functor consists only of the code, and this is equivalent to a function.</p>\n<p>But, a lambda could be said to be semantically equivalent to a <strong>set</strong> of functions. Each possible closure (distinct combination of values/references for the bound variables) would be equivalent to one function in that set.\nOf course this can only be useful when the bound variables can only have a very limited set of values / are references to only a few different variables, if at all.<br>\nFor example I see no reason why a compiler could not treat the following two snippets as (almost*) equivalent:</br></p>\n<pre><code>void Test(bool cond, int x)\n{\n    int y;\n    if(cond) y = 5;\n    else y = 3;\n    auto f = [y](int x) { return x + y; };\n    // more code that\n    // uses f\n}\n</code></pre>\n<p>A clever compiler could see that y can only have the values 5 or 3, and compile as if it would be written like this:</p>\n<pre><code>int F1(int x)\n{\n    return x + 5;\n}\n\nint F2(int x)\n{\n    return x + 3;\n}\n\nvoid Test(bool cond, int x)\n{\n    int (*f)(int);\n    if(cond) f = F1;\n    else f = F2;\n    // more code that\n    // uses f\n}\n</code></pre>\n<p>(*) Of course it depends on what <code>more code that uses f</code> does exactly.</p>\n<p>Another (maybe better) example would be a lambda that always binds the same  variable by reference. Then, there is only one possible closure, and so it is equivalent to a function, if the function has access to that variable by other means than by passing it as an argument.</p>\n<hr>\n<p>Another observation that might be helpful is that asking</p>\n<blockquote>\n<p id=\"so_32211029_32211786_0\">can this object [closure] be ommited and have a plain function instead? If yes,\n  then when and how?</p>\n</blockquote>\n<p>is more or less the same as asking when and how a member function can be used without the object. Since lambdas are functors, and functors are objects, the two questions are closely related.\nThe bound variables of the lambda correspond to the data members of the object, and the lambda body corresponds to the body of the member function.</p>\n</hr></hr>", "OwnerUserId": "3435400", "LastEditorUserId": "3435400", "LastEditDate": "2015-09-03T10:42:13.443", "Id": "32211786", "Score": "7", "CreationDate": "2015-08-25T18:48:52.443", "LastActivityDate": "2015-09-03T10:42:13.443"}, "32211029": {"CommentCount": "3", "AcceptedAnswerId": "32287727", "PostTypeId": "1", "LastEditorUserId": "2567683", "CreationDate": "2015-08-25T18:03:41.040", "LastActivityDate": "2015-09-03T10:42:13.443", "LastEditDate": "2015-08-28T16:50:06.813", "ViewCount": "596", "FavoriteCount": "2", "Title": "Can lambdas translate into functions?", "Id": "32211029", "Score": "14", "Body": "<p>Common knowledge dictated that lambda functions are functors under the hood. </p>\n<p>In <a href=\"https://www.youtube.com/watch?v=xcpSLRpOMJM\">this video</a> (@ about 45:43) Bjarne says:</p>\n<blockquote>\n<p id=\"so_32211029_32211029_0\">I mentioned that a lambda translates into a function object, or into a function if that's convenient</p>\n</blockquote>\n<p>I can see how this is a compiler optimization (ie it doesn't change the perception of lambdas as unnamed functors which means that eg lambdas still won't overload) but <strong>are there any rules that specify when this is applicable?</strong></p>\n<h2>Edit</h2>\n<p>The way I understand the term <strong>translate</strong> (and that's what I'm asking about) has nothing to do with conversion (I'm not asking whether lambdas are convertible to function ptr etc). By translate I mean \"compile lambda expressions into functions instead of function objects\".</p>\n<p>As <a href=\"http://en.cppreference.com/w/cpp/language/lambda\">mentioned in cppreference</a> : \n<em>The lambda expression constructs an unnamed prvalue temporary object of unique unnamed non-union non-aggregate type, known as closure type.</em> </p>\n<p>The question is : <strong>can this object be ommited and have a plain function instead? If yes, then when and how?</strong></p>\n<hr>\n<p><sup>Note: I imagine one such rule being \"don't capture anything\" but I can't find any reliable sources to confirm it</sup></p>\n</hr>", "Tags": "<c++><lambda><c++14>", "OwnerUserId": "2567683", "AnswerCount": "5"}, "32211207": {"ParentId": "32211029", "CommentCount": "4", "Body": "<p>No, it can't be done. Lambdas are defined to be functors, and I don't see the as-if rule helping here.</p>\n<blockquote>\n<p id=\"so_32211029_32211207_0\"><code>[C++14: 5.1.2/6]:</code> The closure type for a non-generic <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function with C++ language linkage (7.5) having the same parameter and return types as the closure type\u2019s function call operator. <em>[..]</em></p>\n</blockquote>\n<p>\u2026followed by similar wording for generic lambdas.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "32211207", "Score": "0", "CreationDate": "2015-08-25T18:14:45.707", "LastActivityDate": "2015-08-25T18:14:45.707"}, "bq_ids": {"n4140": {"so_32211029_32211148_0": {"section_id": 5965, "quality": 0.8888888888888888, "length": 24}, "so_32211029_32211207_0": {"section_id": 5965, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_32211029_32211148_0": {"section_id": 5734, "quality": 0.7777777777777778, "length": 21}, "so_32211029_32211207_0": {"section_id": 5734, "quality": 0.7857142857142857, "length": 22}}, "n4659": {"so_32211029_32211148_0": {"section_id": 7456, "quality": 0.7777777777777778, "length": 21}, "so_32211029_32211207_0": {"section_id": 7456, "quality": 0.75, "length": 21}}}});