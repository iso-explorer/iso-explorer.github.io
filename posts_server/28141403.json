post_cb({"bq_ids": {"n4140": {"so_28141403_28141551_3": {"length": 31, "quality": 0.8378378378378378, "section_id": 5971}, "so_28141403_28141551_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 5971}, "so_28141403_28141551_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 5965}, "so_28141403_28141551_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 5972}}, "n3337": {"so_28141403_28141551_3": {"length": 28, "quality": 0.7567567567567568, "section_id": 5739}, "so_28141403_28141551_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 5740}}, "n4659": {"so_28141403_28141551_3": {"length": 31, "quality": 0.8378378378378378, "section_id": 7470}, "so_28141403_28141551_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 7470}, "so_28141403_28141551_0": {"length": 25, "quality": 0.7575757575757576, "section_id": 7456}, "so_28141403_28141551_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 7471}}}, "28141471": {"Id": "28141471", "PostTypeId": "2", "Body": "<pre><code>int main() {\n    const int a = 2;\n    auto f = [&amp;](auto b) { std::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; std::endl; };\n    f(3);\n}\n</code></pre>\n<p>Don't know if it should work with <code>std::function</code> but this works for sure.</p>\n<p>Further investigation:</p>\n<p>I created a class to mimic as closely as possible the lambda:</p>\n<pre><code>class Functor {\nprivate:\n  int const x;\n\npublic:\n  Functor() : x{24} {}\n  auto operator()(int b) const -&gt; void { cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; }\n};\n\n\nstd::function&lt;auto(int)-&gt;void&gt; f2 = Functor{};\nf2(3); // &lt;- this works\n</code></pre>\n<p>This suggests that your example should have worked. After all lambdas are the same in behavior with an object who has the <code>operator()</code> overloaded and fields for the captured variables.</p>\n<p>If we change the class to get to the <code>auto</code> part:</p>\n<p>This doesn't work:</p>\n<pre><code>class Functor {\nprivate:\n  int const x;\n\npublic:\n  Functor() : x{24} {}\n  auto operator()(auto b) const -&gt; void { cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; }\n};\n\nstd::function&lt;auto(int)-&gt;void&gt; f2 = Functor{}; // &lt;-- doesn't work\n</code></pre>\n<p>However this works:</p>\n<pre><code>class Functor {\nprivate:\n  int const x;\n\npublic:\n  Functor() : x{24} {}\n  template &lt;class T&gt;\n  auto operator()(T b) const -&gt; void { cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; }\n};\n\nstd::function&lt;auto(int)-&gt;void&gt; f2 = Functor{}; // &lt;-- this works\n</code></pre>\n<p>So most likely it is related to the use of <code>auto</code> as parameter of lambda/functions, a feature new to C++14 so most likely without a mature implementation.</p>\n", "LastEditorUserId": "2805305", "LastActivityDate": "2015-01-25T21:20:14.717", "Score": "3", "CreationDate": "2015-01-25T21:01:51.937", "ParentId": "28141403", "CommentCount": "0", "OwnerUserId": "2805305", "LastEditDate": "2015-01-25T21:20:14.717"}, "28141551": {"Id": "28141551", "PostTypeId": "2", "Body": "<p>I can reproduce this unless I do any of the following:</p>\n<ul>\n<li>remove <code>const</code> from <code>a</code></li>\n<li>name <code>a</code> in the <em>capture-list</em></li>\n<li>change <code>std::function&lt;void(int)&gt;</code> to <code>auto</code></li>\n<li>make the lambda non-generic by changing <code>auto b</code> to <code>int b</code></li>\n<li>use Clang (e.g. v3.5.0)</li>\n</ul>\n<p>I believe that this is a compiler bug related to optimisations and a failure to detect <em>odr-use</em> in a generic lambda (though it's interesting that setting <code>-O0</code> has no effect). It could be related to <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61814\" rel=\"nofollow noreferrer\">bug 61814</a> but I don't think it's <em>quite</em> the same thing, therefore:</p>\n<p><strong>I have raised it as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64791\" rel=\"nofollow noreferrer\">GCC bug 64791</a>.</strong></p>\n<ul>\n<li><em>(Update: this bug has since been marked as fixed in GCC 5.0.)</em></li>\n</ul>\n<p>Certainly I can't find anything obvious in the C++14 wording that should disallow your code, though there's very little \"obvious\" in general in the new C++14 wording. :(</p>\n<hr>\n<blockquote>\n<p id=\"so_28141403_28141551_0\"><code>[C++14: 5.1.2/6]:</code> <em>[..]</em> For a generic lambda with no lambda-capture, the closure type has a public non-virtual non-explicit const conversion function template to pointer to function. The conversion function template has the same invented <em>template-parameter-list</em>, and the pointer to function has the same parameter types, as the function call operator template. <em>[..]</em></p>\n<p id=\"so_28141403_28141551_1\"><code>[C++14: 5.1.2/12]:</code> A <em>lambda-expression</em> with an associated <em>capture-default</em> that does not explicitly capture this or a variable with automatic storage duration (this excludes any <em>id-expression</em> that has been found to refer to an <em>init-capture</em>'s associated non-static data member), is said to implicitly capture the entity (i.e., <code>this</code> or a variable) if the <em>compound-statement</em>:</p>\n<ul>\n<li>odr-uses (3.2) the entity, or</li>\n<li>names the entity in a potentially-evaluated expression (3.2) where the enclosing full-expression depends on a generic lambda parameter declared within the reaching scope of the <em>lambda-expression</em>.</li>\n</ul>\n<p id=\"so_28141403_28141551_2\"><em>[ Example:</em></p>\n<pre><code>void f(int, const int (&amp;)[2] = {}) { } // #1\nvoid f(const int&amp;, const int (&amp;)[1]) { } // #2\nvoid test() {\n  const int x = 17;\n  auto g = [](auto a) {\n    f(x); // OK: calls #1, does not capture x\n  };\n\n  auto g2 = [=](auto a) {\n    int selector[sizeof(a) == 1 ? 1 : 2]{};\n    f(x, selector); // OK: is a dependent expression, so captures x\n  };\n}\n</code></pre>\n<p id=\"so_28141403_28141551_3\"><em>\u2014end example ]</em> All such implicitly captured entities shall be declared within the reaching scope of the lambda expression. <em>[ Note:</em> The implicit capture of an entity by a nested lambda-expression can cause its implicit capture by the containing lambda-expression (see below). Implicit <em>odr-uses</em> of this can result in implicit capture. <em>\u2014end note ]</em></p>\n<p id=\"so_28141403_28141551_4\"><code>[C++14: 5.1.2/13]:</code> An entity is captured if it is captured explicitly or implicitly. An entity captured by a <em>lambda-expression</em> is odr-used (3.2) in the scope containing the <em>lambda-expression</em>. <em>[..]</em></p>\n</blockquote>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2015-02-03T16:19:02.070", "Score": "22", "CreationDate": "2015-01-25T21:10:06.257", "ParentId": "28141403", "CommentCount": "9", "OwnerUserId": "560648", "LastEditDate": "2015-02-03T16:19:02.070"}, "28141403": {"ViewCount": "2956", "Body": "<p>I'm trying to use the generic lambda of C++14, but got a trouble with std::function.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nint main()\n{\n    const int a = 2;\n    std::function&lt;void(int)&gt; f = [&amp;](auto b) { std::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; std::endl; };\n    f(3);\n}\n</code></pre>\n<p>This fails to compile with an error message saying that <code>error: \u2018a\u2019 was not declared in this scope</code>.</p>\n<p>It works if I change it to <code>(int b)</code>.</p>\n<p>Is it a bug? or am I missing something?</p>\n<p>The version of GCC i'm using is 4.9.2.</p>\n", "AcceptedAnswerId": "28141551", "Title": "Generic lambda with std::function does not capture variables", "CreationDate": "2015-01-25T20:56:12.110", "Id": "28141403", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-01-25T21:09:00.857", "LastEditorUserId": "560648", "LastActivityDate": "2015-02-03T16:19:02.070", "Score": "27", "OwnerUserId": "1030861", "Tags": "<c++><gcc><c++14>", "AnswerCount": "2"}});