post_cb({"19565341": {"ParentId": "19564009", "LastEditDate": "2013-10-24T12:13:43.810", "CommentCount": "3", "CreationDate": "2013-10-24T11:59:44.473", "OwnerUserId": "560648", "LastEditorUserId": "560648", "PostTypeId": "2", "Id": "19565341", "Score": "4", "Body": "<p><strong>tl;dr: Visual Studio is right \u2014 you can't put that <code>typedef</code> there.</strong><br>\nThe Boost documentation <a href=\"http://www.boost.org/doc/libs/1_54_0/doc/html/intrusive/usage.html#intrusive.usage.usage_member_hook\" rel=\"nofollow\">gets this right, but doesn't explain why</a>.</br></p>\n<hr>\n<blockquote>\n<p id=\"so_19564009_19565341_0\"><code>[C++11: 14.3.2/1]:</code> <strong>A <em>template-argument</em> for a non-type, non-template template-parameter shall be</strong> one of:</p>\n<ul>\n<li>for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression (5.19) of the type of the <em>template-parameter</em>; or</li>\n<li>the name of a non-type <em>template-parameter</em>; or</li>\n<li>a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage or a function with external or internal linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as <code>&amp; id-expression</code>, except that the <code>&amp;</code> may be omitted if the name refers to a function or array and shall be omitted if the corresponding <em>template-parameter</em> is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li><strong>a pointer to member expressed as described in 5.3.1</strong>.</li>\n</ul>\n<p id=\"so_19564009_19565341_1\"><code>[C++11: 5.3.1/3]:</code> The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>. If the operand is a <em>qualified-id</em> naming a non-static member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type \u201cpointer to member of class <code>C</code> of type <code>T</code>\u201d and is a prvalue designating <code>C::m</code>. <em>[..]</em></p>\n</blockquote>\n<p><code>[C++11: 8.3.3/2]</code> gives an example of a pointer-to-member for an incomplete type being valid for as long as the pointer-to-member is not actually initialised, and though not explicitly stated, the implication is that to actually take the address of some <code>C::m</code>, <code>C</code> must be a complete type. Indeed, until <code>C</code> is a complete type, <code>C::m</code> does not really exist.</p>\n<p>There are some <em>similar</em> rules that are clearer:</p>\n<blockquote>\n<p id=\"so_19564009_19565341_2\"><code>[C++11: 9.2/10]</code>: Non-static (9.4) data members shall not have incomplete types. In particular, a class <code>C</code> shall not contain a non-static member of class <code>C</code>, but it can contain a pointer or reference to an object of class <code>C</code>.</p>\n</blockquote>\n<p>At the point of your <code>typedef</code>, <code>Test</code> is not a complete type:</p>\n<blockquote>\n<p id=\"so_19564009_19565341_3\"><code>[C++11: 9.2/2]:</code> A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the <em>class-specifier</em>. Within the class <em>member-specification</em>, the class is regarded as complete within function bodies, default arguments, <em>exception-specifications</em>, and <em>brace-or-equal-initializers</em> for non-static data members (including such things in nested classes). <strong>Otherwise it is regarded as incomplete within its own class <em>member-specification</em>.</strong></p>\n</blockquote>\n<p>Therefore, you cannot use that pointer-to-member at that place. You must write the <code>typedef</code> so that it appears after the closing <code>}</code> of the class definition, or make the pointed-to object non-member, or <code>static</code> member.</p>\n<p>GCC <a href=\"http://ideone.com/zl3H8o\" rel=\"nofollow\">must have a bug or extension in this regard</a>, since the following testcase compiles and executes successfully:</p>\n<pre><code>template &lt;typename B, int B::* PTM&gt;\nstruct A {};\n\nstruct B\n{\n    int x;\n\n    typedef A&lt;B, &amp;B::x&gt; a;\n};\n\nint main() {\n    B b;\n}\n</code></pre>\n<p>whereas Visual Studio 2012 Express correctly outputs:</p>\n<blockquote>\n<p id=\"so_19564009_19565341_4\">1&gt;------ Build started: Project: test1, Configuration: Debug Win32 ------<br>\n  1&gt;  test.cpp<br>\n  1&gt;f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(8): error C2327: 'B::x' : is not a type name, static, or enumerator<br>\n  1&gt;f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(8): error C2065: 'x' : undeclared identifier<br>\n  1&gt;f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(8): error C2975: 'PTM' : invalid template argument for 'A', expected compile-time constant expression<br>\n  1&gt;          f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(1) : see declaration of 'PTM'<br>\n  ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========</br></br></br></br></br></br></p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-10-24T12:13:43.810"}, "bq_ids": {"n4140": {"so_19564009_19565341_1": {"section_id": 6066, "quality": 0.8620689655172413, "length": 25}, "so_19564009_19566059_3": {"section_id": 7070, "quality": 0.7, "length": 7}, "so_19564009_19566059_0": {"section_id": 87, "quality": 0.7142857142857143, "length": 5}, "so_19564009_19565341_2": {"section_id": 5869, "quality": 0.9047619047619048, "length": 19}, "so_19564009_19565341_3": {"section_id": 5862, "quality": 0.9487179487179487, "length": 37}, "so_19564009_19565341_0": {"section_id": 87, "quality": 0.7142857142857143, "length": 5}, "so_19564009_19566059_2": {"section_id": 7113, "quality": 0.8235294117647058, "length": 42}, "so_19564009_19566059_1": {"section_id": 6066, "quality": 0.8620689655172413, "length": 25}}, "n3337": {"so_19564009_19565341_1": {"section_id": 5834, "quality": 0.8620689655172413, "length": 25}, "so_19564009_19566059_3": {"section_id": 6814, "quality": 0.7, "length": 7}, "so_19564009_19566059_0": {"section_id": 82, "quality": 0.7142857142857143, "length": 5}, "so_19564009_19565341_2": {"section_id": 5640, "quality": 0.9047619047619048, "length": 19}, "so_19564009_19565341_3": {"section_id": 5632, "quality": 0.9487179487179487, "length": 37}, "so_19564009_19565341_0": {"section_id": 82, "quality": 0.7142857142857143, "length": 5}, "so_19564009_19566059_2": {"section_id": 6857, "quality": 0.8235294117647058, "length": 42}, "so_19564009_19566059_1": {"section_id": 5834, "quality": 0.8620689655172413, "length": 25}}, "n4659": {"so_19564009_19565341_2": {"section_id": 7352, "quality": 0.9047619047619048, "length": 19}, "so_19564009_19565341_1": {"section_id": 7562, "quality": 0.8620689655172413, "length": 25}, "so_19564009_19566059_2": {"section_id": 8614, "quality": 0.8235294117647058, "length": 42}, "so_19564009_19566059_1": {"section_id": 7562, "quality": 0.8620689655172413, "length": 25}, "so_19564009_19565341_3": {"section_id": 7345, "quality": 0.8205128205128205, "length": 32}}}, "19564009": {"CommentCount": "7", "ViewCount": "2425", "CreationDate": "2013-10-24T10:57:20.523", "LastActivityDate": "2013-10-24T12:32:39.890", "Title": "error C2327: not a type name, static, or enumerator", "FavoriteCount": "1", "PostTypeId": "1", "Id": "19564009", "Score": "4", "Body": "<p>I am facing \"error C2327\" on windows.<br>\nI reduced my code and get similar error with test program   </br></p>\n<pre><code>#include &lt;boost/intrusive/list.hpp&gt;\n#include &lt;iostream&gt;\n\nclass Test {\nprotected:\n         typedef Test self_type;\n         boost::intrusive::list_member_hook&lt;&gt; order_hook;\npublic:\n         typedef boost::intrusive::member_hook&lt;self_type,\n                            boost::intrusive::list_member_hook&lt;&gt;,\n                            &amp; Test::order_hook &gt; order_hook_type;\n};\n</code></pre>\n<p>This works fine on g++ but on windows it's giving following error:   </p>\n<pre><code>test.cpp(11) : error C2327: 'Test::order_hook' : is not a type name, static, or enumerator\ntest.cpp(11) : error C2065: 'order_hook' : undeclared identifier\n</code></pre>\n<p>Please help. What i am missing for windows?</p>\n", "Tags": "<c++><windows><visual-studio><templates><g++>", "OwnerUserId": "1164349", "AnswerCount": "2"}, "19566059": {"ParentId": "19564009", "CommentCount": "5", "Body": "<p><strong>tl;dr: Visual Studio has a bug: your code is legal.</strong></p>\n<hr>\n<blockquote>\n<p id=\"so_19564009_19566059_0\"><code>[C++11: 14.3.2/1]:</code> <strong>A <em>template-argument</em> for a non-type, non-template template-parameter shall be</strong> one of:</p>\n<ul>\n<li>for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression (5.19) of the type of the <em>template-parameter</em>; or</li>\n<li>the name of a non-type <em>template-parameter</em>; or</li>\n<li>a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage or a function with external or internal linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as <code>&amp; id-expression</code>, except that the <code>&amp;</code> may be omitted if the name refers to a function or array and shall be omitted if the corresponding <em>template-parameter</em> is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li><strong>a pointer to member expressed as described in 5.3.1</strong>.</li>\n</ul>\n<p id=\"so_19564009_19566059_1\"><code>[C++11: 5.3.1/3]:</code> The result of the unary <code>&amp;</code> operator is a pointer to its operand. <strong>The operand shall be</strong> an lvalue or <strong>a <em>qualified-id</em></strong>. If the operand is a <em>qualified-id</em> naming a non-static member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type \u201cpointer to member of class <code>C</code> of type <code>T</code>\u201d and is a prvalue designating <code>C::m</code>. <em>[..]</em></p>\n<p id=\"so_19564009_19566059_2\"><code>[C++11: 3.4.3.1/1]</code>: If the <em>nested-name-specifier</em> of a <em>qualified-id</em> nominates a class, the name specified after the <em>nested-name-specifier</em> is looked up in the scope of the class (10.2), except for the cases listed below. The name shall represent one or more members of that class or of one of its base classes (Clause 10). <em>[ Note:</em> <strong>A class member\n  can be referred to using a <em>qualified-id</em> at any point in its potential scope (3.3.7)</strong>. <em>\u2014end note ]</em> <strong>The exceptions to the name lookup rule above are the following:</strong></p>\n<ul>\n<li>a destructor name is looked up as specified in 3.4.3;</li>\n<li>a <em>conversion-type-id</em> of a <em>conversion-function-id</em> is looked up in the same manner as a <em>conversion-type-id</em> in a class member access (see 3.4.5);</li>\n<li>the names in a <em>template-argument</em> of a <em>template-id</em> are looked up in the context in which the entire <em>postfix-expression</em> occurs.</li>\n<li>the lookup for a name specified in a using-declaration (7.3.3) also finds class or enumeration names hidden within the same scope (3.3.10).</li>\n</ul>\n</blockquote>\n<p>None of the exceptions apply here, so we look at the class member's \"potential scope\":</p>\n<blockquote>\n<p id=\"so_19564009_19566059_3\"><code>[C++11: 3.3.7/1]:</code> The following rules describe the scope of names declared in classes.</p>\n<ol>\n<li><strong>The potential scope of a name declared in a class consists not only of the declarative region following the name\u2019s point of declaration</strong>, but also of all function bodies, brace-or-equal-initializers of non-static data members, and default arguments in that class (including such things in nested classes).</li>\n<li><em>[..]</em></li>\n</ol>\n</blockquote>\n<p>GCC <a href=\"http://ideone.com/zl3H8o\" rel=\"nofollow\">correctly compiles and executes the following testcase</a>:</p>\n<pre><code>template &lt;typename B, int B::* PTM&gt;\nstruct A {};\n\nstruct B\n{\n    int x;\n\n    typedef A&lt;B, &amp;B::x&gt; a;\n};\n\nint main() {\n    B b;\n}\n</code></pre>\n<p>whereas Visual Studio 2012 Express incorrectly errors out:</p>\n<blockquote>\n<p id=\"so_19564009_19566059_4\">1&gt;------ Build started: Project: test1, Configuration: Debug Win32 ------<br>\n  1&gt;  test.cpp<br>\n  1&gt;f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(8): error C2327: 'B::x' : is not a type name, static, or enumerator<br>\n  1&gt;f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(8): error C2065: 'x' : undeclared identifier<br>\n  1&gt;f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(8): error C2975: 'PTM' : invalid template argument for 'A', expected compile-time constant expression<br>\n  1&gt;          f:\\documents\\visual studio 2012\\projects\\test1\\test1\\test.cpp(1) : see declaration of 'PTM'<br>\n  ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========</br></br></br></br></br></br></p>\n</blockquote>\n</hr>", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "19566059", "Score": "3", "CreationDate": "2013-10-24T12:32:39.890", "LastActivityDate": "2013-10-24T12:32:39.890"}});