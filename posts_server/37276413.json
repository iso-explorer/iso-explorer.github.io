post_cb({"37277174": {"ParentId": "37276413", "CommentCount": "1", "CreationDate": "2016-05-17T13:11:16.857", "OwnerUserId": "6292850", "PostTypeId": "2", "Id": "37277174", "Score": "-1", "Body": "<p>The behavior can essentially be illustrated with:</p>\n<pre><code>void foo(const int&amp; i)\n{\n    std::cout &lt;&lt; \"copy\";\n}\n\nvoid foo(int&amp;&amp; i)\n{\n    std::cout &lt;&lt; \"move\";\n}\n</code></pre>\n<p>When both overloads are present, the <code>int&amp;&amp;</code> overload is selected for rvalues while the <code>const int&amp;</code> overload is selected for lvalues. If you remove the <code>int&amp;&amp;</code> overload, <code>const int&amp;</code> is called (ergo, not an error) even for rvalues. This is essentially what's happening in this case:</p>\n<pre><code>class Foo\n{\npublic:\n  Foo() = default;\n  Foo(Foo const &amp;) = delete;\n};\n</code></pre>\n<p>Overload resolution only sees one candidate but since it is explicitly deleted, the program is ill-formed.</p>\n<p>The non-normative note below the section you quoted clarifies this is what's happening:</p>\n<blockquote>\n<p id=\"so_37276413_37277174_0\"><em>[ Note:</em> When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would have invoked the\n  move constructor may instead invoke a copy constructor.  \u2014 <em>end note\n  ]</em></p>\n</blockquote>\n", "LastActivityDate": "2016-05-17T13:11:16.857"}, "37277554": {"ParentId": "37276413", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-05-17T13:26:44.850", "Score": "11", "LastEditorUserId": "2666289", "LastEditDate": "2017-10-27T22:08:37.600", "Id": "37277554", "OwnerUserId": "2666289", "Body": "<p><code>user-declared</code> means either either <em>user-provided</em> (<strong>defined</strong> by the user), <em>explicitly defaulted</em> (<code>= default</code>) or <em>explicitly deleted</em> (<code>= delete</code>) in contrast with implicitly defaulted / deleted (such as your move constructor).</p>\n<p>So in your case, <strong>yes</strong> the move constructor is <strong>implicitly</strong> deleted because the copy-constructor is <strong>explicitly</strong> deleted (and thus <em>user-declared</em>).</p>\n<blockquote>\n<p id=\"so_37276413_37277554_0\">However, in that particular case, how would deleted copy constructor/assignment mess default move constructor/assignment?</p>\n</blockquote>\n<p>It would not, but the standard does not make the difference between this case and a complicated one. </p>\n<p>The shortest answer is that having an <em>implicitly</em> defined move-constructor with an <em>explicitly</em> deleted copy-constructor <strong>might</strong> be dangerous in some cases, the same when you have a <em>user-defined</em>  destructor and no <em>user-defined</em> copy-constructor (see <a href=\"http://en.cppreference.com/w/cpp/language/rule_of_three\" rel=\"nofollow noreferrer\">rule  of three/five/zero</a>). Now, you can argue that a user-defined destructor does not delete the copy-constructor, but this is simply a <em>flaw</em> in the language which cannot be removed because it would break a lot of old (bad) program. To quote Bjarne Stroustrup:</p>\n<blockquote>\n<p id=\"so_37276413_37277554_1\">In an ideal world, I think we would decide on \u201cno generation\u201d as the default and provide a really simple notation for \u201cgive me all the usual operations.\u201d [...] Also, a \u201cno default operations\u201d policy leads to compile time errors (which we should have an easy way to fix), whereas a generate operations by default policy leads to problems that cannot be detected until run time.</p>\n</blockquote>\n<p>You can read more about this in <a href=\"http://www.stroustrup.com/move.pdf\" rel=\"nofollow noreferrer\">N3174=10-0164</a>. </p>\n<p>Note that most people follow the <a href=\"http://en.cppreference.com/w/cpp/language/rule_of_three\" rel=\"nofollow noreferrer\">rule  of three/five/zero</a>, and in my opinion you should. By implicitly deleting the default move-constructor, the standard is \"protecting\" you from mistakes and should have protected you a long time before by deleting copy-constructor in some cases (see Bjarne's paper).</p>\n<p>Further reading if you are interested: </p>\n<ul>\n<li><a href=\"http://accu.org/index.php/journals/1896\" rel=\"nofollow noreferrer\">Enforcing the Rule of Zero</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3153.htm\" rel=\"nofollow noreferrer\">N3153 - Implicit Move Must Go</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3174.pdf\" rel=\"nofollow noreferrer\">N3174</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3201.pdf\" rel=\"nofollow noreferrer\">N3201</a></li>\n</ul>\n<blockquote>\n<p id=\"so_37276413_37277554_2\">I think this question has practical importance because manual generation and esp. maintenance of such default functions is error prone, while at the same time, the (righteous) increase of the use of classes such as <code>std::unique_ptr</code> as class members made non-copyable classes much more common beasts than they used to be.</p>\n</blockquote>\n<p>Marking the move constructor as explicitly defaulted will solve this problem:</p>\n<pre><code>class Foo {\npublic:\n  Foo() = default;\n  Foo(Foo const &amp;) = delete;\n  Foo(Foo&amp;&amp;) = default;\n};\n</code></pre>\n<p>You get a non-copyable object with a default move constructor, and in my opinion these explicit declarations are better than implicit ones (e.g. by only declaring the move constructor as <code>default</code> without deleting the copy-constructor).</p>\n", "LastActivityDate": "2017-10-27T22:08:37.600"}, "37276413": {"CommentCount": "1", "AcceptedAnswerId": "37277554", "CreationDate": "2016-05-17T12:36:15.417", "LastActivityDate": "2017-10-27T22:08:37.600", "PostTypeId": "1", "ViewCount": "3109", "FavoriteCount": "2", "Title": "Default move constructor/assignment and deleted copy constructor/assignment", "Id": "37276413", "Score": "9", "Body": "<p>According to the standard, </p>\n<blockquote>\n<p id=\"so_37276413_37276413_0\">If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if</p>\n<p id=\"so_37276413_37276413_1\">\u2014 X does not have a user-declared copy constructor,</p>\n<p id=\"so_37276413_37276413_2\">\u2014 X does not have a user-declared copy assignment operator,</p>\n<p id=\"so_37276413_37276413_3\">\u2014 X does not have a user-declared move assignment operator, and</p>\n<p id=\"so_37276413_37276413_4\">\u2014 X does not have a user-declared destructor.</p>\n</blockquote>\n<p>Now the following fails to compile</p>\n<pre><code># include &lt;utility&gt;\n\nclass Foo\n{\npublic:\n  Foo() = default;\n  Foo(Foo const &amp;) = delete;\n};\n\nint main()\n{\n  Foo f;\n  Foo g(std::move(f)); // compilation fails here\n  return 0;\n}\n</code></pre>\n<p>So it seems that a deleted function is considered as user-defined, which makes sense (it is not its default implementation). However, in that particular case, how would deleted copy construtor/assignment mess default move constructor/assignment?</p>\n<p>I think this question has practical importance because manual generation and esp. maintenance of such default functions is error prone, while at the same time, the (righteous) increase of the use of classes such as <code>std::unique_ptr</code> as class members made non-copyable classes much more common beasts than they used to be.</p>\n", "Tags": "<c++><move-semantics><deleted-functions>", "OwnerUserId": "1735003", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_37276413_37277174_0": {"section_id": 458, "quality": 0.8636363636363636, "length": 19}, "so_37276413_37276413_2": {"section_id": 458, "quality": 1.0, "length": 6}, "so_37276413_37277533_6": {"section_id": 3277, "quality": 1.0, "length": 9}, "so_37276413_37276413_3": {"section_id": 458, "quality": 1.0, "length": 6}, "so_37276413_37277533_0": {"section_id": 458, "quality": 1.0, "length": 12}, "so_37276413_37277533_1": {"section_id": 458, "quality": 1.0, "length": 5}, "so_37276413_37277533_5": {"section_id": 3276, "quality": 0.8, "length": 8}, "so_37276413_37276413_4": {"section_id": 458, "quality": 1.0, "length": 4}, "so_37276413_37276413_0": {"section_id": 458, "quality": 1.0, "length": 12}, "so_37276413_37276413_1": {"section_id": 458, "quality": 1.0, "length": 5}}, "n3337": {"so_37276413_37277174_0": {"section_id": 449, "quality": 0.8636363636363636, "length": 19}, "so_37276413_37276413_2": {"section_id": 449, "quality": 1.0, "length": 6}, "so_37276413_37277533_6": {"section_id": 3148, "quality": 1.0, "length": 9}, "so_37276413_37276413_3": {"section_id": 449, "quality": 1.0, "length": 6}, "so_37276413_37277533_0": {"section_id": 449, "quality": 1.0, "length": 12}, "so_37276413_37277533_1": {"section_id": 449, "quality": 1.0, "length": 5}, "so_37276413_37277533_5": {"section_id": 3147, "quality": 0.8, "length": 8}, "so_37276413_37276413_4": {"section_id": 449, "quality": 1.0, "length": 4}, "so_37276413_37276413_0": {"section_id": 449, "quality": 1.0, "length": 12}, "so_37276413_37276413_1": {"section_id": 449, "quality": 1.0, "length": 5}}, "n4659": {"so_37276413_37277174_0": {"section_id": 481, "quality": 0.8636363636363636, "length": 19}, "so_37276413_37276413_2": {"section_id": 481, "quality": 1.0, "length": 6}, "so_37276413_37277533_6": {"section_id": 4035, "quality": 1.0, "length": 9}, "so_37276413_37276413_3": {"section_id": 481, "quality": 1.0, "length": 6}, "so_37276413_37277533_0": {"section_id": 481, "quality": 1.0, "length": 12}, "so_37276413_37277533_1": {"section_id": 481, "quality": 1.0, "length": 5}, "so_37276413_37277533_5": {"section_id": 4034, "quality": 0.8, "length": 8}, "so_37276413_37276413_4": {"section_id": 481, "quality": 1.0, "length": 4}, "so_37276413_37276413_0": {"section_id": 481, "quality": 1.0, "length": 12}, "so_37276413_37276413_1": {"section_id": 481, "quality": 1.0, "length": 5}}}, "37277533": {"ParentId": "37276413", "CommentCount": "0", "CreationDate": "2016-05-17T13:25:52.550", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "37277533", "Score": "1", "Body": "<p>As you stated, from \u00a712.8</p>\n<blockquote>\n<p id=\"so_37276413_37277533_0\">If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared\n  as defaulted if and only if</p>\n<ul>\n<li><p id=\"so_37276413_37277533_1\">X does not have a <strong>user-declared</strong> copy constructor,</p></li>\n<li><p id=\"so_37276413_37277533_2\">[...]</p></li>\n</ul>\n</blockquote>\n<p>Note the <em>user-declared</em>. But if you look at \u00a78.4.3:</p>\n<blockquote>\n<p id=\"so_37276413_37277533_3\">A function definition of the form:</p>\n<p id=\"so_37276413_37277533_4\"><em>attribute-specifier-seq<sub>opt</sub> decl-specifier-seq<sub>opt</sub> declarator virt-specifier-seq<sub>opt</sub> = delete ;</em></p>\n<p id=\"so_37276413_37277533_5\">is called a deleted <strong>definition</strong>. A function with a deleted <strong>definition</strong> is also called a deleted function.</p>\n<p id=\"so_37276413_37277533_6\">A program that refers to a deleted function implicitly or explicitly, other than to <strong>declare it</strong>, is ill-formed.</p>\n</blockquote>\n<p>So the standard defines <code>delete</code>d functions as <strong>user-declared</strong> (as you can see from above), even though they are <code>delete</code>d and can't be used.</p>\n<p>Then, according to \u00a712.8, the implicit move constructor is not defined, because of the user-declared (with <code>= delete;</code>) copy constructor.</p>\n", "LastActivityDate": "2016-05-17T13:25:52.550"}});