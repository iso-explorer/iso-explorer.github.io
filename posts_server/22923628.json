post_cb({"22924201": {"ParentId": "22923628", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are <em>this</em> close! You only need to use a class instead of an alias:</p>\n<pre><code>template&lt;typename ARG, typename... ARGS&gt;\nstruct first_of { using type = ARG; };\n</code></pre>\n<p>See <a href=\"http://coliru.stacked-crooked.com/a/72c3e694db6c75ec\" rel=\"nofollow\">live example</a>.</p>\n<p>You cannot use an alias directly because</p>\n<pre><code> first_of&lt;_1,_2,_3,_4&gt;\n</code></pre>\n<p>is <em>immediately</em> substituted for <code>_1</code>, which is not of the form expected by <code>eval_impl</code>.</p>\n<p>I don't find this is a limitation because we usually define template functions in the above form, and <em>then</em> define additional aliases like</p>\n<pre><code>template&lt;typename ARG, typename... ARGS&gt;\nusing first_of_t = typename first_of&lt;ARG, ARGS...&gt;::type;\n</code></pre>\n<p>for easier use. So we usually have both; you'll have to use the former with <code>eval</code>.</p>\n<hr>\n<p><strong>Attempt 2.</strong> Also note that direct use of an alias is possible without placeholders at all:</p>\n<pre><code>template&lt;template&lt;typename...&gt; class F, typename... ARGS&gt;\nusing alias_eval = F&lt;ARGS...&gt;;\n</code></pre>\n<p>in which case you can say</p>\n<pre><code>using alias_call = alias_eval&lt;first_of_t, bool, float, char, int&gt;;\n</code></pre>\n<p>as in your first attempt. See <a href=\"http://coliru.stacked-crooked.com/a/091d7e49cf2cf080\" rel=\"nofollow\">updated example</a>. But I guess this is of no use because you intend to use placeholders in a less trivial way.</p>\n<hr>\n<p><strong>Attempt 3.</strong> Yet another option is to <em>delay</em> substitution of the alias, e.g.</p>\n<pre><code>template&lt;template&lt;typename...&gt; class F, typename... PLACEHOLDERS&gt;\nstruct holder {};\n\ntemplate&lt;typename EXPRESSION, typename... ARGS&gt;\nstruct holder_eval_impl;\n\ntemplate&lt;template&lt;typename...&gt; class F, typename... PLACEHOLDERS, typename... ARGS&gt;\nstruct holder_eval_impl&lt;holder&lt;F, PLACEHOLDERS...&gt;, ARGS...&gt; :\n    public F&lt;ARGS...&gt; {};\n\ntemplate&lt;typename EXPRESSION, typename... ARGS&gt;\nusing holder_eval = typename holder_eval_impl&lt;EXPRESSION, ARGS...&gt;::type;\n</code></pre>\n<p>which is very close to your intended syntax</p>\n<pre><code>using holder_call =\n    holder_eval&lt;holder&lt;first_of,_1,_2,_3,_4&gt;, bool, float, char, int&gt;;\n</code></pre>\n<p>especially if you use a short name for <code>holder</code>. Again, <a href=\"http://coliru.stacked-crooked.com/a/04bf0cfa8bc9891f\" rel=\"nofollow\">live example</a>.</p>\n</hr></hr>", "OwnerUserId": "2644390", "LastEditorUserId": "2644390", "LastEditDate": "2014-04-08T09:11:18.300", "Id": "22924201", "Score": "2", "CreationDate": "2014-04-07T22:23:01.837", "LastActivityDate": "2014-04-08T09:11:18.300"}, "bq_ids": {"n4140": {"so_22923628_22923628_0": {"section_id": 157, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_22923628_22923628_0": {"section_id": 156, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_22923628_22923628_0": {"section_id": 161, "quality": 0.5714285714285714, "length": 4}}}, "22923628": {"CommentCount": "2", "AcceptedAnswerId": "22924201", "PostTypeId": "1", "LastEditorUserId": "3043539", "CreationDate": "2014-04-07T21:38:47.693", "LastActivityDate": "2014-04-10T18:54:40.640", "LastEditDate": "2014-04-10T18:54:40.640", "ViewCount": "128", "FavoriteCount": "1", "Title": "Matching template aliases as template template parameters", "Id": "22923628", "Score": "1", "Body": "<p>I'm currently writting a metafunction to evaluate expressions, something like boost::mpl::apply:</p>\n<pre><code>template&lt;typename EXPRESSION , typename... ARGS&gt;\nusing eval = typename eval_impl&lt;EXPRESSION,ARGS...&gt;::result;\n</code></pre>\n<p>As you can see, I'm using C++11 template aliases to avoid writting <code>typename ::result</code> when using the evaluator. </p>\n<p>Among other specializations, <code>eval_impl</code> (The implementation of the evaluation metafunction) has an specializationfor the case the user passes a parametrized expression (Such as a metafunction) and a set of parameters. In other words, for using <code>eval</code> as a high-order metafunction to evaluate a metafunction with a set of specified parameters. </p>\n<p>For that case, I have written a specialization as follows:</p>\n<pre><code>template&lt;template&lt;typename...&gt; class F , typename... PLACEHOLDERS , typename... ARGS&gt;\nstruct eval_impl&lt;F&lt;PLACEHOLDERS...&gt;,ARGS...&gt; : public F&lt;ARGS...&gt; {}\n</code></pre>\n<p>Now consider a use case: </p>\n<pre><code>template&lt;typename ARG , typename... ARGS&gt; using first_of = ARG;\n\nusing call = eval&lt;first_of&lt;_1,_2,_3,_4&gt; , bool,float,char,int&gt;;\n</code></pre>\n<p>Here we define a custom metafunction  <code>first_of</code> as a template alias, and we pass it to <code>eval</code> together with a set of parameters to be called (evaluated) with. <code>_1</code>, <code>_2</code>... are just placeholders.</p>\n<p>I have expected that <code>eval</code> call instances the specialization defined above, but it doesn't.\nAnd if the aliased type is not a type itself, but a one-parameter template, GCC 4.8.1 says:</p>\n<blockquote>\n<p id=\"so_22923628_22923628_0\">Error: Expected one template parameter, two provided</p>\n</blockquote>\n<p>At the point of instantation of that <code>eval_impl</code> specialization.</p>\n<p>So that errors give me to think that <strong>the template alias is not taken in the template template parameter of the partial specialization, the aliased type is matched instead.</strong></p>\n<p>As you can see in the examples, thats not what I wan't, I need the template alias to be matched as any other metafunction. <strong>Is there any way to achieve that?</strong></p>\n", "Tags": "<c++><templates><c++11><template-meta-programming><template-aliases>", "OwnerUserId": "1609356", "AnswerCount": "1"}});