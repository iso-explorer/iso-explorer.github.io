post_cb({"bq_ids": {"n4140": {"so_47991321_47994579_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 205}}, "n3337": {"so_47991321_47994579_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 199}}, "n4659": {"so_47991321_47994579_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 213}}}, "47994579": {"Id": "47994579", "PostTypeId": "2", "Body": "<p>This is going to be tricky.</p>\n<p>I believe your code is ok for <code>Dim&gt;=2</code> but it's ill-formed when given a <code>Dim&lt;=1</code> argument, with no diagnostic required, but for a different reason your compiler is complaining about.</p>\n<hr>\n<p>For <code>Dim&gt;=2</code> it is correct, but your compiler (MSVC++ I guess) complains in the <code>Dim==2</code> case. Given the error description, I suppose the reason is that it's erroneously short-circuiting the &amp;&amp; expressions in the <code>enable_if</code> conditions, interpreting them as value-dependent <em>only</em> on the class template parameter when <code>Dim &gt; x</code> is false. The workaround is to move the <code>Dim &gt; x</code> checks as the last term of the &amp;&amp; expression.</p>\n<p>To elaborate, the situation is  conceptually similar to the following code snippet:</p>\n<pre><code>template &lt;size_t N&gt;\nclass foo\n{\n    template &lt;typename E = enable_if_t&lt;(N&gt;0)&gt;&gt;\n    void bar();\n};\n\nfoo&lt;1&gt; f1;\nfoo&lt;0&gt; f0; // fails\n</code></pre>\n<p>here, the instantation of <code>foo</code> triggers the instantiation of the declarations (but not the definitions) of its members (see <strong>[temp.inst]#1</strong>); but, only checks of names and expressions that <em>depend</em> on the <em>member</em> template parameters are postponed at their respective instantiation points. Here, the type name <code>enable_if_t&lt;(N&gt;0)&gt;</code> does <em>not</em> depend on any <code>bar()</code> template parameter (<code>N</code> belongs to <code>foo</code>'s template parameters list) hence is non-dependent, resulting in <code>enable_if&lt;false&gt;::type</code> when <code>N == 0</code>, so the error.</p>\n<hr>\n<p>Going back to your code, consider:</p>\n<blockquote>\n<p id=\"so_47991321_47994579_0\"><strong>[temp.dep.constexpr]#1</strong> Except as described below, a constant expression is value-dependent <strong>if any subexpression</strong> is value-dependent</p>\n</blockquote>\n<p>and nowhere shortcircuiting operators are mentioned as an exception. So, the expression, say, <code>Dim &gt; 1 &amp;&amp; VDim == 0</code> is value-dependent even if <code>Dim&lt;=1</code>; therefore, no error should occur until substitution of <code>VDim</code> (where SFINAE would apply). In fact, both gcc and clang <a href=\"https://godbolt.org/g/HAi8Cg\" rel=\"nofollow noreferrer\">agree</a> on accepting your code.</p>\n<p>That said, when <code>Dim&lt;=1</code> the first and third <code>getVectorBegin</code> overloads actually declare <em>functionally equivalent</em> member templates (see <strong>[temp.over.link]#6</strong>), so I believe it's ill-formed in that case.</p>\n</hr></hr>", "LastEditorUserId": "8631381", "LastActivityDate": "2017-12-27T15:52:19.477", "Score": "2", "CreationDate": "2017-12-27T15:20:37.063", "ParentId": "47991321", "CommentCount": "0", "OwnerUserId": "8631381", "LastEditDate": "2017-12-27T15:52:19.477"}, "47991321": {"ViewCount": "86", "Body": "<p>I would like to specialize <code>getVector</code> member function, i'm trying to use SFINAE for this. But it works only if Dim is 3 or greater.</p>\n<pre><code>template &lt;size_t Dim&gt;\nclass Mat\n{\n    ...\n    template &lt;size_t VDim, typename enable_if&lt;(Dim &gt; 1 &amp;&amp; VDim == 0)&gt;::type* = nullptr&gt;\n        void getVectorBegin(const array&lt;size_t, Dim - 1&gt;&amp; indexAfter) const;\n\n    template &lt;size_t VDim, typename enable_if&lt;(Dim &gt; 2 &amp;&amp; 0 &lt; VDim &amp;&amp; VDim &lt; Dim-1)&gt;::type* = nullptr&gt;\n        void getVectorBegin(const array&lt;size_t, VDim&gt;&amp; indexBefore, const array&lt;size_t, Dim - VDim - 1&gt;&amp; indexAfter) const;\n\n    template &lt;size_t VDim, typename enable_if&lt;(Dim &gt; 1 &amp;&amp; VDim == Dim-1)&gt;::type* = nullptr&gt;\n        void getVectorBegin(const array&lt;size_t, Dim - 1&gt;&amp; indexBefore) const;\n};\n\nMat&lt;3&gt; m;\nMat&lt;2&gt; m; // error C2039: 'type': is not a member of 'std::enable_if&lt;false,_Ty&gt;'\n</code></pre>\n", "AcceptedAnswerId": "47994579", "Title": "SFINAE on template member overloading", "CreationDate": "2017-12-27T11:24:22.480", "Id": "47991321", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2017-12-27T15:52:19.477", "Score": "2", "OwnerUserId": "312896", "Tags": "<c++><class><templates><template-specialization><sfinae>", "AnswerCount": "1"}});