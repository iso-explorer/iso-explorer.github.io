post_cb({"44871322": {"CommentCount": "3", "ViewCount": "81", "CreationDate": "2017-07-02T13:28:20.257", "LastActivityDate": "2017-07-03T05:41:40.673", "Title": "Template Metaprogramming: \"does not have integral or enumeration type\"", "AcceptedAnswerId": "44871367", "PostTypeId": "1", "Id": "44871322", "Score": "1", "Body": "<p>I'm trying to write a \"power\" function using templates.</p>\n<pre><code>#define VAR_X 2.0f\n\ntemplate &lt;int N&gt; struct Power\n{\n    static const float ret = VAR_X * Power&lt;N-1&gt;::ret;\n};\n\ntemplate &lt;&gt; struct Power&lt;0&gt;\n{\n    static const float ret = 1.0f;\n};\n</code></pre>\n<p>I used a macro for the variable because floating point numbers can't be used as template parameters. When I try to compile with g++ 5.4.0, I get this:</p>\n<pre><code>tmptrig.cpp: In instantiation of \u2018const float Power&lt;1&gt;::ret\u2019:\ntmptrig.cpp:35:28:   required from here\ntmptrig.cpp:17:24: error: the value of \u2018Power&lt;0&gt;::ret\u2019 is not usable in a constant expression\n     static const float ret = VAR_X * Power&lt;N-1&gt;::ret;\n                        ^\ntmptrig.cpp:22:24: note: \u2018Power&lt;0&gt;::ret\u2019 does not have integral or enumeration type\n     static const float ret = 1.0f;\n</code></pre>\n<p>However, when I change the program to only deal with integers, it works fine.</p>\n<pre><code>#define VAR_X 2\n\ntemplate &lt;int N&gt; struct Power\n{\n    static const int ret = VAR_X * Power&lt;N-1&gt;::ret;\n};\n\ntemplate &lt;&gt; struct Power&lt;0&gt;\n{\n    static const int ret = 1;\n};\n</code></pre>\n<p>I know that floating point numbers cannot be used as template parameters, but (as far as I know) that's not how they're being treated here. Why doesn't the compiler like it when I use floats?</p>\n<p><strong>Edit</strong>: this is what my <code>main</code> looks like:</p>\n<pre><code>int main(int argc, char *argv[])\n{\n    std::cout &lt;&lt; Power&lt;1&gt;::ret &lt;&lt; std::endl;\n}\n</code></pre>\n", "Tags": "<c++><templates><floating-point><template-meta-programming>", "OwnerUserId": "8229114", "AnswerCount": "2"}, "44871367": {"ParentId": "44871322", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The problem is not that floating point numbers cannot be constant expressions, because they can (despite not being admissible as template non-type parameters). The problem is that your code needs to mark them a such explicitly, or they cannot be initialized in the class defintion itself.</p>\n<pre><code>#include &lt;iostream&gt;\n\nfloat constexpr var_x = 2.0f;\n\ntemplate &lt;int N&gt; struct Power\n{\n    static constexpr float ret = var_x * Power&lt;N-1&gt;::ret;\n};\n\ntemplate &lt;&gt; struct Power&lt;0&gt;\n{\n    static constexpr float ret = 1.0f;\n};\n\nint main(int argc, char *argv[])\n{\n    std::cout &lt;&lt; Power&lt;1&gt;::ret &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It's pretty much the same as your original intent, since <code>constexpr</code> implies <code>const</code>.</p>\n<p>Clang gives a more helpful warning about your original code:</p>\n<pre class=\"lang-none prettyprint-override\"><code>error: in-class initializer for static data member of type 'const float' requires 'constexpr' specifier [-Wstatic-float-init]\n    static const float ret = VAR_X * Power&lt;N-1&gt;::ret;\n</code></pre>\n<hr>\n<p>They can even be made constant expressions (and the results of meta-functions) in C++03, but that requires an out of class definition:</p>\n<pre><code>float const var_x = 2.0f;\n\ntemplate &lt;int N&gt; struct Power\n{\n    static const float ret;\n};\n\ntemplate &lt;int N&gt;\nconst float Power&lt;N&gt;::ret = var_x * Power&lt;N-1&gt;::ret;\n\ntemplate &lt;&gt; struct Power&lt;0&gt;\n{\n    static const float ret;\n};\n\nconst float Power&lt;0&gt;::ret = 1.0f;\n</code></pre>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-07-03T05:41:40.673", "Id": "44871367", "Score": "1", "CreationDate": "2017-07-02T13:34:58.110", "LastActivityDate": "2017-07-03T05:41:40.673"}, "bq_ids": {"n4140": {"so_44871322_44871623_0": {"section_id": 5908, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_44871322_44871623_0": {"section_id": 5680, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_44871322_44871623_0": {"section_id": 7390, "quality": 1.0, "length": 21}}}, "44871623": {"ParentId": "44871322", "CommentCount": "0", "Body": "<p>The reason why the <code>int</code> version works is because, well, it cheats.</p>\n<p>From <a href=\"http://eel.is/c++draft/class.static.data#3\" rel=\"nofollow noreferrer\">[class.static.data]</a></p>\n<blockquote>\n<p id=\"so_44871322_44871623_0\">If a non-volatile non-inline const static data member is of <strong>integral or enumeration type</strong>, its declaration in the class definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression</p>\n</blockquote>\n<p>For how to actually write correct code, check out <a href=\"https://stackoverflow.com/a/44871367/4832499\">StoryTeller's answer</a></p>\n", "OwnerUserId": "4832499", "PostTypeId": "2", "Id": "44871623", "Score": "0", "CreationDate": "2017-07-02T14:05:20.717", "LastActivityDate": "2017-07-02T14:05:20.717"}});