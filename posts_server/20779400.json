post_cb({"20779486": {"ParentId": "20779400", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-12-26T05:13:55.833", "Id": "20779486", "LastEditDate": "2017-05-23T10:25:30.177", "OwnerDisplayName": "user1508519", "Score": "2", "Body": "<p>This <a href=\"http://social.msdn.microsoft.com/Forums/vstudio/en-US/637a4c27-3e30-4b88-b36d-b5b720cf0d04/why-are-cout-cin-initialized-once-and-only-once-given-the-scheme-below-in-the-iostream?forum=vclanguage\" rel=\"nofollow noreferrer\">MSDN forum link</a> provides a code snippet:</p>\n<pre><code>#include &lt;ostream&gt;\n#include &lt;istream&gt;\n\nnamespace std\n{\n    extern istream cin;\n    extern ostream cout;\n    ....\n\n    // this is explained below\n    static ios_base::Init __foo;    // not its real name\n} \n</code></pre>\n<p>Relevant quote:</p>\n<blockquote>\n<p id=\"so_20779400_20779486_0\">Now, the runtime penalty mentioned previously: the global objects must\n  be initialized before any of your own code uses them; this is\n  guaranteed by the standard. Like any other global object, they must be\n  initialized once and only once. This is typically done with a\n  construct like the one above, and the nested class ios_base::Init is\n  specified in the standard for just this reason.</p>\n</blockquote>\n<p>And the <a href=\"https://stackoverflow.com/a/8784923/1508519\">standard quote</a>:</p>\n<blockquote>\n<p id=\"so_20779400_20779486_1\">According to \u00a727.3/2: \"The objects [std::cin, std::cout, etc.] are\n  constructed, and the associations are established at some time prior\n  to or during first time an object of class ios_base::Init is\n  constructed, and in any case before the body of main begins\n  execution.\"</p>\n</blockquote>\n<p>The culprit is indeed the <code>ios_base::Init</code> line, as <a href=\"https://stackoverflow.com/questions/20779400/why-so-much-boilerplate-for-iostream-in-assembly-output#comment31146931_20779400\">cHao</a>'s comment suggests. So if the msdn link is correct, then that means that <code>&lt;iostream&gt;</code> is <a href=\"http://coliru.stacked-crooked.com/a/bb239d23df36a638\" rel=\"nofollow noreferrer\">special</a> for that reason.</p>\n", "LastActivityDate": "2013-12-26T05:13:55.833", "LastEditorUserId": "-1"}, "20779400": {"CommentCount": "3", "ViewCount": "330", "PostTypeId": "1", "LastEditorUserId": "1009479", "CreationDate": "2013-12-26T05:03:10.213", "LastActivityDate": "2013-12-26T05:13:55.833", "LastEditDate": "2013-12-26T05:07:12.990", "AcceptedAnswerId": "20779486", "OwnerDisplayName": "user1508519", "Title": "Why so much boilerplate for iostream in assembly output?", "Id": "20779400", "Score": "2", "Body": "<p>For the following code:</p>\n<pre><code>int main()\n{\n}\n</code></pre>\n<p>For <code>g++ -pedantic -Wall -O3 -S -o test.asm test.cpp &amp;&amp; cat test.asm</code>, the assembly output is unsurprisingly clean. If I do <code>gcc -x c ... test c</code> with <code>#include &lt;stdio.h&gt;</code> at the top, the output is <b>identical</b> except for the label names. Actually it doesn't matter if it's in <code>C++</code> or <code>C</code> mode. Other headers like <code>&lt;string&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;algorithm&gt;</code>, <code>&lt;ostream&gt;</code> etc. give identical results.</p>\n<pre><code>    .file   \"test.cpp\"\n    .section    .text.unlikely,\"ax\",@progbits\n.LCOLDB0:\n    .section    .text.startup,\"ax\",@progbits\n.LHOTB0:\n    .p2align 4,,15\n    .globl  main\n    .type   main, @function\nmain:\n.LFB0:\n    .cfi_startproc\n    xorl    %eax, %eax\n    ret\n    .cfi_endproc\n.LFE0:\n    .size   main, .-main\n    .section    .text.unlikely\n.LCOLDE0:\n    .section    .text.startup\n.LHOTE0:\n    .ident  \"GCC: (GNU) 4.9.0 20131223 (experimental)\"\n    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>But as soon as you add <code>#include &lt;iostream&gt;</code>, it blows up (identical part omitted):</p>\n<pre><code>    .section    .text.unlikely\n.LCOLDE0:\n    .section    .text.startup\n.LHOTE0:\n    .section    .text.unlikely\n.LCOLDB1:\n    .section    .text.startup\n.LHOTB1:\n    .p2align 4,,15\n    .type   _GLOBAL__sub_I_main, @function\n_GLOBAL__sub_I_main:\n.LFB1027:\n    .cfi_startproc\n    subq    $8, %rsp\n    .cfi_def_cfa_offset 16\n    movl    $_ZStL8__ioinit, %edi\n    call    _ZNSt8ios_base4InitC1Ev\n    movl    $__dso_handle, %edx\n    movl    $_ZStL8__ioinit, %esi\n    movl    $_ZNSt8ios_base4InitD1Ev, %edi\n    addq    $8, %rsp\n    .cfi_def_cfa_offset 8\n    jmp __cxa_atexit\n    .cfi_endproc\n.LFE1027:\n    .size   _GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main\n    .section    .text.unlikely\n.LCOLDE1:\n    .section    .text.startup\n.LHOTE1:\n    .section    .init_array,\"aw\"\n    .align 8\n    .quad   _GLOBAL__sub_I_main\n    .local  _ZStL8__ioinit\n    .comm   _ZStL8__ioinit,1,1\n    .hidden __dso_handle\n    .ident  \"GCC: (GNU) 4.9.0 20131223 (experimental)\"\n    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>What makes <code>&lt;iostream&gt;</code> special?</p>\n<p>One quote that might be relevant is:</p>\n<blockquote>\n<p id=\"so_20779400_20779400_0\">In terms of static initialization order, cout is guaranteed to be\n  properly constructed and initialized no later than the first time an\n  object of type ios_base::Init is constructed, with the inclusion of\n   counting as at least one initialization of such objects\n  with static duration.</p>\n</blockquote>\n", "Tags": "<c++><gcc><assembly>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20779400_20779486_1": {"section_id": 1920, "quality": 0.7692307692307693, "length": 20}}, "n3337": {"so_20779400_20779486_1": {"section_id": 1909, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_20779400_20779486_1": {"section_id": 2191, "quality": 0.7692307692307693, "length": 20}}}});