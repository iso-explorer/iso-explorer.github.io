post_cb({"bq_ids": {"n4140": {"so_42088015_42089831_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 5966}}, "n3337": {"so_42088015_42089831_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 5735}}, "n4659": {"so_42088015_42089831_0": {"length": 8, "quality": 1.0, "section_id": 7468}, "so_42088015_42089831_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 7460}}}, "42089177": {"Id": "42089177", "PostTypeId": "2", "Body": "<p>I'm trying to pack together a few comments to the question to give you a meaningful answer.<br>\nFirst of all, note that:</br></p>\n<ul>\n<li>Non-static data members are declared for the lambda for each copy-captured variable</li>\n<li>In the specific case, the lambda has a closure type which has a public inline template function call operator accepting a parameter named <code>foo</code></li>\n</ul>\n<p>Therefore the logic would make me say at a first glance that the parameter should shadow the captured variable as if in:</p>\n<pre><code>struct Lambda {\n    template&lt;typename T&gt; void operator()(T foo) const { /* ... */ }\n    private: decltype(outer_foo) foo{outer_foo};\n};\n</code></pre>\n<p>Anyway, @n.m. correctly noted that the non-static data members declared for copy-captured variables are actually unnamed. That being said, the unnamed data member is still accessed by means of an identifier (that is <code>foo</code>). Therefore, the parameter name of the function call operator should still (let me say) <em>shadow that identifier</em>.<br>\nAs correctly pointed out by @n.m. in the comments to the question:</br></p>\n<blockquote>\n<p id=\"so_42088015_42089177_0\">the original captured entity [...] should be shadowed normally according to scope rules</p>\n</blockquote>\n<p>Because of that, I'd say that clang is right.</p>\n", "LastEditorUserId": "4987285", "LastActivityDate": "2017-02-07T12:59:14.073", "Score": "6", "CreationDate": "2017-02-07T11:51:00.823", "ParentId": "42088015", "CommentCount": "2", "OwnerUserId": "4987285", "LastEditDate": "2017-02-07T12:59:14.073"}, "42088015": {"ViewCount": "3448", "Body": "<pre><code>auto foo = \"You're using g++!\";\nauto compiler_detector = [foo](auto foo) { std::puts(foo); };\ncompiler_detector(\"You're using clang++!\");\n</code></pre>\n<ul>\n<li><p><strong>clang++ 3.6.0</strong> and newer print out <em>\"You're using clang++!\"</em> and warn about the <strong>capture</strong> <code>foo</code> being unused.</p></li>\n<li><p><strong>g++ 4.9.0</strong> and newer print out <em>\"You're using g++!\"</em> and warn about the <strong>parameter</strong> <code>foo</code> being unused.</p></li>\n</ul>\n<p>What compiler is more accurately following the C++ Standard here?</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/FFngRM4CwRdtcCBl\"><strong>wandbox example</strong></a></p>\n", "AcceptedAnswerId": "42089831", "Title": "Lambda capture and parameter with same name - who shadows the other? (clang vs gcc)", "CreationDate": "2017-02-07T10:56:29.803", "Id": "42088015", "CommentCount": "11", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-02-07T16:39:42.983", "LastEditorUserId": "598696", "LastActivityDate": "2017-09-19T19:21:17.430", "Score": "121", "OwnerUserId": "598696", "Tags": "<c++><c++11><lambda><language-lawyer><shadowing>", "AnswerCount": "2"}, "42089831": {"Id": "42089831", "PostTypeId": "2", "Body": "<p>Update: as promised by the Core chair in the bottom quote, the code is <a href=\"http://eel.is/c++draft/expr.prim.lambda#capture-5\" rel=\"nofollow noreferrer\">now ill-formed</a>:</p>\n<blockquote>\n<p id=\"so_42088015_42089831_0\">If an <em>identifier</em> in a <em>simple-capture</em> appears as the <em>declarator-id</em> of a parameter of the <em>lambda-declarator</em>'s <em>parameter-declaration-clause</em>, the program is ill-formed.</p>\n</blockquote>\n<hr>\n<p>There were a few issues concerning name lookup in lambdas a while ago. They were resolved by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf\" rel=\"nofollow noreferrer\">N2927</a>:</p>\n<blockquote>\n<p id=\"so_42088015_42089831_1\">The new wording no longer relies on lookup to remap uses of captured entities. <strong>It more clearly\n  denies the interpretations that a lambda's <em>compound-statement</em> is processed in two passes or that any names in that <em>compound-statement</em> might resolve to a member of the closure type.</strong></p>\n</blockquote>\n<p>Lookup is always done in the context of the <em>lambda-expression</em>, never \"after\" the transformation to a closure type's member function body. See <a href=\"http://eel.is/c++draft/expr.prim.lambda#8\" rel=\"nofollow noreferrer\">[expr.prim.lambda]/8</a>:</p>\n<blockquote>\n<p id=\"so_42088015_42089831_2\">The <em>lambda-expression</em>'s <em>compound-statement</em> yields the <em>function-body</em> ([dcl.fct.def]) of the function call operator, but for purposes of name lookup, [\u2026], the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em>. [ <em>Example</em>:</p>\n<pre><code>struct S1 {\n  int x, y;\n  int operator()(int);\n  void f() {\n    [=]()-&gt;int {\n      return operator()(this-&gt;x+y);  // equivalent to: S1::operator()(this-&gt;x+(*this).y)\n                                     // and this has type S1*\n    }; \n  }\n};\n</code></pre>\n<p id=\"so_42088015_42089831_3\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p><sub>(The example also makes clear that lookup does not somehow consider the generated capture member of the closure type.)</sub></p>\n<p>The name <code>foo</code> is not (re)declared in the capture; it is declared in the block enclosing the lambda expression. The parameter <code>foo</code> is declared in a block that is nested in that outer block (see <a href=\"http://eel.is/c++draft/basic.scope.block#2\" rel=\"nofollow noreferrer\">[basic.scope.block]/2</a>, which also explicitly mentions lambda parameters). The order of lookup is clearly <a href=\"http://eel.is/c++draft/basic.lookup.unqual#6\" rel=\"nofollow noreferrer\">from inner to outer blocks</a>. Hence the parameter should be selected, that is, Clang is right.</p>\n<p>If you were to make the capture an init-capture, i.e. <code>foo = \"\"</code> instead of <code>foo</code>, the answer would not be clear. This is because the capture now actually <a href=\"http://eel.is/c++draft/expr.prim.lambda#12\" rel=\"nofollow noreferrer\">induces a declaration</a> whose \"block\" is not given. I messaged the core chair on this, who replied</p>\n<blockquote>\n<p id=\"so_42088015_42089831_4\">This is issue 2211 (a new issues list will appear on the open-std.org site shortly, unfortunately with just placeholders for a number of issues, of which this is one; I'm working hard to fill in those gaps before the Kona meeting at the end of the month). CWG discussed this during our January teleconference, and <strong>the direction is to make the program ill-formed if a capture name is also a parameter name.</strong> </p>\n</blockquote>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2017-09-19T19:21:17.430", "Score": "63", "CreationDate": "2017-02-07T12:22:42.427", "ParentId": "42088015", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2017-09-19T19:21:17.430"}});