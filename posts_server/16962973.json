post_cb({"bq_ids": {"n4140": {"so_16962973_16966072_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 774}, "so_16962973_16966072_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}}, "n3337": {"so_16962973_16966072_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 761}, "so_16962973_16966072_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}}, "n4659": {"so_16962973_16966072_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}}}, "17121515": {"Id": "17121515", "PostTypeId": "2", "Body": "<p>For one-dimensional arrays, this might work in all cases, the 2D case is more tricky:</p>\n<p>In principle, it is possible for the std::array &lt; &gt; template to only consist of the array itself because its length argument is a compile time variable which does not need to be stored. However, your STL-implementation might have chosen to store it anyway, or any other data it needs. So, while '&amp;a[n] == &amp;a[0] + n' holds for any std::array, the expression '&amp;a[n][0] == &amp;a[0][0] + n*arrayWidth' might not hold for a 'std::array &lt; std::array, arrayHeight &gt;'.</p>\n<p>Still you might want to check whether 'sizeof(std::array &lt; int, 100 &gt;) == sizeof(int) * 100' with your STL-implementation. If it does, it should be safe to replace even the 2D arrays.</p>\n", "LastActivityDate": "2013-06-15T08:07:50.333", "CommentCount": "2", "CreationDate": "2013-06-15T08:07:50.333", "ParentId": "16962973", "Score": "3", "OwnerUserId": "2445184"}, "16966072": {"Id": "16966072", "PostTypeId": "2", "Body": "<p>It depends on STL implementation. I means, the standard does not prevent to implement <code>std::array</code> using more members, or reserving more memory of that is really necessary (for example, for debugging), but I think is very improbable to found one <code>std::array</code> implementation without just use more of <code>T elem[N];</code> data member.</p>\n<p>If we assume the std::array implementation includes just one field for store the data and it allocate just the necessary memory (not more), <code>int v[100];</code> and where the data is stored in <code>array&lt;int, 100&gt; v;</code> will have the same layout, since from the standard:</p>\n<p>[array.overview 23.3.2.1 p1]:</p>\n<blockquote>\n<p id=\"so_16962973_16966072_0\">The elements of an array are stored contiguously, meaning that if <code>a</code> is\n  an <code>array&lt;T, N&gt;</code> then it obeys the identity <code>&amp;a[n] == &amp;a[0] + n</code> for all <code>0 &lt;= n &lt; N</code>.</p>\n</blockquote>\n<p>and [class.mem 9.2 p20]:</p>\n<blockquote>\n<p id=\"so_16962973_16966072_1\">A pointer to a standard-layout struct object, suitably converted using\n  a <code>reinterpret_cast</code>, points to its initial member (or if that member is\n  a bit-field, then to the unit in which it resides) and vice versa. [\n  Note: There might therefore be unnamed padding within a\n  standard-layout struct object, but not at its beginning, as necessary\n  to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n<p>Anyway, that depends on compiler and STL implementation. But the reversed code depends on compiler too. Why are you assuming int <code>a; int b[50];</code> will locate <code>a</code> and then array of <code>b</code> in memory in that order and not in the other if that declarations are not part of a <code>struct</code> or <code>class</code>? The compiler would decide other thing for performance reasons (but I see that is improbable). </p>\n", "LastActivityDate": "2013-06-06T15:24:47.160", "CommentCount": "2", "CreationDate": "2013-06-06T15:24:47.160", "ParentId": "16962973", "Score": "2", "OwnerUserId": "2095459"}, "16965787": {"Id": "16965787", "PostTypeId": "2", "Body": "<p>I wonder how that replacement should even work in code full of pointer arithmetic.</p>\n<pre><code>/// @file array_eval.cpp\n#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;algorithm&gt;\n\n\nint main() {\n    auto dump = [](const int&amp; n){std::cout &lt;&lt; n &lt;&lt; \" \";};\n\n#ifdef DO_FAIL\n    std::array&lt;int, 10&gt; arr;\n#else    \n    int arr[10];\n#endif\n\n    // this does not work for std::arrays\n    int* p = arr; \n\n    std::for_each(p, p+10, dump);\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>And </p>\n<pre><code>g++ -Wall -pedantic -std=c++11 -DDO_FAIL array_eval.cpp \n</code></pre>\n<p>of course fails:</p>\n<pre><code>array_eval.cpp: In function \u2018int main()\u2019:\narray_eval.cpp:17:14: error: cannot convert \u2018std::array&lt;int, 10ul&gt;\u2019 to \u2018int*\u2019 in initialization\n     int* p = arr; \n              ^\n</code></pre>\n", "LastActivityDate": "2013-06-06T15:13:00.860", "CommentCount": "5", "CreationDate": "2013-06-06T15:13:00.860", "ParentId": "16962973", "Score": "2", "OwnerUserId": "2378245"}, "16962973": {"ViewCount": "2368", "Body": "<p>First time questioner :)\nIs it possible to transform global c-style arrays to std::arrays without breaking the code? I'm working on a project which consists of decompiling the source code of an old game. We have already managed to refactor a large part of the disassembly/decompilation output. Since it's automatic there are still sections like</p>\n<pre><code>  int a;\n  int b[50];\n  *(&amp;a + 100) = xxx;\n</code></pre>\n<p>or</p>\n<pre><code>  int b[50];\n  int a;\n  *(&amp;a - 100) = xxx;\n</code></pre>\n<p>and other types of crazy pointer arithmetics remaining, which have yet to be refactored manually. But we would like to use bounds checking for sections that have been (presumably) correctly changed to arrays.</p>\n<p>(<strong>Ignore the text in italics, I'm keeping it just for consistency in the comments</strong>)<em>I've found one problem so far with chaning every array: <code>sizeof(class containing array)</code> would change. This could break code in some cycles, for example\n    someclass somearray[100];\n    //for example (sizeof(somearray[0]) == 50) is true\n    int pointer = (int)somearray;\n    pointer += 100\n    ((someclass</em>)pointer)-&gt;doSomething();\n.<em>because <code>pointer +=100</code> wouldn't be pointing to the second element, but somewhere inside the first, or even zeroth, I'm not sure (don't forget it's automatically decompiled code, hence the ugliness).</em></p>\n<p>I'm thinking of changing every global array to std::array and every instance of accessing the array without the <code>[]</code> operator to <code>array._Elems</code>.</p>\n<p>Are there any problems that might arise if I were to change global arrays to std::arrays in code such as this?</p>\n<p><strong>Edit</strong>\nYou were right about the size not changing. I had an error in the testing functions. So I'll expand the question:</p>\n<p>Is it safe to change every c-style array to std::array?</p>\n<p><strong>Edit</strong>\nOur current code is actually only runnable in debug mode, since it doesn't move variables around. Release mode crashes basically at the start of the program.</p>\n<p><strong>Edit</strong>\nSince there seems to be some confusion what this question is about, let me clarify: Is there some guarantee that there's no other member in the array, other than T elems [N] ?\nCan I count on having </p>\n<pre><code>array&lt;array&lt;int,10&gt;, 10&gt; varname;\nint* ptr = &amp;varname[0][0];\nptr += 10\n</code></pre>\n<p>and be sure that ptr is pointing at <code>varname[1][0]</code> regardless of implementation details? Although it's guaranteed that an array is contiguous, I'm not sure about this. The standard contains an implementation, but I'm not sure whether that's an example implementation or the actual definition which every implementation should adhere with iterator and const_iterator being the only things that are implementation specific, since only those have the words <em>implementation-defined</em> (I don't have the latest specifiation at hand, so there might be some other differences).</p>\n", "AcceptedAnswerId": "17121515", "Title": "Is a C-Style array to std::array transition completely safe for arrays?", "CreationDate": "2013-06-06T13:09:06.107", "Id": "16962973", "CommentCount": "15", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-10-19T17:18:19.460", "LastEditorUserId": "2459583", "LastActivityDate": "2014-10-19T17:18:19.460", "Score": "15", "OwnerUserId": "2459583", "Tags": "<c++><arrays><c++11><disassembly><stdarray>", "AnswerCount": "3"}});