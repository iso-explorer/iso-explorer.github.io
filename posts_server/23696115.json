post_cb({"bq_ids": {"n4140": {"so_23696115_23696175_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 548}}, "n3337": {"so_23696115_23696175_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 539}}, "n4659": {"so_23696115_23696175_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 569}}}, "23699893": {"Id": "23699893", "PostTypeId": "2", "Body": "<p><code>#pragma once</code> is <em>not</em> standard.  It is a widespread (but not\nuniversal) extension, which can be used </p>\n<ul>\n<li>if your portability concerns are limited, and</li>\n<li>you can be sure that all of your include files are always on a local disk.</li>\n</ul>\n<p>It was considered for standardization, but rejected because it\ncannot be implemented reliably.  (The problems occur when you\nhave files accessible through several different remote mounts.)</p>\n<p>It's fairly easy to ensure that there are no include guard\nconflicts within a single development.  For libraries, which may\nbe used by many different developments, the obvious solution is\nto generate a lot of random characters for the include guard\nwhen you create it.  (A good editor can be set up to do this for\nyou whenever you open a new header.)  But even without this,\nI've yet to encounter any problems with conflicts between\nlibraries.</p>\n", "LastActivityDate": "2014-05-16T16:08:00.823", "CommentCount": "15", "CreationDate": "2014-05-16T16:08:00.823", "ParentId": "23696115", "Score": "79", "OwnerUserId": "649665"}, "23696175": {"Id": "23696175", "PostTypeId": "2", "Body": "<p>Section \u00a716.6 of the Standard (<a href=\"https://github.com/cplusplus/draft/blob/master/papers/N3936.pdf\">N3936</a> draft) describes <code>#pragma</code> directives as:</p>\n<blockquote>\n<p id=\"so_23696115_23696175_0\">A preprocessing directive of the form </p>\n<pre><code># pragma pp-tokensopt new-line\n</code></pre>\n<p id=\"so_23696115_23696175_1\">causes the implementation to behave in an implementation-defined\n  manner. The behavior might cause translation to fail or cause the\n  translator or the resulting program to behave in a non-conforming\n  manner. Any pragma that is not recognized by the implementation is\n  ignored.</p>\n</blockquote>\n<p>Basically <code>#pragma once</code> is an implementation specific instance of a <code>#pragma</code> directive, and no, it's not standard. Yet. </p>\n<p>It is often widely supported by most \"major compilers\" including <a href=\"http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC8\">GCC</a> and <a href=\"http://clang.llvm.org/docs/InternalsManual.html#multipleincludeopt\">Clang</a> and is therefore sometimes recommended to avoid include-guards boilerplate.</p>\n", "LastEditorUserId": "493122", "LastActivityDate": "2014-05-16T13:27:59.130", "Score": "25", "CreationDate": "2014-05-16T13:22:32.093", "ParentId": "23696115", "CommentCount": "17", "OwnerUserId": "493122", "LastEditDate": "2014-05-16T13:27:59.130"}, "23696115": {"ViewCount": "28251", "Body": "<p>Traditionally, the standard and portable way to avoid multiple header inclusions in C++ was/is  to use the <code>#ifndef - #define - #endif</code>pre-compiler directives scheme also called <a href=\"http://en.wikipedia.org/wiki/Include_guard\">macro-guard scheme</a> (see code snippet below).</p>\n<pre><code>#ifndef MY_HEADER_HPP\n#define MY_HEADER_HPP\n...\n#endif\n</code></pre>\n<p>In most implementations/compilers (see picture below) however, there's a more \"elegant\" alternative that serves the same purpose as the macro-guard scheme called <a href=\"http://en.wikipedia.org/wiki/Pragma_once\"><code>#pragma once</code></a>. <code>#pragma once</code> has several advantages compared to the macro-guard scheme, including less code, avoidance of name clashes, and sometimes improved compile speed.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/qDohP.png\"/></p>\n<p>Doing some research, I realized that although <code>#pragma once</code> directive is supported by almost all known compilers, there's a turbidness on whether <code>#pragma once</code> directive is part of the C++11 standard or not.</p>\n<h2><strong>Questions:</strong></h2>\n<ul>\n<li>Could someone clarify whether <code>#pragma once</code> directive is part of the C++11 standard or not?</li>\n<li>If it's not part of the C++11 standard, are there any plans on including it on later releases (e.g., C++14 or later)?</li>\n<li>It would also be nice if someone could further elaborate on the advantages/disadvantages in using either one of the techniques (i.e., macro-guard versus <code>#pragma once</code>).</li>\n</ul>\n", "AcceptedAnswerId": "23699893", "Title": "Is #pragma once part of the C++11 standard?", "CreationDate": "2014-05-16T13:20:24.863", "Id": "23696115", "CommentCount": "6", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2014-05-16T22:58:11.240", "LastEditorUserId": "2352671", "LastActivityDate": "2014-05-16T22:58:11.240", "Score": "112", "OwnerUserId": "2352671", "Tags": "<c++><c++11><macros><header-files><c++14>", "AnswerCount": "2"}});