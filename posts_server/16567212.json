post_cb({"bq_ids": {"n4140": {"so_16567212_16567212_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 133}}, "n3337": {"so_16567212_16567212_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 127}}, "n4659": {"so_16567212_16567212_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 137}}}, "16567212": {"ViewCount": "895", "Body": "<p>The C++ standard prohibits friend declarations of partial specializations. (\u00a714.5.3/8):</p>\n<blockquote>\n<p id=\"so_16567212_16567212_0\">Friend declarations shall not declare partial specializations. [Example:</p>\n</blockquote>\n<pre><code>template&lt;class T&gt; class A { };\nclass X {\n    template &lt;class T&gt; friend class A&lt;T*&gt;;   //error\n};\n</code></pre>\n<blockquote>\n<p id=\"so_16567212_16567212_1\">--end example]</p>\n</blockquote>\n<p>Other questions, e.g. <a href=\"https://stackoverflow.com/q/1458752/1362568\">this one</a>, \nhave received answers that invoke this prohibition, but I would like to know the\nrationale. I don't see it and can't find it with my favourite search engine. I \ncan find however that it goes right back to the C++98 standard, so presumably \nthe rationale is quite basic and clear. Can someone explain it to me?</p>\n", "Title": "Why does the Standard prohibit friend declarations of partial specializations?", "CreationDate": "2013-05-15T14:03:05.327", "LastActivityDate": "2013-05-15T14:29:44.673", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:01:03.307", "LastEditorUserId": "-1", "Id": "16567212", "Score": "14", "OwnerUserId": "1362568", "Tags": "<c++><friend><template-specialization>", "AnswerCount": "2"}, "16567481": {"Id": "16567481", "PostTypeId": "2", "Body": "<p>Here is some undirect explanation:\n<a href=\"http://www.cprogramming.com/tutorial/template_specialization.html\" rel=\"nofollow\">http://www.cprogramming.com/tutorial/template_specialization.html</a></p>\n<blockquote>\n<p id=\"so_16567212_16567481_0\">A final implementation detail comes up with partial specializations:\n  how does the compiler pick which specialization to use if there are a\n  combination of completely generic types, some partial specializations,\n  and maybe even some full specializations? The general rule of thumb is\n  that the compiler will pick the most specific template\n  specialization--the most specific template specialization is the one\n  whose template arguments would be accepted by the other template\n  declarations, but which would not accept all possible arguments that\n  other templates with the same name would accept.</p>\n</blockquote>\n<p>I infer that maybe it is not permitted to prevent any ambiguity in the determination of specialization type.</p>\n", "LastEditorUserId": "2183287", "LastActivityDate": "2013-05-15T14:18:11.210", "Score": "0", "CreationDate": "2013-05-15T14:14:37.997", "ParentId": "16567212", "CommentCount": "3", "LastEditDate": "2013-05-15T14:18:11.210", "OwnerUserId": "2183287"}, "16567858": {"Id": "16567858", "PostTypeId": "2", "Body": "<p>I don't have a reference but I suspect that this is because it would result in the partial specialization being declared in the scope of the friend-declaring class rather than the scope of the template in question, and rather than creating a bunch of rules to force the friend declaration to result in the specialization being in the correct scope, they simply prohibit it.</p>\n", "LastActivityDate": "2013-05-15T14:29:44.673", "Score": "1", "CreationDate": "2013-05-15T14:29:44.673", "ParentId": "16567212", "CommentCount": "1", "OwnerUserId": "251738"}});