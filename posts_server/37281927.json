post_cb({"37281965": {"ParentId": "37281927", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>std::move</code> doesn't do anything to the object! All it does is <em>casting</em> an object to an ravlue, so that it can be bound by rvalue reference.</p>\n<p>Any modifications to the object are done by corresponding move constructor or move assingnment operator. If none are called, nothing happens at all.</p>\n", "OwnerUserId": "5245033", "LastEditorUserId": "5245033", "LastEditDate": "2016-05-17T17:16:28.373", "Id": "37281965", "Score": "6", "CreationDate": "2016-05-17T16:40:09.520", "LastActivityDate": "2016-05-17T17:16:28.373"}, "37282416": {"ParentId": "37281927", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_37281927_37282416_0\">But I'm having trouble understanding the difference between <code>std::move(x).something()</code> and <code>y = std::move(x); y.something()</code></p>\n</blockquote>\n<p>With (note the <code>&amp;</code>/<code>&amp;&amp;</code> after <code>const</code>)</p>\n<pre><code>struct S\n{\n    void foo() const &amp; {std::cout &lt;&lt; \"l-value this\\n\"; }\n    void foo() const &amp;&amp; {std::cout &lt;&lt; \"r-value this\\n\"; }\n};\n</code></pre>\n<p>You got:    </p>\n<pre><code>S tmp;\nstd::move(tmp).foo(); // \"r-value this\n\nS x = std::move(tmp);\nx.foo(); // \"l-value this\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "37282416", "Score": "0", "CreationDate": "2016-05-17T17:07:53.870", "LastActivityDate": "2016-05-17T17:07:53.870"}, "bq_ids": {"n4140": {"so_37281927_37281927_0": {"section_id": 1341, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_37281927_37281927_0": {"section_id": 1335, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_37281927_37281927_1": {"section_id": 7709, "quality": 1.0, "length": 13}, "so_37281927_37281927_2": {"section_id": 7709, "quality": 0.85, "length": 17}, "so_37281927_37281927_0": {"section_id": 1471, "quality": 0.6666666666666666, "length": 4}}}, "37281927": {"CommentCount": "7", "ViewCount": "50", "PostTypeId": "1", "LastEditorUserId": "6292850", "CreationDate": "2016-05-17T16:38:16.613", "LastActivityDate": "2016-05-17T17:16:28.373", "Title": "Performing some operation on std::move(x)", "LastEditDate": "2016-05-17T16:56:12.440", "Id": "37281927", "Score": "2", "Body": "<p>Let's get the formalities out of the way.</p>\n<blockquote>\n<p id=\"so_37281927_37281927_0\">17.3.28 valid but unspecified state [defns.valid]</p>\n<p id=\"so_37281927_37281927_1\">an object state that is not specified except that the object's\n  invariants are met and operations on the object behave as specified\n  for its type </p>\n<p id=\"so_37281927_37281927_2\">[ <em>Example:</em> If an object <code>x</code> of type <code>std::vector&lt;int&gt;</code> is\n  in a valid but unspecified state, <code>x.empty()</code> can be called\n  unconditionally, and <code>x.front()</code> can be called only if <code>x.empty()</code> returns\n  false.  \u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Some users have suggested that <code>std::move(x).something()</code> is nonsensical. But I'm having trouble understanding the difference between <code>std::move(x).something()</code> and <code>y = std::move(x); y.something()</code>. Observe:</p>\n<pre><code>// -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC\nstd::vector&lt;int&gt; v;\nv.pop_back();\n// Error: attempt to access an element in an empty container.\n</code></pre>\n<p>Now we want to try our nonsensical case:</p>\n<pre><code>std::vector&lt;int&gt; v(10);\nstd::move(v).pop_back();\n</code></pre>\n<p>No error. This must be the \"valid but unspecified\" everyone's talking about, but let's keep going.</p>\n<pre><code>std::vector&lt;int&gt; v(10);\nstd::cout &lt;&lt; std::move(v).size();\nauto v2 = std::move(v);\nstd::cout &lt;&lt; v.size();\n</code></pre>\n<p>This prints <code>100</code>. That's not too surprising. <code>std::move</code> is just a cast, it doesn't actually perform the job of the move constructor.</p>\n<p>Am I missing something or is <code>std::move(x).something()</code> still non-sensical (other than being a no-op)?</p>\n<hr/>\n<p>For reference, see the comments on <a href=\"https://stackoverflow.com/questions/37262329/member-function-begin-and-stdbegin\">Member function .begin() and std::begin()</a> as well as the upvoted answer.</p>\n<p>The following example suggests that <code>v</code> is not moved from:</p>\n<pre><code>template&lt; class C &gt;\nauto begin( C&amp;&amp; c ) -&gt; decltype(c.begin())\n{\n    return c.begin();\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v(10);\n    std::vector&lt;int&gt;::iterator it3 = begin(std::move(v));\n    std::cout &lt;&lt; v.size();\n}\n</code></pre>\n<p>Outputs <code>10</code>.</p>\n", "Tags": "<c++><move-semantics>", "OwnerUserId": "6292850", "AnswerCount": "2"}});