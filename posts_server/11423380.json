post_cb({"bq_ids": {"n4140": {"so_11423380_11423718_0": {"length": 18, "quality": 0.9, "section_id": 5846}, "so_11423380_11423718_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 179}}, "n3337": {"so_11423380_11423718_0": {"length": 18, "quality": 0.9, "section_id": 5616}, "so_11423380_11423718_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 173}}, "n4659": {"so_11423380_11423718_0": {"length": 18, "quality": 0.9, "section_id": 7325}, "so_11423380_11423718_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 184}}}, "11423985": {"Id": "11423985", "PostTypeId": "2", "Body": "<p>While the phenomenon can probably be attributed to <em>class name injection</em>, as noted in ephemient's answer, for this specific example it has been outlawed by C++ language quite a while ago. </p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#147\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#147</a></p>\n<p>The combination <code>A::A</code> is required to refer to class constructor, not to the class injected name. The <code>A::A(i)</code> is supposed to be interpreted by a compliant compiler as an illegal (and therefore meaningless) expression involving constructor name. Comeau compiler, for one example, will refuse to compile your code for that reason.</p>\n<p>Apparently VC11 continues to treat <code>A::A</code> as a reference to the injected class name. Interestingly enough, I don't observe this problem in VS2005.</p>\n<p>Back in the day when <code>A::A</code> was interpreted as referring to the injected name, one could declare an <code>A</code> object as</p>\n<pre><code>A::A::A::A::A::A a;\n</code></pre>\n<p>and so on, with arbitrary number of <code>A</code>s. But not anymore. Surprisingly, version of GCC (4.3.4?) used by ideone still suffers from this issue</p>\n<p><a href=\"http://ideone.com/OkR0F\" rel=\"noreferrer\">http://ideone.com/OkR0F</a></p>\n<p>You can try this with your version of VC11 and see if it allows that.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2012-07-11T00:56:21.710", "Score": "7", "CreationDate": "2012-07-11T00:41:40.617", "ParentId": "11423380", "CommentCount": "4", "OwnerUserId": "187690", "LastEditDate": "2012-07-11T00:56:21.710"}, "11423380": {"ViewCount": "1345", "Body": "<p>I came across some code like this:</p>\n<pre><code>struct A {\n    A() {}\n    A(int) {}\n};\n\nstruct B : A {\n    void init(int i);\n};\n\nvoid B::init(int i) {\n    A::A(i); // what is this?\n}\n\nint main() {\n    B b;\n    b.init(2);\n}\n</code></pre>\n<p>This compiled and ran using VC11 beta with no errors or warnings with /W4.</p>\n<p>The apparent intent is for calling B::init to reinitialize the B's A base subobject. I believe it actually parses as a variable declaration for a new variable named <code>i</code> with type <code>A</code>. Compiling with clang produces diagnostics:</p>\n<pre><code>ConsoleApplication1.cpp:11:14: warning: declaration shadows a local variable\n        A::A(i);\n             ^\nConsoleApplication1.cpp:10:22: note: previous declaration is here\n    void B::init(int i) {\n                     ^\nConsoleApplication1.cpp:11:14: error: redefinition of 'i' with a different type\n        A::A(i);\n             ^\nConsoleApplication1.cpp:10:22: note: previous definition is here\n    void B::init(int i) {\n                     ^\n</code></pre>\n<p>It seems curious that the type can be referred to with the redundant class qualification.</p>\n<p>Also, <code>A::A(i)</code> appears to be parsed differently by VS11 and clang/gcc. If I do <code>A::A(b)</code> clang and gcc create a variable <code>b</code> of type <code>A</code> using the default constructor. VS11 errors out on that saying <code>b</code> is an unknown identifier. VS11 appears to parse <code>A::A(i)</code> as the creation of a temporary <code>A</code> using the constructor <code>A::A(int)</code> with <code>i</code> as the parameter.  When the redundant qualifier is eliminated VS parses the source as a variable declaration like clang and gcc do, and produces a similar error about shadowing the variable <code>i</code>.</p>\n<p>This difference in parsing explains why VS11 will choke on more than a single extra qualifier; <code>A::A::A::A(i)</code>, and why, given that clang and gcc can accept one extra qualifier, any number more than one extra has the same result as one extra.</p>\n<p>Here's another example with the redundant qualifiers in a different context. All compiler seem to parse this as a temporary construction:</p>\n<pre><code>class Foo {};\n\nvoid bar(Foo const &amp;) {}\n\nint main() {\n    bar(Foo::Foo());\n}\n</code></pre>\n<ol>\n<li>Why are redundant qualifiers allowed at all?</li>\n<li>There are some contexts where constructors can be referred to, such as the syntax for inheriting constructors (<code>class D : B { using B::B; };</code>) but VS seems to be allowing it anywhere. Is VS wrong and are clang and gcc right in how redundant qualifiers are parsed?</li>\n<li>I know VS is still a fair bit behind in terms of standards compliance, but I do find it a bit surprising that modern, actively developed compilers could be so divergent, in this case resolving a redundant qualifier as the name of a constructor (even though constructors don't have names) vs. resolving redundant qualifiers simply to the type, resulting in VS constructing a temporary where the others declare a variable. It can be made even worse where <code>B b(A::A(i));</code> is parsed by clang and gcc as the most vexing parse, but VS sees it as declaring a variable <code>b</code> of type <code>B</code> with an initializer. Are there still many differences this severe?</li>\n<li>Clearly, redundant qualifiers should be avoided in portable code. Is there a good way to prevent this construct from being used?</li>\n</ol>\n", "AcceptedAnswerId": "11423985", "Title": "Why are redundant class name qualifiers allowed?", "CreationDate": "2012-07-10T23:17:11.780", "Id": "11423380", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-07-11T16:33:37.357", "LastEditorUserId": "365496", "LastActivityDate": "2012-07-11T16:33:37.357", "Score": "10", "OwnerUserId": "365496", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "11423718": {"Id": "11423718", "PostTypeId": "2", "Body": "<p>From the ISO/IEC 14882:2011 final draft \u00a79,</p>\n<blockquote>\n<p id=\"so_11423380_11423718_0\">\u00b2 The <em>class-name</em> is inserted into the scope in which it is declared immediately after the <em>class-name</em> is seen.  The <em>class-name</em> is also inserted into the scope of the class itself, this is known as the <em>injected-class-name</em>.</p>\n</blockquote>\n<p>When you write</p>\n<pre><code>A::A(i);\n</code></pre>\n<p>it is the same as the declaration</p>\n<pre><code>A i;\n</code></pre>\n<p>as the extra parentheses are superfluous (you can add as many as you like) and <code>A::A</code> refers to <code>A</code>.</p>\n<hr>\n<p>From \u00a714.6.1,</p>\n<blockquote>\n<p id=\"so_11423380_11423718_1\">\u00b9 Like normal (non-template) classes, class templates have an injected-class-name (Clause 9).  The injected-class-name can be used as a <em>template-name</em> or a <em>type-name</em>.  When it is used with a <em>template-argument-list</em>, as a <em>template-argument</em> for a template <em>template-parameter</em>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, it refers to the class template itself.  Otherwise, it is equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>\n</blockquote>\n<p>The injected class name seems to be a convenience to allow <code>A&lt;...&gt;</code> to be referred to as simply <code>A</code> from within the class.</p>\n</hr>", "LastEditorUserId": "20713", "LastActivityDate": "2012-07-11T00:19:26.020", "Score": "3", "CreationDate": "2012-07-10T23:59:28.760", "ParentId": "11423380", "CommentCount": "3", "OwnerUserId": "20713", "LastEditDate": "2012-07-11T00:19:26.020"}});