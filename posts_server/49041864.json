post_cb({"49041884": {"ParentId": "49041864", "LastActivityDate": "2018-03-01T03:12:35.790", "OwnerUserId": "2684539", "Id": "49041884", "CreationDate": "2018-03-01T02:52:24.123", "LastEditorUserId": "2684539", "Body": "<p><code>D::operator()</code> hides overloads of parent.</p>\n<p>You have to write using <code>C::operator()</code> (and same for other bases).</p>\n<p>Then all overloads are visible. </p>\n", "LastEditDate": "2018-03-01T03:12:35.790", "PostTypeId": "2", "CommentCount": "2", "Score": "1"}, "49041864": {"Tags": "<c++><inheritance><standards><c++17><overload-resolution>", "ViewCount": "50", "LastEditDate": "2018-03-01T02:55:23.147", "AnswerCount": "2", "LastEditorUserId": "882932", "Title": "Overload resolution over several layers of inheritance?", "CommentCount": "2", "AcceptedAnswerId": "49041975", "Score": "0", "CreationDate": "2018-03-01T02:49:27.080", "Id": "49041864", "LastActivityDate": "2018-03-01T03:12:35.790", "Body": "<p>Consider the following example with several layers of inheritance:</p>\n<pre><code>struct A {\n    void operator()(double x);\n};\n\nstruct B: A {\n    using A::operator();\n    template &lt;class... T&gt; void operator()(T... x);\n};\n\nstruct C: B {\n    using B::operator();\n    void operator()() const;\n    void operator()(int x) const;\n};\n\nstruct D: C {\n    using C::operator();\n    void operator()();\n};\n</code></pre>\n<p>Will the overload resolution work exactly as if <code>D</code> had been written as:</p>\n<pre><code>struct D {\n    void operator()(double x);\n    template &lt;class... T&gt; void operator()(T... x);\n    void operator()() const;\n    void operator()(int x) const;\n    void operator()();\n};\n</code></pre>\n<p>or in the contrary, the compiler tries to find a working overload in <code>D</code>, then in <code>C</code>, then in <code>B</code>, then in <code>A</code>? In other words, does inheritance play any role in overload resolution (for functions that do not have the same signature), or not?</p>\n", "PostTypeId": "1", "OwnerUserId": "882932"}, "49041975": {"ParentId": "49041864", "LastActivityDate": "2018-03-01T03:04:17.230", "OwnerUserId": "481267", "Id": "49041975", "CreationDate": "2018-03-01T03:04:17.230", "Body": "<p>A general rule is that overload resolution will consider the set of declarations found by name lookup, and no others.</p>\n<p>According to [namespace.udecl]/1:</p>\n<blockquote>\n<p id=\"so_49041864_49041975_0\">Each <em>using-declarator</em> in a <em>using-declaration</em> introduces a set of declarations into the declarative region in\n  which the <em>using-declaration</em> appears. The set of declarations introduced by the <em>using-declarator</em> is found by\n  performing qualified name lookup (6.4.3, 13.2) for the name in the <em>usingdeclarator</em>, excluding functions that\n  are hidden as described below.</p>\n</blockquote>\n<p>Therefore, the name lookup of <code>operator()</code> in the scope of <code>D</code>, which finds <code>D::operator()</code> as well as the <em>using-declaration</em>, must recursively look up <code>operator()</code> in the scope of <code>C</code>, which finds the two <code>C::operator()</code>s as well as the <em>using-declaration</em>, and so on. So yes, in your case, overload resolution will consider the full set of <code>operator()</code>s as candidates.</p>\n", "PostTypeId": "2", "CommentCount": "0", "Score": "4"}, "bq_ids": {"n4659": {"so_49041864_49041975_0": {"length": 27, "section_id": 6924, "quality": 0.9}}}});