post_cb({"30694923": {"CommentCount": "3", "ViewCount": "112", "CreationDate": "2015-06-07T14:53:59.587", "LastActivityDate": "2015-06-07T15:08:48.840", "Title": "C++: Associativity of * (multiply) operator is not left-to-right", "AcceptedAnswerId": "30694991", "PostTypeId": "1", "Id": "30694923", "Score": "2", "Body": "<p>While working on a school assignment, we had to do something with operator overloading and templates. All cool. I wrote:</p>\n<pre><code>template&lt;class T&gt;\nclass Multiplication : public Expression&lt;T&gt;\n{\nprivate:\n        typename std::shared_ptr&lt;Expression&lt;T&gt; &gt; l, r;\n\npublic:\n        Multiplication(typename std::shared_ptr&lt;Expression&lt;T&gt; &gt; l, typename std::shared_ptr&lt;Expression&lt;T&gt; &gt; r) : l(l), r(r) {};\n        virtual ~Multiplication() {};\n\n        T evaluate() const\n        {\n                std::cout &lt;&lt; \"*\";\n                T ml = l-&gt;evaluate();\n                T mr = r-&gt;evaluate();\n                return ml * mr;\n        };\n};\n</code></pre>\n<p>Then a friend asked me why his code produced output in the \"wrong\" order.\nHe had something like</p>\n<pre><code>T evaluate() const\n{\n        std::cout &lt;&lt; \"*\";\n        return l-&gt;evaluate() * r-&gt;evaluate();\n};\n</code></pre>\n<p>The code of <code>r-&gt;evaluate()</code> printed the debug information, before <code>l-&gt;evaluate()</code>.\nI tested it on my machine as well, by just changing these three lines to a one-liner.</p>\n<p>So, I thought, well then <code>*</code> should be right-to-left associative. But everywhere on the internet they say it is left-to-right. Are there some extra rules? Maybe something special when using templates? Or is this a bug in VS2012 ?</p>\n", "Tags": "<c++><operator-overloading><operator-keyword><associativity>", "OwnerUserId": "155137", "AnswerCount": "2"}, "30694995": {"ParentId": "30694923", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have a single operator in your expression:</p>\n<pre><code>l-&gt;evaluate() * r-&gt;evaluate()\n</code></pre>\n<p>so associativity is not involved at all here. The catch is that the two operands are evaluated before calling the <code>*</code> operator and the order in which they are evaluated is not defined. A compiler is allowed to reorder the evaluation in any suitable way.</p>\n<p>In C++11 terms, the call to <code>operator*</code> is sequenced after the operand evaluation, but there is no sequence relation between the two evaluations. From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">n4296 draft (post C++14)</a>, page 10:</p>\n<blockquote>\n<p id=\"so_30694923_30694995_0\"><strong>\u00a71.9.15</strong> Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n", "OwnerUserId": "2344584", "LastEditorUserId": "2344584", "LastEditDate": "2015-06-07T15:08:48.840", "Id": "30694995", "Score": "2", "CreationDate": "2015-06-07T15:00:40.347", "LastActivityDate": "2015-06-07T15:08:48.840"}, "30694991": {"ParentId": "30694923", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>When we say the associativity of <code>*</code> is left-to-right, we mean that the expression <code>a*b*c*d</code> will always evaluate as <code>(((a*b)*c)*d)</code>. That's it. In your example, you only have one <code>operator*</code>, so there isn't anything to associate.</p>\n<p>What you're running into is the order of evaluation of operands. You are calling:</p>\n<pre><code>operator*(l-&gt;evaluate(), r-&gt;evaluate());\n</code></pre>\n<p>Both expressions need to be evaluated before the call to <code>operator*</code>, but it is unspecified (explicitly) by the C++ standard what order they get evaluated in. In your case, <code>r-&gt;evaluate()</code> got evaluated first - but that has nothing to do with the associativity of <code>operator*</code>. </p>\n<p>Note that even if you had <code>a-&gt;evaluate() * b-&gt;evaluate() * c-&gt;evaluate()</code>, that would get parsed as:</p>\n<pre><code>operator*(operator*(a-&gt;evaluate(), b-&gt;evaluate()), c-&gt;evaluate())\n</code></pre>\n<p>based on the rules of operator associativity - but even in that case, there's no rule to prevent <code>c-&gt;evaluate()</code> from being called first. It may very well be!</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "155137", "LastEditDate": "2015-06-07T15:03:19.020", "Id": "30694991", "Score": "8", "CreationDate": "2015-06-07T15:00:09.343", "LastActivityDate": "2015-06-07T15:03:19.020"}, "bq_ids": {"n4140": {"so_30694923_30694995_0": {"section_id": 5811, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_30694923_30694995_0": {"section_id": 5584, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_30694923_30694995_0": {"section_id": 7272, "quality": 0.9166666666666666, "length": 11}}}});