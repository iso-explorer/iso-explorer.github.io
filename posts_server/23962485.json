post_cb({"24049765": {"ParentId": "23962485", "CommentCount": "0", "CreationDate": "2014-06-05T00:27:24.223", "OwnerUserId": "538370", "PostTypeId": "2", "Id": "24049765", "Score": "0", "Body": "<p>Well, I got it to work in gcc and Visual C++ 2012, so I'm posting in case anyone else hits this issue. I had to add the following in my allocator class:</p>\n<pre><code>template&lt;class U&gt;\nstruct rebind\n{\n    typedef typename std::conditional&lt;std::is_same&lt;T, U&gt;::value, ContigAlloc&lt;U&gt;, std::allocator&lt;U&gt;&gt;::type other;\n}\n\ntemplate&lt;class U&gt;\ninline operator std::allocator&lt;U&gt;(void) const\n{\n    return std::allocator&lt;U&gt;();\n}\n</code></pre>\n<p>For Visual C++2012, in Debug builds both the conditional typedef and the conversion operator seem to be needed.</p>\n<p>This only works if the default std::allocator is stateless, which I don't think is specified in the standard.</p>\n", "LastActivityDate": "2014-06-05T00:27:24.223"}, "23964550": {"ParentId": "23962485", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-05-30T23:00:17.767", "Score": "2", "LastEditorUserId": "2881849", "LastEditDate": "2014-06-01T09:53:50.343", "Id": "23964550", "OwnerUserId": "2881849", "Body": "<p>If I understand your question correctly, you are using vectors of fixed size. \nIf these sizes and the number of the vectors are compile time constants, I would suggest using <code>std::array</code>.</p>\n<p>EDIT:\nJust to clarify what I mean, here an example:</p>\n<pre><code>struct Memory {\n    std::array&lt;int, 2&gt; a1; \n    std::array&lt;int, 2&gt; a2;\n} memory; \n\n\nint main() {         \n    std::array&lt;int, 2&gt;&amp; a1 = memory.a1;\n    std::array&lt;int, 2&gt;&amp; a2 = memory.a2; \n\n    a1[0] = 10; \n    a1[1] = 11;  \n    a2[0] = 20;\n    a2[1] = 21;  \n\n    int *it=&amp;(a1[0]); \n\n    for (size_t i = 0; i &lt; 4; ++i){\n        std::cout &lt;&lt; *(it++) &lt;&lt; \",\";\n    }\n}\n</code></pre>\n<p>Output: <code>10,11,20,21,</code>\nDepending on your requirements, you can also implement <code>Memory</code> as a singleton. \nOf course it's just a guess from my side, whether this matches your current usage pattern.</p>\n", "LastActivityDate": "2014-06-01T09:53:50.343"}, "23962485": {"CommentCount": "11", "ViewCount": "306", "PostTypeId": "1", "LastEditorUserId": "538370", "CreationDate": "2014-05-30T19:55:41.700", "LastActivityDate": "2014-06-05T00:27:24.223", "Title": "Vector-like container that can have instances with storages mutually contiguous?", "AcceptedAnswerId": "24049765", "LastEditDate": "2014-06-03T23:57:05.167", "Id": "23962485", "Score": "3", "Body": "<p>I need a container class with API as close as possible to std::vector (except no reallocation), but whose elements' storage (and not its member variables such as size) can be specified to be allocated from an existing buffer, so that I can have all vectors' held elements in a contiguous buffer. That is, .end() of one vector points to the same element in the buffer as .front() of the next.</p>\n<p>I don't know whether I can simply use a custom allocator with std::vector, because I can't find information on whether that allocates storage for the whole class including the size and pointer data members (in which case I can't use this approach), or just the data elements it holds (in which case I can use it).</p>\n<p>I only need an instance's storage to be allocated once, so there's no issue with reallocation. I'm posting here to see if there's already such a container published, rather than reimplementing most of the std vector interface with iterators etc. from scratch.</p>\n<hr>\n<p>Update: I unchecked the answer that was posted because it doesn't work in debug mode in Visual C++ 2012. Example with <code>T</code> = <code>float</code>:</p>\n<pre><code>template&lt;class T&gt;\ninline typename ContigAlloc&lt;T&gt;::pointer ContigAlloc&lt;T&gt;::allocate(std::size_t n)\n{\n    std::cout &lt;&lt; \"Alloc \" &lt;&lt; n &lt;&lt; \"; type match: \" &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;T, float&gt;::value &lt;&lt; std::endl;\n    return reinterpret_cast&lt;T *&gt;(_buff.alloc(T * sizeof(n)));\n}\n\ntemplate&lt;class T&gt;\ninline void ContigAlloc&lt;T&gt;::deallocate(T *p, std::size_t n) // TODO: noexcept when VC++2013\n{\n    std::cout &lt;&lt; \"Deall \" &lt;&lt; n &lt;&lt; \"; type match: \" &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;T, float&gt;::value &lt;&lt; std::endl;\n    _buff.dealloc(p, T * sizeof(n));\n}\n</code></pre>\n<p>Test:</p>\n<pre><code>std::vector&lt;float, ContigAlloc&lt;float&gt;&gt; vec;\nvec.push_back(1.1f);\nvec.push_back(1.9f);\n</code></pre>\n<p>Result in Release build is fine:</p>\n<pre><code>Alloc 1; type match: true\nAlloc 2; type match: true\nDeall 1; type match: true\nDeall 2; type match: true\n</code></pre>\n<p>Result in Debug build is <em>not</em> fine:</p>\n<pre><code>Alloc 1; type match: false\nAlloc 1; type match: true\nAlloc 2; type match: true\nDeall 1; type match: true\nDeall 2; type match: true\nDeall 1; type match: false\n</code></pre>\n<p>In the first call to <code>allocate()</code>, <code>T</code> = <code>_Container_proxy</code></p>\n</hr>", "Tags": "<c++><c++11><memory-management><vector><stl>", "OwnerUserId": "538370", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_23962485_23962721_0": {"section_id": 712, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_23962485_23962721_0": {"section_id": 701, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_23962485_23962721_0": {"section_id": 741, "quality": 0.9285714285714286, "length": 13}}}, "23962721": {"ParentId": "23962485", "PostTypeId": "2", "CommentCount": "25", "CreationDate": "2014-05-30T20:15:00.973", "Score": "6", "LastEditorUserId": "576911", "LastEditDate": "2014-05-30T20:54:10.057", "Id": "23962721", "OwnerUserId": "576911", "Body": "<p>An allocator is used only to allocate storage for the elements.  You can use a custom allocator for this purpose.</p>\n<p>I stand corrected by Jon in the comments below.</p>\n<p>I <em>think</em> one could implement a conforming <code>vector</code> such that it stored everything on the heap except a pointer.  The things on the heap would be either 3 pointers, plus the allocator (if not allocator is not optimized away), or 1 pointer, the size, and the capacity (and the possibly optimized away allocator).</p>\n<p>In practice, every single implementation of <code>std::vector</code> that has ever shipped in any kind of volume, including:</p>\n<ul>\n<li>HP</li>\n<li>SGI</li>\n<li>libstdc++ (gcc)</li>\n<li>libc++ (llvm)</li>\n<li>Dinkumware</li>\n<li>Microsoft</li>\n<li>Rogue Wave </li>\n<li>CodeWarrior</li>\n<li>STLPort</li>\n<li>I'm sure I'm forgetting some others...</li>\n</ul>\n<p>has placed all of the supporting members within the vector class itself, and used the allocator only for allocating the data.  And there seems to be little motivation to do otherwise.</p>\n<p>So this is a de facto standard, not an official one.  With the history above, it is a pretty safe one.</p>\n<p>Note that one could not make the same claim for <code>string</code>, which conceptually has an identical layout.  C++11 implementations of <code>string</code> will typically use a \"short string\" optimization where the allocator is not used at all for \"short\" strings, but rather the value is embedded within the string class.  This optimization is effectively forbidden for <code>vector</code> by 23.2.1 General container requirements [container.requirements.general]/10:</p>\n<blockquote>\n<p id=\"so_23962485_23962721_0\">(Unless otherwise specified) no swap() function invalidates any\n  references, pointers, or iterators referring to the elements of the\n  containers being swapped.</p>\n</blockquote>\n", "LastActivityDate": "2014-05-30T20:54:10.057"}});