post_cb({"29116887": {"ParentId": "29116751", "CommentCount": "1", "Body": "<p>It follows from the definition of value categories in C++11 3.10/1 (emphasis mine):</p>\n<blockquote>\n<ul>\n<li><p id=\"so_29116751_29116887_0\">An <em>lvalue</em> (...) designates a <strong>function</strong> or an object. ...</p></li>\n<li><p id=\"so_29116751_29116887_1\">An <em>xvalue</em> (an \u201ceXpiring\u201d value) also refers to an object, ...</p></li>\n<li><p id=\"so_29116751_29116887_2\">An <em>rvalue</em> (...) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.</p></li>\n<li><p id=\"so_29116751_29116887_3\">A <em>prvalue</em> (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue. ...</p></li>\n</ul>\n</blockquote>\n<p>Notice that only the lvalue category can be a function, all the others are values or objects only.</p>\n<p>It's also echoed in 5.2.9/1:</p>\n<blockquote>\n<p id=\"so_29116751_29116887_4\">The result of the expression <code>static_cast&lt;T&gt;(v)</code> is the result of converting the expression <code>v</code> to type <code>T</code>. <strong>If <code>T</code>\n  is</strong> an lvalue reference type or <strong>an rvalue reference to function type, the result is an lvalue</strong>; if <code>T</code> is an rvalue\n  reference to object type, the result is an xvalue; otherwise, the result is a prvalue. ...</p>\n</blockquote>\n<p>As for the why of it, I can of course only guess (not being part of the standardisation committee). But my guess is that it would make no sense to have rvalues of function type\u2014a function can never be a temporary, it can never be at or near the end of its lifetime.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "29116887", "Score": "7", "CreationDate": "2015-03-18T08:07:47.907", "LastActivityDate": "2015-03-18T08:07:47.907"}, "29136042": {"ParentId": "29116751", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Very grateful to the information(<strong>N3055</strong>,link at his comment) provided by T.C. , in order to facilitate a quick overview of the answers, and I quote some paragraphs related to this issue.<strong>This answer tells us why</strong></p>\n<blockquote>\n<p id=\"so_29116751_29136042_0\">rvalue references (like traditional lvalue references) can be bound to\n  functions. <strong>Treating an rvalue reference return value as an rvalue,\n  however, introduces the novel concept of a function rvalue into the\n  language.</strong> There was previously no such idea \u2013 a function lvalue used\n  in an rvalue context becomes a pointer-to-function rvalue, not a\n  function rvalue \u2013 so the current draft Standard does not describe how\n  such rvalues are to be treated. <strong>In particular, function calls and\n  conversions to function pointers are specified in terms of function\n  lvalues,</strong> <strong>so most plausible uses of rvalue references to functions are\n  undefined in the current wording.</strong> </p>\n<p id=\"so_29116751_29136042_1\">One possible resolution for these\n  problems would be to maintain the current approach of treating an\n  rvalue reference return value as an rvalue but to add various caveats\n  to the specification of rvalues so that those coming from rvalue\n  references would have special characteristics. This could be called\n  the \u201cfunny rvalue\u201d approach. However, further examination of the\n  current wording of the draft Standard indicates that the problems\n  listed above are probably only the tip of the iceberg: many of the\n  specifications that should apply to the objects to which rvalue\n  references refer, such as object lifetime, aliasing rules, etc., are\n  phrased in terms of lvalues, <strong>so the list of rvalue caveats could get\n  quite long</strong>.</p>\n<p id=\"so_29116751_29136042_2\">This suggests an alternative approach: that rvalue reference return\n  values should actually be seen as lvalues, with a few exceptions to\n  allow them to be treated as rvalues in the cases where that is\n  intended, i.e., in reference binding, overload resolution, and\n  template argument deduction. This idea, dubbed the \u201cfunny lvalue\u201d\n  approach, is embodied in earlier versions of this paper.After <strong>extensive discussions</strong> in the Core Working Group at the Pittsburgh (March 8-13, 2010) meeting,\n  ......</p>\n</blockquote>\n<p>In addition\uff0cAs 5.2.2 Function call[expr.call] says:</p>\n<blockquote>\n<p id=\"so_29116751_29136042_3\">For a call to a non-member function or to a static member function,\n  the postfix expression shall be either an <strong>lvalue</strong> that refers to a\n  function (in which case the function-to-pointer  standard conversion\n  (4.3) is suppressed on the postfix expression), or it shall have\n  pointer to function type.</p>\n</blockquote>\n<p>Now <code>static_cast&lt;void(&amp;&amp;)(int)&gt;(test)</code> is an lvalue.</p>\n<p>So   <code>static_cast&lt;void(&amp;&amp;)(int)&gt;(test)(555);</code> is OK.</p>\n", "OwnerUserId": "2593814", "LastEditorUserId": "2593814", "LastEditDate": "2015-03-19T02:57:17.980", "Id": "29136042", "Score": "0", "CreationDate": "2015-03-19T02:07:35.803", "LastActivityDate": "2015-03-19T02:57:17.980"}, "29116751": {"CommentCount": "1", "ViewCount": "439", "PostTypeId": "1", "LastEditorUserId": "2593814", "CreationDate": "2015-03-18T07:57:28.293", "LastActivityDate": "2015-03-19T02:57:17.980", "Title": "Why cast expression to rvalue reference to function is lvalue?", "AcceptedAnswerId": "29116887", "LastEditDate": "2015-03-18T08:02:34.443", "Id": "29116751", "Score": "4", "Body": "<p>At here,<a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow\">cppreference-lvalue</a>,I found that</p>\n<blockquote>\n<p id=\"so_29116751_29116751_0\">Cast expression to rvalue reference to function is lvalue.</p>\n</blockquote>\n<p>I was curious, so I carried out the following experiment:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\ntypedef void (&amp;&amp;funr) (int);\ntypedef void (&amp;funl) (int);\n\nvoid test(int num){\n    cout&lt;&lt;num&lt;&lt;endl;//output:20\n}\n\nvoid foo(funr fun){\n    fun(10);\n}\n\nvoid foo(funl fun){\n    fun(20);//call this\n}\n\ntemplate &lt;typename T&gt; void foo(T&amp;&amp; fun){\n    cout&lt;&lt;is_same&lt;T,void(&amp;)(int)&gt;::value&lt;&lt;endl;//true, it is lvalue. \n    cout&lt;&lt;is_same&lt;T,void(int)&gt;::value&lt;&lt;endl;//false, it isn't rvalue.\n}\nint main()\n{\n\n   foo(static_cast&lt;void(&amp;&amp;)(int)&gt;(test));\n   return 0;\n}\n</code></pre>\n<p>the fact that so.</p>\n<p>Why cast expression to rvalue reference to function is  lvalue? \nIs it because a function type is no need to move semantics or something else?\nOr I understand this word wrong.</p>\n<blockquote>\n<p id=\"so_29116751_29116751_1\">Cast expression to rvalue reference to function is lvalue </p>\n</blockquote>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2593814", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29116751_29116751_1": {"section_id": 597, "quality": 0.8333333333333334, "length": 5}, "so_29116751_29116887_4": {"section_id": 6027, "quality": 0.9615384615384616, "length": 25}, "so_29116751_29116887_2": {"section_id": 7230, "quality": 0.9, "length": 9}, "so_29116751_29136042_3": {"section_id": 5988, "quality": 0.9565217391304348, "length": 22}, "so_29116751_29116887_1": {"section_id": 7230, "quality": 0.8333333333333334, "length": 5}, "so_29116751_29116751_0": {"section_id": 597, "quality": 0.8333333333333334, "length": 5}, "so_29116751_29116887_3": {"section_id": 7230, "quality": 0.8, "length": 4}}, "n3337": {"so_29116751_29116751_1": {"section_id": 3191, "quality": 0.8333333333333334, "length": 5}, "so_29116751_29116887_4": {"section_id": 5795, "quality": 0.9615384615384616, "length": 25}, "so_29116751_29116887_2": {"section_id": 6974, "quality": 0.9, "length": 9}, "so_29116751_29116887_3": {"section_id": 6974, "quality": 0.8, "length": 4}, "so_29116751_29136042_3": {"section_id": 5756, "quality": 0.9130434782608695, "length": 21}, "so_29116751_29116887_1": {"section_id": 6974, "quality": 0.8333333333333334, "length": 5}, "so_29116751_29116751_0": {"section_id": 3191, "quality": 0.8333333333333334, "length": 5}, "so_29116751_29116887_0": {"section_id": 5947, "quality": 1.0, "length": 4}}, "n4659": {"so_29116751_29116751_1": {"section_id": 620, "quality": 0.8333333333333334, "length": 5}, "so_29116751_29136042_3": {"section_id": 7488, "quality": 0.9565217391304348, "length": 22}, "so_29116751_29116887_4": {"section_id": 7526, "quality": 0.9615384615384616, "length": 25}, "so_29116751_29116751_0": {"section_id": 620, "quality": 0.8333333333333334, "length": 5}}}});