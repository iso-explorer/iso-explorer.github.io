post_cb({"19802230": {"ParentId": "19802173", "CommentCount": "0", "Body": "<p>name conflit, changing to ::swap solves the issue. </p>\n", "OwnerUserId": "2958582", "PostTypeId": "2", "Id": "19802230", "Score": "3", "CreationDate": "2013-11-06T01:11:13.500", "LastActivityDate": "2013-11-06T01:11:13.500"}, "19802260": {"ParentId": "19802173", "CommentCount": "1", "Body": "<p>The compiler says it is confused because of two functions : yours and the standard std::swap. It consider std::swap too because std::complex is member of std::namespace, it's calling Argument Dependant Lookup. If you want to explicitly test your swap, you can use :: scope resolution operator, ie ::swap instead of swap. It will make another kind of lookup : Qualified Name Lookup solving the ambiguity.</p>\n<p>Nonetheless, std::swap works well and do the job, except as exercise, include utility standard header, make a using std::swap, and it will work fine :  </p>\n<pre><code>#include&lt;utility&gt;\n\n//before needed (closest)\nusing std::swap;\nswap(/*arguments*/);\n</code></pre>\n", "OwnerUserId": "1974818", "PostTypeId": "2", "Id": "19802260", "Score": "0", "CreationDate": "2013-11-06T01:14:16.317", "LastActivityDate": "2013-11-06T01:14:16.317"}, "19802377": {"ParentId": "19802173", "CommentCount": "1", "Body": "<p>The problem is that <em>argument-dependent lookup</em> is applied because you are calling a function <em>template</em>. If you had a plain function, there would be no ambiguity:</p>\n<pre><code>#include &lt;complex&gt;\n\nvoid swap(complex&lt;double&gt; &amp; d, complex&lt;double&gt; &amp; s)\n{\n    complex&lt;double&gt; temp = d;\n    d = s;\n    s = temp;\n}\n\n\nint main()\n{\n   std::complex&lt;double&gt; r(2.4, 3.5), s(3.4, 6.7);\n   swap(r, s);\n}\n</code></pre>\n<p>This is because of C++11 3.4.2:</p>\n<blockquote>\n<p id=\"so_19802173_19802377_0\">Let <em>X</em> be the lookup set produced by unqualified lookup (3.4.1) and let <em>Y</em> be the lookup set produced by argument dependent lookup (defined as follows). If <em>X</em> contains</p>\n<p id=\"so_19802173_19802377_1\">\u2014 a declaration of a class member, or</p>\n<p id=\"so_19802173_19802377_2\">\u2014 a block-scope function declaration that is not a using-declaration, or</p>\n<p id=\"so_19802173_19802377_3\">\u2014 a declaration that is neither a function or a function template</p>\n<p id=\"so_19802173_19802377_4\">then <em>Y</em> is empty. Otherwise <em>Y</em> is the set of declarations found in the namespaces associated with the argument types as described below. The set of declarations found by the lookup of the name is the union of <em>X</em> and <em>Y</em>.</p>\n</blockquote>\n<p>In the above case, <em>X</em> contains a block-scope function declaration.</p>\n<p>However, if the unqualified lookup finds the function <em>template</em> you provided, then the ADL rules say that the argument-dependent lookup set is also considered. Since <code>std::complex&lt;double&gt;</code> lives in the <code>std</code> namespace, this namespace is also searched for the name <code>swap</code>, which already exists (by 20.2.2).</p>\n<p>You can prevent argument-dependent lookup by wrapping the function name in parentheses:</p>\n<pre><code>(swap)(r, s);\n</code></pre>\n<p>This way, only the unqualified lookup is considered.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "19802377", "Score": "2", "CreationDate": "2013-11-06T01:25:51.630", "LastActivityDate": "2013-11-06T01:25:51.630"}, "bq_ids": {"n4140": {"so_19802173_19802377_0": {"section_id": 7105, "quality": 0.9411764705882353, "length": 16}, "so_19802173_19802377_4": {"section_id": 7105, "quality": 0.9473684210526315, "length": 18}, "so_19802173_19802377_2": {"section_id": 7105, "quality": 1.0, "length": 4}, "so_19802173_19802377_3": {"section_id": 7105, "quality": 1.0, "length": 5}}, "n3337": {"so_19802173_19802377_0": {"section_id": 6849, "quality": 0.9411764705882353, "length": 16}, "so_19802173_19802377_4": {"section_id": 6849, "quality": 0.9473684210526315, "length": 18}, "so_19802173_19802377_2": {"section_id": 6849, "quality": 1.0, "length": 4}, "so_19802173_19802377_3": {"section_id": 6849, "quality": 1.0, "length": 5}}, "n4659": {"so_19802173_19802377_0": {"section_id": 8606, "quality": 0.9411764705882353, "length": 16}, "so_19802173_19802377_3": {"section_id": 8606, "quality": 1.0, "length": 5}, "so_19802173_19802377_4": {"section_id": 8606, "quality": 0.9473684210526315, "length": 18}, "so_19802173_19802377_2": {"section_id": 8606, "quality": 1.0, "length": 4}}}, "19802173": {"CommentCount": "9", "ViewCount": "286", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2013-11-06T01:05:12.837", "LastActivityDate": "2013-11-06T01:30:46.227", "Title": "Overloading function doesn't work with complex", "AcceptedAnswerId": "19802230", "LastEditDate": "2013-11-06T01:30:46.227", "Id": "19802173", "Score": "0", "Body": "<p>I have written this simple C++ code to swap any two variables. It works for int and double, but doesn't work for complex numbers, any idea why?</p>\n<pre><code>#include &lt;iostream&gt;  \n#include &lt;complex&gt;  \n\nusing std::cout; \nusing std::endl; \nusing std::complex; \n\ntemplate &lt;class T&gt;\n\ninline void swap(T&amp; d, T&amp; s)\n{\n    T temp = d;\n    d = s;\n    s = temp;\n}\n\n\nint main()\n{\n   int m=5, n=10;\n   double x=5.3, y=10.6;\n   complex&lt;double&gt; r(2.4, 3.5), s(3.4, 6.7);\n\n   cout &lt;&lt; \"inputs:  \" &lt;&lt; m &lt;&lt; \" , \" &lt;&lt; n &lt;&lt; endl;\n   swap(m, n);\n   cout &lt;&lt; \"outputs: \" &lt;&lt; m &lt;&lt; \" , \" &lt;&lt; n &lt;&lt; endl;\n\n   cout &lt;&lt; \"double inputs:  \" &lt;&lt; x &lt;&lt; \" , \" &lt;&lt; y &lt;&lt; endl;\n   swap(x, y);\n   cout &lt;&lt; \"double outputs: \" &lt;&lt; x &lt;&lt; \" , \" &lt;&lt; y &lt;&lt; endl;\n\n   cout &lt;&lt; \"complex inputs:  \" &lt;&lt; r &lt;&lt; \" , \" &lt;&lt; s &lt;&lt; endl;\n   swap(r, s);\n   cout &lt;&lt; \"complex outputs: \" &lt;&lt; r &lt;&lt; \" , \" &lt;&lt; s &lt;&lt; endl;\n}\n</code></pre>\n<p>This is the error:</p>\n<pre><code>g++ 02.swap.template.cpp -o c.out.02\n02.swap.template.cpp: In function \u2018int main()\u2019:\n02.swap.template.cpp:37:13: error: call of overloaded \u2018swap(std::complex&lt;double&gt;&amp;, std::complex&lt;double&gt;&amp;)\u2019 is ambiguous\n02.swap.template.cpp:37:13: note: candidates are:\n02.swap.template.cpp:13:13: note: void swap(T&amp;, T&amp;) [with T = std::complex&lt;double&gt;]\n/usr/include/c++/4.6/bits/move.h:122:5: note: void std::swap(_Tp&amp;, _Tp&amp;) [with _Tp = std::complex&lt;double&gt;]\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "2191236", "AnswerCount": "3"}});