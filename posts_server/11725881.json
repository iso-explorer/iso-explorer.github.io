post_cb({"22076623": {"PostTypeId": "2", "Body": "<p>You can make it work, in clang 3.4, as long as the lambda doesn't capture anything. The idea is directly from <a href=\"http://pfultz2.github.io/Pythy/\" rel=\"nofollow\">Pythy</a> .</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\ntemplate&lt;typename T&gt;\nauto address(T&amp;&amp; t) -&gt; typename std:: remove_reference&lt;T&gt; :: type *\n{\n        return &amp;t;\n}\n\nstruct A\n{\n        static constexpr auto * F = false ? address(\n\n                [](int x){ std:: cout &lt;&lt; \"It worked. x = \" &lt;&lt; x &lt;&lt; std:: endl;\n\n                }\n        ) : nullptr; // a nullptr, but at least its *type* is useful\n};\n\n\nint main()\n{\n    (*A::F)(1337); // dereferencing a null. Doesn't look good\n    return 0;\n}\n</code></pre>\n<p>There are two potentially controversial bits here. First, there's the fact that <code>A::F</code> is <code>constexpr</code>, but it has a lambda in its definition.</p>\n<p>That should be impossible right? No. A ternary expression <code>b ? v1 : v2</code> can be a <code>constexpr</code> without requiring all three of <code>b</code>, <code>v1</code>, <code>v2</code> to be <code>constexpr</code>. It is sufficient merely that <code>b</code> is <code>constexpr</code> along with <em>one</em> of the remaining two (depending on whether <code>b</code> is <code>true</code> or <code>false</code>. Here <code>b</code> is <code>false</code>, and this selects the final part of the <code>?:</code>, i.e. <code>nullptr</code>.</p>\n<p>In other words <code>false ? a_non_constexpr_func() : a_constexpr_func()</code> is a <code>constexpr</code>. This appears to be the interpretation in clang anyway. I hope this is what's in the standard. If not, I wouldn't say that clang \"should not accept this\". It appears to be a valid relaxation of the rule. The unevaluated part of a <code>?:</code> is unevaluated and therefore it <code>constexpr</code>-ness shouldn't matter.</p>\n<p>Anyway, assuming this is OK, that gives us a <code>nullptr</code> of the correct type, i.e. the type of a pointer to the lambda. The second controversial bit is <code>(*A::F)(1337);</code> where we are dereferencing the null pointer. But it is argued by the <a href=\"http://pfultz2.github.io/Pythy/\" rel=\"nofollow\">page</a> linked above that that is not a problem:</p>\n<blockquote>\n<p id=\"so_11725881_22076623_0\">It appears that we are derefencing a null pointer. Remember in C++ when dereferencing a null pointer, undefined behavior occurs when there is an lvalue-to-rvalue conversion. However, since a non-capturing lambda closure is almost always implemented as an object with no members, undefined behavior never occurs, since it won't access any of its members. Its highly unlikely that a non-capturing lambda closure could be implemented another way since it must be convertible to a function pointer. But the library does statically assert that the closure object is empty to avoid any possible undefined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2014-02-27T18:00:37.090", "Id": "22076623", "CommentCount": "2", "CreationDate": "2014-02-27T18:00:37.090", "ParentId": "11725881", "Score": "1", "OwnerUserId": "146041"}, "bq_ids": {"n4140": {"so_11725881_11734112_0": {"length": 7, "quality": 0.7, "section_id": 6185}}, "n3337": {"so_11725881_11734112_0": {"length": 10, "quality": 1.0, "section_id": 5946}}}, "11725881": {"ViewCount": "5052", "Body": "<p>I'm trying to use a lambda as a static member, like this:</p>\n<pre><code>struct A\n{\n    static constexpr auto F = [](){};\n};\n\n\nint main()\n{\n    A::F();\n    return 0;\n}\n</code></pre>\n<p>Is this even correct C++11 code? On clang, I get this error:</p>\n<pre><code>error: constexpr variable 'F' must be initialized by a constant\n      expression\n    static constexpr auto F = [](){};\n                              ^~~~~~\n</code></pre>\n<p>It seems in clang, lambdas aren't considered a constant expression. Is this correct? Perhaps they haven't fully implemented lambdas yet in clang because gcc 4.7 seems to allow it as a <code>constexpr</code>, but it give another error:</p>\n<pre><code>error: \u2018constexpr const&lt;lambda()&gt; A::F\u2019, declared using local type \u2018const&lt;lambda()&gt;\u2019, is used but never defined\n</code></pre>\n<p>I'm not sure, I understand what that means. It seems to correctly deduce the type of the lambda, but it only declares it and not define it. How would I go about defining it?</p>\n", "AcceptedAnswerId": "11734112", "Title": "lambda as a static member", "CreationDate": "2012-07-30T16:43:56.047", "Id": "11725881", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-08T11:11:55.127", "LastEditorUserId": "256431", "LastActivityDate": "2014-06-08T11:11:55.127", "Score": "26", "OwnerUserId": "375343", "Tags": "<c++><lambda><c++11><language-lawyer><constexpr>", "AnswerCount": "2"}, "11734112": {"PostTypeId": "2", "Body": "<p>This code is ill-formed. A <code>constexpr</code> variable is required to be initialized by a constant expression, and <code>[expr.const]p2</code> says:</p>\n<blockquote>\n<p id=\"so_11725881_11734112_0\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless it involves one of the following as a potentially evaluated subexpression [...]:</p>\n<ul>\n<li>a <em>lambda-expression</em></li>\n</ul>\n</blockquote>\n<p>GCC is therefore incorrect to accept this code.</p>\n<p>Here's one way to give a class a static data member of lambda type:</p>\n<pre><code>auto a = []{};\nstruct S {\n  static decltype(a) b;\n};\ndecltype(a) S::b = a;\n</code></pre>\n", "LastActivityDate": "2012-08-03T21:30:20.633", "LastEditorUserId": "1041090", "Id": "11734112", "CommentCount": "10", "CreationDate": "2012-07-31T06:06:17.277", "ParentId": "11725881", "Score": "16", "OwnerUserId": "1041090", "LastEditDate": "2012-08-03T21:30:20.633"}});