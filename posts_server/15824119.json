post_cb({"15824568": {"CommentCount": "3", "Body": "<p>I think the most correct formal way of answering this (as opposed to describing existing implementations) is based on \u00a723.3.6.1/1:</p>\n<blockquote>\n<p id=\"so_15824119_15824568_0\">[...] The elements of a vector are stored contiguously, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where T is some type other than bool, then it obeys the identity</p>\n<pre><code>&amp;v[n] == &amp;v[0] + n\n</code></pre>\n<p id=\"so_15824119_15824568_1\">for all <code>0 &lt;= n &lt; v.size()</code>.</p>\n</blockquote>\n<p>Note that this talks about the addresses <code>&amp;v[i]</code> of individual elements of the vector and implies, in particular, that each element of the vector has constant size <code>sizeof(T)</code> (because that's how pointer arithmetic works).</p>\n<p>This means it is impossible for the elements of a vector to change size at run-time. If a <code>vector&lt;vector&lt;T&gt;&gt;</code> was implemented as one contiguous block of memory, the members of the outer vector, being themselves vectors, would be allowed to change size.</p>\n<p>Therefore, there must be an extra level of indirection, i.e., the individual vectors must contain some sort of pointer to a variable-size data structure stored at a different place.</p>\n", "CreationDate": "2013-04-05T01:43:33.567", "ParentId": "15824119", "Id": "15824568", "LastActivityDate": "2013-04-05T01:43:33.567", "PostTypeId": "2", "Score": "3", "OwnerUserId": "777186"}, "15824151": {"CommentCount": "5", "Body": "<p>Each of your vector inside the vector of vectors is an individual object, and as such is responsible for it's storage. So, no, it is by no means guaranteed to be contiguous, in fact I can 't really see a situation where it could happen that the data stored in the outer vector and it's inner vectors is one contiguous block of memory ever. </p>\n", "CreationDate": "2013-04-05T00:46:31.087", "ParentId": "15824119", "Id": "15824151", "LastActivityDate": "2013-04-05T00:46:31.087", "PostTypeId": "2", "Score": "5", "OwnerUserId": "1919155"}, "15824182": {"LastActivityDate": "2013-04-05T01:13:43.307", "CreationDate": "2013-04-05T00:50:01.837", "CommentCount": "2", "Body": "<p>Let's look at the (logical) memory layout of vector:</p>\n<pre><code>[size:4/8 bytes]\n[capacity:4/8 bytes]\n[other datamembers:n bytes]\n*[elements:size*sizeof(element) bytes] &lt;&lt; one contiguous memory (pointer to heap)\n</code></pre>\n<p>With a vector of vectors it looks like this:</p>\n<pre><code>[size:4/8 bytes]\n[capacity:4/8 bytes]\n[other datamembers:n bytes]\n* [\n    [Vector:0]\n        [size:4/8 bytes]\n        [capacity:4/8 bytes]\n        [other datamembers:n bytes]\n        *[elements:size*sizeof(element) bytes] &lt;&lt; pointer to contiguous memory for elements\n    [Vector:1]\n        [size:4/8 bytes]\n        [capacity:4/8 bytes]\n        [other datamembers:n bytes]\n        *[elements:size*sizeof(element) bytes]\n    [Vector:2]\n        [size:4/8 bytes]\n        [capacity:4/8 bytes]\n        [other datamembers:n bytes]\n        *[elements:size*sizeof(element) bytes]\n    ...\n    ...\n] &lt;&lt; contiguous memory of vectors\n</code></pre>\n<p>This means that a vector has a pointer to contiguous memory storing vectors, each of which stores their elements pointing to another heap with contiguous memory storing the elements.</p>\n<p>But if you managed to create an allocator to be used by the vector, such that it would allocate blocks of memory that are contiguous, you'd still face issues where if one of the nested vectors gets removed, the memory is no longer contiguous. Not to mention the situation of having the nested vector having different sizes.</p>\n<p>Depending on your use-case you can either use the customer contiguous block memory allocator for a vector of vector, or just do it the old way of manually allocating and deallocating one contiguous block of memory.</p>\n", "Id": "15824182", "LastEditDate": "2013-04-05T01:13:43.307", "ParentId": "15824119", "OwnerUserId": "210634", "PostTypeId": "2", "Score": "0", "LastEditorUserId": "210634"}, "15824402": {"CommentCount": "0", "Body": "<p>To put it simply - std::vector guarantees the elements are stored contiguously. But that only includes the element's member data, in the case of vector that would be its size, capacity and stuff like that, plus the pointer to the actual vector data.</p>\n<p>So, a vector of vectors will give you a contiguous vector of vectors, but those vectors will have their data dynamically allocated on arbitrary memory addresses.</p>\n<p>Since an object size needs to be known at compile time, you cannot have objects with varying size, the only way to do this is to use dynamic memory allocation. If you had a custom vector of fixed size that uses no dynamic memory allocation internally, then a <code>std::vector&lt;customVector&gt;</code> would store the customVectors contiguously, but you will still have the additional auxiliary members which will \"interrupt\" the actual contiguity of the customVector element data. </p>\n", "CreationDate": "2013-04-05T01:20:52.833", "ParentId": "15824119", "Id": "15824402", "LastActivityDate": "2013-04-05T01:20:52.833", "PostTypeId": "2", "Score": "0", "OwnerUserId": "991484"}, "bq_ids": {"n4140": {"so_15824119_15824568_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 955}}, "n3337": {"so_15824119_15824568_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 943}}}, "15824119": {"CreationDate": "2013-04-05T00:42:51.530", "ViewCount": "427", "Id": "15824119", "AcceptedAnswerId": "15824151", "Score": "1", "Title": "Why isn't a vector of a vector guaranteed to be contiguous? (or is it?)", "CommentCount": "5", "Body": "<p>I know <code>std::vector</code> elements are guaranteed contiguous in memory.</p>\n<p>So then why can't you expect a vector containing other vectors to have the total collection contiguous?</p>\n<p>The vector is supposed to guarantee contiguous memory layout for its enclosed items, and if those enclosures are also vectors, then I'd expect the full contents of the top-most vector to be in contiguous memory.</p>\n<p>But there seems to be some contention on this issue as to whether or not this is true. Can one safely rely on it or not? Some folks seem to <a href=\"http://objectmix.com/c/36159-contiguous-allocation-multi-dimensional-vector.html\" rel=\"nofollow\">go out of their way</a> to achieve this, while I'd think it is guaranteed.</p>\n", "Tags": "<c++><stdvector>", "LastActivityDate": "2013-04-05T01:43:33.567", "PostTypeId": "1", "AnswerCount": "6", "OwnerUserId": "3758484"}, "15824285": {"LastActivityDate": "2013-04-05T01:10:10.197", "CreationDate": "2013-04-05T01:04:50.013", "CommentCount": "0", "Body": "<p>The problem is that the vector template doesn't contain the data it handle \"inline\", or directly. Another way of saying it that the vector class boxes the data array it holds: the vector class holds a pointer to the memory area containing the array of elements. It is structurally equivalent to:</p>\n<pre><code>template &lt;typename T&gt;\nstruct vector_eq {\n    T *ptr;\n};\n</code></pre>\n<p>and not</p>\n<pre><code>template &lt;typename T&gt;\nstruct vector_neq {\n    T arr[SIZE];\n};\n</code></pre>\n<p>which would require <code>SIZE</code> to be known at compile time (ie. a <code>constexpr</code>), for <code>arr</code> elements to be included in the struct.</p>\n<p>I imagine thar it should  be possible to specialise <code>vector&lt;vector&lt;T&gt;&gt;</code> to contain a pointer to a single block of memory, and have its methods return ad hoc instances of <code>vector&lt;T&gt;</code> sharing slices of that memory block, although the logic behind it would probably be a bit hairy.</p>\n", "Id": "15824285", "LastEditDate": "2013-04-05T01:10:10.197", "ParentId": "15824119", "OwnerUserId": "1769720", "PostTypeId": "2", "Score": "0", "LastEditorUserId": "1769720"}, "15824175": {"CommentCount": "0", "Body": "<p>A vector is an object containing a pointer to the actual array. </p>\n<p>A vector of vectors would be an object with a pointer to an array of objects, each of which points to its own array elsewhere on the heap. So no, they would never be contiguous in the way that you're asking.</p>\n", "CreationDate": "2013-04-05T00:49:28.217", "ParentId": "15824119", "Id": "15824175", "LastActivityDate": "2013-04-05T00:49:28.217", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1239706"}});