post_cb({"bq_ids": {"n4140": {"so_25385876_25386885_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4651}, "so_25385876_25386885_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 4660}}, "n3337": {"so_25385876_25386885_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4462}}, "n4659": {"so_25385876_25386885_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6020}, "so_25385876_25386885_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 6030}}}, "25385876": {"ViewCount": "687", "Body": "<p>Is the code below valid C++ according to the C++11 or C++14 standard?</p>\n<pre><code>#include &lt;functional&gt;\n\nint ReturnInt()\n{\n  return 5;\n}\n\nint main( int argc, char **argv )\n{\n  std::function&lt; void () &gt; BoundType = ReturnInt;\n  return 0;\n}\n</code></pre>\n<p>The code compiles fine with the latest cygwin versions of gcc (4.8.3) and clang (4.3.2) but not with Visual Studio 2013, Visual Studio November 2013 CTP or the Visual Studio 14 preview. It also compiles on all platforms if std::function is changed to boost::function.</p>\n<p>I found <a href=\"https://stackoverflow.com/questions/10866779/function-pointers-and-return-type-conversions\">this</a> other stack overflow question that suggests it should work.</p>\n", "AcceptedAnswerId": "25386885", "Title": "Should std::function assignment ignore return type?", "CreationDate": "2014-08-19T14:21:57.347", "LastActivityDate": "2014-08-20T14:21:58.057", "CommentCount": "1", "LastEditDate": "2017-05-23T11:46:36.333", "PostTypeId": "1", "Tags": "<c++><c++11><std-function><c++14>", "Id": "25385876", "AnswerCount": "2", "Score": "6", "OwnerUserId": "1985643", "ClosedDate": "2014-08-22T17:47:10.363", "LastEditorUserId": "-1"}, "25386885": {"Id": "25386885", "PostTypeId": "2", "Body": "<p>The code is undefined behavior in C++11, and ill-formed in C++14.  C++14 adds this <em>Remark</em> to the specification of this constructor:</p>\n<blockquote>\n<p id=\"so_25385876_25386885_0\"><em>Remarks</em>: These constructors shall not participate in overload\n  resolution unless <code>f</code> is Callable (20.9.11.2) for argument types\n  <code>ArgTypes...</code> and return type <code>R</code>.</p>\n</blockquote>\n<p>Callable is defined in [func.wrap.func]/p2:</p>\n<blockquote>\n<p id=\"so_25385876_25386885_1\">A callable object <code>f</code> of type <code>F</code> is <em>Callable</em> for argument types <code>ArgTypes</code>\n  and return type <code>R</code> if the expression <em>INVOKE</em> <code>(f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand\n  (Clause 5), is well formed (20.9.2).</p>\n</blockquote>\n<p>For this <em>INVOKE</em> to be well formed, the return type of <em>INVOKE</em> without the <code>R</code> must be implicitly convertible to <code>R</code> ([func.require]/p2).</p>\n<p>In C++11 these statements were under a <em>Requries</em> clause, which means it is up to the client to get them right, and if the client fails, anything can happen, including successful compilation.</p>\n<p>This was changed by <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2132\">LWG 2132</a>.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2014-08-19T15:28:16.330", "Score": "9", "CreationDate": "2014-08-19T15:06:20.360", "ParentId": "25385876", "CommentCount": "4", "OwnerUserId": "576911", "LastEditDate": "2014-08-19T15:28:16.330"}, "25392559": {"Id": "25392559", "PostTypeId": "2", "Body": "<p><code>std::function</code> in C++11 and 14 does not have the behavior you desire.</p>\n<p>It also fails to SFINAE detect bad overloads.</p>\n<p>We can wrap it in a different type that both has the behavior you desire (<code>void</code> discarding return) and has SFINAE bad overload detection while we are at it as follows:</p>\n<pre><code>template&lt;class Sig&gt;\nstruct checked_function;\n\ntemplate&lt;class R, class... Args&gt;\nstruct checked_function&lt;R(Args...)&gt;:std::function&lt;R(Args...)&gt; {\n  using function = std::function&lt;R(Args...)&gt;;\n  checked_function(std::nullptr_t):function() {}\n  checked_function():function() {}\n  template&lt;class F, class=typename std::enable_if&lt;\n    std::is_convertible&lt;\n      typename std::result_of&lt; F(Args...) &gt;::type\n      , R\n    &gt;::value\n  &gt;::type&gt;\n  checked_function( F&amp;&amp; f ):function( std::forward&lt;F&gt;(f) ) {}\n\n  template&lt;class F, class=typename std::enable_if&lt;\n    std::is_convertible&lt;\n      typename std::result_of&lt; F(Args...) &gt;::type\n      , R\n    &gt;::value\n  &gt;::type&gt;\n  checked_function&amp; operator=( F&amp;&amp; f ) { return function::operator=( std::forward&lt;F&gt;(f) ); }\n\n  checked_function&amp; operator=( checked_function const&amp; o ) = default;\n  checked_function&amp; operator=( checked_function &amp;&amp; o ) = default;\n  checked_function( checked_function const&amp; o ) = default;\n  checked_function( checked_function &amp;&amp; o ) = default;\n};\n\ntemplate&lt;class... Args&gt;\nstruct checked_function&lt;void(Args...)&gt;:std::function&lt;void(Args...)&gt; {\n  using function = std::function&lt;void(Args...)&gt;;\n  checked_function(std::nullptr_t):function() {}\n  checked_function():function() {}\n  template&lt;class F, class=typename std::enable_if&lt;\n    std::is_same&lt;\n      typename std::result_of&lt; F(Args...) &gt;::type\n      , void\n    &gt;::value\n  &gt;::type&gt;\n  checked_function( F&amp;&amp; f, int*unused=nullptr ):function( std::forward&lt;F&gt;(f) ) {}\n\n  template&lt;class F&gt;\n  static auto wrap(F&amp;&amp; f){\n    return [f_=std::forward&lt;F&gt;(f)](auto&amp;&amp;...args){\n      f_( std::forward&lt;decltype(args)&gt;(args)... );\n    };\n  }\n  template&lt;class F, class=typename std::enable_if&lt;\n    !std::is_same&lt;\n      typename std::result_of&lt; F(Args...) &gt;::type\n      , void\n    &gt;::value\n  &gt;::type&gt;\n  checked_function( F&amp;&amp; f, void*unused=nullptr ):\n    function( wrap(std::forward&lt;F&gt;(f)) ) {}\n\n   template&lt;class F&gt;\n  typename std::enable_if&lt;\n    !std::is_same&lt;\n      typename std::result_of&lt; F(Args...) &gt;::type\n      , void\n    &gt;::value,\n    checked_function&amp;\n  &gt;::type operator=( F&amp;&amp; f ) { return function::operator=( wrap(std::forward&lt;F&gt;(f)) ); }\n\n  template&lt;class F&gt;\n  typename std::enable_if&lt;\n    std::is_same&lt;\n      typename std::result_of&lt; F(Args...) &gt;::type\n      , void\n    &gt;::value,\n    checked_function&amp;\n  &gt;::type operator=( F&amp;&amp; f ) { return function::operator=( std::forward&lt;F&gt;(f) ); }\n\n  checked_function&amp; operator=( checked_function const&amp; o ) = default;\n  checked_function&amp; operator=( checked_function &amp;&amp; o ) = default;\n  checked_function( checked_function const&amp; o ) = default;\n  checked_function( checked_function &amp;&amp; o ) = default;\n};\n</code></pre>\n<p>It now compiles in C++14 (not in C++11, due to <code>wrap</code>: <code>wrap</code> can be replaced at point of call with a copy of its own body, so...).  Could probably reduce boilerplate by a bunch.</p>\n<p>It uses some C++14 features (move-into-lambda to be precise in <code>wrap</code> -- you can do away with that by adding more boilerplate).</p>\n<p>Not run yet.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2014-08-20T14:21:58.057", "Score": "3", "CreationDate": "2014-08-19T20:38:35.200", "ParentId": "25385876", "CommentCount": "3", "OwnerUserId": "1774667", "LastEditDate": "2014-08-20T14:21:58.057"}});