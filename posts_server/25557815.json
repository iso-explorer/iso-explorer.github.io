post_cb({"25557864": {"ParentId": "25557815", "CommentCount": "2", "Body": "<p><code>set&lt;T&gt;::iterator</code> is always* a constant iterator, just like <code>set&lt;T&gt;::const_iterator</code>, so you can't use it to modify any elements of the set.  If you could modify elements of the set directly, the set would most likely become unordered, which would just lead to Bad Things\u2122.</p>\n<p>* Well, since C++11, at least, though it's unlikely any major implementations ever had non-const set iterators before that for long anyway.</p>\n", "OwnerUserId": "744178", "PostTypeId": "2", "Id": "25557864", "Score": "4", "CreationDate": "2014-08-28T20:56:06.877", "LastActivityDate": "2014-08-28T20:56:06.877"}, "25557815": {"CommentCount": "2", "AcceptedAnswerId": "25557857", "ClosedDate": "2014-08-28T21:01:02.733", "CreationDate": "2014-08-28T20:52:25.573", "LastActivityDate": "2014-08-28T22:05:43.997", "PostTypeId": "1", "ViewCount": "661", "Title": "Iterator for set of pairs is const?", "Id": "25557815", "Score": "0", "Body": "<p>I get the following error message: \"expression must be a modifiable lvalue iter-&gt;first = iter-&gt;second;\" for the code:</p>\n<pre><code>func( const std::set&lt;Edge&gt; &amp;obstructEdges1,\n      const std::set&lt;Edge&gt; &amp;obstructEdges2 )\n{\nstd::set&lt;Edge&gt; obstructEdges = obstructEdges1;\nobstructEdges.insert( obstructEdges2.begin(), obstructEdges2.end() );\n\nfor ( std::set&lt;Edge&gt;::iterator iter = obstructEdges.begin();\n    iter != obstructEdges.end(); iter++ )\n{\n  if ( iter-&gt;first &gt; iter-&gt;second )\n  {\n    int t = iter-&gt;first;\n    iter-&gt;first = iter-&gt;second;\n    iter-&gt;second = t;\n  }\n...\n</code></pre>\n<p><code>Edge</code> is a pair of ints. What's wrong? Looks like <code>iter-&gt;first</code> is considered <code>const</code> for some reason.</p>\n", "Tags": "<c++><iterator><const><pair>", "OwnerUserId": "2503111", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25557815_25557857_0": {"section_id": 742, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_25557815_25557857_0": {"section_id": 731, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_25557815_25557857_0": {"section_id": 800, "quality": 0.9615384615384616, "length": 25}}}, "25557857": {"ParentId": "25557815", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Yes, <code>std::set</code> iterator is always a const iterator even if the set itself is not <code>const</code>, i.e. <code>std::set::iterator</code> and <code>std::set::const_iterator</code> are both constant iterators (and can refer to the same type). Note that <code>std::set</code> is an associative container. In standard associative containers you are not allowed to modify the stored keys in place, which means that in <code>std::set</code> you are not allowed to modify anything at all. Of course, your comparator does not have to treat the entire set element as the key, but from the <code>std::set</code> point of view the whole thing is the key and is therefore immutable. </p>\n<p>As it says in 23.2.4</p>\n<blockquote>\n<p id=\"so_25557815_25557857_0\"><strong>6</strong> iterator of an associative container is of the bidirectional iterator category. For associative containers where the value type is\n  the same as the key type, both iterator and const_iterator are\n  constant iterators. It is unspecified whether or not iterator and\n  const_iterator are the same type.</p>\n</blockquote>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2014-08-28T22:05:43.997", "Id": "25557857", "Score": "4", "CreationDate": "2014-08-28T20:55:31.253", "LastActivityDate": "2014-08-28T22:05:43.997"}});