post_cb({"26244662": {"CreationDate": "2014-10-07T20:26:57.097", "LastActivityDate": "2015-01-15T18:38:51.583", "LastEditorUserId": "1012936", "ParentId": "26242231", "Id": "26244662", "Score": "3", "Body": "<p>Angew's answer is correct considering C++. Now that the question mentions POSIX environment, which could provide stronger guarantees, this needs another answer, which is:</p>\n<blockquote>\n<p id=\"so_26242231_26244662_0\">If the process is multi-threaded, or if the process is single-threaded and a signal handler is executed other than as the result of:</p>\n<ul>\n<li><p id=\"so_26242231_26244662_1\">The process calling <code>abort()</code>, <code>raise()</code>, <code>kill()</code>, <code>pthread_kill()</code>, or <code>sigqueue()</code> to generate a signal that is not blocked</p></li>\n<li><p id=\"so_26242231_26244662_2\">A pending signal being unblocked and being delivered before the call that unblocked it returns</p></li>\n</ul>\n<p id=\"so_26242231_26244662_3\">the behavior is undefined if the signal handler refers to any object other than <code>errno</code> with static storage duration other than by assigning a value to an object declared as <code>volatile sig_atomic_t</code>, or if the signal handler calls any function defined in this standard other than one of the functions listed in the following table.</p>\n</blockquote>\n<p><a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04\" rel=\"nofollow\">Source: The Open Group Base Specifications Issue 7\nIEEE Std 1003.1, 2013 Edition, 2.4.3</a></p>\n<p>This is... still a very weak guarantee. As far as I can understand this:</p>\n<p><strong><code>vector::operator[]</code> is not safe. <strike>Fixed arrays are not safe.</strike> Access to fixed arrays is safe if the array is non-static.</strong></p>\n<p>Why? <code>vector::operator[]</code> doesn't specify exactly how it should be implemented, only the preconditions and postconditions. The access to elements of an array is possible (if the array is non-static), this implies that the access to vector elements is also safe if you create a pointer (with <code>vec.data()</code> or <code>&amp;vec[0]</code>) before signalling, and then accessing the elements through the pointer.</p>\n<p>EDIT: Originally I missed that because I wasn't aware of the <code>sigaction</code> function - with <code>signal</code> you could only access your local arrays in the signal handler, but with <code>sigaction</code> you can provide pointers to automatic and dynamically arrays. The advice with doing as little as possible in signal handlers still applies here though.</p>\n<p>Bottom line: You're doing too much in your signal handlers. Try doing as little as possible. One approach is to assign to a flag (of type <code>volatile sig_atomic_t</code>), and return. The code can later check if the flag was triggered (e.g. in an event loop)</p>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "1012936", "LastEditDate": "2015-01-15T18:38:51.583"}, "26242322": {"LastActivityDate": "2014-10-07T18:04:56.743", "ParentId": "26242231", "Id": "26242322", "Score": "5", "Body": "<p>No, it's not safe. C++11 1.9/6:</p>\n<blockquote>\n<p id=\"so_26242231_26242322_0\">When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects which\n  are neither</p>\n<ul>\n<li>of type <code>volatile std::sig_atomic_t</code> nor</li>\n<li>lock-free atomic objects (29.4)</li>\n</ul>\n<p id=\"so_26242231_26242322_1\">are unspecified during the execution of the signal handler, and the value of any object not in either of these\n  two categories that is modified by the handler becomes undefined.</p>\n</blockquote>\n", "CommentCount": "13", "PostTypeId": "2", "OwnerUserId": "1782465", "CreationDate": "2014-10-07T18:04:56.743"}, "26246256": {"LastActivityDate": "2014-10-07T22:22:21.320", "ParentId": "26242231", "Id": "26246256", "Score": "1", "Body": "<p>I believe that if you know the <em>reason</em> that access to a vector is not safe then you can work around it. Note that access <em>still</em> isn't guaranteed safe. But it will work on anything that isn't a Death Station 9000.</p>\n<p>A signal handler interrupts the execution of the program much like a interrupt handler would if you were programming directly to the hardware. The operating system simply stops executing your program, <strong>wherever it happens to be</strong>. This might be in the middle of anything. For example, if your vector has elements being added to it and it is updating its size value or it is copying the contents to a new, longer vector, that might be interrupted by the signal. And then your signal handler would try to read from the vector resulting in disaster.</p>\n<p>You can access the vector from the signal handler as long as it is effectively constant. If you set up the whole thing at program start and then never write to it again, it is safe to use. Note, not safe to use according to the standards documents, but effectively safe.</p>\n<p>This is a lot like multi-threading on a single-core CPU.</p>\n<p>Now, if you do need to update the vector while the program is running you need to \"lock\" the signal handler away from it by masking the signal or disabling the handler before updating the vector, to ensure that the handler won't run while the vector is in an inconsistent state.</p>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "13422", "CreationDate": "2014-10-07T22:22:21.320"}, "bq_ids": {"n3337": {"so_26242231_26242322_1": {"section_id": 5575, "quality": 1.0, "length": 14}, "so_26242231_26242322_0": {"section_id": 5575, "quality": 1.0, "length": 10}}}, "26242231": {"CreationDate": "2014-10-07T17:59:41.207", "AcceptedAnswerId": "26244662", "Tags": "<c++><vector><posix><signal-handling><async-safe>", "AnswerCount": "3", "OwnerUserId": "681231", "Body": "<p>My program needs to perform read-only access to the contents of a <code>vector&lt;string&gt;</code> in a signal handler for <code>SIGINT</code>. (The alternative is to use a fixed-size array of fixed-length C strings.) The program is designed to run in a POSIX environment.</p>\n<p>Are <code>vector::operator[]</code> and <code>vector::size()</code> asynchronous-safe (or signal-safe)?</p>\n", "CommentCount": "0", "PostTypeId": "1", "ViewCount": "303", "FavoriteCount": "1", "LastActivityDate": "2015-01-15T18:38:51.583", "Id": "26242231", "LastEditorUserId": "681231", "Title": "Is read-only access to a vector (vector::operator[] and vector::size()) asynchronous-safe?", "Score": "4", "LastEditDate": "2014-10-07T20:53:07.697"}});