post_cb({"bq_ids": {"n4140": {"so_14920997_14921057_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 2865}}, "n3337": {"so_14920997_14921057_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 2786}}, "n4659": {"so_14920997_14921057_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 3615}}}, "14921057": {"Id": "14921057", "PostTypeId": "2", "Body": "<p>The standard defines that <code>std::unique_lock</code> constructor with:</p>\n<blockquote>\n<pre><code>unique_lock(mutex_type&amp; m, try_to_lock_t);\n</code></pre>\n<p id=\"so_14920997_14921057_0\"><em>Requires:</em> The supplied Mutex type shall meet the Lockable requirements (30.2.5.3). If mutex_type is not a recursive mutex <strong>the calling thread does not own the mutex</strong>.</p>\n</blockquote>\n<p>So the behavior is undefined since you're violating the requirement for that call. (<code>std::mutex</code> is not recursive.)</p>\n", "LastActivityDate": "2013-02-17T12:24:23.637", "CommentCount": "0", "CreationDate": "2013-02-17T12:24:23.637", "ParentId": "14920997", "Score": "4", "OwnerUserId": "635608"}, "14920997": {"ViewCount": "905", "Body": "<p>The following code results in different outputs with VS2012 Express and gcc 4.7.2, which is what <a href=\"http://ideone.com\" rel=\"nofollow\">ideone</a> uses. For the record, I tried to compile with MinGW, but it does not implement C++11's &lt;mutex&gt; as stated <a href=\"http://kbokonseriousstuff.blogspot.com.br/2011/08/c11-standard-library-threads-with-mingw.html\" rel=\"nofollow\">here</a>.</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::mutex m;\n    {\n            std::unique_lock&lt;std::mutex&gt; l(m, std::try_to_lock);\n            std::cout &lt;&lt; (bool)l &lt;&lt;std::endl;\n    }\n    {\n            m.lock();\n            std::unique_lock&lt;std::mutex&gt; l(m, std::try_to_lock);\n            std::cout &lt;&lt; (bool)l &lt;&lt;std::endl;\n    }\n}\n</code></pre>\n<p>In visual studio, the second test prints 0, which means the lock does not own the mutex, since it was already locked.</p>\n<p>With gcc, the second test prints 1, meaning that the lock aquired the mutex, even if already locked, as in <code>std::adopt_lock</code>.</p>\n<p>Which one is correct ?</p>\n", "AcceptedAnswerId": "14921057", "Title": "Should unique_lock with try_to_lock owns the mutex even if lock fails?", "CreationDate": "2013-02-17T12:17:46.457", "Id": "14920997", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-02-17T12:24:23.637", "Score": "0", "OwnerUserId": "231306", "Tags": "<c++><gcc><visual-studio-2012><mutex>", "AnswerCount": "1"}});