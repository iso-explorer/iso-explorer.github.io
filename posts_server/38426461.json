post_cb({"38426597": {"Id": "38426597", "PostTypeId": "2", "Body": "<p>Your example compiles with <a href=\"http://edg.com/\" rel=\"nofollow\">EDG</a> and <a href=\"http://clang.llvm.org/\" rel=\"nofollow\">clang</a> but it does not compile with <a href=\"http://gcc.gnu.org/\" rel=\"nofollow\">gcc</a>. I'm not sure if the code should compile as is as it seems the constructor of the abstract base class is declared as deleted: According to 12.1 [class.ctor] paragraph 4, sixth bullet, the defaulted default constructor is declared as deleted if any subobject doesn't have a default constructor:</p>\n<blockquote>\n<p id=\"so_38426461_38426597_0\">...  A defaulted default constructor for class X is defined as deleted if:\n  ...</p>\n<ul>\n<li>...</li>\n<li>any potentially constructed subobject, except for a non-static data member with a brace-or-equalinitializer, has class type <code>M</code> (or array thereof) and either <code>M</code> has no default constructor or overload resolution (13.3) as applied to <code>M</code>\u2019s default constructor results in an ambiguity or in a function that is deleted or inaccessible from the defaulted default constructor, or</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>There is no special exemption for classes with <code>virtual</code> bases with respect to creation of <code>virtual</code> bases, i.e., the defaulted default constructor will be deleted.</p>\n<p>For abstract classes it is apparently not necessary to call the virtual base from a constructors member initializer list. At least, that is what 12.6.2 [class.base.init] paragraph 8 says according to its note:</p>\n<blockquote>\n<p id=\"so_38426461_38426597_1\">In a non-delegating constructor, if a given potentially constructed subobject is not designated by a meminitializer-id (including the case where there is no mem-initializer-list because the constructor has no ctorinitializer), then</p>\n<ul>\n<li>if the entity is a non-static data member that has a brace-or-equal-initializer and either</li>\n<li>the constructor\u2019s class is a union (9.5), and no other variant member of that union is designated by a mem-initializer-id or</li>\n<li>the constructor\u2019s class is not a union, and, if the entity is a member of an anonymous union, no other member of that union is designated by a mem-initializer-id, the entity is initialized as specified in 8.5;</li>\n<li>otherwise, if the entity is an anonymous union or a variant member (9.5), no initialization is performed;</li>\n<li>otherwise, the entity is default-initialized (8.5).</li>\n</ul>\n<p id=\"so_38426461_38426597_2\">[ Note: An abstract class (10.4) is never a most derived class, thus its constructors never initialize virtual base classes, therefore the corresponding mem-initializers may be omitted. \u2014 end note ] ...</p>\n</blockquote>\n<p>The relevant part for the most derived base is in 12.6.2 paragraph 7, last sentence:</p>\n<blockquote>\n<p id=\"so_38426461_38426597_3\">... A mem-initializer where the mem-initializer-id denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.</p>\n</blockquote>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2016-07-18T01:16:33.603", "Score": "4", "CreationDate": "2016-07-17T22:38:39.030", "ParentId": "38426461", "CommentCount": "4", "OwnerUserId": "1120273", "LastEditDate": "2016-07-18T01:16:33.603"}, "38426586": {"Id": "38426586", "PostTypeId": "2", "Body": "<p>Unfortunately the C+03 language didn't make abstract classes a special case wrt. constructor invocations, and still as of C++11 and later the g++ compiler (my version 5.1.0) doesn't regard them as special for this.</p>\n<p>And so in practice, for portable code, all bases must be initialized, <em>as far as the compiler knows</em>.</p>\n<p>If you want to make it clear to a reader of the source code that these are dummy calls, then you can do that via comments, or better, expressed directly in the source code with an <code>assert</code>:</p>\n<pre><code>#include &lt;assert.h&gt;\n\nstruct Dummy_call {};\n\nclass VirtualBase\n{\nprivate:\n    int count;\n\nprotected:\n    VirtualBase( Dummy_call ) { assert( false ); }\n\npublic:\n    auto getCount() const -&gt; int {\n        return count;\n    }\n    void increment() {\n        ++count;\n    }\n\n    VirtualBase( int const initial )\n        : count(initial)\n    {}\n};\n\nclass ContractA\n    : public virtual VirtualBase\n{\npublic:\n    virtual void doSomething() = 0;\n    ContractA(): VirtualBase( Dummy_call{} ) {}\n};\n\nclass ContractB\n    : public virtual VirtualBase\n{\npublic:\n    virtual void doSomethingElse() = 0;\n    ContractB(): VirtualBase( Dummy_call{} ) {}\n};\n\nclass Concrete\n    : public ContractA\n    , public ContractB\n{\npublic:\n    void doSomething() override {\n        increment();\n    }\n    void doSomethingElse() override {}   // etc...\n\n    Concrete()\n        : VirtualBase{ 0 }\n    {}\n};\n\nint main()\n{\n    Concrete concrete;\n    concrete.doSomething();\n    concrete.doSomethingElse();\n}\n</code></pre>\n", "LastEditorUserId": "464581", "LastActivityDate": "2016-07-17T23:12:59.667", "Score": "3", "CreationDate": "2016-07-17T22:37:16.263", "ParentId": "38426461", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2016-07-17T23:12:59.667"}, "38426461": {"ViewCount": "340", "Body": "<p>I am having trouble with multiple inheritance and the diamond problem. </p>\n<p>The problem occurs because my base class constructor requires a parameter. The compiler tries to generate a default constructor for my two abstract classes, but that fails because the default constructor cannot determine the parameter for the base class.</p>\n<p>I don't understand why my abstract classes are calling the base constructor. I thought the most derived class is the one that calls the virtual base class constructor.</p>\n<p>Here is code that reproduces what I'm talking about:</p>\n<pre><code>class VirtualBase\n{\n\n        public:\n\n                VirtualBase(int initial) :\n                        count(initial)\n        {}\n\n                int getCount() const\n                {\n                        return count;\n                }\n\n                void increment()\n                {\n                        count++;\n                }\n\n        private:\n\n                int count;\n\n};\n\n\nclass ContractA : public virtual VirtualBase\n{\n\n        public:\n\n                virtual void doSomething() = 0;\n\n};\n\nclass ContractB : public virtual VirtualBase\n{\n\n        public:\n\n                virtual void doSomethingElse() = 0;\n\n};\n\nclass Concrete : public ContractA, public ContractB\n{\n\n        public:\n\n                Concrete() : \n                        VirtualBase(0)\n        {}\n\n                virtual void doSomething()\n                {\n                         increment();\n                }\n\n                virtual void doSomethingElse()\n                {\n                        // etc...       \n                }\n\n};\n\nint main()\n{\n\n        Concrete concrete;\n        concrete.doSomething();\n        concrete.doSomethingElse();\n        return 0;\n}\n</code></pre>\n<p>I get the following error (for each Contract):</p>\n<pre><code>main.cpp: In constructor \u2018ContractA::ContractA()\u2019:\nmain.cpp:29:7: error: no matching function for call to \u2018VirtualBase::VirtualBase()\u2019\n class ContractA : public virtual VirtualBase\n       ^\nmain.cpp:29:7: note: candidates are:\nmain.cpp:9:3: note: VirtualBase::VirtualBase(int)\n   VirtualBase(int initial) :\n   ^\nmain.cpp:9:3: note:   candidate expects 1 argument, 0 provided\nmain.cpp:4:7: note: VirtualBase::VirtualBase(const VirtualBase&amp;)\n class VirtualBase\n       ^\nmain.cpp:4:7: note:   candidate expects 1 argument, 0 provided\nmain.cpp: In constructor \u2018Concrete::Concrete()\u2019:\nmain.cpp:53:17: note: synthesized method \u2018ContractA::ContractA()\u2019 first required here \n    VirtualBase(0)\n                 ^\n</code></pre>\n", "Title": "Do you need to call virtual base class constructor from all derived classes? Even if they're not the most derived?", "CreationDate": "2016-07-17T22:18:20.627", "LastActivityDate": "2016-07-18T01:16:33.603", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "Id": "38426461", "Score": "2", "OwnerUserId": "2445507", "Tags": "<c++><inheritance><abstract-class><multiple-inheritance><diamond-problem>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_38426461_38426597_1": {"length": 17, "quality": 1.0, "section_id": 435}, "so_38426461_38426597_3": {"length": 15, "quality": 1.0, "section_id": 434}, "so_38426461_38426597_2": {"length": 19, "quality": 0.8260869565217391, "section_id": 435}, "so_38426461_38426597_0": {"length": 6, "quality": 1.0, "section_id": 369}}, "n3337": {"so_38426461_38426597_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 427}, "so_38426461_38426597_3": {"length": 15, "quality": 1.0, "section_id": 426}, "so_38426461_38426597_2": {"length": 19, "quality": 0.8260869565217391, "section_id": 427}, "so_38426461_38426597_0": {"length": 6, "quality": 1.0, "section_id": 359}}, "n4659": {"so_38426461_38426597_1": {"length": 17, "quality": 1.0, "section_id": 454}, "so_38426461_38426597_3": {"length": 15, "quality": 1.0, "section_id": 452}, "so_38426461_38426597_2": {"length": 19, "quality": 0.8260869565217391, "section_id": 454}, "so_38426461_38426597_0": {"length": 6, "quality": 1.0, "section_id": 382}}}, "38426775": {"Id": "38426775", "PostTypeId": "2", "Body": "<p>Your code is well-formed since C++11.  Unfortunately, you're seeing gcc bug <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53878\" rel=\"nofollow\">53878</a>.</p>\n", "LastActivityDate": "2016-07-17T23:09:48.150", "CommentCount": "0", "CreationDate": "2016-07-17T23:09:48.150", "ParentId": "38426461", "Score": "1", "OwnerUserId": "459640"}});