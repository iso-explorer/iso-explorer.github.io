post_cb({"bq_ids": {"n4140": {"so_41263504_41454584_1": {"length": 8, "quality": 1.0, "section_id": 48}, "so_41263504_41263504_1": {"length": 30, "quality": 0.967741935483871, "section_id": 5900}, "so_41263504_41263504_2": {"length": 6, "quality": 1.0, "section_id": 5906}, "so_41263504_41263504_0": {"length": 8, "quality": 1.0, "section_id": 48}, "so_41263504_41454584_0": {"length": 9, "quality": 0.9, "section_id": 5900}}, "n3337": {"so_41263504_41454584_1": {"length": 6, "quality": 0.75, "section_id": 43}, "so_41263504_41263504_1": {"length": 30, "quality": 0.967741935483871, "section_id": 5672}, "so_41263504_41263504_0": {"length": 6, "quality": 0.75, "section_id": 43}, "so_41263504_41263504_2": {"length": 6, "quality": 1.0, "section_id": 5678}, "so_41263504_41454584_0": {"length": 9, "quality": 0.9, "section_id": 5672}}, "n4659": {"so_41263504_41454584_1": {"length": 7, "quality": 0.875, "section_id": 49}, "so_41263504_41263504_1": {"length": 30, "quality": 0.967741935483871, "section_id": 7382}, "so_41263504_41263504_2": {"length": 6, "quality": 1.0, "section_id": 7388}, "so_41263504_41263504_0": {"length": 7, "quality": 0.875, "section_id": 49}, "so_41263504_41454584_0": {"length": 9, "quality": 0.9, "section_id": 7382}}}, "41263504": {"ViewCount": "308", "Body": "<p>For example:</p>\n<pre><code>class example{\n    public:\n        template &lt;class T&gt; static constexpr T var = T(1.5);\n};\n\nint main(){\n\n    int a = example::var&lt;int&gt;;\n\n    example obj;\n    int b = obj.var&lt;int&gt;;\n\n    return 0;\n}\n</code></pre>\n<p>GCC produces error for both: \n<code>'example::var&lt;T&gt;' is not a function template</code> and <code>'var' is not a member template function</code></p>\n<p>Clang compiles correctly the first one but produces an error for the second: <code>cannot refer to member 'var' in 'example' with '.'</code></p>\n<p>According to the C++14 Standard (ISO/IEC 14882:2014):</p>\n<p>Section 14, Paragraph 1.</p>\n<blockquote>\n<p id=\"so_41263504_41263504_0\">A variable template at class scope is a static data member template.</p>\n</blockquote>\n<p>Section 9.4, Paragraph 2.</p>\n<blockquote>\n<p id=\"so_41263504_41263504_1\">A static member s of class X may be referred to using the qualified-id expression X::s; it is not necessary to use the class member access syntax (5.2.5) to refer to a static member. A static member may be referred to using the class member access syntax, in which case the object expression is evaluated.</p>\n</blockquote>\n<p>Therefore, IMHO, a Variable Template at Class scope (i.e., a Static Data Member Template) could be referred to in both ways. Could it be a bug in the compilers?</p>\n<p>The only thing I found to try to justify this behaviour is this sentence in Section 9.4.2, Paragraph 1:</p>\n<blockquote>\n<p id=\"so_41263504_41263504_2\">A static data member is not part of the subobjects of a class.</p>\n</blockquote>\n<p>However, the two aforementioned paragraphs are still valid. Besides, I tried the same example referring to other static members such as a variable, a function and a function template, and all of them compile successfully in both GCC and Clang.</p>\n<pre><code>class example{\n    public:\n        static int constexpr variable = 1;\n        void static function(){ return; }\n        template &lt;class T&gt; void static function_template(){ return; }\n};\n\nint main(){\n\n    example obj;\n\n    int a = obj.variable;\n    int b = example::variable;\n\n    obj.function();\n    example::function();\n\n    obj.function_template&lt;int&gt;();\n    example::function_template&lt;int&gt;();\n\n   return 0;\n}\n</code></pre>\n<p>Thanks in Advance.</p>\n<p>Note 1: compiler versions are clang 3.7.0 and gcc 5.2.1.</p>\n<p>Note 2: the keyword <code>static</code> is required: <a href=\"https://stackoverflow.com/questions/21474111/variable-template-at-class-scope\">Variable template at class scope</a> </p>\n<p>Note 3: since I want to initialize the variable template, the keyword <code>constexpr</code> is also required because in my actual code I will instantiate it with float, double and long double (see C++14 Standard (ISO/IEC 14882:2014), Section 9.4.2, Paragraph 3).</p>\n<p>Note 4: actual \"definitions\" of these static data members outside the class (i.e., <code>template &lt;class T&gt; constexpr T example::var;</code>) are not needed in this example cases. I also tried though, but it makes no difference.</p>\n", "AcceptedAnswerId": "41454584", "Title": "How should a Variable Template be referred to in C++14 when declared at Class scope?", "CreationDate": "2016-12-21T13:07:24.490", "Id": "41263504", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:46.777", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-04T01:09:41.423", "Score": "17", "OwnerUserId": "7325235", "Tags": "<c++><templates><c++14><static-members><variable-templates>", "AnswerCount": "1"}, "41454584": {"Id": "41454584", "PostTypeId": "2", "Body": "<p>I copied your first code into Visual Studio 2015 (it compiled successfully). I added a few outputs via <code>std::cout</code>, where I found using <code>b</code> gives a compiler error: <code>uninitialized local variable 'b' used</code>. <code>a</code> on the other hand, was successfully printed when <code>b</code> was not used. So it would seem c++ is a bit finicky about accessing template static members as you said, requiring you to reference it by its complete, qualified name.</p>\n<p>Perhaps more curious, are the following lines:</p>\n<pre><code>std::cout &lt;&lt; example::var&lt;int&gt; &lt;&lt; \"a\\n\";\n</code></pre>\n<p>The above line works as expected, outputting <code>1.5</code> truncated to <code>1</code> and an <code>'a'</code> with a new line. Nothing to write home about.</p>\n<pre><code>std::cout &lt;&lt; obj.var&lt;int&gt; &lt;&lt; \"b\\n\";\n</code></pre>\n<p>Now here's where it gets interesting... Not only does the above line not print out a value for <code>obj.var&lt;int&gt;</code>, the <code>'b'\\n</code> never gets printed either. I even tested against the <code>std::cout</code>'s <code>good()</code> <code>fail()</code> and <code>bad()</code> functions, none of which reported that anything was wrong (and further uses of <code>std::cout</code> were executed successfully outputted).</p>\n<p>Another oddity I found was that <code>auto x = obj.var</code> is legal, and come to find, x is of type <code>example</code>. Now, doing this with a global template variable results in a compiler error (as I expected the first one to as well):</p>\n<pre><code>template&lt;typename T&gt; constexpr T ex = 1.5;\nauto x = ex // compiler error: argument list for variable template \"ex\" is missing\n</code></pre>\n<p>Additionally, I found that access <code>var</code> through another template static function was successful, further implying that member selection just doesn't work in this case</p>\n<pre><code>class example\n{\npublic:\n    template &lt;class T&gt; static constexpr T var = T(1.5);\n    template &lt;typename T&gt; static void thing()\n    {\n        std::cout &lt;&lt; var&lt;T&gt; &lt;&lt; '\\n';          // works\n        std::cout &lt;&lt; example::var&lt;T&gt; &lt;&lt; '\\n'; // also works\n    }\n};\n</code></pre>\n<p>Now, as far as the standard goes, I'm inclined to believe their phrasing is just a bit ... pedantic. The sections you've quoted from the standard:</p>\n<blockquote>\n<p id=\"so_41263504_41454584_0\">it is not necessary to use the class member access syntax (5.2.5) to refer to a static member.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_41263504_41454584_1\">A variable template at class scope is a static data member template.</p>\n</blockquote>\n<p>would seem to imply that this would work. I believe the point where these quotes don't apply in this case is the technicality that a template (of anything) doesn't really \"exist\" until it is instantiated in a compilation unit (i.e. why the code for templates is often included in the header file itself).</p>\n<p>Because of this, although the template variable can be a member of a class, its instantiations aren't ... for some reason ... and therefore require the scope resolution operator as opposed to the member selection operator.</p>\n<p>But IMO, accessing static data via the member selection operator is bad practice, as static data and functions are not actually part of a given object. Accessing static data the same way as non-static data can cause relatively-innocent looking code to actually be flawed logic. For instance if for some reason you had a non-const static member called <code>something</code>, you could write <code>example_object.something = 42</code>, not expecting anything to change for all other instantiations of that class throughout your program (the same issues as global variables, really). Because of this (and the fact that member access syntax apparently doesn't work for template static member variables anyway), I recommend always using scope resolution to access/modify static content from outside of the class. <code>example_class::something = 42</code> is a lot more clear that we're changing <code>something</code> for <strong>all</strong> instances of <code>example_class</code>. In fact, some more-modern languages like C# <em>require</em> you to access static data via the class name unless you're inside said class.</p>\n<p>Given that several compilers are erroring for different parts of this little example program, I'd be willing to bet it's not covered very well in the standard (and probably not used very often in practice), and the compilers just handle it differently (another reason to avoid it).</p>\n<p><strong>tl;dr</strong></p>\n<p>Apparently while member selection syntax works for static member variables, it doesn't work for template static member variables (though the compiler doesn't seem to complain). However, the scope resolution syntax <em>does</em> work, and IMO should be preferred anyway.</p>\n", "LastEditorUserId": "7366953", "LastActivityDate": "2017-01-04T01:09:41.423", "Score": "2", "CreationDate": "2017-01-04T00:48:20.683", "ParentId": "41263504", "CommentCount": "3", "OwnerUserId": "7366953", "LastEditDate": "2017-01-04T01:09:41.423"}});