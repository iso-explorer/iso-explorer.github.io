post_cb({"30911330": {"ParentId": "24470404", "CommentCount": "0", "CreationDate": "2015-06-18T09:19:40.923", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "30911330", "Score": "0", "Body": "<p>First the left-hand side of <code>::</code> is looked up, and then the right-hand side is looked up inside it. So, to look up <code>N::i</code>, first it finds <code>N</code> using unqualified lookup, then it looks inside <code>N</code> to find <code>i</code>. Simple!</p>\n<p>In your example, you redefine <code>N</code> locally. After the local definition, the outer definition is hidden per \u00a73.3.10: <em>\"A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived class.\"</em></p>\n<p>Since the compiler knows at the outset that the left-hand side (<code>N</code>) must yield a type, namespace, or enumeration, any other lookup results (i.e. functions, variables, and templates) are ignored. So, you could also do:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct N { enum { i = 1 }; };\n\nint main()\n{\n    int N = 3;\n    std::cout &lt;&lt; N::i &lt;&lt; '\\n'; // prints 1\n    std::cout &lt;&lt; N &lt;&lt; '\\n'; // prints 3\n\n    struct N { enum { i = 0 }; };\n\n    std::cout &lt;&lt; N::i &lt;&lt; '\\n'; // prints 0\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9a7c9e34b1e74ce7\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/9a7c9e34b1e74ce7</a></p>\n<p>See \u00a73.4.3/1:</p>\n<blockquote>\n<p id=\"so_24470404_30911330_0\">The name of a class or namespace member or enumerator can be referred to after the <code>::</code> scope resolution operator (5.1) applied to a nested-name-specifier that denotes its class, namespace, or enumeration. If a <code>::</code> scope resolution operator in a nested-name-specifier is not preceded by a decltype-specifier, lookup of the name preceding that <code>::</code> considers only namespaces, types, and templates whose specializations are types. If the name found does not designate a namespace or a class, enumeration, or dependent type, the program is ill-formed.</p>\n</blockquote>\n", "LastActivityDate": "2015-06-18T09:19:40.923"}, "24470404": {"CommentCount": "2", "ViewCount": "173", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2014-06-28T19:54:00.247", "LastActivityDate": "2015-06-18T09:19:40.923", "Title": "I don't understand 3.4/2 in the Standard", "LastEditDate": "2014-06-29T15:14:54.010", "Id": "24470404", "Score": "4", "Body": "<p>I don't understand 3.4/2 in the Standard:</p>\n<blockquote>\n<p id=\"so_24470404_24470404_0\">A name \u201clooked up in the context of an expression\u201d is looked up as an\n  unqualified name in the scope where the expression is found.</p>\n</blockquote>\n<p>What if the name is qualified, as <code>N::i</code> below?</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace N { int i = 1; }\n\nint main()\n{\n    int i = 0;\n\n    std::cout &lt;&lt; N::i &lt;&lt; '\\n';\n}\n</code></pre>\n<p>The qualified name <code>N::i</code> is not looked up in the scope where <code>N::i</code> is found, i.e., it's not looked up in the scope of main() and the global scope!</p>\n", "Tags": "<c++><c++11><language-lawyer><name-lookup><qualified-name>", "OwnerUserId": "3694387", "AnswerCount": "2"}, "24477408": {"ParentId": "24470404", "CommentCount": "1", "CreationDate": "2014-06-29T15:14:24.300", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "24477408", "Score": "0", "Body": "<p>To expand on the comment by @JerryCoffin, the rules for qualified lookup are:</p>\n<p><strong>3.4.3 Quali\ufb01ed name lookup [basic.lookup.qual]</strong></p>\n<blockquote>\n<p id=\"so_24470404_24477408_0\">3 In a declaration in which the declarator-id is a quali\ufb01ed-id, names\n  used before the quali\ufb01ed-id being declared are looked up in the\n  de\ufb01ning namespace scope; names following the quali\ufb01ed-id are looked up\n  in the scope of the member\u2019s class or namespace.</p>\n</blockquote>\n<p>Here's an example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct N { enum { i = 1 }; };\n\nint main()\n{\n    std::cout &lt;&lt; N::i &lt;&lt; '\\n'; // prints 1\n\n    struct N { enum { i = 0 }; };\n\n    std::cout &lt;&lt; N::i &lt;&lt; '\\n'; // prints 0\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/220317a58490b37b\" rel=\"nofollow\"><strong>Live Example</strong></a>.</p>\n", "LastActivityDate": "2014-06-29T15:14:24.300"}, "bq_ids": {"n4140": {"so_24470404_24477408_0": {"section_id": 7109, "quality": 0.8, "length": 16}, "so_24470404_24470404_0": {"section_id": 7084, "quality": 1.0, "length": 11}, "so_24470404_30911330_0": {"section_id": 7107, "quality": 0.9777777777777777, "length": 44}}, "n3337": {"so_24470404_24477408_0": {"section_id": 6853, "quality": 0.8, "length": 16}, "so_24470404_24470404_0": {"section_id": 6828, "quality": 1.0, "length": 11}, "so_24470404_30911330_0": {"section_id": 6851, "quality": 0.9777777777777777, "length": 44}}, "n4659": {"so_24470404_24477408_0": {"section_id": 8610, "quality": 0.8, "length": 16}, "so_24470404_24470404_0": {"section_id": 8585, "quality": 1.0, "length": 11}, "so_24470404_30911330_0": {"section_id": 8608, "quality": 0.9777777777777777, "length": 44}}}});