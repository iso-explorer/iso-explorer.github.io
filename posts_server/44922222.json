post_cb({"bq_ids": {"n4140": {"so_44922222_44922513_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 480}}, "n3337": {"so_44922222_44922513_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 471}}, "n4659": {"so_44922222_44922513_0": {"length": 40, "quality": 0.975609756097561, "section_id": 502}}}, "44922513": {"Id": "44922513", "PostTypeId": "2", "Body": "<pre><code>Auto_ptr4&lt;Resource&gt; generateResource()\n{\n    Auto_ptr4&lt;Resource&gt; res(new Resource);\n    return res; // this return value will invoke the move constructor\n}\n</code></pre>\n<p>Your code is written in a way that very much allows for copy elision. The C++ standard has an entire section devoted to just this use case. </p>\n<p><a href=\"http://eel.is/c++draft/class.copy.elision#1.1\" rel=\"noreferrer\">[class.copy.elision/1.1]</a></p>\n<blockquote>\n<p id=\"so_44922222_44922513_0\">in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function parameter or a variable introduced by the exception-declaration of a handler ([except.handle])) with the same type (ignoring cv-qualification) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function call's return object</p>\n</blockquote>\n<p>If you want to prevent elision, you need to return an expression that cannot be elided legally. Fortunately it's rather easy in this case to also force a move constructor to be called:</p>\n<pre><code>Auto_ptr4&lt;Resource&gt; generateResource()\n{\n    Auto_ptr4&lt;Resource&gt; res(new Resource);\n    return std::move(res); // this return value will invoke the move constructor\n}\n</code></pre>\n<p>Since now the expression is not an automatic variable name, nor is <code>Auto_ptr4&lt;Resource&gt;&amp;&amp;</code> the same exactly as <code>Auto_ptr4&lt;Resource&gt;</code>. The c'tor isn't elided.</p>\n<p>This is fine for learning purposes, but don't do it in real code. Copy elision is a very good thing that makes for more efficient code. Let the compiler do it for you when it can.</p>\n", "LastActivityDate": "2017-07-05T09:40:38.157", "CommentCount": "1", "CreationDate": "2017-07-05T09:40:38.157", "ParentId": "44922222", "Score": "4", "OwnerUserId": "817643"}, "44922222": {"ViewCount": "88", "Body": "<p>I came across the following program from learncpp.com as an example for understanding the move semantics. I tried to run this program and see how the program flow is working as explained in the tutorial.</p>\n<p>But, I fail to understand it in the function call.</p>\n<pre><code>Auto_ptr4&lt;Resource&gt; generateResource()\n{\n    Auto_ptr4&lt;Resource&gt; res(new Resource);\n    return res; // this return value will invoke the move constructor\n}\n</code></pre>\n<p>Where it has been said that will use move constructor, but it is not doing that at all when I set a break point and debug.</p>\n<p>Can anyone help me to understand why move constructor is not invoked here ? Does compiler eliding here ? If so, how to modify this so it will invoke move constructor. Please explain what is happening here. </p>\n<p>Also, it would be great if you can share with some examples of where move constructor is called and how to use move constructors in place of copy constructor. </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nclass Auto_ptr4\n{\n    T* m_ptr;\npublic:\n    Auto_ptr4(T* ptr = nullptr)\n    :m_ptr(ptr)\n    {\n    }\n\n    ~Auto_ptr4()\n    {\n        delete m_ptr;\n    }\n\n    // Copy constructor\n    // Do deep copy of a.m_ptr to m_ptr\n    Auto_ptr4(const Auto_ptr4&amp; a)\n    {\n        m_ptr = new T;\n        *m_ptr = *a.m_ptr;\n    }\n\n    // Move constructor\n    // Transfer ownership of a.m_mptr to m_ptr\n    Auto_ptr4(Auto_ptr4&amp;&amp; a)\n    : m_ptr(a.m_ptr)\n    {\n        a.m_ptr = nullptr;\n    }\n\n    // Copy assignment\n    // Do deep copy of a.m_ptr to m_ptr\n    Auto_ptr4&amp; operator=(const Auto_ptr4&amp; a)\n    {\n        // Self-assignment detection\n        if (&amp;a == this)\n            return *this;\n\n        // Release any resource we're holding\n        delete m_ptr;\n\n        // Copy the resource\n        m_ptr = new T;\n        *m_ptr = *a.m_ptr;\n\n        return *this;\n    }\n\n    // Move assignment\n    // Transfer ownership of a.m_ptr to m_ptr\n    Auto_ptr4&amp; operator=(Auto_ptr4&amp;&amp; a)\n    {\n        // Self-assignment detection\n        if (&amp;a == this)\n            return *this;\n\n        // Release any resource we're holding\n        delete m_ptr;\n\n        // Transfer ownership of a.m_ptr to m_ptr\n        m_ptr = a.m_ptr;\n        a.m_ptr = nullptr;\n\n        return *this;\n    }\n\n    T&amp; operator*() const { return *m_ptr; }\n    T* operator-&gt;() const { return m_ptr; }\n    bool isNull() const { return m_ptr == nullptr; }\n};\n\nclass Resource\n{\npublic:\n    Resource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\n    ~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\n};\n\nAuto_ptr4&lt;Resource&gt; generateResource()\n{\n    Auto_ptr4&lt;Resource&gt; res(new Resource);\n    return res; // this return value will invoke the move constructor\n}\n\nint main()\n{\n    Auto_ptr4&lt;Resource&gt; mainres;\n    mainres = generateResource(); // this assignment will invoke the move assignment\n\n    return 0;\n}\n</code></pre>\n<p>Thanks</p>\n", "AcceptedAnswerId": "44922513", "Title": "Understanding move semantics with objects returned by a function", "CreationDate": "2017-07-05T09:28:05.987", "Id": "44922222", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-07-05T12:55:36.420", "Score": "1", "OwnerUserId": "7152961", "Tags": "<c++><constructor><move-semantics>", "AnswerCount": "1"}});