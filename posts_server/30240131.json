post_cb({"bq_ids": {"n4140": {"so_30240131_30241944_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 5964}, "so_30240131_30241944_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5962}, "so_30240131_30241944_4": {"length": 14, "quality": 1.0, "section_id": 336}}, "n3337": {"so_30240131_30241944_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5731}, "so_30240131_30241944_4": {"length": 14, "quality": 1.0, "section_id": 326}}, "n4659": {"so_30240131_30241944_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 7453}, "so_30240131_30241944_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7451}, "so_30240131_30241944_4": {"length": 14, "quality": 1.0, "section_id": 345}}}, "30240214": {"Id": "30240214", "PostTypeId": "2", "Body": "<p>Type deduction for <code>auto</code> does not consider default arguments.</p>\n", "LastActivityDate": "2015-05-14T14:42:33.097", "Score": "19", "CreationDate": "2015-05-14T14:42:33.097", "ParentId": "30240131", "CommentCount": "3", "OwnerUserId": "2073257"}, "30241944": {"Id": "30241944", "PostTypeId": "2", "Body": "<p>Since lambdas are <em>sugar</em> for functors, the issue is on the fact template functions are unable to deduce template arguments (<code>auto</code>) in this default context.</p>\n<p>A lambda can be reduced to the functor struct level by taking in consideration those statements:</p>\n<p><em>\u00a75.1.2/3 [expr.prim.lambda]</em></p>\n<blockquote>\n<p id=\"so_30240131_30241944_0\">The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type [...]</p>\n</blockquote>\n<p><em>\u00a75.1.2/5 [expr.prim.lambda]</em></p>\n<blockquote>\n<p id=\"so_30240131_30241944_1\">[...] For a generic lambda, the closure type has a public inline function call operator member template (14.5.2) whose template-parameter-list consists of one invented type\n  template-parameter for each occurrence of auto in the lambda\u2019s parameter-declaration-clause, in order of appearance. [...]</p>\n</blockquote>\n<p>As such the type of your lambda is equivalent to this functor type:</p>\n<pre><code>struct unnamed\n{\n    template&lt;typename Auto1&gt;\n    auto operator()(Auto1 = []{})\n    {\n    }\n};\n</code></pre>\n<p>And your usage is then equivalent to:</p>\n<pre><code>int main() {\n    auto lambda = unnamed();\n    lambda();\n}\n</code></pre>\n<p>The type of <code>Auto1</code> is unable to be inferred in this context as specified in <em>\u00a714.8.2.5/5 [temp.deduct.type]</em>:</p>\n<blockquote>\n<p id=\"so_30240131_30241944_2\">The non-deduced contexts are:</p>\n<p id=\"so_30240131_30241944_3\">[...]</p>\n<p id=\"so_30240131_30241944_4\">\u2014 A template parameter used in the parameter type of a function parameter that has a default argument\n  that is being used in the call for which argument deduction is being done.</p>\n</blockquote>\n", "LastEditorUserId": "2679626", "LastActivityDate": "2015-05-14T17:41:22.710", "Score": "9", "CreationDate": "2015-05-14T16:03:55.897", "ParentId": "30240131", "CommentCount": "0", "LastEditDate": "2015-05-14T17:41:22.710", "OwnerUserId": "2679626"}, "30240131": {"ViewCount": "908", "Body": "\n<p>I get an error with the latest versions of clang and gcc with this code:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>int main() {\n    auto lambda = [] (auto = [] {}) {};\n    lambda();\n}\n</code></pre>\n<p>Clang gives the error:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>prog.cc: In function 'int main()':\nprog.cc:3:12: error: no match for call to '(main()::&lt;lambda(auto:1)&gt;) ()'\n     lambda();\n            ^\nprog.cc:2:35: note: candidate: template&lt;class auto:1&gt; main()::&lt;lambda(auto:1)&gt;\n     auto lambda = [] (auto = [] {}) {};\n                                   ^\nprog.cc:2:35: note:   template argument deduction/substitution failed:\nprog.cc:3:12: note:   couldn't deduce template parameter 'auto:1'\n     lambda();\n            ^\n</code></pre>\n<p>Why does this fail?</p>\n", "AcceptedAnswerId": "30240214", "Title": "Lambda as default argument fails", "CreationDate": "2015-05-14T14:38:01.853", "Id": "30240131", "CommentCount": "3", "LastEditDate": "2015-05-14T14:44:02.363", "PostTypeId": "1", "LastEditorUserId": "493122", "LastActivityDate": "2015-05-14T17:41:22.710", "Score": "16", "OwnerUserId": "1594090", "Tags": "<c++><c++1z>", "AnswerCount": "3"}, "30240900": {"Id": "30240900", "PostTypeId": "2", "Body": "<p>Template functions (or methods) do not deduce their type parameters from their default arguments, and a closure with <code>auto</code> parameters is merely an object with a template method.</p>\n<p>This makes having a default lambda for a template function a bit annoying.</p>\n<p>One approach would be to type erase calling an object, without storing it, like so:</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;type_traits&gt;\n#include &lt;memory&gt;\n\ntemplate&lt;class Sig&gt;\nstruct function_view;\n\ntemplate&lt;class R, class...Args&gt;\nstruct function_view&lt;R(Args...)&gt;{\n  void* state;\n  R(*f)(void*, Args&amp;&amp;...);\n\n  template&lt;class F, class=std::enable_if_t&lt;std::is_convertible&lt;std::result_of_t&lt;F&amp;(Args...)&gt;,R&gt;{}&gt;&gt;\n  function_view( F&amp;&amp; fin ):\n    state(const_cast&lt;void*&gt;(static_cast&lt;void*&gt;(std::addressof(fin)))),\n    f( [](void* state, Args&amp;&amp;...args)-&gt;R{\n      F&amp;&amp; f = std::forward&lt;F&gt;(*static_cast&lt;std::decay_t&lt;F&gt;*&gt;(state));\n      return f(std::forward&lt;Args&gt;(args)...);\n    })\n  {}\n  function_view( R(*fin)(Args...) ):\n    state(fin),\n    f( fin?+[](void* state, Args&amp;&amp;...args)-&gt;R{\n      R(*f)(Args...) = static_cast&lt;R(*)(Args...)&gt;(state);\n      return f(std::forward&lt;Args&gt;(args)...);\n    }:nullptr)\n  {}\n  explicit operator bool(){return f;}\n  function_view():state(nullptr),f(nullptr){}\n  function_view(std::nullptr_t):function_view(){}\n  R operator()(Args...args)const{\n    return f(state, std::forward&lt;Args&gt;(args)...);\n  }\n};\ntemplate&lt;class...Args&gt;\nstruct function_view&lt;void(Args...)&gt;{\n  void* state;\n  void(*f)(void*, Args&amp;&amp;...);\n\n  template&lt;class F, class=std::result_of_t&lt;F&amp;(Args...)&gt;&gt;\n  function_view( F&amp;&amp; fin ):\n    state(const_cast&lt;void*&gt;(static_cast&lt;void*&gt;(std::addressof(fin)))),\n    f( [](void* state, Args&amp;&amp;...args){\n      F&amp;&amp; f = std::forward&lt;F&gt;(*static_cast&lt;std::decay_t&lt;F&gt;*&gt;(state));\n      f(std::forward&lt;Args&gt;(args)...);\n    })\n  {}\n  function_view( void(*fin)(Args...) ):\n    state(fin),\n    f( fin?+[](void* state, Args&amp;&amp;...args){\n      void(*f)(Args...) = static_cast&lt;void(*)(Args...)&gt;(state);\n      f(std::forward&lt;Args&gt;(args)...);\n    }:nullptr)\n  {}\n\n  explicit operator bool(){return f;}\n  function_view():state(nullptr),f(nullptr){}\n  function_view(std::nullptr_t):function_view(){}\n  void operator()(Args...args)const{\n    f(state, std::forward&lt;Args&gt;(args)...);\n  }\n};\n\nint main() {\n  auto f = [] (function_view&lt;void()&gt; x=[]{}) {\n    x();\n  };\n  f();\n}\n</code></pre>\n<p>As this just works with function pointers, and I have had good experience with gcc inlining simple function pointers, it might not have as high a performance impact as <code>std::function</code>.  And unlike <code>std::function</code> no virtual tables or heap allocation is involved.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c89fc769750f3904\" rel=\"nofollow\">live example</a></p>\n<p>For a non-lambda, you can do this:</p>\n<pre><code>template&lt;class X=function_view&lt;void()&gt;&gt;\nvoid f( X&amp;&amp; x=[]{} ) {\n  x();\n}\n</code></pre>\n<p>which deduces if you pass is an argument, and becomes a function-at-nothing if you don't.  You could also do:</p>\n<pre><code>struct do_nothing {\n  template&lt;class...Args&gt;\n  void operator()(Args&amp;&amp;...)const{}\n};\n\ntemplate&lt;class X=do_nothing&gt;\nvoid f( X&amp;&amp; x=do_nothing{} ) {\n  x();\n}\n</code></pre>\n<p>which might be easier to optimize.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-05-14T15:20:50.203", "Score": "2", "CreationDate": "2015-05-14T15:13:28.820", "ParentId": "30240131", "CommentCount": "3", "LastEditDate": "2015-05-14T15:20:50.203", "OwnerUserId": "1774667"}});