post_cb({"1097595": {"PostTypeId": "2", "ParentId": "1097479", "Body": "<p>Even though VS2008 was considered the most standard-compliant C++ compiler of it's time, here we have one instance where it's accepting invalid code. G++ doesn't compile this (d++: error: 'd' was not declared in this scope). That said, any program that relies this much on the intricacies of the C++ language is broken anyway :)</p>\n", "CreationDate": "2009-07-08T11:52:06.283", "Score": "3", "CommentCount": "0", "Id": "1097595", "OwnerUserId": "134841", "LastActivityDate": "2009-07-08T11:52:06.283"}, "bq_ids": {"n3337": {"so_1097479_1098357_1": {"quality": 0.6190476190476191, "length": 13, "section_id": 217}}}, "1109668": {"PostTypeId": "2", "ParentId": "1097479", "Body": "<p>VS should have complained about d++ as d should be looked up at point of definition.</p>\n<p>The article is incorrect, the calls should be resolved to f(char) as point of instantiation lookup should not be done for fundamental types (see tlib answer).</p>\n<p>g++ behaviour depends on the version:</p>\n<ul>\n<li><p>before 3.4, it does always point of instantiation lookup, which is a bug.</p></li>\n<li><p>starting with 3.4, it does point of definition lookup for d; but it does point of\ninstantiation lookup for fundamental types when they are a template parameter, which\nis a bug.</p></li>\n<li><p>starting with 4.1, it doesn't do point of instantiation lookup for basic types anymore.</p></li>\n</ul>\n", "CreationDate": "2009-07-10T13:53:28.727", "Score": "1", "LastEditDate": "2009-07-15T13:45:27.710", "CommentCount": "0", "Id": "1109668", "OwnerUserId": "136208", "LastEditorUserId": "136208", "LastActivityDate": "2009-07-15T13:45:27.710"}, "1097558": {"PostTypeId": "2", "ParentId": "1097479", "Body": "<p>The article is correct about whether <code>d++</code> should compile.</p>\n<p>Visual C++ does not do two-phase template instantiation - it does pretty much all its parsing at instatiation time.</p>\n<p>Gcc and <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"nofollow noreferrer\">Comeau</a> will give the correct error and will call the correct <code>f</code>.</p>\n", "CreationDate": "2009-07-08T11:45:47.280", "Score": "3", "LastEditDate": "2009-07-14T09:28:29.663", "CommentCount": "5", "Id": "1097558", "OwnerUserId": "11828", "LastEditorUserId": "11828", "LastActivityDate": "2009-07-14T09:28:29.663"}, "1097479": {"AcceptedAnswerId": "1098357", "Body": "<p>I was reading about the template name resolution <a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=387\" rel=\"nofollow noreferrer\">here</a>. Just to get the feel of the things I replicated the code like this:</p>\n<pre><code>void f (char c)\n{\n    std::cout&lt;&lt;\"f(char)\\n\";\n}\ntemplate &lt;class T&gt;\nvoid g(T t)\n{\n    f(1);\n    f(T(1));\n    f(t);\n\n    d++;\n}\ndouble d;\nvoid f(int n)\n{\n    std::cout&lt;&lt;\"f(int)\\n\";\n}\n\nvoid test()\n{\n    std::cout&lt;&lt;\"First call\\n\";\n    g(1);\n\n    std::cout&lt;&lt;\"Second call\\n\";\n    g('a');\n}\n\nint main()\n{\n    test();\n    return 0;\n}\n</code></pre>\n<p>According to the article linked I should have a compiler error for the d++ statement. Also for the first call of g(1), I should have  one call of f(char) followed by two calls of f(int) and for the second call I should get three calls of f(char). However, when I compiled this using Vs2008, it compiled fine without any errors. Also, the output was:</p>\n<blockquote>\n<p id=\"so_1097479_1097479_0\">First call</p>\n<p id=\"so_1097479_1097479_1\">f(int)</p>\n<p id=\"so_1097479_1097479_2\">f(int)</p>\n<p id=\"so_1097479_1097479_3\">f(int)</p>\n<p id=\"so_1097479_1097479_4\">Second call</p>\n<p id=\"so_1097479_1097479_5\">f(int)</p>\n<p id=\"so_1097479_1097479_6\">f(char)</p>\n<p id=\"so_1097479_1097479_7\">f(char)</p>\n</blockquote>\n<p>I am now wondering which one is correct? The article I am linking to or the VS2008 output? Any clue which is correct?</p>\n", "CreationDate": "2009-07-08T11:31:28.260", "Score": "1", "CommentCount": "1", "OwnerUserId": "39742", "Title": "Name resolution in templates", "LastActivityDate": "2009-07-15T13:45:27.710", "PostTypeId": "1", "Tags": "<c++><templates>", "AnswerCount": "4", "FavoriteCount": "1", "Id": "1097479", "ViewCount": "285"}, "1098357": {"PostTypeId": "2", "ParentId": "1097479", "Body": "<blockquote>\n<p id=\"so_1097479_1098357_0\">Also for the first call of g(1), I should have one call of f(char) followed by two calls of f(int) and for the second call I should get three calls of f(char).</p>\n</blockquote>\n<p>This is not the expected result with a Standard compliant compiler. Since both time you call it with a fundamental type, you will <em>not</em> get name lookup at the instantiation context for the function call. </p>\n<p>Name lookup at instantiation context only happens for argument dependent lookup (called <em>lookup using associated namespaces</em>). Both of <code>int</code> and <code>char</code> do not have argument dependent lookup, an thus <em>all</em> the function calls you do will call <code>f(char)</code> after you removed the <code>d++</code> line. </p>\n<hr>\n<p>Since i understand you won't possibly just believe me, here is the Standard quote, out of <code>14.6.4.2</code>:</p>\n<blockquote>\n<p id=\"so_1097479_1098357_1\">For a function call that depends on a template parameter, if the function name is an unqualified-id but not a template-id, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1), only function declarations with external linkage from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations with external linkage found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n</blockquote>\n<p>Note that the article uses a defective example of the Standard (at <code>14.6/9</code>) (and note that examples are non-normative: They can't change or state rules. Their purpose entirely is illustrative). The defect has been fixed and is incorporated into the upcoming Standard. See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#197\" rel=\"nofollow noreferrer\">this defect report</a>.</p>\n<hr>\n<p>As you see, you will have to change from <code>int</code> / <code>char</code> to some user defined type (enums or classes) too see the effect of lookup in instantiation context. Read this answer <a href=\"https://stackoverflow.com/questions/804217/function-template-declaration-order-affects-visibility-sometimes/804686#804686\">Order affects visibility</a> for more information. </p>\n</hr></hr>", "CreationDate": "2009-07-08T14:13:07.277", "Score": "3", "LastEditDate": "2017-05-23T12:19:35.893", "CommentCount": "5", "Id": "1098357", "OwnerUserId": "34509", "LastEditorUserId": "-1", "LastActivityDate": "2009-07-08T14:18:43.370"}});