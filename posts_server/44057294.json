post_cb({"bq_ids": {"n4140": {"so_44057294_44057312_1": {"length": 11, "quality": 1.0, "section_id": 5444}}, "n3337": {"so_44057294_44057312_1": {"length": 11, "quality": 1.0, "section_id": 5239}}, "n4659": {"so_44057294_44057312_0": {"length": 8, "quality": 0.5333333333333333, "section_id": 802}, "so_44057294_44057312_1": {"length": 11, "quality": 1.0, "section_id": 6871}}}, "44057364": {"Id": "44057364", "PostTypeId": "2", "Body": "<p>At first, you are right.  <strong>a struct is just a class</strong> under the hood.  </p>\n<p>Some indications:</p>\n<p>1-  You can forward declare one of them and then define it with the other one (although some compliers may issue a warning).  </p>\n<pre><code>class A;     // declaration of A with class\nstruct A { /* definition of A with struct */ } ;\n</code></pre>\n<p>2-  <code>is_class&lt;&gt;</code> returns true for both.<br>\n3-  There is no <code>is_struct&lt;&gt;</code> in <code>&lt;type_traits&gt;</code>.<br>\n4-  In most cases, the two keywords are interchangeable. (e.g: in scoped enum).  </br></br></p>\n<p>However, they have important syntactic differences:   </p>\n<p><code>struct</code> </p>\n<ul>\n<li>Grants public access to its members by default.</li>\n<li>Backward compatible with C if used without C++ features.</li>\n</ul>\n<p><code>class</code> </p>\n<ul>\n<li>Grants private access to its members by default.</li>\n<li>Not compatible with C.</li>\n</ul>\n<p>Which one to use is a matter of convention and/or convenience.  </p>\n<p>Generally, I prefer using <code>struct</code> as an aggregate of data (record). And <code>class</code> for other uses.  </p>\n<p>Now we come to your second question:  </p>\n<blockquote>\n<p id=\"so_44057294_44057364_0\">Why does the code show two different things?  </p>\n</blockquote>\n<p>It does not.  </p>\n<p>Because <code>is_class&lt;&gt;</code> is not about types but rather it is about <strong>type categories</strong>. (i.e. <code>is_class&lt;x&gt;</code> checks if the <strong>type x</strong> is a class or not) whereas <code>is_same&lt;&gt;</code> is about types themselves ((i.e. <code>is_same&lt;x, y&gt;</code> checks if <strong>type x</strong> is as same as <strong>type y</strong> or not))  </p>\n<p>If you change <code>struct</code> in your test code into <code>class</code>, <code>is_same&lt;&gt;</code> would still outputs \u201cNo\u201d  because <code>A</code> is a type and <code>B</code> is another type even if they both have the same type category which is <code>class</code>.  </p>\n<p>Based on your code:</p>\n<pre><code>A a;  // a is of type A\nB b; // b is of type B\n// Can we say that a and b of the same type?\n// No. And this is what is_same&lt;&gt; checks.\n</code></pre>\n", "LastEditorUserId": "6204556", "LastActivityDate": "2017-05-20T14:22:04.097", "Score": "9", "CreationDate": "2017-05-18T20:39:15.797", "ParentId": "44057294", "CommentCount": "2", "LastEditDate": "2017-05-20T14:22:04.097", "OwnerUserId": "6204556"}, "44057294": {"ViewCount": "154", "Body": "<p>I was trying to convince a friend that <code>struct</code> is just a <code>class</code> in the modern C++. After a lot of arguing and resource exchange (including some SO Q&amp;A), I came into an idea to prove it through code, so I wrote:</p>\n<pre><code>class A {};\nstruct B {};\n\nint main()\n{\n    cout &lt;&lt; (is_class&lt;A&gt;::value ? \"Yes\" : \"No\") &lt;&lt; \"\\n\";  // output Yes\n    cout &lt;&lt; (is_class&lt;B&gt;::value ? \"Yes\" : \"No\") &lt;&lt; \"\\n\";  // output Yes\n\n    cout &lt;&lt; (is_same&lt;A,B&gt;::value ? \"Yes\" : \"No\") &lt;&lt; \"\\n\"; // output No ???\n}\n</code></pre>\n<p>As you can see, I was surprised from the third <code>cout</code> line output. So, I am stuck here now, and I do not know if am I right or not.</p>\n<p>Is a <code>struct</code> a <code>class</code> or not?<br>\nWhy does the code show two different things?</br></p>\n<p>Update:</p>\n<p>I pretty understand what is the difference between struct and class. What confused me is the difference between the <code>is_class</code> and <code>is_same</code> as answers showed. What should I have done if not asking here???\nWhat is this site for? Why some users tend to claim questions are not useful without even put a comment to specify where it is not conforming with the asking policy?</p>\n<p>Remember, We not all people speaks English fluently. and not all people have years of the experience.</p>\n<p>Thanks for all who answer or comment.</p>\n", "AcceptedAnswerId": "44057364", "Title": "I know struct is a class but the code says No", "CreationDate": "2017-05-18T20:33:39.210", "Id": "44057294", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-18T21:45:27.337", "LastEditorUserId": "7972961", "LastActivityDate": "2017-05-20T14:22:04.097", "Score": "1", "OwnerUserId": "7972961", "Tags": "<c++><class><struct><types><typetraits>", "AnswerCount": "3"}, "44057772": {"Id": "44057772", "PostTypeId": "2", "Body": "<p>This has nothing to do with <code>struct</code> vs <code>class</code>.</p>\n<blockquote id=\"so_44057294_44057772_0\">\n<pre><code>cout &lt;&lt; (is_class&lt;A&gt;::value ? \"Yes\" : \"No\") &lt;&lt; \"\\n\";  // output Yes\n</code></pre>\n</blockquote>\n<p>Yes, because <code>A</code> is a class.</p>\n<blockquote id=\"so_44057294_44057772_1\">\n<pre><code>cout &lt;&lt; (is_class&lt;B&gt;::value ? \"Yes\" : \"No\") &lt;&lt; \"\\n\";  // output Yes\n</code></pre>\n</blockquote>\n<p>Yes, because <code>B</code> is also a class <em>(<a href=\"https://stackoverflow.com/a/36917400/560648\">it rea</a><a href=\"https://stackoverflow.com/a/34108140/560648\">lly is</a>)</em>.</p>\n<blockquote id=\"so_44057294_44057772_2\">\n<pre><code>cout &lt;&lt; (is_same&lt;A,B&gt;::value ? \"Yes\" : \"No\") &lt;&lt; \"\\n\"; // output No ???\n</code></pre>\n</blockquote>\n<p>No, because they're not <em>the same class</em>.</p>\n<p><code>A</code> and <code>B</code> are two different types.</p>\n<p>It's <code>std::is_same</code>, not <code>std::is_similar</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-18T21:14:46.060", "Score": "3", "CreationDate": "2017-05-18T21:06:57.840", "ParentId": "44057294", "CommentCount": "2", "LastEditDate": "2017-05-23T12:34:45.403", "OwnerUserId": "560648"}, "44057312": {"Id": "44057312", "PostTypeId": "2", "Body": "<p>You are confused as to what <code>std::is_same&lt;&gt;</code> is for.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/types/is_same\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/types/is_same</a>:</p>\n<blockquote>\n<p id=\"so_44057294_44057312_0\">If T and U name the same type with the same const-volatile\n  qualifications, provides the member constant value equal to true.\n  Otherwise value is false.</p>\n</blockquote>\n<p>Clearly <code>A</code> and <code>B</code> are different classes; with that last sentence I am implying that you are indeed correct in that a <code>struct</code> is the same as a <code>class</code>; the difference being that a <code>struct</code> has a default access of <code>public</code> for its members, whereas a <code>class</code> has a default of <code>private</code> instead.</p>\n<p>Don't take my word for it, the C++ standard states the following in 10.1.7.3 Elaborated type specifiers [dcl.type.elab]:</p>\n<blockquote>\n<p id=\"so_44057294_44057312_1\">[...] either the class or struct class-key shall be used to refer to a\n  class declared using the class or struct class-key.</p>\n</blockquote>\n<p>Reference: <a href=\"http://eel.is/c++draft/dcl.type.elab\" rel=\"nofollow noreferrer\">http://eel.is/c++draft/dcl.type.elab</a></p>\n", "LastEditorUserId": "2296177", "LastActivityDate": "2017-05-18T21:01:21.160", "Score": "7", "CreationDate": "2017-05-18T20:34:45.347", "ParentId": "44057294", "CommentCount": "0", "LastEditDate": "2017-05-18T21:01:21.160", "OwnerUserId": "2296177"}});