post_cb({"bq_ids": {"n4140": {"so_27214556_27214615_3": {"length": 4, "quality": 1.0, "section_id": 6018}, "so_27214556_27214615_0": {"length": 9, "quality": 1.0, "section_id": 6018}, "so_27214556_27214615_2": {"length": 26, "quality": 1.0, "section_id": 6018}, "so_27214556_27214615_1": {"length": 23, "quality": 1.0, "section_id": 6018}, "so_27214556_27214615_4": {"length": 17, "quality": 0.8947368421052632, "section_id": 6019}}, "n3337": {"so_27214556_27214615_3": {"length": 4, "quality": 1.0, "section_id": 5786}, "so_27214556_27214615_0": {"length": 9, "quality": 1.0, "section_id": 5786}, "so_27214556_27214615_2": {"length": 26, "quality": 1.0, "section_id": 5786}, "so_27214556_27214615_1": {"length": 23, "quality": 1.0, "section_id": 5786}, "so_27214556_27214615_4": {"length": 17, "quality": 0.8947368421052632, "section_id": 5787}}, "n4659": {"so_27214556_27214615_3": {"length": 4, "quality": 1.0, "section_id": 7517}, "so_27214556_27214615_0": {"length": 9, "quality": 1.0, "section_id": 7517}, "so_27214556_27214615_2": {"length": 26, "quality": 1.0, "section_id": 7517}, "so_27214556_27214615_1": {"length": 23, "quality": 1.0, "section_id": 7517}, "so_27214556_27214615_4": {"length": 17, "quality": 0.8947368421052632, "section_id": 7518}}}, "27214615": {"Id": "27214615", "PostTypeId": "2", "Body": "<p>The semantics of <code>dynamic_cast</code> are described in \u00a75.2.7/8:</p>\n<blockquote>\n<p id=\"so_27214556_27214615_0\">If <code>C</code> is the class type to which <code>T</code> points or refers, the run-time\n  check logically executes as follows:</p>\n<p id=\"so_27214556_27214615_1\">\u2014 If, in the most derived object\n  pointed (referred) to by <code>v</code>, <code>v</code> points (refers) to a public base\n  class subobject of a <code>C</code> object, and if only one object of type <code>C</code> is\n  derived from the subobject pointed (referred) to by <code>v</code> the result\n  points (refers) to that <code>C</code> object.</p>\n<p id=\"so_27214556_27214615_2\">\u2014 Otherwise, if <code>v</code> points (refers) to a public base class subobject\n  of the most derived object, and the type of the most derived object\n  has a base class, of type <code>C</code>, that is unambiguous and public, the\n  result points (refers) to the <code>C</code> subobject of the most derived\n  object.</p>\n<p id=\"so_27214556_27214615_3\">\u2014 Otherwise, the run-time check <em>fails</em>.</p>\n</blockquote>\n<p>And paragraph 9:</p>\n<blockquote>\n<p id=\"so_27214556_27214615_4\">The value of a failed cast to pointer type is the <strong>null pointer\n  value</strong> of the required result type. A failed cast to reference type\n  throws <code>std::bad_cast</code> (18.7.2).</p>\n</blockquote>\n<p><sup>Note: you should probably include <code>&lt;typeinfo&gt;</code> for <code>std::badcast</code>.</sup></p>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-11-30T15:02:47.087", "Score": "5", "CreationDate": "2014-11-30T15:02:47.087", "ParentId": "27214556", "CommentCount": "0"}, "27214669": {"Id": "27214669", "PostTypeId": "2", "Body": "<p>bad_cast will occur only when you are casting reference:\nTry something like this:</p>\n<pre><code>Triangle prim;\nGeometricPrimitive gp;\ntry {\n    gp = dynamic_cast&lt;const GeometricPrimitive &amp;&gt;(*(primitives[edges[axis][j].primNum].GetPtr()));\n\n    prim = dynamic_cast&lt;const Triangle &amp;&gt;(*((gp-&gt;shape).GetPtr()));\n\n}\ncatch (std::bad_cast&amp; bc) {\n    continue;\n}\n</code></pre>\n", "LastActivityDate": "2014-11-30T15:07:58.500", "CommentCount": "0", "CreationDate": "2014-11-30T15:07:58.500", "ParentId": "27214556", "Score": "4", "OwnerUserId": "1149513"}, "27214556": {"ViewCount": "278", "Body": "<p>How is it possible that I pass the try succesfully with a non <code>const Triangle</code> pointer?</p>\n<pre><code>const Triangle *prim;\nconst GeometricPrimitive *gp;\ntry {\n    gp = dynamic_cast&lt;const GeometricPrimitive*&gt;(primitives[edges[axis][j].primNum].GetPtr());\n    prim = dynamic_cast&lt;const Triangle*&gt;((gp-&gt;shape).GetPtr());\n}\ncatch (std::bad_cast&amp; bc) {\n    continue;\n}\n</code></pre>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/qv87H.jpg\"/></p>\n<pre><code>template &lt;typename T&gt; class Reference {\npublic:\n    ...\n    T *operator-&gt;() { return ptr; }\n    const T *operator-&gt;() const { return ptr; }\n    operator bool() const { return ptr != NULL; }\n    const T *GetPtr() const { return ptr; }\nprivate:\n    T *ptr;\n};\n</code></pre>\n<p>Edit:\n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/gd0au.jpg\"/></p>\n", "AcceptedAnswerId": "27214615", "Title": "Bad cast not caught after dynamic casting", "CreationDate": "2014-11-30T14:55:06.170", "Id": "27214556", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-11-30T15:07:58.500", "Score": "4", "OwnerUserId": "1731200", "Tags": "<c++>", "AnswerCount": "2"}});