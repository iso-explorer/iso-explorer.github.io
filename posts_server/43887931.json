post_cb({"43888263": {"Id": "43888263", "PostTypeId": "2", "Body": "<p>It's a questionable design, but correct from a pure language standpoint. The C++ standard has this to say:</p>\n<p><a href=\"http://eel.is/c++draft/basic.life\" rel=\"nofollow noreferrer\">[basic.life]</a></p>\n<blockquote>\n<p id=\"so_43887931_43888263_0\">1 The lifetime of an object or reference is a runtime property of the\n  object or reference. An object is said to have non-vacuous\n  initialization if it is of a class or aggregate type and it or one of\n  its subobjects is initialized by a constructor other than a trivial\n  default constructor. The lifetime of an object of type T begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object has non-vacuous initialization, its initialization is complete,</li>\n</ul>\n<p id=\"so_43887931_43888263_1\">...</p>\n<p id=\"so_43887931_43888263_2\">7 before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated or, after the lifetime\n  of an object has ended and before the storage which the object\n  occupied is reused or released, any glvalue that refers to the\n  original object may be used but only in limited ways... such a glvalue\n  refers to allocated storage, and using the properties of the glvalue\n  that do not depend on its value is well-defined. The program has\n  undefined behavior if:</p>\n<ul>\n<li>the glvalue is used to access the object, or</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>Paragraph 7 explicitly specifies that using such a reference to assign into an object whose lifetime hasn't started yet is UB.</p>\n<p>But according to paragraph 1, the lifetime of the pointer starts right when storage is allocated for it, since it is a type with vacuous initialization. So in essence, your code isn't under the threat of paragraph 7.</p>\n<hr>\n<p>If you don't want to specify the template parameter when calling <code>newObject</code> (which isn't so bad or verbose if you use C++11 <code>auto p = newObject&lt;Dervied1&gt;()</code>), and you have access to C++11 at the very least, you can use a common template related trick to deffer the construction until the type is known. The meat of it:</p>\n<pre><code>namespace detail {\n// ...\ntemplate&lt;typename... Args&gt;\nstruct DefferedConstruct {\n    std::tuple&lt;Args&amp;...&gt; args_tuple;\n\n    template&lt;typename T&gt;\n    operator T*() {\n        return new T(make_from_tuple&lt;T&gt;(\n            args_tuple\n        ));\n    }\n};\n} // namespace detail\n\ntemplate&lt;typename... Args&gt;\nauto newObject(Args&amp;&amp;... args) -&gt; detail::DefferedConstruct&lt;Args...&gt; {\n    return detail::DefferedConstruct&lt;Args...&gt;{\n        std::forward_as_tuple(args...)\n    };\n}\n\nclass Base\n{\n  public:\n    virtual ~Base(void){}\n};\n\nclass Derived1 : public Base\n{\n  public:\n    Derived1(int) {}\n    virtual ~Derived1(void){}\n};\n\nclass Derived2 : public Base\n{\n  public:\n    virtual ~Derived2(void){}\n};\n\nint main()\n{\n// compiler construct the right object according to the return type\n    Derived1 *p1 = newObject(1);\n    Derived2 *p2 = newObject();\n\n    delete p1;\n    delete p2;\n}\n</code></pre>\n<p><kbd><a href=\"http://ideone.com/ilP0gq\" rel=\"nofollow noreferrer\">Live Example</a></kbd></p>\n<p>The code above just uses a lot of C++ magic to lug the constructor parameters around until the class to construct is known at function exit.</p>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2017-05-10T10:32:00.323", "Score": "4", "CreationDate": "2017-05-10T09:17:31.417", "ParentId": "43887931", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2017-05-10T10:32:00.323"}, "43888377": {"Id": "43888377", "PostTypeId": "2", "Body": "<p>I think the code you've written is safe.</p>\n<p>To create a factory of derived types, since you <em>can't</em> overload on return type,\nwhy not just have differently named methods? The caller already has to know what type it wants in order to declare the variable, so requiring them to also know what factory method to call doesn't seem too onerous. E.g.:</p>\n<pre><code>Derived1 * newDerived1() {\n    return new Derived1();\n}\n\nDerived2 * newDerived2() {\n    return new Derived2();\n}\n</code></pre>\n<p>If you <em>must</em> have factory methods named the same, you could use a template:</p>\n<pre><code>template&lt;\n    typename T,\n    typename = std::enable_if_t&lt;std::is_base_of&lt;Base, T&gt;::value&gt;\n&gt;\nT* newObject() {\n    return new T();\n}\n\nDerived1* d = newObject&lt;Derived1&gt;();\n</code></pre>\n<p>If the set-up code required before calling the constructor differs for each derived class, or if each derived class's constructor takes different arguments, you can use template specialisation to cover this.</p>\n<p>Note, however, that you still need to provide the type you're creating as a template parameter when calling the factory. There's no way round this as far as I'm aware.</p>\n", "LastEditorUserId": "7099148", "LastActivityDate": "2017-05-10T09:27:53.527", "Score": "2", "CreationDate": "2017-05-10T09:22:17.230", "ParentId": "43887931", "CommentCount": "1", "OwnerUserId": "7099148", "LastEditDate": "2017-05-10T09:27:53.527"}, "bq_ids": {"n4140": {"so_43887931_43888263_0": {"length": 25, "quality": 0.78125, "section_id": 7189}, "so_43887931_43888263_2": {"length": 44, "quality": 0.9777777777777777, "section_id": 7194}}, "n3337": {"so_43887931_43888263_0": {"length": 25, "quality": 0.78125, "section_id": 6933}, "so_43887931_43888263_2": {"length": 44, "quality": 0.9777777777777777, "section_id": 6938}}, "n4659": {"so_43887931_43888263_0": {"length": 28, "quality": 0.875, "section_id": 8697}, "so_43887931_43888263_2": {"length": 44, "quality": 0.9777777777777777, "section_id": 8703}}}, "43887931": {"ViewCount": "73", "Body": "<p>I have a polymorphic hierarchy of classes. While I also support the standard factory approach, where I use only base class pointers, I also want a factory mechanism which gives me derived classes, which is not easy because these functions only differ in their return types. This is why I came up with the idea to overload a function and let the compiler pick the right one.</p>\n<p>A simple application of this is that I can write functions which create a derived object, \"prepare\" it and return a base pointer to it for further access, when the type information is not needed anymore.</p>\n<ul>\n<li>Question 1: Is the following ok? </li>\n<li>Question 2: The parameter of newObject() is only for the compiler to pick the right function. I am concerned about using <code>p1</code> on the same line where it is declared. I never read its value before setting it in <code>newObject()</code>, but I am not sure if it can cause undefined behavior. Also I have a self-assignment because the returned value is assigned to itself...</li>\n</ul>\n<p>This is the code example:</p>\n<pre><code>class Base\n{\n  public:\n    virtual ~Base(void){}\n};\n\nclass Derived1 : public Base\n{\n  public:\n    virtual ~Derived1(void){}\n};\n\nclass Derived2 : public Base\n{\n  public:\n    virtual ~Derived2(void){}\n};\n\n// factory\n\nBase * newObject(int i)\n{\n    if (i == 1)\n    {\n        return new Derived1();\n    }\n    else\n    {\n        return new Derived2();\n    }\n}\n\n// family of functions to create all derived classes of Base\n\nDerived1 * newObject(Derived1 *&amp; p)\n{\n    p = new Derived1();\n    return p;\n}\n\nDerived2 * newObject(Derived2 *&amp; p)\n{\n    p = new Derived2();\n    return p;\n}\n\nint main()\n{\n    // compiler picks the right newObject function according to the parameter type\n    Derived1 * p1 = newObject(p1);\n    Derived2 * p2 = newObject(p2);\n\n    // This is safe, right? But it does not convey that it creates something. Hence I prefer the above syntax.\n    Derived2 * p3 = nullptr;\n    newObject(p3);\n\n    delete p3;\n    delete p2;\n    delete p1;\n}\n</code></pre>\n<p><strong>EDIT:</strong></p>\n<p>To circumvent the problem of using a variable which was just created, this is an alternative:</p>\n<pre><code>Derived1 * newObject(Derived1 *)\n{\n    // anonymous variable is not used at all, just to pick the right function\n    Derived1 * p = new Derived1();\n    return p;\n}\n</code></pre>\n", "AcceptedAnswerId": "43888263", "Title": "Can I use a variable on the same line it is declared in this factory in C++?", "CreationDate": "2017-05-10T09:02:10.430", "Id": "43887931", "CommentCount": "4", "LastEditDate": "2017-05-10T09:41:45.427", "PostTypeId": "1", "LastEditorUserId": "4675398", "LastActivityDate": "2017-05-10T10:32:00.323", "Score": "2", "OwnerUserId": "4675398", "Tags": "<c++><factory>", "AnswerCount": "2"}});