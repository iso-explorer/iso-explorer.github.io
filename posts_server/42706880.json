post_cb({"bq_ids": {"n4140": {"so_42706880_42707066_0": {"length": 11, "quality": 1.0, "section_id": 175}}, "n3337": {"so_42706880_42707066_0": {"length": 11, "quality": 1.0, "section_id": 169}}, "n4659": {"so_42706880_42707066_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 180}}}, "42706880": {"ViewCount": "228", "Body": "<p>I have this code:</p>\n<pre><code>struct Base {};\n\ntemplate&lt;typename T&gt;\nstruct Foo : Base {};\n\nstruct Bar {\n    template&lt;typename T&gt; //           v--- What's happening here?\n    Bar(T foo) : baz{std::make_unique&lt;Foo&gt;(foo)} {}\n\n    std::unique_ptr&lt;Base&gt; baz;\n};\n</code></pre>\n<p>As a surprise, GCC and Clang accept and compiles it. It seem to deduce the template parameter of <code>Foo</code>, but it wouldn't make sense. How come the compilers accept that even if there is no overload of <code>std::make_unique</code> that takes a template template parameter? <kbd><a href=\"http://coliru.stacked-crooked.com/a/55d427db6e75707e\" rel=\"noreferrer\">Live example</a></kbd></p>\n", "AcceptedAnswerId": "42707066", "Title": "Why don't I need template parameters in this particular case?", "CreationDate": "2017-03-09T22:39:00.587", "Id": "42706880", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-03-09T22:59:36.740", "Score": "9", "OwnerUserId": "2104697", "Tags": "<c++><templates><c++14>", "AnswerCount": "2"}, "42707129": {"Id": "42707129", "PostTypeId": "2", "Body": "<p>The reason this works is because C++ doesn't actually create template functions until they're called from somewhere in the code.  In this instance, since your code doesn't ever try to create a <code>Bar</code>, your template one-arg <code>Bar</code> constructor is never generated, so the compiler never needs to check if the code is correct.</p>\n<p>Template functions are generated by the compiler as soon as they're used, and they're generated only based on the types passed into them.  So, if you try to create a <code>Bar</code> like so:</p>\n<pre><code>Foo&lt;int&gt; f;\nBar b = Bar(f);\n</code></pre>\n<p>The compiler will try to generate the constructor and fail with an error like: </p>\n<pre><code>error C2955: 'Foo' : use of class template requires template argument list\n</code></pre>\n<p>Because it now knows the code is wrong.</p>\n<p>If you think about it, this is how it has to work: since C++ doesn't allow you to put constraints on template types, the compiler would have to try every possible combination of template types to figure out if a template function has syntax errors.</p>\n", "LastActivityDate": "2017-03-09T22:59:36.740", "CommentCount": "4", "CreationDate": "2017-03-09T22:59:36.740", "ParentId": "42706880", "Score": "4", "OwnerUserId": "7663809"}, "42707066": {"Id": "42707066", "PostTypeId": "2", "Body": "<p>There are some situations where a template is always invalid, no matter what template arguments are supplied, but the compiler isn't able to figure that out, because it doesn't have the ability to try substituting every possible set of template arguments. According to the standard ([temp.res]/8):</p>\n<blockquote>\n<p id=\"so_42706880_42707066_0\">If no valid specialization can\n  be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic\n  required.</p>\n</blockquote>\n<p>That means that the compiler is allowed to be smart and <em>prove</em> that there is no valid specialization, and produce a compilation error, but it's also allowed to not be smart enough, and not produce a compilation error. Of course, once the template is instantiated, then the compiler must diagnose the error.</p>\n<p>It's not illegal to use the name of a template without template arguments. There are some circumstances where the compiler can deduce arguments. For example:</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(T x);\n\nint main() {\n    void (*p)(int) = foo;  // p points to foo&lt;int&gt;\n}\n</code></pre>\n<p>In your code, it turns out that you've used <code>Foo</code> in a context where the template arguments can't be deduced. If the compilers were smarter, they would have figured that out. But the fact that they didn't manage to figure it out does not mean your code is correct.</p>\n", "LastActivityDate": "2017-03-09T22:54:29.103", "CommentCount": "1", "CreationDate": "2017-03-09T22:54:29.103", "ParentId": "42706880", "Score": "8", "OwnerUserId": "481267"}});