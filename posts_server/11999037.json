post_cb({"11999037": {"CommentCount": "0", "AcceptedAnswerId": "11999097", "PostTypeId": "1", "LastEditorUserId": "1567318", "CreationDate": "2012-08-17T02:27:39.210", "LastActivityDate": "2012-08-17T03:13:10.710", "LastEditDate": "2012-08-17T03:13:10.710", "ViewCount": "472", "FavoriteCount": "1", "Title": "Is int&& valid in a template instantiation?", "Id": "11999037", "Score": "3", "Body": "<p>Consider the code below. What is going on there?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nvoid test(T &amp;t)  // but why  int&amp;&amp; is valid here,when  instantiated with test&lt;int&amp;&gt;??\n{\n  puts(\"T&amp;\");\n}\n\nint tref(int&amp;&amp; param)    //compile  error\n{\n  puts(\"tref&amp;\");\n}\n\nint main()\n{\n  int i;\n  test&lt;int&amp;&gt;(i);\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "1567318", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11999037_11999097_1": {"section_id": 3223, "quality": 0.7857142857142857, "length": 22}, "so_11999037_11999097_0": {"section_id": 3222, "quality": 1.0, "length": 7}}, "n3337": {"so_11999037_11999097_1": {"section_id": 3097, "quality": 0.8928571428571429, "length": 25}, "so_11999037_11999097_0": {"section_id": 3096, "quality": 1.0, "length": 7}}, "n4659": {"so_11999037_11999097_1": {"section_id": 3980, "quality": 0.7857142857142857, "length": 22}, "so_11999037_11999097_0": {"section_id": 3979, "quality": 1.0, "length": 7}}}, "11999097": {"ParentId": "11999037", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I am not sure I follow, if you mean <code>int&amp;&amp;</code>in the first one because <code>T</code> is <code>int&amp;</code> you are wrong. When <code>T</code> is <code>int&amp;</code>, the <code>T&amp;</code> in the signature is still <code>int&amp;</code>. Also, <code>int&amp;&amp;</code> has <em>nothing</em> to do with composing <code>int&amp;</code> with an extra <code>&amp;</code>. <code>&amp;&amp;</code> has a specific meaning: <em>rvalue-reference</em>.</p>\n<p>\u00a78.3.2[dcl.ref]/5</p>\n<blockquote>\n<p id=\"so_11999037_11999097_0\">There shall be no references to references, no arrays of references, and no pointers to references. [...]</p>\n</blockquote>\n<p>\u00a78.3.2[dcl.ref]/6</p>\n<blockquote>\n<p id=\"so_11999037_11999097_1\">If a typedef (7.1.3), a type template-parameter (14.3.1), or a decltype-specifier (7.1.6.2) denotes a type TR that is a reference to a type T, an attempt to create the type \u201clvalue reference to cv TR\u201d creates the type \u201clvalue reference to T\u201d, while an attempt to create the type \u201crvalue reference to cv TR\u201d creates the type TR.</p>\n</blockquote>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2012-08-17T02:51:06.233", "Id": "11999097", "Score": "7", "CreationDate": "2012-08-17T02:39:05.100", "LastActivityDate": "2012-08-17T02:51:06.233"}});