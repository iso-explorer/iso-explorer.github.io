post_cb({"39971738": {"ParentId": "39971659", "CommentCount": "0", "Body": "<p><strong>Copy initialization</strong>, the <code>=</code> syntax as in <code>Server server = Server{port};</code>, requires that a copy constructor or a move constructor exists and is accessible.</p>\n<p>Since your copy constructor doesn't exist, try to provide a move constructor.</p>\n<p>If you can't, then your only recourse is to use <strong>direct initialization</strong> syntax, e.g. <code>Server server{port};</code></p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "39971738", "Score": "2", "CreationDate": "2016-10-11T06:46:02.303", "LastActivityDate": "2016-10-11T06:46:02.303"}, "39971659": {"CommentCount": "2", "CreationDate": "2016-10-11T06:38:25.287", "PostTypeId": "1", "AcceptedAnswerId": "39971691", "LastEditorUserId": "3309790", "LastActivityDate": "2016-10-11T07:43:17.027", "LastEditDate": "2016-10-11T07:23:28.643", "ViewCount": "75", "FavoriteCount": "1", "Title": "Why is the copy constructor called when I am not passing an instance of the class?", "Id": "39971659", "Score": "0", "Body": "<p>I have a class Server which has a constructor:</p>\n<pre><code>Server::Server(int port) {\n    // initialize some class variables\n    port_ = port;\n    //...\n}\n</code></pre>\n<p>I try to create an instance of the class like so:</p>\n<pre><code>int main(int argc, char** argv) {\n    int port = 3000;\n    Server server = Server(port);\n}\n</code></pre>\n<p>And I get this compile error:</p>\n<pre><code>server_main.cpp:32:32: error: use of deleted function \u2018Server::Server(const Server&amp;)\u2019\n     Server server = Server(port);\n                                ^\n</code></pre>\n<p>Now, I understand why the copy constructor was implicitly deleted, but why is it being called?</p>\n<p>The error goes away if I add a copy constructor to the class. Is there any other way to avoid this?</p>\n", "Tags": "<c++><constructor><initialization>", "OwnerUserId": "3465177", "AnswerCount": "4"}, "39971950": {"ParentId": "39971659", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the very annoyingly pedantic point of view, many of the currently provided answers (if not all of them) are slightly misleading. </p>\n<p>In C++ copy-initialization with the same type on the left-hand side and right-hand side is treated in a special way: it is immediately interpreted as an equivalent direct-initialization. </p>\n<p>From [dcl.init]/16:</p>\n<blockquote>\n<p id=\"so_39971659_39971950_0\">\u2014 If the destination type is a (possibly cv-qualified) class type: </p>\n<p id=\"so_39971659_39971950_1\">\u2014 If the initialization is direct-initialization, <strong>or if it is\n  copy-initialization where the cv-unqualified version of the source\n  type is the same class as, or a derived class of, the class of the\n  destination</strong>, constructors are considered...</p>\n</blockquote>\n<p>This means that your copy-initialization</p>\n<pre><code>Server server = Server(port);\n</code></pre>\n<p>is actually handled as direct-initialization</p>\n<pre><code>Server server(Server(port));\n</code></pre>\n<p>and is further processed in accordance with the rules of direct-initialization.</p>\n<p>Rules of direct-initialization say that overload resolution is used to choose a constructor and the constructor chosen in this case is the copy-constructor (which is deleted in your case, hence the error).</p>\n<p>So, the end result is the same - the copy constructor is required. But \"branches\" of the standard logic that make it required are not the ones responsible for copy-initialization, but rather the ones responsible for direct-initialization.</p>\n<p>In this case the difference is purely conceptual. But back in the days of C++98 this obscure distinction payed important role in the functionality of [now forgotten] <code>std::auto_ptr</code> pointer (re: <code>auto_ptr_ref</code> and how it worked). This is actually often seen as an early idiomatic implementation of Move Constructor pattern (<a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Move_Constructor\" rel=\"nofollow\">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Move_Constructor</a>).</p>\n<hr>\n<p>A simple example that illustrates that special handling might look as follows</p>\n<pre><code>struct A\n{\n    A() {}\n    A(A&amp;) {}\n    A(int) {}\n    operator int() const { return 42; }\n};\n\nstruct B\n{\n    B();\n    operator int() const { return 42; }\n};\n\nint main()\n{\n    A a1 = A(); // OK\n    A a2 = B(); // Error\n}\n</code></pre>\n<p>Note that even though both classes on the right-hand side provide a user-defined conversion to <code>int</code>, only the first initialization compiles and uses <code>A::A(int)</code> constructor. The second one fails.</p>\n<p>The second initialization proceeds in accordance with usual copy-initialization rules. And in order to succeed it needs <em>two</em> user-defined conversions (<code>B -&gt; int</code> and <code>int -&gt; A</code>), which cannot be done implicitly.</p>\n<p>The first initialization is treated in accordance with direct-initialization rules, thus effectively making the <code>int -&gt; A</code> conversion explicit. This initialization now needs only <em>one</em> implicit user-defined conversion (<code>A -&gt; int</code>), which is fine.</p>\n</hr>", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2016-10-11T07:34:31.790", "Id": "39971950", "Score": "3", "CreationDate": "2016-10-11T07:01:39.293", "LastActivityDate": "2016-10-11T07:34:31.790"}, "39971684": {"ParentId": "39971659", "CommentCount": "9", "Body": "<p>Because you copy-initialize the <code>server</code> object.</p>\n<p>The definition</p>\n<pre><code>Server server = Server(port);\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>Server server(Server(port));\n</code></pre>\n<p>You might want to use the constructor explicitly by doing</p>\n<pre><code>Server server(port);\n</code></pre>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "39971684", "Score": "2", "CreationDate": "2016-10-11T06:40:59.130", "LastActivityDate": "2016-10-11T06:40:59.130"}, "39971691": {"ParentId": "39971659", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>Server server = Server(port);</code> is <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow\">copy initialization</a>; You're initializing <code>server</code> from a temporary <code>Server</code>.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow\">copy elision</a> might take place, but not guaranteed until C++17. Even copy-/move-constructor might not be called, but still must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed.</p>\n<p>You could change it to <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow\">direct initialization</a>, which will invoke <code>Server::Server(int)</code> directly:</p>\n<pre><code>Server server(port);\n</code></pre>\n<p>Or <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow\">direct list initialization</a> (Since C++11):</p>\n<pre><code>Server server{port};\n</code></pre>\n<p><strong>EDIT</strong></p>\n<p>Since C++17, <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow\">copy elision</a> is guaranteed for this case.</p>\n<blockquote>\n<p id=\"so_39971659_39971691_0\">Under the following circumstances, the compilers are required to omit\n  the copy- and move- constructors of class objects even if copy/move\n  constructor and the destructor have observable side-effects:</p>\n<ul>\n<li><p id=\"so_39971659_39971691_1\">In initialization, if the initializer expression is a prvalue and the\n  cv-unqualified version of the source type is the same class as the\n  class of the destination, the initializer expression is used to\n  initialize the destination object:</p>\n<p id=\"so_39971659_39971691_2\"><code>T x = T(T(T())); // only one call to default constructor of T, to initialize x</code></p></li>\n</ul>\n</blockquote>\n<p>So your code will work well with C++17; For copy elision being guaranteed, copy/move constructor is not required to be accessible.</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/5vdcGCLcYVziqXXW\" rel=\"nofollow\">LIVE DEMO from GCC</a></p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-10-11T07:43:17.027", "Id": "39971691", "Score": "4", "CreationDate": "2016-10-11T06:41:33.877", "LastActivityDate": "2016-10-11T07:43:17.027"}, "bq_ids": {"n4140": {"so_39971659_39971691_1": {"section_id": 3296, "quality": 0.8235294117647058, "length": 14}, "so_39971659_39971691_2": {"section_id": 7043, "quality": 0.6666666666666666, "length": 4}, "so_39971659_39971950_1": {"section_id": 3296, "quality": 1.0, "length": 15}, "so_39971659_39971950_0": {"section_id": 3296, "quality": 1.0, "length": 6}}, "n3337": {"so_39971659_39971691_2": {"section_id": 6788, "quality": 0.6666666666666666, "length": 4}, "so_39971659_39971691_1": {"section_id": 3166, "quality": 0.8235294117647058, "length": 14}, "so_39971659_39971950_1": {"section_id": 3166, "quality": 1.0, "length": 15}, "so_39971659_39971950_0": {"section_id": 3166, "quality": 1.0, "length": 6}}, "n4659": {"so_39971659_39971691_2": {"section_id": 4058, "quality": 0.6666666666666666, "length": 4}, "so_39971659_39971691_1": {"section_id": 4058, "quality": 0.9411764705882353, "length": 16}, "so_39971659_39971950_1": {"section_id": 4058, "quality": 1.0, "length": 15}, "so_39971659_39971950_0": {"section_id": 4058, "quality": 1.0, "length": 6}}}});