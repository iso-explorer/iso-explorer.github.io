post_cb({"21937122": {"ParentId": "21936455", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Using a specialization which is <strong>not visible at the POC - point of call - is an error</strong>.</p>\n<p>By the way compilers are not required to treat this as an error and can handle it as they like.</p>\n<p>You should have the specialization into the header file but in C++11 you can do it into an external unit <a href=\"http://en.cppreference.com/w/cpp/language/class_template\" rel=\"nofollow\">with the C++11 \"extern\" keyword for explicit instantiation declaration</a></p>\n<p>As noted by Sebastian: it's a violation of the requirement in <code>14.7.3/6</code>: </p>\n<blockquote>\n<p id=\"so_21936455_21937122_0\">\"If a template [...] is explicitly specialized then that\n  specialization shall be declared before the first use of that\n  specialization that would cause an implicit instantiation to take\n  place, in every translation unit in which such a use occurs; no\n  diagnostic is required.\"</p>\n</blockquote>\n<p>Since no diagnostic is required, <strong>violating this requirement is undefined behavior</strong>.</p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "1938163", "LastEditDate": "2014-02-21T23:36:38.073", "Id": "21937122", "Score": "2", "CreationDate": "2014-02-21T14:28:06.110", "LastActivityDate": "2014-02-21T23:36:38.073"}, "21937013": {"ParentId": "21936455", "CommentCount": "0", "Body": "<p>Like any function, the specialisation must be declared before use, in every translation unit that uses it. Otherwise, the compiler doesn't know that it exists, and will use the generic template (instantiating it if necessary).</p>\n<p>This might mean that you end up with two non-identical copies of the specialisation (the one you wrote, and the one instantiated from the template); depending on exactly what the linker does, this might result in one or the other being called, or a link error, or some other undefined behaviour.</p>\n<p>Note that you don't need to move the definition of the specialisation into the header; it's enough to declare it.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "21937013", "Score": "2", "CreationDate": "2014-02-21T14:22:28.517", "LastActivityDate": "2014-02-21T14:22:28.517"}, "21936455": {"CommentCount": "3", "AcceptedAnswerId": "21937122", "CreationDate": "2014-02-21T13:57:21.143", "LastActivityDate": "2014-02-21T23:36:38.073", "PostTypeId": "1", "ViewCount": "171", "FavoriteCount": "1", "Title": "C++ compiler optimizations discard template specializations", "Id": "21936455", "Score": "3", "Body": "<p>I noticed that template specializations in .cpp files are discarded if compiler optimizations are enabled. I found this in a big application and I boiled down the problem to a simple example.</p>\n<p>First, I define a new class in obj.h  </p>\n<pre><code>#ifndef _OBJ_H_\n#define _OBJ_H_\n\nclass Obj { };\n\n#endif //_OBJ_H_\n</code></pre>\n<p>Then I define a new template function in templates.h</p>\n<pre><code>#ifndef _TEMPLATES_H_\n#define _TEMPLATES_H_\n\ntemplate&lt;typename T&gt;\nint get()\n{\n    return 0;\n}\n\n#endif //_TEMPLATES_H_\n</code></pre>\n<p>...and a specialization for the class Obj in templates.cpp</p>\n<pre><code>#include \"templates.h\"\n#include \"obj.h\"\n\ntemplate&lt;&gt;\nint get&lt;Obj&gt;()\n{\n    return 1;\n}\n</code></pre>\n<p>Then I call the function from main:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include \"templates.h\"\n#include \"obj.h\"\n\nint main()\n{\n    printf(\"Get: %d\\n\", get&lt;Obj&gt;());\n    return 0;\n}\n</code></pre>\n<p>Compiling this example with different <code>-O</code> levels yields different outputs.  </p>\n<pre><code>$ g++ -o a main.cpp templates.cpp -O0\n$ ./a\nGet: 1\n\n$ g++ -o a main.cpp templates.cpp -O2 #same with -O3, -O4, Os\n$ ./a\nGet: 0\n</code></pre>\n<p>The same happens replacing g++ with clang. I'm using g++ 4.7.2 and clang 3.4.<br>\nI'm no assembly expert, but looking at the generated code I can see that the <code>-O0</code> version defines the mangled symbol <code>_Z3getI3ObjEiv</code>, which refers to the specialization, while the optimized versions just inline everything (as I expected).<br>\nThe problem was eventually solved moving all the specializations to the header files, but still I'm curious: why this happens? Initially I thought that I hit an undefined behaviour, although it's strange that both clang and g++ produce the same results if it's the case.</br></br></p>\n", "Tags": "<c++><templates><template-specialization>", "OwnerUserId": "3337330", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_21936455_21937122_0": {"section_id": 268, "quality": 1.0, "length": 24}}, "n3337": {"so_21936455_21937122_0": {"section_id": 259, "quality": 1.0, "length": 24}}, "n4659": {"so_21936455_21937122_0": {"section_id": 275, "quality": 1.0, "length": 24}}}});