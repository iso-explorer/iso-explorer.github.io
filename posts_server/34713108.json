post_cb({"bq_ids": {"n4140": {"so_34713108_34713427_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 464}, "so_34713108_34713427_2": {"length": 14, "quality": 1.0, "section_id": 464}, "so_34713108_34713427_3": {"length": 7, "quality": 0.875, "section_id": 464}}, "n3337": {"so_34713108_34713427_2": {"length": 14, "quality": 1.0, "section_id": 455}, "so_34713108_34713427_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 455}, "so_34713108_34713427_3": {"length": 7, "quality": 0.875, "section_id": 455}}, "n4659": {"so_34713108_34713427_2": {"length": 14, "quality": 1.0, "section_id": 487}, "so_34713108_34713427_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 487}, "so_34713108_34713427_3": {"length": 7, "quality": 0.875, "section_id": 487}}}, "34713108": {"ViewCount": "80", "Body": "<p>In the following code, I tried to pass a simple <code>struct</code> variable to <code>func()</code> function, and see what would happen to the original <code>struct</code> variable when <code>func()</code> returned.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nstruct student\n{\n    char name[8];\n};\nvoid func(student a)\n{\n    a.name[1] = 'Z';\n}\nint main()\n{\n    student a;\n    strcpy(a.name, \"abcde\");\n    func(a);\n    cout &lt;&lt; a.name;\n}\n</code></pre>\n<p>It prints out <code>abcde</code>, not <code>aZcde</code>, which means the original <code>a</code> was unchanged after <code>func()</code> returned.</p>\n<p>So rather than passing members by value( and pass address when it comes to <code>char[]</code>), it seems that the <code>struct student</code> was passed as a whole to the <code>func()</code>.</p>\n<p>I'm quite confused if this is true, because it seems this violates some principles. I have originally thought that <code>struct</code>, like many other practices, would let its member decide how to pass to a function. And  principle two just like <code>built-in array</code> which may take up lots of memory, it should pass a pointer, rather all the contents in memory, so should <code>struct</code>, especially when struct may have a couple of <code>built-in array</code> members.</p>\n<p>Just don't the details how <code>struct</code> is passed to a function.</p>\n", "AcceptedAnswerId": "34713427", "Title": "How struct was passed to a function?", "CreationDate": "2016-01-11T01:56:56.260", "Id": "34713108", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2016-01-11T03:07:34.440", "Score": "0", "OwnerUserId": "5555077", "Tags": "<c++><arrays><struct>", "AnswerCount": "3"}, "34713427": {"Id": "34713427", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34713108_34713427_0\">it should pass a pointer, rather all the contents in memory,</p>\n</blockquote>\n<p>No, all of the elements of the array will be copied. You don't declare a copy ctor by yourself, and the behaviour of implicitly-defined copy constructor is provided as follows.</p>\n<p>According to the stardard, $12.8/15 Copying and moving class objects [class.copy] (bold by me)</p>\n<blockquote>\n<p id=\"so_34713108_34713427_1\">The implicitly-defined copy/move constructor for a non-union class X\n  performs a memberwise copy/move of its bases and members. </p>\n<p id=\"so_34713108_34713427_2\">Let x be either\n  the parameter of the constructor. Each base or non-static data member\n  is copied/moved in the manner appropriate to its type: </p>\n<p id=\"so_34713108_34713427_3\">(15.1) \u2014 if the\n  member is an array, <strong>each element</strong> is direct-initialized with the\n  corresponding subobject of x;</p>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-01-11T02:49:02.853", "Score": "1", "CreationDate": "2016-01-11T02:43:39.753", "ParentId": "34713108", "CommentCount": "1", "LastEditDate": "2016-01-11T02:49:02.853", "OwnerUserId": "3309790"}, "34713475": {"Id": "34713475", "PostTypeId": "2", "Body": "<p>I believe you're seeing the C++ default copy constructor in action.</p>\n<p>The parameter is copied, and since it is an array constant (a[8]) the entire array is copied, not a pointer to it.</p>\n<p>Prefer to pass by reference (f(student&amp; s)).</p>\n", "LastActivityDate": "2016-01-11T02:49:03.617", "Score": "1", "CreationDate": "2016-01-11T02:49:03.617", "ParentId": "34713108", "CommentCount": "0", "OwnerUserId": "42059"}, "34713241": {"Id": "34713241", "PostTypeId": "2", "Body": "<p>There are three ways to pass parameters to functions in C++:</p>\n<p>1 - by value (default)</p>\n<p>2- by reference</p>\n<p>3- by pointer (which is technically by value, but with the special twist that the value passed is an address)</p>\n<p><code>func(student a)</code> is by value, as you didn't specified anything special. What happens is that you create a local variable <code>a</code>, in which you'll copy the content of <code>student a</code> (but the one in <code>main</code>). Once the function terminates, the local <code>a</code> is destroyed, and so your change didn't affect anything.</p>\n<p>But if you wanted to change the value of the struct <code>a</code> in main, you'd need to pass via reference or via a pointer. Example:</p>\n<p>Pointer:</p>\n<p>in main... <code>func(&amp;a)</code> ... and your function <code>func</code> would be</p>\n<pre><code>void func(student* a) {\n    a-&gt;name[1] = 'Z';\n}\n</code></pre>\n<p>If you'd rather want to do it via reference, no change in the main, but your function <code>func</code> would be:</p>\n<pre><code>void func(student&amp; a) {\n    a.name[1] = 'Z';\n}\n</code></pre>\n<p>For more explanation, <a href=\"http://www.tutorialspoint.com/cplusplus/cpp_functions.htm\" rel=\"nofollow\">go here</a> in the \"Function Arguments\" section.</p>\n<p><br>\n<strong>Edit:</strong> In response to OP saying</br></p>\n<blockquote>\n<p id=\"so_34713108_34713241_0\">many other practices, would let its member decide how to pass to a function. And principle two just like built-in array which may take up lots of memory, it should pass a pointer, rather all the contents in memory [...] Just don't (explain) the details how struct is passed to a function.</p>\n</blockquote>\n<p>In the C/C++ mentality, almost nothing is done in the background. It's meant to give the power to the programmer to decide which way is better for a specific case. The down side is that it makes it a little more cryptic/difficult for new comers. </p>\n<p>Therefore, passing a <code>struct</code> as a parameter, without using <code>&amp;</code> or <code>*</code> (aka pointers or references) will make it pass by value. C++ won't do some magic behind your back, and it'll be consistent.</p>\n", "LastEditorUserId": "3893901", "LastActivityDate": "2016-01-11T03:07:34.440", "Score": "3", "CreationDate": "2016-01-11T02:15:34.733", "ParentId": "34713108", "CommentCount": "4", "LastEditDate": "2016-01-11T03:07:34.440", "OwnerUserId": "3893901"}});