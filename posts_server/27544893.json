post_cb({"27545083": {"Id": "27545083", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27544893_27545083_0\">I suspect the reason has to do with the fact that a using <em>directive</em> is supposed to make the symbol appear as if it is in the global namespace <code>::</code> (because that is the common ancestor of namespaces <code>alleq</code> and <code>ns</code>).</p>\n</blockquote>\n<p>That's sort of true, but only for unqualified lookup, not argument-dependent lookup:</p>\n<p>7.3.4 [namespace.udir]:</p>\n<blockquote id=\"so_27544893_27545083_1\">\n<ol start=\"3\">\n<li>A <em>using-directive</em> specifies that the names in the nominated namespace can be used in the scope in which the <em>using-directive</em> appears after the <em>using-directive</em>. During unqualified name lookup (3.4.1), the names appear as if they were declared in the nearest enclosing namespace which contains both the <em>using-directive</em> and the nominated namespace.</li>\n</ol>\n</blockquote>\n<p>Since that only applies to unqualified name lookup, it only really helps when performing name lookup from within the enclosing namespace, when name lookup looks \"outwards\" into enclosing namespaces. It doesn't help find unqualified names from outside the namespace (which is what ADL does).</p>\n<p>And the next paragraph states:</p>\n<blockquote id=\"so_27544893_27545083_2\">\n<ol start=\"3\">\n<li>A using-directive does not add any members to the declarative region in which it appears.</li>\n</ol>\n</blockquote>\n<p>i.e. A using directive makes names visible in a scope, but does not add new declarations to the scope.</p>\n<p>The reason for the behaviour you see is simply that the standard says ADL ignores using directives:</p>\n<p>3.4.2 [basic.lookup.argdep]</p>\n<blockquote id=\"so_27544893_27545083_3\">\n<ol start=\"4\">\n<li>When considering an associated namespace, the lookup is the same as the lookup performed when the associated namespace is used as a qualifier (3.4.3.2) except that:<br>\n  \u2014 Any using-directives in the associated namespace are ignored.</br></li>\n</ol>\n</blockquote>\n", "LastEditorUserId": "981959", "LastActivityDate": "2014-12-18T11:14:36.217", "Score": "2", "CreationDate": "2014-12-18T11:05:25.027", "ParentId": "27544893", "CommentCount": "0", "OwnerUserId": "981959", "LastEditDate": "2014-12-18T11:14:36.217"}, "bq_ids": {"n4140": {"so_27544893_27545083_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 7106}, "so_27544893_27545083_2": {"length": 7, "quality": 1.0, "section_id": 5511}, "so_27544893_27545083_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 5510}}, "n3337": {"so_27544893_27545083_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 6850}, "so_27544893_27545083_2": {"length": 7, "quality": 1.0, "section_id": 5297}, "so_27544893_27545083_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 5296}}, "n4659": {"so_27544893_27545083_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 8607}, "so_27544893_27545083_2": {"length": 7, "quality": 1.0, "section_id": 6946}, "so_27544893_27545083_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 6945}}}, "27544893": {"ViewCount": "138", "Body": "<p>I am trying to understand why the following code does not compile:</p>\n<pre><code>namespace ns {\n  struct S {};\n}\n\nnamespace alleq {\n  inline bool\n  operator==(const ns::S &amp;, const ns::S &amp;)\n  {\n    return true;\n  }\n}\n\nnamespace ns {\n  using namespace alleq;\n  // using alleq::operator==; // Works if you uncomment this\n}\n\nns::S a;\n\nvoid\nf()\n{\n  ::ns::operator==(a, a); // OK\n  a == a;                 // Error: no match for 'operator=='\n}\n</code></pre>\n<p>The first line of function <code>f</code> does compile, which makes me believe that namespace <code>ns</code> contains a function <code>operator==</code>.  However, when I compare two values of type <code>ns::S</code>, this <code>operator==</code> function is not found.  By contrast, a using declaration does work as expected, and allow the second line of <code>f</code> to find <code>ns::operator==</code> by ADL.</p>\n<p>I suspect the reason has to do with the fact that a using <em>directive</em> is supposed to make the symbol appear as if it is in the global namespace <code>::</code> (because that is the common ancestor of namespaces <code>alleq</code> and <code>ns</code>).  But if that were really the case, then why would <code>::ns::operator==</code> find the function?</p>\n<p>More generally, I'm trying to provide some useful <code>operator==</code> (and related) overloads in a library, but not force people to use the definitions if they don't want them.  I was hoping to allow people to enable or not enable operator== (and related other operators) on their types based on whether they import a dedicated operator namespace into their own namespace.  Now it looks like people may have to write a host of using <em>declarations</em> (which I could simplify with a macro, but yuck).</p>\n", "AcceptedAnswerId": "27545083", "Title": "Why doesn't a using directive affect ADL?", "CreationDate": "2014-12-18T10:55:29.103", "Id": "27544893", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-12-18T11:14:36.217", "Score": "1", "OwnerUserId": "3188445", "Tags": "<c++><namespaces><argument-dependent-lookup>", "AnswerCount": "1"}});