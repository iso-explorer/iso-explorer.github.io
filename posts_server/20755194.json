post_cb({"22301994": {"Id": "22301994", "PostTypeId": "2", "Body": "<p>There's a reason <code>unique_ptr</code> is explicitly documented to behave that way: it's a stronger guarantee than you usually get for the rest of the standard library. If the same rule applied to all types then it wouldn't need to be stated specifically for <code>unique_ptr</code>.</p>\n<p>Your code recursively calls <code>F::container.clear()</code> while another call to <code>F::container.clear()</code> is running. That is not guaranteed to work:</p>\n<blockquote>\n<p id=\"so_20755194_22301994_0\"><strong>17.6.5.8  Reentrancy  [reentrancy]</strong><br>\n   Except where explicitly specified in this standard, it is implementation-defined which functions in the Standard C ++ library may be recursively reentered.</br></p>\n</blockquote>\n<p>Now unfortunately libstdc++ fails to document which functions can be recursively reentered, so it is safer to assume that none can be, so your assertion is incorrect.</p>\n", "LastActivityDate": "2014-03-10T13:48:30.220", "CommentCount": "0", "CreationDate": "2014-03-10T13:48:30.220", "ParentId": "20755194", "Score": "2", "OwnerUserId": "981959"}, "bq_ids": {"n4140": {"so_20755194_22301994_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 6345}}, "n3337": {"so_20755194_22301994_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 6102}}, "n4659": {"so_20755194_22301994_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 7854}}}, "20755276": {"Id": "20755276", "PostTypeId": "2", "Body": "<p>The destructor of F is called while clearing the container, during which the container is not empty, thus the assertion failed.</p>\n", "LastActivityDate": "2013-12-24T05:22:24.437", "CommentCount": "3", "CreationDate": "2013-12-24T05:22:24.437", "ParentId": "20755194", "Score": "1", "OwnerUserId": "1149981"}, "20755346": {"Id": "20755346", "PostTypeId": "2", "Body": "<p>I'm not sure why you would expect that assertion to be true. You are not expected to know the details of how containers hold and destroy memory. You should not make assumptions about what happens during <code>std::set::clear()</code>, only trust that after it finishes all the destructors will be called and <code>std::set::size()</code> will return 0.</p>\n<p>In this old Dr. Dobbs article <a href=\"http://www.drdobbs.com/cpp/stls-red-black-trees/184410531\" rel=\"nofollow\">STL's Red-Black Trees</a>, the backing data structure behind <code>std::set</code> is described. Nodes will get deleted (and their contents destructed) before the whole tree is empty, but rest assured by the end of <code>std::set::clear()</code> all the destructors will be called and <code>std::set::size()</code> will return 0.</p>\n<p>Note: other implementations of <code>std::set</code> might used different backing data structures, red-black trees are only a possible implementation.</p>\n", "LastActivityDate": "2013-12-24T05:29:37.460", "CommentCount": "4", "CreationDate": "2013-12-24T05:29:37.460", "ParentId": "20755194", "Score": "1", "OwnerUserId": "1298400"}, "20755194": {"ViewCount": "899", "Body": "<p>In the following code I'd expect the assertion to pass, but it does not.</p>\n<p>This is different from the <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/reset\" rel=\"nofollow\">documented behavior of unique_ptr::reset</a> and I find it quite surprising.</p>\n<p>Am I doing something wrong or is it a bug? This is a problem because if the same element is removed a gain, the destructor is called twice.</p>\n<pre><code>#include &lt;set&gt;\n#include &lt;memory&gt;\n\nstruct F\n    : std::enable_shared_from_this&lt;F&gt;\n{\n    static int destructor_count;\n    static std::set&lt;std::shared_ptr&lt;F&gt;&gt; container;\n\n    F() {}\n\n    ~F() {\n        assert(container.size() == 0);\n        container.clear(); // This will delete the same pointer twice.\n        destructor_count--;\n    }\n};\n\nint F::destructor_count = 0;\nstd::set&lt;std::shared_ptr&lt;F&gt;&gt; F::container;\n\nint main()\n{\n    F::container.insert(std::shared_ptr&lt;F&gt;(new F));\n    F::container.clear();\n    return 0;\n}\n</code></pre>\n<p>Compiler Information:</p>\n<p>libstdc++6-4.6-dev</p>\n<pre><code>g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n", "AcceptedAnswerId": "22301994", "Title": "set.clear() calls destructors of contained elements before removing the element", "CreationDate": "2013-12-24T05:12:18.583", "Id": "20755194", "CommentCount": "4", "LastEditDate": "2013-12-24T06:01:54.177", "PostTypeId": "1", "LastEditorUserId": "1278288", "LastActivityDate": "2014-03-10T13:48:30.220", "Score": "0", "OwnerUserId": "1278288", "Tags": "<c++><stl><g++><libstdc++>", "AnswerCount": "3"}});