post_cb({"24092614": {"ViewCount": "143", "Body": "<p>Consider this hypothetical code snippet :</p>\n<pre><code> template&lt;?? function&gt;\n void loop() {        \n    for(int i =0; i &lt; 10000; ++i ) {\n        function(i)\n    }\n }\n\n //...\n\n void print(int i) {\n    std::cout &lt;&lt; i &lt;&lt; '\\n';\n }\n\n //...\n\n loop&lt;print&gt;();\n</code></pre>\n<p>is it possible to do something like that in C++ ? So far I know that function pointers and generic functors can be passed through templates parameters (like in std::sort), but is there a way to make it so that no actual object is passed during runtime and the call to \"print\" is completely direct (ie no indirection) ?  ie transferring the actual function by \"value\" in the template, like it's possible to pass integer in a template using <code>template &lt;int i&gt;</code> or some other integral types.</p>\n", "Title": "actual function as template parameter?", "CreationDate": "2014-06-07T00:57:03.967", "LastActivityDate": "2014-06-07T04:24:46.163", "CommentCount": "4", "LastEditDate": "2014-06-07T01:01:48.550", "PostTypeId": "1", "LastEditorUserId": "744178", "Id": "24092614", "Score": "3", "OwnerUserId": "875295", "Tags": "<c++><templates>", "AnswerCount": "5"}, "24092680": {"Id": "24092680", "PostTypeId": "2", "Body": "<p>Since you can pass pointers to templates as non-type parameters, you can pass function pointers to them as well. You may also consider one to pass function objects.</p>\n<pre><code> #include &lt;iostream&gt;\n\n template &lt;void (*f)()&gt;\n void loop() {\n   f();\n }\n\n template &lt;typename F&gt;\n void loop() {\n   F()();\n }\n\n void F() {\n   std::cout &lt;&lt; \"F\" &lt;&lt; std::endl;\n }\n\n struct G {\n\n   void operator()() const {\n     std::cout &lt;&lt; \"G\" &lt;&lt; std::endl;\n   }\n\n };\n\n int main() {\n   loop&lt;F&gt;();\n   loop&lt;G&gt;();\n }\n</code></pre>\n<p>Prints</p>\n<pre><code> F\n G\n</code></pre>\n", "LastActivityDate": "2014-06-07T01:08:47.337", "CommentCount": "1", "CreationDate": "2014-06-07T01:08:47.337", "ParentId": "24092614", "Score": "1", "OwnerUserId": "2968284"}, "24092671": {"Id": "24092671", "PostTypeId": "2", "Body": "<p>Of course, it is possible. Template non-type parameters can be of function pointer type. In the most simplistic case, specifically tailored to your simple example it might look as follows</p>\n<pre><code>template &lt;void (*function)(int)&gt;\nvoid loop() {        \n   for(int i = 0; i &lt; 10000; ++i ) {\n       function(i);\n   }\n}\n</code></pre>\n<p>Note that C++03 stated that a valid template argument for such template must be a pointer to a function with <em>external linkage</em>. C++11 removed the external linkage requirement.</p>\n", "LastEditorUserId": "1783614", "LastActivityDate": "2014-06-07T01:26:29.013", "Score": "3", "CreationDate": "2014-06-07T01:06:22.960", "ParentId": "24092614", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2014-06-07T01:26:29.013"}, "24093636": {"Id": "24093636", "PostTypeId": "2", "Body": "<p>There is no way to use a function rather than a function pointer as a template argument. There fairly few entities which can be used a template arguments. The non-type template parameters are listed in 14.1 [temp.param] paragraph 4:</p>\n<blockquote>\n<p id=\"so_24092614_24093636_0\">A non-type template-parameter shall have one of the following (optionally cv-qualified) types:</p>\n<ul>\n<li>integral or enumeration type,</li>\n<li>pointer to object or pointer to function,</li>\n<li>lvalue reference to object or lvalue reference to function,</li>\n<li>pointer to member,</li>\n<li>std::nullptr_t.</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2014-06-07T04:24:46.163", "CommentCount": "0", "CreationDate": "2014-06-07T04:24:46.163", "ParentId": "24092614", "Score": "0", "OwnerUserId": "1120273"}, "24092816": {"Id": "24092816", "PostTypeId": "2", "Body": "<p>A simpler function template, without any bells and whistles :)</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename Function&gt;\nvoid loop(Function function) {        \n    for(int i =0; i &lt; 10000; ++i ) {\n        function(i);\n    }\n}\n\nvoid print(int i) {\n    std::cout &lt;&lt; i &lt;&lt; '\\n';\n}\n\nint main()\n{\n   loop(print);\n   return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-06-07T01:34:11.803", "CommentCount": "2", "CreationDate": "2014-06-07T01:34:11.803", "ParentId": "24092614", "Score": "2", "OwnerUserId": "434551"}, "bq_ids": {"n4140": {"so_24092614_24093636_0": {"length": 8, "quality": 1.0, "section_id": 57}}, "n3337": {"so_24092614_24093636_0": {"length": 8, "quality": 1.0, "section_id": 52}}, "n4659": {"so_24092614_24093636_0": {"length": 8, "quality": 1.0, "section_id": 59}}}, "24092669": {"Id": "24092669", "PostTypeId": "2", "Body": "<p>As has been noted in other answers, there is such a thing as function template parameters. However, sometimes it is desirable for the template parameter to be a type. This is especially useful with other kinds of template metaprogramming, e.g. to make a list of functions.</p>\n<p>The following code allows you to wrap functions in types. There are different variants of the <code>WRAP_FUNC</code> macro for wrapping a function. The suffix-less one is for use outside of templates, the <code>_T</code> variant is for use within templates, and the <code>_TI</code> variant is for inheriting within templates (see below).</p>\n<p>Note that in order to work with references, <code>std::forward</code> is used. Also, it must be used as written, with another parameter pack, <code>CallArgs</code>, for the types of arguments which <code>call()</code> is called with, as opposed to <code>Args</code>, which are the argument types for the given function.</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;stdio.h&gt;\n\n// This goes into a header.\n\ntemplate &lt;typename R, typename... Args&gt;\nstruct Helper {\n    template &lt;R (*Func) (Args...)&gt;\n    struct Wrapper {\n        template &lt;typename... CallArgs&gt;\n        static R call (CallArgs &amp;&amp; ... args)\n        {\n            return Func(std::forward&lt;CallArgs&gt;(args)...);\n        }\n    };\n};\n\ntemplate &lt;typename R, typename... Args&gt;\nstruct Helper&lt;R, Args...&gt; MakeHelper (R (*func) (Args...));\n\n#define WRAP_FUNC(func) decltype(MakeHelper(func))::Wrapper&lt;func&gt;\n#define WRAP_FUNC_T(func) typename decltype(MakeHelper(func))::template Wrapper&lt;func&gt;\n#define WRAP_FUNC_TI(func) decltype(MakeHelper(func))::template Wrapper&lt;func&gt;\n\n// Let's try it out.\n\nstatic double test_func (int x, double y)\n{\n    return x + y;\n}\nusing TestFunc = WRAP_FUNC(test_func);\n\ntemplate &lt;typename Func&gt;\nstatic void CallFunc ()\n{\n    double r = Func::call(4, 6.0);\n    printf(\"%f\\n\", r);\n}\n\nint main ()\n{\n    CallFunc&lt;TestFunc&gt;();\n}\n</code></pre>\n<p>If the function can only be defined after being passed to the class that needs it (because it itself calls to the class that calls it and we don't want to separate its definition and declaration), inheritance can be used to work around the circular dependency. Here, the <code>_TI</code> form of the macro needs to be used if this is within a template.</p>\n<pre><code>template &lt;.....&gt;\nclass Qux {\n    struct CallbackFunc;\n    using MyFoo = Foo&lt;CallbackFunc&gt;;\n\n    static void callback_func ()\n    {\n        // Foo calls us but we call Foo!\n        MyFoo::bar();\n    }\n    struct CallbackFunc : public WRAP_FUNC_TI(callback_func) {};\n};\n</code></pre>\n", "LastEditorUserId": "1020667", "LastActivityDate": "2014-06-07T02:20:27.177", "Score": "2", "CreationDate": "2014-06-07T01:05:59.630", "ParentId": "24092614", "CommentCount": "4", "OwnerUserId": "1020667", "LastEditDate": "2014-06-07T02:20:27.177"}});