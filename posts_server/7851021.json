post_cb({"bq_ids": {"n4140": {"so_7851021_7851319_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 6172}}, "n3337": {"so_7851021_7851319_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 5933}}, "n4659": {"so_7851021_7851319_0": {"length": 15, "quality": 0.5357142857142857, "section_id": 7667}}}, "7851319": {"Id": "7851319", "PostTypeId": "2", "Body": "<p>The implicit move-on-return is only legal in the same contexts in which RVO is legal.  And RVO is legal when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv- unqualified type as the function return type ([class.copy]/p31/b1).</p>\n<p>If you transform <code>make_c4</code> to:</p>\n<pre><code>C make_c4(int a) {\n    C tmp;\n    if (a == 1)\n        return make_c1();\n    return tmp;\n}\n</code></pre>\n<p>Then you get the expected move construction for the call to <code>make_c4(2)</code>.  Your <code>make_c5</code> rewrite is not desirable for exactly the reasons you state.</p>\n<p><strong>Update:</strong></p>\n<p>I should have also included a reference to [expr.cond]/p6/b1 which explains the semantics of the conditional expression when the second expression is a prvalue and the third is an lvalue, but both have the same type:</p>\n<blockquote>\n<p id=\"so_7851021_7851319_0\">The second and third operands have the same type; the result is of\n  that type. If the operands have class type, the result is a prvalue\n  temporary of the result type, which is copy-initialized from either\n  the second operand or the third operand depending on the value of the\n  first operand.</p>\n</blockquote>\n<p>I.e. this paragraph specifies that the resultant prvalue of the conditional is <em>copy-initialized</em>, from the 3rd argument in your example.  <em>Copy-initialization</em> is defined in [dcl.init]/p14.  When the source of a copy-initialization is a class-type lvalue, this will invoke the type's copy constructor.  If the source is an rvalue, it will invoke the move constructor if one exists, else it will invoke the copy constructor.</p>\n<p>The specification of the conditional expression has no allowance for an implicit move from an lvalue argument, even if the conditional expression is part of a return expression.  It is possible that the language could have been crafted to allow such an implicit move, but as far as I know, it was never proposed.  Furthermore the existing specification of the conditional expression is already extremely complicated, making such change to the language all the more difficult.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2011-10-21T17:52:33.617", "Score": "7", "CreationDate": "2011-10-21T15:00:13.247", "ParentId": "7851021", "CommentCount": "5", "OwnerUserId": "576911", "LastEditDate": "2011-10-21T17:52:33.617"}, "7851021": {"ViewCount": "508", "Body": "<p>I have been learning about move constructors over the last day or so, trying to stick to a general rule of returning by value as most people seem to suggest, and have come across an interesting (to me) dilemma.</p>\n<p>Assume that I have an expensive to construct/copy class 'C' that has correctly defined copy constructor, assignment operator, move constructor and move assignment operator.</p>\n<p>First, this piece of code elides the copy constructor as I expected:</p>\n<pre><code>C make_c1() {\n    return C();\n}\n</code></pre>\n<p>as does this:</p>\n<pre><code>C make_c2() {\n    C tmp;\n    return tmp;\n}\n</code></pre>\n<p>and so does this (whether I pass in a 1 or 2):</p>\n<pre><code>C make_c3(int a) {\n    return a == 1 ? make_c1() : make_c2();\n}\n</code></pre>\n<p>It's when I get to this that I have an issue:</p>\n<pre><code>C make_c4(int a) {\n    C tmp;\n    return a == 1 ? make_c1() : tmp;\n}\n</code></pre>\n<p>Passing in a 1 triggers RVO for the result of make_c1, but passing in a 2 triggers the copy constructor on tmp.</p>\n<p>Amending the function to the following causes the move constructor to be triggered for tmp instead:</p>\n<pre><code>C make_c5(int a) {\n    C tmp;\n    return a == 1 ? make_c1() : std::move(tmp);\n}\n</code></pre>\n<p>All great and wonderful except...</p>\n<p>In these simple examples, RVO has been triggered pretty much as I'd hoped.</p>\n<p>However what if my code is slightly more complex and on some compilers doesn't evoke RVO in that last function? In that case, I'd need to wrap my call to make_c1 in std::move, which will make the code less efficient on those compilers that do evoke RVO.</p>\n<p>So my questions are:</p>\n<ol>\n<li>Why was the move constructor not invoked in make_c4 when I returned my local object? (It's about to be destroyed after all).</li>\n<li>In the function make_c5, should I return the results of make_c1 by value or by moving it? (To avoid different versions of the code for differing compilers/platforms).</li>\n<li>Is there a better way to code the final function so that it does the right thing for a reasonable compiler implementation?</li>\n</ol>\n<p>The compiler I have been playing with is GCC 4.5.3 on Cygwin.</p>\n", "AcceptedAnswerId": "7851319", "Title": "RVO, move operations and a dilemma", "CreationDate": "2011-10-21T14:38:07.540", "Id": "7851021", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-10-21T16:31:35.800", "LastEditorUserId": "125671", "LastActivityDate": "2011-10-21T17:52:33.617", "Score": "8", "OwnerUserId": "125671", "Tags": "<c++><c++11>", "AnswerCount": "1"}});