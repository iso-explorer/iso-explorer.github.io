post_cb({"5989131": {"Id": "5989131", "PostTypeId": "2", "Body": "<p>You are confusing the type and the value of the comparator; use this e.g.:</p>\n<pre><code>int main()\n{\n    std::map&lt;foo, bool, bool(*)(const foo&amp;, const foo&amp;)&gt; fooMap(compare_foo);\n}\n</code></pre>\n", "LastActivityDate": "2011-05-13T08:18:02.297", "CommentCount": "0", "CreationDate": "2011-05-13T08:18:02.297", "ParentId": "5989010", "Score": "2", "OwnerUserId": "85371"}, "5989010": {"ViewCount": "619", "Body": "<p>A <code>std::map</code> must satisfy the requirements of an associative container specified in paragraph 23.1.2/2:</p>\n<blockquote>\n<p id=\"so_5989010_5989010_0\">Each associative container is\n  parameterized on Key and an ordering\n  relation Compare that induces a strict\n  weak ordering (25.3) on elements of\n  Key. In addition, map and multimap\n  associate an arbitrary type T with the\n  Key. The object of type Compare is\n  called the comparison object of a\n  container. This comparison object may\n  be a <strong>pointer to function</strong> or an object\n  of a type with an appropriate function\n  call operator.</p>\n</blockquote>\n<p>But then in paragraph 23.3.1/2 the <code>std::map</code> template is specified as:</p>\n<pre><code>template &lt;class Key, class T, class Compare = less&lt;Key&gt;,\n          class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;\nclass map;\n</code></pre>\n<p>which seems to explicitly prohibit the use of a function pointer as <code>Compare</code>. Is this a contradiction or am I not understanding the standard correctly?</p>\n<p><strong>EDIT:</strong> Yes, the problem I was really having was why code like GMan's example:</p>\n<pre><code>struct foo\n{\n    int x;\n};\n\nbool compare_foo(const foo&amp; x, const foo&amp; y)\n{\n    return x.x &lt; y.x;\n}\n\nstd::map&lt;foo, bool, compare_foo&gt; fooMap;\n</code></pre>\n<p>wouldn't compile (yeah, I stupidly mixed up the type and value of the <code>Compare</code> parameter).</p>\n", "AcceptedAnswerId": "5989097", "Title": "Contradiction in C++ standard?", "CreationDate": "2011-05-13T08:05:47.763", "Id": "5989010", "CommentCount": "2", "LastEditDate": "2011-05-13T08:28:09.697", "PostTypeId": "1", "LastEditorUserId": "125672", "LastActivityDate": "2011-05-13T08:28:09.697", "Score": "2", "OwnerUserId": "125672", "Tags": "<c++>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_5989010_5989010_0": {"length": 28, "quality": 0.6666666666666666, "section_id": 738}}, "n3337": {"so_5989010_5989010_0": {"length": 28, "quality": 0.6666666666666666, "section_id": 727}}, "n4659": {"so_5989010_5989010_0": {"length": 28, "quality": 0.6666666666666666, "section_id": 796}}}, "5989057": {"Id": "5989057", "PostTypeId": "2", "Body": "<p>This:</p>\n<pre><code>class Compare\n</code></pre>\n<p>does not mean that Compare has to be a class. It might be clearer if it said:</p>\n<pre><code>typename Compare\n</code></pre>\n<p>You can use any type that provides the comparable function call semantics, such as a function pointer.</p>\n", "LastActivityDate": "2011-05-13T08:10:02.770", "CommentCount": "4", "CreationDate": "2011-05-13T08:10:02.770", "ParentId": "5989010", "Score": "5", "OwnerUserId": "2100815"}, "5989039": {"Id": "5989039", "PostTypeId": "2", "Body": "<p>Specify it like this:</p>\n<pre><code>struct foo\n{\n    int x;\n};\n\nbool compare_foo(foo x, foo y)\n{\n    return x.x &lt; y.x;\n}\n\n//                  vvvvvvvvvvvvvvvvv function pointer type\nstd::map&lt;foo, bool, bool(*)(foo, foo)&gt; fooMap(compare_foo);\n//                     function pointer value ^^^^^^^^^^^\n</code></pre>\n", "LastEditorUserId": "87234", "LastActivityDate": "2011-05-13T08:18:40.203", "Score": "3", "CreationDate": "2011-05-13T08:08:16.583", "ParentId": "5989010", "CommentCount": "7", "OwnerUserId": "87234", "LastEditDate": "2011-05-13T08:18:40.203"}, "5989097": {"Id": "5989097", "PostTypeId": "2", "Body": "<p>Compare is the type of the comparator.  The fact that it is declared with <code>class</code> instead of <code>typename</code> doesn't make a difference, you can have a pointer to function as type and give your function in the map constructor.</p>\n<pre><code>#include &lt;map&gt;\n\nbool myCmp(int a, int b) {\n    return a &lt; b;\n}\n\nvoid foo()\n{\n    std::map&lt;int, char*, bool (*)(int, int)&gt; m(myCmp);\n}\n</code></pre>\n", "LastActivityDate": "2011-05-13T08:14:19.493", "CommentCount": "0", "CreationDate": "2011-05-13T08:14:19.493", "ParentId": "5989010", "Score": "7", "OwnerUserId": "136208"}});