post_cb({"39583562": {"ParentId": "39583491", "CommentCount": "12", "Body": "<p>I want to say you can do it like this:</p>\n<pre><code>new (const_cast&lt;SomeStruct*&gt;(thing)) volatile SomeStruct(...);\n</code></pre>\n<p>But I'm not actually sure whether this is valid or not. The problem is that since the allocation function returns a <code>void*</code> into which to construct the <code>volatile SomeStruct</code> object, accesses to the memory may not have volatile semantics, leading to undefined behavior.</p>\n<p>So I'm not sure whether it's legal to use placement new to construct an object into a volatile-qualified block of memory. However, assuming the memory was originally, say, a non-volatile array of <code>char</code>, this seems like the correct solution.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "39583562", "Score": "8", "CreationDate": "2016-09-19T23:30:56.293", "LastActivityDate": "2016-09-19T23:30:56.293"}, "39704547": {"ParentId": "39583491", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_39583491_39704547_0\">I know this would work if there was no <code>volatile</code> keyword......but how can I do this with a <code>volatile</code> variable?</p>\n</blockquote>\n<p>Placement <code>new</code> has to do with constructing an object at a given location. <em>cv-qualifiers</em> are only applied after the object is constructed. The <code>const</code>-ness or <code>volatile</code>-ity are only applicable once the object is constructed. In that sense, it makes sense that the placement <code>new</code> does not provide an overload that accepts a <code>volatile</code> (or <code>const</code>) pointer. From the C++ standard (draft) <a href=\"http://eel.is/c++draft/class.ctor#3\" rel=\"nofollow noreferrer\">[class.ctor/3] here</a>;</p>\n<blockquote>\n<p id=\"so_39583491_39704547_1\">A constructor can be invoked for a <code>const</code>, <code>volatile</code> or <code>const volatile</code> object. <code>const</code> and <code>volatile</code> semantics ([dcl.type.cv]) are not applied on an object under construction. They come into effect when the constructor for the most derived object ([intro.object]) ends.</p>\n</blockquote>\n<p>Any attempt to cast away the <code>volatile</code> leads to undefined behavior, <a href=\"http://en.cppreference.com/w/cpp/language/const_cast\" rel=\"nofollow noreferrer\">see the cppreference here</a>;</p>\n<blockquote>\n<p id=\"so_39583491_39704547_2\">Modifying a <code>const</code> object through a non-<code>const</code> access path and referring to a <code>volatile</code> object through a non-<code>volatile</code> glvalue results in undefined behavior.</p>\n</blockquote>\n<p><em>See also <a href=\"http://eel.is/c++draft/expr.const.cast#6\" rel=\"nofollow noreferrer\">[expr.const.cast/6]</a></em>.</p>\n<p>Given the use of the <code>volatile</code> and the placement <code>new</code>, the assertion in the question (and some of the comments) is that the object is required for use with a signal handler and maps to a specific location in memory.</p>\n<p>There are some alternatives though...</p>\n<p><em>If the specific location is not needed</em>, the best is to not use the placement <code>new</code> and just add a <code>volatile</code> qualifer to the object wherever it is declared;</p>\n<pre><code>struct SomeStruct {\n    /*...*/\n};\n// ...\nvolatile SomeStruct Object;\n</code></pre>\n<p><em>If both the placement <code>new</code> and the <code>volatile</code> is needed</em>, then reorder their use. Construct the object as required and then add the qualifier;</p>\n<pre><code>SomeStruct Object;\n// ...\nvoid* p = &amp;Object; // or at the required location\nvolatile SomeStruct* p2 = new (p) SomeStruct;\n</code></pre>\n<p><em>Does the <code>struct</code> have to be volatile?</em> The <code>volatile</code> parts of the <code>struct</code> could be internalised/abstracted and the <em>cv-qualifiers</em> of the data would not need to be exposed to the client to begin with, it is dealt with internally to the <code>struct</code>;</p>\n<pre><code>struct SomeStruct {\n    volatile int data;\n    void DoSomething()\n    {\n        data = 42;\n    }\n};\n\nSomeStruct Object;\n/* ... */\nvoid* p = &amp;Object;\nauto p2 = new (p) SomeStruct{};\np2-&gt;DoSomething();\n</code></pre>\n<p><em>Internalise the initialise of the volatile object</em>, an alternative is to allow the <code>SomeStruct</code> to lazy initialise (or re-initialise/reset) itself as needed. Given some of the apparent constraints, this may not be that feasible.</p>\n<pre><code>struct SomeStruct {\n    void Initialise() volatile\n    {\n        /*...*/\n    }\n}\n</code></pre>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2017-02-01T18:25:14.383", "Id": "39704547", "Score": "5", "CreationDate": "2016-09-26T13:42:54.610", "LastActivityDate": "2017-02-01T18:25:14.383"}, "bq_ids": {"n4140": {"so_39583491_39704547_1": {"section_id": 368, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_39583491_39704547_1": {"section_id": 358, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_39583491_39704547_1": {"section_id": 380, "quality": 0.9259259259259259, "length": 25}}}, "39583491": {"CommentCount": "27", "AcceptedAnswerId": "39583562", "PostTypeId": "1", "LastEditorUserId": "6149078", "CreationDate": "2016-09-19T23:21:02.627", "LastActivityDate": "2017-02-01T18:25:14.383", "LastEditDate": "2016-09-23T21:45:12.793", "ViewCount": "538", "FavoriteCount": "1", "Title": "C++ Volatile Placement New", "Id": "39583491", "Score": "16", "Body": "<p>How does one do a placement new operation on a volatile pointer.</p>\n<p>For example, I want to do something like this:</p>\n<pre><code>volatile SomeStruct Object;\nvolatile SomeStruct* thing = &amp;Object;\nnew (thing) SomeStruct(/*arguments to SomeStruct's constructor*/);\n</code></pre>\n<p>I know this would work if there was no volatile keyword......but how can I do this with a volatile variable?</p>\n<p><strong>Note:</strong></p>\n<p>Placement new is defined like this:</p>\n<pre><code>void* operator new(size_t memoryRequested, void* pointer)\n{\n  return pointer;\n}\n</code></pre>\n<p>(By the way here is how GCC implements it):</p>\n<pre><code>// Default placement versions of operator new.\ninline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT\n{ return __p; }\n</code></pre>\n<p>The problem is that I am trying to convert <code>thing</code> of type <code>volatile SomeStruct*</code> to <code>void*</code>, which is not allowed.</p>\n<p>For example if I change the new operator to this:</p>\n<pre><code>void* operator new(size_t memoryRequested, volatile void* pointer)\n{\n  return (void*)pointer;\n} \n</code></pre>\n<p>It would compile, but would invoke undefined behavior.</p>\n", "Tags": "<c++><volatile><placement-new>", "OwnerUserId": "6149078", "AnswerCount": "3"}, "39644812": {"ParentId": "39583491", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think this may help you with what it is you are trying to achieve. Now the template class I'm showing you is written with use of the Windows Platform for locking threads, you can modify this class to work with other OS - Platforms as needed. It is just used as an illustration of how one could achieve the above semantics. This does compile, run and exits with a code of 0 for Visual Studio 2015 CE. This class does rely on the <code>&lt;Windows.h&gt;</code> header file for the use of <code>CRITICAL_SECTION</code>, <code>EnterCriticalSection()</code>, <code>LeaveCriticalSection()</code>, <code>InitializeCriticalSection()</code> &amp; <code>DeleteCriticalSection()</code>. If there is an alternative to these with in other libraries such as the boost library this class can easily be written to achieve the same functionality. This class is designed to lock a user defined class object as volatile while working across multiple threads.</p>\n<p><strong>VolatileLocker.h</strong></p>\n<pre><code>#ifndef VOLATILE_LOCKER_H\n#define VOLATILE_LOCKER_H\n\n#include &lt;Windows.h&gt;\n\ntemplate&lt;typename T&gt;\nclass VolatileLocker {\nprivate:\n    T*  m_pObject;\n    CRITICAL_SECTION* m_pCriticalSection;\n\npublic:\n    VolatileLocker( volatile T&amp; objectToLock, CRITICAL_SECTION&amp; criticalSection );\n    ~VolatileLocker();\n\n    T* operator-&gt;();\n\nprivate:\n    VolatileLocker( const VolatileLocker&amp; c ); // Not Implemented\n    VolatileLocker&amp; operator=( const VolatileLocker&amp; c ); // Not Implemented\n\n}; // VolatileLocker\n\n#include \"VolatileLocker.inl\"\n\n#endif // VOLATILE_LOCKER_H\n</code></pre>\n<p><strong>VolatileLocker.inl</strong></p>\n<pre><code>// ----------------------------------------------------------------------------\n// VolatileLocker()\n// Locks A Volatile Variable So That It Can Be Used Across Multiple Threads Safely\ntemplate&lt;typename T&gt;\nVolatileLocker&lt;T&gt;::VolatileLocker( volatile T&amp; objectToLock, CRITICAL_SECTION&amp; criticalSection ) :\n    m_pObject( const_cast&lt;T*&gt;( &amp;objectToLock ) ),\n    m_pCriticalSection( &amp;criticalSection ) {\n    EnterCriticalSection( m_pCriticalSection );\n} // VolatileLocker\n\n// ----------------------------------------------------------------------------\n// ~VolatileLocker()\ntemplate&lt;typename T&gt;\nVolatileLocker&lt;T&gt;::~VolatileLocker() {\n    LeaveCriticalSection( m_pCriticalSection );\n} // ~VolatileLocker\n\n// ----------------------------------------------------------------------------\n// operator-&gt;()\n// Allow The Locked Object To Be Used Like A Pointer\ntemplate &lt;typename T&gt;\nT* VolatileLocker&lt;T&gt;::operator-&gt;() {\n    return m_pObject;\n} // operator-&gt;\n</code></pre>\n<p><strong>VolatileLocker.cpp</strong></p>\n<pre><code>#include \"VolatileLocker.h\"\n</code></pre>\n<p>Now here is the main running application that uses the templated volatile locker class and the use of the placement new operator.</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"VolatileLocker.h\"\n\nstatic CRITICAL_SECTION s_criticalSection;\n\nclass SomeClass {\nprivate:\n    int m_value;\n\npublic:\n    explicit SomeClass( int value ) : m_value( value ) {}\n\n    int getValue() const { return m_value; }\n\n}; // SomeClass\n\nint main() {\n    InitializeCriticalSection( &amp;s_criticalSection ); // Initialize Our Static Critical Section\n\n    SomeClass localStackObject( 2 ); // Create A Local Variable On The Stack And Initialize It To Some Value\n\n    // Create A Pointer To That Class And Initialize It To Null.\n    SomeClass* pSomeClass = nullptr;\n    // Not Using Heap Here, Only Use Local Stack For Demonstration, So Just Get A Reference To The Stack Object\n    pSomeClass = &amp;localStackObject;\n\n    // Here Is Our Pointer / Reference To Our Class As A Volatile Object \n    // Which Is Also Locked For Thread Safety Across Multiple Threads\n    // And We Can Access The Objects Fields (public variables, methods) via\n    // the VolatileLocker's overloaded -&gt;() operator.\n    std::cout &lt;&lt; VolatileLocker&lt;SomeClass&gt;( *pSomeClass, s_criticalSection )-&gt;getValue() &lt;&lt; std::endl;\n\n    // Placement New Operator On Our Pointer To Our Object Using The Class's Constructor\n    new (pSomeClass) SomeClass( 4 );\n\n    // Again Using The Volatile Locker And Getting The New Value.\n    std::cout &lt;&lt; VolatileLocker&lt;SomeClass&gt;( *pSomeClass, s_criticalSection )-&gt;getValue() &lt;&lt; std::endl;\n\n    // Here Is The Interesting Part - Let's Check The Original Local Stack Object\n    std::cout &lt;&lt; localStackObject.getValue() &lt;&lt; std::endl;\n\n    // Cleaning Up Our Critical Section.\n    DeleteCriticalSection( &amp;s_criticalSection );\n    return 0;\n} // main\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>2\n4\n4\n</code></pre>\n<p><strong>NOTE:</strong></p>\n<p>Something to be aware of. The initial local stack variable itself is not volatile. If you try to declare the stack variable as volatile and used it directly as such:</p>\n<pre><code>volatile SomeClass localStackObject( 2 );\nSomeClass* pSomeClass = nullptr;\npSomeClass = &amp;localStackObject; // Invalid - volatile SomeClass* cannot be assigned to an entity of type SomeClass*\n</code></pre>\n<p>If you try to work around this by using the volatile local variable directly you can still use it with the VolatileLocker, but you won't be able to use the Placement New as this snippet shows:</p>\n<pre><code>std::cout &lt;&lt; VolatileLocker&lt;SomeClass&gt;( localStackObject, s_criticalSection )-&gt;getValue() &lt;&lt; std::endl; // Line Okay - Notice using object directly and no dereferencing.\n\n// However when we get to this line of code here:\nnew (localStackObject) SomeClass( 4 ); // Does Not Compile. There Is No Instance Of Operator New To Match The Argument List\n\n// To Fix That We Can Do This:\nnew ( const_cast&lt;SomeClass*&gt;( &amp;localStackObject) ) SomeClass( 4 ); // This Will Compile\n</code></pre>\n<p>However to access any members using this design method you would then have to use the VolatileLocker to access the class's methods so the localStackObject can not be used directly .</p>\n<pre><code>// This Is Invalid:\nstd::cout &lt;&lt; localStackObject.getValue() &lt;&lt; std::endl; \n\n// Use This Instead:   \nstd::cout &lt;&lt; VolatileLocker&lt;SomeClass&gt;( localStackObject, s_criticalSection )-&gt;getValue() &lt;&lt; std::endl;\n</code></pre>\n<p>As an important reminder note this class was originally designed with the specific windows platform in mind, however, the concept of this template class can easily be written with cross-platform modularity in mind just by replacing the CRITICAL_SECTION with any available cross-platform equivalent functions.</p>\n<p>Here is a reference answer for working with Linux / Unix based systems:\n<a href=\"https://stackoverflow.com/questions/3508507/what-are-gcc-on-linuxs-equivalent-to-microsofts-critical-sections\">stackoverflow/multithreading/linux</a></p>\n<p>Here is a reference answer for working with Mac / Apple based systems:\n<a href=\"https://stackoverflow.com/questions/24533965/best-equivalent-for-entercriticalsection-on-mac-os-x\">stackoverflow/multithreading/mac</a></p>\n<p>Here are references to write cross-platform modularity equivalents:</p>\n<ol>\n<li><a href=\"http://en.cppreference.com/w/cpp/thread\" rel=\"nofollow noreferrer\">cppreference/thread</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable\" rel=\"nofollow noreferrer\">cppreference/condition_variable</a></li>\n</ol>\n", "OwnerUserId": "1757805", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:10.467", "Id": "39644812", "Score": "0", "CreationDate": "2016-09-22T16:56:56.997", "LastActivityDate": "2016-09-22T18:13:06.523"}});