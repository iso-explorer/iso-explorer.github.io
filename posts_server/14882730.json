post_cb({"bq_ids": {"n4140": {"so_14882730_14882925_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 5322}, "so_14882730_14882925_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 179}}, "n3337": {"so_14882730_14882925_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 5119}, "so_14882730_14882925_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 173}}, "n4659": {"so_14882730_14882925_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6743}, "so_14882730_14882925_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 184}}}, "14882925": {"Id": "14882925", "PostTypeId": "2", "Body": "<p>14.6.1 says:</p>\n<blockquote>\n<p id=\"so_14882730_14882925_0\">The injected-class-name can be used as a <em>template-name</em> or a <em>type-name</em>. When it is used with a <em>template-argument-list</em>, as a <em>template-argument</em> for a template <em>template-parameter</em>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, it refers to the class template itself.</p>\n</blockquote>\n<p>The \"injected-class-name\" is the name of the class template (<code>B</code>) \"injected\" into the scope of the class. In other words, it refers to the use of the unqualified name <code>B</code> within the definition of the class <code>B</code>. If you use that name in a context where a template name is required: i.e., with explicit template arguments (<code>B&lt;int&gt;</code>) or as a template argument for a template which takes a template template parameter (<code>A&lt;B&gt;</code>), it should refer to the template itself.</p>\n<p>So, gcc is right.</p>\n<p>Also, in C++11, you should not need a space after the <code>&lt;</code> in <code>&lt;::B&gt;</code>. According to section 2.5, paragraph 3, when dividing the input stream into tokens:</p>\n<blockquote>\n<p id=\"so_14882730_14882925_1\">if the next three characters are <code>&lt;::</code> and the subsequent character is neither <code>:</code> nor <code>&gt;</code>, the <code>&lt;</code> is treated as a preprocessor token by itself and not as the first character of the alternative token <code>&lt;:</code>. (<code>&lt;:</code> is another way of writing <code>[</code>.)</p>\n</blockquote>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2013-02-14T20:03:51.360", "Score": "1", "CreationDate": "2013-02-14T19:54:34.237", "ParentId": "14882730", "CommentCount": "2", "OwnerUserId": "1566221", "LastEditDate": "2013-02-14T20:03:51.360"}, "14882730": {"ViewCount": "57", "Body": "<p>Suppose i have the following code:</p>\n<pre><code>template &lt;template &lt;typename&gt; class T&gt;\nclass A {};\n\ntemplate &lt;typename T&gt;\nclass B\n{\n    A&lt;B&gt; instance;\n};\n\nint main()\n{\n   B&lt;int&gt; instance;\n}\n</code></pre>\n<p>gcc 4.7.2 and gcc 4.8.0 compiles this code ok, while icc 13.0.1 and clang 3.2 gave me an error (clang require ::B instead of B, while icc also require whitespace after &lt; in template instantiaion).</p>\n<p>Who's right?</p>\n<p>I found the thread about it (<a href=\"https://stackoverflow.com/questions/3052415/template-class-that-refers-to-itself-as-a-template-template-parameter\">Template class that refers to itself as a template template parameter?</a>), but i can't understand 14.6.1/2 of the standard and also saw LLVM bug 14350 (<a href=\"http://www.mail-archive.com/llvmbugs@cs.uiuc.edu/msg21095.html\" rel=\"nofollow noreferrer\">http://www.mail-archive.com/llvmbugs@cs.uiuc.edu/msg21095.html</a>). So, clang and intel wrong here?</p>\n", "Title": "Different behavior of compilers - template template argument", "CreationDate": "2013-02-14T19:41:09.817", "LastActivityDate": "2013-02-14T20:03:51.360", "CommentCount": "0", "LastEditDate": "2017-05-23T11:49:17.803", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "14882730", "Score": "0", "OwnerUserId": "1608835", "Tags": "<c++>", "AnswerCount": "1"}});