post_cb({"7602006": {"ParentId": "7601731", "CommentCount": "0", "Body": "<p>Quoting the C++03 standard, \u00a74.7/3 (Integral Conversions):</p>\n<blockquote>\n<p id=\"so_7601731_7602006_0\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); <strong>otherwise, the value is implementation-defined</strong>.</p>\n</blockquote>\n<p>Because the result is implementation-defined, by definition it is impossible for there to be a truly <em>portable</em> solution.</p>\n", "OwnerUserId": "636019", "PostTypeId": "2", "Id": "7602006", "Score": "10", "CreationDate": "2011-09-29T18:50:52.423", "LastActivityDate": "2011-09-29T18:50:52.423"}, "7602060": {"ParentId": "7601731", "CommentCount": "0", "Body": "<p>Here's another solution that worked for me:</p>\n<pre><code>if (val &lt;= INT_MAX) {\n    return static_cast&lt;int&gt;(val);\n}\nelse {\n    int ret = static_cast&lt;int&gt;(val &amp; ~INT_MIN);\n    return ret | INT_MIN;\n}\n</code></pre>\n<p>If I mask off the high bit, I avoid overflow when casting.  I can then OR it back safely.</p>\n", "OwnerUserId": "46821", "PostTypeId": "2", "Id": "7602060", "Score": "4", "CreationDate": "2011-09-29T18:55:23.520", "LastActivityDate": "2011-09-29T18:55:23.520"}, "7601731": {"CommentCount": "5", "AcceptedAnswerId": "7602036", "PostTypeId": "1", "LastEditorUserId": "46821", "CreationDate": "2011-09-29T18:25:30.993", "LastActivityDate": "2011-09-29T18:59:52.837", "LastEditDate": "2011-09-29T18:57:22.100", "ViewCount": "11647", "FavoriteCount": "1", "Title": "How does one safely static_cast between unsigned int and int?", "Id": "7601731", "Score": "10", "Body": "<p>I have an 8-character <code>string</code> representing a hexadecimal number and I need to convert it to an <code>int</code>.  This conversion has to preserve the bit pattern for strings <code>\"80000000\"</code> and higher, i.e., those numbers should come out negative.  Unfortunately, the naive solution:</p>\n<pre><code>int hex_str_to_int(const string hexStr)\n{    \n    stringstream strm;\n    strm &lt;&lt; hex &lt;&lt; hexStr;\n    unsigned int val = 0;\n    strm &gt;&gt; val;\n    return static_cast&lt;int&gt;(val);\n}\n</code></pre>\n<p>doesn't work for my compiler if <code>val &gt; MAX_INT</code> (the returned value is 0).  Changing the type of val to <code>int</code> also results in a 0 for the larger numbers.  I've tried several different solutions from various answers here on SO and haven't been successful yet.</p>\n<p>Here's what I do know:</p>\n<ul>\n<li>I'm using HP's C++ compiler on OpenVMS (using, I believe, an Itanium processor).</li>\n<li><code>sizeof(int)</code> will be at least 4 on every architecture my code will run on.</li>\n<li>Casting from a number &gt; INT_MAX to int is implementation-defined. On my machine, it usually results in a 0 but interestingly casting from <code>long</code> to <code>int</code> results in <code>INT_MAX</code> when the value is too big.</li>\n</ul>\n<p>This is surprisingly difficult to do correctly, or at least it has been for me.  Does anyone know of a <strong>portable</strong> solution to this?</p>\n<p><strong>Update:</strong></p>\n<p>Changing <code>static_cast</code> to <code>reinterpret_cast</code> results in a compiler error.  A comment prompted me to try a C-style cast: <code>return (int)val</code> in the code above, and it worked.  <em>On this machine.</em>  Will that still be safe on other architectures?</p>\n", "Tags": "<c++><casting><integer-overflow><openvms>", "OwnerUserId": "46821", "AnswerCount": "4"}, "7602036": {"ParentId": "7601731", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>While there are ways to do this using casts and conversions, most rely on undefined behavior that happen to have well-defined behaviors on some machines / with some compilers. Instead of relying on undefined behavior, copy the data:</p>\n<pre><code>int signed_val;\nstd::memcpy (signed_val, val, sizeof(int));\nreturn signed_val;\n</code></pre>\n", "OwnerUserId": "774499", "LastEditorUserId": "774499", "LastEditDate": "2011-09-29T18:59:52.837", "Id": "7602036", "Score": "8", "CreationDate": "2011-09-29T18:52:41.647", "LastActivityDate": "2011-09-29T18:59:52.837"}, "7601786": {"ParentId": "7601731", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can negate an unsigned twos-complement number by taking the complement and adding one. So let's do that for negatives:</p>\n<pre><code>if (val &lt; 0x80000000) // positive values need no conversion\n  return val;\nif (val == 0x80000000) // Complement-and-addition will overflow, so special case this\n  return -0x80000000; // aka INT_MIN\nelse\n  return -(int)(~val + 1);\n</code></pre>\n<p>This assumes that your ints are represented with 32-bit twos-complement representation (or have similar range). It does not rely on any undefined behavior related to signed integer overflow (note that the behavior of <em>unsigned</em> integer overflow is well-defined - although that should not happen here either!).</p>\n<p>Note that if your ints are not 32-bit, things get more complex. You may need to use something like <code>~(~0U &gt;&gt; 1)</code> instead of <code>0x80000000</code>. Further, if your ints are no twos-complement, you may have overflow issues on certain values (for example, on a ones-complement machine, <code>-0x80000000</code> cannot be represented in a 32-bit signed integer). However, non-twos-complement machines are very rare today, so this is unlikely to be a problem.</p>\n", "OwnerUserId": "36723", "LastEditorUserId": "36723", "LastEditDate": "2011-09-29T18:38:17.873", "Id": "7601786", "Score": "5", "CreationDate": "2011-09-29T18:30:39.983", "LastActivityDate": "2011-09-29T18:38:17.873"}, "bq_ids": {"n4140": {"so_7601731_7602006_0": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_7601731_7602006_0": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_7601731_7602006_0": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}}}});