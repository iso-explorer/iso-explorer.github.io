post_cb({"32505222": {"Id": "32505222", "PostTypeId": "2", "Body": "<p>A quick note on something I don't see covered explicitly by the other answers:</p>\n<blockquote>\n<p id=\"so_32504524_32505222_0\">if the order of evaluation for <code>x*f(x)</code> is guaranteed if <code>f</code> modifies <code>x</code>, and is this different for <code>f(x)*x</code>.</p>\n</blockquote>\n<p>Consider, as in Maksim's answer</p>\n<pre><code>operator*(x, f(x));\n</code></pre>\n<p>now there are only two ways of evaluating both arguments before the call as required:</p>\n<pre><code>auto lhs = x;        // or auto rhs = f(x);\nauto rhs = f(x);     // or auto lhs = x;\n    return lhs * rhs\n</code></pre>\n<p>So, when you ask</p>\n<blockquote>\n<p id=\"so_32504524_32505222_1\">I'm wondering whether this is guaranteed behavior or unspecified.</p>\n</blockquote>\n<p>the standard doesn't specify <em>which</em> of those two behaviours the compiler must choose, but it <em>does</em> specify those are the only valid behaviours.</p>\n<p>So, it's neither guaranteed nor entirely unspecified.</p>\n<hr>\n<p>Oh, and:</p>\n<blockquote>\n<p id=\"so_32504524_32505222_2\">I've looked at a bunch of questions regarding sequence points, and haven't been able to figure out if the order of evaluation ...</p>\n</blockquote>\n<p><em>sequence points</em> are a used in the C language standard's treatment of this, but not in the C++ standard.</p>\n</hr>", "LastActivityDate": "2015-09-10T14:52:43.850", "CommentCount": "4", "CreationDate": "2015-09-10T14:52:43.850", "ParentId": "32504524", "Score": "7", "OwnerUserId": "212858"}, "32514058": {"Id": "32514058", "PostTypeId": "2", "Body": "<p>In the expression <code>x * y</code>, the terms <code>x</code> and <code>y</code> are <em>unsequenced</em>. This is one of the three possible sequencing relations, which are:</p>\n<ul>\n<li><code>A</code> <em>sequenced-before</em> <code>B</code>: <code>A</code> must be evaluated, with all side-effects complete, before <code>B</code> begins evaluationg</li>\n<li><code>A</code> and <code>B</code> <em>indeterminately-sequenced</em>:  one of the two following cases is true: <code>A</code> is sequenced-before <code>B</code>, or <code>B</code> is sequenced-before <code>A</code>. It is <em>unspecified</em> which of those two cases holds.</li>\n<li><code>A</code> and <code>B</code> <em>unsequenced</em>: There is no sequencing relation defined between <code>A</code> and <code>B</code>. </li>\n</ul>\n<p>It is important to note that these are <em>pair-wise</em> relations. We cannot say \"<code>x</code> is unsequenced\".  We can only say that two operations are unsequenced with respect to each other.</p>\n<p>Also important is that these relations are <a href=\"https://en.wikipedia.org/wiki/Transitive_relation\" rel=\"nofollow noreferrer\">transitive</a>; and the latter two relations are symmetric.</p>\n<hr>\n<p><em>unspecified</em> is a technical term which means that the Standard specifies a set number of possible results. This is different to <em>undefined behaviour</em> which means that the Standard does not cover the behaviour at all. <a href=\"https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\">See here</a> for further reading.</p>\n<hr>\n<p>Moving onto the code <code>x * f(x)</code>.  This is identical to <code>f(x) * x</code>, because as discussed above, <code>x</code> and <code>f(x)</code> are <em>unsequenced</em>, with respect to each other, in both cases.</p>\n<p>Now we come to the point where several people seem to be coming unstuck. Evaluating the expression <code>f(x)</code> is unsequenced <em>with respect to <code>x</code></em>. However, it does <strong>not</strong> follow that any statements inside the function body of <code>f</code> are also unsequenced with respect to <code>x</code>.  In fact, there are sequencing relations surrounding any function call, and those relations cannot be ignored.</p>\n<p>Here is the text from C++14:</p>\n<blockquote>\n<p id=\"so_32504524_32514058_0\">When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is <em>sequenced before</em> execution of every expression or statement in the body of the called function. [Note: Value computations and side effects associated with different argument expressions are unsequenced. \u2014end note ]\n  <strong>Every evaluation in the calling function (including other function calls) that is not otherwise specifically <em>sequenced before</em> or after the execution of the body of the called function is <em>indeterminately sequenced</em> with\n  respect to the execution of the called function.</strong></p>\n</blockquote>\n<p>with footnote:</p>\n<blockquote>\n<p id=\"so_32504524_32514058_1\">In other words, function executions do not interleave with each other.</p>\n</blockquote>\n<p>The bolded text clearly states that for the two expressions:</p>\n<ul>\n<li><strong>A</strong>: <code>x = x + 1;</code> inside <code>f(x)</code> </li>\n<li><strong>B</strong>: evaluating the first <code>x</code> in the expression <code>x * f(x)</code></li>\n</ul>\n<p>their relationship is: <em>indeterminately sequenced</em>.  </p>\n<p>The text regarding undefined behaviour and sequencing is:</p>\n<blockquote>\n<p id=\"so_32504524_32514058_2\">If a side effect on a scalar object is <em>unsequenced</em> relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, and they are not potentially concurrent (1.10), the behavior is undefined.</p>\n</blockquote>\n<p>In this case, the relation is <em>indeterminately sequenced</em>, not unsequenced.  So there is no undefined behaviour.</p>\n<p>The result is instead <em>unspecified</em> according to whether <code>x</code> is sequenced before <code>x = x + 1</code> or the other way around. So there are only two possible outcomes, <code>42</code> and <code>49</code>.</p>\n<hr>\n<p>In case anyone had qualms about the <code>x</code> in <code>f(x)</code>, the following text applies:</p>\n<blockquote>\n<p id=\"so_32504524_32514058_3\">When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is <em>sequenced before</em> execution of every expression or statement in the body of the called function.</p>\n</blockquote>\n<p>So the evaluation of that <code>x</code> is <em>sequenced before</em> <code>x = x + 1</code>.  This is an example of an evlauation that falls under the case of \"specifically <em>sequenced before</em>\" in the bolded quote above.</p>\n<hr>\n<p>Footnote: the behaviour was exactly the same in C++03, but the terminology was different. In C++03 we say that there is a <em>sequence point</em> upon entry and exit of every function call, therefore the write to <code>x</code> inside the function is separated from the read of <code>x</code> outside the function by at least one sequence point.</p>\n</hr></hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-11T01:21:23.640", "Score": "5", "CreationDate": "2015-09-11T01:21:23.640", "ParentId": "32504524", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2017-05-23T11:44:29.997"}, "32504762": {"Id": "32504762", "PostTypeId": "2", "Body": "<p>The evaluation order of arguments is <strong>not</strong> specified by the standard, so the behaviour that you see is not guaranteed.</p>\n<p>Since you mention sequence points, I'll consider the c++03 standard which uses that term while the later standards have changed wording and abandoned the term.</p>\n<p>ISO/IEC 14882:2003(E) \u00a75 /4:</p>\n<blockquote>\n<p id=\"so_32504524_32504762_0\">Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified...</p>\n</blockquote>\n<hr>\n<p>There is also discussion on whether this is undefined behaviour or is the order merely unspecified. The rest of that paragraph sheds some light (or doubt) on that.</p>\n<p>ISO/IEC 14882:2003(E) \u00a75 /4:</p>\n<blockquote>\n<p id=\"so_32504524_32504762_1\">... Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior  value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full expression; otherwise the behavior is undefined.</p>\n</blockquote>\n<p><code>x</code> is indeed modified in <code>f</code> and it's value is read as an operand in the same expression where <code>f</code> is called. And it's not specified whether <code>x</code> reads the modified or non-modified value. That might scream <em>Undefined Behaviour!</em> to you, but hold your horses, because the standard also states:</p>\n<p>ISO/IEC 14882:2003(E) \u00a71.9 /17:</p>\n<blockquote>\n<p id=\"so_32504524_32504762_2\">... When calling a function (whether or not the function is inline), there is a sequence point after the evaluation of all function arguments (if any) which takes place before execution of any expressions or statements in the function body. There is also a sequence point after the copying of a returned value and before the execution of any expressions outside the function <sup>11)</sup> ...</p>\n</blockquote>\n<p>So, if <code>f(x)</code> is evaluated first, then there is a sequence point after copying the returned value. So the above rule about UB does not apply because the read of <code>x</code> is not between the next and previous sequence point. The <code>x</code> operand will have the modified value.</p>\n<p>If <code>x</code> is evaluated first, then there is a sequence point after evaluating the arguments of <code>f(x)</code> Again, the rule about UB does not apply. In this case <code>x</code> operand will have the non-modified value.</p>\n<p>In summary, the order is unspecified but there is <strong>no undefined behaviour</strong>. It's a bug, but the outcome is predictable to some degree. The behaviour is the same in the later standards, even though the wording changed. I'll not delve into those since it's already covered well in other good answers.</p>\n<hr>\n<p>Since you ask about similar situation in C</p>\n<p>C89 (draft) 3.3/3:</p>\n<blockquote>\n<p id=\"so_32504524_32504762_3\">Except as indicated by the syntax <sup>27</sup> or otherwise specified later (for the function-call operator () , &amp;&amp; , || , ?: , and comma operators), the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.</p>\n</blockquote>\n<p>The function call exception is already mentioned here. Following is the paragraph that implies the undefined behaviour if there were no sequence points:</p>\n<p>C89 (draft) 3.3/2:</p>\n<blockquote>\n<p id=\"so_32504524_32504762_4\">Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored.<sup>26</sup></p>\n</blockquote>\n<p>And here are the sequence points defined:</p>\n<p>C89 (draft) A.2</p>\n<blockquote>\n<p id=\"so_32504524_32504762_5\">The following are the sequence points described in 2.1.2.3</p>\n<ul>\n<li><p id=\"so_32504524_32504762_6\">The call to a function, after the arguments have been evaluated (3.3.2.2).</p></li>\n<li><p id=\"so_32504524_32504762_7\">...</p></li>\n<li><p id=\"so_32504524_32504762_8\">... the expression in a return statement (3.6.6.4).</p></li>\n</ul>\n</blockquote>\n<p>The conclusions are the same as in C++.</p>\n</hr></hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2015-09-11T09:10:15.847", "Score": "12", "CreationDate": "2015-09-10T14:32:07.930", "ParentId": "32504524", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2015-09-11T09:10:15.847"}, "bq_ids": {"n4140": {"so_32504524_32514058_3": {"length": 28, "quality": 1.0, "section_id": 5811}, "so_32504524_32514058_0": {"length": 60, "quality": 0.9523809523809523, "section_id": 5811}, "so_32504524_32504762_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 5811}, "so_32504524_32504764_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5811}, "so_32504524_32514058_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 5811}, "so_32504524_32514058_1": {"length": 7, "quality": 1.0, "section_id": 5811}}, "n3337": {"so_32504524_32514058_3": {"length": 28, "quality": 1.0, "section_id": 5584}, "so_32504524_32514058_0": {"length": 60, "quality": 0.9523809523809523, "section_id": 5584}, "so_32504524_32504762_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 5584}, "so_32504524_32504764_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5584}, "so_32504524_32514058_2": {"length": 20, "quality": 0.7692307692307693, "section_id": 5584}, "so_32504524_32514058_1": {"length": 7, "quality": 1.0, "section_id": 5584}}, "n4659": {"so_32504524_32514058_3": {"length": 28, "quality": 1.0, "section_id": 7273}, "so_32504524_32514058_0": {"length": 36, "quality": 0.5714285714285714, "section_id": 7273}, "so_32504524_32504762_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 7272}, "so_32504524_32504764_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7272}, "so_32504524_32514058_2": {"length": 19, "quality": 0.7307692307692307, "section_id": 7272}, "so_32504524_32514058_1": {"length": 7, "quality": 1.0, "section_id": 7273}}}, "32505295": {"Id": "32505295", "PostTypeId": "2", "Body": "<p>You need to distinguish:</p>\n<p>a) Operator precedence and associativity, which controls the order in which the values of subexpressions are combined by their operators.</p>\n<p>b) The sequence of subexpression evaluation. E.g. in the expression <code>f(x)/g(x)</code>, the compiler can evaluate <code>g(x)</code> first and <code>f(x)</code> afterwards. Nonetheless, the resulting value must be computed by dividing respective sub-values in the right order, of course.</p>\n<p>c) The sequence of side-effects of the subexpressions. Roughly speaking, for example, the compiler might, for sake of optimization, decide to write values to the affected variables only at the end of the expression or any other suitable place.</p>\n<p>As a very rough approximation, you can say, that within a single expression, the order of evaluation (not associativity etc.) is more or less unspecified. If you need a specific order of evaluation, break down the expression into series of statements like this:</p>\n<p><code>int a = f(x);\n int b = g(x);\n return a/b;</code></p>\n<p>instead of</p>\n<p><code>return f(x)/g(x);</code></p>\n<p>For exact rules, see <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/eval_order</a></p>\n", "LastEditorUserId": "212858", "LastActivityDate": "2015-09-10T16:03:27.690", "Score": "4", "CreationDate": "2015-09-10T14:56:09.213", "ParentId": "32504524", "CommentCount": "0", "OwnerUserId": "1355959", "LastEditDate": "2015-09-10T16:03:27.690"}, "32504804": {"Id": "32504804", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32504524_32504804_0\">Order of evaluation of the operands of almost all C++ operators is\n  unspecified.  The compiler can evaluate operands in any order, and may\n  choose another order when the same expression is evaluated again</p>\n</blockquote>\n<p>As the order of evaluation is not always the same hence you may get unexpected results.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow\">Order of evaluation</a></p>\n", "LastActivityDate": "2015-09-10T14:34:10.643", "CommentCount": "2", "CreationDate": "2015-09-10T14:34:10.643", "ParentId": "32504524", "Score": "1", "OwnerUserId": "3845604"}, "32504524": {"ViewCount": "2066", "Body": "<p>I've looked at a bunch of questions regarding sequence points, and haven't been able to figure out if the order of evaluation for <code>x*f(x)</code> is guaranteed if <code>f</code> modifies <code>x</code>, and is this different for <code>f(x)*x</code>. </p>\n<p>Consider this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint fx(int &amp;x) {\n  x = x + 1;\n  return x;\n}\n\nint f1(int &amp;x) {\n  return fx(x)*x; // Line A\n}\n\nint f2(int &amp;x) {\n  return x*fx(x); // Line B\n}\n\nint main(void) {\n  int a = 6, b = 6;\n  std::cout &lt;&lt; f1(a) &lt;&lt; \" \" &lt;&lt; f2(b) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This prints <code>49 42</code> on g++ 4.8.4 (Ubuntu 14.04). </p>\n<p>I'm wondering whether this is guaranteed behavior or unspecified. </p>\n<p>Specifically, in this program, <code>fx</code> gets called twice, with <code>x=6</code> both times, and returns 7 both times. The difference is that Line A computes 7*7 (taking the value of <code>x</code> after <code>fx</code> returns) while Line B computes 6*7 (taking the value of <code>x</code> before <code>fx</code> returns). </p>\n<p>Is this guaranteed behavior? If yes, what part of the standard specifies this?</p>\n<p>Also: If I change all the functions to use <code>int *x</code> instead of <code>int &amp;x</code> and make corresponding changes to places they're called from, I get <code>C</code> code which has the same issues. Is the answer any different for C?</p>\n", "AcceptedAnswerId": "32504764", "Title": "Is value of x*f(x) unspecified if f modifies x?", "CreationDate": "2015-09-10T14:22:37.220", "Id": "32504524", "CommentCount": "12", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2015-09-12T07:42:47.493", "LastEditorUserId": "178238", "LastActivityDate": "2015-09-12T07:42:47.493", "Score": "34", "OwnerUserId": "178238", "Tags": "<c++><c><c++03><order-of-evaluation><sequence-points>", "AnswerCount": "6"}, "32504764": {"Id": "32504764", "PostTypeId": "2", "Body": "<p>In terms of evaluation sequence, it is easier to think of <code>x*f(x)</code> as if it was:</p>\n<pre><code>operator*(x, f(x));\n</code></pre>\n<p>so that there are no mathematical preconceptions on how multiplication is supposed to work.</p>\n<p>As @dan04 helpfully pointed out, the standard says:</p>\n<blockquote>\n<p id=\"so_32504524_32504764_0\">Section 1.9.15: \u201cExcept where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.\u201d</p>\n</blockquote>\n<p>This means that the compiler is free to evaluate these arguments in any order, the sequence point being <code>operator*</code> call. The only guarantee is that before the <code>operator*</code> is called, both arguments have to be evaluated.</p>\n<p>In your example, conceptually, you could be certain that at least one of the arguments will be 7, but you cannot be certain that both of them will. To me, this would be enough to label this behaviour as undefined; however, @user2079303 answer explains well why it is not technically the case.</p>\n<p>Regardless of whether the behaviour is undefined or indeterminate, you cannot use such an expression in a well-behaved program.</p>\n", "LastEditorUserId": "4765374", "LastActivityDate": "2015-09-11T08:18:10.357", "Score": "22", "CreationDate": "2015-09-10T14:32:19.030", "ParentId": "32504524", "CommentCount": "31", "OwnerUserId": "4765374", "LastEditDate": "2015-09-11T08:18:10.357"}});