post_cb({"14086279": {"ParentId": "14085956", "CommentCount": "6", "Body": "<p>Your function <code>fp()</code> does not return a literal type, therefore it cannot be a <em>constexpr function</em>:</p>\n<blockquote>\n<p id=\"so_14085956_14086279_0\">From 7.1.5: \"The definition of a constexpr function shall satisfy the following constraints: </p>\n<ul>\n<li>it shall not be virtual (10.3);</li>\n<li><strong>its return type shall be a literal type</strong>;</li>\n<li>each of its parameter types shall be a literal type;</li>\n<li>its function-body shall be = delete, = default, <strong>or a compound-statement that contains only</strong>\n<ul>\n<li>null statements,</li>\n<li>static_assert-declarations</li>\n<li>typedef declarations and alias-declarations that do not define classes or enumerations,</li>\n<li>using-declarations,</li>\n<li>using-directives,</li>\n<li><strong>and exactly one return statement</strong>;\"</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>I do not think there is any bug here, and especially nothing related to lambdas as mentioned in an earlier answer: variables simply cannot be declared inside of a <em>constexpr function</em>.</p>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "14086279", "Score": "10", "CreationDate": "2012-12-29T21:56:40.487", "LastActivityDate": "2012-12-29T21:56:40.487"}, "14085956": {"CommentCount": "4", "AcceptedAnswerId": "14086279", "PostTypeId": "1", "LastEditorUserId": "1012936", "CreationDate": "2012-12-29T21:10:49.537", "LastActivityDate": "2012-12-30T00:02:34.677", "LastEditDate": "2012-12-29T21:17:39.357", "ViewCount": "1755", "FavoriteCount": "3", "Title": "Why can't my constexpr function return a lambda?", "Id": "14085956", "Score": "20", "Body": "<p>I found this piece of code doesn't work:</p>\n<pre><code>typedef int (*fp)(int a, int b);\n\nconstexpr fp addition()\n{\n    return [](int a, int b){ return a+b; };\n}\n\n#include &lt;iostream&gt;\n\nint main()\n{\n    fp fun = addition();\n    std::cout &lt;&lt; fun(2,2);\n}\n</code></pre>\n<p>It gives me error</p>\n<pre><code>cexpr.cpp: In function 'constexpr int (* addition())(int, int)':\ncexpr.cpp:5:43: error: call to non-constexpr function 'addition()::&lt;lambda(int,\nint)&gt;::operator int (*)(int, int)() const'\n</code></pre>\n<p>Why is that? I'm not calling it here.</p>\n<p>Direct approach works:</p>\n<pre><code>typedef int (*fp)(int a, int b);\n\n#include &lt;iostream&gt;\n\nint main()\n{\n    fp fun = [](int a, int b){ return a+b; };\n    std::cout &lt;&lt; fun(2,2);\n}\n</code></pre>\n<p>I'm using MinGW with g++ version 4.7.2.</p>\n", "Tags": "<c++><c++11><lambda><constexpr>", "OwnerUserId": "1012936", "AnswerCount": "3"}, "14086626": {"ParentId": "14085956", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The error message gcc gave you was precise and correct:</p>\n<blockquote>\n<p id=\"so_14085956_14086626_0\">error: call to non-constexpr function 'addition()::<br/>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&lt;lambda(int,int)&gt;::<br/>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<b>operator int (*)(int, int)() const</b>'</p>\n</blockquote>\n<p>I've reformatted it a bit and added emphasis. By coercing the lambda to a function pointer, you're implicitly calling the automatically-created conversion function from lambda to <code>pointer to function of type \"auto (int, int)-&gt;int\"</code>, which is not a constexpr function because the automatically-created conversion function is not declared <code>constexpr</code> (and the standard doesn't require it to be).</p>\n", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "LastEditDate": "2012-12-30T00:02:34.677", "Id": "14086626", "Score": "5", "CreationDate": "2012-12-29T22:52:36.393", "LastActivityDate": "2012-12-30T00:02:34.677"}, "bq_ids": {"n4140": {"so_14085956_14086253_0": {"section_id": 6184, "quality": 0.8235294117647058, "length": 28}, "so_14085956_14086279_0": {"section_id": 5419, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_14085956_14086253_0": {"section_id": 5945, "quality": 0.8235294117647058, "length": 28}, "so_14085956_14086279_0": {"section_id": 5214, "quality": 0.6666666666666666, "length": 6}, "so_14085956_14086253_1": {"section_id": 5946, "quality": 0.7142857142857143, "length": 20}}, "n4659": {"so_14085956_14086253_0": {"section_id": 7686, "quality": 0.7941176470588235, "length": 27}, "so_14085956_14086279_0": {"section_id": 6841, "quality": 0.5555555555555556, "length": 5}}}, "14086253": {"ParentId": "14085956", "CommentCount": "3", "Body": "<p>According to N3376 working draft of the standard section 5.19 [expr.const]: </p>\n<blockquote>\n<p id=\"so_14085956_14086253_0\">Certain contexts require expressions that satisfy additional\n  requirements as detailed in this sub-clause; other contexts have\n  di\ufb00erent semantics depending on whether or not an expression satis\ufb01es\n  these requirements. Expressions that satisfy these requirements are\n  called constant expressions. [ Note: Constant expressions can be\n  evaluated during translation.\u2014 end note ]</p>\n</blockquote>\n<p>It goes on to say: </p>\n<blockquote>\n<p id=\"so_14085956_14086253_1\">A conditional-expression is a core constant expression unless it\n  involves one of the following as a potentially evaluated subexpression\n  (3.2), but subexpressions of logical AND (5.14), logical OR (5.15),\n  and conditional (5.16) operations that are not evaluated are not\n  considered [ Note: An overloaded operator invokes a function.\u2014 end\n  note ]:</p>\n</blockquote>\n<p>Which lists under it:</p>\n<blockquote>\n<p id=\"so_14085956_14086253_2\">\u2014 a lambda-expression (5.1.2);</p>\n</blockquote>\n<p>So while I don't know enough standardese, I believe this says that a constexpr shouldn't have a lambda expression inside.</p>\n", "OwnerUserId": "1381108", "PostTypeId": "2", "Id": "14086253", "Score": "7", "CreationDate": "2012-12-29T21:53:03.847", "LastActivityDate": "2012-12-29T21:53:03.847"}});