post_cb({"21112279": {"Id": "21112279", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_21110059_21112279_0\">I simply do not understand what \"depends on the side effects\" means.</p>\n</blockquote>\n<p>It means that it depends on something the destructor is doing. In your example, modifying <code>*p</code> or not modifying it. You have that dependency in your code, as the output would differ if the dctor wouldn't get called.</p>\n<p>In your current code, the number that is printed, might not be the same number that would have returned by the second rand() call. Your program invokes undefined behavior, but it's just that UB here has no ill effect.</p>\n<p>If you wouldn't print the value (or otherwise read it), then there wouldn't be any  dependency on the side effects of the dcor, and thus no UB.</p>\n<p>So:</p>\n<blockquote>\n<p id=\"so_21110059_21112279_1\">Is forgetting to call a destructor any different than forgetting to call an ordinary function with the same body?</p>\n</blockquote>\n<p>Nope, it's not any different in this regard. If you depend on it being called, you must make sure it's called, otherwise your dependency is not satisfied.</p>\n<blockquote>\n<p id=\"so_21110059_21112279_2\">Furthermore, at what point is it correct to say the program \"depends\" on the destructor? Does it do so if the value was random -- or in general, if there is no way for me to distinguish the destructor from running vs. not running?</p>\n</blockquote>\n<p>Random or not doesn't matter, because the code depends on the variable being written to. Just because it's difficult to predict what the new value is doesn't mean there's no dependency.</p>\n<blockquote>\n<p id=\"so_21110059_21112279_3\">What if I never read the value?</p>\n</blockquote>\n<p>Then there's no UB, as the code has no dependency on the variable after it was written to.</p>\n<blockquote>\n<p id=\"so_21110059_21112279_4\">Under which condition(s), if any, does this program exhibit Undefined Behavior?</p>\n</blockquote>\n<p>There are no conditions. It's always UB.</p>\n<blockquote>\n<p id=\"so_21110059_21112279_5\">Exactly which expression(s) or statement(s) cause this, and why?</p>\n</blockquote>\n<p>The expression:</p>\n<pre><code>printf(\"%d\", x);\n</code></pre>\n<p>because it introduces the dependency on the affected variable.</p>\n", "LastEditorUserId": "856199", "LastActivityDate": "2014-01-14T12:07:27.903", "Score": "7", "CreationDate": "2014-01-14T11:20:00.707", "ParentId": "21110059", "CommentCount": "11", "LastEditDate": "2014-01-14T12:07:27.903", "OwnerUserId": "856199"}, "21261658": {"Id": "21261658", "PostTypeId": "2", "Body": "<p>My reading of this portion of the standard is:</p>\n<ul>\n<li>You are allowed to reuse the storage for an object that has a non-trivial destructor without calling that destructor</li>\n<li>If you do, the compiler is not allowed to call the destructor for you</li>\n<li>If your program has logic that depends on the destructor being called, your program might break.</li>\n</ul>\n<p>Side effects here are simply changes in program state that result from calling the destructor. They will be things like updating reference counts, releasing locks, closing handles, stuff like that.</p>\n<p>'Depends on the side effects' means that another part of the program expects the reference count to be maintained correctly, locks to be released, handles closed and so on. If you make a practice of not calling destructors, you need to make sure your program logic does not depend on them having been called.</p>\n<p>Although 'forgetting' is not really relevant, the answer is no, destructors are just functions. The key difference is that under some circumstances they get called by the compiler ('implicitly') and this section of the standard defines a situation in which they will not.</p>\n<p>Your example does not really 'depend on the side effects'. It obviously calls the random function exactly 3 times and prints whatever value it calculates. You could change it so:</p>\n<ul>\n<li>The struct maintains a reference count (ctor +1, dtor -1)</li>\n<li>A factory function reuses objects and randomly calls the destructor or not</li>\n<li>A client function 'depends on' the reference count being maintained correctly, by expecting it to be zero.</li>\n</ul>\n<p>Obviously, with this dependency the program would exhibit 'undefined behaviour' with respect to the reference count. </p>\n<p>Please note that 'undefined behaviour' does not have to be bad behaviour. It simply means 'behavior for which this International Standard imposes no requirements'.</p>\n<p>I really think there is a danger of overthinking what is fundamentally quite a simple concept. I can't quote any authority beyond the words that are here and the standard itself, which I find quite clear (but by all means tell me if I'm missing something).</p>\n", "LastEditorUserId": "1105562", "LastActivityDate": "2014-01-22T14:34:12.333", "Score": "1", "CreationDate": "2014-01-21T15:00:49.133", "ParentId": "21110059", "CommentCount": "2", "LastEditDate": "2014-01-22T14:34:12.333", "OwnerUserId": "1105562"}, "21273622": {"Id": "21273622", "PostTypeId": "2", "Body": "<p>Whether a program \"depends on the side effects produced by a destructor\" hinges on the definition of \"<em>observable behavior</em>\".</p>\n<p>To quote the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">standard</a> (section 1.9.8, Program execution, bold face is added):</p>\n<blockquote>\n<p id=\"so_21110059_21273622_0\">The least requirements on a conforming implementation are:</p>\n<ul>\n<li>Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</li>\n<li>At program termination, all data written into \ufb01les shall be identical to one of the possible results that execution of the program\n  according to the abstract semantics would have produced.</li>\n<li>The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered\n  before a program waits for input. What constitutes an interactive\n  device is implementation-de\ufb01ned.</li>\n</ul>\n<p id=\"so_21110059_21273622_1\">These collectively are referred to as the <strong>observable behavior</strong> of the\n  program. [ Note: More stringent correspondences between abstract and\n  actual semantics may be de\ufb01ned by each implementation. ]</p>\n</blockquote>\n<p>As for your other question:</p>\n<blockquote>\n<p id=\"so_21110059_21273622_2\">Is forgetting to call a destructor any different than forgetting to\n  call an ordinary function with the same body?</p>\n</blockquote>\n<p>Yes! Forgetting an \"equivalent\" call to a function leads to well defined behavior (whatever it was supposed to make happen doesn't happen), but it's quite different for a destructor. In essence, the the standard is saying that if you engineer your program such that an observable destructor is \"forgotten,\" then you're no longer writing C++, and your program result is completely undefined.</p>\n<p><strong>Edit:</strong>\nOh right, the last question:</p>\n<blockquote>\n<p id=\"so_21110059_21273622_3\">Under which condition(s), if any, does this program exhibit Undefined\n  Behavior?</p>\n</blockquote>\n<p>I believe printf qualifies as writing to a file, and is therefore observable. Of course rand() is not actually random, but is completely deterministic for any given seed, so the program as written does exhibit undefined behavior (that said, I would be really surprised if it didn't operate exactly as written, it just doesn't <em>have</em> to).</p>\n", "LastEditorUserId": "1239692", "LastActivityDate": "2014-01-22T03:46:24.657", "Score": "1", "CreationDate": "2014-01-22T03:28:14.673", "ParentId": "21110059", "CommentCount": "1", "LastEditDate": "2014-01-22T03:46:24.657", "OwnerUserId": "1239692"}, "bq_ids": {"n4140": {"so_21110059_21250206_2": {"length": 17, "quality": 1.0, "section_id": 5804}, "so_21110059_21272556_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7192}, "so_21110059_21286446_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 5768}, "so_21110059_21250206_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 5804}, "so_21110059_21286446_2": {"length": 34, "quality": 0.8947368421052632, "section_id": 5801}, "so_21110059_21286446_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5808}, "so_21110059_21286446_5": {"length": 25, "quality": 0.9615384615384616, "section_id": 5768}, "so_21110059_21273622_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 5804}, "so_21110059_21110059_0": {"length": 48, "quality": 0.96, "section_id": 7192}, "so_21110059_21272556_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7192}, "so_21110059_21273622_0": {"length": 4, "quality": 0.8, "section_id": 5804}, "so_21110059_21250206_1": {"length": 9, "quality": 1.0, "section_id": 5804}, "so_21110059_21250206_0": {"length": 4, "quality": 0.8, "section_id": 5804}, "so_21110059_21286446_6": {"length": 8, "quality": 0.7272727272727273, "section_id": 5768}, "so_21110059_21286446_7": {"length": 31, "quality": 0.8857142857142857, "section_id": 7192}, "so_21110059_21286446_3": {"length": 5, "quality": 0.625, "section_id": 5768}, "so_21110059_21272556_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 7192}}, "n3337": {"so_21110059_21250206_2": {"length": 17, "quality": 1.0, "section_id": 5577}, "so_21110059_21272556_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6936}, "so_21110059_21286446_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 5541}, "so_21110059_21273622_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 5577}, "so_21110059_21250206_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 5577}, "so_21110059_21286446_2": {"length": 34, "quality": 0.8947368421052632, "section_id": 5574}, "so_21110059_21110059_0": {"length": 48, "quality": 0.96, "section_id": 6936}, "so_21110059_21286446_5": {"length": 25, "quality": 0.9615384615384616, "section_id": 5541}, "so_21110059_21286446_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5581}, "so_21110059_21272556_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6936}, "so_21110059_21286446_3": {"length": 5, "quality": 0.625, "section_id": 5541}, "so_21110059_21250206_1": {"length": 9, "quality": 1.0, "section_id": 5577}, "so_21110059_21250206_0": {"length": 4, "quality": 0.8, "section_id": 5577}, "so_21110059_21286446_6": {"length": 8, "quality": 0.7272727272727273, "section_id": 5541}, "so_21110059_21286446_7": {"length": 31, "quality": 0.8857142857142857, "section_id": 6936}, "so_21110059_21273622_0": {"length": 4, "quality": 0.8, "section_id": 5577}, "so_21110059_21272556_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 6936}}, "n4659": {"so_21110059_21250206_2": {"length": 17, "quality": 1.0, "section_id": 7262}, "so_21110059_21272556_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8701}, "so_21110059_21110059_0": {"length": 48, "quality": 0.96, "section_id": 8701}, "so_21110059_21273622_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 7262}, "so_21110059_21250206_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 7262}, "so_21110059_21286446_2": {"length": 34, "quality": 0.8947368421052632, "section_id": 7260}, "so_21110059_21286446_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 7225}, "so_21110059_21286446_5": {"length": 25, "quality": 0.9615384615384616, "section_id": 7225}, "so_21110059_21286446_1": {"length": 19, "quality": 0.8260869565217391, "section_id": 7269}, "so_21110059_21272556_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 8701}, "so_21110059_21273622_0": {"length": 4, "quality": 0.8, "section_id": 7262}, "so_21110059_21250206_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 7262}, "so_21110059_21250206_0": {"length": 4, "quality": 0.8, "section_id": 7262}, "so_21110059_21286446_6": {"length": 8, "quality": 0.7272727272727273, "section_id": 7225}, "so_21110059_21286446_7": {"length": 31, "quality": 0.8857142857142857, "section_id": 8701}, "so_21110059_21286446_3": {"length": 5, "quality": 0.625, "section_id": 7225}, "so_21110059_21272556_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 8701}}}, "21110298": {"Id": "21110298", "PostTypeId": "2", "Body": "<p>Say you have a class that acquires a lock in its constructor and then releases the lock in its destructor. Releasing the lock is a side affect of calling the destructor.</p>\n<p>Now, it's your job to ensure that the destructor is called. Typically this is done by calling <code>delete</code>, but you can also call it directly, and this is usually done if you've allocated an object using placement new.</p>\n<p>In your example you've allocate 2 <code>MakeRandom</code> instances, but only called the destructor on one of them. If it were were managing some resource (like a file ) then you'd have a resource leak.</p>\n<p>So, to answer your question, yes, forgetting to call a destructor is different to forgetting to call an ordinary function. A destructor is the inverse of the constructor. You're required to call the constructor, and so you're required to call the destructor in order to \"unwind\" anything done by the destructor. This isn't the case with an \"ordinary\" function.</p>\n", "LastEditorUserId": "26095", "LastActivityDate": "2014-01-14T10:33:51.423", "Score": "0", "CreationDate": "2014-01-14T09:47:46.620", "ParentId": "21110059", "CommentCount": "15", "LastEditDate": "2014-01-14T10:33:51.423", "OwnerUserId": "26095"}, "21273893": {"Id": "21273893", "PostTypeId": "2", "Body": "<p>It basically means that when you define your own destructor for a class, it is no longer called automatically upon leaving scope. The object will still be out of scope if you try to use it, but the memory will still be used up in the stack and anything in your non-default destructor will not happen. If you want the count of objects to decrease whenever you call your destructor, for example, it will not happen.</p>\n", "LastActivityDate": "2014-01-22T04:00:11.347", "Score": "0", "CreationDate": "2014-01-22T04:00:11.347", "ParentId": "21110059", "CommentCount": "0", "OwnerUserId": "3221893"}, "21334574": {"Id": "21334574", "PostTypeId": "2", "Body": "<p>The standard is required to speak in such terms as <code>observable behavior</code> and <code>side effects</code> because, although many people often forget this, c++ is not just used for PC software. </p>\n<p>Consider the example in your comment to Gene's answer: </p>\n<pre><code>class S { \n    unsigned char x; \n    public: ~S() { \n        ++x; \n    } \n};\n</code></pre>\n<blockquote>\n<p id=\"so_21110059_21334574_0\">the destructor here is clearly modifying an object -- hence that's a\n  \"side effect\" with the given definition -- yet I'm pretty sure no\n  program could \"depend\" on this side effect in any reasonable sense of\n  the term. What am I missing?</p>\n</blockquote>\n<p>you are missing the embedded world for example. Consider a bare metal c++ program running on a small processor with special function register access to a uart:</p>\n<pre><code>new (address_of_uart_tx_special_function_register) S;\n</code></pre>\n<p>here calling the destructor clearly has observable side effects. If we don't call it, the UART transmits one byte less.</p>\n<p>Therefore whether side effects are observable also depends on what the hardware is doing with the writes to certain memory locations. </p>\n<p>It may also be noteworthy that even if the body of a destructor is empty it could still have side effects if any of the classes member variables have destructors with side effects. </p>\n<p>I don't see anything forbidding the compiler from doing other bookkeeping (maybe with regard to exceptions and stack unwinding). Even if no compiler currently does and no compiler ever will from a language lawyer point of view you still have to consider it UB unless you know that the compiler doesn't create side effects.</p>\n", "LastActivityDate": "2014-01-24T13:59:53.147", "Score": "0", "CreationDate": "2014-01-24T13:59:53.147", "ParentId": "21110059", "CommentCount": "7", "OwnerUserId": "893819"}, "21345136": {"Id": "21345136", "PostTypeId": "2", "Body": "<p>First of all, we need to define undefined behavior, which according to the C FAQ would be when:</p>\n<blockquote>\n<p id=\"so_21110059_21345136_0\">Anything at all can happen; the Standard imposes no requirements. The\n  program may fail to compile, or it may execute incorrectly (either\n  crashing or silently generating incorrect results), or it may\n  fortuitously do exactly what the programmer intended.</p>\n</blockquote>\n<p>Which, in other words, means that the programmer cannot predict what would happen once the program is executed. This doesn't mean that the program or OS would crash, it simple means that the program future state would only be know once that it is executed.</p>\n<p>So, explained in math notation, if a program is reduced to a function <em>F</em> which makes a transformation from an initial state <em>Is</em> into a final state <em>Fs</em>, given certain initial conditions <em>Ic</em></p>\n<hr>\n<p><em>F(Is,Ic) -&gt; Fs</em></p>\n<hr>\n<p>And if you evaluate the function (execute the program) <em>n</em> times, given that <em>n-&gt; \u221e</em></p>\n<hr>\n<p><em>F(Is,Ic) -&gt; Fs1</em>, <em>F(Is,Ic) -&gt; Fs2</em>, ..., <em>F(Is,Ic) -&gt; Fsn</em>,      <em>n-&gt; \u221e</em> </p>\n<hr>\n<p>Then: </p>\n<ul>\n<li>A <strong>defined behavior</strong> would be given by all the resulting states being\nthe same: Fs1 = Fs2 = ... = Fsn,     given that n-&gt; \u221e</li>\n<li>An <strong>undefined behavior</strong> would be given by the <strong>possibility</strong> of\nobtaining different finished states among different executions. Fs1 \u2260\nFs2 \u2260 ... \u2260 Fsn,     given that n-&gt; \u221e</li>\n</ul>\n<p>Notice how I highlight <strong>possibility</strong>, because undefined behavior is exactly that. There exists a possibility that the program executes as desired, but nothing guarantees that it would do so, or that it wouldn't do it.</p>\n<p>Hence, answering your answer:</p>\n<blockquote>\n<p id=\"so_21110059_21345136_1\">Is forgetting to call a destructor any different than forgetting to\n  call an ordinary function with the same body?</p>\n</blockquote>\n<p>Given that a destructor is a function that could be called even when you don't explicitly call it, forgetting to call a destructor IS different from forgetting to call an\nordinary function, and doing so COULD lead to undefined behavior.</p>\n<p>The justification is given by the fact that, when you forget to call an ordinary function you are SURE, ahead of time, that that function won't be called at any point in your program, even when you run your program an infinite number of times.</p>\n<p>However, when you forget to call a destructor, and you call your program an infinite number of times, and as is exemplified by this post:\n<a href=\"https://stackoverflow.com/questions/3179494/under-what-circumstances-are-c-destructors-not-going-to-be-called\">https://stackoverflow.com/questions/3179494/under-what-circumstances-are-c-destructors-not-going-to-be-called</a>\nunder certain circumstances, C++ destructors are not called, it means that you can't assure beforehand when the destructor would be called, nor when it wouldn't be. This uncertainty means that you can't assure the same final state, thus leading to UB.</p>\n<p>So answering your second question:</p>\n<blockquote>\n<p id=\"so_21110059_21345136_2\">Under which condition(s), if any, does this program exhibit Undefined\n  Behavior?</p>\n</blockquote>\n<p>The circumstances would be given by the circumstances when the C++ destructors are not called, given on the link that I referenced.</p>\n</hr></hr></hr></hr>", "LastActivityDate": "2014-01-25T00:51:40.500", "Score": "2", "CreationDate": "2014-01-25T00:51:40.500", "ParentId": "21110059", "CommentCount": "0", "OwnerUserId": "2691080"}, "21272556": {"Id": "21272556", "PostTypeId": "2", "Body": "<p>I have not read everyone else's input, but I have a simple explanation.  In the quote</p>\n<blockquote>\n<p id=\"so_21110059_21272556_0\">however, if there is no explicit call to the destructor or if a\n  delete-expression is not used to release the storage, the destructor\n  shall not be implicitly called and any program that depends on the\n  side effects produced by the destructor has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>The meaning is very different depending on how you parse it.\nThis meaning is what I hear people talking about.</p>\n<blockquote>\n<p id=\"so_21110059_21272556_1\">however, { if there is no explicit call to the destructor or if a\n  delete-expression is not used to release the storage }, the destructor\n  shall not be implicitly called and any program that depends on the\n  side effects produced by the destructor has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>But I think this meaning makes more sense</p>\n<blockquote>\n<p id=\"so_21110059_21272556_2\">however, if there is no explicit call to the destructor or { if a\n  delete-expression is not used to release the storage, the destructor\n  shall not be implicitly called and any program that depends on the\n  side effects produced by the destructor has unde\ufb01ned behavior } .</p>\n</blockquote>\n<p>which basically says C++ does not have a garbage collector and if you assume\nit does have GC your program will not work as you expect.</p>\n", "LastActivityDate": "2014-01-22T01:36:25.863", "Score": "0", "CreationDate": "2014-01-22T01:36:25.863", "ParentId": "21110059", "CommentCount": "1", "OwnerUserId": "1862101"}, "21286446": {"Id": "21286446", "PostTypeId": "2", "Body": "<p>For this answer, I will be using a 2012 C++11 release of the C++ standard, which can be found <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">here (C++ standard)</a>, because this is freely available and up to date.</p>\n<p>The following three terms used in your question occur as followed:</p>\n<ol>\n<li>Destructor - 385 times</li>\n<li>Side effect - 71 times</li>\n<li>Depends - 41 times</li>\n</ol>\n<p>Sadly \"depends on the side effect\" appears only once, and DEPENDS ON is not an RFC standardized identifier like SHALL, so it's rather hard to pin down what depends means. </p>\n<p><strong>Depends on</strong></p>\n<p>Let's take an \"activist judge\" approach, and assume that \"depends\", \"dependency\", and \"depending\" are all used in a similar context in this document, that is, that the language was used to convey a broad idea rather than to convey a legalease concept.</p>\n<p>Then we can analyze this portion of page 1194:</p>\n<blockquote>\n<p id=\"so_21110059_21286446_0\">17.6.3.2<br>\n  E\ufb00ect on original feature: Function swap moved to a di\ufb00erent header<br>\n  Rationale: Remove dependency on  for swap.<br>\n  E\ufb00ect on original feature: Valid C++ 2003 code that has been compiled expecting\n  swap to be in &lt; algorithm &gt; may have to instead include &lt; utility &gt;.</br></br></br></p>\n</blockquote>\n<p>This portion indicates a strict sort of dependency; you originally needed to include  to get std::swap. \"depends on\" therefore indicated a strict requirement, a necessity so to speak, in the sense that there is not sufficient context without the requirement to proceed; failure will occur without the dependency. </p>\n<p>I chose this passage because it conveys the intended meaning as clearly as possible; other passages are more verbose, but they all include a similar meaning: <strong>necessity</strong>. </p>\n<p><strong>Therefore, a \"depends on\" relationship means that the thing being depended on is required for the depending item to make sense, be whole and complete, and be usable in a context.</strong></p>\n<p>To cut through that legalese red tape, this means A depends on B means A requires B. This is basically what you'd understand \"depend\" to mean if you looked it up in a dictionary or spoke it in a sentence. </p>\n<p><strong>Side effect</strong></p>\n<p>This is more strictly defined, on page 10:</p>\n<blockquote>\n<p id=\"so_21110059_21286446_1\">Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O\n  function, or calling a function that does any of those operations are all <em>side e\ufb00ects</em>, <strong>which are changes in the\n  state of the execution environment.</strong></p>\n</blockquote>\n<p>This means that anything which results in a change to the environment (such as RAM, network IO, variables, etc etc) are side effects. This neatly fits with the notion of impurity/purity from functional languages, which is clearly what was intended. Note that the C++ standard does not require that such side effects be observable; modifying a variable in any way, even if that variable is never looked at, is still a side effect. </p>\n<p>However, due to the \"as if\" rule, such unobservable side effects may be removed, page 8:</p>\n<blockquote>\n<p id=\"so_21110059_21286446_2\">A conforming implementation executing a well-formed program shall produce the same observable behavior\n  as one of the possible executions of the corresponding instance of the abstract machine with the same program\n  and the same input. However, if any such execution contains an unde\ufb01ned operation, this International\n  Standard places no requirement on the implementation executing that program with that input (not even\n  with regard to operations preceding the \ufb01rst unde\ufb01ned operation).</p>\n</blockquote>\n<p><strong>Depends on the side effects</strong></p>\n<p>Putting these two definitions together, we can now define this phrase: something depends on the side effects when those changes to the execution environment are required in order to satisfy the senseful, whole, and complete operations of the program. If, without the side effects, some constraint is not satisfied that is required for the program to operate in a standard compliant way, we can say that it <strong>depends on the side effects.</strong></p>\n<p>A simple example to illustrate this would be, as stated in another answer, a lock. A program that uses locks <strong>depends on the side effect of the lock</strong>, notably, the side effect of providing a serialized access pattern to some resource (simplified). If this side effect is violated, the constraints of the program are violated, and thus the program cannot be thought of as senseful (since race conditions or other hazards may occur).</p>\n<p>The program DEPENDS on the constraints that a lock provides, via side effects; violating those results in a program that is invalid.</p>\n<p><strong>Depends on the side effects produced by the destructor</strong></p>\n<p>Changing the language from referring to a lock to a destructor is simple and obvious; if the destructor has side effects which satisfy some constraint that is required by the program to be senseful, whole, complete, and usable, then it depends on the side effects produced by the destructor. This is not exactly difficult to understand, and follows quite readily from both a legalese interpretation of the standard and a cursory layman understanding of the words and how they are used.</p>\n<p>Now we can get into answering your questions:</p>\n<p><strong>Under which condition(s), if any, does this program exhibit Undefined Behavior?</strong></p>\n<p>Any time a dependency or requirement is not fulfilled because a destructor is not called, the behavior of any dependent code is undefined. But what does this really mean?</p>\n<blockquote>\n<p id=\"so_21110059_21286446_3\">1.3.24 \n  unde\ufb01ned behavior<br>\n  behavior for which this International Standard imposes no requirements  </br></p>\n<p id=\"so_21110059_21286446_4\">[ Note: Unde\ufb01ned behavior may be expected when this International Standard omits any explicit de\ufb01nition of\n  behavior or when a program uses an erroneous construct or erroneous data. </p>\n<p id=\"so_21110059_21286446_5\">Permissible unde\ufb01ned behavior\n  ranges from ignoring the situation completely with unpredictable results, to behaving during translation or\n  program execution in a documented manner characteristic of the environment (with or without the issuance of\n  a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</p>\n<p id=\"so_21110059_21286446_6\">Many erroneous program constructs do not engender unde\ufb01ned behavior; they are required to be diagnosed.\n  \u2014 end note ]</p>\n</blockquote>\n<p>Let's suppose for a moment that such behavior WAS defined. </p>\n<p>Suppose it was explicitly illegal. This would then require any standard compiler to detect this case, to diagnose it, to deal with it in some fashion. For example, any object not explicitly deleted would have to be deleted at program exit, requiring some sort of tracking mechanism and ability to issue destructors to arbitrary types, possibly not known at compile time. This is basically a garbage collector, but given it's possibly hide pointers, it's possible to call malloc, etc etc, it would be essentially infeasible to require this. </p>\n<p>Suppose it was explicitly allowed. This would also allow compilers to remove destructor calls, under the as-if rule, since hey, you can't depend on that behavior anyway. This would result in some nasty surprises, mostly related to memory not freeing very quickly or easily. To get around that, we'd all start using finalizers, and the problem arises yet again. Furthermore, allowing that behavior means that no library can be sure when their memory is recovered or if it ever will be, or if their locks, OS dependent resources, etc etc, will ever get returned. This pushes the requirements for clean up from the code using the resources to the code providing it, where it's basically impossible to deal with in a language like C or C++.</p>\n<p>Suppose it had a specific behavior; what behavior would this be? Any such behavior would have to be quite involved or it wouldn't cover the large number of cases. We've already covered two, and the idea of cleaning up for any given object at program exit imposes a large overhead. For a language meant to be fast or at least minimal, this is clearly an unnecessary burden.</p>\n<p>So instead, the behavior was labeled <strong>undefined</strong>, meaning any implementation is free to provide diagnostics, but also free to simply ignore the problem and leave it to you to figure out. <em>But no matter what, if you depend on those constraints being satisfied but fail to call the destructor, you are getting undefined behavior</em>. Even if the program works perfectly well, that behavior is undefined; it may throw an error message in some new version of Clang, it may delete your hard drive in some incredibly secure cryptographic OS of the far flung future, it may work until the end of time.</p>\n<p>But it's still undefined. </p>\n<p><strong>Your Example</strong></p>\n<p>Your example does not satisfy the \"depends on\" clause; no constraint that is required for the program to run is unsatisfied. </p>\n<ol>\n<li>Constructor requires a well formed pointer to a real variable: satisfied</li>\n<li>new requires a properly allocated buffer: satisfied</li>\n<li>printf requires an accessible variable, interpretable as an integer: satisfied</li>\n</ol>\n<p>No where in this program does a certain value for x or a lack of that value result in a constraint being dissatisfied; you are not invoking undefined behavior. Nothing \"depends\" on these side effects; if you were to add a test which functioned as a constraint that required a certain value for \"x\", then it would be undefined behavior.</p>\n<p>As it stands, your example is not undefined behavior; it's merely wrong.</p>\n<p>Finally!</p>\n<p><strong>Is forgetting to call a destructor any different than forgetting to call an ordinary function with the same body?</strong></p>\n<p>It is impossible in many cases to define an ordinary function with the same body:</p>\n<ol>\n<li>A destructor is a member, not an ordinary function</li>\n<li>A function cannot access private or protected values</li>\n<li>A function cannot be required to be called upon destruction</li>\n<li>A finalizer also cannot be required to be called upon destruction</li>\n<li>An ordinary function cannot restore the memory to the OS without calling the destructor</li>\n</ol>\n<p>And no, calling free on an allocated object cannot restore the memory; free/malloc need not work on things allocated with new, and without calling the destructor, the private data members will not be released, resulting in a memory leak. </p>\n<p>Furthermore, forgetting to call a function will not result in undefined behavior if your program depends on the side effects it imposes; those side effects will simply not be imposed, and your program will not satisfy those constraints, and probably not work as intended. Forgetting to call a destructor, however, results in undefined behavior, as stated on page 66:</p>\n<blockquote>\n<p id=\"so_21110059_21286446_7\">For an object of a class type\n  with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage\n  which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a\n  delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and\n  any program that depends on the side e\ufb00ects produced by the destructor has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>As you referenced in your original question. I don't see why you had to ask the question, given you already referenced it, but there you go.</p>\n", "LastActivityDate": "2014-01-22T15:02:36.527", "Score": "3", "CreationDate": "2014-01-22T15:02:36.527", "ParentId": "21110059", "CommentCount": "22", "OwnerUserId": "3137484"}, "21250206": {"Id": "21250206", "PostTypeId": "2", "Body": "<p>This makes sense if you accept that the Standard is <em>requiring</em> allocation to be balanced by destruction in the case where destructors affect program behavior.  I.e. the only plausible interpretation is that if a program</p>\n<ul>\n<li>ever fails to call the destructor (perhaps indirectly through <code>delete</code>) on an object <em>and</em></li>\n<li>said destructor has side-effects,</li>\n</ul>\n<p>then the program is doomed to the land of UB.  (OTOH, if the destructor doesn't affect program behavior, then you are off the hook. You can skip the call.)</p>\n<p><strong>Note added</strong> Side effects are discussed in <a href=\"https://stackoverflow.com/questions/9563600/what-exactly-is-a-side-effect-in-c\">this SO article</a>, and I'll not repeat that here.  A conservative inference is that \"program ... depends on destructor\" is equivalent to \"destructor has a side-effect.\" </p>\n<p><strong>Additional note</strong> However, the Standard seems to allow for a more liberal interpretation. It does not formally define dependence of a program. (It does define a specific quality of expressions as dependence-carrying, but this does not apply here.)  Yet in over 100 uses of derivatives of \"A depends on B\" and \"A has a dependency on B,\" it employs the conventional sense of the word: a variation in B leads directly to variation in A. Consequently, it does not seem a leap to infer that a program P depends on side effect E to the extent that performance or non-performance of E results in a variation in <em>observable behavior during execution of P</em>. Here we are on solid ground. The meaning of a program - its semantics - is equivalent under the Standard to its observable behavior during execution, and this is clearly defined.  </p>\n<blockquote>\n<p id=\"so_21110059_21250206_0\">The least requirements on a conforming implementation are:</p>\n<ul>\n<li><p id=\"so_21110059_21250206_1\">Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</p></li>\n<li><p id=\"so_21110059_21250206_2\">At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.</p></li>\n<li><p id=\"so_21110059_21250206_3\">The input and output dynamics of interactive devices shall take place in such a fashion that\n  prompting output is actually delivered before a program waits for input. What constitutes an\n  interactive device is implementation-defined.</p></li>\n</ul>\n<p id=\"so_21110059_21250206_4\">These collectively are referred to as the observable behavior of the program.</p>\n</blockquote>\n<p><em><strong>Thus, by the Standard's conventions, if a destructor's side effect would ultimately affect volatile storage access, input, or output, and that destructor is never called, the program has UB.</strong></em></p>\n<p>Put yet another way: If your destructors do significant things and aren't consistently called, your program (says the Standard) ought to be considered, and is hereby declared, useless.</p>\n<p>Is this overly restrictive, nay pedantic, for a language standard?  (After all, the Standard <em>prevents</em> the side-effect from occurring due to an implicit destructor call and then drubs you if the destructor <em>would have</em> caused a variation in observable behavior if it <em>had been</em> called!) Perhaps so. But it does make sense as a way to insist on well-formed programs.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-22T04:05:30.117", "Score": "5", "CreationDate": "2014-01-21T05:54:35.373", "ParentId": "21110059", "CommentCount": "6", "LastEditDate": "2017-05-23T11:46:02.187", "OwnerUserId": "1161878"}, "21112028": {"Id": "21112028", "PostTypeId": "2", "Body": "<p>In the comments you've left a simple question that made me rethink what I said. I've removed the old answer because even if it had some value, it was far from the point.</p>\n<blockquote>\n<p id=\"so_21110059_21112028_0\">So you're saying my code is well-defined, since it \"doesn't depend on that even if I print it\"? No undefined behavior here? </p>\n</blockquote>\n<p>Let me say again that I don't precisely remember the definition of placement new operator and deallocation rules. Actually, I've not even read the newest C++ standard in full. But if the text you quoted is from there, then you are hitting the UB.</p>\n<p>Not due to Rand or Print. Or anything we \"see\".</p>\n<p>Any UB that occurs here is because your code assumes that you can safely \"overwrite\" an old 'object' without destroying the previous instance that was sitting at that place. The core sideeffect of a destructor is not \"freeing handles/resources\" (which you do manually in your code!) but leaving the space \"ready for being reclaimed/reused\".</p>\n<p>You have assumed that the usage of the memory chunks and lifetimes of objects are not well-tracked. I'm pretty sure that the C++ standard <strong>does not define</strong> that they <strong>are untracked</strong>.</p>\n<p>For example, imagine that you have the same code as provided, but that this struct/class has a <code>vtable</code>. Imagine that you are using hyper-picky compiler which has tons of debugchecks that manages the vtable with extra care and allocates some extra bitflag and that injects code into base constructors and destructors that flips that flag to help to trace errors. On such compiler, this code would crash on the line of <code>new (r) MakeRandom</code> since first object's lifetime has not been terminated. And I'm pretty sure that such picky compiler would still be fully C++ compliant, just as your compiler surely is too.</p>\n<p>It's an UB. It's only that most compilers really don't do such checks.</p>\n", "LastActivityDate": "2014-01-14T11:08:24.480", "Score": "2", "CreationDate": "2014-01-14T11:08:24.480", "ParentId": "21110059", "CommentCount": "11", "OwnerUserId": "717732"}, "21110059": {"ViewCount": "1278", "Body": "<p><em>Note:</em> I've seen similar questions, but none of the answers are precise enough, so I'm asking this myself.</p>\n<h3><em>This is a very nitpicky \"language-lawyer\" question; I'm looking for an authoritative answer.</em></h3>\n<p>The C++ standard says:</p>\n<blockquote>\n<p id=\"so_21110059_21110059_0\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; <em>however, if there is no explicit call to the destructor or if a delete-expression is not used to release the storage, the destructor shall not be implicitly called <strong>and any program that depends on the side effects produced by the destructor has unde\ufb01ned behavior</strong></em></p></blockquote>.\n\n<p>I simply <em>do not understand</em> what <em>\"depends on the side effects\"</em> means.</p>\n<p>The general question is:</p>\n<h3>Is forgetting to call a destructor any different than forgetting to call an ordinary function with the same body?</h3>\n<p>A specific example to illustrate my point is:</p>\n<p>Consider a program like this below. Also consider the obvious variations (e.g. what if I <em>don't</em> construct an object on top of another one but I still forget to call the destructor, what if I <em>don't</em> print the output to observe it, etc.):</p>\n<pre><code>#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n\nstruct MakeRandom\n{\n    int *p;\n    MakeRandom(int *p) : p(p) { *p = rand(); }\n    ~MakeRandom() { *p ^= rand(); }\n};\n\nint main()\n{\n    srand((unsigned) time(NULL));        // Set a random seed... not so important\n    // In C++11 we could use std::random_xyz instead, that's not the point\n\n    int x = 0;\n    MakeRandom *r = new MakeRandom(&amp;x);  // Oops, forgot to call the destructor\n    new (r) MakeRandom(&amp;x);              // Heck, I'll make another object on top\n    r-&gt;~MakeRandom();                    // I'll remember to destroy this one!\n    printf(\"%d\", x);                     // ... so is this undefined behavior!?!\n    // If it's indeed UB: now what if I didn't print anything?\n}\n</code></pre>\n<p>It seems ridiculous to me to say this exhibits \"undefined behavior\", because <code>x</code> is already random -- and therefore XORing it another random number cannot really make the program more \"undefined\" than before, can it?</p>\n<p>Furthermore, at what point is it correct to say the program \"depends\" on the destructor? Does it do so if the value was random -- or in general, if there is no way for me to distinguish the destructor from running vs. not running? What if I never read the value? Basically:</p>\n<h3>Under which condition(s), if any, does this program exhibit Undefined Behavior?</h3>\n<p>Exactly which expression(s) or statement(s) cause this, and why?</p>\n", "Title": "Observable behavior and undefined behavior -- What happens if I don't call a destructor?", "CreationDate": "2014-01-14T09:35:07.857", "LastActivityDate": "2014-06-10T13:37:46.113", "CommentCount": "15", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-01-14T10:38:14.253", "LastEditorUserId": "541686", "Id": "21110059", "Score": "23", "OwnerUserId": "541686", "Tags": "<c++><destructor><language-lawyer><undefined-behavior>", "AnswerCount": "12"}, "21114296": {"Id": "21114296", "PostTypeId": "2", "Body": "<p>This is indeed not a very well defined thing in the standard, but I would interpret \"depends on\" as meaning \"the behavior under the rules of the abstract machine is affected\".</p>\n<p>This behavior consists of the sequence of reads and writes to volatile variables and the calls to library I/O functions (which includes at least the I/O functions of the standard library like <code>printf</code>, but may also include any number of additional functions in any given implementation, e.g. WinAPI functions). See 1.9/9 for the exact wording.</p>\n<p>So the behavior is undefined if execution of the destructor or lack thereof affects this behavior. In your example, whether the destructor is executed or not affects the value of <code>x</code>, but that store is dead anyway, since the next constructor call overwrites it, so the compiler could actually optimize it away (and chances are, it will). But more importantly, the call to <code>rand()</code> affects the internal state of the RNG, which influences the values returned by <code>rand()</code> in the other object's constructor and destructor, so it does affect the final value of <code>x</code>. It's \"random\" (pseudo-random) either way, but it would be a different value. Then you print <code>x</code>, turning that modification into observable behavior, thus making the program undefined.</p>\n<p>If you never did anything observable with <code>x</code> or the RNG state, the observable behavior would be unchanged independent of whether the destructor is called or not, so it wouldn't be undefined.</p>\n", "LastActivityDate": "2014-01-14T13:04:24.263", "Score": "4", "CreationDate": "2014-01-14T13:04:24.263", "ParentId": "21110059", "CommentCount": "2", "OwnerUserId": "8922"}});