post_cb({"44948166": {"ParentId": "44947510", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Unfortunately there is no standard way to tell <code>stable_sort</code> to do the in-place sort.  In C++14 the only options we have </p>\n<pre><code>template&lt;class RandomAccessIterator&gt;\nvoid stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate&lt;class RandomAccessIterator, class Compare&gt;\nvoid stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n</code></pre>\n<p>C++17 added versions that allow the execution policy as you point out but those will not affect the decision either.  If we look at the complexity requirement in [stable.sort] we get</p>\n<blockquote>\n<p id=\"so_44947510_44948166_0\"><em>Complexity</em>: It does at most <code>N log\u00b2(N)</code> (where <code>N == last - first</code>) comparisons; if enough extra memory is available, it is <code>N log(N).</code></p>\n</blockquote>\n<p>So it is mandated to use more memory if it is available.</p>\n<p>You're either going to have to write your own and you can see <a href=\"//cs.stackexchange.com/q/2569\">Worst case O(<em>n</em>ln<em>n</em>)O(<em>n</em>ln\u2061<em>n</em>) in place stable sort?</a> about that or find a library that provides the function for you.</p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "4850040", "LastEditDate": "2017-07-06T15:24:00.983", "Id": "44948166", "Score": "7", "CreationDate": "2017-07-06T11:54:16.703", "LastActivityDate": "2017-07-06T15:24:00.983"}, "44947510": {"CommentCount": "11", "AcceptedAnswerId": "44947803", "PostTypeId": "1", "LastEditorUserId": "4515030", "CreationDate": "2017-07-06T11:22:26.717", "LastActivityDate": "2017-07-06T18:46:43.817", "LastEditDate": "2017-07-06T18:46:43.817", "ViewCount": "801", "FavoriteCount": "1", "Title": "std::stable_sort: How to choose memory-optimised algorithm over time-optimised algorithm?", "Id": "44947510", "Score": "17", "Body": "<p>I wish to make use of <code>std::stable_sort</code>. The complexity of the algorithm is stated as </p>\n<blockquote>\n<p id=\"so_44947510_44947510_0\">O(N\u00b7log^2(N)), where N = std::distance(first, last) applications of cmp. If additional memory is available, then the complexity is O(N\u00b7log(N)). <a href=\"http://en.cppreference.com/w/cpp/algorithm/stable_sort\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/algorithm/stable_sort</a></p>\n</blockquote>\n<p>In my application, memory is critical, therefore, I would prefer <code>std::stable_sort</code> to use the memory-optimised O(N\u00b7log^2(N))\nalgorithm, rather than the time-optimised O(N\u00b7log(N)) algorithm. \nI understand that the time-optimised version will only be chosen if it is safe\nto do so (memory available). However, I aim to benchmark my application, and therefore, as memory is critical, want to benchmark the algorithm when memory consumption is lowest. As my system currently has enough memory to allocate\nthe buffer, it will automatically chose the O(N\u00b7log^2(N)) version of <code>std::stable_sort</code>. I would therefore like to assert to <code>std::stable_sort</code> to \ntake the memory-optimised version. Is this possible?</p>\n<p>The execution policy appears\nto be a parameter that can modify the algorithm, however, it appears\nto only alter the extent of parallelism.\n<a href=\"http://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t</a></p>\n<p>Although choosing either\nthe parallel or sequential version may actually be choosing the O(N\u00b7log(N)) or\nO(N\u00b7log^2(N)) versions respectively, this is not stated anywhere on the webpage.</p>\n<p>I wonder if anyone has any experience in asserting this choice. If so\nwould they be able to provide any advice?</p>\n", "Tags": "<c++><sorting><std><c++1z><stable-sort>", "OwnerUserId": "4515030", "AnswerCount": "2"}, "44947803": {"ParentId": "44947510", "CommentCount": "7", "Body": "<p>You can look into your headers and see which function gets called if the extra buffer isn't available. For me on gcc it is</p>\n<pre><code>    std::__inplace_stable_sort(__first, __last, __comp);\n</code></pre>\n<p>This is of course not standards compliant. The __inplace_stable_sort is a helper function and is not intended to be used directly.</p>\n<p>The call by std::stable_sort to this function is a result of the following code</p>\n<pre><code>typedef _Temporary_buffer&lt;_RandomAccessIterator, _ValueType&gt; _TmpBuf;\n  _TmpBuf __buf(__first, __last);\n\n  if (__buf.begin() == 0)\nstd::__inplace_stable_sort(__first, __last, __comp);\n  else\nstd::__stable_sort_adaptive(__first, __last, __buf.begin(),\n                _DistanceType(__buf.size()), __comp);\n</code></pre>\n", "OwnerUserId": "451600", "PostTypeId": "2", "Id": "44947803", "Score": "14", "CreationDate": "2017-07-06T11:37:46.230", "LastActivityDate": "2017-07-06T11:37:46.230"}, "bq_ids": {"n4140": {"so_44947510_44948166_0": {"section_id": 1405, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_44947510_44948166_0": {"section_id": 1399, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_44947510_44948166_0": {"section_id": 1523, "quality": 0.6153846153846154, "length": 8}}}});