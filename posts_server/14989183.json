post_cb({"14989183": {"CommentCount": "8", "CreationDate": "2013-02-20T20:22:06.893", "PostTypeId": "1", "AcceptedAnswerId": "14989347", "LastEditorUserId": "391104", "LastActivityDate": "2013-02-20T20:56:59.827", "LastEditDate": "2013-02-20T20:33:06.140", "ViewCount": "115", "FavoriteCount": "1", "Title": "why not crash after the temporary object is destroyed", "Id": "14989183", "Score": "3", "Body": "<pre><code>class C\n{\npublic:\n    int True(int i) const\n    {\n        return i+2;\n    }\n};\n\n\nconst C&amp; F(const C&amp; c)\n{\n    return c;\n}\n\nint main()\n{ \n    const C&amp; c = F(C());                             // Line 1\n    cout &lt;&lt; boolalpha &lt;&lt; c.True(1) &lt;&lt; endl;          // Line 2\n}\n</code></pre>\n<p>Question&gt; why the above code can print the value correct?\nI assume the variable <code>c</code> will refer to an invalid temporary <code>C</code> object when it hits line 2.</p>\n<p>// Update</p>\n<p>I would like to update this OP to illustrate the reason why I am concern on this question.</p>\n<p>Here is code snippet from C++ Templates: The Complete Guide</p>\n<pre><code>// maximum of two values of any type \ntemplate &lt;typename T&gt; \ninline T const&amp; max (T const&amp; a, T const&amp; b) \n{ \n    return a &lt; b ? b : a; \n} \n</code></pre>\n<p>As you can see the function return reference to the pass-in parameter.\nI just wonder why not the following version instead:</p>\n<pre><code>// maximum of two values of any type \ntemplate &lt;typename T&gt; \ninline T max (T const&amp; a, T const&amp; b) \n{ \n    return a &lt; b ? b : a; \n} \n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "391104", "AnswerCount": "4"}, "14989477": {"ParentId": "14989183", "LastEditDate": "2017-05-23T11:49:18.723", "CommentCount": "3", "CreationDate": "2013-02-20T20:39:36.247", "OwnerUserId": "185171", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "14989477", "Score": "2", "Body": "<p>This invokes undefined behaviour. As soon as the full expression involving <code>F(C())</code> completes, the temporary created by <code>C()</code> is destroyed, so the reference returned by <code>F</code> is no longer valid. </p>\n<p>However, undefined behaviour does not guarantee your program will crash. In more annoying cases (like this) it simply causes subtle, hard to diagnose bugs. As for why this undefined behaviour gives you this specific result, I refer you to this <a href=\"https://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope/6445794#6445794\">famous answer</a>.</p>\n", "LastActivityDate": "2013-02-20T20:39:36.247"}, "14989472": {"ParentId": "14989183", "CommentCount": "0", "Body": "<p>Paragraph 12.2/4 of the C++11 Standard specifies that <em>in some situations</em> the lifetime of temporaries can indeed be extended beyond the end of the full expression in which they are generated:</p>\n<blockquote>\n<p id=\"so_14989183_14989472_0\">There are <strong>two contexts</strong> in which temporaries are destroyed at a different point than the end of the full expression. [...]</p>\n</blockquote>\n<p>The first context is not relevant. However, per Paragraph 12.2/5:</p>\n<blockquote>\n<p id=\"so_14989183_14989472_1\">The second context is when a reference is bound to a temporary. <strong>The temporary to which the reference is bound</strong> or the temporary that is the complete object of a subobject to which the reference is bound <strong>persists for the lifetime of the reference <em>except</em></strong>:</p>\n<p id=\"so_14989183_14989472_2\">\u2014 A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits.</p>\n<p id=\"so_14989183_14989472_3\">\u2014 <strong>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</strong></p>\n<p id=\"so_14989183_14989472_4\">\u2014 The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not extended; the temporary is destroyed at the end of the full-expression in the return statement. </p>\n<p id=\"so_14989183_14989472_5\">\u2014 A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the full-expression containing the new-initializer.</p>\n</blockquote>\n<p>Here, the temporary constructed with <code>C()</code> is bound to the argument <code>c</code> of function <code>F</code>. Therefore, the temporary is destroyed at the end of the full-expression which contains the call to function <code>F()</code>, and the returned reference is <em>dangling</em>. </p>\n<p>Invoking function <code>True()</code> on it causes <strong>Undefined Behavior</strong>.</p>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "14989472", "Score": "5", "CreationDate": "2013-02-20T20:39:15.873", "LastActivityDate": "2013-02-20T20:39:15.873"}, "14989623": {"ParentId": "14989183", "LastEditDate": "2013-02-20T20:56:59.827", "CommentCount": "0", "CreationDate": "2013-02-20T20:47:47.693", "OwnerUserId": "1527", "LastEditorUserId": "1527", "PostTypeId": "2", "Id": "14989623", "Score": "1", "Body": "<p>What you are seeing is undefined behaviour. It is fairly likely that, since the function you call does not depend on the object's state or vtable at all, the compiler inlined it to <code>cout &lt;&lt; boolalpha &lt;&lt; ( 1+2 );</code>, so it does not matter whether or not the object has been destroyed - in fact, the compiler may not have even bothered to create it in the first place. </p>\n<p>For example, with VS2010, in 'Debug' it calls <code>F</code> and <code>True</code> as static calls. As <code>True</code> does not reference <code>this</code> the code in it happens to work fine. ( it may even still work even if it did, as there are no member variables in <code>C</code> to access, so the only thing it could do would be to print out the address of <code>this</code>, and that would just be an address on the stack. If <code>C</code> had member variables which were altered by <code>C</code>'s destructor and <code>True</code> used them, then you would see a difference - in all cases, the behaviour is undefined and just an artefact of the implementation )</p>\n<p>In 'Release' VS2010 does not bother to create any <code>C</code> object or call <code>F</code> or <code>True</code> - it simply calls <code>cout &lt;&lt; boolalpha &lt;&lt; 3</code>, having determined the value of <code>C::True(2)</code> at compile time. There is no temporary <code>C</code> object, invalid or not, in the program the compiler generates.</p>\n<p>So just because calling a function on an object appears to work, it does not imply that the object exists, or ever existed, in the program generated by the compiler. A different source program with different undefined behaviour may cause the compiler to generate a executable which raises an access violation, or exhibit some other behaviour.</p>\n<hr>\n<p>The binding a return value to const reference only applies to return by value, not returning a reference to a parameter or local, otherwise the compiler would need to solve the halting problem to determine the lifecycle of objects.</p>\n<p>For example, this code:</p>\n<pre><code>#include&lt;iostream&gt;\n\nclass C\n{\npublic:\n    int t;\n    C( int t ) : t(t){}\n    ~C() { std::cout &lt;&lt; __FUNCTION__ &lt;&lt; \" \" &lt;&lt; t &lt;&lt; std::endl; }\n};\n\nconst C&amp; F(const C&amp; c)\n{\n    return c;\n}\nconst C&amp; G()\n{\n    return C(2);\n}\nC H()\n{\n    return C(3);\n}\n\nint main()\n{\n    const C&amp; c = F(C(1));\n    std::cout &lt;&lt; \"main 1\" &lt;&lt; std::endl;\n    const C&amp; d = G();    \n    std::cout &lt;&lt; \"main 2\" &lt;&lt; std::endl;\n    const C&amp; e = H();    \n    std::cout &lt;&lt; \"main 3\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>results in this output - only <code>H()</code> returns by value, so only the 3rd C has its lifecycle extended:</p>\n<pre><code>C::~C 1\nmain 1\nC::~C 2\nmain 2\nmain 3\nC::~C 3\n</code></pre>\n</hr>", "LastActivityDate": "2013-02-20T20:56:59.827"}, "bq_ids": {"n4140": {"so_14989183_14989472_5": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_14989183_14989472_3": {"section_id": 382, "quality": 0.9230769230769231, "length": 12}, "so_14989183_14989472_1": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_14989183_14989472_0": {"section_id": 381, "quality": 0.8181818181818182, "length": 9}, "so_14989183_14989472_2": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_14989183_14989472_4": {"section_id": 382, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_14989183_14989472_5": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_14989183_14989472_3": {"section_id": 373, "quality": 0.9230769230769231, "length": 12}, "so_14989183_14989472_1": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_14989183_14989472_0": {"section_id": 372, "quality": 0.8181818181818182, "length": 9}, "so_14989183_14989472_2": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_14989183_14989472_4": {"section_id": 373, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_14989183_14989472_0": {"section_id": 396, "quality": 0.7272727272727273, "length": 8}, "so_14989183_14989472_4": {"section_id": 397, "quality": 0.8823529411764706, "length": 15}, "so_14989183_14989472_5": {"section_id": 397, "quality": 0.9090909090909091, "length": 10}, "so_14989183_14989472_3": {"section_id": 397, "quality": 0.9230769230769231, "length": 12}, "so_14989183_14989472_1": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}}}, "14989347": {"ParentId": "14989183", "LastEditDate": "2013-02-20T20:38:27.483", "CommentCount": "1", "CreationDate": "2013-02-20T20:31:51.180", "OwnerUserId": "582", "LastEditorUserId": "582", "PostTypeId": "2", "Id": "14989347", "Score": "3", "Body": "<p>Normally, when a temporary is bound to a const reference, the lifetime of the temporary is extended to the lifetime of the reference. Thus if your code said <code>const C&amp; c = C()</code> then the temporary would live as long as <code>c</code> does.</p>\n<p>However, you're passing the temporary to another function <code>F()</code>. In this case, \u00a712.2.5 of the C++11 spec dictates that the temporary will persist until the completion of the full-expression containing the call.</p>\n<p>Therefore, when you say <code>const C&amp; c = F(C())</code>, the temporary <code>C()</code> is actually destructed at the end of this statement, and is no longer valid on the next line.</p>\n<p>That said, your code appears to function properly because the call to <code>c.True()</code> is known at compile-time, and the function definition doesn't actually refer to any data in <code>c</code>, so the fact that the temporary is dead doesn't really affect the observed behavior. However this is technically undefined behavior.</p>\n", "LastActivityDate": "2013-02-20T20:38:27.483"}});