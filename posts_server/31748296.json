post_cb({"31749381": {"ParentId": "31748296", "LastEditDate": "2015-07-31T15:28:12.133", "CommentCount": "3", "CreationDate": "2015-07-31T15:01:44.777", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "PostTypeId": "2", "Id": "31749381", "Score": "1", "Body": "<p>Attempting to convert a floating point number greater than <code>INT_MAX</code> to an <code>int</code> is <strong>undefined behaviour</strong>:</p>\n<blockquote>\n<p id=\"so_31748296_31749381_0\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be\n  represented in the destination type. (\u00a74.9 [conv.fpint], para. 1)</p>\n</blockquote>\n<p>So a compiler can produce any value (or even do something else, like throw an exception) for the conversion. Different compilers can do different things. The same compiler can do different things at different times.</p>\n<p>There is no real point attempting to understand why a particular instance of undefined behaviour shows the result it shows (unless you are trying to reverse engineer the compiler, and even then UB is not usually particularly interesting). Rather, you need to concentrate on <em>avoiding</em> undefined behaviour.</p>\n<p>For example, since any out-of-range cast of a floating value to an integer is undefined, you need to ensure that such casts do not involve out-of-range values. Unlike some other languages [note 1], the C++ standard does not provide an easily-recognizable result which can be tested for, so you need to test before doing the cast.</p>\n<hr>\n<p>Note that <code>DBL_MAX</code> is a macro, whose substitution is a string representing an approximation of the largest representable floating point number. <code>std::numeric_limits&lt;double&gt;::max()</code>, on the other hand, is the precise largest representable floating point number.</p>\n<p>The difference should not normally be noticeable, but (as indicated by a note in the standard in \u00a75.20 [expr.const], para 6):</p>\n<blockquote>\n<p id=\"so_31748296_31749381_1\">Since this International Standard imposes no restrictions on the accuracy of floating-point operations, it is unspecified whether the evaluation of a floating-point expression during translation yields the same result as the evaluation of the same expression (or the same operations on the same values) during program execution.</p>\n</blockquote>\n<p>Although <code>std::numeric_limits&lt;double&gt;::max()</code> is declared a <code>constexpr</code>, the cast to <code>int</code> is <em>not</em> a constant expression (as per \u00a75.20/p2.5) precisely because its behaviour is undefined.</p>\n<hr>\n<h3>Notes</h3>\n<ol>\n<li>In Java, for example, the conversion is well defined. See the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3\" rel=\"nofollow\">Java Language Specification</a> for details.</li>\n</ol>\n</hr></hr>", "LastActivityDate": "2015-07-31T15:28:12.133"}, "31748296": {"CommentCount": "4", "ViewCount": "184", "PostTypeId": "1", "LastEditorUserId": "1879192", "CreationDate": "2015-07-31T14:12:56.997", "LastActivityDate": "2015-07-31T16:30:16.267", "Title": "results from convert DBL_MAX to int is different from std::numeric_limits<double>::max() to int", "LastEditDate": "2015-07-31T16:30:16.267", "Id": "31748296", "Score": "0", "Body": "<p>While doing a conversion test I encounter some strange behavior in C++.</p>\n<h2>Context</h2>\n<p>The online C++ reference indicates that the return value of <code>std::numeric_limits&lt;double&gt;::max()</code> (defined in <code>limit.h</code>) should be <code>DBL_MAX</code> (defined in <code>float.h</code>). In my test, when I print these values out, both are indeed exactly the same. However, when I cast them from <code>double</code> to <code>int</code>, strange things came out.</p>\n<h2>'Same' input, different results?</h2>\n<p><code>int32_t t1 = (int) std::numeric_limits&lt;double&gt;::max();</code> sets <code>t1</code> to <code>INT_MIN</code>, but <code>int32_t t2 = (int) DBL_MAX;</code> sets <code>t2</code> to <code>INT_MAX</code>. The same is true when the cast is done using <code>static_cast&lt;int&gt;</code>.</p>\n<h2>'Same' input, same results in similar situation</h2>\n<p>However, if I define a function</p>\n<pre><code>int32_t doubleToInt(double dvalue) {\n    return (int) value;\n}\n</code></pre>\n<p>both <code>doubleToInt(std::numeric_limits&lt;double&gt;::max())</code> and <code>doubleToInt(DBL_MAX)</code> return <code>INT_MIN</code>.</p>\n<p>To help make sense of things, I implemented a similar program in Java. There, all casts returned the value of <code>INT_MAX</code>, regardless of being in a function or not.</p>\n<p>Can someone point out the reason why in C++ the result is <code>INT_MIN</code> in some cases, and <code>INT_MAX</code> in the others? What should the expected behaviour be like when casting <code>DBL_MAX</code> to <code>int</code> in C++?</p>\n<h2>Sample Code for C++</h2>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;float.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T, typename D&gt; D cast(T a, D b) { return (D) a;}\n\nint main()\n{\n    int32_t t1 = 9;\n    std::cout &lt;&lt; std::numeric_limits&lt;double&gt;::max() &lt;&lt; std::endl;\n    std::cout &lt;&lt; DBL_MAX &lt;&lt; std::endl;\n    std::cout &lt;&lt; (int32_t) std::numeric_limits&lt;double&gt;::max() &lt;&lt; std::endl;\n    std::cout &lt;&lt; (int32_t) DBL_MAX &lt;&lt; std::endl;\n    std::cout &lt;&lt; cast(std::numeric_limits&lt;double&gt;::max(), t1) &lt;&lt; std::endl;\n    std::cout &lt;&lt; cast(DBL_MAX, t1) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>For completeness: I am using cygwin gcc and java 8.</p>\n", "Tags": "<c++><casting><type-conversion><double><max>", "OwnerUserId": "2573685", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31748296_31749381_0": {"section_id": 37, "quality": 0.8461538461538461, "length": 22}, "so_31748296_31749381_1": {"section_id": 6188, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_31748296_31749381_0": {"section_id": 34, "quality": 0.8461538461538461, "length": 22}, "so_31748296_31749381_1": {"section_id": 5948, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_31748296_31749381_0": {"section_id": 37, "quality": 0.7692307692307693, "length": 20}, "so_31748296_31749381_1": {"section_id": 7691, "quality": 0.9629629629629629, "length": 26}}}});