post_cb({"3890047": {"CommentCount": "0", "AcceptedAnswerId": "3890362", "PostTypeId": "1", "LastEditorUserId": "51305", "CreationDate": "2010-10-08T11:32:34.807", "LastActivityDate": "2011-11-23T11:50:30.057", "LastEditDate": "2010-10-08T11:38:17.383", "ViewCount": "1587", "FavoriteCount": "7", "Title": "Why is std::type_info polymorphic?", "Id": "3890047", "Score": "16", "Body": "<p>Is there a reason why <code>std::type_info</code> is specified to be polymorphic? The destructor is specified to be virtual (and there's a comment to the effect of \"so that it's polymorphic\" in The Design and Evolution of C++). I can't really see a compelling reason why. I don't have any specific use case, I was just wondering if there ever was a rationale or story behind it.</p>\n<hr>\n<p>Here's some ideas that I've come up with and rejected:</p>\n<ol>\n<li>It's an extensibility point - implementations might define subclasses, and programs might then try to <code>dynamic_cast</code> a <code>std::type_info</code> to another, implementation-defined derived type. This is possibly the reason, but it seems that it's just as easy for implementations to add an implementation-defined member, which could possibly be virtual. Programs wishing to test for these extensions would necessarily be non-portable anyway.</li>\n<li>It's to ensure that derived types are destroyed properly when <code>delete</code>ing a base pointer. But there are no standard derived types, users can't define useful derived types, because <code>type_info</code> has no standard public constructors, and so <code>delete</code>ing a <code>type_info</code> pointer is never both legal and portable. And the derived types aren't useful because they can't be constructed - the only use I know for such non-constructible derived types is in the implementation of things like the <code>is_polymorphic</code> type trait.</li>\n<li>It leaves open the possibility of metaclasses with customized types - each real polymorphic <code>class A</code> would get a derived \"metaclass\" <code>A__type_info</code>, which derives from <code>type_info</code>. Perhaps such derived classes could expose members that call <code>new A</code> with various constructor arguments in a type-safe way, and things like that. But making <code>type_info</code> polymorphic itself actually makes such an idea basically impossible to implement, because you'd have to have metaclasses for your metaclasses, ad infinitum, which is a problem if all the <code>type_info</code> objects have static storage duration. Maybe barring this is the reason for making it polymorphic.</li>\n<li>There's some use for applying RTTI features (other than <code>dynamic_cast</code>) to <code>std::type_info</code> itself, or someone thought that it was cute, or embarrassing if <code>type_info</code> wasn't polymorphic. But given that there's no standard derived type, and no other classes in the standard hierarchy which one might reasonably try cross-cast to, the question is: what? Is there a use for expressions such as <code>typeid(std::type_info) == typeid(typeid(A))</code>?</li>\n<li>It's because implementers will create their own private derived type (as I believe GCC does). But, why bother specifying it? Even if the destructor wasn't specified as virtual and an implementer decided that it should be, surely that implementation could declare it virtual, because it doesn't change the set of allowed operations on <code>type_info</code>, so a portable program wouldn't be able to tell the difference.</li>\n<li>It's something to do with compilers with partially compatible ABIs coexisting, possibly as a result of dynamic linking. Perhaps implementers could recognize their own <code>type_info</code> subclass (as opposed to one originating from another vendor) in a portable way if <code>type_info</code> was guaranteed to be virtual.</li>\n</ol>\n<p>The last one is the most plausible to me at the moment, but it's pretty weak.</p>\n</hr>", "Tags": "<c++><polymorphism><rtti><typeinfo>", "OwnerUserId": "51305", "AnswerCount": "4"}, "3890441": {"ParentId": "3890047", "CommentCount": "1", "Body": "<p>About the simplest \"global\" id you can have in C++ is a class name,and <code>typeinfo</code> provides a way to compare such id's for equality. But the design is so awkward and limited that you then need to wrap <code>typeinfo</code> in some wrapper class, e.g. to be able to put instances in collections. Andrei Alexandrescu did that in his \"Modern C++ Design\" and I think that that <code>typeinfo</code> wrapper is part of the Loki library; there's probably one also in Boost; and it's pretty easy to roll your own, e.g. see <a href=\"http://alfps.wordpress.com/2010/06/15/cppx-unique-identifier-values-via-stdtype_info/\" rel=\"nofollow\">my own wrapper</a>.</p>\n<p>But even for such a wrapper there's not in general any need for a virtual destructor in <code>typeinfo</code>.</p>\n<p>The question is therefore not so much \"huh, why is there a virtual destructor\" but rather, as I see it, \"huh, why is the design so backward, awkward and not directly usable\"? And I'd put that down to the standardization process. For example, iostreams are not exactly examples of superb design, either; not something to emulate.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "3890441", "Score": "2", "CreationDate": "2010-10-08T12:28:16.497", "LastActivityDate": "2010-10-08T12:28:16.497"}, "8241701": {"ParentId": "3890047", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3890047_8241701_0\">3/ It leaves open the possibility of metaclasses with customized types - each real polymorphic <code>class A</code> would get a derived \"metaclass\" <code>A__type_info</code>, which derives from <code>type_info</code>. Perhaps such derived classes could expose members that call <code>new A</code> with various constructor arguments in a type-safe way, and things like that. But making <code>type_info</code> polymorphic itself actually makes such an idea basically impossible to implement, because you'd have to have metaclasses for your metaclasses, ad infinitum, which is a problem if all the <code>type_info</code> objects have static storage duration. Maybe barring this is the reason for making it polymorphic.</p>\n</blockquote>\n<p>Clever... </p>\n<p>Anyway, I disagree with this reasoning: such implementation could easily rule-out meta classes for types derived from <code>type_info</code>, including <code>type_info</code> itself.</p>\n", "OwnerUserId": "963864", "PostTypeId": "2", "Id": "8241701", "Score": "2", "CreationDate": "2011-11-23T11:50:30.057", "LastActivityDate": "2011-11-23T11:50:30.057"}, "3890097": {"ParentId": "3890047", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The C++ standard says that <code>typeid</code> returns an object of type type_info, OR AN IMPLEMENTATION-DEFINED subclass thereof. So... I guess this is pretty much the answer. So I don't see why you reject your points 1 and 2.</p>\n<p>Paragraph 5.2.8 Clause 1 of the current C++ standard reads: </p>\n<blockquote>\n<p id=\"so_3890047_3890097_0\">The result of a typeid expression is an\n  lvalue of static type const\n  std::type_info (18.5.1) and dynamic\n  type const std::type_info or const\n  name where name is an\n  implementation-defined class derived\n  from std::type_info which preserves\n  the behavior described in 18.5.1.61)\n  The lifetime of the object referred to\n  by the lvalue extends to the end of\n  the program. Whether or not the\n  destructor is called for the type_info\n  object at the end of the program is\n  unspecified.</p>\n</blockquote>\n<p>Which in turn means that one could write the following code is legal and fine:\n<code>const type_info&amp; x = typeid(expr);</code> which may require that type_info be polymorphic</p>\n", "OwnerUserId": "469935", "LastEditorUserId": "469935", "LastEditDate": "2010-10-08T12:43:10.427", "Id": "3890097", "Score": "9", "CreationDate": "2010-10-08T11:40:21.757", "LastActivityDate": "2010-10-08T12:43:10.427"}, "3890362": {"ParentId": "3890047", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I assume it's there for the convenience of implementers. It allows them to define extended <code>type_info</code> classes, and delete them through pointers to <code>type_info</code> at program exit, without having to build in special compiler magic to call the correct destructor, or otherwise jump through hoops.</p>\n<blockquote>\n<p id=\"so_3890047_3890362_0\">surely that implementation could\n  declare it virtual, because it doesn't\n  change the set of allowed operations\n  on type_info, so a portable program\n  wouldn't be able to tell the\n  difference.</p>\n</blockquote>\n<p>I don't think that's true. Consider the following:</p>\n<pre><code>#include &lt;typeinfo&gt;\n\nstruct A {\n    int x;\n};\n\nstruct B {\n    int x;\n};\n\nint main() {\n    const A *a1 = dynamic_cast&lt;const A*&gt;(&amp;typeid(int));\n    B b;\n    const A *a2 = dynamic_cast&lt;const A*&gt;(&amp;b);\n}\n</code></pre>\n<p>Whether it's <em>reasonable</em> or not, the first dynamic cast is allowed (and evaluates to a null pointer), whereas the second dynamic cast is not allowed. So, if <code>type_info</code> was defined in the standard to have the default non-virtual destructor, but an implementation added a virtual destructor, then a portable program could tell the difference[*].</p>\n<p>Seems simpler to me to put the virtual destructor in the standard, than to either:</p>\n<p>a) put a note in the standard that, although the class definition implies that <code>type_info</code> has no virtual functions, it is permitted to have a virtual destructor.</p>\n<p>b) determine the set of programs which can distinguish whether <code>type_info</code> is polymorphic or not, and ban them all. They may not be very useful or productive programs, I don't know, but to ban them you have to come up with some standard language that describes the specific exception you're making to the normal rules.</p>\n<p>Therefore I think that the standard has to either mandate the virtual destructor, or ban it. Making it optional is too complex (or perhaps I should say, I think it would be judged unnecessarily complex. Complexity never stopped the standards committee in areas where it was considered worthwhile...)</p>\n<p>If it was banned, though, then an implementation could:</p>\n<ul>\n<li>add a virtual destructor to some derived class of <code>type_info</code></li>\n<li>derive all of its typeinfo objects from <em>that</em> class</li>\n<li>use that internally as the polymorphic base class for everything</li>\n</ul>\n<p>that would solve the situation I described at the top of the post, <em>but</em> the static type of a <code>typeid</code> expression would still be <code>const std::type_info</code>, so it would be difficult for implementations to define extensions where programs can <code>dynamic_cast</code> to various targets to see what kind of <code>type_info</code> object they have in a particular case. Perhaps the standard hoped to allow that, although an implementation could always offer a variant of <code>typeid</code> with a different static type, or guarantee that a <code>static_cast</code> to a certain extension class will work, and then let the program <code>dynamic_cast</code> from there.</p>\n<p>In summary, as far as I know the virtual destructor is potentially useful to implementers, and removing it doesn't gain anyone anything other than that we wouldn't be spending time wondering why it's there ;-)</p>\n<p>[*] Actually, I haven't demonstrated that. I've demonstrated that an illegal program would, all else being equal, compile. But an implementation could perhaps work around that by ensuring that all isn't equal, and that it doesn't compile. Boost's <code>is_polymorphic</code> isn't portable, so while it's possible for a program to test that a class <em>is</em> polymorphic, that should be, there may be no way for a conforming program to test that a class <em>isn't</em> polymorphic, that shouldn't be. I think though that even if it's impossible, proving that, in order to remove one line from the standard, is quite a lot of effort.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-10-08T12:49:13.940", "Id": "3890362", "Score": "9", "CreationDate": "2010-10-08T12:18:18.053", "LastActivityDate": "2010-10-08T12:49:13.940"}, "bq_ids": {"n4140": {"so_3890047_3890097_0": {"section_id": 6020, "quality": 0.775, "length": 31}}, "n3337": {"so_3890047_3890097_0": {"section_id": 5788, "quality": 0.775, "length": 31}}, "n4659": {"so_3890047_3890097_0": {"section_id": 7519, "quality": 0.8, "length": 32}}}});