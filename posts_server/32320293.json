post_cb({"32320293": {"CommentCount": "12", "AcceptedAnswerId": "34536235", "PostTypeId": "1", "LastEditorUserId": "4958516", "CreationDate": "2015-08-31T21:30:50.877", "LastActivityDate": "2015-12-31T18:00:52.850", "LastEditDate": "2015-12-29T15:11:35.017", "ViewCount": "638", "FavoriteCount": "2", "Title": "Matching of class template partial specializations", "Id": "32320293", "Score": "14", "Body": "<p>N4527 14.5.5.1[temp.class.spec.match]</p>\n<blockquote>\n<p id=\"so_32320293_32320293_0\">2 A partial specialization matches a given actual template argument list if the template arguments of the partial specialization can be deduced from the actual template argument list.</p>\n<pre><code>template&lt;class T1, class T2, int I&gt; class A             { }; // #1\ntemplate&lt;class T, int I&gt;            class A&lt;T, T*, I&gt;   { }; // #2\ntemplate&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; { }; // #3\ntemplate&lt;class T&gt;                   class A&lt;int, T*, 5&gt; { }; // #4\ntemplate&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; { }; // #5\n\nA&lt;int, int, 1&gt;   a1; // uses #1\nA&lt;int, int*, 1&gt;  a2; // uses #2, T is int, I is 1\nA&lt;int, char*, 5&gt; a3; // uses #4, T is char\nA&lt;int, char*, 1&gt; a4; // uses #5, T1 is int, T2 is char, I is 1\nA&lt;int*, int*, 2&gt; a5; // ambiguous: matches #3 and #5\n</code></pre>\n<p id=\"so_32320293_32320293_1\">3 A non-type template argument can also be deduced from the value of an actual template argument of a non-type parameter of the primary template. [ Example: the declaration of <code>a2</code> above. \u2014end example ]</p>\n<p id=\"so_32320293_32320293_2\">4 In a type name that refers to a class template specialization, (e.g., <code>A&lt;int, int, 1&gt;</code>) the argument list shall\n  match the template parameter list of the primary template. The template arguments of a specialization are\n  deduced from the arguments of the primary template.</p>\n</blockquote>\n<p>In rule3, the example shows <code>I</code> is deduced from the third actual template argument <code>1</code>, this is what the rule2 says. So as the second sentence of rule4, I think it is repeating what rule2 says.</p>\n<p>What are the differences between them(rule2, rule3 and rule4)?</p>\n<p>Another words, we already have rule2, what are the intents(meaning) of rule3 and the second sentence of rule4, why they are here? </p>\n", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "4958516", "AnswerCount": "2"}, "34510257": {"ParentId": "32320293", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The differences between rule two and rule four is the second and third template parameter. In example three:</p>\n<p><code>A&lt;int, char*, 5&gt; a3; // uses #4, T is char</code></p>\n<p>It uses rule4 because the third parameter clearly specializes to a const int 5, and the second parameter is specialized to accept a pointer type; its a unique specialization of <code>class A</code>.</p>\n<p>I look at each specialization as a specific species of the class, and each specie has a unique signature (similar to overloading functions).  The compiler is going to choose the specialization that matches the signature being used.  </p>\n<p>Rule three only makes sense without rule five, so after removing rule five, the intent of rule three would be to specialize any typenames of <code>class A</code> that:\n<code>\na) do not use a const int 5 for the third parameter \nb) do not use a pointer or as the second parameter \nc) do not use a `int` in the second parameter.\n</code></p>\n<p>Since non of your examples use the unique signature of rule3, non of them use rule3 (given we remove the ambiguous rule5).</p>\n<p>This could be better to understand if you only look at the <code>template&lt;...&gt;</code> scheme of the specialization, and not the signature <code>&lt;&gt;</code> of the specialization. The compiler is looking at the template scheme before looking at the specialization. Also, all other specializations of <code>class A</code> define the rules for any new specialization. To understand the intentions of a specialization, you have to understand the intentions of all the other specializations, and intention of a specialization is not defined by the standard, its defined by whoever implemented the specialization; ie. implementation details of the specialization truly define the intent.</p>\n", "OwnerUserId": "230194", "LastEditorUserId": "230194", "LastEditDate": "2015-12-29T12:49:53.113", "Id": "34510257", "Score": "2", "CreationDate": "2015-12-29T11:40:35.553", "LastActivityDate": "2015-12-29T12:49:53.113"}, "34536235": {"ParentId": "32320293", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I think, the rule <strong>[temp.class.spec.match] 14.5.5.1\\2</strong> may be rewritten like this without changing its purport:</p>\n<p><strong>[temp.class.spec.match] 14.5.5.1\\2 (modified)</strong></p>\n<blockquote>\n<p id=\"so_32320293_34536235_0\">A partial specialization matches a given actual template argument list\n  if the template arguments of the partial specialization can be deduced\n  from the actual template argument list according to 14.8.2.5, where P\n  is the argument list of the partial specialization from its\n  <em>simple-template-id</em> and A is the actual template argument list.</p>\n</blockquote>\n<p>The rule <strong>[temp.deduct.type] 14.8.2.5\\1</strong> defines the process for deducing from types (I am not sure about templates though) only, so there is a need for the rule <strong>[temp.class.spec.match] 14.5.5.1\\3</strong>, which adds to <strong>14.5.5.1\\2</strong> cases with non-type template parameters of the primary template, which are not (partially) specialized in the partial specialization.</p>\n<p>The rule <strong>[temp.class.spec.match] 14.5.5.1\\4</strong>, as you noted in the comments above (<a href=\"https://stackoverflow.com/questions/32320293/matching-of-class-template-partial-specializations#comment52529222_32320293\">1</a>, <a href=\"https://stackoverflow.com/questions/32320293/matching-of-class-template-partial-specializations#comment56831331_32320293\">2</a>), is just the clarification, that template arguments in the <em>template-id</em> corresponds to template parameters of the primary template, not its partial specializations, which may have different <em>template-parameter-list</em> s. Moreover, the second sentence of the rule most likely claims that the implicit template argument list of the primary template (<strong>14.5.5\\4</strong>) is deduced (!) according to <strong>[temp.deduct.type] 14.8.2.5\\9</strong> from the actual argument list. So the phrases \"implicit template argument list of the primary template\" and \"the template arguments of a specialization\" imply one selfsame thing, and the phrases \"the arguments of the primary template\" and \"the actual template argument list\" imply another selfsame thing... But it also may be that authors intended to write this:</p>\n<p><strong>[temp.class.spec.match] 14.5.5.1\\4 (modified)</strong></p>\n<blockquote id=\"so_32320293_34536235_1\">\nIn a type name that refers to a class template specialization the argument list shall match the template parameter list of the primary template. The template arguments of a partial specialization are deduced from the arguments of the primary template.\n</blockquote>\n<p>Whatever...</p>\n", "OwnerUserId": "5181494", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:06:51.347", "Id": "34536235", "Score": "2", "CreationDate": "2015-12-30T19:49:06.433", "LastActivityDate": "2015-12-31T18:00:52.850"}, "bq_ids": {"n4140": {"so_32320293_34536235_0": {"section_id": 144, "quality": 0.5806451612903226, "length": 18}, "so_32320293_32320293_0": {"section_id": 144, "quality": 1.0, "length": 18}, "so_32320293_32320293_1": {"section_id": 145, "quality": 0.8421052631578947, "length": 16}, "so_32320293_34536235_1": {"section_id": 146, "quality": 0.9130434782608695, "length": 21}, "so_32320293_32320293_2": {"section_id": 146, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_32320293_34536235_0": {"section_id": 138, "quality": 0.5806451612903226, "length": 18}, "so_32320293_32320293_0": {"section_id": 138, "quality": 1.0, "length": 18}, "so_32320293_32320293_1": {"section_id": 139, "quality": 0.8421052631578947, "length": 16}, "so_32320293_34536235_1": {"section_id": 140, "quality": 0.9130434782608695, "length": 21}, "so_32320293_32320293_2": {"section_id": 140, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_32320293_34536235_0": {"section_id": 148, "quality": 0.5806451612903226, "length": 18}, "so_32320293_32320293_0": {"section_id": 148, "quality": 1.0, "length": 18}, "so_32320293_32320293_2": {"section_id": 150, "quality": 0.9583333333333334, "length": 23}, "so_32320293_34536235_1": {"section_id": 150, "quality": 0.9130434782608695, "length": 21}}}});