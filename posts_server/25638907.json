post_cb({"25638907": {"CommentCount": "5", "ViewCount": "132", "PostTypeId": "1", "LastEditorUserId": "809384", "CreationDate": "2014-09-03T07:43:55.923", "LastActivityDate": "2014-09-03T08:52:26.567", "Title": "Is rethrowing an exception from catch block which has an nested exception okay?", "AcceptedAnswerId": "25640101", "LastEditDate": "2014-09-03T08:17:55.737", "Id": "25638907", "Score": "0", "Body": "<p>The idea is \"try <code>you()</code>, if it fails try <code>_do()</code>, if it fails report the exception from the first try, i.e., <code>you()</code>\".</p>\n<pre><code>void that_thing() {\n    try {\n        you();\n    } catch( ... ) {\n        bool error=false;\n        try {\n            _do();\n        } catch( ... ) {\n            error = true;\n        }\n        if( error ) throw;\n    }\n}\n</code></pre>\n<p>Testing with Gcc it worked fine, I was wondering if it will work with any compiler. Just to be clearer, the weird behavior I was expecting was that the <code>throw;</code> would rethrow the inner exception.</p>\n<p>Edit: This question is NOT about the inner most <code>catch</code>, it is about rethrowing the outer exception after catching the inner most. The question is if this kind of rethrowing is legally definitely was not approached on the question that are being pointed as similar.</p>\n", "Tags": "<c++><exception-handling>", "OwnerUserId": "809384", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25638907_25640101_2": {"section_id": 3341, "quality": 0.8571428571428571, "length": 6}, "so_25638907_25640101_6": {"section_id": 3353, "quality": 0.8333333333333334, "length": 10}, "so_25638907_25640101_5": {"section_id": 3352, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_25638907_25640101_2": {"section_id": 3211, "quality": 0.8571428571428571, "length": 6}, "so_25638907_25640101_6": {"section_id": 3223, "quality": 0.8333333333333334, "length": 10}, "so_25638907_25640101_5": {"section_id": 3222, "quality": 1.0, "length": 24}}, "n4659": {"so_25638907_25640101_2": {"section_id": 7673, "quality": 0.8571428571428571, "length": 6}, "so_25638907_25640101_6": {"section_id": 4120, "quality": 0.8333333333333334, "length": 10}, "so_25638907_25640101_5": {"section_id": 4119, "quality": 0.625, "length": 15}}}, "25640101": {"ParentId": "25638907", "CommentCount": "0", "Body": "<p>The standard requires implementations to properly nest exceptions. To quote from the standard:</p>\n<blockquote>\n<p id=\"so_25638907_25640101_0\"><strong>15.1 Throwing an exception [except.throw]</strong></p>\n<p id=\"so_25638907_25640101_1\">...</p>\n<p id=\"so_25638907_25640101_2\">8 A <em>throw-expression</em> with no operand rethrows the currently handled exception (15.3).</p>\n<p id=\"so_25638907_25640101_3\"><strong>15.3 Handling an exception [except.handle]</strong></p>\n<p id=\"so_25638907_25640101_4\">...</p>\n<p id=\"so_25638907_25640101_5\">7 A handler is considered active when initialization is complete for the formal parameter (if any) of the catch clause. ... A handler is no longer considered active when the catch clause exits or when <code>std::unexpected()</code> exits after being entered due to a throw.</p>\n<p id=\"so_25638907_25640101_6\">8 The exception with the most recently activated handler that is still active is called the <em>currently handled exception</em>.</p>\n</blockquote>\n<p>When your code reaches the <code>throw;</code>, the inner exception handler is no longer active: the catch clause has exited. The outer exception handler is still active: it has not yet exited, and <code>std::unexpected()</code> has not been called. Therefore, implementations must support this usage, and re-throw the outer exception. A global \"current exception\" pointer that gets cleared after the inner handler exits would not match the requirements of the C++ standard.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "25640101", "Score": "4", "CreationDate": "2014-09-03T08:52:26.567", "LastActivityDate": "2014-09-03T08:52:26.567"}});