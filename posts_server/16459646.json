post_cb({"16459747": {"ParentId": "16459646", "LastEditDate": "2013-05-09T10:53:47.310", "CommentCount": "10", "CreationDate": "2013-05-09T10:35:15.733", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "PostTypeId": "2", "Id": "16459747", "Score": "6", "Body": "<blockquote>\n<p id=\"so_16459646_16459747_0\">I read that protected members are private in derived classes, so it seems to be ok, but it isnt.</p>\n</blockquote>\n<p>It is not because a <code>protected</code> data member inherited from a base class <code>A</code> (<code>root</code>, in this case) by a derived class <code>B</code> (<code>aa</code>, in this case) is accessible <em>as long as it is being accessed on an object of type <code>B</code></em> (<code>aa</code>). Here, you are accessing it through an object of type <code>A</code> (<code>root</code>):</p>\n<pre><code>root* aa::add(const root&amp; a)\n{\n    for (int i=0; i&lt;a.size; i++)\n    //              ^^^^^^\n    //              Accessing size on an object of type `root`, not `aa`!\n        array[i] += a.array[i];\n    return *this;\n}\n</code></pre>\n<p>Per paragraph 11.4/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16459646_16459747_1\">An additional access check beyond those described earlier in Clause 11 is applied when a non-static data\n  member or non-static member function is a protected member of its naming class (11.2). <strong>As described\n  earlier, access to a protected member is granted because the reference occurs in a friend or member of some\n  class C</strong>. If the access is to form a pointer to member (5.3.1), the nested-name-specifier shall denote C or a\n  class derived from C. <strong>All other accesses involve a (possibly implicit) object expression (5.2.5). In this case,\n  the class of the object expression shall be C or a class derived from C.</strong> [<em>Example:</em></p>\n<pre><code>class B {\nprotected:\n    int i;\n    static int j;\n};\nclass D1 : public B {\n};\nclass D2 : public B {\n    // ...\n    void mem(B*,D1*);\n};\n\nvoid D2::mem(B* pb, D1* p1) {\n    pb-&gt;i = 1; // ill-formed\n    p1-&gt;i = 2; // ill-formed\n    // ...\n    i = 3; // OK (access through this)\n    B::i = 4; // OK (access through this, qualification ignored)\n    j = 5; // OK (because j refers to static member)\n    B::j = 6; // OK (because B::j refers to static member)\n}\n</code></pre>\n<p id=\"so_16459646_16459747_2\"><em>\u2014 end example</em> ]</p>\n</blockquote>\n<p>To fix this, you need to provide public setters/getters. You already have a <code>getSize()</code> function, so instead of writing this:</p>\n<pre><code>for (int i=0; i&lt;a.size; i++)\n//              ^^^^^^\n</code></pre>\n<p>You could write this:</p>\n<pre><code>for (int i=0; i&lt;a.getSize(); i++)\n//              ^^^^^^^^^^^\n</code></pre>\n<p>Similarly, you will have to provide functions for getting/setting the value of the n-th element of <code>array</code>, so that you could write:</p>\n<pre><code>array[i] += a.get_at(i);\n</code></pre>\n<p>Notice, that the expression on the left side of <code>+=</code> is OK, because <code>array</code> is being accessed through <code>this</code> (see also the above example from the C++11 Standard).</p>\n", "LastActivityDate": "2013-05-09T10:53:47.310"}, "16459646": {"CommentCount": "0", "ViewCount": "8291", "CreationDate": "2013-05-09T10:29:31.233", "LastActivityDate": "2013-05-09T10:53:47.310", "Title": "Can't access protected member in base class from derived class", "AcceptedAnswerId": "16459747", "PostTypeId": "1", "Id": "16459646", "Score": "6", "Body": "<p>Heres my code :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;sstream&gt;\nusing namespace std;\n\nclass root\n{\n    protected :\n\n            int size;\n            double *array;\n\n    public :\n\n        virtual ~root() {}\n        virtual root* add(const root&amp;) = 0;\n        virtual root* sub(const root&amp;) = 0;\n        virtual istream&amp; in(istream&amp;, root&amp;) = 0;\n        virtual int getSize() const = 0;\n        virtual void setSize(int);\n};\n\nclass aa: public root\n{\n\n    public :\n\n        aa();\n        aa(int);\n        aa(const aa&amp;);\n        root* add(const root&amp; a);\n        root* sub(const root&amp; a);\n        istream&amp; in(istream&amp;, root&amp;){}\n        int getSize() const;\n        void setSize(int);\n};\n\nclass bb: public root\n{\npublic:\n    bb() { }\n    bb(const bb&amp; b) { }\n    root* add(const root&amp; a);\n    root* sub(const root&amp; a);\n    istream&amp; in(istream&amp;, root&amp;){}\n    int getSize() const{}\n    void setSize(int){}\n};\n\naa::aa()\n{\n    size = 0;\n    array = NULL;\n}\n\naa::aa(int nsize)\n{\n    size = nsize;\n    array = new double[size+1];\n    for(int i=0; i&lt;size; i++)\n        array[i] = 0;\n}\n\nroot* aa::add(const root&amp; a)\n{\n    for (int i=0; i&lt;a.size; i++)\n        array[i] += a.array[i];\n    return *this;\n}\n\nroot* aa::sub(const root&amp; a)\n{\n}\n\nint aa::getSize() const\n{\n    return size;\n}\n\nvoid aa::setSize(int nsize)\n{\n    size = nsize;\n    array = new double[size+1];\n    for(int i=0; i&lt;size; i++)\n        array[i] = 0;\n}\n\nroot* bb::add(const root&amp; a)\n{\n    return new bb();\n}\n\nroot* bb::sub(const root&amp; a)\n{\n\n}\n\nint main(int argc, char **argv)\n{\n}\n</code></pre>\n<p>When I want to access <code>size</code> or an <code>array</code> in derived class, I just cant because my compiler says:</p>\n<pre><code>/home/brian/Desktop/Temp/Untitled2.cpp||In member function \u2018virtual root* aa::add(const root&amp;)\u2019:|\n/home/brian/Desktop/Temp/Untitled2.cpp|10|error: \u2018int root::size\u2019 is protected|\n/home/brian/Desktop/Temp/Untitled2.cpp|66|error: within this context|\n/home/brian/Desktop/Temp/Untitled2.cpp|11|error: \u2018double* root::array\u2019 is protected|\n/home/brian/Desktop/Temp/Untitled2.cpp|67|error: within this context|\n/home/brian/Desktop/Temp/Untitled2.cpp|68|error: cannot convert \u2018aa\u2019 to \u2018root*\u2019 in return|\n||=== Build finished: 5 errors, 0 warnings ===|\n</code></pre>\n<p>I read that protected members are private in derived classes, so it seems to be ok, but it isnt. How to fix this?</p>\n", "Tags": "<c++><public><protected><inheritance>", "OwnerUserId": "1376444", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16459646_16459747_0": {"section_id": 6678, "quality": 0.5555555555555556, "length": 5}, "so_16459646_16459747_1": {"section_id": 6695, "quality": 0.9333333333333333, "length": 56}}, "n3337": {"so_16459646_16459747_0": {"section_id": 6433, "quality": 0.5555555555555556, "length": 5}, "so_16459646_16459747_1": {"section_id": 6450, "quality": 0.9333333333333333, "length": 56}}, "n4659": {"so_16459646_16459747_0": {"section_id": 8153, "quality": 0.5555555555555556, "length": 5}, "so_16459646_16459747_1": {"section_id": 8170, "quality": 0.9333333333333333, "length": 56}}}});