post_cb({"7923624": {"CommentCount": "0", "ViewCount": "1855", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2011-10-27T23:27:35.847", "LastActivityDate": "2011-10-28T04:03:49.667", "Title": "When and how are static data initialized in C++?", "LastEditDate": "2011-10-27T23:52:20.827", "Id": "7923624", "Score": "2", "Body": "<p>When are static data initialized ? </p>\n<p>I think: </p>\n<p>It can be initialized by\nconstructor, </p>\n<p>or</p>\n<p>when it is declared, </p>\n<p>or\noutside of the class by </p>\n<pre><code>class A::member_d = 5; //  member_d is static  \n</code></pre>\n<p>others ? </p>\n<p>Also, When do file scope static variables initialized and when do function scope static variables initizliaed?</p>\n<p>I think they are initialized when they are declared. </p>\n<p>thanks</p>\n", "Tags": "<c++><class><static><constructor><initialization>", "OwnerUserId": "1002288", "AnswerCount": "4"}, "7925027": {"ParentId": "7923624", "CommentCount": "0", "Body": "<h2>Static Storage duration object initialization:</h2>\n<p>Note: Static member objects are initialized the same way as objects at file scope.</p>\n<ul>\n<li>Objects at file scope are initialized at point of definition.\n<ul>\n<li>You can think of these as all being initialized before main() is called.</li>\n<li>See details below. </li>\n</ul></li>\n<li>Objects in function scope are initialized the first time execution passes over the definition.\n<ul>\n<li>ie Usually the first time the function is called.</li>\n</ul></li>\n</ul>\n<p>The object is initialized by the initializer in the definition. if you do not provide an initializer then it will be zero-initialized.</p>\n<pre><code>int x1;        // zero initialized.\nint x2 = 5;    // initialized with 5 \nA   y1;        // Default initialized:\n               // If A has a user defined constructor this is called.\n               // If A has a compiler generated constructor then\n               // it is value-initialized which means class objects have their\n               // default constructor called and POD objects are zero-initialized\nA   y2 = A();  // Default constructed.\nA   y3(5);     // Constructor called with value 5.\n</code></pre>\n<p>Static members are exactly the same as objects as file scope.</p>\n<pre><code>class Z\n{\n    static int x1; // declaration;\n    static int x2;\n    static A   y1;\n    static A   y2;\n    static A   y3;\n};\n// definition\n\nint Z::x1;\nint Z::x2 = 5;\nA   Z::y1;\nA   Z::y2 = A();\nA   Z::y3(5);\n</code></pre>\n<p>Now the order that they are initialized is harder to define. The order is deliberately left vague to allow for compiler and linker situations that the committee could not foresee. </p>\n<p>It is defined in:</p>\n<h2>3.6.2 Initialization of non-local variables</h2>\n<p>The main thing to note is:</p>\n<blockquote>\n<p id=\"so_7923624_7925027_0\">Non-local variables with static storage duration are initialized as a consequence of program initiation.</p>\n</blockquote>\n<p>So in most situations they will all be fully constructed before main is entered.</p>\n<p>As noted by others. The compiler is allowed to delay initialization.</p>\n<h3>3.6.2 Paragraph 4</h3>\n<blockquote>\n<p id=\"so_7923624_7925027_1\">It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of main.</p>\n</blockquote>\n<p>This addition is mainly done to support dynamically loading libraries at runtime (which may by laded dynamically after main has started). But it does provide a simple guarantee that all static storage duration objects within a compilation until will be fully constructed before any objects or function in that compilation are used.</p>\n<h3>3.6.2 Paragraph 5</h3>\n<blockquote>\n<p id=\"so_7923624_7925027_2\">If the initialization is deferred to some point in time after the first statement of the initial function of the thread, it shall occur before the first odr-use (3.2) of any variable with thread storage duration defined in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n", "OwnerUserId": "14065", "PostTypeId": "2", "Id": "7925027", "Score": "2", "CreationDate": "2011-10-28T04:03:49.667", "LastActivityDate": "2011-10-28T04:03:49.667"}, "7923680": {"ParentId": "7923624", "CommentCount": "0", "Body": "<p>No, of course, the constructor can't initialize static data members. For const integral or enumeration types, you can initialize within the scope of the class definition. However, in general, you must initialize outside the class  definition.</p>\n", "OwnerUserId": "73007", "PostTypeId": "2", "Id": "7923680", "Score": "0", "CreationDate": "2011-10-27T23:36:21.413", "LastActivityDate": "2011-10-27T23:36:21.413"}, "7923641": {"ParentId": "7923624", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Static members of a class are initialized at the point of definition. Const integral data types are an exception that can be initialized at the point of declaration. When such initialization is going to be executed is somewhat complicated (google for <em>static initialization fiasco</em>). According to the standard:</p>\n<blockquote>\n<p id=\"so_7923624_7923641_0\">If the initialization is deferred to some point in time after the first statement of main, it shall occur before the first odr-use of any function or variable defined in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n", "OwnerUserId": "927034", "LastEditorUserId": "927034", "LastEditDate": "2011-10-28T00:21:27.623", "Id": "7923641", "Score": "4", "CreationDate": "2011-10-27T23:30:56.883", "LastActivityDate": "2011-10-28T00:21:27.623"}, "bq_ids": {"n4140": {"so_7923624_7925027_0": {"section_id": 7150, "quality": 1.0, "length": 8}, "so_7923624_7925027_2": {"section_id": 7154, "quality": 1.0, "length": 25}, "so_7923624_7923641_0": {"section_id": 7153, "quality": 1.0, "length": 21}, "so_7923624_7925027_1": {"section_id": 7153, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_7923624_7925027_0": {"section_id": 6894, "quality": 1.0, "length": 8}, "so_7923624_7925027_2": {"section_id": 6898, "quality": 1.0, "length": 25}, "so_7923624_7923641_0": {"section_id": 6897, "quality": 1.0, "length": 21}, "so_7923624_7925027_1": {"section_id": 6897, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_7923624_7925027_0": {"section_id": 8651, "quality": 0.75, "length": 6}, "so_7923624_7925027_2": {"section_id": 8659, "quality": 0.76, "length": 19}, "so_7923624_7923641_0": {"section_id": 8657, "quality": 0.6666666666666666, "length": 14}, "so_7923624_7925027_1": {"section_id": 8657, "quality": 0.8571428571428571, "length": 12}}}, "7923652": {"ParentId": "7923624", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Global variables are initialized at program start-up, before <code>main()</code> is invoked. Static objects that are local to a scope are initialized the first time execution passes over them.</p>\n<p>Static class members are just global variables, so see above.</p>\n<p>Destruction of global and static objects happens after <code>main()</code> returns.</p>\n<p>(The implementation details of this are fairly intricate, since all the destructors have to be queued up for execution somewhere, and for local statics there needs to be a flag to indicate whether the object has already been instantiated.)</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2011-10-27T23:52:42.883", "Id": "7923652", "Score": "1", "CreationDate": "2011-10-27T23:32:26.693", "LastActivityDate": "2011-10-27T23:52:42.883"}});