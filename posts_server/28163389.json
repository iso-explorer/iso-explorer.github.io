post_cb({"bq_ids": {"n4140": {"so_28163389_28163505_0": {"length": 15, "quality": 0.9375, "section_id": 7067}, "so_28163389_28163389_0": {"length": 25, "quality": 0.7352941176470589, "section_id": 7117}}, "n3337": {"so_28163389_28163505_0": {"length": 15, "quality": 0.9375, "section_id": 6811}, "so_28163389_28163389_0": {"length": 25, "quality": 0.7352941176470589, "section_id": 6861}}, "n4659": {"so_28163389_28163505_0": {"length": 15, "quality": 0.9375, "section_id": 8564}, "so_28163389_28163389_0": {"length": 25, "quality": 0.7352941176470589, "section_id": 8618}}}, "28163505": {"Id": "28163505", "PostTypeId": "2", "Body": "<p>From [basic.scope.namespace] (\u00a73.3.6/1), emphasis mine:</p>\n<blockquote>\n<p id=\"so_28163389_28163505_0\">A namespace\n  member name has namespace scope. Its potential scope includes its namespace from the name\u2019s <strong>point of\n  declaration (3.3.2) onwards</strong></p>\n</blockquote>\n<p><code>a</code> can only be found in <code>namespace A</code> <em>after</em> it is declared. So example (1) is invalid because <code>a</code> hasn't been declared yet and example (2) is valid because it has been. </p>\n", "LastActivityDate": "2015-01-27T04:56:15.330", "CommentCount": "0", "CreationDate": "2015-01-27T04:56:15.330", "ParentId": "28163389", "Score": "2", "OwnerUserId": "2069064"}, "28163389": {"ViewCount": "31", "Body": "<p>I'm interested in a formal couplig between a <code>point of declaration</code> and a <code>name-lookup</code> concepts. In particular, when a <code>nested-name-specifier</code> denoted a namespace, an unqualified name lookup produce a set of declaration as follows: <code>N4296::3.4.3.2 [namespace.qual]</code></p>\n<blockquote>\n<p id=\"so_28163389_28163389_0\">For a namespace <code>X</code> and name <code>m</code>, the namespace-qualified lookup set\n  <code>S(X,m)</code> is defined as follows: Let <code>S0(X,m)</code> be the set of all\n  declarations of <code>m</code> in <code>X</code> and the inline namespace set of <code>X</code> (7.3.1). If\n  <code>S0(X,m)</code> is not empty, <code>S(X,m)</code> is <code>S0(X,m)</code>; otherwise, <code>S(X,m)</code> is the\n  union of <code>S(Ni,m)</code> for all namespaces <code>Ni</code> nominated by using-directives\n  in <code>X</code> and its inline namespace set.</p>\n</blockquote>\n<p>Let me provide a couple examples:</p>\n<p>1.</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace A\n{\n    int b = 42;\n}\n\nint a = A::a; //Error\n\nnamespace A\n{\n    int a = 24;\n}\n\nint main(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/c27a2260df3b916a\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>2.</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace A\n{\n    int b = 42;\n}\n\nnamespace A\n{\n    int a = 24;\n}\n\nint a = A::a; //OK\n\nint main(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/32f7340c4715c0b8\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>The rule I provided has nothing to do with the point of declaration concept, but in fact we can see that it does. So the Standard implicitly assumes that the name's <code>m</code> point of declaration should be before the point where the name is used. I think  it should be specified explicitly. Maybe I lost the clause where it was specified... if so, couldn't you point me out to that one?</p>\n", "AcceptedAnswerId": "28163505", "Title": "Name lookup and point of declaration concepts", "CreationDate": "2015-01-27T04:41:34.650", "Id": "28163389", "CommentCount": "0", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-01-27T04:56:15.330", "Score": "0", "Tags": "<c++><namespaces>", "AnswerCount": "1"}});