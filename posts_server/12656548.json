post_cb({"12656790": {"CommentCount": "18", "CreationDate": "2012-09-29T21:48:08.453", "CommunityOwnedDate": "2012-09-29T23:26:38.190", "LastEditorUserId": "445296", "LastActivityDate": "2016-11-21T09:44:28.597", "ParentId": "12656548", "PostTypeId": "2", "LastEditDate": "2016-11-21T09:44:28.597", "Id": "12656790", "Score": "5", "Body": "<p>NOTE FROM OP: <em>VC++ was buggy. VC++ 2015 accepts the code correctly.</em></p>\n<p>My original answer that the code that VC++ rejected is disallowed in the standard actually was wrong: It is allowed as Johannes Schaub pointed out: in 5.1 [expr.prim.general] paragraph 12 it is described where an <em>id-expression</em> denoting a non-static data member or a non-static member function can be used. In particular, the last bullet states:</p>\n<blockquote>\n<p id=\"so_12656548_12656790_0\">if that id-expression denotes a non-static data member and it appears in an unevaluated operand.</p>\n</blockquote>\n<p>The expression in <code>decltype(expr)</code> is an unevaluated operand. Furthermore, 9.3.1 [class.mfct.non-static] paragraph 3 explains the situation where <code>this</code> is implicitly added to an expression:</p>\n<blockquote>\n<p id=\"so_12656548_12656790_1\">When an id-expression (5.1) that is not part of a class member access syntax (5.2.5) and not used to form a pointer to member (5.3.1) is used in a member of class X in a context where this can be used (5.1.1), if name lookup (3.4) resolves the name in the id-expression to a non-static non-type member of some class C, and if either the id-expression is potentially evaluated or C is X or a base class of X, the id-expression is transformed into a class member access expression (5.2.5) using (*this) (9.3.2) as the postfix-expression to\n  the left of the . operator.</p>\n</blockquote>\n<p>The context in question is not \"potentially evaluated\" and there is no based involved. Thus, <code>this</code> isn't added and doesn't have to be in scope. Taken together, this means that the declaration</p>\n<pre><code>decltype(fwd.rbegin()) begin() const;\n</code></pre>\n<p>should be legal. It seems that using</p>\n<pre><code>decltype(static_cast&lt;Reverser&lt;Fwd&gt; const*&gt;(0)-&gt;fwd.rbegin()) begin() const;\n</code></pre>\n<p>is a work-around in cases where the compiler isn't correctly implemented.</p>\n", "OwnerUserId": "1120273"}, "12656548": {"CommentCount": "8", "AcceptedAnswerId": "12656790", "PostTypeId": "1", "LastEditorUserId": "445296", "CreationDate": "2012-09-29T21:15:43.950", "LastActivityDate": "2016-11-21T09:44:28.597", "LastEditDate": "2016-11-18T03:24:10.347", "ViewCount": "450", "FavoriteCount": "2", "Title": "Why does the compiler want a trailing return-type?", "Id": "12656548", "Score": "5", "Body": "<p>I was playing around with an adapter for using range-based for-loops to iterate in reverse. (I did not know about the boost adapter (\"adaptor\") for that purpose. I am a big believer in not re-inventing the wheel if it's a free wheel I have already downloaded.)</p>\n<p>What puzzles me is why VC++ 2012 is not happy unless I use trailing return-types in the code that follows:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;class Fwd&gt;\nstruct Reverser {\n    const Fwd &amp;fwd;\n    Reverser&lt;Fwd&gt;(const Fwd &amp;fwd_): fwd(fwd_) {}\n    auto begin() -&gt; decltype(fwd.rbegin()) const { return fwd.rbegin(); } \n    auto end() -&gt;   decltype(fwd.rend())   const { return fwd.rend(); } \n};\n\ntemplate&lt;class Fwd&gt;\nReverser&lt;Fwd&gt; reverse(const Fwd &amp;fwd) { return Reverser&lt;Fwd&gt;(fwd); }\n\nint main() {\n    using namespace std;\n    const string str = \".dlrow olleH\";\n    for(char c: reverse(str)) cout &lt;&lt; c;\n    cout &lt;&lt; endl;\n}\n</code></pre>\n<p>When I tried the following, I got the errors, \"error C2100: illegal indirection,\" and \"error C2228: left of '.rbegin' must have class/struct/union\". What am I missing?</p>\n<pre><code>template&lt;class Fwd&gt;\nstruct Reverser {\n    const Fwd &amp;fwd;\n    Reverser&lt;Fwd&gt;(const Fwd &amp;fwd_): fwd(fwd_) {}\n    decltype(fwd.rbegin()) begin() const { return fwd.rbegin(); } \n    decltype(fwd.rend())   end() const { return fwd.rend(); } \n};\n</code></pre>\n<p>UPDATE: In light of the discussion about a \"this\" pointer, I tried another tack. Look Ma, no this! And it compiles fine. I do believe that, rightly or wrongly, VC++ is not aware of that this.</p>\n<pre><code>template&lt;class Fwd&gt;\nstruct Reverser {\n    const Fwd &amp;fwd;\n    Reverser&lt;Fwd&gt;(const Fwd &amp;fwd_): fwd(fwd_) {}\n    decltype(((const Fwd*)0)-&gt;rbegin()) begin() const { return fwd.rbegin(); } \n    decltype(((const Fwd*)0)-&gt;rend())   end()   const { return fwd.rend(); } \n\n};\n</code></pre>\n<p>UPDATE 2: Submitted to MS: <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/765455/vc-2012-compiler-refuses-decltype-return-spec-for-member-function\" rel=\"nofollow noreferrer\">https://connect.microsoft.com/VisualStudio/feedback/details/765455/vc-2012-compiler-refuses-decltype-return-spec-for-member-function</a></p>\n<p>UPDATE 3: This problem is fixed as of VC++ 2015. Thanks, Microsoft person.</p>\n", "Tags": "<c++><visual-c++><for-loop><c++11>", "OwnerUserId": "445296", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_12656548_12656790_0": {"section_id": 5959, "quality": 1.0, "length": 8}, "so_12656548_12656790_1": {"section_id": 5891, "quality": 0.8936170212765957, "length": 42}}, "n3337": {"so_12656548_12656790_0": {"section_id": 5728, "quality": 1.0, "length": 8}, "so_12656548_12656790_1": {"section_id": 5662, "quality": 0.8936170212765957, "length": 42}}, "n4659": {"so_12656548_12656790_0": {"section_id": 7440, "quality": 1.0, "length": 8}, "so_12656548_12656790_1": {"section_id": 7374, "quality": 0.8936170212765957, "length": 42}}}});