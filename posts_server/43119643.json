post_cb({"bq_ids": {"n4140": {"so_43119643_43120923_2": {"length": 31, "quality": 0.96875, "section_id": 6185}, "so_43119643_43120923_1": {"length": 30, "quality": 0.9375, "section_id": 7040}, "so_43119643_43120923_0": {"length": 19, "quality": 1.0, "section_id": 5972}}, "n3337": {"so_43119643_43120923_2": {"length": 22, "quality": 0.6875, "section_id": 5946}, "so_43119643_43120923_0": {"length": 13, "quality": 0.6842105263157895, "section_id": 5740}}, "n4659": {"so_43119643_43120923_2": {"length": 29, "quality": 0.90625, "section_id": 7687}, "so_43119643_43120923_1": {"length": 30, "quality": 0.9375, "section_id": 8537}, "so_43119643_43120923_0": {"length": 19, "quality": 1.0, "section_id": 7471}}}, "43120923": {"Id": "43120923", "PostTypeId": "2", "Body": "<p>This is a VS bug. The code is perfectly well-formed.</p>\n<p>The rule in [expr.prim.lambda] is:</p>\n<blockquote>\n<p id=\"so_43119643_43120923_0\">If a lambda-expression or an instantiation of the function call operator template of a generic lambda <strong>odr-uses</strong> (3.2) this or a variable with automatic storage duration from its reaching scope, that entity shall be captured by the lambda-expression.</p>\n</blockquote>\n<p>Where a variable is odr-used if, according to [basic.def.odr]:</p>\n<blockquote>\n<p id=\"so_43119643_43120923_1\">A variable x whose name appears as a potentially-evaluated expression ex is odr-used by ex <strong>unless applying the lvalue-to-rvalue conversion (4.1) to x yields a constant expression (5.20)</strong> that does not invoke any non-trivial\n  functions and, if x is an object, ex is an element of the set of potential results of an expression e, where either <strong>the lvalue-to-rvalue conversion (4.1) is applied to e</strong>, or e is a discarded-value expression (Clause 5).</p>\n</blockquote>\n<p>And, from [expr.const]:</p>\n<blockquote>\n<p id=\"so_43119643_43120923_2\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions:  [...] an lvalue-to-rvalue conversion (4.1) unless it is applied to a non-volatile glvalue of integral or enumeration type that refers to a complete non-volatile const object with a preceding initialization, initialized with a constant expression</p>\n</blockquote>\n<p>In:</p>\n<pre><code>return item == controlValue;\n</code></pre>\n<p><code>controlValue</code> is a glvalue of integral type that refers to a complete non-volatile const object initialized with a constant expression. Hence, when we use <code>controlValue</code> in a context that involves an lvalue-to-rvalue conversion, it is not odr-used. Since it's not odr-used, we don't need to capture it.</p>\n<p>When you changed <code>controlValue</code> to be <em>non</em>-<code>const</code>, it's ceases to be a constant expression, and the equality check odr-uses it. Since it's not captured but is odr-used, the lambda is ill-formed. </p>\n<hr/>\n<p>Note that exactly such an example appears in the standard:</p>\n<pre><code>void f(int, const int (&amp;)[2] = {}) { }   // #1\nvoid f(const int&amp;, const int (&amp;)[1]) { } // #2\nvoid test() {\n    const int x = 17;\n    auto g = [](auto a) {\n        f(x); // OK: calls #1, does not capture x\n    };\n\n    // ...\n}\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-03-30T19:38:50.503", "Score": "15", "CreationDate": "2017-03-30T14:36:08.220", "ParentId": "43119643", "CommentCount": "2", "LastEditDate": "2017-03-30T19:38:50.503", "OwnerUserId": "2069064"}, "43119643": {"ViewCount": "796", "Body": "<p>I've encountered an interesting case (at least for me) when using lambdas and was wondering whether it is a compiler bug or something allowed by the standard feature.</p>\n<p>Let's cut to the chase. Having sample code:</p>\n<pre><code>const int controlValue = 5;\nstd::vector&lt;int&gt; vect{ 0, 1, 2, 3 };\nconst auto result = std::any_of(vect.begin(), vect.end(), [](const int&amp; item)\n{\n    return item == controlValue;\n});\n</code></pre>\n<p>Notice that <code>controlValue</code> variable is not captured by the lambda expression.\nAdditionally, in the <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow noreferrer\">cppreference</a> for lambda expressions it is stated that <code>[] - captures nothing</code></p>\n<p>Using <strong>VS2015</strong> for compilation of the above code gives an error which is not surprising:</p>\n<pre><code>error C3493: 'controlValue' cannot be implicitly captured because no default capture mode has been specified\n</code></pre>\n<p>However, when using <strong>MinGW</strong> with <em>gcc 4.8.2</em> same example compiles and works.\nSome online compilers including <em>gcc 5.4.0</em>, <em>clang 3.8.0</em> give similar result.</p>\n<p>When <code>controlValue</code> loses its <code>const</code> then all tested compilers give the error all expect (that the variable is not captured which is fine).</p>\n<p>Which of the compilers is standard compliant in this case? \nDoes this mean that some optimizations or other \"hacks\" are used for const variables here? Maybe something is captured implicitly?\nCould anyone explain the situation happening here?</p>\n<p><strong>EDIT:</strong></p>\n<p>Some pointed out that this question is a duplicate of <a href=\"https://stackoverflow.com/questions/13468989/lambda-capturing-constexpr-object\">Lambda capturing constexpr object\n</a>. While the answer there may be somewhat related (points to the odr-use case) the question there is about an error occurring while capturing by ref. The topic here is quite different and focuses on not capturing explicitly a variable at all (although using it in the lambda body).</p>\n<p>After looking through more lambda related questions, if someone's interested, I'd point to <a href=\"https://stackoverflow.com/questions/28763375/using-lambda-captured-constexpr-value-as-an-array-dimension?noredirect=1&amp;lq=1\">Using lambda captured constexpr value as an array dimension\n</a> which (same as @Barry stated) suggests VS2015 bug and shows that setting the <code>controlValue</code> variable in the example here to <code>static</code> fixes the compilation under VS2015.</p>\n", "AcceptedAnswerId": "43120923", "Title": "Lambda expression with empty capture", "CreationDate": "2017-03-30T13:40:22.427", "Id": "43119643", "CommentCount": "9", "LastEditDate": "2017-05-23T12:09:51.667", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-30T21:23:29.667", "Score": "16", "OwnerUserId": "4341198", "Tags": "<c++><c++11><lambda><language-lawyer>", "AnswerCount": "1"}});