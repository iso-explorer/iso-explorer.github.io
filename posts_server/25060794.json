post_cb({"25061207": {"PostTypeId": "2", "Body": "<p>Since both <code>(char*)dest</code> and <code>(char const*)src</code> point to <code>char</code>, the compiler must assume that they might alias.  Plus, there is a rule that says that a pointer to a character type can alias anything.</p>\n<p>All of which is irrelevant for <code>memcpy</code>, since the actual signature is:</p>\n<pre><code>void* memcpy( void* restrict dest, void* restrict src, size_t n );\n</code></pre>\n<p>which tells the compiler that there cannot be aliasing, because the user guarantees it.  You cannot use <code>memcpy</code> to copy overlapping areas without incurring undefined behavior.</p>\n<p>At any rate, there's no problem with the given implementation.</p>\n", "LastActivityDate": "2014-07-31T14:15:46.530", "Id": "25061207", "CommentCount": "2", "CreationDate": "2014-07-31T14:15:46.530", "ParentId": "25060794", "Score": "4", "OwnerUserId": "649665"}, "25060794": {"ViewCount": "736", "Body": "<p>The general answer when asking \"how does one implement memcpy function conformant with strict aliasing rules\" is something along the lines of</p>\n<pre><code>void *memcpy(void *dest, const void *src, size_t n)\n{\n    for (size_t i = 0; i &lt; n; i++)\n        ((char*)dest)[i] = ((const char*)src)[i];\n    return dest;\n}\n</code></pre>\n<p>However, if I understand correctly, compiler is free to reorder call to memcpy and access to the dest, because it can reorder writes to char* with reads from any other pointer type (strict aliasing rules prevent only reordering of reads from char* with writes to any other pointer type).</p>\n<p>Is this correct and if yes, are there any ways to correctly implement memcpy, or should we just rely on builtin memcpy?</p>\n<p>Please note, that this question concerns not only memcpy but any deserialization/decoding function.</p>\n", "AcceptedAnswerId": "25060988", "Title": "Writing memcpy conformant with strict aliasing", "CreationDate": "2014-07-31T13:57:46.860", "Id": "25060794", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-07-31T13:59:39.253", "LastEditorUserId": "1834147", "LastActivityDate": "2016-10-28T15:28:03.343", "Score": "8", "OwnerUserId": "2855276", "Tags": "<c++><c><memcpy><strict-aliasing>", "AnswerCount": "6"}, "40308384": {"PostTypeId": "2", "Body": "<p>If an object has no declared type, any effective type it may acquire will only be effective until the next time the object is modified.  Writing to an object using a pointer of character type counts as modifying it, thus unsetting the old type, but writing it via character-type pointer does not set a new type unless such operation occurs as part of \"copying as an array of character type\", whatever that means.  Objects which have no effective type may be legally read with any type.</p>\n<p>Since the effective-type semantics for \"copying as an array of character type\" would be the same as those for <code>memcpy</code>, a memcpy implementation could be written using character pointers for reading and writing.  It may not set the effective type of the destination the way <code>memcpy</code> would be allowed to, but any behavior which would be defined when using <code>memcpy</code> would be defined identically if the destination were left with no effective type [as IMHO should have been the case with <code>memcpy</code>].</p>\n<p>I'm not sure who came up with the idea that a compiler can assume that storage which has acquired an effective type keeps that effective type when it is modified using a <code>char*</code>, but nothing in the Standard justifies it.  If you need your code to work with gcc, specify that it must be use with the <code>-fno-strict-aliasing</code> flag unless or until gcc starts honoring the Standard.  There's no reason to bend over backward trying to support a compiler whose authors continually seek out new cases to ignore aliasing even in cases where the Standard would require them to recognize it.</p>\n", "LastActivityDate": "2016-10-28T15:28:03.343", "Id": "40308384", "CommentCount": "0", "CreationDate": "2016-10-28T15:28:03.343", "ParentId": "25060794", "Score": "0", "OwnerUserId": "363751"}, "25060988": {"PostTypeId": "2", "Body": "<p>The strict aliasing rule specifically excludes casts to <code>char</code> types (see last bullet point below), so the compiler will do the correct thing in your case. Type punning is only a problem when converting things like <code>int</code> to <code>short</code>. Here the compiler may make assumptions that will cause undefined behavior. </p>\n<p>C99 \u00a76.5/7:</p>\n<blockquote>\n<p id=\"so_25060794_25060988_0\">An object shall have its stored value accessed only by an lvalue expression that has one of the following types:</p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>a quali\ufb01ed version of a type compatible with the effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a quali\ufb01ed version of the effective type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</li>\n<li>a character type. </li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2014-07-31T14:17:14.990", "LastEditorUserId": "19405", "Id": "25060988", "CommentCount": "0", "CreationDate": "2014-07-31T14:06:02.290", "ParentId": "25060794", "Score": "5", "OwnerUserId": "232918", "LastEditDate": "2014-07-31T14:17:14.990"}, "25060912": {"PostTypeId": "2", "Body": "<p>IANALL, but I don't think the compiler is allowed to mess things up in the way you describe.  Strict aliasing is \"implemented\" in the spec by rendering undefined accesses to an object through an illegal pointer type, rather than by specifying another complicated partial order on object accesses.</p>\n", "LastActivityDate": "2014-07-31T14:02:44.457", "Id": "25060912", "CommentCount": "0", "CreationDate": "2014-07-31T14:02:44.457", "ParentId": "25060794", "Score": "1", "OwnerUserId": "1834147"}, "bq_ids": {"n4140": {"so_25060794_25060988_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 7230}}, "n3337": {"so_25060794_25060988_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 6974}}}, "40042568": {"PostTypeId": "2", "Body": "<p>What everyone seems to be missing here, is that strict aliasing (6.5/7) depends on the term <em>effective type</em> (6.5/6). And effective type has explicit, special rules for the function <code>memcpy</code> (6.5/6): </p>\n<blockquote>\n<p id=\"so_25060794_40042568_0\">If a value is copied into an object having no declared type using\n  <code>memcpy</code> or <code>memmove</code>, or is copied as an array of character type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one.</p>\n</blockquote>\n<p>So therefore I don't think it even makes sense to speak of strict aliasing inside the <code>memcpy</code> function. You can only speak of strict aliasing if you know the effective type. Now, how do you determine that, based on the above? Is the internals of <code>memcpy</code> a copy with <code>memcpy</code> or not?</p>\n<p>It's like saying \"in order to understand which effective type that is used in memcpy, you must first understand which effective type that is used in memcpy\". </p>\n<p>So I don't quite see how the question, or any of the answers posted, make any sense.</p>\n", "LastActivityDate": "2016-10-14T11:54:31.247", "Id": "40042568", "CommentCount": "1", "CreationDate": "2016-10-14T11:54:31.247", "ParentId": "25060794", "Score": "1", "OwnerUserId": "584518"}, "25060932": {"PostTypeId": "2", "Body": "<p>Yes, you're missing something. The compiler may to reorder writes to <code>dest</code> and reads to <code>dest</code>. Now, since reads from <code>src</code> happen-before writes to <code>dest</code>, and your hypothethical read from <code>dest</code>happens-after the write to <code>dest</code>, it follows that the read from <code>dest</code> happens-after the read from <code>src</code>. </p>\n", "LastActivityDate": "2014-07-31T14:03:32.660", "Id": "25060932", "CommentCount": "0", "CreationDate": "2014-07-31T14:03:32.660", "ParentId": "25060794", "Score": "0", "OwnerUserId": "15416"}});