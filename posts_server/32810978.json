post_cb({"bq_ids": {"n4140": {"so_32810978_32810978_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 37}}, "n3337": {"so_32810978_32810978_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 34}}, "n4659": {"so_32810978_32810978_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 37}}}, "32835776": {"Id": "32835776", "PostTypeId": "2", "Body": "<p>Let's consider positive integers from  1 to MAX_FLOAT.   For IEEE 754 The exponent represents the power of 2 (it's stored with a bias). \nIEE-754 format  uses 1 sign bit, 8 biased exponent bits and 23 mantissa bits.The mantissa\nis a factional part of the number.  The highest bit is 1/2, the next 1/4, the next 1/8 ... </p>\n<p>Numbers from 1 to 1.999... have the same exponent. There is 1 integer in the range (1)</p>\n<p>Numbers from 2 to 3.999... have the same exponent. There are 2 integers in the range (2,3).\n3 has the highest mantissa bit set so it requires the leading mantissa bit.\nIf any other lower mantissa bits are then its not an integer. Because it's 2 or 3\nplus the the value of the fractional bit.</p>\n<p>Numbers from 4 to 7.999... have the same exponent. There are 4 integers in the range (4,5,6,7)\nThese use the 2 highest mantissa bits. If any other mantissa bits are set then its not an integer.</p>\n<p>Numbers from 8 to 15.999... have the same exponent. There are 8 integers in the range (8,9,10,11,12,13,14,15)\nThese use the 3 highest mantissa bits. If any other mantissa bits are set then its not an integer.</p>\n<p>I hope you can see the pattern as you increase the exponent, the number of possible integers doubles. So ignore the n highest mantissa bits and test if the lower bits are set.  If they are then the number is not an integer.</p>\n<p>This tables shows the constant exponent value 0x40 plus the next highest bit, and  that only the high order mantissa bits are set for integers</p>\n<pre><code>Float    Hex\n4        0x40800000\n5        0x40a00000\n6        0x40c00000\n7        0x40e00000\n</code></pre>\n<p>To convert a float to a UInt32  </p>\n<pre><code>float x  = 7.0;\nUInt32 * px = (UInt32*)&amp;x;\nUInt32    i = *px;\n</code></pre>\n", "LastEditorUserId": "867998", "LastActivityDate": "2015-09-29T04:42:13.130", "Score": "0", "CreationDate": "2015-09-29T04:36:42.383", "ParentId": "32810978", "CommentCount": "1", "LastEditDate": "2015-09-29T04:42:13.130", "OwnerUserId": "867998"}, "32811683": {"Id": "32811683", "PostTypeId": "2", "Body": "<p>Check <code>truncf(x) == x</code>.  (The function is in <code>&lt;math.h&gt;</code>)  This will compare true if and only if <em>x</em> has no fractional part.  Then, compare <em>x</em> to the range of the type.</p>\n<h3>Example Code (Untested)</h3>\n<pre><code>#include &lt;cfenv&gt;\n#include &lt;cmath&gt;\n#pragma STDC FENV_ACCESS on\n\ntemplate&lt;class F, class N&gt; // F is a float type, N integral.\n  bool is_representable(const F x)\n{\n  const int orig_rounding = std::fegetround();\n\n  std::fesetround(FE_TOWARDZERO);\n  const bool to_return = std::trunc(x) == x &amp;&amp;\n                         x &gt;= std::numeric_limits&lt;N&gt;.min() &amp;&amp;\n                         x &lt;= std::numeric_limits&lt;N&gt;.max();\n  std::fesetround(orig_rounding);\n  return to_return;\n}\n</code></pre>\n<p>With rounding set toward zero, the implicit conversion of the minimum and maximum values of the integral type to the floating-point type should not overflow.  On many architectures, including i386, casting to <code>long double</code> will also provide enough precision to exactly represent a 64-bit int.</p>\n", "LastEditorUserId": "4474419", "LastActivityDate": "2015-09-29T01:49:45.220", "Score": "0", "CreationDate": "2015-09-27T18:59:12.153", "ParentId": "32810978", "CommentCount": "3", "LastEditDate": "2015-09-29T01:49:45.220", "OwnerUserId": "4474419"}, "32835261": {"Id": "32835261", "PostTypeId": "2", "Body": "<p>You could use the <code>%a</code> format type specifier in <code>snprintf()</code> to get access to the mantissa and the exponent and you can then work out if the number is an integer or not and if it can fit into an integer type of a specific size. I used this method in a <a href=\"https://stackoverflow.com/a/15197157/968261\">different problem</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-29T03:34:58.707", "Score": "0", "CreationDate": "2015-09-29T03:34:58.707", "ParentId": "32810978", "CommentCount": "0", "LastEditDate": "2017-05-23T11:58:22.647", "OwnerUserId": "968261"}, "32810978": {"ViewCount": "161", "Body": "<p>How do I check whether a <code>float</code> can be represented as an integral type without invoking undefined behavior by just casting? This is forbidden by \u00a74.9.1:</p>\n<blockquote>\n<p id=\"so_32810978_32810978_0\">A prvalue of a floating point type can be converted to a prvalue of an\n  integer type. The conversion truncates; that is, the fractional part\n  is discarded. The behavior is undefined if the truncated value cannot\n  be represented in the destination type,</p>\n</blockquote>\n<p>There's <a href=\"https://stackoverflow.com/questions/8905246/how-to-check-if-float-can-be-exactly-represented-as-an-integer\">this</a> question for C, but the accepted answer clearly causes undefined behavior (first by just plain casting and the later by using the union hack, which makes the whole thing very questionable to me).</p>\n<p>I can see how it'd be hard to have a fully compliant solution, but one that is implementation defined (to assume IEEE-754 floats) would be acceptable too.</p>\n", "Title": "Check if float can be represented as integral type", "CreationDate": "2015-09-27T17:49:53.370", "LastActivityDate": "2015-09-29T04:42:13.130", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:58:22.647", "LastEditorUserId": "-1", "Id": "32810978", "Score": "4", "OwnerUserId": "144746", "Tags": "<c++><undefined-behavior>", "AnswerCount": "3"}});