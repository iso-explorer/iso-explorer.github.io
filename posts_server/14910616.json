post_cb({"43108512": {"Id": "43108512", "PostTypeId": "2", "Body": "<p>As said before pointers to members are not pointers and their conversions to types like int or void * are meaningless in general. In particular the 0x1 most likely means the first or second entry in the vtable of the object.\nLet's consider this code:</p>\n<pre><code>void (*Base::*test)() = &amp;Base::foo\nChild f;\nf.*test();\n</code></pre>\n<p>For the third line the compiler gets the address of f. Converts it to the address of a Base object, which in this case is a NOOP) reads from that address the address of the vtable for f (the vtable is usually the first data item in an object), then adds two that address 1*sizeof(void*) and calls the function at that address largely something equivalent to this C :</p>\n<pre><code>typedef void (*FnPtr)();\nFnPtr *vtable=*(FnPtr **)&amp;(Base &amp;)f;\n(*(vtable[(int)test]))(); or (*(vtable[(int)test - 1]))();\n</code></pre>\n<p>This is only hypothesis which is likely true for the exact version of the compiler you have. No guarantee of portability even to future compiler versions.</p>\n", "LastActivityDate": "2017-03-30T04:20:16.483", "Score": "1", "CreationDate": "2017-03-30T04:20:16.483", "ParentId": "14910616", "CommentCount": "0", "OwnerUserId": "6069467"}, "bq_ids": {"n4140": {"so_14910616_14910723_3": {"length": 20, "quality": 1.0, "section_id": 6049}, "so_14910616_14910723_2": {"length": 37, "quality": 0.925, "section_id": 6049}, "so_14910616_14910723_4": {"length": 27, "quality": 1.0, "section_id": 6049}, "so_14910616_14910723_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 3227}}, "n3337": {"so_14910616_14910723_3": {"length": 20, "quality": 1.0, "section_id": 5817}, "so_14910616_14910723_2": {"length": 37, "quality": 0.925, "section_id": 5817}, "so_14910616_14910723_4": {"length": 27, "quality": 1.0, "section_id": 5817}, "so_14910616_14910723_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 3100}}, "n4659": {"so_14910616_14910723_3": {"length": 20, "quality": 1.0, "section_id": 7548}, "so_14910616_14910723_2": {"length": 37, "quality": 0.925, "section_id": 7548}, "so_14910616_14910723_4": {"length": 27, "quality": 1.0, "section_id": 7548}, "so_14910616_14910723_1": {"length": 31, "quality": 0.8611111111111112, "section_id": 3984}}}, "14910723": {"Id": "14910723", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14910616_14910723_0\">Why doesn't &amp;Base::foo get the correct C++ member address?</p>\n</blockquote>\n<p>Pointers to member are different types than pointers (they are, in fact, more <em>offsets</em> than types themselves) and, in particular, they cannot be converted to <code>void*</code> (they can on GCC, but it's probably a compiler extension).</p>\n<p>See Paragraph 8.3.3/3 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14910616_14910723_1\">A pointer to member shall not point to** a static member of a class (9.4), a member with reference type, or \u201ccv void.\u201d\n  [ Note: See also 5.3 and 5.5. <strong>The type \u201cpointer to member\u201d is distinct from the type \u201cpointer\u201d</strong>, that is, a pointer to member is declared only by the pointer to member declarator syntax, and never by the pointer declarator syntax. There is no \u201creference-to-member\u201d type in C++. \u2014end note ]</p>\n</blockquote>\n<p>Also, Paragraph 5.2.10/10 (about <code>reinterpret_cast&lt;&gt;</code>) defines the only possible conversions for pointers to member as follows:</p>\n<blockquote>\n<p id=\"so_14910616_14910723_2\">A prvalue of type \u201cpointer to member of X of type T1\u201d can be explicitly converted to a prvalue of a different type \u201cpointer to member of Y of type T2\u201d if T1 and T2 are both function types or both object types. The null member pointer value (4.11) is converted to the null member pointer value of the destination type. The result of this conversion is unspecified, except in the following cases:</p>\n<p id=\"so_14910616_14910723_3\">\u2014 converting a prvalue of type \u201cpointer to member function\u201d to a different pointer to member function type and back to its original type yields the original pointer to member value.</p>\n<p id=\"so_14910616_14910723_4\">\u2014 converting a prvalue of type \u201cpointer to data member of X of type T1\u201d to the type \u201cpointer to data member of Y of type T2\u201d (where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer to member value.</p>\n</blockquote>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-16T13:25:12.533", "Score": "5", "CreationDate": "2013-02-16T13:15:27.130", "ParentId": "14910616", "CommentCount": "0", "LastEditDate": "2013-02-16T13:25:12.533", "OwnerUserId": "1932150"}, "14912050": {"Id": "14912050", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14910616_14912050_0\">Why doesn't &amp;Base::foo get the correct C++ member address?</p>\n</blockquote>\n<p>Base::foo is not a static method. There's no foo that belongs to Base. I wonder what the [foo 0x1] means (eg: why the 0x1 if the whole thing doesn't make much sense)?</p>\n", "LastEditorUserId": "2026056", "LastActivityDate": "2013-02-16T16:12:39.307", "Score": "0", "CreationDate": "2013-02-16T15:44:56.153", "ParentId": "14910616", "CommentCount": "0", "LastEditDate": "2013-02-16T16:12:39.307", "OwnerUserId": "2026056"}, "14910616": {"ViewCount": "1985", "Body": "<p>I searched this article:\n<a href=\"https://stackoverflow.com/questions/4998318/c-getting-function-virtual-address-with-member-function-pointer\">C++ : Getting function virtual 'address' with member function pointer</a></p>\n<p>In order to test if the virtual member function is usually at the beginning address of the object, I wrote the code as following:</p>\n<pre><code>#include &lt;pwd.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nclass Base\n{\npublic:\n    int mBase1;\n    char mBase2;\n    virtual void foo()\n    {\n        fprintf(stderr,\"Base foo called\\n\");\n    }\n};\n\nclass Child: public Base\n{\npublic:\n    int cc;\n    virtual void foo()\n    {\n        fprintf(stderr,\"Child foo called\");\n    }\n};\n\n\nint main(int argc, char *argv[])\n{\n    Base bb;\n    fprintf(stderr,\"[mBase1 %p][mBase2 %p] [foo %p]\\n\",&amp;bb.mBase1,&amp;bb.mBase2,&amp;Base::foo);\n    return 0;\n}\n</code></pre>\n<p>when compiling, I got a warning:</p>\n<pre><code>test.cpp:30:88: warning \u2018%p\u2019 expects argument of type \u2018void*\u2019, but argument 5 has type \u2018void (Base::*)()\u2019 [-Wformat]\n</code></pre>\n<p>The output is:</p>\n<pre><code>[mBase1 0xbfc2ca38][mBase2 0xbfc2ca3c] [foo 0x1]\n</code></pre>\n<p>I consider it's wired. </p>\n<ol>\n<li><p>Is there any \"pretty method\" to get the member function (not static member function address?). Besides the following method, is there any other elegant way?</p>\n<pre><code>typedef void (Base::*Foo)();\nFoo f = &amp;Base::foo();\n</code></pre></li>\n<li><p>Why doesn't <code>&amp;Base::foo</code> get the correct C++ member address?</p></li>\n</ol>\n", "Title": "Is there a way to get the C++ virtual member function address", "CreationDate": "2013-02-16T13:06:06.753", "LastActivityDate": "2017-03-30T04:20:16.483", "CommentCount": "2", "LastEditDate": "2017-05-23T12:32:26.887", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "14910616", "Score": "1", "OwnerUserId": "2078354", "Tags": "<c++><function><virtual>", "AnswerCount": "3"}});