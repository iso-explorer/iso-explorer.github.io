post_cb({"12024740": {"ParentId": "12024706", "CommentCount": "1", "Body": "<p>there is a auto cast. if you well run this program: </p>\n<pre><code>#include &lt;stdio.h&gt;\nconst char* c_str()\n{\n    static const char nullchar = '\\0';\n    return nullchar;\n}\n\nint main()\n{\n    printf(\"%d\" , sizeof(c_str()));\n    return 0;\n}\n</code></pre>\n<p>the out-put well be 4 on my computer -&gt; the size of a pointer.</p>\n<p>the compiler auto casts. notice, at least gcc gives a warning (i don't know about VS)</p>\n", "OwnerUserId": "1561062", "PostTypeId": "2", "Id": "12024740", "Score": "2", "CreationDate": "2012-08-19T06:38:29.593", "LastActivityDate": "2012-08-19T06:38:29.593"}, "12024849": {"ParentId": "12024706", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It compiles for the very same reason this compiles</p>\n<pre><code>const char *p = 0; // OK\n\nconst int i = 0;\ndouble *q = i; // OK\n\nconst short s = 0;\nlong *r = s; // OK\n</code></pre>\n<p>Expressions on the right have type <code>int</code> and <code>short</code>, while the object being initialized is a pointer. Does this surprise you?</p>\n<p>In C++ language (as well as in C) integral constant expressions (ICEs) with value <code>0</code> have special status (although ICEs are defined differently in C and C++). They qualify as <em>null-pointer constants</em>. When they are used in pointer contexts, they are implicitly converted to null pointers of the appropriate type.</p>\n<p>Type <code>char</code> is an integral type, not much different from <code>int</code> in this context, so a <code>const char</code> object initialized by <code>0</code> is also a null-pointer constant in C++ (but not in C).</p>\n<p>BTW, type <code>bool</code> in C++ is also an integral type, which means that a <code>const bool</code> object initialized by <code>false</code> is also a null-pointer constant    </p>\n<pre><code>const bool b = false;\nfloat *t = b; // OK\n</code></pre>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-08-19T07:41:25.893", "Id": "12024849", "Score": "9", "CreationDate": "2012-08-19T07:05:52.723", "LastActivityDate": "2012-08-19T07:41:25.893"}, "12024839": {"ParentId": "12024706", "PostTypeId": "2", "CommentCount": "24", "Body": "<p>As you've defined it, <code>nullchar</code> is an integer constant expression with the value 0.</p>\n<p>The C++03 standard defines an null pointer constant as: \"A null pointer constant is an integral constant expression (5.19) rvalue of integer type that evaluates to\nzero.\" To make a long story short, your <code>nullchar</code> is a null pointer constant, meaning it can be implicitly converted and assigned to essentially any pointer.</p>\n<p>Note that all those elements are required for that implicit conversion to work though. For example, if you had used <code>'\\1'</code> instead of <code>'\\0'</code>, or if you had <em>not</em> specified the <code>const</code> qualifier for <code>nullchar</code>, you wouldn't get the implicit conversion -- your assignment would have failed.</p>\n<p>Inclusion of this conversion is intentional but widely known as undesirable. 0 as a null pointer constant was inherited from C. I'm fairly sure Bjarne and most of the rest of the C++ standard committee (and most of the C++ community in general) would dearly love to remove this particular implicit conversion, but doing so would destroy compatibility with a lot of C code (probably close to all of it).</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "517503", "LastEditDate": "2012-08-21T21:22:01.760", "Id": "12024839", "Score": "69", "CreationDate": "2012-08-19T07:04:21.250", "LastActivityDate": "2012-08-21T21:22:01.760"}, "12024706": {"CommentCount": "14", "AcceptedAnswerId": "12024839", "PostTypeId": "1", "LastEditorUserId": "239916", "CreationDate": "2012-08-19T06:31:41.907", "LastActivityDate": "2016-11-15T05:04:16.700", "LastEditDate": "2012-12-26T00:41:36.447", "ViewCount": "3039", "FavoriteCount": "14", "Title": "Why is C++ allowing me to assign a const char to a const char *?\u200b!", "Id": "12024706", "Score": "70", "Body": "<p>To my astonishment, this compiles:</p>\n<pre><code>const char* c_str()\n{\n    static const char nullchar = '\\0';\n    return nullchar;\n}\n</code></pre>\n<p>and it introduced a bug in my code. Thankfully, I caught it.</p>\n<p>Is this intentional by C++, or a compiler bug? Is there a reason why the data type is actively ignored?<br>\nIt worked in Visual C++ 2010 and <a href=\"http://ideone.com/Crhv2\" rel=\"nofollow noreferrer\">GCC</a>, but I don't understand why it should work, given the obvious data type mismatch. (The <code>static</code> isn't necessary, either.)</br></p>\n", "Tags": "<c++><implicit-conversion><type-safety>", "OwnerUserId": "541686", "AnswerCount": "8"}, "12025051": {"ParentId": "12024706", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-08-19T07:49:13.617", "OwnerUserId": "161144", "CommunityOwnedDate": "2012-08-19T07:49:13.617", "Id": "12025051", "Score": "5", "Body": "<p>It seems that a lot of the real answer to this question has ended up in the comments.  To summarize:</p>\n<ul>\n<li><p>The C++ standard allows <code>const</code> variables of integral type to be considered \"integral constant expressions.\"  Why? Quite possibly to bypass the issue that C only allows macros and enums to hold the place of integral constant expression.</p></li>\n<li><p>Going (at least) as far back as C89, an integral constant expression with value 0 is implicitly convertible to (any type of) null pointer.  And this is used often in C code, where <code>NULL</code> is quite often <code>#define</code>'d as <code>(void*)0</code>.</p></li>\n<li><p>Going back to K&amp;R, the literal value <code>0</code> has been used to represent null pointers.  This convention is used all over the place, with such code as:</p>\n<pre><code>if ((ptr=malloc(...)) {...} else {/* error */}\n</code></pre></li>\n</ul>\n", "LastActivityDate": "2012-08-19T07:49:13.617"}, "12024867": {"ParentId": "12024706", "CommentCount": "0", "Body": "<p>It is not ignoring the data type. It's not a bug. It's taking advantage of the const you put in there and seeing that its value is actually an integer 0 (char is an integer type).</p>\n<p>Integer 0 is a valid (by definition) null pointer constant, which can be converted to a pointer type (becomes the null pointer).</p>\n<p>The reasons why you'd want the null pointer is to have some pointer value which \"points to nowhere\" and can be checkable (i.e. you can compare a null pointer to an integer 0, and you will get true in return).</p>\n<p>If you drop the const, you will get an error. If you put double in there (as with many other non integer types; I guess the exceptions are only types that can be converted to const char* [through overloading of the conversion operators]), you will get an error (even w/o the const). And so forth.</p>\n<p>The whole thing is that, in this case, your implementation sees that you're returning a null ptr constant; which you can convert to a pointer type.</p>\n", "OwnerUserId": "1562324", "PostTypeId": "2", "Id": "12024867", "Score": "6", "CreationDate": "2012-08-19T07:09:40.950", "LastActivityDate": "2012-08-19T07:09:40.950"}, "12024724": {"ParentId": "12024706", "PostTypeId": "2", "CommentCount": "11", "Body": "<p><code>nullchar</code> is a (compile-time-)constant expression, with value 0.  So it's fair game for implicit conversion to a null pointer.</p>\n<p>In more detail: I'm quoting from a <a href=\"http://www.csci.csusb.edu/dick/c++std/cd2/index.html\">1996 draft standard</a> here.</p>\n<p><code>char</code> is an integral type.  <code>nullchar</code> is const, so it is a (compile-time) integral constant expression, as per section 5.19.1:</p>\n<blockquote>\n<p id=\"so_12024706_12024724_0\">5.19  Constant expressions                                [expr.const]</p>\n<p id=\"so_12024706_12024724_1\">1 In  several places, C++ requires expressions that evaluate to an inte-\n   gral  or  enumeration  constant ...  An integral constant-expression can involve\n   ... const variables ...</p>\n</blockquote>\n<p>Moreover, <code>nullchar</code> evaluates to 0, allowing it to be implicitly converted to a pointer, as per section 4.10.1:</p>\n<blockquote>\n<p id=\"so_12024706_12024724_2\">4.10  Pointer conversions                                   [conv.ptr]</p>\n<p id=\"so_12024706_12024724_3\">1 An  integral constant expression (<em>expr.const</em>) rvalue of integer type\n   that evaluates to zero (called a null pointer constant)  can  be  con-\n   verted  to  a  pointer  type.</p>\n</blockquote>\n<p>Perhaps an intuitive reason \"why\" this might be allowed (just off the top of my head) is that pointer width isn't specified, and so conversion from any size integral constant expression to a null pointer is allowed.</p>\n<hr>\n<p>Updated with the relevant parts of the (newer) C++03 standard...\nAccording to \u00a75.19.1...</p>\n<blockquote>\n<p id=\"so_12024706_12024724_4\">An <em>integral constant-expression</em> can involve only literals (2.13), enumerators, <code>const</code> variables or static data members of integral or enumeration types initialized with constant expressions (8.5), non-type template parameters of integral or enumeration types, and <code>sizeof</code> expressions.</p>\n</blockquote>\n<p>Then, we look to \u00a74.10.1...</p>\n<blockquote>\n<p id=\"so_12024706_12024724_5\">A <em>null pointer constant</em> is an integral constant expression (5.19) rvalue of integer type that evaluates to zero. A null pointer constant can be converted to a pointer type; the result is the <em>null pointer</em> value of that type and is distinguishable from every other value of pointer to object or pointer to function type. Two null pointer values of the same type shall compare equal.</p>\n</blockquote>\n</hr>", "OwnerUserId": "161144", "LastEditorUserId": "161144", "LastEditDate": "2012-08-19T07:17:59.550", "Id": "12024724", "Score": "14", "CreationDate": "2012-08-19T06:34:43.527", "LastActivityDate": "2012-08-19T07:17:59.550"}, "12024833": {"ParentId": "12024706", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is an old history: it goes back to C.</p>\n<p>There is no <code>null</code> keyword in C. A null pointer constant in C is either:</p>\n<ul>\n<li>an integral constant expression with value 0, like <code>0</code>, <code>0L</code>, <code>'\\0'</code> (remember that <code>char</code> is an integral type), <code>(2-4/2)</code></li>\n<li>such expression cast to <code>void*</code>, like <code>(void*)0</code>, <code>(void*)0L</code>, <code>(void*)'\\0'</code>, <code>(void*)(2-4/2)</code></li>\n</ul>\n<p>The <code>NULL</code> <strong>macro</strong> (not a keyword!) expands to such null pointer constant.</p>\n<p>In the first C++ design, only the integral constant expression was allowed as a null pointer constant. Recently <code>std::nullptr_t</code> was added to C++.</p>\n<p>In C++, but not in C, a <code>const</code> variable of integral type initialized with an integral constant expression is an integral constant expression:</p>\n<pre><code>const int c = 3;\nint i;\n\nswitch(i) {\ncase c: // valid C++\n// but invalid C!\n}\n</code></pre>\n<p>So a <code>const char</code> initialized with the expression <code>'\\0'</code> is a null pointer constant:</p>\n<pre><code>int zero() { return 0; }\n\nvoid foo() {\n    const char k0 = '\\0',\n               k1 = 1,\n               c = zero();\n    int *pi;\n\n    pi = k0; // OK (constant expression, value 0)\n    pi = k1; // error (value 1)\n    pi = c; // error (not a constant expression)\n}\n</code></pre>\n<p>And you think this is not sound language design?</p>\n<hr>\n<p>Updated to include relevant parts of C99 standard...\nAccording to \u00a76.6.6...</p>\n<blockquote>\n<p id=\"so_12024706_12024833_0\">An <em>integer constant expression</em> shall have integer type and shall only have operands\n  that are integer constants, enumeration constants, character constants, <strong><code>sizeof</code></strong>\n  expressions whose results are integer constants, and floating constants that are the\n  immediate operands of casts. Cast operators in an integer constant expression shall only\n  convert arithmetic types to integer types, except as part of an operand to the <strong><code>sizeof</code></strong>\n  operator.</p>\n</blockquote>\n<p><strong>Some clarifications for C++-only programmers:</strong></p>\n<ul>\n<li>C uses the term \"constant\" for what C++ programmers know as a \"literal\".</li>\n<li>In C++, <code>sizeof</code> is always a compile time constant; but C has variable length arrays, so <code>sizeof</code> is sometimes <em>not</em> a compile time constant.</li>\n</ul>\n<p>Then, we see \u00a76.3.2.3.3 states...</p>\n<blockquote>\n<p id=\"so_12024706_12024833_1\">An integer constant expression with the value 0, or such an expression cast to type\n  <strong><code>void *</code></strong>, is called a <em>null pointer constant</em>. If a null pointer constant is converted to a pointer type, the resulting pointer, called a <em>null pointer</em>, is guaranteed to compare unequal to a pointer to any object or function.</p>\n</blockquote>\n<hr>\n<p>To see just how old this functionality is, see the identical mirrored parts in the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\" rel=\"nofollow noreferrer\">C99 standard</a>...</p>\n<p>\u00a76.6.6</p>\n<blockquote>\n<p id=\"so_12024706_12024833_2\">An <em>integer constant expression</em> shall have integer type and shall only have operands that are integer constants, enumeration constants, character constants, <strong><code>sizeof</code></strong> expressions whose results are integer constants, and floating constants that are the immediate operands of casts. Cast operators in an integer constant expression shall only convert arithmetic types to integer types, except as part of an operand to the <strong><code>sizeof</code></strong> operator.</p>\n</blockquote>\n<p>\u00a76.3.2.3.3</p>\n<blockquote>\n<p id=\"so_12024706_12024833_3\">An integer constant expression with the value 0, or such an expression cast to type\n  <strong><code>void *</code></strong>, is called a <em>null pointer constant</em>. If a null pointer constant is converted to a pointer type, the resulting pointer, called a <em>null pointer</em>, is guaranteed to compare unequal to a pointer to any object or function.</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "963864", "LastEditorUserId": "3777958", "LastEditDate": "2016-11-15T05:04:16.700", "Id": "12024833", "Score": "26", "CreationDate": "2012-08-19T07:02:47.480", "LastActivityDate": "2016-11-15T05:04:16.700"}, "bq_ids": {"n4140": {"so_12024706_12024724_5": {"section_id": 39, "quality": 0.7560975609756098, "length": 31}, "so_12024706_12024724_3": {"section_id": 87, "quality": 0.5555555555555556, "length": 10}}, "n3337": {"so_12024706_12024833_1": {"section_id": 36, "quality": 0.5333333333333333, "length": 16}, "so_12024706_12024724_5": {"section_id": 36, "quality": 0.8780487804878049, "length": 36}, "so_12024706_12024724_3": {"section_id": 36, "quality": 0.7222222222222222, "length": 13}, "so_12024706_12024833_3": {"section_id": 36, "quality": 0.5333333333333333, "length": 16}}, "n4659": {"so_12024706_12024724_5": {"section_id": 39, "quality": 0.7560975609756098, "length": 31}}}, "12024749": {"ParentId": "12024706", "CommentCount": "0", "Body": "<p>I think it might be the fact the null character is common between the types. What you are doing is setting a null pointer when you return the null character. This would fail if any other character was used because you are not passing the address of the character to the pointer, but the value of the character. Null is a valid pointer and character value so a null character can be set as pointer.</p>\n<p>In short, null can be used by any type to set an empty value, regardless to if it is an array, a pointer, or a variable.</p>\n", "OwnerUserId": "1253462", "PostTypeId": "2", "Id": "12024749", "Score": "2", "CreationDate": "2012-08-19T06:40:34.430", "LastActivityDate": "2012-08-19T06:40:34.430"}});