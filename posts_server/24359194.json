post_cb({"bq_ids": {"n4140": {"so_24359194_24359735_0": {"length": 14, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_24359194_24359735_0": {"length": 14, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_24359194_24359735_0": {"length": 14, "quality": 1.0, "section_id": 7604}}}, "24359735": {"Id": "24359735", "PostTypeId": "2", "Body": "<p><code>reset</code> ist implemented as </p>\n<pre><code>pointer old = this-&gt;ptr;\nthis-&gt;ptr= newPointer;\ndelete[] old;\n</code></pre>\n<p>The templated overload is deleted for arrays to prevent the following case</p>\n<pre><code>class foo{};\nclass bar : public foo {};\n\nfoo* managedPointer = new foo[3];\nbar* newPointer = new bar[5];\n\nfoo* old = managedPointer;\nmanagedPointer = newPointer;\ndelete[] old;\n</code></pre>\n<p>Which is undefined behavior. Section 5.3.5 paragraph 3:</p>\n<blockquote>\n<p id=\"so_24359194_24359735_0\">[...] In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>Since deleted functions still participate in overload resolution and <code>reset(U)</code> provide a better match for <code>nullptr</code> than <code>reset(pointer)</code> \n, there is an additional overload to to allow <code>reset(nullptr)</code>, which would otherwise give a compiler error and thus result in an inconsistent interface between array and pointer version.</p>\n", "LastEditorUserId": "498298", "LastActivityDate": "2014-06-23T06:50:07.803", "Score": "2", "CreationDate": "2014-06-23T06:34:46.377", "ParentId": "24359194", "CommentCount": "0", "OwnerUserId": "498298", "LastEditDate": "2014-06-23T06:50:07.803"}, "24359194": {"ViewCount": "490", "Body": "<p>Accroding to <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/reset\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/memory/unique_ptr/reset</a>,</p>\n<pre><code>void reset( pointer ptr = pointer() );\n\ntemplate&lt; class U &gt; \nvoid reset( U ) = delete;\n\nvoid reset( std::nullptr_t p );\n</code></pre>\n<blockquote>\n<p id=\"so_24359194_24359194_0\">1) Given <code>current_ptr</code>, the pointer that was managed by <code>*this</code>, performs\n  the following actions, in this order:\n      Saves a copy of the current pointer <code>old_ptr = current_ptr</code>;\n      Overwrites the current pointer with the argument <code>current_ptr = ptr</code>;\n      If the old pointer was non-empty, deletes the previously managed object <code>if(old_ptr != nullptr) get_deleter()(old_ptr)</code>.</p>\n<p id=\"so_24359194_24359194_1\">2) In the specialization for dynamic arrays, <code>std::unique_ptr&lt;T[]&gt;</code>,\n  this template member is provided to prevent using <code>reset()</code> with a\n  pointer to derived (which would result in undefined behavior with\n  arrays).</p>\n<p id=\"so_24359194_24359194_2\">3) In the specialization for dynamic arrays, <code>std::unique_ptr&lt;T[]&gt;</code>, the\n  third overload is necessary to allow reset to <code>nullptr</code> (which would\n  otherwise be prohibited by the template overload). Equivalent to\n  <code>reset(pointer())</code></p>\n</blockquote>\n<p>Now that <code>reset(nullptr)</code> is equivalent to <code>reset(pointer())</code>, why does the latter exist?</p>\n<p>If I want to reset an array form unique_ptr, why can I not just use <code>rest(pointer())</code>?</p>\n", "AcceptedAnswerId": "24359826", "Title": "Why does unique_ptr overload reset(pointer p = pointer()) and reset(nullptr_t)?", "CreationDate": "2014-06-23T05:53:38.113", "Id": "24359194", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-23T05:57:56.273", "LastEditorUserId": "985296", "LastActivityDate": "2014-06-23T06:50:07.803", "Score": "3", "OwnerUserId": "508343", "Tags": "<c++><arrays><c++11><overloading><unique-ptr>", "AnswerCount": "2"}, "24359826": {"Id": "24359826", "PostTypeId": "2", "Body": "<p>The</p>\n<pre><code>template&lt; class U &gt; \nvoid reset( U ) = delete;\n</code></pre>\n<p>would be chosen for a call with <code>nullptr</code> argument, if not for</p>\n<pre><code>void reset( std::nullptr_t p );\n</code></pre>\n<p>That's why it exists, to allow the call with <code>nullptr</code>.</p>\n<hr>\n<p>Example (compile with <code>FIX</code> defined to suppress the compilation error):</p>\n<pre><code>#include &lt;cstddef&gt;      // std::nullptr_t\n\nstruct S\n{\n    void reset( char* ) {}\n\n    template&lt; class Type &gt;\n    void reset( Type ) = delete;\n\n    #if FIX\n    void reset( std::nullptr_t ) {}\n    #endif\n};\n\nauto main() -&gt; int\n{\n    S().reset( nullptr );    // Fails when FIX is not defined.\n}\n</code></pre>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-06-23T06:46:42.047", "Score": "7", "CreationDate": "2014-06-23T06:40:02.013", "ParentId": "24359194", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2014-06-23T06:46:42.047"}});