post_cb({"18971808": {"Id": "18971808", "PostTypeId": "2", "Body": "<p><code>long</code> is equivalent to <code>long int</code>, just as <code>short</code> is equivalent to <code>short int</code>. A <code>long int</code> is a signed integral type that is <em>at least</em> 32 bits, while a <code>long long</code> or <code>long long int</code> is a signed integral type is <em>at least</em> 64 bits.</p>\n<p>This doesn't necessarily mean that a <code>long long</code> is wider than a <code>long</code>. Many platforms / ABIs use the <code>LP64</code> model - where <code>long</code> (and pointers) are 64 bits wide. Win64 uses the <code>LLP64</code>, where <code>long</code> is still 32 bits, and <code>long long</code> (and pointers) are 64 bits wide.</p>\n<p>There's a good summary of 64-bit data models <a href=\"http://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models\" rel=\"noreferrer\">here</a>.</p>\n<p><code>long double</code> doesn't guarantee much other than it will be <em>at least</em> as wide as a <code>double</code>.</p>\n", "LastActivityDate": "2013-09-24T02:00:03.673", "Score": "12", "CreationDate": "2013-09-24T02:00:03.673", "ParentId": "18971732", "CommentCount": "0", "OwnerUserId": "906839"}, "18971732": {"ViewCount": "198383", "Body": "<p>I am transitioning from Java to C++ and have some questions about the <code>long</code> data type. In Java, to hold an integer greater than 2<sup>32</sup>, you would simply write <code>long x;</code>. However, in C++, it seems that <code>long</code> is both a data type and a modifier. </p>\n<p>There seems to be several ways to use <code>long</code>:</p>\n<pre><code>long x;\nlong long x;\nlong int x;\nlong long int x;\n</code></pre>\n<p>Also, it seems there are things such as:</p>\n<pre><code>long double x;\n</code></pre>\n<p>and so on.</p>\n<p>What is the difference between all of these various data types, and do they all have the same purpose?</p>\n", "AcceptedAnswerId": "18971763", "Title": "What is the difference between \"long\", \"long long\", \"long int\", and \"long long int\" in C++?", "CreationDate": "2013-09-24T01:49:19.417", "Id": "18971732", "CommentCount": "6", "FavoriteCount": "37", "PostTypeId": "1", "LastEditDate": "2015-11-22T18:09:12.493", "LastEditorUserId": "1950231", "LastActivityDate": "2016-11-03T09:01:54.957", "Score": "108", "OwnerUserId": "2612743", "Tags": "<c++><long-integer>", "AnswerCount": "6"}, "25284847": {"Id": "25284847", "PostTypeId": "2", "Body": "<p>Historically, in early C times, when processors had 8 or 16 bit wordlength,<code>int</code>was identical to todays <code>short</code>(16 bit). In a certain sense, int is a more abstract data type than<code>char</code>,<code>short</code>,<code>long</code>or<code>long long</code>, as you cannot be sure about the bitwidth. </p>\n<p>When defining<code>int n;</code>you could translate this with \"give me the best compromise of bitwidth and speed on this machine for n\". Maybe in the future you should expect compilers to translate<code>int</code>to be 64 bit. So when you want your variable to have 32 bits and not more, better use an explicit<code>long</code>as data type.</p>\n<p>[Edit: <code>#include &lt;stdint.h&gt;</code> seems to be the proper way to ensure bitwidths using the int##_t types, though it's not yet part of the standard.]</p>\n", "LastEditorUserId": "1284927", "LastActivityDate": "2014-11-20T11:25:07.930", "Score": "3", "CreationDate": "2014-08-13T11:23:24.893", "ParentId": "18971732", "CommentCount": "3", "LastEditDate": "2014-11-20T11:25:07.930", "OwnerUserId": "1284927"}, "18971763": {"Id": "18971763", "PostTypeId": "2", "Body": "<p><code>long</code> and <code>long int</code> are identical. So are <code>long long</code> and <code>long long int</code>. In both cases, the <code>int</code> is optional.</p>\n<p>As to the difference between the two sets, the C++ standard mandates minimum ranges for each, and that <code>long long</code> is at <em>least</em> as wide as <code>long</code>.</p>\n<p>The controlling parts of the standard (C++11, but this has been around for a long time) are, for one, <code>3.9.1 Fundamental types</code>, section 2 (a later section gives similar rules for the unsigned integral types):</p>\n<blockquote>\n<p id=\"so_18971732_18971763_0\">There are five standard signed integer types : signed char, short int, int, long int, and long long int. In this list, each type provides at least as much storage as those preceding it in the list.</p>\n</blockquote>\n<p>There's also a table 9 in <code>7.1.6.2 Simple type specifiers</code>, which shows the \"mappings\" of the specifiers to actual types (showing that the <code>int</code> is optional), a section of which is shown below:</p>\n<pre><code>Specifier(s)         Type\n-------------    -------------\nlong long int    long long int\nlong long        long long int\nlong int         long int\nlong             long int\n</code></pre>\n<p>Note the distinction there between the specifier and the type. The specifier is how you tell the compiler what the type is but you can use different specifiers to end up at the same type.</p>\n<p>Hence <code>long</code> on its own is neither a type <em>nor</em> a modifier as your question posits, it's simply a specifier for the <code>long int</code> type. Ditto for <code>long long</code> being a specifier for the <code>long long int</code> type.</p>\n<p>Although the C++ standard itself doesn't specify the minimum ranges of integral types, it does cite C99, in <code>1.2 Normative references</code>, as applying. Hence the minimal ranges as set out in <code>C99 5.2.4.2.1 Sizes of integer types &lt;limits.h&gt;</code> are applicable.</p>\n<hr>\n<p>In terms of <code>long double</code>, that's actually a floating point value rather than an integer. Similarly to the integral types, it's required to have at least as much precision as a <code>double</code> and to provide a superset of values over that type (meaning <em>at least</em> those values, not necessarily <em>more</em> values).</p>\n</hr>", "LastEditorUserId": "14860", "LastActivityDate": "2013-12-15T07:19:36.457", "Score": "105", "CreationDate": "2013-09-24T01:53:06.850", "ParentId": "18971732", "CommentCount": "5", "LastEditDate": "2013-12-15T07:19:36.457", "OwnerUserId": "14860"}, "40397388": {"Id": "40397388", "PostTypeId": "2", "Body": "<p>long int or long has a size of 4 bytes whereas long long or long long int is 8 bytes long</p>\n", "LastActivityDate": "2016-11-03T09:01:54.957", "Score": "0", "CreationDate": "2016-11-03T09:01:54.957", "ParentId": "18971732", "CommentCount": "1", "OwnerUserId": "6885713"}, "bq_ids": {"n4140": {"so_18971732_18971763_0": {"length": 25, "quality": 1.0, "section_id": 7211}}, "n3337": {"so_18971732_18971763_0": {"length": 25, "quality": 1.0, "section_id": 6955}}, "n4659": {"so_18971732_18971763_0": {"length": 24, "quality": 0.96, "section_id": 8720}}}, "18971792": {"Id": "18971792", "PostTypeId": "2", "Body": "<p>Long and long int are at least 32 bits.</p>\n<p>long long and long long int are at least 64 bits. You must be using a c99 compiler or better.</p>\n<p>long doubles are a bit odd. Look them up on Wikipedia for details.</p>\n", "LastActivityDate": "2013-09-24T01:57:44.500", "Score": "36", "CreationDate": "2013-09-24T01:57:44.500", "ParentId": "18971732", "CommentCount": "0", "OwnerUserId": "88656"}, "37563374": {"Id": "37563374", "PostTypeId": "2", "Body": "<p>This looks confusing because you are taking <code>long</code> as a datatype itself.</p>\n<p><code>long</code> is nothing but just the shorthand for <code>long int</code> when you are using it alone.</p>\n<p><code>long</code> is a modifier, you can use it with <code>double</code> also as <code>long double</code>.</p>\n<p><code>long</code> == <code>long int</code>.</p>\n<p>Both of them take 4 bytes.</p>\n", "LastActivityDate": "2016-06-01T08:30:48.543", "Score": "6", "CreationDate": "2016-06-01T08:30:48.543", "ParentId": "18971732", "CommentCount": "0", "OwnerUserId": "5132337"}});