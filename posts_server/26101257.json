post_cb({"26101257": {"ViewCount": "685", "Body": "<p>I am surprised by C++'s behavior when applying bit-wise not to an unsigned char.</p>\n<p>Take the binary value <code>01010101b</code>, which is <code>0x55</code>, or <code>85</code>. Applying bit-wise not on an eight bit representation should yield <code>10101010b</code>, which is <code>0xAA</code>, or <code>170</code>.</p>\n<p>However, I cannot reproduce the above in C++. The following simple assertion fails.</p>\n<pre><code>assert(static_cast&lt;unsigned char&gt;(0xAAu) == ~static_cast&lt;unsigned char&gt;(0x55u));\n</code></pre>\n<p>I printed the values of <code>0x55</code>, <code>0xAA</code>, and <code>~0x55</code> (as uchar) with the following code. And it reveals that the bit-wise not does not do what I expect it to do.</p>\n<pre><code>std::cout &lt;&lt; \"--&gt; 0x55: \" &lt;&lt; 0x55u &lt;&lt; \", 0xAA: \" &lt;&lt; 0xAAu &lt;&lt; \", ~0x55: \"\n     &lt;&lt; static_cast&lt;unsigned&gt;(~static_cast&lt;unsigned char&gt;(0x55u)) &lt;&lt; std::endl;\n\n--&gt; 0x55: 85, 0xAA: 170, ~0x55: 4294967210\n</code></pre>\n<p>The number that is printed for <code>~0x55</code> is equal to <code>11111111111111111111111110101010b</code>, which is the 32-bit bit-wise not of <code>0x55</code>. So, the <code>~</code> operator is operating on 32-bit integers even if I explicitly cast the input to an <code>unsigned char</code>. Why is that?</p>\n<p>I applied another test to see what type the <code>~</code> operator returns. And it turns out to be <code>int</code> on an <code>unsigned char</code> input:</p>\n<pre><code>template &lt;class T&gt;\nstruct Print;\n\n// inside main()    \nPrint&lt;decltype(~static_cast&lt;unsigned char&gt;(0x55))&gt; dummy;\n</code></pre>\n<p>Yields the following compiler error, which indicates, that the result is of type <code>int</code>.</p>\n<pre><code>error: implicit instantiation of undefined template 'Print&lt;int&gt;'\n    Print&lt;decltype(~static_cast&lt;unsigned char&gt;(0x55u))&gt; dummy;\n</code></pre>\n<p>What am I doing wrong? Or, how do I get C++ to produce <code>0xAA</code> from <code>~0x55</code>?</p>\n<p><em>Full code is <a href=\"http://coliru.stacked-crooked.com/a/37ec1bf60c4aa9d3\" rel=\"nofollow\">here</a></em></p>\n", "AcceptedAnswerId": "26101357", "Title": "C++ - Bit-wise not of uchar produces int", "CreationDate": "2014-09-29T13:37:13.480", "Id": "26101257", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-09-29T19:15:35.540", "LastEditorUserId": "1708801", "LastActivityDate": "2015-04-10T20:17:10.520", "Score": "7", "OwnerUserId": "841562", "Tags": "<c++><bit-manipulation><integer-promotion>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26101257_26101357_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 6073}, "so_26101257_26101357_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 45}, "so_26101257_26101357_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 21}, "so_26101257_26101357_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 45}}, "n3337": {"so_26101257_26101357_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 5841}, "so_26101257_26101357_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 42}, "so_26101257_26101357_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 18}, "so_26101257_26101357_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 42}}, "n4659": {"so_26101257_26101357_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7569}, "so_26101257_26101357_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 46}, "so_26101257_26101357_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 21}, "so_26101257_26101357_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 46}}}, "26133692": {"Id": "26133692", "PostTypeId": "2", "Body": "<p>The answer about integral promotion is correct. </p>\n<p>You can get the desired results by casting and NOTting in the right order:</p>\n<pre><code>assert(static_cast&lt;unsigned char&gt;(0xAAu) == static_cast&lt;unsigned char&gt;(~0x55u));\n</code></pre>\n", "LastActivityDate": "2014-10-01T03:33:08.243", "CommentCount": "0", "CreationDate": "2014-10-01T03:33:08.243", "ParentId": "26101257", "Score": "2", "OwnerUserId": "291737"}, "26101357": {"Id": "26101357", "PostTypeId": "2", "Body": "<p>Integral promotions are performed on the operand of <code>~</code> we can see this by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>5.3.1</code> <em>Unary operators</em> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_26101257_26101357_0\">The operand of \u02dc shall have integral or unscoped enumeration type; the\n  result is the one\u2019s complement of its operand. <strong>Integral promotions\n  are performed.</strong> The type of the result is the type of the promoted operand [...]</p>\n</blockquote>\n<p>and the integral promotions are covered in section <code>4.5</code> <em>Integral promotions</em> and say:</p>\n<blockquote>\n<p id=\"so_26101257_26101357_1\">A prvalue of an integer type other than bool, char16_t, char32_t, or\n  wchar_t whose integer conversion rank (4.13) is less than the rank of\n  int can be converted to a prvalue of type int if int can represent all\n  the values of the source type;</p>\n</blockquote>\n<p>For completeness, to see that <em>unsigned char</em> rank is less than the rank of <em>int</em> we can go to section <code>4.13</code> <em>Integer conversion rank</em> which says:</p>\n<blockquote>\n<p id=\"so_26101257_26101357_2\">The rank of a signed integer type shall be greater than the rank of\n  any signed integer type with a smaller size.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_26101257_26101357_3\">The rank of char shall equal the rank of signed char and unsigned\n  char.</p>\n</blockquote>\n<p>One solution would be to assign the result to an <em>unsigned char</em> which, this is safe since you don't have to worry about signed integer overflow.</p>\n<p>As Ben Voigt points out it would compliant to have a system where <code>sizeof (int) == 1</code> and <code>CHAR_BIT &gt;= 32</code>. In which case the rank of unsigned char woudl not be less than int and therefore the promotion would be to unsigned int. We do not know of any systems that this actually occurs on.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-04-10T20:17:10.520", "Score": "9", "CreationDate": "2014-09-29T13:41:35.157", "ParentId": "26101257", "CommentCount": "10", "OwnerUserId": "1708801", "LastEditDate": "2015-04-10T20:17:10.520"}, "26101562": {"Id": "26101562", "PostTypeId": "2", "Body": "<p>You can kind of \"truncate\" the leading 1's by assigning the result of <code>~0x55</code> to an <code>unsigned char</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    unsigned char input = 0x55;\n    unsigned char output = ~input;\n\n    std::cout &lt;&lt; \"input: \" &lt;&lt; (int)input &lt;&lt; \" output: \" &lt;&lt; (int)output &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>input: 85 output: 170\n</code></pre>\n", "LastEditorUserId": "1916893", "LastActivityDate": "2014-09-29T14:28:35.747", "Score": "1", "CreationDate": "2014-09-29T13:52:22.263", "ParentId": "26101257", "CommentCount": "2", "OwnerUserId": "1916893", "LastEditDate": "2014-09-29T14:28:35.747"}});