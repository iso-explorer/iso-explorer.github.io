post_cb({"32279668": {"Id": "32279668", "PostTypeId": "2", "Body": "<pre><code>reinterpret_cast&lt;unsigned short int&amp;&gt;(*cd);\n</code></pre>\n<p>is similar to</p>\n<pre><code>*reinterpret_cast&lt;unsigned short int*&gt;(cd);\n</code></pre>\n", "LastActivityDate": "2015-08-28T20:58:02.637", "CommentCount": "3", "CreationDate": "2015-08-28T20:58:02.637", "ParentId": "32279647", "Score": "0", "OwnerUserId": "2684539"}, "32279899": {"Id": "32279899", "PostTypeId": "2", "Body": "<p>Cast with reference is different from the same cast without reference in one thing - cast without reference creates a new temporary object, while cast with reference changes the type of the already existing object. This matters in many cases, for example, in your case, since you assigning a result to a non-const reference. Non-const references can not be inialized with temporary objects.</p>\n<p>On a side note, you know that what you are doing here is a violation on type aliasing rule, and is yields undefeined behaviour?</p>\n", "LastActivityDate": "2015-08-28T21:17:59.940", "CommentCount": "4", "CreationDate": "2015-08-28T21:17:59.940", "ParentId": "32279647", "Score": "1", "OwnerUserId": "5245033"}, "32281264": {"Id": "32281264", "PostTypeId": "2", "Body": "<p>The \"intuitive\" meaning of <code>reinterpret_cast</code> is \"take a sequence of bits and treat it as if that sequence of bits has a different type\". That is not possible to do for types <code>char</code> and <code>unsigned short</code>, because they have different width.</p>\n<p>As for the first case, the intuition is: <code>reinterpret_cast</code> treats lvalue reference as if it was a pointer to the type it refers (and applies mentioned conversion to that pointer).</p>\n<p>Formally, the standard says:</p>\n<blockquote>\n<p id=\"so_32279647_32281264_0\"><strong>4.2 Array-to-pointer conversion [conv.array]</strong></p>\n<ol>\n<li>An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The result is a pointer to the first element of the array.</li>\n</ol>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_32279647_32281264_1\"><strong>5.3.1 Unary operators [expr.unary.op]</strong></p>\n<ol>\n<li>The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function\n  to which the expression points. If the type of the expression is \u201cpointer to T\u201d, the type of the result is\n  \u201cT\u201d.</li>\n</ol>\n</blockquote>\n<p>So, after dereferencing <code>*cd</code> we will get an lvalue of type <code>char</code> (same as if you wrote <code>cd[0]</code>).</p>\n<blockquote>\n<p id=\"so_32279647_32281264_2\"><strong>5.2.10 Reinterpret cast [expr.reinterpret.cast]</strong></p>\n<ol start=\"10\">\n<li>A glvalue expression of type T1 can be cast to the type \u201creference to T2\u201d if an expression of type \u201cpointer to T1\u201d can be explicitly converted to the type \u201cpointer to T2\u201d using a <code>reinterpret_cast</code>. The result refers to the same object as the source glvalue, but with the specified type. [ Note: That is, for lvalues, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in <code>&amp;</code> and <code>*</code> operators (and similarly for <code>reinterpret_cast&lt;T&amp;&amp;&gt;(x)</code>). \u2014 end note ] No temporary is created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.</li>\n</ol>\n</blockquote>\n<p>That means, you have got something like</p>\n<pre><code>*reinterpret_cast&lt;unsigned short *&gt;(&amp;cd[0])\n</code></pre>\n<p>But what is perhaps more important than all the above:</p>\n<blockquote>\n<p id=\"so_32279647_32281264_3\"><strong>3.10 Lvalues and rvalues [basic.lval]</strong></p>\n<p id=\"so_32279647_32281264_4\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>...</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<p>That is, binding a \"reference to char\" to an object of type \"unsigned short\" is ok. But doing vise-versa (i.e., as in your example) is sort-of-not-ok, because accessing such reference would invoke undefined behavior.</p>\n", "LastEditorUserId": "4142343", "LastActivityDate": "2015-08-29T12:52:29.240", "Score": "3", "CreationDate": "2015-08-28T23:43:35.110", "ParentId": "32279647", "CommentCount": "1", "OwnerUserId": "4142343", "LastEditDate": "2015-08-29T12:52:29.240"}, "bq_ids": {"n4140": {"so_32279647_32281264_4": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_32279647_32281264_4": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_32279647_32281264_4": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "32282372": {"Id": "32282372", "PostTypeId": "2", "Body": "<p><code>unsigned short int &amp; messageSize</code> means that <code>messageSize</code> is a variable of type <code>unsigned short int</code>, and the memory area where that variable  will be stored shall be given as initializer.</p>\n<p>The initializer <code>=reinterpret_cast&lt;unsigned short int&amp;&gt;(*cd)</code> says: take the memory at the location being pointed to by <code>cd</code>, and pretend it contains a <code>unsigned short int</code>.</p>\n<p>The result is that if you try to read and write <code>messageSize</code>, then you will try to read and write a <code>unsigned short int</code> in a memory location that contains something else. This causes undefined behaviour.</p>\n<p>There are a few situations in which it is OK to pretend a memory location contains an object that it actually doesn't; this is not one of them. </p>\n<p>If your compiler is not performing aliasing optimizations then it <em>might appear</em> as if your code \"works\" for now. However the code is broken.</p>\n", "LastActivityDate": "2015-08-29T03:18:13.037", "CommentCount": "0", "CreationDate": "2015-08-29T03:18:13.037", "ParentId": "32279647", "Score": "0", "OwnerUserId": "1505939"}, "32279647": {"ViewCount": "163", "Body": "<p>Can anyone explain what's happening in the following code?</p>\n<pre><code>char cd[1024];\nunsigned short int &amp; messageSize =reinterpret_cast&lt;unsigned short int&amp;&gt;(*cd);\n</code></pre>\n<p>does it take the first 2 char of cd by reference and cast it to a 16 bit int?\nwhen I remove the '&amp;', the compiler complains about cannot cast from char to unsigned short int.</p>\n<pre><code>unsigned short int messageSize =reinterpret_cast&lt;unsigned short int&gt;(*cd);\n</code></pre>\n", "AcceptedAnswerId": "32281264", "Title": "C++ how does cast with reference work?", "CreationDate": "2015-08-28T20:56:13.413", "Id": "32279647", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-08-29T12:52:29.240", "Score": "0", "OwnerUserId": "1464870", "Tags": "<c++><casting><char>", "AnswerCount": "4"}});