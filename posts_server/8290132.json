post_cb({"8290162": {"Id": "8290162", "PostTypeId": "2", "Body": "<p>It depends on the <strong>type</strong> of the variable, and on whether \"constant\" also means \"constant expression\". Example:</p>\n<pre><code>static const Foo = get_foo(std::cin);\n\nstatic const int q = argc * 3;\n\nstatic const std::string s(gets());\n</code></pre>\n<p>These variables are const, but blatantly need an actual allocation.</p>\n<p>On the other hand, the following constant <em>expression</em> may never have physical storage:</p>\n<pre><code>static const int N = 1000;\n\nstatic const std::shared_ptr&lt;void&gt; vp();  // constexpr constructor!\n</code></pre>\n<p>Most importantly, static constexpr <em>member</em> variables don't need a definition if you're careful:</p>\n<pre><code>struct Bar\n{\n  int size() const { return N; }\n  static const int N = 8;\n};\n// does NOT need \"const int Bar::N;\"\n</code></pre>\n", "LastActivityDate": "2011-11-28T00:05:26.880", "CommentCount": "12", "CreationDate": "2011-11-28T00:05:26.880", "ParentId": "8290132", "Score": "11", "OwnerUserId": "596781"}, "8290153": {"Id": "8290153", "PostTypeId": "2", "Body": "<p>There is chance that it isn't, but that doesn't matter. You can't rely on implementation details, only on the standard. </p>\n", "LastEditorUserId": "72178", "LastActivityDate": "2011-11-28T06:29:12.140", "Score": "2", "CreationDate": "2011-11-28T00:04:44.573", "ParentId": "8290132", "CommentCount": "1", "OwnerUserId": "140367", "LastEditDate": "2011-11-28T06:29:12.140"}, "bq_ids": {"n4140": {"so_8290132_8290368_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 7165}, "so_8290132_8290368_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 7165}, "so_8290132_8290523_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 7165}}, "n3337": {"so_8290132_8290368_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 6909}, "so_8290132_8290368_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 6909}, "so_8290132_8290523_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6909}}, "n4659": {"so_8290132_8290368_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 8673}, "so_8290132_8290368_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 8673}, "so_8290132_8290523_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 8673}}}, "8290523": {"Id": "8290523", "PostTypeId": "2", "Body": "<p>Memory for global variables is reserved by the linker, not the compiler. So the question is whether the linker is smart enough to not reserve space for global variables that are only used by value.</p>\n<p>It depends on the type and use of such data; for example, floating point constants generally must be loaded from memory, so they must have storage even if you don't directly use the address.</p>\n<p>Having said that, the standard does specify whether you <strong>can</strong> optimize out static storage (3.7.1.2: [basic.stc.static]):</p>\n<blockquote>\n<p id=\"so_8290132_8290523_0\">If a variable with static storage duration has initialization or a\n  destructor with side effects, it shall not be eliminated even if it\n  appears to be unused, except that a class object or its copy/move may\n  be eliminated as specified in 12.8.</p>\n</blockquote>\n<p>So if the static const variable has a constructor or destructor, it cannot be optimized out (although some compilers/linkers will do this anyway). If it doesn't, it can. Whether it will depends on the linker.</p>\n", "LastActivityDate": "2011-11-28T01:14:35.093", "CommentCount": "1", "CreationDate": "2011-11-28T01:14:35.093", "ParentId": "8290132", "Score": "1", "OwnerUserId": "6210"}, "8290132": {"ViewCount": "4561", "Body": "<p>If I never use the address of a static const variable, is memory allocated for it when using a reasonably modern compiler?</p>\n", "AcceptedAnswerId": "8290162", "Title": "Is memory allocated for a static const variable whose address is never used?", "CreationDate": "2011-11-28T00:01:36.377", "Id": "8290132", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-11-28T06:29:12.140", "Score": "7", "OwnerUserId": "436418", "Tags": "<c++><c><optimization><static><const>", "AnswerCount": "4"}, "8290368": {"Id": "8290368", "PostTypeId": "2", "Body": "<p>In practice, space for static storage can be allocated as part of the initial binary loading, or by the runtime during startup; but will always happen before user code is encountered.</p>\n<p>In addition to the constraints that <em>Kerrek SB</em> mentions, the storage for a <code>const expr</code> value could be eliminated if the value itself is never used at runtime.</p>\n<p>This wouldn't necessarily mean that the value needs to not be evaluated - if a static <code>const expr</code> were only used as a branch condition, that condition may be evaluated statically and other code paths may not be generated or may be excluded by the optimiser.</p>\n<p>Pretty much any storage with <code>static</code> duration may be eliminated if the implementation can guarantee behaviour as though the storage were present - i.e. a comparison expression that can be evaluated at compile time - like a different <code>const expr</code>, a pointer comparison where the rhs is known to be an alias to a different variable, or perhaps an incompatible type.  It may also be eliminated if the value is only read into variables that are never read themselves; or where the value may be reduced to a <code>const expr</code>.</p>\n<pre><code>struct Foo{};\nstatic Foo bar; // static instance\n\nFoo* func() {\n    if ( ! (&amp;bar) ) { // always non-NULL\n        // this block may be eliminated\n        Foo* myCopy(new Foo(bar));\n        return myCopy;\n    }\n    // so 'bar' is never referred to, and we know it has no side-\n    // effects, so the static variable can be eliminated\n    return new Foo();\n}\n</code></pre>\n<blockquote>\n<p id=\"so_8290132_8290368_0\"><strong>3.7.1 Static storage duration</strong></p>\n<blockquote>\n<p id=\"so_8290132_8290368_2\"><code>2.</code> If an object of static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy may be eliminated as specified in 12.8.</p>\n</blockquote>\n</blockquote>\n", "LastActivityDate": "2011-11-28T00:46:23.777", "CommentCount": "0", "CreationDate": "2011-11-28T00:46:23.777", "ParentId": "8290132", "Score": "1", "OwnerUserId": "918764"}});