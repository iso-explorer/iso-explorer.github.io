post_cb({"14915238": {"CommentCount": "4", "AcceptedAnswerId": "14920864", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2013-02-16T21:20:33.177", "LastActivityDate": "2013-02-17T12:08:54.090", "LastEditDate": "2013-02-17T00:05:10.413", "ViewCount": "402", "FavoriteCount": "1", "Title": "Conditional inclusion in C++11 with user-defined literal?", "Id": "14915238", "Score": "6", "Body": "<p>In C++11 when a preprocessing directive of the form...</p>\n<pre><code>#if expr\n</code></pre>\n<p>...is encountered,<code>expr</code> is evaluated as a <code>constant-expression</code> as described in <code>16.1 [cpp.cond]</code>.</p>\n<p>This is done after macro replacement on <code>expr</code>, its identifiers (and keywords) are replaced by 0, its <code>preprocessing-tokens</code> are converted to <code>tokens</code>, <code>defined</code> operator is evaluated, and so on.</p>\n<p>My question is what happens when one of the tokens in <code>expr</code> is a <code>user-defined-literal</code>?</p>\n<p>User defined literals are like function calls, but function calls can't occur in <code>expr</code> (I think), as a side effect of the identifier replacement.  However technically <code>user-defined-literals</code> could survive.</p>\n<p>I suspect it is an error, but I can't quite see how to conclude that from the standard?</p>\n<p>Perhaps the (pedantic) impact of adding user defined literals on clause 16 <code>[cpp]</code> was simply ignored?</p>\n<p>Or am I missing something?</p>\n<p><strong>Update:</strong></p>\n<p>To clarify by an example:</p>\n<p>What does this preprocess to:</p>\n<pre><code>#if 123_foo + 5.5 &gt; 100\nbar\n#else\nbaz\n#endif\n</code></pre>\n<p>bar or baz or is it an error?</p>\n<p>GCC 4.7 reports:</p>\n<pre><code>test.cpp:1:5: error: user-defined literal in preprocessor expression\n</code></pre>\n<p>so it thinks it is an error.  Can this be justified with reference to the standard?  Or is this just \"implicit\"?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1131467", "AnswerCount": "2"}, "14920864": {"ParentId": "14915238", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_14915238_14920864_0\">In C++11 when a preprocessing directive of the form... <code>#if expr ...</code>is encountered, \n  <code>expr</code> is evaluated as a <code>constant-expression</code> as described in <code>16.1 [cpp.cond]</code>.</p>\n<p id=\"so_14915238_14920864_1\">This is done after macro replacement on <code>expr</code>, its identifiers (and keywords) are \n  replaced by <code>0</code>, its <code>preprocessing-tokens</code> are converted to <code>tokens</code>, \n  <code>defined</code> operator is evaluated, and so on.</p>\n<p id=\"so_14915238_14920864_2\">My question is what happens when one of the <code>tokens</code> in <code>expr</code> is a\n  <code>user-defined-literal</code>?</p>\n</blockquote>\n<p>The program is ill-formed.</p>\n<p>The core of my argument is gleaned from the observation in <code>16.1/1</code> footnote <code>147</code>, that in translation phase 4 there are no <code>identifiers</code> other than macro names yet.</p>\n<p>Argument: </p>\n<p>According to <code>2.14.8 [lex.ext]/2</code> </p>\n<blockquote>\n<p id=\"so_14915238_14920864_3\">A <code>user-defined-literal</code> is treated as a call to a <code>literal operator</code>\n  or <code>literal operator template</code> <code>(13.5.8)</code>.</p>\n</blockquote>\n<p>So here we have a remaining call to an (operator) function even after all the substitutions described in <code>16.1/4</code>. (Other attempts, for example to use a <code>constexpr</code> function, would be thwarted by the substitution of all non-macro <code>identifiers</code>by <code>0</code>.)</p>\n<p>As this occurs in translation phase 4, there are <strong>no</strong> defined or even declared functions yet; an attempted lookup of the <code>literal-operator-id</code> must fail (see footnote 147 in <code>16.1/1</code> for a similar argument).</p>\n<p>From a slightly different angle, looking at <code>5.19/2</code>we find:</p>\n<blockquote>\n<p id=\"so_14915238_14920864_4\">A <code>conditional-expression</code> is a <code>core constant expression</code> unless it\n  involves one of the following as a potentially evaluated subexpression\n  (3.2) [...]:</p>\n<ul>\n<li>[...]</li>\n<li>an invocation of a function other than a constexpr constructor for a literal class or a constexpr function;</li>\n<li>an invocation of an undefined constexpr function or an undefined constexpr constructor [...];</li>\n</ul>\n</blockquote>\n<p>From this, use of a <code>user-defined literal</code> in a <code>constant expression</code> requires a <em>defined</em> and <em>constexpr</em> <code>literal operator</code>, which again can't be available in translation phase 4.</p>\n<p>gcc is right to reject this. </p>\n", "OwnerUserId": "585729", "LastEditorUserId": "585729", "LastEditDate": "2013-02-17T12:08:54.090", "Id": "14920864", "Score": "3", "CreationDate": "2013-02-17T12:03:12.987", "LastActivityDate": "2013-02-17T12:08:54.090"}, "14916193": {"ParentId": "14915238", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_14915238_14916193_0\">In C++11 when a preprocessing directive of the form <code>#ifdef expr</code> is encountered, <code>expr</code> is evaluated as a constant-expression as described 16.1. This is done after macro replacement on expr, its identifiers (and keywords) are replaced by 0, its preprocessing-tokens are converted to tokens, defined operator is evaluated, and so on.</p>\n</blockquote>\n<p>No!</p>\n<p>The argument to <code>#ifdef</code>, <code>#ifndef</code>, or <code>defined</code> is <em>not</em> evaluated. For example, suppose I never <code>#define</code> the preprocessor symbol <code>SYMBOL_THAT_IS_NEVER_DEFINED</code>. This is perfectly valid:</p>\n<pre><code>#ifdef SYMBOL_THAT_IS_NEVER_DEFINED\ncode\n#endif\n</code></pre>\n<p>Expanding a symbol that symbol isn't defined is illegal. This is illegal assuming <code>SYMBOL_THAT_IS_NEVER_DEFINED</code> hasn't been defined:</p>\n<pre><code>#if SYMBOL_THAT_IS_NEVER_DEFINED\ncode\n#endif\n</code></pre>\n<p>Analogous to checking whether a pointer is non-null before dereferencing it, checking whether a symbol is defined before using it is legal:</p>\n<pre><code>#if (defined SYMBOL_THAT_MIGHT_BE_DEFINED) &amp;&amp; SYMBOL_THAT_MIGHT_BE_DEFINED\ncode\n#endif\n</code></pre>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "14916193", "Score": "0", "CreationDate": "2013-02-16T23:13:30.063", "LastActivityDate": "2013-02-16T23:13:30.063"}, "bq_ids": {"n4140": {"so_14915238_14920864_4": {"section_id": 6185, "quality": 0.6, "length": 6}, "so_14915238_14920864_3": {"section_id": 5368, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_14915238_14920864_4": {"section_id": 5946, "quality": 0.9, "length": 9}, "so_14915238_14920864_3": {"section_id": 5164, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_14915238_14920864_3": {"section_id": 6793, "quality": 0.8888888888888888, "length": 8}}}});