post_cb({"bq_ids": {"n4140": {"so_27197464_27197464_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 7151}, "so_27197464_27197836_2": {"length": 8, "quality": 1.0, "section_id": 7151}, "so_27197464_27197836_3": {"length": 43, "quality": 1.0, "section_id": 7151}, "so_27197464_27197836_0": {"length": 11, "quality": 1.0, "section_id": 7156}, "so_27197464_27197551_0": {"length": 11, "quality": 1.0, "section_id": 7156}, "so_27197464_27197836_4": {"length": 14, "quality": 1.0, "section_id": 7151}, "so_27197464_27197836_1": {"length": 19, "quality": 1.0, "section_id": 7156}}, "n3337": {"so_27197464_27197836_2": {"length": 8, "quality": 1.0, "section_id": 6895}, "so_27197464_27197836_3": {"length": 43, "quality": 1.0, "section_id": 6895}, "so_27197464_27197836_0": {"length": 11, "quality": 1.0, "section_id": 6900}, "so_27197464_27197551_0": {"length": 11, "quality": 1.0, "section_id": 6900}, "so_27197464_27197836_4": {"length": 14, "quality": 1.0, "section_id": 6895}, "so_27197464_27197836_1": {"length": 19, "quality": 1.0, "section_id": 6900}}, "n4659": {"so_27197464_27197464_0": {"length": 33, "quality": 0.7333333333333333, "section_id": 8652}, "so_27197464_27197836_2": {"length": 5, "quality": 0.625, "section_id": 8652}, "so_27197464_27197836_0": {"length": 11, "quality": 1.0, "section_id": 8663}, "so_27197464_27197551_0": {"length": 11, "quality": 1.0, "section_id": 8663}, "so_27197464_27197836_4": {"length": 8, "quality": 0.5714285714285714, "section_id": 8655}, "so_27197464_27197836_1": {"length": 19, "quality": 1.0, "section_id": 8663}}}, "27197551": {"Id": "27197551", "PostTypeId": "2", "Body": "<p><code>[basic.start.term]/1</code> (N4140) says:</p>\n<blockquote>\n<p id=\"so_27197464_27197551_0\">If an object is initialized statically, the object is destroyed in the same order as if the object was dynamically initialized.</p>\n</blockquote>\n<p>As I understand, this means that for the purpose of determinig the order of destruction, all static initialization is treated as dynamic (ordered or unordered) and the destructors are called in reverse order of this initialization.</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-11-29T00:31:45.757", "Score": "1", "CreationDate": "2014-11-29T00:21:14.620", "ParentId": "27197464", "CommentCount": "5", "OwnerUserId": "3959454", "LastEditDate": "2014-11-29T00:31:45.757"}, "27197464": {"ViewCount": "267", "Body": "<p>A <a href=\"https://stackoverflow.com/a/27168696/596781\">recent question</a> drew my attention to the way that <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html\" rel=\"nofollow noreferrer\"><code>constexpr</code> has changed in C++14</a>. The new feature is that a non-local variable with static storage  duration may be initialized in the static initialization phase if its initializer consists of a <code>constexpr</code> constructor, even if the type of the variable isn't a literal type. More precisely, the new wording in [basic.start.init] is:</p>\n<blockquote>\n<p id=\"so_27197464_27197464_0\">A <em>constant initializer</em> for an object <code>o</code> is an expression that is a constant expression, except that it may also invoke constexpr constructors for <code>o</code> and its subobjects even if those objects are of non-literal class types [<em>Note</em>: such a class may have a non-trivial destructor \u2014 <em>end note</em>]. <em>Constant initialization</em> is performed [...]  if an object with static or thread storage duration is initialized by a constructor call, and if the initialization full-expression is a constant initializer for the object [...]</p>\n</blockquote>\n<p>The typical example is <code>std::unique_ptr</code>, which \"should never be worse that hand-written\":</p>\n<pre><code>std::unique_ptr&lt;int&gt; p;   // statically initialized by [unique.ptr.single.ctor],\n                          // requires no code excution\nint main()\n{\n    p = std::make_unique&lt;int&gt;(100);\n}\n\n// p is destroyed eventually\n</code></pre>\n<p>Prior to this addition, statically initialized variables were either of reference type or of literal object type, and therefore had trivial destructors. But now a statically initialized global variable can have a non-trivial destructor.</p>\n<p>How is such a destructor call ordered with respect to the destructors of dynamically initialized global objects, with respect to other statically initialized ones, and how are the destructor calls sequenced?</p>\n", "Title": "Destruction order of statically initialized, non-literal objects", "CreationDate": "2014-11-29T00:09:56.403", "LastActivityDate": "2014-11-29T14:45:55.007", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:00:49.047", "LastEditorUserId": "-1", "Id": "27197464", "Score": "10", "OwnerUserId": "596781", "Tags": "<c++><language-lawyer><c++14><termination><static-initialization>", "AnswerCount": "2"}, "27197836": {"Id": "27197836", "PostTypeId": "2", "Body": "<p>Consider</p>\n<blockquote>\n<p id=\"so_27197464_27197836_0\">If an object is initialized statically, the object is destroyed in the\n  same order as if the object was dynamically initialized.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_27197464_27197836_1\">If the completion of the constructor or dynamic initialization of an\n  object with static storage duration is sequenced before that of\n  another, the completion of the destructor of the second is sequenced\n  before the initiation of the destructor of the first.</p>\n</blockquote>\n<p>Now, </p>\n<blockquote>\n<p id=\"so_27197464_27197836_2\">Static initialization shall be performed before any dynamic\n  initialization takes place.</p>\n</blockquote>\n<p>Clearly this answers the first question: Since <code>p</code> is guaranteed to be initialized before any dynamic initialization is performed, the destructor is called <em>after</em> any dynamically initialized object is destroyed. </p>\n<p>Essentially the second question, i.e. what order the destructions of several statically initialized variables have, is reduced to the ordering of the initialization of these:</p>\n<blockquote>\n<p id=\"so_27197464_27197836_3\">Dynamic initialization of a non-local variable with static storage\n  duration is either ordered or unordered. Definitions of explicitly\n  specialized class template static data members have ordered\n  initialization. Other class template static data members (i.e.,\n  implicitly or explicitly instantiated specializations) have unordered\n  initialization. <strong>Other non-local variables with static storage\n  duration have ordered initialization.</strong></p>\n</blockquote>\n<p>The bold sentence includes all statically initialized objects that are not static data members of instantiated classes. They are ordered within one translation unit:</p>\n<blockquote>\n<p id=\"so_27197464_27197836_4\">Variables with ordered initialization defined within a single\n  translation unit shall be initialized in the order of their\n  definitions in the translation unit.</p>\n</blockquote>\n<p>So, to summarize:</p>\n<ul>\n<li><p>Variables which are subject of static initialization and are not static data members of an instantiated class are destroyed in the reverse order of definition in a translation file.</p></li>\n<li><p>... those variables are always destroyed after any dynamically initialized object is destroyed.</p></li>\n</ul>\n<p>However, despite possible argumentative mistakes, neither Clang nor GCC seem to implement it this way at the moment: <a href=\"http://coliru.stacked-crooked.com/a/a341e5edf4ac0c6f\" rel=\"nofollow\">Demo</a>.</p>\n", "LastActivityDate": "2014-11-29T01:07:41.793", "CommentCount": "4", "CreationDate": "2014-11-29T01:07:41.793", "ParentId": "27197464", "Score": "3", "OwnerUserId": "3647361"}});