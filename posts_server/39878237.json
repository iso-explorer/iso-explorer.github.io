post_cb({"40092051": {"ParentId": "39878237", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It's always true, but instead of looking at the rules for pointer arithmetic you must rely on the semantics given for the <code>sizeof</code> operator (5.3.3 <code>[expr.sizeof]</code>):</p>\n<blockquote>\n<p id=\"so_39878237_40092051_0\">When applied to a reference or a reference type, the result is the size of the referenced type. <strong>When applied to a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array.</strong> The size of a most derived class shall be greater than zero.\n  The result of applying sizeof to a base class subobject is the size of the base class type. <strong>When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of <em>n</em> elements is <em>n</em> times the size of an element.</strong></p>\n</blockquote>\n<p>It should be clear that there's only one packing that puts <em>n</em> non-overlapping elements in space of <code>n * sizeof(element)</code>, namely that they are regularly spaced <code>sizeof (element)</code> bytes apart.  And only one ordering is allowed by the pointer comparison rules found under the relational operator section (5.9 <code>[expr.rel]</code>):</p>\n<blockquote>\n<p id=\"so_39878237_40092051_1\">Comparing pointers to objects is defined as follows:</p>\n<ul>\n<li>If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to the element with the higher subscript compares greater.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2016-10-17T17:16:20.583", "Id": "40092051", "Score": "1", "CreationDate": "2016-10-17T17:10:43.463", "LastActivityDate": "2016-10-17T17:16:20.583"}, "39878591": {"ParentId": "39878237", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>In [dcl.array]:</p>\n<blockquote>\n<p id=\"so_39878237_39878591_0\">An object of array type contains a contiguously allocated non-empty\n  set of <code>N</code> subobjects of type <code>T</code>.</p>\n</blockquote>\n<p>Contiguous implies that the offset between any consecutive subobjects of type <code>T</code> is <code>sizeof(T)</code>, which implies that the offset of the <code>n</code>th subobject is <code>n*sizeof(T)</code>.</p>\n<p>The upper bound of <code>n &lt; N</code> comes from [expr.add]:</p>\n<blockquote>\n<p id=\"so_39878237_39878591_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the expression <code>P</code> points to element <code>x[i]</code> of an array object <code>x</code> with <code>n</code> elements,\n  the expressions <code>P + J</code> and <code>J + P</code> (where <code>J</code> has the value <code>j</code>) point to the (possibly-hypothetical) element <code>x[i + j]</code> if <code>0 &lt;= i + j &lt; n</code>; <strong>otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-10-05T15:57:29.510", "Id": "39878591", "Score": "8", "CreationDate": "2016-10-05T15:51:25.437", "LastActivityDate": "2016-10-05T15:57:29.510"}, "39878237": {"CommentCount": "23", "ViewCount": "665", "PostTypeId": "1", "LastEditorUserId": "472495", "CreationDate": "2016-10-05T15:34:47.967", "LastActivityDate": "2016-11-22T13:30:47.400", "Title": "T* versus char* pointer arithmetic", "FavoriteCount": "1", "LastEditDate": "2016-11-22T13:30:47.400", "Id": "39878237", "Score": "11", "Body": "<p>Assume we have an array that contains N elements of type T.</p>\n<pre><code>T a[N];\n</code></pre>\n<p><em>According to the C++14 Standard</em>, under which conditions do we have a guarantee that</p>\n<pre><code> (char*)(void*)&amp;a[0] + n*sizeof(T) == (char*)(void*)&amp;a[n],  (0&lt;=n&lt;N) ?\n</code></pre>\n<p>While this is true for many types and implementations, the standard mentions it in a footnote, and in an ambiguous way:</p>\n<blockquote>\n<p id=\"so_39878237_39878237_0\">\u00a75.7.6, footnote 85) Another way to approach pointer arithmetic ...</p>\n</blockquote>\n<p>There is little indication that this other way was thought of being equivalent to the standard's way. It might rather be a hint for implementers that suggests one of many conforming implementations.</p>\n<hr>\n<p>Edits:</p>\n<p>People have underestimated the difficulty of this question.</p>\n<p>This question is not about what you can read in textbooks, it is about what what you can deduce from the C++14 Standard through the use of logic and reason.</p>\n<p>If you use 'contiguous' or 'contiguously', please also say what is being contiguous.</p>\n<p>While T[] and T* are closely related, they are abstractions, and the addition on T* x N may be defined by the implementation in any consistent way.</p>\n<p>The equation was rearranged using pointer addition. If p points to a char, p+1 is always defined using (\u00a75.7 (4)) or unary addition, so we don't run into UB. The original included a pointer subtraction, which might have caused UB early on. (The char pointers are only compared, not dereferenced).</p>\n</hr>", "Tags": "<c++><arrays><pointers><c++14><language-lawyer>", "OwnerUserId": "6724807", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_39878237_39878591_0": {"section_id": 3228, "quality": 1.0, "length": 10}, "so_39878237_40092051_0": {"section_id": 6077, "quality": 0.9491525423728814, "length": 56}, "so_39878237_40018150_0": {"section_id": 3228, "quality": 0.8333333333333334, "length": 10}, "so_39878237_39878237_0": {"section_id": 6143, "quality": 0.5714285714285714, "length": 4}, "so_39878237_40092051_1": {"section_id": 6151, "quality": 1.0, "length": 5}, "so_39878237_40018150_1": {"section_id": 6151, "quality": 0.8666666666666667, "length": 13}, "so_39878237_39878591_1": {"section_id": 6142, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_39878237_40092051_0": {"section_id": 5845, "quality": 0.9491525423728814, "length": 56}, "so_39878237_40018150_0": {"section_id": 3101, "quality": 0.8333333333333334, "length": 10}, "so_39878237_39878591_0": {"section_id": 3101, "quality": 1.0, "length": 10}, "so_39878237_39878237_0": {"section_id": 5907, "quality": 0.5714285714285714, "length": 4}, "so_39878237_40018150_1": {"section_id": 5913, "quality": 0.7333333333333333, "length": 11}, "so_39878237_39878591_1": {"section_id": 5906, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_39878237_39878591_0": {"section_id": 3985, "quality": 1.0, "length": 10}, "so_39878237_40092051_0": {"section_id": 7573, "quality": 0.9491525423728814, "length": 56}, "so_39878237_40018150_0": {"section_id": 3985, "quality": 0.8333333333333334, "length": 10}, "so_39878237_40092051_1": {"section_id": 7648, "quality": 1.0, "length": 5}, "so_39878237_40018150_1": {"section_id": 7648, "quality": 0.8666666666666667, "length": 13}, "so_39878237_39878591_1": {"section_id": 7638, "quality": 1.0, "length": 26}}}, "40018150": {"ParentId": "39878237", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>The declaration in the first line is also a definition. (\u00a73.1(2))\nIt creates the array object. (\u00a71.8(1))</p>\n<p>An object can be accessed via multiple lvalues \ndue to the aliasing rules. (\u00a73.10(10)) In particular, the objects on the \nright hand side  may be legally accessed (aliased) through char pointers.  </p>\n<p>Lets look at a sentence in the array definition and then disambiguate 'contiguous'.</p>\n<blockquote>\n<p id=\"so_39878237_40018150_0\">\"An object of array type contains a contiguously allocated non-empty set \n  of N subobjects of type T.\" [dcl.array] \u00a78.3.4.</p>\n</blockquote>\n<hr>\n<h2>Disambiguation</h2>\n<p>We start from the binary symmetric relation 'contiguous' for char objects, which should be obvious. ('iff' is short for 'if and only if', sets and sequences are mathematical ones, not C++ containers) If you can\nlink to a better or more acknowledged definition, comment.</p>\n<p>A sequence x_1 ... x_N of char objects is contiguous iff\nx_i and x_{i+1} are contiguous in memory for all i=1...N-1.</p>\n<p>A set M of char objects is contiguous iff the objects in \nM can be numbered, x_1 ...x_N, say, such that the sequence (x_i)_i is contiguous.\nThat is, iff M is the image of a contiguous, injective sequence.</p>\n<p>Two sets M_1, M_2 of char objects are contiguous iff there\nexist x_1 in M_1 and x_2 in M_2 such that x_1 and x_2 are contiguous.</p>\n<p>A sequence M_1 ... M_N of sets of char objects is contiguous iff\nM_i and M_{i+1} are contiguous for all i=1...N-1.</p>\n<p>A set of sets of char objects is contiguous iff it is the image of\na contiguous, injective sequence of sets of char objects.</p>\n<p>Now which version of 'contiguous' to apply? Linguistic overload resolution:</p>\n<p>1) 'contiguous' may refer to 'allocation'. As an allocation function call provides a\nsubset of the available char objects, this would invoke the set-of-chars variant. That is,\nthe set of all char objects that occur in any of the N subobjects would be  meant to be contiguous. </p>\n<p>2) 'contiguous' may refer to 'set'. This would invoke the set-of-sets-of-chars variant with every subobject considered as a set of char objects.</p>\n<hr>\n<p>What does this mean? First, while the authors numbered the array subobjects a[0] ... a[N-1], they chose not to say anything about the\norder of subobjects in memory: they used 'set' instead of 'sequence'.\nThey described the allocation as contiguous, but they do not say that \na[j] and a[j+1] are contiguous in memory. Also, they chose not to write down the \nstraightforward formula involving (char*) pointers and sizeof(). While it looks like they \ndeliberately separated contiguity from ordering concerns, \n\u00a75.9 (3) requires one and the same ordering for array subobjects of all types. </p>\n<blockquote>\n<p id=\"so_39878237_40018150_1\">If pointers point to two different elements of the same array, <em>or a subobject thereof</em>, the pointer \n  to the element with the higher subscript compares greater.</p>\n</blockquote>\n<p>Now do the bytes that make up the array subobjects qualify as\nsubobjects in the sense of the above quote? Reading \u00a71.8(2) and <a href=\"https://stackoverflow.com/questions/40108184/complete-object-or-subobject\">Complete object or subobject?</a>\nthe answer is: No, at least not for arrays whose elements don't contain subobjects and are no arrays of chars, e.g. arrays of ints. So we may find examples where no particular ordering is imposed on the array elements.</p>\n<p>But for the moment let's assume that our array subobjects are populated with chars only. \nWhat does this mean considering the two possible interpretations of 'contiguous'?</p>\n<p>1) We have a contiguous set of bytes that coincides with an ordered set of subobjects.\nThen the claim in the OP is unconditionally true.</p>\n<p>2) We have a contiguous sequence of subobjects, each of which may be non-contiguous individually.\nThis may happen in two ways: either the subobjects may have gaps, that is, they \ncontain two char objects at distance greater than sizeof(subobject)-1. Or the\nsubobjects may be distributed among different sequences of contiguous bytes.</p>\n<p>In case 2) there is no guarantee that that the claim in the OP is true.</p>\n<p>Therefore, it is important to be clear about what 'contiguous' means.</p>\n<hr>\n<p>Finally, here's an example of an implementation where no obvious ordering is imposed on the array subobjects by \u00a75.9 because the array subobjects don't have subobjects themselves. Readers raised concerns that this would contradict the standard in other places, but no definite contradiction has been demonstrated yet.</p>\n<p>Assume T is int, and we have one particular conforming implementation that behaves as expected naively with one exception:</p>\n<p>It allocates arrays of ints in reversed memory order,\nputting the array's first element at the high-memory-address end of the object:</p>\n<pre><code>a[N-1], a[N-2], ... a[0]  \n</code></pre>\n<p>instead of</p>\n<pre><code>a[0], a[1],   ... a[N-1]  \n</code></pre>\n<p>This implementation satisfies any reasonable contiguity\nrequirement, so we don't have to agree on a single interpretation of \n'contiguous' to proceed with the argument.</p>\n<p>Then if p points to a, mapping p to &amp;a[0] (invoking [conv.array]) would make the pointer jump near the high memory end of a.\nAs array arithmetic has to be compatible with pointer arithmetic, we'd also have</p>\n<pre><code>int * p= &amp;intVariable;\n(char*)(p+1) + sizeof(int) == (char*)p\n</code></pre>\n<p>and </p>\n<pre><code>int a[N];\n\n(char*)(void*)&amp;a[n] + n*sizeof(int)==(char*)(void*)&amp;a[0],  (0&lt;=n&lt;N)\n</code></pre>\n<p>Then, for T=int, there is no guarantee that the claim in the original post is true.</p>\n<hr>\n<p>edit history: removed and reintroduced in modified form a possibly erroneous shortcut that was due to not applying a relevant part of the  pointer &lt; relation specification. It has not been determined yet whether this was justified or not, but the main argument about contiguity comes through anyway. </p>\n</hr></hr></hr></hr>", "OwnerUserId": "6724807", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:46.860", "Id": "40018150", "Score": "-3", "CreationDate": "2016-10-13T10:12:16.980", "LastActivityDate": "2016-10-18T16:07:08.023"}});