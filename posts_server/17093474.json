post_cb({"17093583": {"Id": "17093583", "PostTypeId": "2", "Body": "<p>Yes: you can have <code>virtual</code> destructors, and the only reason is to override them in derived classes.</p>\n<p>It looks like this:</p>\n<pre><code>class Parent {\npublic:\n    virtual ~Parent();\n};\n\nclass Child : public Parent {\npublic:\n    virtual ~Child();\n};\n\nclass Grandchild : public Child {\npublic:\n    ~Grandchild(); // virtual is inherited here\n};\n</code></pre>\n<p>Note that the destructor isn't overridden by <em>name</em> like ordinary functions, because the name is always that of the class whose instance you're destroying.</p>\n<p>Note also that the parent class' destructors are always called too, so you don't need to duplicate their cleanup code: read up on member object and base-class sub-object construction and destruction order for the details.</p>\n<hr>\n<h2>Terminology</h2>\n<ul>\n<li><em>overriding</em> a function means implementing a base-class <code>virtual</code> function in a derived class. You can't change the signature at all (except for using covariant return types). So, an <em>override</em> always has the same signature as an inherited virtual function. </li>\n<li><em>overloading</em> a function means implementing multiple functions with the same name (and in some sense the same scope). So, an <em>overload</em> always has a <em>different</em> signature to the others with the same name, doesn't relate directly to virtual dispatch, and isn't necessarily inherited.</li>\n</ul>\n</hr>", "LastEditorUserId": "212858", "LastActivityDate": "2015-09-25T10:42:14.330", "Score": "3", "CreationDate": "2013-06-13T17:40:27.360", "ParentId": "17093474", "CommentCount": "0", "OwnerUserId": "212858", "LastEditDate": "2015-09-25T10:42:14.330"}, "17093474": {"ViewCount": "13216", "Body": "<p>From the C++ FAQ:</p>\n<blockquote>\n<p id=\"so_17093474_17093474_0\">[11.4] Can I overload the destructor for my class?\n  No.</p>\n</blockquote>\n<p>I realize this means you cannot change the return type, arguments' types nor the number of arguments. I may be splitting hairs on the syntax of the words, but is it possible to <em>override</em> the Parent's destructor?</p>\n<pre><code>class Child : public Parent {\npublic:\n    virtual Parent::~Parent() {\n        // New definition\n    }\n};\n</code></pre>\n<p>And for that matter do it recursively?</p>\n<pre><code>class Grandchild : public Child {\npublic:\n    Child::Parent::~Parent() {\n        // An even newer definition\n    }\n};\n</code></pre>\n<p>I've read <a href=\"https://stackoverflow.com/questions/14184341/c-constructor-destructor-inheritance\">this</a> and a <a href=\"https://stackoverflow.com/questions/2198379/are-virtual-destructors-inherited\">related post</a> and it makes me think because destructors are not inherited, they cannot be overridden, but I've never seen it explicitly stated.</p>\n<p>EDIT: I changed this to reflect the fact that I want to override the Parent's destructor, note Child and Grandchild overriding ~Parent().</p>\n<p>The main reason I am doing this is to maintain Parent's interface while changing the way it is destroyed (the entire reason for the child class). I will have something else managing all Parent's created and will explicitly call their destructors at a later time of my choosing.</p>\n", "AcceptedAnswerId": "17093588", "Title": "Override Destructor C++", "CreationDate": "2013-06-13T17:33:46.697", "Id": "17093474", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:29:43.953", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-25T10:42:14.330", "Score": "7", "OwnerUserId": "2096544", "Tags": "<c++><inheritance><override><destructor><multiple-inheritance>", "AnswerCount": "4"}, "17093588": {"Id": "17093588", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17093474_17093588_0\">I may be splitting hairs on the syntax of the words</p>\n</blockquote>\n<p>No, you are definitely not \u2013 these are two very different things.</p>\n<blockquote>\n<p id=\"so_17093474_17093588_1\">but is it possible to override the destructor?</p>\n</blockquote>\n<p>Yes, and in fact you <em>must</em> do this in many cases. In order for this to work for a polymorphic object, you need to declare the base class destructor as <code>virtual</code>, though:</p>\n<pre><code>Parent const&amp; p = Child();\n</code></pre>\n<p>Will properly call <code>p.~Child()</code> at the end of scope because <code>Parent::~Parent</code> is virtual.</p>\n", "LastEditorUserId": "1968", "LastActivityDate": "2013-06-13T17:54:21.187", "Score": "8", "CreationDate": "2013-06-13T17:40:42.047", "ParentId": "17093474", "CommentCount": "7", "OwnerUserId": "1968", "LastEditDate": "2013-06-13T17:54:21.187"}, "bq_ids": {"n4140": {"so_17093474_17093825_0": {"length": 80, "quality": 0.9523809523809523, "section_id": 404}}, "n3337": {"so_17093474_17093825_0": {"length": 80, "quality": 0.9523809523809523, "section_id": 395}}, "n4659": {"so_17093474_17093825_0": {"length": 80, "quality": 0.9523809523809523, "section_id": 422}}}, "17093825": {"Id": "17093825", "PostTypeId": "2", "Body": "<p>Yes, it is possible to override the destructor of a class.  In fact, when you define a class hierarchy in which polymorphism is used, you <strong>must</strong> declare a virtual destructor in the base class.</p>\n<p>Overrides of destructors work exactly the same way overrides of normal member functions work in that when you destroy an object by <code>delete</code>ing the object via a pointer to the base class, the destructor of the derived class is properly called.  This is why you must have a virtual destructor in the base class for polymorphic hierarchies.</p>\n<p>However, there is a difference between virtual destructors and virtual member methods which has nothing to do with the <code>virtual</code> nature of the destructor.  That is, when executing code like this:</p>\n<pre><code>class A\n{\npublic:  \n  virtual void Foo() {}\n  virtual ~A() {};\n};\n\nclass B : public A\n{\npublic:\n  void Foo() {};\n  ~B() {}\n};\n\nint main()\n{\n  A* a = new B;\n  a-&gt;Foo();  // B::Foo() is called\n  delete a;  // B is destroyed via B::~B()\n}\n</code></pre>\n<p>...when you call <code>a-&gt;Foo()</code>, the method <code>Foo()</code> in <code>B</code> is called.  Since <code>B::Foo()</code> doesn't explicitly call <code>A::Foo()</code>, <code>A::Foo()</code> isn't called.</p>\n<p>However, when the object is destroyed via <code>delete a;</code>, first the destructor <code>B::~B()</code> is called, and then after that finishes but before control returns to the program, the base class destructor <code>A::~A()</code> is <em>also</em> called.</p>\n<p>Of course this is obvious when you think about it, and again this has nothing to do with the <code>virtual</code> nature of the destructor, but it does behave differently than a normal <code>virtual</code> method call, so I thought I'd point it out.</p>\n<p>Obligitory Standard Quotation:</p>\n<h2>[C++03] 12.4/6 : Destructors</h2>\n<blockquote>\n<p id=\"so_17093474_17093825_0\">After executing the body of the destructor and destroying any\n  automatic objects allocated within the body, a destructor for class X\n  calls the destructors for X\u2019s direct members, the destructors for X\u2019s\n  direct base classes    and, if X is the type of the most derived class\n  (12.6.2), its destructor calls the destructors for X\u2019s virtual base\n      classes. All destructors are called as if they were referenced with a qualified name, that is, ignoring any    possible virtual\n  overriding destructors in more derived classes. Bases and members are\n  destroyed in the   reverse order of the completion of their\n  constructor (see 12.6.2). A return statement (6.6.3) in a  destructor\n  might not directly return to the caller; before transferring control\n  to the caller, the destructors for the members and bases are called.\n  Destructors for elements of an array are called in reverse order of\n  their construction (see 12.6).</p>\n</blockquote>\n", "LastActivityDate": "2013-06-13T17:54:02.437", "CommentCount": "0", "CreationDate": "2013-06-13T17:54:02.437", "ParentId": "17093474", "Score": "4", "OwnerUserId": "241536"}, "17093718": {"Id": "17093718", "PostTypeId": "2", "Body": "<p>Yes; you can, and should, make a destructor virtual, whenever you have a child class which may be destroyed using a reference to the base class. Static code analysis tools will even complain if you <em>don't</em> offer a virtual destructor.</p>\n<p>Consider the following example:</p>\n<pre><code>class A\n{\npublic:\n    A() { a = new int; }\n    virtual ~A() { delete a; }\n\nprivate:\n    int *a;\n};\n\nclass B : public A\n{\npublic:\n    B() { b = new int; }\n    virtual ~B() { delete b; }\n\nprivate:\n    int *b;\n};\n\nint main()\n{\n    A *a = new B();\n    delete a;\n}\n</code></pre>\n<p>If the destructor was <em>not</em> virtual, then <code>delete a</code> would only call A's destructor, and you would end up with a memory leak. But because it's virtual, both destructors will be called, in the order <code>~B()</code> -&gt; <code>~A()</code>.</p>\n", "LastActivityDate": "2013-06-13T17:47:25.213", "CommentCount": "0", "CreationDate": "2013-06-13T17:47:25.213", "ParentId": "17093474", "Score": "0", "OwnerUserId": "2387403"}});