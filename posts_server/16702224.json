post_cb({"16702224": {"CommentCount": "0", "ViewCount": "215", "CreationDate": "2013-05-22T21:53:36.327", "LastActivityDate": "2013-05-22T22:05:42.323", "Title": "Protected destructor of policy Classes in C++", "AcceptedAnswerId": "16702313", "PostTypeId": "1", "Id": "16702224", "Score": "0", "Body": "<p>I wrote the following dumb policy struct:</p>\n<pre><code>template\n&lt;typename T&gt;\nstruct SuperLeague\n{\npublic:\n  void printLeague(){std::cout &lt;&lt; \"SuperLegue\" &lt;&lt; std::endl;};\nprotected:\n  //~SuperLeague(){}\n};\n</code></pre>\n<p>and the host class</p>\n<pre><code>template\n&lt;typename TT,template &lt;typename C&gt; class Policy&gt;\nclass League: public Policy&lt;TT&gt;\n{\npublic:\n  void fun()\n  {\n    Policy&lt;TT&gt;().printLeague();\n  }\n};\n</code></pre>\n<p>My main is </p>\n<pre><code>int main()\n{\n  League&lt;int,SuperLeague&gt; k;\n  League&lt;int,SuperLeague&gt; kk;\n  k.fun();\n  kk.printLeague();\n  League&lt;int,SuperLeague&gt; *kkk=new League&lt;int,SuperLeague&gt;();\n  kkk-&gt;fun();\n  //delete kkk;\n};\n</code></pre>\n<p>Until here, everything works fine. And the output is:</p>\n<pre><code>SuperLegue\nSuperLegue\nSuperLegue\n</code></pre>\n<p>In one of his Books Andrei Alexandrescu writes:\n<strong><em>Unless the policy class defines a virtual destructor, applying delete to a pointer to the policy class has undefined behavior</em></strong>. He explains the reasons not to use virtual destructor on the policy or protected (or private) inheritance when deriving from the policy class, and he suggests <strong><em>The lightweight, effective solution that policies should use is to define a nonvirtual protected destructor</em></strong>. The problem is that when I tried to do that using <code>~SuperLeague(){}</code> the compiler complains that the destructor is protected. What I am doing wrong?</p>\n", "Tags": "<c++><templates><destructor>", "OwnerUserId": "2277094", "AnswerCount": "2"}, "16702313": {"ParentId": "16702224", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-05-22T21:59:54.817", "Score": "2", "LastEditorUserId": "1932150", "LastEditDate": "2013-05-22T22:05:42.323", "Id": "16702313", "OwnerUserId": "1932150", "Body": "<p>You shouldn't be creating a temporary policy object inside <code>League::fun()</code>. Since your instance of the <code>League</code> template derives from the appropriate instance of the <code>Policy</code> template, it inherits the <code>printLeague()</code> function:</p>\n<pre><code>template\n&lt;typename TT,template &lt;typename C&gt; class Policy&gt;\nclass League: public Policy&lt;TT&gt;\n{\npublic:\n  void fun()\n  {\n    Policy&lt;TT&gt;::printLeague();\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  }\n};\n</code></pre>\n<p>The reason why your solution won't compile when you declare the destructor <code>protected</code> is that <code>protected</code> makes base class members accessible from a derived class when accessing an object (or dereferencing a reference or pointer to an object) <strong>of the same derived class</strong> (<code>League</code> in your case). </p>\n<p>That is not the case in your example, where you create a temporary object of type <code>Policy&lt;TT&gt;</code> and invoke <code>printLeague()</code> <em>on that object</em> (which is not of type <code>League</code>).</p>\n<p>Per paragraph 11.4/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16702224_16702313_0\">An additional access check beyond those described earlier in Clause 11 is applied when a non-static data\n  member or non-static member function is a protected member of its naming class (11.2). As described\n  earlier, access to a protected member is granted because the reference occurs in a friend or member of some\n  class C. If the access is to form a pointer to member (5.3.1), the nested-name-specifier shall denote C or a\n  class derived from C. All other accesses involve a (possibly implicit) object expression (5.2.5). <strong>In this case,\n  the class of the object expression shall be C or a class derived from C</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2013-05-22T22:05:42.323"}, "16702334": {"ParentId": "16702224", "CommentCount": "0", "CreationDate": "2013-05-22T22:01:46.610", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "16702334", "Score": "1", "Body": "<pre><code>Policy&lt;TT&gt;().printLeague();\n</code></pre>\n<p>This creates an object of type <code>Policy&lt;TT&gt;</code>, calls <code>printLeague()</code> on that object, then destroys the object. The compiler is complaining about destroying the object, because the destructor is protected.</p>\n<p>Since <code>Policy&lt;TT&gt;</code> is a base class, just call <code>printLeague()</code> directly.</p>\n", "LastActivityDate": "2013-05-22T22:01:46.610"}, "bq_ids": {"n4140": {"so_16702224_16702313_0": {"section_id": 6695, "quality": 0.9491525423728814, "length": 56}}, "n3337": {"so_16702224_16702313_0": {"section_id": 6450, "quality": 0.9491525423728814, "length": 56}}, "n4659": {"so_16702224_16702313_0": {"section_id": 8170, "quality": 0.9491525423728814, "length": 56}}}});