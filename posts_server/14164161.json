post_cb({"14164308": {"Id": "14164308", "PostTypeId": "2", "Body": "<p>Because C++ permits the overloading of functions based on the type of their parameters, and because functions can be placed in non-global scope (both of which are not allowed in Standard C), the simple name of the lexically-enclosing function is not sufficient to identify it.</p>\n<p>For example, consider:</p>\n<pre><code>class A {\npublic:\n    A() {\n        std::cout &lt;&lt; __func__ &lt;&lt; std::endl;\n    }\n    void funca() {\n        std::cout &lt;&lt; __func__ &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    A a;\n    a.funca();\n}\n</code></pre>\n<p>What should it print?</p>\n<p>GCC will produce a program that prints \"A\" and \"funca\", but the standard permits it to print \"A::A\" and \"a::funca,\" which the C standard would not allow.</p>\n", "LastActivityDate": "2013-01-04T20:18:35.963", "Score": "3", "CreationDate": "2013-01-04T20:18:35.963", "ParentId": "14164161", "CommentCount": "0", "OwnerUserId": "33345"}, "bq_ids": {"n4140": {"so_14164161_14164161_2": {"length": 20, "quality": 0.7142857142857143, "section_id": 3269}}, "n3337": {"so_14164161_14164161_2": {"length": 20, "quality": 0.7142857142857143, "section_id": 3141}}, "n4659": {"so_14164161_14164161_2": {"length": 20, "quality": 0.7142857142857143, "section_id": 4027}}}, "14164161": {"ViewCount": "887", "Body": "<p>Am i really right that C standards guarantees that _ _ func _ _ value is always the name of the enclosing function, while in C++ (i mean C++11, of course) it can be any implementation-defined string (for example, if we have function foo without parameters, we can get something like \"Some string fdgdg asdfs fsdf sd\")?</p>\n<p><strong>ISO/IEC 9899:2011</strong></p>\n<p>6.4.2.2 Predefined identifiers</p>\n<blockquote>\n<p id=\"so_14164161_14164161_0\">Semantics</p>\n<p id=\"so_14164161_14164161_1\">1 The identifier _ _ func _ _ shall be implicitly declared by the\n  translator as if, immediately following the opening brace of each\n  function definition, the declaration static const char _ <em>func</em> _ [] =\n  \"function-name\"; appeared, where <strong>function-name is the name of the\n  lexically-enclosing function</strong>.</p>\n</blockquote>\n<p><strong>ISO/IEC 14882:2011</strong></p>\n<p>8.4.1 In general [dcl.fct.def.general]</p>\n<blockquote>\n<p id=\"so_14164161_14164161_2\">8 The function-local predefined variable _ _ func _ _ is defined as if a\n  definition of the form static const char _ _ func _ _ [] = \"function-name\n  \"; had been provided, where <strong>function-name is an implementation-defined\n  string</strong>. It is unspecified whether such a variable has an address\n  distinct from that of any other object in the program.</p>\n</blockquote>\n<p>And what's the reason for this? Return something like \"Unknown\" if we can't receive current function name?</p>\n", "AcceptedAnswerId": "14164238", "Title": "__func__ value difference between C and C++", "CreationDate": "2013-01-04T20:08:26.157", "Id": "14164161", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-01-04T20:18:35.963", "Score": "8", "OwnerUserId": "1608835", "Tags": "<c++><c><c++11><c99><c11>", "AnswerCount": "3"}, "14164238": {"Id": "14164238", "PostTypeId": "2", "Body": "<p>What's the \"name\" of a function in C++?</p>\n<ul>\n<li>Is it qualified by its namespace?</li>\n<li>Are overloaded functions named by their parameter types?</li>\n<li>What about return type, which isn't used for overloading?</li>\n<li>What happens in function templates?</li>\n<li>Is calling convention part of the name?</li>\n<li>Should 'const' and 'volatile' be written before or after the type name?</li>\n</ul>\n<p>An \"implementation-defined string\" gives the compiler some flexibility in how it stuffs all this information into the string.  And it sends you, the programmer, a message that you shouldn't try to perform string comparison or parsing, or in fact do anything except log the value, if you want portability.</p>\n<p>(You can't even compare these values to each other, because there's no guarantee they're unique.  It seems possible that all overloads could yield the same string.  So using it for compiling profiler statistics is ill-advised.)</p>\n", "LastActivityDate": "2013-01-04T20:14:12.250", "Score": "14", "CreationDate": "2013-01-04T20:14:12.250", "ParentId": "14164161", "CommentCount": "7", "OwnerUserId": "103167"}, "14164240": {"Id": "14164240", "PostTypeId": "2", "Body": "<p>I suspect this is to permit the C++ compiler to use the mangled name in <code>__func__</code>.</p>\n", "LastActivityDate": "2013-01-04T20:14:28.577", "Score": "4", "CreationDate": "2013-01-04T20:14:28.577", "ParentId": "14164161", "CommentCount": "0", "OwnerUserId": "367273"}});