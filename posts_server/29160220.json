post_cb({"29160384": {"ParentId": "29160220", "CommentCount": "0", "Body": "<p>The masking with AND is better sind it doesn't depend on the signedness of the value. </p>\n<p>But the most efficient way to take the lower 32 bit is to assign it to a 32-bit variable.</p>\n<pre><code>uint64_t u = 0x1122334455667788;\nuint32_t n;\n\nn = static_cast&lt;uint32_t&gt;(u);  // 0x55667788\n</code></pre>\n<p>The difference to a bit-wise AND is that the CPU just takes the lower part without doing any logical operation.</p>\n<p>If you have a 32-bit CPU it just ignores the upper value stored in a second register or memory place.</p>\n<p>If you have a 64-bit CPU it has a single instruction to extend (unsigned) a 32 bit value to 64 bit value.</p>\n", "OwnerUserId": "266487", "PostTypeId": "2", "Id": "29160384", "Score": "4", "CreationDate": "2015-03-20T06:05:26.217", "LastActivityDate": "2015-03-20T06:05:26.217"}, "29160220": {"CommentCount": "2", "ViewCount": "975", "CreationDate": "2015-03-20T05:51:43.873", "LastActivityDate": "2015-03-20T06:15:23.287", "Title": "Which way is better to get lower 32 bits of a 64 bits integer", "AcceptedAnswerId": "29160271", "PostTypeId": "1", "Id": "29160220", "Score": "10", "Body": "<p>I found that in some answers they recommended using </p>\n<p><code>lower = (some_var &lt;&lt; 32) &gt;&gt; 32;</code></p>\n<p>But I tested and found the following is faster:</p>\n<p><code>lower = some_var &amp; 0xffffffff;</code></p>\n<p>So which is better? Is the former safer in some cases or faster after compiler optimized?</p>\n", "Tags": "<c++>", "OwnerUserId": "4070719", "AnswerCount": "5"}, "29160513": {"ParentId": "29160220", "CommentCount": "0", "Body": "<p>Adding to what others said, based on the compiler you use the second option might be faster because <strong>if not optimized</strong>, the first option is implemented as 2 cpu instructions while the second option is one cpu instruction. That may be the reason for your observation of performance boost using the second option.  </p>\n", "OwnerUserId": "1526059", "PostTypeId": "2", "Id": "29160513", "Score": "1", "CreationDate": "2015-03-20T06:15:23.287", "LastActivityDate": "2015-03-20T06:15:23.287"}, "29160287": {"ParentId": "29160220", "CommentCount": "0", "Body": "<p>I think both are equally good. However using bitwise operator would be a better(<em>not sure if there is any performance difference</em>) approach as the standard says:</p>\n<blockquote>\n<p id=\"so_29160220_29160287_0\"><strong>6.5.7 Bitwise shift operators</strong></p>\n<p id=\"so_29160220_29160287_1\">4 The result of E1 &lt;&lt; E2 is E1\n  left-shifted E2 bit positions; vacated\n  bits are filled with zeros. If E1 has\n  an unsigned type, the value of the\n  result is E1 \u00d7 2E2, reduced modulo one\n  more than the maximum value\n  representable in the result type. If\n  E1 has a signed type and nonnegative\n  value, and E1 \u00d7 2E2 is representable\n  in the result type, then that is the\n  resulting value; otherwise, the\n  behavior is undefined. </p>\n</blockquote>\n", "OwnerUserId": "1501794", "PostTypeId": "2", "Id": "29160287", "Score": "0", "CreationDate": "2015-03-20T05:57:07.853", "LastActivityDate": "2015-03-20T05:57:07.853"}, "29160499": {"ParentId": "29160220", "CommentCount": "0", "Body": "<p>A good optimizer would generate the same code in both cases. To me this is the most straight forward method: <code>lower = some_var &amp; 0xffffffff;</code> The other form may generate unnecessary shiftage.</p>\n<p>Sometimes I use union to overlap variables when I want to be absolutely sure the compiler doesn't mess things up.</p>\n<p>For example:</p>\n<pre><code>typedef union {\n    int64 QWORD;\n    int32 DWORD[2];\n} overlapper64;\n\noverlapper someVariable;\n</code></pre>\n<p>Then access it as:</p>\n<pre><code>someVariable.QWORD;\n\nint32 myVar32 = someVariable.DWORD[0];\n</code></pre>\n<p>Depending on platform/compiler the order in which the overlap occurs may vary.\nBe sure to test it on your specific platform.\nIn C, I use a bunch of platform specific #ifdefs to control the order automatically.</p>\n", "OwnerUserId": "1294086", "PostTypeId": "2", "Id": "29160499", "Score": "1", "CreationDate": "2015-03-20T06:14:16.613", "LastActivityDate": "2015-03-20T06:14:16.613"}, "29160271": {"ParentId": "29160220", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-03-20T05:55:48.850", "Score": "7", "LastEditorUserId": "410767", "LastEditDate": "2015-03-20T06:08:17.553", "Id": "29160271", "OwnerUserId": "410767", "Body": "<p>Masking with <code>&amp;</code> is better:</p>\n<ul>\n<li><code>&amp;</code> is reliable for signed and unsigned <code>some_var</code>, while bitshifting right a negative number produces an implementation defined result:</li>\n</ul>\n<blockquote>\n<p id=\"so_29160220_29160271_0\">The value of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. [...] If E1 has a signed type and a negative value, the resulting value is implementation-defined.</p>\n</blockquote>\n<ul>\n<li>on every CPU I've ever known (Z80, 6502C, x86, 68000, UltraSparc), bitwise-AND is a single CPU instruction and takes one clock cycle... it's extremely unlikely to be slower or take more bytes of machine code than the bit-shifting approach you mention, though the compiler might optimise that to a bitwise AND anyway.</li>\n</ul>\n<p>The one disadvantage of masking is that it's relatively easy to accidentally have 7 or 9 <code>F</code>s, whereas a typo in <code>32</code> is obvious: there are other ways to generate the masking value though, e.g. <code>(1LL&lt;&lt;32)-1</code>, or the hackish but somehow elegant <code>uint32_t(-1)</code>.</p>\n<p>Of course, if <code>lower</code> is <code>uint32_t</code> and <code>some_var</code> <code>uint64_t</code>, you can just let the conversion be implicit, so the optimiser doesn't even need to realise the bitwise-AND can be removed before assignment, but that might give you a compiler warning, which you can silence ala...</p>\n<pre><code>uint32_t lower = static_cast&lt;uint32_t&gt;(some_var);\n</code></pre>\n<p>The masking is mainly useful when assigning to another <code>uint64_t</code>, or when the mask isn't for all the 32 least significant bits.</p>\n", "LastActivityDate": "2015-03-20T06:08:17.553"}, "bq_ids": {"n4140": {"so_29160220_29160271_0": {"section_id": 6148, "quality": 0.8333333333333334, "length": 10}, "so_29160220_29160287_1": {"section_id": 6147, "quality": 0.8421052631578947, "length": 32}}, "n3337": {"so_29160220_29160271_0": {"section_id": 5911, "quality": 0.8333333333333334, "length": 10}, "so_29160220_29160287_1": {"section_id": 5910, "quality": 0.8421052631578947, "length": 32}}, "n4659": {"so_29160220_29160271_0": {"section_id": 7644, "quality": 0.8333333333333334, "length": 10}, "so_29160220_29160287_1": {"section_id": 7643, "quality": 0.8421052631578947, "length": 32}}}});