post_cb({"bq_ids": {"n4140": {"so_9903718_9904241_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 261}}, "n3337": {"so_9903718_9904241_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 252}}, "n4659": {"so_9903718_9904241_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 268}}}, "9903778": {"Id": "9903778", "PostTypeId": "2", "Body": "<p>You mean you want to change the headers that are shipped with the library? It's in no way guaranteed that adding <code>friend</code> declarations there will work. You <em>might</em> mess up the linking part, even if your compiler says it's ok.</p>\n<p>Also, if those members are <code>private</code>, you just don't access them.</p>\n", "LastActivityDate": "2012-03-28T08:29:58.900", "Score": "1", "CreationDate": "2012-03-28T08:29:58.900", "ParentId": "9903718", "CommentCount": "7", "OwnerUserId": "673730"}, "9904241": {"Id": "9904241", "PostTypeId": "2", "Body": "<p>It is technically <em>undefined behavior</em> to use a different sequence of tokens to define the same entity (here a class) in different Translation Units.</p>\n<p>Whatever the technic you use, as long as it alters the sequence of tokens composing it, it is evil from the Standard point of view (though likely to work in practice).</p>\n<p>Johannes <a href=\"http://bloglitb.blogspot.fr/2011/12/access-to-private-members-safer.html\" rel=\"nofollow noreferrer\">discovered a way</a> to do so while respecting the Standard. It is based on the fact that even though <code>a</code> is a private attribute in class <code>A</code>, <code>&amp;A::a</code> can be written in contexts that cannot write <code>A.a</code> (perhaps an oversight in the Standard ?).</p>\n<p>Core method:</p>\n<pre><code>template&lt;typename Tag, typename Tag::type M&gt;\nstruct Rob { \n  friend typename Tag::type get(Tag) {\n    return M;\n  }\n};\n\n// use\nstruct A {\n  A(int a):a(a) { }\nprivate:\n  int a;\n};\n\n// tag used to access A::a\nstruct A_f { \n  typedef int A::*type;\n  friend type get(A_f);\n};\n\ntemplate struct Rob&lt;A_f, &amp;A::a&gt;;\n\nint main() {\n  A a(42);\n  std::cout &lt;&lt; \"proof: \" &lt;&lt; a.*get(A_f()) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Extension for simplicity:</p>\n<pre><code>template&lt;typename Tag, typename Member&gt;\nstruct TagBase {\n  typedef Member type;\n  friend type get(Tag);\n};\n\nstruct A_f : TagBase&lt;A_f, int A::*&gt; { };\n</code></pre>\n<p><strong>EDIT</strong>:</p>\n<p>This trick is (amusingly) <a href=\"https://stackoverflow.com/a/9907600/147192\">explicitly allowed</a> by the Standard</p>\n<blockquote>\n<p id=\"so_9903718_9904241_0\"><strong>\u00a714.7.2/12</strong> The usual access checking rules do not apply to names used to specify explicit instantiations. [...]</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-28T12:45:10.210", "Score": "1", "CreationDate": "2012-03-28T09:01:17.437", "ParentId": "9903718", "CommentCount": "4", "LastEditDate": "2017-05-23T12:20:14.700", "OwnerUserId": "147192"}, "9903718": {"ViewCount": "823", "Body": "<p>I have a static library written in C++. I have also got the header files for the classes defined in the static library.</p>\n<p>Can I access the private members of the classes defined in the static library introducing a friend function in class declaration ?</p>\n", "AcceptedAnswerId": "9903778", "Title": "Friend function access the private members of class defined in static library", "CreationDate": "2012-03-28T08:26:48.660", "Id": "9903718", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-03-28T12:45:10.210", "Score": "1", "OwnerUserId": "718542", "Tags": "<c++><g++><static-libraries><elf><friend-function>", "AnswerCount": "2"}});