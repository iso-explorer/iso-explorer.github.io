post_cb({"bq_ids": {"n4140": {"so_38374743_38378053_0": {"length": 35, "quality": 1.0, "section_id": 278}}, "n3337": {"so_38374743_38378053_0": {"length": 35, "quality": 1.0, "section_id": 269}}, "n4659": {"so_38374743_38378053_0": {"length": 35, "quality": 1.0, "section_id": 285}}}, "38378053": {"Id": "38378053", "PostTypeId": "2", "Body": "<p>According to \u00a714.7.3.16:</p>\n<blockquote>\n<p id=\"so_38374743_38378053_0\">In an explicit specialization declaration for a member of a class template or a member template that appears in namespace scope, the member template and some of its enclosing class templates may remain unspecialized, except that the declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized as well.</p>\n</blockquote>\n<p>Still, you can use std::enable_if to partial-specialize your contructor:</p>\n<pre><code>template &lt;class Scalar, class Element&gt; struct DataSet\n{\n    template &lt;class T&gt;\n    DataSet(std::vector&lt;T&gt; const &amp; input, std::enable_if_t&lt;!std::is_same&lt;T, SomeClass&gt;{}&gt; * = nullptr) {\n        std::cout &lt;&lt; \"Element\\n\";\n    }\n    template &lt;class T&gt;\n    DataSet(std::vector&lt;T&gt; const &amp; input, std::enable_if_t&lt;std::is_same&lt;T, SomeClass&gt;{}&gt; * = nullptr) {\n        std::cout &lt;&lt; \"SomeClass\\n\";\n    }\n};\n</code></pre>\n<p>But this way is restrictive:</p>\n<ul>\n<li>all your conditions must be exclusives</li>\n<li>you'll have to modify the code of your class for every new class you want to handle.</li>\n</ul>\n<p>Instead, I'd advise you to use a template helper structure:</p>\n<pre><code>DataSet(std::vector&lt;Element&gt; const &amp; input) {\n    Helper&lt;Element&gt;::do_it(input);\n}\n</code></pre>\n<p>that you can specialize as you want:</p>\n<pre><code>template &lt;class Element&gt;\nstruct Helper {\n    static void do_it(std::vector&lt;Element&gt; const &amp; input) {\n        std::cout &lt;&lt; \"General form with Element\\n\";\n    }\n};\n\n\ntemplate&lt;&gt;\nstruct Helper&lt;SomeClass&gt; {\n    static void do_it(std::vector&lt;SomeClass&gt; const &amp; input) {\n        std::cout &lt;&lt; \"SomeClass\\n\";\n    }\n};\n\ntemplate&lt;&gt;\nstruct Helper&lt;SomeOtherClass&gt; {\n    static void do_it(std::vector&lt;SomeOtherClass&gt; const &amp; input) {\n        std::cout &lt;&lt; \"SomeOtherClass\\n\";\n    }\n};\n\n...\n</code></pre>\n", "LastEditorUserId": "3893262", "LastActivityDate": "2016-07-14T16:28:20.603", "Score": "3", "CreationDate": "2016-07-14T15:16:56.933", "ParentId": "38374743", "CommentCount": "9", "OwnerUserId": "3893262", "LastEditDate": "2016-07-14T16:28:20.603"}, "38374875": {"Id": "38374875", "PostTypeId": "2", "Body": "<p>When defining your constructor, you didn't explicitly provide both template arguments for its class. That would need to be revised as follows:</p>\n<pre><code>template&lt;typename T_Scalar, typename T_Element&gt;\nDataSet&lt;T_Scalar, T_Element&gt;                    // template args for type\n::DataSet(std::vector&lt;T_Element&gt; const &amp;input)  // but none for constructor\n{\n    // stuff\n}\n</code></pre>\n<p>Tangentially related: Unlike methods, <a href=\"https://stackoverflow.com/questions/984394/why-not-infer-template-parameter-from-constructor\">template arguments for classes cannot be deduced from constructor calls</a>. That is: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0091r0.html\" rel=\"nofollow noreferrer\">until C++17 comes around</a>! woo!</p>\n<p>The next stumbling block you faced is that template specialisations do not 'inherit' members from their primary template. It is somewhat intuitive to assume they would, but it's just not so. Until I find an official rationale, I <em>presume</em> it's because template arguments might make certain members totally inapplicable to a specialisation, rendering implicit 'inheritance' problematic. If so, it would've been decided to require full redeclaration / not judged worthwhile to add arcane syntax to specify which primary 'base' members are 'inherited'... when you can simply use <em>real</em> inheritance to ensure they are.</p>\n<p>Anyway, what that means is that to get a partial specialisation, you need to declare the whole thing - in this case, the class and its constructor - before you can specialise that constructor's definition. You hadn't declared these ahead of time, so the compiler rightly complained that it couldn't see a declaration.</p>\n<pre><code>// Define specialised class\ntemplate&lt;typename T_Scalar&gt;\nclass DataSet&lt;T_Scalar, SomeClass&gt;\n{\npublic:\n    // Declare its ctor\n    DataSet(std::vector&lt;SomeClass&gt; const &amp;);\n}\n\n// Implement its ctor\ntemplate&lt;typename T_Scalar&gt;\nDataSet&lt;T_Scalar, SomeClass&gt; // complete template args\n::DataSet(std::vector&lt;SomeClass&gt; const &amp;input)\n{\n    // stuff\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8ea807cb9cc84e11\" rel=\"nofollow noreferrer\">See my working example of an equivalent template class, showing general vs. specialised instantiations.</a></p>\n<p>To add to your original confusion, which is fair! - note that out-of-line definitions can get very complicated indeed if a template class itself contains a template function, because then you need <em>2</em> <code>template</code> clauses, e.g.</p>\n<pre><code>template&lt;typename TA, typename TB&gt;\nclass Widget {\n    template&lt;typename TC&gt;\n    void accept_gadget(TC &amp;&amp;gadget);\n};\n\ntemplate&lt;typename TA, typename TB&gt;\ntemplate&lt;typename TC&gt;\nWidget&lt;TA, TB&gt;\n::accept_gadget(TC &amp;&amp;gadget)\n{\n    /* ... */\n}\n</code></pre>\n<p>Something that will help a lot in many contexts, especially including such out-of-line template definitions, is if <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0223r0.html\" rel=\"nofollow noreferrer\">the proposal to allow <code>namespace class</code></a> is accepted in a future version. Very sad this didn't make it into C++17... and very odd that it was ever missing in the 1st place!</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-15T07:43:53.280", "Score": "3", "CreationDate": "2016-07-14T12:56:46.700", "ParentId": "38374743", "CommentCount": "11", "OwnerUserId": "2757035", "LastEditDate": "2017-05-23T12:22:33.153"}, "38374743": {"ViewCount": "159", "Body": "<p>I'm currently implementing a dataset helper class template storing floating point values (<code>Scalar</code>) in a dynamically sized <code>Eigen::Matrix</code> constructed from a vector of different values types (<code>Element</code>) additionally storing a reference to this input vector. Now i want to partially specialize the constructor in the vector value type remaining a template in the scalar type to be explicitly instantiated. </p>\n<p>Unfortunately i'm getting \"unable to match function definition to an existing declaration\" on VS 2010. The code is as simple as:</p>\n<pre><code>template &lt;class Scalar, class Element&gt; struct DataSet\n{\n    DataSet(std::vector&lt;Element&gt; const &amp; source);\n\n    // several generic member functions here ...\n\n    Eigen::Matrix&lt;Scalar, ...  &gt; data;\n    std::vector&lt;Element&gt; const &amp; source;\n};\n\ntemplate&lt;class Scalar&gt;\nDataSet&lt;Scalar, SomeClass&gt;::DataSet(std::vector&lt;SomeClass&gt; const &amp; input)\n{\n    // special impl for Element==SomeClass ...\n}\n</code></pre>\n<p>SomeClass should be automatically be figured out by the compiler, when done right but i tried all meaningful combinations but still getting:</p>\n<pre><code>*.cpp(79) C2244 : unable to match function definition to an existing declaration\nsee declaration of 'DataSet&lt;Scalar, Element&gt;::DataSet'\n</code></pre>\n<p>I was not able to find a matching example by searching the internet yet. Thanks in advance!</p>\n<p><strong>EDIT</strong>:</p>\n<p>To make it more specific, in my real world case i want to be able to define several partial specializations to the constructor with different types for <code>Element</code> e.g:</p>\n<pre><code>template&lt;Scalar&gt;\nDataSet&lt;Scalar, FirstClass&gt;::DataSet(std::vector&lt;FirstClass&gt; const &amp; first)\n: data()\n, source(first)\n{\n    // special impl here ...\n}\n\ntemplate&lt;Scalar&gt;\nDataSet&lt;Scalar, std::shared_ptr&lt;SecondClass&gt; &gt;::DataSet(std::vector&lt;std::shared_ptr&lt;SecondClass&gt; &gt; const &amp; second)\n: data()\n, source(second)\n{\n    // special impl here ...\n}\n</code></pre>\n<p>Redeclaring/specializing the class completely to a certain typename is not desired. Then there is little use to be a template at all. I want the solution as it is, otherwise there might be other strategies to my problem. </p>\n<p><strong>FIN</strong>:</p>\n<p>Since it looks like not being possible to share the type <code>Element</code> between class template and constructor by only specializing the constructor (which is somehow related to an implicit specialization of the class) i removed the reference <code>source</code> from the class template entirely and copied the needed information into a generic container and implemented the constructors via overloads.</p>\n", "AcceptedAnswerId": "38378053", "Title": "C++, partial specialization of 2-argument class template: unable to match function definition to an existing declaration", "CreationDate": "2016-07-14T12:51:16.227", "Id": "38374743", "CommentCount": "0", "LastEditDate": "2016-07-15T07:28:16.023", "PostTypeId": "1", "LastEditorUserId": "6568982", "LastActivityDate": "2016-07-15T07:43:53.280", "Score": "3", "OwnerUserId": "6568982", "Tags": "<c++><templates>", "AnswerCount": "2"}});