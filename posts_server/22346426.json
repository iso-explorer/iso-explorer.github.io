post_cb({"22346933": {"ParentId": "22346426", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Here are some quotes from the C Standard that can help to understand initialization of arrays.</p>\n<blockquote>\n<p id=\"so_22346426_22346933_0\">20 If the aggregate or union contains elements or members that are\n  aggregates or unions, these rules apply recursively to the\n  subaggregates or contained unions. If the initializer of a\n  subaggregate or contained union begins with a left brace, the\n  initializers enclosed by that brace and its matching right brace\n  initialize the elements or members of the subaggregate or the\n  contained union. Otherwise, only enough initializers from the list are\n  taken to account for the elements or members of the subaggregate or\n  the first member of the contained union; any remaining initializers\n  are left to initialize the next element or member of the aggregate of\n  which the current subaggregate or contained union is a part.</p>\n<p id=\"so_22346426_22346933_1\">21 If there are fewer initializers in a brace-enclosed list than there\n  are elements or members of an aggregate, or fewer characters in a\n  string literal used to initialize an array of known size than there\n  are elements in the array, the remainder of the aggregate shall be\n  initialized implicitly the same as objects that have static storage\n  duration.</p>\n<p id=\"so_22346426_22346933_2\">22 If an array of unknown size is initialized, its size is determined\n  by the largest indexed element with an explicit initializer. The array\n  type is completed at the end of its initializer list.</p>\n</blockquote>\n<p>And here is an example from the Standard</p>\n<pre><code>int y[4][3] = {\n    { 1, 3, 5 },\n    { 2, 4, 6 },\n    { 3, 5, 7 },\n};\n</code></pre>\n<blockquote>\n<p id=\"so_22346426_22346933_3\">is a definition with a fully bracketed initialization: 1, 3, and 5 initialize the first row of y (the array object y[0]), namely y[0][0], y[0][1], and y[0][2]. Likewise the next two lines initialize y[1] and y[2]. The initializer ends early, so y[3] is initialized with zeros. Precisely the same effect could have been achieved by</p>\n</blockquote>\n<pre><code>int y[4][3] = {\n    1, 3, 5, 2, 4, 6, 3, 5, 7\n};\n</code></pre>\n<blockquote>\n<p id=\"so_22346426_22346933_4\">The initializer for y[0] does not begin with a left brace, so three items from the list are used. Likewise the next three are taken successively for y[1] and y[2].</p>\n</blockquote>\n", "OwnerUserId": "2877241", "LastEditorUserId": "147192", "LastEditDate": "2014-03-12T10:14:05.473", "Id": "22346933", "Score": "2", "CreationDate": "2014-03-12T09:22:21.957", "LastActivityDate": "2014-03-12T10:14:05.473"}, "22346864": {"ParentId": "22346426", "CommentCount": "3", "Body": "<p>The following is from A8.7 of \"The C Programming Language\" by K&amp;R, 2nd edition, page 220</p>\n<pre><code>float y[4][3] = {\n    { 1, 3, 5 },    \n    { 2, 4, 6 },\n    { 3, 5, 7 }\n};\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>float y[4][3] = {\n   1, 3, 5, 2, 4, 6, 3, 5, 7 \n};\n</code></pre>\n<p>Note that in both cases, the fourth row of the array will be initialized with zero, since not enough initializers were specified.</p>\n<pre><code>float y[4][3] = { \n    { 1 }, { 2 }, { 3 }, { 4 } \n};\n</code></pre>\n<p>initializes the first column of y and leaves the rest 0.  </p>\n<p>So the compiler doesn't ignore the inner braces.  However, the inner braces are not required if you specify all of the initializers in order with no gaps.  Using the inner braces gives you more control over the initialization if you don't want to specify a full set of initializers.</p>\n", "OwnerUserId": "3386109", "PostTypeId": "2", "Id": "22346864", "Score": "6", "CreationDate": "2014-03-12T09:19:20.763", "LastActivityDate": "2014-03-12T09:19:20.763"}, "22346899": {"ParentId": "22346426", "CommentCount": "0", "Body": "<p>I guess, this chapter is relevant:</p>\n<blockquote>\n<h1>8.5.1 Aggregates</h1>\n<p id=\"so_22346426_22346899_0\">(...)</p>\n<p id=\"so_22346426_22346899_1\">When initializing a multi-dimensional array, the initializer-clauses initialize the elements with the last (rightmost) index of the array varying the fastest (8.3.4). [ Example:</p>\n</blockquote>\n<pre><code>int x[2][2] = { 3, 1, 4, 2 };\n</code></pre>\n<blockquote>\n<p id=\"so_22346426_22346899_2\">initializes <code>x[0][0]</code> to 3, <code>x[0][1]</code> to 1, <code>x[1][0]</code> to 4, and <code>x[1][1]</code> to 2. On the other hand,</p>\n</blockquote>\n<pre><code>float y[4][3] = {\n    { 1 }, { 2 }, { 3 }, { 4 }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_22346426_22346899_3\">initializes the first column of y (regarded as a two-dimensional array) and leaves the rest zero. \u2014end example ]</p>\n<p id=\"so_22346426_22346899_4\">In a declaration of the form</p>\n</blockquote>\n<pre><code>T x = { a };\n</code></pre>\n<blockquote>\n<p id=\"so_22346426_22346899_5\">braces can be elided in an initializer-list as follows.105 If the initializer-list begins with a left brace, then the succeeding comma-separated list of initializer-clauses initializes the members of a subaggregate; it is erroneous for there to be more initializer-clauses than members. If, however, the initializer-list for a subaggregate does not begin with a left brace, then only enough initializer-clauses from the list are taken to initialize the members of the subaggregate; any remaining initializer-clauses are left to initialize the next member of the aggregate of which the current subaggregate is a member. [ Example:</p>\n</blockquote>\n<pre><code>float y[4][3] = {\n    { 1, 3, 5 },\n    { 2, 4, 6 },\n    { 3, 5, 7 },\n};\n</code></pre>\n<blockquote>\n<p id=\"so_22346426_22346899_6\">is a completely-braced initialization: 1, 3, and 5 initialize the first row of the array <code>y[0]</code>, namely <code>y[0][0]</code>, <code>y[0][1]</code>, and <code>y[0][2]</code>. Likewise the next two lines initialize <code>y[1]</code> and <code>y[2]</code>. The initializer ends early and therefore <code>y[3]</code>s elements are initialized as if explicitly initialized with an expression of the form float(), that is, are initialized with 0.0. In the following example, braces in the initializer-list are elided; however the initializer-list has the same effect as the completely-braced initializer-list of the above example,</p>\n</blockquote>\n<pre><code>float y[4][3] = {\n    1, 3, 5, 2, 4, 6, 3, 5, 7\n};\n</code></pre>\n<blockquote>\n<p id=\"so_22346426_22346899_7\">The initializer for y begins with a left brace, but the one for y[0] does not, therefore three elements from the list are used. Likewise the next three are taken successively for <code>y[1]</code> and <code>y[2]</code>. \u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "453803", "PostTypeId": "2", "Id": "22346899", "Score": "1", "CreationDate": "2014-03-12T09:20:53.437", "LastActivityDate": "2014-03-12T09:20:53.437"}, "22346962": {"ParentId": "22346426", "CommentCount": "0", "Body": "<p>The language specification does state that \"fields that aren't given will be zero\" in array initialization:</p>\n<p>Section 8.5: paragpraph 7 of n3337 version of C++11 Standard:</p>\n<blockquote>\n<p id=\"so_22346426_22346962_0\">If there are fewer initializer-clauses in the list than there are\n  members in the aggregate, then each member not explicitly initialized\n  shall be initialized from an empty initializer list (8.5.4).  [\n  Example:</p>\n<pre><code>struct S { int a; const char* b; int c; };\nS ss = { 1, \"asdf\" };\n</code></pre>\n<p id=\"so_22346426_22346962_1\">initializes ss.a with 1, ss.b with \"asdf\", and ss.c with the value of\n  an expression of the form int(), that is, 0. \u2014 end example ]</p>\n</blockquote>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "22346962", "Score": "1", "CreationDate": "2014-03-12T09:23:33.347", "LastActivityDate": "2014-03-12T09:23:33.347"}, "22347092": {"ParentId": "22346426", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>ANSCI C-89 (<a href=\"http://port70.net/~nsz/c/c89/c89-draft.html#3.5.7\" rel=\"nofollow\">3.5.7</a>) says:</p>\n<pre><code>float y[4][3] = {\n    { 1, 3, 5 },\n    { 2, 4, 6 },\n    { 3, 5, 7 },\n};\n</code></pre>\n<p>is a definition with a fully bracketed initialization: 1, 3 and 5 initialize the first row of the array object <code>y[0]</code> (namely <code>y[0][0]</code>, <code>y[0][1]</code> and <code>y[0][2]</code>). Likewise, the next two lines initialize <code>y[1]</code> and <code>y[2]</code>. The initializer ends early, so <code>y[3]</code> is initialized with zeroes. Precisely the same effect could have been achieved by</p>\n<pre><code>float y[4][3] = { 1, 3, 5, 2, 4, 6, 3, 5, 7 };\n</code></pre>\n<p>The initializer for <code>y[0]</code> does not begin with a left brace, so three items from the list are used. Likewise, the next three are taken successively for <code>y[1]</code> and <code>y[2]</code>. Also,</p>\n<pre><code>float z[4][3] = {\n    { 1 }, { 2 }, { 3 }, { 4 }\n};\n</code></pre>\n<p>initializes the first column of <code>z</code> as specified and <strong>initializes the rest with zeros</strong>.</p>\n", "OwnerUserId": "997813", "LastEditorUserId": "830320", "LastEditDate": "2014-03-12T23:16:44.143", "Id": "22347092", "Score": "2", "CreationDate": "2014-03-12T09:29:26.957", "LastActivityDate": "2014-03-12T23:16:44.143"}, "22347985": {"ParentId": "22346426", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Attempt 2.</p>\n<p>The following is from section A8.7 of \"The C Programming Language\" by K&amp;R, 2nd edition, pages 219,220</p>\n<blockquote>\n<p id=\"so_22346426_22347985_0\">An aggregate is a structure or array.  If an aggregate contains\n  members of aggregate type, the initialization rules apply recursively.\n  Braces may be elided in the initialization as follows: if the\n  initializer for an aggregate's member that is itself an aggregate\n  begins with a left brace, then the succeeding comma-separated list of\n  initializers initialize the members of the sub aggregate; it is\n  erroneous for there to be more initializers than members.  If,\n  however, the initializer for a subaggregate does not begin with a left\n  brace, then only enough elements from the list are taken to account of\n  the members of the subaggregate; any remaining members are left to\n  initialize the next member of the aggregate of which the subaggregate\n  is a part.   For example,</p>\n<pre><code> int x[] = { 1, 3, 5 }; \n</code></pre>\n<p id=\"so_22346426_22347985_1\">declares and initializes x as a 1-dimensional array with thee members, since no size was specified and\n  there are three initializers.</p>\n</blockquote>\n<p>Therefore, given this line</p>\n<pre><code>int myArray[][2] = { { 2 }, { 4, 5 }, { 4, 1 } };\n</code></pre>\n<p>the compiler will recursively initialize the array, noting that each subarray starts with a left brace and has no more than the required number of initializers, and will count the number of subarrays to determine the first dimension of the array.</p>\n<p>The following is from section A8.7 of \"The C Programming Language\" by K&amp;R, 2nd edition, page 220</p>\n<pre><code>float y[4][3] = {\n    { 1, 3, 5 },    \n    { 2, 4, 6 },\n    { 3, 5, 7 }\n};\n\nis equivalent to\n\nfloat y[4][3] = {\n   1, 3, 5, 2, 4, 6, 3, 5, 7 \n};\n\nNote that in both cases, the fourth row of the array will be initialized \nwith zero, since not enough initializers were specified.\n\nfloat y[4][3] = { \n    { 1 }, { 2 }, { 3 }, { 4 } \n};\n\ninitializes the first column of y and leaves the rest 0.\n</code></pre>\n<p>So the compiler doesn't ignore the inner braces. However, the inner braces are optional if you specify all of the initializers in order with no gaps. Using the inner braces gives you more control over the initialization, if you don't want to specify a full set of initializers.</p>\n", "OwnerUserId": "3386109", "LastEditorUserId": "3386109", "LastEditDate": "2014-03-12T23:28:55.893", "Id": "22347985", "Score": "9", "CreationDate": "2014-03-12T10:05:22.443", "LastActivityDate": "2014-03-12T23:28:55.893"}, "bq_ids": {"n4140": {"so_22346426_22346899_6": {"section_id": 3308, "quality": 0.9761904761904762, "length": 41}, "so_22346426_22346899_2": {"section_id": 3307, "quality": 1.0, "length": 7}, "so_22346426_22347985_0": {"section_id": 3308, "quality": 0.5454545454545454, "length": 36}, "so_22346426_22346899_3": {"section_id": 3307, "quality": 0.8181818181818182, "length": 9}, "so_22346426_22346899_5": {"section_id": 3308, "quality": 0.9387755102040817, "length": 46}, "so_22346426_22346899_1": {"section_id": 3307, "quality": 0.8666666666666667, "length": 13}, "so_22346426_22346962_1": {"section_id": 3304, "quality": 0.8181818181818182, "length": 9}, "so_22346426_22346933_4": {"section_id": 3308, "quality": 0.7857142857142857, "length": 11}, "so_22346426_22346899_7": {"section_id": 3308, "quality": 0.8421052631578947, "length": 16}, "so_22346426_22346933_3": {"section_id": 3308, "quality": 0.6451612903225806, "length": 20}, "so_22346426_22347985_1": {"section_id": 3301, "quality": 0.7692307692307693, "length": 10}, "so_22346426_22346962_0": {"section_id": 3304, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_22346426_22346899_6": {"section_id": 3178, "quality": 0.9761904761904762, "length": 41}, "so_22346426_22346899_2": {"section_id": 3177, "quality": 1.0, "length": 7}, "so_22346426_22347985_0": {"section_id": 3178, "quality": 0.5303030303030303, "length": 35}, "so_22346426_22346962_1": {"section_id": 3174, "quality": 0.8181818181818182, "length": 9}, "so_22346426_22346899_5": {"section_id": 3178, "quality": 0.9591836734693877, "length": 47}, "so_22346426_22346899_1": {"section_id": 3177, "quality": 0.8666666666666667, "length": 13}, "so_22346426_22346899_3": {"section_id": 3177, "quality": 0.8181818181818182, "length": 9}, "so_22346426_22346933_4": {"section_id": 3178, "quality": 0.7857142857142857, "length": 11}, "so_22346426_22346899_7": {"section_id": 3178, "quality": 0.8421052631578947, "length": 16}, "so_22346426_22346933_3": {"section_id": 3178, "quality": 0.6451612903225806, "length": 20}, "so_22346426_22347985_1": {"section_id": 3171, "quality": 0.7692307692307693, "length": 10}, "so_22346426_22346962_0": {"section_id": 3174, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_22346426_22346899_1": {"section_id": 4073, "quality": 0.8666666666666667, "length": 13}, "so_22346426_22346899_5": {"section_id": 4074, "quality": 0.8367346938775511, "length": 41}, "so_22346426_22346899_3": {"section_id": 4073, "quality": 0.8181818181818182, "length": 9}, "so_22346426_22346899_2": {"section_id": 4073, "quality": 1.0, "length": 7}, "so_22346426_22346933_4": {"section_id": 4074, "quality": 0.7857142857142857, "length": 11}, "so_22346426_22346899_7": {"section_id": 4074, "quality": 0.8421052631578947, "length": 16}, "so_22346426_22346899_6": {"section_id": 4074, "quality": 0.9761904761904762, "length": 41}, "so_22346426_22347985_1": {"section_id": 4067, "quality": 0.7692307692307693, "length": 10}, "so_22346426_22346962_0": {"section_id": 4070, "quality": 0.7894736842105263, "length": 15}, "so_22346426_22346962_1": {"section_id": 4070, "quality": 0.8181818181818182, "length": 9}, "so_22346426_22346933_3": {"section_id": 4074, "quality": 0.6451612903225806, "length": 20}}}, "22346426": {"CommentCount": "6", "AcceptedAnswerId": "22347985", "CreationDate": "2014-03-12T08:57:25.883", "LastActivityDate": "2014-03-12T23:28:55.893", "PostTypeId": "1", "ViewCount": "1995", "FavoriteCount": "5", "Title": "Omitting Sizes while Initializing C/C++ Multidimensional Arrays", "Id": "22346426", "Score": "23", "Body": "<p>What I know about C/C++ compilers is that they ignore inner braces while initializing multidimensional arrays.</p>\n<p>So, you can't do this:</p>\n<pre><code>int myArray[][] = { { 2, 3 }, { 4, 5 }, { 4, 1 } };\n</code></pre>\n<p>because the compiler will see it exactly as</p>\n<pre><code>int myArray[][] = { 2, 3, 4, 5, 4, 1 };\n</code></pre>\n<p>and now it doesn't know if it is 6 * 1, 3 * 2, 2 * 3, 1 * 6, or even something else (since this can be a partial initialization list, not necessarily complete).</p>\n<p>My question is, why does this work in many compilers?</p>\n<pre><code>int myArray[][2] = { { 2 }, { 4, 5 }, { 4, 1 } };\n</code></pre>\n<p>The compiler \"intuitively\" sees it as:</p>\n<pre><code>int myArray[][2] = { { 2, 0 }, { 4, 5 }, { 4, 1 } };\n</code></pre>\n<p>which means it <em>doesn't</em> ignore the braces. I've tried it on three different compilers till now and all worked.</p>\n<p>I expect the answer to be \"this is just compiler-dependent\". I don't have access to the standard, so please provide an answer <em>from the standard</em>. I don't need gut feelings, I have mine.</p>\n", "Tags": "<c++><c><multidimensional-array><initialization>", "OwnerUserId": "830320", "AnswerCount": "6"}});