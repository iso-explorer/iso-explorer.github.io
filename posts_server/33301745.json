post_cb({"33302861": {"ParentId": "33301745", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-10-23T12:55:13.620", "Score": "0", "LastEditorUserId": "1182921", "LastEditDate": "2015-10-23T13:03:19.493", "Id": "33302861", "OwnerUserId": "1182921", "Body": "<p>A \"valid\" (big air quotes) implementation could be along the lines of</p>\n<pre><code>class CString {\n    wchar_t *data_;\n    size_t max_size_;\n    size_t size_;\n    CString() : data_(new wchar_t[20]), max_data_(20), size_(0) {}\n\n    //various operations on CString which might or might not do things like\n    void extend(size_t new_size)\n    {\n        wchar_t *old_data = data_;\n        data_ = new wchar_t[new_size];\n        memcpy(data_, old_data_, size_);\n        delete [] old_data;\n        max_size_ = new_size;\n    }\n    //or even\n    void append(wchar_t c)\n    {\n        data_[size_++] = c;\n    }\n    operator LPCSTR () const { data_[size_ + 1] = 0; return data_; }\n};\n</code></pre>\n<p>So if you use the cast operator you get a pointer to a null terminated string. Right up until the point you (say) add a character to the string. Then the pointer will point to a non-null terminated string. Or if you add a lot of characters to the string, it can free the memory and point it somewhere else. In which case, your pointer is pointing to what probably looks valid until the next memory allocation happens and grabs that recently freed memory.</p>\n", "LastActivityDate": "2015-10-23T13:03:19.493"}, "33301745": {"CommentCount": "1", "ViewCount": "156", "CreationDate": "2015-10-23T11:56:46.910", "LastActivityDate": "2015-10-24T20:12:34.053", "Title": "Why does casting a CString to wchar_t* yield a temporary copy? What if we used some other type instead of CString?", "AcceptedAnswerId": "33302564", "PostTypeId": "1", "Id": "33301745", "Score": "0", "Body": "<p>PVS studio found a potential defect which I am investigating; warning V623 <a href=\"http://www.viva64.com/en/d/0240/\" rel=\"nofollow\">http://www.viva64.com/en/d/0240/</a></p>\n<p>However, not enough is explained to understand why the temporary copy is being made. If CString::operator wchar_t*() is defined like:</p>\n<pre><code>wchar_t* newbuf = new wchar_t[20];\n// do things to put the current CString value in there\nreturn newbuf;\n</code></pre>\n<p>Then there's a memory leak, but no pointer to a destroyed temporary. I see only one other possible implementation, which is to return an already existing wchar_t* pointer contained in the CString, which would not make a new temporary. Something like this:</p>\n<pre><code>return m_pContents;\n</code></pre>\n<p>So, two questions; where can I find the actual implementation for CString? And, what valid implementation of this function (on any selfmade type) could have the conversion operator return a pointer to a destroyed temporary? I just don't believe that Microsfoot would implement it like:</p>\n<pre><code>CString tempCopy(*this);\nreturn tempCopy.m_pContents;\n</code></pre>\n", "Tags": "<c++><undefined-behavior><c-strings><temporary>", "OwnerUserId": "2144408", "AnswerCount": "3"}, "33302564": {"ParentId": "33301745", "CommentCount": "0", "CreationDate": "2015-10-23T12:39:26.880", "OwnerUserId": "1111996", "PostTypeId": "2", "Id": "33302564", "Score": "1", "Body": "<p>In your linked PVS studio code, you have a ternary operator taking a <code>wchar_t *</code> and a <code>CString</code>. Your problem is not with the conversion operator, but that the ternary is promoting the <code>wchar_t *</code> into a <code>CString</code>. You either need to assign the result to a new <code>CString</code> or make sure the ternary arguments are all the same type so that you get a reference back.</p>\n", "LastActivityDate": "2015-10-23T12:39:26.880"}, "bq_ids": {"n4140": {"so_33301745_33302211_8": {"section_id": 6169, "quality": 1.0, "length": 27}}, "n3337": {"so_33301745_33302211_8": {"section_id": 5930, "quality": 1.0, "length": 27}}, "n4659": {"so_33301745_33302211_8": {"section_id": 7667, "quality": 0.5555555555555556, "length": 15}}}, "33302211": {"ParentId": "33301745", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-23T12:20:31.877", "Score": "1", "LastEditorUserId": "2079303", "LastEditDate": "2015-10-24T20:12:34.053", "Id": "33302211", "OwnerUserId": "2079303", "Body": "<p>Here is the <a href=\"https://msdn.microsoft.com/en-us/library/aa300569%28VS.60%29.aspx\" rel=\"nofollow\">documentation</a> for <code>CString::operator LPCTSTR</code>. <code>LPCTSTR</code> is a fancy microsoft name for <code>const char*</code> or <code>const wchar_t*</code> depending on whether <code>_UNICODE</code> is defined.</p>\n<p>Here is the description:</p>\n<blockquote>\n<p id=\"so_33301745_33302211_0\">Return Value</p>\n<p id=\"so_33301745_33302211_1\">A character pointer to the string\u2019s data.</p>\n<p id=\"so_33301745_33302211_2\">Remarks</p>\n<p id=\"so_33301745_33302211_3\">This useful casting operator provides an efficient method to access the null-terminated C string contained in a CString object. No characters are copied; only a pointer is returned. Be careful with this operator. If you change a CString object after you have obtained the character pointer, you may cause a reallocation of memory that invalidates the pointer.</p>\n</blockquote>\n<p>So, let's move on to your questions.</p>\n<blockquote>\n<p id=\"so_33301745_33302211_4\">where can I find the actual implementation for CString?</p>\n</blockquote>\n<p>You'll find it somewhere in the source files of Microsofts c++ runtime library. Unless you work at Microsoft, you probably won't have access.</p>\n<blockquote>\n<p id=\"so_33301745_33302211_5\">I just don't believe that Microsfoot would implement it like:</p>\n</blockquote>\n<pre><code>CString tempCopy(*this);\nreturn tempCopy.m_pContents;\n</code></pre>\n<p>I wouldn't believe that either. That would be copying and the documentation explicitly states that no copying is done.</p>\n<p>Now the question in the title:</p>\n<blockquote>\n<p id=\"so_33301745_33302211_6\">Why does casting a CString to wchar_t* yield a temporary copy?</p>\n</blockquote>\n<p>It does not. Well, it does create a copy of a pointer, but it does not create a copy of the array containing the string.</p>\n<p>You misunderstand the article. Here is the example of broken code from it:</p>\n<pre><code>CString s1(L\"1\");\nwchar_t s2[] = L\"2\";\nbool a = false;\nconst wchar_t *s = a ? s1 : s2;\n</code></pre>\n<p>A temporary <code>CString</code> is constructed from <code>s2</code>. That temporary doesn't exist after the <code>?:</code> operator ends. It's not wrong to use a pointer because it was returned by <code>CString::operator wchar_t*()</code>. It's wrong to use the pointer because <code>CString::operator wchar_t*()</code> was called on a temporary object. The temporary <code>CString</code> was not created by <code>CString::operator wchar_t*()</code>. It was created implicitly from <code>s2</code> because <code>s1</code> is of type <code>CString</code>.</p>\n<p>Edit. You asked in a comment:</p>\n<blockquote>\n<p id=\"so_33301745_33302211_7\">So how did you know that a ? s1 : s2 returns a CString?</p>\n</blockquote>\n<p>I know that the conditional operator must return the same type regardless of the boolean expression. I know that if the expressions return a different type, and one type is implicitly convertible to the other, then the return type of the operator will be the other type. I know that <code>wchar_t*</code> is convertible to <code>CString</code>. Therefore the conditional operator will return a <code>CString</code>.</p>\n<p>Well, it <em>could</em> return <code>CString</code>, except... <code>CString</code> can be converted to a <code>wchar_t*</code> too, so the conditional operator <em>could</em> return either <code>wchar_t*</code> or <code>CString</code> and if it does return <code>CString</code>, then you end up with a dangling pointer. You cannot make assumptions about what it returns because neither is guaranteed by the standard. In fact, that makes the program ill-formed which is another way the example code is broken. Here's a quote from the standard:</p>\n<p>[expr.cond] \u00a75.16 / 3 (draft N3797)</p>\n<blockquote>\n<p id=\"so_33301745_33302211_8\">... it is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand. If both can be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed.</p>\n</blockquote>\n", "LastActivityDate": "2015-10-24T20:12:34.053"}});