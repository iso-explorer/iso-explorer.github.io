post_cb({"bq_ids": {"n4140": {"so_48676645_48679875_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6185}, "so_48676645_48679875_5": {"length": 12, "quality": 1.0, "section_id": 6185}, "so_48676645_48679875_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 6185}, "so_48676645_48679130_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 3327}, "so_48676645_48679875_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 6185}, "so_48676645_48679875_6": {"length": 12, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_48676645_48679130_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 3197}, "so_48676645_48679875_6": {"length": 9, "quality": 0.75, "section_id": 5946}, "so_48676645_48679875_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 5946}, "so_48676645_48679875_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 5946}, "so_48676645_48679875_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 5946}}, "n4659": {"so_48676645_48679875_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7687}, "so_48676645_48679875_5": {"length": 12, "quality": 1.0, "section_id": 7687}, "so_48676645_48679875_3": {"length": 15, "quality": 1.0, "section_id": 7687}, "so_48676645_48679875_4": {"length": 6, "quality": 1.0, "section_id": 7687}, "so_48676645_48679130_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 4093}, "so_48676645_48679875_6": {"length": 12, "quality": 1.0, "section_id": 7687}}}, "48676645": {"ViewCount": "157", "Body": "<p>I'm trying to implement compile-time validation of some hardcoded values. I have the following simplified attempt:</p>\n<pre><code>using Type = std::initializer_list&lt;int&gt;;\n\nconstexpr bool all_positive(const Type&amp; list)\n{\n    bool all_positive = true;\n    for (const auto&amp; elem : list)\n    {\n        all_positive &amp;= (elem &gt; 0);\n    }\n    return all_positive;\n}\n\nint main()\n{\n    static constexpr Type num_list{ 1000, 10000, 100 };\n\n    static_assert(all_positive(num_list), \"all values should be positive\");\n\n    return 0;\n}\n</code></pre>\n<p>gcc compiles this and works exactly as I expected, but clang fails compilation with the error:</p>\n<pre><code>static_assert_test.cc:79:16: error: static_assert expression is not an integral constant expression\n    static_assert(all_positive(num_list), \"all values should be positive\");\n                  ^~~~~~~~~~~~~~~~~~~~~~\nstatic_assert_test.cc:54:20: note: read of temporary is not allowed in a constant expression outside the expression that created the temporary\n            all_positive &amp;= (elem &gt; 0);\n                             ^\nstatic_assert_test.cc:79:16: note: in call to 'all_positive(num_list)'\n    static_assert(all_positive(num_list), \"all values should be positive\");\n                  ^\nstatic_assert_test.cc:77:32: note: temporary created here\n    static constexpr Type num_list{ 1000, 10000, 100 };\n</code></pre>\n<p>What's the expected behaviour here? Should this compile or not? And if not, is there an alternative way to validate hard-coded values?</p>\n", "AcceptedAnswerId": "48679875", "Title": "compile-time validation of constexpr std::initializer_list", "CreationDate": "2018-02-08T02:40:41.917", "Id": "48676645", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2018-02-08T07:35:03.180", "Score": "10", "OwnerUserId": "8360627", "Tags": "<c++><c++14>", "AnswerCount": "2"}, "48679130": {"Id": "48679130", "PostTypeId": "2", "Body": "<p>The problem is that you are trying to use temporary array to initialize your <code>constexpr</code>. </p>\n<blockquote>\n<p id=\"so_48676645_48679130_0\">An object of type std::initializer_list is constructed from an initializer list as if the implementation\n  generated and materialized (7.4) a prvalue of type \u201carray of N const E\u201d, where N is the number of elements\n  in the initializer list.</p>\n</blockquote>\n<p>But <strong>this temporary array is not a constant per se</strong>. It could work like this:</p>\n<pre><code>static constexpr array&lt;int,4&gt; arr = { 1000, 10000, 100 };\nstatic constexpr Type num_list(&amp;arr[0], &amp;arr[3]);\nstatic_assert(all_positive(num_list), \"all values should be positive\");\n</code></pre>\n", "LastEditorUserId": "312896", "LastActivityDate": "2018-02-08T07:24:19.217", "Score": "1", "CreationDate": "2018-02-08T06:38:50.050", "ParentId": "48676645", "CommentCount": "6", "OwnerUserId": "312896", "LastEditDate": "2018-02-08T07:24:19.217"}, "48679875": {"Id": "48679875", "PostTypeId": "2", "Body": "<p>As Yola's answer says, a temporary array is created, and the expression <code>elem &gt; 0</code> tries to apply a lvalue-to-rvalue conversion to <code>elem</code>. Now we refer to the standard <a href=\"http://www.eel.is/c++draft/expr.const#2\" rel=\"nofollow noreferrer\">[expr.const]/2</a>:</p>\n<blockquote>\n<p id=\"so_48676645_48679875_0\">An expression e is a core constant expression unless the evaluation of e, following the rules of the abstract machine, would evaluate one of the following expressions:</p>\n<ul>\n<li><p id=\"so_48676645_48679875_1\">...</p></li>\n<li><p id=\"so_48676645_48679875_2\">an lvalue-to-rvalue conversion unless it is applied to</p>\n<ul>\n<li><p id=\"so_48676645_48679875_3\">a non-volatile glvalue of integral or enumeration type that refers to a complete non-volatile const object with a preceding initialization, initialized with a constant expression, or</p></li>\n<li><p id=\"so_48676645_48679875_4\">a non-volatile glvalue that refers to a subobject of a string literal, or</p></li>\n<li><p id=\"so_48676645_48679875_5\">a non-volatile glvalue that refers to a non-volatile object defined with <code>constexpr</code>, or that refers to a non-mutable subobject of such an object, or</p></li>\n<li><p id=\"so_48676645_48679875_6\">a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began within the evaluation of e;</p></li>\n</ul></li>\n<li><p id=\"so_48676645_48679875_7\">...</p></li>\n</ul>\n</blockquote>\n<p>Note the first bullet does not apply here because <code>elem</code> does not refer to a <strong>complete</strong> object (it is a subobject of an array). The third bullet does not apply too because the temporary array is not defined with <code>constexpr</code> though it is a const object. As a result, <code>all_positive(num_list)</code> fails to become a constant expression.</p>\n<p>The key is that accessing an element of a const, but not <code>constexpr</code>, array is not permitted in a constant expression, though the values of these elements <strong>may be able to</strong> be determined at compile time. The following code snippet shows this issue:</p>\n<pre><code>const int ci[1] = {0};\nconst int &amp;ri = ci[0];\nconstexpr int i = ri; // error\n</code></pre>\n", "LastEditorUserId": "5376789", "LastActivityDate": "2018-02-08T07:35:03.180", "Score": "3", "CreationDate": "2018-02-08T07:29:34.993", "ParentId": "48676645", "CommentCount": "2", "OwnerUserId": "5376789", "LastEditDate": "2018-02-08T07:35:03.180"}});