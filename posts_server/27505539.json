post_cb({"27505539": {"CommentCount": "12", "ViewCount": "372", "PostTypeId": "1", "LastEditorUserId": "2642059", "CreationDate": "2014-12-16T13:16:06.150", "LastActivityDate": "2014-12-16T14:06:47.503", "Title": "Writing a Default Constructor Forces Zero-Initialization?", "AcceptedAnswerId": "27506091", "LastEditDate": "2014-12-16T13:59:59.450", "Id": "27505539", "Score": "1", "Body": "<p>These are my class definitions:</p>\n<pre><code>class Foo{\n    int _ent;\npublic:\n    void printEnt() const{cout &lt;&lt; _ent &lt;&lt; ' ';}\n};\n\nclass Bar{\n    Foo _foo;\npublic:\n    void printEnt() const{_foo.printEnt();}\n};\n</code></pre>\n<p>And this is my test code:</p>\n<pre><code>char* buf = new char[sizeof(Foo) + sizeof(Foo) + sizeof(Bar)];\n\nfill(buf, buf + sizeof(Foo) + sizeof(Foo) + sizeof(Bar), 'J');\n\ncout &lt;&lt; ((int*)buf)[0] &lt;&lt; ' ' &lt;&lt; ((int*)buf)[1] &lt;&lt; ' ' &lt;&lt; ((int*)buf)[2] &lt;&lt; endl;\n\nFoo* first = new (buf) Foo;\nFoo* second = new (buf + sizeof(Foo)) Foo();\nBar* third = new (buf + sizeof(Foo) * 2) Bar;\n\nfirst-&gt;printEnt(); second-&gt;printEnt(); third-&gt;printEnt();\n</code></pre>\n<p>My output is:</p>\n<blockquote>\n<p id=\"so_27505539_27505539_0\">1246382666 1246382666 1246382666<br>\n  1246382666 0 1246382666</br></p>\n</blockquote>\n<p>But if I add a <code>public</code> default ctor to <code>Foo</code>: <code>Foo() : _ent(0) {}</code></p>\n<p>My output becomes:</p>\n<blockquote>\n<p id=\"so_27505539_27505539_1\">1246382666 1246382666 1246382666<br>\n  0 0 0</br></p>\n</blockquote>\n<p><strong>Is this correct behavior? Should adding my own default ctor remove the possibility of default initialization?</strong></p>\n<p>I'm running this code on gcc 4.8.1 if it matters. The results should be dependable because I'm running in debug and asserting: <code>assert(sizeof(Foo) == sizeof(int) &amp;&amp; sizeof(Bar) == sizeof(int));</code></p>\n", "Tags": "<c++><initialization><default><default-constructor>", "OwnerUserId": "2642059", "AnswerCount": "3"}, "27506091": {"ParentId": "27505539", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Once you provide a constructor for a type, it will always be\ninvoked, both for default initialization and for value\ninitialization.  It's a fundamental principle of the language.\nSo once you define <code>Foo::Foo()</code>, it will be called any time you\nconstruct a <code>Foo</code>; if there is a default constructor, it will be\ninvoked, even in the case of default initialization.  So the\nbehavior you are seeing is correct.</p>\n<p>EDIT:</p>\n<p>Default initialization is explained \u00a78.5/7, in particular:</p>\n<blockquote>\n<p id=\"so_27505539_27506091_0\">To default-initialize an object of type T means:</p>\n<p id=\"so_27505539_27506091_1\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9), the default constructor (12.1) for T is called\n  [...]</p>\n</blockquote>\n<p>In your case, you'll probably also want to look at how the\ncompiler generates a default constructor if none is provided,\n\u00a712.1/4; in particular, the generated default constructor\ninvokes the default constructor of any base classes or members.</p>\n<p>Value initialization is in \u00a78.5/8.  It is basically default\ninitialization preceded by zero initialization, so that default\ninitialization that doesn't do anything still finds everything\nzero initialized.</p>\n<p>More fundamentally, however: in this case, a very fundamental\nprinciple of C++ is involved, dating to long before the first\nstandard: if you provide a constructor for an object, it <em>will</em>\nbe used.  Without doing all sorts of strange pointer casts, it\nis impossible to get an object without it being properly\nconstructed.  The standard describes how this occurs, and covers\na lot of other special cases, but the basic principle has been\nthere from the start (and any proposal which would cause it not\nto be respected in the standard is bound to fail).</p>\n", "OwnerUserId": "649665", "LastEditorUserId": "649665", "LastEditDate": "2014-12-16T14:06:47.503", "Id": "27506091", "Score": "3", "CreationDate": "2014-12-16T13:46:59.930", "LastActivityDate": "2014-12-16T14:06:47.503"}, "27505772": {"ParentId": "27505539", "CommentCount": "0", "Body": "<p>When you provided a default constructor you no longer get the compiler generated one.  Since your default constructor initializes the member to 0 the member will always be 0, this is especially true since the member is private and you have no way to change it.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "27505772", "Score": "0", "CreationDate": "2014-12-16T13:28:01.347", "LastActivityDate": "2014-12-16T13:28:01.347"}, "bq_ids": {"n4140": {"so_27505539_27506091_0": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_27505539_27506091_1": {"section_id": 3286, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_27505539_27506091_0": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_27505539_27506091_1": {"section_id": 3156, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_27505539_27506091_1": {"section_id": 4049, "quality": 0.7777777777777778, "length": 7}}}, "27505702": {"ParentId": "27505539", "CommentCount": "8", "Body": "<p>Your question has been answered in the C++11 revision of the standard:</p>\n<pre><code>class Foo{\n    int _ent=0;\npublic:\n\n    // ...\n};\n</code></pre>\n<p>If you then define your own default constructor, the member will still be initialized to its default value, even if your default constructor does not explicitly do so.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "27505702", "Score": "1", "CreationDate": "2014-12-16T13:24:45.263", "LastActivityDate": "2014-12-16T13:24:45.263"}});