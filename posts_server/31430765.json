post_cb({"31430997": {"ParentId": "31430765", "CommentCount": "2", "Body": "<p>Expanding <code>__func__</code> at preprocessing time requires the preprocessor to know which function it's processing. The preprocessor generally doesn't know that, because parsing happens after the preprocessor is already done.</p>\n<p>Some implementations combine the preprocessing and the parsing, and in those implementations, it would have been possible for <code>__func__</code> to work the way you'd like it to. In fact, if I recall correctly, MSVC's <code>__FUNCTION__</code> works like that. It's an unreasonable demand on implementations that separate the phases of translation though.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "31430997", "Score": "17", "CreationDate": "2015-07-15T12:54:00.763", "LastActivityDate": "2015-07-15T12:54:00.763"}, "bq_ids": {"n4140": {"so_31430765_31430765_3": {"section_id": 550, "quality": 0.8888888888888888, "length": 8}, "so_31430765_31430765_1": {"section_id": 550, "quality": 0.8787878787878788, "length": 29}, "so_31430765_31430765_5": {"section_id": 550, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_31430765_31430765_3": {"section_id": 541, "quality": 0.8888888888888888, "length": 8}, "so_31430765_31430765_1": {"section_id": 541, "quality": 0.8787878787878788, "length": 29}, "so_31430765_31430765_5": {"section_id": 541, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_31430765_31430765_3": {"section_id": 571, "quality": 0.8888888888888888, "length": 8}, "so_31430765_31430765_1": {"section_id": 571, "quality": 0.8787878787878788, "length": 29}, "so_31430765_31430765_5": {"section_id": 571, "quality": 0.9285714285714286, "length": 13}}}, "31430765": {"CommentCount": "4", "CreationDate": "2015-07-15T12:44:31.490", "PostTypeId": "1", "AcceptedAnswerId": "31430997", "LastEditorUserId": "4370109", "LastActivityDate": "2016-07-05T19:12:01.993", "LastEditDate": "2016-07-05T19:12:01.993", "ViewCount": "4269", "FavoriteCount": "4", "Title": "Why __func__, __FUNCTION__ and __PRETTY_FUNCTION__ aren't preprocessor macros?", "Id": "31430765", "Score": "17", "Body": "<p>I've just noticed that <code>__func__</code>, <code>__FUNCTION__</code> and <code>__PRETTY_FUNCTION__</code> aren't treated as preprocessor macros and they're not mentioned on the <em>16.8 Predefined macro names</em> section of the Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\">N4527 Working Draft</a>).</p>\n<p>This means that they cannot be used in the string concatenation trick of <a href=\"http://en.cppreference.com/w/cpp/language/translation_phases\">phase 6</a>:</p>\n<pre><code>// Valid\nconstexpr char timestamp[]{__FILE__ \" has been compiled: \" __DATE__ \" \" __TIME__};\n// Not valid!!!\ntemplate &lt;typename T&gt;\nvoid die() { throw std::runtime_error{\"Error detected in \" __PRETTY_FUNCTION__}; }\n</code></pre>\n<p>As far as I know, the <code>__FILE__</code>, <code>__DATE__</code> and <code>__TIME__</code> are translated to string literals as stated by the standard:</p>\n<blockquote>\n<h3>16.8 Predefined macro names [cpp.predefined]</h3>\n<p id=\"so_31430765_31430765_0\"><code>__DATE__</code></p>\n<p id=\"so_31430765_31430765_1\">The date of translation of the source file: a <strong>character string literal of the form <code>\"Mmm dd yyyy\"</code></strong>, where the names of the months are the same as those generated by the asctime function, and the first character of dd is a space character if the value is less than 10. If the date of translation is not\n  available, an implementation-defined valid date shall be supplied.</p>\n<p id=\"so_31430765_31430765_2\"><code>__FILE__</code></p>\n<p id=\"so_31430765_31430765_3\">The presumed name of the current source file (a <strong>character string literal</strong>).</p>\n<p id=\"so_31430765_31430765_4\"><code>__TIME__</code></p>\n<p id=\"so_31430765_31430765_5\">The time of translation of the source file: a <strong>character string literal of the form <code>\"hh:mm:ss\"</code></strong> as in the time generated by the asctime function.</p>\n</blockquote>\n<p><code>__func__</code> is mentioned by the standard as a function-local predefined variable of the form:</p>\n<pre><code>static const char __func__[] = \"function-name \";\n</code></pre>\n<p>So the fact is that is a local variable hence the string concatenation trick doesn't works with it.</p>\n<p>As for <code>__FUNCTION__</code> and <code>__PRETTY_FUNCTION__</code> aren't mentioned in the standard (are implementation defined?) but is a pretty safe bet to think that they would behave like <code>__func__</code>.</p>\n<p>So the question is: Why <code>__func__</code>, <code>__FUNCTION__</code> and <code>__PRETTY_FUNCTION__</code> are function-local static constant array of characters while <code>__FILE__</code>, <code>__DATE__</code> and <code>__TIME__</code> are string literals? What's the rationale (if any) behind this decision?</p>\n", "Tags": "<c++><c-preprocessor><standards>", "OwnerUserId": "499359", "AnswerCount": "1"}});