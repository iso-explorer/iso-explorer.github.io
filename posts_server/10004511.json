post_cb({"10004511": {"CommentCount": "6", "ViewCount": "3133", "PostTypeId": "1", "LastEditorUserId": "196561", "CreationDate": "2012-04-04T03:23:13.490", "LastActivityDate": "2014-07-17T10:18:01.723", "Title": "Why are string literals l-value while all other literals are r-value?", "FavoriteCount": "8", "LastEditDate": "2012-12-06T01:13:41.987", "Id": "10004511", "Score": "35", "Body": "<p><strong>C++03 5.1 Primary expressions<br>\n\u00a72:</br></strong> </p>\n<blockquote>\n<p id=\"so_10004511_10004511_0\">A literal is a primary expression. Its type depends on its form (2.13). A string literal is an lvalue; all other literals are rvalues.        </p>\n</blockquote>\n<p>What is the rationale behind this?<br>\nAs I understand, string literals are objects, while all other literals are not.And an l-value always refers to an object.      </br></p>\n<p>But the question then is why are string literals objects while all other literals are not?<br>\nThis rationale seems to me more like an egg or chicken problem.        </br></p>\n<p>I understand the answer to this may be related to hardware architecture rather than C/C++ as programming languages, nevertheless I would like to hear the same.        </p>\n<p>Note: I am tagging this question as c &amp; c++ both because C99 standard also has similar quotations, specifically <strong>\u00a76.5.1.4</strong></p>\n", "Tags": "<c++><c><literals><string-literals>", "OwnerUserId": "452307", "AnswerCount": "4"}, "10004567": {"ParentId": "10004511", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>A string literal is a literal with array type, and in C there is no way for an array type to exist in an expression except as an lvalue. String literals could have been specified to have pointer type (rather than array type that usually decays to a pointer) pointing to the string \"contents\", but this would make them rather less useful; in particular, the <code>sizeof</code> operator could not be applied to them.</p>\n<p>Note that C99 introduced compound literals, which are also lvalues, so having a literal be an lvalue is no longer a special exception; it's closer to being the norm.</p>\n", "OwnerUserId": "379897", "LastEditorUserId": "379897", "LastEditDate": "2012-04-04T03:40:10.843", "Id": "10004567", "Score": "23", "CreationDate": "2012-04-04T03:34:03.607", "LastActivityDate": "2012-04-04T03:40:10.843"}, "10006823": {"ParentId": "10004511", "CommentCount": "8", "Body": "<p>I'd guess that the original motive was mainly a pragmatic one: a string\nliteral must reside in memory and have an address.  The type of a string\nliteral is an array type (<code>char[]</code> in C, <code>char const[]</code> in C++), and\narray types convert to pointers in most contexts.  The language could\nhave found other ways to define this (e.g. a string literal could have\npointer type to begin with, with special rules concerning what it\npointed to), but just making the literal an lvalue is probably the\neasiest way of defining what is concretely needed. </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "10006823", "Score": "5", "CreationDate": "2012-04-04T07:38:33.360", "LastActivityDate": "2012-04-04T07:38:33.360"}, "10007090": {"ParentId": "10004511", "CommentCount": "2", "Body": "<p>An lvalue in C++ does not always refer to an object. It can refer to a function too. Moreover objects do not have to be referred to by lvalues. They may be referred to by rvalues, including for arrays (in C++ and C). However in old C89, the array to pointer conversion did not apply for rvalues arrays.</p>\n<p>Now, an rvalue denotes no, limited or soon to be expired lifetime. A string literal however lives for the entire program.</p>\n<p>So string literals being lvalues is exactly right.</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "10007090", "Score": "6", "CreationDate": "2012-04-04T08:00:25.057", "LastActivityDate": "2012-04-04T08:00:25.057"}, "13735632": {"ParentId": "10004511", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>String literals are <em>arrays</em> - objects of inherently unpredictable size (i.e of user-defined and possibly large size). In general case there's simply no other way to represent such literals except as objects in memory, i.e. as lvalues. In C99 this also applies to <em>compound literals</em>, which are also lvalues. </p>\n<p>Any attempts to artificially hide the fact that string literals are lvalues at the language level would produce a considerable number of completely unnecessary difficulties, since the ability to point to a string literal with a pointer as well as the ability to access it as an array relies critically on its lvalue-ness being visible at the language level.</p>\n<p>Meanwhile, literals of scalar types have fixed compile-time size. At the same time such literals are very likely to be embedded directly into the machine commands on the given hardware architecture. For example, when you write something like <code>i = i * 5 + 2</code>, the literal values <code>5</code> and <code>2</code> become explicit (or even implicit) parts of the generated machine code. They don't exist and don't need to exist as standalone locations in data storage. There's imply no point in storing values <code>5</code> and <code>2</code> in data memory.</p>\n<p>It is also worth nothing that on many (if not most, or all) hardware architectures floating-point literals are actually implemented as \"hidden\" lvalues (even though the language does not expose them as such). On platforms like x86 machine commands from floating-point group do not support embedded immediate operands. This means that virtually every floating-point literal has to be stored in (and read from) data memory by the compiler. E.g. when you write something like <code>i = i * 5.5 + 2.1</code> it is translated into something like</p>\n<pre><code>const double unnamed_double_5_5 = 5.5;\nconst double unnamed_double_2_1 = 2.1;\ni = i * unnamed_double_5_5 + unnamed_double_2_1;\n</code></pre>\n<p>In other words, floating-point literals often end up becoming \"unofficial\" lvalues internally. However, it makes perfect sense that language specification did not make any attempts to expose this implementation detail. At language level arithmetic literals make more sense as rvalues.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2014-07-17T10:18:01.723", "Id": "13735632", "Score": "5", "CreationDate": "2012-12-06T01:40:15.417", "LastActivityDate": "2014-07-17T10:18:01.723"}, "bq_ids": {"n4140": {"so_10004511_10004511_0": {"section_id": 5947, "quality": 0.875, "length": 14}}, "n3337": {"so_10004511_10004511_0": {"section_id": 5717, "quality": 0.875, "length": 14}}, "n4659": {"so_10004511_10004511_0": {"section_id": 7433, "quality": 0.875, "length": 14}}}});