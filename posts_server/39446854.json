post_cb({"39446854": {"CommentCount": "6", "AcceptedAnswerId": "39446890", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2016-09-12T09:10:54.713", "LastActivityDate": "2016-09-12T09:39:19.233", "LastEditDate": "2016-09-12T09:39:15.420", "ViewCount": "401", "FavoriteCount": "2", "Title": "Why GCC 5.3.0 gives warning when binding reference to \"this\" pointer", "Id": "39446854", "Score": "14", "Body": "<p>Here is the minimal example:</p>\n<pre><code>class A\n{\n    A* const&amp; this_ref;\npublic:\n    A() : this_ref(this) {}\n};\n</code></pre>\n<p>GCC 5.3.0 gives warning:</p>\n<blockquote>\n<p id=\"so_39446854_39446854_0\">warning: a temporary bound to 'A::this_ref' only persists until the\n  constructor exits [-Wextra]\n       A() : this_ref(this) {}</p>\n</blockquote>\n<p>Is <code>this</code> a temporary then? What the... MSVC 2015 is silent about this, and referring to class members by <code>this_ref-&gt;member</code> outside the constructor in my case gives expected behaviour (but might be just a case of UB, not sure).</p>\n<hr>\n<p>EDIT:</p>\n<p>Note this question extends one linked as possible duplicate, because it's not generic question about way to create such reference, but about warning GCC (and possible other compilers other than MSVC) produces when creating one.</p>\n</hr>", "Tags": "<c++><gcc><reference><this><language-lawyer>", "OwnerUserId": "5405086", "AnswerCount": "2"}, "39447173": {"ParentId": "39446854", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-09-12T09:27:00.623", "Score": "5", "LastEditorUserId": "3309790", "LastEditDate": "2016-09-12T09:39:19.233", "Id": "39447173", "OwnerUserId": "3309790", "Body": "<blockquote>\n<p id=\"so_39446854_39447173_0\">Is <code>this</code> a temporary then? </p>\n</blockquote>\n<p>To be precise, <code>this</code> is not temporary, but a temporary is created here.</p>\n<p>Firstly, <code>this</code> is <a href=\"http://en.cppreference.com/w/cpp/language/value_category#prvalue\" rel=\"nofollow\">prvalue</a>, </p>\n<blockquote>\n<p id=\"so_39446854_39447173_1\">The following expressions are prvalue expressions: </p>\n<ul>\n<li>the <a href=\"http://en.cppreference.com/w/cpp/language/this\" rel=\"nofollow\">this</a> pointer; </li>\n</ul>\n</blockquote>\n<p>Secondly, <a href=\"http://en.cppreference.com/w/cpp/language/lifetime#Temporary_object_lifetime\" rel=\"nofollow\">temporary object</a> will be created when binding reference to a prvalue,</p>\n<blockquote>\n<p id=\"so_39446854_39447173_2\">Temporary objects are created <code>when a prvalue is materialized so that it can be used as a glvalue, which occurs (since C++17)</code> in the following situations:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/reference_initialization\" rel=\"nofollow\">binding a reference to a prvalue</a></li>\n</ul>\n</blockquote>\n<p>That's why GCC gives warning, because <code>this_ref</code> is bound to a temporary created. (And then become dangled later, which leads to UB.)</p>\n", "LastActivityDate": "2016-09-12T09:39:19.233"}, "bq_ids": {"n4140": {"so_39446854_39446854_0": {"section_id": 382, "quality": 0.6, "length": 6}}, "n3337": {"so_39446854_39446854_0": {"section_id": 373, "quality": 0.6, "length": 6}}, "n4659": {"so_39446854_39447173_2": {"section_id": 392, "quality": 0.6153846153846154, "length": 8}}}, "39446890": {"ParentId": "39446854", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-09-12T09:12:55.857", "Score": "18", "LastEditorUserId": "596781", "LastEditDate": "2016-09-12T09:29:21.840", "Id": "39446890", "OwnerUserId": "596781", "Body": "<p>You are creating a dangling reference. Your code is no different from this code:</p>\n<pre><code>struct X\n{\n    const int &amp; r;\n    X() : r(5) {}\n};     // ^^^^ dangles\n</code></pre>\n<p>There is no \"object\" called <code>this</code>. <code>this</code> is a <em>keyword</em>, and when used as an expression, it is a prvalue (a temporary) containing the address of the current instance.</p>\n<p>Here's another example of the creation of a similarly dangling reference from something that looks like an object but isn't:</p>\n<pre><code>struct Y\n{\n    int a[10];\n    int* const &amp; r;\n\n    Y() : r(a) {}\n};\n</code></pre>\n<p>Here, <code>a</code> is a named entity (an lvalue), but in the initializer of <code>r</code>, the <em>expression</em> <code>a</code> is a prvalue (namely the result of the decay of the array).</p>\n<p>The overall message is that you should be careful with the language feature that allows const lvalue references to bind to rvalues. Its main purpose is to make function calls easy, but its other uses are much hairier. </p>\n", "LastActivityDate": "2016-09-12T09:29:21.840"}});