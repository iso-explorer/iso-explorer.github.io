post_cb({"bq_ids": {"n4140": {"so_37882546_37884028_0": {"length": 16, "quality": 1.0, "section_id": 5457}}, "n4659": {"so_37882546_37884028_0": {"length": 16, "quality": 1.0, "section_id": 6883}}}, "37884028": {"Id": "37884028", "PostTypeId": "2", "Body": "<p>Consider <a href=\"http://eel.is/c++draft/dcl.spec.auto#13\" rel=\"nofollow\">[dcl.spec.auto]/13</a>:</p>\n<blockquote>\n<p id=\"so_37882546_37884028_0\">Redeclarations or specializations of a function or function template\n  with a declared return type that uses a placeholder type shall also\n  use that placeholder, not a deduced type.</p>\n</blockquote>\n<p>I.e. if the friend declaration uses <code>auto</code> and the second declaration does not, they don't match. The other way around is guaranteed by <a href=\"http://wg21.link/cwg2081\" rel=\"nofollow\">core issue 2081</a>. Finally, if both use <code>auto</code>, the declarations should indeed match as per <a href=\"http://eel.is/c++draft/temp.over.link#6\" rel=\"nofollow\">[temp.over.link]/6</a>, so Clang is incorrect in that case.</p>\n", "Score": "4", "LastActivityDate": "2016-06-17T14:23:28.730", "CreationDate": "2016-06-17T14:23:28.730", "ParentId": "37882546", "CommentCount": "0", "OwnerUserId": "3647361"}, "37882546": {"ViewCount": "148", "LastEditDate": "2017-05-23T10:28:43.307", "AcceptedAnswerId": "37884028", "Title": "Return type match with auto and friend function", "CreationDate": "2016-06-17T13:14:54.893", "LastActivityDate": "2016-07-29T06:22:35.930", "CommentCount": "0", "Body": "<p>So I was answering this question: <em><a href=\"https://stackoverflow.com/questions/37882049/define-friend-function-template-of-class-template/37882233\">Define friend function template of class template</a></em>, and I found some \"weird\" behavior from g++ (5.3) and clang (3.8):</p>\n<p>Let's assume the following template:</p>\n<pre><code>template&lt;int M&gt;\nstruct test {\nprivate:\n    int value;\n\n    template&lt;int U, int K&gt;\n    friend test&lt;K&gt; foo (test&lt;U&gt; const t);\n};\n\ntemplate &lt;int M, int N = 2 * M&gt;\ntest&lt;N&gt; foo (test&lt;M&gt; const t) {\n    test&lt;N&gt; r;\n    r.value = t.value;\n    return r;\n}\n\nint main(){\n    test&lt;1&gt; t;\n    foo(t);\n}\n</code></pre>\n<p>This compile with both compiler (as expected - If this should not compile, feel free to comment and explain why).</p>\n<p>If I change things to:</p>\n<pre><code>template&lt;int U, int K&gt;\nfriend auto foo(test&lt;U&gt; const t);\n\ntemplate &lt;int M, int N = 2 * M&gt;\nauto foo (test&lt;M&gt; const t) { /* ... */ }\n</code></pre>\n<p>This compile with g++ but not with clang, and if I set one to <code>auto</code> and the other one to a specific value, e.g.:</p>\n<pre><code>template&lt;int U, int K&gt;\nfriend test&lt;K&gt; foo(test&lt;U&gt; const t);\n\ntemplate &lt;int M, int N = 2 * M&gt;\nauto foo (test&lt;M&gt; const t) { /* ... */ }\n\n// or:\n\ntemplate&lt;int U, int K&gt;\nfriend auto foo(test&lt;U&gt; const t);\n\ntemplate &lt;int M, int N = 2 * M&gt;\ntest&lt;N&gt; foo (test&lt;M&gt; const t) { /* ... */ }\n</code></pre>\n<p>Both compiler reject the code saying that:</p>\n<blockquote>\n<p id=\"so_37882546_37882546_0\">error: 'int test&lt;2&gt;::value' is private</p>\n</blockquote>\n<p>My two related questions are:</p>\n<ul>\n<li>Which compiler is right for the first case (<code>auto</code> for both declaration/definition)?</li>\n<li>Why is not possible to use <code>auto</code> when defining the function and <code>test&lt;K&gt;</code> when declaring the friendship?</li>\n</ul>\n<p>Or in one question: <strong>What are the rules about <code>auto</code> for friend function declarations when the function is defined outside the class?</strong></p>\n", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "37882546", "AnswerCount": "1", "Score": "7", "OwnerUserId": "2666289", "Tags": "<c++><c++14><language-lawyer><friend><auto>", "FavoriteCount": "2"}});