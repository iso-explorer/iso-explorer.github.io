post_cb({"24591796": {"Id": "24591796", "PostTypeId": "2", "Body": "<pre><code>this-&gt;bar.baz&lt;int&gt;(); // error\n</code></pre>\n<p>The statement above, within the definition of <code>template&lt;typename T&gt; Foo&lt;T&gt;::Foo()</code>, is well-formed, and should be accepted if C++11 mode or C++1y mode is enabled.  But it was technically ill-formed according to C++03.</p>\n<p>Both standards agree that <code>this</code> is a type-dependent expression:</p>\n<p>C++03 14.6.2.1/1; N3690 14.6.2.1/8:</p>\n<blockquote>\n<p id=\"so_24588207_24591796_0\">A type is dependent if it is</p>\n<ul>\n<li><p id=\"so_24588207_24591796_1\">a template parameter,</p></li>\n<li><p id=\"so_24588207_24591796_2\">...</p></li>\n<li><p id=\"so_24588207_24591796_3\">a [<em>simple-</em>]<em>template-id</em> in which either the template name is a template parameter or any of the template arguments is a dependent type or an expression that is type-dependent or value-dependent,</p></li>\n</ul>\n</blockquote>\n<p>[<code>T</code> is a dependent type, and so is <code>Foo&lt;T&gt;</code>.]</p>\n<p>C++03/N3690 14.6.2.2/2:</p>\n<blockquote>\n<p id=\"so_24588207_24591796_4\"><code>this</code> is type-dependent if the class type of the enclosing member function is dependent.</p>\n</blockquote>\n<p>[Since <code>Foo&lt;T&gt;</code> is a dependent type, the expression <code>this</code> in its member definition is type-dependent.]</p>\n<p>Both standards begin 14.6.2.2 with:</p>\n<blockquote>\n<p id=\"so_24588207_24591796_5\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n</blockquote>\n<p>C++03 has only three simple categories of expressions with more exact descriptions:</p>\n<ul>\n<li><p>Primary expressions (<code>this</code> and looked-up names)</p></li>\n<li><p>Expressions that specify their own type (like casts and new-expressions)</p></li>\n<li><p>Expressions with constant type (like literals and <code>sizeof</code>).</p></li>\n</ul>\n<p>The first category is defined in C++03 14.6.2.2/3:</p>\n<blockquote>\n<p id=\"so_24588207_24591796_6\">An <em>id-expression</em> is type-dependent if it contains:</p>\n<ul>\n<li><p id=\"so_24588207_24591796_7\">an <em>identifier</em> that was declared with a dependent type,</p></li>\n<li><p id=\"so_24588207_24591796_8\">a <em>template-id</em> that is dependent,</p></li>\n<li><p id=\"so_24588207_24591796_9\">a <em>conversion-function-id</em> that specifies a dependent type,</p></li>\n<li><p id=\"so_24588207_24591796_10\">a <em>nested-name-specifier</em> that contains a <em>class-name</em> that names a dependent type.</p></li>\n</ul>\n</blockquote>\n<p>So the lone expression <code>bar</code> is not dependent: it is an <em>identifier</em> and an <em>id-expression</em>, but none of the above apply.</p>\n<p>But <code>this-&gt;bar</code> is not an <em>id-expression</em>, or in any of the other C++03 exceptions, so we have to follow the subexpression rule.  Since subexpression <code>this</code> is type-dependent, the containing expression <code>this-&gt;bar</code> is also type-dependent.</p>\n<p>But in fact, as you noticed, the type of <code>this-&gt;bar</code> can be known while parsing the template definition, without instantiating any template arguments.  It is declared as a member of the primary template, so the name must bind to that member declaration.  A template specialization might make <code>Foo&lt;T&gt;::bar</code> undeclared or declared in a different way, but in that case the primary template won't be used at all and the current definition of <code>Foo()</code> is ignored for that specialization.  Which is why C++11 defined the concept of \"the current instantiation\" and used it for a further exception to the contagiousness of type-dependent expressions.</p>\n<p>N3690 14.6.2.1/1:</p>\n<blockquote>\n<p id=\"so_24588207_24591796_11\">A name refers to the <em>current instantiation</em> if it is</p>\n<ul>\n<li><p id=\"so_24588207_24591796_12\">in the definition of a class template, a nested class of a class template, a member of a class template, or a member of a nested class of a class template, the injected-class-name of the class template or nested class</p></li>\n<li><p id=\"so_24588207_24591796_13\">in the definition of a primary class template or a member of a primary class template, the name of the class template followed by the template argument list of the primary template (as described below) enclosed in <code>&lt;&gt;</code> (or an equivalent template alias specialization),</p></li>\n<li><p id=\"so_24588207_24591796_14\">...</p></li>\n</ul>\n</blockquote>\n<p>[The first bullet says <code>Foo</code> is the current instantiation.  The second says <code>Foo&lt;T&gt;</code> is the current instantiation.  In this example, both name the same type.]</p>\n<p>14.6.2.1/4:</p>\n<blockquote>\n<p id=\"so_24588207_24591796_15\">A name is a <em>member of the current instantiation</em> if it is</p>\n<ul>\n<li><p id=\"so_24588207_24591796_16\">An unqualified name that, when looked up, refers to at least one member of a class that is the current instantiation or a non-dependent base class thereof.</p></li>\n<li><p id=\"so_24588207_24591796_17\">A <em>qualified-id</em> in which ...</p></li>\n<li><p id=\"so_24588207_24591796_18\">An <em>id-expression</em> denoting the member in a class member access expression for which the type of the object expression is the current instantiation, and the <em>id-expression</em>, when looked up, refers to at least one member of a class that is the current instantiation or a non-dependent base class thereof.</p></li>\n</ul>\n</blockquote>\n<p>[The first bullet says <code>bar</code> alone is a member of the current instantiation.  The third bullet says <code>this-&gt;bar</code> is a member of the current instantiation.]</p>\n<p>Finally, C++11 adds a fourth category of rules for type-dependent expressions, for member access.  14.6.2.2/5:</p>\n<blockquote>\n<p id=\"so_24588207_24591796_19\">A class member access expression is type-dependent if the expression refers to a member of the current instantiation and the type of the referenced member is dependent, or the class member access expression refers to a member of an unknown specialization.</p>\n</blockquote>\n<p><code>this-&gt;bar</code> does refer to a member of the current instantiation, but the type <code>Bar</code> of the referenced member is not dependent.  So now <code>this-&gt;bar</code> is not type-dependent, and the name <code>baz</code> in <code>this-&gt;bar.baz</code> is looked up during the template definition as a non-dependent name.  The <code>template</code> keyword is not needed before <code>baz</code>.</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2014-07-06T01:03:44.887", "Score": "4", "CreationDate": "2014-07-06T00:55:51.137", "ParentId": "24588207", "CommentCount": "8", "LastEditDate": "2014-07-06T01:03:44.887", "OwnerUserId": "459640"}, "24589643": {"Id": "24589643", "PostTypeId": "2", "Body": "<h2>Short summary</h2>\n<p>This is just the way the current C++11 rules are: <code>this-&gt;bar.baz&lt;int&gt;()</code> introduces a dependent name not in the current instantiation context that requires disambiguation with the <code>template</code> keyword, even though it is very hard to come up with an actual example of a competing parse that change the semantics of the expression <code>this-&gt;bar.baz&lt;int&gt;()</code>.</p>\n<h2>Parsing ambiguity from angle brackets</h2>\n<p>First: why in general is there a need for <code>template</code>? </p>\n<p>When a C++ compiler encounters an expression <code>f&lt;g&gt;(0)</code>, it can interpret this either as \"call the function template <code>f</code> for template argument <code>g</code> and function argument <code>0</code> and evaluate the result\" or it can mean \"make the comparison <code>(f&lt;g)&gt;(0)</code> for names <code>f</code> and <code>g</code> and constant <code>0</code>.\" Without further information it cannot make this decision. This is an unfortunate consequence of the choice of angle brackets for template arguments.</p>\n<p>In many (most) cases, the compiler <em>does</em> have enough context to decide whether a template expression or a comparison is being parsed. However, when a so-called <strong>dependent name</strong> (essentially a name that is explicitly or implicitly dependent on a template parameter of the current scope) is encountered, another language subtlety comes into play.</p>\n<h2>Two-phase name lookup</h2>\n<p>Because a name dependent on a template could change its meaning (e.g. through specializations) when a template is being instantiated for a concrete type, name lookup of dependent names is done in two phases (quote from <a href=\"http://rads.stackoverflow.com/amzn/click/0201734842\" rel=\"nofollow noreferrer\"><strong>C++ Templates the Complete Guide</strong></a>):</p>\n<blockquote>\n<p id=\"so_24588207_24589643_0\">During the first phase, nondependent names are looked up while the\n  template is being parsed using both the ordinary lookup rules and, if\n  applicable, the rules for argument-dependent lookup (ADL).\n  <strong>Unqualified dependent names</strong> (which are dependent because they look like the name of a function in a function call with dependent\n  arguments) <strong>are also looked up that way, but the result of the lookup\n  is not considered complete until an additional lookup is performed\n  when the template is instantiated</strong>.</p>\n<p id=\"so_24588207_24589643_1\">During the second phase, which occurs when templates are instantiated\n  at a point called the point of instantiation (POI), dependent\n  qualified names are looked up (with the template parameters replaced\n  with the template arguments for that specific instantiation), <strong>and an\n  additional ADL is performed for the unqualified dependent names.</strong></p>\n</blockquote>\n<h2>Why <code>this-&gt;</code> makes your code different</h2>\n<p>Using <code>this-&gt;</code> inside a class template introduces a dependent name and triggers two-phase name lookup. In that case, the rule cited by @40two comes into play. The point is that the ADL at the 2nd phase can bring in new names from explicit specializations that redefine the meaning of your <code>bar</code> and <code>baz</code> and it could conceivably change the meaning of <code>this-&gt;bar.baz&lt;int&gt;(0)</code> to a comparison rather than a function template call. </p>\n<p>Granted, for non-type template arguments such as <code>this-&gt;bar.another_baz&lt;0&gt;()</code> this would be more likely than for a type template parameter. In <a href=\"https://stackoverflow.com/q/22069758/819272\"><strong>this related Q&amp;A</strong></a> a similar discussion arose whether one could find a syntactic valid form that changes the meaning of <code>this-&gt;f&lt;int&gt;()</code> vs <code>this-&gt;template f&lt;int&gt;(0)</code>, without a clear conclusion.</p>\n<p>Note that C++11 already relaxes the rule for <code>template</code> disambiguation compared to C++98. Under the current rules <code>this-&gt;f&lt;int&gt;()</code> for a <code>template&lt;class&gt; f()</code> inside <code>Foo</code> would not require <code>template</code> because it is in the so-called <strong>current instantiation</strong>. See <a href=\"https://stackoverflow.com/a/17579889/819272\"><strong>this answer</strong></a> from the <a href=\"https://stackoverflow.com/q/610245/819272\"><strong>canonical Q&amp;A</strong></a> for this topic for more details</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-05T19:00:20.567", "Score": "3", "CreationDate": "2014-07-05T19:00:20.567", "ParentId": "24588207", "CommentCount": "13", "LastEditDate": "2017-05-23T11:49:24.937", "OwnerUserId": "819272"}, "24588207": {"ViewCount": "349", "Body": "<pre><code>struct Bar {\n    template&lt;typename&gt;\n    void baz() {\n    }\n};\n\ntemplate&lt;typename&gt;\nstruct Foo {\n    Bar bar;\n\n    Foo() {\n        bar.baz&lt;int&gt;();\n    }\n};\n\nint main() {\n    return 0;\n}\n</code></pre>\n<p>This code compiles fine (in GCC 4.7), but if I prefix the call to <code>bar.baz&lt;int&gt;()</code> with <code>this-&gt;</code>, <code>baz</code> becomes a dependent name that needs disambiguating with <code>template</code>.</p>\n<pre><code>bar.baz&lt;int&gt;(); // OK\nthis-&gt;bar.baz&lt;int&gt;(); // error\nthis-&gt;bar.template baz&lt;int&gt;(); // OK\n</code></pre>\n<p>Surely <code>this-&gt;bar</code> can only refer to <code>Bar bar</code>, whose member <code>baz</code> is clearly a template?  Why does the addition of <code>this-&gt;</code> make this code ambiguous to the compiler?</p>\n<p>p.s. Originally, <code>bar</code> was a data member of a base class template which needed disambiguating with <code>this-&gt;</code>, but I have simplified the example for the purpose of this question.</p>\n", "AcceptedAnswerId": "24591796", "Title": "Why is template function of data member a dependent name only when qualifying with \"this\"?", "CreationDate": "2014-07-05T16:04:10.703", "Id": "24588207", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-07-06T12:33:23.473", "LastEditorUserId": "1563039", "LastActivityDate": "2014-07-06T12:33:23.473", "Score": "14", "OwnerUserId": "1563039", "Tags": "<c++><templates><c++11><dependent-name>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_24588207_24591796_7": {"length": 4, "quality": 0.8, "section_id": 202}, "so_24588207_24591796_5": {"length": 7, "quality": 1.0, "section_id": 200}, "so_24588207_24591796_11": {"length": 4, "quality": 1.0, "section_id": 72}, "so_24588207_24588297_0": {"length": 26, "quality": 0.7878787878787878, "section_id": 72}, "so_24588207_24591796_18": {"length": 26, "quality": 1.0, "section_id": 194}, "so_24588207_24591796_12": {"length": 20, "quality": 1.0, "section_id": 191}, "so_24588207_24591796_19": {"length": 22, "quality": 1.0, "section_id": 204}, "so_24588207_24588297_1": {"length": 7, "quality": 0.875, "section_id": 201}, "so_24588207_24591796_3": {"length": 13, "quality": 1.0, "section_id": 198}, "so_24588207_24591796_15": {"length": 4, "quality": 1.0, "section_id": 72}, "so_24588207_24591796_4": {"length": 7, "quality": 1.0, "section_id": 201}, "so_24588207_24591796_10": {"length": 4, "quality": 0.6666666666666666, "section_id": 202}, "so_24588207_24591796_16": {"length": 15, "quality": 1.0, "section_id": 194}, "so_24588207_24591796_9": {"length": 4, "quality": 1.0, "section_id": 202}, "so_24588207_24591796_13": {"length": 24, "quality": 1.0, "section_id": 191}}, "n3337": {"so_24588207_24591796_7": {"length": 4, "quality": 0.8, "section_id": 196}, "so_24588207_24591796_5": {"length": 7, "quality": 1.0, "section_id": 194}, "so_24588207_24591796_11": {"length": 4, "quality": 1.0, "section_id": 67}, "so_24588207_24588297_0": {"length": 26, "quality": 0.7878787878787878, "section_id": 67}, "so_24588207_24591796_18": {"length": 25, "quality": 0.9615384615384616, "section_id": 188}, "so_24588207_24591796_12": {"length": 20, "quality": 1.0, "section_id": 185}, "so_24588207_24591796_4": {"length": 7, "quality": 1.0, "section_id": 195}, "so_24588207_24588297_1": {"length": 7, "quality": 0.875, "section_id": 195}, "so_24588207_24591796_3": {"length": 13, "quality": 1.0, "section_id": 192}, "so_24588207_24591796_15": {"length": 4, "quality": 1.0, "section_id": 67}, "so_24588207_24591796_19": {"length": 22, "quality": 1.0, "section_id": 198}, "so_24588207_24591796_9": {"length": 4, "quality": 1.0, "section_id": 196}, "so_24588207_24591796_16": {"length": 15, "quality": 1.0, "section_id": 188}, "so_24588207_24591796_13": {"length": 24, "quality": 1.0, "section_id": 185}}, "n4659": {"so_24588207_24591796_7": {"length": 4, "quality": 0.8, "section_id": 208}, "so_24588207_24591796_5": {"length": 7, "quality": 1.0, "section_id": 206}, "so_24588207_24591796_11": {"length": 4, "quality": 1.0, "section_id": 200}, "so_24588207_24591796_18": {"length": 26, "quality": 1.0, "section_id": 200}, "so_24588207_24591796_12": {"length": 20, "quality": 1.0, "section_id": 196}, "so_24588207_24591796_4": {"length": 7, "quality": 1.0, "section_id": 207}, "so_24588207_24588297_1": {"length": 7, "quality": 0.875, "section_id": 207}, "so_24588207_24591796_3": {"length": 13, "quality": 1.0, "section_id": 204}, "so_24588207_24591796_15": {"length": 4, "quality": 1.0, "section_id": 196}, "so_24588207_24591796_19": {"length": 22, "quality": 1.0, "section_id": 210}, "so_24588207_24591796_10": {"length": 4, "quality": 0.6666666666666666, "section_id": 208}, "so_24588207_24591796_16": {"length": 15, "quality": 1.0, "section_id": 200}, "so_24588207_24591796_9": {"length": 4, "quality": 1.0, "section_id": 208}, "so_24588207_24591796_13": {"length": 24, "quality": 1.0, "section_id": 196}}}, "24588297": {"Id": "24588297", "PostTypeId": "2", "Body": "<p>According to the standard <em>\u00a7 14.2/4  Names of template specializations [temp.names]</em> </p>\n<blockquote>\n<p id=\"so_24588207_24588297_0\"><em>When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a post\ufb01x-expression or after a nested-name-speci\ufb01er in a quali\ufb01ed-id, and the object expression of the post\ufb01x-expression is type-dependent or the nested-name-speci\ufb01er in the quali\ufb01ed-id refers to a dependent type, but the name is not a member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword <code>template</code>.</em></p>\n</blockquote>\n<p>Edit:</p>\n<p>Also, according the standard <em>\u00a7 14.6.2.2/2 Type-dependent expressions [temp.dep.expr]</em>:</p>\n<blockquote>\n<p id=\"so_24588207_24588297_1\"><code>this</code> is type-dependent if the class type of the enclosing member function is dependent (14.6.2.1).</p>\n</blockquote>\n<p>Thus, in order to call <code>bar.baz&lt;int&gt;()</code> via <code>this</code> you need to prefixed by the keyword <code>template</code>:</p>\n<pre><code>this-&gt;bar.template baz&lt;int&gt;();\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c476dc77fbe81092\" rel=\"nofollow\"><kbd><strong>LIVE DEMO</strong></kbd></a></p>\n<p>[<strong>Reason:</strong>]\nThe compiler needs this \"redantant\"  use of <code>template</code> keyword, because it can't decide whether the token <code>&lt;</code>  is <code>operator&lt;</code> or the beginning of a template argument list.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2014-07-05T18:39:57.490", "Score": "2", "CreationDate": "2014-07-05T16:16:40.283", "ParentId": "24588207", "CommentCount": "6", "LastEditDate": "2014-07-05T18:39:57.490", "OwnerUserId": "2352671"}});