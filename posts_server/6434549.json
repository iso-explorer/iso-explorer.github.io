post_cb({"6434582": {"ParentId": "6434549", "CommentCount": "10", "Body": "<p>The only mention of <code>restrict</code> in the C++11 FDIS is on \u00a717.2 [library.c]:</p>\n<blockquote>\n<p id=\"so_6434549_6434582_0\">The descriptions of many library functions rely on the C standard library for the signatures and semantics\n  of those functions. In all such cases, any use of the <code>restrict</code> quali\ufb01er shall be omitted.</p>\n</blockquote>\n<p>So <code>restrict</code> is not in C++11.</p>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "6434582", "Score": "17", "CreationDate": "2011-06-22T03:28:26.927", "LastActivityDate": "2011-06-22T03:28:26.927"}, "6434616": {"ParentId": "6434549", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Don't think it's in C++1x (unfortunately time has long run out for 0x...!) but at least msvc and g++ support it through <code>__restrict</code> and <code>__restrict__</code> extensions. (I don't use gcc much, I think that's the correct extension).</p>\n<p>To work <em>properly</em> with C++ I feel that we would also need restricted references, not just pointers, maybe along the lines of my question <a href=\"https://stackoverflow.com/questions/6320789/c-aliasing-rules\">C++ aliasing rules</a>. Not sure if some of these considerations might be holding things up...</p>\n", "OwnerUserId": "566274", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:07.537", "Id": "6434616", "Score": "5", "CreationDate": "2011-06-22T03:33:46.937", "LastActivityDate": "2011-06-22T03:33:46.937"}, "6442964": {"ParentId": "6434549", "CommentCount": "3", "Body": "<p>I will take a crack at \"why not?\"</p>\n<p><code>restrict</code> is basically just an assertion that the compiler cannot verify. (Or more precisely, when the compiler <em>can</em> verify it, the assertion itself is not helpful.)  This is just not the sort of thing that the C++ committee is going to like.  C++ has always tended to assume \"sufficiently smart compilers\"; heck, look at the hideous performance of the most trivial C++ libraries before the compilers caught up.</p>\n<p>I also suspect the committee felt that defining <code>restrict</code> semantics precisely in the presence of all the other C++ features (references, rvalue references, blah blah blah) would be non-trivial.</p>\n<p>So, non-trivial to specify + \"a sufficiently smart compiler doesn't need it\" = NAK.</p>\n", "OwnerUserId": "768469", "PostTypeId": "2", "Id": "6442964", "Score": "1", "CreationDate": "2011-06-22T16:01:27.913", "LastActivityDate": "2011-06-22T16:01:27.913"}, "10707915": {"ParentId": "6434549", "CommentCount": "1", "Body": "<p><a href=\"http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/\" rel=\"noreferrer\">http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/</a></p>\n<blockquote>\n<p id=\"so_6434549_10707915_0\">Not only the VC++ team, but also the ISO C++ standards committee, considered adding restrict to VC++ and ISO C++, respectively. Although it was specifically suggested for ISO C++11, it was rejected, in part because it\u2019s not always obvious how it extends to C++ code because C++ is a larger language with more options and we would want to make sure the feature works correctly across the entire language.</p>\n</blockquote>\n", "OwnerUserId": "847305", "PostTypeId": "2", "Id": "10707915", "Score": "13", "CreationDate": "2012-05-22T18:30:47.923", "LastActivityDate": "2012-05-22T18:30:47.923"}, "6442631": {"ParentId": "6434549", "CommentCount": "3", "Body": "<p>One argument is that C needs <code>restrict</code> more than C++, because many operations are done with pointers to primitive types and therefore C code has <strong>more</strong> aliasing problems than C++. </p>\n<p>The aliasing rules say that pointers to different types cannot alias, so if the parameters to a function are of different class types they just cannot overlap. </p>\n<p>In C++ we also have the <code>valarray</code> family of classes that are supposed to handle arrays of primitive types that are not allowed to alias. Not that it is used much...</p>\n<p>Adding yet another way to resolve some aliasing problems, obviously didn't excite the committee enough.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "6442631", "Score": "14", "CreationDate": "2011-06-22T15:41:00.370", "LastActivityDate": "2011-06-22T15:41:00.370"}, "bq_ids": {"n4140": {"so_6434549_6434582_0": {"section_id": 6205, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_6434549_6434582_0": {"section_id": 5965, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_6434549_6434582_0": {"section_id": 7708, "quality": 0.6666666666666666, "length": 12}}}, "6434549": {"CommentCount": "7", "AcceptedAnswerId": "6442631", "PostTypeId": "1", "LastEditorUserId": "292761", "CreationDate": "2011-06-22T03:21:34.240", "LastActivityDate": "2012-05-22T18:30:47.923", "LastEditDate": "2012-02-14T02:07:46.893", "ViewCount": "5731", "FavoriteCount": "3", "Title": "Does C++11 add the C99 restrict specifier? If not, why not?", "Id": "6434549", "Score": "27", "Body": "<p><code>restrict</code> is a C99 feature which is getting a lot of attention lately by allowing the compiler to perform \"previously-fortran-only\" optimizations to pointers. It's also the same keyword announced by Microsoft recently to be the underpinnings of the C++AMP specification.</p>\n<p>Is that keyword actually in the FCD? If not, is there a specific reason it was omitted?</p>\n", "Tags": "<c++><c++11><c++-amp>", "OwnerUserId": "82320", "AnswerCount": "5"}});