post_cb({"bq_ids": {"n4140": {"so_33913670_33913670_0": {"length": 86, "quality": 0.7610619469026548, "section_id": 7151}}, "n3337": {"so_33913670_33913670_0": {"length": 87, "quality": 0.7699115044247787, "section_id": 6895}}}, "33913670": {"ViewCount": "339", "Body": "<p>I have encountered a strange situation recently.</p>\n<p>Let's consider the following class (place in <code>header.h</code>):</p>\n<pre><code>#ifndef HEADER_H\n#define HEADER_H\n\n#include &lt;set&gt;\n\ntemplate &lt;class V, class T&gt;\nclass Class\n{\npublic:\n    typedef std::set&lt;const Class&lt;V, T&gt;* &gt; instances_list;\n\n    explicit Class(const V&amp; Value):m_value(Value)\n    {\n    s_instances.insert(this);\n    }\nprivate:\n    static instances_list s_instances;\n    V m_value;\n};\n\ntemplate &lt;typename V, typename T&gt;\ntypename Class&lt;V,T&gt;::instances_list Class&lt;V,T&gt;::s_instances;\n\nclass Something : public Class&lt;int, Something&gt;\n{\npublic:\n    static const Something SOMETHING_CONSTANT;\n\nprivate:\n    explicit Something(int value): Class&lt;int, Something&gt;(value)\n    {}\n};\n\n#endif\n</code></pre>\n<p>and a very simple application using it:</p>\n<pre><code>#include \"header.h\"\n\nconst Something Something::SOMETHING_CONSTANT (1);\n\nint main()\n{\n}\n</code></pre>\n<p>Compiling it results in various degrees of successfulness.</p>\n<p>g++ (4.9.2, 4.8.4 and 4.3.2) compiles an executable, but they produce a SEGFAULT, with a stack trace like:</p>\n<pre><code>#0  0x00007ffff7b4aaaa in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6\n#1  0x00000000004012bb in std::_Rb_tree_iterator&lt;Class&lt;int, Something&gt; const*&gt;::operator-- (this=0x7fffffffdcf0) at /usr/include/c++/4.8/bits/stl_tree.h:204\n#2  0x0000000000400ef2 in std::_Rb_tree&lt;Class&lt;int, Something&gt; const*, Class&lt;int, Something&gt; const*, std::_Identity&lt;Class&lt;int, Something&gt; const*&gt;, std::less&lt;Class&lt;int, Something&gt; const*&gt;, std::allocator&lt;Class&lt;int, Something&gt; const*&gt; &gt;::_M_get_insert_unique_pos (this=0x6030c0 &lt;Class&lt;int, Something&gt;::s_instances&gt;, __k=@0x7fffffffde08: 0x6030a4 &lt;Something::SOMETHING_CONSTANT&gt;) at /usr/include/c++/4.8/bits/stl_tree.h:1333\n#3  0x0000000000400c1d in std::_Rb_tree&lt;Class&lt;int, Something&gt; const*, Class&lt;int, Something&gt; const*, std::_Identity&lt;Class&lt;int, Something&gt; const*&gt;, std::less&lt;Class&lt;int, Something&gt; const*&gt;, std::allocator&lt;Class&lt;int, Something&gt; const*&gt; &gt;::_M_insert_unique (this=0x6030c0 &lt;Class&lt;int, Something&gt;::s_instances&gt;, __v=@0x7fffffffde08: 0x6030a4 &lt;Something::SOMETHING_CONSTANT&gt;) at /usr/include/c++/4.8/bits/stl_tree.h:1377\n#4  0x0000000000400b19 in std::set&lt;Class&lt;int, Something&gt; const*, std::less&lt;Class&lt;int, Something&gt; const*&gt;, std::allocator&lt;Class&lt;int, Something&gt; const*&gt; &gt;::insert (this=0x6030c0 &lt;Class&lt;int, Something&gt;::s_instances&gt;, \n    __x=@0x7fffffffde08: 0x6030a4 &lt;Something::SOMETHING_CONSTANT&gt;) at /usr/include/c++/4.8/bits/stl_set.h:463\n#5  0x0000000000400ad9 in Class&lt;int, Something&gt;::Class (this=0x6030a4 &lt;Something::SOMETHING_CONSTANT&gt;, Value=@0x7fffffffde24: 1) at header.h:14\n#6  0x0000000000400aa2 in Something::Something (this=0x6030a4 &lt;Something::SOMETHING_CONSTANT&gt;, value=1) at header.h:30\n#7  0x0000000000400a24 in __static_initialization_and_destruction_0 (__initialize_p=1, __priority=65535) at main.cpp:3\n#8  0x0000000000400a6b in _GLOBAL__sub_I__ZN9Something18SOMETHING_CONSTANTE () at main.cpp:7\n#9  0x00000000004015ed in __libc_csu_init ()\n#10 0x00007ffff751ce55 in __libc_start_main (main=0x4009ed &lt;main()&gt;, argc=1, argv=0x7fffffffdf88, init=0x4015a0 &lt;__libc_csu_init&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdf78) at libc-start.c:246\n#11 0x0000000000400929 in _start ()\n</code></pre>\n<p>clang (3.4.1 and 3.5.0-10) produce an executable which runs nicely, does not segfault.</p>\n<p>Visual Studio 2015 produces a segfaulting application.</p>\n<p>If I put everything in one file the compiler found at ideone.com (<a href=\"http://ideone.com/Dhh8Hl\" rel=\"nofollow noreferrer\">http://ideone.com/Dhh8Hl</a>) produces a runtime error, signal 11.</p>\n<p>I have the feeling, this is undefined behaviour ... Please correct me if I'm not right.</p>\n<p>After reading relevant questions: <a href=\"https://stackoverflow.com/questions/1819131/c-static-member-initalization-template-fun-inside\">C++ Static member initalization (template fun inside)</a> , <a href=\"https://stackoverflow.com/questions/23841022/template-static-members-initialization-order\">Template static members initialization order</a> and <a href=\"https://stackoverflow.com/questions/10011039/initialization-order-of-static-data-inside-class-template/10011133#10011133\">Initialization order of static data inside class template</a> I am still unable to find relevant paragraphs from the standard which tell me why does this fail when compiled with g++ and MSVC but passes on clang.</p>\n<p>The (3.6.2) tells me:</p>\n<blockquote>\n<p id=\"so_33913670_33913670_0\">Objects with static storage duration (3.7.1) shall be zero-initialized\n  (8.5) before any other initialization takes place. A reference with\n  static storage duration and an object of POD type with static storage\n  duration can be initialized with a constant expression (5.19); this is\n  called constant initialization. Together, zero-initialization and\n  constant initialization are called static initialization; all other\n  initialization is dynamic initialization. Static initialization shall\n  be performed before any dynamic initialization takes place. Dynamic\n  initialization of an object is either ordered or unordered.\n  Definitions of explicitly specialized class template static data\n  members have ordered initialization. Other class template static data\n  members (i.e., implicitly or explicitly instantiated specializations)\n  have unordered initialization. Other objects defined in namespace\n  scope have ordered initialization. Objects defined within a single\n  translation unit and with ordered initialization shall be initialized\n  in the order of their definitions in the translation unit. The order\n  of initialization is unspecified for objects with unordered\n  initialization and for objects defined in different translation units.</p>\n</blockquote>\n<p>and from it I understand that <code>Static initialization shall\nbe performed before any dynamic initialization takes place.</code> and in my opinion <code>const Something Something::SOMETHING_CONSTANT (1);\n</code> falls in the category of constant initialization (please correct me if I'm wrong) thus it is a static initialization. Also, the one above says that <code>Other class template static data\nmembers (i.e., implicitly or explicitly instantiated specializations)\nhave unordered initialization.</code> which is fine, since I have only one of those, but I just cannot see why the static template member is not initialized before the actual member of that type.</p>\n<p>I have solved the problem using <a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order\" rel=\"nofollow noreferrer\">https://isocpp.org/wiki/faq/ctors#static-init-order</a> so now I am just curious why there is so different behaviour from the compilers, and which is correct.</p>\n", "AcceptedAnswerId": "33914576", "Title": "The classical C++ static initialization order fiasco revisited", "CreationDate": "2015-11-25T10:11:13.297", "Id": "33913670", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:17:14.320", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-25T10:51:45.987", "Score": "4", "OwnerUserId": "186193", "Tags": "<c++><templates><static><static-initialization>", "AnswerCount": "1"}, "33914576": {"PostTypeId": "2", "Body": "<p>The initialization</p>\n<pre><code>const Somthing SomeThing::SOMETHING_CONST(1);\n</code></pre>\n<p>is <em>not</em> constant initialization: it initializes a <code>const</code> but does so dynamically, i.e., it is dynamic initialization. Constant initialization happens when computing a <em>constant expression</em>. That's a more specific meaning than just <code>const</code> and only applies to entities which can be computed during compilation (see section 5.19 [expr.const] for more details).</p>\n<p>If you want this initialization to happen as constant initialization you need to make your constructor <code>constexpr</code>. Given that you access a <code>std::set&lt;int&gt;</code> during this initialization I doubt that you'll manage to make your constructor <code>constexpr</code>.</p>\n<p>This is just the usual peril of using global objects. If you need some level of control of the initialization order use the usual hack to get the global objects at least initialized in a suitable order and wrap them into a function returning a reference to a local static variable. Alternatively you <em>may</em> be able to create something akin to a <code>constexpr</code> version of a <code>std::set&lt;int&gt;</code> which then could be used for constant initialization.</p>\n", "LastActivityDate": "2015-11-25T10:51:45.987", "Id": "33914576", "CommentCount": "3", "CreationDate": "2015-11-25T10:51:45.987", "ParentId": "33913670", "Score": "5", "OwnerUserId": "1120273"}});