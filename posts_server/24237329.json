post_cb({"bq_ids": {"n4140": {"so_24237329_24237615_5": {"length": 16, "quality": 0.8, "section_id": 460}, "so_24237329_24237615_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 456}, "so_24237329_24237615_3": {"length": 7, "quality": 1.0, "section_id": 460}, "so_24237329_24237615_4": {"length": 20, "quality": 0.8695652173913043, "section_id": 460}, "so_24237329_24237615_2": {"length": 14, "quality": 0.875, "section_id": 460}, "so_24237329_24237615_6": {"length": 10, "quality": 0.7692307692307693, "section_id": 369}, "so_24237329_24237615_7": {"length": 8, "quality": 1.0, "section_id": 460}}, "n3337": {"so_24237329_24237615_5": {"length": 19, "quality": 0.95, "section_id": 451}, "so_24237329_24237615_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 447}, "so_24237329_24237615_3": {"length": 7, "quality": 1.0, "section_id": 451}, "so_24237329_24237615_4": {"length": 22, "quality": 0.9565217391304348, "section_id": 451}, "so_24237329_24237615_2": {"length": 14, "quality": 0.875, "section_id": 451}, "so_24237329_24237615_6": {"length": 13, "quality": 1.0, "section_id": 359}, "so_24237329_24237615_7": {"length": 8, "quality": 1.0, "section_id": 451}}, "n4659": {"so_24237329_24237615_5": {"length": 16, "quality": 0.8, "section_id": 483}, "so_24237329_24237615_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 479}, "so_24237329_24237615_3": {"length": 7, "quality": 1.0, "section_id": 483}, "so_24237329_24237615_4": {"length": 20, "quality": 0.8695652173913043, "section_id": 483}, "so_24237329_24237615_2": {"length": 14, "quality": 0.875, "section_id": 483}, "so_24237329_24237615_6": {"length": 10, "quality": 0.7692307692307693, "section_id": 382}, "so_24237329_24237615_7": {"length": 8, "quality": 1.0, "section_id": 483}}}, "24237329": {"ViewCount": "589", "Body": "<p>As I knew until today there are four default things create when creating a new class. \"Default constructor\", \"Destructor\", \"Copy constructor\" and \"Assignment operator\". But today when I was going trough a C++ article, it said that there can be situations where the copy constructor is not create by default.</p>\n<ol>\n<li>Is that true?</li>\n<li>If it is, in which situations?</li>\n<li>In those situations, how can an instance of that class be passed by value?</li>\n</ol>\n", "Title": "Is a copy constructor always created by default?", "CreationDate": "2014-06-16T05:53:35.837", "LastActivityDate": "2014-06-16T06:57:08.510", "CommentCount": "1", "LastEditDate": "2014-06-16T05:56:18.270", "PostTypeId": "1", "LastEditorUserId": "635608", "Id": "24237329", "Score": "4", "OwnerUserId": "1268258", "Tags": "<c++><copy-constructor>", "AnswerCount": "2"}, "24237419": {"Id": "24237419", "PostTypeId": "2", "Body": "<p>Yes, that is correct. For example, if a member of the class is not copyable/assignable (e.g. a member has a private assignment operator and private copy constructor), then you won't be able to rely on a default copy constructor for the containing class. If you want the containing class to be copyable/assignable under those circumstances, then you need to define those operations explicitly.</p>\n<p>That being said, in most cases, you should avoid passing by value. In most circumstances, you should be passing an object by constant reference or passing a smart pointer (e.g. <code>std::unique_ptr</code>) of your object. Passing by value (and any code that does an unnecessary amount of copying) will produce less efficient code than cases where you are able to reuse existing implementations. Additionally, for polymorphic objects, pass-by-value causes \"slicing\" (the functionality is truncated from the runtime type to the declared type to which the object is being copied), and so pass-by-value is particularly dangerous and error-prone when operating with any data types that might possibly be inherited.</p>\n<p><b>Edit</b><br/>\nTo clarify the above a little bit... in terms of passing by const-reference vs passing by value, the decision should depend on the size of the object and how expensive it is to copy. Boost provides a handy mechanism in \"call traits\" (<a href=\"http://www.boost.org/doc/libs/1_51_0/libs/utility/call_traits.htm\" rel=\"nofollow\">call_traits&lt;T&gt;::param_type</a>) to automatically select between a value and a const reference based on the size of an object. When making this decision, it's also useful to distinguish between value types (objects that behave similarly to primitives -- for example, by overloading various operators and that are copyable, assignable, and cannot be inherited) and user-defined polymorphic types. Whenever you have a type that declares a virtual method, as a general rule of thumb, that object should be passed by reference or const reference to avoid the slicing which I mentioned above.</p>\n<p>In terms of passing by smart pointer, generally this is done when transferring or sharing ownership (otherwise you should generally just pass around a reference to the object in question).</p>\n", "LastEditorUserId": "136540", "LastActivityDate": "2014-06-16T06:28:28.290", "Score": "0", "CreationDate": "2014-06-16T06:01:56.297", "ParentId": "24237329", "CommentCount": "20", "OwnerUserId": "136540", "LastEditDate": "2014-06-16T06:28:28.290"}, "24237615": {"Id": "24237615", "PostTypeId": "2", "Body": "<p>1) Yes, there can be situations where the copy constructor is not created by default.</p>\n<p>2) The conditions where the implicitly declared default constructor is <em>deleted</em> are laid out in <strong>12.8 Copying and moving class objects [class.copy]</strong>:</p>\n<p><strong>12.8.7</strong> is about how the declaration of other special member functions affect the implicitly declared copy constructor. Whenever the class declares a copy constructor, a move constructor or a move assignment operator. If it declares any one of those, then you don't get an implicitly declared one. </p>\n<blockquote>\n<p id=\"so_24237329_24237615_0\">...</p>\n<p id=\"so_24237329_24237615_1\"><sup>7</sup> If the class definition does not explicitly declare a copy\n  constructor, one is declared implicitly. If the class definition\n  declares a move constructor or move assignment operator, the\n  implicitly declared copy constructor is defined as deleted; otherwise,\n  it is defined as defaulted (8.4). The latter case is deprecated if the\n  class has a user-declared copy assignment operator or a user-declared\n  destructor.</p>\n</blockquote>\n<p><strong>12.8.11</strong> is about how the data members and base classes affect the implicitly declared copy constructor. Essentially, if the class has any data members or base classes that are not copyable, the implicitly declared copy constructor is <code>delete</code>d:</p>\n<blockquote>\n<p id=\"so_24237329_24237615_2\"><sup>11</sup> An implicitly-declared copy/move constructor is an inline public\n  member of its class. A defaulted copy/ move constructor for a class X\n  is defined as deleted (8.4.3) if X has: </p>\n<p id=\"so_24237329_24237615_3\">\u2014 a variant member with a\n  non-trivial corresponding constructor and X is a union-like class, </p>\n<p id=\"so_24237329_24237615_4\">\u2014 a non-static data member of class type M (or array thereof) that cannot\n  be copied/moved because overload resolution (13.3), as applied to M\u2019s\n  corresponding constructor, results in an ambiguity or a function that\n  is deleted or inaccessible from the defaulted constructor, </p>\n<p id=\"so_24237329_24237615_5\">\u2014 a direct or virtual base class B that cannot be copied/moved because overload\n  resolution (13.3), as applied to B\u2019s corresponding constructor,\n  results in an ambiguity or a function that is deleted or inaccessible\n  from the defaulted constructor, </p>\n<p id=\"so_24237329_24237615_6\">\u2014 any direct or virtual base class or\n  non-static data member of a type with a destructor that is deleted or\n  inaccessible from the defaulted constructor, </p>\n<p id=\"so_24237329_24237615_7\">\u2014 for the copy\n  constructor, a non-static data member of rvalue reference type, or </p>\n<p id=\"so_24237329_24237615_8\">...</p>\n</blockquote>\n<p>3) You can declare and define (either by providing an implementation or <code>default</code>ing a copy constructor, or a move copy constructor, or both.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2014-06-16T06:57:08.510", "Score": "5", "CreationDate": "2014-06-16T06:17:18.523", "ParentId": "24237329", "CommentCount": "2", "OwnerUserId": "661519", "LastEditDate": "2014-06-16T06:57:08.510"}});