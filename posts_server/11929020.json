post_cb({"11929299": {"ParentId": "11929020", "CommentCount": "6", "Body": "<p>The explanation if found in the next section, [24.2.5] Forward iterators, where it is stated how these differ from input and output iterators:</p>\n<blockquote>\n<p id=\"so_11929020_11929299_0\">Two dereferenceable iterators <code>a</code> and <code>b</code> of type <code>X</code> offer the <em>multi-pass guarantee</em> if: </p>\n<p id=\"so_11929020_11929299_1\">\u2014 <code>a == b</code> implies <code>++a == ++b</code> and<br>\n  \u2014 <code>X</code> is a pointer type or the expression <code>(void)++X(a), *a</code> is equivalent to the expression <code>*a</code>.</br></p>\n<p id=\"so_11929020_11929299_2\">[ Note: The requirement that <code>a == b</code> implies <code>++a == ++b</code> (which is not true for input and output iterators) and the removal of the restrictions on the number of the assignments through a mutable iterator (which applies to output iterators) allows the use of multi-pass one-directional algorithms with forward iterators.\n  \u2014end note ]</p>\n</blockquote>\n<p>Unfortunately, the standard must be read as a whole, and the explanation is not always where you expect it to be. </p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "11929299", "Score": "6", "CreationDate": "2012-08-13T06:41:45.240", "LastActivityDate": "2012-08-13T06:41:45.240"}, "11930403": {"ParentId": "11929020", "CommentCount": "1", "Body": "<p>Input and output iterators are basically designed to allow single-pass traversal: to describe sequences where each element can only be visited once.</p>\n<p>Streams are a great example. If you read from stdin or a socket, or write to a file, then there is only the stream's current position. All other iterators pointing to the same underlying sequence are invalidated when you increment an iterator.</p>\n<p>Forward iterators allow multi-pass traversal, the additional guarantee you need: they ensure that you can copy your iterator, increment the original, and the copy will <em>still</em> point to the old position, so you can iterate from there.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "11930403", "Score": "3", "CreationDate": "2012-08-13T08:14:05.850", "LastActivityDate": "2012-08-13T08:14:05.850"}, "bq_ids": {"n4140": {"so_11929020_11929020_0": {"section_id": 5558, "quality": 0.8, "length": 12}, "so_11929020_11929299_2": {"section_id": 5576, "quality": 0.8518518518518519, "length": 23}, "so_11929020_11929299_1": {"section_id": 5575, "quality": 1.0, "length": 7}, "so_11929020_11929299_0": {"section_id": 5575, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_11929020_11929020_0": {"section_id": 5340, "quality": 0.8, "length": 12}, "so_11929020_11929299_2": {"section_id": 5358, "quality": 0.8518518518518519, "length": 23}, "so_11929020_11929299_1": {"section_id": 5357, "quality": 1.0, "length": 7}, "so_11929020_11929299_0": {"section_id": 5357, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_11929020_11929020_0": {"section_id": 7003, "quality": 0.6666666666666666, "length": 10}, "so_11929020_11929299_2": {"section_id": 7023, "quality": 0.8518518518518519, "length": 23}, "so_11929020_11929299_1": {"section_id": 7022, "quality": 1.0, "length": 7}, "so_11929020_11929299_0": {"section_id": 7022, "quality": 0.8571428571428571, "length": 6}}}, "11929020": {"CommentCount": "4", "CreationDate": "2012-08-13T06:15:53.570", "PostTypeId": "1", "AcceptedAnswerId": "11929299", "LastEditorUserId": "560648", "LastActivityDate": "2014-11-17T23:19:14.623", "LastEditDate": "2014-11-17T23:19:14.623", "ViewCount": "649", "FavoriteCount": "1", "Title": "Does incrementing a mutable input iterator invalidate old iterator values?", "Id": "11929020", "Score": "7", "Body": "<blockquote>\n<p id=\"so_11929020_11929020_0\">Iterators that further satisfy the requirements of output iterators are called <em>mutable iterators</em>. Nonmutable iterators are referred to as <em>constant iterators</em>. [24.2.1:4]</p>\n</blockquote>\n<p>This suggests you could have a mutable input iterator, which meets the requirements of both input and output iterators.  </p>\n<p>After incrementing an input iterator, copies of its old value need not be dereferenceable [24.2.3]. However, the standard does not say the same for output iterators; in fact, the operational semantics for postfix increment are given as <code>{ X tmp = r; ++r; return tmp; }</code>, suggesting that output iterators may not invalidate (copies of) old iterator values.</p>\n<p>So, can incrementing a mutable input iterator invalidate old iterator copies?</p>\n<p>If so, how would you support code like <code>X a(r++); *a = t</code> or <code>X::reference p(*r++); p = t</code> with (e.g.) a proxy object?</p>\n<p>If not, then why does <a href=\"http://www.boost.org/doc/libs/1_50_0/boost/iterator/iterator_facade.hpp\" rel=\"nofollow noreferrer\"><code>boost::iterator</code></a> claim it needs a proxy object? (Link is code; scroll down to read the comments on <code>struct</code>s <code>writable_postfix_increment_proxy</code> and <code>postfix_increment_result</code>). That is, if you can return a (dereferenceable) copy of the old iterator value, why would you need to wrap this copy in a proxy?</p>\n", "Tags": "<c++><iterator>", "OwnerUserId": "985943", "AnswerCount": "2"}});