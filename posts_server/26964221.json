post_cb({"bq_ids": {"n4140": {"so_26964221_26964314_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}, "so_26964221_26964314_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 599}, "so_26964221_26964314_4": {"length": 14, "quality": 1.0, "section_id": 599}, "so_26964221_26964314_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_26964221_26964314_3": {"length": 20, "quality": 1.0, "section_id": 599}}, "n3337": {"so_26964221_26964314_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}, "so_26964221_26964314_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 589}, "so_26964221_26964314_4": {"length": 14, "quality": 1.0, "section_id": 589}, "so_26964221_26964314_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_26964221_26964314_3": {"length": 20, "quality": 1.0, "section_id": 589}}, "n4659": {"so_26964221_26964314_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}, "so_26964221_26964314_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 622}, "so_26964221_26964314_4": {"length": 14, "quality": 1.0, "section_id": 622}, "so_26964221_26964314_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_26964221_26964314_3": {"length": 20, "quality": 1.0, "section_id": 622}}}, "26964314": {"Id": "26964314", "PostTypeId": "2", "Body": "<p>The standard describes it pretty well; [dcl.init.list]/3:</p>\n<blockquote>\n<p id=\"so_26964221_26964314_0\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>[...]</li>\n<li>Otherwise, if <code>T</code> is a class type, constructors are considered. The\n  applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3, 13.3.1.7). If a narrowing\n  conversion (see below) is required to convert any of the arguments,\n  the program is ill-formed.</li>\n</ul>\n</blockquote>\n<p>[over.match.list] (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26964221_26964314_1\">When objects of non-aggregate class type <code>T</code> are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases:</p>\n<ul>\n<li><p id=\"so_26964221_26964314_2\">Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of\n  the initializer list as a single argument.</p></li>\n<li><p id=\"so_26964221_26964314_3\">If no viable initializer-list constructor is found, <strong>overload resolution is performed again, where the candidate functions are all\n  the constructors of the class <code>T</code> and the argument list consists of the\n  elements of the initializer list.</strong> </p></li>\n</ul>\n<p id=\"so_26964221_26964314_4\">If the initializer list has no\n  elements and T has a default constructor, the first phase is omitted.<br>\n<strong>In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the\n  initialization is ill-formed.</strong> </br></p>\n</blockquote>\n<p>Hence, if no initializer-list constructor is found (as in your case), the elements of the initializer list constitute the arguments for the constructor call. <br>In fact, the <em>only</em> difference of direct-list-initialization and copy-list-initialization is covered by the last, bolded sentence. </br></p>\n<p>This is one of the advantages of list-initialization: It doesn't necessitate the presence of a special member function that is not gonna be used anyway.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-17T02:56:21.487", "Score": "9", "CreationDate": "2014-11-17T01:47:12.157", "ParentId": "26964221", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2014-11-17T02:56:21.487"}, "26964221": {"ViewCount": "291", "Body": "<p>Before C++11, we can do copy initialization by writing something like <code>A a = 1;</code> which is more or less equivalent to <code>A a = A(1);</code>. That is, a temporary is first created and then a copy ctor is invoked. Regardless of copy elision, this must be so conceptually and the copy ctor must be accessible.</p>\n<p>With list initialization in C++11, we can do a copy list initialization by writing <code>A a = {1, 2};</code>. In my opinion, this should be more or less equivalent to <code>A a = A(1, 2);</code>. However, on GCC and clang, <code>A a = {1, 2}</code> compiles even when the copy and move ctor are inaccessible (by declaring as private). Still, <code>A a = 1;</code> does not compile on GCC or clang if the corresponding copy/move ctor is inaccessible. So, <code>A a = {1, 2};</code> seems more or less equivalent to <code>A a{1, 2};</code> which is direct list initialization. The difference between this and the real direct list initialization is that <code>A a = {1, 2};</code> does not compile if the ctor that takes two ints are explicit. In this aspect, <code>A a = {1, 2};</code> resembles copy initialization.</p>\n<p>So, my question is: what is the exact semantics of expressions like <code>A a = {1, 2};</code> conceptually? By <em>conceptually</em>, copy elision do not stay in the way.</p>\n", "AcceptedAnswerId": "26964314", "Title": "Does copy list initialization invoke copy ctor conceptually?", "CreationDate": "2014-11-17T01:35:10.630", "Id": "26964221", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-11-17T02:39:07.077", "LastEditorUserId": "1348273", "LastActivityDate": "2014-11-17T02:56:21.487", "Score": "9", "OwnerUserId": "1348273", "Tags": "<c++><c++11><copy-constructor><list-initialization><copy-initialization>", "AnswerCount": "1"}});