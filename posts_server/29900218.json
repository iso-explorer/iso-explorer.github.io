post_cb({"bq_ids": {"n4140": {"so_29900218_29900558_0": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_29900218_29900558_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 5421}, "so_29900218_29900558_1": {"length": 12, "quality": 0.631578947368421, "section_id": 5421}}, "n3337": {"so_29900218_29900558_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 5216}, "so_29900218_29900558_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 5216}}, "n4659": {"so_29900218_29900558_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_29900218_29900558_2": {"length": 17, "quality": 0.8095238095238095, "section_id": 6843}, "so_29900218_29900558_1": {"length": 12, "quality": 0.631578947368421, "section_id": 6843}}}, "29900558": {"Id": "29900558", "PostTypeId": "2", "Body": "<p><strong>The expression <code>lhs |= 1u &lt;&lt; static_cast&lt;uint8_t&gt;(rhs)</code> can never be a constant expression itself</strong>, because it modifies <code>lhs</code>. The rule that forbids this in C++14 is \u00a75.19/2.15 (an effectively equivalent one exists in C++11 as well):</p>\n<blockquote>\n<p id=\"so_29900218_29900558_0\">A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless\n  the evaluation of <code>e</code>, following the rules of the abstract machine\n  (1.9), would evaluate one of the following expressions:</p>\n<ul>\n<li>modification of an object (5.17, 5.2.6, 5.3.2) <strong>unless it is applied\n  to a non-volatile lvalue of literal type that refers to a non-volatile\n  object whose lifetime began within the evaluation of <code>e</code></strong>;</li>\n</ul>\n</blockquote>\n<p>In C++11, it was required to be one, due to  \u00a77.1.5/5:  </p>\n<blockquote>\n<p id=\"so_29900218_29900558_1\">For a <code>constexpr</code> function, if no function argument values exist such that the function invocation substitution would produce a constant expression (5.19), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>There exists no argument that makes the returned expression a constant expression after invocation substitution: The assignment prevents that. Hence the program is ill-formed in C++11 (but no diagnostic is required), and when compiling with <code>-std=c++11</code>, GCC shows compliant behavior.<br>\nIn C++14 that rule was adjusted:</br></p>\n<blockquote>\n<p id=\"so_29900218_29900558_2\">For a non-template, non-defaulted <code>constexpr</code> function [\u2026], if\n  no argument values exist <strong>such that an invocation of the function [\u2026] could be an evaluated subexpression of a core constant\n  expression (5.19)</strong>, the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>This enables the return expression itself to be a non-constant expression, as long as the function is evaluate-able inside another core constant expression, e.g. from within another <code>constexpr</code> function:</p>\n<pre><code>constexpr auto foo(FooEnum rhs)\n{\n    uint32_t x = 0;\n    x |= rhs;\n    return x;\n}\n</code></pre>\n<p><code>foo(FooEnum::Foo1)</code> is a core constant expression, hence <code>operator|=</code> can be invoked in a core constant expression, hence the function definition is well-formed.</p>\n<p>As noted by @dyp in the comments, GCC only supports the \"relaxing constraints on constexpr functions\"-feature since version 5. <a href=\"http://melpon.org/wandbox/permlink/LPbhMoESpNbEFvTm\" rel=\"nofollow\">GCC 5.1 compiles your code</a>. </p>\n<p>So now the bodies of <code>constexpr</code> functions usually consist of statements that aren't constant expressions themselves. An example following the first, quoted section shows a function <code>incr</code>, which GCC would reject as well: </p>\n<blockquote id=\"so_29900218_29900558_3\">\n<pre><code>constexpr int incr(int &amp;n) {\n    return ++n;\n}\n\nconstexpr int h(int k) {\n    int x = incr(k); // OK: incr(k) is not required to be a core\n                     // constant expression\n    return x;\n}\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-04-27T19:21:01.970", "Score": "8", "CreationDate": "2015-04-27T15:58:59.017", "ParentId": "29900218", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2015-04-27T19:21:01.970"}, "29900218": {"ViewCount": "636", "Body": "<p>I have the following code:</p>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;type_traits&gt;\n\nenum class FooEnum : uint8_t{\n    Foo1 = 0, \n    Foo2 = 1\n};\n\nconstexpr uint32_t&amp; operator|= (uint32_t&amp; lhs, FooEnum rhs) {\n    return lhs |= 1u &lt;&lt; static_cast&lt;uint8_t&gt;(rhs);\n}\n\nint main() {\n    uint32_t bar{0};\n    bar|=FooEnum::Foo1;\n}\n</code></pre>\n<p>So essentially, the <code>|=</code> operator is supposed to take an enum and set the bit, whose position corresponds to its integral value.</p>\n<p>When compiled with clang++ 3.5.0 on fedora 21, everything works fine, but when compiled with g++ 4.9.2, it throws an <strong>error</strong> saying that this is not a <em>constant-expression</em>:</p>\n<pre><code>main.cpp: In function \u2018constexpr uint32_t&amp; operator|=(uint32_t&amp;, FooEnum)\u2019:\nmain.cpp:16:2: error: expression \u2018(lhs = (lhs | (1u &lt;&lt; ((int)rhs))))\u2019 is not a constant-expression\n  }\n  ^\n</code></pre>\n<p>This is true for all kinds of compiler flag combinations, but you can e.g. test it with <code>g++ -std=c++11 -o a.out main.cpp</code> (c++14 doesn't make a difference)</p>\n<p><strong>So my questions are:</strong> </p>\n<ol>\n<li>Which of the compilers is right (and why)?</li>\n<li>Is there a way to implement the <code>operator|=</code> such that g++ will accept it as a <code>constexpr</code>?</li>\n</ol>\n<p>EDIT:<br>\nIn case you are wondering, why I tried to declare the operator as <code>constexpr</code> in the first place although this isn't required in the example:<br>\nIn my actual code, I'm using the <code>|=</code>-operator in order to implement the (constexpr) <code>|</code>-operator, which I wanted to be usable in a constexpr expression, but before that, I stumbled over the difference between the two compilers, not realizing, that gcc4.9 doesn't fully support c++14 (yet accepting the <code>-std=c++14</code> flag).<br>\nWhen using the operator to actually initialize a global constexpr variable, even clang only compiles it with c++14 flag.</br></br></br></p>\n", "AcceptedAnswerId": "29900558", "Title": "Constexpr compound assignment operator in clang and gcc", "CreationDate": "2015-04-27T15:42:52.330", "Id": "29900218", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-20T10:40:48.337", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-20T10:40:48.337", "Score": "7", "OwnerUserId": "2881849", "Tags": "<c++><c++11><language-lawyer><c++14><constexpr>", "AnswerCount": "1"}});