post_cb({"43826145": {"ParentId": "43824729", "CommentCount": "10", "Body": "<p>See the discussion in <a href=\"https://wg21.link/cwg787\" rel=\"noreferrer\">core issue 787</a>:</p>\n<blockquote>\n<p id=\"so_43824729_43826145_0\">The undefined behavior referred to above regarding\n  <em>universal-character-name</em>s is the result of the considerations\n  described in the C99 Rationale, section 5.2.1, in the part entitled\n  \u201cUCN models.\u201d Three different models for support of UCNs are\n  described, each involving different conversions between UCNs and wide\n  characters and/or at different times during program translation.\n  Implementations, as well as the specification in a language standard,\n  can employ any of the three, but it must be impossible for a\n  well-defined program to determine which model was actually employed by\n  implementation. The implication of this \u201cequivalence principle\u201d is\n  that any construct that would give different results under the\n  different models must be classified as undefined behavior. For\n  example, an apparent UCN resulting from a line-splice would be\n  recognized as a UCN by an implementation in which all wide characters\n  were translated immediately into UCNs, as described in C++ phase 1,\n  but would not be recognized as a UCN by another implementation in\n  which all UCNs were translated immediately into wide characters (a\n  possibility mentioned parenthetically in C++ phase 1).</p>\n</blockquote>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "43826145", "Score": "7", "CreationDate": "2017-05-06T22:59:46.533", "LastActivityDate": "2017-05-06T22:59:46.533"}, "bq_ids": {"n4140": {"so_43824729_43824729_0": {"section_id": 5313, "quality": 1.0, "length": 15}}, "n3337": {"so_43824729_43824729_0": {"section_id": 5110, "quality": 0.8, "length": 12}}, "n4659": {"so_43824729_43824729_0": {"section_id": 6737, "quality": 1.0, "length": 15}}}, "43824729": {"CommentCount": "0", "ViewCount": "383", "PostTypeId": "1", "LastEditorUserId": "5479741", "CreationDate": "2017-05-06T19:47:51.003", "LastActivityDate": "2017-05-06T22:59:46.533", "Title": "This code, why does it have to show undefined behavior?", "FavoriteCount": "2", "LastEditDate": "2017-05-06T21:32:16.723", "Id": "43824729", "Score": "7", "Body": "<p>According to this sentence in <a href=\"http://eel.is/c++draft/lex.phases#1.2\" rel=\"nofollow noreferrer\">[lex.phases]1.2</a></p>\n<blockquote>\n<p id=\"so_43824729_43824729_0\">Except for splices reverted in a raw string literal, if a splice\n  results in a character sequence that matches the syntax of a\n  universal-character-name, the behavior is undefined.</p>\n</blockquote>\n<p>the snippet below has undefined behavior (<a href=\"http://coliru.stacked-crooked.com/a/d02251c2e8657699\" rel=\"nofollow noreferrer\">live-example</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n\n// According to [lex.phases]1.2 this has undefined behavior\n\nconst char* p = \"\\\\\nu0041\";\n\nint main()\n{\n    std::cout &lt;&lt; p &lt;&lt; '\\n';\n}\n</code></pre>\n<p>What's the reason for the undefined behavior?</p>\n", "Tags": "<c++><c++14><language-lawyer><undefined-behavior>", "OwnerUserId": "5479741", "AnswerCount": "1"}});