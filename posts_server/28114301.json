post_cb({"28114301": {"ViewCount": "560", "Body": "<p>I know it's perfectly possible to initialise a <code>char</code> array with a string literal:</p>\n<pre><code>char arr[] = \"foo\";\n</code></pre>\n<p>C++11 8.5.2/1 says so:</p>\n<blockquote>\n<p id=\"so_28114301_28114301_0\">A <code>char</code> array (whether plain <code>char</code>, <code>signed char</code>, or <code>unsigned char</code>), <code>char16_t</code> array, <code>char32_t</code> array, or\n  <code>wchar_t</code> array can be initialized by a narrow character literal, <code>char16_t</code> string literal, <code>char32_t</code> string\n  literal, or wide string literal, respectively, or by an appropriately-typed string literal enclosed in braces.\n  Successive characters of the value of the string literal initialize the elements of the array. ...</p>\n</blockquote>\n<p>However, can you do the same with <em>two</em> string literals in a conditional expression? For example like this:</p>\n<pre><code>char arr[] = MY_BOOLEAN_MACRO() ? \"foo\" : \"bar\";\n</code></pre>\n<p>(Where <code>MY_BOOLEAN_MACRO()</code> expands to a <code>1</code> or <code>0</code>).</p>\n<p>The relevant parts of C++11 5.16 (Conditional operator) are as follows:</p>\n<blockquote>\n<p id=\"so_28114301_28114301_1\">1 ... The first expression is contextually converted to <code>bool</code> (Clause 4).\n  It is evaluated and if it is <code>true</code>, the result of the conditional expression is the value of the second expression,\n  otherwise that of the third expression. ...</p>\n<p id=\"so_28114301_28114301_2\">4 If the second and third operands are glvalues of the same value category and have the same type, the result\n  is of that type and value category and it is a bit-field if the second or the third operand is a bit-field, or if\n  both are bit-fields.</p>\n</blockquote>\n<p>Notice that the literals are of the same length and thus they're both lvalues of type <code>const char[4]</code>.</p>\n<p><a href=\"http://ideone.com/eih2Jm\">GCC one ideone</a> accepts the construct. But from reading the standard, I am simply not sure whether it's legal or not. Does anyone have better insight?</p>\n", "AcceptedAnswerId": "28117559", "Title": "Is it possible to initialise a character array with a conditionally selected string literal?", "CreationDate": "2015-01-23T16:26:26.210", "Id": "28114301", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-01-30T15:09:06.043", "Score": "14", "OwnerUserId": "1782465", "Tags": "<c++><language-lawyer><string-literals>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28114301_28114301_0": {"length": 34, "quality": 0.7906976744186046, "section_id": 3314}, "so_28114301_28114301_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6167}, "so_28114301_28117559_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5349}, "so_28114301_28114301_2": {"length": 21, "quality": 1.0, "section_id": 6170}, "so_28114301_28117559_3": {"length": 19, "quality": 0.95, "section_id": 5776}}, "n3337": {"so_28114301_28114301_0": {"length": 43, "quality": 1.0, "section_id": 3184}, "so_28114301_28114301_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5928}, "so_28114301_28117559_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5146}, "so_28114301_28114301_2": {"length": 21, "quality": 1.0, "section_id": 5931}, "so_28114301_28117559_3": {"length": 19, "quality": 0.95, "section_id": 5549}}, "n4659": {"so_28114301_28114301_0": {"length": 34, "quality": 0.7906976744186046, "section_id": 4080}, "so_28114301_28114301_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7664}, "so_28114301_28117559_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6774}, "so_28114301_28114301_2": {"length": 21, "quality": 1.0, "section_id": 7668}, "so_28114301_28117559_3": {"length": 19, "quality": 0.95, "section_id": 7233}}}, "28117682": {"Id": "28117682", "PostTypeId": "2", "Body": "<p>This works in GCC <em>in C++11 or newer</em> because the literals you're providing are deterministic during compile time (eg, they are <code>constexpr</code>). Since the compiler can figure out which one is true, it is allowed to figure out which one to use.</p>\n<p>To remove the <code>constexpr</code> ability, try something like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nint main() {\n    bool _bool = rand();\n    char arr[] = (_bool) ? \"asdf\" : \"ffff\";\n\n    std::cout &lt;&lt; arr &lt;&lt; std::endl;\n}\n</code></pre>\n<p>GCC then errors out with:</p>\n<pre><code>g++ test.cpp -std=c++11\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:6:34: error: initializer fails to determine size of \u2018arr\u2019\n  char arr[] = (_bool) ? \"asdf\" : \"ffff\";\n                                  ^\ntest.cpp:6:34: error: array must be initialized with a brace-enclosed initializer\n</code></pre>\n<p>I don't know the standard's text definition well enough to know where or why this is valid, but I <em>feel</em> that it <em>is</em> valid.</p>\n<p>For further reading on <code>constexpr</code> and how it can impact compilability, see <a href=\"https://stackoverflow.com/a/26025026/1708801\">the answer by @ShafikYaghmour in another question</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-23T20:40:24.770", "Score": "3", "CreationDate": "2015-01-23T19:53:30.980", "ParentId": "28114301", "CommentCount": "3", "OwnerUserId": "1111557", "LastEditDate": "2017-05-23T10:27:15.057"}, "28117559": {"Id": "28117559", "PostTypeId": "2", "Body": "<p>On the other hand <code>clang</code> does not accept such code (<em><a href=\"http://melpon.org/wandbox/permlink/jTTGMnBzfy1t9mFV\" rel=\"nofollow\">see it live</a></em>) and I believe <code>clang</code> is correct on this (<em><a href=\"http://rextester.com/NQECUL1379\" rel=\"nofollow\">MSVC also rejects this code </a></em>). </p>\n<p>A <em>string literal</em> is defined by the grammar in section <code>2.14.5</code>:</p>\n<pre><code>string-literal:\n    encoding-prefixopt\" s-char-sequenceopt\"\n    encoding-prefixoptR raw-string\n</code></pre>\n<p>and the first paragraph from this section says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_28114301_28117559_0\">A string literal <strong>is a sequence of characters</strong> (as defined in 2.14.3)\n  <strong>surrounded by double quotes</strong>, optionally prefixed by R, u8, u8R, u, uR,\n  U, UR, L, or LR, as in \"...\", R\"(...)\", u8\"...\", u8R\"<strong>(...)</strong>\",\n  u\"...\", uR\"<em>\u02dc(...)</em>\u02dc\", U\"...\", UR\"zzz(...)zzz\", L\"...\", or LR\"(...)\",\n  respectively</p>\n</blockquote>\n<p>and it further says that the type of a narrow string literal is:</p>\n<blockquote>\n<p id=\"so_28114301_28117559_1\">\u201carray of n const char\u201d,</p>\n</blockquote>\n<p>as well as:</p>\n<blockquote>\n<p id=\"so_28114301_28117559_2\">has static storage duration</p>\n</blockquote>\n<p>but an <em>\u201carray of n const char\u201d,</em> with static storage duration is not a <em>string literal</em> since it does not fit the grammar nor does it fit paragraph <code>1</code>.</p>\n<p>We can make this fail on <code>gcc</code> if we use a non-constant expression (<em><a href=\"http://melpon.org/wandbox/permlink/gEV3ImIU5KBYa5ee\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>bool x = true ;\nchar arr[] = x ? \"foo\" : \"bar\";\n</code></pre>\n<p>which means it is probably an extension, but it is non-conforming since it does not produce a warning in <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Standards.html\" rel=\"nofollow\">strict conformance mode</a> i.e. using <code>-std=c++11 -pedantic</code>. From section <code>1.4</code> <em>[intro.compliance]</em>:</p>\n<blockquote>\n<p id=\"so_28114301_28117559_3\">[...]Implementations are required to diagnose programs that use such\n  extensions that are ill-formed according to this International\n  Standard. Having done so, however, they can compile and execute such\n  programs.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-01-30T15:09:06.043", "Score": "10", "CreationDate": "2015-01-23T19:45:03.160", "ParentId": "28114301", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2015-01-30T15:09:06.043"}});