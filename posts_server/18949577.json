post_cb({"18949891": {"Id": "18949891", "PostTypeId": "2", "Body": "<p>Yes, you're right. The <code>&amp;</code> operator is applying to the member, not the local object.</p>\n<p>Demonstration is straightforward: just modify your example to output the addresses.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int i;\n    std::cout &lt;&lt; &amp; i &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; [=]() mutable -&gt; int * {\n        return &amp; i;\n    } () &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"http://ideone.com/OqsDyg\">http://ideone.com/OqsDyg</a></p>\n<p>Incidentally, this compiles with no warnings under <code>-Wall</code> in GCC 4.9.</p>\n", "LastActivityDate": "2013-09-22T23:42:29.860", "CommentCount": "3", "CreationDate": "2013-09-22T23:42:29.860", "ParentId": "18949577", "Score": "7", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_18949577_18950081_2": {"length": 19, "quality": 0.8260869565217391, "section_id": 5974}, "so_18949577_18950081_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5962}, "so_18949577_18950081_1": {"length": 11, "quality": 0.55, "section_id": 5971}, "so_18949577_18950081_3": {"length": 15, "quality": 1.0, "section_id": 5977}}, "n3337": {"so_18949577_18950081_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5742}, "so_18949577_18950081_3": {"length": 15, "quality": 1.0, "section_id": 5745}, "so_18949577_18950081_1": {"length": 19, "quality": 0.95, "section_id": 5739}, "so_18949577_18950081_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5731}}, "n4659": {"so_18949577_18950081_2": {"length": 19, "quality": 0.8260869565217391, "section_id": 7473}, "so_18949577_18950081_3": {"length": 15, "quality": 1.0, "section_id": 7474}, "so_18949577_18950081_1": {"length": 11, "quality": 0.55, "section_id": 7470}, "so_18949577_18950081_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7451}}}, "18950081": {"Id": "18950081", "PostTypeId": "2", "Body": "<p>Some terminology:</p>\n<ul>\n<li>The <code>=</code> or <code>&amp;</code> inside <code>[&amp;](){ /*..*/ }</code> is called a <em>capture-default</em>.</li>\n<li>odr-use of a variable roughly means that the variable does not appear in a discarded-value-expression (such as <code>(void)some_variable</code> or <code>int x = some_variable, 5;</code>) and it doesn't occur in a constant expression.</li>\n<li><em>compound-statement</em> is the \"function block\" <code>{</code> <em>statements</em> <code>}</code></li>\n<li>the name of a variable is an <em>id-expression</em></li>\n</ul>\n<p>[expr.prim.lambda]/3</p>\n<blockquote>\n<p id=\"so_18949577_18950081_0\">The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a unique, unnamed non-union class type \u2014 called the <em>closure type</em> \u2014 whose properties are described below.</p>\n</blockquote>\n<p>/11</p>\n<blockquote>\n<p id=\"so_18949577_18950081_1\">If a <em>lambda-expression</em> has an associated <em>capture-default</em> and its <em>compound-statement</em> odr-uses (3.2) <code>this</code> or a variable with automatic storage duration and the odr-used entity is not explicitly captured, then the odr-used entity is said to be <em>implicitly captured</em>;</p>\n</blockquote>\n<p>Therefore, <code>i</code> is implicitly captured.</p>\n<p>/14</p>\n<blockquote>\n<p id=\"so_18949577_18950081_2\">An entity is captured by copy if it is implicitly captured and the capture-default is <code>=</code> or if it is explicitly captured with a capture that does not include an <code>&amp;</code>. For each entity captured by copy, an unnamed non-static data member is declared in the closure type.</p>\n</blockquote>\n<p>There is a non-static data member (of type <code>int</code>) in the closure type.</p>\n<p>/17</p>\n<blockquote>\n<p id=\"so_18949577_18950081_3\">Every <em>id-expression</em> that is an odr-use (3.2) of an entity captured by copy is transformed into an access to the corresponding unnamed data member of the closure type.</p>\n</blockquote>\n<p>We don't even need to interpret this, as this paragraph provides us with an example very similar to the OP's:</p>\n<pre><code>void f(const int*);\nvoid g() {\n    const int N = 10;\n    [=] {\n        int arr[N]; // OK: not an odr-use, refers to automatic variable\n        f(&amp;N);      // OK: causes N to be captured; &amp;N points to the\n                    // corresponding member of the closure type\n    };\n}\n</code></pre>\n<p>If we apply this to the OP's example, we see that <code>&amp;i</code> refers to the <em>internal</em> non-static data member of the closure type. Whether or not the diagnostic message is appropriate is not specified in the Standard ;)</p>\n", "LastEditorUserId": "420683", "LastActivityDate": "2013-09-23T00:27:27.747", "Score": "4", "CreationDate": "2013-09-23T00:12:39.633", "ParentId": "18949577", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2013-09-23T00:27:27.747"}, "18949577": {"ViewCount": "427", "Body": "<p>Given the following sample code:</p>\n<pre><code>int main()\n{\n    int i;\n    auto f = [=]()mutable-&gt;int*\n    {\n            return &amp;i;\n    };\n\n    return 0;\n}\n</code></pre>\n<ol>\n<li>g++ v.4.8.1 warns that \"address of local variable \u2018i\u2019 returned\".</li>\n<li>Clang v.3.2 (MacOS's Clang) warns that \"address of stack memory\nassociated with local variable 'i' returned\".</li>\n<li>Neither VS2012 nor VS2013 RC warn of anything.</li>\n</ol>\n<p>My understanding of lambdas is that the compiler will generate a functor class. That functor class will have members for all copied variables (<code>i</code> in the example). I believe that in the context of my code, as long as <code>f</code> exists, it is safe to return the address of one of its members. It seems to me that all compilers got it wrong. I think a warning about using the address of <code>f</code>'s member <code>i</code> after <code>f</code> goes out of scope is valid, but the warnings about the \"local variable 'i'\" are incorrect/misleading. Am I right?</p>\n", "AcceptedAnswerId": "18949891", "Title": "Can a lambda safely return the address of a copied variable?", "CreationDate": "2013-09-22T22:50:29.683", "Id": "18949577", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-09-22T23:03:36.537", "LastEditorUserId": "85371", "LastActivityDate": "2013-09-23T00:27:27.747", "Score": "16", "OwnerUserId": "1300177", "Tags": "<c++><c++11><lambda>", "AnswerCount": "2"}});