post_cb({"11219159": {"ViewCount": "824", "Body": "<p><strong>UPDATE</strong>: I do appreciate \"don't want that, want this instead\" suggestions.  They are useful, especially when provided in context of the <a href=\"https://stackoverflow.com/questions/11167483/deriving-from-a-base-class-whose-instances-reside-in-a-fixed-format-database-m\">motivating scenario</a>.  Still...regardless of goodness/badness, I've become curious to find a hard-and-fast <em>\"yes that can be done legally in C++11\"</em> vs <em>\"no it is not possible to do something like that\"</em>.</p>\n<hr>\n<p>I want to \"alias\" an object pointer as another type, for the <em>sole purpose</em> of adding some helper methods.  The alias cannot add data members to the underlying class (in fact, the more I can prevent that from happening the better!)  All aliases are equally applicable to any object of this type...it's just helpful if the type system can hint which alias is likely the most appropriate.</p>\n<p>There should be no information about any specific alias that is ever encoded in the underlying object.  Hence, I feel like you should be able to \"cheat\" the type system and just let it be an annotation...checked at compile time, but ultimately irrelevant to the runtime casting.  Something along these lines:</p>\n<pre><code>Node&lt;AccessorFoo&gt;* fooPtr = Node&lt;AccessorFoo&gt;::createViaFactory();\nNode&lt;AccessorBar&gt;* barPtr = reinterpret_cast&lt; Node&lt;AccessorBar&gt;* &gt;(fooPtr);\n</code></pre>\n<p>Under the hood, the factory method is actually making a <code>NodeBase</code> class, and then using a similar <code>reinterpret_cast</code> to return it as a <code>Node&lt;AccessorFoo&gt;*</code>.  </p>\n<p>The easy way to avoid this is to make these lightweight classes that wrap nodes and are passed around by value.  Thus you don't need casting, just Accessor classes that take the node handle to wrap in their constructor:</p>\n<pre><code>AccessorFoo foo (NodeBase::createViaFactory());\nAccessorBar bar (foo.getNode());\n</code></pre>\n<p>But if I don't have to pay for all that, I don't want to.  That would involve--for instance--making a special accessor type for each sort of wrapped pointer (AccessorFooShared, AccessorFooUnique, AccessorFooWeak, etc.)  Having these typed pointers being aliased for one single pointer-based object identity is preferable, and provides a nice orthogonality.</p>\n<p>So back to that original question:</p>\n<pre><code>Node&lt;AccessorFoo&gt;* fooPtr = Node&lt;AccessorFoo&gt;::createViaFactory();\nNode&lt;AccessorBar&gt;* barPtr = reinterpret_cast&lt; Node&lt;AccessorBar&gt;* &gt;(fooPtr);\n</code></pre>\n<p>Seems like there would be some way to do this that might be ugly but not \"break the rules\".  According to <a href=\"https://stackoverflow.com/a/9018959/211160\">ISO14882:2011(e) 5.2.10-7</a>:</p>\n<blockquote>\n<p id=\"so_11219159_11219159_0\">An object pointer can be explicitly converted to an object pointer of a different type.70 When a prvalue v of type \"pointer to T1\" is converted to the type \"pointer to cv T2\", the result is static_cast(static_cast(v)) if both T1 and T2 are standard-layout types (3.9) and the alignment requirements of T2 are no stricter than those of T1, or if either type is void. Converting a prvalue of type \"pointer to T1\" to the type \"pointer to T2\" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>Drilling into the definition of a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm\" rel=\"nofollow noreferrer\">\"standard-layout class\"</a>, we find:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout-class (or array of such types) or reference, and</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>has the same access control (clause 11) for all non-static data members, and</li>\n<li>has no non-standard-layout base classes, and</li>\n<li>either has no non-static data member in the most-derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member. </li>\n</ul>\n<p>Sounds like working with something like this would tie my hands a bit with no virtual methods in the accessors or the node.  Yet C++11 apparently has <code>std::is_standard_layout</code> to keep things checked.</p>\n<p>Can this be done safely?  Appears to work in gcc-4.7, but I'd like to be sure I'm not invoking undefined behavior.</p>\n</hr>", "AcceptedAnswerId": "11220705", "Title": "Make interchangeable class types via pointer casting only, without having to allocate any new objects?", "CreationDate": "2012-06-27T03:51:00.407", "Id": "11219159", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:24:05.777", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-09T00:29:19.533", "Score": "4", "OwnerUserId": "211160", "Tags": "<c++><c++11><language-lawyer><reinterpret-cast><type-punning>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_11219159_11219159_0": {"length": 38, "quality": 0.6440677966101694, "section_id": 6046}}, "n3337": {"so_11219159_11219159_0": {"length": 56, "quality": 0.9491525423728814, "section_id": 5814}}, "n4659": {"so_11219159_11219159_0": {"length": 38, "quality": 0.6440677966101694, "section_id": 7545}}}, "11378177": {"Id": "11378177", "PostTypeId": "2", "Body": "<pre><code>struct myPOD {\n   int data1;\n   // ...\n};\n\nstruct myPOD_extended1 : myPOD {\n   int helper() { (*(myPOD*)this)-&gt;data1 = 6; };  // type myPOD referenced here\n};\nstruct myPOD_extended2 : myPOD { \n   int helper() { data1 = 7; };                   // no syntactic ref to myPOD\n};\nstruct myPOD_extended3 : myPOD {\n   int helper() { (*(myPOD*)this)-&gt;data1 = 8; };  // type myPOD referenced here\n};\nvoid doit(myPOD *it)\n{\n    ((myPOD_extended1*)it)-&gt;helper();\n    // ((myPOD_extended2*)it)-&gt;helper(); // uncomment -&gt; program/compile undefined\n    ((myPOD_extended3*)it)-&gt;helper();\n}\n\nint main(int,char**)\n{\n    myPOD a; a.data1=5; \n    doit(&amp;a);\n\n    std::cout&lt;&lt; a.data1 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>\n<p>I believe this is guaranteed to work in all conforming C++ compilers and must print 8. Uncomment the marked line and all bets are off.  </p>\n<p>An optimizer might prune searches for valid aliased references by checking the list of syntactic types actually referenced in a function against the list (in 3.10p10) of syntactic types of references it's required to produce correct results for -- and when an actual (\"dynamic\") object type is known, that list doesn't include access through a reference to any derived type. So the explicit (and valid) downcasts of <code>this</code> to <code>myPOD*</code> in the <code>helper()</code>s puts <code>myPOD</code> on the list of types syntactically referenced there, and the optimizer has to treat the resulting references as potential legal references to (other names for, aliases of) the object <code>a</code>.</p>\n", "LastEditorUserId": "1290731", "LastActivityDate": "2012-07-09T00:29:19.533", "Score": "2", "CreationDate": "2012-07-07T19:54:02.883", "ParentId": "11219159", "CommentCount": "9", "LastEditDate": "2012-07-09T00:29:19.533", "OwnerUserId": "1290731"}, "11220705": {"Id": "11220705", "PostTypeId": "2", "Body": "<p>The term <em>Accessor</em> is a dead giveaway: what you are looking for is a <a href=\"http://www.vincehuston.org/dp/proxy.html\" rel=\"nofollow\"><em>Proxy</em></a>.</p>\n<p>There is no reason for a Proxy not to be passed around by value.</p>\n<pre><code>// Let us imagine that NodeBase is now called Node, since there is no inheritance\n\nclass AccessorFoo {\npublic:\n    AccessorFoo(Node&amp; n): node(n) {}\n\n    int bar() const { return node-&gt;bar; }\n\nprivate:\n    std::reference_wrapper&lt;Node&gt; node;\n};\n</code></pre>\n<p>And then you can freely convert from one accessor to another... though <em>this smells</em>. Normally the very goal of having an accessor is to restrict access in a way, so casting nilly willy to another accessor is <em>bad</em>. However one could support casting to a <strong>narrower</strong> accessor.</p>\n", "LastActivityDate": "2012-06-27T06:40:21.360", "CommentCount": "14", "CreationDate": "2012-06-27T06:40:21.360", "ParentId": "11219159", "Score": "4", "OwnerUserId": "147192"}, "11302435": {"Id": "11302435", "PostTypeId": "2", "Body": "<p>I believe the strict aliasing rules forbid what you are trying to do.</p>\n<p>To clarify: strict aliasing has nothing to do with layout compatibility, POD types or what not. It has to do with optimization. And with what the language explicitly forbids you to do. </p>\n<p>This paper sums it up rather well: <a href=\"http://dbp-consulting.com/StrictAliasing.pdf\" rel=\"nofollow\">http://dbp-consulting.com/StrictAliasing.pdf</a></p>\n", "LastEditorUserId": "454519", "LastActivityDate": "2012-07-03T12:37:37.893", "Score": "4", "CreationDate": "2012-07-02T23:15:32.717", "ParentId": "11219159", "CommentCount": "6", "LastEditDate": "2012-07-03T12:37:37.893", "OwnerUserId": "454519"}, "11219645": {"Id": "11219645", "PostTypeId": "2", "Body": "<p>If I understand you correctly, you have:</p>\n<ul>\n<li>A <code>NodeBase</code> class that is stateful, and the true workhorse of the system;</li>\n<li>a set of stateless <code>Accessor</code> types that provide an interface to <code>NodeBase</code>; and</li>\n<li>a <code>Node&lt;AccessorT&gt;</code> class which wraps an accessor, presumably providing convenience functions.</li>\n</ul>\n<p>I assume the last bit because if you don't have a wrapper type that does convenience stuff, then there's no reason not to make the <code>Accessor</code> types your top-level, like you suggested: pass <code>AccessorFoo</code> and <code>AccessorBar</code> around by value. The fact that they aren't the same object is entirely moot; if you think of them like the pointers that they are, then you'll note that <code>&amp;foo != &amp;bar</code> is no more interesting than having <code>NodeBase* p1 = new NodeBase; NodeBase* p2 = p1;</code> and noting that, of course, <code>&amp;p1 != &amp;p2</code>.</p>\n<p>If you really do need a wrapper <code>Node&lt;AccessorT&gt;</code> and want to make it standard-layout, then I would suggest that you use the statelessness of your <code>Accessor</code> types to your advantage. If they are simply a stateless container of functionality (which they must be; why else would you be able to freely cast them?), then you can do something like this:</p>\n<pre><code>struct AccessorFoo {\n    int getValue(NodeBase* n) { return n-&gt;getValueFoo(); }\n};\n\nstruct AccessorBar {\n    int getValue(NodeBase* n) { return n-&gt;getValueBar(); }\n};\n\ntemplate &lt;typename AccessorT&gt;\nclass Node {\n    NodeBase* m_node;\n\npublic:\n    int getValue() {\n        AccessorT accessor;\n        return accessor.getValue(m_node);\n    }\n};\n</code></pre>\n<p>In this case, you could add a templated conversion operator:</p>\n<pre><code>template &lt;typename OtherT&gt;\noperator Node&lt;OtherT&gt;() {\n    return Node&lt;OtherT&gt;(m_node);\n}\n</code></pre>\n<p>And now you've got direct value conversion between any <code>Node&lt;AccessorT&gt;</code> type you like.</p>\n<p>If you take it just a bit further, you'll make all the methods of the <code>Accessor</code> types static, and arrive at the <a href=\"http://www.cantrip.org/traits.html\" rel=\"nofollow\">traits pattern</a>.</p>\n<hr>\n<p>The section of the C++ standard that you quoted, incidentally, concerns the behavior of <code>reinterpret_cast&lt;T*&gt;(p)</code> in the case that both the source type and the final type are pointers to standard-layout objects, in which case the standard guarantees that you get the same pointer you'd get from casting to a <code>void*</code> and then to the final type. You still don't get to use the object as any type other than the type it was created as without invoking undefined behavior.</p>\n</hr>", "LastEditorUserId": "5696", "LastActivityDate": "2012-06-27T05:56:51.567", "Score": "4", "CreationDate": "2012-06-27T04:56:36.500", "ParentId": "11219159", "CommentCount": "5", "LastEditDate": "2012-06-27T05:56:51.567", "OwnerUserId": "5696"}});