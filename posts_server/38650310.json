post_cb({"38650310": {"CommentCount": "4", "ViewCount": "107", "PostTypeId": "1", "LastEditorUserId": "3677630", "CreationDate": "2016-07-29T04:00:52.353", "LastActivityDate": "2016-08-01T14:52:07.667", "Title": "The issues of member object alignment of a class with virtual function and dynamically allocated", "AcceptedAnswerId": "38701636", "LastEditDate": "2016-07-29T07:12:32.193", "Id": "38650310", "Score": "1", "Body": "<p>Please read the following code.\n</p>\n<pre><code>struct alignas(32) A\n{\n  int a;\n};\nstruct B\n{\n  A a;\n  virtual void foo(){ cout &lt;&lt; 'B'; }\n};\n\nstruct C : public B\n{\n  virtual void foo(){ cout &lt;&lt; 'C'; }\n};\n\nint main()\n{\n  A aa;\n  C c;  \n  C *pc = new C;\n}\n</code></pre>\n<p>\"A\" is a structure that is 32-byte aligned, so the variable \"aa\" in \"main\" function is 32-byte aligned. However, struct \"C\" is a class with virtual function, so the member object \"a\" is not at the beginning of the class. </p>\n<p>My first question is whether variable \"c\" in \"main\" function is 32-byte aligned or its member object \"a\" is aligned?</p>\n<p>The second question is about variable \"pc\" in \"main\" function. I know that the address of \"pc\" may not be aligned. So is there a way that can guarantee member \"a\" will be aligned in any case?</p>\n", "Tags": "<c++><polymorphism><alignment>", "OwnerUserId": "3677630", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38650310_38701636_4": {"section_id": 4239, "quality": 0.5714285714285714, "length": 4}, "so_38650310_38701636_0": {"section_id": 7240, "quality": 0.8461538461538461, "length": 11}, "so_38650310_38701636_2": {"section_id": 7244, "quality": 0.8333333333333334, "length": 20}, "so_38650310_38701636_1": {"section_id": 5873, "quality": 0.9565217391304348, "length": 22}, "so_38650310_38701636_3": {"section_id": 7242, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_38650310_38701636_4": {"section_id": 4080, "quality": 0.5714285714285714, "length": 4}, "so_38650310_38701636_0": {"section_id": 6984, "quality": 0.8461538461538461, "length": 11}, "so_38650310_38701636_2": {"section_id": 6988, "quality": 0.8333333333333334, "length": 20}, "so_38650310_38701636_1": {"section_id": 5644, "quality": 0.9565217391304348, "length": 22}, "so_38650310_38701636_3": {"section_id": 6986, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_38650310_38701636_4": {"section_id": 5177, "quality": 0.5714285714285714, "length": 4}, "so_38650310_38701636_0": {"section_id": 8749, "quality": 0.7692307692307693, "length": 10}, "so_38650310_38701636_2": {"section_id": 8753, "quality": 0.8333333333333334, "length": 20}, "so_38650310_38701636_1": {"section_id": 7356, "quality": 0.9565217391304348, "length": 22}, "so_38650310_38701636_3": {"section_id": 8751, "quality": 0.8695652173913043, "length": 20}}}, "38701636": {"ParentId": "38650310", "PostTypeId": "2", "CommentCount": "2", "Body": "<h2>General principle</h2>\n<p>According to the standard:  </p>\n<blockquote>\n<p id=\"so_38650310_38701636_0\"><strong>3.11/1:</strong> Object types have alignment requirements which place restrictions on\n  the addresses at which an object of that type may be allocated.</p>\n</blockquote>\n<p>These requirements have implications for classes:  </p>\n<blockquote>\n<p id=\"so_38650310_38701636_1\"><strong>9.2/13:</strong> Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so\n  might requirements for <strong><em>space for managing virtual functions and\n  virtual base classes</em></strong>. </p>\n</blockquote>\n<p>So the compiler may use padding between class members to comply with alignment requirements. This can work only if compiler can make some assumptions on the address of the whole object.  In other words, the alignment requirements of members (e.g.<code>A a</code>) have impact on the alignment requirement of its containing class (e.g. <code>struct B</code>). The same applies for inheritance (e.g. <code>struct C: public B</code>) because the inheritance implies the existance of a subobject (e.g. of type <code>B</code> inside the object of type <code>C</code>). </p>\n<p>As far as I know, nowhere in the standard it is written how the compiler has to do to achieve the requirements, but it is reminded that:  </p>\n<blockquote>\n<p id=\"so_38650310_38701636_2\"><strong>3.11/5:</strong> Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values.\n  An address that satisfies an alignment requirement also satisfies any\n  weaker valid alignment requirement. </p>\n</blockquote>\n<p>So it's highly probable that the alignment requirement of a class will be largest alignment requirement of its base classes and all its members.  </p>\n<h2>Your specific example</h2>\n<p>First you can check the effect of the polymorphism and the virtual functions:  </p>\n<pre><code>struct Simple {\n    char x; \n}; \nstruct SimpleVirtual {\n    char x;\n    virtual ~SimpleVirtual() {}\n}; \n...\ncout&lt;&lt;\"Simple         :\"&lt;&lt;alignof(Simple)&lt;&lt;endl; \ncout&lt;&lt;\"SimpleVirtual  :\"&lt;&lt;alignof(SimpleVirtual)&lt;&lt;endl; \n</code></pre>\n<p>You'll see that the XXL alignment requirement of A is much larger than the alignment requirements that come from the virtual functions (e.g. commonly implemented with vtable pointer):   </p>\n<pre><code> cout&lt;&lt;\"A : \"&lt;&lt;alignof(A)&lt;&lt;endl; \n cout&lt;&lt;\"B : \"&lt;&lt;alignof(B)&lt;&lt;endl; \n cout&lt;&lt;\"C : \"&lt;&lt;alignof(C)&lt;&lt;endl; \n</code></pre>\n<p>In your specific example, the 32 byte alignment, is transferred to all the 3 classes.  </p>\n<p>Here an <a href=\"https://ideone.com/nHeBMJ\" rel=\"nofollow\">online demo</a>.   </p>\n<p><strong>EXTRA CAUTION: implementation defined behavior ahead !!</strong> </p>\n<p>Your XXL alignment (it's bytes not bits) may not be supported by all compilers:  </p>\n<blockquote>\n<p id=\"so_38650310_38701636_3\"><strong>3.11/3:</strong> An extended alignment is represented by an alignment greater than <code>alignof(std::max_align_t)</code>. It is <strong>implementation-defined</strong>\n  whether any extended alignments are supported and the contexts in\n  which they are supported. A type having an extended alignment\n  requirement is an over-aligned type.</p>\n</blockquote>\n<p>And especially for dynamic allocation:  </p>\n<blockquote>\n<p id=\"so_38650310_38701636_4\"><strong>5.3.4/1 (new):</strong> It is implementation-defined whether over-aligned types are supported.</p>\n</blockquote>\n<p>For instance, this <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55727\" rel=\"nofollow\">GCC bug repport</a> requests better support for over-aligned objects.   So alignment issues you may experience come from over-alignment and not from the virtual functions. </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2016-08-01T14:52:07.667", "Id": "38701636", "Score": "1", "CreationDate": "2016-08-01T14:38:55.193", "LastActivityDate": "2016-08-01T14:52:07.667"}});