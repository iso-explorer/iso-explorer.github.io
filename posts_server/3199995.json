post_cb({"3199995": {"CommentCount": "3", "AcceptedAnswerId": "3200128", "CreationDate": "2010-07-08T00:56:09.043", "LastActivityDate": "2010-07-08T01:41:38.307", "PostTypeId": "1", "ViewCount": "1206", "FavoriteCount": "3", "Title": "Synchronizing access to a return value", "Id": "3199995", "Score": "13", "Body": "<p>Consider the following C++ member function:</p>\n<pre><code> size_t size() const\n {\n    boost::lock_guard&lt;boost::mutex&gt; lock(m_mutex);\n    return m_size;\n }\n</code></pre>\n<p>The intent here is not to synchronize access to the private member variable <code>m_size</code>, but just to make sure that the caller receives a valid value for m_size.  The goal is to prevent the function from returning <code>m_size</code> at the same time that some other thread is modifying <code>m_size</code>.</p>\n<p>But is there any potential race-condition involved in calling this function?  I'm not sure if the RAII style lock here is adequate to protect against a race condition.  Suppose the lock's destructor is called <em>before</em> the return value of the function is pushed onto the stack?</p>\n<p>Would I need to do something like the following to guarantee thread-safety?</p>\n<pre><code> size_t size() const\n {\n    size_t ret;\n\n    {\n      boost::lock_guard&lt;boost::mutex&gt; lock(m_mutex);\n      ret = m_size;\n    }\n\n    return ret;\n }\n</code></pre>\n", "Tags": "<c++><multithreading><boost-thread><thread-safety>", "OwnerUserId": "386140", "AnswerCount": "3"}, "3200040": {"ParentId": "3199995", "CommentCount": "1", "Body": "<p>Your initial code is fine - the destructor will be called after the return value has been stored. This is the very principle RAII operates on!</p>\n", "OwnerUserId": "169813", "PostTypeId": "2", "Id": "3200040", "Score": "1", "CreationDate": "2010-07-08T01:09:24.617", "LastActivityDate": "2010-07-08T01:09:24.617"}, "3200059": {"ParentId": "3199995", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Your first variant is safe, however you can't rely on this returned value to be consistent for any period of time.  I mean for example don't use that returned value in a for loop to iterate over each element, because the real size could change right after the return. </p>\n<p>Basically you can think of it like this: a copy is needed of the return value, otherwise the destructor would be called hence possibly corrupting whatever the return value was before it was returned. </p>\n<p>The destructor is called after the return statement.\nTake this equivalent example:</p>\n<pre><code>#include &lt;assert.h&gt;\n\nclass A\n{\npublic:\n    ~A()\n    {\n        x = 10;\n    }\n    int x;\n};\n\nint test()\n{\n    A a;\n    a.x = 5;\n    return a.x;\n}\n\nint main(int argc, char* argv[])\n{\n    int x = test();\n    assert(x == 5);\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "3153", "LastEditorUserId": "3153", "LastEditDate": "2010-07-08T01:41:38.307", "Id": "3200059", "Score": "3", "CreationDate": "2010-07-08T01:15:45.633", "LastActivityDate": "2010-07-08T01:41:38.307"}, "bq_ids": {"n4140": {"so_3199995_3200128_1": {"section_id": 3909, "quality": 0.7446808510638298, "length": 35}, "so_3199995_3200128_0": {"section_id": 407, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_3199995_3200128_1": {"section_id": 3769, "quality": 0.7446808510638298, "length": 35}, "so_3199995_3200128_0": {"section_id": 398, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_3199995_3200128_0": {"section_id": 425, "quality": 0.8571428571428571, "length": 12}, "so_3199995_3200128_1": {"section_id": 4795, "quality": 0.7446808510638298, "length": 35}}}, "3200128": {"ParentId": "3199995", "CommentCount": "0", "Body": "<p>Both of your example constructs will do what you're looking for. The following information from the standard supports the behavior you're looking for (even in your 1st example):</p>\n<p>12.4/10 Destructors:</p>\n<blockquote>\n<p id=\"so_3199995_3200128_0\">Destructors are invoked implicitly ... for a constructed object with automatic storage duration (3.7.2) when the block in which the object is created exits.</p>\n</blockquote>\n<p>And, 6.6/2 Jump statements (of which <code>return</code> is one):</p>\n<blockquote>\n<p id=\"so_3199995_3200128_1\">On exit from a scope (however accomplished), destructors (12.4) are called for all constructed objects with automatic storage duration (3.7.2) (named objects or temporaries) that are declared in that scope, in the reverse order of their declaration. Transfer out of a loop, out of a block, or back past an initialized variable with automatic storage duration involves the destruction of variables with automatic storage duration that are in scope at the point transferred from but not at the point transferred to.</p>\n</blockquote>\n<p>So at the point of the <code>return</code> the <code>lock</code> variable is in scope and therefore the dtor has not been called. Once the <code>return</code> has been executed, the dtor for the <code>lock</code> variable is called (thus releasing the lock).</p>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "3200128", "Score": "12", "CreationDate": "2010-07-08T01:35:38.377", "LastActivityDate": "2010-07-08T01:35:38.377"}});