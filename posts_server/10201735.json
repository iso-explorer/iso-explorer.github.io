post_cb({"10201796": {"Id": "10201796", "PostTypeId": "2", "Body": "<p>It appears you are running into rounding errors.</p>\n<p>A simple fix might be to use double instead of float.</p>\n<p>If that's not an option, then you might need to round to the integer. For example, if you have a floating point value f, do the equivalent of <code>int x = (int)(f + 0.5);</code></p>\n", "LastActivityDate": "2012-04-18T02:00:52.357", "CommentCount": "0", "CreationDate": "2012-04-18T02:00:52.357", "ParentId": "10201735", "Score": "0", "OwnerUserId": "522663"}, "bq_ids": {"n4140": {"so_10201735_10551800_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5945}, "so_10201735_10551800_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 5945}}, "n3337": {"so_10201735_10551800_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5716}, "so_10201735_10551800_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 5716}}, "n4659": {"so_10201735_10551800_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7430}, "so_10201735_10551800_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 7430}}}, "10201735": {"ViewCount": "4169", "Body": "<p>just wanna clear about these case below:</p>\n<pre><code>#define MAP_CELL_SIZE_MIN 0.1f\n\nfloat mMapHeight = 256;\nfloat mScrHeight = 320;\n\nint mNumRowMax;\n</code></pre>\n<p>case 1:</p>\n<pre><code>mNumRowMax = mMapHeight/( MAP_CELL_SIZE_MIN * mScrHeight );\n</code></pre>\n<p><code>mNumRowMax</code> is now 7, but actually it must be 8 ( 256/32 ), and if I change the define of <code>MAP_CELL_SIZE_MIN</code> to only <code>0.1</code> then it goes true, <code>mNumRowMax</code> is 8, so what's wrong with the <code>'f'</code></p>\n<p>case 2:</p>\n<pre><code>float tmp = mMapHeight/( MAP_CELL_SIZE_MIN * mScrHeight );//tmp = 8.0\nmNumRowMax = tmp;\n</code></pre>\n<p><code>mNumRowMax</code> is now 8, so can anybody help me understand what is wrong with the first case when <code>mNumRowMax</code> is 7</p>\n", "Title": "c++, float to int casting", "CreationDate": "2012-04-18T01:53:20.123", "LastActivityDate": "2012-05-11T12:56:19.960", "CommentCount": "3", "LastEditDate": "2012-04-18T01:55:42.377", "PostTypeId": "1", "LastEditorUserId": "922184", "Id": "10201735", "Score": "1", "OwnerUserId": "1148080", "Tags": "<c++><types><casting>", "AnswerCount": "3"}, "10551800": {"Id": "10551800", "PostTypeId": "2", "Body": "<p>What happens is </p>\n<h2>5 [expr]</h2>\n<blockquote>\n<p id=\"so_10201735_10551800_0\">10 The values of floating operands and of the results of floating expressions may be represented in greater precision and range than that required by the type; the types are not changed thereby.<sup>55)</sup></p>\n<p id=\"so_10201735_10551800_1\"><sup>55)</sup> The cast and assignment operators must still perform their specific conversions as described in 5.4, 5.2.9 and 5.17.</p>\n</blockquote>\n<p>(C++03; practically identical 6.3.1.8(2) in C99 and the n1570 draft of C11; I'm confident that the gist is identical in C++11.)</p>\n<p>In the following, I assume an IEEE-754 like binary floating point representation.</p>\n<p>In a fractional hexadecimal notation,</p>\n<pre><code>1/10 = 1/2 * 3/15\n     = 1/2 * 0.33333333333...\n     = 2^(-4) * 1.999999999...\n</code></pre>\n<p>so when that is rounded to <code>b</code> bits of precision, you get</p>\n<pre><code>2^(-4) * 1.99...9a   // if b \u2261 0 (mod 4) or b \u2261 1 (mod 4)\n2^(-4) * 1.99...98   // if b \u2261 2 (mod 4) or b \u2261 3 (mod 4)\n</code></pre>\n<p>where the last hex-digit in the fractional part is truncated after the 3,4,1,2 most significant bits respectively.</p>\n<p>Now <code>320 = 2^6*(2^2 + 1)</code>, so the result of <code>r * 320</code> where <code>r</code> is <code>0.1</code> rounded to <code>b</code> bits, is, in full precision (ignoring the power of 2),</p>\n<pre><code>   6.66...68\n + 1.99...9a\n -----------\n   8.00...02\n</code></pre>\n<p>with <code>b+3</code> bits for <code>b \u2261 0 (mod 4)</code> or <code>b \u2261 1 (mod 4)</code> and</p>\n<pre><code>   6.66...60\n + 1.99...98\n -----------\n   7.ff...f8\n</code></pre>\n<p>with <code>b+2</code> bits for <code>b \u2261 2 (mod 4)</code> or <code>b \u2261 3 (mod 4)</code>.</p>\n<p>In each case, rounding the result to <code>b</code> bits of precision yields exactly 32 and then you get <code>256/32 = 8</code> as a final result. But if the intermediate result with greater precision is used, the calculated result of</p>\n<pre><code>256/(0.1 * 320)\n</code></pre>\n<p>is slightly smaller or larger than 8.</p>\n<p>With the typical 32-bit <code>float</code> with 24 (23+1) bits of precision, if the intermediate results are represented with a precision of at least 53 bits:</p>\n<pre><code>0.1f = 1.99999ap-4\n0.1f * 320 = 32*(1 + 2^(-26))\n256/(0.1f * 320) = 8/(1 + 2^(-26)) = 8 * (1 - 2^(-26) + 2^(-52) - ...)\n</code></pre>\n<p>In case 1, the result is directly converted\u00b9 to <code>int</code> from the intermediate result. Since the intermediate result is slightly smaller than 8, it gets truncated to 7.</p>\n<p>In case 2, the intermediate result is stored in a <code>float</code> before converting to <code>int</code>, hence it is rounded to 24 bits of precision first, resulting in exactly 8.</p>\n<p>Now if you leave off the <code>f</code> suffix, <code>0.1</code> is a <code>double</code> (presumably with 53 bits of precision), the two <code>float</code>s are promoted to <code>double</code> for the calculation, and</p>\n<pre><code>0.1 = 1.999999999999ap-4\n0.1 * 320 = 32*(1 + 2^(-55))\n256/(0.1 * 320) = 8 * (1 - 2^(-55) + 2^(-110) - ...)\n</code></pre>\n<p>If the calculation is performed at <code>double</code> precision <code>1 + 2^(-55) == 1</code> and already <code>0.1 * 320 == 32</code>.</p>\n<p>If the calculation is performed at extended precision with 64 bits of precision (think x87) or more, it is likely that the literal <code>0.1</code> isn't converted to <code>double</code> precision at all and directly used with the extended precision, which again leads to the multiplication <code>0.1 * 320</code> resulting in exactly 32.</p>\n<p>If the literal <code>0.1</code> is used at <code>double</code> precision but the calculation is performed at higher precision, it would again yield 7 if the intermediate result is directly truncated to <code>int</code> from the representation with greater precision and 8 if the excess precision is removed before the conversion to <code>int</code>.</p>\n<p>(Aside: gcc/g++ 4.5.1 yields 8 for all cases, regardless of optimisation level, on my 64-bit box, I haven't tried on a 32-bit box.)</p>\n<p>\u00b9 I'm not entirely sure, but I think that's a violation of the standard, it should first remove the excess precision. Any language lawyers?</p>\n", "LastActivityDate": "2012-05-11T12:56:19.960", "CommentCount": "6", "CreationDate": "2012-05-11T12:56:19.960", "ParentId": "10201735", "Score": "2", "OwnerUserId": "1011995"}, "10201787": {"Id": "10201787", "PostTypeId": "2", "Body": "<p>When a floating point number is casted to an integer, the value is <em>truncated</em> and not <em>rounded</em>, i.e. all decimals are just \"chopped off\".</p>\n", "LastActivityDate": "2012-04-18T01:59:38.673", "CommentCount": "5", "CreationDate": "2012-04-18T01:59:38.673", "ParentId": "10201735", "Score": "0", "OwnerUserId": "440558"}});