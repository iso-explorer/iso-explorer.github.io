post_cb({"35790856": {"Id": "35790856", "PostTypeId": "2", "Body": "<p>Thats because the compiler is allowed to consider one conversion.</p>\n<p>To do what you need to do the compiler would need to plant two conversions.</p>\n<pre><code>printFoo(\"qix\");\n\n// Actually needs.\nprintFoo(Foo(std::string(\"qix\")));\n</code></pre>\n<p>If you change this so you pass a string it will work.</p>\n<pre><code>printFoo(std::string(\"qix\"));\n</code></pre>\n<p>The main reason behind all this is string literals have the type <code>char const[&lt;size&gt;]</code> <strong>NOT</strong> <code>std::string</code></p>\n", "LastActivityDate": "2016-03-04T08:00:11.833", "CommentCount": "1", "CreationDate": "2016-03-04T08:00:11.833", "ParentId": "35790664", "Score": "5", "OwnerUserId": "14065"}, "35790664": {"ViewCount": "779", "Body": "<p>In the below example, why can't I simply pass a <code>string</code> to the <code>printFoo()</code>?</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Foo {\npublic:\n  Foo(const Foo &amp;foo) : str(foo.str) {}\n  Foo(string str) : str(str) {}\n\n  string str;\n};\n\nvoid printFoo(Foo foo) {\n  cout &lt;&lt; foo.str &lt;&lt; endl;\n}\n\nint main() {\n  Foo foo(\"qux\");\n  printFoo(foo); // OK\n\n  printFoo(\"qix\"); // error: no matching function for call to 'printFoo'\n\n  return 0;\n}\n</code></pre>\n<p>For whatever reason, I had in my head that a constructor would automatically be determined and used in order to construct an object.</p>\n<p>Why can't I do this, but I can pass a <code>char[n]</code> constant to an argument accepting a <code>std::string</code>, for example?</p>\n", "AcceptedAnswerId": "35790867", "Title": "Why can't I implicitly construct an object given a suitable constructor when passing to an argument?", "CreationDate": "2016-03-04T07:46:44.267", "Id": "35790664", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-04T07:54:54.823", "LastEditorUserId": "510036", "LastActivityDate": "2016-03-05T13:48:07.123", "Score": "12", "OwnerUserId": "510036", "Tags": "<c++>", "AnswerCount": "4"}, "35814932": {"Id": "35814932", "PostTypeId": "2", "Body": "<p>As others have mentioned, problem is that 2 conversions needed. You may use <code>s</code> literal to convert string literal to actual <code>std::string</code></p>\n<pre><code>printFoo(\"qix\"s);\n</code></pre>\n<p><a href=\"http://ideone.com/mKlnbp\" rel=\"nofollow\">DEMO</a></p>\n", "LastActivityDate": "2016-03-05T13:48:07.123", "CommentCount": "0", "CreationDate": "2016-03-05T13:48:07.123", "ParentId": "35790664", "Score": "1", "OwnerUserId": "768110"}, "bq_ids": {"n4140": {"so_35790664_35790867_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}, "so_35790664_35790867_7": {"length": 11, "quality": 1.0, "section_id": 386}, "so_35790664_35790867_5": {"length": 18, "quality": 0.9, "section_id": 384}, "so_35790664_35790854_0": {"length": 11, "quality": 1.0, "section_id": 386}, "so_35790664_35790867_3": {"length": 4, "quality": 1.0, "section_id": 0}, "so_35790664_35790867_4": {"length": 21, "quality": 0.9130434782608695, "section_id": 383}, "so_35790664_35790867_2": {"length": 24, "quality": 1.0, "section_id": 0}, "so_35790664_35790867_1": {"length": 11, "quality": 1.0, "section_id": 0}}, "n3337": {"so_35790664_35790867_7": {"length": 11, "quality": 1.0, "section_id": 377}, "so_35790664_35790867_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}, "so_35790664_35790867_3": {"length": 4, "quality": 1.0, "section_id": 0}, "so_35790664_35790867_5": {"length": 18, "quality": 0.9, "section_id": 375}, "so_35790664_35790854_0": {"length": 11, "quality": 1.0, "section_id": 377}, "so_35790664_35790867_4": {"length": 21, "quality": 0.9130434782608695, "section_id": 374}, "so_35790664_35790867_2": {"length": 24, "quality": 1.0, "section_id": 0}, "so_35790664_35790867_1": {"length": 11, "quality": 1.0, "section_id": 0}}, "n4659": {"so_35790664_35790867_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}, "so_35790664_35790867_7": {"length": 11, "quality": 1.0, "section_id": 403}, "so_35790664_35790867_5": {"length": 18, "quality": 0.9, "section_id": 401}, "so_35790664_35790854_0": {"length": 11, "quality": 1.0, "section_id": 403}, "so_35790664_35790867_4": {"length": 21, "quality": 0.9130434782608695, "section_id": 400}, "so_35790664_35790867_3": {"length": 4, "quality": 1.0, "section_id": 0}, "so_35790664_35790867_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 0}, "so_35790664_35790867_1": {"length": 11, "quality": 1.0, "section_id": 0}}}, "35790854": {"Id": "35790854", "PostTypeId": "2", "Body": "<p>According to the C++ standard <em>\u00a712.3/4 Conversions [class.conv]:</em></p>\n<blockquote>\n<p id=\"so_35790664_35790854_0\">At most one user-defined conversion (constructor or conversion\n  function) is implicitly applied to a single value.</p>\n</blockquote>\n<p>Thus, the compiler is not allowed to apply two conversions in a row. That is, firstly from <code>const char[4]</code> to <code>std::string</code> and secondly from <code>std::string</code> to <code>Foo</code>.</p>\n<p>For this to work you would need to define an additional constructor:</p>\n<pre><code>Foo(char const *str_) : str(str_) {}\n</code></pre>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2016-03-04T08:08:41.980", "Score": "7", "CreationDate": "2016-03-04T08:00:08.043", "ParentId": "35790664", "CommentCount": "0", "OwnerUserId": "2352671", "LastEditDate": "2016-03-04T08:08:41.980"}, "35790867": {"Id": "35790867", "PostTypeId": "2", "Body": "<p>There would be two implicit conversions involved: </p>\n<ol>\n<li>to <code>std::string</code></li>\n<li>to <code>Foo</code></li>\n</ol>\n<p>C++ does at most one:</p>\n<p>From 4 Standard conversions (N3337)</p>\n<blockquote>\n<p id=\"so_35790664_35790867_0\">Standard conversions are implicit conversions with built-in meaning.\n  Clause 4 enumerates the full set of such conversions. A standard\n  conversion sequence is a sequence of standard conversions in the\n  following order: </p>\n<p id=\"so_35790664_35790867_1\">\u2014 Zero or one conversion from the following set:\n  lvalue-to-rvalue conversion, array-to-pointer conversion, and\n  function-to-pointer conversion. </p>\n<p id=\"so_35790664_35790867_2\">\u2014 Zero or one conversion from the\n  following set: integral promotions, floating point promotion, integral\n  conversions, floating point conversions, floating-integral\n  conversions, pointer conversions, pointer to member conversions, and\n  boolean conversions. </p>\n<p id=\"so_35790664_35790867_3\">\u2014 Zero or one qualification conversion.</p>\n</blockquote>\n<p>Also 12.3 Conversions (N3337)</p>\n<blockquote>\n<p id=\"so_35790664_35790867_4\">1 Type conversions of class objects can be specified by constructors and\n  by conversion functions. These conversions are called user-defined\n  conversions and are used for implicit type conversions (Clause 4), for\n  initialization (8.5), and for explicit type conversions (5.4, 5.2.9).</p>\n<p id=\"so_35790664_35790867_5\">2 User-defined conversions are applied only where they are unambiguous\n  (10.2, 12.3.2). Conversions obey the access control rules (Clause 11).\n  Access control is applied after ambiguity resolution (3.4). </p>\n<p id=\"so_35790664_35790867_6\">[...]</p>\n<p id=\"so_35790664_35790867_7\">4 <strong>At most one user-defined</strong>\n<strong>conversion (constructor or conversion function) is implicitly applied</strong>\n<strong>to a single value.</strong></p>\n</blockquote>\n<p>(Emphasis mine)</p>\n", "LastEditorUserId": "510036", "LastActivityDate": "2016-03-04T11:14:26.167", "Score": "14", "CreationDate": "2016-03-04T08:00:50.560", "ParentId": "35790664", "CommentCount": "0", "OwnerUserId": "2249683", "LastEditDate": "2016-03-04T11:14:26.167"}});