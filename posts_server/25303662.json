post_cb({"bq_ids": {"n4140": {"so_25303662_25303864_1": {"length": 8, "quality": 1.0, "section_id": 391}}, "n3337": {"so_25303662_25303864_1": {"length": 8, "quality": 1.0, "section_id": 382}}, "n4659": {"so_25303662_25303864_1": {"length": 8, "quality": 1.0, "section_id": 408}}}, "25303864": {"Id": "25303864", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25303662_25303864_0\">Does declaring a <code>operator T()</code> imply that the cast always returns a <code>T</code> by value?</p>\n</blockquote>\n<p>Yes.</p>\n<p>The return type of conversion operators is implicitly exactly what they convert to.</p>\n<blockquote>\n<p id=\"so_25303662_25303864_1\">[...] the type of the conversion function is \u201cfunction taking no parameter returning conversion-type-id\u201d.</p>\n<p id=\"so_25303662_25303864_2\">\u00a712.3.2 [class.conv.fct]</p>\n</blockquote>\n", "LastActivityDate": "2014-08-14T08:49:01.363", "CommentCount": "12", "CreationDate": "2014-08-14T08:49:01.363", "ParentId": "25303662", "Score": "5", "OwnerUserId": "1007504"}, "25308605": {"Id": "25308605", "PostTypeId": "2", "Body": "<p><strong>Does declaring a <code>operator T()</code> imply that the cast always returns a <code>T</code> by value?</strong></p>\n<p>It means that the conversion operator will return as specified by <code>T</code>. Be that a reference, pointer or value. For example, given some type (as per the OP) <code>Y</code>:</p>\n<pre><code>operator Y();\noperator Y&amp;();\noperator Y*();\n</code></pre>\n<p>Are all (with the cv-qualified variations) valid user defined conversions. To use <code>Y</code> as a reference, you will need to return it as a reference.</p>\n<p>So, yes, casting to a <code>T</code> that is not a reference means that the return type is a value. This is inline with the <a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow\">general casting semantics</a> - a value is returned.</p>\n<p><strong>Is there any difference in the semantics of the first and the second example?</strong></p>\n<p>Yes there are semantic differences. They would be the same semantic deferences as in other methods with reference vs. value return types. They would be different in the same way as the following two methods are different;</p>\n<pre><code>Y get_y_value();\nY&amp; get_y_ref();\n</code></pre>\n<p><strong>Notes</strong></p>\n<p>Mixing <code>operator Y();</code> and <code>operator Y&amp;();</code> in the same class could lead to ambiguous overloads (at least clang complains about this, but gcc seems happy to mix the two).</p>\n<p>I'm not going to opinion on which one is better here as the details of your situation are unclear. In general though, when implementing a user defined conversion, always consider how casts are typically performed and that rvalues are probably returned more often than not. With the advent of C++11, favour them being <code>explicit</code> as well; for the same reasons constructors are <code>explicit</code> (or not if specifically required).</p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2014-10-21T11:40:17.787", "Score": "3", "CreationDate": "2014-08-14T12:57:12.040", "ParentId": "25303662", "CommentCount": "0", "OwnerUserId": "3747990", "LastEditDate": "2014-10-21T11:40:17.787"}, "25303662": {"ViewCount": "2413", "Body": "<p>C++ allows for overloading type casts by creating an <code>operator T()</code> where <code>T</code> is the type we want to cast to.</p>\n<p>Now, how does this feature play together with references? For example:</p>\n<pre><code>struct Y{ int i; };\n\nstruct X{\n    Y y;\n\n    operator Y() const { return y; }\n};\n</code></pre>\n<p>Here, we can cast an <code>X</code> to <code>Y</code> which will simply return the contained <code>Y</code>. But what if we want to make a cast to an <code>Y</code> reference. For example, C++ allows us to do this:</p>\n<pre><code>struct X{\n    Y y;\n\n    operator Y&amp;(){ return y; }\n    operator const Y&amp;() const { return y; }\n};\n</code></pre>\n<p>Now, we can cast an <code>X</code> to a <code>Y</code> reference or a <code>const</code> reference (which also works for a <code>const X</code>). </p>\n<p><strong>Is there any difference in the semantics of the first and the second example? What is the best way if I want to allow casting to a reference?</strong></p>\n<p>I could imagine that even if I write <code>operator T()</code> without any <code>&amp;</code>, C++ might allow that the cast returns a result by reference (i.e., it might somehow add implicit <code>operator T&amp;()</code> methods when I specify <code>operator T()</code>).</p>\n<p>For example, I want the following code to work:</p>\n<pre><code>int main(){\n    X x;\n    Y&amp; y = x; // y now references the y inside x\n    y.i = 5;\n    std::cout &lt;&lt; x.y.i &lt;&lt; std::endl; // Should print 5 now\n}\n</code></pre>\n<p>What is the most simple way to achieve this?</p>\n", "Title": "C++: Cast operator overloading and references", "CreationDate": "2014-08-14T08:38:20.597", "LastActivityDate": "2014-10-21T11:40:17.787", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-08-14T11:23:28.713", "LastEditorUserId": "1774667", "Id": "25303662", "Score": "4", "OwnerUserId": "1408611", "Tags": "<c++><casting><reference><operator-overloading>", "AnswerCount": "3"}, "25303921": {"Id": "25303921", "PostTypeId": "2", "Body": "<p>With clang++:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass   test\n{\npublic:\n  test(int n) : nb{n} {}\n\npublic:\n  operator int() { return nb; }\n\n  private:\n    int nb;\n};\n\nint     main(void)\n{\n  test  t{42};\n\n  int x = t;\n\n  int&amp; ref = t;   // error: non-const lvalue reference to type 'int' cannot bind to a value of unrelated type 'test'\n  int&amp;&amp; rref = t; // compiles fine\n\n  std::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Which suggest that you do return a temporary new value.</p>\n<p>The real question to help you choose between your two cases is: <strong>do you want to let people modify your internal member (return a reference) and is that member expensive to copy (use a const reference instead of value) ?</strong></p>\n", "LastEditorUserId": "1147772", "LastActivityDate": "2014-08-14T09:07:41.860", "Score": "3", "CreationDate": "2014-08-14T08:51:51.320", "ParentId": "25303662", "CommentCount": "5", "OwnerUserId": "1147772", "LastEditDate": "2014-08-14T09:07:41.860"}});