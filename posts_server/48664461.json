post_cb({"bq_ids": {"n4140": {"so_48664461_48664461_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 639}}, "n3337": {"so_48664461_48664461_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 629}}, "n4659": {"so_48664461_48664461_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 667}}}, "48664496": {"Id": "48664496", "PostTypeId": "2", "Body": "<p>Variable templates have been introduced in C++14, see <a href=\"http://en.cppreference.com/w/cpp/language/variable_template\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/variable_template</a></p>\n", "LastEditorUserId": "6525260", "LastActivityDate": "2018-02-07T13:04:49.820", "Score": "9", "CreationDate": "2018-02-07T13:01:10.117", "ParentId": "48664461", "CommentCount": "9", "OwnerUserId": "2684539", "LastEditDate": "2018-02-07T13:04:49.820"}, "48664657": {"Id": "48664657", "PostTypeId": "2", "Body": "<p>To declare an <code>array</code> of 5 elements:</p>\n<pre><code>constexpr std::array&lt;void*, 5&gt; empty_array{};\n</code></pre>\n<p>To declare an <code>array</code> of 10 elements:</p>\n<pre><code>constexpr std::array&lt;void*, 10&gt; empty_array{};\n</code></pre>\n<p>To declare an array of N elements where N is not fixed, you need to use a template which can be instantiated for different values of N:</p>\n<pre><code>// A variable of type std::array&lt;void*, N&gt; where N is not fixed yet:\ntemplate&lt;size_t N&gt; constexpr std::array&lt;void*, N&gt; empty_array{};\n\n// Then given a function like this:\nvoid do_something(const std::array&lt;void*, 5&gt;&amp;);\n\n// You use the variable like this, by giving the value of N:\nvoid some_function() {\n  do_something(empty_array&lt;5&gt;);\n}\n</code></pre>\n<p>But this is a <em>variable template</em> which is a new feature in C++14. You can't do this in C++11, so you get that compiler error.</p>\n<p>Either use C++14, or do something like:</p>\n<pre><code>// An alias template defining a _type_ of array with no fixed N:\ntemplate&lt;std::size_t N&gt;\n  using voidptr_array = std::array&lt;void*, N&gt;;\n\nconstexpr voidptr_array&lt;5&gt; empty_array_of_5{};\nconstexpr voidptr_array&lt;10&gt; empty_array_of_10{};\n\nvoid do_something(const std::array&lt;void*, 5&gt;&amp;);\n\nvoid some_function() {\n  do_something(empty_array_of_5);\n}\n</code></pre>\n<p>This alias template defines a <em>type</em> that takes N as a parameter, instead of a <em>variable</em> that takes N as a parameter. You still need to define variables of that type, like <code>empty_array_of_5</code> and <code>empty_array_of_10</code>.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2018-02-07T13:15:58.423", "Score": "8", "CreationDate": "2018-02-07T13:07:56.580", "ParentId": "48664461", "CommentCount": "0", "OwnerUserId": "981959", "LastEditDate": "2018-02-07T13:15:58.423"}, "48664461": {"ViewCount": "81", "Body": "<p>Consider the following MWE (<a href=\"https://godbolt.org/g/aydjpW\" rel=\"nofollow noreferrer\">https://godbolt.org/g/aydjpW</a>):</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;array&gt;\ntemplate&lt;size_t N&gt; constexpr std::array&lt;void*, N&gt; empty_array{};\n</code></pre>\n<p>My goal is to have an array of size <code>N</code> where every element is default-initialized (in the case of this MWE, a <code>nullptr</code>). g++ 5.4.0 with <code>-std=c++11</code> complains that</p>\n<blockquote>\n<p id=\"so_48664461_48664461_0\">variable templates only available with -std=c++14 or -std=gnu++14</p>\n</blockquote>\n<p>I don't understand why. According to <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/container/array</a>, <code>array&lt;T, N&gt;</code> exists since C++11 and the implicitly declared constructor </p>\n<blockquote>\n<p id=\"so_48664461_48664461_1\">initializes the array following the rules of aggregate initialization</p>\n</blockquote>\n<p>Following the link to the description of aggregate initialization at <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/aggregate_initialization</a>, it says that</p>\n<blockquote>\n<p id=\"so_48664461_48664461_2\">If the number of initializer clauses is less than the number of\n  members or initializer list is completely empty, the remaining members\n  are value-initialized.</p>\n</blockquote>\n<p>Thus, my assumption would have been that my code above is valid C++11. What am I missing here that variable templates get involved somehow, which would require C++14?</p>\n", "AcceptedAnswerId": "48664657", "Title": "Why does the default initialization of the elements of an array<T*, N> require C++14?", "CreationDate": "2018-02-07T12:59:18.400", "Id": "48664461", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2018-02-07T13:15:58.423", "Score": "2", "OwnerUserId": "4568958", "Tags": "<c++><arrays><c++11><c++14>", "AnswerCount": "2"}});