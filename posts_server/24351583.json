post_cb({"bq_ids": {"n4140": {"so_24351583_24351606_3": {"length": 39, "quality": 0.9285714285714286, "section_id": 6991}, "so_24351583_24351606_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6990}, "so_24351583_24351606_5": {"length": 27, "quality": 1.0, "section_id": 6993}, "so_24351583_24351606_4": {"length": 60, "quality": 0.8823529411764706, "section_id": 6992}, "so_24351583_24351606_1": {"length": 35, "quality": 0.8974358974358975, "section_id": 6989}}, "n3337": {"so_24351583_24351606_3": {"length": 41, "quality": 0.9761904761904762, "section_id": 6737}, "so_24351583_24351606_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6736}, "so_24351583_24351606_5": {"length": 27, "quality": 1.0, "section_id": 6739}, "so_24351583_24351606_1": {"length": 35, "quality": 0.8974358974358975, "section_id": 6735}, "so_24351583_24351606_4": {"length": 60, "quality": 0.8823529411764706, "section_id": 6738}}, "n4659": {"so_24351583_24351606_3": {"length": 39, "quality": 0.9285714285714286, "section_id": 8489}, "so_24351583_24351606_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 8488}, "so_24351583_24351606_5": {"length": 27, "quality": 1.0, "section_id": 8491}, "so_24351583_24351606_1": {"length": 35, "quality": 0.8974358974358975, "section_id": 8487}, "so_24351583_24351606_4": {"length": 60, "quality": 0.8823529411764706, "section_id": 8490}}}, "24351869": {"Id": "24351869", "PostTypeId": "2", "Body": "<p>1) You must use pointers.\n2) If you want to get A::f(), you must use A* type variable, but class instance can be of type B* or A*.</p>\n<pre><code>    #include &lt;iostream&gt;\n    using namespace std;\n    class A {\n    public:\n        virtual void f(int a) {cout &lt;&lt; a &lt;&lt; \" A::f(int)\" &lt;&lt; endl; }\n        virtual void f(){cout &lt;&lt; 5 &lt;&lt; \" A::f()\" &lt;&lt; endl;}\n    };\n    class B:public A {\n    public:\n        virtual void f(int a) {cout &lt;&lt; a+1 &lt;&lt; \" B::f(int)\" &lt;&lt; endl; }\n    };\n    int main() {\n        A *a;\n        a = new B();\n        a-&gt;f(1);\n        a-&gt;f();\n        delete a;\n        a = new A();\n        a-&gt;f(1);\n        a-&gt;f();\n        delete a;\n        return 0;\n    }\n</code></pre>\n<p>Output:</p>\n<pre><code>    2 B::f(int)\n    5 A::f()\n    1 A::f(int)\n    5 A::f()\n</code></pre>\n", "LastActivityDate": "2014-06-22T13:45:40.860", "CommentCount": "0", "CreationDate": "2014-06-22T13:45:40.860", "ParentId": "24351583", "Score": "0", "OwnerUserId": "1742529"}, "24351583": {"ViewCount": "113", "Body": "<p>Running this C++ Source on Visual C++ 2010:</p>\n<pre><code>class B{\npublic:\n    virtual void f(int a){}\n    virtual void f(){}\n};\nclass A:public B{\npublic:\n    virtual void f(int a){}\n};\nint main(){\nA a;\na.f();\nreturn 0;\n}\n</code></pre>\n<p>Leads to the following error:</p>\n<p><code>IntelliSense: too few arguments in function call</code></p>\n<p>In other words, it seems that <code>void f()</code> didn't inherited? </p>\n<p>What is the problem? </p>\n", "AcceptedAnswerId": "24351606", "Title": "Unrecognized inherited function", "CreationDate": "2014-06-22T13:12:59.183", "Id": "24351583", "CommentCount": "3", "LastEditDate": "2014-06-22T13:18:50.527", "PostTypeId": "1", "LastEditorUserId": "2794292", "LastActivityDate": "2014-06-27T14:43:01.683", "Score": "4", "OwnerUserId": "1798362", "Tags": "<c++><inheritance>", "AnswerCount": "3"}, "24351612": {"Id": "24351612", "PostTypeId": "2", "Body": "<p>Your declaration of <code>A::f(int a)</code> hides all signatures <code>B::f</code> unless they are exposed to the derived class.  There are 2 good options for exposing the \"hidden\" methods.</p>\n<p><strong>Option 1</strong></p>\n<pre><code>class A:public B{\npublic:\n    using B::f;\n    virtual void f(int a){}\n};\n</code></pre>\n<p><strong>Option 2</strong></p>\n<pre><code>class A:public B{\npublic:\n    virtual void f(int a){}\n    virtual void f(){ B::f(); }\n};\n</code></pre>\n", "LastActivityDate": "2014-06-22T13:17:18.107", "CommentCount": "0", "CreationDate": "2014-06-22T13:17:18.107", "ParentId": "24351583", "Score": "6", "OwnerUserId": "1303358"}, "24351606": {"Id": "24351606", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24351583_24351606_0\">it seems that void f() didn't inherited?</p>\n</blockquote>\n<p>The name f in class A <em>shadows</em> name f in B. You can still access foo() from B this way</p>\n<pre><code>A a;\na.B::f();\n</code></pre>\n<p>Other option is to redeclare function foo of B in the scope of A:</p>\n<pre><code>class A : public B{\npublic:\n\n    virtual void f(int a) {}\n    using B::foo;\n};\n</code></pre>\n<hr>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 10.2 Member name lookup</p>\n<blockquote>\n<p id=\"so_24351583_24351606_1\">1) Member name lookup determines the meaning of a name (id-expression)\n  in a class scope (3.3.7). Name lookup can result in an ambiguity, in\n  which case the program is ill-formed. For an id-expression, name\n  lookup begins in the class scope of this; for a qualified-id, name\n  lookup begins in the scope of the nested- name-specifier. Name lookup\n  takes place before access control (3.4, Clause 11).</p>\n<p id=\"so_24351583_24351606_2\">2) The following steps define the result of name lookup for a member\n  name f in a class scope C.</p>\n<p id=\"so_24351583_24351606_3\">3) The lookup set for f in C, called S(f, C), consists of two\n  component sets: the declaration set, a set of members named f; and the\n  subobject set, a set of subobjects where declarations of these members\n  (possibly including using-declarations) were found. In the declaration\n  set, using-declarations are replaced by the members they designate,\n  and type declarations (including injected-class-names) are replaced by\n  the types they designate. S(f, C) is calculated as follows:</p>\n<p id=\"so_24351583_24351606_4\">4) If C contains a declaration of the name f, the declaration set\n  contains every declaration of f declared in C that satisfies the\n  requirements of the language construct in which the lookup occurs. [\n  Note: Looking up a name in an elaborated-type-specifier (3.4.4) or\n  base-specifier (Clause 10), for instance, ignores all non- type\n  declarations, while looking up a name in a nested-name-specifier\n  (3.4.3) ignores function, variable, and enumerator declarations. As\n  another example, looking up a name in a using-declaration (7.3.3)\n  includes the declaration of a class or enumeration that would\n  ordinarily be hidden by another declaration of that name in the same\n  scope. \u2014 end note ] If the resulting declaration set is not empty, the\n  subobject set contains C itself, and calculation is complete.</p>\n<p id=\"so_24351583_24351606_5\">5) Otherwise (i.e., C does not contain a declaration of f or the\n  resulting declaration set is empty), S(f, C) is initially empty. If C\n  has base classes, calculate the lookup set for f in each direct base\n  class subobject Bi , and merge each such lookup set S(f, Bi ) in turn\n  into S(f, C).</p>\n</blockquote>\n</hr>", "LastEditorUserId": "1141471", "LastActivityDate": "2014-06-27T14:43:01.683", "Score": "8", "CreationDate": "2014-06-22T13:16:09.780", "ParentId": "24351583", "CommentCount": "0", "OwnerUserId": "1141471", "LastEditDate": "2014-06-27T14:43:01.683"}});