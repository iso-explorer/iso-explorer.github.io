post_cb({"bq_ids": {"n4140": {"so_32845759_32848265_1": {"length": 39, "quality": 0.9285714285714286, "section_id": 5797}, "so_32845759_32848265_0": {"length": 10, "quality": 1.0, "section_id": 5797}}, "n3337": {"so_32845759_32848265_1": {"length": 39, "quality": 0.9285714285714286, "section_id": 5570}, "so_32845759_32848265_0": {"length": 10, "quality": 1.0, "section_id": 5570}}, "n4659": {"so_32845759_32848265_1": {"length": 39, "quality": 0.9285714285714286, "section_id": 7256}, "so_32845759_32848265_0": {"length": 10, "quality": 1.0, "section_id": 7256}}}, "32845759": {"ViewCount": "64", "Body": "<p>I'm wondering under what circumstances compilers like GCC and LLVM are able to optimize multiple calls in the same function to some of the trivial member functions like <code>size()</code> and <code>length()</code> of STL containers to just one call?</p>\n<p>For example, if I compare values to the size of a container twice in the same function, but never actually change the container can it combine these into one function call and if so when?</p>\n<p>The compiler should be able to do an optimization unless it might think that another thread could be mucking with the container simultaneously. On the other hand the typical <code>it != x.end()</code> guard in a loop seems to be optimized to just one call to <code>x.end()</code> and I presume this happens, because if some other thread would be adding/deleting stuff from <code>x</code>, then it would invalidate the iterator <code>it</code>, so we're free to do the optimization, since we would have undefined behavior anyway.</p>\n", "Title": "When can optimizer combine calls to member functions?", "CreationDate": "2015-09-29T13:50:47.817", "LastActivityDate": "2015-09-29T16:51:31.597", "CommentCount": "2", "PostTypeId": "1", "Id": "32845759", "Score": "0", "OwnerUserId": "4258832", "Tags": "<c++><gcc><optimization><llvm>", "AnswerCount": "1"}, "32848265": {"Id": "32848265", "PostTypeId": "2", "Body": "<p>The compiler is allowed to omit code that would have no visible effect. Ref: Draft 4296 for C++11 specification says at 1.9 Program execution [intro.execution] \u00a75</p>\n<blockquote>\n<p id=\"so_32845759_32848265_0\">...conforming\n  implementations are required to emulate (only) the observable behavior of the abstract machine as explained\n  below.</p>\n</blockquote>\n<p>A note gives following precision (emphasize mine):</p>\n<blockquote>\n<p id=\"so_32845759_32848265_1\">This provision is sometimes called the \u201cas-if\u201d rule, because an implementation is free to disregard any requirement of this\n  International Standard as long as the result is as if the requirement had been obeyed, as far as can be determined from the\n  observable behavior of the program. For instance, an actual implementation <strong>need not evaluate part of an expression if it can\n  deduce that its value is not used and that no side effects</strong> affecting the observable behavior of the program are produced.</p>\n</blockquote>\n<p>If the compiler knows that a particular method has no side effect, it can replace (provided <code>x</code> is not volatile):</p>\n<pre><code>int x = myfunction(y);\n... // other instructions not changing x\nint x = myfunction(z);\n</code></pre>\n<p>with</p>\n<pre><code>int x = myfunction(z);\n... // other instructions not changing x\n</code></pre>\n<p>The problem here, is that you are calling a function from the standard library, and compiler may not know whether the implementation will have or not side effects. For example a debugging implementation could trace all calls to <code>size</code> method by calling a method not present in header (*), but this would be the only reason that forbids omitting code here.</p>\n<p>Other threads changing container is <strong>not</strong> compiler's problem but programmer's one. <strong>You</strong> have to synchronize accesses.</p>\n<p>(*) As noted in comments, is the container code in only in a header (common for a template) compiler can know at compile time that <code>size</code> method will have no visible side effect and could optimize out the second call. But this is not required by standard and shall be seen as an implementation detail.</p>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2015-09-29T16:51:31.597", "Score": "1", "CreationDate": "2015-09-29T15:40:04.520", "ParentId": "32845759", "CommentCount": "5", "OwnerUserId": "3545273", "LastEditDate": "2015-09-29T16:51:31.597"}});