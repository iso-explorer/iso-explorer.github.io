post_cb({"bq_ids": {"n4140": {"so_16999039_16999060_1": {"length": 17, "quality": 1.0, "section_id": 328}, "so_16999039_16999060_0": {"length": 21, "quality": 1.0, "section_id": 328}}, "n3337": {"so_16999039_16999060_1": {"length": 17, "quality": 1.0, "section_id": 318}, "so_16999039_16999060_0": {"length": 21, "quality": 1.0, "section_id": 318}}, "n4659": {"so_16999039_16999060_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 336}, "so_16999039_16999060_0": {"length": 21, "quality": 1.0, "section_id": 336}}}, "16999060": {"Id": "16999060", "PostTypeId": "2", "Body": "<p>So here is what happens (or rather, <em>should</em> happen): in order to resolve this constructor call</p>\n<pre><code>Myclass b(a);\n</code></pre>\n<p>The compiler has to perform overload resolution and decide, at first, which constructors are viable candidates.</p>\n<p>The first thing to notice is that both constructors are viable: forms like <code>T&amp;&amp;</code> do <em>not</em> always resolve into rvalue references (that's only the case if what you are passing is an rvalue). That's what Scott Meyers calls <a href=\"http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11\" rel=\"nofollow noreferrer\">\"universal references\"</a> (notice, that this term is not standard).</p>\n<p>When the compiler tries to perform type deduction to see if the second constructor is viable, the type <code>T</code> in this case will be deduced to be <code>Myclass&amp;</code> - since what you are passing (<code>a</code>) is an lvalue; and because of the reference collapsing rules, <code>Myclass&amp; &amp;&amp;</code> gives <code>Myclass&amp;</code>, so you end up with the same signature your first constructor has.</p>\n<p>So is the call is ambiguous? As pointed out by <a href=\"https://stackoverflow.com/questions/16999039/why-are-my-t-and-t-copy-constructors-ambiguous/16999060#comment24561208_16999039\">Marc Glisse in the comments to the question</a>, and by <a href=\"http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11\" rel=\"nofollow noreferrer\">Jonathan Wakely in the comments to this answer</a>, <strong>no</strong>, it should not be (as the original version of this answer claimed - mea culpa). </p>\n<p>The reason is that a special rule in the Standard specifies that the overload accepting an lvalue reference is <em>more specialized</em> than the overload accepting an rvalue reference. Per paragraph 14.8.2.4/9 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16999039_16999060_0\">If, for a given type, deduction succeeds in both directions (i.e., the types are identical after the transformations\n  above) and both P and A were reference types (before being replaced with the type referred to\n  above):</p>\n<p id=\"so_16999039_16999060_1\">\u2014 <strong>if the type from the argument template was an lvalue reference and the type from the parameter\n  template was not, the argument type is considered to be more specialized than the other</strong>; otherwise, [...]</p>\n</blockquote>\n<p>This means the compiler has a bug (<a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57172\" rel=\"nofollow noreferrer\">the link to the bug report</a> has been provided by Marc Glisse in the comments to the question).</p>\n<p>To workaround this bug and make sure your constructor template accepting a <code>T&amp;&amp;</code> will be picked by GCC only when rvalues are being passed, you can rewrite it this way:</p>\n<pre><code>    #include &lt;type_traits&gt;\n\n    template&lt;typename U,\n        typename std::enable_if&lt;\n            !std::is_reference&lt;U&gt;::value\n            &gt;::type* = nullptr&gt;\n    Myclass(U&amp;&amp; rvalue):i(rvalue)\n    {cout&lt;&lt;i &lt;&lt;\" template right reference\" &lt;&lt;endl;i++;}\n</code></pre>\n<p>Where I added a SFINAE-constraint which makes the compiler discard this constructor from the overload set when an lvalue is being passed. </p>\n<p>When an lvalue is passed, in fact, <code>T</code> will be deduced to be <code>X&amp;</code> for some <code>X</code> (the type of the expression you pass, <code>Myclass</code> in your case), and <code>T&amp;&amp;</code> will resolve into <code>X&amp;</code>; when an rvalue is being passed, on the other hand, <code>T</code> will be deduced to be <code>X</code> from some <code>X</code> (the type of the expression you pass, <code>Myclass</code> in your case), and <code>T&amp;&amp;</code> will resolve into <code>X&amp;&amp;</code>.</p>\n<p>Since the SFINAE constraint checks whether <code>T</code> is not deduced to be a reference type and creates a substitution failure otherwise, your constructor is guaranteed to be considered only when the argument is an rvalue expression.</p>\n<p>So to sum it all up:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nclass Myclass\n{\n    int i;\npublic:\n    template&lt;typename U&gt;\n    Myclass(U&amp; lvalue):i(lvalue)\n    {\n        std::cout &lt;&lt; i &lt;&lt;\" template light reference\" &lt;&lt; std::endl;\n        i++;\n    }\n\n    template&lt;typename U,\n        typename std::enable_if&lt;\n            !std::is_reference&lt;U&gt;::value\n            &gt;::type* = nullptr&gt;\n    Myclass(U&amp;&amp; rvalue):i(rvalue)\n    {\n        std::cout &lt;&lt; i &lt;&lt;\" template right reference\" &lt;&lt; std::endl;\n        i++;\n    }\n};\n\nint main(int argc,char*argv[])\n{\n    Myclass a(0);\n    int x = 42;\n    Myclass b(x);\n    Myclass c(2);\n}\n</code></pre>\n<p>Here is a <a href=\"http://coliru.stacked-crooked.com/view?id=3306dc4347a90be1be31b064c187c33e-25dabfc2c190f5ef027f31d968947336\" rel=\"nofollow noreferrer\"><strong>live example</strong></a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-08T14:21:19.210", "Score": "9", "CreationDate": "2013-06-08T11:28:48.703", "ParentId": "16999039", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:11:20.387"}, "16999039": {"ViewCount": "956", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass Myclass{\n        private:\n                int i;\n        public:\n                template&lt;typename U&gt;Myclass(U&amp; lvalue):i(lvalue){cout&lt;&lt;i &lt;&lt;\" template light reference\" &lt;&lt;endl;i++;}\n                //Myclass(Myclass &amp;lvalue):i(lvalue){cout&lt;&lt;i &lt;&lt;\" light reference\" &lt;&lt;endl;i++;}\n                template&lt;typename U&gt;Myclass(U&amp;&amp; rvalue):i(rvalue){cout&lt;&lt;i &lt;&lt;\" template right reference\" &lt;&lt;endl;i++;}\n};\n\nint main(int argc,char*argv[])\n{\nMyclass a(0);\nMyclass b(a);\nMyclass c(2);\nreturn 0;\n}\n</code></pre>\n<p><strong>error message:</strong></p>\n<pre><code>rightvalue.cpp: In function \u2018int main(int, char**)\u2019:\nrightvalue.cpp:15:12: error: call of overloaded \u2018Myclass(Myclass&amp;)\u2019 is ambiguous\nrightvalue.cpp:15:12: note: candidates are:\nrightvalue.cpp:10:23: note: Myclass::Myclass(U&amp;&amp;) [with U = Myclass&amp;]\nrightvalue.cpp:8:23: note: Myclass::Myclass(U&amp;) [with U = Myclass]\nrightvalue.cpp:4:7: note: constexpr Myclass::Myclass(const Myclass&amp;)\nrightvalue.cpp:4:7: note: constexpr Myclass::Myclass(Myclass&amp;&amp;) &lt;near match&gt;\nrightvalue.cpp:4:7: note:   no known conversion for argument 1 from \u2018Myclass\u2019 to \u2018Myclass&amp;&amp;\u2019\n</code></pre>\n", "AcceptedAnswerId": "16999060", "Title": "Why are my T& and T&& copy constructors ambiguous?", "CreationDate": "2013-06-08T11:25:52.237", "Id": "16999039", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-06-08T11:32:33.187", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-08T14:21:19.210", "Score": "8", "OwnerUserId": "1501948", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}});