post_cb({"17254443": {"ParentId": "17254381", "CommentCount": "0", "Body": "<p>The function with the signature <code>B::test(void)</code> returns an object of type <code>Q&lt;A&gt;</code>, while <code>C::test(void)</code> (which is the same signature, so you're overwriting the function) returns <code>Q&lt;B&gt;</code>. I think that is impossible.</p>\n<p>As far as I know it is impossible to overload a function by return type and overwrites of parent functions need to stick to the same return type.</p>\n<p>From the Standard \u00a710.3/7</p>\n<blockquote>\n<p id=\"so_17254381_17254443_0\">The return type of an overriding function shall be either identical to the return type of the overridden function or covariant with the classes of the functions. If a function D::f overrides a function B::f, the return types of the functions are covariant if they satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to classes, both are lvalue references to classes, or both are rvalue references to\n  classes112</li>\n<li>the class in the return type of B::f is the same class as the class in the return type of D::f, or is an unambiguous and accessible direct or indirect base class of the class in the return type of D::f</li>\n<li>both pointers or references have the same cv-qualification and the class type in the return type of D::f has the same cv-qualification as or less cv-qualification than the class type in the return type of B::f.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "951423", "PostTypeId": "2", "Id": "17254443", "Score": "0", "CreationDate": "2013-06-22T19:19:32.473", "LastActivityDate": "2013-06-22T19:19:32.473"}, "17254455": {"ParentId": "17254381", "CommentCount": "0", "Body": "<p>You cannot do that. Overrides of virtual functions cannot change the prototype of the function, except very specific cases, such as the covariant return types.</p>\n<p>Covariant return would be valid if you were to return in the virtual override a subclass of the type returned in the virtual base. But your <code>Q&lt;A&gt;</code> and <code>Q&lt;B&gt;</code> are unrelated by inheritance. The fact that <code>B</code> is a subclass of <code>A</code> does not make any difference here.</p>\n", "OwnerUserId": "865874", "PostTypeId": "2", "Id": "17254455", "Score": "0", "CreationDate": "2013-06-22T19:21:03.853", "LastActivityDate": "2013-06-22T19:21:03.853"}, "17254381": {"CommentCount": "1", "AcceptedAnswerId": "17254451", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2013-06-22T19:11:43.603", "LastActivityDate": "2017-01-17T10:57:49.817", "LastEditDate": "2017-01-17T10:57:49.817", "ViewCount": "5449", "FavoriteCount": "1", "Title": "\"Invalid covariant return type\" errors in nested classes with methods returning template-based objects", "Id": "17254381", "Score": "4", "Body": "<p>The following C++ code gives me these errors when compiled:</p>\n<pre><code>covariant.cpp:32:22: error: invalid covariant return type for \u2018virtual Q&lt;B&gt; C::test()\u2019\ncovariant.cpp:22:22: error:   overriding \u2018virtual Q&lt;A&gt; B::test()\u2019\n</code></pre>\n<p>I do not want to change the line <code>virtual Q&lt;B&gt; test() {}</code> to <code>virtual Q&lt;A&gt; test() {}</code> although it removes the compilation errors. Is there another way to solve this problem?</p>\n<pre><code>template &lt;class T&gt;\nclass Q\n{\n    public:\n        Q() {}\n        virtual ~Q() {}\n};\n\nclass A\n{\n    public:\n        A() {}\n        virtual ~A() {}    \n};\n\nclass B\n{\n    public:\n        B() {}\n        virtual ~B() {}\n\n        virtual Q&lt;A&gt; test() = 0;\n\n};\n\nclass C : public B\n{\n    public:\n        C() {}\n        virtual ~C() {}\n\n        virtual Q&lt;B&gt; test() {}\n};\n</code></pre>\n", "Tags": "<c++><class><templates><nested><covariant>", "OwnerUserId": "1385360", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_17254381_17254443_0": {"section_id": 7008, "quality": 0.92, "length": 23}}, "n3337": {"so_17254381_17254443_0": {"section_id": 6754, "quality": 0.92, "length": 23}}, "n4659": {"so_17254381_17254443_0": {"section_id": 8505, "quality": 0.92, "length": 23}}}, "17254451": {"ParentId": "17254381", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>Q&lt;B&gt;</code> and <code>Q&lt;A&gt;</code> are unrelated classes. Imagine you are a client of <code>B</code> calling <code>test()</code>: what do you assign the result to, if you do not know what type it is going to have?</p>\n<p>The fact that both <code>Q&lt;A&gt;</code> and <code>Q&lt;B&gt;</code> are instances of the same class template does not change the fact that they are two completely unrelated classes, possibly with a completely different layout (due to template specialization).</p>\n<p>This would not be any different from doing:</p>\n<pre><code>struct X\n{\n    virtual std::string test() = 0;\n};\n\nstruct Y : X\n{\n    virtual int test() { return 42; } // ERROR! std::string and int are\n                                      // unrelated, just as Q&lt;A&gt; and Q&lt;B&gt;\n};\n</code></pre>\n<p>The client calling <code>test()</code> on a pointer to <code>X</code> would expect the result to be a <code>string</code>, but \"Whoops!\", the object pointed to by that pointer is of type <code>Y</code>, and the return type of <code>Y::test()</code> is <code>int</code>. What should happen? A run-time crash?</p>\n<pre><code>Y y;\nX* p = &amp;y;\nstd::string s = p-&gt;test(); // D'OH!\n</code></pre>\n<p>C++ is a statically typed language, meaning that type checking is performed at compile-time. In this case, the message from the compiler is there to tell you that the derived class does not adhere to the interface of the class it derives from.</p>\n<p>If you are wondering what \"<em>invalid covariant return type</em>\" means, and in particular the word \"<em>covariant</em>\", that's easily explained.</p>\n<p>Suppose you have a base class <code>B</code> with a virtual function <code>foo()</code> that returns an <code>X*</code>:</p>\n<pre><code>struct B\n{\n    virtual X* foo();\n};\n</code></pre>\n<p>And suppose that you have a class <code>D</code> derived from <code>B</code> that overrides <code>foo()</code> by returning an <code>Y*</code>, where <code>Y</code> is a class derived from <code>X</code>:</p>\n<pre><code>struct D : B\n{\n    virtual Y* foo();\n};\n</code></pre>\n<p>Is this a problem? Well, the right answer comes from answering this slightly better question: \"<em>Would that be a problem for a client calling <code>foo()</code> that expects an <code>X*</code> to be returned?</em>\"</p>\n<p>And the answer to that question is obviously \"No\", since <code>Y</code> is a derived class of <code>X</code>, so you can return a pointer to <code>Y</code> instead of a pointer to <code>X</code>:</p>\n<pre><code>D d;\nB* b = &amp;d;\nX* p = b-&gt;foo(); // Returns an Y*, but that's OK, because a pointer to Y can be\n                 // assigned to a pointer to X\n</code></pre>\n<p>This is an example of a covariant return type. In your example, the return type of <code>C::test()</code>  is not covariant with respect to the return type of <code>B::test()</code>. </p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-06-22T19:31:58.277", "Id": "17254451", "Score": "5", "CreationDate": "2013-06-22T19:20:30.087", "LastActivityDate": "2013-06-22T19:31:58.277"}});