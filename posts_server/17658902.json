post_cb({"bq_ids": {"n4140": {"so_17658902_17659133_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6101}}, "n3337": {"so_17658902_17659133_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5867}}, "n4659": {"so_17658902_17659133_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7598}}}, "17658902": {"ViewCount": "516", "Body": "<p>Following on from this:  <a href=\"https://stackoverflow.com/q/17657761/14065\">Is the destructor called when a delegating constructor throws?</a></p>\n<pre><code>class X\n{\npublic:\n    X()       {};\n    X(int)    : X() { throw std::exception(); }\n    X(double)       { throw std::exception(); }\n    ~X();\n};\n</code></pre>\n<p>What about dynamic memory? Normally an exception in the constructor means the object was not fully constructed and thus the memory is cleanedup and not lost.</p>\n<p>But the argument in the previous question is that the object is fully constructed (or fully initialized) after the delegate completes. How does this affect reclaiming the memory? I would hope that memory is still cleanedup! </p>\n<pre><code>int main()\n{\n    new X(5);        // new called \n                     // delete called because delegate completed.\n                     // I assume:  \n                     //      Memory re-claimed (because constructor did not complete)\n                     //      I assume the C++11 standard adjusted to compensate.\n                     //      As a constructor did complete.\n}\n</code></pre>\n<p>Compared too:</p>\n<pre><code>int main()\n{\n    new X(5.0);      // new called \n                     //    Delete **NOT** called\n                     // Memory re-claimed (because constructor did not complete)\n}\n</code></pre>\n<p>If the memory is cleaned up, then the definition of when the memory is cleanup needs to be altered from C++03 spec. How is the behavior changed?</p>\n", "AcceptedAnswerId": "17659133", "Title": "Is the memory automatically reclaimed when a delegating constructor throws?", "CreationDate": "2013-07-15T16:16:44.187", "Id": "17658902", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:13:23.537", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-15T20:37:50.087", "Score": "14", "OwnerUserId": "14065", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "17659133": {"Id": "17659133", "PostTypeId": "2", "Body": "<p>If the constructor called by <code>new</code> throws an exception then the memory allocated by <code>new</code> is automatically deallocated. Delegating constructors change nothing in this regard.</p>\n<blockquote>\n<p id=\"so_17658902_17659133_0\">If any part of the object initialization described above<sup>76</sup> terminates by throwing an exception and a suitable deallocation function can be found, the deallocation function is called to free the memory in which the object was being constructed</p>\n<p id=\"so_17658902_17659133_1\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 C++11 [expr.new] 5.3.4/18</em></p>\n</blockquote>\n<p>The 'any part of the object initialization' described includes both the constructor calls and evaluation of the expressions passed to the constructor.</p>\n<p>Also, this behavior is specified identically in the C++98 standard [C++98 5.4.3/17]. The only difference delegating constructors make is if your mental model was previously based on the object being completely constructed or not. Given delegating constructors that's no longer equivalent to the actual specification of when deallocation occurs.</p>\n<hr>\n<p>In your first example:</p>\n<pre><code>new X(5);\n</code></pre>\n<p>The order of events is:</p>\n<ul>\n<li>allocation function called</li>\n<li>X(int) called</li>\n<li><ul>\n<li>X() called (and exits successfully)</li>\n</ul></li>\n<li><ul>\n<li>X(int) throws an exception</li>\n</ul></li>\n<li><ul>\n<li>~X() called</li>\n</ul></li>\n<li>X(int) exits via exception</li>\n<li>deallocation function called because object initialization failed</li>\n<li>exception continues to propagate normally</li>\n</ul>\n<p>With the second example</p>\n<pre><code>new X(5.0);\n</code></pre>\n<ul>\n<li>allocation function called</li>\n<li>X(double) called</li>\n<li>X(double) fails with an exception</li>\n<li>deallocation function called because object initialization failed</li>\n<li>exception continues to propagate normally</li>\n</ul>\n<p>You can observe this behavior by replacing the allocation and deallocation functions:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;stdexcept&gt;\n#include &lt;new&gt;\n\nvoid *operator new(std::size_t s) {\n    if (void *ptr = std::malloc(s)) {\n        std::cout &lt;&lt; \"allocation\\n\";\n        return ptr;\n    }\n    throw std::bad_alloc{};\n}\n\nvoid operator delete(void *ptr) noexcept {\n    if (ptr) {\n        std::cout &lt;&lt; \"deallocation\\n\";\n        std::free(ptr);\n    }\n}\n\nstruct S {\n    S() {};\n    S(int) : S{} { throw std::exception(); }\n    S(double) { throw std::exception(); }\n    ~S() { std::cout &lt;&lt; \"destructor\\n\"; }\n};\n\nint main() {\n    std::cout &lt;&lt; \"test 1\\n\";\n    try {\n        new S(1);\n    } catch(...) {\n        std::cout &lt;&lt; \"exception caught\\n\";\n    }\n\n    std::cout &lt;&lt; \"test 2\\n\";\n    try {\n        new S(1.);\n    } catch(...) {\n        std::cout &lt;&lt; \"exception caught\\n\";\n    }\n}\n</code></pre>\n<p>The correct output of this program is:</p>\n<pre><code>test 1\nallocation\ndestructor\ndeallocation\nexception caught\ntest 2\nallocation\ndeallocation\nexception caught\n</code></pre>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2013-07-15T20:37:50.087", "Score": "21", "CreationDate": "2013-07-15T16:29:32.727", "ParentId": "17658902", "CommentCount": "3", "OwnerUserId": "365496", "LastEditDate": "2013-07-15T20:37:50.087"}});