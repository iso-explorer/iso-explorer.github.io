post_cb({"27845967": {"ParentId": "27845061", "CommentCount": "0", "Body": "<p>In C++11 we don't have to define a constructor for a POD. We can use the new list-initialization syntax:</p>\n<pre><code>MyTest mt{1, 'c'};\nMyTest mt2 = {1, 'c'};\n</code></pre>\n<p>this is what's being called in your code.</p>\n", "OwnerUserId": "1312406", "PostTypeId": "2", "Id": "27845967", "Score": "0", "CreationDate": "2015-01-08T17:22:22.540", "LastActivityDate": "2015-01-08T17:22:22.540"}, "27845274": {"ParentId": "27845061", "CommentCount": "2", "Body": "<p>Well, first of you main function is wrong:</p>\n<pre><code>int main() {\n/* ... code ... here */\nreturn 0;\n}\n</code></pre>\n<p>Second, you need a object to initialize your struct:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    char _a;\n    int _b;\n};\n\nvoid print_them (const Foo&amp; foo) {\n    std::cout &lt;&lt; foo._a &lt;&lt; \", \" &lt;&lt; foo._b &lt;&lt; std::endl;\n}\n\nint main () {\n    /* create object and initialize it */\n    Foo f = {\n        'a', 7\n    };\n    /* call function */\n    print_them (f);\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "2030219", "PostTypeId": "2", "Id": "27845274", "Score": "-4", "CreationDate": "2015-01-08T16:46:26.550", "LastActivityDate": "2015-01-08T16:46:26.550"}, "27845484": {"ParentId": "27845061", "CommentCount": "0", "Body": "<p>This class is an <em>aggregate</em> - a simple structure containing public data members and no user-defined constructors and the like.</p>\n<p>List-initialisation is supported for aggregate types; the elements of the initialiser list are used to initialise each data member in turn. This has been supported for variable initialisation in both C and C++ for a very long time:</p>\n<pre><code>MyTest x = {1, 'c'};\n</code></pre>\n<p>and C++11 extended this to other uses of list-initialisation, including (in this case) initialising a temporary function argument.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "27845484", "Score": "7", "CreationDate": "2015-01-08T16:57:21.790", "LastActivityDate": "2015-01-08T16:57:21.790"}, "27845171": {"ParentId": "27845061", "LastEditDate": "2015-01-08T16:49:18.027", "CommentCount": "0", "CreationDate": "2015-01-08T16:40:50.583", "OwnerUserId": "1013719", "LastEditorUserId": "1013719", "PostTypeId": "2", "Id": "27845171", "Score": "3", "Body": "<p>list-initialization is occurring.  Since (as in C) you can initialize the type with</p>\n<pre><code>MyTest mt = {1, 'c'};\n</code></pre>\n<p>the same initialization takes place at the point of the call</p>\n<blockquote>\n<p id=\"so_27845061_27845171_0\">(N3690) 8.5/17 [...]</p>\n<p id=\"so_27845061_27845171_1\">-- If the initializer is a (non-parenthesized) braced-init-list, the object or reference is list-initialized</p>\n</blockquote>\n<p>8.5.4/3 gives the example:</p>\n<pre><code>struct S2 { // OK\n  int m1; \n  double m2, m3; \n}; \nS2 s21 = { 1, 2, 3.0 };  // OK\n</code></pre>\n<p>Calling the function with an initializer list behaves the same way.  Further:</p>\n<blockquote>\n<p id=\"so_27845061_27845171_2\">(8.5.1/1) An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3). When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order.</p>\n</blockquote>\n", "LastActivityDate": "2015-01-08T16:49:18.027"}, "27845061": {"CommentCount": "1", "ViewCount": "787", "CreationDate": "2015-01-08T16:35:20.837", "LastActivityDate": "2015-01-08T17:22:22.540", "Title": "c++ passing initializer list to function as parameters will construct an object?", "AcceptedAnswerId": "27845484", "PostTypeId": "1", "Id": "27845061", "Score": "2", "Body": "<p>Here is my code:</p>\n<pre><code>struct MyTest{\n    int a;\n    char b;\n};\nvoid testFunc(MyTest mt){\n    cout &lt;&lt; mt.a &lt;&lt; mt.b &lt;&lt; endl;\n}\nvoid main(){\n    testFunc({ 1, 'c' });\n}\n</code></pre>\n<p>It seems that <strong>mt will get constructed</strong> from the initializer_list and testFunc will output the right result. But how can it be since I didn't implement a constructor accepting an initializer_list at all.</p>\n", "Tags": "<c++>", "OwnerUserId": "1900516", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_27845061_27845171_1": {"section_id": 3296, "quality": 1.0, "length": 6}}, "n3337": {"so_27845061_27845171_1": {"section_id": 3166, "quality": 1.0, "length": 6}}, "n4659": {"so_27845061_27845171_1": {"section_id": 4058, "quality": 1.0, "length": 6}}}});