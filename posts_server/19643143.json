post_cb({"19643378": {"ParentId": "19643143", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have a few options:</p>\n<p>1) add a constructor to initialize the vectors to size 3:</p>\n<pre><code>struct body \n{\n  body() : p(3), v(3) {}\n  string name; \n  float m; \n  vector&lt; float &gt; p; \n  vector&lt; float &gt; v;\n};\n</code></pre>\n<p>2) initialize the variables at the point of declaration (C++11)</p>\n<pre><code>struct body \n{\n  string name; \n  float m; \n  vector&lt; float &gt; p = vector&lt;float&gt;(3); \n  vector&lt; float &gt; v = vector&lt;float&gt;(3);\n};\n</code></pre>\n<p>3) Use <code>std::array&lt;float, 3&gt;</code> instead of vectors</p>\n<pre><code>struct body \n{\n  body() : p(3), v(3) {}\n  string name; \n  float m; \n  std::array&lt;float, 3&gt; p; \n  std::array&lt;float, 3&gt; v;\n};\n</code></pre>\n<p>3) Use brace initialization to instantiate the struct.</p>\n<pre><code>body b1 {\"hello\", 3.14, vector(3,0), vector(3,0) };\n</code></pre>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2013-10-28T19:30:53.977", "Id": "19643378", "Score": "1", "CreationDate": "2013-10-28T19:24:49.747", "LastActivityDate": "2013-10-28T19:30:53.977"}, "19643349": {"ParentId": "19643143", "CommentCount": "0", "Body": "<p>You call the vector constructor inside your constructor.</p>\n<pre><code>struct body {\n    string name; \n    float m; \n    vector&lt; float &gt; p; \n    vector&lt; float &gt; v;\n\n    body(): p(3,0), v(3,0) {}\n};\n</code></pre>\n", "OwnerUserId": "14065", "PostTypeId": "2", "Id": "19643349", "Score": "1", "CreationDate": "2013-10-28T19:23:18.950", "LastActivityDate": "2013-10-28T19:23:18.950"}, "19643369": {"ParentId": "19643143", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You can specify the size for the vector in the constructor for your <code>body</code>:</p>\n<pre><code>struct body {\n    string name; \n    float m; \n    vector&lt; float &gt; p; \n    vector&lt; float &gt; v;\n\n     body() : p(3), v(3) {}\n};\n</code></pre>\n<p>C++11 allows you to specify constructor arguments \"in place\", so something like:</p>\n<pre><code>struct body {\n    string name; \n    float m; \n    vector&lt; float &gt; p{3}; \n    vector&lt; float &gt; v{3};\n};\n</code></pre>\n<p>...is allowed, but it sounds like your compiler doesn't support that (maybe time for an update?)</p>\n<p>Edit: doing a bit of checking, it appears that not all compilers select the correct constructor when given the second piece of code. For example, given the code above, VC++ gives a vector containing 3 0's, but g++ gives a vector containing a single value of 3. In other words, g++ is using the overload that takes an initializer list, but VC++ is using the overload that takes one parameter.</p>\n<p>For whatever it's worth, it appears that g++ is doing this correctly, and VC++ is incorrect<sup>1</sup>, but from a practical viewpoint it's of little consequence: code that uses it isn't portable, so most people probably want to avoid it (at least until the compiler vendors get their acts together).</p>\n<hr>\n<ol>\n<li><p>The specific wording is at $13.3.1.7:</p>\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the argument list consists of the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</li>\n</ul></li>\n</ol>\n<p><code>std::vector</code> has an intializer-list constructor, leaving on the question of whether it's viable. That comes down to the question of whether converting <code>3</code> to a <code>float</code> is a \"narrowing conversion\". In this case, the answer is no, it's not. The official wording is (\u00a78.5.4/7):</p>\n<blockquote>\n<p id=\"so_19643143_19643369_0\">A narrowing conversion is an implicit conversion</p>\n<p id=\"so_19643143_19643369_1\">[ ... ]</p>\n<p id=\"so_19643143_19643369_2\">from an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type,</p>\n</blockquote>\n<p>So, since we're using a constant expression with the value <code>3</code>, and <code>float</code> is guaranteed to be able to hold that value, and produce <code>3</code> as the result if we convert it back to <code>int</code>, it's <em>not</em> a narrowing conversion. That means the initializer-list constructor is viable, so it's the one that should be chosen.</p>\n<p>In theory, if you want to do the in-place initialization, you should probably use:</p>\n<pre><code>std::vector&lt;float&gt; p{0, 0, 0};\n</code></pre>\n<p>...MS VC++, however, rejects this, reinforcing the previous advice that if you care about portability, you probably want to avoid this in general.</p>\n</hr>", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2013-10-28T20:25:48.453", "Id": "19643369", "Score": "1", "CreationDate": "2013-10-28T19:24:14.777", "LastActivityDate": "2013-10-28T20:25:48.453"}, "bq_ids": {"n4140": {"so_19643143_19643369_2": {"section_id": 3329, "quality": 1.0, "length": 30}}, "n3337": {"so_19643143_19643369_2": {"section_id": 3199, "quality": 1.0, "length": 30}}, "n4659": {"so_19643143_19643369_2": {"section_id": 4095, "quality": 1.0, "length": 30}}}, "19643143": {"CommentCount": "4", "ViewCount": "836", "PostTypeId": "1", "LastEditorUserId": "250168", "CreationDate": "2013-10-28T19:10:34.683", "LastActivityDate": "2013-10-28T20:25:48.453", "Title": "Defining the length of a vector within a struct", "LastEditDate": "2013-10-28T19:23:12.790", "Id": "19643143", "Score": "0", "Body": "<p>The struct I want to use is defined below. (I am using <code>namespace std</code>):</p>\n<pre><code>struct body {string name; float m; vector&lt; float &gt; p; vector&lt; float &gt; v;};\n</code></pre>\n<p>This compiles, but later I get a segmentation fault at run time. I know this is because the vectors don't have a defined size (I want three components). </p>\n<p>I have tried using the a vector constructor <code>vector x(3,0)</code>, but this won't compile. I get: </p>\n<pre><code>glib.h(5): error: expected a type specifier\n  struct body {string name; float m; vector&lt;float&gt; p (3,0); vector&lt;float&gt; v(3,0);};\n                                                      ^\n\nglib.h(5): error: expected a type specifier\n  struct body {string name; float m; vector&lt;float&gt; p (3,0); vector&lt;float&gt; v(3,0);};\n                                                        ^\n\nglib.h(5): error: expected a type specifier\n  struct body {string name; float m; vector&lt;float&gt; p (3,0); vector&lt;float&gt; v(3,0);};\n                                                                            ^\n\nglib.h(5): error: expected a type specifier\n  struct body {string name; float m; vector&lt;float&gt; p (3,0); vector&lt;float&gt; v(3,0);};\n</code></pre>\n<p>Basically, I need to allocate space for a vector of 3 elements when I define the struct, and I do not know how to do this. I am a C++ beginner and have done a lot of research, but I cannot find an answer. Thanks for any help I can get.</p>\n", "Tags": "<c++><vector><struct><std>", "OwnerUserId": "2929341", "AnswerCount": "3"}});