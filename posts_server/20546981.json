post_cb({"20547177": {"ParentId": "20546981", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As <a href=\"https://groups.google.com/d/msg/comp.lang.c++/nSlM8t2bUd0/h4I3x6kuMK4J\" rel=\"nofollow\">Bjarne Stroustrup (the original designer) explained it</a> in a clc++ posting in 2005, it was for uniform rules.</p>\n<blockquote>\n<p id=\"so_20546981_20547177_0\">The rules for references are simply the most general and uniform I\n  could find. In the cases of arguments and local references, the\n  temporary lives as long as the reference to which it is bound. One\n  obvious use is as a shorthand for a complicated expression in a\n  deeply nested loop. For example:</p>\n<pre><code>for (int i = 0; i&lt;xmax; ++i)\n    for (int j = 0; j&lt; ymax; ++j) { \n        double&amp; r = a[i][j]; \n        for (int k = 0; k &lt; zmax; ++k) { \n           // do something with a[i][j] and a[i][j][k] \n        }\n    } \n</code></pre>\n<p id=\"so_20546981_20547177_1\">This can improve readability as well as run-time performance.</p>\n</blockquote>\n<p>And it turned out to be useful for storing an object of a class derived from the reference type, e.g. as in <a href=\"http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758\" rel=\"nofollow\">the original Scopeguard implementation</a>.</p>\n<hr>\n<p>In <a href=\"https://groups.google.com/d/msg/comp.lang.c++/P23XtGgxLP8/G9fbld70_nwJ\" rel=\"nofollow\">a clc++ posting in 2008</a>, James Kanze supplied some more details:</p>\n<blockquote>\n<p id=\"so_20546981_20547177_2\">The standard says exactly when the destructor must be called.  Before\n  the standard, however, the ARM (and earlier language specifications)\n  were considerably looser: the destructor could be called anytime after\n  the temporary was \"used\" and before the next closing brace.</p>\n</blockquote>\n<p>(The \u201cARM\u201d is the Annotated Reference Manual by (IIRC) Bjarne Stroustrup and Margareth Ellis, which served as a <i>de-facto</i> standard in the last decade before the first ISO standard. Unfortunately my copy is buried in a box, under a lot of other boxes, in the outhouse. So I can't verify, but I believe this is correct.)</p>\n<p>Thus, as with much else the details of lifetime extensions were honed and perfected in the standardization process.</p>\n<p>Since James has raised this point in comments to this answer: that perfection could not reach back in time to affect Bjarne's rationale for the lifetime extension.</p>\n<hr>\n<p>Example of Scopeguard-like code, where the temporary bound to the reference is the full object of derived type, with its derived type destructor executed at the end:</p>\n<pre><code>struct Base {};\n\ntemplate&lt; class T &gt;\nstruct Derived: Base {};\n\ntemplate&lt; class T &gt;\nauto foo( T ) -&gt; Derived&lt;T&gt; { return Derived&lt;T&gt;(); }\n\nint main()\n{\n    Base const&amp; guard = foo( 42 );\n}\n</code></pre>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2013-12-14T03:32:27.817", "Id": "20547177", "Score": "8", "CreationDate": "2013-12-12T15:13:29.103", "LastActivityDate": "2013-12-14T03:32:27.817"}, "20547296": {"ParentId": "20546981", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The simple answer is that you need to be able to bind a temporary with a const reference, not having that feature would require a good amount of code duplication, with functions taking <code>const&amp;</code> for lvalue or value arguments or by-value for rvalue arguments. \nOnce you need that the language needs to define some semantics that will guarantee the lifetime of the temporary is at least as long as that of the reference.</p>\n<p>Once you accept that a reference can bind to an rvalue in one context, just for consistency you may want to extend the rule to allow the same binding in other contexts, and the semantics are really the same. The temporary lifetime is extended until the reference goes away (be it a function parameter, or a local variable).</p>\n<p>The alternative would be rules that allow binding in some contexts (function call) but not all (local reference) or rules that allow both and always create a dangling reference in the latter case.</p>\n<hr>\n<p>Removed the quote from the answer, left here so that comments would still make sense:</p>\n<p><strike>If you look at the wording in the standard there are some hints as of this intended usage:</strike></p>\n<blockquote>\n<p id=\"so_20546981_20547296_0\">12.2/5 [middle of the paragraph]\n  [...] A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call. [...]\n  </p></blockquote></hr>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2013-12-12T17:34:05.557", "Id": "20547296", "Score": "14", "CreationDate": "2013-12-12T15:19:48.883", "LastActivityDate": "2013-12-12T17:34:05.557"}, "bq_ids": {"n4140": {"so_20546981_20547296_0": {"section_id": 382, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_20546981_20547296_0": {"section_id": 373, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_20546981_20547296_0": {"section_id": 397, "quality": 0.6470588235294118, "length": 11}}}, "24895239": {"ParentId": "20546981", "CommentCount": "0", "Body": "<p>I discovered an interesting application for lifetime extension somewhere here on SO. (I forget where, I'll add a reference when I find it.)</p>\n<p>Lifetime extension allows us to use prvalues of immobile types.</p>\n<p>For example:</p>\n<pre><code>struct Foo\n{\n    Foo(int, bool, char);\n    Foo(Foo &amp;&amp;) = delete;\n};\n</code></pre>\n<p>The type <code>Foo</code> cannot be copied nor moved. Yet, we can have a function that returns a prvalue of type <code>Foo</code>:</p>\n<pre><code>Foo make_foo()\n{\n    return {10, false, 'x'};\n}\n</code></pre>\n<p>Yet we cannot construct a local variable initialized with the return value of <code>make_foo</code>, so in general, calling the function will create a temporary object that is immediately destroyed. Lifetime extension allows us to use the temporary object throughout an entire scope:</p>\n<pre><code>auto &amp;&amp; foo = make_foo();\n</code></pre>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "24895239", "Score": "2", "CreationDate": "2014-07-22T18:41:16.910", "LastActivityDate": "2014-07-22T18:41:16.910"}, "20546981": {"CommentCount": "21", "ViewCount": "381", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-12-12T15:05:02.633", "LastActivityDate": "2014-07-22T18:41:16.910", "Title": "What is the rationale for extending the lifetime of temporaries?", "FavoriteCount": "6", "LastEditDate": "2017-05-23T10:30:59.773", "Id": "20546981", "Score": "16", "Body": "<p>In C++, the lifetime of a temporary value can be extended by binding it to a reference:</p>\n<pre><code>Foo make_foo();\n\n{\n    Foo const &amp; r1 = make_foo();\n    Foo &amp;&amp; r2 = make_foo();\n\n    // ...\n}             // both objects are destroyed here\n</code></pre>\n<p>Why is this allowed? What problem does this solve?</p>\n<p>I couldn't find an explanation for this in <em>Design and Evolution</em> (e.g. 6.3.2: Lifetime of Temporaries). Nor could I find any previous questions about this (<a href=\"https://stackoverflow.com/q/4670137/596781\">this one</a> came closest).</p>\n<p>This feature is somewhat unintuitive and has subtle failure modes. For example:</p>\n<pre><code>Foo const &amp; id(Foo const &amp; x) { return x; }  // looks like a fine function...\n\nFoo const &amp; r3 = id(make_foo());             // ... but causes a terrible error!\n</code></pre>\n<p>Why is something that can be so easily and silently abused part of the language?</p>\n<hr>\n<p><strong>Update:</strong> the point may be subtle enough to warrant some clarification: I do not dispute the use of the rule that \"references bind to temporaries\". That is all fine and well, and allows us to use implicit con\u00adver\u00adsions when binding to references. What I am asking about is why the <em>lifetime</em> of the temporary is affected. To play the devil's advocate, I could claim that the existing rules of \"lifetime until end of full expression\" already cover the common use cases of calling functions with temporary arguments.</p>\n</hr>", "Tags": "<c++><language-design>", "OwnerUserId": "596781", "AnswerCount": "3"}});