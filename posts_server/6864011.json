post_cb({"bq_ids": {"n4140": {"so_6864011_6864720_1": {"length": 18, "quality": 1.0, "section_id": 6909}, "so_6864011_6864720_2": {"length": 15, "quality": 0.75, "section_id": 3340}, "so_6864011_6864139_0": {"length": 33, "quality": 0.6346153846153846, "section_id": 3344}, "so_6864011_6864139_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3367}}, "n3337": {"so_6864011_6864720_1": {"length": 18, "quality": 1.0, "section_id": 6655}, "so_6864011_6864720_2": {"length": 19, "quality": 0.95, "section_id": 3210}, "so_6864011_6864139_0": {"length": 33, "quality": 0.6346153846153846, "section_id": 3214}, "so_6864011_6864139_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3237}}, "n4659": {"so_6864011_6864720_1": {"length": 18, "quality": 1.0, "section_id": 8407}, "so_6864011_6864720_2": {"length": 14, "quality": 0.7, "section_id": 4142}, "so_6864011_6864139_1": {"length": 13, "quality": 0.5652173913043478, "section_id": 4132}}}, "6864011": {"ViewCount": "3107", "Body": "<p><code>std::exception</code> requires that its constructor be <code>throw()</code>. Yet <code>std::runtime_error</code> accepts a <code>std::string</code> as its argument, which indicates that it's storing a <code>std::string</code> somewhere. Therefore, an assignment or copy construction has to be going on somewhere. And for <code>std::string</code>, that's not a <code>nothrow</code> operation.</p>\n<p>How then does <code>runtime_error::runtime_error</code> meet <code>throw()</code>?</p>\n<p>(For context, I'm implementing an exception type, and want to store a few <code>std::string</code>s from the call site, and I want to do it correctly...)</p>\n", "AcceptedAnswerId": "6864139", "Title": "How can std::runtime_error::runtime_error(const std::string&) meet std::exception's requirement of throw()?", "CreationDate": "2011-07-28T18:40:53.330", "Id": "6864011", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-07-28T19:32:43.447", "LastEditorUserId": "1737", "LastActivityDate": "2015-05-20T09:10:09.377", "Score": "16", "OwnerUserId": "82320", "Tags": "<c++><exception-specification>", "AnswerCount": "2"}, "6864139": {"Id": "6864139", "PostTypeId": "2", "Body": "<p><sub>(<a href=\"http://codepad.org/EcX0Yaqf\" rel=\"noreferrer\">Here's</a> the same thing in a minimal-ish testcase.)</sub></p>\n<hr>\n<p><code>runtime_error::runtime_error(string const&amp;)</code> doesn't need to meet <code>throw()</code>.</p>\n<p>It doesn't inherit from or override <code>exception::exception()</code>, and by the time <code>string</code>'s copy constructor is invoked, <code>exception::exception()</code> has completed.</p>\n<p>If copying the <code>string</code> were to throw an exception, this would unwind <code>runtime_error::runtime_error(string const&amp;)</code> and then, I suppose, invoke <code>exception::~exception()</code>.</p>\n<hr>\n<p>It's hard to directly show that there is no requirement of a derived ctor to meet a base ctor's exception specifier, but it is strongly implied by the following passage (which describes how the base's destructor is invoked, rather than passing the exception into the base constructor):</p>\n<blockquote>\n<p id=\"so_6864011_6864139_0\"><code>[2003: 15.2/2]</code> <strong>An object that is partially constructed or\n  partially destroyed will have destructors executed for all of its\n  fully constructed subobjects, that is, for subobjects for which the\n  constructor has completed execution and the destructor has not yet\n  begun execution.</strong> Should a constructor for an element of an automatic\n  array throw an exception, only the constructed elements of that array\n  will be destroyed. If the object or array was allocated in a\n  new-expression, the matching deallocation function (3.7.3.2, 5.3.4,\n  12.5), if any, is called to free the storage occupied by the object.</p>\n</blockquote>\n<p>The only passage which comes even close to the scenario you presumed (and which I initially presumed) is the following.</p>\n<blockquote>\n<p id=\"so_6864011_6864139_1\"><code>[2003: 15.4/3]</code> If a virtual function has an exception-specification,\n  all declarations, including the definition, of any function that\n  overrides that virtual function in any derived class shall only allow\n  exceptions that are allowed by the exception-specification of the base\n  class virtual function.</p>\n</blockquote>\n<p>But clearly <code>exception::exception()</code> is not a virtual function, and clearly <code>runtime_error::runtime_error(string const&amp;)</code> does not override it.</p>\n<p>(Note that this scenario <em>would</em> apply for a virtual destructor; accordingly, <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.6.0/libstdc++/api/a01044_source.html\" rel=\"noreferrer\">you can see that, in libstdc++, <code>runtime_error::~runtime_error()</code> is <code>throw()</code></a>).</p>\n</hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-07-28T19:31:22.987", "Score": "9", "CreationDate": "2011-07-28T18:50:58.733", "ParentId": "6864011", "CommentCount": "11", "LastEditDate": "2011-07-28T19:31:22.987", "OwnerUserId": "560648"}, "6864720": {"Id": "6864720", "PostTypeId": "2", "Body": "<h3>Update, 2015:</h3>\n<blockquote>\n<p id=\"so_6864011_6864720_0\">Yet <code>std::runtime_error</code> accepts a <code>std::string</code> as its argument, which indicates that it's storing a <code>std::string</code> somewhere. Therefore, an assignment or copy construction has to be going on somewhere. And for <code>std::string</code>, that's not a <code>noexcept</code> operation.</p>\n</blockquote>\n<p><code>runtime_error</code> (and <code>logic_error</code>) are only required to accept an argument of type <code>std::string const &amp;</code>. <em>They are not required to copy it.</em></p>\n<p>Use these overloads at your own peril. LLVM libc++ does not provide storage.</p>\n<p>On the other hand, GNU libstdc++ tiptoes carefully to avoid running out of memory. It copies the contents of the string, but into the exception storage space, not into a new <code>std::string</code>.</p>\n<p>Even then, it adds an <code>std::string&amp;&amp;</code> overload and uses <code>friend</code>ship to adopt the internal buffer of a <code>std::string</code> argument passed by rvalue, to conserve exception storage space too.</p>\n<p>So that's your real answer: \"Very carefully, if at all.\"</p>\n<p>You could leverage GCC's generosity by using <code>std::runtime_error</code>s as members of your own exception class, storing one string each. This would still be useless on Clang, though.</p>\n<p><br/></p>\n<h3>Original answer, 2011. This is still true:</h3>\n<p>An exception during stack unwinding causes <code>terminate</code> to be called.</p>\n<p>But constructing the object to be thrown is not part of unwinding, and is treated no differently from the code before the <code>throw</code> expression.</p>\n<p>If <code>std::runtime_error::runtime_error( std::string const &amp; )</code> throws <code>std::bad_alloc</code>, the <code>runtime_error</code> exception is lost (it never existed) and the <code>bad_alloc</code> is handled instead.</p>\n<p>Demonstration: <a href=\"http://ideone.com/QYPj3\" rel=\"nofollow\">http://ideone.com/QYPj3</a></p>\n<p>As for your own class storing <code>std::string</code>s from the call site, you'll want to follow \u00a718.8.1/2:</p>\n<blockquote>\n<p id=\"so_6864011_6864720_1\">Each standard library class T that derives from class exception shall have a publicly accessible copy constructor and a publicly accessible copy assignment operator that do not exit with an exception.</p>\n</blockquote>\n<p>This is required because copying from the stack to the thread's exception storage <em>is</em> sensitive to exceptions. \u00a715.1/7:</p>\n<blockquote>\n<p id=\"so_6864011_6864720_2\">If the exception handling mechanism, after completing evaluation of the expression to be thrown but before the exception is caught, calls a function that exits via an exception, std::terminate is called (15.5.1).</p>\n</blockquote>\n<p>So, you should use a <code>shared_ptr&lt; std::string &gt;</code> or some such to sanitize copies <em>after</em> the first.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2015-05-20T09:10:09.377", "Score": "5", "CreationDate": "2011-07-28T19:44:57.740", "ParentId": "6864011", "CommentCount": "0", "LastEditDate": "2015-05-20T09:10:09.377", "OwnerUserId": "153285"}});