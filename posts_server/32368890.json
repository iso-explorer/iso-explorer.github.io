post_cb({"32369797": {"Id": "32369797", "PostTypeId": "2", "Body": "<p>Your version of exp which prints rvalues is incorrect.\nIt should be:</p>\n<pre><code>template &lt;typename T&gt;\nvoid exp(T&amp;&amp; a, T&amp;&amp; b)\n{\n  cout &lt;&lt; \"rvalues\" &lt;&lt; endl;\n}\n</code></pre>\n<p>If you call foo(a, b) the compiler could have chosen to copy a and b and call your rvalues version when in fact they are not rvalues.\nThat is why you received the compilation error.</p>\n<p>If you really want to see if the argument is an rvalue you can use is_rvalue_reference:</p>\n<pre><code>template &lt;typename T&gt;\nvoid exp(T&amp;&amp; a, T&amp;&amp; b)\n{\n  std::cout &lt;&lt; \"rvalues: \" &lt;&lt; std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>If you want one function for rvalues and one for lvalues then you can use enable_if:</p>\n<pre><code>template &lt;typename T&gt;\ntypename std::enable_if&lt;std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value, void&gt;::type exp(T&amp;&amp; a, T&amp;&amp; b)\n{\n  std::cout &lt;&lt; \"rvalues\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;typename T&gt;\ntypename std::enable_if&lt;!std::is_rvalue_reference&lt;T&amp;&gt;::value, void&gt;::type exp(T&amp; a, T&amp; b)\n{\n  std::cout &lt;&lt; \"lvalues\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>You might need to include the type_traits header file.</p>\n", "LastEditorUserId": "682537", "LastActivityDate": "2015-09-03T14:26:41.463", "Score": "0", "CreationDate": "2015-09-03T07:45:24.680", "ParentId": "32368890", "CommentCount": "4", "OwnerUserId": "682537", "LastEditDate": "2015-09-03T14:26:41.463"}, "bq_ids": {"n4140": {"so_32368890_32371173_4": {"length": 21, "quality": 1.0, "section_id": 328}, "so_32368890_32371173_1": {"length": 10, "quality": 1.0, "section_id": 324}, "so_32368890_32371173_5": {"length": 17, "quality": 1.0, "section_id": 328}, "so_32368890_32371173_3": {"length": 5, "quality": 1.0, "section_id": 324}, "so_32368890_32371173_2": {"length": 5, "quality": 1.0, "section_id": 324}, "so_32368890_32371173_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 625}}, "n3337": {"so_32368890_32371173_4": {"length": 21, "quality": 1.0, "section_id": 318}, "so_32368890_32371173_1": {"length": 10, "quality": 1.0, "section_id": 314}, "so_32368890_32371173_5": {"length": 17, "quality": 1.0, "section_id": 318}, "so_32368890_32371173_3": {"length": 5, "quality": 1.0, "section_id": 314}, "so_32368890_32371173_2": {"length": 5, "quality": 1.0, "section_id": 314}, "so_32368890_32371173_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 615}}, "n4659": {"so_32368890_32371173_4": {"length": 21, "quality": 1.0, "section_id": 336}, "so_32368890_32371173_1": {"length": 10, "quality": 1.0, "section_id": 332}, "so_32368890_32371173_5": {"length": 13, "quality": 0.7647058823529411, "section_id": 336}, "so_32368890_32371173_3": {"length": 5, "quality": 1.0, "section_id": 332}, "so_32368890_32371173_2": {"length": 5, "quality": 1.0, "section_id": 332}, "so_32368890_32371173_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 651}}}, "32371173": {"Id": "32371173", "PostTypeId": "2", "Body": "<p>Both reference binding and an lvalue-to-rvalue conversion are given an exact match rank:</p>\n<p>\u00a7 13.3.3.1.4 [over.ics.ref]/p1:</p>\n<blockquote>\n<p id=\"so_32368890_32371173_0\">When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion sequence is the <strong>identity conversion.</strong></p>\n</blockquote>\n<p>Thus, the compiler can't choose between the two on the basis of better conversion sequence selection, and tries to partially order the two overloads of <code>exp</code> (because the more specialized function templates take precedence in overload resolution). However:</p>\n<p>\u00a7 14.8.2.4 [temp.deduct.partial]/p5:</p>\n<blockquote>\n<p id=\"so_32368890_32371173_1\">Before the partial ordering is done, certain transformations are performed on the types used for partial ordering:</p>\n<p id=\"so_32368890_32371173_2\">\u2014 If <code>P</code> is a reference type, <code>P</code> is replaced by the type referred to.</p>\n<p id=\"so_32368890_32371173_3\">\u2014 If <code>A</code> is a reference type, <code>A</code> is replaced by the type referred to.</p>\n</blockquote>\n<p>This makes the two overloads indistinguishable, since neither is more specialized, as from the partial ordering point of view they look the same, and no other exception applies.</p>\n<p>If your primary goal is to have one overload for rvalues and another for lvalues, you can define them as follows:</p>\n<pre><code>template &lt;typename T&gt;\nvoid exp(T&amp;&amp; a, T&amp;&amp; b) {}\n\ntemplate &lt;typename T&gt;\nvoid exp(T&amp; a, T&amp; b) {}\n</code></pre>\n<p>Now, although <code>exp(T&amp;&amp; a, T&amp;&amp; b)</code> is viable for lvalues as well, the other overload is deemed <em>more specialized</em>:</p>\n<p>\u00a7 14.8.2.4 [temp.deduct.partial]/p9:</p>\n<blockquote>\n<p id=\"so_32368890_32371173_4\">If, for a given type, deduction succeeds in both directions (i.e., the types are identical after the transformations above) and <strong>both <code>P</code> and <code>A</code> were reference types</strong> (before being replaced with the type referred to above):</p>\n<p id=\"so_32368890_32371173_5\">\u2014 if the type from the argument template was an lvalue reference and the type from the parameter\n  template was not, the argument type is considered to be more specialized than the other; otherwise [...]</p>\n</blockquote>\n<p>which makes <code>exp(T&amp; a, T&amp; b)</code> to be the preffered one for lvalues, and <code>exp(T&amp;&amp; a, T&amp;&amp; b)</code> the only viable for rvalues in turn.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/831fb03df4313e15\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-09-03T09:08:27.860", "Score": "3", "CreationDate": "2015-09-03T08:55:49.000", "ParentId": "32368890", "CommentCount": "5", "OwnerUserId": "3953764", "LastEditDate": "2015-09-03T09:08:27.860"}, "32368890": {"ViewCount": "123", "Body": "<p>Yesterday I asked <a href=\"https://stackoverflow.com/questions/32349944/move-and-forward-cases-use\">a question about when to use <code>std::forward</code> and when to use <code>std::move</code></a></p>\n<p>Today I was trying to apply what I think I learned. I wrote the following:</p>\n<pre><code>template &lt;typename T&gt;\nvoid exp(T a, T b)\n{\n  cout &lt;&lt; \"rvalues\" &lt;&lt; endl;\n}\n\ntemplate &lt;typename T&gt;\nvoid exp(T&amp; a, T&amp; b)\n{\n  cout &lt;&lt; \"lvalues\" &lt;&lt; endl;\n}\n\ntemplate &lt;typename T&gt;\nvoid foo(T&amp;&amp; a, T&amp;&amp; b)\n{\n  exp(forward&lt;T&gt;(a), forward&lt;T&gt;(b));\n}\n</code></pre>\n<p>When in the <code>main</code> I call <code>foo(4, 5)</code> it prints out <code>\"rvalue\"</code>, as I would expect, but when I do something like</p>\n<pre><code>int a = 0, b = 0;\nfoo(a, b);\n</code></pre>\n<p>an error occurs that says: <code>'exp' : ambiguous call to overloaded function</code></p>\n<p>What am I missing here? Why the last call to <code>foo(a, b)</code> doesn't call the <code>void exp(T&amp; a, T&amp; b)</code> function?</p>\n", "AcceptedAnswerId": "32371173", "Title": "Calling function based on the value categories of its arguments", "CreationDate": "2015-09-03T06:56:40.743", "Id": "32368890", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:10:15.027", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-03T14:26:41.463", "Score": "3", "OwnerUserId": "1492438", "Tags": "<c++><c++11>", "AnswerCount": "2"}});