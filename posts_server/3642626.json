post_cb({"3642770": {"Id": "3642770", "PostTypeId": "2", "Body": "<p>In that situation, <code>const_cast</code> will have exactly the same effect as a C cast. Both will give a non-const pointer to a constant object, and in both cases trying to modify the object will give undefined behaviour.</p>\n<p>Any conversion can be made using some combination of C++ casts, but there are some cases where a C cast can make a conversion that no <em>single</em> C++ cast can. For example, <code>reinterpret_cast</code> can't remove <code>const</code> or <code>volatile</code> qualifications, and <code>const_cast</code> can't convert between two unrelated pointer types; but a C cast can do both at once:</p>\n<pre><code>class A;\nclass B;\n\nA const* a = 0;\nB* b;\n\nb = reinterpret_cast&lt;B*&gt;(a); // fail: can't remove const\nb = const_cast&lt;B*&gt;(a); // fail: can't convert between pointer types\nb = reinterpret_cast&lt;B*&gt;(const_cast&lt;A*&gt;(a)); // OK\nb = (B*)a; // OK\n</code></pre>\n<p>I would still prefer to see the the two casts in this case, at the cost of extra typing; it makes it clear that something freaky is going down, and uses a syntax that can be searched for. In my opinion, C casts should never be used for anything.</p>\n", "LastActivityDate": "2010-09-04T15:00:10.750", "CommentCount": "4", "CreationDate": "2010-09-04T15:00:10.750", "ParentId": "3642626", "Score": "4", "OwnerUserId": "204847"}, "3642778": {"Id": "3642778", "PostTypeId": "2", "Body": "<p>In C++, the old-style casts are defined in terms of the new-style casts.  </p>\n<p>5.4: </p>\n<blockquote>\n<p id=\"so_3642626_3642778_0\">4 Any type conversion not mentioned\n  below and not explicitly defined by\n  the user (12.3) is ill-formed.</p>\n<p id=\"so_3642626_3642778_1\">5 The conversions performed by \n  \u2014 a const_cast (5.2.11), \n  \u2014 a static_cast (5.2.9), \n  \u2014 a static_cast followed by a\n  const_cast, \u2014 a reinterpret_cast\n  (5.2.10), or \u2014 a reinterpret_cast\n  followed by a const_cast, can be\n  performed using the cast notation of\n  explicit type conversion.</p>\n</blockquote>\n<p>The example you provided is covered quite cleanly by the first bullet.  Your comment at the end of the example is only half right.  You can <em>read</em> the result, but you can not <em>write</em> to it.  This is the same whether you use <code>const_cast</code> or not.  The underlying object does not lose its <code>const</code>-ness just because you cast it away.</p>\n<p>A few clauses later, a few situations in which a C-style cast behaves differently from a regular <code>static_cast</code> are listed.  But they have to do with casting along inheritances in which the base class is inaccessible.  The <code>virtual</code> in your example suggests that maybe there was some inheritance in the book's actual code; perhaps that is what he was trying to get at, and you misunderstood?</p>\n<p>For completeness:</p>\n<blockquote>\n<p id=\"so_3642626_3642778_2\">7  In addition to those conversions, the\n  following static_cast and\n  reinterpret_cast operations\n  (optionally followed by a const_cast\n  operation) may be performed using the\n  cast notation of explicit type\n  conversion, even if the base class\n  type is not accessible: </p>\n<p id=\"so_3642626_3642778_3\">\u2014 a pointer to\n  an object of derived class type or an\n  lvalue of derived class type may be\n  explicitly converted to a pointer or\n  reference to an unambiguous base class\n  type, respectively; </p>\n<p id=\"so_3642626_3642778_4\">\u2014 a pointer to\n  member of derived class type may be\n  explicitly converted to a pointer to\n  member of an unambiguous non-virtual\n  base class type; </p>\n<p id=\"so_3642626_3642778_5\">\u2014 a pointer to an\n  object of non-virtual base class type,\n  an lvalue of non-virtual base class\n  type, or a pointer to member of non-virtual base class type may be explicitly converted to a pointer, a reference, or a\n  pointer to member of a derived class type, respectively.</p>\n</blockquote>\n<p>As an example of what that last clause is talking about, here is something only possible with a C-style cast.</p>\n<pre><code>class Base { };\nclass Derived : Base { };\n\nDerived d;\nBase* pb;\npb = static_cast&lt;Base*&gt;(&amp;d); //inaccessible base\npb = (Base*)(&amp;d); //just fine\n</code></pre>\n<p>However, I am finding it hard to imagine a situation where this would not be a bad idea. For practical purposes, just assume C-style casts don't exist.</p>\n", "LastEditorUserId": "293791", "LastActivityDate": "2010-09-04T16:22:35.723", "Score": "2", "CreationDate": "2010-09-04T15:02:55.253", "ParentId": "3642626", "CommentCount": "1", "OwnerUserId": "293791", "LastEditDate": "2010-09-04T16:22:35.723"}, "3642626": {"ViewCount": "382", "Body": "<p>From the book Exceptional C++ Solution to ch. 44 I've learned that they are situations when none of the new cast styles would work properly. I always thought that they (those 4 new casts) cover every possible situation and there is no need for \"old\" style cast anymore, but it appears to be not true. So my question is:<br>\nAre those new casts cover all possible situations so there is no need to ever use c-style cast or:<br>\nThere are situation in which only the old cast works properly?<br>\nThanks.  </br></br></br></p>\n<p>That's appropriate fragment from this book:<br>\n\"</br></p>\n<pre><code>class  A { public: virtual ~A(); /*...*/ }; \nA::~A() { }\n\nclass B : private virtual A  { /*...*/ };\n\nclass C : public  A          { /*...*/ };\n\nclass D : public B, public C { /*...*/ };\n\nA a1; B b1; C c1; D d1;\nconst A  a2;\nconst A&amp; ra1 = a1;\nconst A&amp; ra2 = a2;\nchar c;\n\n\n    void f() \n{\n  A* pa; B* pb; C* pc;\n  pa = (A*)&amp;ra1;\n  pa = (A*)&amp;a2;&lt;&lt;----------This is the cast I'm interested in\n//This cannot be expressed as a new-style cast. The closest candidate is const_cast,  \n //but because a2 is a const object, the results of using the pointer are undefined.\n//Not my words those are words of Herb Sutter. (whose style of writing irritates me to bits)  \n  pb = (B*)&amp;c1;\n  pc = (C*)&amp;d1;\n}\n\n\n\n\"\n</code></pre>\n<p><strong>EDITED</strong> </p>\n<h2>Chapter 44 from Exceptional C++:</h2>\n<h3>\"Item 44. Casts</h3>\n<p>Difficulty: 6</p>\n<p>How well do you know C++'s casts? Using them well can greatly improve the reliability of your code.</p>\n<p>The new-style casts in standard C++ offer more power and safety than the old-style (C-style) casts. How well do you know them? The rest of this problem uses the following classes and global variables:</p>\n<pre><code>class  A { public: virtual ~A(); /*...*/ }; \nA::~A() { }\n\nclass B : private virtual A  { /*...*/ };\n\nclass C : public  A          { /*...*/ };\n\nclass D : public B, public C { /*...*/ };\n\nA a1; B b1; C c1; D d1;\nconst A  a2;\nconst A&amp; ra1 = a1;\nconst A&amp; ra2 = a2;\nchar c;\n</code></pre>\n<p>This Item presents four questions.</p>\n<p>Which of the following new-style casts are not equivalent to a C-style cast?</p>\n<ul>\n<li>const_cast </li>\n<li>dynamic_cast</li>\n<li>reinterpret_cast</li>\n<li>static_cast</li>\n</ul>\n<p>For each of the following C-style casts, write the equivalent new-style cast. Which are incorrect if not written as a new-style cast?</p>\n<pre><code>void f() \n{\n  A* pa; B* pb; C* pc;\n  pa = (A*)&amp;ra1;\n  pa = (A*)&amp;a2;\n  pb = (B*)&amp;c1;\n  pc = (C*)&amp;d1;\n}\n</code></pre>\n<p>Critique each of the following C++ casts for style and correctness.</p>\n<pre><code>void g() \n{\n  unsigned char* puc = static_cast&lt;unsigned char*&gt;(&amp;c);\n  signed char* psc = static_cast&lt;signed char*&gt;(&amp;c);\n\n  void* pv = static_cast&lt;void*&gt;(&amp;b1);\n  B* pb1 = static_cast&lt;B*&gt;(pv);\n\n  B* pb2 = static_cast&lt;B*&gt;(&amp;b1);\n\n  A* pa1 = const_cast&lt;A*&gt;(&amp;ra1);\n  A* pa2 = const_cast&lt;A*&gt;(&amp;ra2);\n\n  B* pb3 = dynamic_cast&lt;B*&gt;(&amp;c1);\n\n  A* pa3 = dynamic_cast&lt;A*&gt;(&amp;b1);\n\n  B* pb4 = static_cast&lt;B*&gt;(&amp;d1);\n\n  D* pd = static_cast&lt;D*&gt;(pb4);\n\n  pa1 = dynamic_cast&lt;A*&gt;(pb2);\n  pa1 = dynamic_cast&lt;A*&gt;(pb4);\n\n  C* pc1 = dynamic_cast&lt;C*&gt;(pb4);\n  C&amp; rc1 = dynamic_cast&lt;C&amp;&gt;(*pb2);\n}\n</code></pre>\n<p>Why is it typically unuseful to const_cast from non-const to const? Demonstrate a valid example in which it can be useful to const_cast from non-const to const.\"</p>\n<h2><strong>Solution to chapter 44</strong></h2>\n<h3>Solution</h3>\n<p>Let's answer the questions one by one.</p>\n<p>Which of the following new-style casts are not equivalent to a C-style cast?</p>\n<p>Only dynamic_cast is not equivalent to a C-style cast. All other new-style casts have old-style equivalents.</p>\n<h2>Guideline</h2>\n<h3>Prefer new-style casts.</h3>\n<p><em>For each of the following C-style casts, write the equivalent new-style cast. Which are incorrect if not written as a new-style cast?</em></p>\n<pre><code>void f() \n{\n  A* pa; B* pb; C* pc;\n  pa = (A*)&amp;ra1;\n</code></pre>\n<p>Use const_cast instead:</p>\n<pre><code>  pa = const_cast&lt;A*&gt;(&amp;ra1); \n\n  pa = (A*)&amp;a2;\n</code></pre>\n<p>This cannot be expressed as a new-style cast. The closest candidate is const_cast, but because a2 is a const object, the results of using the pointer are undefined.</p>\n<pre><code>  pb = (B*)&amp;c1; \n</code></pre>\n<p>Use reinterpret_cast instead:</p>\n<pre><code>  pb = reinterpret_cast&lt;B*&gt;(&amp;c1); \n\n  pc = (C*)&amp;d1;\n</code></pre>\n<p>The above cast is wrong in C. In C++, no cast is required:</p>\n<pre><code>  pc = &amp;d1; \n}\n</code></pre>\n<p><em>Critique each of the following C++ casts for style and correctness.</em></p>\n<p>First, a general note: All of the following dynamic_casts would be errors if the classes involved did not have virtual functions. Fortunately, A does provide a virtual function, making all the dynamic_casts legal.</p>\n<pre><code>void g() \n{\n  unsigned char* puc = static_cast&lt;unsigned char*&gt;(&amp;c);\n  signed char* psc = static_cast&lt;signed char*&gt;(&amp;c);\n</code></pre>\n<p>Error: We must use reinterpret_cast for both cases. This might surprise you at first, but the reason is that char, signed char, and unsigned char are three distinct types. Even though there are implicit conversions between them, they are unrelated, so pointers to them are unrelated.</p>\n<pre><code>  void* pv  = static_cast&lt;void*&gt; (&amp;b1); \n  B*    pb1 = static_cast&lt;B*&gt;(pv);\n</code></pre>\n<p>These are both fine, but the first is unnecessary, because there is already an implicit conversion from a data pointer to a void*.</p>\n<pre><code>  B*    pb2 = static_cast&lt;B*&gt; (&amp;b1); \n</code></pre>\n<p>This is fine, but unnecessary, since the argument is already a B*.</p>\n<pre><code>  A*    pa1 = const_cast&lt;A*&gt;(&amp;ra1); \n</code></pre>\n<p>This is legal, but casting away const (or volatile) is usually indicative of poor style. Most of the cases in which you legitimately would want to remove the const-ness of a pointer or reference are related to class members and covered by the mutable keyword. See Item 43 for further discussion of const-correctness.</p>\n<h2>Guideline</h2>\n<h3>Avoid casting away const. Use mutable instead.</h3>\n<pre><code>  A*    pa2 = const_cast&lt;A*&gt;(&amp;ra2); \n</code></pre>\n<p>Error: This will produce undefined behavior if the pointer is used to write on the object, because a2 really is a const object. To see why this is a legitimate problem, consider that a compiler is allowed to see that a2 is created as a const object and use that information to store it in read-only memory as an optimization. Casting away const on such an object is obviously dangerous.</p>\n<h2>Guideline</h2>\n<h3>Avoid casting away const.</h3>\n<pre><code>  B*    pb3 = dynamic_cast&lt;B*&gt;(&amp;c1); \n</code></pre>\n<p>Potential error (if you try to use pb3): Because c1 IS-NOT-A B (because C is not publicly derived from B\u2014in fact, it is not derived from B at all), this will set pb3 to null. The only legal cast would be a reinterpret_cast, and using that is almost always evil.</p>\n<pre><code>  A*    pa3 = dynamic_cast&lt;A*&gt;(&amp;b1); \n</code></pre>\n<p>Probable error: Because b1 IS-NOT-AN A (because B is not publicly derived from A; its derivation is private), this is illegal unless g() is a friend of B.</p>\n<pre><code>  B*    pb4 = static_cast&lt;B*&gt;(&amp;d1); \n</code></pre>\n<p>This is fine, but unnecessary because derived-to-public-base pointer conversions can be done implicitly.</p>\n<pre><code>  D*    pd = static_cast&lt;D*&gt;(pb4); \n</code></pre>\n<p>This is fine, which may surprise you if you expected this to require a dynamic_cast. The reason is that downcasts can be static when the target is known, but beware: You are telling the compiler that you know for a fact that what is being pointed to really is of that type. If you are wrong, then the cast cannot inform you of the problem (as could dynamic_cast, which would return a null pointer if the cast failed) and, at best, you will get spurious run-time errors and/or program crashes.</p>\n<h2>Guideline</h2>\n<h3>Avoid downcasts.</h3>\n<pre><code>  pa1 = dynamic_cast&lt;A*&gt;(pb2); \n  pa1 = dynamic_cast&lt;A*&gt;(pb4);\n</code></pre>\n<p>These two look very similar. Both attempt to use dynamic_cast to convert a B* into an A*. However, the first is an error, while the second is not.</p>\n<p>Here's the reason: As noted above, you cannot use dynamic_cast to cast a pointer to what really is a B object (and here pb2 points to the object b1) into an A object, because B inherits privately, not publicly, from A. However, the second cast succeeds because pb4 points to the object d1, and D does have A as an indirect public base class (through C), and dynamic_cast is able to cast across the inheritance hierarchy using the path B*  D*  C*  A*.</p>\n<pre><code>  C* pc1 = dynamic_cast&lt;C*&gt;(pb4); \n</code></pre>\n<p>This, too, is fine for the same reason as the last: dynamic_cast can navigate the inheritance hierarchy and perform cross-casts, so this is legal and will succeed.</p>\n<pre><code>  C&amp; rc1 = dynamic_cast&lt;C&amp;&gt;(*pb2); \n}\n</code></pre>\n<p>Finally, an \"exceptional\" error: Because *pb2 isn't really a C, dynamic_cast will throw a bad_cast exception to signal failure. Why? Well, dynamic_cast can and does return null if a pointer cast fails, but since there's no such thing as a null reference, it can't return a null reference if a reference cast fails. There's no way to signal such a failure to the client code besides throwing an exception, so that's what the standard bad_cast exception class is for.</p>\n<p>Why is it normally unuseful to const_cast from non-const to const?</p>\n<p>The first three questions included no examples of using const_cast to add const, for example, to convert a pointer to non-const to a pointer to const. After all, explicitly adding const is usually redundant\u2014for example, it's already legal to assign a pointer to non-const to a pointer to const. Normally, we only need const_cast to do the reverse.</p>\n<p>And the last part of the question: Demonstrate a valid example where it can be useful to const_cast from non-const to const.</p>\n<p>There is at least one case in which you could usefully const_cast from non-const to const\u2014to call a specific overloaded function or a specific version of a template. For example:</p>\n<pre><code>void f( T&amp; ); \nvoid f( const T&amp; );\ntemplate&lt;class T&gt; void g( T&amp; t )\n{\n  f( t );                       // calls f(T&amp;)\n  f( const_cast&lt;const T&amp;&gt;(t) ); // calls f(const T&amp;)\n}\n</code></pre>\n<p>Of course, in the case of choosing a specific version of a template, it's usually just easier to name it explicitly instead of forcing the right deduction. For example, to call the right version of a templated function h(), writing \"h( t )\" is preferable to writing \"h( const_cast(t) )\".</p>\n", "AcceptedAnswerId": "3642778", "Title": "Casting \"Stylee\"", "CreationDate": "2010-09-04T14:11:16.363", "Id": "3642626", "CommentCount": "7", "LastEditDate": "2010-09-05T19:11:06.187", "PostTypeId": "1", "LastEditorUserId": "14065", "LastActivityDate": "2010-09-05T19:11:06.187", "Score": "2", "OwnerUserId": "207177", "Tags": "<c++><casting>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_3642626_3642778_0": {"length": 8, "quality": 0.8, "section_id": 6125}, "so_3642626_3642778_5": {"length": 27, "quality": 0.9642857142857143, "section_id": 6126}, "so_3642626_3642778_4": {"length": 15, "quality": 1.0, "section_id": 6126}, "so_3642626_3642778_1": {"length": 19, "quality": 0.8260869565217391, "section_id": 6126}, "so_3642626_3642778_3": {"length": 19, "quality": 1.0, "section_id": 6126}, "so_3642626_3642778_2": {"length": 16, "quality": 0.6666666666666666, "section_id": 6126}}, "n3337": {"so_3642626_3642778_0": {"length": 8, "quality": 0.8, "section_id": 5889}, "so_3642626_3642778_5": {"length": 27, "quality": 0.9642857142857143, "section_id": 5890}, "so_3642626_3642778_4": {"length": 15, "quality": 1.0, "section_id": 5890}, "so_3642626_3642778_1": {"length": 19, "quality": 0.8260869565217391, "section_id": 5890}, "so_3642626_3642778_3": {"length": 19, "quality": 1.0, "section_id": 5890}, "so_3642626_3642778_2": {"length": 16, "quality": 0.6666666666666666, "section_id": 5890}}, "n4659": {"so_3642626_3642778_0": {"length": 8, "quality": 0.8, "section_id": 7622}, "so_3642626_3642778_5": {"length": 27, "quality": 0.9642857142857143, "section_id": 7623}, "so_3642626_3642778_4": {"length": 15, "quality": 1.0, "section_id": 7623}, "so_3642626_3642778_1": {"length": 19, "quality": 0.8260869565217391, "section_id": 7623}, "so_3642626_3642778_3": {"length": 19, "quality": 1.0, "section_id": 7623}, "so_3642626_3642778_2": {"length": 16, "quality": 0.6666666666666666, "section_id": 7623}}}, "3642752": {"Id": "3642752", "PostTypeId": "2", "Body": "<p>All that seems to prove is that everything has an edge case. I've never come across that situation in the real world.</p>\n<p>By the way, did you have a question?</p>\n", "LastActivityDate": "2010-09-04T14:52:56.267", "CommentCount": "2", "CreationDate": "2010-09-04T14:52:56.267", "ParentId": "3642626", "Score": "0", "OwnerUserId": "342"}, "3642761": {"Id": "3642761", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3642626_3642761_0\">The closest candidate is const_cast, but because a2 is a const object, the results of using the pointer are undefined.</p>\n</blockquote>\n<p>Just to be clear, the C-style cast <code>(A*)&amp;a2</code> also yields undefined behavior. So <code>const_cast</code> is not \"the closest candidate\", it is the <em>equivalent</em>.</p>\n", "LastActivityDate": "2010-09-04T14:56:39.523", "CommentCount": "25", "CreationDate": "2010-09-04T14:56:39.523", "ParentId": "3642626", "Score": "1", "OwnerUserId": "252000"}});