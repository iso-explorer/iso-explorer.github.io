post_cb({"bq_ids": {"n4140": {"so_47664905_47665050_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_47664905_47665050_0": {"length": 5, "quality": 1.0, "section_id": 82}}}, "47665050": {"Id": "47665050", "PostTypeId": "2", "Body": "<p>There is no solution to your problem: C++03 pointer template parameters have to designate an object. Using NULL as a non-type template parameter is a feature that was added in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow noreferrer\">N1905</a>, which came out <a href=\"https://stackoverflow.com/a/4653479/251153\">at least one year</a> after C++03.</p>\n<blockquote>\n<h1>14.3.2 Template non-type arguments</h1>\n<p id=\"so_47664905_47665050_0\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>an integral constant-expression of integral or enumeration type; or</li>\n<li>the name of a non-type template-parameter; or</li>\n<li>the address of an object or function with external linkage, including function templates and function template-ids but excluding non-static class members, expressed as &amp; id-expression where the &amp; is optional if the name refers to a function or array, or if the corresponding template-parameter is a reference; or</li>\n<li><strong>(NEW)</strong> a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li><strong>(NEW)</strong> a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1.</li>\n</ul>\n</blockquote>\n<p>One option is to declare a \"null struct\" with a member that you can use instead of a real <code>NULL</code>:</p>\n<pre><code>template&lt;typename T&gt;\nstruct null\n{\n    static T value;\n};\n\ntemplate&lt;typename T, T* = &amp;null&lt;T&gt;::value&gt;\nstruct Foo\n{\n};\n</code></pre>\n<p>Of course, accessing <code>null&lt;T&gt;::value</code> has well-defined semantics and it won't crash; the purpose is just to have an address that is guaranteed to be different from the address of any other object.</p>\n<p>Note that in any case, it will be impossible for you to use <code>T = void</code>. You can't use the <code>null</code> workaround with it because <code>void</code> is an incomplete type; and you can't cast anything to a <code>void</code> pointer to use as a non-type template argument.</p>\n", "LastEditorUserId": "251153", "LastActivityDate": "2017-12-06T08:15:33.957", "Score": "3", "CreationDate": "2017-12-06T00:46:18.707", "ParentId": "47664905", "CommentCount": "0", "OwnerUserId": "251153", "LastEditDate": "2017-12-06T08:15:33.957"}, "47664905": {"ViewCount": "63", "Body": "<p>I've distilled a problem that's confounded me to the minimal example shown below. Basically the gcc compiler doesn't accept <code>NULL</code> as a template parameter of type <code>void*</code>.</p>\n<p>Is there a workaround for this? </p>\n<p>Please note that I'm restricted to C++03.</p>\n<pre><code>#define NULL 0\n\ntemplate&lt;typename T = void , T* = NULL&gt;\nstruct Foo\n{\n};\n\ntypedef Foo&lt;&gt; FooType;\n\nint main()\n{\n}\n</code></pre>\n<p>Edit: <a href=\"http://rextester.com/WLJHKJ83334\" rel=\"nofollow noreferrer\">online version</a></p>\n", "AcceptedAnswerId": "47665050", "Title": "Cannot convert template argument NULL to void*", "CreationDate": "2017-12-06T00:28:49.670", "Id": "47664905", "CommentCount": "10", "LastEditDate": "2017-12-06T10:51:44.313", "PostTypeId": "1", "LastEditorUserId": "181783", "LastActivityDate": "2017-12-06T10:51:44.313", "Score": "1", "OwnerUserId": "181783", "Tags": "<c++><templates><c++03>", "AnswerCount": "1"}});