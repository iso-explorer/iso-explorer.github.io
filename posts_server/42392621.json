post_cb({"42392621": {"ViewCount": "107", "Body": "<p>If a function cannot be found in the scope where it is called, looking up in the namespaces of its arguments will follow. I have a few questions.</p>\n<ol>\n<li><p>If there are several arguments in different namespaces, which namespace will be first looked up? Is it the namespace of the first argument?</p>\n<pre><code>f(A::T t, B:U u); // Is namespace A looked up first?\n</code></pre></li>\n<li><p>More complex for template classes, like</p>\n<pre><code>f(A::T&lt;B::U&gt; t); // Namespace A or B is looked up first?\n</code></pre></li>\n</ol>\n", "AcceptedAnswerId": "42392717", "Title": "function lookup and namespaces", "CreationDate": "2017-02-22T13:18:30.460", "Id": "42392621", "CommentCount": "0", "LastEditDate": "2017-02-22T13:23:43.050", "PostTypeId": "1", "LastEditorUserId": "1782465", "LastActivityDate": "2017-02-22T13:30:25.283", "Score": "2", "OwnerUserId": "1899020", "Tags": "<c++><namespaces><argument-dependent-lookup>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42392621_42392717_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 7105}, "so_42392621_42392717_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7105}}, "n3337": {"so_42392621_42392717_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 6849}, "so_42392621_42392717_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6849}}, "n4659": {"so_42392621_42392717_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 8606}, "so_42392621_42392717_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 8606}}}, "42392717": {"Id": "42392717", "PostTypeId": "2", "Body": "<p>Actually, there is no order among the namespaces for ADL. All relevant namespaces are searched, and all functions thus found form the set of candidates for overload resolution.</p>\n<p>Also note that unlike what you say in the question, ADL is performed even when a function <em>is</em> found by unqualified lookup in the calling scope. The union of unqualified lookup and ADL is then used to find the best overload.</p>\n<p>ADL is only suppressed if unqualified lookup at calling scope finds a class member, a non-function, or a block-scope non-<code>using</code> declaration.</p>\n<p>The relevant rules are in C++14 3.4.2 [basic.lookup.argdep]. Quoting N4140, bold emphasis mine:</p>\n<blockquote>\n<p id=\"so_42392621_42392717_0\">3 Let <em>X</em> be the lookup set produced by unqualified lookup (3.4.1) and let <em>Y</em> be the lookup set produced by\n  argument dependent lookup (defined as follows). If <em>X</em> contains</p>\n<ul>\n<li>a declaration of a class member, or</li>\n<li>a block-scope function declaration that is not a using-declaration, or</li>\n<li>a declaration that is neither a function or a function template</li>\n</ul>\n<p id=\"so_42392621_42392717_1\">then <em>Y</em> is empty. Otherwise <em>Y</em> is the set of declarations found in the namespaces associated with the\n  argument types as described below. <strong>The set of declarations found by the lookup of the name is the union of\n  <em>X</em> and <em>Y</em>.</strong></p>\n</blockquote>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2017-02-22T13:28:03.373", "Score": "5", "CreationDate": "2017-02-22T13:22:52.647", "ParentId": "42392621", "CommentCount": "0", "LastEditDate": "2017-02-22T13:28:03.373", "OwnerUserId": "1782465"}});