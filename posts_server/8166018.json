post_cb({"8166322": {"ParentId": "8166018", "CommentCount": "0", "CreationDate": "2011-11-17T11:26:32.797", "OwnerUserId": "124161", "PostTypeId": "2", "Id": "8166322", "Score": "3", "Body": "<p>Consider a namespace instead of nested class. </p>\n<pre><code>class A;\nA * pa;\nnamespace A_help\n{\n   class B;\n} // namespace A_help\nA_help::B * pb;\n</code></pre>\n", "LastActivityDate": "2011-11-17T11:26:32.797"}, "8166018": {"CommentCount": "3", "ViewCount": "207", "CreationDate": "2011-11-17T11:02:33.120", "LastActivityDate": "2011-11-17T11:38:41.650", "Title": "Declaring nested classes before they are defined", "AcceptedAnswerId": "8166480", "PostTypeId": "1", "Id": "8166018", "Score": "5", "Body": "<p>I can declare a pointer to a class that hasn't yet been defined, like this:</p>\n<pre><code>class A ;\nA* p ;\n</code></pre>\n<p>But how do I do this for a nested class? I want to do this:</p>\n<pre><code>class A ;\nclass A::B ; // error: 'B' in class 'A' does not name a type\nA::B* p ;\n</code></pre>\n<p>But it doesn't compile (using g++ 4.5.2). Is there any way to make this work?</p>\n", "Tags": "<c++>", "OwnerUserId": "428857", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_8166018_8166480_1": {"section_id": 5443, "quality": 0.5897435897435898, "length": 23}, "so_8166018_8166480_0": {"section_id": 5442, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_8166018_8166480_1": {"section_id": 5238, "quality": 0.5897435897435898, "length": 23}, "so_8166018_8166480_0": {"section_id": 5237, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_8166018_8166480_1": {"section_id": 6870, "quality": 0.5897435897435898, "length": 23}, "so_8166018_8166480_0": {"section_id": 6869, "quality": 0.8666666666666667, "length": 13}}}, "8166480": {"ParentId": "8166018", "CommentCount": "0", "CreationDate": "2011-11-17T11:38:41.650", "OwnerUserId": "90527", "PostTypeId": "2", "Id": "8166480", "Score": "4", "Body": "<p>There are a number of parts of C++03 that disallow forward declarations of nested classes. In particular, \u00a7 7.1.5.3 Elaborated type specifiers:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_8166018_8166480_0\">If an <i>elaborated-type-specifier</i> is the sole constituent of a declaration, the declaration is ill-formed unless it is an explicit specialization (14.7.3), an explicit instantiation (14.7.2) or it has one of the following forms:</p>\n<pre><i>class-key</i> <i>identifier</i> ; \nfriend <i>class-key</i> ::<sub>opt</sub> <i>identifier</i> ; \nfriend <i>class-key</i> ::<sub>opt</sub> <i>template-id</i> ; \nfriend <i>class-key</i> ::<sub>opt</sub> <i>nested-name-specifier</i> <i>identifier</i> ; \nfriend <i>class-key</i> ::<sub>opt</sub> <i>nested-name-specifier</i> <i>template</i><sub>opt</sub>\n<i>template-id</i> ;\n</pre>\n</li>\n<li><p id=\"so_8166018_8166480_1\">3.4.4 describes how name lookup proceeds for the <i>identifier</i> in an <i>elaborated-type-specifier</i>. If the identifier resolves to a <i>class-name</i> or <i>enum-name</i>, the <i>elaborated-type-specifier</i> introduces it into the declaration the same way a <i>simple-type-specifier</i> introduces its <i>type-name</i>. [...] If name lookup does not find a declaration for the name, the elaborated-type-specifier is ill-formed unless it is of the simple form <i>class-key</i> <i>identifier</i> in which case the <i>identifier</i> is declared as described in 3.3.1.</p></li>\n</ol>\n</blockquote>\n<p>In short, when an identifier is scoped, the compiler must try to resolve the identifier. When the scope is a class, the compiler must look up the declaration for the identifier in the outer class. When the outer class hasn't yet been defined, this can't be done and the result is an ill-formed program.</p>\n", "LastActivityDate": "2011-11-17T11:38:41.650"}});