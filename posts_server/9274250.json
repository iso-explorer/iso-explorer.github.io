post_cb({"9274325": {"Id": "9274325", "PostTypeId": "2", "Body": "<p>Probably because it wouldn't actually be all that useful (in addition to what @Luchian Grigore says in another answer). Even if individual container operations are thread-safe, you still need to do a lot of work to ensure thread safety. For instance, this simple code contains a race condition even if the container itself is thread-safe:</p>\n<pre><code>if (!container.empty())\n    container.pop();\n</code></pre>\n", "LastActivityDate": "2012-02-14T09:18:16.693", "CommentCount": "1", "CreationDate": "2012-02-14T09:18:16.693", "ParentId": "9274250", "Score": "5", "OwnerUserId": "626853"}, "9274337": {"Id": "9274337", "PostTypeId": "2", "Body": "<p>The C++ STL provides the kind of thread-safety that pretty much everything else provides: You can safely use STL containers from multiple threads so long as an object isn't accessed in one thread while another thread is, or might be, modifying it.</p>\n", "LastActivityDate": "2012-02-14T09:19:11.140", "CommentCount": "0", "CreationDate": "2012-02-14T09:19:11.140", "ParentId": "9274250", "Score": "0", "OwnerUserId": "721269"}, "bq_ids": {"n4140": {"so_9274250_9274327_0": {"length": 38, "quality": 0.8636363636363636, "section_id": 6326}}, "n3337": {"so_9274250_9274327_0": {"length": 38, "quality": 0.8636363636363636, "section_id": 6083}}, "n4659": {"so_9274250_9274327_0": {"length": 38, "quality": 0.8636363636363636, "section_id": 7836}}}, "9274250": {"ViewCount": "2449", "Body": "<blockquote>\n<p id=\"so_9274250_9274250_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/2630485/question-about-stl-thread-safe-and-stl-debugging\">question about STL thread-safe and STL debugging</a> </br></p>\n</blockquote>\n<p>I'm currently being engaged in a project which is developed using C++. Recently we are considering replacing some self-defined thread-safe containers with some STL equivalents to gain some efficiency.</p>\n<p>However, after looking for a while, I found that there is no a thread-safe container provided in STL at all, which surprises quite a lot. Is there any reason?</p>\n", "Title": "Why does the C++ STL not provide a set of thread-safe containers?", "CreationDate": "2012-02-14T09:12:49.847", "LastActivityDate": "2012-02-14T09:45:15.277", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:20:02.190", "Tags": "<c++><stl><containers>", "Id": "9274250", "LastEditorUserId": "-1", "Score": "1", "OwnerUserId": "1087373", "ClosedDate": "2012-02-14T13:31:01.987", "AnswerCount": "5"}, "9274368": {"Id": "9274368", "PostTypeId": "2", "Body": "<p>In a sentence - because it's hard.</p>\n<p>Because thread-safe containers require specific design - e.g. they must be <a href=\"http://en.wikipedia.org/wiki/Persistent_data_structure\" rel=\"nofollow\">persistent data structures</a>. Such containers are easiest to implement in functional / garbage collected / event-based environments. Which C++ is not.</p>\n<p>That is to say, implementing these would still require the user to handle all resource allocation/deallocation. That kind of defeats the point of having a collection.</p>\n", "LastActivityDate": "2012-02-14T09:21:05.863", "CommentCount": "0", "CreationDate": "2012-02-14T09:21:05.863", "ParentId": "9274250", "Score": "0", "OwnerUserId": "140786"}, "9274305": {"Id": "9274305", "PostTypeId": "2", "Body": "<p>Because thread safety is highly platform and compiler specific. </p>\n", "LastActivityDate": "2012-02-14T09:16:55.037", "CommentCount": "1", "CreationDate": "2012-02-14T09:16:55.037", "ParentId": "9274250", "Score": "2", "OwnerUserId": "673730"}, "9274327": {"Id": "9274327", "PostTypeId": "2", "Body": "<p>Standard Library containers do provide some basic thread safety, Performance was a more important design goal for designers of the Standard Library containers than safety.</p>\n<p>All Standard Library containers guarantee:<br>\nMultiple concurrent reads from the same container are safe but<br>\nIf there is atleast one writer thread, then there is no thread safety &amp; there shall not be any other  writer or reader.    </br></br></p>\n<p>The Standard Library containers were primarily designed for working efficiently in Single threaded environments and providing only basic thread safety is a way to ensure full performance for containers that do not need concurrent access. </p>\n<p>The basic thread safety needs that users need some sort of synchronization methods to avoid race conditions through use of using mutexes, or locks.Locking or other forms of synchronization are typically expensive and hence need to be avoided when not necessary.</p>\n<p>Also, given the interfaces exposed by the Standard Library containers, It is easy for the client or user of the container to provide the necessary locking by wrapping the underlying container operations with a lock acquisition and release if intended use is for multi-threaded environments.</p>\n<hr>\n<p>Note that All the implementations conform the following requirements specified by the C++ Standard:</p>\n<p><strong>17.6.3.10 Shared objects and the library [res.on.objects]</strong> </p>\n<blockquote>\n<p id=\"so_9274250_9274327_0\">The behavior of a program is undefined if calls to standard library functions from different threads may introduce a data race. The conditions under which this may occur are specified in 17.6.4.8. [ Note: Modifying an object of a standard library type that is shared between threads risks undefined behavior unless objects of that type are explicitly specified as being sharable without data races or the user supplies a locking mechanism. \u2014end note ]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2012-02-14T09:45:15.277", "Score": "4", "CreationDate": "2012-02-14T09:18:22.143", "ParentId": "9274250", "CommentCount": "0", "OwnerUserId": "452307", "LastEditDate": "2012-02-14T09:45:15.277"}});