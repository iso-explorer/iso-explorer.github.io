post_cb({"48881336": {"ParentId": "48879226", "LastActivityDate": "2018-02-20T09:05:27.037", "OwnerUserId": "580083", "Id": "48881336", "CreationDate": "2018-02-20T09:02:53.787", "LastEditorUserId": "580083", "Body": "<p>Quoting from C++17 Working Draft \u00a715.2 Temporary Objects Paragraph 3 (<a href=\"https://timsong-cpp.github.io/cppwp/class.temporary#3\" rel=\"noreferrer\">https://timsong-cpp.github.io/cppwp/class.temporary#3</a>):</p>\n<blockquote>\n<p id=\"so_48879226_48881336_0\">When an object of class type X is passed to or <strong>returned from a function</strong>, if each copy constructor, move constructor, and destructor of X is either trivial or deleted, and X has at least one non-deleted copy or move constructor, <strong>implementations are permitted to create a temporary object to hold</strong> the function parameter or <strong>result object</strong>. ...  [\u2009<em>Note</em>: This latitude is granted to allow objects of class type to be passed to or returned from functions in registers. \u2014\u2009<em>end note</em>]</p>\n</blockquote>\n<p>In your case, when I made both copy and move constructors defaulted:</p>\n<pre><code>S(const S &amp;) = default;\nS(S &amp;&amp;) = default;\n</code></pre>\n<p>assertion failed as well with GCC and Clang. Note that implicitly-defined constructors are trivial.</p>\n", "LastEditDate": "2018-02-20T09:05:27.037", "PostTypeId": "2", "CommentCount": "4", "Score": "10"}, "48879226": {"Tags": "<c++><language-lawyer><c++17><copy-elision>", "ViewCount": "446", "LastEditDate": "2018-02-20T16:03:29.343", "AnswerCount": "1", "FavoriteCount": "5", "Title": "Does the behavior of guaranteed copy elision depend on existence of user-defined copy constructor?", "CommentCount": "7", "LastEditorUserId": "5376789", "AcceptedAnswerId": "48881336", "Score": "12", "CreationDate": "2018-02-20T06:34:03.717", "Id": "48879226", "LastActivityDate": "2018-02-25T09:51:43.150", "Body": "<p>The following code behaves differently with or without user-defined copy constructor <a href=\"https://wandbox.org/permlink/46p36ZShdZub7WFM\" rel=\"noreferrer\">under GCC 8.0.1</a>:</p>\n<pre><code>#include &lt;cassert&gt;\n\nstruct S {\n    int i;\n    int *p;\n    S() : i(0), p(&amp;i) {}\n//    S(const S &amp;s) : i(s.i), p(&amp;i) {}  // #1\n//    S(const S &amp;s) : i(s.i), p(s.p) {} // #2\n//    S(const S &amp;s) = delete;           // #3\n};\n\nS make_S() {return S{};}\n\nint main()\n{\n    S s = make_S();\n    assert(s.p == &amp;s.i);\n}\n</code></pre>\n<p>With either of the commented user-defined copy constructors (even with #2, the one performing a simple shallow copy), the assertion will not fail, which means <a href=\"https://stackoverflow.com/questions/38043319/how-does-guaranteed-copy-elision-work\">guaranteed copy elision</a> works as expected.</p>\n<p>However, without any user-defined copy constructor, the assertion fails, which means the object <code>s</code> in <code>main</code> function is not default-constructed. Why does this happen? Doesn't guaranteed copy elision perform here?</p>\n", "PostTypeId": "1", "OwnerUserId": "5376789"}, "bq_ids": {"n4659": {"so_48879226_48881336_0": {"length": 42, "section_id": 394, "quality": 0.9130434782608695}}}});