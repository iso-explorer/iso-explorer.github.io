post_cb({"bq_ids": {"n4140": {"so_28436148_28583523_1": {"length": 88, "quality": 0.9263157894736842, "section_id": 370}, "so_28436148_28436735_0": {"length": 14, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_28436148_28583523_1": {"length": 88, "quality": 0.9263157894736842, "section_id": 360}, "so_28436148_28436735_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 5946}}, "n4659": {"so_28436148_28583523_1": {"length": 86, "quality": 0.9052631578947369, "section_id": 384}, "so_28436148_28436735_0": {"length": 14, "quality": 1.0, "section_id": 7687}}}, "28583523": {"Id": "28583523", "PostTypeId": "2", "Body": "<p>As @Casey correctly pointed out in the comments, there is nothing foggy about the <code>constexpr</code>-ness of the implicit constructor of <code>std::array</code> or other aggregates:</p>\n<blockquote>\n<p id=\"so_28436148_28583523_0\"><strong>12.1 Constructors [class.ctor]</strong></p>\n<p id=\"so_28436148_28583523_1\">5 A default constructor that is defaulted and not defined as deleted\n  is implicitly defined when it is odr-used (3.2) to create an object of\n  its class type (1.8) or when it is explicitly defaulted after its\n  first declaration. The implicitly-defined default constructor performs\n  the set of initializations of the class that would be performed by a\n  user-written default constructor for that class with no\n  ctor-initializer (12.6.2) and an empty compound-statement. If that\n  user-written default constructor would be ill-formed, the program is\n  ill-formed. <strong>If that user-written default constructor would satisfy the\n  requirements of a <code>constexpr</code> constructor (7.1.5), the\n  implicitly-defined default constructor is <code>constexpr</code>.</strong> Before the\n  defaulted default constructor for a class is implicitly defined, all\n  the non-user-provided default constructors for its base classes and\n  its nonstatic data members shall have been implicitly defined. [ Note:\n  An implicitly-declared default constructor has an\n  exception-specification (15.4). An explicitly-defaulted definition\n  might have an implicit exceptionspecification, see 8.4. \u2014end note ]</p>\n</blockquote>\n<p>This has been fixed in the latest gcc HEAD 5.0.0 20150217, see this <a href=\"http://melpon.org/wandbox/permlink/VGhGnmAQzxj50UuP\" rel=\"nofollow noreferrer\"><strong>live example</strong></a>, and has been working in Clang since almost a year and a half now (since the 3.4 release IIRC, see <a href=\"https://stackoverflow.com/q/19019252/819272\"><strong>this Q&amp;A</strong></a>).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-18T12:18:30.897", "Score": "1", "CreationDate": "2015-02-18T12:18:30.897", "ParentId": "28436148", "CommentCount": "2", "OwnerUserId": "819272", "LastEditDate": "2017-05-23T12:31:04.847"}, "28436735": {"Id": "28436735", "PostTypeId": "2", "Body": "<p>This is kinda foggy. The rules for constexpr in C++14 forbid (N3797, 5.19/2 bullet 2)</p>\n<blockquote>\n<p id=\"so_28436148_28436735_0\">an invocation of a function other than a constexpr constructor for a literal class, a constexpr function, or an implicit invocation of a trivial destructor</p>\n</blockquote>\n<p><code>constexpr</code> is not part of the type, so the function pointer passed to <code>make_array_impl</code> is not a constexpr function. On the other hand, it <em>refers</em> to a constexpr function, and since this is constexpr evaluation, the compiler has to know that.</p>\n<p>However, Clang supports that code, and GCC 4.9 doesn't claim conformance with relaxed constexpr functions, so I would trust Clang in this case.</p>\n", "LastActivityDate": "2015-02-10T16:29:46.430", "CommentCount": "3", "CreationDate": "2015-02-10T16:29:46.430", "ParentId": "28436148", "Score": "1", "OwnerUserId": "8922"}, "28436148": {"ViewCount": "554", "Body": "<p>Writting a simple compile time <code>std::array</code> factory from a generator function, I stumbled upon this: clang++ 3.5.1 and g++ 4.9.2 disagree on whether a function is <code>constexpr</code> or not.</p>\n<p>The code (this is c++14!):</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;utility&gt;\n\n    template &lt;class T, std::size_t N, class GenType, std::size_t... I&gt; \n    constexpr std::array&lt;T, N&gt;\nmake_array_impl (GenType gen, std::index_sequence &lt;I...&gt;) \n{\n    return {{ gen (I)... }};\n}\n\n    template &lt;class T, std::size_t N, class GenType&gt; \n    constexpr std::array&lt;T, N&gt;\nmake_array (GenType gen)\n{\n    return make_array_impl &lt;T, N&gt; (\n            gen, \n            std::make_index_sequence &lt;N&gt; {}\n    );\n}\n\n    constexpr int\ngenerator_const (std::size_t /* index */)\n{\n    return 1;\n}\n\n    constexpr auto\na = make_array &lt;int, 3&gt; (generator_const);\n\nstatic_assert (a.size () == 3, \"\");\nstatic_assert (a[0] == 1, \"\");\nstatic_assert (a[1] == 1, \"\");\nstatic_assert (a[2] == 1, \"\");\n\nint main () {}\n</code></pre>\n<p>Compiling with g++:</p>\n<pre><code>migou ~ % g++ -std=c++14 ex.cpp  \nex.cpp:28:41:   in constexpr expansion of \u2018make_array&lt;int, 3ul, int (*)(long unsigned int)&gt;(generator_const)\u2019\nex.cpp:18:5:   in constexpr expansion of \u2018make_array_impl&lt;int, 3ul, int (*)(long unsigned int), {0ul, 1ul, 2ul}&gt;(gen, (std::make_index_sequence&lt;3ul&gt;{}, std::make_index_sequence&lt;3ul&gt;()))\u2019\nex.cpp:8:21: error: expression \u2018generator_const\u2019 does not designate a constexpr function\n return {{ gen (I)... }};\n</code></pre>\n<p>With clang++ it compiles just fine. Can I go on and consider this valid g++14 (and thus g++ bugged)? </p>\n", "AcceptedAnswerId": "28583523", "Title": "gcc and clang disagree over constexpr function", "CreationDate": "2015-02-10T16:00:41.260", "Id": "28436148", "CommentCount": "1", "LastEditDate": "2015-02-10T16:02:29.453", "PostTypeId": "1", "LastEditorUserId": "253056", "LastActivityDate": "2015-02-18T12:18:30.897", "Score": "5", "OwnerUserId": "4499346", "Tags": "<c++><gcc><clang><c++14><constexpr>", "AnswerCount": "2"}});