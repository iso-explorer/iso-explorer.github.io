post_cb({"42441827": {"ParentId": "42441166", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>There are two possibilities to make the program to compile.</p>\n<p>The first one as the friend function is defined outside the class is to use qualified names of the static class data members. For example</p>\n<pre><code>test* friendOfTest(){\n    test::ptr = new test; //Error,ptr not declared in this scope in this line\n    return test::ptr;\n}\n</code></pre>\n<p>The second one is to define the function inside the class. In this case it will be in the scope of the class. </p>\n<p>According to the C++ Standard (11.3 Friends) </p>\n<blockquote>\n<p id=\"so_42441166_42441827_0\">7 Such a function is implicitly inline. A friend function de\ufb01ned in a\n  class is in the (lexical) scope of the class in which it is de\ufb01ned. A\n  friend function de\ufb01ned outside the class is not (3.4.1).</p>\n</blockquote>\n<p>For example</p>\n<pre><code>class test{\nprivate: \n    static test* ptr;\npublic:\n    friend test* friendOfTest();\n\nfriend test* friendOfTest(){\n    ptr = new test; //Error,ptr not declared in this scope in this line\n    return ptr;\n}\n\n    void someMethod(){ cout&lt;&lt;\"someMethod()\\n\";}\n};\n</code></pre>\n<p>Here are demonstrative programs</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass test;\ntest* friendOfTest();\n\nclass test{\nprivate: \n    static test* ptr;\npublic:\n    friend test* friendOfTest();\n/*\nfriend test* friendOfTest(){\n    ptr = new test; //Error,ptr not declared in this scope in this line\n    return ptr;\n}\n*/\n    void someMethod(){ cout&lt;&lt;\"someMethod()\\n\";}\n};\n\ntest* test::ptr=NULL;\n\ntest* friendOfTest(){\n    test::ptr = new test; //Error,ptr not declared in this scope in this line\n    return test::ptr;\n}\n\n\ntest* friendofTest();\n\nint main(){\n    test* t;\n    t = friendOfTest();\n    t-&gt;someMethod();\n    return 0;\n}\n</code></pre>\n<p>and</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass test;\ntest* friendOfTest();\n\nclass test{\nprivate: \n    static test* ptr;\npublic:\n//    friend test* friendOfTest();\n\nfriend test* friendOfTest(){\n    ptr = new test; //Error,ptr not declared in this scope in this line\n    return ptr;\n}\n\n    void someMethod(){ cout&lt;&lt;\"someMethod()\\n\";}\n};\n\ntest* test::ptr=NULL;\n/*\ntest* friendOfTest(){\n    test::ptr = new test; //Error,ptr not declared in this scope in this line\n    return test::ptr;\n}\n*/\n\ntest* friendofTest();\n\nint main(){\n    test* t;\n    t = friendOfTest();\n    t-&gt;someMethod();\n    return 0;\n}\n</code></pre>\n<p>the both programs compile successfully.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2017-02-24T15:25:14.220", "Id": "42441827", "Score": "0", "CreationDate": "2017-02-24T15:01:50.860", "LastActivityDate": "2017-02-24T15:25:14.220"}, "42441208": {"ParentId": "42441166", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, you have access to ptr, but your <strong>syntax</strong> is wrong:</p>\n<pre><code>test* friendofTest(){\n    test::ptr = new test; // note test::\n    return test::ptr;\n}\n</code></pre>\n<p>A friend function will <strong>not behave as a member function</strong> to your class, it just allows it's members to be accessed even though declared private or protected.</p>\n<p><code>friendofTest</code> in this case will still be a completely <strong>separate</strong> function from your class, but you can access it's static <code>test</code> member through a <strong>scope resolution operator</strong> as usual, even though it's declared private.</p>\n", "OwnerUserId": "1129815", "LastEditorUserId": "1129815", "LastEditDate": "2017-02-24T14:38:42.980", "Id": "42441208", "Score": "1", "CreationDate": "2017-02-24T14:32:02.930", "LastActivityDate": "2017-02-24T14:38:42.980"}, "bq_ids": {"n4140": {"so_42441166_42441827_0": {"section_id": 6690, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_42441166_42441827_0": {"section_id": 6445, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_42441166_42441827_0": {"section_id": 8165, "quality": 0.7777777777777778, "length": 14}}}, "42441166": {"CommentCount": "5", "ViewCount": "51", "CreationDate": "2017-02-24T14:30:02.780", "LastActivityDate": "2017-02-24T15:25:14.220", "Title": "Not able to Instantiate class inside friend function? I am getting not declared in scope error", "PostTypeId": "1", "Id": "42441166", "Score": "0", "Body": "<p>I am not able to instantiate test class inside the friend function, the compiler throwing error ptr not declared in this scope. I believe friend functions have access to all the private and public members of the class yet I am getting this error. I am not able to figure out where I am going wrong?</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass test;\ntest* friendOfTest();\n\nclass test{\nprivate: \n    static test* ptr;\npublic:\n    friend test* friendOfTest();\n    void someMethod(){ cout&lt;&lt;\"someMethod()\\n\";}\n};\n\ntest* test::ptr=NULL;\n\ntest* friendofTest(){\n    ptr = new test; //Error,ptr not declared in this scope in this line\n    return ptr;\n}\n\n\nint main(){\n    test* t;\n    t = friendofTest();\n    t-&gt;someMethod();\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><friend>", "OwnerUserId": "5084692", "AnswerCount": "2"}});