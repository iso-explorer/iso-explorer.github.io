post_cb({"8338220": {"Id": "8338220", "PostTypeId": "2", "Body": "<p>In the C++11 FDIS, we can read:</p>\n<blockquote>\n<p id=\"so_8335430_8338220_0\"><strong>23.2.3 Sequence containers [sequence.reqmts]</strong></p>\n<p id=\"so_8335430_8338220_1\"><strong>16/</strong> Table 101 lists operations that are provided for some types of sequence containers but not others. An implementation shall provide these operations for all container types shown in the \u201ccontainer\u201d column, and shall implement them so as to take <strong>amortized constant time</strong>.</p>\n</blockquote>\n<p>Where <em>Table 101</em> is named <em>Optional sequence container operations</em> and lists <code>deque</code> for the <code>push_back</code> and <code>push_front</code> operations.</p>\n<p>Therefore, it seems more like a slight omission in the paragraph you cited. Perhaps worth a Defect Report ?</p>\n<p>Note that the <em>single</em> call to a constructor still holds.</p>\n", "LastActivityDate": "2011-12-01T08:11:22.603", "CommentCount": "3", "CreationDate": "2011-12-01T08:11:22.603", "ParentId": "8335430", "Score": "3", "OwnerUserId": "147192"}, "8335611": {"Id": "8335611", "PostTypeId": "2", "Body": "<p>I suspect that the reallocation of the block pointers is done with a geometrically increasing size  - this is a common trick for std::vector. I think this is technically O(log m) but as you point out m &lt;&lt; n, so as a practical matter it doesn't affect the real-world results.</p>\n", "LastActivityDate": "2011-12-01T01:48:58.747", "CommentCount": "2", "CreationDate": "2011-12-01T01:48:58.747", "ParentId": "8335430", "Score": "0", "OwnerUserId": "5987"}, "bq_ids": {"n4140": {"so_8335430_8338220_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 735}, "so_8335430_8335430_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 819}}, "n3337": {"so_8335430_8338220_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 724}, "so_8335430_8335430_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 808}}, "n4659": {"so_8335430_8338220_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 764}, "so_8335430_8335430_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 878}}}, "8335430": {"ViewCount": "1272", "Body": "<p>As a result of <a href=\"https://stackoverflow.com/questions/8305492/about-dequets-extra-indirection/8305658#8305658\">this</a> question from a few days ago there are a few things that have been bugging me about the complexity requirements for <code>std::deque::push_back/push_front</code> vs the actual <code>std::deque</code> implementations out in the wild.</p>\n<p>The upshot of the previous question was that these operations are required to have <code>O(1)</code> worst case complexity. I verified that this was indeed the case in <code>c++11</code>:</p>\n<blockquote>\n<p id=\"so_8335430_8335430_0\">from 23.3.3.4 deque modifiers, refering to insert, push/emplace front/back</p>\n<p id=\"so_8335430_8335430_1\">Complexity: The complexity is linear in the number of elements inserted plus the \n  lesser of the distances to the beginning and end of the deque. Inserting a single \n  element either at the beginning or end of a deque always takes constant time and \n  causes a single call to a constructor of T.</p>\n</blockquote>\n<p>This is combined with the <code>O(1)</code> complexity requirement for indexing, via <code>operator[]</code> etc.</p>\n<p>The issue is that implementations don't strictly satisfy these requirements. </p>\n<p>In terms of both <code>msvc</code> and <code>gcc</code> the <code>std::deque</code> implementation is a blocked data structure, consisting of a dynamic array of pointers to (fixed size) blocks, where each block stores a number of data elements.</p>\n<p>In the worst case, <code>push_back/front etc</code> could require an extra block to be allocated (which is fine - fixed size allocation is <code>O(1)</code>), but it could also require that the dynamic array of block pointers be resized - this is not fine, since this is <code>O(m)</code> where <code>m</code> is the number of blocks, which at the end of the day is <code>O(n)</code>.</p>\n<p>Obviously this is still amortised <code>O(1)</code> complexity and since generally <code>m &lt;&lt; n</code> it's going to be pretty fast in practice. But it seems there's an issue with conformance?</p>\n<p>As a further point, I don't see how you can design a data structure that strictly satisfies both the <code>O(1)</code> complexity for both <code>push_back/front etc</code> and <code>operator[]</code>. You could have a linked-list of block pointers, but this doesn't give you the desired <code>operator[]</code> behaviour. Can it actually be done?</p>\n", "AcceptedAnswerId": "8338220", "Title": "Complexity requirements for std::deque::push_back/front", "CreationDate": "2011-12-01T01:19:36.053", "Id": "8335430", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:27:37.750", "LastEditorUserId": "-1", "LastActivityDate": "2011-12-01T08:11:22.603", "Score": "11", "OwnerUserId": "566274", "Tags": "<c++><containers>", "AnswerCount": "2"}});