post_cb({"2301655": {"Id": "2301655", "PostTypeId": "2", "Body": "<p>If your compiler won't warn of this, you can try a Linter.  </p>\n<p>Splint is free, but only checks C   <a href=\"http://www.splint.org/\" rel=\"nofollow noreferrer\">http://www.splint.org/</a></p>\n<p>Gimpel Lint supports C++ but costs US $389 - maybe your company c an be persuaded to buy a copy?   <a href=\"http://www.gimpel.com/\" rel=\"nofollow noreferrer\">http://www.gimpel.com/</a></p>\n", "LastActivityDate": "2010-02-20T09:12:04.657", "CommentCount": "0", "CreationDate": "2010-02-20T09:12:04.657", "ParentId": "2301372", "Score": "0", "OwnerUserId": "192910"}, "2301391": {"Id": "2301391", "PostTypeId": "2", "Body": "<p>GCC warns as much as it can when you do something out of the norms of the language while still being syntactically correct, but beyond the certain point one must be informed enough.</p>\n<p>You can call GCC with the <code>-Wall</code> flag to see more of that.</p>\n", "LastActivityDate": "2010-02-20T07:03:06.643", "CommentCount": "0", "CreationDate": "2010-02-20T07:03:06.643", "ParentId": "2301372", "Score": "0", "OwnerUserId": "179328"}, "2301376": {"Id": "2301376", "PostTypeId": "2", "Body": "<p>gcc does warn in that situation (at least with <code>-Wall</code>):</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int a[5];\n  int i = 0;\n\n  a[i] = ++i;\n\n  printf(\"%d\\n\", a[0]);\n\n  return 0;\n}\n</code></pre>\n<p>Gives:</p>\n<pre><code>$ make\ngcc -Wall main.c -o app\nmain.c: In function \u2018main\u2019:\nmain.c:8: warning: operation on \u2018i\u2019 may be undefined\n</code></pre>\n<p>Edit:</p>\n<p>A quick read of the <a href=\"http://linux.die.net/man/1/gcc\" rel=\"nofollow noreferrer\">man page</a> shows that <code>-Wsequence-point</code> will do it, if you don't want <code>-Wall</code> for some reason.</p>\n", "LastEditorUserId": "116908", "LastActivityDate": "2010-02-20T07:05:16.110", "Score": "2", "CreationDate": "2010-02-20T06:58:39.507", "ParentId": "2301372", "CommentCount": "4", "OwnerUserId": "116908", "LastEditDate": "2010-02-20T07:05:16.110"}, "2301426": {"Id": "2301426", "PostTypeId": "2", "Body": "<p>Contrarily, compilers are <strong>not</strong> required to make any sort of diagnosis for undefined behavior:</p>\n<blockquote>\n<p id=\"so_2301372_2301426_0\">\u00a71.4.1:<br>\n  The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard except for those rules containing an explicit notation that \u201cno diagnostic is required\u201d <strong>or which are described as resulting in \u201cundefined behavior.\u201d</strong></br></p>\n</blockquote>\n<p>Emphasis mine. While I agree it may be nice, the compiler's have enough problem trying to be standards compliant, let alone teach the programmer how to program.</p>\n", "LastActivityDate": "2010-02-20T07:19:05.530", "CommentCount": "0", "CreationDate": "2010-02-20T07:19:05.530", "ParentId": "2301372", "Score": "1", "OwnerUserId": "87234"}, "bq_ids": {"n4140": {"so_2301372_2301426_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5769}}, "n3337": {"so_2301372_2301426_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5542}}, "n4659": {"so_2301372_2301426_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7226}}}, "2301427": {"Id": "2301427", "PostTypeId": "2", "Body": "<p>It all boils down to</p>\n<ul>\n<li><p><em>Quality of Implementation</em>: the more accurate and useful the warnings are, the better it is.  A compiler that always printed: \"This program may or may not invoke undefined behavior\" for every program, and then compiled it, is pretty useless, but is standards-compliant.  Thankfully, no one writes compilers such as these :-).</p></li>\n<li><p><em>Ease of determination</em>: a compiler may not be easily able to determine undefined behavior, unspecified behavior, or implementation-defined behavior.  Let's say you have a call stack that's 5 levels deep, with a <code>const char *</code> argument being passed from the top-level, to the last function in the chain, and the last function calls <code>printf()</code> with that <code>const char *</code> as the first argument.  Do you want the compiler to check that <code>const char *</code> to make sure it is correct?  (Assuming that the first function uses a literal string for that value.)  How about when the <code>const char *</code> is read from a file, but you know that the file will always contain valid format specifier for the values being printed?</p></li>\n<li><p><em>Success rate</em>:  A compiler may be able to detect many constructs that may or may not be undefined, unspecified, etc.; but with a very low \"success rate\".  In that case, the user doesn't want to see a lot of \"may be undefined\" messages\u2014too many spurious warning messages may hide real warning messages, or prompt a user to compile at \"low-warning\" setting.  That is bad.</p></li>\n</ul>\n<p>For your particular example, <code>gcc</code> gives a warning about \"may be undefined\".  It even warns for <code>printf()</code> format mismatch.</p>\n<p>But if your hope is for a compiler that issues a diagnostic for all undefined/unspecified cases, it is not clear if that should/can work.</p>\n<p>Let's say you have the following:</p>\n<pre><code>#include &lt;stdio.h&gt;\nvoid add_to(int *a, int *b)\n{\n    *a = ++*b;\n}\n\nint main(void)\n{\n    int i = 42;\n    add_to(&amp;i, &amp;i); /* bad */\n    printf(\"%d\\n\", i);\n    return 0;\n}\n</code></pre>\n<p>Should the compiler warn you about <code>*a = ++*b;</code> line?</p>\n<p>As <a href=\"https://stackoverflow.com/users/168225/gf\">gf</a> says in the comments, a compiler cannot check across translation units for undefined behavior.  Classic example is declaring a variable as a pointer in one file, and defining it as an array in another, see <a href=\"http://c-faq.com/aryptr/aryptr1.html\" rel=\"nofollow noreferrer\">comp.lang.c FAQ 6.1</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-02-20T09:04:05.073", "Score": "6", "CreationDate": "2010-02-20T07:19:27.923", "ParentId": "2301372", "CommentCount": "4", "OwnerUserId": "226621", "LastEditDate": "2017-05-23T10:31:15.870"}, "2301651": {"Id": "2301651", "PostTypeId": "2", "Body": "<p>Different compilers trap different conditions; most compilers have warning level options, GCC specifically has many, but -Wall -Werror will switch on most of the useful ones, and coerce them to errors. Use \\W4 \\WX for similar protection in VC++.  </p>\n<p>In GCC You could use -ansi -pedantic, but pedantic is what it says, and will throw up many irrelevant issues and make it hard to use much third party code.</p>\n<p>Either way, because compilers catch different errors, or produce different messages for the same error, it is therefore useful to use multiple compilers, not necessarily for deployment, but as a poor-man's static analysis.  Another approach for C code is to attempt to compile it as C++;  the stronger type checking of C++ generally results in better C code; but be sure that if you want C compilation to work, don't use the C++ compilation exclusively; you are likely to introduce C++ specific features.  Again this need not be deployed as C++, but just used as an additional check.</p>\n<p>Finally, compilers are generally built with a balance of performance and error checking; to check exhaustively would take time that many developers would not accept.  For this reason static analysers exist, for C there is the traditional lint, and the open-source splint.  C++ is more complex to statically analyse, and tools are often very expensive.  One of the best I have used is QAC++ from Programming Research.  I am not aware of any free or open source C++ analysers of any repute.</p>\n", "LastEditorUserId": "168986", "LastActivityDate": "2010-02-20T12:10:32.047", "Score": "1", "CreationDate": "2010-02-20T09:10:15.673", "ParentId": "2301372", "CommentCount": "1", "OwnerUserId": "168986", "LastEditDate": "2010-02-20T12:10:32.047"}, "2301372": {"ViewCount": "703", "Body": "<p>Can't a compiler warn (even better if it throws errors) when it notices a statement with undefined/unspecified/implementation-defined behaviour?</p>\n<p>Probably to flag a statement as error, the standard should say so, but it can warn the coder at least. Is there any technical difficulties in implementing such an option? Or is it merely impossible?</p>\n<p>Reason I got this question is, in statements like <code>a[i] = ++i;</code> won't it be knowing that the code is trying to reference a variable and modifying it in the same statement, before a sequence point is reached.</p>\n", "AcceptedAnswerId": "2301427", "Title": "Undefined/Unspecified/Implementation-defined behaviour warnings?", "CreationDate": "2010-02-20T06:56:02.807", "Id": "2301372", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2010-02-20T12:10:32.047", "Score": "4", "OwnerUserId": "183120", "Tags": "<c++><c><compiler-warnings><undefined><unspecified>", "AnswerCount": "6"}});