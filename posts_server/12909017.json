post_cb({"12909017": {"CommentCount": "3", "ViewCount": "962", "CreationDate": "2012-10-16T06:52:16.313", "LastActivityDate": "2012-10-16T08:03:10.963", "Title": "std::for_each compile error with g++, not VS2012", "AcceptedAnswerId": "12909556", "PostTypeId": "1", "Id": "12909017", "Score": "2", "Body": "<p>I have the following code (as much simplified as possible):</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing std::vector;\n\nenum class Foo {\n    BAR, BAZ\n};\n\nvoid print_to_file(const vector&lt;const vector&lt;Foo&gt; &gt;&amp; sequences) {\n    std::for_each(sequences.begin(), sequences.end(), [](const vector&lt;Foo&gt;&amp; sequence) {\n    });\n}\n\nint main(int argc, char **argv) {\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>when compiling with <code>g++ (SUSE Linux) 4.7.1 20120723 [gcc-4_7-branch revision 189773]</code> as <code>g++ --std=c++11 test.cpp</code> I get the following error message:</p>\n<pre><code>In file included from /usr/include/c++/4.7/x86_64-suse-linux/bits/c++allocator.h:34:0,\n                 from /usr/include/c++/4.7/bits/allocator.h:48,\n                 from /usr/include/c++/4.7/vector:62,\n                 from test.cpp:1:\n/usr/include/c++/4.7/ext/new_allocator.h: In instantiation of \u2018struct __gnu_cxx::new_allocator&lt;const std::vector&lt;Foo&gt; &gt;\u2019:\n/usr/include/c++/4.7/bits/allocator.h:89:11:   required from \u2018class std::allocator&lt;const std::vector&lt;Foo&gt; &gt;\u2019\n/usr/include/c++/4.7/bits/alloc_traits.h:89:43:   required from \u2018struct std::allocator_traits&lt;std::allocator&lt;const std::vector&lt;Foo&gt; &gt; &gt;\u2019\n/usr/include/c++/4.7/ext/alloc_traits.h:109:10:   required from \u2018struct __gnu_cxx::__alloc_traits&lt;std::allocator&lt;const std::vector&lt;Foo&gt; &gt; &gt;\u2019\n/usr/include/c++/4.7/bits/stl_vector.h:76:28:   required from \u2018struct std::_Vector_base&lt;const std::vector&lt;Foo&gt;, std::allocator&lt;const std::vector&lt;Foo&gt; &gt; &gt;\u2019\n/usr/include/c++/4.7/bits/stl_vector.h:208:11:   required from \u2018class std::vector&lt;const std::vector&lt;Foo&gt; &gt;\u2019\ntest.cpp:11:25:   required from here\n/usr/include/c++/4.7/ext/new_allocator.h:83:7: error: \u2018const _Tp* __gnu_cxx::new_allocator&lt;_Tp&gt;::address(__gnu_cxx::new_allocator&lt;_Tp&gt;::const_reference) const [with _Tp = const std::vector&lt;Foo&gt;; __gnu_cxx::new_allocator&lt;_Tp&gt;::const_pointer = const std::vector&lt;Foo&gt;*; __gnu_cxx::new_allocator&lt;_Tp&gt;::const_reference = const std::vector&lt;Foo&gt;&amp;]\u2019 cannot be overloaded\n/usr/include/c++/4.7/ext/new_allocator.h:79:7: error: with \u2018_Tp* __gnu_cxx::new_allocator&lt;_Tp&gt;::address(__gnu_cxx::new_allocator&lt;_Tp&gt;::reference) const [with _Tp = const std::vector&lt;Foo&gt;; __gnu_cxx::new_allocator&lt;_Tp&gt;::pointer = const std::vector&lt;Foo&gt;*; __gnu_cxx::new_allocator&lt;_Tp&gt;::reference = const std::vector&lt;Foo&gt;&amp;]\u2019\n</code></pre>\n<p>the same code compiles fine with VS2012, but fails badly under g++ and I've not the slightest idea how to interpret the error message.</p>\n", "Tags": "<c++><visual-c++><c++11><g++>", "OwnerUserId": "144746", "AnswerCount": "2"}, "12909556": {"ParentId": "12909017", "CommentCount": "3", "Body": "<p>I'm surprised you don't get problems elsewhere, as this <code>vector&lt;const vector&lt;Foo&gt; &gt;</code> is not a possible data type. </p>\n<p>The value_type of a <code>std::vector</code> must at minimum be copy constructible (C++03) or movable (C++11). If it is const, you cannot assign or move it. </p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "12909556", "Score": "5", "CreationDate": "2012-10-16T07:28:07.387", "LastActivityDate": "2012-10-16T07:28:07.387"}, "bq_ids": {"n4140": {"so_12909017_12910073_1": {"section_id": 6290, "quality": 1.0, "length": 4}}, "n3337": {"so_12909017_12910073_1": {"section_id": 6050, "quality": 1.0, "length": 4}}, "n4659": {"so_12909017_12910073_1": {"section_id": 7797, "quality": 1.0, "length": 4}}}, "12910073": {"ParentId": "12909017", "CommentCount": "1", "Body": "<p>The Allocator requirements used for standard containers doesn't allow for <code>const</code> objects to be held by the containers. C++11 17.6.3.5 \"Allocator requirements\" outlines the requirements for standard allocators using  a set of tables which start with Table 27.  In Table 27, the first definition is for the 'descriptive variables' <code>T</code>, <code>U</code>, and <code>C</code> which are defined as \"any <em>non-const</em>, non-reference object type\". The descriptive variables <code>X</code> and <code>Y</code>, used for the Allocator class defintions, are:</p>\n<blockquote>\n<p id=\"so_12909017_12910073_0\"><code>X</code> - an Allocator class for type <code>T</code></p>\n<p id=\"so_12909017_12910073_1\"><code>Y</code> - the corresponding Allocator class for type <code>U</code></p>\n</blockquote>\n<p>In summary, standard Allocators are defined in terms of parameterization by non-const types.</p>\n<p>There's an old GCC/libstdc++ bug for this (resolved as invalid) going back to 2004 (C++2003 has a similar limitation against storing const objects in containers, but it's simpler to show because the 2003 standard more straightforwardly says that the types of objects stored in containers must be 'Assignable').</p>\n<ul>\n<li><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=16875\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=16875</a></li>\n</ul>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "12910073", "Score": "3", "CreationDate": "2012-10-16T08:03:10.963", "LastActivityDate": "2012-10-16T08:03:10.963"}});