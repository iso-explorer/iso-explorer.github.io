post_cb({"bq_ids": {"n4140": {"so_48151598_48285782_0": {"length": 16, "quality": 1.0, "section_id": 6153}, "so_48151598_48285782_1": {"length": 14, "quality": 1.0, "section_id": 7213}}, "n3337": {"so_48151598_48285782_0": {"length": 16, "quality": 1.0, "section_id": 5916}, "so_48151598_48285782_1": {"length": 14, "quality": 1.0, "section_id": 6957}}, "n4659": {"so_48151598_48285782_0": {"length": 16, "quality": 1.0, "section_id": 7650}, "so_48151598_48285782_1": {"length": 14, "quality": 1.0, "section_id": 8722}}}, "48155296": {"Id": "48155296", "PostTypeId": "2", "Body": "<p>It appears to me that the easiest solution is to prove this backwards. If the first argument to <code>f</code> is the maximum argument, prove that the first argument is returned (fairly easy - the maximum argument <code>a</code> is by definition bigger than <code>b</code>). If the second argument is the maximum argument, prove that the second argument is returned. If the two are equal, show that there is no unique maximum element, so the second argument is still <em>a</em> maximum argument.</p>\n<p>Finally, prove that these three options are exhaustive. If a unique maximum argument is passed, it must be passed either as the first or the second argument, since <code>f</code> is binary.</p>\n", "LastActivityDate": "2018-01-08T17:36:06.043", "Score": "2", "CreationDate": "2018-01-08T17:36:06.043", "ParentId": "48151598", "CommentCount": "0", "OwnerUserId": "15416"}, "48285782": {"Id": "48285782", "PostTypeId": "2", "Body": "<p>Please appologize for my approximate ageing mathematic knowledge.</p>\n<p>Maximum for a closed subset of natural number (BN) can be defined as follow:</p>\n<pre><code>Max:(BN,BN) -&gt; BN\n(x \u220a BN)(a \u220a BN)(b \u220a BN)(x = Max(a,b)) =&gt; ( x=a &amp; a&gt;b | x=b )\n</code></pre>\n<p>where the symbol have the common mathemical signification.</p>\n<p>While your function could be rewritten as follow, where UN is the ensemble of <code>unsigned int</code>:</p>\n<pre><code>f:(UN,UN) -&gt; UN\n(x \u220a UN)(a \u220a UN)(b \u220a UN)(x = f(a,b)) =&gt; ( x=a &amp;&amp; a&gt;b || x=b )\n</code></pre>\n<p>Where symbol = is <code>operator==(unsigned int,unsigned int)</code>, etc...</p>\n<p>So the question reduces to know if the standard specifies that the mathematical structure(s) formed by the <code>unsigned integer</code> with C++ arithmetic operators and comparison operator is <em>isomorphic</em> to the matematical structures (classes,categories) formed by a closed subset of N with the common arithemtic operation and relations. I think the answer is yes, this is expressed in plain english:</p>\n<p><em>C++14 standard,<a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.rel#5\" rel=\"nofollow noreferrer\">[expr.rel]/5</a> (Relational Operators)</em></p>\n<blockquote>\n<p id=\"so_48151598_48285782_0\">If both operands (after conversions) are of arithmetic or enumeration type, each of the operators shall yield <code>true</code> if the specified relationship is true and <code>false</code> if it is false.</p>\n</blockquote>\n<p><em>C++14 standard, <a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.fundamental#4\" rel=\"nofollow noreferrer\">[basic.fundamental]/4</a> (Fundamental Types)</em></p>\n<blockquote>\n<p id=\"so_48151598_48285782_1\">Unsigned integers shall obey the laws of arithmetic modulo 2n where n is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>Then you could also proove that ({<code>true</code>,<code>false</code>},<code>&amp;&amp;</code>,<code>||</code>) is also isomorphic to boolean arithmetic by analysing the text in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.log.and\" rel=\"nofollow noreferrer\">[expr.log.and]</a>\n and <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.log.or\" rel=\"nofollow noreferrer\">[expr.log.or]</a></p>\n<hr>\n<p>I do not think that you should go further than showing that there is  this isomorphism because further would mean demonstrating axioms.</p>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-17T07:43:07.857", "Score": "4", "CreationDate": "2018-01-16T16:29:31.710", "ParentId": "48151598", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2018-01-17T07:43:07.857"}, "48268040": {"Id": "48268040", "PostTypeId": "2", "Body": "<p>I am unsure about what you want. Looking at a previous version, N3337, we can easily see that almost everything is specified:</p>\n<ul>\n<li>a and b starts with the calling values (Function 5.2.2 - 4)</li>\n<li>Calling a function executes the compound statement of the function body (Obvious, but where?)</li>\n<li>The statements are normally executed in order (Statements 6)</li>\n<li>If-statements execute the first sub-statement if condition is true (The If Statement 6.4.1)</li>\n<li>Relations actually work as expected (Relation operators 5.9 - 5)</li>\n<li>The return-statement returns the value to the caller of the function (The return statement 6.6.3)</li>\n</ul>\n<p>However, you attempt to start with f(expr_a, expr_b); and evaluating the arguments to f potentially requires a lot more; especially since they are not sequenced - and could be any function-call.</p>\n", "LastActivityDate": "2018-01-15T17:34:21.340", "Score": "1", "CreationDate": "2018-01-15T17:34:21.340", "ParentId": "48151598", "CommentCount": "0", "OwnerUserId": "5603247"}, "48151598": {"ViewCount": "454", "Body": "<p>Take the following C++14 code snippet:</p>\n<pre><code>unsigned int f(unsigned int a, unsigned int b){\n    if(a&gt;b)return a;\n    return b;\n}\n</code></pre>\n<p><strong>Statement:</strong> <em>the function <code>f</code> returns the maximum of its arguments.</em> </p>\n<p>Now, the statement is \"obviously\" true, yet I failed to prove it rigorously with respect to the <strong>ISO/IEC 14882:2014(E)</strong> specification.</p>\n<p><strong>First:</strong> I cannot state the property in a formal way.</p>\n<p>A formalized version could be: \nFor every statement <em>s</em>, when the abstract machine (which is defined in the spec.) is in state <em>P</em> and <em>s</em> looks like \"f(<em>expr_a</em>,<em>expr_b</em>)\" and 'f' in <em>s</em> is resolved to the function in question, <em>s(P).return=max(expr_a(P).return, expr_b(P).return)</em>.</p>\n<p>Here for a state <em>P</em> and expression <em>s</em>, <em>s(P)</em> is the state of the machine after evaluation of <em>s</em>. </p>\n<p><strong>Question:</strong> What would be a correctly formalized version of the statement? How to prove the statement using the properties imposed by the above mentioned specification? For each deductive step please reference the applicable snippet from the standard allowing said step (the number of the segment is enough).</p>\n<p>Edit: Maybe formalized in Coq</p>\n", "Title": "Rigorous proof of the following C++ code's property?", "CreationDate": "2018-01-08T13:45:43.917", "LastActivityDate": "2018-01-17T07:43:07.857", "CommentCount": "10", "LastEditDate": "2018-01-11T21:14:59.823", "PostTypeId": "1", "LastEditorUserId": "6695164", "Id": "48151598", "Score": "8", "OwnerUserId": "6695164", "Tags": "<c++><static-analysis><coq><proof-of-correctness>", "AnswerCount": "3"}});