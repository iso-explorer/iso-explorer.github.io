post_cb({"bq_ids": {"n4140": {"so_13782742_13782759_2": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_13782742_13782759_2": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_13782742_13782759_2": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "13782742": {"ViewCount": "95", "Body": "<p>Can someone explain to me how data is being utilized since I was messing around with the following code...:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct MyStruct {\npublic:\n    void print() {\n        printf(\"MyStruct.print():\\n\\ta: %i\\n\\tb: %i\\n\\n\", a, b);\n    }\n    void store() {\n        a = 2;\n        b = 3;\n    }\nprivate:\n    int a, b;\n};\n\ntypedef struct MyStruct2 {\npublic:\n    void print() {\n        printf(\"MyStruct2.print():\\na: %i\\nb: %i\\n\\n\", a, b);\n    }\n    void store() {\n        a = 1024;\n        b = 3077;\n    }\nprivate:\n    int a, b;\n};\n\nint main() {\n    void *ptr = malloc(sizeof(MyStruct)); // sizeof(MyStruct) == sizeof(MyStruct2)\nMyStruct* pstruct = (MyStruct*)ptr;\n\npstruct-&gt;store();\npstruct-&gt;print();\n\nMyStruct2* pstruct2 = (MyStruct2*)ptr;\n\npstruct2-&gt;store();\npstruct-&gt;print();\n\nreturn 0;\n}\n</code></pre>\n<p>and I got the following results:</p>\n<pre><code>MyStruct.print():\n        a: 2\n        b: 3\n\nMyStruct.print():\n        a: 1024\n        b: 3077\n</code></pre>\n<p>As you can see I didn't allocate any more memory for the pstruct2, yet I was able to access it. Can anyone explain to me, or at least give me a reference/tutorial to something that is close to this that explains it.</p>\n", "AcceptedAnswerId": "13782761", "Title": "Memory is being shared in C++?", "CreationDate": "2012-12-08T22:49:30.430", "Id": "13782742", "CommentCount": "1", "LastEditDate": "2012-12-08T22:59:09.070", "PostTypeId": "1", "LastEditorUserId": "827263", "LastActivityDate": "2012-12-08T22:59:09.070", "Score": "0", "OwnerUserId": "1244015", "Tags": "<c++>", "AnswerCount": "2"}, "13782759": {"Id": "13782759", "PostTypeId": "2", "Body": "<p>Undefined behaviour, which happens to successfully pretend it works.</p>\n<blockquote>\n<p id=\"so_13782742_13782759_0\">3.10 Lvalues and rvalues [basic.lval]</p>\n<p id=\"so_13782742_13782759_1\">...</p>\n<p id=\"so_13782742_13782759_2\">10 If a program attempts to access the stored value of an object through a glvalue of other than\n  one of the following types the behavior is undefined:</p>\n<p id=\"so_13782742_13782759_3\">\u2014 the dynamic type of the object</p>\n</blockquote>\n", "LastActivityDate": "2012-12-08T22:51:53.613", "CommentCount": "0", "CreationDate": "2012-12-08T22:51:53.613", "ParentId": "13782742", "Score": "0", "OwnerUserId": "390807"}, "13782761": {"Id": "13782761", "PostTypeId": "2", "Body": "<p>Both <code>pstruct</code> and <code>pstruct2</code> point to the same location in memory (Since you assigned the address stored in <code>ptr</code> to both) and thus the data inserted by the <code>MyStruct::store</code> method was overwritten by the <code>MyStruct2::store</code> method.</p>\n<p>In other words, this is happening because you are explicitly making it happen. If your two classes weren't identical or if the compiler had produced different memory layouts of them, you would've possibly read out garbage data.</p>\n<hr>\n<p>Basically, C++ allows you to write into any dynamically allocated memory as much as you want, happily ignorant and oblivious of the fact that you had previously used this memory for another object.</p>\n</hr>", "OwnerDisplayName": "user308323", "LastActivityDate": "2012-12-08T22:51:57.180", "Score": "4", "CreationDate": "2012-12-08T22:51:57.180", "ParentId": "13782742", "CommentCount": "0"}});