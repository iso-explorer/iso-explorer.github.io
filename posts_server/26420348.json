post_cb({"26420583": {"ParentId": "26420348", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-10-17T08:05:58.153", "Score": "3", "LastEditorUserId": "256138", "LastEditDate": "2014-10-17T09:18:09.890", "Id": "26420583", "OwnerUserId": "256138", "Body": "<p>The standard states explicitly what happens when you increment the pointer to the last element. It gives you a value that can only be used as comparison to check if you're at or before the end of the array or not. The pointer may well point to validly allocated memory for some other object, but that is complete undefined (implementation defined?) behaviour and using that pointer as such is definitely undefined behaviour.</p>\n<p>What I'm getting at is that the one-past-the-end pointer is just that: it is the pointer you get when you increment the pointer to the last element, to mark the end of the array in a very cheap way. But do note that comparing pointers of unrelated objects is completely nonsensical (and even undefined behaviour if I'm not mistaken). So the fact that there might be overlap in pointer \"values\" across different objects is a non-issue, as in exploiting this you enter the Land of Undefined Behaviour..</p>\n", "LastActivityDate": "2014-10-17T09:18:09.890"}, "26420974": {"ParentId": "26420348", "PostTypeId": "2", "CommentCount": "22", "CreationDate": "2014-10-17T08:30:39.247", "Score": "34", "LastEditorUserId": "649665", "LastEditDate": "2014-10-17T08:38:02.013", "Id": "26420974", "OwnerUserId": "649665", "Body": "<p>An implementation must allow a pointer to one past the end to\nexist.  How it does this is its business.  On many machines, you\ncan safely put any value into a pointer, without risk (unless\nyou dereference it); on such systems, the one past the end\npointer may point to unmapped memory\u2014I've\nactually encountered a case under Windows where it did. </p>\n<p>On other machines, just loading a pointer to unmapped memory\ninto a register will trap, causing the program to crash.  On\nsuch machines, the implementation must ensure that this doesn't\nhappen, either by refusing to use the last byte or word of\nallocated memory, or by ensuring that all use of the pointer\nother than dereferencing it avoids any instructions which might\ncause the hardware to treat it as an invalid pointer.  (Most such\nsystems have separate address and data registers, and will only\ntrap if the pointer is loaded into an address register.  If the\ndata registers are large enough, the compiler can safely load\nthe pointer into a data register for e.g. comparison.  This is\noften necessary anyway, as the address registers don't always\nsupport comparison.)</p>\n<p>Re your last question: C and C++ are exactly identical in this respect; C++ simply took over the rules from C.</p>\n", "LastActivityDate": "2014-10-17T08:38:02.013"}, "26420772": {"ParentId": "26420348", "CommentCount": "1", "CreationDate": "2014-10-17T08:18:38.953", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "26420772", "Score": "4", "Body": "<p>You're half right. Suppose a hypothetical implementation uses linearly addressed memory and pointers that are represented as 16-bit unsigned integers. Suppose also that the null pointer is represented as zero. And finally, suppose you ask to for 16 bytes of memory, with <code>char *p = malloc(16);</code>. Then it's guaranteed that you will get a pointer of which the numeric value is less than 65520. The value 65520 itself wouldn't be valid, because as you rightly point out, assuming the allocation succeeded, <code>p + 16</code> is a valid pointer that must not be a null pointer.</p>\n<p>However, suppose now that a hypothetical implementation uses linearly addressed memory and pointers that are represented as 32-bit unsigned integers, but only has an address space of 16 bits. Suppose also again that the null pointer is represented as zero. And finally, suppose again that you ask for 16 bytes of memory, with <code>char *p = malloc(16);</code>. Then it's only guaranteed that you will get a pointer of which the numeric value is less than or equal to 65520. The value 65520 itself would be valid, so long as the implementation makes sure that adding 16 to that gives you the value 65536, and that subtracting 16 gets you back to 65520. This is valid even if no memory (physical or virtual) exists at all at address 65536.</p>\n", "LastActivityDate": "2014-10-17T08:18:38.953"}, "26420348": {"CommentCount": "13", "AcceptedAnswerId": "26420974", "PostTypeId": "1", "LastEditorUserId": "1857518", "CreationDate": "2014-10-17T07:50:52.737", "LastActivityDate": "2016-10-06T18:45:22.470", "LastEditDate": "2014-10-17T18:34:03.083", "ViewCount": "1843", "FavoriteCount": "2", "Title": "Can C++ array end at memory boundary?", "Id": "26420348", "Score": "30", "Body": "<p>C++ standard (and C for that matter) allows to create (not dereference though) a pointer to one element past the end of the array. Does this mean that an array will never be allocated at such a location that its last element ends at the memory boundary? I understand that in practice some/all implementation might follow this convention, but which one the following is true:</p>\n<ol>\n<li>It's actually false, and an array might end at memory boundary, OR</li>\n<li>It is mandated by C++ standard to end at least one element's worth of memory before the boundary, OR</li>\n<li>Neither 1, nor 2, but it is still like that in actual compilers because it makes  implementation easier.</li>\n</ol>\n<p>Is anything different for the case of C?</p>\n<p><strong>Update:</strong>\nIt seems like <strong>1</strong> is the correct answer. See answer from James Kanze below, and also see <code>efence</code> (<a href=\"http://linux.die.net/man/3/efence\">http://linux.die.net/man/3/efence</a> - thanks to Michael Chastain for the pointer to it)</p>\n", "Tags": "<c++><c><arrays><c++11>", "OwnerUserId": "1857518", "AnswerCount": "5"}, "26420594": {"ParentId": "26420348", "CommentCount": "2", "CreationDate": "2014-10-17T08:06:44.753", "OwnerUserId": "660894", "PostTypeId": "2", "Id": "26420594", "Score": "-2", "Body": "<p>This depends on implementation. At least in visual C++ without using any from of array bound checking,  you could create a pointer any number of elements past the end of the array. If you dereference it it will still work as long as the memory address that you are accessing is within the allocated heap/stack of your program. You will read/modify whatever the value in that memory location. If the address is outside the allocated memory space it will give an error.</p>\n<p>Debuggers has checks to detect these, as this kind of coding create bugs very difficult to track.</p>\n", "LastActivityDate": "2014-10-17T08:06:44.753"}, "26421176": {"ParentId": "26420348", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2014-10-17T08:43:02.733", "Score": "6", "LastEditorUserId": "1846177", "LastEditDate": "2014-10-17T09:26:40.393", "Id": "26421176", "OwnerUserId": "1846177", "Body": "<p>There's an interesting passage at \u00a73.9.2/3 [Compound types]:</p>\n<blockquote>\n<p id=\"so_26420348_26421176_0\">The type of a pointer to void or a pointer to an object type is called an object pointer type. [...] A valid value of an object pointer type represents either the address of a byte in memory (1.7) or a null pointer (4.10).</p>\n</blockquote>\n<p>Together with the text at \u00a75.7/5 [Additive operators]:</p>\n<blockquote>\n<p id=\"so_26420348_26421176_1\">[...] Moreover, if the expression P points to the last element of an array object,\n  the expression (P)+1 points one past the last element of the array object, and if the expression Q points\n  one past the last element of an array object, the expression (Q)-1 points to the last element of the array\n  object.</p>\n</blockquote>\n<p>it seems that an array ending at the last byte in memory can not be allocated, if there is a requirement that the one-past-the-end pointer must be valid. If the one-past-the-end pointer is allowed to be invalid, I don't know the answer.</p>\n<p>The section \u00a73.7.4.2/4 [Deallocation functions] states that:</p>\n<blockquote>\n<p id=\"so_26420348_26421176_2\">The effect of using an invalid pointer value\n  (including passing it to a deallocation function) is undefined.</p>\n</blockquote>\n<p>Thus if comparing a one-past-the-end pointer for an allocated array must be supported, the one-past-the-end pointer must be valid.</p>\n<p>Based on the comments I got, I assume that an implementation can allocate an array without having to care about if the array's one-past-the-end pointer is usable or not. However I would like to find out the relevant passages in the standard for this.</p>\n", "LastActivityDate": "2014-10-17T09:26:40.393"}, "bq_ids": {"n4140": {"so_26420348_26421176_2": {"section_id": 7187, "quality": 0.9090909090909091, "length": 10}, "so_26420348_26421176_1": {"section_id": 6142, "quality": 1.0, "length": 29}, "so_26420348_26421176_0": {"section_id": 7223, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_26420348_26421176_2": {"section_id": 6927, "quality": 0.9090909090909091, "length": 10}, "so_26420348_26421176_1": {"section_id": 5906, "quality": 1.0, "length": 29}, "so_26420348_26421176_0": {"section_id": 6967, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_26420348_26421176_2": {"section_id": 8695, "quality": 0.9090909090909091, "length": 10}, "so_26420348_26421176_0": {"section_id": 8732, "quality": 0.7083333333333334, "length": 17}}}});