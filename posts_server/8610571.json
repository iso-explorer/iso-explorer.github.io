post_cb({"8610728": {"ParentId": "8610571", "LastEditDate": "2014-12-04T07:13:21.100", "CommentCount": "12", "CreationDate": "2011-12-22T23:09:54.930", "OwnerUserId": "500104", "LastEditorUserId": "908939", "PostTypeId": "2", "Id": "8610728", "Score": "261", "Body": "<p>First, \"ref-qualifiers for *this\" is a just a \"marketing statement\". The type of <code>*this</code> never changes, see the bottom of this post. It's way easier to understand it with this wording though.</p>\n<p>Next, the following code chooses the function to be called based on the <em>ref-qualifier</em> of the \"implicit object parameter\" of the function<sup>\u2020</sup>:</p>\n<pre><code>// t.cpp\n#include &lt;iostream&gt;\n\nstruct test{\n  void f() &amp;{ std::cout &lt;&lt; \"lvalue object\\n\"; }\n  void f() &amp;&amp;{ std::cout &lt;&lt; \"rvalue object\\n\"; }\n};\n\nint main(){\n  test t;\n  t.f(); // lvalue\n  test().f(); // rvalue\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>$ clang++ -std=c++0x -stdlib=libc++ -Wall -pedantic t.cpp\n$ ./a.out\nlvalue object\nrvalue object\n</code></pre>\n<p>The whole thing is done to allow you to take advantage of the fact when the object the function is called on is an rvalue (unnamed temporary, for example). Take the following code as a further example:</p>\n<pre><code>struct test2{\n  std::unique_ptr&lt;int[]&gt; heavy_resource;\n\n  test2()\n    : heavy_resource(new int[500]) {}\n\n  operator std::unique_ptr&lt;int[]&gt;() const&amp;{\n    // lvalue object, deep copy\n    std::unique_ptr&lt;int[]&gt; p(new int[500]);\n    for(int i=0; i &lt; 500; ++i)\n      p[i] = heavy_resource[i];\n\n    return p;\n  }\n\n  operator std::unique_ptr&lt;int[]&gt;() &amp;&amp;{\n    // rvalue object\n    // we are garbage anyways, just move resource\n    return std::move(heavy_resource);\n  }\n};\n</code></pre>\n<p>This may be a bit contrived, but you should get the idea.</p>\n<p>Note that you can combine the <em>cv-qualifiers</em> (<code>const</code> and <code>volatile</code>) and <em>ref-qualifiers</em> (<code>&amp;</code> and <code>&amp;&amp;</code>).</p>\n<hr>\n<p><sup>Note: Many standard quotes and overload resolution explanation after here!</sup></p>\n<p>\u2020 To understand how this works, and why @Nicol Bolas' answer is at least partly wrong, we have to dig in the C++ standard for a bit (the part explaining why @Nicol's answer is wrong is at the bottom, if you're only interested in that).</p>\n<p>Which function is going to be called is determined by a process called <em>overload resolution</em>. This process is fairly complicated, so we'll only touch the bit that is important to us.</p>\n<p>First, it's important to see how overload resolution for member functions works:</p>\n<p><code>\u00a713.3.1 [over.match.funcs]</code></p>\n<blockquote>\n<p id=\"so_8610571_8610728_0\">p2 The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list. So that argument and parameter lists are comparable within this heterogeneous set, <strong>a member function is considered to have an extra parameter, called the implicit object parameter, which represents the object for which the member function has been called</strong>. [...]</p>\n<p id=\"so_8610571_8610728_1\">p3 Similarly, when appropriate, the context can construct an argument list that contains an <em>implied object argument</em> to denote the object to be operated on.</p>\n</blockquote>\n<p>Why do we even need to compare member and non-member functions? Operator overloading, that's why. Consider this:</p>\n<pre><code>struct foo{\n  foo&amp; operator&lt;&lt;(void*); // implementation unimportant\n};\n\nfoo&amp; operator&lt;&lt;(foo&amp;, char const*); // implementation unimportant\n</code></pre>\n<p>You'd certainly want the following to call the free function, don't you?</p>\n<pre><code>char const* s = \"free foo!\\n\";\nfoo f;\nf &lt;&lt; s;\n</code></pre>\n<p>That's why member and non-member functions are included in the so-called overload-set. To make the resolution less complicated, the bold part of the standard quote exists. Additionally, this is the important bit for us (same clause):</p>\n<blockquote>\n<p id=\"so_8610571_8610728_2\">p4 For non-static member functions, the type of the implicit object parameter is</p>\n<ul>\n<li><p id=\"so_8610571_8610728_3\">\u201clvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared without a <em>ref-qualifier</em> or with the <code>&amp;</code> <em>ref-qualifier</em></p></li>\n<li><p id=\"so_8610571_8610728_4\">\u201crvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared with the <code>&amp;&amp;</code> <em>ref-qualifier</em></p></li>\n</ul>\n<p id=\"so_8610571_8610728_5\">where <code>X</code> is the class of which the function is a member and <em>cv</em> is the cv-qualification on the member function declaration. [...]</p>\n<p id=\"so_8610571_8610728_6\">p5 During overload resolution [...] [t]he implicit object parameter [...] retains its identity since conversions on the corresponding argument shall obey these additional rules:</p>\n<ul>\n<li><p id=\"so_8610571_8610728_7\">no temporary object can be introduced to hold the argument for the implicit object parameter; and</p></li>\n<li><p id=\"so_8610571_8610728_8\">no user-defined conversions can be applied to achieve a type match with it</p></li>\n</ul>\n<p id=\"so_8610571_8610728_9\">[...]</p>\n</blockquote>\n<p>(The last bit just means that you can't cheat overload resolution based on implicit conversions of the object a member function (or operator) is called on.)</p>\n<p>Let's take the first example at the top of this post. After the aforementioned transformation, the overload-set looks something like this:</p>\n<pre><code>void f1(test&amp;); // will only match lvalues, linked to 'void test::f() &amp;'\nvoid f2(test&amp;&amp;); // will only match rvalues, linked to 'void test::f() &amp;&amp;'\n</code></pre>\n<p>Then the argument list, containing an <em>implied object argument</em>, is matched against the parameter-list of every function contained in the overload-set. In our case, the argument list will only contain that object argument. Let's see how that looks like:</p>\n<pre><code>// first call to 'f' in 'main'\ntest t;\nf1(t); // 't' (lvalue) can match 'test&amp;' (lvalue reference)\n       // kept in overload-set\nf2(t); // 't' not an rvalue, can't match 'test&amp;&amp;' (rvalue reference)\n       // taken out of overload-set\n</code></pre>\n<p>If, after all overloads in the set are tested, only one remains, the overload resolution succeeded and the function linked to that transformed overload is called. The same goes for the second call to 'f':</p>\n<pre><code>// second call to 'f' in 'main'\nf1(test()); // 'test()' not an lvalue, can't match 'test&amp;' (lvalue reference)\n            // taken out of overload-set\nf2(test()); // 'test()' (rvalue) can match 'test&amp;&amp;' (rvalue reference)\n            // kept in overload-set\n</code></pre>\n<p>Note however that, had we not provided any <em>ref-qualifier</em> (and as such not overloaded the function), that <code>f1</code> <em>would</em> match an rvalue (still <code>\u00a713.3.1</code>):</p>\n<blockquote>\n<p id=\"so_8610571_8610728_10\">p5 [...] For non-static member functions declared without a <em>ref-qualifier</em>, an additional rule applies:</p>\n<ul>\n<li>even if the implicit object parameter is not <code>const</code>-qualified, an rvalue can be bound to the parameter as long as in all other respects the argument can be converted to the type of the implicit object parameter.</li>\n</ul>\n</blockquote>\n<pre><code>struct test{\n  void f() { std::cout &lt;&lt; \"lvalue or rvalue object\\n\"; }\n};\n\nint main(){\n  test t;\n  t.f(); // OK\n  test().f(); // OK too\n}\n</code></pre>\n<hr>\n<p>Now, onto why @Nicol's answer is atleast partly wrong. He says:</p>\n<blockquote>\n<p id=\"so_8610571_8610728_11\">Note that this declaration changes the type of <code>*this</code>.</p>\n</blockquote>\n<p>That is wrong, <code>*this</code> is <em>always</em> an lvalue:</p>\n<p><code>\u00a75.3.1 [expr.unary.op] p1</code></p>\n<blockquote>\n<p id=\"so_8610571_8610728_12\">The unary <code>*</code> operator performs <em>indirection</em>: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type <strong>and the result is an lvalue</strong> referring to the object or function to which the expression points.</p>\n</blockquote>\n<p><code>\u00a79.3.2 [class.this] p1</code></p>\n<blockquote>\n<p id=\"so_8610571_8610728_13\">In the body of a non-static (9.3) member function, the keyword <code>this</code> is a prvalue expression whose value is the address of the object for which the function is called. The type of <code>this</code> in a member function of a class <code>X</code> is <code>X*</code>. [...]</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2014-12-04T07:13:21.100"}, "8614126": {"ParentId": "8610571", "CommentCount": "2", "Body": "<p>There is an additional use case for the lvalue ref-qualifier form. C++98 has language that allows non-<code>const</code> member functions to be called for class instances that are rvalues. This leads to all kinds of weirdness that is against the very concept of rvalueness and deviates from how built-in types work:</p>\n<pre><code>struct S {\n \u00a0S&amp; operator ++(); \n  S* operator &amp;(); \n};\nS() = S();      // rvalue as a left-hand-side of assignment!\nS&amp; foo = ++S(); // oops, dangling reference\n&amp;S();           // taking address of rvalue...\n</code></pre>\n<p>Lvalue ref-qualifiers solve these problems:</p>\n<pre><code>struct S {\n  S&amp; operator ++() &amp;;\n  S* operator &amp;() &amp;;\n  const S&amp; operator =(const S&amp;) &amp;;\n};\n</code></pre>\n<p>Now the operators work like those of the builtin types, accepting only lvalues.</p>\n", "OwnerUserId": "279597", "PostTypeId": "2", "Id": "8614126", "Score": "68", "CreationDate": "2011-12-23T09:14:10.377", "LastActivityDate": "2011-12-23T09:14:10.377"}, "8610714": {"ParentId": "8610571", "LastEditDate": "2011-12-23T18:03:27.867", "CommentCount": "11", "CreationDate": "2011-12-22T23:05:16.777", "OwnerUserId": "734069", "LastEditorUserId": "734069", "PostTypeId": "2", "Id": "8610714", "Score": "25", "Body": "<p>Let's say you have two functions on a class, both with the same name and signature. But one of them is declared <code>const</code>:</p>\n<pre><code>void SomeFunc() const;\nvoid SomeFunc();\n</code></pre>\n<p>If a class instance is not <code>const</code>, overload resolution will preferentially select the non-const version. If the instance is <code>const</code>, the user can only call the <code>const</code> version. And the <code>this</code> pointer is a <code>const</code> pointer, so the instance cannot be changed.</p>\n<p>What \"r-value reference for this` does is allow you to add another alternative:</p>\n<pre><code>void RValueFunc() &amp;&amp;;\n</code></pre>\n<p>This allows you to have a function that can <em>only</em> be called if the user calls it through a proper r-value. So if this is in the type <code>Object</code>:</p>\n<pre><code>Object foo;\nfoo.RValueFunc(); //error: no `RValueFunc` version exists that takes `this` as l-value.\nObject().RValueFunc(); //calls the non-const, &amp;&amp; version.\n</code></pre>\n<p>This way, you can specialize behavior based on whether the object is being accessed via an r-value or not.</p>\n<p>Note that you are not allowed to overload between the r-value reference versions and the non-reference versions. That is, if you have a member function name, all of its versions either use the l/r-value qualifiers on <code>this</code>, or none of them do. You can't do this:</p>\n<pre><code>void SomeFunc();\nvoid SomeFunc() &amp;&amp;;\n</code></pre>\n<p>You must do this:</p>\n<pre><code>void SomeFunc() &amp;;\nvoid SomeFunc() &amp;&amp;;\n</code></pre>\n<p>Note that this declaration changes the type of <code>*this</code>. This means that the <code>&amp;&amp;</code> versions all access members as r-value references. So it becomes possible to easily move from within the object. The example given in the first version of the proposal is (note: the following may not be correct with the final version of C++11; it's straight from the initial \"r-value from this\" proposal):</p>\n<pre><code>class X {\n   std::vector&lt;char&gt; data_;\npublic:\n   // ...\n   std::vector&lt;char&gt; const &amp; data() const &amp; { return data_; }\n   std::vector&lt;char&gt; &amp;&amp; data() &amp;&amp; { return data_; }\n};\n\nX f();\n\n// ...\nX x;\nstd::vector&lt;char&gt; a = x.data(); // copy\nstd::vector&lt;char&gt; b = f().data(); // move\n</code></pre>\n", "LastActivityDate": "2011-12-23T18:03:27.867"}, "8610571": {"CommentCount": "0", "CreationDate": "2011-12-22T22:47:58.480", "PostTypeId": "1", "AcceptedAnswerId": "8610728", "LastEditorUserId": "1381108", "LastActivityDate": "2014-12-04T07:13:21.100", "LastEditDate": "2014-05-13T16:50:43.460", "ViewCount": "19189", "FavoriteCount": "117", "Title": "What is \"rvalue reference for *this\"?", "Id": "8610571", "Score": "205", "Body": "<p>Came across a proposal called \"rvalue reference for *this\" in clang's <a href=\"http://clang.llvm.org/cxx_status.html\">C++11 status page</a>.</p>\n<p>I've read quite a bit about rvalue references and understood them, but I don't think I know about this. I also couldn't find much resources on the web using the terms.</p>\n<p>There's a link to the proposal paper on the page: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm\">N2439</a> (Extending move semantics to *this), but I'm also not getting much examples from there.</p>\n<p>What is this feature about? </p>\n", "Tags": "<c++><c++11><move-semantics><c++-faq><qualifiers>", "OwnerUserId": "365079", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8610571_8610728_12": {"section_id": 6064, "quality": 0.9, "length": 18}, "so_8610571_8610728_0": {"section_id": 566, "quality": 0.9459459459459459, "length": 35}, "so_8610571_8610728_1": {"section_id": 567, "quality": 0.9333333333333333, "length": 14}, "so_8610571_8610728_7": {"section_id": 569, "quality": 1.0, "length": 9}, "so_8610571_8610728_6": {"section_id": 569, "quality": 1.0, "length": 16}, "so_8610571_8610728_13": {"section_id": 5895, "quality": 0.9444444444444444, "length": 17}, "so_8610571_8610728_4": {"section_id": 568, "quality": 1.0, "length": 5}, "so_8610571_8610728_5": {"section_id": 568, "quality": 1.0, "length": 8}, "so_8610571_8610728_2": {"section_id": 568, "quality": 0.875, "length": 7}, "so_8610571_8610728_10": {"section_id": 569, "quality": 0.8888888888888888, "length": 8}, "so_8610571_8610728_3": {"section_id": 568, "quality": 1.0, "length": 6}, "so_8610571_8610728_8": {"section_id": 569, "quality": 1.0, "length": 7}}, "n3337": {"so_8610571_8610728_2": {"section_id": 559, "quality": 0.875, "length": 7}, "so_8610571_8610728_0": {"section_id": 557, "quality": 0.9459459459459459, "length": 35}, "so_8610571_8610728_1": {"section_id": 558, "quality": 0.9333333333333333, "length": 14}, "so_8610571_8610728_7": {"section_id": 560, "quality": 1.0, "length": 9}, "so_8610571_8610728_6": {"section_id": 560, "quality": 1.0, "length": 16}, "so_8610571_8610728_13": {"section_id": 5666, "quality": 0.9444444444444444, "length": 17}, "so_8610571_8610728_4": {"section_id": 559, "quality": 1.0, "length": 5}, "so_8610571_8610728_5": {"section_id": 559, "quality": 1.0, "length": 8}, "so_8610571_8610728_12": {"section_id": 5832, "quality": 0.9, "length": 18}, "so_8610571_8610728_10": {"section_id": 560, "quality": 0.8888888888888888, "length": 8}, "so_8610571_8610728_3": {"section_id": 559, "quality": 1.0, "length": 6}, "so_8610571_8610728_8": {"section_id": 560, "quality": 1.0, "length": 7}}, "n4659": {"so_8610571_8610728_12": {"section_id": 7560, "quality": 0.9, "length": 18}, "so_8610571_8610728_0": {"section_id": 589, "quality": 0.9459459459459459, "length": 35}, "so_8610571_8610728_13": {"section_id": 7378, "quality": 0.9444444444444444, "length": 17}, "so_8610571_8610728_1": {"section_id": 590, "quality": 0.9333333333333333, "length": 14}, "so_8610571_8610728_6": {"section_id": 592, "quality": 0.75, "length": 12}, "so_8610571_8610728_8": {"section_id": 592, "quality": 1.0, "length": 7}, "so_8610571_8610728_4": {"section_id": 591, "quality": 1.0, "length": 5}, "so_8610571_8610728_5": {"section_id": 591, "quality": 1.0, "length": 8}, "so_8610571_8610728_2": {"section_id": 591, "quality": 0.875, "length": 7}, "so_8610571_8610728_10": {"section_id": 592, "quality": 0.8888888888888888, "length": 8}, "so_8610571_8610728_3": {"section_id": 591, "quality": 1.0, "length": 6}, "so_8610571_8610728_7": {"section_id": 592, "quality": 0.6666666666666666, "length": 6}}}});