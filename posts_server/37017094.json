post_cb({"37018059": {"ParentId": "37017094", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_37017094_37018059_0\">Why do gcc and clang allow me to construct an abstract class?</p>\n</blockquote>\n<p>Because they're broken, according to the standard.</p>\n<p>Section 10.4 defines how abstract classes work. It contains this line (in C++14):</p>\n<blockquote>\n<p id=\"so_37017094_37018059_1\">no objects of an abstract class can be created except as subobjects of a class derived from it.</p>\n</blockquote>\n<p>The initialization rules for references with braced-init-lists will construct a temporary and bind it to the reference. Temporaries are objects. As such, the code you wrote above will attempt to create an \"object of an abstract class\" as something other than a \"subobject of a class derived from it.\"</p>\n<p>Something the standard expressly forbids. There is no ambiguity in the standard in this regard. While 10.4, p3 does specify places that the compiler is required to out-right error if you type them (declaring abstract classes as function parameters, explicit conversions, etc), the standard still requires implementations to forbid the construction of an abstract class as something other than a \"subobject of a class derived from it.\"</p>\n<p>A temporary is not a \"subobject of a class derived from it.\" And therefore, compilers are obligated to forbid this.</p>\n<p>Any compiler which does not has a bug.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2016-05-04T04:00:20.443", "Id": "37018059", "Score": "16", "CreationDate": "2016-05-04T03:47:28.113", "LastActivityDate": "2016-05-04T04:00:20.443"}, "bq_ids": {"n4140": {"so_37017094_37018059_1": {"section_id": 7019, "quality": 1.0, "length": 9}}, "n3337": {"so_37017094_37018059_1": {"section_id": 6765, "quality": 1.0, "length": 9}}, "n4659": {"so_37017094_37018059_1": {"section_id": 8516, "quality": 1.0, "length": 9}}}, "37017094": {"CommentCount": "12", "AcceptedAnswerId": "37018059", "PostTypeId": "1", "LastEditorUserId": "3777958", "CreationDate": "2016-05-04T01:46:38.273", "LastActivityDate": "2016-05-04T07:58:18.870", "LastEditDate": "2016-05-04T07:58:18.870", "ViewCount": "382", "FavoriteCount": "2", "Title": "Why do gcc and clang allow me to construct an abstract class?", "Id": "37017094", "Score": "23", "Body": "<p>The following code compiles on a wide range of gcc and clang versions - when compiled and run with gcc 5.3.1, it prints </p>\n<blockquote>\n<p id=\"so_37017094_37017094_0\">A()</p>\n</blockquote>\n<p>then aborts with a pure virtual call error.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass A\n{\npublic:\n    A() {\n        printf(\"A()\\n\");\n    }\n    virtual void b() const = 0;\n};\n\nint main()\n{\n    const A&amp; a{};\n    a.b();\n    return 0;\n}\n</code></pre>\n<p>I realise binding a reference to a temporary is not ideal (though I <em>think</em> this case is covered by some sort of lifetime extension) - but it also works when trying to call a method that takes a const reference like:</p>\n<pre><code>Foo({});\n</code></pre>\n<p>For convenience here's an example of it compiling with clang 3.2: <a href=\"https://gcc.godbolt.org/#compilers:!((compiler:clang32,options:%27-std%3Dc%2B%2B11%27,source:%27%23include+%3Cstdio.h%3E%0A%0Aclass+A%0A%7B%0A++public:%0A++A()+%7B%0A++++printf(%22A()%5Cn%22)%3B%0A++%7D%0A++virtual+void+b()+const+%3D+0%3B%0A%7D%3B%0A%0Aint+main()%0A%7B%0A++const+A%26+a%7B%7D%3B%0A++a.b()%3B%0A++return+0%3B%0A%7D%27)),filterAsm:(colouriseAsm:!t,commentOnly:!t,directives:!t,labels:!t),version:3\">Compiler Explorer</a></p>\n", "Tags": "<c++><gcc><clang><abstract-class><pure-virtual>", "OwnerUserId": "6288451", "AnswerCount": "1"}});