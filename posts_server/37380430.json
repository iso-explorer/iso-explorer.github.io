post_cb({"37380430": {"CommentCount": "3", "AcceptedAnswerId": "37380652", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-05-22T22:45:01.340", "LastActivityDate": "2016-05-22T23:24:51.890", "LastEditDate": "2017-05-23T12:31:45.883", "ViewCount": "98", "FavoriteCount": "1", "Title": "Why `s.clear(ios::badbit);` below? Why not `s.clear(ios::failbit);`?", "Id": "37380430", "Score": "4", "Body": "<p>I was looking into <a href=\"https://stackoverflow.com/q/30563673/3694387\">this question</a> and I have no problem understanding the two answers given to it. But I'm not sure I understood the <code>s.clear(ios::badbit);</code> in the statement highlighted below with the comment <code>// set state</code>. For instance, why not <code>s.clear(ios::failbit);</code> instead?</p>\n<blockquote id=\"so_37380430_37380430_0\">\n<pre><code>#include &lt;istream&gt;\n#include &lt;complex&gt;\n\nusing namespace std;\n\nistream&amp; operator&gt;&gt;(istream&amp; s, complex&lt;double&gt;&amp; a)\n{\n    // input formats for a complex; \"f\" indicates a float:\n    //\n    //   f\n    //   (f)\n    //   (f, f)\n\n    double re = 0, im = 0;\n    char c = 0;\n\n    s &gt;&gt; c;\n    if( c == '(' ) {\n        s &gt;&gt; re &gt;&gt; c;\n        if( c == ',' ) s &gt;&gt; im &gt;&gt; c;\n        if( c != ')' ) s.clear(ios::badbit);  // set state\n    }\n    else {\n        s.putback(c);\n        s &gt;&gt; re;\n    }\n\n    if( s ) a = complex&lt;double&gt;(re, im);\n    return s;\n} \n</code></pre>\n</blockquote>\n", "Tags": "<c++><istream>", "OwnerUserId": "1577873", "AnswerCount": "2"}, "37380639": {"ParentId": "37380430", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_37380430_37380639_0\">For instance, why not s.clear(ios::failbit); instead?</p>\n</blockquote>\n<p><code>std::ios::failbit</code> is intended for recoverable errors. How do you recover from an input stream that is supposed to contain a pair of numbers separated by a comma and enclosed in parentheses after you've already read up to and including the comma?</p>\n<p>You might be able to do that, but that would entail somehow backing up (backing up to where?) using <code>tellg</code> and <code>seekg</code> -- and then what? There is no recovery, so setting the <code>badbit</code> is the right thing to do.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "37380639", "Score": "0", "CreationDate": "2016-05-22T23:22:18.287", "LastActivityDate": "2016-05-22T23:22:18.287"}, "bq_ids": {"n4140": {"so_37380430_37380652_1": {"section_id": 3498, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_37380430_37380652_1": {"section_id": 3363, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_37380430_37380652_1": {"section_id": 4261, "quality": 0.8888888888888888, "length": 8}}}, "37380652": {"ParentId": "37380430", "CommentCount": "2", "Body": "<p>The book you're quoting was published in 1991, 7 years before the first ISO C++ standard was even published. It's not clear why the author chose to use <code>ios::badbit</code> because no rationale was provided in either the 2nd or 3rd editions of the book. </p>\n<p>In C++98, a non-member overload for <code>operator&gt;&gt;</code> was added for <code>complex</code>. This mandates that <code>failbit</code> is required to be set in the case of bad input rather than <code>badbit</code>.</p>\n<p>N1905 26.2/13</p>\n<pre><code>template &lt; class T , class charT , class traits &gt;\nbasic_istream &lt; charT , traits &gt;&amp;\noperator &gt; &gt;( basic_istream &lt; charT , traits &gt;&amp; is , complex &lt;T &gt;&amp; x );\n</code></pre>\n<blockquote>\n<p id=\"so_37380430_37380652_0\"><em>Requires:</em> The input values be convertible to <code>T</code>.</p>\n<p id=\"so_37380430_37380652_1\">If bad input is encountered, calls <code>is.setstate(ios::failbit)</code> (which\n  may throw <code>ios::failure</code> (27.4.4.3).</p>\n</blockquote>\n", "OwnerUserId": "6292850", "PostTypeId": "2", "Id": "37380652", "Score": "4", "CreationDate": "2016-05-22T23:24:51.890", "LastActivityDate": "2016-05-22T23:24:51.890"}});