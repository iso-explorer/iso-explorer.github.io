post_cb({"bq_ids": {"n4140": {"so_18317564_18317739_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6805}}, "n3337": {"so_18317564_18317739_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6560}}, "n4659": {"so_18317564_18317739_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 8296}}}, "18317739": {"Id": "18317739", "PostTypeId": "2", "Body": "<p>Yes, it's needed, but no, it may not be possible. If you're aborting from an async-signal context, calling <code>fflush</code> invokes undefined behavior. And in general, if the reason for calling <code>abort</code> is that you've detected inconsistent state in your program, there's a risk that stdio state is also corrupted, and that calling <code>fflush</code> is therefore unsafe.</p>\n<p>In general, you should use <code>exit(1)</code> if you're terminating due to a condition that your program simply can't handle, and use <code>abort()</code> (without <code>fflush</code>) only when you have detected that your program invoked undefined behavior already,</p>\n<p>Some more details:</p>\n<p>The C standard <em>allows</em> an implementation to flush stdio streams as part of abort (C11 7.22.4.1:):</p>\n<blockquote>\n<p id=\"so_18317564_18317739_0\">Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined.</p>\n</blockquote>\n<p>However, this does not remove the requirement that <code>abort</code> work if called from a signal handler. Since, from a practical standpoint, it's usually impossible to flush buffers if <code>abort</code> is being called from a signal handler that interrupted stdio code that has the buffer in an inconsistent state, any implementation that attempts to use this allowance is likely to be buggy.</p>\n<p>The current version of the Linux man page for <code>abort</code> incorrectly states:</p>\n<blockquote>\n<p id=\"so_18317564_18317739_1\">If the abort() function causes process termination, all open streams are closed and flushed.</p>\n</blockquote>\n<p>A more correct statement of the current behavior would be that flushing is <em>attempted</em> but may fail or corrupt your data. This bug is presently in the process of being fixed in glibc (maybe the fix was already committed...?) according to this thread:</p>\n<p><a href=\"http://www.sourceware.org/ml/libc-alpha/2013-05/msg00207.html\" rel=\"nofollow\">http://www.sourceware.org/ml/libc-alpha/2013-05/msg00207.html</a></p>\n", "LastEditorUserId": "379897", "LastActivityDate": "2013-08-19T16:45:56.640", "Score": "8", "CreationDate": "2013-08-19T15:38:50.307", "ParentId": "18317564", "CommentCount": "5", "OwnerUserId": "379897", "LastEditDate": "2013-08-19T16:45:56.640"}, "18317610": {"Id": "18317610", "PostTypeId": "2", "Body": "<p>Stdout is buffered and so are the file you open with ofstream for example. You have to explicitly flush them using the flush manipulator</p>\n", "LastActivityDate": "2013-08-19T15:31:57.323", "CommentCount": "3", "CreationDate": "2013-08-19T15:31:57.323", "ParentId": "18317564", "Score": "0", "OwnerUserId": "281681"}, "18317564": {"ViewCount": "1230", "Body": "<p>Is there a need to explicitly flush output streams before calling <code>abort()</code> to avoid loss of output?</p>\n<p>As I understand, with <code>stderr</code> there is no buffering, so calling <code>abort</code> after output to <code>stderr</code>/<code>cerr</code> should be ok. How about <code>stdout</code>/<code>cout</code>, or files that I open?</p>\n<p>PS. I am working in Linux environment (if it matters).</p>\n", "AcceptedAnswerId": "18317739", "Title": "C/C++: Flush output before abnormal termination", "CreationDate": "2013-08-19T15:29:14.343", "Id": "18317564", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-08-19T16:45:56.640", "Score": "2", "OwnerUserId": "2052436", "Tags": "<c++><c><io><abort>", "AnswerCount": "2"}});