post_cb({"bq_ids": {"n4140": {"so_18854404_18854682_0": {"length": 77, "quality": 0.927710843373494, "section_id": 3296}}, "n3337": {"so_18854404_18854682_0": {"length": 77, "quality": 0.927710843373494, "section_id": 3166}}, "n4659": {"so_18854404_18854682_0": {"length": 58, "quality": 0.6987951807228916, "section_id": 4058}}}, "18854682": {"Id": "18854682", "PostTypeId": "2", "Body": "<p>This is because initializing <code>s2</code> with a <code>const S &amp;</code> requires two conversions; one to convert the reference into a temporary, and one to copy the temporary into your variable.  C++ only allows one automatic conversion to happen.</p>\n<p>For example, this also works:</p>\n<pre><code>S s2(a);\n</code></pre>\n<p>Since there is no longer a need to create the temporary.</p>\n<p>Note that the standard has a paragraph on this particular case.  In C++03 8.5p14:</p>\n<blockquote>\n<p id=\"so_18854404_18854682_0\">Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3).  If the conversion cannot be done or is ambiguous, the initialization is ill-formed.  The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the destination type.  The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization.  In certain cases, an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</p>\n</blockquote>\n", "LastEditorUserId": "951890", "LastActivityDate": "2013-09-17T19:25:33.317", "Score": "6", "CreationDate": "2013-09-17T16:07:30.850", "ParentId": "18854404", "CommentCount": "2", "OwnerUserId": "951890", "LastEditDate": "2013-09-17T19:25:33.317"}, "18854404": {"ViewCount": "2576", "Body": "<p>I am trying to understand how the cast operator works with templates.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct S {\n    int v;\n};\n\nclass A {\npublic:\n    A(void* ptr) : ptr(ptr) {}  \n    void* ptr;\n\n    template&lt;typename T&gt;\n    const T&amp; as() const {\n        return *static_cast&lt;T*&gt;(ptr);\n    }\n\n    template&lt;typename T&gt;\n    operator const T&amp;() const {\n        return as&lt;T&gt;();\n    }\n};\n\nint main() {\n    S test;\n    test.v = 123;\n\n    A a(&amp;test);\n\n    S s = a.as&lt;S&gt;();\n    S s2 = a; // error here\n    const S&amp; s3 = a;\n\n    cout &lt;&lt; s.v &lt;&lt; endl;\n    cout &lt;&lt; s2.v &lt;&lt; endl;\n    cout &lt;&lt; s3.v &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>gcc gives me the following compile error:</p>\n<blockquote>\n<p id=\"so_18854404_18854404_0\">conversion from \u2018A\u2019 to non-scalar type \u2018S\u2019 requested</p>\n</blockquote>\n<p>I am aware, that I can fix the problem by adding another \"operator T() const\" but why can't the compiler figure out the right conversion in this case?</p>\n<p>Strangely clang does not complain and compiles just fine.</p>\n<p>(tested with gcc4.7, gcc4.8 and clang3.2)</p>\n", "AcceptedAnswerId": "18854682", "Title": "C++ templated cast operator - conversion from to non-scalar type requested", "CreationDate": "2013-09-17T15:52:45.980", "Id": "18854404", "CommentCount": "0", "LastEditDate": "2013-09-17T16:00:22.293", "PostTypeId": "1", "LastEditorUserId": "1492625", "LastActivityDate": "2013-09-17T19:25:33.317", "Score": "4", "OwnerUserId": "1492625", "Tags": "<c++><templates><typecast-operator>", "AnswerCount": "1"}});