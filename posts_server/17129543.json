post_cb({"bq_ids": {"n4140": {"so_17129543_17129555_1": {"length": 24, "quality": 0.96, "section_id": 277}, "so_17129543_17129555_0": {"length": 35, "quality": 1.0, "section_id": 278}}, "n3337": {"so_17129543_17129555_1": {"length": 24, "quality": 0.96, "section_id": 268}, "so_17129543_17129555_0": {"length": 35, "quality": 1.0, "section_id": 269}}, "n4659": {"so_17129543_17129555_1": {"length": 24, "quality": 0.96, "section_id": 284}, "so_17129543_17129555_0": {"length": 35, "quality": 1.0, "section_id": 285}}}, "17129543": {"ViewCount": "285", "Body": "<p>I'm having trouble specializing an inner template when it's parameters are all known.  Here's an example:</p>\n<pre><code>template &lt; typename T0 &gt;\nstruct outer\n{\n    template &lt; typename T1 = void, typename T2 = void &gt;\n    struct inner\n    {\n        typedef T1 type;\n    };\n};\ntemplate &lt; typename T0 &gt;\ntemplate &lt; typename T1 &gt;\nstruct outer&lt;T0&gt;::inner&lt;double,T1&gt; { typedef int type; };\n</code></pre>\n<p>This works just fine.  If I instead specify the inner template like so, it does not:</p>\n<pre><code>template &lt; typename T0 &gt;\ntemplate &lt; &gt;\nstruct outer&lt;T0&gt;::inner&lt;double,void&gt; { typedef int type; };\n</code></pre>\n<p>For this I get the error message, \"invalid explicit specialization before \u2018&gt;\u2019 token...enclosing class templates are not explicitly specialized...template parameters not used in partial specialization:...T0\".  Not sure WTAF is going on here.</p>\n<p>I also tried this:</p>\n<pre><code>template &lt; typename T0 &gt;\nstruct outer&lt;T0&gt;::inner&lt;double,void&gt; { typedef int type; };\n</code></pre>\n<p>I expected this to fail and the error message is not surprising.  It was: \"too few template-parameter-lists\".</p>\n<p>So, what's the correct way to do this?  I can of course hack around it, but if I don't have to I'd prefer not.</p>\n", "AcceptedAnswerId": "17129555", "Title": "Specializing inner template with default parameters", "CreationDate": "2013-06-16T02:06:37.477", "Id": "17129543", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-06-16T02:22:00.553", "Score": "5", "OwnerUserId": "301883", "Tags": "<c++><templates><specialization>", "AnswerCount": "1"}, "17129555": {"Id": "17129555", "PostTypeId": "2", "Body": "<p>That is not allowed. You cannot fully specialize a member of a class template that has not been itself fully specialized.</p>\n<p>Per paragraph 14.7.16 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17129543_17129555_0\">In an explicit specialization declaration for a member of a class template or a member template that appears\n  in namespace scope, the member template and some of its enclosing class templates may remain\n  unspecialized, <strong>except that the declaration shall not explicitly specialize a class member template if its enclosing\n  class templates are not explicitly specialized as well</strong>. [...]</p>\n</blockquote>\n<p>Also, paragraph 14.7.3/15 of the C++11 Standard says:</p>\n<blockquote>\n<p id=\"so_17129543_17129555_1\">A member or a member template may be nested within many enclosing class templates. In an explicit\n  specialization for such a member, the member declaration shall be preceded by a <code>template&lt;&gt;</code> for each\n  enclosing class template that is explicitly specialized. [ <em>Example</em>:</p>\n<pre><code>template&lt;class T1&gt; class A {\n     template&lt;class T2&gt; class B {\n         void mf();\n     };\n};\ntemplate&lt;&gt; template&lt;&gt; class A&lt;int&gt;::B&lt;double&gt;;\ntemplate&lt;&gt; template&lt;&gt; void A&lt;char&gt;::B&lt;char&gt;::mf();\n</code></pre>\n<p id=\"so_17129543_17129555_2\">\u2014<em>end example</em> ]</p>\n</blockquote>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-16T02:22:00.553", "Score": "7", "CreationDate": "2013-06-16T02:10:01.857", "ParentId": "17129543", "CommentCount": "9", "OwnerUserId": "1932150", "LastEditDate": "2013-06-16T02:22:00.553"}});