post_cb({"bq_ids": {"n4140": {"so_17071686_17071736_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 300}, "so_17071686_17071736_0": {"length": 6, "quality": 1.0, "section_id": 300}}, "n3337": {"so_17071686_17071736_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 291}, "so_17071686_17071736_0": {"length": 6, "quality": 1.0, "section_id": 291}}, "n4659": {"so_17071686_17071736_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 307}, "so_17071686_17071736_0": {"length": 6, "quality": 1.0, "section_id": 307}}}, "17072689": {"Id": "17072689", "PostTypeId": "2", "Body": "<p>I think the function works, because the compiler is clever enough not to make a reference of a reference. He gets a reference and wants a reference, so it stays one. I think he simply ignores the second &amp; when you have T&amp; with T already a reference.\nI can't explain it in detail but in c++ you can use references mostly exactly like non-references.</p>\n<p>In <code>FileRef&amp;</code> he can't ignore that. Here you explicitly say: make a reference of a reference, what can't work.\nAnd &amp;&amp; is a logical AND.</p>\n<p>ps: substitution failure is not an error (SFINAE)</p>\n", "LastActivityDate": "2013-06-12T18:28:15.783", "CommentCount": "1", "CreationDate": "2013-06-12T18:28:15.783", "ParentId": "17071686", "Score": "0", "OwnerUserId": "2460466"}, "17071686": {"ViewCount": "106", "Body": "<p>Just a question something I found interesting when working with stl. In the below code, the last two lines in the main function will cause the error (indicated in the comments). However, the test_func compiles fine. Since type being passed to the template function is a reference type and the function itself applies the &amp; operator aren't these two things essentially the same? well, apparently not cause one of them compiles and the other doesn't. Anyone know why?</p>\n<pre><code>class File {\n\n    private:\n            std::string name_;\n\n    public:\n\n            File(std::string n) : name_(n) {}\n            std::string name() const { return name_; }\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const File&amp; f)\n{\n    os &lt;&lt; f.name();\n    return os;\n}\n\ntemplate &lt;class T&gt; void test_func(const T&amp; v)\n{\n    T&amp; v1(v);\n    std::cout &lt;&lt; \"File:\" &lt;&lt; v1 &lt;&lt; std::endl;\n}\n\ntypedef File&amp; FileRef;\n\nint main(int argc, char* argv[])\n{\n    File f(\"test_file\");\n    test_func&lt;File&amp;&gt;(f);\n    // FileRef&amp; fRef1(f);   ==&gt; error; cannot declare reference to 'class File&amp;'\n    // File&amp;&amp; fRef2(f);     ==&gt; error; expected unqualified-id before '&amp;&amp;' token\n\n}\n</code></pre>\n<p>UPDATE: I came across this when working with bind1st and bind2nd functions in ; they are defined just like test_func in the text book (stroustrup in Chapter 18 section on binders) so it can't be wrong.</p>\n", "Title": "C++ nested referece directly vs via template argument", "CreationDate": "2013-06-12T17:30:09.730", "LastActivityDate": "2013-06-12T19:46:20.987", "CommentCount": "1", "LastEditDate": "2013-06-12T19:46:20.987", "PostTypeId": "1", "LastEditorUserId": "1308963", "Id": "17071686", "Score": "1", "OwnerUserId": "1308963", "Tags": "<c++><templates><reference><nested>", "AnswerCount": "2"}, "17071736": {"Id": "17071736", "PostTypeId": "2", "Body": "<p>The first commented line is legal, and your compiler is probably not conforming with C++11. Because of C++11's reference collapsing rules, in fact, it should declare an lvalue reference to <code>File</code> named <code>fRef1</code> and bind it to the lvalue <code>f</code>.</p>\n<p>The second commented line is illegal: you cannot bind an rvalue reference to an lvalue. However, the error you are getting seems to indicate that the compiler does not understand the <code>&amp;&amp;</code> token.</p>\n<p>If you are using Clang or GCC, make sure you are compiling with the <code>-std=c++11</code> or <code>-std=c++0x</code> option.</p>\n<p><strong>UPDATE:</strong></p>\n<p>In C++03, both lines are illegal, and even this function call should be rejected by the compiler:</p>\n<pre><code>test_func&lt;File&amp;&gt;(f); // SHOULD BE AN ERROR! (substitution failure)\n</code></pre>\n<p>Per paragraph 14.8.2/2 of the C++03 Standard:</p>\n<blockquote>\n<p id=\"so_17071686_17071736_0\">[...] Type deduction may fail for\n  the following reasons:</p>\n<p id=\"so_17071686_17071736_1\">\u2014 [...]</p>\n<p id=\"so_17071686_17071736_2\">\u2014 <strong>Attempting to create a reference to a reference type</strong> or a reference to void.</p>\n<p id=\"so_17071686_17071736_3\">\u2014 [...]</p>\n</blockquote>\n<p>This can mean two things: either your compiler has a bug, or it intentionally decides to ignore an attempt to create a reference to reference in the context of template argument deduction (and only in that context) - meaning that you're dealing with a compiler extension.</p>\n<p>In any case, that function call is ill-formed and therefore not portable.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-12T17:52:03.180", "Score": "2", "CreationDate": "2013-06-12T17:34:09.130", "ParentId": "17071686", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2013-06-12T17:52:03.180"}});