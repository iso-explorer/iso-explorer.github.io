post_cb({"5854581": {"ViewCount": "41711", "Body": "<p>AFAIK:</p>\n<p>C++ provides three different types of polymorphism.</p>\n<ul>\n<li>Virtual functions</li>\n<li>Function name overloading</li>\n<li>Operator overloading</li>\n</ul>\n<p>In addition to the above three types of polymorphism, there exist other kinds of polymorphism:</p>\n<ul>\n<li>run-time</li>\n<li>compile-time</li>\n<li>ad-hoc polymorphism</li>\n<li>parametric polymorphism</li>\n</ul>\n<p>I know that <em>runtime polymorphism</em> can be achieved by <em>virtual functions</em>\nand <em>static polymorphism</em> can be achieved by <em>template functions</em></p>\n<p>But for the other two </p>\n<ul>\n<li>ad-hoc polymorphism</li>\n<li>parametric polymorphism\nthe <a href=\"http://www.exforsys.com/tutorials/c-plus-plus/polymorphism-an-introduction.html\" rel=\"noreferrer\">website says</a>,</li>\n</ul>\n<p><strong>ad-hoc polymorphism:</strong></p>\n<p>If the range of actual types that can be used is finite and the combinations must be individually specified prior to use, this is called ad-hoc polymorphism.</p>\n<p><strong>parametric polymorphism:</strong></p>\n<p>If all code is written without mention of any specific type and thus can be used transparently with any number of new types it is called parametric polymorphism. </p>\n<p>i can hardly understand them :(</p>\n<p>can anyone explain them both if possible with an example?\nI hope the answers to this questions would be helpful for many new passouts from thier colleges.</p>\n", "AcceptedAnswerId": "5854862", "Title": "Polymorphism in c++", "CreationDate": "2011-05-02T07:35:10.780", "Id": "5854581", "CommentCount": "16", "FavoriteCount": "115", "PostTypeId": "1", "LastEditDate": "2012-08-08T19:14:57.000", "LastEditorUserId": "565635", "LastActivityDate": "2017-03-04T12:23:28.257", "Score": "102", "OwnerUserId": "134713", "Tags": "<c++><polymorphism><c++-faq>", "AnswerCount": "7"}, "26945553": {"Id": "26945553", "PostTypeId": "2", "Body": "<p>If anybody says CUT to these people</p>\n<pre><code>The Surgeon\nThe Hair Stylist\nThe Actor\n</code></pre>\n<p>What will happen?</p>\n<pre><code>The Surgeon would begin to make an incision.\nThe Hair Stylist would begin to cut someone's hair.\nThe Actor would abruptly stop acting out of the current scene, awaiting directorial guidance.\n</code></pre>\n<p>So above representation shows What is polymorphism (same name, different behavior) in OOP.</p>\n<p>If you are going for an interview and interviewer asks you tell/show a live example for polymorphism in the same room we are sitting at, say-</p>\n<p>Answer - Door / Windows</p>\n<p>Wondering How?</p>\n<p>Through Door / Window - a person can come, air can come, light can come, rain can come, etc.</p>\n<p>i.e. One form different behavior(Polymorphism).</p>\n<p>To understand it better and in a simple manner I used above example.. If you need reference for code follow above answers.</p>\n", "LastActivityDate": "2014-11-15T11:55:00.667", "CommentCount": "2", "CreationDate": "2014-11-15T11:55:00.667", "ParentId": "5854581", "Score": "-4", "OwnerUserId": "4032028"}, "5854862": {"Body": "<h2>Understanding of / requirements for polymorphism</h2>\n<p>To understand polymorphism - as the term is used in Computing Science - it helps to start from a simple test for and definition of it.  Consider:</p>\n<pre><code>    Type1 x;\n    Type2 y;\n\n    f(x);\n    f(y);\n</code></pre>\n<p>Here, <code>f()</code> is to perform some operation and is being given values <code>x</code> and <code>y</code> as inputs.</p>\n<blockquote>\n<p id=\"so_5854581_5854862_0\">To exhibit polymorphism, <code>f()</code> must be able to operate with values of at least two <strong>distinct</strong> types (e.g. <code>int</code> and <code>double</code>), finding and executing distinct type-appropriate code.</p>\n</blockquote>\n<hr>\n<h2>C++ mechanisms for polymorphism</h2>\n<h3>Explicit programmer-specified polymorphism</h3>\n<p>You can write <code>f()</code> such that it can operate on multiple types in any of the following ways:</p>\n<ul>\n<li><p>Preprocessing:</p>\n<pre><code>#define f(X) ((X) += 2)\n// (note: in real code, use a longer uppercase name for a macro!)\n</code></pre></li>\n<li><p>Overloading:</p>\n<pre><code>void f(int&amp; x)    { x += 2; }\n\nvoid f(double&amp; x) { x += 2; }\n</code></pre></li>\n<li><p>Templates:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f(T&amp; x) { x += 2; }\n</code></pre></li>\n<li><p>Virtual dispatch:</p>\n<pre><code>struct Base { virtual Base&amp; operator+=(int) = 0; };\n\nstruct X : Base\n{\n    X(int n) : n_(n) { }\n    X&amp; operator+=(int n) { n_ += n; return *this; }\n    int n_;\n};\n\nstruct Y : Base\n{\n    Y(double n) : n_(n) { }\n    Y&amp; operator+=(int n) { n_ += n; return *this; }\n    double n_;\n};\n\nvoid f(Base&amp; x) { x += 2; } // run-time polymorphic dispatch\n</code></pre></li>\n</ul>\n<h3>Other related mechanisms</h3>\n<p>Compiler-provided polymorphism for builtin types, Standard conversions, and casting/coercion are discussed later for completeness as:</p>\n<ul>\n<li>they're commonly intuitively understood anyway (warranting a \"<em>oh, that</em>\" reaction),</li>\n<li>they impact the threshold in requiring, and seamlessness in using, the above mechanisms, and</li>\n<li>explanation is a fiddly distraction from more important concepts.</li>\n</ul>\n<h2>Terminology</h2>\n<h3>Further categorisation</h3>\n<p>Given the polymorphic mechanisms above, we can categorise them in various ways:</p>\n<ul>\n<li><p>When is the polymorphic type-specific code selected?</p>\n<ul>\n<li><strong>Run time</strong> means the compiler must generate code for all the types the program might handle while running, and at run-time the correct code is selected (<em>virtual dispatch</em>)</li>\n<li><strong>Compile time</strong> means the choice of type-specific code is made during compilation.  A consequence of this: say a program only called <code>f</code> above with <code>int</code> arguments - depending on the polymorphic mechanism used and inlining choices the compiler might avoid generating any code for <code>f(double)</code>, or generated code might be thrown away at some point in compilation or linking.  (<em>all mechanisms above except virtual dispatch</em>)\n<br><br/></br></li>\n</ul></li>\n<li><p>Which types are supported?</p>\n<ul>\n<li><strong>Ad-hoc</strong> meaning you provide explicit code to support each type (e.g. overloading, template specialisation); you explicitly add support \"for this\" (as per <em>ad hoc</em>'s meaning) type, some other \"this\", and maybe \"that\" too ;-).</li>\n<li><p><strong>Parametric</strong> meaning you can just try to use the function for various parameter types without specifically doing anything to enable its support for them (e.g. templates, macros).  An object with functions/operators that act like the template/macro expects<sup>1</sup> <em>is</em> all that template/macro needs to do its job, with the exact type being irrelevant. The \"concepts\" cut from C++11 help express and enforce such expectations - let's hope they make it into a later Standard.</p>\n<ul>\n<li><p>Parametric polymorphism provides <strong>duck typing</strong> - a concept attributed to James Whitcomb Riley who apparently said <em>\"When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.\"</em>.</p>\n<pre><code>template &lt;typename Duck&gt;\nvoid do_ducky_stuff(const Duck&amp; x) { x.walk().swim().quack(); }\n\ndo_ducky_stuff(Vilified_Cygnet());\n</code></pre></li>\n</ul></li>\n<li><p><strong>Subtype (aka inclusion) polymorphism</strong> allows you to work on new types without updating the algorithm/function, but they must be derived from the same base class (virtual dispatch)</p></li>\n</ul></li>\n</ul>\n<p><sup>1</sup> - Templates are extremely flexible.  <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\" rel=\"noreferrer\">SFINAE</a> (see also <a href=\"http://en.cppreference.com/w/cpp/types/enable_if\" rel=\"noreferrer\"><code>std::enable_if</code></a>) effectively allows several sets of expectations for parametric polymorphism.  For example, you might encode that when the type of data you're processing has a <code>.size()</code> member you'll use one function, otherwise another function that doesn't need <code>.size()</code> (but presumably suffers in some way - e.g. using the slower <code>strlen()</code> or not printing as useful a message in the log).  You can also specify ad-hoc behaviours when the template is instantiated with specific parameters, either leaving some parameters parametric (<a href=\"http://en.cppreference.com/w/cpp/language/partial_specialization\" rel=\"noreferrer\"><em>partial template specialisation</em></a>) or not (<a href=\"http://en.cppreference.com/w/cpp/language/template_specialization\" rel=\"noreferrer\"><em>full specialisation</em></a>).</p>\n<h3>\"Polymorphic\"</h3>\n<p>Alf Steinbach comments that in the C++ Standard <strong>polymorphic</strong> only refers to run-time polymorphism using virtual dispatch.  General Comp. Sci. meaning is more inclusive, as per C++ creator Bjarne Stroustrup's glossary (<a href=\"http://www.stroustrup.com/glossary.html\" rel=\"noreferrer\">http://www.stroustrup.com/glossary.html</a>):</p>\n<blockquote>\n<p id=\"so_5854581_5854862_1\">polymorphism - providing a single interface to entities of different types. Virtual functions provide dynamic (run-time) polymorphism through an interface provided by a base class. Overloaded functions and templates provide static (compile-time) polymorphism. TC++PL 12.2.6, 13.6.1, D&amp;E 2.9.</p>\n</blockquote>\n<p>This answer - like the question - relates C++ features to the Comp. Sci. terminology.</p>\n<h2>Discussion</h2>\n<p>With the C++ Standard using a narrower definition of \"polymorphism\" than the Comp. Sci. community, to ensure mutual understanding for <em>your</em> audience consider...</p>\n<ul>\n<li>using unambiguous terminology (\"can we make this code reusable for other types?\" or \"can we use virtual dispatch?\" rather than \"can we make this code polymorphic?\"), and/or</li>\n<li>clearly defining your terminology.</li>\n</ul>\n<p>Still, what's crucial to being a great C++ programmer is <em>understanding</em> what polymorphism's really doing for you...</p>\n<p>\u00a0\u00a0\u00a0\u00a0<em>letting you write \"algorithmic\" code once and then apply it to many types of data</em></p>\n<p>...and then be very aware of how different polymorphic mechanisms match your actual needs.</p>\n<p>Run-time polymorphism suits:</p>\n<ul>\n<li>input processed by factory methods and spat out as an heterogeneous object collection handled via <code>Base*</code>s,</li>\n<li>implementation chosen at runtime based on config files, command line switches, UI settings etc.,</li>\n<li>implementation varied at runtime, such as for a state machine pattern.</li>\n</ul>\n<p>When there's not a clear driver for run-time polymorphism, compile-time options are often preferable.  Consider:</p>\n<ul>\n<li>the compile-what's-called aspect of templated classes is preferable to fat interfaces failing at runtime</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/sfinae\" rel=\"noreferrer\">SFINAE</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"noreferrer\">CRTP</a></li>\n<li>optimisations (many including inlining and dead code elimination, loop unrolling, static stack-based arrays vs heap)</li>\n<li><code>__FILE__</code>, <code>__LINE__</code>, string literal concatenation and other unique capabilities of macros (which remain evil ;-))</li>\n<li>templates and macros test semantic usage is supported, but don't artificially restrict how that support is provided (as virtual dispatch tends to by requiring exactly matching member function overrides)</li>\n</ul>\n<h2>Other mechanisms supporting polymorphism</h2>\n<p>As promised, for completeness several peripheral topics are covered:</p>\n<ul>\n<li>compiler-provided overloads</li>\n<li>conversions</li>\n<li>casts/coercion</li>\n</ul>\n<p>This answer concludes with a discussion of how the above combine to empower and simplify polymorphic code - especially parametric polymorphism (templates and macros).</p>\n<h3>Mechanisms for mapping to type-specific operations</h3>\n<p><strong>&gt; Implicit compiler-provided overloads</strong></p>\n<p>Conceptually, the compiler <em>overloads</em> many operators for builtin types.  It's not conceptually different from user-specified overloading, but is listed as it's easily overlooked.  For example, you can add to <code>int</code>s and <code>double</code>s using the same notation <code>x += 2</code> and the compiler produces:</p>\n<ul>\n<li>type-specific CPU instructions</li>\n<li>a result of the same type.</li>\n</ul>\n<p>Overloading then seamlessly extends to user-defined types:</p>\n<pre><code>std::string x;\nint y = 0;\n\nx += 'c';\ny += 'c';\n</code></pre>\n<p>Compiler-provided overloads for basic types is common in high-level (3GL+) computer languages, and explicit discussion of polymorphism generally implies something more.  (2GLs - assembly languages - often require the programmer to explicitly use different mnemonics for different types.)</p>\n<p><strong>&gt; Standard conversions</strong></p>\n<p>The C++ Standard's fourth section describes Standard conversions.</p>\n<p>The first point summarises nicely (from an old draft - hopefully still substantially correct):</p>\n<blockquote>\n<p id=\"so_5854581_5854862_2\">-1- Standard conversions are implicit conversions defined for built-in types. Clause conv enumerates the full set of such conversions. A standard conversion sequence is a sequence of standard conversions in the following order: </p>\n</blockquote>\n<ul>\n<li><p>Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion. </p></li>\n<li><p>Zero or one conversion from the following set: integral promotions, floating point promotion, integral conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to member conversions, and boolean conversions. </p></li>\n<li><p>Zero or one qualification conversion. </p></li>\n</ul>\n<blockquote>\n<p id=\"so_5854581_5854862_3\">[Note: a standard conversion sequence can be empty, i.e., it can consist of no conversions. ] A standard conversion sequence will be applied to an expression if necessary to convert it to a required destination type. </p>\n</blockquote>\n<p>These conversions allow code such as:</p>\n<pre><code>double a(double x) { return x + 2; }\n\na(3.14);\na(42);\n</code></pre>\n<p>Applying the earlier test:</p>\n<blockquote>\n<p id=\"so_5854581_5854862_4\">To be polymorphic, [<code>a()</code>] must be able to operate with values of at least two <strong>distinct</strong> types (e.g. <code>int</code> and <code>double</code>), <strong>finding and executing type-appropriate code</strong>.</p>\n</blockquote>\n<p><code>a()</code> itself runs code specifically for <code>double</code> and is therefore <em>not</em> polymorphic.</p>\n<p>But, in the second call to <code>a()</code> the compiler knows to generate type-appropriate code for a \"floating point promotion\" (Standard \u00a74) to convert <code>42</code> to <code>42.0</code>.  That extra code is in the <em>calling</em> function.  We'll discuss the significance of this in the conclusion.</p>\n<p><strong>&gt; Coercion, casts, implicit constructors</strong></p>\n<p>These mechanisms allow user-defined classes to specify behaviours akin to builtin types' Standard conversions.  Let's have a look:</p>\n<pre><code>int a, b;\n\nif (std::cin &gt;&gt; a &gt;&gt; b)\n    f(a, b);\n</code></pre>\n<p>Here, the object <code>std::cin</code> is evaluated in a boolean context, with the help of a conversion operator.  This can be conceptually grouped with \"integral promotions\" et al from the Standard conversions in the topic above.</p>\n<p>Implicit constructors effectively do the same thing, but are controlled by the cast-to type:</p>\n<pre><code>f(const std::string&amp; x);\nf(\"hello\");  // invokes `std::string::string(const char*)`\n</code></pre>\n<h3>Implications of compiler-provided overloads, conversions and coercion</h3>\n<p>Consider:</p>\n<pre><code>void f()\n{\n    typedef int Amount;\n    Amount x = 13;\n    x /= 2;\n    std::cout &lt;&lt; x * 1.1;\n}\n</code></pre>\n<p>If we want the amount <code>x</code> to be treated as a real number during the division (i.e. be 6.5 rather than rounded down to 6), we <em>only</em> need change to <code>typedef double Amount</code>.</p>\n<p>That's nice, but it wouldn't have been <em>too</em> much work to make the code explicitly \"type correct\":</p>\n<pre><code>void f()                               void f()\n{                                      {\n    typedef int Amount;                    typedef double Amount;\n    Amount x = 13;                         Amount x = 13.0;\n    x /= 2;                                x /= 2.0;\n    std::cout &lt;&lt; double(x) * 1.1;          std::cout &lt;&lt; x * 1.1;\n}                                      }\n</code></pre>\n<p>But, consider that we can transform the first version into a <code>template</code>:</p>\n<pre><code>template &lt;typename Amount&gt;\nvoid f()\n{\n    Amount x = 13;\n    x /= 2;\n    std::cout &lt;&lt; x * 1.1;\n}\n</code></pre>\n<p>It's due to those little \"convenience features\" that it can be so easily instantiated for either <code>int</code> or <code>double</code> and work as intended.  Without these features, we'd need explicit casts, type traits and/or policy classes, some verbose, error-prone mess like:</p>\n<pre><code>template &lt;typename Amount, typename Policy&gt;\nvoid f()\n{\n    Amount x = Policy::thirteen;\n    x /= static_cast&lt;Amount&gt;(2);\n    std::cout &lt;&lt; traits&lt;Amount&gt;::to_double(x) * 1.1;\n}\n</code></pre>\n<p>So, compiler-provided operator overloading for builtin types, Standard conversions, casting / coercion / implicit constructors - they all contribute subtle support for polymorphism.  From the definition at the top of this answer, they address \"finding and executing type-appropriate code\" by mapping:</p>\n<ul>\n<li><p>\"away\" from parameter types</p>\n<ul>\n<li><p><em>from</em> the many data types polymorphic algorithmic code handles</p></li>\n<li><p><em>to</em> code written for a (potentially lesser) number of (the same or other) types.</p></li>\n</ul></li>\n<li><p>\"to\" parametric types from values of constant type</p></li>\n</ul>\n<p>They do <em>not</em> establish polymorphic contexts by themselves, but do help empower/simplify code inside such contexts.</p>\n<p>You may feel cheated... it doesn't seem like much.  The significance is that in parametric polymorphic contexts (i.e. inside templates or macros), we're trying to support an arbitrarily large range of types but often want to express operations on them in terms of other functions, literals and operations that were designed for a small set of types.  It reduces the need to create near-identical functions or data on a per-type basis when the operation/value is logically the same.  These features cooperate to add an attitude of \"best effort\", doing what's intuitively expected by using the limited available functions and data and only stopping with an error when there's real ambiguity.</p>\n<p>This helps limit the need for polymorphic code supporting polymorphic code, drawing a tighter net around the use of polymorphism so localised use doesn't force widespread use, and making the benefits of polymorphism available as needed without imposing the costs of having to expose implementation at compile time, have multiple copies of the same logical function in the object code to support the used types, and in doing virtual dispatch as opposed to inlining or at least compile-time resolved calls.  As is typical in C++, the programmer is given a lot of freedom to control the boundaries within which polymorphism is used.</p>\n</hr>", "CreationDate": "2011-05-02T08:11:31.490", "ParentId": "5854581", "CommentCount": "28", "LastEditDate": "2016-10-15T11:10:38.387", "Id": "5854862", "PostTypeId": "2", "LastActivityDate": "2016-10-15T11:10:38.387", "LastEditorUserId": "410767", "CommunityOwnedDate": "2011-06-08T09:46:27.923", "Score": "188", "OwnerUserId": "410767"}, "20806079": {"Id": "20806079", "PostTypeId": "2", "Body": "<p>This may not be of any help, but I made this to introduce my friends to programming by giving out defined functions, like <code>START</code>, and <code>END</code> for the main function so it was not too daunting (they only used the <em>main.cpp</em> file). It contains Polymorphic classes and structs, templates, vectors, arrays, preproccessor directives, friendship, operators and pointers (all of which you should probably know before attempting polymorphism):</p>\n<p><strong>Note: It is not finished, but you can get the idea</strong></p>\n<p><em>main.cpp</em></p>\n<pre><code>#include \"main.h\"\n#define ON_ERROR_CLEAR_SCREEN false\nSTART\n    Library MyLibrary;\n    Book MyBook(\"My Book\", \"Me\");\n    MyBook.Summarize();\n    MyBook += \"Hello World\";\n    MyBook += \"HI\";\n    MyBook.EditAuthor(\"Joe\");\n    MyBook.EditName(\"Hello Book\");\n    MyBook.Summarize();\n    FixedBookCollection&lt;FairyTale&gt; FBooks(\"Fairytale Books\");\n    FairyTale MyTale(\"Tale\", \"Joe\");\n    FBooks += MyTale;\n    BookCollection E(\"E\");\n    MyLibrary += E;\n    MyLibrary += FBooks;\n    MyLibrary.Summarize();\n    MyLibrary -= FBooks;\n    MyLibrary.Summarize();\n    FixedSizeBookCollection&lt;5&gt; Collection(\"My Fixed Size Collection\");\n    /* Extension Work */ Book* Duplicate = MyLibrary.DuplicateBook(&amp;MyBook);\n    /* Extension Work */ Duplicate-&gt;Summarize();\nEND\n</code></pre>\n<p><em>main.h</em></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;array&gt;\n#ifndef __cplusplus\n#error Not C++\n#endif\n#define START int main(void)try{\n#define END GET_ENTER_EXIT return(0);}catch(const std::exception&amp; e){if(ON_ERROR_CLEAR_SCREEN){system(\"cls\");}std::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; std::endl; GET_ENTER_EXIT return (1);}\n#define GET_ENTER_EXIT std::cout &lt;&lt; \"Press enter to exit\" &lt;&lt; std::endl; getchar();\nclass Book;\nclass Library;\ntypedef std::vector&lt;const Book*&gt; Books;\nbool sContains(const std::string s, const char c){\n    return (s.find(c) != std::string::npos);\n}\nbool approve(std::string s){\n    return (!sContains(s, '#') &amp;&amp; !sContains(s, '%') &amp;&amp; !sContains(s, '~'));\n}\ntemplate &lt;class C&gt; bool isBook(){\n    return (typeid(C) == typeid(Book) || std::is_base_of&lt;Book, C&gt;());\n}\ntemplate&lt;class ClassToDuplicate&gt; class DuplicatableClass{ \npublic:\n    ClassToDuplicate* Duplicate(ClassToDuplicate ToDuplicate){\n        return new ClassToDuplicate(ToDuplicate);\n    }\n};\nclass Book : private DuplicatableClass&lt;Book&gt;{\nfriend class Library;\nfriend struct BookCollection;\npublic:\n    Book(const char* Name, const char* Author) : name_(Name), author_(Author){}\n    void operator+=(const char* Page){\n        pages_.push_back(Page);\n    }\n    void EditAuthor(const char* AuthorName){\n        if(approve(AuthorName)){\n            author_ = AuthorName;\n        }\n        else{\n            std::ostringstream errorMessage;\n            errorMessage &lt;&lt; \"The author of the book \" &lt;&lt; name_ &lt;&lt; \" could not be changed as it was not approved\";\n            throw std::exception(errorMessage.str().c_str());\n        }\n    }\n    void EditName(const char* Name){\n        if(approve(Name)){\n            name_ = Name;\n        }\n        else{\n            std::ostringstream errorMessage;\n            errorMessage &lt;&lt; \"The name of the book \" &lt;&lt; name_ &lt;&lt; \" could not be changed as it was not approved\";\n            throw std::exception(errorMessage.str().c_str());\n        }\n    }\n    virtual void Summarize(){\n        std::cout &lt;&lt; \"Book called \" &lt;&lt; name_ &lt;&lt; \"; written by \" &lt;&lt; author_ &lt;&lt; \". Contains \"\n            &lt;&lt; pages_.size() &lt;&lt; ((pages_.size() == 1) ? \" page:\" : ((pages_.size() &gt; 0) ? \" pages:\" : \" pages\")) &lt;&lt; std::endl;\n        if(pages_.size() &gt; 0){\n            ListPages(std::cout);\n        }\n    }\nprivate:\n    std::vector&lt;const char*&gt; pages_;\n    const char* name_;\n    const char* author_;\n    void ListPages(std::ostream&amp; output){\n        for(int i = 0; i &lt; pages_.size(); ++i){\n            output &lt;&lt; pages_[i] &lt;&lt; std::endl;\n        }\n    }\n};\nclass FairyTale : public Book{\npublic:\n    FairyTale(const char* Name, const char* Author) : Book(Name, Author){}\n};\nstruct BookCollection{\nfriend class Library;\n    BookCollection(const char* Name) : name_(Name){}\n    virtual void operator+=(const Book&amp; Book)try{\n        Collection.push_back(&amp;Book); \n    }catch(const std::exception&amp; e){\n        std::ostringstream errorMessage;\n        errorMessage &lt;&lt; e.what() &lt;&lt; \" - on line (approx.) \" &lt;&lt; (__LINE__ -3);\n        throw std::exception(errorMessage.str().c_str());\n    }\n    virtual void operator-=(const Book&amp; Book){\n        for(int i = 0; i &lt; Collection.size(); ++i){\n            if(Collection[i] == &amp;Book){\n                Collection.erase(Collection.begin() + i);\n                return;\n            }\n        }\n        std::ostringstream errorMessage;\n        errorMessage &lt;&lt; \"The Book \" &lt;&lt; Book.name_ &lt;&lt; \" was not found, and therefore cannot be erased\";\n        throw std::exception(errorMessage.str().c_str());\n    }\nprivate:\n    const char* name_;\n    Books Collection;\n};\ntemplate&lt;class FixedType&gt; struct FixedBookCollection : public BookCollection{\n    FixedBookCollection(const char* Name) : BookCollection(Name){\n        if(!isBook&lt;FixedType&gt;()){\n            std::ostringstream errorMessage;\n            errorMessage &lt;&lt; \"The type \" &lt;&lt; typeid(FixedType).name() &lt;&lt; \" cannot be initialized as a FixedBookCollection\";\n            throw std::exception(errorMessage.str().c_str());\n            delete this;\n        }\n    }\n    void operator+=(const FixedType&amp; Book)try{\n        Collection.push_back(&amp;Book); \n    }catch(const std::exception&amp; e){\n        std::ostringstream errorMessage;\n        errorMessage &lt;&lt; e.what() &lt;&lt; \" - on line (approx.) \" &lt;&lt; (__LINE__ -3);\n        throw std::exception(errorMessage.str().c_str());\n    }\n    void operator-=(const FixedType&amp; Book){\n        for(int i = 0; i &lt; Collection.size(); ++i){\n            if(Collection[i] == &amp;Book){\n                Collection.erase(Collection.begin() + i);\n                return;\n            }\n        }\n        std::ostringstream errorMessage;\n        errorMessage &lt;&lt; \"The Book \" &lt;&lt; Book.name_ &lt;&lt; \" was not found, and therefore cannot be erased\";\n        throw std::exception(errorMessage.str().c_str());\n    }\nprivate:\n    std::vector&lt;const FixedType*&gt; Collection;\n};\ntemplate&lt;size_t Size&gt; struct FixedSizeBookCollection : private std::array&lt;const Book*, Size&gt;{\n    FixedSizeBookCollection(const char* Name) : name_(Name){ if(Size &lt; 1){ throw std::exception(\"A fixed size book collection cannot be smaller than 1\"); currentPos = 0; } }\n    void operator+=(const Book&amp; Book)try{\n        if(currentPos + 1 &gt; Size){\n            std::ostringstream errorMessage;\n            errorMessage &lt;&lt; \"The FixedSizeBookCollection \" &lt;&lt; name_ &lt;&lt; \"'s size capacity has been overfilled\";\n            throw std::exception(errorMessage.str().c_str());\n        }\n        this-&gt;at(currentPos++) = &amp;Book;\n    }catch(const std::exception&amp; e){\n        std::ostringstream errorMessage;\n        errorMessage &lt;&lt; e.what() &lt;&lt; \" - on line (approx.) \" &lt;&lt; (__LINE__ -3);\n        throw std::exception(errorMessage.str().c_str());\n    }\nprivate:\n    const char* name_;\n    int currentPos;\n};\nclass Library : private std::vector&lt;const BookCollection*&gt;{\npublic:\n    void operator+=(const BookCollection&amp; Collection){\n        for(int i = 0; i &lt; size(); ++i){\n            if((*this)[i] == &amp;Collection){\n                std::ostringstream errorMessage;\n                errorMessage &lt;&lt; \"The BookCollection \" &lt;&lt; Collection.name_ &lt;&lt; \" was already in the library, and therefore cannot be added\";\n                throw std::exception(errorMessage.str().c_str());\n            }\n        }\n        push_back(&amp;Collection);\n    }\n    void operator-=(const BookCollection&amp; Collection){\n        for(int i = 0; i &lt; size(); ++i){\n            if((*this)[i] == &amp;Collection){\n                erase(begin() + i);\n                return;\n            }\n        }\n        std::ostringstream errorMessage;\n        errorMessage &lt;&lt; \"The BookCollection \" &lt;&lt; Collection.name_ &lt;&lt; \" was not found, and therefore cannot be erased\";\n        throw std::exception(errorMessage.str().c_str());\n    }\n    Book* DuplicateBook(Book* Book)const{\n        return (Book-&gt;Duplicate(*Book));\n    }\n    void Summarize(){\n        std::cout &lt;&lt; \"Library, containing \" &lt;&lt; size() &lt;&lt; ((size() == 1) ? \" book collection:\" : ((size() &gt; 0) ? \" book collections:\" : \" book collections\")) &lt;&lt; std::endl;\n        if(size() &gt; 0){\n            for(int i = 0; i &lt; size(); ++i){\n                std::cout &lt;&lt; (*this)[i]-&gt;name_ &lt;&lt; std::endl;\n            }\n        }\n    }\n};\n</code></pre>\n", "LastActivityDate": "2013-12-27T18:45:40.120", "CommentCount": "0", "CreationDate": "2013-12-27T18:45:40.120", "ParentId": "5854581", "Score": "2", "OwnerUserId": "3137470"}, "39155175": {"Id": "39155175", "PostTypeId": "2", "Body": "<p>Polymorphism means many forms as such it is used for an operator to act differently under different instances. Polymorphism is used to implement inheritance. For ex, we have defined a fn draw () for a class shape then the draw fn can be implemented for drawing circle, box, triangle and other shapes. ( which are objects of the class shape)</p>\n", "LastActivityDate": "2016-08-25T21:43:19.757", "CommentCount": "0", "CreationDate": "2016-08-25T21:43:19.757", "ParentId": "5854581", "Score": "0", "OwnerUserId": "6754813"}, "bq_ids": {"n4140": {"so_5854581_5854862_2": {"length": 16, "quality": 0.8, "section_id": 0}, "so_5854581_5854862_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}}, "n3337": {"so_5854581_5854862_2": {"length": 16, "quality": 0.8, "section_id": 0}, "so_5854581_5854862_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}}, "n4659": {"so_5854581_5854862_2": {"length": 16, "quality": 0.8, "section_id": 0}, "so_5854581_5854862_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}}}, "5854659": {"Id": "5854659", "PostTypeId": "2", "Body": "<p>As to ad-hoc polymorphism, it means function overloading or operator overloading. Check out here:</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Ad-hoc_polymorphism\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Ad-hoc_polymorphism</a></p>\n<p>As to parametric polymorphism, template functions can also be counted in because they don't necessarily take in parameters of FIXED types. For example, one function can sort array of integers and it can also sort array of strings, etc.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Parametric_polymorphism\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Parametric_polymorphism</a></p>\n", "LastEditorUserId": "419391", "LastActivityDate": "2011-05-02T07:51:01.793", "Score": "2", "CreationDate": "2011-05-02T07:44:35.723", "ParentId": "5854581", "CommentCount": "2", "OwnerUserId": "419391", "LastEditDate": "2011-05-02T07:51:01.793"}, "20028649": {"Id": "20028649", "PostTypeId": "2", "Body": "<p>In C++, the important distinction is run-time vs. compile-time binding. Ad-hoc vs. parametric doesn't really help, as I'll explain later.</p>\n<pre><code>|----------------------+--------------|\n| Form                 | Resolved at  |\n|----------------------+--------------|\n| function overloading | compile-time |\n| operator overloading | compile-time |\n| templates            | compile-time |\n| virtual methods      | run-time     |\n|----------------------+--------------|\n</code></pre>\n<p>Note - run-time polymorphism may still be resolved at compile-time, but that's just optimization. Needing to support run-time resolution efficiently, and trading off against other issues, is part of what led to virtual functions being what they are. And that's really key for all forms of polymorphism in C++ - each arises from different sets of trade-offs made in a different context.</p>\n<p>Function overloading and operator overloading are the same thing in every way that matters. The names and the syntax for using them doesn't affect polymorphism.</p>\n<p>Templates allow you to specify lots of function overloads at once.</p>\n<p>There's another set of names for the same resolution-time idea...</p>\n<pre><code>|---------------+--------------|\n| early binding | compile-time |\n| late binding  | run-time     |\n|---------------+--------------|\n</code></pre>\n<p>These names are more associated with OOP, so it's a bit odd to say that a template or other non-member function uses early binding.</p>\n<p>To better understand the relationship between virtual functions and function overloading, it's also useful to understand the difference between \"single dispatch\" and \"multiple dispatch\". The idea can be understood as a progression...</p>\n<ul>\n<li>First, there are monomorphic functions. The implementation of the function is uniquely identified by the function name. None of the parameters is special.</li>\n<li>Then, there is single dispatch. One of the parameters is considered special, and used (along with the name) to identify which implementation to use. In OOP, we tend to think of this parameter as \"the object\", list it before the function name etc.</li>\n<li>Then, there is multiple dispatch. Any/all parameters contribute to identifying which implementation to use. Therefore, once again, none of the parameters needs to be special.</li>\n</ul>\n<p>There's obviously more to OOP than an excuse to nominate one parameter as special, but that is one part of it. And relating back to what I said about trade-offs - single dispatch is quite easy to do efficiently (the usual implementation is called \"virtual tables\"). Multiple dispatch is more awkward, not just in terms of efficiency, but also for separate compilation. If you're curious, you might look up \"the expression problem\".</p>\n<p>Just as it's a bit odd to use the term \"early binding\" for non-member functions, it's a bit odd to use the terms \"single dispatch\" and \"multiple dispatch\" where polymorphism is resolved at compile-time. Usually, C++ is considered not to have multiple dispatch, which is considered a particular kind of run-time resolution. However, function overloading can be seen as multiple-dispatch done at compile-time.</p>\n<p>Getting back to parametric vs. ad-hoc polymorphism, these terms are more popular in functional programming, and they don't quite work in C++. Even so...</p>\n<p>Parametric polymorphism means that you have types as parameters, and the exact same code is used irrespective of what type you use for those parameters.</p>\n<p>Ad-hoc polymorphism is ad-hoc in the sense that you provide different code depending on the particular types.</p>\n<p>Overloading and virtual functions are both examples of ad-hoc polymorphism.</p>\n<p>Again, there's some synonyms...</p>\n<pre><code>|------------+---------------|\n| parametric | unconstrained |\n| ad-hoc     | constrained   |\n|------------+---------------|\n</code></pre>\n<p>Except these aren't quite synonyms, though they're commonly treated as though they were, and that's where confusion is likely to arise in C++.</p>\n<p>The reasoning behind treating these as synonyms is that by constraining polymorphism to particular classes of types, it becomes possible to use operations specific to those classes of types. The word \"classes\" here can be interpreted in the OOP sense, but really just refers to (usually named) sets of types that share certain operations.</p>\n<p>So parametric polymorphism is usually taken (at least by default) to imply unconstrained polymorphism. Because the same code is used irrespective of the type parameters, the only supportable operations are those that work for all types. By leaving the set of types unconstrained, you severely limit the set of operations you can apply to those types.</p>\n<p>In e.g. Haskell, you can have...</p>\n<pre><code>myfunc1 :: Bool -&gt; a -&gt; a -&gt; a\nmyfunc1 c x y = if c then x else y\n</code></pre>\n<p>The <code>a</code> here is an unconstrained polymorphic type. It could be anything, so there's not much we can do with values of that type.</p>\n<pre><code>myfunc2 :: Num a =&gt; a -&gt; a\nmyfunc2 x = x + 3\n</code></pre>\n<p>Here, <code>a</code> is constrained to be a member of the <code>Num</code> class - types that act like numbers. That constraint allows you to do number-ish things with those values, such as add them. Even the <code>3</code> is polymorphic - type inference figures out that you mean the <code>3</code> of type <code>a</code>.</p>\n<p>I think of this as constrained parametric polymorphism. There's only one implementation, but it can only be applied in constrained cases. The ad-hoc aspect is the choice of which <code>+</code> and <code>3</code> to use. Each \"instance\" of <code>Num</code> has it's own distinct implementation of these. So even in Haskell \"parametric\" and \"unconstrained\" aren't really synonyms - don't blame me, it's not my fault!</p>\n<p>In C++, both overloading and virtual functions are ad-hoc polymorphism. The definition of ad-hoc polymorphism doesn't care whether the implementation is selected at run-time or compile-time.</p>\n<p>C++ gets very close to parametric polymorphism with templates if every template parameter has type <code>typename</code>. There are type parameters, and there's a single implementation no matter which types are used. However, the \"Substitution Failure Is Not An Error\" rule means that implicit constraints arise as a result of using operations within the template. Additional complications include template specialization for providing alternative templates - different (ad-hoc) implementations.</p>\n<p>So in a way C++ has parametric polymorphism, but it's implicitly constrained and could be overridden by ad-hoc alternatives - ie this classification doesn't really work for C++.</p>\n", "LastEditorUserId": "180247", "LastActivityDate": "2013-11-17T09:41:33.677", "Score": "10", "CreationDate": "2013-11-17T08:15:41.720", "ParentId": "5854581", "CommentCount": "3", "OwnerUserId": "180247", "LastEditDate": "2013-11-17T09:41:33.677"}, "20782521": {"Id": "20782521", "PostTypeId": "2", "Body": "<p>Here is a basic example using Polymorphic classes</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Animal{\npublic:\n   Animal(const char* Name) : name_(Name){/* Add any method you would like to perform here*/\n    virtual void Speak(){\n        std::cout &lt;&lt; \"I am an animal called \" &lt;&lt; name_ &lt;&lt; std::endl;\n    }\n    const char* name_;\n};\n\nclass Dog : public Animal{\npublic:\n    Dog(const char* Name) : Animal(Name) {/*...*/}\n    void Speak(){\n        std::cout &lt;&lt; \"I am a dog called \" &lt;&lt; name_ &lt;&lt; std::endl;\n    }\n};\n\nint main(void){\n    Animal Bob(\"Bob\");\n    Dog Steve(\"Steve\");\n    Bob.Speak();\n    Steve.Speak();\n    //return (0);\n}\n</code></pre>\n", "LastEditorUserId": "784540", "LastActivityDate": "2015-09-23T13:52:15.583", "Score": "1", "CreationDate": "2013-12-26T09:43:06.857", "ParentId": "5854581", "CommentCount": "0", "OwnerUserId": "2976089", "LastEditDate": "2015-09-23T13:52:15.583"}});