post_cb({"25540631": {"Id": "25540631", "PostTypeId": "2", "Body": "<p>At least by my reading of N3337, gcc is correct and MSVC is incorrect (unless you disable its extensions).</p>\n<p>The path starts at \u00a74 of the standard:</p>\n<blockquote>\n<p id=\"so_25540033_25540631_0\">Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions.</p>\n</blockquote>\n<p>So, the only standard conversions that exist are those listed in clause 4. Not every possible standard conversion can be applied in every situation though. Only those that fit together into a standard conversion sequence can be used. A standard conversion sequence is specified as follows:</p>\n<blockquote>\n<p id=\"so_25540033_25540631_1\">\u2014 Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion.<br>\n  \u2014 Zero or one conversion from the following set: integral promotions, floating point promotion, integral conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to member conversions, and boolean conversions.<br>\n  \u2014 Zero or one qualification conversion.</br></br></p>\n</blockquote>\n<p>Here we're starting from a pointer to a function, so the conversions under the first bullet point can't apply. We don't need/care about a qualification conversion, so we don't care about the third bullet point either. </p>\n<p>To convert from <code>pointer to function</code> to <code>pointer to void</code> would clearly be a pointer conversion. These come in exactly three varieties. At \u00a74.10/1 we have pointer conversions starting from null pointer constants (which clearly doesn't apply here). \u00a74.10/2 covers conversions starting from:</p>\n<blockquote>\n<p id=\"so_25540033_25540631_2\">A prvalue of type \"pointer to <em>cv</em> T\" where T is an object type [...]</p>\n</blockquote>\n<p>That clearly doesn't apply here either, because a function isn't an object. The third option is:</p>\n<blockquote>\n<p id=\"so_25540033_25540631_3\">A prvalue of type \u201cpointer to <em>cv</em> D\u201d, where D is a class type [...]</p>\n</blockquote>\n<p>Again, a function isn't a class type, so that can't apply either.</p>\n<p>That leaves us with only one option: a single conversion directly from \"pointer to function\" to \"Boolean\". That, of course, is a Boolean conversions. \u00a74.12 says:</p>\n<blockquote>\n<p id=\"so_25540033_25540631_4\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool.</p>\n</blockquote>\n<p>So, our value can be converted to a Boolean if and only if 1) it's a prvalue, and 2) it's a pointer. That probably seems pretty obvious, but if we want to confirm, we can look to the definition of the address-of operator at \u00a75.3.1/2 and 5.3.1/3:</p>\n<blockquote>\n<p id=\"so_25540033_25540631_5\">The result of each of the following unary operators is a prvalue.</p>\n</blockquote>\n<p>That fulfills the first requirement.</p>\n<blockquote>\n<p id=\"so_25540033_25540631_6\">The result of the unary &amp; operator is a pointer to its operand. The operand shall be an lvalue or a qualified-id. If the operand is a qualified-id naming a non-static member m of some class C with type T, the result has type \u201cpointer to member of class C of type T\u201d and is a prvalue designating C::m. <strong>Otherwise, if the type of the expression is T, the result has type \u201cpointer to T\u201d and is a prvalue that is the address of the designated object (1.7) or a pointer to the designated function.</strong> [emphasis added]</p>\n</blockquote>\n<p>That clearly fulfills the second requirement--the result is a pointer.</p>\n<p>Since those requirements have been met, the conversion can/will happen. The result of the conversion is as follows (back to \u00a74.12):</p>\n<blockquote>\n<p id=\"so_25540033_25540631_7\">A zero value, null pointer value, or null member pointer value is converted to false;\n  any other value is converted to true.</p>\n</blockquote>\n<p>Since we started with a pointer to an actual function, we can't have a null pointer. That leaves only one possibility: \"any other value is converted to true.\"</p>\n<p>Precisely as the warning from gcc said, the only possible result of the conversion is a Boolean with the value <code>true</code>. That will print out as \"1\" by default, or \"true\" if <code>boolalpha</code> has been set to true.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2014-08-28T14:32:33.673", "Score": "6", "CreationDate": "2014-08-28T04:16:49.107", "ParentId": "25540033", "CommentCount": "4", "LastEditDate": "2014-08-28T14:32:33.673", "OwnerUserId": "179910"}, "25540178": {"Id": "25540178", "PostTypeId": "2", "Body": "<p>MSVC can be made to function correctly and perform the conversion from function pointer to <code>bool</code> if you disable language extensions (<code>/Za</code> switch). If you do that, your code produces the following warnings (at <code>/W4</code> on VS2013)</p>\n<pre><code>1&gt;main.cpp(8): warning C4305: 'argument' : truncation from 'void (*)(void)' to 'std::_Bool'\n1&gt;main.cpp(8): warning C4800: 'void (*)(void)' : forcing value to bool 'true' or 'false' (performance warning)\n</code></pre>\n<p>and the output is <code>1</code></p>\n<hr>\n<p>This behavior is <a href=\"http://msdn.microsoft.com/en-us/library/34h23df8.aspx\">documented</a> under the <em>Casts</em> section</p>\n<blockquote>\n<p id=\"so_25540033_25540178_0\">Both the C++ compiler and C compiler support these kinds of non-ANSI casts: <br/>\n  ... <br/>\n  Non-ANSI casts of a function pointer to a data pointer</p>\n</blockquote>\n<p>Sure enough, the following line compiles only with <code>/Za</code> disabled</p>\n<pre><code>void *p = &amp;foo;\n</code></pre>\n<p>Disabling language extensions produces the error message</p>\n<pre><code>1&gt;main.cpp(8): error C2440: 'initializing' : cannot convert from 'void (*)(void)' to 'void *'\n1&gt;          There is no context in which this conversion is possible\n</code></pre>\n</hr>", "LastEditorUserId": "241631", "LastActivityDate": "2014-08-28T03:28:44.470", "Score": "10", "CreationDate": "2014-08-28T03:18:07.580", "ParentId": "25540033", "CommentCount": "4", "LastEditDate": "2014-08-28T03:28:44.470", "OwnerUserId": "241631"}, "bq_ids": {"n4140": {"so_25540033_25540631_6": {"length": 38, "quality": 0.9047619047619048, "section_id": 6066}, "so_25540033_25540631_7": {"length": 15, "quality": 1.0, "section_id": 44}, "so_25540033_25540631_4": {"length": 13, "quality": 1.0, "section_id": 44}, "so_25540033_25540631_1": {"length": 39, "quality": 1.0, "section_id": 0}, "so_25540033_25540631_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 0}, "so_25540033_25540631_3": {"length": 6, "quality": 1.0, "section_id": 41}, "so_25540033_25540631_2": {"length": 6, "quality": 1.0, "section_id": 40}, "so_25540033_25540631_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 6065}}, "n3337": {"so_25540033_25540631_7": {"length": 15, "quality": 1.0, "section_id": 41}, "so_25540033_25540631_3": {"length": 6, "quality": 1.0, "section_id": 37}, "so_25540033_25540631_6": {"length": 38, "quality": 0.9047619047619048, "section_id": 5834}, "so_25540033_25540631_1": {"length": 39, "quality": 1.0, "section_id": 0}, "so_25540033_25540631_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 0}, "so_25540033_25540631_4": {"length": 13, "quality": 1.0, "section_id": 41}, "so_25540033_25540631_2": {"length": 6, "quality": 1.0, "section_id": 37}, "so_25540033_25540631_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 5833}}, "n4659": {"so_25540033_25540631_7": {"length": 15, "quality": 1.0, "section_id": 45}, "so_25540033_25540631_3": {"length": 6, "quality": 1.0, "section_id": 41}, "so_25540033_25540631_6": {"length": 38, "quality": 0.9047619047619048, "section_id": 7562}, "so_25540033_25540631_1": {"length": 35, "quality": 0.8974358974358975, "section_id": 0}, "so_25540033_25540631_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 0}, "so_25540033_25540631_4": {"length": 13, "quality": 1.0, "section_id": 45}, "so_25540033_25540631_2": {"length": 6, "quality": 1.0, "section_id": 40}, "so_25540033_25540631_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 7561}}}, "25540033": {"ViewCount": "185", "Body": "<p>Take the following testcase:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo()\n{}\n\nint main()\n{\n   std::cout &lt;&lt; &amp;foo &lt;&lt; std::endl;\n}\n</code></pre>\n<p>GCC 4.1.2, GCC 4.8 and GCC 4.9 (C++03 and C++11) all <a href=\"http://coliru.stacked-crooked.com/a/d00271b079cfb3f2\" rel=\"nofollow\">give the following output</a> when building and then compiling:</p>\n<pre><code>$ g++ main.cpp -o test &amp;&amp; ./test\nmain.cpp: In function 'int main()':\nmain.cpp:8:23: warning: the address of 'void foo()' will always evaluate as 'true' [-Waddress]\n   std::cout &lt;&lt; &amp;foo &lt;&lt; std::endl;\n                 ^\n1\n</code></pre>\n<p>This is supposedly because the only viable stream insertion for the function pointer is conversion-to-<code>bool</code> (and a cast to <code>void*</code> would be required to actually get an address into the stream).</p>\n<p>However, Microsoft Visual Studio 2012 and 2013 output a pointer address instead.</p>\n<p>Which set of toolchains is conformant? And is the non-conformance documented anywhere?</p>\n", "AcceptedAnswerId": "25540178", "Title": "Is Visual Studio buggy in printing the function address?", "CreationDate": "2014-08-28T03:00:26.577", "Id": "25540033", "CommentCount": "21", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-08-28T14:32:33.673", "Score": "2", "OwnerUserId": "560648", "Tags": "<c++><visual-studio><gcc><language-lawyer>", "AnswerCount": "2"}});