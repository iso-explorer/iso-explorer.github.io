post_cb({"bq_ids": {"n4140": {"so_12920808_12921672_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 7104}, "so_12920808_12921672_3": {"length": 59, "quality": 0.9833333333333333, "section_id": 7104}}, "n3337": {"so_12920808_12921672_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 6848}, "so_12920808_12921672_3": {"length": 60, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_12920808_12921672_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 8605}, "so_12920808_12921672_3": {"length": 59, "quality": 0.9833333333333333, "section_id": 8605}}}, "12920808": {"ViewCount": "433", "Body": "<p>I got the errors compiling this code with g++ 4.6 and 4.8.\ng++ 4.2 and 4.4 is OK. Is it a bug or some new language feature?</p>\n<pre><code>template &lt;typename T&gt;\nstruct A { typedef typename T::value_type type; };\n\ntemplate &lt;typename U&gt;\nstruct B\n{\n  void bar () { }\n  void foo ()\n  {\n    // OK\n    this-&gt;bar ();\n\n    // OK\n    (*this).bar ();\n\n    // Error in g++ 4.6-4.8 \n    // leads to full instantiating of template arg \"U\"\n    (&amp;*this)-&gt;bar ();\n  }\n};\n\nint main ()\n{\n  B&lt; A&lt;void&gt; &gt; b;\n  b.foo ();\n  return 0;\n}\n</code></pre>\n<p>g++ inst.cc</p>\n<pre><code>inst.cc: In instantiation of \u2018struct A&lt;void&gt;\u2019:\ninst.cc:20:5:   required from \u2018void B&lt;U&gt;::foo() [with U = A&lt;void&gt;]\u2019\ninst.cc:27:10:   required from here\ninst.cc:3:34: error: \u2018void\u2019 is not a class, struct, or union type\n   typedef typename T::value_type type;\n                                  ^\n</code></pre>\n<p><strong>Update 1</strong>: A cannot be instantiated, I know. </p>\n<p>The question is: why the compiler tries to instantiate it at \"(&amp;*this)-&gt;bar ()\" line, but not at \"this-&gt;bar ()\" or \"(*this).bar ()\" lines?</p>\n<p><strong>Update 2</strong>:</p>\n<p>The suggested workaround with <code>addressof (object)</code> is not working for me, because actually I got the error when I tried to use <code>std::bind (&amp;B::bar, this)</code>. The real code is much more complex of course and the <code>bind</code> was not used standalone, but the problem was traced to the simple <code>std::bind</code> expression.</p>\n<p>I did not want to rewrite or reinvent <code>std::bind</code>, so I had to use <em>CRTP</em> to make it work:</p>\n<pre><code>#include &lt;tr1/functional&gt;\ntemplate &lt;typename T&gt;\nstruct A { typedef typename T::value_type type; };\n\ntemplate &lt;typename Derived, typename U&gt;\nstruct B\n{\n  Derived* derived (void) { return static_cast&lt;Derived*&gt;(this); }\n\n  void bar () { }\n  void foo ()\n  {\n    // error with recent compiler.\n    // std::tr1::bind (&amp;B::bar, this) ();\n\n    // now ok\n    std::tr1::bind (&amp;Derived::bar, derived ()) ();\n  }\n};\n\nstruct C: B&lt;C, A&lt;void&gt; &gt;\n{\n};\n\nint main ()\n{\n  C c;\n  c.foo ();\n  return 0;\n}\n</code></pre>\n<p>I find such errors and workarounds to be completely illogical though.</p>\n", "AcceptedAnswerId": "12921672", "Title": "Getting the address of template class object leads to full instatiation of template parameters", "CreationDate": "2012-10-16T18:07:37.150", "Id": "12920808", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-18T23:24:12.790", "LastEditorUserId": "633160", "LastActivityDate": "2012-10-18T23:24:12.790", "Score": "9", "OwnerUserId": "633160", "Tags": "<c++><templates><gcc><instantiation>", "AnswerCount": "1"}, "12921672": {"Id": "12921672", "PostTypeId": "2", "Body": "<h2>Analysis/explanation:</h2>\n<p>What you are seeing is <em>shallow</em> instantiation, not full (see below for proof).</p>\n<p>ADL is the culprit here.</p>\n<blockquote>\n<p id=\"so_12920808_12921672_0\"><strong>Hypothesis II</strong> I'm suspecting an ADL-related thing here (classes can have static free functions (friends) declared inline. Perhaps the compiler needs to instantiate the whole class template in order to make sure it has seen the operator overloads declared in it (in order to do overload resolution).</p>\n</blockquote>\n<p>The standard backs me up here: \u00a73.4.2 (p46 in n3337):</p>\n<blockquote>\n<p id=\"so_12920808_12921672_1\"><strong>\u00b2</strong> <em>[snip]</em> The sets of namespaces and classes is determined entirely by\n  the <strong>types of the function arguments</strong> (and the namespace of any template\n  template argument). <em>[snip]</em> The sets of namespaces and classes are\n  determined in the following way:</p>\n<ul>\n<li><p id=\"so_12920808_12921672_2\"><em>[snip]</em></p></li>\n<li><p id=\"so_12920808_12921672_3\">If T is a class type (including unions), its associated classes are: the\n  class itself; the class of which it is a member, if any; and its direct and\n  indirect base classes. Its <em>associated namespaces</em> are the namespaces of which\n  its associated classes are members. Furthermore, if T is a class template\n  specialization, its associated namespaces and classes also include: <em>the\n  namespaces <strong>and classes</strong> associated with the types of the template\n  arguments provided for template type parameters</em> (excluding template\n  template parameters); the namespaces of which any template template arguments\n  are members; and the classes of which any member templates used as template\n  template arguments are members.</p></li>\n</ul>\n</blockquote>\n<p>The bolded phrase includes <code>class A&lt;void&gt;</code> as a lookup namespace for ADL.</p>\n<h2>Workaround:</h2>\n<p>In your situation <code>std::addressof(b)</code> can be used instead of <code>&amp;b</code> and it will work.</p>\n<h2>Demonstration:</h2>\n<p>See <a href=\"http://liveworkspace.org/code/4f85a06598eebe1d8060112be36f4a29\" rel=\"noreferrer\">http://liveworkspace.org/code/4f85a06598eebe1d8060112be36f4a29</a></p>\n<p>Note: the <em><code>(unqualified-id)</code></em> trick is defined in \u00a73.4.2 of the standard)</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nstruct Base {};\n\ntemplate &lt;typename U&gt; struct B : Base { };\n\ntemplate &lt;typename T&gt; struct A {\n    typedef typename T::value_type type;\n    friend void freefunction(B&lt;A&gt;&amp;) { std::cout &lt;&lt; \"ADL was here!\\n\"; }\n};\n\nvoid freefunction(Base&amp; /*acceptAll*/) {}\n\nint main ()\n{\n    B&lt; A&lt;std::vector&lt;int&gt; &gt; &gt;  a;\n    B&lt; A&lt;void&gt; &gt;               b;\n\n    // surrounding with parens prevents ADL:\n    (freefunction)(a);\n    (freefunction)(b); // selects ::freefunction(Base&amp;)\n\n    freefunction(a);   // ADL selects friend inline freefunction(B&lt; A&lt;std::vector&lt;int&gt; &gt; &gt;&amp;)\n  //freefunction(b);   // ADL fails: template arg cannot be (shallow) instantiated\n}\n</code></pre>\n<p>Prints</p>\n<pre><code>ADL was here!\n</code></pre>\n<p>Also, you can verify that the template argument (<code>A&lt;void&gt;</code>) gets <em>shallow instantiated</em> only. <strong>Moving the ill-formed typedef into a member function</strong> removes the problem:</p>\n<pre><code>template &lt;typename T&gt; struct A {\n    void uninstantiated() {\n        typedef typename T::value_type type;\n    }\n    friend void freefunction(B&lt;A&gt;&amp;) { std::cout &lt;&lt; \"ADL was here!\\n\"; }\n};\n</code></pre>\n<p>Outputs (<strong><a href=\"http://liveworkspace.org/code/a15c933293281d0926e8b1ff39180079\" rel=\"noreferrer\">http://liveworkspace.org/code/a15c933293281d0926e8b1ff39180079</a></strong>)</p>\n<pre><code>ADL was here!\nADL was here!\n</code></pre>\n<hr>\n<p>History:</p>\n<ol>\n<li>I noticed <code>operator&amp;</code> was the problem, but <code>std::addressof()</code> was ok!</li>\n<li>I noticed use of <em>any (overloaded) operators</em> seems to trigger this behaviour</li>\n</ol>\n<p>This lead me to my 'Hypothesis II' (see above)</p>\n</hr>", "LastEditorUserId": "85371", "LastActivityDate": "2012-10-16T21:14:57.973", "Score": "11", "CreationDate": "2012-10-16T19:01:52.463", "ParentId": "12920808", "CommentCount": "13", "OwnerUserId": "85371", "LastEditDate": "2012-10-16T21:14:57.973"}});