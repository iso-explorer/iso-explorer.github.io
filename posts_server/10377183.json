post_cb({"bq_ids": {"n4140": {"so_10377183_10377831_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 299}}, "n3337": {"so_10377183_10377831_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 290}}, "n4659": {"so_10377183_10377831_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 306}}}, "10377831": {"Id": "10377831", "PostTypeId": "2", "Body": "<p>I believe I have found the relevant piece of standardese. \u00a714.8.2p7 says:</p>\n<blockquote>\n<p id=\"so_10377183_10377831_0\">The substitution occurs in all types and expressions that are used in the function type and in template parameter declarations.</p>\n</blockquote>\n<p>Since <code>EnableIf&lt;dependent_true_type&lt;T&gt;&gt;</code> is used in a template parameter declaration, substitution should occur and this is <a href=\"http://llvm.org/bugs/show_bug.cgi?id=11723\" rel=\"nofollow\">a bug in clang</a>.</p>\n", "LastEditorUserId": "1381108", "LastActivityDate": "2014-10-08T18:49:06.970", "Score": "7", "CreationDate": "2012-04-30T02:24:11.240", "ParentId": "10377183", "CommentCount": "3", "OwnerUserId": "46642", "LastEditDate": "2014-10-08T18:49:06.970"}, "10377183": {"ViewCount": "524", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nenum class dummy {};\ntemplate &lt;typename T&gt;\nusing EnableIf = typename std::enable_if&lt;T::value, dummy&gt;::type;\ntemplate &lt;typename T&gt;\nusing DisableIf = typename std::enable_if&lt;!T::value, dummy&gt;::type;\n\ntemplate &lt;typename T&gt;\nstruct dependent_true_type : std::true_type {};\n\ntemplate &lt;typename T,\n          EnableIf&lt;dependent_true_type&lt;T&gt;&gt;...&gt;\nstd::true_type f();\ntemplate &lt;typename T,\n          DisableIf&lt;dependent_true_type&lt;T&gt;&gt;...&gt;\nstd::false_type f();\n\nstatic_assert(decltype(f&lt;int&gt;())::value, \"\");\n\nint main() {}\n</code></pre>\n<p>GCC 4.7 glady accepts this program. My recent clang 3.1 build claims the call to <code>f</code> is ambiguous.</p>\n<pre><code>test.c++:22:24: fatal error: call to 'f' is ambiguous\nstatic_assert(decltype(f&lt;int&gt;())::value, \"\");\n                       ^~~~~~\ntest.c++:17:16: note: candidate function [with T = int, $1 = &lt;&gt;]\nstd::true_type f();\n               ^\ntest.c++:20:17: note: candidate function [with T = int, $1 = &lt;&gt;]\nstd::false_type f();\n                ^\n1 error generated.\n</code></pre>\n<p>It does accept the program if I write <code>f&lt;int, dummy{}&gt;()</code>.</p>\n<p>It seems clang does not consider the type of the parameter pack when the pack is empty, which leads to not removing it from the candidate set. GCC seems to perform substitution on the parameter pack type even if the pack is empty, and since said substitution fails for one overload, there is no ambiguity.</p>\n<p>Which of the two is correct?</p>\n", "AcceptedAnswerId": "10377831", "Title": "Is substitution performed on a variadic parameter pack type if the pack is empty?", "CreationDate": "2012-04-30T00:18:09.740", "Id": "10377183", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-04-30T00:31:41.543", "LastEditorUserId": "46642", "LastActivityDate": "2014-10-08T18:49:06.970", "Score": "6", "OwnerUserId": "46642", "Tags": "<c++><c++11><g++><clang><sfinae>", "AnswerCount": "1"}});