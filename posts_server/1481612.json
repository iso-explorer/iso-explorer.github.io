post_cb({"bq_ids": {"n4140": {"so_1481612_1481645_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 3341}}, "n3337": {"so_1481612_1481645_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 3211}, "so_1481612_1481645_1": {"length": 56, "quality": 0.7887323943661971, "section_id": 3206}}, "n4659": {"so_1481612_1481645_0": {"length": 14, "quality": 0.5384615384615384, "section_id": 7673}}}, "1481612": {"ViewCount": "5586", "Body": "<p>Imagine two similar pieces of code:</p>\n<pre><code>try {\n  [...]\n} catch (myErr &amp;err) {\n  err.append(\"More info added to error...\");\n  throw err;\n}\n</code></pre>\n<p>and</p>\n<pre><code>try {\n  [...]\n} catch (myErr &amp;err) {\n  err.append(\"More info added to error...\");\n  throw;\n}\n</code></pre>\n<p>Are these effectively the same or do they differ in some subtle way?  For example, does the first one cause a copy constructor to be run whereas perhaps the second reuses the same object to rethrow it?</p>\n", "AcceptedAnswerId": "1481764", "Title": "What is the difference between throw and throw with arg of caught exception?", "CreationDate": "2009-09-26T16:45:49.053", "Id": "1481612", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2009-09-27T06:39:02.443", "Score": "18", "OwnerUserId": "115751", "Tags": "<c++><exception><try-catch><throw>", "AnswerCount": "2"}, "1481645": {"Id": "1481645", "PostTypeId": "2", "Body": "<p>In the second case according to C++ Standard 15.1/6 copy constructor is not used:</p>\n<blockquote>\n<p id=\"so_1481612_1481645_0\"><em>A throw-expression with no operand rethrows the exception being handled.  The exception is reactivated with the existing temporary; no new temporary exception object is created.</em> The exception is no longer considered to be caught; therefore, the value of uncaught_exception() will again be true.</p>\n</blockquote>\n<p>In the first case new exception will be thrown according to 15.1/3:</p>\n<blockquote>\n<p id=\"so_1481612_1481645_1\">A throw-expression initializes a temporary object, called the exception object, the type of which is determined by removing any top-level cv-qualifiers from the static type of the operand of throw and adjusting\n  the type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d,\n  respectively. &lt;...&gt; The temporary is used to initialize the variable named in the matching handler (15.3).  The type of the throw-expression shall not be an\n  incomplete type, or a pointer or reference to an incomplete type, other than void*, const void*,\n  volatile void*, or const volatile void*.  Except for these restrictions and the restrictions on\n  type matching mentioned in 15.3, the operand of throw is treated exactly as a function argument in a call\n  (5.2.2) or the operand of a return statement.</p>\n</blockquote>\n<p>In both cases copy constructor is required at throw stage (15.1/5):</p>\n<blockquote>\n<p id=\"so_1481612_1481645_2\">When the thrown object is a class object, and the copy constructor used to initialize the temporary copy is not accessible, the program is ill-formed (even when the temporary object could otherwise be eliminated).\n  Similarly, if the destructor for that object is not accessible, the program is ill-formed (even when the temporary object could otherwise be eliminated).</p>\n</blockquote>\n", "LastEditorUserId": "123111", "LastActivityDate": "2009-09-26T17:41:33.823", "Score": "15", "CreationDate": "2009-09-26T17:00:25.683", "ParentId": "1481612", "CommentCount": "4", "OwnerUserId": "123111", "LastEditDate": "2009-09-26T17:41:33.823"}, "1481764": {"Id": "1481764", "PostTypeId": "2", "Body": "<p>Depending on how you have arranged your exception hierarchy, re-throwing an exception by naming the exception variable in the throw statement may <em>slice</em> the original exception object.</p>\n<p>A no-argument throw expression will throw the current exception object preserving its dynamic type, whereas a throw expression with an argument will throw a new exception based on the <em>static</em> type of the argument to <code>throw</code>.</p>\n<p>E.g.</p>\n<pre><code>int main()\n{\n    try\n    {\n        try\n        {\n            throw Derived();\n        }\n        catch (Base&amp; b)\n        {\n            std::cout &lt;&lt; \"Caught a reference to base\\n\";\n            b.print(std::cout);\n            throw b;\n        }\n    }\n    catch (Base&amp; b)\n    {\n        std::cout &lt;&lt; \"Caught a reference to base\\n\";\n        b.print(std::cout);\n    }\n\n    return 0;\n}\n</code></pre>\n<p>As written above, the program will output:</p>\n<pre>Caught a reference to base\nDerived\nCaught a reference to base\nBase</pre>\n<p>If the <code>throw b</code> is replace with a <code>throw</code>, then the outer catch will also catch the originally thrown <code>Derived</code> exception. This still holds if the inner class catches the <code>Base</code> exception by value instead of by reference - although naturally this would mean that the original exception object cannot be modified, so any changes to <code>b</code> would not be reflected in the <code>Derived</code> exception caught by the outer block.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2009-09-27T06:39:02.443", "Score": "25", "CreationDate": "2009-09-26T18:01:33.063", "ParentId": "1481612", "CommentCount": "5", "OwnerUserId": "19563", "LastEditDate": "2009-09-27T06:39:02.443"}});