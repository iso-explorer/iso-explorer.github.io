post_cb({"bq_ids": {"n4140": {"so_28680325_28680414_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}, "so_28680325_28680414_1": {"length": 14, "quality": 0.6666666666666666, "section_id": 3321}, "so_28680325_28680414_2": {"length": 15, "quality": 1.0, "section_id": 14}}, "n3337": {"so_28680325_28680414_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_28680325_28680414_1": {"length": 14, "quality": 0.6666666666666666, "section_id": 3191}, "so_28680325_28680414_2": {"length": 15, "quality": 1.0, "section_id": 11}}, "n4659": {"so_28680325_28680414_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}, "so_28680325_28680414_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 4086}, "so_28680325_28680414_2": {"length": 15, "quality": 1.0, "section_id": 19}}}, "28680325": {"ViewCount": "404", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid f(const char * const &amp;s) {\n    cout &lt;&lt; \"lvalue\" &lt;&lt; endl;\n}\n\nvoid f(const char * const &amp;&amp;s) {\n    cout &lt;&lt; \"rvalue\" &lt;&lt; endl;\n}\n\nint main()\n{\n    char s[] = \"abc\";\n\n    f(\"abc\");\n    f(s);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>rvalue\nrvalue\n</code></pre>\n<p>Why isn't the output \"rvalue lvalue\"?</p>\n", "AcceptedAnswerId": "28680414", "Title": "Overload resolution with rvalue reference to const char *", "CreationDate": "2015-02-23T18:05:11.310", "Id": "28680325", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-02-26T09:35:29.953", "Score": "5", "OwnerUserId": "615789", "Tags": "<c++><c++11><lvalue><rvalue>", "AnswerCount": "2"}, "28680414": {"Id": "28680414", "PostTypeId": "2", "Body": "<p>Neither the string literal nor <code>s</code> are pointers (they are arrays), so the relevant section of the standard is [conv.array]:</p>\n<blockquote>\n<p id=\"so_28680325_28680414_0\">An lvalue or rvalue of type \"array of <code>N</code> <code>T</code>\" or \"array of unknown bound of <code>T</code>\" can be converted <strong>to a prvalue of type \"pointer to <code>T</code>\".</strong> The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>Note that</p>\n<pre><code>char const *p = s;\nf(p);\n</code></pre>\n<p>prints \"lvalue,\" to show that this works as you expect for pointers.</p>\n<p><strong>Addendum re: comment:</strong> In the case of</p>\n<pre><code>char *p = s;\nf(p);\n</code></pre>\n<p>which prints \"rvalue\" if the rvalue overload exists but does not cause a compiler error if it is removed, two other sections of the standard come into play -- one of which seems to prohibit the binding of <code>char*</code> to <code>char const *const &amp;</code> altogether, and the other opening a window back in.</p>\n<p>The first is [dcl.init.ref]/4, where it is stated that</p>\n<blockquote>\n<p id=\"so_28680325_28680414_1\">Given types \"<em>cv1</em> <code>T1</code>\" and \"<em>cv2</em> <code>T2</code>\", \"<em>cv1</em> <code>T1</code>\" is <em>reference-related</em> to \"<em>cv2</em> <code>T2</code>\" if <code>T1</code> is the same type as <code>T2</code>, or <code>T1</code> is a base-class of <code>T2</code>. \"<em>cv1</em> <code>T1</code>\" is <em>reference-compatible</em> with \"<em>cv2</em> <code>T2</code>\" if <code>T1</code> is <em>reference-related</em> to <code>T2</code> and <em>cv1</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv2</em>. (...)</p>\n</blockquote>\n<p>It goes on at length about precise rules for reference initialization, all of which is relevant but unfortunately far too long for a SO answer. The long story made short is that a reference to <em>cv1</em> <code>T1</code> can be initialized with an object of <em>cv2</em> <code>T2</code> if the two are reference-compatible.</p>\n<p>What this Legalese means for our case is that <code>char*</code> and <code>char const *</code> are not <em>reference-compatible</em> (although <code>char*</code> and <code>char *const</code> would be), because <code>char*</code> is not <code>char const *</code> nor is one a base class of the other. This restriction makes sense if you consider the following illegal piece of code that would be legal otherwise:</p>\n<pre><code>const char c = 'c';\nchar *pc;\nconst char*&amp; pcc = pc;   // #1: not allowed\npcc = &amp;c;\n*pc = 'C';               // #2: modifies a const object\n</code></pre>\n<p>This is adapted from a similar example in [conv.qual]/4 that uses a pointer to pointer to demonstrate the same problem.</p>\n<p>[conv.qual] is also the other relevant section that opens the window back in. It says in [conv.qual]/1:</p>\n<blockquote>\n<p id=\"so_28680325_28680414_2\">A prvalue of type \"pointer to <em>cv1</em> <code>T</code>\" can be converted to a prvalue of type \"pointer to <em>cv2</em> <code>T</code>\" if \"<em>cv2</em> <code>T</code>\" is more cv-qualified than \"<em>cv1</em> <code>T</code>\"</p>\n</blockquote>\n<p>It follows from all this that <code>char*</code> can be converted to <code>char const *</code><sup>1</sup> (which is reference-compatible with <code>char const *const</code>), which is why the code still compiles if the rvalue overload of <code>f</code> is removed. However, the result of this conversion is a prvalue, so if it is present, the rvalue overload is preferred in overload resolution.</p>\n<p><sup>1</sup> <code>char*</code> glvalue -&gt; <code>char*</code> prvalue (by [conv.lval]) -&gt; <code>char const *</code> prvalue)</p>\n", "LastEditorUserId": "4301306", "LastActivityDate": "2015-02-26T09:35:29.953", "Score": "3", "CreationDate": "2015-02-23T18:10:34.263", "ParentId": "28680325", "CommentCount": "6", "OwnerUserId": "4301306", "LastEditDate": "2015-02-26T09:35:29.953"}, "28680408": {"Id": "28680408", "PostTypeId": "2", "Body": "<p><code>s</code> is an array lvalue (so is <code>\"abc\"</code>, for that matter - string literals are lvalues). To get a pointer, the array-to-pointer conversion is performed. This conversion yields a pointer prvalue, which preferentially binds to the rvalue reference overload.</p>\n", "LastActivityDate": "2015-02-23T18:10:23.483", "CommentCount": "0", "CreationDate": "2015-02-23T18:10:23.483", "ParentId": "28680325", "Score": "1", "OwnerUserId": "2756719"}});