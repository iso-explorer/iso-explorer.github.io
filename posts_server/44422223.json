post_cb({"44422686": {"ParentId": "44422223", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-06-07T21:01:26.853", "Score": "0", "LastEditorUserId": "6022656", "LastEditDate": "2017-06-07T21:21:06.413", "Id": "44422686", "OwnerUserId": "6022656", "Body": "<p>What about using SFINAE through <code>std::common_type</code> ?</p>\n<p>The following is a simplified example (no <code>Vector</code> but simples values; no <code>operator+()</code> but a <code>sum()</code> function) but I hope you can understand what I mean</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n\ntemplate &lt;typename T1, typename T2&gt;\nT1 sum (T1 t1,\n        T2 const &amp; t2,\n        typename std::enable_if&lt;std::is_same&lt;\n              T1,\n              typename std::common_type&lt;T1, T2&gt;::type\n           &gt;::value&gt;::type * = nullptr)\n { return t1 += t2; }\n\nint main()\n {\n   float  a      = 1.1f;\n   double b      = 2.2;\n   long double c = 3.3;\n\n   std::cout &lt;&lt; sum(b, a) &lt;&lt; std::endl;\n   std::cout &lt;&lt; sum(c, a) &lt;&lt; std::endl;\n   std::cout &lt;&lt; sum(c, b) &lt;&lt; std::endl;\n   // std::cout &lt;&lt; sum(a, b) &lt;&lt; std::endl; compilation error\n   // std::cout &lt;&lt; sum(a, c) &lt;&lt; std::endl; compilation error\n   // std::cout &lt;&lt; sum(b, c) &lt;&lt; std::endl; compilation error\n }\n</code></pre>\n", "LastActivityDate": "2017-06-07T21:21:06.413"}, "44423095": {"ParentId": "44422223", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2017-06-07T21:29:24.847", "Score": "0", "LastEditorUserId": "951423", "LastEditDate": "2017-06-07T22:00:58.087", "Id": "44423095", "OwnerUserId": "951423", "Body": "<p>Has some assumptions with respect to <code>Vector</code> but you should get the idea:</p>\n<pre><code>template &lt;typename T1,typename T2&gt;\nVector&lt;typename std::common_type&lt;T1, T2&gt;::type&gt; \n    operator+(Vector&lt;T1&gt; const&amp; lhs, Vector&lt;T2&gt; const&amp; rhs)\n{ \n    std::size_t const n = std::min(lhs.size(), rhs.size());\n    Vector&lt;typename std::common_type&lt;T1, T2&gt;::type&gt; res(n);\n    for(std::size_t i{}; i &lt; n; ++i) res[i] = a[i] + b[i];\n    return res; \n}\n\nVector&lt;double&gt; a = Vector&lt;double&gt;() + Vector&lt;float&gt;(); // OK\nVector&lt;double&gt; b = Vector&lt;float&gt;() + Vector&lt;double&gt;(); // OK\n</code></pre>\n", "LastActivityDate": "2017-06-07T22:00:58.087"}, "bq_ids": {"n4140": {"so_44422223_44423522_0": {"section_id": 3329, "quality": 1.0, "length": 20}}, "n3337": {"so_44422223_44423522_0": {"section_id": 3199, "quality": 1.0, "length": 20}}, "n4659": {"so_44422223_44423522_0": {"section_id": 4095, "quality": 1.0, "length": 20}}}, "44423522": {"ParentId": "44422223", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-06-07T22:03:20.373", "Score": "0", "LastEditorUserId": "4987285", "LastEditDate": "2017-06-07T22:30:44.860", "Id": "44423522", "OwnerUserId": "4987285", "Body": "<p>You can use the <code>{}</code> constructor and let it detects <a href=\"http://eel.is/c++draft/dcl.init.list#7\" rel=\"nofollow noreferrer\">narrowing conversions</a> for you.<br>\nYou can do that with something like this:</br></p>\n<pre><code>template&lt;typename T&gt;\nstruct Vector {\n    T value;\n};\n\ntemplate &lt;typename T1, typename T2&gt;\nauto operator+(Vector&lt;T1&gt;, const Vector&lt;T2&gt;&amp; rhs)\n-&gt; decltype(T1{rhs.value}, Vector&lt;T1&gt;{})\n{ return {}; }\n\nint main() {\n    auto a = Vector&lt;double&gt;{} + Vector&lt;float&gt;{};\n    //auto b = Vector&lt;float&gt;{} + Vector&lt;double&gt;{};\n    (void)a;\n}\n</code></pre>\n<p>That is, you can use the usual form for sfinae'd expressions involving a trailing return type.<br>\nIn case your <code>Vector</code> class template hasn't a default constructor, you can still work around it with <code>std::declval</code>:</br></p>\n<pre><code>-&gt; decltype(T1{rhs.value}, std::declval&lt;Vector&lt;T1&gt;&gt;())\n</code></pre>\n<p>Note that, because of <a href=\"http://eel.is/c++draft/dcl.init.list#7.2\" rel=\"nofollow noreferrer\">[dcl.init.list]/7.2</a> and the other bullets that follow, you can't simply do this in the code above:</p>\n<pre><code>-&gt; decltype(T1{T2{}}, Vector&lt;T1&gt;{})\n</code></pre>\n<p>Otherwise, in your specific example, the following would be valid:</p>\n<pre><code>auto b = Vector&lt;float&gt;{} + Vector&lt;double&gt;{};\n</code></pre>\n<p>Therefore you must use the actual value provided along with <code>rhs</code> and (let me say) <em>test it</em> with the actual type used to specialize <code>lhs</code>.<br>\nAs long as the contained value is accessible (either it is valid or the operator is a friend of your class) this shouldn't be a problem.</br></p>\n<hr>\n<p>As a side note, you can't\u200b correctly define a <code>is_narrowing_conversion</code> that works properly in your case by using only the types <code>T1</code> and <code>T2</code>.<br>\nAs an example, consider <a href=\"http://eel.is/c++draft/dcl.init.list#7.2\" rel=\"nofollow noreferrer\">[dcl.init.list]/7.2</a> (emphasis mine) and the test code you proposed:</br></p>\n<blockquote>\n<p id=\"so_44422223_44423522_0\">[...] or from\u00a0double to\u00a0float, <strong>except where the source is a constant expression and the actual value after conversion is within the range of values that can be represented (even if it cannot be represented exactly)</strong> [...]</p>\n</blockquote>\n<p>For you don't have actual values with which to make a test, all what you can do is trying something like <code>T1{T2{}}</code>. Anyway this wouldn't work. In other words, <code>float{double{}}</code> would be accepted without errors because of the bullet above mentioned.<br>\nSomething similar applies to few other types.</br></p>\n<hr>\n<p>Another valid approach is to use <code>std::common_type</code>.<br>\nAnyway, there is already a <a href=\"https://stackoverflow.com/a/44422686/4987285\">pretty good answer</a> that proposes it. It wouldn't worth repeating the example code once more.</br></p>\n</hr></hr>", "LastActivityDate": "2017-06-07T22:30:44.860"}, "44422223": {"CommentCount": "0", "AcceptedAnswerId": "44422686", "PostTypeId": "1", "LastEditorUserId": "6022656", "CreationDate": "2017-06-07T20:31:06.513", "LastActivityDate": "2017-06-07T22:30:44.860", "LastEditDate": "2017-06-07T21:02:17.647", "ViewCount": "80", "FavoriteCount": "1", "Title": "How can I use SFINAE to prevent narrowing in a template function?", "Id": "44422223", "Score": "2", "Body": "<p>I am trying to implement basic arithmetic operations for a Vector class and would like to support mixing underlying types while preventing narrowing from occurring.</p>\n<pre><code>template &lt;typename T1,typename T2&gt;\nVector&lt;T1&gt; operator+( Vector&lt;T1&gt; lhs, const Vector&lt;T2&gt;&amp; rhs, std::enable_if&lt; ! is_narrowing_conversion&lt;T2,T1&gt;::value &gt;::type* = nullptr )\n{ return lhs += rhs; }\n</code></pre>\n<p>I would like to implement is_narrowing_conversion so that it will only allow the conversion if the types do not narrow. Here are some examples:</p>\n<pre><code>Vector&lt;double&gt; a = Vector&lt;double&gt;() + Vector&lt;float&gt;(); //OK\nVector&lt;float&gt; a = Vector&lt;float&gt; + Vector&lt;double&gt;; //Fails to find the operator+ function\n</code></pre>\n<p>In the end I would like to write a second template operator+ function that will handle the inverse case by returning a Vector.</p>\n<p>I found this post <a href=\"https://stackoverflow.com/questions/36270158/avoiding-narrowing-conversions-with-c-type-traits\">with an incomplete example</a>. But it is insufficient as he notes that it disallows uint8_t to uint64_t conversions.</p>\n<p>I also discovered <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html\" rel=\"nofollow noreferrer\">Daniel Kr\u00fcgler's paper on fixing is_constructible</a>. Specifically in this paper he mentions using list-initialization which already has the narrowing semantics working but I'm not sure how to convert what he mentions into a proper trait that I can use for SFINAE template deduction.</p>\n", "Tags": "<c++><c++11><sfinae><narrowing>", "OwnerUserId": "8127847", "AnswerCount": "3"}});