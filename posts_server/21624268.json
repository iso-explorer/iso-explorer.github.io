post_cb({"bq_ids": {"n4140": {"so_21624268_21624819_3": {"length": 6, "quality": 0.75, "section_id": 1435}, "so_21624268_21624819_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 1441}, "so_21624268_21624819_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 1437}}, "n3337": {"so_21624268_21624819_3": {"length": 6, "quality": 0.75, "section_id": 1429}, "so_21624268_21624819_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 1435}, "so_21624268_21624819_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 1431}}, "n4659": {"so_21624268_21624819_3": {"length": 6, "quality": 0.75, "section_id": 1572}, "so_21624268_21624819_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 1583}}}, "21624819": {"Id": "21624819", "PostTypeId": "2", "Body": "<p>Looking at the references for <a href=\"http://en.cppreference.com/w/cpp/algorithm/merge\" rel=\"noreferrer\">std::merge</a> and <a href=\"http://en.cppreference.com/w/cpp/algorithm/inplace_merge\" rel=\"noreferrer\">std::inplace_merge</a> you see the following complexities:<br>\nFor <code>std::merge</code>:</br></p>\n<blockquote>\n<p id=\"so_21624268_21624819_0\">At most std::distance(first1, last1) + \n  std::distance(first2, last2) - 1 comparisons.</p>\n</blockquote>\n<p>And for <code>std::inplace_merge</code>:  </p>\n<blockquote>\n<p id=\"so_21624268_21624819_1\">Exactly N-1 comparisons if enough additional memory is available,\n  otherwise N\u00b7log(N) where N = std::distance(first, last).</p>\n</blockquote>\n<p>The <code>if enough additional memory is available</code> has a very specific meaning, from the notes on that page:</p>\n<blockquote>\n<p id=\"so_21624268_21624819_2\">This function attempts to allocate a temporary buffer, typically by calling\n  std::get_temporary_buffer. If the allocation fails, the less efficient \n  algorithm is chosen.</p>\n</blockquote>\n<p><code>std::get_temporary_buffer</code> allocates memory dynamically (this is important to know if you wanted to use <code>std::inplace_merge</code> in a tight loop or have constrained memory requirements).</p>\n<p>Lastly, the reference pages don't mention this (<strong>edit</strong>: cppreference has been updated as per the comment below), but in <code>std::merge</code> I don't think <code>d_first</code> can can overlap either of <code>[first1, last1)</code> or <code>[first2, last2)</code>.  This means that <code>std::merge</code> must output into a different range than either input ranges.<br>\nIt also means the following call (for some <code>RandomAccessContainer</code> <code>a</code>):</br></p>\n<pre><code>    std::inplace_merge(a.begin(), a.begin() + n, a.end());\n</code></pre>\n<p>is not equivalent to:</p>\n<pre><code>    std::merge(a.begin(), a.begin() + n,\n               a.begin() + n, a.end(), a.begin());\n</code></pre>\n<p>because you can't output into <code>a</code> if you're reading from it.  You would need:</p>\n<pre><code>    decltype(a) b;\n    std::merge(a.begin(), a.begin() + n,\n               a.begin() + n, a.end(),\n               std::back_inserter(b));\n</code></pre>\n<p>for example.</p>\n<p>Interestingly, <a href=\"http://www.cplusplus.com/reference/algorithm/merge/?kw=merge\" rel=\"noreferrer\">this reference</a> states that the ranges shall not overlap (just above the return value section) which seems more strict than necessary because it means that the two input ranges also shall not overlap.  Furthermore, in the data races section it quite clearly states that the two input ranges are only accessed, so this slightly contrived (artificial) example:</p>\n<pre><code>    std::merge(a.begin(), a.end(), a.begin(), a.end(), b.begin());\n</code></pre>\n<p>would be illegal according to that, but I'm not convinced.  Neither of these references are the standard, and unfortunately I don't have a copy of it to reference myself, but perhaps someone with access can verify these requirements.</p>\n<p><strong>EDIT</strong>:<br>\nWith the helpful pointer from TemplateRex to a draft of the standard, I can now say </br></p>\n<p><strong><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"noreferrer\">N3797</a> 25.4.4 [alg.merge]</strong></p>\n<blockquote>\n<p id=\"so_21624268_21624819_3\">2 <em>Requires</em>: [...] The resulting range shall not overlap with either of\n  the original ranges.</p>\n</blockquote>\n<p>Which confirms exactly what I was saying.</p>\n", "LastEditorUserId": "1277769", "LastActivityDate": "2014-02-07T17:08:28.573", "Score": "19", "CreationDate": "2014-02-07T10:10:13.180", "ParentId": "21624268", "CommentCount": "10", "OwnerUserId": "1277769", "LastEditDate": "2014-02-07T17:08:28.573"}, "21624268": {"ViewCount": "2608", "Body": "<p>What is the difference between <code>std::merge</code> and <code>std::inplace_merge</code> in terms of complexity and result when it is executed on two consecutive ranges with elements that are all different ? (I am not a native english speaker and I am not sure to clearly understand what \"inplace\" means)</p>\n", "AcceptedAnswerId": "21624819", "Title": "Difference between std::merge and std::inplace_merge?", "CreationDate": "2014-02-07T09:45:45.210", "Id": "21624268", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-02-07T17:08:28.573", "Score": "16", "OwnerUserId": "882932", "Tags": "<c++><algorithm><c++11><stl><stl-algorithm>", "AnswerCount": "1"}});