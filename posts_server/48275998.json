post_cb({"48276426": {"Id": "48276426", "PostTypeId": "2", "Body": "<p>Most of this is required behavior (and most of what isn't still borders on being required).</p>\n<p>To be specific, the C++ standard says that iostreams are associated with C-style input and output streams, so <code>cout</code> is associated with <code>stdout</code> (\u00a7[narrow.stream.objects]/3):</p>\n<blockquote>\n<p id=\"so_48275998_48276426_0\">The object <code>cout</code> controls output to a stream buffer associated with the object <code>stdout</code>, declared in <code>&lt;cstdio&gt;</code>.</p>\n</blockquote>\n<p>The C standard, in turn, defines narrow-character output as being as-if written via <code>fputc</code> (\u00a77.19.3/12): </p>\n<blockquote>\n<p id=\"so_48275998_48276426_1\">The byte output functions write characters to the stream as if by successive calls to the <code>fputc</code> function.</p>\n</blockquote>\n<p><code>fputc</code> requires (\u00a77.19.7.3/2):</p>\n<blockquote>\n<p id=\"so_48275998_48276426_2\">The <code>fputc</code> function writes the character specified by <code>c</code> (converted to an <code>unsigned char</code>) to the output stream pointed to by <code>stream</code>, [...]</p>\n</blockquote>\n<p>So, yes, the conversion to <code>unsigned char</code> is exactly what the standards require. The C standard requires that conversion from signed to unsigned (of any integer type, including <code>char</code>) happen in the following fashion (\u00a76.3.1.3/2):</p>\n<blockquote>\n<p id=\"so_48275998_48276426_3\">Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.</p>\n</blockquote>\n<p>So yes, it is converted to unsigned by adding 256 (assuming <code>unsigned char</code> can represent values from 0 to 255, as is typical).</p>\n<p>So that leaves us one part that the standard sort of attempts to require, without going quite all the way--the transformation that <code>widen</code> has to do (\u00a7[locale.ctype.virtuals]/10):</p>\n<blockquote>\n<p id=\"so_48275998_48276426_4\">Applies the simplest reasonable transformation from a char value or sequence of char values to the corresponding charT value or values.</p>\n</blockquote>\n<p>Since it's a little difficult to decide exactly what's \"reasonable\", this <em>could</em> carry out some more or less arbitrary mapping on your character. In fact, it's apparently mapping input to output without modification (at least for the particular character you're writing), but it's true that other transformations could fall within \"reasonable\", and it would ultimately be difficult to draw a hard line saying that any particular transformation was not \"reasonable\".</p>\n<p>The other part that's not really required by the C++ (or any other) standard is how something else will interpret that output. All the language standards can mandate is what gets written to the stream. The part with something else opening that stream and interpreting its content as \"extended ASCII\" (probably one of the ISO 8859 variants) is clearly outside the control of the language (or much of anything else in your program, of course).</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2018-01-16T16:58:41.610", "Score": "1", "CreationDate": "2018-01-16T07:55:32.607", "ParentId": "48275998", "CommentCount": "9", "OwnerUserId": "179910", "LastEditDate": "2018-01-16T16:58:41.610"}, "bq_ids": {"n4140": {"so_48275998_48276426_4": {"length": 13, "quality": 1.0, "section_id": 6486}, "so_48275998_48276426_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 1925}}, "n3337": {"so_48275998_48276426_4": {"length": 13, "quality": 1.0, "section_id": 6241}, "so_48275998_48276426_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 1914}}, "n4659": {"so_48275998_48276426_4": {"length": 13, "quality": 1.0, "section_id": 7968}, "so_48275998_48276426_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 2196}}}, "48276357": {"Id": "48276357", "PostTypeId": "2", "Body": "<p>Use type casting to <code>int</code>...</p>\n<pre><code>std::cout &lt;&lt; (int)a;\n</code></pre>\n<p>...or, following better C++ programming style (as Christian Hackl suggested):</p>\n<pre><code>std::cout &lt;&lt; static_cast&lt;int&gt;(a);\n</code></pre>\n<p>This actually does not answer your questions (already been answered by Holt), but shows a solution to the problem.</p>\n", "LastEditorUserId": "580083", "LastActivityDate": "2018-01-16T08:39:48.493", "Score": "2", "CreationDate": "2018-01-16T07:52:12.527", "ParentId": "48275998", "CommentCount": "6", "OwnerUserId": "580083", "LastEditDate": "2018-01-16T08:39:48.493"}, "48276121": {"Id": "48276121", "PostTypeId": "2", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2\" rel=\"nofollow noreferrer\">this</a>, the following overload is selected:</p>\n<pre><code>template&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,\n                                        signed char ch );\n</code></pre>\n<p>And since <code>signed char</code> is not <code>char</code>, <code>a</code> is first converted to a <code>char</code> using <a href=\"http://en.cppreference.com/w/cpp/io/basic_ios/widen\" rel=\"nofollow noreferrer\"><code>widen</code></a>:</p>\n<pre><code>char_type widen( char c ) const;\n</code></pre>\n<p>So your code is equivalent to:</p>\n<pre><code>std::cout &lt;&lt; std::cout.widen(c);\n// or:\nstd::cout &lt;&lt; std::use_facet&lt; std::ctype&lt;char&gt; &gt;(getloc()).widen(c)\n</code></pre>\n<p>As you can see, <code>widen</code> takes a <code>char</code>, so you'll have a conversion from <code>signed char</code> to <code>char</code> prior to the actual \"widening\". </p>\n<p>Even if you are widening from a <code>char</code> to a <code>char</code>, the behavior is implementation-defined \u2014 The standard makes no guarantee regarding this.</p>\n", "LastEditorUserId": "2666289", "LastActivityDate": "2018-01-16T11:11:19.640", "Score": "5", "CreationDate": "2018-01-16T07:36:14.477", "ParentId": "48275998", "CommentCount": "4", "OwnerUserId": "2666289", "LastEditDate": "2018-01-16T11:11:19.640"}, "48275998": {"ViewCount": "135", "Body": "<p>How C++ handles cout of negative value of signed char? Is the behavour defined in C++11 standard? I am using MinGW C++ 11 compiler. It looks the signed value is converted to unsigned type by adding 256 and then prints extended ASCII characters. </p>\n<pre><code>signed char a=-35;\nstd::cout&lt;&lt;a;\n</code></pre>\n", "Title": "cout of negative value of signed char in C++", "CreationDate": "2018-01-16T07:27:21.973", "LastActivityDate": "2018-01-16T16:58:41.610", "CommentCount": "2", "PostTypeId": "1", "Id": "48275998", "Score": "3", "OwnerUserId": "6446479", "Tags": "<c++><c++11><gcc>", "AnswerCount": "3"}});