post_cb({"bq_ids": {"n4140": {"so_11335525_11335683_1": {"length": 19, "quality": 1.0, "section_id": 441}, "so_11335525_11335683_0": {"length": 20, "quality": 1.0, "section_id": 441}}, "n3337": {"so_11335525_11335683_1": {"length": 19, "quality": 1.0, "section_id": 432}, "so_11335525_11335683_0": {"length": 20, "quality": 1.0, "section_id": 432}}, "n4659": {"so_11335525_11335683_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 461}, "so_11335525_11335683_0": {"length": 20, "quality": 1.0, "section_id": 461}}}, "11335525": {"ViewCount": "275", "Body": "<p>I know that within constructor of Base class - when calling virtual method - the Base method is called, not derived - see <a href=\"https://stackoverflow.com/questions/962132/calling-virtual-functions-inside-constructors\">Calling virtual functions inside constructors</a>.</p>\n<p>My question is related to this topic. I've just wondered what happens if I call virtual method in Derived class constructor - but before constructing Base part. I mean calling virtual method to evaluate Base class constructor argument, See code:</p>\n<pre><code>class Base {\npublic:\n  Base(const char* name) : name(name) {\n    cout &lt;&lt; \"Base():\" &lt;&lt; name &lt;&lt; endl;\n  }\n  virtual const char* getName() { \n    cout &lt;&lt; \"Base::getName()\" &lt;&lt; endl;\n    return \"Base\";\n  }\nprotected:\n  const char* name;\n};\n\nclass Derived : public Base {\npublic:\n  Derived() : Base(getName()) {\n    cout &lt;&lt; \"Derived():\" &lt;&lt; name &lt;&lt; endl;\n  }\n  virtual const char* getName() { \n    cout &lt;&lt; \"Derived::getName()\" &lt;&lt; endl;\n    return \"Derived\";\n  }\n};\n\nint main() {\n  Derived d;\n}\n</code></pre>\n<p>Compiler g++ (4.3.x-4.5x versions) output is:</p>\n<pre><code>Derived::getName()\nBase():Derived\nDerived():Derived \n</code></pre>\n<p>However I'd expect:</p>\n<pre><code>Base::getName()\nBase():Base\nDerived():Base\n</code></pre>\n<p>This does not look wrong - but consider this example, which produces <code>segmentation fault</code>:</p>\n<pre><code>class Derived : public Base {\npublic:\n  Derived() : Base(getName()), name(new string(\"Derived\")) {\n    cout &lt;&lt; \"Derived():\" &lt;&lt; Base::name &lt;&lt; endl;\n  }\n  virtual const char* getName() { \n    cout &lt;&lt; \"Derived::getName()\" &lt;&lt; endl;\n    return name-&gt;c_str();\n  }\nprivate:\n  string* name;\n};\n</code></pre>\n<p>Please answer: Is this correct g++ behavior? What C++ standard says about that? Maybe it is undefined behavior?</p>\n<p>[UPDATE1]\nI take into consideration Robert and Oli answers - and I changed my first example. Then it getName() is called \"virtual\" - and it produces Segmentation Fault. Please answer my question to this part too.</p>\n<pre><code>const char* virtualGetName(Base* basePtr)\n{\n  return basePtr-&gt;getName();\n}\n\nclass Derived : public Base {\npublic:\n  Derived() : Base(virtualGetName(this)) {\n    cout &lt;&lt; \"Derived():\" &lt;&lt; Base::name &lt;&lt; endl;\n  }\n  virtual const char* getName() { \n    cout &lt;&lt; \"Derived::getName()\" &lt;&lt; endl;\n    return \"Derived\";\n  }\n};\n</code></pre>\n", "AcceptedAnswerId": "11335683", "Title": "Is this correct: virtual method of Derived called before constructing Base object?", "CreationDate": "2012-07-04T21:16:06.803", "Id": "11335525", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:48:53.383", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-04T22:58:26.783", "Score": "4", "OwnerUserId": "1463922", "Tags": "<c++><constructor><g++><standards><virtual-method>", "AnswerCount": "2"}, "11335607": {"Id": "11335607", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11335525_11335607_0\">I've just wondered what happens if I call virtual method in Derived class constructor - but before constructing Base part.</p>\n</blockquote>\n<p>It might look like you're doing this, but you're not.</p>\n<p>In your first example, <code>Derived::getName()</code> does not depend on <code>this</code>, so the method call works.  In your second example, <code>Derived::getName()</code> does depend on <code>this</code>.  Since <code>this-&gt;name</code> is not yet set, it points to an undefined location and gives you a segfault.  </p>\n<p><code>this-&gt;name</code> is not yet set, because the first thing the <code>Derived</code> constructor does is call the <code>Base</code> constructor.  If you specify the parameters to pass to the <code>Base</code> constructor, it processes them first.  Then it instantiates the member variables of the class by calling their constructors.  The initializer list can be used to pass parameters to those constructors, but it cannot change the order in which they get called.  This step is where <code>name</code> gets initialized.  Finally, the body of the <code>Derived</code> constructor is executed.</p>\n", "LastActivityDate": "2012-07-04T21:26:29.610", "CommentCount": "2", "CreationDate": "2012-07-04T21:26:29.610", "ParentId": "11335525", "Score": "1", "OwnerUserId": "382471"}, "11335683": {"Id": "11335683", "PostTypeId": "2", "Body": "<p>All of your examples exhibit undefined behavior.  The C++ language standard states (C++11 \u00a712.6.2/13):</p>\n<blockquote>\n<p id=\"so_11335525_11335683_0\">Member functions (including virtual member functions) can be called for an object under construction.  Similarly, an object under construction can be the operand of the <code>typeid</code> operator or of a <code>dynamic_cast</code>.</p>\n<p id=\"so_11335525_11335683_1\">However, if these operations are performed in a <em>ctor-initializer</em> (or in a function called directly or indirectly from a <em>ctor-initializer</em>) before all the <em>mem-initializers</em> for base classes have completed, the result of the operation is undefined.</p>\n</blockquote>\n<p>You are calling the member function <code>getName()</code> from the initialization list (the <em>ctor-initializer</em>) of the <code>Derived</code> class constructor.  This member function call must take place before the initializer for <code>Base</code> completes (the <em>mem-initializer</em> for <code>Base</code>) because it is an argument to the initializer itself.</p>\n<p>Therefore, the behavior is undefined.</p>\n<p>As a rule, <a href=\"http://www.artima.com/cppsource/nevercall.html\">Never Call Virtual Functions during Construction or Destruction</a>.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2012-07-04T22:58:26.783", "Score": "11", "CreationDate": "2012-07-04T21:38:24.170", "ParentId": "11335525", "CommentCount": "4", "OwnerUserId": "151292", "LastEditDate": "2012-07-04T22:58:26.783"}});