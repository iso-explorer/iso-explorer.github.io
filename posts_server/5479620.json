post_cb({"5479666": {"ParentId": "5479620", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>The result of <code>?:</code> is an rvalue, a new object, if one of the arguments is an rvalue. To create this rvalue, the compiler must copy whatever the result is.</p>\n<pre><code>if (some_condition)\n    S().f(); // Compiler knows that it's rvalue\nelse\n    my_other_S.f(); // Compiler knows that it's lvalue\n</code></pre>\n<p>This is for the same reason that you can't do</p>\n<pre><code>struct B { private: B(const B&amp;); };\nstruct C { C(B&amp;); C(const B&amp;); };\nint main() {\n    B b;\n    C c(some_condition ? b : B());\n}\n</code></pre>\n<p>I changed my example, because the old one was a bit suck. You can clearly see here there is no way to compile this expression because the compiler can't know what constructor to call. Of course, in this case, the compiler could coerce both arguments to <code>const B&amp;</code>, but for some reason which is not very relevant, it won't.</p>\n<p>Edit: No, there isn't, because there's no way to compile that expression, as important data about it (rvalue or lvalue) varies at run-time. The compiler tries to fix this problem for you by converting to rvalue by copy constructing, but it can't because it can't copy, so it can't compile.</p>\n", "OwnerUserId": "298661", "LastEditorUserId": "298661", "LastEditDate": "2011-03-29T23:12:57.893", "Id": "5479666", "Score": "8", "CreationDate": "2011-03-29T22:23:34.017", "LastActivityDate": "2011-03-29T23:12:57.893"}, "5479673": {"ParentId": "5479620", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From <code>[expr.cond]</code> (wording from draft n3242):</p>\n<blockquote>\n<p id=\"so_5479620_5479673_0\">Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class type, or if both are glvalues of the same value category and the same type except for cv-qualification, an attempt is made to convert each of those operands to the type of the other.  The process for determining whether an operand expression <code>E1</code> of type <code>T1</code> can be converted to match an operand expression <code>E2</code> of type <code>T2</code> is de\ufb01ned as follows:</p>\n<ul>\n<li>If <code>E2</code> is an lvalue: <code>E1</code> can be converted to match <code>E2</code> if <code>E1</code> can be implicitly converted (Clause 4) to the type \u201clvalue reference to <code>T2</code>\u201d, subject to the constraint that in the conversion the reference must bind directly (8.5.3) to an lvalue.</li>\n<li>If <code>E2</code> is an xvalue: <code>E1</code> can be converted to match <code>E2</code> if <code>E1</code> can be implicitly converted to the type \u201crvalue reference to <code>T2</code>\u201d, subject to the constraint that the reference must bind directly.</li>\n<li><p id=\"so_5479620_5479673_1\">If <code>E2</code> is an rvalue or if neither of the conversions above can be done and at least one of the operands has (possibly cv-qualified) class type:</p>\n<ul>\n<li>if <code>E1</code> and <code>E2</code> have class type, and the underlying class types are the same or one is a base class of the other:  <code>E1</code> can be converted to match <code>E2</code> if the class of <code>T2</code> is the same type as, or a base class of, the class of <code>T1</code>, and the cv-qualification of <code>T2</code> is the same cv-qualification as, or a greater cv-qualification than, the cv-qualification of <code>T1</code>.  If the conversion is applied, <code>E1</code> is changed to a prvalue of type <code>T2</code> by copy-initializing a temporary of type <code>T2</code> from <code>E1</code> and using that temporary as the converted operand.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>This rule mentions copy-initialization, but it does not apply since both operands have the same type</p>\n<blockquote>\n<p id=\"so_5479620_5479673_2\">If the second and third operands are glvalues of the same value category and have the same type, the result\n  is of that type and value category and it is a bit-field if the second or the third operand is a bit-field, or if\n  both are bit-fields.</p>\n</blockquote>\n<p>This rule does not apply because <code>S()</code> is an rvalue and <code>my_other_S</code> is an lvalue.</p>\n<blockquote>\n<p id=\"so_5479620_5479673_3\">Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed. Otherwise, the conversions thus determined are applied, and the converted operands are used in place of the original\n  operands for the remainder of this section.\n  Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are per-formed on the second and third operands. After those conversions, one of the following shall hold:</p>\n<ul>\n<li>The second and third operands have the same type; the result is of that type.  If the operands have class type, <strong>the result is a prvalue temporary of the result type, which is copy-initialized</strong> from either the second operand or the third operand depending on the value of the first operand.</li>\n</ul>\n</blockquote>\n<p>This rule is applied, the result is copy initialized (emphasis mine).</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-03-29T22:35:36.460", "Id": "5479673", "Score": "7", "CreationDate": "2011-03-29T22:25:14.573", "LastActivityDate": "2011-03-29T22:35:36.460"}, "5479620": {"CommentCount": "4", "ViewCount": "922", "PostTypeId": "1", "LastEditorUserId": "141719", "CreationDate": "2011-03-29T22:19:45.910", "LastActivityDate": "2011-03-30T06:52:25.627", "Title": "Why is a copy constructor required here?", "AcceptedAnswerId": "5479666", "LastEditDate": "2011-03-29T22:47:30.863", "Id": "5479620", "Score": "4", "Body": "<p>Consider the following code:</p>\n<pre><code>struct S\n{\n    S() {}\n    void f();\nprivate:\n    S(const S&amp;);\n};\n\nint main()\n{\n    bool some_condition;\n    S my_other_S;\n    (some_condition ? S() : my_other_S).f();\n    return 0;\n}\n</code></pre>\n<p>gcc fails to compile this, saying:</p>\n<pre><code>test.cpp: In function 'int main()':\ntest.cpp:6:5: error: 'S::S(const S&amp;)' is private\ntest.cpp:13:29: error: within this context\n</code></pre>\n<p>I don't see why copy construction should be taking place on that line - the intention is to simply call <code>f()</code> on either a default-constructed <code>S</code> instance, or on <code>my_other_S</code>, i.e. it should be equivalent to:</p>\n<pre><code>if (some_condition)\n    S().f();\nelse\n    my_other_S.f();\n</code></pre>\n<p>What is different in the first case and why is a copy constructor required?</p>\n<p><strong>EDIT</strong>: Is there any way, then, to express \"perform this operation on either a temporary on a preexisting object\" in an expression context?</p>\n", "Tags": "<c++><copy-constructor><ternary-operator>", "OwnerUserId": "141719", "AnswerCount": "4"}, "5479706": {"ParentId": "5479620", "CommentCount": "0", "Body": "<p>This is an old known issue. See here </p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#446\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#446</a></p>\n<p>According to the committee decisions, in your example the <code>?:</code> operator should always return a temporary object, meaning that for <code>my_other_s</code> branch, the original <code>my_other_s</code> object will have to be copied. This is why the compiler requires the copy constructor.</p>\n<p>This language is not yet in C++03, but many compilers implemented this approach from the very start.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "5479706", "Score": "4", "CreationDate": "2011-03-29T22:30:03.813", "LastActivityDate": "2011-03-29T22:30:03.813"}, "5482907": {"ParentId": "5479620", "CommentCount": "1", "Body": "<p>As for your updated question, if the modification of <code>S</code>'s definition is\nallowed, the following work-around might help:</p>\n<pre><code>struct S\n{\n    ...\n    S&amp; ref() { return *this; } // additional member function\n    ...\n};\n\n(some_condition ? S().ref() : my_other_S).f();\n</code></pre>\n<p>Hope this helps</p>\n", "OwnerUserId": "547710", "PostTypeId": "2", "Id": "5482907", "Score": "1", "CreationDate": "2011-03-30T06:52:25.627", "LastActivityDate": "2011-03-30T06:52:25.627"}, "bq_ids": {"n4140": {"so_5479620_5479673_0": {"section_id": 6169, "quality": 0.9545454545454546, "length": 42}, "so_5479620_5479673_3": {"section_id": 6171, "quality": 0.6923076923076923, "length": 36}, "so_5479620_5479673_2": {"section_id": 6170, "quality": 1.0, "length": 21}, "so_5479620_5479673_1": {"section_id": 6169, "quality": 1.0, "length": 13}}, "n3337": {"so_5479620_5479673_0": {"section_id": 5930, "quality": 0.9545454545454546, "length": 42}, "so_5479620_5479673_3": {"section_id": 5932, "quality": 0.6923076923076923, "length": 36}, "so_5479620_5479673_2": {"section_id": 5931, "quality": 1.0, "length": 21}, "so_5479620_5479673_1": {"section_id": 5930, "quality": 1.0, "length": 13}}, "n4659": {"so_5479620_5479673_0": {"section_id": 7667, "quality": 0.7954545454545454, "length": 35}, "so_5479620_5479673_1": {"section_id": 7667, "quality": 0.8461538461538461, "length": 11}, "so_5479620_5479673_2": {"section_id": 7668, "quality": 1.0, "length": 21}, "so_5479620_5479673_3": {"section_id": 7669, "quality": 0.6923076923076923, "length": 36}}}});