post_cb({"bq_ids": {"n4140": {"so_377178_377208_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 6815}, "so_377178_377208_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 6815}, "so_377178_377208_6": {"length": 14, "quality": 0.9333333333333333, "section_id": 6815}, "so_377178_377208_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 6814}, "so_377178_377208_4": {"length": 10, "quality": 0.6666666666666666, "section_id": 6815}}, "n3337": {"so_377178_377208_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 6570}, "so_377178_377208_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 6570}, "so_377178_377208_6": {"length": 14, "quality": 0.9333333333333333, "section_id": 6570}, "so_377178_377208_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 6569}, "so_377178_377208_4": {"length": 10, "quality": 0.6666666666666666, "section_id": 6570}}, "n4659": {"so_377178_377208_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 8307}, "so_377178_377208_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 8307}, "so_377178_377208_6": {"length": 14, "quality": 0.9333333333333333, "section_id": 8307}, "so_377178_377208_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 8306}, "so_377178_377208_4": {"length": 10, "quality": 0.6666666666666666, "section_id": 8307}}}, "377178": {"ViewCount": "9978", "Body": "<p>What are all the other things the <code>new</code> operator does other than allocating memory and calling a constructor?</p>\n", "AcceptedAnswerId": "377208", "Title": "What does the C++ new operator do other than allocation and a ctor call?", "CreationDate": "2008-12-18T08:16:27.127", "Id": "377178", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-01-15T14:51:36.773", "LastEditorDisplayName": "Ferruccio", "OwnerDisplayName": "rajKumar", "LastEditorUserId": "1593077", "LastActivityDate": "2016-01-15T14:51:36.773", "Score": "8", "OwnerUserId": "22076", "Tags": "<c++><new-operator>", "AnswerCount": "3"}, "377192": {"Id": "377192", "PostTypeId": "2", "Body": "<p>Depends on if it's overloaded or not, if you built the app for debugging, if you're using a memory leak detector, if you have some kind of memory pooling scheme, if you have something like the Boehm garbage collector that's marking/unmarking bits, etc., etc.  It could be doing a lot of custom stuff inside, or nothing special at all.</p>\n", "OwnerDisplayName": "Michel", "LastActivityDate": "2008-12-18T08:25:27.483", "Score": "0", "CreationDate": "2008-12-18T08:25:27.483", "ParentId": "377178", "CommentCount": "1", "OwnerUserId": "31122"}, "377208": {"Id": "377208", "PostTypeId": "2", "Body": "<p>The C++ standard has this to say about the single object form (the form usually used) of the new operator from the <code>&lt;new&gt;</code> header:</p>\n<blockquote>\n<p id=\"so_377178_377208_0\">Required behavior: </p>\n<p id=\"so_377178_377208_1\">Return a nonnull pointer to suitably aligned storage (3.7.3), or else throw a\n  bad_alloc exception. This requirement is binding on a replacement version of this function.</p>\n<p id=\"so_377178_377208_2\">Default behavior:</p>\n<p id=\"so_377178_377208_3\">\u2014  Executes a loop: Within the loop, the function first attempts to allocate the requested storage. Whether\n  the attempt involves a call to the Standard C library function malloc is unspecified.</p>\n<p id=\"so_377178_377208_4\">\u2014 Returns a pointer to the allocated storage if the attempt is successful. Otherwise, if the last argument to\n  set_new_handler() was a null pointer, throw bad_alloc.</p>\n<p id=\"so_377178_377208_5\">\u2014 Otherwise, the function calls the current new_handler (18.4.2.2). If the called function returns, the loop\n  repeats.</p>\n<p id=\"so_377178_377208_6\">\u2014 The loop terminates when an attempt to allocate the requested storage is successful or when a called\n  new_handler function does not return.</p>\n</blockquote>\n<p>The standard has a lot of other stuff to say about the new operator and dynamic memory allocation (an awful lot to say), but I think the \"Default behavior\" list sums up the basics of the new operator pretty well.</p>\n", "OwnerDisplayName": "Mike B", "LastActivityDate": "2008-12-18T08:33:20.447", "Score": "16", "CreationDate": "2008-12-18T08:33:20.447", "ParentId": "377178", "CommentCount": "6", "OwnerUserId": "12711"}, "390585": {"Body": "<p>I've written a explanation of what it does in <a href=\"https://stackoverflow.com/questions/365887/how-do-malloc-and-new-work-how-are-they-different-implementation-wise#365891\">this</a> answer. It explains how</p>\n<ul>\n<li><code>new</code> gets the memory</li>\n<li><code>new</code> handles memory failure</li>\n<li><code>new</code> handles constructor exceptions</li>\n<li><code>new</code> handles special placement and nothrow versions</li>\n</ul>\n<p>Michael explained how the default allocator function (::operator new) gets memory nicely and how it handles failure. I've seen your question on where the size of an object is stored in his comments. The answer is, there isn't size stored if not necassary. Remember that C doesn't need the size for <code>free</code> (and ::operator new can just use <code>malloc</code>):</p>\n<pre><code>void * memory = malloc(x);\nfree (memory); // no need to tell it the size\n</code></pre>\n<p>Here is an example where you see how storing the size has an impact on the size of allocation for the array form of a new expression (not covered by my other answer):</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n\nstruct f {\n    // requests allocation of t bytes\n    void * operator new[](std::size_t t) throw() {\n        void *p = ::operator new[](t);\n        std::cout &lt;&lt; \"new    p: \" &lt;&lt; p &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"new size: \" &lt;&lt; t &lt;&lt; std::endl;\n        return p;\n    }\n\n    // requests deleting of t bytes starting at p\n    void operator delete[](void *p, std::size_t t) throw() {\n        std::cout &lt;&lt; \"delete p: \" &lt;&lt; p &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"size    : \" &lt;&lt; t &lt;&lt; std::endl;\n        return ::operator delete[](p);\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"sizeof f: \" &lt;&lt; sizeof (f) &lt;&lt; std::endl;\n\n    f * f_ = new f[1];\n    std::cout &lt;&lt; \"&amp;f_     : \" &lt;&lt; f_ &lt;&lt; std::endl;\n    delete[] f_;\n}\n</code></pre>\n<p>It will print out something like this:</p>\n<pre><code>sizeof f: 1\nnew    p: 0x93fe008\nnew size: 5\n&amp;f_     : 0x93fe00c\ndelete p: 0x93fe008\nsize    : 5\n</code></pre>\n<p>One byte for the object itself and 4 bytes for the count which is stored just before the allocated area of the object. Now if we use the deallocation function without a size parameter (just removing it from the operator delete), we get this output:</p>\n<pre><code>sizeof f: 1\nnew    p: 0x9451008\nnew size: 1\n&amp;f_     : 0x9451008\ndelete p: 0x9451008\n</code></pre>\n<p>The C++ runtime here doesn't care about the size, so it doesn't store it anymore. Note that this is highly implementation specific, and that's what gcc does here to be able to tell you the size in the member operator delete. Other implementations may still store the size, and will most likely if there is a destructor to invoke for the class. For example just adding <code>~f() { }</code> above makes gcc to store the size, regardless on what deallocation function we write. </p>\n", "CreationDate": "2008-12-24T01:37:32.587", "ParentId": "377178", "CommentCount": "1", "LastEditDate": "2017-05-23T12:15:02.963", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2008-12-24T02:05:00.550", "LastEditorUserId": "-1", "Id": "390585", "OwnerDisplayName": "litb", "Score": "9", "OwnerUserId": "34509"}});