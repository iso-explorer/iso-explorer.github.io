post_cb({"bq_ids": {"n4140": {"so_24281500_24281583_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 438}, "so_24281500_24281583_0": {"length": 6, "quality": 1.0, "section_id": 438}}, "n3337": {"so_24281500_24281583_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 429}, "so_24281500_24281583_0": {"length": 6, "quality": 1.0, "section_id": 429}}, "n4659": {"so_24281500_24281583_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 458}, "so_24281500_24281583_0": {"length": 6, "quality": 1.0, "section_id": 458}}}, "24281583": {"Id": "24281583", "PostTypeId": "2", "Body": "<p>Basically base classes are initialized first, then data members in declaration order. One exception is for virtual base classes, which are initialized first and from the most derived class. Another exception is for delegating constructors.</p>\n<hr>\n<p>Standardeese: in C++11 this is specified by \u00a712.6.2/10:</p>\n<blockquote>\n<p id=\"so_24281500_24281583_0\"><strong>\u201d</strong> In a non-delegating constructor, initialization proceeds in the following order:</p>\n<ul>\n<li>First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in\n  the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes,\n  where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class <em>base-specifier-list</em>.</li>\n<li>Then, direct base classes are initialized in declaration order as they appear in the <em>base-specifier-list</em>\n  (regardless of the order of the <em>mem-initializers</em>).</li>\n<li>Then, non-static data members are initialized in the order they were declared in the class definition\n  (again regardless of the order of the <em>mem-initializers</em>).</li>\n<li>Finally, the <em>compound-statement</em> of the constructor body is executed.</li>\n</ul>\n<p id=\"so_24281500_24281583_1\">[<em>Note:</em> The declaration order is mandated to ensure that base and member subobjects are destroyed in the\n  reverse order of initialization. <em>\u2014end note</em> ]</p>\n</blockquote>\n<hr>\n<p>As to how this works internally, a common technique is that a constructor calls its associated base and ordinary member constructors. If you ignore virtual bases and constructor delegation, and consider instantiation of a class T, then when you instantiate T the first that happens is that a T constructor is called. But this is not yet initialization of the T instance itself. The execution is still in the memory initializer list of that constructor. Here it calls the various base and non-base member constructors (where the same happens, recursively). Finally the constructor body is executed.</p>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-06-18T10:22:22.473", "Score": "2", "CreationDate": "2014-06-18T09:13:51.573", "ParentId": "24281500", "CommentCount": "6", "OwnerUserId": "464581", "LastEditDate": "2014-06-18T10:22:22.473"}, "24281500": {"ViewCount": "94", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass A\n{\n    private:\n        int ai;\n        string as;\n};\nclass B : public A\n{\n    private:\n        int bi;\n        string bs;\n};\n\n\nint main()\n{\n    B bob;\n\n    return 0;\n}\n</code></pre>\n<p>Class A and B have default constructors. And I know that class A default constructor will be called first and then B default constructor. But the question is how that happens internally? Do data members get constructed in the inheritance order? How/where compiler puts call to base ctor from dervied ctor?</p>\n", "AcceptedAnswerId": "24281583", "Title": "How derived class constructor calls base class constructor internally", "CreationDate": "2014-06-18T09:09:55.490", "Id": "24281500", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2014-06-18T10:22:22.473", "Score": "0", "OwnerUserId": "2235661", "Tags": "<c++><constructor>", "AnswerCount": "1"}});