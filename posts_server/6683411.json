post_cb({"6683505": {"ParentId": "6683411", "CommentCount": "0", "Body": "<pre><code>#define _OFFS_OF_MEMBER(p_type, p_member) (size_t)&amp;(((p_type *)NULL)-&gt;p_member)\n\nstruct a \n{\n         int a, b;\n};\n\nsize_t l = _OFFS_OF_MEMBER(struct a, b);\n</code></pre>\n<p>Is the same as (after preprocessing)</p>\n<pre><code>struct a { int a, b; };\nsize_t l = (size_t)&amp;(((struct a *)NULL)-&gt;b);\n</code></pre>\n<p>I see that you are casting NULL to a pointer-to-struct a, and then getting the address of its member b. </p>\n<p>As far as I know, since you are getting the address of b, and not actually accessing or modifying (dereferencing) the value of b, the compiler will not complain, and you will not get a runtime error. Since NULL (or 0) is the starting address of a, this will give you the offset. This is actually a pretty nifty way to do that.</p>\n", "OwnerUserId": "710360", "PostTypeId": "2", "Id": "6683505", "Score": "0", "CreationDate": "2011-07-13T18:08:27.807", "LastActivityDate": "2011-07-13T18:08:27.807"}, "6683499": {"ParentId": "6683411", "CommentCount": "1", "Body": "<p>So <code>&amp;p-&gt;b</code> is <code>&amp;(p-&gt;b)</code> is (by definition) <code>&amp;((*p).b)</code>, which does seem to involve a dereference of <code>p</code> before getting the member. It may work on most compilers though even if it violates the standard. As noted in a comment this work probably work right in cases involving multiple inheritance.</p>\n<p>What problem are you trying to solve by getting this offset? Could you use references, pointers, or pointers-to-member instead?</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "6683499", "Score": "0", "CreationDate": "2011-07-13T18:08:07.877", "LastActivityDate": "2011-07-13T18:08:07.877"}, "6683622": {"ParentId": "6683411", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It is invalid C++.</p>\n<p>From ISO/IEC 14882:2003, 5.2.5:</p>\n<blockquote>\n<p id=\"so_6683411_6683622_0\">3/ If E1 has the type \u201cpointer to class X,\u201d then the expression E1-&gt;E2\n  is converted to the equivalent form (*(E1)).E2 (...)</p>\n</blockquote>\n<p>However, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow\">there has been a defect report about this</a>, and it is valid C99 (and probably valid C++0x too):</p>\n<p>From ISO/IEC 9899:1999, 6.5.3:</p>\n<blockquote>\n<p id=\"so_6683411_6683622_1\">2/ If the operand [of the unary &amp; operator] is the result of a unary *\n  operator, neither that operator nor the &amp; operator is evaluated and\n  the result is as if both were omitted, except that the constraints on\n  the operators still apply and the result is not an lvalue.</p>\n</blockquote>\n", "OwnerUserId": "373025", "LastEditorUserId": "373025", "LastEditDate": "2011-07-13T18:37:35.137", "Id": "6683622", "Score": "1", "CreationDate": "2011-07-13T18:18:19.070", "LastActivityDate": "2011-07-13T18:37:35.137"}, "6683476": {"ParentId": "6683411", "CommentCount": "4", "Body": "<p>Absolutely not.  To even <em>create</em> a pointer by adding an offset to NULL is to invoke Undefined Behavior.  Someone more motivated can dig up chapter and verse from the spec.</p>\n<p>By the way, whatever your reason is for wanting to compute these offsets, it is a probably a bad one.</p>\n", "OwnerUserId": "768469", "PostTypeId": "2", "Id": "6683476", "Score": "2", "CreationDate": "2011-07-13T18:06:34.933", "LastActivityDate": "2011-07-13T18:06:34.933"}, "6683411": {"CommentCount": "13", "AcceptedAnswerId": "6683500", "PostTypeId": "1", "ClosedDate": "2011-07-13T18:18:55.483", "LastEditorUserId": "-1", "CreationDate": "2011-07-13T18:00:21.637", "LastActivityDate": "2011-07-13T18:37:35.137", "LastEditDate": "2017-05-23T12:19:50.280", "ViewCount": "481", "FavoriteCount": "1", "Title": "Is this valid ANSI C++ code? Trying to generate offsets of structure members at compile-time", "Id": "6683411", "Score": "0", "Body": "<blockquote>\n<p id=\"so_6683411_6683411_0\"><strong>Possible Duplicates:</strong><br>\n<a href=\"https://stackoverflow.com/questions/6433339/does-the-offsetof-macro-from-stddef-h-invoke-undefined-behaviour\">Does the 'offsetof' macro from &lt;stddef.h&gt; invoke undefined behaviour?</a><br>\n<a href=\"https://stackoverflow.com/questions/2896689/dereferencing-the-null-pointer\">dereferencing the null pointer</a> </br></br></p>\n</blockquote>\n<pre><code>    #define _OFFS_OF_MEMBER(p_type, p_member) (size_t)&amp;(((p_type *)NULL)-&gt;p_member)\n\n    struct a \n    {\n             int a, b;\n    };\n\n    size_t l = _OFFS_OF_MEMBER(struct a, b);\n</code></pre>\n<p>I had a little chat/conversation with some fellow users, and one of them said that this is dereferencing and accessing the address space near address NULL. I said: taking an address of a member will not access, touch, or read the value of that member. According to standard it is completely safe. </p>\n<pre><code>    struct a* p = NULL;\n    size_t offset = &amp;p-&gt;b; // this may NOT touch b, it is not dereferencing\n    // p-&gt;b = 0; // now, we are dereferincing: acccess violation time!\n</code></pre>\n<p>Is this always a safe way to calculate offset, or are compilers free to dereference and mess up the memory near address NULL according to standards?</p>\n<p>I know there is a safe way to calculate offsets provided by the standard, but I am curious what you have to say about this. All in favor of my explenation: up-vote this question :-)</p>\n", "Tags": "<c++><ansi><offset>", "OwnerUserId": "837803", "AnswerCount": "5"}, "6683500": {"ParentId": "6683411", "CommentCount": "4", "Body": "<p>You're not dereferencing anything invalid here. All that macro does is tell the compiler that a structure of type <code>p_type</code> exists in memory at the address <code>NULL</code>. It then takes the address of <code>p_member</code>, which is a member of this fictitious structure. So, no dereferencing anywhere.</p>\n<p>In fact, this is exactly what the <a href=\"https://secure.wikimedia.org/wikipedia/en/wiki/Offsetof\" rel=\"nofollow\"><code>offsetof</code></a> macro, defined in <code>stddef.h</code> does.</p>\n<p><strong>EDIT:</strong><br/>\nAs some of the comments say, this may not work well with C++ and inheritance, I've only used <code>offsetof</code> with POD structures in C.</p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "6683500", "Score": "2", "CreationDate": "2011-07-13T18:08:07.877", "LastActivityDate": "2011-07-13T18:08:07.877"}, "bq_ids": {"n4140": {"so_6683411_6683622_0": {"section_id": 6005, "quality": 0.9, "length": 9}}, "n3337": {"so_6683411_6683622_0": {"section_id": 5773, "quality": 0.9, "length": 9}}, "n4659": {"so_6683411_6683622_0": {"section_id": 7504, "quality": 0.9, "length": 9}}}});