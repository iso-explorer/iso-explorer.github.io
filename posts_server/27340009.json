post_cb({"bq_ids": {"n4140": {"so_27340009_27340009_0": {"length": 30, "quality": 0.9375, "section_id": 620}, "so_27340009_27340438_0": {"length": 27, "quality": 0.9, "section_id": 5892}, "so_27340009_27340438_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5897}}, "n3337": {"so_27340009_27340009_0": {"length": 30, "quality": 0.9375, "section_id": 610}, "so_27340009_27340438_0": {"length": 27, "quality": 0.9, "section_id": 5663}, "so_27340009_27340438_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5669}}, "n4659": {"so_27340009_27340009_0": {"length": 30, "quality": 0.9375, "section_id": 646}, "so_27340009_27340438_0": {"length": 27, "quality": 0.9, "section_id": 7375}, "so_27340009_27340438_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7380}}}, "27340009": {"ViewCount": "57", "Body": "<p>In the example:</p>\n<pre><code>struct A{ };\n\nstruct B\n{\n    B(){ };\n    operator A(){ return A(); }\n};\n\nconst B b;\n\nvoid foo(A){ };\n\nint main(){ foo(b); } //error: no matching function for call to 'foo'\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/ed14e1b9fc7bee93\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>compiler throws an error. But what the Standard says is (section <code>13.3.3.1.2/1 [over.ics.user]</code>):</p>\n<blockquote>\n<p id=\"so_27340009_27340009_0\">A user-defined conversion sequence consists of an initial standard\n  conversion sequence followed by a userdefined conversion (12.3)\n  followed by a second standard conversion sequence. [...]\n  If the user-defined conversion is specified by a conversion function\n  (12.3.2), the initial standard conversion sequence converts the source\n  type to the implicit object parameter of the conversion function.</p>\n</blockquote>\n<p>Therefore in the example the first standar conversion should conver <code>const B</code> to <code>B</code> and then call the conversion function. But it didn't, why? How does it exactly work? Note the example will work fine if we replace <code>operator A(){ return A(); }</code> with <code>operator A() const{ return A(); }</code></p>\n", "AcceptedAnswerId": "27340438", "Title": "Why should we specify the const qualifier explicitly if we define conversion function?", "CreationDate": "2014-12-07T05:45:03.683", "Id": "27340009", "CommentCount": "2", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-12-20T06:02:11.560", "Score": "0", "Tags": "<c++>", "AnswerCount": "1"}, "27340438": {"Id": "27340438", "PostTypeId": "2", "Body": "<p>You do not demand a conversion sequence here, like the one you picked from the standard.</p>\n<p>You are invoking</p>\n<pre><code>B::operator A()\n</code></pre>\n<p>on an object declared as \"const B\".</p>\n<p>Actually, 3.9.1 says:</p>\n<blockquote>\n<p id=\"so_27340009_27340438_0\">A non-static member function may be declared const, volatile, or const\n  volatile. These cv-qualifiers affect the type of the this pointer\n  (9.3.2). They also affect the function type (8.3.5) of the member\n  function; a member function declared const is a const member function</p>\n</blockquote>\n<p>Moreover 9.3.2/3:</p>\n<blockquote>\n<p id=\"so_27340009_27340438_1\">A cv-qualified member function can be called on an object-expression\n  (5.2.5) only if the object-expression is as cv-qualified or\n  less-cv-qualified than the member function.</p>\n</blockquote>\n<p>As with any other method invocation, you are running into non-const method invocation on a const object. That protection is not broken for obvious reasons.</p>\n<p>BTW, it seems that you answered the question yourself. Otherwise, hope this helps.</p>\n", "LastEditorDisplayName": "user2953119", "LastActivityDate": "2014-12-20T06:02:11.560", "Score": "-1", "CreationDate": "2014-12-07T06:55:16.283", "ParentId": "27340009", "CommentCount": "1", "OwnerUserId": "1340410", "LastEditDate": "2014-12-20T06:02:11.560"}});