post_cb({"28201982": {"CommentCount": "5", "AcceptedAnswerId": "28203110", "CreationDate": "2015-01-28T20:39:26.870", "LastActivityDate": "2015-01-28T21:52:02.083", "PostTypeId": "1", "ViewCount": "492", "FavoriteCount": "1", "Title": "vector::clear in libc++ for trivially destructible types", "Id": "28201982", "Score": "8", "Body": "<p>Would <code>vector&lt;T, std::allocator&lt;T&gt;&gt;::clear()</code> be <code>O(1)</code> if <code>T</code> is trivially destructible?</p>\n<p>gcc's implementation in <code>bits/stl_vector.h</code> calls <code>std::_Destroy</code>(<code>bits/stl_construct.h</code>). This implementation which optimizes for the case of T being trivially destructible through tag-dispatching on <code>std::is_trivially_destructible&lt;T&gt;</code>.</p>\n<p>Looking through llvm's(3.5.0) implementation, <code>vector::clear</code> calls <code>std::allocator&lt;T&gt;::destroy</code> on every element, which in turn invokes the destructor.</p>\n<pre><code> _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p-&gt;~_Tp();}\n</code></pre>\n<p>Would this end up getting optimized out making <code>vector::clear()</code> <code>O(1)</code> in libc++ as well?</p>\n", "Tags": "<c++><c++11><clang><llvm><stdvector>", "OwnerUserId": "862351", "AnswerCount": "1"}, "28203110": {"ParentId": "28201982", "CommentCount": "2", "Body": "<p>In general, a conforming implementation cannot implement <code>std::vector::clear</code> in O(1) for types with non-trivial destructors.</p>\n<p>C++11 [container.requirements.general]/3 states:</p>\n<blockquote>\n<p id=\"so_28201982_28203110_0\">For the components affected by this subclause that declare an allocator_type, objects stored in these components shall be constructed using the <code>allocator_traits&lt;allocator_type&gt;::construct</code> function and destroyed using the <code>allocator_traits&lt;allocator_type&gt;::destroy</code> function (20.6.8.2).</p>\n</blockquote>\n<p>Since <code>clear</code> must destroy <code>size()</code> elements, it necessarily needs to make O(N) calls to the <code>destroy</code> function of the associated allocator. The end result can, however, effectively take constant time if each of those calls takes zero time to complete (i.e., does nothing).</p>\n<p>A quick look at the implementation of <code>_Destroy</code> in <a href=\"https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%2B%2B-v3/include/bits/stl_construct.h?revision=219188&amp;view=markup\" rel=\"nofollow\">the current revision of libstdc++'s bits/stl_construct.h</a> shows that it attempts to only perform this optimization when the default allocator is in use:</p>\n<pre><code>  /**\n   * Destroy the object pointed to by a pointer type.\n   */\n  template&lt;typename _Tp&gt;\n    inline void\n    _Destroy(_Tp* __pointer)\n    { __pointer-&gt;~_Tp(); }\n\n  template&lt;bool&gt;\n    struct _Destroy_aux\n    {\n      template&lt;typename _ForwardIterator&gt;\n        static void\n        __destroy(_ForwardIterator __first, _ForwardIterator __last)\n      {\n        for (; __first != __last; ++__first)\n          std::_Destroy(std::__addressof(*__first));\n      }\n    };\n\n  template&lt;&gt;\n    struct _Destroy_aux&lt;true&gt;\n    {\n      template&lt;typename _ForwardIterator&gt;\n        static void\n        __destroy(_ForwardIterator, _ForwardIterator) { }\n    };\n\n  /**\n   * Destroy a range of objects.  If the value_type of the object has\n   * a trivial destructor, the compiler should optimize all of this\n   * away, otherwise the objects' destructors must be invoked.\n   */\n  template&lt;typename _ForwardIterator&gt;\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type\n                       _Value_type;\n      std::_Destroy_aux&lt;__has_trivial_destructor(_Value_type)&gt;::\n        __destroy(__first, __last);\n    }\n\n  /**\n   * Destroy a range of objects using the supplied allocator.  For\n   * nondefault allocators we do not optimize away invocation of \n   * destroy() even if _Tp has a trivial destructor.\n   */\n\n  template&lt;typename _ForwardIterator, typename _Allocator&gt;\n    void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n         _Allocator&amp; __alloc)\n    {\n      typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;\n      for (; __first != __last; ++__first)\n        __traits::destroy(__alloc, std::__addressof(*__first));\n    }\n\n  template&lt;typename _ForwardIterator, typename _Tp&gt;\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n         allocator&lt;_Tp&gt;&amp;)\n    {\n      _Destroy(__first, __last);\n    }\n</code></pre>\n<p>but unfortunately doesn't quite get it right since the standard allows specialization of templates in the <code>std</code> namespace that depend on user-defined types ([namespace.std]/1). For example, this program:</p>\n<pre><code>struct mytype {\n    int value;\n\n    mytype(int v) : value{v} {}\n\n    operator int() const { return value; }\n};\n\nnamespace std {\ntemplate &lt;&gt;\nstruct allocator&lt;::mytype&gt; {\n    using value_type = mytype;\n\n    allocator() = default;\n    template &lt;typename U&gt;\n    allocator(const allocator&lt;U&gt;&amp;) {}\n\n    mytype* allocate(std::size_t n) {\n        auto result = ::operator new(n * sizeof(mytype));\n        if (!result) throw bad_alloc();\n        return static_cast&lt;mytype*&gt;(result);\n    }\n\n    void deallocate(mytype* ptr, std::size_t) noexcept {\n        ::operator delete(ptr);\n    }\n\n    template &lt;typename U, typename...Args&gt;\n    void construct(U* ptr, Args&amp;&amp;...args) {\n        ::new ((void*)ptr) U(std::forward&lt;Args&gt;(args)...);\n        std::cout &lt;&lt; \"constructed \" &lt;&lt; *ptr &lt;&lt; '\\n';\n    }\n\n    template &lt;typename U&gt;\n    void destroy(U* ptr) noexcept {\n        std::cout &lt;&lt; \"destroying \" &lt;&lt; *ptr &lt;&lt; '\\n';\n        ptr-&gt;~U();\n    }\n\n    friend constexpr bool operator == (const allocator&amp;, const allocator&amp;) noexcept {\n        return true;\n    }\n    friend constexpr bool operator != (const allocator&amp;, const allocator&amp;) noexcept {\n        return false;\n    }\n};\n} // namespace std\n\nint main() {\n    std::vector&lt;mytype&gt;{1,2,3};\n}\n</code></pre>\n<p>should output:</p>\n<pre>\nconstructed 1\nconstructed 2\nconstructed 3\ndestroying 3\ndestroying 2\ndestroying 1\n</pre>\n<p>(the order of element destruction is unspecified, so the \"destroying\" lines can be in any order but must all be present.) libstdc++ incorrectly \"optimizes\" out the calls to <code>allocator&lt;mytype&gt;::construct</code> and <code>allocator&lt;mytype&gt;::destroy</code>, but of course libc++ gets it right (<a href=\"http://coliru.stacked-crooked.com/a/27860e43c400f98e\" rel=\"nofollow\"><strong>DEMO</strong></a>).</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "28203110", "Score": "4", "CreationDate": "2015-01-28T21:52:02.083", "LastActivityDate": "2015-01-28T21:52:02.083"}, "bq_ids": {"n4140": {"so_28201982_28203110_0": {"section_id": 704, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_28201982_28203110_0": {"section_id": 694, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_28201982_28203110_0": {"section_id": 733, "quality": 0.7777777777777778, "length": 14}}}});