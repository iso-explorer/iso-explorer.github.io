post_cb({"12730455": {"ParentId": "12730321", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Unless <code>some_unsigned_type</code> is a fixed-width type, this is your first platform specific. On one platform, you may be shifting out some information that can never recur by the value itself, while on another it may not. Example:</p>\n<pre><code>16 bit 'int':\n\n      1000 0000  0000 0000\n&lt;&lt;1 = 0000 0000  0000 0000\n&gt;&gt;1 = 0000 0000  0000 0000\n\n32 bit 'int':\n\n      0000 0000  0000 0000   1000 0000  0000 0000\n&lt;&lt;1 = 0000 0000  0000 0001   0000 0000  0000 0000\n&gt;&gt;1 = 0000 0000  0000 0000   1000 0000  0000 0000\n</code></pre>\n<p><code>5.8 Shift Operators</code> in the C++ standard also says this:</p>\n<blockquote>\n<p id=\"so_12730321_12730455_0\">The behavior is undefined if the right operand\n  is negative, or greater than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>So if you shift an integer by more bits than there are, you enter undefined behaviour. E.g., if you left-shift a <code>short</code> value by 17 bits, it may give you UB on some machines, but not all.</p>\n<p>C11 says in <code>6.5.7 Bitwise shift operators</code>, apart from other things, this:</p>\n<blockquote>\n<p id=\"so_12730321_12730455_1\">The result of <code>E1 &gt;&gt; E2</code> is <code>E1</code> right-shifted <code>E2</code> bit positions. If <code>E1</code> has an unsigned type\n  or if <code>E1</code> has a signed type and a nonnegative value, the value of the result is the integral\n  part of the quotient of <code>E1 / 2</code><sup><code>E2</code></sup>. <strong>If <code>E1</code> has a signed type and a negative value, the\n  resulting value is implementation-defined.</strong></p>\n</blockquote>\n<p>So signed-number shifting is not portable.</p>\n<p>So, the <em>general</em> answer for integers in <em>general</em>  is:</p>\n<h2>Bitwise manipulations on integers are <em>not</em> portable.</h2>\n", "OwnerUserId": "76722", "LastEditorUserId": "9530", "LastEditDate": "2012-10-04T15:43:45.380", "Id": "12730455", "Score": "5", "CreationDate": "2012-10-04T15:16:19.127", "LastActivityDate": "2012-10-04T15:43:45.380"}, "12730321": {"CommentCount": "2", "AcceptedAnswerId": "12730780", "PostTypeId": "1", "LastEditorUserId": "435800", "CreationDate": "2012-10-04T15:07:51.690", "LastActivityDate": "2012-10-05T13:00:50.587", "LastEditDate": "2012-10-05T10:18:25.453", "ViewCount": "815", "FavoriteCount": "0", "Title": "Standard (cross-platform) way for bit manipulation", "Id": "12730321", "Score": "10", "Body": "<p>As are are different binary representation of the numbers (for example, take big/little endian), is this cross-platform:</p>\n<pre><code>// NOTE: FIXED-SIZE unsigned integral type\nsome_unsigned_type variable = some_number;\n\n// set n-th bit, starting from 1,\n// right-to-left (least significant-to most significant)\nvariable |= ( 1 &lt;&lt; ( n - 1 ) );\n\n// clear the same bit:    \nvariable &amp;= ~( 1 &lt;&lt; ( n - 1 ) );\n</code></pre>\n<p>In other words, does the compiler always take care of the different binary representation of the <strong>fixed size</strong> unsigned numbers, or it's platform-specific?</p>\n<p>And what if <code>variable</code> is signed integral type (for example, <code>int</code>) and its value is</p>\n<ul>\n<li>zero</li>\n<li>positive</li>\n<li>negative?</li>\n</ul>\n<p>What does the <em>Standard</em> say about this?</p>\n<p><sub>P.S. And, <strong>yes</strong>, I'm interesting in both - <code>C</code> and <code>C++</code>, please don't tell me they are different languages, because I know this :)</sub></p>\n<p><sub>I can paste real example, if needed, but the post will become too long</sub></p>\n", "Tags": "<c++><c><cross-platform><standards><bit-manipulation>", "OwnerUserId": "435800", "AnswerCount": "3"}, "12730780": {"ParentId": "12730321", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><strong>Disclaimer:</strong> I am implicitly assuming that you are talking about an integer type with a fixed width. Bit-shifting otherwise is quite hazardous...</p>\n<p><strong>Standard: n3337 C++11</strong></p>\n<p>The definition of shifts is mathematical for unsigned types or positive values in signed types (*), and therefore not affected by the underlying hardware representation.</p>\n<blockquote>\n<p id=\"so_12730321_12730780_0\"><strong>5.8 Shift operators [expr.shift]</strong></p>\n<p id=\"so_12730321_12730780_1\"><em>2</em> The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. If <code>E1</code> has an unsigned type, the value of the result is <code>E1 \u00d7 2</code><sup><code>E2</code></sup>, reduced modulo one more than the maximum value representable in the result type. Otherwise, if <code>E1</code> has a signed type and non-negative value, and <code>E1\u00d72</code><sup><code>E2</code></sup> is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.</p>\n<p id=\"so_12730321_12730780_2\"><em>3</em> The value of <code>E1 &gt;&gt; E2</code> is <code>E1</code> right-shifted <code>E2</code> bit positions. If <code>E1</code> has an unsigned type or if <code>E1</code> has a signed type and a non-negative value, the value of the result is the integral part of the quotient of <code>E1/2</code><sup><code>E2</code></sup>. If <code>E1</code> has a signed type and a negative value, the resulting value is implementation-defined.</p>\n</blockquote>\n<p>For the same reason, I would think the bitwise <code>and</code>, <code>or</code> and <code>negate</code> are okay: they are defined mathematically.</p>\n<blockquote>\n<p id=\"so_12730321_12730780_3\"><strong>5.3.1 Unary operators [expr.unary.op]</strong></p>\n<p id=\"so_12730321_12730780_4\"><em>10</em> The operand of <code>\u02dc</code> shall have integral or unscoped enumeration type; the result is the one\u2019s complement of its operand.</p>\n<p id=\"so_12730321_12730780_5\"><strong>5.11 Bitwise AND operator [expr.bit.and]</strong></p>\n<p id=\"so_12730321_12730780_6\"><em>1</em> The usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The operator applies only to integral or unscoped enumeration operands.</p>\n<p id=\"so_12730321_12730780_7\"><strong>5.13 Bitwise inclusive OR operator [expr.or]</strong></p>\n<p id=\"so_12730321_12730780_8\"><em>1</em> The usual arithmetic conversions are performed; the result is the bitwise inclusive OR function of its operands. The operator applies only to integral or unscoped enumeration operands.</p>\n</blockquote>\n<p>However I will admit I am less sure for the latter two, I could not find any definition of <em>bitwise XX function</em>, so even though I believe they refer to they mathematical counterparts I can offer no assurance.</p>\n<p>(*) Thanks to phresnel for pointing that out.</p>\n", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2012-10-05T13:00:50.587", "Id": "12730780", "Score": "4", "CreationDate": "2012-10-04T15:35:52.523", "LastActivityDate": "2012-10-05T13:00:50.587"}, "12731766": {"ParentId": "12730321", "CommentCount": "0", "Body": "<p>It's implementation specific if you shift negative (or signed) numbers (through most implementations are the same U2 thing). It's portable for most uses if you shift unsigned numbers by values not exceeding the number of bits in variable.</p>\n", "OwnerUserId": "1719787", "PostTypeId": "2", "Id": "12731766", "Score": "1", "CreationDate": "2012-10-04T16:34:47.987", "LastActivityDate": "2012-10-04T16:34:47.987"}, "bq_ids": {"n4140": {"so_12730321_12730780_4": {"section_id": 6073, "quality": 0.9166666666666666, "length": 11}, "so_12730321_12730780_1": {"section_id": 6147, "quality": 0.9210526315789473, "length": 35}, "so_12730321_12730780_6": {"section_id": 6160, "quality": 0.8235294117647058, "length": 14}, "so_12730321_12730455_1": {"section_id": 6148, "quality": 0.8333333333333334, "length": 20}, "so_12730321_12730455_0": {"section_id": 6146, "quality": 0.9285714285714286, "length": 13}, "so_12730321_12730780_8": {"section_id": 6162, "quality": 0.8888888888888888, "length": 16}, "so_12730321_12730780_2": {"section_id": 6148, "quality": 0.875, "length": 21}}, "n3337": {"so_12730321_12730780_4": {"section_id": 5841, "quality": 0.9166666666666666, "length": 11}, "so_12730321_12730780_1": {"section_id": 5910, "quality": 0.9210526315789473, "length": 35}, "so_12730321_12730780_6": {"section_id": 5921, "quality": 0.8235294117647058, "length": 14}, "so_12730321_12730455_1": {"section_id": 5911, "quality": 0.8333333333333334, "length": 20}, "so_12730321_12730455_0": {"section_id": 5909, "quality": 0.9285714285714286, "length": 13}, "so_12730321_12730780_8": {"section_id": 5923, "quality": 0.8888888888888888, "length": 16}, "so_12730321_12730780_2": {"section_id": 5911, "quality": 0.875, "length": 21}}, "n4659": {"so_12730321_12730780_6": {"section_id": 7657, "quality": 0.8235294117647058, "length": 14}, "so_12730321_12730780_1": {"section_id": 7643, "quality": 0.9210526315789473, "length": 35}, "so_12730321_12730780_4": {"section_id": 7569, "quality": 0.9166666666666666, "length": 11}, "so_12730321_12730455_1": {"section_id": 7644, "quality": 0.8333333333333334, "length": 20}, "so_12730321_12730455_0": {"section_id": 7642, "quality": 0.9285714285714286, "length": 13}, "so_12730321_12730780_8": {"section_id": 7659, "quality": 0.8888888888888888, "length": 16}, "so_12730321_12730780_2": {"section_id": 7644, "quality": 0.875, "length": 21}}}});