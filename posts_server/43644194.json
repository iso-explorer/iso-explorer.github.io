post_cb({"bq_ids": {"n4140": {"so_43644194_43644563_0": {"length": 31, "quality": 0.96875, "section_id": 7003}}, "n3337": {"so_43644194_43644563_0": {"length": 31, "quality": 0.96875, "section_id": 6749}}, "n4659": {"so_43644194_43644563_0": {"length": 31, "quality": 0.96875, "section_id": 8500}}}, "43644563": {"Id": "43644563", "PostTypeId": "2", "Body": "<p>When using virtual function dispatch, the so-called \"final overrider\" is what gets called.  For a function to even override an inherited virtual function, it must meet some criteria:</p>\n<blockquote>\n<p id=\"so_43644194_43644563_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a\n  class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member\n  function <code>vf</code> with the same name, <strong>parameter-type-list</strong> (8.3.5),\n  cv-qualification, and refqualifier (or absence of same) as <code>Base::vf</code> is\n  declared, then <code>Derived::vf</code> is also virtual (whether or not it is so\n  declared) and it <em>overrides</em> <code>Base::vf</code>.</p>\n</blockquote>\n<p>-- ISO/IEC 14882:2001(E) \u00a710.3 (bold emphasis mine)</p>\n<p>Quite simply, in your second example the parameter list for <code>Second::f(double)</code> differs from that of <code>First::f(int)</code>, so <code>Second::f(double)</code> is <em>not</em> (automatically) virtual and does <em>not</em> override <code>First::f(int)</code>.</p>\n<p>The C++11 keyword <code>override</code> declares your intent that a method override an inherited virtual method so that the compiler can tell you when it does not.  For example, had you done this instead:</p>\n<pre><code>void f(double a) override {\n</code></pre>\n<p>The compiler would have given you this diagnostic to inform you that it doesn't actually override anything, and it even informs you why it doesn't (<em>\"type mismatch at 1st parameter ('int' vs 'double')\"</em>):</p>\n<pre><code>main.cpp:15:18: error: non-virtual member function marked 'override' hides virtual member function\nvoid f(double a) override { //double instead int here!\n                 ^\nmain.cpp:7:14: note: hidden overloaded virtual function 'First::f' declared here: type mismatch at 1st parameter ('int' vs 'double')\nvirtual void f(int a) {\n             ^\n</code></pre>\n", "LastEditorUserId": "501250", "LastActivityDate": "2017-04-27T00:20:53.193", "Score": "8", "CreationDate": "2017-04-26T21:09:09.683", "ParentId": "43644194", "CommentCount": "0", "OwnerUserId": "501250", "LastEditDate": "2017-04-27T00:20:53.193"}, "43644453": {"Id": "43644453", "PostTypeId": "2", "Body": "<p>In the second piece of code, Second inherits a virtual function called f() and has its own function called also f().</p>\n<p>Now, since all calls are done from First (or an object pointed to by First) it works as follows:\nWhen you call from a First object, it's obvious that the function in First will be called. Now, when you call from a Second object pointed to by a pointer to First then since f() is virtual, the \"compiler\" [please see a comment below] searches for it in the actual class (which is Second) but since there is no function there that matches void f(int) then it takes the one from First.</p>\n", "LastEditorUserId": "5550579", "LastActivityDate": "2017-04-26T21:10:19.993", "Score": "1", "CreationDate": "2017-04-26T21:01:30.367", "ParentId": "43644194", "CommentCount": "7", "OwnerUserId": "5550579", "LastEditDate": "2017-04-26T21:10:19.993"}, "43644194": {"ViewCount": "374", "Body": "<p>I'm trying to understand how virtual functions work, and I am stuck at a certain part.</p>\n<p>I have written this small programm:</p>\n<pre><code>class First\n{\npublic:\n    virtual void f(int a) \n    {\n        cout &lt;&lt; \"First!\" &lt;&lt; endl;\n        cout &lt;&lt; a &lt;&lt; endl;\n    }\n};\n\nclass Second : public First\n{\npublic:\n    void f(int a) {\n        cout &lt;&lt; \"Second!\" &lt;&lt; endl;\n        cout &lt;&lt; a &lt;&lt; endl;\n    }\n};\n\nvoid main() {\n    Second s;\n    First *p = &amp;s;\n    p-&gt;f(5);\n    First n;\n    p = &amp;n;\n    p-&gt;f(3);\n    _getch();\n}\n</code></pre>\n<p>This code results in:</p>\n<pre>\nSecond!\n5\nFirst!\n3\n</pre>\n<p>However, if I change <code>int</code> in the <code>Second::f()</code> function to a different type, like this:</p>\n<pre><code>class First\n{\npublic:\n    virtual void f(int a) {\n        cout &lt;&lt; \"First!\" &lt;&lt; endl;\n        cout &lt;&lt; a &lt;&lt; endl;\n    }\n};\n\nclass Second : public First\n{\npublic:\n    void f(double a) { //double instead int here!\n        cout &lt;&lt; \"Second!\" &lt;&lt; endl;\n        cout &lt;&lt; a &lt;&lt; endl;\n    }\n};\n\nvoid main() {\n    Second s;\n    First *p = &amp;s;\n    p-&gt;f(5);\n    First n;\n    p = &amp;n;\n    p-&gt;f(3);\n    _getch();\n}\n</code></pre>\n<p>My program never calls <code>Second::f()</code>, and I'm getting this as a result:</p>\n<pre>\nFirst!\n5\nFirst!\n3\n</pre>\n<p>Can someone explain to me why this happens?</p>\n", "AcceptedAnswerId": "43644563", "Title": "Virtual functions with different argument types", "CreationDate": "2017-04-26T20:44:13.363", "Id": "43644194", "CommentCount": "13", "LastEditDate": "2017-04-26T22:06:55.173", "PostTypeId": "1", "LastEditorUserId": "65863", "LastActivityDate": "2017-04-27T00:20:53.193", "Score": "3", "OwnerUserId": "7927760", "Tags": "<c++><class><inheritance><virtual-functions>", "AnswerCount": "3"}, "43644402": {"Id": "43644402", "PostTypeId": "2", "Body": "<p>in fact derived classes do not redeclare virtual functions of base classes. They redefine them that in the terms of C++ means to override definitions of  virtual functions of base classes.</p>\n<p>In your second example the derived class declares a new non-virtual function (because the function specifier virtual is absent) with the same name as the name of the virtual function in the base class. The newly declared function hides the declaration of the virtual function in the base class.</p>\n<p>In this code snippet</p>\n<pre><code>Second s;\nFirst *p = &amp;s;\np-&gt;f(5);\n</code></pre>\n<p>the static type of the pointer <code>p</code> is <code>First</code>. So the compiler looks through the table of virtual functions declared in the class First and finds the pointer to the function declared in the class First. This pointer is not overwritten by the address of a virtual function in the derived class because the derived class did not override the base class function.</p>\n<p>If you will write for example</p>\n<pre><code>Second s;\nSecond *p = &amp;s;\n^^^^^^\np-&gt;f(5);\n</code></pre>\n<p>then the non-virtual function declared in the derived class will be called.</p>\n", "LastActivityDate": "2017-04-26T20:59:06.393", "CommentCount": "0", "CreationDate": "2017-04-26T20:59:06.393", "ParentId": "43644194", "Score": "2", "OwnerUserId": "2877241"}});