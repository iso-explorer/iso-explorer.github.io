post_cb({"28103339": {"Id": "28103339", "PostTypeId": "2", "Body": "<p>Make a file called <code>include.cpp</code> containing this:</p>\n<pre><code>int f()\n{\n  return 42;\n}\n</code></pre>\n<p>Then, <code>main.cpp</code> (with inspiration from <a href=\"https://stackoverflow.com/a/25021520/4323\">https://stackoverflow.com/a/25021520/4323</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"include.cpp\"\n\nint main()\n{\n  const char* const str =\n    R\"(include(include.cpp))\"\n  ;\n  std::cout &lt;&lt; str &lt;&lt; '\\n';\n  return f();\n}\n</code></pre>\n<p>What's that <code>include()</code> syntax??  That's m4!  So you compile like this:</p>\n<pre><code>m4 main.cpp | g++ -x c++ -std=c++11 -\n</code></pre>\n<p>Or if you can't use a pipeline in your compilation command:</p>\n<pre><code>g++ -x c++ -std=c++11 &lt;(m4 main.cpp)\n</code></pre>\n<p>If you use the second option,  you'll need a <code>-I</code> rule to tell the compiler where to <code>#include \"include.cpp\"</code> because the source file \"exists\" in <code>/dev</code> (it's a Bash-ism).  You could instead say <code>include(include.cpp)</code> instead of using <code>#include</code> at the top, either way works.</p>\n<p>The program prints the code from <code>include.cpp</code> then invokes the function in it.</p>\n<p>I do apologize for using m4, but it is available on lots of systems (and you can write your own trivial implementation for others).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-23T05:02:47.273", "Score": "1", "CreationDate": "2015-01-23T05:02:47.273", "ParentId": "28103029", "CommentCount": "2", "OwnerUserId": "4323", "LastEditDate": "2017-05-23T12:23:56.040"}, "28103029": {"ViewCount": "368", "Body": "<p>So I would like to have a file that I can conditionally include as either code or a string. \nLike this: </p>\n<pre><code>#define something\n#include \"myfile.inc\" \n\n#undef something\nconst char myfileasastring = \n#include \"myfile.inc\" \n</code></pre>\n<p>myfile.inc would be simple code like this:</p>\n<pre><code>something // anything extra here is fine as long as it goes away in the code include case\nint myfunc() { return 23; } \n</code></pre>\n<p>Is this possible? I tried having #define something R(\"mystring and start myfile with it but that does not seem to work. </p>\n<p>My specific use case for this is a GLSL shader that, when running under GL I need as a string to pass to the GL driver but when running it in software emulation I want to compile it as CPP code. </p>\n<p>I would love to have the same file for both cases. I know many workarounds on the project/make/build level, and even just cut and paste is not terrible, but it would be neat to have a portable compiler level way of doing this. </p>\n<p>Not a dupe as detected. I know how to include as one xor the other, but not as either or with the same file. Also I know how to do it using external tools, I am really just wondering if is wondering in just plain, portable c++11. It might not be possible. (try to remove dupe tag again.. please comment if you still think it is a dupe)</p>\n", "AcceptedAnswerId": "28736703", "Title": "How to include a file in cpp as both a string and code?", "CreationDate": "2015-01-23T04:24:21.343", "Id": "28103029", "CommentCount": "10", "LastEditDate": "2015-01-24T08:51:40.673", "PostTypeId": "1", "LastEditorUserId": "360270", "LastActivityDate": "2017-11-19T19:52:20.007", "Score": "1", "OwnerUserId": "360270", "Tags": "<c++><c++11><macros><glsl>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_28103029_28130061_3": {"length": 17, "quality": 1.0, "section_id": 5313}, "so_28103029_28130061_5": {"length": 38, "quality": 0.95, "section_id": 5313}, "so_28103029_28130061_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5313}, "so_28103029_28130061_4": {"length": 55, "quality": 0.859375, "section_id": 5313}, "so_28103029_28130061_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5313}}, "n3337": {"so_28103029_28130061_3": {"length": 17, "quality": 1.0, "section_id": 5110}, "so_28103029_28130061_5": {"length": 38, "quality": 0.95, "section_id": 5110}, "so_28103029_28130061_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5110}, "so_28103029_28130061_4": {"length": 55, "quality": 0.859375, "section_id": 5110}, "so_28103029_28130061_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5110}}, "n4659": {"so_28103029_28130061_3": {"length": 17, "quality": 1.0, "section_id": 6737}, "so_28103029_28130061_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6737}, "so_28103029_28130061_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6737}, "so_28103029_28130061_4": {"length": 55, "quality": 0.859375, "section_id": 6737}, "so_28103029_28130061_5": {"length": 38, "quality": 0.95, "section_id": 6737}}}, "28736703": {"Id": "28736703", "PostTypeId": "2", "Body": "<p>Ah sorry for wasting everybody's time. I figured it out and it is quite easy:</p>\n<p>test.inc:</p>\n<pre><code>#ifdef ASSTRING\nR\"foo(\n#else\nint do () { return 23; }\n// )foo\";\n#endif\n</code></pre>\n<p>main.cpp</p>\n<pre><code>#define ASSTRING\nconst char s[] =\n#include \"test.inc\";\n\n#undef ASSTRING\n#include \"test.inc\"\n\nprintf ( \"hello\\n%s\\n%i\\n\", s+6, me() );\n</code></pre>\n<p>Will both print the code and run it.</p>\n", "LastActivityDate": "2015-02-26T07:29:03.330", "CommentCount": "2", "CreationDate": "2015-02-26T07:29:03.330", "ParentId": "28103029", "Score": "1", "OwnerUserId": "360270"}, "28114431": {"Id": "28114431", "PostTypeId": "2", "Body": "<p>I've worked on a project where we did something like this. We wrote a script to compile the code as C++, then linked our main target (our application) against the result. We then also include the code as a resource in the application or library we're building and read it from disk when we want to pass it to OpenGL as glsl. We did this in Xcode by having a target that first compiles the code as C++ into a shared library, and a second target for our application that links against the resulting shared library, and also copies the code into our app bundle as a text file. You can probably do the same with make files or Visual Studio, or whatever tool you're using.</p>\n", "LastActivityDate": "2015-01-23T16:33:47.100", "CommentCount": "1", "CreationDate": "2015-01-23T16:33:47.100", "ParentId": "28103029", "Score": "1", "OwnerUserId": "1118321"}, "28130061": {"Id": "28130061", "PostTypeId": "2", "Body": "<p>As commented and explained (by the two other answers <a href=\"https://stackoverflow.com/a/28103339/841108\">by John Zwinck</a> and <a href=\"https://stackoverflow.com/a/28114431/841108\">by user1118321</a>), it is impossible without an external tool. It looks you are dreaming of some (yet inexistent) preprocessor directive <code>#include_verbatim</code> such that <code>#include_verbatim  \"myfile.inc\"</code> expands to a long literal string constant containing the contents of <code>myfile.inc</code>.</p>\n<p>This does not exist yet. You might perhaps customize a compiler (e.g. using <a href=\"http://gcc-melt.org/\" rel=\"nofollow noreferrer\">MELT</a> if compiling with a recent <a href=\"http://gcc.gnu.org/\" rel=\"nofollow noreferrer\">GCC</a>...) which for example would process <code>#pragma MAKE_VERBATIM_LITERAL_FROM_FILE_CONTENT(MYCONTENT,myfile.inc)</code> to define the preprocessor symbol <code>MYCONTENT</code> be the literal content of <code>myfile.inc</code> ; but this would need a significant effort and would be compiler specific.</p>\n<p>The most pragmatic solution is to accept using some external tool (e.g. a simple <code>make</code> rule to transform <code>myfile.inc</code>  into <code>myfile.inc.data</code> such that you could <code>#include \"myfile.inc.data\"</code> appropriately). This would take a few minutes of your development time (e.g. with <code>m4</code>, <code>awk</code>, <code>hexdump</code>, <code>reswrap</code> from <a href=\"http://fox-toolkit.org/\" rel=\"nofollow noreferrer\">FOX toolkit</a> ...)</p>\n<p><sup>If you don't want to depend from some external tool, make it <em>internal to your project</em> by coding an autonomous <code>transform_to_hex_string.cpp</code> program compiled to <code>transform_to_hex_string.bin</code> inside your project and add <code>make</code> rules handling it - i.e. building <code>transform_to_hex_string.bin</code> from <code>transform_to_hex_string.cpp</code> on one side, and running <code>transform_to_hex_string.bin &lt; myfile.inc &gt; myfile.inc.data</code> in another <code>make</code> rule; but it is still external to the compiler!</sup></p>\n<p>Customizing a compiler (be it GCC or LLVM) is compiler specific (and probably version-specific) and would take much more efforts (perhaps a week).</p>\n<p>You might try to lobby some C++ standardization committee member to have such a language feature included in some future (post C++17) standard.</p>\n<p>Remember however that the C++ standard could be read even on hypothetical implementations not even having files or directories (the <a href=\"https://en.wikipedia.org/wiki/C%2B%2B11\" rel=\"nofollow noreferrer\">C++11</a> compiler is required to process \"<a href=\"https://en.wikipedia.org/wiki/Translation_unit\" rel=\"nofollow noreferrer\">translation units</a>\", not \"source files\" in the operating system sense, in the standard wording; a compiler handling <a href=\"https://en.wikipedia.org/wiki/Source_code\" rel=\"nofollow noreferrer\">source code</a> from some database filled by some IDE would be standard compliant - and there have existed such compilers in the previous century, perhaps <a href=\"https://en.wikipedia.org/wiki/IBM_VisualAge\" rel=\"nofollow noreferrer\">VisualAge</a> from IBM)</p>\n<p>From the latest C++11 draft specification (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">n3337</a> <em>\u00a72.1 Separate translation</em>)</p>\n<blockquote>\n<p id=\"so_28103029_28130061_0\">The text of the program is kept in units called source files in this International Standard. A source file\n  together with all the headers (17.6.1.2) and source files included (16.2) via the preprocessing directive #include, less any source lines skipped by any of the conditional inclusion (16.1) preprocessing directives, is\n  called a translation unit. [ Note: A C ++ program need not all be translated at the same time. \u2014 end note ]\n  [ Note: Previously translated translation units and instantiation units can be preserved individually or in\n  libraries. The separate translation units of a program communicate (3.5) by (for example) calls to functions\n  whose identifiers have external linkage, manipulation of objects whose identifiers have external linkage, or\n  manipulation of data files. Translation units can be separately translated and then later linked to produce\n  an executable program (3.5). \u2014 end note ]</p>\n</blockquote>\n<p>Read also the <em>\u00a72.2 Phases of translation</em> of the C++11 standard, notably:</p>\n<blockquote>\n<p id=\"so_28103029_28130061_1\">The precedence among the syntax rules of translation is specified by the following phases.</p>\n<ol>\n<li><p id=\"so_28103029_28130061_2\">Physical source file characters are mapped, in an implementation-defined manner, to the basic source\n  character set [....]</p></li>\n<li><p id=\"so_28103029_28130061_3\">Each instance of a backslash character () immediately followed by a new-line character is deleted,\n  splicing physical source lines to form logical source lines. [....]</p></li>\n<li><p id=\"so_28103029_28130061_4\">The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters\n  (including comments). A source file shall not end in a partial preprocessing token or in a partial com-\n  ment. 12 Each comment is replaced by one space character. New-line characters are retained. Whether\n  each nonempty sequence of white-space characters other than new-line is retained or replaced by one\n  space character is unspecified. The process of dividing a source file\u2019s characters into preprocessing to-\n  kens is context-dependent. [ Example: see the handling of &lt; within a <code>#include</code> preprocessing directive.\n  \u2014 end example ]</p></li>\n<li><p id=\"so_28103029_28130061_5\">Preprocessing directives are executed, macro invocations are expanded, and <code>_Pragma</code> unary operator\n  expressions are executed. If a character sequence that matches the syntax of a universal-character-name is produced by token concatenation (16.3.3), the behavior is undefined. A <code>#include</code> preprocessing directive causes the named header or source file to be processed from phase 1 through phase 4, recursively.\n  All preprocessing directives are then deleted.</p></li>\n</ol>\n</blockquote>\n<p>See also wikipage on <a href=\"https://en.wikipedia.org/wiki/Quine_%28computing%29\" rel=\"nofollow noreferrer\">Quine (computing)</a></p>\n<p>BTW, generating C++ code from external sources with external tools is very common practice: <a href=\"https://en.wikipedia.org/wiki/Yacc\" rel=\"nofollow noreferrer\">Yacc</a> (or GNU <a href=\"http://www.gnu.org/software/bison/\" rel=\"nofollow noreferrer\">bison</a>) &amp; <a href=\"https://en.wikipedia.org/wiki/Lex_%28software%29\" rel=\"nofollow noreferrer\">Lex</a> (or <a href=\"https://github.com/westes/flex\" rel=\"nofollow noreferrer\">Flex</a>) &amp; <a href=\"http://www.antlr.org/\" rel=\"nofollow noreferrer\">ANTLR</a> &amp; <a href=\"http://doc.qt.io/qt-5/moc.html\" rel=\"nofollow noreferrer\">MOC</a> from <a href=\"http://qt-project.org/\" rel=\"nofollow noreferrer\">Qt</a> are very well known examples (and <a href=\"http://gcc-melt.org/\" rel=\"nofollow noreferrer\">MELT</a> is translated to C++).</p>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2017-11-19T19:52:20.007", "Score": "1", "CreationDate": "2015-01-24T20:44:15.040", "ParentId": "28103029", "CommentCount": "0", "OwnerUserId": "841108", "LastEditDate": "2017-11-19T19:52:20.007"}});