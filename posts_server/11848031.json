post_cb({"11848646": {"Id": "11848646", "PostTypeId": "2", "Body": "<p>1)<strong>never use this in initialization list</strong>\n<a href=\"http://msdn.microsoft.com/en-us/library/3c594ae3(v=vs.80).aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/3c594ae3(v=vs.80).aspx</a>\nThe this pointer is valid only within nonstatic member functions. It cannot be used in the initializer list for a base class.</p>\n<p>The base-class constructors and class member constructors are called before this constructor. In effect, you've passed a pointer to an unconstructed object to another constructor. If those other constructors access any members or call member functions on this, the result will be undefined. You should not use the this pointer until all construction has completed.</p>\n<p>shortly: C.r initialized by bad poiter</p>\n", "LastActivityDate": "2012-08-07T14:55:01.993", "CommentCount": "1", "CreationDate": "2012-08-07T14:55:01.993", "ParentId": "11848031", "Score": "0", "OwnerUserId": "904515"}, "11848284": {"Id": "11848284", "PostTypeId": "2", "Body": "<pre>\nstruct C\n{\n    <b>T&amp; r;</b>\n    C(T&amp; v) : r(v) {}\n};\n\nstruct E : T\n{\n    <b>T&amp; r;</b>\n    E(T const&amp; v) : r(*this), T(v) {}   // ok\n};\n</pre>\n<p>You need to initialize any reference at the time of declaration but here you have just declared it. This is not allowed in C++.</p>\n", "LastEditorUserId": "1068443", "LastActivityDate": "2012-08-07T15:17:14.447", "Score": "0", "CreationDate": "2012-08-07T14:34:32.470", "ParentId": "11848031", "CommentCount": "3", "OwnerUserId": "1581088", "LastEditDate": "2012-08-07T15:17:14.447"}, "bq_ids": {"n4140": {"so_11848031_11848814_1": {"length": 9, "quality": 0.9, "section_id": 592}}, "n3337": {"so_11848031_11848814_1": {"length": 9, "quality": 0.9, "section_id": 582}}, "n4659": {"so_11848031_11848814_1": {"length": 9, "quality": 0.9, "section_id": 615}}}, "11848241": {"Id": "11848241", "PostTypeId": "2", "Body": "<p>When you try to initialize the base <code>C</code> of <code>F</code> with <code>*this</code>, both the compiler generated copy constructor for <code>C</code> and the constructor that you define taking a <code>T&amp;</code> are a match as the type of <code>*this</code> (<code>F</code>) is derived directly from both <code>C</code> and <code>T</code>. Your cast resolves this ambiguity.</p>\n<p>I am surprised that the copy constructor is a better match than the one taking <code>T&amp;</code> as I would have thought that they would both be equally preferred. If the copy-constructor is chosen then the base will be initialized from itself which causes <em>undefined behavior</em> as the reference member will be initialized from an uninitialized reference (itself).</p>\n", "LastEditorUserId": "589206", "LastActivityDate": "2012-08-07T14:40:49.310", "Score": "3", "CreationDate": "2012-08-07T14:32:17.180", "ParentId": "11848031", "CommentCount": "5", "OwnerUserId": "19563", "LastEditDate": "2012-08-07T14:40:49.310"}, "11848814": {"Id": "11848814", "PostTypeId": "2", "Body": "<p>The code is ambiguous.</p>\n<p>For constructing the <code>C</code> base of <code>F</code>, the context is direct-initialization, so 13.3.1.3 applies:</p>\n<blockquote>\n<p id=\"so_11848031_11848814_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>13.3.1.3 Initialization by constructor [over.match.ctor]</h3>\n<p id=\"so_11848031_11848814_1\">For direct-initialization, the candidate\n  functions are all the constructors of the class of the object being initialized.</p>\n</blockquote>\n<p>The implicitly-declared copy constructor is included, per 12.8:8.</p>\n<p>The candidates for the constructor of <code>C</code> are <code>C(T &amp;)</code> and (the default copy constructor) <code>C(const C &amp;)</code>, by parameter list <code>(F)</code>.  In both cases we have a reference binding (13.3.3.1.4) followed by a derived-to-base Conversion (13.3.3.1), with an additional cv-qualification adjustment in the latter case, giving overall rank of Conversion in both cases.</p>\n<p>Since <code>C</code> and <code>T</code> are both base classes of <code>F</code>, but are distinct types and neither is a base class of the other, none of the clauses in 13.3.3.2:3 nor 13.3.3.2:4 apply and conversion sequences are indistinguishable.</p>\n<p>Indeed, gcc-4.5.1 rejects the code with:</p>\n<pre><code>prog.cpp: In constructor 'F::F(const T&amp;)':\nprog.cpp:20:34: error: call of overloaded 'C(F&amp;)' is ambiguous\nprog.cpp:9:5: note: candidates are: C::C(T&amp;)\nprog.cpp:7:1: note:                 C::C(const C&amp;)\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-08-07T15:13:05.780", "Score": "3", "CreationDate": "2012-08-07T15:04:40.620", "ParentId": "11848031", "CommentCount": "1", "OwnerUserId": "567292", "LastEditDate": "2012-08-07T15:13:05.780"}, "11848031": {"ViewCount": "1325", "Body": "<pre><code>struct T\n{\n    int a;\n};\n\nstruct C\n{\n    T&amp; r;\n    C(T&amp; v) : r(v) {}\n};\n\nstruct E : T\n{\n    T&amp; r;\n    E(T const&amp; v) : r(*this), T(v) {}   // ok\n};\n\nstruct F : C, T // base order doesn't matter here\n{\n    //F(T const&amp; v) : C(*this), T(v) {}   // error : C::r is not initialized properly\n    F(T const&amp; v) : C(*static_cast&lt;T*&gt;(this)), T(v) {}   // ok\n    //F(T const&amp; v) : C(static_cast&lt;T&amp;&gt;(*this)), T(v) {}   // ok\n};\n\nint main()\n{\n    T v;\n    F f(v);\n    f.r.a = 1;\n}\n</code></pre>\n<p>Although using this pointer in initializer list could be problem, but I've never expected this happened to PODs and may be simply fixed by explicit cast;\nIs this some compiler bug or std related problem?</p>\n", "AcceptedAnswerId": "11848814", "Title": "using this pointer in initializer list", "CreationDate": "2012-08-07T14:19:51.370", "Id": "11848031", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2012-08-07T15:17:14.447", "Score": "6", "OwnerUserId": "872102", "Tags": "<c++>", "AnswerCount": "4"}});