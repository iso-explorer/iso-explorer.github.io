post_cb({"bq_ids": {"n4140": {"so_36760797_36760926_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3376}, "so_36760797_36760987_0": {"length": 14, "quality": 1.0, "section_id": 400}, "so_36760797_36760987_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 405}, "so_36760797_36760926_0": {"length": 23, "quality": 1.0, "section_id": 6107}, "so_36760797_36760987_1": {"length": 20, "quality": 1.0, "section_id": 402}}, "n3337": {"so_36760797_36760926_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3246}, "so_36760797_36760987_0": {"length": 14, "quality": 1.0, "section_id": 391}, "so_36760797_36760987_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 396}, "so_36760797_36760926_0": {"length": 23, "quality": 1.0, "section_id": 5873}, "so_36760797_36760987_1": {"length": 20, "quality": 1.0, "section_id": 393}}, "n4659": {"so_36760797_36760987_1": {"length": 18, "quality": 0.9, "section_id": 384}, "so_36760797_36760987_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 423}, "so_36760797_36760987_0": {"length": 14, "quality": 1.0, "section_id": 417}, "so_36760797_36760926_0": {"length": 23, "quality": 1.0, "section_id": 7604}}}, "36760797": {"ViewCount": "259", "Body": "<pre><code>class Base{};\nclass D1:virtual public Base{};\nclass D2:virtual public Base{};\nclass DD:public D1,public D2{};\n\nint main(){\n    Base *pBase=new DD;\n    delete pBase;\n}\n</code></pre>\n<p>This leads to crash, but I modify as below:</p>\n<pre><code>class Base{\npublic:\n    virtual ~Base(){};\n};\n\nclass D1:virtual public Base{\npublic:\n    virtual ~D1(){}\n};\n\nclass D2:virtual public Base{\npublic:\n    virtual ~D2(){}\n};\n\nclass DD:public D1,public D2{\n};\n</code></pre>\n<p>Then, it passes, but the default destructor should be the virtual dummy function, isn't it?</p>\n", "Title": "Destructor in virtual inheritance", "CreationDate": "2016-04-21T05:56:08.687", "LastActivityDate": "2016-05-17T02:15:05.810", "CommentCount": "5", "LastEditDate": "2016-05-17T02:15:05.810", "PostTypeId": "1", "LastEditorUserId": "963864", "Id": "36760797", "Score": "0", "OwnerUserId": "6233746", "Tags": "<c++><destructor><delete-operator><virtual-inheritance><virtual-destructor>", "AnswerCount": "2"}, "36760926": {"Id": "36760926", "PostTypeId": "2", "Body": "<p>This has nothing to do with virtual inheritance.</p>\n<p>Deleting via a pointer to type T other than the originally allocated type D is Undefined Behavior unless the type T is a base class of D and has a virtual destructor.</p>\n<b>C++14 (as in N3936 draft) \u00a75.3.5/3</b>\n<blockquote>\n<p id=\"so_36760797_36760926_0\"><strong>\u201d</strong> \u2026 if the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>The virtual destructor is used to identify the type D, in particular its size and its destructor, and possibly its custom deallocation function (your code doesn't have that).</p>\n<hr>\n<p>Re</p>\n<blockquote>\n<p id=\"so_36760797_36760926_1\"><strong>\u201d</strong> the default destructor should be the virtual dummy function, isn't it?</p>\n</blockquote>\n<p>No, it isn't.</p>\n<p>Because one guiding principle of the design of C++ is that you don't pay for what you don't use, and another guiding principle is to leave the programmer in control, with the ability to express whatever's needed (e.g. for purposes of binary layout in memory).</p>\n<p>You get a default virtual destructor only if the base class has a virtual destructor.</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2016-04-21T06:12:54.390", "Score": "2", "CreationDate": "2016-04-21T06:04:38.533", "ParentId": "36760797", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2016-04-21T06:12:54.390"}, "36760987": {"Id": "36760987", "PostTypeId": "2", "Body": "<p>From the C++11 specification (ISO/IEC 14882:2011(E)), section 12.4 Destructors [class.dtor]:</p>\n<p>Sub-section 4:</p>\n<blockquote>\n<p id=\"so_36760797_36760987_0\">If a class has no user-declared destructor, a destructor is implicitly declared as defaulted (8.4). An implicitly-declared destructor is an inline public member of its class.</p>\n</blockquote>\n<p>Sub-section 6:</p>\n<blockquote>\n<p id=\"so_36760797_36760987_1\">A destructor that is defaulted and not defined as deleted is implicitly defined when it is odr-used (3.2) to destroy an object of its class type (3.7) or when it is explicitly defaulted after its first declaration.</p>\n</blockquote>\n<p>And finally sub-section 9:</p>\n<blockquote>\n<p id=\"so_36760797_36760987_2\">A destructor can be declared virtual (10.3) or pure virtual (10.4); if any objects of that class or any derived class are created in the program, the destructor shall be defined. If a class has a <strong>base class with a virtual destructor</strong>, its destructor (whether user- or implicitly-declared) is virtual.</p>\n</blockquote>\n<p><sub>Emphasis mine in the last quote.</sub></p>\n<p>The compiler will generate a virtual destructor <em>only</em> if the base class have a virtual destructor. If the base class doesn't have a virtual destructor, like <code>Base</code> in your first example, then the child-classes will not have virtual destructors. And if a class doesn't have a base-class the compiler-generated destructor will not be virtual.</p>\n", "LastActivityDate": "2016-04-21T06:09:17.683", "CommentCount": "1", "CreationDate": "2016-04-21T06:09:17.683", "ParentId": "36760797", "Score": "2", "OwnerUserId": "440558"}});