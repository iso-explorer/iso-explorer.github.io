post_cb({"bq_ids": {"n4140": {"so_42555541_42555541_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7138}, "so_42555541_42555541_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 7143}}, "n3337": {"so_42555541_42555541_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6882}, "so_42555541_42555541_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 6887}}, "n4659": {"so_42555541_42555541_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 8639}, "so_42555541_42555541_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 8644}}}, "42555590": {"Id": "42555590", "PostTypeId": "2", "Body": "<p>It's an ODR violation. The Foo type has different declarations in each file.</p>\n<p>One definition says x is declared with external linkage (can be anything, determined when linking) and the other that it's a compile-time constant with value 2. </p>\n", "LastEditorUserId": "72312", "LastActivityDate": "2017-03-03T09:20:32.160", "Score": "3", "CreationDate": "2017-03-02T12:30:01.847", "ParentId": "42555541", "CommentCount": "4", "OwnerUserId": "72312", "LastEditDate": "2017-03-03T09:20:32.160"}, "42555541": {"ViewCount": "187", "Body": "<p>I'm working on a static analyzer for C++11. There is an interaction between static const members of a class and linkage for which I am not sure whether it is defined. My static analyzer should warn for it only if this construct is not defined.</p>\n<p>The example is this one:</p>\n<p>in file f1.cpp:</p>\n<pre><code>struct Foo {\n    static const int x = 2;\n};\n\nint main(void) {\n    return *&amp;Foo::x;\n}\n</code></pre>\n<p>and in file f2.cpp:</p>\n<pre><code>struct Foo {\n    static int x;\n};\n\nint Foo::x;\n</code></pre>\n<p>The two files compiled and linked with <code>clang++ -std=c++11 -Weverything f1.cpp f2.cpp</code> cause no warning and produce a binary that returns 0. The same files when compiled with <code>g++ -std=c++11 -Wall -Wextra -pedantic f1.cpp f2.cpp</code> cause no warning and return 2.</p>\n<p>My intuition is that this program is ill-defined but no warning is required, as:</p>\n<ul>\n<li><p>both names Foo::x have external linkage following N3376[basic.link]p5:</p>\n<blockquote>\n<p id=\"so_42555541_42555541_0\">In addition, a member function, static data member,[...]\n  has the typedef name for linkage purposes (7.1.3), has external linkage if the name of the class has external\n  linkage.</p>\n</blockquote></li>\n<li><p>but they break the N3376[basic.link]p10 requirement:</p>\n<blockquote>\n<p id=\"so_42555541_42555541_1\">After all adjustments of types (during which typedefs (7.1.3) are replaced by their definitions), the types\n  specified by all declarations referring to a given variable or function shall be identical [...] A violation of this rule on type identity does not require a diagnostic.</p>\n</blockquote></li>\n</ul>\n<p>To be 100% sure about this, a definition for these \"all adjustments of types\" is needed, but seems nowhere to be found in the C++11 standard. Is there any, and is the reasoning above correct?</p>\n", "AcceptedAnswerId": "42555590", "Title": "Static const data member defined in another file", "CreationDate": "2017-03-02T12:27:49.327", "Id": "42555541", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-03-03T09:20:32.160", "Score": "6", "OwnerUserId": "7646271", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}});