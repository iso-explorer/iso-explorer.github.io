post_cb({"37798682": {"CommentCount": "4", "ViewCount": "88", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-06-13T20:35:04.770", "LastActivityDate": "2016-06-15T21:54:29.827", "Title": "Compile-time calculation of bits needed to represent a range", "AcceptedAnswerId": "37800043", "LastEditDate": "2016-06-13T20:43:40.957", "Id": "37798682", "Score": "2", "Body": "<p>I need to calculate at compile-time the number of bits needed to represent a range. \nFor an unsigned range from 0 to n it is simple:</p>\n<pre><code>constexpr unsigned bits_to_represent(uintmax_t n) \n{\n    return n &gt; 0 \n        ? 1 + bits_to_represent(n/2)\n        : 0; \n}\n</code></pre>\n<p>For a signed range, I have:</p>\n<pre><code>constexpr unsigned bits_in_range(intmax_t min,intmax_t max)\n{\n    return bits_to_represent(max &gt;= 0\n              ? static_cast&lt;uintmax_t&gt;(max) - min\n              : max - min);\n}\n</code></pre>\n<p>However this causes MSVC 2015 (recently updated) to complain:</p>\n<p>warning C4308: negative integral constant converted to unsigned type</p>\n<p>Can you explain why this happens? As a work-around, I static_cast min to uintmax_t, but I do not like this solution as it seems less portable than my preferred solution and probably even is undefined behaviour, even though I am sceptical is that can happen at compile time.</p>\n", "Tags": "<c++><c++11><compile-time>", "OwnerUserId": "3721426", "AnswerCount": "3"}, "37800043": {"ParentId": "37798682", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I'm not sure exactly why MSVC is giving a warning, but one thing that you are doing that could cause bad behavior is mixing signed and unsigned integers in arithmetic operations and comparisons.</p>\n<p>You can read this for examples of problems caused by this: <a href=\"http://blog.regehr.org/archives/268\" rel=\"nofollow\">http://blog.regehr.org/archives/268</a></p>\n<p>I would try rewriting your function like this:</p>\n<pre><code>constexpr unsigned bits_in_range(intmax_t min,intmax_t max)\n{\n    return bits_to_represent(\n             static_cast&lt;uintmax_t&gt;(max) - static_cast&lt;uintmax_t&gt;(min));\n}\n</code></pre>\n<p>This way is more programmer friendly. When you do arithmetic operations on mismatched integer types, the compiler is going to have to do implicit conversions to make them match. This way, it doesn't have to do that. Even if max and min are negative, this will still give well-defined and correct results, if you are sure that <code>max &gt;= min</code>.</p>\n", "OwnerUserId": "3598119", "LastEditorUserId": "3598119", "LastEditDate": "2016-06-15T21:54:29.827", "Id": "37800043", "Score": "1", "CreationDate": "2016-06-13T22:19:15.647", "LastActivityDate": "2016-06-15T21:54:29.827"}, "37800887": {"ParentId": "37798682", "CommentCount": "0", "Body": "<p>Thank you for your comments even though they did not explain the Microsoft warning. Clang compiles cleanly, so it might be a bug in the compiler.\nDue to the nature of conversion from signed to unsigned values in C++ the correct answer will be obtained by simply casting both values (again assuming that min &lt;= max):</p>\n<pre><code>constexpr unsigned bits_in_range(intmax_t min,intmax_t max)\n{\n    return bits_to_represent(static_cast&lt;largest_uint&gt;(max) -\n                             static_cast&lt;largest_uint&gt;(min));\n}\n</code></pre>\n<p>The validity of the code can be inferred from this part of the draft standard (I looked at the newest draft but am confident that there has not been a change here).</p>\n<blockquote>\n<p id=\"so_37798682_37800887_0\">4.7 Integral conversions [conv.integral]</p>\n<p id=\"so_37798682_37800887_1\">If the destination type is unsigned, the resulting value is the least &gt; unsigned integer congruent to the source\n  integer (modulo 2n where n is the number of bits used to represent the\n  unsigned type). </p>\n</blockquote>\n", "OwnerUserId": "3721426", "PostTypeId": "2", "Id": "37800887", "Score": "0", "CreationDate": "2016-06-13T23:52:02.340", "LastActivityDate": "2016-06-13T23:52:02.340"}, "bq_ids": {"n4140": {"so_37798682_37800887_1": {"section_id": 31, "quality": 1.0, "length": 18}}, "n3337": {"so_37798682_37800887_1": {"section_id": 28, "quality": 1.0, "length": 18}}, "n4659": {"so_37798682_37800887_1": {"section_id": 31, "quality": 1.0, "length": 18}}}, "37799205": {"ParentId": "37798682", "CommentCount": "5", "Body": "<p>Do it in 4 parts.  Each of min max at least zero.</p>\n<p>If they share the same sign (with 0 as positive), 2s complement integers can have their difference represented as part of their own type.</p>\n<p>That leaves <code>max&lt;min</code> and <code>max</code> positive and <code>min</code> negative cases.</p>\n<p>If we assume <code>uint_max_t</code> is big enough, arithmetic and conversion to that type all behaves according to math mod <code>2^n</code>.</p>\n<p>So <code>unsigned(a)-unsigned(b)</code> will actually be the unsigned distance to get from b to a as signed integers.</p>\n<pre><code>C = A-B mod X\nC = A-B + kX\nB+C=A+kX\n</code></pre>\n<p>With <code>C</code> positive and less than <code>X</code>, and <code>X</code> larger than <code>B-A</code>, gives us <code>C</code> must be the delta.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "37799205", "Score": "1", "CreationDate": "2016-06-13T21:12:02.253", "LastActivityDate": "2016-06-13T21:12:02.253"}});