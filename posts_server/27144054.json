post_cb({"27144307": {"Id": "27144307", "PostTypeId": "2", "Body": "<p>\u00a713.3.1.7 [over.match.list]/p1:</p>\n<blockquote>\n<p id=\"so_27144054_27144307_0\">When objects of non-aggregate class type <code>T</code> are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases:</p>\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of\n  the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all\n  the constructors of the class <code>T</code> and the argument list consists of\n  the elements of the initializer list.</li>\n</ul>\n<p id=\"so_27144054_27144307_1\">If the initializer list has no elements and <code>T</code> has a default\n  constructor, the first phase is omitted. In copy-list-initialization,\n  if an <code>explicit</code> constructor is chosen, the initialization is\n  ill-formed.</p>\n</blockquote>\n<p>As long as there is a viable initializer-list constructor, it will trump all non-initializer-list constructors when list-initialization is used and the initializer list has at least one element.</p>\n", "LastActivityDate": "2014-11-26T08:25:11.757", "CommentCount": "4", "CreationDate": "2014-11-26T08:25:11.757", "ParentId": "27144054", "Score": "22", "OwnerUserId": "2756719"}, "27144477": {"Id": "27144477", "PostTypeId": "2", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf\">n2100</a> proposal for initializer lists goes into great detail about the decision to make sequence constructors (what they call constructors that take <code>std::initializer_lists</code>) to have priority over regular constructors. See Appendix B for a detailed discussion. It's succinctly summarized in the conclusion:</p>\n<blockquote>\n<p id=\"so_27144054_27144477_0\">11.4 Conclusion </p>\n<p id=\"so_27144054_27144477_1\">So, how do we decide between the remaining two alternatives (\u201cambiguity\u201d and \u201csequence constructors take priority\n  over ordinary constructors)? Our proposal gives sequence constructors\n  priority because</p>\n<ul>\n<li>Looking for ambiguities among all the constructors leads to too many \u201cfalse positives\u201d; that is, clashes between apparently unrelated\n  constructors. See examples below.</li>\n<li>Disambiguation is itself error-prone (as well as verbose). See examples in \u00a711.3.</li>\n<li>Using exactly the same syntax for every number of elements of a homogeneous list is important \u2013 disambiguation should be done for\n  ordinary constructors (that do not have a regular pattern of\n  arguments). See examples in \u00a711.3. The simplest example of a false\n  positive is the default constructor:</li>\n</ul>\n<p id=\"so_27144054_27144477_2\">The simplest example of a false positive is the default constructor:</p>\n<pre><code>vector&lt;int&gt; v; \nvector&lt;int&gt; v { }; // potentially ambiguous\nvoid f(vector&lt;int&gt;&amp;); \n// ...\nf({ }); // potentially ambiguous\n</code></pre>\n<p id=\"so_27144054_27144477_3\">It is possible to think of classes where initialization with no\n  members is semantically distinct from default initialization, but we\n  wouldn\u2019t complicate the language to provide better support for those\n  cases than for the more common case where they are semantically the\n  same.</p>\n<p id=\"so_27144054_27144477_4\">Giving priority to sequence constructors breaks argument checking into\n  more comprehensible chunks and gives better locality.</p>\n<pre><code>void f(const vector&lt;double&gt;&amp;);\n// ...\nstruct X { X(int); /* ... */ };\nvoid f(X);\n// ...\nf(1);     // call f(X); vector\u2019s constructor is explicit\nf({1});   // potentially ambiguous: X or vector?\nf({1,2}); // potentially ambiguous: 1 or 2 elements of vector\n</code></pre>\n<p id=\"so_27144054_27144477_5\">Here, giving priority to sequence constructors eliminates the\n  interference from X. Picking X for f(1) is a variant of the problem\n  with explicit shown in \u00a73.3.</p>\n</blockquote>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-11-26T08:34:17.323", "Score": "12", "CreationDate": "2014-11-26T08:34:17.323", "ParentId": "27144054", "CommentCount": "0"}, "27144112": {"Id": "27144112", "PostTypeId": "2", "Body": "<p>The whole initializer list thing was meant to enable list initialisation like so:</p>\n<pre><code>std::vector&lt;int&gt; v { 0, 1, 2 };\n</code></pre>\n<p>Consider the case</p>\n<pre><code>std::vector&lt;int&gt; v { 123 };\n</code></pre>\n<p>That this initializes the vector with one element of value 123 rather than 123 elements of value zero is intended.</p>\n<p>To access the other constructor, use the old syntax</p>\n<pre><code>Foo foo(10);\n</code></pre>\n", "LastActivityDate": "2014-11-26T08:12:56.990", "CommentCount": "2", "CreationDate": "2014-11-26T08:12:56.990", "ParentId": "27144054", "Score": "5", "OwnerUserId": "4260577"}, "bq_ids": {"n4140": {"so_27144054_27144307_1": {"length": 14, "quality": 1.0, "section_id": 599}, "so_27144054_27144307_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}}, "n3337": {"so_27144054_27144307_1": {"length": 14, "quality": 1.0, "section_id": 589}, "so_27144054_27144307_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}}, "n4659": {"so_27144054_27144307_1": {"length": 14, "quality": 1.0, "section_id": 622}, "so_27144054_27144307_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}}}, "27144054": {"ViewCount": "1729", "Body": "<p>Consider the code</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo\n{\n    int val_;\npublic:\n    Foo(std::initializer_list&lt;Foo&gt; il)\n    {\n        std::cout &lt;&lt; \"initializer_list ctor\" &lt;&lt; std::endl;\n    }\n    /* explicit */ Foo(int val): val_(val)\n    {\n        std::cout &lt;&lt; \"ctor\" &lt;&lt; std::endl;\n    };\n};\n\nint main(int argc, char const *argv[])\n{\n    // why is the initializer_list ctor invoked?\n    Foo foo {10}; \n}\n</code></pre>\n<p>The output is</p>\n<pre><code>ctor\ninitializer_list ctor\n</code></pre>\n<p>As far as I understand, the value <code>10</code> is implicitly converted to a <code>Foo</code> (first <code>ctor</code> output), then the initializer constructor kicks in (second <code>initializer_list ctor</code> output). My question is why is this happening? Isn't the standard constructor <code>Foo(int)</code> a better match? I.e., I would have expected the output of this snippet to be just <code>ctor</code>.</p>\n<p>PS: If I mark the constructor <code>Foo(int)</code> as <code>explicit</code>, then <code>Foo(int)</code> is the only constructor invoked, as the integer <code>10</code> cannot now be implicitly converted to a <code>Foo</code>.</p>\n", "AcceptedAnswerId": "27144307", "Title": "Why is the std::initializer_list constructor preferred when using a braced initializer list?", "CreationDate": "2014-11-26T08:09:48.650", "Id": "27144054", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-09-17T11:22:26.363", "LastEditorUserId": "3980929", "LastActivityDate": "2017-09-17T11:22:26.363", "Score": "23", "OwnerUserId": "3093378", "Tags": "<c++><c++11><constructor><language-lawyer><initializer-list>", "AnswerCount": "3"}});