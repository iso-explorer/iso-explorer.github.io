post_cb({"27814859": {"ViewCount": "899", "LastEditDate": "2015-01-07T08:42:21.170", "AcceptedAnswerId": "27815007", "Title": "C++14: deduced (auto) return types from constexpr with ternary expressions", "CreationDate": "2015-01-07T08:02:55.660", "LastActivityDate": "2015-01-07T08:58:40.583", "CommentCount": "0", "Body": "<p>I am experimenting with constexpr functions in C++14. The following code, which computes the factorial works as expected:</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr auto fact(T a) {\n    if(a==1)\n        return 1;\n    return a*fact(a-1);\n}\n\nint main(void) {\n    static_assert(fact(3)==6,  \"fact doesn't work\");\n}\n</code></pre>\n<p>when it is compiled as follows with clang:</p>\n<pre><code>&gt; clang++ --version\nclang version 3.5.0 (tags/RELEASE_350/final)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\n&gt; clang++ -std=c++14 constexpr.cpp\n</code></pre>\n<p>However, when I change the <code>fact</code> definition to use the ternary <code>?</code> operator:</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr auto fact(T a) {\n    return a==1 ? 1 : a*fact(a-1);\n}\n</code></pre>\n<p>I get the following compiler error:</p>\n<pre><code>&gt; clang++ -std=c++14 constexpr.cpp\nconstexpr.cpp:12:31: fatal error: recursive template instantiation exceeded maximum depth of\n      256\n    return a==T(1) ? T(1) : a*fact(a-1);\n        ... snip ...\nconstexpr.cpp:16:19: note: in instantiation of function template specialization 'fact&lt;int&gt;'\n      requested here\n    static_assert(fact(3)==6,  \"fact doesn't work\");\n</code></pre>\n<p>The problem is fixed if I explicitly state the return type T (instead of using auto to deduce the return type)</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr T fact(T a) {\n    return a==1 ? 1 : a*fact(a-1);\n}\n</code></pre>\n<p>If I remove the template parameter, the pattern is repeated (the ternary version fails, and the <code>if</code> version works)</p>\n<pre><code>// this works just fine\nconstexpr auto fact(int a) {\n    if(a==1)\n        return 1;\n    return a*fact(a-1);\n}\n</code></pre>\n<p>whereas this fails</p>\n<pre><code>constexpr auto fact(int a) {\n    return a==1 ? 1 : a*fact(a-1);\n}\n</code></pre>\n<p>with the following error</p>\n<pre><code>&gt; clang++ -std=c++14 constexpr.cpp\nconstexpr.cpp:16:25: error: function 'fact' with deduced return type cannot be used before it\n      is defined\n    return a==1 ? 1 : a*fact(a-1);\n                        ^\nconstexpr.cpp:15:16: note: 'fact' declared here\nconstexpr auto fact(int a) {\n               ^\nconstexpr.cpp:20:26: error: invalid operands to binary expression ('void' and 'int')\n    static_assert(fact(3)==6,  \"fact doesn't work\");\n                  ~~~~~~~^ ~\n2 errors generated.\n</code></pre>\n<p>What is going on here?</p>\n", "PostTypeId": "1", "LastEditorUserId": "15168", "Id": "27814859", "AnswerCount": "1", "Score": "13", "OwnerUserId": "1341660", "Tags": "<c++><ternary-operator><c++14><constexpr>", "FavoriteCount": "1"}, "bq_ids": {"n4140": {"so_27814859_27815007_0": {"length": 22, "quality": 1.0, "section_id": 5453}}, "n4659": {"so_27814859_27815007_0": {"length": 22, "quality": 1.0, "section_id": 6879}}}, "27815007": {"Id": "27815007", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:14:31.680", "CommentCount": "4", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-07T08:58:40.583", "CreationDate": "2015-01-07T08:14:28.913", "ParentId": "27814859", "Score": "11", "Body": "<p>The resulting type from evaluating a ternary expression is the <a href=\"https://stackoverflow.com/a/8535244/241631\">common type of its second and third arguments</a>.</p>\n<p>By having the compiler deduce the return type, you force it to evaluate both of these arguments to the ternary expression. This means that the recursion doesn't end even when the terminating condition is reached, because when <code>a==1</code>, to figure out the return type of <code>fact(0)</code> the compiler must continue evaluating further recursive calls to <code>fact</code>, and endless recursion ensues.</p>\n<p>By stating the return type, <code>fact(0)</code> does not need to be evaluated when <code>a==1</code>, and the recursion is able to terminate.</p>\n<hr>\n<p>As for the case with the two <code>return</code> statements, the relevant standard clause is \u2014</p>\n<p>(from N4296) <em>\u00a77.1.6.4/9</em> <strong>[dcl.spec.auto]</strong></p>\n<blockquote>\n<p id=\"so_27814859_27815007_0\">If a function with a declared return type that contains a placeholder type has multiple return statements, <strong>the return type is deduced for each return statement</strong>. If the type deduced is not the same in each deduction, the program is ill-formed.</p>\n</blockquote>\n<p>In your example, in the call to <code>fact&lt;int&gt;(1)</code>, the return type deduced from the first <code>return</code> statement is <code>int</code>, so the return type of <code>fact&lt;int&gt;(0)</code> in the second <code>return</code> statement cannot be anything but <code>int</code> as well. This means the compiler does not need to evaluate the body of <code>fact&lt;int&gt;(0)</code> and the recursion can terminate.</p>\n<p>Indeed, if you force evaluation of the call to <code>fact</code> in the second <code>return</code> statement as well, for instance by changing the first example so that <code>T</code> is a non-type template argument </p>\n<pre><code>template &lt;unsigned T&gt;\nconstexpr auto fact() {\n    if(T==1)\n        return 1;\n    return T*fact&lt;T-1&gt;();\n}\n</code></pre>\n<p>clang does fail with the error</p>\n<blockquote>\n<p id=\"so_27814859_27815007_1\">fatal error: recursive template instantiation exceeded maximum depth of 256</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/0e98a4e6c3e1574e\" rel=\"nofollow noreferrer\">Live demo</a></p>\n</hr>", "OwnerUserId": "241631"}});