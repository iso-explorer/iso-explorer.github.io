post_cb({"37674591": {"Id": "37674591", "PostTypeId": "2", "Body": "<p>I would say that your construct is correct except for a little syntax error, you need to qualify <code>base&lt;T&gt;</code> in the initializer list:</p>\n<pre><code>derived(derived &amp;&amp;d): base&lt;T&gt;(std::move(d)), t2(std::move(d.t2)){}\n</code></pre>\n<p>First, the order of initialization is independant of the order of the initializer list. Draft n4296 says in <em>12.6.2 Initializing bases and members [class.base.init] \u00a7 13</em></p>\n<blockquote>\n<p id=\"so_37668952_37674591_0\">In a non-delegating constructor, initialization proceeds in the following order:<br/>\n  (13.1) \u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in\n  the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes,\n  where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.\n  <br/>(13.2) \u2014 Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list\n  (regardless of the order of the mem-initializers).\n  <br/>(13.3) \u2014 Then, non-static data members are initialized in the order they were declared in the class definition\n  (again regardless of the order of the mem-initializers).\n  <br/>(13.4) \u2014 Finally, the compound-statement of the constructor body is executed.</p>\n<p id=\"so_37668952_37674591_1\">[ Note: The declaration order is mandated to ensure that base and member subobjects are destroyed in the\n  reverse order of initialization. \u2014end note ]</p>\n</blockquote>\n<p>We have also \u00a77 or same chapter that says:</p>\n<blockquote>\n<p id=\"so_37668952_37674591_2\">The initialization performed by each mem-initializer constitutes a full-expression. Any\n  expression in a mem-initializer is evaluated as part of the full-expression that performs the initialization.</p>\n</blockquote>\n<p>My understanding is that standard says that in the move ctor for the <code>derived</code> class, things happens in that order:</p>\n<ul>\n<li>move ctor for base class is called\n\n<ul>\n<li>in turn it calls move ctor for T effectively constructing t member of target and eventually zeroing t member of source</li>\n</ul></li>\n<li>move ctor for T2 object is called - at that moment, the end of the full expression has not been reached, and only t member of source has eventually been destroyed</li>\n<li>at the end of the full statement, source object is left in an undetermined state and should no longer be used.</li>\n</ul>\n", "LastActivityDate": "2016-06-07T08:45:42.347", "Score": "3", "CreationDate": "2016-06-07T08:45:42.347", "ParentId": "37668952", "CommentCount": "0", "OwnerUserId": "3545273"}, "bq_ids": {"n4140": {"so_37668952_37674591_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 438}, "so_37668952_37674591_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 434}, "so_37668952_37674591_0": {"length": 68, "quality": 0.9444444444444444, "section_id": 438}}, "n3337": {"so_37668952_37674591_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 429}, "so_37668952_37674591_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 426}, "so_37668952_37674591_0": {"length": 68, "quality": 0.9444444444444444, "section_id": 429}}, "n4659": {"so_37668952_37674591_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 458}, "so_37668952_37674591_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 452}, "so_37668952_37674591_0": {"length": 68, "quality": 0.9444444444444444, "section_id": 458}}}, "37668952": {"ViewCount": "481", "Body": "<p>I have 2 classes:</p>\n<pre><code>template&lt;typename T&gt;\nclass base{\n    T t;\npublic:\n    base(base &amp;&amp;b): t(std::move(b.t)){}\n};\n\ntemplate&lt;typename T, typename T2&gt;\nclass derived : protected base&lt;T&gt;{\n    T2 t2;\npublic:\n    derived(derived &amp;&amp;d): base&lt;T&gt;(std::move(d)), t2(std::move(d.t2)){}\n};\n</code></pre>\n<p>I move entire <code>d</code> object in the <code>derived</code> <code>move-constructor</code> to initialize <code>base</code> part and <code>d</code> becomes invalid but I still need it to use it's part for <code>t2</code> initialization</p>\n<p>Is it possible to do such a thing?</p>\n", "AcceptedAnswerId": "37674591", "Title": "Move constructor for derived class", "CreationDate": "2016-06-07T00:59:37.040", "Id": "37668952", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-06-07T13:11:53.673", "LastEditorUserId": "2101084", "LastActivityDate": "2016-06-07T13:11:53.673", "Score": "3", "OwnerUserId": "2101084", "Tags": "<c++><c++11><constructor><initialization><move-semantics>", "AnswerCount": "1"}});