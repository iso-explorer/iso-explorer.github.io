post_cb({"47546260": {"ParentId": "47546111", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>First a couple of standard quotes, with my emphasis:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/stmt.while#1\" rel=\"nofollow noreferrer\">[stmt.while]/1</a></p>\n<blockquote>\n<p id=\"so_47546111_47546260_0\">In the while statement the substatement is executed repeatedly until\n  the value of the condition ([stmt.select]) becomes false. <strong>The test\n  takes place before each execution of the substatement</strong>.</p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.prim.lambda#2\" rel=\"nofollow noreferrer\">[expr.prim.lambda]/2</a></p>\n<blockquote>\n<p id=\"so_47546111_47546260_1\">A lambda-expression is a prvalue whose result object is called the\n  closure object.</p>\n</blockquote>\n<p>The above tells use that <code>([]()-&gt;bool { return something(); })()</code> is evaluated before every iteration. And that the sub-expression <code>[]()-&gt;bool { return something(); }</code> creates a prvalue. So it springs to life only during the evaluation of the full expression.</p>\n<p>So the dry letter of the law would indicate it's a different object of the closure type that is constructed and destructed every time the condition is evaluated.</p>\n<p>But compilers are not stupid. I believe that under the as-if rule it's more than likely to be optimized into a direct call to <code>something()</code>. That is because the construction and destruction of the lambda does not have observable side effects.</p>\n<p>And if we indeed use a tool like the <a href=\"https://godbolt.org/g/ttK8Eg\" rel=\"nofollow noreferrer\">godbolt online compiler viewer</a>, we see that GCC 7.2 at <code>-O1</code> will call the function directly. And so does Clang 5.0, but I had to crank optimizations to <code>-O2</code> for that to happen.</p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-11-29T06:26:05.650", "Id": "47546260", "Score": "5", "CreationDate": "2017-11-29T06:17:34.280", "LastActivityDate": "2017-11-29T06:26:05.650"}, "bq_ids": {"n4140": {"so_47546111_47546260_1": {"section_id": 3296, "quality": 0.625, "length": 5}, "so_47546111_47546260_0": {"section_id": 3899, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_47546111_47546260_1": {"section_id": 3166, "quality": 0.625, "length": 5}, "so_47546111_47546260_0": {"section_id": 3759, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_47546111_47546260_1": {"section_id": 7448, "quality": 1.0, "length": 8}, "so_47546111_47546260_0": {"section_id": 4785, "quality": 0.8947368421052632, "length": 17}}}, "47546111": {"CommentCount": "3", "AcceptedAnswerId": "47546260", "CreationDate": "2017-11-29T06:04:40.740", "LastActivityDate": "2017-11-29T06:26:05.650", "PostTypeId": "1", "ViewCount": "69", "FavoriteCount": "3", "Title": "C++ lambda lifecycle", "Id": "47546111", "Score": "3", "Body": "<p>In the following code, what happens at runtime?</p>\n<pre><code>while ( ([]()-&gt;bool { return something(); })() ) {\n    ...\n}\n</code></pre>\n<ol>\n<li>The lambda instance is created only once and reused in subsequent iterations.</li>\n<li>Every iteration creates a new instance, that is only used once.</li>\n<li>None of the above (please explain).</li>\n</ol>\n<p>Initially it seems obvious to me that it's re-created in every iteration, but I wonder if the compiler does some kind of optimization.</p>\n", "Tags": "<c++><lambda>", "OwnerUserId": "877542", "AnswerCount": "1"}});