post_cb({"5431526": {"ParentId": "5430801", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>One issue with your example is that it has an implicitly-declared, trivial destructor. Despite the name, the implementation is not AFAIK forbidden from doing something in a trivial destructor of a non-POD class.</p>\n<p>So legally on some weird implementation, your class <code>ex_struct</code> could exhibit runtime behavior equivalent to the following:</p>\n<pre><code>struct weird_ex_struct\n{\n  int a,b,c,d;\n  weird_ex_struct() : a(123), aptr(&amp;a) { }\n  weird_ex_struct(const weird_ex_struct &amp;o) : \n    a(o.a), b(o.b), c(o.c), d(o.d), aptr(&amp;a) {}\n  weird_ex_struct &amp;operator=(const weird_ex_struct &amp;o) {\n    a = o.a; //etc\n    aptr = &amp;a;\n    return *this;\n  }\n  ~weird_ex_struct() {\n    if (aptr != &amp;a) std::terminate();\n  }\nprivate:\n  int *aptr;\n}\n</code></pre>\n<p>I say runtime behavior, because <code>weird_ex_struct</code> has a non-trivial destructor, and that affects how it can legally be used (not in unions, for one thing). Also I think there are standard ways to detect the existence of private data members at compile-time. But as long as the implementation can keep this stuff secret unless you do something undefined (<code>memcpy</code> a non-POD object), it's then allowed to spring the surprise on you later.</p>\n<p>Clearly if <code>weird_ex_struct</code> is copied with <code>memcpy</code>, then something strange will happen when it's destroyed.</p>\n<p>There's no obvious reason for an implementation to do this, but the standard left non-POD classes wide open for implementations to do odd things. Not sure whether this is because they thought anyone would think of some useful weirdness, or just because they didn't get around to defining <em>standard-layout</em> like C++0x does.</p>\n<p>[Edit: Johannes has pointed that I'm wrong about trivial destructors - for reasons set out in the part of the standard dealing with object lifetime, an implementation can't do things in trivial destructors that rely on the contents of the memory of the object. Possibly they can if the destructor is called explicitly, I'm not certain.</p>\n<p>However, the fact remains that the standard permits implementations to do quite a lot of crazy things with non-POD objects, and as soon as you write a constructor, you open that door.]</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2011-03-27T23:20:19.850", "Id": "5431526", "Score": "1", "CreationDate": "2011-03-25T10:58:23.177", "LastActivityDate": "2011-03-27T23:20:19.850"}, "5430801": {"CommentCount": "18", "AcceptedAnswerId": "5453372", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-03-25T09:45:53.780", "LastActivityDate": "2011-08-24T22:53:31.840", "LastEditDate": "2017-05-23T11:53:26.267", "ViewCount": "1377", "FavoriteCount": "2", "Title": "C++ guarantee and name for POD-like data, memcpy capable", "Id": "5430801", "Score": "17", "Body": "<p>In another <a href=\"https://stackoverflow.com/questions/5430022/max-sized-array-with-normal-stl-interface-similar-to-boostarray\">question</a> I incorrectly used the term POD to refer to data types that aren't actually POD types (on account of having a constructor). Now, I've looked through the standard and couldn't find a proper name for what I want. Nor can I actually find a guarantee that copying is actually allowed.</p>\n<p>The data type I mean is a POD, but may contain functions, including constructors, but nothing that should alter its alignment or size characteristics when compared to an equivalent POD type.</p>\n<p>In section 3.9 of the standard it states that POD data can be copied with memcpy, either to another object, or to character data and back. No such guarantee is ever made of non-POD data.</p>\n<p>However, the <em>object representation</em> of an object is defined in the same section. It is defined such that one would believe any two objects of the same type could be safely copied via memcpy.</p>\n<p>So my questions are:</p>\n<ol>\n<li>Is the copy with memcpy actually guaranteed to be safe for such objects?</li>\n<li>If yes, then why is there a special note about memcpy and POD?</li>\n<li>Is there a name for this type of data which is memcpy safe?</li>\n</ol>\n<hr>\n<p>A simple example of the type of object I mean:</p>\n<pre><code>struct ex_struct\n{\n  int a,b,c,d;\n  ex_struct() : a(123) { }\n}\n</code></pre>\n<hr>\n<p>Reading the C++0x draft, my struct would appear to be a <em>trivially copyable class</em> (9.1). I believe that implies memcpy would be safe.</p>\n</hr></hr>", "Tags": "<c++><c++11>", "OwnerUserId": "229686", "AnswerCount": "4"}, "5453372": {"ParentId": "5430801", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In C++0x, the concept of PODness is broken out into several individually useful categories:</p>\n<blockquote>\n<p id=\"so_5430801_5453372_0\">A <em>trivially copyable class</em> is a class that (draft 3242, section <code>[class]</code>):</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n<p id=\"so_5430801_5453372_1\">A <em>trivial class</em> is a class that has a trivial default constructor (12.1) and is trivially copyable.</p>\n<p id=\"so_5430801_5453372_2\">[ <em>Note:</em>  In particular, a trivially copyable or trivial class does not have virtual functions or virtual base\n  classes. \u2014 <em>end note</em> ]</p>\n<p id=\"so_5430801_5453372_3\">A <em>standard-layout class</em> is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with\n  non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n</blockquote>\n<p>The requirements for trivial constructors, assignment operators, and destructor are scattered throughout section 12 \"Special Member Functions\" <code>[special]</code>.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-03-28T00:05:52.237", "Id": "5453372", "Score": "7", "CreationDate": "2011-03-28T00:00:30.010", "LastActivityDate": "2011-03-28T00:05:52.237"}, "5430854": {"ParentId": "5430801", "CommentCount": "8", "Body": "<p>The notion of POD in C++03 is too strict indeed. In C++0x POD is generalized to include the objects you described too. So don't worry, you can name it POD. See a nice summery on <a href=\"http://en.wikipedia.org/wiki/C%2B%2B0x#Modification_to_the_definition_of_plain_old_data\" rel=\"nofollow\">Wikipedia</a>.</p>\n", "OwnerUserId": "277176", "PostTypeId": "2", "Id": "5430854", "Score": "4", "CreationDate": "2011-03-25T09:51:04.840", "LastActivityDate": "2011-03-25T09:51:04.840"}, "5430863": {"ParentId": "5430801", "CommentCount": "0", "Body": "<p>Yes it's safe to copy with memcpy because you constructor only initialize values.</p>\n", "OwnerUserId": "572586", "PostTypeId": "2", "Id": "5430863", "Score": "0", "CreationDate": "2011-03-25T09:52:06.250", "LastActivityDate": "2011-03-25T09:52:06.250"}, "bq_ids": {"n4140": {"so_5430801_5453372_1": {"section_id": 5850, "quality": 0.7777777777777778, "length": 7}, "so_5430801_5453372_2": {"section_id": 5850, "quality": 0.8, "length": 12}, "so_5430801_5453372_0": {"section_id": 4706, "quality": 0.625, "length": 5}}, "n3337": {"so_5430801_5453372_1": {"section_id": 5620, "quality": 0.8888888888888888, "length": 8}, "so_5430801_5453372_2": {"section_id": 5620, "quality": 0.8, "length": 12}, "so_5430801_5453372_0": {"section_id": 4515, "quality": 0.625, "length": 5}}, "n4659": {"so_5430801_5453372_1": {"section_id": 7329, "quality": 0.6666666666666666, "length": 6}, "so_5430801_5453372_2": {"section_id": 7329, "quality": 0.8, "length": 12}, "so_5430801_5453372_0": {"section_id": 6103, "quality": 0.625, "length": 5}}}});