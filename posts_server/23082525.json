post_cb({"23082900": {"ParentId": "23082525", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You are wrong. You may have several declarations of the same function in a declarative region. For example</p>\n<pre><code>namespace N\n{\n   void f( int[10] );\n   void f( int[10] );\n   void f( int[] );\n   void f( int[] );\n   void f( int * );\n   void f( int * );\n}\n</code></pre>\n<p>All these declarations declare the same (and one) function f.</p>\n<p>In the quote you cited word <strong>first</strong> means that a friend function was first declared inside a class definition. There is no function declaration before the declaration inside the class definition.</p>\n<p>As for the comment</p>\n<blockquote>\n<p id=\"so_23082525_23082900_0\">// Assume f and g have not yet been defined</p>\n</blockquote>\n<p>then it means that the functions were not declared yet. That is their first declarations are inside the class definition.</p>\n<p>This part of the quote</p>\n<blockquote>\n<p id=\"so_23082525_23082900_1\">Every name first declared in a namespace is a member of that\n  namespace. If a friend declaration in a nonlocal class first declares\n  a class or function the friend class or function is a member of the\n  innermost enclosing namespace</p>\n</blockquote>\n<p>is very clear, Declaring a function as a friend function of a class inside the class definition means its declaration inside the enclosing namespace. However the function is not visible until it will be declared also outside the class definition.</p>\n<p>To demonstrate the idea consider the following example.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    friend void f();\n};\nvoid g() { f(); }\nvoid f() { std::cout &lt;&lt; \"It is me!\" &lt;&lt; std::endl; }\n\nint main() {\n    return 0;\n}\n</code></pre>\n<p>For this code the compiler issues error</p>\n<blockquote>\n<p id=\"so_23082525_23082900_2\">prog.cpp: In function \u2018void g()\u2019: prog.cpp:9:14: error: \u2018f\u2019 was not\n  declared in this scope  void g() { f(); }</p>\n</blockquote>\n<p>Though function f was declared inside class A definition. And if there is no any declaration of the function before the class definition the function is considered as a member of the same namespace where class A is defined (more precisely it would be better to say where the class is declared because the class can be defined in some enclosing namespace). </p>\n<p>However if you add one more declaration of f then the code will be compiled.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    friend void f();\n};\n\nvoid f();\nvoid g() { f(); }\nvoid f() { std::cout &lt;&lt; \"It is me!\" &lt;&lt; std::endl; }\n\nint main() {\n    return 0;\n}\n</code></pre>\n<p>And consider a third example</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f();\nnamespace N {\n   struct A\n   {\n      friend void f();\n   };\n   void g() { f(); }\n}\nvoid f() { std::cout &lt;&lt; \"It is me!\" &lt;&lt; std::endl; }\nint main() {\n    return 0;\n}\n</code></pre>\n<p>Here function f was first declared before namespace N and before the class definition. So the friend declaration of the function f will not be visible in function g() in that namespace until the friend function will be redeclared outside the class. So function g will call the global function f.</p>\n<p>And at last consider a more interesting example</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace N {\n   class A;\n}\nclass N::A {\n    friend void f();\n    int x = 10;\n};\n\nnamespace N {\n   //void f(); // if to uncomment the line the code will be compiled \n               // otherwise f will not be found\n   void g() { f(); }\n   void f() { A a; std::cout &lt;&lt; \"a.x = \" &lt;&lt; a.x &lt;&lt; std::endl; }\n}\nint main() {\n    return 0;\n}\n</code></pre>\n<p>Here though the definition of class A is in the global namespace nevertheless function f is declared in namespace N that is where the class was first declared.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-04-15T14:18:38.363", "Id": "23082900", "Score": "3", "CreationDate": "2014-04-15T11:53:07.353", "LastActivityDate": "2014-04-15T14:18:38.363"}, "23085521": {"ParentId": "23082525", "CommentCount": "3", "Body": "<p>A hopefully shorter more concise answer than the complete one from Vlad:</p>\n<p>An entity can be declared multiple times, your premise is wrong. In the first sentence <strong>first</strong> is important as these two are valid declarations for a function <code>f</code> in namespace <code>N</code>:</p>\n<pre><code>namespace N { void f(); }\nvoid N::f() { ... }        // A definition is *also* a declaration\n</code></pre>\n<p>At this point the need for <strong>first</strong> in the first sentence is apparent, <code>f</code> is a member of the <code>N</code> namespace (<em>first</em> declaration), not the global namespace.</p>\n<p>In the case of a friend declaration the <strong>first</strong> is important for a different reason, as if the friend declaration is the <em>first</em> declaration, the name is not visible for regular lookup:</p>\n<pre><code>//[1]\nclass Y {};                       // Some type\nclass X {\n   X(Y);                          // allow implicit conversions, \n                                  //    for exposition purposes\n   friend X operator+(X, X) {...} // *first* declaration of this operator\n};                                //    and also the definition\nvoid f() {\n   Y a, b;\n   a + b;                         // error, no operator+ takes two Y\n   X c; \n   c + b;                         // OK, ADL can find it\n}\n</code></pre>\n<p>If the friend declaration was not the first declaration, i.e. if [1] gets replaced with a previous declaration:</p>\n<pre><code>class X;\nX operator+(X,X);\n</code></pre>\n<p>With all the rest of the code being the same, the above code would compile and call <code>operator+(X,X)</code> converting <code>a</code> and <code>b</code> to <code>X</code>.</p>\n<p>The last question you had was on the <em>Assume <code>f</code> and <code>g</code> have not been defined</em>, which I believe should read <strong>declared</strong>, not <em>defined</em>. The importance of this statement is that if the function have been <em>declared</em> before hand, the comment <code>// A::f, A::g and A::h are not visible here</code> becomes false, as the previous declaration makes those functions visible.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "23085521", "Score": "4", "CreationDate": "2014-04-15T13:42:45.500", "LastActivityDate": "2014-04-15T13:42:45.500"}, "23107299": {"ParentId": "23082525", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Forgive me for omitting the examples, but I want to keep this short and sweet.</p>\n<p>The purpose of the word <em>first</em> is to emphasize that the friend or namespace-scope declaration is the only way the function has been declared at that point. The paragraph is intending to discuss declarations that create an entity, as opposed to later <em>matching declarations</em>.</p>\n<p>Perhaps <em>initially</em> would be a better word than <em>first</em>.</p>\n<blockquote>\n<p id=\"so_23082525_23107299_0\">The comment <code>::f2&lt;&gt;(int) is a friend</code> is incorrect. Not only there is no definition of the template function <code>f2(T)</code> in namespace <code>A</code>, but more important, the declaration <code>template &lt;class T&gt; void f2(T);</code> must be inside <code>A</code>, otherwise the function <code>f2&lt;&gt;(int)</code> will not be a friend of the class <code>A::X::Y</code>. </p>\n</blockquote>\n<p><code>::f2</code> is a different thing than <code>A::f2</code>. The intent of the example is to emphasize this. <em>Because</em> there is a template <code>::f2</code>, not in <code>A</code>, which matches the <code>friend void f2&lt;&gt;(int)</code> declaration, that template is the one befriended. Only because there is no visible function <code>f</code> matching the declaration <code>friend void f(X);</code> does it by default create a new function in <code>namespace A</code>.</p>\n<p>The rule is quite intricate, however. The last sentence before the note means that a function <code>::f</code> would still not match <code>friend void f(X);</code> because the language prefers to add something to the enclosing namespace, and only looks at outer namespaces as a last resort. So it goes like this:</p>\n<ol>\n<li>If the enclosing namespace contains a declaration matching the <code>friend</code>, friend that thing.</li>\n<li>Otherwise, if the <code>friend</code> declaration contains sufficient information to declare something in the enclosing namespace, create the thing but don't let the declaration be found by qualified or unqualified lookup.</li>\n<li>Otherwise, look for a matching declaration in outer namespaces.</li>\n<li>Otherwise, fail.</li>\n</ol>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2014-04-16T14:46:21.590", "Id": "23107299", "Score": "1", "CreationDate": "2014-04-16T10:50:03.203", "LastActivityDate": "2014-04-16T14:46:21.590"}, "23082525": {"CommentCount": "10", "ViewCount": "528", "PostTypeId": "1", "LastEditorUserId": "210114", "CreationDate": "2014-04-15T11:36:43.767", "LastActivityDate": "2014-05-14T07:54:22.677", "Title": "There are some details I didn't understand in \u00a77.3.1.2/3 in the C++11 Standard", "FavoriteCount": "3", "LastEditDate": "2014-05-14T07:54:22.677", "Id": "23082525", "Score": "10", "Body": "<p>\u00a77.3.1.2/3 in the C++11 Standard (emphasis are mine):</p>\n<blockquote>\n<blockquote>\n<p id=\"so_23082525_23082525_1\">Every name <strong>first</strong> declared in a namespace is a member of that\n    namespace. If a friend declaration in a nonlocal class <strong>first</strong> declares\n    a class or function the friend class or function is a member of the\n    innermost enclosing namespace. The name of the friend is not found by\n    unqualified lookup (3.4.1) or by qualified lookup (3.4.3) until a\n    matching declaration is provided in that namespace scope (either\n    before or after the class definition granting friendship). If a friend\n    function is called, its name may be found by the name lookup that\n    considers functions from namespaces and classes associated with the\n    types of the function arguments (3.4.2). If the name in a friend\n    declaration is neither qualified nor a template-id and the declaration\n    is a function or an elaborated-type-specifier, the lookup to determine\n    whether the entity has been previously declared shall not consider any\n    scopes outside the innermost enclosing namespace. [ Note: The other\n    forms of friend declarations cannot declare a new member of the\n    innermost enclosing namespace and thus follow the usual lookup rules.</p>\n</blockquote>\n</blockquote>\n<p><strong>Example:</strong></p>\n<blockquote id=\"so_23082525_23082525_2\">\n<pre><code>// Assume f and g have not yet been defined.\nvoid h(int);\ntemplate &lt;class T&gt; void f2(T);\nnamespace A {\n    class X {\n        friend void f(X); // A::f(X) is a friend\n        class Y {\n            friend void g(); // A::g is a friend\n            friend void h(int); // A::h is a friend\n            // ::h not considered\n           friend void f2&lt;&gt;(int); // ::f2&lt;&gt;(int) is a friend\n        };\n    };\n    // A::f, A::g and A::h are not visible here\n    X x;\n    void g() { f(x); } // definition of A::g\n    void f(X) { /* ... */} // definition of A::f\n    void h(int) { /* ... */ } // definition of A::h\n    // A::f, A::g and A::h are visible here and known to be friends\n}\nusing A::x;\nvoid h() {\n    A::f(x);\n    A::X::f(x); // error: f is not a member of A::X\n    A::X::Y::g(); // error: g is not a member of A::X::Y\n}\n</code></pre>\n</blockquote>\n<p>Unless I'm missing something, I don't understand the need for the words <strong>first</strong> above. As far as I can see, you can't have more than one declaration of any entity in a namespace, nor more than one declaration of a friend function in a class.</p>\n<p>Also, what is the relevance of the comment \"Assume f and g have yet not been defined\" in the Example? It really doesn't matter if these functions are declared before the definition of the namespace A. They'll necessarily belong to the global namespace and they'll have nothing to do with the functions declared inside the namespace A.</p>\n<p><strong>Edit:</strong></p>\n<p>The fact that one can have repeated declarations of the same function, or a declaration and a definition of a function in a namespace, doesn't invalidate my observation that the use of the words <strong>first</strong> in \u00a77.3.1.2/3 are not necessary.</p>\n<p><strong>Edit1</strong></p>\n<p>I've just found another error. The comment <code>::f2&lt;&gt;(int) is a friend</code> is incorrect. Not only there is no definition of the template function <code>f2(T)</code> in namespace A, but more important, the declaration <code>template &lt;class T&gt; void f2(T);</code> must be <strong>inside</strong> A, otherwise the function <code>f2&lt;&gt;(int)</code> will not be a friend of the class <code>A::X::Y</code>. </p>\n", "Tags": "<c++><c++11><namespaces><language-lawyer><friend>", "OwnerUserId": "2548699", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_23082525_23082525_1": {"section_id": 5485, "quality": 0.9029126213592233, "length": 93}, "so_23082525_23082525_0": {"section_id": 5485, "quality": 0.9029126213592233, "length": 93}, "so_23082525_23082900_1": {"section_id": 5485, "quality": 1.0, "length": 22}}, "n3337": {"so_23082525_23082525_1": {"section_id": 5271, "quality": 0.941747572815534, "length": 97}, "so_23082525_23082525_0": {"section_id": 5271, "quality": 0.941747572815534, "length": 97}, "so_23082525_23082900_1": {"section_id": 5271, "quality": 1.0, "length": 22}}, "n4659": {"so_23082525_23082525_1": {"section_id": 6920, "quality": 0.8349514563106796, "length": 86}, "so_23082525_23082525_0": {"section_id": 6920, "quality": 0.8349514563106796, "length": 86}, "so_23082525_23082900_1": {"section_id": 6920, "quality": 0.6818181818181818, "length": 15}}}});