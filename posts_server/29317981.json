post_cb({"29317981": {"CommentCount": "1", "ViewCount": "293", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-03-28T13:56:11.820", "LastActivityDate": "2015-03-28T14:35:16.437", "Title": "Swapping `std::aligned_storage` instances containing non-trivially-copyable types - undefined behavior?", "AcceptedAnswerId": "29318354", "LastEditDate": "2017-05-23T12:12:57.737", "Id": "29317981", "Score": "1", "Body": "<p><a href=\"http://ideone.com/zgQz1P\" rel=\"nofollow noreferrer\">ideone link</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;   \nusing namespace std;\n\n// Non-trivially-copyable type.\nstruct NTC\n{\n    int x;      \n    NTC(int mX) : x(mX) { }    \n    ~NTC() { cout &lt;&lt; \"boop.\" &lt;&lt; x &lt;&lt; endl; }\n};\n\nint main() \n{\n    using AS = aligned_storage_t&lt;sizeof(NTC), alignof(NTC)&gt;;\n\n    // Create two `std::aligned_storage` instances\n    // and \"fill\" them with two \"placement-new-constructed\" \n    // `NTC` instances.\n    AS as1, as2;        \n    new (&amp;as1) NTC{2};\n    new (&amp;as2) NTC{5};\n\n    // Swap the `aligned_storages`, not their contents.\n    std::swap(as1, as2);\n\n    // Explicitly call `~NTC()` on the contents of the\n    // aligned storage instances.\n    NTC&amp; in1{*static_cast&lt;NTC*&gt;(static_cast&lt;void*&gt;(&amp;as1))};\n    NTC&amp; in2{*static_cast&lt;NTC*&gt;(static_cast&lt;void*&gt;(&amp;as2))};     \n    in1.~NTC();\n    in2.~NTC();\n\n    return 0;\n}\n</code></pre>\n<hr>\n<p><strong>Is the above code undefined behavior?</strong> </p>\n<p>Here's what I think that's happening:</p>\n<ul>\n<li><code>NTC</code> is a non-trivially-copyable type. </li>\n<li>I'm creating two memory locations suitable to store <code>NTC</code> objects (<code>std::aligned_storage</code>).</li>\n<li>I construct two <code>NTC</code> instances directly into the memory locations.</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"nofollow noreferrer\"><code>std::aligned_storage</code> instances are PODTypes</a>. \n\n<blockquote>\n<p id=\"so_29317981_29317981_0\">This means the type is compatible with the types used in the C programming language, can be manipulated using C library functions: it can be created with std::malloc, it can be copied with std::memmove, etc, and can be exchanged with C libraries directly, in its binary form.</p>\n</blockquote></li>\n<li>Since the aligned storage instances are POD types, I should be allowed to move/swap/copy them around.</li>\n<li>Swapping the aligned storage instances means <strong>take all the bytes from aligned storage A and swap them with all the bytes from aligned storage B</strong>.</li>\n<li>Doing so will not call the destructor/copy-constructor of the internally stored <code>NTC</code> objects.</li>\n</ul>\n<p>Are any of my points <strong>incorrect</strong>? If <strong>undefined behavior</strong> does occur, in what part of the program does it occur? And why?</p>\n<hr>\n<p>New <em>potentially-correct/incorrect</em> information (<a href=\"https://stackoverflow.com/posts/29318269\">gathered from a deleted answer</a>):</p>\n<ul>\n<li><code>std::aligned_storage</code> is pretty much just a typedef for a C-style array.</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/swap\" rel=\"nofollow noreferrer\"><code>std::swap</code> has an overload for C-style arrays since C++11</a>.</li>\n<li>That overload <a href=\"http://en.cppreference.com/w/cpp/algorithm/swap_ranges\" rel=\"nofollow noreferrer\">calls <code>std::swap_ranges</code></a>, which swaps every single element in the array.</li>\n<li>Therefore, swapping two <code>std::aligned_storage</code> instances should swap their contents, element by element.</li>\n</ul>\n<p><strong>Am I making any mistake in these new assumptions?</strong></p>\n</hr></hr>", "Tags": "<c++><language-lawyer><swap><undefined-behavior><c++14>", "OwnerUserId": "598696", "AnswerCount": "1"}, "29318354": {"ParentId": "29317981", "CommentCount": "6", "Body": "<p>Directly accessing the bytes of a buffer after a non-trivially-copyable type has been placed in it is a very bad idea, but not undefined just yet.</p>\n<p>Attempting to access the buffer after swapping as a <code>NTC</code> violates the aliasing rules, [basic.lval]p10:</p>\n<blockquote>\n<p id=\"so_29317981_29318354_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<p id=\"so_29317981_29318354_1\">(10.1) -- the dynamic type of the object,</p>\n<p id=\"so_29317981_29318354_2\">[....]</p>\n</blockquote>\n<p>Copying a trivially copyable type through <code>memcpy</code> or equivalent is implied to preserve the dynamic type. No such implication is made for non-trivially copyable types, so after swapping, you no longer have any <code>NTC</code> objects to access.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "29318354", "Score": "5", "CreationDate": "2015-03-28T14:35:11.537", "LastActivityDate": "2015-03-28T14:35:11.537"}, "bq_ids": {"n4140": {"so_29317981_29318354_0": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_29317981_29318354_0": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_29317981_29318354_0": {"section_id": 8748, "quality": 1.0, "length": 14}}}});