post_cb({"21111284": {"Id": "21111284", "PostTypeId": "2", "Body": "<p>In practice it is safe, theoretically - no.</p>\n<p>C++ standard doesn't force to implement <code>string</code> as a sequential character array like it does for the <code>vector</code>. I'm not aware of any implementation of <code>string</code> where it is not safe, but theoretically there is no guarantee.</p>\n<p><a href=\"http://herbsutter.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/\" rel=\"nofollow\">http://herbsutter.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/</a></p>\n", "LastEditorUserId": "940912", "LastActivityDate": "2014-01-14T10:37:43.177", "Score": "0", "CreationDate": "2014-01-14T10:32:42.967", "ParentId": "21110558", "CommentCount": "3", "LastEditDate": "2014-01-14T10:37:43.177", "OwnerUserId": "940912"}, "21110850": {"Id": "21110850", "PostTypeId": "2", "Body": "<p>The relevant section in the standard is \u00a721.4.5:</p>\n<blockquote>\n<p id=\"so_21110558_21110850_0\"><code>const_reference operator[](size_type pos) const noexcept;</code></p>\n<p id=\"so_21110558_21110850_1\"><code>reference operator[](size_type pos) noexcept;</code></p>\n<p id=\"so_21110558_21110850_2\">[...]</p>\n<p id=\"so_21110558_21110850_3\">Returns: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an\n  object of type <code>T</code> with value <code>charT()</code>; <strong>the referenced value shall not be modified</strong>.</p>\n</blockquote>\n<p>If I understand this correctly, it means that as long as the index given to <code>operator[]</code> is smaller than the string's <code>size</code>, one is allowed to modify the value. If however, the index is equal to <code>size</code> and thus we obtain the <code>\\0</code> terminating the string, we must not write to this value.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator_at\" rel=\"nofollow\">Cppreference</a> uses a slightly different wording here:</p>\n<blockquote>\n<p id=\"so_21110558_21110850_4\">If pos == size(), a reference to the character with value <code>CharT()</code> (the null character) is returned.\n  For the first (non-const) version,the behavior is undefined if this character is modified. </p>\n</blockquote>\n<p>I read this such that 'this character' here only refers to the default constructed <code>CharT</code>, and not to the reference returned in the other case. But I admit that the wording is a bit confusing here.</p>\n", "LastEditorUserId": "577603", "LastActivityDate": "2014-01-14T10:18:38.940", "Score": "0", "CreationDate": "2014-01-14T10:13:11.120", "ParentId": "21110558", "CommentCount": "2", "LastEditDate": "2014-01-14T10:18:38.940", "OwnerUserId": "577603"}, "21111856": {"Id": "21111856", "PostTypeId": "2", "Body": "<p>Yes, it's safe.  No, it's not explicitly allowed by the standard. <br>\nAccording to my copy of the standard draft from like half a year ago, they do assure that <code>data()</code> points at a contiguous array, and that that array be the same as what you receive from operator[]:</br></p>\n<pre><code>21.4.7.1 basic_string accessors [string.accessors]\nconst charT* c_str() const noexcept;\nconst charT* data() const noexcept;\nReturns: A pointer p such that p + i == &amp;operator[](i) for each i in [0,size()].\n</code></pre>\n<p>From this one can conclude that operator[] returns a reference to some place within that contiguous array.  They also allow the returned reference from (non-const) operator[] be modified.  <br>\nHaving a non-const reference to one member of an array I dare to say that we can modify the entire array.</br></p>\n", "LastActivityDate": "2014-01-14T10:59:36.233", "CommentCount": "0", "CreationDate": "2014-01-14T10:59:36.233", "ParentId": "21110558", "Score": "2", "OwnerUserId": "2961244"}, "21110558": {"ViewCount": "78", "Body": "<p>If I have the following code:</p>\n<pre><code>std::string hello = \"hello world\"; \nchar* internalBuffer = &amp;hello[0];\n</code></pre>\n<p>Is it then safe to write to internalBuffer  up to hello.length()? Or is this UB/implemention defined? Obviously I can write tests and see that this works, but it doesn't answer my question.</p>\n", "AcceptedAnswerId": "21111856", "Title": "Is it safe to write to a std::strings buffer directly?", "CreationDate": "2014-01-14T09:59:34.950", "Id": "21110558", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-01-14T10:59:36.233", "Score": "1", "OwnerUserId": "1124744", "Tags": "<c++11><stdstring>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_21110558_21110850_3": {"length": 9, "quality": 0.6428571428571429, "section_id": 1617}}, "n3337": {"so_21110558_21110850_3": {"length": 9, "quality": 0.6428571428571429, "section_id": 1613}}, "n4659": {"so_21110558_21110850_3": {"length": 10, "quality": 0.7142857142857143, "section_id": 1770}}}});