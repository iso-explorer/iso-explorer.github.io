post_cb({"bq_ids": {"n4140": {"so_26341979_26342143_0": {"length": 49, "quality": 0.98, "section_id": 7047}, "so_26341979_26342136_0": {"length": 15, "quality": 1.0, "section_id": 7079}}, "n3337": {"so_26341979_26342143_0": {"length": 49, "quality": 0.98, "section_id": 6792}, "so_26341979_26342136_0": {"length": 15, "quality": 1.0, "section_id": 6823}}, "n4659": {"so_26341979_26342143_0": {"length": 49, "quality": 0.98, "section_id": 8544}, "so_26341979_26342136_0": {"length": 15, "quality": 1.0, "section_id": 8580}}}, "26341979": {"ViewCount": "1169", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct test\n{\n    test(){cout&lt;&lt;\"class\"&lt;&lt;endl;}\n};\nvoid test(){cout&lt;&lt;\"function\"&lt;&lt;endl;}\n\nint main()\n{\n    test();\n    return 0;\n}\n</code></pre>\n<p>Output: </p>\n<pre><code>function  \n</code></pre>\n<p>(VS2013 ang gcc 4.8.1)</p>\n<p>Why function is selected? Isn't it ambiguity?</p>\n", "AcceptedAnswerId": "26342143", "Title": "What happens when a class and a function have the same name?", "CreationDate": "2014-10-13T14:06:25.640", "Id": "26341979", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-13T14:51:55.717", "LastEditorUserId": "1603275", "LastActivityDate": "2014-10-13T17:14:30.093", "Score": "18", "OwnerUserId": "3514538", "Tags": "<c++><ambiguity><ambiguous-call>", "AnswerCount": "3"}, "26342136": {"Id": "26342136", "PostTypeId": "2", "Body": "<p>From N3485 \u00a73.3.10 [basic.scope.hiding]/2:</p>\n<blockquote>\n<p id=\"so_26341979_26342136_0\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member,\n  function, or enumerator declared in the same scope.</p>\n</blockquote>\n<p>Therefore, the function takes precedence over the class.</p>\n<p>As mentioned in the <a href=\"https://stackoverflow.com/questions/26341979/class-and-function-with-the-same-name/26342136#comment41346309_26341979\">comments</a>, the class is still accessible via the <code>class</code> or <code>struct</code> keyword. If the class took precedence, the function would be unreachable.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-13T14:15:35.007", "Score": "9", "CreationDate": "2014-10-13T14:15:35.007", "ParentId": "26341979", "CommentCount": "0", "OwnerUserId": "962089", "LastEditDate": "2017-05-23T10:29:27.863"}, "26345342": {"Id": "26345342", "PostTypeId": "2", "Body": "<p>I'm not certain either of the previous responses are the \"why\" for your particular instance.</p>\n<p>Don't get me wrong; They are true and accurate.</p>\n<p>I just think it's simpler.</p>\n<p>In your example, you never instantiate the struct. </p>\n<p>In other words, you declared it, but you never used it.</p>\n<p>Since you never referenced it, it is never called.</p>\n<p>Name precedence and such don't really apply here, since you never instantiated the struct.</p>\n<p>Hope this helps,</p>\n<p>-john</p>\n", "LastActivityDate": "2014-10-13T17:14:30.093", "CommentCount": "2", "CreationDate": "2014-10-13T17:14:30.093", "ParentId": "26341979", "Score": "-3", "OwnerUserId": "4138450"}, "26342143": {"Id": "26342143", "PostTypeId": "2", "Body": "<p>This is called <strong>name hiding</strong> and described in</p>\n<h3>3.3 Scope [basic.scope]</h3>\n<h3>3.3.1 Declarative regions and scopes [basic.scope.declarative]</h3>\n<blockquote>\n<p id=\"so_26341979_26342143_0\">4) Given a set of declarations in a single declarative region, each of\n  which specifies the same unqualified name,<br/> \u2014 they shall all refer to\n  the same entity, or all refer to functions and function templates; or\n  <br/>\u2014 exactly one declaration shall declare a class name or enumeration\n  name that is not a typedef name and the other declarations shall all\n  refer to the same variable or enumerator, or all refer to functions\n  and function templates; <strong>in this case the class name or enumeration\n  name is hidden</strong> (3.3.10). [...]</p>\n</blockquote>\n<p>emphasis mine.</p>\n<p>Note that changing the order of declaration doesn't affect the outcome:</p>\n<pre><code>void test(){cout&lt;&lt;\"function\"&lt;&lt;endl;}\n\nstruct test\n{\n    test(){cout&lt;&lt;\"class\"&lt;&lt;endl;}\n};\n\nint main()\n{\n    test();\n    return 0;\n}\n</code></pre>\n<p>still prints out <code>function</code>.</p>\n<p>In case it isn't obvious, <strong>don't do this</strong> :)</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2014-10-13T15:17:18.813", "Score": "18", "CreationDate": "2014-10-13T14:15:44.587", "ParentId": "26341979", "CommentCount": "5", "OwnerUserId": "673730", "LastEditDate": "2014-10-13T15:17:18.813"}});