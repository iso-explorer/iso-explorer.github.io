post_cb({"39016352": {"CommentCount": "1", "ViewCount": "56", "PostTypeId": "1", "LastEditorUserId": "1053968", "CreationDate": "2016-08-18T10:52:42.443", "LastActivityDate": "2016-08-18T13:43:44.747", "Title": "Standalone ASIO Asynchronous Not Connecting", "LastEditDate": "2016-08-18T13:18:06.700", "Id": "39016352", "Score": "0", "Body": "<p>ASIO seems like the best async cross-platform networking library for my project. However, I'm having trouble getting it to actually connect.</p>\n<p>First off, I'm not using Boost. I'm compiling this on Windows for the time being, so I had to manually add definitions to inform ASIO that I'm using a C++11-compliant compiler.</p>\n<p>Source.cpp</p>\n<pre><code>#define TCPCLIENT_DEBUG\n#include \"TCPClient.hpp\"\n#include &lt;iostream&gt;\n\n#define PORT \"1234\"\n#define HOST \"127.0.0.1\"\n\nint main() {\n    DEBUG(\"Starting program...\\n\");\n    namespace ip = asio::ip;\n\n    asio::io_service io;\n    ip::tcp::resolver::query query(HOST, PORT);\n    ip::tcp::resolver resolver(io);\n    decltype(resolver)::iterator ep_iter = resolver.resolve(query);\n\n    TCPClient client(io, ep_iter);\n\n    try {\n        std::cin.get();\n    }\n    catch (const std::exception &amp;e) { // mainly to catch Ctrl+C\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>TCPClient.hpp</p>\n<pre><code>#ifndef TCPCLIENT_HPP\n#define TCPCLIENT_HPP\n\n#include &lt;functional&gt;\n\n#if defined(_DEBUG) || defined(TCPCLIENT_DEBUG)\n#include &lt;iostream&gt;\n#define DEBUG(dbg_msg) std::cerr &lt;&lt; dbg_msg\n#else\n#define DEBUG(dbg_msg)\n#endif\n\n#define ASIO_STANDALONE\n#define ASIO_HAS_CSTDINT\n#define ASIO_HAS_STD_ARRAY\n#define ASIO_HAS_STD_ADDRESSOF\n#define ASIO_HAS_STD_SHARED_PTR\n#define ASIO_HAS_STD_TYPE_TRAITS\n\n#include &lt;asio.hpp&gt;\n#ifndef BUFFER_SIZE\n#define BUFFER_SIZE 1024\n#endif\n\nclass TCPClient {\npublic:\n    TCPClient(asio::io_service&amp; io, asio::ip::tcp::resolver::iterator endpoint_iter);\n    void on_connect(const asio::error_code&amp; err);\n\nprivate:\n    asio::io_service&amp; m_io;                         // store the io service reference\n    asio::ip::tcp::socket m_sock;                   // object's socket\n    static const size_t bufSize{ BUFFER_SIZE };     // default buffer size\n    char m_buffer[bufSize];                         // store the received data in a buffer\n};\n\n#endif//TCPCLIENT_HPP\n</code></pre>\n<p>TCPClient.cpp</p>\n<pre><code>#include \"TCPClient.hpp\"\n\nTCPClient::TCPClient(asio::io_service&amp; io, asio::ip::tcp::resolver::iterator endpoint_iter) : m_io{ io }, m_sock(io) {\n    asio::ip::tcp::endpoint endpoint = *endpoint_iter;\n    asio::error_code ec;\n\n    m_sock.async_connect(\n        endpoint,\n        std::bind(\n            &amp;TCPClient::on_connect,\n            this,\n            std::placeholders::_1\n        )\n    );\n}\n\nvoid TCPClient::on_connect(const asio::error_code&amp; err) {\n    DEBUG(\"Connected successfully!\\n\");\n}\n</code></pre>\n<p>It seems to me that the <code>on_connect</code> is never being called. It only prints \"Starting program...\".</p>\n<p>Using netcat, I can spawn a listener that sees the connection successfully go through.</p>\n<p><a href=\"https://i.stack.imgur.com/twbDE.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/twbDE.png\"/></a></p>\n<p>What is obviously wrong with my code? I'm only working on the connection function for right now.</p>\n", "Tags": "<c++11><boost-asio>", "OwnerUserId": "3124409", "AnswerCount": "2"}, "39019656": {"ParentId": "39016352", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-08-18T13:35:09.783", "Score": "2", "LastEditorUserId": "2315602", "LastEditDate": "2016-08-18T13:43:44.747", "Id": "39019656", "OwnerUserId": "2315602", "Body": "<p>By calling <code>async_connect</code>, you only register an asynchronous operation. You should explicitly call <code>io_service.run()</code> somewhere, - probably, in <code>main</code> instead of <code>std::cin.get()</code>, - to get your asynchronous operations really executed and callbacks called.</p>\n<p>Under the hood, asio uses <code>epoll</code> or something similar: it registers events it is interested in (a socket connection in your case) and then waits for the events to happen. <code>io_service.run()</code> is precisely the place where waiting is done.</p>\n<p>I'd advise you to look at some boost::asio asyncronous tutorials, like <a href=\"http://www.boost.org/doc/libs/1_61_0/doc/html/boost_asio/tutorial/tuttimer2.html\" rel=\"nofollow\">this one</a>.</p>\n", "LastActivityDate": "2016-08-18T13:43:44.747"}, "bq_ids": {"n4140": {"so_39016352_39019826_0": {"section_id": 577, "quality": 0.625, "length": 5}}, "n3337": {"so_39016352_39019826_0": {"section_id": 567, "quality": 0.625, "length": 5}}, "n4659": {"so_39016352_39019826_0": {"section_id": 600, "quality": 0.625, "length": 5}}}, "39019826": {"ParentId": "39016352", "CommentCount": "0", "CreationDate": "2016-08-18T13:43:31.383", "OwnerUserId": "1053968", "PostTypeId": "2", "Id": "39019826", "Score": "2", "Body": "<p>Handlers are only executed within threads that are currently running the <code>io_service</code>.  As the <code>io_service</code> is never ran, the connect handler is never executed.  To resolve this, run the <code>io_service</code> by calling <a href=\"http://think-async.com/Asio/asio-1.10.6/doc/asio/reference/io_service/run/overload1.html\" rel=\"nofollow\"><code>io_service::run()</code></a>:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>TCPClient client(io, ep_iter);\n\ntry {\n  io.run();\n}\ncatch (const std::exception &amp;e) {\n  std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n}\n</code></pre>\n<hr>\n<p>The <a href=\"http://www.boost.org/doc/libs/1_61_0/doc/html/boost_asio/tutorial/tuttimer2.html\" rel=\"nofollow\">Using a timer asynchronously Tutorial</a> notes the importance of running the <code>io_service</code>:</p>\n<blockquote>\n<p id=\"so_39016352_39019826_0\">Finally, we must call the <code>io_service::run()</code> member function on the <code>io_service</code> object.</p>\n<p id=\"so_39016352_39019826_1\">The asio library provides a guarantee that callback handlers will only be called from threads that are currently calling <code>io_service::run()</code>. Therefore unless the <code>io_service::run()</code> function is called the callback for the asynchronous wait completion will never be invoked.</p>\n<p id=\"so_39016352_39019826_2\">The <code>io_service::run()</code> function will also continue to run while there is still \"work\" to do. In this example, the work is the asynchronous wait on the timer, so the call will not return until the timer has expired and the callback has completed.</p>\n<p id=\"so_39016352_39019826_3\">It is important to remember to give the <code>io_service</code> some work to do before calling <code>io_service::run()</code>. For example, if we had omitted the above call to <code>deadline_timer::async_wait()</code>, the <code>io_service</code> would not have had any work to do, and consequently <code>io_service::run()</code> would have returned immediately.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2016-08-18T13:43:31.383"}});