post_cb({"28696670": {"ParentId": "28696522", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-02-24T13:08:28.927", "Score": "5", "LastEditorUserId": "1782465", "LastEditDate": "2015-02-24T13:54:45.207", "Id": "28696670", "OwnerUserId": "1782465", "Body": "<p>The type of <code>nullptr</code> is defined in namespace <code>::std</code>, so the correct qualification is <code>::std::nullptr_t</code>. Of course, this means you normally spell it <code>std::nullptr_t</code> in practice.</p>\n<p>Quoting C++11:</p>\n<p>2.14.7/1:</p>\n<blockquote>\n<p id=\"so_28696522_28696670_0\">The pointer literal is the keyword <code>nullptr</code>. It is a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>18.2/9:</p>\n<blockquote>\n<p id=\"so_28696522_28696670_1\"><code>nullptr_t</code> is defined as follows:</p>\n<pre><code>namespace std {\n  typedef decltype(nullptr) nullptr_t;\n}\n</code></pre>\n<p id=\"so_28696522_28696670_2\">The type for which <code>nullptr_t</code> is a synonym has the characteristics described in 3.9.1 and 4.10. [ <em>Note:</em>\n  Although <code>nullptr</code>\u2019s address cannot be taken, the address of another <code>nullptr_t</code> object that is an lvalue can\n  be taken. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p><code>&lt;stddef.h&gt;</code> also enters into the picture. 18.2 talks about <code>&lt;cstddef&gt;</code>, so that's the C++ header where <code>std::nullptr_t</code> is defined. Per D.5/2:</p>\n<blockquote>\n<p id=\"so_28696522_28696670_3\">Every C header, each of which has a name of the form <code>name.h</code>, behaves as if each name placed in the standard\n  library namespace by the corresponding <code>cname</code> header is placed within the global namespace scope.</p>\n</blockquote>\n<p>Which means that including <code>&lt;stddef.h&gt;</code> gives you access to <code>::nullptr_t</code>. But since that's supposed to be a C header, I would advise against relying on this in C++ code (even if it's formally valid).</p>\n", "LastActivityDate": "2015-02-24T13:54:45.207"}, "bq_ids": {"n4140": {"so_28696522_28696670_2": {"section_id": 6711, "quality": 0.7391304347826086, "length": 17}, "so_28696522_28696670_0": {"section_id": 5366, "quality": 0.875, "length": 7}, "so_28696522_28696670_3": {"section_id": 4907, "quality": 0.95, "length": 19}}, "n3337": {"so_28696522_28696670_2": {"section_id": 6466, "quality": 0.7391304347826086, "length": 17}, "so_28696522_28696670_0": {"section_id": 5162, "quality": 0.875, "length": 7}, "so_28696522_28696670_3": {"section_id": 4702, "quality": 0.95, "length": 19}}, "n4659": {"so_28696522_28696670_2": {"section_id": 8179, "quality": 0.7391304347826086, "length": 17}, "so_28696522_28696670_0": {"section_id": 6791, "quality": 0.875, "length": 7}, "so_28696522_28696670_3": {"section_id": 6316, "quality": 0.95, "length": 19}}}, "28696522": {"CommentCount": "19", "AcceptedAnswerId": "28696670", "PostTypeId": "1", "LastEditorUserId": "3449781", "CreationDate": "2015-02-24T13:01:10.840", "LastActivityDate": "2015-02-24T14:44:22.850", "LastEditDate": "2015-02-24T14:44:22.850", "ViewCount": "586", "FavoriteCount": "2", "Title": "Where does nullptr_t reside?", "Id": "28696522", "Score": "6", "Body": "<p>A bit of prehistory.</p>\n<p>I've been writing a game engine for quite some time. It's divided into several static libraries, like \"utils\", \"rsbin\" (resource system), \"window\", which are then linked into a single executable.</p>\n<p>It is a crossplatform engine, being compiled for Windows and for Android.\nUnder Windows, I compile it with MinGW. Under Android, with CCTools, which is an interface to native gcc.</p>\n<p>One of the base classes is <code>utils::RefObject</code>, which represents a concept similar to Windows's IUnknown: it provides a reference counter to determine its lifetime and a method for querying a specific interface from base class pointer. There's also <code>template&lt; typename T &gt; utils::Ref</code>, designed specifically for this kind of objects. It holds an <code>std::atomic&lt; utils::RefObject* &gt;</code> and automatically updates its object's refcount upon construction, assignment and destruction, analogously to <code>std::shared_ptr</code>. It also allows to implicitly convert RefObjects of different types through their querying methods. Though, it's inefficient to query an object for its own type, so, <code>utils::Ref</code> overloads most of its operators, e. g. there's specific <code>utils::Ref&lt; T &gt;::Ref( T* ptr )</code> constructor, which simply increments the passed object's refcount, and general <code>utils::Ref&lt; T &gt;::Ref( RefObject* ptr )</code>, which queries its argument for instance of T and throws an exception on failure (don't worry, though, there's of course a method for the soft cast).</p>\n<p>But having just these two methods introduces a problem: you cannot explicitly initialize <code>utils::Ref</code> with a null pointer, as it is ambiguous; so there's also <code>utils::Ref&lt; T &gt;::Ref( nullptr_t )</code> to provide a way to do it.</p>\n<p>Now, we are getting to the problem at hand. In the header file, the prototype is spelled exactly as above, without any preceding <code>std::</code>. Note that I don't use <code>using namespace</code> either. For a long time, this worked.</p>\n<p>Now, I'm working on a graphics system. It existed before, but it was rather rudimentary, so I didn't even noticed that &lt;gl.h&gt; actually defines only OpenGL 1.1, while for newer versions you should go through &lt;glext.h&gt;. Now, it became necessary to use the latter. But including it broke the old reference class.</p>\n<p>Judging from error messages, MinGW now has problems with that <code>nullptr_t</code> in prototypes. I've done a quick search on the Web and found that <em>often</em> it's referred to as <code>std::nullptr_t</code>. Though, not everywhere.</p>\n<p><strong>Quick sumup: I had <code>nullptr_t</code> without either <code>std::</code> or <code>using namespace</code> compiling fine until I included &lt;glext.h&gt; before the header.</strong></p>\n<p>The site I've been using so far, cplusplus.com/reference, suggests that global <code>::nullptr_t</code> <a href=\"http://www.cplusplus.com/reference/cstddef/nullptr_t/\" rel=\"nofollow\">is exactly how it should be</a>. On the other hand, en.cppreference.com wiki <a href=\"http://en.cppreference.com/w/cpp/types/nullptr_t\" rel=\"nofollow\">tells that</a> it's actually <code>std::nullptr_t</code>.</p>\n<p>A quick test program, a helloworld with <code>void foo( int )</code> and <code>void foo( nullptr_t )</code>, failed to compile and the reason now is explicit <code>\"error: 'nullptr_t' was not declared in this scope\"</code> with suggestion to use <code>std::nullptr_t</code> instead.</p>\n<p>It won't be hard to add <code>std::</code> where needed; but this case left me rather curious.</p>\n<p>cplusplus.com was actually lying? =&gt; Answered in commets, yes. It's an inaccurate source.</p>\n<p>Then, if <code>nullptr_t</code> actually resides in <code>namespace std</code>, why did <code>utils::Ref</code> compile? =&gt; With suggestions in comments, ran a couple of test and discovered that &lt;mutex&gt;, included in some other header, when placed before any stddef header, defines global <code>::nullptr_t</code>. Certainly not an ideal behavior, but it's not a major bug. Probably should report it to MinGW/GCC developers anyway.</p>\n<p>Why inclusion of &lt;glext.h&gt; breaks it? =&gt; When any stddef header is included before &lt;mutex&gt;, the type is defined according to the standard, as <code>std::nullptr_t</code>. &lt;glext.h&gt; includes &lt;windows.h&gt;, which, in turn, certainly includes the stddef header, among with a whole pack of others which are needed for WinAPI.</p>\n<p>Here are the sources, defining the class in question:</p>\n<ul>\n<li><a href=\"http://pastebin.com/8ydpP9Aw\" rel=\"nofollow\">utils/ref.hpp</a></li>\n<li><a href=\"http://pastebin.com/KwSRyDTk\" rel=\"nofollow\">utils/ref.cpp</a></li>\n<li><a href=\"http://pastebin.com/7UELQxqz\" rel=\"nofollow\">utils/refobject.hpp</a></li>\n<li><a href=\"http://pastebin.com/qu1VTiuu\" rel=\"nofollow\">utils/refobject.cpp</a></li>\n<li><a href=\"http://pastebin.com/sGa23tB2\" rel=\"nofollow\">utils/logger.hpp</a> =&gt; This one uses a mutex to avoid line tearing during output.</li>\n<li><a href=\"http://pastebin.com/40upGeer\" rel=\"nofollow\">utils/cbase.hpp</a></li>\n</ul>\n<p>(the latter 2 are included and so may affect too)</p>\n<p>As suggested in the comments, I ran g++ -E on a test case which compiled, and found a quite interesting bit in &lt;stddef.h&gt;:</p>\n<pre><code>#if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L\n#ifndef _GXX_NULLPTR_T\n#define _GXX_NULLPTR_T\n  typedef decltype(nullptr) nullptr_t;\n#endif\n#endif /* C++11.  */\n</code></pre>\n<p>Now to find where <code>_GXX_NULLPTR_T</code> is defined else... a quick GREP through MinGW's files didn't find anything besides this stddef.h</p>\n<p>So, it's still a mystery why and how it's getting disabled. Especially when including just &lt;stddef.h&gt; and nothing else does not define <code>nullptr_t</code> anywhere, despite the bit above.</p>\n", "Tags": "<c++><c++11><std><nullptr>", "OwnerUserId": "3449781", "AnswerCount": "1"}});