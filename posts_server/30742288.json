post_cb({"30742473": {"ParentId": "30742288", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-06-09T20:44:09.407", "Score": "8", "LastEditorUserId": "1708801", "LastEditDate": "2015-06-11T18:12:10.307", "Id": "30742473", "OwnerUserId": "1708801", "Body": "<p>In C++03 we were only allowed to provide an in class initializer for static member variables of const integral of enumeration types, in C++11 we could initialize a static member of literal type in class using constexpr. This restriction was kept in C++11 for const variables mainly for compatibility will C++03 we can see this from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1826\" rel=\"nofollow\">closed issue 1826:  const floating-point in constant expressions </a> which says:</p>\n<blockquote>\n<p id=\"so_30742288_30742473_0\">A const integer initialized with a constant can be used in constant expressions, but a const floating point variable initialized with a constant cannot. This was intentional, to be compatible with C++03 while encouraging the consistent use of constexpr. Some people have found this distinction to be surprising, however.</p>\n</blockquote>\n<p>CWG ended up closing this request as not a defect(<em>NAD</em>), basically saying:</p>\n<blockquote>\n<p id=\"so_30742288_30742473_1\">that programmers desiring floating point values to participate in constant expressions should use constexpr instead of const.</p>\n</blockquote>\n<p>For reference <code>N1804</code> the closest draft standard to C++03 publicly available in section <code>9.4.2</code> <em>[class.static.data]</em> says:</p>\n<blockquote>\n<p id=\"so_30742288_30742473_2\">If a static data member is of const integral or const enumeration type, its declaration in the class definition can\n  specify a constant-initializer which shall be an integral constant expression (5.19). In that case, the member can appear\n  in integral constant expressions. The member shall still be defined in a namespace scope if it is used in the program and\n  the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<p>and the draft C++11 standard section <code>9.4.2</code> <em>[class.static.data]</em> says:</p>\n<blockquote>\n<p id=\"so_30742288_30742473_3\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class\n  definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment expression\n  is a constant expression (5.19). A static data member of literal type can be declared in the\n  class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer\n  in which every initializer-clause that is an assignment-expression is a constant expression. [...]</p>\n</blockquote>\n<p>this is pretty much the same in the draft C++14 standard.</p>\n", "LastActivityDate": "2015-06-11T18:12:10.307"}, "30742288": {"CommentCount": "4", "ViewCount": "504", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-06-09T20:32:47.847", "LastActivityDate": "2015-06-11T18:12:10.307", "Title": "Constant expression initializer for static class member of type double", "AcceptedAnswerId": "30742473", "LastEditDate": "2015-06-10T03:12:20.157", "Id": "30742288", "Score": "12", "Body": "<p>In C++11 and C++14, why do I need <code>constexpr</code> in the following snippet: </p>\n<pre><code>class Foo {\n    static constexpr double X = 0.75;\n};\n</code></pre>\n<p>whereas this one produces a compiler error:</p>\n<pre><code>class Foo {\n    static const double X = 0.75;\n};\n</code></pre>\n<p>and (more surprisingly) this compiles without errors?</p>\n<pre><code>class Foo {\n    static const double X;\n};\n\nconst double Foo::X = 0.75;\n</code></pre>\n", "Tags": "<c++><c++11><c++14><static-members><constant-expression>", "OwnerUserId": "2344584", "AnswerCount": "2"}, "30742534": {"ParentId": "30742288", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-06-09T20:47:32.147", "Score": "0", "LastEditorUserId": "4461183", "LastEditDate": "2015-06-09T20:56:36.083", "Id": "30742534", "OwnerUserId": "4461183", "Body": "<p>In-class static const \"definitions\" are actually declarations. When a variable is defined, the compiler allocates memory for that variable, but that is not the case here, i.e. taking address of these static-const-in-class things is ill formed, NDR. </p>\n<p>These things are supposed to be worked into the code, but that is not so easy to do with floating point types, therefore it is not allowed.</p>\n<p>By defining your static const variables outside class you are signalling to the compiler that this is real definition - real instance with memory location.</p>\n", "LastActivityDate": "2015-06-09T20:56:36.083"}, "bq_ids": {"n4140": {"so_30742288_30742473_2": {"section_id": 5908, "quality": 0.7567567567567568, "length": 28}, "so_30742288_30742473_3": {"section_id": 5908, "quality": 0.9285714285714286, "length": 39}}, "n3337": {"so_30742288_30742473_2": {"section_id": 5680, "quality": 0.7567567567567568, "length": 28}, "so_30742288_30742473_3": {"section_id": 5680, "quality": 0.9285714285714286, "length": 39}}, "n4659": {"so_30742288_30742473_2": {"section_id": 7390, "quality": 0.6486486486486487, "length": 24}, "so_30742288_30742473_3": {"section_id": 7390, "quality": 0.6666666666666666, "length": 28}}}});