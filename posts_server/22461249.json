post_cb({"22461668": {"Id": "22461668", "PostTypeId": "2", "Body": "<p>From \u00a730.6.6/17 of the standard, <code>std::future::get()</code></p>\n<blockquote>\n<p id=\"so_22461249_22461668_0\"><em>Throws</em>: the stored exception, if an exception was stored in the shared state.</p>\n</blockquote>\n<p>And from \u00a730.6.8/3 of the standard, when using <code>std::async()</code> with policy <code>std::launch::async</code>,</p>\n<blockquote>\n<p id=\"so_22461249_22461668_1\">Any exception propagated from the execution of <code>INVOKE(DECAY_COPY(std::forward&lt;F&gt;(f)), DECAY_COPY(std::forward&lt;Args&gt;(args))...)</code> is stored as the exceptional result in the shared state.</p>\n</blockquote>\n<p>With policy <code>std::launch::deferred</code>, there is no special behavior required for the exception to propagate up as observed.</p>\n<p>So yes, this behavior is consistent with the C++11 spec.</p>\n", "LastEditorUserId": "3311013", "LastActivityDate": "2014-03-17T18:26:20.700", "Score": "4", "CreationDate": "2014-03-17T17:51:28.280", "ParentId": "22461249", "CommentCount": "2", "LastEditDate": "2014-03-17T18:26:20.700", "OwnerUserId": "3311013"}, "bq_ids": {"n4140": {"so_22461249_22461668_0": {"length": 7, "quality": 0.875, "section_id": 3121}, "so_22461249_22461668_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 3161}}, "n3337": {"so_22461249_22461668_0": {"length": 7, "quality": 0.875, "section_id": 2998}, "so_22461249_22461668_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 3034}}, "n4659": {"so_22461249_22461668_0": {"length": 7, "quality": 0.875, "section_id": 3883}, "so_22461249_22461668_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 3923}}}, "22461249": {"ViewCount": "54", "Body": "<p>My question is: Is the following observed behavior consistent with the C++11 spec or is it a Microsoft extension to the language?</p>\n<p>In a test program (using Visual Studio Express 2013) I am testing out exception propagation from a function run in thread -- to the parent thread. Without using the prescribed exception pointer stuff it all works OK... and this had me wondering if this is actually a Microsoft Extension to the language going on.</p>\n<p>So I set \"Disable Language Extensions\" and now not even Hello World compiles (C2400: inline assembler syntax error) so I am no closer to knowing if the observed behavior is consistent with the standard.  </p>\n<p>Reading some other questions here gives me the impression that the following should not work.</p>\n<pre><code>int myFunc() { throw &lt;various types tried here&gt;; }\n\nint main() {\n    auto fut = std::async(myFunc);\n    //...\n\n    try {\n        int retVal = fut.get();\n    }\n    catch(&lt;corresponding type here&gt;) {\n\n        // matching exception is always caught here in parent \n\n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "22461668", "Title": "C++11 Thread Exception Propogation in Visual Studio (Express 2013)", "CreationDate": "2014-03-17T17:31:50.017", "Id": "22461249", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-03-17T18:26:20.700", "Score": "1", "OwnerUserId": "849048", "Tags": "<c++11>", "AnswerCount": "1"}});