post_cb({"33967781": {"ParentId": "33966809", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I do not think you will find any other cases. If we look at the draft C++ standard <em>Annex A Grammar summary</em> we can see the only other locations in the grammar where <em>type-name</em> shows up are:</p>\n<pre><code>nested-name-specifier:\n  ::\n  type-name ::\n  namespace-name ::\n  decltype-specifier ::\n  nested-name-specifier identifier ::\n  nested-name-specifier templateopt simple-template-id ::\n</code></pre>\n<p>and:</p>\n<pre><code>simple-type-specifier:\n  nested-name-specifieropt type-name\n  [...]\n</code></pre>\n<p>Neither of which provide a similar opportunity that we get with the pseduo-destructor which has the following grammar:</p>\n<pre><code>pseudo-destructor-name:\n  nested-name-specifieropt type-name :: ~ type-name\n  nested-name-specifier template simple-template-id :: ~ type-name\n  nested-name-specifieropt~ type-name\n  ~ decltype-specifier \n</code></pre>\n<p>and is covered in section <code>5.2.4</code> [expr.pseudo] which provides for the behavior we see:</p>\n<blockquote>\n<p id=\"so_33966809_33967781_0\">The use of a pseudo-destructor-name after a dot . or arrow -&gt; operator\n  represents the destructor for the non-class type denoted by type-name\n  or decltype-specifier. The result shall only be used as the operand\n  for the function call operator (), and the result of such a call has\n  type void. The only effect is the evaluation of the postfix-expression\n  before the dot or arrow.</p>\n</blockquote>\n<p>on the other hand we can see the rules for nested-name-specifier in section <code>3.4.3</code> <em>[basic.lookup.qual]</em> forbid such a case:</p>\n<blockquote>\n<p id=\"so_33966809_33967781_1\">The name of a class or namespace member or enumerator can be referred\n  to after the :: scope resolution operator (5.1) applied to a\n  nested-name-specifier that denotes its class, namespace, or\n  enumeration. If a :: scope resolution operator in a\n  nested-name-specifier is not preceded by a decltype-specifier, lookup\n  of the name preceding that :: considers only namespaces, types, and\n  templates whose specializations are types. If the name found does not\n  designate a namespace or a class, enumeration, or dependent type, the\n  program is ill-formed</p>\n</blockquote>\n<p>The simple-type-specifier case does not get us there either since fundamental types are already acceptable for this case.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-12-03T15:23:57.773", "Id": "33967781", "Score": "4", "CreationDate": "2015-11-28T04:43:50.610", "LastActivityDate": "2015-12-03T15:23:57.773"}, "33966809": {"CommentCount": "12", "AcceptedAnswerId": "33967781", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-28T01:43:09.933", "LastActivityDate": "2015-12-03T15:23:57.773", "LastEditDate": "2017-05-23T11:44:19.520", "ViewCount": "488", "FavoriteCount": "4", "Title": "Are there language constructs that are valid for type-name but not for fundamental types?", "Id": "33966809", "Score": "28", "Body": "<p>I noticed that pseudo destructor call is valid when a <em>type-name</em> is used but not when a fundamental type is used.</p>\n<pre><code>typedef int BType;\nint b;\nb.~BType();   // Legal\nb.~int();     // Not legal\n</code></pre>\n<p>An explanation for the above can be found at <a href=\"https://stackoverflow.com/a/24000642/434551\">an answer to another SO post</a>.</p>\n<p>Definition of <em>type-name</em>, from the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_33966809_33966809_0\"><strong>7.1.6.2 Simple type specifiers, p1</strong></p>\n<pre>\n<em>type-name:</em>  \n   <em>class-name</em>   \n   <em>enum-name</em>  \n   <em>typedef-name</em>  \n   <em>simple-template-id</em>\n</pre>\n</blockquote>\n<p>Are there any other language constructs that are valid when the type specifier is a <em>type-name</em> but not valid when it is a fundamental type even when the <em>type-name</em> represents a fundamental type, as shown above?</p>\n", "Tags": "<c++>", "OwnerUserId": "434551", "AnswerCount": "2"}, "34016171": {"ParentId": "33966809", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>There is a difference when the return type of a function is a fundamental type or not:</p>\n<pre><code>struct X{};\n\ntemplate &lt;class T&gt; auto foo() {\n  // one liner\n  []() -&gt; T { return T{}; }() = T{}; // invalid for T fundamental type\n\n  // or more clear:\n  auto get_t = []() -&gt; T { return T{}; };\n  get_t() = T{}; // invalid for T fundamental type\n}\n\nauto main() -&gt; int {\n  foo&lt;X&gt;();    // valid\n  foo&lt;int&gt;();  // invalid\n  return 0;\n}\n</code></pre>\n<p>Without templates, to be even more clear:</p>\n<pre><code>struct X{};\n\nauto ret_x() -&gt; X { return X{}; }    \nauto ret_int() -&gt; int { return int{}; }\n\n\nauto main() -&gt; int {\n  ret_x() = X{};     // valid\n  ret_int() = int{}; // invalid\n  return 0;\n}\n</code></pre>\n<p>rvalues for fundamental types cannot be modified. This is clearly not the case for other types, as, for instance, a move operation must modify the temporary from which it moves (e.g. make the owning pointer nullptr)</p>\n", "OwnerUserId": "2805305", "LastEditorUserId": "2805305", "LastEditDate": "2015-12-01T18:00:07.180", "Id": "34016171", "Score": "2", "CreationDate": "2015-12-01T08:50:08.120", "LastActivityDate": "2015-12-01T18:00:07.180"}, "bq_ids": {"n4140": {"so_33966809_33967781_0": {"section_id": 6002, "quality": 0.90625, "length": 29}, "so_33966809_33967781_1": {"section_id": 7107, "quality": 0.9777777777777777, "length": 44}}, "n3337": {"so_33966809_33967781_0": {"section_id": 5770, "quality": 0.90625, "length": 29}, "so_33966809_33967781_1": {"section_id": 6851, "quality": 0.9777777777777777, "length": 44}}, "n4659": {"so_33966809_33967781_0": {"section_id": 7501, "quality": 0.90625, "length": 29}, "so_33966809_33967781_1": {"section_id": 8608, "quality": 0.9777777777777777, "length": 44}}}});