post_cb({"bq_ids": {"n4140": {"so_24350354_24350505_0": {"length": 10, "quality": 1.0, "section_id": 3244}}, "n3337": {"so_24350354_24350505_0": {"length": 10, "quality": 1.0, "section_id": 3117}}, "n4659": {"so_24350354_24350505_0": {"length": 7, "quality": 0.7, "section_id": 6103}}}, "24350354": {"ViewCount": "228", "Body": "<p>I have these C++ codes:</p>\n<p>In \"header1.h\"</p>\n<pre><code>template &lt;typename T&gt;\nint  f1(const T&amp; t1) {\n    return 0;\n}\n\nextern const int  p[];\n</code></pre>\n<p>in cpptests.cpp</p>\n<pre><code>#include \"header1.h\"\nint _tmain(int argc, _TCHAR* argv[])  {\n    f1(p);\n    return 0;\n}\n</code></pre>\n<p>And in VC++2010, I got this compile error:</p>\n<pre><code>c:\\work\\cpptests\\cpptests\\cpptests.cpp(10): error C2664: 'f1' : cannot convert parameter 1 from 'const int []' to 'const int (&amp;)[1]'\n          Reason: cannot convert from 'const int []' to 'const int [1]'\n          There is no context in which this conversion is possible\n  Generating Code...\n</code></pre>\n<p>Wny does the template function call convert p to <code>const int (&amp;)[1]</code>?</p>\n", "AcceptedAnswerId": "24350505", "Title": "C++ Weird Type Conversion Error wtih Function Template", "CreationDate": "2014-06-22T10:31:37.750", "Id": "24350354", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2014-06-22T11:15:27.540", "Score": "2", "OwnerUserId": "237575", "Tags": "<c++><templates><function-templates>", "AnswerCount": "1"}, "24350505": {"Id": "24350505", "PostTypeId": "2", "Body": "<p>The type of your variable <code>p</code> is \"array of unknown bound of <code>const int</code>\". By C++11 8.3.5, \"Functions\",</p>\n<blockquote>\n<p id=\"so_24350354_24350505_0\">If the type of a parameter includes a type of the form [...] \u201creference to array of unknown bound of <code>T</code>,\u201d the program is ill-formed.</p>\n</blockquote>\n<p>Allow me a little mental excursion on why this makes sense:</p>\n<p>You may know that even if a type <code>T</code> is incomplete, the types <code>T *</code> and <code>T &amp;</code> are complete types. C++ contains a curious mechanism by which the type of a variable may change by virtue of being <em>completed</em>. That is, you can declare a variable <code>T x;</code> which has incomplete type, but later <em>complete</em> the type in the variable's definition. For example, take <code>T = int[]</code>:</p>\n<pre><code>extern int a[];    // `a` has incomplete type \"array of unknown bound of int\"\nint a[10];         // now `a` has complete type \"array of 10 int\"\n</code></pre>\n<p>However (cf. 3.9/6), suppose now that we have another variable of pointer type <code>T *</code>:</p>\n<pre><code>int (*p)[] = &amp;a;   // `p` is a pointer to an array of unknown bound\n</code></pre>\n<p>The type of this variable is already complete, but the \"array\" part of it can never be completed. So even if <code>a</code> may eventually have a complete type, the type <code>p</code> can never change. Its type will never become <code>int (*)[10]</code>. Both types are already complete, and the latter is <em>not</em> a completion of the former.</p>\n<p>That means that you can never <em>use</em> <code>p</code> to access the entire array object as a whole. You can still use <code>p</code> by decaying <code>*p</code> to a pointer to the first element of the array (note that <code>*p</code> is a perfectly fine lvalue; glvalues need not have complete types), but you can never see the whole array through <code>p</code>. (The same reasoning applies to <code>T &amp;</code>.)</p>\n<p>Since pointers and references to arrays of unknown bound have such limited utility, they are not allowed as function parameter types. In your case, the deduced type is precisely an \"array of unknown bound\" type, and so the resulting program is ill-formed.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2014-06-22T11:15:27.540", "Score": "3", "CreationDate": "2014-06-22T10:51:34.407", "ParentId": "24350354", "CommentCount": "1", "OwnerUserId": "596781", "LastEditDate": "2014-06-22T11:15:27.540"}});