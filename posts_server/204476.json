post_cb({"5260799": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-03-10T14:11:33.747", "Score": "1", "LastEditorUserId": "702361", "LastEditDate": "2012-09-28T03:32:13.863", "Id": "5260799", "OwnerUserId": "702361", "Body": "<p>What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.\nIf the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature <code>int main (void) { .. return 0; .. }</code></p>\n", "LastActivityDate": "2012-09-28T03:32:13.863"}, "204530": {"CommentCount": "7", "CreationDate": "2008-10-15T12:33:14.733", "LastEditorUserId": "702361", "LastActivityDate": "2012-09-28T03:31:37.700", "ParentId": "204476", "LastEditDate": "2012-09-28T03:31:37.700", "OwnerDisplayName": "dmityugov", "PostTypeId": "2", "Id": "204530", "Score": "56", "Body": "<p>I believe that <code>main()</code> should return either <code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. They are defined in <code>stdlib.h</code></p>\n", "OwnerUserId": "3232"}, "13524721": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-11-23T07:29:29.500", "Score": "1", "LastEditorUserId": "63550", "LastEditDate": "2016-03-13T15:18:42.787", "Id": "13524721", "OwnerUserId": "1395129", "Body": "<p>Returning 0 should tell the programmer that the program has successfully finished the job.</p>\n", "LastActivityDate": "2016-03-13T15:18:42.787"}, "43558724": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2017-04-22T11:34:54.647", "Score": "0", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:46.643", "Id": "43558724", "OwnerUserId": "3191481", "Body": "<h2>Omit <code>return 0</code></h2>\n<p>When a C or C++ program reaches the end of <code>main</code> the compiler will automatically generate code to return 0, so there is no need to put <code>return 0;</code> explicitly at the end of <code>main</code>.  </p>\n<p><strong>Note:</strong> when I make this suggestion, it's almost invariably followed by one of two kinds of comments:  \"I didn't know that.\" or \"That's bad advice!\"  My rationale is that it's safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:</p>\n<blockquote>\n<p id=\"so_204476_43558724_0\">[...] a return from the initial call to the <code>main</code> function is equivalent to calling the <code>exit</code> function with the value returned by the <code>main</code> function as its argument; reaching the <code>}</code> that terminates the <code>main</code> function returns a value of 0.</p>\n</blockquote>\n<p>For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:</p>\n<blockquote>\n<p id=\"so_204476_43558724_1\">If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;</p>\n</blockquote>\n<p>All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit <code>return;</code> statements at the end of a <code>void</code> function.  Reasons against omitting seem to boil down to <a href=\"https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015\">\"it looks weird\"</a>.  If, like me, you're curious about the rationale for the change to the C standard <a href=\"https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional\">read this question</a>.  Also note that in the early 1990s this was considered \"sloppy practice\" because it was undefined behavior (although widely supported) at the time.  </p>\n<p>So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you'll know that it's explicitly supported by the standard and you'll know what it means.</p>\n", "LastActivityDate": "2017-04-22T11:34:54.647"}, "204559": {"ParentId": "204476", "CommentCount": "4", "CreationDate": "2008-10-15T12:42:47.723", "OwnerUserId": "342", "Id": "204559", "PostTypeId": "2", "OwnerDisplayName": "graham.reeds", "Score": "3", "Body": "<p>I was under the impression that standard specifies that main doesn't need a return value as a successful return was OS based (zero in one could be either a success or a failure in another), therefore the absence of return was a cue for the compiler to insert the successful return itself.</p>\n<p>However I usually return 0.</p>\n", "LastActivityDate": "2008-10-15T12:42:47.723"}, "204487": {"ParentId": "204476", "CommentCount": "0", "CreationDate": "2008-10-15T12:16:51.503", "OwnerUserId": "3937", "Id": "204487", "PostTypeId": "2", "OwnerDisplayName": "Lou Franco", "Score": "27", "Body": "<p>Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.</p>\n", "LastActivityDate": "2008-10-15T12:16:51.503"}, "46554052": {"ParentId": "204476", "CommentCount": "0", "CreationDate": "2017-10-03T21:56:28.587", "OwnerUserId": "3923896", "PostTypeId": "2", "Id": "46554052", "Score": "0", "Body": "<blockquote>\n<p id=\"so_204476_46554052_0\">What is the correct (most efficient) way to define the main() function in C and C++ \u2014 int main() or void main() \u2014 and why?</p>\n</blockquote>\n<p>Those words \"(most efficient)\" don't change the question.  Unless you're in a freestanding environment, there is one universally correct way to declare <code>main()</code>, and that's as returning int.</p>\n<blockquote>\n<p id=\"so_204476_46554052_1\">What should <code>main()</code> return in C and C++?</p>\n</blockquote>\n<p>It's not what <em>should</em> <code>main()</code> return, it's what <em>does</em> <code>main()</code> return.  <code>main()</code> is, of course, a function that someone else calls.  You don't have any control over the code that calls <code>main()</code>.  Therefore, you must declare <code>main()</code> with a type-correct signature to match its caller.  You simply don't have any choice in the matter.  You don't have to ask yourself what's more or less efficient, or what's better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.</p>\n<blockquote>\n<p id=\"so_204476_46554052_2\">If int main() then return 1 or return 0?</p>\n</blockquote>\n<p>0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it's defined by the interface you're supposed to be conforming to.</p>\n", "LastActivityDate": "2017-10-03T21:56:28.587"}, "207992": {"CommentCount": "11", "CreationDate": "2008-10-16T09:59:57.177", "LastEditorUserId": "5375464", "LastActivityDate": "2017-08-05T17:45:56.827", "ParentId": "204476", "LastEditDate": "2017-08-05T17:45:56.827", "OwnerDisplayName": "Chris Young", "PostTypeId": "2", "Id": "207992", "Score": "119", "Body": "<p>The accepted answer appears to be targetted for C++, so I thought I'd add an answer that pertains to C, and this differs in a few ways.</p>\n<p>ISO/IEC 9899:1989 (C90):</p>\n<p><code>main()</code> should be declared as either:</p>\n<pre><code>int main(void)\nint main(int argc, char **argv)\n</code></pre>\n<p>Or equivalent. For example, <code>int main(int argc, char *argv[])</code> is equivalent to the second one. Further, the <code>int</code> return type can be omitted as it is a default.</p>\n<p>If an implementation permits it, <code>main()</code> can be declared in other ways, but this makes the program implementation defined, and no longer strictly conforming.</p>\n<p>The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): <code>0</code> and <code>EXIT_SUCCESS</code> for a successful termination, and <code>EXIT_FAILURE</code> for an unsuccessful termination. Any other values are non-standard and implementation defined. <code>main()</code> must have an explicit <code>return</code> statement at the end to avoid undefined behaviour.</p>\n<p>Finally, there is nothing wrong from a standards point of view with calling <code>main()</code> from a program.</p>\n<p>ISO/IEC 9899:1999 (C99):</p>\n<p>For C99, everything is the same as above except:</p>\n<ul>\n<li>The <code>int</code> return type may not be omitted.</li>\n<li>You may omit the return statement from <code>main()</code>. If you do, and <code>main()</code> finished, there is an implicit <code>return 0</code>.</li>\n</ul>\n", "OwnerUserId": "9417"}, "31263079": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-07-07T08:07:30.277", "Score": "19", "LastEditorUserId": "584518", "LastEditDate": "2017-10-13T12:02:25.630", "Id": "31263079", "OwnerUserId": "584518", "Body": "<p>Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.</p>\n<ul>\n<li><p><strong>C90 hosted environment</strong></p>\n<p>Allowed forms <sup>1</sup>:</p>\n<pre><code>int main (void)\nint main (int argc, char *argv[])\n\nmain (void)\nmain (int argc, char *argv[])\n/*... etc, similar forms with implicit int */\n</code></pre>\n<p>Comments: </p>\n<p>The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed \"implicit int\" for return type and function parameters. No other form is allowed.</p></li>\n<li><p><strong>C90 freestanding environment</strong></p>\n<p>Any form or name of main is allowed <sup>2</sup>.</p></li>\n<li><p><strong>C99 hosted environment</strong></p>\n<p>Allowed forms <sup>3</sup>: </p>\n<pre><code>int main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n</code></pre>\n<p>Comments: </p>\n<p>C99 removed \"implicit int\" so <code>main()</code> is no longer valid.</p>\n<p>A strange, ambiguous sentence \"or in some other implementation-defined manner\" has been introduced. This can either be interpreted as \"the parameters to <code>int main()</code> may vary\" or as \"main can have any implementation-defined form\". </p>\n<p>Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not strictly conforming by citing the standard in itself, since it is is ambiguous.</p>\n<p>However, to allow completely wild forms of main() was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to <code>int main</code> <sup>4</sup>.</p>\n<p>Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int <sup>5</sup>. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.</p></li>\n<li><p><strong>C99 freestanding environment</strong></p>\n<p>Any form or name of main is allowed <sup>6</sup>.</p></li>\n<li><p><strong>C11 hosted environment</strong></p>\n<p>Allowed forms <sup>7</sup>:</p>\n<pre><code>int main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n</code></pre></li>\n<li><p><strong>C11 freestanding environment</strong></p>\n<p>Any form or name of main is allowed <sup>8</sup>.</p></li>\n</ul>\n<hr>\n<p>Note that <code>int main()</code> was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, <code>()</code> and <code>(void)</code> have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:</p>\n<blockquote>\n<p id=\"so_204476_31263079_0\">6.11.6 Function declarators</p>\n<p id=\"so_204476_31263079_1\">The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.</p>\n</blockquote>\n<hr>\n<ul>\n<li><p><strong>C++03 hosted environment</strong></p>\n<p>Allowed forms <sup>9</sup>:</p>\n<pre><code>int main ()\nint main (int argc, char *argv[])\n</code></pre>\n<p>Comments:</p>\n<p>Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.</p></li>\n<li><p><strong>C++03 freestanding environment</strong></p>\n<p>The name of the function called at startup is implementation-defined. If it is named main() it must follow the stated forms <sup>10</sup>:</p>\n<pre><code>// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n</code></pre></li>\n<li><p><strong>C++11 hosted environment</strong></p>\n<p>Allowed forms <sup>11</sup>:</p>\n<pre><code>int main ()\nint main (int argc, char *argv[])\n</code></pre>\n<p>Comments:</p>\n<p>The text of the standard has been changed but it has the same meaning.</p></li>\n<li><p><strong>C++11 freestanding environment</strong></p>\n<p>The name of the function called at startup is implementation-defined. If it is named main() it must follow the stated forms <sup>12</sup>:</p>\n<pre><code>// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n</code></pre></li>\n</ul>\n<hr>\n<p><strong>References</strong></p>\n<ol>\n<li><p>ANSI X3.159-1989 2.1.2.2 Hosted environment. \"Program startup\"</p>\n<blockquote>\n<p id=\"so_204476_31263079_2\">The function called at program startup is named main. The\n  implementation declares no prototype for this function. It shall be\n  defined with a return type of int and with no parameters: </p>\n</blockquote>\n<pre><code>int main(void) { /* ... */ } \n</code></pre>\n<blockquote>\n<p id=\"so_204476_31263079_3\">or with two parameters (referred to here as\n  argc and argv, though any names may be used, as they are local to the\n  function in which they are declared): </p>\n</blockquote>\n<pre><code>int main(int argc, char *argv[]) { /* ... */ }\n</code></pre></li>\n<li><p>ANSI X3.159-1989 2.1.2.1 Freestanding environment:</p>\n<blockquote>\n<p id=\"so_204476_31263079_4\">In a freestanding environment (in which C program execution may take\n  place without any benefit of an operating system), the name and type\n  of the function called at program startup are implementation-defined.</p>\n</blockquote></li>\n<li><p>ISO 9899:1999 5.1.2.2 Hosted environment -&gt; 5.1.2.2.1 Program startup</p>\n<blockquote>\n<p id=\"so_204476_31263079_5\">The function called at program startup is named main. The\n  implementation declares no prototype for this function. It shall be\n  defined with a return type of int and with no parameters: </p>\n</blockquote>\n<pre><code>int main(void) { /* ... */ } \n</code></pre>\n<blockquote>\n<p id=\"so_204476_31263079_6\">or with two parameters (referred to here as\n  argc and argv, though any names may be used, as they are local to the\n  function in which they are declared): </p>\n</blockquote>\n<pre><code>int main(int argc, char *argv[]) { /* ... */ }\n</code></pre>\n<blockquote>\n<p id=\"so_204476_31263079_7\">or equivalent;9) or in some other implementation-defined\n  manner.</p>\n</blockquote></li>\n<li><p>Rationale for International Standard \u2014 Programming Languages \u2014 C, Revision 5.10. 5.1.2.2 Hosted environment --&gt; 5.1.2.2.1 Program startup</p>\n<blockquote>\n<p id=\"so_204476_31263079_8\">The behavior of the arguments to main, and of the interaction of exit, main and atexit\n  (see \u00a77.20.4.2) has been codified to curb some unwanted variety in the representation of argv\n  strings, and in the meaning of values returned by main.</p>\n<p id=\"so_204476_31263079_9\">The specification of argc and argv as arguments to main recognizes extensive prior practice.\n  argv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.</p>\n<p id=\"so_204476_31263079_10\">main is the only function that may portably be declared either with zero or two arguments. (The\n  number of other functions\u2019 arguments must match exactly between invocation and definition.)\n  This special case simply recognizes the widespread practice of leaving off the arguments to\n  main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor\n  forbidden by the Standard; a program that defines main with three arguments is not strictly\n  conforming (see \u00a7J.5.1.).</p>\n</blockquote></li>\n<li><p>ISO 9899:1999 5.1.2.2 Hosted environment --&gt; 5.1.2.2.3 Program termination</p>\n<blockquote>\n<p id=\"so_204476_31263079_11\">If the return type of the main function is a type compatible with int, a return from the\n  initial call to the main function is equivalent to calling the exit function with the value\n  returned by the main function as its argument;11) reaching the } that terminates the\n  main function returns a value of 0. If the return type is not compatible with int, the\n  termination status returned to the host environment is unspecified.</p>\n</blockquote></li>\n<li><p>ISO 9899:1999 5.1.2.1 Freestanding environment</p>\n<blockquote>\n<p id=\"so_204476_31263079_12\">In a freestanding environment (in which C program execution may take place without any\n  benefit of an operating system), the name and type of the function called at program\n  startup are implementation-defined.</p>\n</blockquote></li>\n<li><p>ISO 9899:2011 5.1.2.2 Hosted environment -&gt; 5.1.2.2.1 Program startup</p>\n<p>This section is identical to the C99 one cited above.</p></li>\n<li><p>ISO 9899:1999 5.1.2.1 Freestanding environment</p>\n<p>This section is identical to the C99 one cited above.</p></li>\n<li><p>ISO 14882:2003 3.6.1 Main function</p>\n<blockquote>\n<p id=\"so_204476_31263079_13\">An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation-defined. All implementations\n  shall allow both of the following definitions of main:</p>\n</blockquote>\n<pre><code>int main() { /* ... */ }\n</code></pre>\n<blockquote>\n<p id=\"so_204476_31263079_14\">and</p>\n</blockquote>\n<pre><code>int main(int argc, char* argv[]) { /* ... */ }\n</code></pre></li>\n<li><p>ISO 14882:2003 3.6.1 Main function</p>\n<blockquote>\n<p id=\"so_204476_31263079_15\">It is\n  implementation-defined whether a program in a freestanding environment is required to define a main\n  function.</p>\n</blockquote></li>\n<li><p>ISO 14882:2011 3.6.1 Main function</p>\n<blockquote>\n<p id=\"so_204476_31263079_16\">An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation-defined. All implementations shall\n  allow both</p>\n<p id=\"so_204476_31263079_17\">\u2014 a function of () returning int and</p>\n<p id=\"so_204476_31263079_18\">\u2014 a function of (int, pointer to pointer to char) returning int</p>\n<p id=\"so_204476_31263079_19\">as the type of main (8.3.5).</p>\n</blockquote></li>\n<li><p>ISO 14882:2011 3.6.1 Main function</p>\n<p>This section is identical to the C++03 one cited above.</p></li>\n</ol>\n</hr></hr></hr>", "LastActivityDate": "2017-10-13T12:02:25.630"}, "204476": {"CommentCount": "8", "CreationDate": "2008-10-15T12:13:48.327", "PostTypeId": "1", "AcceptedAnswerId": "204483", "LastEditorUserId": "-1", "LastActivityDate": "2017-10-13T12:02:25.630", "AnswerCount": "19", "LastEditDate": "2017-05-23T12:10:43.057", "ViewCount": "247129", "FavoriteCount": "197", "Title": "What should main() return in C and C++?", "Id": "204476", "Score": "488", "Body": "<p>What is the correct (most efficient) way to define the <code>main()</code> function in C and C++ \u2014 <code>int main()</code> or <code>void main()</code> \u2014 and why? \nIf <code>int main()</code> then <code>return 1</code> or <code>return 0</code>?</p>\n<hr>\n<p><em>There are numerous duplicates of this question, including:</em></p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/2108192/what-are-the-valid-signatures-for-cs-main-function/\">What are the valid signatures for C's <code>main()</code> function?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/17715008/the-return-type-of-main-function/\">The return type of <code>main()</code> function</a></li>\n<li><a href=\"https://stackoverflow.com/questions/636829/difference-between-void-main-and-int-main\">Difference between <code>void main()</code> and <code>int main()</code>?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1621574/mains-signature-in-c\"><code>main()</code>'s signature in C++</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main\">What is the proper declaration of <code>main()</code>?</a> \u2014 For C++, with a very good answer indeed.</li>\n<li><a href=\"https://stackoverflow.com/questions/8692120/styles-of-main-functions-in-c\">Styles of <code>main()</code> functions in C</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10915713/return-type-of-main-method-in-c\">Return type of <code>main()</code> method in C</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9356510/int-main-vs-void-main-in-c\"><code>int main()</code> vs <code>void main()</code> in C</a></li>\n</ul>\n<p>Related:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/5191965/c-int-mainint-argc-char-argv\">C++ \u2014 <code>int main(int argc, char **argv)</code></a></li>\n<li><a href=\"https://stackoverflow.com/questions/5217395/c-int-mainint-argc-char-argv\">C++ \u2014 <code>int main(int argc, char *argv[])</code></a></li>\n<li><a href=\"https://stackoverflow.com/questions/10321435/is-char-envp-as-a-third-argument-to-main-portable\">Is <code>char *envp[]</code> as a third argument to <code>main()</code> portable?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/18402853/must-the-int-main-function-return-a-value-in-all-compilers\">Must the <code>int main()</code> function return a value in all compilers?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/5296163/why-is-the-type-of-the-main-function-in-c-and-c-left-to-the-user-to-define\">Why is the type of the <code>main()</code> function in C and C++ left to the user to define?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/22239/why-does-int-main-compile\">Why does <code>int main(){}</code> compile?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/26470912/legal-definitions-of-main-in-c14\">Legal definitions of <code>main()</code> in C++14?</a></li>\n</ul>\n</hr>", "Tags": "<c++><c><return-value><main><return-type>", "OwnerUserId": "25632", "OwnerDisplayName": "Joel"}, "bq_ids": {"n4140": {"so_204476_18721336_13": {"section_id": 7149, "quality": 1.0, "length": 26}, "so_204476_18721336_12": {"section_id": 7147, "quality": 0.625, "length": 5}, "so_204476_18721336_8": {"section_id": 7145, "quality": 1.0, "length": 7}, "so_204476_18721336_9": {"section_id": 7146, "quality": 0.76, "length": 19}, "so_204476_18721336_31": {"section_id": 6264, "quality": 0.7333333333333333, "length": 11}, "so_204476_31263079_4": {"section_id": 5775, "quality": 0.5333333333333333, "length": 8}, "so_204476_18721336_32": {"section_id": 6265, "quality": 0.75, "length": 9}, "so_204476_18721336_28": {"section_id": 5776, "quality": 0.9705882352941176, "length": 33}, "so_204476_18721336_7": {"section_id": 6805, "quality": 0.75, "length": 21}, "so_204476_18721336_11": {"section_id": 7146, "quality": 0.8333333333333334, "length": 40}, "so_204476_18721336_30": {"section_id": 5777, "quality": 0.8571428571428571, "length": 6}, "so_204476_18721336_27": {"section_id": 5775, "quality": 0.8285714285714286, "length": 29}, "so_204476_31263079_15": {"section_id": 7145, "quality": 0.875, "length": 7}, "so_204476_18721336_29": {"section_id": 5777, "quality": 0.9285714285714286, "length": 13}, "so_204476_31263079_18": {"section_id": 7146, "quality": 1.0, "length": 7}, "so_204476_18721336_33": {"section_id": 6266, "quality": 0.8695652173913043, "length": 20}, "so_204476_31263079_13": {"section_id": 7146, "quality": 0.75, "length": 18}, "so_204476_31263079_16": {"section_id": 7146, "quality": 0.8095238095238095, "length": 17}, "so_204476_31263079_12": {"section_id": 5775, "quality": 0.5333333333333333, "length": 8}, "so_204476_43558724_1": {"section_id": 7149, "quality": 0.9, "length": 9}}, "n3337": {"so_204476_18721336_13": {"section_id": 6893, "quality": 1.0, "length": 26}, "so_204476_18721336_12": {"section_id": 6891, "quality": 0.625, "length": 5}, "so_204476_18721336_8": {"section_id": 6889, "quality": 1.0, "length": 7}, "so_204476_18721336_9": {"section_id": 6890, "quality": 0.88, "length": 22}, "so_204476_18721336_31": {"section_id": 6024, "quality": 0.7333333333333333, "length": 11}, "so_204476_31263079_4": {"section_id": 5548, "quality": 0.5333333333333333, "length": 8}, "so_204476_18721336_32": {"section_id": 6025, "quality": 0.75, "length": 9}, "so_204476_18721336_28": {"section_id": 5549, "quality": 0.9705882352941176, "length": 33}, "so_204476_18721336_7": {"section_id": 6560, "quality": 0.75, "length": 21}, "so_204476_18721336_11": {"section_id": 6890, "quality": 0.8333333333333334, "length": 40}, "so_204476_18721336_30": {"section_id": 5550, "quality": 0.8571428571428571, "length": 6}, "so_204476_18721336_27": {"section_id": 5548, "quality": 0.8285714285714286, "length": 29}, "so_204476_31263079_15": {"section_id": 6889, "quality": 0.875, "length": 7}, "so_204476_18721336_29": {"section_id": 5550, "quality": 0.9285714285714286, "length": 13}, "so_204476_31263079_18": {"section_id": 3073, "quality": 0.8571428571428571, "length": 6}, "so_204476_18721336_33": {"section_id": 6026, "quality": 0.8695652173913043, "length": 20}, "so_204476_31263079_13": {"section_id": 6890, "quality": 0.9166666666666666, "length": 22}, "so_204476_31263079_16": {"section_id": 6890, "quality": 0.9047619047619048, "length": 19}, "so_204476_31263079_12": {"section_id": 5548, "quality": 0.5333333333333333, "length": 8}, "so_204476_43558724_1": {"section_id": 6893, "quality": 0.9, "length": 9}}, "n4659": {"so_204476_18721336_13": {"section_id": 8650, "quality": 0.8076923076923077, "length": 21}, "so_204476_18721336_12": {"section_id": 8648, "quality": 0.625, "length": 5}, "so_204476_18721336_7": {"section_id": 8296, "quality": 0.75, "length": 21}, "so_204476_18721336_9": {"section_id": 8647, "quality": 0.76, "length": 19}, "so_204476_18721336_31": {"section_id": 7770, "quality": 0.7333333333333333, "length": 11}, "so_204476_31263079_4": {"section_id": 7232, "quality": 0.5333333333333333, "length": 8}, "so_204476_31263079_16": {"section_id": 8647, "quality": 0.8095238095238095, "length": 17}, "so_204476_18721336_28": {"section_id": 7233, "quality": 0.9705882352941176, "length": 33}, "so_204476_18721336_8": {"section_id": 8646, "quality": 0.7142857142857143, "length": 5}, "so_204476_18721336_11": {"section_id": 8647, "quality": 0.8333333333333334, "length": 40}, "so_204476_18721336_30": {"section_id": 7234, "quality": 0.8571428571428571, "length": 6}, "so_204476_18721336_27": {"section_id": 7232, "quality": 0.8285714285714286, "length": 29}, "so_204476_31263079_15": {"section_id": 8646, "quality": 0.875, "length": 7}, "so_204476_18721336_29": {"section_id": 7234, "quality": 0.9285714285714286, "length": 13}, "so_204476_31263079_18": {"section_id": 8647, "quality": 1.0, "length": 7}, "so_204476_18721336_33": {"section_id": 7772, "quality": 0.8695652173913043, "length": 20}, "so_204476_31263079_13": {"section_id": 8647, "quality": 0.75, "length": 18}, "so_204476_18721336_32": {"section_id": 7771, "quality": 0.75, "length": 9}, "so_204476_31263079_12": {"section_id": 7232, "quality": 0.5333333333333333, "length": 8}}}, "6550681": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-07-01T16:32:34.087", "Score": "4", "LastEditorUserId": "63550", "LastEditDate": "2016-03-13T15:14:22.033", "Id": "6550681", "OwnerUserId": "536086", "Body": "<p>The return value can be used by the operating system to check how the program was closed.</p>\n<p>Return value 0 usually means OK in most operating systems (the ones I can think of anyway).</p>\n<p>It also can be checked when you call a process yourself, and see if the program exited and finished properly.</p>\n<p>It's <strong>NOT</strong> just a programming convention.</p>\n", "LastActivityDate": "2016-03-13T15:14:22.033"}, "17203786": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-06-20T01:09:15.937", "Score": "-1", "LastEditorUserId": "15168", "LastEditDate": "2014-05-17T19:54:17.010", "Id": "17203786", "OwnerUserId": "1294322", "Body": "<p><code>void main()</code> is forbidden after C90.  <code>main</code> should return a value. I used to return 0.</p>\n", "LastActivityDate": "2014-05-17T19:54:17.010"}, "204498": {"ParentId": "204476", "CommentCount": "1", "CreationDate": "2008-10-15T12:18:43.030", "OwnerUserId": "2260", "Id": "204498", "PostTypeId": "2", "OwnerDisplayName": "Daren Thomas", "Score": "0", "Body": "<p>This basically depends on your execution environment (the OS). C implies that it will be run by a UNIX like OS which expects the program to return a (small? 1 Byte? can't remember) integer to indicate success / failure.</p>\n<p>You should probably just use <code>int main(int argc, char** argv)</code>.</p>\n", "LastActivityDate": "2008-10-15T12:18:43.030"}, "28443025": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-02-10T22:22:08.667", "Score": "0", "LastEditorUserId": "63550", "LastEditDate": "2016-03-13T15:36:48.987", "Id": "28443025", "OwnerUserId": "1559401", "Body": "<p>Here is a small demonstration of the usage of return codes...</p>\n<p>When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:</p>\n<blockquote>\n<p id=\"so_204476_28443025_0\">This is some example in order to check how grep works.</p>\n</blockquote>\n<p>When you execute the grep command a process is created. Once it is through (and didn't break) it returns some code between 0 and 255. For example:</p>\n<pre><code>$ grep order myfile\n</code></pre>\n<p>If you do</p>\n<pre><code>$ echo $?\n$ 0\n</code></pre>\n<p>you will get a 0. Why? Because <a href=\"http://en.wikipedia.org/wiki/Grep\" rel=\"nofollow\">grep</a> found a match and returned an exit code 0, which is the usual value for exiting with a success. Let's check it out again but with something that is not inside our text file and thus no match will be found:</p>\n<pre><code>$ grep foo myfile\n$ echo $?\n$ 1\n</code></pre>\n<p>Since grep failed to match the token \"foo\" with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).</p>\n<p>Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:</p>\n<pre><code>$ grep foo myfile\n$ CHECK=$?\n$ [ $CHECK -eq 0] &amp;&amp; echo 'Match found'\n$ [ $CHECK -ne 0] &amp;&amp; echo 'No match was found'\n$ No match was found\n</code></pre>\n<p>After the second line nothing is printed to the terminal since \"foo\" made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.</p>\n<p>As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).</p>\n", "LastActivityDate": "2016-03-13T15:36:48.987"}, "18721336": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-09-10T14:15:12.000", "Score": "87", "LastEditorUserId": "15168", "LastEditDate": "2017-10-05T00:43:05.723", "Id": "18721336", "OwnerUserId": "15168", "Body": "<h2>Standard C \u2014 Hosted Environment</h2>\n<p>For a hosted environment (that's the normal one), the C11 standard (ISO/IEC 9899:2011) says:</p>\n<blockquote>\n<h3>5.1.2.2.1 Program startup</h3>\n<p id=\"so_204476_18721336_0\">The function called at program startup is named <code>main</code>. The implementation declares no\n  prototype for this function. It shall be defined with a return type of <code>int</code> and with no\n  parameters:</p>\n<pre><code>int main(void) { /* ... */ }\n</code></pre>\n<p id=\"so_204476_18721336_1\">or with two parameters (referred to here as <code>argc</code> and <code>argv</code>, though any names may be\n  used, as they are local to the function in which they are declared):</p>\n<pre><code>int main(int argc, char *argv[]) { /* ... */ }\n</code></pre>\n<p id=\"so_204476_18721336_2\">or equivalent;<sup>10)</sup> or in some other implementation-defined manner.</p>\n<p id=\"so_204476_18721336_3\">If they are declared, the parameters to the main function shall obey the following\n  constraints:</p>\n<ul>\n<li>The value of <code>argc</code> shall be nonnegative.</li>\n<li><code>argv[argc]</code> shall be a null pointer.</li>\n<li>If the value of <code>argc</code> is greater than zero, the array members <code>argv[0]</code> through\n  <code>argv[argc-1]</code> inclusive shall contain pointers to strings, which are given\n  implementation-defined values by the host environment prior to program startup. The\n  intent is to supply to the program information determined prior to program startup\n  from elsewhere in the hosted environment. If the host environment is not capable of\n  supplying strings with letters in both uppercase and lowercase, the implementation\n  shall ensure that the strings are received in lowercase.</li>\n<li>If the value of <code>argc</code> is greater than zero, the string pointed to by <code>argv[0]</code>\n  represents the program name; <code>argv[0][0]</code> shall be the null character if the\n  program name is not available from the host environment. If the value of <code>argc</code> is\n  greater than one, the strings pointed to by <code>argv[1]</code> through <code>argv[argc-1]</code>\n  represent the program parameters.</li>\n<li>The parameters <code>argc</code> and <code>argv</code> and the strings pointed to by the <code>argv</code> array shall\n  be modifiable by the program, and retain their last-stored values between program\n  startup and program termination.</li>\n</ul>\n<p id=\"so_204476_18721336_4\"><sup>10)</sup> Thus, <code>int</code> can be replaced by a typedef name defined as <code>int</code>, or the type of <code>argv</code> can be written as\n  <code>char **argv</code>, and so on.</p>\n</blockquote>\n<h3>Program termination in C99 or C11</h3>\n<p>The value returned from <code>main()</code> is transmitted to the 'environment' in an implementation-defined way.</p>\n<blockquote>\n<h3>5.1.2.2.3 Program termination</h3>\n<p id=\"so_204476_18721336_5\">1 If the return type of the <code>main</code> function is a type compatible with <code>int</code>, a return from the\n  initial call to the <code>main</code> function is equivalent to calling the <code>exit</code> function with the value\n  returned by the <code>main</code> function as its argument;<sup>11)</sup> reaching the <code>}</code> that terminates the\n  <code>main</code> function returns a value of 0. If the return type is not compatible with <code>int</code>, the\n  termination status returned to the host environment is unspecified.</p>\n<p id=\"so_204476_18721336_6\"><sup>11)</sup> In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in <code>main</code>\n  will have ended in the former case, even where they would not have in the latter.</p>\n</blockquote>\n<p>Note that <code>0</code> is mandated as 'success'. You can use <code>EXIT_FAILURE</code> and <code>EXIT_SUCCESS</code> from <code>&lt;stdlib.h&gt;</code> if you prefer, but 0 is well established, and so is 1. See also <a href=\"https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/\">Exit codes greater than 255 \u2014 possible?</a>.</p>\n<p>In C89 (and hence in Microsoft C), there is no statement about what happens if the <code>main()</code> function returns but does not specify a return value; it therefore leads to undefined behaviour.</p>\n<blockquote>\n<h3>7.22.4.4 The <code>exit</code> function</h3>\n<p id=\"so_204476_18721336_7\">\u00b65 Finally, control is returned to the host environment. If the value of <code>status</code> is zero or <code>EXIT_SUCCESS</code>, an implementation-defined form of the status <em>successful termination</em> is returned. If the value of <code>status</code> is <code>EXIT_FAILURE</code>, an implementation-defined form of the status <em>unsuccessful termination</em> is returned. Otherwise the status returned is implementation-defined.</p>\n</blockquote>\n<h2>Standard C++ \u2014 Hosted Environment</h2>\n<p>The C++11 standard (ISO/IEC 14882:2011) says:</p>\n<blockquote>\n<h3>3.6.1 Main function [basic.start.main]</h3>\n<p id=\"so_204476_18721336_8\">\u00b61 A program shall contain a global function called main, which is the designated start of the program. [...]</p>\n<p id=\"so_204476_18721336_9\">\u00b62 An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation defined.\n  All implementations\n  shall allow both of the following definitions of main:</p>\n<pre><code>int main() { /* ... */ }\n</code></pre>\n<p id=\"so_204476_18721336_10\">and</p>\n<pre><code>int main(int argc, char* argv[]) { /* ... */ }\n</code></pre>\n<p id=\"so_204476_18721336_11\">In the latter form <code>argc</code> shall be the number of arguments passed to the program from the environment\n  in which the program is run. If <code>argc</code> is nonzero these arguments shall be supplied in <code>argv[0]</code>\n  through <code>argv[argc-1]</code> as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and <code>argv[0]</code> shall be the pointer to the initial character of a NTMBS that represents the\n  name used to invoke the program or <code>\"\"</code>. The value of <code>argc</code> shall be non-negative. The value of <code>argv[argc]</code>\n  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after <code>argv</code>. \u2014end\n  note ]</p>\n<p id=\"so_204476_18721336_12\">\u00b63 The function <code>main</code> shall not be used within a program. The linkage (3.5) of <code>main</code> is implementation-defined. [...]</p>\n<p id=\"so_204476_18721336_13\">\u00b65 A return statement in main has the effect of leaving the main function (destroying any objects with automatic\n  storage duration) and calling <code>std::exit</code> with the return value as the argument. If control reaches the end\n  of main without encountering a return statement, the effect is that of executing</p>\n<pre><code>return 0;\n</code></pre>\n</blockquote>\n<p>The C++ standard explicitly says \"It [the main function] shall have a return type of type <code>int</code>, but otherwise its type is implementation defined\", and requires the same two signatures as the C standard to be supported as options. So a 'void main()' is directly not allowed by the C++ standard, though there's nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling <code>main</code> (but the C standard does not).</p>\n<p>There's a paragraph of \u00a718.5 <strong>Start and termination</strong> in the C++11 standard that is identical to the paragraph from \u00a77.22.4.4 <strong>The <code>exit</code> function</strong> in the C11 standard (quoted above), apart from a footnote (which simply documents that <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> are defined in <code>&lt;cstdlib&gt;</code>).</p>\n<h2>Standard C \u2014 Common Extension</h2>\n<p>Classically, Unix systems support a third variant:</p>\n<pre><code>int main(int argc, char **argv, char **envp) { ... }\n</code></pre>\n<p>The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via '<code>extern char **environ;</code>'.  For a long time, that did not have a header that declared it, but the <a href=\"http://en.wikipedia.org/wiki/POSIX\" rel=\"nofollow noreferrer\">POSIX</a> 2008 standard now requires it to be declared in <code>&lt;unistd.h&gt;</code>.</p>\n<p>This is recognized by the C standard as a common extension, documented in Annex J:</p>\n<blockquote>\n<h3>J.5.1 Environment arguments</h3>\n<p id=\"so_204476_18721336_14\">\u00b61 In a hosted environment, the main function receives a third argument, <code>char *envp[]</code>,\n  that points to a null-terminated array of pointers to <code>char</code>, each of which points to a string\n  that provides information about the environment for this execution of the program (5.1.2.2.1).</p>\n</blockquote>\n<h2>Microsoft C</h2>\n<p>The <a href=\"http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx\" rel=\"nofollow noreferrer\">Microsoft VS 2010</a> compiler is interesting. The web site says:</p>\n<blockquote>\n<p id=\"so_204476_18721336_15\">The declaration syntax for main is</p>\n<pre><code> int main();\n</code></pre>\n<p id=\"so_204476_18721336_16\">or, optionally,</p>\n<pre><code>int main(int argc, char *argv[], char *envp[]);\n</code></pre>\n<p id=\"so_204476_18721336_17\">Alternatively, the <code>main</code> and <code>wmain</code> functions can be declared as returning <code>void</code> (no return value). If you declare <code>main</code> or <code>wmain</code> as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when <code>main</code> or <code>wmain</code> is declared as <code>void</code>, you must use the <code>exit</code> function.</p>\n</blockquote>\n<p>It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with <code>void main()</code> does exit \u2014 and the MS web site is silent too.</p>\n<p>Interestingly, MS does not prescribe the two-argument version of <code>main()</code> that the C and C++ standards require. It only prescribes a three argument form where the third argument is <code>char **envp</code>, a pointer to a list of environment variables.</p>\n<p>The Microsoft page also lists some other alternatives \u2014 <code>wmain()</code> which takes wide character strings, and some more.</p>\n<p>The Microsoft <a href=\"http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005\" rel=\"nofollow noreferrer\">Visual\u00a0Studio\u00a02005</a> version of <a href=\"http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx\" rel=\"nofollow noreferrer\">this page</a> does not list <code>void main()</code> as an alternative.  The <a href=\"http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx\" rel=\"nofollow noreferrer\">versions</a> from Microsoft <a href=\"http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008\" rel=\"nofollow noreferrer\">Visual\u00a0Studio\u00a02008</a> onwards do.</p>\n<h2>Standard C \u2014 Freestanding Environment</h2>\n<p>As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called <code>main</code> and there are no constraints on its return type.  The standard says:</p>\n<blockquote>\n<h3>5.1.2 Execution environments</h3>\n<p id=\"so_204476_18721336_18\">Two execution environments are defined: freestanding and hosted. In both cases,\n  program startup occurs when a designated C function is called by the execution\n  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.</p>\n<h3>5.1.2.1 Freestanding environment</h3>\n<p id=\"so_204476_18721336_19\">In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.</p>\n<p id=\"so_204476_18721336_20\">The effect of program termination in a freestanding environment is implementation-defined.</p>\n</blockquote>\n<p>The cross-reference to clause 4 Conformance refers to this:</p>\n<blockquote>\n<p id=\"so_204476_18721336_21\">\u00b65 A <em>strictly conforming program</em> shall use only those features of the language and library specified in this International Standard.<sup>3)</sup> It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.</p>\n<p id=\"so_204476_18721336_22\">\u00b66 The two forms of conforming implementation are <em>hosted</em> and <em>freestanding</em>. A <em>conforming hosted implementation</em> shall accept any strictly conforming program. A <em>conforming freestanding implementation</em> shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers <code>&lt;float.h&gt;</code>, <code>&lt;iso646.h&gt;</code>, <code>&lt;limits.h&gt;</code>, <code>&lt;stdalign.h&gt;</code>,\n  <code>&lt;stdarg.h&gt;</code>, <code>&lt;stdbool.h&gt;</code>, <code>&lt;stddef.h&gt;</code>, <code>&lt;stdint.h&gt;</code>, and\n  <code>&lt;stdnoreturn.h&gt;</code>. A conforming implementation may have extensions (including\n  additional library functions), provided they do not alter the behavior of any strictly conforming program.<sup>4)</sup></p>\n<p id=\"so_204476_18721336_23\">\u00b67 A <em>conforming program</em> is one that is acceptable to a conforming implementation.<sup>5)</sup></p>\n<p id=\"so_204476_18721336_24\"><sup>3)</sup> A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:</p>\n<pre><code>#ifdef __STDC_IEC_559__ /* FE_UPWARD defined */\n    /* ... */\n    fesetround(FE_UPWARD);\n    /* ... */\n#endif\n</code></pre>\n<p id=\"so_204476_18721336_25\"><sup>4)</sup> This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.</p>\n<p id=\"so_204476_18721336_26\"><sup>5)</sup> Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.</p>\n</blockquote>\n<p>It is noticeable that the only header required of a freestanding environment that actually defines any functions is <code>&lt;stdarg.h&gt;</code> (and even those may be \u2014 and often are \u2014 just macros).</p>\n<h2>Standard C++ \u2014 Freestanding Environment</h2>\n<p>Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)</p>\n<blockquote>\n<h3>1.4 Implementation compliance [intro.compliance]</h3>\n<p id=\"so_204476_18721336_27\">\u00b67 Two kinds of implementations are defined: a <em>hosted implementation</em> and a <em>freestanding implementation</em>. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding\n  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).</p>\n<p id=\"so_204476_18721336_28\">\u00b68 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that\n  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.</p>\n<p id=\"so_204476_18721336_29\">\u00b69 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.<sup>3</sup></p>\n<p id=\"so_204476_18721336_30\"><sup>3)</sup> This documentation also defines implementation-defined behavior; see 1.9.</p>\n<h3>17.6.1.3 Freestanding implementations [compliance]</h3>\n<p id=\"so_204476_18721336_31\">Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.</p>\n<p id=\"so_204476_18721336_32\">A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.</p>\n<p id=\"so_204476_18721336_33\">The supplied version of the header <code>&lt;cstdlib&gt;</code> shall declare at least the functions <code>abort</code>, <code>atexit</code>, <code>at_quick_exit</code>, <code>exit</code>, and <code>quick_exit</code> (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.</p>\n<p id=\"so_204476_18721336_34\">Table 16 \u2014 C++ headers for freestanding implementations</p>\n<pre><code>Subclause                           Header(s)\n                                    &lt;ciso646&gt;\n18.2  Types                         &lt;cstddef&gt;\n18.3  Implementation properties     &lt;cfloat&gt; &lt;limits&gt; &lt;climits&gt;\n18.4  Integer types                 &lt;cstdint&gt;\n18.5  Start and termination         &lt;cstdlib&gt;\n18.6  Dynamic memory management     &lt;new&gt;\n18.7  Type identification           &lt;typeinfo&gt;\n18.8  Exception handling            &lt;exception&gt;\n18.9  Initializer lists             &lt;initializer_list&gt;\n18.10 Other runtime support         &lt;cstdalign&gt; &lt;cstdarg&gt; &lt;cstdbool&gt;\n20.9  Type traits                   &lt;type_traits&gt;\n29    Atomics                       &lt;atomic&gt;\n</code></pre>\n</blockquote>\n<h2>What about using <code>int main()</code> in C?</h2>\n<p>The standard \u00a75.1.2.2.1 of the C11 standard shows the preferred notation \u2014\u00a0<code>int main(void)</code> \u2014 but there are also two examples in the standard which show <code>int main()</code>: <a href=\"https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8\" rel=\"nofollow noreferrer\">\u00a76.5.3.4 \u00b68</a> and <a href=\"https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20\" rel=\"nofollow noreferrer\">\u00a76.7.6.3 \u00b620</a>.  Now, it is important to note that examples are not 'normative'; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes <code>int main()</code> in an example, it suggests that <code>int main()</code> is not forbidden, even if it is not the preferred notation.</p>\n<blockquote>\n<h3>6.5.3.4 The <code>sizeof</code> and <code>_Alignof</code> operators</h3>\n<p id=\"so_204476_18721336_35\">\u2026</p>\n<p id=\"so_204476_18721336_36\">\u00b68 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:</p>\n<pre><code>#include &lt;stddef.h&gt;\n\nsize_t fsize3(int n)\n{\n    char b[n+3]; // variable length array\n    return sizeof b; // execution time sizeof\n}\nint main()\n{\n    size_t size;\n    size = fsize3(10); // fsize3 returns 13\n    return 0;\n}\n</code></pre>\n</blockquote>\n", "LastActivityDate": "2017-10-05T00:43:05.723"}, "6554135": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-07-01T23:30:59.867", "Score": "1", "LastEditorUserId": "63550", "LastEditDate": "2016-03-13T15:14:52.143", "Id": "6554135", "OwnerUserId": "379888", "Body": "<p>The return value of <code>main()</code> shows how the program exited. If the return value is <code>zero</code> it means that the execution was successful while any non-zero value will represent that something went bad in the execution.</p>\n", "LastActivityDate": "2016-03-13T15:14:52.143"}, "205141": {"ParentId": "204476", "CommentCount": "3", "CreationDate": "2008-10-15T15:22:13.313", "OwnerUserId": "4086", "Id": "205141", "PostTypeId": "2", "OwnerDisplayName": "Ferruccio", "Score": "7", "Body": "<p>Keep in mind that,even though you're returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).</p>\n", "LastActivityDate": "2008-10-15T15:22:13.313"}, "8642388": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-12-27T08:02:51.533", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:43.057", "Id": "8642388", "OwnerUserId": "775964", "Body": "<p>main() in C89 and K&amp;R C unspecified return types <strong>default to int</strong></p>\n<pre><code>return 1? return 0?\n</code></pre>\n<ol>\n<li><p>If you do not write a return statement in <code>int main()</code> then the closing <code>{</code> will return 0 by default</p></li>\n<li><p>Return 0 or return 1 will be received by the environment variable of the OS. So if you are not using that environment variable then you should not worry about the return value of <code>main()</code>.</p></li>\n</ol>\n<p>See <em><a href=\"https://stackoverflow.com/q/8626109/775964\">How can I get what my main function has returned?</a></em>.</p>\n<pre><code>$ ./a.out\n$ echo $?\n</code></pre>\n<p>This way you can see that it is the <strong>environment variable</strong> <code>$?</code> which receives the last one byte of return value of <code>main()</code>.</p>\n<p>So if you are writing any script then you should take care of the return value of <code>main()</code>, otherwise don't.</p>\n<p>In Unix and DOS scripting, return 0 on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.</p>\n", "LastActivityDate": "2016-03-13T15:18:04.473"}, "204483": {"CommentCount": "18", "CreationDate": "2008-10-15T12:16:08.277", "LastEditorUserId": "15168", "LastActivityDate": "2013-07-18T05:26:23.697", "ParentId": "204476", "PostTypeId": "2", "LastEditorDisplayName": "workmad3", "LastEditDate": "2013-07-18T05:26:23.697", "Id": "204483", "Score": "418", "Body": "<p>The return value for <code>main</code> should indicate how the program exited. Normal exit is generally represented by a 0 return value from <code>main</code>. Abnormal termination is usually signalled by a non-zero return but there is no standard for how non-zero codes are interpreted. Also as noted by others, <code>void main()</code> is explicitly prohibited by the C++ standard and shouldn't be used. The valid C++ <code>main</code> signatures are:</p>\n<pre><code>int main()\n</code></pre>\n<p>and</p>\n<pre><code>int main(int argc, char* argv[])\n</code></pre>\n<p>which is equivalent to</p>\n<pre><code>int main(int argc, char** argv)\n</code></pre>\n<p>It's also worth noting that in C++, <code>int main()</code> can be left without a return value at which point it defaults to returning 0. This is also true with a C99 program. Whether return 0 should be omitted or not is open to debate. The range of valid C program main signatures is much greater.  </p>\n<p>Also, efficiency is not an issue with the <code>main</code> function. It can only be entered and left once (marking program start and termination) according to the C++ standard. For C, the case is different and re-entering <code>main()</code> is allowed, but should probably be avoided. </p>\n", "OwnerUserId": "16035", "OwnerDisplayName": "workmad3"}, "5180411": {"ParentId": "204476", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-03-03T11:56:57.407", "Score": "1", "LastEditorUserId": "63550", "LastEditDate": "2016-03-13T15:12:55.730", "Id": "5180411", "OwnerUserId": "571410", "Body": "<p>If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.</p>\n<p>If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.</p>\n<p>In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.</p>\n", "LastActivityDate": "2016-03-13T15:12:55.730"}});