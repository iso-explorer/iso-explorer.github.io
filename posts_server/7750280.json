post_cb({"7750388": {"Id": "7750388", "PostTypeId": "2", "Body": "<p>When you have a pointer to an object, it points to a block of memory that has both the data for that object and a 'vtable pointer.'  In microsoft compilers, the vtable pointer is the first piece of data in the object.  In Borland compilers, it is the last.  Either way, it points to a vtable that represents a list of function vectors corresponding to the virtual methods that can be invoked for that object/class.  The virtual destructor is just another vector in that list of function pointer vectors.</p>\n", "LastActivityDate": "2011-10-13T06:46:18.463", "CommentCount": "0", "CreationDate": "2011-10-13T06:46:18.463", "ParentId": "7750280", "Score": "0", "OwnerUserId": "284758"}, "7750314": {"Id": "7750314", "PostTypeId": "2", "Body": "<p>It's up to the compiler how to implement it and typically it's done with the same mechanism as other virtual methods. In other words there's nothing special about destructors that requires a virtual method dispatch mechanism that is distinct from that used by normal methods.</p>\n", "LastActivityDate": "2011-10-13T06:38:47.280", "CommentCount": "2", "CreationDate": "2011-10-13T06:38:47.280", "ParentId": "7750280", "Score": "1", "OwnerUserId": "505088"}, "7750321": {"Id": "7750321", "PostTypeId": "2", "Body": "<p>A virtual destructor has an entry in the virtual table just as other virtual functions do. When the destructor is invoked -either manually or automatically from a call to <code>delete</code>- the most derived version is invoked. A destructor also automatically calls the destructor for its base classes, so that in combination with the virtual dispatch is what causes the <strong>magic</strong>.</p>\n", "LastActivityDate": "2011-10-13T06:39:37.997", "CommentCount": "3", "CreationDate": "2011-10-13T06:39:37.997", "ParentId": "7750280", "Score": "1", "OwnerUserId": "927034"}, "7750578": {"Id": "7750578", "PostTypeId": "2", "Body": "<p>Unlike other virtual functions, when you override a virtual destructor, your object's virtual destructor is called <em>in addition</em> to any inherited virtual destructors. </p>\n<p>Technically this can be achieved by whatever means the compiler chooses, but almost all compilers achieve this via static memory called a <em>vtable</em>, which permits polymorphism on functions and destructors. For each class in your source code, a static constant vtable is generated for it at compile time. When an object of type T is constructed at runtime, the object's memory is initialized with a hidden <em>vtable pointer</em> which points to the T's vtable in ROM. Inside the vtable is a list of member function pointers and a list of destructor function pointers. When a variable of any type that has a vtable goes out of scope or is deleted with delete or delete[], all of the destructor pointers in vtable the object points to are all invoked. (Some compilers choose to only store the most derived destructor pointer in the table, and then include a hidden invocation of the superclass's destructor in the body of every virtual destructor if one exists. This results in equivalent behavior.)</p>\n<p>Additional magic is needed for virtual and nonvirtual multiple inheritance. Assume I am deleting a pointer p, where p is of the type of a base-class. We need to invoke the destructor of the sub-classes with <strong>this</strong>=p. But using multiple inheritance, p and the start of the derived object may not be the same! There is a fixed offset which must be applied. There is one such offset stored in the vtable for each class that is inherited, as well as a set of inherited offsets.</p>\n", "LastEditorUserId": "981367", "LastActivityDate": "2011-10-13T07:29:01.740", "Score": "1", "CreationDate": "2011-10-13T07:09:14.240", "ParentId": "7750280", "CommentCount": "1", "OwnerUserId": "981367", "LastEditDate": "2011-10-13T07:29:01.740"}, "7750873": {"Id": "7750873", "PostTypeId": "2", "Body": "<p>A suitable implementation of (virtual) destructors the compiler might use would be (in pseudocode)</p>\n<pre><code>class Base {\n...\n  virtual void __destruct(bool should_delete);\n...\n};\n\nvoid Base::__destruct(bool should_delete)\n{\n  this-&gt;__vptr = &amp;Base::vtable; // Base is now the most derived subobject\n\n  ... your destructor code ...\n\n  members::__destruct(false); // if any, in the reverse order of declaration\n  base_classes::__destruct(false); // if any\n  if(should_delete)\n    operator delete(this);  // this would call operator delete defined here, or inherited\n}\n</code></pre>\n<p>This function gets defined even if you didn't define a destructor. Your code would just be empty in that case.</p>\n<p>Now all derived classes would override (automatically) this virtual function:</p>\n<pre><code>class Der : public Base {\n...\n  virtual void __destruct(bool should_delete);\n...\n};\n\nvoid Der::__destruct(bool should_delete)\n{\n  this-&gt;__vptr = &amp;Der::vtable;\n\n  ... your destructor code ...\n\n  members::__destruct(false);\n  Base::__destruct(false);\n  if(should_delete)\n    operator delete(this);\n}\n</code></pre>\n<p>A call <code>delete x</code>, where <code>x</code> is of pointer to class type, would be translated as</p>\n<pre><code>x-&gt;__destruct(true);\n</code></pre>\n<p>and any other destructor call (implicit due to variable going out of scope, explicit <code>x.~T()</code>) would be</p>\n<pre><code>x.__destruct(false);\n</code></pre>\n<p>This results in</p>\n<ul>\n<li>the most derived destructor always being called (for virtual destructors)</li>\n<li>operator delete from the most derived object being called</li>\n<li>all members' and base classes' destructors being called.</li>\n</ul>\n<p>HTH. This should be understandable if you understand virtual functions.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-10-13T10:19:09.130", "Score": "2", "CreationDate": "2011-10-13T07:37:43.190", "ParentId": "7750280", "CommentCount": "10", "OwnerUserId": "51831", "LastEditDate": "2011-10-13T10:19:09.130"}, "7750309": {"Id": "7750309", "PostTypeId": "2", "Body": "<p>As usual with virtual functions there will be some implementation mechanism (like a vtable pointer) that will let the compiler find which destructor to run first depending on the type of the object. Once the most derived class destructor is run it will in turn run the base class destructor and so on.</p>\n", "LastActivityDate": "2011-10-13T06:38:16.123", "CommentCount": "0", "CreationDate": "2011-10-13T06:38:16.123", "ParentId": "7750280", "Score": "2", "OwnerUserId": "57428"}, "bq_ids": {"n4140": {"so_7750280_7751040_0": {"length": 24, "quality": 0.5106382978723404, "section_id": 447}}, "n3337": {"so_7750280_7751040_0": {"length": 24, "quality": 0.5106382978723404, "section_id": 438}}, "n4659": {"so_7750280_7751040_0": {"length": 24, "quality": 0.5106382978723404, "section_id": 469}}}, "7750308": {"Id": "7750308", "PostTypeId": "2", "Body": "<p>A <em>virtual</em> destructor is treated in the same way as any other <code>virtual</code> function. I note that you've <em>correctly</em> maked the base class's destructor as <code>virtual</code>. As such, it is no way different than any other <code>virtual</code> function, as far as dynamic dispatch is concerned. <em>The most derived class destructor gets called through dynamic dispatch but it also automatically results in calls to Base class destructors of the class<sup>1</sup></em>.</p>\n<p>Most compiler implements this feature using <code>vtable</code> and <code>vptr</code>, though the language specification does not mandate it. There can be a compiler which does this differently, without using <code>vtable</code> and <code>vptr</code>.</p>\n<p>Anyway, as it true for most compilers, it is worth knowing what <code>vtable</code> is. So <code>vtable</code> is a table contains pointers of all virtual functions the class defines, and the compiler adds <code>vptr</code> to the class as <em>hidden pointer</em> which points to the correct <code>vtable</code>, so the compiler uses correct index, calculated at compile-time, to the <code>vtable</code> so as to dispatch the correct <em>virtual</em> function at runtime. </p>\n<p><sup>1. The <em>italicized</em> text is taken from @Als's comment. Thanks to him. It makes things more clear.</sup></p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-10-13T08:01:29.773", "Score": "4", "CreationDate": "2011-10-13T06:38:15.443", "ParentId": "7750280", "CommentCount": "4", "OwnerUserId": "415784", "LastEditDate": "2011-10-13T08:01:29.773"}, "7750280": {"ViewCount": "6154", "Body": "<p>I will  type an example :</p>\n<pre><code>class A\n{\npublic:\nvirtual ~A(){}\n};\n\nclass B: public A\n{\npublic:\n~B()\n{\n}\n\n};\n\n\n\nint main(void)\n{\nA * a =  new B;\ndelete a;\nreturn 0;\n}\n</code></pre>\n<p>Now in Above Example , destructors  will be called recursively bottom to up .\nMy Question is how Compiler do this MAGIC .</p>\n", "Title": "How Does Virtual Destructor work in C++", "CreationDate": "2011-10-13T06:36:03.463", "LastActivityDate": "2011-10-13T17:38:37.873", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "Id": "7750280", "Score": "11", "OwnerUserId": "820720", "Tags": "<c++>", "AnswerCount": "8"}, "7751040": {"Id": "7751040", "PostTypeId": "2", "Body": "<p>There are two different pieces of <em>magic</em> in your question. The first one is how does the compiler call the final overrider for the destructor and the second one is how does it then call all the other destructors in order.</p>\n<p>Disclaimer: The standard does not mandate any particular way of performing this operations, it only mandates what the behavior of the operations at a higher level are. These are implementation details that are common to various implementations, but not mandated by the standard.</p>\n<p><strong>How does the compiler dispatch to the final overrider?</strong></p>\n<p>The first answer is the simple one, the same dynamic dispatch mechanism that is used for other <code>virtual</code> functions is used for destructors. To refresh it, each object stores a pointer (<code>vptr</code>) to each of its <code>vtable</code>s (in the event of multiple inheritance there can be more than one), when the compiler sees a call to any virtual function, it follows the <code>vptr</code> of the static type of the pointer to find the <code>vtable</code> and then uses the pointer in that table to forward the call. In most cases the call can be directly dispatched, in others (multiple inheritance) it calls some intermediate code (<em>thunk</em>) that fixes the <code>this</code> pointer to refer to the type of the <em>final overrider</em> for that function.</p>\n<p><strong>How does the compiler then call the base destructors?</strong></p>\n<p>The process of destructing an object takes more operations than those you write inside the body of the destructor. When the compiler generates the code for the destructor, it adds extra code both before and after the user defined code. </p>\n<p>Before the first line of a user defined destructor is called, the compiler injects code that will make the type of the object be that of the destructor being called. That is, right before <code>~derived</code> is entered, the compiler adds code that will modify the <code>vptr</code> to refer to the <code>vtable</code> of <code>derived</code>, so that effectively, the runtime type of the object <em>becomes</em> <code>derived</code> <sup>(*)</sup>.</p>\n<p>After the last line of your user defined code, the compiler injects calls to the member destructors as well as base destructor(s). This is performed <em>disabling</em> dynamic dispatch, which means that it will no longer come all the way down to the just executed destructor. It is the equivalent of adding <code>this-&gt;~mybase();</code> for each base of the object (in reverse order of declaration of the bases) at the end of the destructor.</p>\n<p>With virtual inheritance, things get a bit more complex, but overall they follow this pattern.</p>\n<p><em>EDIT</em> (forgot the <sup>(*)</sup>):\n<sup>(*)</sup> The standard mandates in \u00a712/3:</p>\n<blockquote>\n<p id=\"so_7750280_7751040_0\">When a virtual function is called directly or indirectly from a constructor (including from the mem-initializer for a data member) or from a destructor, and the object to which the call applies is the object under construction or destruction, the function called is the one defined in the constructor or destructor\u2019s own class or in one of its bases, but not a function overriding it in a class derived from the con- structor or destructor\u2019s class, or overriding it in one of the other base classes of the most derived object.</p>\n</blockquote>\n<p>That requirement implies that the runtime type of the object is that of the class being constructed/destructed at this time, even if the original object that is being constructed/destructed is of a derived type. A simple test to verify this implementation can be:</p>\n<pre><code>struct base {\n   virtual ~base() { f(); }\n   virtual void f() { std::cout &lt;&lt; \"base\"; }\n};\nstruct derived : base {\n   void f() { std::cout &lt;&lt; \"derived\"; }\n};\nint main() {\n   base * p = new derived;\n   delete p;\n}\n</code></pre>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-10-13T17:38:37.873", "Score": "9", "CreationDate": "2011-10-13T07:55:52.673", "ParentId": "7750280", "CommentCount": "3", "OwnerUserId": "36565", "LastEditDate": "2011-10-13T17:38:37.873"}});