post_cb({"25925551": {"CommentCount": "7", "AcceptedAnswerId": "26005482", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2014-09-19T02:41:35.010", "LastActivityDate": "2014-09-23T22:09:34.253", "LastEditDate": "2014-09-21T11:44:05.320", "ViewCount": "838", "FavoriteCount": "8", "Title": "gcc and clang implicitly instantiate template arguments during operator overload resolution", "Id": "25925551", "Score": "32", "Body": "<p>Consider this code:</p>\n<pre><code>struct A; // incomplete type\n\ntemplate&lt;class T&gt;\nstruct D { T d; };\n\ntemplate &lt;class T&gt;\nstruct B { int * p = nullptr; };\n\nint main() {\n    B&lt;D&lt;A&gt;&gt; u, v;\n    u = v;  // doesn't compile; complain that D&lt;A&gt;::d has incomplete type\n    u.operator=(v); // compiles\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/bee4448c4b33d91f\">Demo</a>. Since <code>u.operator=(v)</code> compiles but <code>u = v;</code> doesn't, somewhere during the overload resolution for the latter expression the compiler must have implicitly instantiated <code>D&lt;A&gt;</code> - but I don't see why that instantiation is required. </p>\n<p>To make things more interesting, this code compiles:</p>\n<pre><code>struct A; // incomplete type\n\ntemplate&lt;class T&gt;\nstruct D; // undefined\n\ntemplate &lt;class T&gt;\nstruct B { int * p = nullptr; };\n\nint main() {\n    B&lt;D&lt;A&gt;&gt; u, v;\n    u = v;\n    u.operator=(v);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/abdf8b03af21d782\">Demo</a>.</p>\n<p>What's going on here? Why does <code>u = v;</code> cause the implicit instantiation of <code>D&lt;A&gt;</code> - a type that's nowhere used in the body of <code>B</code>'s definition - in the first case but not the second?</p>\n", "Tags": "<c++><templates><gcc><clang>", "OwnerUserId": "2756719", "AnswerCount": "2"}, "26005482": {"ParentId": "25925551", "CommentCount": "7", "Body": "<p>The entire point of the matter is <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"noreferrer\">ADL</a> kicking in:</p>\n<p>N3797 - [basic.lookup.argdep]</p>\n<blockquote>\n<p id=\"so_25925551_26005482_0\">When the postfix-expression in a function call (5.2.2) is an unqualified-id, other namespaces not considered\n  during the usual unqualified lookup (3.4.1) may be searched, and in those namespaces, namespace-scope\n  friend function or function template declarations (11.3) not otherwise visible may be found.</p>\n</blockquote>\n<p>following:</p>\n<blockquote>\n<p id=\"so_25925551_26005482_1\">For each argument type T in the function call, there is a set of zero or more associated namespaces and a\n  set of zero or more associated classes to be considered. [...] The sets of\n  namespaces and classes are determined in the following way:</p>\n<ul>\n<li>If T is a class type [..] its associated classes are: ...\n  furthemore if T is a class template specialization its associated namespaces and classes also include: the namespaces and classes associated with the\n  types of the template arguments provided for template type parameters</li>\n</ul>\n</blockquote>\n<p><code>D&lt;A&gt;</code> is an associated class and therefore in the list waiting for its turn.</p>\n<p>Now for the interesting part [temp.inst]/1</p>\n<blockquote>\n<p id=\"so_25925551_26005482_2\">Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3), \n  the class template specialization is implicitly instantiated [...] <strong>when the completeness of the class type affects the semantics of the program</strong></p>\n</blockquote>\n<p>One could think that the completeness of the type <code>D&lt;A&gt;</code> doesn't affect at all the semantic of that program, however [basic.lookup.argdep]/4 says:</p>\n<blockquote>\n<p id=\"so_25925551_26005482_3\">When considering an associated namespace, the lookup is the same as the lookup performed when the associated namespace is used as a qualifier (3.4.3.2)\n  except that:</p>\n<p id=\"so_25925551_26005482_4\">[...]\n  Any namespace-scope friend functions or friend function templates declared in associated classes are visible within their respective \n  namespaces even if they are not visible during an ordinary lookup (11.3)</p>\n</blockquote>\n<p>i.e. the completeness of the class type <strong>actually affects</strong> friends declarations -&gt; the completeness of the class type therefore affects the semantics of the program.\nThat is also the reason why your second sample works.</p>\n<p><strong>TL;DR</strong> <code>D&lt;A&gt;</code> is instantiated.</p>\n<p>The last interesting point regards why ADL starts in the first place for</p>\n<pre><code>u = v; // Triggers ADL\nu.operator=(v); // Doesn't trigger ADL\n</code></pre>\n<p>\u00a713.3.1.2/2 dictates that there can be no non-member <code>operator=</code> (other than the built-in ones). Join this to [over.match.oper]/2:</p>\n<blockquote>\n<p id=\"so_25925551_26005482_5\">The set of non-member candidates is the result of the unqualified lookup of operator@ in the context\n  of the expression according to the usual rules for name lookup in unqualified function calls (3.4.2)\n  except that all member functions are ignored.</p>\n</blockquote>\n<p>and the logical conclusion is: there's no point in performing the ADL lookup if there's no non-member form in table 11. However [temp.inst]p7 relaxes this:</p>\n<blockquote>\n<p id=\"so_25925551_26005482_6\">If the overload resolution process can determine the correct function to call without instantiating a class template definition, it is unspecified whether that instantiation actually takes place.</p>\n</blockquote>\n<p>and that's the reason why clang triggered the entire <code>ADL -&gt; implicit instantiation</code> process in the first place.</p>\n<p>Starting from <a href=\"https://www.mail-archive.com/cfe-commits@cs.uiuc.edu/msg106405.html\" rel=\"noreferrer\">r218330</a> (at the time of writing this, it has been committed a few minutes ago) this behavior was changed not to perform ADL for <code>operator=</code> at all.</p>\n<hr>\n<p><strong>References</strong></p>\n<ul>\n<li><a href=\"https://www.mail-archive.com/cfe-commits@cs.uiuc.edu/msg106405.html\" rel=\"noreferrer\">r218330</a></li>\n<li><a href=\"https://github.com/llvm-mirror/clang\" rel=\"noreferrer\">clang sources</a> / <em>Sema</em> module</li>\n<li><a href=\"http://clang-developers.42468.n3.nabble.com/ADL-causing-implicit-template-class-instantiation-failure-td4041705.html\" rel=\"noreferrer\">cfe-dev</a></li>\n<li><a href=\"https://isocpp.org/files/papers/N3797.pdf\" rel=\"noreferrer\">N3797</a></li>\n</ul>\n<p>Thanks to Richard Smith and David Blaikie for helping me figuring this out.</p>\n</hr>", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26005482", "Score": "19", "CreationDate": "2014-09-23T22:09:34.253", "LastActivityDate": "2014-09-23T22:09:34.253"}, "bq_ids": {"n4140": {"so_25925551_26005482_1": {"section_id": 7104, "quality": 0.9166666666666666, "length": 22}, "so_25925551_26005482_3": {"section_id": 7106, "quality": 0.9285714285714286, "length": 13}, "so_25925551_26005482_2": {"section_id": 233, "quality": 0.8636363636363636, "length": 19}, "so_25925551_26005482_0": {"section_id": 7103, "quality": 0.8928571428571429, "length": 25}, "so_25925551_26005482_5": {"section_id": 584, "quality": 0.9166666666666666, "length": 22}, "so_25925551_26005482_4": {"section_id": 7106, "quality": 0.9090909090909091, "length": 20}, "so_25925551_26005482_6": {"section_id": 239, "quality": 1.0, "length": 18}}, "n3337": {"so_25925551_26005482_1": {"section_id": 6848, "quality": 0.9166666666666666, "length": 22}, "so_25925551_26005482_3": {"section_id": 6850, "quality": 0.9285714285714286, "length": 13}, "so_25925551_26005482_2": {"section_id": 226, "quality": 0.8636363636363636, "length": 19}, "so_25925551_26005482_0": {"section_id": 6847, "quality": 0.8214285714285714, "length": 23}, "so_25925551_26005482_5": {"section_id": 574, "quality": 0.9166666666666666, "length": 22}, "so_25925551_26005482_4": {"section_id": 6850, "quality": 0.9090909090909091, "length": 20}, "so_25925551_26005482_6": {"section_id": 231, "quality": 1.0, "length": 18}}, "n4659": {"so_25925551_26005482_1": {"section_id": 8605, "quality": 0.75, "length": 18}, "so_25925551_26005482_3": {"section_id": 8607, "quality": 0.9285714285714286, "length": 13}, "so_25925551_26005482_6": {"section_id": 248, "quality": 0.7222222222222222, "length": 13}, "so_25925551_26005482_0": {"section_id": 8604, "quality": 0.8928571428571429, "length": 25}, "so_25925551_26005482_5": {"section_id": 607, "quality": 0.9166666666666666, "length": 22}, "so_25925551_26005482_4": {"section_id": 8607, "quality": 0.9090909090909091, "length": 20}, "so_25925551_26005482_2": {"section_id": 242, "quality": 0.8636363636363636, "length": 19}}}, "25999904": {"ParentId": "25925551", "CommentCount": "0", "Body": "<p>Well, I think in Visual Studio 2013 code should look like(without = nullptr):</p>\n<pre><code>  struct A; // incomplete type\n\n  template&lt;class T&gt;\n  struct D { T d; };\n\n  template &lt;class T&gt;\n  struct B { int * p; };\n\n  int void_main() {\n    B&lt;D&lt;A&gt;&gt; u, v;\n    u = v;          //  compiles\n    u.operator=(v); // compiles\n    return 0;\n    }\n</code></pre>\n<p>In this case it should compile well just because incomplete types can be used for specific template class specialization usage.</p>\n<p>As for the run-time error - the variable v used without initialization - it's correct - struct B does not have any constructor =&gt; B::p is not initialized and could contain garbage.</p>\n", "OwnerUserId": "4066224", "PostTypeId": "2", "Id": "25999904", "Score": "-2", "CreationDate": "2014-09-23T16:14:06.827", "LastActivityDate": "2014-09-23T16:14:06.827"}});