post_cb({"10218205": {"CommentCount": "1", "Body": "<pre><code>for(int i = 0; i &lt; 50;i++)delete var[i];\ndelete[] var;\n</code></pre>\n", "CreationDate": "2012-04-18T21:21:33.923", "ParentId": "10218182", "Id": "10218205", "LastActivityDate": "2012-04-18T21:21:33.923", "PostTypeId": "2", "Score": "-2", "OwnerUserId": "1174201"}, "10218208": {"LastActivityDate": "2012-04-18T21:31:58.097", "CommentCount": "5", "Body": "<pre><code>Class* var[50];\nvar[0] = new SubClass();\n\ndelete[] *var;\n</code></pre>\n<p>This is undefined behavior. The proper way is</p>\n<pre><code>delete var[0]; //equivalent to delete *var;\n</code></pre>\n<p>If you allocate memory for all 50 elements of the array, then you have to iterate and delete each one of them. Think of it this way:</p>\n<ul>\n<li>for every <code>new</code>, you should have an associated <code>delete</code></li>\n<li>for every <code>new[]</code>, you should have an associate <code>delete[]</code></li>\n<li>don't mix up <code>new</code> with <code>delete[]</code> and <code>new[]</code> with <code>delete</code> as it leads to undefined behavior</li>\n</ul>\n<p>Your second snippet is illegal C++.</p>\n<p><strong>EDIT</strong> As you're clearly a beginner, let's break this down a bit. Since the second snippet doesn't even compile, I'm going to focus on the first one:</p>\n<pre><code>Class* var[50];\n</code></pre>\n<p>This declares an array of 50 pointers to <code>Class</code>. The pointers are dangling - they are not initialized and <code>Class</code> objects aren't created.</p>\n<pre><code>var[0] = new SubClass();\n</code></pre>\n<p>This allocates memory for a <code>SubClass</code> object and assigns the first pointer in the array. All other pointers remain uninitialized. </p>\n<pre><code>*var;\n</code></pre>\n<p>returns the first element, which is a <code>Class*</code>. It's equivalent to <code>var[0]</code>.</p>\n<pre><code>delete[] *var;\n</code></pre>\n<p>attempts to call <code>delete[]</code> on a <code>Class*</code>, which was allocated with <code>new</code>, so it results in undefined behavior.</p>\n", "CreationDate": "2012-04-18T21:21:46.693", "LastEditDate": "2012-04-18T21:31:58.097", "ParentId": "10218182", "Id": "10218208", "LastEditorUserId": "673730", "PostTypeId": "2", "Score": "0", "OwnerUserId": "673730"}, "bq_ids": {"n4140": {"so_10218182_10218301_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 7182}}, "n3337": {"so_10218182_10218301_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 6926}}}, "10218340": {"CommentCount": "17", "Body": "<p>The proper way is to use a resource-managing class like <code>std::vector&lt;std::unique_ptr&lt;MyClass&gt;&gt;</code>. This will always guarantee correct resource cleanup with no user intervention. Any C++ code which sees <code>delete</code>, <code>new[]</code> or <code>delete[]</code> used should be immediately refactored to avoid them- and <code>new</code> should have a second look taken.</p>\n", "CreationDate": "2012-04-18T21:30:44.850", "ParentId": "10218182", "Id": "10218340", "LastActivityDate": "2012-04-18T21:30:44.850", "PostTypeId": "2", "Score": "3", "OwnerUserId": "298661"}, "10218301": {"LastActivityDate": "2012-04-18T22:33:25.727", "CommentCount": "0", "Body": "<p><code>delete[]</code> is for dynamically allocated arrays. It corresponds to <code>new []</code>.</p>\n<p>Excerpt from C++ Open Standards (3.7.4.2)</p>\n<blockquote>\n<p id=\"so_10218182_10218301_0\">If a deallocation function terminates by throwing an exception, the\n  behavior is undefined. The value of the first argument supplied to a\n  deallocation function may be a null pointer value; if so, and if the\n  deallocation function is one supplied in the standard library, the\n  call has no effect. Otherwise, <strong>the value supplied to operator\n  delete(void*)</strong> in the standard library shall be one of the values\n  returned by a previous invocation of either operator <strong>new(std::size_t)</strong>\n  or operator new(std::size_t, const std::nothrow_t&amp;) in the standard\n  library, and <strong>the value supplied to operator delete[](void*)</strong> in the\n  standard library shall be one of the values returned by a previous\n  invocation of either operator <strong>new[](std::size_t)</strong> or operator\n  new[](std::size_t, const std::nothrow_t&amp;) in the standard library.</p>\n</blockquote>\n<p>Your first example does not use <code>new []</code> so you are not supposed to use <code>delete []</code> !!!</p>\n", "CreationDate": "2012-04-18T21:28:13.293", "LastEditDate": "2012-04-18T22:33:25.727", "ParentId": "10218182", "Id": "10218301", "LastEditorUserId": "205955", "PostTypeId": "2", "Score": "0", "OwnerUserId": "205955"}, "10218182": {"CreationDate": "2012-04-18T21:19:39.370", "ViewCount": "148", "Id": "10218182", "AcceptedAnswerId": "10218208", "Score": "0", "Title": "Deleting an array of classes", "LastEditorUserId": "1136671", "CommentCount": "7", "Body": "<p>Would the following properly destroy everything (all appropriate destructors called and all memory freed)?</p>\n<pre><code>Class* var[50];\nvar[0] = new SubClass();\n\ndelete[] *var;\n</code></pre>\n<p>Similar to</p>\n<pre><code>Class** var = new Class*[50];\nvar[0] = new SubClass();\n\ndelete[] var;\n</code></pre>\n<p>Or should I be iterating over the array and delete each individual object (which is what I thought delete[] did).</p>\n", "Tags": "<c++>", "LastEditDate": "2012-04-18T21:37:42.497", "LastActivityDate": "2012-04-18T22:33:25.727", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "1136671"}});