post_cb({"2421590": {"ParentId": "2421492", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I've done my best to assemble all the relevant clauses from the ISO/IEC 14882:1997.</p>\n<p>Section 9.7:</p>\n<blockquote>\n<p id=\"so_2421492_2421590_0\">A class defined within another is called a nested class. The name of a nested class is local to its enclosing class. The nested class is in the scope of its enclosing class.  Except by using explicit pointers, references, and object names, declarations in a nested class can use only <strong>type names</strong>, static members, and enumerators from the enclosing class.</p>\n</blockquote>\n<p>11.2.1 (should be fairly obvious):</p>\n<blockquote>\n<p id=\"so_2421492_2421590_1\">[...] If a class is declared to be a base class for another class using the private access specifier, the public and protected members of the base class are accessible as private members of the derived class.</p>\n</blockquote>\n<p>9.9 Nested Type Names:</p>\n<blockquote>\n<p id=\"so_2421492_2421590_2\">Type names obey exactly the same scope rules as other names.</p>\n</blockquote>\n<p>Then in 11.8:</p>\n<blockquote>\n<p id=\"so_2421492_2421590_3\">The members of a nested class have no special access to members of an enclosing class, nor to classes or functions that have granted friendship to an enclosing class; the usual access rules (11) shall be obeyed.  The members of an enclosing class have no special access to members of a nested class; the usual access rules (11) shall be obeyed.</p>\n</blockquote>\n<p>From which I conclude that the behaviour you're experiencing is non-standard.  The nested class shouldn't have any 'special' access to the private member of the base.</p>\n<p>However, Comeau C++, which seems to have the best standard support, has the same behaviour as GCC (allows <code>fred</code>, disallows <code>bar</code> with \"error: type \"Base::priv_t\" (declared at line 4) is inaccessible\").</p>\n", "OwnerUserId": "135385", "LastEditorUserId": "135385", "LastEditDate": "2010-03-11T00:11:25.407", "Id": "2421590", "Score": "1", "CreationDate": "2010-03-10T23:55:02.450", "LastActivityDate": "2010-03-11T00:11:25.407"}, "2421589": {"ParentId": "2421492", "CommentCount": "1", "Body": "<p>This doesn't answer your question, but according to my reading of <a href=\"http://www.parashift.com/c++-faq-lite/private-inheritance.html#faq-24.6\" rel=\"nofollow noreferrer\">the C++ FAQ Lite 24.6</a> what you are trying to do isn't allowed. I'm not sure why gcc is permitting it; have you tried it in other compilers as well?</p>\n", "OwnerUserId": "153535", "PostTypeId": "2", "Id": "2421589", "Score": "0", "CreationDate": "2010-03-10T23:54:56.503", "LastActivityDate": "2010-03-10T23:54:56.503"}, "2421578": {"ParentId": "2421492", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As per the standard:</p>\n<blockquote>\n<p id=\"so_2421492_2421578_0\"><strong>9.2 Class members</strong></p>\n<p id=\"so_2421492_2421578_1\"><strong>1</strong> [...] Members of a class are data members, member functions (9.3), nested types,\n  and enumerators. Data members and member functions are static or non-static; see 9.4.Nested types are\n  classes (9.1, 9.7) and enumerations (7.2) defined in the class, and arbitrary types declared as members by use\n  of a typedef declaration (7.1.3).</p>\n</blockquote>\n<p>To answer your questions:</p>\n<blockquote id=\"so_2421492_2421578_2\">\n<ol>\n<li>Is this standard behaviour? (a decent explanation of why would be\n  very helpful)</li>\n</ol>\n</blockquote>\n<p>No. At least with the <code>typedef</code>s not being accessible. However, note that:</p>\n<pre><code>class Nested {\n    // Not allowed since Nested has no access to PubDerived member data\n     void foo() {std::cout &lt;&lt; pub &lt;&lt; \"\\n\";}\n</code></pre>\n<p>is problematic. The nested class neither has an instance of <code>PubDerived</code> to work with nor is the <code>pub</code> a <code>static</code> member object. </p>\n<blockquote id=\"so_2421492_2421578_3\">\n<ol start=\"2\">\n<li>Can one expect it to work on most modern compilers (i.e., how\n  portable is it)?</li>\n</ol>\n</blockquote>\n<p>Yes. But do check the documentation for standards compliance. And always: Try out with a few compilers such as Comeau in strict mode.</p>\n", "OwnerUserId": "66692", "LastEditorUserId": "66692", "LastEditDate": "2010-03-10T23:59:09.613", "Id": "2421578", "Score": "1", "CreationDate": "2010-03-10T23:53:23.853", "LastActivityDate": "2010-03-10T23:59:09.613"}, "4528154": {"ParentId": "2421492", "CommentCount": "1", "Body": "<p>Short answer: Nested classes have access to the containing classes private member in C++0x, but not C++1998 and C++2003. It is however <em>legal</em> for C++98 and C++2003 compilers support the C++0x behavior, since the old behavior is considered a defect.</p>\n<p>In the C++98 and 2003 standards section 11.8.1 stated:</p>\n<blockquote>\n<p id=\"so_2421492_4528154_0\">The members of a nested class have no\n  special access to members of an\n  enclosing class, nor to classes or\n  functions that have granted friendship\n  to an enclosing class; the usual\n  access rules (clause 11) shall be\n  obeyed. The members of an enclosing\n  class have no special access to\n  members of a nested class; the usual\n  access rules (clause 11) shall be\n  obeyed.</p>\n</blockquote>\n<p>C++0x section 11.8.1 says:</p>\n<blockquote>\n<p id=\"so_2421492_4528154_1\">A nested class is a member and as such\n  has the same access rights as any\n  other member. The members of an\n  enclosing class have no special access\n  to members of a nested class; the\n  usual access rules (Clause 11) shall\n  be obeyed.</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#45\" rel=\"nofollow\">Core Language Defect Report 45</a> shows that the original behavior was considered a defect, so it is legal for non-c++0x compilers to also support the new behavior, although not required.</p>\n", "OwnerUserId": "14978", "PostTypeId": "2", "Id": "4528154", "Score": "2", "CreationDate": "2010-12-24T20:09:44.693", "LastActivityDate": "2010-12-24T20:09:44.693"}, "2421492": {"CommentCount": "3", "AcceptedAnswerId": "2421671", "PostTypeId": "1", "LastEditorUserId": "1448363", "CreationDate": "2010-03-10T23:35:26.583", "LastActivityDate": "2013-02-15T23:35:01.400", "LastEditDate": "2013-02-15T23:35:01.400", "ViewCount": "3095", "FavoriteCount": "3", "Title": "Visibility of privately inherited typedefs to nested classes", "Id": "2421492", "Score": "8", "Body": "<p>In the following example (apologies for the length) I have tried to isolate some unexpected behaviour I've encountered when using nested classes within a class that privately inherits from another. I've often seen statements to the effect that there is nothing special about a nested class compared to an unnested class, but in this example one can see that a nested class (at least according to GCC 4.4) can see the public typedefs of a class that is privately inherited by the closing class. </p>\n<p>I appreciate that typdefs are not the same as member data, but I found this behaviour surprising, and I imagine many others would, too. So my question is twofold:</p>\n<ol>\n<li>Is this standard behaviour? (a decent explanation of why would be very helpful)</li>\n<li>Can one expect it to work on most modern compilers (i.e., how portable is it)?</li>\n</ol>\n<hr>\n<pre><code>#include &lt;iostream&gt;\n\nclass Base {\n  typedef int priv_t;\n  priv_t priv;\npublic:\n  typedef int pub_t;\n  pub_t pub;\n  Base() : priv(0), pub(1) {}\n};\n\nclass PubDerived : public Base {\npublic:\n  // Not allowed since Base::priv is private\n  // void foo() {std::cout &lt;&lt; priv &lt;&lt; \"\\n\";}\n\n  class Nested {\n    // Not allowed since Nested has no access to PubDerived member data\n    // void foo() {std::cout &lt;&lt; pub &lt;&lt; \"\\n\";}\n\n    // Not allowed since typedef Base::priv_t is private\n    // void bar() {priv_t x=0; std::cout &lt;&lt; x &lt;&lt; \"\\n\";}\n  };\n\n};\n\nclass PrivDerived : private Base {\npublic:\n  // Allowed since Base::pub is public\n  void foo() {std::cout &lt;&lt; pub &lt;&lt; \"\\n\";}\n\n  class Nested {\n  public:\n    // Works (gcc 4.4 - see below)\n    void fred() {pub_t x=0; std::cout &lt;&lt; x &lt;&lt; \"\\n\";}\n  };\n};\n\nint main() {\n\n  // Not allowed since typedef Base::priv_t private\n  // std::cout &lt;&lt; PubDerived::priv_t(0) &lt;&lt; \"\\n\";\n\n  // Allowed since typedef Base::pub_t is inaccessible\n  std::cout &lt;&lt; PubDerived::pub_t(0) &lt;&lt; \"\\n\"; // Prints 0\n\n  // Not allowed since typedef Base::pub_t is inaccessible\n  //std::cout &lt;&lt; PrivDerived::pub_t(0) &lt;&lt; \"\\n\";\n\n  // Works (gcc 4.4)\n  PrivDerived::Nested o;\n  o.fred(); // Prints 0\n  return 0;\n}\n</code></pre>\n</hr>", "Tags": "<c++><inheritance><typedef><nested-class>", "OwnerUserId": "290182", "AnswerCount": "5"}, "2421671": {"ParentId": "2421492", "PostTypeId": "2", "CommentCount": "8", "Body": "<p><strong>Preface:</strong> In the answer below I refer to some differences between C++98 and C++03. However, it turns out that the change I'm talking about haven't made it into the standard yet, so C++03 is not really different from C++98 in that respect (thanks to Johannes for pointing that out). Somehow I was sure I saw it in C++03, but in reality it isn't there. Yet, the issue does indeed exist (see the DR reference in Johannes comment) and some compilers already implement what they probably consider the most reasonable resolution of that issue. So, the references to C++03 in the text below are not correct. Please, interpret the references to C++03 as references to some hypothetical but very likely future specification of this behavior, which some compilers are already trying to implement.</p>\n<hr>\n<p>It is important to note that there was a significant change in access rights for nested classes between C++98 and C++03 standards. </p>\n<p>In C++98 nested class had no special access rights to the members of enclosing class. It was basically completely independent class, just declared in the scope of the enclosed class. It could only access <em>public</em> members of the enclosing class.</p>\n<p>In C++03 nested class was given access rights to the members of the enclosing class <em>as a member</em> of the enclosing class. More precisely, nested class was given the same access rights <em>as a static member function</em> of the enclosing class. I.e. now the nested class can access <em>any</em> members of the enclosing class, including <em>private</em> ones.</p>\n<p>For this reason, you might observe the differences between different compilers and versions of the same compiler depending on when they implemented the new specification.</p>\n<p>Of course, you have to remember that an object of the nested class is not tied in any way to  any specific object of the enclosing class. As far as the actual objects are concerned, these are two independent classes. In order to access the non-static data members or methods of the enclosing class from the nested class you have to have a specific object of the enclosing class. In other words, once again, the nested class indeed behaves as just like a <em>static member function</em> of the enclosing class: it has no specific <code>this</code> pointer for the enclosing class, so it can't access the non-static members of the enclosing class, unless you make an effort to give it a specific object of the enclosing class to access. Without it the nested class can only access typedef-names, enums, and static members of the enclosing class.</p>\n<p>A simple example that illustrates the difference between C++98 and C++03 might look as follows</p>\n<pre><code>class E {\n  enum Foo { A };\npublic:\n  enum Bar { B };\n\n  class I {\n    Foo i; // OK in C++03, error in C++98\n    Bar j; // OK in C++03, OK in C++98\n  };\n};\n</code></pre>\n<p>This change is exactly what allows your <code>PrivDerived::Nested::fred</code> function to compile. It wouldn't pass compilation in a pedantic C++98 compiler.</p>\n</hr>", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2010-03-11T17:52:10.847", "Id": "2421671", "Score": "4", "CreationDate": "2010-03-11T00:13:35.370", "LastActivityDate": "2010-03-11T17:52:10.847"}, "bq_ids": {"n4140": {"so_2421492_2421590_0": {"section_id": 5925, "quality": 0.5121951219512195, "length": 21}, "so_2421492_4528154_1": {"section_id": 6700, "quality": 0.9583333333333334, "length": 23}, "so_2421492_2421590_2": {"section_id": 5933, "quality": 1.0, "length": 9}, "so_2421492_2421590_1": {"section_id": 6678, "quality": 1.0, "length": 20}, "so_2421492_2421578_1": {"section_id": 5861, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_2421492_2421590_0": {"section_id": 5697, "quality": 0.5121951219512195, "length": 21}, "so_2421492_4528154_1": {"section_id": 6455, "quality": 0.9583333333333334, "length": 23}, "so_2421492_2421590_2": {"section_id": 5705, "quality": 1.0, "length": 9}, "so_2421492_2421590_1": {"section_id": 6433, "quality": 1.0, "length": 20}, "so_2421492_2421578_1": {"section_id": 5631, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_2421492_4528154_1": {"section_id": 8174, "quality": 0.9583333333333334, "length": 23}, "so_2421492_2421590_2": {"section_id": 7403, "quality": 1.0, "length": 9}, "so_2421492_2421590_1": {"section_id": 8153, "quality": 1.0, "length": 20}, "so_2421492_2421590_0": {"section_id": 7399, "quality": 0.5121951219512195, "length": 21}}}});