post_cb({"33632115": {"Id": "33632115", "PostTypeId": "2", "Body": "<p>Max is a function already defined in Standard Library and it's prototype is as follows:</p>\n<pre><code>template&lt; class T &gt; \nconst T&amp; max( const T&amp; a, const T&amp; b );\n</code></pre>\n<p>If you have a file, where you include algorithm with:</p>\n<pre><code>#include &lt;algorithm&gt;\n</code></pre>\n<p>And moreover you use:</p>\n<pre><code>using namespace std;\n</code></pre>\n<p>Then here is your trouble, because you have got ambiguous call.</p>\n<p>It worked fine with version with</p>\n<pre><code>T max(T&amp; arg1, T&amp; arg2)\n</code></pre>\n<p>Because you lack <code>constnesses</code>, and compiler could recognize which funtion to call, when you have your function with values, then it's ambiguous which function compiler shall chose, so it gives you ambiguous error.</p>\n", "LastActivityDate": "2015-11-10T14:19:05.240", "CommentCount": "0", "CreationDate": "2015-11-10T14:19:05.240", "ParentId": "33631895", "Score": "-1", "OwnerUserId": "4764736"}, "33632072": {"Id": "33632072", "PostTypeId": "2", "Body": "<p>A good solution would be to use universal references.\nYour program will work with values as well as with variables.</p>\n<p>Your function will look like this:</p>\n<pre><code>template &lt;typename T&gt;\nT max(T&amp;&amp; arg1, T&amp;&amp; arg2) {    \n    return (arg1 &gt; arg2) ? arg1:arg2;\n}\n</code></pre>\n<p>Universal reference is the compiler using the template immediate context to generate a function taking a rvalue reference or a lvalue reference.</p>\n<p><strong>EDIT:</strong></p>\n<p>Reading other answers, I realize that your function name collide with <code>std::max</code>\njust renaming the function worked perfectly.</p>\n", "LastEditorUserId": "2104697", "LastActivityDate": "2015-11-10T14:22:37.130", "Score": "-2", "CreationDate": "2015-11-10T14:16:53.763", "ParentId": "33631895", "CommentCount": "5", "OwnerUserId": "2104697", "LastEditDate": "2015-11-10T14:22:37.130"}, "33632212": {"Id": "33632212", "PostTypeId": "2", "Body": "<p>Previous version of your function was incorrect. You should not declare arguments for <code>max()</code> as <code>T&amp;</code> (non-const), because in such case, you won't be able to do this:</p>\n<pre><code>int m = max(5, 6);\n</code></pre>\n<p><code>5</code> and <code>6</code> represent temporary object and as such, they cannot be received as non-const reference to such object.</p>\n<p>Now, after you removed <code>&amp;</code> from prototype, things get better and worse at the same time. Better, because now you can do <code>max(5, 6)</code>. Worse, because there is another function in global namespace, that can also do the job - \"standard\" <code>max(const T&amp;, const T&amp;)</code>.</p>\n<p>And here goes the problem - which one should be used? If you pass parameters as constants, both choices are equally good - compiler may create temporary objects and pass them via <code>const&amp;</code> (if it choose standard <code>max()</code>) or pass them by value, which also implies calling proper constructor. That's why you get error about <em>\"ambiguous call\"</em>.</p>\n<p>Solution:</p>\n<ul>\n<li>use <code>std::max()</code> (why not?)</li>\n<li>do not import <code>std::max()</code> into global namespace (with either <code>using namespace std</code> <code>or using std::max</code>)</li>\n</ul>\n<p>IMHO first option is much more preferable.</p>\n", "LastActivityDate": "2015-11-10T14:24:00.107", "CommentCount": "1", "CreationDate": "2015-11-10T14:24:00.107", "ParentId": "33631895", "Score": "1", "OwnerUserId": "2812864"}, "bq_ids": {"n4140": {"so_33631895_33632903_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 639}}, "n3337": {"so_33631895_33632903_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 629}}, "n4659": {"so_33631895_33632903_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 667}}}, "33631895": {"ViewCount": "92", "Body": "<p>Below you can see small function called max.</p>\n<pre><code>template &lt;typename T&gt;\nT max(T&amp; arg1, T&amp; arg2) {    \n    if (arg1 &gt; arg2) {\n        return arg1;\n    } else {\n        return arg2;\n    }\n}\n</code></pre>\n<p>When i call this function inside main, it perfectly works, but if i make remove reference from arguments </p>\n<pre><code>T max(T arg1, T arg2)  \n</code></pre>\n<p>Then compiler gives following error </p>\n<pre><code>main.cpp:18:21: error: call of overloaded 'max(int&amp;, int&amp;)' is ambiguous\n</code></pre>\n<p>It is clear that compiler could not decide whether to call my function or standard function. The question here how it can decide and work fine, when there is reference on the head of arguments ? </p>\n<p>When i call the function with constant parameters </p>\n<pre><code>const int a = 12;\nconst int b = 24;\ncout &lt;&lt; max(a, b) &lt;&lt; endl;\n</code></pre>\n<p>it calls the standard max function. But when i call with non const values, it calls my function. </p>\n<p>I can understand that if the object is const, the the const function will be called elsewhere the non-const function will be called. But why it should be reference to trigger this mechanism ? Why it cannot decide without the reference operator is there ?</p>\n", "AcceptedAnswerId": "33632903", "Title": "Why compiler cannot decide which function to call without the reference operator?", "CreationDate": "2015-11-10T14:07:53.557", "Id": "33631895", "CommentCount": "4", "LastEditDate": "2015-11-10T15:00:26.373", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2015-11-10T15:01:47.463", "Score": "3", "OwnerUserId": "1087681", "Tags": "<c++><templates><overload-resolution>", "AnswerCount": "5"}, "33632102": {"Id": "33632102", "PostTypeId": "2", "Body": "<p>When you use </p>\n<pre><code>const int a = 12;\nconst int b = 24;\ncout &lt;&lt; max(a, b) &lt;&lt; endl;\n</code></pre>\n<p>The compiler has no other option but to call for the standard <code>max</code> function as it is defined to receive constant references (I almost sure you have <code>using namespace std;</code> at the beginning of your CPP file).</p>\n<p>When you call for <code>max</code> with non <code>const</code> parameters, the compiler has two options either to use your <code>max</code> or the <code>std::max</code>. In such case the compiler always picks the less restricting option, which is <code>T max(T&amp; arg1, T&amp; arg2)</code>.</p>\n<p>Since <code>const</code> on the input parameters is treated as part of the function signature</p>\n<pre><code>T max(T&amp; arg1, T&amp; arg2)\n</code></pre>\n<p>and</p>\n<pre><code>T max(const T&amp; arg1, const T&amp; arg2)\n</code></pre>\n<p>are not the same and it doesn't cause to ambiguity error, while</p>\n<pre><code>T max(T arg1, T arg2)\n</code></pre>\n<p>will cause the ambiguity error with the first case.</p>\n", "LastActivityDate": "2015-11-10T14:18:19.643", "CommentCount": "3", "CreationDate": "2015-11-10T14:18:19.643", "ParentId": "33631895", "Score": "1", "OwnerUserId": "5218277"}, "33632903": {"Id": "33632903", "PostTypeId": "2", "Body": "<p>This is a question about overload resolution, which nobody has yet addressed. Let's ignore templates for the moment, since they're not strictly relevant, and let's pretend we these overloads declared:</p>\n<pre><code>void foo(int&amp; );       // (1)\nvoid foo(const int&amp;);  // (2)\n</code></pre>\n<p>What happens when we try to call <code>foo</code> with an lvalue?</p>\n<pre><code>int i;\nfoo(i);\n</code></pre>\n<p>Both candidates are viable. The first rule for determining which is the <em>best</em> viable candidate is conversion sequences, and [over.ics.rank]:</p>\n<blockquote>\n<p id=\"so_33631895_33632903_0\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence\n  S2 if<br>\n  \u2014 [...]<br>\n  \u2014 S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same\n  type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers\n  is more cv-qualified than the type to which the reference initialized by S1 refers.</br></br></p>\n</blockquote>\n<p>S1 and S2 are both reference bindings, and the types to which the references refer (<code>int</code> and <code>const int</code>) are the same except for cv-qualifiers, but S2's referred type is more cv-qualified than S1's. The least-qualified reference wins. Hence, (1) is preferred.</p>\n<p>This is exactly why your function template</p>\n<pre><code>template &lt;typename T&gt; T max(T&amp;, T&amp;); // (1)\n</code></pre>\n<p>is preferred to the standard function template:</p>\n<pre><code>template &lt;typename T&gt; T const&amp; max(T const&amp;, T const&amp;); // (2)\n</code></pre>\n<hr/>\n<p>The second part of the question introduces this additional overload:</p>\n<pre><code>void foo(int&amp; );       // (1)\nvoid foo(const int&amp;);  // (2)\nvoid foo(int );        // (3)\n</code></pre>\n<p>We know that (1) is better than (2), but there <strong>does not exist</strong> a rule differentiating between (1) and (3). There is no \"reference is better than non-reference\" or vice-versa rule. Thus, both candidates are equally viable - which is ill-formed. Hence the error about ambiguity. This is why:</p>\n<pre><code>template &lt;typename T&gt; T max(T, T); // (3)\ntemplate &lt;Typename T&gt; T const&amp; max(T const&amp;, T const&amp;); // (2)\n</code></pre>\n<p>didn't compile for you.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-11-10T15:01:47.463", "Score": "6", "CreationDate": "2015-11-10T14:56:38.887", "ParentId": "33631895", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-11-10T15:01:47.463"}});