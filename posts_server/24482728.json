post_cb({"24482728": {"CommentCount": "2", "AcceptedAnswerId": "24483026", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2014-06-30T03:54:34.800", "LastActivityDate": "2014-06-30T23:49:14.100", "LastEditDate": "2014-06-30T23:46:53.427", "ViewCount": "750", "FavoriteCount": "3", "Title": "Return value of istream::get()", "Id": "24482728", "Score": "4", "Body": "<p>This question is about the member function of <code>basic_istream</code>:</p>\n<pre><code>int_type get();\n</code></pre>\n<p>as described by N3337 27.7.2.3#4  (that is [istream.unformatted]). Presumably the actual Standard text is the same.</p>\n<p>The text says:</p>\n<blockquote>\n<p id=\"so_24482728_24482728_0\">After constructing a sentry object, extracts a character <code>c</code>, if one is available</p>\n<p id=\"so_24482728_24482728_1\"><em>Returns:</em> <code>c</code> if available, otherwise <code>traits::eof()</code></p>\n</blockquote>\n<p>This text suggests that negative <code>char</code>s should return a negative value. We could compare with the next section, <code>basic_istream&lt;charT,traits&gt;&amp; get(char_type &amp;c)</code>, which says:</p>\n<blockquote>\n<p id=\"so_24482728_24482728_2\">After constructing a sentry object, extracts a character, if one is available, and assigns it to <code>c</code>.</p>\n</blockquote>\n<p>This is very similar wording to <code>get()</code>.</p>\n<p>However, when I try <code>get()</code>, negative chars return a positive value; i.e. <code>basic_istream::get()</code>  behaves like the C function <code>getchar()</code>. This would be the sensible behaviour (to allow signalling of EOF), however the Standard text does not seem to specify this.  The C99 description of <code>getchar()</code> and friends specifically says that it returns the value <em>converted to an unsigned char</em>. But <code>basic_istream::get()</code> does not have any equivalant text.</p>\n<p>My question is: is <code>get()</code> meant to be specified to return a value in the range <code>0...UCHAR_MAX</code> union <code>EOF</code>? Or should it return the actual <code>char</code> converted to <code>int_type</code> (via implicit conversion)? Or something else? What exactly does and does not the Standard specify here?</p>\n<p>If \"something else\", how do I transform the result of <code>int i = cin.get()</code> to match the char value read by <code>char ch; cin.get(ch);</code> for the same input character?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "1505939", "AnswerCount": "2"}, "24482877": {"ParentId": "24482728", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>As per [char.traits.typedefs]</p>\n<blockquote>\n<p id=\"so_24482728_24482877_0\"><code>typedef INT_T int_type;</code></p>\n<p id=\"so_24482728_24482877_1\">Requires: For a certain character container type <code>char_type</code>, a related\n  container type <code>INT_T</code> shall be a type or class which can represent all\n  of the valid characters converted from the corresponding <code>char_-type</code>\n  values, as well as an end-of-file value, <code>eof()</code>. The type <code>int_type</code>\n  represents a character container type which can hold end-of-file to be\n  used as a return type of the iostream class member functions.</p>\n</blockquote>\n<p>The only requirement by the standard is that <code>int_type</code> is large enough to hold all of the values of <code>char_type</code> (it doesn't even have to be a fundamental type), plus the value returned by <code>eof()</code>, the standard also requires however that <code>char_traits&lt;char&gt;::int_type</code> is <code>int</code>, and that <code>char_traits&lt;wchar_t&gt;</code> is <code>wint_t</code>.</p>\n<p>The reason you are seeing your <code>char</code>s cast to an unsigned value is because GCC is making sure that <code>EOF</code> and the character value <code>0xff</code> are distinct behind the scenes in <code>char_traits&lt;char&gt;::to_int_type</code> by casting the character to <code>unsigned char</code> before returning the <code>int</code> (note that the standard also requires that <code>char_traits&lt;char&gt;::eof</code> returns <code>EOF</code>, and <code>WEOF</code> for <code>wchar_t</code>). Without the cast <code>0xff</code> would be sign extended to the equivalent of <code>EOF</code>, at least for GCC.</p>\n<p>As for casting (even implicitly) the return value of <code>get</code> to a <code>char</code>, this works for GCC due to the way it handles <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\" rel=\"nofollow\">signed conversion</a>.</p>\n<blockquote>\n<p id=\"so_24482728_24482877_2\">The result of, or the signal raised by, converting an integer to a\n  signed integer type when the value cannot be represented in an object\n  of that type (C90 6.2.1.2, C99 and C11 6.3.1.3). </p>\n<p id=\"so_24482728_24482877_3\">For conversion to a\n  type of width N, the value is reduced modulo 2^N to be within range of\n  the type; no signal is raised.</p>\n</blockquote>\n<p>This isn't portable however, and you should be using <code>traits_type::to_char_type</code> on the return value first (after checking for <code>EOF</code> / <code>eof()</code> of course...).</p>\n", "OwnerUserId": "657267", "LastEditorUserId": "657267", "LastEditDate": "2014-06-30T23:49:14.100", "Id": "24482877", "Score": "2", "CreationDate": "2014-06-30T04:20:35.793", "LastActivityDate": "2014-06-30T23:49:14.100"}, "bq_ids": {"n4140": {"so_24482728_24482728_2": {"section_id": 2213, "quality": 1.0, "length": 9}, "so_24482728_24482728_0": {"section_id": 2211, "quality": 1.0, "length": 8}, "so_24482728_24482877_1": {"section_id": 1535, "quality": 0.9285714285714286, "length": 39}}, "n3337": {"so_24482728_24482728_2": {"section_id": 2201, "quality": 1.0, "length": 9}, "so_24482728_24482728_0": {"section_id": 2199, "quality": 1.0, "length": 8}, "so_24482728_24482877_1": {"section_id": 1529, "quality": 0.9285714285714286, "length": 39}}, "n4659": {"so_24482728_24482728_2": {"section_id": 2486, "quality": 1.0, "length": 9}, "so_24482728_24482728_0": {"section_id": 2484, "quality": 1.0, "length": 8}, "so_24482728_24482877_1": {"section_id": 1685, "quality": 0.9285714285714286, "length": 39}}}, "24483026": {"ParentId": "24482728", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>To clear up your confusion, the difference just doesn't matter. Think about what you can or can't do with the returnvalue of parameterless <code>get()</code>. The funny thing is that you can't reliably compare it to <code>EOF</code> or <code>traits_type::eof()</code>, because it's not ever guaranteed to be equality-comparable (it <strong>is</strong> for builtin <code>char</code> and <code>wchar_t</code> though). In order to compare it correctly, you just use <code>traits_type::eq_int_type()</code>. Similarly, in order to extract a character from it after checking for EOF, you use <code>traits_type::to_char_type()</code>, and that function then converts the type accordingly. Similarly, <code>get()</code> can't use the implicit conversion but has to use <code>traits_type::to_int_type()</code>.</p>\n<p>In summary, the guarantee for <code>getchar()</code> that it returns the \"unsigned\" value or EOF is not necessary, since the <code>traits_type</code> encapsulates this knowledge and should be used for correct code.</p>\n<p>Example use of parameterless istream::get():</p>\n<pre><code>traits_type::int_type c = in.get();\nif(traits_type::not_eof(c))\n    my_string += traits_type::to_char_type(c);\n</code></pre>\n<p>Similar use of single-parameter istream::get():</p>\n<pre><code>traits_type::char_type c;\nin.get(c);\nif(in) // check for EOF or other input failure\n    my_string += c;\n</code></pre>\n", "OwnerUserId": "1968182", "LastEditorUserId": "1968182", "LastEditDate": "2014-06-30T05:01:23.977", "Id": "24483026", "Score": "3", "CreationDate": "2014-06-30T04:42:34.663", "LastActivityDate": "2014-06-30T05:01:23.977"}});