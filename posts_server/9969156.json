post_cb({"9969210": {"ParentId": "9969156", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the current C++ standard...</p>\n<blockquote>\n<h3>7.1.1 Storage class specifiers</h3>\n<p id=\"so_9969156_9969210_0\">7) A name declared in a namespace scope without a storage-class-specifier has external linkage unless it has internal linkage because of a previous declaration and provided it is not declared const. <strong>Objects declared const and not explicitly declared extern have internal linkage.</strong></p>\n<h3>3.5 Program and Linkage</h3>\n<p id=\"so_9969156_9969210_1\">2) When a name has <strong>internal linkage</strong>, the entity it denotes can be referred to by names from other scopes in the <strong>same translation unit</strong>.</p>\n</blockquote>\n<p>The preprocessor causes stuff defined in headers to be included in the current translation unit.</p>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2012-04-01T23:31:32.890", "Id": "9969210", "Score": "2", "CreationDate": "2012-04-01T23:17:25.943", "LastActivityDate": "2012-04-01T23:31:32.890"}, "9969209": {"ParentId": "9969156", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is because a <code>const</code> declaration at namespace scope implies internal linkage. An object with internal linkage is only available within the translation unit in which it is defined. So in a sense, the one <code>const</code> object you have in <code>c.h</code> is actually two different objects, one internal to <code>a.cpp</code> and one internal to <code>b.cpp</code>.</p>\n<p>In other words,</p>\n<pre><code>const int x = ...;\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>static const int x = ...;\n</code></pre>\n<p>while</p>\n<pre><code>int x;\n</code></pre>\n<p>is similar to</p>\n<pre><code>extern int x;\n</code></pre>\n<p>because non-<code>const</code> declarations at namespace scope imply external linkage. (In this last case, they aren't actually equivalent. <code>extern</code>, as well as explicitly specifying external linkage, produces a <em>declaration</em>, not a <em>definition</em>, of an object.)</p>\n<p>Note that this is specific to C++. In C, <code>const</code> doesn't change the implied linkage. The <em>reason</em> for this is that the C++ committee wanted you to be able to write</p>\n<pre><code>const int x = 5;\n</code></pre>\n<p>in a header. In C, that header included from multiple files would cause linker errors, because you'd be defining the same object multiple times.</p>\n", "OwnerUserId": "5696", "LastEditorUserId": "5696", "LastEditDate": "2012-04-02T00:05:10.090", "Id": "9969209", "Score": "5", "CreationDate": "2012-04-01T23:16:55.230", "LastActivityDate": "2012-04-02T00:05:10.090"}, "9969201": {"ParentId": "9969156", "CommentCount": "3", "Body": "<p>When you do so, you create a separate <code>const</code> variable in each object file for every constant in the header. It's not a problem, since they are <code>const</code>.</p>\n", "OwnerUserId": "2612002", "PostTypeId": "2", "Id": "9969201", "Score": "0", "CreationDate": "2012-04-01T23:15:38.887", "LastActivityDate": "2012-04-01T23:15:38.887"}, "9969156": {"CommentCount": "0", "ViewCount": "244", "CreationDate": "2012-04-01T23:09:56.510", "LastActivityDate": "2012-04-02T00:05:10.090", "Title": "Why is it that I can include a header file in multiple cpp files that contains const int and not have a compiler error?", "AcceptedAnswerId": "9969209", "PostTypeId": "1", "Id": "9969156", "Score": "3", "Body": "<p>Let's assume that I have files a.cpp b.cpp and file c.h. Both of the cpp files include the c.h file. The header file contains a bunch of const int definitions and when I compile them I get no errors and yet I can access those const as if they were global variables. So the question, why don't I get any compilation errors if I have multiple const definitions as well as these const int's having global-like scope?</p>\n", "Tags": "<c++><compilation><header><include>", "OwnerUserId": "1306950", "AnswerCount": "4"}, "9969271": {"ParentId": "9969156", "CommentCount": "0", "Body": "<p>Real reason: because <code>#define</code> is evil and needs to die.</p>\n<p>Some usages of #define can be replaced with inline functions. Some - with <code>const</code> variable declarations. Since #define tends to be in header files, replacing those with <code>const</code>s in place better work. Thus, the \"consts are static by default\" rule.</p>\n", "OwnerUserId": "219159", "PostTypeId": "2", "Id": "9969271", "Score": "0", "CreationDate": "2012-04-01T23:29:18.613", "LastActivityDate": "2012-04-01T23:29:18.613"}, "bq_ids": {"n4140": {"so_9969156_9969210_0": {"section_id": 7136, "quality": 0.5416666666666666, "length": 13}, "so_9969156_9969210_1": {"section_id": 7135, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_9969156_9969210_0": {"section_id": 5191, "quality": 1.0, "length": 24}, "so_9969156_9969210_1": {"section_id": 6879, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_9969156_9969210_1": {"section_id": 8636, "quality": 0.9285714285714286, "length": 13}}}});