post_cb({"bq_ids": {"n4140": {"so_1634589_1634589_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 5485}}, "n3337": {"so_1634589_1634589_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 3082}}, "n4659": {"so_1634589_1634589_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 6920}}}, "1640941": {"Id": "1640941", "PostTypeId": "2", "Body": "<p>An example of when Matrix is in scope, XForm isn't, yet there is an XForm class defined which is the friend of Matrix:</p>\n<pre><code>1.h\n------------------------\nnamespace Foo\n{\n class Matrix\n {\n  friend class XForm;\n };\n}\n\n1.c\n------------------------\n#include 1.h\n// XForm not in scope\n// implement Matrix\n\n2.h\n------------------------\nnamespace Foo\n{\n class XForm\n {\n };\n}\n\nmain.c\n\n#include 1.h\n#include 2.h\nint main()\n{\n // both XForm &amp; Matrix in scope here\n}\n</code></pre>\n<p>Is this correct?</p>\n", "LastActivityDate": "2009-10-29T00:15:07.120", "CommentCount": "0", "CreationDate": "2009-10-29T00:15:07.120", "ParentId": "1634589", "Score": "1", "OwnerUserId": "110226"}, "1634589": {"ViewCount": "397", "Body": "<p>In section 11.5.1 of \"The C++ Programming Language\", Bjarne Stroustrup writes:</p>\n<blockquote>\n<p id=\"so_1634589_1634589_0\">Like a member declaration, a friend declaration does not introduce a name into an enclosing scope.</p>\n<p id=\"so_1634589_1634589_1\">For example:</p>\n<pre><code>class Matrix\n{\n    friend class Xform;\n    friend Matrix invert (const Matrix &amp;);\n//..\n };\nXform x; // error: no Xform in scope\nMatrix (*p) (const Matrix &amp;) = &amp;invert; // error: no invert() in scope\n</code></pre>\n<p id=\"so_1634589_1634589_2\">For large programs and large classes, it is nice that a class doesn\u2019t \u2018\u2018quietly\u2019\u2019 add names to its enclosing scope. For a template class that can be instantiated in many different contexts (Chapter 13), this is very important.</p>\n</blockquote>\n<p>However, the next section then goes on to say that the class must have been previously defined, or defined in the non-class scope immediately enclosing the class that is declaring it a friend.</p>\n<p>My question is that because of the fact that the class needs to be previous defined or defined in the nonclass scope immediately enclosing the class that is declaring it a friend, then in the first example <code>Xform</code> could not be out of scope, as presumably the class would have been defined before the definition of the <code>Matrix</code> class. Furthermore, I can't think of a situation which, given the restriction that the friend class needs to be previously defined or defined immediately after the granter's class, that the friend class will not be in scope!</p>\n<p>Secondly, is my interpretation of Bjarne in this section correct, in that:</p>\n<ul>\n<li>For friend CLASSES only, friend class must have been previously defined in an enclosing scope, OR defined immediately after the non-class scope.</li>\n<li>For a function, must have been previously declared in an enclosing scope, OR it can also be found by having an argument of type == 'the friendship granter's' class?</li>\n</ul>\n", "Title": "friendship scope c++", "CreationDate": "2009-10-28T00:50:40.503", "LastActivityDate": "2015-10-26T13:55:09.223", "CommentCount": "0", "LastEditDate": "2015-10-26T13:55:09.223", "PostTypeId": "1", "LastEditorUserId": "3204551", "Id": "1634589", "Score": "0", "OwnerUserId": "110226", "Tags": "<c++><scope><friend><access-control>", "AnswerCount": "4"}, "1634690": {"Id": "1634690", "PostTypeId": "2", "Body": "<p>The idea of a friend function is when you have a private class so that normally other classes cannot access what's inside - you're making a black box, BUT you want to specifically name functions that are outside that are exceptions to that rule. I think it should be thought of as not having much to do with scope, or if anything, defining a special kind of scope.</p>\n<p>Something defined as a friend would have to be defined elsewhere, otherwise it's not a friend - it's nothing - it doesn't exist.</p>\n<p>Was that the question?</p>\n", "LastActivityDate": "2009-10-28T01:26:18.063", "CommentCount": "0", "CreationDate": "2009-10-28T01:26:18.063", "ParentId": "1634589", "Score": "0", "OwnerUserId": "197388"}, "1634765": {"Id": "1634765", "PostTypeId": "2", "Body": "<p>You're right that <code>Xform</code> would need to have been defined before <code>Matrix</code> <strong>if the example code was supposed to work</strong>. But it wasn't supposed to work. It was an example of <em>bad</em> code \u2014 code that tried to have the friend declaration introduce new names into the program, and then use those names to declare a variable and initialize a pointer.</p>\n<p>That was the entire standalone example. It wasn't just an excerpt where you were supposed to imagine additional code before or after the given code, such as definitions for <code>Xform</code> and <code>invert</code>.</p>\n<p>Your first paraphrase is not quite correct. The definition of the friend class does not need to immediately <em>follow</em> the class who granted it friendship. It needs to be defined in the <em>immediately enclosing scope</em>. Essentially, it should be defined in the same scope as the class it's friends with. The example after the one you cite illustrates it:</p>\n<pre><code>class AE { /* ... */ }; // not a friend of Y\n\nnamespace N {\n  class X { /* ... */ }; // Y's friend\n\n  class Y {\n    friend class X;\n    friend class Z;\n    friend class AE;\n  };\n\n  class Z { /* ... */ }; // Y's friend\n}\n</code></pre>\n<p>Although <code>Y</code> says that <code>AE</code> is its friend, it's not referring to the <code>AE</code> class declared earlier because namespace <code>N</code> is the immediately enclosing scope of <code>Y</code> and <code>AE</code> isn't declared there. Instead, the friend declaration must refer to some <em>other</em> <code>AE</code> class that's going to be defined in namespace <code>N</code> elsewhere in the program. (However, it doesn't <em>need</em> to be defined anywhere at all; classes can say they are friends with things that don't exist, and the program won't care. The programmers will care, though, because they'll waste time trying to find the right <code>AE</code> class in the source code.)</p>\n<p>You're also wrong on your second paraphrase. The function doesn't have to have been <em>previously</em> declared in an enclosing scope. It just has to be declared <em>eventually</em>. Consider the opening example of section 11.5, where <code>operator*</code> is listed as a friend of both <code>Vector</code> and <code>Matrix</code> classes <em>before</em> the operator has been either declared or defined.</p>\n<p>Furthermore, for the friend function to be found, it doesn't have to have arguments equal to the class's type. Stroustrup says the function \"can be found through its arguments,\" and then refers you to section 8.2.6 for what he means by that. That's the section on <em>name lookup</em>.</p>\n", "LastActivityDate": "2009-10-28T01:59:06.837", "CommentCount": "2", "CreationDate": "2009-10-28T01:59:06.837", "ParentId": "1634589", "Score": "2", "OwnerUserId": "33732"}, "1634656": {"Id": "1634656", "PostTypeId": "2", "Body": "<p>I don't know if I understand your question, but I think Bjarne thought you need to define the class (say <code>Xform</code>) outside <code>Matrix</code> if you want to use it (imagine it is some helper class you put in a header file that you don't <code>#include</code> in all <code>.cpp</code> files that #include the file with <code>Matrix</code>). You needn't define it if you never mention it :)</p>\n<p>In case of functions, the situation is similar. However, there is a difference, that it can be even defined with the friend declaration (=inside the <code>Matrix</code> class) and, as you say, \"be found by having an argument of type == 'the friendship granter's' class\" (or have argument type that is a nested class thereof), by Koenig lookup.</p>\n", "LastActivityDate": "2009-10-28T01:15:34.183", "CommentCount": "0", "CreationDate": "2009-10-28T01:15:34.183", "ParentId": "1634589", "Score": "0", "OwnerUserId": "51831"}});