post_cb({"28846608": {"ParentId": "8016780", "LastEditDate": "2015-03-04T13:07:16.920", "CommentCount": "2", "CreationDate": "2015-03-04T04:19:49.447", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "28846608", "Score": "35", "Body": "<p>In C++03 we were only allowed to provide in class intializers for <em>const integrals</em> or <em>const enumeration types</em>, in C++11 using <em>constexpr</em> this was extended to <em>literal types</em>.</p>\n<p>In C++11 we do not need to provide a namespace scope definition for a static constexpr member if it is not <em>odr-used</em>, we can see this from the draft C++11 standard section <code>9.4.2</code> <em>[class.static.data]</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_8016780_28846608_0\">[...]A static data member of literal type can be declared in the class\n  definition with the constexpr specifier; if so, its declaration shall\n  specify a brace-or-equal-initializer in which every initializer-clause\n  that is an assignment-expression is a constant expression. [ Note: In\n  both these cases, the member may appear in constant expressions. \u2014end\n  note ] \n  <strong>The member shall still be defined in a namespace scope if it is odr-used (3.2)</strong> in the program and the namespace scope definition\n  shall not contain an initializer.</p>\n</blockquote>\n<p>So then the question becomes, is <code>baz</code> <em>odr-used</em> here:</p>\n<pre><code>std::string str(baz); \n</code></pre>\n<p>and the answer is <em>yes</em>, and so we require a namespace scope definition as well.</p>\n<p>So how do we determine if a variable is <em>odr-used</em>? The original C++11 wording in section <code>3.2</code> <em>[basic.def.odr]</em> says:</p>\n<blockquote>\n<p id=\"so_8016780_28846608_1\">An expression is potentially evaluated unless it is an unevaluated\n  operand (Clause 5) or a subexpression thereof. A variable whose name\n  appears as a potentially-evaluated expression <strong>is odr-used unless</strong>\n  it is an object that <strong>satisfies the requirements for appearing in a\n  constant expression</strong> (5.19) and <strong>the lvalue-to-rvalue conversion\n  (4.1) is immediately applied</strong>.</p>\n</blockquote>\n<p>So <code>baz</code> does yield a <em>constant expression</em> but the <em>lvalue-to-rvalue</em> conversion is not immediately applied since it is not applicable due to <code>baz</code> being an array. This is covered in section <code>4.1</code> <em>[conv.lval]</em> which says :</p>\n<blockquote>\n<p id=\"so_8016780_28846608_2\">A glvalue (3.10) of a non-function, <strong>non-array type T</strong> can be\n  converted to a prvalue.53 [...]</p>\n</blockquote>\n<p>What is applied in the <em>array-to-pointer conversion</em>.</p>\n<p>This wording of <em>[basic.def.odr]</em> was changed due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#712\" rel=\"noreferrer\">Defect Report 712</a> since some cases were not covered by this wording but these changes do not change the results for this case.</p>\n", "LastActivityDate": "2015-03-04T13:07:16.920"}, "8016853": {"ParentId": "8016780", "CommentCount": "16", "Body": "<p>Add to your cpp file:</p>\n<pre><code>constexpr char foo::baz[];\n</code></pre>\n<p>Reason: You have to provide the <em>definition</em> of the static member as well as the declaration. The declaration and the initializer go inside the class definition, but the member definition has to be separate.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "8016853", "Score": "115", "CreationDate": "2011-11-04T23:22:03.210", "LastActivityDate": "2011-11-04T23:22:03.210"}, "36721665": {"ParentId": "8016780", "LastEditDate": "2017-02-02T18:29:19.030", "CommentCount": "2", "CreationDate": "2016-04-19T14:40:22.100", "OwnerUserId": "159327", "LastEditorUserId": "256007", "PostTypeId": "2", "Id": "36721665", "Score": "2", "Body": "<p>Isn't the more elegant solution be changing the <code>char[]</code> into:</p>\n<pre><code>static constexpr char * baz = \"quz\";\n</code></pre>\n<p>This way we can have the definition/declaration/initializer in 1 line of code.</p>\n", "LastActivityDate": "2017-02-02T18:29:19.030"}, "8016780": {"CommentCount": "10", "CreationDate": "2011-11-04T23:11:45.040", "PostTypeId": "1", "AcceptedAnswerId": "8016853", "LastEditorUserId": "964135", "LastActivityDate": "2017-10-12T22:02:35.753", "LastEditDate": "2016-04-18T18:02:57.790", "ViewCount": "24055", "FavoriteCount": "22", "Title": "Undefined reference to static constexpr char[]", "Id": "8016780", "Score": "121", "Body": "<p>I want to have a <code>static const</code> <code>char</code> array in my class. GCC complained and told me I should use <code>constexpr</code>, although now it's telling me it's an undefined reference. If I make the array a non-member then it compiles. What is going on?</p>\n<pre><code>// .hpp\nstruct foo {\n  void bar();\n  static constexpr char baz[] = \"quz\";\n};\n\n// .cpp\nvoid foo::bar() {\n  std::string str(baz); // undefined reference to baz\n}\n</code></pre>\n", "Tags": "<c++><c++11><static-members><constexpr>", "OwnerUserId": "964135", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_8016780_28846608_2": {"section_id": 8, "quality": 0.75, "length": 6}, "so_8016780_28846608_0": {"section_id": 5908, "quality": 0.9047619047619048, "length": 38}}, "n3337": {"so_8016780_28846608_2": {"section_id": 5, "quality": 0.75, "length": 6}, "so_8016780_28846608_1": {"section_id": 6785, "quality": 0.8846153846153846, "length": 23}, "so_8016780_28846608_0": {"section_id": 5680, "quality": 0.9047619047619048, "length": 38}}, "n4659": {"so_8016780_28846608_2": {"section_id": 8, "quality": 0.75, "length": 6}, "so_8016780_28846608_0": {"section_id": 7390, "quality": 0.5714285714285714, "length": 24}}}, "46719572": {"ParentId": "8016780", "CommentCount": "1", "Body": "<p>This is really a flaw in C++11 - as others have explained, in C++11 a static constexpr member variable, unlike every other kind of constexpr global variable, has external linkage, thus must be explicitly defined somewhere.</p>\n<p>It's also worth noting that you can often in practice get away with static constexpr member variables without definitions when compiling with optimization, since they can end up inlined in all uses, but if you compile without optimization often your program will fail to link. This makes this a very common hidden trap - your program compiles fine with optimization, but as soon as you turn off optimization (perhaps for debugging), it fails to link.</p>\n<p>Good news though - this flaw is fixed in C++17! The approach is a bit convoluted though: in C++17, static constexpr member variables <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"noreferrer\">are implicitly inline</a>. Having <a href=\"http://en.cppreference.com/w/cpp/language/inline\" rel=\"noreferrer\">inline applied to variables</a> is a new concept in C++17, but it effectively means that they do not need an explicit definition anywhere.</p>\n", "OwnerUserId": "1007861", "PostTypeId": "2", "Id": "46719572", "Score": "5", "CreationDate": "2017-10-12T22:02:35.753", "LastActivityDate": "2017-10-12T22:02:35.753"}});