post_cb({"bq_ids": {"n4140": {"so_29723346_29723627_0": {"length": 52, "quality": 0.896551724137931, "section_id": 3296}}, "n3337": {"so_29723346_29723627_0": {"length": 52, "quality": 0.896551724137931, "section_id": 3166}}, "n4659": {"so_29723346_29723627_0": {"length": 52, "quality": 0.896551724137931, "section_id": 4058}}}, "29723627": {"Id": "29723627", "PostTypeId": "2", "Body": "<p>This only compiles because you're initializing class <code>C</code> with itself in the line <code>C c2 = c1;</code>. If you had a class <code>D</code> which behaves identically to <code>C</code> and tried <code>D d; C c = d;</code>, it wouldn't compile for the reason you stated: because the implicit conversion would require two user-defined conversions. <a href=\"http://coliru.stacked-crooked.com/a/14843362367e36fb\">Demonstation</a></p>\n<p>The reason it compiles when using the same class is that copy-initialization (<code>A x = y;</code>) behaves differently when <code>y</code> is of type <code>A</code> or derived from it. In that case, a converting constructor is selected and that constructor is then invoked with the argument <code>y</code>, which may cause an implicit conversion. The constructor call itself is not part of the implicit conversion.</p>\n<p>So in your code, the conversion sequence only contains one user-defined conversion: <code>C</code> to <code>int</code>, as the constructor <code>C(int)</code> is called separately.</p>\n<p>See C++14 8.5/17:</p>\n<blockquote id=\"so_29723346_29723627_0\">\n<ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unquali\ufb01ed\n  version of the source type is the same class as, or a derived class of, the class of the destination,\n  constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best\n  one is chosen through overload resolution (13.3). The constructor so selected is called to initialize\n  the object, with the initializer expression or expression-list as its argument(s).</li>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-de\ufb01ned conversion sequences\n  that can convert from the source type to the destination type or (when a conversion function\n  is used) to a derived class thereof are enumerated [...]</li>\n</ul>\n</blockquote>\n<p>Read more at <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\">http://en.cppreference.com/w/cpp/language/copy_initialization</a>.</p>\n", "LastEditorUserId": "189205", "LastActivityDate": "2015-04-18T22:44:06.480", "Score": "8", "CreationDate": "2015-04-18T22:27:26.990", "ParentId": "29723346", "CommentCount": "0", "OwnerUserId": "189205", "LastEditDate": "2015-04-18T22:44:06.480"}, "29723346": {"ViewCount": "220", "Body": "<p>Consider the following piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct C\n{\n    C() \n    {   \n        std::cout &lt;&lt; \"C()\\n\";\n    }   \n\n    explicit C(const C&amp;) \n    {   \n        std::cout &lt;&lt; \"C(const C&amp;)\\n\";\n    }   \n\n    operator int()\n    {   \n        std::cout &lt;&lt; \"int()\\n\";\n        return 1;\n    }   \n\n    C(int)\n    {   \n        std::cout &lt;&lt; \"C(int)\\n\";\n    }   \n};\n\nint main()\n{\n    C c1; \n    std::cout &lt;&lt; '\\n';\n    C c2 = c1; \n    std::cout &lt;&lt; '\\n';\n    C c3(c1);\n}\n</code></pre>\n<p>Both <code>g++</code> and <code>clang</code> give the following output:</p>\n<pre><code>C()\n\nint()\nC(int)\n\nC(const C&amp;)\n</code></pre>\n<p>Doesn't it break the rule saying that an implicit conversion sequence can consist of at most one user conversion?</p>\n", "AcceptedAnswerId": "29723627", "Title": "Chaining user conversions in c++", "CreationDate": "2015-04-18T21:58:26.447", "Id": "29723346", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-04-18T22:44:06.480", "Score": "7", "OwnerUserId": "2213297", "Tags": "<c++>", "AnswerCount": "1"}});