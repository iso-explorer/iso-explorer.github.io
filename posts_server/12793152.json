post_cb({"12793209": {"Id": "12793209", "PostTypeId": "2", "Body": "<p>The compiler is designed to work with the left-hand <code>i</code> and <code>f</code> as members of the class scope and the right-hand <code>i</code> and <code>f</code> as members of the constructor scope.</p>\n", "LastEditorUserId": "1348324", "LastActivityDate": "2012-10-09T06:07:01.237", "Score": "0", "CreationDate": "2012-10-09T05:15:31.827", "ParentId": "12793152", "CommentCount": "2", "OwnerUserId": "1348324", "LastEditDate": "2012-10-09T06:07:01.237"}, "bq_ids": {"n4140": {"so_12793152_12793512_1": {"length": 62, "quality": 1.0, "section_id": 438}, "so_12793152_12793512_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 440}, "so_12793152_12793512_3": {"length": 32, "quality": 0.8648648648648649, "section_id": 440}, "so_12793152_12793512_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 438}}, "n3337": {"so_12793152_12793512_1": {"length": 62, "quality": 1.0, "section_id": 429}, "so_12793152_12793512_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 431}, "so_12793152_12793512_3": {"length": 32, "quality": 0.8648648648648649, "section_id": 431}, "so_12793152_12793512_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 429}}, "n4659": {"so_12793152_12793512_1": {"length": 62, "quality": 1.0, "section_id": 458}, "so_12793152_12793512_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 460}, "so_12793152_12793512_3": {"length": 32, "quality": 0.8648648648648649, "section_id": 460}, "so_12793152_12793512_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 458}}}, "12793210": {"Id": "12793210", "PostTypeId": "2", "Body": "<p>Because of below points, which all C++ compilers follow as rule:</p>\n<ol>\n<li>Constructor initializer list can only exist with a class constructor</li>\n<li>In initializer list only the same class member and the base class\nconstructor can be called</li>\n<li>Initialization happens in the same order as the class data member\nare declared</li>\n</ol>\n<p>When compiler looks at <code>i</code> and <code>f</code> as part of initializer list, it immediately identifies as the class member and the things goes fine (point no. 2).<br>\nIf you try anything else other than <code>i</code> and <code>f</code>, compiler will give error.</br></p>\n<p>In 2nd case where you do assignment, compiler has 2 candidates for <code>i</code> and <code>f</code>. Either it can be a class member or a local variable. Since local variables are in inner most scope, compiler consider <code>i</code> as <code>i</code> and not <code>this-&gt;i</code>.</p>\n", "LastActivityDate": "2012-10-09T05:15:33.083", "CommentCount": "0", "CreationDate": "2012-10-09T05:15:33.083", "ParentId": "12793152", "Score": "1", "OwnerUserId": "514235"}, "12793152": {"ViewCount": "1260", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass Ex {\nprivate:\n    int i;\n    float f;\npublic:\n    Ex(int i,float f):i(i),f(f) {\n        cout &lt;&lt; this-&gt;i &lt;&lt; '\\t' &lt;&lt; this-&gt;f &lt;&lt; endl;\n    }\n    ~Ex(){\n        cout &lt;&lt; \"destructor\";\n    }\n};\nint main() {\n    Ex i(10,20.1f);\n}\n</code></pre>\n<p>In the program above I wrote above,if the constructor was parameterized constructor like the following:</p>\n<pre><code>Ex(int i,float f){\n        i=i;\n        f=f;\n        cout &lt;&lt; this-&gt;i &lt;&lt; '\\t' &lt;&lt; this-&gt;f &lt;&lt; endl;\n    }\n</code></pre>\n<p>here the data members of the object are initialized to junk because data members are hidden due to local variables of same name.\nBut in the program above it works fine without explicit this.How?</p>\n", "AcceptedAnswerId": "12793512", "Title": "Initialization lists,local variables vs data members", "CreationDate": "2012-10-09T05:08:16.547", "Id": "12793152", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-10-09T06:07:01.237", "Score": "0", "OwnerUserId": "1696337", "Tags": "<c++><oop><constructor><initialization>", "AnswerCount": "3"}, "12793512": {"Id": "12793512", "PostTypeId": "2", "Body": "<p>Similar questions have been asked before, e.g. <a href=\"https://stackoverflow.com/questions/2227244/what-if-a-constructor-parameter-has-the-same-name-as-a-member-variable-in-c\">here</a> and <a href=\"https://stackoverflow.com/questions/2476381/c-constructor-initialization-list-strangeness\">here</a>, but while many answers point out that this is (contrary to what Konstantin D - Infragistics says) not compiler-specific, I couldn't find any answer that actually quotes the relevant parts of the Standard.</p>\n<p>So here they are. I've added emphasis to highlight the key statements.</p>\n<blockquote>\n<p id=\"so_12793152_12793512_0\">(\u00a712.6.2/10) <strong>In a non-delegating constructor, initialization proceeds in the following order:</strong> </p>\n<p id=\"so_12793152_12793512_1\">\u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.<br>\n  \u2014 Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).<br>\n  \u2014 Then, <strong>non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).</strong><br>\n  \u2014 Finally, the compound-statement of the constructor body is executed.</br></br></br></p>\n<p id=\"so_12793152_12793512_2\">(\u00a712.6.2/12) Names in the expression-list or braced-init-list of a mem-initializer are <strong>evaluated in the scope of the constructor</strong> for which the mem-initializer is specified. [ Example:</p>\n<pre><code>    class X {\n      int a;\n      int b;\n      int i;\n      int j;\n    public:\n      const int&amp; r;\n      X(int i): r(a), b(i), i(i), j(this-&gt;i) { }\n    };\n</code></pre>\n<p id=\"so_12793152_12793512_3\">initializes <code>X::r</code> to refer to <code>X::a</code>, initializes <code>X::b</code> with the value of the constructor parameter <code>i</code>, <strong>initializes <code>X::i</code> with the value of the constructor parameter <code>i</code></strong>, and initializes <code>X::j</code> with the value of <code>X::i</code>; this takes place each time an object of class X is created. \u2014 end example ]<br>\n  [ Note: Because the mem-initializer are evaluated in the scope of the constructor, the <code>this</code> pointer can be used in the expression-list of a mem-initializer to refer to the object being initialized. \u2014 end note ]</br></p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-09T05:44:58.560", "Score": "2", "CreationDate": "2012-10-09T05:44:58.560", "ParentId": "12793152", "CommentCount": "0", "OwnerUserId": "777186", "LastEditDate": "2017-05-23T11:56:17.980"}});