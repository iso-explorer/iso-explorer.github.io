post_cb({"33739488": {"ParentId": "33739289", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-11-16T15:57:13.863", "Score": "5", "LastEditorUserId": "496161", "LastEditDate": "2015-11-16T16:10:18.930", "Id": "33739488", "OwnerUserId": "496161", "Body": "<p>This is standard.</p>\n<blockquote>\n<p id=\"so_33739289_33739488_0\"><code>N4140 [temp.dep]/3:</code> In the definition of a class or class template, if a base class depends on a template-parameter, the base class\n  scope is not examined during unqualified name lookup either at the point of definition of the class template\n  or member or during an instantiation of the class template or member.</p>\n</blockquote>\n<p>For <code>buzz</code>, the base class depends on a template parameter, so the <code>foo</code> unqualified lookup does not examine its scope. That is why you need qualified lookup.</p>\n", "LastActivityDate": "2015-11-16T16:10:18.930"}, "33739289": {"CommentCount": "0", "ViewCount": "49", "CreationDate": "2015-11-16T15:47:24.027", "LastActivityDate": "2015-11-16T16:10:18.930", "Title": "Making class templated forces repeating base class template params in inheriting constructor", "AcceptedAnswerId": "33739488", "PostTypeId": "1", "Id": "33739289", "Score": "3", "Body": "<p>I recently changed a class from being templated to not, and discovered that I can no longer omit template arguments when writing a using declaration to inherit a constructor from a templated base class. As long as my class isn't templated I can omit the arguments, as soon as it is I can't. In the compilable snippet below <code>bar</code> represents the class before and <code>buzz</code> represents the class after. I've tested both GCC 5.2 and Clang 3.7 and they have the same behavior. Is this a compiler bug or standard?</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class A, class B&gt;\nstruct foo {\n    foo(int x) {\n        std::cout &lt;&lt; x &lt;&lt; std::endl;\n    }\n};\n\nstruct bar : foo&lt;bar, short&gt; {\n    using foo::foo; // this appears legal\n    // using foo&lt;bar, short&gt;::foo; // this works too, thought I would need it\n};\n\ntemplate&lt;class X&gt;\nstruct buzz : foo&lt;buzz&lt;X&gt;, short&gt; {\n     //using foo::foo; // no longer legal for some reason\n    using foo&lt;buzz&lt;X&gt;, short&gt;::foo; // now do actually need this\n};\n\nint main() {\n    bar x(3);\n    buzz&lt;float&gt; y(5);\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><g++><c++14><clang++>", "OwnerUserId": "50385", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33739289_33739488_0": {"section_id": 190, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_33739289_33739488_0": {"section_id": 184, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_33739289_33739488_0": {"section_id": 195, "quality": 0.7586206896551724, "length": 22}}}});