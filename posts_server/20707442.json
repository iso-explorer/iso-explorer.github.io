post_cb({"20708495": {"ParentId": "20707442", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Example code:</p>\n<pre><code>int&amp; foo() { static int x; return x; }\nint bar() { return 0; }\n\ntemplate&lt; class Type &gt;\nstruct Is_ref_ { static const bool yes = false; };\n\ntemplate&lt; class Type &gt;\nstruct Is_ref_&lt;Type&amp;&gt; { static const bool yes = true; };\n\n#include &lt;iostream&gt;\nusing namespace std;\nauto main() -&gt; int\n{\n    cout &lt;&lt; boolalpha;\n    cout &lt;&lt; \"Function calls foo versus bar:\" &lt;&lt; endl;\n    cout &lt;&lt; Is_ref_&lt;decltype(foo())&gt;::yes &lt;&lt; endl;\n    cout &lt;&lt; Is_ref_&lt;decltype(bar())&gt;::yes &lt;&lt; endl;\n\n    int a;\n    int&amp; b = a;\n    cout &lt;&lt; endl;\n    cout &lt;&lt; \"lvalue versus ref:\" &lt;&lt; endl;\n    cout &lt;&lt; Is_ref_&lt;decltype(a)&gt;::yes &lt;&lt; endl;\n    cout &lt;&lt; Is_ref_&lt;decltype(b)&gt;::yes &lt;&lt; endl;\n}\n</code></pre>\n<p>Output with Visual C++ 12.0 and with MinGW g++ 4.7.2:</p>\n<blockquote>\n<p id=\"so_20707442_20708495_0\">Function calls foo versus bar:<br>\n  true<br>\n  false  </br></br></p>\n<p id=\"so_20707442_20708495_1\">lvalue versus ref:<br>\n  false<br>\n  true  </br></br></p>\n</blockquote>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2013-12-20T17:20:10.153", "Id": "20708495", "Score": "0", "CreationDate": "2013-12-20T16:59:33.683", "LastActivityDate": "2013-12-20T17:20:10.153"}, "20708771": {"ParentId": "20707442", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This was corrected post publication of the standard, in <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1261\" rel=\"nofollow\">DR 1261</a>.  Draft n3485 reads:</p>\n<blockquote>\n<p id=\"so_20707442_20708771_0\">[...] otherwise, the type of the function call expression is the return type of the statically chosen function (i.e.,\n  ignoring the <code>virtual</code> keyword), even if the type of the function actually called is different. This <strong>return</strong> type\n  shall be an object type, a reference type or <em><code>cv</code></em> <code>void</code>.</p>\n</blockquote>\n<p>(my emphasis; not in your quote).</p>\n<p>The two paragraphs are now compatible; the (initial) type of the function call expression is now <code>int &amp;</code>, which gets adjusted to <code>int</code> and value-category lvalue immediately.  A similar process occurs with a function returning a qualified type, which has the advantage that we don't need to worry about lvalue-to-reference conversion:</p>\n<pre><code>const int g();\nstatic_assert(std::is_same&lt;decltype(g()), int&gt;::value, \"!!!\");\n</code></pre>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2013-12-20T17:25:19.473", "Id": "20708771", "Score": "2", "CreationDate": "2013-12-20T17:18:07.477", "LastActivityDate": "2013-12-20T17:25:19.473"}, "20708335": {"ParentId": "20707442", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The type of <code>f()</code> is <code>int</code>; its value category is lvalue. You can demonstrate this fact:</p>\n<pre><code>int&amp; f();\nstatic_assert(std::is_same&lt;int&amp;,decltype((f()))&gt;::value,\"EXPLODE\");\n</code></pre>\n<p>per C++11 \u00a77.1.6.2 [dcl.type.simple]/4 \"...if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>\".</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2013-12-20T17:13:48.673", "Id": "20708335", "Score": "0", "CreationDate": "2013-12-20T16:51:24.873", "LastActivityDate": "2013-12-20T17:13:48.673"}, "bq_ids": {"n4140": {"so_20707442_20707442_1": {"section_id": 5990, "quality": 0.9166666666666666, "length": 33}, "so_20707442_20707442_0": {"section_id": 5938, "quality": 0.8695652173913043, "length": 20}, "so_20707442_20708771_0": {"section_id": 5990, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_20707442_20707442_1": {"section_id": 5758, "quality": 0.9444444444444444, "length": 34}, "so_20707442_20707442_0": {"section_id": 5710, "quality": 0.8695652173913043, "length": 20}, "so_20707442_20708771_0": {"section_id": 5758, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_20707442_20707442_1": {"section_id": 7490, "quality": 0.8888888888888888, "length": 32}, "so_20707442_20707442_0": {"section_id": 7422, "quality": 0.8695652173913043, "length": 20}, "so_20707442_20708771_0": {"section_id": 7490, "quality": 0.9259259259259259, "length": 25}}}, "20707442": {"CommentCount": "8", "ViewCount": "248", "PostTypeId": "1", "LastEditorUserId": "420683", "CreationDate": "2013-12-20T15:58:23.873", "LastActivityDate": "2013-12-20T17:25:19.473", "Title": "What's the type of the function call expression?", "LastEditDate": "2013-12-20T16:31:09.663", "Id": "20707442", "Score": "3", "Body": "<p>This is a language lawyer question. Clause 5p5 in C++11 reads:</p>\n<blockquote>\n<p id=\"so_20707442_20707442_0\">If an expression initially has the type \u201creference to T\u201d (8.3.2, 8.5.3), the type is adjusted to T prior to\n  any further analysis. The expression designates the object or function denoted by the reference, and the\n  expression is an lvalue or an xvalue, depending on the expression.</p>\n</blockquote>\n<p>On the other hand, \u00a75.2.2p3 states:</p>\n<blockquote>\n<p id=\"so_20707442_20707442_1\">If the postfix-expression designates a destructor (12.4), the type of the function call expression is void;\n  otherwise, the type of the function call expression is the return type of the statically chosen function (i.e.,\n  ignoring the virtual keyword), even if the type of the function actually called is different. This type shall\n  be an object type, a reference type or the type void.</p>\n</blockquote>\n<p>Consider this piece of code:</p>\n<pre><code>int&amp; f();\nf();  // What is the type of this expression?\n</code></pre>\n", "Tags": "<c++><c++11><types><reference><expression>", "OwnerUserId": "1770418", "AnswerCount": "3"}});