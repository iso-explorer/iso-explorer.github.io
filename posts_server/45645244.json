post_cb({"bq_ids": {"n4140": {"so_45645244_45645456_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 304}}, "n3337": {"so_45645244_45645456_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 295}}, "n4659": {"so_45645244_45645456_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 311}}}, "45645694": {"Id": "45645694", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45645244_45645694_0\">Does the compiler stick 42 somewhere (on the stack?) and pass its address to <code>foo</code>?</p>\n</blockquote>\n<p>A temporary object of type <code>const int</code> is created, initialized with the prvalue expression <code>42</code>, and bound to the reference.</p>\n<p>In practice,  if <code>foo</code> is not inlined, that requires allocating space on the stack, storing <code>42</code> into it, and passing the address.</p>\n<blockquote>\n<p id=\"so_45645244_45645694_1\">Is there anything in the standard that dictates what is to be done in this situation (or is it strictly up to the compiler)?</p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.ref#5.2.1\" rel=\"nofollow noreferrer\">[dcl.init.ref]</a>.</p>\n<blockquote>\n<p id=\"so_45645244_45645694_2\">Besides ODR, why can't the compiler do whatever it did with 42 above?</p>\n</blockquote>\n<p>Because according to the language, the reference is bound to the object <code>bar::baz</code>, and unless the compiler knows exactly what <code>foo</code> is doing at the point where it is compiling the call, then it has to assume that this is significant. For example, if <code>foo</code> contains an <code>assert(&amp;x == &amp;bar::baz);</code>, that <em>must not</em> fire with <code>foo(bar::baz)</code>.</p>\n<p>(In C++17, <code>baz</code> is <a href=\"https://timsong-cpp.github.io/cppwp/dcl.constexpr#1.sentence-2\" rel=\"nofollow noreferrer\">implicitly inline as a <code>constexpr</code> static data member</a>; no separate definition is required.)</p>\n<blockquote>\n<p id=\"so_45645244_45645694_3\">Is there an elegant way to tell <code>foo</code> to accept <code>x</code> by value for primitive types? </p>\n</blockquote>\n<p>There is generally not much point in doing this in the absence of profiling data showing that pass-by-reference is actually causing problems, but if you really need to do it for some reason, adding (possibly SFINAE-constrained) overloads would be the way to go.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2017-08-12T17:16:19.823", "Score": "11", "CreationDate": "2017-08-12T01:29:46.227", "ParentId": "45645244", "CommentCount": "5", "OwnerUserId": "2756719", "LastEditDate": "2017-08-12T17:16:19.823"}, "45645456": {"Id": "45645456", "PostTypeId": "2", "Body": "<p>With C++17 that code compiles perfectly considering usage of bar::baz as inline, with C++14 the template requires prvalue as an argument, so compiler retains a symbol for <code>bar::baz</code> in object code. Which will not get resolved because you didn't had that declaration. <code>constexpr</code> should be treated as constprvalue or rvalues by compiler, in code generation that may lead to different approach. E.g. if called function is inline,  compiler may generate code that is using that particular value as  constant argument of  processor's  instruction. Keywords here are \"should be\" and \"may\", which are as different from \"must\" as usual disclaimer clause in  general standard documentation states.</p>\n<p>For a primitive type, for a temporal value and <code>constexpr</code> there will be no difference, in which template signature you do use. How actually compiler implements it, depends on platform and compiler... and calling conventions used. we can't really even tell if something is on stack for sure, because some platform do NOT have stack    or it is implemented differently from stack on x86 platform. Multiple modern calling conventions do use registers of CPU to pass arguments. </p>\n<p>If your compiler is modern enough you don't need references at all,  copy elision would save you from extra copy operations. To prove that:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid foo(T x) { std::cout &lt;&lt; x.baz &lt;&lt; std::endl; }\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct bar\n{\n    int baz;\n\n    bar(const int b = 0): baz(b)\n    {\n        cout &lt;&lt; \"Constructor called\" &lt;&lt; endl;\n    }    \n\n    bar(const bar &amp;b): baz(b.baz)  //copy constructor\n    {\n        cout &lt;&lt; \"Copy constructor called\" &lt;&lt; endl;\n    } \n};\n\nint main() \n{ \n    foo(bar(42)); \n}\n</code></pre>\n<p>will result in output:</p>\n<pre><code>Constructor called\n42\n</code></pre>\n<p>Passing by reference, by a const reference wouldn't cost more than passing by value, especially for templates. If you need different semantics, you would require explicit specialization of template. Some older compilers couldn't support the latter in proper way.</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(const T&amp; x) { std::cout &lt;&lt; x.baz &lt;&lt; std::endl; }\n\n// ...\n\nbar b(42);\nfoo(b); \n</code></pre>\n<p>Output:</p>\n<pre><code>Constructor called\n42\n</code></pre>\n<p>Non-const  reference would not allow us  to  forward argument, if it was an lvalue, e.g</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T&amp; x) { std::cout &lt;&lt; x.baz &lt;&lt; std::endl; }\n// ...\nfoo(bar(42)); \n</code></pre>\n<p>by calling this template (called perfect forwarding )</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T&amp;&amp; x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }\n</code></pre>\n<p>one would be able to  avoid forwarding problems, though this process would\nalso involve copy elision. Compiler deduces  template parameter as follows from C++17</p>\n<blockquote>\n<pre><code>template &lt;class T&gt; int f(T&amp;&amp; heisenreference);\ntemplate &lt;class T&gt; int g(const T&amp;&amp;);\nint i;\nint n1 = f(i); // calls f&lt;int&amp;&gt;(int&amp;)\nint n2 = f(0); // calls f&lt;int&gt;(int&amp;&amp;)\nint n3 = g(i); // error: would call g&lt;int&gt;(const int&amp;&amp;), which\n               // would bind an rvalue reference to an lvalue\n</code></pre>\n<p id=\"so_45645244_45645456_0\">A forwarding reference is an rvalue reference to a cv-unqualified\n  template parameter. If P is a forwarding reference and the argument is\n  an lvalue, the type \u201clvalue reference to A\u201d is used in place of A for\n  type deduction.</p>\n</blockquote>\n", "LastEditorUserId": "2742717", "LastActivityDate": "2017-08-12T16:39:20.950", "Score": "2", "CreationDate": "2017-08-12T00:41:48.097", "ParentId": "45645244", "CommentCount": "15", "OwnerUserId": "2742717", "LastEditDate": "2017-08-12T16:39:20.950"}, "45645586": {"Id": "45645586", "PostTypeId": "2", "Body": "<p>Your <strong>example #1</strong>. Constant location completely depends on the compiler and is not defined in a standard. GCC on Linux might allocate such constants in a static read-only memory section. Optimization will probably remove it all together.</p>\n<p>Your <strong>example #2</strong> will not compile (before link). Due to the scoping rules. So you need <code>bar::baz</code> there.</p>\n<p><strong>example #3,</strong> i usually do this:</p>\n<pre><code>template&lt;typename T&gt;\n    void foo(const T&amp; x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }\n</code></pre>\n", "LastEditorUserId": "2459511", "LastActivityDate": "2017-09-06T16:58:25.177", "Score": "2", "CreationDate": "2017-08-12T01:07:27.390", "ParentId": "45645244", "CommentCount": "1", "OwnerUserId": "1143850", "LastEditDate": "2017-09-06T16:58:25.177"}, "45645244": {"ViewCount": "439", "Body": "<p>Imagine the following simplified code:</p>\n<pre><code>#include &lt;iostream&gt;\nvoid foo(const int&amp; x) { do_something_with(x); }\n\nint main() { foo(42); return 0; }\n</code></pre>\n<p>(1) Optimizations aside, what happens when 42 is passed to <code>foo</code>?</p>\n<p>Does the compiler stick 42 somewhere (on the stack?) and pass its address to <code>foo</code>?</p>\n<p>(1a) Is there anything in the standard that dictates what is to be done in this situation (or is it strictly up to the compiler)?</p>\n<hr>\n<p>Now, imagine slightly different code:</p>\n<pre><code>#include &lt;iostream&gt;\nvoid foo(const int&amp; x) { do_something_with(x); }\n\nstruct bar { static constexpr int baz = 42; };\n\nint main() { foo(bar::baz); return 0; }\n</code></pre>\n<p>It won't link, unless I define <code>int bar::baz;</code> (due to ODR?).</p>\n<p>(2) Besides ODR, why can't the compiler do whatever it did with 42 above?</p>\n<hr>\n<p>An obvious way to simplify things is to define <code>foo</code> as:</p>\n<pre><code>void foo(int x) { do_something_with(x); }\n</code></pre>\n<p>However, what would one do in case of a template? Eg:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T&amp;&amp; x) { do_something_with(std::forward&lt;T&gt;(x)); }\n</code></pre>\n<p>(3) Is there an elegant way to tell <code>foo</code> to accept <code>x</code> by value for primitive types? Or do I need to specialize it with SFINAE or some such?</p>\n<p><strong>EDIT</strong>: Modified what happens inside <code>foo</code> as it's irrelevant to this question.</p>\n</hr></hr>", "AcceptedAnswerId": "45645694", "Title": "Passing literal as a const ref parameter", "CreationDate": "2017-08-11T23:58:27.150", "Id": "45645244", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-08-12T16:54:02.957", "LastEditorUserId": "4358570", "LastActivityDate": "2017-09-06T16:58:25.177", "Score": "16", "OwnerUserId": "4358570", "Tags": "<c++><c++11><one-definition-rule><forwarding-reference><pass-by-const-reference>", "AnswerCount": "3"}});