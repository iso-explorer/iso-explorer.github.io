post_cb({"18355814": {"CommentCount": "8", "ViewCount": "1031", "PostTypeId": "1", "LastEditorUserId": "1609356", "CreationDate": "2013-08-21T11:08:37.653", "LastActivityDate": "2013-08-21T15:36:29.953", "Title": "Forcing variadic template member function instantiation in class", "AcceptedAnswerId": "18361773", "LastEditDate": "2013-08-21T12:14:45.347", "Id": "18355814", "Score": "3", "Body": "<p>I have a class which has a variadic member function:</p>\n<pre><code>class class_name {\n  template&lt;ArgTypes.. args&gt;\n  some_return_type memberMethod(ArgTypes... args) {\n    //stuff...\n  }\n}\n</code></pre>\n<p>I need to force instantiation of this method <strong>inside the class definition block</strong>.\nI loose the method name outside of the class definition block because the class is generated by a bunch of macros.</p>\n<p>I try to force the instantiation by copying a pointer to a specialised member function (pseudo code):</p>\n<pre><code>template&lt;typename Self, typename RetType, typename... ArgTypes&gt;\nstruct force_instantation_imlp&lt;Self, RetType, type_placeholder, type_placeholder&lt;ArgTypes...&gt;&gt; {\n    force_instantation_imlp() {\n        using instate = RetType (Self::*)(ArgTypes...);\n        instate force = &amp;Self::memberMethod&lt;ArgTypes...&gt;;        \n    }\n};\n\n\nclass class_name {\n  template&lt;ArgTypes.. args&gt;\n  some_return_type memberMethod(ArgTypes... args) {\n    //stuff...\n  }\n\n  force_instantation_imlp&lt;class_name, some_return_type, rest_of_types_deduced_from_context&gt; force_virtual_instantation;\n}\n</code></pre>\n<p><code>type_placeholder</code> is just a helper template to \"freeze\" parameter pack.</p>\n<p>This unfortunately gives me a compile error </p>\n<pre><code>error: expected primary-expression before \u2018...\u2019 token instate force = &amp;Self::memberMethod&lt;ArgTypes...&gt;;\n</code></pre>\n<p>I guess that this error results from teh fact that the member function is a variadic template.</p>\n<p>Is there any way to force variadic template member function instantiation inside the class definition block?</p>\n", "Tags": "<c++><templates><c++11><variadic-templates>", "OwnerUserId": "434341", "AnswerCount": "1"}, "18361773": {"ParentId": "18355814", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-08-21T15:36:29.953", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:32:15.027", "Id": "18361773", "OwnerUserId": "420683", "Body": "<p>(Repeating from my comments to the OP.)</p>\n<p>The actual problem in the line <code>instate force = &amp;Self::memberMethod&lt;ArgTypes...&gt;;</code> is a missing <code>template</code> keyword:</p>\n<pre><code>instate force = &amp;Self::template memberMethod&lt;ArgTypes...&gt;;\n</code></pre>\n<p>See, e.g. <a href=\"https://stackoverflow.com/q/610245/420683\">Where and why do I have to put the \u201ctemplate\u201d and \u201ctypename\u201d keywords?</a></p>\n<p>Actually, the explicit template arguments are not necessary here [over.over]/1:</p>\n<blockquote>\n<p id=\"so_18355814_18361773_0\">A use of an overloaded function name without arguments is resolved in certain contexts to [...] a pointer to member function for a specific function from the overload set. A function template name is considered to name a set of overloaded functions in such contexts. The function selected is the one whose type is identical to the function type of the target type required in the context.</p>\n</blockquote>\n<p>i.e., because <code>instate</code> defines the function type, the compiler is able to determine which overload (<em>here:</em> template specialization) to choose for the name <code>Self::memberMethod</code>.</p>\n<hr>\n<p>There might be easier solutions to force instantiation of a function template, even inside the class definition. One that comes to my mind is to use a private <code>typedef</code> like <code>using dummy = integral_constant&lt;instate, &amp;Self::memberMethod&gt;;</code> (or a <code>static constexpr instate dummy = &amp;Self::memberMethod;</code>).</p>\n<p><sub>I'm quite, but not 100 % sure the <code>typedef</code> forces the instantiation of the member function template. The function template is instantiated when a definition of that function is required, and the ODR suggests this is the case here: <em>\"A function whose name appears as a potentially-evaluated expression is odr-used if it is the unique lookup result or the selected member of a set of overloaded functions\"</em> and <em>\"Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program\"</em></sub></p>\n</hr>", "LastActivityDate": "2013-08-21T15:36:29.953"}, "bq_ids": {"n4140": {"so_18355814_18361773_0": {"section_id": 641, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_18355814_18361773_0": {"section_id": 631, "quality": 0.972972972972973, "length": 36}}, "n4659": {"so_18355814_18361773_0": {"section_id": 669, "quality": 0.8108108108108109, "length": 30}}}});