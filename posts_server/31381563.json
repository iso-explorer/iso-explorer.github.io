post_cb({"bq_ids": {"n4140": {"so_31381563_31381563_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7040}, "so_31381563_31381563_3": {"length": 9, "quality": 0.9, "section_id": 7040}, "so_31381563_31381563_1": {"length": 23, "quality": 0.5609756097560976, "section_id": 7040}, "so_31381563_31381563_4": {"length": 8, "quality": 0.5714285714285714, "section_id": 7040}}, "n3337": {"so_31381563_31381563_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 6785}}, "n4659": {"so_31381563_31381563_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 8537}, "so_31381563_31381563_3": {"length": 9, "quality": 0.9, "section_id": 8537}, "so_31381563_31381563_4": {"length": 8, "quality": 0.5714285714285714, "section_id": 8537}, "so_31381563_31381563_1": {"length": 23, "quality": 0.5609756097560976, "section_id": 8537}, "so_31381563_31381563_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 802}}}, "31381935": {"Id": "31381935", "PostTypeId": "2", "Body": "<p>cppreference <strike>is</strike> was wrong; it is clear from the language in the standard (whichever version) that both subclauses must hold. I've corrected it.</p>\n<p>In your example, <code>s</code> is not a constant expression (C++14: does not satisfy the requirements for appearing in a constant expression) so is odr-used. The second subclause does not arise.</p>\n<p>Meanwhile, <code>x</code> is also odr-used, because although it would be possible to use <code>x</code> in a constant expression in an appropriate context (e.g. as an array bound within the definition of <code>S</code>); <code>x</code> is not one of the potential results of the enclosing expression <code>s.x</code>, which is the only enclosing expression subject to either the discarded-value transformation or the lvalue-to-rvalue conversion.</p>\n<p>gcc might be OK without a definition of <code>s</code> or <code>x</code>, but there's no requirement that an implementation diagnose every odr violation.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2015-07-13T12:49:41.477", "Score": "3", "CreationDate": "2015-07-13T11:17:10.993", "ParentId": "31381563", "CommentCount": "4", "OwnerUserId": "567292", "LastEditDate": "2015-07-13T12:49:41.477"}, "31381563": {"ViewCount": "140", "Body": "<p>In N4296, 3.2 [basic.def.odr]p3:</p>\n<blockquote>\n<p id=\"so_31381563_31381563_0\">A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is odr-used by <code>ex</code> unless applying the lvalue-to-rvalue conversion to <code>x</code> yields a constant expression that does not invoke any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of the set of potential results of an expression <code>e</code>, where either the lvalue-to-rvalue conversion is applied to <code>e</code>, or <code>e</code> is a discarded-value expression.</p>\n</blockquote>\n<p>How to explain this paragraph? I found two explanation.</p>\n<p>1 from here \"<a href=\"https://stackoverflow.com/questions/29997142/trying-to-understand-basic-def-odr-2-in-c14-n4140\">Trying to understand [basic.def.odr]/2 in C++14 (N4140)</a>\"</p>\n<blockquote id=\"so_31381563_31381563_1\">\nLet's split this into steps: The occurrence of a variable `x` in an expression `ex` constitutes an odr-use unless:\n<ol>\n<li><b>Either</b> <code>ex</code> is not potentially evaluated, <b>or</b></li>\n<li><b>All of the following must be fulfilled:</b>\n<ol>\n<li><i>\"applying the lvalue-to-rvalue conversion to <code>x</code> yields a constant expression that does not invoke any non-trivial functions\"</i> <b>and</b></li>\n<li><i>\"<code>ex</code> is an element of the set of potential results of an expression <code>e</code>\"</i> <b>and either of the following holds</b>:\n         <ol>\n<li><i>\"<b>either</b> the lvalue-to-rvalue conversion is applied to <code>e</code>\"</i></li>\n<li><i>\"<b>or</b> <code>e</code> is a discarded-value expression\"</i></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>and 2 from cppreference <a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/definition</a></p>\n<blockquote>\n<p id=\"so_31381563_31381563_2\">a variable <code>x</code> in a potentially-evaluated expression <code>ex</code> is odr-used unless <strong>any</strong> of the following is true:</p>\n<ul>\n<li><p id=\"so_31381563_31381563_3\">applying lvalue-to-rvalue conversion to <code>x</code> yields a constant expression that doesn't invoke non-trivial functions</p></li>\n<li><p id=\"so_31381563_31381563_4\"><code>x</code> is an object and ex is one of the potential results of a larger expression <code>e</code>, where that larger expression is either a discarded-value expression or an lvalue-to-rvalue conversion </p></li>\n</ul>\n</blockquote>\n<p>First answer about two rules is <strong>and</strong>, the other is <strong>any</strong>. Which one is right?</p>\n<p>Please split rules into steps to explain this code:</p>\n<pre><code>struct S { static const int x = 0; };\nextern S s;// no definition of s\nint i = s.x;// is s odr-used? is x odr-used?\n            // gcc 5.1.0 is ok\n</code></pre>\n", "AcceptedAnswerId": "31381935", "Title": "One definition rule about class member access expression", "CreationDate": "2015-07-13T10:58:33.750", "Id": "31381563", "CommentCount": "0", "LastEditDate": "2017-05-23T12:16:01.020", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-13T12:49:41.477", "Score": "5", "OwnerUserId": "4958516", "Tags": "<c++><one-definition-rule>", "AnswerCount": "1"}});