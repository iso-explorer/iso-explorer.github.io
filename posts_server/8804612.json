post_cb({"8808865": {"Id": "8808865", "PostTypeId": "2", "Body": "<p>Of course, when the reference is first initialised it is done so validly, satisfying the following:</p>\n<blockquote>\n<p id=\"so_8804612_8808865_0\"><code>[C++11: 8.3.2/5]:</code> There shall be no references to references, no arrays of references, and no pointers to references. The declaration of a reference shall contain an initializer (8.5.3) except when the declaration contains an explicit extern specifier (7.1.1), is a class member (9.2) declaration within a class definition, or is the declaration of a parameter or a return type (8.3.5); see 3.1. <strong>A reference shall be initialized to refer to a valid object or function.</strong> [ <em>Note:</em> in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the \u201cobject\u201d obtained by dereferencing a null pointer, which causes undefined behavior. As described in 9.6, a reference cannot be bound directly to a bit-field. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>The reference being returned from the function is an <em>xvalue</em>:</p>\n<blockquote>\n<p id=\"so_8804612_8808865_1\"><code>[C++11: 3.10/1]:</code> [..] An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references (8.3.2). [ <em>Example:</em> The result of calling a function whose return type is an rvalue reference is an xvalue. <em>\u2014end example</em> ] [..]</p>\n</blockquote>\n<p>That means the following does <em>not</em> apply:</p>\n<blockquote>\n<p id=\"so_8804612_8808865_2\"><code>[C++11: 12.2/1]:</code> Temporaries of class type are created in various contexts: binding a reference to a prvalue (8.5.3), <strong>returning a prvalue (6.6.3)</strong>, a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing an exception (15.1), entering a handler (15.3), and in some initializations (8.5).</p>\n<p id=\"so_8804612_8808865_3\"><code>[C++11: 6.6.3/2]:</code> A return statement with neither an <em>expression</em> nor a <em>braced-init-list</em> can be used only in functions that do not return a value, that is, a function with the return type void, a constructor (12.1), or a destructor (12.4).</p>\n<p id=\"so_8804612_8808865_4\">A return statement with an expression of non-void type can be used only in functions returning a value; the value of the expression is returned to the caller of the function. <strong>The value of the expression is implicitly converted to the return type of the function in which it appears. A return statement can involve the construction and copy or move of a temporary object (12.2).</strong> [ <em>Note:</em> A copy or move operation associated with a return statement may be elided or considered as an rvalue for the purpose of overload resolution in selecting a constructor (12.8). <em>\u2014end note</em> ] A return statement with a <em>braced-init-list</em> initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list. [ <em>Example:</em></p>\n<pre><code>std::pair&lt;std::string,int&gt; f(const char* p, int x) {\n   return {p,x};\n}\n</code></pre>\n<p id=\"so_8804612_8808865_5\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>Additionally, even if we interpret the following to mean that an initialisation of a new reference \"object\" is performed, the referee is <em>probably</em> still alive at the time:</p>\n<blockquote>\n<p id=\"so_8804612_8808865_6\"><code>[C++11: 8.5.3/2]:</code> A reference cannot be changed to refer to another object after initialization. Note that initialization of a reference is treated very differently from assignment to it. <strong>Argument passing (5.2.2) and function value return (6.6.3) are initializations.</strong></p>\n</blockquote>\n<ul>\n<li><em>This makes #1 valid.</em></li>\n</ul>\n<p>However, your initialisation of <em>a new reference <code>ref</code></em> inside <code>main</code> quite clearly violates <code>[C++11: 8.3.2/5]</code>. I can't find wording for it, but it stands to reason that the function scope has been exited when the initialisation is performed.</p>\n<ul>\n<li><em>This would make #2 (and consequently #3) invalid.</em></li>\n</ul>\n<p>At the very least, there does not appear to be anything further stated about the matter in the standard, so if the above reasoning is not sufficient then we have to conclude that the standard is ambiguous in the matter. Fortunately, it's of little consequence in practice, at least in the mainstream.</p>\n", "LastActivityDate": "2012-01-10T18:56:16.400", "CommentCount": "6", "CreationDate": "2012-01-10T18:56:16.400", "ParentId": "8804612", "Score": "5", "OwnerUserId": "560648"}, "8804612": {"ViewCount": "229", "Body": "<p><sub>(I am aware of the fact that returning address/reference to a variable local to the function should be avoided and a program should never do this.)</sub></p>\n<hr>\n<p>Does returning a reference to a local variable/reference result in Undefined Behavior? Or does the Undefined Behavior only occur later, when the returned reference is used (or \"dereferenced\")?</p>\n<p>i.e. at what exact statement (<code>#1</code> or <code>#2</code> or <code>#3</code>) does code sample below invoke Undefined Behavior? (I've written my theory alongside each one)</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{ \n   int m_i;\n   A():m_i(10)\n   {\n\n   } \n};  \nA&amp; foo() \n{     \n    A a;\n    a.m_i = 20;     \n    return a; \n} \n\nint main()\n{\n   foo();                // #1 - Not UB; return value was never used\n   A const &amp;ref = foo(); // #2 - Not UB; return value still not yet used\n   std::cout&lt;&lt;ref.m_i;   // #3 - UB: returned value is used\n}\n</code></pre>\n<p>I am interested to know what the C++ standard specifies in this regard.</p>\n<p>I would like a citation from the C++ standard which will basically tell me which exact statement makes this code ill-formed.</p>\n<p>Discussions about how specific implementations handle this are welcome but as I said an ideal answer would cite an reference from the C++ Standard that clarifies this beyond doubt.</p>\n</hr>", "AcceptedAnswerId": "8808865", "Title": "At which exact statement does this program exhibit Undefined behavior as per the C++ standard?", "CreationDate": "2012-01-10T14:11:36.320", "Id": "8804612", "CommentCount": "12", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-01-10T19:01:16.770", "LastEditorUserId": "560648", "LastActivityDate": "2012-01-10T19:01:16.770", "Score": "3", "OwnerUserId": "452307", "Tags": "<c++><undefined-behavior>", "AnswerCount": "3"}, "8804928": {"Id": "8804928", "PostTypeId": "2", "Body": "<p>I would say #3. Alone, #2 doesn't actually do anything even though the referenced object is already out of scope. This isn't really a standards-related issue because it is the result of two mistakes made in succession:</p>\n<ol>\n<li>Returning a reference to an out-of-scope object followed by</li>\n<li>Use of a reference.</li>\n</ol>\n<p>Either in isolation has defined behavior. Whether the standard has anything to say regarding use of references to objects beyond the end of their lifetime is another matter.</p>\n", "LastEditorUserId": "671509", "LastActivityDate": "2012-01-10T16:43:31.540", "Score": "0", "CreationDate": "2012-01-10T14:34:34.887", "ParentId": "8804612", "CommentCount": "7", "OwnerUserId": "671509", "LastEditDate": "2012-01-10T16:43:31.540"}, "8804896": {"Id": "8804896", "PostTypeId": "2", "Body": "<p>Here's my incomplete and possible insufficient view on the matter:</p>\n<p>The only thing special about references is that <em>at initialization time</em> they must refer to a valid object. If the object later stops existing, using the reference is UB, and so is initializing another reference to the now-defunct reference.</p>\n<p>The following much simpler example provides exactly the same dilemma as your question, I think:</p>\n<pre><code>std::reference_wrapper&lt;T&gt; r;\n\n{\n    T t;\n    r = std::ref(t);\n}\n\n// #1\n</code></pre>\n<p>At #1, the reference inside <code>r</code> is no longer valid, but the program is fine. Just don't <em>read</em> <code>r</code>.</p>\n<p>In your example, line #1 is fine, and line #2 isn't -- that is because the original line #2 calls <code>A::A(A const &amp;)</code> with argument <code>foo()</code>, and as discussed, this fails to initialize the function argument variable with a <em>valid</em> reference, and so would your edited version <code>A const &amp; a = foo();</code>.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-01-10T14:41:58.193", "Score": "2", "CreationDate": "2012-01-10T14:32:50.687", "ParentId": "8804612", "CommentCount": "15", "OwnerUserId": "596781", "LastEditDate": "2012-01-10T14:41:58.193"}, "bq_ids": {"n4140": {"so_8804612_8808865_2": {"length": 18, "quality": 0.6428571428571429, "section_id": 378}, "so_8804612_8808865_6": {"length": 21, "quality": 0.84, "section_id": 3318}, "so_8804612_8808865_0": {"length": 61, "quality": 0.8591549295774648, "section_id": 3222}, "so_8804612_8808865_1": {"length": 33, "quality": 0.825, "section_id": 7230}, "so_8804612_8808865_4": {"length": 57, "quality": 0.8769230769230769, "section_id": 3913}, "so_8804612_8808865_3": {"length": 16, "quality": 0.8, "section_id": 3913}}, "n3337": {"so_8804612_8808865_2": {"length": 20, "quality": 0.7142857142857143, "section_id": 369}, "so_8804612_8808865_6": {"length": 21, "quality": 0.84, "section_id": 3188}, "so_8804612_8808865_0": {"length": 62, "quality": 0.8732394366197183, "section_id": 3096}, "so_8804612_8808865_1": {"length": 33, "quality": 0.825, "section_id": 6974}, "so_8804612_8808865_4": {"length": 57, "quality": 0.8769230769230769, "section_id": 3773}, "so_8804612_8808865_3": {"length": 16, "quality": 0.8, "section_id": 3773}}, "n4659": {"so_8804612_8808865_6": {"length": 15, "quality": 0.6, "section_id": 4084}, "so_8804612_8808865_0": {"length": 61, "quality": 0.8591549295774648, "section_id": 3979}}}});