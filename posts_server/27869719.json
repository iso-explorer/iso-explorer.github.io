post_cb({"bq_ids": {"n4140": {"so_27869719_27869778_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_27869719_27869778_4": {"length": 6, "quality": 0.6666666666666666, "section_id": 3321}, "so_27869719_27869778_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_27869719_27869778_2": {"length": 20, "quality": 1.0, "section_id": 3321}, "so_27869719_27869778_1": {"length": 5, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_27869719_27869778_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_27869719_27869778_4": {"length": 6, "quality": 0.6666666666666666, "section_id": 3191}, "so_27869719_27869778_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_27869719_27869778_2": {"length": 20, "quality": 1.0, "section_id": 3191}, "so_27869719_27869778_1": {"length": 5, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_27869719_27869778_3": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_27869719_27869778_4": {"length": 6, "quality": 0.6666666666666666, "section_id": 4087}, "so_27869719_27869778_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_27869719_27869778_2": {"length": 20, "quality": 1.0, "section_id": 4087}, "so_27869719_27869778_1": {"length": 5, "quality": 1.0, "section_id": 4087}}}, "27869801": {"Id": "27869801", "PostTypeId": "2", "Body": "<p>First, a string is a <code>const char *</code> or <code>const char [N]</code> not a <code>std::string</code>. So you're not directly assigning those <code>char *</code> strings. <code>std::string</code> has a constructor that takes a <code>const char [N]</code> and the compiler automatically uses it to construct a new instance.</p>\n<p>But when using <code>const</code> for s2 you've just made it impossible for the compiler to assign the new <code>std::string</code> instance to s2.</p>\n<p>So in the end I think you've misunderstood the difference between a \"string\" of type <code>const char [N]</code> and a \"string\" of type <code>std::string</code>. The standard is referring to <code>const char [N]</code> when it is talking about strings being an lvalue but you're attempting to apply that to a <code>std::string</code> to which the standard's rule doesn't apply.</p>\n", "LastEditorUserId": "1411115", "LastActivityDate": "2015-01-09T22:09:27.387", "Score": "1", "CreationDate": "2015-01-09T21:48:34.007", "ParentId": "27869719", "CommentCount": "2", "LastEditDate": "2015-01-09T22:09:27.387", "OwnerUserId": "1411115"}, "27869719": {"ViewCount": "1601", "Body": "<p>I know there are topics that are similar to this one already (such as <a href=\"https://stackoverflow.com/questions/6967927/non-const-reference-may-only-be-bound-to-an-lvalue/6967989\">this</a>).</p>\n<p>The example given in this topic was this:</p>\n<pre><code>std::string &amp; rs1 = std::string();\n</code></pre>\n<p>Clearly, that std::string() is an rvalue.  However, my question is why is s1 legal while s2 is not?</p>\n<pre><code>const std::string&amp; s1 = \"String literal\";\nstd::string&amp; s2 = \"String literal\";\n</code></pre>\n<p>The standard clearly states that string literals are lvalues (which is understandable since they are technically const char* behind the scenes).  When I compile s2 though, I get the following:</p>\n<pre><code>prog.cpp:4:19: error: invalid initialization of non-const reference of type\n'std::string&amp; {aka std::basic_string&lt;char&gt;&amp;}' from an rvalue of type\n'const char*' std::string&amp; s2 = \"String literal\";\n</code></pre>\n<p>I understand that the standard definition of lvalues and rvalues are mutually exclusive, so is this potentially an error with the compiler?  I'm using gcc 4.9.2 in this example.  Would this also be one of the cases where the literal is really an xvalue?</p>\n", "AcceptedAnswerId": "27869778", "Title": "Since a string literal is considered an lvalue, why must the binding lvalue reference be const?", "CreationDate": "2015-01-09T21:41:48.903", "Id": "27869719", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:48:29.943", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-18T11:29:05.500", "Score": "12", "OwnerUserId": "2964168", "Tags": "<c++><reference><language-lawyer><string-literals><lvalue>", "AnswerCount": "3"}, "27869778": {"Id": "27869778", "PostTypeId": "2", "Body": "<p>The problem is that a string literal is not of type <code>std::string</code> or subclass thereof - it is of type <br><code>char const[N]</code>. \nThus the type of the initializer is not reference compatible with the target type of the reference, and <strong>a temporary must be created and bound to the reference.</strong></br></p>\n<p>However, temporaries cannot be bound to non-const lvalue references. I.e. your case is equivalent to</p>\n<pre><code>std::string&amp; s = std::string(\"Abcdefg\");\n</code></pre>\n<p>which is, even according to you, clearly ill-formed.  </p>\n<hr>\n<p>Actually the precise reason it doesn't work is not because temporaries cannot be bound to non-const lvalue references, but rather that the initializer of a non-const lvalue reference is subject to certain requirements that <code>char const[N]</code> cannot meet in this case, [dcl.init.ref]/5:</p>\n<blockquote>\n<p id=\"so_27869719_27869778_0\">A reference to type \u201c<em>cv1</em> <code>T1</code>\u201d is initialized by an expression of\n  type \u201c<em>cv2</em> <code>T2</code>\u201d as follows:  <br/></p>\n<ul>\n<li><p id=\"so_27869719_27869778_1\">If the reference is an lvalue reference and the initializer expression</p>\n<ul>\n<li>is an lvalue (but is not a bit-field), and \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>\u201d or</li>\n<li>has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be implicitly converted to an lvalue\n  of type \u201ccv3 T3,\u201d where \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with\n  \u201c<em>cv3</em> <code>T3</code>\u201d<sup>106</sup>(this conversion is selected by enumerating the applicable\n  conversion functions (13.3.1.6) and choosing the best one through\n  overload resolution (13.3)),<br/></li>\n</ul>\n<p id=\"so_27869719_27869778_2\">then the reference is bound to the initializer expression lvalue in\n  the first case and to the lvalue result of the conversion in the\n  second case (or, in either case, to the appropriate base class\n  subobject of the object). </p></li>\n<li><p id=\"so_27869719_27869778_3\"><strong>Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., <em>cv1</em> shall be const), or the reference\n  shall be an rvalue reference.</strong></p>\n<ul>\n<li>[..]</li>\n</ul></li>\n</ul>\n<hr>\n<p id=\"so_27869719_27869778_4\"><sup>106) This requires a conversion function (12.3.2) returning a reference type.</sup></p>\n</hr></blockquote>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-04-13T11:53:23.400", "Score": "19", "CreationDate": "2015-01-09T21:47:04.933", "ParentId": "27869719", "CommentCount": "0", "LastEditDate": "2015-04-13T11:53:23.400", "OwnerUserId": "3647361"}, "27869764": {"Id": "27869764", "PostTypeId": "2", "Body": "<p>The string literal may be an lvalue, but it's not a <code>string</code> object. There's a temporary <code>string</code> being created which is an rvalue.</p>\n", "LastActivityDate": "2015-01-09T21:46:07.457", "Score": "10", "CreationDate": "2015-01-09T21:46:07.457", "ParentId": "27869719", "CommentCount": "1", "OwnerUserId": "5987"}});