post_cb({"bq_ids": {"n4140": {"so_33504651_33511131_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 233}, "so_33504651_33511131_0": {"length": 19, "quality": 1.0, "section_id": 234}, "so_33504651_33511131_2": {"length": 16, "quality": 1.0, "section_id": 257}}, "n3337": {"so_33504651_33511131_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 226}, "so_33504651_33511131_0": {"length": 19, "quality": 1.0, "section_id": 227}, "so_33504651_33511131_2": {"length": 16, "quality": 1.0, "section_id": 248}}, "n4659": {"so_33504651_33511131_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 243}, "so_33504651_33511131_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 244}, "so_33504651_33511131_2": {"length": 16, "quality": 1.0, "section_id": 264}}}, "33511131": {"Id": "33511131", "PostTypeId": "2", "Body": "<p>First, a couple of solutions. For both of them, the essential part is taking the address of <code>registrar</code> from code that is guaranteed to be instantiated. This ensures that the definition of the static member is also instantiated, triggering the side effect.</p>\n<p>The first one relies on the fact that the definition of the default constructor for each specialization of <code>Foo</code> is instantiated to handle the default initialization of <code>a</code>, <code>b</code> and <code>c</code> in <code>main</code>:</p>\n<pre><code>template&lt;typename T&gt; class Foo\n{\npublic:\n   Foo() { (void)&amp;RegistrarWrapper&lt;Foo&lt;T&gt;&gt;::registrar; }\n};\n</code></pre>\n<p>A disadvantage is that this introduces a non-trivial constructor. An alternative that avoids this issue is the following:</p>\n<pre><code>template&lt;class T&gt; constexpr std::size_t register_class() \n{ \n   (void)&amp;RegistrarWrapper&lt;T&gt;::registrar; \n   return 1; \n}\n\ntemplate&lt;typename T&gt; class Foo\n{\n   static char reg[register_class&lt;Foo&lt;T&gt;&gt;()];\n};\n</code></pre>\n<p>The key here is to trigger the instantiation in the declaration of the static member, without relying on any initializer (see below).</p>\n<p>Both solutions work fine in Clang 3.7.0, GCC 5.2.0 and Visual C++ 2015, both with and without optimizations enabled. The second one uses the extended rules for <code>constexpr</code> functions, which are a C++14 feature. Of course, there are several easy ways to make it C++11 - compliant, if needed.</p>\n<hr>\n<p>I think the problem with your solution is that there's no guarantee that the initializer for <code>__reg_ptr</code> gets instantiated if its value is not used somewhere. Some Standard quotes from N4527: </p>\n<p>14.7.1p2:</p>\n<blockquote>\n<p id=\"so_33504651_33511131_0\">[...] the initialization (and any associated side-effects) of a static data\n  member does not occur unless the static data member is itself used in\n  a way that requires the definition of the static data member to exist.</p>\n</blockquote>\n<p>This doesn't quite address the <code>constexpr</code> case, since (I think) it's talking about the out-of-class definition of a static data member that is odr-used (it's more relevant to <code>registrar</code>), but it's close.</p>\n<p>14.7.1p1:</p>\n<blockquote>\n<p id=\"so_33504651_33511131_1\">[...] The implicit instantiation of a class template specialization\n  causes the implicit instantiation of the declarations, but not of the\n  definitions, default arguments, or exception-specifications of the\n  class member functions, member classes, scoped member enumerations,\n  static data members and member templates [...]</p>\n</blockquote>\n<p>This guarantees that the second solution works. Note that it doesn't guarantee anything about an in-class initializer for a static data member.</p>\n<p>There seems to be some uncertainty regarding instantiation of <code>constexpr</code> constructs. There's <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1581\" rel=\"nofollow\">CWG 1581</a>, which is not that relevant to our case, except that, at the very end, it talks about the fact that it's not clear whether <code>constexpr</code> instantiation happens during constant expression evaluation or during parsing. Some clarifications in this area may provide some guarantees for your solution as well (either way...) but we'll have to wait.</p>\n<hr>\n<p>A third variant: a way to make your solution work is to explicitly instantiate the specializations of <code>Foo</code>, instead of relying on implicit instantiation:</p>\n<pre><code>template class Foo&lt;int&gt;;\ntemplate class Foo&lt;bool&gt;;\ntemplate class Foo&lt;std::string&gt;;\n\nint main()\n{\n   for(auto&amp;&amp; data : test_vector()) {\n      std::cout &lt;&lt; data.name() &lt;&lt; std::endl;\n   }\n}\n</code></pre>\n<p>This also works in all three compilers, and relies on 14.7.2p8:</p>\n<blockquote>\n<p id=\"so_33504651_33511131_2\">An explicit instantiation that names a class template specialization\n  is also an explicit instantiation of the same kind (declaration or\n  definition) of each of its members [...]</p>\n</blockquote>\n<p>Given that those are explicit instantiation definitions, this seems to be enough to convince GCC to instantiate the initializer for <code>__reg_ptr</code>. However, those explicit instantiation definitions can only appear once in the whole program ([14.7p5.1]), so extra care is needed. I consider the first two solutions to be more reliable.</p>\n</hr></hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2015-11-03T23:59:08.583", "Score": "1", "CreationDate": "2015-11-03T23:33:12.860", "ParentId": "33504651", "CommentCount": "0", "LastEditDate": "2015-11-03T23:59:08.583", "OwnerUserId": "4326278"}, "33504651": {"ViewCount": "168", "Body": "<p>Consider the following program (sorry about the length; this is this shortest way I could think of to express the problem):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;typeindex&gt;\n\nusing namespace std;\n\nstd::vector&lt;std::type_index&gt;&amp;\ntest_vector()\n{\n  static std::vector&lt;std::type_index&gt; rv;\n  return rv;\n}\n\ntemplate &lt;typename T&gt;\nclass RegistrarWrapper;\n\ntemplate&lt;typename T&gt;\nclass Registrar\n{\n  Registrar()\n  {\n    auto&amp; test_vect = test_vector();\n    test_vect.push_back(std::type_index(typeid(T)));\n  }\n  friend class RegistrarWrapper&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nclass RegistrarWrapper\n{\n  public:\n    static Registrar&lt;T&gt; registrar;\n    typedef Registrar&lt;T&gt; registrar_t;\n};\n\ntemplate &lt;typename T&gt;\nRegistrar&lt;T&gt; RegistrarWrapper&lt;T&gt;::registrar;\n\n\ntemplate &lt;typename T&gt;\nclass Foo\n{\n  public:\n    // Refer to the static registrar somewhere to make the compiler\n    // generate it ?!?!?!?\n    static constexpr typename RegistrarWrapper&lt;Foo&lt;T&gt;&gt;::registrar_t&amp; __reg_ptr =\n      RegistrarWrapper&lt;Foo&lt;T&gt;&gt;::registrar;\n};\n\n\nint main(int argc, char** argv)\n{\n  Foo&lt;int&gt; a;\n  Foo&lt;bool&gt; b;\n  Foo&lt;std::string&gt; c;\n\n  for(auto&amp;&amp; data : test_vector()) {\n    std::cout &lt;&lt; data.name() &lt;&lt; std::endl;\n  }\n\n}\n</code></pre>\n<p>When compiled with <code>clang++</code> (version 3.5.2, of course with <code>-std=c++11</code>), this program outputs (piped through <code>c++filt</code> for readability):</p>\n<pre><code>Foo&lt;int&gt;\nFoo&lt;bool&gt;\nFoo&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt;\n</code></pre>\n<p>But with <code>g++</code> (tried versions 4.8.5, 4.9.3, and 5.2.0), it outputs nothing!  What's going on here?  Which compiler is conforming to the c++ standard?  How can I create this effect in a compiler-agnostic way (preferably without any run-time overhead)?</p>\n", "AcceptedAnswerId": "33511131", "Title": "clang and gcc different behavior when handling template generation and static constexpr members?", "CreationDate": "2015-11-03T16:46:38.427", "Id": "33504651", "CommentCount": "14", "PostTypeId": "1", "LastActivityDate": "2015-11-03T23:59:08.583", "Score": "4", "OwnerUserId": "152060", "Tags": "<c++><templates><gcc><clang><static-initialization>", "AnswerCount": "1"}});