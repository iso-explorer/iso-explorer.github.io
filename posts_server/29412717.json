post_cb({"29413213": {"ParentId": "29412717", "CommentCount": "1", "Body": "<p>Well, yes, a literal value of type <code>long double</code> needs to have an <code>L</code> postfix.  So use <code>2.0L</code> rather than <code>2.0</code> (of type <code>double</code>) or <code>2.0f</code> (of type <code>float</code>).</p>\n<p>However, from the error message, your claim that all variables are <code>long double</code> is false.</p>\n<p>At least one of the variables is of type <code>std::complex&lt;long double&gt;</code> and the error message indicates that an operation involving one or more of your variables does not exist.</p>\n<p>That means you're not understanding what the code does.  Which means there will be more to getting it working correctly than changing all things of type <code>double</code> to <code>long double</code>, and fixing type of literal values.</p>\n<p>It is not possible to provide more specific advice, as you have not provided enough information.  In particular, you would need to supply a small and complete sample of code that illustrates your problem(s).</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "29413213", "Score": "2", "CreationDate": "2015-04-02T12:38:45.927", "LastActivityDate": "2015-04-02T12:38:45.927"}, "29412717": {"CommentCount": "5", "ViewCount": "163", "PostTypeId": "1", "LastEditorUserId": "616233", "CreationDate": "2015-04-02T12:14:07.523", "LastActivityDate": "2015-04-02T12:59:23.067", "Title": "changing from double to long double in c++ no more gives correct results", "LastEditDate": "2015-04-02T12:59:23.067", "Id": "29412717", "Score": "0", "Body": "<p>In order to increase the accuracy, I have been trying to upgrade a program from double to long double. However, I got the following error.</p>\n<blockquote>\n<p id=\"so_29412717_29412717_0\">haread.cpp:178:43: error: no match for \u2018operator*\u2019 in \u20182.0e+0 *\n  std::operator+ [with _Tp = long double]((<em>(((const std::complex</em>)KEp) + ((long unsigned int)(((long unsigned int)i) *\n  32ul)))), (<em>(const std::complex</em>)(&amp; energia)</p>\n</blockquote>\n<p>The line was</p>\n<blockquote>\n<p id=\"so_29412717_29412717_1\">phicheb[1][i] = (2.0*(KEp[i] + energia)/dE)-phistate[is][i] ;</p>\n</blockquote>\n<p>The arrays were dynamically defines using 'new'. All the variables are long double. The problem was obtained for all the cases when some number is multiplying the complex array. So, I changed 2.0 to 2.0L and all the similar cases. So, now the compilation is successful. However, my program does not work properly anymore. Do I need to suffix L all the long doubles that I have defined? I have defined them as follows:</p>\n<blockquote>\n<p id=\"so_29412717_29412717_2\">long double xmin = 1.6 ;\n  long double xmax = 7.0 ;</p>\n</blockquote>\n<p>I am not even sure from where to start. Any suggestions?\nThe compiler is gcc version 4.6.2 (SUSE Linux).\nEDIT:</p>\n<pre><code>for ( int is = 0 ; is &lt; nstates ; is++ ){\n        for ( int i = 0 ; i &lt; xgrid ; i++ ) phi[i] = phistate[is][i];\n        fft(&amp;phi[0], &amp;kphi[0], -1);\n        for ( int i = 0 ; i &lt; xgrid ; i++ ){\n                kphi[i] = akx2[i]*kphi[i]*ixgrid; //calculates the KE using Fourier transform\n        }\n        fft(&amp;kphi[0],&amp;KEp[0],1);\n        for ( int i = 0 ; i &lt; xgrid ; i++ ){\n                x = xmin + (i*dx) ;\n                energia = complex&lt;long double&gt;(0.0,0.0);\n                energia = hmatrix[is][is][i]*phistate[is][i] ; //Potential energy\n                phicheb[0][i] = phistate[is][i];\n                phicheb[1][i] = (2.0L*(KEp[i] + energia)/dE)-phistate[is][i] ;\n        }\n        for ( int j = 2 ; j &lt; ncheb ; j++ ){ //this is a recursion relation\n                for ( int i = 0 ; i &lt; xgrid ; i++ ) phi[i] = phicheb[j-1][i];\n                fft(&amp;phi[0], &amp;kphi[0], -1);\n                for ( int i = 0 ; i &lt; xgrid ; i++ ){\n                        kphi[i] = akx2[i]*kphi[i]*ixgrid;\n                }\n                fft(&amp;kphi[0],&amp;KEp[0],1) ;\n                for ( int i = 0 ; i &lt; xgrid ; i++ ){\n                        x = xmin + (i*dx) ;\n                        energia = complex&lt;long double&gt;(0.0,0.0);\n                        energia = hmatrix[is][is][i]*phi[i];\n                        phicheb[j][i] = (2.0L*((2.0L*(KEp[i] + energia)/dE) - phicheb[j-1][i])) - phicheb[j-2][i]; //recursion\n                }\n        }\n        for ( int i = 0 ; i &lt; xgrid ; i++){\n                for ( int j = 0 ; j &lt; ncheb ; j++ ){\n                        phistate_new[is][i] += chebc[j]*phicheb[j][i] ;\n                }\n        }\n}\n</code></pre>\n<p>This is the core of the code. It is used for the propagation of wavefuction on a grid. I will try to explain the code as less technical as possible. I have the values of phistate[0][i], which is the wavefunction corresponding to a ground state (the rest of the states are all zero). Then I calculate the energy of the system (the Kinetic Energy using Fourier transform and the Potential Energy is already given). Now, using a particular method (the Chebychev method), I propagate the wavefunction in time. This method is based on a recursion relation. In this recursion, the propagation is calculated using a polynomial expansion. Chebc are long double coefficients, the values of which are well defined. All the variables whose definition are not shown, are long double.</p>\n<p>When I use just double instead of long double, I have no problem getting results. When using long double, phistate_new, my result, has all it's values given by NaN. </p>\n", "Tags": "<c++><double><long-integer><precision><long-double>", "OwnerUserId": "616233", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29412717_29412717_2": {"section_id": 2290, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_29412717_29412717_2": {"section_id": 2277, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_29412717_29412717_2": {"section_id": 2563, "quality": 0.6666666666666666, "length": 4}}}});