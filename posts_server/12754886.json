post_cb({"12755043": {"ParentId": "12754886", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>libc++, clang's native library, supports <code>std::is_trivially_copyable&lt;T&gt;</code> and, indeed, pretends on your example that the type is trivially copyable although it is clearly not trivially copyable. I think, 12.8 [class.copy] paragraph 12 defines the deleted constructor as non-trivial:</p>\n<blockquote>\n<p id=\"so_12754886_12755043_0\">A copy/move constructor for class X is trivial if it is not user-provided ...</p>\n</blockquote>\n<p>The deleted declaration is clearly user-provided. When I say \"clearly\" here I mean that I can't immediately back it up by the standard that declaring a function as deleted counts as user-provided...</p>\n<p>Further investigation reveals that 8.4.2 [dcl.fct.def.default] paragraph 4 (thanks to Jesse Good for providing the reference) makes a deleted function non-user-provided:</p>\n<blockquote>\n<p id=\"so_12754886_12755043_1\">... A special member function is <em>user-provided</em> if it is user-declared and not explicitly defaulted or deleted on its first declaration. ...</p>\n</blockquote>\n<p>Thus, a class with a deleted copy constructor is indeed trivially copyable if there is no other reason to make non-trivially copyable (but none of those applies to the type <code>A</code> in the question. That's a bit weird: type type cannot be copied using its copy constructor but it <em>can</em> be copied using <code>std::memcpy()</code>! I'm not sure if this is really intentional.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2012-10-05T23:54:27.110", "Id": "12755043", "Score": "5", "CreationDate": "2012-10-05T22:52:16.080", "LastActivityDate": "2012-10-05T23:54:27.110"}, "12755118": {"ParentId": "12754886", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Neither is correct or incorrect, since both are using extensions.</p>\n<p><strong>Warning</strong>: This answer was based on words which were in C++11 draft N3242, but are not in the final Standard.  So it's not especially good.  Leaving it up for comparison and discussion.</p>\n<p>For what it seems you meant to ask: <code>std::is_trivially_copyable&lt;A&gt;::value</code> (and also <code>std::is_trivially_copy_constructible&lt;A&gt;::value</code>) must be <code>false</code>.</p>\n<p>12.8 paragraph 13:</p>\n<blockquote>\n<p id=\"so_12754886_12755118_0\">A copy/move constructor for class <code>X</code> is trivial if it is neither user-provided nor deleted and if....</p>\n</blockquote>\n<p>And just to be complete,</p>\n<p>9 paragraph 6:</p>\n<blockquote>\n<p id=\"so_12754886_12755118_1\">A <em>trivially copyable class</em> is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n</blockquote>\n<p>3.9 paragraph 9:</p>\n<blockquote>\n<p id=\"so_12754886_12755118_2\">Scalar types, trivially copyable class types (Clause 9), arrays of such types, and cv-qualified versions of these types (3.9.3) are collectively called <em>trivially copyable types</em>.</p>\n</blockquote>\n<p>20.9.4.3 Table 49:</p>\n<blockquote>\n<p id=\"so_12754886_12755118_3\">Template: <code>template &lt;class T&gt; struct is_trivially_copyable;</code></p>\n<p id=\"so_12754886_12755118_4\">Condition: <code>T</code> is a trivially copyable type (3.9)</p>\n</blockquote>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2012-10-05T23:31:16.110", "Id": "12755118", "Score": "1", "CreationDate": "2012-10-05T23:00:55.317", "LastActivityDate": "2012-10-05T23:31:16.110"}, "bq_ids": {"n4140": {"so_12754886_12755118_3": {"section_id": 4706, "quality": 0.8, "length": 4}, "so_12754886_12755118_2": {"section_id": 7207, "quality": 0.8421052631578947, "length": 16}, "so_12754886_12755043_1": {"section_id": 3274, "quality": 0.7272727272727273, "length": 8}, "so_12754886_12755118_1": {"section_id": 4706, "quality": 1.0, "length": 4}, "so_12754886_12755118_0": {"section_id": 461, "quality": 0.625, "length": 5}, "so_12754886_12755043_0": {"section_id": 461, "quality": 1.0, "length": 5}}, "n3337": {"so_12754886_12755118_3": {"section_id": 4515, "quality": 0.8, "length": 4}, "so_12754886_12755118_2": {"section_id": 6951, "quality": 0.8947368421052632, "length": 17}, "so_12754886_12755043_1": {"section_id": 3145, "quality": 0.9090909090909091, "length": 10}, "so_12754886_12755118_1": {"section_id": 4515, "quality": 1.0, "length": 4}, "so_12754886_12755118_0": {"section_id": 452, "quality": 0.625, "length": 5}, "so_12754886_12755043_0": {"section_id": 452, "quality": 1.0, "length": 5}}, "n4659": {"so_12754886_12755118_3": {"section_id": 6103, "quality": 0.8, "length": 4}, "so_12754886_12755118_2": {"section_id": 8716, "quality": 0.8947368421052632, "length": 17}, "so_12754886_12755043_1": {"section_id": 4032, "quality": 0.7272727272727273, "length": 8}, "so_12754886_12755118_1": {"section_id": 6103, "quality": 1.0, "length": 4}, "so_12754886_12755118_0": {"section_id": 484, "quality": 0.625, "length": 5}, "so_12754886_12755043_0": {"section_id": 484, "quality": 1.0, "length": 5}}}, "12754886": {"CommentCount": "7", "ViewCount": "1314", "PostTypeId": "1", "LastEditorUserId": "13767", "CreationDate": "2012-10-05T22:33:26.997", "LastActivityDate": "2013-02-08T10:42:49.517", "Title": "__has_trivial_copy behaves differently in clang and gcc. Who's right?", "FavoriteCount": "2", "LastEditDate": "2012-10-05T22:36:31.823", "Id": "12754886", "Score": "7", "Body": "<p><code>std::is_trivially_copyable</code> is still not supported in either of those two compilers (at least as far as gcc 4.6). But both provide <code>__has_trivial_copy</code> directives that do pretty good job.\nExcept when it comes to deleted copy constructors.</p>\n<pre><code>struct A { A(A const&amp;) =delete; };\n</code></pre>\n<p><code>__has_trivial_copy(A)</code> returns 1 in clang and 0 in gcc.</p>\n<p>I was digging in the standard and could not find a clause that says whether the class is still considered trivially copyable when the copy constructor is deleted.</p>\n<p>Who's right?</p>\n<p>My inclination is to believe that gcc is right, because <code>struct A</code> is not copyable at all, let alone trivially copyable. Also, there's a wide-spread consensus, that a deleted copy constructor can be seen as a privately declared, but not defined constructor, in which case gcc would still be right.</p>\n<p>On the other hand, the standard in section 9/6 describes trivial-copyability in terms of not having any non-trivial operations. I guess if you read the standard as written, clang may be right.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1724239", "AnswerCount": "2"}});