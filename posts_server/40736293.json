post_cb({"40736333": {"ParentId": "40736293", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Use <code>std::function</code> with the corresponding type:</p>\n<pre><code>std::vector&lt;std::function&lt;void(void)&gt;&gt; vec;\nvec.push_back([]()-&gt;void{});\n</code></pre>\n<p>In your case it would be <code>std::function&lt;void(std::string)&gt;</code>.</p>\n<p>The exact type of a lambda is meaningless per standard ([expr.prim.lambda]/3):</p>\n<blockquote>\n<p id=\"so_40736293_40736333_0\">The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type</p>\n</blockquote>\n", "OwnerUserId": "1490355", "LastEditorUserId": "1490355", "LastEditDate": "2016-11-22T07:47:59.230", "Id": "40736333", "Score": "10", "CreationDate": "2016-11-22T07:45:39.193", "LastActivityDate": "2016-11-22T07:47:59.230"}, "40736293": {"CommentCount": "4", "ViewCount": "1044", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-11-22T07:43:29.997", "LastActivityDate": "2016-11-22T09:43:07.807", "Title": "How to declare a vector of functions (lambdas)", "LastEditDate": "2017-05-23T12:30:20.237", "Id": "40736293", "Score": "4", "Body": "<p>I have seen how to declare a vector of functions (see <a href=\"https://stackoverflow.com/questions/15128444/c-calling-a-function-from-a-vector-of-function-pointers-inside-a-class-where-t\">calling a function from a vector</a>).</p>\n<p>But that answer users pointers. How can I create a vector of functions/lambdas using the new syntax in modern C++?</p>\n<p>the examples of functions using the new syntax typically use auto:</p>\n<pre><code>auto f = [] (std::string msg) -&gt; void { \n    std::cout &lt;&lt; msg &lt;&lt; std::endl;\n};\n</code></pre>\n<p>What is the actual type of f? so I can declare a vector of this type?</p>\n<p>thank you very much for any help</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "2325702", "AnswerCount": "3"}, "40736534": {"ParentId": "40736293", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_40736293_40736534_0\">What is the actual type of <code>f</code>? so I can declare a vector of this type?</p>\n</blockquote>\n<p>Type of <code>f</code> can only be deduced by using <code>auto</code>. You can declare a <code>vector</code> of this type using</p>\n<pre><code>std::vector&lt;decltype(f)&gt; v;\n</code></pre>\n<p>However, it is not very useful. Lambda functions that look strikingly similar have different types. To make matters worse, lambda functions that have identical body also have different types.</p>\n<pre><code>auto f = [] (std::string msg) -&gt; void { \n    std::cout &lt;&lt; msg &lt;&lt; std::endl;\n};\n\nauto g = [] (std::string msg) -&gt; void { \n    std::cout &lt;&lt; msg &lt;&lt; std::endl;\n};\n\nauto h = [] (std::string msg) -&gt; void { \n    std::cout &lt;&lt; msg &lt;&lt; '+' &lt;&lt; msg &lt;&lt; std::endl;\n};\n</code></pre>\n<p>Given the above functions, you can't use</p>\n<pre><code>std::vector&lt;decltype(f)&gt; v;\nv.push_back(f);  // OK\nv.push_back(g);  // Not OK\nv.push_back(h);  // Not OK\n</code></pre>\n<p>Your best option is to create a <code>std::vector</code> of <code>std::function</code>s. You can add the lambda functions to that <code>std::vector</code>. Given the above definitions of <code>f</code> and <code>g</code>, you can use:</p>\n<pre><code>std::vector&lt;std::function&lt;void(std::string)&gt;&gt; v;\nv.push_back(f);\nv.push_back(g);\nv.push_back(h);\n</code></pre>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2016-11-22T08:05:02.807", "Id": "40736534", "Score": "7", "CreationDate": "2016-11-22T07:57:57.803", "LastActivityDate": "2016-11-22T08:05:02.807"}, "bq_ids": {"n4140": {"so_40736293_40736333_0": {"section_id": 5962, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_40736293_40736333_0": {"section_id": 5731, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_40736293_40736333_0": {"section_id": 7451, "quality": 0.9166666666666666, "length": 11}}}, "40738074": {"ParentId": "40736293", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As mentioned each lambda you declare has unique context specific type even if it has seemingly identical signature. This is why vector of lambdas has only theoretical value - you would be able to push there at most one lambda... You have two choices - you could go along with proposed approach from other answers and store lambdas into a type-erasure <code>std::function</code> before putting them into vector or put your lambdas into a \"container\" that would collect the type of each element apart from the lambda object itself - <code>std::tuple</code>:</p>\n<pre><code>auto t = std::make_tuple([](){ std::cout&lt;&lt;\"First lambda\" &lt;&lt; std::endl; },\n                         [](){ std::cout&lt;&lt;\"Second lambda\"&lt;&lt; std::endl; },\n                         [](){ std::cout&lt;&lt;\"Third lambda\" &lt;&lt; std::endl; });\n</code></pre>\n<p>and get appropriate lambda at compile-time:</p>\n<pre><code>std::get&lt;0&gt;(t)(); // the value in get must be known at compile time! \n                  // otherwise compiler won't be able to establish type \n                  // of lambda and the whole point of using tuple is lost\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/uKdD1ROvlmy4VvFi\" rel=\"nofollow noreferrer\">[live demo]</a></p>\n", "OwnerUserId": "4324224", "LastEditorUserId": "4324224", "LastEditDate": "2016-11-22T09:43:07.807", "Id": "40738074", "Score": "0", "CreationDate": "2016-11-22T09:26:25.327", "LastActivityDate": "2016-11-22T09:43:07.807"}});