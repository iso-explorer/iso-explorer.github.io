post_cb({"14912800": {"CommentCount": "0", "ViewCount": "842", "PostTypeId": "1", "LastEditorUserId": "973730", "CreationDate": "2013-02-16T17:01:33.030", "LastActivityDate": "2014-10-10T04:44:15.007", "Title": "C++11 non-static member initializers and deleted copy constructor", "AcceptedAnswerId": "14913148", "LastEditDate": "2014-10-10T04:44:15.007", "Id": "14912800", "Score": "3", "Body": "<p>I'm trying to compile the following simple code with GCC 4.7.2 (MinGW). Here I'm using C++11 feature - non-static member initializers:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A\n{\n    int var;\n\n    A()\n    {\n        cout &lt;&lt; \"A()\\n\";\n    }\n\n    A(int i)\n    {\n        cout &lt;&lt; \"A(int i)\\n\";\n        var = i;\n    }\n\n    A(const A&amp;) = delete;\n};\n\nstruct B\n{\n    A a = 7;\n};\n\nint main()\n{\n    B b;\n    cout &lt;&lt; \"b.a.var = \" &lt;&lt; b.a.var;\n    return 0;\n}\n</code></pre>\n<p>This code doesn't compile because of deleted copy-constructor which isn't necessary here. Here are errors:</p>\n<pre><code>main.cpp:27:11: error: use of deleted function 'A::A(const A&amp;)'\nmain.cpp:13:5: error: declared here\nmain.cpp: In constructor 'constexpr B::B()':\nmain.cpp:25:8: error: use of deleted function 'A::A(const A&amp;)'\nmain.cpp:13:5: error: declared here\n</code></pre>\n<p>If I implement copy-constructor like this:</p>\n<pre><code>A(const A&amp; a)\n{\n    cout &lt;&lt; \"A(const A&amp;)\\n\";\n    var = a.var;\n}\n</code></pre>\n<p>Then code compiles fine and program gives me expected output:</p>\n<pre><code>A(int i)\nb.a.var = 7\n</code></pre>\n<p>So it means that copy constructor is not used, but why I can't delete it?</p>\n<p><strong>Edit:</strong> Thanks for your answers. Copy or move constructor is required by standard if I'm using <code>=</code>. To fix this problem I need to implement move constructor or use direct initialization syntax <code>A a{7}</code>. </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "973730", "AnswerCount": "5"}, "14912825": {"ParentId": "14912800", "CommentCount": "0", "Body": "<p>Copy initialization is allowed to elide the copy but the copy constructor is mandated to be accessible by the standard.</p>\n", "OwnerUserId": "85371", "PostTypeId": "2", "Id": "14912825", "Score": "3", "CreationDate": "2013-02-16T17:03:45.067", "LastActivityDate": "2013-02-16T17:03:45.067"}, "14912878": {"ParentId": "14912800", "CommentCount": "0", "Body": "<p>The initialiser for <code>a</code> gives you copy-initialization:</p>\n<pre><code>A a = 7;\n</code></pre>\n<p>For such a copy-initialization, where a user-defined conversion is required, the resulting initialisation is equivalent to:</p>\n<pre><code>A a(A(7));\n</code></pre>\n<p>That is, a temporary <code>A</code> is constructed and then passed to the copy constructor of your <code>a</code> object. This copying may be elided, but the copy constructor must be available nonetheless. In other words, the copying can only be elided if the copy would be possible in the first place. If you <code>delete</code> the copy constructor, the copying is impossible.</p>\n<p>You'll have a better time with your deleted copy constructor if you do the following:</p>\n<pre><code>A a{7};\n</code></pre>\n<p>This does direct-initialization and no copy constructor is required.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "14912878", "Score": "4", "CreationDate": "2013-02-16T17:09:30.093", "LastActivityDate": "2013-02-16T17:09:30.093"}, "14912861": {"ParentId": "14912800", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_14912800_14912861_0\">This code doesn't compiles because of deleted copy-constructor which isn't necessary here</p>\n</blockquote>\n<p>Sorry, but your copy constructor <em>is</em> necessary. Even though the copy can be optimised out, it must still be possible in the code. This mandated by the language.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "14912861", "Score": "1", "CreationDate": "2013-02-16T17:07:53.133", "LastActivityDate": "2013-02-16T17:07:53.133"}, "14913148": {"ParentId": "14912800", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Per Paragraph 12.2/14 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14912800_14913148_0\">The initialization that occurs in the form</p>\n<p id=\"so_14912800_14913148_1\">T x = a;</p>\n<p id=\"so_14912800_14913148_2\">as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) <strong>is called copy-initialization</strong>. [ <em>Note: Copy-initialization may invoke a move (12.8). \u2014end note</em> ]</p>\n</blockquote>\n<p>The reason why your copy-initialization doesn't compile is that during copy-initialization a <strong>temporary</strong> object needs to be created (at least logically), and the object being initialized shall be constructed from it.</p>\n<p>Now all the previous answers seem to focus just on copy-constructors, but the first problem here is the absence of a <strong>move-constructor</strong>. As long as you provide one, then it is true that the copy constructor is not necessary.</p>\n<p>Alas, deleting the copy constructor prevents the generation of an implicit move constructor. Adding one explicitly would fix the problem:</p>\n<pre><code>struct A\n{\n    int var;\n\n    A()\n    {\n        cout &lt;&lt; \"A()\\n\";\n    }\n\n    A(int i)\n    {\n        cout &lt;&lt; \"A(int i)\\n\";\n        var = i;\n    }\n\n    A(const A&amp;) = delete;\n\n    // THIS MAKES IT WORK\n    A(A&amp;&amp; a)\n    {\n        cout &lt;&lt; \"A(A&amp;&amp;)\\n`;\n        var = a.var;\n    }\n};\n</code></pre>\n<p>Notice that when both the move-constructor and the copy-constructor are present, <strong>the move-constructor is preferred</strong>, because the temporary created for copy-initializing your object is an rvalue.</p>\n<p>When a move-constructor is absent, the compiler can invoke the copy constructor to perform the initialization, because constant lvalue references can bind to rvalue references and copy is seen as an unoptimized move.</p>\n<p>However, even though the compiler is <em>allowed</em> to elide the call to the move or the copy constructor, the <strong>semantics of the operation must still be checked</strong>. Per Paragraph 12.8/32 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14912800_14913148_3\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ <strong>Note: This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided.</strong> \u2014end note ] [...]</p>\n</blockquote>\n<p>Therefore, an error is issued by the compiler if neither the move constructor nor the copy constructor are present.</p>\n<p>If you want, however, you can <strong>direct-initialize</strong> your object rather than copy-initializing it. Just use the direct-initialization syntax instead:</p>\n<pre><code>struct B\n{\n    A a{7};\n};\n</code></pre>\n<p>This will make the move-constructor and copy-constructor unnecessary, because no temporary is created when direct-initializing an object.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-02-16T18:57:07.770", "Id": "14913148", "Score": "2", "CreationDate": "2013-02-16T17:38:45.297", "LastActivityDate": "2013-02-16T18:57:07.770"}, "bq_ids": {"n4140": {"so_14912800_14913148_3": {"section_id": 481, "quality": 0.8311688311688312, "length": 64}, "so_14912800_14913148_2": {"section_id": 3294, "quality": 0.68, "length": 17}}, "n3337": {"so_14912800_14913148_3": {"section_id": 472, "quality": 0.948051948051948, "length": 73}, "so_14912800_14913148_2": {"section_id": 3164, "quality": 0.68, "length": 17}}, "n4659": {"so_14912800_14913148_3": {"section_id": 504, "quality": 0.7792207792207793, "length": 60}, "so_14912800_14913148_2": {"section_id": 4056, "quality": 0.68, "length": 17}}}, "14912820": {"ParentId": "14912800", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_14912800_14912820_0\">So it means that copy constructor is not used, but whyI can't delete it?</p>\n</blockquote>\n<p>In your case, copy constructor is <strong>used</strong> only for <em>semantic-check</em> as required by the Standard, it also needs to be <em>accessible</em>. Later on, the compiler optimizes the code, eliding the call to the copy-constructor, so it is not actually <em>invoked</em>.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-02-16T17:08:46.380", "Id": "14912820", "Score": "1", "CreationDate": "2013-02-16T17:03:31.463", "LastActivityDate": "2013-02-16T17:08:46.380"}});