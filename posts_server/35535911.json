post_cb({"bq_ids": {"n4140": {"so_35535911_35536737_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 955}}, "n3337": {"so_35535911_35536737_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 943}}}, "35537728": {"PostTypeId": "2", "Body": "<p>It means that there are no holes in a <code>std::vector</code>'s internal memory representation. It looks like this in memory:</p>\n<p><a href=\"https://i.stack.imgur.com/BrSVf.png\" rel=\"nofollow noreferrer\"><img alt=\"&lt;code&gt;std::vector&lt;/code&gt; in memory\" src=\"https://i.stack.imgur.com/BrSVf.png\"/></a></p>\n<p>Each square represents an address in memory, and every orange one an element occupied by the vector.</p>\n<p>Most other containers are not contiguous. For example, a <code>std::forward_list</code> looks like this in memory:</p>\n<p><a href=\"https://i.stack.imgur.com/oo5N6.png\" rel=\"nofollow noreferrer\"><img alt=\"&lt;code&gt;std::forward_list&lt;/code&gt; in memory\" src=\"https://i.stack.imgur.com/oo5N6.png\"/></a></p>\n<p>Here, again, the orange addresses contain the elements of the container. But they are scattered across memory. There are also grey elements; they represent the additional memory needed by the list so that each elements knows where the next element is found.<sup>[*]</sup></p>\n<p>As you can imagine, the clear and concise memory representation of <code>std::vector</code> gives you a lot of advantages. It explains why <code>std::vector</code> has some operations other containers lack, or why those operations run in constant time. For example, in order to get to the n-th element, you just perform one addition (base address + n). It also explains why you can safely take <code>&amp;v[0]</code> and perform pointer arithmetics on it.</p>\n<hr>\n<p><sup>[*] This is a bit of a simplification, because the example has <code>char</code> elements, but the pointers in the list occupy more memory than single <code>char</code>s on typical C++ implementations. A more realistic diagram would use 4 or 8 grey squares for every element, because that's the size of one pointer on typical modern machines.</sup></p>\n</hr>", "LastActivityDate": "2016-02-21T15:12:36.177", "LastEditorUserId": "3313064", "Id": "35537728", "CommentCount": "0", "CreationDate": "2016-02-21T15:04:40.503", "ParentId": "35535911", "Score": "2", "OwnerUserId": "3313064", "LastEditDate": "2016-02-21T15:12:36.177"}, "35535947": {"PostTypeId": "2", "Body": "<p>It means that you can always get to the address of the next element via pointer arithmetic.</p>\n", "LastActivityDate": "2016-02-21T12:13:43.923", "Id": "35535947", "CommentCount": "0", "CreationDate": "2016-02-21T12:13:43.923", "ParentId": "35535911", "Score": "2", "OwnerUserId": "366817"}, "35535945": {"PostTypeId": "2", "Body": "<p>The elements in a <code>std::vector</code> occupy a contiguous block of memory. A <code>std::vector</code> is an improved array.</p>\n<p>This is important because it means access to an arbitrary element is fast. Because the size and number of elements is known, you can look up any element quickly.</p>\n<p>The drawback is that any reorganization, such as inserting or deleting an element in the middle, is an expensive operation as it requires all others to be shuffled to maintain contiguity.</p>\n<p>Other data structures such as lists allow easier reorganization with other tradeoffs.</p>\n", "LastActivityDate": "2016-02-21T12:13:34.183", "Id": "35535945", "CommentCount": "3", "CreationDate": "2016-02-21T12:13:34.183", "ParentId": "35535911", "Score": "2", "OwnerUserId": "369072"}, "35535979": {"PostTypeId": "2", "Body": "<p><em>Contiguous</em> in this context means that sequentially numbered vector's elements are located next to each other in memory space. For example, if an element <code>i</code> is located at the address <code>a</code>, and has a size of <code>s</code>, then the element <code>i+1</code> would be located at the address <code>a+s</code>, the element <code>i+2</code> would be at <code>a+s+s</code>, and so on.</p>\n<p>This is important for two reasons:</p>\n<ul>\n<li><strong>Contiguous requirement makes random access possible</strong> - you can compute the location of any element based on vector's base address and element's index</li>\n<li><strong>You can predict locality of reference</strong> - processing vector elements sequentially is the same as processing array elements sequentially for the purposes of cache behavior analysis.</li>\n</ul>\n", "LastActivityDate": "2016-02-21T12:16:16.220", "Id": "35535979", "CommentCount": "0", "CreationDate": "2016-02-21T12:16:16.220", "ParentId": "35535911", "Score": "6", "OwnerUserId": "335858"}, "35535911": {"ViewCount": "210", "Body": "<p>I've read in a lot of places like <a href=\"https://stackoverflow.com/questions/19876069/why-is-stdvector-contiguous\">here</a> that <code>std::vector</code> is always contiguous, but I didn't find an explanation to the meaning of this or why is this important? </p>\n<p>Does this mean that they have a fixed place in memory or what?</p>\n", "AcceptedAnswerId": "35535979", "Title": "std::vector contiguous meaning", "CreationDate": "2016-02-21T12:10:31.837", "Id": "35535911", "CommentCount": "2", "LastEditDate": "2017-05-23T12:01:46.510", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-21T15:12:36.177", "Score": "1", "OwnerUserId": "3737376", "Tags": "<c++><vector><stl>", "AnswerCount": "5"}, "35536737": {"PostTypeId": "2", "Body": "<p>As none of the answers mentioned it: </p>\n<p>Thanks to this feature of <code>std::vector</code> you can do things like</p>\n<pre><code>std::ifstream file( \"file.txt\", std::ios::ate | std::ios::binary );\nstd::vector&lt;char&gt; vec;\nif (!file)\n{\n    file.seekg(0, std::ios_base::end);\n    auto fileSize = file.tellg();\n    vec.resize(fileSize);\n\n    file.seekg(0, std::ios_base::beg);\n\n    // here we leverage contiguous memory in std::vector\n    file.read(&amp;vec[0], fileSize);\n}\n</code></pre>\n<p>where you avoid reading/writing element by element.</p>\n<p>This can be used since C++03, as mentioned in the (C++03) standard (23.2.4.1)</p>\n<blockquote>\n<p id=\"so_35535911_35536737_0\">The elements of a <code>vector</code> are stored contiguously, meaning that if <code>v</code> is\n  a <code>vector</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the\n  identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code>.</p>\n</blockquote>\n", "LastActivityDate": "2016-02-21T13:29:42.697", "Id": "35536737", "CommentCount": "0", "CreationDate": "2016-02-21T13:29:42.697", "ParentId": "35535911", "Score": "1", "OwnerUserId": "675100"}});