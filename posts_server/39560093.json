post_cb({"39560093": {"CommentCount": "3", "ViewCount": "82", "CreationDate": "2016-09-18T16:37:23.977", "LastActivityDate": "2016-09-18T22:29:06.227", "Title": "Do I still need to call a destructor of a std::container if both the container and allocator are part of the same memory pool?", "PostTypeId": "1", "Id": "39560093", "Score": "2", "Body": "<p>(Using Thread Building Blocks memory pool in example)</p>\n<p>Lets say I have the following setup:</p>\n<pre><code>using MemoryPool = tbb::memory_pool&lt;std::allocator&lt;char&gt;&gt;;\nusing CustomAllocator = tbb::memory_pool_allocator&lt;Result*&gt;;\nusing CustomVector = std::vector&lt;Result*, CustomAllocator&gt;;\n\nMemoryPool shortTermPool;\nvoid* allocatedMemory = shortTermPool.malloc(sizeof(CustomVector);\nCustomVector* results = static_cast&lt;CustomVector*&gt;(allocatedMemory);\nnew(results) CustomVector(CustomAllocator(shortTemPool));\n</code></pre>\n<p>Later I call</p>\n<pre><code>shortTermPool.recycle(); \n</code></pre>\n<p>This line of code recycles all the memory in the memory pool, allowing me to reuse it. Now, since both the vector and it's allocator are using the memory pool, do I still need to call</p>\n<pre><code>results-&gt;~vector();\n</code></pre>\n<p>before recycling the memory pool? Is the destructor doing anything additional, or will recycling the entire pool be enough?</p>\n", "Tags": "<c++><c++11><memory-management><tbb>", "OwnerUserId": "1432882", "AnswerCount": "1"}, "39560247": {"ParentId": "39560093", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-09-18T16:52:30.273", "Score": "1", "LastEditorUserId": "3435400", "LastEditDate": "2016-09-18T22:29:06.227", "Id": "39560247", "OwnerUserId": "3435400", "Body": "<p>From the C++ standard:</p>\n<blockquote>\n<p id=\"so_39560093_39560247_0\"><strong>3.8 Object lifetime</strong> </p>\n<p id=\"so_39560093_39560247_1\"><sup>4</sup> A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly\n  calling the destructor for an object of a class type with a non-trivial destructor.\n  For an object of a class type with a non-trivial destructor, the\n  program is not required to call the destructor explicitly before the\n  storage which the object occupies is reused or released; however, if\n  there is no explicit call to the destructor or if a delete-expression\n  (5.3.5) is not used to release the storage, the destructor shall not\n  be implicitly called and any program that depends on the side effects\n  produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>It depends on whether the <code>std::vector</code> destructor is non-trivial and has side effects on which the program depends. Because it is a library class, it would be advisable to call the destructor to be safe. Else you would have to check the <code>std::vector</code> implementations now and in the future for all standard libraries you want your code to be compatible with.<br>\nIf the vector class was your own, you would be in control of the destructor implementation and you could omit calling it if it was either trivial, or had no side-effects on which the program depends, as described above.<br>\n<sup>(But personally I would also call it in this case.)</sup></br></br></p>\n", "LastActivityDate": "2016-09-18T22:29:06.227"}, "bq_ids": {"n4140": {"so_39560093_39560247_1": {"section_id": 7192, "quality": 0.9607843137254902, "length": 49}}, "n3337": {"so_39560093_39560247_1": {"section_id": 6936, "quality": 0.9607843137254902, "length": 49}}, "n4659": {"so_39560093_39560247_1": {"section_id": 8701, "quality": 0.9607843137254902, "length": 49}}}});