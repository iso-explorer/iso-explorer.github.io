post_cb({"15623829": {"ParentId": "15623472", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>While I can't provide an insight on the reason why <code>cbegin()</code> and <code>cend()</code> are not part of <code>std::initializer_list</code>'s interface <em>in addition to</em> <code>begin()</code> and <code>end()</code>, there are certainly good reasons why the last two member functions ought to be there.</p>\n<p>One reason is, for instance, that the range-based <code>for</code> loop is defined by the C++11 Standard precisely in terms of functions <code>begin()</code> and <code>end()</code> (Paragraph 6.5.4/1). Therefore, in order to make it possible to use it with initializer lists, <code>std::initializer_list</code> has to provide the <code>begin()</code> and <code>end()</code> member functions:</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    auto l = { 1, 2, 3, 4, 5 };\n    for (int x : l) // Works because std::initializer_list provides\n                    // the member functions begin() and end().\n    {\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    }\n}\n</code></pre>\n<p>Moreover, it makes sense to consider that member functions <code>cbegin()</code> and <code>cend()</code> were not present before C++11: therefore, having <code>begin()</code> and <code>end()</code> on the interface of <code>std::initializer_list</code>allows making old generic algorithms written in terms of <code>begin()</code> and <code>end()</code> work with initializer lists as well, without requiring them to be rewritten.</p>\n<p>You write:</p>\n<blockquote>\n<p id=\"so_15623472_15623829_0\">These names (by conventions, comparing to e.g. <code>std::vector</code>) could suggest that both <code>std::initializer_list</code> method could return <code>iterator</code>, when they always return <code>const_iterator</code>.</p>\n</blockquote>\n<p>Actually, this analogy is not very appropriate. <code>std::vector</code>'s function <code>begin()</code>, for instance, returns an <code>iterator</code> when invoked on a non-<code>const</code> instance of <code>std::vector</code> (i.e. a mutable one, whose elements can be modified, added, and removed), and a <code>const_iterator</code> when invoked on a <code>const</code> instance (i.e. an immutable one, whose content cannot be altered):</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;type_traits&gt;\n\nint main()\n{\n    // A non-const vector...\n    std::vector&lt;int&gt; v = { 1, 2, 3, 4, 5 };\n\n    auto i = v.begin();\n    static_assert(\n        std::is_same&lt;decltype(i), decltype(v)::iterator&gt;::value, \n        //                                     ^^^^^^^^\n        //                                     ...non-const iterator!\n        \"What?\");\n\n    // A const vector...\n    std::vector&lt;int&gt; const vc = { 1, 2, 3, 4, 5 };\n    auto ic = vc.begin();\n    static_assert(\n        std::is_same&lt;decltype(ic), decltype(vc)::const_iterator&gt;::value,\n        //                                       ^^^^^^^^^^^^^^\n        //                                       ...const iterator!\n        \"What?\");\n}\n</code></pre>\n<p>Initializer lists are immutable collections by definition. Per Paragraph 18.9/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15623472_15623829_1\">An object of type <code>initializer_list&lt;E&gt;</code> provides access to an array of objects of type <code>const E</code>. [...]</p>\n</blockquote>\n<p>Since initializer lists are collections of <code>const</code> elements, the <code>cbegin()</code> and <code>cend()</code> functions would actually do the exact same thing that <code>begin()</code> and <code>end()</code> do.</p>\n<p>In fact, <code>iterator</code> and <code>const_iterator</code> are both defined as pointers to constant elements of the initializer list's value type, so it's arguable whether it is the case that <code>begin()</code> and <code>end()</code> always return <code>const_iterator</code> (as you assume), or whether they always return <code>iterator</code>.</p>\n<p>This is how Paragraph 18.9/1 of the C++11 Standard defines the <code>initializer_list</code> class template:</p>\n<pre><code>namespace std {\n    template&lt;class E&gt; class initializer_list {\n    public:\n        typedef E value_type;\n        // ...\n        typedef const E* iterator;\n        typedef const E* const_iterator;\n        // ...\n        constexpr const E* begin() const noexcept; // first element\n        constexpr const E* end() const noexcept; // one past the last element\n    };\n\n    // ...\n}\n</code></pre>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-03-26T10:23:52.887", "Id": "15623829", "Score": "25", "CreationDate": "2013-03-25T20:10:59.410", "LastActivityDate": "2013-03-26T10:23:52.887"}, "bq_ids": {"n4140": {"so_15623472_15623829_1": {"section_id": 6955, "quality": 1.0, "length": 9}}, "n3337": {"so_15623472_15623829_1": {"section_id": 6702, "quality": 1.0, "length": 9}}, "n4659": {"so_15623472_15623829_1": {"section_id": 8452, "quality": 1.0, "length": 9}}}, "15623472": {"CommentCount": "4", "AcceptedAnswerId": "15623829", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2013-03-25T19:50:02.917", "LastActivityDate": "2013-03-26T10:23:52.887", "LastEditDate": "2013-03-25T20:16:11.527", "ViewCount": "521", "FavoriteCount": "2", "Title": "std::initializer_list without cbegin()/cend()", "Id": "15623472", "Score": "21", "Body": "<p>If elements in <code>std::initializer_list</code> are always const values, why we have template method like <code>begin()/end()</code> and not <code>cbegin()/cend()</code>? This names (by conventions, comparing to e.g. <code>std::vector</code>) could suggest that both <code>std::initializer_list</code> method could return <code>iterator</code>, when they always return <code>const_iterator</code>.</p>\n", "Tags": "<c++><c++11><iterator><initializer-list>", "OwnerUserId": "407981", "AnswerCount": "1"}});