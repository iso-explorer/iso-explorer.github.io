post_cb({"bq_ids": {"n4140": {"so_29595028_29595219_0": {"length": 25, "quality": 1.0, "section_id": 6992}}, "n3337": {"so_29595028_29595219_0": {"length": 25, "quality": 1.0, "section_id": 6738}}, "n4659": {"so_29595028_29595219_0": {"length": 25, "quality": 1.0, "section_id": 8490}}}, "29595028": {"ViewCount": "502", "Body": "<p>In the example below I have a abstract class with pure virtual method (aka FUN1) and a normal method (aka FUN2).</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n        virtual void fun(int i) = 0; // FUN1\n        void fun() { this-&gt;fun(123); } // FUN2\n};\n\nclass B : public A\n{\npublic:\n        virtual void fun(int i) { std::cerr &lt;&lt; i &lt;&lt; std::endl; }\n};\n\nint main(int,char**)\n{\n        B b;\n        b.fun();\n}\n</code></pre>\n<p>Why can't I call FUN2 on derived class? g++ gives an error: </p>\n<blockquote>\n<p id=\"so_29595028_29595028_0\">main.cpp:19:8: error: no matching function for call to \u2018B::fun()\u2019</p>\n</blockquote>\n<hr>\n<p>EDIT: note that <a href=\"https://stackoverflow.com/questions/15827632/overload-of-pure-virtual-function\">Overload of pure virtual function</a> question is different. I don't want to override methods.</p>\n</hr>", "AcceptedAnswerId": "29595219", "Title": "Can I overload pure virtual method in the base class?", "CreationDate": "2015-04-12T21:49:30.870", "Id": "29595028", "CommentCount": "1", "LastEditDate": "2017-05-23T12:16:03.350", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-18T06:46:16.480", "Score": "4", "OwnerUserId": "2449761", "Tags": "<c++><inheritance><interface>", "AnswerCount": "2"}, "29595108": {"Id": "29595108", "PostTypeId": "2", "Body": "<p>Try to add <code>using A::fun;</code> statement in B class :</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    virtual void fun(int i) = 0; // FUN1\n    void fun() { this-&gt;fun(123); } // FUN2\n};\n\nclass B : public A\n{\npublic:\n    using A::fun;\n    virtual void fun(int i) { std::cerr &lt;&lt; i &lt;&lt; std::endl; }\n};\n\nint main(int, char**)\n{\n    B b;\n    b.fun();\n    b.fun(5);\n}\n</code></pre>\n", "LastEditorUserId": "2815738", "LastActivityDate": "2016-05-18T06:46:16.480", "Score": "5", "CreationDate": "2015-04-12T21:56:37.063", "ParentId": "29595028", "CommentCount": "4", "OwnerUserId": "2815738", "LastEditDate": "2016-05-18T06:46:16.480"}, "29595219": {"Id": "29595219", "PostTypeId": "2", "Body": "<p>This is how derived class member lookup works: in the expression <code>b.fun()</code>, <code>fun</code> is first looked up in the scope of <code>class B</code>, and the lookup finds <code>B::fun(int)</code>. So it stops and never finds <code>A::fun()</code>.</p>\n<p>Relevant section of the standard is 10.2 [class.member.lookup]/4:</p>\n<blockquote>\n<p id=\"so_29595028_29595219_0\">If <code>C</code> contains a declaration of the name <code>f</code>, the declaration set contains every declaration of <code>f</code> declared in\n  <code>C</code> that satisfies the requirements of the language construct in which the lookup occurs. (...) If the resulting declaration set is not empty, the subobject set contains <code>C</code> itself, and calculation is complete.</p>\n</blockquote>\n<p>To make the base class function directly accessible you can use a <code>using</code> declaration in the derived class, i.e. <code>using A::fun;</code>.</p>\n<p>For methods that are implemented in the base class an alternative is sometimes to qualify to call, i.e. <code>b.A::fun()</code>.</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2015-04-12T22:26:59.183", "Score": "6", "CreationDate": "2015-04-12T22:09:56.490", "ParentId": "29595028", "CommentCount": "0", "OwnerUserId": "3959454", "LastEditDate": "2015-04-12T22:26:59.183"}});