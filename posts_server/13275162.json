post_cb({"13275303": {"Id": "13275303", "PostTypeId": "2", "Body": "<p>The syntax is wrong because there is not implicit conversion from <strong>char const *</strong> to <strong>char *</strong> .</p>\n<p>The type of a string literal has been <strong>char const *</strong> for ever in C and C++. (Might be wrong about very old C.)</p>\n<p>The change in the rules has nothing to do with the type of string literals but with allowed conversions between pointer types.</p>\n<p>The conversion is a mistake because of a pointer-to-const-thing is that thing is immutable. A string literal, which is a value known to be constant at compile and link time, might be put in read only memory segments.</p>\n", "LastActivityDate": "2012-11-07T17:49:54.773", "CommentCount": "2", "CreationDate": "2012-11-07T17:49:54.773", "ParentId": "13275162", "Score": "0", "OwnerUserId": "602037"}, "13275316": {"Id": "13275316", "PostTypeId": "2", "Body": "<p>The idea behind the deprecation is to help the compiler catch errors that would otherwise cause crashes at runtime.</p>\n<pre><code>char *hello = \"hello\";\nstrcpy(hello, \"world\"); // Compiles but crashes\n</code></pre>\n<p>as opposed to</p>\n<pre><code>const char *hello = \"hello\";\nstrcpy(hello, \"world\"); // Does not compile\n</code></pre>\n<p>This is a relatively cheap way of catching an entire class of very nasty runtime errors, so deprecation of the conversion is very much in line with the general philosophy of C++ as \"a better C\".</p>\n<p>In addition, your code segment 2 does not invalidate the fact that the content of the pointer is protected. It is the pointer itself that gets written over, not its content. There is a difference between <code>const char *ptr</code> and <code>char * const ptr</code>: the former protects the content; the later protects the pointer itself. The two can be combined to protect the pointer and its content as <code>const char * const ptr</code>.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2012-11-07T17:57:56.050", "Score": "2", "CreationDate": "2012-11-07T17:50:40.963", "ParentId": "13275162", "CommentCount": "1", "OwnerUserId": "335858", "LastEditDate": "2012-11-07T17:57:56.050"}, "13275224": {"Id": "13275224", "PostTypeId": "2", "Body": "<p><code>\"abc\"</code> is a static array that points to possibly immutable memory. <a href=\"https://stackoverflow.com/questions/10001202/is-modification-of-string-literals-undefined-behaviour-according-to-the-c89-stan\">In C</a>, modifying the content of a string literal is undefined behavior (UB).</p>\n<hr>\n<p>But C99 did not make <code>\"abc\"</code> an object of type <code>const char [n]</code>. In fact, this is quite the opposite, as to keep compatibility with C89 (and ANSI C), which specifies (\u00a73.1.4/3):</p>\n<blockquote>\n<p id=\"so_13275162_13275224_0\">A character string literal has static storage duration and type <em>array of char</em>, and is initialized with the given characters.</p>\n</blockquote>\n<p>That is, the declaration</p>\n<pre><code>char* c = \"12345\";\n</code></pre>\n<p>is <strong><em>not deprecated in C</em></strong>, even up to C11.</p>\n<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf</a>, we can see the rationale in C99 of making the string literal modification UB, while keeping the type to be <code>char [n]</code>:</p>\n<blockquote>\n<p id=\"so_13275162_13275224_1\">String literals are not required to be modifiable.  This specification allows implementations to share copies of strings with identical text, to place string literals in read-only memory, and to perform ertain optimizations.  However, string literals do not have the type <em>array of const char</em> in order to avoid the problems of pointer type checking, particularly with library functions, since assigning a <em>pointer to const char</em> to a plain  <em>pointer to char</em> is not valid. Those members of the C89 Committee who insisted that string literals should be modifiable were content to have this practice designated a common extension (see \u00a7J.5.5)</p>\n</blockquote>\n<p>where C99 \u00a7J.5.5 is:</p>\n<blockquote>\n<h2>J.5.5 Writable string literals</h2>\n<p id=\"so_13275162_13275224_2\">String literals are modifiable (in which case, identical string literals should denote distinct objects) (6.4.5).</p>\n</blockquote>\n<hr>\n<p>On the other hand, as your code is C++, this should actually be <strong><em>wrong</em></strong> in standard C++, because it requires (C++03 \u00a72.13.4/1)</p>\n<blockquote>\n<p id=\"so_13275162_13275224_3\">... An ordinary string literal has type \u201carray of <em>n</em> <code>const char</code>\u201d and static storage duration ...</p>\n</blockquote>\n<p>and assigning a <code>const char[n]</code> to a <code>char*</code> shouldn't compile. The compiler warns about \"deprecation\", because existing implementation at that time allowed the conversion (because C allows it), so it went into Annex D: Compatibility features:</p>\n<blockquote>\n<h2>D.4 Implicit conversion from const strings</h2>\n<p id=\"so_13275162_13275224_4\">The implicit conversion from const to non-const qualification for string literals (4.2) is deprecated.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-07T18:52:29.743", "Score": "2", "CreationDate": "2012-11-07T17:44:31.620", "ParentId": "13275162", "CommentCount": "1", "OwnerUserId": "224671", "LastEditDate": "2017-05-23T11:43:09.410"}, "13275162": {"ViewCount": "313", "Body": "<p>I understand that the syntax <strong>char * = \"stringLiteral\";</strong> has been deprecated and may not even work in the future. What I don't understand is <strong>WHY</strong>.  </p>\n<p>I searched the net and stack and although there are many echos confirming that char * = \"stringLiteral\"; is wrong and that <strong>const</strong> char * = \"stringLiteral\"; is corect, I have yet to find information about WHY said syntax is wrong. In other words, I'd like to know what the issue really is under the hood.</p>\n<h2><strong>ILLUSTATING MY CONFUSION</strong></h2>\n<p><strong>CODE SEGMENT 1 - EVIL WAY (Deprecated)</strong></p>\n<pre><code>char* szA = \"stringLiteralA\";     //Works fine as expected. Auto null terminated.\nstd::cout &lt;&lt; szA &lt;&lt; std::endl;    \nszA = \"stringLiteralB\";          //Works, so change by something same length OK.\nstd::cout &lt;&lt; szA &lt;&lt; std::endl;    \nszA = \"stringLiteralC_blahblah\"; //Works, so change by something longer OK also.\nstd::cout &lt;&lt; szA &lt;&lt; std::endl;    \n\nOuput:\nstringLiteralA\nstringLiteralB\nstringLiteralC_blahblah\n</code></pre>\n<p>So what exactly is the problem here?  Seems to work just fine.</p>\n<p><strong>CODE SEGMENT 2 (The \"OK\" way)</strong></p>\n<pre><code>const char* szA = \"stringLiteralA\";  //Works fine as expected. Auto null term.\nstd::cout &lt;&lt; szA &lt;&lt; std::endl;    \nszA = \"stringLiteralB\";          //Works, so change by something same length OK.\nstd::cout &lt;&lt; szA &lt;&lt; std::endl;    \nszA = \"stringLiteralC_blahblah\"; //Works, so change by something longer OK also.\nstd::cout &lt;&lt; szA &lt;&lt; std::endl;    \n\nOuput:\nstringLiteralA\nstringLiteralB\nstringLiteralC_blahblah\n</code></pre>\n<p>Also works fine. No difference. What is the point of adding const?</p>\n<p><strong>CODE SEGMENT 3</strong></p>\n<pre><code>const char* const szA = \"stringLiteralA\";  //Works. Auto null term.\nstd::cout &lt;&lt; szA &lt;&lt; std::endl;    \nszA = \"stringLiteralB\";           //Breaks here. Can't reasign.\n</code></pre>\n<p>I am only illustrating here that in order to read only protect the variable content you have to const char* <strong>const</strong> szA = \"something\"; .</p>\n<p>I don't see the point for deprecation or any issues. Why is this syntax deprecated and considered an issue?</p>\n", "AcceptedAnswerId": "13275297", "Title": "C & C++ String Literal Deprecation for char * = \"stringLiteral\";", "CreationDate": "2012-11-07T17:40:46.737", "Id": "13275162", "CommentCount": "1", "LastEditDate": "2012-11-07T19:24:03.950", "PostTypeId": "1", "LastEditorUserId": "1118167", "LastActivityDate": "2012-11-07T19:24:03.950", "Score": "0", "OwnerUserId": "1118167", "Tags": "<c++><c>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_13275162_13275224_3": {"length": 9, "quality": 0.9, "section_id": 5356}, "so_13275162_13275224_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 5358}}, "n3337": {"so_13275162_13275224_3": {"length": 9, "quality": 0.9, "section_id": 5153}, "so_13275162_13275224_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 5154}}, "n4659": {"so_13275162_13275224_3": {"length": 9, "quality": 0.9, "section_id": 6781}, "so_13275162_13275224_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6789}}}, "13275297": {"Id": "13275297", "PostTypeId": "2", "Body": "<p><code>const char *</code> is a pointer (<code>*</code>) to a constant (<code>const</code>) <code>char</code> (pointer definitions are easily read from right to left). The point here is to protect the content, since, as the standard says, modifying the content of such a pointer results in undefined behavior.</p>\n<p>This has its roots in the fact that typically (C/C++) compilers group the strings used throughout the program in a single memory zone, and are allowed to use the same memory locations for instances of the same string used in unrelated parts of the program (to minimize executable size/memory footprint). If it was allowed to modify string literals you could affect with one change other, unrelated instances of the same literal, which obviously isn't a great idea.</p>\n<p>In facts, with most modern compilers (on hardware that supports memory protection) the memory area of the string table is read-only, so if you attempt to modify a string literal your program crashes. Adding <code>const</code> to pointers that refer to string literals makes these mistakes immediately evident as compilation errors instead of crashes.</p>\n<p>By the way, notice that the fact that a string literal can decay implicitly to a non-const <code>char *</code> is just a concession to backwards compatibility with pre-standard libraries (written when <code>const</code> wasn't part of the C language yet), as said above the standard always said that changing string literals is UB.</p>\n", "LastEditorUserId": "214671", "LastActivityDate": "2012-11-07T17:54:32.050", "Score": "6", "CreationDate": "2012-11-07T17:49:26.697", "ParentId": "13275162", "CommentCount": "4", "OwnerUserId": "214671", "LastEditDate": "2012-11-07T17:54:32.050"}});