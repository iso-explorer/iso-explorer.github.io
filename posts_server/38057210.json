post_cb({"bq_ids": {"n4140": {"so_38057210_38057736_0": {"length": 9, "quality": 0.6, "section_id": 3228}}, "n3337": {"so_38057210_38057736_0": {"length": 9, "quality": 0.6, "section_id": 3101}}, "n4659": {"so_38057210_38057736_0": {"length": 9, "quality": 0.6, "section_id": 3985}}}, "38057736": {"Id": "38057736", "PostTypeId": "2", "Body": "<p>From the C language standard ISO/IEC 9899 <em>\u00a76.2.5 Types/p20</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_38057210_38057736_0\"><strong>An array type describes a contiguously allocated nonempty set of\n  objects</strong> with a particular member object type, called the element type.</p>\n</blockquote>\n<p>Also from the C language standard ISO/IEC 9899 <em>\u00a76.5.2.1/p3 Array subscripting</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_38057210_38057736_1\">Successive subscript operators designate an element of a\n  multidimensional array object. If <code>E</code> is an n-dimensional array (n &gt;=\n  2) with dimensions <code>i x j x . . . x k</code>, then <code>E</code> (used as other than\n  an lvalue) is converted to a pointer to an <code>(n - 1)</code>-dimensional array\n  with dimensions <code>j x . . . x k</code>. If the unary <code>*</code> operator is applied\n  to this pointer explicitly, or implicitly as a result of subscripting,\n  the result is the pointed-to <code>(n - 1)</code>-dimensional array, which itself\n  is converted into a pointer if used as other than an lvalue. <strong>It\n  follows from this that arrays are stored in row-major order (last\n  subscript varies fastest).</strong></p>\n</blockquote>\n<p>From the above we can conclude that a 2D array is actually a 1D array stored in row-major order.</p>\n<p><strong>Consequently, it's safe to assume that elements of a sub-array are stored contiguously in memory</strong>.</p>\n", "LastActivityDate": "2016-06-27T15:23:31.363", "CommentCount": "0", "CreationDate": "2016-06-27T15:23:31.363", "ParentId": "38057210", "Score": "3", "OwnerUserId": "2352671"}, "38057350": {"Id": "38057350", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38057210_38057350_0\">Are Sub-Arrays Guaranteed to be Allocated Linearly?</p>\n</blockquote>\n<p>Yes. Whether the elements of the array are sub-arrays or non-array objects, they are guaranteed to be stored contiguously in memory.</p>\n<p>For completeness, here is the standard quote:</p>\n<blockquote>\n<p id=\"so_38057210_38057350_1\">[dcl.array]</p>\n<ol>\n<li>[snip] An object of array type contains a <strong>contiguously allocated</strong> non-empty set of N subobjects of type T. [snip]</li>\n</ol>\n</blockquote>\n<p>There is no exception for the case when <code>T</code> is an array.</p>\n<hr>\n<blockquote>\n<p id=\"so_38057210_38057350_2\">So we know this isn't guaranteed to be the case for <code>const char[4]</code>.</p>\n</blockquote>\n<p>On the contrary, we do know that this <strong>is</strong> guaranteed for <code>char[4]</code> objects just like it is guaranteed for other types.</p>\n<blockquote>\n<p id=\"so_38057210_38057350_3\">For example: const char first[] = \"foo\"; char foo[][4] = {\"bar\", \"foo\", \"\", \"baz\"}</p>\n</blockquote>\n<p><code>first</code> would be stored like this in memory:</p>\n<pre><code>{'f', 'o', 'o', '\\0'}\n</code></pre>\n<p><code>foo</code> would be stored like this:</p>\n<pre><code>{'b', 'a', 'r', '\\0', 'f', 'o', 'o', '\\0', '\\0', '\\0', '\\0', '\\0', 'b', 'a', 'z', '\\0'}\n</code></pre>\n<blockquote>\n<p id=\"so_38057210_38057350_4\">So why would you say this is guaranteed for ints?</p>\n</blockquote>\n<p>It is guaranteed for <code>int[4]</code>, <code>char[4]</code> and any other type that you can imagine.</p>\n</hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2016-06-27T15:34:07.877", "Score": "5", "CreationDate": "2016-06-27T15:04:14.727", "ParentId": "38057210", "CommentCount": "9", "OwnerUserId": "2079303", "LastEditDate": "2016-06-27T15:34:07.877"}, "38057210": {"ViewCount": "104", "Body": "<p>I know <a href=\"https://stackoverflow.com/a/38029323/2642059\">this answer</a> is in violation of the <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing\" rel=\"nofollow noreferrer\"><code>reinterpret_cast</code> rules</a> but it also presumes that sub-arrays will be allocated linearly.</p>\n<p>I believed this was not guaranteed, but as I search the standard, I find my confidence wavering. If I statically allocate a 2D array, like this:</p>\n<pre><code>int foo[][4] = { { 5, 7, 8 },\n                 { 6, 6 },\n                 {},\n                 { 5, 6, 8, 9 } };\n</code></pre>\n<p>Am I allowed to assume that all elements will be allocated linearly? That is to say that if <code>foo[0]</code> is at address 0x00000042, will:</p>\n<ul>\n<li><code>foo[1]</code> be at address 0x00000052</li>\n<li><code>foo[2]</code> be at address 0x00000062</li>\n<li><code>foo[3]</code> be at address 0x00000072</li>\n</ul>\n<p><sub>These addresses are in hex, and yes they are providing space for the 4-element sub-array with <code>sizeof(int) == 4</code>; they may and may not be zero-initialized.</sub></p>\n", "AcceptedAnswerId": "38057350", "Title": "Are Sub-Arrays Guaranteed to be Allocated Linearly?", "CreationDate": "2016-06-27T14:57:31.360", "LastActivityDate": "2016-06-27T15:34:07.877", "CommentCount": "4", "LastEditDate": "2017-05-23T11:44:16.277", "PostTypeId": "1", "Tags": "<c++><arrays><linear><memory-layout><static-allocation>", "Id": "38057210", "AnswerCount": "2", "Score": "2", "OwnerUserId": "2642059", "ClosedDate": "2016-06-27T15:27:54.127", "LastEditorUserId": "-1"}});