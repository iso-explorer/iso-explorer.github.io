post_cb({"4705990": {"ParentId": "4705968", "CommentCount": "7", "Body": "<p>Yes, they are. <code>'\\0'</code> has the same value of <code>NULL</code> which is 0 (but they mean different things), while EOF is usually -1.</p>\n<pre><code>printf(\"%d\",a==EOF); //printed 1\n</code></pre>\n<p>In this case you are asking: is a == EOF? if it is print 1 (which is true), it it's not print 0 (which is false).</p>\n", "OwnerUserId": "521776", "PostTypeId": "2", "Id": "4705990", "Score": "0", "CreationDate": "2011-01-16T14:50:21.737", "LastActivityDate": "2011-01-16T14:50:21.737"}, "4706217": {"ParentId": "4705968", "LastEditDate": "2011-01-16T15:42:31.703", "CommentCount": "2", "CreationDate": "2011-01-16T15:36:13.410", "OwnerUserId": "214671", "LastEditorUserId": "214671", "PostTypeId": "2", "Id": "4706217", "Score": "23", "Body": "<p><code>NULL</code> and <code>'\\0'</code> are guaranteed to evaluate to 0, so (with appropriate casts) they can be considered identical in value; notice however that they represent two very different things: <code>NULL</code> is a null (always invalid) <em>pointer</em>, while <code>'\\0'</code> is the string terminator. <code>EOF</code> instead is a negative integer constant that indicates the end of a stream; often it's -1, but the standard doesn't say anything about its actual value.</p>\n<p>C &amp; C++ differ in the type of <code>NULL</code> and <code>'\\0'</code>:</p>\n<ul>\n<li>in C++ <code>'\\0'</code> is a <code>char</code>, while in C it's an <code>int</code>; this because in C all character literals are considered <code>int</code>s.</li>\n<li><p>in C++ <code>NULL</code> is \"just\" an integral 0, while in C it can be defined as a 0 casted to <code>void *</code>; this cannot be done in C++ (and it's explicitly forbidden in a note) because, being C++ more strict in pointer conversions, a <code>void *</code> is not implicitly convertible to any other pointer type, so, if <code>NULL</code> was a <code>void *</code>, it would be necessary to cast it to the target pointer type on assignment:</p>\n<pre><code>int * ptr = (void *) 0; /* valid C, invalid C++ */\n</code></pre></li>\n</ul>\n<p>Relevant standard quotations:</p>\n<h1>C++98/03</h1>\n<h2><code>NULL</code></h2>\n<p><code>NULL</code> is an integer type guaranteed to evaluate to 0:</p>\n<blockquote>\n<p id=\"so_4705968_4706217_0\"><em><strong>4.10 Pointer conversions</strong></em></p></blockquote>\n<p>A null pointer constant is an integral constant expression (5.19) rvalue of integer type that evaluates to zero. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type and is distinguishable from every other value of pointer to object or pointer to function type. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer\n  to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (4.4).</p>\n<p><em><strong>18.1 Types</strong></em></p>\n<p>[...] The macro NULL is an implementation-defined C++ null pointer constant in this international Standard (4.10). (<em>Possible definitions include <code>0</code> and <code>0L</code>, but not <code>(void*)0</code></em>).</p>\n<h2><code>'\\0'</code></h2>\n<p>A 0-value char must exist:</p>\n<blockquote>\n<p id=\"so_4705968_4706217_1\"><em><strong>2.2 Character sets</strong></em></p></blockquote>\n<p>The basic execution character set and the basic execution wide-character set shall each contain [...] a null character (respectively, null wide character), whose representation has all zero bits.</p>\n<p><code>'\\0'</code> is a <code>char</code> literal:</p>\n<blockquote>\n<p id=\"so_4705968_4706217_2\"><em><strong>2.13.2 Character literals</strong></em></p></blockquote>\n<p>A character literal is one or more characters enclosed in single quotes, as in <code>'x'</code>, optionally preceded by the letter L, as in L\u2019x\u2019. A character literal that does not begin with L is an ordinary character literal, also referred to as a narrow-character literal. An ordinary character literal that contains a single <em>c-char</em> has type <code>char</code>, with value equal to the numerical value of the encoding of the <em>c-char</em> in the execution character set.</p>\n<p>and it's value is 0, since that escape sequence specifies its value:</p>\n<blockquote>\n<p id=\"so_4705968_4706217_3\">The escape <code>\\ooo</code> consists of the backslash followed by one, two, or three octal digits that are taken to specify the value of the desired character.</p>\n</blockquote>\n<p><code>'\\0'</code> is used to terminate strings literals:</p>\n<blockquote>\n<p id=\"so_4705968_4706217_4\"><em><strong>2.13.4 String literals</strong></em></p></blockquote>\n<p>After any necessary concatenation, in translation phase 7 (2.1), <code>'\\0'</code> is appended to every string literal so that programs that scan a string can find its end.</p>\n<h2><code>EOF</code></h2>\n<p>The definition of <code>EOF</code> is delegated to the C89 standard (as stated in \u00a727.8.2 \"C Library files\"), where it is defined as an implementation specific negative integer.</p>\n<h1>C99</h1>\n<h2><code>NULL</code></h2>\n<p>A null pointer is a 0 integer, optionally casted to <code>void *</code>; <code>NULL</code> is a null pointer.</p>\n<blockquote>\n<p id=\"so_4705968_4706217_5\"><em><strong>6.3.2.3 Pointers</strong></em></p></blockquote>\n<p>[...] An integer constant expression with the value 0, or such an expression cast to type\n  <code>void *</code>, is called a null pointer constant. (The macro <code>NULL</code> is defined in <code>&lt;stddef.h&gt;</code> (and other headers) as a null pointer constant; see 7.17.) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.</p>\n<p><em><strong>7.17 Common definitions <code>&lt;stddef.h&gt;</code></strong></em></p>\n<p>[...] The macros are</p>\n<p><strong><code>NULL</code></strong></p>\n<p>which expands to an implementation-defined null pointer constant; [...]</p>\n<h2><code>'\\0'</code></h2>\n<p><code>'\\0'</code> is an integer with value 0, and is used to terminate strings:</p>\n<blockquote>\n<p id=\"so_4705968_4706217_6\"><em><strong>5.2.1 Character sets</strong></em></p></blockquote>\n<p>[...] A byte with all bits set to 0, called the <em>null character</em>, shall exist in the basic execution character set; it is used to terminate a character string.</p>\n<p><em><strong>6.4.4.4 Character constants</strong></em></p>\n<p>An integer character constant is a sequence of one or more multibyte characters enclosed\n  in single-quotes, as in <code>'x'</code>. [...]</p>\n<p>The octal digits that follow the backslash in an octal escape sequence are taken to be part of the construction of a single character for an integer character constant or of a single wide character for a wide character constant. The numerical value of the octal integer so formed specifies the value of the desired character or wide character. [...]</p>\n<p>An integer character constant has type <code>int</code>.</p>\n<h2><code>EOF</code></h2>\n<p><code>EOF</code> is an implementation-defined negative integer</p>\n<blockquote>\n<p id=\"so_4705968_4706217_7\"><em><strong>7.19 Input/output <code>&lt;stdio.h&gt;</code></strong></em></p></blockquote>\n<p><em><strong>7.19.1 Introduction</strong></em></p>\n<p><strong><code>EOF</code></strong></p>\n<p>which expands to an integer constant expression, with type <code>int</code> and a negative value, that is returned by several functions to indicate end-of-file, that is, no more input from a\n  stream</p>\n", "LastActivityDate": "2011-01-16T15:42:31.703"}, "4705984": {"ParentId": "4705968", "LastEditDate": "2015-07-13T17:20:13.173", "CommentCount": "11", "CreationDate": "2011-01-16T14:49:13.707", "OwnerUserId": "19563", "LastEditorUserId": "621690", "PostTypeId": "2", "Id": "4705984", "Score": "37", "Body": "<p><code>EOF</code> is a macro which expands to an integer constant expression with type <code>int</code> and an implementation dependent negative value but is very commonly -1.</p>\n<p><code>'\\0'</code> is a <code>char</code> with value 0 in C++ and an <code>int</code> with the value 0 in C.</p>\n<p>The reason why <code>printf(\"%d\",a==EOF);</code> resulted in <code>1</code> was because you didn't assign the value <code>EOF</code> to <code>a</code>. Instead you checked if <code>a</code> was equal to <code>EOF</code> and since that was true (<code>a == -1 == EOF</code>) it printed <code>1</code>. </p>\n", "LastActivityDate": "2015-07-13T17:20:13.173"}, "4705983": {"ParentId": "4705968", "CommentCount": "1", "Body": "<p>'\\0' is always the null character, or 0. EOF depends on the compiler, but is usually -1, and always is a value that an <code>unsigned char</code> can't hold. Don't rely on the value of EOF being anything, because it CAN CHANGE. Always do x == EOF not x == -1. The value of '\\0' is ALWAYS 0. You can count on that.</p>\n", "OwnerUserId": "411316", "PostTypeId": "2", "Id": "4705983", "Score": "4", "CreationDate": "2011-01-16T14:49:03.470", "LastActivityDate": "2011-01-16T14:49:03.470"}, "4705968": {"CommentCount": "2", "CreationDate": "2011-01-16T14:46:18.687", "PostTypeId": "1", "AcceptedAnswerId": "4705984", "LastEditorUserId": "827263", "LastActivityDate": "2015-07-13T17:20:13.173", "LastEditDate": "2013-06-11T18:36:44.017", "ViewCount": "48867", "FavoriteCount": "14", "Title": "What is value of EOF and '\\0' in C", "Id": "4705968", "Score": "26", "Body": "<p>I know that <code>EOF</code> and <code>'\\0'</code> are of type integers, but if so shouldn't they have a fixed value?</p>\n<p>I printed both and got -1 for <code>EOF</code> and 0 for <code>'\\0'</code>. But are these values fixed?</p>\n<p>I also had this</p>\n<pre><code>int a=-1;\n\nprintf(\"%d\",a==EOF); //printed 1\n</code></pre>\n<p>Are the value for <code>EOF</code> and <code>'\\0'</code> fixed integers? </p>\n", "Tags": "<c++><c><null><eof>", "OwnerUserId": "441077", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_4705968_4706217_3": {"section_id": 5346, "quality": 0.875, "length": 14}}, "n3337": {"so_4705968_4706217_3": {"section_id": 5143, "quality": 0.875, "length": 14}}, "n4659": {"so_4705968_4706217_3": {"section_id": 6771, "quality": 0.875, "length": 14}}}, "4706009": {"ParentId": "4705968", "LastEditDate": "2011-01-16T14:59:11.107", "CommentCount": "6", "CreationDate": "2011-01-16T14:54:06.760", "OwnerUserId": "268724", "LastEditorUserId": "268724", "PostTypeId": "2", "Id": "4706009", "Score": "0", "Body": "<p>'\\0' is always 0</p>\n<p>EOF is compiler dependent</p>\n<p>most commonly its -1 (in gcc &amp; g++ it is -1).</p>\n", "LastActivityDate": "2011-01-16T14:59:11.107"}});