post_cb({"30089607": {"ParentId": "30089415", "CommentCount": "0", "Body": "<p>From a specification point of view: it's UB.</p>\n<p>From a <em>what-will-it-do</em> point of view, yes, it will eventually wrap around to zero in most environments, especially for plain C. It may take a century or so on a 64-bit system.</p>\n", "OwnerUserId": "140740", "PostTypeId": "2", "Id": "30089607", "Score": "2", "CreationDate": "2015-05-06T23:51:59.167", "LastActivityDate": "2015-05-06T23:51:59.167"}, "30089452": {"ParentId": "30089415", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>Short answer: by spec, it is undefined behavior. Performing any pointer arithmetic that leads to unallocated memory more than one address past an allocated item (see the <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/iterators.html\">One Past the End</a> chapter in the GCC docs for the significance of this) is undefined behavior.</p>\n<hr>\n<p>To see why, let us look at the standard:</p>\n<p>Sec 3.7.4.3.2 in the C++11 standard enumerates over all \"safely-derived pointer\" types. Most items in sec 3.7.4.3.2 of the standard describe ways to obtain references to objects legally. Assuming a pointer refers to allocated memory, 3.7.4.3.2 simply states:</p>\n<blockquote>\n<p id=\"so_30089415_30089452_0\">A pointer value is a <em>safely-derived pointer</em> to a dynamic object only if it has an object pointer type and it is one of the following:</p>\n<ul>\n<li>the result of well-defined pointer arithmetic (5.7) using a safely-derived pointer value;</li>\n</ul>\n</blockquote>\n<p>Sec 5.7.4 states:</p>\n<blockquote>\n<p id=\"so_30089415_30089452_1\">For the purposes of these operators, <strong>a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type</strong>.</p>\n</blockquote>\n<p>Finally, sec 5.7.5:</p>\n<blockquote>\n<p id=\"so_30089415_30089452_2\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; <strong>otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n</hr>", "OwnerUserId": "864313", "LastEditorUserId": "864313", "LastEditDate": "2015-05-06T23:51:41.220", "Id": "30089452", "Score": "9", "CreationDate": "2015-05-06T23:34:26.883", "LastActivityDate": "2015-05-06T23:51:41.220"}, "30089415": {"CommentCount": "0", "ViewCount": "359", "CreationDate": "2015-05-06T23:30:25.427", "LastActivityDate": "2015-05-06T23:51:59.167", "Title": "Do pointer types wrap around their maximum value?", "AcceptedAnswerId": "30089452", "PostTypeId": "1", "Id": "30089415", "Score": "9", "Body": "<p>Consider a pointer <code>char* p</code> that is not <code>nullptr</code>, and the loop</p>\n<pre><code>while(++p);\n</code></pre>\n<p>Is the behaviour well defined or undefined? In other words, will the pointer eventually become 0 when reaching the maximum allocable memory (probably 2^32 or 2^64) or this is just UB?</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits\">std::numeric_limits</a> is (as expected) not specialized for pointer types.</p>\n", "Tags": "<c++><c><pointers>", "OwnerUserId": "3093378", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30089415_30089452_1": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}, "so_30089415_30089452_0": {"section_id": 7185, "quality": 1.0, "length": 11}, "so_30089415_30089452_2": {"section_id": 6142, "quality": 1.0, "length": 21}}, "n3337": {"so_30089415_30089452_1": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}, "so_30089415_30089452_0": {"section_id": 6929, "quality": 1.0, "length": 11}, "so_30089415_30089452_2": {"section_id": 5906, "quality": 1.0, "length": 21}}, "n4659": {"so_30089415_30089452_1": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_30089415_30089452_0": {"section_id": 8693, "quality": 0.9090909090909091, "length": 10}, "so_30089415_30089452_2": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}}}});