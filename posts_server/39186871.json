post_cb({"bq_ids": {"n4140": {"so_39186871_39186871_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 174}, "so_39186871_39186871_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 4560}, "so_39186871_39187930_0": {"length": 42, "quality": 0.875, "section_id": 3241}}, "n3337": {"so_39186871_39186871_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 4390}, "so_39186871_39186871_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 168}, "so_39186871_39187930_0": {"length": 42, "quality": 0.875, "section_id": 3114}}, "n4659": {"so_39186871_39186871_1": {"length": 9, "quality": 1.0, "section_id": 5932}, "so_39186871_39186871_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 179}, "so_39186871_39187930_0": {"length": 41, "quality": 0.8541666666666666, "section_id": 3997}}}, "39191281": {"Id": "39191281", "PostTypeId": "2", "Body": "<p>In <code>result_of_t&lt;Mp(const MyClass)&gt;</code> you appear to be trying to ask what is the type of the result of invoking <code>Mp</code> with a <code>const</code> rvalue of type <code>MyClass</code>. A better way to ask that with <code>result_of</code> would be <code>result_of_t&lt;Mp(const MyClass&amp;&amp;)&gt;</code> but it's usually easier to just use <code>decltype</code> and forget that <code>result_of</code> ever existed. If you actually intended to ask the result with a <code>const</code> lvalue then that would be <code>result_of_t&lt;Mp(const MyClass&amp;)&gt;</code>.</p>\n<p>It is true that top-level <code>const</code> on function parameters has no meaning in a function declaration. When using <code>result_of</code>, therefore, it makes more sense to supply argument types as references to possibly-<code>const</code> types. This also makes the value category explicit, with no loss of expressivity. We can use the <code>print_type</code> trick to see what happens when we do this:</p>\n<pre><code>template &lt;typename...&gt; struct print_type; // forward declaration\n\nprint_type&lt;std::result_of_t&lt;Mp(const MyClass)&gt;,\n           std::result_of_t&lt;Mp(const MyClass&amp;)&gt;,\n           std::result_of_t&lt;Mp(const MyClass&amp;&amp;)&gt;,\n           std::result_of_t&lt;Mp(MyClass)&gt;,\n           std::result_of_t&lt;Mp(MyClass&amp;)&gt;,\n           std::result_of_t&lt;Mp(MyClass&amp;&amp;)&gt;&gt;{};\n</code></pre>\n<p>This prints:</p>\n<pre><code>error: invalid use of incomplete type 'struct print_type&lt;int&amp;&amp;, const int&amp;, const int&amp;&amp;, int&amp;&amp;, int&amp;, int&amp;&amp;&gt;'\n</code></pre>\n<p>So we can deduce:</p>\n<pre><code>std::result_of_t&lt;Mp(const MyClass)&gt;   == int&amp;&amp;\nstd::result_of_t&lt;Mp(const MyClass&amp;)&gt;  == const int&amp;\nstd::result_of_t&lt;Mp(const MyClass&amp;&amp;)&gt; == const int&amp;&amp;\nstd::result_of_t&lt;Mp(MyClass)&gt;         == int&amp;&amp;\nstd::result_of_t&lt;Mp(MyClass&amp;)&gt;        == int&amp;\nstd::result_of_t&lt;Mp(MyClass&amp;&amp;)&gt;       == int&amp;&amp;\n</code></pre>\n<p>We can see that <code>result_of_t&lt;Mp(const MyClass)&gt;</code>, <code>result_of_t&lt;Mp(MyClass)&gt;</code>, and <code>result_of_t&lt;Mp(MyClass&amp;&amp;)&gt;</code> all mean the same thing. I would find it surprising if they didn't.</p>\n<p>Note that when you use <code>declval</code> you are also providing argument types as references, as <code>declval</code> is declared to return a reference. Furthermore, all parameters to <code>std::invoke</code> are references.</p>\n", "LastActivityDate": "2016-08-28T12:29:04.783", "Score": "4", "CreationDate": "2016-08-28T12:29:04.783", "ParentId": "39186871", "CommentCount": "0", "OwnerUserId": "1639256"}, "39186871": {"ViewCount": "255", "Body": "<p>Given the following declarations:</p>\n<pre><code>struct MyClass { };\ntypedef int MyClass::*Mp;\n</code></pre>\n<p>On both gcc 6.2 and Clang  compiler I have tried, <code>result_of&lt;Mp(const MyClass)&gt;::type</code> yields <code>int&amp;&amp;</code>.</p>\n<p><strong>Summary of my question:</strong> Why <code>int&amp;&amp;</code> and not either <code>const int&amp;&amp;</code> or simply <code>int</code>?</p>\n<p>More Background: The standard says that <code>result_of</code> is defined this way:</p>\n<blockquote>\n<p id=\"so_39186871_39186871_0\">the member typedef type shall name the type\n  <code>decltype(INVOKE(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...));</code></p>\n</blockquote>\n<p>The standard also defines INVOKE for pointer-to-member-objects this way:</p>\n<blockquote>\n<p id=\"so_39186871_39186871_1\">\u2014 t1.*f when N == 1 and f is a pointer to data member of a class T and <code>is_base_of_v&lt;T, decay_t&lt;decltype(t1)&gt;&gt;</code> is true;</p>\n</blockquote>\n<p>Note that the <code>decay_t</code> is only for testing whether this bullet applies.  As far as I can tell, applying the two points above should yield:</p>\n<pre><code>decltype(declval&lt;const MyClass&gt;().*declval&lt;Mp&gt;())\n</code></pre>\n<p>Which yields <code>const int&amp;&amp;</code>.  So, am I missing something, or are the compiler libraries wrong?</p>\n<p><strong>Edit, 30 Aug 2016:</strong></p>\n<p>Thanks for the responses.  Several people have suggested alternative ways of getting the correct result without using <code>result_of</code>.  I should clarify that the reason I am hung up on the correct definition of <code>result_of</code> is that I'm actually implementing the closest reasonable implementation of <code>result_of</code> that works with a pre-C++11 compiler. So, while I agree that I can use <code>decltype</code> or <code>result_of&lt;Mp(const MyClass&amp;&amp;)&gt;::type</code> in C++11, they do not do what I need for C++03.  Several people have given the correct answer, which is that const rvalue arguments to functions are not part of the function type.  This clarifies things for me and I will implement my pre-C++11 <code>result_of</code> such that it also discards those qualifiers.</p>\n", "AcceptedAnswerId": "39187930", "Title": "result_of for member object with cv-qualified argument", "CreationDate": "2016-08-28T00:07:58.487", "Id": "39186871", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-08-30T15:52:58.187", "LastEditorUserId": "1005445", "LastActivityDate": "2016-08-30T15:52:58.187", "Score": "20", "OwnerUserId": "1005445", "Tags": "<c++><c++14><language-lawyer><result-of>", "AnswerCount": "2"}, "39187930": {"Id": "39187930", "PostTypeId": "2", "Body": "<p><code>const</code> is stripped from function parameters. You can verify this using <code>is_same</code>.</p>\n<pre><code>void(int) == void(const int)\nMp(MyClass) == Mp(const MyClass)\nresult_of&lt;Mp(MyClass)&gt; == result_of&lt;Mp(const MyClass)&gt;\n</code></pre>\n<p>I think this is explained by <code>[8.3.5.5]</code>:</p>\n<blockquote>\n<p id=\"so_39186871_39187930_0\">After producing the list of parameter types, any top-level\n  cv-qualifiers modifying a parameter type are deleted when forming the\n  function type. The resulting list of transformed parameter types and\n  the presence or absence of the ellipsis or a function parameter pack\n  is the function\u2019s parameter-type-list. [ Note: This transformation\n  does not affect the types of the parameters. For example, <code>int(*)(const\n  int p, decltype(p)*)</code> and <code>int(*)(int, const int*)</code> are identical types.\n  \u2014 end note ]</p>\n</blockquote>\n<p>You can work around it by defining your own <code>result_of</code> that does not (mis)use function types:</p>\n<pre><code>template &lt;typename F, typename... ArgTypes&gt;\nstruct my_result_of\n{\n    using type = decltype(std::invoke(std::declval&lt;F&gt;(), std::declval&lt;ArgTypes&gt;()...));\n};\n</code></pre>\n<p>This definition is really what the standard should have used.</p>\n", "LastEditorUserId": "964135", "LastActivityDate": "2016-08-28T04:22:41.797", "Score": "8", "CreationDate": "2016-08-28T04:11:58.360", "ParentId": "39186871", "CommentCount": "3", "LastEditDate": "2016-08-28T04:22:41.797", "OwnerUserId": "964135"}});