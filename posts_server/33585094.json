post_cb({"33585481": {"ParentId": "33585094", "CommentCount": "0", "Body": "<p>No.  <code>size_t</code> can and does differ from <code>unsigned int</code>.</p>\n<p>Per the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">C standard, 6.5.3.4</a>:</p>\n<blockquote>\n<p id=\"so_33585094_33585481_0\">The value of the result of both operators is implementation-defined,\n  and its type (an unsigned integer type) is <code>size_t</code>, defined in\n  <code>&lt;stddef.h&gt;</code> (and other headers).</p>\n</blockquote>\n<p>Under the C standard, <code>size_t</code> is an undefined unsigned integer type.</p>\n<p>Per the <a href=\"http://www.unix.org/whitepapers/64bit.html\" rel=\"nofollow\">Open Group (POSIX, etc)</a>:</p>\n<blockquote>\n<p id=\"so_33585094_33585481_1\"><strong>64-bit and Data Size Neutrality</strong></p>\n<p id=\"so_33585094_33585481_2\">...</p>\n<p id=\"so_33585094_33585481_3\"><em>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) =\n  sizeof(size_t)</em></p>\n</blockquote>\n<p>Simply put:</p>\n<p><code>size_t</code> <strong>is</strong> <code>size_t</code>.  Code that fails to conform to that is wrong.</p>\n", "OwnerUserId": "4756299", "PostTypeId": "2", "Id": "33585481", "Score": "1", "CreationDate": "2015-11-07T17:14:44.583", "LastActivityDate": "2015-11-07T17:14:44.583"}, "33585153": {"ParentId": "33585094", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>x86-64 and aarch64 (arm64) Linux, OS X and iOS all have <code>size_t</code> ultimately defined as <code>unsigned long</code>. (This is the LP64 model. This kind of thing is part of the platform's ABI which also defines things like function calling convention, etc. Other architectures may vary.) Even 32-bit x86 and ARM architectures use <code>unsigned long</code> on these OSes, although <code>long</code> happens to be the same representation as an <code>int</code> in those cases.</p>\n<p>I'm fairly sure it's an <code>unsigned __int64</code>/<code>unsigned long long</code> on Win64. (which uses the LLP64 model)</p>\n", "OwnerUserId": "48660", "LastEditorUserId": "48660", "LastEditDate": "2015-11-07T16:48:50.207", "Id": "33585153", "Score": "5", "CreationDate": "2015-11-07T16:42:59.223", "LastActivityDate": "2015-11-07T16:48:50.207"}, "33585164": {"ParentId": "33585094", "CommentCount": "0", "Body": "<p>No. I just ran this program on <a href=\"http://cpp.sh/\" rel=\"nofollow\">cpp.sh</a> which is gcc:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n  std::cout &lt;&lt; sizeof(unsigned int) &lt;&lt; \" \" &lt;&lt; sizeof(unsigned long) &lt;&lt; \" \" &lt;&lt; sizeof(size_t) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>and it produce this output:</p>\n<p>4 8 8</p>\n", "OwnerUserId": "1320751", "PostTypeId": "2", "Id": "33585164", "Score": "0", "CreationDate": "2015-11-07T16:43:36.467", "LastActivityDate": "2015-11-07T16:43:36.467"}, "33585169": {"ParentId": "33585094", "CommentCount": "0", "Body": "<p>From the <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_types.h.html\" rel=\"nofollow\">sys/types.h man page</a> :</p>\n<blockquote>\n<p id=\"so_33585094_33585169_0\">size_t shall be an unsigned integer type.</p>\n</blockquote>\n<p>So at least theoretically it could be an unsigned <code>short</code>, <code>int</code>, <code>long</code>, or <code>long long</code>.</p>\n", "OwnerUserId": "1840239", "PostTypeId": "2", "Id": "33585169", "Score": "1", "CreationDate": "2015-11-07T16:43:59.163", "LastActivityDate": "2015-11-07T16:43:59.163"}, "33585174": {"ParentId": "33585094", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, it is unsigned integer type (not <code>unsigned int</code>). From <a href=\"http://en.cppreference.com/w/cpp/types/size_t\" rel=\"nofollow\">CPPReference</a>:       </p>\n<blockquote>\n<p id=\"so_33585094_33585174_0\">std::size_t is the unsigned integer type of the result of the sizeof\n  operator</p>\n</blockquote>\n<p>But you can't say exactly what its size is, that I guess depends on the platform.</p>\n", "OwnerUserId": "3963067", "LastEditorUserId": "3963067", "LastEditDate": "2015-11-07T16:46:48.000", "Id": "33585174", "Score": "2", "CreationDate": "2015-11-07T16:44:30.000", "LastActivityDate": "2015-11-07T16:46:48.000"}, "33585094": {"CommentCount": "2", "ViewCount": "895", "PostTypeId": "1", "ClosedDate": "2015-11-07T18:31:23.610", "LastEditorUserId": "417501", "LastActivityDate": "2015-11-07T17:43:44.597", "Body": "<p>Are there any implementations that have <code>size_t</code> defined as something else than <code>unsigned int</code>? Under every system I worked, it was defined as unsigned int, so I'm just curious.</p>\n", "LastEditDate": "2015-11-07T17:06:30.073", "AcceptedAnswerId": "33585153", "Title": "Is size_t is always unsigned int", "Id": "33585094", "Score": "4", "CreationDate": "2015-11-07T16:37:57.037", "Tags": "<c++><size-t>", "OwnerUserId": "4266765", "AnswerCount": "7"}, "33585152": {"ParentId": "33585094", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>No. But it is an unsigned <em>integer</em> type. It need not be <em>int</em> specifically.</p>\n<h2>For C++</h2>\n<p><a href=\"http://en.cppreference.com/w/cpp/types/size_t\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/types/size_t</a></p>\n<p>C++ standard secton 18.2.6</p>\n<blockquote>\n<p id=\"so_33585094_33585152_0\">The type <code>size_t</code> is an implementation-defined unsigned integer type\n  that is large enough to contain the size in bytes of any object.</p>\n</blockquote>\n<p>For linux; \"<a href=\"https://stackoverflow.com/questions/12490622/where-is-c-size-t-defined-in-linux\">Where is c++ size_t defined in linux</a>\" gives <code>long unsigned int</code></p>\n<h2>For C</h2>\n<p>(The question was originally tagged both C and C++.)</p>\n<p>have a look at the answers here:</p>\n<p><a href=\"https://stackoverflow.com/questions/918787/whats-sizeofsize-t-on-32-bit-vs-the-various-64-bit-data-models\">What's sizeof(size_t) on 32-bit vs the various 64-bit data models?</a></p>\n", "OwnerUserId": "1149664", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:42.480", "Id": "33585152", "Score": "4", "CreationDate": "2015-11-07T16:42:50.163", "LastActivityDate": "2015-11-07T17:43:44.597"}, "bq_ids": {"n4140": {"so_33585094_33585169_0": {"section_id": 6708, "quality": 1.0, "length": 4}, "so_33585094_33585152_0": {"section_id": 6708, "quality": 0.8461538461538461, "length": 11}, "so_33585094_33585265_0": {"section_id": 6708, "quality": 0.8461538461538461, "length": 11}, "so_33585094_33585174_0": {"section_id": 3291, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_33585094_33585169_0": {"section_id": 6463, "quality": 1.0, "length": 4}, "so_33585094_33585152_0": {"section_id": 6463, "quality": 0.8461538461538461, "length": 11}, "so_33585094_33585265_0": {"section_id": 6463, "quality": 0.8461538461538461, "length": 11}, "so_33585094_33585174_0": {"section_id": 3358, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_33585094_33585169_0": {"section_id": 8183, "quality": 1.0, "length": 4}, "so_33585094_33585152_0": {"section_id": 8183, "quality": 0.8461538461538461, "length": 11}, "so_33585094_33585265_0": {"section_id": 8183, "quality": 0.8461538461538461, "length": 11}, "so_33585094_33585174_0": {"section_id": 7797, "quality": 0.7142857142857143, "length": 5}}}, "33585265": {"ParentId": "33585094", "CommentCount": "0", "Body": "<p>There's absolutely <em>no warranty</em> that <code>size_t</code> is defined as any \"concrete\" type. Actually, if you want to see a system where it's not <code>unsigned int</code>, see, for instance, my machine (<code>unsigned long</code>), and thus most 64-bit GNU/Linux systems.</p>\n<p>From N4296, section 18.2.6:</p>\n<blockquote>\n<p id=\"so_33585094_33585265_0\">The type <code>size_t</code> is an implementation-defined unsigned integer type that is large enough to contain the size bytes of any object.</p>\n</blockquote>\n<p>Also, from N897 (Rationale) 6.5.3.4...</p>\n<blockquote>\n<p id=\"so_33585094_33585265_1\">The type of <code>sizeof</code>, whatever it is, is published (in the library\n  header <code>&lt;stddef.h&gt;</code>) as <code>size_t</code>, since it is useful for the programmer\n  to be able to refer to this type.  This requirement implicitly\n  restricts <code>size_t</code> to be a synonym for an existing unsigned integer\n  type. Note also that, although <code>size_t</code> is an unsigned type, <code>sizeof</code> \n  does not involve any arithmetic operations or conversions that would\n  result in modulus behavior if the size is too large to represent as a \n  <code>size_t</code>, thus quashing any notion that the largest declarable\n  object might be too big to span even with an <code>unsigned long</code> in C89 or \n  <code>uintmax_t</code> in C9X. This also restricts the maximum number of elements\n  that may be declared in an array, since for any array <code>a</code> of <code>N</code>\n  elements,</p>\n<p id=\"so_33585094_33585265_2\"><code>N == sizeof(a)/sizeof(a[0])</code></p>\n<p id=\"so_33585094_33585265_3\">Thus <code>size_t</code> is also a convenient type for array sizes, and is so used in several library functions.</p>\n</blockquote>\n", "OwnerUserId": "5249858", "PostTypeId": "2", "Id": "33585265", "Score": "2", "CreationDate": "2015-11-07T16:53:00.377", "LastActivityDate": "2015-11-07T16:53:00.377"}});