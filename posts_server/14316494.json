post_cb({"14316659": {"ParentId": "14316494", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When a polymorphic object (instance of a class with at least one virtual function) is created, it has to have a virtual table pointer that points to the virtual table. Each polymorphic class will have a virtual table that is constructed once. <strong>It is up to the implementation of the compiler to allow the virtual table to be incomplete</strong>. This table is populated based on virtual function definition. </p>\n<p>If any virtual function is not implemented and the function is not pure virtual then some compilers give a compiler error as the virtual table is incomplete.</p>\n<p>In the case of a simple (non-virtual) function, the function declaration will be ignored if it is never used. Even if it is used, we get a linker error and not compiler error.</p>\n", "OwnerUserId": "1201507", "LastEditorUserId": "1201507", "LastEditDate": "2013-01-14T10:34:40.823", "Id": "14316659", "Score": "3", "CreationDate": "2013-01-14T10:25:00.293", "LastActivityDate": "2013-01-14T10:34:40.823"}, "14316611": {"ParentId": "14316494", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is strictly up to the compiler. No diagnostic is required for either case.</p>\n<h3>10.3 Virtual functions [class.virtual]</h3>\n<blockquote>\n<p id=\"so_14316494_14316611_0\">9 A <code>virtual</code> function declared in a class shall be defined, or declared\n  pure (10.4) in that class, or both; but <strong>no diagnostic is required</strong>\n  (3.2). [emphasis mine]</p>\n</blockquote>\n<p>To understand why this happens though, let's have a look at how it works.</p>\n<p>Each translation unit generates an object file, each object file with exports (symbols it exported) and imports (symbols it wants).</p>\n<p>The first example is simple - the imports only require <code>foo</code> when it is used. There's no reason for the linker to look for the symbol, so it doesn't.</p>\n<p>The second one, with the <code>virtual</code> method, is a bit more complicated. Most compilers (if not all) required <strong>valid virtual function tables</strong>. That means that at link time, all classes that declared non-pure virtual methods would have to have those methods exported. This is stricter than the non-<code>virtual</code> case because the implementation doesn't actually know whether the function is called or not (it could be called polymorphically).</p>\n", "OwnerUserId": "673730", "LastEditorUserId": "673730", "LastEditDate": "2013-01-14T10:33:07.767", "Id": "14316611", "Score": "15", "CreationDate": "2013-01-14T10:21:57.913", "LastActivityDate": "2013-01-14T10:33:07.767"}, "14316646": {"ParentId": "14316494", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A virtual function declared in a class shall be defined, or declared pure in that class, or both(C++03 Standard).</p>\n", "OwnerUserId": "844759", "LastEditorUserId": "844759", "LastEditDate": "2013-01-14T10:47:40.163", "Id": "14316646", "Score": "1", "CreationDate": "2013-01-14T10:24:04.637", "LastActivityDate": "2013-01-14T10:47:40.163"}, "14316494": {"CommentCount": "3", "AcceptedAnswerId": "14316611", "PostTypeId": "1", "LastEditorUserId": "1139697", "CreationDate": "2013-01-14T10:14:45.227", "LastActivityDate": "2013-01-14T10:47:40.163", "LastEditDate": "2013-01-14T10:20:22.757", "ViewCount": "1117", "FavoriteCount": "2", "Title": "Why does a virtual function with only a declaration result in a compiler error?", "Id": "14316494", "Score": "14", "Body": "<p>I have this class,</p>\n<pre><code>class Base {\n    public:\n        void foo();\n};\n\nint main()\n{\n    Base b;\n}\n</code></pre>\n<p><code>main</code> will compile without any error, although <code>foo()</code> has no definition. But <code>b.foo();</code> will result in a compile error.</p>\n<p>Moreover, even for <code>constructor</code> and <code>operator=</code>, I can just declare them without defining them, it'll compile as long as I don't trigger them.</p>\n<h1>Question</h1>\n<p>Again, I add a virtual function into <code>Base</code>,</p>\n<pre><code>class Base {\n    public:\n        void foo();\n        virtual void bar();  // no defition is gonna be provided.\n};\n</code></pre>\n<p>Now, <code>main</code> cannot compile, instead I get an error:</p>\n<pre>undefined reference to vtable for Base</pre>\n<p>Well this confuses me a little bit, because previously, <code>main</code> could compile as long as <code>foo()</code> is not called, but now I add <code>bar()</code> and it's not called at all.</p>\n<p>Why doesn't it compile in this case? </p>\n", "Tags": "<c++>", "OwnerUserId": "888051", "AnswerCount": "4"}, "14316578": {"ParentId": "14316494", "CommentCount": "4", "Body": "<p>First version can compile because the linker needn't search for the object <code>foo</code>. It's used nowhere.</p>\n<p>But when you create a virtual function, the construction of the <a href=\"https://en.wikipedia.org/wiki/Virtual_method_table\">vtable</a> (for dynamic dispatch) needs an address for the function <code>Base::bar</code> (it makes a reference to it) and therefore the linker needs to find an implementation of it.</p>\n", "OwnerUserId": "457352", "PostTypeId": "2", "Id": "14316578", "Score": "5", "CreationDate": "2013-01-14T10:19:22.353", "LastActivityDate": "2013-01-14T10:19:22.353"}, "bq_ids": {"n4140": {"so_14316494_14316611_0": {"section_id": 7012, "quality": 0.8, "length": 12}}, "n3337": {"so_14316494_14316611_0": {"section_id": 6758, "quality": 0.8, "length": 12}}, "n4659": {"so_14316494_14316611_0": {"section_id": 8509, "quality": 0.7333333333333333, "length": 11}}}});