post_cb({"19612378": {"CommentCount": "1", "ViewCount": "109", "PostTypeId": "1", "LastEditorUserId": "2923952", "CreationDate": "2013-10-26T22:00:47.563", "LastActivityDate": "2013-10-26T23:26:12.107", "Title": "Nested template requires explicit construction?", "AcceptedAnswerId": "19612457", "LastEditDate": "2013-10-26T22:16:14.100", "Id": "19612378", "Score": "2", "Body": "<p>I have a nested template inside a parent template.  I'd like instances of the nested template to be convertible to other classes instantiated from the same template (but with different parameters.)  To do this, I create a constructor for the nested template that can take different template parameters:</p>\n<pre><code>template &lt;class T&gt;\nstruct Foo\n{\n\n    template &lt;class U&gt;\n    struct Bar\n    {\n        Bar() { }\n\n        template &lt;class X, class Y&gt;\n        Bar(typename Foo&lt;X&gt;::template Bar&lt;Y&gt; b)\n        {\n\n        }\n    };\n\n};\n</code></pre>\n<p>This should enable the following expression to compile:</p>\n<pre><code>Foo&lt;int&gt;::Bar&lt;int&gt; b = Foo&lt;char&gt;::Bar&lt;char&gt;();\n</code></pre>\n<p><br>\n<br/></br></p>\n<p>However, it <strong><em>doesn't</em></strong> actually compile.  It gives the compiler error:</p>\n<pre><code>error: conversion from \u2018Foo&lt;char&gt;::Bar&lt;char&gt;\u2019 to non-scalar type \u2018Foo&lt;int&gt;::Bar&lt;int&gt;\u2019 requested\n  Foo&lt;int&gt;::Bar&lt;int&gt; b = Foo&lt;char&gt;::Bar&lt;char&gt;();\n</code></pre>\n<p>So, I'm confused.  Why doesn't this compile?</p>\n", "Tags": "<c++>", "OwnerUserId": "2923952", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19612378_19612457_0": {"section_id": 306, "quality": 0.85, "length": 34}}, "n3337": {"so_19612378_19612457_0": {"section_id": 297, "quality": 0.85, "length": 34}}, "n4659": {"so_19612378_19612457_0": {"section_id": 313, "quality": 0.85, "length": 34}}}, "19612457": {"ParentId": "19612378", "PostTypeId": "2", "CommentCount": "14", "Body": "<h3>Why does the second version compile?</h3>\n<p>Because the second one doesn't create a <code>Foo&lt;int&gt;::Bar&lt;int&gt;</code>. You've run into the <a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow noreferrer\">most vexing parse</a>.</p>\n<p>Had you attempted you <em>use</em> the <code>b</code> that appears to work, you'd have received further compiler errors showing that your <code>b</code> is in fact declared as a function.</p>\n<p>Try this:</p>\n<pre><code>Foo&lt;int&gt;::Bar&lt;int&gt; b((Foo&lt;char&gt;::Bar&lt;char&gt;()));  // works fine? are you sure? :)\n//                   ^                      ^\n</code></pre>\n<p>Your root problem is that the arguments will not be deduced<sup>\u2020</sup>, and <a href=\"https://stackoverflow.com/a/6359067/560648\">you cannot provide them explicitly</a> because we do not use function-call syntax <em>per se</em> when a constructor is invoked.</p>\n<hr>\n<h3><sup>\u2020</sup> <em>Why</em> won't they be deduced?</h3>\n<p>To demonstrate, observe the following modified code where I replace the non-default constructor with a member function:</p>\n<pre><code>template &lt;class T&gt;\nstruct Foo\n{\n\n    template &lt;class U&gt;\n    struct Bar\n    {\n        Bar();\n\n        template &lt;class X, class Y&gt;\n        void foo(typename Foo&lt;X&gt;::template Bar&lt;Y&gt; b)\n        {}\n    };\n};\n\nint main()\n{\n    //Foo&lt;int&gt;::Bar&lt;int&gt; b = Foo&lt;char&gt;::Bar&lt;char&gt;();\n    Foo&lt;int&gt;::Bar&lt;int&gt; i;\n    i.foo(Foo&lt;char&gt;::Bar&lt;char&gt;());\n}\n</code></pre>\n<p>This gives us some more information to go on, wherein <a href=\"http://ideone.com/DU3Khy\" rel=\"nofollow noreferrer\">the key error is</a>:</p>\n<pre><code>prog.cpp:11:14: note:   template argument deduction/substitution failed:\nprog.cpp:23:30: note:   couldn't deduce template parameter \u2018X\u2019\n  i.foo(Foo&lt;char&gt;::Bar&lt;char&gt;());\n</code></pre>\n<p>Changing the call, providing explicit arguments, to:</p>\n<pre><code>i.foo&lt;char,char&gt;(Foo&lt;char&gt;::Bar&lt;char&gt;());\n</code></pre>\n<p>yields a successful compilation; but this doesn't help us in our original code, as we cannot provide explicit arguments to a constructor invocation.</p>\n<p>So, we're stuck with deduction, but unfortunately the nestedness breaks this for us through the following series of rules:</p>\n<blockquote>\n<p id=\"so_19612378_19612457_0\"><code>[C++11: 14.8.2.1/5]:</code> These alternatives are considered only if type deduction would otherwise fail. If they yield more than one possible deduced <code>A</code>, the type deduction fails. <em>[ Note:</em> <strong>If a <em>template-parameter</em></strong> is not used in any of the function parameters of a function template, or <strong>is used only in a non-deduced context, its corresponding <em>template-argument</em> cannot be deduced from a function call and the <em>template-argument</em> must be explicitly specified.</strong> <em>\u2014end note ]</em></p>\n<p id=\"so_19612378_19612457_1\"><code>[C++11: 14.8.2.5/5]:</code> The non-deduced contexts are:</p>\n<ul>\n<li><em>[..]</em></li>\n<li>The <a href=\"https://stackoverflow.com/a/4103791/560648\"><em>nested-name-specifier</em></a> of a type that was specified using a <em>qualified-id</em>.</li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p>In short, we cannot expect the <code>X</code> in <code>Foo&lt;X&gt;::Bar&lt;Y&gt;</code> to be deduced, and that's where everything breaks down. So, basically, you can't do this. Sorry.</p>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:25:47.877", "Id": "19612457", "Score": "6", "CreationDate": "2013-10-26T22:11:09.613", "LastActivityDate": "2013-10-26T23:26:12.107"}});