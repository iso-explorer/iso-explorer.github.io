post_cb({"38535667": {"Id": "38535667", "PostTypeId": "2", "Body": "<p>For a few references in the Standard:</p>\n<ul>\n<li><p>\u00a76.4.0.4 [stmt.select] </p>\n<blockquote>\n<p id=\"so_38535292_38535667_0\">The value of a condition that is an expression is the value of the\n  expression, contextually converted to <code>bool</code> for statements other than <code>switch</code></p>\n</blockquote></li>\n<li><p>\u00a74.0.4 [conv]</p>\n<blockquote>\n<p id=\"so_38535292_38535667_1\">Certain language constructs require that an expression be converted to a Boolean value. An expression <code>e</code> appearing in such a context is said to be <em>contextually converted to <code>bool</code></em> and is well-formed if and only if the declaration <code>bool t(e);</code> is well-formed, for some invented temporary variable <code>t</code>.</p>\n</blockquote></li>\n<li><p>\u00a78.5.17 [dcl.init]</p>\n<blockquote>\n<p id=\"so_38535292_38535667_2\">The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being initialized and the <em>source type</em> is the type of the initializer expression.</p>\n</blockquote></li>\n<li><p>\u00a78.5.17.7 [dcl.init]</p>\n<blockquote>\n<p id=\"so_38535292_38535667_3\">Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered. The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through overload resolution (13.3). The user-defined conversion so selected is called to convert the initializer expression into the object being initialized. If the conversion cannot be done or is ambiguous, the initialization is ill-formed.</p>\n</blockquote></li>\n<li><p>\u00a713.3.1.5 [over.match.conv]</p>\n<blockquote>\n<p id=\"so_38535292_38535667_4\">Assuming that <em>\u201ccv1 <code>T</code>\u201d</em> is the type of the object being initialized, and <em>\u201ccv <code>S</code>\u201d</em> is the type of the initializer expression, with S a\n  class type, the candidate functions are selected as follows:</p>\n<p id=\"so_38535292_38535667_5\">The conversion functions of S and its base classes are considered. Those non-explicit conversion functions that are not hidden within <code>S</code> and yield type <code>T</code> or a type that can be converted to type <code>T</code> via a standard conversion sequence (13.3.3.1.1) are candidate functions. For direct-initialization, those explicit conversion functions that are not hidden within <code>S</code> and yield type <code>T</code> or a type that can be converted to type <code>T</code> with a qualification conversion (4.4) are also candidate functions.  </p>\n</blockquote></li>\n<li><p>\u00a74.13.1 [conv.bool]</p>\n<blockquote>\n<p id=\"so_38535292_38535667_6\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to <code>false</code>;\n  any other value is converted to <code>true</code>.</p>\n</blockquote></li>\n</ul>\n", "LastActivityDate": "2016-07-22T21:42:58.070", "CommentCount": "0", "CreationDate": "2016-07-22T21:42:58.070", "ParentId": "38535292", "Score": "6", "OwnerUserId": "1873944"}, "38535519": {"Id": "38535519", "PostTypeId": "2", "Body": "<p>If the compiler cannot convert a user-defined type to <code>bool</code> directly, then it tries to do it indirectly, i.e. convert (via an user-defined conversion) to a type that can be converted to <code>bool</code> without involving another user-defined conversion. The list of such types includes (and seems to be limited to) the following types:</p>\n<ul>\n<li>an integer arithmetic type (<code>char</code>, <code>int</code>, etc)</li>\n<li>a floating point arithmetic type (<code>float</code>, <code>double</code>, <code>long double</code>)</li>\n<li><strong>a pointer type (<code>void*</code> belongs here, but it could as well be <code>const std::vector&lt;Something&gt;*</code>)</strong></li>\n<li>a pointer to function (including a pointer to a member function)</li>\n<li>a reference type to any of the above</li>\n</ul>\n<p>Note however that only one such indirect conversion must exist. If two or more conversions from the above list are possible, then the compiler will face an ambiguity and will report an error.</p>\n", "LastActivityDate": "2016-07-22T21:29:46.240", "CommentCount": "0", "CreationDate": "2016-07-22T21:29:46.240", "ParentId": "38535292", "Score": "15", "OwnerUserId": "6394138"}, "38535463": {"Id": "38535463", "PostTypeId": "2", "Body": "<p>Any integral conversion <code>operator</code> would work the same way. You return <code>0</code> in your operator, hence the <code>False</code>.</p>\n<pre><code>operator [int,double,uint64_t,&lt;any_integral&gt;]() const\n{\n    std::cout &lt;&lt; \"integral operator called\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Any integral type can be used in logical expression.</p>\n", "LastActivityDate": "2016-07-22T21:24:48.280", "CommentCount": "0", "CreationDate": "2016-07-22T21:24:48.280", "ParentId": "38535292", "Score": "2", "OwnerUserId": "5405086"}, "38535350": {"Id": "38535350", "PostTypeId": "2", "Body": "<p>This may be any type that can be used in a boolean context, and <code>void *</code> is not special here, eh?</p>\n", "LastActivityDate": "2016-07-22T21:15:26.913", "CommentCount": "0", "CreationDate": "2016-07-22T21:15:26.913", "ParentId": "38535292", "Score": "0", "OwnerUserId": "2749717"}, "bq_ids": {"n4140": {"so_38535292_38535667_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 3}, "so_38535292_38535667_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 595}, "so_38535292_38535667_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3885}, "so_38535292_38535667_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 3296}, "so_38535292_38535667_3": {"length": 36, "quality": 0.9, "section_id": 3296}, "so_38535292_38535667_6": {"length": 28, "quality": 1.0, "section_id": 44}, "so_38535292_38535667_5": {"length": 40, "quality": 0.9302325581395349, "section_id": 595}}, "n3337": {"so_38535292_38535667_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 2}, "so_38535292_38535667_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 585}, "so_38535292_38535667_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3745}, "so_38535292_38535667_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 3166}, "so_38535292_38535667_3": {"length": 36, "quality": 0.9, "section_id": 3166}, "so_38535292_38535667_6": {"length": 28, "quality": 1.0, "section_id": 41}, "so_38535292_38535667_5": {"length": 40, "quality": 0.9302325581395349, "section_id": 585}}, "n4659": {"so_38535292_38535667_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 3}, "so_38535292_38535667_4": {"length": 15, "quality": 1.0, "section_id": 618}, "so_38535292_38535667_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 4764}, "so_38535292_38535667_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 4058}, "so_38535292_38535667_3": {"length": 36, "quality": 0.9, "section_id": 4058}, "so_38535292_38535667_6": {"length": 28, "quality": 1.0, "section_id": 45}, "so_38535292_38535667_5": {"length": 40, "quality": 0.9302325581395349, "section_id": 618}}}, "38535292": {"ViewCount": "691", "Body": "<p><strong>Question:</strong> Does implicit bool conversions always fall back to attempting implicit conversion to <code>void*</code>? (If such a conversion function exists for the type). If so, why?</p>\n<p>Consider the following short program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo{\npublic:\n\n    operator void*() const\n    {\n        std::cout &lt;&lt; \"operator void*() const\" &lt;&lt; std::endl;\n        return 0;\n    }\n};\n\nint main()\n{\n    Foo f;\n\n    if(f)\n        std::cout &lt;&lt; \"True\" &lt;&lt; std::endl;\n    else\n        std::cout &lt;&lt; \"False\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The output of this program is:</p>\n<pre><code>operator void*() const\nFalse\n</code></pre>\n<p>meaning, the conversion function to <code>void*</code> was called.\nIf we tag an <code>explicit</code> qualifier in front of the conversion function then the implicit conversion to <code>void*</code> would fail.</p>\n<p><strong>Edit:</strong>\nIt seems many answers are that \"null pointers can be converted to <code>false</code>\". I understand this, my question was regarding the \"if I can't directly call <code>operator bool()</code> then I will try conversion to any pointer\".</p>\n", "AcceptedAnswerId": "38535519", "Title": "C++, does bool conversion always fall back to implicit conversion to void*?", "CreationDate": "2016-07-22T21:10:49.553", "Id": "38535292", "CommentCount": "3", "LastEditDate": "2016-07-22T21:35:21.130", "PostTypeId": "1", "LastEditorUserId": "3367091", "LastActivityDate": "2016-07-22T21:42:58.070", "Score": "16", "OwnerUserId": "3367091", "Tags": "<c++><implicit-conversion><void-pointers>", "AnswerCount": "5"}, "38535479": {"Id": "38535479", "PostTypeId": "2", "Body": "<p>What's really happening is that your class has an implicit conversion to a pointer type <code>void*</code> in this case. You return <code>0</code>, which is the NULL macro, which is accepted as a pointer type.</p>\n<p>Pointers have implicit conversion to booleans, and null pointers convert to false.</p>\n<p>Really you could have a different implicit conversion to pointer for <code>Foo</code>:</p>\n<pre><code>operator int*() const\n{\n    std::cout &lt;&lt; \"operator int* const\" &lt;&lt; std::endl;\n    return new int(3);\n}\n</code></pre>\n<p>And your output will change to</p>\n<blockquote>\n<p id=\"so_38535292_38535479_0\">operator int* const <br>\n  True</br></p>\n</blockquote>\n<p>However, if you have <strong>both</strong>, then you get a compiler error:</p>\n<pre><code>class Foo{\npublic:\n\n    operator int*() const\n    {\n        std::cout &lt;&lt; \"operator int* const\" &lt;&lt; std::endl;\n        return new int(3);\n    }\n    operator void*() const\n    {\n        std::cout &lt;&lt; \"operator void*() const\" &lt;&lt; std::endl;\n        return 0;\n    }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_38535292_38535479_1\">main.cpp:26:9: error: conversion from 'Foo' to 'bool' is ambiguous</p>\n</blockquote>\n<p>If, however, you explicitly define a conversion, too bool, then it is not ambiguous:</p>\n<pre><code>operator void*() const\n{\n    std::cout &lt;&lt; \"operator void*() const\" &lt;&lt; std::endl;\n    return 0;\n}\n\noperator bool() const\n{\n     std::cout &lt;&lt; \"operator bool() const\" &lt;&lt; std::endl;\n    return true;\n} // &lt;--- compiler chooses this one\n</code></pre>\n<p>The topic of <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow\">implicit conversions</a> actually quite interesting, because it mirrors how the compiler chooses an appropriate member function for given arguments (value conversions, integral promotions, etc.).</p>\n<p>That is, the compiler has a prioritized list it will choose from when trying to determine what you mean. If two overloads have the same priority, you get an error.</p>\n<p>For example, the <code>operator bool</code> will always be chosen, but if you instead had to choose from <code>operator int</code> and <code>operator void*</code>, then <code>operator int</code> would be chosen because it chooses numeric conversion over pointer conversions.</p>\n<p>However, if you had both <code>operator int</code> and <code>operator char</code>, then you'd get an error because they are both numeric integral conversions.</p>\n", "LastEditorUserId": "27678", "LastActivityDate": "2016-07-22T21:34:25.977", "Score": "4", "CreationDate": "2016-07-22T21:25:56.073", "ParentId": "38535292", "CommentCount": "3", "OwnerUserId": "27678", "LastEditDate": "2016-07-22T21:34:25.977"}});