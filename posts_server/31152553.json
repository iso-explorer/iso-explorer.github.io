post_cb({"31152580": {"ParentId": "31152553", "CommentCount": "2", "Body": "<p>Destructors are called for all successfully initialized objects.</p>\n<p>Otherwise there would have had to be default zero-initialization (some overhead) in order to be able to assume anything in a destructor.</p>\n<p>The A object whose constructor throws, is not successfully initialized. So its destructor is not executed. However, if it had any class type sub-objects (base class sub-objects, data members) that had been successfully initialized prior to the exception, then destructors would be called for these.</p>\n<p>And no, throwing from a constructor is not UB.</p>\n<p>On the contrary it's the common way of signalling construction failure, and it ensures that the caller will either have a successfully initialized and presumably useable object, or else (just) an exception.</p>\n<hr>\n<p>History. Originally C++ didn't have exceptions. Construction failure was then signalled by assigning 0 to <code>this</code>. I can't recall how that interacted with allocation, but presumably the same way that an exception now does, namely a guaranteed deallocation. But with this scheme you could only fail construction for dynamically allocated objects\u2026</p>\n</hr>", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "31152580", "Score": "2", "CreationDate": "2015-07-01T04:31:03.147", "LastActivityDate": "2015-07-01T04:31:03.147"}, "31152553": {"CommentCount": "2", "ViewCount": "51", "OwnerDisplayName": "user2953119", "CreationDate": "2015-07-01T04:27:55.690", "LastActivityDate": "2015-07-01T04:39:38.490", "PostTypeId": "1", "AcceptedAnswerId": "31152580", "Title": "Exceptions in constructors", "Id": "31152553", "Score": "0", "Body": "<p>Consider the following class:</p>\n<pre><code>struct A\n{\n    A(){ std::cout &lt;&lt; \"A()\" &lt;&lt; std::endl; throw std::exception(); }\n    ~A(){ std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; }\n};\n\nA a;\nint main(){ }\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/5cca6ec2a4a7405b\" rel=\"nofollow\">DEMO</a></p>\n<p>The Standard promised that the appropriate deallocation function will be called <code>N4296::5.3.4/20 [expr.new]</code>:</p>\n<blockquote>\n<p id=\"so_31152553_31152553_0\">If any part of the object initialization described above78 terminates\n  by throwing an exception, storage has been obtained for the object,\n  and a suitable deallocation function can be found, the deallocation\n  function is called to free the memory in which the object was being\n  constructed,</p>\n</blockquote>\n<p>But what about destructor? In that example it was no called. So, did we get UB?</p>\n", "Tags": "<c++><destructor>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31152553_31152553_0": {"section_id": 6101, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_31152553_31152553_0": {"section_id": 5867, "quality": 0.8076923076923077, "length": 21}}, "n4659": {"so_31152553_31152553_0": {"section_id": 7598, "quality": 0.8076923076923077, "length": 21}}}, "31152656": {"ParentId": "31152553", "CommentCount": "2", "Body": "<p>Destructors are not same as deallocators. Whenever a variable goes out of scope the object referenced to the variable is deleted. In the problem you have given the object is a global variable, so it will be deleted when the program terminates.</p>\n", "OwnerUserId": "4725771", "PostTypeId": "2", "Id": "31152656", "Score": "0", "CreationDate": "2015-07-01T04:39:38.490", "LastActivityDate": "2015-07-01T04:39:38.490"}});