post_cb({"bq_ids": {"n4140": {"so_35875829_35877464_1": {"length": 10, "quality": 1.0, "section_id": 335}, "so_35875829_35877464_2": {"length": 8, "quality": 0.8, "section_id": 336}, "so_35875829_35877464_0": {"length": 18, "quality": 1.0, "section_id": 144}}, "n3337": {"so_35875829_35877464_1": {"length": 10, "quality": 1.0, "section_id": 325}, "so_35875829_35877464_2": {"length": 8, "quality": 0.8, "section_id": 326}, "so_35875829_35877464_0": {"length": 18, "quality": 1.0, "section_id": 138}}, "n4659": {"so_35875829_35877464_1": {"length": 10, "quality": 1.0, "section_id": 344}, "so_35875829_35877464_2": {"length": 8, "quality": 0.8, "section_id": 345}, "so_35875829_35877464_0": {"length": 18, "quality": 1.0, "section_id": 148}}}, "35877464": {"Id": "35877464", "PostTypeId": "2", "Body": "<p>I suspect this is a bug in gcc 6.0, and an incorrect warning in clang 3.9 (the warning is weird - because the warning implies that the partial specialization would not be chosen, but if it were not chosen, the static assert would trigger).</p>\n<hr/>\n<p>From [temp.class.spec.match]:</p>\n<blockquote>\n<p id=\"so_35875829_35877464_0\">A partial specialization matches a given actual template argument list if the template arguments of the\n  partial specialization can be deduced from the actual template argument list</p>\n</blockquote>\n<p>Can we deduce <code>U</code> in <code>typename outer&lt;T&gt;::template inner&lt;U&gt;</code> from <code>outer&lt;int&gt;::inner&lt;double&gt;</code>? </p>\n<p>From [temp.deduct.type]:</p>\n<blockquote>\n<p id=\"so_35875829_35877464_1\">If a template parameter is used only in non-deduced\n  contexts and is not explicitly specified, template argument deduction fails.   </p>\n<p id=\"so_35875829_35877464_2\">The non-deduced contexts are:<br>\n  \u2014 The <em>nested-name-specifier</em> of a type that was specified using a <em>qualified-id</em>.<br>\n  \u2014  [...]</br></br></p>\n</blockquote>\n<p>But the <em>nested-name-specified</em> here is <code>typename outer&lt;T&gt;</code>, which does not contain the type we're trying to deduce. None of the other non-deduced contexts apply. So deduction <strong>should</strong> succeed here.</p>\n<p>Consider the following equivalent situation:</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate &lt;class &gt;\nstruct outer\n{\n    template &lt;class U&gt; struct inner {};\n};\n\ntemplate &lt;class T&gt;\nstruct bar {\n    template &lt;class U&gt; std::false_type foo(U const&amp;);\n    template &lt;class U&gt; std::true_type foo(typename outer&lt;T&gt;::template inner&lt;U&gt; const&amp;);\n};\n\n\nint main() {\n    static_assert(decltype(bar&lt;int&gt;{}.foo(outer&lt;int&gt;::inner&lt;double&gt;{}))::value, \"!\");\n}\n</code></pre>\n<p>Both gcc 6.0 and clang 3.9 compile this code without warning - but this is the same sort of deduction that would happen in the partial specialization in the original example.</p>\n", "LastEditorUserId": "436025", "LastActivityDate": "2016-03-08T20:50:57.073", "Score": "2", "CreationDate": "2016-03-08T20:33:55.537", "ParentId": "35875829", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2016-03-08T20:50:57.073"}, "35875829": {"ViewCount": "1211", "Body": "<p>This code results in an error in gcc6 (but works fine in gcc 4.8, 5.2 and clang 3.6):</p>\n<pre><code>template &lt;typename T&gt;\nstruct outer\n{\n    template &lt;typename U&gt;\n    struct inner\n    {\n\n    };\n};\n\n\ntemplate &lt;typename T&gt;\nstruct is_inner_for\n{\n\n    template &lt;typename Whatever&gt;\n    struct predicate\n    {\n        static constexpr bool value = false;\n    };\n\n    template &lt;typename U&gt;\n    struct predicate&lt;typename outer&lt;T&gt;::template inner&lt;U&gt;&gt;\n    {\n        static constexpr bool value = true;\n    };\n};\n\nstatic_assert(\n    is_inner_for&lt;int&gt;::template predicate&lt;\n        outer&lt;int&gt;::inner&lt;double&gt;\n    &gt;::value,\n    \"Yay!\"\n);\n</code></pre>\n<p>The error is:</p>\n<pre><code>main.cpp:22:9: error: template parameters not deducible in partial specialization:\n  struct predicate&lt;typename outer&lt;T&gt;::template inner&lt;U&gt;&gt; : std::true_type\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmain.cpp:22:9: note:         'U'\n ^~~~~~~~~~~~~\n</code></pre>\n<p>Commandline is:</p>\n<pre><code>g++ -std=c++1y -c main.cpp\n</code></pre>\n<p>See <a href=\"https://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22C4UwtgDgNghqAEAeYBPCIB2MwngFQD4AoAZ2ACcBXAY2HgHtLRyiBvI%2BT%2BUSWBZNJmy4AqsS7wyVWvACWGDCBYT2HLgF8A3ES1E9PaHFwD0WHPmJSadWSQD68xeTsAzei1USDfY6lPD4AHUACyMANyVxLisZCHIQABNZaiM1TnYJCTI4ZPhqegwyEAAPOPgAI3p6KHgwmChKXABeeBd6khBtCV007nBDfj8hczFemLo4xOSjE2HcRmZEQgAuZe8jOQUlRDEo9N6s4BzqPIKi0vIKqpq6hubuKk7e3R7s4GS7GBIO8mAACl6tgcW2cbnIiHkwAIq3WCEmSRSoEQBy4C22kOhy0c2wSjHKUBAe3gmNujQANL0AEQATRgKAAhJSiABKTRAA%22%2C%22compiler%22%3A%22g6%22%2C%22options%22%3A%22-std%3Dc%2B%2B1y%20-O3%20-Wall%20-Werror%22%7D%5D%7D\" rel=\"nofollow\">godbolt output here</a>.</p>\n<p>I have filed a bug report with gcc here: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70141\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70141</a></p>\n<p>However it was marked as invalid (I believe wrongly). The <code>outer&lt;T&gt;</code> that is used inside <code>predicate</code> is a concrete type at that point, so it is not a non-deduced context.</p>\n<p><strong>Is there anything in the standard that prevents this being valid c++ code?</strong></p>\n", "AcceptedAnswerId": "35877464", "Title": "Template parameters not deducible in partial specialization in gcc6, for a case that used to work in gcc5", "CreationDate": "2016-03-08T19:04:05.027", "Id": "35875829", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-08T20:37:44.463", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-08T20:50:57.073", "Score": "3", "OwnerUserId": "436025", "Tags": "<c++><templates><gcc><language-lawyer>", "AnswerCount": "1"}});