post_cb({"bq_ids": {"n4140": {"so_22798558_22798623_0": {"section_id": 6082, "quality": 0.8043478260869565, "length": 37}, "so_22798558_22798623_1": {"section_id": 6082, "quality": 0.7321428571428571, "length": 41}}, "n3337": {"so_22798558_22798623_0": {"section_id": 5850, "quality": 0.8043478260869565, "length": 37}, "so_22798558_22798623_1": {"section_id": 5850, "quality": 0.7321428571428571, "length": 41}}, "n4659": {"so_22798558_22798623_0": {"section_id": 7578, "quality": 0.7608695652173914, "length": 35}, "so_22798558_22798623_1": {"section_id": 7578, "quality": 0.625, "length": 35}}}, "22798677": {"ParentId": "22798558", "CommentCount": "12", "CreationDate": "2014-04-01T23:13:25.810", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "22798677", "Score": "17", "Body": "<blockquote>\n<p id=\"so_22798558_22798677_0\"><code>new</code> obviously doesn't create a const object (I hope).</p>\n</blockquote>\n<p>If you ask <code>new</code> to create a <code>const</code> object, you get a <code>const</code> object.</p>\n<blockquote>\n<p id=\"so_22798558_22798677_1\">there's no reason you can't <strong>legally</strong> <code>const_cast</code> the constness away and actually modify the object. </p>\n</blockquote>\n<p>There is. The reason is that the language specification calls that out explicitly as undefined behaviour. So, in a way, you <em>can</em>, but that means pretty much nothing.</p>\n<p>I don't know what you expected from this, but if you thought the issue was one of allocating in readonly memory or not, that's far from the point. That doesn't matter. A compiler can assume such an object can't change and optimise accordingly and you end up with unexpected results.</p>\n", "LastActivityDate": "2014-04-01T23:13:25.810"}, "22798623": {"ParentId": "22798558", "PostTypeId": "2", "CommentCount": "33", "CreationDate": "2014-04-01T23:08:38.613", "Score": "11", "LastEditorUserId": "560648", "LastEditDate": "2014-04-01T23:22:03.087", "Id": "22798623", "OwnerUserId": "560648", "Body": "<p><code>const</code> is part of the type. It doesn't matter whether you allocate your object with dynamic, static or automatic storage duration. It's still <code>const</code>. Casting away that <code>const</code>ness and mutating the object would still be an undefined operation.</p>\n<p><code>const</code>ness is an abstraction that the type system gives us to implement safety around non-mutable objects; it does so in large part to aid us in interaction with read-only memory, but that does not mean that its semantics are restricted to such memory. Indeed, C++ <em>doesn't even know</em> what is and isn't read-only memory.</p>\n<p>As well as this being derivable from all the usual rules, with no exception [lol] made for dynamically-allocated objects, the standards mention this explicitly (albeit in a note):</p>\n<blockquote>\n<p id=\"so_22798558_22798623_0\"><code>[C++03: 5.3.4/1]:</code> The <em>new-expression</em> attempts to create an object of the <em>type-id</em> (8.1) or <em>new-type-id</em> to which it is applied. The type of that object is the allocated type. This type shall be a complete object type, but not an abstract class type or array thereof (1.8, 3.9, 10.4). <em>[Note:</em> because references are not objects, references cannot be created by <em>new-expressions</em>. <em>] [Note:</em> <strong>the <em>type-id</em> may be a <em>cv-qualified</em> type, in which case the object created by the <em>new-expression</em> has a <em>cv-qualified</em> type.</strong> <em>] [..]</em></p>\n<p id=\"so_22798558_22798623_1\"><code>[C++11: 5.3.4/1]:</code> The <em>new-expression</em> attempts to create an object of the <em>type-id</em> (8.1) or <em>new-type-id</em> to which it is applied. The type of that object is the allocated type. This type shall be a complete object type, but not an abstract class type or array thereof (1.8, 3.9, 10.4). It is implementation-defined whether over-aligned types are supported (3.11). <em>[ Note:</em> because references are not objects, references cannot be created by <em>new-expressions</em>. <em>\u2014end note ] [ Note:</em> <strong>the <em>type-id</em> may be a <em>cv-qualified</em> type, in which case the object created by the <em>new-expression</em> has a <em>cv-qualified</em> type.</strong> <em>\u2014end note ] [..]</em></p>\n</blockquote>\n<p>There's also a usage example given in <code>[C++11: 7.1.6.1/4]</code>.</p>\n<p>Not sure what else you expected. I can't say I've ever done this myself, but I don't see any particular reason not to. There's probably some tech sociologist who can tell you statistics on how rarely we dynamically allocate something only to treat it as non-mutable.</p>\n", "LastActivityDate": "2014-04-01T23:22:03.087"}, "22888269": {"ParentId": "22798558", "CommentCount": "0", "CreationDate": "2014-04-05T23:39:34.103", "OwnerUserId": "1105562", "PostTypeId": "2", "Id": "22888269", "Score": "0", "Body": "<p>My way of looking at this is:</p>\n<ul>\n<li><code>X</code> and <code>const X</code> and pointers to them are distinct types</li>\n<li>there is an implicit conversion from <code>X*</code> to <code>const X*</code>, but not the other way around</li>\n<li><p>therefore the following are legal and the <code>x</code> in each case has identical type and behaviour</p>\n<p>const X* x = new X;\nconst X* x = new const X;</p></li>\n</ul>\n<p>The only remaining question is whether a different allocator might be called in the second case (perhaps in read only memory). The answer is no, there is no such provision in the standard.</p>\n", "LastActivityDate": "2014-04-05T23:39:34.103"}, "22798558": {"CommentCount": "5", "AcceptedAnswerId": "22798623", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-04-01T23:03:31.680", "LastActivityDate": "2014-04-05T23:39:34.103", "LastEditDate": "2017-05-23T11:57:07.140", "ViewCount": "650", "FavoriteCount": "5", "Title": "Is it legal to modify an object created with new through a const pointer?", "Id": "22798558", "Score": "15", "Body": "<p>So <a href=\"https://stackoverflow.com/a/22798293/673730\">this answer</a> made me think about the scenario where you assign the result of <code>new</code> to a pointer to a <code>const</code>. AFAIK, there's no reason you can't <strong>legally</strong> <code>const_cast</code> the constness away and actually modify the object in this situation:</p>\n<pre><code>struct X{int x;};\n\n//....\nconst X* x = new X;\nconst_cast&lt;X*&gt;(x)-&gt;x = 0; // okay\n</code></pre>\n<p>But then I thought - what if you actually want <code>new</code> to create a <code>const</code> object. So I tried</p>\n<pre><code>struct X{};\n\n//....\nconst X* x = new const X;\n</code></pre>\n<p>and it compiled!!!</p>\n<p>Is this a GCC extension or is it standard behavior? I have <strong>never</strong> seen this in practice. If it's standard, I'll start using it whenever possible.</p>\n", "Tags": "<c++><const><language-lawyer>", "OwnerUserId": "673730", "AnswerCount": "3"}});