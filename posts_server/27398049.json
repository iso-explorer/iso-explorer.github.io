post_cb({"bq_ids": {"n4140": {"so_27398049_27398497_2": {"section_id": 558, "quality": 0.92, "length": 23}, "so_27398049_27398497_4": {"section_id": 558, "quality": 0.975, "length": 39}, "so_27398049_27398497_0": {"section_id": 5400, "quality": 0.625, "length": 5}}, "n3337": {"so_27398049_27398497_2": {"section_id": 549, "quality": 0.92, "length": 23}, "so_27398049_27398497_4": {"section_id": 549, "quality": 0.975, "length": 39}, "so_27398049_27398497_0": {"section_id": 5195, "quality": 0.625, "length": 5}}, "n4659": {"so_27398049_27398497_2": {"section_id": 581, "quality": 0.92, "length": 23}, "so_27398049_27398497_4": {"section_id": 581, "quality": 0.975, "length": 39}, "so_27398049_27398497_0": {"section_id": 6825, "quality": 0.625, "length": 5}}}, "27398497": {"ParentId": "27398049", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_27398049_27398497_0\"><em>Why the line A's output is \"const\", even though A() is a object without const?</em></p>\n</blockquote>\n<p>The <code>A()</code> expression creates a prvalue temporary that cannot be bound by a non-const lvalue reference, thus <code>void f (const A&amp; a)</code> is the only viable overload.</p>\n<blockquote>\n<p id=\"so_27398049_27398497_1\"><em>I am still very curious that is it very well defined in c++ specification ?</em></p>\n</blockquote>\n<p>\u00a713.1 [over.load]/p3:</p>\n<blockquote>\n<p id=\"so_27398049_27398497_2\">\u2014 Parameter declarations that differ only in the presence or absence of <code>const</code> and/or <code>volatile</code> are\n  equivalent. That is, the <code>const</code> and <code>volatile</code> type-specifiers for each parameter type are ignored when\n  determining which function is being declared, defined, or called. [ <em>Example</em>:</p>\n<pre><code>typedef const int cInt;\nint f (int);\nint f (const int);           // redeclaration of f(int)\nint f (int) { /* ... */ }    // definition of f(int)\nint f (cInt) { /* ... */ }   // error: redefinition of f(int)\n</code></pre>\n<p id=\"so_27398049_27398497_3\">\u2014 <em>end example</em> ]</p>\n<p id=\"so_27398049_27398497_4\">Only the <code>const</code> and <code>volatile</code> type-specifiers at the outermost level of the parameter type specification are ignored in this fashion; <code>const</code> and <code>volatile</code> type-specifiers buried within a parameter type specification are significant and can be used to distinguish overloaded function declarations. In particular, for any type <code>T</code>, \u201cpointer to <code>T</code>,\u201d \u201cpointer to <code>const T</code>,\u201d and \u201cpointer to <code>volatile T</code>\u201d are considered distinct parameter types, as are \u201creference to T,\u201d \u201creference to <code>const T</code>,\u201d and \u201creference to <code>volatile T</code>.\u201d</p>\n</blockquote>\n<p>For parameters of type <code>A</code> and <code>const A</code> the same conversion sequence applies when initialized by any argument convertible to <code>A</code>, the compiler would never be able to choose between the two.</p>\n<p>For parameters of type <code>A&amp;</code> and <code>const A&amp;</code> there can be different expressions so that the compiler can choose a better conversion sequence or exclude any candidate from the set of candidates.</p>\n", "OwnerUserId": "3953764", "PostTypeId": "2", "Id": "27398497", "Score": "5", "CreationDate": "2014-12-10T10:20:39.737", "LastActivityDate": "2014-12-10T10:20:39.737"}, "27398049": {"CommentCount": "0", "AcceptedAnswerId": "27398497", "PostTypeId": "1", "LastEditorUserId": "4127047", "CreationDate": "2014-12-10T10:01:09.547", "LastActivityDate": "2015-08-12T10:22:41.420", "LastEditDate": "2014-12-10T10:20:42.600", "ViewCount": "196", "FavoriteCount": "1", "Title": "Overloading a function with otherwise identical signatures to accept both a reference and a const reference", "Id": "27398049", "Score": "1", "Body": "<p>The codes are below :</p>\n<pre><code>struct A {};   \n\nvoid f (A&amp; a) {std::cout &lt;&lt; \"No const\" &lt;&lt; std::endl;} \n\nvoid f (const A&amp; a) {std::cout &lt;&lt; \"const\" &lt;&lt; std::endl;} \n\nint main(){\n   f(A()); // indicated as line A, output will be \"const\".\n}\n</code></pre>\n<p>Question 1):</p>\n<p>Why is line <code>A</code>'s output \"const\", even though <code>A()</code> is a non-const object ?</p>\n<p>I reckon the compiler produces code equivalent to :</p>\n<pre><code>const A tempA;\nf(tempA); \n</code></pre>\n<p>Is that right ?</p>\n<p>Question 2), if the two f functions are modified as below, changing reference to value type</p>\n<pre><code>void f (A a) {std::cout &lt;&lt; \"No const\" &lt;&lt; std::endl;} \n\nvoid f (const A a) {std::cout &lt;&lt; \"const\" &lt;&lt; std::endl;}  \n</code></pre>\n<p>These above codes are not able to be compiled. The compiler gives out \"redefinition of function f\" errors. I can understand why the error was given out by the compiler, because it is possible to convert <code>const A</code> to <code>A</code> and vice-versa. Thus there is no way to decide at compile-time. Is that right ?</p>\n<p>I am still very curious that is it very well defined in c++ specification ?</p>\n", "Tags": "<c++><reference><const><overloading>", "OwnerUserId": "4127047", "AnswerCount": "3"}, "27398514": {"ParentId": "27398049", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>In your first case :</p>\n<p><code>A()</code> creates a temporary, which is passed to your function. Temporaries can only bind to <code>const</code> lvalue references by specification. Thus, your <code>const</code> overload is chosen.</p>\n<p>Note that a Visual C++ extension allows non-const lvalue references to bind to temporaries. This is non-standard, and is enabled by default, so beware. I do not know what overload would be chosen in that case.</p>\n<p>In your second case :</p>\n<p>The <code>const</code> qualifier of a function parameter qualifies the parameter itself, not the object that is its argument. Thus the only difference between your two functions is the <code>const</code>ness of your parameter <em>inside</em> the function.<br>\nIn cases such as your first one, where the parameter is a pointer or a reference to a possibly const object, conversion and binding rules make a single overload viable (or preferable) for later function calls.<br>\nIn that second case however, nothing qualifies your argument, so both overloads are undistinguishable by design (no later call can be unambiguous), hence the \"multiple definitions\" error.</br></br></p>\n", "OwnerUserId": "3233393", "LastEditorUserId": "560648", "LastEditDate": "2014-12-10T13:08:25.653", "Id": "27398514", "Score": "2", "CreationDate": "2014-12-10T10:21:30.023", "LastActivityDate": "2014-12-10T13:08:25.653"}, "27398466": {"ParentId": "27398049", "CommentCount": "1", "Body": "<p>You're creating a temporary object to pass to function here f(A()); The constructed object is only used in function. Temporaries are always const. This will work if you construct objects outside of the function call. Ex.</p>\n<pre><code>A nonConstA;\nf(nonConstA); //Will print \"No const\"\n\nconst A constA;\nf(constA); //Will print \"const\"\n</code></pre>\n", "OwnerUserId": "368202", "PostTypeId": "2", "Id": "27398466", "Score": "0", "CreationDate": "2014-12-10T10:19:27.247", "LastActivityDate": "2014-12-10T10:19:27.247"}});