post_cb({"6086912": {"CommentCount": "12", "AcceptedAnswerId": "6088010", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2011-05-22T08:48:01.093", "LastActivityDate": "2012-10-21T19:59:31.550", "LastEditDate": "2011-12-18T22:31:23.217", "ViewCount": "9198", "FavoriteCount": "20", "Title": "Double-Checked Lock Singleton in C++11", "Id": "6086912", "Score": "42", "Body": "<p>Is the following singleton implementation data-race free?</p>\n<pre><code>static std::atomic&lt;Tp *&gt; m_instance;\n...\n\nstatic Tp &amp;\ninstance()\n{\n    if (!m_instance.load(std::memory_order_relaxed))\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);\n        if (!m_instance.load(std::memory_order_acquire))\n        {\n            Tp * i = new Tp;\n            m_instance.store(i, std::memory_order_release);    \n        }    \n    }\n\n    return * m_instance.load(std::memory_order_relaxed);\n}\n</code></pre>\n<p>Is the <code>std::memory_model_acquire</code> of the load operation superfluous? Is it possible to further relax both load and store operations by switching them to <code>std::memory_order_relaxed</code>? In that case, is the acquire/release semantic of <code>std::mutex</code> enough to guarantee its correctness, or a further <code>std::atomic_thread_fence(std::memory_order_release)</code> is also required to ensure that the writes to memory of the constructor happen before the relaxed store? Yet, is the use of fence equivalent to have the store with <code>memory_order_release</code>?</p>\n<p><strong>EDIT</strong>: Thanks to the answer of John, I came up with the following implementation that should be data-race free. Even though the inner load could be non-atomic at all, I decided to leave a relaxed load in that it does not affect the performance. In comparison to always have an outer load with the acquire memory order, the thread_local machinery improves the performance of accessing the instance of about an order of magnitude.</p>\n<pre><code>static Tp &amp;\ninstance()\n{\n    static thread_local Tp *instance;\n\n    if (!instance &amp;&amp; \n        !(instance = m_instance.load(std::memory_order_acquire)))\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);\n        if (!(instance = m_instance.load(std::memory_order_relaxed)))\n        {\n            instance = new Tp; \n            m_instance.store(instance, std::memory_order_release);    \n        }    \n    }\n    return *instance;\n}\n</code></pre>\n", "Tags": "<c++><multithreading><c++11><atomic>", "OwnerUserId": "19630", "AnswerCount": "3"}, "8202925": {"ParentId": "6086912", "CommentCount": "0", "Body": "<p>See also <a href=\"http://en.cppreference.com/w/cpp/thread/call_once\">call_once</a>. \nWhere you'd previously use a singleton to do something, but not actually use the returned object for anything, call_once may be the better solution.\nFor a regular singleton you <em>could</em> do call_once to set a (global?) variable and then return that variable...</p>\n<p>Simplified for brevity:</p>\n<pre><code>template&lt; class Function, class... Args&gt;\nvoid call_once( std::once_flag&amp; flag, Function&amp;&amp; f, Args&amp;&amp; args...);\n</code></pre>\n<ul>\n<li><p>Exactly one execution of exactly one of the functions, passed as f to the invocations in the group <em>(same flag object)</em>, is performed. </p></li>\n<li><p>No invocation in the group returns before the abovementioned execution of the selected function is completed successfully</p></li>\n</ul>\n", "OwnerUserId": "147749", "PostTypeId": "2", "Id": "8202925", "Score": "7", "CreationDate": "2011-11-20T16:31:29.320", "LastActivityDate": "2011-11-20T16:31:29.320"}, "6088010": {"ParentId": "6086912", "CommentCount": "3", "Body": "<p>That implementation is <strong>not</strong> race-free. The atomic store of the singleton, while it uses release semantics, will only synchronize with the matching acquire operation\u2014that is, the load operation that is already guarded by the mutex.</p>\n<p>It's possible that the outer relaxed load would read a non-null pointer before the locking thread finished initializing the singleton.</p>\n<p>The acquire that is guarded by the lock, on the other hand, is redundant. It will synchronize with any store with release semantics on another thread, but at that point (thanks to the mutex) the only thread that can possibly store is the current thread. That load doesn't even need to be atomic\u2014no stores can happen from another thread.</p>\n<p>See <a href=\"http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html\" rel=\"noreferrer\">Anthony Williams' series on C++0x multithreading</a>.</p>\n", "OwnerUserId": "5696", "PostTypeId": "2", "Id": "6088010", "Score": "20", "CreationDate": "2011-05-22T12:43:11.693", "LastActivityDate": "2011-05-22T12:43:11.693"}, "bq_ids": {"n4140": {"so_6086912_6099828_0": {"section_id": 3919, "quality": 1.0, "length": 13}}, "n3337": {"so_6086912_6099828_0": {"section_id": 3779, "quality": 1.0, "length": 13}}, "n4659": {"so_6086912_6099828_0": {"section_id": 4805, "quality": 1.0, "length": 13}}}, "6099828": {"ParentId": "6086912", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I think this a great question and John Calsbeek has the correct answer.</p>\n<p>However, just to be clear a lazy singleton is best implemented using the classic Meyers singleton.  It has garanteed correct semantics in C++11.</p>\n<p>\u00a7 6.7.4</p>\n<blockquote>\n<p id=\"so_6086912_6099828_0\">...  If control enters\n  the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for\n  completion of the initialization. ...</p>\n</blockquote>\n<p>The Meyer's singleton is preferred in that the compiler can aggressively optimize the concurrent code.  The compiler would be more restricted if it had to preserve the semantics of a <code>std::mutex</code>.  Furthermore, the Meyer's singleton is <strong><em>2 lines</em></strong> and virtually impossible to get wrong.</p>\n<p>Here is a classic example of a Meyer's singleton.  Simple, elegant, and broken in c++03.  But simple, elegant, and powerful in c++11.</p>\n<pre><code>class Foo\n{\npublic:\n   static Foo&amp; instance( void )\n   {\n      static Foo s_instance;\n      return s_instance;\n   }\n};\n</code></pre>\n", "OwnerUserId": "28817", "LastEditorUserId": "28817", "LastEditDate": "2011-05-25T21:27:10.107", "Id": "6099828", "Score": "26", "CreationDate": "2011-05-23T16:04:41.060", "LastActivityDate": "2011-05-25T21:27:10.107"}});