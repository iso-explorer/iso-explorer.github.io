post_cb({"47616002": {"ViewCount": "65", "Body": "<p>How can one safely compare an integral value, of unknown type, to a strongly typed enum, when it's possible that the integral value may not be within the range of enumeration values?</p>\n<p>The most obvious way to compare an integral value to an enum would be to cast the integral value, <code>a</code>, to the enum type, <code>E</code>, and compare to the enumeration value <code>b</code>, like this:</p>\n<pre><code>template &lt;typename I, typename E&gt;\nbool compare(I a, E b) { return static_cast&lt;E&gt;(a) == b; }\n</code></pre>\n<p>However, if <code>a</code> is not in the range of enumeration values, this leads to unspecified behavior, per [expr.static.cast]/10:</p>\n<blockquote>\n<p id=\"so_47616002_47616002_0\">A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the <strong>resulting value is unspecified</strong> (and might not be in that range).</p>\n</blockquote>\n<p>This can be seen in the resulting failure (<code>compare</code> as above):</p>\n<pre><code>enum E : uint8_t { A = 0 };\ncompare(256, E::A); // returns true, 256 == E::A, but E::A = 0\n</code></pre>\n<p>One could instead cast the enum to the integral type, but this can lead to incorrect results if the integral type can not represent all the enum values:</p>\n<pre><code>enum E : int { A = 256 };\ntemplate &lt;typename I, typename E&gt;\nbool compare(I a, E b) { return a == static_cast&lt;I&gt;(b); }\ncompare((uint8_t)0); // returns true, 0 == E::A, but E:A = 256\n</code></pre>\n", "Title": "Safely compare integer to strongly typed enum", "CreationDate": "2017-12-03T06:45:52.830", "LastActivityDate": "2017-12-03T21:05:12.670", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-03T21:05:12.670", "LastEditorUserId": "1934800", "Id": "47616002", "Score": "3", "OwnerUserId": "1934800", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47616002_47616002_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6036}}, "n3337": {"so_47616002_47616002_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 5804}}, "n4659": {"so_47616002_47616002_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7535}}}, "47616003": {"Id": "47616003", "PostTypeId": "2", "Body": "<p>The enum can be cast to its underlying integral type, which is guaranteed to be able to represent all of the enumeration's values.</p>\n<pre><code>template &lt;typename I, typename E&gt;\nbool compare(I a, E b) { return a == static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(b); }\n</code></pre>\n<p>There's still a possible issue with the <em>usual arithmetic conversions</em> if the integral type and the enumeration type differ in signededness.</p>\n<pre><code>enum class : int32_t { A = -1 };\ncompare(4294967295u, E3::A); // returns true\n</code></pre>\n<p>Here, <code>E::A</code> = <code>(int32_t)-1</code> is converted to <code>unsigned int</code>, which can not represent -1, converting it to (most likely) 4294967295.</p>\n<p>This conversion, of an integer to another integral type which can not represent its value, can only happen if one type is unsigned and the other has a negative value (and thus must be of signed type).  Since an unsigned value and a negative value cannot possibly be equal, we can tell the result of the comparison without needing to compare the exact values.</p>\n<pre><code>template &lt;typename I, typename E&gt;\nbool compare(I a, E b) {\n    using UTE = std::underlying_type_t&lt;E&gt;; \n    return !(std::is_unsigned_v&lt;I&gt; &amp;&amp; static_cast&lt;UTE&gt;(b) &lt; 0) &amp;&amp;\n           !(std::is_unsigned_v&lt;UTE&gt; &amp;&amp; a &lt; 0) &amp;&amp;\n           a == static_cast&lt;UTE&gt;(b);\n}\n</code></pre>\n<p>This will correctly catch the cases were a negative value would be converted to an unsigned value that could then match the other operand.  Since the compiler knows the types at compile time, it can optimize the sign check expression to nothing, <code>a&lt;0</code>, or <code>b&lt;0</code> as appropriate for the types of <code>a</code> and <code>b</code>.</p>\n", "LastActivityDate": "2017-12-03T06:45:52.830", "CommentCount": "0", "CreationDate": "2017-12-03T06:45:52.830", "ParentId": "47616002", "Score": "8", "OwnerUserId": "1934800"}});