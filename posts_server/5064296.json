post_cb({"5064937": {"ParentId": "5064296", "CommentCount": "0", "Body": "<p><code>T a(x)</code> is <em>direct initialization</em> and <code>T a = x</code> is <em>copy initialization</em>.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_5064296_5064937_0\">8.5.11  The form of initialization (using parentheses or =) is generally insignificant, but does matter when the entity being initialized has a class type; see below. A parenthesized initializer can be a list of expressions only when the entity being initialized has a class type.</p>\n<p id=\"so_5064296_5064937_1\">8.5.12  The initialization that occurs in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and brace-enclosed initializer lists (8.5.1) is called copy-initialization and is equivalent to the form</p>\n<pre><code>   T x = a;\n</code></pre>\n<p id=\"so_5064296_5064937_2\">The initialization that occurs in new expressions (5.3.4), static_cast expressions (5.2.9), functional notation type conversions (5.2.3), and base and member initializers (12.6.2) is called direct-initialization and is equivalent to the form</p>\n<pre><code>    T x(a);\n</code></pre>\n</blockquote>\n<p>The difference is that copy initialization creates a temporary object which is then used to direct-initialize. The compiler is allowed to avoid creating the temporary object:</p>\n<blockquote>\n<p id=\"so_5064296_5064937_3\">8.5.14 ... The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization. In certain cases, an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</p>\n</blockquote>\n<p>Copy initialization requires a non-explicit constructor and a copy constructor to be available. </p>\n", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "5064937", "Score": "2", "CreationDate": "2011-02-21T10:40:47.703", "LastActivityDate": "2011-02-21T10:40:47.703"}, "5064548": {"ParentId": "5064296", "CommentCount": "3", "Body": "<p>Yes. If the type of x is not <code>T</code>, then the second example expands to <code>T a = T(x)</code>. This requires that <code>T(T const&amp;)</code> is public. The first example doesn't invoke the copy constructor.</p>\n<p>After the accessibility has been checked, the copy can be eliminated (as Tony pointed out). However, it cannot be eliminated <em>before</em> checking accessibility.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "5064548", "Score": "3", "CreationDate": "2011-02-21T10:00:41.370", "LastActivityDate": "2011-02-21T10:00:41.370"}, "5064623": {"ParentId": "5064296", "CommentCount": "0", "Body": "<p>In C++, when you write this:</p>\n<pre><code>class A {\n  public:\n  A() { ... }\n};\n</code></pre>\n<p>The compiler actually generates this, depending on what your code uses:</p>\n<pre><code>class A {\n  public:\n  A() { ... }\n  ~A() { ... }\n  A(const A&amp; other) {...}\n  A&amp; operator=(const A&amp; other) { ... }\n};\n</code></pre>\n<p>So now you can see the different semantics of the various constructors.</p>\n<pre><code>A a1; // default constructor\nA a2(a1); // copy constructor\na2 = a1; // copy assignment operator\n</code></pre>\n<p>The copy constructors basically copy all the non-static data. They are only generated if the resulting code is legal and sane: if the compiler sees types inside the class that he doesn't know how to copy (per normal assignment rules), then the copy constructor won't get generated. This means that if the T type doesn't support constructors, or if one of the public fields of the class is const or a reference type, for instance, the generator won't create them - and the code won't build. Templates are expanded at build time, so if the resulting code isn't buildable, it'll fail. And sometimes it fails loudly and very cryptically.</p>\n<p>If you define a constructor (or destructor) in a class, the generator won't generate a default one. This means you can override the default generated constructors. You can make them private (they're public by default), you can override them so they do nothing (useful for saving memory and avoiding side-effects), etc.</p>\n", "OwnerUserId": "170511", "PostTypeId": "2", "Id": "5064623", "Score": "0", "CreationDate": "2011-02-21T10:10:00.907", "LastActivityDate": "2011-02-21T10:10:00.907"}, "5064470": {"ParentId": "5064296", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>From 8.5.14 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_5064296_5064470_0\">The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the destination type. The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization. In certain cases, <strong>an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly</strong> into the object being initialized; see class.temporary, class.copy.</p>\n</blockquote>\n<p>So, whether they're equivalent is left to the implementation.</p>\n<p>8.5.11 is also relevant, but only in confirming that there <em>can</em> be a difference:</p>\n<blockquote>\n<p id=\"so_5064296_5064470_1\">-11- The form of initialization (using parentheses or =) is generally insignificant, but does matter when the entity being initialized has a class type; see below. A parenthesized initializer can be a list of expressions only when the entity being initialized has a class type. </p>\n</blockquote>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2011-02-21T10:01:51.763", "Id": "5064470", "Score": "2", "CreationDate": "2011-02-21T09:53:00.983", "LastActivityDate": "2011-02-21T10:01:51.763"}, "5064296": {"CommentCount": "0", "ViewCount": "380", "PostTypeId": "1", "LastEditorUserId": "167958", "CreationDate": "2011-02-21T09:34:20.507", "LastActivityDate": "2011-02-21T10:40:47.703", "Title": "Do these two C++ initializer syntaxes ever differ in semantics?", "FavoriteCount": "3", "LastEditDate": "2011-02-21T09:50:31.717", "Id": "5064296", "Score": "6", "Body": "<p>Assume that the following code is legal code that compiles properly, that <code>T</code> is a type name, and that <code>x</code> is the name of a variable.</p>\n<p>Syntax one:</p>\n<pre><code>T a(x);\n</code></pre>\n<p>Syntax two:</p>\n<pre><code>T a = x;\n</code></pre>\n<p>Do the exact semantics of these two expressions ever differ? If so, under what circumstances?</p>\n<p>If these two expressions ever do have different semantics I'm also really curious about which part of the standard talks about this.</p>\n<p>Also, if there is a special case when T is the name of a scalar type (aka, <code>int</code>, <code>long</code>, <code>double</code>, etc...), what are the differences when T is a scalar type vs. a non-scalar type?</p>\n", "Tags": "<c++><language-features><initializer><language-lawyer>", "OwnerUserId": "167958", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_5064296_5064937_0": {"section_id": 3293, "quality": 0.7333333333333333, "length": 22}, "so_5064296_5064937_3": {"section_id": 3296, "quality": 0.8823529411764706, "length": 30}, "so_5064296_5064937_2": {"section_id": 3295, "quality": 0.6818181818181818, "length": 15}, "so_5064296_5064470_1": {"section_id": 3293, "quality": 0.7586206896551724, "length": 22}, "so_5064296_5064470_0": {"section_id": 3296, "quality": 0.9166666666666666, "length": 44}}, "n3337": {"so_5064296_5064470_1": {"section_id": 3163, "quality": 0.7586206896551724, "length": 22}, "so_5064296_5064937_2": {"section_id": 3165, "quality": 0.6818181818181818, "length": 15}, "so_5064296_5064937_3": {"section_id": 3166, "quality": 0.8823529411764706, "length": 30}, "so_5064296_5064470_0": {"section_id": 3166, "quality": 0.9166666666666666, "length": 44}, "so_5064296_5064937_0": {"section_id": 3163, "quality": 0.7333333333333333, "length": 22}}, "n4659": {"so_5064296_5064470_0": {"section_id": 4058, "quality": 0.5208333333333334, "length": 25}}}, "5064553": {"ParentId": "5064296", "CommentCount": "5", "Body": "<p>The difference here is between implicit and explicit construction, and there can be difference.</p>\n<p>Imagine having a type <code>Array</code> with the constructor <code>Array(size_t length)</code>, and that somewhere else, you have a function <code>count_elements(const Array&amp; array)</code>. The purpose of these are easily understandable, and the code seems readable enough, until you realise it will allow you to call <code>count_elements(2000)</code>. This is not only ugly code, but will also allocate an array 2000 elements long in memory for no reason.</p>\n<p>In addition, you may have other types that are implicitly castable to an integer, allowing you to run count_elements() on those too, giving you completely useless results at a high cost to efficiency.</p>\n<p>What you want to do here, is declare the <code>Array(size_t length)</code> an <em>explicit</em> constructor. This will disable the implicit conversions, and <code>Array a = 2000</code> will no longer be legal syntax.</p>\n<p>This was only one example. Once you realise what the <code>explicit</code> keyword does, it is easy to dream up others.</p>\n", "OwnerUserId": "44680", "PostTypeId": "2", "Id": "5064553", "Score": "2", "CreationDate": "2011-02-21T10:01:25.417", "LastActivityDate": "2011-02-21T10:01:25.417"}});