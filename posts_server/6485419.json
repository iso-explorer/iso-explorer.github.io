post_cb({"bq_ids": {"n4140": {"so_6485419_6485521_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5444}}, "n3337": {"so_6485419_6485521_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5239}}, "n4659": {"so_6485419_6485521_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 6871}}}, "6485419": {"ViewCount": "153", "Body": "<p>But of course we shouldn't even think of doing such things, I know, but still this is quite interesting:</p>\n<pre><code>class A; //declaration\nstruct A {...}; //definition\n\nstruct B; //declaration\nclass B {...}; //definition\n</code></pre>\n<p>When I think about it, I don't see any problems if such a thing were really allowed(because struct and class are essentially the same thing). But is it (standard-wise)?</p>\n<p>MSVC accepts and compiles it, with a warning.</p>\n", "AcceptedAnswerId": "6485521", "Title": "declaring a class with struct keyword and vice versa", "CreationDate": "2011-06-26T17:12:39.907", "Id": "6485419", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-06-29T18:14:01.187", "Score": "4", "OwnerUserId": "469935", "Tags": "<c++><class><struct><declaration>", "AnswerCount": "2"}, "6485514": {"Id": "6485514", "PostTypeId": "2", "Body": "<p>As per <strong><em>C++03 Standard 9.1 - 2</em></strong></p>\n<p><em>\"A class definition introduces the class name into the scope where it is defined and hides any class, object, function, or other declaration of that name in an enclosing scope (3.3).\"</em> </p>\n<p>So it is valid as per the standard.  </p>\n<p>Playing around a bit with the example code: </p>\n<pre><code>#include&lt;iostream&gt;\n\nclass A; //declaration \nstruct A { int i;}; //definition  \nstruct B; //declaration \nclass B {int j;}; //definition \n\nint main()\n{\n    A obj;\n    obj.i = 10;\n    B obj2;\n    obj2.j = 10;\n    std::cout&lt;&lt;\"sizeof\"&lt;&lt;sizeof(struct B);\n    return 0;\n}\n</code></pre>\n<p>Here is the output:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:6: error: \u2018int B::j\u2019 is private\nprog.cpp:13: error: within this context\n</code></pre>\n<p>The only difference between C++ struct &amp; class is that default access specifier for structure is public while for class it is private.</p>\n<p>So, From the above example:<br>\nIn this case compiler treats <code>A</code> as a <code>structure</code> &amp;<br>\n<code>B</code> as a <code>class</code></br></br></p>\n<p>As you see, the compiler follows the quote from the standard and the type with the definition is what the compiler recognizes, over the declaration type.   </p>\n", "LastEditorUserId": "452307", "LastActivityDate": "2011-06-29T06:33:30.150", "Score": "5", "CreationDate": "2011-06-26T17:27:08.047", "ParentId": "6485419", "CommentCount": "8", "OwnerUserId": "452307", "LastEditDate": "2011-06-29T06:33:30.150"}, "6485521": {"Id": "6485521", "PostTypeId": "2", "Body": "<p>It is allowed according to the standard, but as some compilers warn about it, it is not very useful.</p>\n<p>I believe the warning is/was caused by MSVC using a different name mangling for structs and classes, which would make it even less useful...</p>\n<hr>\n<p>On request from @Armen:</p>\n<p>7.1.5.3 Elaborated type specifiers, p3</p>\n<blockquote>\n<p id=\"so_6485419_6485521_0\">... in any <em>elaborated-type-specifier</em>, the <code>enum</code> keyword shall be used to refer to an enumeration (7.2), the <code>union</code> <em>class-key</em> shall be used to refer to a union (clause 9), and either the <code>class</code> or <code>struct</code> <em>class-key</em> shall be used to refer to a class (clause 9), declared using the <code>class</code> or <code>struct</code> <em>class-key</em>.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "597607", "LastActivityDate": "2011-06-29T15:02:26.373", "Score": "8", "CreationDate": "2011-06-26T17:27:36.080", "ParentId": "6485419", "CommentCount": "2", "OwnerUserId": "597607", "LastEditDate": "2011-06-29T15:02:26.373"}});