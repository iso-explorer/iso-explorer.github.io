post_cb({"21415723": {"ParentId": "21415606", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-01-28T20:06:50.193", "Score": "6", "LastEditorUserId": "1708801", "LastEditDate": "2014-01-28T20:22:52.723", "Id": "21415723", "OwnerUserId": "1708801", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">C++ draft standard</a> section <code>4.12</code> <em>Boolean conversions</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_21415606_21415723_0\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. <strong>A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true.</strong> For direct-initialization (8.5), a prvalue of type std::nullptr_t can be converted to a prvalue of type bool; the resulting value is false.</p>\n</blockquote>\n<p>So any non-zero value will be converted to <code>true</code>.</p>\n<p>You expressed some doubts as to the result of <code>1 &lt;&lt; 4</code> we have a quick way to check this using <a href=\"http://en.cppreference.com/w/cpp/utility/bitset/bitset\" rel=\"nofollow\">std::bitset</a>:</p>\n<pre><code>#include &lt;bitset&gt;\n#include &lt;iostream&gt;\n\nint main() \n{\n    std::bitset&lt;8&gt; b1(1&lt;&lt;4);\n\n    std::cout &lt;&lt; b1 &lt;&lt; std::endl ;\n\n    return 0;\n}\n</code></pre>\n<p>and we can see the result is indeed <code>00010000</code> since <a href=\"http://en.wikipedia.org/wiki/Bitwise_operations_in_C#Bitwise_AND_.22.26.22\" rel=\"nofollow\">bitwise and</a> only set a bit to <code>1</code> if the bit in both operands are <code>1</code> then the result of <code>flag &amp; (1 &lt;&lt; 4)</code> will only be <em>non-zero</em> if bit <code>5</code> of <code>flag</code> is also <code>1</code>.</p>\n", "LastActivityDate": "2014-01-28T20:22:52.723"}, "21415886": {"ParentId": "21415606", "CommentCount": "0", "CreationDate": "2014-01-28T20:16:56.340", "OwnerUserId": "1502345", "PostTypeId": "2", "Id": "21415886", "Score": "2", "Body": "<p>The <code>&amp;</code> operator performs a bitwise boolean AND operation. That means that a bit is set in the final output if, and only if, it is set in both inputs, so for example</p>\n<pre><code>  00011100\n&amp; 01010101\n  --------\n= 00010100\n\n  11010101\n&amp; 01010101\n  --------\n= 01010101\n</code></pre>\n<p>So, if you use a mask that has only a single bit set it will return 0 if that bit is not set, and non-zero if it is set, e.g.</p>\n<pre><code>  11110111\n&amp; 00001000\n  --------\n= 00000000\n\n  00001111\n&amp; 00001000\n  --------\n= 00001000\n</code></pre>\n<p>Then, since C++ will convert treat any non-zero value as true when converting to a <code>bool</code> and zero as false the function works.</p>\n", "LastActivityDate": "2014-01-28T20:16:56.340"}, "21415606": {"CommentCount": "5", "AcceptedAnswerId": "21415723", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-01-28T20:01:11.623", "LastActivityDate": "2014-01-28T20:47:59.627", "LastEditDate": "2014-01-28T20:47:59.627", "ViewCount": "291", "FavoriteCount": "1", "Title": "How does it work \"checking bit flag\"", "Id": "21415606", "Score": "3", "Body": "<p>I've read other questions about this, but they don't answer my question.</p>\n<p>In the following code I understand that it checks if that bit is set, but my question is why?</p>\n<pre><code>bool test(uint8_t&amp; flag)\n{\n   return flag &amp; (1 &lt;&lt; 4);\n}\n</code></pre>\n<p>I don't get why it returns a <code>bool</code> and it works, flag is <code>uint8_t</code> and <code>1 &lt;&lt; 4</code> should be something like this <code>00010000</code> (I think). Why does that code return the value of the desired single bit and not the rightmost or something like that?</p>\n", "Tags": "<c++><bit-manipulation><bit-shift>", "OwnerUserId": "1036958", "AnswerCount": "4"}, "21415746": {"ParentId": "21415606", "CommentCount": "0", "CreationDate": "2014-01-28T20:08:18.913", "OwnerUserId": "391531", "PostTypeId": "2", "Id": "21415746", "Score": "0", "Body": "<p>Since this is also tagged C, C99 has this to say:</p>\n<blockquote>\n<p id=\"so_21415606_21415746_0\">6.3.1.2 Boolean type</p>\n<p id=\"so_21415606_21415746_1\">1 When any scalar value is converted to _Bool, the result is 0 if the value compares equal to 0; otherwise, the result is 1.</p>\n</blockquote>\n", "LastActivityDate": "2014-01-28T20:08:18.913"}, "bq_ids": {"n4140": {"so_21415606_21415632_0": {"section_id": 44, "quality": 0.5384615384615384, "length": 7}, "so_21415606_21415723_0": {"section_id": 44, "quality": 0.975609756097561, "length": 40}}, "n3337": {"so_21415606_21415632_0": {"section_id": 41, "quality": 0.5384615384615384, "length": 7}, "so_21415606_21415723_0": {"section_id": 41, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_21415606_21415723_0": {"section_id": 45, "quality": 0.975609756097561, "length": 40}, "so_21415606_21415632_0": {"section_id": 45, "quality": 0.5384615384615384, "length": 7}}}, "21415632": {"ParentId": "21415606", "CommentCount": "2", "CreationDate": "2014-01-28T20:02:24.667", "OwnerUserId": "878307", "PostTypeId": "2", "Id": "21415632", "Score": "3", "Body": "<p>An <code>int</code> can be converted to a <code>bool</code>. If its value is zero, the converted value ist <code>false</code>, otherwise it is <code>true</code>.\nCheck it out yorself:</p>\n<pre><code>bool f = 0;\nbool t = 5;\n</code></pre>\n<blockquote>\n<p id=\"so_21415606_21415632_0\">Prvalues of integral, floating-point, unscoped enumeration, pointer, and pointer-to-member types can be converted to prvalues of type bool.</p>\n<p id=\"so_21415606_21415632_1\">The value zero (for integral, floating-point, and unscoped enumeration) and the null pointer and the null pointer-to-member values become false. All other values become true.</p>\n</blockquote>\n<p>See: <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast#Boolean_conversions\" rel=\"nofollow\">cppreference</a></p>\n", "LastActivityDate": "2014-01-28T20:02:24.667"}});