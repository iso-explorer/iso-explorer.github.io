post_cb({"44078027": {"Id": "44078027", "PostTypeId": "2", "Body": "<p>It should also note that lambda is convertible to function pointer. However typeid&lt;&gt; returns a non-trvial object which should differ from lambda to generic function pointer. So the test for typeid&lt;&gt; is not a valid assumption. In general C++11 do not want us to worry about type specification, all that matter if a given type is convertible to a target type.</p>\n", "LastActivityDate": "2017-05-19T19:51:07.823", "Score": "0", "CreationDate": "2017-05-19T19:51:07.823", "ParentId": "7951377", "CommentCount": "0", "OwnerUserId": "3230612"}, "7951377": {"ViewCount": "16360", "Body": "<p>I had a perception that, type of a lambda is a function pointer. When I performed following test, I found it to be wrong (<a href=\"http://ideone.com/5ZRRsA\">demo</a>).</p>\n<pre><code>#define LAMBDA [] (int i) -&gt; long { return 0; }\nint main ()\n{\n  long (*pFptr)(int) = LAMBDA;  // ok\n  auto pAuto = LAMBDA;  // ok\n  assert(typeid(pFptr) == typeid(pAuto));  // assertion fails !\n}\n</code></pre>\n<p>Is above code missing any point ? If not then, what is the <code>typeof</code> a lambda expression when deduced with <code>auto</code> keyword ?</p>\n", "AcceptedAnswerId": "7951438", "Title": "What is the type of lambda when deduced with \"auto\" in C++11?", "CreationDate": "2011-10-31T08:36:51.487", "Id": "7951377", "CommentCount": "5", "FavoriteCount": "25", "PostTypeId": "1", "LastEditDate": "2015-09-19T13:34:19.420", "LastEditorUserId": "1673293", "LastActivityDate": "2017-05-19T19:51:07.823", "Score": "87", "OwnerUserId": "514235", "Tags": "<c++><lambda><c++11><typeof><auto>", "AnswerCount": "6"}, "7951438": {"Id": "7951438", "PostTypeId": "2", "Body": "<p>The type of a lambda expression is unspecified. </p>\n<p>But they are generally mere syntactic sugar for functors. A lambda is translated directly into a functor. Anything inside the <code>[]</code> are turned into constructor parameters and members of the functor object, and the parameters inside <code>()</code> are turned into parameters for the functor's <code>operator()</code>.</p>\n<p>A lambda which captures no variables (nothing inside the <code>[]</code>'s) <em>can be converted</em> into a function pointer (MSVC2010 doesn't support this, if that's your compiler, but this conversion is part of the standard).</p>\n<p>But the actual type of the lambda isn't a function pointer. It's some unspecified functor type.</p>\n", "LastActivityDate": "2011-10-31T08:43:34.033", "Score": "95", "CreationDate": "2011-10-31T08:43:34.033", "ParentId": "7951377", "CommentCount": "2", "OwnerUserId": "33213"}, "bq_ids": {"n4140": {"so_7951377_20825525_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 5964}, "so_7951377_20825525_2": {"length": 38, "quality": 0.9047619047619048, "section_id": 5965}, "so_7951377_20825525_0": {"length": 33, "quality": 0.825, "section_id": 5962}}, "n3337": {"so_7951377_20825525_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 5733}, "so_7951377_20825525_2": {"length": 38, "quality": 0.9047619047619048, "section_id": 5734}, "so_7951377_20825525_0": {"length": 33, "quality": 0.825, "section_id": 5731}}, "n4659": {"so_7951377_20825525_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 7453}, "so_7951377_20825525_2": {"length": 34, "quality": 0.8095238095238095, "section_id": 7456}}}, "20825525": {"Id": "20825525", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7951377_20825525_0\"><code>[C++11: 5.1.2/3]:</code> <strong>The type of the <em>lambda-expression</em></strong> (which is also the type of the closure object) <strong>is a unique, unnamed non-union class type</strong> \u2014 called the <em>closure type</em> \u2014 whose properties are described below. This class type is not an aggregate (8.5.1). The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding <em>lambda-expression</em>. <em>[..]</em></p>\n</blockquote>\n<p>The clause goes on to list varying properties of this type. Here are some highlights:</p>\n<blockquote>\n<p id=\"so_7951377_20825525_1\"><code>[C++11: 5.1.2/5]:</code> The closure type for a <em>lambda-expression</em> has a public <code>inline</code> function call operator (13.5.4) whose parameters and return type are described by the <em>lambda-expression</em>\u2019s <em>parameter-declaration-clause</em> and <em>trailing-return-type</em> respectively. <em>[..]</em></p>\n<p id=\"so_7951377_20825525_2\"><code>[C++11: 5.1.2/6]:</code> The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>The consequence of this final passage is that, if you used a conversion, you would be able to assign <code>LAMBDA</code> to <code>pFptr</code>.</p>\n", "LastActivityDate": "2013-12-29T13:15:10.973", "Score": "12", "CreationDate": "2013-12-29T13:15:10.973", "ParentId": "7951377", "CommentCount": "0", "OwnerUserId": "560648"}, "7951476": {"Id": "7951476", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\n#define LAMBDA [] (int i)-&gt;long { return 0l; }\nint main ()\n{\n  long (*pFptr)(int) = LAMBDA;  // ok\n  auto pAuto = LAMBDA;  // ok\n\n  std::cout&lt;&lt;typeid( *pAuto ).name() &lt;&lt; std::endl;\n  std::cout&lt;&lt;typeid( *pFptr ).name() &lt;&lt; std::endl;\n\n  std::cout&lt;&lt;typeid( pAuto ).name() &lt;&lt; std::endl;\n  std::cout&lt;&lt;typeid( pFptr ).name() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The function types are indeed same, but the lambda introduces new type (like a functor).</p>\n", "LastActivityDate": "2011-10-31T08:49:53.713", "Score": "0", "CreationDate": "2011-10-31T08:49:53.713", "ParentId": "7951377", "CommentCount": "0", "OwnerUserId": "476681"}, "7951443": {"Id": "7951443", "PostTypeId": "2", "Body": "<p>It is a unique unnamed structure that overloads the function call operator. Every instance of a lambda introduces a new type.</p>\n<p>In the special case of a non-capturing lambda, the structure in addition has an implicit conversion to a function pointer.</p>\n", "LastActivityDate": "2011-10-31T08:44:12.323", "Score": "73", "CreationDate": "2011-10-31T08:44:12.323", "ParentId": "7951377", "CommentCount": "5", "OwnerUserId": "89847"}, "8050769": {"Id": "8050769", "PostTypeId": "2", "Body": "<p>A practical solution from <a href=\"https://stackoverflow.com/questions/7757096/how-can-i-store-a-boostbind-object-as-a-class-member\">How can I store a boost::bind object as a class member?</a>, try <code>boost::function&lt;void(int)&gt;</code> or <code>std::function&lt;void(int)&gt;</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-11-08T13:01:09.740", "Score": "1", "CreationDate": "2011-11-08T13:01:09.740", "ParentId": "7951377", "CommentCount": "1", "LastEditDate": "2017-05-23T11:33:24.620", "OwnerUserId": "231306"}});