post_cb({"8287227": {"ParentId": "8287188", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2011-11-27T16:54:45.963", "Score": "18", "LastEditorUserId": "415784", "LastEditDate": "2015-11-12T16:13:23.750", "Id": "8287227", "OwnerUserId": "415784", "Body": "<p>The expression<code>std::ostringstream()</code> creates a temporary, and <code>operator&lt;&lt;</code> which takes <code>const char*</code> as argument is a free function, but this free function cannot be called on a temporary, as the type of the first parameter of the function is <code>std::ostream&amp;</code> which cannot be bound to temporary object.</p>\n<p>Having said that, <code>&lt;&lt;std::ostringstream() &lt;&lt; \"some data\"</code> resolves to a call to a member function which is overloaded for <code>void*</code> which prints the address. Note that a member function can be invoked on the temporary.</p>\n<p>In order to call the free function, you need to convert temporary (which is rvalue) into a lvalue, and here is one trick that you can do:</p>\n<pre><code> std::cout &lt;&lt; \"Inline        : \"\n            &lt;&lt; dynamic_cast&lt;std::ostringstream&amp;&gt;(\n                 std::ostringstream().flush() &lt;&lt; \"some data\"\n               ).str()\n            &lt;&lt; \"\\n\";\n</code></pre>\n<p>That is, <code>std::ostringstream().flush()</code> returns <code>std::ostream&amp;</code> which means, now the free function can called, passing the returned reference as first argument. </p>\n<p>Also, you don't need to use <code>dynamic_cast</code> here (which is slow, as it is done at runtime), for the type of the object is pretty much known, and so you can use <code>static_cast</code> (which is fast as it is done at compile-time):</p>\n<pre><code> std::cout &lt;&lt; \"Inline        : \"\n            &lt;&lt; static_cast&lt;std::ostringstream&amp;&gt;(\n                 std::ostringstream().flush() &lt;&lt; \"some data\"\n               ).str()\n            &lt;&lt; \"\\n\";\n</code></pre>\n<p>which should work just fine.</p>\n", "LastActivityDate": "2015-11-12T16:13:23.750"}, "8287231": {"ParentId": "8287188", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2011-11-27T16:55:37.267", "Score": "9", "LastEditorUserId": "464581", "LastEditDate": "2011-11-27T17:05:36.177", "Id": "8287231", "OwnerUserId": "464581", "Body": "<p>A temporary cannot bind to a reference to non-const formal argument.</p>\n<p>Therefore, the non-member <code>&lt;&lt;</code> is not picked up.</p>\n<p>You get the <code>void*</code> version instead.</p>\n<p>C++11 fixes this by adding a non-member <strong>rvalue stream inserter</strong> function,</p>\n<blockquote>\n<p id=\"so_8287188_8287231_0\"><strong>C++11</strong><br>\n<strong>\u00a727.7.3.9 Rvalue stream insertion</strong><br>\n  [ostream.rvalue]<br>\n<code>template &lt;class charT, class traits, class T&gt;<br>\n  basic_ostream&lt;charT, traits&gt;&amp;<br>\n  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);</br></br></code><br>\n  1 <em>Effects:</em> <code>os &lt;&lt; x</code><br>\n  2 <em>Returns:</em> <code>os</code></br></br></br></br></br></p>\n</blockquote>\n<p>Cheers &amp; hth.</p>\n", "LastActivityDate": "2011-11-27T17:05:36.177"}, "8287188": {"CommentCount": "0", "AcceptedAnswerId": "8287227", "CreationDate": "2011-11-27T16:48:57.640", "LastActivityDate": "2015-11-12T16:13:23.750", "PostTypeId": "1", "ViewCount": "5396", "FavoriteCount": "0", "Title": "std::ostringstream printing the address of the c-string instead of its content", "Id": "8287188", "Score": "17", "Body": "<p>I have stumbled on a weird behavior that I just could not explain at first (see <a href=\"http://ideone.com/DSPmM\">ideone</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nint main() {\n  std::cout &lt;&lt; \"Reference     : \"\n            &lt;&lt; (void const*)\"some data\"\n            &lt;&lt; \"\\n\";\n\n  std::ostringstream s;\n  s &lt;&lt; \"some data\";\n  std::cout &lt;&lt; \"Regular Syntax: \" &lt;&lt; s.str() &lt;&lt; \"\\n\";\n\n  std::ostringstream s2;\n  std::cout &lt;&lt; \"Semi inline   : \"\n            &lt;&lt; static_cast&lt;std::ostringstream&amp;&gt;(s2 &lt;&lt; \"some data\").str()\n            &lt;&lt; \"\\n\";\n\n  std::cout &lt;&lt; \"Inline        : \"\n            &lt;&lt; dynamic_cast&lt;std::ostringstream&amp;&gt;(\n                 std::ostringstream() &lt;&lt; \"some data\"\n               ).str()\n            &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Gives the output:</p>\n<pre><code>Reference     : 0x804a03d\nRegular Syntax: some data\nSemi inline   : some data\nInline        : 0x804a03d\n</code></pre>\n<p>Surprisingly, in the last cast we have the address, and not the content!</p>\n<p>Why is that so ?</p>\n", "Tags": "<c++><stream>", "OwnerUserId": "147192", "AnswerCount": "3"}, "8287234": {"ParentId": "8287188", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-11-27T16:56:14.700", "Score": "2", "LastEditorUserId": "147192", "LastEditDate": "2011-11-27T17:01:42.353", "Id": "8287234", "OwnerUserId": "147192", "Body": "<p>To get the started, the simplest solution is to get the list of possible overloads that the compiler considered, for example <a href=\"http://ideone.com/0DKfc\" rel=\"nofollow\">trying</a> this:</p>\n<pre><code>X x;\nstd::cout &lt;&lt; x &lt;&lt; \"\\n\";\n</code></pre>\n<p>where <code>X</code> is a type without any overload for streaming which yields the following list of possible overloads:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:21: error: no match for \u2018operator&lt;&lt;\u2019 in \u2018std::cout &lt;&lt; x\u2019\ninclude/ostream:112: note: candidates are: std::ostream&amp; std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))\ninclude/ostream:121: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(std::basic_ios&lt;_CharT, _Traits&gt;&amp; (*)(std::basic_ios&lt;_CharT, _Traits&gt;&amp;))\ninclude/ostream:131: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(std::ios_base&amp; (*)(std::ios_base&amp;))\ninclude/ostream:169: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(long int)\ninclude/ostream:173: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(long unsigned int)\ninclude/ostream:177: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(bool)\ninclude/bits/ostream.tcc:97: note:         std::ostream&amp; std::ostream::operator&lt;&lt;(short int)\ninclude/ostream:184: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(short unsigned int)\ninclude/bits/ostream.tcc:111: note:        std::ostream&amp; std::ostream::operator&lt;&lt;(int)\ninclude/ostream:195: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(unsigned int)\ninclude/ostream:204: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(long long int)\ninclude/ostream:208: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(long long unsigned int)\ninclude/ostream:213: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(double)\ninclude/ostream:217: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(float)\ninclude/ostream:225: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(long double)\ninclude/ostream:229: note:                 std::ostream&amp; std::ostream::operator&lt;&lt;(const void*)\ninclude/bits/ostream.tcc:125: note:        std::ostream&amp; std::ostream::operator&lt;&lt;(std::basic_streambuf&lt;_CharT, _Traits&gt;*)\n</code></pre>\n<p>First scanning this list, we can remark that <code>char const*</code> is conspiscuously absent, and therefore it is logical that <code>void const*</code> will be selected instead and thus the address printed.</p>\n<p>On a second glance, we note that all overloads are <em>methods</em>, and that not a single free function appears here.</p>\n<p>The issue is a problem of reference binding: because a temporary cannot bind to a reference to non-const, overloads of the form <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;,X)</code> are rejected outright and only member functions remain.</p>\n<p>It is, as far as I am concerned, a design bug in C++, after all we are executing a mutating member function on a temporary, and this requires a (hidden) reference to the object :x</p>\n<p>The workaround, once you understood what went awry, <a href=\"http://ideone.com/1Ar56\" rel=\"nofollow\">is relatively simple</a> and only requires a small wrapper:</p>\n<pre><code>struct Streamliner {\n  template &lt;typename T&gt;\n  Streamliner&amp; operator&lt;&lt;(T const&amp; t) {\n    _stream &lt;&lt; t;\n    return *this;\n  }\n\n  std::string str() const { return _stream.str(); }\n  std::ostringstream _stream;\n};\n\nstd::cout &lt;&lt; \"Inline, take 2: \" &lt;&lt; (Streamliner() &lt;&lt; \"some data\").str() &lt;&lt; \"\\n\";\n</code></pre>\n<p>Which prints the expected result.</p>\n", "LastActivityDate": "2011-11-27T17:01:42.353"}, "bq_ids": {"n4140": {"so_8287188_8287231_0": {"section_id": 4183, "quality": 0.5263157894736842, "length": 10}}, "n3337": {"so_8287188_8287231_0": {"section_id": 4026, "quality": 0.5263157894736842, "length": 10}}, "n4659": {"so_8287188_8287231_0": {"section_id": 3353, "quality": 0.5263157894736842, "length": 10}}}});