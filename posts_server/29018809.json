post_cb({"29018810": {"ParentId": "29018809", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Before C++14 this case was ill-formed and the more general case with some exceptions was also ill-formed. This is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1512\" rel=\"nofollow\">defect report 1512: Pointer comparison vs qualification conversions </a>, which says:</p>\n<blockquote>\n<p id=\"so_29018809_29018810_0\">According to 5.9 [expr.rel] paragraph 2, describing pointer\n  comparisons,</p>\n<blockquote>\n<p id=\"so_29018809_29018810_4\">Pointer conversions (4.10 [conv.ptr]) and qualification conversions (4.4 [conv.qual]) are performed on pointer operands (or on\n    a pointer operand and a null pointer constant, or on two null pointer\n    constants, at least one of which is non-integral) to bring them to\n    their composite pointer type. </p>\n</blockquote>\n<p id=\"so_29018809_29018810_2\">This would appear to make the following example ill-formed,</p>\n<pre><code>bool foo(int** x, const int** y) {\n   return x &lt; y;  // valid ?\n}\n</code></pre>\n<p id=\"so_29018809_29018810_3\">because int** cannot be converted to const int**, according to the\n  rules of 4.4 [conv.qual] paragraph 4. This seems too strict for\n  pointer comparison, and current implementations accept the example.</p>\n</blockquote>\n<p>The defect report points out although this was ill-formed, implementations accepted such comparisons. This <a href=\"http://llvm.org/klaus/clang/commit/b2cb1cbd727469e1567a6f2535895e6b64e12c35/\" rel=\"nofollow\">clang commit</a> indicates it was treated as an extension and indicates both <code>gcc</code> and <code>EDG</code> also treats this as an extension, presumably this is also the case for Visual Studio. </p>\n<p>This was resolved in the standard by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3624.html\" rel=\"nofollow\">N3624: Core Issue 1512: Pointer comparison vs qualification conversions</a>, which says:</p>\n<blockquote>\n<p id=\"so_29018809_29018810_5\">This paper presents the modifications to the Working Draft necessary\n  to resolve core issues 583 and 1512. In particular, it makes</p>\n<p id=\"so_29018809_29018810_6\">[...]</p>\n<p id=\"so_29018809_29018810_7\">and</p>\n<pre><code>void g(int **p1, const int**p2)\n{\n   if (p1 == p2) { ... }\n}\n</code></pre>\n<p id=\"so_29018809_29018810_8\">well-formed.</p>\n</blockquote>\n<p>Also note that in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3622.pdf\" rel=\"nofollow\">meeting it was accepted</a> it was noted that this just codified existing practice.</p>\n<p>Amongst other changes to the standard, this paragraph was added to the end of section <code>5</code> <em>[expr]</em>, which includes the new term <em>cv-combined type</em>:</p>\n<blockquote>\n<p id=\"so_29018809_29018810_9\">The cv-combined type of two types T1 and T2 is a type T3 similar to T1\n  whose cv-qualification signature (4.4) is:</p>\n<ul>\n<li>for every j &gt; 0, cv3,j is the union of cv1,j and cv2,j ;</li>\n<li>if the resulting cv3,j is different from cv1,j or cv2,j , then const is added to every cv3,k for 0 &lt; k &lt; j.</li>\n</ul>\n<p id=\"so_29018809_29018810_10\">[ Note: Given similar types T1\n  and T2, this construction ensures that both can be converted to T3.\n  \u2014end note ] The composite pointer type of two operands p1 and p2\n  having types T1 and T2, respectively, where at least one is a pointer\n  or pointer to member type or std::nullptr_t, is:</p>\n<ul>\n<li>if both p1 and p2 are null pointer constants, std::nullptr_t;</li>\n<li>if either p1 or p2 is a null pointer constant, T2 or T1, respectively;</li>\n<li>if T1 or T2 is \u201cpointer to cv1 void\u201d and the other type is \u201cpointer to cv2 T\u201d, \u201cpointer to cv12 void\u201d, where cv12 is the union of cv1 and\n  cv2 ;</li>\n<li>if T1 is \u201cpointer to cv1 C1\u201d and T2 is \u201cpointer to cv2 C2\u201d, where C1 is reference-related to C2 or C2 is reference-related to C1 (8.5.3),\n  the cv-combined type of T1 and T2 or the cv-combined type of T2 and\n  T1, respectively;</li>\n<li>if T1 is \u201cpointer to member of C1 of type cv1 U1\u201d and T2 is \u201cpointer to member of C2 of type cv2 U2\u201d where C1 is reference-related to C2 or\n  C2 is reference-related to C1 (8.5.3), the cv-combined type of T2 and\n  T1 or the cv-combined type of T1 and T2, respectively;</li>\n<li>if T1 and T2 are similar multi-level mixed pointer and pointer to member types (4.4), the cv-combined type of T1 and T2;</li>\n<li>otherwise, a program that necessitates the determination of a composite pointer type is ill-formed. </li>\n</ul>\n<p id=\"so_29018809_29018810_11\">[ Example:</p>\n<pre><code>    typedef void *p;\n    typedef const int *q;\n    typedef int **pi;\n    typedef const int **pci;\n</code></pre>\n<p id=\"so_29018809_29018810_12\">The composite pointer type of p and q is \u201cpointer to const void\u201d; the\n  composite pointer type of pi and pci is \u201cpointer to const pointer to\n  const int\u201d. \u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-12-14T03:53:20.027", "Id": "29018810", "Score": "24", "CreationDate": "2015-03-12T19:39:22.720", "LastActivityDate": "2015-12-14T03:53:20.027"}, "29018809": {"CommentCount": "4", "ViewCount": "1225", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-03-12T19:39:22.720", "LastActivityDate": "2015-12-14T03:53:20.027", "Title": "Given int **p1 and const int**p2 is p1 == p2 well formed?", "FavoriteCount": "3", "LastEditDate": "2015-03-14T16:24:53.310", "Id": "29018809", "Score": "33", "Body": "<p>Given the following function:</p>\n<pre><code>void g(int **p1, const int**p2)\n{\n   if (p1 == p2) { }  \n}\n</code></pre>\n<p><code>clang</code>(<em>back to version 3.0</em>) produces this warning (<em><a href=\"http://melpon.org/wandbox/permlink/lCtOd2FagxDI9n2T\">see it live</a></em>):</p>\n<pre><code>warning: comparison of distinct pointer types ('int **' and 'const int **')\nuses non-standard composite pointer type 'const int *const *' \n[-Wcompare-distinct-pointer-types]\n  if (p1 == p2) { }\n      ~~ ^ ~~\n</code></pre>\n<p>Using <code>-pedantic-errors</code> flags turns it into an error. Neither <code>gcc</code>(<em>back to 4.3.6</em>) nor <code>Visual Studio</code>(<em>2013</em>) produce a warning, according to the standard, is the comparison:</p>\n<pre><code>p1 == p2\n</code></pre>\n<p>well formed?</p>\n<p>More generally, if two multi-level pointers differ in their <em>cv-qualifications</em> other than at the first level is comparison via the equality operator or relational operators well-formed?</p>\n", "Tags": "<c++><c++11><language-lawyer><c++14>", "OwnerUserId": "1708801", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29018809_29018810_10": {"section_id": 5946, "quality": 0.8214285714285714, "length": 23}, "so_29018809_29018810_12": {"section_id": 5946, "quality": 0.8333333333333334, "length": 15}, "so_29018809_29018810_9": {"section_id": 5946, "quality": 0.8, "length": 8}}, "n3337": {"so_29018809_29018810_12": {"section_id": 14, "quality": 0.6111111111111112, "length": 11}, "so_29018809_29018810_1": {"section_id": 5913, "quality": 0.8928571428571429, "length": 25}, "so_29018809_29018810_4": {"section_id": 5913, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_29018809_29018810_10": {"section_id": 7432, "quality": 0.5357142857142857, "length": 15}, "so_29018809_29018810_2": {"section_id": 4018, "quality": 0.5714285714285714, "length": 4}, "so_29018809_29018810_12": {"section_id": 7432, "quality": 0.8333333333333334, "length": 15}, "so_29018809_29018810_9": {"section_id": 7431, "quality": 0.7, "length": 7}}}});