post_cb({"15624322": {"ParentId": "15624145", "CommentCount": "0", "Body": "<p>Assuming you can construct a <code>ShadeRec</code> from a <code>World</code> without modifying the passed-in <code>World</code>, you need a ShadeRec constructor like this:</p>\n<pre><code> ShadeRec(const World&amp; world);\n</code></pre>\n", "OwnerUserId": "1761845", "PostTypeId": "2", "Id": "15624322", "Score": "0", "CreationDate": "2013-03-25T20:39:45.263", "LastActivityDate": "2013-03-25T20:39:45.263"}, "15624145": {"CommentCount": "2", "ViewCount": "135", "PostTypeId": "1", "LastEditorUserId": "1168156", "CreationDate": "2013-03-25T20:29:05.073", "LastActivityDate": "2013-03-25T20:51:02.953", "Title": "Using *this to initialize a reference", "AcceptedAnswerId": "15624190", "LastEditDate": "2013-03-25T20:47:33.317", "Id": "15624145", "Score": "0", "Body": "<p>I'm trying to initialize an instance of my class <code>ShadeRec</code> with its constructor:</p>\n<pre><code>ShadeRec(World&amp; world);\n</code></pre>\n<p>So I pass to it:</p>\n<pre><code>ShadeRec sr(*this);\n</code></pre>\n<p>where \"this\" is an instance of the class World.</p>\n<p>I get the following error:</p>\n<pre><code>World.cpp: In member function \u2018ShadeRec World::hitObjects(const Ray&amp;) const\u2019:\nWorld.cpp:52: error: no matching function for call to \u2018ShadeRec::ShadeRec(const World&amp;)\u2019\nShadeRec.h:17: note: candidates are: ShadeRec::ShadeRec(const ShadeRec&amp;)\nShadeRec.h:15: note:                 ShadeRec::ShadeRec(World&amp;)\n</code></pre>\n<p>Assuming the problem is just that the World instance has the attribute <code>const</code>, how can I get rid of this error message?</p>\n", "Tags": "<c++><pointers><reference><constructor><argument-passing>", "OwnerUserId": "746963", "AnswerCount": "4"}, "15624200": {"ParentId": "15624145", "CommentCount": "1", "Body": "<p>There is a difference between a <code>const</code> reference and a non-constant.  </p>\n<p>The compiler doesn't want to pass a constant object to a method that takes a non-constant (mutable) object.  That would violate interface agreements:  being able to modify a constant object.  </p>\n<p>This situation may arise from a constant object calling mutable functions or a constant method calling mutable method. </p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "15624200", "Score": "0", "CreationDate": "2013-03-25T20:32:34.227", "LastActivityDate": "2013-03-25T20:32:34.227"}, "15624203": {"ParentId": "15624145", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Type of <code>this</code> pointer within the <code>const</code> member function of a <code>class World</code> is <code>const World*</code>, which means that you can't use it to initialize a non-const reference (you can't just \"drop\" its <em>constness</em>).</p>\n<p>Change the type of the argument of <code>ShadeRec</code>'s constructor to <code>const World&amp;</code>:</p>\n<pre><code>ShadeRec(const World&amp; world);\n</code></pre>\n\nSee C++03, 9.3.2 \u00a71:\n\n<blockquote>\n<p id=\"so_15624145_15624203_0\">The type of <code>this</code> in a member function of a <code>class X</code> is <code>X*</code>. If the member function is declared <code>const</code>, the type of <code>this</code> is <code>const X*</code></p>\n</blockquote>\n", "OwnerUserId": "1168156", "LastEditorUserId": "1168156", "LastEditDate": "2013-03-25T20:51:02.953", "Id": "15624203", "Score": "0", "CreationDate": "2013-03-25T20:32:41.617", "LastActivityDate": "2013-03-25T20:51:02.953"}, "bq_ids": {"n4140": {"so_15624145_15624203_0": {"section_id": 5895, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_15624145_15624203_0": {"section_id": 5666, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_15624145_15624203_0": {"section_id": 7378, "quality": 0.9090909090909091, "length": 10}}}, "15624190": {"ParentId": "15624145", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You're doing this in the <code>hitObjects</code> member function which is marked as <code>const</code>. Think of it this way: that member function is promising not to modify the <code>*this</code> object. However, it's happily passing it to a different object by non-<code>const</code> reference. What if that other object modified it? Uh oh!</p>\n<p>There are two possible solutions that depend on the problem. Does the <code>ShadeRec</code> constructor actually modify the passed <code>World</code> object?</p>\n<ol>\n<li><p>If it does, you should make sure <code>hitObjects</code> is not marked as <code>const</code>. After all, that would be lying.</p></li>\n<li><p>If not, it should take it by <code>const World&amp;</code>. Then it's okay for <code>hitObjects</code>, which is marked <code>const</code>, to pass <code>*this</code> to it.</p></li>\n</ol>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-03-25T20:44:00.223", "Id": "15624190", "Score": "7", "CreationDate": "2013-03-25T20:31:59.697", "LastActivityDate": "2013-03-25T20:44:00.223"}});