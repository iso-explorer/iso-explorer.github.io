post_cb({"36451214": {"ParentId": "36450983", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-04-06T12:28:57.780", "Score": "6", "LastEditorUserId": "819272", "LastEditDate": "2016-04-06T13:02:55.317", "Id": "36451214", "OwnerUserId": "819272", "Body": "<p>Because the second overload will drop the top-level <code>const</code> inside the <code>const T</code>, it will resolve to <code>T*</code> during argument deduction. The first overload is a worse match because it will resolve to <code>S&lt;int, char&gt; const*</code>, which requires a const-qualification conversion. </p>\n<p>You need to add <code>const</code> in front of your variable <code>s</code> in order for the more specialized overload to kick in: </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class A, class B&gt;\nstruct S {};\n\ntemplate&lt;class A, class B&gt;\nconstexpr bool isS(const S&lt;A,B&gt;*) {return true;}\n\n//template&lt;class T&gt;\n//constexpr bool isS(const T*) {return false;}\n\ntemplate&lt;class T&gt;\nconstexpr bool isS(const T) {return false;}\n\nint main() {\n  S&lt;int,char&gt; const s{}; // add const here\n  std::cout&lt;&lt;isS(&amp;s)&lt;&lt;std::endl;\n  return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/0084fca85778bc41\" rel=\"nofollow\"><strong>Live Example</strong></a></p>\n<p>Changing the first overload to a <code>const S&lt;A,B&gt;&amp;</code>, will give the correct result because there is an identity conversion instead of a qualification adjustment.</p>\n<blockquote>\n<p id=\"so_36450983_36451214_0\"><strong>13.3.3.1.4 Reference binding [over.ics.ref]</strong> </p>\n<p id=\"so_36450983_36451214_1\">1 When a parameter of reference type binds directly (8.5.3) to an argument expression, the\n  implicit conversion sequence is the identity conversion, unless the\n  argument expression has a type that is a derived class of the\n  parameter type, in which case the implicit conversion sequence is a\n  derived-to-base Conversion (13.3.3.1).</p>\n</blockquote>\n<p><strong>Note</strong>: when in doubt about such argument deduction games, it's handy to use the <code>__PRETTY_FUNCTION__</code> macro which (on gcc/clang) will give you more information about the deduced types of the selected template. You can then comment out certain overloads to see how this affects the overload resolution. See this <a href=\"http://coliru.stacked-crooked.com/a/575c38233768f65c\" rel=\"nofollow\"><strong>live example</strong></a>.</p>\n", "LastActivityDate": "2016-04-06T13:02:55.317"}, "36451223": {"ParentId": "36450983", "CommentCount": "3", "CreationDate": "2016-04-06T12:29:22.797", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "36451223", "Score": "3", "Body": "<p>Your second version doesn't give the answer you expect because the first version of <code>isS</code> requires an implicit conversion, whereas the second does not.</p>\n<pre><code>template&lt;class A, class B&gt;\nconstexpr bool isS(const S&lt;A,B&gt;*);\n\ntemplate&lt;class T&gt;\nconstexpr bool isS(const T);\n\nS&lt;int,char&gt; s;\nisS(&amp;s);\n</code></pre>\n<p>Note that <code>&amp;s</code> is of type <code>S&lt;int,char&gt;*</code>. The first <code>isS</code> is looking for a <code>const S&lt;int,char&gt;*</code>, so the pointer needs a conversion. The second <code>isS</code> is a direct match.</p>\n<hr>\n<p>If you find yourself needing this pattern often, you could generalize it, like so:</p>\n<pre><code>template&lt;template&lt;typename...&gt; class TT, typename T&gt;\nstruct is_specialization_of : std::false_type {};\n\ntemplate&lt;template&lt;typename...&gt; class TT, typename... Ts&gt;\nstruct is_specialization_of&lt;TT, TT&lt;Ts...&gt;&gt; : std::true_type {};\n</code></pre>\n<p>Then you check if a type is a specialization of <code>S</code> like this:</p>\n<pre><code>is_specialization_of&lt;S, decltype(s)&gt;::value\n</code></pre>\n</hr>", "LastActivityDate": "2016-04-06T12:29:22.797"}, "bq_ids": {"n4140": {"so_36450983_36451214_1": {"section_id": 625, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_36450983_36451214_1": {"section_id": 615, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_36450983_36451214_1": {"section_id": 651, "quality": 0.9285714285714286, "length": 26}}}, "36450983": {"CommentCount": "4", "AcceptedAnswerId": "36451214", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-04-06T12:20:05.237", "LastActivityDate": "2016-04-06T14:53:43.340", "LastEditDate": "2017-05-23T11:59:41.393", "ViewCount": "320", "FavoriteCount": "1", "Title": "Function template overload resolution with a pointer argument", "Id": "36450983", "Score": "5", "Body": "<p>The following code demonstrates the core of a C++ template metaprogramming pattern I have been using to determine whether a type <code>T</code> is an instantiation of a specific class template:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class A, class B&gt;\nstruct S{};\n\ntemplate&lt;class A, class B&gt;\nconstexpr bool isS(const S&lt;A,B&gt;*) {return true;}\n\ntemplate&lt;class T&gt;\nconstexpr bool isS(const T*) {return false;}\n\nint main() {\n  S&lt;int,char&gt; s;\n  std::cout&lt;&lt;isS(&amp;s)&lt;&lt;std::endl;\n  return 0;\n}\n</code></pre>\n<p>It features two overloads of a <code>constexpr</code> function template <code>isS</code>, and it outputs <code>1</code>, as expected. If I remove the pointer from the second <code>isS</code>, i.e. replace it with</p>\n<pre><code>template&lt;class T&gt;\nconstexpr bool isS(const T) {return false;}\n</code></pre>\n<p>the program unexpectedly outputs <code>0</code>. If both versions of <code>isS</code> make it through to the overload resolution phase of compilation, then the output implies that the compiler is choosing the second overload. I have tested this under GCC, Clang and vc++ using the online compilers <a href=\"http://rextester.com/l/cpp_online_compiler_visual\" rel=\"nofollow noreferrer\">here</a>, and they all produce the same result. Why does this happen? </p>\n<p>I have read Herb Sutter's <a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow noreferrer\">\"Why Not Specialize Function Templates\"</a> article several times, and it seems that both <code>isS</code> functions should be considered to be base templates. If this is so, then it is a question of which one is the most specialised. Going by intuition and <a href=\"https://stackoverflow.com/a/4435618/1292784\">this answer</a>, I would expect the first <code>isS</code> to be the most specialised, because <code>T</code> can match every instantiation of <code>S&lt;A,B&gt;*</code>, and there are many possible instantiations of <code>T</code> that cannot match <code>S&lt;A,B&gt;*</code>. I'd like to locate the paragraph in the working draft that defines this behaviour, but I'm not entirely sure what phase of compilation is causing the problem. Is it something to do with <em>\"14.8.2.4 Deducing template arguments during partial ordering\"</em>?</p>\n<p>This issue is particularly surprising given that the following code, in which the first <code>isS</code> takes a reference to <code>const S&lt;A,B&gt;</code> and the second takes a <code>const T</code>, outputs the expected value <code>1</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class A, class B&gt;\nstruct S{};\n\ntemplate&lt;class A, class B&gt;\nconstexpr bool isS(const S&lt;A,B&gt;&amp;) {return true;}\n\ntemplate&lt;class T&gt;\nconstexpr bool isS(const T) {return false;}\n\nint main() {\n  S&lt;int,char&gt; s;\n  std::cout&lt;&lt;isS(s)&lt;&lt;std::endl;\n  return 0;\n}\n</code></pre>\n<p>So the problem seems to be something to do with how pointers are treated.</p>\n", "Tags": "<c++><pointers><overload-resolution><function-templates><argument-deduction>", "OwnerUserId": "1292784", "AnswerCount": "2"}});