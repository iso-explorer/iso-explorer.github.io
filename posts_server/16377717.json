post_cb({"16377717": {"CommentCount": "1", "ViewCount": "52", "CreationDate": "2013-05-04T18:43:07.917", "LastActivityDate": "2013-05-04T19:02:23.780", "Title": "Why would the compiler use a virtual call for `datum::rotate()` below?", "PostTypeId": "1", "Id": "16377717", "Score": "0", "Body": "<p>On page 26 of \"Inside the C++ Object Module\" by S. Lippman, you'll find the following snippet:</p>\n<pre><code>void rotate(\nX datum,\nconst X *pointer,\nconst X &amp;reference )\n{\n    // cannot determine until run-time\n    // actual instance of rotate() invoked\n    (*pointer).rotate();\n    reference.rotate();\n    // always invokes X::rotate()\n    datum.rotate();\n}\nmain() {\n    Z z; // a subtype of X\n    rotate( z, &amp;z, z );\n    return 0;\n}\n</code></pre>\n<p>and this paragraph:</p>\n<p><code>The two invocations through pointer and reference are resolved dynamically. In this example, they both\ninvoke Z::rotate(). The invocation through datum may or may not be invoked through the virtual\nmechanism; however, it will always invoke X::rotate().</code></p>\n<p>AFAIK, <code>datum.rotate()</code> will always be invoked with a static call. Why would the compiler use a virtual call here? </p>\n", "Tags": "<c++><polymorphism>", "OwnerUserId": "1042389", "AnswerCount": "1"}, "16377777": {"ParentId": "16377717", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-05-04T18:49:24.620", "Score": "0", "LastEditorUserId": "1919155", "LastEditDate": "2013-05-04T19:02:23.780", "Id": "16377777", "OwnerUserId": "1919155", "Body": "<p>The compiler MAY choose to use a virtual call even though doing so is not necessary. The standard does not say that the compiler \"MUST\" convert it to a static call. As long as the \"right\" function is called, the compiler has done it's job. </p>\n<p>Edit: It would appear that the standard (at least n3337) doesn't say exactly how the compiler is supposed to be called - it basically just says that </p>\n<blockquote>\n<p id=\"so_16377717_16377777_0\">Note: The interpretation of the call of a virtual function depends on the type of the object for which it is\n  called (the dynamic type), whereas the interpretation of a call of a non-virtual member function depends\n  only on the type of the pointer or reference denoting that object (the static type) (5.2.2). \u2014 end note </p>\n</blockquote>\n", "LastActivityDate": "2013-05-04T19:02:23.780"}, "bq_ids": {"n4140": {"so_16377717_16377777_0": {"section_id": 7010, "quality": 0.8275862068965517, "length": 24}}, "n3337": {"so_16377717_16377777_0": {"section_id": 6756, "quality": 0.8275862068965517, "length": 24}}, "n4659": {"so_16377717_16377777_0": {"section_id": 8507, "quality": 0.8275862068965517, "length": 24}}}});