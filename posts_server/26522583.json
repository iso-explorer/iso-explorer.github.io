post_cb({"26552052": {"ParentId": "26522583", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Once I did face this problem while reading CSV comma delimited file. But we can use <code>strtok()</code> as our solution in such problem were delimited character appears consecutively. Because according to the standard </p>\n<blockquote>\n<p id=\"so_26522583_26552052_0\">The first call in  the  sequence  searches  the  string\n      pointed  to  by <code>s1</code> for  the  first  character  that is <em>not</em>\n      contained in the current separator string pointed to by  <code>s2</code>.\n      If  no  such character is found, then there are no tokens in\n      the string pointed to by <code>s1</code> and the <code>strtok</code> function  returns\n      a  null  pointer.   If  such a character is found, it is the\n      start of the first token.  C11 \u00a77.24.5.8 3</p>\n</blockquote>\n<p>So, for my case I did define another solution using strpbrk() function which will also useful for you.</p>\n<pre><code>#include&lt;iostream.h&gt;\n\nchar *strtok_new(char * string, char const * delimiter){\n   static char *source = NULL;\n   char *p, *riturn = 0;\n   if(string != NULL)         source = string;\n   if(source == NULL)         return NULL;\n\n   if((p = strpbrk (source, delimiter)) != NULL) {\n      *p  = 0;\n      riturn = source;\n      source = ++p;\n   }\nreturn riturn;\n}\n\nint main(){\n   char string[] = \"one,,three,\";\n   char delimiter[] = \",\";\n   char * p    = strtok_new(string, delimiter);\n\n   while(p){\n            if(*p)  cout &lt;&lt; p &lt;&lt; endl;\n            else    cout &lt;&lt; \"No data\" &lt;&lt; endl;                \n            p = strtok_new(NULL, delimiter);\n   }\n   system(\"pause\");\n   return 0;\n}\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>one\nNo data\nthree\n</code></pre>\n<p>Hope so this is your desired output.</p>\n", "OwnerUserId": "2852575", "LastEditorUserId": "2410359", "LastEditDate": "2014-10-24T16:44:15.530", "Id": "26552052", "Score": "5", "CreationDate": "2014-10-24T16:19:08.303", "LastActivityDate": "2014-10-24T16:44:15.530"}, "26522699": {"ParentId": "26522583", "CommentCount": "1", "Body": "<p><a href=\"http://www.cplusplus.com/reference/cstring/strtok/\" rel=\"nofollow\">http://www.cplusplus.com/reference/cstring/strtok/</a> says:</p>\n<blockquote>\n<p id=\"so_26522583_26522699_0\">To determine the beginning and the end of a token, the function first scans from the starting location for the first character <strong>not</strong> contained in <em>delimiters</em> (which becomes the <em>beginning of the token</em>). And then scans starting from this <em>beginning of the token</em> for the first character contained in <em>delimiters</em>, which becomes the <em>end of the token</em>. The scan also stops if the terminating <em>null character</em> is found.</p>\n</blockquote>\n<p>So, as the function 'scans (...) for the first character <strong>not</strong> contained in <em>delimiters</em>', then it skips any sequence of delimiter characters. That makes impossible for it to detect an 'empty token' between consecutive delimiters. You will have to scan the input string char-by-char yourself.</p>\n", "OwnerUserId": "733637", "PostTypeId": "2", "Id": "26522699", "Score": "2", "CreationDate": "2014-10-23T06:51:52.653", "LastActivityDate": "2014-10-23T06:51:52.653"}, "26522583": {"CommentCount": "4", "AcceptedAnswerId": "26552052", "LastEditDate": "2014-10-24T16:24:31.640", "OwnerDisplayName": "user3779750", "LastEditorDisplayName": "user3779750", "LastActivityDate": "2016-11-21T13:05:34.140", "Body": "<p>I am trying to read CSV comma delimited file, content of file are</p>\n<pre><code>      one,,three\n</code></pre>\n<p>And code to read file is this\u2026</p>\n<pre><code>      inFile.getline(line, 500);                            \n      token1 = strtok(line, \",\");\n      token2 = strtok(NULL, \",\");\n      token3 = strtok(NULL, \",\");\n\n      if(token1 != NULL){\n             cout &lt;&lt; \"token1 = \" &lt;&lt; token1 &lt;&lt; \"\\n\";      \n      }else{ \n             cout &lt;&lt; \"token1 = null\\n\" ;\n      }\n      if(token2 != NULL){ \n             cout &lt;&lt; \"token2 = \" &lt;&lt; token2 &lt;&lt; \"\\n\";      \n      }else{ \n             cout &lt;&lt; \"token2 = null\\n\" ;\n      } \n      if(token3 != NULL){ \n             cout &lt;&lt; \"token3 = \" &lt;&lt; token3 &lt;&lt; \"\\n\";      \n      }else{ \n             cout &lt;&lt; \"token3 = null\\n\";\n      }\n</code></pre>\n<p>Output is this</p>\n<pre><code>token1 = one\ntoken2 = three\ntoken3 = null\n</code></pre>\n<p>Whereas my expectation are that output should be like this\u2026</p>\n<pre><code>token1 = one\ntoken2 = null\ntoken3 = three\n</code></pre>\n<p>I did change if statements from </p>\n<pre><code>     if(token1 != NULL) \n</code></pre>\n<p>To </p>\n<pre><code>     if(token1)\n</code></pre>\n<p>But it as well doesn\u2019t works. </p>\n<p>After checking this example <a href=\"http://www.cplusplus.com/reference/cstring/strtok/\" rel=\"noreferrer\">http://www.cplusplus.com/reference/cstring/strtok/</a>, I have updated </p>\n<pre><code>   token2 = strtok(NULL, \",\");\n</code></pre>\n<p>To </p>\n<pre><code>   token2 = strtok(NULL, \",,\");\n</code></pre>\n<p>As well it does not works</p>\n", "PostTypeId": "1", "ViewCount": "2351", "FavoriteCount": "3", "Title": "c++ strtok skips second token or consecutive delimiter", "Id": "26522583", "Score": "8", "CreationDate": "2014-10-23T06:43:42.917", "Tags": "<c++><c>", "AnswerCount": "3"}, "bq_ids": {"n4659": {"so_26522583_26522649_1": {"section_id": 7608, "quality": 0.5333333333333333, "length": 8}}}, "26522649": {"ParentId": "26522583", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>From the standard (C99, referenced from C++11 for compatibility features):</p>\n<blockquote>\n<p id=\"so_26522583_26522649_0\">The first call in the sequence searches the string pointed to by s1 for <strong>the first character that is not contained in the current separator string</strong> pointed to by s2.</p>\n<p id=\"so_26522583_26522649_1\">Each subsequent call, with a null pointer as the value of the first argument, starts searching from the saved pointer and behaves as described above.</p>\n</blockquote>\n<p>That means that, when looking for the second token, it first skips over <strong>all</strong> characters that match any in the delimiter string. Hence, <code>,,</code>is treated as a single delimiter in your input string.</p>\n<p>If you want a tokeniser to work differently to the way the standard one works, you'll have to look elsewhere unfortunately, such as the code below:</p>\n<pre><code>#include &lt;string.h&gt;\n\nchar *paxtok (char *str, char *seps) {\n    static char *tpos, *tkn, *pos = NULL;\n    static char savech;\n\n    // Specific actions for first and subsequent calls.\n\n    if (str != NULL) {\n        // First call, set pointer.\n\n        pos = str;\n        savech = 'x';\n    } else {\n        // Subsequent calls, check we've done first.\n\n        if (pos == NULL)\n            return NULL;\n\n        // Then put character back and advance.\n\n        while (*pos != '\\0')\n            pos++;\n        *pos++ = savech;\n    }\n\n    // Detect previous end of string.\n\n    if (savech == '\\0')\n        return NULL;\n\n    // Now we have pos pointing to first character.\n    // Find first separator or nul.\n\n    tpos = pos;\n    while (*tpos != '\\0') {\n        tkn = strchr (seps, *tpos);\n        if (tkn != NULL)\n            break;\n        tpos++;\n    }\n\n    savech = *tpos;\n    *tpos = '\\0';\n\n    return pos;\n}\n</code></pre>\n<p>That, combined with the following test program, should give you what you need::</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint usage (char *reason) {\n    fprintf (stderr, \"ERROR: %s.\\n\", reason);\n    fprintf (stderr, \"Usage: testprog &lt;string&gt; &lt;separator&gt;\\n\");\n    return 1;\n}\n\nint main (int argc, char *argv[]) {\n    if (argc != 3)\n        return usage (\"wrong number of parameters\");\n\n    printf (\"Initial string is '%s'\\n\", argv[1]);\n\n    char *token = paxtok (argv[1], argv[2]);\n    while (token != NULL) {\n        printf (\"Token is '%s'\\n\", token);\n        token = paxtok (NULL, argv[2]);\n    }\n\n    printf (\"Final string is '%s'\\n\", argv[1]);\n\n    return 0;\n}\n</code></pre>\n<p>That gives a full program so that you can test it, such as with the command:</p>\n<pre><code>testprog ,_start,,middle_,end, _,\n</code></pre>\n<p>which will tokenise the first string using the two separators in the second, the underscore and comma. The output of that shows how it works and you can see it picking up empty tokens, including at the start and end:</p>\n<pre><code>Initial string is ',_start,,middle_,end,'\nToken is ''\nToken is ''\nToken is 'start'\nToken is ''\nToken is 'middle'\nToken is ''\nToken is 'end'\nToken is ''\nFinal string is ',_start,,middle_,end,'\n</code></pre>\n<p>Just keep in mind that, using statics, it suffers from the same limitation as <code>strtok</code> - you can't run two tokenising actions side by side. You <em>could</em> make a <code>paxtok_r</code> to mirror <code>strtok_r</code> but I'll leave that as an exercise for the reader.</p>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2016-11-21T13:05:34.140", "Id": "26522649", "Score": "5", "CreationDate": "2014-10-23T06:48:37.997", "LastActivityDate": "2016-11-21T13:05:34.140"}});