post_cb({"17353560": {"CommentCount": "13", "AcceptedAnswerId": "17354296", "PostTypeId": "1", "LastEditorUserId": "15168", "CreationDate": "2013-06-27T21:30:53.917", "LastActivityDate": "2013-06-27T22:28:11.557", "LastEditDate": "2013-06-27T21:35:28.443", "ViewCount": "208", "FavoriteCount": "1", "Title": "What am I missing in the C++11 Standard?", "Id": "17353560", "Score": "2", "Body": "<p>I'm not arguing against the result of the code below, for I think it's correct to assume that a const lvalue reference and an rvalue reference, both extend the lifetime of the temporary returned from the function. What surprises me is this paragraph in the Standard, which appears to say the contrary:</p>\n<p>12.2p5 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_17353560_17353560_0\">The second context is when a reference is bound to a temporary. The\n  temporary to which the reference is bound or the temporary that is the\n  complete object of a subobject to which the reference is bound\n  persists for the lifetime of the reference <strong>except</strong>:</p>\n<ul>\n<li>...</li>\n<li>...</li>\n<li>The lifetime of a temporary bound to the returned value in a function \n  return statement (6.6.3) is <strong>not</strong> extended; the temporary is destroyed\n  at the end of the full-expression in the return statement.</li>\n</ul>\n</blockquote>\n<p>Example code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A{ A() : i(2) {} int i;};\n\nA f() { A a; return a; }\n\nint main()\n{\n    A&amp;&amp; a1 = f();\n    std::cout &lt;&lt; a1.i &lt;&lt; '\\n';\n    const A&amp; a2 = f();\n    std::cout &lt;&lt; a2.i &lt;&lt; '\\n';\n}\n</code></pre>\n", "Tags": "<c++><c++11><standards><object-lifetime>", "OwnerUserId": "1042389", "AnswerCount": "2"}, "17353985": {"ParentId": "17353560", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The quote you mention is specifically for returning a reference from a function and binding that reference to a temporary:</p>\n<pre><code>const T&amp; f() { return T(); };\n</code></pre>\n<p>That is not the case in your code because you are binding a temporary to a reference at the call side, not in the return statement. In your comments you mention that when you modify the code to:</p>\n<pre><code>T f() { return T(); }\nT&amp;&amp; r = f();\n</code></pre>\n<p><em>the lifetime is still extended</em>, but that is wrong. The temporary lives for the duration of the <code>return</code> statement during which it gets copied to the returned value. After the copy completes the lifetime of the temporary ends. On the calling side you have a different temporary (the result of <code>f()</code>) whose lifetime gets extended.</p>\n<p>But <em>there's no doubt that the lifetime of temporaries are extended. If you define a destructor for class A with any message, it will be printed at the end of main()</em>, or is there?</p>\n<p>That statement is also incorrect. You are seeing the effects of the return value optimization (RVO). Instead of creating a temporary for the <code>T()</code> inside the function and another for the returned value, the compiler is creating the two objects in the same location. You are probably seeing a single object in the output of the program, but in theory there are two. </p>\n<p>You can try using g++ with -fno-elide-constructors and you should be able to see both temporaries, one of which is extended the other will not be.</p>\n<p>Alternatively, you can return a reference:</p>\n<pre><code>const A&amp; f() { return A(); }\nconst A&amp; r = f();\n</code></pre>\n<p>Which should show how the temporary dies before <code>r</code> goes out of scope.</p>\n<hr>\n<p>This is basically the same test inhibiting the </p>\n<blockquote>\n<p id=\"so_17353560_17353985_0\">$ g++ --version | head -1</p>\n<p id=\"so_17353560_17353985_1\">g++ (GCC) 4.3.2</p>\n<p id=\"so_17353560_17353985_2\">$ cat x.cpp</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X {\n    X() { std::cout &lt;&lt; \"X\\n\"; }\n    ~X() { std::cout &lt;&lt; \"~X\\n\"; }\n};\n\nX f() { return X(); }\n\nint main() {\n    const X&amp; x = f();\n    std::cout &lt;&lt; \"still in main()\\n\";\n}\n</code></pre>\n<blockquote>\n<p id=\"so_17353560_17353985_3\">$ g++ -o t1 x.cpp &amp;&amp; ./t1</p>\n</blockquote>\n<pre><code>X\nstill in main()\n~X\n</code></pre>\n<blockquote>\n<p id=\"so_17353560_17353985_4\">$ g++ -fno-elide-constructors -o t2 x.cpp &amp;&amp; ./t2</p>\n</blockquote>\n<pre><code>X\n~X\nstill in main()\n~X\n</code></pre>\n<blockquote>\n<p id=\"so_17353560_17353985_5\">$ clang++ -version | head -1</p>\n<p id=\"so_17353560_17353985_6\">$ clang version 3.2 (tags/RELEASE_32/final)</p>\n<p id=\"so_17353560_17353985_7\">$ clang++ -fno-elide-constructors -o t3 x.cpp &amp;&amp; ./t3</p>\n</blockquote>\n<pre><code>X\n~X\nstill in main()\n~X\n</code></pre>\n<blockquote>\n<p id=\"so_17353560_17353985_8\">$ cat y.cpp</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X {\n    X() { std::cout &lt;&lt; \"X\\n\"; }\n    ~X() { std::cout &lt;&lt; \"~X\\n\"; }\n};\n\nconst X&amp; f() { return X(); }\n\nint main() {\n    const X&amp; x = f();\n    std::cout &lt;&lt; \"still in main()\\n\";\n}\n</code></pre>\n<blockquote>\n<p id=\"so_17353560_17353985_9\">$ g++ -fno-elide-constructors -o t4 y.cpp &amp;&amp; ./t4</p>\n</blockquote>\n<pre><code>X\n~X\nstill in main()\n</code></pre>\n</hr>", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2013-06-27T22:27:49.090", "Id": "17353985", "Score": "5", "CreationDate": "2013-06-27T22:03:15.503", "LastActivityDate": "2013-06-27T22:27:49.090"}, "bq_ids": {"n4140": {"so_17353560_17353560_0": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_17353560_17354296_0": {"section_id": 382, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_17353560_17353560_0": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_17353560_17354296_0": {"section_id": 373, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_17353560_17353560_0": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_17353560_17354296_0": {"section_id": 397, "quality": 0.8333333333333334, "length": 15}}}, "17354296": {"ParentId": "17353560", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_17353560_17354296_0\">The second context is when a reference is bound to a temporary - <strong>except</strong> - The lifetime of a temporary bound to the returned value in a function return statement is <strong>not</strong> extended</p>\n</blockquote>\n<pre><code>A f() { A a; return a; }\n</code></pre>\n<p>First of all, <code>a</code> isn't a temporary.  This may be what you were thinking of:</p>\n<pre><code>A f() { return A(); }\n</code></pre>\n<p>Secondly, the return type of the function is not a reference type.  Here is when the rule would apply:</p>\n<pre><code>const A&amp; f() { return A(); }\n</code></pre>\n<p>The temporary from <code>A()</code> is being bound to the return type of <code>const A&amp;</code>.  As per the rule, the lifetime of the temporary is not extended.</p>\n", "OwnerUserId": "1131467", "PostTypeId": "2", "Id": "17354296", "Score": "4", "CreationDate": "2013-06-27T22:28:11.557", "LastActivityDate": "2013-06-27T22:28:11.557"}});