post_cb({"21026358": {"ParentId": "21026264", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2014-01-09T16:52:06.900", "Score": "6", "LastEditorUserId": "560648", "LastEditDate": "2014-10-31T00:20:59.347", "Id": "21026358", "OwnerUserId": "560648", "Body": "<p>Your confusion stems from the fact that <code>extern</code> and <code>extern \"C\"</code> do two different things.</p>\n<hr>\n<h2>About <code>extern</code></h2>\n<p><code>extern</code> on its own is a <em>storage class specifier</em>:</p>\n<blockquote>\n<p id=\"so_21026264_21026358_0\"><code>[C++11: 7.1.1/6]:</code> The <code>extern</code> specifier can be applied only to the names of variables and functions. The <code>extern</code> specifier cannot be used in the declaration of class members or function parameters. For the linkage of a name declared with an <code>extern</code> specifier, see 3.5. <em>[ Note:</em> <strong>The <code>extern</code> keyword can also be used in <em>explicit-instantiations</em> and <em>linkage-specifications</em>, but it is not a <em>storage-class-specifier</em> in such contexts.</strong> <em>\u2014end note ]</em></p>\n</blockquote>\n<hr>\n<h2>About <code>extern \"C\"</code></h2>\n<p>As that trailing note alludes to, there is another context in which you may use the <code>extern</code> keyword and that is as a <em>linkage specifier</em>:</p>\n<blockquote>\n<p id=\"so_21026264_21026358_1\"><code>[C++11: 7.5/2]:</code> Linkage (3.5) between C++ and non-C++ code fragments can be achieved using a <em>linkage-specification</em>:</p>\n<p id=\"so_21026264_21026358_2\"><em>linkage-specification:</em><br>\n  \u00a0 \u00a0 <code>extern</code> <em>string-literal</em> <code>{</code> <em>declaration-seq</em><sub>opt</sub> <code>}</code><br>\n  \u00a0 \u00a0 <code>extern</code> <em>string-literal declaration</em></br></br></p>\n</blockquote>\n<p>C++ likes to re-use keywords.</p>\n<hr>\n<h2>Declarations vs definitions</h2>\n<p>Now, by default, a variable marked with a linkage specifier is a <em>declaration</em> rather than a <em>definition</em>, so in that sense it is as if you had also used the other meaning of <code>extern</code>:</p>\n<blockquote>\n<p id=\"so_21026264_21026358_3\"><code>[C++11: 7.5/7]:</code> A declaration directly contained in a <em>linkage-specification</em> is treated as if it contains the <code>extern</code> specifier (7.1.1) for the purpose of determining the linkage of the declared name and whether it is a definition. Such a declaration shall not specify a storage class. <em>[ Example:</em></p>\n<pre><code>extern \"C\" double f();\nstatic double f(); // error\nextern \"C\" int i; // declaration\nextern \"C\" {\n   int i; // definition\n}\nextern \"C\" static void g(); // error\n</code></pre>\n<p id=\"so_21026264_21026358_4\"><em>\u2014 end example ]</em></p>\n</blockquote>\n<p>As you can see in the above example, it is still possible to <em>either</em> a declaration or a definition when you use a linkage specifier.</p>\n<p>Here's another example of that:</p>\n<pre><code>// Everything in this block has C linkage\nextern \"C\" {\n\n   // Declaration of g_myVal\n   extern int g_myVal;\n\n   // Definition of g_myVal2\n   int g_myVal2;\n}\n\nint main()\n{\n    g_myVal2 = 5;  // ok\n    g_myVal  = 6;  // not okay - linker error, symbol not found\n}\n</code></pre>\n<h3><a href=\"http://coliru.stacked-crooked.com/a/523620a6a0599ce2\" rel=\"nofollow\">Live demo</a></h3>\n<hr>\n<h2>When you add an initialiser...</h2>\n<p>That all being said, the treatment of <code>g_myVal</code> as a <em>declaration</em> is <strong>overruled</strong> by your use of an initialiser, which forces the statement to be a definition:</p>\n<blockquote>\n<p id=\"so_21026264_21026358_5\"><code>[C++11: 7/8]:</code> Syntactic components beyond those found in the general form of declaration are added to a function declaration to make a function-definition. <strong>An object declaration, however, is also a definition unless it contains the <code>extern</code> specifier and has no initializer (3.1).</strong> A definition causes the appropriate amount of storage to be reserved and any appropriate initialization (8.5) to be done.</p>\n</blockquote>\n<p>I hope that this clarifies what is going on in your code with these differing meanings of <code>extern</code>.</p>\n</hr></hr></hr></hr>", "LastActivityDate": "2014-10-31T00:20:59.347"}, "21026574": {"ParentId": "21026264", "CommentCount": "1", "CreationDate": "2014-01-09T17:01:39.730", "OwnerUserId": "3132801", "PostTypeId": "2", "Id": "21026574", "Score": "1", "Body": "<p>In this case, putting the initializer <code>= 0</code> changed the declaration to a definition, which is why storage is allocated here. (The same would have happened even with just plain <code>extern</code>.)</p>\n", "LastActivityDate": "2014-01-09T17:01:39.730"}, "21026264": {"CommentCount": "2", "AcceptedAnswerId": "21026358", "PostTypeId": "1", "LastEditorUserId": "345027", "CreationDate": "2014-01-09T16:48:22.583", "LastActivityDate": "2014-10-31T00:20:59.347", "LastEditDate": "2014-01-09T16:56:42.933", "ViewCount": "166", "FavoriteCount": "1", "Title": "exern declaration on an extern \"C\" global variable", "Id": "21026264", "Score": "3", "Body": "<p>In C and C++ if I want to used a global variable in other compilation units I will define the variable like:</p>\n<pre><code>int g_myVal = 0;\n</code></pre>\n<p>This allocates storage for the <code>int</code></p>\n<p>I the header file I then declare the variable:</p>\n<pre><code>extern int g_myVal;\n</code></pre>\n<p>This informs the compiler that said symbol exists in some other compilation unit. It is then up to the linker to resolve the symbol.</p>\n<p>However if I want the variable to be available with \"C\" linkage I must define the variable (allocate storage) like:</p>\n<pre><code>extern \"C\" int g_myVal = 0;\n</code></pre>\n<p>So how does one then differentiate between allocating storage and just informing the compiler that said symbol exists in another compilation unit?</p>\n", "Tags": "<c++>", "OwnerUserId": "232918", "AnswerCount": "3"}, "21026385": {"ParentId": "21026264", "CommentCount": "11", "CreationDate": "2014-01-09T16:53:16.343", "OwnerUserId": "2485710", "PostTypeId": "2", "Id": "21026385", "Score": "-2", "Body": "<p>In C++ all the symbols in a translation unit are <code>extern</code> by default, in other words <code>extern</code> is implicit.</p>\n<p><code>extern \"C\"</code> is a C++ only definition that allows the correct use of C code inside C++ applications, otherwise with just a simple <code>extern</code> implied your C code will be seen as a C++ symbol.</p>\n<p>I don't think that there is too much to say about that.</p>\n<p>This is about name mangling and linking.</p>\n", "LastActivityDate": "2014-01-09T16:53:16.343"}, "bq_ids": {"n4140": {"so_21026264_21026358_3": {"section_id": 5523, "quality": 0.8333333333333334, "length": 20}, "so_21026264_21026358_1": {"section_id": 5518, "quality": 0.7272727272727273, "length": 8}, "so_21026264_21026358_5": {"section_id": 5386, "quality": 0.96875, "length": 31}, "so_21026264_21026358_2": {"section_id": 5518, "quality": 0.5714285714285714, "length": 4}, "so_21026264_21026358_0": {"section_id": 5396, "quality": 0.7, "length": 28}}, "n3337": {"so_21026264_21026358_3": {"section_id": 5309, "quality": 0.8333333333333334, "length": 20}, "so_21026264_21026358_1": {"section_id": 5304, "quality": 0.7272727272727273, "length": 8}, "so_21026264_21026358_5": {"section_id": 5180, "quality": 0.96875, "length": 31}, "so_21026264_21026358_2": {"section_id": 5304, "quality": 0.5714285714285714, "length": 4}, "so_21026264_21026358_0": {"section_id": 5190, "quality": 0.7, "length": 28}}, "n4659": {"so_21026264_21026358_3": {"section_id": 6958, "quality": 0.8333333333333334, "length": 20}, "so_21026264_21026358_1": {"section_id": 6953, "quality": 0.7272727272727273, "length": 8}, "so_21026264_21026358_5": {"section_id": 6811, "quality": 0.96875, "length": 31}, "so_21026264_21026358_2": {"section_id": 6953, "quality": 0.5714285714285714, "length": 4}, "so_21026264_21026358_0": {"section_id": 6821, "quality": 0.775, "length": 31}}}});