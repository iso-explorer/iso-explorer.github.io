post_cb({"bq_ids": {"n4140": {"so_24286209_24286209_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 1395}}, "n3337": {"so_24286209_24286209_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 1389}}, "n4659": {"so_24286209_24286209_0": {"length": 24, "quality": 0.8, "section_id": 1513}}}, "24286884": {"Id": "24286884", "PostTypeId": "2", "Body": "<p>Consider the values</p>\n<pre><code>pair\n    x{0, 1},\n    y{2, 0},\n    z{1, 2};\n</code></pre>\n<p>Here,</p>\n<pre><code>!tpc(x, y) &amp;&amp; !tpc(y, x);\n!tpc(y, z) &amp;&amp; !tpc(z, y);\n</code></pre>\n<p>However,</p>\n<pre><code>tpc(x, z);\n</code></pre>\n<p>Thus your comparator does <em>not</em> impose a strict weak ordering, and behavior is undefined if you use it with <code>std::sort</code> or in any other role where a strict weak ordering is required.</p>\n<p>A comparator that <em>is</em> strict weak and is a refinement of your comparator would be:</p>\n<pre><code>struct refined_comparator {\n    bool operator()(const pair &amp;p, const pair &amp;q) const { return p.a + p.b &lt; q.a + q.b; }\n} rc;\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-06-18T14:01:10.413", "Score": "6", "CreationDate": "2014-06-18T13:29:23.473", "ParentId": "24286209", "CommentCount": "3", "OwnerUserId": "567292", "LastEditDate": "2014-06-18T14:01:10.413"}, "24286209": {"ViewCount": "1444", "Body": "<p><strong>Note:</strong> While writing this question, I think I already found the answer. Feel free to ammend or append it with a better version. I thought it might be nice to document my problem. <strong>edit</strong> I was wrong, my aswer was not correct.</p>\n<p>Considering a list of integer pairs: I'd like to topologically sort them based on a partial ordering. This is similar to <a href=\"https://stackoverflow.com/questions/12419603/is-partial-order-in-contrast-to-total-order-enough-to-build-a-heap\">Is partial-order, in contrast to total-order, enough to build a heap?</a> , but I'd like to use std::sort instead of std::priority_queue.</p>\n<p>To do so I wrote this piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\n\nstruct pair {\n    int a, b;\n    pair(int a, int b) : a(a), b(b) {}\n\n    std::ostream &amp;print(std::ostream &amp;out) const {\n        return (out &lt;&lt; \"(\" &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \")\");\n    }\n};\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const pair &amp;p) { return p.print(out); }\n\nstruct topological_pair_comparator {\n    bool operator()(const pair &amp;p, const pair &amp;q) const { return p.a&lt;q.a &amp;&amp; p.b&lt;q.b; }\n} tpc;\n\nstd::vector&lt;pair&gt; pairs = {\n    pair(1,1),\n    pair(1,2),\n    pair(2,1),\n    pair(3,1),\n    pair(1,3),\n    pair(5,5),\n    pair(2,2),\n    pair(4,0)\n};\n\nint main() {\n    std::sort(pairs.begin(), pairs.end(), tpc);\n    for(const pair &amp;p : pairs) std::cout &lt;&lt; p &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Source: <a href=\"http://ideone.com/CxOVO0\" rel=\"nofollow noreferrer\">http://ideone.com/CxOVO0</a></p>\n<p>Resulting in:</p>\n<pre><code>(1, 1) (1, 2) (2, 1) (3, 1) (1, 3) (2, 2) (4, 0) (5, 5) \n</code></pre>\n<p>Which is pretty much topologially sorted (proof by example ;).</p>\n<p>However, the partial ordering creates that !((1,2) &lt; (2,1)) and !((1,2) &gt; (2,1)) according to the tpc, and hence one may conclude (1,2) == (2,1). However, paragraph 25.4.3 of the c++ standard (January 2012 working draft) states:</p>\n<blockquote>\n<p id=\"so_24286209_24286209_0\">For all algorithms that take Compare, there is a version that uses operator&lt; instead. That is, comp(*i,\n  *j) != false defaults to *i &lt; *j != false. For algorithms other than those described in 25.4.3 to work\n  correctly, comp has to induce a strict weak ordering on the values.</p>\n</blockquote>\n<p><strong>Edited:</strong> According to ecatmur 's valid answer: \nA partial ordering is not necessarily a strict weak ordering; it breaks the <em>transitivity of incomparibility.</em> So I'd like to drop my reasoning that a partial ordering is always a strict weak ordering and the associated questions, and add the question: am I doomed to write my own topological sorting algorithm or use the boost implementation which requires me to build the graph?</p>\n<p><strong>Solution:</strong> A smart suggestion of ecatmur: </p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct topological_pair_comparator {\n    bool operator()(const pair &amp;p, const pair &amp;q) const { return (p.a + p.b) &lt; (q.a + q.b); }\n} tpc;\n</code></pre>\n<p>Source: <a href=\"http://ideone.com/uoOXNC\" rel=\"nofollow noreferrer\">http://ideone.com/uoOXNC</a></p>\n<p>Please note, the SO about heaps does not explicitely mention that std::sort sorts topologically; except for one comment, which is not backed up by argumentation.</p>\n", "AcceptedAnswerId": "24286884", "Title": "Topological sorting using std::sort", "CreationDate": "2014-06-18T12:56:37.100", "Id": "24286209", "CommentCount": "6", "LastEditDate": "2017-05-23T11:53:37.693", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-18T14:02:56.827", "Score": "3", "OwnerUserId": "853462", "Tags": "<c++><sorting><c++11><topological-sort>", "AnswerCount": "1"}});