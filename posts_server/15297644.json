post_cb({"15297699": {"ParentId": "15297644", "PostTypeId": "2", "CommentCount": "17", "Body": "<blockquote>\n<p id=\"so_15297644_15297699_0\">const for values is an implementation detail of my function, not part of it's interface. </p>\n</blockquote>\n<p>That's the flaw in your thinking, when talking about references and pointers  <code>const</code> has everything to do with the interface, it tells the programmer using the interface that what you're passing won't be altered by the function.  It tells the compiler the same and binds the programmer to this contract.</p>\n<p>A function with a <code>const</code> argument and one with a non-<code>const</code> argument are different.</p>\n<p><em>Passing by value however, will copy the arguments, in which case altering them isn't an issue.</em>  Your <code>int</code>s are passed by value, where this <code>const</code> won't make much difference.</p>\n<p>However, personally I don't think that is a reason to abuse having inconsistent interfaces, and make interfaces different in one place to another.  </p>\n<p>Whereas passing by ref, a ref to <code>const</code> is quite different to ref to non-<code>const</code>.</p>\n", "OwnerUserId": "174614", "LastEditorUserId": "174614", "LastEditDate": "2013-03-08T15:45:31.863", "Id": "15297699", "Score": "0", "CreationDate": "2013-03-08T15:39:17.850", "LastActivityDate": "2013-03-08T15:45:31.863"}, "15297695": {"ParentId": "15297644", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>It's not OK for the <em>function type</em> to differ, but you need to know what is part of the function type and what isn't. In your case, the <code>const</code> for the parameters is not significant, so the function type is the same, although the <em>declaration</em> looks like it differs from the <em>definition</em>.</p>\n<p>In your case it's</p>\n<blockquote>\n<h3>8.3.5 Functions [dcl.fct]</h3>\n<p id=\"so_15297644_15297695_0\"><sup>5</sup> A single name can be used for several different functions in a single scope; this is function overloading (Clause 13). All declarations for a function shall agree exactly in both the return type and the parameter-type-list. The type of a function is determined using the following rules. The type of each parameter (including function parameter packs) is determined from its own decl-specifier-seq and declarator. After\n  determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively. After producing the list of parameter types, any top-level cv-qualifiers modifying a parameter type are deleted when forming the function type. The resulting list of transformed parameter types and the presence or absence of the ellipsis or a function parameter pack is the function\u2019s parameter-type-list. [ Note: This transformation does not\n  affect the types of the parameters. For example, <code>int(*)(const int p, decltype(p)*)</code> and <code>int(*)(int, const int*)</code> are identical types. \u2014 end note ]</p>\n</blockquote>\n<p>As it seems, it need some explanation, so here we go: The important sentence in our case is: <em>After producing the list of parameter types, any top-level cv-qualifiers modifying a parameter type are deleted when forming the function type.</em></p>\n<p>This means that all <em>top-level</em> cv-qualifier are remove. To explain what top-level means, I'll write types in an illegal way to emphasize what a <code>const</code> refers to:</p>\n<ul>\n<li><code>const int</code> = <code>(const (int))</code> -&gt; this is a top-level <code>const</code></li>\n<li><code>const int*</code> = <code>((const (int))*)</code> -&gt; not top-level, it's at the second level</li>\n<li><code>const int* const</code> = <code>(((const (int))*) const)</code> -&gt; the second <code>const</code> is at top-level</li>\n<li><code>const int&amp;</code> = <code>((const (int))&amp;)</code> -&gt; not top-level</li>\n</ul>\n<p>I hope this clears some misconceptions about function types up.</p>\n<p>For your other questions: I'd advise to keep the declaration and the definition identical, as it might confuse people (like evidenced by this question ;).</p>\n<p>For the example of <code>main</code> that you gave:</p>\n<pre><code>int main( const int argc, const char* const argv[] )\n</code></pre>\n<p>is, according to the above quote from the standard, equivalent to:</p>\n<pre><code>int main( int argc, const char* const* argv )\n</code></pre>\n<p>so the added <code>const</code> for <code>argv</code> does not end up as a top-level <code>const</code> which is removed and it's therefore an ill-formed function type for <code>main</code>, which expects:</p>\n<pre><code>int main( int argc, char** argv )\n</code></pre>\n<p>You last question about leaving out the parameter names: I wouldn't do it because to me, they are part of the <em>documentation</em> of the function. They communicate the intent and the semantics of the function (if you choose them wisely).</p>\n", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-03-08T16:59:33.820", "Id": "15297695", "Score": "10", "CreationDate": "2013-03-08T15:39:10.040", "LastActivityDate": "2013-03-08T16:59:33.820"}, "bq_ids": {"n4140": {"so_15297644_15297695_0": {"section_id": 3241, "quality": 0.9230769230769231, "length": 96}}, "n3337": {"so_15297644_15297695_0": {"section_id": 3114, "quality": 0.9230769230769231, "length": 96}}, "n4659": {"so_15297644_15297695_0": {"section_id": 3997, "quality": 0.8653846153846154, "length": 90}}}, "15299361": {"ParentId": "15297644", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It should be OK to have differing top level <code>const</code> for function parameters between declarations and definitions of the function, but note that not all compilers are bug free. For example, the Oracle Sun compiler has a <a href=\"http://docs.oracle.com/cd/E24457_01/html/E21987/glnzd.html#gkgak\" rel=\"nofollow\">long standing issue</a> where it mangles <code>int f(int)</code> and <code>int f(const int)</code> differently.</p>\n<p>To avoid any possibility of confusion that you really meant to pass by <code>const</code> reference I usually recommend avoiding top level <code>const</code> in public function declarations and to avoid possible compiler issues I would avoid it in function definitions as well.</p>\n<p>(Note that changing <code>char **</code> to <code>const char* const argv[]</code> in an argument list is not adding top level const, it's a genuine signature change. <code>char**</code> would only be equivalent to <code>char** const</code> in a function parameter list.)</p>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2013-03-08T17:06:01.813", "Id": "15299361", "Score": "1", "CreationDate": "2013-03-08T17:00:57.987", "LastActivityDate": "2013-03-08T17:06:01.813"}, "15297644": {"CommentCount": "2", "AcceptedAnswerId": "15297695", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-03-08T15:36:18.657", "LastActivityDate": "2013-03-08T17:06:01.813", "LastEditDate": "2017-05-23T11:59:42.580", "ViewCount": "600", "FavoriteCount": "4", "Title": "Is it OK for function prototypes and function implementation signatures to use const inconsistently?", "Id": "15297644", "Score": "8", "Body": "<p>I like to declare even value parameters as <code>const</code> where possible, and by searching SO, I found that <a href=\"https://stackoverflow.com/questions/117293/use-of-const-for-function-parameters\">that's not too uncommon</a>. Like this:</p>\n<pre><code>int add(const int a, const int b)\n{\n    ...\n}\n</code></pre>\n<p>But I'm wondering: <code>const</code> for <strong>values</strong> is an implementation detail of my function, not part of it's interface. So putting it into the prototype seems unnecessary.</p>\n<p>This prototype for the above function seems to work just fine:</p>\n<pre><code>int add(int a, int b);\n</code></pre>\n<p>Yet I've heard about issues that e.g. declaring the main function's argc as const can lead to problems:</p>\n<pre><code>int main(const int argc, const char* const argv[])\n</code></pre>\n<p>So does that mean that <code>int add(int a, int b)</code> and <code>int add(const int a, const int b)</code> are not identical after all?</p>\n<p>And if it's technically OK, is that something I should do? I could also leave out variable names in the prototype, but I don't, so maybe I shouldn't leave out <code>const</code> either?</p>\n", "Tags": "<c++><c><header><const><function-prototypes>", "OwnerUserId": "606036", "AnswerCount": "3"}});