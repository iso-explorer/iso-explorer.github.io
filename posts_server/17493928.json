post_cb({"17494165": {"Id": "17494165", "PostTypeId": "2", "Body": "<p>No. You just can't move a <code>packaged_task&lt;int ()&gt;</code> into a <code>packaged_task&lt;void ()&gt;</code>. These types a unrelated and cannot be move-assigned or move-constructed from each other. If you for some reason really want to do that you can \"swallow\" the result of the <code>int ()</code> like <a href=\"http://ideone.com/ScfGDM\" rel=\"nofollow\">this</a></p>\n", "LastActivityDate": "2013-07-05T17:31:38.873", "CommentCount": "2", "CreationDate": "2013-07-05T17:31:38.873", "ParentId": "17493928", "Score": "0", "OwnerUserId": "440004"}, "17493928": {"ViewCount": "788", "Body": "<p>I have this minimal not-working example of code </p>\n<pre><code>#include &lt;future&gt;\n\nint main()\n{\n    auto intTask = std::packaged_task&lt;int()&gt;( []()-&gt;int{ return 5; } );\n    std::packaged_task&lt;void()&gt; voidTask{ std::move(intTask) };\n}\n</code></pre>\n<p>Why doesn't it compile (on gcc 4.8.1)? I suspect, the reason is, that <code>std::packaged_task</code> stores the lambda internally inside an <code>std::function</code> which needs a <code>CopyConstructible</code> argument. However, <code>std::packaged_task</code> is move-only. Is this a bug? What does the standard say about it? In my opinion <code>std::packaged_task</code> should not need a <code>CopyConstructible</code> argument, but a <code>MoveConstructible</code> argument should be enough.</p>\n<p>By the way, when I replace <code>std::packaged_task&lt;int()&gt;</code> by <code>std::packaged_task&lt;void()&gt;</code> everything compiles fine. </p>\n<p>GCC 4.8.1 is giving me this error message:</p>\n<pre><code>In file included from /usr/include/c++/4.6/future:38:0,\n                 from ../cpp11test/main.cpp:160:\n/usr/include/c++/4.6/functional: In static member function 'static void        std::_Function_base::_Base_manager&lt;_Functor&gt;::_M_clone(std::_Any_data&amp;, const std::_Any_data&amp;, std::false_type) [with _Functor = std::packaged_task&lt;int()&gt;, std::false_type = std::integral_constant&lt;bool, false&gt;]':\n/usr/include/c++/4.6/functional:1652:8:   instantiated from 'static bool std::_Function_base::_Base_manager&lt;_Functor&gt;::_M_manager(std::_Any_data&amp;, const std::_Any_data&amp;, std::_Manager_operation) [with _Functor = std::packaged_task&lt;int()&gt;]'\n/usr/include/c++/4.6/functional:2149:6:   instantiated from 'std::function&lt;_Res(_ArgTypes ...)&gt;::function(_Functor, typename std::enable_if&lt;(! std::is_integral&lt;_Functor&gt;::value), std::function&lt;_Res(_ArgTypes ...)&gt;::_Useless&gt;::type) [with _Functor = std::packaged_task&lt;int()&gt;, _Res = void, _ArgTypes = {}, typename std::enable_if&lt;(! std::is_integral&lt;_Functor&gt;::value), std::function&lt;_Res(_ArgTypes ...)&gt;::_Useless&gt;::type = std::function&lt;void()&gt;::_Useless]'\n/usr/include/c++/4.6/bits/shared_ptr_base.h:410:4:   instantiated from 'std::_Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt;::_Sp_counted_ptr_inplace(_Alloc, _Args&amp;&amp; ...) [with _Args = {std::packaged_task&lt;int()&gt;}, _Tp = std::__future_base::_Task_state&lt;void()&gt;, _Alloc = std::allocator&lt;std::__future_base::_Task_state&lt;void()&gt; &gt;, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]'\n/usr/include/c++/4.6/bits/shared_ptr_base.h:518:8:   instantiated from 'std::__shared_count&lt;_Lp&gt;::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&amp;, _Args&amp;&amp; ...) [with _Tp = std::__future_base::_Task_state&lt;void()&gt;, _Alloc = std::allocator&lt;std::__future_base::_Task_state&lt;void()&gt; &gt;, _Args = {std::packaged_task&lt;int()&gt;}, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]'\n/usr/include/c++/4.6/bits/shared_ptr_base.h:987:35:   instantiated from 'std::__shared_ptr&lt;_Tp, _Lp&gt;::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&amp;, _Args&amp;&amp; ...) [with _Alloc = std::allocator&lt;std::__future_base::_Task_state&lt;void()&gt; &gt;, _Args = {std::packaged_task&lt;int()&gt;}, _Tp = std::__future_base::_Task_state&lt;void()&gt;, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]'\n/usr/include/c++/4.6/bits/shared_ptr.h:317:64:   instantiated from 'std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&amp;, _Args&amp;&amp; ...) [with _Alloc = std::allocator&lt;std::__future_base::_Task_state&lt;void()&gt; &gt;, _Args = {std::packaged_task&lt;int()&gt;}, _Tp = std::__future_base::_Task_state&lt;void()&gt;]'\n/usr/include/c++/4.6/bits/shared_ptr.h:535:39:   instantiated from 'std::shared_ptr&lt;_Tp&gt; std::allocate_shared(const _Alloc&amp;, _Args&amp;&amp; ...) [with _Tp = std::__future_base::_Task_state&lt;void()&gt;, _Alloc = std::allocator&lt;std::__future_base::_Task_state&lt;void()&gt; &gt;, _Args = {std::packaged_task&lt;int()&gt;}]'\n/usr/include/c++/4.6/bits/shared_ptr.h:551:42:   instantiated from 'std::shared_ptr&lt;_Tp1&gt; std::make_shared(_Args&amp;&amp; ...) [with _Tp = std::__future_base::_Task_state&lt;void()&gt;, _Args = {std::packaged_task&lt;int()&gt;}]'\n/usr/include/c++/4.6/future:1223:66:   instantiated from 'std::packaged_task&lt;_Res(_ArgTypes ...)&gt;::packaged_task(_Fn&amp;&amp;) [with _Fn = std::packaged_task&lt;int()&gt;, _Res = void, _ArgTypes = {}]'\n../cpp11test/main.cpp:165:61:   instantiated from here\n/usr/include/c++/4.6/functional:1616:4: error: use of deleted function 'std::packaged_task&lt;_Res(_ArgTypes ...)&gt;::packaged_task(std::packaged_task&lt;_Res(_ArgTypes ...)&gt;&amp;) [with _Res = int, _ArgTypes = {}, std::packaged_task&lt;_Res(_ArgTypes ...)&gt; = std::packaged_task&lt;int()&gt;]'\n/usr/include/c++/4.6/future:1244:7: error: declared here\n</code></pre>\n<p><strong>UPDATE:</strong> I have written the following test program. It seems to support the assumption that the reason is missing <code>CopyConstructability</code>. Again, what are the requirements on the type of the object from which an <code>std::packaged_task</code> may be constructed?</p>\n<pre><code>#include &lt;future&gt;\n\nstruct Functor {\n    Functor() {}\n    Functor( const Functor &amp; ) {} // without this line it doesn't compile\n    Functor( Functor &amp;&amp; ) {}\n    int operator()(){ return 5; }\n};\n\nint main() {\n    auto intTask = std::packaged_task&lt;int()&gt;( Functor{} );\n}\n</code></pre>\n", "AcceptedAnswerId": "17494800", "Title": "Does `std::packaged_task` need a CopyConstructible constructor argument?", "CreationDate": "2013-07-05T17:15:13.580", "Id": "17493928", "CommentCount": "5", "LastEditDate": "2013-07-05T17:26:23.167", "PostTypeId": "1", "LastEditorUserId": "1335865", "LastActivityDate": "2013-07-05T18:19:01.543", "Score": "3", "OwnerUserId": "1335865", "Tags": "<c++><c++11><future><packaged-task>", "AnswerCount": "3"}, "17494046": {"Id": "17494046", "PostTypeId": "2", "Body": "<p>Indeed, <code>packaged_task</code> only has a moving constructor (30.6.9/2):</p>\n<blockquote>\n<p id=\"so_17493928_17494046_0\"><code>template &lt;class F&gt; explicit packaged_task(F&amp;&amp; f);</code></p>\n</blockquote>\n<p>However, your problem is the <code>explicit</code> constructor. So write it like this:</p>\n<pre><code>std::packaged_task&lt;int()&gt; pt([]() -&gt; int { return 1; });\n</code></pre>\n<hr>\n<p><strong>Complete example:</strong></p>\n<pre><code>#include &lt;future&gt;\n#include &lt;thread&gt;\n\nint main()\n{\n    std::packaged_task&lt;int()&gt; intTask([]() -&gt; int { return 5; } );\n    auto f = intTask.get_future();\n    std::thread(std::move(intTask)).detach();\n    return f.get();\n}\n</code></pre>\n</hr>", "LastEditorUserId": "596781", "LastActivityDate": "2013-07-05T17:33:58.770", "Score": "2", "CreationDate": "2013-07-05T17:24:48.687", "ParentId": "17493928", "CommentCount": "1", "OwnerUserId": "596781", "LastEditDate": "2013-07-05T17:33:58.770"}, "bq_ids": {"n4140": {"so_17493928_17494800_1": {"length": 12, "quality": 1.0, "section_id": 3173}, "so_17493928_17494800_0": {"length": 5, "quality": 1.0, "section_id": 3170}}, "n3337": {"so_17493928_17494800_1": {"length": 12, "quality": 1.0, "section_id": 3046}, "so_17493928_17494800_0": {"length": 5, "quality": 1.0, "section_id": 3044}}, "n4659": {"so_17493928_17494800_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3935}, "so_17493928_17494800_0": {"length": 5, "quality": 1.0, "section_id": 3932}}}, "17494800": {"Id": "17494800", "PostTypeId": "2", "Body": "<p>The standard (as of N3690) doesn't state anything explicitly about the requirements of the type <code>F</code> in </p>\n<pre><code>template &lt;class R, class... ArgTypes&gt;\ntemplate &lt;class F&gt;\npackaged_task&lt;R(ArgTypes...)&gt;::packaged_task(F&amp;&amp; f);\n</code></pre>\n<p>(see 30.6.9.1) However, it states that </p>\n<blockquote>\n<p id=\"so_17493928_17494800_0\">Invoking a copy of <code>f</code> shall behave the same as invoking <code>f</code>.</p>\n</blockquote>\n<p>and that this call can throw</p>\n<blockquote>\n<p id=\"so_17493928_17494800_1\">any exceptions thrown by the copy or move constructor of <code>f</code>, or <code>std::bad_alloc</code> if memory\n  for the internal data structures could not be allocated.</p>\n</blockquote>\n<p>This implicitly implies that the type <code>F</code> must be at least <code>MoveConstructible</code>, or <code>CopyConstructible</code>, if an lvalue reference is handed to the function. </p>\n<p>Hence, it's not a bug, it's just not specified that precisely. To solve the problem of putting a <code>std::packaged_task&lt;int()&gt;</code> into a <code>std::packaged_task&lt;void()&gt;</code> just wrap the first into a <code>shared_ptr</code> like this:</p>\n<pre><code>#include &lt;future&gt;\n#include &lt;memory&gt;\n\nint main()\n{\n    auto intTask = std::make_shared&lt;std::packaged_task&lt;int()&gt;&gt;( \n        []()-&gt;int{ return 5; } );\n    std::packaged_task&lt;void()&gt; voidTask{ [=]{ (*intTask)(); } };\n}\n</code></pre>\n", "LastActivityDate": "2013-07-05T18:19:01.543", "CommentCount": "0", "CreationDate": "2013-07-05T18:19:01.543", "ParentId": "17493928", "Score": "0", "OwnerUserId": "1335865"}});