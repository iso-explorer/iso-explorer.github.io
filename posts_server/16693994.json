post_cb({"bq_ids": {"n4140": {"so_16693994_16694256_4": {"length": 11, "quality": 1.0, "section_id": 95}, "so_16693994_16694256_2": {"length": 6, "quality": 1.0, "section_id": 95}, "so_16693994_16694256_6": {"length": 11, "quality": 1.0, "section_id": 95}, "so_16693994_16693994_0": {"length": 9, "quality": 0.9, "section_id": 60}, "so_16693994_16693994_2": {"length": 9, "quality": 0.9, "section_id": 60}}, "n3337": {"so_16693994_16694256_6": {"length": 11, "quality": 1.0, "section_id": 90}, "so_16693994_16694256_4": {"length": 11, "quality": 1.0, "section_id": 90}, "so_16693994_16694256_2": {"length": 6, "quality": 1.0, "section_id": 90}, "so_16693994_16693994_2": {"length": 9, "quality": 0.9, "section_id": 55}, "so_16693994_16693994_0": {"length": 9, "quality": 0.9, "section_id": 55}}, "n4659": {"so_16693994_16694256_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 99}, "so_16693994_16694256_4": {"length": 11, "quality": 1.0, "section_id": 99}, "so_16693994_16694256_2": {"length": 6, "quality": 1.0, "section_id": 99}, "so_16693994_16693994_2": {"length": 7, "quality": 0.7, "section_id": 62}, "so_16693994_16693994_0": {"length": 7, "quality": 0.7, "section_id": 62}}}, "16693994": {"ViewCount": "920", "Body": "<p>I have problem understanding the following paragraph Per C++11 Standard N3485 Section 14.1.7.\nI think it is more important to understand the rationale instead of memorizing the facts.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_16693994_16693994_2\">A non-type template-parameter shall not be declared to have floating point, class, or void type.<br>\n    [ Example:   </br></p>\n</blockquote>\n<pre><code>template&lt;double d&gt; class X; // error\ntemplate&lt;double* pd&gt; class Y; // OK\ntemplate&lt;double&amp; rd&gt; class Z; // OK\n</code></pre>\n<p id=\"so_16693994_16693994_1\">\u2014end example ]</p>\n</blockquote>\n<p>I have some questions regarding this rule:</p>\n<ol>\n<li><p><strong>Is there a reason that why <code>floating point</code> type cannot be used as template parameter? What is the rationale behind that?</strong> I know this is true before C++11 and it seems also true for C++11 standard.</p></li>\n<li><p><strong>Why it is OK to use <code>pointer</code> or <code>reference</code> to floating point types as non-template parameters, but not raw floating point type?</strong> What is the big difference here?</p></li>\n</ol>\n<p>Thank you for your help.</p>\n", "AcceptedAnswerId": "16694256", "Title": "understanding of non-type template parameters", "CreationDate": "2013-05-22T14:08:28.260", "Id": "16693994", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-05-22T15:23:25.510", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-22T15:23:25.510", "Score": "12", "OwnerUserId": "1760345", "Tags": "<c++><templates><c++11>", "AnswerCount": "2"}, "16694256": {"Id": "16694256", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16693994_16694256_0\">Is there a reason that why floating point type cannot be used as template parameter? What is the rationale behind that?</p>\n</blockquote>\n<p>While I cannot give the ultimate reason, I can definitely imagine there would be problems with specializing a template that accepts a floating pointer value as a parameter. </p>\n<p>Equality comparisons between floating point numbers is tricky (in the sense that it sometimes gives unexpected results), and when matching specializations, the compiler would have to perform an equality check between the argument provided and the value for which a template is being specialized.</p>\n<p>Another similar issue is determining whether two instances of the same class templates are actually the same type:</p>\n<pre><code>template&lt;double D&gt;\nstruct X\n{\n    // ...\n};\n\nint main()\n{\n    X&lt;3.0&gt; x;\n    X&lt;some_constant_expression()&gt; y;\n}\n</code></pre>\n<p>Are <code>x</code> and <code>y</code> instances of the same class? To decide this, an equality check has to be performed between <code>3.0</code> and <code>some_constant_expression()</code>.</p>\n<blockquote>\n<p id=\"so_16693994_16694256_1\">Why it is OK to use pointer or reference to floating point types as non-template parameters, but not raw floating point type?</p>\n</blockquote>\n<p>With respect to the above scenario, the answer concerning pointers is simple: pointers are integral values, and comparison between pointers is well defined.</p>\n<p>Concerning references, evidence shows that they are in fact treated like pointers:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ndouble a = 0.0;\ndouble b = 0.0;\n\ntemplate&lt;double&amp; D&gt;\nstruct X : std::false_type { };\n\ntemplate&lt;&gt;\nstruct X&lt;a&gt; : std::true_type { }\n\nint main()\n{\n    static_assert(X&lt;a&gt;::value, \"!\"); // Does not fire\n    static_assert(X&lt;b&gt;::value, \"!\"); // Fires\n}\n</code></pre>\n<p>Also, per paragraph 14.4/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16693994_16694256_2\">Two <em>template-ids</em> refer to the same class or function if</p>\n<p id=\"so_16693994_16694256_3\">\u2014 [...]</p>\n<p id=\"so_16693994_16694256_4\">\u2014 their corresponding non-type template arguments of integral or enumeration type have identical values and</p>\n<p id=\"so_16693994_16694256_5\">\u2014 [...]</p>\n<p id=\"so_16693994_16694256_6\">\u2014 their corresponding non-type <em>template-arguments</em> of reference type refer to the same external object\n  or function and</p>\n<p id=\"so_16693994_16694256_7\">\u2014 [...]</p>\n<p id=\"so_16693994_16694256_8\">[ <em>Example:</em></p>\n<pre><code>template&lt;class E, int size&gt; class buffer { / ... / };\nbuffer&lt;char,2*512&gt; x;\nbuffer&lt;char,1024&gt; y;\n</code></pre>\n<p id=\"so_16693994_16694256_9\">declares <code>x</code> and <code>y</code> to be of the same type, and [...]</p>\n</blockquote>\n<p>The above shows that determining whether two different instances of the same class template are actually the same class requires an equality check between the constant expressions used as template arguments.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-22T15:00:58.427", "Score": "8", "CreationDate": "2013-05-22T14:20:05.867", "ParentId": "16693994", "CommentCount": "11", "OwnerUserId": "1932150", "LastEditDate": "2013-05-22T15:00:58.427"}, "16694886": {"Id": "16694886", "PostTypeId": "2", "Body": "<p>To figure this out, consider that integral types and pointers always have a one-to-one relationship with their literal representation.</p>\n<p>But then let's consider a non-type template <code>Foo&lt;float&gt;</code>.</p>\n<p>Let's say it's specialized for a non-binary-representable numver like <code>0.1</code>: <code>Foo&lt;0.1&gt;</code> and let's say the compiler decorates the symbol name based on the specialization and you wind up with something like <code>Foo_3DCCCCCC</code> because the compiler is using \"round down\" for an IEEE 754 32 bit rep.</p>\n<p>But then let's say that the <em>user</em> of this code is compiling is such a way that the compiler chooses \"round to positive infinity\" instead. Then then specialization's name is instead <code>Foo_3DCCCCCD</code> which is a completely different function from the one that was previously specialized in another translation unit.</p>\n<p>Unless you start making up a wide variety of rules to handle all these sorts of things  (what about NaN, infinity, and other not-a-normal-numbers?) then you open yourself to mismatches and all sorts of possible problems.</p>\n", "LastActivityDate": "2013-05-22T14:46:21.310", "CommentCount": "1", "CreationDate": "2013-05-22T14:46:21.310", "ParentId": "16693994", "Score": "2", "OwnerUserId": "251738"}});