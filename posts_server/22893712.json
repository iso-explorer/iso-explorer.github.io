post_cb({"22893724": {"ParentId": "22893712", "CommentCount": "2", "Body": "<p>Because the C Standard says:</p>\n<blockquote>\n<p id=\"so_22893712_22893724_0\">(C99, 6.2.5p5) \"A \"plain\" int object has the natural size suggested by the architecture of the execution environment\"</p>\n</blockquote>\n<p>C only defines a minimum value for the maximum value an <code>int</code> (<code>INT_MAX</code>) can hold, a maximum value for the minimum value an <code>int</code> can hold (<code>INT_MIN</code>).</p>\n", "OwnerUserId": "1119701", "PostTypeId": "2", "Id": "22893724", "Score": "1", "CreationDate": "2014-04-06T12:00:29.710", "LastActivityDate": "2014-04-06T12:00:29.710"}, "22893712": {"CommentCount": "1", "AcceptedAnswerId": "22894114", "PostTypeId": "1", "ClosedDate": "2014-04-06T12:47:08.310", "LastEditorUserId": "3200487", "CreationDate": "2014-04-06T11:59:34.383", "LastActivityDate": "2014-04-06T12:43:28.770", "LastEditDate": "2014-04-06T12:06:38.293", "ViewCount": "298", "FavoriteCount": "1", "Title": "Why does the size of an int vary in some compilers?", "Id": "22893712", "Score": "0", "Body": "<p>Reading the following resource it says the size of an int/pointer can vary depending on the compiler:</p>\n<p><a href=\"http://www.c4learn.com/c-programming/c-size-of-pointer-variable/\" rel=\"nofollow\">http://www.c4learn.com/c-programming/c-size-of-pointer-variable/</a></p>\n<p>Why is this?</p>\n<p>I understand C defines only the min and max number of what a type should hold, but why would one compiler choose to set for example int to 2 bytes and another at 4? What would be the advantage of one over another?</p>\n", "Tags": "<c++><c><architecture><int>", "OwnerUserId": "3200487", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_22893712_22893724_0": {"section_id": 7211, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_22893712_22893724_0": {"section_id": 6955, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_22893712_22893724_0": {"section_id": 8720, "quality": 0.6363636363636364, "length": 7}}}, "22894114": {"ParentId": "22893712", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Whilst the \"why\" can be answered with \"Because the standard says so\", one could make the argument that the standard could be written differently, to guarantee a particular size. </p>\n<p>However, the purpose of C and C++ is to produce very fast code on all machines. If the compiler had to make sure that an <code>int</code> is a \"unnatural size\" for that machine, it would require extra instructions. For nearly all circumstances, that is not required, all you'd care about is that it's \"big enough for what I want to do\". So, to give the compiler a good chance to generate \"good code\", the standard specifies only minimum sizes, avoiding the compiler having to generate \"extra code\" to make <code>int</code> (and other types) behave in a very specific way. </p>\n<p>One of the many benefits of C and C++ is that there are compilers to target a vast range of machines, from little 8- and 16-bit microcontrollers to large, 64-bit multi-core processors like the ones in a PC. And of course, some 18, 24 or 36-bit machines too. If your machine has a 36-bit native size, you wouldn't be very happy if, because some standard says so, you get half the performance in integer math due to extra instructions, and can't use the top 4 bits of an <code>int</code>... </p>\n<p>A small microprocessor with 8-bit registers often have support to do 16-bit additions and subtractions (and perhaps also multiplication and divide), but 32-bit math would involve doubling up on those instructions [and more work for multiplication and divide]. So 16-bit integers (2 byte) would make much more sense on such a small processor - particularly since memory is probably not very large either, so storing 4 bytes for every integer is a bit of a waste. In a 32- or 64-bit machine, memory range is most likely a lot larger, so having larger integers isn't that much of a drawback, and 32-bit integer operations are the same speed as smaller ones (and in some cases \"better\" - for example in x86, a 16-bit simple math operation such as addition or subtraction requires an extra prefix byte to say \"make this 16-bit\", so math on 16-bit integers would take up more code-space). </p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2014-04-06T12:43:28.770", "Id": "22894114", "Score": "5", "CreationDate": "2014-04-06T12:36:43.620", "LastActivityDate": "2014-04-06T12:43:28.770"}});