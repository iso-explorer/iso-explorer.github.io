post_cb({"7554039": {"CommentCount": "4", "AcceptedAnswerId": "7554172", "PostTypeId": "1", "LastEditorUserId": "476681", "CreationDate": "2011-09-26T10:56:51.730", "LastActivityDate": "2013-02-01T17:00:16.623", "LastEditDate": "2011-09-26T11:00:48.903", "ViewCount": "7678", "FavoriteCount": "9", "Title": "Is string::c_str() no longer null terminated in C++11?", "Id": "7554039", "Score": "72", "Body": "<p>In C++11 <code>basic_string::c_str</code> is defined to be exactly the same as <code>basic_string::data</code>, which is in turn defined to be exactly the same as <code>*(begin() + n)</code> and <code>*(&amp;*begin() + n)</code> (when <code>0 &lt;= n &lt; size()</code>).</p>\n<p>I cannot find anything that requires the string to always have a null character at its end.</p>\n<p>Does this mean that <code>c_str()</code> is no longer guaranteed to produce a null-terminated string?</p>\n", "Tags": "<c++><string><c++11>", "OwnerUserId": "485561", "AnswerCount": "4"}, "7554136": {"ParentId": "7554039", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Well, in fact it is true that the new standard stipulates that .data() and .c_str() are now synonyms. However, it doesn't say that .c_str() is no longer zero-terminated :)</p>\n<p>It just means that you can now rely on .data() being zero-terminated as well.</p>\n<blockquote>\n<p id=\"so_7554039_7554136_0\">Paper N2668 defines c_str() and data() members of std::basic_string as \n   follows: </p>\n<pre><code> const charT* c_str() const; \n const charT* data() const; \n</code></pre>\n<p id=\"so_7554039_7554136_1\">Returns: A pointer to the initial element of an array of length \n   size() + 1 whose first size() elements equal the corresponding \n   elements of the string controlled by *this and whose last element is a \n   null character specified by charT(). </p>\n<p id=\"so_7554039_7554136_2\">Requires: The program shall not alter any of the values stored in \n   the character array.</p>\n</blockquote>\n<p>Note that this does <em>NOT</em> mean that any valid std::string can be treated as a C-string because std::string can contain embedded nulls, which will prematurely end the C-string when used directly as a const char*.</p>\n<h2>Addendum:</h2>\n<p>I don't have access to the actual published <a href=\"http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372\" rel=\"noreferrer\">final spec of C++11</a> but it appears that indeed the wording was dropped somewhere in the revision history of the spec: e.g. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a></p>\n<blockquote>\n<p id=\"so_7554039_7554136_3\">\u00a7 21.4.7 basic_string string operations <code>[string.ops]</code></p>\n<p id=\"so_7554039_7554136_4\">\u00a7 21.4.7.1 basic_string accessors <code>[string.accessors]</code></p>\n</blockquote>\n<blockquote id=\"so_7554039_7554136_5\">\n<pre><code>     const charT* c_str() const noexcept;\n     const charT* data() const noexcept;\n</code></pre>\n<ol>\n<li>Returns: A pointer p such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</li>\n<li>Complexity: constant time.</li>\n<li>Requires: The program shall not alter any of the values stored in the character array.</li>\n</ol>\n</blockquote>\n", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2012-03-27T09:41:36.820", "Id": "7554136", "Score": "23", "CreationDate": "2011-09-26T11:05:12.790", "LastActivityDate": "2012-03-27T09:41:36.820"}, "7554142": {"ParentId": "7554039", "CommentCount": "2", "Body": "<p>Well spotted.  This is certainly a defect in the recently adopted standard; I'm sure that there was no intent to break all of the code currently using <code>c_str</code>.  I would suggest a defect report, or at least asking the question in <code>comp.std.c++</code> (which will usually end up before the committee if it concerns a defect).</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "7554142", "Score": "2", "CreationDate": "2011-09-26T11:05:45.473", "LastActivityDate": "2011-09-26T11:05:45.473"}, "13048115": {"ParentId": "7554039", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The \"history\" was that a long time ago when everyone worked in single threads, or at least the threads were workers with their own data, they designed a string class for C++ which made string handling easier than it had been before, and they overloaded operator+ to concatenate strings.</p>\n<p>The issue was that users would do something like:</p>\n<pre><code>s = s1 + s2 + s3 + s4;\n</code></pre>\n<p>and each concatenation would create a temporary which had to implement a string.</p>\n<p>Therefore someone had the brainwave of \"lazy evaluation\" such that internally you could store some kind of \"rope\" with all the strings until someone wanted to read it as a C-string at which point you would change the internal representation to a contiguous buffer.</p>\n<p>This solved the problem above but caused a load of other headaches, in particular in the multi-threaded world where one expected a .c_str() operation to be read-only / doesn't change anything and therefore no need to lock anything. Premature internal-locking in the class implementation just in case someone was doing it multi-threaded (when there wasn't even a threading standard) was also not a good idea. In fact it was more costly to do anything of this than simply copy the buffer each time. Same reason \"copy on write\" implementation was abandoned for string implementations.</p>\n<p>Thus making <code>.c_str()</code> a truly immutable operation turned out to be the most sensible thing to do, however could one \"rely\" on it in a standard that now is thread-aware? Therefore the new standard decided to clearly state that you can, and thus the internal representation needs to hold the null terminator.</p>\n", "OwnerUserId": "442284", "LastEditorUserId": "485561", "LastEditDate": "2012-10-24T12:24:11.820", "Id": "13048115", "Score": "9", "CreationDate": "2012-10-24T11:15:38.193", "LastActivityDate": "2012-10-24T12:24:11.820"}, "bq_ids": {"n4140": {"so_7554039_7554172_1": {"section_id": 1617, "quality": 0.6428571428571429, "length": 9}, "so_7554039_7554136_2": {"section_id": 1763, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_7554039_7554172_1": {"section_id": 1613, "quality": 0.6428571428571429, "length": 9}, "so_7554039_7554136_2": {"section_id": 1757, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_7554039_7554172_1": {"section_id": 1770, "quality": 0.7142857142857143, "length": 10}, "so_7554039_7554136_2": {"section_id": 1929, "quality": 0.7142857142857143, "length": 5}}}, "7554172": {"ParentId": "7554039", "PostTypeId": "2", "CommentCount": "22", "Body": "<p>Strings are now required to use null-terminated buffers internally. Look at the definition of <code>operator[]</code> (21.4.5):</p>\n<blockquote>\n<p id=\"so_7554039_7554172_0\"><em>Requires:</em> <code>pos &lt;= size()</code>. </p>\n<p id=\"so_7554039_7554172_1\"><em>Returns:</em> <code>*(begin() + pos)</code> if <code>pos &lt;\n  size()</code>, otherwise a reference to an object of type <code>T</code> with value \n  <code>charT()</code>; the referenced value shall not be modified.</p>\n</blockquote>\n<p>Looking back at <code>c_str</code> (21.4.7.1/1), we see that it is defined in terms of <code>operator[]</code>:</p>\n<blockquote>\n<p id=\"so_7554039_7554172_2\"><em>Returns:</em> A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n<p>And both <code>c_str</code> and <code>data</code> are required to be O(1), so the implementation is effectively forced to use null-terminated buffers.</p>\n<p>Additionally, as <a href=\"https://stackoverflow.com/users/36565/david-rodriguez-dribeas\">David Rodr\u00edguez - dribeas</a> points out in the comments, the return value requirement also means that you can use <code>&amp;operator[](0)</code> as a synonym for <code>c_str()</code>, so the terminating null character must lie in the same buffer (since <code>*(p + size())</code> must be equal to <code>charT()</code>); this also means that even if the terminator is initialised lazily, it's not possible to observe the buffer in the intermediate state.</p>\n", "OwnerUserId": "242169", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:08:05.467", "Id": "7554172", "Score": "80", "CreationDate": "2011-09-26T11:09:05.697", "LastActivityDate": "2011-10-17T14:02:17.940"}});