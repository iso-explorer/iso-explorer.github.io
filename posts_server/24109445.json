post_cb({"24109650": {"ParentId": "24109445", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>From <a href=\"http://www.cplusplus.com/reference/initializer_list/initializer_list/\" rel=\"nofollow noreferrer\">http://www.cplusplus.com/reference/initializer_list/initializer_list/</a></p>\n<blockquote>\n<p id=\"so_24109445_24109650_0\">initializer_list objects are automatically constructed as if an array\n  of elements of type T was allocated</p>\n</blockquote>\n<p>thus they can't be used with something like <code>std::initializer_list&lt;int&amp;&gt;</code>. The reason is the same for which the following gives a compiler error</p>\n<pre><code>int&amp; arr[20];\n</code></pre>\n<blockquote>\n<p id=\"so_24109445_24109650_1\">error: declaration of \u2018arr\u2019 as array of references</p>\n</blockquote>\n<p>and that is dictated by the C++ standard: <a href=\"https://stackoverflow.com/a/1164306/1938163\">https://stackoverflow.com/a/1164306/1938163</a></p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:18.597", "Id": "24109650", "Score": "3", "CreationDate": "2014-06-08T18:52:00.530", "LastActivityDate": "2014-06-08T18:52:00.530"}, "24109445": {"CommentCount": "2", "ViewCount": "1485", "PostTypeId": "1", "LastEditorUserId": "1095108", "CreationDate": "2014-06-08T18:28:53.810", "LastActivityDate": "2014-06-21T18:26:55.150", "Title": "std::initializer_list and reference types", "AcceptedAnswerId": "24109747", "LastEditDate": "2014-06-21T18:26:55.150", "Id": "24109445", "Score": "5", "Body": "<p>Can a <code>std::initializer_list</code> contain reference types (both rvalue and lvalue)? Or does one have to use pointers or a reference wrapper (such as <code>std::ref</code>)?</p>\n<p>EDIT:</p>\n<p>Perhaps more clarification is due:</p>\n<p>I have a member variable, <code>::std::vector&lt;std::function&lt;void()&gt; &gt;</code>, into which I would like to forward a lambda object. This would usually be accomplished with <code>emplace_back</code>, but I wanted to do it in the constructor's initialization list. Alas, as I read, this would make forwarding impossible.</p>\n", "Tags": "<c++><c++11><initializer-list>", "OwnerUserId": "1095108", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24109445_24109747_4": {"section_id": 6955, "quality": 1.0, "length": 9}, "so_24109445_24109747_2": {"section_id": 6955, "quality": 1.0, "length": 9}}, "n3337": {"so_24109445_24109747_4": {"section_id": 6702, "quality": 1.0, "length": 9}, "so_24109445_24109747_2": {"section_id": 6702, "quality": 1.0, "length": 9}}, "n4659": {"so_24109445_24109747_4": {"section_id": 8452, "quality": 1.0, "length": 9}, "so_24109445_24109747_2": {"section_id": 8452, "quality": 1.0, "length": 9}}}, "24109747": {"ParentId": "24109445", "PostTypeId": "2", "CommentCount": "3", "Body": "\n<blockquote>\n<p id=\"so_24109445_24109747_0\">Can a <code>std::initializer_list</code> contain reference types (both rvalue and lvalue)?</p>\n</blockquote>\n<p><code>std::initializer_list&lt;T&gt;</code> doesn't hold references to its elements. It uses <em>copy-semantics</em> by holding its values as <code>const</code> objects:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_24109445_24109747_3\"><code>18.9</code> <strong>Initializer List</strong> <code>[support.initlist]</code></p>\n<p id=\"so_24109445_24109747_4\">An object of type <code>initializer_list&lt;E&gt;</code> provides access to an array of objects of type <code>const E</code>.</p>\n</blockquote>\n</blockquote>\n<p>An <code>initializer_list</code> of references will cause a compilation error because iternally pointers are used for iterators:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;initializer_list&gt;\nint main()\n{\n    int x;\n    std::initializer_list&lt;int&amp;&gt; l = {x};\n\n    // In instantiation of 'class std::initializer_list&lt;int&amp;&gt;':\n    // error: forming pointer to reference type 'int&amp;'\n\n    // typedef const _E*  iterator;\n}\n</code></pre>\n<p>An <code>initializer_list</code> also doesn't support move-semantics as <code>const</code> objects cannot be moved from. Holding your objects in a <code>std::reference_wrapper&lt;T&gt;</code> is the most viable solution if you wish to maintain reference-semantics.</p>\n", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2014-06-08T19:07:49.170", "Id": "24109747", "Score": "4", "CreationDate": "2014-06-08T19:01:09.290", "LastActivityDate": "2014-06-08T19:07:49.170"}});