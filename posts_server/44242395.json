post_cb({"bq_ids": {"n4140": {"so_44242395_44242881_0": {"length": 15, "quality": 0.9375, "section_id": 392}}, "n3337": {"so_44242395_44242881_0": {"length": 15, "quality": 0.9375, "section_id": 383}}, "n4659": {"so_44242395_44242881_0": {"length": 15, "quality": 0.9375, "section_id": 409}}}, "44242881": {"Id": "44242881", "PostTypeId": "2", "Body": "<p>From ISO [class.conv.fct]:</p>\n<blockquote>\n<p id=\"so_44242395_44242881_0\">A conversion function may be explicit (7.1.2), in which case it is\n  only considered as a user-defined conversion for direct-initialization\n  (8.5). Otherwise, user-defined conversions are not restricted to use\n  in assignments and initializations.</p>\n</blockquote>\n<pre><code>double b { A { .0 } }; // fine\ndouble d = A { .0 }; // wrong\n</code></pre>\n", "LastActivityDate": "2017-05-29T12:46:09.120", "CommentCount": "0", "CreationDate": "2017-05-29T12:46:09.120", "ParentId": "44242395", "Score": "0", "OwnerUserId": "1983409"}, "44242395": {"ViewCount": "71", "Body": "<p>I've encountered a strange behavior (in my eyes) of vector::emplace_back() in gcc (version 6.3.1). It implicitly casts a type to another one even though the conversion operator declared as explicit.</p>\n<pre><code>class A\n{\npublic:\n    explicit A(double value) :\n        value{value}\n    {}\n\n    explicit operator double() const\n    {\n        return value;\n    }\n\nprivate:\n    double value;\n};\n\nint main()\n{\n    A a{0.0};\n    std::vector&lt;double&gt; values;\n    values.emplace_back(a); // &lt;- no error here!    \n\n    return 0;\n}\n</code></pre>\n<p>Is it a bug or a feature? </p>\n", "Title": "Implicit conversion for explicit operator", "CreationDate": "2017-05-29T12:22:17.760", "LastActivityDate": "2017-05-29T12:46:09.120", "CommentCount": "2", "PostTypeId": "1", "Id": "44242395", "Score": "1", "OwnerUserId": "1240657", "Tags": "<c++><std>", "AnswerCount": "2"}, "44242527": {"Id": "44242527", "PostTypeId": "2", "Body": "<p>It is basically as Jarod42 wrote in the comments, but here are some details. </p>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/container/vector/emplace_back\" rel=\"nofollow noreferrer\"><code>emplace_back</code> method</a> emplaces an element which </p>\n<blockquote>\n<p id=\"so_44242395_44242527_0\">is constructed through std::allocator_traits::construct</p>\n</blockquote>\n<p>If you look at <a href=\"http://en.cppreference.com/w/cpp/memory/allocator/construct\" rel=\"nofollow noreferrer\"><code>construct</code></a>, you can see it uses <a href=\"http://en.cppreference.com/w/cpp/language/new\" rel=\"nofollow noreferrer\">placement <code>new</code></a>. It is essentially something like</p>\n<pre><code>new((void *)p) T(val)\n</code></pre>\n<p>which is an explicit ctor call.</p>\n", "LastActivityDate": "2017-05-29T12:28:50.560", "CommentCount": "0", "CreationDate": "2017-05-29T12:28:50.560", "ParentId": "44242395", "Score": "1", "OwnerUserId": "3510736"}});