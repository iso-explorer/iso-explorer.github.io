post_cb({"14125911": {"Id": "14125911", "PostTypeId": "2", "Body": "<p>Though the behavior of the cast is not defined by the \"core\" of the standard, this case is explicitly described as invalid in the C99 rationale document (6.3.2.3, <em>Pointers</em>):</p>\n<blockquote>\n<p id=\"so_14125474_14125911_0\">Nothing is said about pointers to functions, which may be incommensurate with object pointers and/or integers.</p>\n<p id=\"so_14125474_14125911_1\">Even with an explicit cast, it is invalid to convert a function pointer to an object pointer or a pointer to void, or vice versa.</p>\n</blockquote>\n<p>And since it may be useful, it is also mentioned in the Annex J of the standard as a \"common extension\" (C11 Standard J.5.7, <em>Function pointer casts</em>):</p>\n<blockquote>\n<p id=\"so_14125474_14125911_2\">A pointer to an object or to <strong><code>void</code></strong> may be cast to a pointer to a function, allowing data to be invoked as a function (6.5.4).</p>\n<p id=\"so_14125474_14125911_3\">A pointer to a function may be cast to a pointer to an object or to <strong><code>void</code></strong>, allowing a\n  function to be inspected or modified (for example, by a debugger) (6.5.4).</p>\n</blockquote>\n<p>Describing this as an extension means that this is not part of the standard requirements (but it wouldn't be needed, the omission of any explicit behavior is enough).</p>\n", "LastEditorUserId": "1202636", "LastActivityDate": "2013-01-02T17:29:40.677", "Score": "5", "CreationDate": "2013-01-02T16:53:55.763", "ParentId": "14125474", "CommentCount": "0", "LastEditDate": "2013-01-02T17:29:40.677", "OwnerUserId": "1202636"}, "14125474": {"ViewCount": "1863", "Body": "<p>Am i wrong about the following?</p>\n<p>C++ standards says that conversion between pointer-to-function and pointer-to-object (and back) is conditionnaly-supported with implementation-defined semantics, while all C standards says that this is illegal in all cases, right?</p>\n<pre><code>void foo() {}\n\nint main(void)\n{\n    void (*fp)() = foo;\n    void* ptr = (void*)fp;\n    return 0;\n}\n</code></pre>\n<p><strong>ISO/IEC 14882:2011</strong></p>\n<p>5.2.10 Reinterpret cast [expr.reinterpret.cast]</p>\n<blockquote>\n<p id=\"so_14125474_14125474_0\">8 Converting a function pointer to an object pointer type or vice\n  versa is conditionally-supported. The meaning of such a conversion is\n  implementation-defined, except that if an implementation supports\n  conversions in both directions, converting a prvalue of one type to\n  the other type and back, possibly with different cvqualification,\n  shall yield the original pointer value.</p>\n</blockquote>\n<p>I can't find anything about it in C standard right now...</p>\n", "Title": "Casts between pointer-to-function and pointer-to-object in C and C++", "CreationDate": "2013-01-02T16:23:15.977", "LastActivityDate": "2013-01-02T17:29:40.677", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "Id": "14125474", "Score": "12", "OwnerUserId": "1608835", "Tags": "<c++><c>", "AnswerCount": "4"}, "14125633": {"Id": "14125633", "PostTypeId": "2", "Body": "<p>In all C standards the conversion between pointer-to-function and pointer-to-object is not defined, in C++ before C++11, the conversion was not allowed and compilers had to give an error, but there were compilers which accepted the conversion for C and backward compatibility and because is useful for things like dynamically loaded libraries access (for instance the <code>dlsym</code> POSIX function mandates its use). C++11 introduced the notion of <em>conditionally-supported</em> features an used it to adapt the standard with the existing practice. Now either the compiler should reject the program trying to do such conversion or it should respect the limited constraints given. </p>\n", "LastEditorUserId": "136208", "LastActivityDate": "2013-01-02T16:53:52.790", "Score": "5", "CreationDate": "2013-01-02T16:35:24.633", "ParentId": "14125474", "CommentCount": "4", "LastEditDate": "2013-01-02T16:53:52.790", "OwnerUserId": "136208"}, "bq_ids": {"n4140": {"so_14125474_14125911_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 6047}, "so_14125474_14125474_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 6047}}, "n3337": {"so_14125474_14125911_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 5815}, "so_14125474_14125474_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 5815}}, "n4659": {"so_14125474_14125911_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 7546}, "so_14125474_14125474_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 7546}}}, "14125994": {"Id": "14125994", "PostTypeId": "2", "Body": "<p><ul>\n<li>In C++03, such conversions were illegal (not UB). The compiler was supposed to issue a diagnostic. A lot of compilers on Unix systems didn't issue a diagnostic. This was essentially a clash between standards, POSIX vs C++.</li>\n<li>In C++11, such conversions are \"conditionally supported\". No diagnostic is required if the system does supports such conversions; there's nothing to diagnose.</li>\n<li>In C, such conversions officially are undefined behavior, so no diagnostic is required. If the system happens to do the \"right\" thing, well that's one way to implement UB.</li>\n<li>In C99, this is once again UB. However, the standard also lists such conversions as one of the \"common extensions\" to the language:</li></ul></p>\n<blockquote>\n<p id=\"so_14125474_14125994_0\">J.5.7 Function pointer casts<br>\n  A pointer to an object or to void may be cast to a pointer to a function, allowing data to be invoked as a function (6.5.4).<br>\n  A pointer to a function may be cast to a pointer to an object or to void, allowing a function to be inspected or modified (for example, by a debugger) (6.5.4).</br></br></p></blockquote>\n", "LastActivityDate": "2013-01-02T16:59:50.437", "Score": "8", "CreationDate": "2013-01-02T16:59:50.437", "ParentId": "14125474", "CommentCount": "1", "OwnerUserId": "774499"}, "14125516": {"Id": "14125516", "PostTypeId": "2", "Body": "<p>You're right, the C(99) standard says nothing about conversion from pointer-to-function to pointer-to-object, therefore it's undefined behaviour.<sup>*</sup></p>\n<p><hr>\n<sub>*Note, however, that it does define behaviour between pointer-to-function types.</sub></hr></p>\n", "LastActivityDate": "2013-01-02T16:26:05.470", "Score": "9", "CreationDate": "2013-01-02T16:26:05.470", "ParentId": "14125474", "CommentCount": "10", "OwnerUserId": "129570"}});