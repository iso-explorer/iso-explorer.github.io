post_cb({"bq_ids": {"n4140": {"so_47075871_47076760_3": {"length": 37, "quality": 0.9024390243902439, "section_id": 6111}, "so_47075871_47076760_2": {"length": 23, "quality": 0.8518518518518519, "section_id": 6111}, "so_47075871_47097868_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 6091}, "so_47075871_47076760_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 6091}, "so_47075871_47076760_1": {"length": 7, "quality": 1.0, "section_id": 6111}, "so_47075871_47076760_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 6111}}, "n3337": {"so_47075871_47076760_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5876}, "so_47075871_47076760_4": {"length": 4, "quality": 0.5714285714285714, "section_id": 407}}, "n4659": {"so_47075871_47076760_3": {"length": 37, "quality": 0.9024390243902439, "section_id": 7608}, "so_47075871_47076760_2": {"length": 23, "quality": 0.8518518518518519, "section_id": 7608}, "so_47075871_47097868_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7587}, "so_47075871_47076760_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7587}, "so_47075871_47076760_1": {"length": 7, "quality": 1.0, "section_id": 7608}, "so_47075871_47076760_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 7608}}}, "47075871": {"ViewCount": "2668", "Body": "<p>As far as compiler optimizations go, is it legal and/or possible to change a heap allocation to a stack allocation? Or would that break the <a href=\"https://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule\">as-if rule</a>?</p>\n<p>For example, say this is the original version of the code</p>\n<pre><code>{\n    Foo* f = new Foo();\n    f-&gt;do_something();\n    delete f;\n}\n</code></pre>\n<p>Would a compiler be able to change this to the following</p>\n<pre><code>{\n    Foo f{};\n    f.do_something();\n}\n</code></pre>\n<p>I wouldn't think so, because that would have implications if the original version was relying on things like custom allocators. Does the standard say anything specifically about this?</p>\n", "AcceptedAnswerId": "47076760", "Title": "Can the compiler optimize from heap to stack allocation?", "CreationDate": "2017-11-02T12:54:05.137", "Id": "47075871", "CommentCount": "10", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-11-03T11:10:22.283", "LastEditorUserId": "2296458", "LastActivityDate": "2017-11-03T15:32:15.817", "Score": "59", "OwnerUserId": "2296458", "Tags": "<c++><memory-management><language-lawyer><compiler-optimization>", "AnswerCount": "3"}, "47076607": {"Id": "47076607", "PostTypeId": "2", "Body": "<p>These are not equivalent. <code>f.do_something()</code> might throw, in which case the first object remains in memory, the second gets destructed.</p>\n", "LastActivityDate": "2017-11-02T13:30:54.977", "CommentCount": "2", "CreationDate": "2017-11-02T13:30:54.977", "ParentId": "47075871", "Score": "6", "OwnerUserId": "6292621"}, "47076760": {"Id": "47076760", "PostTypeId": "2", "Body": "<p>Yes, it's legal. <code>expr.new/10</code> of C++14:</p>\n<blockquote>\n<p id=\"so_47075871_47076760_0\">An implementation is allowed to omit a call to a replaceable global\n  allocation function (18.6.1.1, 18.6.1.2). When it does so, the <strong>storage\n  is instead provided by the implementation</strong> or provided by extending the\n  allocation of another new-expression.</p>\n</blockquote>\n<p><code>expr.delete/7</code>:</p>\n<blockquote>\n<p id=\"so_47075871_47076760_1\">If the value of the operand of the delete-expression is not a null\n  pointer value, then:</p>\n<p id=\"so_47075871_47076760_2\">\u2014 If the allocation call for the new-expression for the object to be\n  deleted was not omitted and the allocation was not extended (5.3.4),\n  the delete-expression shall call a deallocation function (3.7.4.2).\n  The value returned from the allocation call of the new-expression\n  shall be passed as the \ufb01rst argument to the deallocation function.</p>\n<p id=\"so_47075871_47076760_3\">\u2014 Otherwise, if the allocation was extended or was provided by\n  extending the allocation of another new- expression, and the\n  delete-expression for every other pointer value produced by a\n  new-expression that had storage provided by the extended\n  new-expression has been evaluated, the delete-expression shall call a\n  deallocation function. The value returned from the allocation call of\n  the extended new-expression shall be passed as the \ufb01rst argument to\n  the deallocation function.</p>\n<p id=\"so_47075871_47076760_4\">\u2014 Otherwise, <strong>the delete-expression will not call a deallocation\n  function</strong> (3.7.4.2).</p>\n</blockquote>\n<p>So, in summary, it's legal to replace <code>new</code> and <code>delete</code> with something implementation defined, like using the stack instead of heap.</p>\n<p>Note: As Massimiliano Janes comments, the compiler could not stick exactly to this transformation for your sample, if <code>do_something</code> throws: the compiler should omit destructor call of <code>f</code> in this case (while your transformed sample does call the destructor in this case). But other than that, it is free to put <code>f</code> into the stack.</p>\n", "LastEditorUserId": "8157187", "LastActivityDate": "2017-11-02T14:19:47.303", "Score": "50", "CreationDate": "2017-11-02T13:39:17.393", "ParentId": "47075871", "CommentCount": "3", "OwnerUserId": "8157187", "LastEditDate": "2017-11-02T14:19:47.303"}, "47097868": {"Id": "47097868", "PostTypeId": "2", "Body": "<p>I'd like to point out something IMO not stressed enough in the other answers:</p>\n<pre><code>struct Foo {\n    static void * operator new(std::size_t count) {\n        std::cout &lt;&lt; \"Hey ho!\" &lt;&lt; std::endl;\n        return ::operator new(count);\n    }\n};\n</code></pre>\n<p>An allocation <code>new Foo()</code> cannot generally be replaced, because:</p>\n<blockquote>\n<p id=\"so_47075871_47097868_0\">An implementation is allowed to omit a call to a replaceable <strong>global</strong> allocation function (18.6.1.1, 18.6.1.2). When it does so, the storage is instead provided by the implementation or provided by extending the allocation of another new-expression.</p>\n</blockquote>\n<p>Thus, like in the <code>Foo</code> example above, the <code>Foo::operator new</code> needs to be called. Omitting this call would change the observable behavior of the program.</p>\n<p>Real world example: <code>Foo</code>s might need to reside in some special memory region (like memory mapped IO) to function properly.</p>\n", "LastEditorUserId": "1116364", "LastActivityDate": "2017-11-03T15:32:15.817", "Score": "4", "CreationDate": "2017-11-03T14:14:54.937", "ParentId": "47075871", "CommentCount": "0", "OwnerUserId": "1116364", "LastEditDate": "2017-11-03T15:32:15.817"}});