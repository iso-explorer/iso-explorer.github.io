post_cb({"15077078": {"ParentId": "15045879", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-02-25T21:44:34.303", "Score": "5", "LastEditorUserId": "1041090", "LastEditDate": "2013-02-26T18:46:37.063", "Id": "15077078", "OwnerUserId": "1041090", "Body": "<p>It looks like you've found a GCC bug. These both name the implicitly-declared copy constructor:</p>\n<pre><code>template Foo&lt;int&gt;::Foo( const Foo&lt;int&gt;&amp; foo );\ntemplate Foo&lt;float&gt;::Foo( const Foo&lt;float&gt;&amp; foo );\n</code></pre>\n<p>Per [temp.explicit]p4,</p>\n<blockquote>\n<p id=\"so_15045879_15077078_0\">If the declaration of the explicit instantiation names an implicitly-declared special member function (Clause 12), the program is ill-formed.</p>\n</blockquote>\n<p>Therefore Clang is correct to reject this code.</p>\n", "LastActivityDate": "2013-02-26T18:46:37.063"}, "15045879": {"CommentCount": "1", "AcceptedAnswerId": "15077078", "PostTypeId": "1", "LastEditorUserId": "1119818", "CreationDate": "2013-02-23T21:23:23.893", "LastActivityDate": "2013-02-26T18:46:37.063", "LastEditDate": "2013-02-24T15:51:17.547", "ViewCount": "2270", "FavoriteCount": "1", "Title": "Explicit instantiation of templated constructor for template class", "Id": "15045879", "Score": "11", "Body": "<p>I am uncertain if it is a bug in Clang 3.2 or a violation of C++03, but it appears that explicit instantiation of templated constructors for template classes fails, but explicit instantiation of templated member functions of template classes succeeds.</p>\n<p>For instance, the following compiles without a problem with both clang++ and g++:</p>\n<pre><code>template&lt;typename T&gt;\nclass Foo\n{\npublic:\n    template&lt;typename S&gt;\n    void Bar( const Foo&lt;S&gt;&amp; foo )\n    { }\n};\ntemplate class Foo&lt;int&gt;;\ntemplate class Foo&lt;float&gt;;\n\ntemplate void Foo&lt;int&gt;::Bar( const Foo&lt;int&gt;&amp; foo );\ntemplate void Foo&lt;int&gt;::Bar( const Foo&lt;float&gt;&amp; foo );\ntemplate void Foo&lt;float&gt;::Bar( const Foo&lt;int&gt;&amp; foo );\ntemplate void Foo&lt;float&gt;::Bar( const Foo&lt;float&gt;&amp; foo );\n</code></pre>\n<p>whereas the following compiles without warning with g++ but fails with clang++:</p>\n<pre><code>template&lt;typename T&gt;\nclass Foo\n{\npublic:\n    template&lt;typename S&gt;\n    Foo( const Foo&lt;S&gt;&amp; foo )\n    { }\n};\ntemplate class Foo&lt;int&gt;;\ntemplate class Foo&lt;float&gt;;\n\ntemplate Foo&lt;int&gt;::Foo( const Foo&lt;int&gt;&amp; foo );\ntemplate Foo&lt;int&gt;::Foo( const Foo&lt;float&gt;&amp; foo );\ntemplate Foo&lt;float&gt;::Foo( const Foo&lt;int&gt;&amp; foo );\ntemplate Foo&lt;float&gt;::Foo( const Foo&lt;float&gt;&amp; foo );\n</code></pre>\n<p>In particular, I see two error messages of the form:</p>\n<pre><code>TemplateMember.cpp:12:20: error: explicit instantiation refers to member\n      function 'Foo&lt;int&gt;::Foo' that is not an instantiation\ntemplate Foo&lt;int&gt;::Foo( const Foo&lt;int&gt;&amp; foo );\n                   ^\nTemplateMember.cpp:9:16: note: explicit instantiation refers here\ntemplate class Foo&lt;int&gt;;\n               ^\n</code></pre>\n<p>Is this a violation of the standard or a bug in clang++?</p>\n", "Tags": "<c++><clang><clang++><explicit-instantiation>", "OwnerUserId": "1119818", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_15045879_15077078_0": {"section_id": 253, "quality": 1.0, "length": 10}}, "n3337": {"so_15045879_15077078_0": {"section_id": 244, "quality": 1.0, "length": 10}}, "n4659": {"so_15045879_15077078_0": {"section_id": 260, "quality": 1.0, "length": 10}}}});