post_cb({"bq_ids": {"n4140": {"so_22991549_22991760_1": {"length": 18, "quality": 0.9, "section_id": 7151}, "so_22991549_22991760_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 7151}}, "n3337": {"so_22991549_22991760_1": {"length": 18, "quality": 0.9, "section_id": 6895}, "so_22991549_22991760_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6895}}, "n4659": {"so_22991549_22991760_1": {"length": 14, "quality": 0.7, "section_id": 8652}, "so_22991549_22991760_0": {"length": 9, "quality": 0.6, "section_id": 4051}}}, "22991760": {"Id": "22991760", "PostTypeId": "2", "Body": "<p>I believe that part of the standard is relevant to your question (\u00a73.6.2/2): </p>\n<blockquote>\n<p id=\"so_22991549_22991760_0\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5)\n  before any other initialization takes place.[...]</p>\n</blockquote>\n<p>So in this case, even before the compiler looks at your definition of <code>bar</code>, it has already zero-initialized it.</p>\n<p>As it is specified a bit further in the standard, there shall be two phases for static variables initialization (emphasis mine).</p>\n<blockquote>\n<p id=\"so_22991549_22991760_1\">Together, zero-initialization and constant initialization are called <strong>static initialization</strong>; all other initialization\n  is <strong>dynamic initialization</strong>. <strong>Static initialization shall be performed before any dynamic initialization takes place</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "1594913", "LastActivityDate": "2014-04-10T15:13:10.430", "Score": "14", "CreationDate": "2014-04-10T14:59:54.880", "ParentId": "22991549", "CommentCount": "0", "OwnerUserId": "1594913", "LastEditDate": "2014-04-10T15:13:10.430"}, "22991549": {"ViewCount": "276", "Body": "<p>Consider following code example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstatic int bar = bar;\n\nint main()\n{\n    int foo = foo;\n    std::cout &lt;&lt; \"foo = \" &lt;&lt; foo &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"bar = \" &lt;&lt; bar &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I get following compiler warning:</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:7:15: warning: 'foo' is used uninitialized in this function [-Wuninitialized]\n     int foo = foo;\n               ^\n</code></pre>\n<p>Output:</p>\n<pre><code>foo = 0\nbar = 0\n</code></pre>\n<p>I expected this warning as foo is used unitialised. Instead of 0, 'foo' can be anything. \nSelf-assignment is undefined.</p>\n<p>But why is the the self-assignment of 'bar' not warned? Is this assignment of 'bar' defined or undefined behaviour and why?</p>\n<p>I know, static variables of elementar data types are initialised with '0' but in this case, the variable 'bar' is used during its initialisation. I'm wondering, if this is defined behaviour and the '0' is the expected output. (Which would explain, that no compiler warning occurs).</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/925cc0d0f3d9e5b1\">Link to Live example</a></p>\n", "AcceptedAnswerId": "22991760", "Title": "Initialisation of static variable with itself", "CreationDate": "2014-04-10T14:51:20.397", "Id": "22991549", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-04-10T15:13:10.430", "Score": "13", "OwnerUserId": "3293086", "Tags": "<c++>", "AnswerCount": "1"}});