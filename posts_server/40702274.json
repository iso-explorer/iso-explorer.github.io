post_cb({"40702482": {"ParentId": "40702274", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_40702274_40702482_0\">Accepting Clang's interpretation of the standard, what is a canonical way to enforce compile-time checks on template parameters?</p>\n</blockquote>\n<p>You can drop the \"specialization\"/overload of <code>foo()</code> for <code>A&lt;0&gt;</code> and define the general template as follows:</p>\n<pre><code>template &lt;class T, size_t N&gt;\nT foo(A&lt;N&gt;) {\n  Assert&lt;N != 0&gt;();\n  return T(N - 1);\n}\n</code></pre>\n<p>With C++11 you don't need to define your own static Assert and can use the language provided <code>static_assert</code>:</p>\n<pre><code>template &lt;class T, size_t N&gt;\nT foo(A&lt;N&gt;) {\n  static_assert(N!=0, \"N must be positive\");\n  return T(N - 1);\n}\n</code></pre>\n", "OwnerUserId": "6394138", "PostTypeId": "2", "Id": "40702482", "Score": "5", "CreationDate": "2016-11-20T09:28:27.550", "LastActivityDate": "2016-11-20T09:28:27.550"}, "40703439": {"ParentId": "40702274", "CommentCount": "0", "Body": "<p>Both compilers are correct. As usual, this is controlled by <a href=\"https://timsong-cpp.github.io/cppwp/temp.res#8\" rel=\"noreferrer\">[temp.res]/8</a>:</p>\n<blockquote>\n<p id=\"so_40702274_40703439_0\">Knowing which names are type names allows the syntax of every template\n  to be checked. The program is ill-formed, no diagnostic required, if:</p>\n<ul>\n<li><p id=\"so_40702274_40703439_1\">no valid specialization can be generated for a template or a substatement of a <code>constexpr if</code> statement ([stmt.if]) within a\n  template and the template is not instantiated, or</p></li>\n<li><p id=\"so_40702274_40703439_2\">every valid specialization of a variadic template requires an empty template parameter pack, or</p></li>\n<li><p id=\"so_40702274_40703439_3\">a hypothetical instantiation of a template immediately following its definition would be ill-formed due to a construct that does not depend\n  on a template parameter, or</p></li>\n<li><p id=\"so_40702274_40703439_4\">the interpretation of such a construct in the hypothetical instantiation is different from the interpretation of the\n  corresponding construct in any actual instantiation of the template. </p></li>\n</ul>\n</blockquote>\n<p>Your template runs afoul of the third bullet point.</p>\n<p>As to the correct solution, either a suitable <code>static_assert</code> can be used, or you can explicitly delete the undesirable overload:</p>\n<pre><code>template &lt;class T&gt;\nT foo(A&lt;0&gt;) = delete;\n</code></pre>\n<p>The former allows better error messages, the latter plays more nicely with other metaprogramming.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "40703439", "Score": "5", "CreationDate": "2016-11-20T11:25:05.097", "LastActivityDate": "2016-11-20T11:25:05.097"}, "bq_ids": {"n4140": {"so_40702274_40703439_2": {"section_id": 175, "quality": 1.0, "length": 10}, "so_40702274_40703439_0": {"section_id": 175, "quality": 0.9230769230769231, "length": 12}, "so_40702274_40703439_1": {"section_id": 175, "quality": 0.6153846153846154, "length": 8}}, "n3337": {"so_40702274_40703439_2": {"section_id": 169, "quality": 1.0, "length": 10}, "so_40702274_40703439_0": {"section_id": 169, "quality": 0.9230769230769231, "length": 12}, "so_40702274_40703439_1": {"section_id": 169, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_40702274_40703439_2": {"section_id": 180, "quality": 1.0, "length": 10}, "so_40702274_40703439_4": {"section_id": 180, "quality": 1.0, "length": 12}, "so_40702274_40703439_3": {"section_id": 180, "quality": 1.0, "length": 15}, "so_40702274_40703439_0": {"section_id": 180, "quality": 0.9230769230769231, "length": 12}, "so_40702274_40703439_1": {"section_id": 180, "quality": 0.9230769230769231, "length": 12}}}, "40702330": {"ParentId": "40702274", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I believe clang is correct, since <code>Assert&lt;false&gt;</code> is not a dependent type.   </p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/dependent_name\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/dependent_name</a></p>\n<blockquote>\n<p id=\"so_40702274_40702330_0\">Non-dependent names are looked up and bound at the point of template definition. This binding holds even if at the point of template instantiation there is a better match:</p>\n</blockquote>\n<p>Don't make specializations that cannot be valid.  Make them general purpose and use static_assert (with a dependent value) to check for invalid template argument types/values.   <code>static_assert(std::is_same&lt;T, int&gt;::value)</code> or <code>static_assert(N != 0)</code></p>\n", "OwnerUserId": "493106", "LastEditorUserId": "493106", "LastEditDate": "2016-11-20T09:42:01.640", "Id": "40702330", "Score": "5", "CreationDate": "2016-11-20T09:06:36.697", "LastActivityDate": "2016-11-20T09:42:01.640"}, "40702274": {"CommentCount": "0", "ViewCount": "207", "PostTypeId": "1", "LastEditorUserId": "4634174", "CreationDate": "2016-11-20T08:57:21.540", "LastActivityDate": "2016-11-20T11:25:05.097", "Title": "Template instantiation in GNU C++ and Clang", "AcceptedAnswerId": "40702330", "LastEditDate": "2016-11-20T09:26:37.333", "Id": "40702274", "Score": "7", "Body": "<p>Looks like the rules for template instantiation in Clang (3.8) and GNU C++ (4.9) are not the same. Here is an example:</p>\n<pre><code>#include &lt;cstddef&gt;\n\ntemplate &lt;bool&gt;\nclass Assert {\n  Assert();          // private constructor for Assert&lt;false&gt;\n};\n\ntemplate &lt;&gt;\nclass Assert&lt;true&gt; { // implicit public constructor for Assert&lt;true&gt;\n};\n\ntemplate &lt;size_t N&gt;\nclass A {\n};\n\ntemplate &lt;class T, size_t N&gt;\nT foo(A&lt;N&gt;) {\n  return T(N - 1);\n}\n\ntemplate &lt;class T&gt;\nT foo(A&lt;0&gt;) {        // foo is not defined for N=0\n  Assert&lt;false&gt;();\n  return T(0);\n}\n\nint main(int argc, char **argv) {\n  foo&lt;int&gt;(A&lt;3&gt;());\n  return 0;\n}\n</code></pre>\n<p>This minimal example shows a template function, <code>foo</code>, that is generalized over a type <code>T</code> and a natural number <code>N</code>. This function is not defined for <code>N=0</code>, so I'd like to use the <code>Assert</code> class to signal a compiler error if it is used this way.</p>\n<p>This code is accepted by the GNU compiler (and by Visual C++ 2015, as well), but Clang gives an error for \"calling a private constructor of class <code>Assert&lt;false&gt;</code>\".</p>\n<p>So who is right? As I see it, there is no call for <code>foo&lt;T,0&gt;</code>, so there is no need to instantiate this template...</p>\n<p>EDIT: Accepting Clang's interpretation of the standard, what is a canonical way to enforce compile-time checks on template parameters?</p>\n", "Tags": "<c++><templates><gcc><instantiation><clang++>", "OwnerUserId": "4634174", "AnswerCount": "3"}});