post_cb({"bq_ids": {"n4140": {"so_1447141_1447360_0": {"length": 8, "quality": 1.0, "section_id": 344}}, "n3337": {"so_1447141_1447360_0": {"length": 8, "quality": 1.0, "section_id": 334}}, "n4659": {"so_1447141_1447360_0": {"length": 5, "quality": 0.625, "section_id": 309}}}, "1447141": {"ViewCount": "962", "Body": "<p>a template parameter can be used in another template parameter that follows it this way :</p>\n<pre><code>template&lt;typename T, T N&gt;\nstruct s\n{\n};\n</code></pre>\n<p>But is it possible to reference \"T\" if it is declared after \"N\" ?</p>\n<p>This does not work :</p>\n<pre><code>template&lt;T N, typename T&gt;\nstruct s\n{\n};\n</code></pre>\n<p>Can we help the compiler by pre-declaring \"T\" or doing anything else ?</p>\n<p>Thanks by advance.</p>\n<p>EDIT : as the first two replies were asking \"why are you willing to do that ?\" I'll explain the goal :</p>\n<p>I would like to make the compiler infer the type \"T\" in order to make the use of templated classes easier.</p>\n<p>For example :</p>\n<pre><code>template&lt;typename T, T A, T B&gt;\nstruct sum\n{\n    static T const value = A + B;\n};\n</code></pre>\n<p>This template can be used this way :</p>\n<pre><code>sum&lt;int, 1, 2&gt;::value\n</code></pre>\n<p>But it would be better if it could be used this way :</p>\n<pre><code>sum&lt;1, 2&gt;::value\n</code></pre>\n<p>Technically it's should be possible because the compiler knows the types of \"1\" and \"2\" : \"int\", and in fact it uses these informations to find the best overload for a function.\nSo by declaring the template this way :</p>\n<pre><code>template&lt;T A, T B, typename T&gt;\nstruct sum\n{\n    static T const value = A + B;\n};\n</code></pre>\n<p>the compiler could use its capability to infer the last parameter from the informations provided by the first and the second one, and then find the best template to instantiate.</p>\n", "AcceptedAnswerId": "1447360", "Title": "How to use a template parameter in another template parameter declared before", "CreationDate": "2009-09-18T22:48:11.947", "Id": "1447141", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-09-18T23:25:53.540", "LastEditorUserId": "145757", "LastActivityDate": "2009-09-19T00:45:47.120", "Score": "5", "OwnerUserId": "145757", "Tags": "<c++><templates><parameters><declaration>", "AnswerCount": "3"}, "1447158": {"Id": "1447158", "PostTypeId": "2", "Body": "<p>Below is rubbish as I didn't read your question properly.</p>\n<p>Indeed, I don't see any point in what you are trying to achieve either.    </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T, T N&gt;\nstruct s\n{\n    T size() { return N; }\n};\n\n\nint main()\n{\n    s&lt;int, 4&gt; x;\n    std::cout &lt;&lt; x.size()&lt;&lt; '\\n';\n\n    //s&lt;float, 3.14&gt; f; //this doesn't compile\n}\n</code></pre>\n<p>This compiles for me with GCC and Comeau Online.</p>\n<p>I think the problem is with the type of T you are trying to use. Non-type template arguments only support integral types, and then pointers to objects with external linkage (or something like that and perhaps a few other very limited things).</p>\n", "LastActivityDate": "2009-09-18T22:54:58.313", "CommentCount": "0", "CreationDate": "2009-09-18T22:54:58.313", "ParentId": "1447141", "Score": "0", "OwnerUserId": "155693"}, "1447145": {"Id": "1447145", "PostTypeId": "2", "Body": "<p>You can't. I don't see the point why you are doing it too.</p>\n", "LastActivityDate": "2009-09-18T22:50:16.727", "CommentCount": "0", "CreationDate": "2009-09-18T22:50:16.727", "ParentId": "1447141", "Score": "0", "OwnerUserId": "45262"}, "1447360": {"Id": "1447360", "PostTypeId": "2", "Body": "<p>Like others say - No this isn't possible, the compiler can't infer the type of <code>T</code> from the non-type <em>template</em> arguments (in the case of functions, it infers types from the <em>function</em> arguments):</p>\n<p><code>14.8.2.4/12</code>:</p>\n<blockquote>\n<p id=\"so_1447141_1447360_0\">A template type argument cannot be deduced from the type of a non-type template-argument. </p>\n</blockquote>\n<p>In any case, no deduction will be made for the arguments of a class template anyway. An example for a function template might be</p>\n<pre><code>template&lt;int&gt; struct having_int { };\ntemplate&lt;typename T, T i&gt; void f(having_int&lt;i&gt;);\nint main() { having_int&lt;0&gt; h; f(h); }\n</code></pre>\n<p>In this case, <code>T</code> won't be deduced as <code>int</code> - you have to explicitly specify it. </p>\n", "LastActivityDate": "2009-09-19T00:45:47.120", "CommentCount": "2", "CreationDate": "2009-09-19T00:45:47.120", "ParentId": "1447141", "Score": "6", "OwnerUserId": "34509"}});