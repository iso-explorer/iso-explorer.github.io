post_cb({"7236534": {"ParentId": "7236417", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>[EDIT] According to the comments (people way smarter than me) my answer is completely wrong.  However, make your destructors virtual anyway. [/EDIT]</p>\n<p>In C++, I consider upcasting to a base type is only safe if the destructor is virtual. Technically it's safe, but in reality, you almost always want a virtual destructor.  For instance:</p>\n<pre><code>class Base {\n   int thingy;\n};\nclass Derived : Base{\n   int *array;\n   Derived() {array = new int[100];}\n   ~Derived() {delete [] array;}\n};\nint main() {\n    std::auto_ptr&lt;Base&gt; obj(dynamic_cast&lt;Base*&gt;(new Derived));\n}\n</code></pre>\n<p>In this example, when obj goes out of scope, the auto_ptr automatically calls the Base's destructor, <em>but does not call the Derived deconstructor</em> because the type is a Base, not a Derived.  [Edit: corrections] This causes Undefined behaviour (at the very best, it causes a memory leak).  I haven't any idea why C++ doesn't require a virtual destructor to compile down casts, it really should.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2012-07-19T15:59:04.427", "Id": "7236534", "Score": "-1", "CreationDate": "2011-08-29T22:04:12.823", "LastActivityDate": "2012-07-19T15:59:04.427"}, "7236702": {"ParentId": "7236417", "CommentCount": "3", "Body": "<p>There are two main reasons. The first is that there's just no use case for it. The point of inheritance is virtual functions. If you're not using virtual functions, don't use inheritance.</p>\n<p>The second is that it's very complex to actually implement <code>dynamic_cast</code> that works without virtual functions due to the C++ compilation model. The only way to realistically implement <code>dynamic_cast</code> is to operate on the virtual table- a binary blob of data is typeless. You could define a class and then only <code>dynamic_cast</code> it in one TU- now one TU thinks the class has a vtable and one doesn't. That would be instant bad. Allowing <code>dynamic_cast</code> on classes that do not already have virtual functions would be, well, <code>export</code>, which means \"Exceedingly difficult to implement\".</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "7236702", "Score": "0", "CreationDate": "2011-08-29T22:24:50.710", "LastActivityDate": "2011-08-29T22:24:50.710"}, "7236417": {"CommentCount": "4", "AcceptedAnswerId": "7236534", "PostTypeId": "1", "LastEditorUserId": "493106", "CreationDate": "2011-08-29T21:53:45.210", "LastActivityDate": "2016-10-25T22:34:34.310", "LastEditDate": "2016-10-25T22:34:34.310", "ViewCount": "6402", "FavoriteCount": "1", "Title": "Does dynamic_cast really work for multiple inheritance?", "Id": "7236417", "Score": "5", "Body": "<p>I wanted to see if it's possible to create \"interfaces\", inherit them, and then check at runtime if any random class implements that interface. This is what I have:</p>\n<pre><code>struct GameObject {\n    int x,y;\n    std::string name;\n\n    virtual void blah() { };\n};\n\nstruct Airholder {\n   int oxygen;\n   int nitrogen;\n};\n\nstruct Turf : public GameObject, public Airholder {\n   Turf() : GameObject() {\n      name = \"Turf\";\n   }\n\n   void blah() { };\n};\n\nvoid remove_air(GameObject* o) {\n   Airholder* a = dynamic_cast&lt;Airholder*&gt;(o);\n   if(!a) return;\n   a-&gt;oxygen   = 0;\n   a-&gt;nitrogen = 0;\n};\n</code></pre>\n<p>Now, it works. The documentation says that it works, the test example works.. But also, it didn't compile until I added a virtual method to GameObject. The thing is, I really don't know if the feature is intended to be used like that. What made me wonder there is the fact that I have to declare a virtual function for the class I'm checking. But obviously, there is none, the class I'm checking itself has no virtual functions, in fact my whole code has nothing to do with virtual functions, it's an entirely different approach.</p>\n<p>So, I guess my question is: If what I'm doing really works, why do I need a virtual function to give my class a vtable? Why can't I declare the class a \"runtime type\" or something without virtual functions?</p>\n", "Tags": "<c++><polymorphism><multiple-inheritance>", "OwnerUserId": "661171", "AnswerCount": "6"}, "7236543": {"ParentId": "7236417", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_7236417_7236543_0\">So, I guess my question is: If what I'm doing really works, why do I need a virtual function to give my class a vtable? Why can't I declare the class a \"runtime type\" or something without virtual functions?</p>\n</blockquote>\n<p>The presence of a virtual function is what makes a class polymorphic in C++. <code>dynamic_cast&lt;&gt;</code> only works with polymorphic classes. (The compiler will reject a dynamic cast on a non-polymorphic object.)</p>\n<p>Polymorphism has a cost, both in time and in space (memory). Calls to virtual functions are now indirect, typically implemented in terms of a virtual table. In some critical places, those costs are simply unacceptable.  So the language provides means of avoiding these costs.</p>\n<p>Similar concepts exist elsewhere in the language. The underlying principle is that if you don't want to use some high-falutin' feature you shouldn't have to pay for the fact the some people do want to use it.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "7236543", "Score": "1", "CreationDate": "2011-08-29T22:04:48.223", "LastActivityDate": "2011-08-29T22:04:48.223"}, "7236548": {"ParentId": "7236417", "CommentCount": "1", "Body": "<p><code>dynamic_cast</code> requires the type to be polymorphic, and without any virtual methods (or at least a virtual destructor) a type is not (run-time) polymorphic. Simple inheritance is not enough. The run-time type information used by <code>dynamic_cast</code> is stored alongside the vtable if remember correctly.</p>\n", "OwnerUserId": "452688", "PostTypeId": "2", "Id": "7236548", "Score": "0", "CreationDate": "2011-08-29T22:05:22.327", "LastActivityDate": "2011-08-29T22:05:22.327"}, "7236895": {"ParentId": "7236417", "CommentCount": "0", "Body": "<p>As others have said, you need at least one virtual function to make a class polymorphic. Why this matters is that dynamic_cast itself is a polymorphic operation! Given a base class pointer, it returns different results based on the actual object it is called on.</p>\n<p>C++ has a \"don't pay for what you don't need\" philosophy, thus the vtable (or whatever mechanism the compiler uses) is not provided unless there's a need as determined by the presence of a virtual function. Evidently the designers of C++ thought this was a reasonable requirement for the proper operation of dynamic_cast or they would have provided a way to generate a vtable without it.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "7236895", "Score": "0", "CreationDate": "2011-08-29T22:49:28.553", "LastActivityDate": "2011-08-29T22:49:28.553"}, "7236574": {"ParentId": "7236417", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>\u00a7 5.2.7 of the standard says:</p>\n<ol>\n<li>The result of the expression dynamic_cast(v) is the result of converting the expression v to type\nT. T shall be a pointer or reference to a complete class type, or \u201cpointer to cv void\u201d. Types shall not be\ndefined in a dynamic_cast. The dynamic_cast operator shall not cast away constness (5.2.11).</li>\n<li>If T is a pointer type, v shall be an rvalue of a pointer to complete class type, and the result is an rvalue of\ntype T. If T is a reference type, v shall be an lvalue of a complete class type, and the result is an lvalue of\nthe type referred to by T.</li>\n<li>If the type of v is the same as the required result type (which, for convenience, will be called R in this\ndescription), or it is the same as R except that the class object type in R is more cv-qualified than the class\nobject type in v, the result is v (converted if necessary).</li>\n<li>If the value of v is a null pointer value in the pointer case, the result is the null pointer value of type R.</li>\n<li><p>If T is \u201cpointer to cv1 B\u201d and v has type \u201cpointer to cv2 D\u201d such that B is a base class of D, the result is a\npointer to the unique B sub-object of the D object pointed to by v. Similarly, if T is \u201creference to cv1 B\u201d\nand v has type \u201ccv2 D\u201d such that B is a base class of D, the result is an lvalue for the unique60) B sub-object\nof the D object referred to by v. In both the pointer and reference cases, cv1 shall be the same cvqualification\nas, or greater cv-qualification than, cv2, and B shall be an accessible unambiguous base class\nof D. [Example:</p>\n<p>struct B {};<br/>\nstruct D : B {};<br/>\nvoid foo(D* dp)<br/>\n{<br/>\n\u00a0\u00a0\u00a0\u00a0\u00a0B* bp = dynamic_cast(dp); // equivalent to B* bp = dp;<br/>\n}<br/>\n\u2014end example]</p></li>\n<li><strong>Otherwise, v shall be a pointer to or an lvalue of a polymorphic type (10.3).</strong></li>\n</ol>\n<p>And <strong>to make a type polymorphic, it needs a virtual function</strong>, as per \u00a7 10.3:</p>\n<blockquote>\n<p id=\"so_7236417_7236574_0\">Virtual functions support dynamic binding and object-oriented programming. A class that declares or\n  inherits a virtual function is called a polymorphic class.</p>\n</blockquote>\n<p>So the reason why is \"because the standard says so.\" That doesn't really tell you <em>why</em> the standard says so though, but the other answers cover that well I think.</p>\n", "OwnerUserId": "726361", "LastEditorUserId": "726361", "LastEditDate": "2011-08-29T22:29:05.877", "Id": "7236574", "Score": "5", "CreationDate": "2011-08-29T22:07:28.047", "LastActivityDate": "2011-08-29T22:29:05.877"}, "bq_ids": {"n4140": {"so_7236417_7236574_0": {"section_id": 7002, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_7236417_7236574_0": {"section_id": 6748, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_7236417_7236574_0": {"section_id": 8499, "quality": 0.9333333333333333, "length": 14}}}});