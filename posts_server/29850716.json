post_cb({"bq_ids": {"n4140": {"so_29850716_29850921_2": {"length": 32, "quality": 0.9411764705882353, "section_id": 41}, "so_29850716_29850922_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 41}}, "n3337": {"so_29850716_29850921_2": {"length": 32, "quality": 0.9411764705882353, "section_id": 38}, "so_29850716_29850922_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 38}}, "n4659": {"so_29850716_29850921_2": {"length": 32, "quality": 0.9411764705882353, "section_id": 41}, "so_29850716_29850922_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 41}}}, "29850921": {"Id": "29850921", "PostTypeId": "2", "Body": "<p>Stroustrup discusses this case in section 4.5 of <a href=\"https://www.usenix.org/legacy/publications/compsystems/1989/fall_stroustrup.pdf\" rel=\"nofollow noreferrer\">his 1989 multiple inheritance paper [PDF]</a>:</p>\n<blockquote>\n<p id=\"so_29850716_29850921_0\">The solution is to elaborate the conversion (casting) operation to\n  test for the pointer-value 0 [...]</p>\n<p id=\"so_29850716_29850921_1\">The added complexity and run-time overhead are a test and an\n  increment.</p>\n</blockquote>\n<p>The implementation checks explicitly for null-values and ensures that the result of the cast is still a null-value. This was true in C++98 and has not changed with C++11 and <code>nullptr</code>.</p>\n<p>This is especially important in the case of multiple base classes, where a cast from a derived class to one of the base classes might require changing the actual value of the pointer.</p>\n<p>In your example, the layout of <code>C</code> in memory will first contain the bytes for <code>IA</code>, followed by the bytes for <code>IB</code>. Casting to <code>IA</code> is trival, as a pointer to the beginning of <code>C</code> will also point to the beginning of the <code>IA</code> part of <code>C</code>. Casting to <code>IB</code> on the other hand, requires shifting the <code>C</code> pointer by the size of <code>IA</code>. Performing this shifting in the nullptr case would lead to a non-null pointer after the cast, hence the special treatment for nulls.</p>\n<p>As <a href=\"https://stackoverflow.com/a/29850922/577603\">pointed out by aschepler</a>, the relevant section in the standard is [conv.ptr] \u00a74.10:</p>\n<blockquote>\n<p id=\"so_29850716_29850921_2\">A prvalue of type \u201cpointer to <em>cv</em> <code>D</code>\u201d, where <code>D</code> is a class type, can be\n  converted to a prvalue of type \u201cpointer to <em>cv</em> <code>B</code>\u201d, where <code>B</code> is a base\n  class [...] of <code>D</code>. [...] The result of the conversion is a pointer to\n  the base class subobject of the derived class object. The null pointer\n  value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-24T15:24:39.707", "Score": "7", "CreationDate": "2015-04-24T15:02:27.157", "ParentId": "29850716", "CommentCount": "3", "LastEditDate": "2017-05-23T11:44:06.293", "OwnerUserId": "577603"}, "29850922": {"Id": "29850922", "PostTypeId": "2", "Body": "<p>Upcasting a null pointer is well-defined to give you another null pointer:</p>\n<p>4.10p3:</p>\n<blockquote>\n<p id=\"so_29850716_29850922_0\">A prvalue of type \"pointer to <em>cv</em> <code>D</code>\", where <code>D</code> is a class type, can be converted to a prvalue of type \"pointer to <em>cv</em> <code>B</code>\", where <code>B</code> is a base class of <code>D</code>.  ...  The null pointer value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n", "LastActivityDate": "2015-04-24T15:02:31.290", "Score": "8", "CreationDate": "2015-04-24T15:02:31.290", "ParentId": "29850716", "CommentCount": "0", "OwnerUserId": "459640"}, "29850716": {"ViewCount": "131", "Body": "<p>I'm wondering whether the following code leads to undefined behavior:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;cstdio&gt;\n\nstruct IA { \n  virtual ~IA() {}\n  int a = 0;\n};\nstruct IB {\n  virtual ~IB() {}\n  int b = 0;\n};\nstruct C: IA, IB {};\n\nint main() {\n  C* pc = nullptr;\n  IB* pib = pc;\n  std::printf(\"%p %p\", (void*)pc, (void*)pib);\n}\n</code></pre>\n", "AcceptedAnswerId": "29850921", "Title": "Does upcasting a null pointer lead to undefined behavior", "CreationDate": "2015-04-24T14:53:24.580", "Id": "29850716", "CommentCount": "4", "LastEditDate": "2015-04-24T15:03:21.383", "PostTypeId": "1", "LastEditorUserId": "1348273", "LastActivityDate": "2015-04-24T15:24:39.707", "Score": "15", "OwnerUserId": "1348273", "Tags": "<c++><language-lawyer><implicit-conversion><nullptr><upcasting>", "AnswerCount": "2"}});