post_cb({"19877363": {"ParentId": "19877218", "CommentCount": "0", "Body": "<p>The Standard actually has a rule for this, in \u00a712.6.2/9:</p>\n<blockquote>\n<p id=\"so_19877218_19877363_0\">If a given non-static data member has both a brace-or-equal-initializer and a mem-initializer, the initialization specified by the mem-initializer is performed, and the non-static data member\u2019s brace-or-equal-initializer\n  is ignored. [ Example: Given</p>\n<pre><code>struct A {\nint i = /\u2217 some integer expression with side effects \u2217/ ;\nA(int arg) : i(arg) { }\n// ...\n};\n</code></pre>\n<p id=\"so_19877218_19877363_1\">the A(int) constructor will simply initialize i to the value of arg, and the side effects in i\u2019s brace-or-equal-\n  initializer will not take place. \u2014 end example ]</p>\n</blockquote>\n<p>So in the case you described, if the default constructor is called, only the initialization defined there will be performed, and <code>test</code> will be <code>1</code>.</p>\n", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "19877363", "Score": "14", "CreationDate": "2013-11-09T14:59:18.073", "LastActivityDate": "2013-11-09T14:59:18.073"}, "bq_ids": {"n4140": {"so_19877218_19877363_0": {"section_id": 436, "quality": 0.9444444444444444, "length": 17}, "so_19877218_19877363_1": {"section_id": 436, "quality": 0.75, "length": 12}}, "n3337": {"so_19877218_19877363_0": {"section_id": 428, "quality": 0.9444444444444444, "length": 17}, "so_19877218_19877363_1": {"section_id": 428, "quality": 0.75, "length": 12}}, "n4659": {"so_19877218_19877363_0": {"section_id": 455, "quality": 0.8333333333333334, "length": 15}, "so_19877218_19877363_1": {"section_id": 455, "quality": 0.8125, "length": 13}}}, "19877218": {"CommentCount": "0", "AcceptedAnswerId": "19877363", "PostTypeId": "1", "LastEditorUserId": "212378", "CreationDate": "2013-11-09T14:39:35.493", "LastActivityDate": "2016-04-03T00:33:38.327", "LastEditDate": "2016-04-03T00:33:38.327", "ViewCount": "221", "FavoriteCount": "1", "Title": "Does C++11 re-initialize initialized member fields?", "Id": "19877218", "Score": "7", "Body": "<p>C++11 now supports setting the value of a class member field at declaration time, like this:</p>\n<pre><code>class MyClass\n{\nprivate\n  int test = 0;\n}\n</code></pre>\n<p>If I also initialize the variable in the constructor like this:</p>\n<pre><code>class MyClass\n{\nprivate\n  int test = 0;\n\npublic:\n  MyClass() : test(1)\n  {\n  }\n}\n</code></pre>\n<p>will this cause the variable to have its value set twice, or the specification dictates that the compiler should optimise this to initialize the variable only once? If the specification doesn't dictate anything, do you know the behaviour of the famous compilers (e.g. MSVC, GCC, etc.) with respect to this?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "196697", "AnswerCount": "1"}});