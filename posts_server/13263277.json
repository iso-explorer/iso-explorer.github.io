post_cb({"41203433": {"ParentId": "13263277", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>GCC 5.3.0</strong> (C++ stdlib is inside GCC source):</p>\n<ul>\n<li><a href=\"https://github.com/gcc-mirror/gcc/blob/2bc376d60753a58b10cb179f8edb7d72bee7a88b/libstdc%2B%2B-v3/include/std/chrono#L776\" rel=\"nofollow noreferrer\"><code>high_resolution_clock</code></a> is an alias for <code>system_clock</code></li>\n<li><a href=\"https://github.com/gcc-mirror/gcc/blob/2bc376d60753a58b10cb179f8edb7d72bee7a88b/libstdc++-v3/src/c++11/chrono.cc#L54\" rel=\"nofollow noreferrer\"><code>system_clock</code></a> forwards to the first of the following that is available:\n\n<ul>\n<li><code>clock_gettime(CLOCK_REALTIME, ...)</code></li>\n<li><code>gettimeofday</code></li>\n<li><code>time</code></li>\n</ul></li>\n<li><a href=\"https://github.com/gcc-mirror/gcc/blob/2bc376d60753a58b10cb179f8edb7d72bee7a88b/libstdc++-v3/src/c++11/chrono.cc#L82\" rel=\"nofollow noreferrer\"><code>steady_clock</code></a> forwards to the first of the following that is available:\n\n<ul>\n<li><code>clock_gettime(CLOCK_MONOTONIC, ...)</code></li>\n<li><code>system_clock</code></li>\n</ul></li>\n</ul>\n<p>Then <code>CLOCK_REALTIME</code> vs <code>CLOCK_MONOTONIC</code> is explained at: <a href=\"https://stackoverflow.com/questions/3523442/difference-between-clock-realtime-and-clock-monotonic\">Difference between CLOCK_REALTIME and CLOCK_MONOTONIC?</a></p>\n", "OwnerUserId": "895245", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:19.983", "Id": "41203433", "Score": "6", "CreationDate": "2016-12-17T21:56:49.087", "LastActivityDate": "2016-12-17T21:56:49.087"}, "13263277": {"CommentCount": "5", "AcceptedAnswerId": "13263328", "PostTypeId": "1", "LastEditorUserId": "1392132", "CreationDate": "2012-11-07T04:48:41.493", "LastActivityDate": "2016-12-17T21:56:49.087", "LastEditDate": "2015-12-17T01:52:31.663", "ViewCount": "23706", "FavoriteCount": "15", "Title": "Difference between std::system_clock and std::steady_clock?", "Id": "13263277", "Score": "61", "Body": "<p>What is the difference between <code>std::system_clock</code> and <code>std::steady_clock</code>? (An example case that illustrate different results/behaviours would be great).</p>\n<p>If my goal is to precisely measure execution time of functions (like a benchmark), what would be the best choice between <code>std::system_clock</code>, <code>std::steady_clock</code> and <code>std::high_resolution_clock</code>?</p>\n", "Tags": "<c++><c++11><timer><chrono>", "OwnerUserId": "882932", "AnswerCount": "3"}, "13263328": {"ParentId": "13263277", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>From N3376:</p>\n<p>20.11.7.1 [time.clock.system]/1:</p>\n<blockquote>\n<p id=\"so_13263277_13263328_0\">Objects of class <code>system_clock</code> represent wall clock time from the system-wide realtime clock.</p>\n</blockquote>\n<p>20.11.7.2 [time.clock.steady]/1:</p>\n<blockquote>\n<p id=\"so_13263277_13263328_1\">Objects of class <code>steady_clock</code> represent clocks for which values of <code>time_point</code> never decrease as physical time advances and for which values of <code>time_point</code> advance at a steady rate relative to real time. That is, the clock may not be adjusted.</p>\n</blockquote>\n<p>20.11.7.3 [time.clock.hires]/1:</p>\n<blockquote>\n<p id=\"so_13263277_13263328_2\">Objects of class <code>high_resolution_clock</code> represent clocks with the shortest tick period. <code>high_resolution_clock</code> may be a synonym for <code>system_clock</code> or <code>steady_clock</code>.</p>\n</blockquote>\n<p>For instance, the system wide clock might be affected by something like daylight savings time, at which point the actual time listed at some point in the future can actually be a time in the past. (E.g. in the US, in the fall time moves back one hour, so the same hour is experienced \"twice\") However, <code>steady_clock</code> is not allowed to be affected by such things.</p>\n<p>Another way of thinking about \"steady\" in this case is in the requirements defined in the table of 20.11.3 [time.clock.req]/2:</p>\n<blockquote>\n<p id=\"so_13263277_13263328_3\">In Table 59 <code>C1</code> and <code>C2</code> denote clock types. <code>t1</code> and <code>t2</code> are values returned by <code>C1::now()</code> where the call returning <code>t1</code> happens before the call returning <code>t2</code> and both of these calls occur before <code>C1::time_point::max()</code>. [ Note: this means <code>C1</code> did not wrap around between <code>t1</code> and <code>t2</code>. \u2014end note ]  </p>\n<p id=\"so_13263277_13263328_4\">Expression: <code>C1::is_steady</code><br>\n  Returns: <code>const bool</code><br>\n  Operational Semantics: <code>true</code> if <code>t1 &lt;= t2</code> is always true and the time between clock ticks is constant, otherwise <code>false</code>.</br></br></p>\n</blockquote>\n<p>That's all the standard has on their differences.</p>\n<p>If you want to do benchmarking, your best bet is probably going to be <code>std::high_resolution_clock</code>, because it is likely that your platform uses a high resolution timer (e.g. <code>QueryPerformanceCounter</code> on Windows) for this clock. (EDIT: MSVC++, as of Visual Studio 2013, does not yet use <code>QueryPerformanceCounter</code> for this clock :( ) However, if you're benchmarking, you should really consider using platform specific timers for your benchmark, because different platforms handle this differently. For instance, some platforms might give you some means of determining the actual number of clock ticks the program required (independent of other processes running on the same CPU). Better yet, get your hands on a real profiler and use that.</p>\n", "OwnerUserId": "82320", "LastEditorUserId": "82320", "LastEditDate": "2014-01-10T17:46:44.750", "Id": "13263328", "Score": "47", "CreationDate": "2012-11-07T04:54:57.180", "LastActivityDate": "2014-01-10T17:46:44.750"}, "13266477": {"ParentId": "13263277", "CommentCount": "4", "Body": "<p>Billy provided a great answer based on the ISO C++ standard that I fully agree with. However there is another side of the story - real life. It seems that right now there is really no difference between those clocks in implementation of popular compilers:</p>\n<p>gcc 4.8:</p>\n<pre><code>#ifdef _GLIBCXX_USE_CLOCK_MONOTONIC\n   ...\n#else\n  typedef system_clock steady_clock;\n#endif\n  typedef system_clock high_resolution_clock;\n</code></pre>\n<p>Visual Studio 2012:</p>\n<pre><code>class steady_clock : public system_clock\n{   // wraps monotonic clock\npublic:\n  static const bool is_monotonic = true;    // retained\n  static const bool is_steady = true;\n};\n\ntypedef system_clock high_resolution_clock;\n</code></pre>\n<p>In case of gcc you can check if you deal with steady clock simply by checking <code>is_steady</code> and behave accordingly. However VS2012 seems to cheat a bit here :-)</p>\n<p>If you need high precision clock I recommend for now writing your own clock that conforms to C++11 official clock interface and wait for implementations to catch up. It will be much better approach than using OS specific API directly in your code.\nFor Windows you can do it like that:</p>\n<pre><code>// Self-made Windows QueryPerformanceCounter based C++11 API compatible clock\nstruct qpc_clock {\n  typedef std::chrono::nanoseconds                       duration;      // nanoseconds resolution\n  typedef duration::rep                                  rep;\n  typedef duration::period                               period;\n  typedef std::chrono::time_point&lt;qpc_clock, duration&gt;   time_point;\n  static bool is_steady;                                                // = true\n  static time_point now()\n  {\n    if(!is_inited) {\n      init();\n      is_inited = true;\n    }\n    LARGE_INTEGER counter;\n    QueryPerformanceCounter(&amp;counter);\n    return time_point(duration(static_cast&lt;rep&gt;((double)counter.QuadPart / frequency.QuadPart *\n                                                period::den / period::num)));\n  }\n\nprivate:\n  static bool is_inited;                                                // = false\n  static LARGE_INTEGER frequency;\n  static void init()\n  {\n    if(QueryPerformanceFrequency(&amp;frequency) == 0)\n      throw std::logic_error(\"QueryPerformanceCounter not supported: \" + std::to_string(GetLastError()));\n  }\n};\n</code></pre>\n<p>For Linux it is even easier. Just read the man page of <code>clock_gettime</code> and modify the code above.</p>\n", "OwnerUserId": "1749706", "PostTypeId": "2", "Id": "13266477", "Score": "41", "CreationDate": "2012-11-07T09:13:17.257", "LastActivityDate": "2012-11-07T09:13:17.257"}, "bq_ids": {"n4140": {"so_13263277_13263328_2": {"section_id": 4853, "quality": 1.0, "length": 13}, "so_13263277_13263328_3": {"section_id": 4739, "quality": 0.8518518518518519, "length": 23}, "so_13263277_13263328_4": {"section_id": 4739, "quality": 0.7647058823529411, "length": 13}, "so_13263277_13263328_0": {"section_id": 4848, "quality": 1.0, "length": 10}, "so_13263277_13263328_1": {"section_id": 4852, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_13263277_13263328_2": {"section_id": 4648, "quality": 1.0, "length": 13}, "so_13263277_13263328_3": {"section_id": 4546, "quality": 0.8518518518518519, "length": 23}, "so_13263277_13263328_4": {"section_id": 4546, "quality": 0.7647058823529411, "length": 13}, "so_13263277_13263328_0": {"section_id": 4643, "quality": 1.0, "length": 10}, "so_13263277_13263328_1": {"section_id": 4647, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_13263277_13263328_2": {"section_id": 6278, "quality": 1.0, "length": 13}, "so_13263277_13263328_3": {"section_id": 6150, "quality": 0.8518518518518519, "length": 23}, "so_13263277_13263328_4": {"section_id": 6150, "quality": 0.7647058823529411, "length": 13}, "so_13263277_13263328_0": {"section_id": 6273, "quality": 1.0, "length": 10}, "so_13263277_13263328_1": {"section_id": 6277, "quality": 0.9583333333333334, "length": 23}}}});