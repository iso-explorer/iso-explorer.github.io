post_cb({"bq_ids": {"n4140": {"so_41817052_41817619_0": {"length": 22, "quality": 1.0, "section_id": 480}}, "n3337": {"so_41817052_41817619_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 471}}, "n4659": {"so_41817052_41817619_0": {"length": 22, "quality": 1.0, "section_id": 502}}}, "41817109": {"Id": "41817109", "PostTypeId": "2", "Body": "<p><sup>The part of the question about a class <code>X</code> was added after this answer. It's fundamentally different in that <code>X</code> copy constructor does not copy. I've therefore answered that <a href=\"https://stackoverflow.com/a/41817619/464581\">separately</a>.</sup></p>\n<p>Regarding the original question's <code>WeirdString</code>: it's your class so the standard places no requirements on it.</p>\n<p>However, the standard effectively let compilers assume that <em>a copy constructor copies, and nothing else</em>.</p>\n<p>Happily that's what your copy constructor does, but if (I know this doesn't apply to you, but if) it had mainly had some other effect, that you relied on, then the copy elision rules could wreak havoc with your expectations.</p>\n<p>Where you'd want a guaranteed owning instance (e.g. in order to pass it to a thread) you can simply provide an <code>unshare</code> member function, or a constructor with a tag argument, or a factory function.</p>\n<p>You can generally not rely on a copy constructor being invoked.</p>\n<hr>\n<p>To avoid problems you'd better take care of all possible copying, which means also the copy assignment operator, <code>operator=</code>.</p>\n<p>Otherwise you risk that two or more instances all think they own the buffer, and are responsible for deallocation.</p>\n<p>It's also a good idea to support move semantics by defining a move a constructor and declaring or defining a move assignment operator.</p>\n<p>You can be more sure of correctness of all this by using a <strong><code>std::unique_ptr&lt;char[]&gt;</code></strong> to hold the buffer pointer.</p>\n<p>Among other things that prevents inadvertent copying via a copy assignment operator.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-24T01:15:37.087", "Score": "4", "CreationDate": "2017-01-23T22:51:28.340", "ParentId": "41817052", "CommentCount": "4", "OwnerUserId": "464581", "LastEditDate": "2017-05-23T12:09:23.957"}, "41817619": {"Id": "41817619", "PostTypeId": "2", "Body": "<p>Regarding the new question's code</p>\n<pre><code>struct X {\n    int i;\n\n    X(int i)\n      : i(i)\n    { }\n\n    X(X const&amp; rhs)\n      : i(rhs.i + 1)\n    { }        ~~~~\n};\n\nX getX();\nconst auto x = X(getX());\n</code></pre>\n<p>Here the copy constructor doesn't copy, so you're breaking the compiler's assumption that it does.</p>\n<p>With C++17 I believe you're guaranteed that it's not invoked in the above example. However I don't have a draft of C++17 at hand.</p>\n<p>With C++14 and earlier it's up to the compiler whether the copy constructor is invoked for the call of <code>getX</code>, and whether it's invoked for the copy initialization. </p>\n<b>C++14 \u00a712.8/31 <sub><sup>class.copy/31</sup></sub></b>:\n\n<blockquote>\n<p id=\"so_41817052_41817619_0\"><strong>\u201d</strong> When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects.</p>\n</blockquote>\n<p>This is not <em>undefined behavior</em> in the sense of the formal meaning of that term, where it can invoke nasal demons. For the formal terminology I'd choose <em>unspecified behavior</em>, because that's behavior that depends on the implementation and not required to be documented. But as I see it what name one chooses doesn't really matter: what matters is that the standard just says that under the specified conditions a compiler can optimize a copy/move construction, regardless of the side effects of the optimized-away constructor \u2013 which you therefore can not and should not rely on.</p>\n", "LastActivityDate": "2017-01-23T23:37:51.220", "CommentCount": "1", "CreationDate": "2017-01-23T23:37:51.220", "ParentId": "41817052", "Score": "5", "OwnerUserId": "464581"}, "41817052": {"ViewCount": "268", "Body": "<p>Suppose I have a weird string type, that either owns or doesn't own it's underlying buffer:</p>\n<pre><code>class WeirdString {\nprivate:\n    char* buffer;\n    size_t length;\n    size_t capacity;\n    bool owns;\n\npublic:\n    // Non-owning constructor\n    WeirdString(char* buffer, size_t length, size_t capacity)\n        : buffer(buffer), length(length), capacity(capacity), owns(false)\n    { }\n\n    // Make an owning copy\n    WeirdString(WeirdString const&amp; rhs)\n        : buffer(new char[rhs.capacity])\n        , length(rhs.length)\n        , capacity(rhs.capacity)\n        , owns(true)\n    {\n        memcpy(buffer, rhs.buffer, length);\n    }\n\n    ~WeirdString() {\n        if (owns) delete [] buffer;\n    }\n};\n</code></pre>\n<p>Does that copy constructor violate the standard somewhere? Consider:</p>\n<pre><code>WeirdString get(); // this returns non-owning string\nconst auto s = WeirdString(get());\n</code></pre>\n<p><code>s</code> is either owning or non-owning depending on whether or not the additional copy constructor got elided, which in C++14 and earlier is permitted but optional (though in C++17 is guaranteed). That Schr\u00f6dinger's ownership model suggests that this copy constructor is, in itself, undefined behavior.</p>\n<p>Is it? </p>\n<hr/>\n<p>A more illustrative example might be:</p>\n<pre><code>struct X {\n    int i;\n\n    X(int i)\n      : i(i)\n    { }\n\n    X(X const&amp; rhs)\n      : i(rhs.i + 1)\n    { }        ~~~~\n};\n\nX getX();\nconst auto x = X(getX());\n</code></pre>\n<p>Depending on which copies get elided, <code>x.i</code> could be 0, 1, or 2 more than whatever was returned in <code>getX()</code>. Does the standard say anything about this?</p>\n", "AcceptedAnswerId": "41817619", "Title": "Does the standard state that copies must be equivalent?", "CreationDate": "2017-01-23T22:47:13.003", "Id": "41817052", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-01-23T23:13:19.003", "LastEditorUserId": "2069064", "LastActivityDate": "2017-01-24T01:15:37.087", "Score": "9", "OwnerUserId": "2069064", "Tags": "<c++><language-lawyer><copy-constructor><copy-elision>", "AnswerCount": "2"}});