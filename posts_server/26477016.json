post_cb({"26477051": {"ParentId": "26477016", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A <code>std::list</code> is a doubly linked list, meaning that it can be sorted simply by modifying <em>pointers</em> within the list. No element assignments are necessary.</p>\n<p>A simple case would be something like:</p>\n<pre>\nhead   --&gt;   2   --&gt;   1   --&gt;   null\n</pre>\n<p>which can be sorted as:</p>\n<pre>\n         ______________\n        |              |\n        |              v\nhead   -'    2   &lt;--   1   +-&gt;   null\n             |             |\n             '-------------'\n</pre>\n<p>without copying <em>any</em> elements.</p>\n<p>In fact, as per <code>C++11 23.3.5.5 list operations /29</code>, the requirement to keep iterators and references valid means that, for efficiency, it really <em>can't</em> move things around:</p>\n<blockquote>\n<p id=\"so_26477016_26477051_0\">Effects: Sorts the list according to the <code>operator&lt;</code> or a <code>Compare</code> function object. <em>Does not affect the validity of iterators and references.</em></p>\n</blockquote>\n<hr>\n<p>A <code>std::vector</code>, on the other hand, keeps its items in a contiguous array so there are no pointers to manipulate. If you want it sorted, items have to be moved around.</p>\n</hr>", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2014-10-21T01:41:03.797", "Id": "26477051", "Score": "3", "CreationDate": "2014-10-21T00:20:51.017", "LastActivityDate": "2014-10-21T01:41:03.797"}, "26477016": {"CommentCount": "1", "ViewCount": "381", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-10-21T00:17:39.957", "LastActivityDate": "2014-10-21T01:41:03.797", "Title": "Assignment operations in sort() functions", "LastEditDate": "2014-10-21T00:27:57.460", "Id": "26477016", "Score": "1", "Body": "<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\n\nclass Int\n{\npublic:\n    Int(int i = 0) : m_i(i) { }\n\npublic:\n    bool operator&lt;(const Int&amp; a) const { return this-&gt;m_i &lt; a.m_i; }\n\n    Int&amp; operator=(const Int &amp;a)\n    {\n        this-&gt;m_i = a.m_i;\n        ++m_assignments;\n        return *this;\n    }\n\n    static int get_assignments() { return m_assignments; }\n\nprivate:\n    int m_i;\n    static int m_assignments;\n};\n\nint Int::m_assignments = 0;\n\nint main()\n{\n    std::list&lt;Int&gt; l({ Int(3), Int(1) });\n    l.sort();\n    std::cout &lt;&lt; (Int::get_assignments() &gt; 0 ? 1 : 0);\n\n    std::vector&lt;Int&gt; v({ Int(2), Int() });\n    std::sort(v.begin(), v.end());\n    std::cout &lt;&lt; (Int::get_assignments() &gt; 0 ? 2 : 0) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The above code prints out <code>02</code> which means that <code>std::list::sort()</code> doesn't perform any assignment operations (<code>operator=()</code>) on list's elements while <code>std::sort()</code> does perform at least 1 assignment operation on the elements of an <code>std::vector</code>.</p>\n<p>What does the difference stem from? Container classes? Sort implementations? The <code>Int</code> class implementation?</p>\n", "Tags": "<c++><c++11><stl><assignment-operator>", "OwnerUserId": "1030598", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26477016_26477051_0": {"section_id": 951, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_26477016_26477051_0": {"section_id": 939, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_26477016_26477051_0": {"section_id": 1012, "quality": 0.9230769230769231, "length": 12}}}});