post_cb({"bq_ids": {"n4140": {"so_32574459_32574835_1": {"section_id": 5824, "quality": 1.0, "length": 4}}, "n3337": {"so_32574459_32574835_1": {"section_id": 5595, "quality": 1.0, "length": 4}}, "n4659": {"so_32574459_32574835_1": {"section_id": 7285, "quality": 1.0, "length": 4}}}, "32574459": {"CommentCount": "3", "ViewCount": "143", "CreationDate": "2015-09-14T21:45:59.923", "LastActivityDate": "2015-09-14T22:20:48.737", "Title": "Memory ordering, instruction reordering and lack of happens-before relationship", "AcceptedAnswerId": "32574835", "PostTypeId": "1", "Id": "32574459", "Score": "3", "Body": "<p><strong>Relaxed ordering</strong></p>\n<p>Atomic operations tagged with std::memory_order_relaxed are not synchronization operations; only the modification order of each individual atomic object is shared between threads. Different objects have no ordering between themselves relative to other threads; operations can be seen out of order.</p>\n<p><strong>Example \u2013 Relaxed ordering</strong></p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;thread&gt;\n#include &lt;assert.h&gt;\nstd::atomic&lt;int&gt; x{ 0 };\nstd::atomic&lt;bool&gt; x_is_set{ false };\nstd::atomic&lt;int&gt; counter{ 0 };\nvoid f1()\n{\n    x.store(5, std::memory_order_relaxed);              // A\n    x_is_set.store(true, std::memory_order_relaxed);    // B\n}\nvoid f2()\n{\n    while (!x_is_set.load(std::memory_order_relaxed));  // C\n\n    if (x.load(std::memory_order_relaxed) == 5)         // D\n        ++counter;                                      // E\n}\nint main()\n{\n    std::thread t1{ f1 };\n    std::thread t2{ f2 };\n    t1.join();\n    t2.join();\n    assert(counter.load() == 1);                        // F\n}\n</code></pre>\n<p>There are no ordering constraints between thread <strong>t1</strong> and thread <strong>t2</strong>. Therefore, the store done in <strong>B</strong> can be seen by <strong>t2</strong> before the store done by <strong>A</strong>; the assert <strong>F</strong> in main() will fire in that case.</p>\n<p>The obvious solution to this issue is to make the store in <strong>B</strong> have <code>std::memory_order_release</code> and the load in <strong>C</strong> have <code>std::memory_order_acquire</code> for synchronization purposes. The assert in <strong>F</strong> would seemingly never fire.</p>\n<p><strong>Question</strong></p>\n<p>However, since there is no <em>happens-before</em> relationship between <strong>A</strong> and <strong>B</strong> (am I wrong?), can't the compiler/optimizer/CPU reorganize the instructions in function <code>f1()</code> such that <strong>B</strong> is <em>sequenced-before</em> <strong>A</strong>? This would cause <strong>C</strong> in function <code>f2()</code> to evaluate to <code>true</code>, but <strong>D</strong> would be <code>false</code>; the assert could fire.</p>\n<p>Is there anything preventing that issue from arising?</p>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "4683600", "AnswerCount": "1"}, "32574835": {"ParentId": "32574459", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_32574459_32574835_0\">since there is no happens-before relationship between A and B </p>\n</blockquote>\n<p>Wrong. [intro.multithread]/p14:</p>\n<blockquote>\n<p id=\"so_32574459_32574835_1\">An evaluation A <em>happens before</em> an evaluation B if:</p>\n<ul>\n<li>A is sequenced before B, or</li>\n<li>A inter-thread happens before B.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "32574835", "Score": "4", "CreationDate": "2015-09-14T22:20:48.737", "LastActivityDate": "2015-09-14T22:20:48.737"}});