post_cb({"10833512": {"CommentCount": "4", "CreationDate": "2012-05-31T12:21:14.723", "PostTypeId": "1", "AcceptedAnswerId": "10833580", "LastEditorUserId": "1054324", "LastActivityDate": "2013-12-19T16:19:38.357", "LastEditDate": "2013-12-19T16:19:38.357", "ViewCount": "3037", "FavoriteCount": "10", "Title": "Safe parallel read-only access to a STL container", "Id": "10833512", "Score": "19", "Body": "<p>I want access a STL based container <strong>read-only</strong> from <strong>parallel</strong> running threads. Without using any user implemented locking. The base of the following code is C++11 with a proper implementation of the standard.</p>\n<p><a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_concurrency.html\">http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_concurrency.html</a><br>\n<a href=\"http://www.sgi.com/tech/stl/thread_safety.html\">http://www.sgi.com/tech/stl/thread_safety.html</a><br>\n<a href=\"http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/threadsintro.html\">http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/threadsintro.html</a><br>\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/\">http://www.open-std.org/jtc1/sc22/wg21/</a> (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\">current draft</a> or <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">N3337</a>, which is essentially C++11 with minor errors and typos corrected)  </br></br></br></p>\n<blockquote>\n<p id=\"so_10833512_10833512_0\">23.2.2 Container data races [container.requirements.dataraces]</p>\n<p id=\"so_10833512_10833512_1\">For purposes of avoiding data races (17.6.5.9), implementations shall\n  consider the following functions to be const: begin, end, rbegin,\n  rend, front, back, data, find, lower_bound, upper_bound, equal_range,\n  at and, except in associative or unordered associative containers,\n  operator[].</p>\n<p id=\"so_10833512_10833512_2\">Notwithstanding (17.6.5.9), implementations are required\n  to avoid data races when the contents of the con- tained object in\n  different elements in the same sequence, excepting vector&lt;bool&gt;, are\n  modified concurrently.</p>\n<p id=\"so_10833512_10833512_3\">[ Note: For a vector&lt;int&gt; x with a size greater\n  than one, x[1] = 5 and *x.begin() = 10 can be executed concurrently\n  without a data race, but x[0] = 5 and *x.begin() = 10 executed\n  concurrently may result in a data race. As an exception to the general\n  rule, for a vector&lt;bool&gt; y, y[0] = true may race with y[1]\n  = true. \u2014 end note ]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_10833512_10833512_4\">17.6.5.9 Data race avoidance [res.on.data.races] 1 This section specifies requirements that implementations shall meet to prevent data\n  races (1.10). Every   standard library function shall meet each\n  requirement unless otherwise specified. Implementations may   prevent\n  data races in cases other than those specified below.</p>\n<p id=\"so_10833512_10833512_5\">2 A C++ standard\n  library function shall not directly or indirectly access objects\n  (1.10) accessible by threads   other than the current thread unless\n  the objects are accessed directly or indirectly via the function\u2019s\n  argu-   ments, including this.</p>\n<p id=\"so_10833512_10833512_6\">3 A C++ standard library function shall\n  not directly or indirectly modify objects (1.10) accessible by threads\n  other than the current thread unless the objects are accessed directly\n  or indirectly via the function\u2019s non-const   arguments, including\n  this.</p>\n<p id=\"so_10833512_10833512_7\">4 [ Note: This means, for example, that implementations can\u2019t\n  use a static object for internal purposes without   synchronization\n  because it could cause a data race even in programs that do not\n  explicitly share objects   between threads. \u2014 end note ]</p>\n<p id=\"so_10833512_10833512_8\">5 A C++ standard library function shall not access objects indirectly\n  accessible via its arguments or via   elements of its container\n  arguments except by invoking functions required by its specification\n  on those   container elements.</p>\n<p id=\"so_10833512_10833512_9\">6 Operations on iterators obtained by\n  calling a standard library container or string member function may<br>\n  access the underlying container, but shall not modify it. [ Note: In\n  particular, container operations that   invalidate iterators conflict\n  with operations on iterators associated with that container. \u2014 end\n  note ]</br></p>\n<p id=\"so_10833512_10833512_10\">7 Implementations may share their own internal objects between\n  threads if the objects are not visible to users   and are protected\n  against data races.</p>\n<p id=\"so_10833512_10833512_11\">8 Unless otherwise specified, C++ standard library\n  functions shall perform all operations solely within the   current\n  thread if those operations have effects that are visible (1.10) to\n  users.</p>\n<p id=\"so_10833512_10833512_12\">9 [ Note: This allows implementations to parallelize operations\n  if there are no visible side effects. \u2014 end note ]</p>\n</blockquote>\n<p><strong>Conclusion</strong><br>\nContainers are not thread safe! But it is safe to call <strong>const functions</strong> on containers from multiple parallel threads. So it is possible to do <strong>read-only</strong> operations from parallel threads without <strong>locking</strong>.\nAm I right?</br></p>\n<p>I pretend that their doesn't exist any faulty implementation and every implementation of the C++11 standard is correct.</p>\n<p>Sample:</p>\n<pre><code>// concurrent thread access to a stl container\n// g++ -std=gnu++11 -o p_read p_read.cpp -pthread -Wall -pedantic &amp;&amp; ./p_read\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;string&gt;\n#include &lt;unistd.h&gt;\n\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n\n#include &lt;map&gt;\n\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\nusing namespace std;\n\n// new in C++11\nusing str_map = map&lt;string, string&gt;;\n\n// thread is new in C++11\n// to_string() is new in C++11\n\nmutex m;\nconst unsigned int MAP_SIZE = 10000;\n\nvoid fill_map(str_map&amp; store) {\n    int key_nr;\n    string mapped_value;\n    string key;\n\n    while (store.size() &lt; MAP_SIZE) {\n        // 0 - 9999\n        key_nr = rand() % MAP_SIZE;\n\n        // convert number to string\n        mapped_value = to_string(key_nr);\n        key = \"key_\" + mapped_value;\n\n        pair&lt;string, string&gt; value(key, mapped_value);\n        store.insert(value);\n    }\n}\n\nvoid print_map(const str_map&amp; store) {\n    str_map::const_iterator it = store.begin();\n\n    while (it != store.end()) {\n        pair&lt;string, string&gt; value = *it;\n        cout &lt;&lt; left &lt;&lt; setw(10) &lt;&lt; value.first &lt;&lt; right &lt;&lt; setw(5) &lt;&lt; value.second &lt;&lt; \"\\n\";\n        it++;   \n    }\n}\n\nvoid search_map(const str_map&amp; store, int thread_nr) {\n    m.lock();\n    cout &lt;&lt; \"thread(\" &lt;&lt; thread_nr &lt;&lt; \") launched\\n\";\n    m.unlock();\n\n    // use a straight search or poke around random\n    bool straight = false;\n    if ((thread_nr % 2) == 0) {\n        straight = true;\n    }\n\n    int key_nr;\n    string mapped_value;\n    string key;\n    str_map::const_iterator it;\n\n    string first;\n    string second;\n\n    for (unsigned int i = 0; i &lt; MAP_SIZE; i++) {\n\n        if (straight) {\n            key_nr = i;\n        } else {\n            // 0 - 9999, rand is not thread-safe, nrand48 is an alternative             \n            m.lock();\n            key_nr = rand() % MAP_SIZE;\n            m.unlock();\n        }\n\n        // convert number to string\n        mapped_value = to_string(key_nr);\n        key = \"key_\" + mapped_value;\n\n        it = store.find(key);\n\n        // check result\n        if (it != store.end()) {\n            // pair\n            first = it-&gt;first;\n            second = it-&gt;second;\n\n            // m.lock();\n            // cout &lt;&lt; \"thread(\" &lt;&lt; thread_nr &lt;&lt; \") \" &lt;&lt; key &lt;&lt; \": \"\n            //      &lt;&lt; right &lt;&lt; setw(10) &lt;&lt; first &lt;&lt; setw(5) &lt;&lt; second &lt;&lt; \"\\n\"; \n            // m.unlock();\n\n            // check mismatch\n            if (key != first || mapped_value != second) {\n                m.lock();\n                cerr &lt;&lt; key &lt;&lt; \": \" &lt;&lt; first &lt;&lt; second &lt;&lt; \"\\n\"\n                     &lt;&lt; \"Mismatch in thread(\" &lt;&lt; thread_nr &lt;&lt; \")!\\n\";\n                exit(1);\n\n                // never reached\n                m.unlock();\n            }\n        } else {\n            m.lock();\n            cerr &lt;&lt; \"Warning: key(\" &lt;&lt; key &lt;&lt; \") not found in thread(\"\n                 &lt;&lt; thread_nr &lt;&lt; \")\\n\";\n            exit(1);\n\n            // never reached\n            m.unlock();\n        }\n    }\n}\n\nint main() {\n    clock_t start, end;\n    start = clock();\n\n    str_map store;\n    srand(0);\n\n    fill_map(store);\n    cout &lt;&lt; \"fill_map finished\\n\";\n\n    // print_map(store);\n    // cout &lt;&lt; \"print_map finished\\n\";\n\n    // copy for check\n    str_map copy_store = store;\n\n    // launch threads\n    thread t[10];\n    for (int i = 0; i &lt; 10; i++) {\n        t[i] = thread(search_map, store, i);\n    }\n\n    // wait for finish\n    for (int i = 0; i &lt; 10; i++) {\n        t[i].join();\n    }\n    cout &lt;&lt; \"search_map threads finished\\n\";\n\n    if (store == copy_store) {\n        cout &lt;&lt; \"equal\\n\";\n    } else {\n        cout &lt;&lt; \"not equal\\n\";\n    }\n\n\n    end = clock();\n    cout &lt;&lt; \"CLOCKS_PER_SEC \" &lt;&lt; CLOCKS_PER_SEC &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"CPU-TIME START \" &lt;&lt; start &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"CPU-TIME END \" &lt;&lt; end &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"CPU-TIME END - START \" &lt;&lt; end - start &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"TIME(SEC) \" &lt;&lt; static_cast&lt;double&gt;(end - start) / CLOCKS_PER_SEC &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>This code can be compiled with <strong>GCC 4.7</strong> and runs fine on my machine. </p>\n<p>$ echo $?<br>\n$ 0</br></p>\n", "Tags": "<c++><multithreading><stl><c++11><containers>", "OwnerUserId": "1054324", "AnswerCount": "2"}, "10833589": {"ParentId": "10833512", "CommentCount": "0", "Body": "<p>Yes, you are right. You are safe as long as the thread that populates your vector finishes doing so before the reader threads start. There was <a href=\"http://www.stackoverflow.com/questions/10824299/multithreaded-read-only-access-to-a-vector-copy-or-lock/\">a similar question</a> recently.</p>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "10833589", "Score": "4", "CreationDate": "2012-05-31T12:26:26.053", "LastActivityDate": "2012-05-31T12:26:26.053"}, "bq_ids": {"n4140": {"so_10833512_10833512_9": {"section_id": 6351, "quality": 0.8928571428571429, "length": 25}, "so_10833512_10833512_12": {"section_id": 6354, "quality": 0.6666666666666666, "length": 8}, "so_10833512_10833512_6": {"section_id": 6348, "quality": 0.9545454545454546, "length": 21}, "so_10833512_10833512_4": {"section_id": 6346, "quality": 0.7941176470588235, "length": 27}, "so_10833512_10833512_8": {"section_id": 6350, "quality": 1.0, "length": 23}, "so_10833512_10833512_7": {"section_id": 6349, "quality": 0.8461538461538461, "length": 22}, "so_10833512_10833512_2": {"section_id": 718, "quality": 0.8, "length": 16}, "so_10833512_10833512_1": {"section_id": 717, "quality": 0.9259259259259259, "length": 25}, "so_10833512_10833512_11": {"section_id": 6353, "quality": 0.8947368421052632, "length": 17}, "so_10833512_10833512_5": {"section_id": 6347, "quality": 0.8636363636363636, "length": 19}, "so_10833512_10833512_3": {"section_id": 719, "quality": 0.8709677419354839, "length": 27}, "so_10833512_10833512_10": {"section_id": 6352, "quality": 1.0, "length": 16}}, "n3337": {"so_10833512_10833512_9": {"section_id": 6108, "quality": 0.8928571428571429, "length": 25}, "so_10833512_10833512_5": {"section_id": 6104, "quality": 0.8636363636363636, "length": 19}, "so_10833512_10833512_6": {"section_id": 6105, "quality": 0.9545454545454546, "length": 21}, "so_10833512_10833512_4": {"section_id": 6103, "quality": 0.7941176470588235, "length": 27}, "so_10833512_10833512_8": {"section_id": 6107, "quality": 1.0, "length": 23}, "so_10833512_10833512_7": {"section_id": 6106, "quality": 0.8461538461538461, "length": 22}, "so_10833512_10833512_2": {"section_id": 707, "quality": 0.85, "length": 17}, "so_10833512_10833512_1": {"section_id": 706, "quality": 0.9259259259259259, "length": 25}, "so_10833512_10833512_11": {"section_id": 6110, "quality": 0.8947368421052632, "length": 17}, "so_10833512_10833512_12": {"section_id": 6111, "quality": 0.6666666666666666, "length": 8}, "so_10833512_10833512_3": {"section_id": 708, "quality": 0.8709677419354839, "length": 27}, "so_10833512_10833512_10": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n4659": {"so_10833512_10833512_9": {"section_id": 7860, "quality": 0.8928571428571429, "length": 25}, "so_10833512_10833512_12": {"section_id": 7863, "quality": 0.6666666666666666, "length": 8}, "so_10833512_10833512_6": {"section_id": 7857, "quality": 0.9545454545454546, "length": 21}, "so_10833512_10833512_4": {"section_id": 7855, "quality": 0.7941176470588235, "length": 27}, "so_10833512_10833512_8": {"section_id": 7859, "quality": 1.0, "length": 23}, "so_10833512_10833512_7": {"section_id": 7858, "quality": 0.8461538461538461, "length": 22}, "so_10833512_10833512_2": {"section_id": 749, "quality": 0.8, "length": 16}, "so_10833512_10833512_1": {"section_id": 748, "quality": 0.9259259259259259, "length": 25}, "so_10833512_10833512_11": {"section_id": 7862, "quality": 0.8947368421052632, "length": 17}, "so_10833512_10833512_5": {"section_id": 7856, "quality": 0.8636363636363636, "length": 19}, "so_10833512_10833512_3": {"section_id": 750, "quality": 0.8709677419354839, "length": 27}, "so_10833512_10833512_10": {"section_id": 7861, "quality": 1.0, "length": 16}}}, "10833580": {"ParentId": "10833512", "LastEditDate": "2012-05-31T12:36:01.200", "CommentCount": "3", "CreationDate": "2012-05-31T12:25:42.040", "OwnerUserId": "649233", "LastEditorUserId": "649233", "PostTypeId": "2", "Id": "10833580", "Score": "17", "Body": "<p>A data-race, from the C++11 specification in sections 1.10/4 and 1.10/21, requires at least two threads with non-atomic access to the same set of memory locations, the two threads are not synchronized with regards to accessing the set of memory locations, and <em>at least one thread <strong>writes to</strong> or modifies an element in the set of memory locations</em>.  So in your case, if the threads are only reading, you are fine ... by definition since none of the threads write to the same set of memory locations, there are no data-races even though there is no explicit synchronization mechanism between the threads.</p>\n", "LastActivityDate": "2012-05-31T12:36:01.200"}});