post_cb({"13798897": {"ViewCount": "1631", "Body": "<p>I thought that during overloading, compiler checks whether the formal arguments are of the same type. For example:</p>\n<pre><code>void a(int x)\nvoid a(double x)\n</code></pre>\n<p>can overload simply because the two \"x\"s have the difference type.</p>\n<p>However, does the following two have the different type?</p>\n<pre><code>void f(int y)\nvoid f(int&amp; y)\n</code></pre>\n<p>I understand that one is PBV and the other PBR. But the second y has the type \"int\" as well right? Why it compiles successfully?</p>\n<p>P.S.\nI notice that although it compiles, it does not run though, reporting run-time error of ambiguity.</p>\n", "Title": "Why the compiler can overload functions with passing by reference and passing by value", "CreationDate": "2012-12-10T10:16:38.620", "LastActivityDate": "2012-12-10T10:32:39.333", "CommentCount": "5", "LastEditDate": "2012-12-10T10:17:47.377", "PostTypeId": "1", "LastEditorUserId": "561309", "Id": "13798897", "Score": "12", "OwnerUserId": "1819047", "Tags": "<c++><function><reference><overloading>", "AnswerCount": "4"}, "13799053": {"Id": "13799053", "PostTypeId": "2", "Body": "<p>Firstly, ambiguety is ALWAYS reported at compile time.</p>\n<p>Secondly, whether your example compiles or not depends on how you use this function</p>\n<pre><code>void f(int y)\n{\n}\nvoid f(int&amp; y)\n{\n}\n\n\nint main ()\n{\n    int a = 10;\n\n    f (a); // ERROR: ambiguous call\n    f (10); // OK\n}\n</code></pre>\n<p>In the first case there is an error, becasue <code>a</code> can be passed as both copy and reference.\nIn the second case there will be no error, because <code>int</code> literal cannot be passed by non-const reference</p>\n", "OwnerDisplayName": "user1773602", "LastActivityDate": "2012-12-10T10:26:57.313", "Score": "1", "CreationDate": "2012-12-10T10:26:57.313", "ParentId": "13798897", "CommentCount": "0"}, "13798943": {"Id": "13798943", "PostTypeId": "2", "Body": "<p>Broadly speaking functions can be overloaded on the basis of:</p>\n<ul>\n<li>Number of arguments</li>\n<li><em>Type</em> of arguments</li>\n<li>Sequence of arguments</li>\n</ul>\n<p>The example compiles because it satisfy's the second criteria.<br>\n<code>int</code> and <code>int &amp;</code> are different <em>data types</em>.   </br></p>\n<hr>\n<p>Consider the following example:</p>\n<pre><code>void foo(int i);\nvoid foo(int&amp; i);\nvoid foo(int i){}\nvoid foo(int&amp; i){}\nint main()\n{\n     return 0;\n}  \n</code></pre>\n<p>The above code compiles because it is valid code. Depending on what function argument is passed to the function the compiler may/may not detect the best match for the function call. So the functions themselves are allowed to co-exist but their usage in certain ways may cause ambiguity for the compiler.</p>\n<p>For example:\nIn the following code, a literal cannot be bound to a non-const reference and hence the only candidate for function call is the non reference version and this should compile and work just fine:</p>\n<pre><code>void foo(int i);\nvoid foo(int&amp; i);\nvoid foo(int i){}\nvoid foo(int&amp; i){}\nint main()\n{\n    foo(20); \n    return 0;\n}  \n</code></pre>\n<p>But,</p>\n<pre><code>void foo(int i);\nvoid foo(int&amp; i);\nvoid foo(int i){}\nvoid foo(int&amp; i){}\nint main()\n{\n    int i = 10;\n    foo(i);\n    return 0;\n}  \n</code></pre>\n<p>the above will cause ambiguity for the compiler because compiler cannot detect the best match between the two function calls.</p>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2012-12-10T10:32:39.333", "Score": "7", "CreationDate": "2012-12-10T10:19:04.677", "ParentId": "13798897", "CommentCount": "7", "OwnerUserId": "452307", "LastEditDate": "2012-12-10T10:32:39.333"}, "bq_ids": {"n4140": {"so_13798897_13799098_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 625}}, "n3337": {"so_13798897_13799098_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 615}}, "n4659": {"so_13798897_13799098_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 651}}}, "13799098": {"Id": "13799098", "PostTypeId": "2", "Body": "<p>Let's take the call f(x) where x is an int.</p>\n<blockquote>\n<p id=\"so_13798897_13799098_0\">$13.3.3.1.4 - \"When a parameter of reference type binds directly\n  (8.5.3) to an argument expression, the implicit conversion sequence is\n  the identity conversion, unless the argument expression has a type\n  that is a derived class of the parameter type, in which case the\n  implicit conversion sequence is a derived-to-base Conversion\"</p>\n</blockquote>\n<p>Therefore f(int &amp;) is an exact match and so is f(int) as both are identity conversions. Therefore ambiguity</p>\n<p>Now Let's take the call 'f(2)'</p>\n<p>This is fine because 'f(int &amp;)' is not a match at all as rvalues don't bind to non-const lvalues. Therefore, no ambiguity</p>\n<p>So, the standard allows 'f(T)' abd 'f(T &amp;)' to form an overload set.</p>\n", "LastActivityDate": "2012-12-10T10:30:30.580", "CommentCount": "3", "CreationDate": "2012-12-10T10:30:30.580", "ParentId": "13798897", "Score": "2", "OwnerUserId": "418110"}, "13799056": {"Id": "13799056", "PostTypeId": "2", "Body": "<p>That depends. If you don't call these functions from your code, the compiler might optimize them away. If it doesn't, you can open the .obj file with a text viewer and search for the function name  (give it a more unique name than <code>f</code>, e.g. <code>floop</code> :-)), you will see two mangled names using your basic function name. </p>\n<p>But if you do try to use them then you will notice a difference. If you call</p>\n<pre><code>f(5);\n</code></pre>\n<p>The the compiler can use only the <code>f(int y)</code> version, because it's impossible to pass a constant by reference. But if you do</p>\n<pre><code>int b = 10;\nf(b);\n</code></pre>\n<p>Then the compiler will issue an amibuity error, since both <code>f</code> forms can be called this way. </p>\n", "LastActivityDate": "2012-12-10T10:27:02.597", "CommentCount": "0", "CreationDate": "2012-12-10T10:27:02.597", "ParentId": "13798897", "Score": "2", "OwnerUserId": "888731"}});