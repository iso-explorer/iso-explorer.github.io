post_cb({"bq_ids": {"n4140": {"so_15222286_15222430_2": {"length": 33, "quality": 0.8461538461538461, "section_id": 3345}}, "n3337": {"so_15222286_15222430_2": {"length": 29, "quality": 0.7435897435897436, "section_id": 3215}}}, "15222653": {"PostTypeId": "2", "Body": "<p>Herb Sutter has written on the subject: <a href=\"http://www.gotw.ca/gotw/047.htm\" rel=\"nofollow\">http://www.gotw.ca/gotw/047.htm</a></p>\n<p>His conclusion is to never throw from a destructor, always report the error using the mechanism that you would use in the case where you can't throw.</p>\n<p>The two reasons are:</p>\n<ul>\n<li>it doesn't always work. Sometimes <code>uncaught_exception</code> returns true and yet it is safe to throw.</li>\n<li>it's bad design to have the same error reported in two different ways, both of which the user will have to account for if they want to know about the error.</li>\n</ul>\n<p>Note that for any given reusable piece of code, there is no way to know for sure that it will never be called during stack unwinding. Whatever your code does, you can't be certain that some user of it won't want to call it from a destructor with a <code>try/catch</code> in place to handle its exceptions. Therefore, you can't rely on <code>uncaught_exception</code> always returning true if it's safe to throw, except maybe by documenting the function, \"must not be called from destructors\". If you resorted to that then all callers would also have to document their functions, \"must not be called from destructors\" and you have an even more annoying restriction.</p>\n<p>Aside from anything else, the nothrow guarantee is valuable to users - it helps them write exception-safe code if they know that a particular thing that they do won't throw.</p>\n<p>One way out is to give your class a member function <code>close</code> that calls <code>trySomeCleanupOperation</code> and throws if it fails. Then the destructor calls <code>trySomeCleanupOperation</code> and logs or suppresses the error, but doesn't throw. Then users can call <code>close</code> if they want to know whether their operation succeeds or not, and just let the destructor handle it if they don't care (including the case where the destructor is called as part of stack unwinding, because an exception was thrown before getting to the user's call to <code>close</code>). \"Aha!\", you say, \"but that defeats the purpose of RAII because the user has to remember to call <code>close</code>!\". Yes, a bit, but what's in question isn't whether RAII can do everything you want. It can't. What's in question is whether it <em>consistently</em> does less than you'd like (you'd like it to throw an exception if <code>trySomeCleanupOperator</code> fails), or does less <em>surprisingly</em> when used during stack unwinding.</p>\n<blockquote>\n<p id=\"so_15222286_15222653_0\">Furthermore, throwing exceptions for all failed assertions is an important part of my unit testing approach</p>\n</blockquote>\n<p>That's probably a mistake - your unit testing framework should be capable of treating a <code>terminate()</code> as a test failure. Suppose that an assert fails during stack unwinding - surely you want to record that, but you can't do so by throwing an exception, so you've painted yourself into a corner. If your assertions terminate then you can detect them as terminations.</p>\n<p>Unfortunately if you terminate then you can't run the rest of the tests (at least, not in that process). But if an assertion fails then generally speaking your program is in an unknown and potentially unsafe state. So once you've failed an assertion you can't <em>rely</em> on doing anything else in that process anyway. You could consider designing your test framework to use more than one process, or just accept that a sufficiently severe test failure will prevent the rest of the tests running. Externally to the test framework, you can consider that your test run has three possible outcomes \"all passed, something failed, tests crashed\". If the test run fails to complete then you don't treat it as a pass.</p>\n", "LastActivityDate": "2013-03-05T12:03:55.180", "LastEditorUserId": "13005", "Id": "15222653", "CommentCount": "6", "CreationDate": "2013-03-05T11:29:28.093", "ParentId": "15222286", "Score": "10", "OwnerUserId": "13005", "LastEditDate": "2013-03-05T12:03:55.180"}, "15222286": {"ViewCount": "1177", "Body": "<p>People have argued pretty strongly against throwing exceptions from destructors. Take <a href=\"https://stackoverflow.com/a/391616/1468366\">this answer</a> as an example. I wonder whether <a href=\"http://en.cppreference.com/w/cpp/error/uncaught_exception\" rel=\"nofollow noreferrer\"><code>std::uncaught_exception()</code></a> can be used to portably detect whether we are in the process of unwinding the stack due to some other exception.</p>\n<p>I find myself deliberately throwing exceptions in destructors. To mention two possible use cases:</p>\n<ul>\n<li>Some resource cleanup which involves flushing buffers, so that failure likely signifies truncated output.</li>\n<li>Destruction of an object holding a <code>std::exception_ptr</code> which might contain an exception encountered in a different thread.</li>\n</ul>\n<p>Simply ignoring these exceptional situations feels plain wrong. And chances are that by throwing an exception some exception handler might be able to provide more useful context information than if the destructor itself were writing to <code>std::cerr</code>. Furthermore, throwing exceptions for all failed assertions is an important part of my unit testing approach. An error message followed by an ignored error condition wouldn't work in that case.</p>\n<p>So my question is, <strong>is it OK to throw exceptions except when another exception is being processed</strong>, or is there a reason not to do that?</p>\n<p>To put this in code:</p>\n<pre><code>Foo::~Foo() {\n  bool success = trySomeCleanupOperation();\n  if (!success) {\n    if (std::uncaught_exception())\n      std::cerr &lt;&lt; \"Error in destructor: \" &lt;&lt; errorCode &lt;&lt; std::endl;\n    else\n      throw FooOperationFailed(\"Error in destructor\", errorCode);\n  }\n}\n</code></pre>\n<p>As far as I can tell, this should be safe and in many cases better than not throwing an exception at all. But I'd like to verify that.</p>\n", "AcceptedAnswerId": "15222653", "Title": "Exceptions in C++ destructors if there is no uncaught_exception", "CreationDate": "2013-03-05T11:10:41.073", "Id": "15222286", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:45:34.403", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-05T12:29:37.097", "Score": "8", "OwnerUserId": "1468366", "Tags": "<c++><exception><destructor>", "AnswerCount": "2"}, "15222430": {"PostTypeId": "2", "Body": "<p>This is what standard says about dtors and exceptions:</p>\n<blockquote>\n<p id=\"so_15222286_15222430_0\">15.2</p>\n<p id=\"so_15222286_15222430_1\">(...)</p>\n<p id=\"so_15222286_15222430_2\">The process of calling destructors for automatic objects constructed on the path from a try block to the\n  point where an exception is thrown is called \u201cstack unwinding.\u201d If a destructor called during stack unwinding\n  exits with an exception, std::terminate is called (15.5.1). [ <strong>Note: So destructors should generally catch\n  exceptions and not let them propagate out of the destructor. \u2014end note</strong> ]</p>\n</blockquote>\n<p>Since you asked very ambiguous question, the answer depends:</p>\n<ul>\n<li><em>Can</em> you throw an exception in dtor such that application won't crash? <strong>Yes</strong>, you can (in terms: it will compile and sometimes it will run correctly).</li>\n<li><em>Should</em> you throw an exception in dtor? <strong>No</strong>, you should not, because it may (and usually it will) cause you problems.</li>\n</ul>\n<p>I'd say, that a need for throwing an exception from dtor is a sign of bad design. It seems, that you're doing something in your destructor, that should be done elsewhere.</p>\n", "LastActivityDate": "2013-03-05T11:37:00.097", "LastEditorUserId": "453803", "Id": "15222430", "CommentCount": "4", "CreationDate": "2013-03-05T11:18:49.270", "ParentId": "15222286", "Score": "3", "OwnerUserId": "453803", "LastEditDate": "2013-03-05T11:37:00.097"}});