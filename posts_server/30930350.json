post_cb({"30930486": {"Id": "30930486", "PostTypeId": "2", "Body": "<p>In fact, member-function <em>pointers</em> can be used as template arguments (just exactly as any other pointer type may be used as template parameter):</p>\n<pre><code>struct A\n{\n    int f(float x);\n};\n\ntemplate &lt;int (A::F*)(float)&gt;\nstruct B {};\n\ntemplate&lt;A *&gt; struct C;\ntemplate&lt;A &amp;&gt; struct D;\n</code></pre>\n<p>However, according to the following excerpt from the C++ standard, one cannot pass references to members.</p>\n<blockquote>\n<p id=\"so_30930350_30930486_0\">[temp.param]</p>\n<ol start=\"4\">\n<li>A non-type template-parameter shall have one of the following\n  (optionally cv-qualified) types:</li>\n</ol>\n<p id=\"so_30930350_30930486_1\">(4.1) \u2014 integral or enumeration type,</p>\n<p id=\"so_30930350_30930486_2\">(4.2) \u2014 pointer to object or pointer to function,</p>\n<p id=\"so_30930350_30930486_3\">(4.3) \u2014 lvalue reference to object or lvalue reference to function,</p>\n<p id=\"so_30930350_30930486_4\">(4.4) \u2014 <strong>pointer to member,</strong></p>\n<p id=\"so_30930350_30930486_5\">(4.5) \u2014 std::nullptr_t.</p>\n</blockquote>\n<p><br/></p>\n<hr>\n<p>Next, given you managed to pass your function type somehow and want to call it inside, you encounter the same problem as if you want to store them inside a function pointer or <a href=\"https://stackoverflow.com/a/7582574/2412846\">a <code>std::function</code> object</a>: namely to call you need both, the member function as well as the concrete object. Passing only the function won't suffice.</p>\n<p>But in fact you can achieve what you want. Just bind the function to your object and pass it afterwards:</p>\n<pre><code>template&lt;typename T, typename F&gt;\nvoid call(T&amp;&amp; t, F&amp;&amp;f)\n{\n    f(std::forward&lt;T&gt;(t));\n}\n\nstruct A\n{\n    void foo() { std::cout&lt;&lt;\"hello\"&lt;&lt;std::endl; }  \n};\n\nint main()\n{\n    A a;\n    auto f=std::bind(&amp;A::foo, a);   //or possibly \"std::ref(a)\" instead of \"a\"\n    call(3,f);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1cc3ca4378cce289\" rel=\"nofollow noreferrer\">DEMO</a></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-19T05:54:00.613", "Score": "0", "CreationDate": "2015-06-19T05:23:10.630", "ParentId": "30930350", "CommentCount": "6", "OwnerUserId": "2412846", "LastEditDate": "2017-05-23T11:54:57.007"}, "bq_ids": {"n4140": {"so_30930350_30930486_3": {"length": 6, "quality": 1.0, "section_id": 57}, "so_30930350_30930486_2": {"length": 4, "quality": 1.0, "section_id": 57}}, "n3337": {"so_30930350_30930486_3": {"length": 6, "quality": 1.0, "section_id": 52}, "so_30930350_30930486_2": {"length": 4, "quality": 1.0, "section_id": 52}}, "n4659": {"so_30930350_30930486_3": {"length": 6, "quality": 1.0, "section_id": 59}, "so_30930350_30930486_2": {"length": 4, "quality": 1.0, "section_id": 59}}}, "30930350": {"ViewCount": "3989", "Body": "<p>Why member functions cannot be used as template arguments?\nFor example, I want to do like: </p>\n<pre><code>struct Foo {\n    void Bar() { // do something\n    }\n};\ntemplate &lt;typename TOwner, void(&amp;func)()&gt;\nvoid Call(TOwner *p) {\n    p-&gt;func();\n}\nint main() {\n    Foo a;\n    Call&lt;Foo, Foo::Bar&gt;(&amp;a);\n    return 0;\n}\n</code></pre>\n<p>I know that a similar thing can be done using pointers-to-member; \nwell, it's cool enough most of the time, but I'm just curious about why pointers \"should\" be used. </p>\n<p>I see no ambiguity of interpreting \"p-&gt;func()\" above. \nWhy the standard prohibits us to use member functions as template arguments?\nEven static member functions are not allowed according to my compiler (VC++ 2013). Does anyone know the reason? Or, is there a way to do the same thing without loss of any performance due to pointer dereferencing?</p>\n<p>Thank you. </p>\n", "Title": "Why member functions can't be used as template arguments?", "CreationDate": "2015-06-19T05:11:19.690", "LastActivityDate": "2015-06-19T05:54:00.613", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "Id": "30930350", "Score": "4", "OwnerUserId": "4751858", "Tags": "<c++><templates><member-functions>", "AnswerCount": "2"}, "30930497": {"Id": "30930497", "PostTypeId": "2", "Body": "<p>They can be used as non-type parameters, but you need to use the right syntax</p>\n<pre><code>struct Foo {\n    void Bar() { // do something\n    }\n};\ntemplate &lt;typename TOwner, void(TOwner::*func)()&gt;\nvoid Call(TOwner *p) {\n    (p-&gt;*func)();\n}\nint main() {\n    Foo a;\n    Call&lt;Foo, &amp;Foo::Bar&gt;(&amp;a);\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "657267", "LastActivityDate": "2015-06-19T05:26:40.743", "Score": "12", "CreationDate": "2015-06-19T05:24:08.770", "ParentId": "30930350", "CommentCount": "3", "OwnerUserId": "657267", "LastEditDate": "2015-06-19T05:26:40.743"}});