post_cb({"bq_ids": {"n4140": {"so_11876128_11876128_0": {"length": 14, "quality": 1.0, "section_id": 5572}, "so_11876128_11876128_1": {"length": 14, "quality": 1.0, "section_id": 5572}}, "n3337": {"so_11876128_11876128_0": {"length": 14, "quality": 1.0, "section_id": 5354}, "so_11876128_11876128_1": {"length": 14, "quality": 1.0, "section_id": 5354}}, "n4659": {"so_11876128_11876128_0": {"length": 14, "quality": 1.0, "section_id": 7019}, "so_11876128_11876128_1": {"length": 14, "quality": 1.0, "section_id": 7019}}}, "11885030": {"Id": "11885030", "PostTypeId": "2", "Body": "<p>As you note, <code>r++</code> has operational semantics</p>\n<pre><code>X operator++(int) { X tmp = r; ++r; return tmp; }\n</code></pre>\n<p>I've added the return value as <code>X</code> because per 24.2.2:2 <code>Iterator</code> satisfies <code>CopyConstructible</code>, so it is legitimate to copy construct the return value of <code>r++</code> into an instance of type <code>X</code>.</p>\n<p>Next, <code>*r++ = o</code> is required to be valid; this differs from <code>{ const X &amp;a(r++); *a = o; }</code> only in the addition of a sequence point, which merges with the sequence point after <code>return tmp;</code> in the <em>operational semantics</em> definition above, so the compound statement has the same validity as the expression statement.  By invoking <code>CopyConstructible</code>, <code>{ X a(r++); *a = o; }</code> has the same validity and operational semantics.</p>\n<p>In the case</p>\n<pre><code>*r = o;\nX a(r++);\n</code></pre>\n<p>the following hold:</p>\n<ul>\n<li><p>(a) <code>*a = o</code> is invalid because that value of the iterator has already been dereference-assigned;</p></li>\n<li><p>(b) <code>++a; *a = o</code> is invalid because that value of the iterator has already been incremented, violating the single-pass requirement, as only (the new value of) <code>r</code> is required to be incrementable: per the note to 24.2.4:2, <em>Algorithms on output iterators should never\nattempt to pass through the same iterator twice</em>, although it's not specified what <em>pass through</em> means in this context;</p></li>\n<li><p>(c) <code>*r = o</code> is valid, because the only difference to <code>*r = o; r++; *r = o</code> overall is the continued existence of a copy of the original value of <code>r</code>, which per <code>CopyConstructible</code> requirements has no semantic effect on the value copied from.</p></li>\n</ul>\n<p>Another interesting question is (for a non-dereference-assigned <code>r</code>):</p>\n<pre><code>X a(r);\n++r;\n++r;\n*a = o;\n</code></pre>\n<p>This isn't covered by the standard directly, but from <code>CopyConstructible</code> it appears it should be valid.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-08-09T15:30:56.633", "Score": "4", "CreationDate": "2012-08-09T13:53:25.427", "ParentId": "11876128", "CommentCount": "4", "OwnerUserId": "567292", "LastEditDate": "2012-08-09T15:30:56.633"}, "11876128": {"ViewCount": "597", "Body": "<p>C++ requires that an OutputIterator type <code>X</code> support expressions of the form <code>r++</code>, where <code>r</code> is an instance of <code>X</code>. This postfix increment must be semantically equivalent to:</p>\n<p>(*)  <code>{ X tmp = r; ++r; return tmp; }</code></p>\n<p>and must return a type that is convertible to <code>X const&amp;</code>. In C++11, see 24.2.4 (this is not new, however). In the same section, it says </p>\n<blockquote>\n<blockquote>\n<p id=\"so_11876128_11876128_1\">Algorithms on output iterators should never attempt to pass through the same iterator twice. They should be <em>single pass</em> algorithms.</p>\n</blockquote>\n</blockquote>\n<p>Given (*), above, say I copy the return value like <code>X a(r++);</code></p>\n<ol>\n<li><p>Suppose <code>r</code> was dereferencable before incrementing, but was not dereferenced. Is it required that <code>a</code> be dereferencable? If so, must <code>X a(r++); *a = t;</code> perform the same assignment as <code>*r++ = t;</code> would have otherwise? Are there any (other) conditions on <code>a</code> and <code>r</code> ?</p></li>\n<li><p>Otherwise, suppose <code>r</code> was dereferenced/assigned before incrementing, and its incremented value is (also) dereferencable. Which of the following (if any) are well-defined: (a)\n<code>*a = t;</code>,  (b) <code>++a; *a = t;</code>, (c) <code>*r = t;</code>?</p></li>\n</ol>\n<hr>\n<p>Also see the follow-up: <a href=\"https://stackoverflow.com/q/11887104/985943\">Dereference-assignment to a doubly incremented OutputIterator</a></p>\n</hr>", "AcceptedAnswerId": "11885030", "Title": "C++ OutputIterator post-increment requirements", "CreationDate": "2012-08-09T02:52:38.137", "Id": "11876128", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:34:39.107", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-09T17:06:45.843", "Score": "9", "OwnerUserId": "985943", "Tags": "<c++><iterator><post-increment>", "AnswerCount": "1"}});