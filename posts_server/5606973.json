post_cb({"5607107": {"Id": "5607107", "PostTypeId": "2", "Body": "<p>An iterator is not the same as the container itself. The iterator refers to a single item in the container, as well as providing ways to reach other items.</p>\n<p>Consider designing your own container without iterators. It could have a <code>size</code> function to obtain the number of items it contains, and could overload the <code>[]</code> operator to allow you to get or set an item by its position.</p>\n<p>But \"random access\" of that kind is not easy to implement efficiently on some kinds of container. If you obtain the millionth item: <code>c[1000000]</code> and the container internally uses a linked list, it will have to scan through a million items to find the one you want.</p>\n<p>You might instead decide to allow the collection to remember a \"current\" item. It could have functions like <code>start</code> and <code>more</code> and <code>next</code> to allow you to loop through the contents:</p>\n<pre><code>c.start();\nwhile (c.more()) \n{\n    item_t item = c.next();\n\n    // use the item somehow\n}\n</code></pre>\n<p>But this puts the \"iteration state\" inside the container. This is a serious limitation. What if you wanted to compare each item in the container with every other item? That requires two nested loops, both iterating through all the items. If the container itself stores the position of the iteration, you have no way to nest two such iterations - the inner loop will destroy the working of the outer loop.</p>\n<p>So iterators are an independent copy of an iteration state. You can begin an iteration:</p>\n<pre><code>container_t::iterator i = c.begin();\n</code></pre>\n<p>That iterator, <code>i</code>, is a separate object that represents a position within the container. You can fetch whatever is stored at that position:</p>\n<pre><code>item_t item = *i;\n</code></pre>\n<p>You can move to the next item:</p>\n<pre><code>i++;\n</code></pre>\n<p>With some iterators you can skip forward several items:</p>\n<pre><code>i += 1000;\n</code></pre>\n<p>Or obtain an item at some position relative to the position identified by the iterator:</p>\n<pre><code>item_t item = i[1000];\n</code></pre>\n<p>And with some iterators you can move backwards.</p>\n<p>And you can discover if you've reached beyond the contents of the container by comparing the iterator to <code>end</code>:</p>\n<pre><code>while (i != c.end())\n</code></pre>\n<p>You can think of <code>end</code> as returning an iterator that represents a position that is one beyond the last position in the container.</p>\n<p>An important point to be aware of with iterators (and in C++ generally) is that they can become invalid. This usually happens for example if you empty a container: any iterators pointing to positions in that container have now become invalid. In that state, most operations on them are undefined - anything could happen!</p>\n", "LastActivityDate": "2011-04-09T18:54:45.953", "Score": "1", "CreationDate": "2011-04-09T18:54:45.953", "ParentId": "5606973", "CommentCount": "0", "OwnerUserId": "27423"}, "5606996": {"Id": "5606996", "PostTypeId": "2", "Body": "<p>There already exists a lot of good explanations of iterators. Just google it.</p>\n<p>One <a href=\"http://www.oreillynet.com/network/2005/10/18/what-is-iterator-in-c-plus-plus.html\" rel=\"nofollow\">example</a>.</p>\n<p>If there is something specific you don't understand come back and ask. </p>\n", "LastActivityDate": "2011-04-09T18:31:46.860", "Score": "0", "CreationDate": "2011-04-09T18:31:46.860", "ParentId": "5606973", "CommentCount": "1", "OwnerUserId": "346804"}, "5606973": {"ViewCount": "2889", "Body": "<p>Hi so im a little confused about iterators and what they actually are.... in the C++ STL</p>\n<p>In this case im using a list, and i don't understand why you have to make an iterator:<br>\n<code>std::list &lt;int&gt;::const_iterator iElementLocator;</code> </br></p>\n<p>to dipslay contents of the list by the derefrence operator:<br>\n<code>cout &lt;&lt; *iElementLocator;</code> </br></p>\n<p>after assigning it to maybe list.begin();</p>\n<p>Please explain what exactly an iterator is and why i have to derefrence it /use it!<br>\n<strong>Thanks!!</strong></br></p>\n", "AcceptedAnswerId": "5607206", "Title": "Understanding Iterators in the STL", "CreationDate": "2011-04-09T18:28:05.423", "Id": "5606973", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2011-04-09T19:10:41.063", "Score": "5", "OwnerUserId": "700195", "Tags": "<c++><stl><iterator>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_5606973_5607012_1": {"length": 65, "quality": 0.9285714285714286, "section_id": 5555}}, "n3337": {"so_5606973_5607012_1": {"length": 65, "quality": 0.9285714285714286, "section_id": 5337}}, "n4659": {"so_5606973_5607012_1": {"length": 59, "quality": 0.8428571428571429, "section_id": 7000}}}, "5607206": {"Id": "5607206", "PostTypeId": "2", "Body": "<p>There are three building blocks in the STL:</p>\n<ul>\n<li>Containers</li>\n<li>Algorithms</li>\n<li>Iterators</li>\n</ul>\n<p>At the conceptual level containers hold data. That by itself isn't very useful, because you want to <strong>do</strong> something with the data; you want to <strong>operate</strong> on it, manipulate it, query it, play with it. Algorithms do exactly that. But algorithms don't <strong>hold</strong> data, they <strong>have no</strong> data -- they need a container for this task. Give a container to an algorithm and you have an action going on.</p>\n<p>The only problem left to solve is how does an algorithm traverse a container, from a technical point of view. Technically a container can be a linked list, or it can be an array, or a binary tree, or any other data structure that can hold data. But traversing an array is done differently than traversing a binary tree. Even though conceptually all an algorithm wants is to \"get\" one element at a time from a container, and then work on that element, the operation of <strong>getting</strong> the next element from a container is technically very container-specific.</p>\n<p>It appears as if you'd need to write the same algorithm for each container, so that each version of the algorithm has the correct code for traversing the container. But there's a better solution: ask the container to return an object that can traverse over the container. The object would have an interface algorithms know. When an algorithm asks the object to \"get the next element\" the object would comply. Because the object came directly from the container it knows how to access the container's data. And because the object has an interface the algorithm knows, we need not duplicate an algorithm for each container.</p>\n<p>This is the iterator.</p>\n<p>The iterator here <strong>glues</strong> the algorithm to the container, without coupling the two. An iterator is coupled to a container, and an algorithm is coupled to the iterator's interface. The source of the magic here is really template programming. Consider the standard <code>copy()</code> algorithm:</p>\n<pre><code>template&lt;class In, class Out&gt;\nOut copy(In first, In last, Out res)\n{\n    while( first != last ) {\n        *res = *first;\n        ++first;\n        ++res;\n    }\n    return res;\n}\n</code></pre>\n<p>The <code>copy()</code> algorithm takes as parameters two iterators templated on the type <code>In</code> and one iterator of type <code>Out</code>. It copies the elements starting at position <code>first</code> and ending just before position <code>last</code>, into <code>res</code>. The algorithm knows that to get the next element it needs to say <code>++first</code> or <code>++res</code>. It knows that to read an element it needs to say <code>x = *first</code> and to write an element it needs to say <code>*res = x</code>. That's part of the interface algorithms assume and iterators commit to. If by mistake an iterator doesn't comply with the interface then the compiler would emit an error for calling a function over type <code>In</code> or <code>Out</code>, when the type doesn't define the function.</p>\n", "LastActivityDate": "2011-04-09T19:10:41.063", "Score": "10", "CreationDate": "2011-04-09T19:10:41.063", "ParentId": "5606973", "CommentCount": "1", "OwnerUserId": "456"}, "5607030": {"Id": "5607030", "PostTypeId": "2", "Body": "<p>I'd suggest reading about operator overloading in C++. This will tell why <code>*</code> and <code>-&gt;</code> can mean essentially anything. Only then you should read about the iterators. Otherwise it might appear very confusing.</p>\n", "LastActivityDate": "2011-04-09T18:40:03.187", "Score": "0", "CreationDate": "2011-04-09T18:40:03.187", "ParentId": "5606973", "CommentCount": "0", "OwnerUserId": "475763"}, "5607051": {"Id": "5607051", "PostTypeId": "2", "Body": "<p>An iterator is to an STL container what a pointer is to an array. You can think of them as pointer objects to STL containers. As pointers, you will be able to use them with the pointer notation (e.g. <code>*iElementLocator</code>, <code>iElementLocator++</code>). As objects, they will have their own attributes and methods (http://www.cplusplus.com/reference/std/iterator).</p>\n", "LastActivityDate": "2011-04-09T18:45:07.397", "Score": "2", "CreationDate": "2011-04-09T18:45:07.397", "ParentId": "5606973", "CommentCount": "0", "OwnerUserId": "260313"}, "5607012": {"Id": "5607012", "PostTypeId": "2", "Body": "<p>I'm being lazy. So I would not type describing what an iterator is and how they're used, especially when there're already lots of articles online that you can read yourself.</p>\n<p>Here are few that I can quote for a start, proividing the links to complete articles:</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/k3tf6509%28v=vs.80%29.aspx\" rel=\"nofollow\">MSDN</a> says,</p>\n<blockquote>\n<p id=\"so_5606973_5607012_0\"><strong>Iterators are a generalization of\n  pointers, abstracting from their\n  requirements in a way that allows a\n  C++ program to work with different\n  data structures in a uniform manner</strong>.\n  Iterators act as intermediaries\n  between containers and generic\n  algorithms. Instead of operating on\n  specific data types, algorithms are\n  defined to operate on a range\n  specified by a type of iterator. Any\n  data structure that satisfies the\n  requirements of the iterator may then\n  be operated on by the algorithm. There\n  are five types or categories of\n  iterator [...]</p>\n</blockquote>\n<p>By the way, it seems the MSDN has taken the text in bold from C++ Standard itself, specifically from the section \u00a724.1/1 which says </p>\n<blockquote>\n<p id=\"so_5606973_5607012_1\"><strong>Iterators are a generalization of\n  pointers that allow a C + + program to\n  work with different data structures\n  (containers) in a uniform manner.</strong> To\n  be able to construct template\n  algorithms that work correctly and\n  efficiently on different types of data\n  structures, the library formalizes not\n  just the interfaces but also the\n  semantics and complexity assumptions\n  of iterators. All iterators i support\n  the expression *i, resulting in a\n  value of some class, enumeration, or\n  built-in type T, called the value type\n  of the iterator. All iterators i for\n  which the expression (*i).m is\n  well-defined, support the expression\n  i-&gt;m with the same semantics as\n  (*i).m. For every iterator type X for\n  which equality is defined, there is a\n  corresponding signed integral type\n  called the difference type of the\n  iterator.</p>\n</blockquote>\n<p><a href=\"http://www.cplusplus.com/reference/std/iterator/\" rel=\"nofollow\">cplusplus</a> says,</p>\n<blockquote>\n<p id=\"so_5606973_5607012_2\">In C++, an iterator is any object\n  that, pointing to some element in a\n  range of elements (such as an array or\n  a container), has the ability to\n  iterate through the elements of that\n  range using a set of operators (at\n  least, the increment (++) and\n  dereference (*) operators).</p>\n<p id=\"so_5606973_5607012_3\">The most obvious form of iterator is a\n  pointer [...]</p>\n</blockquote>\n<p>And you can also read these:</p>\n<ul>\n<li><a href=\"http://www.oreillynet.com/network/2005/10/18/what-is-iterator-in-c-plus-plus.html\" rel=\"nofollow\">What Is an Iterator?</a></li>\n<li><a href=\"http://anaturb.net/C/iterators.htm\" rel=\"nofollow\">Iterators in the Standard C++ Library</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Iterator\" rel=\"nofollow\">Iterator</a> (at wiki entry)</li>\n</ul>\n<p>Have patience and read all these. Hopefully, you will have some idea what an iterator is, in C++. Learning C++ requires patience and time. </p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-04-09T18:52:53.883", "Score": "6", "CreationDate": "2011-04-09T18:35:41.697", "ParentId": "5606973", "CommentCount": "0", "LastEditDate": "2011-04-09T18:52:53.883", "OwnerUserId": "415784"}});