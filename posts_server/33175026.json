post_cb({"33177411": {"Id": "33177411", "PostTypeId": "2", "Body": "<p>The only thing missing is the meta-iterator.</p>\n<p>A meta-iterator takes an iterator, and creates an iterator that contains a copy of it.  It passes all operations through to the contained iterator, except when dereferenced returns a copy of the contained iterator instead.</p>\n<p>With any care, the code used for this also works to create an iterator over size_t or int or similar <a href=\"http://math.ucr.edu/home/baez/torsors.html\" rel=\"nofollow\">torsor</a>-likes.</p>\n<pre><code>template&lt;class It, class R&gt;\nstruct reduced_t {\n  It it;\n  R r;\n  friend bool operator&lt;( reduced_t const&amp; lhs, reduced_t const&amp; rhs ) {\n    return lhs.r &lt; rhs.r;\n  }\n};\ntemplate&lt;class It, class F&gt;\nreduced_t&lt;It, std::result_of_t&lt;F(typename std::iterator_traits&lt;It&gt;::reference)&gt;&gt;\nreducer( It it, F&amp;&amp; f ) {\n  return {it, std::forward&lt;F&gt;(f)(*it)};\n}\n\ntemplate&lt;class It, class F&gt;\nIt reduce( It begin, It end, F&amp;&amp; f ) {\n  if (begin==end)\n    return begin;\n\n  return std::accumulate(\n    meta_iterator(std::next(begin)), meta_iterator(end),\n    reducer(begin, f),\n    [&amp;](\n      auto&amp;&amp; reduced, // reduced_t&lt;blah...&gt; in C++11\n      It i\n    ) {\n      auto r2 = reducer( i, f );\n      return (std::min)(reduced, r2);\n    }\n  ).it;\n};\n</code></pre>\n<p><code>f(*it)</code> is called exactly once per iterator.</p>\n<p>I wouldn't call this ... obvious.  The trick is that we use <code>accumulate</code> and meta-iterators to implement <code>min_element</code>, then we can have <code>accumulate</code> operate on transformed elements (which gets called once, and returned).</p>\n<p>You could rewrite it in stack-based programming style using primitives, but there are lots of primitives to write.  Maybe post ranges-v3.</p>\n<hr>\n<p>At this point, I'm imagining having some high-powered compositional programming library.  If I did, we could do the following:</p>\n<p><code>reducer( X, f )</code> can be rewritten <code>graph( deref |then| f )(X)</code> using <code>order_by( get_n_t&lt;1&gt; )</code> for ordering.</p>\n<p>The <code>accumulate</code> call could read <code>accumulate( skip_first(range), g(begin(range)), get_least( order_by( get_n_t&lt;1&gt; ) ) )</code>.</p>\n<p>Not sure if that is any clearer.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2015-10-17T10:36:06.933", "Score": "3", "CreationDate": "2015-10-16T18:37:25.177", "ParentId": "33175026", "CommentCount": "2", "OwnerUserId": "1774667", "LastEditDate": "2015-10-17T10:36:06.933"}, "34570306": {"Id": "34570306", "PostTypeId": "2", "Body": "<p>Here's a solution using (already works with the <a href=\"https://github.com/ericniebler/range-v3\" rel=\"nofollow\"><strong>range-v3 library</strong></a>, the implementation by the author of the upcoming Ranges TS)</p>\n<pre><code>#include &lt;range/v3/all.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nusing namespace ranges::v3;\n\nint main()\n{\n    auto const expensive = [](auto x) { static int n; std::cout &lt;&lt; n++ &lt;&lt; \" \"; return x; };\n    auto const v = view::closed_iota(1,10) | view::transform(expensive); \n\n    auto const m1 = *min_element(v);\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; m1 &lt;&lt; \"\\n\";\n\n    auto const inf = std::numeric_limits&lt;int&gt;::max();    \n    auto const min = [](auto x, auto y) { return std::min(x, y); };\n\n    auto const m2 = accumulate(v, inf, min);\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; m2 &lt;&lt; \"\\n\";    \n}\n</code></pre>\n<p><strong><kbd><a href=\"http://coliru.stacked-crooked.com/a/15dfecef5f5eeb5e\" rel=\"nofollow\">Live On Coliru</a></kbd></strong> with output:</p>\n<pre><code>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \n1\n19 20 21 22 23 24 25 26 27 28 \n1\n</code></pre>\n<p>As you can see, using <code>min_element</code> takes <code>2N</code> comparisons, but using <code>accumulate</code> only <code>N</code>.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2016-01-02T20:25:10.297", "Score": "2", "CreationDate": "2016-01-02T20:18:45.753", "ParentId": "33175026", "CommentCount": "3", "OwnerUserId": "819272", "LastEditDate": "2016-01-02T20:25:10.297"}, "33175202": {"Id": "33175202", "PostTypeId": "2", "Body": "<p>You could use <code>boost::range</code> <a href=\"http://www.boost.org/doc/libs/1_49_0/libs/range/doc/html/index.html\" rel=\"nofollow\">library</a>.</p>\n<pre><code>auto reductionLambda = [](const Complex&amp; a) { return calcReduction(a); };\nauto it = boost::range::min_element(values | boost::adaptors::transformed( \n                             std::ref(reductionLambda));\n</code></pre>\n<p>Ranges themselves should be coming to the standard C++ with C++17 as well.</p>\n<p><strong>Edit</strong></p>\n<p>As we figured out in comments, this would also make the conversion twice.</p>\n<p>So here's something fun:</p>\n<pre><code>#include &lt;boost/iterator/iterator_adaptor.hpp&gt;\n#include &lt;boost/assign.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\n\ntemplate &lt;class Iterator, class UnaryFunction&gt;\nclass memoizing_transform_iterator\n  : public boost::iterator_adaptor&lt;\n        memoizing_transform_iterator&lt;Iterator, UnaryFunction&gt; // Derived\n      , Iterator                                              // Base\n      , std::decay_t&lt;decltype(std::declval&lt;UnaryFunction&gt;()(std::declval&lt;typename Iterator::value_type&gt;()))&gt; // Value\n      , boost::forward_traversal_tag    // CategoryOrTraversal\n    &gt;\n{\n public:\n    memoizing_transform_iterator() {}\n\n    explicit memoizing_transform_iterator(Iterator iter, UnaryFunction f)\n      : memoizing_transform_iterator::iterator_adaptor_(iter), fun(f) {}\n\n    static int total;\n private:\n    friend class boost::iterator_core_access;\n    void increment() { ++this-&gt;base_reference(); memoized = false; }\n\n    using MemoType = std::decay_t&lt;decltype(std::declval&lt;UnaryFunction&gt;()(std::declval&lt;typename Iterator::value_type&gt;()))&gt;;      \n\n    MemoType&amp; dereference() const \n    {\n        if (!memoized) {\n            ++total;\n            memoized = true;\n            memo = fun(*this-&gt;base());\n        }\n        return memo;\n    }\n\n    UnaryFunction fun;\n    mutable bool memoized = false;\n    mutable MemoType memo;\n};\n\n\ntemplate &lt;class Iterator, class UnaryFunction&gt;\nauto make_memoizing_transform_iterator(Iterator i, UnaryFunction&amp;&amp; f)\n{\n    return memoizing_transform_iterator&lt;Iterator, UnaryFunction&gt;(i, f);\n}\n\n\n\ntemplate&lt;class I, class U&gt;\nint memoizing_transform_iterator&lt;I, U&gt;::total = 0;\n\n\n// THIS IS COPIED FROM LIBSTDC++\ntemplate&lt;typename _ForwardIterator&gt;\n   _ForwardIterator\n     min_el(_ForwardIterator __first, _ForwardIterator __last)\n     {\n       if (__first == __last)\n     return __first;\n       _ForwardIterator __result = __first;\n       while (++__first != __last)\n     if (*__first &lt; *__result)\n       __result = __first;\n       return __result;\n     }\n\n\nint main(int argc, const char* argv[])\n{\n    using namespace boost::assign;\n\n    std::vector&lt;int&gt; input;\n    input += 2,3,4,1,5,6,7,8,9,10;\n\n\n    auto transformLambda = [](const int&amp; a) { return a*2; };\n\n\n    auto begin_it = make_memoizing_transform_iterator(input.begin(), std::ref(transformLambda));\n    auto end_it = make_memoizing_transform_iterator(input.end(), std::ref(transformLambda));\n    std::cout &lt;&lt; *min_el(begin_it, end_it).base() &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt;begin_it.total;\n\n    return 0;\n}\n</code></pre>\n<p>Basically I implemented an iterator that memoizes the result of calling the transformation functor. The weird part though is that at least in online compilers, the iterators are copied before their dereferenced values are compared (thus defeating the purpose of memoizing). However when I simply copied the implementation from libstdc++, it works as expected. Perhaps you could try it out on a real machine? The live example is <a href=\"http://rextester.com/MRX9374\" rel=\"nofollow\">here</a>.</p>\n<p><em>Small edit:</em>\nI tested on VS2015 and it works as expected with <code>std::min_element</code>.</p>\n", "LastEditorUserId": "3589890", "LastActivityDate": "2015-10-27T11:55:39.960", "Score": "6", "CreationDate": "2015-10-16T16:22:12.140", "ParentId": "33175026", "CommentCount": "8", "OwnerUserId": "3589890", "LastEditDate": "2015-10-27T11:55:39.960"}, "33175718": {"Id": "33175718", "PostTypeId": "2", "Body": "<p>If you take a minElem as a lambda parameter you could use min_element</p>\n<pre><code>Complex findMinValueWithPredicates(const std::vector&lt;Complex&gt;&amp; values)\n{\n  float minElem = std::numeric_limits&lt;float&gt;::max();\n  auto it = std::min_element(values.begin(), values.end(),\n                             [&amp;minElem](const Complex&amp; a, const Complex&amp; b) {\n                               float tmp = calcReduction(a);\n                               if (tmp &lt; minElem) {\n                                  minElem = tmp;\n                                  return true;\n                               }\n                               return false;\n                             });\n\n  if (it == values.end()) throw std::runtime_error(\"\");\n\n  return *it;\n}\n</code></pre>\n<p>Edit:\nWhy does this work when <code>b</code>is not used? \n25.4.7.21 min_element</p>\n<blockquote>\n<p id=\"so_33175026_33175718_0\">21 Returns: The first iterator i in the range [first,last) such that\n  for every iterator j in the range [first,last) the following\n  corresponding conditions hold: !(*j &lt; *i) or comp(*j, *i) == false.\n  Returns last if first == last.</p>\n</blockquote>\n<p>because <code>b</code> should have been named <code>smallestYet</code> (code from <a href=\"http://www.cplusplus.com/reference/algorithm/min_element/\" rel=\"nofollow\">cplusplus.com</a>)</p>\n<pre><code>template &lt;class ForwardIterator&gt;\n  ForwardIterator min_element ( ForwardIterator first, ForwardIterator last )\n{\n  if (first==last) return last;\n  ForwardIterator smallest = first;\n\n  while (++first!=last)\n    if (*first&lt;*smallest)    // or: if (comp(*first,*smallest)) for version (2)\n      smallest=first;\n  return smallest;\n}\n</code></pre>\n<p>Which lead me to a new favourite quote:</p>\n<p>\"<em>There are only 10 hard problems in Computer Science: \ncache invalidation, naming things and off-by-one errors</em>.\"</p>\n<ul>\n<li>one commented on that we might be off-by-one as we don't use <code>b</code>.</li>\n<li>I worried that the <code>minElem</code> cached might not be correct.</li>\n<li>And I realized that the name <code>b</code> should have been more meaningful as it is \"dereferenced iterator to smallest element yet\" or <code>smallestYet</code>.</li>\n<li>Finally that not all understand binary when its not written with a \u00b4b\u00b4 at the end.</li>\n</ul>\n", "LastEditorUserId": "4013258", "LastActivityDate": "2015-10-17T09:51:29.833", "Score": "2", "CreationDate": "2015-10-16T16:53:59.180", "ParentId": "33175026", "CommentCount": "8", "OwnerUserId": "4013258", "LastEditDate": "2015-10-17T09:51:29.833"}, "bq_ids": {"n4140": {"so_33175026_33175718_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 1505}}, "n3337": {"so_33175026_33175718_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 1499}}, "n4659": {"so_33175026_33175718_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 1649}}}, "33193401": {"Id": "33193401", "PostTypeId": "2", "Body": "<p>Here is another option, but it is still effectively your second solution. To be honest it doesn't look clear, but someone might like it. (I use <code>std::pair&lt;float, Complex&gt;</code> to store reduction result and the value that was reduced.)</p>\n<pre><code>std::pair&lt;float, Complex&gt; result{std::numeric_limits&lt;float&gt;::max(), {}};\nauto output_function = [&amp;result](std::pair&lt;float, Complex&gt; candidate) {\n    if (candidate.first &lt; result.first)\n        result = candidate;\n};\nstd::transform(values.begin(), values.end(), \n               boost::make_function_output_iterator(output_function),\n               [](Complex x) { return std::make_pair(calcReduction(x), x); });\n</code></pre>\n<p><strong>P.S.</strong> If your <code>calcReduction</code> costs a lot, have you considered caching results in <code>Complex</code> objects? It will lead to a slightly more complicated implementation, but you'll be able to use plain <code>std::min_element</code> which makes your intentions clear.</p>\n", "LastActivityDate": "2015-10-18T01:31:44.103", "CommentCount": "1", "CreationDate": "2015-10-18T01:31:44.103", "ParentId": "33175026", "Score": "2", "OwnerUserId": "4510766"}, "33175026": {"ViewCount": "788", "Body": "<p>Here is the task came to me from a code review. I want to select a minimum value from a set, based on a special kind of compare predicate. Like this:</p>\n<pre><code>struct Complex { ... };\n\nfloat calcReduction(Complex elem);\n\nComplex findMinValueWithPredicates(const std::vector&lt;Complex&gt;&amp; values)\n{\n  auto it = std::min_element(values.begin(), values.end(), \n                             [](const Complex&amp; a, const Complex&amp; b) { \n                               return calcReduction(a) &lt; calcReduction(b); \n                             });\n\n  if (it == values.end()) throw std::runtime_error(\"\");\n\n  return *it;\n}\n</code></pre>\n<p>Here I find the minimum element based on a predicate. This predicate computes a <em>reduction</em> of both values to <code>float</code> and then compares those floats. Works fine, looks neat.</p>\n<p>Can you see the problem? Yes, for a set of <code>N</code> elements <code>calcReduction()</code> is called <code>2N</code> times, while it is enough to compute it only <code>N</code> times - once for each element.</p>\n<p>One way to solve this problem is to write explicit computations:</p>\n<pre><code>Complex findMinValueExplicit(const std::vector&lt;Complex&gt;&amp; values)\n{\n  float minReduction = std::numeric_limits&lt;float&gt;::max();\n  Complex minValue;\n\n  for (Complex value : values)\n  {\n    float reduction = calcReduction(value);\n    if (reduction &lt; minReduction)\n    {\n      minReduction = reduction;\n      minValue = value;\n    }\n  }\n\n  if (minReduction == std::numeric_limits&lt;float&gt;::max()) throw std::runtime_error(\"\");\n\n  return minValue;\n}\n</code></pre>\n<p>It works fine and we only have <code>N</code> calls to <code>calcReduction()</code>. However, it looks too verbose and the intent is not such clear, as compared to explicit call of <code>min_element</code>. Because when you call <code>min_element</code> it is really easy to guess you are going to find a minimum element, you know. </p>\n<p>The only idea I have for now is to create my own algorithm like <code>min_element_with_reduction</code>, accepting a range and a reduction function. Sounds reasonable, but I wonder whether there are any ready solutions.</p>\n<p>Any ideas on how to solve this task with clear intent and some ready solutions? Boost is welcomed. C++17 and ranges are interesting to see.</p>\n", "Title": "Finding minimum element based on a transformed value", "CreationDate": "2015-10-16T16:12:02.040", "LastActivityDate": "2017-08-17T07:44:59.203", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-08-17T07:44:59.203", "LastEditorUserId": "261217", "Id": "33175026", "Score": "11", "OwnerUserId": "261217", "Tags": "<c++><algorithm><min><c++1z><range-v3>", "AnswerCount": "5"}});