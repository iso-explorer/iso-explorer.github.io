post_cb({"271076": {"CommentCount": "3", "ViewCount": "86479", "OwnerDisplayName": "Joel", "CreationDate": "2008-11-07T02:39:53.410", "LastActivityDate": "2016-11-15T17:25:50.760", "PostTypeId": "1", "AcceptedAnswerId": "271087", "FavoriteCount": "51", "Title": "What is the difference between an int and a long in C++?", "Id": "271076", "Score": "99", "Body": "<p>Correct me if I am wrong,</p>\n<p>int is 4 bytes, with a range of values from -2,147,483,648 to 2,147,483,647 (2^31)<br>\nlong is 4 bytes, with a range of values from -2,147,483,648 to 2,147,483,647 (2^31)</br></p>\n<p>What is the difference in C++?  Can they be used interchangeably?</p>\n", "Tags": "<c++><variables>", "OwnerUserId": "25632", "AnswerCount": "9"}, "271187": {"ParentId": "271076", "CommentCount": "0", "Body": "<p>For the most part, the number of bytes and range of values is determined by the CPU's architecture not by C++.  However, C++ sets minimum requirements, which litb explained properly and Martin York only made a few mistakes with.</p>\n<p>The reason why you can't use int and long interchangeably is because they aren't always the same length.  C was invented on a PDP-11 where a byte had 8 bits, int was two bytes and could be handled directly by hardware instructions.  Since C programmers often needed four-byte arithmetic, long was invented and it was four bytes, handled by library functions.  Other machines had different specifications.  The C standard imposed some minimum requirements.</p>\n", "OwnerUserId": "23705", "Id": "271187", "PostTypeId": "2", "OwnerDisplayName": "Windows programmer", "Score": "5", "CreationDate": "2008-11-07T03:47:59.777", "LastActivityDate": "2008-11-07T03:47:59.777"}, "271087": {"CommentCount": "6", "CreationDate": "2008-11-07T02:43:06.867", "LastEditorUserId": "15168", "LastActivityDate": "2008-11-07T03:32:16.720", "ParentId": "271076", "PostTypeId": "2", "LastEditorDisplayName": "Jonathan Leffler", "LastEditDate": "2008-11-07T03:32:16.720", "Id": "271087", "Score": "95", "Body": "<p>It is implementation dependent.  </p>\n<p>For example, under Windows they are the same, but for example on Alpha systems a long was 64 bits whereas an int was 32 bits.  This <a href=\"http://software.intel.com/en-us/articles/size-of-long-integer-type-on-different-architecture-and-os\" rel=\"noreferrer\">article</a> covers the rules for the Intel C++ compiler on variable platforms.  To summarize:</p>\n<pre><code>  OS           arch           size\nWindows       IA-32        4 bytes\nWindows       Intel 64     4 bytes\nWindows       IA-64        4 bytes\nLinux         IA-32        4 bytes\nLinux         Intel 64     8 bytes\nLinux         IA-64        8 bytes\nMac OS X      IA-32        4 bytes\nMac OS X      Intel 64     8 bytes  \n</code></pre>\n", "OwnerUserId": "3631", "OwnerDisplayName": "Rob Walker"}, "271132": {"CommentCount": "11", "CreationDate": "2008-11-07T03:12:42.407", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-26T16:58:51.590", "ParentId": "271076", "PostTypeId": "2", "LastEditorDisplayName": "Martin York", "LastEditDate": "2017-05-23T12:03:07.500", "Id": "271132", "Score": "71", "Body": "<p>The only guarantee you have are:</p>\n<pre><code>sizeof(char) == 1\nsizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)\n\n// FROM @KTC. The C++ standard also has:\nsizeof(signed char)   == 1\nsizeof(unsigned char) == 1\n\n// NOTE: These size are not specified explicitly in the standard.\n//       They are implied by the minimum/maximum values that MUST be supported\n//       for the type. These limits are defined in limits.h\nsizeof(short)     * CHAR_BIT &gt;= 16\nsizeof(int)       * CHAR_BIT &gt;= 16\nsizeof(long)      * CHAR_BIT &gt;= 32\nsizeof(long long) * CHAR_BIT &gt;= 64\nCHAR_BIT         &gt;= 8   // Number of bits in a byte\n</code></pre>\n<p>Also see: <a href=\"https://stackoverflow.com/q/4329777/14065\">Is <code>long</code> guaranteed to be at least 32 bits?</a></p>\n", "OwnerUserId": "14065", "OwnerDisplayName": "Martin York"}, "271083": {"ParentId": "271076", "CommentCount": "0", "Body": "<p>It depends on your compiler.  You are guaranteed that a long will be at least as large as an int, but you are not guaranteed that it will be any longer.</p>\n", "OwnerUserId": "5922", "Id": "271083", "PostTypeId": "2", "OwnerDisplayName": "Glomek", "Score": "4", "CreationDate": "2008-11-07T02:41:46.010", "LastActivityDate": "2008-11-07T02:41:46.010"}, "271200": {"ParentId": "271076", "CommentCount": "1", "Body": "<p>Relying on the compiler vendor's implementation of primitive type sizes \nWILL come back to haunt you if you ever compile your code on another\nmachine architecture, OS, or another vendor's compiler .</p>\n<p>Most compiler vendors provide a header file that defines primitive types with\nexplict type sizes.\nThese primitive types should be used when ever code may be potentially ported\nto another compiler (read this as ALWAYS in EVERY instance).\nFor example, most UNIX compilers have <code>int8_t uint8_t  int16_t int32_t uint32_t</code>.\nMicrosoft has <code>INT8 UINT8 INT16 UINT16 INT32 UINT32</code>.\nI prefer Borland/CodeGear's  <code>int8 uint8 int16 uint16 int32 uint32</code>.\nThese names also give a little reminder of the size/range of the intended value.</p>\n<p>For years I have used Borland's explicit primitive type names\nand <code>#include</code> the following C/C++ header file (primitive.h)\nwhich is intended to define the explicit primitive types with these names for any C/C++ compiler\n(this header file might not actually cover every compiler but it covers several compilers I have used on Windows, UNIX and Linux, it also doesn't (yet) define 64bit types).</p>\n<pre><code>#ifndef primitiveH\n#define primitiveH\n// Header file primitive.h\n// Primitive types\n// For C and/or C++\n// This header file is intended to define a set of primitive types\n// that will always be the same number bytes on any operating operating systems\n// and/or for several popular C/C++ compiler vendors.\n// Currently the type definitions cover:\n// Windows (16 or 32 bit)\n// Linux\n// UNIX (HP/US, Solaris)\n// And the following compiler vendors\n// Microsoft, Borland/Imprise/CodeGear, SunStudio,  HP/UX\n// (maybe GNU C/C++)\n// This does not currently include 64bit primitives.\n#define float64 double\n#define float32 float\n// Some old C++ compilers didn't have bool type\n// If your compiler does not have bool then add   emulate_bool\n// to your command line -D option or defined macros.\n#ifdef emulate_bool\n#   ifdef TVISION\n#     define bool int\n#     define true 1\n#     define false 0\n#   else\n#     ifdef __BCPLUSPLUS__\n      //BC++ bool type not available until 5.0\n#        define BI_NO_BOOL\n#        include &lt;classlib/defs.h&gt;\n#     else\n#        define bool int\n#        define true 1\n#        define false 0\n#     endif\n#  endif\n#endif\n#ifdef __BCPLUSPLUS__\n#  include &lt;systypes.h&gt;\n#else\n#  ifdef unix\n#     ifdef hpux\n#        include &lt;sys/_inttypes.h&gt;\n#     endif\n#     ifdef sun\n#        include &lt;sys/int_types.h&gt;\n#     endif\n#     ifdef linux\n#        include &lt;idna.h&gt;\n#     endif\n#     define int8 int8_t\n#     define uint8 uint8_t\n#     define int16 int16_t\n#     define int32 int32_t\n#     define uint16 uint16_t\n#     define uint32 uint32_t\n#  else\n#     ifdef  _MSC_VER\n#        include &lt;BaseTSD.h&gt;\n#        define int8 INT8\n#        define uint8 UINT8\n#        define int16 INT16\n#        define int32 INT32\n#        define uint16 UINT16\n#        define uint32 UINT32\n#     else\n#        ifndef OWL6\n//          OWL version 6 already defines these types\n#           define int8 char\n#           define uint8 unsigned char\n#           ifdef __WIN32_\n#              define int16 short int\n#              define int32 long\n#              define uint16 unsigned short int\n#              define uint32 unsigned long\n#           else\n#              define int16 int\n#              define int32 long\n#              define uint16 unsigned int\n#              define uint32 unsigned long\n#           endif\n#        endif\n#      endif\n#  endif\n#endif\ntypedef int8   sint8;\ntypedef int16  sint16;\ntypedef int32  sint32;\ntypedef uint8  nat8;\ntypedef uint16 nat16;\ntypedef uint32 nat32;\ntypedef const char * cASCIIz;    // constant null terminated char array\ntypedef char *       ASCIIz;     // null terminated char array\n#endif\n//primitive.h\n</code></pre>\n", "OwnerUserId": "14964", "Id": "271200", "PostTypeId": "2", "OwnerDisplayName": "Roger Nelson", "Score": "5", "CreationDate": "2008-11-07T03:53:14.447", "LastActivityDate": "2008-11-07T03:53:14.447"}, "3618662": {"ParentId": "271076", "CommentCount": "0", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow noreferrer\">C++ Standard</a> says it like this :</p>\n<p>3.9.1, \u00a72 :</p>\n<blockquote>\n<p id=\"so_271076_3618662_0\">There are five signed integer types :\n  \"signed char\", \"short int\", \"int\",\n  \"long int\", and \"long long int\". In\n  this list, each type provides at least\n  as much storage as those preceding it\n  in the list. Plain ints have the\n  natural size suggested by the\n  architecture of the execution\n  environment (44); the other signed\n  integer types are provided to meet\n  special needs.</p>\n<p id=\"so_271076_3618662_1\">(44) that is, <b>large enough to contain\n  any value in the range of INT_MIN and\n  INT_MAX, as defined in the header\n  <code>&lt;climits&gt;</code></b>.</p>\n</blockquote>\n<p>The conclusion : it depends on which architecture you're working on. Any other assumption is false.</p>\n", "OwnerUserId": "3673", "PostTypeId": "2", "Id": "3618662", "Score": "4", "CreationDate": "2010-09-01T13:40:39.133", "LastActivityDate": "2010-09-01T13:40:39.133"}, "bq_ids": {"n4140": {"so_271076_3618662_0": {"section_id": 7211, "quality": 1.0, "length": 42}, "so_271076_271107_1": {"section_id": 7211, "quality": 0.7692307692307693, "length": 10}, "so_271076_271107_0": {"section_id": 7211, "quality": 0.967741935483871, "length": 30}, "so_271076_3618662_1": {"section_id": 7211, "quality": 1.0, "length": 10}}, "n3337": {"so_271076_3618662_0": {"section_id": 6955, "quality": 1.0, "length": 42}, "so_271076_271107_1": {"section_id": 6955, "quality": 0.7692307692307693, "length": 10}, "so_271076_271107_0": {"section_id": 6955, "quality": 0.967741935483871, "length": 30}, "so_271076_3618662_1": {"section_id": 6955, "quality": 1.0, "length": 10}}, "n4659": {"so_271076_271107_1": {"section_id": 8720, "quality": 0.6153846153846154, "length": 8}, "so_271076_3618662_1": {"section_id": 8720, "quality": 0.8, "length": 8}, "so_271076_271107_0": {"section_id": 8720, "quality": 0.9354838709677419, "length": 29}, "so_271076_3618662_0": {"section_id": 8720, "quality": 0.9761904761904762, "length": 41}}}, "271107": {"CommentCount": "0", "CreationDate": "2008-11-07T02:54:18.107", "LastEditorUserId": "2988879", "LastActivityDate": "2016-11-15T17:25:50.760", "ParentId": "271076", "PostTypeId": "2", "LastEditorDisplayName": "Jonathan Leffler", "LastEditDate": "2016-11-15T17:25:50.760", "Id": "271107", "Score": "11", "Body": "<p>The <a href=\"https://web.archive.org/web/20071230202350/http://www.kuzbass.ru/docs/isocpp/basic.html#basic.fundamental\" rel=\"nofollow noreferrer\">C++ specification itself</a> (old version but good enough for this) leaves this open.</p>\n<blockquote>\n<p id=\"so_271076_271107_0\">There are four signed integer types:\n  '<code>signed char</code>', '<code>short int</code>',\n  '<code>int</code>', and '<code>long int</code>'. In this\n  list, each type provides at least as\n  much storage as those preceding it in\n  the list. Plain ints have the natural\n  size suggested by the architecture of\n  the execution environment* ; </p>\n<p id=\"so_271076_271107_1\">[Footnote: that is, large enough to\n  contain any value in the range of\n  INT_MIN and INT_MAX, as defined in the\n  header <code>&lt;climits&gt;</code>. --- end foonote]</p>\n</blockquote>\n", "OwnerUserId": "10410", "OwnerDisplayName": "Kevin Haines"}, "271143": {"CommentCount": "1", "CreationDate": "2008-11-07T03:15:20.623", "LastEditorUserId": "15168", "LastActivityDate": "2008-11-07T03:39:01.853", "ParentId": "271076", "PostTypeId": "2", "LastEditorDisplayName": "Jonathan Leffler", "LastEditDate": "2008-11-07T03:39:01.870", "Id": "271143", "Score": "7", "Body": "<p>As Kevin Haines points out, ints have the natural size suggested by the execution environment, which has to fit within INT_MIN and INT_MAX.</p>\n<p>The C89 standard states that <code>UINT_MAX</code> should be at least 2^16-1, <code>USHRT_MAX</code> 2^16-1 and <code>ULONG_MAX</code> 2^32-1 . That makes a bit-count of at least 16 for short and int, and 32 for long. For char it states explicitly that it should have at least 8 bits (<code>CHAR_BIT</code>).\nC++ inherits those rules for the limits.h file, so in C++ we have the same fundamental requirements for those values. \nYou should however <em>not</em> derive from that that int is at least 2 byte. Theoretically, char, int and long could all be 1 byte, in which case <code>CHAR_BIT</code> must be at least 32. Just remember that \"byte\" is always the size of a char, so if char is bigger, a byte is not only 8 bits any more.</p>\n", "OwnerUserId": "34509", "OwnerDisplayName": "litb"}, "271092": {"ParentId": "271076", "CommentCount": "1", "Body": "<p>When compiling for x64, the difference between int and long is somewhere between 0 and 4 bytes, depending on what compiler you use.</p>\n<p>GCC uses the LP64 model, which means that ints are 32-bits but longs are 64-bits under 64-bit mode.</p>\n<p>MSVC for example uses the LLP64 model, which means both ints and longs are 32-bits even in 64-bit mode.</p>\n", "OwnerUserId": "31987", "PostTypeId": "2", "Id": "271092", "Score": "13", "CreationDate": "2008-11-07T02:45:46.410", "LastActivityDate": "2008-11-07T02:45:46.410"}});