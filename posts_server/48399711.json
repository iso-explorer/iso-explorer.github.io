post_cb({"bq_ids": {"n4140": {"so_48399711_48400098_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 7043}, "so_48399711_48400098_2": {"length": 38, "quality": 0.926829268292683, "section_id": 7043}, "so_48399711_48400098_0": {"length": 31, "quality": 1.0, "section_id": 7137}}, "n3337": {"so_48399711_48400098_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 6788}, "so_48399711_48400098_2": {"length": 39, "quality": 0.9512195121951219, "section_id": 6788}, "so_48399711_48400098_0": {"length": 31, "quality": 1.0, "section_id": 6881}}, "n4659": {"so_48399711_48400098_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 8540}, "so_48399711_48400098_2": {"length": 38, "quality": 0.926829268292683, "section_id": 8540}, "so_48399711_48400098_0": {"length": 31, "quality": 1.0, "section_id": 8638}}}, "48399711": {"ViewCount": "215", "Body": "<p>Consider the following C++11 application:</p>\n<p><strong>A.cpp:</strong></p>\n<pre><code>template&lt;typename T&gt;\nstruct Shape {\n    T x;\n    T area() const { return x*x; }\n};\n\nint testA() {\n    return Shape&lt;int&gt;{2}.area();\n}\n</code></pre>\n<p><strong>B.cpp:</strong></p>\n<pre><code>template&lt;typename T, typename U = T&gt;\nstruct Shape {\n    T x;\n    U y;\n    U area() const { return x*y; }\n};\nint testB() {\n    return Shape&lt;int,short&gt;{3,4}.area();\n}\n</code></pre>\n<p><strong>Main.cpp:</strong></p>\n<pre><code>int testA();\nint testB();\nint main() {\n   return testA() + testB();\n}\n</code></pre>\n<p>Although it compiles (as long as A and B are in separate TUs), it doesn't look right, and I'm having trouble figuring out why.</p>\n<p><strong>Hence my Question:</strong> Does this violate ODR, overloading, or any other rule, and if so, what sections of <a href=\"https://timsong-cpp.github.io/cppwp/n3337/\" rel=\"noreferrer\">the Standard</a> are violated and why?</p>\n", "AcceptedAnswerId": "48400098", "Title": "Class template overloading across TUs", "CreationDate": "2018-01-23T10:43:19.477", "LastActivityDate": "2018-01-23T11:33:34.177", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-01-23T10:43:46.887", "LastEditorUserId": "2380830", "Id": "48399711", "Score": "8", "OwnerUserId": "485343", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}, "48400098": {"Id": "48400098", "PostTypeId": "2", "Body": "<p>It is an ODR violation. <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp#4\" rel=\"noreferrer\">Template names have linkage</a>. And both those template names have external linkage, as <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.link\" rel=\"noreferrer\">[basic.link]/4</a> says:</p>\n<blockquote>\n<p id=\"so_48399711_48400098_0\">An unnamed namespace or a namespace declared directly or indirectly\n  within an unnamed namespace has internal linkage. All other namespaces\n  have external linkage. A name having namespace scope that has not been\n  given internal linkage above has the same linkage as the enclosing\n  namespace if it is the name of</p>\n<ul>\n<li>[...]</li>\n<li>a template.</li>\n</ul>\n</blockquote>\n<p>And on account of that, since both templates share a name, it means that <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.def.odr#5\" rel=\"noreferrer\">[basic.def.odr]/5</a> applies:</p>\n<blockquote>\n<p id=\"so_48399711_48400098_1\">There can be more than one definition of a [...] class template\n  (Clause [temp]) [...] in a program provided that each definition\n  appears in a different translation unit, and provided the definitions\n  satisfy the following requirements. Given such an entity named D\n  defined in more than one translation unit, then</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n<li>[...]</li>\n</ul>\n<p id=\"so_48399711_48400098_2\">If D is a template and is defined in more than one translation unit,\n  then the preceding requirements shall apply both to names from the\n  template's enclosing scope used in the template definition\n  ([temp.nondep]), and also to dependent names at the point of\n  instantiation ([temp.dep]). If the definitions of D satisfy all these\n  requirements, then the program shall behave as if there were a single\n  definition of D. If the definitions of D do not satisfy these\n  requirements, then the behavior is undefined.</p>\n</blockquote>\n<p>Not the same sequence of tokens by a margin.</p>\n<p>You can easily resolve it, as <a href=\"https://stackoverflow.com/users/2684539/jarod42\">Jarod42</a> suggested, by putting both definitions of the templates into an unnamed namespace, thus giving them internal linkage.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2018-01-23T11:33:34.177", "Score": "13", "CreationDate": "2018-01-23T11:02:22.280", "ParentId": "48399711", "CommentCount": "5", "OwnerUserId": "817643", "LastEditDate": "2018-01-23T11:33:34.177"}});