post_cb({"39824879": {"Id": "39824879", "PostTypeId": "2", "Body": "<p>Actually I can answer my own question... didn't find an answer while searching before writing it, but then searching again afterwards did find an answer (typical huh).</p>\n<p>Anyway:  this issue is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1880\">CWG #1880</a> with the resolution:</p>\n<blockquote>\n<p id=\"so_39824814_39824879_0\"><strong>Notes from the June, 2014 meeting:</strong></p>\n<p id=\"so_39824814_39824879_1\">WG decided to make it unspecified whether parameter objects are destroyed immediately following the call or at the end of the full-expression to which the call belongs. </p>\n</blockquote>\n<p>The latest C++17 draft that I have (N4606) has changed the text in [expr.call]/4:</p>\n<blockquote>\n<p id=\"so_39824814_39824879_2\">It is implementation-defined whether the lifetime of a parameter ends when the function in which it is defined returns or at the end of the enclosing full-expression.</p>\n</blockquote>\n<p>I guess we should treat this resolution (i.e. \"implementation-defined\") as applying retroactively , since it was not well specified by published standards.</p>\n<p>Note: The definition of <em>full-expression</em> can be found in C++14 [intro.execution]/10:</p>\n<blockquote>\n<p id=\"so_39824814_39824879_3\">A full-expression is an expression that is not a subexpression of another expression. [...] If a language construct is defined to produce an implicit call of a function, a use of the language construct is considered to be an expression for the purposes of this definition.</p>\n</blockquote>\n<p>So <code>F v { func(0) };</code> is the enclosing <em>full-expression</em> for <code>gparm</code> (even though it's a declaration and not an expression!).</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2016-10-03T07:00:26.813", "Score": "12", "CreationDate": "2016-10-03T05:06:13.730", "ParentId": "39824814", "CommentCount": "5", "OwnerUserId": "1505939", "LastEditDate": "2016-10-03T07:00:26.813"}, "bq_ids": {"n4140": {"so_39824814_39824879_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 5991}, "so_39824814_39824814_0": {"length": 7, "quality": 0.875, "section_id": 5991}, "so_39824814_39824879_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 5806}}, "n3337": {"so_39824814_39824879_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 5759}, "so_39824814_39824814_0": {"length": 7, "quality": 0.875, "section_id": 5759}, "so_39824814_39824879_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 5579}}, "n4659": {"so_39824814_39824879_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 7491}, "so_39824814_39824814_0": {"length": 7, "quality": 0.875, "section_id": 7491}, "so_39824814_39824879_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 7267}}}, "39824814": {"ViewCount": "262", "Body": "<p>According to C++14 [expr.call]/4:</p>\n<blockquote>\n<p id=\"so_39824814_39824814_0\">The lifetime of a parameter ends when the function in which it is defined returns.</p>\n</blockquote>\n<p>This seems to imply that a parameter's destructor must run before the code which called the function goes on to use the function's return value. </p>\n<p>However, this code shows differently:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct G\n{\n    G(int): moved(0) { std::cout &lt;&lt; \"G(int)\\n\"; }\n    G(G&amp;&amp;): moved(1) { std::cout &lt;&lt; \"G(G&amp;&amp;)\\n\"; }\n    ~G() { std::cout &lt;&lt; (moved ? \"~G(G&amp;&amp;)\\n\" : \"~G()\\n\"); }\n\n    int moved;\n};\n\nstruct F\n{\n    F(int) { std::cout &lt;&lt; \"F(int)\\n\"; }\n    ~F() { std::cout &lt;&lt; \"~F()\\n\"; }\n};\n\nint func(G gparm)\n{\n    std::cout &lt;&lt; \"---- In func.\\n\";\n    return 0;\n}\n\n\nint main()\n{\n    F v { func(0) };\n    std::cout &lt;&lt; \"---- End of main.\\n\";\n    return 0;\n}\n</code></pre>\n<p>The output for gcc and clang , with <code>-fno-elide-constructors</code>, is (with my annotations):</p>\n<pre><code>G(int)               // Temporary used to copy-initialize gparm\nG(G&amp;&amp;)               // gparm\n---- In func.\nF(int)               // v\n~G(G&amp;&amp;)              // gparm\n~G()                 // Temporary used to copy-initialize gparm\n---- End of main.\n~F()                 // v\n</code></pre>\n<p>So, clearly <code>v</code>'s constructor runs before <code>gparm</code>'s destructor.  But in MSVC, <code>gparm</code> is destroyed before <code>v</code>'s constructor runs.</p>\n<p>The same issue can be seen with copy-elision enabled, and/or with <code>func({0})</code> so that the parameter is direct-initialized. <code>v</code> is always constructed before <code>gparm</code> is destructed. I also observed the issue in a longer chain, e.g. <code>F v = f(g(h(i(j())));</code> did not destroy any of the parameters of <code>f,g,h,i</code> until after <code>v</code> was initialized.</p>\n<p>This could be a problem in practice, for example if <code>~G</code> unlocks a resource and <code>F()</code> acquires the resource, it would be a deadlock. Or, if <code>~G</code> throws, then execution should jump to a catch handler without <code>v</code> having been initialized.</p>\n<p>My question is: does the standard permit both of these orderings? . Is there any more specific definition of the sequencing relationship involving parameter destruction, than just that quote from expr.call/4 which does not use the standard sequencing terms?</p>\n", "Title": "Sequencing of function parameter destruction", "CreationDate": "2016-10-03T04:57:15.733", "LastActivityDate": "2016-10-03T07:00:26.813", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "Id": "39824814", "Score": "16", "OwnerUserId": "1505939", "Tags": "<c++><c++14><language-lawyer><function-calls><sequencing>", "AnswerCount": "1"}});