post_cb({"9339829": {"ViewCount": "5587", "Body": "<p>A while ago I used <code>std::function</code> pretty much like this:</p>\n<pre><code>std::function&lt;void(int)&gt; func = [](int i) -&gt; int { return i; };\n</code></pre>\n<p>Basically, I did this because I wanted to store different function objects in a <code>std::function</code>, but I didn't want to restrict the return types of these functions. Since this seemed to work, I went with it. But I'm not convinced that it is safe to use, and I haven't been able to find any documentation on it. Does anyone know whether this usage is legitimate? Or more generally, what the rules are for the object which can safely be assigned to a <code>std::function</code>?</p>\n<h2>Edit</h2>\n<p>For clarification, the issue I'm concerned with is that the lambda function returns an <code>int</code>, while <code>func</code> is declared with return type <code>void</code>. I'm not sure if this is OK, especially once a call to <code>func()</code> is made.</p>\n", "AcceptedAnswerId": "9343400", "Title": "Using `std::function<void(...)>` to call non-void function", "CreationDate": "2012-02-18T08:37:44.120", "Id": "9339829", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-02-19T08:36:24.207", "LastEditorUserId": "636019", "LastActivityDate": "2012-02-19T12:32:23.937", "Score": "16", "OwnerUserId": "616815", "Tags": "<c++><c++11><return-type><std-function>", "AnswerCount": "3"}, "9343400": {"Id": "9343400", "PostTypeId": "2", "Body": "<p>Your code has undefined behavior.  It may or may not work as you expect.  The reason it has undefined behavior is because of 20.8.11.2.1 [func.wrap.func.con]/p7:</p>\n<blockquote>\n<p id=\"so_9339829_9343400_0\"><em>Requires:</em> <code>F</code> shall be <code>CopyConstructible</code>. <code>f</code> shall be Callable (20.8.11.2) for argument types <code>ArgTypes</code> and return type <code>R</code>.</p>\n</blockquote>\n<p>For <code>f</code> to be Callable for return type <code>R</code>, <code>f</code> must return something implicitly convertible to the return type of the <code>std::function</code> (<code>void</code> in your case).  And <code>int</code> is not implicitly convertible to <code>void</code>.</p>\n<p>I would expect your code to work on most implementations.  However on at least one implementation (<a href=\"http://libcxx.llvm.org/\" rel=\"nofollow noreferrer\">libc++</a>), it fails to compile:</p>\n<pre><code>test.cpp:7:30: error: no viable conversion from 'int (int)' to 'std::function&lt;void (int)&gt;'\n    std::function&lt;void(int)&gt; ff = f;\n                             ^    ~\n</code></pre>\n<p>Ironically the rationale for this behavior stems from <a href=\"https://stackoverflow.com/q/5931214/576911\">another SO question</a>.</p>\n<p>The other question presented a problem with <code>std::function</code> usage. The solution to that problem involved having the implementation enforce the <em>Requires:</em> clause at compile time. In contrast, the solution to this question's problem is <strong>forbidding</strong> the implementation from enforcing the <em>Requires:</em> clause.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-19T02:11:39.137", "Score": "19", "CreationDate": "2012-02-18T17:27:31.550", "ParentId": "9339829", "CommentCount": "7", "OwnerUserId": "576911", "LastEditDate": "2017-05-23T12:09:33.230"}, "bq_ids": {"n4140": {"so_9339829_9343400_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4660}, "so_9339829_9341064_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 4560}, "so_9339829_9341064_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4660}, "so_9339829_9341064_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 4651}}, "n3337": {"so_9339829_9343400_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4470}, "so_9339829_9341064_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 4390}, "so_9339829_9341064_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4470}, "so_9339829_9341064_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 4462}}, "n4659": {"so_9339829_9343400_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 6020}, "so_9339829_9341064_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 5932}, "so_9339829_9341064_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 6020}, "so_9339829_9341064_1": {"length": 13, "quality": 0.6842105263157895, "section_id": 6020}}}, "9339890": {"Id": "9339890", "PostTypeId": "2", "Body": "<p>This looks like it may be ok for anonymous functions. </p>\n<p>Quote from <a href=\"http://www.alorelang.org/release/0.5/doc/std_function.html\" rel=\"nofollow\">http://www.alorelang.org/release/0.5/doc/std_function.html</a> (this is not from the C++ standard library, however it looks like they are using something similar in there bindings down to C++)</p>\n<blockquote>\n<p id=\"so_9339829_9339890_0\">Function objects can only be created with a function definition, an anonymous function expression or by accessing a bound method using the dot (.) operator.</p>\n</blockquote>\n<p>Another way this could possibly be done is by storing the function pointer in auto as seen here: <a href=\"http://en.wikipedia.org/wiki/Anonymous_function\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Anonymous_function</a> (C++ section)</p>\n", "LastActivityDate": "2012-02-18T08:49:39.463", "CommentCount": "1", "CreationDate": "2012-02-18T08:49:39.463", "ParentId": "9339829", "Score": "0", "OwnerUserId": "803942"}, "9341064": {"Id": "9341064", "PostTypeId": "2", "Body": "<p><s>Your use case is well-defined according to the standard.</s></p>\n<p>You are constructing a <code>std::function</code> from a callable object[1]</p>\n<p>\u00a720.8.11.2.1/7:</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\n</code></pre>\n<p id=\"so_9339829_9341064_0\">Requires: F shall be CopyConstructible. f shall be Callable (20.8.11.2) for argument types ArgTypes\n  and return type R.</p>\n</blockquote>\n<p>So is your f callable?</p>\n<p>\u00a720.8.11.2/2 says:</p>\n<blockquote>\n<p id=\"so_9339829_9341064_1\">A callable object f of type F is Callable for argument types ArgTypes\n  and return type R if the expres- sion <code>INVOKE (f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand\n  (Clause 5), is well formed (20.8.2).</p>\n</blockquote>\n<p>And the definition of <code>INVOKE</code> says:</p>\n<p>\u00a720.8.2</p>\n<blockquote>\n<ol>\n<li><p id=\"so_9339829_9341064_2\">Define <code>INVOKE (f, t1, t2, ..., tN)</code> as follows:\n  ... stuff dealing with member function/var pointers ...\n  \u2014 <code>f(t1, t2, ..., tN)</code> in all other cases.</p></li>\n<li><p id=\"so_9339829_9341064_3\">Define <code>INVOKE (f, t1, t2, ..., tN, R) as INVOKE (f, t1, t2, ..., tN)</code> implicitly converted to <code>R</code>.</p></li>\n</ol>\n</blockquote>\n<p><s>And since any type can be implicitly converted to <code>void</code>, your code should be fine with a standards-conforming compiler.</s> As pointed out by litb below, there isn't an implicit conversion to void so this isn't well defined.</p>\n<p>[1]: I think the lambda counts as a callable object here, although I don't have a reference for that. Your lambda could also be used as a function pointer as it captures no context</p>\n", "LastEditorUserId": "1030301", "LastActivityDate": "2012-02-19T12:32:23.937", "Score": "1", "CreationDate": "2012-02-18T12:15:47.430", "ParentId": "9339829", "CommentCount": "3", "OwnerUserId": "1030301", "LastEditDate": "2012-02-19T12:32:23.937"}});