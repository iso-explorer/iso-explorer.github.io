post_cb({"24336044": {"ParentId": "24335886", "CommentCount": "4", "Body": "<p>As the value of M is undefined, I would expect it to taint the call to swap.\nNasal Demons may fly, when swap is called.</p>\n", "OwnerUserId": "7734", "PostTypeId": "2", "Id": "24336044", "Score": "1", "CreationDate": "2014-06-20T21:39:33.670", "LastActivityDate": "2014-06-20T21:39:33.670"}, "24336049": {"ParentId": "24335886", "CommentCount": "13", "Body": "<p>Very nice question. However, I would say this is covered by [res.on.arguments]\u00a71:</p>\n<blockquote>\n<p id=\"so_24335886_24336049_0\">Each of the following applies to all arguments to functions defined in the C++ standard library, unless\n  explicitly stated otherwise.</p>\n<ul>\n<li>If an argument to a function has an invalid value (such as a value outside the domain of the function\n  or a pointer invalid for its intended use), the behavior is undefined.</li>\n</ul>\n</blockquote>\n<p>To address your concern about <code>f(n)</code>, the function <code>f</code> from your question is not a part of the C++ standard library and thus the above clause does not apply to it.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "24336049", "Score": "12", "CreationDate": "2014-06-20T21:39:53.523", "LastActivityDate": "2014-06-20T21:39:53.523"}, "24335886": {"CommentCount": "9", "ViewCount": "573", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2014-06-20T21:26:41.883", "LastActivityDate": "2014-06-20T21:39:53.523", "Title": "Does swap() cause undefined behaviour?", "FavoriteCount": "1", "LastEditDate": "2014-06-20T21:36:27.677", "Id": "24335886", "Score": "16", "Body": "<p>I'm trying to understand the conditions on <code>std::swap</code> from [C++11: utility.swap]. The template is defined as</p>\n<pre><code>template &lt;typename T&gt; void swap(T &amp;, T &amp;)\n</code></pre>\n<p>(plus some <code>noexcept</code> details) and as having the effect of \"exchanging the values stored at the two locations\".</p>\n<p>Is the following program have well-defined?</p>\n<pre><code>#include &lt;utility&gt;\n\nint main()\n{\n    int m, n;\n    std::swap(m, n);\n}\n</code></pre>\n<p>If I wrote swap code myself (i.e. <code>int tmp = m; m = n; n = tmp;</code>), it would have undefined behaviour, since it would attempt lvalue-to-rvalue conversion on an uninitialized object. But the standard <code>std::swap</code> function does not seem to come with any conditions imposed on it, nor can one derive from the specification that there is any lvalue-to-rvalue and thus UB. </p>\n<p>Does the standard require <code>std::swap</code> to perform some magic that is well-defined on uninitialized objects?</p>\n<p>To clarify the point, consider the function <code>void f(int &amp; n) { n = 25; }</code>, which never has undefined behaviour (since it does not read from <code>n</code>).</p>\n", "Tags": "<c++><c++11><language-lawyer><undefined-behavior><lvalue-to-rvalue>", "OwnerUserId": "596781", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24335886_24336049_0": {"section_id": 6325, "quality": 1.0, "length": 11}}, "n3337": {"so_24335886_24336049_0": {"section_id": 6082, "quality": 1.0, "length": 11}}, "n4659": {"so_24335886_24336049_0": {"section_id": 7835, "quality": 1.0, "length": 11}}}});