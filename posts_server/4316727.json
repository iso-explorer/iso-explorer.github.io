post_cb({"44889967": {"Id": "44889967", "PostTypeId": "2", "Body": "<p><del>One thing that i didn't see in other answers is</del> To clarify <a href=\"https://stackoverflow.com/a/4316948\">another answers</a> that there is a difference between returning std::unique_ptr that has been created within a function, and one that has been given to that function.</p>\n<p>The example could be like this:</p>\n<pre><code>class Test\n{int i;};\nstd::unique_ptr&lt;Test&gt; foo1()\n{\n    std::unique_ptr&lt;Test&gt; res(new Test);\n    return res;\n}\nstd::unique_ptr&lt;Test&gt; foo2(std::unique_ptr&lt;Test&gt;&amp;&amp; t)\n{\n    // return t;  // this will produce an error!\n    return std::move(t);\n}\n\n//...\nauto test1=foo1();\nauto test2=foo2(std::unique_ptr&lt;Test&gt;(new Test));\n</code></pre>\n", "LastEditorUserId": "2893496", "LastActivityDate": "2017-07-03T16:35:21.510", "Score": "1", "CreationDate": "2017-07-03T16:06:44.533", "ParentId": "4316727", "CommentCount": "2", "OwnerUserId": "2893496", "LastEditDate": "2017-07-03T16:35:21.510"}, "4316775": {"Id": "4316775", "PostTypeId": "2", "Body": "<p>This is in no way specific to unique_ptr, but applies to any class that is movable. It's guaranteed by the language rules since you are returning by value. The compiler tries to elide copies, invokes a move constructor if it can't remove copies, calls a copy constructor if it can't move, and fails to compile if it can't copy.</p>\n<p>If you had a function that accepts unique_ptr as an argument you wouldn't be able to pass p to it. You would have to explicitly invoke move constructor, but in this case you shouldn't use variable p after the call to bar().</p>\n<pre><code>void bar(std::unique_ptr&lt;int&gt; p)\n{\n}\n\nint main()\n{\n    unique_ptr&lt;int&gt; p = foo();\n    bar(p); // error, can't implicitly invoke move constructor on lvalue\n    bar(std::move(p)); // OK but don't use p afterwards\n}\n</code></pre>\n", "LastEditorUserId": "523124", "LastActivityDate": "2017-03-15T15:03:07.550", "Score": "70", "CreationDate": "2010-11-30T17:48:39.980", "ParentId": "4316727", "CommentCount": "5", "OwnerUserId": "155670", "LastEditDate": "2017-03-15T15:03:07.550"}, "4319605": {"Id": "4319605", "PostTypeId": "2", "Body": "<p>unique_ptr doesn't have the traditional copy constructor. Instead it has a \"move constructor\" that uses rvalue references:</p>\n<pre><code>unique_ptr::unique_ptr(unique_ptr &amp;&amp; src);\n</code></pre>\n<p>An rvalue reference (the double ampersand) will only bind to an rvalue. That's why you get an error when you try to pass an lvalue unique_ptr to a function. On the other hand, a value that is returned from a function is treated as an rvalue, so the move constructor is called automatically. </p>\n<p>By the way, this will work correctly:</p>\n<pre><code>bar(unique_ptr&lt;int&gt;(new int(44));\n</code></pre>\n<p>The temporary unique_ptr here is an rvalue.</p>\n", "LastEditorUserId": "4100", "LastActivityDate": "2013-01-09T16:31:11.850", "Score": "31", "CreationDate": "2010-11-30T23:00:27.760", "ParentId": "4316727", "CommentCount": "3", "OwnerUserId": "90088", "LastEditDate": "2013-01-09T16:31:11.850"}, "bq_ids": {"n4140": {"so_4316727_4316948_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 481}, "so_4316727_4316948_1": {"length": 36, "quality": 0.972972972972973, "section_id": 480}}, "n3337": {"so_4316727_4316948_2": {"length": 21, "quality": 1.0, "section_id": 472}, "so_4316727_4316948_1": {"length": 36, "quality": 0.972972972972973, "section_id": 471}}, "n4659": {"so_4316727_4316948_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 504}, "so_4316727_4316948_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 502}}}, "4316727": {"ViewCount": "81545", "Body": "<p><code>unique_ptr&lt;T&gt;</code> does not allow copy construction, instead it supports move semantics. Yet, I can return a <code>unique_ptr&lt;T&gt;</code> from a function and assign the returned value to a variable.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nunique_ptr&lt;int&gt; foo()\n{\n  unique_ptr&lt;int&gt; p( new int(10) );\n\n  return p;                   // 1\n  //return move( p );         // 2\n}\n\nint main()\n{\n  unique_ptr&lt;int&gt; p = foo();\n\n  cout &lt;&lt; *p &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>The code above compiles and works as intended. So how is it that line <code>1</code> doesn't invoke the copy constructor and result in compiler errors? If I had to use line <code>2</code> instead it'd make sense (using line <code>2</code> works as well, but we're not required to do so).</p>\n<p>I know C++0x allows this exception to <code>unique_ptr</code> since the return value is a temporary object that will be destroyed as soon as the function exits, thus guaranteeing the uniqueness of the returned pointer. I'm curious about how this is implemented, is it special cased in the compiler or is there some other clause in the language specification that this exploits?</p>\n", "AcceptedAnswerId": "4316948", "Title": "Returning unique_ptr from functions", "CreationDate": "2010-11-30T17:44:37.347", "Id": "4316727", "CommentCount": "2", "FavoriteCount": "75", "PostTypeId": "1", "LastEditDate": "2012-03-29T22:39:21.340", "LastEditorUserId": "241631", "LastActivityDate": "2017-10-05T02:33:08.207", "Score": "218", "OwnerUserId": "241631", "Tags": "<c++><c++11><unique-ptr>", "AnswerCount": "5"}, "4316948": {"Id": "4316948", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4316727_4316948_0\">is there some other clause in the language specification that this exploits?</p>\n</blockquote>\n<p>Yes, see 12.8 \u00a734 and \u00a735:</p>\n<blockquote>\n<p id=\"so_4316727_4316948_1\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object [...]\n  This elision of copy/move operations, called <em>copy elision</em>, is permitted [...]\n  in a return statement in a function with a class return type, <strong>when the expression is the name of\n  a non-volatile automatic object</strong> with the same cv-unqualified type as the function return type [...]</p>\n<p id=\"so_4316727_4316948_2\">When the criteria for elision of a copy operation are met and the object to be copied is designated by an lvalue,\n  overload resolution to select the constructor for the copy is first performed <strong>as if the object were designated by an rvalue</strong>.</p>\n</blockquote>\n<hr>\n<p>Just wanted to add one more point that returning by value should be the default choice here because a named value in the return statement in the worst case, i.e. without elisions in C++11, C++14 and C++17 is treated as an rvalue.  So for example the following function compiles with the <code>-fno-elide-constructors</code> flag</p>\n<pre><code>std::unique_ptr&lt;int&gt; get_unique() {\n  auto ptr = std::unique_ptr&lt;int&gt;{new int{2}}; // &lt;- 1\n  return ptr; // &lt;- 2, moved into the to be returned unique_ptr\n}\n\n...\n\nauto int_uptr = get_unique(); // &lt;- 3\n</code></pre>\n<p>With the flag set on compilation there are two moves (1 and 2) happening in this function and then one move later on (3).  </p>\n</hr>", "LastEditorUserId": "5501675", "LastActivityDate": "2016-07-12T23:55:39.923", "Score": "147", "CreationDate": "2010-11-30T18:06:56.860", "ParentId": "4316727", "CommentCount": "8", "OwnerUserId": "252000", "LastEditDate": "2016-07-12T23:55:39.923"}, "46571941": {"Id": "46571941", "PostTypeId": "2", "Body": "<p>I think it's perfectly explained in <em>item 25</em> of Scott Meyers' <a href=\"http://shop.oreilly.com/product/0636920033707.do\" rel=\"nofollow noreferrer\">Effective Modern C++</a>. Here's an excerpt:  </p>\n<blockquote>\n<p id=\"so_4316727_46571941_0\">The part of the Standard blessing the RVO goes on to say that if the conditions for the RVO are met, but compilers choose not to perform copy elision, the object being returned must be treated as an rvalue. In effect, the Standard requires that when the RVO is permitted, either copy elision takes place or <code>std::move</code> is implicitly applied to local objects being returned.</p>\n</blockquote>\n<p>Here, <em>RVO</em> refers to <em>return value optimization</em>, and <em>if the conditions for the RVO are met</em> means returning the local object declared inside the function that you would expect to do the <em>RVO</em>, which is also nicely explained in item 25 of his book by referring to the standard (here the <em>local object</em> includes the temporary objects created by the return statement). The biggest take away from the excerpt is <em>either copy elision takes place or <code>std::move</code> is implicitly applied to local objects being returned</em>. Scott mentions in item 25 that <code>std::move</code> is implicitly applied when the compiler choose not to elide the copy and the programmer should not explicitly do so.</p>\n<p>In your case, the code is clearly a candidate for <em>RVO</em> as it returns the local object <code>p</code> and the type of <code>p</code> is the same as the return type, which results in copy elision. And if the compiler chooses not to elide the copy, for whatever reason, <code>std::move</code> would've kicked in to line <code>1</code>.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2017-10-05T02:33:08.207", "Score": "0", "CreationDate": "2017-10-04T18:38:45.720", "ParentId": "4316727", "CommentCount": "0", "OwnerUserId": "853315", "LastEditDate": "2017-10-05T02:33:08.207"}});