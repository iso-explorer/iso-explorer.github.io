post_cb({"44341441": {"ParentId": "44341215", "CommentCount": "0", "Body": "<p>For C99, we have:</p>\n<blockquote>\n<p id=\"so_44341215_44341441_0\"><strong>6.5 Expressions</strong></p>\n<ol start=\"2\">\n<li>Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.</li>\n</ol>\n</blockquote>\n<p>In <code>arr[i] = i++</code>, the value of <code>i</code> is only modified once. But <code>arr[i]</code> also reads from <code>i</code>, and this value is not used to determine the new value of <code>i</code>. That's why it has undefined behavior.</p>\n<p>On the other hand, in <code>i = i + 1</code> we read <code>i</code> in order to compute <code>i + 1</code>, which is used as the new value of <code>i</code>. Therefore this expression is fine.</p>\n", "OwnerUserId": "1848654", "PostTypeId": "2", "Id": "44341441", "Score": "9", "CreationDate": "2017-06-03T07:18:15.890", "LastActivityDate": "2017-06-03T07:18:15.890"}, "44348568": {"ParentId": "44341215", "CommentCount": "7", "Body": "<p>Note that this <em>will change</em> in C++17. In C++17, <code>arr[i] = i++</code> does not invoke undefined behavior. This is due to the following change in <a href=\"http://eel.is/c++draft/expr.ass#1\" rel=\"noreferrer\">[expr.ass]</a>:</p>\n<blockquote>\n<p id=\"so_44341215_44348568_0\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression. <strong>The right operand is sequenced before the left operand.</strong></p>\n</blockquote>\n<p>That is, we do <code>i++</code> <em>then</em> we do <code>arr[i]</code> <em>then</em> we perform the assignment. The now well-defined ordering is:</p>\n<pre><code>auto src = i++;\nauto&amp; dst = arr[i];\ndst = src;\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "44348568", "Score": "12", "CreationDate": "2017-06-03T21:09:12.393", "LastActivityDate": "2017-06-03T21:09:12.393"}, "44341231": {"ParentId": "44341215", "PostTypeId": "2", "CommentCount": "8", "Body": "<p><b><sup><em>Since this was originally tagged with <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> and <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> and not any specific version(s), the below answer is a generic answer to the problem. However, please note for <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a>, <code>C++17</code> onwards, the behaviour has changed. Please see this <a href=\"https://stackoverflow.com/a/44348568/2173917\">answer by Barry to know more.</a></em></sup></b></p>\n<hr>\n<p>For the statement</p>\n<pre><code>arr[i] = i++;\n</code></pre>\n<p>the value of <code>i</code> is <em>used</em> in both the operands, RHS(right-hand-side) and LHS(left-hand-side), and in one of the cases, the value is being modified (as a side effect of post <code>++</code>) where there's no <a href=\"https://stackoverflow.com/q/4176328/2173917\">sequence point</a> in between to determine which value of <code>i</code> should be considered. You can also check <a href=\"https://stackoverflow.com/q/949433/2173917\">this canonical answer</a> for more on this.</p>\n<p>On the other hand, for <code>i = i + 1</code>, the value of <code>i</code> is <em>used</em> only in RHS, the computed result is stored in LHS, in other words, there's no ambiguity. We can write the same statement as <code>i++</code>, which </p>\n<ul>\n<li>reads the value of <code>i</code></li>\n<li>Increments it by <code>1</code></li>\n<li>stores it back to <code>i</code></li>\n</ul>\n<p>in a well-defined sequence. Hence, no issues.</p>\n</hr>", "OwnerUserId": "2173917", "LastEditorUserId": "2069064", "LastEditDate": "2017-06-05T16:42:09.630", "Id": "44341231", "Score": "36", "CreationDate": "2017-06-03T06:52:56.293", "LastActivityDate": "2017-06-05T16:42:09.630"}, "44347241": {"ParentId": "44341215", "CommentCount": "0", "Body": "<p>In your example a [i] = i++, if i = 3 for example, do you think a [i] is evaluated first, or i++? In one case, the value 3 would be stored in a [3], in the other case, it would be stored in a [4]. It's obvious that <strong>we have a problem</strong> here. No sane person would dare writing that code unless they found a guarantee what exactly will happen here. (Java gives that guarantee). </p>\n<p>What would you think could be a problem with i = i + 1? The language must read i first to calculate i+1, then store that result. There is nothing here that could be wrong. Same with a [i] = i+1. Evaluating i+1, unlike i++, doesn't change i. So if i = 3, the number 4 must be stored in a [3]. </p>\n<p>Various languages have various rules to fix the problem with a [i] = i++. Java <em>defines</em> what happens: Expressions are evaluated left to right including their side effects. C defines it as undefined behaviour. C++ doesn't make it <em>undefined</em> behaviour but just unspecified. It says that either a[i] or i++ is evaluated first, and the other one next, but it doesn't say which one. So unlike C where <em>anything</em> can happen, C++ defines that only one of two things can happen. Obviously that's one thing too many to be acceptable in your code.</p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "44347241", "Score": "2", "CreationDate": "2017-06-03T18:26:42.940", "LastActivityDate": "2017-06-03T18:26:42.940"}, "44341215": {"CommentCount": "2", "AcceptedAnswerId": "44341231", "PostTypeId": "1", "LastEditorUserId": "7035151", "CreationDate": "2017-06-03T06:51:25.187", "LastActivityDate": "2017-06-05T16:42:09.630", "LastEditDate": "2017-06-03T18:53:14.917", "ViewCount": "1847", "FavoriteCount": "4", "Title": "Behaviour of arr[i] = i++ and i = i + 1 statements in C and C++", "Id": "44341215", "Score": "19", "Body": "<p>In the C and C++ languages, the <code>arr[i] = i++;</code> statement invokes undefined behavior. Why does the statement <code>i = i + 1;</code> not invoke undefined behavior?</p>\n", "Tags": "<c++><c><c++14><undefined-behavior><sequence-points>", "OwnerUserId": "7035151", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_44341215_44348568_0": {"section_id": 6173, "quality": 0.6818181818181818, "length": 15}}, "n3337": {"so_44341215_44348568_0": {"section_id": 5934, "quality": 0.6818181818181818, "length": 15}}, "n4659": {"so_44341215_44348568_0": {"section_id": 7675, "quality": 0.9545454545454546, "length": 21}}}, "44341384": {"ParentId": "44341215", "CommentCount": "1", "Body": "<pre><code>arr[i] = i++;\n</code></pre>\n<p>implies that</p>\n<ul>\n<li>right hand expression is evaluated before assignment</li>\n<li>subscript operator is evaluated before assignment</li>\n</ul>\n<p>but contains ambiguity regarding the order of right hand expression evaluation and subscript operator evaluation, compiler is free to treat it as</p>\n<pre><code>auto &amp; val{arr[i]};\ni++;\nauto const rval{i};\nval = rval;\n</code></pre>\n<p>or as</p>\n<pre><code>i++;\nauto &amp; val{arr[i]};\nauto const rval{i};\nval = rval;\n</code></pre>\n<p>or as (same result as above)</p>\n<pre><code>i++;\nauto const rval{i};\nauto &amp; val{arr[i]};\nval = rval;\n</code></pre>\n<p>Which may produce unpredictable result, while </p>\n<pre><code>i = i + 1;\n</code></pre>\n<p>dos not have any ambiguity, right hand expression is evaluated before assignment:</p>\n<pre><code>auto const rval{i + 1};\nauto &amp; val{i};\nval = rval;\n</code></pre>\n<p>or (same result as above)</p>\n<pre><code>auto &amp; val{i};\nauto const rval{i + 1};\nval = rval;\n</code></pre>\n", "OwnerUserId": "7860670", "PostTypeId": "2", "Id": "44341384", "Score": "8", "CreationDate": "2017-06-03T07:12:00.003", "LastActivityDate": "2017-06-03T07:12:00.003"}});