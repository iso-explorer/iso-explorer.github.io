post_cb({"23947055": {"CommentCount": "14", "ViewCount": "46", "PostTypeId": "1", "LastEditorUserId": "2786156", "CreationDate": "2014-05-30T04:30:22.180", "LastActivityDate": "2014-05-30T05:24:25.553", "Title": "What name lookup rule apply to the name in the definition of static const data member", "AcceptedAnswerId": "23947470", "LastEditDate": "2014-05-30T05:19:30.750", "Id": "23947055", "Score": "1", "Body": "<p>There is a quote described name lookup applied to data member of a const static data member after the <strong>quialified-id</strong> of the data member:</p>\n<p><strong>sec. 3.4.1/13:</strong></p>\n<blockquote>\n<p id=\"so_23947055_23947055_0\">A name used in the definition of a static data member of class X\n  (9.4.2) (after the qualified-id of the static member) is looked up as\n  if the name was used in a member function of X.</p>\n</blockquote>\n<p>But we can define in-class static const data member:</p>\n<pre><code>class A\n{\n    static const int i = x;//x is a name defined an arbitrary const int\n};\n</code></pre>\n<p>Rule from the sec. 3.4.1/13 does not apply to the name <code>x</code> lookup. <strong>What rule will be applied actually? Please give a reference to a corresponding clause from standard.</strong></p>\n<p>For instance, the following code is valid:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nconst int a=5;\nclass A\n{\npublic:\n    static const int b=a;//b is unqualified-id of this data-member\n};\n\nint main(){ printf(\"%d\\n\",A::b); } //5\n</code></pre>\n<p>The following code is also valid:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass A\n{\npublic:\n    static const int a=7;\n    static const int b=a;\n};\n\nint main(){ printf(\"%d\\n\",A::b); } //7\n</code></pre>\n<p>But the following is invalid:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass A\n{\npublic:\n    static const int b=a; //error: a was not declare in this scope.\n    static const int a=7;\n};\n\nint main(){ printf(\"%d\\n\",A::b); }\n</code></pre>\n<p>It is unclear what rules applied to lookup of <code>a</code>.</p>\n", "Tags": "<c++><class><static><member>", "OwnerUserId": "2786156", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23947055_23947470_2": {"section_id": 7070, "quality": 1.0, "length": 11}, "so_23947055_23947470_0": {"section_id": 7070, "quality": 0.967741935483871, "length": 30}, "so_23947055_23947470_1": {"section_id": 7070, "quality": 1.0, "length": 15}, "so_23947055_23947470_3": {"section_id": 7093, "quality": 0.9090909090909091, "length": 20}, "so_23947055_23947055_0": {"section_id": 7099, "quality": 0.9375, "length": 15}}, "n3337": {"so_23947055_23947470_1": {"section_id": 6814, "quality": 1.0, "length": 15}, "so_23947055_23947470_0": {"section_id": 6814, "quality": 0.8709677419354839, "length": 27}, "so_23947055_23947470_2": {"section_id": 6814, "quality": 1.0, "length": 11}, "so_23947055_23947470_3": {"section_id": 6837, "quality": 0.6363636363636364, "length": 14}, "so_23947055_23947055_0": {"section_id": 6843, "quality": 0.9375, "length": 15}}, "n4659": {"so_23947055_23947470_1": {"section_id": 8568, "quality": 1.0, "length": 15}, "so_23947055_23947470_0": {"section_id": 8567, "quality": 0.9354838709677419, "length": 29}, "so_23947055_23947055_0": {"section_id": 8600, "quality": 0.9375, "length": 15}, "so_23947055_23947470_3": {"section_id": 8594, "quality": 0.9090909090909091, "length": 20}}}, "23947539": {"ParentId": "23947055", "CommentCount": "0", "Body": "<pre><code>#include &lt;stdio.h&gt;\n\nconst int a=5;\nclass A\n{\n  public:\n    static const int b=a; // The quote corresponds to the lookup for a.\n                          // It says that the lookup logic for a is the same\n                          // as the lookup for a name in a member function of A\n};\n</code></pre>\n<p>If you have member function, let's make it <code>static</code> for easy comparison, let's see what the lookup for a name in the function looks like.</p>\n<pre><code>class A\n{\n  public:\n    static void fun()\n    {\n       b = a;\n       // The lookup for a:\n       // 1. A local variable in the function.\n       // 2. A `static` member of the class.\n       // 3. A variable in the enclosing namespace.\n    }\n\n    static const int b;\n};\n</code></pre>\n<p>When you use</p>\n<pre><code>    static const int b = a;\n</code></pre>\n<p>the lookup for <code>a</code> will be (2) and (3) from the function <code>foo</code> since <code>a</code> cannot be a local variable.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "23947539", "Score": "0", "CreationDate": "2014-05-30T05:19:28.640", "LastActivityDate": "2014-05-30T05:19:28.640"}, "23947470": {"ParentId": "23947055", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>An in-class declaration of a static data member is not a definition even if it includes an initializer. Therefore \u00a73.4.1/13 does not apply to your example.</p>\n<p>Name lookup in class scope is defined by the rules of which scopes reach a class scope. \u00a73.3.7/1.1:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_23947055_23947470_0\">The potential scope of a name declared in a class consists not only of the declarative region following the name\u2019s point of declaration,\n  but also of all function bodies, default arguments,\n  exception-specifications, and brace-or-equal-initializers of\n  non-static data members in that class (including such things in nested\n  classes).</p></li>\n<li><p id=\"so_23947055_23947470_1\">A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S. No\n  diagnostic is required for a violation of this rule.</p></li>\n<li><p id=\"so_23947055_23947470_2\">If reordering member declarations in a class yields an alternate valid program under (1) and (2), the program is ill-formed, no\n  diagnostic is required.</p></li>\n</ol>\n</blockquote>\n<p>The purpose of these rules is to allow a member function to access member variables that are declared later in the class. Because the rules don't mention initializers of static data members, name lookup from a static data member defaults to 3.4.1/7:</p>\n<blockquote>\n<p id=\"so_23947055_23947470_3\">A name used in the definition of a class X outside of a member\n  function body, default argument, exception- specification,\n  brace-or-equal-initializer of a non-static data member, or nested\n  class definition shall be declared in one of the following ways:</p>\n</blockquote>\n<p>The list essentially boils down to \"a name must be a member of the same class, or declared in an enclosing scope.\" In your first example, <code>a</code> is declared in the enclosing namespace, so it is found. In the second example, <code>a</code> is declared before it is used.</p>\n<p>But in the third example, it is used before it is declared which is illegal \u2014 and if there was a declaration of some <code>a</code> in the enclosing namespace, it would be undefined behavior due to 3.3.7/1.2.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2014-05-30T05:24:25.553", "Id": "23947470", "Score": "2", "CreationDate": "2014-05-30T05:12:23.820", "LastActivityDate": "2014-05-30T05:24:25.553"}});