post_cb({"39138194": {"ParentId": "39137335", "CommentCount": "0", "Body": "<blockquote id=\"so_39137335_39138194_0\">\n<ul>\n<li>&amp;f1 should be the address of a function pointer, why is it can be passed to f3 as void *?</li>\n</ul>\n</blockquote>\n<p>That is correct, and that is <em>exactly</em> why it succeeds. Because a pointer-to-a-pointer can be implicitly converted to <code>void *</code>, irrespective of what data type its target points to.</p>\n<blockquote id=\"so_39137335_39138194_1\">\n<ul>\n<li>Why &amp;f2 is <code>void *(*)()</code>? And what does <code>void *(*)()</code> even mean?</li>\n</ul>\n</blockquote>\n<p>You may be misunderstanding function pointer notation. <code>void *(*)()</code> is the notation for a function pointer. <code>void *f2(void)</code> is a function that returns a void pointer. <code>&amp;f2</code> is a function pointer (to that function). The compiler is telling you that it can't implicitly convert a function pointer to <code>void *</code> (per the C standard, this is not guaranteed, and your compiler apparently isn't capable of doing it).</p>\n<p>That's the scoop.</p>\n", "OwnerUserId": "3403663", "PostTypeId": "2", "Id": "39138194", "Score": "0", "CreationDate": "2016-08-25T06:31:46.377", "LastActivityDate": "2016-08-25T06:31:46.377"}, "39137439": {"ParentId": "39137335", "LastEditDate": "2017-05-23T12:08:31.177", "CommentCount": "5", "CreationDate": "2016-08-25T05:38:35.887", "OwnerUserId": "15168", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "39137439", "Score": "6", "Body": "<p>You're right that the first is a pointer to a function and the second is a function declaration.</p>\n<p>That means that the compiler is correct about the warnings, too.</p>\n<p>The first call (<code>f3(&amp;f1)</code>) passes the address of the function pointer, which is convertible to <code>void *</code> (contrary to a previous comment of mine).  So, there's no error required.  (It's a pointer to a function pointer, and therefore a data object, not a function pointer.  Omit the <code>&amp;</code> and you get the same error as with the second call.)</p>\n<p>The second call (<code>f3(&amp;f2)</code>) passes a pointer to a function, and function pointers and <code>void</code> pointers are not inter-convertible.  The <code>&amp;</code> in front of the function name is superfluous \u2014 and mildly misleading in context.  You can add an arbitrary number of <code>*</code>, or a single <code>&amp;</code> (or omit them all) from a function name and it is treated the same \u2014 one of the weirder aspects of standard C.  (See also <a href=\"https://stackoverflow.com/questions/6893285/\">Why do function pointer definitions work with any number of ampersands '&amp;' or asterisks '*'?</a>)</p>\n<p>I note that I had to use <code>-pedantic</code> to get GCC to complain about it at all.  That's a consequence of the standard documenting a common extension in Annex J:</p>\n<blockquote>\n<h3>J.5.7 Function pointer casts</h3>\n<p id=\"so_39137335_39137439_0\">\u00b61 A pointer to an object or to <code>void</code> may be cast to a pointer to a function, allowing data to\n  be invoked as a function (6.5.4).</p>\n<p id=\"so_39137335_39137439_1\">\u00b62 A pointer to a function may be cast to a pointer to an object or to <code>void</code>, allowing a\n  function to be inspected or modified (for example, by a debugger) (6.5.4).</p>\n</blockquote>\n<p>You ask what <code>void *(*)()</code> means.  It is the 'cast' form of a pointer to a function that takes an indeterminate argument list (but not a variadic one with ellipsis <code>...</code> at the end) and returns a pointer to a function. </p>\n<hr>\n<p><a href=\"https://stackoverflow.com/users/2455888/haccks\">haccks</a> <a href=\"https://stackoverflow.com/questions/39137335/confusion-about-c-function-pointer/39137439#comment65619457_39137439\">asked</a>:</p>\n<blockquote>\n<p id=\"so_39137335_39137439_2\">Could you please add a reference from C standard about function pointers and void pointers are not inter-convertible? </p>\n</blockquote>\n<p>Yes \u2014 that's easy:</p>\n<blockquote>\n<h3>6.2.5 Types</h3>\n<p id=\"so_39137335_39137439_3\">\u00b61 \u2026 Types are partitioned into object types (types that describe objects) and function types (types that describe functions). </p>\n<h2>6.3 Conversions</h2>\n<h3>6.3.2.3 Pointers</h3>\n<p id=\"so_39137335_39137439_4\">\u00b61 A pointer to <code>void</code> may be converted to or from a pointer to any object type. A pointer to any object type may be converted to a pointer to <code>void</code> and back again; the result shall compare equal to the original pointer.</p>\n<p id=\"so_39137335_39137439_5\">\u00b67 A pointer to an object type may be converted to a pointer to a different object type. If the\n  resulting pointer is not correctly aligned<sup>68)</sup> for the referenced type, the behavior is\n  undefined. Otherwise, when converted back again, the result shall compare equal to the\n  original pointer. When a pointer to an object is converted to a pointer to a character type,\n  the result points to the lowest addressed byte of the object. Successive increments of the\n  result, up to the size of the object, yield pointers to the remaining bytes of the object.</p>\n<p id=\"so_39137335_39137439_6\">\u00b68 A pointer to a function of one type may be converted to a pointer to a function of another\n  type and back again; the result shall compare equal to the original pointer. If a converted\n  pointer is used to call a function whose type is not compatible with the referenced type,\n  the behavior is undefined.</p>\n</blockquote>\n<p>Those are the only defined conversions for between pointer types.  There's nothing there about converting between pointers to objects and pointers to functions, so it isn't allowed (but a diagnostic is not necessarily required; it isn't in a 'constraints' section of the standard).</p>\n<h3>Tested code</h3>\n<p>Variant 1 (<code>pf19.c</code>):</p>\n<pre><code>void (*f1)(void);\nvoid *f2(void);\n\nvoid f3(void *p_func);\n\nint main(void)\n{\n    f3(&amp;f1);\n    f3(&amp;f2);\n}\n</code></pre>\n<p>Compilation warnings (errors because of <code>-Werror</code> and <code>-pedantic</code>):</p>\n<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes  -Wold-style-definition -pedantic -c pf19.c\npf19.c: In function \u2018main\u2019:\npf19.c:9:12: error: ISO C forbids passing argument 1 of \u2018f3\u2019 between function pointer and \u2018void *\u2019 [-Werror=pedantic]\n         f3(&amp;f2); //&lt;----------Compiler error\n            ^\npf19.c:4:6: note: expected \u2018void *\u2019 but argument is of type \u2018void * (*)(void)\u2019\n void f3(void *p_func);\n      ^~\ncc1: all warnings being treated as errors\n</code></pre>\n<p>Variant 2 (also <code>pf19.c</code>):</p>\n<pre><code>void (*f1)(void);\nvoid *f2(void);\n\nvoid f3(void *p_func);\n\nint main(void)\n{\n    f3(f1);\n    f3(&amp;f2);\n}\n</code></pre>\n<p>Compilation messages:</p>\n<pre><code>$ gcc -O3   -g      -std=c11   -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes  -Wold-style-definition      -pedantic -c pf19.c\npf19.c: In function \u2018main\u2019:\npf19.c:8:8: error: ISO C forbids passing argument 1 of \u2018f3\u2019 between function pointer and \u2018void *\u2019 [-Werror=pedantic]\n     f3(f1);\n        ^~\npf19.c:4:6: note: expected \u2018void *\u2019 but argument is of type \u2018void (*)(void)\u2019\n void f3(void *p_func);\n      ^~\npf19.c:9:8: error: ISO C forbids passing argument 1 of \u2018f3\u2019 between function pointer and \u2018void *\u2019 [-Werror=pedantic]\n     f3(&amp;f2);\n        ^\npf19.c:4:6: note: expected \u2018void *\u2019 but argument is of type \u2018void * (*)(void)\u2019\n void f3(void *p_func);\n      ^~\ncc1: all warnings being treated as errors\n$\n</code></pre>\n<p>The wording of the message is different from a C compiler compared with a C++ compiler, but the intent is the same (<code>pf17.cc</code> is a simple copy of <code>pf19.c</code>):</p>\n<pre><code>$ g++ -O3 -g -I./inc -std=c++11 -Wall -Wextra -Werror    -c pf17.cc\npf17.cc: In function \u2018int main()\u2019:\npf17.cc:8:10: error: invalid conversion from \u2018void (*)()\u2019 to \u2018void*\u2019 [-fpermissive]\n     f3(f1);\n          ^\npf17.cc:4:6: note:   initializing argument 1 of \u2018void f3(void*)\u2019\n void f3(void *p_func);\n      ^~\npf17.cc:9:8: error: invalid conversion from \u2018void* (*)()\u2019 to \u2018void*\u2019 [-fpermissive]\n     f3(&amp;f2);\n        ^~~\npf17.cc:4:6: note:   initializing argument 1 of \u2018void f3(void*)\u2019\n void f3(void *p_func);\n      ^~\n$\n</code></pre>\n<p>Testing: GCC 6.2.0 on Mac OS X 10.11.6 El Capitan.</p>\n<hr>\n<p><sup><em>Thanks to <a href=\"https://stackoverflow.com/users/929459/dmitri\">Dmitri</a> for <a href=\"https://stackoverflow.com/questions/39137335/confusion-about-c-function-pointer/39137439#comment65619801_39137439\">noting</a> that \u00a76.3.2.3 \u00b61 was relevant, and Annex J.5.7.</em></sup></p>\n</hr></hr>", "LastActivityDate": "2016-08-25T15:42:00.757"}, "39137434": {"ParentId": "39137335", "LastEditDate": "2016-08-25T06:04:18.603", "CommentCount": "2", "CreationDate": "2016-08-25T05:38:21.217", "OwnerUserId": "1983495", "LastEditorUserId": "1983495", "PostTypeId": "2", "Id": "39137434", "Score": "2", "Body": "<p>The error message doesn't make sense if this is a <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> program. Because in <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> every pointer is convertible to <code>void *</code> and back without the need for a cast. Your compiler seems to think that there is no way to convert from a pointer to <code>void *</code> which is how <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> works.</p>\n<p>Although comments on your question are correct too, your code should compile in both cases provided it's compiled as <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> code. The standard strictly forbids this kind of conversion but the error message still is the c++ error not the c compiler error, and also the conversion from/to <code>void *</code>/function pointers is a common extension</p>\n<blockquote>\n<p id=\"so_39137335_39137434_0\"><strong>J.5.7 Function pointer casts</strong></p>\n<ol>\n<li>A pointer to an object or to void may be cast to a pointer to a function, allowing data to\n  be invoked as a function (6.5.4).</li>\n<li>A pointer to a function may be cast to a pointer to an object or to void, allowing a\n  function to be inspected or modified (for example, by a debugger) (6.5.4).</li>\n</ol>\n</blockquote>\n<p>though it's not guaranteed that all systems support this, most systems do.</p>\n<p>Possible reasons to be compiliing as <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> are</p>\n<ol>\n<li>You called the c++ compiler directly, for example <code>g++</code></li>\n<li>You named your source file with <em>.cpp</em> extension instead of <em>.c</em></li>\n</ol>\n<p>If it is <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> source code, the error makes sense because <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> does not allow such conversions but in c this might compile correctly (<em>and will most of the time</em>) even though it's strictly forbidden.</p>\n<p>Also note that function pointers in <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> are not the usual way to do things AFAIK. Because when you have an object, you can only create pointers to static members, and that's not too different than having a pointer to a normal function. In <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> callbacks are not so common, and in fact a library that I've used extensively <a href=\"http://www.qt.io\" rel=\"nofollow\">Qt</a> needed (<em>before the c++11 standard</em>) a tool called <em>moc</em> in order to make \"<em>callbacks</em>\" work. The tool generated code from header files to allow callbacks or (<em>a simulation of them</em>) to work in <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a>.</p>\n", "LastActivityDate": "2016-08-25T06:04:18.603"}, "bq_ids": {"n4140": {"so_39137335_39137439_4": {"section_id": 6039, "quality": 0.6190476190476191, "length": 13}, "so_39137335_39138194_0": {"section_id": 7177, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_39137335_39137439_4": {"section_id": 5807, "quality": 0.6190476190476191, "length": 13}, "so_39137335_39138194_0": {"section_id": 6921, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_39137335_39137439_4": {"section_id": 7548, "quality": 0.5238095238095238, "length": 11}, "so_39137335_39138194_0": {"section_id": 8685, "quality": 0.7142857142857143, "length": 5}}}, "39137335": {"CommentCount": "10", "CreationDate": "2016-08-25T05:29:49.367", "PostTypeId": "1", "AcceptedAnswerId": "39137439", "LastEditorUserId": "505088", "LastActivityDate": "2016-08-25T15:42:00.757", "LastEditDate": "2016-08-25T06:05:18.643", "ViewCount": "148", "FavoriteCount": "2", "Title": "Confusion about C++ function pointer", "Id": "39137335", "Score": "1", "Body": "<p>My source file name ends with <code>cpp</code>.</p>\n<p>Below are 2 declarations:</p>\n<pre><code>void (*f1)(void);\n\nvoid *f2(void);\n</code></pre>\n<p>I think:</p>\n<ul>\n<li><code>f1</code> is a valid function pointer.</li>\n<li><code>f2</code> is a function that returns a <code>void *</code> pointer.</li>\n</ul>\n<p>Then I have another function:</p>\n<pre><code>void f3(void *p_func);\n</code></pre>\n<p>I think:</p>\n<ul>\n<li>Despite the <code>p_func</code> parameter name, <code>f3</code> is just a function that takes a <code>void *</code> pointer, i.e. a 32-bit unsigned integer on a 32 bit machine.</li>\n</ul>\n<p>And below 2 statements:</p>\n<pre><code>f3(&amp;f1); //&lt;----------It works\nf3(&amp;f2); //&lt;----------Compiler error\n</code></pre>\n<p>The compiler error is:</p>\n<pre><code>no known conversion from 'void *(*)()' to 'void *' for 2nd argument;\n</code></pre>\n<p>My questions:</p>\n<ul>\n<li><code>&amp;f1</code> should be the address of a function pointer, why it can be passed to <code>f3</code> as <code>void *</code>?</li>\n<li>Why <code>&amp;f2</code> is <code>void *(*)()</code>? </li>\n<li>And what does <code>void *(*)()</code> even mean?</li>\n</ul>\n", "Tags": "<c++><function-pointers>", "OwnerUserId": "264052", "AnswerCount": "3"}});