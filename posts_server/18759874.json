post_cb({"18759989": {"Id": "18759989", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18759874_18759989_0\">My question is how the std::string member function begin() recognises that the object it is being called by is const and so returns a const_iterator.</p>\n</blockquote>\n<p>There are two overloads of <code>begin</code>:</p>\n<pre><code>iterator       begin();\nconst_iterator begin() const;\n</code></pre>\n<p>Which one gets chosen depends on the type of the implicit <code>this</code> parameter when you call a member function - in your case it's either <code>std::string&amp;</code> or <code>const std::string&amp;</code>.</p>\n<p>n3337, 13.3.1</p>\n<blockquote>\n<p id=\"so_18759874_18759989_1\">2 The set of candidate functions can contain both member and non-member functions to be resolved against\n  the same argument list. So that argument and parameter lists are comparable within this heterogeneous\n  set, <strong>a member function is considered to have an extra parameter, called the implicit object parameter, which\n  represents the object for which the member function has been called.</strong> For the purposes of overload resolution,\n  both static and non-static member functions have an implicit object parameter, but constructors do not.</p>\n</blockquote>\n<p>Only <code>const</code> qualified member function can be called on a <code>const</code> qualified object parameter.</p>\n<p>How does compiler know that <code>str</code> is const? Well, you told it in the declaration of <code>Foo</code>.</p>\n", "LastEditorUserId": "947836", "LastActivityDate": "2013-09-12T09:12:17.807", "Score": "3", "CreationDate": "2013-09-12T09:05:52.933", "ParentId": "18759874", "CommentCount": "1", "LastEditDate": "2013-09-12T09:12:17.807", "OwnerUserId": "947836"}, "18760023": {"Id": "18760023", "PostTypeId": "2", "Body": "<p>The compiler automatically selects a const member function if your object is const.</p>\n<p>You will have to provide two member functions:</p>\n<pre><code>void someMethod();\nvoid someMethod() const;\n</code></pre>\n", "LastActivityDate": "2013-09-12T09:07:38.930", "Score": "0", "CreationDate": "2013-09-12T09:07:38.930", "ParentId": "18759874", "CommentCount": "0", "OwnerUserId": "1711146"}, "18759874": {"ViewCount": "663", "Body": "<p>I have the following piece of code</p>\n<pre><code>#include &lt;string&gt;\n\nint Foo(const std::string&amp; str){\n\n    std::string::iterator start;\n\n    start = str.begin();\n\n    return 0;\n}\n</code></pre>\n<p>When i compile it with GCC 4.7.3 i receive an error.As i suspect the error pops up because i am trying to assign a   </p>\n<pre><code>std::string::const_iterator; \n</code></pre>\n<p>to an </p>\n<pre><code>std::string::iterator\n</code></pre>\n<p>So changing the line </p>\n<pre><code>std::string::iterator start; \n</code></pre>\n<p>To</p>\n<pre><code>std::string::const_iterator start;\n</code></pre>\n<p>Compiles it finely.</p>\n<p>My question is how the std::string member function begin() recognises that the object it is being called by is const and so returns a const_iterator.  </p>\n<p>Making the question more general:<br>\nCan i change or somehow overload a class member function to act differently when being called by a const object?</br></p>\n", "AcceptedAnswerId": "18759989", "Title": "Class member function behaviour when calling const objects", "CreationDate": "2013-09-12T09:01:05.040", "Id": "18759874", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-09-12T09:12:17.807", "Score": "0", "OwnerUserId": "2442969", "Tags": "<c++><const>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_18759874_18759989_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 566}}, "n3337": {"so_18759874_18759989_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 557}}, "n4659": {"so_18759874_18759989_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 589}}}, "18759985": {"Id": "18759985", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18759874_18759985_0\">My question is how the std::string member function begin() recognises\n  that the object it is being called by is const and so returns a\n  const_iterator.</p>\n</blockquote>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/begin\" rel=\"nofollow\"><code>begin()</code> method has an overload</a> where that is <code>const</code> qualified that returns a <code>const_iterator</code>. Being <code>const</code> qualified means that it is the one that is used when the object it is being called from is <code>const</code></p>\n<pre><code>iterator begin();\nconst_iterator begin() const;  // This one\n</code></pre>\n<p>With <code>str</code> being <code>const</code>, the second one is called, therefore the object returned is a <code>const_iterator</code>, the you try to assign to an <code>iterator</code> which is invalid and thus the error.</p>\n<hr>\n<blockquote>\n<p id=\"so_18759874_18759985_1\">Can i change or somehow overload a class member function to act\n  differently when being called by a const object?</p>\n</blockquote>\n<p>Use <code>auto</code>! Instead of doing</p>\n<pre><code>std::string::iterator start;\n\nstart = str.begin();\n</code></pre>\n<p>Do</p>\n<pre><code>auto start = str.begin();\n</code></pre>\n<p>With that, you are actually using the <em>exact type</em> of what is being returned by <code>begin()</code>.</p>\n<p>However, you may be doing things the wrong way, as whether you need a const or non-const iterator depends on the task you want to achieve. As a general guideline, always use const iterators unless you intend to modify the elements inside the container.</p>\n</hr>", "LastEditorUserId": "1619294", "LastActivityDate": "2013-09-12T09:11:43.633", "Score": "0", "CreationDate": "2013-09-12T09:05:45.263", "ParentId": "18759874", "CommentCount": "0", "LastEditDate": "2013-09-12T09:11:43.633", "OwnerUserId": "1619294"}});