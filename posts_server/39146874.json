post_cb({"39146874": {"ViewCount": "144", "Body": "<p>I want to pass a non-capturing lambda, which returns a \n<code>std::unique_ptr&lt;Derived&gt;</code>, as a function pointer of type <code>std::unique_ptr&lt;Base&gt;(*)()</code>.</p>\n<p>However, this only works if I explicitly state the return type of the lambda as <code>std::unique_ptr&lt;Base&gt;</code>. </p>\n<ul>\n<li>Why do I have explicitly state the return type?</li>\n<li>Why does it work for a <code>std::function</code> without this extra return type? </li>\n</ul>\n<hr>\n<pre><code>#include &lt;functional&gt;\n#include &lt;memory&gt;\n\nstruct Base{virtual ~Base()=default;};\nstruct Derived : Base{};\n\nstruct FailsForF2\n{\n   using Function = std::add_pointer_t&lt;std::unique_ptr&lt;Base&gt;()&gt;;\n   FailsForF2(Function f) {}\n};\n\nstruct Works\n{\n   using Function = std::function&lt;std::unique_ptr&lt;Base&gt;()&gt;;\n   Works(Function f) {}\n};\n\n\nstd::unique_ptr&lt;Derived&gt; fun() {return std::make_unique&lt;Derived&gt;();} \n\nint main()\n{\n\n   auto f1 = [](){return std::make_unique&lt;Base&gt;();};\n   auto f2 = [](){return std::make_unique&lt;Derived&gt;();};\n   auto f3 = []()-&gt;std::unique_ptr&lt;Base&gt;{return std::make_unique&lt;Derived&gt;();};\n\n   Works x1(f1);\n   Works x2(f2);\n   Works x3(f3);\n\n   FailsForF2 x4(f1);\n   FailsForF2 x5(f2);\n   FailsForF2 x6(f3);\n}\n</code></pre>\n<p><strong>gcc error</strong>:</p>\n<pre><code>main.cpp: In function 'int main()':\n\nmain.cpp:34:20: error: invalid user-defined conversion from 'main()::&lt;lambda()&gt;' to 'FailsForF2::Function {aka std::unique_ptr&lt;Base&gt; (*)()}' [-fpermissive]\n\n    FailsForF2 x5(f2);\n\n                    ^\n\nmain.cpp:26:17: note: candidate is: main()::&lt;lambda()&gt;::operator std::_MakeUniq&lt;Derived&gt;::__single_object (*)()() const &lt;near match&gt;\n\n    auto f2 = [](){return std::make_unique&lt;Derived&gt;();};\n\n                 ^\n\nmain.cpp:26:17: note:   no known conversion from 'std::_MakeUniq&lt;Derived&gt;::__single_object (*)() {aka std::unique_ptr&lt;Derived&gt; (*)()}' to 'FailsForF2::Function {aka std::unique_ptr&lt;Base&gt; (*)()}'\n\nmain.cpp:10:4: note:   initializing argument 1 of 'FailsForF2::FailsForF2(FailsForF2::Function)'\n\n    FailsForF2(Function f) {}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/557ce19ce859a6d4\" rel=\"nofollow\">live example</a></p>\n</hr>", "AcceptedAnswerId": "39147737", "Title": "Passing lambda, which returns polymorphic unique_ptr, as function pointer", "CreationDate": "2016-08-25T13:37:07.220", "Id": "39146874", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-08-25T13:44:35.313", "LastEditorUserId": "678093", "LastActivityDate": "2016-08-25T14:42:09.360", "Score": "4", "OwnerUserId": "678093", "Tags": "<c++><lambda><function-pointers><c++14>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_39146874_39147737_4": {"length": 4, "quality": 1.0, "section_id": 4560}, "so_39146874_39147737_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4651}, "so_39146874_39147737_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5965}}, "n3337": {"so_39146874_39147737_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 5734}, "so_39146874_39147737_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4462}, "so_39146874_39147737_4": {"length": 4, "quality": 1.0, "section_id": 4390}}, "n4659": {"so_39146874_39147737_4": {"length": 4, "quality": 1.0, "section_id": 5932}, "so_39146874_39147737_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6020}, "so_39146874_39147737_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7456}}}, "39148081": {"Id": "39148081", "PostTypeId": "2", "Body": "<p>In addition to Holt's answer, and to cover your first question: You don't necessarily have to specify the return type explicitly as a trailing return type. But since you're creating a <code>unique_ptr&lt;Derived&gt;</code>, but want a <code>unique_ptr&lt;Base&gt;</code>, you should return the latter and perform the conversion within your function.</p>\n<p>So, I believe, that's something along the lines of</p>\n<pre><code>auto f2 = [](){ return std::unique_ptr&lt;Base&gt;{new Derived()}; };\n</code></pre>\n<p>which also compiles.</p>\n", "LastActivityDate": "2016-08-25T14:31:14.117", "CommentCount": "2", "CreationDate": "2016-08-25T14:31:14.117", "ParentId": "39146874", "Score": "1", "OwnerUserId": "5294141"}, "39147737": {"Id": "39147737", "PostTypeId": "2", "Body": "<p><strong>TL;DR;</strong></p>\n<ul>\n<li><code>FailsForF2</code> fails because <code>std::unique_ptr&lt;Derived&gt; (*) ()</code> is not implicitly convertible to <code>std::unique_ptr&lt;Base&gt; (*) ()</code>;</li>\n<li><code>Works</code> works because <code>std::unique_ptr&lt;Derived&gt;</code> is implicitly convertible to <code>std::unique_ptr&lt;Base&gt;</code> (see the standard quotes at the end).</li>\n</ul>\n<hr>\n<p>A lambda is implicitly convertible to a function pointer with the same return type and arguments<sup>1</sup>, so your three lambdas are respectively convertible to:</p>\n<pre><code>std::unique_ptr&lt;Base&gt; (*) ()\nstd::unique_ptr&lt;Derived&gt; (*) ()\nstd::unique_ptr&lt;Base&gt; (*) ()\n</code></pre>\n<p>Since <code>std::unique_ptr&lt;Derived&gt; (*) ()</code> is different from (and not convertible to) <code>std::unique_ptr&lt;Base&gt; (*) ()</code>, there is no viable overload for <code>FailsForF2</code> constructor. See with the following piece of code:</p>\n<pre><code>std::unique_ptr&lt;Derived&gt; (*pfd) () = f2; // Compiles.\nstd::unique_ptr&lt;Base&gt; (*pfb) () = pfd;   // Does not compile (invalid conversion).\n</code></pre>\n<p>When you explicitly specify the return type of the lambda, you change the return type of the call operator of the lambda (the closure type associated to it actually, see the quote at the end), so the conversion is possible.</p>\n<hr>\n<p><code>std::function</code> on the other hand does not have such constraints - The constructor of <code>std::function</code> is templated so it can take any callable:</p>\n<pre><code>template &lt;typename F&gt;\nstd::function(F &amp;&amp;f);\n</code></pre>\n<p>...as long as the following is valid<sup>2</sup>:</p>\n<pre><code>INVOKE(f, std::forward&lt;Args&gt;(args)..., R)\n</code></pre>\n<hr>\n<p><sub><sup>1</sup> Standard quote from N4594, \u00a75.1.5/7 (emphasis is mine): </sub></p>\n<blockquote>\n<p id=\"so_39146874_39147737_0\"><sub>The closure type for a non-generic lambda-expression with no lambda-capture has a conversion function to pointer to function with C++ language linkage (7.5) having <strong>the same parameter and return types</strong> as the\n  closure type\u2019s function call operator. [...]</sub></p>\n</blockquote>\n<p><sub><sup>2</sup> Standard quote from N4594, \u00a720.12.12.2/2: </sub></p>\n<blockquote>\n<p id=\"so_39146874_39147737_1\"><sub>A callable object f of type F is Callable for argument types ArgTypes and return type R if the expression <code>INVOKE (f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is well formed (20.12.2).</sub></p>\n</blockquote>\n<p><sub>...and \u00a720.12.2 (emphasis is mine, 1.1 through 1.6 are about pointer (or alike) to member functions, so not relevant here): </sub></p>\n<blockquote>\n<p id=\"so_39146874_39147737_2\"><sub><sup>1</sup> Define <code>INVOKE (f, t1, t2, ..., tN)</code> as follows:</sub></p>\n<p id=\"so_39146874_39147737_3\"><sub>(1.x) - [...]</sub></p>\n<p id=\"so_39146874_39147737_4\"><sub><sup>(1.7)</sup> - <code>f(t1, t2, ..., tN)</code> in all other cases.</sub></p>\n<p id=\"so_39146874_39147737_5\"><sub><sup>2</sup> Define <code>INVOKE (f, t1, t2, ..., tN, R)</code> as static_cast(<code>INVOKE (f, t1, t2, ..., tN)</code>) if R is cv void, otherwise <code>INVOKE (f, t1, t2, ..., tN)</code> <strong>implicitly converted to R</strong>.</sub></p>\n</blockquote>\n</hr></hr></hr>", "LastEditorUserId": "2666289", "LastActivityDate": "2016-08-25T14:42:09.360", "Score": "5", "CreationDate": "2016-08-25T14:15:26.907", "ParentId": "39146874", "CommentCount": "0", "OwnerUserId": "2666289", "LastEditDate": "2016-08-25T14:42:09.360"}});