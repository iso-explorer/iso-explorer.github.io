post_cb({"35433452": {"ParentId": "35431651", "CommentCount": "2", "Body": "<p>The simple answer is - the compiler didn't fire any warnings because this is a valid expression which could (theoretically) be used on purpose. The expression:</p>\n<pre><code>std::lock_guard&lt;std::mutex&gt;(getMutexObj());\n</code></pre>\n<p>is a functional notation of type conversion, defined in the Standard:</p>\n<blockquote>\n<p id=\"so_35431651_35433452_0\"><strong>5.2.3 Explicit type conversion (functional notation)</strong></p>\n<p id=\"so_35431651_35433452_1\">1) A simple-type-specifier (7.1.6.2) or typename-specifier (14.6)\n  followed by a parenthesized expression-list constructs a value of the\n  specified type given the expression list. If the expression list is a\n  single expression, the type conversion expression is equivalent (in\n  definedness, and if defined in meaning) to the corresponding cast\n  expression (5.4). <em>(...)</em></p>\n</blockquote>\n<p>and is interpreted as static cast (5.2.9.4):</p>\n<blockquote>\n<p id=\"so_35431651_35433452_2\">An expression e can be explicitly converted to a type T using a\n  static_cast of the form static_cast(e) if the declaration <code>T t(e);</code>\n  is well-formed, for some invented temporary variable <code>t</code> (8.5). The\n  effect of such an explicit conversion is the same as performing the\n  declaration and initialization and then using the temporary variable\n  as the result of the conversion. <em>(...)</em></p>\n</blockquote>\n<hr>\n<p>The compiler could not give any of the warnings it does for </p>\n<pre><code>int(23);\nuint16_t remove_me = 23;\n</code></pre>\n<p>Because you are not creating a variable (which could be unused) and the expression <em>does</em> have an effect - which is calling the constructor of <code>std::lock_guard&lt;std::mutex&gt;</code>.</p>\n</hr>", "OwnerUserId": "3941935", "PostTypeId": "2", "Id": "35433452", "Score": "4", "CreationDate": "2016-02-16T13:05:58.013", "LastActivityDate": "2016-02-16T13:05:58.013"}, "35431651": {"CommentCount": "10", "ViewCount": "266", "PostTypeId": "1", "LastEditorUserId": "5218277", "CreationDate": "2016-02-16T11:42:39.180", "LastActivityDate": "2016-02-17T17:14:59.430", "Title": "Why \"constructor invocation\" doesn't fire any compiler (g++) warning?", "AcceptedAnswerId": "35457745", "LastEditDate": "2016-02-17T12:50:22.077", "Id": "35431651", "Score": "2", "Body": "<p>I implemented a shared library which should be thread safe. To protect the critical areas I used <code>std::lock_guard&lt;std::mutex&gt;</code> from the C++11 standard.</p>\n<p>The typo was that I omitted the object itself:</p>\n<pre><code>std::lock_guard&lt;std::mutex&gt;(getMutexObj());\n</code></pre>\n<p>Instead of</p>\n<pre><code>std::lock_guard&lt;std::mutex&gt; lock_obj(getMutexObj());\n</code></pre>\n<p>And copy/pasted it in every place... Needless to say that it took me a while to root cause it when multi threaded applications began to crash unpredictably.</p>\n<p>Just to cover all the points, the declaration of <code>getMutexObj()</code> and the mutex itself are the following:</p>\n<pre><code>...\nmutable std::mutex  m_mutex;\n...\nstd::mutex&amp; getMutexObj() const\n{\n    return m_mutex;\n}\n</code></pre>\n<p>All the code was compiled with <code>g++ 5.2.0</code> with the following warning flags: </p>\n<pre><code>WARNINGS := -pedantic \\\n            -Wall \\\n            -Wextra \\\n            -Werror \\\n            -Wconversion \\\n            -Woverloaded-virtual \\\n            -Wcast-qual \\\n            -Wctor-dtor-privacy \\\n            -Wdisabled-optimization \\\n            -Wuninitialized \\\n            -Wformat=2 \\\n            -Winit-self \\\n            -Wlogical-op \\\n            -Wmissing-declarations \\\n            -Wmissing-include-dirs \\\n            -Wold-style-cast \\\n            -Wredundant-decls \\\n            -Wshadow \\\n            -Wsign-conversion \\\n            -Wsign-promo \\\n            -Wstrict-null-sentinel \\\n            -Wstrict-overflow=5 \\\n            -Wswitch-default \\\n            -Wundef \\\n            -Wunused \\\n            -Wfloat-equal \\\n            -Wsuggest-final-methods \\\n            -Wsuggest-final-types \\\n            -Wzero-as-null-pointer-constant\n</code></pre>\n<p><strong>How comes that the compiler didn't fire any warning on <code>std::lock_guard&lt;std::mutex&gt;(getMutexObj());</code>?</strong></p>\n<p>I tried the following code just to see if the compiler throws warnings on them:</p>\n<pre><code>    std::lock_guard&lt;std::mutex&gt;(getMutexObj());\n    int(23);\n    23;\n    uint16_t remove_me = 23;\n</code></pre>\n<p>and for line 2,3 and 4 I got warnings BUT not for line 1... WHY?</p>\n<pre><code>&lt;.../path/...&gt;:32:16: error: statement has no effect [-Werror=unused-value]\n         int(23);\n                ^\n&lt;.../path/...&gt;:33:11: error: statement has no effect [-Werror=unused-value]\n         23;\n           ^\n&lt;.../path/...&gt;:34:18: error: unused variable 'remove_me' [-Werror=unused-variable]\n         uint16_t remove_me = 23;\n                  ^\ncc1plus: all warnings being treated as errors\n</code></pre>\n<p><strong>EDIT1</strong></p>\n<p>I noticed that the question is a little confusing since almost all of the answers are related to </p>\n<blockquote>\n<p id=\"so_35431651_35431651_0\">for line 2,3 and 4 I got warnings BUT not for line 1... WHY?</p>\n</blockquote>\n<p>However the real question here is:</p>\n<p><strong>How comes that the compiler didn't fire any warning on <code>std::lock_guard&lt;std::mutex&gt;(getMutexObj());</code>?</strong></p>\n<p>Is there any switch at all to make the compiler warn about such code???</p>\n<p><strong>EDIT2</strong></p>\n<p>As <em>cpplearner</em> mentioned in his comment, <code>std::lock_guard&lt;std::mutex&gt;(getMutexObj());</code> is seen as a function declaration of function named <code>getMutexObj</code> which returns <code>std::lock_guard&lt;std::mutex&gt;</code>.</p>\n<p>I looked at the disassembly and saw that in case of <code>std::lock_guard&lt;std::mutex&gt;(getMutexObj());</code>, there are no related opcodes at all.</p>\n<p>However when I changed it to</p>\n<pre><code>std::lock_guard&lt;std::mutex&gt;{getMutexObj()};\n</code></pre>\n<p>and looked at the disassembly, it was compiled as temporal object creation but again without any warning.</p>\n", "Tags": "<c++><multithreading><c++11><compiler-warnings>", "OwnerUserId": "5218277", "AnswerCount": "5"}, "35431980": {"ParentId": "35431651", "CommentCount": "11", "Body": "<p>Unlike <code>23;</code> with the message <em>\"error: statement has no effect\"</em>, creating an unnamed temporary <code>lock_guard</code> <em>does</em> have the effect of locking and unlocking the mutex.</p>\n<p>This has the side effect of a memory barrier that is visible to other threads.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "35431980", "Score": "7", "CreationDate": "2016-02-16T11:57:25.443", "LastActivityDate": "2016-02-16T11:57:25.443"}, "35432033": {"ParentId": "35431651", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The guard is an aggregate data type (in contrast to the primitive types you're comparing it with) where the constructor can contain custom code; so \"statement has no effect\" is (or may be) not correct - it may well be your intention to just construct and immediately destroy an object. \"unused variable\" doesn't match either, as the temporary object has no name and is not persistent until the end of the block.</p>\n", "OwnerUserId": "5794048", "LastEditorUserId": "4850040", "LastEditDate": "2016-02-17T17:14:59.430", "Id": "35432033", "Score": "3", "CreationDate": "2016-02-16T11:59:57.307", "LastActivityDate": "2016-02-17T17:14:59.430"}, "35457745": {"ParentId": "35431651", "PostTypeId": "2", "CommentCount": "1", "Body": "<pre><code>std::lock_guard&lt;std::mutex&gt;(getMutexObj());\n</code></pre>\n<p>This should actually give an error, because it declares a function called <code>getMutexObj</code> but that is already declared with a different return type (and you can't overload on return type). This is a GCC bug, I've reported it as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=69855\" rel=\"nofollow\">bug 69855</a>.</p>\n<p>This case is different:</p>\n<pre><code>std::lock_guard&lt;std::mutex&gt;{getMutexObj()};\n</code></pre>\n<p>This <em>does</em> create a temporary, but there's no warning here because compilers aren't magic.</p>\n<p>Warnings are added to compilers to catch common mistakes, but someone has to actually implement the code to check for it, and issue a warning. That doesn't just happen by magic or by fairies coming and improving the compiler at night when nobody is looking.</p>\n<p>In this case the compiler sees that you are creating a temporary variable, which has side effects (it writes to a global memory location, the mutex, and issues memory barriers). The compiler doesn't know that those side effects are not exactly what you wanted to do, because it's not magic.</p>\n<p>It would be nice if the compiler did warn here, and someone did write a patch for GCC to warn about this, see <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=36587\" rel=\"nofollow\">bug 36587</a>, but as I pointed out in that bug report, it would also warn about valid code. It would be bad if the compiler issued a warning every time you create a temporary variable with side effects. This is a valid scenario using similar syntax:</p>\n<pre><code>std::ofstream( \"./lockfile\" );\n</code></pre>\n<p>This opens an <code>ofstream</code> with a particular name, which will create the file if it doesn't exist already. The compiler should not warn about this, because it's perfectly valid. </p>\n<p>So to warn for your example, but not other similar pieces of code, would require some additional information to tell the compiler that the <code>lock_guard</code> type should never be used this way. That means annotating the <code>lock_guard</code> somehow and teaching the compiler to recognise that annotation. Again, fairies are not going to come and do that work, so it hasn't happened because it hasn't been prioritised and nobody has written a patch.</p>\n<p>GCC supports a <code>warn_unused</code> attribute on constructors, see <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55203\" rel=\"nofollow\">bug 55203</a>, but that wouldn't help for <code>lock_guard</code> because the correct use of the class means it is always \"unused\" (you never refer to it after construction). A different attribute and warning would need to be implemented for this case.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2016-02-17T14:34:06.097", "Id": "35457745", "Score": "5", "CreationDate": "2016-02-17T13:13:46.100", "LastActivityDate": "2016-02-17T14:34:06.097"}, "35432215": {"ParentId": "35431651", "CommentCount": "0", "Body": "<p>I believe is about the compiler not knowing the exact context of a referenced variable. The cases that raise a warning are not referenced values, they are primitive types. The compiler is not aware of what you are trying to accomplish, because it doesn't know what the library does.</p>\n<p>Also, in this case, you are effectively locking the variable. But it could be something else. Like starting something outside your program. You don't really need a name if you are not going to stop that something you started.</p>\n", "OwnerUserId": "4776680", "PostTypeId": "2", "Id": "35432215", "Score": "2", "CreationDate": "2016-02-16T12:07:50.403", "LastActivityDate": "2016-02-16T12:07:50.403"}, "bq_ids": {"n4140": {"so_35431651_35433452_2": {"section_id": 6030, "quality": 0.9333333333333333, "length": 28}, "so_35431651_35433452_0": {"section_id": 367, "quality": 0.6666666666666666, "length": 4}, "so_35431651_35433452_1": {"section_id": 5999, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_35431651_35433452_2": {"section_id": 5798, "quality": 0.9333333333333333, "length": 28}, "so_35431651_35433452_0": {"section_id": 356, "quality": 0.6666666666666666, "length": 4}, "so_35431651_35433452_1": {"section_id": 5767, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_35431651_35433452_0": {"section_id": 379, "quality": 0.6666666666666666, "length": 4}}}});