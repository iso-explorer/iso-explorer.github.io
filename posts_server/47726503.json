post_cb({"bq_ids": {"n4140": {"so_47726503_47759174_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 3957}, "so_47726503_47759174_1": {"length": 20, "quality": 0.625, "section_id": 5421}}, "n3337": {"so_47726503_47759174_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5214}}, "n4659": {"so_47726503_47759174_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6841}, "so_47726503_47759174_1": {"length": 29, "quality": 0.90625, "section_id": 6843}}}, "47726503": {"ViewCount": "137", "Body": "<p>Coming from that question: \n <a href=\"https://stackoverflow.com/questions/47725266/how-to-build-a-custom-macro-that-behaves-differently-when-used-as-constexpr-lik\">How to build a custom macro that behaves differently when used as constexpr (like assert)?</a></p>\n<p>I wonder why it is possible to call a non constexpr function if it is conditional.</p>\n<pre><code>void bla( )\n{\n    std::cout &lt;&lt; \"bla called!\" &lt;&lt; std::endl;\n}\n\nconstexpr bool check(bool condition)\n{\n    //bla(); // can not directly be called -&gt; not constexpr! \n    condition ? void (0) : bla(); // compiles and runs even if condition is true or false!\n\n    // if condition is const, it did not compile because it\n    // directly force execution of non constexpr function\n    true ? void(0): bla(); // also that compiles!, ok, directly evaluated\n    //true ? bla(): void(0); // that did not compile;)\n\n    //false ? void(0): bla(); // that did not compile;)\n    false ? bla(): void(0); // compiles, ok, directly evaluated\n\n    return 0;\n}\n\nint main()\n{\n    check( false );\n    check( true );\n}\n</code></pre>\n<p>Can someone explain which rules are given from the standard?\nAs commented from W.F.: If result is used in constexpr term like an\ntemplate parameter, it fails if condition results in evaluation\nof non constexpr function.</p>\n<p>That makes <code>assert</code> to complain directly while compiling if result is\nused in constexpr term. </p>\n", "AcceptedAnswerId": "47759174", "Title": "calling non constexpr function from constexpr allowed in some conditions", "CreationDate": "2017-12-09T07:48:45.263", "LastActivityDate": "2017-12-11T18:43:11.447", "CommentCount": "7", "LastEditDate": "2017-12-11T17:18:27.847", "PostTypeId": "1", "LastEditorUserId": "878532", "Id": "47726503", "Score": "2", "OwnerUserId": "878532", "Tags": "<c++><c++14><constexpr>", "AnswerCount": "1"}, "47759174": {"Id": "47759174", "PostTypeId": "2", "Body": "<p>A <code>constexpr</code> function implies that it is possible to evaluate the value of the function at compile time. Since this is possible for the input <code>true</code> the function is a valid <code>constexpr</code>. Remember that a <code>constexpr</code> function can have an address just as a regular function, it does not need to be compile time, only when used as a compile time function (which you do not in your example).</p>\n<p>As mentioned on the <code>constexpr</code> page on <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_47726503_47759174_0\">A constexpr function must satisfy the following requirements:</p>\n<ul>\n<li>it must not be virtual</li>\n<li>its return type must be LiteralType</li>\n<li>each of its parameters must be LiteralType</li>\n<li><strong>there exists at least one set of argument values such that an invocation of the function could be an evaluated subexpression of a core constant expression (for constructors, use in a constant initializer is sufficient) (since C++14). No diagnostic is required for a violation of this bullet.</strong> <em>(Emphasis mine)</em></li>\n</ul>\n</blockquote>\n<p>Your function fulfils all of the above requirements: it is not virtual, it returns a literal type, the parameter is literal. And more interestingly last bullet point: there exists at least one set of argument values for which the function is actually fully compile time. (hence my emphasis of the last bullet)</p>\n<p>As W.F. mentioned in the comments, the function can be used compile time, but only for valid inputs, that is, inputs that does not lead to a sub expression that is not compile time constant. So the input <code>true</code> will work, but <code>false</code> will not since it will lead to <code>bla</code> being evaluated.</p>\n<p>This is also stated in the standard: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4700.pdf\" rel=\"nofollow noreferrer\">\u00a710.1.5.5</a>:</p>\n<blockquote>\n<p id=\"so_47726503_47759174_1\">For a constexpr function or constexpr constructor that is neither defaulted nor a template, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of a core constant expression (8.20), or, for a constructor, a constant initializer for some object (6.6.2), the program is ill-formed, no diagnostic required.</p>\n<pre><code>constexpr int f(bool b)\n{ return b ? throw 0 : 0; }   // OK\n\nconstexpr int f() \n{ return f(true); }           // ill-formed, no diagnostic required\n</code></pre>\n</blockquote>\n<p>See the examples from the standard document in particular.</p>\n", "LastEditorUserId": "111143", "LastActivityDate": "2017-12-11T18:43:11.447", "Score": "1", "CreationDate": "2017-12-11T18:32:27.240", "ParentId": "47726503", "CommentCount": "0", "OwnerUserId": "111143", "LastEditDate": "2017-12-11T18:43:11.447"}});