post_cb({"bq_ids": {"n4140": {"so_31565836_31565836_1": {"length": 6, "quality": 0.75, "section_id": 7040}, "so_31565836_31565836_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5908}}, "n3337": {"so_31565836_31565836_1": {"length": 5, "quality": 0.625, "section_id": 6785}, "so_31565836_31565836_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5680}}, "n4659": {"so_31565836_31565836_1": {"length": 6, "quality": 0.75, "section_id": 8537}, "so_31565836_31565836_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7390}}}, "31565836": {"ViewCount": "300", "Body": "<p>Given an example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    static const int numberOfWheels = 4;\n};\n\n// const int A::numberOfWheels;\n\nint main()\n{\n    std::cout &lt;&lt; A::numberOfWheels &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Is it formally undefined behavior(<em>UB</em>) since <code>A::numberOfWheels</code> is <em>used</em> without its definition? (see also <a href=\"https://stackoverflow.com/questions/16190776/do-we-still-need-to-separately-define-static-members-even-if-they-are-initialis\">here</a>). As C++03 states:</p>\n<blockquote>\n<p id=\"so_31565836_31565836_0\">The member shall still be defined in a namespace scope if it is used\n  in the program and the namespace scope definition shall not contain an\n  initializer.</p>\n</blockquote>\n<p>I found that definition of <em>used</em> in C++03 is rather confusing, as it points to <em>potentially-evaluated</em> expression:</p>\n<blockquote>\n<p id=\"so_31565836_31565836_1\">An object or non-overloaded function is <em>used</em> if its name appears in a\n  potentially-evaluated expression.</p>\n</blockquote>\n<p>From my wild guess it excludes expressions such as:</p>\n<pre><code>sizeof(A::numberOfWheels) ;\ntypeid(A::numberOfWheels).name() ;\n</code></pre>\n<p>but not necessarily an expression with overloaded <code>&lt;&lt;</code> operator like above.</p>\n", "AcceptedAnswerId": "31567265", "Title": "Does \"potentially-evaluated\" means the same as \"odr-used\" in C++03?", "CreationDate": "2015-07-22T14:20:25.250", "Id": "31565836", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:21:58.357", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-13T21:35:15.197", "Score": "6", "OwnerUserId": "586873", "Tags": "<c++><language-lawyer><c++03>", "AnswerCount": "1"}, "31567265": {"Id": "31567265", "PostTypeId": "2", "Body": "<p>From these two defect reports it seems that was the intent that it should be very similar to odr-used: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#48\" rel=\"nofollow\">defect report 48: Definitions of unused static members</a> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_31565836_31567265_0\">Originally, all static data members still had to be defined outside\n  the class whether they were used or not.</p>\n<p id=\"so_31565836_31567265_1\">But that restriction was supposed to be lifted so that static data\n  members need not be defined outside the class unless they are used in\n  a manner which requires their definition, in the same manner as\n  namespace-scope variables. In particular, <strong>if an integral/enum const\n  static data member is initialized within the class, and its address is\n  never taken, we agreed that no namespace-scope definition was\n  required.</strong></p>\n</blockquote>\n<p>this modified <code>3.2p2</code> as follows:</p>\n<blockquote>\n<p id=\"so_31565836_31567265_2\">An expression is potentially evaluated unless <strong>it appears where an\n  integral constant expression is required (see 5.19 [expr.const] )</strong>,\n  is the operand of the sizeof operator (5.3.3 [expr.sizeof] ), or is\n  the operand of the typeid operator and the expression does not\n  designate an lvalue of polymorphic class type (5.2.8 [expr.typeid] ).</p>\n</blockquote>\n<p>and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1323.html#82\" rel=\"nofollow\">defect report 82: Definition of \"using\" a constant expression </a>:</p>\n<blockquote>\n<p id=\"so_31565836_31567265_3\">The wording in 3.2  basic.def.odr paragraph 2 about \"potentially\n  evaluated\" is incomplete. It does not distinguish between expressions\n  which are used as \"integral constant expressions\" and those which are\n  not; nor does it distinguish between uses in which an objects address\n  is taken and those in which it is not. (A suitable definition of\n  \"address taken\" could be written without actually saying \"address\".)</p>\n</blockquote>\n<p>But the wording in the standard was not modified to encompassed the stated intent in either defect report and it is not clear why, only added the exception for where a integral constant expression is required. </p>\n<p><b>Update</b></p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2126.html#454\" rel=\"nofollow\">defect report 454: When is a definition of a static data member required? </a> finally synced up the wording of the standard with the intent expressed in defect report 48 and it says: </p>\n<blockquote>\n<p id=\"so_31565836_31567265_4\">As a result of the resolution of core issue 48, the current C++\n  standard is not in sync with existing practice and with user\n  expectations as far as definitions of static data members having const\n  integral or const enumeration type are concerned. Basically what\n  current implementations do is to require a definition only if the\n  address of the constant is taken. Example:</p>\n<pre><code>void f() {\n\n  std::string s;\n  ... \n\n  // current implementations don't require a definition\n  if (s.find('a', 3) == std::string::npos) {\n   ...\n  }\n</code></pre>\n<p id=\"so_31565836_31567265_5\">To the letter of the standard, though, the above requires a definition\n  of npos, since the expression std::string::npos is potentially\n  evaluated. I think this problem would be easily solved with simple\n  changes to 9.4.2  class.static.data paragraph 4, 9.4.2 \n  class.static.data paragraph 5 and 3.2  basic.def.odr paragraph 3.</p>\n</blockquote>\n<p>So for C++03 section <em>[basic.def.odr]</em> was meant to cover close to what we consider the odr-used rules from C++11. There were subsequent changes to the C++11 rules via <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3383.html#712\" rel=\"nofollow\">defect report 712</a> which bring C++11 closer to the C++14 rules.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-25T17:36:40.150", "Score": "5", "CreationDate": "2015-07-22T15:16:16.717", "ParentId": "31565836", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-07-25T17:36:40.150"}});