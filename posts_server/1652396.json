post_cb({"1652404": {"ParentId": "1652396", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>There is no difference; per the standard (\u00a75.2.3):</p>\n<blockquote id=\"so_1652396_1652404_0\">\nA simple-type-specifier (7.1.5) followed by a parenthesized expression-list constructs a value of the specified type given the expression list. If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4).\n</blockquote>\n<p>Since the question specified the difference between <code>type(value)</code> and <code>(type)value</code>, there is absolutely no difference.</p>\n<p>If and only if you're dealing with a comma-separated <em>list</em> of values can there be a difference. In this case:</p>\n<blockquote id=\"so_1652396_1652404_1\">\nIf the expression list specifies more than a single value, the type shall be a class with a suitably declared constructor (8.5, 12.1), and the expression T(x1, x2, ...) is equivalent in effect to the declaration T t(x1, x2, ...); for some invented temporary variable t, with the result being the value of t as an rvalue.\n</blockquote>\n<p>As Troubadour pointed out, there are a certain names of types for which the <code>type(value)</code> version simply won't compile. For example:</p>\n<pre><code>char *a = (char *)string;\n</code></pre>\n<p>will compile, but:</p>\n<pre><code>char *a = char *(string);\n</code></pre>\n<p>will not. The same type with a different name (e.g., created with a <code>typedef</code>) can work though:</p>\n<pre><code>typedef char *char_ptr;\n\nchar *a = char_ptr(string);\n</code></pre>\n", "OwnerUserId": "179910", "LastEditorUserId": "560648", "LastEditDate": "2014-11-25T21:50:57.850", "Id": "1652404", "Score": "50", "CreationDate": "2009-10-30T21:25:03.543", "LastActivityDate": "2014-11-25T21:50:57.850"}, "1652396": {"CommentCount": "1", "AcceptedAnswerId": "1652404", "PostTypeId": "1", "LastEditorUserId": "2310866", "LastEditorDisplayName": "Roger Pate", "CreationDate": "2009-10-30T21:23:15.310", "LastActivityDate": "2015-07-08T03:50:15.977", "LastEditDate": "2014-04-27T16:38:49.093", "ViewCount": "1716", "FavoriteCount": "6", "Title": "What is the difference between (type)value and type(value)?", "Id": "1652396", "Score": "41", "Body": "<p>What is the difference between</p>\n<pre><code>(type)value\n</code></pre>\n<p>and</p>\n<pre><code>type(value)\n</code></pre>\n<p>in C++?</p>\n", "Tags": "<c++><type-conversion><casting>", "OwnerUserId": "199484", "AnswerCount": "5"}, "8461052": {"ParentId": "1652396", "CommentCount": "0", "Body": "<p>There is no difference when both are casts, but sometimes 'type(value)' is not a cast.</p>\n<p>Here's an example from standard draft N3242, section 8.2.1: </p>\n<pre><code>struct S \n{\n    S(int);\n};\n\nvoid foo(double a) \n{\n    S w( int(a) ); // function declaration\n    S y( (int)a ); // object declaration\n}\n</code></pre>\n<p>In this case 'int(a)' is not a cast because 'a' is not a value, it is a parameter name surrounded by redundant parentheses. The document states</p>\n<blockquote>\n<p id=\"so_1652396_8461052_0\">The ambiguity arising from the similarity between a function-style\n  cast and a declaration mentioned in 6.8 can also occur in the context\n  of a declaration. In that context, the choice is between a function\n  declaration with a redundant set of parentheses around a parameter\n  name and an object declaration with a function-style cast as the\n  initializer. Just as for the ambiguities mentioned in 6.8, the\n  resolution is to consider any construct that could possibly be a\n  declaration a declaration.</p>\n</blockquote>\n", "OwnerUserId": "1037360", "PostTypeId": "2", "Id": "8461052", "Score": "5", "CreationDate": "2011-12-11T00:33:44.177", "LastActivityDate": "2011-12-11T00:33:44.177"}, "14803320": {"ParentId": "1652396", "CommentCount": "0", "Body": "<p>In c there is no <code>type (value)</code>, while in c/c++ both <code>type (value)</code> and <code>(type) value</code> are allowed.</p>\n", "OwnerUserId": "1090637", "PostTypeId": "2", "Id": "14803320", "Score": "1", "CreationDate": "2013-02-10T22:27:12.200", "LastActivityDate": "2013-02-10T22:27:12.200"}, "1652539": {"ParentId": "1652396", "CommentCount": "2", "Body": "<p>There is no difference; the C++ standard (1998 and 2003 editions) is clear about this point.  Try the following program, make sure you use a compiler that's compliant, such as the free preview at <a href=\"http://comeaucomputing.com/tryitout/\" rel=\"noreferrer\">http://comeaucomputing.com/tryitout/</a>.</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;string&gt;\nint main() {\n  int('A'); (int) 'A'; // obvious\n  (std::string) \"abc\"; // not so obvious\n  unsigned(a_var) = 3; // see note below\n  (long const&amp;) a_var; // const or refs, which T(v) can't do\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Note: <code>unsigned(a_var)</code> is different, but does show one way those exact tokens can mean something else.  It is declaring a variable named <code>a_var</code> of type unsigned, and isn't a cast at all.  (If you're familiar with pointers to functions or arrays, consider how you have to use a parens around <code>p</code> in a type like <code>void (*pf)()</code> or <code>int (*pa)[42]</code>.)</p>\n<p>(Warnings are produced since these statements don't use the value and in a real program that'd almost certainly be an error, but everything still works.  I just didn't have the heart to change it after making everything line up.)</p>\n", "Id": "1652539", "PostTypeId": "2", "OwnerDisplayName": "Roger Pate", "Score": "13", "CreationDate": "2009-10-30T21:55:06.863", "LastActivityDate": "2009-10-30T21:55:06.863"}, "bq_ids": {"n4140": {"so_1652396_1652404_1": {"section_id": 5999, "quality": 0.9259259259259259, "length": 25}, "so_1652396_1652404_0": {"section_id": 5999, "quality": 0.9615384615384616, "length": 25}, "so_1652396_8461052_0": {"section_id": 3201, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_1652396_1652404_1": {"section_id": 5767, "quality": 0.9259259259259259, "length": 25}, "so_1652396_1652404_0": {"section_id": 5767, "quality": 0.9615384615384616, "length": 25}, "so_1652396_8461052_0": {"section_id": 3075, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_1652396_8461052_0": {"section_id": 3962, "quality": 0.9743589743589743, "length": 38}}}, "31283205": {"ParentId": "1652396", "CommentCount": "0", "Body": "<p>To illustrate your options in C++ (only one has a safety check)</p>\n<pre><code>#include&lt;boost/numeric/conversion/cast.hpp&gt; \n\nusing std::cout;\nusing std::endl;\nint main(){\n\n    float smallf = 100.1;\n\n    cout &lt;&lt; (int)smallf &lt;&lt; endl; // outputs 100 // c cast\n    cout &lt;&lt; int(smallf) &lt;&lt; endl; // outputs 100 // c++ constructor = c cast\n\n    cout &lt;&lt; static_cast&lt;int&gt;(smallf) &lt;&lt; endl; // outputs 100\n//  cout &lt;&lt; static_cast&lt;int&amp;&gt;(smallf) &lt;&lt; endl; // not allowed\n    cout &lt;&lt; reinterpret_cast&lt;int&amp;&gt;(smallf) &lt;&lt; endl; // outputs 1120416563\n    cout &lt;&lt; boost::numeric_cast&lt;int&gt;(smallf) &lt;&lt; endl; // outputs 100\n\n    float bigf = 1.23e12;\n\n    cout &lt;&lt; (int)bigf &lt;&lt; endl; // outputs -2147483648\n    cout &lt;&lt; int(bigf) &lt;&lt; endl; // outputs -2147483648\n\n    cout &lt;&lt; static_cast&lt;int&gt;(bigf) &lt;&lt; endl; // outputs -2147483648\n//  cout &lt;&lt; static_cast&lt;int&amp;&gt;(bigf) &lt;&lt; endl; // not allowed\n    cout &lt;&lt; reinterpret_cast&lt;int&amp;&gt;(bigf) &lt;&lt; endl; // outputs 1401893083\n    cout &lt;&lt; boost::numeric_cast&lt;int&gt;(bigf) &lt;&lt; endl; // throws bad numeric conversion\n}\n</code></pre>\n", "OwnerUserId": "225186", "PostTypeId": "2", "Id": "31283205", "Score": "0", "CreationDate": "2015-07-08T03:50:15.977", "LastActivityDate": "2015-07-08T03:50:15.977"}});