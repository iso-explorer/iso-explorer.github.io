post_cb({"25323356": {"ParentId": "25323026", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Constructors affect assignment via the implicit copy assignment operator:</p>\n<pre><code>test&amp; operator=(test const&amp;) = default;\n</code></pre>\n<p>The effect is:</p>\n<pre><code>test&lt;std::string&gt; a;\nstd::string b;\nstd::move(a) = std::move(b);\n// a.operator=(b) constructs a temporary test&lt;std::string&gt; from b\n</code></pre>\n<p>If you <code>delete</code> the copy assignment operator, then <code>is_assignable</code> will become <code>false</code> in both cases.</p>\n<p>An alternative is to mark your converting constructors <code>explicit</code>; this will prevent them being available to convert the RHS operand of the assignment operator.</p>\n<p>To correct the determination of the compiler on your variadic template constructor, you can use <code>decltype</code> SFINAE:</p>\n<pre><code>template &lt;typename... Args,\n    typename = decltype(Ty(std::forward&lt;Args&gt;(std::declval&lt;Args&gt;())...))&gt;\ntest(Args&amp;&amp;... args) : val(std::forward&lt;Args&gt;(args)...) {}\n</code></pre>\n<p>The difference in behaviour between gcc and Visual Studio is a non-standard extension on the part of the latter compiler: <a href=\"https://stackoverflow.com/questions/11508607/rvalue-to-lvalue-conversion-visual-studio\">rvalue to lvalue conversion Visual Studio</a>. This allows the lvalue reference in the <code>std::string&amp;</code> constructor to bind to the xvalue <code>std::string</code> returned from <code>std::declval&lt;std::string&gt;</code> in the definition of <code>is_assignable</code>. gcc will give the same result if you pass <code>std::string&amp;</code> to <code>is_assignable</code> or alternatively if you make that constructor take a <code>const</code> lvalue reference or a rvalue reference.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:49:31.090", "Id": "25323356", "Score": "2", "CreationDate": "2014-08-15T08:23:53.703", "LastActivityDate": "2014-08-15T08:53:38.543"}, "25323026": {"CommentCount": "2", "ViewCount": "108", "CreationDate": "2014-08-15T07:57:07.703", "LastActivityDate": "2014-08-15T08:53:38.543", "Title": "std::is_assignable<A, B>::value always true when A has variadic constructor", "AcceptedAnswerId": "25323153", "PostTypeId": "1", "Id": "25323026", "Score": "1", "Body": "<p>Hopefully the problem is obvious from the question :)\nIf not, consider the following code:</p>\n<pre><code>template &lt;typename Ty&gt;\nclass test\n{\npublic:\n    test(std::string &amp;v) : val(v) {}\n\n    template &lt;typename... Args&gt;\n    test(Args&amp;&amp;... args) : val(std::forward&lt;Args&gt;(args)...) {}\n\n    Ty val;\n};\n\nint main(void)\n{\n    std::cout &lt;&lt; std::is_assignable&lt;test&lt;std::string&gt;, std::string&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::is_assignable&lt;test&lt;std::string&gt;, std::vector&lt;int&gt;&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The output is true in both cases, tested using Visual Studio 2013 update 3 as well as ideone. This just seems wrong to me on many different levels. For one, attempting to construct/assign <code>std::vector&lt;int&gt;</code> to an instance of the type <code>test&lt;std::string&gt;</code> will not compile (obviously). I can live with this as the compiler is likely just checking types and whether or not an acceptable function exists (and not whether or not said function compiles).</p>\n<p>What bugs me the most is that constructors should have no effect on assignment. This seems to be true (at least in GCC) when removing the variadic constructor. The output is then false in both cases. On Visual Studio, the output is still true for the first line of output; I'll file a bug on that tomorrow.</p>\n<p>Anyway, is this correct behavior? It seems quite counter-intuitive.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "692061", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25323026_25323153_0": {"section_id": 4706, "quality": 0.8823529411764706, "length": 45}}, "n3337": {"so_25323026_25323153_0": {"section_id": 4515, "quality": 0.8823529411764706, "length": 45}}, "n4659": {"so_25323026_25323153_0": {"section_id": 6103, "quality": 0.8823529411764706, "length": 45}}}, "25323153": {"ParentId": "25323026", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This doesn't have much to do with variadic constructor templates. The problem is that you have a constructor template taking an unconstrained universal reference parameter. Using the following constructor also prints <code>1</code> in both cases:</p>\n<pre><code>template &lt;typename Args&gt;\ntest(Args&amp;&amp; args) : val(std::forward&lt;Args&gt;(args)) {}\n</code></pre>\n<p>The definition of <code>is_assignable</code> is (\u00a720.10.4.3 [meta.unary.prop], Table 49):</p>\n<blockquote>\n<p id=\"so_25323026_25323153_0\">The expression <code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> is well-formed when\n  treated as an unevaluated operand  (Clause 5). Access checking is\n  performed as if in a context unrelated to <code>T</code> and <code>U</code>. Only the\n  validity of the immediate context of the assignment expression is\n  considered. [ <em>Note</em>: The compilation of the expression can result in\n  side effects such as the instantiation of class template\n  specializations and function template specializations, the generation\n  of implicitly-defined functions, and so on. Such side effects are not\n  in the \u201cimmediate context\u201d and can result in the program being\n  ill-formed. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>This allows implicit conversion sequences to be used. Universal references can bind to <em>everything</em>, so your variadic constructor defines implicit conversions from <em>everything</em> to <code>test</code>. (Your constructor taking a <code>std::string &amp;</code> doesn't have an effect on <code>is_assignable</code> because the return type of <code>declval&lt;std::string&gt;()</code> is an rvalue reference and so doesn't bind to non-const lvalue references.)</p>\n<p>If you don't want this to happen, mark your constructor <code>explicit</code>. It's probably also a good idea to constrain your variadic template constructor using <code>std::is_constructible</code>:</p>\n<pre><code>template &lt;typename... Args, typename = typename std::enable_if&lt;std::is_constructible&lt;Ty, Args...&gt;::value&gt;::type&gt;\nexplicit test(Args&amp;&amp;... args) : val(std::forward&lt;Args&gt;(args)...) {}\n</code></pre>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-15T08:33:46.730", "Id": "25323153", "Score": "4", "CreationDate": "2014-08-15T08:07:13.260", "LastActivityDate": "2014-08-15T08:33:46.730"}});