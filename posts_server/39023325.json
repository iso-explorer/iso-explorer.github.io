post_cb({"bq_ids": {"n4140": {"so_39023325_39023634_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 451}}, "n3337": {"so_39023325_39023634_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 442}}, "n4659": {"so_39023325_39023634_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 474}}}, "39023634": {"Id": "39023634", "PostTypeId": "2", "Body": "<p>No it can't: overload resolution always considers non-templated functions first, and when a <code>delete</code>d one is encountered, overload resolution <em>fails</em> rather than a template overload being considered.</p>\n<p>Allow me to introduce the default constructor into your class with the line</p>\n<p><code>Foo() = default;</code></p>\n<p>Then, consider two variables</p>\n<pre><code>Foo&lt;double&gt; double_foo;\nFoo&lt;int&gt; int_foo;\n</code></pre>\n<p>Then note</p>\n<ol>\n<li><code>Foo&lt;int&gt; bar(double_foo);</code> is allowed due to the template</li>\n<li><code>Foo&lt;int&gt; bar(int_foo);</code> is not allowed due to the <code>delete</code>d constructor</li>\n<li><code>Foo&lt;int&gt; bar = Foo&lt;int&gt;();</code> <em>would</em> be allowed if you had re-introduced the <em>move constructor</em> by writing <code>Foo(const Foo&amp;&amp;) = default;</code>. You need to use the <code>=</code> syntax here since <code>Foo&lt;int&gt; bar(Foo&lt;int&gt;());</code> is a forward declaration.</li>\n</ol>\n<p>Finally, your assertion \"the copy constructor must not be a template function\" is not correct. Credit to @LightnessRacesInOrbit:</p>\n<blockquote>\n<p id=\"so_39023325_39023634_0\">C++14 12.8.2 \"A non-template constructor for class X is a copy\n  constructor if its first parameter is of type X&amp;, const X&amp;, volatile\n  X&amp; or const volatile X&amp;, and either there are no other parameters or\n  else all other parameters have default arguments (8.3.6).</p>\n</blockquote>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2016-08-18T17:00:58.387", "Score": "3", "CreationDate": "2016-08-18T16:52:07.537", "ParentId": "39023325", "CommentCount": "2", "OwnerUserId": "2380830", "LastEditDate": "2016-08-18T17:00:58.387"}, "39023325": {"ViewCount": "128", "Body": "<p>Consider</p>\n<pre><code>template&lt;typename T&gt;\nstruct Foo\n{\n    Foo(const Foo&amp;) = delete;\n    template &lt;typename Y&gt;\n    Foo(const Foo&lt;Y&gt;&amp;){}\n};\n</code></pre>\n<p>Does the appropriate instantiation of the template constructor stand in for the copy constructor? I know it doesn't normally (since the copy constructor must not be a template function) but here I've deleted the copy constructor.</p>\n", "AcceptedAnswerId": "39023634", "Title": "Can a templatised constructor stand in for a deleted copy constructor?", "CreationDate": "2016-08-18T16:33:07.423", "Id": "39023325", "CommentCount": "5", "LastEditDate": "2016-08-18T16:35:49.780", "PostTypeId": "1", "LastEditorUserId": "6448768", "LastActivityDate": "2016-08-18T17:00:58.387", "Score": "7", "OwnerUserId": "6448768", "Tags": "<c++>", "AnswerCount": "2"}, "39023526": {"Id": "39023526", "PostTypeId": "2", "Body": "<p>The trouble here is that deleted functions still participate in overload resolution.  So given</p>\n<pre><code>Foo&lt;int&gt; a;\nFoo&lt;int&gt; b{a};\n</code></pre>\n<p>the viable functions are the deleted copy constructor and the template constructor with deduced template argument <code>int</code>.  Being a non-template, the deleted copy constructor wins.  And using the deleted function makes the program ill-formed.</p>\n<p>So no, a template constructor cannot ever be instantiated as a copy constructor for copying an object of the same type.</p>\n", "LastActivityDate": "2016-08-18T16:44:50.513", "CommentCount": "0", "CreationDate": "2016-08-18T16:44:50.513", "ParentId": "39023325", "Score": "4", "OwnerUserId": "459640"}});