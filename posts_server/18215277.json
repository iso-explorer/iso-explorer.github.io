post_cb({"18216316": {"Id": "18216316", "PostTypeId": "2", "Body": "<p>One difference which comes to mind is that the first form can be used even if the constructor is declared <code>explicit</code> while the second cannot. Sorry but, @Timothy Shields and @Tomek are wrong, both statements are direct initializations, not copy initialization.</p>\n", "LastActivityDate": "2013-08-13T18:17:33.917", "CommentCount": "0", "CreationDate": "2013-08-13T18:17:33.917", "ParentId": "18215277", "Score": "1", "OwnerUserId": "440004"}, "18215991": {"Id": "18215991", "PostTypeId": "2", "Body": "<h1>1.</h1>\n<pre><code>vector&lt;double&gt; v { 0.0, 1.1, 2.2, 3.3 };\n</code></pre>\n<p>Is a <em>direct-list-initialization</em>. It means that it is initialized with a constructor taking an initializer list.</p>\n<p>Constructor :</p>\n<pre><code>vector( std::initializer_list&lt;T&gt; init, const Allocator&amp; alloc = Allocator() );\n</code></pre>\n<h1>2.</h1>\n<pre><code>vector&lt;double&gt; v = { 0.0, 1.1, 2.2, 3.3 };\n</code></pre>\n<p>Is a <em>copy-list-initialization</em>.</p>\n<hr>\n<p>The standard is pretty clear :</p>\n<blockquote>\n<p id=\"so_18215277_18215991_0\"><strong>8.5.4 List-initialization [dcl.init.list]</strong></p>\n<p id=\"so_18215277_18215991_1\">List-initialization is initialization of an object or reference from a braced-init-list. Such an initializer is called an initializer list, and the comma-separated initializer-clauses of the list are called the elements of the initializer list. An initializer list may be empty. List-initialization can occur in direct-initialization or copyinitialization contexts; list-initialization in a direct-initialization context is called direct-list-initialization and list-initialization in a copy-initialization context is called copy-list-initialization. [ Note: List-initialization\n  can be used :</p>\n<ul>\n<li><strong>as the initializer in a variable de\ufb01nition</strong></li>\n</ul>\n<p id=\"so_18215277_18215991_2\"><strong>[...]</strong></p>\n<p id=\"so_18215277_18215991_3\">Example :</p>\n<pre><code>  std::complex&lt;double&gt; z{1,2};\n\n  [...]\n\n  std::map&lt;std::string,int&gt; anim = { {\"bear\",4}, {\"cassowary\",2}, {\"tiger\",7} };\n</code></pre>\n</blockquote>\n<p>For the difference between both, we should go a little bit further :</p>\n<blockquote>\n<p id=\"so_18215277_18215991_4\"><strong>13.3.1.7 Initialization by list-initialization [over.match.list]</strong></p>\n<ul>\n<li>For <em>direct-list-initialization</em>, the candidate functions are all the constructors of the class T.</li>\n<li>For <em>copy-list-initialization</em>, the candidate functions are all the constructors of T. \n  <strong>However, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed.</strong> [ Note: This restriction only applies if this initialization is part of the \ufb01nal result of overload resolution \u2014 end note ]</li>\n</ul>\n</blockquote>\n</hr>", "LastEditorUserId": "1394283", "LastActivityDate": "2013-08-14T08:08:06.723", "Score": "8", "CreationDate": "2013-08-13T17:57:43.030", "ParentId": "18215277", "CommentCount": "2", "OwnerUserId": "1394283", "LastEditDate": "2013-08-14T08:08:06.723"}, "bq_ids": {"n4140": {"so_18215277_18216193_0": {"length": 6, "quality": 1.0, "section_id": 599}, "so_18215277_18215991_1": {"length": 39, "quality": 0.975, "section_id": 3323}}, "n3337": {"so_18215277_18216193_0": {"length": 6, "quality": 1.0, "section_id": 589}, "so_18215277_18215991_1": {"length": 39, "quality": 0.975, "section_id": 3193}}, "n4659": {"so_18215277_18216193_0": {"length": 6, "quality": 1.0, "section_id": 622}, "so_18215277_18215991_1": {"length": 36, "quality": 0.9, "section_id": 4089}}}, "18215277": {"ViewCount": "420", "Body": "<p>Is there any subtle difference between these two ways of initializing variables in C++11?</p>\n<ol>\n<li><p><code>vector&lt;double&gt; v { 0.0, 1.1, 2.2, 3.3 };</code></p></li>\n<li><p><code>vector&lt;double&gt; v = { 0.0, 1.1, 2.2, 3.3 };</code></p></li>\n</ol>\n<p>Can the latter be used for all the same cases as the first one?</p>\n<p>Stroustrup claims in <a href=\"http://www.stroustrup.com/4th.html\" rel=\"nofollow noreferrer\">TCPL4ED</a> that the first way is the only one that can be used in every context, and thus recommends it. Later on, he seems to imply that the second one is just a different way of writing the first one.</p>\n", "AcceptedAnswerId": "18215991", "Title": "Is there any subtle difference between prepending '=' to initializer lists?", "CreationDate": "2013-08-13T17:13:50.480", "Id": "18215277", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-08-19T13:48:00.297", "LastEditorUserId": "269753", "LastActivityDate": "2013-08-19T13:48:00.297", "Score": "13", "OwnerUserId": "269753", "Tags": "<c++><c++11>", "AnswerCount": "4"}, "18215354": {"Id": "18215354", "PostTypeId": "2", "Body": "<p>I guess this is similar to the case with normal constructors (ie not using initializer lists). The first choice is a construction using (in this case) constructor taking initializer list constructor. The other choice is a temporary created with initializer list constructor and then the variable is copy-constructed from that. Temporary then goes away. Note that the latter usually skips temporary and copy destruction as (N)RVO kicks in BUT the latter requires that your class has accessible copy constructor at the point of definition. At least this is what I remember from C++03, it MAY have changed in C++11.</p>\n", "LastActivityDate": "2013-08-13T17:19:45.643", "CommentCount": "1", "CreationDate": "2013-08-13T17:19:45.643", "ParentId": "18215277", "Score": "0", "OwnerUserId": "25406"}, "18216193": {"Id": "18216193", "PostTypeId": "2", "Body": "<p>The purpose of uniform initialization was (in part) to <em>remove</em> the difference between these two constructs. To ensure that they would have the same functionality.</p>\n<p>Sadly, they failed. There is <em>exactly one difference</em> between direct-list-initialization (ie: <code>T t{...}</code>) and copy-list-initialization (ie: <code>T t = {...}</code>). You don't need a copy/move constructor for copy-list-initialization (despite the name); section 8.5.4 doesn't list that as a requirement. There's no notion of a temporary being constructed that might be elided away. They have identical behavior <em>except</em>:</p>\n<p>Copy-list-initialization will fail if it selects an <code>explicit</code> constructor. That's the only difference.</p>\n<p>It's hard to give a quote from the spec, because there are only 3 mentions of what copy-list-initialization is. One is in 8.5.4, where it defines that copy-list-initialization is a form of list-initialization, another stating that returning a braced-init-list uses copy-list-initialization. And the last in 13.3.1.7, where it states the above exception:</p>\n<blockquote>\n<p id=\"so_18215277_18216193_0\">In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>So that's the only difference.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2013-08-13T18:15:26.220", "Score": "5", "CreationDate": "2013-08-13T18:10:17.880", "ParentId": "18215277", "CommentCount": "0", "OwnerUserId": "734069", "LastEditDate": "2013-08-13T18:15:26.220"}});