post_cb({"36571636": {"ParentId": "36571061", "CommentCount": "0", "Body": "<p>You need to put the inline function definition inside your header file (they both must appear in every translation unit where they are used), you can separate declaration and definition but both must be in the header file. Also they must be declared as inline.</p>\n<p>N4140 dcl.fct.spec 7.1.2.4</p>\n<blockquote>\n<p id=\"so_36571061_36571636_0\">An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly\n  the same definition in every case (3.2). [ Note: A call to the inline function may be encountered before its\n  definition appears in the translation unit. \u2014end note ] If the definition of a function appears in a translation\n  unit before its first declaration as inline, the program is ill-formed.</p>\n</blockquote>\n", "OwnerUserId": "471160", "PostTypeId": "2", "Id": "36571636", "Score": "2", "CreationDate": "2016-04-12T11:14:29.657", "LastActivityDate": "2016-04-12T11:14:29.657"}, "bq_ids": {"n4140": {"so_36571061_36571636_0": {"section_id": 5404, "quality": 0.9210526315789473, "length": 35}}, "n3337": {"so_36571061_36571636_0": {"section_id": 5199, "quality": 0.9210526315789473, "length": 35}}, "n4659": {"so_36571061_36571636_0": {"section_id": 6853, "quality": 0.9210526315789473, "length": 35}}}, "36571061": {"CommentCount": "2", "ViewCount": "340", "PostTypeId": "1", "LastEditorUserId": "2625561", "CreationDate": "2016-04-12T10:50:04.760", "LastActivityDate": "2016-04-12T11:14:33.300", "Title": "Linker can't find a namespace's functions", "AcceptedAnswerId": "36571638", "LastEditDate": "2016-04-12T11:08:42.110", "Id": "36571061", "Score": "0", "Body": "<p>See code below. There's something wrong with it, because the linker is complaining it can't find the <code>Memory</code>'s functions, but I can't figure out why.</p>\n<p><strong>memory.h</strong></p>\n<pre><code>#pragma once\n#include \"includes.h\" //it just includes other strandard headers.\n\nclass MemoryUnit\n{\npublic:\n    MemoryUnit() {}\n    virtual int getValue() = 0;\n    virtual int getSize() = 0;\n    virtual void setValue(int) = 0;\n    virtual ~MemoryUnit() {};\n};\nclass Byte : public MemoryUnit\n{\n    int value;\npublic:\n    static int size;\n    Byte(int byte) :value(byte) {};\n    int getSize() { return size; }\n    int getValue() { return value; };\n    void setValue(int byte) { value = byte; }\n    ~Byte() {};\n};\nnamespace Memory\n{\n    extern int size;\n    extern MemoryUnit** map;\n    void checkAddress(int address);\n    int read(int adress);\n    MemoryUnit* getOperation(int address);\n    void write(int adress, MemoryUnit* data);\n    void writeByte(int adress, int data);\n}\n</code></pre>\n<p><strong>memory.cpp</strong></p>\n<pre><code>#include \"includes.h\"\n#include \"memory.h\"\n#include \"simulator.h\" // it contains only externed constants.\n\nnamespace Memory\n{\n    int size = 0;\n    MemoryUnit** map = NULL;\n    inline MemoryUnit* getOperation(int address)\n    {\n        return map[address];\n    }\n    inline void checkAddress(int address)\n    {\n        if (address &lt; 0 || address &gt;= MAX_MEMORY_SIZE)\n            throw std::out_of_range(\"Invalid memory address.\");\n    }\n    inline int read(int address)\n    {\n        checkAddress(address);\n        return map[address]-&gt;getValue();\n    }\n    inline void write(int address, MemoryUnit* data)\n    {\n        checkAddress(address);\n        delete map[address];\n        map[address] = data;\n    }\n    inline void writeByte(int address, int data)\n    {\n        checkAddress(address);\n        map[address]-&gt;setValue(data);\n    }\n}\n</code></pre>\n<p>Everywhere the class/namespace <code>memory.h</code> declares is includes <code>memory.h</code>. Is here anything wrong in the code below?</p>\n<p>Edit:\nI'm using Visual Studio 2015.\nErrors I got when building the project:</p>\n<pre><code>LNK1120 5 unresolved externals  simulator.exe\nLNK2019 unresolved external symbol \"void __cdecl Memory::writeByte(int,int)\" referenced in function \"void __cdecl ALU::setFlags(int)\" alu.obj\nLNK2001 unresolved external symbol \"void __cdecl Memory::writeByte(int,int)\" cu.obj\nLNK2019 unresolved external symbol \"class MemoryUnit * __cdecl Memory::getOperation(int)\" referenced in function \"void __cdecl CU::run(void)\" cu.obj\nLNK2001 unresolved external symbol \"void __cdecl Memory::writeByte(int,int)\" helpers.obj\nLNK2019 unresolved external symbol \"void __cdecl Memory::write(int,class MemoryUnit *)\" referenced in function \"void __cdecl readProgramCommands(void)\" helpers.obj\nLNK2001 unresolved external symbol \"public: virtual int __thiscall MemoryPointer::getValue(void)\" helpers.obj\nLNK2001 unresolved external symbol \"public: virtual int __thiscall IndirectMemoryPointer::getAddress(void)\" helpers.obj\nLNK2001 unresolved external symbol \"void __cdecl Memory::writeByte(int,int)\" main.obj\n</code></pre>\n<p><code>alu.h</code> and <code>alu.cpp</code> for the first error:</p>\n<pre><code>//alu.h\n#pragma once\n#include \"includes.h\"\n#include \"operation.h\"\nnamespace ALU\n{\n    int operation(Operation* op);\n    void setFlags(int result);\n}\n//alu.cpp\n#include \"includes.h\"\n#include \"simulator.h\"\n#include \"alu.h\"\n#include \"memory.h\"\n#include \"operation.h\"\nnamespace ALU\n{\n    int operation(Operation* operation)\n    {\n        // ...\n        setFlags(result);\n        return result;\n    }\n    inline void setFlags(int result)\n    {\n        Memory::writeByte(FLAG_Z, result == 0);\n        // ...\n    }\n}\n</code></pre>\n", "Tags": "<c++><linker><linker-errors><unresolved-external>", "OwnerUserId": "2625561", "AnswerCount": "2"}, "36571638": {"ParentId": "36571061", "CommentCount": "2", "Body": "<p>When you're using inline functions or methods, their definitions should be visible for every source unit that uses them. You defined your inline functions in Memory.cpp, that's why you get 'unresolved' linker error.</p>\n<p>To fix your problem you can:</p>\n<ol>\n<li><p>Remove inline modifier and keep functions definitions in Memory.cpp.</p></li>\n<li><p>Keep inline modifier but move functions definitions to Memory.h.</p></li>\n</ol>\n", "OwnerUserId": "5740031", "PostTypeId": "2", "Id": "36571638", "Score": "1", "CreationDate": "2016-04-12T11:14:33.300", "LastActivityDate": "2016-04-12T11:14:33.300"}});