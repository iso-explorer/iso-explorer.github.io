post_cb({"46178544": {"ParentId": "46164958", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_46164958_46178544_0\"><strong>[basic.life]/8</strong> If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<p id=\"so_46164958_46178544_1\">...</p>\n<p id=\"so_46164958_46178544_2\">(8.4) \u2014 the original object was a most derived object (1.8) of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects).</p>\n</blockquote>\n<p>In your example, a call to <code>kill()</code> itself may be valid (if it so happens that <code>sizeof(Animal)==sizeof(Dead)</code>, which I don't think is guaranteed), but most attempts to use <code>Animal*</code> pointer or <code>Animal&amp;</code> lvalue through which that call was made would trigger undefined behavior by way of accessing the object whose lifetime has ended. Even assuming that the stars align and <code>Animal</code> subobject of <code>Dead</code> perfectly overlays the original location of the original stand-alone <code>Animal</code> object, such a pointer or lvalue is not considered to refer to the former, but to the now-expired latter.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "46178544", "Score": "2", "CreationDate": "2017-09-12T14:04:15.460", "LastActivityDate": "2017-09-12T14:04:15.460"}, "46164958": {"CommentCount": "19", "AcceptedAnswerId": "46178544", "PostTypeId": "1", "LastEditorUserId": "4988044", "CreationDate": "2017-09-11T22:03:09.297", "LastActivityDate": "2017-09-12T14:04:15.460", "LastEditDate": "2017-09-12T04:29:42.737", "ViewCount": "121", "FavoriteCount": "1", "Title": "Is it possible to use placement-new to change the type of a polymorphic object?", "Id": "46164958", "Score": "3", "Body": "<p>Is it possible to use placement-new to change the type of a polymorphic object? if not, what exactly in the standard prohibits it?</p>\n<p>Consider this code:</p>\n<pre><code>#include &lt;new&gt;\n\nstruct Animal {\n    Animal();\n    virtual ~Animal();\n    virtual void breathe();\n    void kill();\n    void *data;\n};\n\nstruct Dead: Animal {\n    void breathe() override;\n};\n\nvoid Animal::kill() {\n    this-&gt;~Animal();\n    new(this) Dead;\n}\n</code></pre>\n<p>Is calling \"kill\" ever legal?</p>\n<p>Update:  Early comments do not address the (il)legality according to the standard of the programming technique shown here of changing the type of an object by explicit call to destructor and applying placement-new for a new object compatible.</p>\n<p>Because there is interest in why would anyone would like to do this, I can mention the use case that led me to the question, although it is not relevant to the question I am asking.</p>\n<p>Imagine you have a polymorphic type hierarchy with several virtual methods.  During the lifetime of the object, things happen that can be modeled in the code as the object changing its type.  There are many perfectly legal ways to program this, for example, keeping the object as a pointer, smart or not, and swapping in a copy of the other type.  But this may be expensive:  One has to clone or move the original object into another one of a different type just to swap the new in.</p>\n<p>In GCC, Clang, and others, changing the type of an object can be as cheap as to simply changing the virtual table pointer, but in portable C++ this is not possible except by constructing in-place an object of a new type.</p>\n<p>In my original use case, the object could not be held as a pointer either.</p>\n<p>I would like to know what the standard says on the subject of reusing memory.</p>\n", "Tags": "<c++><polymorphism><language-lawyer><placement-new>", "OwnerUserId": "4988044", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46164958_46178544_2": {"section_id": 7195, "quality": 1.0, "length": 17}, "so_46164958_46178544_0": {"section_id": 7195, "quality": 0.9772727272727273, "length": 43}}, "n3337": {"so_46164958_46178544_2": {"section_id": 6939, "quality": 1.0, "length": 17}, "so_46164958_46178544_0": {"section_id": 6939, "quality": 0.9772727272727273, "length": 43}}, "n4659": {"so_46164958_46178544_2": {"section_id": 8704, "quality": 1.0, "length": 17}, "so_46164958_46178544_0": {"section_id": 8704, "quality": 0.9772727272727273, "length": 43}}}});