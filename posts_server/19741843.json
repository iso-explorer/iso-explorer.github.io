post_cb({"19741843": {"CommentCount": "9", "AcceptedAnswerId": "19743719", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-11-02T12:20:59.617", "LastActivityDate": "2013-11-02T15:51:16.103", "LastEditDate": "2017-05-23T11:50:06.320", "ViewCount": "178", "FavoriteCount": "0", "Title": "If Derived adds no new members to Base (and is POD), then what kind of pointer casts, and dereferencing, can be safely done?", "Id": "19741843", "Score": "6", "Body": "<p><em>(This is another question about undefined behaviour (UB).  If this code 'works' on some compiler, then that means nothing in the land of UB.  That is understood.  But exactly at what line below do we cross into UB?)</em></p>\n<p><em>(There are a number of very similar questions on SO already, e.g. <a href=\"https://stackoverflow.com/questions/15328297/validity-of-casting-a-base-pointer-to-a-derived-pointer-when-derived-only-adds-m\">(1)</a>  but I'm curious what can be safely done with the pointers before dereferencing them.)</em></p>\n<p>Start off with a very simple Base class.  No <code>virtual</code> methods. No inheritance.  (Maybe this can be extended to anything that's POD?)</p>\n<pre><code>struct Base {\n        int first;\n        double second;\n};\n</code></pre>\n<p>And then a simple extension that adds (non-<code>virtual</code>) methods and doesn't add any members.  No <code>virtual</code> inheritance.</p>\n<pre><code>struct Derived : public Base {\n        int foo() { return first; }\n        int bar() { return second; }\n};\n</code></pre>\n<p>Then, consider the following lines.  If there is some deviation from defined behaviour, I'd be curious to know which lines exactly.  My guess is that we can safely perform much of the calculations on the pointers.  Is it possible that some of these pointer calculations, if not fully defined, at least give us some sort of 'indeterminate/unspecified/implementation-defined' value that isn't entirely useless?</p>\n<pre><code>void foo () {\n    Base b;\n    void * vp = &amp;b;     // (1) Defined behaviour?\n    cout &lt;&lt; vp &lt;&lt; endl; // (2) I hope this isn't a 'trap value'\n    cout &lt;&lt; &amp;b &lt;&lt; endl; // (3a) Prints the same as the last line?\n                        // (3b) It has the 'same value' in some sense?\n    Derived *dp = (Derived*)(vp);\n                        // (4) Maybe this is an 'indeterminate value',\n                        // but not fully UB?\n    cout &lt;&lt; dp &lt;&lt; endl; // (5)  Defined behaviour also?  Should print the same value as &amp;b\n</code></pre>\n<p>Edit: If the program ended here, would it be UB?  Note that, at this stage, I have <em>not</em> attempted to do anything with <code>dp</code>, other than print the pointer itself to the output.  If simply casting is UB, then I guess the question ends here.</p>\n<pre><code>                        // I hope the dp pointer still has a value,\n                        // even if we can't dereference it\n    if(dp == &amp;b) {      // (6) True?\n            cout &lt;&lt; \"They have the same value. (Whatever that means!)\" &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; &amp;(b.second) &lt;&lt; endl; (7) this is definitely OK\n    cout &lt;&lt; &amp;(dp-&gt;second) &lt;&lt; endl; // (8)  Just taking the address. Is this OK?\n    if( &amp;(dp-&gt;second) == &amp;(b.second) ) {      // (9) True?\n            cout &lt;&lt; \"The members are stored in the same place?\" &lt;&lt; endl;\n    }\n}\n</code></pre>\n<p>I'm slightly nervous about <strong>(4)</strong> above.  But I assume that it's always safe to cast to and from void pointers.  Maybe the <em>value</em> of such a pointer can be discussed.  But, is it defined to do the cast, and to print the pointer to <code>cout</code>?</p>\n<p><strong>(6)</strong> is important also.  Will this evaluate to true?</p>\n<p>In <strong>(8)</strong>, we have the first time this pointer is being dereferenced (correct term?).  But note that this line doesn't read from <code>dp-&gt;second</code>.  It's still just an lvalue and we take its address.  This calculation of the address is, I assume, defined by simple pointer arithmetic rules that we have from the C language?</p>\n<p>If all of the above is OK, maybe we can prove that <code>static_cast&lt;Derived&amp;&gt;(b)</code> is OK, and will lead to a perfectly usable object.</p>\n", "Tags": "<c++><language-lawyer><undefined-behavior>", "OwnerUserId": "146041", "AnswerCount": "2"}, "19743607": {"ParentId": "19741843", "CommentCount": "0", "CreationDate": "2013-11-02T15:40:28.553", "OwnerUserId": "146041", "PostTypeId": "2", "Id": "19743607", "Score": "1", "Body": "<p>(Attempting to answer my own question, from the point of view of strict aliasing.  A good optimizer is entitled to do some unexpected things, which effectively give us UB.  But I'm not an expert, by any means!)</p>\n<p>In this function,</p>\n<pre><code> void foo(Base &amp;b_ref) {\n     Base b;\n     ....\n }\n</code></pre>\n<p>it is obvious that <code>b</code> and <code>b_ref</code> can't refer to each other.  This particular example doesn't involve analysis of compatible types, it's just the simple observation that a new-constructed local variable is guaranteed to be the only reference to itself.  This allows the optimizer to do some tricks.  It can store <code>b</code> in a register and it can then execute code, such as <code>b_ref.modify()</code>, that modifies <code>b_ref</code>, safe in the knowledge that <code>b</code> is not affected.  (Perhaps only really smart optimizers will notice this, but it is allowed.)</p>\n<p>Next, consider this,</p>\n<pre><code>void foo(Base &amp;b_ref, Derived&amp;d_ref);\n</code></pre>\n<p>Within the implementation of this function, the optimize <em>cannot</em> assume that b_ref and d_ref refer to different objects.  Therefore, if the code calls <code>d_ref.modify()</code>, then the next time the code is accessing <code>b_ref</code> it must look again at the memory that stores the <code>b_ref</code> object.  If there is a copy of the <code>b_ref</code> data in the CPU registers, then it is possibly out-of-date data.</p>\n<p>But if the types having nothing to do with each other, then such optimizations would be allowed. e.g.</p>\n<pre><code>struct Base1 { int i; };  struct Base2 { int i; };\nvoid foo(Base1 &amp; b1_ref, Base2 &amp;b2_ref);\n</code></pre>\n<p>These can be assumed to point to different objects and therefore the compiler is allowed to make certain assumptions.  <code>b2_ref.i=5;</code> cannot change <code>b1_ref.i</code>, therefore the compiler can make some assumptions.  (Actually, there might be other threads, or even POSIX signals, making changes behind the scenes, and I must admit I'm not to clear on threads!)</p>\n<p>So, there are assumptions the compiler is allowed to make for optimization.  Consider this:</p>\n<pre><code>Base b; // a global variable\nvoid foo() {\n    Derived &amp;d_ref = some_function();\n    int x1 = b.i;\n    d_ref.i = 5;\n    int x2 = b.i;\n}\n</code></pre>\n<p>With this, the optimizer knows the dynamic type of <code>b</code>, it's a <code>Base</code>.  The two consecutive calls to <code>b.i</code> should give the same value (excepting other threads or whatever), and therefore the compiler is allowed to optimize the latter to <code>int x2 = x1</code>.  If <code>some_function</code> returned a <code>Base&amp;</code>, i.e. <code>Base &amp;d_ref = some_function();</code> then the compiler would not be allowed to make such an optimization.</p>\n<p>So, given an object where the compiler knows its dynamic type is <code>Base</code>, and a reference to a derived type <code>Derived&amp;</code>, the compiler is entitled to assume they refer to different objects.  The compiler is allowed to rewrite the code a little, making the assumption that the two objects don't refer to each other.  This can, at the very least, lead to unpredictable behaviour.  And anything you do that violates assumptions the optimizer is allowed to make is undefined behaviour.</p>\n", "LastActivityDate": "2013-11-02T15:40:28.553"}, "bq_ids": {"n4140": {"so_19741843_19743719_0": {"section_id": 6037, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_19741843_19743719_0": {"section_id": 5805, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_19741843_19743719_0": {"section_id": 7536, "quality": 0.8421052631578947, "length": 16}}}, "19743719": {"ParentId": "19741843", "CommentCount": "2", "CreationDate": "2013-11-02T15:51:16.103", "OwnerUserId": "214671", "PostTypeId": "2", "Id": "19743719", "Score": "3", "Body": "<ol>\n<li>Casting from a data pointer to <code>void *</code> is always guaranteed to work, and the pointer is guaranteed to survive the roundtrip <code>Base *</code> -&gt; <code>void *</code> -&gt; <code>Base *</code> (C++11 \u00a75.2.9 \u00b613);</li>\n<li><code>vp</code> is a valid pointer, so there shouldn't be any problem.</li>\n<li><p>a. albeit printing pointers is implementation-defined<sup>1</sup>, the printed values should be the same: in facts <code>operator&lt;&lt;</code> by default is overloaded only for <code>const void *</code>, so when you write <code>cout&lt;&lt;&amp;b</code> you are converting to <code>const void *</code> anyway, i.e. what <code>operator&lt;&lt;</code> sees is in both cases <code>&amp;b</code> casted to <code>const void *</code>.</p>\n<p>b. yes, if we take the only sensible definition of \"has the same value\" - i.e. it compares equal with the <code>==</code> operator; in facts, if you compare <code>vp</code> and <code>&amp;b</code> with <code>==</code>, the result is <code>true</code>, both if you convert <code>vp</code> to <code>Base *</code> (due to what we said in 1), and if you convert <code>&amp;b</code> to <code>void *</code>.</p>\n<p>Both these conclusions follow from \u00a74.10 \u00b62, where it's specified that any pointer can be converted to <code>void *</code> (modulo the usual <em>cv</em>-qualified stuff), and the result \u00abpoints to the start of the storage location where the object [...] resides\u00bb<sup>1</sup></p></li>\n<li><p>This is tricky; that C-style cast is equivalent to a <code>static_cast</code>, which will happily allow casting a \u00ab\"pointer to <em>cv1</em> <code>B</code>[...] to [...] \"pointer to *cv2 <code>D</code>\", where <code>D</code> is a class derived from <code>B</code>\u00bb (\u00a75.2.9, \u00b611; there are some additional constraints, but they are satisfied here); <em>but</em>:</p>\n<blockquote>\n<p id=\"so_19741843_19743719_0\">If the prvalue of type \u201cpointer to <em>cv1</em> <code>B</code>\u201d points to a <code>B</code> that is actually a subobject of an object of type <code>D</code>, the resulting pointer points to the enclosing object of type <code>D</code>. <strong>Otherwise, the result of the cast is undefined.</strong></p>\n</blockquote>\n<p>(emphasis added)</p>\n<p>So, here your cast is allowed, but the result is undefined...</p></li>\n<li><p>... which leads us to printing its value; since the result of the cast is undefined, you may get anything. Since pointers are probably allowed to have trap representations (at least in C99, I could find only sparse references to \"traps\" in the C++11 standard, but I think that probably this behavior should already be inherited from C89) you may even get a crash just by <em>reading</em> this pointer to print it via <code>operator&lt;&lt;</code>.</p></li>\n</ol>\n<p>If follows that also 6, 8 and 9 aren't meaningful, because you are using an undefined result.</p>\n<p>Also, even if the cast was valid, strict aliasing (\u00a73.10, \u00b610) would block you to do anything meaningful with the pointed objects, since aliasing a <code>Base</code> object via a <code>Derived</code> pointer is only allowed when the dynamic type of the <code>Base</code> object is actually <code>Derived</code>; anything that deviates from the exceptions specified at \u00a73.10 \u00b610 results in undefined behavior.</p>\n<hr>\n<p><em>Notes:</em></p>\n<ol>\n<li><p><code>operator&gt;&gt;</code> delegates to <code>num_put</code> which conceptually delegates to <code>printf</code> with <code>%p</code>, whose description boils down to \"implementation defined\".</p></li>\n<li><p>This rules out my fear that an evil implementation could in theory return different but equivalent values when casting to <code>void *</code>.</p></li>\n</ol>\n</hr>", "LastActivityDate": "2013-11-02T15:51:16.103"}});