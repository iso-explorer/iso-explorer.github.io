post_cb({"32608695": {"ParentId": "32608458", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is not undefined behavior, although <code>foo</code> is uninitialzed you are using it a way that is allowed by the standard. After space is allocated for an object but before it is fully initialized you are allowed to use it limited ways. Both binding a reference to that variable and taking its address is allowed.</p>\n<p>This is covered by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#363\" rel=\"nofollow noreferrer\">defect report 363: Initialization of class from self </a> which says:</p>\n<blockquote>\n<p id=\"so_32608458_32608695_0\">And if so, what is the semantics of the self-initialization of UDT?\n  For example</p>\n<pre><code> #include &lt;stdio.h&gt;\n\n struct A {\n        A()           { printf(\"A::A() %p\\n\",            this);     }\n        A(const A&amp; a) { printf(\"A::A(const A&amp;) %p %p\\n\", this, &amp;a); }\n        ~A()          { printf(\"A::~A() %p\\n\",           this);     }\n };\n\n int main()\n {\n  A a=a;\n }\n</code></pre>\n<p id=\"so_32608458_32608695_1\">can be compiled and prints:</p>\n<pre><code>A::A(const A&amp;) 0253FDD8 0253FDD8\nA::~A() 0253FDD8\n</code></pre>\n</blockquote>\n<p>and the resolution was:</p>\n<blockquote>\n<p id=\"so_32608458_32608695_2\">3.8 [basic.life] paragraph 6 indicates that the references here are valid. It's permitted to take the address of a class object before it is fully initialized, and it's permitted to pass it as an argument to a reference parameter as long as the reference can bind directly. Except for the failure to cast the pointers to void * for the %p in the printfs, these examples are standard-conforming.</p>\n</blockquote>\n<p>The full quote of section <code>3.8</code> <em>[basic.life]</em> from the draft C++14 standard is as follows:</p>\n<blockquote>\n<p id=\"so_32608458_32608695_3\">Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any glvalue that refers to the\n  original object may be used but only in limited ways. For an object\n  under construction or destruction, see 12.7. Otherwise, such a glvalue\n  refers to allocated storage (3.7.4.2), and using the properties of the\n  glvalue that do not depend on its value is well-defined. The program\n  has undefined behavior if:</p>\n<ul>\n<li><p id=\"so_32608458_32608695_4\">an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</p></li>\n<li><p id=\"so_32608458_32608695_5\">the glvalue is used to access a non-static data member or call a non-static member function of the\n  object, or</p></li>\n<li><p id=\"so_32608458_32608695_6\">the glvalue is bound to a reference to a virtual base class (8.5.3), or</p></li>\n<li><p id=\"so_32608458_32608695_7\">the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.</p></li>\n</ul>\n</blockquote>\n<p>We are not doing anything with <code>foo</code> that falls under undefined behavior as defined by the bullets above. </p>\n<p>If we try this with clang we see an ominous warning (<em><a href=\"http://melpon.org/wandbox/permlink/r91TJdb8tVqSnuPG\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<blockquote>\n<p id=\"so_32608458_32608695_8\">warning: variable 'foo' is uninitialized when used within its own initialization [-Wuninitialized]</p>\n</blockquote>\n<p>It is a valid warning since <a href=\"https://stackoverflow.com/q/23415661/1708801\">producing and indeterminate value from an uninitialized automatic variable is undefined behavior</a> but in this case you are just binding a reference and taking the address of the variable within the constructor which does not produce an indeterminate value and is valid. On the other hand the <a href=\"https://stackoverflow.com/q/14935722/1708801\">following self-initialization example from the draft C++11 standard</a>:</p>\n<pre><code>int x = x ;\n</code></pre>\n<p>does invoke undefined behavior.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#453\" rel=\"nofollow noreferrer\">Active issue 453: References may only bind to \u201cvalid\u201d objects </a> also seems relevant but is still open. The initial proposed language is consistent with defect report 363.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:01.790", "Id": "32608695", "Score": "62", "CreationDate": "2015-09-16T12:30:51.383", "LastActivityDate": "2015-11-30T04:58:58.777"}, "32608458": {"CommentCount": "17", "ViewCount": "5073", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-09-16T12:20:56.797", "LastActivityDate": "2015-11-30T04:58:58.777", "Title": "Is passing a C++ object into its own constructor legal?", "FavoriteCount": "15", "LastEditDate": "2015-09-16T17:38:22.533", "Id": "32608458", "Score": "104", "Body": "<p>I am surprised to accidentally discover that the following works:</p>\n<pre><code>#include &lt;iostream&gt;            \nint main(int argc, char** argv)\n{\n  struct Foo {\n    Foo(Foo&amp; bar) {\n      std::cout &lt;&lt; &amp;bar &lt;&lt; std::endl;\n    }\n  };\n  Foo foo(foo); // I can't believe this works...\n  std::cout &lt;&lt; &amp;foo &lt;&lt; std::endl; // but it does...\n}\n</code></pre>\n<p>I am passing the address of the constructed object into its own constructor. This looks like a circular definition at the source level. Do the standards really allow you to pass an object into a function before the object is even constructed or is this undefined behavior? </p>\n<p>I suppose it's not that odd given that all class member functions already have a pointer to the data for their class instance as an implicit parameter. And the layout of the data members is fixed at compile time.</p>\n<p>Note, I'm NOT asking if this is useful or a good idea; I'm just tinkering around to learn more about classes.</p>\n", "Tags": "<c++><class><constructor><language-lawyer><undefined-behavior>", "OwnerUserId": "139802", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32608458_32608695_5": {"section_id": 7194, "quality": 1.0, "length": 10}, "so_32608458_32608695_4": {"section_id": 6185, "quality": 1.0, "length": 5}, "so_32608458_32608695_3": {"section_id": 7194, "quality": 0.9272727272727272, "length": 51}, "so_32608458_32608695_7": {"section_id": 7194, "quality": 0.8333333333333334, "length": 5}, "so_32608458_32608695_6": {"section_id": 7194, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_32608458_32608695_5": {"section_id": 6938, "quality": 1.0, "length": 10}, "so_32608458_32608695_4": {"section_id": 5946, "quality": 1.0, "length": 5}, "so_32608458_32608695_3": {"section_id": 6938, "quality": 0.9272727272727272, "length": 51}, "so_32608458_32608695_7": {"section_id": 6938, "quality": 0.8333333333333334, "length": 5}, "so_32608458_32608695_6": {"section_id": 359, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_32608458_32608695_3": {"section_id": 8703, "quality": 0.9272727272727272, "length": 51}, "so_32608458_32608695_4": {"section_id": 7687, "quality": 1.0, "length": 5}, "so_32608458_32608695_7": {"section_id": 8703, "quality": 0.8333333333333334, "length": 5}, "so_32608458_32608695_5": {"section_id": 8702, "quality": 0.9, "length": 9}, "so_32608458_32608695_6": {"section_id": 8703, "quality": 0.8571428571428571, "length": 6}}}, "32609143": {"ParentId": "32608458", "CommentCount": "2", "Body": "<p>The constructor is called at a point where memory is allocated for the object-to-be. At that point, no object exists at that location (or possibly an object with a trivial destructor). Furthermore, the <code>this</code> pointer refers to that memory and the memory is properly aligned.</p>\n<p>Since it's allocated and aligned memory, we may refer to it using lvalue expressions of <code>Foo</code> type (i.e. <code>Foo&amp;</code>). What we may <em>not</em> yet do is have an lvalue-to-rvalue conversion. That's only allowed after the constructor body is entered.</p>\n<p>In this case, the code just tries to print <code>&amp;bar</code> inside the constructor body. It would even be legal to print <code>bar.member</code> here. Since the constructor body has been entered, a <code>Foo</code> object exists and its members may be read.</p>\n<p>This leaves us with one small detail, and that's name lookup. In <code>Foo foo(foo)</code>, the first <code>foo</code> introduces the name in scope and the second <code>foo</code> therefore refers back to the just-declared name. That's why <code>int x = x</code> is invalid, but <code>int x = sizeof(x)</code> is valid.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "32609143", "Score": "15", "CreationDate": "2015-09-16T12:51:39.220", "LastActivityDate": "2015-09-16T12:51:39.220"}});