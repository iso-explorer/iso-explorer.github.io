post_cb({"33670238": {"CommentCount": "0", "ViewCount": "204", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2015-11-12T11:18:33.443", "LastActivityDate": "2015-11-12T22:39:15.423", "Title": "Using user-defined literals in expressions sometimes requires whitespace", "LastEditDate": "2015-11-12T22:39:15.423", "Id": "33670238", "Score": "8", "Body": "<p>The following code compiles in both GCC and Clang:</p>\n<pre><code>long double operator\"\"_a(long double);     \nauto x = 0e1_a+0; // OK \n</code></pre>\n<p>But not this (replacing <code>_a</code> with <code>_e</code>):</p>\n<pre><code>long double operator\"\"_e(long double);\nauto y = 0e1_e+0; // Error: unable to find numeric literal operator 'operator\"\"_e+0'\n</code></pre>\n<p>OTOH, this code compiles:</p>\n<pre><code>auto z = 0e1_e +0; // OK\n</code></pre>\n<p>What's going on?</p>\n<p>(This question is inspired by <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68288\">this GCC bug report</a>.)</p>\n", "Tags": "<c++><c++11><user-defined-literals>", "OwnerUserId": "2756719", "AnswerCount": "1"}, "33670239": {"ParentId": "33670238", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Maximal munch strikes again.</p>\n<p>[lex.pptoken]/p3:</p>\n<blockquote>\n<p id=\"so_33670238_33670239_0\">If the input stream has been parsed into preprocessing tokens up to a\n  given character:</p>\n<ul>\n<li>[two exceptions not relevant here]</li>\n<li>Otherwise, the next preprocessing token is the longest sequence of characters that could constitute a preprocessing token, even if that\n  would cause further lexical analysis to fail, except that a\n  <em>header-name</em> (2.8) is only formed within a <code>#include</code> directive (16.2).</li>\n</ul>\n</blockquote>\n<p>The problem is that <code>0e1_e+0</code>, unlike <code>0e1_a+0</code>, is a valid preprocessing number ([lex.ppnumber]):</p>\n<pre><code>pp-number:\n    digit\n    . digit\n    pp-number digit\n    pp-number identifier-nondigit\n    pp-number \u2019 digit\n    pp-number \u2019 nondigit\n    pp-number e sign\n    pp-number E sign\n    pp-number .\n</code></pre>\n<p>As a result, <code>0e1_e+0</code> is parsed as a single <em>pp-number</em> preprocessing token, and then explodes later because it cannot be converted to a valid token (for obvious reasons).</p>\n<p><code>0e1_a+0</code>, on the other hand, is parsed as three tokens, <code>0e1_a</code>, <code>+</code>, and <code>0</code>, and all is well.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-11-12T20:27:38.140", "Id": "33670239", "Score": "12", "CreationDate": "2015-11-12T11:18:33.443", "LastActivityDate": "2015-11-12T20:27:38.140"}, "bq_ids": {"n4140": {"so_33670238_33670239_0": {"section_id": 5322, "quality": 1.0, "length": 9}}, "n3337": {"so_33670238_33670239_0": {"section_id": 5119, "quality": 1.0, "length": 9}}, "n4659": {"so_33670238_33670239_0": {"section_id": 6743, "quality": 1.0, "length": 9}}}});