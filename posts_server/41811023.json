post_cb({"bq_ids": {"n4140": {"so_41811023_41811023_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 3336}, "so_41811023_41811023_2": {"length": 8, "quality": 1.0, "section_id": 3336}, "so_41811023_41811023_1": {"length": 8, "quality": 1.0, "section_id": 3334}}, "n3337": {"so_41811023_41811023_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 3206}, "so_41811023_41811023_2": {"length": 5, "quality": 0.625, "section_id": 371}, "so_41811023_41811023_1": {"length": 8, "quality": 1.0, "section_id": 3204}}, "n4659": {"so_41811023_41811023_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 7672}, "so_41811023_41811023_2": {"length": 8, "quality": 1.0, "section_id": 4103}, "so_41811023_41811023_1": {"length": 8, "quality": 1.0, "section_id": 4101}}}, "41811023": {"ViewCount": "68", "Body": "<p>While reading about the details of exception handling in the standard, I noticed that it doesn't ever seem to actually specify that the operand to a throw expression will provide the value for the thrown exception object.</p>\n<p>The [expr.throw] section describing the semantics of a throw expression says only that:</p>\n<blockquote>\n<p id=\"so_41811023_41811023_0\">Evaluating a throw-expression with an operand throws <strong>an</strong> exception (15.1); the <strong>type</strong> of the exception object is determined by removing any top-level cv-qualifiers from the static type of the operand and adjusting the type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively.</p>\n</blockquote>\n<p>So if someone says <code>throw 5</code>, the type of the exception object must be <code>int</code>. This does not seem to actually say that the value of the exception object must be <code>5</code> rather than, say, <code>7</code> or any other arbitrary value of type <code>int</code>. Section 15.1 [except.throw] continues to be just as nebulous. It says things like:</p>\n<blockquote>\n<p id=\"so_41811023_41811023_1\">An object is passed and <strong>the type of that object</strong> determines which handlers can catch it.</p>\n</blockquote>\n<p>Once again, the the type of the operand matters, but not the value of the operand.</p>\n<blockquote>\n<p id=\"so_41811023_41811023_2\">Throwing an exception copy-initializes a temporary object, called the exception object.</p>\n</blockquote>\n<p>A temporary object is copy-initialized, but no mention is made of this temporary object having any particular value. The compiler could copy-initialize the temporary exception object from a prvalue <code>int</code> with value <code>7</code> if it wanted to, and it would still satisfy this clause because it did copy-initialize a temporary object. <em>The operand to the throw expression is never mentioned.</em></p>\n<hr>\n<p>So, if I have this program:</p>\n<pre><code>#include &lt;cassert&gt;\nvoid f() {\n    try {\n        throw 5;\n    } catch (int x) {\n        assert(x == 5);\n    }\n}\n</code></pre>\n<p>What specific wording in the C++ standard guarantees that this assertion will never fail? As far as I can tell, the standard only guarantees that the exception object will have type <code>int</code> but not that it will have any particular value, i.e. the assertion could fail if the temporary object were initialized with a value of <code>7</code>. There doesn't seem to be any mention of the object/value/result of the operand to the throw expression being used to create the exception object.</p>\n</hr>", "Title": "Does the C++ standard actually guarantee that the operand to a throw expression provides the thrown value?", "CreationDate": "2017-01-23T16:27:37.010", "LastActivityDate": "2017-01-23T16:27:37.010", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "Id": "41811023", "Score": "2", "OwnerUserId": "839932", "Tags": "<c++><exception><language-lawyer><standards><throw>", "AnswerCount": "0"}});