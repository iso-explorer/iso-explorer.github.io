post_cb({"33600274": {"Id": "33600274", "PostTypeId": "2", "Body": "<p>Yes, this is covered by the standard and it is unspecified behavior. This particular case is covered in a recent C++ standards proposal: <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4228.pdf\" rel=\"nofollow noreferrer\">N4228: Refining Expression Evaluation Order for Idiomatic C++</a> which seeks to refine the order of evaluation rules to make it well specified for certain cases.</p>\n<p>It describes this problem as follows:</p>\n<blockquote>\n<p id=\"so_33598938_33600274_0\">Expression evaluation order is a recurring discussion topic in the C++\n  community.  In a nutshell, given an  expression  such  as  <strong>f(a, b, \n  c)</strong>, the  order  in  which  the  sub-expressions  <strong>f,  a,  b,  c</strong> are  evaluated  is  left  unspecified by  the  standard. If  any  two  of  these  sub-expressions  happen  to  modify  the  same  object  without  intervening  sequence  points,  the  behavior  of  the  program  is  undefined. For  instance,  the  expression  <strong>f(i++,  i)</strong>  where  i is  an \n  integer variable  leads  to  undefined  behavior ,  as  does  <strong>v[i] \n  =  i++</strong>. Even  when the behavior is not undefined, the result of  evaluating an expression  can still be anybody\u2019s guess.   Consider\n  the following program fragment:</p>\n<pre><code>#include &lt;map&gt;\n\nint main() {\n  std::map&lt;int, int&gt;  m;\n  m[0] = m.size(); // #1\n}\n</code></pre>\n<p id=\"so_33598938_33600274_1\">What should the map object  m look like after evaluation of the\n  statement marked #1? { {0, 0 } } or  {{0, 1 } } ?</p>\n</blockquote>\n<p>We know that unless specified the evaluations of sub-expressions are unsequenced, this is from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft C++11 standard</a> section <code>1.9</code> <em>Program execution</em> which says:</p>\n<blockquote>\n<p id=\"so_33598938_33600274_2\">Except where noted, evaluations of operands of individual operators\n  and of subexpressions of individual expressions are unsequenced.[...]</p>\n</blockquote>\n<p>and all the section <code>5.17</code> Assignment and compound assignment operators [expr.ass] says is:</p>\n<blockquote>\n<p id=\"so_33598938_33600274_3\">[...]In all cases, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression.[...]</p>\n</blockquote>\n<p>So this section does not nail down the order of evaluation but we know this is not undefined behavior since both <code>operator []</code> and <code>size()</code> are function calls and section <code>1.9</code> tells us(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_33598938_33600274_4\">[...]When calling a function (whether or not the function is inline), every value computation and side effect\n  associated with any argument expression, or with the postfix expression designating the called function, is\n  sequenced before execution of every expression or statement in the body of the called function. [ Note: Value\n  computations and side effects associated with different argument expressions are unsequenced. \u2014end note ]\n  <strong>Every evaluation in the calling function (including other function calls) that is not otherwise specifically\n  sequenced before or after the execution of the body of the called function is indeterminately sequenced with\n  respect to the execution of the called function</strong>.9[...]</p>\n</blockquote>\n<p>Note, I cover the second interesting example from the <code>N4228</code> proposal in this <a href=\"https://stackoverflow.com/q/27158812/1708801\">question here</a>.</p>\n<p><b>Update</b></p>\n<p>It seems like a revised version of <code>N4228</code> was <a href=\"https://botondballo.wordpress.com/2015/11/09/trip-report-c-standards-meeting-in-kona-october-2015/\" rel=\"nofollow noreferrer\">accepted by the Evolution Working Group at the last WG21 meeting</a> but the paper(<a href=\"http://wg21.link/p0145r0\" rel=\"nofollow noreferrer\">P0145R0</a>) is not yet available. So this could possibly no longer be unspecified in C++17.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-24T13:31:50.123", "Score": "12", "CreationDate": "2015-11-08T23:26:42.637", "ParentId": "33598938", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:25:54.580"}, "34032664": {"Id": "34032664", "PostTypeId": "2", "Body": "<p>Let's take a look at what your code breaks down to:</p>\n<pre><code>mp.operator[](10).operator=(mp.size());\n</code></pre>\n<p>which pretty much tells the story that in the first part an entry to 10 is created and in the second part the size of the container is assigned to the integer reference in position of 10. </p>\n<p>But now you get into the order of evaluation problem which is unspecified. Here is a much simpler <a href=\"https://stackoverflow.com/questions/8900404/argument-evaluation-order-between-chained-static-function-calls\">example</a> . </p>\n<p>When should <code>map::size()</code> get called, before or after <code>map::operator(int const &amp;);</code> ?</p>\n<p>Nobody really knows.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-02T00:08:39.577", "Score": "1", "CreationDate": "2015-12-02T00:08:39.577", "ParentId": "33598938", "CommentCount": "0", "OwnerUserId": "4345926", "LastEditDate": "2017-05-23T12:34:11.653"}, "bq_ids": {"n4140": {"so_33598938_33600274_4": {"length": 59, "quality": 0.9365079365079365, "section_id": 5811}, "so_33598938_33600274_2": {"length": 11, "quality": 1.0, "section_id": 5811}, "so_33598938_33599142_1": {"length": 42, "quality": 0.9545454545454546, "section_id": 6173}, "so_33598938_33599142_3": {"length": 7, "quality": 1.0, "section_id": 5768}, "so_33598938_33600274_3": {"length": 15, "quality": 1.0, "section_id": 6173}}, "n3337": {"so_33598938_33600274_4": {"length": 59, "quality": 0.9365079365079365, "section_id": 5584}, "so_33598938_33599142_3": {"length": 7, "quality": 1.0, "section_id": 5541}, "so_33598938_33599142_1": {"length": 42, "quality": 0.9545454545454546, "section_id": 5934}, "so_33598938_33600274_2": {"length": 11, "quality": 1.0, "section_id": 5584}, "so_33598938_33600274_3": {"length": 15, "quality": 1.0, "section_id": 5934}}, "n4659": {"so_33598938_33600274_4": {"length": 35, "quality": 0.5555555555555556, "section_id": 7273}, "so_33598938_33599142_3": {"length": 7, "quality": 1.0, "section_id": 7225}, "so_33598938_33599142_1": {"length": 42, "quality": 0.9545454545454546, "section_id": 7675}, "so_33598938_33600274_2": {"length": 11, "quality": 1.0, "section_id": 7272}, "so_33598938_33600274_3": {"length": 15, "quality": 1.0, "section_id": 7675}}}, "33599142": {"Id": "33599142", "PostTypeId": "2", "Body": "<p>From the C++11 standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33598938_33599142_0\"><strong>5.17 Assignment and compound assignment operators</strong></p>\n<p id=\"so_33598938_33599142_1\">1 The assignment operator (=) and the compound assignment operators all group right-to-left. All require a modifiable lvalue as their left operand and return an lvalue referring to the left operand. The result in all cases is a bit-field if the left operand is a bit-field. In all cases, <strong>the assignment is sequenced after the value computation of the right and left operands</strong>, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>Whether the left operand is evaluated first or the right operand is evaluated first is not specified by the language. A compiler is free to choose to evaluate either operand first. Since the final result of your code depends on the order of evaluation of the operands, I would say it is unspecified behavior rather than undefined behavior.</p>\n<blockquote>\n<p id=\"so_33598938_33599142_2\"><strong>1.3.25 unspecified behavior</strong></p>\n<p id=\"so_33598938_33599142_3\">behavior, for a well-formed program construct and correct data, that depends on the implementation</p>\n</blockquote>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-11-08T21:26:40.823", "Score": "7", "CreationDate": "2015-11-08T21:18:25.083", "ParentId": "33598938", "CommentCount": "0", "OwnerUserId": "434551", "LastEditDate": "2015-11-08T21:26:40.823"}, "33598938": {"ViewCount": "1035", "Body": "<pre><code>map&lt;int, int&gt; mp;\nprintf(\"%d \", mp.size());\nmp[10]=mp.size();\nprintf(\"%d\\n\", mp[10]);\n</code></pre>\n<p>This code yields an answer that is not very intuitive:</p>\n<blockquote>\n<p id=\"so_33598938_33598938_0\">0 1</p>\n</blockquote>\n<p>I understand why it happens - the left side of the assignment returns reference to <code>mp[10]</code>'s underlying value and at the same time creates aforementioned value, and only then is the right side evaluated, using the newly computed <code>size()</code> of the map.</p>\n<p>Is this behaviour stated anywhere in C++ standard? Or is the order of evaluation undefined?</p>\n<p>Result was obtained using g++ 5.2.1.</p>\n", "AcceptedAnswerId": "33600274", "Title": "Order of evaluation of assignment statement in C++", "CreationDate": "2015-11-08T20:54:19.740", "Id": "33598938", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-09T04:43:27.853", "LastEditorUserId": "1708801", "LastActivityDate": "2017-04-24T13:31:50.123", "Score": "13", "OwnerUserId": "2805344", "Tags": "<c++><language-lawyer><order-of-evaluation>", "AnswerCount": "4"}, "33599002": {"Id": "33599002", "PostTypeId": "2", "Body": "<p>I'm sure that the standard does not specify for an expression <code>x = y;</code> which order <code>x</code> or <code>y</code> is evaluated in the C++ standard (this is the reason why you can't do <code>*p++ = *p++</code> for example, because <code>p++</code> is not done in a defined order).</p>\n<p>In other words, to guarantee order <code>x = y;</code> in a defined order, you need to do break it up into two sequence points.</p>\n<pre><code> T tmp = y;\n x = tmp;\n</code></pre>\n<p>(Of course, in this particular case, one might presume the compiler prefers to do <code>operator[]</code> before <code>size()</code> because it can then store the value directly into the result of <code>operator[]</code> instead of keeping it in a temporary place, to store it later after <code>operator[]</code> has been evaluated - but I'm pretty sure the compiler doesn't NEED to do it in that order)</p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2015-11-08T21:42:27.493", "Score": "3", "CreationDate": "2015-11-08T21:02:00.527", "ParentId": "33598938", "CommentCount": "2", "OwnerUserId": "1919155", "LastEditDate": "2015-11-08T21:42:27.493"}});