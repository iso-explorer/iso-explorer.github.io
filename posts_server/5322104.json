post_cb({"5322217": {"ParentId": "5322104", "CommentCount": "2", "CreationDate": "2011-03-16T07:30:23.607", "OwnerUserId": "634489", "PostTypeId": "2", "Id": "5322217", "Score": "0", "Body": "<p>This code is not OK, in case list is empty you are in trouble.  </p>\n<p>So check for that, if list is not empty the code is very fine.</p>\n", "LastActivityDate": "2011-03-16T07:30:23.607"}, "5322104": {"CommentCount": "6", "AcceptedAnswerId": "5322234", "PostTypeId": "1", "LastEditorUserId": "662015", "CreationDate": "2011-03-16T07:15:53.423", "LastActivityDate": "2011-03-16T21:52:01.683", "LastEditDate": "2011-03-16T07:21:04.823", "ViewCount": "13154", "FavoriteCount": "9", "Title": "how portable is end iterator decrement?", "Id": "5322104", "Score": "39", "Body": "<p>Just encountered decrement of <code>end()</code> iterator in my company source codes and it looks strange for me. As far as I remember this was working on some platforms, but not for the others. Maybe I'm wrong, however I couldn't find anything useful in standard about that. Standard only says that <code>end()</code> returns an iterator which is the past-the-end value, but is it guaranteed to be decrementable? How does code like that match the standard?</p>\n<pre><code>std::list&lt;int&gt;::iterator it = --l.end();\n</code></pre>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><stl><iterator><portability>", "OwnerUserId": "662015", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5322104_5322234_3": {"section_id": 6217, "quality": 1.0, "length": 19}, "so_5322104_5322234_1": {"section_id": 735, "quality": 0.8846153846153846, "length": 23}}, "n3337": {"so_5322104_5322234_3": {"section_id": 5977, "quality": 1.0, "length": 19}, "so_5322104_5322234_1": {"section_id": 724, "quality": 0.8846153846153846, "length": 23}}, "n4659": {"so_5322104_5322234_3": {"section_id": 7720, "quality": 1.0, "length": 19}, "so_5322104_5322234_1": {"section_id": 764, "quality": 0.8846153846153846, "length": 23}}}, "5322234": {"ParentId": "5322104", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2011-03-16T07:32:16.067", "Score": "44", "LastEditorUserId": "308661", "LastEditDate": "2011-03-16T21:52:01.683", "Id": "5322234", "OwnerUserId": "308661", "Body": "<p>I think this is the relevant clause:</p>\n<blockquote>\n<p id=\"so_5322104_5322234_0\"><strong>ISO/IEC 14882:2003 C++ Standard 23.1.1/12 \u2013 Sequences</strong></p>\n<p id=\"so_5322104_5322234_1\">Table 68 lists sequence operations\n  that are provided for some types of\n  sequential containers but not others.\n  An implementation shall provide these\n  operations for all container types\n  shown in the \"container\" column, and\n  shall implement them so as to take\n  amortized constant time.</p>\n</blockquote>\n<pre>\n    +----------------------------------------------------------------------------+\n    |                                  Table 68                                  |\n    +--------------+-----------------+---------------------+---------------------+\n    |  expression  |   return type   |     operational     |      container      |\n    |              |                 |      semantics      |                     |\n    +--------------+-----------------+---------------------+---------------------+\n    | a.front()    | reference;      | *a.begin()          | vector, list, deque |\n    |              | const_reference |                     |                     |\n    |              | for constant a  |                     |                     |\n    +--------------+-----------------+---------------------+---------------------+\n    | a.back()     | reference;      | *--a.end()          | vector, list, deque |\n    |              | const_reference |                     |                     |\n    |              | for constant a  |                     |                     |\n    ..............................................................................\n    .              .                 .                     .                     .\n    .              .                 .                     .                     .\n    ..............................................................................\n    | a.pop_back() | void            | a.erase(--a.end())  | vector, list, deque |\n    ..............................................................................\n    .              .                 .                     .                     .\n    .              .                 .                     .                     .\n</pre>\n<p>So for the containers listed, not only should the iterator returned from <code>end()</code> be decrementable, the decremented iterator should also be dereferencable. (Unless the container is empty, of course. That invokes undefined behavior.)</p>\n<p>In fact, <code>vector</code>, <code>list</code> and <code>deque</code> implementations that came with the Visual C++ compiler does it exactly like the table. Of course, that's not to imply that every compiler does it like this:</p>\n<pre><code>// From VC++'s &lt;list&gt; implementation\n\nreference back()\n    {    // return last element of mutable sequence\n    return (*(--end()));\n    }\n\nconst_reference back() const\n    {    // return last element of nonmutable sequence\n    return (*(--end()));\n    }\n</code></pre>\n<hr>\n<p>Note about the code in the table:</p>\n<blockquote>\n<p id=\"so_5322104_5322234_2\"><strong>ISO/IEC 14882:2003 C++ Standard 17.3.1.2/6 \u2013 Requirements</strong></p>\n<p id=\"so_5322104_5322234_3\">In some cases the semantic\n  requirements are presented as C + +\n  code. <strong>Such code is intended as a\n  specification of equivalence of a\n  construct to another construct</strong>, not\n  necessarily as the way the construct\n  must be implemented.</p>\n</blockquote>\n<p>So while it's true that an implementation may not implement those expressions in terms of <code>begin()</code> and <code>end()</code>, the C++ standard specifies that the two expressions are equivalent. In other words, <code>a.back()</code> and <code>*--a.end()</code> are equivalent constructs according to the above clause. It seems to me that it means that you should be able to replace every instance of <code>a.back()</code> with <code>*--a.end()</code> and vice-versa and have the code still work.</p>\n<hr>\n<p>According to Bo Persson, the revision of the C++ standard that I have on hand <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#355\" rel=\"noreferrer\">has a defect</a> with respect to Table 68.</p>\n<blockquote>\n<p id=\"so_5322104_5322234_4\"><strong>Proposed resolution:</strong></p>\n<p id=\"so_5322104_5322234_5\">Change the specification in table 68\n  \"Optional Sequence Operations\" in\n  23.1.1/12 for \"a.back()\" from</p>\n<pre><code>*--a.end()\n</code></pre>\n<p id=\"so_5322104_5322234_6\">to</p>\n<pre><code>{ iterator tmp = a.end(); --tmp; return *tmp; }\n</code></pre>\n<p id=\"so_5322104_5322234_7\">and the specification for\n  \"a.pop_back()\" from</p>\n<pre><code>a.erase(--a.end())\n</code></pre>\n<p id=\"so_5322104_5322234_8\">to</p>\n<pre><code>{ iterator tmp = a.end(); --tmp; a.erase(tmp); }\n</code></pre>\n</blockquote>\n<p>It appears that you can still decrement the iterator returned from <code>end()</code> and dereference the decremented iterator, as long as it's not a temporary.</p>\n</hr></hr>", "LastActivityDate": "2011-03-16T21:52:01.683"}});