post_cb({"22014784": {"Id": "22014784", "PostTypeId": "2", "Body": "<h2>Detection toolkit</h2>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\" rel=\"nofollow noreferrer\">N4502</a> proposes a detection tookit for inclusion into the C++17 standard library which can solve the problem in a somewhat elegant manner. Moreover, it just got accepted into the library fundamentals TS v2. It introduces some metafunctions, including <a href=\"http://en.cppreference.com/w/cpp/experimental/is_detected\" rel=\"nofollow noreferrer\"><code>std::is_detected</code></a> which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:</p>\n<pre><code>template&lt;typename T&gt;\nusing toString_t = decltype( std::declval&lt;T&amp;&gt;().toString() );\n\ntemplate&lt;typename T&gt;\nconstexpr bool has_toString = std::is_detected_v&lt;toString_t, T&gt;;\n</code></pre>\n<p>Note that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature <code>if constexpr</code>:</p>\n<pre><code>template&lt;class T&gt;\nstd::string optionalToString(T* obj)\n{\n    if constexpr (has_toString&lt;T&gt;)\n        return obj-&gt;toString();\n    else\n        return \"toString not defined\";\n}\n</code></pre>\n<h2>Boost.TTI</h2>\n<p>Another somewhat idiomatic toolkit to perform such a check - even though less elegant - is <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/index.html\" rel=\"nofollow noreferrer\">Boost.TTI</a>, introduced in Boost 1.54.0. For your example, you would have to use the macro <code>BOOST_TTI_HAS_MEMBER_FUNCTION</code>. Here is how you could use it:</p>\n<pre><code>#include &lt;boost/tti/has_member_function.hpp&gt;\n\n// Generate the metafunction\nBOOST_TTI_HAS_MEMBER_FUNCTION(toString)\n\n// Check whether T has a member function toString\n// which takes no parameter and returns a std::string\nconstexpr bool foo = has_member_function_toString&lt;T, std::string&gt;::value;\n</code></pre>\n<p>Then, you could use the <code>bool</code> to create a SFINAE check.</p>\n<p><em>Explanation</em></p>\n<p>The macro <code>BOOST_TTI_HAS_MEMBER_FUNCTION</code> generates the metafunction <code>has_member_function_toString</code> which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function's parameters. The member <code>value</code> contains <code>true</code> if the class <code>T</code> has a member function <code>std::string toString()</code>.</p>\n<p>Alternatively, <code>has_member_function_toString</code> can take a member function pointer as a template parameter. Therefore, it is possible to replace <code>has_member_function_toString&lt;T, std::string&gt;::value</code> by <code>has_member_function_toString&lt;std::string T::* ()&gt;::value</code>.</p>\n", "LastEditorUserId": "1364752", "LastActivityDate": "2017-10-17T11:51:43.010", "Score": "32", "CreationDate": "2014-02-25T12:52:04.210", "ParentId": "257288", "CommentCount": "2", "OwnerUserId": "1364752", "LastEditDate": "2017-10-17T11:51:43.010"}, "9154394": {"Id": "9154394", "PostTypeId": "2", "Body": "<p>This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:</p>\n<pre><code>template&lt;class T&gt;\nauto serialize_imp(std::ostream&amp; os, T const&amp; obj, int)\n    -&gt; decltype(os &lt;&lt; obj, void())\n{\n  os &lt;&lt; obj;\n}\n\ntemplate&lt;class T&gt;\nauto serialize_imp(std::ostream&amp; os, T const&amp; obj, long)\n    -&gt; decltype(obj.stream(os), void())\n{\n  obj.stream(os);\n}\n\ntemplate&lt;class T&gt;\nauto serialize(std::ostream&amp; os, T const&amp; obj)\n    -&gt; decltype(serialize_imp(os, obj, 0), void())\n{\n  serialize_imp(os, obj, 0);\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/f69d3407b9de8ad160e18d98a6804f6d\" rel=\"noreferrer\">Live example.</a></p>\n<p>Now onto some explanations. First thing, I use <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html\" rel=\"noreferrer\">expression SFINAE</a> to exclude the <code>serialize(_imp)</code> functions from overload resolution, if the first expression inside <code>decltype</code> isn't valid (aka, the function doesn't exist).</p>\n<p>The <code>void()</code> is used to make the return type of all those functions <code>void</code>.</p>\n<p>The <code>0</code> argument is used to prefer the <code>os &lt;&lt; obj</code> overload if both are available (literal <code>0</code> is of type <code>int</code> and as such the first overload is a better match).</p>\n<hr>\n<p>Now, you probably want a trait to check if a function exists. Luckily, it's easy to write that. Note, though, that you need to write a trait <em>yourself</em> for every different function name you might want.</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;class&gt;\nstruct sfinae_true : std::true_type{};\n\nnamespace detail{\n  template&lt;class T, class A0&gt;\n  static auto test_stream(int)\n      -&gt; sfinae_true&lt;decltype(std::declval&lt;T&gt;().stream(std::declval&lt;A0&gt;()))&gt;;\n  template&lt;class, class A0&gt;\n  static auto test_stream(long) -&gt; std::false_type;\n} // detail::\n\ntemplate&lt;class T, class Arg&gt;\nstruct has_stream : decltype(detail::test_stream&lt;T, Arg&gt;(0)){};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/cd139d95d214c5c3\" rel=\"noreferrer\">Live example.</a></p>\n<p>And on to explanations. First, <code>sfinae_true</code> is a helper type, and it basically amounts to the same as writing <code>decltype(void(std::declval&lt;T&gt;().stream(a0)), std::true_type{})</code>. The advantage is simply that it's shorter.<br>\nNext, the <code>struct has_stream : decltype(...)</code> inherits from either <code>std::true_type</code> or <code>std::false_type</code> in the end, depending on whether the <code>decltype</code> check in <code>test_stream</code> fails or not.<br>\nLast, <code>std::declval</code> gives you a \"value\" of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as <code>decltype</code>, <code>sizeof</code> and others.</br></br></p>\n<hr>\n<p>Note that <code>decltype</code> is not necessarily needed, as <code>sizeof</code> (and all unevaluated contexts) got that enhancement. It's just that <code>decltype</code> already delivers a type and as such is just cleaner. Here's a <code>sizeof</code> version of one of the overloads:</p>\n<pre><code>template&lt;class T&gt;\nvoid serialize_imp(std::ostream&amp; os, T const&amp; obj, int,\n    int(*)[sizeof((os &lt;&lt; obj),0)] = 0)\n{\n  os &lt;&lt; obj;\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/500701ee6ff3e243213b2b4cc862d3d1\" rel=\"noreferrer\">Live example.</a></p>\n<p>The <code>int</code> and <code>long</code> parameters are still there for the same reason. The array pointer is used to provide a context where <code>sizeof</code> can be used.</p>\n</hr></hr>", "LastEditorUserId": "500104", "LastActivityDate": "2014-05-08T19:23:22.757", "Score": "205", "CreationDate": "2012-02-06T00:27:05.087", "ParentId": "257288", "CommentCount": "9", "OwnerUserId": "500104", "LastEditDate": "2014-05-08T19:23:22.757"}, "6324863": {"Id": "6324863", "PostTypeId": "2", "Body": "<p>Here are some usage snippets:\n*The guts for all this are farther down</p>\n<p><strong>Check for member <code>x</code> in a given class.  Could be var, func, class, union, or enum:</strong></p>\n<pre><code>CREATE_MEMBER_CHECK(x);\nbool has_x = has_member_x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p><strong>Check for member function <code>void x()</code>:</strong></p>\n<pre><code>//Func signature MUST have T as template variable here... simpler this way :\\\nCREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);\nbool has_func_sig_void__x = has_member_func_void__x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p><strong>Check for member variable <code>x</code>:</strong></p>\n<pre><code>CREATE_MEMBER_VAR_CHECK(x);\nbool has_var_x = has_member_var_x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p><strong>Check for member class <code>x</code>:</strong></p>\n<pre><code>CREATE_MEMBER_CLASS_CHECK(x);\nbool has_class_x = has_member_class_x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p><strong>Check for member union <code>x</code>:</strong></p>\n<pre><code>CREATE_MEMBER_UNION_CHECK(x);\nbool has_union_x = has_member_union_x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p><strong>Check for member enum <code>x</code>:</strong></p>\n<pre><code>CREATE_MEMBER_ENUM_CHECK(x);\nbool has_enum_x = has_member_enum_x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p><strong>Check for any member function <code>x</code> regardless of signature:</strong></p>\n<pre><code>CREATE_MEMBER_CHECK(x);\nCREATE_MEMBER_VAR_CHECK(x);\nCREATE_MEMBER_CLASS_CHECK(x);\nCREATE_MEMBER_UNION_CHECK(x);\nCREATE_MEMBER_ENUM_CHECK(x);\nCREATE_MEMBER_FUNC_CHECK(x);\nbool has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p>OR</p>\n<pre><code>CREATE_MEMBER_CHECKS(x);  //Just stamps out the same macro calls as above.\nbool has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;\n</code></pre>\n<p><strong>Details and core:</strong></p>\n<pre><code>/*\n    - Multiple inheritance forces ambiguity of member names.\n    - SFINAE is used to make aliases to member names.\n    - Expression SFINAE is used in just one generic has_member that can accept\n      any alias we pass it.\n*/\n\n//Variadic to force ambiguity of class members.  C++11 and up.\ntemplate &lt;typename... Args&gt; struct ambiguate : public Args... {};\n\n//Non-variadic version of the line above.\n//template &lt;typename A, typename B&gt; struct ambiguate : public A, public B {};\n\ntemplate&lt;typename A, typename = void&gt;\nstruct got_type : std::false_type {};\n\ntemplate&lt;typename A&gt;\nstruct got_type&lt;A&gt; : std::true_type {\n    typedef A type;\n};\n\ntemplate&lt;typename T, T&gt;\nstruct sig_check : std::true_type {};\n\ntemplate&lt;typename Alias, typename AmbiguitySeed&gt;\nstruct has_member {\n    template&lt;typename C&gt; static char ((&amp;f(decltype(&amp;C::value))))[1];\n    template&lt;typename C&gt; static char ((&amp;f(...)))[2];\n\n    //Make sure the member name is consistently spelled the same.\n    static_assert(\n        (sizeof(f&lt;AmbiguitySeed&gt;(0)) == 1)\n        , \"Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified.\"\n    );\n\n    static bool const value = sizeof(f&lt;Alias&gt;(0)) == 2;\n};\n</code></pre>\n<p><em><strong>Macros (El Diablo!):</strong></em></p>\n<p><strong>CREATE_MEMBER_CHECK:</strong></p>\n<pre><code>//Check for any member with given name, whether var, func, class, union, enum.\n#define CREATE_MEMBER_CHECK(member)                                         \\\n                                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;                             \\\nstruct Alias_##member;                                                      \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct Alias_##member &lt;                                                     \\\n    T, std::integral_constant&lt;bool, got_type&lt;decltype(&amp;T::member)&gt;::value&gt;  \\\n&gt; { static const decltype(&amp;T::member) value; };                             \\\n                                                                            \\\nstruct AmbiguitySeed_##member { char member; };                             \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct has_member_##member {                                                \\\n    static const bool value                                                 \\\n        = has_member&lt;                                                       \\\n            Alias_##member&lt;ambiguate&lt;T, AmbiguitySeed_##member&gt;&gt;            \\\n            , Alias_##member&lt;AmbiguitySeed_##member&gt;                        \\\n        &gt;::value                                                            \\\n    ;                                                                       \\\n}\n</code></pre>\n<p><strong>CREATE_MEMBER_VAR_CHECK:</strong></p>\n<pre><code>//Check for member variable with given name.\n#define CREATE_MEMBER_VAR_CHECK(var_name)                                   \\\n                                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;                             \\\nstruct has_member_var_##var_name : std::false_type {};                      \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct has_member_var_##var_name&lt;                                           \\\n    T                                                                       \\\n    , std::integral_constant&lt;                                               \\\n        bool                                                                \\\n        , !std::is_member_function_pointer&lt;decltype(&amp;T::var_name)&gt;::value   \\\n    &gt;                                                                       \\\n&gt; : std::true_type {}\n</code></pre>\n<p><strong>CREATE_MEMBER_FUNC_SIG_CHECK:</strong></p>\n<pre><code>//Check for member function with given name AND signature.\n#define CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \\\n                                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;                             \\\nstruct has_member_func_##templ_postfix : std::false_type {};                \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct has_member_func_##templ_postfix&lt;                                     \\\n    T, std::integral_constant&lt;                                              \\\n        bool                                                                \\\n        , sig_check&lt;func_sig, &amp;T::func_name&gt;::value                         \\\n    &gt;                                                                       \\\n&gt; : std::true_type {}\n</code></pre>\n<p><strong>CREATE_MEMBER_CLASS_CHECK:</strong></p>\n<pre><code>//Check for member class with given name.\n#define CREATE_MEMBER_CLASS_CHECK(class_name)               \\\n                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;             \\\nstruct has_member_class_##class_name : std::false_type {};  \\\n                                                            \\\ntemplate&lt;typename T&gt;                                        \\\nstruct has_member_class_##class_name&lt;                       \\\n    T                                                       \\\n    , std::integral_constant&lt;                               \\\n        bool                                                \\\n        , std::is_class&lt;                                    \\\n            typename got_type&lt;typename T::class_name&gt;::type \\\n        &gt;::value                                            \\\n    &gt;                                                       \\\n&gt; : std::true_type {}\n</code></pre>\n<p><strong>CREATE_MEMBER_UNION_CHECK:</strong></p>\n<pre><code>//Check for member union with given name.\n#define CREATE_MEMBER_UNION_CHECK(union_name)               \\\n                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;             \\\nstruct has_member_union_##union_name : std::false_type {};  \\\n                                                            \\\ntemplate&lt;typename T&gt;                                        \\\nstruct has_member_union_##union_name&lt;                       \\\n    T                                                       \\\n    , std::integral_constant&lt;                               \\\n        bool                                                \\\n        , std::is_union&lt;                                    \\\n            typename got_type&lt;typename T::union_name&gt;::type \\\n        &gt;::value                                            \\\n    &gt;                                                       \\\n&gt; : std::true_type {}\n</code></pre>\n<p><strong>CREATE_MEMBER_ENUM_CHECK:</strong></p>\n<pre><code>//Check for member enum with given name.\n#define CREATE_MEMBER_ENUM_CHECK(enum_name)                 \\\n                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;             \\\nstruct has_member_enum_##enum_name : std::false_type {};    \\\n                                                            \\\ntemplate&lt;typename T&gt;                                        \\\nstruct has_member_enum_##enum_name&lt;                         \\\n    T                                                       \\\n    , std::integral_constant&lt;                               \\\n        bool                                                \\\n        , std::is_enum&lt;                                     \\\n            typename got_type&lt;typename T::enum_name&gt;::type  \\\n        &gt;::value                                            \\\n    &gt;                                                       \\\n&gt; : std::true_type {}\n</code></pre>\n<p><strong>CREATE_MEMBER_FUNC_CHECK:</strong></p>\n<pre><code>//Check for function with given name, any signature.\n#define CREATE_MEMBER_FUNC_CHECK(func)          \\\ntemplate&lt;typename T&gt;                            \\\nstruct has_member_func_##func {                 \\\n    static const bool value                     \\\n        = has_member_##func&lt;T&gt;::value           \\\n        &amp;&amp; !has_member_var_##func&lt;T&gt;::value     \\\n        &amp;&amp; !has_member_class_##func&lt;T&gt;::value   \\\n        &amp;&amp; !has_member_union_##func&lt;T&gt;::value   \\\n        &amp;&amp; !has_member_enum_##func&lt;T&gt;::value    \\\n    ;                                           \\\n}\n</code></pre>\n<p><strong>CREATE_MEMBER_CHECKS:</strong></p>\n<pre><code>//Create all the checks for one member.  Does NOT include func sig checks.\n#define CREATE_MEMBER_CHECKS(member)    \\\nCREATE_MEMBER_CHECK(member);            \\\nCREATE_MEMBER_VAR_CHECK(member);        \\\nCREATE_MEMBER_CLASS_CHECK(member);      \\\nCREATE_MEMBER_UNION_CHECK(member);      \\\nCREATE_MEMBER_ENUM_CHECK(member);       \\\nCREATE_MEMBER_FUNC_CHECK(member)\n</code></pre>\n", "LastEditorUserId": "376331", "LastActivityDate": "2013-06-09T00:58:10.533", "Score": "8", "CreationDate": "2011-06-12T21:40:44.083", "ParentId": "257288", "CommentCount": "3", "OwnerUserId": "376331", "LastEditDate": "2013-06-09T00:58:10.533"}, "19815793": {"Id": "19815793", "PostTypeId": "2", "Body": "<p>I modified the solution provided in <a href=\"https://stackoverflow.com/a/264088/2712152\">https://stackoverflow.com/a/264088/2712152</a> to make it a bit more general. Also since it doesn't use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.</p>\n<p>The following macro can be used to check if a particular class has a particular typedef or not.</p>\n<pre><code>/** \n * @class      : HAS_TYPEDEF\n * @brief      : This macro will be used to check if a class has a particular\n * typedef or not.\n * @param typedef_name : Name of Typedef\n * @param name  : Name of struct which is going to be run the test for\n * the given particular typedef specified in typedef_name\n */\n#define HAS_TYPEDEF(typedef_name, name)                           \\\n   template &lt;typename T&gt;                                          \\\n   struct name {                                                  \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template &lt;typename U&gt;                                       \\\n      struct type_check;                                          \\\n      template &lt;typename _1&gt;                                      \\\n      static yes&amp; chk(type_check&lt;typename _1::typedef_name&gt;*);    \\\n      template &lt;typename&gt;                                         \\\n      static no&amp; chk(...);                                        \\\n      static bool const value = sizeof(chk&lt;T&gt;(0)) == sizeof(yes); \\\n   }\n</code></pre>\n<p>The following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.</p>\n<pre><code>/** \n * @class      : HAS_MEM_FUNC\n * @brief      : This macro will be used to check if a class has a particular\n * member function implemented in the public section or not. \n * @param func : Name of Member Function\n * @param name : Name of struct which is going to be run the test for\n * the given particular member function name specified in func\n * @param return_type: Return type of the member function\n * @param ellipsis(...) : Since this is macro should provide test case for every\n * possible member function we use variadic macros to cover all possibilities\n */\n#define HAS_MEM_FUNC(func, name, return_type, ...)                \\\n   template &lt;typename T&gt;                                          \\\n   struct name {                                                  \\\n      typedef return_type (T::*Sign)(__VA_ARGS__);                \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template &lt;typename U, U&gt;                                    \\\n      struct type_check;                                          \\\n      template &lt;typename _1&gt;                                      \\\n      static yes&amp; chk(type_check&lt;Sign, &amp;_1::func&gt;*);              \\\n      template &lt;typename&gt;                                         \\\n      static no&amp; chk(...);                                        \\\n      static bool const value = sizeof(chk&lt;T&gt;(0)) == sizeof(yes); \\\n   }\n</code></pre>\n<p>We can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:</p>\n<pre><code>class A {\npublic:\n  typedef int check;\n  void check_function() {}\n};\n\nclass B {\npublic:\n  void hello(int a, double b) {}\n  void hello() {}\n};\n\nHAS_MEM_FUNC(check_function, has_check_function, void, void);\nHAS_MEM_FUNC(hello, hello_check, void, int, double);\nHAS_MEM_FUNC(hello, hello_void_check, void, void);\nHAS_TYPEDEF(check, has_typedef_check);\n\nint main() {\n  std::cout &lt;&lt; \"Check Function A:\" &lt;&lt; has_check_function&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Check Function B:\" &lt;&lt; has_check_function&lt;B&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Hello Function A:\" &lt;&lt; hello_check&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Hello Function B:\" &lt;&lt; hello_check&lt;B&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Hello void Function A:\" &lt;&lt; hello_void_check&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Hello void Function B:\" &lt;&lt; hello_void_check&lt;B&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Check Typedef A:\" &lt;&lt; has_typedef_check&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Check Typedef B:\" &lt;&lt; has_typedef_check&lt;B&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-12T06:44:12.987", "Score": "4", "CreationDate": "2013-11-06T15:16:13.753", "ParentId": "257288", "CommentCount": "1", "OwnerUserId": "2712152", "LastEditDate": "2017-05-23T10:31:37.570"}, "261262": {"Body": "<p>Now this was a <em>nice</em> little puzzle - great question!</p>\n<p>Here's an alternative to <a href=\"https://stackoverflow.com/questions/257288/possible-for-c-template-to-check-for-a-functions-existence#257382\">Nicola Bonelli's solution</a> that does not rely on the non-standard <code>typeof</code> operator.</p>\n<p>Unfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.</p>\n<p>The longer comment block has the details on how it works (or is supposed to work).  As it says, I'm not sure which behavior is standards compliant - I'd welcome commentary on that.</p>\n<hr>\n<p>update - 7 Nov 2008:</p>\n<p>It looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to <a href=\"https://stackoverflow.com/users/4727/leon-timmermans\">Leon Timmermans</a> and <a href=\"https://stackoverflow.com/users/34509/litb\">litb</a> for pointing me in the right direction).  The C++03 standard says the following:</p>\n<blockquote>\n<p id=\"so_257288_261262_0\">14.6.2 Dependent names [temp.dep]</p>\n<p id=\"so_257288_261262_1\">Paragraph 3</p>\n<p id=\"so_257288_261262_2\">In the definition of a class template\n  or a member of a class template, if a\n  base class of the class template\n  depends on a template-parameter, the\n  base class scope is not examined\n  during unqualified name lookup either\n  at the point of definition of the\n  class template or member or during an\n  instantiation of the class template or\n  member.</p>\n</blockquote>\n<p>So, it looks like that when MSVC or Comeau consider the <code>toString()</code> member function of <code>T</code> performing name lookup at the call site in <code>doToString()</code> when the template is instantiated, that is incorrect (even though it's actually the behavior I was looking for in this case).</p>\n<p>The behavior of GCC and Digital Mars looks to be correct - in both cases the non-member <code>toString()</code> function is bound to the call.</p>\n<p>Rats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...</p>\n<hr>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Hello\n{\n    std::string toString() {\n        return \"Hello\";\n    }\n};\n\nstruct Generic {};\n\n\n// the following namespace keeps the toString() method out of\n//  most everything - except the other stuff in this\n//  compilation unit\n\nnamespace {\n    std::string toString()\n    {\n        return \"toString not defined\";\n    }\n\n    template &lt;typename T&gt;\n    class optionalToStringImpl : public T\n    {\n    public:\n        std::string doToString() {\n\n            // in theory, the name lookup for this call to \n            //  toString() should find the toString() in \n            //  the base class T if one exists, but if one \n            //  doesn't exist in the base class, it'll \n            //  find the free toString() function in \n            //  the private namespace.\n            //\n            // This theory works for MSVC (all versions\n            //  from VC6 to VC9) and Comeau C++, but\n            //  does not work with MinGW 3.4.5 or \n            //  Digital Mars 8.42n\n            //\n            // I'm honestly not sure what the standard says \n            //  is the correct behavior here - it's sort \n            //  of like ADL (Argument Dependent Lookup - \n            //  also known as Koenig Lookup) but without\n            //  arguments (except the implied \"this\" pointer)\n\n            return toString();\n        }\n    };\n}\n\ntemplate &lt;typename T&gt;\nstd::string optionalToString(T &amp; obj)\n{\n    // ugly, hacky cast...\n    optionalToStringImpl&lt;T&gt;* temp = reinterpret_cast&lt;optionalToStringImpl&lt;T&gt;*&gt;( &amp;obj);\n\n    return temp-&gt;doToString();\n}\n\n\n\nint\nmain(int argc, char *argv[])\n{\n    Hello helloObj;\n    Generic genericObj;\n\n    std::cout &lt;&lt; optionalToString( helloObj) &lt;&lt; std::endl;\n    std::cout &lt;&lt; optionalToString( genericObj) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n</hr></hr>", "CreationDate": "2008-11-04T08:37:40.677", "ParentId": "257288", "CommentCount": "7", "LastEditDate": "2017-05-23T10:31:37.570", "PostTypeId": "2", "LastEditorDisplayName": "Mike B", "LastActivityDate": "2014-03-31T18:04:45.957", "LastEditorUserId": "-1", "Id": "261262", "OwnerDisplayName": "Mike B", "Score": "6", "OwnerUserId": "12711"}, "3102261": {"Id": "3102261", "PostTypeId": "2", "Body": "<p>Strange nobody suggested the following nice trick I saw once on this very site :</p>\n<pre><code>template &lt;class T&gt;\nstruct has_foo\n{\n    struct S { void foo(...); };\n    struct derived : S, T {};\n\n    template &lt;typename V, V&gt; struct W {};\n\n    template &lt;typename X&gt;\n    char (&amp;test(W&lt;void (X::*)(), &amp;X::foo&gt; *))[1];\n\n    template &lt;typename&gt;\n    char (&amp;test(...))[2];\n\n    static const bool value = sizeof(test&lt;derived&gt;(0)) == 1;\n};\n</code></pre>\n<p>You have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.</p>\n", "LastActivityDate": "2010-06-23T13:56:49.030", "CommentCount": "0", "CreationDate": "2010-06-23T13:56:49.030", "ParentId": "257288", "Score": "3", "OwnerUserId": "373025"}, "257288": {"ViewCount": "97597", "Body": "<p>Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?</p>\n<p>Here's a simple example of what I would want to write:</p>\n<pre><code>template&lt;class T&gt;\nstd::string optionalToString(T* obj)\n{\n    if (FUNCTION_EXISTS(T-&gt;toString))\n        return obj-&gt;toString();\n    else\n        return \"toString not defined\";\n}\n</code></pre>\n<p>So, if <code>class T</code> has <code>toString()</code> defined, then it uses it; otherwise, it doesn't. The magical part that I don't know how to do is the \"FUNCTION_EXISTS\" part.</p>\n", "AcceptedAnswerId": "257382", "Title": "Is it possible to write a template to check for a function's existence?", "CreationDate": "2008-11-02T20:10:47.673", "LastActivityDate": "2017-11-01T22:29:06.583", "CommentCount": "2", "FavoriteCount": "255", "PostTypeId": "1", "LastEditDate": "2017-05-03T17:35:37.473", "OwnerDisplayName": "andy", "LastEditorUserId": "1896169", "Id": "257288", "Score": "365", "OwnerUserId": "21482", "Tags": "<c++><templates><template-meta-programming><sfinae>", "AnswerCount": "22"}, "21063089": {"Id": "21063089", "PostTypeId": "2", "Body": "<p>Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nHAS_MEM(bar)\nHAS_MEM_FUN_CALL(bar)\n\nstruct test\n{\n   void bar(int);\n   void bar(double);\n   void bar(int,double);\n\n   template &lt; typename T &gt;\n   typename std::enable_if&lt; not std::is_integral&lt;T&gt;::value &gt;::type\n   bar(const T&amp;, int=0){}\n\n   template &lt; typename T &gt;\n   typename std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::type\n   bar(const std::vector&lt;T&gt;&amp;, T*){}\n\n   template &lt; typename T &gt;\n   int bar(const std::string&amp;, int){}\n};\n</code></pre>\n<p>Now you can use it like this:</p>\n<pre><code>int main(int argc, const char * argv[])\n{\n   static_assert( has_mem_bar&lt;test&gt;::value , \"\");\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(char const*,long)&gt;::value , \"\");\n   static_assert( has_valid_mem_fun_call_bar&lt;test(std::string&amp;,long)&gt;::value , \"\");\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(std::vector&lt;int&gt;, int*)&gt;::value , \"\");\n   static_assert( has_no_viable_mem_fun_call_bar&lt;test(std::vector&lt;double&gt;, double*)&gt;::value , \"\");\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(int)&gt;::value , \"\");\n   static_assert( std::is_same&lt;void,result_of_mem_fun_call_bar&lt;test(int)&gt;::type&gt;::value , \"\");\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(int,double)&gt;::value , \"\");\n   static_assert( not has_valid_mem_fun_call_bar&lt;test(int,double,int)&gt;::value , \"\");\n\n   static_assert( not has_ambiguous_mem_fun_call_bar&lt;test(double)&gt;::value , \"\");\n   static_assert( has_ambiguous_mem_fun_call_bar&lt;test(unsigned)&gt;::value , \"\");\n\n   static_assert( has_viable_mem_fun_call_bar&lt;test(unsigned)&gt;::value , \"\");\n   static_assert( has_viable_mem_fun_call_bar&lt;test(int)&gt;::value , \"\");\n\n   static_assert( has_no_viable_mem_fun_call_bar&lt;test(void)&gt;::value , \"\");\n\n   return 0;\n}\n</code></pre>\n<p>Here is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.</p>\n<pre><code>#pragma once\n\n#if __cplusplus &gt;= 201103\n\n#include &lt;utility&gt;\n#include &lt;type_traits&gt;\n\n#define HAS_MEM(mem)                                                                                     \\\n                                                                                                     \\\ntemplate &lt; typename T &gt;                                                                               \\\nstruct has_mem_##mem                                                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  struct ambiguate_seed { char mem; };                                                               \\\n  template &lt; typename U &gt; struct ambiguate : U, ambiguate_seed {};                                   \\\n                                                                                                     \\\n  template &lt; typename U, typename = decltype(&amp;U::mem) &gt; static constexpr no  test(int);              \\\n  template &lt; typename                                 &gt; static constexpr yes test(...);              \\\n                                                                                                     \\\n  static bool constexpr value = std::is_same&lt;decltype(test&lt; ambiguate&lt;T&gt; &gt;(0)),yes&gt;::value ;         \\\n  typedef std::integral_constant&lt;bool,value&gt;    type;                                                \\\n};\n\n\n#define HAS_MEM_FUN_CALL(memfun)                                                                         \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_valid_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_valid_mem_fun_call_##memfun&lt; T(Args...) &gt;                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  template &lt; typename U, bool = has_mem_##memfun&lt;U&gt;::value &gt;                                         \\\n  struct impl                                                                                        \\\n  {                                                                                                  \\\n     template &lt; typename V, typename = decltype(std::declval&lt;V&gt;().memfun(std::declval&lt;Args&gt;()...)) &gt; \\\n     struct test_result { using type = yes; };                                                       \\\n                                                                                                     \\\n     template &lt; typename V &gt; static constexpr typename test_result&lt;V&gt;::type test(int);               \\\n     template &lt; typename   &gt; static constexpr                            no test(...);               \\\n                                                                                                     \\\n     static constexpr bool value = std::is_same&lt;decltype(test&lt;U&gt;(0)),yes&gt;::value;                    \\\n     using type = std::integral_constant&lt;bool, value&gt;;                                               \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template &lt; typename U &gt;                                                                            \\\n  struct impl&lt;U,false&gt; : std::false_type {};                                                         \\\n                                                                                                     \\\n  static constexpr bool value = impl&lt;T&gt;::value;                                                      \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_ambiguous_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_ambiguous_mem_fun_call_##memfun&lt; T(Args...) &gt;                                              \\\n{                                                                                                     \\\n  struct ambiguate_seed { void memfun(...); };                                                       \\\n                                                                                                     \\\n  template &lt; class U, bool = has_mem_##memfun&lt;U&gt;::value &gt;                                            \\\n  struct ambiguate : U, ambiguate_seed                                                               \\\n  {                                                                                                  \\\n    using ambiguate_seed::memfun;                                                                    \\\n    using U::memfun;                                                                                 \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template &lt; class U &gt;                                                                               \\\n  struct ambiguate&lt;U,false&gt; : ambiguate_seed {};                                                     \\\n                                                                                                     \\\n  static constexpr bool value = not has_valid_mem_fun_call_##memfun&lt; ambiguate&lt;T&gt;(Args...) &gt;::value; \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_viable_mem_fun_call_##memfun;                                                              \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_viable_mem_fun_call_##memfun&lt; T(Args...) &gt;                                                 \\\n{                                                                                                     \\\n  static constexpr bool value = has_valid_mem_fun_call_##memfun&lt;T(Args...)&gt;::value                   \\\n                             or has_ambiguous_mem_fun_call_##memfun&lt;T(Args...)&gt;::value;              \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_no_viable_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_no_viable_mem_fun_call_##memfun &lt; T(Args...) &gt;                                             \\\n{                                                                                                     \\\n  static constexpr bool value = not has_viable_mem_fun_call_##memfun&lt;T(Args...)&gt;::value;             \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct result_of_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct result_of_mem_fun_call_##memfun&lt; T(Args...) &gt;                                                  \\\n{                                                                                                     \\\n  using type = decltype(std::declval&lt;T&gt;().memfun(std::declval&lt;Args&gt;()...));                          \\\n};\n\n#endif\n</code></pre>\n<hr>\n</hr>", "LastEditorUserId": "3185134", "LastActivityDate": "2014-01-11T17:28:57.793", "Score": "1", "CreationDate": "2014-01-11T13:54:13.657", "ParentId": "257288", "CommentCount": "0", "OwnerUserId": "3185134", "LastEditDate": "2014-01-11T17:28:57.793"}, "34801904": {"Id": "34801904", "PostTypeId": "2", "Body": "<p>You can skip all the metaprogramming in C++14, and just write this using <a href=\"http://fit.readthedocs.io/en/latest/include/fit/conditional.html\" rel=\"nofollow noreferrer\"><code>fit::conditional</code></a> from the <a href=\"https://github.com/pfultz2/Fit\" rel=\"nofollow noreferrer\">Fit</a> library:</p>\n<pre><code>template&lt;class T&gt;\nstd::string optionalToString(T* x)\n{\n    return fit::conditional(\n        [](auto* obj) -&gt; decltype(obj-&gt;toString()) { return obj-&gt;toString(); },\n        [](auto*) { return \"toString not defined\"; }\n    )(x);\n}\n</code></pre>\n<p>You can also create the function directly from the lambdas as well:</p>\n<pre><code>FIT_STATIC_LAMBDA_FUNCTION(optionalToString) = fit::conditional(\n    [](auto* obj) -&gt; decltype(obj-&gt;toString(), std::string()) { return obj-&gt;toString(); },\n    [](auto*) -&gt; std::string { return \"toString not defined\"; }\n);\n</code></pre>\n<p>However, if you are using a compiler that doesn't support generic lambdas, you will have to write separate function objects:</p>\n<pre><code>struct withToString\n{\n    template&lt;class T&gt;\n    auto operator()(T* obj) const -&gt; decltype(obj-&gt;toString(), std::string())\n    {\n        return obj-&gt;toString();\n    }\n};\n\nstruct withoutToString\n{\n    template&lt;class T&gt;\n    std::string operator()(T*) const\n    {\n        return \"toString not defined\";\n    }\n};\n\nFIT_STATIC_FUNCTION(optionalToString) = fit::conditional(\n    withToString(),\n    withoutToString()\n);\n</code></pre>\n", "LastEditorUserId": "375343", "LastActivityDate": "2017-01-04T23:50:27.640", "Score": "1", "CreationDate": "2016-01-14T23:43:07.427", "ParentId": "257288", "CommentCount": "0", "OwnerUserId": "375343", "LastEditDate": "2017-01-04T23:50:27.640"}, "502552": {"Id": "502552", "PostTypeId": "2", "Body": "<p>The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. </p>\n<p>For a solution that handles this situation refer to :</p>\n<p>In Russian :\n<a href=\"http://www.rsdn.ru/forum/message/2759773.1.aspx\" rel=\"noreferrer\">http://www.rsdn.ru/forum/message/2759773.1.aspx</a> </p>\n<p>English Translation by Roman.Perepelitsa : \n<a href=\"http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1\" rel=\"noreferrer\">http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1</a> </p>\n<p>It is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)</p>\n<p>In Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.</p>\n", "OwnerDisplayName": "Roshan", "LastActivityDate": "2009-02-02T08:35:41.037", "Score": "6", "CreationDate": "2009-02-02T08:35:41.037", "ParentId": "257288", "CommentCount": "1"}, "4810386": {"Id": "4810386", "PostTypeId": "2", "Body": "<p>MSVC has the __if_exists and __if_not_exists keywords (<a href=\"http://msdn.microsoft.com/en-us/library/x7wy9xh3(VS.80).aspx\" rel=\"noreferrer\">Doc</a>). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.</p>\n<p><strong>Update:</strong> Source can be found <a href=\"https://github.com/nob13/sfserialization/blob/master/sfserialization/isdefault.h\" rel=\"noreferrer\">Here</a></p>\n", "LastEditorUserId": "335385", "LastActivityDate": "2011-01-30T18:26:49.267", "Score": "5", "CreationDate": "2011-01-26T21:45:11.023", "ParentId": "257288", "CommentCount": "0", "OwnerUserId": "335385", "LastEditDate": "2011-01-30T18:26:49.267"}, "8755981": {"Id": "8755981", "PostTypeId": "2", "Body": "<p>I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:</p>\n<p><a href=\"https://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions/8752988#8752988\">SFINAE to check for inherited member functions</a></p>\n<p>Here are some example from that solution:</p>\n<h2>Example1:</h2>\n<p>We are checking for a member with the following signature: \n<code>T::const_iterator begin() const</code></p>\n<pre><code>template&lt;class T&gt; struct has_const_begin\n{\n    typedef char (&amp;Yes)[1];\n    typedef char (&amp;No)[2];\n\n    template&lt;class U&gt; \n    static Yes test(U const * data, \n                    typename std::enable_if&lt;std::is_same&lt;\n                             typename U::const_iterator, \n                             decltype(data-&gt;begin())\n                    &gt;::value&gt;::type * = 0);\n    static No test(...);\n    static const bool value = sizeof(Yes) == sizeof(has_const_begin::test((typename std::remove_reference&lt;T&gt;::type*)0));\n};\n</code></pre>\n<p>Please notice that it even checks the constness of the method, and works with primitive types, as well. (I mean <code>has_const_begin&lt;int&gt;::value</code> is false and doesn't cause a compile-time error.) </p>\n<h2>Example 2</h2>\n<p>Now we are looking for the signature: <code>void foo(MyClass&amp;, unsigned)</code></p>\n<pre><code>template&lt;class T&gt; struct has_foo\n{\n    typedef char (&amp;Yes)[1];\n    typedef char (&amp;No)[2];\n\n    template&lt;class U&gt;\n    static Yes test(U * data, MyClass* arg1 = 0,\n                    typename std::enable_if&lt;std::is_void&lt;\n                             decltype(data-&gt;foo(*arg1, 1u))\n                    &gt;::value&gt;::type * = 0);\n    static No test(...);\n    static const bool value = sizeof(Yes) == sizeof(has_foo::test((typename std::remove_reference&lt;T&gt;::type*)0));\n};\n</code></pre>\n<p>Please notice that MyClass doesn't has to be default constructible or to satisfy any special concept. The technique works with template members, as well.</p>\n<p>I am eagerly waiting opinions regarding this.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-06-27T19:42:21.547", "Score": "6", "CreationDate": "2012-01-06T09:48:51.917", "ParentId": "257288", "CommentCount": "0", "OwnerUserId": "667409", "LastEditDate": "2017-05-23T10:31:37.570"}, "33328621": {"Id": "33328621", "PostTypeId": "2", "Body": "<p>There are a lot of answers here, but I failed, to find a version, that performs <em>real</em> method resolution ordering, while not using any of the newer c++ features (only using c++98 features).<br>\nNote: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.<br/></br></p>\n<p>So I came up with a version, that only uses sizeof():</p>\n<pre><code>template&lt;typename T&gt; T declval(void);\n\nstruct fake_void { };\ntemplate&lt;typename T&gt; T &amp;operator,(T &amp;,fake_void);\ntemplate&lt;typename T&gt; T const &amp;operator,(T const &amp;,fake_void);\ntemplate&lt;typename T&gt; T volatile &amp;operator,(T volatile &amp;,fake_void);\ntemplate&lt;typename T&gt; T const volatile &amp;operator,(T const volatile &amp;,fake_void);\n\nstruct yes { char v[1]; };\nstruct no  { char v[2]; };\ntemplate&lt;bool&gt; struct yes_no:yes{};\ntemplate&lt;&gt; struct yes_no&lt;false&gt;:no{};\n\ntemplate&lt;typename T&gt;\nstruct has_awesome_member {\n template&lt;typename U&gt; static yes_no&lt;(sizeof((\n   declval&lt;U&gt;().awesome_member(),fake_void()\n  ))!=0)&gt; check(int);\n template&lt;typename&gt; static no check(...);\n enum{value=sizeof(check&lt;T&gt;(0)) == sizeof(yes)};\n};\n\n\nstruct foo { int awesome_member(void); };\nstruct bar { };\nstruct foo_void { void awesome_member(void); };\nstruct wrong_params { void awesome_member(int); };\n\nstatic_assert(has_awesome_member&lt;foo&gt;::value,\"\");\nstatic_assert(!has_awesome_member&lt;bar&gt;::value,\"\");\nstatic_assert(has_awesome_member&lt;foo_void&gt;::value,\"\");\nstatic_assert(!has_awesome_member&lt;wrong_params&gt;::value,\"\");\n</code></pre>\n<p>Live demo (with extended return type checking and vc++2010 workaround): <a href=\"http://cpp.sh/5b2vs\" rel=\"nofollow noreferrer\">http://cpp.sh/5b2vs</a></p>\n<p>No source, as I came up with it myself.</p>\n<p>When running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.<br>\nA commonly used work-around is to replace the 'typedef' in the macro with 'extern'.</br></p>\n", "LastEditorUserId": "3296587", "LastActivityDate": "2016-12-07T08:41:58.913", "Score": "2", "CreationDate": "2015-10-25T10:28:37.920", "ParentId": "257288", "CommentCount": "5", "OwnerUserId": "3296587", "LastEditDate": "2016-12-07T08:41:58.913"}, "264088": {"Body": "<p>C++ allows <a href=\"http://en.wikipedia.org/wiki/SFINAE\" rel=\"noreferrer\">SFINAE</a> to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):</p>\n<pre><code>#define HAS_MEM_FUNC(func, name)                                        \\\n    template&lt;typename T, typename Sign&gt;                                 \\\n    struct name {                                                       \\\n        typedef char yes[1];                                            \\\n        typedef char no [2];                                            \\\n        template &lt;typename U, U&gt; struct type_check;                     \\\n        template &lt;typename _1&gt; static yes &amp;chk(type_check&lt;Sign, &amp;_1::func &gt; *); \\\n        template &lt;typename   &gt; static no  &amp;chk(...);                    \\\n        static bool const value = sizeof(chk&lt;T&gt;(0)) == sizeof(yes);     \\\n    }\n</code></pre>\n<p>the above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types to not fit, SFINAE causes the template to be ignored. Usage like this:</p>\n<pre><code>HAS_MEM_FUNC(toString, has_to_string);\n\ntemplate&lt;typename T&gt; void\ndoSomething() {\n   if(has_to_string&lt;T, std::string(T::*)()&gt;::value) {\n      ...\n   } else {\n      ...\n   }\n}\n</code></pre>\n<p>But note that you cannot just call that <code>toString</code> function in that if branch. since the compiler will check for validity in both branches, that would fail for cases the function doesnt exist. One way is to use SFINAE once again (enable_if can be gotten from boost too):</p>\n<pre><code>template&lt;bool C, typename T = void&gt;\nstruct enable_if {\n  typedef T type;\n};\n\ntemplate&lt;typename T&gt;\nstruct enable_if&lt;false, T&gt; { };\n\nHAS_MEM_FUNC(toString, has_to_string);\n\ntemplate&lt;typename T&gt; \ntypename enable_if&lt;has_to_string&lt;T, \n                   std::string(T::*)()&gt;::value, std::string&gt;::type\ndoSomething(T * t) {\n   /* something when T has toString ... */\n   return t-&gt;toString();\n}\n\ntemplate&lt;typename T&gt; \ntypename enable_if&lt;!has_to_string&lt;T, \n                   std::string(T::*)()&gt;::value, std::string&gt;::type\ndoSomething(T * t) {\n   /* something when T doesnt have toString ... */\n   return \"T::toString() does not exist.\";\n}\n</code></pre>\n<p>Have fun using it. The advantage of it is that it also works for overloaded member functions, and also for const member functions (remember using  <code>std::string(T::*)() const</code> as the member function pointer type then!). </p>\n", "CreationDate": "2008-11-05T01:08:39.087", "ParentId": "257288", "CommentCount": "19", "LastEditDate": "2014-04-11T17:27:23.410", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2014-04-11T17:27:23.410", "LastEditorUserId": "34509", "Id": "264088", "OwnerDisplayName": "litb", "Score": "152", "OwnerUserId": "34509"}, "17534399": {"Id": "17534399", "PostTypeId": "2", "Body": "<p>How about this solution?</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename U, typename = void&gt; struct hasToString : std::false_type { };\n\ntemplate &lt;typename U&gt;\nstruct hasToString&lt;U,\n  typename std::enable_if&lt;bool(sizeof(&amp;U::toString))&gt;::type\n&gt; : std::true_type { };\n</code></pre>\n", "LastActivityDate": "2013-07-08T19:25:41.937", "CommentCount": "2", "CreationDate": "2013-07-08T19:25:41.937", "ParentId": "257288", "Score": "1", "OwnerUserId": "1095108"}, "257382": {"Body": "<p>Yes, with SFINAE you can check if a given class does provide a certain method. Here's the working code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Hello\n{\n    int helloworld() { return 0; }\n};\n\nstruct Generic {};    \n\n// SFINAE test\ntemplate &lt;typename T&gt;\nclass has_helloworld\n{\n    typedef char one;\n    typedef long two;\n\n    template &lt;typename C&gt; static one test( typeof(&amp;C::helloworld) ) ;\n    template &lt;typename C&gt; static two test(...);    \n\npublic:\n    enum { value = sizeof(test&lt;T&gt;(0)) == sizeof(char) };\n};\n\nint main(int argc, char *argv[])\n{\n    std::cout &lt;&lt; has_helloworld&lt;Hello&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; has_helloworld&lt;Generic&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>I've just tested it with Linux and gcc 4.1/4.3. I don't know if it's portable to other platforms running different compilers. </p>\n", "CreationDate": "2008-11-02T21:15:01.180", "ParentId": "257288", "CommentCount": "18", "LastEditDate": "2016-03-02T22:59:29.610", "PostTypeId": "2", "LastEditorDisplayName": "Nicola Bonelli", "LastActivityDate": "2016-03-02T22:59:29.610", "LastEditorUserId": "1459996", "Id": "257382", "OwnerDisplayName": "Nicola Bonelli", "Score": "255", "OwnerUserId": "19630"}, "47064058": {"Id": "47064058", "PostTypeId": "2", "Body": "<p>Here is an example of the working code.</p>\n<pre><code>template&lt;typename T&gt;\nusing toStringFn = decltype(std::declval&lt;const T&gt;().toString());\n\ntemplate &lt;class T, toStringFn&lt;T&gt;* = nullptr&gt;\nstd::string optionalToString(const T* obj, int)\n{\n    return obj-&gt;toString();\n}\n\ntemplate &lt;class T&gt;\nstd::string optionalToString(const T* obj, long)\n{\n    return \"toString not defined\";\n}\n\nint main()\n{\n    A* a;\n    B* b;\n\n    std::cout &lt;&lt; optionalToString(a, 0) &lt;&lt; std::endl; // This is A\n    std::cout &lt;&lt; optionalToString(b, 0) &lt;&lt; std::endl; // toString not defined\n}\n</code></pre>\n<p><code>toStringFn&lt;T&gt;* = nullptr</code> will enable the function which takes extra <code>int</code> argument which has a priority over function which takes <code>long</code> when called with <code>0</code>.</p>\n<p>You can use the same principle for the functions which returns <code>true</code> if function is implemented.</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr bool toStringExists(long)\n{\n    return false;\n}\n\ntemplate &lt;typename T, toStringFn&lt;T&gt;* = nullptr&gt;\nconstexpr bool toStringExists(int)\n{\n    return true;\n}\n\n\nint main()\n{\n    A* a;\n    B* b;\n\n    std::cout &lt;&lt; toStringExists&lt;A&gt;(0) &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; toStringExists&lt;B&gt;(0) &lt;&lt; std::endl; // false\n}\n</code></pre>\n", "LastEditorUserId": "2584542", "LastActivityDate": "2017-11-01T22:29:06.583", "Score": "0", "CreationDate": "2017-11-01T21:35:03.883", "ParentId": "257288", "CommentCount": "0", "OwnerUserId": "2584542", "LastEditDate": "2017-11-01T22:29:06.583"}, "bq_ids": {"n4140": {"so_257288_261262_2": {"length": 27, "quality": 0.8709677419354839, "section_id": 190}}, "n3337": {"so_257288_261262_2": {"length": 27, "quality": 0.8709677419354839, "section_id": 184}}, "n4659": {"so_257288_261262_2": {"length": 22, "quality": 0.7096774193548387, "section_id": 195}}}, "23996349": {"Id": "23996349", "PostTypeId": "2", "Body": "<p>This is a C++11 solution for the general problem if \"If I did X, would it compile?\"</p>\n<pre><code>template&lt;class&gt; struct type_sink { typedef void type; }; // consumes a type, and makes it `void`\ntemplate&lt;class T&gt; using type_sink_t = typename type_sink&lt;T&gt;::type;\ntemplate&lt;class T, class=void&gt; struct has_to_string : std::false_type {}; \\\ntemplate&lt;class T&gt; struct has_to_string&lt;\n  T,\n  type_sink_t&lt; decltype( std::declval&lt;T&gt;().toString() ) &gt;\n&gt;: std::true_type {};\n</code></pre>\n<p>Trait <code>has_to_string</code> such that <code>has_to_string&lt;T&gt;::value</code> is <code>true</code> if and only if <code>T</code> has a method <code>.toString</code> that can be invoked with 0 arguments in this context.</p>\n<p>Next, I'd use tag dispatching:</p>\n<pre><code>namespace details {\n  template&lt;class T&gt;\n  std::string optionalToString_helper(T* obj, std::true_type /*has_to_string*/) {\n    return obj-&gt;toString();\n  }\n  template&lt;class T&gt;\n  std::string optionalToString_helper(T* obj, std::false_type /*has_to_string*/) {\n    return \"toString not defined\";\n  }\n}\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj) {\n  return details::optionalToString_helper( obj, has_to_string&lt;T&gt;{} );\n}\n</code></pre>\n<p>which tends to be more maintainable than complex SFINAE expressions.</p>\n<p>You can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:</p>\n<pre><code>#define MAKE_CODE_TRAIT( TRAIT_NAME, ... ) \\\ntemplate&lt;class T, class=void&gt; struct TRAIT_NAME : std::false_type {}; \\\ntemplate&lt;class T&gt; struct TRAIT_NAME&lt; T, type_sink_t&lt; decltype( __VA_ARGS__ ) &gt; &gt;: std::true_type {};\n</code></pre>\n<p>what the above does is create a macro <code>MAKE_CODE_TRAIT</code>.  You pass it the name of the trait you want, and some code that can test the type <code>T</code>.  Thus:</p>\n<pre><code>MAKE_CODE_TRAIT( has_to_string, std::declval&lt;T&gt;().toString() )\n</code></pre>\n<p>creates the above traits class.</p>\n<p>As an aside, the above technique is part of what MS calls \"expression SFINAE\", and their 2013 compiler fails pretty hard.</p>\n<p>Note that in C++1y the following syntax is possible:</p>\n<pre><code>template&lt;class T&gt;\nstd::string optionalToString(T* obj) {\n  return compiled_if&lt; has_to_string &gt;(*obj, [&amp;](auto&amp;&amp; obj) {\n    return obj.toString();\n  }) *compiled_else ([&amp;]{ \n    return \"toString not defined\";\n  });\n}\n</code></pre>\n<p>which is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.</p>\n", "LastEditorUserId": "369009", "LastActivityDate": "2017-06-09T16:10:24.457", "Score": "6", "CreationDate": "2014-06-02T13:58:38.237", "ParentId": "257288", "CommentCount": "6", "OwnerUserId": "1774667", "LastEditDate": "2017-06-09T16:10:24.457"}, "30848101": {"Id": "30848101", "PostTypeId": "2", "Body": "<p>Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\" rel=\"nofollow noreferrer\" title=\"Proposing Standard Library Support for the C++ Detection Idiom, v2\">N4502</a> for details, but as a self-contained example consider the following.</p>\n<p>This part is the constant part, put it in a header.</p>\n<pre><code>// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf.\ntemplate &lt;typename...&gt;\nusing void_t = void;\n\n// Primary template handles all types not supporting the operation.\ntemplate &lt;typename, template &lt;typename&gt; class, typename = void_t&lt;&gt;&gt;\nstruct detect : std::false_type {};\n\n// Specialization recognizes/validates only types supporting the archetype.\ntemplate &lt;typename T, template &lt;typename&gt; class Op&gt;\nstruct detect&lt;T, Op, void_t&lt;Op&lt;T&gt;&gt;&gt; : std::true_type {};\n</code></pre>\n<p>then there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:</p>\n<pre><code>template &lt;typename T&gt;\nusing toString_t = decltype(std::declval&lt;T&gt;().toString());\n\ntemplate &lt;typename T&gt;\nusing has_toString = detect&lt;T, toString_t&gt;;\n</code></pre>\n<p>The following example, taken from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\" rel=\"nofollow noreferrer\" title=\"Proposing Standard Library Support for the C++ Detection Idiom, v2\">N4502</a>, shows a more elaborate probe:</p>\n<pre><code>// Archetypal expression for assignment operation.\ntemplate &lt;typename T&gt;\nusing assign_t = decltype(std::declval&lt;T&amp;&gt;() = std::declval&lt;T const &amp;&gt;())\n\n// Trait corresponding to that archetype.\ntemplate &lt;typename T&gt;\nusing is_assignable = detect&lt;T, assign_t&gt;;\n</code></pre>\n<p>Compared to the other implementations described above, this one is fairly simple: a reduced set of tools (<code>void_t</code> and <code>detect</code>) suffices, no need for hairy macros.  Besides, it was reported (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\" rel=\"nofollow noreferrer\" title=\"Proposing Standard Library Support for the C++ Detection Idiom, v2\">N4502</a>) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.</p>\n<p>Here is a <a href=\"http://coliru.stacked-crooked.com/a/7eae9c76232a2d20\" rel=\"nofollow noreferrer\" title=\"Detection idiom\">live example</a>.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused <code>void_t</code> to not work as expected.  Yakk already provided the work-around: use the following definition of <code>void_t</code> (<a href=\"https://stackoverflow.com/questions/28967003/void-t-in-parameter-list-works-but-not-as-return-type/28967049#28967049\">void_t in parameter list works but not as return type</a>):</p>\n<pre><code>#if __GNUC__ &lt; 5 &amp;&amp; ! defined __clang__\n// https://stackoverflow.com/a/28967049/1353549\ntemplate &lt;typename...&gt;\nstruct voider\n{\n  using type = void;\n};\ntemplate &lt;typename...Ts&gt;\nusing void_t = typename voider&lt;Ts...&gt;::type;\n#else\ntemplate &lt;typename...&gt;\nusing void_t = void;\n#endif\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-15T16:32:27.763", "Score": "15", "CreationDate": "2015-06-15T14:43:14.573", "ParentId": "257288", "CommentCount": "3", "OwnerUserId": "1353549", "LastEditDate": "2017-05-23T11:55:00.137"}, "37142300": {"Id": "37142300", "PostTypeId": "2", "Body": "<p>The generic template that can be used for checking if some \"feature\" is supported by the type:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;template &lt;typename&gt; class TypeChecker, typename Type&gt;\nstruct is_supported\n{\n    // these structs are used to recognize which version\n    // of the two functions was chosen during overload resolution\n    struct supported {};\n    struct not_supported {};\n\n    // this overload of chk will be ignored by SFINAE principle\n    // if TypeChecker&lt;Type_&gt; is invalid type\n    template &lt;typename Type_&gt;\n    static supported chk(typename std::decay&lt;TypeChecker&lt;Type_&gt;&gt;::type *);\n\n    // ellipsis has the lowest conversion rank, so this overload will be\n    // chosen during overload resolution only if the template overload above is ignored\n    template &lt;typename Type_&gt;\n    static not_supported chk(...);\n\n    // if the template overload of chk is chosen during\n    // overload resolution then the feature is supported\n    // if the ellipses overload is chosen the the feature is not supported\n    static constexpr bool value = std::is_same&lt;decltype(chk&lt;Type&gt;(nullptr)),supported&gt;::value;\n};\n</code></pre>\n<p>The template that checks whether there is a method <code>foo</code> that is compatible with signature <code>double(const char*)</code></p>\n<pre><code>// if T doesn't have foo method with the signature that allows to compile the bellow\n// expression then instantiating this template is Substitution Failure (SF)\n// which Is Not An Error (INAE) if this happens during overload resolution\ntemplate &lt;typename T&gt;\nusing has_foo = decltype(double(std::declval&lt;T&gt;().foo(std::declval&lt;const char*&gt;())));\n</code></pre>\n<p>Examples</p>\n<pre><code>// types that support has_foo\nstruct struct1 { double foo(const char*); };            // exact signature match\nstruct struct2 { int    foo(const std::string &amp;str); }; // compatible signature\nstruct struct3 { float  foo(...); };                    // compatible ellipsis signature\nstruct struct4 { template &lt;typename T&gt;\n                 int    foo(T t); };                    // compatible template signature\n\n// types that do not support has_foo\nstruct struct5 { void        foo(const char*); }; // returns void\nstruct struct6 { std::string foo(const char*); }; // std::string can't be converted to double\nstruct struct7 { double      foo(      int *); }; // const char* can't be converted to int*\nstruct struct8 { double      bar(const char*); }; // there is no foo method\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha;\n\n    std::cout &lt;&lt; is_supported&lt;has_foo, int    &gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, double &gt;::value &lt;&lt; std::endl; // false\n\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct1&gt;::value &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct2&gt;::value &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct3&gt;::value &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct4&gt;::value &lt;&lt; std::endl; // true\n\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct5&gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct6&gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct7&gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct8&gt;::value &lt;&lt; std::endl; // false\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/83c6a631ed42cea4\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/83c6a631ed42cea4</a></p>\n", "LastActivityDate": "2016-05-10T15:02:54.153", "CommentCount": "1", "CreationDate": "2016-05-10T15:02:54.153", "ParentId": "257288", "Score": "3", "OwnerUserId": "5447906"}, "3627243": {"Id": "3627243", "PostTypeId": "2", "Body": "<p>Though this question is two years old, I'll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the <code>typeof</code> extension:</p>\n<pre><code>template &lt;class Type&gt;\nclass TypeHasToString\n{\n    // This type won't compile if the second template parameter isn't of type T,\n    // so I can put a function pointer type in the first parameter and the function\n    // itself in the second thus checking that the function has a specific signature.\n    template &lt;typename T, T&gt; struct TypeCheck;\n\n    typedef char Yes;\n    typedef long No;\n\n    // A helper struct to hold the declaration of the function pointer.\n    // Change it if the function signature changes.\n    template &lt;typename T&gt; struct ToString\n    {\n        typedef void (T::*fptr)();\n    };\n\n    template &lt;typename T&gt; static Yes HasToString(TypeCheck&lt; typename ToString&lt;T&gt;::fptr, &amp;T::toString &gt;*);\n    template &lt;typename T&gt; static No  HasToString(...);\n\npublic:\n    static bool const value = (sizeof(HasToString&lt;Type&gt;(0)) == sizeof(Yes));\n};\n</code></pre>\n<p>I checked it with gcc 4.1.2.\nThe credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)</p>\n", "LastEditorUserId": "102834", "LastActivityDate": "2010-09-02T13:39:24.480", "Score": "51", "CreationDate": "2010-09-02T12:50:43.803", "ParentId": "257288", "CommentCount": "2", "OwnerUserId": "102834", "LastEditDate": "2010-09-02T13:39:24.480"}, "31860104": {"Id": "31860104", "PostTypeId": "2", "Body": "<p>A simple solution for C++11:</p>\n<pre><code>template&lt;class T&gt;\nauto optionalToString(T* obj)\n -&gt; decltype(  obj-&gt;toString()  )\n{\n    return     obj-&gt;toString();\n}\nauto optionalToString(...) -&gt; string\n{\n    return \"toString not defined\";\n}\n</code></pre>\n", "LastActivityDate": "2015-08-06T15:41:05.200", "CommentCount": "2", "CreationDate": "2015-08-06T15:41:05.200", "ParentId": "257288", "Score": "20", "OwnerUserId": "146041"}, "257315": {"Body": "<p>This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:</p>\n<pre><code>template &lt;typename T&gt;\nstruct response_trait {\n    static bool const has_tostring = false;\n};\n\ntemplate &lt;&gt;\nstruct response_trait&lt;your_type_with_tostring&gt; {\n    static bool const has_tostring = true;\n}\n</code></pre>\n", "CreationDate": "2008-11-02T20:26:30.030", "ParentId": "257288", "CommentCount": "15", "LastEditDate": "2015-03-20T16:32:40.793", "PostTypeId": "2", "OwnerDisplayName": "Konrad Rudolph", "LastEditorUserId": "280314", "LastActivityDate": "2015-03-20T16:32:40.793", "Id": "257315", "Score": "27", "OwnerUserId": "1968"}});