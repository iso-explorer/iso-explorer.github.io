post_cb({"13638623": {"CommentCount": "0", "ViewCount": "129", "PostTypeId": "1", "LastEditorUserId": "882932", "CreationDate": "2012-11-30T03:34:51.573", "LastActivityDate": "2012-11-30T03:55:18.727", "Title": "Default vs Deduced template parameter?", "AcceptedAnswerId": "13638743", "LastEditDate": "2012-11-30T03:42:55.150", "Id": "13638623", "Score": "1", "Body": "<p>In the following :</p>\n<pre><code>template&lt;typename Type&gt;\nstruct MyClass\n{\n    template&lt;typename OtherType&gt; MyClass(const MyClass&lt;OtherType&gt;&amp; x);\n    template&lt;typename OtherType = Type&gt; void test(const MyClass&lt;OtherType&gt;&amp; x);\n};\n</code></pre>\n<hr>\n<p>In the function <code>test</code> what is done between :</p>\n<p><strong>Case 1 :</strong> The default parameter is priority : the conversion constructor <code>MyClass&lt;Type&gt;(const MyClass&lt;OtherType&gt;&amp; x)</code> is implicitely called and <code>MyClass&lt;Type&gt;::test&lt;Type&gt;(const MyClass&lt;Type&gt;&amp; x)</code> is called.</p>\n<p><strong>Case 2 :</strong> The deduced parameter is priority : <code>MyClass&lt;Type&gt;::test&lt;Type&gt;(const MyClass&lt;OtherType&gt;&amp; x)</code> is called.</p>\n<hr>\n<p>I think that the good answer is the second one, but I'm not sure. Can you confirm me that (and that this situation is well-defined by the standard) ?</p>\n<hr>\n<p>EDIT : The test function is called by :</p>\n<pre><code>MyClass&lt;double&gt; d;\nMyClass&lt;unsigned int&gt; ui;\nd.test(ui); // &lt;- So the question is : is ui implicitely \n            //    converted to MyClass&lt;double&gt; or not ?\n</code></pre>\n</hr></hr></hr>", "Tags": "<c++><templates><c++11><standards-compliance><templates-deduction>", "OwnerUserId": "882932", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13638623_13638743_0": {"section_id": 297, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_13638623_13638743_0": {"section_id": 288, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_13638623_13638743_0": {"section_id": 304, "quality": 0.8636363636363636, "length": 19}}}, "13638743": {"ParentId": "13638623", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>test</code> will be called as</p>\n<pre><code>MyClass&lt;double&gt;::test(const MyClass&lt;unsigned int&gt; &amp;)\n</code></pre>\n<p>i.e. there will be no conversion of <code>ui</code> from <code>MyClass&lt;unsigned int&gt;</code> to <code>MyClass&lt;double&gt;</code>.</p>\n<p>A default template argument never overrides a given one. It is only used when no template argument is given and the compiler can't deduce it from the function arguments.</p>\n<p>From the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_13638623_13638743_0\">(\u00a714.8.2/5) The resulting substituted and adjusted function type is used as the type of the function template for template argument deduction. If a template argument has not been deduced, its default template argument, if any, is used. [ Example:</p>\n<pre><code>template &lt;class T, class U = double&gt;\nvoid f(T t = 0, U u = 0);\nvoid g() {\n  f(1, \u2019c\u2019);      // f&lt;int,char&gt;(1,\u2019c\u2019)\n  f(1);           // f&lt;int,double&gt;(1,0)\n  f();            // error: T cannot be deduced\n  f&lt;int&gt;();       // f&lt;int,double&gt;(0,0)\n  f&lt;int,char&gt;();  // f&lt;int,char&gt;(0,0)\n}\n</code></pre>\n<p id=\"so_13638623_13638743_1\">\u2014 end example ]</p>\n</blockquote>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2012-11-30T03:55:18.727", "Id": "13638743", "Score": "2", "CreationDate": "2012-11-30T03:50:14.170", "LastActivityDate": "2012-11-30T03:55:18.727"}});