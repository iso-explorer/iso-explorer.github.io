post_cb({"18756169": {"Id": "18756169", "PostTypeId": "2", "Body": "<p>If we could assign one lambda to another lambda of a different type, how do we copy the function bodies/definitions from that lambda to the other one? If we would be so stubborn, then we could use some member <code>std::function</code>-like type to be the one who will be copied. But that would be against the ol' C++ rule of not paying blah blah...</p>\n", "LastActivityDate": "2013-09-12T05:40:26.957", "Score": "3", "CreationDate": "2013-09-12T05:40:26.957", "ParentId": "18755787", "CommentCount": "0", "OwnerUserId": "1619294"}, "18756007": {"Id": "18756007", "PostTypeId": "2", "Body": "<p>You seem to think that those two lambdas have the same type, but that is not true. Each one creates its own type:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\nint main() {\n  auto test = []{};\n  auto test2 = []{};\n  std::cout &lt;&lt; std::is_same&lt; decltype( test ), decltype( test2 ) &gt;::value &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>will print <code>0</code>. Of course the error message you are getting from the compiler could be a little bit clearer in this regards...</p>\n", "LastActivityDate": "2013-09-12T05:27:59.557", "Score": "63", "CreationDate": "2013-09-12T05:27:59.557", "ParentId": "18755787", "CommentCount": "7", "OwnerUserId": "2073257"}, "19695191": {"Id": "19695191", "PostTypeId": "2", "Body": "<p>The reason you are not able to do this is because the copy assignment operator for the lambda-expression is declared deleted, See section 5.1.2/20 of the standard.  For a more clear (for unusual definitions of clear) see this code sample</p>\n<pre><code>template&lt;class T&gt; void f(T x1)\n{\n  T x2 = x1; // copy constructor exists, this operation will succeed.\n  x2 = x1; // assignment operator, deleted and will cause an error\n}\nint main()\n{\n  f([]{});\n  return 0;\n}\n</code></pre>\n<p>Other answers have pointed out that each lambda has a unique type, but this is not the reason why you are getting that error.  This example shows that even if the two lambdas have the same type, it still is not able to copy it.  However you are able to copy it to a new variable.  This is the reason your error message is complaining about missing <code>operator=</code> and not about their types being different.  Although each lambda having it's own type does not help you out much either.</p>\n", "LastEditorUserId": "1273178", "LastActivityDate": "2014-01-03T03:08:30.093", "Score": "3", "CreationDate": "2013-10-30T22:40:38.880", "ParentId": "18755787", "CommentCount": "6", "LastEditDate": "2014-01-03T03:08:30.093", "OwnerUserId": "1273178"}, "bq_ids": {"n4140": {"so_18755787_18755787_1": {"length": 5, "quality": 1.0, "section_id": 5962}, "so_18755787_18755912_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 5962}, "so_18755787_18755787_0": {"length": 17, "quality": 1.0, "section_id": 5962}, "so_18755787_18755787_3": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_18755787_18755787_4": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_18755787_18755787_2": {"length": 6, "quality": 1.0, "section_id": 5962}}, "n3337": {"so_18755787_18755787_3": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_18755787_18755912_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 5731}, "so_18755787_18755787_0": {"length": 17, "quality": 1.0, "section_id": 5731}, "so_18755787_18755787_1": {"length": 5, "quality": 1.0, "section_id": 5731}, "so_18755787_18755787_4": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_18755787_18755787_2": {"length": 6, "quality": 1.0, "section_id": 5731}}, "n4659": {"so_18755787_18755787_3": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_18755787_18755912_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 7451}, "so_18755787_18755787_0": {"length": 17, "quality": 1.0, "section_id": 7452}, "so_18755787_18755787_1": {"length": 5, "quality": 1.0, "section_id": 7452}, "so_18755787_18755787_4": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_18755787_18755787_2": {"length": 6, "quality": 1.0, "section_id": 7452}}}, "18755787": {"ViewCount": "3553", "Body": "<p>Example:</p>\n<pre><code>#include &lt;functional&gt;\n\nint main() {\n  auto test = []{};\n  test = []{};\n\n  return 0;\n}\n</code></pre>\n<p>This emits the following error message in gcc 4.7.2:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:5:13: error: no match for \u2018operator=\u2019 in \u2018test = &lt;lambda closure object&gt;main()::&lt;lambda()&gt;{}\u2019\ntest.cpp:5:13: note: candidate is:\ntest.cpp:4:16: note: main()::&lt;lambda()&gt;&amp; main()::&lt;lambda()&gt;::operator=(const main()::&lt;lambda()&gt;&amp;) &lt;deleted&gt;\ntest.cpp:4:16: note:   no known conversion for argument 1 from \u2018main()::&lt;lambda()&gt;\u2019 to \u2018const main()::&lt;lambda()&gt;&amp;\u2019\n</code></pre>\n<p>From the standard 5.1.2.3 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18755787_18755787_0\">An implementation may define the closure type differently from what is described below provided this does not alter the observable behavior of the program other than by changing:</p>\n<p id=\"so_18755787_18755787_1\">\u2014 the size and/or alignment of the closure type,</p>\n<p id=\"so_18755787_18755787_2\">\u2014 whether the closure type is <strong>trivially copyable</strong> (Clause 9)</p>\n<p id=\"so_18755787_18755787_3\">\u2014 whether the closure type is a standard-layout class (Clause 9), or</p>\n<p id=\"so_18755787_18755787_4\">\u2014 whether the closure type is a POD class (Clause 9).</p>\n</blockquote>\n<p>As far as I can tell, this is what I'm running up against.  It's attempting to use a deleted assignment operator and failing. I am curious to know if there's an easy workaround, and more broadly what the motivating rationale for allowing copy constructibility to be omitted for lambdas generally.</p>\n", "AcceptedAnswerId": "18756007", "Title": "Redefining lambdas not allowed in C++11, why?", "CreationDate": "2013-09-12T05:10:08.767", "Id": "18755787", "CommentCount": "13", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-09-12T05:26:02.200", "LastEditorUserId": "483486", "LastActivityDate": "2014-01-03T03:08:30.093", "Score": "53", "OwnerUserId": "483486", "Tags": "<c++><c++11><lambda><language-lawyer>", "AnswerCount": "5"}, "18755990": {"Id": "18755990", "PostTypeId": "2", "Body": "<p>Lambda can't be redefined because each lambda is of a different, anonymous, incompatible type.\nThey can be copied only if you pass them to a templated function (like <code>std::function</code> ctor) that would be able to deduce that type.</p>\n", "LastActivityDate": "2013-09-12T05:26:52.060", "Score": "5", "CreationDate": "2013-09-12T05:26:52.060", "ParentId": "18755787", "CommentCount": "0", "OwnerUserId": "628361"}, "18755912": {"Id": "18755912", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18755787_18755912_0\">The type of the\n  lambda-expression\n  (which is also the type of the closure object) is a <strong>unique</strong>, unnamed non-\n  union class type </p>\n</blockquote>\n<p>So it is like you are doing the following:</p>\n<pre><code>struct {} a;\nstruct {} b;\na = b; // error, type mismatch\n</code></pre>\n<p>Use <code>std::function</code> if you want to assign different lambdas with the same signature to the same variable.</p>\n<pre><code>std::function&lt;void()&gt; f = []{};\nf = []{}; //ok\n</code></pre>\n", "LastEditorUserId": "1131467", "LastActivityDate": "2013-09-12T05:30:50.560", "Score": "39", "CreationDate": "2013-09-12T05:21:20.027", "ParentId": "18755787", "CommentCount": "5", "LastEditDate": "2013-09-12T05:30:50.560", "OwnerUserId": "1131467"}});