post_cb({"2027873": {"ViewCount": "895", "Body": "<p>I wrote the following program to test when the copy constructor is called and when the assignment operator is called:</p>\n<pre>\n<code>\n#include \n\nclass Test\n{\npublic:\n    Test() :\n        iItem (0)\n    {\n        std::cout &lt;&lt; \"This is the default ctor\" &lt;&lt; std::endl;\n    }\n\n    Test (const Test&amp; t) :\n        iItem (t.iItem)\n\n    {\n        std::cout &lt;&lt; \"This is the copy ctor\" &lt;&lt; std::endl;\n    }\n\n    ~Test()\n    {\n        std::cout &lt;&lt; \"This is the dtor\" &lt;&lt; std::endl;\n    }\n\n    const Test&amp; operator=(const Test&amp; t)\n    {\n        iItem = t.iItem;    \n        std::cout &lt;&lt; \"This is the assignment operator\" &lt;&lt; std::endl;\n        return *this;\n    }\n\nprivate:\n    int iItem;\n};\n\nint main()\n{\n    {\n        Test t1;\n        Test t2 = t1;\n    }\n    {\n        Test t1;\n        Test t2 (t1);\n    }\n    {\n        Test t1;\n        Test t2;\n        t2 = t1;\n    }\n}\n</code></pre>\n<p></p>\n<p>This results in the following output (just added empy lines to make it more understandable):</p>\n<pre>\ndoronw@DW01:~$ ./test\nThis is the default ctor\nThis is the copy ctor\nThis is the dtor\nThis is the dtor\n\nThis is the default ctor\nThis is the copy ctor\nThis is the dtor\nThis is the dtor\n\nThis is the default ctor\nThis is the default ctor\nThis is the assignment operator\nThis is the dtor\nThis is the dtor\n\n\n</pre>\n<p>The second and third set behave as expected, but in the first set the copy constructor is called even though the assignment operator is used. </p>\n<p>Is this behaviour part of the C++ standard or just a clever compiler optimization (I am using gcc 4.4.1)</p>\n", "AcceptedAnswerId": "2027914", "Title": "Copy constructors and Assignment Operators", "CreationDate": "2010-01-08T13:38:05.167", "Id": "2027873", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-01-08T13:47:24.623", "LastEditorUserId": "107009", "LastActivityDate": "2010-01-08T13:57:24.463", "Score": "3", "OwnerUserId": "232918", "Tags": "<c++><copy-constructor>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2027873_2027988_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 3294}, "so_2027873_2027988_1": {"length": 15, "quality": 0.6818181818181818, "section_id": 3295}}, "n3337": {"so_2027873_2027988_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 3164}, "so_2027873_2027988_1": {"length": 15, "quality": 0.6818181818181818, "section_id": 3165}}, "n4659": {"so_2027873_2027988_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 4056}}}, "2027914": {"Id": "2027914", "PostTypeId": "2", "Body": "<p>No assignment operator is used in the first test-case. It just uses the initialization form called \"copy initialization\".  Copy initialization does not consider explicit constructors when initializing the object. </p>\n<pre><code>struct A {\n  A();\n\n  // explicit copy constructor\n  explicit A(A const&amp;);\n\n  // explicit constructor\n  explicit A(int);\n\n  // non-explicit \"converting\" constructor\n  A(char const*c);\n};\n\nA a;\nA b = a; // fail\nA b1(a); // succeeds, \"direct initialization\"\n\nA c = 1; // fail, no converting constructor found\nA d(1); // succeeds\n\nA e = \"hello\"; // succeeds, converting constructor used\n</code></pre>\n<p>Copy initialization is used in those cases that correspond to implicit conversions, where one does not explicitly kick off a conversion, as in function argument passing, and returning from a function. </p>\n", "LastActivityDate": "2010-01-08T13:45:28.130", "CommentCount": "0", "CreationDate": "2010-01-08T13:45:28.130", "ParentId": "2027873", "Score": "10", "OwnerUserId": "34509"}, "2027988": {"Id": "2027988", "PostTypeId": "2", "Body": "<p>C++ standard 8.5/12</p>\n<blockquote>\n<p id=\"so_2027873_2027988_0\">The initialization that occurs in\n  argument passing, function return,\n  throwing an exception (15.1), handling\n  an exception (15.3), and\n  brace-enclosed initializer lists\n  (8.5.1) is called copy-initialization\n  and is equivalent to the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_2027873_2027988_1\">The initialization that occurs in new\n  expressions (5.3.4), static_cast\n  expressions (5.2.9), functional\n  notation type conversions (5.2.3), and\n  base and member initializers (12.6.2)\n  is called direct-initialization and is\n  equivalent to the form</p>\n<pre><code>T x(a);\n</code></pre>\n</blockquote>\n", "LastActivityDate": "2010-01-08T13:57:24.463", "CommentCount": "0", "CreationDate": "2010-01-08T13:57:24.463", "ParentId": "2027873", "Score": "3", "OwnerUserId": "125672"}, "2027937": {"Id": "2027937", "PostTypeId": "2", "Body": "<p>Your first set is according to the C++ standard, and not due to some optimization.</p>\n<p>Section 12.8 (<code>[class.copy]</code>) of the <a href=\"http://www.iso.org/iso/catalogue_detail.htm?csnumber=25845\" rel=\"nofollow noreferrer\">C++ standard</a> gives a similar example:</p>\n<pre><code>class X {\n    // ...\npublic:\n    X(int);\n    X(const X&amp;, int = 1);\n};\n\nX a(1);     // calls X(int);\nX b(a, 0);  // calls X(const X&amp;, int);\nX c = b;    // calls X(const X&amp;, int);\n</code></pre>\n<p>The last line would be the one matching your case.</p>\n", "LastActivityDate": "2010-01-08T13:50:26.020", "CommentCount": "0", "CreationDate": "2010-01-08T13:50:26.020", "ParentId": "2027873", "Score": "2", "OwnerUserId": "240733"}});