post_cb({"bq_ids": {"n4140": {"so_44679200_44679576_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5936}, "so_44679200_44679200_0": {"length": 23, "quality": 0.92, "section_id": 3}, "so_44679200_44679200_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 6072}, "so_44679200_44679576_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 584}, "so_44679200_44679576_2": {"length": 7, "quality": 1.0, "section_id": 697}}, "n3337": {"so_44679200_44679200_0": {"length": 23, "quality": 0.92, "section_id": 2}, "so_44679200_44679576_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5708}, "so_44679200_44679200_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 5840}, "so_44679200_44679576_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 574}, "so_44679200_44679576_2": {"length": 7, "quality": 1.0, "section_id": 687}}, "n4659": {"so_44679200_44679200_0": {"length": 23, "quality": 0.92, "section_id": 3}, "so_44679200_44679576_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7420}, "so_44679200_44679200_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 7568}, "so_44679200_44679576_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 607}, "so_44679200_44679576_2": {"length": 7, "quality": 1.0, "section_id": 726}}}, "44679576": {"Id": "44679576", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/expr#3.sentence-1\" rel=\"nofollow noreferrer\">[expr]</a> as a whole applies to built-in operators:</p>\n<blockquote>\n<p id=\"so_44679200_44679576_0\">Clause [expr] defines the effects of operators when applied to types for which they have not been overloaded. </p>\n</blockquote>\n<p>The definition in [expr.unary.op] is simply the definition of the <em>built-in</em> <code>operator!</code>. Additionally, <a href=\"http://eel.is/c++draft/over.match.oper#3\" rel=\"nofollow noreferrer\">[over.match.oper]</a> describes how to look up overloaded operators:</p>\n<blockquote>\n<p id=\"so_44679200_44679576_1\">For a unary operator @ with an operand of a type whose cv-unqualified version is T1, [...], three sets of candidate functions, designated member candidates, non-member candidates and built-in candidates, are constructed as follows: [...]</p>\n</blockquote>\n<p>For <code>!a</code>, you'd have two candidates: your overload <code>A::operator!()</code> and the built-in defined in <a href=\"http://eel.is/c++draft/over.built#24\" rel=\"nofollow noreferrer\">[over.built]</a>:</p>\n<blockquote>\n<p id=\"so_44679200_44679576_2\">There also exist candidate operator functions of the form</p>\n<pre><code>bool operator!(bool);\n</code></pre>\n</blockquote>\n<p>For the built-in to be selected by overload resolution, the type would have to be contextually converted to <code>bool</code><sup>\u2020</sup> as your argument suggests. However, this candidate is not viable - but the overloaded member operator is. </p>\n<hr/>\n<p><sup>\u2020</sup><a href=\"https://stackoverflow.com/questions/44679200/expr-unary-op-9-seems-to-imply-that-the-operator-could-not-be-applied-to/44679576?noredirect=1#comment76347693_44679576\">T.C.</a> is on top of it as usual, pointing out <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1919\" rel=\"nofollow noreferrer\">cwg issue 1919</a> which indicates that a type that <em>is</em> contextually convertible to <code>bool</code> still shouldn't use the builtin <code>operator!</code> due to a wording issue. Although, both gcc and clang permit it (which is what we all want to happen, probably).</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-06-21T16:45:13.950", "Score": "7", "CreationDate": "2017-06-21T14:55:02.033", "ParentId": "44679200", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2017-06-21T16:45:13.950"}, "44679200": {"ViewCount": "215", "Body": "<p><a href=\"http://eel.is/c++draft/conv#4\" rel=\"noreferrer\">[conv]/4</a>:</p>\n<blockquote>\n<p id=\"so_44679200_44679200_0\">Certain language constructs require that an expression be converted to\n  a Boolean value. An expression <code>e</code> appearing in such a context is said\n  to be <em>contextually converted to <code>bool</code></em> and is well-formed if and\n  only if the declaration <code>bool t(e);</code> is well-formed, for some invented\n  temporary variable <code>t</code> (11.6).</p>\n</blockquote>\n<p>Consider now the snippet below. It doesn't compile, neither in <a href=\"http://coliru.stacked-crooked.com/a/866ba3623fba4dc8\" rel=\"noreferrer\">clang</a>, <a href=\"http://coliru.stacked-crooked.com/a/049a411350ef8cd6\" rel=\"noreferrer\">GCC</a> or <a href=\"http://rextester.com/WMHEMU15817\" rel=\"noreferrer\">VS</a>.</p>\n<pre><code>struct A{ bool operator!() { return true; } };\nint main(){\n    A a;\n    bool t(a);\n}\n</code></pre>\n<p>Thus, from [conv]/4 we conclude that the type <code>A</code> is <strong>not</strong> contextually converted to <code>bool</code>.</p>\n<p><a href=\"http://eel.is/c++draft/expr.unary.op#9\" rel=\"noreferrer\">[expr.unary.op]/9</a>:</p>\n<blockquote>\n<p id=\"so_44679200_44679200_1\">The operand of the logical negation operator <code>!</code> is contextually\n  converted to <code>bool</code> (Clause 7); its value is <code>true</code> if the converted\n  operand is <code>false</code> and <code>false</code> otherwise. The type of the result is\n  <code>bool</code>.</p>\n</blockquote>\n<p>My understanding of the paragraph above is that the operand of the logical negation operator <code>!</code> must be contextually converted to <code>bool</code>. We have just concluded that the type <code>A</code> is <strong>not</strong> contextually converted to <code>bool</code>. Therefore, from [expr.unary.op]/9, we can say that the following code should <strong>not</strong> compile. But it does, in <a href=\"http://coliru.stacked-crooked.com/a/7ea19016164fa08b\" rel=\"noreferrer\">clang</a>, <a href=\"http://coliru.stacked-crooked.com/a/8900f6d1a76aac88\" rel=\"noreferrer\">GCC</a> and <a href=\"http://rextester.com/YUX54013\" rel=\"noreferrer\">VS</a>.</p>\n<pre><code>struct A{ bool operator!() { return true; } };\nint main(){\n    A a;\n    bool t = !a;\n}\n</code></pre>\n<p>What am I missing?</p>\n", "AcceptedAnswerId": "44679576", "Title": "[expr.unary.op]/9 seems to imply that the `operator !()` could not be applied to the type A below. But compilers disagree with that", "CreationDate": "2017-06-21T14:39:11.473", "Id": "44679200", "CommentCount": "7", "LastEditDate": "2017-06-21T14:44:17.267", "PostTypeId": "1", "LastEditorUserId": "1042389", "LastActivityDate": "2017-06-21T16:45:13.950", "Score": "7", "OwnerUserId": "1042389", "Tags": "<c++><language-lawyer><c++1z><unary-operator>", "AnswerCount": "1"}});