post_cb({"45839129": {"CommentCount": "9", "ViewCount": "117", "PostTypeId": "1", "LastEditorUserId": "8157187", "CreationDate": "2017-08-23T11:59:47.253", "LastActivityDate": "2017-08-23T13:35:11.537", "Title": "Are underlying bytes of an object allowed to change, if the value is not changed?", "LastEditDate": "2017-08-23T12:23:36.210", "Id": "45839129", "Score": "4", "Body": "<p>Are underlying bytes of an object allowed to change, if the value itself is not changed?</p>\n<p>So, for example, can this code-snippet print \"differ\"?</p>\n<pre><code>int a = 0;\nchar b[sizeof(int)];\n\nmemcpy(b, &amp;a, sizeof(int));\nif (memcmp(b, &amp;a, sizeof(int)) {\n    printf(\"differ\\n\");\n}\n</code></pre>\n<p>Here's the question that made me to ask this: <a href=\"https://stackoverflow.com/questions/45149756/is-delete-allowed-to-modify-its-parameter\">Is delete allowed to modify its parameter?</a>, check out the comments below the question, for example, this <a href=\"https://stackoverflow.com/questions/45149756/is-delete-allowed-to-modify-its-parameter#comment78507451_45149756\">comment</a> from Johannes Schaub:</p>\n<blockquote>\n<p id=\"so_45839129_45839129_0\">What rule forbids changing the internal bits of an int? As far as I\n  know, the implementation is even allowed to make int a = 0; /* test\n  bits of 'a' now <em>/; /</em> test bits of 'a' now*/ have two different bits\n  each time</p>\n</blockquote>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "8157187", "AnswerCount": "1"}, "45839230": {"ParentId": "45839129", "PostTypeId": "2", "CommentCount": "17", "CreationDate": "2017-08-23T12:05:12.553", "Score": "3", "LastEditorUserId": "14860", "LastEditDate": "2017-08-23T13:35:11.537", "Id": "45839230", "OwnerUserId": "14860", "Body": "<p>Generally, <code>memcpy</code> and <code>memcmp</code> work strictly on bytes so they cannot differ.</p>\n<p>One reading of the (C++11) standard seems to indicate it <em>may</em> be possible for an <code>int</code> to differ from another (according to <code>memcmp</code>) that you've just assigned it from, if integers are allowed to have padding bytes which have no effect on the value.</p>\n<p>It would seem to be feasible as per your code with an <code>int</code> and similarly-sized <code>char</code> buffer:</p>\n<pre><code>int a = 0;\nchar b[sizeof(int)];\nmemcpy(b, &amp;a, sizeof(int));\n</code></pre>\n<p>for the padding bytes (if any) in <code>a</code> to change in such a way that the underlying value does not change. That <em>could</em> cause a <code>memcmp</code> to fail.</p>\n<p>That particular reading can be found in <code>C++11 3.9.1 Fundamental types</code>:</p>\n<blockquote>\n<p id=\"so_45839129_45839230_0\">For character types, all bits of the object representation participate\n  in the value representation. For unsigned character types, all possible bit patterns of the value representation represent numbers. <em>These requirements do not hold for other types.</em></p>\n</blockquote>\n<p>That allows for the possibility of padding bits within non-character types and there's nothing in the standard explicitly preventing those bits from changing at any time.</p>\n<p>However, in that same section, it lumps the character and signed or unsigned integers into a \"integral type\" category and states that the:</p>\n<blockquote>\n<p id=\"so_45839129_45839230_1\">representations of integral types shall define values by use of a pure binary numeration system. (footnote 49) [Example: this International Standard permits 2\u2019s complement, 1\u2019s complement and signed magnitude representations for integral types. \u2014end example ]</p>\n</blockquote>\n<p>Footnote 49 state:</p>\n<blockquote>\n<p id=\"so_45839129_45839230_2\">A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position. (Adapted from the American National Dictionary for Information Processing Systems.)</p>\n</blockquote>\n<p>That doesn't seem to leave the possibility open for padding bits in these types at all, because it very specifically calls out <em>successive</em> bits and powers of two, with the only exception specifically mentioned being the high bit (used for deciding sign for the three possible encodings) <sup>(a)</sup>.</p>\n<p>So I suspect that <code>memcmp</code> will not be able to fail immediately following a <code>memcpy</code> using the same memory blocks and size.</p>\n<p>That's totally irrelevant in the question you link to, of course, since there's an intervening operation, <code>delete</code>, which is free to change the underlying bit pattern. That situation is no different to:</p>\n<pre><code>int a = 0;\nchar b[sizeof(int)];\nmemcpy(b, &amp;a, sizeof(int));\na = 42; // intervening operation\n</code></pre>\n<p>after which a <code>memcmp</code> would be pretty much <em>guaranteed</em> to consider the two memory blocks as different.</p>\n<hr>\n<p><sup>(a)</sup> Annoyingly, there is <em>one</em> potential reading allowing for padding bits while still satisfying the \"successive\" bits and powers-of-two mentioned above - that's if the padding bits are at the low end of the underlying bit pattern (furthest from the sign). If <em>that</em> were allowed then, yes, <code>memcmp</code> immediately after <code>memcpy</code> could report a difference.</p>\n</hr>", "LastActivityDate": "2017-08-23T13:35:11.537"}, "bq_ids": {"n4140": {"so_45839129_45839230_0": {"section_id": 7210, "quality": 0.8888888888888888, "length": 24}, "so_45839129_45839230_2": {"section_id": 7216, "quality": 0.9642857142857143, "length": 27}, "so_45839129_45839230_1": {"section_id": 7216, "quality": 0.7916666666666666, "length": 19}}, "n3337": {"so_45839129_45839230_0": {"section_id": 6954, "quality": 0.8888888888888888, "length": 24}, "so_45839129_45839230_1": {"section_id": 6960, "quality": 0.7916666666666666, "length": 19}, "so_45839129_45839230_2": {"section_id": 6960, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_45839129_45839230_0": {"section_id": 8719, "quality": 0.7407407407407407, "length": 20}, "so_45839129_45839230_2": {"section_id": 8725, "quality": 0.9642857142857143, "length": 27}, "so_45839129_45839230_1": {"section_id": 8725, "quality": 0.7916666666666666, "length": 19}}}});