post_cb({"11363781": {"ParentId": "11363737", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>C++11's enum classes are the solution for this:</p>\n<pre><code>namespace Test\n{\n    enum class EName\n    {\n        CoolEnum,\n        NiceEnum\n    };\n\n    enum class CoolEnum\n    {\n        NiceVal1,\n        NiceVal2\n    };\n\n    enum class NiceEnum\n    {\n        NiceVal1,\n        NiceVal2\n    };\n}\n</code></pre>\n<p>Then you can use the appropiate <code>NiceVal1</code>:</p>\n<pre><code>Test::CoolEnum cEnum = Test::CoolEnum::NiceVal1;\n</code></pre>\n<p>Plain enums were inherited from C, where there is no notion of what a namespace is. If plain enums introduced some kind of namespace, C code which uses enums would not compile at all. That's why enum classes were introduced, in order not to break backward compatibility.</p>\n", "OwnerUserId": "525217", "LastEditorUserId": "525217", "LastEditDate": "2012-07-06T14:11:07.483", "Id": "11363781", "Score": "7", "CreationDate": "2012-07-06T14:05:05.347", "LastActivityDate": "2012-07-06T14:11:07.483"}, "bq_ids": {"n4140": {"so_11363737_11364760_0": {"section_id": 7079, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_11363737_11364760_0": {"section_id": 6823, "quality": 0.9142857142857143, "length": 32}}, "n4659": {"so_11363737_11364760_0": {"section_id": 8580, "quality": 0.9142857142857143, "length": 32}}}, "11364760": {"ParentId": "11363737", "CommentCount": "1", "Body": "<p>The answer is because the standard dictates this behavior. See 3.3.7/2:</p>\n<blockquote>\n<p id=\"so_11363737_11364760_0\">A class name (9.1) or enumeration name (7.2) can be hidden by the name\n  of an object, function, or enumerator declared in the same scope. If a\n  class or enumeration name and an object, function, or enumerator are\n  declared in the same scope (in any order) with the same name, the\n  class or enumeration name is hidden wherever the object, function, or\n  enumerator name is visible.</p>\n</blockquote>\n<p>Presumably this is to facilitate compatibility with C's mechanism (where an enumerator doesn't open a new scope) which has been established for a long time.</p>\n<p>In your case, at least with g++ you can use <code>typename</code> to indicate you want to use the type instead of the enumerator (<code>typename Test::CoolEnum cEnum = Test::NiceVal1;</code>).</p>\n<p>In general however I like to scope all enumerations in a separate namespace or class to prevent these collisions completely.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "11364760", "Score": "1", "CreationDate": "2012-07-06T15:02:56.763", "LastActivityDate": "2012-07-06T15:02:56.763"}, "11363737": {"CommentCount": "3", "ViewCount": "2504", "PostTypeId": "1", "LastEditorUserId": "223880", "CreationDate": "2012-07-06T14:02:26.567", "LastActivityDate": "2013-03-07T07:55:19.797", "Title": "Enum value collision with enum name", "AcceptedAnswerId": "11363781", "LastEditDate": "2012-07-07T00:23:19.267", "Id": "11363737", "Score": "6", "Body": "<p>Let's take a code construction that I've recently found somewhere in project:</p>\n<pre><code>namespace Test\n{\n    enum EName\n    {\n        CoolEnum,\n        NiceEnum\n    };\n\n    enum CoolEnum\n    {\n        CoolVal1,\n        CoolVal2\n    };\n\n    enum NiceEnum\n    {\n        NiceVal1,\n        NiceVal2\n    };\n}\n</code></pre>\n<p>My question is why the compiler allows something like this. Let's take a code sample here:</p>\n<pre><code>Test::CoolEnum cEnum = Test::NiceVal1; // INVALID, as compiler refers to Test::CoolEnum value of Test::Ename enum\n</code></pre>\n<p>Why is such confusion allowed? I understand why I have to prepend enum keyword, so the compiler clearly knows that I'm declaring a variable of given enum, not using value of other enum in the same namespace. I just don't understand why in the first place it's even possible to make such a construction.</p>\n", "Tags": "<c++><gcc><enums>", "OwnerUserId": "223880", "AnswerCount": "2"}});