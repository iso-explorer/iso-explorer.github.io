post_cb({"16197316": {"ParentId": "16195273", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>A definition of a function required if you take its address (within an evaluated context).</p>\n<p>Of course the definition can be given in a separate translation unit, but that doesn't change the fact that a definition is needed.</p>\n<p>If only one member function is needed, that does not imply that other member functions are instantiated as well.</p>\n<p>If the function template is undefined, it cannot be implicitly instantiated. It must then be explicitly instantiated in another translation unit. Relying on an implicit instantiation in another translation unit is disallowed (but no diagnostic is required).</p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2013-04-24T16:45:29.670", "Id": "16197316", "Score": "6", "CreationDate": "2013-04-24T16:28:03.167", "LastActivityDate": "2013-04-24T16:45:29.670"}, "16195508": {"ParentId": "16195273", "CommentCount": "1", "Body": "<p>The instantiation needs to occur, because the expansion of the template might not result in wellformed code.</p>\n<p>In fact, the instantiation might not even result in a valid prototype (this failure would qualify as 'not a failure').</p>\n<p>(When SFINAE is involved the effective address taken might disregard several earlier candidates in the partial ordering (because Substitution Failure Is Not An Error), before the actual candidate is selected to take the address of.)</p>\n", "OwnerUserId": "85371", "PostTypeId": "2", "Id": "16195508", "Score": "0", "CreationDate": "2013-04-24T15:05:13.220", "LastActivityDate": "2013-04-24T15:05:13.220"}, "16195273": {"CommentCount": "3", "ViewCount": "529", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-24T14:56:32.710", "LastActivityDate": "2013-04-24T16:45:29.670", "Title": "Implicit instantiation of function templates when taking their address", "AcceptedAnswerId": "16197316", "LastEditDate": "2017-05-23T12:32:55.277", "Id": "16195273", "Score": "7", "Body": "<p>Note: I've already looked <a href=\"https://stackoverflow.com/questions/6735720/what-are-the-rules-around-instantiation-of-template-types-class-function-when\">here</a> and I don't think the answer is right.</p>\n<p>What are the rules governing the implicit instantiation of functions when taking their address?  14.7.1/9 of n3242 says this:</p>\n<blockquote>\n<p id=\"so_16195273_16195273_0\">An implementation shall not implicitly instantiate a function template, a member template, a non-virtual member function, a member class, or a static data member of a class template that does not require instantiation.</p>\n</blockquote>\n<p>Now, it's certainly not required to have a function definition in order to take its address. We can take the address of forward-declared functions and have them defined in a different translation unit.</p>\n<p>That being the case, I don't know when it would be required. Yet, compilers seem to have their own idea. Testing on GCC and VC, here are a few examples:</p>\n<pre><code>template &lt;typename T&gt; void CallBanana() { T::Banana(); }\ntemplate &lt;typename T&gt; void CallUnimpl();\n\ntemplate &lt;typename T&gt;\nstruct S {\n    static void CallBanana() { T::Banana(); }\n    static void CallOrange() { T::Orange(); }\n    static void CallUnimpl();\n};\n\nstruct B { static void Banana() {} };\n\nint main() {\n    (void)(&amp;CallBanana&lt;void&gt;); // 1\n    (void)(&amp;CallUnimpl&lt;void&gt;); // 2\n    (void)(&amp;S&lt;void&gt;::CallBanana); // 3\n    (void)(&amp;S&lt;void&gt;::CallOrange); // 4\n    (void)(&amp;S&lt;void&gt;::CallUnimpl); // 5\n    (void)(&amp;S&lt;B&gt;::CallBanana); // 6\n}\n</code></pre>\n<p>These should be commented-in one at a time to see the effects.</p>\n<p>GCC 4.7 <a href=\"http://ideone.com/rCy47p\" rel=\"nofollow noreferrer\">tested here</a> will complain about 1, 3, and 4.  So it is instantiating all definitions if they exist.</p>\n<p>VC 2010 (no online test, sorry) instantiates 3 and 4, yet doesn't instantiate 1.</p>\n<p>Clang 3.0 <a href=\"http://tinyurl.com/cwjzdls\" rel=\"nofollow noreferrer\">tested here</a> has the same behaviour as VC 2010.</p>\n<p>No compiler complains about 2 or 5, which I would expect. I would expect it to fail to link if I actually used those pointers though.</p>\n<p>On all compilers, 6 compiles.  I expect this, but it is intended to show that the whole class template isn't instantiated (as claimed in the answer to that other question) just because I take the address of a single function.  If the whole template was instantiated, then S::CallOrange shouldn't compile, because B doesn't contain an Orange function.</p>\n<p>So I'm wondering if anyone has a definitive answer as to what the correct behaviour should be.  The standard seems to claim that no functions should be instantiated, yet three popular compilers instantiate in some cases, but differ from each other too.</p>\n", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "692677", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16195273_16195273_0": {"section_id": 243, "quality": 1.0, "length": 20}}, "n3337": {"so_16195273_16195273_0": {"section_id": 235, "quality": 1.0, "length": 20}}, "n4659": {"so_16195273_16195273_0": {"section_id": 250, "quality": 0.9, "length": 18}}}});