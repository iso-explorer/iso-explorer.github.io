post_cb({"10724143": {"Id": "10724143", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10723892_10724143_0\">How you'd initialise a variable within a scope with the value of an identically named variable in the containing scope without using a temporary or global variable?</p>\n</blockquote>\n<p>Unless the outer scope can be explicitly named you cannot do this. You can explicitly name the global scope, namespace scopes, and class scopes, but not function or block statement scopes.</p>\n<hr>\n<p>C++11 [basic.scope.pdecl 3.3.2 p1 states:</p>\n<blockquote>\n<p id=\"so_10723892_10724143_1\">The <em>point of declaration</em> for a name is immediately after its complete declarator (Clause 8) and before its <em>initializer</em> (if any), except as noted below. [ <em>Example:</em></p>\n<pre><code>int x = 12;\n{ int x = x; }\n</code></pre>\n<p id=\"so_10723892_10724143_2\"><em>Here the second x is initialized with its own (indeterminate) value. \u2014end example</em> ]</p>\n</blockquote>\n<p>MSVC correctly implements this example, however it does not correctly implement this when the initializer uses parentheses instead of assignment syntax. There's <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/695909/c-parser-places-point-of-declaration-incorrectly-for-some-initialization-syntaxes#details\" rel=\"nofollow\">a bug</a> filed about this on microsoft connect.</p>\n<p>Here's an example program with incorrect behavior in VS as a result of this bug.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo(char) { return 0; }\nint foo(int) { return 1; } \n\nint main()\n{\n    char x = 'a';\n    {\n        int x = foo(static_cast&lt;decltype(x)&gt;(0));\n        std::cout &lt;&lt; \"'=' initialization has correct behavior? \" &lt;&lt; (x?\"Yes\":\"No\") &lt;&lt; \".\\n\";\n    }\n    {\n        int x(foo(static_cast&lt;decltype(x)&gt;(0)));\n        std::cout &lt;&lt; \"'()' initialization has correct behavior? \" &lt;&lt; (x?\"Yes\":\"No\") &lt;&lt; \".\\n\";\n    }\n}\n</code></pre>\n<p>C++ includes the following note.</p>\n<blockquote>\n<p id=\"so_10723892_10724143_3\">[ <em>Note: Operations involving indeterminate values may cause undefined behavior. \u2014end note</em> ]</p>\n</blockquote>\n<p>However, this note indicates that operations <em>may</em> cause undefined behavior, not that they necessarily <em>do</em>. The above linked bug report includes an acknowledgement from Microsoft that this is a bug and not that the program triggers undefined behavior.</p>\n<p><strong>Edit:</strong> And now I've changed the example so that the object with indeterminate value is only 'used' in an unevaluated context, and I believe that this absolutely rules out the possibility of undefined behavior on any platform, while still demonstrating the bug in Visual Studio.</p>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2012-05-29T17:06:51.310", "Score": "10", "CreationDate": "2012-05-23T16:28:34.647", "ParentId": "10723892", "CommentCount": "3", "OwnerUserId": "365496", "LastEditDate": "2012-05-29T17:06:51.310"}, "10723892": {"ViewCount": "1805", "Body": "<p>Out of curiosity, I've tried this code, resulting from an interview question[*]</p>\n<pre><code>int main(int argc, char *argv[])\n{\n    int a = 1234;\n    printf(\"Outer: %d\\n\", a);\n    {\n        int a(a);\n        printf(\"Inner: %d\\n\", a);\n    }\n}\n</code></pre>\n<p>When compiled on Linux (both g++ 4.6.3 and clang++ 3.0) it outputs:</p>\n<pre><code>Outer: 1234\nInner: -1217375632\n</code></pre>\n<p>However on Windows (VS2010) it prints:</p>\n<pre><code>Outer: 1234\nInner: 1234\n</code></pre>\n<p>The rationale would be that, until the copy-constructor of the second 'a' variable has finished, the first 'a' variable is still accessible. However I'm not sure if this is standard behaviour, or just a(nother) Microsoft quirk.</p>\n<p>Any idea?</p>\n<p>[*] The actual question was:</p>\n<blockquote>\n<p id=\"so_10723892_10723892_0\">How you'd initialise a variable within a scope with the value of an identically named variable in the containing scope without using a temporary or global variable?</p>\n</blockquote>\n<pre><code>{\n    // Not at global scope here\n    int a = 1234;\n    {\n        int a;\n        // how do you set this a to the value of the containing scope a ?\n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "10734635", "Title": "Hiding name of int variable in c++", "CreationDate": "2012-05-23T16:11:20.433", "Id": "10723892", "CommentCount": "9", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-05-23T16:25:58.367", "LastEditorUserId": "253949", "LastActivityDate": "2012-05-29T17:06:51.310", "Score": "7", "OwnerUserId": "253949", "Tags": "<c++><scope><standards><copy-constructor>", "AnswerCount": "5"}, "10724431": {"Id": "10724431", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10723892_10724431_0\">How you'd initialise a variable within a scope with the value of an identically named variable in the containing scope without using a temporary or global variable?</p>\n</blockquote>\n<p>You can't.  As soon as the identical name is declared, the outer name is inaccessible for the rest of the scope.  You'd need a copy or an alias of the outer variable, which means you'd need a temporary variable.</p>\n<p>I'm surprised that, even with the warning level cranked up, VC++ doesn't complain on this line:</p>\n<pre><code>int a(a);\n</code></pre>\n<p>Visual C++ will sometimes warn you about hiding a variable (maybe that's only for members of derived classes).  It's also usually pretty good about telling you you're using a value before it has been initialized, which is the case here.</p>\n<p>Looking at the code generated, it happens to initialize the inner a to the same value of the outer a because that's what's left behind in a register.</p>\n", "LastActivityDate": "2012-05-23T16:49:29.033", "CommentCount": "0", "CreationDate": "2012-05-23T16:49:29.033", "ParentId": "10723892", "Score": "1", "OwnerUserId": "1386054"}, "bq_ids": {"n4140": {"so_10723892_10734635_5": {"length": 7, "quality": 0.7777777777777778, "section_id": 7050}, "so_10723892_10724143_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 7049}, "so_10723892_10724143_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 6283}, "so_10723892_10724143_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7049}, "so_10723892_10734635_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 7033}, "so_10723892_10734635_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 7049}}, "n3337": {"so_10723892_10734635_5": {"length": 7, "quality": 0.7777777777777778, "section_id": 6795}, "so_10723892_10724143_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6794}, "so_10723892_10724143_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 6043}, "so_10723892_10724143_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 6794}, "so_10723892_10734635_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 6779}, "so_10723892_10734635_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 6794}}, "n4659": {"so_10723892_10734635_5": {"length": 7, "quality": 0.7777777777777778, "section_id": 8547}, "so_10723892_10724143_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 8546}, "so_10723892_10724143_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 7790}, "so_10723892_10724143_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 8546}, "so_10723892_10734635_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 8530}, "so_10723892_10734635_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 8546}}}, "10725174": {"Id": "10725174", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10723892_10725174_0\">How you'd initialise a variable within a scope with the value of an identically named variable in the containing scope without using a temporary or global variable?</p>\n</blockquote>\n<p>If you want to get technical about the wording, it's pretty easy. A \"temporary\" has a specific meaning in C++ (see \u00a712.2); any named variable you create is not a temporary. As such, you can just create a local variable (which is <em>not</em> a temporary) initialized with the correct value:</p>\n<pre><code>int a = 1234;\n{ \n   int b = a;\n   int a = b;\n}\n</code></pre>\n<p>An even more defensible possibility would be to use a reference to the variable in the outer scope:</p>\n<pre><code>int a = 1234;\n{ \n    int &amp;ref_a = a;\n    int a = ref_a;\n}\n</code></pre>\n<p>This doesn't create an extra variable at all -- it just creates an alias to the variable at the outer scope. Since the alias has a different name, we retain access to the variable at the outer scope, without defining a variable (temporary or otherwise) to do so. Many references are implemented as pointers internally, but in this case (at least with a modern compiler and optimization turned on) I'd expect it not to be -- that the alias really would just be treated as a different name referring to the variable at the outer scope (and a quick test with VC++ shows that it works this way -- the generated assembly language doesn't use <code>ref_a</code> at all).</p>\n<p>Another possibility along the same lines would be like this:</p>\n<pre><code>const int a = 10;\n{ \n    enum { a_val = a };\n    int a = a_val;\n}\n</code></pre>\n<p>This is somewhat similar to the reference, except that in this case there's not even room for argument about whether <code>a_val</code> could be called a variable -- it absolutely is <em>not</em> a variable. The problem is that an enumeration can only be initialized with a constant expression, so we have to define the outer variable as <code>const</code> for it to work.</p>\n<p>I doubt any of these is what the interviewer really intended, but all of them answer the question as stated. The first is (admittedly) a pure technicality about definitions of terms. The second might still be open to some argument (many people think of references as variables). Though it restricts the scope, there's no room for question or argument about the third.</p>\n", "LastActivityDate": "2012-05-23T17:44:38.760", "CommentCount": "5", "CreationDate": "2012-05-23T17:44:38.760", "ParentId": "10723892", "Score": "6", "OwnerUserId": "179910"}, "10734635": {"Id": "10734635", "PostTypeId": "2", "Body": "<p>I had a look at the standard, it's actually a grey area but here's my 2 cents...</p>\n<blockquote>\n<p id=\"so_10723892_10734635_0\">3.1 Declarations and de\ufb01nitions [basic.def]</p>\n<ol>\n<li><p id=\"so_10723892_10734635_1\">A declaration introduces names into a translation unit or redeclares names introduced by previous declarations.</p></li>\n<li><p id=\"so_10723892_10734635_2\">A declaration is a de\ufb01nition unless... [non relevant cases follow]</p></li>\n</ol>\n<p id=\"so_10723892_10734635_3\">3.3.1 Point of declaration</p>\n<ol>\n<li><p id=\"so_10723892_10734635_4\">The point of declaration for a name is immediately after its complete declarator and before its initializer (if any), except as noted below [self-assignment example].</p></li>\n<li><p id=\"so_10723892_10734635_5\">A nonlocal name remains visible up to the point of declaration of the local name that hides it.</p></li>\n</ol>\n</blockquote>\n<p>Now, if we assume that this is the point of declaration of the inner 'a' (3.3.1/1)</p>\n<pre><code>int a (a);\n     ^\n</code></pre>\n<p>then the outer 'a' should be visible up to that point (3.3.1/2), where the inner 'a' is defined.</p>\n<p>Problem is that in this case, according to 3.1/2, a declaration IS a definition. This means the inner 'a' should be created. Until then, I can't understand from the standard whether the outer 'a' is still visible or not. VS2010 assumes that it is, and all that falls within the parentheses refers to the outer scope. However clang++ and g++ treat that line as a case of self-assignment, which results in undefined behaviour.</p>\n<p>I'm not sure which approach is correct, but I find VS2010 to be more consistent: the outer scope is still visible until the inner 'a' is fully created.</p>\n", "LastEditorUserId": "253949", "LastActivityDate": "2012-05-24T10:43:32.263", "Score": "0", "CreationDate": "2012-05-24T09:24:12.707", "ParentId": "10723892", "CommentCount": "1", "OwnerUserId": "253949", "LastEditDate": "2012-05-24T10:43:32.263"}, "10723931": {"Id": "10723931", "PostTypeId": "2", "Body": "<p>What you are doing, initializing a variable with itself, is undefined behavior. All your test cases got it right, this is not a quirk. An implementation could also initialize <code>a</code> to <code>123456789</code> and it would still be standard.</p>\n<p><strong>Update:</strong> The comments on this answer point that initializing a variable with itself is not undefined behavior, but trying to read such variable is.</p>\n", "LastEditorUserId": "927034", "LastActivityDate": "2012-05-23T16:57:23.617", "Score": "2", "CreationDate": "2012-05-23T16:14:19.987", "ParentId": "10723892", "CommentCount": "11", "OwnerUserId": "927034", "LastEditDate": "2012-05-23T16:57:23.617"}});