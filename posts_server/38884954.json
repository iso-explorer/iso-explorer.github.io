post_cb({"bq_ids": {"n4140": {"so_38884954_38885680_0": {"length": 42, "quality": 0.9130434782608695, "section_id": 234}}, "n3337": {"so_38884954_38885680_0": {"length": 42, "quality": 0.9130434782608695, "section_id": 227}}, "n4659": {"so_38884954_38885680_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 244}}}, "38906180": {"Id": "38906180", "PostTypeId": "2", "Body": "<p>The two syntaxes are both valid, but they mean different things. The syntax with <code>template&lt;&gt;</code> is used to declare or define a member of an implicit or explicit <em>instantiation</em>:</p>\n<pre><code>template&lt;class T&gt; struct X { static int const i; };\n\ntemplate&lt;&gt; int const X&lt;char&gt;::i = 1; // Define member of an implicit instantiation\n\ntemplate struct X&lt;long&gt;;\ntemplate&lt;&gt; int const X&lt;long&gt;::i = 2; // Define member of an explicit instantiation\n</code></pre>\n<p>The syntax without <code>template&lt;&gt;</code> is used to define a member of a <em>specialization</em>:</p>\n<pre><code>template&lt;&gt; struct X&lt;float&gt; { static int const j; }; // Class template specialization\nint const X&lt;float&gt;::j = 3;\n</code></pre>\n", "LastActivityDate": "2016-08-11T21:07:46.180", "CommentCount": "1", "CreationDate": "2016-08-11T21:07:46.180", "ParentId": "38884954", "Score": "3", "OwnerUserId": "567292"}, "38885680": {"Id": "38885680", "PostTypeId": "2", "Body": "<p>Yes, it seems to meet standard.</p>\n<p>At least C++14 standard contains (hope its final revision contains it as well, I've checked with pre-release version <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf</a>).</p>\n<blockquote>\n<p id=\"so_38884954_38885680_0\">14.7.1 Implicit instantiation\n  ...\n  Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.\n  ...</p>\n</blockquote>\n<p>By <code>const int TBase&lt;double&gt;::j=0;</code> you are accessing (not specializing) static member <code>j</code> of <code>TBase&lt;double&gt;</code>, so <code>TBase&lt;double&gt;</code> specialization should be created if not existed yet.</p>\n<p>The code sample without templates, which proves that you are just accessing struct member:</p>\n<pre><code>struct WithoutTemplate {\n    static const int i;\n};\nconst int WithoutTemplate::i = 5;\n</code></pre>\n", "LastActivityDate": "2016-08-11T00:50:23.547", "CommentCount": "1", "CreationDate": "2016-08-11T00:50:23.547", "ParentId": "38884954", "Score": "0", "OwnerUserId": "4117097"}, "38884954": {"ViewCount": "86", "Body": "<p>It looks like compilers accept different syntax to initialization of static in template.</p>\n<pre><code>template &lt;typename T&gt; struct TBase\n{   \n    static const int i;\n    static const int j;\n};\n\n// compile: gcc + clang + visual + icc\ntemplate &lt;&gt; const int TBase&lt;double&gt;::i=1;\n\n// compile: vc + icc\n// failed gcc, gcc -fpermissive, clang\nconst int TBase&lt;double&gt;::j=2;\n</code></pre>\n<p>Is the syntax without <code>template&lt;&gt;</code> accepted by the standard even if it's obviously not portable at the moment ?</p>\n<p>edit: \nWith this code on vc++  <code>TBase&lt;double&gt;::i==1</code> and <code>TBase&lt;double&gt;::j==2</code> exactly like the code without template. </p>\n<pre><code>struct noTemplate \n{   \n    static const int i;\n    static const int j;\n};\nconst int noTemplate::i=1; \nconst int noTemplate::j=2;\n</code></pre>\n<p>gcc and clang seems to enforce the use of <code>template&lt;&gt;</code> to initialize this static, I don't see why compiler need this information.</p>\n", "AcceptedAnswerId": "38906180", "Title": "Template specialization static initialization icc+vc vs gcc+clang", "CreationDate": "2016-08-10T23:09:00.643", "Id": "38884954", "CommentCount": "0", "LastEditDate": "2016-08-11T19:33:24.787", "PostTypeId": "1", "LastEditorUserId": "459640", "LastActivityDate": "2016-08-11T21:07:46.180", "Score": "1", "OwnerUserId": "2054398", "Tags": "<c++><gcc><visual-c++><clang><language-lawyer>", "AnswerCount": "2"}});