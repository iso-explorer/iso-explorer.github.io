post_cb({"bq_ids": {"n4140": {"so_24690195_24690326_0": {"length": 7, "quality": 0.875, "section_id": 6179}}, "n3337": {"so_24690195_24690326_0": {"length": 7, "quality": 0.875, "section_id": 5940}}, "n4659": {"so_24690195_24690326_0": {"length": 7, "quality": 0.875, "section_id": 7681}}}, "24690326": {"Id": "24690326", "PostTypeId": "2", "Body": "<p>C++11 \u00a75.17/7:</p>\n<blockquote>\n<p id=\"so_24690195_24690326_0\"><strong>\u201d</strong><br>\n  The behavior of an expression of the form <code>E1</code> <em>op</em> <code>= E2</code> is equivalent to <code>E1 = E1</code> <em>op</em> <code>E2</code> except that <code>E1</code> is\n  evaluated only once</br></p>\n</blockquote>\n<p>This means that e.g.</p>\n<pre><code>one += list.at(0);\n</code></pre>\n<p>is evaluated <em>as if</em> it were</p>\n<pre><code>one = one + list.at(0);\n</code></pre>\n<p>except that <code>one</code> is evaluated only once.</p>\n<p>In the expresseion <code>one + list.at(0)</code> both operands are first promoted to <code>int</code>, by C++11 \u00a75/9, the <em>usual arithmetic conversions</em> rule.</p>\n<p>In short, C++ binary arithmetic operators do not deal with operands of types with potentially smaller range than <code>int</code>. The operands are promoted. And then for the final assignment, there is (logical) conversion back down.</p>\n", "LastActivityDate": "2014-07-11T04:51:23.440", "Score": "1", "CreationDate": "2014-07-11T04:51:23.440", "ParentId": "24690195", "CommentCount": "0", "OwnerUserId": "464581"}, "24690195": {"ViewCount": "99", "Body": "<p>I do apologize if this question has been answered somewhere else, but I've searched, and have not yet found an answer...</p>\n<p>I get the following warning when compiling the code below:</p>\n<pre><code>warning: conversion to 'short unsigned int' from 'int' may alter its value\n</code></pre>\n<p>Here is an excerpt of code (several examples to illustrate my question):</p>\n<pre><code>std::vector&lt;unsigned short int&gt; list = {1}; \nunsigned short int one = 1;\n\none += list.at(0);                            // produces warning\none += 1;                                     // produces warning\none += static_cast&lt;unsigned short int&gt; 1;     // produces warning\none++;                                        // does not produce warning\n</code></pre>\n<p>I've also tried other forms of arithmetic besides addition. Why does the compiler throw this warning, claiming that I'm converting to an 'unsigned short int' from an 'int' (especially when I've explicitly cast it as unsigned)? It would also seem, that for the second case, 'one += 1;', since the right side of the expression is a positive number, the compiler wouldn't have any problem adding it to the unsigned variable 'one'.</p>\n<p>Also, the final test, 'one++;' does not produce a warning, and I'm not sure why.</p>\n<p>I'm still getting used to asking questions on here, so forgive me if this question is trivial or unclear. Thanks! </p>\n", "AcceptedAnswerId": "24690326", "Title": "Unsigned integer arithmetic warnings", "CreationDate": "2014-07-11T04:36:36.773", "Id": "24690195", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2014-07-11T04:51:23.440", "Score": "-1", "OwnerUserId": "3817228", "Tags": "<c++><warnings><unsigned-integer><integer-arithmetic>", "AnswerCount": "1"}});