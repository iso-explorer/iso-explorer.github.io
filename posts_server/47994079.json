post_cb({"bq_ids": {"n4140": {"so_47994079_47994079_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3321}, "so_47994079_47994498_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_47994079_47994498_1": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_47994079_47994079_2": {"length": 14, "quality": 0.875, "section_id": 597}, "so_47994079_47994498_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_47994079_47994079_1": {"length": 13, "quality": 1.0, "section_id": 3321}, "so_47994079_47994498_2": {"length": 20, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_47994079_47994079_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3191}, "so_47994079_47994498_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_47994079_47994498_1": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_47994079_47994079_2": {"length": 14, "quality": 0.875, "section_id": 587}, "so_47994079_47994498_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_47994079_47994498_2": {"length": 20, "quality": 1.0, "section_id": 3191}, "so_47994079_47994079_1": {"length": 13, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_47994079_47994079_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 4087}, "so_47994079_47994498_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_47994079_47994498_1": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_47994079_47994079_2": {"length": 16, "quality": 1.0, "section_id": 620}, "so_47994079_47994498_3": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_47994079_47994079_1": {"length": 13, "quality": 1.0, "section_id": 4087}, "so_47994079_47994498_2": {"length": 20, "quality": 1.0, "section_id": 4087}}}, "47994079": {"ViewCount": "211", "Body": "<p>Consider this code:</p>\n<pre><code>int **p = 0;\n\nclass S {\npublic:\n    explicit operator int**&amp;() {\n        return p;\n    }\n};\n\nint main() {\n    S a;\n    int *const*&amp;b (a); // error in both g++-7 and clang-5.0 with \"-std=c++17\"\n    return 0;\n}\n</code></pre>\n<p>You will agree</p>\n<ul>\n<li>a qualification conversion from <code>int**</code> to <code>int*const*</code> is possible, and</li>\n<li><code>int *const*&amp;b (a)</code> is a <em>direct-initialization</em>.</li>\n</ul>\n<p>First, we refer to 11.6.3, paragraph 5 [dcl.init.ref] from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4700.pdf\" rel=\"nofollow noreferrer\">n4700</a>.</p>\n<blockquote>\n<p id=\"so_47994079_47994079_0\">A reference to type \u201c<em>cv1</em> <code>T1 (= int*const*)</code>\u201d is initialized by an expression of type \u201c<em>cv2</em> <code>T2 (= S)</code>\u201d as follows:</p>\n<ul>\n<li>If <strong>the reference is an lvalue reference</strong> and the initializer expression\n  \n  <ul>\n<li>...</li>\n<li><strong>has a class type</strong> (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be converted to an lvalue of type \u201c<em>cv3</em> <code>T3</code>\u201d, where \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv3</em> <code>T3</code>\u201d (this conversion is selected <strong>by enumerating the applicable conversion functions (16.3.1.6)</strong> and choosing the best one through overload resolution (16.3)),</li>\n</ul></li>\n</ul>\n<p id=\"so_47994079_47994079_1\">then <strong>the reference is bound</strong> to the initializer expression lvalue in the first case and <strong>to the lvalue result of the conversion in the second case</strong>...</p>\n</blockquote>\n<p><strong>Here, we expect <code>T3</code> to be <code>int*const*</code>.</strong> As noted above, whether it's a possible conversion is determined as per 16.3.1.6, paragraph 1 [over.match.ref].</p>\n<blockquote>\n<p id=\"so_47994079_47994079_2\">... Assuming that \u201creference to <em>cv1</em> <code>T</code>\u201d is the type of the reference being\n  initialized, and \u201c<em>cv</em> <code>S</code>\u201d is the type of the initializer expression, with <code>S</code> a class type, the candidate functions are selected as follows:</p>\n<ul>\n<li>... For direct-initialization, <strong>those explicit conversion functions</strong> that\n  are not hidden within <code>S</code> and yield type \u201clvalue reference to <em>cv2</em> <code>T2</code>\u201d or \u201c<em>cv2</em> <code>T2</code>\u201d or \u201crvalue reference to <em>cv2</em> <code>T2</code>\u201d, respectively, where <code>T2</code> is the same type as <code>T</code> <strong>or can be converted to type <code>T</code> with a qualification conversion are also candidate functions</strong>.</li>\n</ul>\n</blockquote>\n<p><strong>Here, <code>S::operator int**&amp;</code> yields \"lvalue reference to <code>T2 (= int**)</code>\", and it can be converted to <code>T (= int*const*)</code> by a qualification conversion.</strong> Here, we can say that the conversion is possible, but the program is not accepted in both g++-7 and clang-5.0. Why is that?</p>\n", "AcceptedAnswerId": "47994498", "Title": "Why is this reference binding ill-formed?", "CreationDate": "2017-12-27T14:42:26.177", "LastActivityDate": "2017-12-27T15:14:51.500", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-27T15:14:01.243", "LastEditorUserId": "5645940", "Id": "47994079", "Score": "5", "OwnerUserId": "5645940", "Tags": "<c++><language-lawyer><c++17>", "AnswerCount": "1"}, "47994498": {"Id": "47994498", "PostTypeId": "2", "Body": "<p>The reference initialization rule we're looking for is <a href=\"http://eel.is/c++draft/dcl.init.ref#5\" rel=\"noreferrer\">[dcl.init.ref]</a>: </p>\n<blockquote>\n<p id=\"so_47994079_47994498_0\">A reference to type \u201c<em>cv1</em> <code>T1</code>\u201d is initialized by an expression of type \u201c<em>cv2</em> <code>T2</code>\u201d as follows:</p>\n</blockquote>\n<p>We have <em>cv1</em> <code>T1</code> as <code>int* const*</code> and <em>cv2</em> <code>T2</code> as <code>S</code>. We then go through the next sections carefully:</p>\n<blockquote>\n<p id=\"so_47994079_47994498_1\">If the reference is an lvalue reference and the initializer expression  </p>\n<ul>\n<li>is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2\u201d, or</li>\n<li>has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be converted to <strong>an lvalue</strong> of type \u201ccv3 T3\u201d, <strong>where \u201ccv1 T1\u201d is reference-compatible with \u201ccv3 T3\u201d</strong> (this conversion is selected by enumerating the applicable conversion functions ([over.match.ref]) and choosing the best one through overload resolution),</li>\n</ul>\n<p id=\"so_47994079_47994498_2\">then the reference is bound to the initializer expression lvalue in the first case and to the lvalue result of the conversion in the second case (or, in either case, to the appropriate base class subobject of the object).</p>\n</blockquote>\n<p>Our reference is an lvalue reference. The initializer expression is an lvalue but the two types are not <a href=\"http://eel.is/c++draft/dcl.init.ref#4\" rel=\"noreferrer\">reference-compatible</a>, so the first bullet does not apply. </p>\n<p>The initializer expression does have non-reference-related class type, but it cannot be converted to a reference-compatible type. The reference-compatible part is important. <code>int**</code> is <strong>not</strong> reference-compatible with <code>int* const*</code>, and while the former can be converted to the latter, the result would not be an lvalue - which is also required.</p>\n<p>So, this section doesn't apply, and we <a href=\"http://eel.is/c++draft/dcl.init.ref#5.2\" rel=\"noreferrer\">move on</a>.</p>\n<blockquote>\n<p id=\"so_47994079_47994498_3\">Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be const), or the reference shall be an rvalue reference.</p>\n</blockquote>\n<p>Our reference meets neither of those criteria, so the initialization is ill-formed.</p>\n<hr/>\n<p>A simpler version of this failure would be:</p>\n<pre><code>int* pi;\nint const*&amp; r = pi; // error\n</code></pre>\n<p>We can't go through a qualification conversion when we have an lvalue reference to non-const type. </p>\n", "LastActivityDate": "2017-12-27T15:14:51.500", "CommentCount": "3", "CreationDate": "2017-12-27T15:14:51.500", "ParentId": "47994079", "Score": "7", "OwnerUserId": "2069064"}});