post_cb({"17667152": {"Id": "17667152", "PostTypeId": "2", "Body": "<p>You do, because those are full function specializations, and therefore subject to the one-definition rule just like normal functions.</p>\n", "LastActivityDate": "2013-07-16T02:43:44.787", "CommentCount": "2", "CreationDate": "2013-07-16T02:43:44.787", "ParentId": "17667098", "Score": "20", "OwnerUserId": "541686"}, "17667098": {"ViewCount": "17130", "Body": "<p>Do I need <code>inline</code> template functions if they are included in several <code>cpp</code> files? Thanks.</p>\n<pre><code>template&lt;bool&gt; inline QString GetText();\ntemplate&lt;&gt; inline QString GetText&lt;true&gt;() {return \"true\";}\ntemplate&lt;&gt; inline QString GetText&lt;false&gt;() {return \"false\";}\n</code></pre>\n", "AcceptedAnswerId": "17667152", "Title": "inline template function?", "CreationDate": "2013-07-16T02:36:00.393", "Id": "17667098", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-07-16T02:57:02.477", "Score": "18", "OwnerUserId": "1899020", "Tags": "<c++><template-function>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_17667098_17667265_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 274}, "so_17667098_17667265_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 7043}}, "n3337": {"so_17667098_17667265_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 265}, "so_17667098_17667265_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 6788}}, "n4659": {"so_17667098_17667265_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 281}, "so_17667098_17667265_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 8540}}}, "17667137": {"Id": "17667137", "PostTypeId": "2", "Body": "<p>There is no reason for inline for template declaration but not for template full specialization, you don't need to add the inline keyword for the first line but the second and third one need it.\nBut each translation unit, which use the template, need to contains the template definition  so the best way is to include it in header file and include in other cpps which use it.</p>\n<p>In C++ standard n3376 for 3.2/6, there can be more than one definition of class template for the whole application, given the definition is same.</p>\n<p>===============</p>\n<p>Update the answere base on  Jesse Good comments, (need inline for template full sepcialization) Thanks Jesse Good point out that.</p>\n", "LastEditorUserId": "2428052", "LastActivityDate": "2013-07-16T02:55:03.650", "Score": "0", "CreationDate": "2013-07-16T02:42:12.190", "ParentId": "17667098", "CommentCount": "5", "OwnerUserId": "2428052", "LastEditDate": "2013-07-16T02:55:03.650"}, "17667192": {"Id": "17667192", "PostTypeId": "2", "Body": "<p>It seem that the template method must be defined in the same file which is building, You don't need to use the 'inline' keyword for they were build in each cpp file which include it.</p>\n", "LastActivityDate": "2013-07-16T02:49:02.373", "CommentCount": "0", "CreationDate": "2013-07-16T02:49:02.373", "ParentId": "17667098", "Score": "0", "OwnerUserId": "2585537"}, "17667265": {"Id": "17667265", "PostTypeId": "2", "Body": "<p>Yes, you need the <code>inline</code> specifier there.</p>\n<p>The ODR (one-definition rule) states that there must be exactly one definition of a variable, function, class, enum or template. Exceptions relevant for your question are listed in \u00a73.2/5 (C++11) (emphasis mine):</p>\n<blockquote>\n<p id=\"so_17667098_17667265_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or <strong>template specialization for which some template parameters are not specified</strong> (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. [...]</p>\n</blockquote>\n<p>Template specializations for which <em>all</em> parameters are specified (i.e. explicit specializations) are not listed there, and \u00a714.7.3/12 says:</p>\n<blockquote>\n<p id=\"so_17667098_17667265_1\">An explicit specialization of a function template is inline only if it is declared with the inline specifier or defined as deleted, and independently of whether its function \n  template is inline. [ Example:</p>\n<pre><code>template&lt;class T&gt; void f(T) { /\u2217 ... \u2217/ }\ntemplate&lt;class T&gt; inline T g(T) { /\u2217 ... \u2217/ }\ntemplate&lt;&gt; inline void f&lt;&gt;(int) { /\u2217 ... \u2217/ }  // OK: inline\ntemplate&lt;&gt; int g&lt;&gt;(int) { /\u2217 ... \u2217/ }          // OK: not inline\n</code></pre>\n<p id=\"so_17667098_17667265_2\">\u2014 end example ]</p>\n</blockquote>\n", "LastActivityDate": "2013-07-16T02:57:02.477", "CommentCount": "2", "CreationDate": "2013-07-16T02:57:02.477", "ParentId": "17667098", "Score": "13", "OwnerUserId": "777186"}});