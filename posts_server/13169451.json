post_cb({"45680849": {"ParentId": "13169451", "CommentCount": "1", "Body": "<p>Yes, there is a full guarantee that <strong>sizeof(signed type) is equal to sizeof(unsigned type)</strong> since unsigned is only taking the space of negative numbers of signed type to increase its range.</p>\n", "OwnerUserId": "8459014", "PostTypeId": "2", "Id": "45680849", "Score": "0", "CreationDate": "2017-08-14T18:34:02.423", "LastActivityDate": "2017-08-14T18:34:02.423"}, "13169451": {"CommentCount": "2", "CreationDate": "2012-11-01T00:42:08.273", "PostTypeId": "1", "AcceptedAnswerId": "13169473", "LastEditorUserId": "636019", "LastActivityDate": "2017-08-14T18:34:02.423", "LastEditDate": "2012-11-01T00:55:03.457", "ViewCount": "2739", "FavoriteCount": "1", "Title": "Do I have the guarantee that sizeof(type) == sizeof(unsigned type)?", "Id": "13169451", "Score": "23", "Body": "<p>The sizeof char, int, long double... can vary from one compiler to another. But do I have the guarantee according to the C++11 or C11 standard that the size of any signed and unsigned fundamental integral type is the same ?</p>\n", "Tags": "<c++><c><sizeof><language-lawyer><standards-compliance>", "OwnerUserId": "882932", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13169451_13169473_1": {"section_id": 7212, "quality": 0.6923076923076923, "length": 18}, "so_13169451_13169473_0": {"section_id": 7212, "quality": 0.9436619718309859, "length": 67}}, "n3337": {"so_13169451_13169473_1": {"section_id": 6956, "quality": 0.6923076923076923, "length": 18}, "so_13169451_13169473_0": {"section_id": 6956, "quality": 0.9436619718309859, "length": 67}}, "n4659": {"so_13169451_13169473_1": {"section_id": 8721, "quality": 0.6923076923076923, "length": 18}, "so_13169451_13169473_0": {"section_id": 8721, "quality": 0.9436619718309859, "length": 67}}}, "13169473": {"ParentId": "13169451", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++11 Standard says about integer types:</p>\n<blockquote>\n<p id=\"so_13169451_13169473_0\">(\u00a73.9.1/3) For each of the standard signed integer types, there exists a corresponding (but different) standard unsigned integer type: \u201cunsigned char\u201d, \u201cunsigned short int\u201d, \u201cunsigned int\u201d, \u201cunsigned long int\u201d, and \u201cunsigned long long int\u201d, each of which occupies the same amount of storage and has the same alignment requirements (3.11) as the corresponding signed integer type; that is, each signed integer type has the same object representation as its corresponding unsigned integer type. Likewise, for each of the extended signed integer types there exists a corresponding extended unsigned integer type with the same amount of storage and alignment requirements. [...]</p>\n</blockquote>\n<p>So the answer is yes.</p>\n<p>For C11, there is a corresponding statement here (this is from N1570):</p>\n<blockquote>\n<p id=\"so_13169451_13169473_1\">(\u00a76.2.5/6) For each of the signed integer types, there is a corresponding (but different) unsigned\n  integer type (designated with the keyword unsigned) that uses the same amount of\n  storage (including sign information) and has the same alignment requirements [...]</p>\n</blockquote>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2012-11-01T00:52:52.310", "Id": "13169473", "Score": "40", "CreationDate": "2012-11-01T00:45:01.977", "LastActivityDate": "2012-11-01T00:52:52.310"}});