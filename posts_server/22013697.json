post_cb({"22013788": {"ParentId": "22013697", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the  n2798 (draft of C++0x)::</p>\n<blockquote>\n<p id=\"so_22013697_22013788_0\"><strong>23.2.6 Class template vector [vector]</strong></p>\n<p id=\"so_22013697_22013788_1\">1 A vector is a sequence container that supports random access\n  iterators. In addition, it supports (amortized) constant time insert\n  and erase operations at the end; insert and erase in the middle take\n  linear time. Storage management is handled automatically, though hints\n  can be given to improve efficiency. <strong>The elements of a vector are\n  stored contiguously</strong>, meaning that if v is a vector where T is some\n  type other than bool, then it obeys the identity &amp;v[n] == &amp;v[0] + n\n  for all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n<p>Also do check array being reallocated (invalidating any pointers and iterators) after adding elements to it.</p>\n<p>Also check this article:- <a href=\"http://herbsutter.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/\" rel=\"nofollow\">Cringe not: Vectors are guaranteed to be contiguous</a></p>\n<blockquote>\n<p id=\"so_22013697_22013788_2\">contiguity is in fact part of the vector abstraction. It\u2019s so\n  important, in fact, that when it was discovered that the C++98\n  standard didn\u2019t completely guarantee contiguity, the C++03 standard\n  was amended to explicitly add the guarantee.</p>\n</blockquote>\n<p>Also from the <strong><a href=\"http://www.parashift.com/c++-faq-lite/vector-is-contiguous.html\" rel=\"nofollow\">C++ FAQ</a></strong></p>\n<pre><code>#include &lt;vector&gt;\n#include \"Foo.h\"  /* get class Foo */\n\n// old-style code that wants an array\nvoid f(Foo* array, unsigned numFoos);\n\nvoid g()\n{\n  std::vector&lt;Foo&gt; v;\n  ...\n  f(v.empty() ? NULL : &amp;v[0], v.size());  \u2190 safe\n}\n</code></pre>\n<p>The funny expression <code>v.empty() ? NULL : &amp;v[0]</code> simply passes the NULL pointer if v is empty, otherwise passes a pointer to the first (zeroth) element of v. If you know a priori that v is not empty, you can change that to simply &amp;v[0].\nIn general, it means you are guaranteed that <code>&amp;v[0] + n == &amp;v[n]</code>, where v is a <code>std::vector&lt;T&gt;</code> and n is an integer in the range <code>0 .. v.size()-1.</code></p>\n<p>However v.begin() is not guaranteed to be a T*, which means v.begin() is not guaranteed to be the same as &amp;v[0]:</p>\n<pre><code>void g()\n{\n  std::vector&lt;Foo&gt; v;\n  ...\n  f(v.begin(), v.size());  \u2190 Error!! Not Guaranteed!!\n    ^^^^^^^^^-- cough, choke, gag; not guaranteed to be the same as &amp;v[0]\n}\n</code></pre>\n", "OwnerUserId": "1501794", "LastEditorUserId": "1501794", "LastEditDate": "2014-02-25T12:21:19.467", "Id": "22013788", "Score": "6", "CreationDate": "2014-02-25T12:09:33.653", "LastActivityDate": "2014-02-25T12:21:19.467"}, "22013697": {"CommentCount": "2", "AcceptedAnswerId": "22013788", "PostTypeId": "1", "ClosedDate": "2014-02-26T10:50:27.900", "LastEditorUserId": "456065", "CreationDate": "2014-02-25T12:05:48.483", "LastActivityDate": "2014-02-25T14:34:38.773", "LastEditDate": "2014-02-25T14:34:38.773", "ViewCount": "977", "FavoriteCount": "1", "Title": "Is data storage in std::vector continuous?", "Id": "22013697", "Score": "2", "Body": "<p>I have a vector of chars and I want to pass it's content as a char* to another function:</p>\n<pre><code>void foo(boost::shared_ptr&lt;std::vector&lt;boost::uint8_t&gt; &gt; data)\n{\n    bar(data-&gt;size()?reinterpret_cast&lt;char*&gt;(&amp;(data.get()-&gt;front())):NULL);\n}\n</code></pre>\n<p>Can I assume that the data is always stored in a contiguous manner?\nThanks.</p>\n", "Tags": "<c++><vector>", "OwnerUserId": "456065", "AnswerCount": "3"}, "22013743": {"ParentId": "22013697", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes you can. The standard mandates that the memory in a <code>std::vector</code> is <em>contiguous</em>. But note that this is <strong>not</strong> true for <code>std::vector&lt;bool&gt;</code>.</p>\n<p>In fact <code>std::vector::data()</code> gives you a pointer to the first element in the vector. You can then use pointer arithmetic to access the vector elements.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2014-02-25T12:22:26.243", "Id": "22013743", "Score": "0", "CreationDate": "2014-02-25T12:07:48.703", "LastActivityDate": "2014-02-25T12:22:26.243"}, "bq_ids": {"n4140": {"so_22013697_22013788_1": {"section_id": 955, "quality": 0.96, "length": 48}}, "n3337": {"so_22013697_22013788_1": {"section_id": 943, "quality": 0.96, "length": 48}}, "n4659": {"so_22013697_22013788_1": {"section_id": 1016, "quality": 0.54, "length": 27}}}, "22013808": {"ParentId": "22013697", "CommentCount": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\">Cppreference</a>: </p>\n<blockquote>\n<p id=\"so_22013697_22013808_0\">std::vector is a sequence container that encapsulates dynamic size arrays.</p>\n<p id=\"so_22013697_22013808_1\">The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets on regular pointers to elements.</p>\n</blockquote>\n<p>So yes, the elements are contiguous in memory. That means you can use the underlying data container (which is a <code>T[]</code>, that you get with the <code>data()</code> member function) as a classic array.</p>\n", "OwnerUserId": "1594913", "PostTypeId": "2", "Id": "22013808", "Score": "2", "CreationDate": "2014-02-25T12:10:25.237", "LastActivityDate": "2014-02-25T12:10:25.237"}});