post_cb({"11966326": {"ParentId": "11965402", "CommentCount": "0", "Body": "<p>Let me quote relevant clauses of C++03 Standard.\n5.3.1/2</p>\n<blockquote>\n<p id=\"so_11965402_11966326_0\">The result of the unary &amp; operator is a pointer to its operand. The\n  operand shall be an lvalue.</p>\n</blockquote>\n<p>An integer literal is an rvalue (however, I haven't found a direct quote in C++03 Standard, but C++11 mentiones that as a side note in 3.10/1).\nTherefore, it's not possible to take an address of an integer literal.</p>\n<p>What about the exact place where <code>2</code> is stored, it depends on usage. It might be a part of an machine instruction, or it might be optimized away, e.g. <code>j=i*2</code> might become <code>j=i+i</code>. You should not rely upon it.</p>\n", "OwnerUserId": "1345960", "PostTypeId": "2", "Id": "11966326", "Score": "0", "CreationDate": "2012-08-15T08:41:51.953", "LastActivityDate": "2012-08-15T08:41:51.953"}, "11966852": {"ParentId": "11965402", "CommentCount": "5", "Body": "<p>You have two questions:</p>\n<p>Where are literal constants stored?  With the exception of string\nliterals (which are actual objects), pretty much wherever the\nimplementation wants.  It will usually depend on what you're doing with\nthem, but on a lot of architectures, integral constants (and often some\nspecial floating point constants, like <code>0.0</code>) will end up as part of a\nmachine instruction.  When this isn't possible, they'll usually be\nplaced in the same logical segment as the code. </p>\n<p>As to why taking the address of an rvalue is illegal, the main reason is\nbecause the standard says so.  Historically, it's forbidden because such\nconstants often never exist as a separate object in memory, and thus\nhave no address.  Today... one could imagine other solutions: compilers\nare smart enough to put them in memory if you took their address, and\nnot otherwise; and rvalues of class type <em>do</em> have a memory address.\nThe rules are somewhat arbitrary (and would be, regardless of what they\nwere)\u2014hopefully, any rules which would allow taking the address of\na literal would make its type <code>int const*</code>, and not <code>int*</code>.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "11966852", "Score": "0", "CreationDate": "2012-08-15T09:23:11.860", "LastActivityDate": "2012-08-15T09:23:11.860"}, "11965402": {"CommentCount": "6", "AcceptedAnswerId": "11965675", "PostTypeId": "1", "LastEditorUserId": "802815", "CreationDate": "2012-08-15T07:15:48.350", "LastActivityDate": "2012-08-15T09:23:11.860", "LastEditDate": "2012-08-15T07:57:09.640", "ViewCount": "1339", "FavoriteCount": "1", "Title": "Where the C++ literal-constant storage in memory?", "Id": "11965402", "Score": "0", "Body": "<p>Where the C++ literal-constant storage in memory? stack or heap?</p>\n<p><code>int *p = &amp;2</code><p> is wrong. I want know why? Thanks</p></p>\n<p>-------------------------------------------------</p>\n<p><p>My question is \"Where the C++ literal-constant storage in memory\", \"<code>int *p = &amp;2</code><p> is wrong\",not my question. </p></p>\n</p>", "Tags": "<c++><pointers><literals>", "OwnerUserId": "802815", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_11965402_11966326_0": {"section_id": 6066, "quality": 0.8, "length": 8}}, "n3337": {"so_11965402_11966326_0": {"section_id": 5834, "quality": 0.8, "length": 8}}, "n4659": {"so_11965402_11966326_0": {"section_id": 7562, "quality": 0.8, "length": 8}}}, "11965675": {"ParentId": "11965402", "CommentCount": "1", "Body": "<p>The details depend on the machine, but assuming a commonest sort of machine and operating system... every executable file contains several \"segments\" - CODE, BSS, DATA and some others.  </p>\n<p>CODE holds all the executable opcodes. Actually, it's often named TEXT because somehow that made sense to people way back decades ago. Normally it's read-only.</p>\n<p>BSS is uninitialized data - it actually doesn't need to exist in the executable file, but is allocated by the operating system's loader when the program is starting to run.   </p>\n<p>DATA holds the literal constants - the int8, int16, int32 etc along with floats, string literals, and whatever weird things the compiler and linker care to produce.  This is what you're asking about.   However, it holds only constants defined for use as variables, as in </p>\n<pre><code>const long x = 2;\n</code></pre>\n<p>but unlikely to hold literal constants used in your source code but not tightly associated with a variable.   Just a lone '2' is dealt with directly by the compiler.  For example in C, </p>\n<pre><code>print(\"%d\", 2);\n</code></pre>\n<p>would cause the compiler to build a subroutine call to print(), writing opcodes to push a pointer to the string literal \"%d\" and the value 2, both as 64-bit integers on a 64-bit machine (you're not one of those laggards still using 32-bit hardware, are you? :) followed by the opcode to jump to a subroutine at (identifier for 'print' subroutine).  </p>\n<p>The \"%d\" literal goes into DATA.   The 2 doesn't; it's built into the opcode that stuffs integers onto the stack.  That might actually be a \"load register RAX immediate\" followed by the value 2, followed by a \"push register RAX\", or maybe a single opcode can do the job.  So in the final executable file, the 2 will be found in the CODE (aka TEXT) segment.</p>\n<p>It typically isn't possible to make a pointer to that value, or to any opcode.  It just doesn't make sense in terms of what high level languages like C do (and C is \"high level\" when you're talking about opcodes and segments.)  \"&amp;2\" can only be an error.</p>\n<p>Now, it's not entirely impossible to have a pointer to opcodes.  Whenever you define a function in C, or an object method, constructor or destructor in C++, the name of the function can be thought of as a pointer to the first opcode of the machine code compiled from that function.  For example, print() without the parentheses is a pointer to a function. Maybe if your example code were in a function and you guess the right offset, pointer arithmetic could be used to point to that \"immediate\" value 2 nestled among the opcodes, but this is not going to be easy for any contemporary CPU, and certainly isn't for beginners. </p>\n", "OwnerUserId": "10468", "PostTypeId": "2", "Id": "11965675", "Score": "6", "CreationDate": "2012-08-15T07:42:46.713", "LastActivityDate": "2012-08-15T07:42:46.713"}});