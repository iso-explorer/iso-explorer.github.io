post_cb({"32106942": {"ParentId": "32106803", "PostTypeId": "2", "CommentCount": "10", "Body": "<blockquote>\n<p id=\"so_32106803_32106942_0\"><code>[C99: 6.2.5/25, C11: 6.2.5/26]:</code> <em>[..]</em> The qualified or unqualified versions of a type are distinct types that belong to the same type category and have the same representation and alignment requirements. <em>[..]</em></p>\n<p id=\"so_32106803_32106942_1\"><code>[C++03, C++11, C++14: 3.9.3/1]:</code> <em>[..]</em> The cv-qualified or cv-unqualified versions of a type are distinct types; however, they shall have the same representation and alignment requirements (3.11).</p>\n</blockquote>\n<p>And for the encapsulating types:</p>\n<blockquote>\n<p id=\"so_32106803_32106942_2\"><code>[C99: 6.2.7/1]:</code> <em>[..]</em> Moreover, two structure, union, or enumerated types declared in separate translation units are compatible if their tags and members satisfy the following requirements: If one is declared with a tag, the other shall be declared with the same tag. If both are complete types, then the following additional requirements apply: there shall be a one-to-one correspondence between their members such that each pair of corresponding members are declared with compatible types, and such that if one member of a corresponding pair is declared with a name, the other member is declared with the same name. <em>[..]</em></p>\n<p id=\"so_32106803_32106942_3\"><code>[C++03: 9.2/14]:</code> Two POD-struct (clause 9) types are layout-compatible if they have the same number of nonstatic data members, and corresponding nonstatic data members (in order) have layout-compatible types (3.9).</p>\n<p id=\"so_32106803_32106942_4\"><code>[C++11: 9.2/16, C++14: 9.2/17]:</code> Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).</p>\n</blockquote>\n<p>So, assuming we're ignoring the type system bypass (<code>const void*</code> \u2192 <code>void*</code> through <code>const_cast</code> either directly or by C-style cast \u2014 note that <code>reinterpret_cast</code> has nothing to do with this and is explicitly prohibited from dropping <em>cv-qualifiers</em>) and only talking about aliasing compatibility\u2026</p>\n<p><strong>\u2026yes, this is \"safe\".</strong></p>\n<p>It's why we're able to use <code>const_cast</code>, delicately, when ancient C APIs force us to take them at their word rather than actually using <code>const</code>-safety.</p>\n<p>You know this is okay anyway, because when you wrote <code>&amp;in_arg</code> your compiler implicitly converted the <code>s1*</code> to <code>const s1*</code> for the call, and did not complain.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-08-19T23:33:01.943", "Id": "32106942", "Score": "-1", "CreationDate": "2015-08-19T22:55:20.027", "LastActivityDate": "2015-08-19T23:33:01.943"}, "32106803": {"CommentCount": "2", "ViewCount": "199", "PostTypeId": "1", "LastEditorUserId": "5245300", "CreationDate": "2015-08-19T22:41:31.187", "LastActivityDate": "2015-08-26T18:14:05.127", "Title": "Pointer to qualified and non-qualified type representation", "LastEditDate": "2015-08-26T18:14:05.127", "Id": "32106803", "Score": "2", "Body": "<p>Is it safe to reinterpret a pointer to an unqualified type as a pointer to a qualified type? Consider a standard layout type containing a pointer member \"void *ptr\" and another standard layout type defined equivalently, but with \"const void *ptr\". Are these types layout compatible, and does this answer depend on the language revision or between C and C++?</p>\n<p>Motivation:</p>\n<p>Sometimes when interfacing with C programs, one defines a struct grouping parameters to some type of buffer. For const-correctness, an input buffer should have const pointers to underlying buffers, but output buffers must obviously be mutable.</p>\n<pre><code>struct s1 { const void *ptr; }\nstruct s2 { void *ptr; }\n\nconst void *get_in_ptr(void);\nvoid *get_out_ptr(void);\n\nvoid alg(const s1 *in, const s2 *out);\n\nvoid f()\n{\n    s1 in_arg = { get_in_ptr() };\n    s2 out_arg1 = { get_out_ptr() };\n    s2 out_arg2 = { get_out_ptr() };\n\n    /* First algorithm pass. */\n    alg(&amp;in_arg, &amp;out_arg1);\n    /* Second algorithm pass. */\n    alg((const s1 *)&amp;out_arg1, &amp;out_arg2); /* Is this legal? */\n}\n</code></pre>\n<p>Please cite the relevant standard publications in any answers.</p>\n", "Tags": "<c++><c><const><language-lawyer>", "OwnerUserId": "5245300", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32106803_32107221_1": {"section_id": 5435, "quality": 0.5357142857142857, "length": 15}, "so_32106803_32106942_1": {"section_id": 7225, "quality": 0.6842105263157895, "length": 13}, "so_32106803_32106942_4": {"section_id": 5876, "quality": 0.8076923076923077, "length": 21}, "so_32106803_32106942_3": {"section_id": 5876, "quality": 0.7727272727272727, "length": 17}}, "n3337": {"so_32106803_32106942_1": {"section_id": 6969, "quality": 0.6842105263157895, "length": 13}, "so_32106803_32106942_4": {"section_id": 5647, "quality": 0.8461538461538461, "length": 22}, "so_32106803_32106942_3": {"section_id": 5647, "quality": 0.8181818181818182, "length": 18}}, "n4659": {"so_32106803_32106942_1": {"section_id": 8735, "quality": 0.6842105263157895, "length": 13}, "so_32106803_32106942_4": {"section_id": 7361, "quality": 0.6923076923076923, "length": 18}, "so_32106803_32106942_3": {"section_id": 7361, "quality": 0.7727272727272727, "length": 17}}}, "32107221": {"ParentId": "32106803", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>C11 <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.3.2.3p1\" rel=\"nofollow\">states</a>:</p>\n<blockquote>\n<p id=\"so_32106803_32107221_0\">For any qualifier q, a pointer to a non-q-qualified type may be converted to a pointer to the q-qualified version of the type; the values stored in the original and converted pointers shall compare equal.</p>\n</blockquote>\n<p>So, it is safe to cast to a qualified version, but not vice-versa. Casting away - especially <code>const</code> or volatile could use different memory accesses, e.g. for Harvard architectures storing <code>const</code> variables in program memory (PIC, AVR). And the standard is very <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.7.3p6\" rel=\"nofollow\">clear</a> about the consequences:</p>\n<blockquote>\n<p id=\"so_32106803_32107221_1\">If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined. If an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined.</p>\n</blockquote>\n<p>Briefly: it is <strong>not</strong> safe to cast away those qualifiers in general. The standard does not mention read-accesses for ex-<code>const</code> objects, however.</p>\n<p>For the other qualifiers and further details, please read yourself.</p>\n<hr>\n<p>For the struct layout: C uses compatibility by type/layout, as opposed to C++. So two types are compatible if they use the same layout/standard type, not the same type-name.</p>\n</hr>", "OwnerUserId": "4774918", "LastEditorUserId": "59303", "LastEditDate": "2015-08-24T16:33:07.263", "Id": "32107221", "Score": "1", "CreationDate": "2015-08-19T23:24:36.550", "LastActivityDate": "2015-08-24T16:33:07.263"}});