post_cb({"bq_ids": {"n4140": {"so_48109271_48109621_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 5836}, "so_48109271_48109621_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5817}}, "n3337": {"so_48109271_48109621_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 5606}, "so_48109271_48109621_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5588}}, "n4659": {"so_48109271_48109621_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 7298}, "so_48109271_48109621_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 7278}}}, "48109271": {"ViewCount": "98", "Body": "<p>Here is the originan question, but mine have some differences with it. <a href=\"https://stackoverflow.com/questions/20871063/c-memory-model-does-this-example-contain-a-data-race\">C++ memory model - does this example contain a data race?</a></p>\n<p>My question:</p>\n<pre><code>//CODE-1: initially, x == 0 and y == 0\nif (x) y++; // pthread 1\nif (y) x++; // pthread 2\n</code></pre>\n<p>Note: the code above is written in C, not C++ (without a memory model). So does it contain a data race? </p>\n<p>From my point of view: if we view the code in Sequential Consistency memory model, there is no data race because x and y will never be both non-zero at the same time. However, we can never assume a Sequential Consistency memory model, so the compilier reordering could make a transformation that respect to the intra-thread correctness because the compiler isn't aware of the existence of thread.......right?</p>\n<p>So the code could be transformed to:</p>\n<pre><code>//CODE-2\ny++; if (!x) y--;\nx++; if (!y) x--;\n</code></pre>\n<p>the transformation above doesn't violate the sequential correctness so it's correct.It's not the fault of the compilier, right? So I agree with the view that the CODE-1 contains a data race.What about you?</p>\n<p>I have an extra question, C++11 with a memory model can solve this data race because the compilers are aware of the thread, so they will do their reorder according to the memory model type, right?</p>\n", "AcceptedAnswerId": "48109621", "Title": "Does this example contain a data race?", "CreationDate": "2018-01-05T07:45:32.713", "LastActivityDate": "2018-01-06T00:01:46.120", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-05T09:58:08.577", "LastEditorUserId": "2564301", "Id": "48109271", "Score": "3", "OwnerUserId": "6821151", "Tags": "<c><multithreading><c++11><java-memory-model><memory-model>", "AnswerCount": "2"}, "48109427": {"Id": "48109427", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48109271_48109427_0\">//CODE-1: initially, x == 0 and y == 0<br/>\n     if (x) y++; // pthread 1<br/>\n     if (y) x++; // pthread 2</p>\n</blockquote>\n<p>There is no undefined behavior because neither x nor y will ever change their value.<br/>\nHowever, there is still a race condition, because there is no defined sequence between read access in one thread and write access in the other one.</p>\n<blockquote>\n<p id=\"so_48109271_48109427_1\">//CODE-2<br/>\n     y++; if (!x) y--; // pthread 1<br/>\n     x++; if (!y) x--; // pthread 2</p>\n</blockquote>\n<p>Now you have a data race and undefined behavior because there is no sequence between <code>y++</code> in thread 1 and if(!y) in thread 2 and vice versa. So possible results for y are:</p>\n<ul>\n<li><code>y = 0</code><br/>\nThread 1 runs after thread 2. So x is still 0.</li>\n<li><code>y = 1</code><br/>\nThread 1 runs in parallel to thread 2, sees the change to x but not vice versa. So y is not decremented.</li>\n</ul>\n<p>This has nothing to do with the memory model. It is just a race in any unsynchronized context.</p>\n", "LastEditorUserId": "6256451", "LastActivityDate": "2018-01-06T00:01:46.120", "Score": "1", "CreationDate": "2018-01-05T07:58:54.490", "ParentId": "48109271", "CommentCount": "7", "OwnerUserId": "6256451", "LastEditDate": "2018-01-06T00:01:46.120"}, "48109621": {"Id": "48109621", "PostTypeId": "2", "Body": "<p>The C++ standard defines a data race (which triggers undefined behavior) as:</p>\n<blockquote>\n<p id=\"so_48109271_48109621_0\">\u00a7 1.10.1-2  [intro.races]<br>\n  Two expression evaluations conflict if one of them modifies a memory location (..) and the other one reads or modifies the same memory location.</br></p>\n</blockquote>\n<p>Per the C++ memory model rules, your first code fragment contains no data race because the C++ standard forbids compiler transformations that would introduce such a race:</p>\n<blockquote>\n<p id=\"so_48109271_48109621_1\">\u00a7 1.10.1-21  [intro.races]<br>\n  Compiler transformations that introduce assignments to a potentially shared memory location that would not be modified by the abstract machine are generally precluded by this International Standard, since such an assignment might overwrite another assignment by a different thread in cases in which an abstract machine execution would not have encountered a data race.</br></p>\n</blockquote>\n<p>So it says that if the condition in the if-statement (<code>x</code>) yields false, no transformation is allowed that would modify <code>y</code>, even if the end result is that <code>y</code> appears unmodified. </p>\n<p>The second example clearly contains a data race because 2 threads can write and read <code>x</code> at the same time (same applies to <code>y</code>).</p>\n<p>Note that both C++ and C have a memory model since version 11. If you use a compiler that does not support C11, multithreaded behavior is not officially defined.</p>\n<p>Here is a <a href=\"https://stackoverflow.com/questions/45885048/is-this-compiler-transformation-allowed\">question</a> that shows an example of an illegal compiler transformation.</p>\n", "LastEditorUserId": "6651824", "LastActivityDate": "2018-01-05T09:26:05.627", "Score": "2", "CreationDate": "2018-01-05T08:15:18.303", "ParentId": "48109271", "CommentCount": "2", "OwnerUserId": "6651824", "LastEditDate": "2018-01-05T09:26:05.627"}});