post_cb({"30821671": {"LastActivityDate": "2015-06-13T19:08:35.770", "CommentCount": "5", "Body": "<p>It means that everything in the ctor of <code>B</code> up to the point of the exception is destruction. An instance of <code>B</code> itself was never constructed, therefore it must not be destructed. Note also that <code>pi</code> was never constructed.</p>\n<pre><code>std::shared_ptr&lt;B&gt; pi(new B)  - start with new B\nnew B                         - triggers the ctor of B\nstd::cout ...                 - the output \nA b;                          - construct an A\nthrow 3;                      - calls ~A()\n                              - rewind, new B is \"aborted\"\n                              - std::shared_ptr&lt;B&gt; pi(new B) is \"aborted\"\n</code></pre>\n<p>You could modify your code to see, that the constructor of the <code>std::shared_ptr</code> is never hit by replacing it with a new class of yours, taking a pointer:</p>\n<pre><code>struct T {\n  T(B*) { std::cout &lt;&lt; \"T::T()\\n\"; }\n};\n...\ntry\n{\n    T pi(new B);  // instead of std::shared_ptr&lt;B&gt; pi(new B);\n}\n...\n</code></pre>\n<p>The constructor of <code>T</code> will not be hit (cf. \"<code>pi</code> was never constructed\").</p>\n<p>Now assume that the constructor of <code>B</code> would allocate memory as in:</p>\n<pre><code>B()\n{\n  A* a = new A();   // in contrast to A a;\n  throw 3;\n}\n</code></pre>\n<p>were previously <code>A::~A()</code> was called, that is a was deconstructed, we now have a pointer, and pointers don't need to be deconstructed. However the memory allocated and assigned to a is <strong>not</strong> deleted. (Had you used a smart pointer <code>std::unique_ptr&lt;A&gt; a = std::make_unique&lt;A&gt;();</code>, the memory would have been released, because the destructor of <code>std::unique_ptr&lt;A&gt;</code> is called and it will release the memory.)</p>\n", "CreationDate": "2015-06-13T17:42:51.270", "LastEditDate": "2015-06-13T19:08:35.770", "ParentId": "30821651", "Id": "30821671", "LastEditorUserId": "1671066", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1671066"}, "30821651": {"CreationDate": "2015-06-13T17:40:51.547", "ViewCount": "458", "Id": "30821651", "AcceptedAnswerId": "30821671", "Score": "2", "Title": "Why is there a memory leak when an exception is thrown from a constructor?", "LastEditorUserId": "560648", "CommentCount": "1", "Body": "<p>I read the book <em>C++ How to Program 8th Edition</em> by <em>Paul Deitel</em>. There is a statement at p.645:</p>\n<blockquote>\n<p id=\"so_30821651_30821651_0\">When an exception is thrown from the constructor for an object that's created in a new expression, the dynamically allocated memory for that object is released.</p>\n</blockquote>\n<p>To verify this statement, I wrote code as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;exception&gt;\n#include &lt;memory&gt;\n\nclass A{\npublic:\n  A(){std::cout &lt;&lt; \"A is coming.\" &lt;&lt; std::endl;}\n  ~A(){std::cout &lt;&lt; \"A is leaving.\" &lt;&lt; std::endl;}\n};\nclass B\n{\npublic:\n  B()\n  {\n    std::cout &lt;&lt; \"B is coming.\" &lt;&lt; std::endl;\n    A b;\n    throw 3;\n  }\n  ~B(){std::cout &lt;&lt; \"B is leaving.\" &lt;&lt; std::endl;}\n};\n\nint main(void)\n{\n    try\n    {\n        std::shared_ptr&lt;B&gt; pi(new B);\n    }\n    catch(...)\n    {\n      std::cout &lt;&lt; \"Exception handled!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>B is coming.\nA is coming.\nA is leaving.\nException handled!\n</code></pre>\n<p>This shows that B's destructor isn't invoked, which seems to conflict with the statement above. </p>\n<p>Is my code correct to verify the statement? If not, how should I modify it? If yes, does it mean that the statement is wrong?</p>\n", "Tags": "<c++><c++11><exception><memory-leaks>", "LastEditDate": "2015-06-13T17:57:47.763", "LastActivityDate": "2015-06-13T19:08:35.770", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "4982781"}, "30821814": {"CommentCount": "0", "Body": "<p>You're confusing two things:</p>\n<ul>\n<li>memory being released</li>\n<li>the destructor being called</li>\n</ul>\n<p>You've shown that the latter doesn't occur, which makes sense: how can you destroy something that wasn't properly constructed? Note that the member variables <em>will</em> have their destructors invoked, though, because by the time the constructor threw an exception all the member variables had been fully constructed.</p>\n<p>But that has nothing to do with memory being released, which <em>will</em> assuredly occur.</p>\n<blockquote>\n<p id=\"so_30821651_30821814_0\"><code>[C++11: 15.2/2]:</code> An object of any storage duration whose initialization or destruction is terminated by an exception will have destructors executed for all of its fully constructed subobjects (excluding the variant members of a union-like class), that is, for subobjects for which the principal constructor (12.6.2) has completed execution and the destructor has not yet begun execution. Similarly, if the non-delegating constructor for an object has completed execution and a delegating constructor for that object exits with an exception, the object\u2019s destructor will be invoked. If the object was allocated in a new-expression, the matching deallocation function (3.7.4.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.</p>\n</blockquote>\n", "CreationDate": "2015-06-13T17:56:34.767", "ParentId": "30821651", "Id": "30821814", "LastActivityDate": "2015-06-13T17:56:34.767", "PostTypeId": "2", "Score": "3", "OwnerUserId": "560648"}, "bq_ids": {"n4140": {"so_30821651_30821814_0": {"length": 58, "quality": 0.90625, "section_id": 3344}}, "n3337": {"so_30821651_30821814_0": {"length": 58, "quality": 0.90625, "section_id": 3214}}}});