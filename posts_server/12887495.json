post_cb({"bq_ids": {"n4140": {"so_12887495_12887534_0": {"length": 25, "quality": 1.0, "section_id": 3335}, "so_12887495_12887534_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3354}}, "n3337": {"so_12887495_12887534_0": {"length": 25, "quality": 1.0, "section_id": 3205}, "so_12887495_12887534_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3224}}, "n4659": {"so_12887495_12887534_0": {"length": 25, "quality": 1.0, "section_id": 4102}, "so_12887495_12887534_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 4121}}}, "12887729": {"Id": "12887729", "PostTypeId": "2", "Body": "<p>C++ destroy a local variable when unwinding stack(return from a function, either with <code>return</code> keyword or with an exception), so it should see one to destroy your <code>scoped_ptr</code>. But in your special case, exception occurred in <code>main</code> so <code>terminate</code> will be called and kill your program before C++ unwind the stack.</p>\n<pre><code>void test() {throw 1;}\nvoid main() {\n    string sMain;\n    test();\n}\n</code></pre>\n<p>In above example, <code>sMain</code> will not destroyed because exception cause calling <code>terminate</code>:</p>\n<pre><code>sMain constructed\nexception occurred: main has no where to go, and it has no handler to handle\n    the exception, so it will call `terminate`, but wait we are still at `main`\n    so we have no stack unwinding here and sMain will never destroyed!!\n</code></pre>\n", "LastEditorUserId": "1425813", "LastActivityDate": "2012-10-15T00:10:23.293", "Score": "0", "CreationDate": "2012-10-14T23:58:40.637", "ParentId": "12887495", "CommentCount": "2", "OwnerUserId": "1425813", "LastEditDate": "2012-10-15T00:10:23.293"}, "12887495": {"ViewCount": "543", "Body": "<p>I have just started using c++ boost libraries. I read in many places that when a scoped_ptr is used then the object is always destroyed even in case of exceptions.</p>\n<blockquote>\n<p id=\"so_12887495_12887495_0\"><a href=\"http://www.boost.org/libs/smart_ptr/\" rel=\"nofollow\">They behave much like built-in C++ pointers except that they automatically delete the object pointed to at the appropriate time. Smart pointers are particularly useful in the face of exceptions as they ensure proper destruction of dynamically allocated objects.</a> </p>\n</blockquote>\n<p>I tried in the following code.</p>\n<pre><code>#include&lt;boost/scoped_ptr.hpp&gt;\n\nclass B\n{\n  public:\n    B(){ std::cout&lt;&lt; \"B constructor call\\n\"; }\n    ~B(){ std::cout&lt;&lt;\"B destructor call\\n\"; }\n};\n\nclass A\n{\n  public:\n  boost::scoped_ptr&lt;B&gt; b;\n  A():b(new B())  \n  {\n    throw 1;\n  }\n};\n\nint main()\n{\n    A a; return 0;\n}\n\noutput:\nB constructor call\nterminate called after throwing an instance of 'int'\nAborted (core dumped)\n</code></pre>\n<p>There is no call to B's destructor. But I used scoped_ptr so it should have called B's destructor or did I mis-interpreted the use  of scoped_ptr. </p>\n<p>But if a surround it with try catch then B's destructor is called.</p>\n<pre><code>try{\n  A a;\n} catch( ... ) {\n}\n</code></pre>\n<p>In this case destructor of A will be called as all locally allocated objects in case of exception in a try block are removed from the stack and I have my pointer wrapped inside and object of scoped_ptr so when the destructor of scoped object destroys which ultimately the pointer. \nSo is scoped_ptr is useful because we don't have to explicitly delete the memory allocated or I mis-interpreted the description of scoped_ptr. </p>\n<p>How can I call the destructor of class B in case of exception using scoped_ptr </p>\n", "AcceptedAnswerId": "12887534", "Title": "destructor not called in case of exception with scoped_ptr", "CreationDate": "2012-10-14T23:17:43.933", "Id": "12887495", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-10-14T23:43:06.450", "LastEditorUserId": "636019", "LastActivityDate": "2012-10-15T00:10:23.293", "Score": "6", "OwnerUserId": "1203714", "Tags": "<c++><exception><boost><destructor><scoped-ptr>", "AnswerCount": "2"}, "12887534": {"Id": "12887534", "PostTypeId": "2", "Body": "<p>There's no matching exception handler, so <code>std::terminate</code> is called directly, in this case without the stack being unwound. Put a <code>try</code>/<code>catch</code> in <code>main</code> that catches <code>int</code> and you'll see your destructor call, even if that handler rethrows.</p>\n<p>C++11 \u00a715.1/2:</p>\n<blockquote>\n<p id=\"so_12887495_12887534_0\">When an exception is thrown, control is transferred to the nearest handler with a matching type; \"nearest\" means the handler for which the <em>compound-statement</em> or <em>ctor-initializer</em> following the <code>try</code> keyword was most recently entered by the thread of control and not yet exited.</p>\n</blockquote>\n<p>and \u00a715.3/9:</p>\n<blockquote>\n<p id=\"so_12887495_12887534_1\">If no matching handler is found, the function <code>std::terminate()</code> is called; whether or not the stack is unwound before this call to <code>std::terminate()</code> is implementation-defined.</p>\n</blockquote>\n<p><sub><a href=\"http://liveworkspace.org/code/21c86a6e614ac0e03fffd7f7a5db61fe\" rel=\"noreferrer\">Online demo</a></sub></p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2012-10-14T23:39:47.870", "Score": "15", "CreationDate": "2012-10-14T23:27:41.340", "ParentId": "12887495", "CommentCount": "5", "OwnerUserId": "636019", "LastEditDate": "2012-10-14T23:39:47.870"}});