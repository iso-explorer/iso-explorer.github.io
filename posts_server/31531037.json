post_cb({"31531580": {"ParentId": "31531037", "CommentCount": "2", "CreationDate": "2015-07-21T06:13:14.293", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "31531580", "Score": "3", "Body": "<p>Paxdiablo has answered pretty well, but some background might help.</p>\n<p>\"Lock-free atomic\" is a bit of redundant terminology. The point of atomic variables, as they were originally invented, is to avoid locks by leveraging hardware guarantees. But, each platform has its own limitations, and C++ is highly portable. So the implementation has to emulate atomicity (usually via the library) using fine-grained locks for atomic types that don't really exist at the hardware level.</p>\n<p>Behavioral differences are minimized between hardware atomics and \"software atomics,\" because differences would mean lost portability. On the other hand, a program should be able to avoid accidentally using mutexes, hence introspection through <code>ATOMIC_x_LOCK_FREE</code> which is available to the preprocessor.</p>\n", "LastActivityDate": "2015-07-21T06:13:14.293"}, "31531243": {"ParentId": "31531037", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-07-21T05:46:13.000", "Score": "8", "LastEditorUserId": "14860", "LastEditDate": "2015-07-21T07:12:01.793", "Id": "31531243", "OwnerUserId": "14860", "Body": "<p>There is at least <em>one</em> semantic difference.</p>\n<p>As per <code>C++11 1.9 Program execution /6</code>:</p>\n<blockquote>\n<p id=\"so_31531037_31531243_0\">When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects which are neither of type <code>volatile std::sig_atomic_t</code> nor lock-free atomic objects are unspecified during the execution of the signal handler, and the value of any object not in either of\n  these two categories that is modified by the handler becomes undefined.</p>\n</blockquote>\n<p>In other words, it's safe to muck about with those two categories of variables but any access or modification to all other categories should be avoided.</p>\n<p>Of course you could argue that it's no longer a well <em>defined</em> program if you invoke unspecified/undefined behaviour like that but I'm not entirely sure whether you meant that or well-formed (i.e., compilable).</p>\n<p>But, even if you discount that semantic difference, a <em>performance</em> difference is worth having. If I had to have a value for communicating between threads, I'd probably choose, in order of preference:</p>\n<ul>\n<li>the smallest adequate data type that was lock-free.</li>\n<li>a larger data type than necessary, if it was lock-free and the smaller one wasn't.</li>\n<li>a shared region fully capable of race conditions, but in conjunction with an <code>atomic_flag</code> (guaranteed to be lock-free) to control access.</li>\n</ul>\n<p>This behaviour could be selected at compile or run time based on the <code>ATOMIC_x_LOCK_FREE</code> macros so that, even though the program behaves the same regardless, the optimal <em>method</em> for that behaviour is chosen.</p>\n", "LastActivityDate": "2015-07-21T07:12:01.793"}, "31531037": {"CommentCount": "4", "AcceptedAnswerId": "31552232", "PostTypeId": "1", "LastEditorUserId": "541686", "CreationDate": "2015-07-21T05:28:25.743", "LastActivityDate": "2015-07-23T11:25:38.717", "LastEditDate": "2015-07-21T05:33:33.423", "ViewCount": "747", "FavoriteCount": "3", "Title": "Is the meaning of \"lock-free\" even defined by the C++ standard?", "Id": "31531037", "Score": "11", "Body": "<p>I can't find a semantic difference between lock-based and lock-free atomics. So far as I can tell, the difference is semantically meaningless as far as the language is concerned, since the language doesn't provide any timing guarantees. The only guarantees I can find are memory ordering guarantees, which seem to be the same for both cases.</p>\n<h3>(How) can the lock-free-ness of atomics affect program semantics?</h3>\n<p>i.e., aside from calling <code>is_lock_free</code> or <code>atomic_is_lock_free</code>, is it possible to write a well-defined program whose behavior is actually affected by whether atomics are lock-free?<br>\nDo those functions even have a semantic meaning? Or are they just practical hacks for writing responsive programs even though the language never provides timing guarantees in the first place?</br></p>\n", "Tags": "<c++><multithreading><c++11><atomic><lock-free>", "OwnerUserId": "541686", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_31531037_31552232_0": {"section_id": 5815, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_31531037_31531243_0": {"section_id": 5575, "quality": 1.0, "length": 31}}, "n4659": {"so_31531037_31552232_1": {"section_id": 7225, "quality": 0.8461538461538461, "length": 11}, "so_31531037_31552232_0": {"section_id": 7301, "quality": 0.8333333333333334, "length": 10}}}, "31552232": {"ParentId": "31531037", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-07-22T01:07:17.017", "Score": "5", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:20.917", "Id": "31552232", "OwnerUserId": "684921", "Body": "<p>In C++11 Standard, the term \"lock-free\" was not defined well as reported in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2075\" rel=\"nofollow noreferrer\">issue LWG #2075</a>.</p>\n<p>C++14 Standard define what <em>lock-free executions</em> is in C++ language (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3927.html\" rel=\"nofollow noreferrer\">N3927</a> approved).</p>\n<p>Quote C++14 1.10[intro.multithread]/paragraph 4:</p>\n<blockquote>\n<p id=\"so_31531037_31552232_0\">Executions of atomic functions that are either defined to be lock-free (29.7) or indicated as lock-free (29.4) are <em>lock-free executions</em>.</p>\n<ul>\n<li>If there is only one unblocked thread, a lock-free execution in that thread shall complete. [ Note: Concurrently executing threads may prevent progress of a lock-free execution. For example, this situation can occur with load-locked store-conditional implementations. This property is sometimes termed obstruction-free. -- end note ]</li>\n<li>When one or more lock-free executions run concurrently, at least one should complete. [ Note: It is difficult for some implementations to provide absolute guarantees to this effect, since repeated and particularly inopportune interference from other threads may prevent forward progress, e.g., by repeatedly stealing a cache line for unrelated purposes between load-locked and store-conditional instructions. Implementations should ensure that such effects cannot indefinitely delay progress under expected operating conditions, and that such anomalies can therefore safely be ignored by programmers. Outside this International Standard, this property is sometimes termed lock-free. -- end note ]</li>\n</ul>\n</blockquote>\n<p>Above definition of \"lock-free\" depends on what does unblocked thread behave. C++ Standard does not define <em>unblocked thread</em> directly, but 17.3.3[defns.blocked] defines <em>blocked thread</em>:</p>\n<blockquote>\n<p id=\"so_31531037_31552232_1\">a thread that is waiting for some condition (other than the availability of a processor) to be satisfied before it can continue execution</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_31531037_31552232_2\">(How) can the lock-free-ness of atomics affect program semantics?</p>\n</blockquote>\n<p>I think the answer is NO, except signal handler as <a href=\"https://stackoverflow.com/a/31531243/684921\">paxdiablo's answer</a>, when \"program semantics\" mean the side effects of atomic operations.\nThe lock-free-ness of atomic affect the <em>strength of progress guarantee</em> for whole multithreading program.\nWhen two (or more) threads concurrently execute lock-free atomic operations on same object, at least one of these operations should complete under <em>any</em> worst thread scheduling.\nIn other words, 'evil' thread scheduler could intentionally block progress of lock-based atomic operations in theory.</p>\n</hr>", "LastActivityDate": "2015-07-23T11:25:38.717"}});