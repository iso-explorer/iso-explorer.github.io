post_cb({"bq_ids": {"n4140": {"so_17536196_17536450_0": {"length": 9, "quality": 0.75, "section_id": 7041}, "so_17536196_17536450_4": {"length": 10, "quality": 1.0, "section_id": 5404}, "so_17536196_17536450_2": {"length": 16, "quality": 1.0, "section_id": 5404}, "so_17536196_17557626_0": {"length": 29, "quality": 1.0, "section_id": 5404}, "so_17536196_17536450_3": {"length": 19, "quality": 0.95, "section_id": 5402}, "so_17536196_17536450_1": {"length": 13, "quality": 1.0, "section_id": 5404}, "so_17536196_17536450_5": {"length": 8, "quality": 1.0, "section_id": 5882}, "so_17536196_17536243_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 7041}}, "n3337": {"so_17536196_17536450_0": {"length": 9, "quality": 0.75, "section_id": 6786}, "so_17536196_17536450_4": {"length": 10, "quality": 1.0, "section_id": 5199}, "so_17536196_17536450_2": {"length": 16, "quality": 1.0, "section_id": 5199}, "so_17536196_17557626_0": {"length": 29, "quality": 1.0, "section_id": 5199}, "so_17536196_17536450_3": {"length": 19, "quality": 0.95, "section_id": 5197}, "so_17536196_17536450_1": {"length": 13, "quality": 1.0, "section_id": 5199}, "so_17536196_17536450_5": {"length": 8, "quality": 1.0, "section_id": 5653}, "so_17536196_17536243_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 6786}}, "n4659": {"so_17536196_17536450_0": {"length": 9, "quality": 0.75, "section_id": 8538}, "so_17536196_17536450_4": {"length": 10, "quality": 1.0, "section_id": 6853}, "so_17536196_17536450_2": {"length": 16, "quality": 1.0, "section_id": 6853}, "so_17536196_17557626_0": {"length": 29, "quality": 1.0, "section_id": 6853}, "so_17536196_17536450_3": {"length": 18, "quality": 0.9, "section_id": 6849}, "so_17536196_17536450_1": {"length": 13, "quality": 1.0, "section_id": 6853}, "so_17536196_17536450_5": {"length": 7, "quality": 0.875, "section_id": 7365}, "so_17536196_17536243_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 8538}}}, "17557626": {"Id": "17557626", "PostTypeId": "2", "Body": "<p>Both compilers are correct. You are invoking undefined behavior for which no diagnostic is required per  7.1.2 para 2:</p>\n<blockquote>\n<p id=\"so_17536196_17557626_0\">An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly the same definition in every case (3.2). ... If a function with external linkage is declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required.</p>\n</blockquote>\n<p>GCC is free to do what it does and give you a program that just might happen to work. VC++ is equally valid in rejecting your code. </p>\n", "LastActivityDate": "2013-07-09T20:29:50.293", "CommentCount": "3", "CreationDate": "2013-07-09T20:29:50.293", "ParentId": "17536196", "Score": "5", "OwnerUserId": "774499"}, "17536243": {"Id": "17536243", "PostTypeId": "2", "Body": "<p>Inline functions should have a definition in every translation unit where used and in your case there is no one in <code>main.cpp</code></p>\n<blockquote>\n<p id=\"so_17536196_17536243_0\">The definition of an inline function doesn't have to be in a header\n  file but, because of the one definition rule for inline functions, an\n  identical definition for the function must exist in every translation\n  unit that uses it.</p>\n<p id=\"so_17536196_17536243_1\">The easiest way to achieve this is by putting the definition in a\n  header file.</p>\n<p id=\"so_17536196_17536243_2\">If you want to put the definition of a function in a single source\n  file then you shouldn't declare it inline. A function not declared\n  inline does not mean that the compiler cannot inline the function.</p>\n</blockquote>\n<p>By @CharlesBailey</p>\n<p>1 <b>Does either compiler have conforming behavior in this case?</b></p>\n<p>From this standard citation we can say that in this specific case VC is right.</p>\n<blockquote>\n<p id=\"so_17536196_17536243_3\">C++ Standard, \u00a73.2 One definition rule / 3: An inline function shall\n  be defined in every translation unit in which it is odr-used</p>\n</blockquote>\n<p>thanks @Pixelchemist</p>\n<p>2 <strong>Why does VC++ work if the method is non-virtual?</strong></p>\n<p>Accoring to the standard non-virtual functions are not \"One Definition Rule\" - used, so it allows to use it the way you want.</p>\n", "LastEditorUserId": "2149111", "LastActivityDate": "2013-07-08T21:44:56.400", "Score": "3", "CreationDate": "2013-07-08T21:25:59.823", "ParentId": "17536196", "CommentCount": "3", "OwnerUserId": "2149111", "LastEditDate": "2013-07-08T21:44:56.400"}, "17536196": {"ViewCount": "406", "Body": "<p><strong>GCC 4.7.2 compiles this code as follows:</strong></p>\n<ul>\n<li>The reference to <code>Obj::getNumber()</code> in <code>Obj::defaultNumber()</code> is inlined</li>\n<li>The body of <code>Obj::getNumber()</code> is separately compiled and exported and can be linked to from a different translation unit.</li>\n</ul>\n<p><strong>VC++2012 fails at the link step with:</strong></p>\n<ul>\n<li><code>Error    1   error LNK2001: unresolved external symbol \"public: virtual int __thiscall Obj::getNumber(unsigned int)\"</code> in <code>main.obj</code></li>\n</ul>\n<p>VC++ seems to be inlining the call within <code>Obj::defaultNumber()</code> but not exporting <code>getNumber()</code> in the symbol table.</p>\n<p><strong>VC++ can be made to compile it by one of the following:</strong></p>\n<ul>\n<li>Remove the <code>inline</code> keyword from the <code>getNumber()</code> definition, or</li>\n<li>Remove the <code>virtual</code> keyword from the <code>getNumber()</code> declaration <em>(Why!?)</em></li>\n</ul>\n<p>At first glance, GCC's behavior certainly seems more helpful/intuitive. Perhaps someone familiar with the Standard could point me in the right direction here.</p>\n<ul>\n<li><strong>Does either compiler have conforming behavior in this case?</strong></li>\n<li><strong>Why does VC++ work if the method is non-virtual?</strong></li>\n</ul>\n<p>.</p>\n<pre><code>// Obj.h\n\nclass Obj\n{\npublic:\n    virtual int getNumber(unsigned int i);\n    virtual int defaultNumber();\n};\n\n// Obj.cpp\n\nstatic const int int_table[2] = { -1, 1 };\n\ninline int Obj::getNumber(unsigned int i)\n{\n    return int_table[i];\n}\n\nint Obj::defaultNumber()\n{\n    return getNumber(0);\n}\n\n// main.cpp\n\n#include &lt;iostream&gt;\n#include \"Obj.h\"\n\nint main()\n{\n    Obj obj;\n    std::cout &lt;&lt; \"getNumber(1): \" &lt;&lt; obj.getNumber(1) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"defaultNumber(): \" &lt;&lt; obj.defaultNumber() &lt;&lt; std::endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "17536450", "Title": "Linking an inline virtual method", "CreationDate": "2013-07-08T21:22:24.930", "Id": "17536196", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-07-08T21:27:35.783", "LastEditorUserId": "629493", "LastActivityDate": "2013-12-24T10:49:31.307", "Score": "9", "OwnerUserId": "629493", "Tags": "<c++>", "AnswerCount": "3"}, "17536450": {"Id": "17536450", "PostTypeId": "2", "Body": "<p><sup>I changed the answer completely once, why not twice? It's quite late sorry for any typos.</sup></p>\n<h1>Short</h1>\n<h3>Does either compiler have conforming behavior in this case?</h3>\n<p>Both of them do. It's undefined behaviour.</p>\n<h3>Why does VC++ work if the method is non-virtual?</h3>\n<p>Because your code is non-standard conformant and the compiler can construe your code at its own discretion.</p>\n<h1>Long</h1>\n<h2>Why are the compilers conformant?</h2>\n<p>The standard says that a virtual member is used per one-definition rule if not pure and that every translation unit needs its own definition of an odr-used inline function.</p>\n<blockquote>\n<h3>\u00a7 3.2</h3>\n<p id=\"so_17536196_17536450_0\">2) <em>\"[...] A virtual member function is odr-used if it is not pure. [...]\"</em><br>\n  3) <em>\"[...] An inline function shall be defined in every translation unit in which it is odr-used. [...]\"</em></br></p>\n<h3>\u00a7 7.1.2</h3>\n<p id=\"so_17536196_17536450_1\">4) An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly the same definition in every case (3.2). [...]</p>\n</blockquote>\n<p>Additionally the standard requires the function to be declared inline within each translation unit but allows the compilers to omit any diagnostics. </p>\n<blockquote>\n<h3>\u00a7 7.1.2</h3>\n<p id=\"so_17536196_17536450_2\">4) [...] If a function with external linkage is declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required. [...]</p>\n</blockquote>\n<p>Since your <code>getNumber()</code> isn't declared inline in both <code>main.cpp</code> and <code>Obj.cpp</code> you're in the Land of undefined behaviour here.</p>\n<p><sub><strong>(edit)</strong> I interpret this (see standard quotes below) in a way that the compiler is not required to check whether the function is declared inline everywhere it appears. I don't know but suspect that this \"compilers don't have to check\"-rule doesn't refer to the sentence \"An inline function shall be defined in every translation unit in which it is odr-used[...]\".</sub></p>\n<p><sub>MSVC compiles even if <code>getNumber</code> is additionally defined in main (without ever being declared inline from main's point of view), even if the Obj.cpp implementation is still declared inline and present in the symbol table. This behaviour of the compiler is allowed by the standard even though the code is non-conformant: undefined behaviour (UB).<strong>(/edit)</strong></sub></p>\n<p><strong>Both compilers are therefore free to either accept and compile or reject your code.</strong></p>\n<h2>Why does VC++ work if the method is non-virtual?</h2>\n<p>The question here is: Why doesn't VC++ instantiate a the virtual inline function but does so if virtual is left out?</p>\n<p>You probably read those statements all around SO where it says \"UB may blow your house, kill your mum, end the world\" etc. I have no clue why there's no function instance if the function is virtual but otherwise there is. I guess that's what UB is about - weird things.</p>\n<h2>Why do both GCC and VS <sup>(without <code>virtual</code>)</sup> provide externally linked function instances of an inline function?</h2>\n<p>The compilers are not required to actually substitute the functions inline, they may well produce an instance of the function.\nSince inline functions have external linkage by default, this results in the possibility to call <code>getNumber</code> from main if there is an instance created. </p>\n<ul>\n<li>The compiler will just add an undefined external into the main.obj (no problem, it's not inline here).</li>\n<li>The linker will find the very same external symbol in the Obj.obj and link happily.</li>\n</ul>\n<blockquote>\n<h3>7.1.2</h3>\n<p id=\"so_17536196_17536450_3\">2) An implementation is not required to perform this inline substitution at the point of call; however, even if this inline substitution is omitted, the other rules for inline functions defined by 7.1.2 shall still be respected.  </p>\n<p id=\"so_17536196_17536450_4\">4) An inline function with external linkage shall have the same address in all translation units.</p>\n<h3>\u00a7 9.3</h3>\n<p id=\"so_17536196_17536450_5\">3) Member functions of a class in namespace scope have external linkage.</p>\n<h3><a href=\"http://msdn.microsoft.com/en-us/library/z8y1yy88%28v=vs.110%29.aspx\" rel=\"nofollow\">MSDN inline, __inline, __forceinline</a></h3>\n<p id=\"so_17536196_17536450_6\">The inline keyword tells the compiler that inline expansion is preferred. However, the compiler can create a separate instance of the function (instantiate) and <strong>create standard calling linkages</strong> instead of inserting the code inline. Two cases where this can happen are: </p>\n<ul>\n<li>Recursive functions.</li>\n<li>Functions that are referred to through a pointer elsewhere in the translation unit.</li>\n</ul>\n<p id=\"so_17536196_17536450_7\">These reasons may interfere with inlining, <strong>as may others</strong>, at the discretion of the compiler; you should not depend on the inline specifier to cause a function to be inlined.</p>\n</blockquote>\n<p>So probably there is one of the \"other\" reasons that makes the compiler instantiate it and create a symbol that is used by main.obj but I can't tell why that reason disappears if the function is <code>virtual</code>.</p>\n<h2>Conclusion:</h2>\n<p>The compiler may or may not instantiate an inline function and it may or may not accept the same function being inline in one and non-inline in another translation unit. To have your behaviour defined you need to</p>\n<ul>\n<li>Have every declaration of your function inline or have all of them non-inline</li>\n<li>Provide a separate definition of an inline function for every translation unit (i.e. inline definition in the header or separate definitions in the source files) </li>\n</ul>\n", "LastEditorUserId": "85662", "LastActivityDate": "2013-12-24T10:49:31.307", "Score": "8", "CreationDate": "2013-07-08T21:40:17.797", "ParentId": "17536196", "CommentCount": "8", "OwnerUserId": "951423", "LastEditDate": "2013-12-24T10:49:31.307"}});