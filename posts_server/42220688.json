post_cb({"bq_ids": {"n4140": {"so_42220688_42220956_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 7043}}, "n3337": {"so_42220688_42220956_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 6788}}, "n4659": {"so_42220688_42220956_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 8540}}}, "42220688": {"ViewCount": "134", "Body": "<p>I know, there are many answered question about linkage of a static (constexpr) members.</p>\n<p>But I wonder, why using a template class out-of-line definition works in a header file but not for a specialized class.</p>\n<p>a) This works without linker error:</p>\n<pre><code>template&lt;typename, typename&gt;\nstruct Foobar;\n\ntemplate&lt;typename T&gt;\nstruct Foobar&lt;int, T&gt; {\n  static constexpr std::array&lt;int, 1&gt; a = {{1}};\n};\n\ntemplate&lt;typename T&gt;\nconstexpr std::array&lt;int, 1&gt; Foobar&lt;int, T&gt;::a;\n\n// foo.cpp\nstd::cout &lt;&lt; Foobar&lt;int, int&gt;::a[0] &lt;&lt; \"\\n\";\n\n// bar.cpp\nstd::cout &lt;&lt; Foobar&lt;int, int&gt;::a[0] &lt;&lt; \"\\n\";\n</code></pre>\n<p>The objdump of:</p>\n<p>foo.o: <code>0000000000000000  w    O .rodata._Z6FoobarIiiE1aE    0000000000000004 _Z6FoobarIiiE1aE</code></p>\n<p>bar.o: <code>0000000000000000  w    O .rodata._Z6FoobarIiiE1aE    0000000000000004 _Z6FoobarIiiE1aE</code></p>\n<p>Linked file: <code>0000000000475a30  w    O .rodata  0000000000000004 _Z6FoobarIiiE1aE</code></p>\n<p>b) This does not (multiple definition):</p>\n<pre><code>template&lt;typename&gt;\nstruct Foobar;\n\ntemplate&lt;&gt;\nstruct Foobar&lt;int&gt; {\n  static constexpr std::array&lt;int, 1&gt; a = {{1}};\n};\nconstexpr std::array&lt;int, 1&gt; Foobar&lt;int&gt;::a;\n\n// foo.cpp\nstd::cout &lt;&lt; Foobar&lt;int&gt;::a[0] &lt;&lt; \"\\n\";\n\n// bar.cpp\nstd::cout &lt;&lt; Foobar&lt;int&gt;::a[0] &lt;&lt; \"\\n\";\n</code></pre>\n<p>The objdump of:</p>\n<p>foo.o <code>0000000000000100 g     O .rodata        0000000000000004 _Z6FoobarIiE1aE</code></p>\n<p>bar.o: <code>0000000000000420 g     O .rodata        0000000000000004 _Z6FoobarIiE1aE</code></p>\n<p>What we see, the out-of-line definition has different addresses inside the object files (example b)).</p>\n<p>My question to you:</p>\n<ol>\n<li>Is it save to use the template trick? What are the disadvantage?</li>\n<li>Would it be useful to relax the definition of odr for such cases like b in the future?</li>\n</ol>\n<p>Thank you in advance!</p>\n", "AcceptedAnswerId": "42220956", "Title": "ODR of template class with static constexpr member", "CreationDate": "2017-02-14T07:57:29.347", "Id": "42220688", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-02-14T08:16:07.217", "Score": "1", "OwnerUserId": "1611317", "Tags": "<c++><c++11><c++14><constexpr><one-definition-rule>", "AnswerCount": "1"}, "42220956": {"Id": "42220956", "PostTypeId": "2", "Body": "<p>See [basic.def.odr]/6:</p>\n<blockquote>\n<p id=\"so_42220688_42220956_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with\n  external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member\n  of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for\n  which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements. ...</p>\n</blockquote>\n<p>The effect of this rule is that every <em>template-declaration</em> behaves as though it is inline. (But it does not extend to <em>explicit-instantiation</em> and <em>explicit-specialization</em> declarations.)</p>\n<p>In the first snippet, you have</p>\n<pre><code>template&lt;typename T&gt;\nconstexpr std::array&lt;int, 1&gt; Foobar&lt;int, T&gt;::a;\n</code></pre>\n<p>which is a <em>template-declaration</em> and therefore is allowed to be multiply defined. In the second snippet, you have</p>\n<pre><code>constexpr std::array&lt;int, 1&gt; Foobar&lt;int&gt;::a;\n</code></pre>\n<p>which is not a <em>template-declaration</em>: the definition itself is not templated, even though the thing being defined happens to be a specialization of a template.</p>\n<blockquote>\n<p id=\"so_42220688_42220956_1\">My question to you:</p>\n<ol>\n<li>Is it save to use the template trick? What are the disadvantage?</li>\n</ol>\n</blockquote>\n<p>There is no \"trick\" here. If you want to define the member for <em>all</em> <code>Foo&lt;T&gt;</code>, then you have no choice but to put the definition in the header file. If you want to define the member for <em>one specific</em> <code>Foo&lt;T&gt;</code> such as <code>Foo&lt;int&gt;</code>, then you must not put the definition in the header file (until C++17, which introduces inline variables.) There is no trick because what you are supposed to do depends on your specific goal.</p>\n<p>(Your second question was answered in the comment section.)</p>\n", "LastActivityDate": "2017-02-14T08:16:07.217", "CommentCount": "0", "CreationDate": "2017-02-14T08:16:07.217", "ParentId": "42220688", "Score": "3", "OwnerUserId": "481267"}});