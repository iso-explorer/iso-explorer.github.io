post_cb({"3028632": {"CommentCount": "4", "AcceptedAnswerId": "8621112", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2010-06-12T12:19:57.290", "LastActivityDate": "2011-12-23T23:58:15.980", "LastEditDate": "2011-12-23T17:49:30.073", "ViewCount": "895", "FavoriteCount": "1", "Title": "Move from *this in an rvalue method?", "Id": "3028632", "Score": "10", "Body": "<p>In C++11, methods can be overloaded on whether or not the expression that denotes the object on which the method is called is an lvalue or an rvalue. If I return <code>*this</code> from a method called via an rvalue, do I need to explicitly <code>move</code> from <code>*this</code> or not?</p>\n<pre><code>Foo Foo::method() &amp;&amp;\n{\n    return std::move(*this);   // Is this move required or not?\n}\n</code></pre>\n<p>Unfortunately, I can't simply test this on my compiler since g++ does not support this feature yet :(</p>\n", "Tags": "<c++><c++11><rvalue-reference>", "OwnerUserId": "252000", "AnswerCount": "1"}, "8621112": {"ParentId": "3028632", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The type of <code>*this</code> is <em>always</em> an lvalue:</p>\n<p><code>\u00a79.3.2 [class.this] p1</code></p>\n<blockquote>\n<p id=\"so_3028632_8621112_0\">In the body of a non-static (9.3) member function, the keyword <strong><code>this</code></strong> is a prvalue expression whose value is the address of the object for which the function is called. The type of <strong><code>this</code></strong> in a member function of a class <strong><code>X</code></strong> is <strong><code>X*</code></strong>. [...]</p>\n</blockquote>\n<p><code>\u00a75.3.1 [expr.unary.op] p1</code></p>\n<blockquote>\n<p id=\"so_3028632_8621112_1\">The unary <strong><code>*</code></strong> operator performs <em>indirection</em>: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and <strong>the result is an lvalue</strong> referring to the object or function to which the expression points.</p>\n</blockquote>\n<p>So you will need to <code>std::move</code> if you want to invoke the move constructor.</p>\n<p>The following code snippet shows that:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct test{\n  test(){}\n  test(test const&amp;){ std::cout &lt;&lt; \"copy ctor // #1\\n\"; }\n  test(test&amp;&amp;){ std::cout &lt;&lt; \"move ctor // #2\\n\"; }\n\n  test f_no_move() &amp;&amp;{ return *this; }\n  test f_move() &amp;&amp;{ return std::move(*this); }\n};\n\nint main(){\n  test().f_no_move(); // #1\n  test().f_move(); // #2\n}\n</code></pre>\n<p>Using Clang 3.1 (the only compiler I know that implements ref-qualifiers), I get the following output:</p>\n<blockquote>\n<p id=\"so_3028632_8621112_2\">$ clang++ -std=c++0x -stdlib=libc++ -pedantic -Wall t.cpp<br>\n  $ ./a.out<br>\n  copy ctor // #1<br>\n  move ctor // #2</br></br></br></p>\n</blockquote>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-12-23T23:58:15.980", "Id": "8621112", "Score": "4", "CreationDate": "2011-12-23T22:17:42.323", "LastActivityDate": "2011-12-23T23:58:15.980"}, "bq_ids": {"n4140": {"so_3028632_8621112_0": {"section_id": 5895, "quality": 0.9444444444444444, "length": 17}, "so_3028632_8621112_1": {"section_id": 6064, "quality": 0.9, "length": 18}}, "n3337": {"so_3028632_8621112_0": {"section_id": 5666, "quality": 0.9444444444444444, "length": 17}, "so_3028632_8621112_1": {"section_id": 5832, "quality": 0.9, "length": 18}}, "n4659": {"so_3028632_8621112_0": {"section_id": 7378, "quality": 0.9444444444444444, "length": 17}, "so_3028632_8621112_1": {"section_id": 7560, "quality": 0.9, "length": 18}}}});