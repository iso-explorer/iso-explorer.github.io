post_cb({"45019980": {"CommentCount": "0", "CreationDate": "2017-07-10T19:14:48.287", "PostTypeId": "1", "AcceptedAnswerId": "45020525", "LastEditorUserId": "1013719", "LastActivityDate": "2017-07-13T14:38:01.183", "LastEditDate": "2017-07-10T20:42:09.147", "ViewCount": "300", "FavoriteCount": "4", "Title": "Redefinitions of constexpr static data members are allowed now? (but not inline const)?", "Id": "45019980", "Score": "14", "Body": "<p>The following fails to compile under both gcc and clang in c++14, but succeeds with c++1z:</p>\n<pre><code>struct Cls {\n  static constexpr int N = 0;\n};\nconstexpr int Cls::N;\nconstexpr int Cls::N;\n</code></pre>\n<p>The C++14 error is predictable: <code>redefinition of \u2018constexpr const int Cls::N\u2019</code></p>\n<p>What changed to make this legal? I found:</p>\n<blockquote>\n<p id=\"so_45019980_45019980_0\"><em>n4659 10.1.5 [dcl.constexpr]</em></p>\n<p id=\"so_45019980_45019980_1\">A function or static data member declared with the constexpr\n  specifier is implicitly an inline function or variable</p>\n</blockquote>\n<p>So I thought it might have to do with inline variables, but the following fails for c++1z under both compilers</p>\n<pre><code>struct Cls {\n  static inline const int N = 0;\n};\ninline const int Cls::N; // note, only one definition here\n</code></pre>\n", "Tags": "<c++><c++14><c++1z>", "OwnerUserId": "1013719", "AnswerCount": "1"}, "45020525": {"ParentId": "45019980", "LastEditDate": "2017-07-13T14:38:01.183", "CommentCount": "0", "CreationDate": "2017-07-10T19:55:23.060", "OwnerUserId": "27302", "LastEditorUserId": "1013719", "PostTypeId": "2", "Id": "45020525", "Score": "12", "Body": "<p>Before C++17, you needed to re-declare all <code>static</code> variables outside the class in exactly one translation unit (typically each translation unit is a <code>.cpp</code> file and vice versa, but this isn\u2019t required). As you pointed out, C++17 introduces <code>inline</code> class member variables, and <code>static constexpr</code> variables automatically qualify. You are <em>not</em> allowed to redeclare <code>inline</code> variables outside the class, as you saw in your second example, but an exception was made for <code>constexpr</code> because previously you were allowed (and in fact required) to do so, but the syntax is deprecated.</p>\n<p>In [class.static.data]p2, it allows that syntax for non-inline members (\u201cThe declaration of a non-inline static data member in its class definition is not a definition and may be of\nan incomplete type other than cv void. The definition for a static data member that is not defined inline\nin the class definition shall appear in a namespace scope enclosing the member\u2019s class definition.\u201d)</p>\n<p>In the next paragraph, the standard allows <code>constexpr</code> outside-of-class declarations and requires them for non-<code>constexpr</code> data (emphasis added):</p>\n<blockquote>\n<p id=\"so_45019980_45020525_0\">If a non-volatile non-inline <code>const</code> static data member is of integral or enumeration type, its declaration\n  in the class definition can specify a <em>brace-or-equal-initializer</em> in\n  which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a\n  constant expression (8.20). The member shall still be defined in a\n  namespace scope if it is odr-used (6.2) in the program and the\n  namespace scope definition shall not contain an <em>initializer</em>. An inline\n  static data member may be defined in the class definition\n  and may specify a <em>brace-or-equal-initializer</em>. <strong>If the member is\n  declared with the <code>constexpr</code> specifier, it may be redeclared in\n  namespace scope with no initializer</strong> (this usage is deprecated; see\n  D.1). Declarations of other static data members shall not specify a\n  <em>brace-or-equal-initializer</em>.</p>\n</blockquote>\n<p>And here\u2019s the deprecation note, D.1 Redeclaration of static constexpr data members [depr.static_constexpr]:</p>\n<blockquote>\n<p id=\"so_45019980_45020525_1\">For compatibility with prior C++ International Standards, a constexpr static data member may be redundantly redeclared outside the\n  class with no initializer. This usage is deprecated. [ <em>Example:</em></p>\n<pre><code>struct A {\n  static constexpr int n = 5; // definition (declaration in C++ 2014)\n};\nconstexpr int A::n; // redundant declaration (definition in C++ 2014)\n</code></pre>\n<p id=\"so_45019980_45020525_2\"><em>\u2014 end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2017-07-13T14:38:01.183"}, "bq_ids": {"n4140": {"so_45019980_45019980_1": {"section_id": 48, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_45019980_45019980_1": {"section_id": 254, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_45019980_45020525_0": {"section_id": 7390, "quality": 0.96875, "length": 62}, "so_45019980_45019980_1": {"section_id": 6839, "quality": 1.0, "length": 11}, "so_45019980_45020525_1": {"section_id": 6305, "quality": 0.8421052631578947, "length": 16}}}});