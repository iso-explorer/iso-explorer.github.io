post_cb({"24964971": {"ParentId": "24964760", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Consider this code, which is perfectly legal C++ and <a href=\"http://coliru.stacked-crooked.com/a/e84a6d8502bdc3a6\" rel=\"nofollow\">compiles and runs fine</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nclass Outer\n{\nprivate:\n    struct Inner { };\n};\n\ntemplate &lt;typename T&gt;\nvoid testFunction (const typename Outer&lt;T&gt;::Inner* p)\n{\n    std::cout &lt;&lt; \"Hello!\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;&gt;\nclass Outer&lt;double&gt;{\npublic:\n    struct Inner { };\n};\n\nint main()\n{\n    Outer&lt;double&gt;::Inner i;\n    testFunction&lt;double&gt;(&amp;i);\n    return 0;\n}\n</code></pre>\n<p>The compiler can't issue a diagnostic at <code>Outer&lt;T&gt;::Inner</code> because it doesn't know if there's going to be an explicit specialization of <code>Outer</code> later on that makes the function well-formed. When you later attempt to call <code>testFunction&lt;int&gt;</code>, SFINAE kicks in to remove the ill-formed function signature (because <code>Inner</code> is private) from the overload set, giving you a \"no matching function\" error.</p>\n<p>However, when you write <code>Outer&lt;int&gt;::Inner</code> in your function definition (as in your <code>testUntemplated</code>), that's going to trigger an implicit instantiation unless there's an explicit specialization for <code>Outer&lt;int&gt;</code> previously declared. The compiler need not worry about later explicit specializations because the standard requires explicit specializations to be declared before anything that can trigger an implicit instantiation (\u00a714.7.3 [temp.expl.spec]/p6):</p>\n<blockquote>\n<p id=\"so_24964760_24964971_0\">If a template, a member template or a member of a class template is\n  explicitly specialized then that specialization shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<p>Finally, note that compilers are not required to generate a diagnostic for a template with no valid specialization if it is never instantiated (\u00a714.6 [temp.res]/p8):</p>\n<blockquote>\n<p id=\"so_24964760_24964971_1\">If no valid specialization can be generated for a template, and that\n  template is not instantiated, the template is ill-formed, no\n  diagnostic required.</p>\n</blockquote>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-07-25T21:56:20.037", "Id": "24964971", "Score": "1", "CreationDate": "2014-07-25T21:44:15.673", "LastActivityDate": "2014-07-25T21:56:20.037"}, "bq_ids": {"n4140": {"so_24964760_24964971_1": {"section_id": 175, "quality": 1.0, "length": 11}, "so_24964760_24964971_0": {"section_id": 268, "quality": 1.0, "length": 29}}, "n3337": {"so_24964760_24964971_1": {"section_id": 169, "quality": 1.0, "length": 11}, "so_24964760_24964971_0": {"section_id": 259, "quality": 1.0, "length": 29}}, "n4659": {"so_24964760_24964971_1": {"section_id": 180, "quality": 0.8181818181818182, "length": 9}, "so_24964760_24964971_0": {"section_id": 275, "quality": 1.0, "length": 29}}}, "24964972": {"ParentId": "24964760", "CommentCount": "0", "Body": "<p>Your main question:</p>\n<blockquote>\n<p id=\"so_24964760_24964972_0\">Why is using a private inner class as parameter an error in the header in one case, and in the calling function in the other?</p>\n</blockquote>\n<p>When the compiler processes the following line in <code>Other::main</code>,</p>\n<pre><code>testFunction&lt;T&gt;(foo.ptr); \n</code></pre>\n<p>it tries to create an instance of <code>testFunction</code>. At that time, it finds that <code>T::Inner</code> is a private class of <code>T</code>. The problem is still with <code>testFunction</code>. In the second case, the line that is being processed when the problem is encountered is in <code>Other::main</code>.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "24964972", "Score": "0", "CreationDate": "2014-07-25T21:44:17.580", "LastActivityDate": "2014-07-25T21:44:17.580"}, "24964760": {"CommentCount": "3", "ViewCount": "338", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-07-25T21:27:25.957", "LastActivityDate": "2014-07-25T21:56:20.037", "Title": "Why is using a private inner class as parameter an error in the header in one case, and in the calling function in the other?", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:11:39.363", "Id": "24964760", "Score": "1", "Body": "<p>I'm trying to build a templated C++ function that accepts, as its argument, a pointer to an object of an inner class.  (An earlier difficulty I had on this problem can be seen in \"<a href=\"https://stackoverflow.com/questions/24942729/how-to-make-c-find-templated-function-header-when-dependent-scoped-inner-class/24943089#24943089\">How to make C++ find templated function header when dependent-scoped inner classes are involved?</a>\".)  At one point I was having a problem that turned out to be an access control issue; I've figured out how to avoid the problem, but I'm still sort of shaky on why this problem was reported in the way it was (which sent me down a garden path in terms of tracking down the problem).</p>\n<p>Basically, I was trying to call the function, with a private-inner-class object as a parameter, from a method inside a <code>friend</code> class (which therefore possesses the required access privilege).  The problem, of course, was that the non-method function was <em>not</em> a <code>friend</code> and so didn't have access to the inner class.  But the compiler reported it as a header mismatch rather than an access problem.</p>\n<p>First, the setup.  My data class has the following general structure:</p>\n<pre><code>template &lt;typename T&gt;\nclass Outer\n{\n  private:\n  struct Inner\n  {\n    T val;\n    Inner (T v) : val(v) { }\n  };\n\n  public:\n  Inner* ptr = nullptr;\n\n  friend class Other;\n};\n</code></pre>\n<p>If I write a simple function that is <em>not</em> templated and tries to take an <code>Inner*</code> as a parameter, the compiler correctly diagnoses the problem:</p>\n<pre><code>void testUntemplated (const Outer&lt;int&gt;::Inner* p)\n{\n  cout &lt;&lt; p-&gt;val &lt;&lt; endl;\n}\n</code></pre>\n<p>Without even calling this function, as soon as it is defined, <code>g++</code> tells me <code>error: \u2018struct Outer&lt;int&gt;::Inner\u2019 is private</code>, and <code>clang++</code> tells me <code>error: 'Inner' is a private member of 'Outer&lt;int&gt;'</code>.  Super-duper.</p>\n<p>But now consider this templated function, called from within a class:</p>\n<pre><code>template &lt;typename T&gt;\nvoid testFunction (const typename Outer&lt;T&gt;::Inner* p)\n{\n  cout &lt;&lt; p-&gt;val &lt;&lt; endl;\n}\n\nstruct Other {\n  template&lt;typename T&gt;\n  static void main(const Outer&lt;T&gt;&amp; foo)\n  {\n    testFunction&lt;T&gt;(foo.ptr);  //this line is flagged as the error\n  }\n};\n</code></pre>\n<p>Even though <code>Outer</code> is already defined, and <code>Inner</code> is private---regardless of the typename that is used to fill in for <code>T</code>---the function definition passes through without error; in this case it is the <em>call</em> to <code>testFunction</code> that is flagged, with the singularly unhelpful message <code>error: no matching function for call to \u2018testFunction(Outer&lt;int&gt;::Inner* const&amp;)\u2019</code> in <code>g++</code>.  Happily, <code>clang++</code> does a bit better: it flags the same line with an error (<code>error: no matching function for call to 'testFunction'</code>) but follows this up with an explanatory note (<code>note: candidate template ignored: substitution failure [with T = int]: 'Inner' is a private member of 'Outer&lt;int&gt;'</code>).</p>\n<p>But even though the more-helpful <code>clang++</code> has found what I see as the actual source of error here (the defined function doesn't have access to the type of its parameter), it still says the error lies in the call, not the definition, and I've learned that this sort of mismatch usually means I've found some corner of C++ that I don't understand as well as I should (especially when different compilers have the same seemingly-weird error behaviour).  What actually is going on here?  Why can't it reject the templated function in exactly the same way that it rejects the regular function?</p>\n", "Tags": "<c++><templates><inner-classes><private-members>", "OwnerUserId": "2566613", "AnswerCount": "2"}});