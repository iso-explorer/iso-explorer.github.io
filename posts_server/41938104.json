post_cb({"bq_ids": {"n4140": {"so_41938104_41938247_0": {"length": 10, "quality": 1.0, "section_id": 335}}, "n3337": {"so_41938104_41938247_0": {"length": 10, "quality": 1.0, "section_id": 325}}, "n4659": {"so_41938104_41938247_0": {"length": 10, "quality": 1.0, "section_id": 344}}}, "41938104": {"ViewCount": "123", "Body": "<p>I need to specialized a member function:</p>\n<pre><code>template &lt;typename T&gt;\nint32_t writeVectorVariableUnit(\n    foo&amp; classFoo,\n    typename std::vector&lt;T&gt;::const_iterator&amp; start,\n    typename std::vector&lt;T&gt;::const_iterator&amp; stop,\n    const std::string&amp; name,\n    const std::string&amp; unit,\n    const std::string&amp; longName,\n    const std::vector&lt;std::string&gt;&amp; dimName) const\n</code></pre>\n<p>in this way:</p>\n<pre><code>template &lt;&gt;\nint32_t writeVectorVariableUnit(\n    foo&amp; classFoo,\n    std::vector&lt;uint16_t&gt;::const_iterator&amp; start,\n    std::vector&lt;uint16_t&gt;::const_iterator&amp; stop,\n    const std::string&amp; name,\n    const std::string&amp; unit,\n    const std::string&amp; longName,\n    const std::vector&lt;std::string&gt;&amp; dimName) const;\n</code></pre>\n<p>but the g++ compiler (version 4.4.7 on a redhat 6.7) complains that is not able to match any template declaration:</p>\n<blockquote>\n<p id=\"so_41938104_41938104_0\">error: template-id \u2018writeVectorVariableUnit&lt;&gt;\u2019 for \u2018int32_t\n  writeVectorVariableUnit(foo&amp;, __gnu_cxx::__normal_iterator &gt; &gt;&amp;, __gnu_cxx::__normal_iterator &gt; &gt;&amp;, const std::string&amp;, const std::string&amp;, const std::string&amp;,\n  const std::vector,\n  std::allocator &gt;, std::allocator, std::allocator &gt; &gt; &gt;&amp;) const\u2019 does not\n  match any template declaration</p>\n</blockquote>\n<p>I suspect that is related with the usage of typename, I try several combination without success. \nDo you have any suggestion? </p>\n", "AcceptedAnswerId": "41938247", "Title": "c++ template specialization, error when using typename", "CreationDate": "2017-01-30T14:17:48.880", "LastActivityDate": "2017-01-30T15:24:10.323", "CommentCount": "0", "LastEditDate": "2017-01-30T14:39:21.120", "PostTypeId": "1", "Tags": "<c++><c++11><templates><template-specialization>", "Id": "41938104", "AnswerCount": "2", "Score": "2", "OwnerUserId": "7490134", "ClosedDate": "2017-01-30T15:32:55.187", "LastEditorUserId": "3309790"}, "41938509": {"Id": "41938509", "PostTypeId": "2", "Body": "<p>I beleive T here is actually in a non deduced context, so the function cannot actually deduce T (<a href=\"https://stackoverflow.com/questions/15208628/why-does-iterator-type-deduction-fail\">see this question</a>)</p>\n<p>worst case you could do:</p>\n<pre><code>writeVectorVariableUnit&lt;float&gt;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/0f03f4bc1d96ef07\" rel=\"nofollow noreferrer\">live demo</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-30T14:37:29.517", "Score": "0", "CreationDate": "2017-01-30T14:37:29.517", "ParentId": "41938104", "CommentCount": "0", "OwnerUserId": "2325752", "LastEditDate": "2017-05-23T12:09:08.813"}, "41938247": {"Id": "41938247", "PostTypeId": "2", "Body": "<p>The issues have nothing to do with the usage of <code>typename</code>, they are</p>\n<ol>\n<li><p>You should specialize the template out of the class definition.</p></li>\n<li><p>For <code>std::vector&lt;uint16_t&gt;::const_iterator</code>, <code>T</code> can't be deduced as <code>uint16_t</code> because this belongs to <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction#Non-deduced_contexts\" rel=\"nofollow noreferrer\">non-deduced contexts</a>. That means you have to specify the specialized template parameter explicitly.</p></li>\n</ol>\n<blockquote>\n<p id=\"so_41938104_41938247_0\">If a template parameter is used only in non-deduced contexts and is\n  not explicitly specified, template argument deduction fails.</p>\n<p id=\"so_41938104_41938247_1\">1) The nested-name-specifier (everything to the left of the scope\n  resolution operator ::) of a type that was specified using a\n  qualified-id:</p>\n</blockquote>\n<p>e.g.</p>\n<pre><code>template &lt;&gt;\nint32_t bar::writeVectorVariableUnit&lt;uint16_t&gt; (\n//      ~~~~~                       ~~~~~~~~~~\n    foo&amp; classFoo,\n    std::vector&lt;uint16_t&gt;::const_iterator&amp; start,\n    std::vector&lt;uint16_t&gt;::const_iterator&amp; stop,\n    const std::string&amp; name,\n    const std::string&amp; unit,\n    const std::string&amp; longName,\n    const std::vector&lt;std::string&gt;&amp; dimName) const {\n    // ...\n}\n</code></pre>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-01-30T15:24:10.323", "Score": "3", "CreationDate": "2017-01-30T14:24:49.433", "ParentId": "41938104", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2017-01-30T15:24:10.323"}});