post_cb({"bq_ids": {"n4140": {"so_44088682_44091763_0": {"length": 31, "quality": 1.0, "section_id": 526}}, "n3337": {"so_44088682_44091763_0": {"length": 31, "quality": 1.0, "section_id": 517}}, "n4659": {"so_44088682_44091763_0": {"length": 31, "quality": 1.0, "section_id": 547}}}, "44088742": {"Id": "44088742", "PostTypeId": "2", "Body": "<p>You can't do that.</p>\n<p>The preprocessor has much, much less requirements on syntax than the compiler, but what you're feeding it still has to be a series of valid tokens, and an unterminated string literal is not a valid token.</p>\n", "LastEditorUserId": "3233393", "LastActivityDate": "2017-05-20T17:21:42.573", "Score": "3", "CreationDate": "2017-05-20T17:13:14.707", "ParentId": "44088682", "CommentCount": "0", "LastEditDate": "2017-05-20T17:21:42.573", "OwnerUserId": "3233393"}, "44088682": {"ViewCount": "74", "Body": "<pre><code>#include &lt;iostream&gt;\n\n#define DEF(A) #A\n\nint main()\n{\n    std::cout &lt;&lt; DEF(qwer) &lt;&lt; std::endl; //prints: qwer\n    std::cout &lt;&lt; DEF(\"qwer\") &lt;&lt; std::endl; //prints: \"qwer\"\n    std::cout &lt;&lt; DEF(\"qwer) &lt;&lt; std::endl; //error, but I want to print \"qwer without a second quote\n}\n</code></pre>\n<p>How to pass an argument with only one quote to a macro?</p>\n", "AcceptedAnswerId": "44088742", "Title": "Passing quote symbol to macro", "CreationDate": "2017-05-20T17:06:55.533", "Id": "44088682", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-05-20T23:28:43.473", "Score": "0", "OwnerUserId": "3514538", "Tags": "<c++><preprocessor>", "AnswerCount": "2"}, "44091763": {"Id": "44091763", "PostTypeId": "2", "Body": "<p>If your system uses ASCII / ISO 8859-k as its single-byte encoding -- which is not fully portable but exceptions are pretty uncommon these days -- then you could write:</p>\n<pre><code>std::cout &lt;&lt; DEF(\\x22qwer) &lt;&lt; std::endl;\n</code></pre>\n<p>Note that the apparently similar</p>\n<pre><code>std::cout &lt;&lt; DEF(\\u022qwer) &lt;&lt; std::endl;\n</code></pre>\n<p>will not work. In order to understand why not, it's important to understand why (or how) the first one works, because the mechanism is not as obvious as it might appear.</p>\n<p>The input to the compiler must consist of a series of tokens and whitespace, and the argument to the <code>DEF</code> function is not an exception. When the compiler is initially tokenising the line including the <code>DEF</code> function, it does not know that its argument will be stringified, so the argument must be decomposable into tokens.</p>\n<p>Fortunately, the preprocessor is very liberal in what it considers a token. For C++, the possible preprocessor tokens are: (\u00a72.4 [lex.pptoken])</p>\n<pre><code>header-name\nidentifier\npp-number\ncharacter-literal\nuser-defined-character-literal\nstring-literal\nuser-defined-string-literal\npreprocessing-op-or-punc\neach non-white-space character that cannot be one of the above\n</code></pre>\n<p><code>\\x22qwer</code> does not qualify as any of the above, but <code>\\</code> is a non-white-space character that cannot be one of the other tokens and <code>x22qwer</code> is an <code>identifier</code>. So the argument to <code>DEF</code> contains two tokens without intervening whitespace, and the stringify operator dutifully turns that into a string literal, which is then reinterpreted according to the string literal rules, in which the consecutive characters <code>\\x22</code> are replaced with a double quote (or whatever character corresponds to 0x22 in the execution character encoding).</p>\n<p>On the other hand, <code>DEF(\\u0022qwer)</code> will not work. The reason is that <code>\\u022</code> is a <em>universal-character-name</em>, so <code>\\u022qwer</code> satisfies the lexical production for an <em>identifier</em>. That makes it a single token. But it is not a valid identifier token because <code>\\u0022</code> is not in the list of universal character names which are valid identifier characters (according to \u00a72.10 [lex.name] Table 2).</p>\n<p>If you've skimmed the detailed description for the stringify operator, you might be surprised that the backslash is passed through unchanged by the stringify operation. A close reading is required.  \u00a716.3.2 [cpp.stringize]:</p>\n<blockquote>\n<p id=\"so_44088682_44091763_0\">the original spelling of each preprocessing token in the argument is retained in the character string literal, except for special handling for producing the spelling of string literals and character literals: a <kbd>\\</kbd> character is inserted before each <kbd>\"</kbd> and <kbd>\\</kbd> character of a character literal or string literal (including the delimiting <kbd>\"</kbd> characters).</p>\n</blockquote>\n<p>There is an important qualification there: only quotes and backslashes <em>which are part of a character or string literal</em> are re-escaped. The backslash in <code>DEF(\\x22qwer)</code> is not part of a character or string literal, so it is passed through unchanged.</p>\n", "LastActivityDate": "2017-05-20T23:28:43.473", "Score": "0", "CreationDate": "2017-05-20T23:28:43.473", "ParentId": "44088682", "CommentCount": "0", "OwnerUserId": "1566221"}});