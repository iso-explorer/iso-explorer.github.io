post_cb({"26704728": {"CommentCount": "3", "ViewCount": "114", "PostTypeId": "1", "LastEditorUserId": "2617043", "CreationDate": "2014-11-02T21:38:23.940", "LastActivityDate": "2014-11-02T22:28:57.573", "Title": "Destructor not working in C++ for anonymous object?", "LastEditDate": "2014-11-02T21:42:30.983", "Id": "26704728", "Score": "1", "Body": "<p>My friend told me C++ allows us to call a member function even if the instance is destroyed from memory. So I write the code below to verify it, but why the value of <code>a</code> can be extracted even after the object was destroyed? I thought there would be a segment fault.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo{\npublic:\n  Foo(int a = 0){\n    std::cout &lt;&lt; \"created\" &lt;&lt; std::endl;\n    this-&gt;a = a;\n  }\n  ~Foo(){\n    std::cout &lt;&lt; \"destroyed\" &lt;&lt; std::endl;\n  }\n  Foo *f(){\n    std::cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; std::endl;\n    return this;\n  }\nprivate:\n  int a;\n};\n\nFoo *iwanttocallf(int i){\n    return ((Foo)i).f();\n}\n\nint main(){\n  for(int i = 0; i &lt; 3; i++)\n    iwanttocallf(i)-&gt;f();\n}\n</code></pre>\n<p>Output from my Macbook Air:</p>\n<pre><code>created\na=0\ndestroyed\na=0\ncreated\na=1\ndestroyed\na=1\ncreated\na=2\ndestroyed\na=2\n</code></pre>\n", "Tags": "<c++><segmentation-fault><destructor>", "OwnerUserId": "2617043", "AnswerCount": "4"}, "26704789": {"ParentId": "26704728", "CommentCount": "0", "Body": "<p>\"My friend told me C++ allows us to call a member function even if the member is destroyed from memory\"?</p>\n<p>I don't know what your friend is trying to say. But you call member function on some object of a class \nunless it's a static member. So, if you delete that object from memory, how could you call any function of that class on that object. It's an undefined behavior.</p>\n", "OwnerUserId": "4047092", "PostTypeId": "2", "Id": "26704789", "Score": "0", "CreationDate": "2014-11-02T21:44:37.173", "LastActivityDate": "2014-11-02T21:44:37.173"}, "26704895": {"ParentId": "26704728", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Usually compilers are implementing the member function call as a call to a regular c function with the first argument a pointer to the object (gcc does it like that as far as I know). Now if your pointer is pointing to one destroyed object it doesn't mean that the memory where the a has been stored will be changed, it might be changed. So it is undefined behavior in general. In your case you got a value of a but maybe next time with a different compiler or different code you will crash. Try to use placement new operator then set a value of 'a' = 0 in destructor... and follow the memory where the object is stored.</p>\n", "OwnerUserId": "1000930", "LastEditorUserId": "1000930", "LastEditDate": "2014-11-02T22:14:30.627", "Id": "26704895", "Score": "2", "CreationDate": "2014-11-02T21:54:28.797", "LastActivityDate": "2014-11-02T22:14:30.627"}, "26705204": {"ParentId": "26704728", "CommentCount": "0", "Body": "<p>As other people have told, this involves undefined behavior, and any result is possible. I'll try to explain why you encountered this particular result (stuff working normally).</p>\n<p>Objects in C++ are represented by contents of memory. When an object is destroyed, its \ndestructor is executed, but the memory still contains the previous value. The output operation outputs the value taken from memory (which is now \"free\" - doesn't belong to any object) - if there is not much stuff going on between the destructor call and the output, the old value will remain.</p>\n<p>However, if you change your code to add some calculations, the bug will be evident. For example, I added the following function that simulates some calculations:</p>\n<pre><code>int do_stuff()\n{\n    int result = 0;\n    int x[3] = {0};\n    for (auto&amp; n: x)\n    {\n        n = rand();\n        result ^= n;\n    }\n    return result;\n}\n</code></pre>\n<p>I also added a call to this function:</p>\n<pre><code>  Foo *f(){\n    std::cout &lt;&lt; \"foo1: a=\" &lt;&lt; a &lt;&lt; std::endl;\n    do_stuff();\n    std::cout &lt;&lt; \"foo2: a=\" &lt;&lt; a &lt;&lt; std::endl;\n    return this;\n  }\n</code></pre>\n<p>I got the output:</p>\n<pre><code>foo1: a=0\nfoo2: a=424238335\n</code></pre>\n<p>This clearly shows that it's not safe to expect anything consistent when dealing with deleted objects.</p>\n<p>By the way, some debuggers overwrite the memory that deleted objects occupied with a special value like <code>0xcdcdcdcd</code> - to make some sense out of this kind of unpredictable behavior. If you execute your code under such a debugger, you will see garbage printed, and will immediately know that your code is buggy.</p>\n", "OwnerUserId": "509868", "PostTypeId": "2", "Id": "26705204", "Score": "0", "CreationDate": "2014-11-02T22:28:57.573", "LastActivityDate": "2014-11-02T22:28:57.573"}, "26704942": {"ParentId": "26704728", "CommentCount": "0", "Body": "<p>This is covered in \u00a712.7 [class.cdtor]:</p>\n<blockquote>\n<p id=\"so_26704728_26704942_0\"><em>[..]</em> For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor\n  finishes execution results in undefined behavior.</p>\n</blockquote>\n", "Id": "26704942", "PostTypeId": "2", "OwnerDisplayName": "user3920237", "Score": "0", "CreationDate": "2014-11-02T22:00:33.657", "LastActivityDate": "2014-11-02T22:00:33.657"}, "bq_ids": {"n4140": {"so_26704728_26704942_0": {"section_id": 444, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_26704728_26704942_0": {"section_id": 435, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_26704728_26704942_0": {"section_id": 467, "quality": 0.9411764705882353, "length": 16}}}});