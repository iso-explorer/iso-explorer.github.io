post_cb({"bq_ids": {"n4140": {"so_19757653_19757653_0": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_19757653_19758067_0": {"length": 114, "quality": 0.95, "section_id": 7210}}, "n3337": {"so_19757653_19757653_0": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_19757653_19758067_0": {"length": 107, "quality": 0.8916666666666667, "section_id": 6954}}, "n4659": {"so_19757653_19757653_0": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_19757653_19758067_0": {"length": 108, "quality": 0.9, "section_id": 8719}}}, "19757653": {"ViewCount": "7409", "Body": "<p>There are several posts on the internet that suggest that you should use <code>std::vector&lt;unsigned char&gt;</code> or something similar for binary data.</p>\n<p>But I'd much rather prefer a <code>std::basic_string</code> variant for that, since it provides many convenient string manipulation functions. And AFAIK, since C++11, the standard guarantees what every known C++03 implementation already did: that <code>std::basic_string</code> stores its contents contiguously in memory.</p>\n<p>At first glance then, <code>std::basic_string&lt;unsigned char&gt;</code> might be a good choice.</p>\n<p>I don't want to use <code>std::basic_string&lt;unsigned char&gt;</code>, however, because almost all operating system functions only accept <code>char*</code>, making an explicit cast necessary. Also, string literals are <code>const char*</code>, so I would need an explicit cast to <code>const unsigned char*</code> every time I assigned a string literal to my binary string, which I would also like to avoid. Also, functions for reading from and writing to files or networking buffers similarly accept <code>char*</code> and <code>const char*</code> pointers.</p>\n<p>This leaves <code>std::string</code>, which is basically a typedef for <code>std::basic_string&lt;char&gt;</code>.</p>\n<p>The only potential remaining issue (that I can see) with using <code>std::string</code> for binary data is that <code>std::string</code> uses <code>char</code> (which can be signed).</p>\n<p><code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are three different types and <code>char</code> can be either unsigned or signed.</p>\n<p>So, when an actual byte value of <code>11111111b</code> is returned from <code>std::string:operator[]</code> as char, and you want to check its value, its value can be either <code>255</code> (if <code>char</code> is unsigned) or it might be \"something negative\" (if <code>char</code> is signed, depending on your number representation).</p>\n<p>Similarly, if you want to explicitly append the actual byte value <code>11111111b</code> to a <code>std::string</code>, simply appending <code>(char) (255)</code> might be implementation-defined (and even raise a signal) if <code>char</code> is signed and the <code>int</code> to <code>char</code> conversation results in an overflow.</p>\n<p>So, is there a safe way around this, that makes <code>std::string</code> binary-safe again?</p>\n<p>\u00a73.10/15 states:</p>\n<blockquote>\n<p id=\"so_19757653_19757653_0\">If a program attempts to access the stored value of an object through a <em>glvalue</em> of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>[...]  </li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,  </li>\n<li>[...]  </li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<p>Which, if I understand it correctly, seems to allow using an <code>unsigned char*</code> pointer to access and manipulate the contents of a <code>std::string</code> and makes this also <em>well-defined</em>. It just <em>reinterprets</em> the bit pattern as an <code>unsigned char</code>, without any change or information loss, the latter namely because all bits in a <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> must be used for the value representation.</p>\n<p>I could then use this <code>unsigned char*</code> interpretation of the contents of <code>std::string</code> as a means to access and change the byte values in the <code>[0, 255]</code> range, in a well-defined and portable manner, regardless of the signedness of <code>char</code> itself.</p>\n<p>This should solve any problems arising from a potentially signed <code>char</code>.</p>\n<p>Are my assumptions and conclusions correct?</p>\n<p>Also, is the <code>unsigned char*</code> interpretation of the same bit pattern (i.e. <code>11111111b</code> or <code>10101010b</code>) guaranteed to be the same on all implementations? Put differently, does the standard guarantee that \"looking through the eyes of an <code>unsigned char</code>\", the same bit pattern always leads to the same numerical value (assuming the number of bits in a byte is the same)?</p>\n<p><strong>Can I thus safely (that is, <em>without any</em> undefined or implementation-defined behavior) use <code>std::string</code> for storing and manipulating binary data in C++11?</strong></p>\n", "AcceptedAnswerId": "19758067", "Title": "Can I safely use std::string for binary data in C++11?", "CreationDate": "2013-11-03T20:22:08.713", "Id": "19757653", "CommentCount": "10", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2013-11-03T20:31:48.777", "LastEditorUserId": "2228370", "LastActivityDate": "2015-01-05T00:37:23.060", "Score": "17", "OwnerUserId": "2228370", "Tags": "<c++><c++11><stdstring>", "AnswerCount": "3"}, "19758067": {"Id": "19758067", "PostTypeId": "2", "Body": "<p>The conversion <code>static_cast&lt;char&gt;(uc)</code> where <code>uc</code> is of type is <code>unsigned char</code> is always valid: according to 3.9.1 [basic.fundamental] the representation of <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are identical with <code>char</code> being identical to one of the two other types:</p>\n<blockquote>\n<p id=\"so_19757653_19758067_0\">Objects declared as characters (char) shall be large enough to store any member of the implementation\u2019s basic character set. If a character from this set is stored in a character object, the integral value of that character object is equal to the value of the single character literal form of that character. It is implementation-defined whether a char object can hold negative values. Characters can be explicitly declared unsigned or signed. Plain char, signed char, and unsigned char are three distinct types, collectively called narrow character types. A char, a signed char, and an unsigned char occupy the same amount of storage and have the same alignment requirements (3.11); that is, they have the same object representation. For narrow character types, all bits of the object representation participate in the value representation. For unsigned narrow character types, all possible bit patterns of the value representation represent numbers. These requirements do not hold for other types. In any particular implementation, a plain char object can take on either the same\n  values as a signed char or an unsigned char; which one is implementation-defined.</p>\n</blockquote>\n<p>Converting values outside the range of <code>unsigned char</code> to <code>char</code> will, of course, be problematic and may cause undefined behavior. That is, as long as you don't try to store funny values into the <code>std::string</code> you'd be OK. With respect to bit patterns, you can rely on the <code>n</code>th bit to translated into 2<sup><code>n</code></sup>. There shouldn't be a problem to store binary data in a <code>std::string</code> when processed carefully.</p>\n<p>That said, I don't buy into your premise: Processing binary data mostly requires dealing with bytes which are best manipulated using <code>unsigned</code> values. The few cases where you'd need to convert between <code>char*</code> and <code>unsigned char*</code> create convenient errors when not treated explicitly while messing up the use of <code>char</code> accidentally will be silent! That is, dealing with <code>unsigned char</code> will prevent errors. I also don't buy into the premise that you get all those nice string functions: for one, you are generally better off using the algorithms anyway but also binary data is <em>not</em> string data. In summary: the recommendation for <code>std::vector&lt;unsigned char&gt;</code> isn't just coming out of thin air! It is deliberate to avoid building hard to find traps into the design!</p>\n<p>The only mildly reasonable argument in favor of using <code>char</code> could be the one about string literals but even that doesn't hold water with user-defined string literals introduced into C++11:</p>\n<pre><code>#include &lt;cstddef&gt;\nunsigned char const* operator\"\"_u (char const* s, size_t) \n{\n    return reinterpret_cast&lt;unsigned char const*&gt;(s);\n}\n\nunsigned char const* hello = \"hello\"_u;\n</code></pre>\n", "LastActivityDate": "2013-11-03T21:01:07.193", "CommentCount": "3", "CreationDate": "2013-11-03T21:01:07.193", "ParentId": "19757653", "Score": "17", "OwnerUserId": "1120273"}, "19757891": {"Id": "19757891", "PostTypeId": "2", "Body": "<p>Yes your assumptions are correct.\nStore binary data as a sequence of unsigned char in std::string.</p>\n", "LastActivityDate": "2013-11-03T20:46:16.877", "CommentCount": "2", "CreationDate": "2013-11-03T20:46:16.877", "ParentId": "19757653", "Score": "1", "OwnerUserId": "800454"}, "27771975": {"Id": "27771975", "PostTypeId": "2", "Body": "<p>I've run into trouble using std::string to handle binary data in Microsoft Visual Studio. I've seen the strings get inexplicably truncated, so I wouldn't do this regardless of what the standards documents say.</p>\n", "LastActivityDate": "2015-01-05T00:37:23.060", "CommentCount": "1", "CreationDate": "2015-01-05T00:37:23.060", "ParentId": "19757653", "Score": "-1", "OwnerUserId": "4418484"}});