post_cb({"40787405": {"ParentId": "40787241", "CommentCount": "0", "Body": "<p>The other answer miss a very simple solution to make it legal: Make <code>null</code> a pointer:</p>\n<pre><code>int *null = 0, *p = null;\n</code></pre>\n<p>But as noted, the best solution is to not use the <code>null</code> variable at all, but to use the standard <code>nullptr</code>.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "40787405", "Score": "3", "CreationDate": "2016-11-24T13:15:36.663", "LastActivityDate": "2016-11-24T13:15:36.663"}, "bq_ids": {"n4140": {"so_40787241_40787595_1": {"section_id": 39, "quality": 0.8571428571428571, "length": 6}, "so_40787241_40787595_0": {"section_id": 87, "quality": 0.625, "length": 5}}, "n3337": {"so_40787241_40787595_1": {"section_id": 5947, "quality": 0.7142857142857143, "length": 5}, "so_40787241_40787595_0": {"section_id": 36, "quality": 1.0, "length": 8}}, "n4659": {"so_40787241_40787595_1": {"section_id": 39, "quality": 0.8571428571428571, "length": 6}}}, "40787345": {"ParentId": "40787241", "CommentCount": "1", "Body": "<p>I think you can use <code>reinterpret_cast&lt;int*&gt;</code> over the int in order to make this valid.</p>\n", "OwnerUserId": "7177505", "PostTypeId": "2", "Id": "40787345", "Score": "-1", "CreationDate": "2016-11-24T13:12:47.667", "LastActivityDate": "2016-11-24T13:12:47.667"}, "40787363": {"ParentId": "40787241", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Indeed this is not legal:</p>\n<pre><code>int null = 0, *p = null;\n</code></pre>\n<p>As well as this:</p>\n<pre><code>int null = 0, *p = static_cast&lt;int*&gt;(null);\n</code></pre>\n<p>These compile, and are equivalent:</p>\n<pre><code>int null = 0, *p = (int*)null;\nint null = 0, *p = reinterpret_cast&lt;int*&gt;(null);\n</code></pre>\n<p>But should be avoided, as explained <a href=\"http://www.stroustrup.com/bs_faq2.html#static-cast\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>The C-style cast <code>(int*)null</code> can be considered as a bad practice in C++ (to be clear, this part is a matter of opinion), mainly because it's hard to spot in a code either with your own eyes (there is usually no syntax hightlighting for casts) or with a search/find command (how to separate the casts from the other type usage, e.g. variable declarations?).</p>\n<p><code>reinterpret_cast</code> is more visible, and can be searched easily, but is as permissive as the C-style cast, so it should be avoided unless you know exactly why you're using it.</p>\n<p>Of course, a good initialization in C++11 would be:</p>\n<pre><code>int null = 0, *p = nullptr;\n</code></pre>\n", "OwnerUserId": "6612932", "LastEditorUserId": "6612932", "LastEditDate": "2016-11-24T13:32:35.270", "Id": "40787363", "Score": "1", "CreationDate": "2016-11-24T13:13:39.990", "LastActivityDate": "2016-11-24T13:32:35.270"}, "40787297": {"ParentId": "40787241", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have several options to make it legal, to name a few:</p>\n<pre><code>int null = 0, *p = 0;\n\nint null = 0, *p = nullptr;\n</code></pre>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2016-11-24T13:13:24.583", "Id": "40787297", "Score": "1", "CreationDate": "2016-11-24T13:10:22.943", "LastActivityDate": "2016-11-24T13:13:24.583"}, "40787374": {"ParentId": "40787241", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If you're going for the smallest diff, you can choose</p>\n<pre><code>int null = 0, *p = nullptr;\n                       ^^^\n</code></pre>\n<p>or </p>\n<pre><code>int null = 0, *p = {};\n</code></pre>\n<p>or </p>\n<pre><code>int null = 0, *p = 0;\n</code></pre>\n<p>The last example might be surprising to you, but the way it's defined (in C++14) requires in integer literal with value zero. Not an object with type <code>int</code>.</p>\n<hr>\n<p>Alternatively, if you don't indent to zero-initialize <code>p</code>, you could initialize it with <code>null</code>'s address:</p>\n<pre><code>int null = 0, *p = &amp;null;\n</code></pre>\n</hr>", "OwnerUserId": "2456565", "LastEditorUserId": "2456565", "LastEditDate": "2016-11-24T13:25:44.527", "Id": "40787374", "Score": "2", "CreationDate": "2016-11-24T13:14:09.347", "LastActivityDate": "2016-11-24T13:25:44.527"}, "40787241": {"CommentCount": "6", "ViewCount": "276", "PostTypeId": "1", "LastEditorUserId": "417289", "CreationDate": "2016-11-24T13:07:59.443", "LastActivityDate": "2016-11-24T13:43:18.223", "Title": "How to make this initialization legal in C++?", "AcceptedAnswerId": "40787595", "LastEditDate": "2016-11-24T13:18:28.920", "Id": "40787241", "Score": "4", "Body": "<p>I'va seen an <strong>excersise</strong> in a book, but I cannot figure out the answer:</p>\n<blockquote>\n<p id=\"so_40787241_40787241_0\">Is the following code legal or not? If not, how might you make it\n  legal?</p>\n<p id=\"so_40787241_40787241_1\"><code>int null = 0, *p = null;</code></p>\n</blockquote>\n<p>Of course, the second one is not legal, you cannot convert int to int*.</p>\n<p>The theme was in the section the <code>constexpr</code>.</p>\n<p><strong>GUYS! This is just an exercise about pointers, consts, and constexprs! I think, you have to solve it without cast and nullptr.</strong></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "417289", "AnswerCount": "6"}, "40787595": {"ParentId": "40787241", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>In C++11, a null pointer constant was defined as</p>\n<blockquote>\n<p id=\"so_40787241_40787595_0\">an integral constant expression prvalue of integer type that evaluates to zero</p>\n</blockquote>\n<p>(C++11 [conv.ptr] 4.10/1)</p>\n<p>This means that adding <code>constexpr</code> to the declaration actually makes <code>null</code> a valid null pointer constant:</p>\n<pre><code>constexpr int null = 0, *p = null;\n</code></pre>\n<p>Note that this was considered a defect and changed in C++14, so that only an integer <em>literal</em> can be a null pointer constant:</p>\n<blockquote>\n<p id=\"so_40787241_40787595_1\">A <em>null pointer constant</em> is an integer literal with value zero ...</p>\n</blockquote>\n<p>(C++14 N4140 [conv.ptr] 4.10/1)</p>\n<p>So, there is a way to make the initialisation legal using <code>constexpr</code> in C++11, but its existence was considered a standard defect and removed in C++14. The book is therefore teaching outdated information.</p>\n<p>Note that because this is a defect, compilers have generally backported this behaviour to their C++11 mode as well (if they even implemented the original one in the first place).</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2016-11-24T13:43:18.223", "Id": "40787595", "Score": "9", "CreationDate": "2016-11-24T13:24:37.717", "LastActivityDate": "2016-11-24T13:43:18.223"}});