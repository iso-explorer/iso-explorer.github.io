post_cb({"18061394": {"ViewCount": "438", "Body": "<p>Following situation, I have a struct containing pointers to integer variables like this:</p>\n<pre><code>struct Structure[] = { \n    { &amp;Var[0], &amp;Var[1] },\n    { &amp;Var[2], &amp;Var[3] }\n};\n</code></pre>\n<p>Thing is: <code>Var</code> is uninitialized the first time this struct is filled. (As in: <code>NULL</code>)\nShortly after (on first pass) the variable <code>Var</code> will be initialized and the references will be updated accordingly.</p>\n<p>I see no reason for this to malfunction, but I'd like your expertise on it.\nIs it legal to put a reference to invalid memory (with array subscript) into an array like this? Or do I need a different kind of approach for this situation?</p>\n<p>I'm not accessing the contents of these variables until after the first initialization.</p>\n<p>Thank you very much.</p>\n<p>Edit:\nFor the benefit of future readers: <code>Var</code> is a global pointer variable, which is initialized to NULL at the beginning. The initialization turns it into an array by using <code>new</code>.</p>\n", "AcceptedAnswerId": "18061598", "Title": "Is it legal to reference uninitialized memory without accessing it?", "CreationDate": "2013-08-05T15:01:37.710", "Id": "18061394", "CommentCount": "13", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-08-06T08:43:59.897", "LastEditorUserId": "1537128", "LastActivityDate": "2013-08-06T08:43:59.897", "Score": "5", "OwnerUserId": "1537128", "Tags": "<c++><variables><memory>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_18061394_18061598_1": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}}, "n3337": {"so_18061394_18061598_1": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}}}, "18062337": {"PostTypeId": "2", "Body": "<p>To answer the specific question (forgetting the example code): yes, you can have a reference to uninitialized memory, you simply cannot <em>dereference</em> it and expect defined behavior.</p>\n", "LastActivityDate": "2013-08-05T15:48:18.967", "Id": "18062337", "CommentCount": "0", "CreationDate": "2013-08-05T15:48:18.967", "ParentId": "18061394", "Score": "0", "OwnerUserId": "479574"}, "18061598": {"PostTypeId": "2", "Body": "<p>I'm assuming that <code>Var</code> is a pointer object and that its current value is a null pointer. This is implied by your statement:</p>\n<blockquote>\n<p id=\"so_18061394_18061598_0\"><code>Var</code> is uninitialized the first time this struct is filled. (As in: <code>NULL</code>)</p>\n</blockquote>\n<p>I'm also assuming that <code>Var</code> is not defined at block scope. If it's defined at block scope, and you haven't initialized it or assigned a value to it, then its value is garbage, not necessarily a null pointer value, and any attempt to refer to its value has undefined behavior.</p>\n<p>The behavior is undefined.</p>\n<p>If <code>Var == NULL</code>, then <code>&amp;Var[N]</code> has undefined behavior.</p>\n<p><code>arr[index]</code> is by definition equivalent to <code>*(arr + index)</code>, so <code>&amp;Var[N]</code> is equivalent to <code>&amp;(*(Var + N))</code>. The behavior of pointer arithmetic is defined in terms of elements of the array object into which the pointer points (with a single object treated as a one-element array) and a null pointer doesn't point to anything.</p>\n<p>A digression:</p>\n<p>C explicitly says that <code>&amp;*x</code> is evaluated as <code>x</code>, and <code>&amp;[x[i])</code> is evaluated as <code>x+i</code>; C++ doesn't say this, so the operand of <code>&amp;</code> has to be valid. C++ has a special case for adding <code>0</code>, which is well defined even for a null pointer (C has no such special case). But <code>&amp;Var[0]</code> is still invalid in in both C and C++, but for different reasons. In C, it's equivalent to <code>Var + 0</code>, but adding <code>0</code> to a null pointer has undefined behavior. In C++, it's <em>not</em> equivalent to <code>Var + 0</code>; rather it's equivalent to <code>&amp;(*(Var + 0))</code>; <code>Var + 0</code> is a null pointer, and dereferencing it has undefined behavior.)</p>\n<p>End of digression.</p>\n<p>Yes, just computing an invalid address has undefined behavior, even if it's never dereferenced.</p>\n<p>Here's the relevant text from the 2011 ISO C++ standard, 5.7 [expr.add] paragraph 5; note particularly the very end:</p>\n<blockquote>\n<p id=\"so_18061394_18061598_1\">When an expression that has integral type is added to or subtracted \n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from  the\n  original element such that the difference of the subscripts  of the\n  resulting and original array elements equals the integral expression.\n  In other words, if the expression P points to the i-th element of an\n  array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N\n  (where N has the value n) point to, respectively,  the i + n-th and i\n  \u2212 n-th elements of the array object, provided they exist. Moreover, if\n  the expression P points to the last element of an array object, the\n  expression (P)+1 points one past the last element of the array object,\n  and if the expression Q points one past the last element of an array\n  object, the expression (Q)-1 points to the last element of the array\n  object. If both the pointer operand and the result point to elements\n  of the same array object, or one past the last element of the array\n  object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2013-08-05T19:48:18.550", "LastEditorUserId": "827263", "Id": "18061598", "CommentCount": "14", "CreationDate": "2013-08-05T15:11:31.607", "ParentId": "18061394", "Score": "7", "OwnerUserId": "827263", "LastEditDate": "2013-08-05T19:48:18.550"}, "18061670": {"PostTypeId": "2", "Body": "<p>Since you aren't using the values until after the first pass, do the right thing and initialize your struct's pointers to null instead. Then put the right values in when you know them. If you take that approach your \"is it legal\" problem just goes away!</p>\n", "LastActivityDate": "2013-08-05T15:15:33.693", "Id": "18061670", "CommentCount": "1", "CreationDate": "2013-08-05T15:15:33.693", "ParentId": "18061394", "Score": "2", "OwnerUserId": "251738"}});