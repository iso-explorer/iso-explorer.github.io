post_cb({"27032096": {"ParentId": "27031839", "CommentCount": "0", "Body": "<p>The source code has to be translated into ASCII in an implementation defined way, preserving characters that are from the original encoding using escape sequences where necessary:</p>\n<blockquote>\n<p id=\"so_27031839_27032096_0\"><strong>ISO/IEC 14882:2003(E)</strong></p>\n<p id=\"so_27031839_27032096_1\"><strong>2.1.1 Phases of translation</strong></p>\n<p id=\"so_27031839_27032096_2\">Physical source file characters are mapped, in an implementation-defined manner, to the basic source\n  character set (introducing new-line characters for end-of-line\n  indicators) if necessary. Trigraph sequences (2.3) are replaced by\n  corresponding single-character internal representations. Any source\n  file character not in the basic source character set (2.2) is replaced\n  by the universal-character-name that designates that character. (An\n  implementation may use any internal encoding, so long as an actual\n  extended character encountered in the source file, and the same\n  extended character expressed in the source file as a\n  universal-character-name (i.e. using the \\uXXXX notation), are handled\n  equivalently.)</p>\n<p id=\"so_27031839_27032096_3\">...</p>\n<p id=\"so_27031839_27032096_4\"><sup>15)</sup> The glyphs for the members of the basic\n  source character set are intended to identify characters from the\n  subset of ISO/IEC 10646 which corresponds to the ASCII character set.\n  However, because the mapping from source file characters to the source\n  character set (described in translation phase 1) is specified as\n  implementation-defined, an implementation is required to document how\n  the basic source characters are represented in source files.</p>\n</blockquote>\n", "OwnerUserId": "3807729", "PostTypeId": "2", "Id": "27032096", "Score": "0", "CreationDate": "2014-11-20T04:59:52.207", "LastActivityDate": "2014-11-20T04:59:52.207"}, "27031839": {"CommentCount": "1", "ViewCount": "58", "CreationDate": "2014-11-20T04:35:07.543", "LastActivityDate": "2014-11-20T04:59:52.207", "Title": "String characters interpretation by compiler", "PostTypeId": "1", "Id": "27031839", "Score": "0", "Body": "<p>Lets start from a simple line in C++</p>\n<pre><code>char const* hello = \"\u52d5\u753b\u3001\u8aad\u66f8\u306a\"; // I hope it is not offensive, I dont know what this means ))\n</code></pre>\n<p>And make a point that this line is stored in utf-8 encoded file.\nWhen I pass the file with this line for compilation (result is a binary code), the compile do the following steps:</p>\n<ol>\n<li>Reads file (it needs to know what is the file encoding, in case of utf-8 it probably will be easy by using BOM, but what about other encodings?)</li>\n<li>Parse the file content using its grammar, build syntax tree, ...</li>\n<li>If everything is fine, it start writing binary code, in this stage it saves constans in the code.</li>\n</ol>\n<p>The question is how it will store the constant above (\"\u52d5\u753b\u3001\u8aad\u66f8\u306a\")? Does it convert it somehow?\nOr it just reads bytes after \" character untill another \" from file and store them as it is? Then does it mean that final binary code depends on the original source file encoding?</p>\n", "Tags": "<c++><character-encoding>", "OwnerUserId": "1594394", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27031839_27032096_2": {"section_id": 5313, "quality": 0.9333333333333333, "length": 56}, "so_27031839_27032096_4": {"section_id": 5314, "quality": 0.975609756097561, "length": 40}}, "n3337": {"so_27031839_27032096_2": {"section_id": 5110, "quality": 0.9333333333333333, "length": 56}, "so_27031839_27032096_4": {"section_id": 5111, "quality": 0.975609756097561, "length": 40}}, "n4659": {"so_27031839_27032096_2": {"section_id": 6737, "quality": 0.8333333333333334, "length": 50}, "so_27031839_27032096_4": {"section_id": 6738, "quality": 0.9512195121951219, "length": 39}}}});