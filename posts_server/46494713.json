post_cb({"46499414": {"ParentId": "46494713", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_46494713_46499414_0\"><strong>[expr.shift]/1</strong> ... The behavior [of the shift operator - IT] is undefined if the right operand is negative, or greater than <strong>or equal to the length in bits of the promoted left operand.</strong></p>\n</blockquote>\n<p>Emphasis mine. <code>allBitsSet &gt;&gt; (maxBits - begin)</code> (in the non-<code>bitset</code> version) exhibits undefined behavior.</p>\n<p>On the other hand, the behavior of <code>bitset::operator&gt;&gt;</code> is well-defined: <code>allBitsSet &gt;&gt; (maxBits - begin)</code> produces a bitset with all zero bits.</p>\n", "OwnerUserId": "1670129", "LastEditorUserId": "1670129", "LastEditDate": "2017-09-30T04:00:54.110", "Id": "46499414", "Score": "1", "CreationDate": "2017-09-30T03:55:33.767", "LastActivityDate": "2017-09-30T04:00:54.110"}, "46494713": {"CommentCount": "0", "ViewCount": "22", "CreationDate": "2017-09-29T18:12:29.390", "LastActivityDate": "2017-09-30T04:00:54.110", "Title": "difference in output using std::size_t and std::bitset for bit operations", "AcceptedAnswerId": "46499414", "PostTypeId": "1", "Id": "46494713", "Score": "0", "Body": "<p>Having following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;limits&gt;\n#include &lt;limits.h&gt;\nusing namespace std;\n\nconstexpr std::size_t maxBits = CHAR_BIT * sizeof(std::size_t);\n\nint main() {\n    std::size_t value =47;\n    unsigned int begin=0;\n    unsigned int end=32;\n\n    //std::size_t allBitsSet(std::numeric_limits&lt;std::size_t&gt;::max());\n    std::bitset&lt;maxBits&gt; allBitsSet(std::numeric_limits&lt;std::size_t&gt;::max());\n    //std::size_t mask((allBitsSet &gt;&gt; (maxBits - end)) ^(allBitsSet &gt;&gt; (maxBits - begin)));\n    std::bitset&lt;maxBits&gt; mask = (allBitsSet &gt;&gt; (maxBits - end)) ^(allBitsSet &gt;&gt; (maxBits - begin));\n\n    //std::size_t bitsetValue(value);\n    std::bitset&lt;maxBits&gt; bitsetValue(value);\n\n    auto maskedValue = bitsetValue &amp; mask;\n    auto result = maskedValue &gt;&gt; begin;\n\n    //std::cout &lt;&lt; static_cast&lt;std::size_t&gt;(result) &lt;&lt; std::endl;\n    std::cout &lt;&lt; static_cast&lt;std::size_t&gt;(result.to_ulong()) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Which in fact should return the same value as <code>value</code>, but for some reason the version with <code>std::bitset</code> works just fine and version with <code>std::size_t</code> does not.</p>\n<p>It is strange as such, because AFAIK <code>std::bitset</code>, when something is wrong simply throws exception and what is more AFAIK bitset should behave the same way as operations on unsigned integers, but as we can see even if bitset has same number of bits it does not behave the same. In fact it seems for me, that <code>std::bitset</code> works fine, while <code>std::size_t</code> does not.</p>\n<p>My configuration is:\nintel corei7 - g++-5.4.0-r3</p>\n", "Tags": "<c++11>", "OwnerUserId": "4764736", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46494713_46499414_0": {"section_id": 6146, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_46494713_46499414_0": {"section_id": 5909, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_46494713_46499414_0": {"section_id": 7642, "quality": 0.7058823529411765, "length": 12}}}});