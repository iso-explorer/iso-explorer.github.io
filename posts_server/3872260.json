post_cb({"3872278": {"ParentId": "3872260", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-10-06T12:15:56.320", "Score": "1", "LastEditorUserId": "212063", "LastEditDate": "2010-10-06T13:52:05.063", "Id": "3872278", "OwnerUserId": "212063", "Body": "<p>The argument is passed, and ignored.</p>\n<p>Your code does not use it.</p>\n", "LastActivityDate": "2010-10-06T13:52:05.063"}, "3872281": {"ParentId": "3872260", "CommentCount": "0", "Body": "<p>The exactly same thing happens, you just didn't name the parameter and therefore can't access it.</p>\n", "OwnerUserId": "211659", "PostTypeId": "2", "Id": "3872281", "Score": "0", "CreationDate": "2010-10-06T12:16:08.273", "LastActivityDate": "2010-10-06T12:16:08.273"}, "3872260": {"CommentCount": "0", "ViewCount": "481", "CreationDate": "2010-10-06T12:13:56.510", "LastActivityDate": "2010-10-06T13:52:05.063", "Title": "Undefined parameters in function", "AcceptedAnswerId": "3872345", "PostTypeId": "1", "Id": "3872260", "Score": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Imp\n{\n    public:\n        int X(int) {return 50;}\n        int Y(int y) {return y;}\n};\n\nint main()\n{\n    Imp i;\n    cout &lt;&lt; i.X(100) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>This code works and prints out 50. My question is what happens to the argument passed? Just out of curiosity. :)</p>\n", "Tags": "<c++>", "OwnerUserId": "466694", "AnswerCount": "5"}, "3872533": {"ParentId": "3872260", "CommentCount": "0", "Body": "<p>Firing up the compiled program in gdb you can see that at assembly level the argument is being passed, but ignored inside the called method:</p>\n<pre><code>Dump of assembler code for function main:\n0x0000000100000ce3 &lt;main+0&gt;:    push   %rbp\n0x0000000100000ce4 &lt;main+1&gt;:    mov    %rsp,%rbp\n0x0000000100000ce7 &lt;main+4&gt;:    sub    $0x10,%rsp\n0x0000000100000ceb &lt;main+8&gt;:    lea    -0x1(%rbp),%rdi\n0x0000000100000cef &lt;main+12&gt;:   mov    $0x64,%esi ; ** 0x64 = 100 = your argument\n0x0000000100000cf4 &lt;main+17&gt;:   callq  0x100000d82 &lt;dyld_stub__ZN3Imp1XEi&gt;\n</code></pre>\n<p>And then inside the X method the value 0x32 (50) is returned ignoring parameter passed from the main method.</p>\n<pre><code>Dump of assembler code for function _ZN3Imp1XEi:  ; X();\n0x0000000100000d1e &lt;_ZN3Imp1XEi+0&gt;: push   %rbp\n0x0000000100000d1f &lt;_ZN3Imp1XEi+1&gt;: mov    %rsp,%rbp\n0x0000000100000d22 &lt;_ZN3Imp1XEi+4&gt;: mov    %rdi,-0x8(%rbp)\n0x0000000100000d26 &lt;_ZN3Imp1XEi+8&gt;: mov    %esi,-0xc(%rbp)\n0x0000000100000d29 &lt;_ZN3Imp1XEi+11&gt;:   mov    $0x32,%eax ; ** 0x32 = 50 = your return\n0x0000000100000d2e &lt;_ZN3Imp1XEi+16&gt;:   leaveq \n0x0000000100000d2f &lt;_ZN3Imp1XEi+17&gt;:   retq   \n</code></pre>\n<p>Hope it was helpful or maybe at least interesting to have a look at. Even when you are not fit in assembler it can sometimes help to dig in and look around</p>\n", "OwnerUserId": "457853", "PostTypeId": "2", "Id": "3872533", "Score": "0", "CreationDate": "2010-10-06T12:43:48.140", "LastActivityDate": "2010-10-06T12:43:48.140"}, "3872348": {"ParentId": "3872260", "CommentCount": "0", "Body": "<p>Somtimes you need a specific signature although the parameter is not used inside the function. In this case you can omit the parameter name to avoid a compiler warning.</p>\n", "OwnerUserId": "148897", "PostTypeId": "2", "Id": "3872348", "Score": "0", "CreationDate": "2010-10-06T12:23:16.400", "LastActivityDate": "2010-10-06T12:23:16.400"}, "3872345": {"ParentId": "3872260", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-10-06T12:22:58.583", "Score": "2", "LastEditorUserId": "418110", "LastEditDate": "2010-10-06T12:31:38.203", "Id": "3872345", "OwnerUserId": "418110", "Body": "<p>The arguments for such parameters are passed in the usual way, but it is not possible to acess such parameters by name in the corresponding function definition (unusual machine architecture specific code can be written however to access the argument)</p>\n<p>A good example is the postfix operator++ (and --) as well which is usually overloaded as</p>\n<pre><code>struct A{\n   A operator++(int){ \n       // stuff\n       // return an appropriate A object\n   }\n};\n</code></pre>\n<p>NB: The compiler usually passes a dummy argument 0 for such overloads</p>\n<blockquote>\n<p id=\"so_3872260_3872345_0\">$13.5.7/1- \"When the postfix increment\n  is called as a result of using the ++\n  operator, the int argument will have\n  value zero.136\"</p>\n</blockquote>\n<p>The dummy parameter type is indicated as 'int' and is not named almost always(and hence not used in the operator definition)</p>\n", "LastActivityDate": "2010-10-06T12:31:38.203"}, "bq_ids": {"n4140": {"so_3872260_3872345_0": {"section_id": 665, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_3872260_3872345_0": {"section_id": 655, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_3872260_3872345_0": {"section_id": 693, "quality": 0.8571428571428571, "length": 12}}}});