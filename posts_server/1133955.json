post_cb({"1133988": {"Id": "1133988", "PostTypeId": "2", "Body": "<p>It makes the function pure virtual as opposed to virtual.</p>\n<p>No implementation is provided by default and the intent is that the function implementation must be specified by an inheriting class. This can be overriden however.</p>\n<p>You sometimes see complete classes where all member functions are specified as pure virtual in this manner.</p>\n<p>These are Abstract Base Classes, sometimes referred to as Interface Classes, and the designer of the ABC is saying to you, \"I have now idea how this functionality would be implemented for all specialisations of this base class. But, you must have all of these defined for your specialisation to work and you know how your object should behave\".</p>\n<p><strong>Edit:</strong> Oops, just spotted the fact that the member pure virtual function is private. (Thanks Michael) This changes things slightly.</p>\n<p>When this base class is inherited using private inheritance it changes things. Basically what the designer of the base class is doing is saying is that, when your derived class calls a non-private function in the base class. part of the behaviour has been delegated to your specialisation of the function in your derived class. The non-private member is doing \"something\" and part of that \"something\" is a call, via the pure virtual base class function, to your implementation.</p>\n<p>So some public function in Foo is calling the Bar function inside Foo, and it is relying on the fact that you will provide a specialised implementation of the Bar function for your particular case.</p>\n<p>Scott Meyers refers to this as \"implemented in terms of\".</p>\n<p>BTW Just chuckling about the number of answers that were quickly deleted by people who also didn't see the \"fine print\" in the question! (-:</p>\n<p>HTH</p>\n<p>cheers,</p>\n", "LastEditorUserId": "2974", "LastActivityDate": "2009-07-15T21:13:39.590", "Score": "1", "CreationDate": "2009-07-15T20:52:39.210", "ParentId": "1133955", "CommentCount": "0", "OwnerUserId": "2974", "LastEditDate": "2009-07-15T21:13:39.590"}, "bq_ids": {"n4140": {"so_1133955_1134198_0": {"length": 4, "quality": 0.8, "section_id": 7003}}, "n3337": {"so_1133955_1134198_0": {"length": 4, "quality": 0.8, "section_id": 6749}}, "n4659": {"so_1133955_1134198_0": {"length": 4, "quality": 0.8, "section_id": 8500}}}, "1134198": {"Id": "1134198", "PostTypeId": "2", "Body": "<p>ISO C++ 2003 explicitly allows it:</p>\n<p>\u00a710.3 states nothing about access specifier and contains even a footnote in the second clause stating in the context of virtual function overrides: </p>\n<blockquote>\n<p id=\"so_1133955_1134198_0\">[...] Access control (clause 11) is\n  not considered in determining\n  overriding.</p>\n</blockquote>\n<p>The code is fully legal.</p>\n", "LastEditorUserId": "1473751", "LastActivityDate": "2014-05-30T18:24:37.260", "Score": "9", "CreationDate": "2009-07-15T21:28:10.030", "ParentId": "1133955", "CommentCount": "0", "OwnerUserId": "98693", "LastEditDate": "2014-05-30T18:24:37.260"}, "1133955": {"ViewCount": "11730", "Body": "<p>I just spotted this in some code:</p>\n<pre><code>class Foo {\n[...]\nprivate:\n    virtual void Bar() = 0;\n[...]\n}\n</code></pre>\n<p>Does this have any purpose?</p>\n<p>(I am trying to port some code from VS to G++, and this caught my attention)</p>\n", "AcceptedAnswerId": "1134007", "Title": "Why would a virtual function be private?", "CreationDate": "2009-07-15T20:49:09.607", "Id": "1133955", "CommentCount": "4", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2011-12-26T02:06:27.537", "LastEditorUserId": "963864", "LastActivityDate": "2014-05-30T18:24:37.260", "Score": "25", "OwnerUserId": "42610", "Tags": "<c++><private><virtual-functions><access-specifier><function-overriding>", "AnswerCount": "8"}, "1134028": {"Id": "1134028", "PostTypeId": "2", "Body": "<p>I'm going to quote a brief explanation from the great <a href=\"http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.4\" rel=\"nofollow noreferrer\">C++ FAQ Lite</a> which sums it up well:</p>\n<blockquote>\n<p id=\"so_1133955_1134028_0\">[23.4] When should someone use private\n  virtuals?</p>\n<p id=\"so_1133955_1134028_1\">Almost never.</p>\n<p id=\"so_1133955_1134028_2\">Protected virtuals are okay, but\n  private virtuals are usually a net\n  loss. Reason: private virtuals confuse\n  new C++ programmers, and confusion\n  increases cost, delays schedule, and\n  degrades risk.</p>\n<p id=\"so_1133955_1134028_3\">New C++ programmers get confused by\n  private virtuals because they think a\n  private virtual cannot be overridden.\n  After all, a derived class cannot\n  access members that are private in its\n  base class so how, they ask, could it\n  override a private virtual from its\n  base class? There are explanations for\n  the above, but that's academic. The\n  real issue is that almost everyone\n  gets confused the first time they run\n  into private virtuals, and confusion\n  is bad.</p>\n<p id=\"so_1133955_1134028_4\">Unless there is a compelling reason to\n  the contrary, avoid private virtuals.</p>\n</blockquote>\n<hr>\n<p>The C++ FAQ Lite was updated in the meantime:</p>\n<blockquote>\n<p id=\"so_1133955_1134028_5\">By the way, it confuses most novice C++ programmers that private virtuals can be overridden, let alone are valid at all. We were all taught that private members in a base class are not accessible in classes derived from it, which is correct. However this inaccessibility by the derived class does not have anything to do with the virtual call mechanism, which is to the derived class. Since that might confuse novices, <strong>the C++ FAQ formerly recommended using protected virtuals rather than private virtuals. However the private virtual approach is now common enough that confusion of novices is less of a concern.</strong></p>\n</blockquote>\n</hr>", "LastEditorUserId": "252000", "LastActivityDate": "2012-08-02T13:41:14.780", "Score": "5", "CreationDate": "2009-07-15T20:58:05.113", "ParentId": "1133955", "CommentCount": "6", "OwnerUserId": "75761", "LastEditDate": "2012-08-02T13:41:14.780"}, "1134124": {"Id": "1134124", "PostTypeId": "2", "Body": "<p>This is a pure virtual function that happens to be private.  This makes it so that a derived class must implement the method.  In this case Bar.</p>\n<p>I think you may be confused b/c this is done to create \"interfaces\" in C++ and a lot of times people think of these as public.  There are cases where you may want to define an interface that is private where a public method uses those private methods in order to ensure the order of how they are called.  (I believe this is called the Template Method) </p>\n<p>For a relatively bad example :)  </p>\n<pre>\nclass RecordFile\n{\n    public:\n       RecordFile(const std::string &amp;filename;);\n\n       void process(const Record &amp;rec;)\n       {\n           // Call the derived class function to filter out\n           // records the derived instance of this class does\n           // not care about\n           if (filterRecord(rec))    \n           {\n               writeRecordToFile(rec);           \n           }\n       };\n\n    private:\n       // Returns true if the record is of importance\n       // and should be kept\n       virtual bool filterRecord(const Record &amp;rec;) = 0;\n\n       void writeRecordToFile(const Record &amp;rec;);\n};\n\n</pre>\n", "LastEditorUserId": "22118", "LastActivityDate": "2009-07-15T21:59:07.720", "Score": "10", "CreationDate": "2009-07-15T21:12:34.757", "ParentId": "1133955", "CommentCount": "6", "OwnerUserId": "22118", "LastEditDate": "2009-07-15T21:59:07.720"}, "1133983": {"Id": "1133983", "PostTypeId": "2", "Body": "<p>It is a pure virtual function.  Any final implementation that is dervied from \"Foo\" MUST implement the \"Bar\" function.</p>\n", "LastActivityDate": "2009-07-15T20:52:06.967", "CommentCount": "1", "CreationDate": "2009-07-15T20:52:06.967", "ParentId": "1133955", "Score": "2", "OwnerUserId": "131140"}, "1134019": {"Id": "1134019", "PostTypeId": "2", "Body": "<p>The only purpose it seems to serve is to provide a common interface. </p>\n<p>BTW even though a function is declared as private virtual, it can still be implemented and called with the class instance or from friends.</p>\n<p>Nonetheless, this sort of things usually meant to serve as interface, yet I don't do it this way. </p>\n", "OwnerDisplayName": "Sasha", "LastActivityDate": "2009-07-15T20:57:25.333", "Score": "0", "CreationDate": "2009-07-15T20:57:25.333", "ParentId": "1133955", "CommentCount": "0"}, "1134007": {"Id": "1134007", "PostTypeId": "2", "Body": "<p>See <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"noreferrer\">this Herb Sutter article</a> as to why you'd want to do such a thing.</p>\n", "LastActivityDate": "2009-07-15T20:55:37.737", "CommentCount": "7", "CreationDate": "2009-07-15T20:55:37.737", "ParentId": "1133955", "Score": "23", "OwnerUserId": "5963"}, "1134122": {"Id": "1134122", "PostTypeId": "2", "Body": "<p>The usual \"academic\" answer is: access specifiers and virtuality are orthogonal - one does not affect the other.</p>\n<p>A little more practical answer: private virtual functions are often used to implement the <a href=\"http://sourcemaking.com/design_patterns/template_method\" rel=\"noreferrer\">Template Method</a> design pattern. In languages that do not support private virtual functions, the template method needs to be public although it is not really meant to be a part of the interface.</p>\n", "LastActivityDate": "2009-07-15T21:12:07.457", "CommentCount": "2", "CreationDate": "2009-07-15T21:12:07.457", "ParentId": "1133955", "Score": "5", "OwnerUserId": "8899"}});