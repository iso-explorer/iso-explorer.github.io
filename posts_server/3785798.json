post_cb({"3789617": {"ParentId": "3785798", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The compiler is free to optimize your code out <em>because <code>buffer</code> is not a volatile object</em>. </p>\n<p>The Standard only requires a compiler to strictly adhere to semantics for volatile objects. Here is what C++03 says</p>\n<blockquote>\n<p id=\"so_3785798_3789617_0\">The least requirements on a conforming implementation are:</p>\n<ul>\n<li>At sequence points, volatile objects are stable in the sense that previous evaluations are complete and\n  subsequent evaluations have not yet occurred.\n  [...]</li>\n</ul>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_3785798_3789617_1\">The observable behavior of the abstract machine is its sequence of reads and writes to volatile data and\n  calls to library I/O functions</p>\n</blockquote>\n<p>In your example, what you have are reads and writes using volatile lvalues to non-volatile objects. C++0x removed the second text I quoted above, because it's redundant. C++0x just says</p>\n<blockquote>\n<p id=\"so_3785798_3789617_2\">The least requirements on a conforming implementation are:</p>\n<ul>\n<li>Access to volatile objects are evaluated strictly according to the rules of the abstract machine.[...]</li>\n</ul>\n<p id=\"so_3785798_3789617_3\">These collectively are referred to as the <em>observable behavior</em> of the program. </p>\n</blockquote>\n<p>While one may argue that \"volatile data\" could maybe mean \"data accessed by volatile lvalues\", which would still be quite a stretch, the C++0x wording removed all doubts about your code and clearly allows implementations to optimize it away.</p>\n<p>But as people pointed out to me, It probably does not matter in practice. A compiler that optimizes such a thing will most probably go against the programmers intention (why would someone have a pointer to volatile otherwise) and so would probably contain a bug. Still, I have experienced compiler vendors that cited these paragraphs when they were faced with bugreports about their over-aggressive optimizations. In the end, <code>volatile</code> is inherent platform specific and you are supposed to double check the result anyway. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-09-24T18:08:44.180", "Id": "3789617", "Score": "2", "CreationDate": "2010-09-24T17:43:20.310", "LastActivityDate": "2010-09-24T18:08:44.180"}, "3785798": {"CommentCount": "3", "AcceptedAnswerId": "3789617", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-09-24T09:34:37.860", "LastActivityDate": "2010-09-24T18:08:44.180", "LastEditDate": "2017-05-23T12:04:09.937", "ViewCount": "452", "FavoriteCount": "3", "Title": "Does using \"pointer to volatile\" prevent compiler optimizations at all times?", "Id": "3785798", "Score": "6", "Body": "<p>Here's the problem: <a href=\"https://stackoverflow.com/questions/3785366/how-to-ensure-that-compiler-optimizations-dont-introduce-a-security-risk\">your program temporarily uses some sensitive data and wants to erase it when it's no longer needed</a>. Using <code>std::fill()</code> on itself won't always help - the compiler might decide that <em>the memory block is not accessed later, so erasing it is a waste of time</em> and eliminate erasing code.</p>\n<p><a href=\"https://stackoverflow.com/users/277176/ybungalobill\">User ybungalobill</a> suggests <a href=\"https://stackoverflow.com/questions/3785582/how-to-write-a-password-safe-class/3785676#3785676\">using <code>volatile</code> keyword</a>:</p>\n<pre><code>{\n  char buffer[size];\n  //obtain and use password\n  std::fill_n( (volatile char*)buffer, size, 0);\n}\n</code></pre>\n<p>The intent is that upon seeing the <code>volatile</code> keyword the compiler will not try to eliminate the call to <code>std::fill_n()</code>.</p>\n<p>Will <code>volatile</code> keyword always prevent the compiler from such memory modifying code elimination?</p>\n", "Tags": "<c++><volatile>", "OwnerUserId": "57428", "AnswerCount": "3"}, "3786005": {"ParentId": "3785798", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The memory content you wish to remove may have already been flushed out from your CPU/core's inner cache to RAM, where other CPUs can continue to see it.  After overwriting it, you need to use a mutex / memory barrier instruction / atomic operation or something to trigger a sync with other cores.  In practice, your compiler will probably do this before calling any external functions (google Dave Butenhof's post on volatile's dubious utility in multi-threading), so if you thread does that soon afterwards anyway then it's not a major issue.  Summarily: volatile isn't needed.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2010-09-24T10:14:50.517", "Id": "3786005", "Score": "1", "CreationDate": "2010-09-24T10:05:04.620", "LastActivityDate": "2010-09-24T10:14:50.517"}, "bq_ids": {"n4140": {"so_3785798_3789617_2": {"section_id": 5804, "quality": 0.8, "length": 4}, "so_3785798_3785944_3": {"section_id": 5808, "quality": 0.9473684210526315, "length": 18}, "so_3785798_3789617_0": {"section_id": 5804, "quality": 0.8, "length": 4}, "so_3785798_3785944_1": {"section_id": 5804, "quality": 1.0, "length": 9}, "so_3785798_3785944_0": {"section_id": 5804, "quality": 0.8, "length": 4}}, "n3337": {"so_3785798_3789617_2": {"section_id": 5577, "quality": 0.8, "length": 4}, "so_3785798_3785944_3": {"section_id": 5581, "quality": 0.9473684210526315, "length": 18}, "so_3785798_3789617_0": {"section_id": 5577, "quality": 0.8, "length": 4}, "so_3785798_3785944_1": {"section_id": 5577, "quality": 1.0, "length": 9}, "so_3785798_3785944_0": {"section_id": 5577, "quality": 0.8, "length": 4}}, "n4659": {"so_3785798_3785944_3": {"section_id": 7269, "quality": 0.8947368421052632, "length": 17}, "so_3785798_3789617_2": {"section_id": 7262, "quality": 0.8, "length": 4}, "so_3785798_3785944_0": {"section_id": 7262, "quality": 0.8, "length": 4}, "so_3785798_3785944_1": {"section_id": 7262, "quality": 0.7777777777777778, "length": 7}, "so_3785798_3789617_0": {"section_id": 7262, "quality": 0.8, "length": 4}}}, "3785944": {"ParentId": "3785798", "CommentCount": "1", "CreationDate": "2010-09-24T09:55:59.273", "OwnerUserId": "277176", "PostTypeId": "2", "Id": "3785944", "Score": "3", "Body": "<p>From the last C++0x draft [intro.execution]:</p>\n<blockquote>\n<p id=\"so_3785798_3785944_0\">8 The least requirements on a\n  conforming implementation are:</p>\n<p id=\"so_3785798_3785944_1\">\u2014 Access to volatile objects are\n  evaluated strictly according to the\n  rules of the abstract machine.</p>\n<p id=\"so_3785798_3785944_2\">[...]</p>\n<p id=\"so_3785798_3785944_3\">12 Accessing an object designated by a\n  volatile glvalue (3.10), modifying an\n  object, calling a library I/O\n  function, or calling a function that\n  does any of those operations are all\n  side effects, [...]</p>\n</blockquote>\n<p>So even the code you provided must not be optimized.</p>\n", "LastActivityDate": "2010-09-24T09:55:59.273"}});