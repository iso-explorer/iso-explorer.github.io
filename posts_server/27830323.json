post_cb({"bq_ids": {"n4140": {"so_27830323_27831380_2": {"section_id": 709, "quality": 0.8333333333333334, "length": 5}, "so_27830323_27831380_3": {"section_id": 716, "quality": 1.0, "length": 14}, "so_27830323_27831380_14": {"section_id": 6290, "quality": 1.0, "length": 9}, "so_27830323_27831380_8": {"section_id": 705, "quality": 1.0, "length": 6}, "so_27830323_27831380_10": {"section_id": 709, "quality": 0.92, "length": 23}, "so_27830323_27831380_7": {"section_id": 716, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_27830323_27831380_2": {"section_id": 698, "quality": 0.8333333333333334, "length": 5}, "so_27830323_27831380_3": {"section_id": 705, "quality": 0.9285714285714286, "length": 13}, "so_27830323_27831380_8": {"section_id": 695, "quality": 1.0, "length": 6}, "so_27830323_27831380_14": {"section_id": 6050, "quality": 1.0, "length": 9}, "so_27830323_27831380_10": {"section_id": 698, "quality": 0.92, "length": 23}, "so_27830323_27831380_7": {"section_id": 705, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_27830323_27831380_2": {"section_id": 738, "quality": 0.8333333333333334, "length": 5}, "so_27830323_27831380_3": {"section_id": 746, "quality": 0.9285714285714286, "length": 13}, "so_27830323_27831380_8": {"section_id": 734, "quality": 0.8333333333333334, "length": 5}, "so_27830323_27831380_14": {"section_id": 7797, "quality": 1.0, "length": 9}, "so_27830323_27831380_10": {"section_id": 738, "quality": 0.92, "length": 23}, "so_27830323_27831380_7": {"section_id": 746, "quality": 0.8461538461538461, "length": 11}}}, "27830376": {"ParentId": "27830323", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The state of the moved-from vector is unspecified but valid after the move, as you found out.</p>\n<p>This means that it could really be in any valid state, in particular you can't assume that its capacity will be 0. It will probably be zero, and that would make a lot of sense, but that's not at all guaranteed.</p>\n<p>But again, in practice if you don't care all that much about the standard, I suppose that you could rely on the capacity being 0. Due to the constraints on move operations, the vector move constructor pretty much has to steal memory from the moved-from one, leaving it empty. That's what will happen in almost all cases/implementations, but that's just not required.</p>\n<p>A particularly twisted implementation could decide to reserve some elements in the moved-from vector just to mess with you. That technically wouldn't break any requirement.</p>\n", "OwnerUserId": "1401962", "LastEditorUserId": "1401962", "LastEditDate": "2015-01-07T23:18:12.767", "Id": "27830376", "Score": "1", "CreationDate": "2015-01-07T23:12:38.743", "LastActivityDate": "2015-01-07T23:18:12.767"}, "27831380": {"ParentId": "27830323", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If your question had been about move construction of a <code>vector</code>, the answer would be easy, the source <code>vector</code> is left empty after the move. This is because of the requirement in </p>\n<blockquote>\n<p id=\"so_27830323_27831380_0\">Table 99 \u2014 Allocator-aware container requirements</p>\n<p id=\"so_27830323_27831380_1\">Expression:</p>\n<pre><code>  X(rv)\n  X u(rv)\n</code></pre>\n<p id=\"so_27830323_27831380_2\">Requires: move construction of <code>A</code> shall not exit via an exception.<br/></p>\n<p id=\"so_27830323_27831380_3\">post: <code>u</code> shall have the same elements as <code>rv</code> had before this construction; the value of <code>u.get_allocator()</code> shall be the same as the value of <code>rv.get_allocator()</code> before this construction.</p>\n<p id=\"so_27830323_27831380_4\">Complexity: constant</p>\n</blockquote>\n<p>(the <code>A</code> in the requirements clause is the allocator type)</p>\n<p>The constant complexity leaves no option but to steal resources from the source <code>vector</code>, which means for it to be in a <em>valid, but unspecified state</em> you'd need to leave it empty, and <strong><code>capacity()</code> will equal zero</strong>.</p>\n<hr>\n<p>The answer is considerably more complicated in case of a move assignment. The same Table 99 lists the requirement for move assignment as</p>\n<blockquote>\n<p id=\"so_27830323_27831380_5\">Expression:</p>\n<pre><code>  a = rv\n</code></pre>\n<p id=\"so_27830323_27831380_6\">Return type:</p>\n<pre><code>  X&amp;\n</code></pre>\n<p id=\"so_27830323_27831380_7\">Requires: If <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> is\n  <code>false</code>, T is <code>MoveInsertable</code> into <code>X</code> and <code>MoveAssignable</code>. All existing elements of <code>a</code> are either move assigned to or destroyed.</p>\n<p id=\"so_27830323_27831380_8\">post: <code>a</code> shall be equal to the value that <code>rv</code> had before this assignment.</p>\n<p id=\"so_27830323_27831380_9\">Complexity: linear</p>\n</blockquote>\n<p>There are different cases to evaluate here. </p>\n<hr>\n<p>First, say <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value == true</code>, then the allocator can also be move assigned. This is mentioned in <code>\u00a723.2.1/8</code></p>\n<blockquote>\n<p id=\"so_27830323_27831380_10\"><code>...</code> <strong>The allocator may be replaced only via assignment</strong> or <code>swap()</code>. <strong>Allocator replacement is performed by</strong> copy assignment, <strong>move assignment</strong>, or swapping of the allocator\n  only if <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</code>,\n  <strong><code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code></strong>, or <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code> <strong>is true</strong> within the implementation of the corresponding container operation.</p>\n</blockquote>\n<p>So the destination <code>vector</code> will destroy its elements, the allocator from the source is moved and the destination <code>vector</code> takes ownership of the memory buffer from the source. This will leave the source <code>vector</code> empty, and <strong><code>capacity()</code> will equal zero</strong>.</p>\n<hr>\n<p>Now let's consider the case where <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value == false</code>. This means the allocator from the source cannot be move assigned to the destination <code>vector</code>. So you need to check the two allocators for equality before determining what to do.</p>\n<p>If <code>dest.get_allocator() == src.get_allocator()</code>, then the destination <code>vector</code> is free to take ownership of the memory buffer from the source because it can use its own allocator to deallocate the storage.</p>\n<blockquote>\n<p id=\"so_27830323_27831380_11\">Table 28 \u2014 Allocator requirements</p>\n<p id=\"so_27830323_27831380_12\">Expression:</p>\n<pre><code>  a1 == a2\n</code></pre>\n<p id=\"so_27830323_27831380_13\">Return type:</p>\n<pre><code>  bool\n</code></pre>\n<p id=\"so_27830323_27831380_14\">returns <code>true</code> only if storage allocated from each can be deallocated via the other. <code>...</code></p>\n</blockquote>\n<p>The sequence of operations performed is the same as the first case, except the source allocator is not move assigned. This will leave the source <code>vector</code> empty, and <strong><code>capacity()</code> will equal zero</strong>.</p>\n<hr>\n<p>In the last case, if <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value == false</code> and <code>dest.get_allocator() != src.get_allocator()</code>, then the source allocator cannot be moved, and the destination allocator is unable to deallocate the storage allocated by the source allocator, so it cannot steal the memory buffer from source.</p>\n<p>Each element from the source <code>vector</code> must be either <a href=\"http://en.cppreference.com/w/cpp/concept/MoveInsertable\" rel=\"nofollow\">move inserted</a> or <a href=\"http://en.cppreference.com/w/cpp/concept/MoveAssignable\" rel=\"nofollow\">move assigned</a> to the destination <code>vector</code>. Which operation gets done depends on the existing size and capacity of the destination <code>vector</code>.</p>\n<p>The source <code>vector</code> retains ownership of its memory buffer after the move assignment, and it is up to the implementation to decide whether to deallocate the buffer or not, and the <code>vector</code> will most likely have <strong><code>capacity() greater than 0</code></strong>.</p>\n<hr>\n<p>To ensure you do not run into undefined behavior when trying to resuse a <code>vector</code> that has been move assigned from, you should first call the <code>clear()</code> member function. This can be safely done since <code>vector::clear</code> has no pre-conditions, and will return the <code>vector</code> to a valid and specified state.</p>\n<p>Also, <code>vector::capacity</code> has no pre-conditions either, so you can always query the <code>capacity()</code> of a moved from <code>vector</code>.</p>\n</hr></hr></hr></hr></hr>", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2015-01-08T01:09:13.710", "Id": "27831380", "Score": "2", "CreationDate": "2015-01-08T01:02:07.673", "LastActivityDate": "2015-01-08T01:09:13.710"}, "27830323": {"CommentCount": "2", "ViewCount": "177", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2015-01-07T23:08:30.907", "LastActivityDate": "2015-01-08T01:09:13.710", "Title": "Capacity of the vector from which data was moved", "AcceptedAnswerId": "27831380", "LastEditDate": "2015-01-07T23:14:23.597", "Id": "27830323", "Score": "2", "Body": "<p>Is it mandatory, that the capacity of the <code>std::vector</code> is zero, after moving data from it? Assume that the memory allocators of source and destination vectors are always matching.</p>\n<pre><code>std::vector&lt; int &gt; v{1, 2, 3};\nassert(0 &lt; v.capacity());\nstd::vector&lt; int &gt; w;\nw = std::move(v);\nassert(0 == v.capacity());\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/vector/operator%3D\" rel=\"nofollow\">Here</a> said that move assignment operator leaves stealed RHS vector in a valid, but unspecified state. But nowhere pointed, that vector should perform additional memory allocations during move assignment operation. Another note is: vector have continuous memory region as underlying storage.</p>\n", "Tags": "<c++><vector><stl><move-semantics><c++14>", "OwnerUserId": "1430927", "AnswerCount": "2"}});