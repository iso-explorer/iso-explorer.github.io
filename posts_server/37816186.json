post_cb({"37818272": {"ParentId": "37816186", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>For C++14 and 11, Clang is right; however, things have changed in the latest working draft (the future C++17) - see the next section.</p>\n<p>The Standard quotes to look for are (from N4140, the draft closest to C++14):</p>\n<p>[temp.inst]/1:</p>\n<blockquote>\n<p id=\"so_37816186_37818272_0\">[...] The implicit instantiation of a class template specialization\n  causes the implicit instantiation of the declarations, but not of the\n  definitions, default arguments, or exception-specifications of the\n  class member functions, member classes, scoped member enumerations,\n  static data members and member templates; [...]</p>\n</blockquote>\n<p>[temp.point]/4:</p>\n<blockquote>\n<p id=\"so_37816186_37818272_1\">For a class template specialization, [...] the point of instantiation\n  for such a specialization immediately precedes the namespace scope\n  declaration or definition that refers to the specialization.</p>\n</blockquote>\n<p>So, the point of instantiation for <code>S&lt;U&gt;</code> is right before the declaration of <code>U</code>, with only a forward declaration <code>struct U;</code> conceptually inserted before, so that the name <code>U</code> is found.</p>\n<p>[class.static.data]/3:</p>\n<blockquote>\n<p id=\"so_37816186_37818272_2\">[...] A static data member of literal type can be declared in the\n  class definition with the <code>constexpr</code> specifier; if so, its\n  declaration shall specify a <em>brace-or-equal-initializer</em> in which\n  every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a\n  constant expression. [...] The member shall still be defined in a\n  namespace scope if it is odr-used (3.2) in the program and the\n  namespace scope definition shall not contain an <em>initializer</em>.</p>\n</blockquote>\n<p>According to the paragraph quoted above, the declaration of <code>bar</code> within the definition of <code>S</code>, even though it has an initializer, is still just a declaration, not a definition, so it's instantiated when <code>S&lt;U&gt;</code> is implicitly instantiated, and there's no <code>U::foo</code> at that time.</p>\n<p>A workaround is to make <code>bar</code> a function; according to the first quote, the function's definition will not be instantiated at the time of the implicit instantiation of <code>S&lt;U&gt;</code>. As long as you use <code>bar</code> after the definition of <code>U</code> has been seen (or from within the bodies of other member functions of <code>S</code>, since those, in turn, will only be instantiated separately when needed - [14.6.4.1p1]), something like this will work:</p>\n<pre><code>template&lt;class T&gt; struct S \n{\n   static constexpr int bar() { return T::foo; }\n};\n\nstruct U : S&lt;U&gt; { static constexpr int foo = 42; };\n\nint main()\n{\n   constexpr int b = U::bar();\n   static_assert(b == 42, \"oops\");\n}\n</code></pre>\n<hr>\n<p>Following the adoption of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf\" rel=\"nofollow\">P0386R2</a> into the working draft (currently <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf\" rel=\"nofollow\">N4606</a>), [class.static.data]/3 has been amended; the relevant part now reads:</p>\n<blockquote>\n<p id=\"so_37816186_37818272_3\">[...] An inline static data member may be defined in the class definition\n  and may specify a <em>brace-or-equal-initializer</em>. If the member is\n  declared with the <code>constexpr</code> specifier, it may be redeclared in\n  namespace scope with no initializer (this usage is deprecated; see\n  D.1). [...]</p>\n</blockquote>\n<p>This is complemented by the change to [basic.def]/2.3:</p>\n<blockquote>\n<p id=\"so_37816186_37818272_4\">A declaration is a <em>definition</em> unless:<br>\n  [...]</br></p>\n<ul>\n<li>it declares a non-inline static data member in a class definition (9.2, 9.2.3),  </li>\n</ul>\n<p id=\"so_37816186_37818272_5\">[...]</p>\n</blockquote>\n<p>So, if it's inline, it's a definition (with or without an initializer). And [dcl.constexpr]/1 says:</p>\n<blockquote>\n<p id=\"so_37816186_37818272_6\">[...] A function or static data member declared with the <code>constexpr</code>\n  specifier is implicitly an inline function or variable (7.1.6). [...]</p>\n</blockquote>\n<p>Which means the declaration of <code>bar</code> is now a definition, and according to the quotes in the previous section it's not instantiated for the implicit instantiation of <code>S&lt;U&gt;</code>; only a declaration of <code>bar</code>, which doesn't include the initializer, is instantiated at that time.</p>\n<p>The changes in this case are nicely summarized in the example in [depr.static_constexpr] in the current working draft:</p>\n<pre><code>struct A {\n   static constexpr int n = 5; // definition (declaration in C++ 2014)\n};\n\nconst int A::n; // redundant declaration (definition in C++ 2014)\n</code></pre>\n<p>This makes GCC's behaviour standard-conformant in C++1z mode.</p>\n</hr>", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2016-07-23T21:01:38.557", "Id": "37818272", "Score": "5", "CreationDate": "2016-06-14T17:11:53.953", "LastActivityDate": "2016-07-23T21:01:38.557"}, "bq_ids": {"n4140": {"so_37816186_37818272_0": {"section_id": 233, "quality": 0.9642857142857143, "length": 27}, "so_37816186_37818272_3": {"section_id": 5908, "quality": 0.5652173913043478, "length": 13}, "so_37816186_37818272_1": {"section_id": 219, "quality": 0.9375, "length": 15}, "so_37816186_37818272_2": {"section_id": 5908, "quality": 0.96875, "length": 31}}, "n3337": {"so_37816186_37818272_0": {"section_id": 226, "quality": 0.9285714285714286, "length": 26}, "so_37816186_37818272_3": {"section_id": 5680, "quality": 0.5652173913043478, "length": 13}, "so_37816186_37818272_1": {"section_id": 212, "quality": 0.9375, "length": 15}, "so_37816186_37818272_2": {"section_id": 5680, "quality": 0.96875, "length": 31}}, "n4659": {"so_37816186_37818272_0": {"section_id": 243, "quality": 0.9285714285714286, "length": 26}, "so_37816186_37818272_6": {"section_id": 6839, "quality": 0.9166666666666666, "length": 11}, "so_37816186_37818272_3": {"section_id": 7390, "quality": 1.0, "length": 23}, "so_37816186_37818272_1": {"section_id": 227, "quality": 0.9375, "length": 15}, "so_37816186_37818272_2": {"section_id": 7390, "quality": 0.75, "length": 24}}}, "37816186": {"CommentCount": "5", "AcceptedAnswerId": "37818272", "PostTypeId": "1", "LastEditorUserId": "4987285", "CreationDate": "2016-06-14T15:25:10.860", "LastActivityDate": "2016-07-23T21:01:38.557", "LastEditDate": "2016-06-15T19:07:04.240", "ViewCount": "656", "FavoriteCount": "2", "Title": "Initializing a static constexpr data member of the base class by using a static constexpr data member of the derived class", "Id": "37816186", "Score": "11", "Body": "<p>Consider the following code:</p>\n<pre><code>template&lt;typename T&gt;\nstruct S { static constexpr int bar = T::foo; };\n\nstruct U: S&lt;U&gt; { static constexpr int foo = 42; };\n\nint main() { }\n</code></pre>\n<p><a href=\"https://godbolt.org/g/xDmBPW\" rel=\"nofollow\">GCC v6.1</a> compiles it, <a href=\"https://godbolt.org/g/CQMXaJ\" rel=\"nofollow\">clang 3.8</a> rejects it with the error:</p>\n<blockquote>\n<p id=\"so_37816186_37816186_0\">2 : error: no member named 'foo' in 'U'<br>\n  struct S { static constexpr int bar = T::foo; };</br></p>\n</blockquote>\n<p>Which compiler is right?<br>\nCould it be due to the fact that <code>U</code> <a href=\"http://eel.is/c++draft/class#class.mem-6\" rel=\"nofollow\">is not a complete type</a> at the point where we try to use it within <code>S</code>?<br>\nIn this case, it should be considered a bug of GCC, but I'd like to know if I'm right before to search/open an issue on the bug tracker...</br></br></p>\n<p><strong>EDIT</strong></p>\n<p>Meanwhile I've opened a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71534\" rel=\"nofollow\">bug</a> to GCC.<br>\nWaiting for it to accept the answer.</br></p>\n", "Tags": "<c++><templates><c++14><constexpr><crtp>", "OwnerUserId": "4987285", "AnswerCount": "1"}});