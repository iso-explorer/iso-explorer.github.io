post_cb({"bq_ids": {"n4140": {"so_39432311_39434234_2": {"length": 27, "quality": 0.9, "section_id": 3325}, "so_39432311_39434234_1": {"length": 47, "quality": 0.94, "section_id": 3327}, "so_39432311_39434234_0": {"length": 24, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_39432311_39434234_2": {"length": 27, "quality": 0.9, "section_id": 3195}, "so_39432311_39434234_1": {"length": 35, "quality": 0.7, "section_id": 3197}, "so_39432311_39434234_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 3195}}, "n4659": {"so_39432311_39434234_2": {"length": 27, "quality": 0.9, "section_id": 4091}, "so_39432311_39434234_1": {"length": 43, "quality": 0.86, "section_id": 4093}, "so_39432311_39434234_0": {"length": 16, "quality": 0.6666666666666666, "section_id": 4091}}}, "39432311": {"ViewCount": "21", "Body": "<p>Why does <code>initializer_list&lt;string&gt; ls = {\"A\", \"B\", \"C\"};</code>  work?</p>\n<p>The rhs is of <code>intializer_list&lt;const char*&gt;</code>, I wonder how is it converted to the lhs.</p>\n<p>Similarly, how does <code>vector&lt;string&gt; vs = {\"A\", \"B\", \"C\"}</code> work ?</p>\n", "AcceptedAnswerId": "39434234", "Title": "rules on convariance for templates", "CreationDate": "2016-09-11T02:29:14.697", "Id": "39432311", "CommentCount": "0", "LastEditDate": "2016-09-11T07:54:33.020", "PostTypeId": "1", "LastEditorUserId": "678093", "LastActivityDate": "2016-09-11T08:27:50.277", "Score": "0", "OwnerUserId": "855160", "Tags": "<c++><templates><covariance>", "AnswerCount": "1"}, "39434234": {"Id": "39434234", "PostTypeId": "2", "Body": "<p><em>The rhs is of <code>intializer_list&lt;const char*&gt;</code></em></p>\n<p>This is wrong. Right hand side has no type. It is not an object of type <code>initializer_list</code>. It is <em>braced-init-list</em>, a special construct in language, used in several contexts.</p>\n<p><strong>[dcl.init.list]/3</strong> says this about your first question:</p>\n<blockquote>\n<p id=\"so_39432311_39434234_0\">List-initialization of an object or reference of type T is defined as follows:<br>\n  \u00a0\u00a0\u00a0\u00a0[...]<br>\n  \u2014 Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code>, a prvalue <code>initializer_list</code> object is constructed as described below and used to initialize the object according to the rules for initialization of an object from a class of the same type (8.5).</br></br></p>\n</blockquote>\n<p><strong>[dcl.init.list]/5</strong>:</p>\n<blockquote>\n<p id=\"so_39432311_39434234_1\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated a temporary array of <em>N</em> elements of type <em>const E</em>, where <em>N</em> is the number of elements in the <code>initializer list</code>. Each element of that array is copy-initialized with the corresponding element of the initializer list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array. <em>[ Note: A constructor or conversion function selected for the copy shall be accessible (Clause 11) in the context of the initializer list. \u2014end note ]</em> If a narrowing conversion is required to initialize any of the elements, the program is ill-formed.</p>\n</blockquote>\n<p>In short:</p>\n<ol>\n<li><p>First it allocates memory for array of 3 strings</p></li>\n<li><p>Then it tries to initialize each string with corresponding element from <em>init-list</em>. All elements of list are convertible to <code>const char*</code> and <code>std::string</code> has constructor accepting <code>const char*</code>, so it is used to construct those strings.</p></li>\n</ol>\n<p>In your second question another clause from <strong>[dcl.init.list]/3</strong> is used:</p>\n<blockquote>\n<p id=\"so_39432311_39434234_2\">List-initialization of an object or reference of type T is defined as follows:<br>\n      [...]<br>\n  \u2014 Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</br></br></p>\n</blockquote>\n<p><code>vector&lt;string&gt;</code> has a constructor taking <code>initializer_list&lt;string&gt;</code>. It is a best match in this case and we are back to stage 1: we need to construct <code>initializer_list&lt;string&gt;</code> from <em>braced-init-list</em>, which we already know how to do.</p>\n", "LastActivityDate": "2016-09-11T08:27:50.277", "CommentCount": "0", "CreationDate": "2016-09-11T08:27:50.277", "ParentId": "39432311", "Score": "0", "OwnerUserId": "3410396"}});