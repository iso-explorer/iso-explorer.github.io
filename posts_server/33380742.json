post_cb({"33380742": {"ViewCount": "3124", "Body": "<p>Suppose I have some <strong>legacy</strong> code which cannot be changed unless a <strong>bug</strong> is discovered, and it contains this code:</p>\n<pre><code>bool data[32];\nmemset(data, 0, sizeof(data));\n</code></pre>\n<p>Is this a safe way to set all <code>bool</code> in the array to a <code>false</code> value?</p>\n<p>More generally, is it safe to <code>memset</code> a <code>bool</code> to <code>0</code> in order to make its value <code>false</code>?</p>\n<p>Is it guaranteed to work on all compilers? Or do I to request a fix?</p>\n", "AcceptedAnswerId": "33398698", "Title": "Is it safe to memset bool to 0?", "CreationDate": "2015-10-28T00:12:13.230", "Id": "33380742", "CommentCount": "19", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2015-10-29T15:41:40.860", "LastEditorUserId": "2068573", "LastActivityDate": "2015-11-03T16:50:32.973", "Score": "31", "OwnerUserId": "2068573", "Tags": "<c++><language-lawyer><memset>", "AnswerCount": "4"}, "33380982": {"Id": "33380982", "PostTypeId": "2", "Body": "<p><strong>No.</strong> It is not safe (or more specifically, portable). However, it likely <em>works</em> by virtue of the fact that your typical implementation will:</p>\n<ol>\n<li>use 0 to represent a boolean (actually, the C++ specification requires it)</li>\n<li>generate an array of elements that <code>memset()</code> can deal with.</li>\n</ol>\n<p>However, best practice would dictate using <code>bool data[32] = {false}</code> - additionally, this will likely free the compiler up to internally represent the structure differently - since using <code>memset()</code> could result in it generating a 32 byte array of values rather than, say, a single 4 byte that will fit nicely within your average CPU register.</p>\n", "LastEditorUserId": "234946", "LastActivityDate": "2015-10-28T02:34:04.500", "Score": "9", "CreationDate": "2015-10-28T00:39:15.813", "ParentId": "33380742", "CommentCount": "13", "OwnerUserId": "234946", "LastEditDate": "2015-10-28T02:34:04.500"}, "bq_ids": {"n4140": {"so_33380742_33398698_8": {"length": 11, "quality": 0.9166666666666666, "section_id": 5365}, "so_33380742_33380798_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7216}, "so_33380742_33398698_6": {"length": 36, "quality": 0.8372093023255814, "section_id": 7216}, "so_33380742_33398698_3": {"length": 9, "quality": 0.9, "section_id": 7212}, "so_33380742_33398698_9": {"length": 14, "quality": 1.0, "section_id": 26}, "so_33380742_33398698_7": {"length": 6, "quality": 1.0, "section_id": 7215}, "so_33380742_33398698_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 7202}, "so_33380742_33398698_4": {"length": 34, "quality": 0.8095238095238095, "section_id": 7202}}, "n3337": {"so_33380742_33398698_8": {"length": 11, "quality": 0.9166666666666666, "section_id": 5161}, "so_33380742_33380798_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 6960}, "so_33380742_33398698_4": {"length": 34, "quality": 0.8095238095238095, "section_id": 6946}, "so_33380742_33398698_9": {"length": 14, "quality": 1.0, "section_id": 23}, "so_33380742_33398698_7": {"length": 6, "quality": 1.0, "section_id": 6959}, "so_33380742_33398698_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 6946}, "so_33380742_33398698_6": {"length": 36, "quality": 0.8372093023255814, "section_id": 6960}}, "n4659": {"so_33380742_33398698_8": {"length": 11, "quality": 0.9166666666666666, "section_id": 6790}, "so_33380742_33380798_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 8725}, "so_33380742_33398698_4": {"length": 34, "quality": 0.8095238095238095, "section_id": 8711}, "so_33380742_33398698_3": {"length": 9, "quality": 0.9, "section_id": 8721}, "so_33380742_33398698_9": {"length": 14, "quality": 1.0, "section_id": 26}, "so_33380742_33398698_7": {"length": 6, "quality": 1.0, "section_id": 8724}, "so_33380742_33398698_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 8711}, "so_33380742_33398698_2": {"length": 7, "quality": 0.5384615384615384, "section_id": 6901}, "so_33380742_33398698_6": {"length": 36, "quality": 0.8372093023255814, "section_id": 8725}}}, "33380764": {"Id": "33380764", "PostTypeId": "2", "Body": "<p><strong>Is it guaranteed by the law? No.</strong></p>\n<p>C++ says nothing about the representation of <code>bool</code> values.</p>\n<p><strong>Is it guaranteed by practical reality? Yes.</strong></p>\n<p>I mean, if you wish to find a C++ implementation that does not represent boolean <code>false</code> as a sequence of zeroes, I shall wish you luck. Given that <code>false</code> must implicitly convert to <code>0</code>, and <code>true</code> must implicitly convert to <code>1</code>, and <code>0</code> must implicitly convert to <code>false</code>, and non-<code>0</code> must implicitly convert to <code>true</code> \u2026 well, you'd be silly to implement it any other way.</p>\n<p>Whether that means it's \"safe\" is for you to decide.</p>\n<p>I don't usually say this, but if I were in your situation I would be happy to let this slide. If you're really concerned, you can add a test executable to your distributable to validate the precondition on each target platform before installing the real project.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-10-28T11:08:50.707", "Score": "23", "CreationDate": "2015-10-28T00:14:41.207", "ParentId": "33380742", "CommentCount": "21", "OwnerUserId": "560648", "LastEditDate": "2015-10-28T11:08:50.707"}, "33398698": {"Id": "33398698", "PostTypeId": "2", "Body": "<p>I believe this unspecified although it seems likely the underlying representation of <code>false</code> would be all zeros. <a href=\"http://www.boost.org/doc/libs/1_59_0/doc/html/container/Cpp11_conformance.html#container.Cpp11_conformance.non_standard_memset_initialization\" rel=\"nofollow\">Boost.Container relies on this as well</a> (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_33380742_33398698_0\">Boost.Container uses std::memset with a zero value to initialize some\n  types as in most platforms this initialization yields to the desired\n  value initialization with improved performance.</p>\n<p id=\"so_33380742_33398698_1\">Following the C11 standard, Boost.Container assumes that for any\n  integer type, the object representation where all the bits are zero\n  shall be a representation of the value zero in that type. <strong>Since\n  _Bool/wchar_t/char16_t/char32_t are also integer types in C, it considers all C++ integral types as initializable via std::memset.</strong></p>\n</blockquote>\n<p>This C11 quote they they point to as a rationale actually comes from a C99 defect: <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_263.htm\" rel=\"nofollow\">defect 263: all-zero bits representations</a> which added the following:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_2\">For any integer type, the object representation where all the bits are\n  zero shall be a representation of the value zero in that type.</p>\n</blockquote>\n<p>So then the question here is the assumption correct, are the underlying object representation for integer compatible between C and C++? \nThe proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2631.html\" rel=\"nofollow\">Resolving the difference between C and C++ with regards to object representation of integers</a> sought to answer this to some extent which as far as I can tell was not resolved. I can not find conclusive evidence of this in the draft standard. We have a couple of cases where it links to the C standard explicitly with respect to types. Section <code>3.9.1</code> <em>[basic.fundamental]</em> says:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_3\">[...] The signed and unsigned integer types shall satisfy the\n  constraints given in the C standard, section 5.2.4.2.1.</p>\n</blockquote>\n<p>and <code>3.9</code> <em>[basic.types]</em> which says:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_4\">The object representation of an object of type T is the sequence of N\n  unsigned char objects taken up by the object of type T, where N equals\n  sizeof(T). The value representation of an object is the set of bits\n  that hold the value of type T. For trivially copyable types, the value\n  representation is a set of bits in the object representation that\n  determines a value, which is one discrete element of an\n  implementation-defined set of values.<sup>44</sup></p>\n</blockquote>\n<p>where footnote 44(<em>which is not normative</em>) says:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_5\">The intent is that the memory model of C++ is compatible with that of\n  ISO/IEC 9899 Programming Language C.</p>\n</blockquote>\n<p>The farthest the draft standard gets to specifying the underlying representation of <em>bool</em> is in section <code>3.9.1</code>:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_6\">Types bool, char, char16_t, char32_t, wchar_t, and the signed and\n  unsigned integer types are collectively called integral types.50 A\n  synonym for integral type is integer type. The representations of\n  integral types shall define values by use of a pure binary numeration\n  system.51 [ Example: this International Standard permits 2\u2019s\n  complement, 1\u2019s complement and signed magnitude representations for\n  integral types. \u2014end example ]</p>\n</blockquote>\n<p>the section also says:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_7\">Values of type bool are either true or false.</p>\n</blockquote>\n<p>but all we know of <code>true</code> and <code>false</code> is:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_8\">The Boolean literals are the keywords false and true. Such literals\n  are prvalues and have type bool.</p>\n</blockquote>\n<p>and we know they are convertible to <code>0</code> an <code>1</code>:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_9\">A prvalue of type bool can be converted to a prvalue of type int, with\n  false becoming zero and true becoming one.</p>\n</blockquote>\n<p>but this gets us no closer to the underlying representation.</p>\n<p>As far as I can tell the only place where the standard references the actual underlying bit value besides padding bits was removed via <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1796\" rel=\"nofollow\">defect report 1796: Is all-bits-zero for null characters a meaningful requirement? </a>:</p>\n<blockquote>\n<p id=\"so_33380742_33398698_10\">It is not clear that a portable program can examine the bits of the representation; instead, it would appear to be limited to examining the bits of the numbers corresponding to the value representation (3.9.1 [basic.fundamental] paragraph 1). It might be more appropriate to require that the null character value compare equal to 0 or '\\0' rather than specifying the bit pattern of the representation.</p>\n</blockquote>\n<p>There are more <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1943\" rel=\"nofollow\">defect reports</a> that deal with the gaps in the standard with respect to what is a bit and difference between the value and object representation. </p>\n<p>Practically, I would expect this to work, I would not consider it safe since we can not nail this down in the standard. Do you need to change it, not clear, you clearly have a non-trivial trade-off involved. So assuming it works now the question is do we consider it likely to break with future versions of various compilers, that is unknown.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-03T16:50:32.973", "Score": "7", "CreationDate": "2015-10-28T18:20:09.437", "ParentId": "33380742", "CommentCount": "7", "OwnerUserId": "1708801", "LastEditDate": "2015-11-03T16:50:32.973"}, "33380798": {"Id": "33380798", "PostTypeId": "2", "Body": "<p>From 3.9.1/7:</p>\n<blockquote>\n<p id=\"so_33380742_33380798_0\">Types bool , char , char16_t , char32_t , wchar_t , and the signed and\n  unsigned integer types are collectively called integral types. A\n  synonym for integral type is integer type . The representations of\n  integral types shall define values by use of a pure binary numeration\n  system.</p>\n</blockquote>\n<p>Given this I can't see any possible implementation of <code>bool</code> that wouldn't represent false as all 0 bits.</p>\n", "LastActivityDate": "2015-10-28T00:18:56.120", "CommentCount": "13", "CreationDate": "2015-10-28T00:18:56.120", "ParentId": "33380742", "Score": "6", "OwnerUserId": "251738"}});