post_cb({"bq_ids": {"n4140": {"so_5108111_5108295_0": {"length": 21, "quality": 0.75, "section_id": 3223}}, "n3337": {"so_5108111_5108295_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 3097}}, "n4659": {"so_5108111_5108295_0": {"length": 21, "quality": 0.75, "section_id": 3980}}}, "5108111": {"ViewCount": "569", "Body": "<p>I have this class that makes a path for a montecarlo simulator where it takes creates paths of integers from an array of available ints. So for example we could have a path of length 3 drawn from the array containing {0,1,2,3,4} and this would for example generate 3,1,2 and 1,4,0.</p>\n<pre><code>//This path generator just generates a list of ints for each path\ntemplate&lt; typename randgen &gt;\nclass MCPathGen {\n    public:\n        typedef vector&lt; int &gt; mcpath_t;\n        typedef randgen randgen_t;\n        typedef typename add_lvalue_reference&lt;randgen&gt;::type randgen_ref_t;\n\n        MCPathGend(randgen_ref_t r) : m_rgen(r) {}\n\n        //generate a single path by shuffling a copy of blank_d\n        mcpath_t operator()() {\n            Chooser&lt; randgen_t &gt; choose(m_rgen);\n            mcpath_t path_temp(blank_d.begin(), blank_d.end());\n            random_shuffle(path_temp.begin(), path_temp.end(), choose);\n\n            return path_temp;\n        };\n\n    private:\n        randgen_ref_t m_rgen;\n\n};\n</code></pre>\n<p>Now I'm not quite sure what my colleague has done by using <code>typedef typename add_lvalue_reference&lt;randgen&gt;::type randgen_ref_t;</code></p>\n<p>What does add_lvalue_reference do?\nIs this necessary for making the code work?</p>\n<p>I have not seen this before, so any insight is appreciated!</p>\n", "AcceptedAnswerId": "5108295", "Title": "What does add_lvalue_reference do?", "CreationDate": "2011-02-24T17:20:25.267", "Id": "5108111", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2011-02-24T18:10:47.697", "Score": "6", "OwnerUserId": "296460", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "5108295": {"Id": "5108295", "PostTypeId": "2", "Body": "<p>Copying pseudo-random number generators means you'd get the same stream of \"random\" numbers from each, which is not desirable, so you need a reference there.</p>\n<p>However, <strong>you could just say <code>randgen&amp;</code>.</strong></p>\n<p>According to <code>[dcl.ref]</code> in draft 3225, just <code>randgen&amp;</code> will create an lvalue reference no matter what's passed in (type, lvalue-reference-type, or rvalue-reference-type), so I'd just use that.</p>\n<p>Quote from the standard that controls this behavior:</p>\n<blockquote>\n<p id=\"so_5108111_5108295_0\">If a <em>typedef</em> (7.1.3), a type <em>template-parameter</em> (14.3.1), or a <em>decltype-speci\ufb01er</em> (7.1.6.2) denotes a type <strong><code>TR</code></strong> that is a reference to a type <strong><code>T</code></strong>, an attempt to create the type \u201clvalue reference to <em>cv</em> <strong><code>TR</code></strong>\u201d creates the type\n  \u201clvalue reference to <strong><code>T</code></strong>\u201d, while an attempt to create the type \u201crvalue reference to <em>cv</em> <strong><code>TR</code></strong>\u201d creates the type <strong><code>TR</code></strong>.</p>\n<p id=\"so_5108111_5108295_1\">[ Example:</p>\n</blockquote>\n<pre><code>int  i;\ntypedef  int&amp;  LRI;\ntypedef  int&amp;&amp;  RRI;\n\nLRI&amp;  r1  =  i; // r1 has the type int&amp;\nconst  LRI&amp;  r2  =  i; // r2 has the type int&amp;\nconst  LRI&amp;&amp;  r3  =  i; // r3 has the type int&amp;\n\nRRI&amp;  r4  =  i; // r4 has the type int&amp;\nRRI&amp;&amp;  r5  =  i; // r5 has the type int&amp;&amp;\n\ndecltype(r2)&amp;  r6  =  i; // r6 has the type int&amp;\ndecltype(r2)&amp;&amp;  r7  =  i; // r7 has the type int&amp;\n</code></pre>\n<blockquote>\n<p id=\"so_5108111_5108295_2\">\u2014 end example ]</p>\n</blockquote>\n<p>From section <code>[meta.trans.ref]</code>:</p>\n<blockquote>\n<p id=\"so_5108111_5108295_3\"><code>template &lt;class T&gt; struct add_lvalue_reference;</code>\n  If <strong><code>T</code></strong> names an object or function type then the member typedef <code>type</code>\n  shall name <strong><code>T&amp;</code></strong>; otherwise, if <strong><code>T</code></strong> names a type \u201crvalue reference to <strong><code>T1</code></strong>\u201d then\n  the member typedef <code>type</code> shall name <strong><code>T1&amp;</code></strong>; otherwise, type shall name <strong><code>T</code></strong>.</p>\n</blockquote>\n<p>They are exactly the same thing.</p>\n<p>In C++03, they're the same thing too.  From <code>[type.arg.type]</code>:</p>\n<blockquote>\n<p id=\"so_5108111_5108295_4\">If a template-argument for a template-parameter <strong><code>T</code></strong> names a type \u201creference to <em>cv1</em> <strong><code>S</code></strong>\u201d, an attempt to create the type\n  \u201creference to <em>cv2</em> <strong><code>T</code></strong>\u201d creates the type \u201creference to <em>cv12</em> <strong><code>S</code></strong>\u201d, where <em>cv12</em> is the union of the cv-quali\ufb01ers <em>cv1</em> and <em>cv2</em>.\n  Redundant cv-quali\ufb01ers are ignored.</p>\n<p id=\"so_5108111_5108295_5\">[ Example:</p>\n</blockquote>\n<pre><code>template   &lt; class  T &gt;  class   X  {\nvoid   f( const   T &amp;);\n/ \u2217 . . . \u2217 /\n};\nX&lt; int &amp; &gt;  x;          / / X&lt;int&amp;&gt;::f has the parameter type const  int&amp;\n</code></pre>\n<blockquote>\n<p id=\"so_5108111_5108295_6\">\u2014 end example ]</p>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2011-02-24T18:07:28.483", "Score": "5", "CreationDate": "2011-02-24T17:33:40.340", "ParentId": "5108111", "CommentCount": "7", "OwnerUserId": "103167", "LastEditDate": "2011-02-24T18:07:28.483"}});