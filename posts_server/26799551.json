post_cb({"26800526": {"ParentId": "26799551", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-07T11:45:38.487", "Score": "0", "LastEditorUserId": "2069064", "LastEditDate": "2014-11-07T11:51:12.403", "Id": "26800526", "OwnerUserId": "2069064", "Body": "<p>In this case, the standard is extremely straightforward</p>\n<blockquote>\n<p id=\"so_26799551_26800526_0\">\u00a714.5.2.3) A member function template shall not be virtual. [ <em>Example:</em></p>\n</blockquote>\n<pre><code>template &lt;class T&gt; struct AA {\n    template &lt;class C&gt; virtual void g(C); // error\n    virtual void f(); // OK\n};\n</code></pre>\n<blockquote>\n<p id=\"so_26799551_26800526_1\"><em>\u2014 end example</em> ]</p>\n</blockquote>\n<p>Basically, how would you implement them? What would the vtable look like? </p>\n<p>If all you need is a type that is \"in-streamable\", I'd recommend checking out the <a href=\"http://www.boost.org/doc/libs/1_57_0/doc/html/boost_typeerasure/basic.html\" rel=\"nofollow\">Boost.TypeErasure</a> library. It may not exactly solve your problem, but it's pretty neat. You'll need something like:</p>\n<pre><code>using Inputable = any&lt;\n    mpl::vector&lt;\n        copy_constructible&lt;&gt;,\n        typeid_&lt;&gt;,\n        istreamable&lt;&gt;\n    &gt;\n&gt;;\n\nvirtual Inputable askFor(const std::string&amp; mesg) const = 0;\n</code></pre>\n<p>Probably something more involved than that, I've only played around with that library but it makes it possible to have a virtual \"template\" member function as long as you clearly define what it is you need your template type to do. (Note that there's also an <code>any_cast</code> so the caller knows what type he wants to get, he can always cast the result to it.)</p>\n", "LastActivityDate": "2014-11-07T11:51:12.403"}, "26810306": {"ParentId": "26799551", "CommentCount": "0", "Body": "<p>Based on your comments, I would advice to give the interface a series of virtual functions for a limited set of types you want to support. In derived classes you can forward the call of each overridden function to a single template function that implements the desired functionality.</p>\n", "OwnerUserId": "1741297", "PostTypeId": "2", "Id": "26810306", "Score": "0", "CreationDate": "2014-11-07T21:23:08.387", "LastActivityDate": "2014-11-07T21:23:08.387"}, "26799551": {"CommentCount": "6", "ViewCount": "405", "PostTypeId": "1", "LastEditorUserId": "1741297", "CreationDate": "2014-11-07T10:49:49.977", "LastActivityDate": "2014-11-07T21:39:48.830", "Title": "Alternative for virtual template functions", "LastEditDate": "2014-11-07T21:39:48.830", "Id": "26799551", "Score": "1", "Body": "<p>I Have an abstract <code>UI</code> class that needs to be able to ask the user for some input.\nThis function is templated because different things can be asked for.</p>\n<p>However, this function must also be virtual because I want derived classes of <code>UI</code> to be able to \nprovide their own implementations (a <code>CommandLineUI</code> will need to behave differently from \n<code>WebBasedUI</code>). </p>\n<pre><code>class UI {\n    // ...\n\n    public:\n        // ask some input\n        template&lt;T&gt;\n        virtual T askFor(const std::string&amp; mesg) const = 0;\n\n        // ask but provide default fallback\n        template&lt;T&gt;\n        virtual T askFor(const std::string&amp; mesg, const T&amp; def) const = 0;\n}\n\nclass CommandLineUI : UI {\n    // ...\n    public:\n        template&lt;T&gt;\n        virtual T askFor(const std::string&amp; mesg) const {\n            // implementation details\n        }\n        template&lt;T&gt;\n        virtual T askFor(const std::string&amp; mesg, const T&amp; def) const {\n            // implementation details\n        }\n}\n</code></pre>\n<p>The above code will not work however, since a templated method cannot be virtual in C++,\nfor reasons that go above me.</p>\n<p>I read some things about the Visitor pattern or type erasure being able to fix this problem, but I fail to see how. (I tried to translate the examples found in answers to \nsimilar stack overflow questions but this wasn't successful).</p>\n", "Tags": "<c++><templates><inheritance><polymorphism><virtual>", "OwnerUserId": "600545", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26799551_26800526_0": {"section_id": 112, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_26799551_26800526_0": {"section_id": 107, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_26799551_26800526_0": {"section_id": 116, "quality": 0.6666666666666666, "length": 4}}}});