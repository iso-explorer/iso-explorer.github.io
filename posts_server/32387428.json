post_cb({"bq_ids": {"n4140": {"so_32387428_32387467_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}}, "n3337": {"so_32387428_32387467_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}}}, "32387428": {"ViewCount": "199", "Body": "<p>The following code compiles under Visual Studio 2013, and fails to compile under gcc/clang (all tested versions).</p>\n<p>clang: <code>error: use 'template' keyword to treat 'write' as a dependent template name</code></p>\n<p>gcc: <code>error: expected primary-expression before \u2018int\u2019</code></p>\n<p>Both errors occur where indicated in the code</p>\n<pre><code>template &lt;typename Itr&gt;    \nstruct A {        \n    template &lt;typename Other&gt;    \n    void write(Other x) {}    \n};      \n\ntemplate &lt;class T&gt;    \nstruct B {       \n   A&lt;T&gt;&amp; a;    \n   B(A&lt;T&gt;&amp; a) : a(a) {    \n      // error: use 'template' keyword to treat 'write' as a dependent template name    \n      a.write&lt;int&gt;(5);    \n   }    \n}; \n\nint main() {    \n    A&lt;int&gt; a;    \n    // Fine    \n    a.write&lt;int&gt;(5);    \n    B&lt;int&gt; b(a);    \n}\n</code></pre>\n<p>Experience tells me that Visual Studio is probably wrong, but I'm not sure why this should fail to compile when <code>A&lt;T&gt;</code> is fully specified, and I'm only wanting to call a template method whose type I specify.</p>\n", "AcceptedAnswerId": "32387467", "Title": "Dependent Template Compiles with Visual Studio, but fails with clang/gcc", "CreationDate": "2015-09-04T00:27:59.737", "Id": "32387428", "CommentCount": "3", "LastEditDate": "2015-10-02T00:17:45.800", "PostTypeId": "1", "LastEditorUserId": "1783619", "LastActivityDate": "2015-10-02T00:17:45.800", "ClosedDate": "2015-09-04T00:36:56.743", "Score": "1", "OwnerUserId": "3870920", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}, "32387467": {"PostTypeId": "2", "Body": "<p>From [temp.names], emphasis mine:</p>\n<blockquote>\n<p id=\"so_32387428_32387467_0\">When the <strong>name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a <em>postfix-expression</em></strong> or after a\n  <em>nested-name-specifier</em> in a <em>qualified-id</em>, and <strong>the object expression of the <em>postfix-expression</em> is <em>type-dependent</em></strong>\n  or the <em>nested-name-specifier</em> in the <em>qualified-id</em> refers to a dependent type, but the name is not a member of\n  the current instantiation (14.6.2.1), the member template name <strong>must be prefixed by the keyword <code>template</code></strong>.\n  Otherwise the name is assumed to name a non-template.</p>\n</blockquote>\n<p>Here, <code>write</code> is a member template specialization that appears after a <code>.</code> in a <em>postfix-expression</em>, and <code>a</code> is <em>type-dependent</em> (it depends on <code>T</code>), and <code>a</code> is not a member of the current instantiation (which would be <code>B&lt;T&gt;</code>), so it must be prefixed with <code>template</code>. gcc and clang are correct to reject this code, as it should be treated as if <code>write</code> were a non-template and the <code>&lt;</code> were an operator - which is invalid. </p>\n", "LastActivityDate": "2015-09-04T00:34:25.283", "Id": "32387467", "CommentCount": "3", "CreationDate": "2015-09-04T00:34:25.283", "ParentId": "32387428", "Score": "1", "OwnerUserId": "2069064"}});