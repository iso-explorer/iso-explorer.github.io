post_cb({"29402590": {"ParentId": "29402367", "LastEditDate": "2015-04-01T23:38:25.877", "CommentCount": "0", "CreationDate": "2015-04-01T23:25:36.650", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "PostTypeId": "2", "Id": "29402590", "Score": "3", "Body": "<p>The arithmetic operators perform the integral promotions on their operand. Specifically [expr.unary.op]/9 says that this happens for <code>~</code> too.</p>\n<p>So <code>~t</code> is the same as <code>~1</code>. This gives a valid non-zero integer.</p>\n<p>Integer-to-bool conversions are defined by [conv.bool]: </p>\n<blockquote>\n<p id=\"so_29402367_29402590_0\">A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true</p>\n</blockquote>\n<p>so <code>bool t2 = ~t;</code> yields <code>t2 == true</code>.  There is no undefined behaviour.</p>\n<hr>\n<p><code>~f</code> is the same as <code>~0</code>. In 2's complement, <code>~0</code> gives <code>-1</code>, so we will have <code>f2 == true</code>.</p>\n<p><sub>In 1's complement -- if there were ever a C++ system that uses 1's complement -- then the effect of <code>~0</code> is unclear.</sub></p>\n</hr>", "LastActivityDate": "2015-04-01T23:38:25.877"}, "29402367": {"CommentCount": "4", "CreationDate": "2015-04-01T23:06:18.797", "PostTypeId": "1", "AcceptedAnswerId": "29402657", "LastEditorUserId": "64046", "LastActivityDate": "2015-04-06T17:05:24.910", "LastEditDate": "2015-04-06T17:05:24.910", "ViewCount": "308", "FavoriteCount": "1", "Title": "Does using bitwise not operator (~) on boolean values invoke Undefined Behavior?", "Id": "29402367", "Score": "10", "Body": "<p>If a C++ program applies the bitwise-not operator (~) to a boolean value, does that invoke Undefined Behavior?</p>\n<p>E.g. is the following program well-defined?</p>\n<pre><code>bool f = false;\nbool f2 = ~f;    // is f2 guaranteed to be true, or is this UB?\nbool t = true;\nbool t2 = ~t;    // is t2 guaranteed to be false, or is this UB?\n</code></pre>\n<p>(Yes, I know there is a ! operator that is better-suited to this sort of thing; for purposes of this question we will ignore its existence ;))</p>\n", "Tags": "<c++><bit-manipulation><language-lawyer><undefined-behavior>", "OwnerUserId": "131930", "AnswerCount": "3"}, "29402576": {"ParentId": "29402367", "LastEditDate": "2015-04-02T00:35:09.820", "CommentCount": "0", "CreationDate": "2015-04-01T23:24:40.070", "OwnerUserId": "991484", "LastEditorUserId": "991484", "PostTypeId": "2", "Id": "29402576", "Score": "1", "Body": "<pre><code>bool t = true;\nbool t2 = ~t;    // is t2 guaranteed to be false, or is this UB?\n</code></pre>\n<p>I suppose it is not guaranteed, seeing how</p>\n<pre><code>  bool b = true;\n  bool b1 = ~b;\n  cout &lt;&lt; b1;\n</code></pre>\n<p>outputs a \"true\"</p>\n<p>I suppose it has to do with boolean representation... if it is a byte, then <code>00000001</code> will negate to <code>11111110</code> which is not zero. Promotion might also be at play, but it's the same tune.</p>\n<p>The key here is it is \"bitwise\" not \"logical\". So one should not expect the two to match, unless the boolean representation is a single bit.</p>\n<p>Easily entirely defined behavior. </p>\n", "LastActivityDate": "2015-04-02T00:35:09.820"}, "bq_ids": {"n4140": {"so_29402367_29402657_2": {"section_id": 5943, "quality": 0.6666666666666666, "length": 4}, "so_29402367_29402590_0": {"section_id": 44, "quality": 1.0, "length": 15}, "so_29402367_29402657_1": {"section_id": 26, "quality": 0.9333333333333333, "length": 14}, "so_29402367_29402657_0": {"section_id": 6073, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_29402367_29402657_2": {"section_id": 5714, "quality": 0.6666666666666666, "length": 4}, "so_29402367_29402590_0": {"section_id": 41, "quality": 1.0, "length": 15}, "so_29402367_29402657_1": {"section_id": 23, "quality": 0.9333333333333333, "length": 14}, "so_29402367_29402657_0": {"section_id": 5841, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_29402367_29402590_0": {"section_id": 45, "quality": 1.0, "length": 15}, "so_29402367_29402657_2": {"section_id": 7428, "quality": 0.6666666666666666, "length": 4}, "so_29402367_29402657_0": {"section_id": 7569, "quality": 0.7777777777777778, "length": 14}, "so_29402367_29402657_1": {"section_id": 26, "quality": 0.9333333333333333, "length": 14}}}, "29402657": {"ParentId": "29402367", "LastEditDate": "2015-04-01T23:59:14.190", "CommentCount": "4", "CreationDate": "2015-04-01T23:31:23.447", "OwnerUserId": "1670129", "LastEditorUserId": "1670129", "PostTypeId": "2", "Id": "29402657", "Score": "8", "Body": "<blockquote>\n<p id=\"so_29402367_29402657_0\"><strong>5.3.1/10</strong> The operand of <code>~</code> shall have integral or unscoped enumeration type; the result is the one\u2019s complement of its operand. <strong>Integral promotions are performed.</strong> [emphasis mine]</p>\n<p id=\"so_29402367_29402657_1\"><strong>4.5/6</strong> A prvalue of type <code>bool</code> can be converted to a prvalue of type <code>int</code>, with <code>false</code> becoming zero and <code>true</code> becoming one.</p>\n<p id=\"so_29402367_29402657_2\"><strong>4.5/7</strong> These conversions are called <em>integral promotions</em>.</p>\n</blockquote>\n<p>So <code>~false</code> is an <code>int</code> with a bit pattern consisting of all ones - one's complement of a bit pattern representing 0, namely all zeros (as required by <strong>3.9.1/7</strong>.) Similarly, <code>~true</code> is an <code>int</code> that's one's complement of the bit representation of 1 - namely, all ones with the least significant bit zero. Both these values will evaluate to <code>true</code> in boolean context.</p>\n", "LastActivityDate": "2015-04-01T23:59:14.190"}});