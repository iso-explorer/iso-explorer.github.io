post_cb({"bq_ids": {"n4140": {"so_28141871_28142480_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 6073}, "so_28141871_28142480_6": {"length": 38, "quality": 1.0, "section_id": 21}, "so_28141871_28142480_2": {"length": 42, "quality": 0.9333333333333333, "section_id": 6147}, "so_28141871_28142480_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 6146}}, "n3337": {"so_28141871_28142480_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 5841}, "so_28141871_28142480_6": {"length": 38, "quality": 1.0, "section_id": 18}, "so_28141871_28142480_2": {"length": 35, "quality": 0.7777777777777778, "section_id": 5910}, "so_28141871_28142480_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 5909}}, "n4659": {"so_28141871_28142480_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 7569}, "so_28141871_28142480_6": {"length": 38, "quality": 1.0, "section_id": 21}, "so_28141871_28142480_2": {"length": 42, "quality": 0.9333333333333333, "section_id": 7643}, "so_28141871_28142480_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 7642}}}, "28142065": {"Id": "28142065", "PostTypeId": "2", "Body": "<p>You're quite correct -- the expression <code>~'q' &lt;&lt; 6</code> is undefined behavior according to the standard.  Its even worse than you state, as the <code>~</code> operator is defined as computing \"The one's complement\" of the value, which is meaningless for a signed (2s-complement) integer -- the term \"one's complement\" only really means anything for an unsigned integer.</p>\n<p>When doing bitwise operations, if you want strictly well-defined (according to the standard) results, you generally have to ensure that the values being operated on are unsigned.  You can do that either with explicit casts, or by using explicitly unsigned constants (<code>U</code>-suffix) in binary operations.  Doing a binary operation with a signed and unsigned int is done as unsigned (the signed value is converted to unsigned).</p>\n<p>C and C++ are subtley different with the integer promotions, so you need to be careful here -- C++ will convert a smaller-than-int unsigned value to int (signed) before comparing with the other operand to see what should be done, while C will compare operands first.</p>\n", "LastActivityDate": "2015-01-25T22:00:43.680", "CommentCount": "8", "CreationDate": "2015-01-25T22:00:43.680", "ParentId": "28141871", "Score": "5", "OwnerUserId": "16406"}, "28142057": {"Id": "28142057", "PostTypeId": "2", "Body": "<p>Of course, by editing the question, my answer is now partly answering a different question than the one posed, so here goes an attempt to answer the \"new\" question:</p>\n<p>The promotion rules (what gets converted to what) are well defined in the standard. The type <code>char</code> may be either <code>signed</code> or <code>unsigned</code> - in some compilers you can even give a flag to the compiler to say \"I want unsigned char type\" or \"I want signed char type\" - but most compilers just define <code>char</code> as either <code>signed</code> or <code>unsigned</code>. </p>\n<p>A constant, such as <code>6</code> is signed by default. When an operation, such as <code>'q' &lt;&lt; 6</code> is written in the code, the compiler will convert any smaller type to any larger type [or if you do any arithmetic in general, <code>char</code> is converted to <code>int</code>], so <code>'q'</code> becomes the integer value of <code>'q'</code>. If you want to avoid that, you should use <code>6u</code>, or an explicit cast, such as <code>static_cast&lt;unsigned&gt;('q') &lt;&lt; 6</code> - that way, you are ensured that the operand is converted to unsigned, rather than signed. </p>\n<p>The operations are undefined because different hardware behaves differently, and there are architectures with \"strange\" numbering systems, which means that the standards committee has to choose between \"ruling out/making operations extremely inefficient\" or \"defining the standard in a way that isn't very clear\". In a few architectures, overflowing integers may also be a trap, and if you shift such that you change the sign on the number, that typically counts as an overflow - and since trapping typically means \"your code no longer runs\", that would not be what your average programmer expects -&gt; falls under the umbrella of \"undefined behaviour\". Most processors don't, and nothing really bad will happen if you do that.</p>\n<p>Old answer:\nSo the solution to avoid this is to always cast your signed values (including <code>char</code>) to unsigned before shifting them (or accept that your code may not work on another compiler, the same compiler with different options, or the next release of the same compiler). </p>\n<p>It is also worth noting that the resulting value is \"nearly always what you expect\" (in that the compiler/processor will just perform the left or right shift on the value, on right shifts using the sign bit to shift down), it's just undefined or implementation defined because SOME machine architectures may not have hardware to \"do this right\", and C compilers still need to work on those systems. </p>\n<p>The sign bit is the highest bit in a twos-complement, and you are not changing that by shifting that number: </p>\n<pre><code>       11111111 11111111 11111111 10001110 &lt;&lt; 6 =\n111111 11111111 11111111 11100011 10000000\n^^^^^^--- goes away.\nresult=11111111 11111111 11100011 10000000 \n</code></pre>\n<p>Or as a hex number: 0xffffe380. </p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2015-01-25T22:31:37.923", "Score": "1", "CreationDate": "2015-01-25T22:00:03.720", "ParentId": "28141871", "CommentCount": "6", "OwnerUserId": "1919155", "LastEditDate": "2015-01-25T22:31:37.923"}, "28142480": {"Id": "28142480", "PostTypeId": "2", "Body": "<p>It might be simplest to read the exact text of the Standard, instead of a summary like in Primer Plus. (The summary has to leave out detail by virtue of being a summary!)</p>\n<p>The relevant portions are:</p>\n<blockquote>\n<p id=\"so_28141871_28142480_0\"><strong>[expr.shift]</strong></p>\n<ol>\n<li><p id=\"so_28141871_28142480_1\">The shift operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> group left-to-right.\n  The operands shall be of integral or unscoped enumeration type and <strong>integral promotions</strong> are performed. The type of the result is that of the promoted left operand. The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted left operand.</p></li>\n<li><p id=\"so_28141871_28142480_2\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. If <code>E1</code> has an unsigned type, the value of the result is <code>E1</code> \u00d7 <code>2</code><sup>E2</sup> , reduced modulo one more than the maximum value representable in the result type. Otherwise, if <code>E1</code> has a signed type and non-negative value, and  <code>E1</code> \u00d7 <code>2</code><sup>E2</sup> is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the resulting value; otherwise, the behavior is undefined.</p></li>\n</ol>\n<p id=\"so_28141871_28142480_3\"><strong>[expr.unary.op]/10</strong></p>\n<p id=\"so_28141871_28142480_4\">The operand of <code>\u02dc</code> shall have integral or unscoped enumeration type; the result is the one\u2019s complement of its operand. <strong>Integral promotions</strong> are performed. The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>Note that neither of these performs the <em>usual arithmetic conversions</em> (which is the conversion to a common type that is done by most of the binary operators).</p>\n<p>The integral promotions:</p>\n<blockquote>\n<p id=\"so_28141871_28142480_5\"><strong>[conv.prom]/1</strong></p>\n<p id=\"so_28141871_28142480_6\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion rank is less than the rank of int can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned int</code>.</p>\n</blockquote>\n<p>(There are other entries for the types in the \"other than\" list, I have omitted them here but you can look it up in a Standard draft).</p>\n<hr>\n<p>The thing to remmeber about the integer promotions is that they are <em>value-preserving</em> , if you have a <code>char</code> of value <code>-30</code>, then after promotion it will be an <code>int</code> of value <code>-30</code>.  You don't need to think about things like \"sign extension\".</p>\n<p>Your initial analysis of <code>~'q'</code> is correct, and the result has type <code>int</code> (because <code>int</code> can represent all the values of <code>char</code> on normal systems). </p>\n<p>It turns out that any <code>int</code> whose most significant bit is set represents a negative value (there are rules about this in another part of the standard that I haven't quoted here), so <code>~'q'</code> is a negative <code>int</code>.</p>\n<p>Looking at [expr.shift]/2 we see that this means left-shifting it causes undefined behaviour (it's not covered by any of the earlier cases in that paragraph).</p>\n</hr>", "LastActivityDate": "2015-01-25T22:46:17.583", "CommentCount": "1", "CreationDate": "2015-01-25T22:46:17.583", "ParentId": "28141871", "Score": "3", "OwnerUserId": "1505939"}, "28141871": {"ViewCount": "1231", "Body": "<p>I'm reading C++ Primer and I'm slightly confused by a few comments which talk about how Bitwise operators deal with signed types. I'll quote:</p>\n<p><strong>Quote #1</strong> </p>\n<blockquote>\n<p id=\"so_28141871_28141871_0\">(When talking about Bitwise operators) \"If the operand is signed and\n  its value is negative, then the way that the \u201csign bit\u201d is handled in\n  a number of the bitwise operations is machine dependent. Moreover,\n  doing a left shift that changes the value of the sign bit is\n  undefined\"</p>\n</blockquote>\n<p><strong>Quote #2</strong> </p>\n<blockquote>\n<p id=\"so_28141871_28141871_1\">(When talking about the rightshift operator) \"If that operand is\n  unsigned, then the operator inserts 0-valued bits on the left; if it\n  is a signed type, the result is implementation defined\u2014either copies\n  of the sign bit or 0-valued bits are inserted on the left.\"</p>\n</blockquote>\n<p>The bitwise operators promote small integers (such as char) to signed ints. Isn't there an issue with this promotion to <strong>signed</strong> ints when bitwise operators often gives undefined or implementation-defined behaviour on signed operator types? Why wouldn't the standard promote char to unsigned int?</p>\n<hr>\n<p><strong>Edit:</strong> Here is the question I took out, but I've placed it back for context with some answers below.</p>\n<p>An exercise later asks </p>\n<p>\"What is the value of <code>~'q' &lt;&lt; 6</code> on a machine with 32-bit <code>int</code>s and 8 bit <code>char</code>s, that uses Latin-1 character set in which 'q' has the bit pattern <code>01110001</code>?\"</p>\n<p>Well, 'q' is a character literal and would be promoted to int, giving</p>\n<p><code>~'q' == ~0000000 00000000 00000000 01110001 == 11111111 11111111 11111111 10001110</code></p>\n<p>The next step is to apply a left shift operator to the bits above, but as <strong>quote #1</strong> mentions </p>\n<blockquote>\n<p id=\"so_28141871_28141871_2\">\"doing a left shift that changes the value of the sign bit is\n  undefined\"</p>\n</blockquote>\n<p>well I don't exactly know which bit is the sign bit, but surely the answer is undefined?</p>\n</hr>", "AcceptedAnswerId": "28142065", "Title": "Bitwise operators and signed types", "CreationDate": "2015-01-25T21:40:59.277", "Id": "28141871", "CommentCount": "4", "LastEditDate": "2015-01-25T23:07:50.433", "PostTypeId": "1", "LastEditorUserId": "2034041", "LastActivityDate": "2015-01-25T23:07:50.433", "Score": "3", "OwnerUserId": "4338785", "Tags": "<c++><bit-manipulation><language-lawyer><signed>", "AnswerCount": "3"}});