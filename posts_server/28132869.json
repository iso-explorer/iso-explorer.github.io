post_cb({"28132910": {"ParentId": "28132869", "CommentCount": "5", "Body": "<p>The point isn't to do this:</p>\n<pre><code>Box*   b = s-&gt;duplicate();\n</code></pre>\n<p>That obviously can't work since <code>Shape::duplicate()</code> returns a <code>Shape*</code>. The point, rather, is to accept a <code>Box*</code> if you're calling <code>duplicate()</code> on a <code>Box</code> directly:</p>\n<pre><code>Box* old = new Box;\nBox* b = old-&gt;duplicate(); // OK! We know it's a Box\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "28132910", "Score": "5", "CreationDate": "2015-01-25T03:28:31.220", "LastActivityDate": "2015-01-25T03:28:31.220"}, "28132869": {"CommentCount": "0", "ViewCount": "440", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-01-25T03:20:50.387", "LastActivityDate": "2017-05-05T19:58:36.703", "Title": "Covariant return type and type conversion", "AcceptedAnswerId": "30144825", "LastEditDate": "2015-01-25T03:27:04.670", "Id": "28132869", "Score": "5", "Body": "<p><code>s-&gt;duplicate()</code> returns an object of type <code>Box*</code>, but I'm getting an error initializing it with <code>Box*</code>. It looks like it's being converted back to <code>Shape*</code>. What is the point of having covariant return types if it's converted back to the base class pointer?:</p>\n<pre><code>struct Shape\n{\n    virtual Shape* duplicate()\n    {\n        return new Shape;\n    }\n};\n\nstruct Box : Shape\n{\n    virtual Box* duplicate()\n    {\n        return new Box;\n    }\n};\n\nint main()\n{\n    Shape* s = new Box;\n    Box*   b = s-&gt;duplicate();\n}\n</code></pre>\n<p>Error:</p>\n<pre><code>main.cpp:22:12: error: cannot initialize a variable of type 'Box *' with an rvalue of type 'Shape *'\n    Box*   b = s-&gt;duplicate();\n           ^   ~~~~~~~~~~~~~~\n1 error generated.\n</code></pre>\n", "Tags": "<c++><covariance><dynamic-dispatch>", "OwnerUserId": "1594090", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28132869_30144825_1": {"section_id": 7009, "quality": 0.8529411764705882, "length": 29}, "so_28132869_30144825_0": {"section_id": 7008, "quality": 0.75, "length": 12}}, "n3337": {"so_28132869_30144825_1": {"section_id": 6755, "quality": 0.9117647058823529, "length": 31}, "so_28132869_30144825_0": {"section_id": 6754, "quality": 0.75, "length": 12}}, "n4659": {"so_28132869_30144825_1": {"section_id": 8506, "quality": 0.8529411764705882, "length": 29}, "so_28132869_30144825_0": {"section_id": 8505, "quality": 0.75, "length": 12}}}, "30144825": {"ParentId": "28132869", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Although <code>Box::duplicate</code> <em>is</em> being invoked at runtime (via virtual dispatch), and although <code>Box::duplicate</code> <em>does</em> override <code>Shape::duplicate</code> (covariantly), and although <code>Box::duplicate</code> <em>does</em> return a <code>Box*</code>, you'll still get a <code>Shape*</code> pointer because you are calling <code>duplicate()</code> through a <code>Shape*</code> pointer, and <code>Shape*</code> is the return type of <code>Shape::duplicate()</code>, and the compiler only sees you calling <code>Shape::duplicate</code>, not <code>Box::duplicate</code>.</p>\n<p>C++ is not able to dynamically select types, so this is the best it can do. Your <code>Box*</code> is being automatically converted to a <code>Shape*</code> on the way out of <code>Box::duplicate</code>. As Barry said, \"it still has to compile at compile time, and at compile time all we know is that it returns a <code>Shape*</code>\".</p>\n<p>Then, to make it into a <code>Box*</code> again, you need to explicitly cast it (using <code>static_cast</code> or <code>dynamic_cast</code>) because no implicit down-conversion exists.</p>\n<blockquote>\n<p id=\"so_28132869_30144825_0\"><code>[C++11: 10.3/7]:</code> <strong>The return type of an overriding function shall be</strong> either identical to the return type of the overridden function or <strong>covariant with the classes of the functions</strong>. <em>[..]</em></p>\n<p id=\"so_28132869_30144825_1\"><code>[C++11: 10.3/8]:</code> If the return type of <code>D::f</code> differs from the return type of <code>B::f</code>, the class type in the return type of <code>D::f</code> shall\n  be complete at the point of declaration of <code>D::f</code> or shall be the class type <code>D</code>. <strong>When the overriding function is called as the final overrider of the overridden function, its result is converted to the type returned by the (statically chosen) overridden function</strong> (5.2.2). <em>[..]</em></p>\n</blockquote>\n<p>In the standard text, a pertinent example follows.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "65863", "LastEditDate": "2017-05-05T19:58:36.703", "Id": "30144825", "Score": "7", "CreationDate": "2015-05-09T20:44:31.843", "LastActivityDate": "2017-05-05T19:58:36.703"}});