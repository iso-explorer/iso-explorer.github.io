post_cb({"17245147": {"PostTypeId": "2", "ParentId": "17245050", "Body": "<p>According to the <a href=\"http://clang.llvm.org/cxx_status.html\">status page</a> for clang, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html\">N3652 Relaxing requirements on constexpr functions</a> is partially implemented. This paper made a big change. The following passage has been deleted.</p>\n<blockquote>\n<p id=\"so_17245050_17245147_0\">A constexpr specifier for a non static member function that is not a\n  constructor declares that member function to be const (9.3.1).</p>\n</blockquote>\n<p>This change means your function cannot be called on <code>const</code> objects anymore. Also, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3669.pdf\">Fixing constexpr member functions without const</a> which is a proposal to fix those areas of the library.</p>\n", "LastEditorUserId": "906773", "Score": "13", "LastEditDate": "2013-06-21T22:42:05.717", "CommentCount": "1", "Id": "17245147", "OwnerUserId": "906773", "CreationDate": "2013-06-21T22:18:27.657", "LastActivityDate": "2013-06-21T22:42:05.717"}, "17245050": {"LastEditDate": "2017-05-23T11:58:26.423", "OwnerUserId": "849856", "Score": "6", "LastEditorUserId": "-1", "CommentCount": "1", "Title": "clang 3.3 and GCC 4.7 const v's constexpr", "AnswerCount": "1", "LastActivityDate": "2013-08-05T06:30:32.280", "PostTypeId": "1", "Tags": "<c++><c++11><const><constexpr><c++14>", "Body": "<p>I just tried compiling a fairly large body of code using clang 3.3 with GCC 4.7.3 standard library header files on Ubuntu 13.04. This all went well except one issue. This code already compiles with the standard Ubuntu clang 3.2 package on this machine so I'm assuming this is some change in the clang 3.3 compiler. The problem related to const and constexpr using the complex header. In particular the complex type has the following block of code</p>\n<pre><code>#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR 387. std::complex over-encapsulated.\n      constexpr double\n      real() { return __real__ _M_value; }\n\n      constexpr double\n      imag() { return __imag__ _M_value; }\n#else\n      double&amp;\n      real() { return __real__ _M_value; }\n\n      const double&amp;\n      real() const { return __real__ _M_value; }\n\n      double&amp;\n      imag() { return __imag__ _M_value; }\n\n      const double&amp;\n      imag() const { return __imag__ _M_value; }\n#endif\n</code></pre>\n<p>In my compile I enter the first block of code and so the compiler sees</p>\n<pre><code>constexpr double real() { return __real__ _M_value; }\n</code></pre>\n<p>This results in clang producing an error that the real member function is not const with the following</p>\n<pre><code>/usr/lib/gcc/x86_64-linux-gnu/4.7/../../../../include/c++/4.7/complex:1212:7: \nnote: candidate function not viable: 'this' argument has type 'const complex&lt;double&gt;',\n      but method is not marked const\n\n      real() { return __real__ _M_value; }\n</code></pre>\n<p>I have read the following post <a href=\"https://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const/14117121#14117121\">Difference between `constexpr` and `const`</a> and a few other similar documents but am still not really clear if this is a GCC header problem or a clang compiler problem. My feeling is that a member function marked constexpr should be regarded by the compiler as const in which case clang is wrong.</p>\n", "FavoriteCount": "2", "Id": "17245050", "ViewCount": "1057", "CreationDate": "2013-06-21T22:06:40.523"}, "bq_ids": {"n3337": {"so_17245050_17245147_0": {"quality": 0.75, "length": 9, "section_id": 5219}}}});