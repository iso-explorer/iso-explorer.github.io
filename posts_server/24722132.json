post_cb({"24722132": {"ViewCount": "206", "Body": "<p>As a C++ newbie I really have problems understanding the new Move-Constructor of C++11 and I hope someone can explain a specific situation I stumbled upon. Let's take this example code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Model {\npublic:\n    int data;\n    Model(int data) : data(data) { cout &lt;&lt; \"Constructor\" &lt;&lt; endl; }\n    Model(Model&amp;&amp; model) { cout &lt;&lt; \"Move constructor\" &lt;&lt; endl; }\n    ~Model() { cout &lt;&lt; \"Destructor\" &lt;&lt; endl; }\n\nprivate:\n    Model(const Model&amp; model);\n    const Model&amp; operator=(const Model&amp;);\n\n};\n\nModel createModel(int data) {\n    return Model(data);\n}\n\nint main(void) {\n    Model model = createModel(1);\n    cout &lt;&lt; model.data &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>So I have created a <code>createModel</code> function which should return a model as a temporary rvalue and I want to assign it to an lvalue. I don't want the compiler to create copies of the <code>Model</code> object so I define the copy constructor as private and I do the same with the assignment operator to make sure no data is copied. After doing this the code correctly no longer compiles so I added the Move constructor and now it compiles again. But when I run the program I get this output:</p>\n<pre><code>Constructor\n1\nDestructor\n</code></pre>\n<p>So the Move Constructor was never called. I don't understand why I have to specify the move constructor to be able to compile the program when it is not used at all during runtime. </p>\n<p>Is it because the compiler (GCC 4.8.2) optimizes the Move Constructor away? Or is there some other magic performed here?</p>\n<p>So can someone please explain what exactly happens in the code above? The code does what I want but I really don't understand why.</p>\n", "AcceptedAnswerId": "24722282", "Title": "Need some help understanding C++11 Move Constructors", "CreationDate": "2014-07-13T11:21:39.390", "LastActivityDate": "2014-07-13T11:54:29.080", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "Tags": "<c++><c++11><move-semantics>", "Id": "24722132", "Score": "8", "OwnerUserId": "274473", "ClosedDate": "2014-07-13T14:29:09.480", "AnswerCount": "3"}, "24722226": {"Id": "24722226", "PostTypeId": "2", "Body": "<p>You are a \"victim\" of <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow\">Return Value Optimization</a> here.</p>\n<p>Note this: \"In C++, it is particularly notable for being allowed to change the observable behaviour of the resulting program\".</p>\n<p><strong>EDIT:</strong> Hence, the compiler is allowed to apply the optimization, even though the side effects of the move-ctor (cout) have been changed.</p>\n", "LastEditorUserId": "1641845", "LastActivityDate": "2014-07-13T11:42:05.313", "Score": "1", "CreationDate": "2014-07-13T11:35:22.323", "ParentId": "24722132", "CommentCount": "0", "OwnerUserId": "1641845", "LastEditDate": "2014-07-13T11:42:05.313"}, "24722187": {"Id": "24722187", "PostTypeId": "2", "Body": "<p>i think this is what you call copy elision (i.e. prevent the copy of an object) and directly use it. See: <a href=\"https://stackoverflow.com/questions/11914691/copy-elision-move-constructor-not-called-when-using-ternary-expression-in-retur\">copy elision: move constructor not called when using ternary expression in return statement?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-13T11:31:16.693", "Score": "1", "CreationDate": "2014-07-13T11:31:16.693", "ParentId": "24722132", "CommentCount": "1", "OwnerUserId": "3125562", "LastEditDate": "2017-05-23T11:53:46.553"}, "24722282": {"Id": "24722282", "PostTypeId": "2", "Body": "<p>There are two moves that could happen in your program:</p>\n<ol>\n<li>From the function to the return object.</li>\n<li>From the return object to <code>model</code>.</li>\n</ol>\n<p>Both of these moves can be <em>elided</em> by the compiler for the same reason:</p>\n<blockquote>\n<p id=\"so_24722132_24722282_0\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</p>\n</blockquote>\n<p>There are other situations in which copy/move elision occurs (see \u00a712.8/31 in C++11). Note that copy/move elision is entirely optional - the compiler doesn't have to do it.</p>\n<p>Note that <strong>the compiler is allowed to optimize absolutely anything away as long as it doesn't change the behaviour of your program</strong> (under the <em>as-if rule</em>). The reason that <strong>copy/move elision</strong> is explicitly mentioned in the standard is because <strong>it might change the behaviour of your program</strong> if your copy/move constructors have side effects. The compiler is allowed to perform this optimization even if it changes the behaviour of your program. This is why <strong>your copy/move constructors should never have side effects</strong>, because then your program will have multiple valid execution paths.</p>\n<p>You can pass the <code>-fno-elide-constructors</code> option to <code>gcc</code> to ensure that this optimization is never performed.</p>\n", "LastEditorUserId": "2666289", "LastActivityDate": "2014-07-13T11:54:29.080", "Score": "7", "CreationDate": "2014-07-13T11:41:44.617", "ParentId": "24722132", "CommentCount": "1", "OwnerUserId": "150634", "LastEditDate": "2014-07-13T11:54:29.080"}, "bq_ids": {"n4140": {"so_24722132_24722282_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}}, "n3337": {"so_24722132_24722282_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}}, "n4659": {"so_24722132_24722282_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}}}});