post_cb({"bq_ids": {"n4140": {"so_12185094_12185546_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 389}}, "n3337": {"so_12185094_12185546_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 380}}, "n4659": {"so_12185094_12185546_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 406}}}, "12185513": {"Id": "12185513", "PostTypeId": "2", "Body": "<p>You could write a trait that reports whether or not a type is a specialization of <code>Derived2&lt;&gt;</code>:</p>\n<pre><code>template&lt;typename T&gt;\nstruct is_derived2 : std::false_type { };\n\ntemplate&lt;class P1, class P2, class P&gt;\nstruct is_derived2&lt;Derived2&lt;P1, P2, P&gt;&gt; : std::true_type { };\n</code></pre>\n<p>And a function stub to extract the <code>P</code> in <code>Base&lt;P&gt;</code>:</p>\n<pre><code>template&lt;typename Parameter&gt;\nParameter base_parameter(Base&lt;Parameter&gt; const&amp;);\n</code></pre>\n<p>Then change your implicit constructor to:</p>\n<pre><code>template&lt;\n    class T,\n    class = typename std::enable_if&lt;\n        !is_derived2&lt;T&gt;::value\n        &amp;&amp; std::is_base_of&lt;\n            Base&lt;decltype(base_parameter(std::declval&lt;T&gt;()))&gt;,\n            T\n        &gt;::value\n    &gt;::type\n&gt;\nDerived2(const T&amp; x);\n</code></pre>\n<p>Online demo: <a href=\"http://liveworkspace.org/code/c43d656d60f85b8b9d55d8e3c4812e2b\" rel=\"nofollow\">http://liveworkspace.org/code/c43d656d60f85b8b9d55d8e3c4812e2b</a></p>\n<hr>\n<p>Update: Here is an online demo incorporating these changes into your 'Edit 2' link:<br>\n<a href=\"http://liveworkspace.org/code/3decc7e0658cfd182e2f56f7b6cafe61\" rel=\"nofollow\">http://liveworkspace.org/code/3decc7e0658cfd182e2f56f7b6cafe61</a></br></p>\n</hr>", "LastEditorUserId": "636019", "LastActivityDate": "2012-08-29T21:35:33.163", "Score": "2", "CreationDate": "2012-08-29T19:52:48.083", "ParentId": "12185094", "CommentCount": "0", "OwnerUserId": "636019", "LastEditDate": "2012-08-29T21:35:33.163"}, "12185094": {"ViewCount": "496", "Body": "<p>The following code sum up my problem :</p>\n<pre><code>template&lt;class Parameter&gt;\nclass Base {};\n\ntemplate&lt;class Parameter1, class Parameter2, class Parameter&gt;\nclass Derived1 : public Base&lt;Parameter&gt;\n{ };\n\ntemplate&lt;class Parameter1, class Parameter2, class Parameter&gt;\nclass Derived2 : public Base&lt;Parameter&gt;\n{\npublic :\n    // Copy constructor\n    Derived2(const Derived2&amp; x);\n\n    // An EXPLICIT constructor that does a special conversion for a Derived2\n    // with other template parameters\n    template&lt;class OtherParameter1, class OtherParameter2, class OtherParameter&gt;\n    explicit Derived2(\n        const Derived2&lt;OtherParameter1, OtherParameter2, OtherParameter&gt;&amp; x\n    );\n\n    // Now the problem : I want an IMPLICIT constructor that will work for every\n    // type derived from Base EXCEPT\n    // Derived2&lt;OtherParameter1, OtherParameter2, OtherParameter&gt; \n    template&lt;class Type, class = typename std::enable_if&lt;/* SOMETHING */&gt;::type&gt;\n    Derived2(const Type&amp; x);\n};\n</code></pre>\n<p>How to restrict an implicit constructor to all classes derived from the parent class excepted the current class whatever its template parameters, considering that I already have an explicit constructor as in the example code ?</p>\n<p>EDIT :\nFor the implicit constructor from Base, I can obviously write :</p>\n<pre><code>template&lt;class OtherParameter&gt; Derived2(const Base&lt;OtherParameter&gt;&amp; x);\n</code></pre>\n<p>But in that case, do I have the guaranty that the compiler will not use this constructor as an implicit constructor for <code>Derived2&lt;OtherParameter1, OtherParameter2, OtherParameter&gt;</code> ?</p>\n<p>EDIT2:\nHere I have a test : (LWS here : <a href=\"http://liveworkspace.org/code/cd423fb44fb4c97bc3b843732d837abc\" rel=\"nofollow\">http://liveworkspace.org/code/cd423fb44fb4c97bc3b843732d837abc</a>)</p>\n<pre><code>#include &lt;iostream&gt;\ntemplate&lt;typename Type&gt; class Base {};\ntemplate&lt;typename Type&gt; class Other : public Base&lt;Type&gt; {};\ntemplate&lt;typename Type&gt; class Derived : public Base&lt;Type&gt;\n{\n    public:\n        Derived() {std::cout&lt;&lt;\"empty\"&lt;&lt;std::endl;}\n        Derived(const Derived&lt;Type&gt;&amp; x) {std::cout&lt;&lt;\"copy\"&lt;&lt;std::endl;}\n        template&lt;typename OtherType&gt; explicit Derived(const Derived&lt;OtherType&gt;&amp; x) {std::cout&lt;&lt;\"explicit\"&lt;&lt;std::endl;}\n        template&lt;typename OtherType&gt; Derived(const Base&lt;OtherType&gt;&amp; x) {std::cout&lt;&lt;\"implicit\"&lt;&lt;std::endl;}\n};\nint main()\n{\n    Other&lt;int&gt; other0;\n    Other&lt;double&gt; other1;\n    std::cout&lt;&lt;\"1 = \";\n    Derived&lt;int&gt; dint1;                     // &lt;- empty\n    std::cout&lt;&lt;\"2 = \";\n    Derived&lt;int&gt; dint2;                     // &lt;- empty\n    std::cout&lt;&lt;\"3 = \";\n    Derived&lt;double&gt; ddouble;                // &lt;- empty\n    std::cout&lt;&lt;\"4 = \";\n    Derived&lt;double&gt; ddouble1(ddouble);      // &lt;- copy\n    std::cout&lt;&lt;\"5 = \";\n    Derived&lt;double&gt; ddouble2(dint1);        // &lt;- explicit\n    std::cout&lt;&lt;\"6 = \";\n    ddouble = other0;                       // &lt;- implicit\n    std::cout&lt;&lt;\"7 = \";\n    ddouble = other1;                       // &lt;- implicit\n    std::cout&lt;&lt;\"8 = \";\n    ddouble = ddouble2;                     // &lt;- nothing (normal : default assignment)\n    std::cout&lt;&lt;\"\\n9 = \";\n    ddouble = Derived&lt;double&gt;(dint1);       // &lt;- explicit\n    std::cout&lt;&lt;\"10 = \";\n    ddouble = dint2;                        // &lt;- implicit : WHY ?!?!\n    return 0;\n}\n</code></pre>\n<p>The last line worry me. Is it ok with the C++ standard ? Is it a bug of g++ ?</p>\n", "AcceptedAnswerId": "12185546", "Title": "Implicit constructor available for all types derived from Base excepted the current type?", "CreationDate": "2012-08-29T19:23:45.590", "Id": "12185094", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-08-29T20:25:07.900", "LastEditorUserId": "882932", "LastActivityDate": "2012-08-29T23:23:40.810", "Score": "4", "OwnerUserId": "882932", "Tags": "<c++><c++11><implicit-conversion><enable-if><explicit-constructor>", "AnswerCount": "3"}, "12185546": {"Id": "12185546", "PostTypeId": "2", "Body": "<p>Since each of the constructors you are referencing are templated class methods, the rules of template instantiation and function overload resolution are invoked.</p>\n<p>If you look in section 14.8.3 of the C++11 standard, there are actually some examples in paragraphs 1-3 that somewhat demonstrate your question.  Basically put, the C++ compiler will look for the best-match or \"least generalized\" template function instantiation among a series of overloaded template functions (with conversions of types added if necessary).  In your case, because you have explicitly created a constructor that takes an alternate instantiation of a <code>Derived2</code> object, that constructor will be a preferred overload for any <code>Derived2&lt;...&gt;</code> type compared to one that takes either a generic type <code>T</code>, or even a <code>Base&lt;OtherParameter&gt;</code> argument.</p>\n<p><strong>UPDATE</strong>: Apparently, according to 12.3.1/2 in the C++11 standard, </p>\n<blockquote>\n<p id=\"so_12185094_12185546_0\">An explicit constructor constructs objects just like non-explicit constructors, but does so only where the\n  direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.</p>\n</blockquote>\n<p>The implications are that if you do not use the direct-initialization syntax for constructing your objects or opt for a cast, then you cannot use any constructors that are marked as <code>explicit</code>.  This explains the puzzling results you're seeing between test #9 and #10.</p>\n", "LastEditorUserId": "649233", "LastActivityDate": "2012-08-29T23:23:40.810", "Score": "6", "CreationDate": "2012-08-29T19:55:23.693", "ParentId": "12185094", "CommentCount": "5", "OwnerUserId": "649233", "LastEditDate": "2012-08-29T23:23:40.810"}, "12186806": {"Id": "12186806", "PostTypeId": "2", "Body": "<p>Ok, maybe I've found a workaround that only imply the addition of a \"fake\" constructor :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\ntemplate&lt;typename Type&gt; class Base {};\ntemplate&lt;typename Type&gt; class Other : public Base&lt;Type&gt; {};\ntemplate&lt;typename Type&gt; class Derived : public Base&lt;Type&gt;\n{\n    public:\n        Derived() {std::cout&lt;&lt;\"empty\"&lt;&lt;std::endl;}\n        Derived(const Derived&lt;Type&gt;&amp; x) {std::cout&lt;&lt;\"copy\"&lt;&lt;std::endl;}\n        template&lt;typename OtherType&gt; explicit Derived(const Derived&lt;OtherType&gt;&amp; x) {std::cout&lt;&lt;\"explicit\"&lt;&lt;std::endl;}\n        template&lt;typename Something&gt; Derived(const Something&amp; x) {std::cout&lt;&lt;\"implicit\"&lt;&lt;std::endl;}\n\n    // Workaround\n    public:\n        template&lt;template&lt;typename&gt; class Something, typename OtherType,\n        class = typename std::enable_if&lt; std::is_same&lt; Something&lt;OtherType&gt;, Derived&lt;OtherType&gt; &gt;::value&gt;::type &gt;\n        Derived(const Something&lt;OtherType&gt;&amp; x)\n        {std::cout&lt;&lt;\"workaround (for example always false static assert here)\"&lt;&lt;std::endl;}\n};\ntemplate&lt;unsigned int Size&gt; class Test {};\n\nint main()\n{\n    Other&lt;int&gt; other0;\n    Other&lt;double&gt; other1;\n    Test&lt;3&gt; test;\n    std::cout&lt;&lt;\"1 = \";\n    Derived&lt;int&gt; dint1;                     // &lt;- empty\n    std::cout&lt;&lt;\"2 = \";\n    Derived&lt;int&gt; dint2;                     // &lt;- empty\n    std::cout&lt;&lt;\"3 = \";\n    Derived&lt;double&gt; ddouble;                // &lt;- empty\n    std::cout&lt;&lt;\"4 = \";\n    Derived&lt;double&gt; ddouble1(ddouble);      // &lt;- copy\n    std::cout&lt;&lt;\"5 = \";\n    Derived&lt;double&gt; ddouble2(dint1);        // &lt;- explicit\n    std::cout&lt;&lt;\"6 = \";\n    ddouble = other0;                       // &lt;- implicit\n    std::cout&lt;&lt;\"7 = \";\n    ddouble = other1;                       // &lt;- implicit\n    std::cout&lt;&lt;\"8 = \";\n    ddouble = ddouble2;                     // &lt;- nothing (normal : default assignment)\n    std::cout&lt;&lt;\"\\n9 = \";\n    ddouble = Derived&lt;double&gt;(dint1);       // &lt;- explicit\n    std::cout&lt;&lt;\"10 = \";\n    ddouble = dint2;                        // &lt;- workaround\n    std::cout&lt;&lt;\"11 = \";\n    ddouble = test;                         // &lt;- implicit\n    return 0;\n}\n</code></pre>\n<p>@Everybody : Do you think that it's a good solution to that problem ?</p>\n<p>LWS : <a href=\"http://liveworkspace.org/code/f581356a7472c902b10ca486d648fafc\" rel=\"nofollow\">http://liveworkspace.org/code/f581356a7472c902b10ca486d648fafc</a></p>\n", "LastEditorUserId": "882932", "LastActivityDate": "2012-08-29T21:36:03.930", "Score": "0", "CreationDate": "2012-08-29T21:30:25.097", "ParentId": "12185094", "CommentCount": "4", "OwnerUserId": "882932", "LastEditDate": "2012-08-29T21:36:03.930"}});