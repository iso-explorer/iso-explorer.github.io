post_cb({"24268165": {"CommentCount": "2", "ViewCount": "80", "OwnerDisplayName": "user2953119", "CreationDate": "2014-06-17T15:48:48.883", "LastActivityDate": "2014-06-17T16:57:47.497", "PostTypeId": "1", "FavoriteCount": "0", "Title": "Context of using declaration and ambiguous declaration", "Id": "24268165", "Score": "1", "Body": "<p>There is a quote from the sec. 3.4.3.2/3:</p>\n<blockquote>\n<p id=\"so_24268165_24268165_0\">Given X::m (where X is a user-declared namespace), or given ::m (where\n  X is the global namespace), if S(X, m) is the empty set, the program\n  is ill-formed. <strong>Otherwise, if S(X, m) has exactly one member, or if\n  the context of the reference is a using-declaration (7.3.3), S(X, m)\n  is the required set of declarations of m.</strong></p>\n</blockquote>\n<p>Definition of S(X,m) is the following sec. 3.4.3.2/2:</p>\n<blockquote>\n<p id=\"so_24268165_24268165_1\">For a namespace X and name m, the namespace-qualified lookup set S(X,\n  m) is defined as follows: Let S (X, m) be the set of all declarations\n  of m in X and the inline namespace set of X (7.3.1). If S (X, m) is\n  not empty, S(X, m) is S (X, m); otherwise, S(X, m) is the union of\n  S(Ni , m) for all namespaces Ni nominated by using-directives in X and\n  its inline namespace set.</p>\n</blockquote>\n<p>Now consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\nnamespace N\n{\n    int cout = 6;\n}\nusing namespace N;\n\nint main() {\n    using ::cout;//error: reference to \u2018cout\u2019 is ambiguous\n    return 0;\n}\n</code></pre>\n<p>I don't understand thar error. The code above does not contradict to the rule:</p>\n<blockquote>\n<p id=\"so_24268165_24268165_2\">if S(X, m) has exactly one member, or if the context of the reference\n  is a using-declaration (7.3.3), S(X, m) is the required set of\n  declarations of m.</p>\n</blockquote>\n<p>Can you explain the sense of that rule?</p>\n", "Tags": "<c++><namespaces><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24268165_24268165_0": {"section_id": 7118, "quality": 0.9545454545454546, "length": 21}, "so_24268165_24268165_1": {"section_id": 7117, "quality": 0.8928571428571429, "length": 25}, "so_24268165_24268165_2": {"section_id": 7118, "quality": 0.9, "length": 9}}, "n3337": {"so_24268165_24268165_0": {"section_id": 6862, "quality": 0.9545454545454546, "length": 21}, "so_24268165_24268165_1": {"section_id": 6861, "quality": 0.8928571428571429, "length": 25}, "so_24268165_24268165_2": {"section_id": 6862, "quality": 0.9, "length": 9}}, "n4659": {"so_24268165_24268165_0": {"section_id": 8619, "quality": 0.9545454545454546, "length": 21}, "so_24268165_24268165_1": {"section_id": 8618, "quality": 0.8928571428571429, "length": 25}, "so_24268165_24268165_2": {"section_id": 8619, "quality": 0.9, "length": 9}}}, "24269304": {"ParentId": "24268165", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Dmitry, I suspect you are misinterpreting what \"if the context of the reference is a <em>using-declaration</em>\" means. \"In the context of a <em>using-declaration</em>\" does not mean \"when used in a <em>using-declaration</em>\". It instead means \"when the reference is the subject of a <em>using-declaration</em>\". Suppose your code is changed as follows:</p>\n<pre><code>int main() {\n    using N::cout;\n    std::cout &lt;&lt; \"value=\" &lt;&lt; cout &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Note the use of the unqualified <code>cout</code> in <code>std::cout &lt;&lt; \"value=\" &lt;&lt; cout &lt;&lt; '\\n'</code>. The context of that unqualified reference is the <em>using-declaration</em> <code>using N::cout</code>.</p>\n<p>Another way to look at what the standard means is that a <em>using-declaration</em> takes precedence over a <em>using-directive</em>.</p>\n", "OwnerUserId": "774499", "LastEditorUserId": "774499", "LastEditDate": "2014-06-17T16:57:47.497", "Id": "24269304", "Score": "1", "CreationDate": "2014-06-17T16:50:24.510", "LastActivityDate": "2014-06-17T16:57:47.497"}});