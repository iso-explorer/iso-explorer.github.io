post_cb({"27720222": {"CommentCount": "1", "ViewCount": "81", "CreationDate": "2014-12-31T11:04:20.270", "LastActivityDate": "2014-12-31T11:50:54.607", "Title": "Is a function call expression with a single non-type template parameter argument type-dependent?", "PostTypeId": "1", "Id": "27720222", "Score": "1", "Body": "<p>Both clang 3.6 and gcc 5.0 require <code>typename</code> in the following example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct B\n{\n    typedef int Type;\n};\n\nvoid f(int);\n\ntemplate&lt;int n&gt;\nstruct A\n{\n    typedef typename B&lt;decltype(f(n))&gt;::Type Type;\n};\n</code></pre>\n<p>This is covered by the following wording in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_27720222_27720222_0\">[temp.dep.type]/5</p>\n<p id=\"so_27720222_27720222_1\">A name is a <em>member of an unknown specialization</em> if it is</p>\n<ul>\n<li>A qualified-id in which the nested-name-specifier names a dependent type that is not the current\n  instantiation.</li>\n</ul>\n<p id=\"so_27720222_27720222_2\">[temp.dep.type]/8</p>\n<p id=\"so_27720222_27720222_3\">A type is dependent if it is</p>\n<ul>\n<li><p id=\"so_27720222_27720222_4\">a member of an unknown specialization,</p></li>\n<li><p id=\"so_27720222_27720222_5\">a simple-template-id in which either the template name is a template parameter or any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent</p></li>\n<li><p id=\"so_27720222_27720222_6\">denoted by <code>decltype(expression)</code>, where expression is type-dependent</p></li>\n</ul>\n</blockquote>\n<p>This suggests <code>B&lt;decltype(f(n))&gt;::Type</code> is type-dependent only if <code>B&lt;decltype(f(n))&gt;</code> is type-dependent. Also that <code>B&lt;decltype(f(n))&gt;</code> is dependent only if <code>f(n)</code> is type-dependent.</p>\n<blockquote>\n<p id=\"so_27720222_27720222_7\">[temp.dep.expr]/1</p>\n<p id=\"so_27720222_27720222_8\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n<p id=\"so_27720222_27720222_9\">[temp.dep.expr]/3</p>\n<p id=\"so_27720222_27720222_10\">An id-expression is type-dependent if it contains</p>\n<ul>\n<li><p id=\"so_27720222_27720222_11\">an identifier associated by name lookup with one or more declarations declared with a dependent type,</p></li>\n<li><p id=\"so_27720222_27720222_12\">a template-id that is dependent,</p></li>\n<li><p id=\"so_27720222_27720222_13\">a conversion-function-id that specifies a dependent type, or</p></li>\n<li><p id=\"so_27720222_27720222_14\">a nested-name-specifier or a qualified-id that names a member of an unknown specialization;</p></li>\n</ul>\n<p id=\"so_27720222_27720222_15\">or if it names a static data member of the current instantiation that has type \u201carray of unknown bound of\n  T\u201d for some T</p>\n</blockquote>\n<p>This suggests <code>f(n)</code> is type-dependent only if <code>n</code> is type-dependent, and that <code>n</code> is <em>not</em> type-dependent.</p>\n<p>Am I missing something, or is this a compiler bug?</p>\n", "Tags": "<c++><templates><language-lawyer><dependent-type><compiler-bug>", "OwnerUserId": "1690864", "AnswerCount": "1"}, "27720501": {"ParentId": "27720222", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your analysis is a little bit incomplete, but otherwise correct.</p>\n<blockquote>\n<p id=\"so_27720222_27720501_0\">When a <em>qualified-id</em> is intended to refer to a type that is not a\n  member of the current instantiation (14.6.2.1) and its\n  <em>nested-name-specifier</em> refers to a dependent type, it shall be prefixed by the keyword <code>typename</code>, forming a <em>typename-specifier</em>.</p>\n</blockquote>\n<p>Clearly <code>B&lt;\u2026&gt;::Type</code> cannot refer to a member of the current instantiation. So the question is whether <code>B&lt;decltype(f(n))&gt;</code> is a dependent type.</p>\n<blockquote>\n<p id=\"so_27720222_27720501_1\">A type is dependent if it is  </p>\n<ul>\n<li>[\u2026]  </li>\n<li>a member of an unknown specialization,  </li>\n<li>[\u2026]  </li>\n<li>a <em>simple-template-id</em> in which either the template name is a template parameter or any of the template arguments is a dependent\n  type or an expression that is type-dependent or value-dependent, or  </li>\n<li>denoted by <code>decltype(expression)</code>, where <em>expression</em> is type-dependent (14.6.2.2).</li>\n</ul>\n</blockquote>\n<p><code>f(n)</code> isn't type-dependent as no sub-expression is, hence <code>decltype(f(n))</code> isn't a dependent type.<br>\nAlso, <code>decltype(...)</code> cannot be value-dependent as it isn't a constant expression<sup>1</sup> and no other paragraph in [temp.dep.constexpr] applies. Clearly <code>decltype(f(n))</code> isn't type-dependent either.<br>\nAnd least but not last, <code>B&lt;decltype(f(n))&gt;::Type</code> would be a member of an unknown specialization only if the template argument was a dependent type<sup>2</sup>, which we concluded it isn't.</br></br></p>\n<p>So by my interpretation the compilers are incorrect and the <code>typename</code> keyword is not required.</p>\n<hr>\n<p><sup>1</sup> In fact, <code>decltype(\u2026)</code> is not an expression at all.</p>\n<p><sup>2</sup> [temp.dep.type]/5:</p>\n<blockquote>\n<p id=\"so_27720222_27720501_2\">A name is a member of an unknown specialization if it is</p>\n<ul>\n<li>A <em>qualified-id</em> <strong>in which the <em>nested-name-specifier</em> names a dependent type</strong> that is not the current instantiation.  </li>\n<li>A <em>qualified-id</em> in which the <em>nested-name-specifier</em> refers to the current instantiation, <strong>the current instantiation has at least one\n  dependent base class</strong>, and name lookup of the <em>qualified-id</em> does not\n  find any member of a class that is the current instantiation or a\n  non-dependent base class thereof.  </li>\n<li>An <em>id-expression</em> denoting the member in a class member access expression (5.2.5) in which either<br>\n<ul>\n<li>[\u2026]</li>\n</ul></br></li>\n</ul>\n</blockquote>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-12-31T11:50:54.607", "Id": "27720501", "Score": "2", "CreationDate": "2014-12-31T11:30:24.360", "LastActivityDate": "2014-12-31T11:50:54.607"}, "bq_ids": {"n4140": {"so_27720222_27720222_14": {"section_id": 202, "quality": 1.0, "length": 6}, "so_27720222_27720222_15": {"section_id": 202, "quality": 0.8181818181818182, "length": 9}, "so_27720222_27720222_8": {"section_id": 200, "quality": 1.0, "length": 7}, "so_27720222_27720501_0": {"section_id": 170, "quality": 0.8421052631578947, "length": 16}, "so_27720222_27720222_13": {"section_id": 202, "quality": 1.0, "length": 4}, "so_27720222_27720222_6": {"section_id": 198, "quality": 1.0, "length": 5}, "so_27720222_27720501_2": {"section_id": 194, "quality": 1.0, "length": 4}, "so_27720222_27720222_1": {"section_id": 194, "quality": 1.0, "length": 4}, "so_27720222_27720222_5": {"section_id": 198, "quality": 1.0, "length": 13}, "so_27720222_27720222_11": {"section_id": 202, "quality": 1.0, "length": 10}}, "n3337": {"so_27720222_27720222_14": {"section_id": 196, "quality": 1.0, "length": 6}, "so_27720222_27720222_15": {"section_id": 196, "quality": 1.0, "length": 11}, "so_27720222_27720222_8": {"section_id": 194, "quality": 1.0, "length": 7}, "so_27720222_27720501_0": {"section_id": 164, "quality": 0.8421052631578947, "length": 16}, "so_27720222_27720222_13": {"section_id": 196, "quality": 1.0, "length": 4}, "so_27720222_27720222_6": {"section_id": 192, "quality": 1.0, "length": 5}, "so_27720222_27720501_2": {"section_id": 188, "quality": 1.0, "length": 4}, "so_27720222_27720222_1": {"section_id": 188, "quality": 1.0, "length": 4}, "so_27720222_27720222_5": {"section_id": 192, "quality": 1.0, "length": 13}, "so_27720222_27720222_11": {"section_id": 196, "quality": 1.0, "length": 10}}, "n4659": {"so_27720222_27720222_14": {"section_id": 208, "quality": 1.0, "length": 6}, "so_27720222_27720222_15": {"section_id": 208, "quality": 0.8181818181818182, "length": 9}, "so_27720222_27720222_8": {"section_id": 206, "quality": 1.0, "length": 7}, "so_27720222_27720501_0": {"section_id": 175, "quality": 0.9473684210526315, "length": 18}, "so_27720222_27720222_13": {"section_id": 208, "quality": 1.0, "length": 4}, "so_27720222_27720222_6": {"section_id": 204, "quality": 1.0, "length": 5}, "so_27720222_27720501_2": {"section_id": 74, "quality": 1.0, "length": 4}, "so_27720222_27720222_1": {"section_id": 74, "quality": 1.0, "length": 4}, "so_27720222_27720222_5": {"section_id": 204, "quality": 1.0, "length": 13}, "so_27720222_27720222_11": {"section_id": 208, "quality": 1.0, "length": 10}}}});