post_cb({"bq_ids": {"n4140": {"so_27720222_27720222_6": {"length": 5, "quality": 1.0, "section_id": 198}, "so_27720222_27720222_14": {"length": 6, "quality": 1.0, "section_id": 202}, "so_27720222_27720222_15": {"length": 9, "quality": 0.8181818181818182, "section_id": 202}, "so_27720222_27720222_11": {"length": 10, "quality": 1.0, "section_id": 202}, "so_27720222_27720222_1": {"length": 4, "quality": 1.0, "section_id": 194}, "so_27720222_27720501_2": {"length": 4, "quality": 1.0, "section_id": 194}, "so_27720222_27720222_5": {"length": 13, "quality": 1.0, "section_id": 198}, "so_27720222_27720222_13": {"length": 4, "quality": 1.0, "section_id": 202}, "so_27720222_27720501_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 170}, "so_27720222_27720222_8": {"length": 7, "quality": 1.0, "section_id": 200}}, "n3337": {"so_27720222_27720222_14": {"length": 6, "quality": 1.0, "section_id": 196}, "so_27720222_27720222_15": {"length": 11, "quality": 1.0, "section_id": 196}, "so_27720222_27720501_2": {"length": 4, "quality": 1.0, "section_id": 188}, "so_27720222_27720222_6": {"length": 5, "quality": 1.0, "section_id": 192}, "so_27720222_27720222_1": {"length": 4, "quality": 1.0, "section_id": 188}, "so_27720222_27720222_13": {"length": 4, "quality": 1.0, "section_id": 196}, "so_27720222_27720222_5": {"length": 13, "quality": 1.0, "section_id": 192}, "so_27720222_27720501_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 164}, "so_27720222_27720222_8": {"length": 7, "quality": 1.0, "section_id": 194}, "so_27720222_27720222_11": {"length": 10, "quality": 1.0, "section_id": 196}}, "n4659": {"so_27720222_27720222_14": {"length": 6, "quality": 1.0, "section_id": 208}, "so_27720222_27720222_15": {"length": 9, "quality": 0.8181818181818182, "section_id": 208}, "so_27720222_27720501_2": {"length": 4, "quality": 1.0, "section_id": 74}, "so_27720222_27720222_6": {"length": 5, "quality": 1.0, "section_id": 204}, "so_27720222_27720222_1": {"length": 4, "quality": 1.0, "section_id": 74}, "so_27720222_27720222_13": {"length": 4, "quality": 1.0, "section_id": 208}, "so_27720222_27720222_5": {"length": 13, "quality": 1.0, "section_id": 204}, "so_27720222_27720501_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 175}, "so_27720222_27720222_8": {"length": 7, "quality": 1.0, "section_id": 206}, "so_27720222_27720222_11": {"length": 10, "quality": 1.0, "section_id": 208}}}, "27720501": {"Id": "27720501", "PostTypeId": "2", "Body": "<p>Your analysis is a little bit incomplete, but otherwise correct.</p>\n<blockquote>\n<p id=\"so_27720222_27720501_0\">When a <em>qualified-id</em> is intended to refer to a type that is not a\n  member of the current instantiation (14.6.2.1) and its\n  <em>nested-name-specifier</em> refers to a dependent type, it shall be prefixed by the keyword <code>typename</code>, forming a <em>typename-specifier</em>.</p>\n</blockquote>\n<p>Clearly <code>B&lt;\u2026&gt;::Type</code> cannot refer to a member of the current instantiation. So the question is whether <code>B&lt;decltype(f(n))&gt;</code> is a dependent type.</p>\n<blockquote>\n<p id=\"so_27720222_27720501_1\">A type is dependent if it is  </p>\n<ul>\n<li>[\u2026]  </li>\n<li>a member of an unknown specialization,  </li>\n<li>[\u2026]  </li>\n<li>a <em>simple-template-id</em> in which either the template name is a template parameter or any of the template arguments is a dependent\n  type or an expression that is type-dependent or value-dependent, or  </li>\n<li>denoted by <code>decltype(expression)</code>, where <em>expression</em> is type-dependent (14.6.2.2).</li>\n</ul>\n</blockquote>\n<p><code>f(n)</code> isn't type-dependent as no sub-expression is, hence <code>decltype(f(n))</code> isn't a dependent type.<br>\nAlso, <code>decltype(...)</code> cannot be value-dependent as it isn't a constant expression<sup>1</sup> and no other paragraph in [temp.dep.constexpr] applies. Clearly <code>decltype(f(n))</code> isn't type-dependent either.<br>\nAnd least but not last, <code>B&lt;decltype(f(n))&gt;::Type</code> would be a member of an unknown specialization only if the template argument was a dependent type<sup>2</sup>, which we concluded it isn't.</br></br></p>\n<p>So by my interpretation the compilers are incorrect and the <code>typename</code> keyword is not required.</p>\n<hr>\n<p><sup>1</sup> In fact, <code>decltype(\u2026)</code> is not an expression at all.</p>\n<p><sup>2</sup> [temp.dep.type]/5:</p>\n<blockquote>\n<p id=\"so_27720222_27720501_2\">A name is a member of an unknown specialization if it is</p>\n<ul>\n<li>A <em>qualified-id</em> <strong>in which the <em>nested-name-specifier</em> names a dependent type</strong> that is not the current instantiation.  </li>\n<li>A <em>qualified-id</em> in which the <em>nested-name-specifier</em> refers to the current instantiation, <strong>the current instantiation has at least one\n  dependent base class</strong>, and name lookup of the <em>qualified-id</em> does not\n  find any member of a class that is the current instantiation or a\n  non-dependent base class thereof.  </li>\n<li>An <em>id-expression</em> denoting the member in a class member access expression (5.2.5) in which either<br>\n<ul>\n<li>[\u2026]</li>\n</ul></br></li>\n</ul>\n</blockquote>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-31T11:50:54.607", "Score": "2", "CreationDate": "2014-12-31T11:30:24.360", "ParentId": "27720222", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-12-31T11:50:54.607"}, "27720222": {"ViewCount": "81", "Body": "<p>Both clang 3.6 and gcc 5.0 require <code>typename</code> in the following example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct B\n{\n    typedef int Type;\n};\n\nvoid f(int);\n\ntemplate&lt;int n&gt;\nstruct A\n{\n    typedef typename B&lt;decltype(f(n))&gt;::Type Type;\n};\n</code></pre>\n<p>This is covered by the following wording in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_27720222_27720222_0\">[temp.dep.type]/5</p>\n<p id=\"so_27720222_27720222_1\">A name is a <em>member of an unknown specialization</em> if it is</p>\n<ul>\n<li>A qualified-id in which the nested-name-specifier names a dependent type that is not the current\n  instantiation.</li>\n</ul>\n<p id=\"so_27720222_27720222_2\">[temp.dep.type]/8</p>\n<p id=\"so_27720222_27720222_3\">A type is dependent if it is</p>\n<ul>\n<li><p id=\"so_27720222_27720222_4\">a member of an unknown specialization,</p></li>\n<li><p id=\"so_27720222_27720222_5\">a simple-template-id in which either the template name is a template parameter or any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent</p></li>\n<li><p id=\"so_27720222_27720222_6\">denoted by <code>decltype(expression)</code>, where expression is type-dependent</p></li>\n</ul>\n</blockquote>\n<p>This suggests <code>B&lt;decltype(f(n))&gt;::Type</code> is type-dependent only if <code>B&lt;decltype(f(n))&gt;</code> is type-dependent. Also that <code>B&lt;decltype(f(n))&gt;</code> is dependent only if <code>f(n)</code> is type-dependent.</p>\n<blockquote>\n<p id=\"so_27720222_27720222_7\">[temp.dep.expr]/1</p>\n<p id=\"so_27720222_27720222_8\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n<p id=\"so_27720222_27720222_9\">[temp.dep.expr]/3</p>\n<p id=\"so_27720222_27720222_10\">An id-expression is type-dependent if it contains</p>\n<ul>\n<li><p id=\"so_27720222_27720222_11\">an identifier associated by name lookup with one or more declarations declared with a dependent type,</p></li>\n<li><p id=\"so_27720222_27720222_12\">a template-id that is dependent,</p></li>\n<li><p id=\"so_27720222_27720222_13\">a conversion-function-id that specifies a dependent type, or</p></li>\n<li><p id=\"so_27720222_27720222_14\">a nested-name-specifier or a qualified-id that names a member of an unknown specialization;</p></li>\n</ul>\n<p id=\"so_27720222_27720222_15\">or if it names a static data member of the current instantiation that has type \u201carray of unknown bound of\n  T\u201d for some T</p>\n</blockquote>\n<p>This suggests <code>f(n)</code> is type-dependent only if <code>n</code> is type-dependent, and that <code>n</code> is <em>not</em> type-dependent.</p>\n<p>Am I missing something, or is this a compiler bug?</p>\n", "Title": "Is a function call expression with a single non-type template parameter argument type-dependent?", "CreationDate": "2014-12-31T11:04:20.270", "LastActivityDate": "2014-12-31T11:50:54.607", "CommentCount": "1", "PostTypeId": "1", "Id": "27720222", "Score": "1", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer><dependent-type><compiler-bug>", "AnswerCount": "1"}});