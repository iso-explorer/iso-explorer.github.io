post_cb({"17309708": {"CommentCount": "4", "ViewCount": "97", "CreationDate": "2013-06-26T00:28:21.480", "LastActivityDate": "2013-06-26T00:43:26.887", "Title": "Do std containers always throw exceptions in a multi-threaded environment?", "AcceptedAnswerId": "17309820", "PostTypeId": "1", "Id": "17309708", "Score": "2", "Body": "<p>Do containers like std::vector &amp;&amp; friends (I'm actually using a QList) throw a catchable exception or is it undefined behavior if one thread tries to write to the container when another thread is reading from it:</p>\n<pre><code>std::vector&lt;std::string&gt; stuff;\n</code></pre>\n<p>Non-critical task (e.g. spell check) in another thread:</p>\n<pre><code>try {\n    for (std::string&amp; s : stuff) {\n        //do stuff with s\n    }\n} catch (...) {  // Handle all exceptions\n    //bail out of task\n}\n</code></pre>\n<p>Main thread:</p>\n<pre><code>stuff.erase(std::remove(someIterator), stuff.end()); \n</code></pre>\n<p>So you can see there would be a scenario here where it could have an invalidated iterator and an exception will be thrown in the read thread - which would be caught and just bail out of the task. </p>\n<p>But that is just one scenario - can I <em>rely</em> on catchable exceptions to be thrown from these containers so that I don't need to protect the vectors or strings with a mutex? Or will there be some instances where it could dereference a nullptr (or something) and cause a SEH exception - i.e. something I can't catch and continue. I think the answer is that it's probably implementation dependent, and will most likely result in undefined behavior, but I thought I'd ask the question. </p>\n", "Tags": "<c++><exception><containers><std>", "OwnerUserId": "1284610", "AnswerCount": "3"}, "17309804": {"ParentId": "17309708", "CommentCount": "1", "Body": "<p>AFAIK the standard says nothing about the multithreaded behavior of std::vector et al. Realistically, though, everyone is going to implement things in the most straight forward, performant manner and that means no thread safety whatsoever.</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/c9ceah3b%28VS.71%29.aspx\" rel=\"nofollow\">MSDN</a> documents the behavior of their implementation of the STL. I would expect no differences between mainstream implementations. FYI the long and the short of the MSDN docs is that if you have readers in other threads and the container is being modified behavior will be undefined.</p>\n", "OwnerUserId": "78384", "PostTypeId": "2", "Id": "17309804", "Score": "0", "CreationDate": "2013-06-26T00:42:01.887", "LastActivityDate": "2013-06-26T00:42:01.887"}, "17309820": {"ParentId": "17309708", "CommentCount": "0", "Body": "<p>Generally speaking, you can't count on access to an invalidated iterator throwing any sort of exception.  The result is Undefined Behavior: the call could throw, it could crash, it could seem to work for years and then bite you later, it could break something unrelated elsewhere in your program.</p>\n<p>The Standard forbids this sort of thing on the objects and functions of the standard library:</p>\n<p>17.6.4.10/1:</p>\n<blockquote>\n<p id=\"so_17309708_17309820_0\">The behavior of a program is undefined if calls to standard library functions from different threads may introduce a data race.  The conditions under which this may occur are specified in  17.6.5.9.</p>\n</blockquote>\n<p>17.6.5.9/6:</p>\n<blockquote>\n<p id=\"so_17309708_17309820_1\">Operations on iterators obtained by calling a standard library container or string member function may access the underlying container, but shall not modify it.  [ <em>Note:</em> In particular, container operations that invalidate iterators conflict with operations on iterators associated with that container. --<em>end note</em> ]</p>\n</blockquote>\n<p>Most Qt functions are similarly not thread-safe.</p>\n<p>If you need to share data between threads, protect yourself from data races.  Don't count on a library to do it for you unless the documentation says it does.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "17309820", "Score": "8", "CreationDate": "2013-06-26T00:43:26.887", "LastActivityDate": "2013-06-26T00:43:26.887"}, "17309805": {"ParentId": "17309708", "CommentCount": "0", "Body": "<p>Using invalidated iterator is undefined behavior in its own right. It does not throw exception as you seem to think. So your idea (unless I misunderstood it) would not fly even with mutexing.</p>\n<p>Data races accessing the same std:: object are also source of undefined behavior. </p>\n", "OwnerUserId": "2422194", "PostTypeId": "2", "Id": "17309805", "Score": "1", "CreationDate": "2013-06-26T00:42:10.123", "LastActivityDate": "2013-06-26T00:42:10.123"}, "bq_ids": {"n4140": {"so_17309708_17309820_1": {"section_id": 6351, "quality": 0.8928571428571429, "length": 25}, "so_17309708_17309820_0": {"section_id": 6326, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_17309708_17309820_1": {"section_id": 6108, "quality": 0.8928571428571429, "length": 25}, "so_17309708_17309820_0": {"section_id": 6083, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_17309708_17309820_1": {"section_id": 7860, "quality": 0.8928571428571429, "length": 25}, "so_17309708_17309820_0": {"section_id": 7836, "quality": 0.8421052631578947, "length": 16}}}});