post_cb({"23645786": {"Id": "23645786", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23645495_23645786_0\">the entity it denotes can be referred to by names from other scopes in the same translation unit.</p>\n</blockquote>\n<p>For this to make sense, you have to understand the difference between the entity and the name.</p>\n<p>In your main function, you are creating a new entity and giving it the name <code>a</code>.  The name does not refer to the same entity called <code>a</code> that is in namespace A.  It's a different entity not only because it has different linkage, but also because it is in a different namespace.</p>\n<p>Local variables have no linkage by default, and so they always specify a new entity.  For example</p>\n<pre><code>static int a = 5; // a new entity with name `a` that has internal linkage.\n\nint main()\n{\n    int a; // This is a new entity local to function main with no linkage.\n           // It isn't initialized, so you have undefined behavior if you try to\n           // access it.\n}\n</code></pre>\n<p>In this case, you have two entities, both named <code>a</code>, but they refer to different entities because they are in different scopes with different linkages.</p>\n<p>The situation the standard is referring to is like this:</p>\n<pre><code>static int a = 5; // A new entity with the name `a` that has internal linkage.\n\nvoid f()\n{\n   extern int a; // This is a new declaration for the same entity called `a` in\n                 // the global scope.\n}\n</code></pre>\n<p>Now you only have one entity, but you still have two names in two different scopes.  Those two names are referring to that same single entity.</p>\n<p>This is a very tricky point.  Because the declaration inside <code>f()</code> has <code>extern</code>, you are saying that you want f's <code>a</code> to refer to an entity that is defined elsewhere.  However, since there is already a declaration for <code>a</code> at global scope that is declared <code>static</code>, it makes the <code>a</code> have internal linkage instead of external linkage.</p>\n<p>Note that there isn't much practical value for having two names for the same entity with internal linkage since you can always just use the first name instead.</p>\n", "LastEditorUserId": "951890", "LastActivityDate": "2014-05-14T05:10:46.997", "Score": "0", "CreationDate": "2014-05-14T04:44:42.550", "ParentId": "23645495", "CommentCount": "0", "LastEditDate": "2014-05-14T05:10:46.997", "OwnerUserId": "951890"}, "23645541": {"Id": "23645541", "PostTypeId": "2", "Body": "<p>\"Translation unit\" is the technical term for the chunk of code the compiler processes at one time. Usually this is a <code>.cpp</code> source file and all of the header files it includes.</p>\n<p>In practice, this usually means that a translation unit gets compiled into an object file. This object file is not the complete program; it must be \"linked\" with other object files to make the final program. The \"linking\" process is simply matching up the various functions and such that are defined in one translation unit and used in one or more others.</p>\n<p>For example, your translation unit calls <code>printf</code>, but the definition (machine code) for <code>printf</code> is actually in another translation unit. So the linker has to know 1) where the actual definition of <code>printf</code> is, and 2) where in your code it's called, so it can plug the address of 1) into 2).</p>\n<p><code>printf</code> is an example of something with <em>external linkage;</em> it can be linked to things external to its translation unit. On the flip side, something with <em>internal</em> linkage can only be linked within its translation unit. So, in your example, <code>main</code> can access <code>A::a</code>, which is declared <code>static</code> at the namespace level, but functions defined <em>outside</em> of this translation unit have no way of seeing <code>A::a</code>. This is because the compiler omits the reference to <code>A::a</code> from the link table in the object file.</p>\n<p>Finally, what's happening in your example is that the <code>a</code> that <code>main</code> sees is the one it declared inside itself, which is uninitialized. That's why it's printing a garbage value. If you changed <code>main</code> to:</p>\n<pre><code>int main()\n{\n    printf(\"%d\\n\", A::a);\n}\n</code></pre>\n<p>it would print <code>5</code>.</p>\n", "LastEditorUserId": "2624511", "LastActivityDate": "2014-05-14T04:24:34.897", "Score": "2", "CreationDate": "2014-05-14T04:17:14.267", "ParentId": "23645495", "CommentCount": "0", "LastEditDate": "2014-05-14T04:24:34.897", "OwnerUserId": "2624511"}, "bq_ids": {"n4140": {"so_23645495_23645495_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 7136}, "so_23645495_23645495_2": {"length": 10, "quality": 1.0, "section_id": 7135}, "so_23645495_23645495_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7135}, "so_23645495_23645786_0": {"length": 10, "quality": 1.0, "section_id": 7135}}, "n3337": {"so_23645495_23645495_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 6880}, "so_23645495_23645495_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6879}, "so_23645495_23645786_0": {"length": 10, "quality": 1.0, "section_id": 6879}, "so_23645495_23645495_2": {"length": 10, "quality": 1.0, "section_id": 6879}}, "n4659": {"so_23645495_23645495_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 8637}, "so_23645495_23645495_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8636}, "so_23645495_23645786_0": {"length": 10, "quality": 1.0, "section_id": 8636}, "so_23645495_23645495_2": {"length": 10, "quality": 1.0, "section_id": 8636}}}, "23645495": {"ViewCount": "1068", "Body": "<p>In the standard it says that:</p>\n<blockquote>\n<p id=\"so_23645495_23645495_0\">When a name has internal linkage , the entity it denotes can be\n  referred to by names from other scopes in the same translation unit.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_23645495_23645495_1\">A name having namespace scope (3.3.6) has internal linkage if it is\n  the name of \u2014 a variable, function or function template that is\n  explicitly declared static;</p>\n</blockquote>\n<p>So consider the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nnamespace A\n{\n        /* a with internal linkage now.\n           Entity denoted by a will be referenced from another scope.\n           This will be main() function scope in my case\n        */\n    static int a=5;\n}\n\nint main()\n{\n        int a; //declaring a for unqualified name lookup rules\n    printf(\"%d\\n\",a);//-1216872448\n}\n</code></pre>\n<p>I really don't understand the definitions in the standard. What does it mean that:</p>\n<blockquote>\n<p id=\"so_23645495_23645495_2\">the entity it denotes can be referred to by names from other scopes in\n  the same translation unit.</p>\n</blockquote>\n", "AcceptedAnswerId": "23645584", "Title": "What does \"internal linkage\" mean?", "CreationDate": "2014-05-14T04:12:13.323", "LastActivityDate": "2014-05-14T05:10:46.997", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-14T04:31:25.593", "OwnerDisplayName": "user2889159", "LastEditorUserId": "19465", "Id": "23645495", "Score": "4", "Tags": "<c++><linkage>", "AnswerCount": "3"}, "23645584": {"Id": "23645584", "PostTypeId": "2", "Body": "<p>A <a href=\"https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c\">translation unit</a> usually consists of single source file with all <code>#include</code>d files and results in one <em>object file</em>.</p>\n<p>A <strong>name</strong> in <em>namespace scope</em> has by default <em>external linkage</em>, meaning you can refer that name from other translation units (with scope resolution operator or using directive). But if the name is qualified with <code>static</code>, the linkage becomes <em>internal</em>, and the name can not be referred outside the translation unit in which it was defined. </p>\n<p>In your example you could access <code>a</code> if the namespace <code>A</code>, the name <code>a</code> and <code>main</code> method is in the <strong>same</strong> translation unit. But in <code>main</code>, you are declaring another variable <code>a</code>, which hides the <code>a</code> in namespace <code>A</code>. and the <code>a</code> in main is not initialized, so when you print, it actually prints garbage value from <code>a</code> declared in <code>main</code>. If you want to use <code>a</code> from <code>A</code> in <code>main</code>, use like <code>cout&lt;&lt;A::a</code> or use <code>using namespace A;</code> in the source file containing <code>main</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-14T04:26:23.000", "Score": "5", "CreationDate": "2014-05-14T04:20:38.100", "ParentId": "23645495", "CommentCount": "2", "LastEditDate": "2017-05-23T11:53:56.840", "OwnerUserId": "1390091"}});