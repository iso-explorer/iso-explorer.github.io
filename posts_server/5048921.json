post_cb({"bq_ids": {"n4140": {"so_5048921_5049667_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5999}}, "n3337": {"so_5048921_5049667_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5767}}}, "37600605": {"Id": "37600605", "PostTypeId": "2", "Body": "<p>From C++14 Appendix A, the <em>complete</em> list of cases where parentheses may appear in the grammar is:</p>\n<pre><code>\u00a7A.14 Preprocessing directives\ncontrol-line: # define identifier lparen identifier-list_opt ) replacement-list new-line\ncontrol-line: # define identifier lparen ... ) replacement-list new-line\ncontrol-line: # define identifier lparen identifier-list , ... ) replacement-list new-line\n\n\u00a7A.2 Lexical conventions\nraw-string: \" d-char-sequence_opt ( r-char-sequence_opt ) d-char-sequence_opt \"\n\n\u00a7A.4 Expressions\nprimary-expression: ( expression )\nlambda-declarator: ( parameter-declaration-clause ) mutable_opt exception-specification_opt attribute-specifier-seq_opt trailing-return-type_opt\npostfix-expression: const_cast &lt; type-id &gt; ( expression )\npostfix-expression: dynamic_cast &lt; type-id &gt; ( expression )\npostfix-expression: postfix-expression ( expression-list_opt )\npostfix-expression: reinterpret_cast &lt; type-id &gt; ( expression )\npostfix-expression: simple-type-specifier ( expression-list_opt )\npostfix-expression: static_cast &lt; type-id &gt; ( expression )\npostfix-expression: typeid ( expression )\npostfix-expression: typeid ( type-id )\npostfix-expression: typename-specifier ( expression-list_opt )\nunary-expression: alignof ( type-id )\nunary-expression: sizeof ( type-id )\nunary-expression: sizeof ... ( identifier )\nnew-expression: ::_opt new new-placement_opt ( type-id ) new-initializer_opt\nnew-placement: ( expression-list )\nnew-initializer: ( expression-list_opt )\nnoexcept-expression: noexcept ( expression )\ncast-expression: ( type-id ) cast-expression\n\n\u00a7A.5 Statements\nselection-statement: if ( condition ) statement\nselection-statement: if ( condition ) statement else statement\nselection-statement: switch ( condition ) statement\niteration-statement: do statement while ( expression ) ;\niteration-statement: for ( for-init-statement condition_opt ; expression_opt ) statement\niteration-statement: for ( for-range-declaration : for-range-initializer ) statement\niteration-statement: while ( condition ) statement\n\n\u00a7A.6 Declarations\nstatic_assert-declaration: static_assert ( constant-expression , string-literal ) ;\ndecltype-specifier: decltype ( auto )\ndecltype-specifier: decltype ( expression )\nasm-definition: asm ( string-literal ) ;\nalignment-specifier: alignas ( assignment-expression ..._opt )\nalignment-specifier: alignas ( type-id ..._opt )\nattribute-argument-clause: ( balanced-token-seq )\nbalanced-token: ( balanced-token-seq )\n\n\u00a7A.7 Declarators\nnoptr-declarator: ( ptr-declarator )\nparameters-and-qualifiers: ( parameter-declaration-clause ) attribute-specifier-seq_opt cv-qualifier-seq_opt ref-qualifier_opt exception-specification_opt\nnoptr-abstract-declarator: ( ptr-abstract-declarator )\ninitializer: ( expression-list )\n\n\u00a7A.10 Special member functions\nmem-initializer: mem-initializer-id ( expression-list_opt )\n\n\u00a7A.11 Overloading\noperator-function-id: operator ( )\n\n\u00a7A.13 Exception handling\nhandler: catch ( exception-declaration ) compound-statement\ndynamic-exception-specification: throw ( type-id-list_opt )\nnoexcept-specification: noexcept ( constant-expression )\n</code></pre>\n<p>Note that:</p>\n<ul>\n<li>The preprocessor rules for <code>if-group</code> and <code>elif-group</code> do refer to <code>constant-expression</code>.</li>\n<li><code>lparen</code> means a <code>(</code> with no preceding whitespace</li>\n<li>The rule for <code>raw-string</code> is during lexing, so the <code>(</code> and <code>)</code> do not become tokens.</li>\n<li>Any sequence of valid tokens can appear in a preprocessor group whose condition evaluates to false.</li>\n</ul>\n<hr>\n<p>In your question, you use the following:</p>\n<ul>\n<li><code>cast-expression: ( type-id ) cast-expression</code></li>\n<li><code>postfix-expression: simple-type-specifier ( expression-list_opt )</code></li>\n<li><code>parameters-and-qualifiers: ( parameter-declaration-clause ) attribute-specifier-seq_opt cv-qualifier-seq_opt ref-qualifier_opt exception-specification_opt</code></li>\n<li><code>noptr-abstract-declarator: ( ptr-abstract-declarator )</code></li>\n</ul>\n</hr>", "LastEditorUserId": "1405588", "LastActivityDate": "2016-06-02T19:38:39.147", "CommentCount": "0", "CreationDate": "2016-06-02T19:32:25.680", "ParentId": "5048921", "Score": "0", "OwnerUserId": "1405588", "LastEditDate": "2016-06-02T19:38:39.147"}, "5048932": {"Id": "5048932", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_5048921_5048932_0\">casting (int)a or int(a) </p>\n</blockquote>\n<p>(int)a is a cast</p>\n<p>int(a) is the construction of an int, passing in a to the int ctor</p>\n<p>Expressions are evaluated according to operators' precedence, arity, and whether the operator is right or left associative. Read the operator precedence chart in your C++ text.</p>\n<p>Get a copy of the program c++decl; it reads C++ expressions and outputs an English langauge explanation of the expression. <a href=\"http://unixwiz.net/techtips/reading-cdecl.html\" rel=\"noreferrer\">Or read this explanation.</a></p>\n", "LastEditorUserId": "85931", "LastActivityDate": "2011-02-19T05:02:57.120", "CommentCount": "2", "CreationDate": "2011-02-19T04:54:01.843", "ParentId": "5048921", "Score": "5", "OwnerUserId": "85931", "LastEditDate": "2011-02-19T05:02:57.120"}, "5048921": {"ViewCount": "10700", "Body": "<p>I am a bit confused withnthe interpretation of parentheses by the compiler. Can some one please explain what actually happens in such contexts?</p>\n<p>Casting: <code>(int)a</code> or <code>int(a)</code></p>\n<p>Parameter passing: </p>\n<pre><code>template &lt;typename t&gt;\nint size(t (&amp;)[n]){return n;}\n</code></pre>\n<p>Obviously there could be many different contexts where parentheses change the meaning or interpretation. Can some one please explain what exaactly is happening behind the curtain? How does the compiler know how to interpret in each context? Is there a general guideline or is it a specific rule for each case?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "5049667", "Title": "Different meanings of parentheses in C++?", "CreationDate": "2011-02-19T04:49:50.030", "Id": "5048921", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-02-19T08:21:11.110", "LastEditorUserId": "501557", "LastActivityDate": "2016-06-02T19:38:39.147", "Score": "8", "OwnerUserId": "322933", "Tags": "<c++><parsing><compiler-construction><parentheses>", "AnswerCount": "3"}, "5049667": {"Id": "5049667", "PostTypeId": "2", "Body": "<p>Captain Pedantic to the Rescue!</p>\n<p>If you write</p>\n<pre><code>int(value)\n</code></pre>\n<p>This is what's known as an <em>explicit type conversion</em> and is governed by \u00a75.2.3.  The exact wording says that</p>\n<blockquote>\n<p id=\"so_5048921_5049667_0\">A simple-type-specifier (7.1.5) followed by a parenthesized expression-list constructs a value of the specified type given the expression list. <strong>If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression</strong> (5.4)</p>\n</blockquote>\n<p>(My emphasis).  So this means that</p>\n<pre><code>int(value)\n</code></pre>\n<p>and</p>\n<pre><code>(int)value\n</code></pre>\n<p>are completely identical to one another.  It's up to you to pick whichever of these you find easier to write.</p>\n<p>As for your second question, in the example you gave with the templates and array, I believe that what you meant to write was something like this.</p>\n<pre><code>template &lt;typename T, size_t N&gt;\nsize_t (T (&amp;)[N]) {\n    return N;\n}\n</code></pre>\n<p>Here, <code>N</code> as well as <code>T</code> is a template parameter, which allows you to pass in any array that you'd like while having the compiler fill in <code>N</code> with the number of elements in the array.  In case this looks confusing (what on earth is <code>T (&amp;)[N]</code>?), it's because this function is taking in a parameter of type <code>T (&amp;)[N]</code>.  To make this a bit easier to read, let's give this parameter a name, as shown here:</p>\n<pre><code>template &lt;typename T, size_t N&gt;\nsize_t (T (&amp;array)[N]) {\n    return N;\n}\n</code></pre>\n<p>I think this makes this a bit easier to read.  But what does this declaration mean?</p>\n<pre><code>T (&amp;array)[N]\n</code></pre>\n<p>This declares a variable called <code>array</code> that is a reference to an array of <code>T</code>s of exactly <code>N</code> elements.  You can indeed declare references to arrays, just as you can declare pointers to arrays.  This is not very common in practice, but in this particular template idiom is a great way of having the compiler infer the size of the array for you as it tries to match the array to the template argument.</p>\n<p>The reason for the parentheses in this case is that if you write</p>\n<pre><code>T&amp; array[N]\n</code></pre>\n<p>The compiler would parse this as \"a variable called <code>array</code> that's an array of <code>N</code> objects, each of which is a <code>T&amp;</code>.  However, the C++ spec specifically disallows arrays of references, and this would be illegal.  The parentheses explicitly disambiguate this.  This is similar to function pointers - you write</p>\n<pre><code>void (*functionPointer)()\n</code></pre>\n<p>instead of</p>\n<pre><code>void *functionPointer()\n</code></pre>\n<p>To make the compiler realize that the <code>*</code> means that <code>functionPointer</code> is a pointer, rather than a function that returns a <code>void *</code>.</p>\n<p>As for how the compiler determines when to treat parentheses in each way, the rules are fairly complex and there are actually a few circumstances in which the compiler will not parse your expression in the intended way.  One of these cases is something colloquially referred to as \"the most vexing parse\" in which the compiler treats what looks like object construction as a function prototype.  As an example, this code:</p>\n<pre><code>vector&lt;int&gt; v();\n</code></pre>\n<p>Does <strong>not</strong> create a <code>vector&lt;int&gt;</code> called <code>v</code> initialized using the default constructor.  Instead, it treats this as a function prototype for a function called <code>v</code> that takes no arguments and produces a <code>vector&lt;int&gt;</code>!  However, if you were to write</p>\n<pre><code>vector&lt;int&gt; v(10);\n</code></pre>\n<p>Then the compiler can unambiguously infer that this is a declaration of a <code>vector&lt;int&gt;</code> passing <code>10</code> as a constructor argument, because there's no way that it could be treated as a function prototype.  \u00a76.8 and \u00a78.2 of the spec handles these cases by saying that anything that can be treated as a declaration will be, and anything that can be treated as a function prototype will be as well.</p>\n<p>The case of parentheses in the context of the array (that is, <code>T (&amp;array)[N]</code>) is handled by a different piece of logic because in the context in which you're declaring a variable or defining a parameter whose type requires explicit parenthesis, there can be no ambiguity about your intention because it's clear from context that you're naming a type in order to declare a variable.</p>\n<p>To summarize -</p>\n<ol>\n<li>Casts of the form <code>T(value)</code> and <code>(T)value</code> are identical.</li>\n<li>The parentheses in <code>T (&amp;array)[N]</code> are to prevent the compiler from binding the <code>&amp;</code> to <code>T</code> instead of to <code>array</code> as intended.</li>\n<li>The particular use of parenthesis is usually inferred from context, though some issues can come up between variable declarations and function prototypes.</li>\n</ol>\n<p>Hope this helps!</p>\n", "LastEditorUserId": "501557", "LastActivityDate": "2011-02-19T08:16:07.227", "CommentCount": "1", "CreationDate": "2011-02-19T08:11:01.937", "ParentId": "5048921", "Score": "20", "OwnerUserId": "501557", "LastEditDate": "2011-02-19T08:16:07.227"}});