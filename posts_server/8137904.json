post_cb({"8138772": {"ParentId": "8137904", "CommentCount": "1", "Body": "<p>While I quite agree with @JamesKanze's answer, perhaps somebody would like to see what the standard actually says. According to the standard (\u00a712.1/4):</p>\n<blockquote>\n<p id=\"so_8137904_8138772_0\">const and volatile semantics (7.1.5.1) are not applied on an object under\n  construction. Such semantics only come into effect once the constructor for the most derived object (1.8)\n  ends.</p>\n</blockquote>\n<p>and (\u00a712.4/2):</p>\n<blockquote>\n<p id=\"so_8137904_8138772_1\">const and\n  volatile semantics (7.1.5.1) are not applied on an object under destruction. Such semantics stop being\n  into effect once the destructor for the most derived object (1.8) starts.</p>\n</blockquote>\n<p>In fairness, this does little more than re-state what @James said, a bit more specifically: the object is only really considered an object from the time the ctor finishes (or <em>all</em> the ctors, when inheritance is involved) to the point that the first dtor begins. Outside those boundaries, const and volatile aren't enforced.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "8138772", "Score": "2", "CreationDate": "2011-11-15T15:28:51.650", "LastActivityDate": "2011-11-15T15:28:51.650"}, "8138097": {"ParentId": "8137904", "CommentCount": "3", "Body": "<p>It's not.  The <code>delete</code> expression first calls the destructor.  <em>After</em>\ndestruction, you are left with a <code>void*</code>.  (The typical implementation,\nin fact, has the destructor call the <code>operator delete()</code> function, since\nwhich <code>operator delete()</code> to call depends on the most derived class.)</p>\n<p>As to why your <code>T const*</code> becomes a <code>T*</code> in the destructor: is this any \ndifferent than:</p>\n<pre><code>{\n    T const anObject;\n    //  ...\n} // destructor of anObject called here.  With T*, not T const*\n</code></pre>\n<p>?  One can argue for different rules, but in the end, destructors are\nspecial, and obey special rules.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "8138097", "Score": "4", "CreationDate": "2011-11-15T14:41:57.513", "LastActivityDate": "2011-11-15T14:41:57.513"}, "bq_ids": {"n4140": {"so_8137904_8138772_0": {"section_id": 368, "quality": 0.7894736842105263, "length": 15}, "so_8137904_8138772_1": {"section_id": 398, "quality": 0.75, "length": 15}}, "n3337": {"so_8137904_8138772_0": {"section_id": 358, "quality": 0.7894736842105263, "length": 15}, "so_8137904_8138772_1": {"section_id": 389, "quality": 0.75, "length": 15}}, "n4659": {"so_8137904_8138772_0": {"section_id": 380, "quality": 0.7894736842105263, "length": 15}, "so_8137904_8138772_1": {"section_id": 415, "quality": 0.75, "length": 15}}}, "8137904": {"CommentCount": "4", "ViewCount": "215", "PostTypeId": "1", "ClosedDate": "2011-11-15T21:31:15.807", "LastEditorUserId": "-1", "CreationDate": "2011-11-15T14:30:30.213", "LastActivityDate": "2015-08-17T20:25:06.523", "Title": "Why a \"const T*\" is trivially converted to \"void*\" in \"operator delete\"?", "AcceptedAnswerId": "8138772", "LastEditDate": "2017-05-23T12:14:02.780", "Id": "8137904", "Score": "4", "Body": "<blockquote>\n<p id=\"so_8137904_8137904_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/755196/deleting-a-pointer-to-const-t-const\">Deleting a pointer to const (T const*)</a> </br></p>\n</blockquote>\n<pre><code>void operator delete (void*);\n...\nconst char *pn = new char, *pm = (char*)malloc(1);\ndelete pn; // allowed !!\nfree(pm); // error\n</code></pre>\n<p><a href=\"http://www.ideone.com/IPX25\" rel=\"nofollow noreferrer\">Demo</a>.</p>\n<p>It's understandable that <code>free()</code> is a function, so a <code>const void*</code> cannot be converted to <code>void*</code>. But why is it allowed in the case of <code>operator delete</code> (default or overloaded) ?</p>\n<p>Is it not functionally a wrong construct ?</p>\n", "Tags": "<c++><pointers><const><free><delete-operator>", "OwnerUserId": "514235", "AnswerCount": "2"}});