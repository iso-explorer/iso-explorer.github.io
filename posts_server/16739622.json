post_cb({"16739622": {"ViewCount": "1532", "Body": "<p>It is known that two- and one-dimensional arrays can be used equivalently, by simple coordinate conversion. Is such equivalence guaranteed by the C++ standard, or maybe it's the most convenient way of organizing data, but doesn't have to be obeyed everywhere? \nFor example, is the following code compiler-independent?</p>\n<pre><code>std::ofstream ofbStream;\nofbStream.open(\"File\", std::ios::binary);\nchar Data[3][5];\n\nfor(int i=0; i&lt;3; ++i)\nfor(int j=0; j&lt;5; ++j)\n{\n    Data[i][j] = (char) 5*i+j;\n}\n\nofbStream.write(&amp;Data[0][0], 15);\n\nofbStream.close();\n</code></pre>\n<p>The program is expected to write the numbers: 0, 1, 2, ..., 14 to a file. </p>\n", "AcceptedAnswerId": "16740522", "Title": "Two- and one-dimensional arrays equivalence in C++", "CreationDate": "2013-05-24T16:27:52.937", "Id": "16739622", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-05-24T17:27:34.330", "Score": "4", "OwnerUserId": "2418192", "Tags": "<c++><multidimensional-array><standards-compliance>", "AnswerCount": "5"}, "16739891": {"Id": "16739891", "PostTypeId": "2", "Body": "<p>As other commenters have indicated, the 2-dimensional array will be mapped to 1-dimensional memory. Is your assumption platform independent? I would expect so, but you should always test it to be sure.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n\n   char Data[3][5];\n   int count = 0;\n\n   for (int i = 0; i &lt; 3; ++i)\n      for (int j = 0; j &lt; 5; ++j)\n         Data[i][j] = count++;\n\n   std::copy(&amp;Data[0][0], &amp;Data[0][0] + 15, std::ostream_iterator&lt;int&gt;(std::cout,\", \"));\n}\n</code></pre>\n<blockquote>\n<p id=\"so_16739622_16739891_0\">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,</p>\n</blockquote>\n<p><a href=\"http://www.fredosaurus.com/notes-cpp/arrayptr/23two-dim-array-memory-layout.html\" rel=\"nofollow noreferrer\">http://www.fredosaurus.com/notes-cpp/arrayptr/23two-dim-array-memory-layout.html</a></p>\n<p><a href=\"https://stackoverflow.com/questions/2565039/how-are-multi-dimensional-arrays-formatted-in-memory\">How are multi-dimensional arrays formatted in memory?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/6673719/memory-map-for-a-2d-array-in-c\">Memory map for a 2D array in C</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-24T16:50:46.157", "Score": "0", "CreationDate": "2013-05-24T16:46:41.310", "ParentId": "16739622", "CommentCount": "0", "OwnerUserId": "2406758", "LastEditDate": "2017-05-23T11:46:58.117"}, "16740061": {"Id": "16740061", "PostTypeId": "2", "Body": "<p>C++ stores multi-dimensional arrays in <a href=\"http://en.wikipedia.org/wiki/Row-major_order\" rel=\"nofollow\">row major</a> order as a one-dimensional array extending through memory.</p>\n", "LastActivityDate": "2013-05-24T16:58:17.877", "CommentCount": "0", "CreationDate": "2013-05-24T16:58:17.877", "ParentId": "16739622", "Score": "1", "OwnerUserId": "2350293"}, "16740058": {"Id": "16740058", "PostTypeId": "2", "Body": "<p>In his book <a href=\"http://rads.stackoverflow.com/amzn/click/0321563840\" rel=\"nofollow\"><em>The C++ Programming Language</em></a>, Bjarne Stroustrup mentions (C.7.2; p. 838 of the <em>Special Edition</em>, 2000):</p>\n<blockquote>\n<p id=\"so_16739622_16740058_0\">... We can initialize <code>ma</code> like this:</p>\n<pre><code>void int_ma() {\n    for(int i=0; i&lt;3; i++)\n        for(int j=0; j&lt;5; j++) ma[i][j] = 10 * i + j; }\n</code></pre>\n<p id=\"so_16739622_16740058_1\">...</p>\n<p id=\"so_16739622_16740058_2\">The array <code>ma</code> is simply 15 <code>int</code>s that we access as if it were 3\n  arrays of 5 <code>int</code>s. <strong>In particular, there is no single object in memory\n  that is the matrix <code>ma</code> - only the elements are stored. The dimensions 3\n  and 5 exist in the compiler source only.</strong></p>\n</blockquote>\n<p>(emphasis mine).</p>\n<p>In other words, the notation <code>[][]...[]</code> is a compiler construction; syntactical sugar if you will.</p>\n<p>For entertainment purposes, I wrote the following code:</p>\n<pre><code>#include&lt;cstdlib&gt;\n#include&lt;iostream&gt;\n#include&lt;iterator&gt;\n#include&lt;algorithm&gt;\n\nint main() {\n  double ma[5][3]; double *beg = &amp;ma[0][0]; // case 1\n  //double ma[3][5]; double *beg = &amp;ma[0][0]; // case 2\n  //double ma[15]; double *beg = &amp;ma[0]; // case 3\n\n  double *end = beg + 15;\n\n  // fill array with random numbers\n  std::generate(beg, end, std::rand);\n\n  // display array contents\n  std::copy(beg, end, std::ostream_iterator&lt;double&gt;(std::cout, \" \"));\n  std::cout&lt;&lt;std::endl;  \n  return 0;\n}\n</code></pre>\n<p>And compared the assembly generated for the three cases using the compilation command (GCC 4.7.2):</p>\n<pre><code>g++ test.cpp -O3 -S -oc1.s \n</code></pre>\n<p>The cases are called <code>c1.s</code>, <code>c2.s</code>, and <code>c3.s</code>. The output of the command <code>shasum *.s</code> is:</p>\n<pre><code>5360e2438aebea682d88277da69c88a3f4af10f3  c1.s\n5360e2438aebea682d88277da69c88a3f4af10f3  c2.s\n5360e2438aebea682d88277da69c88a3f4af10f3  c3.s\n</code></pre>\n<p>Now, I must mention that the most natural construction seems to be the one-dimensional declaration of <code>ma</code>, that is: <code>double ma[N]</code>, because then the initial position is simply <code>ma</code>, and the final position is simply <code>ma + N</code> (this is as opposed to taking the address of the first element of the array).</p>\n<p>I find that the algorithms provided by the <code>&lt;algorithm&gt;</code> C++ Standard Library header fit much more snuggly in this case.</p>\n<p>Finally, I must encourage you to consider using <code>std::array</code> or <code>std::vector</code> if at all possible.</p>\n<p>Cheers.</p>\n", "LastEditorUserId": "104427", "LastActivityDate": "2013-05-24T17:27:34.330", "Score": "4", "CreationDate": "2013-05-24T16:58:05.280", "ParentId": "16739622", "CommentCount": "0", "OwnerUserId": "104427", "LastEditDate": "2013-05-24T17:27:34.330"}, "bq_ids": {"n4140": {"so_16739622_16740158_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 3236}, "so_16739622_16740522_0": {"length": 57, "quality": 1.0, "section_id": 6142}}, "n3337": {"so_16739622_16740158_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 3109}, "so_16739622_16740522_0": {"length": 57, "quality": 1.0, "section_id": 5906}}, "n4659": {"so_16739622_16740158_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 3992}}}, "16740522": {"Id": "16740522", "PostTypeId": "2", "Body": "<p>In practice, this is just fine.  Any compiler that doesn't do that would have countless problems with existing code.</p>\n<p>Very strictly speaking, though, the pointer arithmetic needed is Undefined Behavior.</p>\n<pre><code>char Data[3][5];\nchar* p = &amp;Data[0][0];\np + 7; // UB!\n</code></pre>\n<p>5.7/5 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_16739622_16740522_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand.  If the pointer operand points to an element of an array object, <em>and the array is large enough</em>, the result points to an element offset from the original element such that that difference of the subscripts of the resulting and original array elements equals the integral expression.  ...  If both the pointer operand and the result point to <em>elements of the same array object, or one past the last element of the array object</em>, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>The Standard does guarantee that all the array elements are adjacent in memory and are in a specific order, and that dereferencing a pointer with the correct address (no matter how you got it) refers to the object at that address, but it doesn't guarantee that <code>p + 7</code> does anything predictable, since <code>p</code> and <code>p + 7</code> don't point at elements of the same array or past-the-end.  (Instead they point at elements of elements of the same array.)</p>\n", "LastActivityDate": "2013-05-24T17:26:49.467", "CommentCount": "3", "CreationDate": "2013-05-24T17:26:49.467", "ParentId": "16739622", "Score": "4", "OwnerUserId": "459640"}, "16740158": {"Id": "16740158", "PostTypeId": "2", "Body": "<p>Quote</p>\n<blockquote>\n<p id=\"so_16739622_16740158_0\">It follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that\n  the \ufb01rst subscript in the declaration helps determine the amount of storage consumed by an array but plays\n  no other part in subscript calculations. </p>\n</blockquote>\n<p><a href=\"http://isocpp.org/std/the-standard\" rel=\"nofollow\">C++ ISO standard</a></p>\n", "LastActivityDate": "2013-05-24T17:03:42.793", "CommentCount": "0", "CreationDate": "2013-05-24T17:03:42.793", "ParentId": "16739622", "Score": "0", "OwnerUserId": "2299382"}});