post_cb({"bq_ids": {"n4140": {"so_38817156_38817548_0": {"length": 11, "quality": 0.55, "section_id": 3242}}, "n3337": {"so_38817156_38817548_0": {"length": 11, "quality": 0.55, "section_id": 3115}}, "n4659": {"so_38817156_38817548_0": {"length": 11, "quality": 0.55, "section_id": 4000}}}, "38817548": {"Id": "38817548", "PostTypeId": "2", "Body": "<p>Recall that default parameters are specified at the declaration (unless the function is inlined):</p>\n<pre><code>void foo(int i, const char* p=nullptr);\n\nvoid foo(int i, const char* p) {\n    //...\n}\n</code></pre>\n<p>The responsibility for populating the default parameters falls to the caller: <a href=\"https://godbolt.org/g/8z63qA\" rel=\"nofollow\">https://godbolt.org/g/8z63qA</a></p>\n<p>Under the hood, the function signature is that of a function with a full set of arguments, so these two functions have the same signature:</p>\n<pre><code>void foo(int i, const char* p);\nvoid foo(int i, const char* p=nullptr);\n</code></pre>\n<p>8.3.5/8 <a href=\"http://eel.is/c++draft/dcl.fct\" rel=\"nofollow\">dcl.fct</a></p>\n<blockquote>\n<p id=\"so_38817156_38817548_0\">The return type, the parameter-type-list, the ref-qualifier, the cv-qualifier-seq, and whether the function has a non-throwing exception-specification, but not the default arguments ([dcl.fct.default]) or the exception specification ([except.spec]), are part of the function type. </p>\n</blockquote>\n<p>So adding a default parameter to your function will change its signature and require that clients be recompiled with the new header.</p>\n", "LastActivityDate": "2016-08-07T19:05:36.263", "CommentCount": "0", "CreationDate": "2016-08-07T19:05:36.263", "ParentId": "38817156", "Score": "0", "OwnerUserId": "257645"}, "38817156": {"ViewCount": "38", "Body": "<p>In creating a shared library, I must implement the function <code>void foo();</code>  foo() has dependencies that I would like to mock in my unit tests. My initial thought is to rewrite the signature to include default parameters so that I can inject the dependencies.</p>\n<p>One option is to use foo() as a wrapper around bar() and write unit tests for bar() like so:</p>\n<pre><code>void bar(SomeClass *someObject=NULL);  // test this   \nvoid foo() { \n    bar(); \n}\n</code></pre>\n<p>However, my question is how safe is it to modify foo() to take default parameters without breaking the library import or usage of foo()?</p>\n<p>I can do things with the processor to rewrite the signature depending on build settings(test, debug, release); however, the question still remains. I can't recall how C++ implements default parameters under the hood.</p>\n", "Title": "Can adding default parameters to a library function break the import or useage?", "CreationDate": "2016-08-07T18:19:31.500", "LastActivityDate": "2016-08-07T19:05:36.263", "CommentCount": "1", "PostTypeId": "1", "Id": "38817156", "Score": "-1", "OwnerUserId": "5121507", "Tags": "<c++><unit-testing>", "AnswerCount": "1"}});