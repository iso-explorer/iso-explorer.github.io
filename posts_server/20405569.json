post_cb({"20405814": {"ParentId": "20405569", "CommentCount": "5", "Body": "<p>That's to prevent you from creating a template that has nullptr as a argument.\nYou most likely don't want that. You want the template to use a propper class as an argument and take nullptr as a value for that argument.</p>\n<p>You can either</p>\n<ul>\n<li>explicitly call the right version of the template</li>\n<li>cast nullptr to a propper type for the template.</li>\n<li>create a local var of the right pointer type, give it value nullptr and make the call using that var.</li>\n</ul>\n", "OwnerUserId": "241013", "PostTypeId": "2", "Id": "20405814", "Score": "-1", "CreationDate": "2013-12-05T16:47:50.157", "LastActivityDate": "2013-12-05T16:47:50.157"}, "20405891": {"ParentId": "20405569", "CommentCount": "2", "Body": "<p>From the C++ standard (4.10 Pointer conversions [conv.ptr])</p>\n<blockquote>\n<p id=\"so_20405569_20405891_0\">1 A null pointer constant is an integral constant expression (5.19) prvalue of integer type \n  that evaluates to zero or a prvalue of type std::nullptr_t. A null pointer constant can be \n  converted to a pointer type; the result is the null pointer value of that type and is \n  distinguishable from every other value of object pointer or function pointer type. Such a \n  conversion is called a null pointer conversion.</p>\n</blockquote>\n<p>In your first exemple your two nullptr have already been converted before template argument deduction. So there is no problem you have the same type twice.</p>\n<p>In the second one, there is a <code>std::vector&lt;int&gt;</code> and a <code>std::nullptr_t</code> and that does not match. You have to do the conversion yourself: <code>static_cast&lt;std::vector&lt;int&gt;*&gt;(nullptr)</code>.</p>\n", "OwnerUserId": "2439734", "PostTypeId": "2", "Id": "20405891", "Score": "6", "CreationDate": "2013-12-05T16:51:12.463", "LastActivityDate": "2013-12-05T16:51:12.463"}, "20405569": {"CommentCount": "1", "AcceptedAnswerId": "20405891", "PostTypeId": "1", "LastEditorUserId": "476681", "CreationDate": "2013-12-05T16:37:57.193", "LastActivityDate": "2013-12-05T19:34:37.487", "LastEditDate": "2013-12-05T16:43:19.977", "ViewCount": "4233", "FavoriteCount": "1", "Title": "In function call, why doesn't nullptr match a pointer to a template object?", "Id": "20405569", "Score": "9", "Body": "<p>Here is an example of a code that works perfectly:</p>\n<hr>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\ntemplate&lt; class D, template&lt; class D, class A &gt; class C, class A = std::allocator&lt; D &gt; &gt;\nvoid foo( C&lt; D, A &gt; *bar, C&lt; D, A &gt; *bas ) {\n  std::cout &lt;&lt; \"Ok!\" &lt;&lt; std::endl;\n}\n\nint main( ) {\n  std::vector&lt; int &gt; *sample1 = nullptr;\n  std::vector&lt; int &gt; *sample2 = nullptr;\n  foo( sample1, sample2 );\n  return( 0 );\n}\n</code></pre>\n<hr>\n<p>In the code below, however, the compiler is unable to match std::vector&lt; int &gt;* with nullptr for the second parameter, even being able to deduct the template types from the first parameter.</p>\n<hr>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\ntemplate&lt; class D, template&lt; class D, class A &gt; class C, class A = std::allocator&lt; D &gt; &gt;\nvoid foo( C&lt; D, A &gt; *bar, C&lt; D, A &gt; *bas ) {\n  std::cout &lt;&lt; \"Ok!\" &lt;&lt; std::endl;\n}\n\nint main( ) {\n  std::vector&lt; int &gt; *sample = nullptr;\n  foo( sample, nullptr );\n  return( 0 );\n}\n</code></pre>\n<hr>\n<p>The error message is:</p>\n<hr>\n<pre><code>$ g++ -std=c++11 nullptr.cpp -o nullptr\n\nnullptr.cpp: In function \u2018int main()\u2019:\n\nnullptr.cpp:11:24: error: no matching function for call to \u2018foo(std::vector&lt;int&gt;*&amp;, std::nullptr_t)\u2019\n\n   foo( sample, nullptr );\n\nnullptr.cpp:11:24: note: candidate is:\n\nnullptr.cpp:5:6: note: template&lt;class D, template&lt;class D, class A&gt; class C, class A&gt; void foo(C&lt;D, A&gt;*, C&lt;D, A&gt;*)\n\n void foo( C&lt; D, A &gt; *bar, C&lt; D, A &gt; *bas ) {\n\nnullptr.cpp:5:6: note:   template argument deduction/substitution failed:\n\nnullptr.cpp:11:24: note:   mismatched types \u2018C&lt;D, A&gt;*\u2019 and \u2018std::nullptr_t\u2019\n\n   foo( sample, nullptr );\n</code></pre>\n<hr>\n<p>Why does that happen?</p>\n</hr></hr></hr></hr></hr></hr>", "Tags": "<c++><c++11><function-call><template-matching><nullptr>", "OwnerUserId": "1574855", "AnswerCount": "5"}, "20408948": {"ParentId": "20405569", "CommentCount": "0", "Body": "<p>template argument deduction is pattern matching.  It does not do much conversion of the arguments other than conversion-to-base (well, adding <code>const</code> and reference qualifiers on the type and <code>decay</code>).</p>\n<p>While <code>nullptr</code> can be converted into a <code>C&lt; D, A &gt;*</code>, it is not such a type.  And both arguments participate equally in the deduction.</p>\n<p>You can block deduction of the second argument by using something like <code>typename std::identity&lt;C&lt; D, A &gt; &gt;::type*</code>, and the same for the first argument.  If you do it for both arguments, the <code>template</code> types will not be deduced.</p>\n<p>Another approach would be to take two arbitrary types, then use SFINAE to ensure that one type of pointer can be converted to the other, and the one that can be can be converted to from the other can be deduced to be a <code>C&lt;D,A&gt;</code> for some <code>template</code> <code>C</code> and types <code>D</code> and <code>A</code>.  This probably matches what your internal mental model of what the function type deduction <em>should</em> do.  However, the result will be really, really verbose.</p>\n<p>An even better approach might be asking \"what do you expect to do with these two arguments\", and do duck-type testing on that, rather than doing type matching.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "20408948", "Score": "0", "CreationDate": "2013-12-05T19:34:37.487", "LastActivityDate": "2013-12-05T19:34:37.487"}, "20408445": {"ParentId": "20405569", "CommentCount": "0", "Body": "<p>This is just how template deduction work: no conversion take place.</p>\n<p>The problem is not endemic to <code>nullptr</code> either, consider the extremely simple case:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Thing {\n    operator int() const { return 0; }\n} thingy;\n\ntemplate &lt;typename T&gt;\nvoid print(T l, T r) { std::cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; \"\\n\"; }\n\nint main() {\n    int i = 0;\n    print(i, thingy);\n    return 0;\n}\n</code></pre>\n<p>which <a href=\"http://ideone.com/aV7gEZ\" rel=\"nofollow\">yields</a>:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:12:17: error: no matching function for call to \u2018print(int&amp;, Thing&amp;)\u2019\n  print(i, thingy);\n                 ^\nprog.cpp:12:17: note: candidate is:\nprog.cpp:8:6: note: template&lt;class T&gt; void print(T, T)\n void print(T l, T r) { std::cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; \"\\n\"; }\n      ^\nprog.cpp:8:6: note:   template argument deduction/substitution failed:\nprog.cpp:12:17: note:   deduced conflicting types for parameter \u2018T\u2019 (\u2018int\u2019 and \u2018Thing\u2019)\n  print(i, thingy);\n                 ^\n</code></pre>\n<p>Thus, the conversion of <code>nullptr</code> to <code>int*</code> does not occur <em>prior</em> to template argument deduction either. As mentioned, you have two ways of solving the issue:</p>\n<ul>\n<li>specifying the template parameters (thus no deduction occur)</li>\n<li>converting the argument yourself (deduction occurs, but after your explicit conversion)</li>\n</ul>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "20408445", "Score": "4", "CreationDate": "2013-12-05T19:05:46.150", "LastActivityDate": "2013-12-05T19:05:46.150"}, "bq_ids": {"n4140": {"so_20405569_20405891_0": {"section_id": 39, "quality": 0.7857142857142857, "length": 33}, "so_20405569_20405975_0": {"section_id": 5366, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_20405569_20405891_0": {"section_id": 36, "quality": 0.9285714285714286, "length": 39}, "so_20405569_20405975_0": {"section_id": 5162, "quality": 0.9142857142857143, "length": 32}}, "n4659": {"so_20405569_20405891_0": {"section_id": 39, "quality": 0.7857142857142857, "length": 33}, "so_20405569_20405975_0": {"section_id": 6791, "quality": 0.9142857142857143, "length": 32}}}, "20405975": {"ParentId": "20405569", "CommentCount": "1", "Body": "<p>Compiler can not deduce the second argument type because <code>std::nullptr_t</code> is not a pointer type.</p>\n<blockquote>\n<p id=\"so_20405569_20405975_0\"><sup>1</sup> The pointer literal is the keyword nullptr. It is a\n  prvalue of type std::nullptr_t. [Note: std::nullptr_t is a distinct\n  type that is neither a pointer type nor a pointer to member type;\n  rather, a prvalue of this type is a null pointer constant and can be\n  converted to a null pointer value or null member pointer value.\n  [\u00a72.14.7]</p>\n</blockquote>\n", "OwnerUserId": "952747", "PostTypeId": "2", "Id": "20405975", "Score": "2", "CreationDate": "2013-12-05T16:54:42.020", "LastActivityDate": "2013-12-05T16:54:42.020"}});