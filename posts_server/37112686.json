post_cb({"37112686": {"CommentCount": "2", "ViewCount": "297", "PostTypeId": "1", "LastEditorUserId": "2219912", "CreationDate": "2016-05-09T09:53:29.757", "LastActivityDate": "2016-05-09T10:27:15.057", "Title": "Double move on same object is copying from left to right?", "LastEditDate": "2016-05-09T10:04:27.440", "Id": "37112686", "Score": "4", "Body": "<p>I am just beginner in move operation in c++11, so playing with it. But found something which i am not able to understand.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A{\n    public:\n        A(){cout &lt;&lt; \"default ctor\" &lt;&lt; endl;}\n        A(const string&amp; str):_str{str}{cout &lt;&lt; \"parameter ctor\" &lt;&lt; endl;}\n        A(A&amp;&amp; obj):_str{std::move(obj._str)}{cout &lt;&lt; \"move ctor\" &lt;&lt; endl;}\n        A&amp; operator =(A&amp;&amp; rhs){_str = std::move(rhs._str);cout &lt;&lt; \"move assignment operation\" &lt;&lt; endl; return *this;}\n        void print(){cout &lt;&lt; _str &lt;&lt; endl;}\n    private:\n        string _str;\n};\n\nint main(){\n    A a(\"rupesh yadav\"); // parameter ctor\n    A b(std::move(a));   // move ctor\n\n    cout &lt;&lt; \"print a: \";\n    a.print();           // NOT printing  --&gt; CORRECT!!\n    cout &lt;&lt; \"print b: \";\n    b.print();           // printing      --&gt; CORRECT!!\n\n    b = std::move(a);    // i don't know may be silly but still lets do it WHY NOT!!!, could be just mistake??\n\n    cout &lt;&lt; \"print a: \"; \n    a.print();           // printing      --&gt; WRONG!! \n    cout &lt;&lt; \"print b: \"; \n    b.print();           // NOT printing  --&gt; WRONG!!\n}\n</code></pre>\n<p>I was expecting that <code>b = std::move(a)</code> operation would behave something different because i am applying move on object <strong>a</strong> second time but it is copying left side object <strong>b</strong> to right hand side object <strong>a</strong>, this part i don't understand. </p>\n<p>Or i have done something wrong in programming.\nPlease help if i am doing something wrong in move operation.</p>\n<p><strong>EDIT:</strong> I know this is undefined behavior. My doubt is if i will do it again then it is copying from object <strong>a</strong> to object <strong>b</strong>, and if again i will do the same thing then will copy object <strong>b</strong> to object <strong>a</strong>?</p>\n<p>Hence it is copying form left to right and right to left why?</p>\n", "Tags": "<c++><c++11><move><move-semantics><move-assignment-operator>", "OwnerUserId": "2219912", "AnswerCount": "2"}, "37112743": {"ParentId": "37112686", "CommentCount": "10", "Body": "<p>You can't move from the same object twice.</p>\n<p>After you first moved <code>a</code> into <code>b</code>, <code>a</code> had a \"valid but unspecified state\" (can't remember the exact terminology). Then, you attempted to move <code>a</code> into <code>b</code> <em>again</em>! Now all heck has broken loose. (I suspect that, internally, the data pointers have just been swapped around.)</p>\n<p>Simply don't do this. I see no reason to want to.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "37112743", "Score": "5", "CreationDate": "2016-05-09T09:56:30.587", "LastActivityDate": "2016-05-09T09:56:30.587"}, "37113417": {"ParentId": "37112686", "CommentCount": "0", "Body": "<p>Nothing prevents you from moving from an object twice. Standard library objects are required to be left in a \"valid, but unspecified\" state when moved from. The only condition is that \"the object's invariants are met and operations on the object behave as specified for its type\" <a href=\"http://eel.is/c++draft/defns.valid\" rel=\"nofollow\">17.3.28</a>. As an example, the move constructor for <a href=\"http://eel.is/c++draft/string.cons#2\" rel=\"nofollow\"><code>std::string</code></a> says:</p>\n<blockquote>\n<p id=\"so_37112686_37113417_0\"><code>basic_string(const basic_string&amp; str);</code> </p>\n<p id=\"so_37112686_37113417_1\"><code>basic_string(basic_string&amp;&amp; str) noexcept;</code></p>\n<p id=\"so_37112686_37113417_2\">2 <em>Effects</em>: Constructs an object of class <code>basic_string</code> as indicated\n  in Table [tab:strings.ctr.cpy]. In the second form, <code>str</code> is left in a\n  valid state with an unspecified value.</p>\n</blockquote>\n<p>The move constructor  has no preconditions and moving from it again would not violate its invariants. Furthermore, since it's clearly outlined in the standard, by definition it's not undefined behavior. You could argue by omission that violating the invariants of <code>std::string</code> is undefined behavior however, but that leads us to:</p>\n<p>Is calling <code>operator&lt;&lt;</code> on a <code>std::string</code> disallowed? The description from <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator_ltltgtgt\" rel=\"nofollow\"><code>cppreference</code></a> says:</p>\n<blockquote>\n<p id=\"so_37112686_37113417_3\">Behaves as a\n  <a href=\"http://en.cppreference.com/w/cpp/concept/FormattedOutputFunction\" rel=\"nofollow\">FormattedOutputFunction</a>.\n  After constructing and checking the sentry object, determines the\n  output format padding as follows:</p>\n<ul>\n<li><p id=\"so_37112686_37113417_4\">If <code>str.size()</code> is not less than <code>os.width()</code>, uses the range <code>[str.begin(), str.end())</code> as-is </p></li>\n<li><p id=\"so_37112686_37113417_5\">Otherwise, if <code>(os.flags() &amp; ios_base::adjustfield) == ios_base::left</code>, places <code>os.width()-str.size()</code> copies of the\n  <code>os.fill()</code> character after the character sequence </p></li>\n<li><p id=\"so_37112686_37113417_6\">Otherwise, places <code>os.width()-str.size()</code> copies of the <code>os.fill()</code> character before the character sequence</p></li>\n</ul>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/string.capacity#3\" rel=\"nofollow\"><code>size()</code></a>, <a href=\"http://eel.is/c++draft/string.iterators#1\" rel=\"nofollow\"><code>begin()</code></a> and <a href=\"http://eel.is/c++draft/string.iterators#2\" rel=\"nofollow\"><code>end()</code></a> have no preconditions so the code is perfectly safe.</p>\n", "OwnerUserId": "6292850", "PostTypeId": "2", "Id": "37113417", "Score": "2", "CreationDate": "2016-05-09T10:27:15.057", "LastActivityDate": "2016-05-09T10:27:15.057"}, "bq_ids": {"n4140": {"so_37112686_37113417_6": {"section_id": 2289, "quality": 0.5555555555555556, "length": 5}, "so_37112686_37113417_2": {"section_id": 1569, "quality": 0.8125, "length": 13}}, "n3337": {"so_37112686_37113417_3": {"section_id": 1853, "quality": 0.5833333333333334, "length": 7}, "so_37112686_37113417_2": {"section_id": 1564, "quality": 0.8125, "length": 13}}, "n4659": {"so_37112686_37113417_6": {"section_id": 2562, "quality": 0.5555555555555556, "length": 5}, "so_37112686_37113417_2": {"section_id": 1718, "quality": 0.8125, "length": 13}}}});