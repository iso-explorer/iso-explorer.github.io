post_cb({"25674562": {"ParentId": "25672745", "CommentCount": "0", "CreationDate": "2014-09-04T20:35:14.113", "OwnerUserId": "501250", "PostTypeId": "2", "Id": "25674562", "Score": "2", "Body": "<p>No, clang is doing the right thing.  This is not a bug.</p>\n<p>You are misreading the context of this spec excerpt.  The only thing this paragraph is communicating relates to how friend function declarations and their target function get associated with each other.  <em>It has nothing whatsoever to do with the usual rules around <strong>calling</strong> that particular function, and changes nothing in that regard.</em></p>\n<p>Compilation therefore does not fail because the prototype of the function <code>f()</code> has not yet been declared at the point you attempt to use it (and instead it finds the typedef with the same name).</p>\n<p>If you alter your code to implement the <code>A::g()</code> member outside of the class, you will note that compilation fails when the <code>f()</code> prototype appears before the implementation and succeeds when the prototype appears after it -- exactly what you would expect to happen if the friend declaration was absent.</p>\n", "LastActivityDate": "2014-09-04T20:35:14.113"}, "25672745": {"CommentCount": "11", "AcceptedAnswerId": "25674562", "PostTypeId": "1", "LastEditorUserId": "815724", "CreationDate": "2014-09-04T18:35:08.893", "LastActivityDate": "2014-09-05T04:29:50.303", "LastEditDate": "2014-09-05T04:29:50.303", "ViewCount": "260", "FavoriteCount": "1", "Title": "Friend declarations: Is this a bug in clang?", "Id": "25672745", "Score": "2", "Body": "<p>\u00a73.4.1/3 has the following example:</p>\n<pre><code>typedef int f;\nnamespace N\n{\n    struct A\n    {\n        friend void f(A &amp;);\n        operator int();\n        void g(A a)\n        {\n            int i = f(a);\n        }\n    };\n}\n</code></pre>\n<p>Which compiles without errors (see <a href=\"http://rextester.com/DCFIX79502\" rel=\"nofollow\">live example</a>) as the compiler doesn't see the friend declaration <code>N::A::f(A&amp;)</code> in the ordinary lookup for the name <code>f</code> in the declaration <code>int i = f(a);</code> and this is correct according to \u00a77.3.1.2/3.</p>\n<p>\u00a77.3.1.2/3 (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_25672745_25672745_0\">Every name first declared in a namespace is a member of that\n  namespace. If a friend declaration in a nonlocal class first declares\n  a class or function the friend class or function is a member of the\n  innermost enclosing namespace. The name of the friend is not found by\n  unqualified lookup (3.4.1) or by qualified lookup (3.4.3) until a\n  matching declaration is provided in that namespace scope (<strong>either\n  before or after the class definition granting friendship</strong>).</p>\n</blockquote>\n<p>Now if we include the declarations</p>\n<pre><code>struct A;\nvoid f(A&amp;);\n</code></pre>\n<p>In the snippet above in <code>namespace N</code>, <strong>before</strong> the <code>struct A</code>, the code will correctly emit an error (see <a href=\"http://rextester.com/OUBS81834\" rel=\"nofollow\">live example</a>), as now the function <code>::f(A&amp;)</code> is found by ordinary lookup for the name <code>f</code> in the expression <code>int i = f(a);</code> and this is in accordance with \u00a77.3.1.2/3.</p>\n<p>However, if we include the declaration</p>\n<pre><code>void f(A&amp;);\n</code></pre>\n<p>In <code>namespace N</code>, <strong>after</strong> the <code>struct A</code>, the code surprisingly doesn't emit any error, see <a href=\"http://rextester.com/CLT93411\" rel=\"nofollow\">live example</a>.</p>\n", "Tags": "<c++><c++11><namespaces><language-lawyer><name-lookup>", "OwnerUserId": "2548699", "AnswerCount": "2"}, "25673101": {"ParentId": "25672745", "CommentCount": "0", "CreationDate": "2014-09-04T18:57:20.367", "OwnerUserId": "3959454", "PostTypeId": "2", "Id": "25673101", "Score": "1", "Body": "<p>In the same paragraph you cited (<code>\u00a77.3.1.2/3</code>) there is an example clarifying the lookup rules:</p>\n<pre><code>// Assume f and g have not yet been defined.\nvoid h(int);\ntemplate &lt;class T&gt; void f2(T);\nnamespace A {\n    class X {\n        friend void f(X); // A::f(X) is a friend\n        class Y {\n            friend void g(); // A::g is a friend\n            friend void h(int); // A::h is a friend\n            // ::h not considered\n            friend void f2&lt;&gt;(int); // ::f2&lt;&gt;(int) is a friend\n        };\n    };\n\n    // A::f, A::g and A::h are not visible here\n    X x;\n    void g() { f(x); } // definition of A::g\n    void f(X) { /* ... */} // definition of A::f\n    void h(int) { /* ... */ } // definition of A::h\n    // A::f, A::g and A::h are visible here and known to be friends\n}\n</code></pre>\n<p>So the compiler works correctly.</p>\n", "LastActivityDate": "2014-09-04T18:57:20.367"}, "bq_ids": {"n4140": {"so_25672745_25672745_0": {"section_id": 5485, "quality": 0.8444444444444444, "length": 38}}, "n3337": {"so_25672745_25672745_0": {"section_id": 5271, "quality": 0.9333333333333333, "length": 42}}, "n4659": {"so_25672745_25672745_0": {"section_id": 6920, "quality": 0.6888888888888889, "length": 31}}}});