post_cb({"bq_ids": {"n4140": {"so_17074385_17074933_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 5908}}, "n3337": {"so_17074385_17074933_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 5680}}, "n4659": {"so_17074385_17074933_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 7390}}}, "17074933": {"Id": "17074933", "PostTypeId": "2", "Body": "<p>I think GCC is right. From the code you posted, it seems to me you are not providing a <em>definition</em> for your static data member.</p>\n<p>Since you are passing <code>T::ID</code> in input to <code>std::unordered_map::find()</code>, which takes its argument <em>by reference</em>, you are odr-using <code>ID</code> (ODR stands for One Definition Rule, and odr-using means, in short, that the compiler needs to know the address of that object).</p>\n<p>Since the address of the static data member is needed, but no definition at global namespace is provided, you end up with an unresolved symbol error from the linker. </p>\n<p>Per paragraph 9.4.2/3 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17074385_17074933_0\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class\n  definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em>\n  is a constant expression (5.19). [...] The <strong>member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an initializer</strong>.</p>\n</blockquote>\n<p>Therefore, to solve the problem, just add a definition at namespace scope in a <code>.cpp</code> file (or in a header included by just one <code>.cpp</code> file):</p>\n<pre><code>const ELComponentID Position3DComponent::ID;\n</code></pre>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-12T21:40:58.237", "Score": "0", "CreationDate": "2013-06-12T20:40:18.990", "ParentId": "17074385", "CommentCount": "7", "OwnerUserId": "1932150", "LastEditDate": "2013-06-12T21:40:58.237"}, "17074385": {"ViewCount": "265", "Body": "<p>So I have this c++ code which I have written for c++0X. It used to compile in MSVC 2012, but now I switched to MingW64 4.8.1 because I was dissatisfied with the lack of C++11 support in MSVC. The following is part of some code which implements a simple Entity/Component System.</p>\n<p>This is the error I get:</p>\n<blockquote>\n<p id=\"so_17074385_17074385_0\">if(e-&gt;components.find(T::ID) == e-&gt;components.end())</p>\n<p id=\"so_17074385_17074385_1\">undefined reference to\n  `EL::Position3DComponent::ID' ELEntityManager.h   /Elementium/Elementium  line\n  64    C/C++ Problem</p>\n</blockquote>\n<p>which is related to using T::ID... </p>\n<p>Here is some further explanation of what I used to use this code for in MSVC 2012:</p>\n<p>In every component, I have a static const ELComponentID member which is initialized to the component's id. This is used because I need to easily get the entities which have a certain component, so I'm using a multimap in the ELEntityManager whose key is ELComponentID and whose value is a unique_ptr containing the ELEntity who has such a component.</p>\n<p>In the ELEntity class, I use an unordered_map whose key is ELComponentID and whose value is a unique_ptr containing the ELComponent in question.</p>\n<p>Yes it does take up a little more memory, but I do this mainly for access speed.</p>\n<p>file ELEntityManager.h:</p>\n<pre><code>//Includes\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include \"ELEntity.h\"\n#include \"ELComponent.h\"\n\nnamespace EL{\n\nclass ELEntityManager\n{\npublic:\n\n//...\n\ntemplate&lt;typename T&gt; void addComponent(std::unique_ptr&lt;ELEntity&gt; e, std::unique_ptr&lt;ELComponent&gt; c)\n{\n    if(c == nullptr || e == nullptr)\n        return;\n    if(e-&gt;components.find(T::ID) == e-&gt;components.end())  //***** &lt;-- This is where I get the error.\n    {\n        //...\n    }\n    //...\n}\n\n//...\n\nprivate:\n//******************************************\n// Private data members\n//******************************************\n    std::multimap&lt;ELComponentID, std::unique_ptr&lt;ELEntity&gt; &gt; entities;\n};    \n\n};// End namespace\n</code></pre>\n<p>file ELEntity.h:</p>\n<pre><code>//Includes\n#include &lt;unordered_map&gt;\n#include &lt;memory&gt;\n#include \"ELComponent.h\"\n\nnamespace EL{\n\nclass ELEntity\n{\n    friend class ELEntityManager;\n\n//...\n\nprivate:\n//******************************************\n// Private data members\n//******************************************\n    /**The map of ComponentIDs with their components.*/\n    std::unordered_map&lt;ELComponentID, std::unique_ptr&lt;ELComponent&gt; &gt; components;\n};\n\n};// End namespace\n</code></pre>\n<p>file ELComponent.h:</p>\n<pre><code>//Includes\n#include &lt;unordered_map&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include \"ELMath.h\"\n\n\nnamespace EL{\n\n/**\n* Component IDs.\n*/\nenum ELComponentID {\n    LogicalDevice = 1,  // Start the enum at 1.\n    Viewport,\n    Position3D,\n    Position2D,\n    Orientation,\n    PhysicsRK4\n};\n\n/**\n* Base component class.\n*/\nstruct ELComponent\n{\n};\n\n/**\n* Position3D component, derives from ELVector3D in EL::Math.\n*/\nstruct Position3DComponent: public ELComponent, EL::Math::ELVector3D\n{\n    static const ELComponentID ID = Position3D;\n};\n\n//...\n</code></pre>\n<p>then I have this in main.cpp as a test (with all the required includes, etc...):</p>\n<pre><code>EL::ELEntityManager em;\n\nstd::unique_ptr&lt;EL::ELEntity&gt; e(new EL::ELEntity());\nstd::unique_ptr&lt;EL::Position3DComponent&gt; obj(new EL::Position3DComponent());\n\nobj-&gt;x = 1.0;\nobj-&gt;y = 2.0;\nobj-&gt;z = 3.0;\n\nem.addComponent&lt;EL::Position3DComponent&gt;(std::move(e), std::move(obj));\n</code></pre>\n<p>Now my question is, am I doing something wrong which is gcc specific, is the T::ID not supported in gcc/mingw, or has anything changed in the final c++11 implementation which wasn't in for MSVC 2012?</p>\n<p>How do I fix this error? If it can't be done anymore in c++11, or if there's a bug in gcc, can I do this any other way?</p>\n<p>Thanks a lot in advance for your replies! :)</p>\n", "AcceptedAnswerId": "17074933", "Title": "C++ using a static const class member in a template", "CreationDate": "2013-06-12T20:07:42.350", "Id": "17074385", "CommentCount": "0", "LastEditDate": "2013-06-12T21:26:31.847", "PostTypeId": "1", "LastEditorUserId": "2479694", "LastActivityDate": "2013-06-12T21:40:58.237", "Score": "1", "OwnerUserId": "2479694", "Tags": "<c++><templates><c++11><const><static-members>", "AnswerCount": "1"}});