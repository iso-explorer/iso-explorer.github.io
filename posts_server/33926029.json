post_cb({"33926711": {"ParentId": "33926029", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This code seems to work, for both constructor and assignment-operator:</p>\n<pre><code>#include &lt;array&gt;\n\ntemplate&lt;size_t N&gt;\nstruct Vector\n{\n    Vector() = default;\n\n    template&lt;typename...Args&gt;\n    Vector(double d, Args... args)\n    {\n        static_assert(sizeof...(args) == N-1, \"wrong args count\");\n\n        size_t idx = 0;\n        auto vhelp = [&amp;](double d) { x[idx++] = d; };\n        vhelp(d);\n        double tmp[] { (vhelp(args), 1.0)... };\n    }\n\n    Vector &amp;operator=(Vector const &amp;other) = default;\n\nprivate:\n    std::array&lt;double, N&gt; x = {};\n};\n\nint main()\n{\n    Vector&lt;5&gt; v = { 1,2,3,4,5 };\n    v = { 3,4,5,6,7 };\n\n    Vector&lt;1&gt; w = { 1,2 };  // error\n}\n</code></pre>\n<p>The assignment operator works because the constructor is implicit, so <code>v = bla</code> attempts to convert <code>bla</code> to match the only definition of <code>operator=</code>. </p>\n<p>I made the first argument <code>double d</code> instead of just using all variadic args, to avoid the issue where all-variadic-args constructor catches calls that were supposed to be copy-construction.</p>\n<p>The line involving <code>double tmp[]</code> uses what I call the <a href=\"https://stackoverflow.com/questions/33620783/int-a-functioncalla1-a2-0-voida-what-does-this-syntax-do-mea/\">variadic template comma operator hack</a>. This hack has many uses, but here it lets us avoid the narrowing-conversion issue that <code>double tmp[] { args... };</code> has.  </p>\n<p>(TBH though, incorporating rubvenvb's idea and using <code>double tmp[] { static_cast&lt;double&gt;(args)... };</code> would be simpler)</p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:45.763", "Id": "33926711", "Score": "5", "CreationDate": "2015-11-25T21:28:52.040", "LastActivityDate": "2015-11-25T21:42:18.723"}, "33926665": {"ParentId": "33926029", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>You can make your constructor a variadic template so that any condition can be used:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;cstddef&gt;\n\ntemplate&lt;typename T, std::size_t N&gt;\nclass vector\n{\npublic:\n    vector(T&amp;&amp; value)\n    : data{static_cast&lt;T&gt;(value)}\n    {}\n    template&lt;typename U&gt;\n    vector(const vector&lt;U,N&gt;&amp; v)\n    {\n      std::copy(begin(v.data), end(v.data),\n                begin(data));\n    }\n    template&lt;typename U&gt;\n    vector(const vector&lt;U,N&gt;&amp; v)\n    {\n        std::copy(begin(v.data), end(v.data),\n                  begin(data));\n    }\n    template&lt;typename... U,\n             typename = typename std::enable_if&lt;sizeof...(U)-1&gt;::type&gt;\n    vector(U&amp;&amp;... values)\n    : data{static_cast&lt;T&gt;(values)...}\n    {\n        static_assert(sizeof...(values) == N, \"wrong size\");\n    }\n    std::array&lt;T,N&gt; data;\n};\n\nint main()\n{\n    vector&lt;int, 3&gt; v = {1,2,3};\n    vector&lt;double, 4&gt; vv = {5,4,3,2};\n\n    vv = {1,2,3,4};\n\n    //vector&lt;float, 3&gt; vf = {1,2,3,4}; // fails to compile\n    vector&lt;float,3&gt; vf = v;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/504427107b6d17fb\" rel=\"nofollow\">Live example on coliru</a>.</p>\n<p>It gets you a custom error message, easily adaptable/extensible condition for failure, and gets rid of the \"narrowing conversion\" problem by effectively forwarding the initialization to the <code>std::array</code> initializer like you wanted to do in the first place. Oh, and you get assignment for free.</p>\n<p>As @M.M mentions, this solution ruins copy construction, unfortunately. You can solve it by adding an <code>enable_if</code> on the variadic arguments \"array\" size as shown above. Of course you need to be careful to not ruin assignment/copy-construction and single-element vectors, which is remedied by adding two extra constructors for these special cases.</p>\n", "OwnerUserId": "256138", "LastEditorUserId": "256138", "LastEditDate": "2015-11-26T11:00:35.610", "Id": "33926665", "Score": "5", "CreationDate": "2015-11-25T21:24:38.233", "LastActivityDate": "2015-11-26T11:00:35.610"}, "bq_ids": {"n4140": {"so_33926029_33926029_1": {"section_id": 3329, "quality": 1.0, "length": 30}}, "n3337": {"so_33926029_33926029_1": {"section_id": 3199, "quality": 1.0, "length": 30}}, "n4659": {"so_33926029_33926029_1": {"section_id": 4095, "quality": 1.0, "length": 30}}}, "33926029": {"CommentCount": "7", "ViewCount": "347", "PostTypeId": "1", "LastEditorUserId": "3348786", "CreationDate": "2015-11-25T20:39:53.583", "LastActivityDate": "2015-11-26T11:00:35.610", "Title": "Compile time error if brace-closed list is the wrong size for class constructor", "AcceptedAnswerId": "33926665", "LastEditDate": "2015-11-26T10:59:26.823", "Id": "33926029", "Score": "9", "Body": "<p>I'm trying to write a class based around mathematical vectors:</p>\n<pre><code>template &lt;unsigned N&gt; class Vector{\npublic:\n    Vector() = default;\n    Vector(std::initializer_list&lt;double&gt; li) { *this = li;}\n    Vector&amp; operator=(std::initializer_list&lt;double&gt;);\n\nprivate:\n    std::array&lt;double, N&gt; x = {}\n}\n\ntemplate &lt;unsigned N&gt; inline Vector&lt;N&gt;&amp; Vector&lt;N&gt;::operator=(std::initializer_list&lt;double&gt; li){\n     if(N != li.size()) throw std::length_error(\"Attempt to initialise Vector with an initializer_list of different size.\");\n     std::copy(li.begin(), li.end(), x.begin());\n     return *this;\n}\n</code></pre>\n<p>I want to be able to write code like this;</p>\n<pre><code>Vector&lt;3&gt; a = {1,2,3};\na = {3,5,1};\n</code></pre>\n<p>It would be natural for a user to expect to write code like that, right? However I want <em>compile</em>-time errors to occur if I use the wrong-sized initializer list, much like <code>std::array</code> does.</p>\n<pre><code> std::array&lt;double, 3&gt; a = {2,4,2,4} //compile time error\n Vector&lt;3&gt; a = {3,5,1,5} //run-time error as of right now\n</code></pre>\n<p>My first idea was to use <code>std::array</code> as the constructor/operator parameter so implicit conversions would occur and then the constructor would hijack, from <code>std::array</code>, the compile time errors. Except of course I could only write code like this:</p>\n<pre><code>Vector&lt;3&gt; a({2,3,2}); //fine\nVector&lt;3&gt; b = {2,4,2}; //error, requires two user-defined conversions (list -&gt; array&lt;double,3&gt; -&gt; Vector&lt;3&gt;) \n</code></pre>\n<p>I thought maybe to use a Variadic member template:</p>\n<pre><code>template &lt;typename... Args&gt; Vector(Args... li): x({li...}){\n    static_assert(sizeof...(li) == N);\n}\n</code></pre>\n<p>It has to be <code>typename...</code> rather than <code>double...</code> because nontype parameters must be integral types. But then I run in to a narrowing conversion error</p>\n<pre><code>Vector&lt;2&gt; a = {3,2} //error: narrowing conversion of 'li#0' from 'int' to 'double' inside { } [-Wnarrowing]|\n //error: narrowing conversion of 'li#1' from 'int' to 'double' inside { } [-Wnarrowing]|\n</code></pre>\n<p>Presumably for violating [8.5.4]/7</p>\n<blockquote>\n<p id=\"so_33926029_33926029_0\">A narrowing conversion is an implicit conversion</p>\n<p id=\"so_33926029_33926029_1\">\u2014 from an integer type or unscoped enumeration type to a floating-point type, except where the source is a <strong>constant expression</strong> and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type, or</p>\n</blockquote>\n<p>The parameters from expanding <code>li...</code> aren't constant expressions and hence produce the narrowing conversion error. As far as I'm aware it wouldn't even be possible to make function parameters as constant expressions (nor would it make much sense?). So I'm not sure how to carry on down that route. Obviously <code>Vector&lt;2&gt; a = {2.,3.}</code> works fine but this puts a burden on the user to remember only to supply floating-point literals.</p>\n", "Tags": "<c++><templates><c++11><brace-initialization>", "OwnerUserId": "3348786", "AnswerCount": "2"}});