post_cb({"27078793": {"CommentCount": "2", "ViewCount": "86", "PostTypeId": "1", "LastEditorUserId": "1554020", "CreationDate": "2014-11-22T15:02:34.937", "LastActivityDate": "2016-07-15T14:23:46.857", "Title": "Use inherited member operator instead of free one", "AcceptedAnswerId": "27080014", "LastEditDate": "2016-07-15T14:23:46.857", "Id": "27078793", "Score": "2", "Body": "<p>Suppose there is a free <code>operator*</code> defined somewhere in the namespace <code>ns</code>:</p>\n<pre><code>namespace ns {\n    struct Dummy {};\n\n    template &lt;typename T&gt;\n    Dummy operator*(T&amp;&amp;) {\n        return {};\n    }\n}\n</code></pre>\n<p>In a different place there is a base class in the same namespace, that defines member <code>operator*</code>:</p>\n<pre><code>namespace ns {\n    template &lt;typename T&gt;\n    struct Base {\n        T x;\n\n        T&amp; operator*() { \n            return x;\n        }\n    };\n}\n</code></pre>\n<p>And a lot of types derived from it. They behave identically, but must be distinct, for elsewhere templates need to be specialized on them:</p>\n<pre><code>namespace ns {\n    template &lt;typename T&gt;\n    struct DerivedA : Base&lt;T&gt; {};\n\n    template &lt;typename T&gt;\n    struct DerivedB : Base&lt;T&gt; {};\n\n    template &lt;typename T&gt;\n    struct DerivedC : Base&lt;T&gt; {};\n\n    // etc\n}\n</code></pre>\n<p>When I try to use <code>operator*</code> on a derived class:</p>\n<pre><code>ns::DerivedA&lt;int&gt; d;\n*d = 42;\n</code></pre>\n<p>GCC yells at me \"FOOL! Thou shan't assign <code>int</code> to <code>Dummy</code>!\", which apparently means that free <code>operator*</code> is used instead of the member one in the base class.</p>\n<p>I have no control at all over free operator, and can't move derived classes to different namespace. </p>\n<p>How can I fix this without duplicating <code>operator*</code> in each derived class?</p>\n", "Tags": "<c++><inheritance><operator-overloading><overload-resolution>", "OwnerUserId": "1554020", "AnswerCount": "2"}, "27080014": {"ParentId": "27078793", "CommentCount": "0", "Body": "<p>Short answer, you can do this:</p>\n<pre><code>template &lt;typename T&gt;\nstruct DerivedA : Base&lt;T&gt; {\n    using Base&lt;T&gt;::operator*;\n};\n</code></pre>\n<p>Long answer: in order to figure out what <code>*d</code> to call, we have to determine all the viable functions (\u00a713.3.2): </p>\n<blockquote>\n<p id=\"so_27078793_27080014_0\">From the set of candidate functions constructed for a given context (13.3.1), a set of viable functions is\n  chosen, from which the best function will be selected by comparing argument conversion sequences for the\n  best fit (13.3.3). The selection of viable functions considers relationships between arguments and function\n  parameters other than the ranking of conversion sequences.</p>\n</blockquote>\n<p>There are two:</p>\n<pre><code>template &lt;typename T&gt;\nDummy operator*(T&amp;&amp; );\n\nT&amp; Base::operator*();\n</code></pre>\n<p>In order to figure out which one to pick, we have to determine which \"implicit conversion sequence\" (\u00a713.3.3.1) is better:</p>\n<blockquote>\n<p id=\"so_27078793_27080014_1\">An implicit conversion sequence is a sequence of conversions used to convert an argument in a function call\n  to the type of the corresponding parameter of the function being called.</p>\n</blockquote>\n<p>which for our first option is an \"Exact Match\", and for our second overload option is (\u00a713.3.3.1.6):</p>\n<blockquote>\n<p id=\"so_27078793_27080014_2\">When the parameter has a class type and the argument expression has a derived class type,\n  the implicit conversion sequence is a derived-to-base Conversion from the derived class to the base class.\n  [ <em>Note</em>: There is no such standard conversion; this derived-to-base Conversion exists only in the description of\n  implicit conversion sequences. \u2014<em>end note</em> ] A derived-to-base Conversion has Conversion rank</p>\n</blockquote>\n<p>The ranking of the conversion sequences is (\u00a713.3.3.1.1.3):</p>\n<blockquote>\n<p id=\"so_27078793_27080014_3\">Each conversion in Table 12 also has an associated rank (Exact Match, Promotion, or Conversion). These are\n  used to rank standard conversion sequences (13.3.3.2). The rank of a conversion sequence is determined by\n  considering the rank of each conversion in the sequence and the rank of any reference binding (13.3.3.1.4). If\n  any of those has Conversion rank, the sequence has Conversion rank; otherwise, if any of those has Promotion\n  rank, the sequence has Promotion rank; otherwise, the sequence has Exact Match rank.</p>\n</blockquote>\n<p>I don't know how to insert the table here. But basically we have one \"Exact Match\" (to call <code>Dummy operator*(T&amp;&amp;)</code>) and one \"Conversion\" (to call <code>T&amp; Base::operator*</code>), thus the \"Exact Match\" is the \"best viable function\". And (\u00a713.3.3.2):</p>\n<blockquote>\n<p id=\"so_27078793_27080014_4\">If there is exactly one viable function that is a better function than all other viable functions, then it is the\n  one selected by overload resolution</p>\n</blockquote>\n<p>That's why the <code>Dummy operator*(T&amp;&amp; )</code> is preferred. </p>\n<p>Now, why does my proposal work? In that case, our two options are:</p>\n<pre><code>template &lt;typename T&gt;\nDummy operator*(T&amp;&amp; );\n\nT&amp; DerivedA&lt;int&gt;::operator*();\n</code></pre>\n<p>So we have two \"Exact Match\" candidates - though one of them is through a template and one of the criteria for choose better viable functions is (\u00a713.3.3.1):</p>\n<blockquote>\n<p id=\"so_27078793_27080014_5\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if ...</p>\n<ul>\n<li>F1 is a non-template function and F2 is a function template specialization</li>\n</ul>\n</blockquote>\n<p>Hence, in this case, we pick the <code>DerivedA::operator*</code>. Which is what you want. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "27080014", "Score": "2", "CreationDate": "2014-11-22T16:59:25.347", "LastActivityDate": "2014-11-22T16:59:25.347"}, "bq_ids": {"n4140": {"so_27078793_27080014_5": {"section_id": 603, "quality": 0.9090909090909091, "length": 10}, "so_27078793_27080014_3": {"section_id": 619, "quality": 0.8936170212765957, "length": 42}, "so_27078793_27080014_2": {"section_id": 611, "quality": 0.9142857142857143, "length": 32}, "so_27078793_27080014_0": {"section_id": 600, "quality": 0.8947368421052632, "length": 34}, "so_27078793_27080014_1": {"section_id": 606, "quality": 0.9333333333333333, "length": 14}, "so_27078793_27080014_4": {"section_id": 604, "quality": 1.0, "length": 17}}, "n3337": {"so_27078793_27080014_5": {"section_id": 593, "quality": 0.9090909090909091, "length": 10}, "so_27078793_27080014_3": {"section_id": 609, "quality": 0.8936170212765957, "length": 42}, "so_27078793_27080014_2": {"section_id": 601, "quality": 0.9142857142857143, "length": 32}, "so_27078793_27080014_0": {"section_id": 590, "quality": 0.8947368421052632, "length": 34}, "so_27078793_27080014_1": {"section_id": 596, "quality": 0.9333333333333333, "length": 14}, "so_27078793_27080014_4": {"section_id": 594, "quality": 1.0, "length": 17}}, "n4659": {"so_27078793_27080014_5": {"section_id": 629, "quality": 0.9090909090909091, "length": 10}, "so_27078793_27080014_3": {"section_id": 645, "quality": 0.8936170212765957, "length": 42}, "so_27078793_27080014_4": {"section_id": 630, "quality": 1.0, "length": 17}, "so_27078793_27080014_0": {"section_id": 626, "quality": 0.8947368421052632, "length": 34}, "so_27078793_27080014_1": {"section_id": 632, "quality": 0.9333333333333333, "length": 14}, "so_27078793_27080014_2": {"section_id": 637, "quality": 0.9142857142857143, "length": 32}}}, "27080115": {"ParentId": "27078793", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_27078793_27080115_0\">I have no control at all over free operator, and can't move derived classes to different namespace.</p>\n</blockquote>\n<p>If you cannot move the derived classes to a different namespace from the user's perspective but <em>can</em> move them in the code itself, you can do this:</p>\n<pre><code> namespace ns {\n   namespace ns_ {\n     template &lt;typename T&gt;\n     struct Base {\n       T x;\n\n       T&amp; operator*() { return x; }\n     };\n\n     template &lt;typename T&gt;\n     struct DerivedA : Base&lt;T&gt; {};\n   }\n\n   using namespace ns_;\n }\n</code></pre>\n", "OwnerUserId": "19093", "PostTypeId": "2", "Id": "27080115", "Score": "0", "CreationDate": "2014-11-22T17:09:49.370", "LastActivityDate": "2014-11-22T17:09:49.370"}});