post_cb({"34935792": {"ParentId": "34935618", "CommentCount": "2", "Body": "<p>Basically, it's just that the syntax <code>&amp;A::x</code> (without variation) has been chosen to mean pointer-to-member.</p>\n<p>If you write, for example, <code>&amp;(A::x)</code>, you will get the plain pointer you expect.</p>\n<p>More information on pointers-to-members, including a note about this very property, can be found <a href=\"http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_non-static_member_objects\">here</a>.</p>\n", "OwnerUserId": "3233393", "PostTypeId": "2", "Id": "34935792", "Score": "8", "CreationDate": "2016-01-21T22:44:07.953", "LastActivityDate": "2016-01-21T22:44:07.953"}, "34936548": {"ParentId": "34935618", "LastEditDate": "2016-07-25T14:51:11.280", "CommentCount": "0", "CreationDate": "2016-01-21T23:43:55.600", "OwnerUserId": "1639256", "LastEditorUserId": "1639256", "PostTypeId": "2", "Id": "34936548", "Score": "3", "Body": "<p>The C++ standard doesn't explicitly specify operator precedence; it's possible to deduce operator precedence implicitly from the grammar rules, but this approach fails to appreciate the occasional special case like this which doesn't fit into a traditional model of operator precedence.</p>\n<p>[expr.unary.op]/3:</p>\n<blockquote>\n<p id=\"so_34935618_34936548_0\">The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>. If the operand is a\n  <em>qualified-id</em> naming a non-static or variant member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type 'pointer to member of class <code>C</code> of type\n  <code>T</code>' and is a prvalue designating <code>C::m</code>. Otherwise, if the type of the expression is <code>T</code>, the result has type 'pointer to <code>T</code>' and is a prvalue that is the address of the designated object or a pointer to the designated function.</p>\n</blockquote>\n<p>/4:</p>\n<blockquote>\n<p id=\"so_34935618_34936548_1\">A pointer to member is only formed when an explicit <code>&amp;</code> is used and its operand is a <em>qualified-id</em> not enclosed in parentheses. [ <em>Note:</em>\n  that is, the expression <code>&amp;(qualified-id)</code>, where the <em>qualified-id</em> is enclosed in parentheses, does not form an expression of type 'pointer to member'.</p>\n</blockquote>\n<p>[expr.prim.general]/9:</p>\n<blockquote>\n<p id=\"so_34935618_34936548_2\">A <em>nested-name-specifier</em> that denotes a class, optionally followed by the keyword <code>template</code>, and then followed by the name of a member of either that class or one of its base classes, is a <em>qualified-id</em>.</p>\n</blockquote>\n<p>What it all adds up to is that an expression of the form <code>&amp;A::x</code> has the type \"pointer to member <code>x</code> of class <code>A</code>\" if <code>x</code> is a non-static member of a non-union class <code>A</code>, and operator precedence has no influence on this.</p>\n", "LastActivityDate": "2016-07-25T14:51:11.280"}, "bq_ids": {"n4140": {"so_34935618_34936548_0": {"section_id": 6066, "quality": 0.926829268292683, "length": 38}, "so_34935618_34936548_2": {"section_id": 5955, "quality": 1.0, "length": 18}, "so_34935618_34936548_1": {"section_id": 6067, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_34935618_34936548_0": {"section_id": 5834, "quality": 0.926829268292683, "length": 38}, "so_34935618_34936548_2": {"section_id": 5724, "quality": 1.0, "length": 18}, "so_34935618_34936548_1": {"section_id": 5835, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_34935618_34936548_0": {"section_id": 7562, "quality": 0.9512195121951219, "length": 39}, "so_34935618_34936548_2": {"section_id": 7443, "quality": 1.0, "length": 18}, "so_34935618_34936548_1": {"section_id": 7563, "quality": 0.9130434782608695, "length": 21}}}, "34935618": {"CommentCount": "0", "ViewCount": "163", "PostTypeId": "1", "LastEditorUserId": "3348786", "CreationDate": "2016-01-21T22:30:57.887", "LastActivityDate": "2016-07-25T14:51:11.280", "Title": "Pointer-to-member confusion", "AcceptedAnswerId": "34936548", "LastEditDate": "2016-01-21T22:45:28.350", "Id": "34935618", "Score": "7", "Body": "<p>I'm trying to understand the consistency in the error that is thrown in this program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A{\npublic:\n    void test();\n    int x = 10;\n\n};\n\nvoid A::test(){\n\n    std::cout &lt;&lt; x &lt;&lt; std::endl; //(1)\n    std::cout &lt;&lt; A::x &lt;&lt; std::endl; //(2)\n\n    int* p = &amp;x;\n    //int* q = &amp;A::x; //error: cannot convert 'int A::*' to 'int*' in initialization| //(3)\n\n\n}\n\nint main(){\n\n    const int A::* a = &amp;A::x; //(4)\n\n    A b;\n\n    b.test();\n\n}\n</code></pre>\n<p>The output is <code>10 10</code>. I labelled 4 points of the program, but (3) is my biggest concern:</p>\n<ol>\n<li><code>x</code> is fetched normally from inside a member function.</li>\n<li><code>x</code> of the object is fetched using the scope operator and an lvalue to the object <code>x</code> is returned.</li>\n<li>Given <code>A::x</code> returned an <code>int</code> lvalue in (2), why then does <code>&amp;A::x</code> return not <code>int*</code> but instead returns <code>int A::*</code>? The scope operator even takes precedence before the <code>&amp;</code> operator so <code>A::x</code> should be run first, returning an <code>int</code> lvalue, before the address is taken. i.e. this should be the same as <code>&amp;(A::x)</code> surely? (Adding parentheses does actually work by the way). </li>\n<li>A little different here of course, the scope operator referring to a class member but with no object to which is refers. </li>\n</ol>\n<p>So why exactly does <code>A::x</code> not return the address of the object <code>x</code> but instead returns the address of the member, ignoring precedence of <code>::</code> before <code>&amp;</code>?</p>\n", "Tags": "<c++><c++11><pointer-to-member>", "OwnerUserId": "3348786", "AnswerCount": "2"}});