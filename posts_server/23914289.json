post_cb({"bq_ids": {"n4140": {"so_23914289_23915503_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 481}, "so_23914289_23915503_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 5952}}, "n3337": {"so_23914289_23915503_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 5722}}, "n4659": {"so_23914289_23915503_0": {"length": 23, "quality": 0.6388888888888888, "section_id": 7438}, "so_23914289_23915503_1": {"length": 30, "quality": 0.7142857142857143, "section_id": 504}}}, "23915503": {"Id": "23915503", "PostTypeId": "2", "Body": "<p>In most cases there is no difference in writing <code>a</code> or <code>(a)</code>. The relevant part of the spec is \u00a75.1p6 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_23914289_23915503_0\">A parenthesized expression is a primary expression whose type and value are identical to those of the enclosed expression. The presence of parentheses does not affect whether the expression is an lvalue. The parenthesized expression can be used in exactly the same contexts as those where the enclosed expression can be used, and with the <strong>same meaning</strong>, except as otherwise indicated.</p>\n</blockquote>\n<p>Hence, the same reasoning applies to the return value of your function <code>g</code> as you have given for <code>f</code>.</p>\n<hr>\n<p>In the upcomming standard C++14 this has been clarified \u00a712.8p32 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_23914289_23915503_1\">When the criteria for elision of a copy/move operation are met, but not for an exception-declaration, and the object to be copied is designated by an lvalue, or when the expression in a return statement is a (<strong>possibly parenthesized</strong>) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n<hr>\n<p>For those who want to know, when the parentheses matter, here is an example:</p>\n<pre><code>namespace N {\nstruct S { };\n\n  void f(S);\n\n}\n\nvoid g() {\n  N::S s;\n  f(s); // OK: calls N::f\n  (f)(s); // error: N::f not considered; parentheses\n          // prevent argument-dependent lookup\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "1770418", "LastActivityDate": "2014-05-28T15:43:18.803", "Score": "11", "CreationDate": "2014-05-28T15:13:25.450", "ParentId": "23914289", "CommentCount": "0", "OwnerUserId": "1770418", "LastEditDate": "2014-05-28T15:43:18.803"}, "33639368": {"Id": "33639368", "PostTypeId": "2", "Body": "<p>Note that if you declare</p>\n<pre><code>const A a;\n</code></pre>\n<p>in your examples, they will all copy.\nSection 12.8 of the standard says \"overload resolution\nto select the constructor for the copy is first performed as if the object were designated by an rvalue,\" but if a is const, that will be a const rvalue, which doesn't match the move constructor.</p>\n", "LastActivityDate": "2015-11-10T20:51:05.323", "CommentCount": "0", "CreationDate": "2015-11-10T20:51:05.323", "ParentId": "23914289", "Score": "0", "OwnerUserId": "198621"}, "23914289": {"ViewCount": "422", "Body": "<p>After reading this <a href=\"https://stackoverflow.com/questions/11914691/copy-elision-move-constructor-not-called-when-using-ternary-expression-in-retur\">question</a>. I created this small little test:</p>\n<pre><code>class A{\npublic:\n    A(){}\n    A(const A&amp;){printf(\"copy\\n\");}\n    A(A&amp;&amp;){printf(\"move\\n\");}\n\n    static A f(){\n        A a;\n        return a;}\n\n    static A g(){\n        A a;\n        return (a);}//could be return *&amp;a; too.\n\n    static A h(){\n        A a;\n        return true?a:a;}\n\n };\n</code></pre>\n<p>The result is (without RVO and NRVO):</p>\n<ul>\n<li>f uses move</li>\n<li>g uses move</li>\n<li>h uses copy</li>\n</ul>\n<p>As far as I  know the rules used to decide whether to use copy or move are described in 12.8.32:</p>\n<ul>\n<li>When <strong>the criteria for elision of a copy operation are met</strong> or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. ...</li>\n</ul>\n<p>Which refers to the rules of 12.8.31: (I only show the relevant part)</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is <strong>the name of a non-volatile automatic object</strong> (other than a function or catch-clause parameter) with the same cvunqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</li>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\nto a class object with the same cv-unqualified type, the copy/move operation can be omitted by\nconstructing the temporary object directly into the target of the omitted copy/move</li>\n</ul>\n<p>Following these rules I understand what happens for f and h:</p>\n<ul>\n<li>The copy in f is eligible for elision so it is moved. (cf. the bold part) </li>\n<li>The copy in h is not eligible for elision so it is copied.</li>\n</ul>\n<p><strong>What about g?</strong></p>\n<p>To me it looks really like h. I am returning an expression which is not the name of an automatic object and as such I thought it would be copied however it is moved. What is going on here? </p>\n", "AcceptedAnswerId": "23915503", "Title": "When does returning a value outside of a function uses move vs copy?", "CreationDate": "2014-05-28T14:21:23.577", "Id": "23914289", "CommentCount": "9", "LastEditDate": "2017-05-23T11:59:02.380", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-10T20:51:05.323", "Score": "8", "OwnerUserId": "1824274", "Tags": "<c++><c++11><copy><return><move>", "AnswerCount": "2"}});