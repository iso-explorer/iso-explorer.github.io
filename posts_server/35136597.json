post_cb({"bq_ids": {"n4140": {"so_35136597_35136597_0": {"length": 66, "quality": 0.6947368421052632, "section_id": 6009}, "so_35136597_35136597_1": {"length": 65, "quality": 0.9154929577464789, "section_id": 6173}, "so_35136597_35136597_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6173}}, "n3337": {"so_35136597_35136597_0": {"length": 66, "quality": 0.6947368421052632, "section_id": 5777}, "so_35136597_35136597_1": {"length": 65, "quality": 0.9154929577464789, "section_id": 5934}, "so_35136597_35136597_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5934}}, "n4659": {"so_35136597_35136597_0": {"length": 77, "quality": 0.8105263157894737, "section_id": 7508}, "so_35136597_35136597_1": {"length": 65, "quality": 0.9154929577464789, "section_id": 7675}, "so_35136597_35136597_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7675}}}, "35136597": {"ViewCount": "142", "Body": "<p>From <a href=\"http://eel.is/c++draft/expr.post.incr#1\" rel=\"nofollow\">\u00a75.2.6/1</a> we have (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_35136597_35136597_0\">The value of a postfix ++ expression is the value of its operand. [\n  Note: the value obtained is a copy of the original value  \u2014 end note ]\n  The operand shall be a modifiable lvalue. The type of the operand\n  shall be an arithmetic type other than cv bool, or a pointer to a\n  complete object type. The value of the operand object is modified by\n  adding 1 to it. <strong>The value computation of the ++ expression is\n  sequenced before the modification of the operand object</strong>. With\n  respect to an indeterminately-sequenced function call, the operation\n  of postfix ++ is a single evaluation. [ Note: Therefore, a function\n  call shall not intervene between the lvalue-to-rvalue conversion and\n  the side effect associated with any single postfix ++ operator.  \u2014 end\n  note ] The result is a prvalue. The type of the result is the\n  cv-unqualified version of the type of the operand. If the operand is a\n  bit-field that cannot represent the incremented value, the resulting\n  value of the bit-field is implementation-defined. See also [expr.add]\n  and [expr.ass].</p>\n</blockquote>\n<p>That is, the modification of the operand object is <strong>sequenced after</strong> the value computation of the <code>++</code> expression.</p>\n<p>From <a href=\"http://eel.is/c++draft/expr.ass#1\" rel=\"nofollow\">\u00a75.18/1</a> we have (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_35136597_35136597_1\">The assignment operator (=) and the compound assignment operators all\n  group right-to-left. All require a modifiable lvalue as their left\n  operand and return an lvalue referring to the left operand. The result\n  in all cases is a bit-field if the left operand is a bit-field. In all\n  cases, <strong>the assignment is sequenced after the value computation of\n  the right and left operands</strong>, and before the value computation of the\n  assignment expression. With respect to an indeterminately-sequenced\n  function call, the operation of a compound assignment is a single\n  evaluation. [ Note: Therefore, a function call shall not intervene\n  between the lvalue-to-rvalue conversion and the side effect associated\n  with any single compound assignment operator.  \u2014 end note ]</p>\n<p id=\"so_35136597_35136597_2\"><em>assignment-expression</em>:<br>\n      \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>conditional-expression</em><br>\n      \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>logical-or-expression</em> <em>assignment-operator</em> <em>initializer-clause</em><br>\n      \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>throw-expression</em></br></br></br></p>\n<p id=\"so_35136597_35136597_3\"><em>assignment-operator</em>: one of<br>\n      \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0=  *=  /=  %=   +=  -=  &gt;&gt;=  &lt;&lt;=  &amp;=  ^=  |=</br></p>\n</blockquote>\n<p>The assignment is also <strong>sequenced after</strong> the value computation of the right and left operands of the assignment operator.</p>\n<p>Thus, if we consider the expression</p>\n<pre><code>i = i++;\n</code></pre>\n<p>we know from \u00a75.2.6/1 that the side effect of the expression <code>i++</code>, on the RHS of this assignment expression is sequenced after the value computation of <code>i++</code>. And from \u00a75.18/1 we know that the side effect corresponding to the assignment to <code>i</code> on the LHS of the assignment operator is sequenced after the value computation of the right and left operands of the assignment operator.</p>\n<p>But how do I show that these two side effects are unsequenced, in order to prove that the expression <code>i = i++;</code> shows undefined behavior? </p>\n", "Title": "How to determine if two side effects on a assignment are unsequenced?", "CreationDate": "2016-02-01T17:25:17.660", "LastActivityDate": "2016-02-01T18:33:57.630", "CommentCount": "12", "PostTypeId": "1", "Id": "35136597", "Score": "3", "OwnerUserId": "1042389", "Tags": "<c++><language-lawyer><c++1z><partial-ordering>", "AnswerCount": "1"}, "35137787": {"Id": "35137787", "PostTypeId": "2", "Body": "<p>First, if A is not sequenced before B and B is not sequenced before A, then A and B are <em>unsequenced</em> (1.9/13). That's the <strong>definition</strong> of unsequenced. Second, if two side effects on a scalar object are unsequenced, the behavior is undefined (1.9/15). So unless you can find something that says that the post-increment and the assignment are sequenced (and you won't), the behavior is undefined.</p>\n", "LastActivityDate": "2016-02-01T18:33:57.630", "Score": "6", "CreationDate": "2016-02-01T18:33:57.630", "ParentId": "35136597", "CommentCount": "5", "OwnerUserId": "1593860"}});