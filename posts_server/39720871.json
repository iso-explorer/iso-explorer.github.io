post_cb({"39720871": {"CommentCount": "3", "ViewCount": "83", "CreationDate": "2016-09-27T09:22:03.787", "LastActivityDate": "2016-09-27T10:35:10.027", "Title": "What`s result of converting char* to int*", "PostTypeId": "1", "Id": "39720871", "Score": "0", "Body": "<p>The code is below\uff1a</p>\n<pre><code>int main(void) {\n    char* str = \"12345678\";\n    int* in = (int*)str;\n    printf(\"%d\\n%d\\n\", in[0], in[1]);\n    return 0;\n}\n</code></pre>\n<p>What is result? Why?</p>\n", "Tags": "<c++>", "OwnerUserId": "5943721", "AnswerCount": "3"}, "39721566": {"ParentId": "39720871", "CommentCount": "0", "CreationDate": "2016-09-27T09:52:53.280", "OwnerUserId": "771073", "PostTypeId": "2", "Id": "39721566", "Score": "0", "Body": "<p>The result is <em>undefined behaviour</em>, which <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">n4296</a> (the final draft of C++ 14) defines as </p>\n<blockquote>\n<p id=\"so_39720871_39721566_0\">behavior for which this International Standard imposes no requirements</p>\n</blockquote>\n<p><em>Anything</em> can happen.  Seg fault, hard drive wiped, etc.  A quite plausible result is that the ASCII characters \"1234\" are treated as the bytes of a four byte little endian integer, and the resulting number printed out (and similarly for \"5678\") - but don't rely on this.</p>\n", "LastActivityDate": "2016-09-27T09:52:53.280"}, "39722242": {"ParentId": "39720871", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-09-27T10:25:53.203", "Score": "1", "LastEditorUserId": "3769687", "LastEditDate": "2016-09-27T10:35:10.027", "Id": "39722242", "OwnerUserId": "3769687", "Body": "<p>The answer is (for my system)</p>\n<pre><code>875770417\n943142453\n</code></pre>\n<p>Here goes the reason :\nstr points to \"12345678\". In my system int is 4 bytes. So *in points to \"1234\" and *in+1 points to \"5678\".\nInside the memory char is stored in binary form. </p>\n<p>Now lets have look at in[0]. in[0] would evaluate \"1234\". The memory representation would be this (in binary):    </p>\n<pre><code>00110001 00110010 00110011 00110100\n</code></pre>\n<p>(These are ascii values for 1, 2, 3, 4 which are - 49, 50, 51, 52)</p>\n<p>Now as you have assigned char to int, now the compiler will load the about 32 bits as one word. Depending upon <strong>BIG ENDIAN or LITTLE ENDIAN</strong> evaluation will happen. My system is LITTLE ENDIAN.\nSo my evaluation happened this way - </p>\n<pre><code> 52*(2^24) + 51*(2^16) + 50*(2^8) + 49 = 8775770417\n</code></pre>\n<p>Similar interpretation for in[1]. Hope this clears things.</p>\n", "LastActivityDate": "2016-09-27T10:35:10.027"}, "bq_ids": {"n4140": {"so_39720871_39721564_2": {"section_id": 6046, "quality": 0.9772727272727273, "length": 43}, "so_39720871_39721566_0": {"section_id": 5768, "quality": 0.8, "length": 4}}, "n3337": {"so_39720871_39721564_2": {"section_id": 5814, "quality": 0.8863636363636364, "length": 39}, "so_39720871_39721566_0": {"section_id": 5541, "quality": 0.8, "length": 4}}, "n4659": {"so_39720871_39721564_2": {"section_id": 7545, "quality": 0.9772727272727273, "length": 43}, "so_39720871_39721566_0": {"section_id": 7225, "quality": 0.8, "length": 4}}}, "39721564": {"ParentId": "39720871", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-09-27T09:52:48.447", "Score": "1", "LastEditorUserId": "2015579", "LastEditDate": "2016-09-27T10:00:37.463", "Id": "39721564", "OwnerUserId": "2015579", "Body": "<blockquote>\n<p id=\"so_39720871_39721564_0\">What is result? </p>\n</blockquote>\n<p>Implementation defined. </p>\n<blockquote>\n<p id=\"so_39720871_39721564_1\">Why?</p>\n</blockquote>\n<p>Because the standard says so.</p>\n<p>\u00a75.2.10.7</p>\n<blockquote>\n<p id=\"so_39720871_39721564_2\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of\n  object pointer type is converted to the object pointer type \u201cpointer to cv T\u201d, the result is static_cast(static_cast(v)). Converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to\n  T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than\n  those of T1) and back to its original type yields the original pointer value.</p>\n</blockquote>\n<p>BTW, this is illegal in c++: <code>char* str = \"12345678\";</code> as string literals are const. To be correct it should be: <code>const char* str = \"12345678\";</code></p>\n", "LastActivityDate": "2016-09-27T10:00:37.463"}});