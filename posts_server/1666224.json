post_cb({"1666350": {"Id": "1666350", "PostTypeId": "2", "Body": "<p>To the 2nd part of the question: Note that sizeof(void *)!= sizeof(void).\n On a 32-bit arch, sizeof(void *) is 4 bytes, so p++, would be set accordingly.The amount by which a pointer is incremented is dependent on the data it is pointing to. So, it will be increased by 1 byte.</p>\n", "LastEditorDisplayName": "user59634", "OwnerDisplayName": "user59634", "LastActivityDate": "2009-11-03T10:32:59.357", "Score": "0", "CreationDate": "2009-11-03T09:57:19.360", "ParentId": "1666224", "CommentCount": "5", "LastEditDate": "2009-11-03T10:32:59.357"}, "bq_ids": {"n4140": {"so_1666224_28259072_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 6076}}, "n3337": {"so_1666224_28259072_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 5844}}, "n4659": {"so_1666224_28259072_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 7572}}}, "1666247": {"Id": "1666247", "PostTypeId": "2", "Body": "<p>Although <code>void</code> may stand in place for a type, it cannot actually hold a value. Therefore, it has no size in memory. Getting the size of a <code>void</code> isn\u2019t defined.</p>\n<p>A <code>void</code> <em>pointer</em> is simply a language construct meaning a pointer to <em>untyped</em> memory.</p>\n", "LastActivityDate": "2009-11-03T09:33:44.337", "CommentCount": "3", "CreationDate": "2009-11-03T09:33:44.337", "ParentId": "1666224", "Score": "14", "OwnerUserId": "1968"}, "15543775": {"Id": "15543775", "PostTypeId": "2", "Body": "<p>Most C++ compilers choosed to raise a compile error when trying to get <code>sizeof(void)</code>. </p>\n<p>When compiling C, gcc is not conforming and chose to define <code>sizeof(void)</code> as 1. It may look strange, but has a rationale. When you do pointer arithmetic adding or removing one unit means adding or removing the object pointed to size. Thus defining <code>sizeof(void)</code> as 1 helps defining <code>void*</code> as a pointer to byte (untyped memory address). Otherwise you would have surprising behaviors using pointer arithmetic like <code>p+1 == p when</code> p is <code>void*</code>. Such pointer arithmetic on void pointers is not allowed in c++ but works fine with when compiling C with gcc.</p>\n<p>The standard recommended way would be to use <code>char*</code> for that kind of purpose (pointer to byte).</p>\n<p>Another similar difference between C and C++ when using sizeof occurs when you defined an empty struct like:</p>\n<pre><code>struct Empty {\n} empty;\n</code></pre>\n<p>Using gcc as my C compiler <code>sizeof(empty)</code> returns 0.\nUsing g++ the same code will return 1.</p>\n<p>I'm not sure what states both C and C++ standards on this point, but I believe defining the size of some empty structs/objects helps with reference management to avoid that two references to differing consecutive objects, the first one being empty, get the same address. If reference are implemented using hidden pointers as it is often done, ensuring different address will help comparing them. </p>\n<p>But this is merely avoiding a surprising behavior (corner case comparison of references) by introduction another one (empty objects, even PODs consume at least 1 byte memory).</p>\n", "LastEditorUserId": "168465", "LastActivityDate": "2013-03-21T12:32:46.073", "Score": "-1", "CreationDate": "2013-03-21T09:34:36.400", "ParentId": "1666224", "CommentCount": "3", "OwnerUserId": "168465", "LastEditDate": "2013-03-21T12:32:46.073"}, "1666224": {"ViewCount": "39854", "Body": "<p>What would this statement yield?</p>\n<pre><code>void * p = (void*) malloc(sizeof(void));\n</code></pre>\n<hr>\n<p>Edit: An extension to the question. </p>\n<p>If sizeof(void) yields 1 in GCC compiler, then 1 byte of memory is allocated and the pointer p points to that byte and would p++ be incremented to 0x2346? Suppose p was 0x2345. I am talking about p and not *p.</p>\n</hr>", "AcceptedAnswerId": "1666232", "Title": "What is the size of void?", "CreationDate": "2009-11-03T09:30:11.360", "Id": "1666224", "CommentCount": "3", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2009-11-03T10:44:50.877", "LastEditorUserId": "63550", "LastActivityDate": "2015-02-01T03:17:20.860", "Score": "58", "OwnerUserId": "40236", "Tags": "<c++><c>", "AnswerCount": "10"}, "1666232": {"Id": "1666232", "PostTypeId": "2", "Body": "<p>The type <code>void</code> has no size; that would be a compilation error. For the same reason you can't do something like:</p>\n<pre><code>void n;\n</code></pre>\n<p>EDIT.\nTo my surprise, doing <code>sizeof(void)</code> actually <em>does</em> compile in GNU C:</p>\n<pre><code>$ echo 'int main() { printf(\"%d\", sizeof(void)); }' | gcc -xc -w - &amp;&amp; ./a.out \n1\n</code></pre>\n<p>However, in C++ it does not:</p>\n<pre><code>$ echo 'int main() { printf(\"%d\", sizeof(void)); }' | gcc -xc++ -w - &amp;&amp; ./a.out \n&lt;stdin&gt;: In function 'int main()':\n&lt;stdin&gt;:1: error: invalid application of 'sizeof' to a void type\n&lt;stdin&gt;:1: error: 'printf' was not declared in this scope\n</code></pre>\n", "LastEditorUserId": "15168", "LastActivityDate": "2015-02-01T03:10:56.163", "Score": "41", "CreationDate": "2009-11-03T09:31:42.357", "ParentId": "1666224", "CommentCount": "6", "OwnerUserId": "197368", "LastEditDate": "2015-02-01T03:10:56.163"}, "1666266": {"Id": "1666266", "PostTypeId": "2", "Body": "<p>Taking the size of void is a <a href=\"http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc_4.html#SEC78\" rel=\"noreferrer\">GCC extension</a>.</p>\n", "LastActivityDate": "2009-11-03T09:39:02.043", "CommentCount": "0", "CreationDate": "2009-11-03T09:39:02.043", "ParentId": "1666224", "Score": "9", "OwnerUserId": "25324"}, "1666243": {"Id": "1666243", "PostTypeId": "2", "Body": "<p>In C, <code>sizeof(void) == 1</code> in GCC, but this appears to depend on your compiler.</p>\n<p>In C++, I get:</p>\n<pre>\nIn function 'int main()':\nLine 2: error: invalid application of 'sizeof' to a void type\ncompilation terminated due to -Wfatal-errors.\n</pre>\n", "LastEditorUserId": "893", "LastActivityDate": "2009-11-03T09:48:07.587", "Score": "3", "CreationDate": "2009-11-03T09:33:27.937", "ParentId": "1666224", "CommentCount": "3", "OwnerUserId": "893", "LastEditDate": "2009-11-03T09:48:07.587"}, "1666255": {"Id": "1666255", "PostTypeId": "2", "Body": "<p>If you are using GCC and you are not using compilation flags that remove compiler specific extensions, then <code>sizeof(void)</code> is 1. GCC has a <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Pointer-Arith.html#Pointer-Arith\" rel=\"noreferrer\">nonstandard extension</a> that does that.</p>\n<p>In general, <code>void</code> is a incomplete type, and you cannot use sizeof for incomplete types.</p>\n", "LastActivityDate": "2009-11-03T09:35:35.800", "CommentCount": "4", "CreationDate": "2009-11-03T09:35:35.800", "ParentId": "1666224", "Score": "34", "OwnerUserId": "120471"}, "8173452": {"Id": "8173452", "PostTypeId": "2", "Body": "<p>while sizeof(void) perhaps makes no sense in itself, it is important when you're doing any pointer math.</p>\n<p>eg.</p>\n<pre><code> void *p;\n while(...)\n      p++;\n</code></pre>\n<p>If sizeof(void) is considered 1 then this will work.\nIf sizeof(void) is considered 0 then you hit an infinite loop.</p>\n", "LastActivityDate": "2011-11-17T19:59:03.910", "CommentCount": "2", "CreationDate": "2011-11-17T19:59:03.910", "ParentId": "1666224", "Score": "-1", "OwnerUserId": "906752"}, "1666249": {"Id": "1666249", "PostTypeId": "2", "Body": "<p><code>sizeof()</code> cannot be applied to incomplete types. And <code>void</code> is incomplete type that cannot be completed.</p>\n", "LastActivityDate": "2009-11-03T09:34:13.147", "CommentCount": "0", "CreationDate": "2009-11-03T09:34:13.147", "ParentId": "1666224", "Score": "5", "OwnerUserId": "168727"}, "28259072": {"Id": "28259072", "PostTypeId": "2", "Body": "<p><code>void</code> has no size. In both C and C++, the expression <code>sizeof (void)</code> is invalid.</p>\n<p>In C, quoting <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"noreferrer\">N1570</a> 6.5.3.4 paragraph 1:</p>\n<blockquote>\n<p id=\"so_1666224_28259072_0\">The <strong><code>sizeof</code></strong> operator shall not be applied to an expression that\n  has function type <em>or an incomplete type</em>, to the parenthesized name of\n  such a type, or to an expression that designates a bit-field member.</p>\n</blockquote>\n<p>(N1570 is a draft of the 2011 ISO C standard.)</p>\n<p><code>void</code> is an incomplete type. This paragraph is a <em>constraint</em>, meaning that any conforming C compiler must diagnose any violation of it. (The diagnostic message may be a non-fatal warning.)</p>\n<p>The C++ 11 standard has very similar wording. Both editions were published after this question was asked, but the rules go back to the 1989 ANSI C standard and the earliest C++ standards. In fact, the rule that <code>void</code> is an incomplete type to which <code>sizeof</code> may not be applied goes back exactly as far as the introduction of <code>void</code> into the language.</p>\n<p>gcc has an <em>extension</em> that treats <code>sizeof (void)</code> as 1. gcc is not a conforming C compiler by default, so in its default mode it doesn't warn about <code>sizeof (void)</code>. Extensions like this are permitted even for fully conforming C compilers, but the diagnostic is still required.</p>\n", "LastActivityDate": "2015-02-01T03:17:20.860", "CommentCount": "2", "CreationDate": "2015-02-01T03:17:20.860", "ParentId": "1666224", "Score": "6", "OwnerUserId": "827263"}});