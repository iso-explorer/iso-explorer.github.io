post_cb({"bq_ids": {"n4140": {"so_43129165_43129235_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_43129165_43129165_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 5992}}, "n3337": {"so_43129165_43129235_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_43129165_43129165_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 5760}}, "n4659": {"so_43129165_43129235_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_43129165_43129165_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 7494}}}, "43129165": {"ViewCount": "109", "Body": "<p>I had a discussion with one programmer, and its main point was that the following assertion in <code>foo</code> can be passed or not, depending on compiler. </p>\n<pre><code>#include &lt;cassert&gt; \n\nconst int i = 0 ; \n\nvoid foo ( const int&amp; i ) \n{  \n    assert( &amp;::i == &amp;i ) ; \n} \n\nint main ( ) \n{ \n    foo( i ) ; \n} \n</code></pre>\n<p>he told me, that (&amp;i) expression can be evaluated to address of some temporary object. \nsince i have doubts, i'm here.\nhow reference to temp can be passed to a function, if in function I can check and do whatever I want with i's and parameter's addresses and expected semantics must be kept.? for example </p>\n<pre><code>#include &lt;initializer_list&gt;\n\nconst int i = 0 ;\n\nbool func ( const int &amp; i ) \n{ \n    return &amp;::i == &amp; i ; \n}\n\nint main ()\n{\n    const int i = 0 ;\n    for ( const int * each : { &amp;::i , &amp;i , } )\n         if ( func( * each ) ) break ; // etc\n}\n</code></pre>\n<p>probably such thing can occur somewhere, but not for this case.\nthat is how i think, but i cannot get complete proof from standard.</p>\n<p>what i have found already (thanks to <a href=\"https://stackoverflow.com/users/3484570/nwp\">npw</a>) :</p>\n<p>from [<a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.call#5\" rel=\"nofollow noreferrer\">expr.call#5</a>] :</p>\n<blockquote>\n<p id=\"so_43129165_43129165_0\">Where a parameter is of const reference type a temporary object is\n  introduced if needed ([dcl.type], [lex.literal], [lex.string],\n  [dcl.array], [class.temporary])</p>\n</blockquote>\n<p>first four references are not applicable to my case, but fifth gives a hope. </p>\n<p>so my question is : does standard give guaranties, that assertion in <code>foo</code> will be hold.?</p>\n", "AcceptedAnswerId": "43129235", "Title": "(&const_object) can be evaluated to address of temporary", "CreationDate": "2017-03-30T22:05:28.257", "Id": "43129165", "CommentCount": "0", "LastEditDate": "2017-05-23T12:09:41.573", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-30T22:32:28.700", "Score": "5", "OwnerUserId": "4625005", "Tags": "<c++><const><language-lawyer>", "AnswerCount": "1"}, "43129235": {"Id": "43129235", "PostTypeId": "2", "Body": "<p>In the first code sample, the <code>&amp;::i == &amp;i</code> condition is always true.  A reference of type <code>const int&amp;</code> binds directly to an object of type <code>const int</code>.  There is no temporary object created.</p>\n<p>C++14 [dcl.init.ref]/5:</p>\n<blockquote>\n<p id=\"so_43129165_43129235_0\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:</p>\n<ul>\n<li>If the reference is an lvalue reference and the initializer expression\n  \n  <ul>\n<li>is an lvalue (but is not a bit-field), and \u201c cv1 T1\u201d is reference-compatible with \u201c cv2 T2,\u201d or</li>\n<li>[...],\n  then the reference is bound to the initializer expression lvalue in the first case  [...]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>A type is reference-compatible with itself.</p>\n<p>The second example is similar: certainly, initializing a pointer with the address of an object does not create a temporary. It points to the object.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2017-03-30T22:32:28.700", "Score": "6", "CreationDate": "2017-03-30T22:10:39.650", "ParentId": "43129165", "CommentCount": "4", "OwnerUserId": "1505939", "LastEditDate": "2017-03-30T22:32:28.700"}});