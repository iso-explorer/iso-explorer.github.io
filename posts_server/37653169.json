post_cb({"bq_ids": {"n4140": {"so_37653169_37653472_0": {"length": 51, "quality": 0.9107142857142857, "section_id": 6067}}, "n3337": {"so_37653169_37653472_0": {"length": 51, "quality": 0.9107142857142857, "section_id": 5835}}, "n4659": {"so_37653169_37653472_0": {"length": 51, "quality": 0.9107142857142857, "section_id": 7563}}}, "37653472": {"Id": "37653472", "PostTypeId": "2", "Body": "<p>\u00a7 5.3.1 <a href=\"http://eel.is/c++draft/expr.unary.op#4\" rel=\"nofollow\">[expr.unary.op]</a>/p4:</p>\n<blockquote>\n<p id=\"so_37653169_37653472_0\">A pointer to member is only formed when an explicit <code>&amp;</code> is used and its operand is a <a href=\"http://eel.is/c++draft/expr.prim.id.qual#qualified-id\" rel=\"nofollow\"><em>qualified-id</em></a> not enclosed\n  in parentheses. [ <em>Note:</em> that is, the expression <code>&amp;(qualified-id)</code>, where the <a href=\"http://eel.is/c++draft/expr.prim.id.qual#qualified-id\" rel=\"nofollow\"><em>qualified-id</em></a> is enclosed in\n  parentheses, does not form an expression of type \u201cpointer to member.\u201d Neither does <a href=\"http://eel.is/c++draft/expr.prim.id.qual#qualified-id\" rel=\"nofollow\"><em>qualified-id</em></a>, because\n  there is no implicit conversion from a <a href=\"http://eel.is/c++draft/expr.prim.id.qual#qualified-id\" rel=\"nofollow\"><em>qualified-id</em></a> for a non-static member function to the type \u201cpointer to\n  member function\u201d as there is from an lvalue of function type to the type \u201cpointer to function\u201d <a href=\"http://eel.is/c++draft/conv.func\" rel=\"nofollow\">(4.3)</a>. Nor is\n  <code>&amp;unqualified-id</code> a pointer to member, even within the scope of the <a href=\"http://eel.is/c++draft/expr.prim.id.unqual#unqualified-id\" rel=\"nofollow\"><em>unqualified-id</em></a>\u2019s class. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>If it still doesn't help, you can uncover the correct syntax below:</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_37653169_37653472_1\"> <code>(t.*(cond ? &amp;T::memfunc1 : &amp;T::memfunc2))()</code></p>\n</blockquote>\n", "LastActivityDate": "2016-06-06T09:07:33.337", "CommentCount": "0", "CreationDate": "2016-06-06T09:07:33.337", "ParentId": "37653169", "Score": "1", "OwnerUserId": "3953764"}, "37653169": {"ViewCount": "57", "Body": "<p>Consider this:</p>\n<pre><code>int func1( int i );\nint func2( int i );\n</code></pre>\n<p>Conditional operator can be used like that:</p>\n<pre><code>int res = (cond)?func1(4):func2(4);\n</code></pre>\n<p>Or, if both may use the same parameter:</p>\n<pre><code>int res = ((cond)?func1:func2)(4);\n</code></pre>\n<p>Now, what about member functions of a class:</p>\n<pre><code>class T\n{\npublic:\n    T( int i ) : i(i) {}\n\n    int memfunc1() { return 1*i; }\n    int memfunc2() { return 2*i; }\n\nprivate:\n    int i;\n};\n</code></pre>\n<p>I tried this, but it does not work:</p>\n<pre><code>T t(4);\nint res2 = t.((cond)?memfunc1:memfunc2)();\n</code></pre>\n<p>...tried other syntax too (<code>(t.*((cond)?&amp;(T::memfunc1):&amp;(T::memfunc2)))()</code>) with no success...</p>\n<p>Is that doable and then what would be the good syntax? One line code answer are preferable (using a temporary auto variable to store pointer to function would be too easy...;-)</p>\n", "AcceptedAnswerId": "37653472", "Title": "Can conditional operator be used to toggle between two class member function calls", "CreationDate": "2016-06-06T08:50:57.393", "Id": "37653169", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2016-06-06T09:07:33.337", "Score": "0", "OwnerUserId": "3336423", "Tags": "<c++11><conditional><member-function-pointers>", "AnswerCount": "1"}});