post_cb({"4732449": {"ParentId": "4732084", "CommentCount": "2", "Body": "<p>I believe that the standards committee originally attempted to make it so move constructors would not be allowed to throw exceptions, but (at least as of today) found that trying to enforce that had too many pitfalls.</p>\n<p>Proposal N3050, \"Allowing Move Constructors to Throw (Rev 1)\", has been incorporated into the draft standard. Essentially the proposal adds the capability for move constructors to throw, but to disallow 'throwing' moves to be used for certain operations where strong exception safety guarantees were needed (the library will fall back to copying the object if a non-throwing move isn't available). </p>\n<p>If you mark a move constructor as non-throwing (<code>noexcept</code>) and an exception is thrown, std::terminate() will be called.</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html</a></li>\n</ul>\n<p>It might also be worth reading a blog article by David Abrahams that discusses the issues that N3050 was intended to address:</p>\n<ul>\n<li><a href=\"http://cpp-next.com/archive/2009/10/exceptionally-moving/\" rel=\"noreferrer\">http://cpp-next.com/archive/2009/10/exceptionally-moving/</a></li>\n</ul>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "4732449", "Score": "10", "CreationDate": "2011-01-19T06:44:14.280", "LastActivityDate": "2011-01-19T06:44:14.280"}, "4733134": {"ParentId": "4732084", "CommentCount": "0", "Body": "<p>Your question then amounts to a question about Exception Guarantees. There are 3 types of Exceptions Guarantees (that apply to functions):</p>\n<ul>\n<li>No exception guarantee at all (not really a type... but it may happen if no concern is given to the matter)</li>\n<li><strong>Basic Exception Guarantee</strong>: Technically correct, but not Functionally correct (ie no resource is leaked, the program will terminate without an abrupt halt, but it may have undesired side-effects, like the payment being cashed-in but the command not being registered)</li>\n<li><strong>Strong Exception Guarantee</strong>: All or Nothing (like a transaction), that is either everything is done right, or we rollback to the previous state.</li>\n<li><strong>No Throw Exception Guarantee</strong>: This does not throw, ever, so no worry.</li>\n</ul>\n<p>When you compose your function, you usually pick up existing functions with their own guarantees. It is difficult to increase the exception guarantee, that is your are generally limited by the weakest guarantee used.</p>\n<p>W.r.t your question, it takes at least a <em>Strong Exception Guarantee</em> for the original object to be left untouched if an exception is thrown.</p>\n<p>So, what happens if an exception is thrown during move-construction ? It depends on the guarantees exhibited by the sub-objects and the way you combined the calls...</p>\n<ol>\n<li>If an exception is thrown from a constructor, the object is not being built and all built subobjects are destroyed, in reverse order. This rule is also applicable to a move-constructor</li>\n<li>Unless you \"wrap\" the constructor in a try catch and somehow restore the objects that have been moved, they'll have lost their resources. Note that they must still be in a destructable state anyway, so technically the program will be correct.</li>\n</ol>\n<p>In terms of exceptions guarantees, it means that by default, if all of the subobjects' constructors at least meet the <em>Basic Exception Guarantee</em>, then your move constructor will too, without any special care.</p>\n<p>However, even if all the subobjects' constructors meet the <em>Strong Exception Guarantee</em>, it's unlikely you'll succeed in having your own move constructor meet it: this is the same issue that chaining transactions does not yield a transaction.</p>\n<p>If only one of the subobjects' constructors may throw, and it meets the <em>Strong Exception Guarantee</em>, then your move constructor will naturally meet it itself if you initialize the throwing object first.</p>\n<p>Hope this helped... exceptions are a wild beast to tame :)</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "4733134", "Score": "2", "CreationDate": "2011-01-19T08:25:39.987", "LastActivityDate": "2011-01-19T08:25:39.987"}, "4732274": {"ParentId": "4732084", "CommentCount": "0", "Body": "<p>Depends on the type being moved from.  It's possible to explicitly throw an exception, of course, from a move ctor, but also to implicitly call a copy ctor for a subobject from a move ctor.  That copy ctor might do something that may throw, such as allocate memory.  So, for the source object, the minimum guarantee is the original value may or may not remain, but it should still be in a destructable state.</p>\n<p>For the object being moved to, it's the same as throwing from a ctor in current C++: destroy any constructed bases and members, execute the ctor's function try handler, if any, then propagate the exception.  Details are in N3225 \u00a715.2p2.</p>\n<p>In particular, note that containers require their allocator types not have throwing move ctors:</p>\n<blockquote>\n<p id=\"so_4732084_4732274_0\">Such move construction of the allocator shall not exit via an exception. [N3225 \u00a723.2p8]</p>\n</blockquote>\n<p>This allows the containers to move allocators around and use those allocators to clean up their items in the case of an exception when moving or copying items.</p>\n", "OwnerUserId": "511601", "PostTypeId": "2", "Id": "4732274", "Score": "3", "CreationDate": "2011-01-19T06:12:47.840", "LastActivityDate": "2011-01-19T06:12:47.840"}, "bq_ids": {"n4140": {"so_4732084_4732274_0": {"section_id": 709, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_4732084_4732274_0": {"section_id": 698, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_4732084_4732274_0": {"section_id": 738, "quality": 0.7777777777777778, "length": 7}}}, "4732084": {"CommentCount": "3", "ViewCount": "3396", "OwnerDisplayName": "Matthieu N.", "CreationDate": "2011-01-19T05:37:22.427", "LastActivityDate": "2011-01-19T08:25:39.987", "PostTypeId": "1", "FavoriteCount": "7", "Title": "C++ Move semantics and Exceptions", "Id": "4732084", "Score": "25", "Body": "<p>In the forthcoming C++0x standard, what happens when an exception is thrown within/during the move constructor?</p>\n<p>Will the original object remain? or are both the original and move-to object in an undefined state? what are the guarantees afforded by the language?</p>\n", "Tags": "<c++><exception><c++11><move-semantics>", "AnswerCount": "3"}});