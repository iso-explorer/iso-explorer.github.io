post_cb({"bq_ids": {"n4140": {"so_46626832_46626887_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5573}}, "n3337": {"so_46626832_46626887_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5355}}, "n4659": {"so_46626832_46626887_0": {"length": 9, "quality": 1.0, "section_id": 7020}}}, "46626832": {"ViewCount": "75", "Body": "<p>I'm implementing an iterator that iterates over the results of a generator function rather than over a data structure in memory such as a vector or map.</p>\n<p>Reading through the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">final working draft for C++17</a> \u00a727.2.3, the return type of the dereference operator for <strike>an input iterator (and by extension, most other iterators)</strike> <a href=\"https://stackoverflow.com/a/46626887/5729206\"><em>a forward iterator</em></a> is required to be a reference. This is fine for items that exist in the data structure the iterator is iterating over. However, because I'm not using a data structure and am calculating each item when the dereference operator is called, I don't have a valid reference to return; the calculated item is destroyed when the operator returns. To work around this, I am storing the result of the calculation in the iterator itself and returning a reference to the stored result. This works fine for my use case, but has issues of its own when used with arbitrary user-defined types.</p>\n<p>I can understand iterators being <em>allowed</em> to return a reference, but why would this be a requirement for non-mutating iterators? Did the writers of the standard not consider generators and on-the-fly transformations to be valid use cases for iterators? Would returning a value instead of a const reference cause any actual harm?</p>\n<p>[edit]: I'm asking more out of curiosity about <em>why</em> the standard is written the way it is, since I already have a perfectly good workaround.</p>\n", "AcceptedAnswerId": "46626887", "Title": "Why are C++ iterators required to return a reference?", "CreationDate": "2017-10-08T01:52:52.927", "Id": "46626832", "CommentCount": "5", "LastEditDate": "2017-10-08T16:59:40.987", "PostTypeId": "1", "LastEditorUserId": "5729206", "LastActivityDate": "2017-10-08T16:59:40.987", "Score": "3", "OwnerUserId": "5729206", "Tags": "<c++><iterator><std><standard-library><c++-standard-library>", "AnswerCount": "1"}, "46626887": {"Id": "46626887", "PostTypeId": "2", "Body": "<p>Dereferencing an input iterator is <em>not</em> required to yield a glvalue (that is, return a reference). The input iterator requirements say that the return type when dereferencing must be \"<code>reference</code>, convertible to <code>T</code>\" but nowhere does it say that <code>reference</code> must be a reference type.</p>\n<p>However, dereferencing a forward iterator <em>is</em> required to yield a glvalue:</p>\n<blockquote>\n<p id=\"so_46626832_46626887_0\">if <code>X</code> is a mutable iterator, <code>reference</code> is a reference to <code>T</code>; if <code>X</code> is a constant iterator, <code>reference</code> is a reference to <code>const T</code>,</p>\n</blockquote>\n<p>So go ahead and write your iterator that generates elements on the fly, but it can only be an input iterator, not a forward iterator. For many algorithms this is sufficient (<em>e.g.,</em> <code>std::for_each</code> and <code>std::all_of</code>).</p>\n", "LastActivityDate": "2017-10-08T02:06:00.587", "CommentCount": "7", "CreationDate": "2017-10-08T02:06:00.587", "ParentId": "46626832", "Score": "3", "OwnerUserId": "481267"}});