post_cb({"41388497": {"ParentId": "41385355", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In addition to Ben Voigt's answer which details when it is OK to omit the destructor call, it is important to ensure the memory is properly aligned for the type to be placed-new in it. I'll try to write it up here as <a href=\"https://stackoverflow.com/questions/41385355/is-it-ok-not-to-call-the-destructor-on-placement-new-allocated-objects#comment69973124_41385355\">requested by to OP</a>.</p>\n<p>This line:</p>\n<pre><code>S *newS = new(buffer + offset)S;\n</code></pre>\n<p>works only if the address <code>buffer + offset</code> is aligned properly:</p>\n<blockquote>\n<p id=\"so_41385355_41388497_0\"><strong>3.11  Alignment</strong><br>\n<sup>1</sup> Object types have alignment requirements (3.9.1, 3.9.2) which place restrictions on the addresses\n  at which an object of that type may be allocated. An alignment is an\n  implementation-defined integer value representing the number of bytes\n  between successive addresses at which a given object can be allocated.<br>\n  [...]</br></br></p>\n</blockquote>\n<p><code>buffer</code> itself is properly aligned for any type with <em>fundamental alignment requirement</em>:</p>\n<blockquote>\n<p id=\"so_41385355_41388497_1\"><strong>3.7.4.1  Allocation functions</strong><br>\n<sup>2</sup> [...]<br>\n  The pointer returned shall\n  be suitably aligned so that it can be converted to a pointer of any\n  complete object type with a fundamental alignment requirement (3.11)\n  and then used to access the object or array in the storage allocated<br>\n  [...]</br></br></br></p>\n</blockquote>\n<p>To know the alignment requirement of a type, there is <code>alignof(type)</code>. Then there is <code>std::max_align_t</code>, <code>alignof(std::max_align_t)</code> returns the greatest alignment value of all types with fundamental alignment requirement.</p>\n<p>There is a special case of types that require an <em>extended alignment</em>, to be sure your type is not one of these I would include this in your program:</p>\n<pre><code>static_assert(alignof(S) &lt;= alignof(std::max_align_t),  \n              \"Extended alignment required for S\");\n</code></pre>\n<p>Then, you just have to make sure that <code>offset</code> is a multiple of <code>alignof(S)</code>.</p>\n", "OwnerUserId": "3435400", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:33:53.177", "Id": "41388497", "Score": "4", "CreationDate": "2016-12-29T23:12:33.577", "LastActivityDate": "2016-12-29T23:12:33.577"}, "41385385": {"ParentId": "41385355", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard has a rule in section 3.8 <code>[basic.life]</code> that covers this:</p>\n<blockquote>\n<p id=\"so_41385355_41385385_0\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. <strong>For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released</strong>; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, <strong>the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior</strong>.</p>\n</blockquote>\n<p>Lots of experts are in agreement that \"depends on the side effects produced by the destructor\" is far too vague to be useful.  Many interpret it as a tautology meaning \"If the program has undefined behavior when the destructor side effects are not evaluated, then failing to call the destructor causes undefined behavior\".  See <a href=\"https://stackoverflow.com/q/21110059/103167\">Observable behavior and undefined behavior -- What happens if I don't call a destructor?</a></p>\n<p>If your type has a trivial destructor (which appears to be the case in your example), then calling it (or failing to call it) has no effect whatsoever -- calling a trivial destructor does not even end the life of the object.</p>\n<blockquote>\n<p id=\"so_41385355_41385385_1\">The lifetime of an object <code>o</code> of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor, the destructor call starts, or</li>\n<li>the storage which the object occupies is released, or is reused by an object that is not nested within <code>o</code>.</li>\n</ul>\n</blockquote>\n<p>That is, if <code>T</code> doesn't have a non-trivial destructor, the only way to end the lifetime of object <code>o</code> is to release or reuse its storage.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:33.133", "Id": "41385385", "Score": "14", "CreationDate": "2016-12-29T18:38:22.753", "LastActivityDate": "2016-12-29T18:49:36.730"}, "bq_ids": {"n4140": {"so_41385355_41388497_0": {"section_id": 7240, "quality": 0.7666666666666667, "length": 23}, "so_41385355_41385385_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_41385355_41385385_0": {"section_id": 7192, "quality": 0.9607843137254902, "length": 49}, "so_41385355_41388497_1": {"section_id": 7177, "quality": 0.7916666666666666, "length": 19}}, "n3337": {"so_41385355_41388497_0": {"section_id": 6984, "quality": 0.7666666666666667, "length": 23}, "so_41385355_41385385_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_41385355_41385385_0": {"section_id": 6936, "quality": 0.9607843137254902, "length": 49}, "so_41385355_41388497_1": {"section_id": 6921, "quality": 0.7916666666666666, "length": 19}}, "n4659": {"so_41385355_41388497_1": {"section_id": 8685, "quality": 0.6666666666666666, "length": 16}, "so_41385355_41385385_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_41385355_41388497_0": {"section_id": 8749, "quality": 0.7333333333333333, "length": 22}, "so_41385355_41385385_0": {"section_id": 8701, "quality": 0.9607843137254902, "length": 49}}}, "41385355": {"CommentCount": "11", "ViewCount": "173", "CreationDate": "2016-12-29T18:35:33.747", "LastActivityDate": "2016-12-29T23:27:18.810", "Title": "Is it OK not to call the destructor on placement new allocated objects?", "AcceptedAnswerId": "41385385", "PostTypeId": "1", "Id": "41385355", "Score": "6", "Body": "<p>Say I have a fixed memory buffer</p>\n<pre><code>char *buffer; \n</code></pre>\n<p>And I <strong>allocate my structures in that buffer using placement new</strong></p>\n<pre><code>struct S\n{ \n    std::tuple&lt;int, double, char&gt; m_data; \n    auto getRecord() \n    { \n        return m_data;\n    }\n};\n\nS *newS = new(buffer + offset)S; \n</code></pre>\n<p>I know that I'm supposed to manually call the destructor of such allocated items but <strong>if there's no bookeeping / resource management involved</strong> is it ok to omit this? In other words if the destructor of the classes using the buffer is not doing anything (similar to <code>~S()</code> above) is it ok to skip this step? If that's the case can I reuse the buffer without destroying the previous tenants?</p>\n", "Tags": "<c++>", "OwnerUserId": "4224575", "AnswerCount": "3"}, "41385381": {"ParentId": "41385355", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Technically the destructor call is not required. Practically better safe than sorry (do call the destructor)</p>\n", "OwnerUserId": "3897333", "LastEditorUserId": "3897333", "LastEditDate": "2016-12-29T23:27:18.810", "Id": "41385381", "Score": "5", "CreationDate": "2016-12-29T18:38:16.477", "LastActivityDate": "2016-12-29T23:27:18.810"}});