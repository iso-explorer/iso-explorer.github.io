post_cb({"18919893": {"Body": "<p>A <code>num_get</code> facet to support the explicit check for signedness. Rejects any non-zero number beginning with a <code>'-'</code> (after white-spaces) for unsigned types and uses the default C locale's <code>num_get</code> to do the actual conversion.</p>\n<pre><code>#include &lt;locale&gt;\n#include &lt;istream&gt;\n#include &lt;ios&gt;\n#include &lt;algorithm&gt;\n\ntemplate &lt;class charT, class InputIterator = std::istreambuf_iterator&lt;charT&gt; &gt;\nclass num_get_strictsignedness : public std::num_get &lt;charT, InputIterator&gt;\n{\npublic:\n    typedef charT char_type;\n    typedef InputIterator iter_type;\n\n    explicit num_get_strictsignedness(std::size_t refs = 0)\n        : std::num_get&lt;charT, InputIterator&gt;(refs)\n    {}\n    ~num_get_strictsignedness()\n    {}\n\nprivate:\n    #define DEFINE_DO_GET(TYPE) \\\n        virtual iter_type do_get(iter_type in, iter_type end,      \\\n            std::ios_base&amp; str, std::ios_base::iostate&amp; err,       \\\n            TYPE&amp; val) const override                              \\\n        {  return do_get_templ(in, end, str, err, val);  }         // MACRO END\n\n    DEFINE_DO_GET(unsigned short)\n    DEFINE_DO_GET(unsigned int)\n    DEFINE_DO_GET(unsigned long)\n    DEFINE_DO_GET(unsigned long long)\n\n    // not sure if a static locale::id is required..\n\n    template &lt;class T&gt;\n    iter_type do_get_templ(iter_type in, iter_type end, std::ios_base&amp; str,\n                           std::ios_base::iostate&amp; err, T&amp; val) const\n    {\n        using namespace std;\n\n        if(in == end)\n        {\n            err |= ios_base::eofbit;\n            return in;\n        }\n\n        // leading white spaces have already been discarded by the\n        // formatted input function (via sentry's constructor)\n\n        // (assuming that) the sign, if present, has to be the first character\n        // for the formatting required by the locale used for conversion\n\n        // use the \"C\" locale; could use any locale, e.g. as a data member\n\n        // note: the signedness check isn't actually required\n        //       (because we only overload the unsigned versions)\n        bool do_check = false;\n        if(std::is_unsigned&lt;T&gt;{} &amp;&amp; *in == '-')\n        {\n            ++in;  // not required\n            do_check = true;\n        }\n\n        in = use_facet&lt; num_get&lt;charT, InputIterator&gt; &gt;(locale::classic())\n                 .get(in, end, str, err, val);\n\n        if(do_check &amp;&amp; 0 != val)\n        {\n            err |= ios_base::failbit;\n            val = 0;\n        }\n\n        return in;\n    }\n};\n</code></pre>\n<p>Usage example:</p>\n<pre><code>#include &lt;sstream&gt;\n#include &lt;iostream&gt;\nint main()\n{\n    std::locale loc( std::locale::classic(),\n                     new num_get_strictsignedness&lt;char&gt;() );\n    std::stringstream ss(\"-10\");\n    ss.imbue(loc);\n    unsigned int ui = 42;\n    ss &gt;&gt; ui;\n    std::cout &lt;&lt; \"ui = \"&lt;&lt;ui &lt;&lt; std::endl;\n    if(ss)\n    {\n        std::cout &lt;&lt; \"extraction succeeded\" &lt;&lt; std::endl;\n    }else\n    {\n        std::cout &lt;&lt; \"extraction failed\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>Notes:</p>\n<ul>\n<li>the allocation on the free store is not required, you could use e.g. a (static) local variable where you initialize the ref counter with <code>1</code> in the ctor</li>\n<li>for every character type you want to support (like <code>char</code>, <code>wchar_t</code>, <code>charXY_t</code>), you need to add an own facet (can be different instantiations of the <code>num_get_strictsignedness</code> template)</li>\n<li><code>\"-0\"</code> is accepted</li>\n</ul>\n", "CreationDate": "2013-09-20T14:58:21.017", "ParentId": "18917167", "CommentCount": "5", "LastEditDate": "2013-09-20T16:20:57.777", "Id": "18919893", "PostTypeId": "2", "LastActivityDate": "2013-09-20T16:20:57.777", "LastEditorUserId": "420683", "CommunityOwnedDate": "2013-09-20T14:58:21.017", "Score": "2", "OwnerUserId": "420683"}, "bq_ids": {"n4140": {"so_18917167_18918372_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 2189}, "so_18917167_18918372_1": {"length": 8, "quality": 1.0, "section_id": 2189}}, "n3337": {"so_18917167_18918372_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 2177}, "so_18917167_18918372_1": {"length": 8, "quality": 1.0, "section_id": 2177}}, "n4659": {"so_18917167_18918372_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 2462}, "so_18917167_18918372_1": {"length": 8, "quality": 1.0, "section_id": 2462}}}, "18918372": {"Id": "18918372", "PostTypeId": "2", "Body": "<p>Version disclaimer: The answer is different for C++03. The following deals with C++11.</p>\n<p>First, let's analyse what's happening.</p>\n<p><code>ss &gt;&gt; res;</code> This calls <code>std::istream::operator&gt;&gt;(unsigned)</code>. In [istream.formatted.arithmetic]/1, the effects are defined as follows:</p>\n<blockquote>\n<p id=\"so_18917167_18918372_0\">These extractors behave as formatted input functions (as described in 27.7.2.2.1). After a sentry object is constructed, the conversion occurs as if performed by the following code fragment:</p>\n<pre><code>typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;\niostate err = iostate::goodbit;\nuse_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, val);\nsetstate(err);\n</code></pre>\n<p id=\"so_18917167_18918372_1\">In the above fragment, <code>loc</code> stands for the private member of the <code>basic_ios</code> class.</p>\n</blockquote>\n<p>Following <em>formatted input functions</em> to [istream::sentry], the main effect of the <code>sentry</code> object here is to consume leading white-space characters. It also prevents executing of the code shown above in case of an error (stream is in failed / eof state).</p>\n<p>The used locale is the <code>\"C\"</code> locale. Rationale:</p>\n<p>For a the <code>stringstream</code> constructed via <code>stringstream ss(s);</code>, the locale of that iostream is the current global locale at the time of construction (that's guaranteed deep down in the rabbit hole at [ios.base.locales]/4). As the global locale hasn't been changed in the OP's program, [locale.cons]/2 specifies the \"classic\" locale, i.e. the <code>\"C\"</code> locale.</p>\n<p><code>use_facet&lt; numget &gt;(loc).get</code> uses the member function <code>num_get&lt;char&gt;::get(iter_type in, iter_type end, ios_base&amp;, ios_base::iostate&amp; err, unsigned int&amp; v) const;</code> specified in [locale.num.get] (note the <code>unsigned int</code>, everything is still fine). The details of the string -&gt; <code>unsigned int</code> conversion for the \"C\" locale are lengthy and described in [facet.num.get.virtuals]. Some interesting details:</p>\n<ul>\n<li>For an unsigned integer value, the function <code>strtoull</code> is used.</li>\n<li>If the conversion fails, <code>ios_base::failbit</code> is assigned to <code>err</code>. Specifically: \"The numeric value to be stored can be one of: [...] the most negative representable value or zero for an unsigned integer type, if the field represents a value too large negative to be represented in val. <code>ios_base::failbit</code> is assigned to <code>err</code>.\"</li>\n</ul>\n<p>We need to go to C99, 7.20.1.4 for the definition of <code>strtoull</code>, under paragraph 5:</p>\n<blockquote>\n<p id=\"so_18917167_18918372_2\">If the subject sequence begins with a minus sign, the value resulting from\n  the conversion is negated (in the return type).</p>\n</blockquote>\n<p>and under paragraph 8:</p>\n<blockquote>\n<p id=\"so_18917167_18918372_3\">If the correct value is outside the range of representable values, <code>LONG_MIN</code>, <code>LONG_MAX</code>, <code>LLONG_MIN</code>, <code>LLONG_MAX</code>, <code>ULONG_MAX</code>, or <code>ULLONG_MAX</code> is returned (according to the return type and sign of the value, if any), and the value of the macro <code>ERANGE</code> is stored in <code>errno</code></p>\n</blockquote>\n<p>It seems that it has been debated in the past if negative values are considered valid input for <code>strotoul</code>. In any case, the problem lies here with this function. A quick check on gcc says that it's considered valid input, and therefore the behaviour you observed.</p>\n<hr>\n<p>Historic note: C++03</p>\n<p>C++03 used <code>scanf</code> inside the <code>num_get</code> conversion. Unfortunately, I'm not quite sure (yet) how the conversion for <code>scanf</code> is specified, and under which circumstances errors occur.</p>\n<hr>\n<p>An explicit error check:</p>\n<p>We can manually insert that check either by using a signed value for conversion and testing <code>&lt;0</code>, or we look for the <code>-</code> character (which isn't a good idea because of possible localization issues).</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-09-20T14:00:30.487", "Score": "3", "CreationDate": "2013-09-20T13:45:02.233", "ParentId": "18917167", "CommentCount": "5", "OwnerUserId": "420683", "LastEditDate": "2013-09-20T14:00:30.487"}, "18917167": {"ViewCount": "2287", "Body": "<p>I'm writing part of program which parses and validates some user input in program console arguments. I choose to use stringstream for that purpose, but encounter a problem with unsigned types reading.</p>\n<p>Next template is intended for reading requested type from given string:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nusing std::string;\nusing std::stringstream;\nusing std::cout;\nusing std::endl;\n\ntemplate&lt;typename ValueType&gt;\nValueType read_value(string s)\n{   \n    stringstream ss(s);\n    ValueType res;\n    ss &gt;&gt; res;\n    if (ss.fail() or not ss.eof())\n        throw string(\"Bad argument: \") + s;\n    return res;\n}\n// +template specializations for strings, etc. \n\nint main(void)\n{   \n    cout &lt;&lt; read_value&lt;unsigned int&gt;(\"-10\") &lt;&lt; endl;\n}   \n</code></pre>\n<p>In case type is unsigned and input string contains negative number I expect to see exception throw (caused by <code>ss.fail() = true</code>). But stringstream produces casted to unsigned type value (4294967286 in written sample).</p>\n<p>How can be this sample fixed to achieve desired behavior (preferable without fallback to c functions)?\nI understand that it can be done with simple first symbol check but I can put leading spaces for example. I can write own parser but don't believe that problem is so unpredictable and standard library unable to solve it.</p>\n<p>Functions hidden in deep of stringstream operators for unsigned types are strtoull and strtoul. They work in described manner but <em>mentioned functions are low-level</em>. Why stringstream do not provide some validation level? (I just hope I'm wrong and it does but some movements required to enable this).</p>\n", "AcceptedAnswerId": "18919893", "Title": "stringstream unsigned input validation", "CreationDate": "2013-09-20T12:46:37.513", "Id": "18917167", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-04-02T20:55:01.890", "LastEditorUserId": "1505939", "LastActivityDate": "2016-04-02T20:55:01.890", "Score": "5", "OwnerUserId": "2784509", "Tags": "<c++><validation><c++11>", "AnswerCount": "2"}});