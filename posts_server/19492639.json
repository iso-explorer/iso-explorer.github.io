post_cb({"19492740": {"ParentId": "19492639", "CommentCount": "0", "Body": "<p>In both cases, the destructor is needed to destroy the object at the end of its static or automatic lifetime, so must be accessible where the object is declared.</p>\n<p>In the first case, the object is declared inside a member of the class, so the destructor is accessible and compilation succeeds.</p>\n<p>In the second case, the object is declared in a non-member function, so the destructor is no accessible and compilation fails.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "19492740", "Score": "0", "CreationDate": "2013-10-21T11:01:52.773", "LastActivityDate": "2013-10-21T11:01:52.773"}, "19492733": {"ParentId": "19492639", "CommentCount": "0", "Body": "<p>All objects are destructed when they go out of scope, and objects declared static goes out of scope when the program ends, which is exactly what you see in the first example. That the destructor is declared as private only means that you can create (and destroy) instances within the same class.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "19492733", "Score": "0", "CreationDate": "2013-10-21T11:01:35.793", "LastActivityDate": "2013-10-21T11:01:35.793"}, "19492713": {"ParentId": "19492639", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Static function is function of class, so it has access to <code>private</code> functions of this class, thats why 1 case work well as expected.</p>\n<p>In first case - object will be created in function <code>Instance</code>, which have access to constructor for this class. Since object is declared <code>static</code> - it will be destroyed only in the end of program, since object is created in class function - there is access to destructor.</p>\n<p>In second case - you are trying to create object of type <code>MyClass</code> in <code>main</code> function, which is not class-function, so it has no access to c-tor/d-tor.</p>\n", "OwnerUserId": "1498580", "LastEditorUserId": "1498580", "LastEditDate": "2013-10-21T11:05:54.923", "Id": "19492713", "Score": "2", "CreationDate": "2013-10-21T11:00:42.017", "LastActivityDate": "2013-10-21T11:05:54.923"}, "19492754": {"ParentId": "19492639", "CommentCount": "0", "Body": "<p>Although I don't understand what you are trying to achive, the error is obvious:</p>\n<p>In your first case, the line constructing your object is inside the class and therefor has access to all private methods. </p>\n<p>In your second case, the construction is outside the class and therefor no access to private members is possible.</p>\n", "OwnerUserId": "2060725", "PostTypeId": "2", "Id": "19492754", "Score": "0", "CreationDate": "2013-10-21T11:02:16.720", "LastActivityDate": "2013-10-21T11:02:16.720"}, "19492639": {"CommentCount": "1", "ViewCount": "214", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-10-21T10:57:17.480", "LastActivityDate": "2013-10-23T06:10:44.907", "Title": "why private destructor getting called when obj is created statically", "LastEditDate": "2017-05-23T10:25:45.843", "Id": "19492639", "Score": "1", "Body": "<p>I have asked one question (<a href=\"https://stackoverflow.com/questions/19442928/use-of-making-destructor-private\">Use of making destructor private</a>) related with private destructor, but I have ended with this below question and still I don't understand the exact answer.</p>\n<p>Question:</p>\n<p>Why private destructor are getting called when I creates an object of class having private destructor? But not when I creates a normal object.</p>\n<h3>CASE I</h3>\n<pre><code>// myclass.h\n\n#include &lt;iostream&gt;\n\nclass MyClass {\npublic:\n    static MyClass&amp; GetInstance();\n    void Display();\nprivate:\n    MyClass();\n    virtual ~MyClass();\n};\n\nMyClass::MyClass() {\n    std::cout &lt;&lt; \"Constructor \" &lt;&lt; std::endl;\n}\n\nMyClass::~MyClass() {\n    std::cout &lt;&lt; \"Destructor\" &lt;&lt; std::endl;\n}\n\nMyClass&amp; MyClass::GetInstance() {\n    static MyClass _instance;\n    return _instance;\n}\n\nvoid MyClass::Display() {\n    std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl;\n}\n// main.cpp\n\n#include \"myclass.h\"\n#include &lt;iostream&gt;\n\nint main() {\n\n    MyClass::GetInstance().Display(); //case1\n\n\n\n    std::cout &lt;&lt; \"main finished!\" &lt;&lt; std::endl;\n\n    return 0;\n}\n\n// output\nConstructor \nmain finished\nDestructor.\n</code></pre>\n<h3>CASE II</h3>\n<pre><code>// myclass.h\n\n#include &lt;iostream&gt;\n\nclass MyClass {\npublic:\n    void Display();\n    MyClass();\n    virtual ~MyClass();\n};\n\nMyClass::MyClass() {\n    std::cout &lt;&lt; \"Constructor \" &lt;&lt; std::endl;\n}\n\nMyClass::~MyClass() {\n    std::cout &lt;&lt; \"Destructor\" &lt;&lt; std::endl;\n}\n\nMyClass&amp; MyClass::GetInstance() {\n    static MyClass _instance;\n    return _instance;\n}\n\nvoid MyClass::Display() {\n    std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl;\n}\n// main.cpp\n\n#include \"myclass.h\"\n#include &lt;iostream&gt;\n\nint main() {\n\n    MyClass testObj;\n\n\n\n    std::cout &lt;&lt; \"main finished!\" &lt;&lt; std::endl;\n\n    return 0;\n}\n\n// Error\n1&gt;e:\\programs\\cpp_test\\src\\main.cpp(38): error C2248: 'MyClass::MyClass' : cannot access private member declared in class 'MyClass'\n1&gt;          e:\\programs\\cpp_test\\static_single_test.h(11) : see declaration of 'MyClass::MyClass'\n1&gt;          e:\\programs\\cpp_test\\static_single_test.h(6) : see declaration of 'MyClass'\n1&gt;e:\\programs\\cpp_test\\src\\main.cpp(38): error C2248: 'MyClass::~MyClass' : cannot access private member declared in class 'MyClass'\n1&gt;          e:\\programs\\cpp_test\\static_single_test.h(12) : see declaration of 'MyClass::~MyClass\n</code></pre>\n<p>EDIT</p>\n<p>I have come to know that making destructor protected/private is needed when we \"Require heap based object only.</p>\n<p><a href=\"http://en.wikibooks.org/w/index.php?title=More_C%2b%2b_Idioms/Requiring_or_Prohibiting_Heap-based_Objects&amp;diff=2567824&amp;oldid=2202430&amp;utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed:%20MoreCppIdiomsWikibook%20%28Wikibooks%20-%20Changes%20related%20to%20%22More%20C%2b%2b%20Idioms%22%20%5Ben%5D%29\" rel=\"nofollow noreferrer\">http://en.wikibooks.org/w/index.php?title=More_C%2B%2B_Idioms%2FRequiring_or_Prohibiting_Heap-based_Objects&amp;diff=2567824&amp;oldid=2202430&amp;utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+MoreCppIdiomsWikibook+%28Wikibooks+-+Changes+related+to+%22More+C%2B%2B+Idioms%22+[en]%2</a>9</p>\n", "Tags": "<c++><constructor>", "OwnerUserId": "571156", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_19492639_19493960_0": {"section_id": 7156, "quality": 1.0, "length": 17}}, "n3337": {"so_19492639_19493960_1": {"section_id": 398, "quality": 1.0, "length": 12}, "so_19492639_19493960_0": {"section_id": 6900, "quality": 1.0, "length": 17}}, "n4659": {"so_19492639_19493960_1": {"section_id": 242, "quality": 0.5833333333333334, "length": 7}, "so_19492639_19493960_0": {"section_id": 8661, "quality": 0.7647058823529411, "length": 13}}}, "19493960": {"ParentId": "19492639", "CommentCount": "0", "Body": "<p>An object with static storage duration is destroyed after a return from <code>main</code> or after a call to <code>std::exit</code>. Section 3.6.3 of the standards describe this destruction. From C++11, 3.6.3,</p>\n<blockquote>\n<p id=\"so_19492639_19493960_0\">Destructors for initialized objects (that is, objects whose lifetime has begun) with static storage duration are called as a result of returning from main and as a result of calling std::exit.</p>\n</blockquote>\n<p>Note that there is no mention of the accessibility (public/protected/private) of the destructor. The appropriate destructor is called, period.</p>\n<p>It's section 12.4 that covers accessibility. C++11 12.4 para 11 (paragraph 10 in C++03) states that</p>\n<blockquote>\n<p id=\"so_19492639_19493960_1\">A program is ill-formed if an object of class type or array thereof is declared and the destructor for the class is not accessible at the point of the declaration.</p>\n</blockquote>\n<p>The destructor is accessible in static function <code>MyClass::GetInstance()</code>, so the block scope static variable declared in that function is okay. The destructor is not accessible in <code>main()</code>, so the automatic variable declared in <code>main</code> is not okay.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "19493960", "Score": "1", "CreationDate": "2013-10-21T12:01:50.937", "LastActivityDate": "2013-10-21T12:01:50.937"}});