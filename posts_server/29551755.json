post_cb({"29551755": {"CommentCount": "1", "ViewCount": "506", "ClosedDate": "2015-04-10T01:38:57.333", "CreationDate": "2015-04-10T01:16:45.983", "LastActivityDate": "2015-04-10T01:39:28.267", "Title": "why getenv() can get name resolved without a std::?", "PostTypeId": "1", "Id": "29551755", "Score": "3", "Body": "<p>getenv() has a C++ implementation which can be included in the header file . So it is a member of namespace std. However, the getenv() function can be get resolved correctly in my code even without a std::getenv(), which means my follow program can be compiled and run without any error and warning. So why getenv() as a name member of namespace std can get resolved without std::? My OS and compiler is Ubuntu 12.04 i386 and g++ 4.8.1 respectively.</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    char * path_env;\n\n    path_env = getenv(\"PATH\"); //without a name resolve operation std::getenv()\n\n    std::cout &lt;&lt; path_env &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><getenv><name-resolution>", "OwnerUserId": "4771657", "AnswerCount": "3"}, "29551811": {"ParentId": "29551755", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>When you <code>include</code> one of the c* headers, the standard <em>requires</em> that the names are in the <code>std</code> namespace, but <em>allows</em> them to be first placed into the global namespace and then copied over to <code>std</code>.</p>\n<p>Conversely, when you <code>include</code> one of the *.h headers (which are deprecated), the standard <em>requires</em> that the names are placed into the global namespace, but <em>allows</em> them to be first declared in the <code>std</code> namespace and copied over.</p>\n<p>From [headers] / 4</p>\n<blockquote>\n<p id=\"so_29551755_29551811_0\">[...] It is unspecified whether these names are first declared within the\n  global namespace scope and are then injected into namespace std by\n  explicit using-declarations (7.3.3).</p>\n</blockquote>\n<p>From [depr.c.headers]</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/w0z6d.png\"/></p>\n<p>Technically for maximum portability you should prefix names (except macros of course) in the c* headers with <code>std</code>, although in my limited experience I haven't come across an implementation that doesn't declare them in the global namespace as well.</p>\n", "OwnerUserId": "657267", "LastEditorUserId": "657267", "LastEditDate": "2015-04-10T01:39:28.267", "Id": "29551811", "Score": "1", "CreationDate": "2015-04-10T01:25:02.793", "LastActivityDate": "2015-04-10T01:39:28.267"}, "29551827": {"ParentId": "29551755", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Try to use search before asking questions. This is duplicate of <a href=\"https://stackoverflow.com/questions/15037456/why-and-how-does-rand-exist-both-in-global-and-std-namespace-in-cstdlib\">why and how does rand() exist both in global and std namespace in cstdlib?</a></p>\n<p><strong>C++11 Standard: D.5 C standard library headers</strong><br>\n<strong>Para 3:</strong> </br></p>\n<blockquote>\n<p id=\"so_29551755_29551827_0\">The header <code>&lt;cstdlib&gt;</code> assuredly provides its declarations and definitions within the namespace <code>std</code>. It may also provide these names within the global namespace. The header <code>&lt;stdlib.h&gt;</code> assuredly provides the same declarations and definitions within the global namespace, much as in the C Standard. It may also provide these names within the namespace <code>std</code>.</p>\n</blockquote>\n", "OwnerUserId": "655436", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:06:21.323", "Id": "29551827", "Score": "1", "CreationDate": "2015-04-10T01:27:25.487", "LastActivityDate": "2015-04-10T01:27:25.487"}, "bq_ids": {"n4140": {"so_29551755_29551827_0": {"section_id": 4908, "quality": 0.9210526315789473, "length": 35}, "so_29551755_29551811_0": {"section_id": 6259, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_29551755_29551827_0": {"section_id": 4703, "quality": 0.9210526315789473, "length": 35}, "so_29551755_29551811_0": {"section_id": 6019, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_29551755_29551827_0": {"section_id": 6317, "quality": 0.9210526315789473, "length": 35}, "so_29551755_29551811_0": {"section_id": 7763, "quality": 0.9411764705882353, "length": 16}}}, "29551784": {"ParentId": "29551755", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your code is probably not portable. BTW, it <a href=\"http://ideone.com/TpgiHb\" rel=\"nofollow\">seems to work</a> even without including <code>&lt;cstdlib&gt;</code>. If we look carefully at the declaration:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/utility/program/getenv\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/utility/program/getenv</a></p>\n<p>we see that indeed it belongs to <code>cstdlib</code>, and the usual convention is that all headers that starts with <code>c</code> + previous C-like header are now in <code>namespace std;</code>, so you should be using <code>std::</code>. </p>\n<p>Same happens with <code>std::string</code>, seems to be included by many standard library headers, although if you look at the standard, you shouldn't rely on this.</p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "3093378", "LastEditDate": "2015-04-10T01:28:34.433", "Id": "29551784", "Score": "0", "CreationDate": "2015-04-10T01:20:58.820", "LastActivityDate": "2015-04-10T01:28:34.433"}});