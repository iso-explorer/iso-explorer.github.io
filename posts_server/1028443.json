post_cb({"1028443": {"ViewCount": "1617", "Body": "<p>I'm reviewing a collegue's code, and I see he has several constants defined in the global scope as:</p>\n<pre><code>const string&amp; SomeConstant = \"This is some constant text\";\n</code></pre>\n<p>Personally, this smells bad to me because the reference is referring to what I'm assuming is an \"anonymous\" object constructed from the given char array.</p>\n<p>Syntactically, it's legal (at least in VC++ 7), and it seems to run, but really I'd rather have him remove the &amp; so there's no ambiguity as to what it's doing.</p>\n<p>So, is this TRULY safe and legal and I'm obsessing?  Does the temp object being constructed have a guaranteed lifetime?  I had always assumed anonymous objects used in this manner were destructed after use...</p>\n<hr>\n<p>So my question could also be generalized to anonymous object lifetime.  Does the standard dictate the lifetime of an anonymous object?  Would it have the same lifetime as any other object in that same scope?  Or is it only given the lifetime of the expression?</p>\n<hr>\n<p>Also, when doing it as a local, it's obviously scoped differently:</p>\n<pre><code>class A\n{\n    string _str;\n\npublic:\n    A(const string&amp; str) :\n        _str(str)\n    {\n        cout &lt;&lt; \"Constructing A(\" &lt;&lt; _str &lt;&lt; \")\" &lt;&lt; endl;\n    }\n\n    ~A()\n    {\n        cout &lt;&lt; \"Destructing A(\" &lt;&lt; _str &lt;&lt; \")\" &lt;&lt; endl;\n    }\n};\n\nvoid TestFun()\n{\n    A(\"Outer\");\n    cout &lt;&lt; \"Hi\" &lt;&lt; endl;\n}\n</code></pre>\n<p>Shows:</p>\n<p>Constructing A(Outer);\nDestructing A(Outer);\nHi</p>\n</hr></hr>", "AcceptedAnswerId": "1028511", "Title": "Global const string& smells bad to me, is it truly safe?", "CreationDate": "2009-06-22T17:27:12.990", "Id": "1028443", "CommentCount": "7", "LastEditDate": "2009-06-22T18:12:49.353", "PostTypeId": "1", "LastEditorUserId": "8123", "LastActivityDate": "2009-06-23T16:16:49.933", "Score": "10", "OwnerUserId": "127084", "Tags": "<c++><string><object><const><anonymous>", "AnswerCount": "7"}, "1028583": {"Id": "1028583", "PostTypeId": "2", "Body": "<p>It might be legal, but still ugly. Leave out the reference !</p>\n<pre><code>const string SomeConstant = \"This is some constant text\";\n</code></pre>\n", "LastActivityDate": "2009-06-22T17:52:32.787", "Score": "6", "CreationDate": "2009-06-22T17:52:32.787", "ParentId": "1028443", "CommentCount": "7", "OwnerUserId": "106205"}, "1033215": {"Id": "1033215", "PostTypeId": "2", "Body": "<p>Okay, folks correct me if I'm off the deep end, but here's my conclusions listening to all of your excellent responses:</p>\n<p>A) it is syntactically and logically legal, the &amp; extends the lifetime of the temp/anonymous from beyond expression level to the life of the reference.  I verified this in VC++7 with:</p>\n<pre><code>class A { \n    public: A() { cout &lt;&lt; \"constructing A\" &lt;&lt; endl; }\n    public: ~A() { cout &lt;&lt; \"destructing A\" &lt;&lt; endl; }\n};\n\nvoid Foo()\n{\n    A();\n    cout &lt;&lt; \"Foo\" &lt;&lt; endl;\n}\n\nvoid Bar()\n{\n    const A&amp; someA = A();\n    cout &lt;&lt; \"Bar\" &lt;&lt; endl;\n}\n\nint main()\n{\n    Foo();    // outputs constructing A, destructing A, Foo\n    Bar();    // outputs constructing A, Bar, destructing A\n    return 0;\n}\n</code></pre>\n<p>B) Though it is legal, it can lead to some confusion as to the actual lifetime and the reference in these cases give you no benefit of declaring it as a non-reference, thus the reference should probably be avoided and may even be extra space.  Since there's no benefit to it, it's unnecessary obfuscation.</p>\n<p>Thanks for all the answers it was a very interesting dicussion.  So the long and short of it: Yes, it's syntactically legal, no it's not technically dangerous as the lifetime is extended, but it adds nothing and may add cost and confusion, so why bother.</p>\n<p>Sound right?</p>\n", "LastEditorUserId": "47773", "LastActivityDate": "2009-06-23T16:16:49.933", "Score": "0", "CreationDate": "2009-06-23T15:15:45.450", "ParentId": "1028443", "CommentCount": "2", "LastEditDate": "2009-06-23T16:16:49.933", "OwnerUserId": "127084"}, "bq_ids": {"n4140": {"so_1028443_1028511_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 7164}}, "n3337": {"so_1028443_1028511_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 6908}}, "n4659": {"so_1028443_1028511_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 8672}}}, "1028755": {"Id": "1028755", "PostTypeId": "2", "Body": "<p>It's as legal as it's ugly.</p>\n", "LastActivityDate": "2009-06-22T18:36:23.010", "Score": "4", "CreationDate": "2009-06-22T18:36:23.010", "ParentId": "1028443", "CommentCount": "0", "OwnerUserId": "126912"}, "1028887": {"Id": "1028887", "PostTypeId": "2", "Body": "<p>By declaring it as const (which means it can't be changed) and then making it a reference, which implies that someone might change it, seems like bad form, at the very least. Plus, as I am sure you understand, global variables are BAD, and rarely necessary.</p>\n", "LastActivityDate": "2009-06-22T19:06:47.767", "Score": "0", "CreationDate": "2009-06-22T19:06:47.767", "ParentId": "1028443", "CommentCount": "1", "OwnerUserId": "90095"}, "1028511": {"Id": "1028511", "PostTypeId": "2", "Body": "<p>It's completely legal.  It will not be destructed until the program ends.</p>\n<p>EDIT: <em>Yes</em>, it's guaranteed:</p>\n<blockquote>\n<p id=\"so_1028443_1028511_0\">\"All objects which do not have dynamic\n  storage duration, do not have thread\n  storage duration, and are not local\n  have static storage duration. The\n  storage for these objects shall last\n  for the duration of the program\n  (3.6.2, 3.6.3).\"</p>\n</blockquote>\n<p>--  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf\" rel=\"noreferrer\">2008 Working Draft, Standard for Programming Language C++</a>, \u00a7 3.7.1 p. 63</p>\n<p>As Martin noted, this is not the whole answer.  The standard draft further notes (\u00a7 12.2, p. 250-1):</p>\n<blockquote>\n<p id=\"so_1028443_1028511_1\">\"Temporaries of class type are created\n  in various contexts: binding an rvalue\n  to a reference (8.5.3) [...] Even when\n  the creation of the temporary object\n  is avoided (12.8), all the semantic\n  restrictions shall be respected as if\n  the temporary object had been created.\n  [...] Temporary objects are destroyed\n  as the last step in evaluating the\n  full-expression (1.9) that (lexically)\n  contains the point where they were\n  created. [...] There are two contexts\n  in which temporaries are destroyed at\n  a di\ufb00erent point than the end of the\n  full-expression. [...] The second\n  context is when a reference is bound\n  to a temporary. The temporary to which\n  the reference is bound or the\n  temporary that is the complete object\n  of a subobject to which the reference\n  is bound persists for the lifetime of\n  the reference except as speci\ufb01ed\n  below.\"</p>\n</blockquote>\n<p>I tested in g++ if that makes you feel any better. ;)</p>\n", "LastEditorUserId": "47773", "LastActivityDate": "2009-06-22T19:35:56.647", "Score": "14", "CreationDate": "2009-06-22T17:37:43.773", "ParentId": "1028443", "CommentCount": "10", "LastEditDate": "2009-06-22T19:35:56.647", "OwnerUserId": "47773"}, "1028765": {"Id": "1028765", "PostTypeId": "2", "Body": "<p>Yes it is valid and legal.</p>\n<pre><code>const string&amp; SomeConstant = \"This is some constant text\";\n\n// Is equivalent too:\n\nconst string&amp; SomeConstant = std::string(\"This is some constant text\");\n</code></pre>\n<p>Thus you are creating a temporary object.<br>\nThis temporary object is bound to a const&amp; and thus has its lifetime extended to the lifespan of the variable it is bound too (ie longer than the expression in which it was created).</br></p>\n<p>This is guranteed by the standard.</p>\n<h3>Note:</h3>\n<p>Though it is legal. I would not use it. The easist solution would be to convert it into a const std::string.</p>\n<h3>Usage:</h3>\n<p>In this situation because the variable is in global scope it is valid for the full length of the program. So it can be used as soon as execution enters main() and should not be accessed after executiuon exits main().</p>\n<p>Though it technically may be avilable before this your usage of it in constructors/destructors of global objects should be tempered with the known problem of global variable initialization order.</p>\n<h3>Extra Thoughts:</h3>\n<p>This on the other hand will not suffer from the problem:</p>\n<pre><code>char const* SomeConstant = \"This is some constant text\";\n</code></pre>\n<p>And can be used at any point. Just a thought.</p>\n", "LastEditorUserId": "14065", "LastActivityDate": "2009-06-22T19:42:30.407", "Score": "10", "CreationDate": "2009-06-22T18:38:33.163", "ParentId": "1028443", "CommentCount": "1", "LastEditDate": "2009-06-22T19:42:30.407", "OwnerUserId": "14065"}, "1028748": {"Id": "1028748", "PostTypeId": "2", "Body": "<p>It's legal to extend a temporary variable with a <code>const</code> reference, this is used by Alexandrescu's <a href=\"http://www.ddj.com/cpp/184403758\" rel=\"nofollow noreferrer\">ScopeGaurd</a> see this excellent explanation by Herb Sutter called <a href=\"http://www.ddj.com/cpp/184403758\" rel=\"nofollow noreferrer\">A candidate for the \"Most important <code>const</code>\"</a>. </p>\n<p>That being said this specific case is an abuse of this feature of C++ and the reference should be removed leaving a plain <code>const string</code>.</p>\n", "LastActivityDate": "2009-06-22T18:35:18.410", "Score": "2", "CreationDate": "2009-06-22T18:35:18.410", "ParentId": "1028443", "CommentCount": "0", "OwnerUserId": "3848"}});