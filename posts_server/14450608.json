post_cb({"bq_ids": {"n4140": {"so_14450608_14450664_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5965}}, "n3337": {"so_14450608_14450608_0": {"length": 14, "quality": 0.6363636363636364, "section_id": 5732}, "so_14450608_14450608_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5732}}, "n4659": {"so_14450608_14450608_1": {"length": 9, "quality": 0.6, "section_id": 7667}}}, "19377494": {"Id": "19377494", "PostTypeId": "2", "Body": "<p>GCC 4.8.1 (and possibly earlier) and clang 3.3 already implements it; fixing DR975.</p>\n<p>There is now a proposal (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3386.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3386.html</a>) to get it into C++1y</p>\n", "LastActivityDate": "2013-10-15T09:19:11.670", "CommentCount": "1", "CreationDate": "2013-10-15T09:19:11.670", "ParentId": "14450608", "Score": "1", "OwnerUserId": "2064196"}, "14450608": {"ViewCount": "866", "Body": "<p>I've been writing code, and I've recently found out that g++ doesn't warn me about a certain class of issue: per C++11 5.1.2.4, if your lambda is not a single return statement then the return type must be declared as a trailing-return-type or be void.</p>\n<p>Although g++ is allowed to compile invalid code if it makes enough sense, is there a way to either turn this behavior off (allowed with <code>-fpedantic</code> in g++-4.7) or all least warn about it?</p>\n<p>Example code:</p>\n<pre><code>[]() { return 0; } //is fine\n[&amp;a]() { a++; return 0; } //is not fine but g++ doesn't warn me\n[&amp;a]() -&gt; int {a++; return 0; } //is fine again\n</code></pre>\n<p>C++11 5.1.2.4</p>\n<blockquote>\n<p id=\"so_14450608_14450608_0\">An implementation shall not add members of rvalue reference type to the closure type.\n  If a lambda-expression does not include a lambda-declarator, it is as if the lambda-declarator were (). If a lambda-expression does not include a trailing-return-type, it is as if the trailing-return-type denotes the following type:</p>\n<p id=\"so_14450608_14450608_1\">\u2014 if the compound-statement is of the form<br>\n  { attribute-specifier-seq(opt) return expression ; }<br>\n  the type of the returned expression after lvalue-to-rvalue conversion (4.1), array-to-pointer conversion (4.2), and function-to-pointer conversion (4.3);</br></br></p>\n<p id=\"so_14450608_14450608_2\">\u2014 otherwise, void.</p>\n</blockquote>\n", "AcceptedAnswerId": "14450664", "Title": "Return type deduction with multi-statement lambdas", "CreationDate": "2013-01-22T02:27:01.657", "Id": "14450608", "CommentCount": "10", "LastEditDate": "2013-01-22T02:40:15.953", "PostTypeId": "1", "LastEditorUserId": "483486", "LastActivityDate": "2013-10-15T09:19:11.670", "Score": "8", "OwnerUserId": "483486", "Tags": "<c++><c++11><lambda><g++><trailing-return-type>", "AnswerCount": "2"}, "14450664": {"Id": "14450664", "PostTypeId": "2", "Body": "<p>That is because it is a defect in the standard, and will be changed (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#975\" rel=\"nofollow\">DR 975</a>):</p>\n<blockquote>\n<p id=\"so_14450608_14450664_0\">975 Restrictions on return type deduction for lambdas </p>\n<p id=\"so_14450608_14450664_1\">There does not appear to be any technical difficulty that would\n  require the current restriction that the return type of a lambda can\n  be deduced only if the body of the lambda consists of a single return\n  statement. In particular, multiple return statements could be\n  permitted if they all return the same type.</p>\n</blockquote>\n<p>I doubt if there is a way to turn it off.</p>\n", "LastEditorUserId": "906773", "LastActivityDate": "2013-01-22T20:35:04.500", "Score": "11", "CreationDate": "2013-01-22T02:35:37.410", "ParentId": "14450608", "CommentCount": "2", "OwnerUserId": "906773", "LastEditDate": "2013-01-22T20:35:04.500"}});