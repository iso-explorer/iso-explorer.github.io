post_cb({"20444106": {"ParentId": "20443919", "CommentCount": "1", "Body": "<p>In paragraph 4 of 5.16 [expr.cond] in the standard says:</p>\n<blockquote>\n<p id=\"so_20443919_20444106_0\">If the second and third operands are glvalues of the same value category and have the same type, the result\n  is of that type and value category [...]</p>\n</blockquote>\n<p>So the result should be an lvalue to type array of 1 <code>int</code> in your case.</p>\n<p>Paragraph 5 starts with \"Otherwise, the result is a prvalue\" which is obviously the other case to the \"If...\" of paragraph 4.</p>\n<p>In my reading paragraph 6 also doesn't apply.</p>\n<blockquote>\n<p id=\"so_20443919_20444106_1\">Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the second and third operands.</p>\n</blockquote>\n<p>If we've determined that the result is a glvalue then there's no way that the after an lvalue-to-rvalue conversion we have a valid object to use as the result so paragraph 6 <em>must</em> be following on the \"Otherwise...\" started in paragraph 5. To be fair, I don't think that this is completely unambiguous even if an alternative reading to mine would result in greater inconsistency.</p>\n<p>tl;dr: I think that gcc is correct in this case.</p>\n<p>A workaround could be to use: <code>*(true ? &amp;ary1 : &amp;ary2)</code> instead.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "20444106", "Score": "2", "CreationDate": "2013-12-07T17:10:02.353", "LastActivityDate": "2013-12-07T17:10:02.353"}, "bq_ids": {"n4140": {"so_20443919_20444106_1": {"section_id": 6172, "quality": 1.0, "length": 8}, "so_20443919_20444106_0": {"section_id": 6170, "quality": 1.0, "length": 14}}, "n3337": {"so_20443919_20444106_1": {"section_id": 5933, "quality": 1.0, "length": 8}, "so_20443919_20444106_0": {"section_id": 5931, "quality": 1.0, "length": 14}}, "n4659": {"so_20443919_20444106_1": {"section_id": 7670, "quality": 1.0, "length": 8}, "so_20443919_20444106_0": {"section_id": 7668, "quality": 1.0, "length": 14}}}, "20443919": {"CommentCount": "1", "AcceptedAnswerId": "20444106", "CreationDate": "2013-12-07T16:52:17.667", "LastActivityDate": "2013-12-07T17:10:02.353", "PostTypeId": "1", "ViewCount": "187", "FavoriteCount": "1", "Title": "Array-to-pointer conversion in VC++", "Id": "20443919", "Score": "2", "Body": "<p>This code can't be compiled with VC++2012.</p>\n<pre><code>struct Test\n{\n    int ary1[1];\n    int ary2[1];\n    void func() {\n        int (&amp;ref)[1] = ( true ? ary1 : ary2 );\n     }\n};\n\nint main() {}\n</code></pre>\n<p>The compiler says:</p>\n<pre><code>error C2440: 'initializing' : cannot convert from 'int *' to 'int (&amp;)[1]'\n</code></pre>\n<p>Ternary Operator makes Array-to-pointer conversion.</p>\n<p>However, GCC never shows this error.\nWhat's the correct behaviour?</p>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "1205869", "AnswerCount": "1"}});