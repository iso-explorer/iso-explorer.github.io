post_cb({"bq_ids": {"n4140": {"so_30206864_30207180_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 6003}, "so_30206864_30207180_2": {"length": 4, "quality": 1.0, "section_id": 6003}, "so_30206864_30207180_0": {"length": 29, "quality": 0.90625, "section_id": 6002}}, "n3337": {"so_30206864_30207180_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 5771}, "so_30206864_30207180_2": {"length": 4, "quality": 1.0, "section_id": 5771}, "so_30206864_30207180_0": {"length": 29, "quality": 0.90625, "section_id": 5770}}, "n4659": {"so_30206864_30207180_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 7502}, "so_30206864_30207180_2": {"length": 4, "quality": 1.0, "section_id": 7502}, "so_30206864_30207180_0": {"length": 29, "quality": 0.90625, "section_id": 7501}}}, "30207180": {"Id": "30207180", "PostTypeId": "2", "Body": "<p>This is indeed valid C++ (and has been since C++98, as far as I know), and known as a <em>pseudo-destructor call</em>. N4431 \u00a75.2.4 [expr.pseudo]:</p>\n<blockquote>\n<p id=\"so_30206864_30207180_0\">1 The use of a <em>pseudo-destructor-name</em> after a dot <code>.</code> or arrow <code>-&gt;</code>\n  operator represents the destructor for the non-class type denoted by\n  <em>type-name</em> or <em>decltype-specifier</em>. The result shall only be used as the operand for the function call operator <code>()</code>, and the result of\n  such a call has type <code>void</code>. The only effect is the evaluation of the\n  <em>postfix-expression</em> before the dot or arrow.</p>\n<p id=\"so_30206864_30207180_1\">2 The left-hand side of the dot operator shall be of scalar type. The\n  left-hand side of the arrow operator shall be of pointer to scalar\n  type. This scalar type is the object type. The cv-unqualified versions\n  of the object type and of the type designated by the\n  <em>pseudo-destructor-name</em> shall be the same type. Furthermore, the two <em>type-names</em> in a <em>pseudo-destructor-name</em> of the form</p>\n<pre><code>nested-name-specifier_opt type-name :: ~ type-name\n</code></pre>\n<p id=\"so_30206864_30207180_2\">shall designate the same scalar type.</p>\n</blockquote>\n<p>A <em>pseudo-destructor-name</em> is one of (\u00a75.2 [expr.post]):</p>\n<pre><code>nested-name-specifier_opt type-name :: ~ type-name\nnested-name-specifier template simple-template-id :: ~ type-name\n~ type-name\n~ decltype-specifier\n</code></pre>\n<p>While a <em>type-name</em> is one of (\u00a77.1.6.2 [dcl.type.simple])</p>\n<pre><code>class-name\nenum-name\ntypedef-name\nsimple-template-id\n</code></pre>\n<p><code>bool</code> is not a <em>type-name</em>, so the <code>~bool()</code> version is a syntax error. Inside a template, a template type parameter is a <em>typedef-name</em> (\u00a714.1 [temp.param]/p3), which is a <em>type-name</em>, so the <code>~T()</code> version compiles.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-05-13T06:46:06.783", "Score": "11", "CreationDate": "2015-05-13T06:26:29.720", "ParentId": "30206864", "CommentCount": "8", "OwnerUserId": "2756719", "LastEditDate": "2015-05-13T06:46:06.783"}, "30206864": {"ViewCount": "308", "Body": "<p>The C++ program (somewhat unexpectedly, at first, to me) compiles and runs fine, except for the line commented at the end of <code>main()</code>, which is a compile-time error if it is uncommented.</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;iostream&gt;\n\nstruct Foo {\n    int x;\n};\n\ntemplate &lt;typename T&gt;\nvoid create(char *buffer)\n{\n    std::cout &lt;&lt; \"creating \" &lt;&lt; typeid(T).name() &lt;&lt; std::endl;\n    new (buffer) T();\n}\n\ntemplate &lt;typename T&gt;\nvoid destroy(char *buffer)\n{\n    std::cout &lt;&lt; \"destroying \" &lt;&lt; typeid(T).name() &lt;&lt; std::endl;\n    ((T*)buffer)-&gt;~T();\n}\n\nint main(int argc, char **argv)\n{\n    char buffer[sizeof(Foo) &gt; sizeof(bool) ? sizeof(Foo) : sizeof(bool)];\n\n    // create/destroy Foo via template function calls\n    create&lt;Foo&gt;(buffer);\n    destroy&lt;Foo&gt;(buffer);\n    // now do the above explicitly...\n    new (buffer) Foo();\n    ((Foo*)buffer)-&gt;~Foo();\n\n    // create/destroy bool via template function calls\n    create&lt;bool&gt;(buffer);\n    destroy&lt;bool&gt;(buffer);\n    // now do the above explicitly...\n    new (buffer) bool();\n    // ((bool*)buffer)-&gt;~bool(); // oops, doesn't work\n\n    return 0;\n}\n</code></pre>\n<p>I gather from this that C++ (or at least g++'s idea of C++) allows an \"explicit destructor call\" of a template parameter type, even when manually doing the type replacement oneself results in a syntax error (since <code>bool</code> doesn't really actually have a destructor to call).</p>\n<p>To be more explicit, the line:</p>\n<pre><code>((T*)buffer)-&gt;~T();\n</code></pre>\n<p>compiles and runs fine when T is instatiated on a <code>bool</code>, but doing the same thing with an actual <code>bool</code>:</p>\n<pre><code>((bool*)buffer)-&gt;~bool();\n</code></pre>\n<p>is a syntax error.</p>\n<p>I'm discovered this behavior as I was doing template metaprogramming and find it a very helpful, so I'm guessing it's standard and was added specifically to handle cases like the one I have above. Does anyone know for sure if this is actually the case, and when this behavior was standardized if it is?</p>\n<p>In addition, can anyone point to what the exact wording in the standard is that allows this, and the scope of the situations it allows? (I'm not adept at reading standardese so I have a hard time figuring this out myself.)</p>\n", "AcceptedAnswerId": "30207180", "Title": "Explicit call to destructor of template parameter type, even when instantiated on a builtin", "CreationDate": "2015-05-13T06:05:23.283", "Id": "30206864", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-05-13T06:12:27.140", "LastEditorUserId": "4894016", "LastActivityDate": "2015-05-13T06:46:06.783", "Score": "12", "OwnerUserId": "4894016", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});