post_cb({"14492942": {"ParentId": "14492894", "CommentCount": "11", "Body": "<p>No, this is not necessarily possible.  The C++ ISO standard explicitly guarantees contiguous storage of elements in a <code>std::vector</code>, so you can safely take the address of the first element and then use that pointer as if you were pointing at a raw array.  Other containers in the standard library do not have this guarantee.</p>\n<p>The reason for this is to efficiently support most operations on a <code>std::set</code>, the implementation needs to use complex data structures like balanced binary search trees to store and organize the data.  These structures are inherently nonlinear and require nodes to be allocated and linked together.  Efficiently getting this to work with the elements in a flat array would be difficult, if not impossible, in the time constraints laid out by the standard (amortized O(log n) for most operations.)</p>\n<p><strong>EDIT</strong>: In response to your question - there is no way to build a <code>std::vector</code> from a <code>std::set</code> without some code somewhere iterating over the set and copying the elements over.  You can do this without explicitly using any loops yourself by using the <code>std::vector</code> range constructor:</p>\n<pre><code>std::vector&lt;T&gt; vec(mySet.begin(), mySet.end());\n</code></pre>\n<p>Hope this helps!</p>\n", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "14492942", "Score": "6", "CreationDate": "2013-01-24T02:29:48.697", "LastActivityDate": "2013-01-24T02:29:48.697"}, "14492894": {"CommentCount": "5", "ViewCount": "2223", "PostTypeId": "1", "LastEditorUserId": "1103122", "CreationDate": "2013-01-24T02:24:13.803", "LastActivityDate": "2013-01-24T03:32:40.713", "Title": "Get pointer to raw data in set like &(vector[0])", "AcceptedAnswerId": "14492942", "LastEditDate": "2013-01-24T02:32:58.187", "Id": "14492894", "Score": "2", "Body": "<p>To get the pointer to the data in a vector we can use </p>\n<pre><code>vector&lt;double&gt; Vec;    \ndouble* Array_Pointer = &amp;(Vec[0]);\nFunction(Array_Pointer);\n</code></pre>\n<p>Is that possible to get the pointer to the data in a <strong>set</strong>? Can I use that as array pointer like above?</p>\n<hr>\n<p>If not possible, what is the best way to make a vector out of set? I mean without loop over all elements.</p>\n</hr>", "Tags": "<c++><pointers><vector><set><containers>", "OwnerUserId": "1103122", "AnswerCount": "2"}, "14493258": {"ParentId": "14492894", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No. It's not possible to implement <code>set</code> in such a way that you can do this.</p>\n<p>If you implement <code>set</code> in such a way that elements are stored in a single array, then when you add more elements, that array will inevitably need to be reallocated at some point. At that time, any references to existing elements will be invalidated.</p>\n<p>One of features of <code>set</code> is that it <em>guarantees</em> that references to elements will never be invalidated if you add (or remove) other elements. As stated in [associative.reqmts]:</p>\n<blockquote>\n<p id=\"so_14492894_14493258_0\">The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators and references to the container, and the <code>erase</code> members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>So it's <em>impossible</em> to implement <code>set</code> in such a way that all of the elements of the set are stored in a single array.</p>\n<p>Note that this has nothing to do with the efficiency requirements such as O(log n) insert/delete/lookup (if you squint really hard and allow for amortized O(log n) insertion time, at least), or maintaining sorted order, or anything like that. If it was just these, they could easily be handled with a data structure on top of the underlying elements, and the elements themselves could be stored in an array. It also doesn't even have anything to do with guarantees about <em>iterator</em> invalidation, since iterators are abstract.</p>\n<p>No, the only thing holding you back is the reference invalidation requirement.</p>\n", "OwnerUserId": "2006002", "LastEditorUserId": "2006002", "LastEditDate": "2013-01-24T03:32:40.713", "Id": "14493258", "Score": "1", "CreationDate": "2013-01-24T03:05:53.370", "LastActivityDate": "2013-01-24T03:32:40.713"}, "bq_ids": {"n4140": {"so_14492894_14493258_0": {"section_id": 745, "quality": 0.9375, "length": 15}}, "n3337": {"so_14492894_14493258_0": {"section_id": 734, "quality": 0.9375, "length": 15}}, "n4659": {"so_14492894_14493258_0": {"section_id": 803, "quality": 0.9375, "length": 15}}}});