post_cb({"38795374": {"CommentCount": "8", "AcceptedAnswerId": "38796733", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-08-05T18:03:26.227", "LastActivityDate": "2016-08-05T19:42:49.153", "LastEditDate": "2017-05-23T12:16:31.537", "ViewCount": "152", "FavoriteCount": "0", "Title": "Is This Actually Ambiguous?", "Id": "38795374", "Score": "5", "Body": "<p>So I am aware that braces in code can mean more than just an <code>initializer_list</code>: <a href=\"https://stackoverflow.com/q/37682392/2642059\">What Is a Curly-Brace Enclosed List If Not an intializer_list?</a></p>\n<p>But what should they <em>default</em> to?</p>\n<p>For example, say that I define an overloaded function:</p>\n<pre><code>void foo(const initializer_list&lt;int&gt;&amp; row_vector) { cout &lt;&lt; size(row_vector) &lt;&lt; \"x1 - FIRST\\n\"; }\nvoid foo(const initializer_list&lt;initializer_list&lt;int&gt;&gt;&amp; matrix) { cout &lt;&lt; size(matrix) &lt;&lt; 'x' &lt;&lt; size(*begin(matrix)) &lt;&lt; \" - SECOND\\n\"; }\n</code></pre>\n<p>If I call <code>foo({ 1, 2, 3 })</code> the 1<sup>st</sup> will obviously be called. And if I call <code>foo({ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } })</code> the 2<sup>nd</sup> will obviously be called.</p>\n<p>But what if I call:</p>\n<pre><code>foo({ { 1 }, { 2 }, { 3 } })\n</code></pre>\n<p>Are those nested braces <code>int</code>-initializers or <code>initializer_list&lt;int&gt;</code> intializers? <a href=\"http://ideone.com/3DsWe7\" rel=\"nofollow noreferrer\">gcc says it's ambiguous</a> But if you take that code and run it on <a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow noreferrer\">http://webcompiler.cloudapp.net/</a> Visual Studio says it's just constructing an <code>initializer_list&lt;int&gt;</code>. Who's right? Should there be a default here?</p>\n", "Tags": "<c++><nested><initializer-list><ambiguous><brace-initialization>", "OwnerUserId": "2642059", "AnswerCount": "1"}, "38796733": {"ParentId": "38795374", "CommentCount": "3", "Body": "<p>The rule is in <a href=\"http://eel.is/c++draft/over.ics.list\">[over.ics.list]</a>:</p>\n<blockquote>\n<p id=\"so_38795374_38796733_0\">Otherwise, if the parameter type is <code>std::initializer_list&lt;X&gt;</code> and all the elements of the initializer list can be implicitly converted to <code>X</code>, the implicit conversion sequence is the worst conversion necessary to convert an element of the list to <code>X</code>, or if the initializer list has no elements, the identity conversion.</p>\n</blockquote>\n<p>In both your overloads, the worst conversion necessary is the identity conversion. So we have two implicit conversion sequences with rank identity. There is a rule in <a href=\"http://eel.is/c++draft/over.match.best#over.ics.rank-3\">[over.match.best]</a> which prefers a list-initialization of a <code>std::initializer_list&lt;X&gt;</code> over alternatives (so <code>std::initializer_list&lt;int&gt;</code> is preferred to <code>int</code> for <code>{1}</code>), but there nothing to suggest that this rule should apply recursively. </p>\n<p>Since there's nothing to disambiguate the two conversion sequences, the call is ambiguous. gcc and clang are correct to reject.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "38796733", "Score": "6", "CreationDate": "2016-08-05T19:42:49.153", "LastActivityDate": "2016-08-05T19:42:49.153"}, "bq_ids": {"n4140": {"so_38795374_38796733_0": {"section_id": 630, "quality": 0.96, "length": 24}}, "n3337": {"so_38795374_38796733_0": {"section_id": 621, "quality": 0.8, "length": 20}}, "n4659": {"so_38795374_38796733_0": {"section_id": 658, "quality": 1.0, "length": 25}}}});