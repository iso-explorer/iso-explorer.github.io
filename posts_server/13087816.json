post_cb({"bq_ids": {"n4140": {"so_13087816_13087876_0": {"length": 18, "quality": 0.9, "section_id": 6146}}, "n3337": {"so_13087816_13087876_0": {"length": 18, "quality": 0.9, "section_id": 5909}}, "n4659": {"so_13087816_13087876_0": {"length": 18, "quality": 0.9, "section_id": 7642}}}, "13087963": {"Id": "13087963", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13087816_13087963_0\">According to the C++ specification if you shift a 32-bit value left by 32, the result is always 0</p>\n</blockquote>\n<p>No, that's not what the standard says. It is undefined behavior to shift a 32-bit type by 32 or more (5.8/1)</p>\n<p>Since it is undefined behavior to shift by 256 bits on ARM (which has no 257-bit-or-greater type), the CPU is perfectly entitled to wrap at that point.</p>\n", "LastActivityDate": "2012-10-26T13:33:49.093", "Score": "3", "CreationDate": "2012-10-26T13:33:49.093", "ParentId": "13087816", "CommentCount": "0", "OwnerUserId": "13005"}, "13087876": {"Id": "13087876", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13087816_13087876_0\">The type of the result is that of the promoted left operand. The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>This is from \u00a75.8/1 from C++11. If your ints are 32bit, you can't shift by 32 (right- or left-shift, regardless of the signedness of the left operand).</p>\n", "LastActivityDate": "2012-10-26T13:26:30.010", "Score": "3", "CreationDate": "2012-10-26T13:26:30.010", "ParentId": "13087816", "CommentCount": "1", "OwnerUserId": "635608"}, "13087940": {"Id": "13087940", "PostTypeId": "2", "Body": "<p>If you use the x86 or x64 machine instructions for shifting the value, they will mask off the shift amount and only use the lower bits for the actual shift. Some other hardware might not do that.</p>\n<p>That's why it is undefined.</p>\n<p>In your example with literals <code>1 &lt;&lt; 32</code>, it is likely that the compiler computes the value and that's why it is <code>0</code>. Trying the operation on real x86 hardware, you would get <code>1</code>.</p>\n", "LastActivityDate": "2012-10-26T13:32:15.637", "Score": "4", "CreationDate": "2012-10-26T13:32:15.637", "ParentId": "13087816", "CommentCount": "0", "OwnerUserId": "597607"}, "13087816": {"ViewCount": "834", "Body": "<p>I'm confused by something I read in the Shift Operators section of an <a href=\"http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx\" rel=\"nofollow\">article on undefined C++ behavior</a>.</p>\n<blockquote>\n<p id=\"so_13087816_13087816_0\">On the ARM architecture, the shift operators always behave as if they take place in a 256-bit pattern space, regardless of the operand size--that is, the pattern repeats, or \"wraps around\", only every 256 positions. Another way of thinking of this is that the pattern is shifted the specified number of positions modulo 256. Then, of course, the result contains just the least-significant bits of the pattern space.</p>\n</blockquote>\n<p>The tables are especially strange:</p>\n<pre><code>Given a 32-bit integer with a value of 1:\n+-----------------------------------+\n| Shift left    ARM    x86    x64   |\n+-----------------------------------+\n| 32            0      1      1     |\n| 48            0      32768  32768 |\n| 64            0      1      1     |\n+-----------------------------------+\n</code></pre>\n<p>What are these values, and why do they matter?</p>\n<p>The <a href=\"http://msdn.microsoft.com/en-us/library/336xbhcz\" rel=\"nofollow\">shift operators</a> don't wrap. <strike>According to the C++ specification if you shift a 32-bit value left by 32, the result is always 0.</strike> <em>(EDIT: I'm wrong, see the answers!)</em> So what is this article getting at? What is the undefined behavior?</p>\n<p>When I run this code on x86 I get <code>0</code>:</p>\n<pre><code>printf(\"%d\", 1 &lt;&lt; 32);\n</code></pre>\n<p>Supposedly <a href=\"http://msdn.microsoft.com/en-us/library/cx0bb1cy\" rel=\"nofollow\">this code snippet</a> illustrates the problem:</p>\n<pre><code>// C4293.cpp\n// compile with: /c /W1\nunsigned __int64 combine (unsigned lo, unsigned hi) {\n\n    return (hi &lt;&lt; 32) | lo;   // C4293\n\n    // try the following line instead\n    // return ( (unsigned __int64)hi &lt;&lt; 32) | lo;\n}\n</code></pre>\n<p>I would expect the returned value to be <code>lo</code>, since the programmer shifted away all the <code>hi</code> bits. A warning is nice, since this was probably a mistake, but I don't see any undefined behavior...</p>\n", "AcceptedAnswerId": "13087940", "Title": "Confused by undefined C++ shift operator behavior and wrapping \"pattern space\"", "CreationDate": "2012-10-26T13:23:27.907", "Id": "13087816", "CommentCount": "0", "LastEditDate": "2012-10-26T14:51:34.553", "PostTypeId": "1", "LastEditorUserId": "111327", "LastActivityDate": "2012-10-26T14:51:34.553", "Score": "2", "OwnerUserId": "111327", "Tags": "<c++><undefined-behavior><bit-shift>", "AnswerCount": "3"}});