post_cb({"12789376": {"CommentCount": "0", "AcceptedAnswerId": "12798526", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2012-10-08T20:58:22.780", "LastActivityDate": "2015-01-28T06:10:41.387", "LastEditDate": "2012-10-08T21:03:46.773", "ViewCount": "3719", "FavoriteCount": "2", "Title": "Are `char16_t` and `char32_t` misnomers?", "Id": "12789376", "Score": "8", "Body": "<p><sup><strong>NB:</strong> I'm sure someone will call this subjective, but I reckon it's fairly tangible.</sup></p>\n<p>C++11 gives us new <code>basic_string</code> types <code>std::u16string</code> and <code>std::u32string</code>, type aliases for <code>std::basic_string&lt;char16_t&gt;</code> and <code>std::basic_string&lt;char32_t&gt;</code>, respectively.</p>\n<p>The use of the substrings <code>\"u16\"</code> and <code>\"u32\"</code> to me in this context rather implies \"UTF-16\" and \"UTF-32\", which would be silly since C++ of course has no concept of text encodings.</p>\n<p>The names in fact reflect the character types <code>char16_t</code> and <code>char32_t</code>, but these seem misnamed. They <em>are</em> unsigned, due to the unsignedness of their underlying types:</p>\n<blockquote>\n<p id=\"so_12789376_12789376_0\"><code>[C++11: 3.9.1/5]:</code> [..] Types <code>char16_t</code> and <code>char32_t</code> denote distinct types with the same size, signedness, and alignment as <code>uint_least16_t</code> and <code>uint_least32_t</code>, respectively [..]</p>\n</blockquote>\n<p>But then it seems to me that these names violate the convention that such unsigned types have names beginning <code>'u'</code>, and that the use of numbers like <code>16</code> unqualified by terms like <code>least</code> indicate fixed-width types.</p>\n<p>My question, then, is this: <strong>am I imagining things, or are these names fundamentally flawed?</strong></p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "560648", "AnswerCount": "3"}, "12792039": {"ParentId": "12789376", "CommentCount": "6", "Body": "<p>They are <em>not</em> fundamentally flawed, by definition - they are part of the standard. If that offends your sensibilities then you must find a way to deal with it. The time to make this argument was before the latest standard was ratified, and that time has long passed.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "12792039", "Score": "-3", "CreationDate": "2012-10-09T02:24:25.793", "LastActivityDate": "2012-10-09T02:24:25.793"}, "12798526": {"ParentId": "12789376", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>The naming convention to which you refer (<code>uint32_t</code>, <code>int_fast32_t</code>, etc.) is actually only used for <em>typedefs</em>, and not for primitive types. The primitive integer types are {signed, unsigned} {char, short, int, long, long long}, {as opposed to float or decimal types} ...</p>\n<p>However, in addition to those integer types, there are four <em>distinct</em>, unique, fundamental types, <code>char</code>, <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code>, which are the types of the respective literals <code>''</code>, <code>L''</code>, <code>u''</code> and <code>U''</code> and are used for alpha-numeric type data, and similarly for arrays of those. Those types are of course also integer types, and thus they will have the same layout at <em>some</em> of the arithmetic integer types,  but the language makes a very clear distinction between the former, arithmetic types (which you would use for computations) and the latter \"character\" types which form the basic unit of some type of I/O data.</p>\n<p>(I've previously rambled about those new types <a href=\"https://stackoverflow.com/questions/6796157/unicode-encoding-for-string-literals-in-c11\">here</a> and <a href=\"https://stackoverflow.com/questions/6300804/wchars-encodings-standards-and-portability\">here</a>.)</p>\n<p>So, I think that <code>char16_t</code> and <code>char32_t</code> are actually very aptly named to reflect the fact that they belong to the \"char\" family of integer types.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:43.453", "Id": "12798526", "Score": "11", "CreationDate": "2012-10-09T10:54:31.737", "LastActivityDate": "2015-01-28T06:10:41.387"}, "12792161": {"ParentId": "12789376", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_12789376_12792161_0\">are these names fundamentally flawed?</p>\n</blockquote>\n<p>(I think most of this question has been answered in the comments, but to make an answer) No, not at all. <code>char16_t</code> and <code>char32_t</code> were created for a specific purpose. To have data type support for all Unicode encoding formats (UTF-8 is covered by <code>char</code>) while keeping them as generic as possible to not limit them to only Unicode. Whether they are unsigned or have a fixed-width is not directly related to what they are: <strong>character data types</strong>. Types which hold and represent <a href=\"http://en.wikipedia.org/wiki/Character_%28computing%29\" rel=\"nofollow\">characters</a>. Signedness is a property of data types that represent <em>numbers</em> not characters. The types are meant to <strong>store characters</strong>, either a 16 bit or 32 bit based character data, nothing more or less.</p>\n", "OwnerUserId": "906773", "PostTypeId": "2", "Id": "12792161", "Score": "4", "CreationDate": "2012-10-09T02:42:42.827", "LastActivityDate": "2012-10-09T02:42:42.827"}, "bq_ids": {"n4140": {"so_12789376_12789376_0": {"section_id": 7214, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_12789376_12789376_0": {"section_id": 6958, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_12789376_12789376_0": {"section_id": 8723, "quality": 0.8666666666666667, "length": 13}}}});