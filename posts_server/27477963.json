post_cb({"27477963": {"CommentCount": "2", "ViewCount": "72", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "CreationDate": "2014-12-15T05:34:40.997", "LastActivityDate": "2014-12-15T10:00:04.043", "LastEditDate": "2014-12-15T05:44:26.713", "AcceptedAnswerId": "27478480", "LastEditorDisplayName": "user2953119", "Title": "Friend declaration and the entity it denotes", "Id": "27477963", "Score": "3", "Body": "<p>I have one question about friend functions/classes. Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\nprivate:\n    int a = 5;\n    friend int foo(A a);\n};\n\nint foo(A a)\n{\n    return a.a;\n}\n\nint a = foo(A());\n\nint main(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/aa91c35f58d77d58\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>It works fine and both <code>int foo()</code> within class scope and global scope refer to the same entity. Although, the declaration of <code>int foo()</code> within the class scope didn't introduce a name into the global scope. If it were then we would recieve a linker-error intstead of compile-error in the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\nprivate:\n    int a = 5;\n    friend int foo();\n};\n\nint a = foo(); //undeclared foo\n\nint main(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/22c496def0c4fc76\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>I can't find explanation about this in the Standard. What it says is <code>N3797:11.3/6  [class.friend]</code>:</p>\n<blockquote>\n<p id=\"so_27477963_27477963_0\">A function can be <em>defined</em> in a friend declaration of a class if and\n  only if the class is a non-local class (9.8), the function name is\n  unqualified, and the function has namespace scope.</p>\n</blockquote>\n<p>So, it explains why the following code works fine:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\nprivate:\n    int a = 5;\n    friend int foo(A a)\n    {\n        return a.a;\n    }\n};\n\nint a = foo(A());\n\nint main(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/b68696d1e6ad8d28\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>We defined the function in the friend declaration and, as the Standard said it became the member of the global namespace. But the rule covers <strong><em>the defintion</em></strong>, not declaration. Obviously, that's not any declaration is definition. So we can't apply one to the first example.</p>\n", "Tags": "<c++><class><friend>", "AnswerCount": "1"}, "27478480": {"ParentId": "27477963", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In the last program</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\nprivate:\n    int a = 5;\n    friend int foo(A a)\n    {\n        return a.a;\n    }\n};\n\nint a = foo(A());\n\nint main(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n</code></pre>\n<p>The compiler finds definition of function <code>foo</code> only due to the argument dependent lookup.\nYou should consider the following section of the C++ Standard</p>\n<p>3.4.2 Argument-dependent name lookup</p>\n<blockquote>\n<p id=\"so_27477963_27478480_0\">2 For each argument type T in the function call, there is a set of\n  zero or more associated namespaces and a set of zero or more\n  associated classes to be considered. <strong>The sets of namespaces and\n  classes is determined entirely by the types of the function\n  arguments</strong> (and the namespace of any template template argument).\n  Typedef names and using-declarations used to specify the types do not\n  contribute to this set.</p>\n</blockquote>\n<p>Thus in this program the compiler searches the function in the scope of the class because the argument of the function has the class type. If you will change the function definition for example the following way then the compiler will not find the function.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\npublic:\n    A( int x ) : a( 2 * x ) {}\n\nprivate:\n    int a;\n    friend int foo( int x )\n    {\n        A a( x );\n\n        return a.a;\n    }\n};\n\nint a = foo( 10 );\n\n\nint main() \n{\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>But if you add a declaration of the function in the scope where the class is defined then the compiler will see the function</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\npublic:\n    A( int x ) : a( 2 * x ) {}\n\nprivate:\n    int a;\n    friend int foo( int x )\n    {\n        A a( x );\n\n        return a.a;\n    }\n};\n\nint foo( int );\n\nint a = foo( 10 );\n\n\nint main() \n{\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Here the program output is</p>\n<pre><code>20\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-12-15T10:00:04.043", "Id": "27478480", "Score": "0", "CreationDate": "2014-12-15T06:27:12.840", "LastActivityDate": "2014-12-15T10:00:04.043"}, "bq_ids": {"n4140": {"so_27477963_27478480_0": {"section_id": 7104, "quality": 0.9459459459459459, "length": 35}, "so_27477963_27477963_0": {"section_id": 6689, "quality": 1.0, "length": 15}}, "n3337": {"so_27477963_27478480_0": {"section_id": 6848, "quality": 0.9459459459459459, "length": 35}, "so_27477963_27477963_0": {"section_id": 6444, "quality": 1.0, "length": 15}}, "n4659": {"so_27477963_27478480_0": {"section_id": 8605, "quality": 0.8378378378378378, "length": 31}, "so_27477963_27477963_0": {"section_id": 8164, "quality": 1.0, "length": 15}}}});