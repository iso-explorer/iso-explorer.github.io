post_cb({"41094239": {"Id": "41094239", "PostTypeId": "2", "Body": "<p>What you are doing is illegal in C++ language, meaning that the behavior of your <code>b_memcpy</code> object is undefined. The latter means that any behavior is \"correct\" and your expectations are completely unfounded. There's not much point in trying to analyze undefined behavior - it is not supposed to follow any logic.</p>\n<p>In practice, it is quite possible that your manipulations with <code>memcpy</code> did actually copy <code>Derived</code>'s virtual table pointer to <code>b_memcpy</code> object. And your experiments with <code>b_ref</code> confirm that. However, when a virtual method is called though an immediate object (as is the case with <code>b_memcpy.vfunc()</code> call) most implementations optimize away the access to the virtual table and perform a <em>direct</em> (<em>non-virtual</em>) call to the target function. Formal rules of the language state that no legal action can ever make <code>b_memcpy.vfunc()</code> call to dispatch to anything other than <code>Base::vfunc()</code>, which is why the compiler can safely replace this call with a direct call to <code>Base::vfunc()</code>. This is why any virtual table manipulations will normally have no effect on <code>b_memcpy.vfunc()</code> call.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-12-12T04:50:36.860", "Score": "2", "CreationDate": "2016-12-12T04:29:59.190", "ParentId": "41094195", "CommentCount": "4", "OwnerUserId": "187690", "LastEditDate": "2016-12-12T04:50:36.860"}, "bq_ids": {"n4140": {"so_41094195_41906951_2": {"length": 9, "quality": 1.0, "section_id": 7195}, "so_41094195_41906951_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_41094195_41906951_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 7195}, "so_41094195_41906951_1": {"length": 10, "quality": 1.0, "section_id": 7195}, "so_41094195_41906951_3": {"length": 16, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_41094195_41906951_2": {"length": 9, "quality": 1.0, "section_id": 6939}, "so_41094195_41906951_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 6939}, "so_41094195_41906951_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_41094195_41906951_1": {"length": 10, "quality": 1.0, "section_id": 6939}, "so_41094195_41906951_3": {"length": 16, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_41094195_41906951_2": {"length": 9, "quality": 1.0, "section_id": 8704}, "so_41094195_41906951_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 8704}, "so_41094195_41906951_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_41094195_41906951_1": {"length": 10, "quality": 1.0, "section_id": 8704}, "so_41094195_41906951_3": {"length": 16, "quality": 1.0, "section_id": 8704}}}, "41094409": {"Id": "41094409", "PostTypeId": "2", "Body": "<p>The behavior you've invoked is undefined because the standard says it's undefined, and your compiler takes advantage of that fact.  Lets look at g++ for a concrete example.  The assembly it generates for the line <code>b_memcpy.vfunc();</code> with optimizations disabled looks like this:</p>\n<pre><code>lea     rax, [rbp-48]\nmov     rdi, rax\ncall    Base::vfunc()\n</code></pre>\n<p>As you can see, the vtable wasn't even referenced.  Since the compiler knows the static type of <code>b_memcpy</code> it has no reason to dispatch that method call polymorphically.  <code>b_memcpy</code> can't be anything other than a <code>Base</code> object, so it just generates a call to <code>Base::vfunc()</code> as it would with any other method call.</p>\n<p>Going a bit further, lets add a function like this:</p>\n<pre><code>void callVfunc(Base&amp; b)\n{\n  b.vfunc();\n}\n</code></pre>\n<p>Now if we call <code>callVfunc(b_memcpy);</code> we can see different results.  Here we get a different result depending on the optimization level at which I compile the code. On -O0 and -O1 <code>Derived::vfunc()</code> is called and on -O2 and -O3 <code>Base::vfunc()</code> is printed.  Again, since the standard says the behavior of your program is undefined, the compiler makes no effort to produce a predictable result, and simply relies on the assumptions made by the language.  Since the compiler knows <code>b_memcpy</code> is a <code>Base</code> object, it can simply inline the call to <code>puts(\"Base::vfunc()\");</code> when the optimization level allows for it.</p>\n", "LastActivityDate": "2016-12-12T04:54:35.357", "CommentCount": "1", "CreationDate": "2016-12-12T04:54:35.357", "ParentId": "41094195", "Score": "1", "OwnerUserId": "4151599"}, "41094250": {"Id": "41094250", "PostTypeId": "2", "Body": "<p>You aren't allowed to do</p>\n<pre><code>memcpy(&amp;b_memcpy, &amp;d, sizeof(Base));\n</code></pre>\n<p>- it's undefined behaviour, because <code>b_memcpy</code> and <code>d</code> aren't \"plain old data\" objects (<em>because</em> they have virtual member functions).</p>\n<p>If you wrote:</p>\n<pre><code>b_memcpy = d;\n</code></pre>\n<p>then it would print <code>Base::vfunc()</code> as expected.</p>\n", "LastActivityDate": "2016-12-12T04:31:08.857", "CommentCount": "9", "CreationDate": "2016-12-12T04:31:08.857", "ParentId": "41094195", "Score": "0", "OwnerUserId": "106104"}, "41906951": {"Id": "41906951", "PostTypeId": "2", "Body": "<h1>Any use of a vptr is outside the scope of the standard</h1>\n<h2>Granted, the use of <code>memcpy</code> here has UB</h2>\n<p>The answers pointing out that any use of <code>memcpy</code>, or other byte manipulation of non-PODs, that is, of any object with a vptr, has undefined behavior, are strictly technically correct but do not answer the question. <em>The question is predicated on the existence of a vptr (vtable pointer) which isn't even mandated by the standard</em>: of course the answer will involve facts outside the standard and the result bill not be guaranteed by the standard!</p>\n<h2>Standard text is not relevant regarding the vptr</h2>\n<p>The issue is not that <em>you</em> are not allowed to manipulate the vptr; the notion of being allowed by the standard to manipulate anything that is not even described in the standard text is absurd. Of course not standard way to change the vptr will exist and this is beside the point.</p>\n<h2>The vptr encodes the type of a polymorphic object</h2>\n<p>The issue here is not what the standard says about the vptr, <strong>the issue is what the vptr represents, and what the standard says about that</strong>: the vptr represents the dynamic type of an object. Whenever the result of an operation depends on the dynamic type, the compiler will generate code to use the vptr. </p>\n<p>[Note regarding MI: I say \"the\" vptr (as if the only one vptr), but when MI (multiple inheritance) is involved, objects can have more than one vptr, each representing the complete object viewed as a particular polymorphic base class type. (A polymorphic class is a class with a least one virtual function.)]</p>\n<p>[Note regarding virtual bases: I mention only the vptr, but some compilers insert other pointers to represent aspects of the dynamic type, like the location of virtual base subobjects, and some other compilers use the vptr for that purpose. What is true about the vptr is also true about these other internal pointers.]</p>\n<p>So <em>a particular value of the vptr corresponds to a dynamic type</em>: that is the type of most derived object.</p>\n<h1>Changes of the dynamic type of an object during its lifetime</h1>\n<p>During construction, the dynamic type changes, and that is why virtual function calls from inside the constructor can be \"surprising\". Some people say that the rules of calling virtual functions during construction are special, but they are absolutely not: the final overrider is called; that override is the one the class corresponding to the most derived object that has been constructed, and in a constructor <code>C::C(arg-list)</code>, it is always the type of the class <code>C</code>.</p>\n<p>During destruction, the dynamic type changes, in the reverse order. Calls to virtual function from inside destructors follow the same rules.</p>\n<h1>What it means when something is left undefined</h1>\n<p>You can do low level manipulations that are not sanctioned in the standard. <strong>That a behavior is not explicitly defined in the C++ standard does not imply that it is not described elsewhere</strong>. Just because the result of a manipulation is explicitly described has having UB (undefined behavior) in the C++ standard does not mean your implementation cannot define it.</p>\n<p>You can also use your knowledge of the way the compilers work: if strict separate compilation is used, that is when the compiler can get no information from separately compiled code, every separately compiled function is a \"black box\". You can use this fact: the compiler will have to assume that anything that a separately compiled function could do will be done. Even with inside a given function, you can use <code>asm</code> directive to get the same effects: an <code>asm</code> directive with no constraint can do anything that is legal in C++. The effect is a \"forget what you know from code analysis at that point\" directive.</p>\n<p>The standard describes what can change the dynamic type, and nothing is allowed to change it except construction/destruction, so only an \"external\" (blackbox) function is is otherwise allowed to perform construction/destruction can change a dynamic type.</p>\n<p>Calling constructors on an existing object is not allowed, except to reconstruct it with the exact same type (and with restrictions) see <a href=\"http://eel.is/c++draft/basic.life#8\" rel=\"nofollow noreferrer\">[basic.life]/8</a> :</p>\n<blockquote>\n<p id=\"so_41094195_41906951_0\">If, after the lifetime of an object has ended and before the storage\n  which the object occupied is reused or released, a new object is\n  created at the storage location which the original object occupied, a\n  pointer that pointed to the original object, a reference that referred\n  to the original object, or the name of the original object will\n  automatically refer to the new object and, once the lifetime of the\n  new object has started, can be used to manipulate the new object, if:</p>\n<p id=\"so_41094195_41906951_1\">(8.1) the storage for the new object exactly overlays the storage\n  location which the original object occupied, and</p>\n<p id=\"so_41094195_41906951_2\">(8.2) the new object is of the same type as the original object\n  (ignoring the top-level cv-qualifiers), and</p>\n<p id=\"so_41094195_41906951_3\">(8.3) the type of the original object is not const-qualified, and, if\n  a class type, does not contain any non-static data member whose type\n  is const-qualified or a reference type, and</p>\n<p id=\"so_41094195_41906951_4\">(8.4) the original object was a most derived object ([intro.object])\n  of type T and the new object is a most derived object of type T (that\n  is, they are not base class subobjects).</p>\n</blockquote>\n<p>This means that the only case where you could call a constructor (with placement new) and still use the same expressions that used to designate the objects (its name, pointers to it, etc.) are those where the dynamic type would not change, so the vptr would still be the same.</p>\n<p>On other words, <em>if you want to overwrite the vptr using low level tricks, you could; but only if you write the same value</em>.</p>\n<p>On other words, don't try to hack the vptr.</p>\n", "LastActivityDate": "2017-01-28T06:15:16.830", "CommentCount": "0", "CreationDate": "2017-01-28T06:15:16.830", "ParentId": "41094195", "Score": "0", "OwnerUserId": "963864"}, "41094195": {"ViewCount": "158", "Body": "<p>I am reading <strong>Inside the C++ Object Model</strong>. In section 1.3</p>\n<blockquote>\n<p id=\"so_41094195_41094195_0\">So, then, why is it that, given</p>\n</blockquote>\n<pre><code>Bear b; \nZooAnimal za = b; \n\n// ZooAnimal::rotate() invoked \nza.rotate(); \n</code></pre>\n<blockquote>\n<p id=\"so_41094195_41094195_1\">the instance of rotate() invoked is the ZooAnimal instance and not that of Bear? Moreover, if memberwise initialization copies the values of one object to another, why is za's vptr not addressing Bear's virtual table?</p>\n<p id=\"so_41094195_41094195_2\">The answer to the second question is that the compiler intercedes in the initialization and assignment of one class object with another. The compiler must ensure that if an object contains one or more vptrs, <strong>those vptr values are not initialized or changed by the source object</strong> .</p>\n</blockquote>\n<p>So I wrote the test code below:</p>\n<pre><code>#include &lt;stdio.h&gt;\nclass Base{\npublic:\n    virtual void vfunc() { puts(\"Base::vfunc()\"); }\n};\nclass Derived: public Base\n{\npublic:\n    virtual void vfunc() { puts(\"Derived::vfunc()\"); }\n};\n#include &lt;string.h&gt;\n\nint main()\n{\n    Derived d;\n    Base b_assign = d;\n    Base b_memcpy;\n    memcpy(&amp;b_memcpy, &amp;d, sizeof(Base));\n\n    b_assign.vfunc();\n    b_memcpy.vfunc();\n\n    printf(\"sizeof Base : %d\\n\", sizeof(Base));\n\n    Base &amp;b_ref = d;\n    b_ref.vfunc();\n\n    printf(\"b_assign: %x; b_memcpy: %x; b_ref: %x\\n\", \n        *(int *)&amp;b_assign,\n        *(int *)&amp;b_memcpy,\n        *(int *)&amp;b_ref);\n    return 0;\n}\n</code></pre>\n<p>The <a href=\"http://ideone.com/uWZF2t\" rel=\"nofollow noreferrer\">result</a></p>\n<pre><code>Base::vfunc()\nBase::vfunc()\nsizeof Base : 4\nDerived::vfunc()\nb_assign: 80487b4; b_memcpy: 8048780; b_ref: 8048780\n</code></pre>\n<p>My question is why b_memcpy still called Base::vfunc()</p>\n", "AcceptedAnswerId": "41094239", "Title": "memcpy derived class to base class, why still called base class function", "CreationDate": "2016-12-12T04:23:45.833", "Id": "41094195", "CommentCount": "5", "LastEditDate": "2017-01-28T00:16:01.993", "PostTypeId": "1", "LastEditorUserId": "963864", "LastActivityDate": "2017-01-28T06:15:16.830", "Score": "1", "OwnerUserId": "5546786", "Tags": "<c++><undefined-behavior><lifetime><dynamictype><vptr>", "AnswerCount": "4"}});