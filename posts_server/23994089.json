post_cb({"bq_ids": {"n4140": {"so_23994089_23994089_0": {"length": 16, "quality": 1.0, "section_id": 7107}}, "n3337": {"so_23994089_23994089_0": {"length": 16, "quality": 1.0, "section_id": 6851}}, "n4659": {"so_23994089_23994089_0": {"length": 16, "quality": 1.0, "section_id": 8608}}}, "23994089": {"ViewCount": "71", "Body": "<p>I've read the following (3.4.3/1):</p>\n<blockquote>\n<p id=\"so_23994089_23994089_0\">If a :: scope resolution operator in a nested-name-specifier is not\n  preceded by a decltype-specifier, <strong>lookup of the name preceding that ::</strong>\n  considers only namespaces, types, and templates whose specializations\n  are types.</p>\n</blockquote>\n<p>What is the lookup rule for nested-name-specifier?</p>\n<p>For example:</p>\n<pre><code>#include &lt;iostrem&gt;\n\nnamespace A\n{\n    int j=5;\n}\n\nint main()\n{\n    std::cout &lt;&lt; A::j //I assume that A will be searched as just *unqualified-name* appeared inside the function which is a member of namespace\n}\n</code></pre>\n<p>The second example:</p>\n<pre><code>namespace A\n{\n    namespace B\n    {\n        int j=5;\n    }\n}\n\nint main()\n{\n    std::cout &lt;&lt; A::B::j\n}\n</code></pre>\n<p>Is it true that in the second example A::B will be looking as qualified name inside the namespace? I.e. we can define rules for <strong>nested-name-specifier</strong> lookup inductively. But I cant find anything like that in the standard. Is it true at all?</p>\n", "Title": "Name lookup rules for nested-name-specifier", "CreationDate": "2014-06-02T12:02:37.317", "LastActivityDate": "2014-06-02T12:51:09.377", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "Id": "23994089", "Score": "2", "Tags": "<c++><language-lawyer><qualified-name>", "AnswerCount": "1"}, "23994621": {"Id": "23994621", "PostTypeId": "2", "Body": "<p>Yes, it's inductive, and I'd say it simply follows from the wording. First, let's add full parenthesizing based on the associativity of <code>::</code>:</p>\n<pre><code>(std::cout) &lt;&lt; ((A::B)::j)\n</code></pre>\n<p><sup>(The above is just to demonstrate how the parser understands precedence, it's not valid code).</sup></p>\n<p>So <code>j</code> is qualified by the name <code>A::B</code>. It's a qualified name, so it's looked up according to 3.4.3.</p>\n<p><code>A::B</code> is itself a qualified name (it conforms to the syntactic form outlined by 5.1.1/8), so it is looked up according to rules for a qualified name.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2014-06-02T12:51:09.377", "Score": "1", "CreationDate": "2014-06-02T12:30:51.923", "ParentId": "23994089", "CommentCount": "2", "OwnerUserId": "1782465", "LastEditDate": "2014-06-02T12:51:09.377"}});