post_cb({"22991232": {"ParentId": "22991180", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The initialization list wins. The in-place initialization would win if you had another constructor that does not initialize the member.</p>\n<p>For example,</p>\n<pre><code>struct B\n{\n  B():mya_{5} {}\n  B(int) {}\n  A mya_{7};\n};\n\nint main\n{\n  B b0;    // b.mya_.a_ is 5\n  B b(42); // b.mya_.a_ is 7\n}\n</code></pre>\n<p>From <strong>12.6.2 Initializing bases and members [class.base.init]</strong></p>\n<blockquote>\n<p id=\"so_22991180_22991232_0\">If a given non-static data member has both a\n  brace-or-equal-initializer and a mem-initializer, the initialization\n  specified by the mem-initializer is performed, and the non-static data\n  member\u2019s brace-or-equal-initializer is ignored. [ Example: Given</p>\n</blockquote>\n<pre><code>struct A {\nint i = /\u2217 some integer expression with side effects \u2217/ ;\nA(int arg) : i(arg) { }\n// ...\n};\n</code></pre>\n<blockquote>\n<p id=\"so_22991180_22991232_1\">the A(int) constructor will simply initialize i to the value of arg,\n  and the side effects in i\u2019s brace-or-equal- initializer will not take\n  place. \u2014 end example ]</p>\n</blockquote>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2014-04-10T14:44:47.623", "Id": "22991232", "Score": "3", "CreationDate": "2014-04-10T14:37:16.960", "LastActivityDate": "2014-04-10T14:44:47.623"}, "bq_ids": {"n4140": {"so_22991180_22991232_0": {"section_id": 436, "quality": 0.9444444444444444, "length": 17}, "so_22991180_22991232_1": {"section_id": 436, "quality": 0.75, "length": 12}}, "n3337": {"so_22991180_22991232_0": {"section_id": 428, "quality": 0.9444444444444444, "length": 17}, "so_22991180_22991232_1": {"section_id": 428, "quality": 0.75, "length": 12}}, "n4659": {"so_22991180_22991232_1": {"section_id": 455, "quality": 0.8125, "length": 13}, "so_22991180_22991232_0": {"section_id": 455, "quality": 0.8333333333333334, "length": 15}}}, "22991180": {"CommentCount": "0", "AcceptedAnswerId": "22991232", "CreationDate": "2014-04-10T14:35:08.660", "LastActivityDate": "2014-04-10T14:44:47.623", "PostTypeId": "1", "ViewCount": "98", "FavoriteCount": "1", "Title": "Conflict resolution between in-class member initializer and initialization list", "Id": "22991180", "Score": "0", "Body": "<p>Let me precede the question with the following code:</p>\n<pre><code>struct A\n{\n  explicit A(int i):a_{i} {}\n\n  int a_\n};\n\nstruct B\n{\n  B():mya_{5} {} // Initialize mya_ (again?)\n\n  A mya_{7}; // Initialize mya_\n};\n</code></pre>\n<p>In <code>struct B</code> we have a conflict between the in-class initializer for <code>mya_</code> and <code>mya_</code> being initialized in <code>B</code>'s constructor's initializer list. How is this resolved per the C++ standard and what should the final value of <code>mya_.a_</code> be when <code>B</code>'s construction is complete?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "473798", "AnswerCount": "1"}});