post_cb({"bq_ids": {"n4140": {"so_34163580_34164001_1": {"length": 18, "quality": 1.0, "section_id": 1617}, "so_34163580_34164001_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1566}}, "n3337": {"so_34163580_34164001_1": {"length": 18, "quality": 1.0, "section_id": 1613}, "so_34163580_34164001_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1561}}, "n4659": {"so_34163580_34164001_1": {"length": 18, "quality": 1.0, "section_id": 1770}}}, "34164001": {"Id": "34164001", "PostTypeId": "2", "Body": "<p>Since C++11, std::string is required to be stored in contiguous memory. This is the quote from the C++11 standard (section 24.4.1.4):</p>\n<blockquote>\n<p id=\"so_34163580_34164001_0\">The char-like objects in a\n  basic_string\n  object shall be stored contiguously. That is, for any\n  basic_string\n  object\n  s\n  , the identity\n  &amp;*(s.begin() + n) == &amp;*s.begin() + n\n  shall hold for all values of\n  n\n  such that\n  0\n  &lt;= n &lt; s.size()\n  .</p>\n</blockquote>\n<p>This quote about the return value of operator[] states that it returns the same as <code>&amp;*(s.begin()+n)</code> (section 21.4.5.1):</p>\n<blockquote>\n<p id=\"so_34163580_34164001_1\">*(begin() + pos)\n  if\n  pos &lt; size()\n  . Otherwise, returns a reference to an object of type\n  charT\n  with value\n  charT()\n  , where modifying the object leads to undefined behavior</p>\n</blockquote>\n<p>Then we have this quote on the return value of data() in (section 24.4.7.1):</p>\n<blockquote>\n<p id=\"so_34163580_34164001_2\">A pointer\n  p\n  such that\n  p + i == &amp;operator[](i)\n  for each\n  i\n  in\n  [0,size()]\n  .</p>\n</blockquote>\n<p>So data returns the same as you would get using the &amp;operator[]. And any value between you retrieve using the &amp;operator should be stored contiguously. So you can conclude both return a pointer to contiguous memory. So it will not return a pointer to a distance page.</p>\n<p>Note that this only applies to C++11. Such guarantees were not made by the standard before C++11.</p>\n", "LastEditorUserId": "5625102", "LastActivityDate": "2015-12-08T19:28:15.107", "Score": "1", "CreationDate": "2015-12-08T19:07:29.483", "ParentId": "34163580", "CommentCount": "4", "OwnerUserId": "5625102", "LastEditDate": "2015-12-08T19:28:15.107"}, "34163580": {"ViewCount": "146", "Body": "<p>So, <code>operator[]</code> does not directly say that <code>s[s.size()]</code> must be the character after <code>s[s.size()-1]</code> in memory.  It seems worded to avoid making that claim.</p>\n<p>But <code>s.data()</code> states that <code>s.data()+k == &amp;s[k]</code>, and <code>s.data()</code> must return a pointer.</p>\n<p>Ignoring the seeming standard defect of using <code>&amp;</code> on <code>CharT</code> above and not <code>std::addressof</code>, is the implementation free to return a different <code>CharT</code> (say, one on a protected page, or in ROM) for <code>s[s.size()]</code> prior to the first call to <code>s.data()</code>?  (Clearly it could arrange the buffer to end on a read-only page with a zero on it; I'm talking about a different situation)</p>\n<p>To be explicit:</p>\n<p>As far as I can tell, if <code>s.data()</code> is never called (and the compiler can prove it), then <code>s[s.size()]</code> need not be contiguous with the rest of the buffer.</p>\n<p>Can <code>std::addressof(s[s.size()])</code> <em>change</em> after a call to <code>s.data()</code> and the implementation be standards-compliant (so long as <code>s.data()+k == &amp;s[k]</code> has <code>.data()</code> evaluated before <code>[]</code>, but the compiler is free to enforce that).  Or are there immutability requirements I cannot see?</p>\n", "Title": "Can `std::basic_string::operator[]` return a \"distant\" protected page nul terminator?", "CreationDate": "2015-12-08T18:44:02.503", "LastActivityDate": "2015-12-08T21:10:05.483", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-12-08T19:25:38.167", "LastEditorUserId": "1774667", "Id": "34163580", "Score": "8", "OwnerUserId": "1774667", "Tags": "<c++><language-lawyer><c++14><stdstring><c++1z>", "AnswerCount": "1"}});