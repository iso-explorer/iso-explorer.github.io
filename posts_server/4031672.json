post_cb({"38576559": {"Id": "38576559", "PostTypeId": "2", "Body": "<p>GLIBC-specific solution:</p>\n<pre><code>#include &lt;errno.h&gt;\n...\nfprintf(stderr, \"Program name is %s\\n\", program_invocation_name);\n</code></pre>\n<p>From <code>man invocation_name</code>:</p>\n<blockquote>\n<p id=\"so_4031672_38576559_0\"><code>program_invocation_name</code> contains the name that was used to invoke the calling program.  This is the same as the value of <code>argv[0]</code> in <code>main()</code>, with the difference that the scope of <code>program_invocation_name</code> is global.</p>\n<p id=\"so_4031672_38576559_1\"><code>program_invocation_short_name</code> contains the basename component of name that was used to invoke the calling program.  That is, it is the same  value  as  <code>program_invocation_name</code>, with all text up to and including the final slash (/), if any, removed.</p>\n</blockquote>\n", "LastActivityDate": "2016-07-25T20:08:57.377", "CommentCount": "0", "CreationDate": "2016-07-25T20:08:57.377", "ParentId": "4031672", "Score": "3", "OwnerUserId": "3065593"}, "4031835": {"Id": "4031835", "PostTypeId": "2", "Body": "<p>No, there is no such function. Linux stores the program name in <code>__progname</code>, but that's not a public interface. In case you want to use this for warnings/error messages, use the <code>err(3)</code> functions.</p>\n<p>If you want the full path of the running program, call <code>readlink</code> on <code>/proc/self/exe</code>:</p>\n<pre><code>char *program_path()\n{\n    char *path = malloc(PATH_MAX);\n    if (path != NULL) {\n        if (readlink(\"/proc/self/exe\", path, PATH_MAX) == -1) {\n            free(path);\n            path = NULL;\n        }\n    }\n    return path;\n}\n</code></pre>\n<p>(I believe <code>__progname</code> is set to the basename of <code>argv[0]</code>. Check out the glibc sources to be sure.)</p>\n", "LastEditorUserId": "166749", "LastActivityDate": "2010-10-27T09:59:54.667", "Score": "17", "CreationDate": "2010-10-27T09:47:26.177", "ParentId": "4031672", "CommentCount": "3", "OwnerUserId": "166749", "LastEditDate": "2010-10-27T09:59:54.667"}, "4031822": {"Id": "4031822", "PostTypeId": "2", "Body": "<p>You can determine the pid of your process using getpid() and then inspect the contents of /proc/[pid number] using standard I/O tools.</p>\n", "LastActivityDate": "2010-10-27T09:44:52.703", "CommentCount": "4", "CreationDate": "2010-10-27T09:44:52.703", "ParentId": "4031672", "Score": "2", "OwnerUserId": "434507"}, "bq_ids": {"n4140": {"so_4031672_4031745_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 7146}}, "n3337": {"so_4031672_4031745_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 6890}}, "n4659": {"so_4031672_4031745_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 8647}}}, "4031691": {"Id": "4031691", "PostTypeId": "2", "Body": "<p>This is not guaranteed.</p>\n<p>Usually, <code>argv[0]</code> holds the executable name but one can call your executable using <code>execve</code> and set it to something else.</p>\n<p>In a word: don't rely on this.</p>\n", "LastActivityDate": "2010-10-27T09:28:49.843", "CommentCount": "6", "CreationDate": "2010-10-27T09:28:49.843", "ParentId": "4031672", "Score": "8", "OwnerUserId": "279259"}, "4031745": {"Id": "4031745", "PostTypeId": "2", "Body": "<p>No, it depends <em>entirely</em> on what the parent program puts in there.</p>\n<p>The <code>exec</code> family of functions allow the executable name to be totally different to the argument passed in, and this is supported by the ISO C standard.</p>\n<blockquote>\n<p id=\"so_4031672_4031745_0\">If the value of argc is greater than zero, the string pointed to by argv[0] represents the program name; argv[0][0] shall be the null character if the program name is not available from the host environment.</p>\n</blockquote>\n<p>So no, it's only the program name if the name is available. And the section before that states:</p>\n<blockquote>\n<p id=\"so_4031672_4031745_1\">If the value of argc is greater than zero, the array members argv[0] through argv[argc-1] inclusive shall contain pointers to strings, which are given <em>implementation-defined</em> values by the host environment prior to program startup.</p>\n</blockquote>\n<p>(my italics).</p>\n<p>So, even their values are not dictated by the standard, it's up to the implementation entirely. This means that the program name can be empty if the host environment doesn't provide it, and anything else if the host environment does provide it.</p>\n<p>However, implementation-defined has a specific meaning in the ISO standards - the implementation <em>must</em> document how it works. So even UNIX, which can put anything it likes into <code>argv[0]</code> with the <code>exec</code> family of calls, has to (and does) document it.</p>\n<p>Similarly (thanks to Chubsdad), C++03 states:</p>\n<blockquote>\n<p id=\"so_4031672_4031745_2\">\"If argc is nonzero these arguments shall be supplied in argv[0] through argv[argc-1] as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.3.2.1.3.2) and argv[0] shall be the pointer to the initial character of a NTMBS that represents the name used to invoke the program or \"\".</p>\n</blockquote>\n<p>So, even there, argv[0] may not contain anything and, even if it does, \"represents the name\" is a very vague requirement. It doesn't have to be the full pathname of the executable or even contain the command used to invoke it</p>\n<hr>\n<p>Another way to do it under Linux is with the <code>proc</code> filesystem. I think <code>/proc/self/exe</code> is a link to the executable file.</p>\n<p>Wikipedia has an entry for the <a href=\"http://en.wikipedia.org/wiki/Procfs\"><code>procfs</code></a> filesystem with lots of goodies.</p>\n</hr>", "LastEditorUserId": "14860", "LastActivityDate": "2010-10-27T09:46:46.667", "Score": "6", "CreationDate": "2010-10-27T09:35:48.337", "ParentId": "4031672", "CommentCount": "9", "OwnerUserId": "14860", "LastEditDate": "2010-10-27T09:46:46.667"}, "4031875": {"Id": "4031875", "PostTypeId": "2", "Body": "<p>If you use GLib you can use the function <a href=\"http://library.gnome.org/devel/glib/stable/glib-Miscellaneous-Utility-Functions.html#g-get-prgname\" rel=\"nofollow\"><code>g_get_prgname()</code></a>.  On Win32 it calls <a href=\"http://msdn.microsoft.com/en-us/library/ms683197%28VS.85%29.aspx\" rel=\"nofollow\"><code>GetModuleFileNameW()</code></a>, on everything else it appears to return NULL though.</p>\n", "LastActivityDate": "2010-10-27T09:51:47.680", "CommentCount": "2", "CreationDate": "2010-10-27T09:51:47.680", "ParentId": "4031672", "Score": "2", "OwnerUserId": "175849"}, "4031672": {"ViewCount": "9368", "Body": "<p>I know the program name is passed as the first argument, and next simple example will print it to the standard output :</p>\n<pre><code>#include &lt;iostream&gt;\nint main ( int argc, char *argv[] )\n{\n  std::cout&lt;&lt;argv[0]&lt;&lt;std::endl;\n}\n</code></pre>\n<p>Is there a function to get the program name?</p>\n<p><strong>EDIT</strong></p>\n<p>I am starting the program from the shell, and the above code will always print the program name (I am using fedora 9, but I am sure it works in other distros).</p>\n<p>I have found that /proc/self/ directory might contain what I am looking for, but I couldn't find what exactly in that directory.</p>\n", "AcceptedAnswerId": "4031835", "Title": "Without access to argv[0], how do I get the program name?", "CreationDate": "2010-10-27T09:26:27.207", "Id": "4031672", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-10-27T11:33:40.510", "LastEditorUserId": "15416", "LastActivityDate": "2016-07-25T20:08:57.377", "Score": "8", "OwnerUserId": "476681", "Tags": "<c++><c><linux><command-line-arguments>", "AnswerCount": "6"}});