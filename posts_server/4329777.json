post_cb({"4330344": {"ParentId": "4329777", "CommentCount": "2", "Body": "<p>Yes, the C++ standard is explicit that the number of bits in a byte is not specified. The number of bits in a long isn't specified, either.</p>\n<p>Setting a <strong>lower bound</strong> on a number is not <strong>specifying</strong> it.</p>\n<p>The C++ standard says, in one place:</p>\n<pre><code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long).\n</code></pre>\n<p>It says, in effect, in another place, via inclusion of the C standard:</p>\n<pre><code>CHAR_BITS &gt;= 8; SHORT_BITS &gt;= 16; INT_BITS &gt;= 16; LONG_BITS &gt;= 32\n</code></pre>\n<p>(except that AFAIK, the identifiers SHORT_BITS, INT_BITS and LONG_BITS don't exist, and that these limits are inferred by the requirements for minimum values on the types.)</p>\n<p>This follows from the fact that a certain number of bits are required, mathematically, to encode all of the values in the (e.g. for longs) LONG_MIN..LONG_MAX range.</p>\n<p>Finally, shorts, ints and longs must all be made up of an integral number of chars; sizeof() always reports an integral value. Also, iterating through memory char by char must access every bit, which places some practical limitations.</p>\n<p>These requirements are <strong>not inconsistent in any way</strong>. Any sizes that satisfy the requirements are OK.</p>\n<p>There were machines long ago with a native word size of 36 bits. If you were to port a C++ compiler to them, you could legally decide to have 9 bits in a char, 18 in both short and int, and 36 in long. You could also legally decide to have 36 bits in each of those types, for the same reason that you can have 32 bits in an int on a typical 32-bit system today. There are real-world implementations that use 64-bit chars.</p>\n<p>See also sections 26.1-6 and 29.5 of the <a href=\"http://www.parashift.com/c++-faq-lite/index.html\">C++ FAQ Lite</a>.</p>\n", "OwnerUserId": "523612", "PostTypeId": "2", "Id": "4330344", "Score": "6", "CreationDate": "2010-12-01T23:52:39.503", "LastActivityDate": "2010-12-01T23:52:39.503"}, "4330175": {"ParentId": "4329777", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_4329777_4330175_0\">But Alf and others are specific that a\n  long must be at least 32 bits. This is\n  what I'm trying to establish. The C++\n  Standard is explicit that the number\n  of bits in a byte are not specified.\n  Could be 4, 8, 16, 42... So how is the\n  connection made from being able to\n  accomodate the numbers\n  LONG_MIN-LONG_MAX to being at least 32\n  bits?</p>\n</blockquote>\n<p>You need 32 bits in the value representation in order to get <em>at least that many</em> bitpatterns. And since C++ requires a binary representation of integers (explicit language to that effect in the standard, \u00a73.9.1/7), Q.E.D.</p>\n", "OwnerUserId": "464581", "LastEditorUserId": "560648", "LastEditDate": "2012-01-08T17:23:36.307", "Id": "4330175", "Score": "7", "CreationDate": "2010-12-01T23:22:35.157", "LastActivityDate": "2012-01-08T17:23:36.307"}, "4329777": {"CommentCount": "22", "AcceptedAnswerId": "4337544", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-12-01T22:24:32.517", "LastActivityDate": "2016-09-09T15:51:16.073", "LastEditDate": "2017-05-23T12:09:20.900", "ViewCount": "8813", "FavoriteCount": "12", "Title": "Is `long` guaranteed to be at least 32 bits?", "Id": "4329777", "Score": "49", "Body": "<p>By my reading of the C++ Standard, I have always understood that the sizes of the integral fundamental types in C++ were as follows:</p>\n<pre><code>sizeof(char) &lt;= sizeof(short int) &lt;= sizeof(int) &lt;= sizeof(long int)\n</code></pre>\n<p>I deduced this from 3.9.1/2:</p>\n<blockquote id=\"so_4329777_4329777_0\">\n<ol start=\"2\">\n<li>There are four signed integer types: \u201csigned char\u201d, \u201cshort int\u201d,\n  \u201cint\u201d, and \u201clong int.\u201d In this list,\n  each type provides at least as much\n  storage as those preceding it in the\n  list. Plain ints have the natural size\n  suggested by the architecture of the\n  execution environment</li>\n</ol>\n</blockquote>\n<p>Further, the size of <code>char</code> is described by 3.9.1/ as being:</p>\n<blockquote id=\"so_4329777_4329777_1\">\n<ol>\n<li>[...] large enough to store any member of the implementation\u2019s basic character set.</li>\n</ol>\n</blockquote>\n<p>1.7/1 defines this in more concrete terms:</p>\n<blockquote id=\"so_4329777_4329777_2\">\n<ol>\n<li>The fundamental storage unit in the C + + memory model is the byte. A byte is at least large enough to contain any member of the basic execution character set and is composed of a contiguous sequence of bits, the number of which is implementation-defined.</li>\n</ol>\n</blockquote>\n<p>This leads me to the following conclusion:</p>\n<pre><code>1 == sizeof(char) &lt;= sizeof(short int) &lt;= sizeof(int) &lt;= sizeof(long int)\n</code></pre>\n<p>where <code>sizeof</code> tells us how many bytes the type is.  Furthermore, it is implementation-defined how many bits are in a byte.  Most of us are probably used to dealing with 8-bit bytes, but the Standard says there are <code>n</code> bits in a byte.</p>\n<hr>\n<p>In <a href=\"https://stackoverflow.com/questions/4329277/whats-the-point-of-long-data-type/4329349#4329349\">this post</a>, Alf P. Steinbach says: </p>\n<blockquote>\n<p id=\"so_4329777_4329777_3\">long is guaranteed (at least) 32 bits. </p>\n</blockquote>\n<p>This flies in the face of everything I understand the size of the fundamental types to be in C++ according to the Standard.  Normally I would just discount this statement as a beginner being wrong, but since this was Alf I decided it was worth investigating further.</p>\n<p>So, what say you?  Is a long guaranteed by the standard to be at least 32 bits?  If so, please be specific as to how this guarantee is made.  I just don't see it.</p>\n<ol>\n<li><p>The C++ Standard specifically says that in order to know C++ you must know C (1.2/1) <sup>1</sup></p></li>\n<li><p>The C++ Standard implicitly defines the minimum limit on the values a <code>long</code> can accommodate to be <code>LONG_MIN</code>-<code>LONG_MAX</code> <sup>2</sup></p></li>\n</ol>\n<p>So no matter how big a <code>long</code> is, it has to be big enough to hold LONG_MIN to LONG_MAX.</p>\n<p>But Alf and others are <em>specific</em> that a long must be at least 32 bits.  This is what I'm trying to establish.  The C++ Standard is explicit that the number of bits in a byte are not specified (it could be 4, 8, 16, 42)  So how is the connection made from being able to accommodate the numbers <code>LONG_MIN-LONG_MAX</code> to being at least 32 bits?</p>\n<hr>\n<p>(1) 1.2/1: The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>\n<ul>\n<li>ISO/IEC 2382 (all parts), Information technology \u2013 Vocabulary </li>\n<li>ISO/IEC 9899:1999, Programming languages \u2013 C</li>\n<li>ISO/IEC 10646-1:2000, Information technology \u2013 Universal Multiple-Octet Coded Character Set (UCS) \u2013 Part 1: Architecture and Basic Multilingual Plane</li>\n</ul>\n<p>(2) Defined in <code>&lt;climits&gt;</code> as:</p>\n<pre><code>LONG_MIN -2147483647 // -(2^31 - 1)\nLONG_MAX +2147483647 //   2^31 - 1\n</code></pre>\n</hr></hr>", "Tags": "<c++><standards><long-integer><language-lawyer>", "OwnerUserId": "241536", "AnswerCount": "5"}, "4329830": {"ParentId": "4329777", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>C++ uses the limits defined in the C standard (C++: 18.3.2 (c.limits), C: 5.2.4.2.1): </p>\n<pre><code>LONG_MIN -2147483647 // -(2^31 - 1)\nLONG_MAX +2147483647 //   2^31 - 1\n</code></pre>\n<p>So you are guaranteed that a long is at least 32 bits.</p>\n<p>And if you want to follow the long circuitous route to whether <code>LONG_MIN</code>/<code>LONG_MAX</code> are representable by a <code>long</code>, you have to look at 18.3.1.2 (numeric.limits.members) in the C++ standard:</p>\n<pre><code>static constexpr T min() throw(); // Equivalent to CHAR_MIN, SHRT_MIN, FLT_MIN, DBL_MIN, etc.\nstatic constexpr T max() throw(); // Equivalent to CHAR_MAX, SHRT_MAX, FLT_MAX, DBL_MAX, etc.\n</code></pre>\n<p>I moved the footnotes into the comment, so it's not exactly what appears in the standard. But it basically implies that <code>std::numeric_limits&lt;long&gt;::min()==LONG_MIN==(long)LONG_MIN</code> and <code>std::numeric_limits&lt;long&gt;::max()==LONG_MAX==(long)LONG_MAX</code>.</p>\n<p>So, even though the C++ standard does not specify the bitwise representation of (signed) negative numbers, it has to either be twos-complement and require 32-bits of storage in total, or it has an explicit sign bit which means that it has 32-bits of storage also.</p>\n", "OwnerUserId": "6210", "LastEditorUserId": "6210", "LastEditDate": "2010-12-01T22:52:44.677", "Id": "4329830", "Score": "34", "CreationDate": "2010-12-01T22:32:09.360", "LastActivityDate": "2010-12-01T22:52:44.677"}, "4329855": {"ParentId": "4329777", "CommentCount": "2", "Body": "<p>The C++ standard notes that the contents of <code>&lt;climits&gt;</code> are the same as the C header <code>&lt;limits.h&gt;</code> (18.2.2 in ISO C++03 doc). </p>\n<p>Unfortunately, I do not have a copy of the C standard that existed pre-C++98 (i.e. C90), but in C99 (section 5.2.4.2.1), <code>&lt;limits.h&gt;</code> has to have at least this minimum values. I don't think this changed from C90, other than C99 adding the <code>long long</code> types.</p>\n<pre><code>\u2014 minimum value for an object of type long int\n\nLONG_MIN -2147483647 // \u2212(2^31 \u2212 1)\n\n\u2014 maximum value for an object of type long int\n\nLONG_MAX +2147483647 // 2^31 \u2212 1\n\n\u2014 maximum value for an object of type unsigned long int\n\nULONG_MAX 4294967295 // 2^32 \u2212 1\n\n\u2014 minimum value for an object of type long long int\n\nLLONG_MIN -9223372036854775807 // \u2212(2^63\u2212 1)\n</code></pre>\n", "OwnerUserId": "297696", "PostTypeId": "2", "Id": "4329855", "Score": "7", "CreationDate": "2010-12-01T22:35:42.777", "LastActivityDate": "2010-12-01T22:35:42.777"}, "bq_ids": {"n4140": {"so_4329777_4329777_0": {"section_id": 7211, "quality": 0.967741935483871, "length": 30}, "so_4329777_4329777_2": {"section_id": 5785, "quality": 0.8695652173913043, "length": 20}, "so_4329777_4329777_1": {"section_id": 7210, "quality": 1.0, "length": 8}}, "n3337": {"so_4329777_4329777_0": {"section_id": 6955, "quality": 0.967741935483871, "length": 30}, "so_4329777_4329777_2": {"section_id": 5558, "quality": 0.8695652173913043, "length": 20}, "so_4329777_4329777_1": {"section_id": 6954, "quality": 1.0, "length": 8}}, "n4659": {"so_4329777_4329777_0": {"section_id": 8720, "quality": 0.9354838709677419, "length": 29}, "so_4329777_4329777_2": {"section_id": 7242, "quality": 0.8695652173913043, "length": 20}, "so_4329777_4329777_1": {"section_id": 8719, "quality": 1.0, "length": 8}}}, "4337544": {"ParentId": "4329777", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The answer is definitively YES. Read my OP and all the comments to understand why exactly, but here's the short version.  If you doubt or question any of this, I encourage you to read the entire thread and all of the comments.  Otherwise accept this as true:</p>\n<ol>\n<li>The C++ standard includes parts of the C standard, including the definitions for <code>LONG_MIN</code> and <code>LONG_MAX</code></li>\n<li><code>LONG_MIN</code> is defined as no greater than <code>-2147483647</code> </li>\n<li><code>LONG_MAX</code> is defined as no less than <code>+2147483647</code> </li>\n<li>In C++ integral types are stored in  binary in the underlying representation</li>\n<li>In order to represent <code>-2147483647</code> and <code>+2147483647</code> in binary, you need 32 bits.</li>\n<li>A C++ long is guaranteed to be able to represent the minimum range <code>LONG_MIN</code> through <code>LONG_MAX</code></li>\n</ol>\n<p>Therefore a <code>long</code> must be at least 32 bits<sup>1</sup>.</p>\n<h2>EDIT:</h2>\n<p><code>LONG_MIN</code> and <code>LONG_MAX</code> have values with magnitudes dictated by the C standard (ISO/IEC 9899:TC3) in section \u00a75.2.4.2.1:</p>\n<blockquote>\n<p id=\"so_4329777_4337544_0\">[...] Their implementation-defined values shall be equal or greater in magnitude [...] (absolute value) to those shown, with the same sign [...]</p>\n</blockquote>\n<pre><code>\u2014 minimum value for an object of type long int\nLONG_MIN -2147483647 // -(2 ^ 31 - 1)\n\u2014 maximum value for an object of type long int\nLONG_MAX +2147483647 // 2 ^ 31 - 1\n</code></pre>\n<hr>\n<p><sup>1</sup> <strong>32 bits</strong>:  This does not mean that <code>sizeof (long) &gt;= 4</code>, because a byte is not necessarily 8 bits.  According to the Standard, a byte is some unspecified (platform-defined) number of bits.  While most readers will find this odd, there is real hardware on which <code>CHAR_BIT</code> is 16 or 32.</p>\n</hr>", "OwnerUserId": "241536", "LastEditorUserId": "3580433", "LastEditDate": "2016-09-09T15:51:16.073", "Id": "4337544", "Score": "15", "CreationDate": "2010-12-02T16:51:22.363", "LastActivityDate": "2016-09-09T15:51:16.073"}});