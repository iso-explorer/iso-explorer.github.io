post_cb({"bq_ids": {"n4140": {"so_12740403_12740932_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 1617}, "so_12740403_41310431_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1617}}, "n3337": {"so_12740403_12740932_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 1613}, "so_12740403_41310431_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1613}}, "n4659": {"so_12740403_12740932_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 1770}, "so_12740403_41310431_0": {"length": 18, "quality": 1.0, "section_id": 1770}}}, "41310431": {"Id": "41310431", "PostTypeId": "2", "Body": "<p><a href=\"https://timsong-cpp.github.io/lwg-issues/2475\" rel=\"noreferrer\">LWG 2475</a> made this valid by editing the specification of <code>operator[](size())</code> (inserted text in bold):</p>\n<blockquote>\n<p id=\"so_12740403_41310431_0\">Otherwise, returns a reference to an object of type <code>charT</code> with value\n  <code>charT()</code>, where modifying the object <strong>to any value other than <code>charT()</code></strong>\n  leads to undefined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2016-12-24T04:54:52.963", "CommentCount": "9", "CreationDate": "2016-12-24T04:54:52.963", "ParentId": "12740403", "Score": "6", "OwnerUserId": "2756719"}, "12740932": {"Id": "12740932", "PostTypeId": "2", "Body": "<p>Unfortunately, this is UB, if I interpret the wording correct (in any case, it's not allowed):</p>\n<p><code>\u00a721.4.5 [string.access] p2</code></p>\n<blockquote>\n<p id=\"so_12740403_12740932_0\"><em>Returns:</em> <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an object of type <code>T</code> with value <code>charT()</code>; <strong>the referenced value shall not be modified</strong>.</p>\n</blockquote>\n<p>(Editorial error that it says <code>T</code> not <code>charT</code>.)</p>\n<p><code>.data()</code> and <code>.c_str()</code> basically point back to <code>operator[]</code> (<code>\u00a721.4.7.1 [string.accessors] p1</code>):</p>\n<blockquote>\n<p id=\"so_12740403_12740932_1\"><em>Returns:</em> A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n", "LastActivityDate": "2012-10-05T06:44:31.370", "CommentCount": "15", "CreationDate": "2012-10-05T06:44:31.370", "ParentId": "12740403", "Score": "25", "OwnerUserId": "500104"}, "12742517": {"Id": "12742517", "PostTypeId": "2", "Body": "<p>According to the spec, overwriting the terminating <code>NUL</code> should be <em>undefined behavior</em>.\nSo, the right thing to do would be to allocate <code>length+1</code> characters in the string, pass the string buffer to the C API, and then <code>resize()</code> back to <code>length</code>:</p>\n<pre><code>// \"+ 1\" to make room for the terminating NUL for the C API\nstd::string str(length + 1);\n\n// Call the C API passing &amp;str[0] to safely write to the string buffer\n...\n\n// Resize back to length\nstr.resize(length);\n</code></pre>\n<p>(FWIW, I tried the \"overwriting NUL\" approach on MSVC10, and it works fine.)</p>\n", "LastActivityDate": "2012-10-05T08:36:16.727", "CommentCount": "3", "CreationDate": "2012-10-05T08:36:16.727", "ParentId": "12740403", "Score": "11", "OwnerUserId": "1629821"}, "12740775": {"Id": "12740775", "PostTypeId": "2", "Body": "<p>I suppose n3092 isn't current any more but that's what I have.  Section 21.4.5 allows access to a single element.  It requires pos &lt;= size().  If pos &lt; size() then you get the actual element, otherwise (i.e. if pos == size()) then you get a non-modifiable reference.</p>\n<p>I think that as far as the programming language is concerned, a kind of access which could modify the value is considered a modification even if the new value is the same as the old value.</p>\n<p>Does g++ have a pedantic library that you can link to?</p>\n", "LastActivityDate": "2012-10-05T06:33:16.643", "CommentCount": "1", "CreationDate": "2012-10-05T06:33:16.643", "ParentId": "12740403", "Score": "5", "OwnerUserId": "23705"}, "12740403": {"ViewCount": "2591", "Body": "<p>In C++11, we know that <code>std::string</code> is guaranteed to be both contiguous and null-terminated (or more pedantically, terminated by <code>charT()</code>, which in the case of <code>char</code> is the null character 0).</p>\n<p>There is this C API I need to use that fills in a string by pointer. It writes the whole string + null terminator. In C++03, I was always forced to use a <code>vector&lt;char&gt;</code>, because I couldn't assume that <code>string</code> was contiguous or null-terminated. But in C++11 (assuming a properly conforming <code>basic_string</code> class, which is still iffy in some standard libraries), I can.</p>\n<p>Or can I? When I do this:</p>\n<pre><code>std::string str(length);\n</code></pre>\n<p>The string will allocate <code>length+1</code> bytes, with the last filled in by the null-terminator. That's good. But when I pass this off to the C API, it's going to write <code>length+1</code> characters. It's going to overwrite the null-terminator.</p>\n<p>Admittedly, it's going to overwrite the null-terminator <em>with a null character</em>. Odds are good that this will work (indeed, I can't imagine how it <em>couldn't</em> work).</p>\n<p>But I don't care about what \"works\". I want to know, <em>according to the spec</em>, whether it's OK to overwrite the null-terminator with a null character?</p>\n", "AcceptedAnswerId": "41310431", "Title": "Legal to overwrite std::string's null terminator?", "CreationDate": "2012-10-05T06:03:42.037", "Id": "12740403", "CommentCount": "13", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2012-10-05T06:53:10.310", "LastEditorUserId": "500104", "LastActivityDate": "2016-12-24T04:54:52.963", "Score": "33", "OwnerUserId": "734069", "Tags": "<c++><c++11><language-lawyer><stdstring>", "AnswerCount": "4"}});