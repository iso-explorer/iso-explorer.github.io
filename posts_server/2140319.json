post_cb({"2140413": {"ParentId": "2140319", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>My initial thought was that it is undefined behavior.</p>\n<blockquote>\n<p id=\"so_2140319_2140413_0\">5.3.5/3: \"In the second alternative (<i>delete array</i>) if the dynamic\n  type of the object to be deleted\n  differs from its static type, the\n  behavior is undefined.<sup>73)</sup>.</p>\n</blockquote>\n<p>Footnote 73 reads, \"This implies that an object cannot be deleted using a pointer of type <code>void*</code> because there are no objects of type <code>void</code>\".</p>\n<p>Arguably the object in your example doesn't <em>have</em> a dynamic type, since the definition of \"dynamic type\" at 1.3.3 mentions \"most derived object\", and the definition of \"most derived object\" at 1.8/4 is talking about objects of class type. So I kept looking:</p>\n<blockquote>\n<p id=\"so_2140319_2140413_1\">5.2.10/3: \"[reinterpret_cast] might, or might not, produce a representation\n  different from the original value\"</p>\n<p id=\"so_2140319_2140413_2\">5.3.5/2: \"The value of the operand of <code>delete</code> shall be the pointer value\n  which resulted from a previous array\n  <i>new-expression</i>\".</p>\n</blockquote>\n<p>I'm not sure whether a reinterpret_cast results in the same pointer value as was input, or not. Possibly it's cleared up by some other bit of the standard which I haven't found yet. I would not call this code \"OK\" without finding something to definitively state that if you reinterpret_cast a pointer, the result is the same \"pointer value\" as before, so that by passing it to delete[] you are passing \"the pointer value\" from new[].</p>\n<blockquote>\n<p id=\"so_2140319_2140413_3\">5.2.10/7: \"Except that casting [between certain pointer types] and\n  back to its original type yields the\n  original pointer value, the result of\n  such a pointer conversion is\n  unspecified\".</p>\n</blockquote>\n<p>This looks like bad news to me - it conspicuously doesn't say that the cast yields the same value, only that the pair of casts over and back, yields the same value. This suggests to me that the single cast is allowed to yield a different value, but it is only suggestive, not explicit. This is the usual problem with the rule that \"if the standard doesn't state the behavior, then the behavior is undefined\". Just because it doesn't state it in any of the paragraphs I can find using the index, doesn't mean it doesn't state it somewhere else...</p>\n<p>We know that in practice we can cast things to unsigned char* in order to inspect their bytes, or void* to copy PODs using memcpy, so there must be some casts guaranteed to create aliases. You might think that if your implementation does create aliases with certain casts, then you're passing in the \"same value\" you got from new[]. But I'm still not sure that's good enough for delete[]. I think I'm missing something important.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-01-26T17:15:59.897", "Id": "2140413", "Score": "16", "CreationDate": "2010-01-26T15:41:12.860", "LastActivityDate": "2010-01-26T17:15:59.897"}, "2140401": {"ParentId": "2140319", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The delete[] operator internally uses a loop of some form to destruct the elements of your array. If the elements are different objects a different destructor will be used -- which can potentially cause undefined behaviour. Since the is a wchar and a char -- primitive types -- it probably won't cause any undesireable behaviour.</p>\n<p><strong>WARNING: IF YOU CONTINUE READING DO SO AT YOUR OWN PERIL !! GROSS DESCRIPTIONS OF UNDEFINED BEHAVIOUR AHEAD. THIS IS FOR EDUCATIONAL PURPOSES ONLY.</strong></p>\n<p><strong>Example 1:</strong> </p>\n<p>If you had two objects which were the same size and all their destructor did was zero out the memory then again it would probably not cause undersireable behaviour. </p>\n<p><strong>Example 2:</strong></p>\n<p>However if you had two objects where one type encapsulated a single 4 byte handle to a resource and the other had two such elements and you casted an array of the later into the singular case -- well then you would leak half of the handles of your array. The situation would look as follows:</p>\n<p>..2:[1|2][1|2]FREE..</p>\n<p>where the '2:' represents the size of the array. After a downcast the compiler will generate a delete that perceived the data as so :</p>\n<p>..2:[1][1]FREE...</p>\n<p>therefore after the free things would look like so:</p>\n<p>..FREE[1|2]FREE..</p>\n", "OwnerUserId": "153865", "LastEditorUserId": "153865", "LastEditDate": "2010-01-26T17:04:11.873", "Id": "2140401", "Score": "0", "CreationDate": "2010-01-26T15:30:18.110", "LastActivityDate": "2010-01-26T17:04:11.873"}, "2140319": {"CommentCount": "6", "AcceptedAnswerId": "2140413", "CreationDate": "2010-01-26T15:20:34.827", "LastActivityDate": "2010-01-27T15:23:32.677", "PostTypeId": "1", "ViewCount": "2813", "FavoriteCount": "5", "Title": "Can I new[], then cast the pointer, then delete[] safely with built-in types in C++?", "Id": "2140319", "Score": "12", "Body": "<p>In my code I have effectively the following:</p>\n<pre><code>wchar_t* buffer = new wchar_t[size];\n// bonus irrelevant code here\ndelete[] reinterpret_cast&lt;char*&gt;( buffer );\n</code></pre>\n<p>Types in question are all built-in and so they have trivial destructors. In VC++ the code above works allright - <code>new[]</code> just allocates memory, then <code>delete[]</code> just frees it.</p>\n<p>Is it acceptable in C++? Is it undefined behaviour?</p>\n", "Tags": "<c++><visual-c++><memory-management><undefined-behavior>", "OwnerUserId": "57428", "AnswerCount": "7"}, "2140934": {"ParentId": "2140319", "CommentCount": "0", "Body": "<p>iso14882 section 5.2.10.3:</p>\n<p><code>The mapping performed by reinterpret_cast is is implementation defined</code></p>\n<p>iso14882 section 5.3.5.2:</p>\n<p><code>The value of the operand of delete[] shall be the pointer value which resulted from a previous array new-expression</code></p>\n<p>In other words, it's implementation defined whether or not the delete[] invokes undefined behaviour. Steer clear.</p>\n", "OwnerUserId": "59379", "PostTypeId": "2", "Id": "2140934", "Score": "4", "CreationDate": "2010-01-26T16:45:28.430", "LastActivityDate": "2010-01-26T16:45:28.430"}, "2141189": {"ParentId": "2140319", "CommentCount": "0", "Body": "<p>Why are you using reinterpret_cast&lt;..&gt;? If you are writing something in pure C++, then you don't need reinterpret cast. In your case you are not allocating the memory for a object. You are allocating the memory for wchar_t. Why don't use to string instead of array of wchar_t?</p>\n", "OwnerUserId": "256543", "PostTypeId": "2", "Id": "2141189", "Score": "0", "CreationDate": "2010-01-26T17:20:24.963", "LastActivityDate": "2010-01-26T17:20:24.963"}, "2140421": {"ParentId": "2140319", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>At least as I'd read it, you have a static type (the type of the pointer) that differs from the dynamic type (the real type of the object it points at). That being the case, the second sentence of \u00a75.3.5/3 applies:</p>\n<blockquote>\n<p id=\"so_2140319_2140421_0\">In the second alternative (delete array) if the dynamic type of the\n  object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>Edit: Since what you apparently want is to allocate a buffer of \"raw\" memory instead of an array of objects, I'd advise using <code>::operator new</code> instead of <code>new[]</code>. In this case, what you're doing is clearly defined, and also gives the reader a clear indication of intent.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2010-01-26T16:14:32.557", "Id": "2140421", "Score": "5", "CreationDate": "2010-01-26T15:42:23.363", "LastActivityDate": "2010-01-26T16:14:32.557"}, "2148068": {"ParentId": "2140319", "CommentCount": "0", "Body": "<p>Since <code>wchar_t</code> and <code>char</code> are both built-in types, the correct deallocation function (<code>void operator delete(void* ptr)</code>) would be called, and there is no destructor to call.</p>\n<p>However the C++ 03 standard says the result of <code>reinterpret_cast&lt;T1*&gt;(T2*)</code> is undefined (section 5.2.10.7): </p>\n<blockquote>\n<p id=\"so_2140319_2148068_0\">A pointer to an object can be explicitly converted to a pointer to an object of different type. Except that\n  converting an rvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types\n  and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type\n  yields the original pointer value, the result of such a pointer conversion is unspecified. </p>\n</blockquote>\n<p>From a practical POV I can't imagine an implementation where a <code>wchar_t*</code> value is not a valid <code>char*</code> value, so your code <em>should</em> be OK on all the platforms. Just not standard-compliant...</p>\n", "OwnerUserId": "55870", "PostTypeId": "2", "Id": "2148068", "Score": "1", "CreationDate": "2010-01-27T15:23:32.677", "LastActivityDate": "2010-01-27T15:23:32.677"}, "bq_ids": {"n4140": {"so_2140319_2140413_1": {"section_id": 6042, "quality": 0.8888888888888888, "length": 8}, "so_2140319_2140413_2": {"section_id": 6106, "quality": 0.8181818181818182, "length": 9}, "so_2140319_2140421_0": {"section_id": 6107, "quality": 0.9285714285714286, "length": 13}, "so_2140319_2140413_0": {"section_id": 6107, "quality": 0.8, "length": 12}, "so_2140319_2140413_3": {"section_id": 6045, "quality": 0.8, "length": 16}, "so_2140319_2148068_0": {"section_id": 6045, "quality": 0.7368421052631579, "length": 28}}, "n3337": {"so_2140319_2140413_1": {"section_id": 5810, "quality": 0.8888888888888888, "length": 8}, "so_2140319_2140413_2": {"section_id": 5872, "quality": 0.8181818181818182, "length": 9}, "so_2140319_2140421_0": {"section_id": 5873, "quality": 0.9285714285714286, "length": 13}, "so_2140319_2140413_0": {"section_id": 5873, "quality": 0.8, "length": 12}, "so_2140319_2140413_3": {"section_id": 5813, "quality": 0.8, "length": 16}, "so_2140319_2148068_0": {"section_id": 5814, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_2140319_2140413_1": {"section_id": 7541, "quality": 0.8888888888888888, "length": 8}, "so_2140319_2140413_2": {"section_id": 7603, "quality": 0.8181818181818182, "length": 9}, "so_2140319_2140421_0": {"section_id": 7604, "quality": 0.9285714285714286, "length": 13}, "so_2140319_2140413_0": {"section_id": 7604, "quality": 0.8, "length": 12}, "so_2140319_2140413_3": {"section_id": 7544, "quality": 0.8, "length": 16}, "so_2140319_2148068_0": {"section_id": 7544, "quality": 0.7368421052631579, "length": 28}}}, "2140362": {"ParentId": "2140319", "CommentCount": "0", "Body": "<p>It is undefined behaviour because <code>delete[]</code> invokes the wrong destructor. However, <code>wchar_t</code> and <code>char</code> are PODs, so they have no dedicated destructor and all <code>delete[]</code> does is calling the heap implementation to free up the pointer. Therefore, it is most likely to work, no byte is lost. But strictly speaking it is still undefined.</p>\n", "OwnerUserId": "234053", "PostTypeId": "2", "Id": "2140362", "Score": "8", "CreationDate": "2010-01-26T15:25:18.357", "LastActivityDate": "2010-01-26T15:25:18.357"}});