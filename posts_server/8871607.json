post_cb({"8871641": {"ParentId": "8871607", "CommentCount": "3", "Body": "<p>Do your resize <strong>first</strong>, and it should work fine.</p>\n<pre><code>vector&lt;int&gt; v;\nv.resize(100);\nmemcpy(&amp;v[0], someArrayOfSize100, 100 * sizeof(int));\n</code></pre>\n", "OwnerUserId": "264712", "PostTypeId": "2", "Id": "8871641", "Score": "1", "CreationDate": "2012-01-15T17:16:59.723", "LastActivityDate": "2012-01-15T17:16:59.723"}, "8871607": {"CommentCount": "0", "AcceptedAnswerId": "8871647", "CreationDate": "2012-01-15T17:12:27.247", "LastActivityDate": "2012-01-15T17:19:44.497", "PostTypeId": "1", "ViewCount": "9636", "FavoriteCount": "4", "Title": "Copying an array into a std::vector", "Id": "8871607", "Score": "8", "Body": "<p>I was searching about this topic and I found many ways to convert an array[] to an std::vector, like using:</p>\n<pre><code>assign(a, a + n)\n</code></pre>\n<p>or, direct in the constructor:</p>\n<pre><code>std::vector&lt;unsigned char&gt; v ( a, a + n );\n</code></pre>\n<p>Those solve my problem, but I am wondering if it is possible (and correct) to do:</p>\n<pre><code>myvet.resize( 10 );\nmemcpy( &amp;myvet[0], buffer, 10 );\n</code></pre>\n<p>I am wondering this because I have the following code:</p>\n<pre><code>IDiskAccess::ERetRead nsDisks::DiskAccess::Read( std::vector&lt; uint8_t &gt;&amp; bufferRead, int32_t totalToRead )\n{\n    uint8_t* data = new uint8_t[totalToRead];\n    DWORD totalRead;\n    ReadFile( mhFile, data, totalToRead, &amp;totalRead, NULL );\n    bufferRead.resize( totalRead );\n    bufferRead.assign( data, data + totalRead );\n    delete[] data;\n\n    return IDiskAccess::READ_OK;\n}\n</code></pre>\n<p>And I would like to do:</p>\n<pre><code>IDiskAccess::ERetRead nsDisks::DiskAccess::Read( std::vector&lt; uint8_t &gt;&amp; bufferRead, int32_t totalToRead )\n{\n    bufferRead.resize( totalToRead );\n    DWORD totalRead;\n    ReadFile( mhFile, &amp;bufferRead[0], totalToRead, &amp;totalRead, NULL );\n    bufferRead.resize( totalRead );\n\n    return IDiskAccess::READ_OK;\n}\n</code></pre>\n<p>(I have removed the error treatment of the ReadFile function to simplify the post).</p>\n<p>It is working, but I am affraid that it is not safe. I believe it is ok, as the memory used by the vector is continuous, but I've never seen someone using vectors this way. </p>\n<p>Is it correct to use vectors like this? Is there any other better option?</p>\n", "Tags": "<c++><vector>", "OwnerUserId": "1122858", "AnswerCount": "6"}, "8871646": {"ParentId": "8871607", "CommentCount": "0", "Body": "<p>The memory in <code>vector</code> is guaranteed to be allocated contiguously, and unsigned char is POD, therefore it is totally safe to <code>memcpy</code> into it (assuming you don't copy more than you have allocated, of course).</p>\n", "OwnerUserId": "1032073", "PostTypeId": "2", "Id": "8871646", "Score": "2", "CreationDate": "2012-01-15T17:17:16.290", "LastActivityDate": "2012-01-15T17:17:16.290"}, "8871667": {"ParentId": "8871607", "CommentCount": "0", "Body": "<p>That approach is correct, it only depends on the vector having contiguous memory which is required by the standard. I believe that in c++11 there is a new <code>data()</code> member function in vectors that returns a pointer to the buffer. Also note that in the case of `memcpy you need to pass the size in bytes not e size of the array</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "8871667", "Score": "3", "CreationDate": "2012-01-15T17:19:44.497", "LastActivityDate": "2012-01-15T17:19:44.497"}, "8871655": {"ParentId": "8871607", "CommentCount": "0", "Body": "<p>Yes, it is fine to do that. You might want to do <code>myvet.data()</code> instead of <code>&amp;myvet[0]</code> if it looks better to you, but they both have the same effect. Also, if circumstances permit, you can use <code>std::copy</code> instead and have more type-safety and all those other C++ standard library goodies.</p>\n<p>The storage that a <code>vector</code> uses is guaranteed to be contiguous, which makes it suitable for use as a buffer or with other functions.</p>\n<p>Make sure that you don't modify the <code>vector</code> (such as calling <code>push_back</code> on it, etc) while you are using the pointer you get from <code>data</code> or <code>&amp;v[0]</code> because the <code>vector</code> could resize its buffer on one of those operations and invalidate the pointer.</p>\n", "OwnerUserId": "726361", "PostTypeId": "2", "Id": "8871655", "Score": "5", "CreationDate": "2012-01-15T17:18:07.443", "LastActivityDate": "2012-01-15T17:18:07.443"}, "8871647": {"ParentId": "8871607", "CommentCount": "0", "Body": "<p>Yes it is safe with <code>std::vector</code> C++ standard guarantees that the elements will be stored at contiguous memory locations.</p>\n<p>C++11 Standard:   </p>\n<p><strong>23.3.6.1 Class templatevector overview [vector.overview]</strong></p>\n<blockquote>\n<p id=\"so_8871607_8871647_0\">A vector is a sequence container that supports random access iterators. In addition,itsupports(amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, though hints can be given to improve e\ufb03ciency. <strong>The elements of a vector are stored contiguously</strong>, meaning that ifv is avector whereT is some type other than bool, then it obeys the identity&amp;v[n] == &amp;v[0] + n for all0 &lt;= n &lt; v.size().</p>\n</blockquote>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "8871647", "Score": "8", "CreationDate": "2012-01-15T17:17:19.533", "LastActivityDate": "2012-01-15T17:17:19.533"}, "bq_ids": {"n4140": {"so_8871607_8871647_0": {"section_id": 955, "quality": 0.8367346938775511, "length": 41}}, "n3337": {"so_8871607_8871647_0": {"section_id": 943, "quality": 0.8367346938775511, "length": 41}}, "n4659": {"so_8871607_8871647_0": {"section_id": 1016, "quality": 0.5102040816326531, "length": 25}}}, "8871648": {"ParentId": "8871607", "CommentCount": "0", "Body": "<p>Yes, the solution using <code>memcpy</code> is correct; the buffer held by a <code>vector</code> is contiguous. But it's not quite type-safe, so prefer <code>assign</code> or <code>std::copy</code>.</p>\n", "OwnerUserId": "166749", "PostTypeId": "2", "Id": "8871648", "Score": "1", "CreationDate": "2012-01-15T17:17:24.310", "LastActivityDate": "2012-01-15T17:17:24.310"}});