post_cb({"46894136": {"CommentCount": "6", "ViewCount": "153", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2017-10-23T16:25:42.827", "LastActivityDate": "2017-10-23T16:59:24.810", "Title": "Class template argument deduction failed with derived class", "FavoriteCount": "2", "LastEditDate": "2017-10-23T16:59:24.810", "Id": "46894136", "Score": "8", "Body": "<pre><code>#include &lt;utility&gt;\n\ntemplate&lt;class T1, class T2&gt;\nstruct mypair : std::pair&lt;T1, T2&gt;\n{ using std::pair&lt;T1, T2&gt;::pair; };\n\nint main()\n{\n    (void)std::pair(2, 3); // It works\n    (void)mypair(2, 3);    // It doesn't work\n}\n</code></pre>\n<p>Is the above well formed?</p>\n<p>Is it possible deduce the class template arguments in the second case if the constructors are being inherited? Are the constructors of <code>std::pair</code> participating in the creation of implicit deduction guides for <code>mypair</code>?</p>\n<p>My compiler is g++ 7.2.0.</p>\n", "Tags": "<c++><c++1z><template-deduction><deduction-guide>", "OwnerUserId": "1794803", "AnswerCount": "1"}, "46894648": {"ParentId": "46894136", "CommentCount": "4", "Body": "<p>I think this is a gcc bug (or at least a minor core language wording defect).</p>\n<p>Inherited constructors <em>do</em> count as constructors, according to <a href=\"http://eel.is/c++draft/basic.namespace#namespace.udecl-16.sentence-4\" rel=\"nofollow noreferrer\">[namespace.udecl]/16</a>:</p>\n<blockquote>\n<p id=\"so_46894136_46894648_0\">Likewise, constructors that are introduced by a <em>using-declaration</em> are treated as though they were constructors of the derived class when looking up the constructors of the derived class ([class.qual]) or forming a set of overload candidates ([over.match.ctor], [over.match.copy], [over.match.list])</p>\n</blockquote>\n<p>That list of conditions technically doesn't include [over.match.class.deduct], but the implication is that the base class constructors <em>are</em> constructors of the derived class. And the rule in <a href=\"http://eel.is/c++draft/over.match.class.deduct#1.1\" rel=\"nofollow noreferrer\">[over.match.class.deduct]</a> is to consider:</p>\n<blockquote>\n<p id=\"so_46894136_46894648_1\">If <code>C</code> is defined, for <strong>each</strong> constructor of <code>C</code>, a function template with the following properties [...]</p>\n</blockquote>\n<p>We <em>are</em> looking up constructors of the derived class, just not in any of the listed cases. But this example should work conceptually:</p>\n<pre><code>template &lt;class T&gt; struct base { base(T ) { } };\ntemplate &lt;class T&gt; struct derived : base&lt;T&gt; { using base&lt;T&gt;::base; };\n\nbase b = 4;    // ok\nderived d = 4; // error\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "46894648", "Score": "3", "CreationDate": "2017-10-23T16:55:42.013", "LastActivityDate": "2017-10-23T16:55:42.013"}, "bq_ids": {"n4140": {"so_46894136_46894648_1": {"section_id": 5768, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_46894136_46894648_1": {"section_id": 5541, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_46894136_46894648_1": {"section_id": 623, "quality": 0.8571428571428571, "length": 6}, "so_46894136_46894648_0": {"section_id": 6939, "quality": 0.8333333333333334, "length": 20}}}});