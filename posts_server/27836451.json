post_cb({"27836451": {"ViewCount": "1565", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A{\n\n};\n\nclass B: public A{\n   public:\n          void f(A *ptr){\n               if(dynamic_cast&lt;C *&gt;(ptr)!=0){            // errors in this line\n                   cout&lt;&lt;\"ptr is pointing to C object\\n\";\n               } \n          }                 \n};\n\nclass C: public B{\n\n};\n\nint main(){\n\n  A *aptr = new C();\n  B *bptr = new B();\n  bptr-&gt;f(aptr);\n\n  return 0;\n}\n</code></pre>\n<p>When I try to compile this I get the error: </p>\n<p><code>'C' has not been declared.</code></p>\n<p>So I add a forward declaration <code>class C;</code> just above the code of <code>class B</code> and then try to compile it again but then it gives the error:</p>\n<p><code>cannot dynamic_cast 'ptr' (of type 'class A*') to type 'struct C*' (target is not pointer or reference to complete type)</code></p>\n<p>1) Why in the first error, <code>class B</code> cannot see its derived <code>class C</code> while they 're in the same .cpp file?</p>\n<p>2) And why in the second error compiler says that <code>class C</code> is not a pointer to complete type?</p>\n<p>Thanks in advance.</p>\n", "AcceptedAnswerId": "27836567", "Title": "CLASS_NAME not declared - cannot dynamic_cast (target is not pointer or reference to complete type)", "CreationDate": "2015-01-08T09:09:23.103", "Id": "27836451", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-01-08T09:41:52.057", "Score": "-1", "OwnerUserId": "4413894", "Tags": "<c++><dynamic-cast>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27836451_27836567_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6011}}, "n3337": {"so_27836451_27836567_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5779}}, "n4659": {"so_27836451_27836567_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7510}}}, "27836567": {"Id": "27836567", "PostTypeId": "2", "Body": "<p>Define <code>B::f()</code> later.</p>\n<pre><code>class B: public A{\npublic:\n      void f(A *ptr);    \n};\nclass C : public B { /* ... */ };\n\nvoid B::f(A *ptr) {\n           if(dynamic_cast&lt;C *&gt;(ptr)!=0){\n               cout&lt;&lt;\"ptr is pointing to C object\\n\";\n           } \n}\n</code></pre>\n<p>As stated in C++ standard [expr.dynamic.cast],</p>\n<blockquote>\n<p id=\"so_27836451_27836567_0\">The result of the expression <code>dynamic_cast&lt;T&gt;(v)</code> is the result of\n  converting the expression <code>v</code> to type <code>T</code>. <code>T</code> shall be a pointer or\n  reference to a complete class type, or \u201cpointer to <em>cv</em> void.\u201d</p>\n</blockquote>\n", "LastEditorUserId": "718379", "LastActivityDate": "2015-01-08T09:41:52.057", "Score": "1", "CreationDate": "2015-01-08T09:17:00.643", "ParentId": "27836451", "CommentCount": "1", "OwnerUserId": "718379", "LastEditDate": "2015-01-08T09:41:52.057"}});