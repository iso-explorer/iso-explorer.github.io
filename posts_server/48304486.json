post_cb({"bq_ids": {"n4140": {"so_48304486_48314806_2": {"length": 9, "quality": 0.9, "section_id": 304}, "so_48304486_48314806_1": {"length": 17, "quality": 1.0, "section_id": 305}, "so_48304486_48314806_0": {"length": 18, "quality": 0.75, "section_id": 302}}, "n3337": {"so_48304486_48314806_2": {"length": 9, "quality": 0.9, "section_id": 295}, "so_48304486_48314806_1": {"length": 17, "quality": 1.0, "section_id": 296}, "so_48304486_48314806_0": {"length": 18, "quality": 0.75, "section_id": 293}}, "n4659": {"so_48304486_48314806_2": {"length": 10, "quality": 1.0, "section_id": 311}, "so_48304486_48314806_1": {"length": 17, "quality": 1.0, "section_id": 312}, "so_48304486_48314806_0": {"length": 24, "quality": 1.0, "section_id": 309}}}, "48304486": {"ViewCount": "62", "Body": "<pre><code>template &lt;typename T&gt;\nvoid fun1(T t) {} \n\ntemplate &lt;typename T&gt;\nvoid fun2(T &amp;&amp; t) {}\n\nint i = 1;\nfun1(i); // the deduced type of T is int\nfun2(i); // the deduced type of T is int &amp;\n</code></pre>\n<p>The deduced type of T in fun1(i) and fun2(i) are <code>int</code> and <code>int &amp;</code> respectively, can anyone explain the mechanism how compiler do deduction?</p>\n<h3>UPDATE</h3>\n<p>This question is not a duplicate of <a href=\"https://stackoverflow.com/questions/42145453/type-not-deduced-to-be-r-value-reference-why-not\">Type not deduced to be r-value reference: why not?</a>, because:</p>\n<p>The later question explained the deduction rules for :</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(T&amp;&amp; )\n</code></pre>\n<p><strong>Here, I want to know the difference of deduction rules for</strong> </p>\n<pre><code>template &lt;class T&gt;\nvoid foo(T&amp;&amp; )\n</code></pre>\n<p>and</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(T )\n</code></pre>\n", "Title": "Why deduced types of fun(T t) and fun(T && t) are different in C++?", "CreationDate": "2018-01-17T15:22:59.353", "LastActivityDate": "2018-01-18T06:05:12.250", "CommentCount": "5", "LastEditDate": "2018-01-17T15:38:34.320", "PostTypeId": "1", "LastEditorUserId": "5432806", "Id": "48304486", "Score": "0", "OwnerUserId": "5432806", "Tags": "<c++><rvalue-reference>", "AnswerCount": "2"}, "48314806": {"Id": "48314806", "PostTypeId": "2", "Body": "<p>Because the type of <code>i</code> is <code>int</code>, not <code>int&amp;</code>. As <a href=\"http://www.eel.is/c++draft/temp.deduct.call#1\" rel=\"nofollow noreferrer\">[temp.deduct.call] paragraph 1</a> says</p>\n<blockquote>\n<p id=\"so_48304486_48314806_0\">Template argument deduction is done by comparing each function template \n  parameter type (call it P) that contains template-parameters that participate in template argument deduction with the type of the corresponding argument of the call (call it A) as described below.</p>\n</blockquote>\n<p>And <a href=\"http://www.eel.is/c++draft/temp.deduct.call#4\" rel=\"nofollow noreferrer\">[temp.deduct.call] paragraph 4</a> says</p>\n<blockquote>\n<p id=\"so_48304486_48314806_1\">In general, the deduction process attempts to find template argument values that will make the deduced A identical to A (after the type A is transformed as described above).</p>\n</blockquote>\n<p>The forwarding reference case is a special case. As <a href=\"http://www.eel.is/c++draft/temp.deduct.call#3\" rel=\"nofollow noreferrer\">[temp.deduct.call] paragraph 3</a> explicitly says</p>\n<blockquote>\n<p id=\"so_48304486_48314806_2\">If P is a forwarding reference and the argument is an lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction.</p>\n</blockquote>\n", "LastActivityDate": "2018-01-18T06:05:12.250", "Score": "0", "CreationDate": "2018-01-18T06:05:12.250", "ParentId": "48304486", "CommentCount": "0", "OwnerUserId": "5376789"}, "48305151": {"Id": "48305151", "PostTypeId": "2", "Body": "<p>That is aperfect forward which can produce different outcomes depending on what arguments are provided to the template.</p>\n<blockquote>\n<p id=\"so_48304486_48305151_0\">Perfect forwarding reduces the need for overloaded functions and helps\n  avoid the forwarding problem. The forwarding problem can occur when\n  you write a generic function that takes references as its parameters\n  and it passes (or forwards) these parameters to another function. For\n  example, if the generic function takes a parameter of type const T&amp;,\n  then the called function cannot modify the value of that parameter. If\n  the generic function takes a parameter of type T&amp;, then the function\n  cannot be called by using an rvalue (such as a temporary object or\n  integer literal).</p>\n<p id=\"so_48304486_48305151_1\">Ordinarily, to solve this problem, you must provide overloaded\n  versions of the generic function that take both T&amp; and const T&amp; for\n  each of its parameters. As a result, the number of overloaded\n  functions increases exponentially with the number of parameters.\n  Rvalue references enable you to write one version of a function that\n  accepts arbitrary arguments and forwards them to another function as\n  if the other function had been called directly.</p>\n</blockquote>\n<p><a href=\"https://msdn.microsoft.com/en-us/library/dd293668.aspx\" rel=\"nofollow noreferrer\">Rvalue Reference</a></p>\n<blockquote>\n<p id=\"so_48304486_48305151_2\">Forwarding references\n  Forwarding references are a special kind of references that preserve the value category of a function argument, making it possible to forward it by means of std::forward. Forwarding references are either:</p>\n</blockquote>\n<ol>\n<li>function parameter of a function template declared as rvalue reference to cv-unqualified type template parameter of that same function template:</li>\n<li>auto&amp;&amp; except when deduced from a brace-enclosed initializer list.</li>\n</ol>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/reference\" rel=\"nofollow noreferrer\">Forwarding Reference</a></p>\n<p>How it is donde is explained here:\n<a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction#Deduction_from_a_function_call\" rel=\"nofollow noreferrer\">Template Deduction</a></p>\n", "LastActivityDate": "2018-01-17T15:57:07.167", "Score": "0", "CreationDate": "2018-01-17T15:57:07.167", "ParentId": "48304486", "CommentCount": "0", "OwnerUserId": "3203817"}});