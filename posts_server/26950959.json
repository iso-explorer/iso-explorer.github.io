post_cb({"bq_ids": {"n4140": {"so_26950959_26951975_0": {"length": 65, "quality": 0.9420289855072463, "section_id": 6007}}, "n3337": {"so_26950959_26951975_0": {"length": 69, "quality": 1.0, "section_id": 5775}}, "n4659": {"so_26950959_26951975_0": {"length": 65, "quality": 0.9420289855072463, "section_id": 7506}}}, "26950959": {"ViewCount": "219", "Body": "<p>Can you help me to understand why the compiler is giving me those error messages? I believe members of volatile objects are volatile too. I'm referring from <a href=\"https://stackoverflow.com/questions/4479597/does-making-a-struct-volatile-make-all-its-members-volatile\">here</a>. But it shows up that if we have a structure:</p>\n<pre><code>struct someStruct\n{\n    int d;\n};\n</code></pre>\n<p>And 'p' is a defined like:</p>\n<pre><code>volatile someStruct* volatile* p;\n</code></pre>\n<p><code>&amp;(*p)-&gt;d</code> have the following type 'int* volatile*' instead of 'volatile int* volatile*'. Below is the actual code on which I'm working on.</p>\n<hr>\n<p>The lines (marked with error 1 &amp; 2) is where the compiler throws an error messages:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;windows.h&gt;\n\nusing namespace std;\n\nstruct ThreadInfo\n{\n    bool bWaiting = false;\n\n    bool bWorking = false;\n};\n\nstruct lThreadInfo\n{\n    ThreadInfo d;\n    lThreadInfo *pNextList = nullptr;\n} volatile *volatile lThreads(nullptr);\n\nthread_local ThreadInfo* currentThr(nullptr);\n\nvoid CreateThread_(void (*pFunc)(ThreadInfo*))\n{\n    volatile lThreadInfo* volatile* p = &amp;lThreads;\n\n    for(; *p; p = &amp;(*p)-&gt;pNextList); //**//error 1!**\n\n    *p = new lThreadInfo;\n\n    CreateThread(\n            nullptr,                   // default security attributes\n            0,                      // use default stack size\n            (long unsigned int (*)(void*))pFunc,       // thread function name\n            &amp;(*p)-&gt;d,          // argument to thread function     **//error 2!**\n            0,                      // use default creation flags\n            nullptr);\n}\n</code></pre>\n<p>The errors messages are the following:</p>\n<pre><code>error 1: invalid conversion from 'lThreadInfo* volatile*' to 'volatile lThreadInfo* volatile*' [-fpermissive]\nerror 2: invalid conversion from 'volatile void*' to 'LPVOID {aka void*}' [-fpermissive]\n</code></pre>\n<p><sup><strong>Note</strong>: I know that volatile have nothing to do with thread-safety, so don't bother telling me so.</sup>\n<sup><strong>Note1</strong>: I'm using mingw64 compiler on windows.</sup></p>\n</hr>", "AcceptedAnswerId": "26951975", "Title": "Volatile related error in C++ code", "CreationDate": "2014-11-15T21:32:48.767", "Id": "26950959", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:52:18.833", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-15T23:27:41.843", "Score": "5", "OwnerUserId": "4031604", "Tags": "<c++><windows><c++11><gcc><volatile>", "AnswerCount": "1"}, "26951975": {"Id": "26951975", "PostTypeId": "2", "Body": "<p><code>pNextList</code>, through a <code>volatile</code> access-path, is <code>volatile</code> too. But <code>pNextList</code> is the <strong>pointer</strong>. The <strong>pointee</strong> type has the same cv-qualification as before.</p>\n<p>That is, for </p>\n<pre><code>struct A\n{\n    lThreadInfo* p;\n};\n\nsomeStruct volatile* volatile* p;\n</code></pre>\n<ul>\n<li><code>*p</code> is an lvalue of type <code>someStruct volatile* volatile</code></li>\n<li><code>(*p)-&gt;d</code> is an lvalue of type <code>lThreadInfo* volatile</code>.</li>\n</ul>\n<p>So in the type of <code>(*p)-&gt;d</code> you're missing the volatile between <code>lThreadInfo</code> and <code>*</code>. [expr.ref]/4:</p>\n<blockquote>\n<p id=\"so_26950959_26951975_0\">If <code>E2</code> is a non-static data member and the type of <code>E1</code> is \u201c<em>cq1 vq1</em>\n<code>X</code>\u201d, and the type of <code>E2</code> is \u201c<em>cq2 vq2</em> <code>T</code>\u201d, the expression\n  designates the named member of the object designated by the first\n  expression. If <code>E1</code> is an lvalue, then <code>E1.E2</code> is an lvalue; if <code>E1</code>\n  is an xvalue, then <code>E1.E2</code> is an xvalue; otherwise, it is a prvalue.\n  <strong>Let the notation <em>vq12</em> stand for the \u201cunion\u201d of <em>vq1</em> and <em>vq2</em>; that is, if <em>vq1</em> or <em>vq2</em> is <code>volatile</code>, then\n  <em>vq12</em> is <code>volatile</code>.</strong> Similarly, let the notation <em>cq12</em> stand for the \u201cunion\u201d of <em>cq1</em> and <em>cq2</em> ; that is, if <em>cq1</em> or <em>cq2</em> is\n  <code>const</code>, then <em>cq12</em> is <code>const</code>. If <code>E2</code> is declared to be a mutable\n  member, then the type of <code>E1.E2</code> is \u201c<em>vq12</em> <code>T</code>\u201d. If <code>E2</code> is not\n  declared to be a mutable member, then <strong>the type of <code>E1.E2</code> is \u201c<em>cq12</em>\n<em>vq12</em> <code>T</code>\u201d</strong>.</p>\n</blockquote>\n<p><em>vq1</em> is <code>volatile</code> and <em>vq2</em> is empty. Thus <em>vq12</em> is <code>volatile</code>. Thus the type of the expression is <code>volatile T</code>, which is <code>lThreadInfo* volatile</code>.</p>\n", "LastActivityDate": "2014-11-15T23:27:41.843", "CommentCount": "0", "CreationDate": "2014-11-15T23:27:41.843", "ParentId": "26950959", "Score": "2", "OwnerUserId": "3647361"}});