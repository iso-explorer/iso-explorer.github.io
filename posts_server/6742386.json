post_cb({"bq_ids": {"n4140": {"so_6742386_6745554_1": {"length": 15, "quality": 0.5172413793103449, "section_id": 6186}, "so_6742386_6745554_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 87}}, "n3337": {"so_6742386_6745554_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 82}}}, "6744787": {"PostTypeId": "2", "Body": "<p>There's a stadard solution for this. Convert iteration into recursion. </p>\n<pre><code>template&lt;int i&gt;\nvoid Device::createSubDomains()\n{\n    SubDomain&lt;i&gt; tmp(member);\n    // some operations on tmp\n    createSubDomains&lt;i-1&gt;();\n}\ntemplate&lt;&gt;\nvoid Device&lt;-1&gt;::createSubDomains()\n{\n  // End of recursion.\n}\n</code></pre>\n<p>Note: you can't use a runtime <code>if(i!=0) createSubDomains&lt;i-1&gt;();</code>.</p>\n<p>2017 Note: you can now use a compile-time <code>if constexpr(i!=0) createSubDomains&lt;i-1&gt;();</code></p>\n", "LastActivityDate": "2017-09-13T14:44:32.963", "LastEditorUserId": "15416", "Id": "6744787", "CommentCount": "1", "CreationDate": "2011-07-19T09:09:48.637", "ParentId": "6742386", "Score": "7", "OwnerUserId": "15416", "LastEditDate": "2017-09-13T14:44:32.963"}, "6742421": {"PostTypeId": "2", "Body": "<p><strong>Re-Edit</strong>:</p>\n<p>My previous answer was correct. I have tried your code, it's giving <strong>compiler error</strong>. You cannot declare objects like that, as <code>i</code> cannot remain a compile time constant (<em>as you are intending to do</em> <code>i++</code>). <code>template</code> parameter must always be compile time constants. Here is <a href=\"http://www.ideone.com/KLc5y\" rel=\"nofollow\">the demo</a>.</p>\n<p>Also note that, loop unrolling is done for normal loops also, as part of optimization by compilers. It's not limited to <code>template</code>s.</p>\n", "LastActivityDate": "2011-07-19T09:45:49.213", "LastEditorUserId": "514235", "Id": "6742421", "CommentCount": "14", "CreationDate": "2011-07-19T04:51:50.003", "ParentId": "6742386", "Score": "1", "OwnerUserId": "514235", "LastEditDate": "2011-07-19T09:45:49.213"}, "6742386": {"ViewCount": "2120", "Body": "<p>wikipedia (<a href=\"http://en.wikipedia.org/wiki/Template_metaprogramming#Compile-time_code_optimization\" rel=\"nofollow noreferrer\">here</a>) gives a compile time unrolling of for loop.......\ni was wondering can we use a similar for loop with template statements inside...\nfor example...</p>\n<p>is the following loop valid</p>\n<pre><code>template&lt;int max_subdomain&gt;\nvoid Device&lt;max_sudomain&gt;::createSubDomains()\n{\n    for(int i=0; i&lt; max_subdomain; ++i)\n    {\n        SubDomain&lt;i&gt; tmp(member);\n        ...\n        // some operations on tmp\n        ...\n    }\n}\n</code></pre>\n<p>SubDomain is a class which takes in the a template parameter int and here has been constructed with an argument that is a member of the Device class.</p>\n<p>Thanks for the answer guys...\nnow that you know what i want...\nis there anyway i achieve what i want to??</p>\n<p>i finally got what i wanted..............\ninstead of using the for loop directly...\none can instead use the <a href=\"http://en.wikipedia.org/wiki/Template_metaprogramming#Compile-time_code_optimization\" rel=\"nofollow noreferrer\">Boost::MPL for_each construct</a>. I haven't yet implemented it but I am guessing that this provides a way to do what i wanted.....</p>\n<p>I took the answer from another stack overflow question <a href=\"https://stackoverflow.com/questions/1032602/template-ing-a-for-loop-in-c\">here</a>... However the <a href=\"https://stackoverflow.com/questions/1032602/template-ing-a-for-loop-in-c/1032784#1032784\">comment</a> to the same question decries its use because it would be very slow (for large for loops of course)... however.. for loops which are not large i don't think there should be any bloating... i'll try the code and let you know the results.... </p>\n<p>the use is illustrated well in the <a href=\"http://www.boost.org/doc/libs/1_46_1/libs/mpl/doc/refmanual/for-each.html#example\" rel=\"nofollow noreferrer\">example</a></p>\n", "AcceptedAnswerId": "6742421", "Title": "template arguments inside a compile time unrolled for loop?", "CreationDate": "2011-07-19T04:44:37.367", "Id": "6742386", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:31:18.880", "LastEditorUserId": "-1", "LastActivityDate": "2017-09-13T14:44:32.963", "Score": "6", "OwnerUserId": "796530", "Tags": "<c++><templates><loop-unrolling>", "AnswerCount": "3"}, "6745554": {"PostTypeId": "2", "Body": "<p>Even though you already accepted @iammilind 's answer, let me propose another one, because his reasoning for why <code>i</code> is not compile-time-constant <s>is</s> was not correct.</p>\n<p>Suppose you have</p>\n<pre><code>    template&lt;unsigned int MAX&gt; struct SubDomain {...};\n    ...\n</code></pre>\n<p>and you want to declare an instance of it ...</p>\n<pre><code>    SubDomain&lt;i&gt; tmp(member);\n</code></pre>\n<p>then <code>i</code> must be a commonly so-called <em>compile-time-constant</em>. What is that?</p>\n<p><br/></p>\n<h1>Pedantry</h1>\n<p>The standard assigns the term <code>nontype template argument</code> to template arguments that are not types (D'Oh). </p>\n<p><strong>14.3.2 <em>Template non-type arguments</em> [temp.arg.nontype]</strong></p>\n<blockquote>\n<p id=\"so_6742386_6745554_0\">A template-argument for a non-type, non-template template-parameter shall be one of:<br/>\n    \u2014 an integral constant-expression of integral or enumeration type; or<br/>\n    \u2014 ... [more follow, but are not relevant]</p>\n</blockquote>\n<p>Right the first point contains a reference for further research: <code>an integral constant-expression</code>. This leads us to </p>\n<p><strong>5.19 <em>Constant expressions</em> [expr.const]</strong></p>\n<blockquote>\n<p id=\"so_6742386_6745554_1\">In several places, C + + requires expressions that evaluate to an integral or enumeration constant: as array\n    bounds (8.3.4, 5.3.4), as case expressions (6.4.2), as bit-field lengths (9.6), as enumerator initializers (7.2),\n    as static member initializers (9.4.2), <strong><em>and as integral or enumeration non-type template arguments (14.3)</em></strong>.</p>\n</blockquote>\n<p>Then, the key is:</p>\n<blockquote>\n<p id=\"so_6742386_6745554_2\">An integral constant-expression can involve only literals (2.13), enumerators, const variables or static\n    data members of integral or enumeration types initialized with constant expressions (8.5), non-type template\n    parameters of integral or enumeration types, and sizeof expressions.</p>\n</blockquote>\n<p><br/></p>\n<h1>Pedantry application</h1>\n<p>If we look back at your loop:</p>\n<pre><code>for (int i=...\n    ...\n    SubDomain&lt;i&gt;\n</code></pre>\n<p>then we can now observe that <code>i</code> is not allowed there. Why? Because <code>i</code> is NOT a <code>const variable</code>.</p>\n<p>The observing reader might now think you can circumvent this:</p>\n<pre><code>for (int i=...\n        ...\n        const int I = i;\n        SubDomain&lt;I&gt;\n</code></pre>\n<p>But is this really allowed?  Negative, <code>I = i</code> is not an <em>integral constant-expression</em>, because <code>i</code> is not. It helps to realise that the rule for integral constant-expressions is applied recursively.</p>\n<p>E.g., the following is valid code:</p>\n<pre><code>template &lt;int&gt; void foo() {}     \nint main () {\n    const int ccI = 0;\n    const int ccJ = ccI*2;\n    const int ccK = ccJ/4;     \n    foo&lt;ccK&gt;();\n}\n</code></pre>\n<p>But if make just one part of the chain non-const, then <code>ccK</code> is not considered integral constant anymore:</p>\n<pre><code>template &lt;int&gt; void foo() {}     \nint main () {\n          int ccI = 0;\n    const int ccJ = ccI*2;  // not compile time constant\n    const int ccK = ccJ/4;  // same\n\n    foo&lt;ccK&gt;();             // error\n}\n</code></pre>\n<p><br/></p>\n<h1>Summary</h1>\n<p>So, in human readable form, template arguments that are not types, but (integer) values, must be compile-time-constant:</p>\n<ul>\n<li>the initializer of a compile-time-constant must only involve other compile-time-constants</li>\n<li>a literal value is a compile-time-constant</li>\n<li>an enum value is a compile-time-constant</li>\n<li>function-calls don't give compile-time-constants (for some advanced reasons)</li>\n</ul>\n", "LastActivityDate": "2011-07-19T10:18:52.723", "LastEditorUserId": "76722", "Id": "6745554", "CommentCount": "0", "CreationDate": "2011-07-19T10:13:48.517", "ParentId": "6742386", "Score": "3", "OwnerUserId": "76722", "LastEditDate": "2011-07-19T10:18:52.723"}});