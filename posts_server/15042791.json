post_cb({"bq_ids": {"n4140": {"so_15042791_15043019_0": {"length": 23, "quality": 0.92, "section_id": 571}}, "n3337": {"so_15042791_15043019_0": {"length": 23, "quality": 0.92, "section_id": 562}}, "n4659": {"so_15042791_15043019_0": {"length": 23, "quality": 0.92, "section_id": 594}}}, "15043019": {"Id": "15043019", "PostTypeId": "2", "Body": "<p>The problem is that <code>endl</code> is a manipulator defined as a <em>function template</em>. Paragraph 27.7.1 of the C++11 Standard specifies its signature: </p>\n<pre><code>template &lt;class charT, class traits&gt;\nbasic_ostream&lt;charT,traits&gt;&amp; endl(basic_ostream&lt;charT,traits&gt;&amp; os);\ntemplate &lt;class charT, class traits&gt;\n</code></pre>\n<p>Moreover, per Paragraph 13.3.1 on overload resolution:</p>\n<blockquote>\n<p id=\"so_15042791_15043019_0\">In each case where a candidate is a function template, <strong>candidate function template specializations are generated using template argument deduction</strong> (14.8.3, 14.8.2). Those candidates are then handled as candidate functions in the usual way.</p>\n</blockquote>\n<p>Your <code>operator &lt;&lt;</code> is a defined as a template, and the compiler needs to deduce the type of <code>T</code>. However, how can the compiler know which instantiation of <code>endl</code> you meant? How can it deduce the template arguments <code>charT</code> and <code>traits</code>? There is nothing else in your call to <code>operator &lt;&lt;</code> from which it could be deduced. </p>\n<p>You have two ways out of this problem. Either you cast the type of <code>endl</code> explicitly, to tell the compiler which overload shall be picked:</p>\n<pre><code>foo &lt;&lt; (std::ostream&amp; (*)(std::ostream&amp;))endl;\n</code></pre>\n<p>Or, as you did, you create an overload of <code>operator &lt;&lt;</code> which accepts a function with that specific signature. Your compiler will now select it:</p>\n<pre><code>Foo&amp; operator&lt;&lt;(ostream&amp; (*f)(ostream&amp;)) \n{\n    return *this &lt;&lt; f;\n}\n</code></pre>\n<p>Inside this function definition there is no ambiguity as to what <code>f</code> is: its type is precisely defined. However, be careful here: this function doesn't likely do what you expect! In fact, it just keeps calling itself, generating an <strong>infinite recursion</strong>!</p>\n<p>Therefore, this assertion:</p>\n<blockquote>\n<p id=\"so_15042791_15043019_1\">[...] note I'm actually calling my other method implementation:</p>\n</blockquote>\n<p>Is <strong>incorrect</strong>: you're not calling the other method implementation, you keep calling the same function over and over again.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-23T17:07:07.693", "Score": "1", "CreationDate": "2013-02-23T16:54:20.187", "ParentId": "15042791", "CommentCount": "1", "LastEditDate": "2013-02-23T17:07:07.693", "OwnerUserId": "1932150"}, "15042875": {"Id": "15042875", "PostTypeId": "2", "Body": "<p><code>endl</code> is a manipulator, i.e. it's an <em>unresolved function type</em>. There are several overloads, and the type deduction is unable to decide which one you want.</p>\n<p>More specificly, here's what <code>endl</code> looks like (in GNU libc++):</p>\n<pre><code>/**\n *  @brief  Write a newline and flush the stream.\n *\n *  This manipulator is often mistakenly used when a simple newline is\n *  desired, leading to poor buffering performance.  See\n *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html\n *  for more on this subject.\n*/\ntemplate&lt;typename _CharT, typename _Traits&gt;\n  inline basic_ostream&lt;_CharT, _Traits&gt;&amp;\n  endl(basic_ostream&lt;_CharT, _Traits&gt;&amp; __os)\n  { return flush(__os.put(__os.widen('\\n'))); }\n</code></pre>\n<p><strong>Updated</strong> So, the problem is, the compiler cannot <em>deduce</em> which <em>instance of <code>endl</code></em> you would be passing (it's an unresolved overload). <strong><em>You might work around this by doing a <code>static_cast&lt;ostream&amp;(*)(ostream&amp;)&gt;(endl)</code> instead.</em></strong></p>\n<p>Of course, that's not convenient. Here's a simple fix: <a href=\"http://liveworkspace.org/code/2F2VHe%241\" rel=\"nofollow\">http://liveworkspace.org/code/2F2VHe$1</a></p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Foo : public std::ostream\n{\n    public:\n        template&lt;typename T&gt;\n        Foo&amp; operator&lt;&lt;(T&amp;&amp; t) {\n            cout &lt;&lt; std::forward&lt;T&gt;(t);\n            return *this;\n        }\n\n        typedef std::ostream&amp; (manip)(std::ostream&amp;);\n\n        Foo&amp; operator&lt;&lt;(manip&amp; m) {\n            cout &lt;&lt; m;\n            return *this;\n        }\n};\n\nint main() {\n    Foo foo;\n    foo &lt;&lt; \"Hello World\"; // perfectly fine\n    foo &lt;&lt; endl; // everything is fine\n\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "85371", "LastActivityDate": "2013-02-23T17:17:15.497", "Score": "3", "CreationDate": "2013-02-23T16:40:56.097", "ParentId": "15042791", "CommentCount": "7", "LastEditDate": "2013-02-23T17:17:15.497", "OwnerUserId": "85371"}, "15042791": {"ViewCount": "672", "Body": "<p>I'm unsure as to whether this code will not compile.</p>\n<p>The example code I'm working with:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Foo {\n    public:\n        template&lt;typename T&gt;\n        Foo&amp; operator&lt;&lt;(const T&amp; t) {\n            cout &lt;&lt; t;\n            return *this;\n        }\n};\n\nint main() {\n    Foo foo;\n    foo &lt;&lt; \"Hello World\"; // perfectly fine\n    foo &lt;&lt; endl; // shit hits the fan\n\n    return 0;\n}\n</code></pre>\n<p>This is the error:</p>\n<pre><code>test.cpp:19:12: error: no match for \u2018operator&lt;&lt;\u2019 in \u2018foo &lt;&lt; std::endl\u2019\ntest.cpp:19:12: note: candidates are:\ntest.cpp:10:14: note: template&lt;class T&gt; Foo&amp; Foo::operator&lt;&lt;(const T&amp;)\ntest.cpp:10:14: note:   template argument deduction/substitution failed:\ntest.cpp:19:12: note:   couldn't deduce template parameter \u2018T\u2019\n</code></pre>\n<p>I'm confused as to why it cannot substitute the function type of <code>endl</code> (<code>ostream&amp; (*)(ostream&amp;)</code>) for <code>T</code>, where it clearly is fine with doing it when you specify <code>cout &lt;&lt; endl;</code></p>\n<p>I find it additionally puzzling that this fixes the problem [ edited ]</p>\n<pre><code>Foo&amp; operator&lt;&lt;(ostream&amp; (*f)(ostream&amp;)) {\n    cout &lt;&lt; f;\n    return *this;\n}\n</code></pre>\n<p>In case the question isn't clear, I'm asking why it could not deduce the template in the first place.</p>\n", "AcceptedAnswerId": "15042875", "Title": "Template type deduction for stream manipulators", "CreationDate": "2013-02-23T16:32:16.013", "Id": "15042791", "CommentCount": "2", "LastEditDate": "2013-02-23T16:57:27.347", "PostTypeId": "1", "LastEditorUserId": "812183", "LastActivityDate": "2013-02-23T17:17:15.497", "Score": "4", "OwnerUserId": "812183", "Tags": "<c++><templates><iostream><manipulators>", "AnswerCount": "2"}});