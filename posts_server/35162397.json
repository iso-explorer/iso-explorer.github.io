post_cb({"35162397": {"ViewCount": "281", "Body": "<p>I was playing around with templates today to see if I could get the compiler to deduce the type of an outer class from one of its inner classes.\nI didn't find my solution (which I suspect is impossible), but while trying to fix an error I ran into very strange behavior that I reduced to the following snippet. </p>\n<pre class=\"lang-c++ prettyprint-override\"><code>struct A\n{\n    struct B{};\n\n    template &lt;typename T&gt;\n    struct EverythingIsFine\n    {\n        using Outer = T;\n        using Inner = typename T::B::B::B::B::B::B;\n    };\n\n    using ItWillBeOkay = EverythingIsFine&lt;B&gt;; // Probably not ok\n    using InnerProblem = ItWillBeOkay::Inner; // Still not ok\n    using OuterProblem = decltype(B().ItWillBeOkay::Outer::B::B::B\n                                     ::B::B::B::~B()); // Not even CLOSE to ok\n};\n</code></pre>\n<p>It surprisingly compiles with no warnings and no errors with both Clang and GCC.<br/>\nThe versions of my compilers are <code>gcc version 5.3.1 20160121 (Debian 5.3.1-7)</code> and <code>Debian clang version 3.6.2-3 (tags/RELEASE_362/final) (based on LLVM 3.6.2)</code> and the flag used to compile are <code>-std=c++11 -Wall -Wextra</code>.</p>\n<p>I observed that it also compiles fine <a href=\"https://ideone.com/DC2kRw\" rel=\"nofollow\">on Ideone with the C++14 setting</a>.</p>\n<hr>\n<p>I then used this simple test to get the exact types of <code>InnerProblem</code> and <code>OuterProblem</code>:</p>\n<pre><code>template &lt;class T&gt; void Type();\nint main()\n{\n    Type&lt;A::InnerProblem&gt;();\n    Type&lt;A::OuterProblem&gt;();\n}\n</code></pre>\n<p>And both compilers report the same types when compiling the test:</p>\n<blockquote>\n<p id=\"so_35162397_35162397_0\">In function <code>main</code>:<br/>\n  main.cpp:20: undefined reference to <code>void Type&lt;A::B&gt;()</code><br/>\n  main.cpp:21: undefined reference to <code>void Type&lt;void&gt;()</code></p>\n</blockquote>\n<p>That is to say, the type of <code>InnerProblem</code> is <code>A::B</code> and the type of <code>OuterProblem</code> is <code>void</code>.</p>\n<hr>\n<p>Is this somehow permitted by the standard or is it a bug in both compilers?<br/>\nAnd since I seem to be as confused as my compiler, what is actually happening with this code?</p>\n<p><strong>EDIT</strong>: As a simplified followup, because I don't understand why two compilers can not give the same result, the following code compiles with Clang, but not with GCC.</p>\n<pre><code>struct A\n{\n    struct B{};\n\n    template &lt;typename T&gt;\n    struct EverythingIsFine\n    {\n        using Inner = typename T::B::B::B;\n    };\n\n    using Problem = EverythingIsFine&lt;B&gt;::Inner::B::B::B; // Not ok\n};\n</code></pre>\n<p>GCC now outputs the following error:</p>\n<blockquote>\n<p id=\"so_35162397_35162397_1\">main.cpp:11:26: error: 'A::B::B' names the constructor, not the type\n     using InnerProblem = EverythingIsFine::Inner::B::B::B; // Not ok</p>\n</blockquote>\n</hr></hr>", "Title": "Is this absurd code that compiles fine a bug in both Clang and GCC?", "CreationDate": "2016-02-02T19:39:14.307", "LastActivityDate": "2016-02-02T20:39:41.860", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-02-02T19:55:17.087", "Tags": "<c++><c++11><g++><clang><language-lawyer>", "Id": "35162397", "LastEditorUserId": "1401962", "Score": "8", "OwnerUserId": "1401962", "ClosedDate": "2016-02-05T06:22:35.133", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35162397_35162505_0": {"length": 9, "quality": 0.9, "section_id": 5846}}, "n3337": {"so_35162397_35162505_0": {"length": 9, "quality": 0.9, "section_id": 5616}}, "n4659": {"so_35162397_35162505_0": {"length": 9, "quality": 0.9, "section_id": 7325}}}, "35162505": {"Id": "35162505", "PostTypeId": "2", "Body": "<p>It's valid. </p>\n<blockquote>\n<p id=\"so_35162397_35162505_0\">The class-name is also inserted into the scope of the class itself;\n  this is known as the injected-class-name.\" (9/2).</p>\n</blockquote>\n<p>So <code>B::B</code> names the class <code>B</code>, as does <code>B::B::B</code>, and so on.</p>\n<p>EDIT:</p>\n<p>So <code>typename B::B</code> names the class <code>B</code>, as does <code>typename B::B::B</code>, and so on.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2016-02-02T20:39:41.860", "Score": "6", "CreationDate": "2016-02-02T19:45:41.777", "ParentId": "35162397", "CommentCount": "8", "OwnerUserId": "1593860", "LastEditDate": "2016-02-02T20:39:41.860"}});