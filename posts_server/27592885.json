post_cb({"bq_ids": {"n4140": {"so_27592885_27601859_2": {"length": 14, "quality": 0.875, "section_id": 170}, "so_27592885_27601859_7": {"length": 32, "quality": 0.8, "section_id": 72}, "so_27592885_27601859_5": {"length": 4, "quality": 1.0, "section_id": 72}, "so_27592885_27601859_1": {"length": 19, "quality": 1.0, "section_id": 169}, "so_27592885_27601859_3": {"length": 49, "quality": 0.98, "section_id": 174}}, "n3337": {"so_27592885_27601859_2": {"length": 14, "quality": 0.875, "section_id": 164}, "so_27592885_27601859_7": {"length": 32, "quality": 0.8, "section_id": 67}, "so_27592885_27601859_5": {"length": 4, "quality": 1.0, "section_id": 67}, "so_27592885_27601859_1": {"length": 19, "quality": 1.0, "section_id": 163}, "so_27592885_27601859_3": {"length": 49, "quality": 0.98, "section_id": 168}}, "n4659": {"so_27592885_27601859_2": {"length": 16, "quality": 1.0, "section_id": 175}, "so_27592885_27601859_5": {"length": 4, "quality": 1.0, "section_id": 200}, "so_27592885_27601859_1": {"length": 19, "quality": 1.0, "section_id": 174}, "so_27592885_27601859_3": {"length": 48, "quality": 0.96, "section_id": 179}}}, "27592885": {"ViewCount": "144", "Body": "<p>I'm implementing my own map and this is a piece of the code. A part of the code that is troubling me is these two declarations:</p>\n<pre><code>template&lt;typename KEY, typename VAL&gt;\nMap&lt;KEY,VAL&gt;::MapPair&lt;KEY,VAL&gt; Map&lt;KEY,VAL&gt;::make_map_pair(KEY k, VAL v){\n    return MapPair&lt;KEY,VAL&gt;(k,v);\n }\n\ntemplate&lt;typename KEY, typename VAL&gt;\ntemplate&lt;typename K, typename V&gt;\nMap&lt;KEY,VAL&gt;::MapPair&lt;K,V&gt;&amp; Map&lt;KEY,VAL&gt;::MapPair&lt;K,V&gt;::setKey(K keyp, V val){\n    key = keyp;\n    value = val;\n }\n</code></pre>\n<p>The class def is as follows:</p>\n<pre><code> template &lt;typename KEY, typename VAL&gt;\n class Map{\n private:\n    template&lt;typename K, typename V&gt;\n    class MapPair {\n    public:\n        K key;\n        V value;\n        MapPair(){};\n        MapPair(K key, V value);\n        MapPair&lt;K,V&gt;&amp; setKey(K key, V val);\n        V&amp; getValue();\n        K getKey();\n        bool operator==(MapPair&lt;K,V&gt; item);\n    };\n\n    List&lt;MapPair&lt;KEY,VAL&gt;&gt; pair_list_;\n    MapPair&lt;KEY,VAL&gt; make_empty_map_pair(KEY k);\n    MapPair&lt;KEY,VAL&gt; make_map_pair(KEY k, VAL v);\n public:\n    Map(){}\n    bool exists(KEY key);\n    VAL&amp; operator[](KEY key);\n    VAL pop_pair(KEY key);\n };\n</code></pre>\n<p>This code compiles without a peep from g++, but Visual Studio 2013 flips out errors:</p>\n<pre><code>error C2059: syntax error : ')'\nerror C2059: syntax error : ')'\n</code></pre>\n<p>each of the top function definitions generate an error.</p>\n<p>From g++ under debain 7.5</p>\n<pre><code>g++ -Wall -c -std=c++11  vm.cpp\ng++ vm.o -o vm\n</code></pre>\n<p>and it runs nicely with no run time issues and does what its supposed to do.</p>\n<p>The question is why does g++ run this fine, and vs2013 wont compile it?  What can I do to make this code compile properly on vs2013?  What kind of habits can I develop to ensure portability in the code that I write?</p>\n", "Title": "Template class with nested template class, g++ compiles fine, vs2013 wont compile", "CreationDate": "2014-12-21T19:23:57.670", "LastActivityDate": "2014-12-22T12:55:56.940", "CommentCount": "3", "PostTypeId": "1", "Id": "27592885", "Score": "2", "OwnerUserId": "2375262", "Tags": "<c++><templates><visual-studio-2013><g++><nested-class>", "AnswerCount": "2"}, "27601859": {"Id": "27601859", "PostTypeId": "2", "Body": "<p>My reading of the C++11 standard suggests that <code>typename</code> is required. VS2013 is doing the right thing.</p>\n<p>Without the <code>typename</code> keyword, a dependent name is assumed not to name a type.</p>\n<blockquote>\n<p id=\"so_27592885_27601859_0\">14.6 Name resolution [temp.res]</p>\n<p id=\"so_27592885_27601859_1\">2)\n  A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename.</p>\n<p id=\"so_27592885_27601859_2\">3)\n  When a qualified-id is intended to refer to a type that is not a member of the current instantiation\n  and its nested-name-specifier refers to a dependent type, it shall be prefixed by the keyword typename</p>\n<p id=\"so_27592885_27601859_3\">7)\n  Within the definition of a class template or <em>within the definition of a member of a class template following\n  the declarator-id</em>, the keyword typename is not required when referring to the name of a previously declared\n  member of the class template that declares a type. [Note: such names can be found using unqualified name\n  lookup, <em>class member lookup into the current instantiation</em>, or class member access\n  expression lookup when the type of the object expression is the current instantiation</p>\n<p id=\"so_27592885_27601859_4\">14.6.2.1 Dependent types [temp.dep.type]</p>\n<p id=\"so_27592885_27601859_5\">A name refers to the <em>current instantiation</em> if it is</p>\n<ul>\n<li>in the definition of a primary class template or a member of a primary class template, the name of the\n  class template followed by the template argument list of the primary template (as described below)\n  enclosed in &lt;&gt;</li>\n</ul>\n</blockquote>\n<p>When <code>Map&lt;KEY, VAL&gt;</code> is used in the definition of <code>Map</code>, it refers to the <em>current instantiation</em>. When parsing the definition of <code>make_map_pair</code> a type name qualified by <code>Map&lt;KEY, VAL&gt;::</code> can in general be found by <em>class member name lookup into the current instantiation</em>.</p>\n<p>However, when the C++ parser encounters <code>Map&lt;KEY, VAL&gt;</code> in the return-type of a member function definition - before the declarator-id - it has not yet encountered the name of the enclosing class. The parser cannot determine whether or not <code>Map</code> refers to the enclosing class at this point.</p>\n<p>For this reason - regardless of whether or not <code>Map&lt;KEY, VAL&gt;</code> names the current instantiation - the standard does not permit omission of <code>typename</code> within the definition of a member of a class template before the declarator-id.</p>\n<p>This <a href=\"http://melpon.org/wandbox/permlink/NrXfYV6FeTvCUGl9\" rel=\"nofollow noreferrer\">example</a> by Vaughn Cato demonstrates that the behaviour of Clang/GCC is inconsistent, and requires <code>typename</code> in a similar scenario:</p>\n<pre><code>template &lt;typename T&gt;\nstruct A {\n    typedef int X;\n    X f();\n};\n\ntemplate &lt;typename T&gt;\nA&lt;T&gt;::X A&lt;T&gt;::f() // error: missing 'typename'\n{\n}\n</code></pre>\n<p>If we conclude that the name <code>Map</code> is dependent and <code>typename</code> is required then the <code>template</code> keyword is also required:</p>\n<blockquote>\n<p id=\"so_27592885_27601859_6\">14.2 Names of template specializations [temp.names]</p>\n<p id=\"so_27592885_27601859_7\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a postfix-expression or after a\n  nested-name-specifier in a qualified-id, and the object or pointer expression of the postfix-expression or the\n  nested-name-specifier in the qualified-id depends on a template parameter (14.6.2) but does not refer to a\n  member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword\n  template. Otherwise the name is assumed to name a non-template.</p>\n</blockquote>\n<p>The corrected example would be:</p>\n<pre><code>template&lt;typename KEY, typename VAL&gt;\ntypename Map&lt;KEY,VAL&gt;::template MapPair&lt;KEY,VAL&gt;\n    Map&lt;KEY,VAL&gt;::make_map_pair(KEY k, VAL v) {\n    return MapPair&lt;KEY,VAL&gt;(k,v);\n}\n</code></pre>\n<p>There was a discussion of the same issue here: <a href=\"https://stackoverflow.com/questions/18344580/can-typename-be-omitted-in-the-type-specifier-of-an-out-of-line-member-definitio\">Can typename be omitted in the type-specifier of an out of line member definition?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-22T12:55:56.940", "Score": "2", "CreationDate": "2014-12-22T11:31:28.167", "ParentId": "27592885", "CommentCount": "0", "OwnerUserId": "1690864", "LastEditDate": "2017-05-23T12:12:49.007"}, "27592981": {"Id": "27592981", "PostTypeId": "2", "Body": "<p>So it turns out, VS2013 likes to have <code>typename</code> inserted before the return type of a nested class.  I knew I 'could' do that but id never know why I would until this instance.</p>\n<pre><code>template&lt;typename KEY, typename VAL&gt;\ntypename Map&lt;KEY,VAL&gt;::MapPair&lt;KEY,VAL&gt; Map&lt;KEY,VAL&gt;::make_map_pair(KEY k, VAL v){\n/*^^^^^ right here before the nested class object that it will return.*/\n    return MapPair&lt;KEY,VAL&gt;(k,v);\n}\n</code></pre>\n<p>Best idea is to use it so the code can ported with less changes, even though g++ wont require it.</p>\n", "LastActivityDate": "2014-12-21T19:33:52.207", "CommentCount": "1", "CreationDate": "2014-12-21T19:33:52.207", "ParentId": "27592885", "Score": "4", "OwnerUserId": "2375262"}});