post_cb({"42246727": {"ParentId": "42246545", "CommentCount": "0", "Body": "<p>It is not just gcc implementation, it is required by the standard ([time.syn]):</p>\n<pre><code>typedef duration&lt;signed integer type of at least 64 bits,        nano&gt; nanoseconds;\n</code></pre>\n<p>A duration represents a time difference between two time points A and B. If A &gt; B, the duration is positive, otherwise it's negative, so it makes perfect sense.</p>\n", "OwnerUserId": "1490355", "PostTypeId": "2", "Id": "42246727", "Score": "3", "CreationDate": "2017-02-15T10:28:08.993", "LastActivityDate": "2017-02-15T10:28:08.993"}, "42246545": {"CommentCount": "2", "ViewCount": "150", "CreationDate": "2017-02-15T10:20:09.747", "LastActivityDate": "2017-02-15T11:07:18.460", "Title": "why is representation type for chrono::nanoseconds a signed integer type?", "PostTypeId": "1", "Id": "42246545", "Score": "2", "Body": "<p>In gcc 4.84 in file /usr/include/c++/4.8 we have</p>\n<pre><code>namespace std  \n{\n   typedef duration&lt;int64_t, nano&gt;     nanoseconds;\n</code></pre>\n<p>Why is the representation type for nanosecond a signed integer type? Why isn't it unsigned? when can we have a duration object with a negative value ?</p>\n", "Tags": "<c++><std><chrono>", "OwnerUserId": "3034482", "AnswerCount": "3"}, "42246616": {"ParentId": "42246545", "CommentCount": "0", "Body": "<p>If two objects <code>a</code> and <code>b</code> are defined such that <code>a - b</code> is a duration, then it's desirable to have <code>a - b = -(b - a)</code>.</p>\n<p>To implement that anti-commutative property, the duration needs to be signed.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "42246616", "Score": "6", "CreationDate": "2017-02-15T10:23:26.863", "LastActivityDate": "2017-02-15T10:23:26.863"}, "42246733": {"ParentId": "42246545", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_42246545_42246733_0\">when can we have a duration object with a negative value ?</p>\n</blockquote>\n<p>Any time you want to represent a negative duration!</p>\n<p>e.g. \"Ten seconds earlier\" would be <code>std::chrono::seconds(-10)</code> and if you add that to some <code>time_point t</code> then you get a <code>time_point</code>  that is ten seconds before <code>t</code>.</p>\n<p>The standard says \"A <code>duration</code> type measures time between two points in time (<code>time_points</code>).\" It doesn't say that it can only measure time between non-decreasing time points. So that means it can be used to measure the time between <code>t1</code> and <code>t2</code> even if <code>t2 &lt; t1</code>. And to do that simply, you need a negative value.</p>\n<p>If durations couldn't be signed then, to represent an offset that means \"earlier\" not \"later\", you'd have to use something like <code>std::pair&lt;bool, duration&gt;</code> where the <code>bool</code> says whether it's a positive or negative offset, and then you'd have to do:</p>\n<pre><code>chrono::time_point adjust(chrono::time_point t, pair&lt;bool, duration&gt; offset)\n{\n  if (offset.first)  // positive\n    return t + offset.second;\n  else // negative\n    return t - offset.second;\n}\n</code></pre>\n<p>This is dumb. The language and the hardware already support this far more expressively and efficiently, by using signed integers.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2017-02-15T11:07:18.460", "Id": "42246733", "Score": "7", "CreationDate": "2017-02-15T10:28:28.870", "LastActivityDate": "2017-02-15T11:07:18.460"}, "bq_ids": {"n4140": {"so_42246545_42246733_0": {"section_id": 5790, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_42246545_42246733_0": {"section_id": 5563, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_42246545_42246733_0": {"section_id": 7247, "quality": 0.7142857142857143, "length": 5}}}});