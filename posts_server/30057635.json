post_cb({"bq_ids": {"n4140": {"so_30057635_30057826_0": {"length": 25, "quality": 0.7352941176470589, "section_id": 5768}}, "n3337": {"so_30057635_30057826_0": {"length": 25, "quality": 0.7352941176470589, "section_id": 5541}}, "n4659": {"so_30057635_30057826_0": {"length": 24, "quality": 0.7058823529411765, "section_id": 7225}}}, "30058129": {"Id": "30058129", "PostTypeId": "2", "Body": "<p>Template functions may be overloaded by return type alone, unlike regular functions.</p>\n<pre><code>template &lt;typename T&gt; int f() { return 1; }\ntemplate &lt;typename T&gt; long f() { return 2; }\n\nint main() {\n  int (&amp;f1) () = f&lt;void&gt;;\n  long (&amp;f2) () = f&lt;void&gt;;\n  return f1() == f2();\n}\n</code></pre>\n<p>Here, assuming a non-optimising compiler, the generated assembly will contain two functions <code>f&lt;void&gt;()</code>, but they can't share the same mangled name, or there would be no way for the generated assembly for <code>main</code> to specify which of the instantiations it refers to.</p>\n<p>Typically, if you have an overloaded template function, only one of the definitions will be used for a particular template argument, so this is uncommon, but in the comments on Columbo's answer, dyp came up with the basic idea for how this might actually be useful. In <a href=\"https://stackoverflow.com/questions/14863422/can-addressof-be-implemented-as-constexpr-function\">Can addressof() be implemented as constexpr function?</a>, I came up with</p>\n<pre><code>template &lt;bool&gt;\nstruct addressof_impl;\n\ntemplate &lt;&gt;\nstruct addressof_impl&lt;false&gt; {\n  template &lt;typename T&gt;\n  static constexpr T *impl(T &amp;t) {\n    return &amp;t;\n  }\n};\n\ntemplate &lt;&gt;\nstruct addressof_impl&lt;true&gt; {\n  template &lt;typename T&gt;\n  static /* not constexpr */ T *impl(T &amp;t) {\n    return reinterpret_cast&lt;T *&gt;(&amp;const_cast&lt;char &amp;&gt;(reinterpret_cast&lt;const volatile char &amp;&gt;(t)));\n  }\n};\n\ntemplate &lt;typename T&gt;\nconstexpr T *addressof(T &amp;t)\n{\n  return addressof_impl&lt;has_overloaded_addressof_operator&lt;T&gt;::value&gt;::template impl&lt;T&gt;(t);\n}\n</code></pre>\n<p>but this is actually an ODR violation if the same instantiation <code>addressof&lt;X&gt;</code> is used in multiple translation units, some where <code>X</code> is incomplete, and some where <code>X</code> is complete and has an overloaded <code>&amp;</code> operator. This can be re-worked by performing the logic inside <code>addressof</code> directly, using regular overloaded functions.</p>\n<pre><code>template &lt;typename T&gt;\nstd::enable_if_t&lt;has_overloaded_addressof_operator&lt;T&gt;::value, T *&gt;\naddressof(T &amp;t)\n{\n  return reinterpret_cast&lt;T *&gt;(&amp;const_cast&lt;char &amp;&gt;(reinterpret_cast&lt;const volatile char &amp;&gt;(t)));\n}\n\ntemplate &lt;typename T&gt;\nconstexpr\nstd::enable_if_t&lt;!has_overloaded_addressof_operator&lt;T&gt;::value, T *&gt;\naddressof(T &amp;t)\n{\n  return &amp;t;\n}\n</code></pre>\n<p>(<code>has_overloaded_addressof_operator</code> would need to be inlined too, for the same reason.)</p>\n<p>This way, the problem is avoided: when <code>X</code> is incomplete, then <code>addressof&lt;X&gt;</code> refers to a different function than when <code>X</code> is complete.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-05T16:52:42.313", "Score": "8", "CreationDate": "2015-05-05T16:11:19.670", "ParentId": "30057635", "CommentCount": "14", "OwnerUserId": "743382", "LastEditDate": "2017-05-23T11:46:01.853"}, "30057826": {"Id": "30057826", "PostTypeId": "2", "Body": "<p>Maybe because, as opposed to normal functions, a function templates signature contains the return type? \u00a71.3:</p>\n<blockquote>\n<p id=\"so_30057635_30057826_0\"><strong>1.3.17 signature</strong> <code>&lt;</code>function<code>&gt;</code> name, parameter type list (8.3.5), and enclosing namespace (if any)<br> [ <em>Note</em>: <strong>Signatures are used as a\n  basis for name mangling and linking.</strong> \u2014 <em>end note</em> ]<br>\n<hr>\n<strong>1.3.18 signature</strong> <code>&lt;</code>function template<code>&gt;</code> name, parameter type list (8.3.5), enclosing namespace (if any), <strong>return\n  type</strong>, and template parameter list</hr></br></br></p>\n</blockquote>\n<p>Consider that we can have two entirely distinct function template overloads that only differ in their return type, if written thusly:</p>\n<pre><code>template &lt;int&gt;\nchar foo();\n\ntemplate &lt;int&gt;\nint foo();\n</code></pre>\n<p>If name mangling wouldn't consider the return type, linking those templates would prove difficult, since <code>foo&lt;0&gt;</code> does not uniquely name one specialization. Still, one specialization can be addressed using overload resolution (without arguments):</p>\n<pre><code>int (*funptr)() = foo&lt;0&gt;;   \n</code></pre>\n<p>On the other hand, including the return type is not necessary for ordinary functions, as these cannot be overloaded on their return type - i.e. their signature does not include the return type.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-05-05T16:27:29.010", "Score": "15", "CreationDate": "2015-05-05T15:56:17.420", "ParentId": "30057635", "CommentCount": "12", "OwnerUserId": "3647361", "LastEditDate": "2015-05-05T16:27:29.010"}, "30057635": {"ViewCount": "734", "Body": "<p>The Itanium ABI <a href=\"https://mentorembedded.github.io/cxx-abi/abi.html#mangle.function-type\">specifies</a> that, with a couple uninteresting exceptions, the return type is included in the mangled names of template instantions but not non-templates.</p>\n<p>Why is this? In what case could you have two function template instantiations where the linker needs to distinguish them because it is not indicative of a one-definition-rule violation or similar?</p>\n<p>As an example of what I mean: </p>\n<pre><code>class ReturnType {};\nclass ParamType {};\n\ntemplate &lt;typename T&gt;\nReturnType foo(T p)  {\n    return ReturnType();\n};\ntemplate ReturnType foo&lt;ParamType&gt;(ParamType);\n\nReturnType bar(ParamType p) {\n    return ReturnType();\n}\n</code></pre>\n<p>Then the resulting object file has manglings:</p>\n<pre><code>ReturnType foo&lt;ParamType&gt;(ParamType)\n   =&gt; _Z3fooI9ParamTypeE10ReturnTypeT_\n                        ^^^^^^^^^^^^\n\nReturnType bar(ParamType)\n   =&gt; _Z3bar9ParamType\n</code></pre>\n<p>Why does <code>foo</code> need <code>ReturnType</code> mangled but <code>bar</code> doesn't?</p>\n<p>(I am presuming there is a reason and it's not just an arbitrary choice.)</p>\n", "AcceptedAnswerId": "30057826", "Title": "Why is the return type of C++ function template instantiations included in the mangled function name?", "CreationDate": "2015-05-05T15:48:27.267", "Id": "30057635", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-05-05T16:45:14.280", "LastEditorUserId": "1023390", "LastActivityDate": "2015-05-05T16:52:42.313", "Score": "13", "OwnerUserId": "362981", "Tags": "<c++><name-mangling>", "AnswerCount": "2"}});