post_cb({"4274963": {"Id": "4274963", "PostTypeId": "2", "Body": "<p>I think this one is picky. I suppose you can't do it, read <a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow\">this</a>.</p>\n", "LastActivityDate": "2010-11-25T08:22:52.593", "Score": "0", "CreationDate": "2010-11-25T08:22:52.593", "ParentId": "4274828", "CommentCount": "0", "OwnerUserId": "347137"}, "4274965": {"Id": "4274965", "PostTypeId": "2", "Body": "<p>icecrime posted a temporary answer and it gets compiled due to some bug probably by visual C++ 2008:</p>\n<pre><code>template &lt;typename T&gt;\nclass Test{\n public:\n  template &lt;typename Z&gt;\n  void doSomething();\n  //rest of things\n private:\n  T obj;\n  //some things\n};\ntemplate &lt;&gt;\ntemplate &lt;typename T&gt;\nvoid Test&lt;T&gt;::doSomething&lt;int&gt;(){\n //do something\n}\n</code></pre>\n<p>Check his current answer though.\nThe funny thing at least with VC++ 2008 is, no problem compiling when specializing with inline definitions, but for specializations with not-inline definitions once there's more than one version it doesn't get compiled successfully.</p>\n", "LastEditorUserId": "388056", "LastActivityDate": "2010-11-25T13:37:29.763", "Score": "-2", "CreationDate": "2010-11-25T08:23:04.880", "ParentId": "4274828", "CommentCount": "4", "LastEditDate": "2010-11-25T13:37:29.763", "OwnerUserId": "388056"}, "4274828": {"ViewCount": "605", "Body": "<p>Is following design possible?:</p>\n<pre><code>template &lt;typename T&gt;\nclass Test{\n public:\n  template &lt;typename Z&gt;\n  void doSomething();\n  //rest of things\n private:\n  T obj;\n  //some things\n};\n</code></pre>\n<p>Now if it was possible I'd do some explicit specializations for doSomething so that at the end I'd have some versions like below:</p>\n<pre><code>void doSomething&lt;int&gt;(){\n //do something\n}\nvoid doSomething&lt;double&gt;(){\n //do something\n}\n...etc\n</code></pre>\n<p>which seems impossible I can't find any syntax to do the job then I thought maybe the design should be as it follows so that all template arguments should be passed to template class itself:</p>\n<pre><code>template &lt;typename T,typename Z&gt;\nclass Test{\n public:\n  void doSomething();\n  //rest of things\n private:\n  T obj;\n  //some things\n};\n</code></pre>\n<p>Then I tried partial specialization which didn't even compile:</p>\n<pre><code>template &lt;typename T&gt;\nvoid Test&lt;T,int&gt;::doSomething(){\n //do something\n}\ntemplate &lt;typename T&gt;\nvoid Test&lt;T,double&gt;::doSomething(){\n //do something\n}\n...etc\n</code></pre>\n<p>I got the following errors for explicit specialization:<br>\nerror#1:template argument list following class template name must list parameters in the order used in template parameter list.<br>\nerror#2:'Container1' :too few template arguments.</br></br></p>\n", "AcceptedAnswerId": "4274874", "Title": "How should I do this explicit specialization?", "CreationDate": "2010-11-25T08:01:29.167", "Id": "4274828", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2010-11-25T14:33:12.127", "Score": "6", "OwnerUserId": "388056", "Tags": "<c++><templates><explicit-specialization>", "AnswerCount": "6"}, "4278149": {"Id": "4278149", "PostTypeId": "2", "Body": "<p>Not sure if this is a bug in g++ but this compiles and produce what I expect.</p>\n<pre><code>#include&lt;typeinfo&gt;\n#include&lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nclass Test\n{\npublic:\n    template&lt;typename Z&gt;\n    void doSomething();\n\nprivate:\n    T obj;\n};\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename Z&gt;\nvoid Test&lt;T&gt;::doSomething()\n{\n    Z val;\n    std::cout &lt;&lt; __func__ &lt;&lt; \": type \" &lt;&lt; typeid(val).name() &lt;&lt; std::endl;\n}\n\nint main(int argc, char *argv[])\n{\n    Test&lt;double&gt; a;\n    a.doSomething&lt;int&gt;();\n    a.doSomething&lt;double&gt;();\n}\n</code></pre>\n", "LastActivityDate": "2010-11-25T14:33:12.127", "Score": "0", "CreationDate": "2010-11-25T14:33:12.127", "ParentId": "4274828", "CommentCount": "2", "OwnerUserId": "142791"}, "bq_ids": {"n4140": {"so_4274828_4274874_0": {"length": 35, "quality": 1.0, "section_id": 278}}, "n3337": {"so_4274828_4274874_0": {"length": 35, "quality": 1.0, "section_id": 269}}, "n4659": {"so_4274828_4274874_0": {"length": 35, "quality": 1.0, "section_id": 285}}}, "4274929": {"Id": "4274929", "PostTypeId": "2", "Body": "<p>You cannot explicitly specialize a member template unless its enclosing class templates are also explicitly specialized.</p>\n<p>So only something like this will work:</p>\n<pre><code>template&lt;&gt; template&lt;&gt;\nvoid Test&lt;int&gt;::doSomething&lt;int&gt;()\n{\n}\n</code></pre>\n", "LastActivityDate": "2010-11-25T08:17:18.460", "Score": "2", "CreationDate": "2010-11-25T08:17:18.460", "ParentId": "4274828", "CommentCount": "3", "OwnerUserId": "155670"}, "4274874": {"Id": "4274874", "PostTypeId": "2", "Body": "<p>In order to explicitly specialize <code>doSomething</code> you have to also explicitly specialize <code>Test</code>.</p>\n<p>From 14.7.3/18 :</p>\n<blockquote>\n<p id=\"so_4274828_4274874_0\">In an explicit specialization\n  declaration for a member of a class\n  template or a member template that\n  appears in namespace scope, the member\n  template and some of its enclosing\n  class templates may remain\n  unspecialized, <strong>except that the\n  declaration shall not explicitly\n  specialize a class member template if\n  its enclosing class templates are not\n  explicitly specialized as well</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "451980", "LastActivityDate": "2010-11-25T08:24:00.003", "Score": "6", "CreationDate": "2010-11-25T08:08:37.177", "ParentId": "4274828", "CommentCount": "2", "LastEditDate": "2010-11-25T08:24:00.003", "OwnerUserId": "451980"}, "4275012": {"Id": "4275012", "PostTypeId": "2", "Body": "<p>you can always make the function inline</p>\n<pre><code>template &lt;class T&gt;\nclass Test\n{\npublic:\n template &lt;class Z&gt;\n void doSomething() { cout &lt;&lt; \"default\" &lt;&lt; endl; }\n\n template&lt;&gt;\n void doSomething&lt;int&gt;() { cout &lt;&lt; \"int\" &lt;&lt; endl;}\n template&lt;&gt;\n void doSomething&lt;double&gt;() { cout &lt;&lt; \"double\" &lt;&lt; endl; }\nprivate:\n T obj;\n};\n</code></pre>\n", "LastActivityDate": "2010-11-25T08:28:35.480", "Score": "1", "CreationDate": "2010-11-25T08:28:35.480", "ParentId": "4274828", "CommentCount": "3", "OwnerUserId": "305160"}});