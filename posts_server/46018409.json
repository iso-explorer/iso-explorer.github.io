post_cb({"bq_ids": {"n4140": {"so_46018409_46018409_1": {"length": 26, "quality": 0.7647058823529411, "section_id": 6142}, "so_46018409_46018409_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 7177}}, "n3337": {"so_46018409_46018409_1": {"length": 26, "quality": 0.7647058823529411, "section_id": 5906}, "so_46018409_46018409_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 6921}}, "n4659": {"so_46018409_46018409_1": {"length": 34, "quality": 1.0, "section_id": 7638}, "so_46018409_46018409_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 8685}}}, "46018409": {"ViewCount": "82", "Body": "<p>Let's say I want to implement std::vector without invoking any undefined behavior (UB). Is the code below invokes UB:</p>\n<pre><code>struct X{int i;};\nint main(){\n  auto p = static_cast&lt;X*&gt;(::operator new(sizeof(X)*2));\n  new(p) X{};\n  new(p+1) X{};// p+1 UB?\n}\n</code></pre>\n<p>Folowing a selection of quote from the standard that may help:</p>\n<p><strong>[basic.stc.dynamic.allocation]</strong></p>\n<blockquote>\n<p id=\"so_46018409_46018409_0\">The pointer returned (by an allocation function) shall be suitably aligned so that it can be converted to a pointer to any\n  suitable complete object type (21.6.2.1) and then used to access the object or array in the storage allocated\n  (until the storage is explicitly deallocated by a call to a corresponding deallocation function).</p>\n</blockquote>\n<p><strong>[expr.add]</strong></p>\n<blockquote>\n<p id=\"so_46018409_46018409_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. If the expression P points to element x[i] of an array object x with n elements,\n  the expressions P + J and J + P (where J has the value j) point to the (<strong>possibly-hypothetical</strong>) element\n  x[i + j] if 0&lt;=i + j&lt;=n; otherwise, the behavior is undefined. Likewise, the expression P - J points to the\n  (<strong>possibly-hypothetical</strong>) element x[i \u2212 j] if 0&lt;=i \u2212 j &lt;=n; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>My interpretation is that allocation provides an possibly-hypothetical array of X (in C++ arrays are objects) so pointer arithmetic on allocated storage as in the exemple may not invoke undefined behavior. Or my interpretation of <strong>hypothetical</strong> is wrong? How could I do if the previous code snipest is UB?</p>\n", "Title": "Is pointer arithmetic on allocated storage UB?", "CreationDate": "2017-09-02T21:34:09.300", "LastActivityDate": "2017-09-02T22:10:30.157", "CommentCount": "11", "LastEditDate": "2017-09-02T22:10:30.157", "PostTypeId": "1", "LastEditorUserId": "5632316", "Id": "46018409", "Score": "0", "OwnerUserId": "5632316", "Tags": "<c++><memory-management><language-lawyer>", "AnswerCount": "0"}});