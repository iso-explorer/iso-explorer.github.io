post_cb({"bq_ids": {"n4140": {"so_46018409_46018409_0": {"section_id": 7177, "quality": 0.8275862068965517, "length": 24}, "so_46018409_46018409_1": {"section_id": 6142, "quality": 0.7647058823529411, "length": 26}}, "n3337": {"so_46018409_46018409_0": {"section_id": 6921, "quality": 0.8275862068965517, "length": 24}, "so_46018409_46018409_1": {"section_id": 5906, "quality": 0.7647058823529411, "length": 26}}, "n4659": {"so_46018409_46018409_0": {"section_id": 8685, "quality": 0.8620689655172413, "length": 25}, "so_46018409_46018409_1": {"section_id": 7638, "quality": 1.0, "length": 34}}}, "46018409": {"CommentCount": "11", "ViewCount": "82", "PostTypeId": "1", "LastEditorUserId": "5632316", "CreationDate": "2017-09-02T21:34:09.300", "LastActivityDate": "2017-09-02T22:10:30.157", "Title": "Is pointer arithmetic on allocated storage UB?", "LastEditDate": "2017-09-02T22:10:30.157", "Id": "46018409", "Score": "0", "Body": "<p>Let's say I want to implement std::vector without invoking any undefined behavior (UB). Is the code below invokes UB:</p>\n<pre><code>struct X{int i;};\nint main(){\n  auto p = static_cast&lt;X*&gt;(::operator new(sizeof(X)*2));\n  new(p) X{};\n  new(p+1) X{};// p+1 UB?\n}\n</code></pre>\n<p>Folowing a selection of quote from the standard that may help:</p>\n<p><strong>[basic.stc.dynamic.allocation]</strong></p>\n<blockquote>\n<p id=\"so_46018409_46018409_0\">The pointer returned (by an allocation function) shall be suitably aligned so that it can be converted to a pointer to any\n  suitable complete object type (21.6.2.1) and then used to access the object or array in the storage allocated\n  (until the storage is explicitly deallocated by a call to a corresponding deallocation function).</p>\n</blockquote>\n<p><strong>[expr.add]</strong></p>\n<blockquote>\n<p id=\"so_46018409_46018409_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. If the expression P points to element x[i] of an array object x with n elements,\n  the expressions P + J and J + P (where J has the value j) point to the (<strong>possibly-hypothetical</strong>) element\n  x[i + j] if 0&lt;=i + j&lt;=n; otherwise, the behavior is undefined. Likewise, the expression P - J points to the\n  (<strong>possibly-hypothetical</strong>) element x[i \u2212 j] if 0&lt;=i \u2212 j &lt;=n; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>My interpretation is that allocation provides an possibly-hypothetical array of X (in C++ arrays are objects) so pointer arithmetic on allocated storage as in the exemple may not invoke undefined behavior. Or my interpretation of <strong>hypothetical</strong> is wrong? How could I do if the previous code snipest is UB?</p>\n", "Tags": "<c++><memory-management><language-lawyer>", "OwnerUserId": "5632316", "AnswerCount": "0"}});