post_cb({"41913578": {"Tags": "<c++><templates><vector><member><incomplete-type>", "ViewCount": "1561", "LastEditDate": "2017-10-21T11:27:45.073", "CreationDate": "2017-01-28T18:55:23.340", "LastEditorUserId": "63550", "Title": "How can I declare a member vector of the same class?", "CommentCount": "2", "AcceptedAnswerId": "41913654", "Score": "39", "OwnerUserId": "5662819", "Id": "41913578", "LastActivityDate": "2017-10-21T11:30:13.910", "Body": "<p>Why on earth does the following piece of code work?</p>\n<pre><code>struct A {\n    std::vector&lt;A&gt; subAs;\n};\n</code></pre>\n<p>A is an incomplete type, right? If there was a vector of A*s I would understand. But here I don't understand how it works. It seems to be a recursive definition.</p>\n", "PostTypeId": "1", "FavoriteCount": "1", "AnswerCount": "1"}, "41913654": {"ParentId": "41913578", "Score": "31", "CreationDate": "2017-01-28T19:01:49.763", "LastActivityDate": "2017-10-21T11:30:13.910", "LastEditDate": "2017-10-21T11:30:13.910", "OwnerUserId": "1621391", "LastEditorUserId": "63550", "Body": "<p>This <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html\" rel=\"nofollow noreferrer\">paper</a> was adopted <a href=\"https://stackoverflow.com/questions/38060436/what-are-the-new-features-in-c17\">into C++17</a> which allows incomplete types to be used in certain STL containers. Prior to that, it was Undefined Behavior. To quote from the paper:</p>\n<blockquote>\n<p id=\"so_41913578_41913654_0\">Based on the discussion on the Issaquah meeting, we achieved the\n  consensus to proceed* with the approach \u2013 \u201cContainers of Incomplete\n  Types\u201d, but limit the scope to <code>std::vector</code>, <code>std::list</code>, and\n  <code>std::forward_list</code>, as the first step.</p>\n</blockquote>\n<p>And as for the changes in the standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_41913578_41913654_1\">An incomplete type <code>T</code> may be used when instantiating <code>vector</code> if the\n  <em>allocator</em> satisfies the <em>allocator-completeness-requirements</em>\n  (17.6.3.5.1). <em>T</em> shall be complete before any member of the resulting\n  specialization of vector is referenced.</p>\n</blockquote>\n<p>So, there you have it, if you leave the default <code>std::allocator&lt;T&gt;</code> in place when instantiating the <code>std::vector&lt;T, Allocator&gt;</code>, then it will always work with an incomplete type <code>T</code> according to the paper; otherwise, it depends on your <em>Allocator</em> being instantiable with an incomplete type <code>T</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_41913578_41913654_2\">A is an incomplete type, right? If there was a vector of A*s I would understand. But here I don't understand how it works. It seems to be a recursive definition.</p>\n</blockquote>\n<p>There is no recursion there. In an extremely simplified form, it's similar to:</p>\n<pre><code>class A{\n    A* subAs;\n};\n</code></pre>\n<p>Technically, apart from <code>size</code>, <code>capacity</code> and possibly <code>allocator</code>, <code>std::vector</code> only needs to hold a pointer to a dynamic array of <code>A</code> it manages via its allocator. (And the size of a pointer is known at compile time.)</p>\n<p>So, an implementation may look like this:</p>\n<pre><code>namespace std{\n\n    template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;\n    class vector{\n\n        ....\n\n        std::size_t m_capacity;\n        std::size_t m_size;\n        Allocator m_allocator;\n        T* m_data;\n    };\n\n}\n</code></pre>\n</hr>", "Id": "41913654", "PostTypeId": "2", "CommentCount": "1"}, "bq_ids": {"n4659": {"so_41913578_41913654_1": {"length": 15, "section_id": 1018, "quality": 0.8823529411764706}}}});