post_cb({"34036482": {"CommentCount": "2", "ViewCount": "54", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2015-12-02T06:43:15.517", "LastActivityDate": "2015-12-06T14:13:58.190", "Title": "How compiler works in case of error: reference to \u2018mytype\u2019 is ambiguous", "LastEditDate": "2015-12-06T13:08:20.030", "Id": "34036482", "Score": "0", "Body": "<p>I have created one scenario where I want help. Below code is the sample test application for same.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A\n{\npublic:\n    typedef int mytype;\n    mytype GetInt() { return 1;}\n};\n\nclass B\n{\npublic:\n    typedef char mytype;\n};\n\nclass C : public A, public B\n{\n};\n\nclass D : public C\n{\npublic:\n    void scenario()\n    {\n        mytype m = GetInt();\n    }\n};\n\nint main()\n{\n    D d1;\n    d1.scenario();\n\n    return 0;\n}\n</code></pre>\n<p>Compiling code using : g++ tmp.cpp</p>\n<pre><code>Error:\ntmp.cpp:27:9: error: reference to \u2018mytype\u2019 is ambiguous\n         mytype m = GetInt();\n         ^\ntmp.cpp:15:18: note: candidates are: typedef char B::mytype\n     typedef char mytype;\n                  ^\ntmp.cpp:8:17: note:                 typedef int A::mytype\n     typedef int mytype;\n                 ^\ntmp.cpp:27:16: error: expected \u2018;\u2019 before \u2018m\u2019\n         mytype m = GetInt();\n</code></pre>\n<p>As we can see from the code that GetInt() is defined only in the class A, so I though that mytype will be taken from class A only. But it is not the case as per the error log.</p>\n<p>We can solve this by adding the scope of class A like </p>\n<blockquote>\n<p id=\"so_34036482_34036482_0\">A::mytype m = GetInt();</p>\n</blockquote>\n<p>I want to know about: \nHow compiler is behaving in this case?\nIs there ant compiler flag that will solve this error in case of gcc?</p>\n", "Tags": "<c++><typedef><multiple-inheritance><ambiguity><name-lookup>", "OwnerUserId": "5190087", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34036482_34118342_0": {"section_id": 5412, "quality": 1.0, "length": 12}}, "n3337": {"so_34036482_34118342_0": {"section_id": 5207, "quality": 1.0, "length": 12}}, "n4659": {"so_34036482_34118342_0": {"section_id": 6834, "quality": 1.0, "length": 12}}}, "34118342": {"ParentId": "34036482", "CommentCount": "0", "Body": "<p><em>[dcl.typedef]/p6</em></p>\n<blockquote>\n<p id=\"so_34036482_34118342_0\">In a given scope, a typedef specifier shall not be used to redefine the name of any type declared in that\n  scope to refer to a different type</p>\n</blockquote>\n<p><code>GetInt</code> might be defined in <code>A</code> but the <code>typedef</code>s in the base classes will bring the conflict into play when resolving the name in <code>scenario()</code> (cfr. <em>[class.member.lookup]</em>) since this is an unqualified lookup.</p>\n<p>This behavior is defined and expected. I'm not aware of any flag you might use to achieve your goal. Either go for a qualified name lookup as you've already discovered or use <code>auto</code> type deduction as Joachim pointed out.</p>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "34118342", "Score": "0", "CreationDate": "2015-12-06T14:13:58.190", "LastActivityDate": "2015-12-06T14:13:58.190"}});