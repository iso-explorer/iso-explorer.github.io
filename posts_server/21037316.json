post_cb({"21038239": {"ParentId": "21037316", "CommentCount": "0", "Body": "<p>C++11 5.2.9 [expr.static.cast]/10:</p>\n<blockquote>\n<p id=\"so_21037316_21038239_0\">A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is\n  unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting\n  value is unspecified (and might not be in that range).</p>\n</blockquote>\n<p>The \"range of the enumeration values\" is defined in 7.2/7:</p>\n<blockquote>\n<p id=\"so_21037316_21038239_1\">For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the\n  underlying type. Otherwise, for an enumeration where emin is the smallest enumerator and emax is the\n  largest, the values of the enumeration are the values in the range bmin to bmax, defined as follows: Let K\n  be 1 for a two\u2019s complement representation and 0 for a one\u2019s complement or sign-magnitude representation.\n  bmax is the smallest value greater than or equal to max(|emin| \u2212 K, |emax|) and equal to 2M \u2212 1, where\n  M is a non-negative integer. bmin is zero if emin is non-negative and \u2212(bmax + K) otherwise. The size of\n  the smallest bit-field large enough to hold all the values of the enumeration type is max(M, 1) if bmin is\n  zero and M + 1 otherwise. It is possible to define an enumeration that has values not defined by any of its\n  enumerators. If the enumerator-list is empty, the values of the enumeration are as if the enumeration had a\n  single enumerator with value 0.</p>\n</blockquote>\n<p>For <code>Colour</code>, the range of the enumeration values (assuming two's-complement) is [0, 3]. <code>RED</code> - 1 is either <code>-1</code> or <code>UINT_MAX</code>, both of which are outside the range [0, 3], so the result of the <code>static_cast</code> is unspecified.</p>\n<p>Since the result of converting out-of-range values is unspecified, you would do better to perform your comparisons in the domain of the underlying type, which is exactly the effect of your fix.</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "21038239", "Score": "2", "CreationDate": "2014-01-10T07:14:55.550", "LastActivityDate": "2014-01-10T07:14:55.550"}, "bq_ids": {"n4140": {"so_21037316_21038239_0": {"section_id": 6036, "quality": 0.9583333333333334, "length": 23}, "so_21037316_21038239_1": {"section_id": 5467, "quality": 0.8333333333333334, "length": 70}}, "n3337": {"so_21037316_21038239_0": {"section_id": 5804, "quality": 0.9583333333333334, "length": 23}, "so_21037316_21038239_1": {"section_id": 5253, "quality": 0.8333333333333334, "length": 70}}, "n4659": {"so_21037316_21038239_0": {"section_id": 7535, "quality": 0.8333333333333334, "length": 20}, "so_21037316_21038239_1": {"section_id": 6901, "quality": 0.8333333333333334, "length": 70}}}, "21037316": {"CommentCount": "0", "ViewCount": "686", "CreationDate": "2014-01-10T06:10:43.510", "LastActivityDate": "2014-01-10T07:14:55.550", "Title": "Is this a bug with std::underlying_type", "AcceptedAnswerId": "21038239", "PostTypeId": "1", "Id": "21037316", "Score": "2", "Body": "<p>I think I may have encountered a bug with the c++11 template std::underlying_type.</p>\n<p>I use a traits class to define the ranges of enumerations we have in our system.\nI am then able to provide a generic is_valid function.</p>\n<p>I recently extended the function when -Wextra was enabled because I was getting\na lot of warnings about an always true comparison.</p>\n<p>When an enum is of an unsigned type, and its first value is 0, the warning was generated.</p>\n<p>Solved that easily. But the next day some unit tests in modules using the function started\nto fail.</p>\n<p>When you don't specify the underlying type of the enum, it still chooses the correct implementation, but somehow returns the wrong result.</p>\n<p>Here is the minimal example (<a href=\"http://ideone.com/PwFz15\" rel=\"nofollow\">http://ideone.com/PwFz15</a>):</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum Colour\n{\n    RED = 0,\n    GREEN,\n    BLUE\n};\n\nenum NoProblems : int\n{\n    A,\n    B,\n    C\n};\n\nenum AlsoOk : unsigned\n{\n    D,\n    E,\n    F\n};\n\n\ntemplate &lt;typename Enum&gt; struct enum_traits;\n\ntemplate &lt;&gt; struct enum_traits&lt;Colour&gt;\n{\n    typedef Colour type;\n    static constexpr type FIRST = RED;\n    static constexpr type LAST = BLUE;\n};\n\ntemplate &lt;&gt; struct enum_traits&lt;NoProblems&gt;\n{\n    typedef NoProblems type;\n    static constexpr type FIRST = A;\n    static constexpr type LAST = C;\n};\n\ntemplate &lt;&gt; struct enum_traits&lt;AlsoOk&gt;\n{\n    typedef AlsoOk type;\n    static constexpr type FIRST = D;\n    static constexpr type LAST = F;\n};\n\n\n#if 0\n// This implementation gives you warnings about an always true comparison\n// ONLY IF you define the underlying type of your enum, such as Colour.\ntemplate &lt;typename Enum&gt;\ninline constexpr bool is_valid(Enum e)\n{\n    return e &gt;= enum_traits&lt;Enum&gt;::FIRST &amp;&amp; e &lt;= enum_traits&lt;Enum&gt;::LAST;\n}\n#endif\n\n// So you define the is_valid function like so, to prevent the warnings:\n\ntemplate &lt;typename Enum, typename enable_if&lt;is_unsigned&lt;typename underlying_type&lt;Enum&gt;::type&gt;::value &amp;&amp; enum_traits&lt;Enum&gt;::FIRST == 0, int&gt;::type = 0&gt;\ninline constexpr bool is_valid(Enum e)\n{\n    return e &lt;= enum_traits&lt;Enum&gt;::LAST;\n}\n\ntemplate &lt;typename Enum, typename enable_if&lt;is_signed&lt;typename underlying_type&lt;Enum&gt;::type&gt;::value || enum_traits&lt;Enum&gt;::FIRST != 0, int&gt;::type = 0&gt;\ninline constexpr bool is_valid(Enum e)\n{\n    return e &gt;= enum_traits&lt;Enum&gt;::FIRST &amp;&amp; e &lt;= enum_traits&lt;Enum&gt;::LAST;\n}\n\n\n\nint main()\n{\n    Colour c = static_cast&lt;Colour&gt;(RED - 1);\n    cout &lt;&lt; is_valid(c) &lt;&lt; endl;\n\n    NoProblems np = static_cast&lt;NoProblems&gt;(A - 1);\n    cout &lt;&lt; is_valid(np) &lt;&lt; endl;\n\n    AlsoOk ao = static_cast&lt;AlsoOk&gt;(D - 1);\n    cout &lt;&lt; is_valid(ao) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Which gives the output:</p>\n<pre><code>1\n0\n0\n</code></pre>\n<p>Clearly the output for the first call to is_valid, should be 0 / false. Somehow the enum is both signed and unsigned at the same time?</p>\n<p>Have I missed some critical piece of documentation in the standard library regarding the templates I've used?</p>\n<p>It is fixable by performing the comparison like so:</p>\n<pre><code>return static_cast&lt;typename std::underlying_type&lt;Enum&gt;::type&gt;(e) &lt;= enum_traits&lt;Enum&gt;::LAST;\n</code></pre>\n<p>But it doesn't seem like that should be necessary.</p>\n<p>I've tried this on gcc 4.8.1, gcc 4.7.3 and clang 3.2.1, all on x86-64</p>\n", "Tags": "<c++11><g++>", "OwnerUserId": "2723873", "AnswerCount": "1"}});