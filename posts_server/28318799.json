post_cb({"bq_ids": {"n4140": {"so_28318799_28323698_1": {"length": 10, "quality": 0.6666666666666666, "section_id": 3328}, "so_28318799_28323698_0": {"length": 7, "quality": 1.0, "section_id": 6955}, "so_28318799_28323698_11": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}, "so_28318799_28323698_10": {"length": 18, "quality": 0.8181818181818182, "section_id": 3328}}, "n3337": {"so_28318799_28323698_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 3198}, "so_28318799_28323698_0": {"length": 7, "quality": 1.0, "section_id": 6702}, "so_28318799_28323698_11": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}}, "n4659": {"so_28318799_28323698_1": {"length": 10, "quality": 0.6666666666666666, "section_id": 4094}, "so_28318799_28323698_0": {"length": 7, "quality": 1.0, "section_id": 8452}, "so_28318799_28323698_11": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}, "so_28318799_28323698_10": {"length": 18, "quality": 0.8181818181818182, "section_id": 4094}}}, "28323698": {"Id": "28323698", "PostTypeId": "2", "Body": "<p>The problem is that you are referencing an object that no longer exists and therefore you are invoking <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a>. <code>initializer_list</code> seems underspecified in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">C++11 draft standard</a>, there are no normative sections that actually specify this behavior. Although there are plenty of notes that indicate this will not work and in general although notes are not normative if they don't conflict with the normative text they are strongly indicative.</p>\n<p>If we go to section <code>18.9</code> <em>Initializer lists</em> it has a note which says:</p>\n<blockquote>\n<p id=\"so_28318799_28323698_0\">Copying an initializer list does not copy the underlying elements.</p>\n</blockquote>\n<p>and in section <code>8.5.4</code> we have the following examples:</p>\n<pre><code>typedef std::complex&lt;double&gt; cmplx;\nstd::vector&lt;cmplx&gt; v1 = { 1, 2, 3 };\n\nvoid f() {\n    std::vector&lt;cmplx&gt; v2{ 1, 2, 3 };\n    std::initializer_list&lt;int&gt; i3 = { 1, 2, 3 };\n}\n</code></pre>\n<p>with the following notes:</p>\n<blockquote>\n<p id=\"so_28318799_28323698_1\">For v1 and v2, the initializer_list object and array created for { 1, 2, 3 } have full-expression\n  lifetime. For i3, the initializer_list object and array have automatic lifetime.</p>\n</blockquote>\n<p>These notes are consistent with the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf\" rel=\"nofollow\">initializer_list proposal: N2215</a> which gives the following example:</p>\n<pre><code>std::vector&lt;double&gt; v = {1, 2, 3.14};\n</code></pre>\n<p>and says:</p>\n<blockquote>\n<p id=\"so_28318799_28323698_2\">Now add <code>vector(initializer_list&lt;E&gt;)</code> to <code>vector&lt;E&gt;</code> as shown above. Now,\n  the example works. The initializer list {1, 2, 3.14} is interpreted as\n  a temporary constructed like this:</p>\n<pre><code>const double temp[] = {double(1), double(2), 3.14 } ;\ninitializer_list&lt;double&gt; tmp(temp,\nsizeof(temp)/sizeof(double));\nvector&lt;double&gt; v(tmp);\n</code></pre>\n<p id=\"so_28318799_28323698_3\">[...]</p>\n<p id=\"so_28318799_28323698_4\">Note that an initializer_list is a small object (probably two words),\n  so passing it by value makes sense. Passing by value also simplifies\n  inlining of begin() and end() and constant expression evaluation of\n  size().</p>\n<p id=\"so_28318799_28323698_5\">An initializer_list s will be created by the compiler, but can be\n  copied by users. Think of it as a pair of pointers.</p>\n</blockquote>\n<p>The <code>initializer_list</code> in this case just holds pointers to an automatic variable which will not exist after exiting the scope.</p>\n<p><b>Update</b></p>\n<p>I just realized the proposal actually points out this <em>misuse scenario</em>:</p>\n<blockquote>\n<p id=\"so_28318799_28323698_6\">One implication is that an initializer_list is \u201c pointer like\u201d in that\n  it behaves like a pointer in respect to the underlying array. For\n  example: </p>\n<pre><code>int * f(int a)\n{ \n   int* p = &amp;a;\n   return p; //bug waiting to happen\n}\n\ninitializer_list&lt;int&gt; g(int a, int b, int c)\n{\n   initializer_list&lt;int&gt; v = { a, b, c };\n   return v; // bug waiting to happen\n} \n</code></pre>\n<p id=\"so_28318799_28323698_7\"><strong>It actually takes a minor amount of ingenuity to misuse an\n  initializer_list this way. In particular, variables of type\n  initializer_list are going to be rare</strong>.</p>\n</blockquote>\n<p>I find the last statement(<em>emphasis mine</em>) particularly ironic.</p>\n<p><b>Update 2</b></p>\n<p>So <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1290\" rel=\"nofollow\">defect report 1290</a> fixes the normative wording and so it now covers this behavior, although the copy case could be more explicit. It says:</p>\n<blockquote>\n<p id=\"so_28318799_28323698_8\">A question has arisen over expected behavior when an initializer_list\n  is a non-static data member of a class. Initialization of an\n  initializer_list is defined in terms of construction from an\n  implicitly allocated array whose lifetime \"is the same as that of the\n  initializer_list object\". That would mean that the array needs to live\n  as long as the initializer_list does, which would on the face of it\n  appear to require the array to be stored in something like a\n  std::unique_ptr within the same class (if the member is\n  initialized in this manner).</p>\n<p id=\"so_28318799_28323698_9\">It would be surprising if that was the intent, but it would make\n  initializer_list usable in this context.</p>\n</blockquote>\n<p>The resolution fixes the wording and we can find the new wording in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">N3485 version of the draft standard</a>. So section <code>8.5.4</code> <em>[dcl.init.list]</em> now says:</p>\n<blockquote>\n<p id=\"so_28318799_28323698_10\">The array has the same lifetime as any other temporary object (12.2),\n  except that initializing an initializer_- list object from the array\n  extends the lifetime of the array exactly like binding a reference to\n  a temporary.</p>\n</blockquote>\n<p>and <code>12.2</code> <em>[class.temporary]</em> says:</p>\n<blockquote>\n<p id=\"so_28318799_28323698_11\">The lifetime of a temporary bound to the returned value in a function\n  return statement (6.6.3) is not extended; the temporary is destroyed\n  at the end of the full-expression in the return statement.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-02-10T15:31:56.070", "Score": "15", "CreationDate": "2015-02-04T14:20:45.110", "ParentId": "28318799", "CommentCount": "8", "OwnerUserId": "1708801", "LastEditDate": "2015-02-10T15:31:56.070"}, "28318799": {"ViewCount": "2434", "Body": "<p>Consider this <strong>C++11</strong> code snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;stdexcept&gt;\n#include &lt;initializer_list&gt;\n\n\nint main(int argc, char ** argv)\n{\n    enum Switch {\n        Switch_1,\n        Switch_2,\n        Switch_3,\n        Switch_XXXX,\n    };\n\n    int foo_1 = 1;\n    int foo_2 = 2;\n    int foo_3 = 3;\n    int foo_4 = 4;\n    int foo_5 = 5;\n    int foo_6 = 6;\n    int foo_7 = 7;\n\n    auto get_foos = [=] (Switch ss) -&gt; std::initializer_list&lt;int&gt; {\n        switch (ss) {\n            case Switch_1:\n                return {foo_1, foo_2, foo_3};\n            case Switch_2:\n                return {foo_4, foo_5};\n            case Switch_3:\n                return {foo_6, foo_7};\n            default:\n                throw std::logic_error(\"invalid switch\");\n        }\n    };\n\n    std::set&lt;int&gt; foos = get_foos(Switch_1);\n    for (auto &amp;&amp; foo : foos) {\n        std::cout &lt;&lt; foo &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Whatever compiler I try, all seem to handle it incorrectly. This makes me think that I am doing something wrong rather than it's a common bug across multiple compilers.</p>\n<p><strong>clang 3.5</strong> output:</p>\n<pre><code>-1078533848 -1078533752 134518134\n</code></pre>\n<p><strong>gcc 4.8.2</strong> output:</p>\n<pre><code>-1078845996 -1078845984 3\n</code></pre>\n<p><strong>gcc 4.8.3</strong> output (compiled on <a href=\"http://www.tutorialspoint.com\" rel=\"noreferrer\">http://www.tutorialspoint.com</a>):</p>\n<pre><code>1 2 267998238\n</code></pre>\n<p><strong>gcc (unknown version)</strong> output (compiled on <a href=\"http://coliru.stacked-crooked.com\" rel=\"noreferrer\">http://coliru.stacked-crooked.com</a>)</p>\n<pre><code>-1785083736 0 6297428 \n</code></pre>\n<p>The problem seems to be caused by using <code>std::initializer_list&lt;int&gt;</code> as a return value of lambda. When changing lambda definition to <code>[=] (Switch ss) -&gt; std::set&lt;int&gt; {...}</code> returned values are correct.</p>\n<p>Please, help me solve this mystery.</p>\n", "AcceptedAnswerId": "28319001", "Title": "Strange values in a lambda returning initializer_list", "CreationDate": "2015-02-04T10:17:53.973", "Id": "28318799", "CommentCount": "1", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2015-02-04T20:10:33.037", "LastEditorUserId": "1381108", "LastActivityDate": "2015-02-10T15:31:56.070", "Score": "32", "OwnerUserId": "966376", "Tags": "<c++><c++11><lambda><initializer-list>", "AnswerCount": "3"}, "28319001": {"Id": "28319001", "PostTypeId": "2", "Body": "<p>From: <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\">http://en.cppreference.com/w/cpp/utility/initializer_list</a></p>\n<blockquote>\n<p id=\"so_28318799_28319001_0\">The underlying array is not guaranteed to exist after the lifetime of the original initializer list object has ended. The storage for std::initializer_list is unspecified (i.e. it could be automatic, temporary, or static read-only memory, depending on the situation).</p>\n</blockquote>\n<p>I don't think the initializer list is copy-constructable. <code>std::set</code> and other containers are. Basically it looks like your code behaves similar to \"returning a reference to a temporary\".</p>\n<p>C++14 has something slightly different to say about the underlying storage - extending <em>its</em> lifetime - but that does not fix anything having to do with the lifetime of the <code>initializer_list</code> object, let alone copies thereof. Hence, the issue remains, even in C++14.</p>\n<blockquote>\n<p id=\"so_28318799_28319001_1\">The underlying array is a temporary array, in which each element is copy-initialized (except that narrowing conversions are invalid) from the corresponding element of the original initializer list. The lifetime of the underlying array is the same as any other temporary object, <strong>except that initializing an initializer_list object from the array extends the lifetime of the array exactly like binding a reference to a temporary</strong> (with the same exceptions, such as for initializing a non-static class member). The underlying array may be allocated in read-only memory.</p>\n</blockquote>\n", "LastEditorUserId": "1128737", "LastActivityDate": "2015-02-04T16:49:56.617", "Score": "32", "CreationDate": "2015-02-04T10:27:01.033", "ParentId": "28318799", "CommentCount": "11", "OwnerUserId": "26083", "LastEditDate": "2015-02-04T16:49:56.617"}, "28330389": {"Id": "28330389", "PostTypeId": "2", "Body": "<p>So, <code>initializer_list</code>s do not extend the lifetime of their referenced array when they are themselves copied or moved to the result of the copy/move.  This makes returning them problematic.  (they do extend the lifetime of the referenced array to their own lifetime, but this extension is not transitive over elision or copies of the list).</p>\n<p>To fix this problem, store the data, and manage its lifetime manually:</p>\n<pre><code>template&lt;size_t size, class T&gt;\nstd::array&lt;T, size&gt; partial_array( T const* begin, T const* end ) {\n  std::array&lt;T, size&gt; retval;\n  size_t delta = (std::min)( size, end-begin );\n  end = begin+delta;\n  std::copy( begin, end, retval.begin() );\n  return retval;\n}\ntemplate&lt;class T, size_t max_size&gt;\nstruct capped_array {\n  std::array&lt;T, max_size&gt; storage;\n  size_t used = 0;\n  template&lt;size_t osize, class=std::enable_if_t&lt; (size&lt;=max_size) &gt;&gt;\n  capped_array( std::array&lt;T, osize&gt; const&amp; rhs ):\n    capped_array( rhs.data(), rhs.data()+osize )\n  {}\n  template&lt;size_t osize, class=std::enable_if_t&lt; (size&lt;=max_size) &gt;&gt;\n  capped_array( capped_array&lt;T, osize&gt; const&amp; rhs ):\n    capped_array( rhs.data(), rhs.data()+rhs.used )\n  {}\n  capped_array(capped_array const&amp; o)=default;\n  capped_array(capped_array &amp; o)=default;\n  capped_array(capped_array &amp;&amp; o)=default;\n  capped_array(capped_array const&amp;&amp; o)=default;\n  capped_array&amp; operator=(capped_array const&amp; o)=default;\n  capped_array&amp; operator=(capped_array &amp; o)=default;\n  capped_array&amp; operator=(capped_array &amp;&amp; o)=default;\n  capped_array&amp; operator=(capped_array const&amp;&amp; o)=default;\n\n  // finish-start MUST be less than max_size, or we will truncate\n  capped_array( T const* start, T const* finish ):\n    storage( partial_array(start, finish) ),\n    used((std::min)(finish-start, size))\n  {}\n  T* begin() { return storage.data(); }\n  T* end() { return storage.data()+used; }\n  T const* begin() const { return storage.data(); }\n  T const* end() const { return storage.data()+used; }\n  size_t size() const { return used; }\n  bool empty() const { return !used; }\n  T&amp; front() { return *begin(); }\n  T const&amp; front() const { return *begin(); }\n  T&amp; back() { return *std::prev(end()); }\n  T const&amp; back() const { return *std::prev(end()); }\n\n  capped_array( std::initializer_list&lt;T&gt; il ):\n    capped_array(il.begin(), il.end() )\n  {}\n};\n</code></pre>\n<p>the goal here is simple.  Create a stack based data type that stores a bunch of <code>T</code>s, up to a cap, and can handle having fewer.</p>\n<p>Now we replace your <code>std::initializer_list</code> with:</p>\n<pre><code>auto get_foos = [=] (Switch ss) -&gt; capped_array&lt;int,3&gt; {\n    switch (ss) {\n        case Switch_1:\n            return {foo_1, foo_2, foo_3};\n        case Switch_2:\n            return {foo_4, foo_5};\n        case Switch_3:\n            return {foo_6, foo_7};\n        default:\n            throw std::logic_error(\"invalid switch\");\n    }\n};\n</code></pre>\n<p>and your code works.  The free store is not used (no heap allocation).</p>\n<p>A more advanced version would use an array of uninitialized data and manually construct each <code>T</code>.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-02-04T21:03:04.913", "Score": "2", "CreationDate": "2015-02-04T20:02:38.167", "ParentId": "28318799", "CommentCount": "7", "OwnerUserId": "1774667", "LastEditDate": "2015-02-04T21:03:04.913"}});