post_cb({"11751270": {"ParentId": "11747652", "CommentCount": "0", "Body": "<p>You are misinterpeting \"until function exit\".  If you really want to use a const reference to extend the life of an object beyond <code>foo</code>, use</p>\n<pre><code>A foo() {\n    return A(32);\n}\nint main() {\n    const A&amp; a = foo();\n}\n</code></pre>\n<p>You must return from <code>foo</code> <em>by value</em>, and then use a const reference to reference the return value, if you wish to extend things in the way you expect.</p>\n<p>As @AndreyT has said, the object is destroyed in the function that has the <code>const &amp;</code>.  You want your object to survive beyond <code>foo</code>, and hence you should <em>not</em> have <code>const &amp;</code> \n(or <code>&amp;</code>) anywhere in <code>foo</code> or in the return type of <code>foo</code>.  The first mention of <code>const &amp;</code> should be in <code>main</code>, as that is the function that should keep the object alive.</p>\n<p>You might think this return-by-value code is slow as there appear to be copies of A made in the return, but this is incorrect.  In most cases, the compiler can construct A only once, in its final location (i.e. on the stack of the calling function), and then set up the relevant reference.</p>\n", "OwnerUserId": "146041", "PostTypeId": "2", "Id": "11751270", "Score": "2", "CreationDate": "2012-08-01T01:13:45.557", "LastActivityDate": "2012-08-01T01:13:45.557"}, "11747652": {"CommentCount": "5", "ViewCount": "2539", "PostTypeId": "1", "LastEditorUserId": "1462604", "CreationDate": "2012-07-31T19:33:38.087", "LastActivityDate": "2012-08-01T01:13:45.557", "Title": "What exactly happens when returning const reference to a local object?", "AcceptedAnswerId": "11747735", "LastEditDate": "2012-07-31T19:52:20.073", "Id": "11747652", "Score": "4", "Body": "<pre><code>struct A {\n    A(int) : i(new int(783)) {\n        std::cout &lt;&lt; \"a ctor\" &lt;&lt; std::endl;\n    }\n\n    A(const A&amp; other) : i(new int(*(other.i))) {\n        std::cout &lt;&lt; \"a copy ctor\" &lt;&lt; std::endl;\n    }\n\n    ~A() {\n        std::cout &lt;&lt; \"a dtor\" &lt;&lt; std::endl;\n        delete i;\n    }\n\n    void get() {\n        std::cout &lt;&lt; *i &lt;&lt; std::endl;\n    }\n\nprivate:\n    int* i;\n};\n\nconst A&amp; foo() {\n    return A(32);\n}\n\nconst A&amp; foo_2() {\n    return 6;\n}\n\nint main()\n{\n    A a = foo();\n    a.get();\n}\n</code></pre>\n<p>I know, returning references to local values is bad. But, on the other hand, const reference should extend a temporary object lifetime.</p>\n<p>This code produce an UB output. So no life extention.  </p>\n<p>Why? I mean can someone explain whats happening step by step?</p>\n<p>Where is fault in my reasoning chain?</p>\n<p>foo():</p>\n<ol>\n<li><p>A(32) - ctor</p></li>\n<li><p>return A(32) - a const reference to local object is created and is returned</p></li>\n<li><p>A a = foo(); - a is initialized by foo() returned value, returned value goes out of scope(out of expression) and is destroyed, but a is already initialized;</p></li>\n</ol>\n<p>(But actually destructor is called before copy constructor)</p>\n<p>foo_2():</p>\n<ol>\n<li><p>return 6 - temp object of type A is created implicitly,a const reference to this object is created(extending its life) and is returned</p></li>\n<li><p>A a = foo(); - a is initialized by foo() returned value, returned value goes out of scope(out of expression) and is destroyed, but a is already initialized;</p></li>\n</ol>\n<p>(But actually destructor is called before copy constructor)</p>\n", "Tags": "<c++><const-reference>", "OwnerUserId": "1063413", "AnswerCount": "2"}, "11747735": {"ParentId": "11747652", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Rules of temporary lifetime extension for each specific context are explicitly spelled out in the language specification. And it says that </p>\n<blockquote>\n<p id=\"so_11747652_11747735_0\"><strong>12.2 Temporary objects</strong></p>\n<p id=\"so_11747652_11747735_1\">5 The second context is when a reference is bound to a temporary. [...] A temporary bound to the returned value in a function return statement\n  (6.6.3) persists until the function exits. [...]</p>\n</blockquote>\n<p>Your temporary object is destroyed at the moment of function exit. That happens before the initialization of the recipient object begins. </p>\n<p>You seem to assume that your temporary should somehow live longer than that. Apparently you are trying to apply the rule that says that the temporary should survive until the end of the full expression. But that rule does not apply to temporaries created inside functions. Such temporaries' lifetimes are governed by their own, dedicated rules.</p>\n<p>Both your <code>foo</code> and your <code>foo_2</code> produce undefined behavior, if someone attempts to use the returned reference.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-07-31T19:43:47.243", "Id": "11747735", "Score": "11", "CreationDate": "2012-07-31T19:38:35.173", "LastActivityDate": "2012-07-31T19:43:47.243"}, "bq_ids": {"n4140": {"so_11747652_11747735_1": {"section_id": 382, "quality": 0.7894736842105263, "length": 15}}, "n3337": {"so_11747652_11747735_1": {"section_id": 373, "quality": 0.7894736842105263, "length": 15}}, "n4659": {"so_11747652_11747735_1": {"section_id": 397, "quality": 0.7368421052631579, "length": 14}}}});