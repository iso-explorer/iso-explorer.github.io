post_cb({"46580007": {"ParentId": "46579016", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>First an informal explanation</h2>\n<p>Let's take it in logical steps.</p>\n<p>A non-const method is allowed and assumed to change the object. As such it can be called on non-const objects only.</p>\n<p>A const method is not allowed to change the object. As such it can be called on const objects, but also on non-const objects.</p>\n<p>When both overloads of a functions are defined (const and non-const) the method chosen is the one whose constness fits the object constness.</p>\n<h2>The standard</h2>\n<p>In reality overload resolution has no special rule for const and non-const methods. Instead, the standard specifies an implicit object parameter. After you take into consideration this implicit object parameter, you can apply the usual overload resolution rules:</p>\n<blockquote>\n<p id=\"so_46579016_46580007_0\">\u00a713.3.1 Candidate functions and argument lists [over.match.funcs]</p>\n<ol start=\"2\">\n<li><p id=\"so_46579016_46580007_1\">[...] a member function is considered to have an extra parameter, called the implicit object parameter , which represents the object for\n  which the member function has been called. For the purposes of\n  overload resolution, both static and non-static member functions have\n  an implicit object parameter, but constructors do not.</p></li>\n<li><p id=\"so_46579016_46580007_2\">Similarly, when appropriate, the context can construct an argument list that contains an implied object argument to denote the object to\n  be operated on. Since arguments and parameters are associated by\n  position within their respective lists, the convention is that the\n  implicit object parameter, if present, is always the first parameter\n  and the implied object argument, if present, is always the first\n  argument.</p></li>\n<li><p id=\"so_46579016_46580007_3\">For non-static member functions, the type of the implicit object parameter is</p>\n<ul>\n<li>(4.1) \u201clvalue reference to cv X\u201d for functions declared without a ref-qualifier or with the &amp; ref-qualifier</li>\n<li>(4.2) \u201crvalue reference to cv X\u201d for functions declared with the &amp;&amp; ref-qualifier</li>\n</ul></li>\n</ol>\n<p id=\"so_46579016_46580007_4\">where X is the class of which the function is a member and cv is the\n  cv-qualification on the member function declaration. [ Example: for a\n  const member function of class X, the extra parameter is assumed to\n  have type \u201creference to const X\u201d. \u2014end example ] For conversion\n  functions, the function is considered to be a member of the class of\n  the implied object argument for the purpose of defining the type of\n  the implicit object parameter. For non-conversion functions introduced\n  by a using-declaration into a derived class, the function is\n  considered to be a member of the derived class for the purpose of\n  defining the type of the implicit object parameter. [...]</p>\n<ol start=\"5\">\n<li><strong>During overload resolution, the implied object argument is indistinguishable from other arguments</strong></li>\n</ol>\n</blockquote>\n", "OwnerUserId": "2805305", "LastEditorUserId": "2805305", "LastEditDate": "2017-10-05T12:21:18.873", "Id": "46580007", "Score": "4", "CreationDate": "2017-10-05T07:19:47.627", "LastActivityDate": "2017-10-05T12:21:18.873"}, "46579091": {"ParentId": "46579016", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Assume that every member function of class <code>A</code> has an implicit parameter that is <code>const A&amp;</code> for a const member function and <code>A&amp;</code> for a non-const member function. Your member functions in the context of overload resolution process will look like:</p>\n<pre><code>int f(const St&amp;); \nint f(St&amp;);\n</code></pre>\n<p>If it is possible for overload resolution to choose the appropriate member than there is no ambiguity. This specific case is regulated in</p>\n<blockquote>\n<p id=\"so_46579016_46579091_0\">13.3.3.2 [over.ics.rank]\n  Standard conversion sequence <code>S1</code> is a better conversion sequence than\n  standard conversion sequence <code>S2</code> if<br>\n  ...<br>\n  13.3.3.2/(3.2.6) <code>S1</code> and <code>S2</code> are reference bindings, and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by <code>S2</code> refers is more cv-qualified than the type to which the reference initialized by <code>S1</code> refers.</br></br></p>\n</blockquote>\n<p>Thus, overload resolution process chooses the non-const member (as less cv-qualified). </p>\n", "OwnerUserId": "4759200", "LastEditorUserId": "4759200", "LastEditDate": "2017-10-05T09:18:21.933", "Id": "46579091", "Score": "2", "CreationDate": "2017-10-05T06:23:35.403", "LastActivityDate": "2017-10-05T09:18:21.933"}, "46580532": {"ParentId": "46579016", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is <a href=\"https://isocpp.org/wiki/faq/const-correctness#const-overloading\" rel=\"nofollow noreferrer\">const overloading</a>, which is <a href=\"https://stackoverflow.com/questions/251159/what-is-the-use-of-const-overloading-in-c\">a thing</a> in C++.</p>\n<p>In this case, the compiler determines the struct does NOT have an overloaded function return type, (which is <a href=\"https://stackoverflow.com/questions/9568852/overloading-by-return-type\">disallowed due to ambiguity </a>of course) but rather an overloaded function with different \u201cconstness;\u201d a term in one of the other answers which makes sense here.</p>\n<p>As for getting no compiler errors:</p>\n<ol>\n<li>const overloading is part of the C++ specification, so no errors</li>\n<li>At compile-time, the compiler \u201csees\u201d that the struct is returning to a non-const environment, so uses the non-const function, causing a normal operation to happen </li>\n</ol>\n<p>Hope that helps!</p>\n", "OwnerUserId": "4513509", "LastEditorUserId": "4513509", "LastEditDate": "2017-10-05T08:01:47.597", "Id": "46580532", "Score": "4", "CreationDate": "2017-10-05T07:51:23.647", "LastActivityDate": "2017-10-05T08:01:47.597"}, "bq_ids": {"n4140": {"so_46579016_46580007_4": {"section_id": 568, "quality": 0.9090909090909091, "length": 50}, "so_46579016_46580007_1": {"section_id": 566, "quality": 0.9333333333333333, "length": 28}, "so_46579016_46580007_2": {"section_id": 567, "quality": 0.9743589743589743, "length": 38}, "so_46579016_46579091_0": {"section_id": 639, "quality": 0.8787878787878788, "length": 29}, "so_46579016_46580007_3": {"section_id": 568, "quality": 0.875, "length": 7}}, "n3337": {"so_46579016_46580007_4": {"section_id": 559, "quality": 0.9090909090909091, "length": 50}, "so_46579016_46580007_1": {"section_id": 557, "quality": 0.9333333333333333, "length": 28}, "so_46579016_46580007_2": {"section_id": 558, "quality": 0.9743589743589743, "length": 38}, "so_46579016_46579091_0": {"section_id": 629, "quality": 0.8787878787878788, "length": 29}, "so_46579016_46580007_3": {"section_id": 559, "quality": 0.875, "length": 7}}, "n4659": {"so_46579016_46580007_4": {"section_id": 591, "quality": 0.9090909090909091, "length": 50}, "so_46579016_46580007_1": {"section_id": 589, "quality": 0.9333333333333333, "length": 28}, "so_46579016_46580007_3": {"section_id": 591, "quality": 0.875, "length": 7}, "so_46579016_46579091_0": {"section_id": 667, "quality": 0.8787878787878788, "length": 29}, "so_46579016_46580007_2": {"section_id": 590, "quality": 0.9743589743589743, "length": 38}}}, "46579016": {"CommentCount": "2", "AcceptedAnswerId": "46580532", "PostTypeId": "1", "LastEditorUserId": "6935629", "CreationDate": "2017-10-05T06:17:39.977", "LastActivityDate": "2017-10-05T12:21:18.873", "LastEditDate": "2017-10-05T11:13:35.073", "ViewCount": "293", "FavoriteCount": "2", "Title": "Doesn't compiler give an ambiguous error for \"const\" and \"not-const\" functions", "Id": "46579016", "Score": "6", "Body": "<p>I have overloaded <code>const</code> and <code>non-const</code> functions in c++ structure. Then, I have run the program and I wondered, it's working fine without ambiguous error. </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct St \n{\n  int f() const \n  { \n      return 1; \n  }\n\n  int f()\n  { \n      return 2;\n  }\n} s;\n\nint main() \n{\n    int ret = s.f();  \n    std::cout&lt;&lt;ret&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n<p>So, I just want to know, Why doesn't the compiler give an ambiguous error  for \"const\" and \"not-const\" functions?</p>\n", "Tags": "<c++><function><c++11><c++14><const>", "OwnerUserId": "6935629", "AnswerCount": "3"}});