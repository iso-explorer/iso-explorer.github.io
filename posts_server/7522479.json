post_cb({"7522521": {"ParentId": "7522479", "CommentCount": "1", "Body": "<p>I'm pretty sure the whole point of calling <code>close()</code> is to flush the buffer.  <a href=\"http://www.cplusplus.com/reference/iostream/fstream/close/\" rel=\"nofollow\">This site</a> agrees.  Although depending on your file system and mount settings, just because you've 'written to the disk' doesn't mean that your file system drivers and disk hardware have actually taken the data and made magnet-y bits on the physical piece of metal.  It could probably be in a disk buffer still.</p>\n", "OwnerUserId": "524389", "PostTypeId": "2", "Id": "7522521", "Score": "-1", "CreationDate": "2011-09-22T23:07:19.650", "LastActivityDate": "2011-09-22T23:07:19.650"}, "7522479": {"CommentCount": "1", "AcceptedAnswerId": "7522650", "PostTypeId": "1", "LastEditorUserId": "307930", "CreationDate": "2011-09-22T23:02:42.143", "LastActivityDate": "2011-12-13T06:58:55.750", "LastEditDate": "2011-12-13T06:14:34.567", "ViewCount": "2839", "FavoriteCount": "0", "Title": "How do I ensure data is written to disk before closing fstream?", "Id": "7522479", "Score": "2", "Body": "<p>The following looks sensible, but I've heard that the data could theoretically still be in a buffer rather than on the disk, even after the close() call.</p>\n<pre><code>#include &lt;fstream&gt;\n\nint main()\n{\n    ofstream fsi(\"test.txt\");\n\n    fsi &lt;&lt; \"Hello World\";\n\n    fsi.flush();\n\n    fsi.close();\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><fstream>", "OwnerUserId": "307930", "AnswerCount": "7"}, "7522517": {"ParentId": "7522479", "CommentCount": "3", "Body": "<p>The <code>close()</code> member function closes the underlying OS file descriptor. At that point, the file should be on disk.</p>\n", "OwnerUserId": "9990", "PostTypeId": "2", "Id": "7522517", "Score": "-1", "CreationDate": "2011-09-22T23:06:33.127", "LastActivityDate": "2011-09-22T23:06:33.127"}, "7522651": {"ParentId": "7522479", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Which operating system are you using?</p>\n<p>You need to use Direct (non-buffered) I/O to guarantee the data is written directly to the physical device without hitting the filesystem write-cache. Be aware it still has to pass thru the disk cache before getting physically written.</p>\n<p>On Windows, you can use the <a href=\"http://support.microsoft.com/kb/99794\" rel=\"nofollow\">FILE_FLAG_WRITE_THROUGH</a> flag when opening the file.</p>\n", "OwnerUserId": "298054", "LastEditorUserId": "298054", "LastEditDate": "2011-11-20T07:59:29.207", "Id": "7522651", "Score": "0", "CreationDate": "2011-09-22T23:23:45.543", "LastActivityDate": "2011-11-20T07:59:29.207"}, "7522650": {"ParentId": "7522479", "CommentCount": "0", "Body": "<p>You cannot to this with standard tools and have to rely on OS facilities.\nFor POSIX <code>fsync</code> should be what you need. As there is no way to a get C file descriptor from a standard stream you would have to resort to C streams in your whole application or just open the file for flushing do disk. Alternatively there is <code>sync</code> but this flushes <strong>all</strong> buffers, which your users and other applications are going to hate.</p>\n", "OwnerUserId": "105672", "PostTypeId": "2", "Id": "7522650", "Score": "3", "CreationDate": "2011-09-22T23:23:16.200", "LastActivityDate": "2011-09-22T23:23:16.200"}, "7522543": {"ParentId": "7522479", "CommentCount": "2", "Body": "<p>How abt <a href=\"http://www.cplusplus.com/reference/iostream/manipulators/flush/\" rel=\"nofollow\">flushing</a> before closing?</p>\n", "OwnerUserId": "496289", "PostTypeId": "2", "Id": "7522543", "Score": "-2", "CreationDate": "2011-09-22T23:09:49.787", "LastActivityDate": "2011-09-22T23:09:49.787"}, "7522527": {"ParentId": "7522479", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You could guarantee the data from the buffer is written to disk by flushing the stream. That could be done by calling its <code>flush()</code> member function, the <code>flush</code> manipulator, the <code>endl</code> manipulator.</p>\n<p>However, there is no need to do so in your case since <code>close</code> guarantees that any pending output sequence is written to the physical file.</p>\n<blockquote>\n<p id=\"so_7522479_7522527_0\">\u00a7 27.9.1.4 / 6:</p>\n<p id=\"so_7522479_7522527_1\">basic_filebuf&lt; charT, traits &gt;* close();</p>\n<p id=\"so_7522479_7522527_2\">Effects: If is_open() == false, returns a null pointer. If a put area exists, calls overflow(traits::eof()) to \ufb02ush characters. (...)</p>\n</blockquote>\n", "OwnerUserId": "927034", "LastEditorUserId": "927034", "LastEditDate": "2011-09-22T23:14:03.287", "Id": "7522527", "Score": "1", "CreationDate": "2011-09-22T23:08:25.703", "LastActivityDate": "2011-09-22T23:14:03.287"}, "bq_ids": {"n4140": {"so_7522479_7522537_0": {"section_id": 2430, "quality": 0.922077922077922, "length": 71}, "so_7522479_7522527_2": {"section_id": 2430, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_7522479_7522537_0": {"section_id": 2415, "quality": 0.922077922077922, "length": 71}, "so_7522479_7522527_2": {"section_id": 2415, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_7522479_7522537_0": {"section_id": 2706, "quality": 0.8961038961038961, "length": 69}, "so_7522479_7522527_2": {"section_id": 2706, "quality": 0.7692307692307693, "length": 10}}}, "7522537": {"ParentId": "7522479", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_7522479_7522537_0\">\u00a7 27.9.1.4<br>\n  basic_filebuf* close();<br>\n  Effects: If is_open() == false, returns a null pointer. <strong>If a put area\n  exists, calls overflow(traits::eof()) to flush characters.</strong> If the last\n  virtual member function called on *this (between underflow, overflow,\n  seekoff, and seekpos) was overflow then calls a_codecvt.unshift\n  (possibly several times) to determine a termination sequence, inserts\n  those characters and <strong>calls overflow(traits::eof()) again.</strong> Finally,\n  regardless of whether any of the preceding calls fails or throws an\n  exception, the function closes the file (as if by calling\n  std::fclose(file)).  If any of the calls made by the function,\n  including std::fclose, fails, close fails by returning a null pointer.\n  If one of these calls throws an exception, the exception is caught and\n  rethrown after closing the file.</br></br></p>\n</blockquote>\n<p>It's guaranteed to flush the file.  However, note that the <em>OS</em> might keep it cached, and the <em>OS</em> might not flush it immmediately.</p>\n", "OwnerUserId": "845092", "PostTypeId": "2", "Id": "7522537", "Score": "0", "CreationDate": "2011-09-22T23:09:09.547", "LastActivityDate": "2011-09-22T23:09:09.547"}});