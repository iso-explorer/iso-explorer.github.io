post_cb({"8468246": {"ParentId": "8459219", "CommentCount": "0", "CreationDate": "2011-12-11T23:04:44.520", "OwnerUserId": "823424", "PostTypeId": "2", "Id": "8468246", "Score": "0", "Body": "<p>My answer to the first is yes. A pointer is just a variable (integral) whose value is an address to another memory location. Which is why you are able to do the following.</p>\n<pre><code>(*(void(*)())0)(); /*Ref: Andrew Koenig C Traps and Pitfals*/\n</code></pre>\n<p>or</p>\n<pre><code>#define CARD_INTERFACE_ADDRESS 0x4801C\nstruct A * = new (CARD_INTERFACE_ADDRESS) struct A\n</code></pre>\n<p><code>MyClassA * ptr_a</code> cannot (logically) be converted to <code>int* ptr_i</code> because what you are saying is that the the address held by the variable <code>ptr_a</code> is the address of <code>MyClassA</code> in the former while in the latter you are saying that saying that <code>ptr_i</code> is the address of an <code>int</code>.</p>\n", "LastActivityDate": "2011-12-11T23:04:44.520"}, "8459240": {"ParentId": "8459219", "CommentCount": "0", "CreationDate": "2011-12-10T19:30:45.223", "OwnerUserId": "964135", "PostTypeId": "2", "Id": "8459240", "Score": "1", "Body": "<blockquote>\n<p id=\"so_8459219_8459240_0\">(5.2.10/4) A pointer can be explicitly converted to any integral type large enough to hold it.</p>\n</blockquote>\n<p>This means <code>int*</code> to <code>int</code>. Pointers aren't integral types.</p>\n<p>Casting pointers of unrelated types is bad news and shouldn't be done. It <em>may</em> work, but is not portable. </p>\n<p>Inheritance will work though. Have the types inherit from a base class!</p>\n", "LastActivityDate": "2011-12-10T19:30:45.223"}, "8459234": {"ParentId": "8459219", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-12-10T19:30:00.697", "Score": "1", "LastEditorUserId": "401196", "LastEditDate": "2011-12-10T19:35:16.087", "Id": "8459234", "OwnerUserId": "401196", "Body": "<p>As to whether this works or not I do not know, that would be implementation dependant.</p>\n<p>However there are no guarantee by the standard that this would work (so don't do it), MyClassA and MyClassB are two separate types that are non compatible even if they are structurally the same.</p>\n<p>Same applies to int*.</p>\n<p>if you need conversion between then then you can make an A to B assignment operator</p>\n<pre><code>class MyClassA{\n...\n\n    operator=(const MyClassB&amp; mcb)\n    {\n        this.x=mcb.x;\n        this.y=mcb.y;\n    }\n};\n</code></pre>\n<p>And if you need access to an integer element inside of MyClassA.</p>\n<pre><code>//in MyClassA\nint&amp; getX(){ return x; }\nconst int&amp; getX() const { return x; }\n\nint&amp; x=mca.getX();\n</code></pre>\n", "LastActivityDate": "2011-12-10T19:35:16.087"}, "8459232": {"ParentId": "8459219", "CommentCount": "0", "CreationDate": "2011-12-10T19:29:45.270", "OwnerUserId": "764882", "PostTypeId": "2", "Id": "8459232", "Score": "0", "Body": "<p>That doesn't mean you can cast unrelated types. It means you can cast a pointer to a 64bit integer (for example) if on your platform 64bit integer is sufficiently big enough to contain a pointer value.</p>\n<p><strong>PS: I would like to mention that what you have done is totally deviating from the standard but you might get away with it on many platforms / compilers :)</strong></p>\n", "LastActivityDate": "2011-12-10T19:29:45.270"}, "bq_ids": {"n4140": {"so_8459219_8459219_0": {"section_id": 6043, "quality": 0.9, "length": 9}, "so_8459219_8459240_0": {"section_id": 6043, "quality": 0.9, "length": 9}}, "n3337": {"so_8459219_8459219_0": {"section_id": 5811, "quality": 0.9, "length": 9}, "so_8459219_8459240_0": {"section_id": 5811, "quality": 0.9, "length": 9}}, "n4659": {"so_8459219_8459219_0": {"section_id": 7542, "quality": 0.9, "length": 9}, "so_8459219_8459240_0": {"section_id": 7542, "quality": 0.9, "length": 9}}}, "8459219": {"CommentCount": "3", "ViewCount": "207", "CreationDate": "2011-12-10T19:26:55.153", "LastActivityDate": "2011-12-11T23:04:44.520", "Title": "Pointer to integer using reinterpret", "PostTypeId": "1", "Id": "8459219", "Score": "0", "Body": "<p>I'm trying to cast a pointer to another type using reinterpret_cast</p>\n<pre><code>class MyClassA\n{\n int x;\n int y;\n public:\n    MyClassA();\n    ~MyClassA();\n};\n\nclass MyClassB\n{\n int x;\n int y;\n public:\n    MyClassB();\n    ~MyClassB();\n};\n</code></pre>\n<p>For example, if I cast a pointer to MyClassA to MyClassB, using reinterpret_cast would this conversion work? what about code portability?</p>\n<p>And also, as I noted:</p>\n<blockquote>\n<p id=\"so_8459219_8459219_0\">(5.2.10/4) A pointer can be explicitly converted to any integral type\n  large enough to hold it.</p>\n</blockquote>\n<p>Does it mean any pointer e.g <code>MyClassA*</code> can only be converted to int* pointer? if i'm correct?</p>\n", "Tags": "<c++><reinterpret-cast>", "OwnerUserId": "1086635", "AnswerCount": "4"}});