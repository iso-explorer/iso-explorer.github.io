post_cb({"7917045": {"CommentCount": "3", "AcceptedAnswerId": "7917190", "CreationDate": "2011-10-27T14:02:37.380", "LastActivityDate": "2011-10-27T14:18:47.463", "PostTypeId": "1", "ViewCount": "3591", "FavoriteCount": "2", "Title": "void* with static_cast vs intptr_t with reinterpret_cast", "Id": "7917045", "Score": "13", "Body": "<p>I want to know if there are specific, standards-based differences between two different types of casts of very particular types.  In particular, given: type <code>T</code> and a variable <code>T * object</code> is:</p>\n<pre><code>intptr_t opaque = reinterpret_cast&lt;intptr_t&gt;( object );\nT * result = reinterpret_cast&lt;T*&gt;( opaque );\n</code></pre>\n<p>equivalent to:</p>\n<pre><code>void * opaque = static_cast&lt;void*&gt;( object );\nT * result = static_cast&lt;T*&gt;( opaque );\n</code></pre>\n<p>I only care about the <code>result</code>, is it guaranteed to be the same value, equivalent to the original <code>object</code> for any type <code>T</code>? I don't care what bit pattern the intermediate <code>opaque</code> has, as I believe the standard technically allows them to be different in each case (though no sane compiler would have different results).</p>\n<p>Note, I'm not interested in the generic case of <code>static_cast</code> vs. <code>reinterpret_cast</code>, that I understand well. What I'm interested is in the above very specific case -- resulting from the standard assigning special logic to <code>static_cast</code> and <code>void*</code> that make it behave similar to a <code>reinterpret_cast</code>. <em>(There are several related questions on StackOverflow, but they are more generic, and my scenario I believe is highly specific)</em></p>\n<p>Style and preference aside, is there any technical reason why one form should be used over the over? Or is it guaranteed, for all <code>T</code> to produce the same final <code>result</code> variable?</p>\n", "Tags": "<c++>", "OwnerUserId": "229686", "AnswerCount": "1"}, "7917190": {"ParentId": "7917045", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Yes, both are guaranteed to restore the original pointer value.</p>\n<p>The first is specified by C++11 5.2.10/5:</p>\n<blockquote>\n<p id=\"so_7917045_7917190_0\">A pointer converted\n  to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type\n  will have its original value;</p>\n</blockquote>\n<p>The second is specified by C++11 5.2.9/13:</p>\n<blockquote>\n<p id=\"so_7917045_7917190_1\">A value of type pointer to object\n  converted to \u201cpointer to cv void\u201d and back, possibly with different cv-qualification, shall have its original\n  value.</p>\n</blockquote>\n<p>There is a technical reason to prefer the second version over the first one: <code>intptr_t</code> is optional, but every implementation has <code>void*</code>.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "46642", "LastEditDate": "2011-10-27T14:18:47.463", "Id": "7917190", "Score": "14", "CreationDate": "2011-10-27T14:12:53.750", "LastActivityDate": "2011-10-27T14:18:47.463"}, "bq_ids": {"n4140": {"so_7917045_7917190_1": {"section_id": 6039, "quality": 1.0, "length": 15}, "so_7917045_7917190_0": {"section_id": 6044, "quality": 1.0, "length": 17}}, "n3337": {"so_7917045_7917190_1": {"section_id": 5807, "quality": 1.0, "length": 15}, "so_7917045_7917190_0": {"section_id": 5812, "quality": 1.0, "length": 17}}, "n4659": {"so_7917045_7917190_1": {"section_id": 7543, "quality": 0.6, "length": 9}, "so_7917045_7917190_0": {"section_id": 7543, "quality": 1.0, "length": 17}}}});