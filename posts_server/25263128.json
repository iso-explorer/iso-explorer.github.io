post_cb({"25263189": {"ParentId": "25263128", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You are not overloading assignment operators, but conversion operators. So they are called when conversion takes place.</p>\n<p>See <a href=\"https://stackoverflow.com/q/12335684\">c++: cast operator vs. assign operator vs. conversion constructor priority</a></p>\n", "OwnerUserId": "3246555", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:08.233", "Id": "25263189", "Score": "2", "CreationDate": "2014-08-12T11:32:23.473", "LastActivityDate": "2014-08-12T11:44:02.710"}, "25263128": {"CommentCount": "2", "ViewCount": "72", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2014-08-12T11:29:31.087", "LastActivityDate": "2017-03-06T13:37:59.207", "Title": "Assignment operator overload", "LastEditDate": "2017-03-06T13:37:59.207", "Id": "25263128", "Score": "0", "Body": "<p>I have class that has assignment to <code>string</code> operator.</p>\n<pre><code>class turbo\n    {\npublic:\n    operator string   (void) {printf(\"assignment to string operator\\n\");return \"bla2\";}\n    };\n</code></pre>\n<p>Assignment operation works just fine:</p>\n<pre><code>turbo t;\nstring s;\ns=t;\n</code></pre>\n<p>And I have <code>\"assignment to string operator\"</code> in output.</p>\n<p>Then I decided to make another assignment operator to <code>turbo</code></p>\n<pre><code>class turbo\n    {\npublic:\n    operator string   (void) {printf(\"assignment to string operator\\n\");return \"bla\";}\n    operator turbo   (void) {printf(\"assignment to turbo operator\\n\");return *this;}\n    };\n</code></pre>\n<p>But code below does not calls <code>turbo</code> assignment operator.</p>\n<pre><code>turbo t;\nturbo tt ;\ntt=t;\n</code></pre>\n<p>Why?</p>\n<p>I know that I can overload <code>=</code> operator, but I expect operator <code>turbo</code> work also since <code>string</code> one is operating.</p>\n", "Tags": "<c++>", "OwnerUserId": "1501700", "AnswerCount": "2"}, "25263258": {"ParentId": "25263128", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The implicitly-declared copy assignment operator of a class takes a single parameter of type <code>X const&amp;</code> (here <code>turbo const&amp;</code>). Since your RHS operand is already of type <code>turbo</code>, there is no need to call the conversion function.</p>\n<p>Indeed, a conversion function to the same type is never called implicitly; it can only be called explicitly (as <code>turbo::operator turbo()</code>) or possibly via a virtual conversion function in a base class.  This is discussed in <strong>[class.conv.fct]</strong>:</p>\n<blockquote>\n<p id=\"so_25263128_25263258_0\">1 - [...]  A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), or to (possibly cv-qualified) void. [...]</p>\n</blockquote>\n<p>See <a href=\"https://stackoverflow.com/questions/8350678/under-what-circumstances-would-a-types-conversion-operator-to-itself-be-invoked\">Under what circumstances would a type's conversion operator to itself be invoked?</a></p>\n", "OwnerUserId": "567292", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:10.080", "Id": "25263258", "Score": "1", "CreationDate": "2014-08-12T11:35:57.437", "LastActivityDate": "2014-08-12T11:35:57.437"}, "bq_ids": {"n4140": {"so_25263128_25263258_0": {"section_id": 391, "quality": 1.0, "length": 22}}, "n3337": {"so_25263128_25263258_0": {"section_id": 382, "quality": 1.0, "length": 22}}, "n4659": {"so_25263128_25263258_0": {"section_id": 408, "quality": 1.0, "length": 22}}}});