post_cb({"16596864": {"CommentCount": "0", "AcceptedAnswerId": "16596909", "CreationDate": "2013-05-16T20:28:11.067", "LastActivityDate": "2013-05-16T20:45:00.393", "PostTypeId": "1", "ViewCount": "3155", "FavoriteCount": "1", "Title": "C++11 operator\"\" with double parameter", "Id": "16596864", "Score": "22", "Body": "<p>Consider:</p>\n<pre><code>struct str {};\n\nstr operator\"\" _X(long double d) {\n    return str();\n}\n</code></pre>\n<p>This compiles fine with g++ 4.7.2 Wall std=c++11</p>\n<p>but now if I give a double :</p>\n<pre><code>str operator\"\" _X(double d) {\n    return str();\n}\n</code></pre>\n<p>I get the following error message:\nmain.cpp|3|error: 'str operator\"\" _X(double)' has invalid argument list</p>\n<p>What is the problem ? Has this something to do with \"It is not possible to redefine the meaning of a built-in literal suffix\" (Stroustrup FAQ) ?\nCan you think of a workaround ?</p>\n", "Tags": "<c++><c++11><literals>", "OwnerUserId": "1583122", "AnswerCount": "2"}, "16596909": {"ParentId": "16596864", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_16596864_16596909_0\">What is the problem?</p>\n</blockquote>\n<p>The problem is that the Standard forbids it. Per paragraph 13.5.8./3 of the C++11 Standard on user-defined literals:</p>\n<blockquote>\n<p id=\"so_16596864_16596909_1\">The declaration of a literal operator shall have a parameter-declaration-clause equivalent to one of the\n  following:</p>\n<pre><code>const char*\nunsigned long long int\nlong double\nchar\nwchar_t\nchar16_t\nchar32_t\nconst char*, std::size_t\nconst wchar_t*, std::size_t\nconst char16_t*, std::size_t\nconst char32_t*, std::size_t\n</code></pre>\n</blockquote>\n<p>Concerning a workaround, I am not sure it is needed, since the following works fine (a <code>double</code> gets implicitly converted to a <code>long double</code>, so you can pass in literals of type <code>double</code>):</p>\n<pre><code>struct str {};\n\nstr operator\"\" _X(long double d) {\n    return str();\n}\n\nint main()\n{\n    str s = 4.0_X;\n}\n</code></pre>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "16596909", "Score": "30", "CreationDate": "2013-05-16T20:30:28.013", "LastActivityDate": "2013-05-16T20:30:28.013"}, "16597135": {"ParentId": "16596864", "CommentCount": "2", "Body": "<p>I think it's to prevent ambiguous overloads.  What if you were allowed to define the following overload set</p>\n<pre><code>str operator\"\" _X(long double ld);\nstr operator\"\" _X(double d);\nstr operator\"\" _X(float f);\n</code></pre>\n<p>Can you give examples of user-defined literals in source code that would map to each of the above?  No, there's no way to constrain the literal to a particular floating-point datatype.</p>\n<p>What could be useful is this set:</p>\n<pre><code>str operator\"\" l_X(long double ld);\nstr operator\"\"  _X(long double d);\nstr operator\"\" f_X(long double f);\n</code></pre>\n<p>Since now you could write</p>\n<pre><code>3.0_X  // treated like a double\n3.0l_X // treated like a long double\n3.0f_X // treated like a float\n</code></pre>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "16597135", "Score": "3", "CreationDate": "2013-05-16T20:45:00.393", "LastActivityDate": "2013-05-16T20:45:00.393"}, "bq_ids": {"n4140": {"so_16596864_16596909_1": {"section_id": 669, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_16596864_16596909_1": {"section_id": 659, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_16596864_16596909_1": {"section_id": 697, "quality": 0.8888888888888888, "length": 8}}}});