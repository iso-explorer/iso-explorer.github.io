post_cb({"45056630": {"ParentId": "45056234", "LastEditDate": "2017-07-12T11:51:16.263", "CommentCount": "0", "CreationDate": "2017-07-12T11:37:48.097", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "PostTypeId": "2", "Id": "45056630", "Score": "0", "Body": "<p>In the statements like these</p>\n<pre><code>cout &lt;&lt; (\"A\" &gt; \"A\") &lt;&lt; endl;\ncout &lt;&lt; (\"a\" &gt; \"A\")&lt;&lt; endl;\ncout &lt;&lt; (\"B\" &gt; \"a\")&lt;&lt; endl;\n//...\n</code></pre>\n<p>there are used string literals that have the static storage duration. In C++ string literals have types of constant character arrays. For example the string literal <code>\"A\"</code> has type <code>const char[2]</code> because in memory it is stored like <code>{ 'A', '\\0' }</code>.</p>\n<p>Execute this statement</p>\n<pre><code>std::cout &lt;&lt; sizeof( \"A\" ) &lt;&lt; std::endl;\n</code></pre>\n<p>and you will see that the result will be 2.</p>\n<p>From the C++ Standard (2.13.5 String literals)</p>\n<blockquote>\n<p id=\"so_45056234_45056630_0\">8 Ordinary string literals and UTF-8 string literals are also referred\n  to as narrow string literals. <strong>A narrow string literal has type\n  \u201carray of n const char\u201d, where n is the size of the string as defined\n  below, and has static storage duration</strong> (3.7).</p>\n</blockquote>\n<p>In expressions like this <code>\"A\" &gt; \"A\"</code> arrays are implicitly converted to pointers to their first characters. So in this expression there are compared two pointers.</p>\n<p>From the C++ STandard (4.2 Array-to-pointer conversion)</p>\n<blockquote>\n<p id=\"so_45056234_45056630_1\">1 An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown\n  bound of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The\n  temporary materialization conversion (4.4) is applied. <strong>The result is\n  a pointer to the first element of the array.</strong></p>\n</blockquote>\n<p>In general it is not necessary that string literals with equal contents will be stored as one character array. So in fact this expression</p>\n<pre><code>\"A\" == \"A\"\n</code></pre>\n<p>can yield either <code>true</code> or <code>false</code> depending on compiler options that is whether these two string literals stored as one array or as two distinct arrays by the compiler.</p>\n<p>It seems your compiler stores equal string literals as one array. In this case this statement</p>\n<pre><code>cout &lt;&lt; (\"A\" &gt; \"A\") &lt;&lt; endl;\n</code></pre>\n<p>outputs 0.</p>\n<p>Also it seems that the compiler placed the array that stores the string literal <code>\"a\"</code> after the array that stores string literal <code>\"A\"</code>. So the address of the first character of the string literal <code>\"a\"</code>, that is of the character <code>'a'</code>, is higher than the address of the first character of the string literal <code>\"A\"</code>.  So this statement</p>\n<pre><code>cout &lt;&lt; (\"a\" &gt; \"A\")&lt;&lt; endl;\n</code></pre>\n<p>outputs 1.</p>\n<p>Also the compiler placed the array that stores the string literal <code>\"B\"</code> after the array that stores the string literal <code>\"a\"</code>. So again the address of the first character of the string literal <code>\"B\"</code> is higher than the address of the first character of the string literal <code>\"a\"</code> and in this statement</p>\n<pre><code>cout &lt;&lt; (\"B\" &gt; \"a\")&lt;&lt; endl;\n</code></pre>\n<p>there are compared these addresses. So the statement outputs 1. </p>\n<p>And so on.</p>\n<p>It seems what you need to do is to compare character literals instead of the string literals. For example</p>\n<pre><code>cout &lt;&lt; ( 'A' &gt; 'A') &lt;&lt; endl;\ncout &lt;&lt; ('a' &gt; 'A')&lt;&lt; endl;\ncout &lt;&lt; ('B' &gt; 'a')&lt;&lt; endl;\n//...\n</code></pre>\n", "LastActivityDate": "2017-07-12T11:51:16.263"}, "45056427": {"ParentId": "45056234", "CommentCount": "4", "Body": "<p>You have made an <em>assumption</em> that <code>&gt;</code> and <code>&lt;</code> perform lexicographic comparison on string literals.</p>\n<p>Unfortunately, that assumption does not hold. You are just comparing pointers.</p>\n<p>Use <a href=\"http://en.cppreference.com/w/cpp/string/byte/strcmp\" rel=\"noreferrer\"><code>strcmp</code></a> instead and, next time, <em>read the documentation</em> instead of making assumptions.</p>\n<p>Also, <code>main</code> returns <code>int</code>, not <code>void</code>.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "45056427", "Score": "7", "CreationDate": "2017-07-12T11:27:56.857", "LastActivityDate": "2017-07-12T11:27:56.857"}, "45056234": {"CommentCount": "5", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "4117728", "CreationDate": "2017-07-12T11:19:30.017", "LastActivityDate": "2017-07-12T11:51:16.263", "Title": "Why in Visual C++ STL: \"C\" not bigger than \"b\"", "LastEditDate": "2017-07-12T11:23:44.447", "Id": "45056234", "Score": "-1", "Body": "<p>Why C not bigger than b, when B bigger than a?</p>\n<p>Code in Visual C++ 2017 STL:</p>\n<pre><code>void main ()\n{       \n    cout &lt;&lt; (\"A\" &gt; \"A\") &lt;&lt; endl;\n    cout &lt;&lt; (\"a\" &gt; \"A\")&lt;&lt; endl;\n    cout &lt;&lt; (\"B\" &gt; \"a\")&lt;&lt; endl;\n    cout &lt;&lt; (\"b\" &gt; \"B\")&lt;&lt; endl;\n    cout &lt;&lt; (\"C\" &gt; \"b\")&lt;&lt; endl; \n    cout &lt;&lt; (\"c\" &gt; \"C\")&lt;&lt; endl;\n    cout &lt;&lt; (\"AA\" &gt; \"c\")&lt;&lt; endl;\n    cout &lt;&lt; (\"Aa\" &gt; \"AA\")&lt;&lt; endl;\n    cout &lt;&lt; (\"aA\" &gt; \"AA\")&lt;&lt; endl;\n    cout &lt;&lt; (\"aa\" &gt; \"aA\")&lt;&lt; endl;\n    cout &lt;&lt; (\"BA\" &gt; \"aa\")&lt;&lt; endl;\n    cout &lt;&lt; (\"Ba\" &gt; \"BA\")&lt;&lt; endl;\n    cout &lt;&lt; (\"D\" &gt; \"c\")&lt;&lt; endl;\n    string pause;\n    cin &gt;&gt; pause;\n}\n</code></pre>\n<p>OutPut:\n0\n1\n1\n1\n0\n1\n1\n1\n1\n1\n1\n1\n1</p>\n", "Tags": "<c++>", "OwnerUserId": "8275354", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_45056234_45056630_1": {"section_id": 11, "quality": 0.7391304347826086, "length": 17}, "so_45056234_45056630_0": {"section_id": 5356, "quality": 1.0, "length": 26}}, "n3337": {"so_45056234_45056630_1": {"section_id": 8, "quality": 0.7391304347826086, "length": 17}, "so_45056234_45056630_0": {"section_id": 5153, "quality": 1.0, "length": 26}}, "n4659": {"so_45056234_45056630_1": {"section_id": 12, "quality": 0.9130434782608695, "length": 21}, "so_45056234_45056630_0": {"section_id": 6781, "quality": 1.0, "length": 26}}}, "45056428": {"ParentId": "45056234", "LastEditDate": "2017-07-12T11:32:45.333", "CommentCount": "2", "CreationDate": "2017-07-12T11:27:58.060", "OwnerUserId": "1055118", "LastEditorUserId": "1055118", "PostTypeId": "2", "Id": "45056428", "Score": "3", "Body": "<p>You are comparing pointers. </p>\n<p><code>\"A\"</code> is a pointer to chararaters. (Actaully const char[2] as pointed out in comments)\n<code>'A'</code> is a character.</p>\n<p>Try this: </p>\n<pre><code>int main ()\n{\n    cout &lt;&lt; ('A' &gt; 'A') &lt;&lt; endl;\n    cout &lt;&lt; ('a' &gt; 'A')&lt;&lt; endl;\n    cout &lt;&lt; ('B' &gt; 'a')&lt;&lt; endl;\n    cout &lt;&lt; ('b' &gt; 'B')&lt;&lt; endl;\n    cout &lt;&lt; ('C' &gt; 'b')&lt;&lt; endl; \n    cout &lt;&lt; ('c' &gt; 'C')&lt;&lt; endl;\n}\n</code></pre>\n<p>You now need to think about what you want from a string (or char array).</p>\n<p>Is \"AA\" less or greater than \"c\"? It comes first in a dictionary, but it's shorter. </p>\n<p>If you want \"dictionary\" (lexographical) order you need to compare strings; <code>strcmp</code> or look at <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator_cmp\" rel=\"nofollow noreferrer\">string comparision operators</a> (if you decide to use std::string instead)</p>\n", "LastActivityDate": "2017-07-12T11:32:45.333"}});