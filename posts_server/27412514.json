post_cb({"bq_ids": {"n4140": {"so_27412514_27412702_0": {"length": 53, "quality": 0.9464285714285714, "section_id": 6028}}, "n3337": {"so_27412514_27412702_0": {"length": 55, "quality": 0.9821428571428571, "section_id": 5796}}, "n4659": {"so_27412514_27412702_0": {"length": 45, "quality": 0.8035714285714286, "section_id": 7527}}}, "27412702": {"Id": "27412702", "PostTypeId": "2", "Body": "<p>In theory, no. In practice, maybe, as long as there are no virtual functions involved. The relevant passage in the standard is 5.2.9 (2):</p>\n<blockquote>\n<p id=\"so_27412514_27412702_0\">An lvalue of type \"<em>cv1</em> B\", where B is a class type, can be cast to type \"reference to <em>cv2</em> D,\" where D is a class derived from B, if a valid standard conversion from \"pointer to D\" to \"pointer to B\" exists, <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and B is neither a virtual base class of D nor a base class of a virtual base class of D. The result has type \"<em>cv2</em> D.\" (...) If the object of type \"<em>cv1</em> B\" is actually a subobject of an object of type D, the result refers to the enclosing object of type D. <strong>Otherwise, the result of the cast is undefined.</strong></p>\n</blockquote>\n<p>Emphasis mine.</p>\n<p>EDIT: Well, my first approach at a dirty-but-legal hack didn't work, which is nice because the loophole I thought existed was one that shouldn't. There's no way to legally call <code>foo</code> on <code>*obj</code> that I can find -- as well there shouldn't be, if <code>protected</code> is to have any meaning at all -- so the best I can offer are two ideas for workarounds:</p>\n<p>Firstly, if copying (or moving) back and forth is okay</p>\n<pre><code>class PublicBase : public Base {\npublic:\n  void bar(Base *obj) {\n    // upcast, perfectly legal. make a working copy into self\n    *static_cast&lt;Base*&gt;(this) = *obj;\n    // work\n    foo();\n    // copy back\n    *obj = *this;\n  }\n};\n</code></pre>\n<p>Secondly, if you can derive from <code>Base</code> and use the new class whereever you would have used <code>Base</code> before:</p>\n<pre><code>// use this instead of Base everywhere.\nclass BaseWithAccess {\npublic:\n  void publicfoo() { foo(); }\n};\n</code></pre>\n<p>Other than that, I have nothing. Unless you can change <code>Base</code>, in which case you could just make <code>foo</code> public.</p>\n", "LastEditorUserId": "4301306", "LastActivityDate": "2014-12-10T23:55:24.067", "Score": "5", "CreationDate": "2014-12-10T23:21:54.680", "ParentId": "27412514", "CommentCount": "4", "OwnerUserId": "4301306", "LastEditDate": "2014-12-10T23:55:24.067"}, "27412514": {"ViewCount": "77", "Body": "<p>I use the following code to access a protected member of an object.</p>\n<pre><code>class Base {\nprotected:\n    void foo();\n};\n\nclass PublicBase : public Base {\npublic:\n    static void bar(Base *obj) {\n        static_assert(sizeof(PublicBase) == sizeof(Base), \"Not today\");\n        static_cast&lt;PublicBase *&gt;(obj)-&gt;foo();\n    }\n};\n</code></pre>\n<p>Can I assume that provided code is safe to use (in theory and in practice)?</p>\n", "AcceptedAnswerId": "27412702", "Title": "In which case it is not safe to cast an object of base class to EMPTY derived class", "CreationDate": "2014-12-10T23:05:40.333", "Id": "27412514", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-12-10T23:55:24.067", "Score": "2", "OwnerUserId": "2489083", "Tags": "<c++>", "AnswerCount": "1"}});