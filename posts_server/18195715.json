post_cb({"18449668": {"Id": "18449668", "PostTypeId": "2", "Body": "<p>In addition to the other issues mentioned, having unsigned math wrap makes the unsigned integer types behave as abstract algebraic groups (meaning that, among other things, for any pair of values <code>X</code> and <code>Y</code>, there will exist some other value <code>Z</code> such that <code>X+Z</code> will, if properly cast, equal <code>Y</code> and <code>Y-Z</code> will, if properly cast, equal <code>X</code>).  If unsigned values were merely storage-location types and not intermediate-expression types (e.g. if there were no unsigned equivalent of the largest integer type, and arithmetic operations on unsigned types behaved as though they were first converted them to larger signed types, then there wouldn't be as much need for defined wrapping behavior, but it's difficult to do calculations in a type which doesn't have e.g. an additive inverse.</p>\n<p>This helps in situations where wrap-around behavior is actually useful - for example with TCP sequence numbers or certain algorithms, such as hash calculation. It may also help in situations where it's necessary to detect overflow, since performing calculations and checking whether they overflowed is often easier than checking in advance whether they would overflow, especially if the calculations involve the largest available integer type.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2016-03-15T14:11:27.010", "Score": "6", "CreationDate": "2013-08-26T17:31:59.857", "ParentId": "18195715", "CommentCount": "7", "OwnerUserId": "363751", "LastEditDate": "2016-03-15T14:11:27.010"}, "18195756": {"Id": "18195756", "PostTypeId": "2", "Body": "<p>The historical reason is that most C implementations (compilers) just used whatever overflow behaviour was easiest to implement with the integer representation it used. C implementations usually used the same representation used by the CPU - so the overflow behavior followed from the integer representation used by the CPU.</p>\n<p>In practice, it is only the representations for signed values that may differ according to the implementation: one's complement, two's complement, sign-magnitude. For an unsigned type there is no reason for the standard to allow variation because there is only one obvious binary representation (the standard only allows binary representation).</p>\n<p>Relevant quotes:</p>\n<p><strong>C99 6.2.6.1:3</strong>:</p>\n<blockquote>\n<p id=\"so_18195715_18195756_0\">Values stored in unsigned bit-fields and objects of type unsigned char shall be represented using a pure binary notation.</p>\n</blockquote>\n<p><strong>C99 6.2.6.2:2</strong>:</p>\n<blockquote>\n<p id=\"so_18195715_18195756_1\">If the sign bit is one, the value shall be modified in one of the following ways:</p>\n<p id=\"so_18195715_18195756_2\">\u2014 the corresponding value with sign bit 0 is negated (<em>sign and magnitude</em>); </p>\n<p id=\"so_18195715_18195756_3\">\u2014 the sign bit has the value \u2212(2<sup>N</sup>) (<em>two\u2019s complement</em>);</p>\n<p id=\"so_18195715_18195756_4\">\u2014 the sign bit has the value \u2212(2<sup>N</sup> \u2212 1) (<em>one\u2019s complement</em>).</p>\n</blockquote>\n<hr>\n<p>Nowadays, all processors use two's complement representation, but signed arithmetic overflow remains undefined and compiler makers want it to remain undefined because they use this undefinedness to help with optimization. See for instance this <a href=\"http://www.airs.com/blog/archives/120\" rel=\"noreferrer\">blog post</a> by Ian Lance Taylor or this <a href=\"http://gcc.gnu.org/ml/gcc-help/2011-07/msg00219.html\" rel=\"noreferrer\">complaint</a> by Agner Fog, and the answers to his bug report.</p>\n</hr>", "LastEditorUserId": "597607", "LastActivityDate": "2017-03-13T11:12:54.160", "Score": "112", "CreationDate": "2013-08-12T20:06:48.813", "ParentId": "18195715", "CommentCount": "14", "OwnerUserId": "139746", "LastEditDate": "2017-03-13T11:12:54.160"}, "46572658": {"Id": "46572658", "PostTypeId": "2", "Body": "<p>Perhaps another reason for why unsigned arithmetic is defined is because unsigned numbers form integers modulo 2^n, where n is the width of the unsigned number. Unsigned numbers are simply integers represented using binary digits instead of decimal digits. Performing the standard operations in a modulus system is well understood. I believe the OP's quote refers to this fact.</p>\n<p>Unsigned numbers are most often represented using two's complement. They make certain operations make more sense in binary format. E.g., incrementing negative numbers is the same that for positive numbers (expect under overflow conditions). Some operations at the machine level can be the same for signed and unsigned numbers. However, when interpreting the result of those operations, some cases doesn't make sense - positive and negative overflow.</p>\n", "LastEditorUserId": "3905308", "LastActivityDate": "2017-10-06T00:57:13.297", "Score": "0", "CreationDate": "2017-10-04T19:24:14.723", "ParentId": "18195715", "CommentCount": "2", "OwnerUserId": "3905308", "LastEditDate": "2017-10-06T00:57:13.297"}, "bq_ids": {"n4140": {"so_18195715_41280273_0": {"length": 13, "quality": 0.8125, "section_id": 5937}, "so_18195715_18195715_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 7213}, "so_18195715_41280273_3": {"length": 9, "quality": 0.5294117647058824, "section_id": 6035}}, "n3337": {"so_18195715_41280273_0": {"length": 13, "quality": 0.8125, "section_id": 5709}, "so_18195715_18195715_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 6957}, "so_18195715_41280273_1": {"length": 23, "quality": 0.5111111111111111, "section_id": 6957}, "so_18195715_41280273_3": {"length": 9, "quality": 0.5294117647058824, "section_id": 5930}}, "n4659": {"so_18195715_41280273_0": {"length": 13, "quality": 0.8125, "section_id": 7421}, "so_18195715_18195715_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 8722}, "so_18195715_41280273_3": {"length": 9, "quality": 0.5294117647058824, "section_id": 7534}}}, "18195715": {"ViewCount": "28603", "Body": "<p>Unsigned integer overflow is well defined by both the C and C++ standards.  For example, the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"noreferrer\">C99 standard</a> (<code>\u00a76.2.5/9</code>) states </p>\n<blockquote>\n<p id=\"so_18195715_18195715_0\">A computation involving unsigned operands can never over\ufb02ow,\n  because a result that cannot be represented by the resulting unsigned integer type is\n  reduced modulo the number that is one greater than the largest value that can be\n  represented by the resulting type.</p>\n</blockquote>\n<p>However, both standards state that signed integer overflow is undefined behavior.  Again, from the C99 standard (<code>\u00a73.4.3/1</code>)</p>\n<blockquote>\n<p id=\"so_18195715_18195715_1\">An example of unde\ufb01ned behavior is the behavior on integer over\ufb02ow</p>\n</blockquote>\n<p>Is there an historical or (even better!) a technical reason for this discrepancy?</p>\n", "AcceptedAnswerId": "18195756", "Title": "Why is unsigned integer overflow defined behavior but signed integer overflow isn't?", "CreationDate": "2013-08-12T20:04:18.380", "Id": "18195715", "CommentCount": "6", "FavoriteCount": "42", "PostTypeId": "1", "LastEditDate": "2017-05-22T06:48:19.733", "LastEditorUserId": "584518", "LastActivityDate": "2017-10-06T00:57:13.297", "Score": "142", "OwnerUserId": "600591", "Tags": "<c++><c><undefined-behavior><integer-overflow>", "AnswerCount": "5"}, "18195824": {"Id": "18195824", "PostTypeId": "2", "Body": "<p>Aside from Pascal's good answer (which I'm sure is the main motivation), it is also possible that some processors cause an exception on signed integer overflow, which of course would cause problems if the compiler had to \"arrange for another behaviour\" (e.g. use extra instructions to check for potential overflow and calculate differently in that case). </p>\n<p>It is also worth noting that \"undefined behaviour\" doesn't mean \"doesn't work\". It means that the implementation is allowed to do whatever it likes in that situation. This includes doing \"the right thing\" as well as \"calling the police\" or \"crashing\". Most compilers, when possible, will choose \"do the right thing\", assuming that is relatively easy to define (in this case, it is). However, if you are having overflows in the calculations, it is important to understand what that actually results in, and that the compiler MAY do something other than what you expect (and that this may very depending on compiler version, optimisation settings, etc). </p>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2015-11-11T19:39:09.700", "Score": "9", "CreationDate": "2013-08-12T20:10:43.150", "ParentId": "18195715", "CommentCount": "16", "OwnerUserId": "1919155", "LastEditDate": "2015-11-11T19:39:09.700"}, "41280273": {"Id": "41280273", "PostTypeId": "2", "Body": "<p>First of all, please note that C11 3.4.3, like all examples and foot notes, is not normative text and therefore not relevant to cite!</p>\n<p>The relevant text that states that overflow of integers and floats is undefined behavior is this:</p>\n<p><strong>C11 6.5/5</strong></p>\n<blockquote>\n<p id=\"so_18195715_41280273_0\">If an exceptional condition occurs during the evaluation of an\n  expression (that is, if the result is not mathematically defined or\n  not in the range of representable values for its type), the behavior\n  is undefined.</p>\n</blockquote>\n<p>A clarification regarding the behavior of unsigned integer types specifically can be found here:</p>\n<p><strong>C11 6.2.5/9</strong></p>\n<blockquote>\n<p id=\"so_18195715_41280273_1\">The range of nonnegative values of a signed integer type is a subrange\n  of the corresponding unsigned integer type, and the representation of\n  the same value in each type is the same. A computation involving\n  unsigned operands can never overflow, because a result that cannot be\n  represented by the resulting unsigned integer type is reduced modulo\n  the number that is one greater than the largest value that can be\n  represented by the resulting type.</p>\n</blockquote>\n<p>This makes unsigned integer types a special case.</p>\n<p>Also note that there is an exception if any type is <em>converted</em> to a signed type and the old value can no longer be represented. The behavior is then merely implementation-defined, although a signal may be raised.</p>\n<p><strong>C11 6.3.1.3</strong></p>\n<blockquote>\n<p id=\"so_18195715_41280273_2\">6.3.1.3 Signed and unsigned integers   </p>\n<p id=\"so_18195715_41280273_3\">When a value with integer\n  type is converted to another integer type other than _Bool, if the\n  value can be represented by the new type, it is unchanged.  </p>\n<p id=\"so_18195715_41280273_4\">Otherwise, if the new type is unsigned, the value is converted by\n  repeatedly adding or subtracting one more than the maximum value that\n  can be represented in the new type until the value is in the range of\n  the new type.  </p>\n<p id=\"so_18195715_41280273_5\">Otherwise, the new type is signed and the value\n  cannot be represented in it; either the result is\n  implementation-defined or an implementation-defined signal is raised.</p>\n</blockquote>\n", "LastActivityDate": "2016-12-22T09:53:33.370", "CommentCount": "0", "CreationDate": "2016-12-22T09:53:33.370", "ParentId": "18195715", "Score": "4", "OwnerUserId": "584518"}});