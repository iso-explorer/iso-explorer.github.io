post_cb({"bq_ids": {"n4140": {"so_28809728_28810559_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 88}, "so_28809728_28810559_1": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_28809728_28810559_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 83}, "so_28809728_28810559_1": {"length": 5, "quality": 1.0, "section_id": 82}}}, "28809728": {"ViewCount": "1531", "Body": "<p>Let's suppose we have a template function with non-type parameter of <code>const char *</code> like this:</p>\n<pre><code>template &lt;const char * MESSAGE&gt; void print() {\n    std::cout &lt;&lt; MESSAGE &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Using this template wouldn't be a problem as log as the <code>MESSAGE</code> can be deduced at compile-time, so the following uses are legal:</p>\n<pre><code>namespace {\n    char namespace_message[] = \"Anonymous Namespace Message\";\n    constexpr char namespace_constexpr_message[] = \"Anonymous Namespace Constexpr Message\";\n}\n\nchar message[] = \"Message\";\nconstexpr char constexpr_message[] = \"Constexpr Message\";\n\nint main()\n{\n    print&lt;namespace_message&gt;();\n    print&lt;namespace_constexpr_message&gt;();\n\n    print&lt;message&gt;();\n    print&lt;constexpr_message&gt;();\n\n    return 0;\n}\n</code></pre>\n<p>But the ones below are not (<a href=\"http://ideone.com/bpzevR\" rel=\"nofollow noreferrer\">see here</a>):</p>\n<pre><code>namespace {\nconst char namespace_const_message[] = \"Anonymous Namespace Const Message\";\n}\n\nconst char const_message[] = \"Const Message\";\n\nint main()\n{\n    print&lt;namespace_const_message&gt;();\n    print&lt;const_message&gt;();\n    print&lt;\"Literal\"&gt;();\n\n    return 0;\n}\n</code></pre>\n<p>The errors generated by the code above are the following:</p>\n<blockquote>\n<p id=\"so_28809728_28809728_0\">the value of '{anonymous}::namespace_const_message' is not usable in a constant expression</p>\n</blockquote>\n<p>I don't get why <code>namespace_const_message</code> is not usable in a constant expression while <code>namespace_message</code> is; if I must bet for one of them to be unable to be used in a constant expression I'll bet for the no constant one, but is the one which already works as constant expression!</p>\n<blockquote>\n<p id=\"so_28809728_28809728_1\">note: '{anonymous}::namespace_const_message' was not declared 'constexpr'</p>\n</blockquote>\n<p><code>namespace_message</code> was neither declared as <code>constexpr</code> and is used into a constant expression and its value is deduced at compile time. Why <code>constexpr</code> is needed if the expression is <code>const</code> and not required if no-const?</p>\n<p>Same goes for the values outside the anonymous namespace, I was trying to force the compile-time-constness placing the values into a internal linkage space but is obvious that I've failed.</p>\n<p>Finally, the last error:</p>\n<blockquote>\n<p id=\"so_28809728_28809728_2\">'\"Literal\"' is not a valid template argument for type 'const char*' because string literals can never be used in this context</p>\n</blockquote>\n<p>So, surprisingly (at least it was a surprise for me) a string literal cannot be used as template argument, but as long as the string (well, a pointer to a null-terminated array of characters) is a compile-time value it can be used as non-type template parameters so: they're available at compile-time as long as \"they are a lvalue\" (but they're <a href=\"https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value\">already lvalues</a>!).</p>\n<p>I'm trying to guess why a string literal can never be used in this context, and my best guess is that two string literals with the same content aren't the same literal (because the pointer which points to the content could be different) while two integral literals are the same (they're a value, not a pointer to a value).</p>\n<p>So, what's the question here?</p>\n<ul>\n<li>Why the <code>namespace_const_message</code> and <code>const_message</code> aren't available at compile-time and thus forbidden in the <code>print</code> template function?</li>\n<li>Is my guess about the string literals correct?</li>\n</ul>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "28810320", "Title": "Some const char * are unavailable at compile time?", "CreationDate": "2015-03-02T12:25:09.107", "Id": "28809728", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:33:04.773", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-02T13:39:33.287", "Score": "12", "OwnerUserId": "499359", "Tags": "<c++><string><templates><compile-time><string-literals>", "AnswerCount": "2"}, "28810320": {"PostTypeId": "2", "Body": "<p>The instantiation variable of a template needed to have external\nlinkage, and <code>const</code> was implicitly internal linkage.  So you have to\nwrite:</p>\n<pre><code>extern char const constMessage[] = \"Const message\";\n</code></pre>\n<p>(Another alternative would be for it to be a static class member.\nStatic class members always have external linkage.)</p>\n<p>The case of string literals is in some ways similar: their type is \n<code>char const[]</code>.  But it's even worse: template instantiations (at least\nthe early ones) need a name, and a string literal doesn't have one.\nEven more to the point, it's unspecified whether identical string literals\nare the same object or not, so in the following:</p>\n<pre><code>template &lt;char const* m&gt;\nstruct Toto { char const* f() const; };\n\nToto &lt;\"titi\"&gt; t1;\nToto &lt;\"titi\"&gt; t2;\n</code></pre>\n<p>it would be unspecified whether <code>t1</code> and <code>t2</code> had the type or not.</p>\n", "LastActivityDate": "2015-03-02T13:01:58.667", "LastEditorUserId": "649665", "Id": "28810320", "CommentCount": "7", "CreationDate": "2015-03-02T12:54:40.487", "ParentId": "28809728", "Score": "8", "OwnerUserId": "649665", "LastEditDate": "2015-03-02T13:01:58.667"}, "28810559": {"PostTypeId": "2", "Body": "<p>From the c++11 standard \u00a714.3.2.1</p>\n<blockquote>\n<p id=\"so_28809728_28810559_0\"><em>Template non-type arguments</em></p>\n<p id=\"so_28809728_28810559_1\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ol>\n<li>for a non-type template-parameter of integral or enumeration type,\n  a converted constant expression (5.19) of the type of the\n  template-parameter; or </li>\n<li>the name of a non-type template-parameter; or</li>\n<li>a constant expression (5.19) that designates the address of an\n  object with static storage duration and external or internal linkage\n  or a function with external or internal linkage, including function\n  templates and function template-ids but excluding non-static class\n  members, expressed (ignoring parentheses) as &amp; id-expression, except\n  that the &amp; may be omitted if the name refers to a function or array\n  and shall be omitted if the corresponding template-parameter is a\n  reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1; or</li>\n<li>an address constant expression of type std::nullptr_t.</li>\n</ol>\n</blockquote>\n<p>To your questions:</p>\n<p><em>Why the namespace_const_message and const_message aren't available at compile-time and thus forbidden in the print template function?</em></p>\n<p>That's why <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\"><code>constexpr</code></a> exists. They can be used where it's needed <em>compile-time evaluation</em>, thus available to be template-arguments.</p>\n<p><em>Is my guess about the string literals correct?</em></p>\n<p>There is a note about this right after the arguments:</p>\n<blockquote>\n<p id=\"so_28809728_28810559_2\">Note: A string literal (2.14.5) does not satisfy the requirements of any of these categories and thus is not\n  an acceptable template-argument.</p>\n</blockquote>\n", "LastActivityDate": "2015-03-02T13:39:33.287", "LastEditorUserId": "3658660", "Id": "28810559", "CommentCount": "0", "CreationDate": "2015-03-02T13:06:37.307", "ParentId": "28809728", "Score": "3", "OwnerUserId": "3658660", "LastEditDate": "2015-03-02T13:39:33.287"}});