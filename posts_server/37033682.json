post_cb({"37033859": {"ParentId": "37033682", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Yes, it's perfectly valid. From [expr.unary.op]:</p>\n<blockquote>\n<p id=\"so_37033682_37033859_0\">For purposes of pointer arithmetic (5.7) and comparison (5.9, 5.10), an object that is not an array element whose address is taken in this way is considered to belong to an array with one element of type <code>T</code>.</p>\n</blockquote>\n<p><code>&amp;i + 1</code> simply points to one past the end of that object, which for this purpose is one past the end of an array of size one of that type, which is a perfectly legal thing to refer to, according to [expr.add]:</p>\n<blockquote>\n<p id=\"so_37033682_37033859_1\">If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is\n  undefined.</p>\n</blockquote>\n<hr/>\n<p>As a side note, your <code>append()</code> function is a strictly worse implementation of your <code>init()</code> function. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-05-04T17:05:06.780", "Id": "37033859", "Score": "6", "CreationDate": "2016-05-04T16:59:09.597", "LastActivityDate": "2016-05-04T17:05:06.780"}, "bq_ids": {"n4140": {"so_37033682_37033859_1": {"section_id": 6142, "quality": 1.0, "length": 21}}, "n3337": {"so_37033682_37033859_1": {"section_id": 5906, "quality": 1.0, "length": 21}}, "n4659": {"so_37033682_37033859_0": {"section_id": 7562, "quality": 0.8888888888888888, "length": 16}, "so_37033682_37033859_1": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}}}, "37033682": {"CommentCount": "0", "ViewCount": "96", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-05-04T16:49:40.973", "LastActivityDate": "2016-05-04T17:05:06.780", "Title": "Append single element to container using iterator ranges", "AcceptedAnswerId": "37033859", "LastEditDate": "2016-05-04T17:04:20.250", "Id": "37033682", "Score": "2", "Body": "<p>I want to (copy) append single element to some (STL-like) container, but all I can use is <code>basic_string &amp; append(InputIt first, InputIt last)</code>-like interface to initialize or to append elements to the container.</p>\n<p>Is it wrong to do the following:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct container\n{\n\n    template&lt; typename input_iterator &gt;\n    void init(input_iterator const beg, input_iterator const end)\n    {\n        v.insert(v.cend(), beg, end);\n    }\n\n    template&lt; typename input_iterator &gt;\n    void append(input_iterator beg, input_iterator const end)\n    {\n        while (beg != end) {\n            v.push_back(*beg);\n            ++beg;\n        }\n    }\n\nprivate:\n    std::vector&lt; int &gt; v;\n};\n\n#include &lt;cstdlib&gt;\n\nint main()\n{\n    int i = 123;\n    container c;\n    c.init(&amp;i, &amp;i + 1);\n    int j = 555;\n    c.init(&amp;j, &amp;j + 1);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Specifically, I am concerned with whether the <code>f(&amp;i, &amp;i + 1)</code> construction is valid (assume unary <code>operator &amp;</code> is not overloaded) or not?</p>\n", "Tags": "<c++><stl><iterator><containers>", "OwnerUserId": "1430927", "AnswerCount": "1"}});