post_cb({"26081424": {"Id": "26081424", "PostTypeId": "2", "Body": "<p>The problem is somewhere in the template-template argument not actually creating a specialization. This is more clear if you declare the non-specialized version with just a <code>;</code> instead of an empty definition.</p>\n<p>The short answer is to not use template-template arguments; your code as written does not require them (or, in fact, any specialization at all of that template), and it is unlikely that you will ever see a case that needs them (in this case, it actually <em>harms</em> by eliminating possibly useful cases).</p>\n", "LastActivityDate": "2014-09-28T03:47:15.800", "CommentCount": "0", "CreationDate": "2014-09-28T03:47:15.800", "ParentId": "26081078", "Score": "0", "OwnerUserId": "1405588"}, "bq_ids": {"n4140": {"so_26081078_26081078_0": {"length": 21, "quality": 0.7, "section_id": 146}}, "n3337": {"so_26081078_26081078_0": {"length": 21, "quality": 0.7, "section_id": 140}}, "n4659": {"so_26081078_26081078_0": {"length": 21, "quality": 0.7, "section_id": 150}}}, "26081078": {"ViewCount": "63", "Body": "<p>i am trying to implement a generic queue fifo, but i cannot make any progress in trying to select the correct specialization class from the one defined as a base template class.\nHere is the code:\nThis code described first, a linked list implementation , so the class Node and the a enum class is defined to described the types of queue that is going to be used (linked list or fixed array), the first part (Node and GenericQueueType) work well, in the main function is defined first to do some test.\nThen the wrapper function that going to be used as a wrapper class is not selecting the partial specialization defined for use the linked list.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n//The node definition used for the linked list\n template&lt;typename ValueType&gt;\n struct Node_\n {\n    Node_(): NodePtr(nullptr)\n    {}\n    Node_(const ValueType &amp; aValue): _Value( aValue )\n       ,NodePtr(nullptr)\n    {\n\n    }\n     ValueType  _Value;\n    Node_ * NodePtr;\n};\n//====================\nenum class EQueueType\n{\n    EQueueType_Linked_List,\n    EQueueType_Fixed_Queue\n};\n//====================\ntemplate&lt;EQueueType,class ...  TypeValue&gt;\nstruct GenericQueueType\n{\n\n};\ntemplate&lt;class   TypeValue&gt;\nstruct GenericQueueType&lt;EQueueType::EQueueType_Linked_List, TypeValue&gt;\n{\n    GenericQueueType():TopPtr(nullptr)\n      ,BackPtr(nullptr)\n    {}\n\n    void insertValueInQueue(const TypeValue  &amp; aValue)\n    {\n       Node_&lt;TypeValue &gt; * aPtr=BackPtr;\n       BackPtr=new Node_&lt;TypeValue&gt;(aValue );\n       if(TopPtr==nullptr)\n       {\n            TopPtr=BackPtr;\n       }\n       else\n       {\n           BackPtr-&gt;NodePtr=aPtr;\n       }\n    }\n\n\n    void getValueFromQueue(TypeValue  &amp;  aValue)\n    {\n        //aErrorcode=ERROR_PROCESS;\n        if (TopPtr!=nullptr)\n        {\n           Node_&lt;TypeValue &gt; * aPtr= TopPtr;\n            aValue=aPtr-&gt;_Value;\n             aPtr-&gt;_Value ;\n           TopPtr=TopPtr-&gt;NodePtr;\n            delete TopPtr;\n           TopPtr=nullptr;\n        }\n    }\n\nprivate:\nstatic const int ERROR_PROCESS = -1;\nstatic const int OK_ERROR_CODE = 0;\n  Node_ &lt;TypeValue &gt; * TopPtr;\n  Node_ &lt;TypeValue &gt; * BackPtr;\n\n\n};\n//base queue wrapper\n\ntemplate&lt;typename  QueueType, typename  ... Element&gt;\nclass QueueFIFO\n{\n};\n\ntemplate&lt; template&lt;typename  ... &gt; class QueueType,typename   EQ_type,typename  ... TypeElement &gt;\nclass QueueFIFO&lt;QueueType&lt;EQ_type,TypeElement  ...&gt;,EQ_type,TypeElement ... &gt;\n{\n\n\n    using value_type = typename std::tuple&lt;TypeElement...&gt;;\n    static const int INITIAL_SIZE=0;\npublic:\n    QueueFIFO():_Size(INITIAL_SIZE)\n    {}\n\n    void enqueue(const value_type  &amp;  aElement)\n    {\n            Queue.insertValueInQueue(aElement);\n    }\n\n    void dequeue( value_type   &amp; aElement)\n    {\n        Queue.getValueFromQueue(aElement);\n    }\n    int size(){}\n\nprivate:\n    int _Size;\n    QueueType&lt;EQ_type,TypeElement  ...&gt; Queue;\n\n\n};\n\n\n\nint main()\n{\n     float aElement=14;\n    GenericQueueType&lt;EQueueType::EQueueType_Linked_List,float&gt; aLinkedList;\n    aLinkedList.insertValueInQueue(aElement);\n    QueueFIFO&lt;GenericQueueType&lt;EQueueType::EQueueType_Linked_List,float&gt;,float&gt; _Queue;\n    _Queue.enqueue(aElement);\n\n    return 0;\n}\n</code></pre>\n<p>Here is the compiler outs:</p>\n<pre><code>error: 'class QueueFIFO&lt;GenericQueueType&lt;(EQueueType)0, float&gt;, float&gt;' has no member named 'enqueue'\n     _Queue.enqueue(aElement);\n            ^\n</code></pre>\n<p>I have been reading this from the standart:</p>\n<blockquote>\n<p id=\"so_26081078_26081078_0\">In a type name that refers to a class template specialization, (e.g.,\n  A) the argument list shall match the template parameter\n  list of the primary template. The template arguments of a\n  specialization are deduced from the arguments of the primary template.\n  14.5.5.1\n  But still i cannot see the error.\n  Thx in advance!</p>\n</blockquote>\n", "Title": "c++11 template argument ,wrong partial specialitzation from base definition", "CreationDate": "2014-09-28T02:33:21.880", "LastActivityDate": "2014-09-28T03:53:49.017", "CommentCount": "1", "LastEditDate": "2014-09-28T02:46:22.903", "PostTypeId": "1", "LastEditorUserId": "696811", "Id": "26081078", "Score": "0", "OwnerUserId": "696811", "Tags": "<c++><templates><c++11>", "AnswerCount": "2"}, "26081290": {"Id": "26081290", "PostTypeId": "2", "Body": "<p><code>enqueue</code> defined in your partial specialization of <code>QueueFIFO</code> takes a <code>const &amp; value_type</code> where <code>value_type</code> is <code>std::tuple</code>. You are trying to call it with <code>aElement</code> which is a <code>float</code>, while you should be passing it a <code>std::tuple&lt;float&gt;</code>. Try passing <code>std::make_tuple(aElement)</code> to <code>enqueue</code>.</p>\n<p>Also, as T.C. pointed out in the comments, the places you are using <code>typename EQ_type</code> and passing in an enum value of type <code>EQueueType</code> are erroneous - an enum value will not match a template type argument. You will have to use non-type arguments for that, as you have done in the definition of <code>GenericQueueType</code>.</p>\n", "LastEditorUserId": "862351", "LastActivityDate": "2014-09-28T03:53:49.017", "Score": "0", "CreationDate": "2014-09-28T03:22:30.677", "ParentId": "26081078", "CommentCount": "0", "OwnerUserId": "862351", "LastEditDate": "2014-09-28T03:53:49.017"}});