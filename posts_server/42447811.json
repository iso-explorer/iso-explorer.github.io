post_cb({"42447936": {"ParentId": "42447811", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>If the type is standard-layout, then a pointer to the containing struct at any level of inheritance is equal to a pointer to the first element.  By transitivity, the pointers to all levels of inheritance are also the same -- and the Standard goes ahead and also makes this guarantee in the odd case when no non-static data members exist.</p>\n<p>(Note that to be standard-layout, a type can introduce data members at only one level in the inheritance diagram -- further subclasses can add functions and remain standard layout, but cannot add more data).</p>\n<p>If the type is not standard-layout, then no guarantees are made and you must use <code>static_cast</code>, not <code>reinterpret_cast</code> (nor reinterpret_cast equivalents such as multiple static_cast with <code>void*</code> as an intermediate) to properly include any offset.</p>\n<p>All POD types are of course standard-layout, PODness requires both standard-layout and triviality.</p>\n<p>The exact rule I'm explaining is found in section 9.2:</p>\n<blockquote>\n<p id=\"so_42447811_42447936_0\">If a standard-layout class object has any non-static data members, its address is the same as the address of its first non-static data member. Otherwise, its address is the same as the address of its first base class subobject (if any).</p>\n<p id=\"so_42447811_42447936_1\">[ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014 end note ]</p>\n<p id=\"so_42447811_42447936_2\">[ Note: The object and its first subobject are pointer-interconvertible. \u2014 end note ]</p>\n</blockquote>\n<p>The rule that explicitly states that odd layouts are possible for types which are non standard-layout is in section 10:</p>\n<blockquote>\n<p id=\"so_42447811_42447936_3\">The order in which the base class subobjects are allocated in the most derived object is unspecified.</p>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2017-02-24T22:18:08.693", "Id": "42447936", "Score": "3", "CreationDate": "2017-02-24T20:43:20.513", "LastActivityDate": "2017-02-24T22:18:08.693"}, "42447811": {"CommentCount": "3", "ViewCount": "137", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2017-02-24T20:35:43.153", "LastActivityDate": "2017-02-24T22:18:08.693", "Title": "Is a pointer allowed to change value in single inheritance?", "FavoriteCount": "1", "LastEditDate": "2017-02-24T20:37:26.823", "Id": "42447811", "Score": "6", "Body": "<p>I know that with multiple inheritance the value of a pointer is allowed to change. But is that the case with single inheritance too? Or with POD types for that matter?</p>\n<p>You probably know the classic example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nstruct Base1 { virtual void f1() {} };\nstruct Base2 { virtual void f2() {} };\nstruct Derived : public Base1, public Base2 { virtual void g() {} };\nint main() {\n    Derived d{};\n    auto *pd = &amp;d;\n    auto pb1 = (Base1*)pd;\n    auto pb2 = (Base2*)pd;\n    cout &lt;&lt; pd &lt;&lt; \"\\n\"; // say, 0x1000\n    cout &lt;&lt; pb1 &lt;&lt; \"\\n\"; // say, 0x1000\n    cout &lt;&lt; pb2 &lt;&lt; \"\\n\"; // say, 0x1008 !!!\n}\n</code></pre>\n<p>So far so good and that is good old compiler practice. The objects are layed out in a way that the \"root\" of <code>Base2</code> has an offset to <code>Derived</code> which can be printed when looking at the actual pointer value. This not a problem when refraining from doing <code>void*</code> and <code>reinterpret_cast</code>s.</p>\n<p>And as far as I know in practice this occurs only with multiple inheritance.</p>\n<p>But my question: What does the standard say about \"pointer changing values during cast\"? Can this happen <em>only</em> with multiple inheritance or can that also happen with single inheritance, or casting PODs?</p>\n", "Tags": "<c++><pointers><casting><language-lawyer><multiple-inheritance>", "OwnerUserId": "472245", "AnswerCount": "2"}, "42448309": {"ParentId": "42447811", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_42447811_42448309_0\">Is a pointer allowed to change value in single inheritance?</p>\n</blockquote>\n<p>I am not able to find anything in the standard that would prevent an implementation from doing that.</p>\n<p>I found the following in the C++11 standard that are related to conversion of pointers between pointers to base classes and derived classes:</p>\n<blockquote>\n<p id=\"so_42447811_42448309_1\"><strong>4.10 Pointer conversion</strong></p>\n<p id=\"so_42447811_42448309_2\">3 A prvalue of type \u201cpointer to <em>cv</em> <code>D</code>\u201d, where <code>D</code> is a class type, can be converted to a prvalue of type \u201cpointer to <em>cv</em> <code>B</code>\u201d, where <code>B</code> is a base class (Clause 10) of <code>D</code>. If <code>B</code> is an inaccessible (Clause 11) or ambiguous (10.2) base class of <code>D</code>, a program that necessitates this conversion is ill-formed. The result of the conversion is a pointer to the base class subobject of the derived class object. The null pointer value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_42447811_42448309_3\"><strong>5.2.9 Static cast</strong></p>\n<p id=\"so_42447811_42448309_4\">2 An lvalue of type \u201c<em>cv1</em> <code>B</code>,\u201d where <code>B</code> is a class type, can be cast to type \u201creference to <em>cv2</em> <code>D</code>,\u201d where <code>D</code> is a class derived (Clause 10) from <code>B</code>, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code> is neither a virtual base class of <code>D</code> nor a base class of a virtual base class of <code>D</code>. The result has type \u201c<em>cv2</em> <code>D</code>.\u201d An xvalue of type \u201c<em>cv1</em> <code>B</code>\u201d may be cast to type \u201crvalue reference to <em>cv2</em> <code>D</code>\u201d with the same constraints as for an lvalue of type \u201c<em>cv1</em> <code>B</code>.\u201d If the object of type \u201c<em>cv1</em> <code>B</code>\u201d is actually a subobject of an object of type <code>D</code>, the result refers to the enclosing object of type <code>D</code>. Otherwise, the result of the cast is undefined. [ <em>Example:</em></p>\n<pre><code>struct B { };\nstruct D : public B { };\nD d;\nB &amp;br = d;\nstatic_cast&lt;D&amp;&gt;(br); // produces lvalue to the original d object\n</code></pre>\n<p id=\"so_42447811_42448309_5\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<hr>\n<p>Given</p>\n<pre><code>class B { ... };\nclass D : public B { ... };\n</code></pre>\n<p>An implementation is free to choose the following layout:</p>\n<pre><code>+------------------+\n|  D members       |\n+------------------+\n|  B members       |\n+------------------+\n</code></pre>\n<p>as long as it does the right thing when converting pointers and references.</p>\n<p>In such an implementation,</p>\n<pre><code>D d;\nD* dptr = &amp;d;\nB* bptr = &amp;d;\n</code></pre>\n<p>The values of <code>dptr</code> and <code>bptr</code> are going to be different.</p>\n</hr>", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "42448309", "Score": "2", "CreationDate": "2017-02-24T21:08:46.277", "LastActivityDate": "2017-02-24T21:08:46.277"}, "bq_ids": {"n4140": {"so_42447811_42448309_2": {"section_id": 41, "quality": 0.9318181818181818, "length": 41}, "so_42447811_42447936_0": {"section_id": 5879, "quality": 1.0, "length": 25}, "so_42447811_42448309_4": {"section_id": 6028, "quality": 0.8082191780821918, "length": 59}, "so_42447811_42447936_1": {"section_id": 5879, "quality": 0.8421052631578947, "length": 16}, "so_42447811_42447936_3": {"section_id": 6978, "quality": 0.9, "length": 9}}, "n3337": {"so_42447811_42448309_2": {"section_id": 38, "quality": 0.9318181818181818, "length": 41}, "so_42447811_42448309_4": {"section_id": 5796, "quality": 0.8356164383561644, "length": 61}, "so_42447811_42447936_1": {"section_id": 5650, "quality": 0.8421052631578947, "length": 16}, "so_42447811_42447936_3": {"section_id": 6724, "quality": 0.9, "length": 9}}, "n4659": {"so_42447811_42448309_4": {"section_id": 7527, "quality": 0.6712328767123288, "length": 49}, "so_42447811_42447936_2": {"section_id": 7363, "quality": 0.5555555555555556, "length": 5}, "so_42447811_42447936_0": {"section_id": 7363, "quality": 1.0, "length": 25}, "so_42447811_42448309_2": {"section_id": 41, "quality": 0.9318181818181818, "length": 41}, "so_42447811_42447936_1": {"section_id": 7363, "quality": 0.8421052631578947, "length": 16}, "so_42447811_42447936_3": {"section_id": 8477, "quality": 0.9, "length": 9}}}});