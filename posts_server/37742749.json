post_cb({"37743365": {"ParentId": "37742749", "CommentCount": "1", "Body": "<p>Your example is not identical to the one in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#287\" rel=\"nofollow\">defect report</a>. In the defect report, <code>CL</code> is a class template. However the intent of  the proposed resolution is to make the template case the same as the non-template one, aka <a href=\"http://eel.is/c++draft/basic.scope.pdecl\" rel=\"nofollow\">[basic.scope.pdecl]</a>:</p>\n<blockquote>\n<p id=\"so_37742749_37743365_0\">6 After the point of declaration of a class member, the member name\n  can be looked up in the scope of its class. [ <em>Note:</em> this is true\n  even if the class is an incomplete class. For example,</p>\n<pre><code>struct X {\n  enum E { z = 16 };\n  int b[X::z];      // OK\n};\n</code></pre>\n<p id=\"so_37742749_37743365_1\">\u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Then the proposed resolution:</p>\n<blockquote>\n<p id=\"so_37742749_37743365_2\">In 14.6.4.1 [temp.point] paragraph 3 change:</p>\n<p id=\"so_37742749_37743365_3\">the point of instantiation is immediately before the point of\n  instantiation of the enclosing template. Otherwise, the point of\n  instantiation for such a specialization immediately precedes the\n  namespace scope declaration or definition that refers to the\n  specialization. </p>\n<p id=\"so_37742749_37743365_4\">To:</p>\n<p id=\"so_37742749_37743365_5\">the point of instantiation is <strong>the same</strong> as the point of\n  instantiation of the enclosing template. Otherwise, the point of\n  instantiation for such a specialization immediately precedes the\n  <strong>nearest enclosing declaration. [Note: The point of instantiation is still at namespace scope but any declarations preceding the point of\n  instantiation, even if not at namespace scope, are considered to have\n  been seen.]</strong></p>\n<p id=\"so_37742749_37743365_6\">Add following paragraph 3:</p>\n<p id=\"so_37742749_37743365_7\">If an implicitly instantiated class template specialization, class\n  member specialization, or specialization of a class template\n  references a class, class template specialization, class member\n  specialization, or specialization of a class template containing a\n  specialization reference that directly or indirectly caused the\n  instantiation, the requirements of completeness and ordering of the\n  class reference are applied in the context of the specialization\n  reference.</p>\n</blockquote>\n<p>As of the latest <a href=\"http://eel.is/c++draft/temp.point#4\" rel=\"nofollow\">draft</a>, the non-template case was and is still valid. The template case is not. However the defect is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#Issue%20Status\" rel=\"nofollow\">drafting</a>, which means that the template case is intended to compile.</p>\n<blockquote>\n<p id=\"so_37742749_37743365_8\"><strong>Drafting:</strong> Informal consensus has been reached in the working group and is described in rough terms in a Tentative Resolution, although\n  precise wording for the change is not yet available.</p>\n</blockquote>\n", "OwnerUserId": "6292850", "PostTypeId": "2", "Id": "37743365", "Score": "2", "CreationDate": "2016-06-10T08:22:53.430", "LastActivityDate": "2016-06-10T08:22:53.430"}, "37742749": {"CommentCount": "4", "ViewCount": "178", "CreationDate": "2016-06-10T07:47:52.830", "LastActivityDate": "2016-06-10T08:22:53.430", "Title": "Point of instantiation of a template class", "AcceptedAnswerId": "37743365", "PostTypeId": "1", "Id": "37742749", "Score": "7", "Body": "<p>Could that code to be compile?</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct TMPL\n{\n    using TP = typename T::TP; //is CL::TP visible (with T == CL)?\n};\n\nstruct CL\n{\n    using TP = int;\n    TMPL&lt;CL&gt;::TP val; \n};\n\nint main()\n{\n    CL cl;\n}\n</code></pre>\n<p>TMPL is instantiated immediately before CL class definition according to Standard 14.6.4.1/4</p>\n<blockquote>\n<p id=\"so_37742749_37742749_0\">For a class template specialization, ..., if the specialization is\n  implicitly instantiated because it is referenced from within another\n  template specialization, .... <strong>Otherwise, the point of instantiation\n  for such a specialization immediately precedes the namespace scope\n  declaration or definition that refers to the specialization.</strong></p>\n</blockquote>\n<p>So, CL::TP isn't visible in TMPL instantiation point, but all the compilers (MSVC, gcc, clang) compile it fine. I also has found a defect report <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#287\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#287</a>, but it, apparently, wasn't accepted</p>\n", "Tags": "<c++><templates><c++14><instantiation><name-resolution>", "OwnerUserId": "3514538", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37742749_37743365_0": {"section_id": 7054, "quality": 0.9, "length": 18}, "so_37742749_37743365_3": {"section_id": 219, "quality": 1.0, "length": 21}, "so_37742749_37742749_0": {"section_id": 219, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_37742749_37743365_0": {"section_id": 6798, "quality": 0.9, "length": 18}, "so_37742749_37743365_3": {"section_id": 212, "quality": 1.0, "length": 21}, "so_37742749_37742749_0": {"section_id": 212, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_37742749_37743365_0": {"section_id": 8551, "quality": 0.9, "length": 18}, "so_37742749_37742749_0": {"section_id": 227, "quality": 0.9615384615384616, "length": 25}, "so_37742749_37743365_3": {"section_id": 227, "quality": 1.0, "length": 21}}}});