post_cb({"bq_ids": {"n4140": {"so_15059250_15059275_0": {"length": 12, "quality": 1.0, "section_id": 3913}}, "n3337": {"so_15059250_15059275_0": {"length": 12, "quality": 1.0, "section_id": 3773}}, "n4659": {"so_15059250_15059275_0": {"length": 9, "quality": 0.75, "section_id": 4799}}}, "15059250": {"ViewCount": "310", "Body": "<p>I want to make a function object which takes arbitrary function objects and returns a tuple which stores the return value of each function object. </p>\n<p>To achieve this goal, I made a <code>class A</code></p>\n<pre><code>class A\n{\nprivate:\n    template &lt;class Ret, class Func&gt;\n    auto impl(Ret ret, Func func) -&gt; decltype(tuple_cat(ret, make_tuple(func())))\n    {\n        return tuple_cat(ret, make_tuple(func()));\n    }\n\n    template &lt;class Ret, class First, class... Funcs&gt;\n    auto impl(Ret ret, First first, Funcs... funcs) \n    -&gt; decltype(impl(tuple_cat(ret, make_tuple(first())), funcs...))\n    {\n    return impl(tuple_cat(ret, make_tuple(first())), funcs...);\n    }\n\npublic:\n    template &lt;class Func&gt;\n    auto operator()(Func func) -&gt; decltype(make_tuple(func()))\n        {\n        return make_tuple(func());\n    }\n\n    template &lt;class First, class... Funcs&gt;\n    auto operator()(First first, Funcs... funcs)\n     -&gt; decltype(impl(make_tuple(first()),funcs...))\n    {\n        impl(make_tuple(first()),funcs...);\n    }\n};\n</code></pre>\n<p>And in the main function, I made three lambdas.</p>\n<pre><code>int main(){\n    auto func1 = [](){ cout &lt;&lt; 1 &lt;&lt; endl; return 1;};\n    auto func2 = [](){ cout &lt;&lt; 2 &lt;&lt; endl; return 2;};\n    auto func3 = [](){ cout &lt;&lt; 3 &lt;&lt; endl; return 3;};\n\n    A a;\n    auto x = a(func1, func2);\n    cout &lt;&lt; \"ans : \" &lt;&lt; get&lt;0&gt;(x) &lt;&lt; get&lt;1&gt;(x) &lt;&lt; endl; // I expect ans : 12\n}\n</code></pre>\n<p>This code can be compiled by gcc 4.7.2. However, it doesn't work as I expected.\nHow should I modify this code?</p>\n", "AcceptedAnswerId": "15059275", "Title": "Make variadic function which takes arbitary functors and returns a tuple of each return value of input functors", "CreationDate": "2013-02-25T02:35:47.873", "Id": "15059250", "CommentCount": "2", "LastEditDate": "2014-07-13T20:36:34.800", "PostTypeId": "1", "LastEditorUserId": "759866", "LastActivityDate": "2014-07-13T20:36:34.800", "Score": "1", "OwnerUserId": "1120977", "Tags": "<c++><c++11><tuples><variadic-templates>", "AnswerCount": "3"}, "15059312": {"Id": "15059312", "PostTypeId": "2", "Body": "<p>The obvious problem is that you've a missing return statement as pointed out by other answer.</p>\n<p>Anyway, I think you have done too much. This should work:</p>\n<pre><code>class A\n{\npublic:\n    template &lt;class First, class... Funcs&gt;\n    auto operator()(First first, Funcs... funcs) -&gt; decltype((make_tuple(first(),funcs()...)))\n    {\n        return (make_tuple(first(),funcs()...));\n    }\n};\n\nint main(){\n    auto func1 = [](){ cout &lt;&lt; 1 &lt;&lt; endl; return 1;};\n    auto func2 = [](){ cout &lt;&lt; 2 &lt;&lt; endl; return 2;};\n\n    A a;\n    auto x = a(func1, func2);\n    cout &lt;&lt; \"ans : \" &lt;&lt; get&lt;0&gt;(x) &lt;&lt; get&lt;1&gt;(x) &lt;&lt; endl; // I expect ans : 12\n}\n</code></pre>\n<p><a href=\"http://stacked-crooked.com/view?id=4495a718a494a626e57f5e915473c3dc\" rel=\"nofollow\">Online Demo</a></p>\n", "LastActivityDate": "2013-02-25T02:45:10.103", "CommentCount": "2", "CreationDate": "2013-02-25T02:45:10.103", "ParentId": "15059250", "Score": "1", "OwnerUserId": "415784"}, "15059275": {"Id": "15059275", "PostTypeId": "2", "Body": "<p>I think the problem is that you're missing a <code>return</code> statement:</p>\n<pre><code>template &lt;class First, class... Funcs&gt;\nauto operator()(First first, Funcs... funcs)\n -&gt; decltype(impl(make_tuple(first()),funcs...))\n{\n    return impl(make_tuple(first()),funcs...);\n//  ^^^^^^\n}\n</code></pre>\n<p>Without it, your code has Undefined Behavior. Per Paragraph 6.6.3/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15059250_15059275_0\">[...] Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>\n</blockquote>\n", "LastActivityDate": "2013-02-25T02:39:53.270", "CommentCount": "2", "CreationDate": "2013-02-25T02:39:53.270", "ParentId": "15059250", "Score": "2", "OwnerUserId": "1932150"}, "15059318": {"Id": "15059318", "PostTypeId": "2", "Body": "<p>@Andy's fix works, but you can do it <em>a lot</em> simpler than that, without implementing overloads nor helper functions:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\ntemplate&lt;typename... Args&gt;\nauto tuple_from_funs(Args&amp;&amp;... args) -&gt; std::tuple&lt;decltype(args())...&gt;{\n    return std::make_tuple(args()...);\n}\n\nint f() { return 1; }\nchar g() { return '2'; }\nstd::string h() { return \"jorge\"; }\n\nint main() {\n    auto tup = tuple_from_funs(f, g, h);\n    std::cout &lt;&lt; std::get&lt;0&gt;(tup) &lt;&lt; \", \" &lt;&lt; std::get&lt;1&gt;(tup) &lt;&lt; \", \" &lt;&lt; std::get&lt;2&gt;(tup) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Demo <a href=\"http://ideone.com/bgV2Ad\" rel=\"nofollow\">here</a>.</p>\n", "LastActivityDate": "2013-02-25T02:46:20.483", "CommentCount": "2", "CreationDate": "2013-02-25T02:46:20.483", "ParentId": "15059250", "Score": "1", "OwnerUserId": "525217"}});