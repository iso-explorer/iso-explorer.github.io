post_cb({"17399047": {"ParentId": "17398959", "PostTypeId": "2", "CommentCount": "24", "Body": "<p><code>s.length()</code> is unsigned integer type. When you subtract 3, you make it negative. For an <code>unsigned</code>, it means <em>very big</em>.</p>\n<p>A workaround (valid as long the string is long up to INT_MAX) would be to do like this:</p>\n<pre><code>#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n\n    string s = \"aa\";\n\n    for (int i = 0; i &lt; static_cast&lt;int&gt; (s.length() ) - 3; i++) {\n\n    }\n}\n</code></pre>\n<p>Which would never enter the loop.</p>\n<p>A very important detail is that you have probably received a warning \"comparing signed and unsigned value\". The problem is that if you ignore those warnings, you enter the very dangerous field of <em>implicit</em> <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\">\"integer conversion\"</a><sup>(*)</sup>, which has a defined behaviour, but it is difficult to follow: the best is to never ignore those compiler warnings.</p>\n<p><hr>\n<sub>(*) You might also be interested to know about <a href=\"http://msdn.microsoft.com/en-us/library/a170dhzf.aspx\">\"integer promotion\"</a>.</sub></hr></p>\n", "OwnerUserId": "2436175", "LastEditorUserId": "2436175", "LastEditDate": "2013-07-08T09:29:34.113", "Id": "17399047", "Score": "84", "CreationDate": "2013-07-01T07:05:39.510", "LastActivityDate": "2013-07-08T09:29:34.113"}, "17399015": {"ParentId": "17398959", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The type of s.length() is <code>size_t</code> with a value of 2, therefore s.length() - 3 is also an unsigned type <code>size_t</code> and it has a value of <code>SIZE_MAX</code> which is implementation defined (which is 18446744073709551615 if its size is 64 bit). It is at least 32 bit type (can be 64 bit in 64 bit platforms) and this high number means an indefinite loop. In order to prevent this problem you can simply cast <code>s.length()</code> to <code>int</code>:</p>\n<pre><code>for (int i = 0; i &lt; (int)s.length() - 3; i++)\n{\n          //..some code causing crash\n}\n</code></pre>\n<p>In the second case <code>len</code> is -1 because it is a <code>signed integer</code> and it does not enter the loop.</p>\n<p>When it comes to crashing, this \"infinite\" loop is not the direct cause of the crash. If you share the code within the loop you can get further explanation.</p>\n", "OwnerUserId": "2183287", "LastEditorUserId": "2183287", "LastEditDate": "2013-07-03T05:00:11.173", "Id": "17399015", "Score": "3", "CreationDate": "2013-07-01T07:03:55.477", "LastActivityDate": "2013-07-03T05:00:11.173"}, "17404016": {"ParentId": "17398959", "CommentCount": "3", "Body": "<p>Since s.length() is unsigned type quantity, when you do s.length()-3, it becomes negative and negative values are stored as large positive values (due to unsigned conversion specifications) and the loop goes infinite and hence it crashes.</p>\n<p>To make it work, you must typecast the s.length() as :</p>\n<p>static_cast &lt; int &gt; (s.length())</p>\n", "OwnerUserId": "1599882", "PostTypeId": "2", "Id": "17404016", "Score": "1", "CreationDate": "2013-07-01T12:00:58.333", "LastActivityDate": "2013-07-01T12:00:58.333"}, "17399027": {"ParentId": "17398959", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Actually, in the first version you loop for a very long time, as you compare <code>i</code> to an <em>unsigned</em>  integer containing a very large number. The size of a string is (in effect) the same as <code>size_t</code> which is an unsigned integer. When you subtract the <code>3</code> from that value it underflows and goes on to be a big value.</p>\n<p>In the second version of the code, you assign this unsigned value to a signed variable, and so you get the correct value.</p>\n<p>And it's not actually the condition or the value that causes the crash, it's most likely that you index the string out of bounds, a case of undefined behavior.</p>\n", "OwnerUserId": "440558", "LastEditorUserId": "440558", "LastEditDate": "2013-07-02T06:58:20.110", "Id": "17399027", "Score": "12", "CreationDate": "2013-07-01T07:04:33.340", "LastActivityDate": "2013-07-02T06:58:20.110"}, "29199659": {"ParentId": "17398959", "CommentCount": "0", "Body": "<p>The reason is the same as \nint a = 1000000000;\nlong long b = a * 100000000; would give error. When compilers multiplies these numbers it evaluates it as ints, since a and literal 1000000000 are ints, and since 10^18 is much more large than the upper bound of int, it will give error.\nIn your case we have s.length() - 3, as s.length() is unsigned int, it cant be negative, and since s.length() - 3 is evaluated as unsigned int, and its value is -1, it gives error here too.</p>\n", "OwnerUserId": "4414772", "PostTypeId": "2", "Id": "29199659", "Score": "0", "CreationDate": "2015-03-22T20:48:17.290", "LastActivityDate": "2015-03-22T20:48:17.290"}, "17437214": {"ParentId": "17398959", "PostTypeId": "2", "CommentCount": "4", "Body": "<h2>Assuming you left out important code in the <code>for</code> loop</h2>\n<p>Most people here seem unable to reproduce the crash\u2014myself included\u2014and it looks like the other answers here are based on the assumption that you left out some important code in the body of the <code>for</code> loop, and that the missing code is what is causing your crash.</p>\n<p>If you are using <code>i</code> to access memory (presumably characters in the string) in the body of the <code>for</code> loop, and you left that code out of your question in an attempt to provide a minimal example, then the crash is easily explained by the fact that <code>s.length() - 3</code> has the value <code>SIZE_MAX</code> due to modular arithmetic on unsigned integer types.  <code>SIZE_MAX</code> is a very big number, so <code>i</code> will keep getting bigger until it is used to access an address that triggers a segfault.</p>\n<p>However, your code could theoretically crash as-is, even if the body of the <code>for</code> loop is empty.  I am unaware of any implementations that would crash, but maybe your compiler and CPU are exotic.</p>\n<p>The following explanation does not assume that you left out code in your question.  It takes on faith that the code you posted in your question crashes as-is; that it isn't an abbreviated stand-in for some other code that crashes.</p>\n<h2>Why your first program crashes</h2>\n<p>Your first program crashes because that is its reaction to undefined behavior in your code.  (When I try running your code, it terminates without crashing because that is my implementation's reaction to the undefined behavior.)</p>\n<p>The undefined behavior comes from overflowing an <code>int</code>.  The C++11 standard says (in [expr] clause 5 paragraph 4):</p>\n<blockquote>\n<p id=\"so_17398959_17437214_0\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p>\n</blockquote>\n<p>In your example program, <code>s.length()</code> returns a <code>size_t</code> with value 2.  Subtracting 3 from that would yield negative 1, except <code>size_t</code> is an unsigned integer type.  The C++11 standard says (in [basic.fundamental] clause 3.9.1 paragraph 4):</p>\n<blockquote>\n<p id=\"so_17398959_17437214_1\">Unsigned integers, declared <code>unsigned</code>, shall obey the laws of arithmetic modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.<sup>46</sup></p>\n<p id=\"so_17398959_17437214_2\">46) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n<p>This means that the result of <code>s.length() - 3</code> is a <code>size_t</code> with value <code>SIZE_MAX</code>.  This is a very big number, bigger than <code>INT_MAX</code> (the largest value representable by <code>int</code>).</p>\n<p>Because <code>s.length() - 3</code> is so big, execution spins in the loop until <code>i</code> gets to <code>INT_MAX</code>.  On the very next iteration, when it tries to increment <code>i</code>, the result would be <code>INT_MAX</code> + 1 but that is not in the range of representable values for <code>int</code>.  Thus, the behavior is undefined.  In your case, the behavior is to crash.</p>\n<p>On my system, my implementation's behavior when <code>i</code> is incremented past <code>INT_MAX</code> is to wrap (set <code>i</code> to <code>INT_MIN</code>) and keep going.  Once <code>i</code> reaches -1, the usual arithmetic conversions (C++ [expr] clause 5 paragraph 9) cause <code>i</code> to equal <code>SIZE_MAX</code> so the loop terminates.</p>\n<p>Either reaction is appropriate.  That is the problem with undefined behavior\u2014it might work as you intend, it might crash, it might format your hard drive, or it might cancel Firefly.  You never know.</p>\n<h2>How your second program avoids the crash</h2>\n<p>As with the first program, <code>s.length() - 3</code> is a <code>size_t</code> type with value <code>SIZE_MAX</code>.  However, this time the value is being assigned to an <code>int</code>.  The C++11 standard says (in [conv.integral] clause 4.7 paragraph 3):</p>\n<blockquote>\n<p id=\"so_17398959_17437214_3\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>The value <code>SIZE_MAX</code> is too big to be representable by an <code>int</code>, so <code>len</code> gets an implementation-defined value (probably -1, but maybe not).  The condition <code>i &lt; len</code> will eventually be true regardless of the value assigned to <code>len</code>, so your program will terminate without encountering any undefined behavior.</p>\n", "OwnerUserId": "712605", "LastEditorUserId": "712605", "LastEditDate": "2013-07-07T17:13:20.393", "Id": "17437214", "Score": "5", "CreationDate": "2013-07-02T23:03:16.233", "LastActivityDate": "2013-07-07T17:13:20.393"}, "17398959": {"CommentCount": "16", "CreationDate": "2013-07-01T06:59:03.830", "PostTypeId": "1", "AcceptedAnswerId": "17399047", "LastEditorUserId": "63550", "LastActivityDate": "2015-03-22T20:48:17.290", "LastEditDate": "2013-07-08T07:33:31.420", "ViewCount": "4530", "FavoriteCount": "9", "Title": "C++ crashes in a 'for' loop with a negative expression", "Id": "17398959", "Score": "55", "Body": "<p>The following code crashes C++ with a runtime error:</p>\n<pre><code>#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    string s = \"aa\";\n    for (int i = 0; i &lt; s.length() - 3; i++) {\n\n    }\n}\n</code></pre>\n<p>While this code does not crash:</p>\n<pre><code>#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    string s = \"aa\";\n    int len = s.length() - 3;\n    for (int i = 0; i &lt; len; i++) {\n\n    }\n}\n</code></pre>\n<p>I just don't have any idea how to explain it. What could be the reason for this behavior?</p>\n", "Tags": "<c++>", "OwnerUserId": "2534633", "AnswerCount": "8"}, "17400210": {"ParentId": "17398959", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>First of all: <em>why</em> does it crash? Let's step through your program like a debugger would.</p>\n<p>Note: I'll assume that your loop body isn't empty, but accesses the string. If this isn't the case, the cause of the crash is <em>undefined behaviour</em> through integer overflow. See Richard Hansens answer for that.</p>\n<pre><code>std::string s = \"aa\";//assign the two-character string \"aa\" to variable s of type std::string\nfor ( int i = 0; // create a variable i of type int with initial value 0 \ni &lt; s.length() - 3 // call s.length(), subtract 3, compare the result with i. OK!\n{...} // execute loop body\ni++ // do the incrementing part of the loop, i now holds value 1!\ni &lt; s.length() - 3 // call s.length(), subtract 3, compare the result with i. OK!\n{...} // execute loop body\ni++ // do the incrementing part of the loop, i now holds value 2!\ni &lt; s.length() - 3 // call s.length(), subtract 3, compare the result with i. OK!\n{...} // execute loop body\ni++ // do the incrementing part of the loop, i now holds value 3!\n.\n.\n</code></pre>\n<p>We would expect the check <code>i &lt; s.length() - 3</code> to fail right away, since the length of <code>s</code> is two (we only every given it a length at the beginning and never changed it) and <code>2 - 3</code> is <code>-1</code>, <code>0 &lt; -1</code> is false. However we do get an \"OK\" here.</p>\n<p>This is because <code>s.length()</code> isn't <code>2</code>. It's <code>2u</code>. <code>std::string::length()</code> has return type <code>size_t</code> which is an unsigned integer. So going back to the loop condition, we first get the value of <code>s.length()</code>, so <code>2u</code>, now subtract <code>3</code>. <code>3</code> is an integer literal and interpreted by the compiler as type <code>int</code>. So the compiler has to calculate <code>2u - 3</code>, two values of different types. Operations on primitive types only work for same types, so one has to be converted into the other. There are some strict rules, in this case, <code>unsigned</code> \"wins\", so <code>3</code> get's converted to <code>3u</code>. In unsigned integers, <code>2u - 3u</code> can't be <code>-1u</code> as such a number does not exists (well, because it has a sign of course!). Instead it calculates every operation <code>modulo 2^(n_bits)</code>, where <code>n_bits</code> is the number of bits in this type (usually 8, 16, 32 or 64). So instead of <code>-1</code> we get <code>4294967295u</code> (assuming 32bit).</p>\n<p>So now the compiler is done with <code>s.length() - 3</code> (of course it's much much faster than me ;-) ), now let's go for the comparison: <code>i &lt; s.length() - 3</code>. Putting in the values: <code>0 &lt; 4294967295u</code>. Again, different types, <code>0</code> becomes <code>0u</code>, the comparison <code>0u &lt; 4294967295u</code> is obviously true, the loop condition is positively checked, we can now execute the loop body.</p>\n<p>After incrementing, the only thing that changes in the above is the value of <code>i</code>. The value of <code>i</code> will again be converted into an unsigned int, as the comparison needs it.</p>\n<p>So we have </p>\n<pre><code>(0u &lt; 4294967295u) == true, let's do the loop body!\n(1u &lt; 4294967295u) == true, let's do the loop body!\n(2u &lt; 4294967295u) == true, let's do the loop body!\n</code></pre>\n<p>Here's the problem: What do you do in the loop body? Presumably you <em>access</em> the <code>i^th</code> character of your string, don't you? Even though it wasn't your intention, you didn't only accessed the zeroth and first, but also the second! The second doesn't exists (as your string only has two characters, the zeroth and first), you access memory you shouldn't, the program does whatever it wants (undefined behaviour). Note that the program isn't required to crash immediately. It can seem to work fine for another half an hour, so these mistakes are hard to catch. But it's always dangerous to access memory beyond the bounds, this is where most crashes come from.</p>\n<p>So in summary, you get a different value from <code>s.length() - 3</code> from that what you'd expect, this results in a positive loop condition check, that leads to repetitive execution of the loop body, which in itself accesses memory it shouldn't.</p>\n<p>Now let's see how to avoid that, i.e. how to tell the compiler what you actually meant in your loop condition.</p>\n<hr>\n<p>Lengths of strings and sizes of containers are inherently <em>unsigned</em> so you should use an unsigned integer in for loops.</p>\n<p>Since <code>unsigned int</code> is fairly long and therefore undesirable to write over and over again in loops, just use <code>size_t</code>. This is the type every container in the STL uses for storing length or size. You may need to include <code>cstddef</code> to assert platform independence.</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n\n    string s = \"aa\";\n\n    for ( size_t i = 0; i + 3 &lt; s.length(); i++) {\n    //    ^^^^^^         ^^^^\n    }\n}\n</code></pre>\n<p>Since <code>a &lt; b - 3</code> is mathematically equivalent to <code>a + 3 &lt; b</code>, we can interchange them. However, <code>a + 3 &lt; b</code> prevents <code>b - 3</code> to be a huge value. Recall that <code>s.length()</code> returns an unsigned integer and unsigned integers perform operations module <code>2^(bits)</code> where bits is the number of bits in the type (usually 8, 16, 32 or 64). Therefore with <code>s.length() == 2</code>, <code>s.length() - 3 == -1 == 2^(bits) - 1</code>. </p>\n<hr>\n<p>Alternatively, if you want to use <code>i &lt; s.length() - 3</code> for personal preference, you have to add a condition:</p>\n<pre><code>for ( size_t i = 0; (s.length() &gt; 3) &amp;&amp; (i &lt; s.length() - 3); ++i )\n//    ^             ^                    ^- your actual condition\n//    ^             ^- check if the string is long enough\n//    ^- still prefer unsigned types!\n</code></pre>\n</hr></hr>", "OwnerUserId": "985296", "LastEditorUserId": "985296", "LastEditDate": "2013-07-03T17:12:19.273", "Id": "17400210", "Score": "28", "CreationDate": "2013-07-01T08:31:24.437", "LastActivityDate": "2013-07-03T17:12:19.273"}, "bq_ids": {"n4140": {"so_17398959_17437214_3": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}, "so_17398959_17437214_0": {"section_id": 5937, "quality": 1.0, "length": 13}, "so_17398959_17437214_1": {"section_id": 7213, "quality": 0.8125, "length": 13}, "so_17398959_17437214_2": {"section_id": 7213, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_17398959_17437214_3": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}, "so_17398959_17437214_0": {"section_id": 5709, "quality": 1.0, "length": 13}, "so_17398959_17437214_1": {"section_id": 6957, "quality": 0.9375, "length": 15}, "so_17398959_17437214_2": {"section_id": 6957, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_17398959_17437214_3": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}, "so_17398959_17437214_0": {"section_id": 7421, "quality": 1.0, "length": 13}, "so_17398959_17437214_1": {"section_id": 8722, "quality": 0.8125, "length": 13}, "so_17398959_17437214_2": {"section_id": 8722, "quality": 0.9642857142857143, "length": 27}}}, "17405499": {"ParentId": "17398959", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The problem you are having arises from the following statement:</p>\n<pre><code>i &lt; s.length() - 3\n</code></pre>\n<p>The result of s.length() is of the <strong>unsigned</strong> size_t type.\nIf you imagine the binary representation of two:</p>\n<blockquote>\n<p id=\"so_17398959_17405499_0\">0...010</p>\n</blockquote>\n<p>And you then substitute three from this, you are effectively taking off 1 three times, that is:</p>\n<blockquote>\n<p id=\"so_17398959_17405499_1\">0...001</p>\n<p id=\"so_17398959_17405499_2\">0...000 </p>\n</blockquote>\n<p>But then you have a problem, removing the third digit it underflows, as it attempts to get another digit from the left:</p>\n<blockquote>\n<p id=\"so_17398959_17405499_3\">1...111</p>\n</blockquote>\n<p>This is what happens no matter if you have an <strong>unsigned</strong> or <strong>signed</strong> type, however the difference is the <strong>signed</strong> type uses the Most Significant Bit (or MSB) to represent if the number is negative or not. When the undeflow occurs it simply represents a negative for the <strong>signed</strong> type.</p>\n<p>On the other hand, size_t is <strong>unsigned</strong>. When it underflows it will now represent the highest number size_t can possibly represent. Thus the loop is <em>practically</em> infinite (Depending on your computer, as this effects the maximum of size_t).</p>\n<p>In order to fix this problem, you can manipulate the code you have in a few different ways:</p>\n<pre><code>int main() {\n    string s = \"aa\";\n    for (size_t i = 3; i &lt; s.length(); i++) {\n\n    }\n}\n</code></pre>\n<p>or</p>\n<pre><code>int main() {\n    string s = \"aa\";\n    for (size_t i = 0; i + 3 &lt; s.length(); i++) {\n\n    }\n}\n</code></pre>\n<p>or even:</p>\n<pre><code>int main() {\n    string s = \"aa\";\n    for(size_t i = s.length(); i &gt; 3; --i) {\n\n    }\n}\n</code></pre>\n<p>The important things to note is that the substitution has been omitted and instead addition has been used elsewhere with the same logical evaluations.\nBoth the first and last ones change the value of <code>i</code> that is available inside the <code>for</code> loop whereas the second will keep it the same.</p>\n<p>I was tempted to provide this as an example of code:</p>\n<pre><code>int main() {\n    string s = \"aa\";\n    for(size_t i = s.length(); --i &gt; 2;) {\n\n    }\n}\n</code></pre>\n<p>After some thought I realised this was a bad idea. Readers' exercise is to work out why!</p>\n", "OwnerUserId": "1188701", "LastEditorUserId": "1188701", "LastEditDate": "2013-07-02T22:41:01.410", "Id": "17405499", "Score": "1", "CreationDate": "2013-07-01T13:22:07.390", "LastActivityDate": "2013-07-02T22:41:01.410"}});