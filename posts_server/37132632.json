post_cb({"37132632": {"CommentCount": "6", "AcceptedAnswerId": "38191243", "PostTypeId": "1", "LastEditorUserId": "3706364", "CreationDate": "2016-05-10T08:06:28.313", "LastActivityDate": "2016-07-04T19:35:24.460", "LastEditDate": "2016-05-10T09:06:14.497", "ViewCount": "289", "FavoriteCount": "1", "Title": "Why Does the Standard C++ Grammar Not Cover this Case?", "Id": "37132632", "Score": "7", "Body": "<p>I am mainly referring to the C++03 standard but, after a quick glance, it should also be applicable to the C++11 standard.</p>\n<p>The following code compiled and executed successfully in VC++2010:</p>\n<pre><code>template&lt;typename T&gt; \nclass CC { \n  public: \n    T f(T a) { \n            return a*a;\n    } \n};\ntemplate&lt;&gt; \nclass ::CC&lt;int&gt; {  //&lt;--- ::CC&lt;int&gt; syntax allowed by VC++2010, but is it non-standard ?\n  public: \n    int f(int a) { \n            return a*a;\n    } \n};\n\nint main(int argc, _TCHAR* argv[])\n{\n    ::CC&lt;int&gt; c;\n}\n</code></pre>\n<p>Notice the <code>::CC&lt;int&gt;</code> syntax to refer to the template defined in the global namespace. This is not the same as the <code>NamespaceA::CC&lt;int&gt;</code> syntax where the <code>::</code> operator is preceded by something.  With some other tools, I tried to parse this using the grammar strictly from the C++03 but it gave me errors and it seems to me that the standard accepts only <code>NamespaceA::CC&lt;int&gt;</code> form in the class head declaration.</p>\n<p>On a closer look, the issue is that the <code>class-head</code> is defined by this grammar in the standard:</p>\n<pre><code>class-head:\n   class-key identifier(optional) base-clause(optional)\n   class-key nested-name-specifier identifier base-clause(optional)\n   class-key nested-name-specifier(optional) template-id base-clause(optional)\n</code></pre>\n<p>And since <code>nested-name-specifier</code> is of the form <code>AA::bb::</code>..., it doesn't accept my <code>::CC</code>.\nMy question is, why the C++ standard doesn't allow the ::CC form? Is it just my incorrect interpretation of the standard grammar? Should the proper grammar looks like this:</p>\n<pre><code>class-head:\n   ...\n   class-key '::'(optional) nested-name-specifier(optional) template-id base-clause(optional)\n</code></pre>\n<p>Note, the above form is really used by the standard somewhere else, say, in specifying declarator-id:</p>\n<pre><code>declarator-id:\n   id-expression\n   ::(optional) nested-name-specifier(optional) class-name\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer><grammar><c++03>", "OwnerUserId": "237575", "AnswerCount": "2"}, "37132814": {"ParentId": "37132632", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>In the C++ draft, the <em>nested-name-specifier</em> is mentioned in <a href=\"http://eel.is/c++draft/class#11\" rel=\"nofollow\">[class].11</a>:</p>\n<blockquote>\n<p id=\"so_37132632_37132814_0\">If a class-head-name contains a nested-name-specifier, the class-specifier shall refer to a class that was previously declared directly in the class or namespace to which the nested-name-specifier refers, or in an element of the inline namespace set ([namespace.def]) of that namespace (i.e., not merely inherited or introduced by a using-declaration), and the class-specifier shall appear in a namespace enclosing the previous declaration. In such cases, the nested-name-specifier of the class-head-name of the definition shall not begin with a decltype-specifier.</p>\n</blockquote>\n<p>And it can of course also be <code>::</code> according to <a href=\"http://eel.is/c++draft/expr.prim.id.qual#nested-name-specifier\" rel=\"nofollow\">[expr.prim.id.qual]</a>.</p>\n<p>In your code, you're using <code>class ::CC&lt;int&gt;</code> in a template class specialization, for which <a href=\"http://eel.is/c++draft/temp.expl.spec#2\" rel=\"nofollow\">[temp.expl.spec].2</a> also applies:</p>\n<blockquote>\n<p id=\"so_37132632_37132814_1\">An explicit specialization shall be declared in a namespace enclosing the specialized template. An explicit specialization whose declarator-id or class-head-name is not qualified shall be declared in the nearest enclosing namespace of the template, or, if the namespace is inline ([namespace.def]), any namespace from its enclosing namespace set. Such a declaration may also be a definition. If the declaration is not a definition, the specialization may be defined later ([namespace.memdef]).</p>\n</blockquote>\n<p>Hence, I think, using a qualified name should be okay.</p>\n", "OwnerUserId": "3919155", "LastEditorUserId": "3919155", "LastEditDate": "2016-05-10T08:33:22.683", "Id": "37132814", "Score": "2", "CreationDate": "2016-05-10T08:15:40.737", "LastActivityDate": "2016-05-10T08:33:22.683"}, "bq_ids": {"n4140": {"so_37132632_37132814_1": {"section_id": 264, "quality": 0.9210526315789473, "length": 35}, "so_37132632_37132814_0": {"section_id": 5855, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_37132632_37132814_1": {"section_id": 255, "quality": 0.9210526315789473, "length": 35}, "so_37132632_37132814_0": {"section_id": 5625, "quality": 0.972972972972973, "length": 36}}, "n4659": {"so_37132632_37132814_0": {"section_id": 7334, "quality": 0.972972972972973, "length": 36}}}, "38191243": {"ParentId": "37132632", "CommentCount": "0", "Body": "<p>From a comment by Columbo,</p>\n<blockquote>\n<p id=\"so_37132632_38191243_0\">Of course a nested-name-specifier can be ::, and CC is the identifier, \u2026?</p>\n</blockquote>\n<p>That is not the case, at least not in the context of this question. Up until the 2014 version of the C++ standard, a bare double semicolon did not qualify as a <em>nested-name-specifier</em>. The 2003 version of the standard said a <em>nested-name-specifier</em> took on one of the two forms, in BNF:</p>\n<ul>\n<li><em>class-or-namespace-name</em> <code>::</code> <em>nested-name-specifier</em><sub>opt</sub> </li>\n<li><em>class-or-namespace-name</em> <code>::</code> <code>template</code> <em>nested-name-specifier</em></li>\n</ul>\n<p>There was no room for a bare <code>class ::CC</code> to fit into this specification. The 2011 version added quite a bit to the BNF for a <em>nested-name-specifier</em>:</p>\n<ul>\n<li>::<sub>opt</sub> <em>type-name</em> ::</li>\n<li>::<sub>opt</sub> <em>namespace-name</em> ::</li>\n<li><em>decltype-specifier</em> ::</li>\n<li><em>nested-name-specifier</em> <em>identifier</em> ::</li>\n<li><em>nested-name-specifier</em> <code>template</code><sub>opt</sub> <em>simple-template-id</em> ::</li>\n</ul>\n<p>This still left no room for <code>class ::CC</code>. The 2014 version of the standard finally addressed this by saying a <em>nested-name-specifier</em> is one of</p>\n<ul>\n<li><code>::</code></li>\n<li><em>type-name</em> <code>::</code></li>\n<li><em>namespace-name</em> <code>::</code></li>\n<li><em>decltype-specifier</em> <code>::</code></li>\n<li><em>nested-name-specifier</em> <em>identifier</em> <code>::</code></li>\n<li><em>nested-name-specifier</em> <code>template</code><sub>opt</sub> <em>simple-template-id</em> <code>::</code></li>\n</ul>\n<p><br>\nThere are a number of ways to look at this interesting \"feature\". One is that this is a longstanding bug in the language specification, first identified in 2002 as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#355\" rel=\"nofollow\">issue #355</a>. One of the jobs of a compiler vendor is to identify and patch over bugs in the language specification, and then get those bugs fixed in an upcoming release of the standard. From this point of view, <code>template&lt;&gt; class ::CC&lt;int&gt; {...}</code> should compile.</br></p>\n<p>An alternative point of view is that this was <strong>not</strong> a bug. The BNF for a <em>nested-name-specifier</em> in both the 2003 and 2011 versions of the standard were quite clear, and thus <code>template&lt;&gt; class ::CC&lt;int&gt; {...}</code> should not compile. Whether this was an unfortunate misfeature or a deliberate feature didn't matter. The code in the question should not compile from the perspective of this point of view.</p>\n<p>Which point of view is correct is debatable. That the issue that first reported this discrepancy was not rejected was a sign that there was some meat to that report. On the other hand, that nothing was done about it through two revisions of the standard also says something.</p>\n<p>That said, now that the standard has been clarified, there is a bug in newer releases of GCC because even if one specifies <code>--std=c++14</code>, they do not allow <code>template&lt;&gt; class ::CC&lt;int&gt; {...}</code> to compile.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "38191243", "Score": "3", "CreationDate": "2016-07-04T19:35:24.460", "LastActivityDate": "2016-07-04T19:35:24.460"}});