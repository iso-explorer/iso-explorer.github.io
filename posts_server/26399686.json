post_cb({"bq_ids": {"n4140": {"so_26399686_26399786_1": {"length": 52, "quality": 0.9629629629629629, "section_id": 3201}}, "n3337": {"so_26399686_26399786_1": {"length": 52, "quality": 0.9629629629629629, "section_id": 3075}}, "n4659": {"so_26399686_26399786_1": {"length": 44, "quality": 0.8148148148148148, "section_id": 3962}}}, "26399786": {"Id": "26399786", "PostTypeId": "2", "Body": "<p>Consider this :</p>\n<p><a href=\"http://cdecl.ridiculousfish.com/?q=float+foo%28+int+%28%29+%29\" rel=\"nofollow noreferrer\"><em><code>float foo( int () )</code></em></a></p>\n<p>This declares a function <code>foo</code> ( accepting a function returning <code>int</code> ) returning <code>float</code>.</p>\n<p>Now read</p>\n<pre><code>Y y(X());\n</code></pre>\n<p>as <code>y</code> as function (accepting a function returning <code>X</code>) returning <code>Y</code></p>\n<p>The problem arises due to <a href=\"https://stackoverflow.com/questions/1424510/most-vexing-parse-why-doesnt-a-a-work\">C++ most vexing parse</a></p>\n<p>Can be solved with :</p>\n<pre><code> Y y{ X() }; // requires C++11\n</code></pre>\n<p>or </p>\n<pre><code>Y y( ( X() ) );\n  // ^     ^ notice parenthesis \n</code></pre>\n<hr>\n<p><strong>Update</strong> based on edit: </p>\n<p>A <em>quote from the standard</em> :</p>\n<blockquote>\n<p id=\"so_26399686_26399786_0\"><strong><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf#section.8.2\" rel=\"nofollow noreferrer\">\u00a7 8.2</a> Ambiguity resolution [dcl.ambig.res]</strong></p>\n<p id=\"so_26399686_26399786_1\">1 - The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 6.8 can also occur in the context of a declaration. <strong>In that context, the choice is between a function declaration with a redundant set of parentheses around a parameter name and an object declaration with a function-style cast as the initializer. Just as for the ambiguities mentioned in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf#section.6.8\" rel=\"nofollow noreferrer\">6.8</a>, the resolution is to consider any construct that could possibly be a declaration a declaration.</strong> [Note: a declaration can be explicitly disambiguated by a nonfunction-style cast, by a = to indicate initialization or by removing the redundant parentheses around the parameter name. ] </p>\n</blockquote>\n<pre><code>[Example:\n\nstruct S {\n    S(int);\n};\n\nvoid foo(double a)\n{\n   S w(int(a));  // function declaration\n   S x(int());   // function declaration\n   S y((int)a);  // object declaration\n   S z = int(a); // object declaration\n}\n\u2014end example]\n</code></pre>\n<p>Similarly other examples following this.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-16T17:07:08.587", "Score": "6", "CreationDate": "2014-10-16T08:37:58.453", "ParentId": "26399686", "CommentCount": "3", "OwnerUserId": "1870232", "LastEditDate": "2017-05-23T12:27:21.243"}, "26399686": {"ViewCount": "235", "Body": "<p>Why does the compiler interpret this line as a function definition and not as a variable definition:</p>\n<pre><code>Y y(X());\n</code></pre>\n<p>in the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X {\n  X() { std::cout &lt;&lt; \"X\"; }\n};\n\nstruct Y {\n  Y(const X &amp;x) { std::cout &lt;&lt; \"Y\"; }\n  void f() { std::cout &lt;&lt; \"f\"; }\n};\n\nint main() {\n  Y y(X());\n  y.f();\n}\n</code></pre>\n<p>VS2010 gives the following error on line \"y.f();\"</p>\n<pre><code>left of '.f' must have class/struct/union\n</code></pre>\n<p>Which part of the standard describes this behavior?\nThe answer to the following question doesn't give details about it:\n<a href=\"https://stackoverflow.com/questions/5926103/most-vexing-parsec\">Most vexing parse</a></p>\n", "AcceptedAnswerId": "26399786", "Title": "Function definition or variable definition?", "CreationDate": "2014-10-16T08:33:09.550", "Id": "26399686", "CommentCount": "2", "LastEditDate": "2017-05-23T12:20:28.997", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-16T17:07:08.587", "Score": "5", "OwnerUserId": "4108963", "Tags": "<c++><language-lawyer><most-vexing-parse>", "AnswerCount": "2"}, "26399760": {"Id": "26399760", "PostTypeId": "2", "Body": "<p><a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow\">Most vexing parse problem</a>. <code>Y y(X())</code> is actually function declaration with name <code>y</code>, that returns <code>Y</code> and receives argument of type function, that returns <code>X</code> and receives nothing.</p>\n<p>It's solved in C++11 with usage of <code>{}</code> for construct object.</p>\n", "LastActivityDate": "2014-10-16T08:36:47.747", "CommentCount": "0", "CreationDate": "2014-10-16T08:36:47.747", "ParentId": "26399686", "Score": "4", "OwnerUserId": "1498580"}});