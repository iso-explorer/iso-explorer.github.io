post_cb({"bq_ids": {"n4140": {"so_35378090_35379796_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 7234}}, "n3337": {"so_35378090_35379796_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 6978}}}, "35379796": {"Id": "35379796", "PostTypeId": "2", "Body": "<p>There's a pretty steep learning curve as far as <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">value categories</a> are concerned (at least to me), but I believe you have got the <a href=\"https://stackoverflow.com/q/3601602/4224575\">terminology</a> right on your example. So </p>\n<pre><code>func()\n</code></pre>\n<p>indeed returns a <strong>prvalue</strong> and from the C++ Standard par. <strong>3.10.5</strong> (I only have the current <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">draft</a>, your paragraph number may vary) we read :</p>\n<blockquote>\n<p id=\"so_35378090_35379796_0\">An lvalue for an object is necessary in order to modify the object except that <strong>an rvalue of class type can also be used to modify its referent under certain circumstances</strong>. [Example: a member function called for an\n  object (9.3) can modify the object. \u2014 end example]</p>\n</blockquote>\n<p>So the assignment operator, which is a member function, as in the example mentioned in the standard is an exception to the rule, allowing rvalues to be modified. </p>\n<p>This has spawned much criticism in the programming world, with its most extreme example this <a href=\"http://yosefk.com/blog/c11-fqa-anyone.html\" rel=\"nofollow noreferrer\">C++ FQA</a> excerpt : </p>\n<blockquote>\n<p id=\"so_35378090_35379796_1\">(Yes, sugar-coated death traps, you clueless cheerleaders. <code>X&amp; obj=a.b().c()</code> \u2013 oops, <code>b()</code> is a temporary object and c() returns a reference into it! Shouldn't have assigned that to a reference. Not many chances for a compiler warning, either.) </p>\n</blockquote>\n<p>But in real C++ programming it has <a href=\"http://cpptruths.blogspot.gr/2009/08/modifying-temporaries.html\" rel=\"nofollow noreferrer\">industrial applications</a> like the <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Named_Parameter\" rel=\"nofollow noreferrer\">named parameter</a> idiom : </p>\n<pre><code>std::cout &lt;&lt; X::create().setA(10).setB('Z') &lt;&lt; std::endl;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-13T12:25:46.123", "CommentCount": "1", "CreationDate": "2016-02-13T12:25:46.123", "ParentId": "35378090", "Score": "1", "OwnerUserId": "4224575", "LastEditDate": "2017-05-23T11:54:09.597"}, "35378577": {"Id": "35378577", "PostTypeId": "2", "Body": "<p>The value category of the function call expression is in fact an rvalue.</p>\n<p>Indeed, you may not call the copy assignment operator on rvalue primitives. The historical definition of rvalues in C was in fact the distinction that they may not be on the left side of an assigment.</p>\n<p>The assignment operators of classes are a bit different, though. They're regular member functions. And no rule prevents calling member functions of rvalues. Indeed, it's often quite useful when the functions have side-effects.</p>\n<p>How it works, well, the copy assignment operator is called on the temporary, the operator copies the right hand argument, changing the state of the temporary. After the statement, the temporary object is discarded. There is no UB, just pointless copying.</p>\n<p>You <em>can</em> prevent calling copy assignment on an rvalue, by declaring the operator with a reference qualifier like this: <code>Test&amp; operator=(Test) &amp; = default;</code>. Ref-qualifiers were added only later in c++11, so (implicit) copy assignment couldn't have been specified to be ref-qualified earlier. Presumably, C++11 didn't change the qualifier of implicit copy constructor to prevent breaking old code that does assign to an rvalue, even though such assignment does seem quite pointless. The <a href=\"http://www.codingstandard.com/rule/12-5-7-declare-assignment-operators-with-the-ref-qualifier/\" rel=\"nofollow noreferrer\">High Integrity C++ Coding Standard</a> recommends that you do use ref qualifier with user defined copy assignment operators.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2017-03-26T02:09:47.153", "CommentCount": "3", "CreationDate": "2016-02-13T10:12:29.320", "ParentId": "35378090", "Score": "6", "OwnerUserId": "2079303", "LastEditDate": "2017-03-26T02:09:47.153"}, "35378090": {"ViewCount": "300", "Body": "<pre><code>class Test {\n\npublic:\n\n    int n1;\n\n};\n\nTest func() {\n\n    return Test();\n\n}\n\nint main() {\n\n    func() = Test();\n\n}\n</code></pre>\n<p>This doesn't make sense to me. How and why is this allowed? Is it undefined behavior? If a function returns an rvalue, then how is it possible to set an rvalue to another rvalue? If I tried this with any primitive types, it would give me an error like I expect.</p>\n<p>I know that lvalues are a place in memory, so is the function creating a temporary lvalue (rvalue?) and assigning it to another lvalue? Can someone explain how this syntax works?</p>\n", "AcceptedAnswerId": "35378577", "Title": "Assigning Rvalue returned from function to another Rvalue", "CreationDate": "2016-02-13T09:11:39.570", "Id": "35378090", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-02-13T09:30:26.867", "LastEditorUserId": "4152273", "LastActivityDate": "2017-03-26T02:09:47.153", "Score": "7", "OwnerUserId": "4152273", "Tags": "<c++><c++11><rvalue><lvalue-to-rvalue>", "AnswerCount": "2"}});