post_cb({"bq_ids": {"n4140": {"so_26315899_26315899_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 7192}, "so_26315899_26315899_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 7192}, "so_26315899_26417168_0": {"length": 28, "quality": 1.0, "section_id": 6246}}, "n3337": {"so_26315899_26315899_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 6936}, "so_26315899_26315899_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 6936}, "so_26315899_26417168_0": {"length": 28, "quality": 1.0, "section_id": 6006}}, "n4659": {"so_26315899_26315899_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 8701}, "so_26315899_26315899_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 8701}, "so_26315899_26417168_0": {"length": 28, "quality": 1.0, "section_id": 7750}}}, "26315899": {"ViewCount": "215", "Body": "<h2><strong><em>QUESTION</em></strong></h2>\n<p>Is it allowed by the C++11 Standard to end lifetime of the container\n(std::map, for example) without invoking its destructor, if such\ncontainer does not need to invoke destructors of elements which it\ncontains and memory does not need to be deallocated (with\nAllocator::deallocate).</p>\n<h2><strong><em>IN-DEPTH EXPLANATION</em></strong></h2>\n<p>C++11 Standard states the following:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_26315899_26315899_1\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n</blockquote>\n<p>This is clear and straightforward.\nFor example, there is some object which allocates memory during its lifetime and releases memory on destruction. If program depends on releasing memory, then not calling destructor of the object leads to undefined behavior. On the other hand, if object obtains memory from some memory pool, then there is no need to call the destructor, because program does not depend on its side effects and behavior is well-defined.</p>\n<p><em>But what about STL containers like std::map, std::list, etc.?</em>\nStandard states that conforming implementation must follow AS-IF rule. As long as observable behavior is the same, implementation may vary.</p>\n<p>I am trying to say that, for example, as stated in table 96 (container requirements), the destructor of container shall invoke destructors of its elements and deallocate all the memory. But what if it also uses some mutexes inside. Using one inside the container is not prohibited by standard (<em>am I wrong?</em>). Not invoking the destructor of mutex might lead to undefined behaviour.</p>\n<p><strong>I would like to know, if it is allowed by standard to use std::map and end its lifetime without calling of the destructor</strong>. For example, std::map uses custom allocator. This allocator uses some memory pool and to release memory no deallocation function is needed. Since all memory in the container is obtained using this allocator, the program which uses such container does not depend on side effects of destructor.</p>\n<p>Code:</p>\n<pre><code>class MemoryPool\n{\npublic:\n    ...\n\n    // Pre-allocates memory.\n    // Returns true on success.\n    bool initialize(uint32_t size)\n    {\n        ...\n    }\n\n    // Returns properly aligned block of memory from pre-allocated area.\n    template &lt;class T&gt; T* allocate(size_t n = 1)\n    {\n        ...\n    }\n\n    ...\n};\n\ntemplate &lt;class T&gt; class CustomAllocator\n{\npublic:\n    CustomAllocator(MemoryPool&amp; memoryPool): memoryPool_(&amp;memoryPool) {}\n\n    ...\n\n    /* this allocator obtains memory from memory pool */\n    T* allocate(size_t n)\n    {\n        return memoryPool_-&gt;allocate&lt;T&gt;(n);\n    }\n\n    // This function may be a no-op, it depends on the implementation of\n    // memory pool. It doesn't really matter in context of this question.\n    // Anyway, all memory is already allocated in memory pool, so whether there\n    // is a need to mark unused chunks or not depends on actual application.\n    void deallocate(T*, size_t) {}\n    ...\n\nprivate:\n    MemoryPool* memoryPool_;\n    ...\n};\n\nMemoryPool memoryPool;\nmemoryPool.initialize();\n\n// I intentionally use only fundamental types in this map\n// since not invoking the destructors of such objects\n// will not lead to undefined behavior\ntypedef std::map\n&lt;\n    uint32_t, uint32_t,\n    std::less&lt;uint32_t&gt;,\n    CustomAllocator&lt;uint32_t&gt;\n&gt; SomeMap;\n\nSomeMap* someMap = memoryPool.allocate&lt;SomeMap&gt;();\nnew(someMap) SomeMap(CustomAllocator&lt;uint32_t&gt;{memoryPool});\n\n// no destructor of SomeMap is called\n// memory is deallocated in destructor of memory pool\n</code></pre>\n", "AcceptedAnswerId": "26417168", "Title": "Ending lifetime of STL container without calling the destructor", "CreationDate": "2014-10-11T14:49:23.897", "Id": "26315899", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-12T06:28:29.110", "LastEditorUserId": "2037382", "LastActivityDate": "2014-10-17T02:53:44.620", "Score": "2", "OwnerUserId": "2037382", "Tags": "<c++><c++11><standards-compliance>", "AnswerCount": "1"}, "26417168": {"Id": "26417168", "PostTypeId": "2", "Body": "<p>I've asked this question here: <a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/R_KPazXbE0k\" rel=\"nofollow\">https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/R_KPazXbE0k</a></p>\n<p>According to 17.5.2.3 / 1:</p>\n<blockquote>\n<p id=\"so_26315899_26417168_0\">Clauses 18 through 30 and Annex D do not specify the representation of classes, and intentionally omit\n  specification of class members (9.2). An implementation may define static or non-static class members, or\n  both, as needed to implement the semantics of the member functions specified in Clauses 18 through 30 and\n  Annex D.</p>\n</blockquote>\n<p>In other words, implementation may have some private members which use resources other than memory. Thus, there is <strong>no guarantee</strong> that there are no other side effects (at least in the current C++11 Standard).</p>\n", "LastActivityDate": "2014-10-17T02:53:44.620", "CommentCount": "0", "CreationDate": "2014-10-17T02:53:44.620", "ParentId": "26315899", "Score": "0", "OwnerUserId": "2037382"}});