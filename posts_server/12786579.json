post_cb({"12786579": {"CommentCount": "0", "ViewCount": "597", "PostTypeId": "1", "ClosedDate": "2012-10-08T18:05:55.167", "LastEditorUserId": "-1", "CreationDate": "2012-10-08T17:28:58.227", "LastActivityDate": "2012-10-08T18:01:40.167", "Title": "the idea behind unsigned integer", "AcceptedAnswerId": "12786755", "LastEditDate": "2017-05-23T11:50:18.343", "Id": "12786579", "Score": "2", "Body": "<blockquote>\n<p id=\"so_12786579_12786579_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/2711522/what-happens-if-i-assign-a-negative-value-to-an-unsigned-variable\">What happens if I assign a negative value to an unsigned variable?</a> </br></p>\n</blockquote>\n<p>I'm new at C++ and I want to know how to use unsigned types. For the <code>unsigned int</code> type, I know that it can take the values from 0 to 4294967296. but when I want to initialize an unsigned int type as follows:</p>\n<pre><code>unsigned int x = -10;\ncout &lt;&lt; x;\n</code></pre>\n<p>The output seems like <code>4294967286</code>\nThe got this <code>output =  max value - 10</code>. So I want to learn what is happening in the memory? What kind of processes are being done while this calculation is continuing? Thanks for your answers.</p>\n", "Tags": "<c++><unsigned-integer>", "OwnerUserId": "1729549", "AnswerCount": "3"}, "12786755": {"ParentId": "12786579", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You're encountering wrap around behavior.</p>\n<p>Unsigned types are cyclic (signed types, on the other hand, may or may not be cyclic, but it's undefined behavior that you shouldn't rely on).  That is to say, one less than the minimum possible value is the maximum possible value.  You can demonstrate this yourself with the following snippet:</p>\n<pre><code>int main()\n{\n    unsigned int x = 5;\n    for (int i = 0; i &lt; 10; ++i) cout &lt;&lt; x-- &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>You'll notice that after reaching zero, the value of x jumps to 2^32-1, the maximum representable value.  Subtracting further acts as expected.</p>\n<p>When you subtract 1 from unsigned 0, the bit pattern changes in the following way:</p>\n<pre><code>0000 0000 0000 0000 0000 0000 0000 0000 // before (0)\n1111 1111 1111 1111 1111 1111 1111 1111 // after  (2^32 - 1)\n</code></pre>\n<p>With unsigned numbers, negative numbers are treated like positive numbers subtracted from zero.  So <code>(unsigned int) -10</code> will equal <code>((unsigned int) 0) - ((unsigned int) 10)</code>.</p>\n<p>I like to think about it as an unsigned int being the lowest 32 bits of a higher-precision arbitrary value.  Like this:</p>\n<pre><code>v imaginary high order bit\n1 0000 0000 0000 0000 0000 0000 0000 0000 // before (2^32)\n0 1111 1111 1111 1111 1111 1111 1111 1111 // after  (2^32 - 1)\n</code></pre>\n<p>The behavior of the unsigned int in these overflow cases is exactly the same as the behavior of the low 8 bits of an unsigned int when you subtract 1 from 256.  It makes more sense to look at an unsigned char (1 byte) like this, because the values 0 and 256 are equal if casted to <code>unsigned char</code>, since the limited precision discards the extra bits.</p>\n<pre><code>0 0000 0000 0000 0000 0000 0001 0000 0000 // before (256)\n0 0000 0000 0000 0000 0000 0000 1111 1111 // before (255)\n</code></pre>\n<p>As others have pointed out, this is called modulo arithmetic.  Using higher precision values to help visualize the transitions made when wrapping around works because you mask off high order bits.  It doesn't matter what it was, so it can be anything, it just gets discarded.  Integers are values over modulus 2^32, so any multiples of 2^32 equal zero in the space of an integer.  That's why I can get away with pretending there's an extra bit on the end.</p>\n<p>Modulus operations have their own dedicated operator in case you need to compute them for numbers other than 2^32 in your programs, as used in this statement:</p>\n<pre><code>int forty_mod_twelve = 40 % 12;\n// value is 4: 4 + n * 12 == 40 for some whole number n\n</code></pre>\n<p>Modulus operations on powers of two (like 2^32) simplify directly to masking off high order bits, and if you take a 64 bit integer and compute it modulo 2^32, the value will be exactly the same as if you had converted it to an unsigned int.</p>\n<pre><code>01011010 01011100 10000001 00001101 11111111 11111111 11111111 11111111 // before\n00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111 // after\n</code></pre>\n<p>Programmers like to use this property to speed up programs, because it's easy to chop off some number of bits, but performing a modulus operation is much harder (it's about as hard as doing a division).</p>\n<p>Does that make sense?</p>\n", "OwnerUserId": "1462604", "LastEditorUserId": "1462604", "LastEditDate": "2012-10-08T18:01:40.167", "Id": "12786755", "Score": "5", "CreationDate": "2012-10-08T17:40:23.723", "LastActivityDate": "2012-10-08T18:01:40.167"}, "12786656": {"ParentId": "12786579", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This involves the standard integral conversions.  Here's the applicable rule.  We start with the type of the literal <code>10</code>:</p>\n<blockquote>\n<h2>2.14.2    Integer literals [lex.icon]</h2>\n<p id=\"so_12786579_12786656_0\">An integer literal is a sequence of digits that has no period or exponent part.  An integer literal may have\n  a prefix that speci\ufb01es its base and a suffix that speci\ufb01es its type.  The lexically first digit of the sequence\n  of digits is the most signi\ufb01cant.  A decimal integer literal (base ten) begins with a digit other than <code>0</code> and\n  consists of a sequence of decimal digits.  An octal  integer literal (base eight) begins with the digit <code>0</code> and\n  consists of a sequence of octal digits. A hexadecimal integer literal (base sixteen) begins with <code>0x</code> or <code>0X</code> and\n  consists of a sequence of hexadecimal digits, which include the decimal digits and the letters <code>a</code> through <code>f</code> and <code>A</code> through <code>F</code> with decimal values ten through fifteen. [ Example:  the number twelve can be written <code>12</code>, <code>014</code>, or <code>0XC</code>.  \u2014 end example ]</p>\n<p id=\"so_12786579_12786656_1\">The type of an integer literal is the \ufb01rst of the corresponding list in Table 6 in which its value can be\n  represented.</p>\n</blockquote>\n<p>A table follows, the first type is <code>int</code> and it fits.  So the literal's type is <code>int</code>.</p>\n<p>The unary minus operator is applied, which doesn't change the type.  Then the following rule is applied:</p>\n<blockquote>\n<h2>4.7    Integral conversions [conv.integral]</h2>\n<p id=\"so_12786579_12786656_2\">A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped enumeration type can be converted to a prvalue of an integer type.</p>\n<p id=\"so_12786579_12786656_3\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type).  [ Note:  In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation).  \u2014 end note ]</p>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-10-08T17:39:24.753", "Id": "12786656", "Score": "4", "CreationDate": "2012-10-08T17:34:02.697", "LastActivityDate": "2012-10-08T17:39:24.753"}, "bq_ids": {"n4140": {"so_12786579_12786656_3": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_12786579_12786656_0": {"section_id": 5340, "quality": 0.8148148148148148, "length": 66}, "so_12786579_12786656_2": {"section_id": 30, "quality": 1.0, "length": 18}, "so_12786579_12786656_1": {"section_id": 5341, "quality": 0.75, "length": 9}}, "n3337": {"so_12786579_12786656_3": {"section_id": 28, "quality": 0.90625, "length": 29}, "so_12786579_12786656_0": {"section_id": 5137, "quality": 0.8765432098765432, "length": 71}, "so_12786579_12786656_2": {"section_id": 27, "quality": 1.0, "length": 18}, "so_12786579_12786656_1": {"section_id": 5138, "quality": 0.75, "length": 9}}, "n4659": {"so_12786579_12786656_3": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_12786579_12786656_0": {"section_id": 6761, "quality": 0.7654320987654321, "length": 62}, "so_12786579_12786656_2": {"section_id": 30, "quality": 1.0, "length": 18}, "so_12786579_12786656_1": {"section_id": 6762, "quality": 0.75, "length": 9}}}, "12786682": {"ParentId": "12786579", "CommentCount": "1", "Body": "<p>Instead of printing the value the way you are, print it in hexadecimal format (sorry, I forget how to do that with cout but I know it's possible). You'll see that the representation is the same for both values.</p>\n<p>From your context, an integer is 32 bits (this is not always the case). When using a signed integer, the most significant bit is the sign, not part of the value. When using an unsigned integer, the most significant bit is part of the value. </p>\n", "OwnerUserId": "749284", "PostTypeId": "2", "Id": "12786682", "Score": "0", "CreationDate": "2012-10-08T17:35:29.147", "LastActivityDate": "2012-10-08T17:35:29.147"}});