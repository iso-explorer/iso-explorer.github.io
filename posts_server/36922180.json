post_cb({"bq_ids": {"n4140": {"so_36922180_36922424_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 7194}, "so_36922180_36922424_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 7049}}, "n3337": {"so_36922180_36922424_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 6938}, "so_36922180_36922424_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 6794}}, "n4659": {"so_36922180_36922424_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 8703}, "so_36922180_36922424_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 8546}}}, "36922423": {"Id": "36922423", "PostTypeId": "2", "Body": "<p>Reference variables must always be initialised, and are always valid. If you want to refer to potentially invalid/uninitialized memory, use a pointer parameter (<code>T*</code>) instead. </p>\n<p>You can use your parameter like you could with any variable of type <code>T</code>, the only thing that the <code>&amp;</code> does it alter how it is initialized, which is done when the function is called, and will initialise it to refer to some lvalue expression.\nAs <code>v</code> is already initialised, you cannot reinitialise it (well you could try <code>new(&amp;v) T()</code>, but I wouldn't advise that unless you have called the destructor for <code>v</code>, (e.g. by <code>v.T::~T()</code>). (Note: <code>v = T();</code> does not (re)initialise <code>v</code>, it will copy assign).</p>\n<p>As for using it as a temp buffer, don't, use a pointer. (though I believe it is valid to use <code>T&amp; v</code> as a buffer, and it would work as expected, it may confuse the compiler if your trying to store objects of the wrong time), </p>\n", "LastActivityDate": "2016-04-28T18:12:10.243", "CommentCount": "1", "CreationDate": "2016-04-28T18:12:10.243", "ParentId": "36922180", "Score": "-2", "OwnerUserId": "5277173"}, "36922424": {"Body": "<p><em>The below is stolen (slightly modified) from <a href=\"https://stackoverflow.com/a/8595523/560648\">Mike Seymour's answer to a previous, similar question</a>.</em></p>\n<hr>\n<p>Inside <code>bind</code>, the <code>value1</code> has been declared, so the name is available for use:</p>\n<blockquote>\n<p id=\"so_36922180_36922424_0\"><code>[C++11: 3.3.2/1]:</code> The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer</p>\n</blockquote>\n<p>You are allowed to use objects in limited ways before they are initialised. Basically, anything that doesn't depend on the value is OK:</p>\n<blockquote>\n<p id=\"so_36922180_36922424_1\"><code>[C++11: 3.8/6]:</code> before the lifetime of an object has started but after the storage which the object will occupy has been allocated [...] any glvalue that refers to the original object may be used but only in limited ways. [...] using the properties of the glvalue that do not depend on its value is well-defined.</p>\n</blockquote>\n<p>So, what you are doing is well-defined.</p>\n<p>(Although, being ultrapedantic, I don't think it's specified when the storage for an automatic object is allocated, and 8.3.2/5 says that \"a reference shall be initialized to refer to a valid object\" without defining \"valid\", so there's scope to argue that it's not well-defined).</p>\n</hr>", "CreationDate": "2016-04-28T18:12:12.583", "ParentId": "36922180", "CommentCount": "4", "LastEditDate": "2017-05-23T12:16:10.407", "Id": "36922424", "PostTypeId": "2", "LastActivityDate": "2016-04-28T18:12:12.583", "LastEditorUserId": "-1", "CommunityOwnedDate": "2016-04-28T18:12:12.583", "Score": "5", "OwnerUserId": "560648"}, "36922180": {"ViewCount": "69", "Body": "<pre><code>// bind function: \ntemplate&lt;typename T&gt; T bind(T&amp; v) \n{   \n    // Can I toy with the object v refers to? or that's undefined behaviour?\n    // the object v refers to is not initialized yet, But the object has been allocated, so I can use that memory, I think?\n\n    // The following 2 lines should be fine if I'm correct.\n    // Which is my function is currently is doing (sorta)\n    myvector.emplace_back(SQLType&lt;T&gt;(), (void*)&amp;v);\n    return 0;\n}\n\nSomeClass value = bind(value);\n</code></pre>\n<p>I would like to know if I can use the object<code>value</code> before it has been initialized (which would happen when the <code>bind</code> function returns).</p>\n<p><strong>1</strong> - <strong>Can I initialize the object myself and use it ? ie:</strong></p>\n<pre><code>v = T();\nv.something();  // if T is a class\n</code></pre>\n<p><strong>2</strong> - <strong>Or can I use the memory where it's stored? ie: as a temp raw buffer?</strong></p>\n<pre><code>if (sizeof(v) &gt; 4)\n{\n     ((char*)&amp;v)[0] = 1;\n     ((char*)&amp;v)[1] = e + 5;       \n}\n</code></pre>\n", "AcceptedAnswerId": "36922424", "Title": "using a local variable before it has been initialized", "CreationDate": "2016-04-28T17:58:29.687", "Id": "36922180", "CommentCount": "10", "LastEditDate": "2016-04-28T21:11:19.177", "PostTypeId": "1", "LastEditorUserId": "6053907", "LastActivityDate": "2016-04-28T21:11:19.177", "Score": "-1", "OwnerUserId": "6053907", "Tags": "<c++>", "AnswerCount": "3"}, "36922513": {"Id": "36922513", "PostTypeId": "2", "Body": "<p>What I see, your question is, how does memory allocation and memory initalization in c++ work?</p>\n<p>I'm no expert myself, but this is my understanding of the concept:</p>\n<ul>\n<li>If the variable is of primitive type, it will be allocated but not initialized.</li>\n<li>If the variable is a object, a constructor is always executed (the default if no else is used) therefore the memory is allocated and MIGHT be initialized (depending on the constructor)</li>\n</ul>\n<p>What this means:\nYes, you should be able to use the memory, but don't trust the data</p>\n<p>For your perspective, it seems you want to \"receive\" data from a function without having it \"return it\" and if the function itself doesn't care about the data, this way of handling variables is completly fine. (from my understanding)</p>\n<p>Verified by \"Lightness Races in Orbit \" answer</p>\n", "LastActivityDate": "2016-04-28T18:17:55.233", "CommentCount": "0", "CreationDate": "2016-04-28T18:17:55.233", "ParentId": "36922180", "Score": "0", "OwnerUserId": "3252497"}});