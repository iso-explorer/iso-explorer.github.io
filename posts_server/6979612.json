post_cb({"6979612": {"CommentCount": "2", "ViewCount": "13776", "CreationDate": "2011-08-08T08:46:45.117", "LastActivityDate": "2013-03-08T12:47:01.543", "Title": "Why constructors will always have same name as of class and how they are invoked implicitly?", "AcceptedAnswerId": "6979712", "PostTypeId": "1", "Id": "6979612", "Score": "4", "Body": "<p>I want to know that why the name of constructor is always same as that of class name and how its get invoked implicitly when we create object of that class. Can anyone please explain the flow of execution in such situation?</p>\n", "Tags": "<c#><java><c++>", "OwnerUserId": "662320", "AnswerCount": "6"}, "6979702": {"ParentId": "6979612", "CommentCount": "5", "CreationDate": "2011-08-08T08:55:18.097", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "6979702", "Score": "2", "Body": "<p>One of the good reasons for constructor having the same name is their expressiveness. For example, in Java you create an object like,</p>\n<pre><code>MyClass obj = new MyClass();  // almost same in other languages too\n</code></pre>\n<p>Now, the constructor is defined as,</p>\n<pre><code>class MyClass {\n  public MyClass () {... }\n}\n</code></pre>\n<p>So the statement above very well expresses that, you are creating an object and while this process the constructor <code>MyClass()</code> is called.</p>\n<p>Now, whenever you create an object, it always calls its constructor. If that class is <code>extend</code>ing some other Base class, then their constructor will be called first and so on. All these operations are implicit. First the memory for the object is allocated (on heap) and then the constructor is called to initialize the object. If you don't provide a constructor, compiler will generate one for your class.</p>\n", "LastActivityDate": "2011-08-08T08:55:18.097"}, "6979638": {"ParentId": "6979612", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-08-08T08:49:09.753", "Score": "6", "LastEditorUserId": "1583", "LastEditDate": "2011-08-08T08:55:29.470", "Id": "6979638", "OwnerUserId": "1583", "Body": "<p>Why? Because the designers of the different languages you mention decided to make them that way. It is entirely possible for someone to design an OOP language where constructors do not have to have the same name as the class (as commented, this is the case in python).</p>\n<p>It is a simple way to distinguish constructors from other functions and makes the constructing of a class in code very readable, so makes sense as a language design choice.</p>\n<p>The mechanism is slightly different in the different languages, but essentially this is just a method call assisted by language features (the <code>new</code> keyword in java and c#, for example).</p>\n<p>The constructor gets invoked by the runtime whenever a new object is created.</p>\n", "LastActivityDate": "2011-08-08T08:55:29.470"}, "15294330": {"ParentId": "6979612", "CommentCount": "1", "CreationDate": "2013-03-08T12:47:01.543", "OwnerUserId": "2148437", "PostTypeId": "2", "Id": "15294330", "Score": "4", "Body": "<p>Seem to me that having sepearte keywords for declaring constructor(s) would be \"better\", as it would remove the otherwise unnecessary dependency to the name of the class itself.</p>\n<p>Then, for instance, the code inside the class could be copied as the body of another without having to make changes regarding name of the constructor(s). Why one would want to do this I don't know (possibly during some code refactoring process), but the point is one always strives for independency between things and here the language syntax goes against that, I think.</p>\n<p>Same for destructors.</p>\n", "LastActivityDate": "2013-03-08T12:47:01.543"}, "6979768": {"ParentId": "6979612", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-08-08T08:59:31.040", "Score": "2", "LastEditorUserId": "13005", "LastEditDate": "2011-08-08T09:07:07.377", "Id": "6979768", "OwnerUserId": "13005", "Body": "<p>In C++, strictly speaking constructors do not have names at all. 12.1/1 in the standard states, \"Constructors do not have names\", it doesn't get much clearer than that.</p>\n<p>The syntax for declaring and defining constructors in C++ uses the name of the class. There has to be some way of doing that, and using the name of the class is concise, and easy to understand. C# and Java both copied C++'s syntax, presumably because it would be familiar to at least some of the audience they were targeting.</p>\n<p>The precise flow of execution depends what language you're talking about, but what the three you list have in common is that first some memory is assigned from somewhere (perhaps allocated dynamically, perhaps it's some specific region of stack memory or whatever). Then the runtime is responsible for ensuring that the correct constructor or constructors are called in the correct order, for the most-derived class and also base classes. It's up to the implementation how to ensure this happens, but the required effects are defined by each of those languages.</p>\n<p>For the simplest possible case in C++, of a class that has no base classes, the compiler simply emits a call to the constructor specified by the code that creates the object, i.e. the constructor that matches any arguments supplied. It gets more complicated once you have a few virtual bases in play.</p>\n", "LastActivityDate": "2011-08-08T09:07:07.377"}, "6980506": {"ParentId": "6979612", "CommentCount": "0", "CreationDate": "2011-08-08T10:03:17.253", "OwnerUserId": "207421", "PostTypeId": "2", "Id": "6980506", "Score": "1", "Body": "<blockquote>\n<p id=\"so_6979612_6980506_0\">I want to know that why the name of constructor is always same as that\n  of class name</p>\n</blockquote>\n<p>So that it can be unambigously identified as the constructor.</p>\n<blockquote>\n<p id=\"so_6979612_6980506_1\">and how its get invoked implicitly when we create object of that class.</p>\n</blockquote>\n<p>It is invoked by the compiler because it has already been unambiguously identified because of its naming sheme.</p>\n<blockquote>\n<p id=\"so_6979612_6980506_2\">Can anyone please explain the flow of execution in such situation?</p>\n</blockquote>\n<ol>\n<li>The new X() operator is called.</li>\n<li>Memory is allocated, or an exception is thrown.</li>\n<li>The constructor is called.</li>\n<li>The new() operator returns to the caller.</li>\n</ol>\n<blockquote>\n<p id=\"so_6979612_6980506_3\">the question is why designers decided so?</p>\n</blockquote>\n<p>Naming the constructor after its class is a long-established convention dating back at least to the early days of C++ in the early 1980s, possibly to its Simula predecessor.</p>\n", "LastActivityDate": "2011-08-08T10:03:17.253"}, "bq_ids": {"n4140": {"so_6979612_6980506_1": {"section_id": 407, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_6979612_6980506_1": {"section_id": 398, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_6979612_6980506_1": {"section_id": 425, "quality": 0.5555555555555556, "length": 5}}}, "6979712": {"ParentId": "6979612", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-08-08T08:55:41.723", "Score": "13", "LastEditorUserId": "252000", "LastEditDate": "2011-08-08T09:20:11.017", "Id": "6979712", "OwnerUserId": "252000", "Body": "<blockquote>\n<p id=\"so_6979612_6979712_0\">I want to know that why the name of constructor is always same as that of class name</p>\n</blockquote>\n<p>Because this syntax does not require any new keywords. Aside from that, there is no good reason.</p>\n<blockquote>\n<p id=\"so_6979612_6979712_1\">To minimize the number of new keywords, I didn't use an explicit syntax like this:</p>\n<pre><code>class X {\n    constructor();\n    destructor();\n}\n</code></pre>\n<p id=\"so_6979612_6979712_2\">Instead, I chose a declaration syntax that mirrored the <em>use</em> of constructors.</p>\n<pre><code>class X {\n    X();\n    ~X();\n</code></pre>\n<p id=\"so_6979612_6979712_3\">This may have been overly clever. [The Design And Evolution Of C++, 3.11.2 Constructor Notation]</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6979612_6979712_4\">Can anyone please explain the flow of execution in such situation?</p>\n</blockquote>\n<p>The lifetime of an object can be summarized like this:</p>\n<ol>\n<li>allocate memory</li>\n<li>call constructor</li>\n<li>use object</li>\n<li>call destructor/finalizer</li>\n<li>release memory</li>\n</ol>\n<p>In Java, step 1 always allocates from the heap. In C#, classes are allocated from the heap as well, whereas the memory for structs is already available (either on the stack in the case of non-captured local structs or within their parent object/closure). <a href=\"http://blogs.msdn.com/b/ericlippert/archive/2010/09/30/the-truth-about-value-types.aspx\" rel=\"noreferrer\">Note that knowing these details is generally not necessary or very helpful</a>. In C++, memory allocation is extremely complicated, so I won't go into the details here.</p>\n<p>Step 5 depends on how the memory was allocated. Stack memory is automatically released as soon as the method ends. In Java and C#, heap memory is implicitly released by the Garbage Collector at some unknown time after it is no longer needed. In C++, heap memory is technically released by calling <code>delete</code>. In modern C++, <code>delete</code> is rarely called manually. Instead, you should use RAII objects such as <code>std::string</code>, <code>std::vector&lt;T&gt;</code> and <code>std::shared_ptr&lt;T&gt;</code> that take care of that themselves.</p>\n</hr>", "LastActivityDate": "2011-08-08T09:20:11.017"}});