post_cb({"7886604": {"Id": "7886604", "PostTypeId": "2", "Body": "<p>If <code>unsigned long</code> is 32 bits, then the behavior of shifting it by 32 bits is undefined.  Quoting the C++ 2003 standard:</p>\n<blockquote>\n<p id=\"so_7886504_7886604_0\">The behavior is undefined if the right operand is negative, or greater\n  than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>Apparently the compile-time and run-time evaluations are done differently -- which is perfectly valid as long as they yield the same results in cases where it's defined.</p>\n<p>(If <code>unsigned long</code> is wider than 32 bits on your system, this doesn't apply.)</p>\n", "LastActivityDate": "2011-10-25T08:29:05.133", "Score": "2", "CreationDate": "2011-10-25T08:29:05.133", "ParentId": "7886504", "CommentCount": "0", "OwnerUserId": "827263"}, "7886595": {"Id": "7886595", "PostTypeId": "2", "Body": "<p>I think that this is all down to undefined behaviour. I believe that in bitwise shifts the results are undefined if the right operand is greater than or equal to the number of bits in the left operand.</p>\n", "LastActivityDate": "2011-10-25T08:28:23.303", "Score": "3", "CreationDate": "2011-10-25T08:28:23.303", "ParentId": "7886504", "CommentCount": "0", "OwnerUserId": "102238"}, "bq_ids": {"n4140": {"so_7886504_7886604_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6146}}, "n3337": {"so_7886504_7886604_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5909}}, "n4659": {"so_7886504_7886604_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7642}}}, "7886552": {"Id": "7886552", "PostTypeId": "2", "Body": "<p>Both those tests <a href=\"http://ideone.com/7Q1SZ\" rel=\"nofollow\">pass on gcc-4.3.4</a> with plain old <code>assert</code>.</p>\n", "LastActivityDate": "2011-10-25T08:24:25.463", "Score": "0", "CreationDate": "2011-10-25T08:24:25.463", "ParentId": "7886504", "CommentCount": "2", "OwnerUserId": "458742"}, "7886588": {"Id": "7886588", "PostTypeId": "2", "Body": "<p>It is undefined behaviour to shift a value greater than or equal the size in bits of the left operand (\u00a75.8\u00b61). (I assume <code>unsigned long</code> is 32 bits from your comments about 0xfffffff being the expected result if you consider sign extension.)</p>\n<p>Still, there's probably something that <code>ASSERT_EQ</code> does that causes the difference, as it works fine on GCC 4.5 <a href=\"http://ideone.com/G3rOm\" rel=\"nofollow\">with good old <code>assert</code></a>.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2011-10-25T08:33:53.447", "Score": "5", "CreationDate": "2011-10-25T08:27:56.867", "ParentId": "7886504", "CommentCount": "5", "LastEditDate": "2011-10-25T08:33:53.447", "OwnerUserId": "46642"}, "7886504": {"ViewCount": "279", "Body": "<p>I'm working with gcc 4.4.5, and have some difficulties in understanding the right shift operator on plain simple unsigned values...</p>\n<p>This test</p>\n<pre><code>    ASSERT_EQ( 0u, (unsigned long)(0xffffffff) &gt;&gt; (4*8) );\n</code></pre>\n<p>passes.</p>\n<p>This test</p>\n<pre><code>    unsigned long address = 0xffffffff;\n    ASSERT_EQ( 0u, address &gt;&gt; (4*8) );\n</code></pre>\n<p>fails:</p>\n<pre><code>Value of: address &gt;&gt; (4*8)\n   Actual: 4294967295\n   Expected: 0u\n</code></pre>\n<p>It seems that the variable is treated like a signed value, and thus results in sign-extension.  (0xffffffff is 4294967295 in decimal).\nCan anyone spot the difference?</p>\n", "AcceptedAnswerId": "7886588", "Title": "Sign extension on literal vs. variable", "CreationDate": "2011-10-25T08:19:58.900", "Id": "7886504", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2011-10-25T08:33:53.447", "Score": "3", "OwnerUserId": "6610", "Tags": "<c++><bit-shift>", "AnswerCount": "4"}});