post_cb({"4891180": {"Id": "4891180", "PostTypeId": "2", "Body": "<p>You might see it in a class, but you need to assign it upon initialization in all constructors, e.g.</p>\n<pre><code>class X\n{\n    int &amp; a;\npublic:\n    X(int &amp; i) :a(i) {}\n};\n</code></pre>\n", "LastActivityDate": "2011-02-03T20:14:20.610", "CommentCount": "1", "CreationDate": "2011-02-03T20:14:20.610", "ParentId": "4891146", "Score": "7", "OwnerUserId": "440119"}, "bq_ids": {"n4140": {"so_4891146_4891191_0": {"length": 60, "quality": 0.8955223880597015, "section_id": 3222}}, "n3337": {"so_4891146_4891191_0": {"length": 61, "quality": 0.9104477611940298, "section_id": 3096}}, "n4659": {"so_4891146_4891191_0": {"length": 60, "quality": 0.8955223880597015, "section_id": 3979}}}, "4891198": {"Id": "4891198", "PostTypeId": "2", "Body": "<p>&amp; does not define an alias; it is a reference, which is like a stripped down pointer.  They cannot be reinitialized, which is why you must specify the \"alias\" at the beginning.</p>\n", "LastActivityDate": "2011-02-03T20:15:22.827", "CommentCount": "0", "CreationDate": "2011-02-03T20:15:22.827", "ParentId": "4891146", "Score": "1", "OwnerUserId": "590042"}, "4891187": {"Id": "4891187", "PostTypeId": "2", "Body": "<p>You would have to use a pointer. The reference notation comes down to the same as a pointer, only it cannot be null. That's why you cannot just declare a variable as <code>int &amp; a</code>. Maybe there is an exception for members of a class (i.e. they can be defined as references), but the references have to be set in the constructor (see PigBen's answer).</p>\n", "LastActivityDate": "2011-02-03T20:14:35.550", "CommentCount": "1", "CreationDate": "2011-02-03T20:14:35.550", "ParentId": "4891146", "Score": "-1", "OwnerUserId": "104954"}, "4891146": {"ViewCount": "192", "Body": "<p>I read somewhere that in C++ you can't give a definition like:</p>\n<pre><code>int&amp; a;\n</code></pre>\n<p>but only:</p>\n<pre><code>int b;  \nint&amp; a=b;  \n</code></pre>\n<p>Since <code>&amp;</code> is a reference of the other variable, it cannot be defined separately.\nOn the other hand, I see it defined separately in code all the time.</p>\n<p>Could someone explain to me how can you define</p>\n<pre><code>int &amp; a;   \n</code></pre>\n<p>without specifying a reference to which variable it is?</p>\n", "AcceptedAnswerId": "4891180", "Title": "& of a variable", "CreationDate": "2011-02-03T20:10:38.623", "Id": "4891146", "CommentCount": "2", "LastEditDate": "2011-02-03T20:46:33.937", "PostTypeId": "1", "LastEditorUserId": "56338", "LastActivityDate": "2011-02-03T20:46:33.937", "Score": "1", "OwnerUserId": "591005", "Tags": "<c++><reference>", "AnswerCount": "4"}, "4891191": {"Id": "4891191", "PostTypeId": "2", "Body": "<p>Considering the C++ standard, you cannot declare an unitialized reference by itself :</p>\n<blockquote>\n<p id=\"so_4891146_4891191_0\">There shall be no references to references, no arrays of references, and no pointers to references. The declaration of a reference shall contain an initializer (8.5.3) except when the declaration contains an explicit extern specifier (7.1.1), is a class member (9.2) declaration within a class declaration, or is the declaration of a parameter or a return type (8.3.5); see 3.1. A reference shall be initialized to refer to a valid object or function. [Note: in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the \u201cobject\u201d obtained by dereferencing a null pointer, which causes undefined behavior. As described in 9.6, a reference cannot be bound directly to a bitfield. ]</p>\n<p id=\"so_4891146_4891191_1\">\u2014ISO/IEC 14882:1998(E), the ISO C++ standard, in section 8.3.2 [dcl.ref]</p>\n</blockquote>\n", "LastActivityDate": "2011-02-03T20:14:55.440", "CommentCount": "0", "CreationDate": "2011-02-03T20:14:55.440", "ParentId": "4891146", "Score": "5", "OwnerUserId": "444469"}});