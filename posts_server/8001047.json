post_cb({"8001186": {"Id": "8001186", "PostTypeId": "2", "Body": "<p>That's not a valid example of the rule. The <code>hidden</code> class in your example has <em>external</em> linkage. (It has a compiler-generated unique name such that nothing outside the current translation unit can actually link with it, but it's still external.)</p>\n<p>The standard gives an example of a local type:</p>\n<pre><code>template &lt;class T&gt; class X { /* ... */ };\nvoid f()\n{\n  struct S { /* ... */ };\n\n  X&lt;S&gt; x3;  // error: local type used as template-argument\n  X&lt;S*&gt; x4; // error: pointer to local type used as template-argument\n}\n</code></pre>\n", "LastActivityDate": "2011-11-03T20:09:17.313", "CommentCount": "0", "CreationDate": "2011-11-03T20:09:17.313", "ParentId": "8001047", "Score": "4", "OwnerUserId": "33732"}, "bq_ids": {"n4140": {"so_8001047_8001177_0": {"length": 7, "quality": 0.875, "section_id": 7136}, "so_8001047_8001177_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7136}, "so_8001047_8001177_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 5482}}, "n3337": {"so_8001047_8001177_0": {"length": 7, "quality": 0.875, "section_id": 6880}, "so_8001047_8001177_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6880}, "so_8001047_8001177_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 5268}}, "n4659": {"so_8001047_8001177_0": {"length": 7, "quality": 0.875, "section_id": 8637}, "so_8001047_8001177_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 8637}}}, "8001047": {"ViewCount": "675", "Body": "<p>ISO 98/03 standard (section 14.3.1) seems to forbid using a type with internal linkage as a template parameter. (See example below.) The C++11 standard does not.\nG++ - using the old standard - is allowing it.\nAm I misreading the 03 standard, or is g++ just letting this slide?</p>\n<pre><code>namespace\n{\n    struct hidden { };\n}\n\ntemplate&lt;typename T&gt;\nstruct S\n{\n   T t;\n};\n\nint main()\n{\n    S&lt;hidden&gt; s;\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "8001177", "Title": "Internal type as a template argument", "CreationDate": "2011-11-03T19:57:00.203", "Id": "8001047", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-11-03T20:14:21.590", "Score": "6", "OwnerUserId": "785937", "Tags": "<c++><templates>", "AnswerCount": "2"}, "8001177": {"Id": "8001177", "PostTypeId": "2", "Body": "<p>You're correct that C++03 doesn't allow using a type with internal linkage as a template type parameter, while C++11 does.</p>\n<p>I seem to recall, however, that definitions inside the anonymous namespace still have external linkage.</p>\n<hr>\n<p>Yup, section 3.5 <code>[basic.link]</code> says</p>\n<blockquote>\n<p id=\"so_8001047_8001177_0\">A name having namespace scope (3.3.5) has internal linkage if it is the name of</p>\n<ul>\n<li>an object, reference, function or function template that is explicitly declared static or,</li>\n<li>an  object  or  reference  that  is  explicitly  declared <code>const</code> and neither  explicitly declared <code>extern</code> nor previously declared to have external linkage; or</li>\n<li>a data member of an anonymous union.</li>\n</ul>\n<p id=\"so_8001047_8001177_1\">A name having namespace scope has external linkage if it is the name of</p>\n<ul>\n<li>an object or reference, unless it has internal linkage; or</li>\n<li>a function, unless it has internal linkage; or</li>\n<li>a named class (clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage purposes (7.1.3); or</li>\n<li>a named enumeration (7.2), or an unnamed enumeration defined in a typedef declaration in which the enumeration has the typedef name for linkage purposes (7.1.3); or</li>\n<li>an enumerator belonging to an enumeration with external linkage; or</li>\n<li>a template, unless it is a function template that has internal linkage (clause 14); or</li>\n<li>a namespace (7.3), unless it is declared within an unnamed namespace.</li>\n</ul>\n</blockquote>\n<p>You have a named class at namespace scope, it has external linkage.</p>\n<p>And the footnote on the bottom of page 115 of ISO/IEC 14882:2003 clarifies:</p>\n<blockquote>\n<p id=\"so_8001047_8001177_2\">Although entities in an unnamed namespace might have external linkage, they are effectively qualified by a name unique to their translation unit and therefore can never be seen from any other translation unit.</p>\n</blockquote>\n<p>If you have another version, try looking in section 7.3.1.1 <code>[namespace.unnamed]</code></p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-11-03T20:14:21.590", "Score": "7", "CreationDate": "2011-11-03T20:08:18.000", "ParentId": "8001047", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2011-11-03T20:14:21.590"}});