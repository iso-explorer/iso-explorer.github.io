post_cb({"bq_ids": {"n4140": {"so_23475776_23476013_0": {"length": 186, "quality": 0.9441624365482234, "section_id": 480}}, "n3337": {"so_23475776_23476013_0": {"length": 188, "quality": 0.9543147208121827, "section_id": 471}}, "n4659": {"so_23475776_23476013_0": {"length": 160, "quality": 0.8121827411167513, "section_id": 502}}}, "23476013": {"Id": "23476013", "PostTypeId": "2", "Body": "<p>Use <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\" rel=\"nofollow\"><code>std::make_shared</code></a> to avoid explicitly calling new. Similarly, use <code>std::make_unique</code>.</p>\n<p><code>make_shared</code> might be more efficient because it can allocate the counters for the smart-pointer and the object in one block together.</p>\n<p>Still, it does not come into its own until you have at least one more way for your statement to cause an exception after construction of the object but before it is safely ensconced in its smart-pointer. Said exceptions would otherwise cause a memory-leak.</p>\n<p>Example for bad behaviour:</p>\n<pre><code>void f(std::shared_ptr&lt;int&gt; a, std::shared_ptr&lt;int&gt; b);\n\nf(std::shared_ptr&lt;int&gt;(new int(0)), std::shared_ptr&lt;int&gt;(new int(4)));\n</code></pre>\n<p>And corrected:</p>\n<pre><code>f(std::make_shared&lt;int&gt;(0), std::make_shared&lt;int&gt;(4));\n</code></pre>\n<p>Now, someone advises you to return <code>Something</code> not by value but as a dynamically allocated pointer. For your use-case, there's actually no difference with an acceptable compiler as long as <code>Something</code> is copyable, due to copy-ellision, aka directly constructing the returned value in the space allocated by <code>new</code>/<code>make_shared</code>/<code>make_unique</code>.<br>\nSo, just do what you think best there.</br></p>\n<p>Copy-ellision is explicitly allowed by the standard. Just be aware the copy-constructor must be accessible anyway:</p>\n<blockquote>\n<h3>12.8. Copying and moving class objects \u00a732</h3>\n<p id=\"so_23475776_23476013_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases,\n  the implementation treats the source and target of the omitted copy/move operation as simply two different\n  ways of referring to the same object, and the destruction of that object occurs at the later of the times\n  when the two objects would have been destroyed without the optimization.123 This elision of copy/move\n  operations, called copy elision, is permitted in the following circumstances (which may be combined to\n  eliminate multiple copies):<br>\n  \u2014 in a return statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified\n  type as the function return type, the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value<br>\n  \u2014 in a throw-expression, when the operand is the name of a non-volatile automatic object (other than\n  a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from the operand to the exception\n  object (15.1) can be omitted by constructing the automatic object directly into the exception object<br>\n  \u2014 when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move<br>\n  \u2014 when the exception-declaration of an exception handler (Clause 15) declares an object of the same type\n  (except for cv-qualification) as the exception object (15.1), the copy/move operation can be omitted\n  by treating the exception-declaration as an alias for the exception object if the meaning of the program\n  will be unchanged except for the execution of constructors and destructors for the object declared by\n  the exception-declaration.</br></br></br></br></p>\n</blockquote>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2014-05-05T17:40:53.293", "Score": "2", "CreationDate": "2014-05-05T15:16:51.530", "ParentId": "23475776", "CommentCount": "6", "OwnerUserId": "3204551", "LastEditDate": "2014-05-05T17:40:53.293"}, "23475890": {"Id": "23475890", "PostTypeId": "2", "Body": "<p>The better way would be to have <code>f()</code> return <code>Something*</code> (allocated with <code>new</code>) or <code>shared_ptr&lt;Something&gt;</code>. Otherwise, the <code>Something</code> returned by <code>f()</code> will have automatic storage and putting it in a <code>shared_ptr</code> doesn't make sense. You could, in theory, use a <code>shared_ptr</code> with a custom deleter, but that wouldn't change the storage class of the underlying object, and you'd most likely just end up with a wild pointer.</p>\n<p>If you can't change <code>f()</code>, your solution of making a copy with dynamic storage is really all you can do. If you can give <code>Something</code> a move constructor, you could at least reduce the cost of making the copy (assuming it's expensive enough to be worth reducing).</p>\n<p>But see <a href=\"https://stackoverflow.com/a/23476013/3549027\">this answer</a> for why the copy isn't worth worrying about. Do whatever you think makes the code most readable.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-05T18:01:43.753", "Score": "2", "CreationDate": "2014-05-05T15:11:26.927", "ParentId": "23475776", "CommentCount": "0", "OwnerUserId": "3549027", "LastEditDate": "2017-05-23T11:57:29.560"}, "23475776": {"ViewCount": "953", "Body": "<p>I am doing it like this:</p>\n<pre><code>class Something;\nSomething f();\n...\nstd::shared_ptr&lt;Something&gt; ptr(new Something(f()));\n</code></pre>\n<p>but this doesn't feel right. Moreover it needs the copy constructor. Is there a better way?</p>\n", "AcceptedAnswerId": "23476013", "Title": "How to initialize a std::shared_ptr from a function returning by value?", "CreationDate": "2014-05-05T15:05:55.440", "Id": "23475776", "CommentCount": "4", "LastEditDate": "2014-05-05T16:03:10.593", "PostTypeId": "1", "LastEditorUserId": "72178", "LastActivityDate": "2014-05-05T18:01:43.753", "Score": "0", "OwnerUserId": "1097451", "Tags": "<c++><shared-ptr>", "AnswerCount": "3"}, "23475865": {"Id": "23475865", "PostTypeId": "2", "Body": "<p>You can use <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\" rel=\"nofollow\"><code>std::make_shared</code></a>. \nIt is better to use it for the following reason:</p>\n<blockquote>\n<p id=\"so_23475776_23475865_0\">This function typically allocates memory for the T object and for the shared_ptr's control block with a single memory allocation (it is a non-binding requirement in the Standard). In contrast, the declaration std::shared_ptr p(new T(Args...)) performs at least two memory allocations, which may incur unnecessary overhead.</p>\n</blockquote>\n", "LastActivityDate": "2014-05-05T15:10:23.597", "CommentCount": "0", "CreationDate": "2014-05-05T15:10:23.597", "ParentId": "23475776", "Score": "2", "OwnerUserId": "498424"}});