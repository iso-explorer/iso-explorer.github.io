post_cb({"9215695": {"ParentId": "9215391", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From C++ Jan 2012 draft:</p>\n<blockquote>\n<p id=\"so_9215391_9215695_0\">\u00a7 23.2.3/3 [sequence.reqmts] ....i and j denote iterators satisfying input iterator\n  requirements and <strong>refer to elements implicitly convertible to\n  value_type</strong>, [i, j) denotes a valid range....</p>\n<p id=\"so_9215391_9215695_1\">X(i, j)<br>\n  X a(i, j)<br>\n<em>Requires</em>: T shall be EmplaceConstructible into X\n  from *i. For vector, if the iterator does not meet the forward\n  iterator requirements (24.2.5), T shall also be MoveInsertable into X.\n  Each iterator in the range [i,j) shall be dereferenced exactly once.<br>\n<em>post</em>: distance(begin(), end()) == distance(i, j) Constructs a sequence\n  container equal to the range [i, j)</br></br></br></p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/users/1164929/coren\">Coren</a> brought my attention that the section you quoted:</p>\n<blockquote>\n<p id=\"so_9215391_9215695_2\">\u00a7 23.3.6.2/8 [vector.cons] <code>template &lt;class InputIterator&gt; vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());</code><br>\n<em>Effects</em>: Constructs a vector equal to the range [first,last), using the specified allocator.<br>\n<em>Complexity</em>: Makes only N <strong>calls to the copy constructor of T</strong> (where N is the distance between first and last) and no reallocations if iterators first and last are of forward, bidirectional, or random access categories. It makes order N calls to the copy constructor of T and order log(N) reallocations if they are just input iterators.</br></br></p>\n</blockquote>\n<p>is in the vector-specific area and <em>technically</em> should override the first section.  However, I believe this reference to the copy constructor is in error, and to be pedantic, the mention of copy-constructors is in the complexity as a maximum, and thus 0 calls to the copy constructor  (only using a conversion constructor) <em>seems to me</em> to be valid.  This is less clear than I would wish.</p>\n<p><a href=\"https://stackoverflow.com/users/500104\">Xeo</a> brought my attention to the fact that  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html\" rel=\"nofollow noreferrer\">C++ Standard Core Language Active Issues, Revision 78</a> has an issue (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#535\" rel=\"nofollow noreferrer\">535</a>) is about how in the standard \"many of the stipulations about copy construction are phrased to refer only to \u201ccopy constructors.\u201d' and this is obviously poor wording.  \"each use of the term \u201ccopy constructor\u201d in the Standard should be examined to determine if it applies strictly to copy constructors or to any constructor used for copying. (A similar issue applies to \u201ccopy assignment operators,\u201d which have the same relationship to assignment operator function templates.)\"  So, correcting this poor wording is on their to-do list.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:20.300", "Id": "9215695", "Score": "11", "CreationDate": "2012-02-09T17:26:15.643", "LastActivityDate": "2012-02-09T18:57:11.460"}, "9215991": {"ParentId": "9215391", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Since the compiler cannot distinguish between the attempt to use copy constructor of type X and the attempt to use a constructor which takes X, any implementation of </p>\n<p><code>template &lt;class InputIterator&gt;\n     vector(InputIterator first, InputIterator last,\n            const Allocator&amp; = Allocator());</code></p>\n<p>has to work in all compilers.</p>\n<p>[Edit] Looks like this needs more explanation.\nHow do I implement the above Vector constructor?</p>\n<pre><code>template &lt;class InputIterator&gt;\nvector(InputIterator first, InputIterator last,\n            const Allocator&amp; = Allocator())\n{\n for(InputIterator i = first; i != last; i++)\n {\n   push_back(*i);  // Or whatever way to add to vector.\n }\n} \n</code></pre>\n<p>Now any de-reference and attempt to add it local container storage *i will result in a copy constructor of the type *i (let us say type T (i.e, vector). In other words the implementation has to make a copy of the object *i and add it to the internal object collection(whatever it is).\nSo, the template definition/implementation will be finally expanded to something like \"T x(*i)\". Here on wards it is just a language aspect. C++ doesn't distinguish if *i is of actually type T or *i is a type that can be implicitly converted to T. </p>\n<p>This need not be explicitly stated in a standard.</p>\n", "OwnerUserId": "1183123", "LastEditorUserId": "1183123", "LastEditDate": "2012-02-10T09:32:40.180", "Id": "9215991", "Score": "0", "CreationDate": "2012-02-09T17:45:55.440", "LastActivityDate": "2012-02-10T09:32:40.180"}, "9215809": {"ParentId": "9215391", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You can even go further. This code works fine too :</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nstruct A {\n    int n;\n    int v;\n    A(int n_, int v_ = 0) : n(n_), v(v_) {}\n};\n\nint main() {\n    int arr[] = {1,2,3,4,5,6,7,8,9,10};\n    std::vector&lt;A&gt; A_vec(arr, arr+10);\n\n    for( std::vector&lt;A&gt;::iterator it=A_vec.begin(); it!=A_vec.end(); ++it )\n        std::cout&lt;&lt; it-&gt;n &lt;&lt;\" \";\n    std::cout&lt;&lt;std::endl;\n}\n</code></pre>\n<p>As you have noted in the standard, in \u00a723.3.6.2 : </p>\n<blockquote>\n<p id=\"so_9215391_9215809_0\">Makes only N calls to the <strong>copy constructor</strong> of T</p>\n</blockquote>\n<p>=&gt; This constructor iterates on each element and use the copy constructor so, as long as you have a working copy constructor, it should work fine on every compilers. </p>\n", "OwnerUserId": "1164929", "LastEditorUserId": "1164929", "LastEditDate": "2012-02-09T18:23:23.197", "Id": "9215809", "Score": "1", "CreationDate": "2012-02-09T17:34:18.303", "LastActivityDate": "2012-02-09T18:23:23.197"}, "bq_ids": {"n4140": {"so_9215391_9215695_1": {"section_id": 723, "quality": 0.9, "length": 27}, "so_9215391_9215391_0": {"section_id": 966, "quality": 0.725, "length": 29}, "so_9215391_9215809_0": {"section_id": 966, "quality": 1.0, "length": 4}, "so_9215391_9215695_0": {"section_id": 722, "quality": 0.875, "length": 14}, "so_9215391_9215695_2": {"section_id": 966, "quality": 0.5576923076923077, "length": 29}}, "n3337": {"so_9215391_9215695_1": {"section_id": 712, "quality": 0.9, "length": 27}, "so_9215391_9215391_0": {"section_id": 954, "quality": 0.725, "length": 29}, "so_9215391_9215809_0": {"section_id": 954, "quality": 1.0, "length": 4}, "so_9215391_9215695_0": {"section_id": 711, "quality": 0.875, "length": 14}, "so_9215391_9215695_2": {"section_id": 954, "quality": 0.5576923076923077, "length": 29}}, "n4659": {"so_9215391_9215695_1": {"section_id": 754, "quality": 0.8666666666666667, "length": 26}, "so_9215391_9215391_0": {"section_id": 1028, "quality": 0.725, "length": 29}, "so_9215391_9215809_0": {"section_id": 1028, "quality": 1.0, "length": 4}, "so_9215391_9215695_0": {"section_id": 753, "quality": 0.875, "length": 14}, "so_9215391_9215695_2": {"section_id": 1028, "quality": 0.5576923076923077, "length": 29}}}, "9215391": {"CommentCount": "1", "AcceptedAnswerId": "9215695", "PostTypeId": "1", "LastEditorUserId": "654891", "CreationDate": "2012-02-09T17:07:45.560", "LastActivityDate": "2012-03-15T13:23:51.330", "LastEditDate": "2012-03-15T13:23:51.330", "ViewCount": "1441", "FavoriteCount": "0", "Title": "Is conversion allowed with std::vector's template constructor taking iterators?", "Id": "9215391", "Score": "17", "Body": "<p>In the C++11 standard, Section 23.3.6.2 [vector.cons], the following is said:</p>\n<pre><code>   template &lt;class InputIterator&gt;\n     vector(InputIterator first, InputIterator last,\n            const Allocator&amp; = Allocator());\n</code></pre>\n<blockquote>\n<p id=\"so_9215391_9215391_0\">9  <em>Effects</em>: Constructs a vector equal to the range <code>[first,last)</code>, using the specified allocator.<br>\n  10 <em>Complexity</em>: Makes only N calls to the copy constructor of T (where N is the distance between <code>first</code> and <code>last</code>) and no reallocations if iterators first and last are of forward, bidirectional, or random access categories. It makes order N calls to the copy constructor of T and order log(N) reallocations if they are just input iterators.</br></p>\n</blockquote>\n<p>(this text exists in the older standard as well). On one hand, it does not require that dereferencing an <code>InputIterator</code> should result in a value of the same type that is stored in the vector. On the other hand, it tells about using copy constructors, which sort of implies the same type.</p>\n<p><strong>My question is</strong>: is it valid to use a sequence of elements of different type with this constructor, provided that conversion between types is possible?  References to the standard are desirable.</p>\n<p>For example, the following code works fine <a href=\"http://ideone.com/Fn5d3\" rel=\"nofollow\">at ideone</a>. Is it guaranteed by the standard, or does just GCC happen to allow it?</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nstruct A {\n    int n;\n    A(int n_) : n(n_) {}\n};\n\nint main() {\n    int arr[] = {1,2,3,4,5,6,7,8,9,10};\n    std::vector&lt;int&gt; int_vec(arr, arr+10);\n    std::vector&lt;A&gt; A_vec(int_vec.begin(), int_vec.end());\n\n    for( std::vector&lt;A&gt;::iterator it=A_vec.begin(); it!=A_vec.end(); ++it )\n        std::cout&lt;&lt; it-&gt;n &lt;&lt;\" \";\n    std::cout&lt;&lt;std::endl;\n}\n</code></pre>\n", "Tags": "<c++><stl><vector>", "OwnerUserId": "654891", "AnswerCount": "3"}});