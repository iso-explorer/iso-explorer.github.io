post_cb({"18937850": {"Id": "18937850", "PostTypeId": "2", "Body": "<p>A lock is just an automatic guard that <em>operates</em> a mutex in a safe and sane fashion.</p>\n<p>What you really want is this code:</p>\n<pre><code>std::mutex m;\n\nvoid f()\n{\n    std::lock_guard&lt;std::mutex&gt; lock(m);\n    // ...\n}\n</code></pre>\n<p>This effectively \"synchronizes\" calls to <code>f</code>, since every thread that enters it blocks until it manages to obtain the mutex.</p>\n<p>A <code>unique_lock</code> is just a beefed-up version of the <code>lock_guard</code>: It can be constructed unlocked, moved around (thanks, @MikeVine) and it is itself a \"lockable object\", like the mutex itself, and so it can be used for example in the variadic <code>std::lock(...)</code> to lock multiple things at once in a deadlock-free way, and it can be managed by an <code>std::condition_variable</code> (thanks, @syam).</p>\n<p>But unless you have a good reason to use a <code>unique_lock</code>, prefer to use a <code>lock_guard</code>. And once you <em>need</em> to upgrade to a <code>unique_lock</code>, you'll know why.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-09-21T21:50:03.503", "Score": "3", "CreationDate": "2013-09-21T21:31:47.343", "ParentId": "18937564", "CommentCount": "11", "LastEditDate": "2013-09-21T21:50:03.503", "OwnerUserId": "596781"}, "18937564": {"ViewCount": "2609", "Body": "<p>I am having some trouble conceptualizing how <code>unique_lock</code> is supposed to operate across threads. I tried to make a quick example to recreate something that I would normally use a <code>condition_variable</code> for.</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;thread&gt;\nusing namespace std;\nmutex m;\nunique_lock&lt;mutex&gt;* mLock;\nvoid funcA()\n{\n    //thread 2\n    mLock-&gt;lock();//blocks until unlock?Access violation reading location 0x0000000000000000.\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    //thread 1\n    mLock = new unique_lock&lt;mutex&gt;(m);\n    mLock-&gt;release();//Allows .lock() to be taken by a different thread?\n    auto a = std::thread(funcA);\n    std::chrono::milliseconds dura(1000);//make sure thread is running\n    std::this_thread::sleep_for(dura);\n    mLock-&gt;unlock();//Unlocks thread 2's lock?\n    a.join();\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "18937679", "Title": "unique_lock across threads?", "CreationDate": "2013-09-21T20:59:26.347", "Id": "18937564", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-11-13T21:16:02.247", "Score": "2", "OwnerUserId": "314290", "Tags": "<c++><c++11><concurrency><locking>", "AnswerCount": "4"}, "39505286": {"Id": "39505286", "PostTypeId": "2", "Body": "<p>As a side-note, the above answers skip over the difference between immediate and deferred locking of mutex:</p>\n<pre><code>#include&lt;mutex&gt;\n::std::mutex(mu);\nauto MyFunction()-&gt;void\n{\n   std::unique_lock&lt;mutex&gt; lock(mu); //Created instance and immediately locked the mutex\n   //Do stuff....\n}\n\nauto MyOtherFunction()-&gt;void\n{\n   std::unique_lock&lt;mutex&gt; lock(mu,std::defer_lock); //Create but not locked the mutex\n   lock.lock(); //Lock mutex\n   //Do stuff....\n   lock.unlock(); //Unlock mutex\n}\n</code></pre>\n<p>MyFunction() shows the widely used immediate lock, whilst MyOtherFunction() shows the deferred lock.</p>\n", "LastActivityDate": "2016-09-15T07:27:04.713", "Score": "0", "CreationDate": "2016-09-15T07:27:04.713", "ParentId": "18937564", "CommentCount": "0", "OwnerUserId": "5477287"}, "18937679": {"Id": "18937679", "PostTypeId": "2", "Body": "<p>That doesn't look at all right. First, <a href=\"http://en.cppreference.com/w/cpp/thread/unique_lock/release\" rel=\"nofollow\"><code>release</code></a> is \"disassociates the mutex without unlocking it\", which is highly unlikely that it is what you want to do in that place. It basically means that you no longer have a <code>mutex</code> in your <code>unique_lock&lt;mutex&gt;</code> - which will make it pretty useless - and probably the reason you get \"access violation\". </p>\n<p>Edit: After some \"massaging\" of your code, and convincing g++ 4.6.3 to do what I wanted (hence the <code>#define _GLIBCXX_USE_NANOSLEEP</code>), here's a working example:</p>\n<pre><code>#define _GLIBCXX_USE_NANOSLEEP\n#include &lt;chrono&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nmutex m;\nvoid funcA()\n{\n    cout &lt;&lt; \"FuncA Before lock\" &lt;&lt; endl;\n    unique_lock&lt;mutex&gt; mLock(m);\n    //thread 2\n    cout &lt;&lt; \"FuncA After lock\" &lt;&lt; endl;\n    std::chrono::milliseconds dura(500);//make sure thread is running\n    std::this_thread::sleep_for(dura);        //this_thread::sleep_for(dura);\n    cout &lt;&lt; \"FuncA After sleep\" &lt;&lt; endl;\n}\n\nint main(int argc, char* argv[])\n{\n    cout &lt;&lt; \"Main before lock\" &lt;&lt; endl;\n    unique_lock&lt;mutex&gt; mLock(m);\n    auto a = std::thread(funcA);\n    std::chrono::milliseconds dura(1000);//make sure thread is running\n    std::this_thread::sleep_for(dura);        //this_thread::sleep_for(dura);\n    mLock.unlock();//Unlocks thread 2's lock?\n    cout &lt;&lt; \"Main After unlock\" &lt;&lt; endl;\n    a.join();\n    cout &lt;&lt; \"Main after a.join\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Not sure why you need to use <code>new</code> to create the lock tho'. Surely <code>unique_lock&lt;mutex&gt; mlock(m);</code> should do the trick (and corresponding changes of <code>mLock-&gt;</code> into <code>mLock.</code> of course). </p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2013-09-21T21:35:30.583", "Score": "4", "CreationDate": "2013-09-21T21:11:39.877", "ParentId": "18937564", "CommentCount": "0", "LastEditDate": "2013-09-21T21:35:30.583", "OwnerUserId": "1919155"}, "bq_ids": {"n4140": {"so_18937564_18937820_0": {"length": 7, "quality": 0.875, "section_id": 2758}}, "n3337": {"so_18937564_18937820_0": {"length": 7, "quality": 0.875, "section_id": 2719}}, "n4659": {"so_18937564_18937820_0": {"length": 7, "quality": 0.875, "section_id": 3496}}}, "18937820": {"Id": "18937820", "PostTypeId": "2", "Body": "<p><code>unique_lock</code> should not be accessed from multiple threads at once.  It was not designed to be thread-safe in that manner.  Instead, multiple <code>unique_lock</code>s (local variables) reference the same global <code>mutex</code>.  Only the <code>mutex</code> itself is designed to be accessed by multiple threads at once.  And even then, my statement excludes <code>~mutex()</code>.</p>\n<p>For example, one knows that <code>mutex::lock()</code> can be accessed by multiple threads because its specification includes the following:</p>\n<blockquote>\n<p id=\"so_18937564_18937820_0\"><em>Synchronization:</em> Prior <code>unlock()</code> operations on the same object shall <em>synchronize with</em> (4.7) this operation.</p>\n</blockquote>\n<p>where <em>synchronize with</em> is a term of art defined in 4.7 [intro.multithread] (and its subclauses).</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2017-11-13T21:16:02.247", "Score": "7", "CreationDate": "2013-09-21T21:27:39.463", "ParentId": "18937564", "CommentCount": "3", "LastEditDate": "2017-11-13T21:16:02.247", "OwnerUserId": "576911"}});