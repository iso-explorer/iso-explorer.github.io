post_cb({"bq_ids": {"n4140": {"so_8404210_8576751_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 330}}, "n3337": {"so_8404210_8576751_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 320}}, "n4659": {"so_8404210_8576751_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 339}}}, "8404210": {"ViewCount": "4355", "Body": "<p>Consider the following class template 'X' and its partial specializations.</p>\n<pre><code>template &lt;class ...Types&gt;\nstruct X {};               // #1\n\ntemplate &lt;class T1&gt;\nstruct X&lt;T1&gt; {};           // #2\n\ntemplate &lt;class T1, class ...Types&gt;\nstruct X&lt;T1, Types...&gt; {}; // #3\n\nX&lt;int&gt; x;                  // #2 or #3 ?\n</code></pre>\n<p>I suspect X&lt;int&gt; is ambiguous. It is because:</p>\n<p>It is obvious that both #2 and #3 are more specialized than #1, #2 and #3 are now compared. According to 14.5.5.2, let's consider which of the following #2' and #3' is more specialized.</p>\n<pre><code>template &lt;class T1&gt;\nvoid f(X&lt;T1&gt;);             // #2'\n\ntemplate &lt;class T1, class ...Types&gt;\nvoid f(X&lt;T1, Types...&gt;);   // #3'\n</code></pre>\n<p>According to 14.8.2.4, the first step is the template argument deduction using #2' as the argument template and #3' as the parameter template. Given the only argument type is X&lt;A1&gt;, the deduced T1 is A1, and Types is empty.</p>\n<pre><code>A = X&lt;A1&gt;, P = X&lt;T1, Types...&gt;  =&gt;  T1 = A1, Types = {}\n</code></pre>\n<p>The second step is done using #3' as the argument template and #2' as the parameter template. Given the only argument type is X&lt;A1, Args...&gt;, according to 14.8.2.5/9 (note that this paragraph is recently revised by N3281), Args is simply ignored, the deduced T1 is A1 and argument deduction succeeds.</p>\n<pre><code>A = X&lt;A1, Args...&gt;, P = X&lt;T1&gt;  =&gt;  T1 = A1 (Args is ignored)\n</code></pre>\n<p>Finally, the bidirectional argument deductions succeeded. So #2 is just as specialized as #3. In conclusion, X&lt;int&gt; is ambiguous.</p>\n<p>My question is: \"is my interpretation correct?\"</p>\n<p>If this interpretation is correct, the definition of 'std::common_type' in 20.9.7.6/3 is inappropriate.</p>\n<pre><code>template &lt;class ...T&gt;\nstruct common_type;            // #1\n\ntemplate &lt;class T&gt;\nstruct common_type&lt;T&gt;          // #2\n{\n    typedef T type;\n};\n\ntemplate &lt;class T, class U&gt;\nstruct common_type&lt;T, U&gt;       // #3\n{\n    typedef\n        decltype(true ? declval&lt;T&gt;() : declval&lt;U&gt;())\n    type;\n};\n\ntemplate &lt;class T, class U, class ...V&gt;\nstruct common_type&lt;T, U, V...&gt; // #4\n{\n    typedef typename\n        common_type&lt;typename common_type&lt;T, U&gt;::type, V...&gt;::type\n    type;\n};\n</code></pre>\n<p>When common_type&lt;A, B&gt; is used, #3 and #4 are ambiguous.</p>\n<p>Note: on the first example, GCC 4.7.0 (snapshot) and Clang 3.0 select #2. However, these compilers are so unreliable that they don't follow the other changes by N3281.</p>\n", "Title": "Partial specialization of variadic templates", "CreationDate": "2011-12-06T17:36:05.590", "LastActivityDate": "2017-11-27T22:16:26.457", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-11-27T22:16:26.457", "LastEditorUserId": "3043539", "Id": "8404210", "Score": "40", "OwnerUserId": "976416", "Tags": "<c++><c++11><templates><variadic-templates><template-specialization>", "AnswerCount": "1"}, "8576751": {"Id": "8576751", "PostTypeId": "2", "Body": "<p>14.8.2.4, section 11 (I refer to draft N3242).</p>\n<blockquote>\n<p id=\"so_8404210_8576751_0\">In most cases, all template parameters must have values in order for\n  deduction to succeed, but for partial ordering purposes a template\n  parameter may remain without a value provided it is not used in the\n  types being used for partial ordering. [ Note: A template parameter\n  used in a non-deduced context is considered used. \u2014end note ] [\n  Example: </p>\n<pre><code>template &lt;class T&gt; T f(int); // #1\ntemplate &lt;class T, class U&gt; T f(U); // #2\nvoid g() {\nf&lt;int&gt;(1); // calls #1\n}\n</code></pre>\n</blockquote>\n<p>In your case, #3 will be used.</p>\n", "LastEditorUserId": "160206", "LastActivityDate": "2011-12-20T14:16:54.027", "Score": "8", "CreationDate": "2011-12-20T14:11:34.050", "ParentId": "8404210", "CommentCount": "0", "OwnerUserId": "653772", "LastEditDate": "2011-12-20T14:16:54.027"}});