post_cb({"26897781": {"ParentId": "26897066", "Score": "3", "CreationDate": "2014-11-12T22:21:04.330", "Id": "26897781", "OwnerUserId": "923854", "LastActivityDate": "2014-11-12T22:21:04.330", "Body": "<p>This simplest way to disengage an optional is with <code>foo = {};</code>, which is resolved as move assignment from a disengaged prvalue <code>optional</code>. The specification actually goes out of its way to enable this syntax which would otherwise be ambiguous with assignment from the contained type. (See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4023.html#optional.object.assign\" rel=\"nofollow\">[optional.object.assign] para 18-23 in N4023 for details</a>)</p>\n", "PostTypeId": "2", "CommentCount": "1"}, "26897067": {"ParentId": "26897066", "Score": "1", "CreationDate": "2014-11-12T21:37:40.330", "Id": "26897067", "OwnerUserId": "1678468", "LastActivityDate": "2014-11-12T21:37:40.330", "Body": "<p>Having read through the headers, the correct way to disengage the std::experimental::optional appears to be:\n</p>\n<pre class=\"lang-c++11 prettyprint-override\"><code>work = std::experimental::nullopt;\n</code></pre>\n", "PostTypeId": "2", "CommentCount": "0"}, "26897066": {"Tags": "<c++><c++14><optional><boost-optional>", "ViewCount": "1756", "AnswerCount": "3", "CreationDate": "2014-11-12T21:37:40.330", "Title": "How to disengage std::experimental::optional?", "CommentCount": "0", "AcceptedAnswerId": "26897163", "Score": "4", "OwnerUserId": "1678468", "Id": "26897066", "LastActivityDate": "2014-11-12T22:21:04.330", "Body": "<p>With Boost I can create an optional in-place with:\n</p>\n<pre class=\"lang-c++11 prettyprint-override\"><code>boost::optional&lt;boost::asio::io_service::work&gt; work = boost::in_place(boost::ref(io_service));\n</code></pre>\n<p>And disengage it with:</p>\n<pre class=\"lang-c++11 prettyprint-override\"><code>work = boost::none;\n</code></pre>\n<p>With C++14 / experimental support, I can instead construct an optional in-place with:</p>\n<pre class=\"lang-c++11 prettyprint-override\"><code>std::experimental::optional&lt;boost::asio::io_service::work&gt; work;\nwork.emplace(boost::asio::io_service::work(io_service));\n</code></pre>\n<p>But I'm at a loss for how to disengage it...</p>\n", "PostTypeId": "1"}, "26897163": {"ParentId": "26897066", "Score": "8", "CreationDate": "2014-11-12T21:42:49.637", "LastActivityDate": "2014-11-12T21:47:53.950", "LastEditDate": "2014-11-12T21:47:53.950", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "Body": "<pre><code>work = std::experimental::nullopt;\n</code></pre>\n<p>should disengage <code>work</code>.<br>\nThe <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3908.html#optional\">library fundamental TS</a> specifies in [optional.nullopt]:</br></p>\n<blockquote>\n<p id=\"so_26897066_26897163_0\">The struct <code>nullopt_t</code> is an empty structure type used as a unique\n  type to indicate a disengaged state for optional objects.</p>\n</blockquote>\n<p>There is an appropriate assignment operator, [optional.object.assign]:</p>\n<blockquote>\n<pre><code>optional&lt;T&gt;&amp; operator=(nullopt_t) noexcept;\n</code></pre>\n<p id=\"so_26897066_26897163_1\"><em>Effects:</em> If <code>*this</code> is engaged calls <code>val-&gt;T::~T()</code> to destroy the contained value; otherwise no effect.</p>\n</blockquote>\n<p>To avoid constructing a <code>nullopt_t</code> object every time, a constant of this type is already declared:</p>\n<blockquote>\n<p id=\"so_26897066_26897163_2\"><code>struct nullopt_t{</code><em>see below</em><code>};</code><br>\n<code>constexpr nullopt_t nullopt(</code><em>unspecified</em><code>);</code></br></p>\n</blockquote>\n", "Id": "26897163", "PostTypeId": "2", "CommentCount": "3"}, "bq_ids": {"n4659": {"so_26897066_26897163_1": {"length": 6, "section_id": 5052, "quality": 0.6666666666666666}, "so_26897066_26897163_0": {"length": 11, "section_id": 5113, "quality": 0.8461538461538461}}}});