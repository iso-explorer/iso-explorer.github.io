post_cb({"4397367": {"Id": "4397367", "PostTypeId": "2", "Body": "<p>It probably would be possible to define such a thing, but that would open such a can of worms that it almost certainly wouldn't be worth it:</p>\n<ol>\n<li>Which object to construct?</li>\n<li>If you define a union constructor, how does it construct one object vs another?</li>\n<li>Do you have to define one constructor per non-pod member?</li>\n<li>What is the syntax for assigning to a different object to the one that is currently assigned?</li>\n<li>Do you allow one object to be interpreted in the context of another? This <em>is</em> allowed for unions currently, and is a very common use-case (<code>union { char c[4]; int n; } u; u.n=1234; cout &lt;&lt; u.c[1];</code>).</li>\n<li>How does the compiler know which destructor to call?</li>\n<li>How does the compiler know which copy-constructor to call when copying a union?</li>\n</ol>\n<p>(Have I left anything out?)</p>\n<p>I suspect it just went into the too-hard basket.</p>\n", "LastActivityDate": "2010-12-09T10:46:43.747", "Score": "2", "CreationDate": "2010-12-09T10:46:43.747", "ParentId": "4397019", "CommentCount": "3", "OwnerUserId": "9990"}, "4397019": {"ViewCount": "6212", "Body": "<p>I may be mistaken, but the basic explanation I've found has been that the union can't initialize because it doesn't know which member's constructor to call. The compiler can not automatically generate a constructor for the union.</p>\n<p>Why is the user not allowed to define the unions constructor? This would remove said issue and allow the presence of union members that have a non-trivial constructor/destructor.</p>\n<p>Also, why can't a union member have <em>any</em> custom constructors? The previous explanation doesn't stand for custom constructors.</p>\n<p>Update 1:</p>\n<p>Example:</p>\n<pre><code>struct SQuaternion\n{\n    union\n    {\n        S3DVector Axis;\n        struct\n        {\n            float X;\n            float Y;\n            float Z;\n        };\n    };\n    float W;\n};\n</code></pre>\n<p>Note: The issue here seems to be that the union is anonymous. As such, how would one name the constructor of the union? It seems impossible to do so, merely because it has no name, and for no other reason. It'd be a terrible reason if it was a simple lexical issue...</p>\n<p>Update 2:\nSimply by wrapping the offending member in an enclosing anonymous structure, the error disappears. I suppose this is the closest thing one can do with an anonymous union. The fact that it ceases to be an issue still seems strange...</p>\n", "AcceptedAnswerId": "4397228", "Title": "Why can't anonymous unions contain members with non-trivial constructors/destructors?", "CreationDate": "2010-12-09T10:09:43.827", "Id": "4397019", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-01T16:16:24.150", "LastEditorUserId": "718379", "LastActivityDate": "2012-10-01T16:16:24.150", "Score": "5", "OwnerUserId": "420116", "Tags": "<c++><membership><unions>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_4397019_4397125_0": {"length": 26, "quality": 0.5777777777777777, "section_id": 5914}}, "n3337": {"so_4397019_4397125_0": {"length": 25, "quality": 0.5555555555555556, "section_id": 5686}}, "n4659": {"so_4397019_4397125_0": {"length": 26, "quality": 0.5777777777777777, "section_id": 7406}}}, "4397228": {"Id": "4397228", "PostTypeId": "2", "Body": "<p>A bigger reason would be: how would the union know which <strong>destructor</strong> to call. The language itself doesn't track which member is active in a union.</p>\n<p>It seems that C++0x will allow non-trivial types in unions, in which case you'll be forced to implement your own constructor(s) and destructor. (The latter is a little unclear from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf\" rel=\"noreferrer\">proposal</a>, it seems that the union destructor will not call any member destructors and the destructor for the right one would have to be invoked manually.) </p>\n", "LastActivityDate": "2010-12-09T10:32:07.010", "Score": "13", "CreationDate": "2010-12-09T10:32:07.010", "ParentId": "4397019", "CommentCount": "1", "OwnerUserId": "219972"}, "4397125": {"Id": "4397125", "PostTypeId": "2", "Body": "<p>You've heard right - non-trivial constructors for members suggest the object is meant to encapsulate its data content, and unions remove that encapsulation.  Putting a union of simple types into a class is a great way to add encapsulation, and make sure the union content is used in a sensible, safe way.</p>\n<p>Re unions having members: from 9.5</p>\n<blockquote>\n<p id=\"so_4397019_4397125_0\">A union can have member functions (including constructors and destructors), but not virtual (10.3) functions. A union shall not have base classes. A union shall not be used as a base class.An object of a class with a non-trivial constructor (12.1), a non-trivial copy constructor (12.8), a non-trivial destructor (12.4), or a non-trivial copy assignment operator (13.5.3, 12.8) cannot be a member of a union, nor can an array of such objects</p>\n</blockquote>\n", "LastActivityDate": "2010-12-09T10:23:06.160", "Score": "0", "CreationDate": "2010-12-09T10:23:06.160", "ParentId": "4397019", "CommentCount": "3", "OwnerUserId": "410767"}, "4397053": {"Id": "4397053", "PostTypeId": "2", "Body": "<p>This code seems to work fine for me:</p>\n<pre><code>typedef union uAA {\n    double dVal;\n    int iVal[2];\n\n    uAA() : dVal(3.22) {}\n} UAA;\n\nmain() {\n    UAA rdata;\n\n    printf(\"Array output: %d %d \\nDouble output: %lf \\n\",\n        rdata.iVal[0], rdata.iVal[1], rdata.dVal);\n}\n</code></pre>\n", "LastActivityDate": "2010-12-09T10:14:02.490", "Score": "0", "CreationDate": "2010-12-09T10:14:02.490", "ParentId": "4397019", "CommentCount": "4", "OwnerUserId": "63832"}, "4397939": {"Id": "4397939", "PostTypeId": "2", "Body": "<p>I think you're right, unions in C++ are under-featured. They're pretty much a straight copy of unions from C, which means that they don't serve as variant types <em>for C++</em>.</p>\n<p>There's no simple way for <code>union</code> in C++ to represent a proper variant type. Consider the following code, if it were legal:</p>\n<pre><code>union X {\n    int i;\n    std::string s;\n};\n\nX x;\nx.s = \"Hello\";\nx.i = 23;\n</code></pre>\n<p>No amount of constructors or destructors for X is going to ensure that the assignment in the final line calls <code>~string</code> before storing <code>23</code>. For the compiler to do it, the union would have to contain some kind of indicator what type is stored. That's why everything must be POD. I don't know the reasons for the differences between named and unnamed unions, though, this applies to both.</p>\n<p>Perhaps C++ unions <em>could</em> have been defined to be like C unions if all their members are POD, but to contain this extra information, and call the correct destructors at the correct times, if any member is non-POD. But this isn't the simple change you proposed.</p>\n<p>You can somewhat laboriously write a variant type by writing a class which has a value to indicate the type currently stored, and then the constructors, copy assignment operator, and destructor that you would have put in your union, had you been allowed.</p>\n<p>Use a char array for storage, placement new for construction/assignment, and a direct call to the correct destructor in your destructor.</p>\n<p>Beware of the alignment issue - you need to ensure that your raw storage is adequately aligned for any of the types you place in it. One way to do this is to dynamically allocate it. Another is to put your char array into a union with whatever built-in type has the greatest alignment requirement (if you don't know: all of them).</p>\n<p>The only thing that's different in usage, from the union you want, is that instead of public data members <code>int a</code>, <code>float b</code>, <code>string c</code>, you'll have to provide accessors that return a proxy object (possibly a reference to the object itself), that is capable of assigning correctly, which means calling the destructor for the old type first. Then you can write <code>x.i() = 23</code> instead of <code>x.i = 23</code>.</p>\n<p>Or, you can use <a href=\"http://www.boost.org/doc/libs/1_45_0/doc/html/boost/variant.html\" rel=\"nofollow\">Boost.Variant</a>.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2010-12-09T12:18:06.910", "Score": "1", "CreationDate": "2010-12-09T11:59:57.107", "ParentId": "4397019", "CommentCount": "2", "LastEditDate": "2010-12-09T12:18:06.910", "OwnerUserId": "13005"}});