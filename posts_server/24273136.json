post_cb({"24273136": {"CommentCount": "9", "ViewCount": "373", "CreationDate": "2014-06-17T20:56:14.810", "LastActivityDate": "2014-06-17T20:56:14.810", "Title": "Why lambda in static initializer can't access private members of class in VC++2013?", "PostTypeId": "1", "Id": "24273136", "Score": "3", "Body": "<p>Consider the following piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass foo {\n  int var = 99;\npublic:\n  static int const i;\n};\n\nint const foo::i = [&amp;] { return foo().var; }();\n\nauto main() -&gt; int {\n  std::cout &lt;&lt; foo::i &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>Considering the standard <em>\u00a7 9.4.2/2 Static data members [class.static.data]:</em> </p>\n<blockquote>\n<p id=\"so_24273136_24273136_0\"><em>The initializer expression in the\n  de\ufb01nition of a <code>static</code> data member is in the scope of its class.</em></p>\n</blockquote>\n<p>and</p>\n<p><em>\u00a7 5.1.2/2&amp;3 Lambda expressions [expr.prim.lambda]:</em></p>\n<blockquote>\n<p id=\"so_24273136_24273136_1\"><em><code>2</code> The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the closure object. A lambda-expression shall not appear in an unevaluated operand (Clause 5). [ Note: A closure object behaves like a function object (20.9).-end note]</em></p>\n<p id=\"so_24273136_24273136_2\"><em><code>3</code> The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed nonunion class type - called the closure type - whose properties are described below. This class type is not an aggregate (8.5.1). The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding lambda-expression.</em></p>\n</blockquote>\n<p>We end up to conclusion that the lambda in the expression:</p>\n<pre><code>int const foo::i = [&amp;] { return foo().var; }();\n</code></pre>\n<p>can rightfully access <code>private</code> members of <code>class foo</code> since it is declared and defined in the initializer expression of the <code>static</code> member <code>i</code> of <code>class foo</code>, and as such its scope is the scope of <code>class foo</code>.</p>\n<p>The code compiles and runs fine in <a href=\"http://coliru.stacked-crooked.com/a/a7073be1d776f245\" rel=\"nofollow\">GCC v4.8</a> and <a href=\"http://coliru.stacked-crooked.com/a/1921536756f846c6\" rel=\"nofollow\">Clang v3.4</a>., however it fails to compile in VC++2013 producing a compiler error:</p>\n<blockquote>\n<p id=\"so_24273136_24273136_3\"><em>error C2248: 'foo::var' : cannot access private member declared in class 'foo'</em></p>\n</blockquote>\n<p><strong>Question:</strong></p>\n<ul>\n<li>Is the above recorded behaviour of VC++2013 a bug, or it is attribute to specific VC++2013 behaviour that could be altered by changing specific compiler settings?</li>\n</ul>\n", "Tags": "<c++><visual-c++><c++11><lambda><visual-studio-2013>", "OwnerUserId": "2352671", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_24273136_24273136_0": {"section_id": 5907, "quality": 0.8, "length": 8}, "so_24273136_24273136_1": {"section_id": 5961, "quality": 0.7307692307692307, "length": 19}, "so_24273136_24273136_2": {"section_id": 5962, "quality": 0.868421052631579, "length": 33}}, "n3337": {"so_24273136_24273136_0": {"section_id": 5679, "quality": 0.8, "length": 8}, "so_24273136_24273136_1": {"section_id": 5730, "quality": 0.7307692307692307, "length": 19}, "so_24273136_24273136_2": {"section_id": 5731, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_24273136_24273136_0": {"section_id": 7389, "quality": 0.8, "length": 8}, "so_24273136_24273136_1": {"section_id": 7448, "quality": 0.5769230769230769, "length": 15}}}});