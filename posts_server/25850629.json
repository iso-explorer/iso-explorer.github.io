post_cb({"25850776": {"Id": "25850776", "PostTypeId": "2", "Body": "<p>Replace</p>\n<pre><code>std::unique_ptr&lt;Foo_impl&gt; m_impl = nullptr;\n</code></pre>\n<p>with</p>\n<pre><code>std::unique_ptr&lt;Foo_impl&gt; m_impl;\n</code></pre>\n<p>to fix the error.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2014-09-15T14:55:40.010", "Score": "3", "CreationDate": "2014-09-15T14:47:00.350", "ParentId": "25850629", "CommentCount": "11", "LastEditDate": "2014-09-15T14:55:40.010", "OwnerUserId": "2684539"}, "25850680": {"Id": "25850680", "PostTypeId": "2", "Body": "<p>The implementation of <code>Foo_impl</code> must be complete prior to the instantiation required in <code>std::unique_ptr&lt;Foo_impl&gt; m_impl = nullptr</code>.</p>\n<p>Leaving the type declared (but not initialised) will fix the error (<code>std::unique_ptr&lt;Foo_impl&gt; m_impl;</code>), you would then need to initialise it later on in the code.</p>\n<p>The error you are seeing is from the implementation of a technique used to test for this; the incomplete type. Basically, <code>sizeof</code> will result in an error with types that are only forward declared (i.e. lack definition when used at that point in the code/compilation).</p>\n<p>A possible fix here would look like;</p>\n<pre><code>class Foo_impl;\n\nclass Foo\n{\n  // redacted\n  public:\n    Foo();\n    ~Foo();\n\n  private:\n    Foo(const Foo&amp;);\n    Foo&amp; operator=(const Foo&amp;);\n\n    std::unique_ptr&lt;Foo_impl&gt; m_impl;// = nullptr;\n};\n\nclass Foo_impl {\n  // ...\n};\n\nFoo::Foo() : m_impl(nullptr)\n{\n}\n</code></pre>\n<p><strong>Why is the complete type required?</strong></p>\n<p>The instantiation via <code>= nullptr</code> uses <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow noreferrer\">copy initialisation</a> and requires the constructor and destructor to be declared (for <code>unique_ptr&lt;Foo_impl&gt;</code>). The destructor requires the deleter function of the <code>unique_ptr</code> which, by default, calls <code>delete</code> on the pointer to <code>Foo_impl</code> hence it requires the destructor of <code>Foo_impl</code>, and the destructor of <code>Foo_impl</code> is not declared in the incomplete type (the compiler doesn't know what it looks like). See <a href=\"https://stackoverflow.com/a/25853985/3747990\">Howard's answer</a> on this as well. </p>\n<p>Key here is that <strong>calling <code>delete</code> on an incomplete type results in undefined behaviour</strong> (\u00a7 5.3.5/5) and hence is explicitly checked for in the implementation of <code>unique_ptr</code>.</p>\n<p>Another alternative for this situation may be to use <strong>direct initialisation</strong> as follows;</p>\n<pre><code>std::unique_ptr&lt;Foo_impl&gt; m_impl { nullptr };\n</code></pre>\n<p>There seems to be some debate on the <strong>non-static data member initialiser</strong> (NSDMI) and whether this is <em>a context that requires the member definition to exist</em>, at least for clang (and possibly gcc), this seems to be such a context.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-20T19:51:00.577", "Score": "10", "CreationDate": "2014-09-15T14:42:59.610", "ParentId": "25850629", "CommentCount": "27", "LastEditDate": "2017-05-23T12:34:08.020", "OwnerUserId": "3747990"}, "25852676": {"Id": "25852676", "PostTypeId": "2", "Body": "<p>N3936 [temp.inst]/2 states:</p>\n<blockquote>\n<p id=\"so_25850629_25852676_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.</p>\n</blockquote>\n<p>So this question really comes down to whether or not a declaration with a non-static data member initializer (NSDMI) constitutes \"a context that requires the member definition to exist\" with respect to the destructor of that member's type. While it's clear that the <em>declarations</em> of the type's constructor are immediately required to determine if the NSDMI is of an appropriate type to initialize the member, I would say the <em>definitions</em> of the constructor/destructor are required only by the constructor/destructor of the enclosing type and that the implementations are non-conforming.</p>\n<p>That said, there several issues with the semantics of NSDMI that are currently being reviewed by the core language group:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1351\" rel=\"nofollow\">1351. Problems with implicitly-declared exception-specifications</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1360\" rel=\"nofollow\">1360 <code>constexpr</code> defaulted default constructors</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1396\" rel=\"nofollow\">1396. Deferred instantiation and checking of non-static data member initializers</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1397\" rel=\"nofollow\">1397. Class completeness in non-static data member initializers</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1621\" rel=\"nofollow\">1621. Member initializers in anonymous unions</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1623\" rel=\"nofollow\">1623. Deleted default union constructor and member initializers</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1632\" rel=\"nofollow\">1632. Lambda capture in member initializers</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1633\" rel=\"nofollow\">1633. Copy-initialization in member initialization</a></li>\n</ul>\n<p>so it's not suprising that there is confusion here.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2014-09-15T17:45:47.013", "Score": "1", "CreationDate": "2014-09-15T16:32:08.783", "ParentId": "25850629", "CommentCount": "6", "LastEditDate": "2014-09-15T17:45:47.013", "OwnerUserId": "923854"}, "25853985": {"Id": "25853985", "PostTypeId": "2", "Body": "<p>The statement:</p>\n<pre><code>std::unique_ptr&lt;Foo_impl&gt; m_impl = nullptr;\n</code></pre>\n<p>invokes <em>copy-initialization</em>.  This has the same semantics as:</p>\n<pre><code>std::unique_ptr&lt;Foo_impl&gt; m_impl = std::unique_ptr&lt;Foo_impl&gt;(nullptr);\n</code></pre>\n<p>I.e. it constructs a temporary prvalue.  This temporary prvalue must be destructed.  And that destructor needs to see the complete type of <code>Foo_impl</code>.  Even if the prvalue and move construction is elided, the compiler must behave \"as if\".</p>\n<p>You can instead use <em>direct-initialization</em>, and the <code>unique_ptr</code> destructor will no longer be required at this point:</p>\n<pre><code>std::unique_ptr&lt;Foo_impl&gt; m_impl{nullptr};\n</code></pre>\n<p><strong>Update</strong></p>\n<p><a href=\"https://stackoverflow.com/users/923854/casey\">Casey</a> points out that gcc-4.9 currently instantiates <code>~unique_ptr()</code> even for the direct-initialization form.  However in my tests clang does not.  I do not know what other compilers may do.  I <em>believe</em> that clang is conforming in this regard, at least with the most recent core defect reports factored in.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-15T18:29:05.030", "Score": "9", "CreationDate": "2014-09-15T17:56:51.273", "ParentId": "25850629", "CommentCount": "5", "LastEditDate": "2017-05-23T11:53:20.017", "OwnerUserId": "576911"}, "bq_ids": {"n4140": {"so_25850629_25852676_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 234}}, "n3337": {"so_25850629_25852676_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 227}}, "n4659": {"so_25850629_25852676_0": {"length": 41, "quality": 0.9534883720930233, "section_id": 244}}}, "25850629": {"ViewCount": "2427", "Body": "<p>I already checked out the questions <a href=\"https://stackoverflow.com/questions/13414652/forward-declaration-with-unique-ptr\">here</a> and <a href=\"https://stackoverflow.com/questions/9020372/how-do-i-use-unique-ptr-for-pimpl\">here</a>, but still cannot figure out what is wrong.</p>\n<p>This is the calling code:</p>\n<pre><code>#include \"lib.h\"\n\nusing namespace lib;\n\nint\nmain(const int argc, const char *argv[]) \n{\n    return 0;\n}\n</code></pre>\n<p>This is the lib code:</p>\n<pre><code>#ifndef lib_h\n#define lib_h\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nnamespace lib\n{\n\nclass Foo_impl;\n\nclass Foo\n{\n    public:\n        Foo();\n        ~Foo();\n\n    private:\n        Foo(const Foo&amp;);\n        Foo&amp; operator=(const Foo&amp;);\n\n        std::unique_ptr&lt;Foo_impl&gt; m_impl = nullptr;\n\n        friend class Foo_impl;\n};\n\n} // namespace\n\n#endif\n</code></pre>\n<p>clang++ gives me this error:</p>\n<blockquote>\n<p id=\"so_25850629_25850629_0\">invalid application of 'sizeof' to an incomplete type 'lib::Foo_impl'\n  <br/>note: in instantiation of member function 'std::default_delete::operator()' requested</p>\n</blockquote>\n<p>You can see I already specifically declared Foo destructor. What else am I missing here?</p>\n", "AcceptedAnswerId": "25850680", "Title": "unique_ptr, pimpl/forward declaration and complete definition", "CreationDate": "2014-09-15T14:40:13.197", "Id": "25850629", "CommentCount": "10", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:20.017", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-20T19:51:00.577", "Score": "15", "OwnerUserId": "996371", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "4"}});