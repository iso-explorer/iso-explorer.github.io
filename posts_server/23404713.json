post_cb({"bq_ids": {"n4140": {"so_23404713_23404835_1": {"length": 41, "quality": 0.8541666666666666, "section_id": 5425}, "so_23404713_23404950_0": {"length": 9, "quality": 0.9, "section_id": 5417}, "so_23404713_23404835_0": {"length": 15, "quality": 0.9375, "section_id": 5417}}, "n3337": {"so_23404713_23404835_1": {"length": 46, "quality": 0.9583333333333334, "section_id": 5220}, "so_23404713_23404950_0": {"length": 9, "quality": 0.9, "section_id": 5212}, "so_23404713_23404835_0": {"length": 15, "quality": 0.9375, "section_id": 5212}}, "n4659": {"so_23404713_23404950_0": {"length": 7, "quality": 0.7, "section_id": 6839}, "so_23404713_23404835_0": {"length": 12, "quality": 0.75, "section_id": 6839}}}, "23404948": {"Id": "23404948", "PostTypeId": "2", "Body": "<pre><code>struct Parameters {\n  static constexpr int n = 2;\n  static constexpr double v[n] = {4.0, 5.0};\n};\n\nint main() {\n  constexpr int a = Parameters::v[0];\n  return 0;\n}\n</code></pre>\n<p>This code on gcc 4.8.2 compiles into the following:</p>\n<pre><code>0000000000000000 &lt;main&gt;:\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   4:   c7 45 fc 04 00 00 00    mov    DWORD PTR [rbp-0x4],0x4\n   b:   b8 00 00 00 00          mov    eax,0x0\n  10:   5d                      pop    rbp\n  11:   c3                      ret \n</code></pre>\n<p>So yes, it is a compile time constant.</p>\n<p>clang 3.4 produces similar code:</p>\n<pre><code>0000000000000000 &lt;main&gt;:\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   4:   b8 00 00 00 00          mov    eax,0x0\n   9:   c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0\n  10:   c7 45 f8 04 00 00 00    mov    DWORD PTR [rbp-0x8],0x4\n  17:   5d                      pop    rbp\n  18:   c3                      ret\n</code></pre>\n<p>Again, it is a compile time constant.</p>\n<p>Everything was compiled with -O0.</p>\n<p>P.S.: If a is declared const, then for gcc nothing changes but for clang does, the value 4 is not mov'ed directly as if was a compile time constant. </p>\n<p>If a is declared neither const or constexpr then both compilers fail to treat Parameters::v[0] as a compile time constant.</p>\n", "LastEditorUserId": "1040690", "LastActivityDate": "2014-05-01T09:46:40.357", "Score": "1", "CreationDate": "2014-05-01T09:13:21.670", "ParentId": "23404713", "CommentCount": "0", "OwnerUserId": "1040690", "LastEditDate": "2014-05-01T09:46:40.357"}, "23404713": {"ViewCount": "1197", "Body": "<p>Is the code fragment</p>\n<pre><code>struct Parameters {\n   static constexpr int n = 2;\n   static constexpr double v[n] = {4.0, 5.0};\n};\n</code></pre>\n<p>legal C++11? And, if so, are <code>Parameters::v[0]</code> and <code>Parameters::v[1]</code> compile time constants or is just the pointer <code>Parameters::v</code> itself a <code>constexpr</code> (whatever that would mean at compile time)?</p>\n<p>As you can see I am generally a bit confused about <code>constexpr</code> arrays and their initialization in classes/structs. Please feel free to not only answer my specific question but also to mention common pitfalls and the like concerning this topic.</p>\n", "AcceptedAnswerId": "23404835", "Title": "Are constexpr array members compile time constants?", "CreationDate": "2014-05-01T08:54:14.577", "Id": "23404713", "CommentCount": "4", "LastEditDate": "2014-05-01T08:56:17.633", "PostTypeId": "1", "LastEditorUserId": "718379", "LastActivityDate": "2014-05-01T09:46:40.357", "Score": "17", "OwnerUserId": "2663392", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "23404950": {"Id": "23404950", "PostTypeId": "2", "Body": "<pre><code>struct Parameters {\n   static constexpr int n = 2;\n   static constexpr double v[n] = {4.0, 5.0};\n};\n</code></pre>\n<p>This fragment by itself is certainly legal as far as I can tell. Section 7.1.5 [dcl.constexpr] of the C++11 standard says that</p>\n<blockquote>\n<p id=\"so_23404713_23404950_0\">The constexpr specifier shall be applied only to... the declaration of a static data member of a literal type</p>\n</blockquote>\n<p>and a <em>literal type</em> is defined in 3.9:</p>\n<blockquote>\n<p id=\"so_23404713_23404950_1\">A type is a literal type if it is:</p>\n<p id=\"so_23404713_23404950_2\">\u2014 a scalar type; or...</p>\n<p id=\"so_23404713_23404950_3\">\u2014 an array of literal type</p>\n</blockquote>\n<p>So <code>static constexpr double v[2] = { ... }</code> is certainly valid as far as I can tell.</p>\n<p>As to whether the members of the array are <code>constexpr</code>... I'm not sure. If we declare</p>\n<pre><code>constexpr double d = Parameter::v[1];\n</code></pre>\n<p>then both g++ and clang compile it okay, but the clang version fails to link with an undefined reference to <code>Parameters::v</code>. I don't know whether this points to a Clang bug, or whether the construct is invalid.</p>\n", "LastEditorUserId": "2797826", "LastActivityDate": "2014-05-01T09:19:30.283", "Score": "2", "CreationDate": "2014-05-01T09:13:28.643", "ParentId": "23404713", "CommentCount": "3", "OwnerUserId": "2797826", "LastEditDate": "2014-05-01T09:19:30.283"}, "23404835": {"Id": "23404835", "PostTypeId": "2", "Body": "<p>I see no problem with the construct. Quoting C++11, <code>[dcl.constexpr]</code>:</p>\n<blockquote>\n<p id=\"so_23404713_23404835_0\">\u00a71 The <code>constexpr</code> specifier shall be applied only to the definition of a variable, the declaration of a function or\n  function template, or the declaration of a static data member of a literal type (3.9). ...</p>\n<p id=\"so_23404713_23404835_1\">\u00a79 A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have\n  literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant\n  expression (5.19). Otherwise, or if a constexpr specifier is used in a reference declaration, every full-expression\n  that appears in its initializer shall be a constant expression. Each implicit conversion used in\n  converting the initializer expressions and each constructor call used for the initialization shall be one of those\n  allowed in a constant expression (5.19).</p>\n</blockquote>\n<p><code>double</code> is a literal type, and so is an array of literal types. Which means that <code>v[0]</code> and <code>v[1]</code> from your code are indeed constant expressions.</p>\n", "LastActivityDate": "2014-05-01T09:05:33.043", "CommentCount": "0", "CreationDate": "2014-05-01T09:05:33.043", "ParentId": "23404713", "Score": "4", "OwnerUserId": "1782465"}});