post_cb({"bq_ids": {"n4140": {"so_46205151_46205275_0": {"length": 58, "quality": 0.8787878787878788, "section_id": 6037}}, "n3337": {"so_46205151_46205275_0": {"length": 57, "quality": 0.8636363636363636, "section_id": 5805}}, "n4659": {"so_46205151_46205275_0": {"length": 64, "quality": 0.9696969696969697, "section_id": 7536}}}, "46205275": {"Id": "46205275", "PostTypeId": "2", "Body": "<p>This is reasonably straightforward in <a href=\"http://eel.is/c++draft/expr.static.cast#11\" rel=\"nofollow noreferrer\">[expr.static.cast]/11</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_46205151_46205275_0\"><strong>A prvalue of type \u201cpointer to cv1 B\u201d, where B is a class type, can be converted to a prvalue of type \u201cpointer to cv2 D\u201d, where D is a class derived from B</strong>, if cv2 is the same cv-qualification as, or greater cv-qualification than, cv1. If B is a virtual base class of D or a base class of a virtual base class of D, or if no valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists ([conv.ptr]), the program is ill-formed. The null pointer value is converted to the null pointer value of the destination type. <strong>If the prvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object of type D. Otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n<p>You don't have a subobject of a <code>Derived</code>, so it's undefined behaviour.</p>\n<hr>\n<p>Note there are no special cases for lvalue or xvalue pointers, and /8 mentions that the operand undergoes an lvalue-to-rvalue conversion.</p>\n</hr>", "LastEditorUserId": "962089", "LastActivityDate": "2017-09-13T19:31:53.263", "Score": "11", "CreationDate": "2017-09-13T19:16:42.447", "ParentId": "46205151", "CommentCount": "0", "OwnerUserId": "962089", "LastEditDate": "2017-09-13T19:31:53.263"}, "46205151": {"ViewCount": "68", "Body": "<p>Is the following C++ code correct?</p>\n<pre><code>struct Base { int x; };\nstruct Derived : Base { int y; }\nBase * b = new Base;\nDerived * d = static_cast&lt;Derived *&gt;(b);\n//below we access only d-&gt;x, but not d-&gt;y\nstd::cout &lt;&lt; d-&gt;x;\n</code></pre>\n<p>If not, what exactly is wrong? What C++ standard say about this? At least I have not seen it ever crashed.</p>\n", "AcceptedAnswerId": "46205275", "Title": "Accessing base class members with incorrect downcast in C++", "CreationDate": "2017-09-13T19:09:29.030", "Id": "46205151", "CommentCount": "7", "LastEditDate": "2017-09-13T19:20:33.170", "PostTypeId": "1", "LastEditorUserId": "4581301", "LastActivityDate": "2017-09-13T19:31:53.263", "Score": "2", "OwnerUserId": "8035619", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});