post_cb({"15065810": {"ParentId": "15064535", "CommentCount": "2", "Body": "<p>The problem is that <code>as</code> is injected into the scope of <code>template&lt;...&gt; struct as</code> as both a class and a template name; this is why gcc complains \"<code>invalid use of \u2018struct as&lt;T&gt;\u2019</code>\".</p>\n<p>I'm not quite sure whether gcc is correct (it's down to the rules for name lookup on member expressions), but the workaround is to use <code>decltype</code>:</p>\n<pre><code>    return u[ 0 ].decltype(u[ 0 ])::template as&lt; T &gt;();\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "15065810", "Score": "1", "CreationDate": "2013-02-25T11:22:04.697", "LastActivityDate": "2013-02-25T11:22:04.697"}, "15064535": {"CommentCount": "8", "ViewCount": "412", "PostTypeId": "1", "LastEditorUserId": "2073257", "CreationDate": "2013-02-25T10:11:46.380", "LastActivityDate": "2013-02-25T15:32:08.117", "Title": "Verify bug in GCC", "AcceptedAnswerId": "15066266", "LastEditDate": "2013-02-25T15:32:08.117", "Id": "15064535", "Score": "10", "Body": "<p>I'd like to verify that the following is a bug in GCC and not in my understanding of C++. Consider the following code:</p>\n<pre><code>struct A\n{\n    struct B\n    {\n        template&lt; typename U &gt; U as() const { return U(); }\n    };\n\n    B operator[]( int ) const { return B(); }\n};\n\ntemplate&lt; typename T &gt;\nstruct as\n{\n    template&lt; typename U &gt;\n    static T call( const U&amp; u )\n    {\n        return u[ 0 ].as&lt; T &gt;(); // accepted by Clang 3.2, rejected by GCC 4.7\n        // return u[ 0 ].template as&lt; T &gt;(); // does not help and is IMHO not needed\n        // return u[ 0 ].A::B::as&lt; T &gt;(); // accepted by GCC 4.7\n    }\n};\n\nint main()\n{\n    as&lt; int &gt;::call( A() );\n}\n</code></pre>\n<p>IMHO the code should be fine, it is accepted by Clang 3.2, but not by GCC 4.7 (4.4 and 4.6 also fail with basically the same error but 4.4 produces a slightly different message). Here's the output from my shell:</p>\n<pre><code>$ clang++-3.2 -O3 -Wall -Wextra -std=c++0x t.cc -o t\n$ g++-4.7 -O3 -Wall -Wextra -std=c++0x t.cc -o t\nt.cc: In static member function \u2018static T as&lt;T&gt;::call(const U&amp;)\u2019:\nt.cc:17:21: error: invalid use of \u2018struct as&lt;T&gt;\u2019\nt.cc: In static member function \u2018static T as&lt;T&gt;::call(const U&amp;) [with U = A; T = int]\u2019:\nt.cc:18:4: warning: control reaches end of non-void function [-Wreturn-type]\n$ \n</code></pre>\n<p><strong>Question:</strong> Is this a bug in GCC or am I missing something?</p>\n<p><strong>EDIT:</strong> I'm a bit confused: The GCC bug report at <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55576\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55576</a> says at comment #9 that the code in comment #3 is \"valid\". What exactly does this mean? It looks like the GCC folks think that it actually <em>is</em> a bug, otherwise they would have closed it already? OTOH the answer from @Potatoswatter seems to be quite clear that it should be correct and I should file a bug report against Clang (or is there already such a bug report?)</p>\n<p>Note that I hesitate to mark an answer as accepted until the above is clarified. Since both answers are already helpful (one to explain, one to work-around), I gave both an upvote.</p>\n<p>Bonus question: Since I got a downvote for non-narrative code, I wonder how others feel. I tried to create a SCCEE which removes all distractions and concentrates on the technical issue. That's how I prefer thinking about these things. Is that wrong?</p>\n<p>Also, @EdHeal: Why is the code prone to disaster? (You don't think that is the real-world code I have, right?)</p>\n<p><strong>EDIT2:</strong> Thanks, David, just noticed your edit. I'll mark your answer as accepted now and I also saw that you commented on the GCC bug report. I think the main point of this question is thereby answered and GCC got another reminder. Thanks everyone.</p>\n", "Tags": "<c++><templates><gcc><c++11>", "OwnerUserId": "2073257", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15064535_15066266_1": {"section_id": 126, "quality": 0.625, "length": 5}, "so_15064535_15066266_3": {"section_id": 4706, "quality": 0.5333333333333333, "length": 8}, "so_15064535_15066266_2": {"section_id": 194, "quality": 0.5333333333333333, "length": 8}, "so_15064535_15066266_0": {"section_id": 7126, "quality": 0.6923076923076923, "length": 36}, "so_15064535_15066266_4": {"section_id": 7126, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_15064535_15066266_1": {"section_id": 120, "quality": 0.625, "length": 5}, "so_15064535_15066266_4": {"section_id": 6870, "quality": 0.9411764705882353, "length": 16}, "so_15064535_15066266_2": {"section_id": 188, "quality": 0.5333333333333333, "length": 8}, "so_15064535_15066266_0": {"section_id": 6870, "quality": 0.6923076923076923, "length": 36}, "so_15064535_15066266_3": {"section_id": 188, "quality": 0.5333333333333333, "length": 8}}, "n4659": {"so_15064535_15066266_4": {"section_id": 8627, "quality": 0.9411764705882353, "length": 16}, "so_15064535_15066266_0": {"section_id": 8627, "quality": 0.6923076923076923, "length": 36}, "so_15064535_15066266_1": {"section_id": 131, "quality": 0.625, "length": 5}}}, "15066266": {"ParentId": "15064535", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is a tricky corner of the language. GCC is applying the rule from C++03 \u00a73.4.5/1:</p>\n<blockquote>\n<p id=\"so_15064535_15066266_0\">In a class member access expression (5.2.5), if the <code>.</code> or <code>-&gt;</code> token is immediately followed by an identifier followed by a <code>&lt;</code>, the identifier must be looked up to determine whether the <code>&lt;</code> is the beginning of a template argument list (14.2) or a less-than operator. The identifier is first looked up in the class of the object expression. If the identifier is not found, it is then looked up in the context of the entire postfix-expression and shall name a class or function template. If the lookup in the class of the object expression finds a template, the name is also looked up in the context of the entire postfix-expression and</p>\n<p id=\"so_15064535_15066266_1\">\u2014 if the name is not found, the name found in the class of the object expression is used, otherwise</p>\n<p id=\"so_15064535_15066266_2\">\u2014 if the name is found in the context of the entire postfix-expression and does not name a class template, the name found in the class of the object expression is used, otherwise</p>\n<p id=\"so_15064535_15066266_3\"><strong>\u2014 if the name found is a class template, it must refer to the same entity as the one found in the class of the object expression, otherwise the program is ill-formed.</strong></p>\n</blockquote>\n<p>Note that this process was useless because the <code>template</code> keyword is already required to disambiguate the <code>&lt;</code> token, since the type of the subexpression <code>u[0]</code> depends on a template argument. </p>\n<p>The reason for doing it this way is to simplify parsing in the case that the template-id is used in a nested-name-qualifier, for example <code>u[ 0 ].as&lt; T &gt;::bar.baz</code> where <code>bar</code> is a typedef to a base class.</p>\n<p>C++11 removes the three bullet points simplifies the process to</p>\n<blockquote>\n<p id=\"so_15064535_15066266_4\">The identifier is first looked up in the class of the object expression. If the identifier is not found, it is then looked up in the context of the entire postfix-expression and shall name a class template.</p>\n</blockquote>\n<p>So this is a bug, and not an old one as I had said previously. The name lookup corner case needs to be removed.</p>\n<p>Also, it looks like this quirk could be exploited to allow a single templated expression to alternately refer to a class or a function. Not sure if that's useful, but it's new in C++11.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-02-25T13:54:43.993", "Id": "15066266", "Score": "5", "CreationDate": "2013-02-25T11:47:59.587", "LastActivityDate": "2013-02-25T13:54:43.993"}});