post_cb({"34477383": {"ViewCount": "100", "Body": "<p>I am writing an C++ websocket server library. In one of the examples I have provided I use two classes <code>session_base</code> and <code>session</code>. I do this so that I can have the <code>tcp::socket</code> object in the <code>session_base</code> parent class initialised (using a move constructor) before passing a reference to it to the <code>ws::session&lt;tcp::socket&gt;</code> parent class which stores this reference for later use. The reason I have created ws:session as a template class is so i can use <code>boost::asio::ssl::stream</code>s as well as tcp sockets.</p>\n<p>Would it be valid to have the <code>tcp::socket</code> object a member of the <code>session</code> class, pass a reference to this uninitialised object to the <code>ws::session</code> constructor (which doesn't use the <code>tcp::socket</code> yet - only stores the reference) and then initialise the <code>tcp::socket</code> object afterwards using the socket move constructor?</p>\n<p><strong>Current code:</strong></p>\n<pre><code>using boost::asio::ip::tcp;\n\nclass session_base {\npublic:\n    session_base(tcp::socket socket) : socket_(std::move(socket)) { }\nprotected:\n    tcp::socket socket_;\n};\n\nusing T = tcp::socket;\nclass session : public session_base, public ws::session&lt;T&gt; {\npublic:\n    session(tcp::socket socket) :\n        session_base(std::move(socket)), ws::session&lt;T&gt;(socket_)\n    {\n        std::cout &lt;&lt; \"session()\\n\";\n    }\n\n    ~session() {\n        std::cout &lt;&lt; \"~session()\\n\";\n    }\n\nprivate:\n    void on_open() override {\n        std::cout &lt;&lt; \"WebSocket connection open\\n\";\n    }\n\n    void on_msg(const ws::message &amp;msg) override {\n        /* Do stuff with msg */\n\n        read();\n    }\n\n    void on_close() override {\n        std::cout &lt;&lt; \"WebSocket connection closed\\n\";\n    }\n\n    void on_error() override {\n        std::cout &lt;&lt; \"WebSocket connection error\\n\";\n    }\n};\n</code></pre>\n<p><strong>Proposed code:</strong></p>\n<p>The proposed code below works for me but i am wondering this is defined behaviour and recommended.</p>\n<pre><code>using boost::asio::ip::tcp;\n\nusing T = tcp::socket;\nclass session : public ws::session&lt;T&gt; {\npublic:\n    session(tcp::socket socket) :\n        ws::session&lt;T&gt;(socket_), socket_(std::move(socket))\n    {\n        std::cout &lt;&lt; \"session()\\n\";\n    }\n\n    ~session() {\n        std::cout &lt;&lt; \"~session()\\n\";\n    }\n\nprivate:\n    tcp::socket socket_;\n\n    void on_open() override {\n        std::cout &lt;&lt; \"WebSocket connection open\\n\";\n    }\n\n    void on_msg(const ws::message &amp;msg) override {\n        /* Do stuff with msg */\n\n        read();\n    }\n\n    void on_close() override {\n        std::cout &lt;&lt; \"WebSocket connection closed\\n\";\n    }\n\n    void on_error() override {\n        std::cout &lt;&lt; \"WebSocket connection error\\n\";\n    }\n};\n</code></pre>\n<p>Full source: <a href=\"https://github.com/alexyoung91/ws\" rel=\"nofollow\">https://github.com/alexyoung91/ws</a></p>\n", "AcceptedAnswerId": "34492547", "Title": "Passing a reference to an uninitialised object to a super class constructor and then initialising said object with it's move constructor afterwards?", "CreationDate": "2015-12-27T03:40:21.560", "Id": "34477383", "CommentCount": "2", "LastEditDate": "2015-12-28T03:06:55.773", "PostTypeId": "1", "LastEditorUserId": "605504", "LastActivityDate": "2015-12-28T11:19:20.763", "Score": "0", "OwnerUserId": "605504", "Tags": "<c++><oop><boost>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34477383_34492547_4": {"length": 8, "quality": 0.7272727272727273, "section_id": 7193}, "so_34477383_34492547_3": {"length": 6, "quality": 0.75, "section_id": 6169}, "so_34477383_34492547_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 7194}, "so_34477383_34492547_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 7194}, "so_34477383_34492547_1": {"length": 5, "quality": 1.0, "section_id": 6185}, "so_34477383_34492547_2": {"length": 10, "quality": 1.0, "section_id": 7194}}, "n3337": {"so_34477383_34492547_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 6938}, "so_34477383_34492547_3": {"length": 7, "quality": 0.875, "section_id": 6938}, "so_34477383_34492547_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 6938}, "so_34477383_34492547_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 6938}, "so_34477383_34492547_1": {"length": 5, "quality": 1.0, "section_id": 5946}, "so_34477383_34492547_2": {"length": 10, "quality": 1.0, "section_id": 6938}}, "n4659": {"so_34477383_34492547_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 8702}, "so_34477383_34492547_3": {"length": 6, "quality": 0.75, "section_id": 8539}, "so_34477383_34492547_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 8703}, "so_34477383_34492547_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 8703}, "so_34477383_34492547_1": {"length": 5, "quality": 1.0, "section_id": 7687}, "so_34477383_34492547_2": {"length": 9, "quality": 0.9, "section_id": 8702}}}, "34492547": {"Id": "34492547", "PostTypeId": "2", "Body": "<p>If <code>ws::session</code> constructor only stores a reference to the socket but does not use the reference to, for example, call the socket member functions or access data members then the program is well-formed. The standard calls this a reference to the allocated storage in 3.8/6 ([basic.life/6]):</p>\n<blockquote>\n<p id=\"so_34477383_34492547_0\">Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object\n  occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, such a glvalue refers to allocated storage (3.7.4.2), and using the properties of the glvalue that do not depend on its value is well-defined. The program has undefined behavior if:</p>\n<p id=\"so_34477383_34492547_1\">\u2014 an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</p>\n<p id=\"so_34477383_34492547_2\">\u2014 the glvalue is used to access a non-static data member or call a non-static member function of the object, or</p>\n<p id=\"so_34477383_34492547_3\">\u2014 the glvalue is implicitly converted (4.10) to a reference to a base class type, or</p>\n<p id=\"so_34477383_34492547_4\">\u2014 the glvalue is used as the operand of a <code>static_cast</code> (5.2.9) except when the conversion is ultimately to <em>cv</em> <code>char&amp;</code> or <em>cv</em> <code>unsigned char&amp;</code>, or</p>\n<p id=\"so_34477383_34492547_5\">\u2014 the glvalue is used as the operand of a <code>dynamic_cast</code> (5.2.7) or as the operand of <code>typeid</code>.</p>\n</blockquote>\n<p>Note that the storage must be allocated when the reference is obtained, and that is so when <code>session</code> constructor is invoked.</p>\n<p>But despite that I wouldn't recommend this approach. Mostly because it is easy to forget in the <code>ws::session</code> constructor that the passed reference refers to a not-yet-initialized object and introduce a bug at a later time. Better use the <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Base-from-Member\" rel=\"nofollow\">base-from-member idiom</a> and keep your original code.</p>\n", "LastActivityDate": "2015-12-28T11:19:20.763", "CommentCount": "1", "CreationDate": "2015-12-28T11:19:20.763", "ParentId": "34477383", "Score": "1", "OwnerUserId": "4636534"}});