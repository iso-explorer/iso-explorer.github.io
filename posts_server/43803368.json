post_cb({"43803501": {"ParentId": "43803368", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This is invalid. According to the rule of <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Boolean_conversions\" rel=\"nofollow noreferrer\">boolean conversions</a>:</p>\n<blockquote>\n<p id=\"so_43803368_43803501_0\">A prvalue of type <code>std::nullptr_t</code>, including <code>nullptr</code>, can be converted to a prvalue of type <code>bool</code> in context of direct-initialization. The resulting value is <code>false</code>.</p>\n</blockquote>\n<p>Quotes from the standard, <a href=\"http://eel.is/c++draft/conv.bool#1\" rel=\"nofollow noreferrer\">\u00a77.14/1 Boolean conversions [conv.bool]</a></p>\n<blockquote>\n<p id=\"so_43803368_43803501_1\">For direct-initialization, a prvalue of type <code>std\u200b::\u200bnullptr_\u00adt</code> can be converted to a prvalue of type <code>bool</code>; the resulting value is <code>false</code>.</p>\n</blockquote>\n<p>The conversion is only allowed for <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow noreferrer\">direct-initialization</a>, but not <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow noreferrer\">copy-intialization</a>, which including the case for passing argument to a function by value. e.g.</p>\n<pre><code>bool b1 = nullptr; // invalid\nbool b2 {nullptr}; // valid\n</code></pre>\n<p>So GCC is correct. But Clang is not wrong either; the standard only requires the compiler to \"issue a diagnostic\" when program is ill-formed, so it must tell you something happens, after that it could do anything. </p>\n<p>See <a href=\"https://stackoverflow.com/questions/40807404/does-the-c-standard-specify-that-for-some-cases-the-compiling-should-fail-with\">Does the C++ standard specify that for some cases the compiling should fail with an error?</a></p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:58.683", "Id": "43803501", "Score": "8", "CreationDate": "2017-05-05T11:12:23.830", "LastActivityDate": "2017-05-05T20:23:30.670"}, "bq_ids": {"n4140": {"so_43803368_43803501_1": {"section_id": 44, "quality": 0.9230769230769231, "length": 12}, "so_43803368_43803501_0": {"section_id": 44, "quality": 0.6875, "length": 11}}, "n3337": {"so_43803368_43803501_1": {"section_id": 41, "quality": 0.8461538461538461, "length": 11}, "so_43803368_43803501_0": {"section_id": 41, "quality": 0.625, "length": 10}}, "n4659": {"so_43803368_43803501_1": {"section_id": 45, "quality": 0.9230769230769231, "length": 12}, "so_43803368_43803501_0": {"section_id": 45, "quality": 0.6875, "length": 11}}}, "43803368": {"CommentCount": "0", "ViewCount": "405", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2017-05-05T11:05:12.107", "LastActivityDate": "2017-05-05T20:23:30.670", "Title": "conversion from nullptr_t to bool: valid or not?", "AcceptedAnswerId": "43803501", "LastEditDate": "2017-05-05T13:45:32.280", "Id": "43803368", "Score": "8", "Body": "<p>I tested the following code with 3 compilers and got 3 different results: error, warning and ok.</p>\n<ul>\n<li>GCC (5.3):  error: invalid user-defined conversion from \u2018std::nullptr_t\u2019 to \u2018const Thing&amp;\u2019</li>\n<li>Clang (3.8):  warning: implicit conversion of nullptr constant to 'bool'</li>\n<li>MSVC (14.1): no error, no warning</li>\n</ul>\n<p>Which compiler is correct? I know it's a trivial conversion between a pointer type and <code>bool</code>. But what's about <code>std::nullptr_t</code> and <code>bool</code>?</p>\n<p>(In the end, Clang and MSVC are both fine with the code. Clang is a little bit more verbose in a positive way.)</p>\n<pre><code>struct Thing\n{\n    Thing(bool) {}\n};\n\nvoid addThing(const Thing&amp;){}\n\nint main()\n{\n    addThing(nullptr); // warning or error on this line\n}\n</code></pre>\n", "Tags": "<c++><c++11><compiler-errors><type-conversion><language-lawyer>", "OwnerUserId": "150392", "AnswerCount": "1"}});