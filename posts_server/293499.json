post_cb({"293520": {"ParentId": "293499", "CommentCount": "3", "Body": "<p>Falling off the end of a function that is declared to return a value (without explicitly returning a value) leads to undefined consequences. For gcc, you should start with the <code>-Wall</code> command line switch that turns on most useful warnings. The specific gcc warning that controls the warning you want is <code>-Wreturn-type</code> (which is included in <code>-Wall</code>, I just mention this for completeness).</p>\n<p>Once you have warnings turned on, you should also use <code>-Werror</code> to treat warnings as errors and make the build stop at the point it detects an error.</p>\n", "OwnerUserId": "893", "Id": "293520", "PostTypeId": "2", "OwnerDisplayName": "Greg Hewgill", "Score": "20", "CreationDate": "2008-11-16T04:53:26.500", "LastActivityDate": "2008-11-16T04:53:26.500"}, "293563": {"ParentId": "293499", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_293499_293563_0\">Did another SomeStruct get created and initialized somewhere implicitly?</p>\n</blockquote>\n<p>Think about how the struct is returned. If both <code>x</code> and <code>y</code> are 32 bits, it is too big to fit in a register on a 32-bit architecture, and the same applies to 64-bit values on a 64-bit architecture (@Denton Gentry's answer mentions how simpler values are returned), so it has to be allocated somewhere. It would be wasteful to use the heap for this, so it has to be allocated on the stack. But it cannot be on the stack frame of your <code>getSomeStruct</code> function, since that is not valid anymore after the function returns.</p>\n<p>The compiler instead has the caller tells the called function where to put the result (which is probably somewhere on the stack of the caller), by passing the called function a hidden pointer to the space allocated to it. So, the place where it is being set to zero is on the <em>caller</em>, not on your <code>getSomeStruct</code> function.</p>\n<p>There are also optimizations like the \"named value return optimization\" where extra copies can be elided. So, had you used the missing <code>return</code>, the result would be created directly on the space allocated by the caller, instead of creating a temporary and copying it.</p>\n<p>To know more about what is happening, you have to look at the caller function. Is it initializing (to zero) an \"empty\" <code>SomeStruct</code> to which you later assign the return value of your <code>getSomeStruct</code> function? Or is it doing something else?</p>\n", "OwnerUserId": "28258", "Id": "293563", "PostTypeId": "2", "OwnerDisplayName": "CesarB", "Score": "7", "CreationDate": "2008-11-16T06:15:19.957", "LastActivityDate": "2008-11-16T06:15:19.957"}, "293737": {"ParentId": "293499", "CommentCount": "0", "Body": "<p>You didn't get any warning because you didn't have <code>-Wall -Werror</code> turned on. (As stated in other answers)</p>\n<p>However I think you probably got a zero-filled struct as the result because the stack object was default constructed in the caller function, possibly with explicit zero arguments, or else due to zeros on the stack?</p>\n", "OwnerUserId": "3978", "Id": "293737", "PostTypeId": "2", "OwnerDisplayName": "Douglas Leeder", "Score": "1", "CreationDate": "2008-11-16T09:58:00.100", "LastActivityDate": "2008-11-16T09:58:00.100"}, "293502": {"ParentId": "293499", "CommentCount": "1", "Body": "<p>For me the compiler didn't allow it: <a href=\"http://codepad.org/KkzVCesh\" rel=\"nofollow noreferrer\">http://codepad.org/KkzVCesh</a></p>\n", "OwnerUserId": "37181", "PostTypeId": "2", "Id": "293502", "Score": "2", "CreationDate": "2008-11-16T04:38:41.367", "LastActivityDate": "2008-11-16T04:38:41.367"}, "293499": {"CommentCount": "0", "AcceptedAnswerId": "293563", "PostTypeId": "1", "LastEditorUserId": "2147", "LastEditorDisplayName": "Jason Baker", "CreationDate": "2008-11-16T04:35:06.367", "LastActivityDate": "2008-11-16T18:16:28.563", "AnswerCount": "6", "LastEditDate": "2008-11-16T04:40:43.017", "ViewCount": "3225", "FavoriteCount": "6", "Title": "What happens if you don't return a value in C++?", "Id": "293499", "Score": "14", "Body": "<p>Yesterday, I found myself writing code like this:</p>\n<pre><code>SomeStruct getSomeStruct()\n{\n    SomeStruct input;\n\n    cin &gt;&gt; input.x;\n    cin &gt;&gt; input.y;\n}\n</code></pre>\n<p>Of course forgetting to actually return the struct I just created.  Oddly enough, the values in the struct that <em>was</em> returned by this function got initialized to zero (when compiled using g++ that is).  Is this just a coincidence or did another SomeStruct get created and initialized somewhere implicitly?</p>\n", "Tags": "<c++><g++><return-value>", "OwnerUserId": "2147", "OwnerDisplayName": "Jason Baker"}, "294183": {"ParentId": "293499", "CommentCount": "1", "Body": "<p>I find this interesting.  With default options used, the following compilers have the following behavior when compiling the <code>GetSomeStruct()</code> function:</p>\n<ul>\n<li><p>Microsoft VC, all versions (since VC6 anyway): </p>\n<p><strong><code>error C4716: 'getSomeStruct' : must return a value</code></strong></p></li>\n<li><p>Digital Mars: </p>\n<p><strong><code>Warning 18: implied return of getSomeStruct at closing '}' does not return value</code></strong></p></li>\n<li><p>Comeau: </p>\n<p><strong><code>warning: missing return statement at end of non-void function \"getSomeStruct\"</code></strong></p></li>\n<li><p>gcc: </p>\n<p><strong>no error or warning</strong></p></li>\n</ul>\n<p>Given the following couple of sentences from the standard (6.6.3 Paragraph 2):</p>\n<blockquote>\n<p id=\"so_293499_294183_0\">A return statement without an\n  expression can be used only in\n  functions that do not return a value,\n  that is, a function with the return\n  type void, a constructor (12.1), or a\n  destructor (12.4). ...  Flowing off\n  the end of a function is equivalent to\n  a return with no value; this results\n  in undefined behavior in a\n  value-returning function.</p>\n</blockquote>\n<p>I would say there's little reason for a compiler not to give an error in this case.  Why do so many compilers give only a warning or no diagnostic at all?</p>\n", "OwnerUserId": "12711", "Id": "294183", "PostTypeId": "2", "OwnerDisplayName": "Mike B", "Score": "3", "CreationDate": "2008-11-16T18:15:17.710", "LastActivityDate": "2008-11-16T18:16:28.563"}, "bq_ids": {"n4140": {"so_293499_294183_0": {"section_id": 3913, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_293499_294183_0": {"section_id": 3773, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_293499_294183_0": {"section_id": 4799, "quality": 0.5185185185185185, "length": 14}}}, "293543": {"ParentId": "293499", "CommentCount": "0", "Body": "<p>The calling conventions for most modern CPU architectures specify a particular register to pass a function return value back to the caller. The caller makes the function call, and then uses the specified register as the return value. If you do not explicitly return a value, the caller will nonetheless use whatever garbage happens to be in that register.</p>\n<p>The compiler will also use all registers it has available for internal computation within the function. The register designated for holding the return value will also be used for misc computation within the function. Thus when you forget to specify a return value it is not unusual to find the correct value has miraculously been returned to the caller: the compiler used that register to store your object.</p>\n<p>Unfortunately even a trivial change to the function can cause the register allocation to change, so the return value becomes true garbage.</p>\n", "OwnerUserId": "4761", "Id": "293543", "PostTypeId": "2", "OwnerDisplayName": "Denton Gentry", "Score": "8", "CreationDate": "2008-11-16T05:34:13.143", "LastActivityDate": "2008-11-16T05:34:13.143"}});