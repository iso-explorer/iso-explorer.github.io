post_cb({"bq_ids": {"n4140": {"so_22870454_22870510_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 7153}}, "n3337": {"so_22870454_22870510_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 6897}}, "n4659": {"so_22870454_22870510_0": {"length": 21, "quality": 0.6, "section_id": 8657}}}, "22870454": {"ViewCount": "81", "Body": "<p>I was writing a quick example to demonstrate initialization/destruction of global objects.  In so doing I hit upon the following conundrum.</p>\n<p>Generally speaking, you should not include any headers in a header file that are not required for the code in the header file.  This helps to reduce confusion and compile time.</p>\n<p>In my example I split out the definition of the constructor and destructor from the class definition.  In my case they are so trivial that I would probably just inline them, but this is for an example.</p>\n<p>The translation unit that actually defines the constructor and destructor includes <code>iostream</code> so that it can output calls to the console.</p>\n<p>Where my question comes in is when we start talking about declaring instances of my class at global scope.  Now I am running into initialization order and translation units.  Order of initialization of global variables within a translation unit is well defined.  Order of initialization of global variables from one translation unit to another is less well specified.  In my example it can do one of the following:</p>\n<ul>\n<li>Initialize the first source file, then the second source file.</li>\n<li>Initialize the second source file, then the first source file.</li>\n<li>Initialize the second source file.</li>\n</ul>\n<p>24.4.1/2:\nThe objects <em>[std::cout in my case]</em> are constructed and the associations are established at some time prior to or during the \ufb01rst time an object of class <code>ios_base::Init</code> is constructed, and in any case before the body of main begins execution. The objects are not destroyed during program execution. The results of including <code>&lt;iostream&gt;</code> in a translation unit shall be as if <code>&lt;iostream&gt;</code> de\ufb01ned an instance of <code>ios_base::Init</code> with static storage duration. Similarly, the entire program shall behave as if there were at least one instance of <code>ios_base::Init</code> with static storage duration.</p>\n<p>Note that this paragraph invokes the as if rule, so it doesn't have to create an instance of <code>ios_base::Init</code>, but it must behave as if it did.</p>\n<p>Assuming that the compiler and standard library do behave as specified in the paragraph and do not do something different but equivalent, it would seem that the only initialization order that would be valid for my program is initialize the first source file, then the second source file.  Otherwise std::cout will not have been initialized before attempting to use it.</p>\n<p>Header file:</p>\n<pre><code>#ifndef HEADER_H_\n#define HEADER_H_\n\nstruct A {\n  A(const char*);\n  ~A();\n  const char* v;\n}\n\n#endif\n</code></pre>\n<p>First source file:</p>\n<pre><code>#include \"header.h\"\n#include &lt;iostream&gt;\n\nA::A(const char* val) : v{ val } {\n  std::cout &lt;&lt; v &lt;&lt; \"\\n\";\n}\n~A() {\n  std::cout &lt;&lt; \"~\" &lt;&lt; v &lt;&lt; \"\\n\";\n}\n\nA a{ \"a\" };\nA b{ \"b\" };\n</code></pre>\n<p>Second source file:</p>\n<pre><code>#include \"header.h\"\n\nA c{ \"c\" };\nA d{ \"d\" };\n\nint main() {\n}\n</code></pre>\n", "Title": "What files must iostream be included in?", "CreationDate": "2014-04-04T18:31:02.397", "LastActivityDate": "2014-04-04T18:39:28.730", "CommentCount": "1", "PostTypeId": "1", "Id": "22870454", "Score": "0", "OwnerUserId": "2012007", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "22870510": {"Id": "22870510", "PostTypeId": "2", "Body": "<p>In writing this question I realized that the answer is contained in 3.6.2/4.</p>\n<blockquote>\n<p id=\"so_22870454_22870510_0\">It is implementation-de\ufb01ned whether the dynamic initialization of a non-local variable with static storage duration is done before the \ufb01rst statement of main. If the initialization is deferred to some point in time after the \ufb01rst statement of main, it shall occur before the first odr-use of any function or variable de\ufb01ned in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>This means that even if it decides to just initialize the second source file, that the call to the constructor of <code>c</code> will cause the first source file to be initialized before it actually executes the constructor for <code>c</code>.  This guarantees that the order that static initialization finishes is:</p>\n<ol>\n<li><code>ios_base::Init</code></li>\n<li><code>a</code></li>\n<li><code>b</code></li>\n<li><code>c</code></li>\n<li><code>d</code></li>\n</ol>\n<p>Since there is no ambiguity to initialization order, there is no problem.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2014-04-04T18:39:28.730", "Score": "0", "CreationDate": "2014-04-04T18:34:44.313", "ParentId": "22870454", "CommentCount": "0", "OwnerUserId": "2012007", "LastEditDate": "2014-04-04T18:39:28.730"}});