post_cb({"bq_ids": {"n4140": {"so_8873048_8873237_1": {"length": 8, "quality": 1.0, "section_id": 579}, "so_8873048_8873237_0": {"length": 7, "quality": 1.0, "section_id": 579}}, "n3337": {"so_8873048_8873237_1": {"length": 8, "quality": 1.0, "section_id": 569}, "so_8873048_8873237_0": {"length": 7, "quality": 1.0, "section_id": 569}}, "n4659": {"so_8873048_8873237_1": {"length": 7, "quality": 0.875, "section_id": 602}, "so_8873048_8873237_0": {"length": 7, "quality": 1.0, "section_id": 602}}}, "8873048": {"ViewCount": "1061", "Body": "<pre><code>void f(int){}\ntypedef void (*f_ptr)(int);\n\nstruct Functor{\n  void operator()(int){}\n};\n\nstruct X{\n  operator f_ptr(){ return f; }\n};\n\nstruct Y{\n  operator Functor(){ return Functor(); }\n};\n\nint main(){\n  X x; Y y;\n  x(5); // works ?!\n  y(5); // doesn't ?!\n}\n</code></pre>\n<p><a href=\"http://ideone.com/jRnWi\">Live example on Ideone</a>. Output:</p>\n<blockquote>\n<p id=\"so_8873048_8873048_0\">error: no match for call to '(Y) (int)'</p>\n</blockquote>\n<p><strong>Q1: Why is the call to <code>x(5)</code> allowed, even though <code>X</code> only defines a conversion to function pointer, and not <code>operator()</code>?</strong></p>\n<p><strong>Q2: Conversely, why is the same thing not allowed, if we define a conversion to another functor?</strong></p>\n", "AcceptedAnswerId": "8873237", "Title": "Why is 'X x; x();' allowed, when 'X' defines a conversion to function pointer, but not, when it defines a conversion to a functor?", "CreationDate": "2012-01-15T20:20:42.657", "Id": "8873048", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-01-15T20:22:52.600", "LastEditorUserId": "46642", "LastActivityDate": "2012-01-16T09:54:59.993", "Score": "29", "OwnerUserId": "500104", "Tags": "<c++><function-pointers><functor><function-call>", "AnswerCount": "1"}, "8873237": {"Id": "8873237", "PostTypeId": "2", "Body": "<pre><code>x(5); // works ?!\n</code></pre>\n<p>This implicitly casts <code>x</code> to an <code>f_ptr</code> and calls that. C++11 standard:</p>\n<blockquote>\n<h3>\u00a7 13.3.1.1.2 Call to object of class type [over.call.object]</h3>\n<p id=\"so_8873048_8873237_0\">2) In addition, for each non-explicit conversion function declared in T of the form</p>\n<pre><code>operator conversion-type-id ( ) attribute-specifier-seqopt cv-qualifier ;\n</code></pre>\n<p id=\"so_8873048_8873237_1\">[\u2026where <code>conversion-type-id</code> denotes the type \u201cpointer to function of <code>(P1,...,Pn)</code> returning <code>R</code>\u201d\u2026]</p>\n</blockquote>\n<hr>\n<pre><code>y(5); // doesn't ?!\n</code></pre>\n<p>The standard doesn't mention anything about implicit conversion to class types that overload <code>operator()</code> (aka functors), which implies that the compiler doesn't allow that.</p>\n<p>You must cast it explicitly:</p>\n<pre><code>static_cast&lt;Functor&gt;(y)(5);\n</code></pre>\n</hr>", "LastEditorDisplayName": "user142019", "OwnerDisplayName": "user142019", "LastActivityDate": "2012-01-16T09:54:59.993", "Score": "26", "CreationDate": "2012-01-15T20:45:25.333", "ParentId": "8873048", "CommentCount": "3", "LastEditDate": "2012-01-16T09:54:59.993"}});