post_cb({"28284842": {"ParentId": "28284740", "CommentCount": "2", "Body": "<p>Regarding</p>\n<pre><code>S * pS = new S;\ndelete S; // would this call the parent destructor?\n</code></pre>\n<p>Yes.\nExcept that destructor is likely a trivial do-nothing destructor.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "28284842", "Score": "4", "CreationDate": "2015-02-02T19:02:03.887", "LastActivityDate": "2015-02-02T19:02:03.887"}, "28284884": {"ParentId": "28284740", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-02-02T19:05:18.800", "Score": "0", "LastEditorUserId": "2249683", "LastEditDate": "2015-02-02T19:20:57.060", "Id": "28284884", "OwnerUserId": "2249683", "Body": "<p>Sure, every call of a derived class destructor will lead to destructor calls of all parent classes. But if a class deleted is a pointer to a base class without virtual destructor, no derived class destructor is called (a possible resource leak) </p>\n<pre><code>struct A {};\nstruct B : A {};\nstruct C : B {};\n\nint main() {\n    B* p = new C;\n    // This will clean up A and B, but leak the resources of C\n    delete p;\n}\n</code></pre>\n", "LastActivityDate": "2015-02-02T19:20:57.060"}, "28284740": {"CommentCount": "0", "ViewCount": "158", "PostTypeId": "1", "LastEditorUserId": "356440", "CreationDate": "2015-02-02T18:55:53.600", "LastActivityDate": "2015-02-02T19:51:09.797", "Title": "Automatic calling of parent destructor in case of non-virtual destructor?", "AcceptedAnswerId": "28284903", "LastEditDate": "2015-02-02T19:01:59.223", "Id": "28284740", "Score": "1", "Body": "<p>I have a <code>struct O</code>, defined in third party code. As it is C code, it does NOT define a <code>virtual destructor</code>. (In my case it's the <code>OVERLAPPED</code> <code>struct</code> from win32 appi).</p>\n<p>The customer code that I am modifying has a <code>class S</code>, deriving from <code>class A</code>, deriving from <code>struct O</code>.</p>\n<pre><code>struct O{};\nclass A : public O{};\nclass S : public A{};\n</code></pre>\n<p><em>None of them</em> are declaring their destructor as <code>virtual</code>.</p>\n<p>There would be a leak if one called <code>delete</code> on a pointer to an <code>O</code>. Sure.</p>\n<p>But what does the C++ standard states if I ever call <code>delete</code> on a pointer to an S ?\nWould it automatically call the destructor of both parent class even though none of them has declared their destructor virtual ? Would it free the relative memory zone of the parents ?</p>\n<pre><code>S * pS = new S;\ndelete S; // would this call the parent destructor?\n</code></pre>\n", "Tags": "<c++><destructor>", "OwnerUserId": "356440", "AnswerCount": "3"}, "28284903": {"ParentId": "28284740", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-02-02T19:07:01.410", "Score": "3", "LastEditorUserId": "2069064", "LastEditDate": "2015-02-02T19:51:09.797", "Id": "28284903", "OwnerUserId": "2069064", "Body": "<blockquote>\n<p id=\"so_28284740_28284903_0\">what does the C++ standard states if I ever call delete on a pointer to an S ?</p>\n</blockquote>\n<p>It says the following, from [class.dtor] (\u00a712.4/8 in N4296):</p>\n<blockquote>\n<p id=\"so_28284740_28284903_1\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a\n  destructor for class <code>X</code> calls the destructors for <code>X</code>\u2019s direct non-variant non-static data members, the destructors\n  for <code>X</code>\u2019s direct base classes and, if <code>X</code> is the type of the most derived class (12.6.2), its destructor calls the\n  destructors for <code>X</code>\u2019s virtual base classes.</p>\n</blockquote>\n<p>So in this case, we call <code>~S()</code>, which will then call the destructors for <code>S</code>'s direct base classes (<code>A</code>), which will then in turn call the destructors for those base classes (<code>O</code>). </p>\n<p>The <code>virtual</code>-ness of the destructor would only matter in the opposite order, namely:</p>\n<pre><code>O* s = new S;\ndelete s;\n</code></pre>\n<p>In that case, only <code>~O()</code> is called - since there are no non-static data members, or direct base classes, or virtual base classes, there's nothing else to do.</p>\n", "LastActivityDate": "2015-02-02T19:51:09.797"}, "bq_ids": {"n4140": {"so_28284740_28284903_1": {"section_id": 404, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_28284740_28284903_1": {"section_id": 395, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_28284740_28284903_1": {"section_id": 422, "quality": 0.9714285714285714, "length": 34}}}});