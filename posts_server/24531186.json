post_cb({"24531338": {"Id": "24531338", "PostTypeId": "2", "Body": "<p>In general about Dynamic initialization of a variable with static storage</p>\n<ul>\n<li>static objects in function scope are initialized at first use (just\nbefore access).</li>\n<li>In file scope(non-local scope, before main), static objects of a file are initialized in order of definition</li>\n<li>For file scope static objects lying across the files(compilation units), order is unspecified.</li>\n</ul>\n<p>If you want more details read below:</p>\n<p>Quoting from <a href=\"http://en.cppreference.com/w/cpp/language/storage_duration\" rel=\"nofollow\">cppreference</a></p>\n<blockquote>\n<p id=\"so_24531186_24531338_0\">Static variables declared at block scope are initialized the first\n  time control passes through their declaration (unless their\n  initialization is zero- or constant-initialization, which can be\n  performed before the block is first entered). On all further calls,\n  the declaration is skipped.</p>\n</blockquote>\n<p>Quoting from <strong>6.7 Declaration statement stmt.dcl</strong> (n3690)</p>\n<blockquote>\n<p id=\"so_24531186_24531338_1\">The zero-initialization (8.5) of all block-scope variables with static\n  storage duration (3.7.1) or thread storage duration (3.7.2) is\n  performed before any other initialization takes place. Constant\n  initialization (3.6.2) of a block-scope entity with static storage\n  duration, if applicable, is performed before its block is \ufb01rst\n  entered.</p>\n</blockquote>\n<p>Quoting <strong>From 3.6.2 basic.start.init</strong> (n3690)</p>\n<blockquote>\n<p id=\"so_24531186_24531338_2\">Other non-local variables with static storage duration have ordered\n  initialization. Variables with ordered initialization de\ufb01ned within a\n  single translation unit shall be initialized in the order of their\n  de\ufb01nitions in the translation unit.\n  If a program starts a thread (30.3), the subsequent initialization of\n  a variable is unsequenced with respect to the initialization of a\n  variable de\ufb01ned in a di\ufb00erent translation unit. Otherwise, the\n  initialization of a variable is indeterminately sequenced with respect\n  to the initialization of a variable de\ufb01ned in a di\ufb00erent translation\n  unit.</p>\n</blockquote>\n<p>You may also want to read <a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"nofollow\">this</a> page from parashift.</p>\n<p>About static (const) initialization, it happens as early as possible, most possibly during compile time. All static initialization completes before dynamic initialization.</p>\n", "LastEditorUserId": "2659313", "LastActivityDate": "2014-07-02T18:49:59.557", "Score": "2", "CreationDate": "2014-07-02T12:41:22.667", "ParentId": "24531186", "CommentCount": "11", "OwnerUserId": "2659313", "LastEditDate": "2014-07-02T18:49:59.557"}, "24531350": {"Id": "24531350", "PostTypeId": "2", "Body": "<ul>\n<li><p>Within the same compilation unit the order is well defined (i.e., it follows the order of definition).</p></li>\n<li><p>Order is unspecified across different compilation units. This is due to the fact that this issue is solved in linker level and not compiler level.</p></li>\n<li><p>This ambiguity can case the known <a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"nofollow\"><code>static</code> initialization fiasco</a>.</p></li>\n</ul>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2014-07-02T14:00:07.913", "Score": "0", "CreationDate": "2014-07-02T12:41:46.267", "ParentId": "24531186", "CommentCount": "4", "OwnerUserId": "2352671", "LastEditDate": "2014-07-02T14:00:07.913"}, "bq_ids": {"n4140": {"so_24531186_24531338_1": {"length": 29, "quality": 0.8529411764705882, "section_id": 3919}, "so_24531186_24531655_3": {"length": 18, "quality": 0.9, "section_id": 7151}, "so_24531186_24531186_0": {"length": 10, "quality": 1.0, "section_id": 7151}, "so_24531186_24531655_4": {"length": 15, "quality": 0.8333333333333334, "section_id": 7151}, "so_24531186_24531655_1": {"length": 9, "quality": 1.0, "section_id": 5911}, "so_24531186_24531338_2": {"length": 42, "quality": 0.8571428571428571, "section_id": 7151}, "so_24531186_24531655_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 7151}, "so_24531186_24531843_0": {"length": 18, "quality": 0.9, "section_id": 7151}}, "n3337": {"so_24531186_24531655_3": {"length": 18, "quality": 0.9, "section_id": 6895}, "so_24531186_24531186_0": {"length": 10, "quality": 1.0, "section_id": 6895}, "so_24531186_24531338_1": {"length": 29, "quality": 0.8529411764705882, "section_id": 3779}, "so_24531186_24531655_4": {"length": 15, "quality": 0.8333333333333334, "section_id": 6895}, "so_24531186_24531655_1": {"length": 9, "quality": 1.0, "section_id": 5683}, "so_24531186_24531338_2": {"length": 42, "quality": 0.8571428571428571, "section_id": 6895}, "so_24531186_24531655_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 6895}, "so_24531186_24531843_0": {"length": 18, "quality": 0.9, "section_id": 6895}}, "n4659": {"so_24531186_24531655_4": {"length": 10, "quality": 0.5555555555555556, "section_id": 4051}, "so_24531186_24531186_0": {"length": 8, "quality": 0.8, "section_id": 8654}, "so_24531186_24531655_1": {"length": 9, "quality": 1.0, "section_id": 7393}, "so_24531186_24531843_0": {"length": 14, "quality": 0.7, "section_id": 8652}, "so_24531186_24531655_3": {"length": 14, "quality": 0.7, "section_id": 8652}}}, "24531655": {"Id": "24531655", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24531186_24531655_0\">Is it true that order of Static Initialization is implementation defined?</p>\n</blockquote>\n<p>I see pretty confused answers so let me summarize: <strong>NO, STATIC INITIALIZATION ORDER IS NOT IMPLEMENTATION DEFINED.</strong></p>\n<p>Let's see why and in which cases. According to your quote let me assume you're asking about (static or dynamic) initialization of non-local variables static storage duration.</p>\n<p><a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2011/n3242.pdf\" rel=\"nofollow noreferrer\">C++ standard</a> <strong>\u00a79.4.2</strong> (paragraph <strong>6</strong>) says:</p>\n<blockquote>\n<p id=\"so_24531186_24531655_1\">Static data members are initialized and destroyed exactly like non-local variables.</p>\n</blockquote>\n<p>Then according to <strong>\u00a73.6.2</strong> and <strong>\u00a73.7.1</strong> no, [order] within a compilation unit is not implementation defined but it always follows declaration order (as described in <strong>\u00a76.7</strong> paragraph <strong>4</strong>):</p>\n<blockquote>\n<p id=\"so_24531186_24531655_2\">Variables with ordered initialization de\ufb01ned within a single translation unit shall be initialized in the order of their de\ufb01nitions in the translation unit.</p>\n</blockquote>\n<p>Rules for static and dynamic initialization are the same and they're described in same paragraph, the only (remarkable) difference between static and dynamic initialization is ordering, static initialization will always occurs before dynamic initialization and dynamic initialization may be unordered.</p>\n<blockquote>\n<p id=\"so_24531186_24531655_3\">Together, zero-initialization and constant initialization are called static initialization; all other initialization is dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place.</p>\n</blockquote>\n<p>How static initialized non-local variables are initialized is described in paragraphs <strong>1</strong> and <strong>2</strong> from <strong>\u00a73.6.2</strong>:</p>\n<blockquote>\n<p id=\"so_24531186_24531655_4\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place. Constant initialization is performed...[omitted]</p>\n</blockquote>\n<p>According to comments I need to <strong>clarify this point</strong>: a non-local static variable may have thread storage duration specifier <code>thread_local</code> (then it'll behave like a <code>static</code> variable from user POV nut they also be combined). It's still eligible for static initialization (then ordered and then it must obey to above rule) but initialization can't be performed simply loading data segment from disk. Code must be executed (<code>TlsAlloc</code> on Windows) but from standard POV it's still a static initialized expression (first zero-initialized and then with constant initialization). Let's see a very fictional example:</p>\n<pre><code>thread_local unsigned int _value = 1;\n</code></pre>\n<p>Now let's try to imagine how compiler may <em>implement</em> that. We can start with something known and imagine a behavior similar to <code>boost::thread_specific_ptr</code>. Implementation on Windows (but it's pretty similar on Windows too) will need to call <code>TlsAlloc</code> when thread is initialized and <code>TlsFree</code> when thread is finished. You'll access variable normally but probably it'll implemented as a pointer with an offset from memory allocated by <code>TlsAlloc</code>. The only thing that will come from executable file on disk is initial value (and again it's just an implementation detail who you shouldn't care). Initial value (as described before) will be 0 (for <code>unsigned int</code>). Given all this code, these function calls and so many details...probably it's still eligible to be considered <em>constant initialization</em> because requirements imposed by standard are fulfilled then compiler should (may) respect them. It means it may be static initialized. To summarize:</p>\n<ul>\n<li>Standard <strong>says</strong> that static initialized variables will respect declaration order.</li>\n<li>Standard <strong>says</strong> when variables are dynamically initialized and when statically initialized.</li>\n<li>Standard <strong>does not say</strong> where that values should come from at run-time.</li>\n<li>Standard <strong>does not say</strong> how implementation should initialize them.</li>\n</ul>\n<p>Of course inside a single function same rule apply but <em>declaration</em> should be replaced with <em>usage</em> (<strong>\u00a76.7</strong> ) but this isn't your question.</p>\n<p>Order for different compilation unit is not granted and it's implementation defined (but there are techniques to make this order arbitrary then predictable: <a href=\"https://stackoverflow.com/questions/5622574/nifty-schwarz-counter-standard-compliant\">Nifty Counter</a> and variables aggregation, for example).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-04T07:20:05.940", "Score": "2", "CreationDate": "2014-07-02T12:55:31.967", "ParentId": "24531186", "CommentCount": "2", "OwnerUserId": "1207195", "LastEditDate": "2017-05-23T12:10:17.807"}, "24531843": {"Id": "24531843", "PostTypeId": "2", "Body": "<p>Static initialization does <strong><em>not</em></strong> mean \"initialization of variables with static storage duration\". It is a much more limited term and is defined in \u00a73.6.2 [basic.start.init]/p2.</p>\n<blockquote>\n<p id=\"so_24531186_24531843_0\">Together, zero-initialization and constant initialization are called <em>static initialization</em>; all other initialization is <em>dynamic initialization</em>. Static initialization shall be performed before any dynamic initialization takes place.</p>\n</blockquote>\n<p>Constant initialization is defined in the same paragraph and basically involves initialization to compile-time constants.</p>\n<p>Because static initialization involves initialization to compile-time constants and is guaranteed to occur before any dynamic initialization takes place, the order doesn't really matter. (In practice, for objects of static storage duration, the initial values are probably placed in the data segment (bss segment for zero-initialization) of the compiled executable and loaded by the operating system directly at program start, so speaking of an \"order\" doesn't make much sense.) Anything for which the \"static initialization fiasco\" can arise actually involves <em>dynamic</em> initialization.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-03T09:22:19.733", "Score": "3", "CreationDate": "2014-07-02T13:04:04.800", "ParentId": "24531186", "CommentCount": "23", "OwnerUserId": "2756719", "LastEditDate": "2014-08-03T09:22:19.733"}, "24531186": {"ViewCount": "355", "Body": "<p>Dynamic initialization can be ordered or unordered:</p>\n<blockquote>\n<p id=\"so_24531186_24531186_0\">Dynamic initialization of a non-local variable with static storage\n  duration is either ordered or unordered.</p>\n</blockquote>\n<p>This does not say anything about order of static initialization. Is it true that order of static initialization is implementation defined?</p>\n", "AcceptedAnswerId": "24531843", "Title": "Is order of static initialization implementation defined?", "CreationDate": "2014-07-02T12:34:36.907", "LastActivityDate": "2014-10-28T15:23:51.100", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-28T15:23:51.100", "OwnerDisplayName": "user2953119", "LastEditorUserId": "2932052", "Id": "24531186", "Score": "3", "Tags": "<c++><language-lawyer><static-initialization>", "AnswerCount": "4"}});