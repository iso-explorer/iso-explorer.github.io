post_cb({"37962414": {"Id": "37962414", "PostTypeId": "2", "Body": "<p>As has already been mentioned there is no \"safe way\". In fact as has been pointed out by PcAF the lifetime of <code>A</code> has already ended by the time you reach <code>B</code>'s destructor.<br>\nI also just want to point out that this is actually a good thing! There has to be a strict order in which objects get destroyed.<br>\nNow what you should do is tell <code>B</code> <strong>beforehand</strong> that <code>A</code> is about to get destructed.<br>\nIt is as simple as</br></br></br></p>\n<pre><code>void ~A( void ) {\n    b-&gt;detach_from_me_i_am_about_to_get_destructed( this );\n}\n</code></pre>\n<p>Passing the <code>this</code> pointer might be necessary or not depending on the design ob <code>B</code> (If <code>B</code> holds many references, it might need to know which one to detach. If it only holds one, the <code>this</code> pointer is superfluous).<br>\nJust make sure that appropriate member functions are private, so that the interface only can be used in the intended way.  </br></p>\n<p><strong>Remark</strong>:\nThis is a simple light-weight solution that is fine if you yourself completely control the communication between <code>A</code> and <code>B</code>. <strong>Do not</strong> under any circumstances design this to be a network protocol! That will require a lot more safety fences.</p>\n", "LastActivityDate": "2016-06-22T08:21:36.653", "Score": "0", "CreationDate": "2016-06-22T08:21:36.653", "ParentId": "37960088", "CommentCount": "0", "OwnerUserId": "483421"}, "37960088": {"ViewCount": "190", "Body": "<p>Say there is an object A which owns an object B via <code>std::unique_ptr&lt;B&gt;</code>. Further B holds a raw pointer(weak) reference to A. Then the destructor of A will invoke the destructor of B, since it owns it.</p>\n<p>What will be a safe way to access A in the destructor of B? (since we may also be in the destructor of A).</p>\n<p>A safe way me be to explicitly reset the strong reference to B in the destructor of A, so that B is destroyed in a predictable manner, but what's the general best practice?</p>\n", "AcceptedAnswerId": "37963022", "Title": "Accessing owner in destructor c++", "CreationDate": "2016-06-22T06:22:55.580", "Id": "37960088", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-06-22T07:19:25.520", "LastEditorUserId": "4523099", "LastActivityDate": "2016-06-22T14:23:34.267", "Score": "8", "OwnerUserId": "1122870", "Tags": "<c++><smart-pointers><ownership-semantics>", "AnswerCount": "5"}, "37960952": {"Id": "37960952", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37960088_37960952_0\">What will be a safe way to access A in the destructor of B? (since we may also be in the destructor of A).</p>\n</blockquote>\n<p><s>There isn't safe way</s>:</p>\n<p>3.8/1</p>\n<blockquote>\n<p id=\"so_37960088_37960952_1\">[...]The lifetime of an object of type T ends when:</p>\n<p id=\"so_37960088_37960952_2\">\u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts [...]</p>\n</blockquote>\n<p><s>I think it's straightforward that you can't access object after it's lifetime has ended.</s></p>\n<p>EDIT: As Chris Drew wrote in comment you <strong>can</strong> use object after it's destructor started, sorry, my mistake I missed out one important sentence in the standard:</p>\n<p>3.8/5</p>\n<blockquote>\n<p id=\"so_37960088_37960952_3\">Before the lifetime of an object has started but after the storage which the object will occupy has been\n  allocated or, <strong>after the lifetime of an object has ended</strong> and before the storage which the object occupied is\n  reused or released, any pointer that refers to the storage location where the object will be or was located\n  may be used but only in limited ways. <strong>For an object under construction or destruction, see 12.7</strong>. Otherwise,\n  such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type void*,\n  is well-de\ufb01ned. Such a pointer may be dereferenced but the resulting lvalue may only be used in limited\n  ways, as described below. The program has unde\ufb01ned behavior if:\n  [...]</p>\n</blockquote>\n<p>In 12.7 there is list of things you can do during construction and destruction, some of the most important:</p>\n<p>12.7/3:</p>\n<blockquote>\n<p id=\"so_37960088_37960952_4\">To explicitly or implicitly convert a <strong>pointer</strong> (a glvalue) referring <strong>to an object of class X to a pointer (reference)\n  to</strong> a direct or indirect <strong>base class B of X</strong>, the construction of X and the construction of all of its direct or\n  indirect bases that directly or indirectly derive from B shall have started and the <strong>destruction of these classes shall not have completed</strong>, otherwise the conversion results in unde\ufb01ned behavior. To <strong>form a pointer to (or\n  access the value of) a direct non-static member of an object obj</strong>, the construction of obj shall have started\n  and <strong>its destruction shall not have completed</strong>, otherwise the computation of the pointer value (or accessing\n  the member value) results in unde\ufb01ned behavior.</p>\n</blockquote>\n<p>12.7/4</p>\n<blockquote>\n<p id=\"so_37960088_37960952_5\"><strong>Member functions</strong>, including virtual functions (10.3), <strong>can be called during</strong> construction or <strong>destruction</strong> (12.6.2).\n  When a virtual function is called directly or indirectly from a constructor or from a destructor, including\n  during the construction or destruction of the class\u2019s non-static data members, and the object to which the\n  call applies is the object (call it x) under construction or destruction, the function called is the \ufb01nal overrider\n  in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class. If the virtual\n  function call uses an explicit class member access (5.2.5) and the object expression refers to the complete\n  object of x or one of that object\u2019s base class subobjects but not x or one of its base class subobjects, the\n  behavior is unde\ufb01ned.</p>\n</blockquote>\n", "LastEditorUserId": "4932834", "LastActivityDate": "2016-06-22T09:42:54.290", "Score": "3", "CreationDate": "2016-06-22T07:12:38.700", "ParentId": "37960088", "CommentCount": "2", "LastEditDate": "2016-06-22T09:42:54.290", "OwnerUserId": "4932834"}, "37963022": {"Id": "37963022", "PostTypeId": "2", "Body": "<p>I'm no language lawyer but I think it is OK. You are treading on dangerous ground and perhaps should rethink your design but if you are careful I think you can just rely on the fact that <a href=\"https://stackoverflow.com/questions/2254263/order-of-member-constructor-and-destructor-calls\">members are destructed in the reverse order they were declared</a>.</p>\n<p>So this is OK</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Noisy {\n    int i;\n    ~Noisy() { std::cout &lt;&lt; \"Noisy \" &lt;&lt; i &lt;&lt; \" dies!\" &lt;&lt; \"\\n\"; }\n};\n\nstruct A;\n\nstruct B {\n    A* parent;\n    ~B();\n    B(A&amp; a) : parent(&amp;a) {}\n};\n\nstruct A {\n    Noisy n1 = {1};\n    B     b;\n    Noisy n2 = {2};\n    A() : b(*this) {}\n};\n\nB::~B() { std::cout &lt;&lt; \"B dies. parent-&gt;n1.i=\" &lt;&lt; parent-&gt;n1.i &lt;&lt; \"\\n\"; }\n\nint main() {\n    A a;\n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/CqCmfHwjbDxd2HNO\" rel=\"nofollow noreferrer\">Live demo</a>.</p>\n<p>since the members of <code>A</code> are destructed in order <code>n2</code> then <code>b</code> then <code>n1</code>. But this is not OK</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Noisy {\n    int i;\n    ~Noisy() { std::cout &lt;&lt; \"Noisy \" &lt;&lt; i &lt;&lt; \" dies!\" &lt;&lt; \"\\n\"; }\n};\n\nstruct A;\n\nstruct B {\n    A* parent;\n    ~B();\n    B(A&amp; a) : parent(&amp;a) {}\n};\n\nstruct A {\n    Noisy n1 = {1};\n    B     b;\n    Noisy n2 = {2};\n    A() : b(*this) {}\n};\n\nB::~B() { std::cout &lt;&lt; \"B dies. parent-&gt;n2.i=\" &lt;&lt; parent-&gt;n2.i &lt;&lt; \"\\n\"; }\n\nint main() {\n    A a;\n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/RAJuj5ZyGmSHdRXd\" rel=\"nofollow noreferrer\">Live demo</a>.</p>\n<p>since <code>n2</code> has already been destroyed by the time <code>B</code> tries to use it.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-22T08:51:00.333", "Score": "3", "CreationDate": "2016-06-22T08:51:00.333", "ParentId": "37960088", "CommentCount": "0", "LastEditDate": "2017-05-23T12:01:09.563", "OwnerUserId": "3422652"}, "bq_ids": {"n4140": {"so_37960088_37960952_5": {"length": 69, "quality": 0.9324324324324325, "section_id": 447}, "so_37960088_37960952_2": {"length": 7, "quality": 0.875, "section_id": 7189}, "so_37960088_37960952_3": {"length": 62, "quality": 0.8732394366197183, "section_id": 7193}, "so_37960088_37960952_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_37960088_37960952_4": {"length": 60, "quality": 0.967741935483871, "section_id": 446}}, "n3337": {"so_37960088_37960952_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_37960088_37960952_2": {"length": 7, "quality": 0.875, "section_id": 6933}, "so_37960088_37960952_4": {"length": 60, "quality": 0.967741935483871, "section_id": 437}, "so_37960088_37960952_3": {"length": 65, "quality": 0.9154929577464789, "section_id": 6937}, "so_37960088_37960952_5": {"length": 69, "quality": 0.9324324324324325, "section_id": 438}}, "n4659": {"so_37960088_37960952_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_37960088_37960952_2": {"length": 7, "quality": 0.875, "section_id": 8697}, "so_37960088_37960952_3": {"length": 61, "quality": 0.8591549295774648, "section_id": 8702}, "so_37960088_37960952_5": {"length": 69, "quality": 0.9324324324324325, "section_id": 469}, "so_37960088_37960952_4": {"length": 60, "quality": 0.967741935483871, "section_id": 468}}}, "37961720": {"Id": "37961720", "PostTypeId": "2", "Body": "<p>If you look only on the relations of the two classes A and B, the construction is well:</p>\n<pre><code>class A {\n    B son;\n    A(): B(this)  {}\n};   \nclass B {\n    A* parent;\n    B(A* myparent): parent(myparent)  {} \n    ~B() {\n        // do not use parent-&gt;... because parent's lifetime may be over\n        parent = NULL;    // always safe\n    }\n}\n</code></pre>\n<p>The problems arise, if objects of A and B are proliferated to other program units. Then you should use the tools from std::memory like std::shared_ptr or std:weak_ptr.</p>\n", "LastEditorUserId": "3951733", "LastActivityDate": "2016-06-22T14:23:34.267", "Score": "-2", "CreationDate": "2016-06-22T07:48:22.237", "ParentId": "37960088", "CommentCount": "0", "LastEditDate": "2016-06-22T14:23:34.267", "OwnerUserId": "3951733"}, "37962515": {"Id": "37962515", "PostTypeId": "2", "Body": "<p>Consider this:</p>\n<pre><code>struct b\n{\n        b()\n        {\n                cout &lt;&lt; \"b()\" &lt;&lt; endl;\n        }\n        ~b()\n        {\n                cout &lt;&lt; \"~b()\" &lt;&lt; endl;\n        }\n};\n\nstruct a\n{\n        b ob;\n        a()\n        {\n                cout &lt;&lt; \"a()\" &lt;&lt; endl;\n        }\n        ~a()\n        {\n                cout &lt;&lt; \"~a()\" &lt;&lt; endl;\n        }\n};\n\nint main()\n{\n        a  oa;\n}\n\n//Output:\nb()\na()\n~a()\n~b()\n</code></pre>\n<p><strong><em>\"Then the destructor of A will invoke the destructor of B, since it owns it.\"</em></strong> This is not the correct way of invocation of destructors in case of composite objects. If you see above example then, first <code>a</code> gets destroyed and then <code>b</code> gets destroyed. <code>a</code>'s destructor won't invoke <code>b</code>'s destructor so that the control would return back to <code>a</code>'s destructor.</p>\n<p><strong><em>\"What will be a safe way to access A in the destructor of B?\"</em></strong>. As per above example <code>a</code> is already destroyed therefore <code>a</code> cannot be accessed in <code>b</code>'s destructor.</p>\n<p><strong><em>\"since we may also be in the destructor of A).\"</em></strong>. This is not correct. Again, when the control goes out of <code>a</code>'s destructor then only control enters <code>b</code>'s destructor.</p>\n<p>Destructor is a member-function of a class T. Once the control goes out of destructor, the class T cannot be accessed. All the data-members of class T can be accessed in class T's constructors and destructor as per above example.</p>\n", "LastActivityDate": "2016-06-22T08:26:26.623", "Score": "0", "CreationDate": "2016-06-22T08:26:26.623", "ParentId": "37960088", "CommentCount": "13", "OwnerUserId": "4635537"}});