post_cb({"bq_ids": {"n4140": {"so_12365415_12365484_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 664}}, "n3337": {"so_12365415_12365484_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 654}}, "n4659": {"so_12365415_12365484_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 692}}}, "12365415": {"ViewCount": "301", "Body": "<p>The following code is extracted from: <a href=\"https://github.com/facebook/folly/blob/master/folly/Synchronized.h\">https://github.com/facebook/folly/blob/master/folly/Synchronized.h</a></p>\n<p>I recent had a look at the Folly library, and found something interesting. Consider the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Lock {\n    void lock() {\n        std::cout &lt;&lt; \"Locking\" &lt;&lt; std::endl;\n    }\n    void unlock() {\n        std::cout &lt;&lt; \"Unlocking\" &lt;&lt; std::endl;\n    }\n};\n\ntemplate &lt;class T, class Mutex = Lock &gt;\nstruct Synchronized {\n    struct LockedPtr {\n        explicit LockedPtr(Synchronized* parent) : p(parent) {\n            p-&gt;m.lock();\n        }\n\n        ~LockedPtr() {\n            p-&gt;m.unlock();\n        }\n\n        T* operator-&gt;() {\n            std::cout &lt;&lt; \"second\" &lt;&lt; std::endl;\n            return &amp;p-&gt;t;\n        }\n\n    private:\n        Synchronized* p;\n    };\n\n    LockedPtr operator-&gt;() {\n        std::cout &lt;&lt; \"first\" &lt;&lt; std::endl;\n        return LockedPtr(this);\n    }\n\nprivate:\n    T t;\n    mutable Mutex m;\n};\n\nstruct Foo {\n    void a() {\n        std::cout &lt;&lt; \"a\" &lt;&lt; std::endl;\n    }\n};\n\nint main(int argc, const char *argv[])\n{\n    Synchronized&lt;Foo&gt; foo;\n    foo-&gt;a();\n\n    return 0;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>first\nLocking\nsecond\na\nUnlocking\n</code></pre>\n<p>My question is: Why is this code valid? Does this pattern have a name?</p>\n<p>The -&gt; operator is called twice, but it has only been written once.</p>\n", "AcceptedAnswerId": "12365484", "Title": "Why does the compiler invoke the -> operator twice", "CreationDate": "2012-09-11T08:11:38.447", "Id": "12365415", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2012-09-11T08:33:34.390", "Score": "11", "OwnerUserId": "339753", "Tags": "<c++>", "AnswerCount": "2"}, "12365484": {"Id": "12365484", "PostTypeId": "2", "Body": "<p>Because that's what the standard says:</p>\n<h3>13.5.6 Class member access [over.ref]</h3>\n<blockquote>\n<p id=\"so_12365415_12365484_0\">1) <code>operator-&gt;</code> shall be a non-static member function taking no\n  parameters. It implements class member access using <code>-&gt;\n  postfix-expression -&gt; id-expression</code> <strong>An expression <code>x-&gt;m</code> is interpreted\n  as <code>(x.operator-&gt;())-&gt;m</code> for a class object <code>x</code> of type <code>T</code> if\n  <code>T::operator-&gt;()</code> exists and if the operator is selected as the best\n  match function by the overload resolution mechanism (13.3).</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>In your case, <code>x</code> is <code>foo</code> and <code>m</code> is <code>a()</code>, Now, <code>Synchronized</code> overloads <code>operator-&gt;</code>, <code>foo-&gt;a()</code> is equivalent to:</p>\n<pre><code>(foo.operator-&gt;())-&gt;a();\n</code></pre>\n<p><code>foo.operator-&gt;()</code> is your overload in class <code>Synchronized</code>, which returns a <code>LockedPtr</code>, and then that <code>LockedPtr</code> calls its own <code>operator-&gt;</code>. </p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-09-11T08:22:27.233", "Score": "12", "CreationDate": "2012-09-11T08:17:07.073", "ParentId": "12365415", "CommentCount": "4", "OwnerUserId": "673730", "LastEditDate": "2012-09-11T08:22:27.233"}, "12365763": {"Id": "12365763", "PostTypeId": "2", "Body": "<p>Ask yourself this: how else could it possibly behave?</p>\n<p>Remember, the point of overloading <code>operator-&gt;</code> at all is so that a smart pointer class can use the same syntax as a raw pointer.  That is, if you have:</p>\n<pre><code>struct S\n{\n    T m;\n};\n</code></pre>\n<p>and you have a pointer <code>p</code> to <code>S</code>, then you access <code>S::m</code> via <code>p-&gt;m</code> regardless of whether <code>p</code> is an <code>S*</code> or some <code>pointer_class&lt;S&gt;</code> type.</p>\n<p>There's also the difference between using <code>-&gt;</code> and invoking <code>operator-&gt;</code> directly:</p>\n<pre><code>pointer_class&lt;S&gt; pointerObj;\nS* p = pointerObj.operator-&gt;();\n</code></pre>\n<p>Note that if using an overloaded <code>-&gt;</code> didn't automatically descend the extra level, what would <code>p-&gt;m</code> ever possibly mean?  How could the overload ever be used?</p>\n", "LastActivityDate": "2012-09-11T08:33:34.390", "CommentCount": "0", "CreationDate": "2012-09-11T08:33:34.390", "ParentId": "12365415", "Score": "0", "OwnerUserId": "179715"}});