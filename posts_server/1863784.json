post_cb({"1870069": {"ParentId": "1863784", "CommentCount": "0", "Body": "<p>I've found the answer in the standard docs(<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf\" rel=\"noreferrer\">latest draft</a>). Hopefully, I'll try to explain what I understood.</p>\n<p>First, if a class defines an initialization list constructor, then it is used whenever suitable:  </p>\n<blockquote>\n<p id=\"so_1863784_1870069_0\"><strong>\u00a7 8.5.4 (page 203)</strong> </p>\n<p id=\"so_1863784_1870069_1\">Initializer-list constructors are\n  favored over other constructors in\n  list-initialization (13.3.1.7).</p>\n</blockquote>\n<p>I think this is a great feature to have, eliminating the headache associated with the <em>non-uniform</em> style :)</p>\n<p>Anyway, the only gotcha(which my question is about) is that if you design a class without the initializer constructor, then you add it later you may get surprising result.</p>\n<p>Basically, imagine <code>std::vector</code> didn't have the initializer list constructor, then the following would create a vector with 10 elements:</p>\n<pre><code>std::vector&lt;int&gt; numbers{10};\n</code></pre>\n<p>By adding the initializer list constructor, the compiler would favor it over the other constructor because of the <code>{}</code> syntax. This behavior would happen because the elements of the init-list <code>{10}</code> <strong>are</strong> accepted using the init-list constructor. If there is no acceptable conversion, any other constructor shall be used e.g.:</p>\n<pre><code>std::vector&lt;string&gt; vec{10};\n// a vector of 10 elements.\n// the usual constructor got used because \"{0}\"\n// is not accepted as an init-list of type string.\n</code></pre>\n", "OwnerUserId": "127893", "PostTypeId": "2", "Id": "1870069", "Score": "9", "CreationDate": "2009-12-08T21:45:09.883", "LastActivityDate": "2009-12-08T21:45:09.883"}, "1863784": {"CommentCount": "4", "ViewCount": "3599", "CreationDate": "2009-12-08T00:18:21.067", "LastActivityDate": "2009-12-08T21:45:09.883", "Title": "Uniform initialization in C++0x, when to use () instead of {}?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "1863784", "Score": "12", "Body": "<p>Is there a rule of thumb to decide when to use the old syntax <strong><code>()</code></strong> instead of the new syntax <strong><code>{}</code></strong>?</p>\n<p>To initialize a struct:</p>\n<pre><code>struct myclass\n{\n    myclass(int px, int py) : x(px), y(py) {}\nprivate:\n    int x, y;\n};\n...\nmyclass object{0, 0};\n</code></pre>\n<p>Now in the case of a <code>vector</code> for example, it has many constructors. Whenever I do the following:</p>\n<pre><code>vector&lt;double&gt; numbers{10};\n</code></pre>\n<p>I get a vector of <strong>1</strong> element instead of one with <strong>10</strong> elements as one of the constructors is:</p>\n<pre><code>explicit vector ( size_type n, const T&amp; value= T(), const Allocator&amp; = Allocator() );\n</code></pre>\n<p>My suspicion is that whenever a class defines an <code>initializer list</code> constructor as in the case of a vector, it gets called with the <strong><code>{}</code></strong> syntax.</p>\n<p>So, is what I am thinking correct. i.e. <strong>Should I revert to the old syntax only whenever a class defines an initializer list constructor to call a different constructor?</strong> e.g. to correct the above code:</p>\n<pre><code>vector&lt;double&gt; numbers(10); // 10 elements instead of just one element with value=10\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "127893", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_1863784_1870069_1": {"section_id": 3324, "quality": 0.875, "length": 7}}, "n3337": {"so_1863784_1870069_1": {"section_id": 3194, "quality": 0.875, "length": 7}}, "n4659": {"so_1863784_1870069_1": {"section_id": 4090, "quality": 0.875, "length": 7}}}, "1863845": {"ParentId": "1863784", "CommentCount": "1", "Body": "<p>Take a look at this:</p>\n<p><a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=453&amp;rll=1\" rel=\"nofollow noreferrer\">http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=453&amp;rll=1</a></p>\n<p>The use of a <code>{}</code>-style initializers on a variable has no direct mapping to the initialization lists on any constructors of the class.  Those constructor initialization lists can be added/removed/modified without breaking existing callers.</p>\n<p>Basically the different behavior of the container is special, and requires special code in that container, specifically a constructor taking a <code>std::initializer_list</code>.  For POD and simple objects, you can use <code>{}</code> and <code>()</code> interchangeably.</p>\n", "OwnerUserId": "135138", "PostTypeId": "2", "Id": "1863845", "Score": "2", "CreationDate": "2009-12-08T00:42:25.543", "LastActivityDate": "2009-12-08T00:42:25.543"}});