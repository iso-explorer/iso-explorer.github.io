post_cb({"10211944": {"ParentId": "9819298", "CommentCount": "0", "Body": "<p>The use of implicit conversion operators is not recommended. In C++11 you can add the keyword <code>explicit</code> not only to single argument constructors, but also to conversion operators. For C++03 code, you could use an explicitly named conversion function such as <code>self()</code> or <code>down_cast()</code>.</p>\n<p>Furthermore, you seem to be using the <code>Base</code> class for CRTP, i.e. to enable static polymorphism. That means that you have to know at <strong>compile-time</strong> which particular <code>Derived</code> class you are calling. Therefore, you should not have to use <code>const Base&amp;</code> references in any public code, except to implement a CRTP interface.</p>\n<p>In my projects, I have a class template <code>enable_crtp</code>:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;boost/static_assert.hpp&gt;\n\ntemplate\n&lt;\n        typename Derived\n&gt;\nclass enable_crtp\n{\npublic:\n        const Derived&amp; self() const\n        {\n                return down_cast(*this);\n        }\n\n        Derived&amp; self()\n        {\n                return down_cast(*this);\n        }\n\nprotected:\n        // disable deletion of Derived* through Base* \n        // enable deletion of Base* through Derived*\n        ~enable_crtp()\n        {\n                // no-op\n        }\n\nprivate:\n        // typedefs\n        typedef enable_crtp Base;\n\n        // cast a Base&amp; to a Derived&amp; (i.e. \"down\" the class hierarchy)\n        const Derived&amp; down_cast(const Base&amp; other) const\n        {\n              BOOST_STATIC_ASSERT((std::is_base_of&lt;Base, Derived&gt;::value));\n              return static_cast&lt;const Derived&amp;&gt;(other);\n        }\n\n        // cast a Base&amp; to a Derived&amp; (i.e. \"down\" the class hierarchy)\n        Derived&amp; down_cast(Base&amp; other)\n        {\n        // write the non-const version in terms of the const version\n        // Effective C++ 3rd ed., Item 3 (p. 24-25)\n        return const_cast&lt;Derived&amp;&gt;(down_cast(static_cast&lt;const Base&amp;&gt;(other)));\n        }\n};\n</code></pre>\n<p>This class is privately derived from by any CRTP base class ISomeClass like this:</p>\n<pre><code>template&lt;typename Impl&gt;\nclass ISomeClass\n:\n    private enable_crtp&lt;Impl&gt;\n{\npublic:\n    // interface to be implemented by derived class Impl\n    void fun1() const\n    {\n        self().do_fun1();\n    }\n\n    void fun2()\n    {\n        self().do_fun2()\n    }\n\nprotected:\n    ~ISomeClass()\n    {}  \n};\n</code></pre>\n<p>The various derived classes can implement this interface in their own specific way like this:</p>\n<pre><code>class SomeImpl\n:\n    public ISomeClass&lt;SomeImpl&gt;\n{\npublic:\n    // structors etc.\n\nprivate:\n    // implementation of interface ISomeClass\n\n    friend class ISomeClass&lt;SomeImpl&gt;;\n\n    void do_fun1() const\n    {\n        // whatever\n    }\n\n    void do_fun2() \n    {\n        // whatever\n    }\n\n    // data representation\n    // ...\n};\n</code></pre>\n<p>Outside code calling <code>fun1</code> of <code>class SomeImpl</code> will get delegated to the appropriate const or non-const version of <code>self()</code> in the <code>class enable_crtp</code> and after down_casting the implementation <code>do_fun1</code> will be called. With a decent compiler, all the indirections should be optimized away completely.</p>\n<p>NOTE: the protected destructors of <code>ISomeClass</code> and <code>enable_crtp</code> make the code safe against users who try to delete <code>SomeImpl*</code> objects through base pointers.</p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "10211944", "Score": "0", "CreationDate": "2012-04-18T14:47:45.107", "LastActivityDate": "2012-04-18T14:47:45.107"}, "9820448": {"ParentId": "9819298", "CommentCount": "0", "Body": "<p>Looking at <strong>[expr.static.cast]</strong> in <em>n3337</em> (first working draft after the Standard):</p>\n<blockquote>\n<p id=\"so_9819298_9820448_0\"><strong>2/</strong> An lvalue of type \u201ccv1 <code>B</code>,\u201d where <code>B</code> is a class type, can be cast to type \u201creference to cv2 <code>D</code>,\u201d where <code>D</code> is a class derived (Clause 10) from <code>B</code>, if a valid standard conversion from \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists [...]</p>\n<p id=\"so_9819298_9820448_1\"><strong>4/</strong> Otherwise, an expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> [..]</p>\n</blockquote>\n<p>Therefore, I would interpret that gcc's behavior is the correct one, ie the expression:</p>\n<pre><code>static_cast&lt;Derived const&amp;&gt;(*this)\n</code></pre>\n<p>should not invoke recursively <code>operator Derived const&amp; () const</code>.</p>\n<p>I deduce this from the presence of the <em>Otherwise</em> keyword which implies an ordering of the rules. The rule <code>2/</code> should be tried before the rule <code>4/</code>.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "9820448", "Score": "3", "CreationDate": "2012-03-22T10:28:34.753", "LastActivityDate": "2012-03-22T10:28:34.753"}, "bq_ids": {"n4140": {"so_9819298_9820448_0": {"section_id": 6028, "quality": 0.9, "length": 18}, "so_9819298_9820448_1": {"section_id": 6030, "quality": 0.9375, "length": 15}}, "n3337": {"so_9819298_9820448_0": {"section_id": 5796, "quality": 0.9, "length": 18}, "so_9819298_9820448_1": {"section_id": 5798, "quality": 1.0, "length": 16}}, "n4659": {"so_9819298_9820448_0": {"section_id": 7527, "quality": 0.9, "length": 18}, "so_9819298_9820448_1": {"section_id": 2, "quality": 0.625, "length": 10}}}, "9819298": {"CommentCount": "3", "CreationDate": "2012-03-22T09:17:54.970", "PostTypeId": "1", "AcceptedAnswerId": "9820448", "LastEditorUserId": "-1", "LastActivityDate": "2012-04-18T14:47:45.107", "LastEditDate": "2017-05-23T12:11:25.700", "ViewCount": "841", "FavoriteCount": "2", "Title": "Conversion operator implemented with static_cast", "Id": "9819298", "Score": "7", "Body": "<p>I ask this question following the issue I raised <a href=\"https://stackoverflow.com/questions/9738975/crtp-compiler-dependent-issue-with-expression-template\">here</a>.</p>\n<p>The point is quite simple. Suppose you have two classes of this kind:</p>\n<pre><code>template &lt; class Derived &gt;\nclass Base {\n...\noperator const Derived&amp;() const {\n    return static_cast&lt; const Derived&amp; &gt;(*this);\n  }\n...\n};\n\nclass Specialization : public Base&lt;Specialization&gt; {\n...\n};\n</code></pre>\n<p>Then suppose you have a type conversion like this one:</p>\n<pre><code>template &lt; class T &gt;\nfunctionCall( const Base&lt;T&gt;&amp; param) {\n  const T &amp; val(param);\n  ...\n}\n</code></pre>\n<p>The question is: <strong>what should be the standard conforming behavior of this conversion?</strong></p>\n<p>Should it be the same as <code>const T &amp; val(static_cast&lt;const T &amp;&gt; (param) )</code> or should it recursively iterate until stack overflow? Notice that I obtain the first behavior compiling with GNU <code>g++</code> and the second compiling with Intel <code>icpc</code>.</p>\n<p>I already tried to peek at the standard (section 5.9 on static_cast and section 12.3 on conversions) but due to my lack of experience I was not able to figure out the answer.</p>\n<p>My many thanks in advance to anybody taking the time to help me out with this.</p>\n", "Tags": "<c++><standards><crtp><static-cast><conversion-operator>", "OwnerUserId": "771663", "AnswerCount": "2"}});