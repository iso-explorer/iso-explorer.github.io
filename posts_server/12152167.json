post_cb({"12152466": {"Id": "12152466", "PostTypeId": "2", "Body": "<p>Since you specifically ask for the rationale of this behavior, here's the closest thing I can find (from the ANSI C90 Rationale document - <a href=\"http://www.lysator.liu.se/c/rat/c3.html#3-3-2-2\" rel=\"noreferrer\">http://www.lysator.liu.se/c/rat/c3.html#3-3-2-2</a>):</p>\n<blockquote>\n<p id=\"so_12152167_12152466_0\">3.3.2.2 Function calls</p>\n<p id=\"so_12152167_12152466_1\">Pointers to functions may be used either as <code>(*pf)()</code> or as <code>pf()</code>.\n  The latter construct, not sanctioned in the Base Document, appears in\n  some present versions of C, is unambiguous, invalidates no old code,\n  and can be an important shorthand. The shorthand is useful for\n  packages that present only one external name, which designates a\n  structure full of pointers to object s and functions : member\n  functions can be called as <code>graphics.open(file)</code> instead of\n  <code>(*graphics.open)(file)</code>. The treatment of function designators can\n  lead to some curious , but valid , syntactic forms . Given the\n  declarations : </p>\n<pre><code>int f ( ) , ( *pf ) ( ) ; \n</code></pre>\n<p id=\"so_12152167_12152466_2\">then all of the following expressions are valid function calls :</p>\n<pre><code>( &amp;f)(); f(); (*f)(); (**f)(); (***f)();\npf(); (*pf)(); (**pf)(); (***pf)();\n</code></pre>\n<p id=\"so_12152167_12152466_3\">The first expression on each line was discussed in the previous\n  paragraph . The second is conventional usage . All subsequent\n  expressions take advantage of the implicit conversion of a function\n  designator to a pointer value , in nearly all expression contexts .\n  The Committee saw no real harm in allowing these forms ; outlawing\n  forms like <code>(*f)()</code>, while still permitting <code>*a</code> (for <code>int a[])</code>,\n  simply seemed more trouble than it was worth .</p>\n</blockquote>\n<p>Basically, the equivalence between function designators and function pointers was added to make using function pointers a little more convenient. </p>\n", "LastEditorUserId": "12711", "LastActivityDate": "2012-08-28T03:48:52.917", "Score": "13", "CreationDate": "2012-08-28T03:43:42.353", "ParentId": "12152167", "CommentCount": "1", "OwnerUserId": "12711", "LastEditDate": "2012-08-28T03:48:52.917"}, "bq_ids": {"n4140": {"so_12152167_12152466_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 1861}}, "n3337": {"so_12152167_12152466_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 1855}}, "n4659": {"so_12152167_12152466_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 823}}}, "12152212": {"Id": "12152212", "PostTypeId": "2", "Body": "<p>It's a feature inherited from C.</p>\n<p>In C, it's allowed primarily because there's not much else the name of a function, by itself, could mean. All you can do with an actual function is call it. If you're not calling it, the <em>only</em> thing you can do is take the address. Since there's no ambiguity, any time a function name isn't followed by a <code>(</code> to signify a call to the function, the name evaluates to the address of the function.</p>\n<p>That actually is somewhat similar to one other part of the language -- the name of an array evaluates to the address of the first element of the array except in some fairly limited circumstances (being used as the operand of <code>&amp;</code> or <code>sizeof</code>).</p>\n<p>Since C allowed it, C++ does as well, mostly because the same remains true: the only things you can do with a function are call it or take its address, so if the name isn't followed by a <code>(</code> to signify a function call, then the name evaluates to the address with no ambiguity.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2012-08-28T03:02:56.880", "Score": "8", "CreationDate": "2012-08-28T02:57:53.360", "ParentId": "12152167", "CommentCount": "3", "OwnerUserId": "179910", "LastEditDate": "2012-08-28T03:02:56.880"}, "12152713": {"Id": "12152713", "PostTypeId": "2", "Body": "<p>For arrays, there is no pointer decay when the address-of operator is used:</p>\n<pre><code>int a[2];\nint * p1 = a;      // No address-of operator, so type is int*\nint (*p2)[2] = &amp;a; // Address-of operator used, so type is int (*)[2]\n</code></pre>\n<p>This makes sense because arrays and pointers are different types, and it is possible for example to return references to arrays or pass references to arrays in functions.</p>\n<p>However, with functions, what other type could be possible?</p>\n<pre><code>void foo(){}\n&amp;foo; // #1\nfoo;  // #2\n</code></pre>\n<p>Let's imagine that only #2 gives the type <code>void(*)()</code>, what would the type of <code>&amp;foo</code> be? There is no other possibility.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2017-11-12T22:54:41.627", "Score": "2", "CreationDate": "2012-08-28T04:17:29.243", "ParentId": "12152167", "CommentCount": "0", "OwnerUserId": "906773", "LastEditDate": "2017-11-12T22:54:41.627"}, "12152167": {"ViewCount": "4488", "Body": "<p>It's interesting that <strong>using the function name as a function pointer is equivalent to applying the address-of operator to the function name</strong>!</p>\n<p>Here's the example.</p>\n<pre><code>typedef bool (*FunType)(int);\nbool f(int);\nint main() {\n  FunType a = f;\n  FunType b = &amp;a; // Sure, here's an error.\n  FunType c = &amp;f; // This is not an error, though. \n                  // It's equivalent to the statement without \"&amp;\".\n                  // So we have c equals a.\n  return 0;\n}\n</code></pre>\n<p>Using the name is something we already know in array. But you can't write something like </p>\n<pre><code>int a[2];\nint * b = &amp;a; // Error!\n</code></pre>\n<p>It seems not consistent with other parts of the language. What's the rationale of this design? </p>\n<p><a href=\"https://stackoverflow.com/questions/6893285/why-do-all-these-crazy-function-pointer-definitions-all-work-what-is-really-goi\">This question explains the semantics of such behavior and why it works.</a> But I'm interested in why the language was designed this way.</p>\n<p>What's more interesting is the function type can be implicitly converted to pointer to itself when using as a parameter, but will not be converted to a pointer to itself when using as a return type!</p>\n<p><strong>Example:</strong></p>\n<pre><code>typedef bool FunctionType(int);\nvoid g(FunctionType); // Implicitly converted to void g(FunctionType *).\nFunctionType h(); // Error!\nFunctionType * j(); // Return a function pointer to a function \n                    // that has the type of bool(int).\n</code></pre>\n", "AcceptedAnswerId": "12152466", "Title": "Why is using the function name as a function pointer equivalent to applying the address-of operator to the function name?", "CreationDate": "2012-08-28T02:50:12.247", "Id": "12152167", "CommentCount": "0", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:24:56.457", "LastEditorUserId": "-1", "LastActivityDate": "2017-11-12T22:54:41.627", "Score": "12", "OwnerUserId": "866732", "Tags": "<c++><syntax><function-pointers>", "AnswerCount": "3"}});