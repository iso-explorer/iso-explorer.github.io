post_cb({"35110453": {"ParentId": "8936549", "CommentCount": "2", "Body": "<p>Detecting and using <code>constexpr</code> can't be made with overloads like\nothers already replied but that is not what we usually need.</p>\n<p>We have two different algorithms, one <code>constexpr</code>, other not. We can\nachieve correct choice by selecting \"manually\" and then shortening \nit down with preprocessor macros.</p>\n<p>Usually such overloads reach same result just by different algorithms.\nHere for testing purposes I took two algorithms that give never same answers: </p>\n<pre><code>#include &lt;iostream&gt;     // handy for test I/O\n#include &lt;type_traits&gt;  // handy for dealing with types\n\n// run-time \"foo\" is always ultimate answer\nint foo_runtime(int)\n{\n    return 42;\n}\n\n// compile-time \"foo\" is factorial\nconstexpr int foo_compiletime(int num)\n{\n      return num &gt; 1 ? foo_compiletime(num - 1) * num : 1;\n}\n</code></pre>\n<p>Here is a  trick of detecting <code>constexpr</code>. I'm pretty sure that it is invented by Johannes Schaub but I can't find the cite. Very nice and \nclear trick.</p>\n<pre><code>template&lt;typename T&gt; \nconstexpr typename std::remove_reference&lt;T&gt;::type makeprval(T &amp;&amp; t) \n{\n    return t;\n}\n\n#define isprvalconstexpr(e) noexcept(makeprval(e))\n</code></pre>\n<p>So what is left is to write a \"foo\" that selects the algorithm based\non argument type and to test it:</p>\n<pre><code>#define foo(X) (isprvalconstexpr(X)?foo_compiletime(X):foo_runtime(X))\n\nint main(int argc, char *argv[])\n{\n    int a = 1;\n    const int b = 2;\n    constexpr int c = 3;\n    const int d = argc;\n\n    std::cout &lt;&lt; foo(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; foo(b) &lt;&lt; std::endl;\n    std::cout &lt;&lt; foo(c) &lt;&lt; std::endl;\n    std::cout &lt;&lt; foo(d) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Expected output is:</p>\n<pre><code>42\n2\n6\n42\n</code></pre>\n<p>On the few compilers that I tried here it works like expected.</p>\n", "OwnerUserId": "528720", "PostTypeId": "2", "Id": "35110453", "Score": "4", "CreationDate": "2016-01-31T04:48:37.997", "LastActivityDate": "2016-01-31T04:48:37.997"}, "8938675": {"ParentId": "8936549", "CommentCount": "0", "Body": "<p>The problem, as stated, feels <em>wrong</em>.</p>\n<hr>\n<p>A <code>std::string</code>, by construction, owns the memory. If you want a simple reference to an existing buffer, you can use something akin to <code>llvm::StringRef</code>:</p>\n<pre><code>class StringRef {\npublic:\n  constexpr StringRef(char const* d, size_t s): data(d), size(s) {}\n\nprivate:\n  char const* data;\n  size_t size;\n};\n</code></pre>\n<p>Of course, there is the bummer that <code>strlen</code> and all the others C functions are <strong>not</strong> <code>constexpr</code>. <em>This</em> feels like a defect of the Standard (think about all the maths functions...).</p>\n<hr>\n<p>As for state, you can (a bit), as long as you understand <em>how</em> to store it. Remember that loops are equivalent to recursions ? Well, likewise, you can \"store\" state by passing it as argument to a helper function.</p>\n<pre><code>// potentially unsafe (non-limited)\nconstexpr int length(char const* c) {\n  return *c == '\\0' ? 0 : 1 + length(c+1);\n}\n\n// OR a safer version\nconstexpr int length_helper(char const* c, unsigned limit) {\n  return *c == '\\0' or limit &lt;= 0 ? 0 : 1 + length_helper(c+1, limit-1);\n}\n\nconstexpr int length256(char const* c) { return length_helper(c, 256); }\n</code></pre>\n<p>Of course, this form of this state is somewhat limited (you cannot use complicated constructs) and that is a limitation of <code>constexpr</code>. But it's already a <em>huge</em> leap forward. Going further would mean going deeper into purity (which is hardly possible in C++).</p>\n</hr></hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "8938675", "Score": "4", "CreationDate": "2012-01-20T08:37:03.287", "LastActivityDate": "2012-01-20T08:37:03.287"}, "8936549": {"CommentCount": "10", "AcceptedAnswerId": "8936637", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-01-20T03:54:52.140", "LastActivityDate": "2016-01-31T04:48:37.997", "LastEditDate": "2017-05-23T11:46:21.557", "ViewCount": "5659", "FavoriteCount": "11", "Title": "constexpr overloading", "Id": "8936549", "Score": "34", "Body": "<p>Related: <a href=\"https://stackoverflow.com/questions/7779013/probrem-with-constexpr-how-to-resolve-it\">Function returning constexpr does not compile</a></p>\n<p>I feel like constexpr is limited in usefulness in C++11 because of the inability to define two functions that would otherwise have the same signature, but have one be constexpr and the other not constexpr. In other words, it would be very helpful if I could have, for example, a constexpr std::string constructor that takes constexpr arguments only, and a non-constexpr std::string constructor for non-constexpr arguments. Another example would be a theoretically complicated function that could be made more efficient by using state. You can't easily do that with a constexpr function, so you are left with two choices: have a constexpr function that is very slow if you pass in non-constexpr arguments, or give up on constexpr entirely (or write two separate functions, but you may not know which version to call).</p>\n<p>My question, therefore, is this:</p>\n<p>Is it possible for a standard-compliant C++11 implementation to allow function overloading based on the arguments being constexpr, or would this require updating the standard? If it is not allowed, was it intentionally not allowed?</p>\n<hr>\n<p>@NicolBolas: Say I have a function that maps an <code>enum</code> to a <code>std::string</code>. The most straight-forward way to do this, assuming my <code>enum</code> goes from <code>0</code> to <code>n - 1</code>, is to create an array of size <code>n</code> filled with the result.</p>\n<p>I could create a <code>static constexpr char const * []</code> and construct a <code>std::string</code> on return (paying the cost of creating a <code>std::string</code> object every time I call the function), or I can create a <code>static std::string const []</code> and return the value I look up, paying the cost of all of the <code>std::string</code> constructors the first time I call the function. It seems like a better solution would be to create the <code>std::string</code> in memory at compile time (similar to what is done now with <code>char const *</code>), but the only way to do this would be to alert the constructor that it has <code>constexpr</code> arguments.</p>\n<p>For a an example other than a <code>std::string</code> constructor, I think it's pretty straight-forward to find an example where, if you could ignore the requirements of <code>constexpr</code> (and thus create a non-<code>constexpr</code> function), you could create a more efficient function. Consider this thread: <a href=\"https://stackoverflow.com/questions/7065200/constexpr-question-why-do-these-two-different-programs-run-in-such-a-different\">constexpr question, why do these two different programs run in such a different amount of time with g++?</a></p>\n<p>If I call <code>fib</code> with a <code>constexpr</code> argument, I can't beat do better than the compiler optimizing away the function call entirely. But if I call <code>fib</code> with a non-<code>constexpr</code> argument, I may want to have it call my own version that implements things like memoization (which would require state) so I get run time similar to what would have been my compile time had I passed a <code>constexpr</code> argument.</p>\n</hr>", "Tags": "<c++><c++11><overloading><compile-time-constant><constexpr>", "OwnerUserId": "852254", "AnswerCount": "6"}, "9962944": {"ParentId": "8936549", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I agree that this feature is missing - I need it too.\nExample:</p>\n<pre><code>double pow(double x, int n) {\n    // calculate x to the power of n\n    return ...\n}\n\nstatic inline double pow (double x, constexpr int n) {\n    // a faster implementation is possible when n is a compile time constant\n    return ...\n}\n\ndouble myfunction (double a, int b) {\n    double x, y;\n    x = pow(a, b);  // call version 1 unless b becomes a compile time constant by inlining\n    y = pow(a, 5),  // call version 2\n    return x + y;\n}\n</code></pre>\n<p>Now I have to do this with templates:</p>\n<pre><code>template &lt;int n&gt;\nstatic inline double pow (double x) {\n    // fast implementation of x ^ n, with n a compile time constant\n    return ...\n}\n</code></pre>\n<p>This is fine, but I miss the overload opportunity. If I make a library function for others to use then it is inconvenient that the user has to use different function calls depending on whether n is a compile time constant or not, and it may be difficult to predict whether the compiler has reduced n to a compile time constant or not.</p>\n", "OwnerUserId": "862391", "LastEditorUserId": "304", "LastEditDate": "2012-04-01T09:30:16.537", "Id": "9962944", "Score": "29", "CreationDate": "2012-04-01T08:23:18.723", "LastActivityDate": "2012-04-01T09:30:16.537"}, "8936733": {"ParentId": "8936549", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_8936549_8936733_0\">Is it possible for a standard-compliant C++11 implementation to allow function overloading based on the arguments being constexpr, or would this require updating the standard? If it is not allowed, was it intentionally not allowed?</p>\n</blockquote>\n<p>If the standard doesn't say you can do something, then allowing someone to do it would be non-standard behavior. And therefore, a compiler that allowed it would be implementing a language extension.</p>\n<p>That's not necessarily a bad thing, after all. But it wouldn't be compliant C++11.</p>\n<p>We can only guess at the intentions of the standards committee. They may have deliberately not allowed it, or it may have been something of an oversight. The fact is that the standard doesn't overloading is allowed, therefore it isn't.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "8936733", "Score": "2", "CreationDate": "2012-01-20T04:27:20.583", "LastActivityDate": "2012-01-20T04:27:20.583"}, "8936637": {"ParentId": "8936549", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>It would have to be overloaded based on the result being <code>constexpr</code> or not, rather than the arguments.</p>\n<p>A <code>const std::string</code> could store a pointer to the literal, knowing that it would never be written to (using <code>const_cast</code> to remove <code>const</code> from the <code>std::string</code> would be necessary, and that's already undefined behavior).  It'd just be necessary to store a boolean flag to inhibit freeing the buffer during destruction.</p>\n<p>But a non-<code>const</code> string, even if initialized from <code>constexpr</code> arguments, requires dynamic allocation, because a writable copy of the argument is required, and therefore a hypothetical <code>constexpr</code> constructor should not be used.</p>\n<hr>\n<p>From the standard (section 7.1.6.1 <code>[dcl.type.cv]</code>), modifying any object which was created <code>const</code> is undefined behavior:</p>\n<blockquote>\n<p id=\"so_8936549_8936637_0\">Except that any class member declared mutable (7.1.1) can be modi\ufb01ed, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-01-20T06:34:52.660", "Id": "8936637", "Score": "4", "CreationDate": "2012-01-20T04:12:37.103", "LastActivityDate": "2012-01-20T06:34:52.660"}, "bq_ids": {"n4140": {"so_8936549_8936637_0": {"section_id": 5433, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_8936549_8936637_0": {"section_id": 5228, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_8936549_8936637_0": {"section_id": 6861, "quality": 0.8888888888888888, "length": 16}}}, "22062918": {"ParentId": "8936549", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>While there is no such thing as \"constexpr overloading\" in C++11, you can still use GCC/Clang <code>__builtin_constant_p</code> intrinsic. Note, that this optimization is not very useful for <code>double pow(double)</code>, because both GCC and Clang already can optimize pow for constant integral exponents, but if you write a multiprecision or vector library, then this optimization should work.</p>\n<p>Check this example:\n</p>\n<pre><code>#define my_pow(a, b) (__builtin_constant_p(b) ? optimized_pow(a, b) : generic_pow(a, b))\n\ndouble generic_pow(double a, double b);\n\n__attribute__((always_inline)) inline double optimized_pow(double a, double b) {\n    if (b == 0.0) return 1.0;\n    if (b == 1.0) return a;\n    if (b == 2.0) return a * a;\n    if (b == 3.0) return a * a * a;\n    if (b == 4.0) return a * a * a * a;\n\n    return generic_pow(a, b);\n}\n\ndouble test(double a, double b) {\n    double x = 2.0 + 2.0;\n    return my_pow(a, x) + my_pow(a, b);\n}\n</code></pre>\n<p>In this example <code>my_pow(a, x)</code> will be expanded to <code>a*a*a*a</code> (thanks to dead code elimination), and <code>my_pow(a, b)</code> will be expanded to direct <code>generic_pow</code> call without any preliminary checks.</p>\n", "OwnerUserId": "337979", "LastEditorUserId": "337979", "LastEditDate": "2014-02-27T08:44:42.250", "Id": "22062918", "Score": "4", "CreationDate": "2014-02-27T08:27:46.417", "LastActivityDate": "2014-02-27T08:44:42.250"}});