post_cb({"bq_ids": {"n4140": {"so_33086346_33086461_0": {"length": 11, "quality": 1.0, "section_id": 480}}, "n3337": {"so_33086346_33086461_0": {"length": 11, "quality": 1.0, "section_id": 471}}, "n4659": {"so_33086346_33086461_0": {"length": 11, "quality": 1.0, "section_id": 502}}}, "33086346": {"ViewCount": "857", "Body": "<p>In the following code, are <code>pS</code> and <code>s.pS</code> guaranteed to be equal in the final line? In other words, in the statement <code>S s = S();</code>, can I be sure that a temporary <code>S</code> will not be constructed?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct S\n{\n  S() { pS = this; }\n  S* pS;\n};\n\nint main()\n{\n  S s = S();\n  S* pS = &amp;s;\n  cout &lt;&lt; pS &lt;&lt; \" \" &lt;&lt; s.pS &lt;&lt; endl;\n}\n</code></pre>\n<p>In every compiler I've tested this in <code>pS == s.pS</code>, but I'm not sufficiently familiar with the standard to be able to satisfy myself that this is guaranteed.</p>\n", "AcceptedAnswerId": "33086461", "Title": "In S s = S() is it guaranteed that no temporary will be created?", "CreationDate": "2015-10-12T16:52:31.120", "Id": "33086346", "CommentCount": "3", "LastEditDate": "2015-10-12T23:54:33.650", "PostTypeId": "1", "LastEditorUserId": "1350209", "LastActivityDate": "2015-10-12T23:54:33.650", "Score": "14", "OwnerUserId": "995218", "Tags": "<c++><constructor><language-lawyer><temporary>", "AnswerCount": "3"}, "33087259": {"Id": "33087259", "PostTypeId": "2", "Body": "<p>There is no guarantee that there will be no temporary. But the Big Three compilers will optimize it out (even with the <code>-O0</code> switch).</p>\n<p>To guarantee no temporary at all just write:</p>\n<pre><code>int main()\n{\n  // ...\n  S s{};\n  // ...\n}\n</code></pre>\n<p>Or simply <code>S s;</code>.</p>\n", "LastEditorUserId": "333698", "LastActivityDate": "2015-10-12T20:44:21.847", "Score": "5", "CreationDate": "2015-10-12T17:50:52.157", "ParentId": "33086346", "CommentCount": "0", "OwnerUserId": "1555823", "LastEditDate": "2015-10-12T20:44:21.847"}, "33086452": {"Id": "33086452", "PostTypeId": "2", "Body": "<p>Most compilers performs what's called <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\">copy/move elision</a>, which is specified by the C++ standard. But it is not guaranteed. For example, you can compile with <code>-fno-elide-constructors</code> in gcc and you'll see <em>all</em> constructors in all their glory. </p>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/c5576dc1bce7298c\">Live example on Coliru</a></kbd></p>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2015-10-12T19:40:59.183", "Score": "11", "CreationDate": "2015-10-12T16:58:01.770", "ParentId": "33086346", "CommentCount": "0", "OwnerUserId": "3093378", "LastEditDate": "2015-10-12T19:40:59.183"}, "33086461": {"Id": "33086461", "PostTypeId": "2", "Body": "<p><strong>NO</strong></p>\n<p>The compiler isn't <em>obligated</em> to do copy elision. The standard simply specifies that, [class.copy]:</p>\n<blockquote>\n<p id=\"so_33086346_33086461_0\">When certain criteria are met, an implementation <strong>is allowed to</strong> omit the copy/move construction of a class object [...]</p>\n</blockquote>\n<p>I can disable copy elision via <code>-fno-elide-constructors</code>, and then the two pointers will definitely be different. For example:</p>\n<pre><code>$g++ -std=c++11 -Wall -pedantic -fno-elide-constructors -Wall -Wextra main.cpp &amp;&amp; ./a.out\n0x7fff5a598920 0x7fff5a598930\n</code></pre>\n<p>And in the general case, if we add <code>S(S&amp;&amp; ) = delete</code>, then the above code wouldn't even compile. </p>\n", "LastActivityDate": "2015-10-12T16:58:34.973", "CommentCount": "5", "CreationDate": "2015-10-12T16:58:34.973", "ParentId": "33086346", "Score": "16", "OwnerUserId": "2069064"}});