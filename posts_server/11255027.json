post_cb({"11255258": {"ParentId": "11255027", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I've upvoted ildjarn's answer because I found it both accurate and humorous. :-)</p>\n<p>I'm providing an alternate answer because I'm assuming because of the title of the question that the OP might want to know <strong>why</strong> the standard says so.</p>\n<p><strong>background</strong></p>\n<p>C++ has implicitly generated copy members because if it didn't, it would've been still-born in 1985 because it was <strong>so</strong> incompatible with C.  And in that case we wouldn't be having this conversation today because C++ wouldn't exist.</p>\n<p>That being said, implicitly generated copy members are akin to a \"deal with the devil\".  C++ couldn't have been born without them.  But they are evil in that they silently generate incorrect code in a significant number of instances.  The C++ committee isn't stupid, they know this.</p>\n<p><strong>C++11</strong></p>\n<p>Now that C++ has been born, and has evolved into a successful grownup, the committee would just love to say:  we're not doing implicitly generated copy members any more.  They are too dangerous.  If you want an implicitly generated copy member you have to opt-in to that decision (as opposed to opt-out of it).  However considering the amount of existing C++ code that would break if this was done, that would be tantamount to suicide.  There is a <em>huge</em> backwards compatibility concern that is quite justified.</p>\n<p>So the committee reached a compromise position:  If you declare move members (which legacy C++ code can't do), then we're going to assume that the default copy members are likely to do the wrong thing.  Opt-in (with <code>=default</code>) if you want them.  Or write them yourself.  Otherwise they are implicitly deleted.  Our experience to-date in a world with move-only types indicates that this default position is actually quite commonly what is desired (e.g. <code>unique_ptr</code>, <code>ofstream</code>, <code>future</code>, etc.).  And the expense of opting-in is actually quite small with <code>= default</code>.</p>\n<p><strong>Looking Forward</strong></p>\n<p>The committee would love to even say:  If you've written a destructor, it is likely that the implicit copy members are incorrect, so we will delete them.  This is the C++98/03 \"rule of three\".  However even that would break lots of code.  However the committee has said in C++11 that if you provide a user-declared destructor, the implicit generation of copy members <strong>is deprecated</strong>.  That means that this feature could be removed in a future standard.  And that any day now your compiler might start issuing \"deprecated warnings\" in this situation (the standard can not specify warnings).</p>\n<p><strong>Conclusion</strong></p>\n<p>So be forewarned:  C++ has grown up and matured over the decades.  And that means that your father's C++ may need migrating to deal with your child's C++.  It is a slow, gradual process so that you don't throw up your hands and just port to another language.  But it <strong>is</strong> change, even if slow.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2014-12-12T20:59:06.633", "Id": "11255258", "Score": "74", "CreationDate": "2012-06-29T02:15:27.187", "LastActivityDate": "2014-12-12T20:59:06.633"}, "11255027": {"CommentCount": "0", "AcceptedAnswerId": "11255258", "PostTypeId": "1", "LastEditorUserId": "415784", "CreationDate": "2012-06-29T01:33:30.877", "LastActivityDate": "2014-12-12T20:59:06.633", "LastEditDate": "2012-06-29T17:43:39.190", "ViewCount": "8714", "FavoriteCount": "16", "Title": "Why user-defined move-constructor disables the implicit copy-constructor?", "Id": "11255027", "Score": "28", "Body": "<p>While I'm reading boost/shared_ptr.hpp, i saw this code:</p>\n<pre><code>//  generated copy constructor, destructor are fine...\n\n#if defined( BOOST_HAS_RVALUE_REFS )\n\n// ... except in C++0x, move disables the implicit copy\n\nshared_ptr( shared_ptr const &amp; r ): px( r.px ), pn( r.pn ) // never throws\n{\n}\n\n#endif\n</code></pre>\n<p>What does the comment \"generated copy constructor, destructor are fine except in C++11, move disables the implicit copy\" mean here? Shall we always write the copy ctor ourselves to prevent this situation in C++11?</p>\n", "Tags": "<c++><boost><c++11><copy-constructor><rvalue-reference>", "OwnerUserId": "108176", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11255027_11255089_1": {"section_id": 5979, "quality": 0.7142857142857143, "length": 5}, "so_11255027_11255089_0": {"section_id": 456, "quality": 0.8780487804878049, "length": 36}}, "n3337": {"so_11255027_11255089_1": {"section_id": 447, "quality": 1.0, "length": 7}, "so_11255027_11255089_0": {"section_id": 447, "quality": 0.9512195121951219, "length": 39}, "so_11255027_11255089_2": {"section_id": 447, "quality": 1.0, "length": 9}}, "n4659": {"so_11255027_11255089_1": {"section_id": 479, "quality": 0.5714285714285714, "length": 4}, "so_11255027_11255089_0": {"section_id": 479, "quality": 0.8780487804878049, "length": 36}}}, "11255089": {"ParentId": "11255027", "CommentCount": "2", "Body": "<p>Because the C++ standard says so \u2013 \u00a712.8/7:</p>\n<blockquote>\n<p id=\"so_11255027_11255089_0\">If the class definition does not explicitly declare a copy constructor, one is declared <em>implicitly</em>. <strong>If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted</strong>; otherwise, it is defined as defaulted. The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor. Thus, for the class definition</p>\n<pre><code>struct X {\n    X(const X&amp;, int);\n};\n</code></pre>\n<p id=\"so_11255027_11255089_1\">a copy constructor is implicitly-declared. If the user-declared constructor is later defined as</p>\n<pre><code>X::X(const X&amp; x, int i =0) { /* ... */ }\n</code></pre>\n<p id=\"so_11255027_11255089_2\">then any use of X\u2019s copy constructor is ill-formed because of the ambiguity; no diagnostic is required.</p>\n</blockquote>\n<p>(Emphasis mine.)</p>\n", "OwnerUserId": "636019", "PostTypeId": "2", "Id": "11255089", "Score": "18", "CreationDate": "2012-06-29T01:45:09.373", "LastActivityDate": "2012-06-29T01:45:09.373"}});