post_cb({"29525852": {"ParentId": "29525797", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>C++14 draft N4140 [basic.scope.pdecl]/1:</p>\n<blockquote>\n<p id=\"so_29525797_29525852_0\">The <em>point of declaration</em> for a name is immediately after its complete declarator (Clause 8) and before its\n  <em>initializer</em> (if any), except as noted below. [ <em>Example:</em></p>\n</blockquote>\n<pre><code>unsigned char x = 12;\n{ unsigned char x = x; }\n</code></pre>\n<blockquote>\n<p id=\"so_29525797_29525852_1\">Here the second <code>x</code> is initialized with its own (indeterminate) value. <em>\u2014end example</em> ]</p>\n</blockquote>\n", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "LastEditDate": "2015-04-08T22:07:26.050", "Id": "29525852", "Score": "3", "CreationDate": "2015-04-08T21:39:59.343", "LastActivityDate": "2015-04-08T22:07:26.050"}, "29525797": {"CommentCount": "5", "ViewCount": "138", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-04-08T21:35:57.577", "LastActivityDate": "2015-04-09T02:43:06.767", "Title": "Can a variable be used while being declared?", "FavoriteCount": "1", "LastEditDate": "2015-04-09T02:03:30.647", "Id": "29525797", "Score": "5", "Body": "<p>Why does the following compile without an error?:</p>\n<pre><code>int main()\n{\n    int x = x;  //I thought this should cause an error\n    return 0;\n}\n</code></pre>\n<p>Where in the standards is it explained why this is allowed?</p>\n", "Tags": "<c++><c><variables><language-lawyer><undefined-behavior>", "OwnerUserId": "4766219", "AnswerCount": "4"}, "29525932": {"ParentId": "29525797", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The answer for C++ - I am quoting C++11 standard:</p>\n<p>3.3.3.1:</p>\n<blockquote>\n<p id=\"so_29525797_29525932_0\">A name declared in a block (6.3) is local to that block; it has block scope. Its potential scope begins at its point of declaration (3.3.2) and ends at the end of its block.</p>\n</blockquote>\n<p>And the point of declaration is defined in 3.3.2 as</p>\n<blockquote>\n<p id=\"so_29525797_29525932_1\">The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer (if any), except as noted below.</p>\n<p id=\"so_29525797_29525932_2\">[ Example:</p>\n</blockquote>\n<pre><code> int x = 12;\n { int x = x; }\n</code></pre>\n<blockquote>\n<p id=\"so_29525797_29525932_3\">Here the second x is initialized with its own (indeterminate) value. \u2014 end example ]</p>\n</blockquote>\n<p>Obviously, using the value of <code>x</code> before it is initialised is undefined behaviour.</p>\n", "OwnerUserId": "2382136", "LastEditorUserId": "2382136", "LastEditDate": "2015-04-08T21:49:28.170", "Id": "29525932", "Score": "3", "CreationDate": "2015-04-08T21:45:46.513", "LastActivityDate": "2015-04-08T21:49:28.170"}, "29526012": {"ParentId": "29525797", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This question has a slightly different answer in C than in C++.</p>\n<p>In both cases, <code>int x = x;</code> tries to initialize <code>x</code> with itself.</p>\n<hr>\n<p><strong>In C++</strong>: [dcl.init]/12 (N3936) says that any evaluation of an object with indeterminate value causes undefined behaviour, <em>except for</em> certain cases involving unsigned <code>char</code>. In fact there is an <em>Example</em>:</p>\n<pre><code>int f(bool b) {\n    unsigned char c;\n    unsigned char d = c; // OK, d has an indeterminate value\n    int e = d;        // undefined behavior\n    return b ? d : 0; // undefined behavior if b is true\n}\n</code></pre>\n<hr>\n<p><strong>In C:</strong> It is more complicated. This is very similar to the behaviour of <code>int b;  foo(b - b);</code> which is <a href=\"https://stackoverflow.com/questions/25074180/is-aa-or-a-a-undefined-behaviour-if-a-is-not-initialized/\">covered in full here</a>.</p>\n<p>I won't repeat that text but the conclusions are, in C11:</p>\n<ul>\n<li><code>int a = a; &amp;a;</code> causes UB if and only if the system has trap representations for <code>int</code></li>\n<li><code>int a = a;</code>, with no subsequent occurrence of <code>&amp;a</code>, causes UB.</li>\n</ul>\n<hr>\n<p>Historical note: In C90 this caused UB. In C99 the <em>trap representation</em> was introduced, and in C11 the possibility of register trap was introduced (for Itanium).  The C++ standard doesn't deal with trap representations at all, it seems underspecified in the case of things like <a href=\"https://stackoverflow.com/questions/29394518/whats-the-result-of-a-b\">bitwise operators</a> generating negative zero.</p>\n</hr></hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:26:59.037", "Id": "29526012", "Score": "6", "CreationDate": "2015-04-08T21:51:27.997", "LastActivityDate": "2015-04-08T22:15:36.670"}, "bq_ids": {"n4140": {"so_29525797_29528757_2": {"section_id": 7193, "quality": 0.9577464788732394, "length": 68}, "so_29525797_29525932_1": {"section_id": 7049, "quality": 0.875, "length": 14}, "so_29525797_29525932_0": {"section_id": 7061, "quality": 0.8947368421052632, "length": 17}, "so_29525797_29528757_3": {"section_id": 3291, "quality": 0.8695652173913043, "length": 40}, "so_29525797_29525852_0": {"section_id": 7049, "quality": 0.8235294117647058, "length": 14}, "so_29525797_29525932_3": {"section_id": 7049, "quality": 0.7777777777777778, "length": 7}, "so_29525797_29525852_1": {"section_id": 7049, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_29525797_29528757_2": {"section_id": 6937, "quality": 0.9014084507042254, "length": 64}, "so_29525797_29525932_1": {"section_id": 6794, "quality": 0.875, "length": 14}, "so_29525797_29525932_0": {"section_id": 6805, "quality": 0.8947368421052632, "length": 17}, "so_29525797_29525852_0": {"section_id": 6794, "quality": 0.8235294117647058, "length": 14}, "so_29525797_29525932_3": {"section_id": 6794, "quality": 0.7777777777777778, "length": 7}, "so_29525797_29525852_1": {"section_id": 6794, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_29525797_29528757_2": {"section_id": 8702, "quality": 0.9436619718309859, "length": 67}, "so_29525797_29525932_1": {"section_id": 8546, "quality": 0.875, "length": 14}, "so_29525797_29525932_0": {"section_id": 8558, "quality": 0.8947368421052632, "length": 17}, "so_29525797_29528757_3": {"section_id": 4053, "quality": 0.8695652173913043, "length": 40}, "so_29525797_29525852_0": {"section_id": 8546, "quality": 0.8235294117647058, "length": 14}, "so_29525797_29525932_3": {"section_id": 8546, "quality": 0.7777777777777778, "length": 7}, "so_29525797_29525852_1": {"section_id": 8546, "quality": 0.7777777777777778, "length": 7}}}, "29528757": {"ParentId": "29525797", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There really are two parts to this question, the one asked:</p>\n<blockquote>\n<p id=\"so_29525797_29528757_0\">Can a variable be used while being declared?</p>\n</blockquote>\n<p>where there answer clearly is Yes, due to the point of declaration rule quoted in other answers.</p>\n<p>And, equally important but not asked:</p>\n<blockquote>\n<p id=\"so_29525797_29528757_1\">What usages of a variable during its declaration are safe?</p>\n</blockquote>\n<p>Well, within the initializer, the variable has not yet completed initialization (a matter of object lifetime), and in fact construction hasn't yet even started.  The object lifetime rules (section 3.8 of the Standard) state that some but not all operations are permitted on such a variable:</p>\n<blockquote>\n<p id=\"so_29525797_29528757_2\">Before  the  lifetime  of  an  object  has  started  but  after  the  storage  which  the  object  will  occupy  has  been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways.  For an object under construction or destruction, see 12.7.  Otherwise,\n  such a pointer refers to allocated storage, and using the pointer as if the pointer were of type <code>void*</code>, is well-defined.  Indirection through such a pointer is permitted but the resulting lvalue may only be used in limited ways, as described below.  The program has undefined behavior if:</p>\n<ul>\n<li>the  object  will  be  or  was  of  a  class  type  with  a  non-trivial  destructor  and  the  pointer  is  used  as  the operand of a delete-expression,</li>\n<li>the  pointer  is  used  to  access  a  non-static  data  member  or  call  a  non-static  member  function  of  the object, or</li>\n<li>the  pointer  is  implicitly  converted  to  a  pointer  to  a  virtual  base  class,  or</li>\n<li>the  pointer  is  used  as  the  operand  of  a  <code>static_cast</code>,  except  when  the  conversion  is  to  pointer to <em><code>cv</code></em> <code>void</code>, or to pointer to <em><code>cv</code></em> <code>void</code> and subsequently to pointer to either <em><code>cv</code></em> <code>char</code> or <em><code>cv</code></em> <code>unsigned char</code>, or </li>\n<li>the  pointer  is  used  as  the  operand  of  a  <code>dynamic_cast</code>.</li>\n</ul>\n</blockquote>\n<p>Effectively, for types with non-trivial initialization, the memory location doesn't contain an object yet, so it has no dynamic type, and attempting to access it as any type except <code>char</code> or <code>unsigned char</code> immediately falls afoul of strict aliasing.</p>\n<p>For types with trivial initialization, including <code>int</code>, an object exists as soon as properly aligned storage is acquired.  But if that storage has automatic or dynamic storage duration, the value is indeterminate until the variable is written to.  This rule from section 8.5 applies:</p>\n<blockquote>\n<p id=\"so_29525797_29528757_3\">If  no  initializer  is  speci\ufb01ed  for  an  object,  the  object  is  default-initialized.   When  storage  for  an  object with  automatic  or  dynamic  storage  duration  is  obtained,  the  object  has  an  indeterminate  value,  and  if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced.  [ Note:  Objects with static or thread storage duration are zero-initialized,  see 3.6.2.   \u2014\n  end note ] If an indeterminate value is produced by an evaluation, the behavior is undefined except in the following cases:</p>\n</blockquote>\n<p>and all the exceptional cases listed are specific to <code>unsigned char</code>.</p>\n<p>At first glance, this rule appears not to apply, because an initializer is specified.  However, during evaluation of the initializer, we are exactly in the case that \"When  storage  for  an  object with  automatic  or  dynamic  storage  duration  is  obtained\" where the rule does apply.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2015-04-09T02:43:06.767", "Id": "29528757", "Score": "0", "CreationDate": "2015-04-09T02:34:19.010", "LastActivityDate": "2015-04-09T02:43:06.767"}});