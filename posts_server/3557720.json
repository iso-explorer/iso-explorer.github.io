post_cb({"3557754": {"ParentId": "3557720", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3557720_3557754_0\">I am aware of the 2s complement representation of signed values.</p>\n</blockquote>\n<p>Well, obviously you aren't. A 1 followed by all 0s is always the smallest negative number.</p>\n", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "3557754", "Score": "13", "CreationDate": "2010-08-24T14:51:19.440", "LastActivityDate": "2010-08-24T14:51:19.440"}, "3557746": {"ParentId": "3557720", "CommentCount": "4", "Body": "<p>Because on your compiler, <code>char</code> means <code>signed char</code>.</p>\n<p>Char is just a tiny integer, generally in the range of 0...255 (for <code>unsigned char</code>) or -128...127 (for <code>signed char</code>).  </p>\n<p>The means of converting a number to 2-complement negative is to \"invert the bits and add 1\"</p>\n<p>128 = \"1000 0000\".  Inverting the bits is \"0111 1111\". Adding 1 yields: \"1000 0000\"</p>\n", "OwnerUserId": "12725", "PostTypeId": "2", "Id": "3557746", "Score": "14", "CreationDate": "2010-08-24T14:50:04.297", "LastActivityDate": "2010-08-24T14:50:04.297"}, "3557752": {"ParentId": "3557720", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The answer is implementation defined as the type of 'default char' is implementation defined.</p>\n<p>$3.9.1/1</p>\n<blockquote>\n<p id=\"so_3557720_3557752_0\">Objects declared as characters (char)\n  shall be large enough to store any\n  member of the implementation\u2019s basic\n  character set. If a character from\n  this set is stored in a character\n  object, the integral value of that\n  character object is equal to the value\n  of the single character literal form\n  of that character. It is\n  implementationdefined whether a char\n  object can hold negative values.\n  Characters can be explicitly declared\n  unsigned or signed. Plain char, signed\n  char, and unsigned char are three\n  distinct types.</p>\n</blockquote>\n<p>$5.8/1 -</p>\n<blockquote>\n<p id=\"so_3557720_3557752_1\">\"The operands shall be of integral or\n  enumeration type and integral\n  promotions are performed. The type of\n  the result is that of the promoted\n  left operand. The behavior is\n  undefined if the right operand is\n  negative, or greater than or equal to\n  the length in bits of the promoted\n  left operand.\"</p>\n</blockquote>\n<p>So when the value of char becomes negative, left shift from thereon has undefined behavior.</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2010-08-24T15:10:05.050", "Id": "3557752", "Score": "2", "CreationDate": "2010-08-24T14:50:47.740", "LastActivityDate": "2010-08-24T15:10:05.050"}, "3557773": {"ParentId": "3557720", "CommentCount": "2", "Body": "<p>That's how it works.</p>\n<pre>\n-1 = 1111 1111\n-2 = 1111 1110\n-3 = 1111 1101\n-4 = 1111 1110\n...\n-126 = 1000 0010\n-127 = 1000 0001\n-128 = 1000 0000\n</pre>\n", "OwnerUserId": "84007", "PostTypeId": "2", "Id": "3557773", "Score": "1", "CreationDate": "2010-08-24T14:53:16.190", "LastActivityDate": "2010-08-24T14:53:16.190"}, "3560842": {"ParentId": "3557720", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Supplying a <code>char</code> to a %d format specifier that expects an <code>int</code> is probably unwise. </p>\n<p>Whether an unadorned <code>char</code> is signed or unsigned is implementation defined.  In this case not only is it apparently signed, but also the char argument has been pushed on to the stack an an <code>int</code> sized object and <em>sign extended</em> so that the higher order bits are all set to the same value as the high order bit of the original char.</p>\n<p>I am not sure whether this is defined behaviour or not without looking it up, but personally I'd have cast the char to an int when formatting it with %d.  Not least because some compilers and static analysis tools will trap that error and issue a warning.  GCC will do so when <code>-Wformat</code> is used for example.</p>\n<p>That is the explanation, if you want a solution (i.e. one that prints 128 rather than -128) then you need to cast to unsigned and mask-off the sign extension bits as well as using a correctly matching format specifier:</p>\n<pre><code>printf(\"%u\", (unsigned)ch &amp; 0xff );\n</code></pre>\n", "OwnerUserId": "168986", "LastEditorUserId": "168986", "LastEditDate": "2010-08-26T21:53:07.920", "Id": "3560842", "Score": "0", "CreationDate": "2010-08-24T20:40:45.487", "LastActivityDate": "2010-08-26T21:53:07.920"}, "3558012": {"ParentId": "3557720", "CommentCount": "0", "Body": "<p>Two's complement is exactly like unsigned binary representation with one slight change:</p>\n<p>The MSB (bit n-1) is redefined to have a value of -2<sup>n-1</sup> instead of 2<sup>n-1</sup>.</p>\n<p>That's why the addition logic is unchanged: because all the other bits still have the same place value.</p>\n<p>This also explains the underflow/overflow detection method, which involves checking the carry from bit (n-2) into bit (n-1).</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "3558012", "Score": "0", "CreationDate": "2010-08-24T15:17:24.527", "LastActivityDate": "2010-08-24T15:17:24.527"}, "3560009": {"ParentId": "3557720", "CommentCount": "0", "Body": "<p>There is a pretty simple process for converting from a negative two's complement integer value to it's positive equivalent.</p>\n<pre><code>0000 0001 ; The x = 1\n1000 0000 ; x &lt;&lt;= 7\n</code></pre>\n<p>The two's complement process is two-steps... first, if the high-bit is 1, reverse all bits</p>\n<pre><code>0111 1111 ; (-) 127\n</code></pre>\n<p>then add 1</p>\n<pre><code>1000 0000 ; (-) 128\n</code></pre>\n", "OwnerUserId": "118150", "PostTypeId": "2", "Id": "3560009", "Score": "0", "CreationDate": "2010-08-24T18:56:59.343", "LastActivityDate": "2010-08-24T18:56:59.343"}, "3557720": {"CommentCount": "2", "ViewCount": "329", "PostTypeId": "1", "LastEditorUserId": "379897", "CreationDate": "2010-08-24T14:46:42.323", "LastActivityDate": "2010-08-26T21:53:07.920", "Title": "Why, if a char is initialized to 1 and then left shifted 7 times and the value printed using %d, does it show -128?", "LastEditDate": "2010-08-24T23:14:39.170", "Id": "3557720", "Score": "0", "Body": "<p>I am aware of the 2s complement representation of signed values. But how does binary '10000000' become -128 in decimal(using %d).</p>\n<p>for +64  binary rep = '01000000' for -64 binary rep = '11000000' which is 2's complement of '01000000'</p>\n<p>can some one please explain?</p>\n<p>Program:</p>\n<pre><code>int main()\n{\n   char ch = 1;\n   int count = 0;\n   while(count != 8)\n   {\n     printf(\"Before shift val of ch = %d,count=%d\\n\",ch,count);\n     ch = ch &lt;&lt; 1;     \n\n     printf(\"After  shift val of ch = %d,count=%d\\n\",ch,count);\n     //printBinPattern(ch);  \n     printf(\"*************************************\\n\");\n     count++;\n   }\n   return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Before shift val of ch = 1, count=0\nAfter  shift val of ch = 2, count=0\n*************************************\n...\n... /* Output not shown */\nBefore shift val of ch = 32, count=5\nAfter  shift val of ch = 64, count=5\n*************************************\nBefore shift val of ch = 64, count=6\nAfter  shift val of ch = -128, count=6\n*************************************\nBefore shift val of **ch = -128**, count=7\nAfter  shift val of ch = 0, count=7\n*************************************\nBefore shift val of ch = 0, count=8\nAfter  shift val of ch = 0, count=8\n*************************************\n</code></pre>\n", "Tags": "<c++><c>", "OwnerUserId": "196146", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_3557720_3557752_0": {"section_id": 7210, "quality": 0.9803921568627451, "length": 50}, "so_3557720_3557752_1": {"section_id": 6146, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_3557720_3557752_0": {"section_id": 6954, "quality": 0.9803921568627451, "length": 50}, "so_3557720_3557752_1": {"section_id": 5909, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_3557720_3557752_0": {"section_id": 8719, "quality": 0.9803921568627451, "length": 50}, "so_3557720_3557752_1": {"section_id": 7642, "quality": 0.8928571428571429, "length": 25}}}});