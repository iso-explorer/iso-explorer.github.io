post_cb({"bq_ids": {"n4140": {"so_32359338_32359338_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 3255}}, "n3337": {"so_32359338_32359338_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 3127}}, "n4659": {"so_32359338_32359338_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 4013}}}, "32359338": {"ViewCount": "454", "Body": "<p>C++ standard section 8.3.6.4 says that</p>\n<blockquote>\n<p id=\"so_32359338_32359338_0\">For non-template functions, default arguments can be added in later\n  declarations of a function in the same scope. [...]</p>\n</blockquote>\n<p>But my question is that why it isn't allowed for template functions? What is the rationale for not allowing addition of default arguments in later declarations in same scope for template functions?</p>\n<p>Consider this program which compiles fine. (non template function) (see live demo <a href=\"http://ideone.com/6q5Cnh\" rel=\"nofollow\">here.</a>)</p>\n<pre><code>#include &lt;iostream&gt;\n\nint f(int a,int b,int c=3);\nint f(int a,int b=9,int c); // default argument in middle, ok allowed\n\nint main()\n{\n    f(3);\n    f(3,6);\n    f(3,6,9);\n    return 0;\n}\n\nint f(int a,int b,int c)\n{\n    std::cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;' '&lt;&lt;c&lt;&lt;'\\n';\n    return 0;\n}\n</code></pre>\n<p>But following fails in compilation. (template function) (see live demo <a href=\"http://ideone.com/q6dVmA\" rel=\"nofollow\">here.</a>)</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; \nvoid f(T a,int b,int c=3);\ntemplate &lt;typename T&gt; \nvoid f(T a,int b=9,int c); // compiler error why???\n\nint main()\n{\n    f(3);\n    f(3,6);\n    f(3,6,9);\n    return 0;\n}\n\ntemplate &lt;typename T&gt; \nvoid f(T a,int b,int c)\n{\n    std::cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;' '&lt;&lt;c&lt;&lt;'\\n';\n} \n</code></pre>\n", "AcceptedAnswerId": "32402399", "Title": "Why default argument can't be added later in template functions?", "CreationDate": "2015-09-02T17:17:07.407", "Id": "32359338", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-06-19T11:30:38.497", "LastEditorUserId": "3777958", "LastActivityDate": "2016-06-19T11:30:38.497", "Score": "13", "OwnerUserId": "3777958", "Tags": "<c++><templates><language-lawyer><function-templates><default-arguments>", "AnswerCount": "2"}, "32402399": {"Id": "32402399", "PostTypeId": "2", "Body": "<p>This is a historical limitation that was added fairly early in the standardization process (it was there in C++98, but not in the ARM).</p>\n<p>I don't recall the exact reason (and neither does my colleague, who was almost certainly there when the decision was made).  However, I have a guess...</p>\n<p>Back then, all-but-one compilers instantiated templates by replaying tokens through the parse.  Some barely parsed templates at all.  Consider:</p>\n<pre><code>template&lt;class T&gt; struct S {\n  T f(T);  // (1)\n};\ntemplate&lt;class T&gt; T S&lt;T&gt;::f(T p = 42) { return p; }  // (2)\nS&lt;int&gt; s;  // Causes the \"real\" parsing of (1), but not (2).\nint r = s.f();  // (3)\n</code></pre>\n<p>When resolving call (3), older compilers therefore often only had access to the instantiated declaration (1), while (2) was still not really parsed (just token-buffered).  As a result, such compilers were unaware of the added default argument in (3).</p>\n<p>Is suspect caution made the committee therefore decide to more generally disallow added default arguments in templates.</p>\n<p>That limitation is probably less (technically) justified today, since other standard requirements have since resulted in the need to parse templates in their generic form (though, e.g., MSVC still doesn't do so AFAICT).  That said, it might still be a bit of a pain to implement, because default arguments would now potentially have to be instantiated in various different contexts.</p>\n", "LastEditorUserId": "2308239", "LastActivityDate": "2015-09-04T16:37:50.777", "Score": "8", "CreationDate": "2015-09-04T16:12:45.757", "ParentId": "32359338", "CommentCount": "3", "OwnerUserId": "2308239", "LastEditDate": "2015-09-04T16:37:50.777"}, "32359603": {"Id": "32359603", "PostTypeId": "2", "Body": "<p>Because it's fundamentally impossible.</p>\n<p>In order to achieve your goal, the compiler has to implement a function that, given two template functions, returns whether or not they are the same function. The problem is that this function is unimplementable.</p>\n<p>For regular non-template functions, this is a terrible idea but still doable because you just have to match the argument types and job done.</p>\n<p>Unfortunately, for template functions, this becomes... more tricky. Consider:</p>\n<pre><code>template&lt;typename T&gt; void f(T t);\ntemplate&lt;typename U&gt; std::enable_if_t&lt;std::is_same&lt;U, int&gt;::value&gt; f(U u = U());\n</code></pre>\n<p>You can see that they probably declare the same function, <em>if</em> <code>T</code> is <code>int</code>. Otherwise, they do not. There are more problematic interactions with default template arguments and similar things, but long story short, this would be undecidable for templates.</p>\n", "LastActivityDate": "2015-09-02T17:31:19.607", "CommentCount": "7", "CreationDate": "2015-09-02T17:31:19.607", "ParentId": "32359338", "Score": "-6", "OwnerUserId": "298661"}});