post_cb({"10607182": {"ViewCount": "142", "Body": "<p>Given a base class B with a virtual function f, a derived class D and it's own implementation of f here are my scenarios: </p>\n<ol>\n<li><code>B&amp; b = *new D; b.f();</code> </li>\n<li><code>D&amp; d = *new D; d.f();</code></li>\n</ol>\n<p>Does the code in bullet 1 involve fetching f's address from vtable and then a jump?\nDoes the code in listing 2 involve any vtable lookup at all? </p>\n<p>I understand that these may be compiler dependent, and perhaps the standard will not specify the implementation details. In that case, I would be grateful if someone who understands how GCC or CLANG handles these cases provides for an explanation. </p>\n<p>Thanks.</p>\n<p>EDIT: Please cut-paste your assembler output; I am still not sure why in 2nd case there should be any lookup in vtable. </p>\n", "Title": "Calling a virtual function: compare base versus derived reference calls?", "CreationDate": "2012-05-15T19:04:05.057", "LastActivityDate": "2012-05-15T20:06:51.083", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-05-15T19:14:53.970", "LastEditorUserId": "350810", "Id": "10607182", "Score": "2", "OwnerUserId": "350810", "Tags": "<c++><gcc><polymorphism>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_10607182_10607251_0": {"length": 41, "quality": 0.5324675324675324, "section_id": 7003}, "so_10607182_10607251_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 7010}}, "n3337": {"so_10607182_10607251_0": {"length": 41, "quality": 0.5324675324675324, "section_id": 6749}, "so_10607182_10607251_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 6756}}, "n4659": {"so_10607182_10607251_0": {"length": 41, "quality": 0.5324675324675324, "section_id": 8500}, "so_10607182_10607251_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 8507}}}, "10607283": {"Id": "10607283", "PostTypeId": "2", "Body": "<p>The standard approach is to use a vtable. Only good or really clever compilers would optimize it out.</p>\n<p>Look in the assembler result of your compiler to know the answer. Most of the time (if not all the time) there is a vtable access.</p>\n", "LastActivityDate": "2012-05-15T19:11:22.847", "CommentCount": "7", "CreationDate": "2012-05-15T19:11:22.847", "ParentId": "10607182", "Score": "1", "OwnerUserId": "1390242"}, "10607294": {"Id": "10607294", "PostTypeId": "2", "Body": "<p>In the first case you are calling <code>f()</code> on an object of a class that declared that function <code>virtual</code>, so the program must do vtable lookup to find the correct derived class's override of <code>f()</code> (unless in the trivial example in your post allows the compiler to optimize this out, knowing the exact class)</p>\n<p>In the second case, there is no vtable lookup unless <code>D</code> declares <code>f()f</code> as virtual as well -- by knowing the class id <code>D</code>, the compiler knows which <code>f()</code> to call at compilation time.</p>\n<p>Update (based on comments): The second case is equivalent to the first one as <code>D</code>'s overriding function is also virtual by virtue of <code>B</code> declaring it virtual (I've learnt something new today too :))</p>\n", "LastEditorUserId": "20322", "LastActivityDate": "2012-05-15T19:24:12.470", "Score": "0", "CreationDate": "2012-05-15T19:12:28.270", "ParentId": "10607182", "CommentCount": "8", "OwnerUserId": "20322", "LastEditDate": "2012-05-15T19:24:12.470"}, "10607251": {"Id": "10607251", "PostTypeId": "2", "Body": "<p>It is a virtual method call. There must be and there is a vtable look-up at runtime in both cases.</p>\n<p>The compiler cannot know whether something happened in between the call to the constructor and the call to the function, which might have modified b and d and changed their actual type to be something else.</p>\n<p>What the standard says:</p>\n<blockquote>\n<p id=\"so_10607182_10607251_0\">2 If a virtual member function vf is declared in a class Base and in a\n  class Derived, derived directly or indirectly from Base, a member\n  function vf with the same name, parameter-type-list (8.3.5), and\n  cv-qualification as Base::vf is declared, then Derived::vf is also\n  virtual (whether or not it is so declared) and it overrides\n  Base::vf. For\n  convenience we say that any virtual function overrides itself. Then in\n  any well-formed class, for each virtual function declared in that\n  class or any of its direct or indirect base classes there is a unique\n  final overrider that overrides that function and every other overrider\n  of that function. The rules for member lookup (10.2) are used to\n  determine the final overrider for a virtual function in the scope of a\n  derived class but ignoring names introduced by using-declarations.</p>\n<p id=\"so_10607182_10607251_1\">7 [ Note: the interpretation of the call of a virtual function depends\n  on the type of the object for which it is called (the dynamic type),\n  whereas the interpretation of a call of a non-virtual member function\n  depends only on the type of the pointer or reference denoting that\n  object (the static type) (5.2.2). \u2014end note ]</p>\n</blockquote>\n<p>This does not mandate how it is done, but states pretty much clearly that the call must be resolved on the actual type of the object when the call is placed.</p>\n", "LastEditorUserId": "278842", "LastActivityDate": "2012-05-15T20:06:51.083", "Score": "2", "CreationDate": "2012-05-15T19:09:13.647", "ParentId": "10607182", "CommentCount": "1", "OwnerUserId": "278842", "LastEditDate": "2012-05-15T20:06:51.083"}, "10607393": {"Id": "10607393", "PostTypeId": "2", "Body": "<p>From the wiki:</p>\n<blockquote>\n<p id=\"so_10607182_10607393_0\">The C++ standards do not mandate exactly how dynamic dispatch must be implemented, but compilers generally use minor variations on the same basic model. Typically, the compiler creates a separate vtable for each class.</p>\n</blockquote>\n<p>the compiler will create a vtable for every class that contains <code>virtual</code> functions, as stated <a href=\"http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/\" rel=\"nofollow\">here</a>:</p>\n<blockquote>\n<p id=\"so_10607182_10607393_1\">every class that uses virtual functions (or is derived from a class that uses virtual functions) is given it\u2019s own virtual table. This table is simply a static array that the compiler sets up at compile time. A virtual table contains one entry for each virtual function that can be called by objects of the class. Each entry in this table is simply a function pointer that points to the most-derived function accessible by that class.</p>\n</blockquote>\n", "LastActivityDate": "2012-05-15T19:20:13.420", "CommentCount": "0", "CreationDate": "2012-05-15T19:20:13.420", "ParentId": "10607182", "Score": "3", "OwnerUserId": "1052126"}, "10607326": {"Id": "10607326", "PostTypeId": "2", "Body": "<p>The VTable has to be looked up in both cases, as at compile-time, the code has no idea which function to call. </p>\n<p>As all instructions are generated at compile time, a virtual function call will be translated into v-table lookup and then a jump. </p>\n", "LastActivityDate": "2012-05-15T19:14:46.337", "CommentCount": "0", "CreationDate": "2012-05-15T19:14:46.337", "ParentId": "10607182", "Score": "0", "OwnerUserId": "106494"}});