post_cb({"bq_ids": {"n4140": {"so_33691417_33714950_1": {"length": 17, "quality": 0.85, "section_id": 5440}, "so_33691417_33714950_2": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_33691417_33714950_3": {"length": 5, "quality": 1.0, "section_id": 5440}}, "n3337": {"so_33691417_33714950_1": {"length": 17, "quality": 0.85, "section_id": 5235}, "so_33691417_33714950_2": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_33691417_33714950_3": {"length": 5, "quality": 1.0, "section_id": 5235}}, "n4659": {"so_33691417_33714950_1": {"length": 17, "quality": 0.85, "section_id": 6867}, "so_33691417_33714950_2": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_33691417_33714950_3": {"length": 5, "quality": 1.0, "section_id": 6867}}}, "33691525": {"Id": "33691525", "PostTypeId": "2", "Body": "<p>*a is a pointer to int so cant call typeof on it this way</p>\n<pre><code>int *a = new int[5];\n</code></pre>\n<p>works because you are showing to integer and declarating the new array of size 5 on the place where a shows</p>\n<p>maybe you wanted :</p>\n<pre><code>typeof(new typeof(int *)[5])a;\n</code></pre>\n<p>instead</p>\n<pre><code> int * a = new typeof(*a)[5];\n</code></pre>\n", "LastEditorUserId": "5533643", "LastActivityDate": "2015-11-13T11:26:47.520", "Score": "1", "CreationDate": "2015-11-13T11:17:10.097", "ParentId": "33691417", "CommentCount": "3", "OwnerUserId": "5533643", "LastEditDate": "2015-11-13T11:26:47.520"}, "33714950": {"Id": "33714950", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_33691417_33714950_0\">or a standard C++11 feature, both don't appear to be working as per my expectations in all cases.</p>\n</blockquote>\n<p>Then you have wrong expectations - at least in the case of <code>decltype</code>. I don't know how the gcc's <code>typeof</code>  works, so I can't answer to why B) works but C) doesn't but D) and E) behave according to the standard.</p>\n<p>D) The expression given to <code>decltype</code> in this example is <code>a</code>. <code>a</code> is name of a variable. In other words it is an id-expression. In the case of an id-expression, <code>decltype</code> resolves to the type of the entity. The type of <code>a</code> is <code>int*</code>. Therefore <code>new decltype(a)[5];</code> constructs an array of <code>int*</code>. Because the type of <code>a</code> isn't <code>int**</code>, it cannot point to an array of <code>int*</code>.</p>\n<p>E) The expression given to <code>decltype</code> in this example is <code>*a</code>. The type (<code>T</code>) of the expression is <code>int</code>. But <code>*a</code> isn't a name of a variable. It isn't an id-expression like <code>a</code> is. The value category of <code>*a</code> is lvalue. In case of an lvalue-expression, <code>decltype</code> resolves to <code>T&amp;</code> where <code>T</code> is the type of the expression. Therefore, <code>decltype(*a)</code> is <code>int&amp;</code>. Arrays of references are not allowed, therefore <code>new decltype(*a)[5]</code> is not allowed.</p>\n<p>Here is the quote from the standard (draft):</p>\n<p>\u00a7 7.1.6.2 [dcl.type.simple]</p>\n<blockquote>\n<ol start=\"4\">\n<li>For an expression\n  e\n  , the type denoted by\n  decltype(e)\n  is defined as follows:</li>\n</ol>\n<p id=\"so_33691417_33714950_1\">\u2014\n   if\n  e\n  is an unparenthesized\n  id-expression\n  or an unparenthesized class member access (\n  5.2.5\n  ),\n  decltype(e)\n  is the type of the entity named by\n  e\n  . If there is no such entity, or if\n  e\n  names a set of overloaded func-\n  tions, the program is ill-formed;</p>\n<p id=\"so_33691417_33714950_2\">\u2014\n   otherwise, if\n  e\n  is an xvalue,\n  decltype(e)\n  is\n  T&amp;&amp;\n  , where\n  T\n  is the type of\n  e\n  ;</p>\n<p id=\"so_33691417_33714950_3\">\u2014\n   otherwise, if\n  e\n  is an lvalue,\n  decltype(e)\n  is\n  T&amp;\n  , where\n  T\n  is the type of\n  e\n  ;</p>\n<p id=\"so_33691417_33714950_4\">\u2014\n   otherwise,\n  decltype(e)\n  is the type of\n  e</p>\n</blockquote>\n<p>This would be correct:</p>\n<pre><code>int * a = new std::remove_pointer&lt;decltype(a)&gt;::type[5];\n</code></pre>\n<p>and also this:</p>\n<pre><code>int * a = new std::remove_reference&lt;decltype(*a)&gt;::type[5];\n</code></pre>\n<p>Of course, both of those are quite pointlessly complicated. If your objective is to avoid repeating the type, then <code>decltype</code> is not the tool you should be looking for. The tool that fits your needs is <code>auto</code>:</p>\n<pre><code>auto a = new int[5];\n</code></pre>\n", "LastActivityDate": "2015-11-15T00:15:29.657", "CommentCount": "0", "CreationDate": "2015-11-15T00:15:29.657", "ParentId": "33691417", "Score": "2", "OwnerUserId": "2079303"}, "33691417": {"ViewCount": "359", "Body": "<p>A)This works:</p>\n<pre><code>int main() {\n    int * a = new int[5];\n    delete[] a;\n    return 0;\n}\n</code></pre>\n<p>B)This errors out:</p>\n<pre><code>int main() {\n    int * a = new typeof(*a)[5];\n    delete[] a;\n    return 0;\n}\n</code></pre>\n<p>with error: invalid types 'int[int]' for array subscript</p>\n<p>C)This works:</p>\n<pre><code>int main() {\n    int * a = new typeof(a)[5];\n    delete[] a;\n    return 0;\n}\n</code></pre>\n<p>I can't understand why B fails because after expansion the statement should look like this:</p>\n<pre><code>int *a = new int[5];\n</code></pre>\n<p>because <code>typeof(*a)</code> is int.</p>\n<p>Here's the experiment with decltype:</p>\n<p>D) This doesn't work:</p>\n<pre><code>int main() {\n    int * a = new decltype(a)[5];\n    delete[] a;\n    return 0;\n}\n</code></pre>\n<p>with error: cannot convert 'int**' to 'int*' in initialization. This is expected given that decltype(a) is int* so it translates to <code>int *a = new int*[5];</code> which is incorrect.</p>\n<p>E) But this doesn't work:</p>\n<pre><code>int main() {\n    int * a = new decltype(*a)[5];\n    delete[] a;\n    return 0;\n}\n</code></pre>\n<p>with error: new cannot be applied to a reference type</p>\n<p>So be it a GCC extension or a standard C++11 feature, both don't appear to be working as per my expectations in all cases.</p>\n", "Title": "Compiler error while defining array using typeof and decltype", "CreationDate": "2015-11-13T11:11:28.780", "LastActivityDate": "2015-11-15T00:15:29.657", "CommentCount": "4", "LastEditDate": "2015-11-13T14:24:50.863", "PostTypeId": "1", "LastEditorUserId": "1851678", "Id": "33691417", "Score": "4", "OwnerUserId": "1851678", "Tags": "<c++><typeof><decltype>", "AnswerCount": "2"}});