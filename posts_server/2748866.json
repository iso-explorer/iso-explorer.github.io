post_cb({"2748964": {"Id": "2748964", "PostTypeId": "2", "Body": "<p>I don't know if that has changed in the latest versions of the standard, but it used to say something like \"if in doubt, don't use the rvalue reference\". Probably for compatibility reasons. </p>\n<p>If you want the move semantics, use <code>f(std::move(arg))</code>, that works with both compilers.</p>\n", "LastActivityDate": "2010-05-01T05:06:11.753", "CommentCount": "0", "CreationDate": "2010-05-01T05:06:11.753", "ParentId": "2748866", "Score": "0", "OwnerUserId": "328543"}, "2749602": {"Id": "2749602", "PostTypeId": "2", "Body": "<p>GCC is doing it wrong according the FCD. The FCD says at <code>8.5.3</code> about reference binding</p>\n<ul>\n<li>If the reference is an lvalue reference and the initializer expression is an [lvalue / class type] ...</li>\n<li>Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be const), or the reference shall be an rvalue reference and the initializer expression shall be an rvalue or have a function type.</li>\n</ul>\n<p>Your case for the call to the <code>std::string &amp;&amp;</code> matches none of them, because the initializer is an <em>lvalue</em>. It doesn't get to the place to create a temporary rvalue, because that toplevel bullet already requires an rvalue. </p>\n<p>Now, overload resolution doesn't directly use reference binding to see whether there exist an implicit conversion sequence. Instead, it says at <code>13.3.3.1.4/2</code></p>\n<blockquote>\n<p id=\"so_2748866_2749602_0\">When a parameter of reference type is not bound directly to an argument expression, the conversion sequence is the one required to convert the argument expression to the underlying type of the reference according to 13.3.3.1.</p>\n</blockquote>\n<p>Thus, overload resolution figures out a winner, even though that winner may actually not be able to bind to that argument. For example:</p>\n<pre><code>struct B { B(int) { /* ... */ } };\nstruct A { int bits: 1; };\n\nvoid f(int&amp;);\nvoid f(B);\nint main() { A a; f(a.bits); }\n</code></pre>\n<p>Reference binding at <code>8.5</code> forbids bitfields to bind to lvalue references. But overload resolution says that the conversion sequence is the one converting to <code>int</code>, thus succeeding even though when the call is made later, the call is ill-formed. Thus my bitfields example is ill-formed. If it was to choose the <code>B</code> version, it would have succeeded, but needed a user defined conversion. </p>\n<p><strong>However</strong>, there exist two exceptions for that rule. These are</p>\n<blockquote>\n<p id=\"so_2748866_2749602_1\">Except for an implicit object parameter, for which see 13.3.1, a standard conversion sequence cannot be formed if it requires binding an lvalue reference to non-const to an rvalue or binding an rvalue reference to an lvalue.</p>\n</blockquote>\n<p>Thus, the following call is valid:</p>\n<pre><code>struct B { B(int) { /* ... */ } };\nstruct A { int bits: 1; };\n\nvoid f(int&amp;); /* binding an lvalue ref to non-const to rvalue! */\nvoid f(B);\nint main() { A a; f(1); }\n</code></pre>\n<p>And thus, your example calls the <code>const T&amp;</code> version</p>\n<pre><code>void f(const std::string &amp;);\nvoid f(std::string &amp;&amp;); // would bind to lvalue!\n\nvoid g(const char * arg) { f(arg); }\n</code></pre>\n<p>However, if you say <code>f(arg + 0)</code>, you create an rvalue, and thus the second function is viable. </p>\n", "LastActivityDate": "2010-05-01T10:38:45.630", "CommentCount": "7", "CreationDate": "2010-05-01T10:38:45.630", "ParentId": "2748866", "Score": "8", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_2748866_2749602_1": {"length": 18, "quality": 0.9, "section_id": 627}, "so_2748866_7230515_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 3321}, "so_2748866_2748896_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 611}, "so_2748866_2749602_0": {"length": 19, "quality": 0.95, "section_id": 626}}, "n3337": {"so_2748866_2749602_1": {"length": 18, "quality": 0.9, "section_id": 617}, "so_2748866_7230515_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 3191}, "so_2748866_2748896_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 601}, "so_2748866_2749602_0": {"length": 19, "quality": 0.95, "section_id": 616}}, "n4659": {"so_2748866_2749602_1": {"length": 18, "quality": 0.9, "section_id": 653}, "so_2748866_7230515_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 4087}, "so_2748866_2748896_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 637}, "so_2748866_2749602_0": {"length": 17, "quality": 0.85, "section_id": 652}}}, "2748866": {"ViewCount": "2850", "Body": "<p>(I asked a variation of this question on comp.std.c++ but didn't get an answer.)</p>\n<p>Why does the call to <code>f(arg)</code> in this code call the const ref overload of <code>f</code>?</p>\n<pre><code>void f(const std::string &amp;); //less efficient\nvoid f(std::string &amp;&amp;); //more efficient\n\nvoid g(const char * arg)\n{\n     f(arg);\n}\n</code></pre>\n<p>My intuition says that the <code>f(string &amp;&amp;)</code> overload should be chosen, because <code>arg</code> needs to be converted to a temporary no matter what, and the temporary matches the rvalue reference better than the lvalue reference.</p>\n<p>This is not what happens in <strike>GCC and</strike> MSVC (edit: Thanks Sumant: it doesn't happen in GCC 4.3-4.5). In at least <strike>G++ and</strike> MSVC, any lvalue does not bind to an rvalue reference argument, <em>even if</em> there is an intermediate temporary created. Indeed, if the const ref overload isn't present, the compilers diagnose an error. However, writing <code>f(arg + 0)</code>  or <code>f(std::string(arg))</code> <em>does</em> choose the rvalue reference overload as you would expect.</p>\n<p>From my reading of the C++0x standard, it seems like the implicit conversion of a const char * to a string should be considered when considering if <code>f(string &amp;&amp;)</code> is viable, just as when passing a const lvalue ref arguments. Section 13.3 (overload resolution) doesn't differentiate between rvalue refs and const references in too many places. Also, it seems that the rule that prevents lvalues from binding to rvalue references (13.3.3.1.4/3) shouldn't apply if there's an intermediate temporary - after all, it's perfectly safe to move from the temporary.</p>\n<p>Is this:</p>\n<ol>\n<li>Me misreading/misunderstand the standard, where the implemented behavior is the intended behavior, and there's some good reason why my example should behave the way it does?</li>\n<li>A mistake that the compiler vendors have somehow all made? Or a mistake based on common implementation strategies? Or a mistake in e.g. GCC (where this lvalue/rvalue reference binding rule was first implemented), that was copied by other vendors?</li>\n<li>A defect in the standard, or an unintended consequence, or something that should be clarified?</li>\n</ol>\n<p>EDIT: I have a follow-on question that is related: <a href=\"https://stackoverflow.com/questions/2749263/c0x-rvalue-references-lvalues-rvalue-binding\">C++0x rvalue references - lvalues-rvalue binding</a></p>\n", "AcceptedAnswerId": "2749602", "Title": "C++0x rvalue references and temporaries", "CreationDate": "2010-05-01T04:20:31.313", "Id": "2748866", "CommentCount": "2", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:48:25.527", "LastEditorUserId": "-1", "LastActivityDate": "2011-10-02T10:27:34.590", "Score": "13", "OwnerUserId": "51305", "Tags": "<c++><c++11><temporary><rvalue-reference>", "AnswerCount": "6"}, "2748896": {"Id": "2748896", "PostTypeId": "2", "Body": "<p>A lot of things in the current draft of the standard need clarification, if you ask me. And the compilers are still developing, so it's hard to trust their help.</p>\n<p>It looks pretty clear that your intuition is right\u2026 temporaries of any kind are supposed to bind to rvalue references. For example, \u00a73.10, the new \"taxonomy\" section, categorically defines temporaries as rvalues.</p>\n<p>The problem may be that the RR argument specification is insufficient to invoke the creation of a temporary. \u00a75.2.2/5: \"Where a parameter is of const reference type a temporary object is introduced if needed.\" That sounds suspiciously exclusive.</p>\n<p>Seems to slip through the cracks again at \u00a713.3.3.1/6: (emphasis mine)</p>\n<blockquote>\n<p id=\"so_2748866_2748896_0\"><strong>When the parameter type is not a reference,</strong> the implicit conversion sequence models a copy-initialization of the parameter from the argument expression. The implicit conversion sequence is the one required to convert the argument expression to a prvalue of the type of the parameter.</p>\n</blockquote>\n<p>Note that copy-initialization <code>string &amp;&amp;rr = \"hello\";</code> works fine in GCC.</p>\n<p><strong>EDIT:</strong> Actually the problem doesn't exist on my version of GCC. I'm still trying to figure out how the second standard conversion of the user-defined conversion sequence relates to forming an rvalue reference. (Is RR formation a conversion at all? Or is it dictated by scattered tidbits like 5.2.2/5?)</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-05-01T05:19:13.583", "Score": "1", "CreationDate": "2010-05-01T04:32:36.523", "ParentId": "2748866", "CommentCount": "1", "OwnerUserId": "153285", "LastEditDate": "2010-05-01T05:19:13.583"}, "2748945": {"Id": "2748945", "PostTypeId": "2", "Body": "<p>I did not see the behavior mentioned by Doug on g++. g++ 4.5 and 4.4.3 both call <code>f(string &amp;&amp;)</code> as expected but VS2010 calls <code>f(const string &amp;)</code>. Which g++ version are you using?</p>\n", "LastActivityDate": "2010-05-01T04:57:07.460", "CommentCount": "2", "CreationDate": "2010-05-01T04:57:07.460", "ParentId": "2748866", "Score": "2", "OwnerUserId": "25014"}, "2748935": {"Id": "2748935", "PostTypeId": "2", "Body": "<p>Take a look at this:</p>\n<p><a href=\"http://blogs.msdn.com/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx\" rel=\"nofollow noreferrer\">http://blogs.msdn.com/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx</a></p>\n<p>rvalue references: overload resolution</p>\n<p>It looks like your case is: \"Lvalues strongly prefer binding to lvalue references\". </p>\n", "LastActivityDate": "2010-05-01T04:53:22.627", "CommentCount": "1", "CreationDate": "2010-05-01T04:53:22.627", "ParentId": "2748866", "Score": "0", "OwnerUserId": "279313"}, "7230515": {"Id": "7230515", "PostTypeId": "2", "Body": "<p>It was a defect in the standard draft you read. This defect got in as a side effect of some eager editing to disallow binding of rvalue references to lvalues for safety reasons.</p>\n<p>Your intuition is right. Of course, there is no harm in allowing an rvalue reference to refer to some unnamed temporary even if the initializer was an lvalue expression. After all, this is what rvalue references are for. The issue you observed has been fixed last year. The upcoming standard will mandate that the second overload will be picked in your example where the rvalue reference will refer to some temporary string object.</p>\n<p>The rule fix made it into the draft n3225.pdf (2010-11-27):</p>\n<blockquote id=\"so_2748866_7230515_0\">\n<ul>\n<li>[...]</li>\n<li>Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be const), or the reference shall be an rvalue reference <strike>and the initializer expression shall be an rvalue or have a function type</strike>. [...]\n  \n  <ul>\n<li>[...]</li>\n<li>Otherwise, a temporary of [...] is created [...]</li>\n</ul></li>\n</ul>\n</blockquote>\n<pre><code>        double&amp;&amp; rrd3 = i; // rrd3 refers to temporary with value 2.0\n</code></pre>\n<p>But N3225 seems to have missed to say what <code>i</code> is in this example. The latest draft N3290 contains these examples:</p>\n<pre><code>        double d2 = 1.0;\n        double&amp;&amp; rrd2 = d2; // error: copying lvalue of related type\n        int i3 = 2;\n        double&amp;&amp; rrd3 = i3; // rrd3 refers to temporary with value 2.0\n</code></pre>\n<p>Since your MSVC version was released before this issue got fixed, it still handles rvalue references according to the old rules. The next MSVC version is expected to implement the new rvalue reference rules (dubbed \"rvalue references 2.1\" by MSVC developers) <a href=\"http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-9-of-n\" rel=\"noreferrer\">see link</a>.</p>\n", "LastEditorUserId": "172531", "LastActivityDate": "2011-08-29T13:38:49.587", "Score": "6", "CreationDate": "2011-08-29T13:08:45.360", "ParentId": "2748866", "CommentCount": "0", "OwnerUserId": "172531", "LastEditDate": "2011-08-29T13:38:49.587"}});