post_cb({"bq_ids": {"n4140": {"so_2613387_2613393_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 6046}, "so_2613387_2613393_0": {"length": 15, "quality": 1.0, "section_id": 6039}}, "n3337": {"so_2613387_2613393_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 5814}, "so_2613387_2613393_0": {"length": 15, "quality": 1.0, "section_id": 5807}}, "n4659": {"so_2613387_2613393_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 7545}, "so_2613387_2613393_0": {"length": 9, "quality": 0.6, "section_id": 7543}}}, "2613387": {"ViewCount": "4121", "Body": "<p>I've been reading StackOverflow too much and started doubting all the code I've ever written, I keep thinking \"Is that undefined behavour?\" even in code that has been working for ages.</p>\n<p>So my question - Is it safe and well defined behavour to cast a pointer to an object (In this case abstract interface classes) to a void* and then later on cast them back to the original class and call method using them?</p>\n<p>I'm fully aware that the code that does this is probably awful. I wouldn't even consider writing it like this now (this is old code which I don't really want to change), so I'm not looking for a discussion of better ways to do this. I already know how to write it better if I ever did this again. But if it's actually broken to rely on this in C++ then I'll have to look at changing the code, if it's merely awful code then changing it won't be a priority.</p>\n<p>I would have had no doubts about something this simple a year or two ago but as my understanding of C++ increases I actually find I have more and more worries about code being safe under the standards even if it works perfectly well. Perhaps reading too much stack overflow is a bad thing for productivity sometimes :P</p>\n", "AcceptedAnswerId": "2613393", "Title": "Casting pointer to object to void * in C++", "CreationDate": "2010-04-10T12:40:25.837", "Id": "2613387", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-04-10T12:44:14.863", "LastEditorUserId": "1977903", "LastActivityDate": "2012-09-19T03:02:32.637", "Score": "12", "OwnerUserId": "417292", "Tags": "<c++><pointers><casting>", "AnswerCount": "3"}, "2613389": {"Id": "2613389", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2613387_2613389_0\">So my question - Is it safe and well defined behavour to cast a pointer to an object (In this case abstract interface classes) to a void* and then later on cast them back to the original class and call method using them?</p>\n</blockquote>\n<p>Yes \u2013 as long as you cast back to the <em>exact same</em> type. Otherwise, base class pointer adjustments may destroy the value of the pointer.</p>\n<p>In practice, this is (probably) only relevant when using multiple inheritance: pointers to a derived class may differ in their physical address from pointers to their base class.</p>\n", "LastActivityDate": "2010-04-10T12:42:35.650", "CommentCount": "0", "CreationDate": "2010-04-10T12:42:35.650", "ParentId": "2613387", "Score": "7", "OwnerUserId": "1968"}, "12486455": {"Id": "12486455", "PostTypeId": "2", "Body": "<p>We use this technique commonly to avoid having switch statements in every single class based on the environment you are using (web-based, Windows, Linux etc)</p>\n<p>Use <code>void **</code> for references. </p>\n<pre><code>void ** detailObject;\n</code></pre>\n<p>Create a function to return the referenced object:</p>\n<pre><code>TheObject *TheClass::GetObject(){\n    TheObject *object   =   (TheObject*)object;\n    return object;\n}\n</code></pre>\n<p>Just use the function as the object from now on.  e.g.  <code>GetObject()-&gt;Go()</code>;</p>\n", "LastEditorUserId": "1063041", "LastActivityDate": "2012-09-19T03:02:32.637", "Score": "1", "CreationDate": "2012-09-18T23:19:34.033", "ParentId": "2613387", "CommentCount": "0", "OwnerUserId": "1681688", "LastEditDate": "2012-09-19T03:02:32.637"}, "2613393": {"Id": "2613393", "PostTypeId": "2", "Body": "<p>You are safe.</p>\n<p>From C++(0x) draft,</p>\n<p>\u00a75.2.9/13 (for <code>static_cast</code>):</p>\n<blockquote>\n<p id=\"so_2613387_2613393_0\">A value of type pointer to object converted to \u201cpointer to <em>cv</em> <code>void</code>\u201d and back, possibly with different cv-qualification, shall have its original value.</p>\n</blockquote>\n<p>\u00a75.2.10/7 (for <code>reinterpret_cast</code>):</p>\n<blockquote>\n<p id=\"so_2613387_2613393_1\">Converting an rvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value.</p>\n</blockquote>\n<p>(Of course, casting to an unrelated class is undefined behavior.)</p>\n", "LastEditorUserId": "224671", "LastActivityDate": "2010-04-10T12:49:32.437", "Score": "15", "CreationDate": "2010-04-10T12:43:37.553", "ParentId": "2613387", "CommentCount": "2", "OwnerUserId": "224671", "LastEditDate": "2010-04-10T12:49:32.437"}});