post_cb({"8336380": {"ParentId": "8336274", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>It cannot be done because you cannot take a pointer to a reference- period. </p>\n<p>If you could take a member pointer to a reference, this would be inconsistent with the behaviour of references on the stack. The attitude of C++ is that references do not exist. As such, you cannot form a pointer to them- ever.</p>\n<p>For example, <code>&amp;f::a</code> would have to be different to <code>&amp;f::b</code>. And by de-referencing <code>&amp;f::b</code>, you would effectively be achieving a pointer to a reference, which is not allowed.</p>\n", "OwnerUserId": "298661", "LastEditorUserId": "298661", "LastEditDate": "2011-12-01T04:16:32.043", "Id": "8336380", "Score": "11", "CreationDate": "2011-12-01T04:02:28.020", "LastActivityDate": "2011-12-01T04:16:32.043"}, "8336274": {"CommentCount": "6", "AcceptedAnswerId": "8336479", "PostTypeId": "1", "LastEditorUserId": "184741", "CreationDate": "2011-12-01T03:41:03.793", "LastActivityDate": "2011-12-01T07:21:17.680", "LastEditDate": "2011-12-01T07:21:17.680", "ViewCount": "3132", "FavoriteCount": "2", "Title": "Pointer to member that is a reference illegal?", "Id": "8336274", "Score": "19", "Body": "<p>Let us say I have:</p>\n<pre><code>// This is all valid in C++11.\nstruct Foo {\n    int i = 42;\n    int&amp; j = i;\n};\n\n// Let's take a pointer to the member \"j\".\nauto b = &amp;Foo::j; // Compiler is not happy here\n// Note that if I tried to get a pointer to member \"i\", it would work, as expected.\nFoo f;\nstd::cout &lt;&lt; f.*b; // Try using the pointer to member\n</code></pre>\n<p>The compiler complains that I cannot take the address of the member because it is a reference. To be precise:</p>\n<blockquote>\n<p id=\"so_8336274_8336274_0\">Semantic Issue: Cannot form a pointer-to-member to member 'j' of reference type 'int &amp;'</p>\n</blockquote>\n<p>I know doing this seems pointless, but I am only wondering why it cannot be done.</p>\n<p>Why is this impossible?</p>\n", "Tags": "<c++><language-lawyer><pointer-to-member>", "OwnerUserId": "1074536", "AnswerCount": "4"}, "8336479": {"ParentId": "8336274", "CommentCount": "4", "Body": "<p>Member pointer (as opposed to a simple pointer to a member) is simply an offset into the structure, not a pointer at all. You can get data through it only in conjunction with the structure itself (or a pointer to a structure): the value of the offset is added to the address of the structure, and the result is dereferenced to produce the value of the member.</p>\n<p>Now suppose a member is a reference, so accessing data through it already requires a dereference (compiler hides it from us, but it needs to spit out the corresponding instructions in its output). If C++ were to allow member pointers to references, they'd be of yet another type: an offset that needs to be added to the base, and then dereferenced twice. It is too much work to improve an already obscure feature; prohibiting it is a much better way out.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "8336479", "Score": "6", "CreationDate": "2011-12-01T04:18:16.880", "LastActivityDate": "2011-12-01T04:18:16.880"}, "8336774": {"ParentId": "8336274", "CommentCount": "0", "Body": "<p>Allowing you to make a pointer to a reference does not give you any expressive power. There's nothing you can do with such a beast that you can't easily do with a reference or with a pointer. All you get out of it is added complexity.</p>\n<p>And making a pointer to a member that is a reference is not allowed for consistency with the rule that forbids pointers to references, and because it adds even more complexity. The designers of the language probably decided that the little gains you get from these was not worth it.</p>\n<p>This is totally just my opinion.</p>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "8336774", "Score": "0", "CreationDate": "2011-12-01T05:05:13.863", "LastActivityDate": "2011-12-01T05:05:13.863"}, "8336392": {"ParentId": "8336274", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>C++11 standard:</p>\n<blockquote>\n<p id=\"so_8336274_8336392_0\">\u00a78.3.3 p3 [dcl.mptr]<br>\n  A pointer to member shall not point to a static member of a class (9.4), <strong>a member with reference type</strong>, or \u201ccv void.\u201d</br></p>\n</blockquote>\n<p>Also, in general:</p>\n<blockquote>\n<p id=\"so_8336274_8336392_1\">\u00a78.3.1 p4 [dcl.ptr]<br>\n  [ Note: There are no pointers to references; see 8.3.2. [...] \u2014end note ]</br></p>\n<p id=\"so_8336274_8336392_2\">\u00a78.3.2 p5 [dcl.ref]<br>\n  There shall be no references to references, no arrays of references, and <strong>no pointers to references</strong>.</br></p>\n</blockquote>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-12-01T04:22:45.787", "Id": "8336392", "Score": "12", "CreationDate": "2011-12-01T04:04:05.993", "LastActivityDate": "2011-12-01T04:22:45.787"}, "bq_ids": {"n4140": {"so_8336274_8336274_0": {"section_id": 391, "quality": 0.5555555555555556, "length": 5}, "so_8336274_8336392_0": {"section_id": 3227, "quality": 0.8333333333333334, "length": 10}, "so_8336274_8336392_2": {"section_id": 3222, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_8336274_8336274_0": {"section_id": 382, "quality": 0.5555555555555556, "length": 5}, "so_8336274_8336392_0": {"section_id": 3100, "quality": 0.8333333333333334, "length": 10}, "so_8336274_8336392_2": {"section_id": 3096, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_8336274_8336392_2": {"section_id": 3979, "quality": 0.7777777777777778, "length": 7}, "so_8336274_8336392_0": {"section_id": 3984, "quality": 0.75, "length": 9}}}});