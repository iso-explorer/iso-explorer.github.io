post_cb({"39005774": {"ParentId": "39005700", "CommentCount": "2", "CreationDate": "2016-08-17T20:32:08.980", "OwnerUserId": "771073", "PostTypeId": "2", "Id": "39005774", "Score": "3", "Body": "<blockquote>\n<p id=\"so_39005700_39005774_0\">When the standard writes,</p>\n<p id=\"so_39005700_39005774_1\">\"If <code>X</code>, foo-initialization is performed. Otherwise, if <code>Y</code>,\n  bar-initialization is performed, ...</p>\n<p id=\"so_39005700_39005774_2\">doesn't this mean that if <code>X</code> holds, but foo-initialization cannot be\n  performed, then we should check if <code>Y</code> holds, and then attempt\n  bar-initialization?</p>\n</blockquote>\n<p>No.  If <code>X</code> holds we perform foo-initialization.  If that fails the program is ill-formed.</p>\n", "LastActivityDate": "2016-08-17T20:32:08.980"}, "39005787": {"ParentId": "39005700", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-08-17T20:33:18.003", "Score": "4", "LastEditorUserId": "734069", "LastEditDate": "2016-08-17T20:39:23.300", "Id": "39005787", "OwnerUserId": "734069", "Body": "<blockquote>\n<p id=\"so_39005700_39005787_0\">When the standard writes,</p>\n<p id=\"so_39005700_39005787_1\">\"If X, foo-initialization is performed. Otherwise, if Y, bar-initialization is performed, .... Otherwise, the program is ill-formed.\", </p>\n<p id=\"so_39005700_39005787_2\">doesn't this mean that if X holds, but foo-initialization cannot be performed, then we should check if Y holds, and then attempt bar-initialization?</p>\n</blockquote>\n<p>No, it does not. Think of it like actual code:</p>\n<pre><code>T *p = ...;\nif(p)\n{\n  p-&gt;Something();\n}\nelse\n{ ... }\n</code></pre>\n<p><code>p</code> isn't NULL. That doesn't mean it's a valid pointer either. If <code>p</code> points to a destroyed object, <code>p-&gt;Something()</code> failing will not cause you to skip to the <code>else</code>. You had your chance to protect the call in the condition.</p>\n<p>So you get undefined behavior.</p>\n<p>The same goes here. If X, do A. That doesn't imply what happens if A fails; it tell you to do it. If it can't be done... you're screwed.</p>\n", "LastActivityDate": "2016-08-17T20:39:23.300"}, "39005700": {"CommentCount": "0", "AcceptedAnswerId": "39005774", "CreationDate": "2016-08-17T20:27:15.517", "LastActivityDate": "2016-08-17T20:39:23.300", "PostTypeId": "1", "ViewCount": "101", "FavoriteCount": "2", "Title": "list initialization of aggregates: when can it invoke copy constructor?", "Id": "39005700", "Score": "6", "Body": "<p>Consider the following code:</p>\n<pre><code>struct A {\n  int x;\n};\n\nint main() {\n  A a;\n  A b{a};\n}\n</code></pre>\n<p>Is this program well-formed at C++11 standard? In my copy of N3797 it says</p>\n<blockquote>\n<p id=\"so_39005700_39005700_0\">8.5.4 List initialization <code>[dcl.init.list]</code> </p>\n<p id=\"so_39005700_39005700_1\">3: List-initialization of an object or reference of type <code>T</code> is defined as follows:<br>\n     - If <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).<br>\n     - Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code>, ...<br>\n     - Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen using overload resolution. If a narrowing conversion is required to convert any of the types, the program is ill-formed.<br>\n     - Otherwise, if the initializer list has a single element of type <code>E</code> and either <code>T</code> is not a reference type or it is reference-related to <code>E</code>, the object or reference is initialized from that element; if a narrowing conversion is required to convert the element to <code>T</code>, the program is ill-formed.<br>\n     - Otherwise, if <code>T</code> is a reference type, a pr-value temporary of the type reference by <code>T</code> is copy-list-initialized or direct-list-initialized, depending on the kind of initialization for the reference, and the reference is bound to that temporary.<br>\n     - Otherwise, if the initializer list has no elements, the object is value-initialized.<br>\n     - Otherwise, the program is ill-formed.  </br></br></br></br></br></br></br></p>\n</blockquote>\n<p>The point of the example is, the type is an aggregate, but list-initialization is supposed to invoke the copy constructor. On <code>gcc 4.8</code> and <code>gcc 4.9</code>, at C++11 standard, it fails:</p>\n<pre><code>main.cpp: In function \u2018int main()\u2019:\nmain.cpp:7:8: error: cannot convert \u2018A\u2019 to \u2018int\u2019 in initialization\n   A b{a};\n        ^\n</code></pre>\n<p>and says <code>A is not convertible to int</code> or similar, because aggregate initialization fails. On <code>gcc 5.4</code>, it works fine at C++11 standard.</p>\n<p>On <code>clang</code> you get similar errors with <code>clang-3.5</code>, <code>3.6</code>, and it starts working at <code>clang-3.7</code>.</p>\n<p>I understand that it is well-formed at C++14 standard, and that it was mentioned in a defect report <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1467\">here</a>.</p>\n<p>However, what I don't understand is why this was considered a defect in the standard.</p>\n<p>When the standard writes,  </p>\n<p>\"If <code>X</code>, foo-initialization is performed. Otherwise, if <code>Y</code>, bar-initialization is performed, .... Otherwise, the program is ill-formed.\",  </p>\n<p>doesn't this mean that if <code>X</code> holds, but foo-initialization cannot be performed, then we should check if <code>Y</code> holds, and then attempt bar-initialization?  </p>\n<p>This would make the example work, because when aggregate initialization fails, we don't match <code>std::initializer_list</code>, and the next condition we match is \"<code>T</code> is a class type\", and then we consider constructors.</p>\n<p>Note that this <em>does</em> seem to be how it works in this modified example</p>\n<pre><code>struct A {\n  int x;\n};\n\nint main() {\n  A a;\n  const A &amp; ref;\n  A b{ref};\n}\n</code></pre>\n<p>All the same compilers treat this the same way as the earlier example, at C++11 and C++14 standards. But it seems that the modified wording from the CWG defect record doesn't apply to this case. It reads:</p>\n<blockquote>\n<p id=\"so_39005700_39005700_2\">If <code>T</code> is a class type and the initializer list has a single element of type <code>cv T</code> or a class type derived from <code>T</code>, the object is initialized from that element.</p>\n</blockquote>\n<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1467\">http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1467</a></p>\n<p>But in the second code example, the initializer list technically contains <code>const T &amp;</code>. So I don't see how it would work unless after aggregate initialization fails, we are supposed to attempt constructors.</p>\n<p>Am I wrong? Is it not supposed to attempt constructors after aggregate initialization fails?</p>\n<p>Here's a related example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B {\n  int x;\n\n  operator int() const { return 2; }\n};\n\nint main() {\n  B b{1};\n  B c{b};\n  std::cout &lt;&lt; c.x &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In <code>clang-3.6</code>, <code>gcc-4.8</code>, <code>gcc-4.9</code>, it prints <code>2</code>, and in <code>clang-3.7</code>, <code>gcc-5.0</code> it prints <code>1</code>.</p>\n<p>Assuming I'm wrong, and at C++11 standard, list initialization of an aggregate is supposed to be aggregate initialization and nothing else, until the new wording in the defect report is introduced, is it a bug that this happens even when I select <code>-std=c++11</code> on the newer compilers?</p>\n", "Tags": "<c++><c++11><aggregate><language-lawyer><list-initialization>", "OwnerUserId": "3598119", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_39005700_39005787_1": {"section_id": 3325, "quality": 0.5714285714285714, "length": 4}, "so_39005700_39005700_2": {"section_id": 3325, "quality": 0.8461538461538461, "length": 11}, "so_39005700_39005700_1": {"section_id": 3325, "quality": 0.9358974358974359, "length": 73}}, "n3337": {"so_39005700_39005787_1": {"section_id": 3195, "quality": 0.5714285714285714, "length": 4}, "so_39005700_39005700_2": {"section_id": 3166, "quality": 0.6153846153846154, "length": 8}, "so_39005700_39005700_1": {"section_id": 3195, "quality": 0.6666666666666666, "length": 52}}, "n4659": {"so_39005700_39005787_1": {"section_id": 4091, "quality": 0.7142857142857143, "length": 5}, "so_39005700_39005700_2": {"section_id": 4091, "quality": 0.8461538461538461, "length": 11}, "so_39005700_39005700_1": {"section_id": 4091, "quality": 0.8717948717948718, "length": 68}}}});