post_cb({"bq_ids": {"n4140": {"so_15080015_15080378_5": {"length": 15, "quality": 1.0, "section_id": 4560}, "so_15080015_15080378_6": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_15080015_15080378_0": {"length": 8, "quality": 1.0, "section_id": 2707}, "so_15080015_15080378_7": {"length": 4, "quality": 1.0, "section_id": 4560}, "so_15080015_15080378_4": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_15080015_15080378_3": {"length": 15, "quality": 1.0, "section_id": 4560}, "so_15080015_15080378_1": {"length": 18, "quality": 0.6666666666666666, "section_id": 2710}}, "n3337": {"so_15080015_15080378_5": {"length": 15, "quality": 1.0, "section_id": 4390}, "so_15080015_15080378_0": {"length": 8, "quality": 1.0, "section_id": 2669}, "so_15080015_15080378_6": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_15080015_15080378_7": {"length": 4, "quality": 1.0, "section_id": 4390}, "so_15080015_15080378_4": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_15080015_15080378_3": {"length": 15, "quality": 1.0, "section_id": 4390}, "so_15080015_15080378_1": {"length": 18, "quality": 0.6666666666666666, "section_id": 2671}}, "n4659": {"so_15080015_15080378_5": {"length": 9, "quality": 0.6, "section_id": 7709}, "so_15080015_15080378_6": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_15080015_15080378_0": {"length": 8, "quality": 1.0, "section_id": 3447}, "so_15080015_15080378_7": {"length": 4, "quality": 1.0, "section_id": 5932}, "so_15080015_15080378_4": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_15080015_15080378_3": {"length": 9, "quality": 0.6, "section_id": 7709}, "so_15080015_15080378_1": {"length": 18, "quality": 0.6666666666666666, "section_id": 3450}}}, "15080378": {"Id": "15080378", "PostTypeId": "2", "Body": "<p>This is because of the generic binding facility in terms of which the C++11 Standard defines not only how a thread is started, but also how <code>std::bind</code> and <code>std::function</code> work.</p>\n<p>In fact, Paragraph 30.3.1.2/3 of the C++11 Standard specifies about the variadic constructor of class <code>std::thread</code>:</p>\n<blockquote>\n<p id=\"so_15080015_15080378_0\"><code>template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);</code></p>\n<p id=\"so_15080015_15080378_1\"><em>Effects</em>: Constructs an object of type thread. The new thread of execution executes <strong><code>INVOKE (DECAY_-\n  COPY ( std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code></strong> with the calls to\n  <code>DECAY_COPY</code> being evaluated in the constructing thread. Any return value from this invocation is\n  ignored. [...]</p>\n</blockquote>\n<p>Ignoring what <code>DECAY_COPY</code> does (it is not relevant to the question), this is how Paragraph 20.8.2 defines the <code>INVOKE</code> pseudo-function:</p>\n<blockquote>\n<p id=\"so_15080015_15080378_2\">Define <strong>INVOKE (f, t1, t2, ..., tN)</strong> as follows:</p>\n<p id=\"so_15080015_15080378_3\">\u2014 (t1.*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is an object of\n  type T or a reference to an object of type T or a reference to an object of a type derived from T;</p>\n<p id=\"so_15080015_15080378_4\">\u2014 ((*t1).*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is not one of\n  the types described in the previous item;</p>\n<p id=\"so_15080015_15080378_5\">\u2014 t1.*f when N == 1 and f is a pointer to member data of a class T and t1 is an object of type T or a\n  reference to an object of type T or a reference to an object of a type derived from T;</p>\n<p id=\"so_15080015_15080378_6\">\u2014 <strong>(*t1).*f when N == 1 and f is a pointer to member data of a class T and t1 is not one of the types\n  described in the previous item;</strong></p>\n<p id=\"so_15080015_15080378_7\">\u2014 f(t1, t2, ..., tN) in all other cases.</p>\n</blockquote>\n<p>Now the question becomes: </p>\n<blockquote>\n<p id=\"so_15080015_15080378_8\">Why does the C++11 Standard defines the <code>INVOKE</code> facility that way?</p>\n</blockquote>\n<p>And the answer is <strong><a href=\"https://stackoverflow.com/questions/12638393/why-does-invoke-facility-in-the-c11-standard-refer-to-data-members\">here</a></strong>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-26T02:37:06.007", "Score": "3", "CreationDate": "2013-02-26T02:37:06.007", "ParentId": "15080015", "CommentCount": "5", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:16:12.163"}, "15080015": {"ViewCount": "684", "Body": "<p>I was reading through the <a href=\"http://en.cppreference.com/w/cpp/thread/thread/thread\">std::thread documentation at cppreference</a> (not always 100% accurate, I know) and noticed the following definition for the behavior of <code>std::thread</code> when passed a \"pointer-to-data-member\" (not \"pointer-to-member-function\") as its first argument (<code>f</code>) and an object of the required class as its second argument (<code>t1</code> after copying to thread-local-storage):</p>\n<blockquote>\n<p id=\"so_15080015_15080015_0\">If N == 1 and f is pointer to a member data object of a class, then it is accessed. The value of the object is ignored. Effectively, the following code is executed:\n  t1.*f if and the type of t1 is either T, reference to T or reference to type derived from T.\n  (*t1).*f otherwise.</p>\n</blockquote>\n<p>Now, I don't plan on using <code>std::thread</code> in this way, but I am flummoxed by this definition. Apparently, the only thing that happens is that the data member is accessed and the value ignored, which doesn't seem like it could have any observable side-effects at all, meaning (as far I can tell) it might as well be a no-op. (I might be missing something obvious...?)</p>\n<p>At first, I thought this might be a misprint, and meant to say that the data member is accessed and then called (since it might be a callable object, even if it's not a function) but I tested it with the following code in GCC-4.7 and indeed there is no call:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nstruct S \n{\n    void f() {\n        std::cout &lt;&lt; \"Calling f()\" &lt;&lt; std::endl;\n    }\n\n    struct {\n        void operator()() {\n            std::cout &lt;&lt; \"Calling g()\" &lt;&lt; std::endl;\n        }\n    } g;\n};\n\nint main(int, char**)\n{\n    S s;\n    s.f(); // prints \"Calling f()\"\n    s.g(); // prints \"Calling g()\"\n\n    std::cout &lt;&lt; \"----\" &lt;&lt; std::endl;\n\n    auto x = &amp;S::f; // ptr-to-mem-func\n    auto y = &amp;S::g; // ptr-to-data-mem\n\n    (s.*x)(); // prints \"Calling f()\"\n    (s.*y)(); // prints \"Calling g()\"\n\n    std::cout &lt;&lt; \"----\" &lt;&lt; std::endl;\n\n    std::thread t(x, &amp;s);\n    t.join();\n    // \"Calling f()\" printed by now\n    std::thread u(y, &amp;s);\n    u.join();\n    // \"Calling g()\" not printed\n\n    return 0;\n}\n</code></pre>\n<p>Is there any purpose to this definition which doesn't seem to accomplish anything? Why not instead make passing a \"pointer-to-data-member-callable\" act just like a \"pointer-to-member-function\", and make passing a \"pointer-to-data-member-noncallable\" an error? In fact, it seems like this would be the easiest way to implement it, since calling a \"pointer-to-data-member-callable\" has equivalent syntax to calling as a \"pointer-to-member-function\" in other contexts (unless there's something in the vagarities of template specialization and SFINAE rules which makes it difficult to treat them equivalently...?)</p>\n<p>This is not something I need for actual code, but the fact that this definition exists leaves me suspecting that I am missing something fundamental, which worries me...can anyone enlighten me about this?</p>\n", "AcceptedAnswerId": "15080378", "Title": "std::thread with pointer to data member", "CreationDate": "2013-02-26T01:52:45.373", "Id": "15080015", "CommentCount": "1", "LastEditDate": "2013-02-26T01:54:25.420", "PostTypeId": "1", "LastEditorUserId": "1865077", "LastActivityDate": "2013-02-26T02:37:06.007", "Score": "5", "OwnerUserId": "2008149", "Tags": "<c++><c++11><std>", "AnswerCount": "1"}});