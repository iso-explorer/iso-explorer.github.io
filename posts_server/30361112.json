post_cb({"bq_ids": {"n4140": {"so_30361112_30363234_0": {"section_id": 6070, "quality": 0.92, "length": 23}, "so_30361112_30363234_1": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_30361112_30363234_0": {"section_id": 5838, "quality": 0.92, "length": 23}, "so_30361112_30363234_1": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_30361112_30363234_0": {"section_id": 7566, "quality": 0.92, "length": 23}, "so_30361112_30363234_1": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}}}, "30363234": {"ParentId": "30361112", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This compiles because the <code>+</code> is being interpreted as unary plus, which will perform the integral promotions on integral or enumeration types and the result will have the type of the promoted operand.</p>\n<p>Assuming <code>e</code> is an integral or unscoped enumeration type would end up having the integral promotions applied anyway since <code>*</code> applies the <em>usual arithmetic conversions</em> to its operands which ends up at the <em>integral promotions</em> for integral types.</p>\n<p>From the draft C++ standard <code>5.3.1</code> <em>[expr.unary.op]</em>:</p>\n<blockquote>\n<p id=\"so_30361112_30363234_0\">The operand of the unary + operator shall have arithmetic, unscoped enumeration, or pointer type and the\n  result is the value of the argument. Integral promotion is performed on integral or enumeration operands.\n  The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>The integral promotions are covered in section <code>4.5</code> <em>[conv.prom]</em> and if the variables <code>e</code> is a type other than <code>bool, char16_t, char32_t, or wchar_t</code> and have conversion rank less than <em>int</em> then it would be covered by paragraph <code>1</code>:</p>\n<blockquote>\n<p id=\"so_30361112_30363234_1\">A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion\n  rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned\n  int.</p>\n</blockquote>\n<p>For a complete set of cases we can look at <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast#Integral_promotion\" rel=\"nofollow noreferrer\">cppreference</a>.</p>\n<p>Unary plus can also be useful in some cases to resolve ambiguity, an interesting case would be from <a href=\"https://stackoverflow.com/q/17822131/1708801\">Resolving ambiguous overload on function pointer and std::function for a lambda using +</a>.</p>\n<p>Note, for those answers, referring to unary <code>-</code> and negative values, this is misleading, as this example shows:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    unsigned  x1 = 1 ;\n\n    std::cout &lt;&lt;  -x1 &lt;&lt; std::endl ;\n}\n</code></pre>\n<p>which results in:</p>\n<pre><code>4294967295\n</code></pre>\n<p>See it live <a href=\"http://melpon.org/wandbox/permlink/D1Os6rZyCEot3il7\" rel=\"nofollow noreferrer\">using gcc on wandbox</a>.</p>\n<p>It is interesting to note that unary plus was added to C99 for symmetry with unary minus, from the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow noreferrer\"> Rationale for International Standard\u2014Programming Languages\u2014C</a>:</p>\n<blockquote>\n<p id=\"so_30361112_30363234_2\">Unary plus was adopted by the C89 Committee from several implementations, for symmetry with unary minus.</p>\n</blockquote>\n<p>and I can not come up with a good case where casting would not be sufficient to achieve the same desired promotion/conversion. The lambda example I cite above, using unary plus to force a lambda expression to be converted to a function pointer:</p>\n<pre><code>foo( +[](){} ); // not ambiguous (calls the function pointer overload)\n</code></pre>\n<p>could be accomplished using a explicit cast:</p>\n<pre><code>foo( static_cast&lt;void (*)()&gt;( [](){} ) );\n</code></pre>\n<p>and it could be argued this code is better since the intention is explicit.</p>\n<p>Worth noting that <a href=\"http://www.stroustrup.com/arm.html\" rel=\"nofollow noreferrer\">Annotated C++ Reference Manual(<em>ARM</em>)</a> it has the following commentary:</p>\n<blockquote>\n<p id=\"so_30361112_30363234_3\">Unary plus is a historical accident and generally useless.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:57.273", "Id": "30363234", "Score": "18", "CreationDate": "2015-05-21T01:50:15.703", "LastActivityDate": "2015-10-12T17:49:38.707"}, "30361124": {"ParentId": "30361112", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The <code>+</code> is interpreted as an unary plus operator. It simply returns the <a href=\"https://stackoverflow.com/questions/24805580/does-unary-operator-do-type-conversions/24805967#24805967\">promoted</a> value of its operand.</p>\n", "OwnerUserId": "481267", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:49.270", "Id": "30361124", "Score": "115", "CreationDate": "2015-05-20T21:59:39.440", "LastActivityDate": "2016-09-07T04:24:20.430"}, "30370851": {"ParentId": "30361112", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is just basic math. For example:</p>\n<pre><code>5 * -4 = -20\n\n5 * +4 = 5 * 4 = 20 \n\n-5 * -4 = 20\n</code></pre>\n<p><strong>Negative * Negative = Positive</strong></p>\n<p><strong>Positive * Negative = Negative</strong></p>\n<p><strong>Positive * Positive = Positive</strong></p>\n<p>This is the easiest explanation there is.</p>\n<p>The minus(-) and plus(+) just tell if the number is positive or negative.</p>\n", "OwnerUserId": "2459641", "LastEditorUserId": "2459641", "LastEditDate": "2015-05-21T13:22:08.360", "Id": "30370851", "Score": "3", "CreationDate": "2015-05-21T10:16:38.147", "LastActivityDate": "2015-05-21T13:22:08.360"}, "30361112": {"CommentCount": "8", "AcceptedAnswerId": "30361124", "PostTypeId": "1", "ClosedDate": "2015-05-21T23:25:41.883", "LastEditorUserId": "1327005", "CreationDate": "2015-05-20T21:58:19.603", "LastActivityDate": "2016-09-07T04:24:20.430", "LastEditDate": "2015-05-21T05:45:01.263", "ViewCount": "6721", "FavoriteCount": "4", "Title": "What does the compiler do here: int a = b * (c * d * + e)?", "Id": "30361112", "Score": "73", "Body": "<p>I had a strange bug in my program, and after a few hours of debugging, I found the following very stupid line:</p>\n<pre><code>int a = b * (c * d *  + e)\n</code></pre>\n<p>If you don't see it: Between <code>d</code> and <code>e</code> I wrote <code>* +</code>, where just a <code>+</code>was intended.</p>\n<p>Why does this compile and what does it actually mean?</p>\n", "Tags": "<c++><arithmetic-expressions>", "OwnerUserId": "2109064", "AnswerCount": "8"}, "30361317": {"ParentId": "30361112", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>As Brian explained, it returns the promoted value.<br>\nIf it was a <code>-</code> it would return the negation:</br></p>\n<pre><code>int a = 5;\nint b = 6;\nunsigned int c = 3;\n\nstd::cout &lt;&lt; (a * +b); // = 30\nstd::cout &lt;&lt; (a * -b); // = -30\nstd::cout &lt;&lt; (1 * -c); // = 4294967293 (2^32 - 3)\n</code></pre>\n", "OwnerUserId": "3677097", "LastEditorUserId": "3677097", "LastEditDate": "2015-05-26T05:48:04.863", "Id": "30361317", "Score": "26", "CreationDate": "2015-05-20T22:16:30.997", "LastActivityDate": "2015-05-26T05:48:04.863"}, "30373870": {"ParentId": "30361112", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Why does it compile? It compiles because <code>+</code> is parsed as unary plus operator, not the addition operator. The compiler tries to parse as much as possible without generating syntax errors. So this:</p>\n<pre><code>d * + e\n</code></pre>\n<p>Is parsed as:</p>\n<ul>\n<li><code>d</code> (operand)</li>\n<li><code>*</code> (multiplication operator)</li>\n<li><code>+</code> (unary plus operator)\n<ul>\n<li><code>e</code> (operand)</li>\n</ul></li>\n</ul>\n<p>Whereas, this:</p>\n<pre><code>d*++e;\n</code></pre>\n<p>Is parsed as:</p>\n<ul>\n<li><code>d</code> (operand)</li>\n<li><code>*</code> (multiplication operator)</li>\n<li><code>++</code> (pre increment operator)\n<ul>\n<li><code>e</code> (operand)</li>\n</ul></li>\n</ul>\n<p>Moreover, this:</p>\n<pre><code>d*+++e;\n</code></pre>\n<p>Is parsed as:</p>\n<ul>\n<li><code>d</code> (operand)</li>\n<li><code>*</code> (multiplication operator)</li>\n<li><code>++</code> (pre increment operator)\n<ul>\n<li><code>+</code> (unary plus operator)\n<ul>\n<li><code>e</code> (operand)</li>\n</ul></li>\n</ul></li>\n</ul>\n<p>Note that it does not create a syntax error but the \"LValue requrired\" compiler error.</p>\n", "OwnerUserId": "87015", "LastEditorUserId": "87015", "LastEditDate": "2015-05-21T12:36:32.117", "Id": "30373870", "Score": "4", "CreationDate": "2015-05-21T12:30:59.113", "LastActivityDate": "2015-05-21T12:36:32.117"}, "30376982": {"ParentId": "30361112", "CommentCount": "0", "Body": "<p>To put a further twist on the correct answers already given here, if you compile with the -s flag, the C compiler will output an assembly file in which actual the instructions generated can be examined. With the following C code:</p>\n<pre><code>int b=1, c=2, d=3, e=4;\nint a = b * (c * d *  + e);\n</code></pre>\n<p>The generated assembly (using gcc, compiling for amd64) begins with:</p>\n<pre><code>    movl    $1, -20(%ebp)\n    movl    $2, -16(%ebp)\n    movl    $3, -12(%ebp)\n    movl    $4, -8(%ebp)\n</code></pre>\n<p>so we can identify individual memory positions -20(%ebp) as variable b, down to -8(%ebp) as variable e. -4(%epp) is variable a. Now, the calculation is rendered as:</p>\n<pre><code>    movl    -16(%ebp), %eax\n    imull   -12(%ebp), %eax\n    imull   -8(%ebp), %eax\n    imull   -20(%ebp), %eax\n    movl    %eax, -4(%ebp)\n</code></pre>\n<p>So, as has been commented by other people replying, the compiler simply treats \"+e\" as the unary positive operation. The first movl instruction places the contents of variable e into the EAX accumulator register, which is then promptly multiplied by the contents of variable d or -12(%ebp), etc. </p>\n", "OwnerUserId": "4925219", "PostTypeId": "2", "Id": "30376982", "Score": "4", "CreationDate": "2015-05-21T14:39:55.107", "LastActivityDate": "2015-05-21T14:39:55.107"}, "30363240": {"ParentId": "30361112", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As what they have explained, (+) and (-) were just used as unary operator:</p>\n<blockquote>\n<p id=\"so_30361112_30363240_0\"><a href=\"https://msdn.microsoft.com/en-us/library/hetcw0tx.aspx\" rel=\"nofollow\">Unary operators</a> act on only one operand in an expression</p>\n</blockquote>\n<pre><code>int value = 6;\nint negativeInt = -5;\nint positiveInt = +5;\n\ncout &lt;&lt; (value * negativeInt); // 6 * -5 = -30\ncout &lt;&lt; (value * positiveInt); // 6 * +5 = 30\n\ncout &lt;&lt; (value * - negativeInt); // 6 * -(-5) = 30\ncout &lt;&lt; (value * + negativeInt); // 6 * +(-5) = -30\n\ncout &lt;&lt; (value * - positiveInt); // 6 * -(+5) = -30\ncout &lt;&lt; (value * + positiveInt); // 6 * +(+5) = 30\n</code></pre>\n<p>so from your code: </p>\n<pre><code>int b = 2;\nint c = 3;\nint d = 4;\nint e = 5;\n\nint a = b * (c * d *  + e)\n\n//result: 2 * (3 * 4 * (+5) ) = 120\n</code></pre>\n", "OwnerUserId": "4273446", "LastEditorUserId": "4273446", "LastEditDate": "2015-05-21T12:54:38.557", "Id": "30363240", "Score": "9", "CreationDate": "2015-05-21T01:50:50.553", "LastActivityDate": "2015-05-21T12:54:38.557"}, "30363430": {"ParentId": "30361112", "CommentCount": "2", "Body": "<p>The + operator between d and e will be treated as an unary + operator  which will determine only sign of e.\nSo the compiler will see this statement as follow:</p>\n<pre><code>int a = b*(c*d*e) ;\n</code></pre>\n", "OwnerUserId": "4452804", "PostTypeId": "2", "Id": "30363430", "Score": "-1", "CreationDate": "2015-05-21T02:14:08.850", "LastActivityDate": "2015-05-21T02:14:08.850"}});