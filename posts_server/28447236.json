post_cb({"47223308": {"Id": "47223308", "PostTypeId": "2", "Body": "<p>I looked into this problem for std::thread before, I found the following to be working. Since CLR does not allow you to include <code>std::thead</code> at compile time, you could try to use it only at linking time. Normally you could resolve this be forward declaring the class in your header and including them only in your cpp files. However you <strong>can</strong> forward declare your own classes in header files, but you <strong>can't</strong> for classes in namespace std. According to the C++11 standard, 17.6.4.2.1:</p>\n<blockquote>\n<p id=\"so_28447236_47223308_0\">The behavior of a C++ program is undefined if it adds declarations or\n  definitions to namespace std or to a namespace within namespace std\n  unless otherwise specified.</p>\n</blockquote>\n<p>A workaround for this problem is to create a threading class that inherits from <code>std::thread</code> that you <strong>can</strong> forward declare. The header file for this class would look like:</p>\n<pre><code>#pragma once\n#include &lt;thread&gt;\n#include &lt;utility&gt;\nnamespace Threading\n{\n    class Thread : std::thread\n    {\n    public:\n        template&lt;class _Fn, class... _Args&gt; Thread(_Fn fn, _Args... args) : std::thread(fn, std::forward&lt;_Args...&gt;(args...))\n        {\n\n        }\n    private:\n\n    };\n}\n</code></pre>\n<p>In the header file that you would like to use the thread you can do forward declare it like:</p>\n<pre><code>#pragma once\n\n// Forward declare the thread class \nnamespace Threading { class Thread; }\nclass ExampleClass\n{\n    public:\n        ExampleClass();\n        void ThreadMethod();\n    private:\n        Threading::Thread * _thread;\n};\n</code></pre>\n<p>In your source file you can then use the theading class like:</p>\n<pre><code>#include \"ExampleClass.h\"\n#include \"Thread.h\"\n\nExampleClass::ExampleClass() :\n{\n    _thread = new Threading::Thread(&amp;ExampleClass::ThreadMethod, this);\n}\n\nvoid ExampleClass::ThreadMethod()\n{\n}\n</code></pre>\n<p>You should be able to do the same thing for std::mutex. Hope it might help anyone.</p>\n<p>Original post: <a href=\"https://stackoverflow.com/questions/15188937/using-clr-and-stdthread?noredirect=1&amp;lq=1\">using clr and std::thread</a></p>\n", "LastActivityDate": "2017-11-10T12:57:21.657", "Score": "0", "CreationDate": "2017-11-10T12:57:21.657", "ParentId": "28447236", "CommentCount": "0", "OwnerUserId": "8894012"}, "bq_ids": {"n4140": {"so_28447236_47223308_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6299}}, "n3337": {"so_28447236_47223308_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6056}}, "n4659": {"so_28447236_47223308_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7808}}}, "28447236": {"ViewCount": "746", "Body": "<p>I am writing a C++/CLI wrapper for a native C++ library.   In one of the classes that is returned back to the CLI wrapper, uses thread and, specifically <code>#include &lt;mutex&gt;</code> in the header to define the class level mutex.</p>\n<p>The problem is once the header is brought into the CLI code (with the /clr option enabled), I get the error that <code>&lt;mutex&gt;</code> is not supported when compiling with /clr or /clr:pure.</p>\n<p>Reading this post <a href=\"https://stackoverflow.com/questions/15821942/how-to-implement-a-unmanaged-thread-safe-collection-when-i-get-this-error-mute\">How to implement a unmanaged thread-safe collection when I get this error: &lt;mutex&gt; is not supported when compiling with /clr</a>, there was a blog article which mentions some possible work arounds.   The workarounds, however, assume that you don't need any header files which cause a conflict and all can be done within the class functions, essentially hiding the thread functions from the CLI app.</p>\n<p>In the case of a class level mutex, this is not the case.   It has to be in the header.   </p>\n<p>Is there any way to make a CLI app work with a native lib that is threaded?</p>\n<p>Yes, I am aware of the GetCurrentThreadID() issue between managed and unmanaged code, but what is the right approach?   Or is there no way around it?   </p>\n<p>I cringe at having to incorporate something like ZMQ because this is in a critical section and now having three copies of data (which could be very large) would be prohibitive.  (one on the managed side, one on the native, and one to pass through the message buffer in ZMQ).    I am aware of ZMQ's zero copy, but have not tried inproc between managed and unmanaged c++ to see if it is possible to share memory.   If it is possible, it would probably require a low level contiguous data structure to be used throughout the application or suffer the consequences of copying the data again.</p>\n<p>Any wizards out there with a decent solution?</p>\n", "Title": "Workaround for mutex in native lib for CLI DLL", "CreationDate": "2015-02-11T05:31:52.950", "LastActivityDate": "2017-11-10T12:57:21.657", "CommentCount": "6", "LastEditDate": "2017-05-23T12:32:45.683", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "28447236", "Score": "2", "OwnerUserId": "3072517", "Tags": "<multithreading><c++-cli><mutex>", "AnswerCount": "1"}});