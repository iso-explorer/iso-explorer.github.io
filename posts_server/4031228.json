post_cb({"4031228": {"ViewCount": "2018", "Body": "<p>While playing with <a href=\"https://stackoverflow.com/questions/4030959/will-a-variablename-c-statement-be-a-no-op-at-all-times/4030983#4030983\">this answer</a> by <a href=\"https://stackoverflow.com/users/87234/gman\">user GMan</a> I crafted the following snippet (compiled with Visual C++ 9):</p>\n<pre><code> class Class {\n public:\n     operator void() {}\n };\n\n Class object;\n static_cast&lt;void&gt;( object );\n (void)object;\n object.operator void();\n</code></pre>\n<p>after stepping over with the debugger I found out that casting to <code>void</code> doesn't invoke <code>Class::operator void()</code>, only the third invokation (with explicitly invoking the operator) actually invokes the operator, the two casts just do nothing.</p>\n<p>Why is the <code>operator void</code> not invoked with the cast syntax?</p>\n", "AcceptedAnswerId": "4031487", "Title": "Why is \"operator void\" not invoked with cast syntax?", "CreationDate": "2010-10-27T08:30:14.920", "Id": "4031228", "CommentCount": "8", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:44:25.273", "LastEditorUserId": "-1", "LastActivityDate": "2010-10-28T09:14:05.613", "Score": "33", "OwnerUserId": "57428", "Tags": "<c++><casting><operators><operator-overloading>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_4031228_4031487_0": {"length": 22, "quality": 1.0, "section_id": 391}, "so_4031228_4031487_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 6032}}, "n3337": {"so_4031228_4031487_0": {"length": 22, "quality": 1.0, "section_id": 382}, "so_4031228_4031487_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5800}}, "n4659": {"so_4031228_4031487_0": {"length": 22, "quality": 1.0, "section_id": 408}, "so_4031228_4031487_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 7531}}}, "4031487": {"Id": "4031487", "PostTypeId": "2", "Body": "<p>The technical reason why is found in \u00a712.3.2:</p>\n<blockquote>\n<p id=\"so_4031228_4031487_0\">A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), <strong>or to (possibly cv-qualified) void</strong>.</p>\n</blockquote>\n<p>The rationale is (likely) to allow \u00a75.2.9/4 to work:</p>\n<blockquote>\n<p id=\"so_4031228_4031487_1\">Any expression can be explicitly converted to type \u201ccv void.\u201d The expression value is discarded.</p>\n</blockquote>\n<p><code>(void)expr</code> to suppose to do nothing for the resulting value of <em>any</em> expression, but if it called your conversion operator it wouldn't be discarding anything. So they ban the use of <code>operator void</code> in conversions.</p>\n<hr>\n<p>Why not make it ill-formed to have the conversion-type-id be <code>void</code>? Who knows, but keep in mind it's not <em>totally</em> useless:</p>\n<pre><code>struct foo\n{\n    operator void()\n    {\n        std::cout &lt;&lt; \"huh?\" &lt;&lt; std::endl;\n    }\n\n};\n\ntypedef void (foo::*void_function)();\n\nfoo f;\nvoid_function func = &amp;foo::operator void;\n\n(f.*func)(); // prints \"huh\"\nf.operator void(); // also does (which you knew)\n</code></pre>\n<p>It is still technically potentially useful for <em>something</em>, so maybe that's rationale enough not to make it ill-formed.</p>\n</hr>", "LastEditorUserId": "87234", "LastActivityDate": "2010-10-28T09:14:05.613", "Score": "26", "CreationDate": "2010-10-27T09:03:36.717", "ParentId": "4031228", "CommentCount": "1", "OwnerUserId": "87234", "LastEditDate": "2010-10-28T09:14:05.613"}});