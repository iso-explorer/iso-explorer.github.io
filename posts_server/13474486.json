post_cb({"13474756": {"ParentId": "13474486", "CommentCount": "0", "CreationDate": "2012-11-20T13:55:10.653", "OwnerUserId": "430766", "PostTypeId": "2", "Id": "13474756", "Score": "2", "Body": "<p>The C++11 standard $12.2.3 says:</p>\n<blockquote>\n<p id=\"so_13474486_13474756_0\">When an implementation introduces a temporary object of a class that\n  has a non-trivial constructor (12.1, 12.8), it shall ensure that a\n  constructor is called for the temporary object. Similarly, the\n  destructor shall be called for a temporary with a non-trivial\n  destructor (12.4). <strong>Temporary objects are destroyed as the last step in\n  evaluating the full-expression (1.9) that (lexically) contains the\n  point where they were created.</strong> This is true even if that evaluation\n  ends in throwing an exception. The value computations and side effects\n  of destroying a temporary object are associated only with the\n  full-expression, not with any specific subexpression.</p>\n</blockquote>\n<p><sup>(emphasis mine)</sup></p>\n<p>There are additional caveats to this, but they don't apply in this situation. In your case the full expression is the indicated part of this statement:</p>\n<pre><code>char *szFish = AnsiString(sFish).c_str();\n//             ^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre>\n<p>So, the instant <code>szFish</code> is assigned, the destructor of your temporary object (i.e. <code>AnsiString(sFish)</code>) will be called and its internal memory representation (where <code>c_str()</code> points to) will be released. Thus, <code>szFish</code> will be immediately become a dangling pointer and any access will fail.</p>\n<p>You can get around this by saying</p>\n<pre><code>CallFunc(AnsiString(sFish).c_str());\n</code></pre>\n<p>instead, as here, the temporary will be destroyed (again) after the <em>full</em> expression (that is, right at the <code>;</code>) and <code>CallFunc</code> will be able to read the raw string.</p>\n", "LastActivityDate": "2012-11-20T13:55:10.653"}, "13474541": {"ParentId": "13474486", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-11-20T13:42:52.833", "Score": "5", "LastEditorUserId": "1033896", "LastEditDate": "2012-11-20T13:49:53.263", "Id": "13474541", "OwnerUserId": "1033896", "Body": "<p><code>szFish</code> is invalid before the call to <code>CallFunc()</code>, because <code>AnsiString</code> is a temporary object that is destructed immediately and <code>szFish</code> is pointing to its internal buffer which will have just been deleted.</p>\n<p>Ensure that the <code>AnsiString</code> instance is valid for the invocation of <code>CallFunc()</code>. For example:</p>\n<pre><code>CallFunc(AnsiString(sFish).c_str());\n</code></pre>\n", "LastActivityDate": "2012-11-20T13:49:53.263"}, "13474546": {"ParentId": "13474486", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-11-20T13:43:08.270", "Score": "4", "LastEditorUserId": "300886", "LastEditDate": "2012-11-20T13:49:22.823", "Id": "13474546", "OwnerUserId": "300886", "Body": "<p>I would replace:</p>\n<pre><code>char *szFish = AnsiString(sFish).c_str();\n</code></pre>\n<p>with:</p>\n<pre><code>AnsiString as(sFish);\nchar *szFish = as.c_str();\n</code></pre>\n<p>I don't know the <code>AnsiString</code> class but in your code its destructor will fire before your call to <code>CallFunc()</code>, and will most probably release the string you point to with <code>*szFish</code>. When you replace the temporary object with a \"named\" object on stack its lifetime will extend until the end of the block it is defined in.</p>\n", "LastActivityDate": "2012-11-20T13:49:22.823"}, "13474486": {"CommentCount": "1", "AcceptedAnswerId": "13474756", "PostTypeId": "1", "LastEditorUserId": "3235496", "CreationDate": "2012-11-20T13:39:52.383", "LastActivityDate": "2016-07-12T08:01:05.060", "LastEditDate": "2016-07-12T08:01:05.060", "ViewCount": "159", "FavoriteCount": "1", "Title": "What's the scope of this string?", "Id": "13474486", "Score": "2", "Body": "<p>If I have the following code:</p>\n<pre><code>{\n    UnicodeString sFish = L\"FISH\";\n    char *szFish = AnsiString(sFish).c_str();\n\n    CallFunc(szFish);\n}\n</code></pre>\n<p>Then what is the scope of the temporary AnsiString that's created, and for how long is szFish pointing to valid data?  Will it still be valid for the CallFunc function?</p>\n<p>Will it's scope last just the one line, or for the whole block?</p>\n", "Tags": "<c++><c++builder><c++builder-xe>", "OwnerUserId": "246312", "AnswerCount": "4"}, "13474629": {"ParentId": "13474486", "CommentCount": "0", "CreationDate": "2012-11-20T13:47:16.873", "OwnerUserId": "970543", "PostTypeId": "2", "Id": "13474629", "Score": "1", "Body": "<p>The scope of AnsiString in this case is \"from right before the call to c_str(), until right after.\" It may help to think of it this way: </p>\n<pre><code>char *szFish; \n\n{ \n    AnsiString tmpString(sFish); \n    szFish = tmpString.c_str(); \n}\n</code></pre>\n", "LastActivityDate": "2012-11-20T13:47:16.873"}, "bq_ids": {"n4140": {"so_13474486_13474756_0": {"section_id": 380, "quality": 0.9090909090909091, "length": 50}}, "n3337": {"so_13474486_13474756_0": {"section_id": 371, "quality": 0.9090909090909091, "length": 50}}, "n4659": {"so_13474486_13474756_0": {"section_id": 395, "quality": 0.9090909090909091, "length": 50}}}});