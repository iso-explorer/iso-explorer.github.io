post_cb({"8642157": {"Id": "8642157", "PostTypeId": "2", "Body": "<p>You need to provide an implementation of a virtual function ( with its default behaviour ) unless you define the function to be \"pure virtual\".</p>\n<p>So your example could be:</p>\n<pre><code>class base\n{\n   public:\n      void virtual virtualfunc() {} //intentionally do nothing;\n};\n</code></pre>\n<p>or</p>\n<pre><code>class base\n{\n   public:\n      void virtual virtualfunc()=0; //pure virtual;\n};\n</code></pre>\n", "LastActivityDate": "2011-12-27T07:30:37.760", "Score": "8", "CreationDate": "2011-12-27T07:30:37.760", "ParentId": "8642124", "CommentCount": "0", "OwnerUserId": "221955"}, "8642124": {"ViewCount": "3337", "Body": "<p>Is it essential to have a definition for a virtual function?</p>\n<p>Consider this sample program below:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass base\n{\n   public:\n      void virtual virtualfunc();\n};\n\nclass derived : public base\n{\n   public:\n   void virtualfunc()\n   {\n      cout &lt;&lt; \"vf in derived class\\n\";\n   }\n};\n\nint main()\n{\n   derived d;\n   return 0;\n}\n</code></pre>\n<p>This gives the link-error:</p>\n<blockquote>\n<p id=\"so_8642124_8642124_0\">In function <code>base::base()</code>:: undefined reference to <code>vtable for base</code></p>\n</blockquote>\n<p>I do not have the definition for the virtual function in base class. Why is this error occurring even though I have not explicitly invoked the virtual function?</p>\n<p>The interesting thing which I find is that if I do not instantiate an object of class <code>derived</code>, the link error is no longer there.  Why is this?  What has instantiation got to do with the above link error?</p>\n", "AcceptedAnswerId": "8642218", "Title": "Should a virtual function essentially have a definition?", "CreationDate": "2011-12-27T07:25:54.107", "Id": "8642124", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-07-20T17:00:26.670", "LastEditorUserId": "4850040", "LastActivityDate": "2017-07-20T17:00:26.670", "Score": "7", "OwnerUserId": "1220250", "Tags": "<c++><virtual-functions><undefined-reference>", "AnswerCount": "5"}, "8642218": {"Id": "8642218", "PostTypeId": "2", "Body": "<p>The ISO C++ Standard specifies that all virtual methods of a class that are not pure-virtual must be defined.</p>\n<p>Reference:</p>\n<p><strong>C++03 Standard: 10.3 Virtual functions   [class.virtual]</strong> </p>\n<blockquote>\n<p id=\"so_8642124_8642218_0\">A virtual function declared in a class shall be defined, or declared pure (10.4) in that class, or both; but no diagnostic is required (3.2).</p>\n</blockquote>\n<p>So either you should make the function pure virtual or provide a definition for it.   </p>\n<p>If you are using gcc, You might get some weird errors if you fail to follow this standard specification. The <strong><a href=\"http://gcc.gnu.org/faq.html#vtables\" rel=\"noreferrer\">gcc faq</a></strong> doccuments it as well:  </p>\n<blockquote>\n<p id=\"so_8642124_8642218_1\">The ISO C++ Standard specifies that all virtual methods of a class that are not pure-virtual must be defined, but does not require any diagnostic for violations of this rule <code>[class.virtual]/8</code>. Based on this assumption, GCC will only emit the implicitly defined constructors, the assignment operator, the destructor and the virtual table of a class in the translation unit that defines its first such non-inline method.</p>\n<p id=\"so_8642124_8642218_2\">Therefore, if you fail to define this particular method, the linker may complain about the lack of definitions for apparently unrelated symbols. Unfortunately, in order to improve this error message, it might be necessary to change the linker, and this can't always be done.</p>\n<p id=\"so_8642124_8642218_3\">The solution is to ensure that all virtual methods that are not pure are defined. Note that a destructor must be defined even if it is declared pure-virtual <code>[class.dtor]/7</code>.</p>\n</blockquote>\n", "LastActivityDate": "2011-12-27T07:41:05.770", "Score": "10", "CreationDate": "2011-12-27T07:41:05.770", "ParentId": "8642124", "CommentCount": "1", "OwnerUserId": "452307"}, "bq_ids": {"n4140": {"so_8642124_8642218_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7012}}, "n3337": {"so_8642124_8642218_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6758}}, "n4659": {"so_8642124_8642218_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 8509}}}, "8642165": {"Id": "8642165", "PostTypeId": "2", "Body": "<p>Yes you would need a body, but perhaps what you are referring to is called a pure virtual functions, which would not need a definition in the base class.</p>\n<p>The syntax to define those is as follows:</p>\n<pre><code>void virtual virtualfunc() = 0;\n</code></pre>\n", "LastActivityDate": "2011-12-27T07:32:10.917", "Score": "0", "CreationDate": "2011-12-27T07:32:10.917", "ParentId": "8642124", "CommentCount": "0", "OwnerUserId": "326820"}, "8642139": {"Id": "8642139", "PostTypeId": "2", "Body": "<p>You either need to provide a definition, or mark it as abstract/pure-vitual.</p>\n<pre><code>void virtual virtualfunc() = 0;\n</code></pre>\n", "LastActivityDate": "2011-12-27T07:29:29.167", "Score": "3", "CreationDate": "2011-12-27T07:29:29.167", "ParentId": "8642124", "CommentCount": "1", "OwnerUserId": "635608"}, "16285113": {"Id": "16285113", "PostTypeId": "2", "Body": "<p>In response to the error about the vtable: the virtual command in this case tells c++ to produce a virtual table of the methods in the base class. In this way when you use polymorphism, C++ is able to replace the base class virtual methods with the methods from the derived class with the same name during run time. This error is telling the user that this replacement is not possible. To fix this error, you will either need to implement the method or set it as pure virtual by adding \"=0\" at the end of the definition.</p>\n<p>In response to the edits: The reason you are not getting an error when you instantiate the object as a base class is because the base class does not need to access the virtual table. On the other hand if you actually try to use this method, you should get an error since no implementation exists. In other words even though you can instantiate an object of the base class its not a complete class.    </p>\n", "LastActivityDate": "2013-04-29T17:52:00.400", "Score": "1", "CreationDate": "2013-04-29T17:52:00.400", "ParentId": "8642124", "CommentCount": "1", "OwnerUserId": "1705325"}});