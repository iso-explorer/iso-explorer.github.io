post_cb({"9532647": {"ParentId": "9532608", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-03-02T11:39:07.290", "Score": "33", "LastEditorUserId": "500104", "LastEditDate": "2012-11-16T00:34:36.107", "Id": "9532647", "OwnerUserId": "500104", "Body": "<p>For local variables, there's no need to <code>std::move</code> them in the <code>return</code> statement most of the time<sup>\u2020</sup>, since the language actually demands that this happens automatically:</p>\n<p><code>\u00a712.8 [class.copy] p32</code></p>\n<blockquote>\n<p id=\"so_9532608_9532647_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, <strong>and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong>. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ <em>Note:</em> This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. <em>\u2014end note</em> ]</p>\n</blockquote>\n<hr>\n<p>\u2020 Copy elision is very restricted in where it can be applied (<code>\u00a712.8/31</code>). One such restriction is that the type of the source object has to be the same as the cv-unqualified return type of the function when dealing with a return-statement. It's also not applicable for subobjects of local variables that are about to go out of scope.</p>\n</hr>", "LastActivityDate": "2012-11-16T00:34:36.107"}, "9532608": {"CommentCount": "6", "AcceptedAnswerId": "9532647", "CreationDate": "2012-03-02T11:35:17.103", "LastActivityDate": "2012-11-16T00:34:36.107", "PostTypeId": "1", "ViewCount": "6083", "FavoriteCount": "9", "Title": "Is returning with `std::move` sensible in the case of multiple return statements?", "Id": "9532608", "Score": "21", "Body": "<p>I'm aware that it's normally not a good idea to return with <code>std::move</code>, i.e.</p>\n<pre><code>bigObject foo() { bigObject result; /*...*/ return std::move(result); }\n</code></pre>\n<p>instead of simply</p>\n<pre><code>bigObject foo() { bigObject result; /*...*/ return result; }\n</code></pre>\n<p>because it gets in the way of return value optimization. But what in the case of a function with multiple different returns, particularly something like</p>\n<pre><code>class bar {\n  bigObject fixed_ret;\n  bool use_fixed_ret;\n  void prepare_object(bigObject&amp;);\n public:\n  bigObject foo() {\n    if(use_fixed_ret)\n      return fixed_ret;\n     else{\n      bigObject result;\n      prepare_object(result);\n      return result;\n    }\n  }\n};\n</code></pre>\n<p>I think normal return value optimization is impossible in such a function, so would it be a good idea to put in</p>\n<pre><code>      return std::move(result);\n</code></pre>\n<p>here, or should I rather do (IMO uglier, but that's debatable)</p>\n<pre><code>  bigObject foo() {\n    bigObject result;\n    if(use_fixed_ret)\n      result = fixed_ret;\n     else{\n      prepare_object(result);\n    }\n    return result;\n  }\n</code></pre>\n", "Tags": "<c++><c++11><move-semantics><return-value-optimization>", "OwnerUserId": "745903", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9532608_9532647_0": {"section_id": 481, "quality": 0.8311688311688312, "length": 64}}, "n3337": {"so_9532608_9532647_0": {"section_id": 472, "quality": 0.948051948051948, "length": 73}}, "n4659": {"so_9532608_9532647_0": {"section_id": 504, "quality": 0.7792207792207793, "length": 60}}}});