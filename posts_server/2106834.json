post_cb({"6697097": {"Id": "6697097", "PostTypeId": "2", "Body": "<p>As an additional remark, this is the typical case where been concise overrules clarity, something Brian Kernighan strongly advises us to avoid (He wrote an excellent book on these matters, \"The Practice of Programming\"). The evaluation order is not well defined in such code, what leads to the \"side effect\" of unpredictable results. The change you have made is the recommended approach to situations like this one.</p>\n", "LastActivityDate": "2011-07-14T16:58:01.250", "CommentCount": "0", "CreationDate": "2011-07-14T16:58:01.250", "ParentId": "2106834", "Score": "0", "OwnerUserId": "738587"}, "2107126": {"Id": "2107126", "PostTypeId": "2", "Body": "<p>Passing data through argument lists like that is very, very, unclear. Relying on implicit casts between reference types to different-sized bases is very, very unsafe.</p>\n<p>Anyway, if you're calling <code>by_index(size_t &amp;,\u2026</code> with an <code>int</code> argument, you're taking the reference of a temporary. This should be a warning, but maybe you're on an older compiler. Try an explicit cast.</p>\n<pre><code>reinterpret_cast&lt; size_t &amp; &gt;( i ) /* modify i before next fn call */\n</code></pre>\n<p>But of course that's not guaranteed to do the right thing. Really, you need to sort out unsigned from signed and not assume <code>sizeof(int) == sizeof(size_t)</code> because often it isn't.</p>\n", "LastActivityDate": "2010-01-21T05:24:57.443", "CommentCount": "0", "CreationDate": "2010-01-21T05:24:57.443", "ParentId": "2106834", "Score": "0", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_2106834_2107128_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 5811}}, "n3337": {"so_2106834_2107128_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 5584}}, "n4659": {"so_2106834_2107128_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 7272}}}, "2107128": {"Id": "2107128", "PostTypeId": "2", "Body": "<p>In my opinion, this boils down to order of evaluation.</p>\n<p>The standard says -</p>\n<blockquote>\n<p id=\"so_2106834_2107128_0\">(5.4) Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified.</p>\n</blockquote>\n<p>Which fits the bill exactly. The values of i and j may be evaluated before the call to by_index(), or after it. You can't tell - this is unspecified.</p>\n<p>I will add that the form that solves your problem is <strong>far</strong> more readable in my eyes, and I would have used it regardless of correctness of the first form...</p>\n", "LastActivityDate": "2010-01-21T05:25:21.937", "CommentCount": "3", "CreationDate": "2010-01-21T05:25:21.937", "ParentId": "2106834", "Score": "3", "OwnerUserId": "88451"}, "2110450": {"Id": "2110450", "PostTypeId": "2", "Body": "<p>Finally I found where in the standard this is specified (n1905 draft):</p>\n<blockquote>\n<p id=\"so_2106834_2110450_0\"><em>(5.2.2-8)</em> - The order of evaluation of arguments is unspeci\ufb01ed. All side effects of argument expression evaluations take effect before the function is entered. The order of evaluation of the post\ufb01x expression and the argument expression list is unspeci\ufb01ed.</p>\n</blockquote>\n<p>The <em>postfix expression</em> mentioned is the part to the left of <code>()</code>. So in the \"outer\" function call it is not specified if <code>by_index(i, j, index)</code> or it's arguments <code>(i, j)</code> are evaluated first.</p>\n<p>There is a sequence point after a function returns, so when <code>by_index(i, j, index)</code> returns all side effects are complete, but the <code>(i, j)</code> parameters might already have been evaluated (and the values been stored in a register or sth.) before that function even go called.</p>\n", "LastEditorUserId": "56338", "LastActivityDate": "2010-01-21T15:44:19.143", "Score": "2", "CreationDate": "2010-01-21T15:35:40.660", "ParentId": "2106834", "CommentCount": "0", "OwnerUserId": "56338", "LastEditDate": "2010-01-21T15:44:19.143"}, "2106935": {"Id": "2106935", "PostTypeId": "2", "Body": "<p>I suspect that casting a reference to a different type breaks <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">strict aliasing rules</a> that your compiler uses to optimize more efficiently. You have two variables/references of different type and the compiler assumes that they don't refer to the same memory (but which they in fact do). The compiler then optimizes the code under that wrong assumption which produces wrong results.</p>\n<p>You can try to compile with <code>-fno-strict-aliasing</code> (or equivalent) to disable these optimizations and see if it improves the situation.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-01-21T04:31:23.050", "Score": "2", "CreationDate": "2010-01-21T04:31:23.050", "ParentId": "2106834", "CommentCount": "2", "OwnerUserId": "56338", "LastEditDate": "2017-05-23T11:46:40.410"}, "2106834": {"ViewCount": "1450", "Body": "<p>i ran into a curious problem regarding evaluation of expressions:</p>\n<pre><code>reference operator()(size_type i, size_type j) {\n  return by_index(i, j, index)(i, j); // return matrix index reference with changed i, j\n}\n\nmatrix&amp; by_index(size_type &amp;i, size_type &amp;j, index_vector &amp;index) {\n  size_type a = position(i, index); // find position of i using std::upper_bound\n  size_type b = position(j, index);\n  i -= index[a];\n  j -= index[b];\n  return matrix_(a,b); // returns matrix reference stored in 2-D array\n}\n</code></pre>\n<p>I have thought matrix(i,j) will be evaluated after the call to buy_index, so that i, j will be updated. this appears to be correct, i verified in debugger. however, for some types of matrix, specifically those which have to cast size_type the something else, for example int, the update in by_index is lost. modifying code slightly removes the problem:  </p>\n<pre><code>reference operator()(size_type i, size_type j) {\n  matrix &amp;m = by_index(i, j, index);\n  return m(i, j); \n}\n</code></pre>\n<p>do you know why the first operator misbehaves?\nthanks</p>\n<p>prototypes which work and which do not</p>\n<pre><code>inline reference operator () (size_t i, size_t j); // ublas, size_type is std::size_t\nreference operator () (int i, int j); // other prototype, size_type is int\n</code></pre>\n<p>in debugger backtrace stack looks like this: </p>\n<ul>\n<li>i = 1 upon entry to operator() //okay</li>\n<li>i = 0 after finish from by_index //okay</li>\n<li>i = 1 upon entry to matrix:: operator() //not right, should be 0</li>\n</ul>\n", "AcceptedAnswerId": "2107128", "Title": "C++ expression evaluation order", "CreationDate": "2010-01-21T04:00:42.793", "Id": "2106834", "CommentCount": "6", "LastEditDate": "2010-01-21T04:31:12.927", "PostTypeId": "1", "LastEditorUserId": "206328", "LastActivityDate": "2011-07-14T16:58:01.250", "Score": "4", "OwnerUserId": "206328", "Tags": "<c++><order><evaluation>", "AnswerCount": "5"}});