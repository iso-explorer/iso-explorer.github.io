post_cb({"26834832": {"ParentId": "26834655", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-10T00:03:35.347", "Id": "26834832", "LastEditDate": "2017-05-23T10:32:38.987", "OwnerDisplayName": "user3920237", "Score": "14", "Body": "<p>A variation of the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow noreferrer\">as-if rule</a>, the C++11 standard says:</p>\n<blockquote>\n<p id=\"so_26834655_26834832_0\">\u00a75.1.2/3 <em>[..]</em> An implementation may define the closure type\n  differently from what is described below provided this does not alter\n  the observable behavior of the program other than by changing:</p>\n<p id=\"so_26834655_26834832_1\">\u2014 the size and/or alignment of the closure type,</p>\n<p id=\"so_26834655_26834832_2\">\u2014 whether the closure type is trivially copyable (Clause 9),</p>\n<p id=\"so_26834655_26834832_3\">\u2014 whether the closure type is a standard-layout class (Clause 9), or</p>\n<p id=\"so_26834655_26834832_4\">\u2014 whether the closure type is a POD class (Clause 9).</p>\n</blockquote>\n<p>I believe this is what people mean when they say that it's <a href=\"https://stackoverflow.com/questions/7951377/what-is-the-type-of-lambda-when-deduced-with-auto-in-c11\">unspecified</a>. However what's guaranteed as already stated in the other answers is the following:</p>\n<p>Original author: <a href=\"https://stackoverflow.com/a/20825525/3920237\">Lightness Races in Orbit</a></p>\n<blockquote>\n<blockquote>\n<p id=\"so_26834655_26834832_9\"><code>[C++11: 5.1.2/3]:</code> <strong>The type of the <em>lambda-expression</em></strong> (which is also the type of the closure object) <strong>is a unique, unnamed\n    non-union class type</strong> \u2014 called the <em>closure type</em> \u2014 whose properties\n    are described below. This class type is not an aggregate (8.5.1). The\n    closure type is declared in the smallest block scope, class scope, or\n    namespace scope that contains the corresponding <em>lambda-expression</em>.\n    <em>[..]</em></p>\n</blockquote>\n<p id=\"so_26834655_26834832_6\">The clause goes on to list varying properties of this type. Here are\n  some highlights:</p>\n<blockquote>\n<p id=\"so_26834655_26834832_10\"><code>[C++11: 5.1.2/5]:</code> The closure type for a <em>lambda-expression</em> has a public <code>inline</code> function call operator (13.5.4) whose parameters and\n    return type are described by the <em>lambda-expression</em>\u2019s\n    <em>parameter-declaration-clause</em> and <em>trailing-return-type</em> respectively. <em>[..]</em></p>\n<p id=\"so_26834655_26834832_11\"><code>[C++11: 5.1.2/6]:</code> The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const\n    conversion function to pointer to function having the same parameter\n    and return types as the closure type\u2019s function call operator. The\n    value returned by this conversion function shall be the address of a\n    function that, when invoked, has the same effect as invoking the\n    closure type\u2019s function call operator.</p>\n</blockquote>\n</blockquote>\n", "LastActivityDate": "2014-11-10T00:03:35.347", "LastEditorUserId": "-1"}, "26834655": {"CommentCount": "4", "AcceptedAnswerId": "26834832", "PostTypeId": "1", "ClosedDate": "2014-11-17T16:51:54.113", "LastEditorUserId": "2069064", "CreationDate": "2014-11-09T23:41:46.727", "LastActivityDate": "2015-02-07T03:24:24.030", "LastEditDate": "2015-02-07T03:24:24.030", "ViewCount": "1577", "FavoriteCount": "4", "Title": "What type do lambdas get compiled into?", "Id": "26834655", "Score": "16", "Body": "<p>As I know all data types must be known at compile time, and lambda is not a type. Does lambda got translated into <code>anonymous struct with operator()</code> or <code>std::function</code> wrapped?</p>\n<p>For example,</p>\n<pre><code>std::for_each(v.begin(), v.end(), [](int n&amp;){n++;});\n</code></pre>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "1270003", "AnswerCount": "3"}, "26834712": {"ParentId": "26834655", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>A lambda expression constructs an unnamed type, with each one having a different type. They are not <code>std::function</code> implementations. More info is provided here:\n<a href=\"https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11/7627218#7627218\">What is a lambda expression in C++11?</a> and here: <a href=\"https://stackoverflow.com/questions/13358672/how-to-convert-a-lambda-to-an-stdfunction-using-templates\">How to convert a lambda to an std::function using templates</a></p>\n<p>You can unveil the type on your specific compiler with a trick like this:</p>\n<pre><code>void foo(int);\n\nint main() {\n    auto a = []{ return 1; };\n    auto b = []{ return 1; };\n\n    foo(a);\n\n    foo(b);\n\n    return 0;\n}\n</code></pre>\n<p>Compiling with clang on my mac gives:</p>\n<pre><code>/Users/jcrotinger/ClionProjects/so_lambda_type/main.cpp:11:5: error: no matching function for call to 'foo'\n    foo(a);\n    ^~~\n/Users/jcrotinger/ClionProjects/so_lambda_type/main.cpp:5:6: note: candidate function not viable: no known conversion from \n'&lt;lambda at /Users/jcrotinger/ClionProjects/so_lambda_type/main.cpp:8:14&gt;' to 'int' for 1st argument\nvoid foo(int);\n     ^\n/Users/jcrotinger/ClionProjects/so_lambda_type/main.cpp:13:5: error: no matching function for call to 'foo'\n    foo(b);\n    ^~~\n/Users/jcrotinger/ClionProjects/so_lambda_type/main.cpp:5:6: note: candidate function not viable: no known conversion from \n'&lt;lambda at /Users/jcrotinger/ClionProjects/so_lambda_type/main.cpp:9:14&gt;' to 'int' for 1st argument\nvoid foo(int);\n</code></pre>\n<p>@Barry points out that you can use <code>typeid</code> instead. If I print out <code>typeid(a).name()</code> and <code>typeid(b).name()</code> on my system, I get:</p>\n<pre><code>Z4mainE3$_0\nZ4mainE3$_1\n</code></pre>\n<p>which demangle to</p>\n<pre><code>main::$_0\nmain::$_1\n</code></pre>\n<p>Just wanted to include this for completeness. I actually find the error message version a little more informative. :)</p>\n", "OwnerUserId": "2587908", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:39.390", "Id": "26834712", "Score": "6", "CreationDate": "2014-11-09T23:49:24.530", "LastActivityDate": "2014-11-10T00:29:54.267"}, "bq_ids": {"n4140": {"so_26834655_26834832_9": {"section_id": 5962, "quality": 0.825, "length": 33}, "so_26834655_26834832_5": {"section_id": 5962, "quality": 0.825, "length": 33}, "so_26834655_26834736_0": {"section_id": 5962, "quality": 0.875, "length": 7}, "so_26834655_26834832_0": {"section_id": 5962, "quality": 0.9444444444444444, "length": 17}, "so_26834655_26834832_10": {"section_id": 5964, "quality": 0.8095238095238095, "length": 17}, "so_26834655_26834832_1": {"section_id": 5962, "quality": 1.0, "length": 5}, "so_26834655_26834832_2": {"section_id": 5962, "quality": 1.0, "length": 6}, "so_26834655_26834832_7": {"section_id": 5964, "quality": 0.8095238095238095, "length": 17}, "so_26834655_26834832_8": {"section_id": 5965, "quality": 0.9047619047619048, "length": 38}, "so_26834655_26834832_4": {"section_id": 5962, "quality": 1.0, "length": 6}, "so_26834655_26834832_3": {"section_id": 5962, "quality": 1.0, "length": 6}, "so_26834655_26834832_11": {"section_id": 5965, "quality": 0.9047619047619048, "length": 38}}, "n3337": {"so_26834655_26834832_9": {"section_id": 5731, "quality": 0.825, "length": 33}, "so_26834655_26834832_5": {"section_id": 5731, "quality": 0.825, "length": 33}, "so_26834655_26834736_0": {"section_id": 5731, "quality": 0.875, "length": 7}, "so_26834655_26834832_0": {"section_id": 5731, "quality": 0.9444444444444444, "length": 17}, "so_26834655_26834832_10": {"section_id": 5733, "quality": 0.8095238095238095, "length": 17}, "so_26834655_26834832_1": {"section_id": 5731, "quality": 1.0, "length": 5}, "so_26834655_26834832_2": {"section_id": 5731, "quality": 1.0, "length": 6}, "so_26834655_26834832_7": {"section_id": 5733, "quality": 0.8095238095238095, "length": 17}, "so_26834655_26834832_8": {"section_id": 5734, "quality": 0.9047619047619048, "length": 38}, "so_26834655_26834832_11": {"section_id": 5734, "quality": 0.9047619047619048, "length": 38}, "so_26834655_26834832_3": {"section_id": 5731, "quality": 1.0, "length": 6}, "so_26834655_26834832_4": {"section_id": 5731, "quality": 1.0, "length": 6}}, "n4659": {"so_26834655_26834832_3": {"section_id": 7452, "quality": 1.0, "length": 6}, "so_26834655_26834832_10": {"section_id": 7453, "quality": 0.8095238095238095, "length": 17}, "so_26834655_26834832_7": {"section_id": 7453, "quality": 0.8095238095238095, "length": 17}, "so_26834655_26834832_8": {"section_id": 7456, "quality": 0.8095238095238095, "length": 34}, "so_26834655_26834736_0": {"section_id": 7451, "quality": 0.875, "length": 7}, "so_26834655_26834832_0": {"section_id": 7452, "quality": 0.9444444444444444, "length": 17}, "so_26834655_26834832_2": {"section_id": 7452, "quality": 1.0, "length": 6}, "so_26834655_26834832_11": {"section_id": 7456, "quality": 0.8095238095238095, "length": 34}, "so_26834655_26834832_1": {"section_id": 7452, "quality": 1.0, "length": 5}, "so_26834655_26834832_4": {"section_id": 7452, "quality": 1.0, "length": 6}}}, "26834736": {"ParentId": "26834655", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>From the standard \u00a75.1.2.3:</p>\n<blockquote>\n<p id=\"so_26834655_26834736_0\">The type of the <em>lambda-expression</em>... is a unique, unnamed non-union class type</p>\n</blockquote>\n<p>It is its own type. Every time. So for instance:</p>\n<pre><code>auto a = []{ return 1; };\nauto b = []{ return 1; };\n</code></pre>\n<p><code>a</code> and <code>b</code> will necessarily have different types. They are both convertible to <code>std::function&lt;int()&gt;</code>, but not to each other:</p>\n<pre><code>std::function&lt;int()&gt; c = a; // OK\na = b; // NOPE\n</code></pre>\n<p>Adding a few more examples to add some clarity:</p>\n<pre><code>decltype(a) a2 = a; // OK, explicitly specifying the correct type\n\ntemplate &lt;typename F&gt;\nvoid foo(F f) { ... }\n\nfoo(a); // calls foo&lt;decltype(a)&gt;, not foo&lt;std::function&lt;int()&gt;\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2014-11-09T23:57:45.613", "Id": "26834736", "Score": "12", "CreationDate": "2014-11-09T23:52:24.387", "LastActivityDate": "2014-11-09T23:57:45.613"}});