post_cb({"bq_ids": {"n4140": {"so_6950055_6950099_1": {"length": 28, "quality": 1.0, "section_id": 6101}, "so_6950055_6950099_0": {"length": 44, "quality": 0.9777777777777777, "section_id": 6089}}, "n3337": {"so_6950055_6950099_1": {"length": 28, "quality": 1.0, "section_id": 5867}, "so_6950055_6950099_0": {"length": 45, "quality": 1.0, "section_id": 5857}}, "n4659": {"so_6950055_6950099_1": {"length": 28, "quality": 1.0, "section_id": 7598}, "so_6950055_6950099_0": {"length": 44, "quality": 0.9777777777777777, "section_id": 7585}}}, "6950386": {"Id": "6950386", "PostTypeId": "2", "Body": "<p>Try auto pointer for <code>T* v_</code> or any dynamic allocated resources. If following happens</p>\n<pre><code>template&lt;class T&gt; \nStack&lt;T&gt;::Stack()\n        : v_(new T[10]),\n          vsize_(10),\n          vused_(0)\n{\n    throw 0; // terminated by exception\n}\n</code></pre>\n<p>or, there is another object in the <code>Stack</code> throw an exception when constructing, <code>v_</code> will cause memory leak. If you wrap it as <code>std::unique_ptr&lt;T[]&gt; v_</code> or something like this, it will be automatically freed if the construct of <code>Stack</code> terminated by an exception.</p>\n", "LastActivityDate": "2011-08-05T01:08:21.907", "CommentCount": "3", "CreationDate": "2011-08-05T01:08:21.907", "ParentId": "6950055", "Score": "0", "OwnerUserId": "555515"}, "6950055": {"ViewCount": "491", "Body": "<p>Exceptional C++ mentions the following code</p>\n<pre><code>template &lt;class T&gt; class Stack \n{\n    public:\n      Stack();\n      ~Stack();\n\n      /*...*/\n\n    private:\n       T*     v_;      // ptr to a memory area big\n       size_t vsize_;  //  enough for 'vsize_' T's\n       size_t vused_;  // # of T's actually in use\n};\n\n\n\ntemplate&lt;class T&gt; \nStack&lt;T&gt;::Stack()\n        : v_(new T[10]),  // default allocation\n          vsize_(10),\n          vused_(0)       // nothing used yet\n{ \n}\n</code></pre>\n<p>It says that If one of the T constructors threw, then any T objects that were fully constructed were properly destroyed and, finally, operator delete was automatically called to release the memory. That makes us leakproof.</p>\n<p>My understanding was that if a constructor throws an exception, the application should cleanup any allocated resources.  How is the above leakproof?</p>\n", "AcceptedAnswerId": "6950099", "Title": "c++ exception safety", "CreationDate": "2011-08-05T00:08:12.863", "Id": "6950055", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-08-05T07:57:12.210", "Score": "6", "OwnerUserId": "635057", "Tags": "<c++><exception>", "AnswerCount": "3"}, "6950099": {"Id": "6950099", "PostTypeId": "2", "Body": "<p>Quoting the C++03 standard, \u00a75.3.4/8:</p>\n<blockquote>\n<p id=\"so_6950055_6950099_0\">A <em>new-expression</em> obtains storage for the object by calling an <em>allocation function</em>. If the <em>new-expression</em> terminates by throwing an exception, it may release storage by calling a deallocation function. If the allocated type is a non-array type, the allocation function\u2019s name is <code>operator new</code> and the deallocation function\u2019s name is <code>operator delete</code>. If the allocated type is an array type, the allocation function\u2019s name is <code>operator new[]</code> and the deallocation function\u2019s name is <code>operator delete[]</code>.</p>\n</blockquote>\n<p>\u00a75.3.4/17:</p>\n<blockquote>\n<p id=\"so_6950055_6950099_1\">If any part of the object initialization described above terminates by throwing an exception and a suitable deallocation function can be found, the deallocation function is called to free the memory in which the object was being constructed, after which the exception continues to propagate in the context of the <em>new-expression</em>.</p>\n</blockquote>\n<p>Consequently, if any <code>T</code> constructor throws an exception, the runtime will destroy any already-created subobjects of the <code>T</code> instance whose constructor threw, then call <code>operator delete[]</code> on the array as a whole, destroying any already-created elements and deallocating the array's memory.</p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2011-08-05T00:59:09.940", "Score": "8", "CreationDate": "2011-08-05T00:16:47.570", "ParentId": "6950055", "CommentCount": "16", "OwnerUserId": "636019", "LastEditDate": "2011-08-05T00:59:09.940"}, "6950083": {"Id": "6950083", "PostTypeId": "2", "Body": "<p>[Correction:] <s>It is not.</s> An exception in your constructor won't leak resources because the only place an exception could occur is inside the <code>new</code> expression, and if a <code>new</code> expression fails, the resources that were allocated by it are freed. <em>Your situation is special because you only make one single allocation in the constructor -- in general this is not safe!</em></p>\n<p>Your quoted phrase refers to is the delete operator for the failed-object whose constructor threw:</p>\n<pre><code>struct T\n{\n  T() { throw 1; }\n  char data[200];\n};\n\n// in your code:\n\nT * pt = new T;\n</code></pre>\n<p>In the last line, memory is allocated before the constructor is invoked. <em>That</em> memory is released in the event of an exception, by an automatic call to <code>::operator delete(pt)</code>. (In general, the matching delete-operator (not \"expression\"!) matching the new expression is called.)</p>\n<p>It goes like this:</p>\n<ul>\n<li><p>Successful construction: 1. Allocation. 2. Construction. 3. Destruction. 4. Deallocation.</p></li>\n<li><p>Unsuccessful construction: 1. Allocation. 2. Deallocation.</p></li>\n</ul>\n<p>Note that we only <em>have</em> an object <em>after</em> the constructor has completed -- so in the event of an exception in the constructor, <em>we do not even have an object</em>. That's why I said \"failed-object\" above with a hyphen, because it's not an object at all (like the Douglas-fir isn't a fir at all).</p>\n<p>Your code is potentially entirely leak <em>unsafe</em>, if you are making more than one allocation which could throw - i.e. a leak occurs whenever one object has been successfully constructed but another, subsequent one fails. You should probably just not call <code>new</code> in the initializer list and instead put it in the body:</p>\n<pre><code>class Danger\n{\n  T * pt1, * pt2;\npublic:\n  Danger()\n  {\n    try { pt1 = new T; } catch(...) { throw(); }\n    try { pt2 = new T; } catch(...) { delete pt1; throw(); }\n  }\n};\n</code></pre>\n<p>Or, by the principle of single responsibility, don't use raw pointers but use resource managing containers that clean up after themselves!!</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2011-08-05T07:57:12.210", "Score": "3", "CreationDate": "2011-08-05T00:15:06.793", "ParentId": "6950055", "CommentCount": "19", "OwnerUserId": "596781", "LastEditDate": "2011-08-05T07:57:12.210"}});