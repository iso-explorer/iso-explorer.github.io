post_cb({"29593334": {"ParentId": "29593207", "CommentCount": "3", "Body": "<p>The reason is that you always have the possibility to override an in class initializer list in the constructor. So I guess that in the end it could be very confusing.</p>\n<pre><code>struct Foo\n{\n   Foo() {} // str = \"test\\0\";\n\n   // Implementing this is easier if I can clearly see how big `str` is, \n   Foo() : str({'a','b', 'c', 'd'}) {} // str = \"abcd0\"\n   const char str[] = \"test\";\n};\n</code></pre>\n<p>Notice that replacing <code>const char</code> with <code>static constexpr</code> works perfectly, and probably it is what you want anyway</p>\n", "OwnerUserId": "666785", "PostTypeId": "2", "Id": "29593334", "Score": "11", "CreationDate": "2015-04-12T18:55:59.290", "LastActivityDate": "2015-04-12T18:55:59.290"}, "29593683": {"ParentId": "29593207", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As mentioned in the comments and as answered by @sbabbi, the answer lies in the details </p>\n<p><strong>12.6.2 Initializing bases and members [class.base.init]</strong></p>\n<blockquote>\n<ol start=\"8\">\n<li><p id=\"so_29593207_29593683_0\">In a non-delegating constructor, if a given non-static data member or\n  base class is not designated by a mem-initializer-id (including the\n  case where there is no mem-initializer-list because the constructor\n  has no ctor-initializer) and the entity is not a virtual base class of\n  an abstract class (10.4), then </p>\n<ul>\n<li>if the entity is a non-static data member that has a brace-or-equal-initializer , the entity is initialized as specified in\n  8.5; </li>\n<li>otherwise, if the entity is an anonymous union or a variant member (9.5), no initialization is performed; </li>\n<li>otherwise, the entity is default-initialized</li>\n</ul></li>\n</ol>\n</blockquote>\n<p><strong>12.6.2 Initializing bases and members [class.base.init]</strong></p>\n<blockquote>\n<ol start=\"9\">\n<li><p id=\"so_29593207_29593683_1\">If a given non-static data member has both a\n  brace-or-equal-initializer and a mem-initializer, the initialization\n  specified by the mem-initializer is performed, and the non-static data\n  member\u2019s brace-or-equal-initializer is ignored. [ Example: Given</p>\n<pre><code>struct A { \n    int i = /\u2217 some integer expression with side effects \u2217/ ; \n    A(int arg) : i(arg) { } \n    // ... \n};\n</code></pre></li>\n</ol>\n<p id=\"so_29593207_29593683_2\">the A(int) constructor will simply initialize i to the value of arg,\n  and the side effects in i\u2019s brace-or equal-initializer will not take\n  place. \u2014 end example ]</p>\n</blockquote>\n<p>So, if there is a non-deleting constructor, the brace-or-equal-initializer is ignored, and the constructor in-member initialization prevails. Thus, for array members for which the size is omitted, the expression becomes ill-formed. \u00a712.6.2, item 9, makes it more explicit where we it specified that the r-value initializer expression is omitted if mem-initialization is performed by the constructor. </p>\n<p>Also, the google group dicussion <a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/lzcGWLDHxr4/5z4ZEmCCzLMJ\" rel=\"nofollow\">Yet another inconsitent behavior in C++</a>, further elaborates and makes it more lucid. It extends the idea in explaining that brace-or-equal-initializer is a glorified way of an in-member initialization for cases where the in-member initialization for the member does not exist. As an example</p>\n<pre><code>struct Foo {\n    int i[5] ={1,2,3,4,5};\n    int j;\n    Foo(): j(0) {};\n}\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>struct Foo {\n    int i[5];\n    int j;\n    Foo(): j(0), i{1,2,3,4,5} {};\n}\n</code></pre>\n<p>but now we see that if the array size was omitted, the expression would be ill-formed.</p>\n<p>But then saying that, the compiler could have supported the feature for cases when the member is not initialized by in-member constructor initialization but currently for the sake of uniformity, the standard like many other things, does not support this feature.</p>\n", "OwnerUserId": "977038", "LastEditorUserId": "658087", "LastEditDate": "2015-04-13T02:36:37.833", "Id": "29593683", "Score": "2", "CreationDate": "2015-04-12T19:27:41.633", "LastActivityDate": "2015-04-13T02:36:37.833"}, "29593207": {"CommentCount": "6", "AcceptedAnswerId": "29593334", "CreationDate": "2015-04-12T18:45:26.057", "LastActivityDate": "2015-04-13T02:36:37.833", "PostTypeId": "1", "ViewCount": "1658", "FavoriteCount": "1", "Title": "What is the reason for not being able to deduce array size from initializer-string in member variable?", "Id": "29593207", "Score": "14", "Body": "<p>Consider the code:</p>\n<pre><code>struct Foo\n{\n    const char str[] = \"test\";\n};\n\nint main()\n{\n    Foo foo;\n}\n</code></pre>\n<p>It fails to compile with both g++ and clang++, spitting out essentially</p>\n<blockquote>\n<blockquote>\n<p id=\"so_29593207_29593207_1\"><code>error: array bound cannot be deduced from an in-class initializer</code></p>\n</blockquote>\n</blockquote>\n<p>I understand that this is what the standard probably says, but is there any particular good reason why? Since we have a string literal it seems that the compiler should be able to deduce the size without any problem, similarly to the case when you simply declare an out-of-class <code>const</code> C-like null terminated string.</p>\n", "Tags": "<c++><c++11><c-strings><in-class-initialization>", "OwnerUserId": "3093378", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29593207_29593683_1": {"section_id": 436, "quality": 0.9444444444444444, "length": 17}, "so_29593207_29593683_0": {"section_id": 435, "quality": 0.6538461538461539, "length": 17}, "so_29593207_29593207_0": {"section_id": 336, "quality": 0.5714285714285714, "length": 4}, "so_29593207_29593207_1": {"section_id": 336, "quality": 0.5714285714285714, "length": 4}, "so_29593207_29593683_2": {"section_id": 436, "quality": 0.75, "length": 12}}, "n3337": {"so_29593207_29593683_1": {"section_id": 428, "quality": 0.9444444444444444, "length": 17}, "so_29593207_29593683_0": {"section_id": 427, "quality": 0.9615384615384616, "length": 25}, "so_29593207_29593207_0": {"section_id": 326, "quality": 0.5714285714285714, "length": 4}, "so_29593207_29593207_1": {"section_id": 326, "quality": 0.5714285714285714, "length": 4}, "so_29593207_29593683_2": {"section_id": 428, "quality": 0.75, "length": 12}}, "n4659": {"so_29593207_29593683_1": {"section_id": 455, "quality": 0.8333333333333334, "length": 15}, "so_29593207_29593683_0": {"section_id": 454, "quality": 0.6538461538461539, "length": 17}, "so_29593207_29593207_0": {"section_id": 345, "quality": 0.5714285714285714, "length": 4}, "so_29593207_29593207_1": {"section_id": 345, "quality": 0.5714285714285714, "length": 4}, "so_29593207_29593683_2": {"section_id": 455, "quality": 0.75, "length": 12}}}, "29593336": {"ParentId": "29593207", "CommentCount": "0", "Body": "<p>If the compiler was allowed to support what you described, and the size of <code>str</code> was deduced to <code>5</code>,</p>\n<pre><code>Foo foo = {{\"This is not a test\"}};\n</code></pre>\n<p>will lead to undefined behavior.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "29593336", "Score": "2", "CreationDate": "2015-04-12T18:56:44.713", "LastActivityDate": "2015-04-12T18:56:44.713"}});