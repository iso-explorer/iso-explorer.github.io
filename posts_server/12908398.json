post_cb({"bq_ids": {"n4140": {"so_12908398_12911760_0": {"length": 39, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_12908398_12911760_0": {"length": 39, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_12908398_12911760_0": {"length": 39, "quality": 1.0, "section_id": 8704}}}, "47016233": {"Id": "47016233", "PostTypeId": "2", "Body": "<p>@ecatmur's answer is correct as of its time of writing. In C++17, we now get <code>std::launder</code> (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html\" rel=\"nofollow noreferrer\">wg21 proposal P0137</a>). This was added to make things such as <code>std::optional</code> work with <code>const</code> members amongst other cases. As long as you remember to <code>launder</code> (i.e. clean up) your memory accesses, then this will now work without invoking undefined behaviour.</p>\n", "LastActivityDate": "2017-10-30T13:16:22.487", "Score": "2", "CreationDate": "2017-10-30T13:16:22.487", "ParentId": "12908398", "CommentCount": "2", "OwnerUserId": "2895182"}, "12911760": {"Id": "12911760", "PostTypeId": "2", "Body": "<p>This is illegal, because 3.8p7, which describes using a destructor call and placement new to recreate an object in place, specifies restrictions on the types of data members:</p>\n<blockquote>\n<h3>3.8 Object lifetime [basic.life]</h3>\n<p id=\"so_12908398_12911760_0\">7 - If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object [...] can\n  be used to manipulate the new object, if: [...]<br/>\n  \u2014 the type of the original object [...] does not contain any non-static data member <strong>whose type is const-qualified</strong> or a reference type [...]</p>\n</blockquote>\n<p>So since your object contains a const data member, after the destructor call and placement new the vector's internal <code>data</code> pointer becomes invalid when used to refer to the first element; I think any sensible reading would conclude that the same applies to other elements as well.</p>\n<p>The justification for this is that the optimiser is entitled to assume that const and reference data members are not respectively modified or reseated:</p>\n<pre><code>struct A { const int i; int &amp;j; };\nint foo() {\n    int x = 5;\n    std::vector&lt;A&gt; v{{4, x}};\n    bar(v);                      // opaque\n    return v[0].i + v[0].j;      // optimised to `return 9;`\n}\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-10-16T10:24:15.910", "Score": "14", "CreationDate": "2012-10-16T09:42:12.107", "ParentId": "12908398", "CommentCount": "1", "LastEditDate": "2012-10-16T10:24:15.910", "OwnerUserId": "567292"}, "12908398": {"ViewCount": "1112", "Body": "<p>There are two existing questions about replacing vector elements that are not assignable:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/12906970/c-use-unassignable-objects-in-vector/\">C++ Use Unassignable Objects in Vector</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9853762/how-to-push-back-without-operator-for-const-members\">How to push_back without operator=() for const members?</a></li>\n</ul>\n<p>A typical reason for an object to be non-assignable is that its class definition includes <code>const</code> members and therefore has its <code>operator=</code> deleted.</p>\n<p><code>std::vector</code> requires that its element type be assignable. And indeed, at least using GCC, neither direct assignment (<code>vec[i] = x;</code>), nor a combination of <code>erase()</code> and <code>insert()</code> to replace an element works when the object is not assignable.</p>\n<p>Can a function like the following, which uses <code>vector::data()</code>, direct element destruction, and placement new with the copy constructor, be used to replace the element without causing undefined behaviour?</p>\n<pre><code>template &lt;typename T&gt;\ninline void replace(std::vector&lt;T&gt; &amp;vec, const size_t pos, const T&amp; src)\n{\n  T *p = vec.data() + pos;\n  p-&gt;~T();\n  new (p) T(src);\n}\n</code></pre>\n<p>An example of the function in use is found below. This compiles in GCC 4.7 and appears to work.</p>\n<pre><code>struct A\n{\n  const int _i;\n  A(const int &amp;i):_i(i) {}\n};\n\nint main() {\n  std::vector&lt;A&gt; vec;\n  A c1(1);\n  A c2(2);\n\n  vec.push_back(c1);\n  std::cout &lt;&lt; vec[0]._i &lt;&lt; std::endl;\n\n  /* To replace the element in the vector\n     we cannot use this: */\n  //vec[0] = c2;\n\n  /* Nor this: */\n  //vec.erase(begin(vec));\n  //vec.insert(begin(vec),c2);\n\n  /* But this we can: */\n  replace(vec,0,c2);\n  std::cout &lt;&lt; vec[0]._i &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "12911760", "Title": "Can placement-new and vector::data() be used to replace elements in a vector?", "CreationDate": "2012-10-16T05:58:09.387", "Id": "12908398", "CommentCount": "15", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:17:09.880", "LastEditorUserId": "-1", "LastActivityDate": "2017-10-30T13:16:22.487", "Score": "15", "OwnerUserId": "777186", "Tags": "<c++><vector><c++11><std><placement-new>", "AnswerCount": "2"}});