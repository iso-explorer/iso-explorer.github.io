post_cb({"31552110": {"ParentId": "31550990", "CommentCount": "0", "Body": "<p>There is no difference between copy or direct-initialization for arrays. Both cases are handled identically by the compiler. The analogy you make in the beginning is more of a rule of thumb. In reality, an array cannot be initialized by another array unless it is a string literal. BTW your analogy is not entirely correct. The target array would be direct-initialized with the temporary array:</p>\n<pre><code>const char test2[](test1);\n</code></pre>\n<p>But this still won't compile for the same reason. This is how initialization of a character array works.</p>\n<p>[dcl.init]/p17:</p>\n<blockquote>\n<p id=\"so_31550990_31552110_0\">The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being initialized and the <em>source type</em> is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</p>\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</li>\n<li>If the destination type is a reference type, see 8.5.3.</li>\n<li><strong>If the destination type is an array of characters, an array of <code>char16_t</code>, an array of <code>char32_t</code>, or an array of <code>wchar_t</code>, and the initializer is a string literal, see 8.5.2.</strong></li>\n</ul>\n</blockquote>\n<p>8.5.2:</p>\n<blockquote>\n<p id=\"so_31550990_31552110_1\">An array of narrow character type (3.9.1), <code>char16_t</code> array, <code>char32_t</code> array, or <code>wchar_t</code> array can be initialized by a narrow string literal, <code>char16_t</code> string literal, <code>char32_t</code> string literal, or wide string literal,\n  respectively, or by an appropriately-typed string literal enclosed in braces (2.13.5). Successive characters of the value of the string literal initialize the elements of the array. <em>[ Example:</em></p>\n<pre><code>char msg[] = \"Syntax error on line %s\\n\";\n</code></pre>\n<p id=\"so_31550990_31552110_2\">shows a character array whose members are initialized with a <em>string-literal</em>. [..]</p>\n</blockquote>\n<p>In your other example the string literal decays into a pointer to its first element, with which <code>test3</code> is initialized. This code is invalid in C++11<sup>1</sup>, as the decayed pointer is <code>const char*</code>, but this was a valid conversion in C because string literals were non-const. It was allowed in until C++03 where it was deprecated.</p>\n<hr>\n<p><sub>1: Some compilers still allow the conversion in C++11 as an extension. </sub></p>\n</hr>", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "31552110", "Score": "1", "CreationDate": "2015-07-22T00:53:01.553", "LastActivityDate": "2015-07-22T00:53:01.553"}, "31550990": {"CommentCount": "4", "AcceptedAnswerId": "31552110", "PostTypeId": "1", "LastEditorUserId": "4338785", "CreationDate": "2015-07-21T22:51:59.653", "LastActivityDate": "2015-07-22T00:53:01.553", "LastEditDate": "2015-07-21T23:19:37.527", "ViewCount": "71", "FavoriteCount": "0", "Title": "Would initialising a character array from a string literal be a case of array copy initialisation?", "Id": "31550990", "Score": "1", "Body": "<p>I had always thought it fine to, in my mind, replace any use of a literal with a temporary variable of that literal's type and value. If this <em>is</em> the case, since string literals are of type array of const char would initialising a character array through a string literal not be considered array copy-initialisation? E.g. wouldn't</p>\n<pre><code>const char test1[] = \"hello\";\n</code></pre>\n<p>be somewhat the same as doing...</p>\n<pre><code>const char temp[6] = {'h', 'e', 'l', 'l', 'o', '\\0'};\nconst char test2[] = temp;\n</code></pre>\n<p>which would be forbidden since this is an example of array copy initialisation? How is it that string literals can be used to initialise an array if the literal's type <em>is</em> an array? Maybe somewhat related, if string literals are of type array of const char then how is it the following code seems to compile fine on my system?</p>\n<pre><code>char* test3 = \"hello\";\n</code></pre>\n<p>Since test3 is missing low-level const the compiler misses this unlawful conversion, but it compiles fine anyway? Of course trying to change any element through test3 causes the program to crash. </p>\n", "Tags": "<c++><arrays><string><literals>", "OwnerUserId": "4338785", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31550990_31552110_2": {"section_id": 3314, "quality": 1.0, "length": 7}, "so_31550990_31552110_1": {"section_id": 3314, "quality": 0.926829268292683, "length": 38}, "so_31550990_31552110_0": {"section_id": 3296, "quality": 0.84, "length": 21}}, "n3337": {"so_31550990_31552110_1": {"section_id": 3184, "quality": 0.8292682926829268, "length": 34}, "so_31550990_31552110_2": {"section_id": 3184, "quality": 1.0, "length": 7}, "so_31550990_31552110_0": {"section_id": 3166, "quality": 0.84, "length": 21}}, "n4659": {"so_31550990_31552110_1": {"section_id": 4080, "quality": 0.926829268292683, "length": 38}, "so_31550990_31552110_2": {"section_id": 4080, "quality": 1.0, "length": 7}, "so_31550990_31552110_0": {"section_id": 4058, "quality": 0.84, "length": 21}}}});