post_cb({"bq_ids": {"n4140": {"so_30123338_30124715_0": {"length": 22, "quality": 0.88, "section_id": 584}, "so_30123338_30124715_1": {"length": 16, "quality": 1.0, "section_id": 590}, "so_30123338_30124715_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 589}}, "n3337": {"so_30123338_30124715_0": {"length": 22, "quality": 0.88, "section_id": 574}, "so_30123338_30124715_1": {"length": 16, "quality": 1.0, "section_id": 580}, "so_30123338_30124715_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 579}}, "n4659": {"so_30123338_30124715_0": {"length": 22, "quality": 0.88, "section_id": 607}, "so_30123338_30124715_1": {"length": 16, "quality": 1.0, "section_id": 613}, "so_30123338_30124715_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 612}}}, "30123338": {"ViewCount": "548", "Body": "<p>The expression <code>x-&gt;y</code> requires <code>x</code> to be a pointer to complete class type, or when <code>x</code> is an instance of a class, requires <code>operator-&gt;()</code> defined for <code>x</code>. But when the latter is the case, why <em>not</em> can I use conversion function instead (i.e., convert object <code>x</code> to a pointer)? For example:</p>\n<pre><code>struct A\n{\n    int mi;\n\n    operator A*() { return this; }\n};\n\nint main()\n{\n    A a;\n\n    a[1];  // ok: equivalent to *(a.operator A*() + 1);\n    a-&gt;mi; // ERROR\n}\n</code></pre>\n<p>This gives an error message:</p>\n<p><code>error: base operand of '-&gt;' has non-pointer type 'A'</code></p>\n<p>But the question is, why don't it use <code>a.operator A*()</code> instead, just like <code>a[1]</code> does ?</p>\n", "Title": "Use \"operator T*()\" instead of \"T* operator->()\" for member access", "CreationDate": "2015-05-08T12:01:09.787", "LastActivityDate": "2015-05-08T14:16:15.473", "CommentCount": "8", "LastEditDate": "2015-05-08T13:08:29.517", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "30123338", "Score": "4", "OwnerUserId": "2881005", "Tags": "<c++><syntax><type-conversion>", "AnswerCount": "2"}, "30123586": {"Id": "30123586", "PostTypeId": "2", "Body": "<p>I don't have the standard to hand, perhaps someone can come in and present a better answer after me. However, from the narrative on cppreference.com:</p>\n<blockquote>\n<p id=\"so_30123338_30123586_0\">The left operand of the built-in operator. and operator-&gt; is an expression of complete scalar type T (for operator.) or pointer to complete scalar type T* (for operator-&gt;), which is evaluated before the operator can be called. The right operand is the name of a member object or member function of T or of one of T's base classes, e.g. expr.member, optionally qualified, e.g. expr.name::member, optionally using template disambiguator, e.g. expr.template member.\n  The expression A-&gt;B is exactly equivalent to (*A).B for builtin types. <strong>If a user-defined operator-&gt; is provided, operator-&gt; is called again on the value that it returns, recursively, until the operator-&gt; is reached that returns a plain pointer. After that, builtin semantics are applied to that pointer.</strong></p>\n</blockquote>\n<p>Emphasis is mine.</p>\n<p>If operator -&gt; is to be called recursively on the result of another operator -&gt; (which will have a pointer return type), it strongly implies that operator -&gt; must be called on a pointer type.</p>\n", "LastActivityDate": "2015-05-08T12:12:57.873", "Score": "0", "CreationDate": "2015-05-08T12:12:57.873", "ParentId": "30123338", "CommentCount": "1", "OwnerUserId": "2015579"}, "30124715": {"Id": "30124715", "PostTypeId": "2", "Body": "<p>This is due to the special overload resolution rules for operators in expressions. For most operators, if either operand has a type that is a class or an enumeration, operator functions and built-in operators compete with each other, and overload resolution determines which one is going to be used. This is what happens for <code>a[1]</code>. However, there are some exceptions, and the one that applies to your case is in paragraph [13.3.1.2p3.3] in the standard (emphasis mine in all quotes):</p>\n<blockquote>\n<p id=\"so_30123338_30124715_0\">(3.3) \u2014 For the operator <code>,</code>, the unary operator <code>&amp;</code>, or the operator <code>-&gt;</code>,\n  <em>the built-in candidates set is empty</em>. For all other operators, the\n  built-in candidates include all of the candidate operator functions\n  defined in 13.6 that, compared to the given operator, </p>\n<ul>\n<li>have the same operator name, and </li>\n<li>accept the same number of operands, and </li>\n<li>accept operand types to which the given operand or operands can be converted according to 13.3.3.1, and </li>\n<li>do not have the same parameter-type-list as any non-member candidate that is not a function template specialization.</li>\n</ul>\n</blockquote>\n<p>So, for <code>a[1]</code>, the user-defined conversion is used to get a pointer to which the built-in <code>[]</code> operator can be applied, but for the three exceptions up there, only operator functions are considered first (and there aren't any in this case). Later on, [13.3.1.2p9]:</p>\n<blockquote>\n<p id=\"so_30123338_30124715_1\">If the operator is the operator <code>,</code>, the unary operator <code>&amp;</code>, or the\n  operator <code>-&gt;</code>, <em>and there are no viable functions</em>, then the operator is\n  assumed to be the built-in operator and interpreted according to\n  Clause 5.</p>\n</blockquote>\n<p>In short, for these three operators, the built-in versions are considered only if everything else fails, and then they have to work on the operands without any user-defined conversions. </p>\n<p>As far as I can tell, this is done to avoid confusing or ambiguous behaviour. For example, built-in operators <code>,</code> and <code>&amp;</code> would be viable for (almost) all operands, so overloading them wouldn't work if they would be considered during the normal step of overload resolution. </p>\n<p>Operator <code>-&gt;</code> has an unusual behaviour when overloaded, as it can result in a chain of invocations of overloaded <code>-&gt;</code>, as explained in [note 129]:</p>\n<blockquote>\n<p id=\"so_30123338_30124715_2\">If the value returned by the <code>operator-&gt;</code> function has class type, this\n  may result in selecting and calling another <code>operator-&gt;</code> function. The\n  process repeats until an <code>operator-&gt;</code> function returns a value of\n  non-class type.</p>\n</blockquote>\n<p>I suppose the possibility that you'd start from a class that overloads <code>-&gt;</code>, which returns an object of another class type, which doesn't overload <code>-&gt;</code> but has a user-defined conversion to a pointer type, resulting in a final invocation of the built-in <code>-&gt;</code> was considered a bit too confusing. Restricting this to explicit overloading of <code>-&gt;</code> looks safer.</p>\n<hr>\n<p>All quotes are from N4431, the current working draft, but the relevant parts haven't changed since C++11.</p>\n</hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2015-05-08T14:16:15.473", "Score": "5", "CreationDate": "2015-05-08T13:10:05.793", "ParentId": "30123338", "CommentCount": "1", "LastEditDate": "2015-05-08T14:16:15.473", "OwnerUserId": "4326278"}});