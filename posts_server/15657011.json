post_cb({"15657297": {"Id": "15657297", "PostTypeId": "2", "Body": "<p>A lambda that captures <em>nothing</em> is implicitly convertible to a function pointer with its same argument list and return type. Only capture-less lambdas can do this; if it captures anything, then they can't.</p>\n<p>Unless you're using VS2010, which didn't implement that part of the standard, since it didn't exist yet when they were writing their compiler.</p>\n", "LastActivityDate": "2013-03-27T11:04:51.260", "CommentCount": "0", "CreationDate": "2013-03-27T11:04:51.260", "ParentId": "15657011", "Score": "20", "OwnerUserId": "734069"}, "bq_ids": {"n4140": {"so_15657011_15674512_0": {"length": 38, "quality": 0.95, "section_id": 5965}}, "n3337": {"so_15657011_15674512_0": {"length": 38, "quality": 0.95, "section_id": 5734}}, "n4659": {"so_15657011_15674512_0": {"length": 34, "quality": 0.85, "section_id": 7456}}}, "15657011": {"ViewCount": "3022", "Body": "<p>I have this code:</p>\n<pre><code>void foo(void (*bar)()) {\n    bar();\n}\n\nint main() {\n    foo([] {\n        int x = 2;\n    });\n}\n</code></pre>\n<p>However, I'm worried that this will suffer the same fate as:</p>\n<pre><code>struct X { int i; };\n\nvoid foo(X* x) {\n    x-&gt;i = 2;\n}\n\nint main() {\n    foo(&amp;X());\n}\n</code></pre>\n<p>Which takes the address of a local variable.</p>\n<p>Is the first example completely safe?</p>\n", "Title": "Is it safe to cast a lambda function to a function pointer?", "CreationDate": "2013-03-27T10:48:08.840", "LastActivityDate": "2013-03-28T04:53:11.200", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-03-27T21:31:56.990", "LastEditorUserId": "2132223", "Id": "15657011", "Score": "12", "OwnerUserId": "102441", "Tags": "<c++><c++11><lambda><function-pointers>", "AnswerCount": "3"}, "15674512": {"Id": "15674512", "PostTypeId": "2", "Body": "<p>Yes I believe the first example is safe, regardless of the life-time of all the temporaries created during the evaluation of the full-expression that involves the capture-less lambda-expression.</p>\n<p>Per the working draft (n3485) 5.1.2 [expr.prim.lambda] p6 </p>\n<blockquote>\n<p id=\"so_15657011_15674512_0\">The closure type for a lambda-expression with no lambda-capture has a\n  public non-virtual non-explicit const conversion function to pointer\n  to function having the same parameter and return types as the closure\n  type\u2019s function call operator. The value returned by this conversion\n  function shall be the address of a function that, when invoked, has\n  the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>The above paragraph says nothing about the pointer-to-function's validity expiring after evaluation of the lambda-expression.</p>\n<p>For e.g., I would expect the following to work:</p>\n<pre><code>auto L = []() {\n   return [](int x, int y) { return x + y; };\n};\n\nint foo( int (*sum)(int, int) ) { return sum(3, 4); }\n\n\nint main() {\n  foo( L() );\n}\n</code></pre>\n<p>While implementation details of clang are certainly not the final word on C++ (the standard is), if it makes you feel any better, the way this is implemented in clang is that when the lambda expression is parsed and semantically analyzed a closure-type for the lambda expression is invented, and a static function is added to the class with semantics similar to the function call operator of the lambda. So even though the life-time of the lambda object returned by 'L()' is over within the body of 'foo', the conversion to pointer-to-function returns the address of a static function that is still valid.</p>\n<p>Consider the somewhat analagous case:</p>\n<pre><code>struct B {\n   static int f(int, int) { return 0; }\n   typedef int (*fp_t)(int, int);\n   operator fp_t() const { return &amp;f; }\n};\nint main() {\n  int (*fp)(int, int) = B{};\n  fp(3, 4); // You would expect this to be ok.\n}\n</code></pre>\n<p>I am certainly not a core-c++ expert, but FWIW, this is my interpretation of the letter of the standard, and I feel it is defendable.</p>\n<p>Hope this helps.</p>\n", "LastActivityDate": "2013-03-28T04:53:11.200", "CommentCount": "1", "CreationDate": "2013-03-28T04:53:11.200", "ParentId": "15657011", "Score": "4", "OwnerUserId": "51103"}, "15657965": {"Id": "15657965", "PostTypeId": "2", "Body": "<p>In addition to <em>Nicol</em>'s perfectly correct general answer, I would add some views on your particular fears:</p>\n<blockquote>\n<p id=\"so_15657011_15657965_0\">However, I'm worried that this will suffer the same fate as ..., which\n  takes the address of a local variable.</p>\n</blockquote>\n<p>Of course it does, but this is absolutely no problem when you just call it inside <code>foo</code> (in the same way your struct example is perfectly working), since the surrounding function (<code>main</code> in this case) that defined the local variable/lambda will outlive the called function (<code>foo</code>) anyway. It could only ever be a problem if you would safe that local variable or lambda pointer for later use. So</p>\n<blockquote>\n<p id=\"so_15657011_15657965_1\">Is the first example completely safe?</p>\n</blockquote>\n<p>Yes, it is, as is the second example, too.</p>\n", "LastEditorUserId": "743214", "LastActivityDate": "2013-03-27T11:53:27.567", "Score": "5", "CreationDate": "2013-03-27T11:42:07.153", "ParentId": "15657011", "CommentCount": "5", "OwnerUserId": "743214", "LastEditDate": "2013-03-27T11:53:27.567"}});