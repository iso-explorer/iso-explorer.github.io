post_cb({"34588930": {"ViewCount": "553", "Body": "<p>Admittedly, this question title sounds pretty much exactly the same as the question you neighbour Mike has repeatedly asked. I found quite a few questions worded the same way, but none was what my question is about.</p>\n<p>First of all, I'd like to clarify a few points for the context of this question:</p>\n<p>1, c++ access control works on a class basis rather than instance basis. Therefore, the following code is completely valid.</p>\n<pre><code>class Base\n{\nprotected:\n    int b_;\n\npublic:\n    bool IsEqual(const Base&amp; another) const\n    {\n        return another.b_ == b_; // access another instance's protected member\n    }\n};\n</code></pre>\n<p>2, I completely understand why the following code is NOT valid - another can be a sibling instance.</p>\n<pre><code>class Derived : public Base\n{\npublic:\n    // to correct the problem, change the Base&amp; to Derived&amp;\n    bool IsEqual_Another(const Base&amp; another) const\n    {\n        return another.b_ == b_;\n    }\n};\n</code></pre>\n<p>Now time to unload my real question:</p>\n<p>Assume in the Derived class, I have an array of Base instances. So effectively, Derived IS A Base(IS-A relation), and Derived consists of Base(Composite relation). I read from somewhere that this(refers to the design of both IS-A and Has-A) is a design smell and I should never have a scenario like this in the first place. Well, the mathematical concept of  Fractals, for example, can be modelled by both IS-A and Has-A relations. However, let's disregard the opinion on design for a moment and just focus on the technical problem.</p>\n<pre><code>class Derived : public Base\n{\nprotected:\n    Base base_;\n\npublic:\n    bool IsEqual_Another(const Derived&amp; another) const\n    {\n        return another.b_ == b_;\n    }\n\n    void TestFunc()\n    {\n        int b = base_.b_; // fail here\n    }\n};\n</code></pre>\n<p>The error message has already stated the error very clearly, so there's no need to repeat that in your answer: </p>\n<blockquote>\n<p id=\"so_34588930_34588930_0\">Main.cpp:140:7: error: \u2018int Base::b_\u2019 is protected\n     int b_;\n         ^\n  Main.cpp:162:22: error: within this context\n      int b = base_.b_;</p>\n</blockquote>\n<p>Really, according to the following 2 facts, the code above should work:</p>\n<p>1, C++ access control works on class basis rather than instance basis(therefore, please don't say that I can only access Derived's b_; I can't access a stand alone Base instance's protected members - it's on class basis).</p>\n<p>2, Error message says \"within this context\" - the context is Derived(I was trying to access a Base instance's protected member from within Derived. It's the very feature of a protected member - it should be able to be accessed from within Base or anything that derives from Base.</p>\n<p>So why is the compiler giving me this error?</p>\n", "Title": "C++ protected: fail to access base's protected member from within derived class", "CreationDate": "2016-01-04T10:20:32.990", "LastActivityDate": "2016-01-09T23:23:30.493", "CommentCount": "0", "LastEditDate": "2016-01-05T02:11:21.330", "PostTypeId": "1", "LastEditorUserId": "1190955", "Id": "34588930", "Score": "5", "OwnerUserId": "1190955", "Tags": "<c++><inheritance><access-control><protected>", "AnswerCount": "6"}, "34700131": {"Id": "34700131", "PostTypeId": "2", "Body": "<p>There are a couple of long answers, and quotes from the standard that are correct. I intend on providing a different way of looking at what protected really means that might help understanding.</p>\n<p>When a type inherits from a different type, it gets a <em>base</em> sub-object. The <code>protected</code> keyword means that any derived type can access this particular member within the sub-object that it contains due to the inheritance relationship. The keyword grants access to specific <em>object</em>(s), not to <em>any</em> object of type base.</p>\n", "LastActivityDate": "2016-01-09T23:23:30.493", "CommentCount": "0", "CreationDate": "2016-01-09T23:23:30.493", "ParentId": "34588930", "Score": "0", "OwnerUserId": "36565"}, "34605638": {"Id": "34605638", "PostTypeId": "2", "Body": "<p>Ok, I've been bothered by this wicked thing for a night. Endless discussions and the ambiguity of clause 11.4(as quoted by Yam marcovic)</p>\n<blockquote>\n<p id=\"so_34588930_34605638_0\">\u00a7 11.4 Protected member access</p>\n<p id=\"so_34588930_34605638_1\">[1] An additional access check beyond those described earlier in Clause 11 is applied when a non-static data member or non-static member function is a protected member of its naming class...As described earlier, access to a protected member is granted because the reference occurs in a friend or member of some class C.</p>\n</blockquote>\n<p>have burned me out. I decided to resort to the gcc source code(gcc 4.9.2 in my case) to check how those gcc guys understood the clause 11.4, and what check exactly the C++ standards wants to do and how those checks are supposed to be done.</p>\n<p>In gcc/cp/search.c:</p>\n<pre><code>/* Returns nonzero if it is OK to access DECL through an object\nindicated by BINFO in the context of DERIVED.  */\n\nstatic int protected_accessible_p (tree decl, tree derived, tree binfo)\n{\n  access_kind access;\n\n  /* We're checking this clause from [class.access.base]\n\n   m as a member of N is protected, and the reference occurs in a\n   member or friend of class N, or in a member or friend of a\n   class P derived from N, where m as a member of P is public, private\n   or protected.\n\nHere DERIVED is a possible P, DECL is m and BINFO_TYPE (binfo) is N.  */\n\n  /* If DERIVED isn't derived from N, then it can't be a P.  */\n  if (!DERIVED_FROM_P (BINFO_TYPE (binfo), derived))\n    return 0;\n\n  access = access_in_type (derived, decl);\n\n  /* If m is inaccessible in DERIVED, then it's not a P.  */\n  if (access == ak_none)\n    return 0;\n\n  /* [class.protected]\n\n When a friend or a member function of a derived class references\n a protected nonstatic member of a base class, an access check\n applies in addition to those described earlier in clause\n _class.access_) Except when forming a pointer to member\n (_expr.unary.op_), the access must be through a pointer to,\n reference to, or object of the derived class itself (or any class\n derived from that class) (_expr.ref_).  If the access is to form\n a pointer to member, the nested-name-specifier shall name the\n derived class (or any class derived from that class).  */\n  if (DECL_NONSTATIC_MEMBER_P (decl))\n  {\n  /* We can tell through what the reference is occurring by\n chasing BINFO up to the root.  */\n    tree t = binfo;\n    while (BINFO_INHERITANCE_CHAIN (t))\n    t = BINFO_INHERITANCE_CHAIN (t);\n\n    if (!DERIVED_FROM_P (derived, BINFO_TYPE (t)))\n    return 0;\n  }\n\n  return 1;\n}\n</code></pre>\n<p>The most interesting part is this:</p>\n<pre><code>  if (DECL_NONSTATIC_MEMBER_P (decl))\n  {\n  /* We can tell through what the reference is occurring by\n chasing BINFO up to the root.  */\n    tree t = binfo;\n    while (BINFO_INHERITANCE_CHAIN (t))\n    t = BINFO_INHERITANCE_CHAIN (t);\n\n    if (!DERIVED_FROM_P (derived, BINFO_TYPE (t)))\n    return 0;\n  }\n</code></pre>\n<p>1) derived in the code is the context, which in my case is the Derived class;</p>\n<p>2) binfo in the code represents the instance whose non-static protected member is access, which in my case is base_, Derived's protected data member Base instance;</p>\n<p>3) decl in the code represents base_.b_.</p>\n<p>What gcc did when translating my code in question was:</p>\n<p>1) check if base_.b_ is non-static protected member? yes of course, so enter the if;</p>\n<p>2) climb up the inheritance tree of base_;</p>\n<p>3) figure out what actual type base_ is; of course, it's Base</p>\n<p>4) check if the result in 3) which is Base, derives from Derived. Of course that's a negative. Then return 0 - access denied.</p>\n<p>Apparently, according to gcc's implementation, the \"additional check\" requested by the C++ standard is the type check of the instance through which the protected member gets accessed. Although the C++ standard did not explicitly mention what check should be done, I think gcc's check is the most sensible and plausible one - it's probably the kind of check the C++ standard wants. And then the question really boils down to the rationale for the standard to request an additional check like this. It effectively makes the standard contradict itself. Getting rid of that interesting section(It seems to me that the C++ standard is asking for inconsistency deliberately), the code should work perfectly. In particular, the sibling problem won't occur as it will be filtered by the statement:</p>\n<pre><code>if (!DERIVED_FROM_P(BINFO_TYPE(t), derived))\n      return 0;\n</code></pre>\n<p>Regarding the kind of protection(protected does not work purely on class, but on BOTH class AND instance) mentioned by Peter and the post(by Eric Lippert) he shared, I personally totally agree with that. Unfortunately, by looking at the C++ standard's wording, it doesn't; if we accept that the gcc implementation is an accurate interpretation of the standard, then what the C++ standard really asks for is, a protected member can be accessed by its naming class or anything that derives from the naming class; however, when the protected member is accessed via an object, make sure the owner object's type is the same as the calling context's type. Looks like the standard just wants to make an exception for the clarification point 1 in my original question.</p>\n<p>Last but not least, I'd like to thank Yam marcovic for pointing out clause 11.4. You are the man, although your explanation wasn't quite right - the context does not have to be Base, it can be Base or anything derived from Base. The catch was in the type check of the instance through which the non-static protected member was accessed.</p>\n", "LastActivityDate": "2016-01-05T06:40:39.653", "CommentCount": "5", "CreationDate": "2016-01-05T06:40:39.653", "ParentId": "34588930", "Score": "0", "OwnerUserId": "1190955"}, "bq_ids": {"n4140": {"so_34588930_34591141_2": {"length": 13, "quality": 1.0, "section_id": 6695}, "so_34588930_34591141_3": {"length": 6, "quality": 0.6, "section_id": 5988}, "so_34588930_34605638_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 6695}, "so_34588930_34591141_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6695}, "so_34588930_34589748_2": {"length": 33, "quality": 0.9705882352941176, "section_id": 6695}}, "n3337": {"so_34588930_34591141_2": {"length": 13, "quality": 1.0, "section_id": 6450}, "so_34588930_34591141_3": {"length": 6, "quality": 0.6, "section_id": 5756}, "so_34588930_34589748_2": {"length": 33, "quality": 0.9705882352941176, "section_id": 6450}, "so_34588930_34591141_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6450}, "so_34588930_34605638_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 6450}}, "n4659": {"so_34588930_34591141_2": {"length": 13, "quality": 1.0, "section_id": 8170}, "so_34588930_34591141_3": {"length": 6, "quality": 0.6, "section_id": 7488}, "so_34588930_34589748_2": {"length": 33, "quality": 0.9705882352941176, "section_id": 8170}, "so_34588930_34591141_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 8170}, "so_34588930_34605638_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 8170}}}, "34589641": {"Id": "34589641", "PostTypeId": "2", "Body": "<p>The access rules could in principle have provided an exemption for this special case, where it's known that <code>Base</code> is the <em>most derived class</em>, the dynamic type of the object. But that would have complicated things. C++ is sufficiently complicated.</p>\n<p>A simple workaround is to provide a <code>static</code> <code>protected</code> accessor function up in <code>Base</code>.</p>\n<p>A more hack'ish workaround is to use the infamous type system loophole for member pointers. But I'd go for the <code>static</code> function, if I had to stick with the basic design. Because I think like there's not much point in saving a few keystrokes when the resulting code is both hard to get right in the first place, and hard to understand for maintainers.</p>\n<hr>\n<p>Concrete example:</p>\n<pre><code>class Base\n{\nprotected:\n    int b_;\n\n    static\n    auto b_of( Base&amp; o )\n        -&gt; int&amp;\n    { return o.b; }\n\npublic:\n    auto IsEqual( const Base&amp; another ) const\n        -&gt; bool\n    {\n        return another.b_ == b_; // access another instance's protected member\n    }\n};\n</code></pre>\n</hr>", "LastActivityDate": "2016-01-04T11:01:46.150", "CommentCount": "4", "CreationDate": "2016-01-04T11:01:46.150", "ParentId": "34588930", "Score": "2", "OwnerUserId": "464581"}, "34591141": {"Id": "34591141", "PostTypeId": "2", "Body": "<p>I am just turning my comments into an answer because I find the issue interesting. In particular that in the following minimal example <code>D</code> doesn't compile baffled me:</p>\n<pre><code>class B            { protected: int i;          };\nclass D : public B { int f(B &amp;b){ return b.i; } };\n</code></pre>\n<p>After all, a <code>D</code> is a <code>B</code> and should be able to do all that a <code>B</code> can do (except access <code>B</code>'s private members), shouldn't it?</p>\n<p>Apparently, the language designers of both C++ and C# found that too lenient. Eric Lippert <a href=\"https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/#comment-2844\" rel=\"nofollow\">commented one of his own blog posts</a> saying </p>\n<blockquote>\n<p id=\"so_34588930_34591141_0\">But that\u2019s not the kind of protection we\u2019ve chosen as interesting or valuable. \"Sibling\" classes do <em>not</em> get to be friendly with each other because otherwise protection is very little protection.</p>\n</blockquote>\n<p><strong>EDIT:</strong><br>\nBecause there seems to be some confusion about the actual rule laid forth in 11.4 I'll parse it and illustrate the basic idea with a short example.</br></p>\n<ol>\n<li><p>The purpose of the section is laid out, and what it applies to (non-static members). </p>\n<blockquote>\n<p id=\"so_34588930_34591141_1\">An additional access check beyond those described earlier in Clause 11\n  is applied when a non-static data member or non-static member function\n  is a protected member of its naming class (11.2)</p>\n</blockquote>\n<p>The naming class in the example below is <code>B</code>.</p></li>\n<li><p>Context is established by summarising the chapter so far (it defined access rules for protected members). Additionally a name for a \"class C\" is introduced: Our code is supposed to reside inside a member or friend function of C, i.e. has C's access rights.</p>\n<blockquote>\n<p id=\"so_34588930_34591141_2\">As described earlier, access to a protected member is\n  granted because\n  the reference occurs in a friend or member of some \n  <strong>class C.</strong></p>\n</blockquote>\n<p>\"Class C\" is also class <code>C</code> in the example below.</p></li>\n<li><p>Only now the actual check is defined. The first part deals with pointers to members, which we ignore here. The second part concerns your everyday accessing a member of an object, which logically <em>\"involve a (possibly implicit) <strong>object expression</strong>\"</em>.<br>\nIt's just the last sentence which describes the \"additional check\" this whole section was for: </br></p>\n<blockquote>\n<p id=\"so_34588930_34591141_3\"><strong>In this case, the class of the object expression</strong> \n  [through which the member is accessed -pas] \n  <strong>shall be C or a class derived from C.</strong></p>\n</blockquote>\n<p>The \"object expression\" can be things like a variable, \na return value of a function, or a dereferenced pointer. \nThe \"class of the object expression\" is a compile time \nproperty, not a run time property; access through one \nand the same object may be denied or granted depending \non the type of the expression used to access the member. </p></li>\n</ol>\n<p>This code snippet demonstrates that.</p>\n<pre><code>class B { protected: int b; };\n\nclass C: public B \n{\n    void f()\n    {\n        // Ok. The expression of *this is C (C has an\n        // inherited member b which is accessible \n        // because it is not declared private in its\n        // naming class B).\n        this-&gt;b = 1;    \n\n        B *pb = this;\n\n        // Not ok -- the compile time \n        // type of the expression *pb is B.\n        // It is not \"C or a class derived from C\"\n        // as mandated by 11.4 in the 2011 standard.\n        pb-&gt;b = 1;\n    }\n};\n</code></pre>\n<hr>\n<p>I initially wondered about this rule and assume the following rationale:</p>\n<p>The issue at hand is data ownership and authority.</p>\n<p>Without code <em>inside</em> <code>B</code> explicitly providing access (by making <code>C</code> a friend or by something like Alf's static accessor) no other classes except those who \"own\" the data are allowed to access it. This prevents gaining illicit access to the protected members of a class by simply defining a sibling and modifying <em>objects of the original derived class</em> through the new and before unknown sibling. Stroustrup speaks of \"subtle errors\" in this context in the TCPPL.</p>\n<p>While it would be safe to access (different) objects of the original base class from a derived class' code, the rule is simply concerned with <em>expressions</em> (a compile time property) and not objects (a run time property). While static code analysis may show that an expression of some type <code>Base</code> actually never refers to a sibling, this is not even attempted, similar to the rules concerning aliasing. (Maybe that is what Alf meant in his post.)</p>\n<p>I imagine the underlying design principle is the following: Guaranteeing ownership and authority over data gives a class the guarantee that it can maintain invariants related to the data (\"after changing protected <code>a</code> always also change <code>b</code>\"). Providing the possibility to change a protected property from by a sibling may break the invariant -- a sibling does not know the details of its sibling's implementation choices (which may have been written in a galaxy far, far away). A simple example would be a <code>Tetragon</code> base class with protected <code>width</code> and <code>height</code> data members plus trivial public virtual accessors. Two siblings derive from it, <code>Parallelogram</code> and <code>Square</code>. <code>Square</code>'s accessors are overridden to always also set the other dimension in order to preserve a square's invariant of equally long sides, or they only just use one of the two. Now if a <code>Parallelogram</code> could set a <code>Square</code>'s <code>width</code> or <code>height</code> directly through a <code>Tertragon</code> reference they would break that invariant.</p>\n</hr>", "LastEditorUserId": "3150802", "LastActivityDate": "2016-01-07T10:06:44.137", "Score": "2", "CreationDate": "2016-01-04T12:26:13.663", "ParentId": "34588930", "CommentCount": "3", "OwnerUserId": "3150802", "LastEditDate": "2016-01-07T10:06:44.137"}, "34589131": {"Id": "34589131", "PostTypeId": "2", "Body": "<p>This has nothing to do with <code>bases_</code> being protected in <code>Derived</code>, it is all about <code>b_</code> being protected in <code>Base</code>.</p>\n<p>As you have already stated, <code>Derived</code> can only access protected members of its base class, not of any other <code>Base</code>objects. Not even if they are members of <code>Derived</code>.</p>\n<p>If you <em>really</em> need access, you can make <code>Derived</code> a friend on <code>Base</code>.</p>\n", "LastActivityDate": "2016-01-04T10:32:07.500", "CommentCount": "3", "CreationDate": "2016-01-04T10:32:07.500", "ParentId": "34588930", "Score": "1", "OwnerUserId": "597607"}, "34589748": {"Id": "34589748", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34588930_34589748_0\">2, Error message says \"within this context\" - the context is Derived(I was trying to access a Base instance's protected member from within Derived. It's the very feature of a protected member- it should be able to be accessed from within Base or anything that derives from Base.</p>\n</blockquote>\n<p>Okay, had to go to the standard for this one.</p>\n<p>So you're asking, \"Why isn't it possible?\" The answer: Because of how the standard <em>really</em> defines protected member access:</p>\n<blockquote>\n<p id=\"so_34588930_34589748_1\">\u00a7 11.4\n  Protected member access</p>\n<p id=\"so_34588930_34589748_2\">[1]\n  An additional access check beyond those described earlier in Clause 11 is applied when a non-static data\n  member or non-static member function is a protected member of its naming class...As described\n  earlier, access to a protected member is granted because <strong>the reference occurs in a friend or member of some class C</strong>.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>So let's go over your examples to see what's what.</p>\n<pre><code>class Base\n{\nprotected:\n    int b_;\n\npublic:\n    bool IsEqual(const Base&amp; another) const\n    {\n        return another.b_ == b_; // access another instance's protected member\n    }\n};\n</code></pre>\n<p>No problem. <code>another.b_</code> is <code>Base::b_</code>, and we're accessing it from a member function <code>Base::IsEqual(const Base&amp;) const</code>.</p>\n<pre><code>class Derived : public Base\n{\npublic:\n    // to correct the problem, change the Base&amp; to Derived&amp;\n    bool IsEqual_Another(const Base&amp; another) const\n    {\n        return another.b_ == b_;\n    }\n};\n</code></pre>\n<p>Here, we're accessing <code>Base::b_</code> again, but our context is a member function <code>Derived::IsEqual_Another(const Base&amp;) const</code>, which isn't a member of <code>Base</code>. So no go.</p>\n<p>Now for the alleged culprit.</p>\n<pre><code>class Derived : public Base\n{\nprotected:\n    Base bases_[5];\n\npublic:\n    bool IsEqual_Another(const Derived&amp; another) const\n    {\n        return another.b_ == b_;\n    }\n\n    void TestFunc()\n    {\n        int b = bases_[0].b_; // fail here\n    }\n};\n</code></pre>\n<p><code>bases_[0].b_</code> is accessing the protected <code>Base::b_</code>, inside the context of <code>Derived::TestFunc()</code>, which isn't a member (or friend...) of <code>Base</code>.</p>\n<p>So looks like the compiler is acting in accordance with the rules.</p>\n", "LastEditorUserId": "602372", "LastActivityDate": "2016-01-04T11:27:14.383", "Score": "2", "CreationDate": "2016-01-04T11:08:10.173", "ParentId": "34588930", "CommentCount": "20", "OwnerUserId": "602372", "LastEditDate": "2016-01-04T11:27:14.383"}});