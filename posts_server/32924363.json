post_cb({"32924957": {"ParentId": "32924363", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Summing up, the guarantees only refer to the range of possible values (minValue, maxValue) specified by the enum.</p>\n<p>Enums without fixed values have the enumerator value guaranteed by the standard (\u00a7 7.2/2)</p>\n<p>An enum is guaranteed to hold any value in the range between it's smallest defined value and it's largest, and is unspecified on how it handles numbers outside the range. All the operations are made on its underlying type </p>\n<p>Also from \u00a75.2.9/10 we have rules about how to convert integrals to enum:</p>\n<blockquote>\n<p id=\"so_32924363_32924957_0\">A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the\n  original value is within the range of the enumeration values (7.2).\n  Otherwise, the resulting value is unspecified (and might not be in\n  that range).</p>\n</blockquote>\n<p>So converting an integer to a enum value outside the range gives unspecified value. This is a general rule, regardless if enumerators value have been specified in the declaration or not. However the range is given by the underlying type, which always can represent the xero, so it's not undefined (See <a href=\"https://stackoverflow.com/a/30153809/2893839\">relevant answer</a>).</p>\n<p>See <a href=\"https://stackoverflow.com/questions/7676817/forcing-improper-enum-values\">Link to relevant question</a></p>\n", "OwnerUserId": "2893839", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:23.407", "Id": "32924957", "Score": "0", "CreationDate": "2015-10-03T16:40:40.303", "LastActivityDate": "2015-10-03T16:40:40.303"}, "32925132": {"ParentId": "32924363", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_32924363_32925132_0\">Are there different rules and/or guarantees between enums with fixed value enumerators vs those without them?</p>\n</blockquote>\n<p>None.  You should consider enums nothing more than type safe (type-safety only guaranteed in c++11 enum classes) integers.</p>\n", "OwnerUserId": "3517622", "PostTypeId": "2", "Id": "32925132", "Score": "0", "CreationDate": "2015-10-03T16:59:36.150", "LastActivityDate": "2015-10-03T16:59:36.150"}, "32924363": {"CommentCount": "3", "ViewCount": "110", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-10-03T15:37:44.723", "LastActivityDate": "2015-10-03T17:05:09.093", "Title": "Zero initialization of enum with fixed value enumerators", "AcceptedAnswerId": "32925191", "LastEditDate": "2017-05-23T12:14:31.463", "Id": "32924363", "Score": "1", "Body": "<p>Suppose the following simple example:</p>\n<pre><code>enum class Test { One = 1, Two = 2, Three = 3 };\n\nint main()\n{\n    Test t{};\n}\n</code></pre>\n<p>The code above seems to compile fine on Clang, GCC, and MSVC. My concern is while the <em>underlying</em> integral type used to represent the numeric range of the individual enumerators is perfectly capable of representing <code>0</code> as a value, that 0 value does not map to the constants themselves. It's this differentiation that is confusing (the integral type range vs the range of the enumeration's enumerators). <code>t</code>'s value seems to be \"well defined\" from the perspective of an <code>int</code>, but it is not well defined in the sense that as a scalar, it does not map to one of the enums constants.</p>\n<p>My searching resulted in <a href=\"https://stackoverflow.com/questions/27935026/the-behavior-of-value-initializing-an-enum\">this SO post</a>, however the top answer was <em>very</em> technical and I didn't quite understand. I'm posing the question here from a slightly different angle, to see if I can get an answer that makes a little more sense to me.</p>\n<p>Are there different rules and/or guarantees between enums with fixed value enumerators vs those without them? The code above makes perfect sense for enums with enumerators that have not been explicitly assigned, it's the fixed value case that is confusing.</p>\n", "Tags": "<c++><c++11><enums>", "OwnerUserId": "157971", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32924363_32924957_0": {"section_id": 6036, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_32924363_32924957_0": {"section_id": 5804, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_32924363_32924957_0": {"section_id": 7535, "quality": 0.8333333333333334, "length": 20}}}, "32925191": {"ParentId": "32924363", "CommentCount": "1", "Body": "<p>The enumerators within an enumeration are used for three distinct purposes:</p>\n<ol>\n<li>They define <em>names for values</em> of this enumeration type.</li>\n<li>They shape the <em>range of valid values</em> for objects of the enumeration type, if the underlying type is not fixed.</li>\n<li>They influence the <em>underlying type</em> of the enumeration, if it is not fixed.</li>\n</ol>\n<p>The range of valid values can include values for which there are no enumerators. This can of course be confusing, e.g. when you write a switch-statement that shall cover all values of the enumeration.</p>\n<hr>\n<p>I'm just guessing, but the reason why there's not a 1-to-1 mapping between enumerators and valid enumeration values might be compatibility to C. In C, the enumerators have type <code>int</code>, hence the representation of the enumerators must be the <code>int</code> the enumerator stands for. You therefore can't map an enumerator <code>A = 1</code> to a value <code>0</code>. <code>enum</code>s might have evolved from integer <code>#define</code>s.</p>\n<p>Now, if you convert from <code>int</code> to the enumeration type, you shouldn't require a complicated program logic \u00e0 la <code>switch</code> to map the enumerator values (<code>int</code>s) to the values stored in an object of the enumeration type. In fact, C requires that the enumeration type is <em>compatible</em> to some integer type. This implies that the representation of <em>values</em> of the enumeration type must be the same as the representation of the compatible integer type. As an example:</p>\n<pre><code>enum my_enum\n{\n    ENUMERATOR = 42\n};\n\nenum my_enum x = ENUMERATOR;\n</code></pre>\n<p>If <code>my_enum</code> is compatible to <code>int</code>, then the representation of the value stored in <code>x</code> must be the same as the representation of <code>42</code>.</p>\n<p>The <em>compatibility</em> requirement binds types so closely together that they can, for all I know, be used interchangeably:</p>\n<pre><code>enum my_enum\n{\n    ENUMERATOR_A = 0,\n    ENUMERATOR_B = ~0\n};\n\nvoid foo(int);\n\nint main() {\n    foo(0);\n}\n\nvoid foo(enum my_enum x) {}\n</code></pre>\n<p>This is not considered an error by clang nor gcc, which use <code>int</code> as the compatible type for <code>my_enum</code>.</p>\n<p>Because enumeration types are essentially typedefs for integer types, there can be values for which there are no enumerators.</p>\n<hr>\n<p>C++ contains some hints about this relation between enumerations and integral types, such as [expr.static.cast] and [conv.integral] talking about <em>not changing the value when converting between integral and enumeration types</em>. However, I'm not sure if this is in and of itself meaningful, since I'm not sure how to observe that change except through a round-trip conversion.</p>\n<p>There is no exception in C++'s <em>strict aliasing rule</em> between enumeration types and their underlying types.</p>\n<hr>\n<p>Note that in C, we can exploit this relation to conveniently use bit-flags:</p>\n<pre><code>enum FLAGS\n{\n    FLAG_A = 1,\n    FLAG_B = 2\n};\n\nvoid foo(enum FLAGS x);\n\nint main() { foo(FLAG_A | FLAG_B); }\n</code></pre>\n<p>In C++, this is a type error: <code>FLAG_A | FLAG_B</code> is an <code>int</code> and not implicitly convertible to <code>FLAGS</code>. Although one can write an explicit cast such as <code>foo( static_cast&lt;FLAGS&gt;(FLAG_A | FLAG_B) )</code>, there are more convenient ways to write bit-sets in C++.</p>\n<hr>\n<p>The <em>zero-initialization</em> part of the question probably is quite relevant as well: It is quite useful if it can be achieved by either a single <code>memset</code> or for static data, placing it in the <code>.bss</code> section. Therefore, having a value that is all bits 0 in types is quite useful.</p>\n<p>One has to add though that <em>pointers-to-data-members</em> often have a null pointer value that is <strong>not</strong> represented by all bits 0, so it is not unheard of to break this useful property.</p>\n</hr></hr></hr></hr>", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "32925191", "Score": "1", "CreationDate": "2015-10-03T17:05:09.093", "LastActivityDate": "2015-10-03T17:05:09.093"}});