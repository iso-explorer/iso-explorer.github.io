post_cb({"bq_ids": {"n4140": {"so_43001428_43001428_0": {"length": 19, "quality": 0.6785714285714286, "section_id": 5449}, "so_43001428_43001428_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 5448}}, "n3337": {"so_43001428_43001428_1": {"length": 13, "quality": 0.5909090909090909, "section_id": 5242}, "so_43001428_43001428_0": {"length": 17, "quality": 0.6071428571428571, "section_id": 5243}}}, "43001428": {"ViewCount": "91", "Body": "<p>Is this code Standard-Compliant? </p>\n<pre><code>class Example {\n    public:\n        static int x;\n};\n\ndecltype(auto) Example::x = 1;\n\nint main(){ return 0; }\n</code></pre>\n<p>Clang 3.9.1 compiles it successfully, but gcc 6.3.0 fails: <code>error: conflicting declaration 'decltype(auto) Example::x'</code></p>\n<p>C++14 Standard (ISO/IEC 14882:2014), Section 7.1.6.4, Paragraph 5 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_43001428_43001428_0\">A placeholder type can also be used in declaring a variable in the <em>condition</em> of a selection statement (6.4) or an iteration statement (6.5), in the <em>type-specifier-seq</em> in the <em>new-type-id</em> or <em>type-id</em> of a <em>new-expression</em> (5.3.4), in a <em>for-range-declaration</em>, and <strong>in declaring a static data member with a <em>brace-or-equal-initializer</em> that appears WITHIN the <em>member-specification</em> of a class definition (9.4.2)</strong>.</p>\n</blockquote>\n<p>The (re)declaration is not strictly <em>within the member-specification of a class definition</em>, but I don't see any good reason to forbid it. Furthermore, it can be seen also as a (re)declaration of a variable (static data member variable) in namespace scope, which is allowed in Paragraph 4:</p>\n<blockquote>\n<p id=\"so_43001428_43001428_1\">The type of a variable declared using auto or decltype(auto) is deduced from its initializer. This use is allowed when declaring variables in a block (6.3), <strong>in namespace scope (3.3.6)</strong>, and in a for-init-statement (6.5.3).</p>\n</blockquote>\n<p>There is a similar C++11 post: <a href=\"https://stackoverflow.com/questions/14285198/why-doesnt-the-c11-auto-keyword-work-for-static-members\">Why doesn't the C++11 'auto' keyword work for static members?</a>\nHowever, there is only one answer, and then a debate starts in the comments. Besides, clang is usually more reliable in this cases, and according to that answer clang would be wrong and gcc would be correct.</p>\n", "Title": "Declaring a Static Data Member with decltype(auto) in C++14", "CreationDate": "2017-03-24T13:58:50.923", "LastActivityDate": "2017-03-24T14:22:20.240", "CommentCount": "2", "LastEditDate": "2017-05-23T12:02:05.063", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "43001428", "Score": "1", "OwnerUserId": "7325235", "Tags": "<c++><c++14><static-members><auto><decltype>", "AnswerCount": "0"}});