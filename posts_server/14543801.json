post_cb({"bq_ids": {"n4140": {"so_14543801_14543811_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 6049}}, "n3337": {"so_14543801_14543811_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 5817}}, "n4659": {"so_14543801_14543811_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 7548}}}, "14543801": {"ViewCount": "4139", "Body": "<p>I want to have a class that would be able to keep as its fields a pointer to a function and a pointer to a structure holding is arguments. The interface of that object would be a method call() taking no arguments but passing saved arguments to the above mentioned function. A family of such classes for different arguments types and counts would have a common abstract ancestor with call being virtual.</p>\n<p>As for now I have the following code which works, though adding the -pedantic option to g++ yields errors:</p>\n<pre><code>class Function {\n    protected:\n    void *data;\n    void *function;\n    public:\n    virtual void call() = 0;\n};\n\nclass SingleArgumentFunction : public Function {\n    public:\n    SingleArgumentFunction( void (*f)(int), int i ) {\n        int *icpy = new int(i);\n        function = (void*) f;\n        data = (void*) icpy;\n    }\n    ~SingleArgumentFunction() { delete (int*)data; }\n    inline void call() {\n        ( *((void (*)(int))function) )( *(int*)data );\n    }\n};\n</code></pre>\n<p>The error I get is as the title says:</p>\n<pre><code>warning: ISO C++ forbids casting between pointer-to-function and pointer-to-object\n</code></pre>\n<p>How to handle that?</p>\n", "AcceptedAnswerId": "14543811", "Title": "ISO C++ forbids casting between pointer-to-function and pointer-to-object", "CreationDate": "2013-01-27T02:19:15.297", "Id": "14543801", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-03-07T14:18:57.537", "Score": "4", "OwnerUserId": "1068618", "Tags": "<c++><function-pointers>", "AnswerCount": "2"}, "19093056": {"Id": "19093056", "PostTypeId": "2", "Body": "<p>If you are forced to use an API that wants a function pointer as <code>void*</code>, you can prefix the statement which generates the warning with <code>__extension__</code> to silence that warning. Since it's gcc-specific, it's best to guard that word, i.e.:</p>\n<pre><code>#ifdef __GNUC__\n__extension__\n#endif\nthe_statement_that_includes_the_cast;\n</code></pre>\n<p>From <a href=\"http://trac.osgeo.org/qgis/ticket/234\" rel=\"nofollow\">http://trac.osgeo.org/qgis/ticket/234</a>.</p>\n", "LastActivityDate": "2013-09-30T11:26:50.300", "CommentCount": "0", "CreationDate": "2013-09-30T11:26:50.300", "ParentId": "14543801", "Score": "1", "OwnerUserId": "242762"}, "14543811": {"Id": "14543811", "PostTypeId": "2", "Body": "<p>Don't cast <em>pointer-to-function</em> to <em>pointer-to-object</em>, they are not guaranteed to have the same size. You will be able to work around this issue by using a <code>void(*)()</code> function pointer instead.</p>\n<p><em>C99 [6.2.5/27]:</em></p>\n<blockquote>\n<p id=\"so_14543801_14543811_0\">A pointer to void shall have the same representation and alignment requirements as a pointer to a character type. Similarly, pointers to quali\ufb01ed or unquali\ufb01ed versions of compatible types shall have the same representation and alignment requirements. All pointers to structure types shall have the same representation and alignment requirements as each other. All pointers to union types shall have the same representation and alignment requirements as each other. Pointers to other types need not have the same representation or alignment requirements.</p>\n</blockquote>\n<p><em>C99 [6.3.2.3/8]:</em></p>\n<blockquote>\n<p id=\"so_14543801_14543811_1\">A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer.</p>\n</blockquote>\n<p>References taken from <a href=\"https://stackoverflow.com/a/3941867/927034\">this other SO answer</a>.</p>\n<hr>\n<p>By the way, it seems that you are trying to recreate <code>std::function+std::bind</code>.</p>\n<pre><code>std::function&lt; void() &gt; f;\nf = std::bind( &amp;some_function_that_takes_an_int, 42 );\n\nf(); // look ma! no arguments\n</code></pre>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-27T03:04:47.120", "Score": "8", "CreationDate": "2013-01-27T02:21:12.490", "ParentId": "14543801", "CommentCount": "6", "LastEditDate": "2017-05-23T10:29:14.653", "OwnerUserId": "927034"}});