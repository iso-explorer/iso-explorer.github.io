post_cb({"bq_ids": {"n4140": {"so_2096571_2097179_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 955}}, "n3337": {"so_2096571_2097179_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 943}}}, "2099446": {"PostTypeId": "2", "Body": "<p>A pedagogic (and thus simplified) version of a container called \"Vec\" is discussed in Chapter 11 of the wonderful (introductory) book \"Accelerated C++\". What they describe is a stripped-down version of std::vector, but I think it is still worth noting that:</p>\n<p>1) they implement their template class in terms of an array,</p>\n<p>2) they discuss push_back in terms of the trick (mentioned above) of allocating more storage than is needed, and coming back for more when they run out, and</p>\n<p>3) they use allocator<code>&lt;T</code>&gt; for memory management. The new operator is not flexible enough in this context, since it both allocates and initializes memory.</p>\n<p>I repeat, though, that this doesn't mean that actual implementations out there are this simple. But since \"Accelerated C++\" is quite widespread, those interested can find in the relevant chapter one way vector-like objects can be created, copied, assigned, and destroyed.</p>\n<p>EDIT: On a related note, I just found the following blog post by Herb Sutter in which he comments on an earlier blog post by Andrew Koenig, regarding whether or not one should be worried about vector elements being contiguous in memory: <a href=\"http://herbsutter.wordpress.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/\" rel=\"nofollow noreferrer\">\nCringe not: Vectors are guaranteed to be contiguous</a>.</p>\n", "LastActivityDate": "2010-01-20T07:24:13.977", "LastEditorUserId": "254628", "Id": "2099446", "CommentCount": "0", "CreationDate": "2010-01-20T06:29:15.180", "ParentId": "2096571", "Score": "2", "OwnerUserId": "254628", "LastEditDate": "2010-01-20T07:24:13.977"}, "2097573": {"PostTypeId": "2", "Body": "<p>There's no actual array at all in any decent implementation (if there is, you can't use any object in it without a default constructor), but just raw memory that gets allocated. It gets allocated in a manner that's usually along the lines of doubling every time you need to expand it.</p>\n<p>The vector then uses in place allocation to call the constructors of the class in the proper location once each slot actually gets used actually used.</p>\n<p>When there is expansion it will try to reallocate in place (but this is a bit silly and doesn't normally work, think windows 98 heap compaction) but usually will end up making a whole new allocation and copying over.</p>\n<p>A standard stl vector is always all together, but not all implementations work like that (I know, having written some of them). Probably none are exactly a linked list, though, either.</p>\n", "LastActivityDate": "2010-01-19T22:15:42.397", "Id": "2097573", "CommentCount": "1", "CreationDate": "2010-01-19T22:15:42.397", "ParentId": "2096571", "Score": "1", "OwnerUserId": "204739"}, "2096974": {"PostTypeId": "2", "Body": "<p>I believe it is the third option. It can't just use <code>new T[n]</code> because then it would actually have to construct as many objects as it allocates. E.g</p>\n<pre><code>std::vector&lt;Foo&gt; v;\nv.reserve(10);\n</code></pre>\n<p>If your implementation simply ended up doing <code>new Foo[10]</code> then you'd just have constructed 10 instances of Foo.</p>\n<p>Instead it uses its allocator to allocate and deallocate raw memory (without constructing objects), and as needed (for example, when you actually <code>push_back</code> objects) places copy-constructed instances into correct memory locations in its reserve using <em>placement new</em> and removes them with <em>explicit calls to the destructor</em> (something you'd only do in combination with placement new). The allocator class provides following methods for that which I presume vector's implementations use</p>\n<pre><code> void construct(pointer p, const_reference val);\n\n  Returns:\n    new((void *)p) T(val)\n\n  void destroy(pointer p);\n\n  Returns:\n    ((T*)p)-&gt;~T()\n</code></pre>\n<p>(The \"returns\" probably should read \"effect\" or similar.)</p>\n<p>More about <a href=\"http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10\" rel=\"noreferrer\">placement new</a></p>\n", "LastActivityDate": "2010-01-19T21:06:07.890", "LastEditorUserId": "155693", "Id": "2096974", "CommentCount": "2", "CreationDate": "2010-01-19T20:52:46.767", "ParentId": "2096571", "Score": "22", "OwnerUserId": "155693", "LastEditDate": "2010-01-19T21:06:07.890"}, "2096589": {"PostTypeId": "2", "Body": "<p>I believe the STL uses option #2 (or something similar) because a std::vector&lt;&gt; is guaranteed to store the elements in contiguous memory. </p>\n<p>If you're looking for a memory structure that doesn't need to use contiguous memory, look at std::deque. </p>\n", "LastActivityDate": "2010-01-19T19:53:44.750", "Id": "2096589", "CommentCount": "1", "CreationDate": "2010-01-19T19:53:44.750", "ParentId": "2096571", "Score": "1", "OwnerUserId": "14069"}, "2098354": {"PostTypeId": "2", "Body": "<p>From what i have read in books and from the functionality of reserve and and the requirement that elements of vectors be contiguous, This is what i think could be a possible way to implement Vector.</p>\n<p>1) Elements of vectors be contiguous , supporting O(1) random access and vectors should be compatible with C arrays. This just implies there are no linked lists. </p>\n<p>2) When you call reserve it reserves additional memory. But reserve does call</p>\n<pre><code>new T[newSize]\n</code></pre>\n<p>to reserve more memory. Otherwise it will call default constructor. As uncleben explained whenever reserve is called the vector class just allocates more uninitialized memory usin its allocator (if required) and copy construct new objects into that memory using placement new(if more memory has been allocated)</p>\n<p>3) Initially vector has some default capacity. for which uninitialized memory is allocated when the vector object is constructed</p>\n<p>4) push_back copy constructs the object into the first available location. If required more memory has to be allocated in similar manner as reserve</p>\n", "LastActivityDate": "2010-01-20T01:17:47.843", "LastEditorUserId": "253699", "Id": "2098354", "CommentCount": "0", "CreationDate": "2010-01-20T00:56:21.513", "ParentId": "2096571", "Score": "0", "OwnerUserId": "253699", "LastEditDate": "2010-01-20T01:17:47.843"}, "2096610": {"PostTypeId": "2", "Body": "<p>They use a dynamically allocated array that is regrown as needed. It is necessary to use something like an array so that the elements are contiguous in memory which is guaranteed by the standard. </p>\n<p>Incidentally, one common way of regrowing an array is to double the size as needed. This is so that if you are inserting <code>n</code> items at most only <code>O(log n)</code> regrowths are performed and at most <code>O(n)</code> space is wasted.</p>\n<p>You can read one implementation for yourself at <a href=\"http://www.sgi.com/tech/stl/stl_vector.h\" rel=\"noreferrer\">SGI</a> (where STL was originally conceived).</p>\n", "LastActivityDate": "2010-01-19T19:56:14.917", "Id": "2096610", "CommentCount": "0", "CreationDate": "2010-01-19T19:56:14.917", "ParentId": "2096571", "Score": "16", "OwnerUserId": "45914"}, "2097179": {"PostTypeId": "2", "Body": "<p>Section 23.2.4, \u00b61 of the standard requires that arithmetic on pointers into a vector work the same as with pointers into an array.</p>\n<blockquote>\n<p id=\"so_2096571_2097179_0\">The elements of a vector are stored\n  contiguously, meaning that if v is a\n  vector where T is some\n  type other than bool, then it obeys\n  the identity &amp;v[n] == &amp;v[0] + n for\n  all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n<p>This guarantees that the storage is in an array. Of course, if you resize the array to be bigger, it might get moved in memory.</p>\n", "LastActivityDate": "2010-01-19T21:21:29.137", "Id": "2097179", "CommentCount": "0", "CreationDate": "2010-01-19T21:21:29.137", "ParentId": "2096571", "Score": "2", "OwnerUserId": "153285"}, "2096581": {"PostTypeId": "2", "Body": "<p>It's implemented by using an underlying array.</p>\n<p>It's not possible to implement a <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"noreferrer\"><code>std::vector&lt;T&gt;</code></a> with a linked list because the standard guarantees the elements in the list will be held in contiguous memory. </p>\n", "LastEditorDisplayName": "user283145", "LastActivityDate": "2013-04-26T16:59:43.100", "Id": "2096581", "CommentCount": "9", "CreationDate": "2010-01-19T19:52:40.760", "ParentId": "2096571", "Score": "39", "OwnerUserId": "23283", "LastEditDate": "2013-04-26T16:59:43.100"}, "2096584": {"PostTypeId": "2", "Body": "<p>There is no one way it is implemented. Different implementations can be different, so long as the preserve the semantics and satisfy the requirements.</p>\n<p>At any given time, there has to be a primitive array of T to satisfy the requirements of contiguity. However, how it is allocated, grown, shrunk, and freed is up to the implementor.</p>\n<p>You can read the implementation for yourself, it's right there in the header file.</p>\n<p>I can tell you that <em>no</em> implementations use linked lists. They aren't consistent with the requirements of the standard.</p>\n", "LastActivityDate": "2010-01-19T21:20:24.287", "LastEditorUserId": "131433", "Id": "2096584", "CommentCount": "7", "CreationDate": "2010-01-19T19:53:14.503", "ParentId": "2096571", "Score": "2", "OwnerUserId": "131433", "LastEditDate": "2010-01-19T21:20:24.287"}, "2096571": {"ViewCount": "24365", "Body": "<p>I have been using <code>std::vector</code> a lot, and recently I asked myself this question: \"How is <code>std::vector</code> implemented?\"</p>\n<p>I had two alternatives:</p>\n<p>1) Linked list, and then making the API feel like random access (i.e. overloading <code>operator[]</code>).</p>\n<p>2) Using <code>new</code>, e.g. <code>Foo* temp = new Foo[20]</code>: I believe they do something like this, but then it raises one more question. Do they always allocate a maximum (<code>uint32_t</code>) storage to give random access? (This is inefficient in terms of memory.)</p>\n<p>Or is there something else that I should be aware of?</p>\n", "Title": "How is C++ std::vector implemented?", "CreationDate": "2010-01-19T19:51:12.290", "LastActivityDate": "2013-04-26T16:59:43.100", "CommentCount": "1", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2012-11-26T13:34:24.907", "LastEditorUserId": "1012284", "Id": "2096571", "Score": "34", "OwnerUserId": "234828", "Tags": "<c++><stl>", "AnswerCount": "9"}});