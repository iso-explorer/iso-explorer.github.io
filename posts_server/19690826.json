post_cb({"19690894": {"ParentId": "19690826", "CommentCount": "0", "Body": "<p>The <code>||</code> works only in logical boolean expression.</p>\n<p>From the standard (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_19690826_19690894_0\"><strong>5.15 Logical OR operator [expr.log.or]</strong></p>\n<p id=\"so_19690826_19690894_1\">The <code>||</code> operator groups left-to-right. <strong>The operands are both contextually converted to <code>bool</code></strong> (Clause 4). It returns <code>true</code> if either of its operands is <code>true</code>, and <code>false</code> otherwise.</p>\n</blockquote>\n<p>So in <code>input.find(\"end\" || \"End\")</code>, it tries to convert <code>\"end\"</code> and <code>\"End\"</code> to <code>bool</code>. And the operator <code>||</code> will return a <code>bool</code> also.</p>\n<hr>\n<p>Here to solve your problem you need to replace:</p>\n<pre><code>if (input.find(\"end\" || \"End\") != std::string::npos)\n</code></pre>\n<p>by</p>\n<pre><code>if ( input.find(\"End\") != std::string::npos ||\n     input.find(\"End\") != std::string::npos )\n</code></pre>\n<p>And do the same in the second <code>find</code>.</p>\n</hr>", "OwnerUserId": "1394283", "PostTypeId": "2", "Id": "19690894", "Score": "1", "CreationDate": "2013-10-30T18:22:02.450", "LastActivityDate": "2013-10-30T18:22:02.450"}, "19690867": {"ParentId": "19690826", "CommentCount": "0", "Body": "<p>the Logical or operator, <code>||</code> only works in boolean expressions.</p>\n<p>For instance, if you had</p>\n<pre><code>bool A = true\nbool B = false\nbool C = A||B;  \n</code></pre>\n<p>than you will have set <code>bool C</code> to be <code>True</code>.  IT just takes 2 booleans, and returns true if either of those booleans is true.  That's all logical or does.</p>\n<p>You might want to try something like</p>\n<pre><code>if (input.find(\"end\") != std::string::npos || input.find(\"End\") != std::string::npos)\n</code></pre>\n", "OwnerUserId": "1123123", "PostTypeId": "2", "Id": "19690867", "Score": "2", "CreationDate": "2013-10-30T18:20:34.120", "LastActivityDate": "2013-10-30T18:20:34.120"}, "19690987": {"ParentId": "19690826", "CommentCount": "0", "Body": "<p>The argument of the function call</p>\n<pre><code>input.find(\"end\" || \"End\") \n</code></pre>\n<p>has type bool and means that addess of string literal \"end\" or/and address of string literal \"End\" is not equal to zero. It is obvious that the both string literals have addresses that are not equal to zero. So the call is equivalent to</p>\n<pre><code>input.find(true) \n</code></pre>\n<p>The compiler finds an overloaded function find that is the most suitable for this argument. This function is</p>\n<p>find( charT, c, size_tipe pos = 0 );</p>\n<p>Value true is implicitly converted to value charT( 1 ) and the function tries to find char with value 1 in your string.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "19690987", "Score": "0", "CreationDate": "2013-10-30T18:27:21.730", "LastActivityDate": "2013-10-30T18:27:21.730"}, "19690860": {"ParentId": "19690826", "CommentCount": "1", "Body": "<p>Replace</p>\n<pre><code>if (input.find(\"end\" || \"End\") != std::string::npos)\n</code></pre>\n<p>with:</p>\n<pre><code>if (input.find(\"end\") != std::string::npos || input.find(\"End\") != std::string::npos)\n</code></pre>\n<p>Similarly for your other <code>if</code>.</p>\n<p>It seems obvious what your expression means, but when you break it down it really doesn't make sense. <code>find</code> expects a string, and <code>\"end\" || \"End\"</code> is not a string.</p>\n", "OwnerUserId": "321772", "PostTypeId": "2", "Id": "19690860", "Score": "4", "CreationDate": "2013-10-30T18:19:55.600", "LastActivityDate": "2013-10-30T18:19:55.600"}, "19690889": {"ParentId": "19690826", "CommentCount": "0", "Body": "<blockquote id=\"so_19690826_19690889_0\">\n<pre><code> if (input.find(\"end\" || \"End\") != std::string::npos)\n //             ^^^^^^^^^^^^^^\n</code></pre>\n</blockquote>\n<p>The <code>||</code> operator is not being used correctly here. The righthand expression will return true because it is non-zero, then it will be returned. So the statement resolves to <code>input.find(\"end\")</code>. You need to use two separate conditional statements there:</p>\n<blockquote id=\"so_19690826_19690889_1\">\n<pre><code> if (input.find(\"end\") != std::string::npos ||\n     input.find(\"End\") != std::string::npos)\n</code></pre>\n</blockquote>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "19690889", "Score": "0", "CreationDate": "2013-10-30T18:21:53.753", "LastActivityDate": "2013-10-30T18:21:53.753"}, "19690947": {"ParentId": "19690826", "CommentCount": "0", "Body": "<p>I'd recommend using regex instead for things like that: \n<a href=\"http://www.cplusplus.com/reference/regex/\" rel=\"nofollow\">regex</a></p>\n", "OwnerUserId": "2540407", "PostTypeId": "2", "Id": "19690947", "Score": "0", "CreationDate": "2013-10-30T18:24:43.233", "LastActivityDate": "2013-10-30T18:24:43.233"}, "19690928": {"ParentId": "19690826", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++ simply doesn't work that way. When you write</p>\n<pre><code>input.find(\"end\" || \"End\") != std::string::npos\n</code></pre>\n<p>the compiler sees the <em>logical</em> or on two non-null const char pointers, which results in the boolean value <code>true</code>. This is then interpreted as a <code>char</code> with the value <code>1</code> (<code>'\\1'</code>) which is then searched in the string - certainly not what you intended. If you want to know if you string is in a set of strings, you could use:</p>\n<pre><code>static std::set&lt;std::string&gt; s = { \"end\", \"End\" };\ns.find( input ) != s.end();\n</code></pre>\n<p>While maybe not the most efficient code in the world, but with a C++11 compiler you can also condense it into a single line like this:</p>\n<pre><code>if( std::set&lt;std::string&gt;{ \"end\", \"End\" }.count( input ) ) {\n    // found...\n}\n</code></pre>\n", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-10-30T18:37:51.917", "Id": "19690928", "Score": "1", "CreationDate": "2013-10-30T18:23:42.737", "LastActivityDate": "2013-10-30T18:37:51.917"}, "19690826": {"CommentCount": "1", "ViewCount": "1745", "CreationDate": "2013-10-30T18:18:33.637", "LastActivityDate": "2013-10-30T18:37:51.917", "Title": "Or operator not working", "AcceptedAnswerId": "19690860", "PostTypeId": "1", "Id": "19690826", "Score": "-1", "Body": "<p>When I enter start then the program outputs the else function even though I fulfilled the criteria, I have tried with &amp;&amp; as well and it still didn't work. Any answers would be appreciated.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;windows.h&gt;\nusing namespace std;\n\nint main ()\n{\n    float timer;\n    bool end;\n    std::string input;\n\n    end = false;\n\n    cout &lt;&lt; \"Enter start then a number to count down from\" &lt;&lt; \".\\n\";\n\n    while (end == false){\n        cin &gt;&gt; input;\n\n        if (input.find(\"end\" || \"End\") != std::string::npos)\n        end = true;\n\n        else if (input.find(\"start\" || \"restart\" || \"Start\" || \"Restart\") != std::string::npos)\n        {\n            cin &gt;&gt; timer;\n\n            while (timer&gt;0){\n                timer -= 0.1;\n\n                Sleep(100);\n\n                cout &lt;&lt; timer &lt;&lt; \".\\n\";\n            }\n\n            cout &lt;&lt; \"Finished! Enter restart then another number to perform another countdown, or enter end to close the program\" &lt;&lt; \".\\n\";\n        }\n\n        else\n        cout &lt;&lt; \"Enter start\" &lt;&lt; \".\\n\";\n    }\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><or-operator>", "OwnerUserId": "2879864", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_19690826_19690894_1": {"section_id": 6165, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_19690826_19690894_1": {"section_id": 5926, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_19690826_19690894_1": {"section_id": 7662, "quality": 0.8947368421052632, "length": 17}}}});