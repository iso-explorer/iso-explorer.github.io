post_cb({"12762187": {"ParentId": "12761875", "CommentCount": "7", "Body": "<p>It is not necessary to use a smart pointer, it's just smart.</p>\n<p>That being said, there are many other possibilities; the only thing to do is to store the type information along the actual object.</p>\n<pre><code>class Holder {\npublic:\n    template &lt;typename T&gt;\n    explicit Holder(T const volatile* t):\n        _data(static_cast&lt;void const volatile*&gt;(t)),\n        _delete(&amp;Delete&lt;T&gt;)\n    {}\n\n    void apply() { _deleter(_data); }\n\nprivate:\n    typedef void (*Deleter)(void const volatile*);\n\n    template &lt;typename T&gt;\n    static void Delete(void const volatile* p) {\n        delete static_cast&lt;T const volatile*&gt;(p);\n    }\n\n    void const volatile* _data;\n    Deleter _deleter;\n};\n</code></pre>\n<p>And now:</p>\n<pre><code>std::list&lt;Holder&gt; owningList;\n\nowningList.push_back(Holder(somePointer));\n\nfor (Holder&amp; h: owningList) { h.apply(); }\n</code></pre>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "12762187", "Score": "1", "CreationDate": "2012-10-06T17:37:47.063", "LastActivityDate": "2012-10-06T17:37:47.063"}, "12761979": {"ParentId": "12761875", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Deleting through a <code>void*</code> results in undefined behavior, so you are guaranteed nothing.</p>\n<blockquote>\n<h3>5.3.5 Delete [expr.delete]</h3>\n<p id=\"so_12761875_12761979_0\">1 The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.<br>\n  [...]<br>\n<strong>The operand shall have a pointer to object type, or a class type having a single non-explicit conversion function (12.3.2) to a pointer to object type</strong>. The result has type void.<sup>78</sup> </br></br></p>\n<p id=\"so_12761875_12761979_1\">78) This implies that an object cannot be deleted using a pointer of type void* because void is not an object type.</p>\n</blockquote>\n<p>Emphasis mine.</p>\n<hr>\n<p>So even though you said not to say it, the answer is to create some form of smart pointer. It would need to use type-erasure to hide the type externally (allowing the heterogeneous list), but internally keep track of the type it was given and how to delete it. Something much like <code>boost::any</code>.</p>\n</hr>", "OwnerUserId": "87234", "LastEditorUserId": "87234", "LastEditDate": "2012-10-06T17:23:09.677", "Id": "12761979", "Score": "14", "CreationDate": "2012-10-06T17:15:58.740", "LastActivityDate": "2012-10-06T17:23:09.677"}, "12761875": {"CommentCount": "3", "AcceptedAnswerId": "12761979", "PostTypeId": "1", "ClosedDate": "2012-10-07T13:37:12.630", "LastEditorUserId": "-1", "CreationDate": "2012-10-06T17:03:48.707", "LastActivityDate": "2014-08-11T13:57:51.687", "LastEditDate": "2017-05-23T11:55:15.147", "ViewCount": "4705", "FavoriteCount": "1", "Title": "Does deleting void pointer guarantee to delete right size?", "Id": "12761875", "Score": "9", "Body": "<blockquote>\n<p id=\"so_12761875_12761875_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/941832/is-it-safe-to-delete-a-void-pointer\">Is it safe to delete a void pointer?</a></br></p>\n</blockquote>\n<p>Say I have a <code>new</code> allocation to a class called <code>MyClass</code> and allocation is as simple as:</p>\n<pre><code>MyClass *myClassPtr = new MyClass();\n</code></pre>\n<p>And I store reference to the list of <code>void*</code> where I simply say</p>\n<pre><code>myListOfPointers.add(static_cast&lt;void*&gt;(myClassPtr)); // this has to be void*\n</code></pre>\n<p>And later I release memory so instead of doing:</p>\n<pre><code>delete myClassPtr\n</code></pre>\n<p>I use:</p>\n<pre><code>delete MyListOfPointer.get(0)\n</code></pre>\n<p>(Say myClassPtr reference is at zero-index.) Also, please note that it has to be <code>void*</code> since this list can store different types of pointers so I wouldn't know the type of pointer that I am deleting:</p>\n<p><strong>So I can't do any thing like:</strong></p>\n<pre><code>delete static_cast&lt;MyClass*&gt;(MyListOfPointer.get(0))\n</code></pre>\n<p>Is this way going to release the correct memory size? (<code>sizeof(MyClass)</code>)? </p>\n<p><strong>Note:</strong><br>\nI am not looking for any answer pointing to smart pointers.</br></p>\n", "Tags": "<c++><pointers><memory-management><void>", "OwnerUserId": "1388187", "AnswerCount": "4"}, "12762010": {"ParentId": "12761875", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The correct answer to this question is of course 'no'</p>\n<p>Edit: asked to provide more information, even though I already did in a comment to the question, the deletion of a void* is undefined, and this question is another way of asking this one: <a href=\"https://stackoverflow.com/questions/941832/is-it-safe-to-delete-a-void-pointer\">Is it safe to delete a void pointer?</a> - see the answers in there for details.</p>\n", "OwnerUserId": "1613085", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:50.873", "Id": "12762010", "Score": "0", "CreationDate": "2012-10-06T17:20:14.350", "LastActivityDate": "2012-10-06T17:39:15.870"}, "12762129": {"ParentId": "12761875", "CommentCount": "4", "Body": "<p>A <code>void</code> pointer has no type information.  If <code>MyClass</code> has a destructor, it will not be called. The compiler needs to know what it is deleting so it can generate the appropriate code. If all of your pointers in the list are of the same type then you should be storing that type in the list, not as <code>void</code>. If the pointers are different types but derive from a common base type, then give that base type a virtual constructor and store pointers of that type instead.</p>\n", "OwnerUserId": "65863", "PostTypeId": "2", "Id": "12762129", "Score": "2", "CreationDate": "2012-10-06T17:31:15.843", "LastActivityDate": "2012-10-06T17:31:15.843"}, "bq_ids": {"n4140": {"so_12761875_12761979_1": {"section_id": 6105, "quality": 0.9230769230769231, "length": 12}, "so_12761875_12761979_0": {"section_id": 6105, "quality": 0.6129032258064516, "length": 19}}, "n3337": {"so_12761875_12761979_1": {"section_id": 5871, "quality": 0.9230769230769231, "length": 12}, "so_12761875_12761979_0": {"section_id": 5871, "quality": 0.8387096774193549, "length": 26}}, "n4659": {"so_12761875_12761979_1": {"section_id": 7602, "quality": 0.9230769230769231, "length": 12}, "so_12761875_12761979_0": {"section_id": 7602, "quality": 0.6129032258064516, "length": 19}}}});