post_cb({"35710536": {"CommentCount": "0", "ViewCount": "136", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2016-02-29T21:59:42.147", "LastActivityDate": "2016-06-01T18:21:48.893", "Title": "Macro not expanded with direct call, but expanded with indirect", "AcceptedAnswerId": "35711462", "LastEditDate": "2016-06-01T18:21:48.893", "Id": "35710536", "Score": "1", "Body": "<p>I've got the following macros</p>\n<pre><code>#include &lt;boost/preprocessor.hpp&gt;\n\n#define DB_FIELD(...) BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)\n\n#define DB_TOFIELD(type,name) \\\n  private:\\\n  type name##_;\\\n  public:\\\n  const type&amp; get_##name(){return name##_;}\\\n  void set_##name(const type&amp; val) { name##_ = val; }\n\n#define GEN_ENUM_FIELD(r,data,elem) BOOST_PP_CAT(FIELD_,BOOST_PP_SEQ_ELEM(1,elem)),\n\n#define DECLARE(type, name) DB_TOFIELD(type, name)\n\n#define GEN_FIELD_DECL(r, data, elem) DECLARE(BOOST_PP_SEQ_ELEM(0,elem),BOOST_PP_SEQ_ELEM(1,elem))\n\n#define DB_TABLE(name, ...) class name : public DataBaseTable {\\\n  public:\\\n  constexpr static const char *get_table_name() { return #name; }\\\n  BOOST_PP_LIST_FOR_EACH(GEN_FIELD_DECL,, BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__)) \\\n  enum Fields{ \\\n  BOOST_PP_LIST_FOR_EACH(GEN_ENUM_FIELD,, BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__))\\\n  FIELD_COUNT\\\n  };\\\n  };\n</code></pre>\n<p>Now the following code:</p>\n<pre><code>DB_TABLE(Test2,\n  DB_FIELD(int, foo),\n  DB_FIELD(int, bar)\n)\n</code></pre>\n<p>Generates:</p>\n<pre><code>class Test2 : public DataBaseTable {\npublic:\n  constexpr static const char *get_table_name() { return \"Test2\"; }\nprivate:\n  int foo_;\npublic:\n  const int &amp;get_foo() { return foo_; }\n  void set_foo(const int &amp;val) { foo_ = val; }\nprivate:\n  int bar_;\npublic:\n  const int &amp;get_bar() { return bar_; }\n  void set_bar(const int &amp;val) { bar_ = val; }\n  enum Fields { FIELD_foo, FIELD_bar, FIELD_COUNT };\n};\n</code></pre>\n<p>Which is as ugly as I wrote it, but my concern is <strong>why do I need this level of indirection (<em>DECLARE</em>) in the GEN_FIELD_DECL macro</strong> ? The direct call to <strong>DB_TOFIELD</strong></p>\n<pre><code>#define GEN_FIELD_DECL(r, data, elem) DB_TOFIELD(BOOST_PP_SEQ_ELEM(0,elem),BOOST_PP_SEQ_ELEM(1,elem))\n</code></pre>\n<p>produces garbage:</p>\n<pre><code>class Test2 : public DataBaseTable {\npublic:\n  constexpr static const char *get_table_name() { return \"Test2\"; }\nprivate:\n  int foo _;\npublic:\n  const int &amp;get_BOOST_PP_SEQ_ELEM(1, (int)(foo))() { return foo _; }\n  void set_BOOST_PP_SEQ_ELEM(1, (int)(foo))(const int &amp;val) { foo _ = val; }\nprivate:\n  int bar _;\npublic:\n  const int &amp;get_BOOST_PP_SEQ_ELEM(1, (int)(bar))() { return bar _; }\n  void set_BOOST_PP_SEQ_ELEM(1, (int)(bar))(const int &amp;val) { bar _ = val; }\n  enum Fields { FIELD_foo, FIELD_bar, FIELD_COUNT };\n};\n</code></pre>\n<p>The same behavior is reproduced with clang 3.7.1 and gcc 5.3</p>\n", "Tags": "<c++><macros><variadic-macros><boost-preprocessor>", "OwnerUserId": "2174017", "AnswerCount": "1"}, "35711462": {"ParentId": "35710536", "CommentCount": "0", "Body": "<p>What you are running into is an exception to how the preprocessor expands parameters if they are arguments to the <code>#</code> or <code>##</code> operators. From C++.2011 \u00a716.3.1\u00b61:</p>\n<blockquote>\n<p id=\"so_35710536_35711462_0\">After the arguments for the invocation of a function-like macro have been identified, argument substitution\n  takes place. A parameter in the replacement list, <strong><em>unless preceded by a <code>#</code> or <code>##</code> preprocessing token or\n  followed by a <code>##</code> preprocessing token</em></strong> (see below), is replaced by the corresponding argument after all macros\n  contained therein have been expanded. Before being substituted, each argument\u2019s preprocessing tokens are\n  completely macro replaced as if they formed the rest of the preprocessing file; no other preprocessing tokens\n  are available.</p>\n</blockquote>\n<p>The macro indirection avoids the exception clause, causing the argument to be expanded before being processed by the other macro.</p>\n<p>For example:</p>\n<pre><code>#define FOO 10\n#define BAR(x) x ## 7\n#define BAR2(x) BAR(x)\n\nint x = BAR(FOO);      // =&gt; int x = FOO7;\n\nint y = BAR2(FOO);     // =&gt; int y = BAR(10); (intermediate result)\n                       // =&gt; int y = 107;     (final expansion)\n</code></pre>\n", "OwnerUserId": "315052", "PostTypeId": "2", "Id": "35711462", "Score": "2", "CreationDate": "2016-02-29T22:59:41.943", "LastActivityDate": "2016-02-29T22:59:41.943"}, "bq_ids": {"n4140": {"so_35710536_35711462_0": {"section_id": 523, "quality": 1.0, "length": 53}}, "n3337": {"so_35710536_35711462_0": {"section_id": 514, "quality": 1.0, "length": 53}}, "n4659": {"so_35710536_35711462_0": {"section_id": 544, "quality": 1.0, "length": 53}}}});