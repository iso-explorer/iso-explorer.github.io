post_cb({"31343107": {"ViewCount": "648", "Body": "<p>In the following fragment of code I receive a compiler error when the method Data::setValue(int, int) is declared virtual:</p>\n<pre><code>struct Data{\n    int ma;\n    int mb;\n    virtual void setValues(int a, int b){\n        ma = a;\n        mb = b;\n    }\n};\n\nstruct ThreadMessage {\n    enum type {\n        DATA\n    };\n\n    type msg_type;\n    union content {\n        Data d;\n        int a;\n    }content;\n};\n</code></pre>\n<p>The error that the compiler (g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3) gives me is:</p>\n<blockquote>\n<p id=\"so_31343107_31343107_0\">struct.cpp:19:14: error: member 'Data ThreadMessage::content::d' with\n  constructor not allowed in union</p>\n<p id=\"so_31343107_31343107_1\">struct.cpp:19:14: error: member 'Data ThreadMessage::content::d' with  copy assignment operator not allowed in union</p>\n</blockquote>\n<p>This set of compiler errors took me completely off guard. In the actual code, I had many more attributes and functions. Therefore, I started looking where I put the bloody operator=() and constructor but I didn't write them in <code>struct Data</code>.</p>\n<p>I know my problem disappears when I make the Data::setValues as not virtual. But why does the struct Data have a constructor? When exactly does a struct have a constructor in C++? And why does the compilation error disappear when I make <code>virtual void Data::setValues(int, int)</code> non virtual?</p>\n", "AcceptedAnswerId": "31343750", "Title": "Non trivial struct constructor inside a union in C++", "CreationDate": "2015-07-10T14:17:04.630", "Id": "31343107", "CommentCount": "3", "LastEditDate": "2015-07-18T12:05:36.173", "PostTypeId": "1", "LastEditorUserId": "718379", "LastActivityDate": "2015-07-18T12:05:36.173", "Score": "2", "OwnerUserId": "2082884", "Tags": "<c++><struct><constructor><unions>", "AnswerCount": "5"}, "31343351": {"Id": "31343351", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_31343107_31343351_0\">When exactly does a struct have a constructor in c++</p>\n</blockquote>\n<p><strong>Always.</strong></p>\n<p>The error message is a bit confusing, but it's saying that you cannot have a class there.</p>\n<p>A class is a type defined with either the <code>struct</code> keyword or the <code>class</code> keyword.</p>\n<p>Every class has a constructor and an assignment operator, whether it's user-provided or not.</p>\n", "LastActivityDate": "2015-07-10T14:28:29.440", "CommentCount": "0", "CreationDate": "2015-07-10T14:28:29.440", "ParentId": "31343107", "Score": "1", "OwnerUserId": "560648"}, "31343750": {"Id": "31343750", "PostTypeId": "2", "Body": "<p>The error messages you quoted are misleading, so no doubt you wonder why making the function non-virtual fixes the problem.</p>\n<p>First - structs and classes in C++ have constructors and copy assignment operators. If you do not create them yourself, they will be created for you. (You may delete those default versions). In your example there is an automatically generated constructor of <code>Data</code>, and also automatically generated assignment operator.</p>\n<p>Now why the error messages are misleading? Because they are not true. In C++ you can have union members with constructors or assignment operators. The problem starts when those member functions are not trivial. Before C++11 it was just not possible to have an union member with non-trivial constructor. C++11 changed it, but still without writing additional functions it is not possible to use such union.</p>\n<p>A struct/class with virtual functions has non-trivial member functions as constructor and assignment operator (because hidden data member needs to be managed). This is why when you make the function non-virtual the errors disappear - then the member functions become trivial and your struct may be used as a union member without problems.</p>\n", "LastActivityDate": "2015-07-10T14:46:00.890", "CommentCount": "1", "CreationDate": "2015-07-10T14:46:00.890", "ParentId": "31343107", "Score": "1", "OwnerUserId": "2382136"}, "bq_ids": {"n4140": {"so_31343107_31343351_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5994}}, "n3337": {"so_31343107_31343351_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5762}}, "n4659": {"so_31343107_31343351_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7496}}}, "31343204": {"Id": "31343204", "PostTypeId": "2", "Body": "<p>Barring the default access of members, a <code>struct</code> and a <code>class</code> are identical in C++.</p>\n<p>Unless you program carefully (and have C++11), you cannot have a <code>class</code> or a <code>struct</code> member in a <code>union</code> since there would be ambiguity as to how such members of the union should be constructed.</p>\n<p>That's what your compiler is telling you.</p>\n", "LastActivityDate": "2015-07-10T14:21:28.203", "CommentCount": "0", "CreationDate": "2015-07-10T14:21:28.203", "ParentId": "31343107", "Score": "3", "OwnerUserId": "2380830"}, "31343290": {"Id": "31343290", "PostTypeId": "2", "Body": "<p>You may want to browse through this thread: <a href=\"https://stackoverflow.com/questions/1127396/struct-constructor-in-c\">Struct Constructor in C++?</a></p>\n<p>The Reader's Digest version is that, like classes, structs have a default constructor, which you can overload and define however you like. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-10T14:25:58.187", "Score": "2", "CreationDate": "2015-07-10T14:25:58.187", "ParentId": "31343107", "CommentCount": "0", "OwnerUserId": "5090805", "LastEditDate": "2017-05-23T11:51:10.143"}, "31343602": {"Id": "31343602", "PostTypeId": "2", "Body": "<p>The compiler error message is a bit misleading. From the conceptual language point of view your class <code>Data</code> will have a constructor in any case, regardless of whether the function is virtual or not.</p>\n<p>The compiler is apparently a pre-C++11 one (or works in pre-C++11 mode). And it does not like the fact that <code>Data</code>'s constructor is <em>non-trivial</em>. It is specifically the <em>non-triviality</em> of <code>Data</code>'s constructor that makes the compiler to say that <code>Data</code> is a class \"with constructor\".</p>\n<p>In this particular case the constructor becomes non-trivial once you introduce at least one virtual function into the class.</p>\n<p>A non-trivial constructor is a constructor that has to do something (in your case - initialize the per-object household information that support polymorphism). I.e. it is a constructor that must exist physically in generated code. Meanwhile a <em>trivial</em> constructor exists only conceptually, but produces no code. The compiler is referring to that physical distinction when it separates classes into ones \"with constructor\" and ones \"without constructor\".</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2015-07-10T16:20:28.767", "Score": "1", "CreationDate": "2015-07-10T14:38:57.727", "ParentId": "31343107", "CommentCount": "1", "OwnerUserId": "187690", "LastEditDate": "2015-07-10T16:20:28.767"}});