post_cb({"43827695": {"Id": "43827695", "PostTypeId": "2", "Body": "<p>Yes, sure. Normal name lookup rules apply.</p>\n<blockquote>\n<p id=\"so_43827651_43827695_0\"><strong>[expr.prim.lambda]/7</strong> ... for purposes of name lookup ... the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>Re: why local variables are treated differently from global ones.</p>\n<blockquote>\n<p id=\"so_43827651_43827695_1\"><strong>[expr.prim.lambda]/13</strong> ... If a <em>lambda-expression</em> or an instantiation of the function call operator template of a generic lambda odr-uses (3.2) <code>this</code> or a variable with automatic storage duration from its reaching scope, that entity shall be captured by the <em>lambda-expression</em>.</p>\n<p id=\"so_43827651_43827695_2\"><strong>[expr.prim.lambda]/9</strong> A <em>lambda-expression</em> whose smallest enclosing scope is a block scope (3.3.3) is a <em>local lambda expression</em>... The <em>reaching scope</em> of a local lambda expression is the set of enclosing scopes up to and including the innermost enclosing function and its parameters.</p>\n</blockquote>\n<p>In your example, <code>m</code> is a variable with automatic storage duration from the lambda's reaching scope, and so shall be captured. <code>n</code> is not, and so doesn't have to be.</p>\n", "LastEditorUserId": "1670129", "LastActivityDate": "2017-05-07T04:40:47.167", "Score": "12", "CreationDate": "2017-05-07T04:04:13.993", "ParentId": "43827651", "CommentCount": "3", "OwnerUserId": "1670129", "LastEditDate": "2017-05-07T04:40:47.167"}, "bq_ids": {"n4140": {"so_43827651_43827695_1": {"length": 19, "quality": 0.95, "section_id": 5972}, "so_43827651_43827695_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5966}, "so_43827651_43827695_2": {"length": 22, "quality": 0.8148148148148148, "section_id": 5968}}, "n3337": {"so_43827651_43827695_1": {"length": 13, "quality": 0.65, "section_id": 5740}, "so_43827651_43827695_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5735}, "so_43827651_43827695_2": {"length": 22, "quality": 0.8148148148148148, "section_id": 5737}}, "n4659": {"so_43827651_43827695_1": {"length": 19, "quality": 0.95, "section_id": 7471}, "so_43827651_43827695_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 7460}, "so_43827651_43827695_2": {"length": 22, "quality": 0.8148148148148148, "section_id": 7466}}}, "43827951": {"Id": "43827951", "PostTypeId": "2", "Body": "<p>Actually the <code>[](){ n = 10; }();</code> doesn't capture anything, it uses the global variable instead.</p>\n<pre><code>int n;    \nint main()\n{\n    [](){ n = 10; }(); // clang says \"ok\"\n    std::cout &lt;&lt; n; // output 10\n}\n</code></pre>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow noreferrer\">capture-list in Explaination</a></p>\n<blockquote>\n<p id=\"so_43827651_43827951_0\"><strong>capture-list</strong>  -   a comma-separated list of zero or more captures, optionally beginning with a capture-default.</p>\n<p id=\"so_43827651_43827951_1\">Capture list can be passed as follows (see below for the detailed\n  description):</p>\n<ul>\n<li>[a,&amp;b] where a is captured by copy and b is captured by reference.</li>\n<li>[this] captures the current object (*this) by reference</li>\n<li>[&amp;] captures all automatic variables used in the body of the lambda by reference and current object by reference if exists</li>\n<li>[=] captures all automatic variables used in the body of the lambda by copy and current object by reference if exists</li>\n<li><strong>[ ] captures nothing</strong></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "5685664", "LastActivityDate": "2017-05-07T05:15:20.120", "Score": "4", "CreationDate": "2017-05-07T04:52:07.563", "ParentId": "43827651", "CommentCount": "0", "OwnerUserId": "5685664", "LastEditDate": "2017-05-07T05:15:20.120"}, "43827651": {"ViewCount": "906", "Body": "<pre><code>int n;    \nint main()\n{\n    [](){ n = 0; }(); // clang says \"ok\"\n\n    int m;\n    [](){ m = 0; }(); // clang says \"not ok\"\n}\n</code></pre>\n<p>I just wonder:</p>\n<p>If the lambda captures nothing, is it allowed to access global variables as per the C++ standard?</p>\n", "AcceptedAnswerId": "43827695", "Title": "Can a lambda capturing nothing access global variables?", "CreationDate": "2017-05-07T03:54:47.950", "Id": "43827651", "CommentCount": "4", "LastEditDate": "2017-05-07T04:09:51.753", "PostTypeId": "1", "LastEditorUserId": "508343", "LastActivityDate": "2017-05-07T05:15:20.120", "Score": "11", "OwnerUserId": "508343", "Tags": "<c++><c++11><lambda><global-variables><standards>", "AnswerCount": "2"}});