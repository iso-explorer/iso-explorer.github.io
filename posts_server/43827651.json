post_cb({"43827951": {"ParentId": "43827651", "LastEditDate": "2017-05-07T05:15:20.120", "CommentCount": "0", "CreationDate": "2017-05-07T04:52:07.563", "OwnerUserId": "5685664", "LastEditorUserId": "5685664", "PostTypeId": "2", "Id": "43827951", "Score": "4", "Body": "<p>Actually the <code>[](){ n = 10; }();</code> doesn't capture anything, it uses the global variable instead.</p>\n<pre><code>int n;    \nint main()\n{\n    [](){ n = 10; }(); // clang says \"ok\"\n    std::cout &lt;&lt; n; // output 10\n}\n</code></pre>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow noreferrer\">capture-list in Explaination</a></p>\n<blockquote>\n<p id=\"so_43827651_43827951_0\"><strong>capture-list</strong>  -   a comma-separated list of zero or more captures, optionally beginning with a capture-default.</p>\n<p id=\"so_43827651_43827951_1\">Capture list can be passed as follows (see below for the detailed\n  description):</p>\n<ul>\n<li>[a,&amp;b] where a is captured by copy and b is captured by reference.</li>\n<li>[this] captures the current object (*this) by reference</li>\n<li>[&amp;] captures all automatic variables used in the body of the lambda by reference and current object by reference if exists</li>\n<li>[=] captures all automatic variables used in the body of the lambda by copy and current object by reference if exists</li>\n<li><strong>[ ] captures nothing</strong></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2017-05-07T05:15:20.120"}, "43827651": {"CommentCount": "4", "ViewCount": "906", "PostTypeId": "1", "LastEditorUserId": "508343", "CreationDate": "2017-05-07T03:54:47.950", "LastActivityDate": "2017-05-07T05:15:20.120", "Title": "Can a lambda capturing nothing access global variables?", "AcceptedAnswerId": "43827695", "LastEditDate": "2017-05-07T04:09:51.753", "Id": "43827651", "Score": "11", "Body": "<pre><code>int n;    \nint main()\n{\n    [](){ n = 0; }(); // clang says \"ok\"\n\n    int m;\n    [](){ m = 0; }(); // clang says \"not ok\"\n}\n</code></pre>\n<p>I just wonder:</p>\n<p>If the lambda captures nothing, is it allowed to access global variables as per the C++ standard?</p>\n", "Tags": "<c++><c++11><lambda><global-variables><standards>", "OwnerUserId": "508343", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_43827651_43827695_0": {"section_id": 5966, "quality": 0.8571428571428571, "length": 6}, "so_43827651_43827695_1": {"section_id": 5972, "quality": 0.95, "length": 19}, "so_43827651_43827695_2": {"section_id": 5968, "quality": 0.8148148148148148, "length": 22}}, "n3337": {"so_43827651_43827695_0": {"section_id": 5735, "quality": 0.8571428571428571, "length": 6}, "so_43827651_43827695_1": {"section_id": 5740, "quality": 0.65, "length": 13}, "so_43827651_43827695_2": {"section_id": 5737, "quality": 0.8148148148148148, "length": 22}}, "n4659": {"so_43827651_43827695_0": {"section_id": 7460, "quality": 0.8571428571428571, "length": 6}, "so_43827651_43827695_1": {"section_id": 7471, "quality": 0.95, "length": 19}, "so_43827651_43827695_2": {"section_id": 7466, "quality": 0.8148148148148148, "length": 22}}}, "43827695": {"ParentId": "43827651", "LastEditDate": "2017-05-07T04:40:47.167", "CommentCount": "3", "CreationDate": "2017-05-07T04:04:13.993", "OwnerUserId": "1670129", "LastEditorUserId": "1670129", "PostTypeId": "2", "Id": "43827695", "Score": "12", "Body": "<p>Yes, sure. Normal name lookup rules apply.</p>\n<blockquote>\n<p id=\"so_43827651_43827695_0\"><strong>[expr.prim.lambda]/7</strong> ... for purposes of name lookup ... the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>Re: why local variables are treated differently from global ones.</p>\n<blockquote>\n<p id=\"so_43827651_43827695_1\"><strong>[expr.prim.lambda]/13</strong> ... If a <em>lambda-expression</em> or an instantiation of the function call operator template of a generic lambda odr-uses (3.2) <code>this</code> or a variable with automatic storage duration from its reaching scope, that entity shall be captured by the <em>lambda-expression</em>.</p>\n<p id=\"so_43827651_43827695_2\"><strong>[expr.prim.lambda]/9</strong> A <em>lambda-expression</em> whose smallest enclosing scope is a block scope (3.3.3) is a <em>local lambda expression</em>... The <em>reaching scope</em> of a local lambda expression is the set of enclosing scopes up to and including the innermost enclosing function and its parameters.</p>\n</blockquote>\n<p>In your example, <code>m</code> is a variable with automatic storage duration from the lambda's reaching scope, and so shall be captured. <code>n</code> is not, and so doesn't have to be.</p>\n", "LastActivityDate": "2017-05-07T04:40:47.167"}});