post_cb({"1703219": {"Id": "1703219", "PostTypeId": "2", "Body": "<p>istream_iterator is input so your second code fragment isn't correct, you can't do this (second pass). Please look <a href=\"http://www.sgi.com/tech/stl/Iterators.html\" rel=\"nofollow noreferrer\">here</a> and pay attention to \"single pass\" algorithms support (second paragraph under \"description\" title). First fragment doesn't try to perform 2 passes.</p>\n<p>Is this explanation OK? BTW SGI STL reference (from where I posted link) is somewhat outdated but very usable for some quick references (by my opinion). I'd recommend it to be bookmarked.</p>\n", "LastActivityDate": "2009-11-09T19:32:06.823", "Score": "1", "CreationDate": "2009-11-09T19:32:06.823", "ParentId": "1702929", "CommentCount": "0", "OwnerUserId": "204665"}, "1703154": {"Id": "1703154", "PostTypeId": "2", "Body": "<p>I don't think you can advance the end iterator to a suitable position: to advance the iterator means to read input, also both iterators are referencing the same stream - therefore advancing one iterator means to advance the second. They both end up referencing the same position in the stream.</p>\n<p>Unless you are willing to write or find an iterator adaptor (boost?) that does an operation on n items referenced by some iterator, it might not be possible to initialize the string like that. Or you read the value with other methods and set the value of the string later.</p>\n", "LastActivityDate": "2009-11-09T19:20:12.453", "Score": "2", "CreationDate": "2009-11-09T19:20:12.453", "ParentId": "1702929", "CommentCount": "2", "OwnerUserId": "155693"}, "bq_ids": {"n4140": {"so_1702929_1703247_1": {"length": 19, "quality": 1.0, "section_id": 5695}}, "n3337": {"so_1702929_1703247_1": {"length": 19, "quality": 1.0, "section_id": 5478}}, "n4659": {"so_1702929_1703247_1": {"length": 19, "quality": 1.0, "section_id": 7140}}}, "1703223": {"Id": "1703223", "PostTypeId": "2", "Body": "<p>The istream_iterator is a very limited iterator knows as a input iterator.</p>\n<p>See: <a href=\"http://www.sgi.com/tech/stl/InputIterator.html\" rel=\"nofollow noreferrer\">http://www.sgi.com/tech/stl/InputIterator.html</a></p>\n<p>But basically for input iterators very few gurantees are made.<br>\nSpecifically to your case:</br></p>\n<p>i == j does not imply ++i == ++j.</p>\n<p>So your first example is an iterator that is passed the end of stream. It is valid (as long as it is not incremented) and comparable to other iterators so works for reading the whole stream.</p>\n", "LastActivityDate": "2009-11-09T19:33:12.957", "Score": "1", "CreationDate": "2009-11-09T19:33:12.957", "ParentId": "1702929", "CommentCount": "0", "OwnerUserId": "14065"}, "1702929": {"ViewCount": "583", "Body": "<p>I'm trying to initialize string with iterators and something like this works:</p>\n<pre><code>ifstream fin(\"tmp.txt\");  \nistream_iterator&lt;char&gt; in_i(fin), eos; \n//here eos is 1 over the end  \nstring s(in_i, eos);\n</code></pre>\n<p>but this doesn't:</p>\n<pre><code>ifstream fin(\"tmp.txt\");\nistream_iterator&lt;char&gt; in_i(fin), eos(fin);\n/* here eos is at this same position as in_i*/\n//moving eos forward \nfor (int i = 0; i &lt; 20; ++i)\n{\n    ++eos; \n}\n// trying to initialize string with \n// pair of iterators gives me \"\" \n// result  \nstring s(in_i, eos);\n</code></pre>\n<p>Thank you.</p>\n", "AcceptedAnswerId": "1703154", "Title": "String initialization with pair of iterators", "CreationDate": "2009-11-09T18:43:04.800", "Id": "1702929", "CommentCount": "3", "LastEditDate": "2015-02-18T01:14:07.593", "PostTypeId": "1", "LastEditorUserId": "204665", "LastActivityDate": "2015-02-18T01:14:07.593", "Score": "2", "OwnerUserId": "207177", "Tags": "<c++><string><iostream><libstdc++>", "AnswerCount": "4"}, "1703247": {"Id": "1703247", "PostTypeId": "2", "Body": "<p>From the standard [24.5.1]/1:</p>\n<blockquote>\n<p id=\"so_1702929_1703247_0\">[...] The constructor with no arguments\n  istream_iterator() always constructs\n  an end of stream input iterator\n  object, which is the only legitimate\n  iterator to be used for the end\n  condition. [...] The main peculiarity of the istream iterators is the fact that ++ operators are not equality preserving, that is, i == j does not guarantee at all that ++i == ++j. Every time ++ is used a new value is read.</p>\n</blockquote>\n<p>[24.5.1]/3</p>\n<blockquote>\n<p id=\"so_1702929_1703247_1\">Two end-of-stream iterators are\n  always equal. An end-of-stream\n  iterator is not equal to a\n  non-end-of-stream iterator. Two\n  non-end-of-stream iterators are equal\n  when they are constructed from the\n  same   stream</p>\n</blockquote>\n<p>The first paragraph states that you cannot use any but end-of-stream iterators as end conditions, so your first usage is correct and expected. The third paragraph in the chapter states that any two non-end-of-stream iterators into the same stream are guaranteed to be equal at all times. That is, the second usage is correct from the language standpoint and will provide the results you are getting.</p>\n<p>The last part of paragraph 1, where it states that <code>i == j</code> does not imply <code>++i == ++j</code> deals with the particular case of one last element present in the stream. After incrementing the first of the iterators (either <code>i</code> or <code>j</code>) the datum is consumed by that iterator. Advancing the other iterator will hit the end of stream and thus the two iterators will differ. In all other cases (there is more than one datum left in the stream), <code>++i == ++j</code>.</p>\n<p>Also note that the sentence <code>++i == ++j</code> executes two mutating operations on the same element (stream) and thus it is not which of the two iterators get the first/second datum in the stream.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2009-11-10T14:28:06.593", "Score": "0", "CreationDate": "2009-11-09T19:37:33.583", "ParentId": "1702929", "CommentCount": "0", "LastEditDate": "2009-11-10T14:28:06.593", "OwnerUserId": "36565"}});