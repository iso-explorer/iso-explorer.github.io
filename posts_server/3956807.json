post_cb({"bq_ids": {"n4140": {"so_3956807_3956807_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 6109}}, "n3337": {"so_3956807_3956807_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5875}}, "n4659": {"so_3956807_3956807_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 7606}}}, "3956807": {"ViewCount": "513", "Body": "<p>Reference <a href=\"https://stackoverflow.com/questions/1025313/c-will-an-empty-destructor-do-the-same-thing-as-the-generated-destructor\">here</a></p>\n<blockquote>\n<p id=\"so_3956807_3956807_0\">That destructor will also implicitly\n  call the destructor of the auto_ptr\n  object. And that will delete the\n  pointer it holds, that points to the C\n  object - without knowing the\n  definition of C! That appeared in the\n  .cpp file where struct A's constructor\n  is defined.</p>\n</blockquote>\n<p>This was curious and then</p>\n<blockquote>\n<p id=\"so_3956807_3956807_1\">5.3.5/5 states - \"If the object being deleted has incomplete class type at\n  the point of deletion and the complete\n  class has a non-trivial destructor or\n  a deallocation function, the behavior\n  is undefined.\"</p>\n</blockquote>\n<p>My question is that why isn't such a program which attempts to delete a pointer to an incomplete type treated as ill-formed? Why is it pushed into the realm of conditional (<strong>and</strong> the complete class has a non-trivial destructor..) 'undefined behavior'? </p>\n<p>What does the '<strong>and</strong>' imply?</p>\n<p>EDIT 2:</p>\n<p>Is the code below well-formed? VS and Gcc/CLang compile, but Comeau gives a warning. I guess all this is part of the undefined behavior mentioned in the Standard. My question is 'why is this not ill-formed but is undefined'?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nstruct C;\n                        // Is this the POI for auto_ptr&lt;C&gt;? $14.6.4.1/3\nstruct A{\n    A();\n    auto_ptr&lt;C&gt; mc;\n    ~A(){}             // how does it link to C::~C at this point?\n};\n\nstruct C{};\n\nA::A():mc(new C){}\n\nint main(){\n    A a;\n}\n</code></pre>\n", "AcceptedAnswerId": "3956918", "Title": "Delete expression", "CreationDate": "2010-10-18T05:39:25.047", "Id": "3956807", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:14:04.210", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-11T09:43:10.490", "Score": "3", "OwnerUserId": "418110", "Tags": "<c++><destructor><delete-operator><incomplete-type>", "AnswerCount": "1"}, "3956918": {"Id": "3956918", "PostTypeId": "2", "Body": "<p>As I'm writing this your text says \"Reference [here][1]\" with no reference.</p>\n<p>But essentially, the standard allows you to <code>delete</code> a pointer to incomplete type so that you can leverage knowledge that the compiler doesn't have, namely that the type's destructor does nothing.</p>\n<p><code>std::auto_ptr</code> is an example where this is a problem, especially for the PIMPL idiom (an infamous example of getting it wrong was Herb Sutter's GOTW on PIMPL, where he incorrectly used <code>std::auto_ptr</code>). <code>boost::shared_ptr</code> is an example where it isn't a problem (in general). That's because the constructor of <code>boost::shared_ptr</code> stores a deleter function, and the complete type of the pointee must necessarily be known at the point of construction.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2010-10-18T06:09:32.233", "CommentCount": "5", "CreationDate": "2010-10-18T06:09:32.233", "ParentId": "3956807", "Score": "5", "OwnerUserId": "464581"}});