post_cb({"996677": {"Id": "996677", "PostTypeId": "2", "Body": "<p>It is perfectly legal. </p>\n<p>The vector&lt;&gt; template class from the stl does exactly this when you call myVec.end(): it gets you a pointer (here as an iterator)  which points one element past the end of the array.</p>\n", "LastActivityDate": "2009-06-15T15:12:03.223", "CommentCount": "1", "CreationDate": "2009-06-15T15:12:03.240", "ParentId": "988158", "Score": "-2", "OwnerUserId": "44952"}, "988303": {"Id": "988303", "PostTypeId": "2", "Body": "<p>I believe that this is legal, and it depends on the 'lvalue to rvalue' conversion taking place.  The last line Core issue <a href=\"http://std.dkuug.dk/JTC1/SC22/WG21/docs/cwg_active.html#232\" rel=\"noreferrer\">232</a> has the following:</p>\n<blockquote>\n<p id=\"so_988158_988303_0\">We agreed that the approach in the standard seems okay: p = 0; *p; is not inherently an error. An lvalue-to-rvalue conversion would give it undefined behavior</p>\n</blockquote>\n<p>Although this is slightly different example, what it does show is that the '*' does not result in  lvalue to rvalue conversion and so, given that the expression is the immediate operand of '&amp;' which expects an lvalue then the behaviour is defined.</p>\n", "LastActivityDate": "2009-06-12T18:40:31.680", "CommentCount": "3", "CreationDate": "2009-06-12T18:40:31.680", "ParentId": "988158", "Score": "8", "OwnerUserId": "11698"}, "991310": {"Id": "991310", "PostTypeId": "2", "Body": "<p>This is legal:</p>\n<pre><code>int array[5];\nint *array_begin = &amp;array[0];\nint *array_end = &amp;array[5];\n</code></pre>\n<blockquote>\n<p id=\"so_988158_991310_0\">Section 5.2.1 Subscripting The expression E1[E2] is identical (by de\ufb01nition) to *((E1)+(E2))</p>\n</blockquote>\n<p>So by this we can say that array_end is equivalent too:</p>\n<pre><code>int *array_end = &amp;(*((array) + 5)); // or &amp;(*(array + 5))\n</code></pre>\n<blockquote>\n<p id=\"so_988158_991310_1\">Section 5.3.1.1 Unary operator '*': The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or \n  a pointer to a function type and <b>the result is an lvalue referring to the object or function</b> to which the expression points. \n  If the type of the expression is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d [ Note: a pointer to an incomplete type (other \n  than cv void) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for \n  example); this lvalue must not be converted to an rvalue, see 4.1. \u2014 end note ] </p>\n</blockquote>\n<p>The important part of the above:</p>\n<blockquote>\n<p id=\"so_988158_991310_2\">'the result is an lvalue referring to the object or function'.</p>\n</blockquote>\n<p>The unary operator '*' is returning a lvalue referring to the int (no de-refeference). The unary operator '&amp;' then gets the address of the lvalue.</p>\n<p>As long as there is no de-referencing of an out of bounds pointer then the operation is fully covered by the standard and all behavior is defined. So by my reading the above is completely legal.</p>\n<p>The fact that a lot of the STL algorithms depend on the behavior being well defined, is a sort of hint that the standards committee has already though of this and I am sure there is a something that covers this explicitly.</p>\n<h1>The comment section below presents two arguments:</h1>\n<p>(please read: but it is long and both of us end up trollish)</p>\n<h2>Argument 1</h2>\n<p>this is illegal because of section 5.7 paragraph 5</p>\n<blockquote>\n<p id=\"so_988158_991310_3\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. In other words, if the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N (where N has the value n) point to, respectively, the i + n-th and i \u2212 n-th elements of the array object, provided they exist. Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>And though the section is relevant; it does not show undefined behavior. All the elements in the array we are talking about are either within the array or one past the end (which is well defined by the above paragraph).</p>\n<h2>Argument 2:</h2>\n<p>The second argument presented below is: <code>*</code> is the de-reference operator.<br>\nAnd though this is a common term used to describe the '*' operator; this term is deliberately avoided in the standard as the term 'de-reference' is not well defined in terms of the language and what that means to the underlying hardware.</br></p>\n<p>Though accessing the memory one beyond the end of the array is definitely undefined behavior. I am not convinced the <code>unary * operator</code> accesses the memory (reads/writes to memory) <strong>in this context</strong> (not in a way the standard defines). In this context (as defined by the standard (see 5.3.1.1)) the <code>unary * operator</code> returns a <code>lvalue referring to the object</code>. In my understanding of the language this is not access to the underlying memory. The result of this expression is then immediately used by the <code>unary &amp; operator</code> operator that returns the address of the object referred to by the <code>lvalue referring to the object</code>.</p>\n<p>Many other references to Wikipedia and non canonical sources are presented. All of which I find irrelevant. <strong>C++ is defined by the standard</strong>.</p>\n<h2>Conclusion:</h2>\n<p>I am wiling to concede there are many parts of the standard that I may have not considered and may prove my above arguments wrong. <strong>NON</strong> are provided below. If you show me a standard reference that shows this is UB. I will </p>\n<ol>\n<li>Leave the answer.</li>\n<li>Put in all caps this is stupid and I am wrong for all to read.</li>\n</ol>\n<p>This is not an argument:</p>\n<blockquote>\n<p id=\"so_988158_991310_4\">Not everything in the entire world is defined by the C++ standard. Open your mind.</p>\n</blockquote>\n", "LastEditorUserId": "207421", "LastActivityDate": "2014-09-17T03:37:14.580", "Score": "3", "CreationDate": "2009-06-13T19:15:29.340", "ParentId": "988158", "CommentCount": "92", "OwnerUserId": "14065", "LastEditDate": "2014-09-17T03:37:14.580"}, "988237": {"Id": "988237", "PostTypeId": "2", "Body": "<p>If your example is NOT a general case but a specific one, then it is allowed. You can <em>legally</em>, AFAIK, move one past the allocated block of memory. \nIt does not work for a generic case though i.e where you are trying to access elements farther by 1 from the end of an array.</p>\n<p>Just searched C-Faq : <a href=\"http://c-faq.com/aryptr/non0based.html\" rel=\"nofollow noreferrer\">link text</a></p>\n", "LastEditorUserId": "95321", "LastActivityDate": "2009-06-12T19:02:18.243", "Score": "-1", "CreationDate": "2009-06-12T18:26:54.130", "ParentId": "988158", "CommentCount": "1", "OwnerUserId": "95321", "LastEditDate": "2009-06-12T19:02:18.243"}, "988408": {"Id": "988408", "PostTypeId": "2", "Body": "<p>Yes, it's legal.  From the <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"noreferrer\">C99 draft standard</a>:</p>\n<p>\u00a76.5.2.1, paragraph 2:</p>\n<blockquote>\n<p id=\"so_988158_988408_0\">A postfix expression followed by an expression in square brackets <code>[]</code> is a subscripted\n  designation of an element of an array object. The definition of the subscript operator <code>[]</code>\n  is that <code>E1[E2]</code> is identical to <code>(*((E1)+(E2)))</code>. Because of the conversion rules that\n  apply to the binary <code>+</code> operator, if <code>E1</code> is an array object (equivalently, a pointer to the\n  initial element of an array object) and <code>E2</code> is an integer, <code>E1[E2]</code> designates the <code>E2</code>-th\n  element of <code>E1</code> (counting from zero).</p>\n</blockquote>\n<p>\u00a76.5.3.2, paragraph 3 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_988158_988408_1\">The unary <code>&amp;</code> operator yields the address of its operand. If the operand has type \u2018\u2018<em>type</em>\u2019\u2019,\n  the result has type \u2018\u2018pointer to <em>type</em>\u2019\u2019. If the operand is the result of a unary <code>*</code> operator,\n  neither that operator nor the <code>&amp;</code> operator is evaluated and the result is as if both were\n  omitted, except that the constraints on the operators still apply and the result is not an\n  lvalue. Similarly, <strong>if the operand is the result of a <code>[]</code> operator, neither the &amp; operator nor the unary <code>*</code> that is implied by the <code>[]</code> is evaluated and the result is as if the <code>&amp;</code> operator\n  were removed and the <code>[]</code> operator were changed to a <code>+</code> operator</strong>. Otherwise, the result is\n  a pointer to the object or function designated by its operand.</p>\n</blockquote>\n<p>\u00a76.5.6, paragraph 8:</p>\n<blockquote>\n<p id=\"so_988158_988408_2\">When an expression that has integer type is added to or subtracted from a pointer, the\n  result has the type of the pointer operand. If the pointer operand points to an element of\n  an array object, and the array is large enough, the result points to an element offset from\n  the original element such that the difference of the subscripts of the resulting and original\n  array elements equals the integer expression. In other words, if the expression <code>P</code> points to\n  the <code>i</code>-th element of an array object, the expressions <code>(P)+N</code> (equivalently, <code>N+(P)</code>) and\n  <code>(P)-N</code> (where <code>N</code> has the value <code>n</code>) point to, respectively, the <code>i+n</code>-th and <code>i\u2212n</code>-th elements of\n  the array object, provided they exist. Moreover, if the expression <code>P</code> points to the last\n  element of an array object, the expression <code>(P)+1</code> points one past the last element of the\n  array object, and if the expression <code>Q</code> points one past the last element of an array object,\n  the expression <code>(Q)-1</code> points to the last element of the array object. If both the pointer\n  operand and the result point to elements of the same array object, or one past the last\n  element of the array object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined. If the result points one past the last element of the array object, it\n  shall not be used as the operand of a unary <code>*</code> operator that is evaluated.</p>\n</blockquote>\n<p>Note that the standard explicitly allows pointers to point one element past the end of the array, <em>provided that they are not dereferenced</em>.  By 6.5.2.1 and 6.5.3.2, the expression <code>&amp;array[5]</code> is equivalent to <code>&amp;*(array + 5)</code>, which is equivalent to <code>(array+5)</code>, which points one past the end of the array.  This does not result in a dereference (by 6.5.3.2), so it is legal.</p>\n", "LastActivityDate": "2009-06-12T18:57:57.923", "CommentCount": "13", "CreationDate": "2009-06-12T18:57:57.923", "ParentId": "988158", "Score": "37", "OwnerUserId": "9530"}, "bq_ids": {"n4140": {"so_988158_988220_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}, "so_988158_991310_1": {"length": 43, "quality": 0.7818181818181819, "section_id": 6064}, "so_988158_988220_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 5986}, "so_988158_991310_2": {"length": 5, "quality": 1.0, "section_id": 6064}, "so_988158_988210_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 6142}, "so_988158_988408_2": {"length": 106, "quality": 0.8833333333333333, "section_id": 6142}, "so_988158_988220_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 7223}, "so_988158_991310_3": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}, "so_988158_988210_0": {"length": 12, "quality": 0.631578947368421, "section_id": 6066}}, "n3337": {"so_988158_988220_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}, "so_988158_991310_1": {"length": 45, "quality": 0.8181818181818182, "section_id": 5832}, "so_988158_988220_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 5754}, "so_988158_991310_2": {"length": 5, "quality": 1.0, "section_id": 5832}, "so_988158_988210_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 5906}, "so_988158_988408_2": {"length": 106, "quality": 0.8833333333333333, "section_id": 5906}, "so_988158_988220_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 6967}, "so_988158_991310_3": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}, "so_988158_988210_0": {"length": 12, "quality": 0.631578947368421, "section_id": 5834}}, "n4659": {"so_988158_991310_1": {"length": 43, "quality": 0.7818181818181819, "section_id": 7560}, "so_988158_988220_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 7486}, "so_988158_991310_2": {"length": 5, "quality": 1.0, "section_id": 7560}, "so_988158_988220_2": {"length": 11, "quality": 0.5789473684210527, "section_id": 8732}, "so_988158_988210_0": {"length": 12, "quality": 0.631578947368421, "section_id": 7562}}}, "988254": {"Id": "988254", "PostTypeId": "2", "Body": "<p>I don't believe that it is illegal, but I do believe that the behaviour of &amp;array[5] is undefined.</p>\n<ul>\n<li><p>5.2.1 [expr.sub] E1[E2] is identical (by definition) to *((E1)+(E2))</p></li>\n<li><p>5.3.1 [expr.unary.op] unary * operator ... the result is an lvalue referring to the object or function to which the expression points.</p></li>\n</ul>\n<p>At this point you have undefined behaviour because the expression ((E1)+(E2)) didn't actually point to an object and the standard does say what the result should be unless it does.</p>\n<ul>\n<li>1.3.12 [defns.undefined] Undefined behaviour may also be expected when this International Standard omits the description of any explicit definition of behaviour.</li>\n</ul>\n<p>As noted elsewhere, <code>array + 5</code> and <code>&amp;array[0] + 5</code> are valid and well defined ways of obtaining a pointer one beyond the end of array.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2009-06-12T19:49:55.537", "Score": "8", "CreationDate": "2009-06-12T18:31:58.050", "ParentId": "988158", "CommentCount": "2", "OwnerUserId": "19563", "LastEditDate": "2009-06-12T19:49:55.537"}, "47169070": {"Id": "47169070", "PostTypeId": "2", "Body": "<p>For C++, the answer seems to be here:</p>\n<p><a href=\"http://eel.is/c++draft/conv#lval-2\" rel=\"nofollow noreferrer\">http://eel.is/c++draft/conv#lval-2</a></p>\n<blockquote>\n<p id=\"so_988158_47169070_0\">When an lvalue-to-rvalue conversion is applied to an expression e, and\n  either (2.1) e is not potentially evaluated, or (2.2) the evaluation\n  of e results in the evaluation of a member ex of the set of potential\n  results of e, and ex names a variable x that is not odr-used by ex,\n  the value contained in the referenced object is not accessed.</p>\n</blockquote>\n", "LastActivityDate": "2017-11-07T23:25:14.973", "CommentCount": "0", "CreationDate": "2017-11-07T23:25:14.973", "ParentId": "988158", "Score": "1", "OwnerUserId": "493106"}, "988199": {"Id": "988199", "PostTypeId": "2", "Body": "<p>It <strong>is</strong> legal.</p>\n<p><a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt08ch19s02.html\" rel=\"noreferrer\">According to the gcc documentation for C++</a>, <code>&amp;array[5]</code> is legal. In both C++ <a href=\"http://c-faq.com/aryptr/non0based.html\" rel=\"noreferrer\">and in C</a> you may safely address the element one past the end of an array - you will get a valid pointer. So <code>&amp;array[5]</code> as an expression is legal.</p>\n<p>However, it is still undefined behavior to attempt to dereference pointers to unallocated memory, even if the pointer points to a valid address. So attempting to dereference the pointer generated by that expression is still undefined behavior (i.e. illegal) even though the pointer itself is valid.</p>\n<p>In practice, I imagine it would usually not cause a crash, though.</p>\n<p>Edit: By the way, this is generally how the end() iterator for STL containers is implemented (as a pointer to one-past-the-end), so that's a pretty good testament to the practice being legal.</p>\n<p>Edit: Oh, now I see you're not really asking if holding a pointer to that address is legal, but if that exact way of obtaining the pointer is legal. I'll defer to the other answerers on that.</p>\n", "LastEditorUserId": "39375", "LastActivityDate": "2009-06-12T18:31:41.450", "Score": "17", "CreationDate": "2009-06-12T18:19:36.723", "ParentId": "988158", "CommentCount": "12", "OwnerUserId": "39375", "LastEditDate": "2009-06-12T18:31:41.450"}, "989299": {"Id": "989299", "PostTypeId": "2", "Body": "<p>C++ standard, 5.19, paragraph 4:</p>\n<p>An address constant expression is a pointer to an lvalue....The pointer shall be created explicitly, using the unary &amp; operator...or using an expression of array (4.2)...type.  The subscripting operator []...can be used in the creation of an address constant expression, but the value of an object shall not be accessed by the use of these operators.  If the subscripting operator is used, one of its operands shall be an integral constant expression.</p>\n<p>Looks to me like &amp;array[5] is legal C++, being an address constant expression.</p>\n", "LastActivityDate": "2009-06-12T22:11:08.600", "CommentCount": "4", "CreationDate": "2009-06-12T22:11:08.600", "ParentId": "988158", "Score": "0", "OwnerUserId": "14148"}, "988317": {"Id": "988317", "PostTypeId": "2", "Body": "<p>In addition to the above answers, I'll point out operator&amp; can be overridden for classes. So even if it was valid for PODs, it probably isn't a good idea to do for an object you know isn't valid (much like overriding operator&amp;() in the first place).</p>\n", "LastActivityDate": "2009-06-12T18:42:36.463", "CommentCount": "1", "CreationDate": "2009-06-12T18:42:36.463", "ParentId": "988158", "Score": "6", "OwnerUserId": "54858"}, "988210": {"Id": "988210", "PostTypeId": "2", "Body": "<p>Working draft (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf\" rel=\"nofollow noreferrer\">n2798</a>):</p>\n<blockquote>\n<p id=\"so_988158_988210_0\">\"The result of the unary &amp; operator is\n  a pointer to its operand. The operand\n  shall be an lvalue or a quali\ufb01ed-id.\n  In the \ufb01rst case, if the type of the\n  expression is \u201cT,\u201d the type of the\n  result is \u201cpointer to T.\u201d\" (p. 103)</p>\n</blockquote>\n<p>array[5] is not a qualified-id as best I can tell (the list is on p. 87); the closest would seem to be identifier, but while array is an identifier array[5] is not.  It is not an lvalue because \"An lvalue refers to an object or function. \" (p. 76).  array[5] is obviously not a function, and is not guaranteed to refer to a valid object (because array + 5 is after the last allocated array element).</p>\n<p>Obviously, it may work in certain cases, but it's not valid C++ or safe.</p>\n<p>Note: It is legal to add to get one past the array (p. 113):</p>\n<blockquote>\n<p id=\"so_988158_988210_1\">\"if the expression P [a pointer]\n  points to the last element of an array\n  object, the expression (P)+1 points\n  one past the last element of the array\n  object, and if the expression Q points\n  one past the last element of an array\n  object, the expression (Q)-1 points to\n  the last element of the array object.\n  If both the pointer operand and the\n  result point to elements of the same\n  array object, or one past the last\n  element of the array object, the\n  evaluation shall not produce an\n  over\ufb02ow\"</p>\n</blockquote>\n<p>But it is not legal to do so using &amp;.</p>\n", "LastEditorUserId": "47773", "LastActivityDate": "2009-06-12T21:48:08.390", "Score": "1", "CreationDate": "2009-06-12T18:22:33.283", "ParentId": "988158", "CommentCount": "8", "OwnerUserId": "47773", "LastEditDate": "2009-06-12T21:48:08.390"}, "988184": {"Id": "988184", "PostTypeId": "2", "Body": "<p>Even if it is legal, why depart from convention? array + 5 is shorter anyway, and in my opinion, more readable.</p>\n<p>Edit: If you want it to by symmetric you can write</p>\n<pre><code>int* array_begin = array; \nint* array_end = array + 5;\n</code></pre>\n", "LastEditorUserId": "72631", "LastActivityDate": "2010-03-16T20:56:59.450", "Score": "2", "CreationDate": "2009-06-12T18:14:31.600", "ParentId": "988158", "CommentCount": "3", "OwnerUserId": "72631", "LastEditDate": "2010-03-16T20:56:59.450"}, "20604161": {"Id": "20604161", "PostTypeId": "2", "Body": "<p>It should be undefined behaviour, for the following reasons:</p>\n<ol>\n<li><p>Trying to access out-of-bounds elements results in undefined behaviour. Hence the standard does not forbid an implementation throwing an exception in that case (i.e. an implementation checking bounds before an element is accessed). If <code>&amp; (array[size])</code> were defined to be <code>begin (array) + size</code>, an implementation throwing an exception in case of out-of-bound access would not conform to the standard anymore.</p></li>\n<li><p>It's impossible to make this yield <code>end (array)</code> if array is not an array but rather an arbitrary collection type.</p></li>\n</ol>\n", "LastEditorUserId": "1419315", "LastActivityDate": "2013-12-17T09:32:24.850", "Score": "1", "CreationDate": "2013-12-16T05:36:57.577", "ParentId": "988158", "CommentCount": "0", "OwnerUserId": "1419315", "LastEditDate": "2013-12-17T09:32:24.850"}, "988158": {"ViewCount": "5663", "Body": "<p>I have seen it asserted several times now that the following code is not allowed by the C++ Standard:</p>\n<pre><code>int array[5];\nint *array_begin = &amp;array[0];\nint *array_end = &amp;array[5];\n</code></pre>\n<p>Is <code>&amp;array[5]</code> legal C++ code in this context?</p>\n<p>I would like an answer with a reference to the Standard if possible.</p>\n<p>It would also be interesting to know if it meets the C standard.  And if it isn't standard C++, why was the decision made to treat it differently from <code>array + 5</code> or <code>&amp;array[4] + 1</code>?</p>\n", "AcceptedAnswerId": "988220", "Title": "Take the address of a one-past-the-end array element via subscript: legal by the C++ Standard or not?", "CreationDate": "2009-06-12T18:08:50.837", "Id": "988158", "CommentCount": "7", "FavoriteCount": "28", "PostTypeId": "1", "LastEditDate": "2016-02-13T00:02:26.037", "LastEditorUserId": "1505939", "LastActivityDate": "2017-11-07T23:25:14.973", "Score": "63", "OwnerUserId": "13422", "Tags": "<c++><c><standards><language-lawyer>", "AnswerCount": "14"}, "988220": {"Id": "988220", "PostTypeId": "2", "Body": "<p>Your example is legal, but only because you're not actually using an out of bounds pointer.</p>\n<p>Let's deal with out of bounds pointers first (because that's how I originally interpreted your question, before I noticed that the example uses a one-past-the-end pointer instead):</p>\n<p>In general, you're not even allowed to <strong>create</strong> an out-of-bounds pointer. A pointer must point to an element within the array, or <em>one past the end</em>. Nowhere else.</p>\n<p>The pointer is not even allowed to exist, which means you're obviously not allowed to dereference it either.</p>\n<p>Here's what the standard has to say on the subject:</p>\n<p>5.7:5:</p>\n<blockquote>\n<p id=\"so_988158_988220_0\">When an expression that has integral\n  type is added to or subtracted from a\n  pointer, the result has the type of\n  the pointer operand. If the pointer\n  operand points to an element of an\n  array object, and the array is large\n  enough, the result points to an\n  element offset from the original\n  element such that the difference of\n  the subscripts of the resulting and\n  original array elements equals the\n  integral expression. In other words,\n  if the expression P points to the i-th\n  element of an array object, the\n  expressions (P)+N (equivalently,\n  N+(P)) and (P)-N (where N has the\n  value n) point to, respectively, the\n  i+n-th and i\u2212n-th elements of the\n  array object, provided they exist.\n  Moreover, if the expression P points\n  to the last element of an array\n  object, the expression (P)+1 points\n  one past the last element of the array\n  object, and if the expression Q points\n  one past the last element of an array\n  object, the expression (Q)-1 points to\n  the last element of the array object.\n  If both the pointer operand and the\n  result point to elements of the same\n  array object, or one past the last\n  element of the array object, the\n  evaluation shall not produce an\n  over\ufb02ow; <strong>otherwise, the behavior is\n  unde\ufb01ned</strong>.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Of course, this is for operator+. So just to be sure, here's what the standard says about array subscripting:</p>\n<p>5.2.1:1:</p>\n<blockquote>\n<p id=\"so_988158_988220_1\">The expression <code>E1[E2]</code> is identical (by de\ufb01nition) to <code>*((E1)+(E2))</code></p>\n</blockquote>\n<p>Of course, there's an obvious caveat: Your example doesn't actually show an out-of-bounds pointer. it uses a \"one past the end\" pointer, which is different. The pointer is allowed to exist (as the above says), but the standard, as far as I can see, says nothing about dereferencing it. The closest I can find is 3.9.2:3:</p>\n<blockquote>\n<p id=\"so_988158_988220_2\">[Note: for instance, the address one past the end of an array (5.7) would be considered to\n  point to an unrelated object of the array\u2019s element type that might be located at that address. \u2014end note ]</p>\n</blockquote>\n<p>Which seems to me to imply that yes, you can legally dereference it, but the result of reading or writing to the location is unspecified.</p>\n<p>Thanks to ilproxyil for correcting the last bit here, answering the last part of your question:</p>\n<ul>\n<li><code>array + 5</code> doesn't actually\ndereference anything, it simply\ncreates a pointer to one past the end\nof <code>array</code>.</li>\n<li><code>&amp;array[4] + 1</code> dereferences\n<code>array+4</code> (which is perfectly safe),\ntakes the address of that lvalue, and\nadds one to that address, which\nresults in a one-past-the-end pointer\n(but that pointer never gets\ndereferenced.</li>\n<li><code>&amp;array[5]</code> dereferences array+5\n(which as far as I can see is legal,\nand results in \"an unrelated object\nof the array\u2019s element type\", as the\nabove said), and then takes the\naddress of that element, which also\nseems legal enough.</li>\n</ul>\n<p>So they don't do quite the same thing, although in this case, the end result is the same.</p>\n", "LastEditorUserId": "68587", "LastActivityDate": "2015-02-25T14:54:32.147", "Score": "32", "CreationDate": "2009-06-12T18:23:30.630", "ParentId": "988158", "CommentCount": "23", "OwnerUserId": "33213", "LastEditDate": "2015-02-25T14:54:32.147"}});