post_cb({"bq_ids": {"n4140": {"so_37578880_37579096_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 142}}, "n3337": {"so_37578880_37579096_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 136}}, "n4659": {"so_37578880_37579096_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 146}}}, "37579096": {"Id": "37579096", "PostTypeId": "2", "Body": "<p>I think this is a gcc bug actually, as a result of [temp.class.spec]:</p>\n<blockquote>\n<p id=\"so_37578880_37579096_0\">The type of a template parameter corresponding to a specialized\n  non-type argument shall not be dependent on a parameter of the\n  specialization. [ <em>Example:</em></p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;;       // error\n\ntemplate&lt; int X, int (*array_ptr)[X] &gt; class A {};\nint array[5];\ntemplate&lt; int X &gt; class A&lt;X,&amp;array&gt; { }; // error\n</code></pre>\n<p id=\"so_37578880_37579096_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>In your example, the type of the 3rd template parameter is dependent on a parameter. When you swap it to <code>typename = std::enable_if_t&lt;...&gt;</code>, then this rule no longer applies. </p>\n<hr/>\n<p>Note: is there any reason to use SFINAE here anyway, as opposed to <code>static_assert</code>-ing? </p>\n", "LastActivityDate": "2016-06-01T21:29:30.407", "Score": "2", "CreationDate": "2016-06-01T21:29:30.407", "ParentId": "37578880", "CommentCount": "4", "OwnerUserId": "2069064"}, "37578880": {"ViewCount": "193", "Body": "<p>This looks like an issue in clang (I've already opened a bug <a href=\"https://llvm.org/bugs/show_bug.cgi?id=27970\" rel=\"nofollow\">here</a>), but I'd like to be sure that I'm not doing a mistake.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;cstddef&gt;\n\ntemplate&lt;std::size_t N, std::size_t M, std::enable_if_t&lt;not (N&gt;M)&gt;* = nullptr&gt; // (1)\nstruct S: public S&lt;N+1, M&gt; { };\n\ntemplate&lt;std::size_t N&gt;\nstruct S&lt;N, N&gt; { };\n\nint main() {\n    S&lt;0, 1&gt; c{};\n}\n</code></pre>\n<p>It fails to compile with the following error:</p>\n<blockquote>\n<p id=\"so_37578880_37578880_0\">8 : error: non-type template argument specializes a template parameter with dependent type 'std::enable_if_t M)&gt; *' (aka 'typename enable_if M), void&gt;::type *')<br>\n  struct S { };</br></p>\n</blockquote>\n<p>The same code works as expected using the following line instead of (1):</p>\n<pre><code>template&lt;std::size_t N, std::size_t M, typename = std::enable_if_t&lt;not (N&gt;M)&gt;&gt;\n</code></pre>\n<p>The SFINAE expression is almost the same. It is based on a specialization of <code>std::enable_if_t</code> and I would expect the same result (success or failure) for both of the examples.<br>\nAre my expectations wrong?</br></p>\n<p>Note that GCC works fine in either cases.</p>\n", "AcceptedAnswerId": "37579096", "Title": "SFINAE expression fails to compile with clang", "CreationDate": "2016-06-01T21:13:48.780", "Id": "37578880", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2016-06-01T21:29:30.407", "Score": "1", "OwnerUserId": "4987285", "Tags": "<gcc><clang><c++14><sfinae><enable-if>", "AnswerCount": "1"}});