post_cb({"34362729": {"ParentId": "34323489", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The reason for this ends up being to maintain C++03 compatibility since in C++03 const integral or const enumeration types initialized with a constant expression where usable in a constant expression but this was not the case for floating point. </p>\n<p>The rationale for keeping the restriction can be found in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1826\" rel=\"nofollow\">defect report 1826</a> which came after C++11(<em>this explains the ABI break comment</em>) and asks (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_34323489_34362729_0\">A const integer initialized with a constant can be used in constant expressions, but a const floating point variable initialized with a constant cannot. This <strong>was intentional, to be compatible with C++03 while encouraging the consistent use of constexpr</strong>. Some people have found this distinction to be surprising, however.</p>\n<p id=\"so_34323489_34362729_1\"><strong>It was also observed that allowing const floating point variables as constant expressions would be an ABI-breaking change, since it would affect lambda capture.</strong></p>\n<p id=\"so_34323489_34362729_2\">One possibility might be to deprecate the use of const integral variables in constant expressions.</p>\n</blockquote>\n<p>and the response was:</p>\n<blockquote>\n<p id=\"so_34323489_34362729_3\">CWG felt that the current rules should not be changed and that programmers desiring floating point values to participate in constant expressions should use constexpr instead of const.</p>\n</blockquote>\n<p>We can note that the question points out that allowing <em>const floating point</em> variables to be constant expression would be an ABI-break with respect to lambda capture.</p>\n<p>This is the case since a lambda does not need to capture a variable if it is not odr-used and allowing const floating point variables to be constant expressions would allow them to fall under this exception. </p>\n<p>This is because an lvalue-to-rvalue conversion of a const integer or enumeration type initialized with a constant expression or a constexpr literal type is allowed in a constant expression. No such exception exists for const floating point types initialized with a constant expression. This is covered in the draft C++11 standard section <code>5.19</code>:</p>\n<blockquote>\n<p id=\"so_34323489_34362729_4\">A conditional-expression is a core constant expression unless it involves one of the following as a potentially\n  evaluated subexpression [...]</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote id=\"so_34323489_34362729_5\">\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) unless it is applied to\n  \n  <ul>\n<li>a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized\n  with a constant expression, or</li>\n<li>a glvalue of literal type that refers to a non-volatile object defined with constexpr, or that refers to a sub-object of such an\n  object, or</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Changing this would potentially effect the size of a lambda object if they no longer had to capture non-odr-used const floating point values which is an ABI break. This restriction was originally put in place to keep C++03 compatibility and to encourage the use of constexpr but now this restriction is in place it becomes hard to remove it.</p>\n<p>Note, in C++03 we were only allowed to specify an in class constant-initializer for const integral or const enumeration types. In C++11 this was expanded and we were allowed to specify constant-initializer for constexpr literal types using a brace-or-equal-initializer.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-12-18T20:18:46.820", "Id": "34362729", "Score": "2", "CreationDate": "2015-12-18T19:36:36.450", "LastActivityDate": "2015-12-18T20:18:46.820"}, "34324971": {"ParentId": "34323489", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the standard \u00a75.1.2/p12 Lambda expressions [expr.prim.lambda] (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_34323489_34324971_0\">A lambda-expression with an associated capture-default that does not\n  explicitly capture <code>this</code> or a variable with automatic storage duration\n  (this excludes any id-expression that has been found to refer to an\n  initcapture\u2019s associated non-static data member), is said to\n  implicitly capture the entity (i.e., <code>this</code> or a variable) if the\n  compound-statement: </p>\n<p id=\"so_34323489_34324971_1\">(12.1) - <strong>odr-uses (3.2) the entity</strong>, or </p>\n<p id=\"so_34323489_34324971_2\">(12.2) - names the entity in a potentially-evaluated expression (3.2) where the\n  enclosing full-expression depends on a generic lambda parameter\n  declared within the reaching scope of the lambda-expression\n  [Example:</p>\n<pre><code>void f(int, const int (&amp;)[2] = {}) { } // #1\nvoid f(const int&amp;, const int (&amp;)[1]) { } // #2\nvoid test() {\nconst int x = 17;\nauto g = [](auto a) {\nf(x); // OK: calls #1, does not capture x\n};\nauto g2 = [=](auto a) {\nint selector[sizeof(a) == 1 ? 1 : 2]{};\nf(x, selector); // OK: is a dependent expression, so captures x\n};\n}\n</code></pre>\n<p id=\"so_34323489_34324971_3\">\u2014 end example ] All such implicitly captured entities shall be\n  declared within the reaching scope of the lambda expression. [ Note:\n  The implicit capture of an entity by a nested lambda-expression can\n  cause its implicit capture by the containing lambda-expression (see\n  below). Implicit odr-uses of this can result in implicit capture. \u2014\n  end note ]</p>\n</blockquote>\n<p>What the standard states here is that a variable in a lambda needs to be captured if it is odr-used. By odr-used the standard means that the variable definition is needed, either because its address is taken or there's a reference to it.</p>\n<p>This rule however has exceptions. One of them that is of particular interest is found in the standard \u00a73.2/p3 One definition rule [basic.def.odr] (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_34323489_34324971_4\"><strong>A variable x whose name appears as a potentially-evaluated expression\n  ex is odr-used by ex unless applying the lvalue-to-rvalue conversion\n  (4.1) to x yields a constant expression (5.20)</strong> that does not invoke\n  any nontrivial functions and, if x is an object, ex is an element of\n  the set of potential results of an expression e,...</p>\n</blockquote>\n<p>Now if in the examples:</p>\n<pre><code>int main() {\n  using T = int;\n  const T x = 1;\n  auto lam = [] (T p) { return x+p; };\n}\n</code></pre>\n<p>and</p>\n<pre><code>int main() {\n  using T = double;\n  constexpr T x = 1.0;\n  auto lam = [] (T p) { return x+p; };\n}\n</code></pre>\n<p>apply an lvalue to rvalue conversion on <code>x</code> we get a constant expression since in the first example <code>x</code> is an integral constant and in the second example <code>x</code> is declared <code>constexpr</code>. Therefore, <code>x</code> doesn't need to be captured in these contexts.</p>\n<p>However, this is not the case for the example:</p>\n<pre><code>int main() {\n  using T = double;\n  const T x = 1.0;\n  auto lam = [] (T p) { return x+p; };\n}\n</code></pre>\n<p><strong>in this example if we apply lvalue to rvalue conversion to <code>x</code> we don't get a constant expression.</strong></p>\n<p>Now you might be wondering why is this the case since <code>x</code> is <code>const double</code>. Well the answer is that a variable declared without a <code>constexpr</code> qualifies as a constant expression if either is a constant integral  or an enumeration type, and is initialized at declaration time with a constant expression. This is justified by the standard in \u00a75.20/p2.7.1 Constant expressions [expr.const] (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_34323489_34324971_5\">A conditional-expression e is a core constant expression unless the\n  evaluation of e, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:</p>\n<p id=\"so_34323489_34324971_6\">...</p>\n<p id=\"so_34323489_34324971_7\">(2.7) - an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<p id=\"so_34323489_34324971_8\">(2.7.1) - a non-volatile glvalue <strong>of integral or enumeration type that\n  refers to a complete non-volatile const object with a preceding\n  initialization, initialized with a constant expression</strong>, ...</p>\n</blockquote>\n<p><strong>Thus, <code>const double</code> variables need to be captured since an lvalue-to-rvalue conversion don't yell a constant expression. Therefore rightfully you get a compiler error.</strong></p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2015-12-17T01:23:30.870", "Id": "34324971", "Score": "6", "CreationDate": "2015-12-17T01:02:56.447", "LastActivityDate": "2015-12-17T01:23:30.870"}, "34323489": {"CommentCount": "3", "AcceptedAnswerId": "34362729", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-12-16T22:38:13.073", "LastActivityDate": "2015-12-18T20:19:05.633", "LastEditDate": "2017-05-23T12:30:54.463", "ViewCount": "297", "FavoriteCount": "1", "Title": "Why type const double is not captured by lambda from reaching-scope, but const int is?", "Id": "34323489", "Score": "6", "Body": "<p>I seem can't understand why the following code with type const int compiles:</p>\n<pre><code>int main()\n{\n  using T = int;\n  const T x = 1;\n  auto lam = [] (T p) { return x+p; };\n}\n$ clang++ -c lambda1.cpp  -std=c++11\n$\n</code></pre>\n<p>while this one with type const double doesn't:</p>\n<pre><code>int main()\n{\n  using T = double;\n  const T x = 1.0;\n  auto lam = [] (T p) { return x+p; };\n}\n$ clang++ -c lambda2.cpp  -std=c++11\nlambda1.cpp:5:32: error: variable 'x' cannot be implicitly captured in a lambda with no capture-default specified\n  auto lam = [] (T p) { return x+p; };\n                               ^\nlambda1.cpp:4:11: note: 'x' declared here\n  const T x = 1.0;\n          ^\nlambda1.cpp:5:14: note: lambda expression begins here\n  auto lam = [] (T p) { return x+p; };\n             ^\n1 error generated.\n</code></pre>\n<p>yet compiles with constexpr double:</p>\n<pre><code>int main()\n{\n  using T = double;\n  constexpr T x = 1.0;\n  auto lam = [] (T p) { return x+p; };\n}\n$ clang++ -c lambda3.cpp  -std=c++11\n$\n</code></pre>\n<p>Why behaviour for int differs from double, or for any other type than int, i.e. int is accepted with const qualifier, yet double/other types must be constexpr? Also, why this code compiles with C++11, my understanding from [1] is that such implicit captures is C++14 feature.</p>\n<p>.. [1] <a href=\"https://stackoverflow.com/questions/33849718/how-is-this-lambda-with-an-empty-capture-list-able-to-refer-to-reaching-scope-na\">how is this lambda with an empty capture list able to refer to reaching-scope name?</a></p>\n", "Tags": "<c++><c++11><lambda><constexpr>", "OwnerUserId": "5153458", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34323489_34324971_8": {"section_id": 6185, "quality": 0.875, "length": 14}, "so_34323489_34324971_0": {"section_id": 5971, "quality": 0.9615384615384616, "length": 25}, "so_34323489_34324971_3": {"section_id": 5971, "quality": 0.8378378378378378, "length": 31}, "so_34323489_34324971_5": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_34323489_34362729_4": {"section_id": 6185, "quality": 0.6, "length": 6}, "so_34323489_34362729_5": {"section_id": 6185, "quality": 0.9285714285714286, "length": 26}, "so_34323489_34324971_4": {"section_id": 7040, "quality": 0.9166666666666666, "length": 22}, "so_34323489_34324971_2": {"section_id": 5971, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_34323489_34362729_4": {"section_id": 5946, "quality": 0.9, "length": 9}, "so_34323489_34324971_8": {"section_id": 5946, "quality": 0.8125, "length": 13}, "so_34323489_34324971_3": {"section_id": 5739, "quality": 0.7567567567567568, "length": 28}, "so_34323489_34362729_5": {"section_id": 5946, "quality": 1.0, "length": 28}}, "n4659": {"so_34323489_34324971_5": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_34323489_34324971_0": {"section_id": 7470, "quality": 0.9230769230769231, "length": 24}, "so_34323489_34324971_3": {"section_id": 7470, "quality": 0.8378378378378378, "length": 31}, "so_34323489_34324971_8": {"section_id": 7687, "quality": 0.9375, "length": 15}, "so_34323489_34362729_5": {"section_id": 7687, "quality": 0.9642857142857143, "length": 27}, "so_34323489_34324971_4": {"section_id": 8537, "quality": 0.9166666666666666, "length": 22}, "so_34323489_34324971_2": {"section_id": 7470, "quality": 0.8888888888888888, "length": 16}}}});