post_cb({"41519368": {"CommentCount": "3", "AcceptedAnswerId": "41523082", "PostTypeId": "1", "LastEditorUserId": "508343", "CreationDate": "2017-01-07T08:18:18.593", "LastActivityDate": "2017-01-07T15:32:18.077", "LastEditDate": "2017-01-07T11:36:30.130", "ViewCount": "266", "FavoriteCount": "1", "Title": "Is the sub-object of a temporary object guaranteed to be moved on return?", "Id": "41519368", "Score": "11", "Body": "<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nauto f()\n{\n    vector&lt;string&gt; coll{ \"hello\" };\n\n    //\n    // Must I use move(coll[0]) ?\n    //\n    return coll[0]; \n}\n\nint main()\n{\n    auto s = f();\n    DoSomething(s);\n}\n</code></pre>\n<p>I know: If I just <code>return coll;</code>, then <code>coll</code> is guaranteed to be moved on return.</p>\n<p>However, I am not sure: <strong>Whether <code>coll[0]</code> is also guaranteed to be moved on return?</strong></p>\n<p><strong>Update:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    A() { std::cout &lt;&lt; \"constructed\\n\"; }\n    A(const A&amp;) { std::cout &lt;&lt; \"copy-constructed\\n\"; }\n    A(A&amp;&amp;) { std::cout &lt;&lt; \"move-constructed\\n\"; }\n    ~A() { std::cout &lt;&lt; \"destructed\\n\"; }\n};\n\nstruct B\n{\n    A a;\n};\n\nA f()\n{\n    B b;\n    return b.a;\n}\n\nint main()\n{\n    f();\n}\n</code></pre>\n<p>gcc 6.2 and clang 3.8 outputs the same:</p>\n<blockquote>\n<p id=\"so_41519368_41519368_0\">constructed</p>\n<p id=\"so_41519368_41519368_1\">copy-constructed</p>\n<p id=\"so_41519368_41519368_2\">destructed</p>\n<p id=\"so_41519368_41519368_3\">destructed</p>\n</blockquote>\n", "Tags": "<c++><c++11><standards><move-semantics>", "OwnerUserId": "508343", "AnswerCount": "2"}, "41520375": {"ParentId": "41519368", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>When returning a <strong>local object</strong>, neither a copy nor a move will be used, but copy elision, which is to be preferred over moving. This is because the rules governing copy elision and moving of local objects are the same. When instead forcing a move by explicitly using <code>std::move</code> as in</p>\n<pre><code>template&lt;typename T&gt;\nstd::string make_string(T const&amp; x)\n{\n  std::ostringstream str;\n  str &lt;&lt; x\n  return std::move(str.str());    // not recommended\n}\n</code></pre>\n<p>recent versions of clang issue a warning </p>\n<blockquote>\n<p id=\"so_41519368_41520375_0\">moving a temporary object prevents copy elision [-Wpessimizing-move]</p>\n</blockquote>\n<p>However, the <strong>situation in your code is different</strong>. Unlike <code>std::ostringstream::str()</code>, which returns an object (a <code>std::string</code>), <code>std::vector&lt;&gt;::operator[]</code>, returns a reference, which must be converted to an object (since <code>auto</code> removes references). In this case, copy elision is not possible (because the actual object is part of another object with non-trivial destructor) and <code>std::move()</code> should be used to avoid a copy.</p>\n<p>These considerations suggest to use <code>std::move()</code> if unsure, but remove it if clang issues above warning.</p>\n", "OwnerUserId": "1023390", "LastEditorUserId": "1023390", "LastEditDate": "2017-01-07T11:15:33.347", "Id": "41520375", "Score": "4", "CreationDate": "2017-01-07T10:26:36.610", "LastActivityDate": "2017-01-07T11:15:33.347"}, "bq_ids": {"n4140": {"so_41519368_41520375_0": {"section_id": 480, "quality": 0.5714285714285714, "length": 4}, "so_41519368_41523082_1": {"section_id": 481, "quality": 0.9473684210526315, "length": 18}, "so_41519368_41523082_3": {"section_id": 481, "quality": 1.0, "length": 35}}, "n3337": {"so_41519368_41523082_3": {"section_id": 472, "quality": 0.9142857142857143, "length": 32}}, "n4659": {"so_41519368_41523082_0": {"section_id": 504, "quality": 1.0, "length": 9}, "so_41519368_41523082_1": {"section_id": 504, "quality": 0.9473684210526315, "length": 18}, "so_41519368_41523082_3": {"section_id": 504, "quality": 1.0, "length": 35}}}, "41523082": {"ParentId": "41519368", "CommentCount": "0", "Body": "<p>The cleanest formulation of the \"implicit move\" rule is in <a href=\"https://timsong-cpp.github.io/cppwp/class.copy.elision#3\" rel=\"nofollow noreferrer\">[class.copy.elision]/3</a> of the current working paper:</p>\n<blockquote>\n<p id=\"so_41519368_41523082_0\">In the following copy-initialization contexts, a move operation might\n  be used instead of a copy operation:</p>\n<ul>\n<li><p id=\"so_41519368_41523082_1\">If the <em>expression</em> in a return statement ([stmt.return]) is a (possibly parenthesized) <em>id-expression</em> that names an object with\n  automatic storage duration declared in the body or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em>, or</p></li>\n<li><p id=\"so_41519368_41523082_2\">[...]</p></li>\n</ul>\n<p id=\"so_41519368_41523082_3\">overload resolution to select the constructor for the copy is first\n  performed as if the object were designated by an rvalue. If the first\n  overload resolution fails or was not performed, or if the type of the\n  first parameter of the selected constructor is not an rvalue reference\n  to the object's type (possibly cv-qualified), overload resolution is\n  performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>Neither <code>b.a</code> nor <code>coll[0]</code> is an <em>id-expression</em>. Therefore, there is no implicit move. If you want a move, you'll have to do it explicitly.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "41523082", "Score": "3", "CreationDate": "2017-01-07T15:32:18.077", "LastActivityDate": "2017-01-07T15:32:18.077"}});