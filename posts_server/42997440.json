post_cb({"42997785": {"ParentId": "42997440", "CommentCount": "8", "Body": "<p>You've actually asked 3 different questions :)</p>\n<p><strong>1. The contract of immutability</strong></p>\n<p>It's just that - a contract, not a language construct. </p>\n<p>In Java for instance, instances of String class are immutable. But that means that all methods of the class have been designed to return new instances of class rather than modifying the instance.</p>\n<p>So if you would like to make Java's String into a mutable object, you couldn't, without having access to its source code.</p>\n<p>Same applies to classes written in C++, or any other language. You have an option to create a <em>wrapper</em> (or use a Proxy pattern), but that's it.</p>\n<p><strong>2. Using placement constructor and allocating into an initialized are off memory.</strong></p>\n<p>That's actually what they were created to do in the first place.\nThe most common use case for the placement constructor are <em>memory pools</em> - you preallocate a large memory buffer, and then you allocate your stuff into it.</p>\n<p>So yes - it is legal, and nobody won't mind.</p>\n<p><strong>3. Overwriting class instance's contents using a placement allocator.</strong></p>\n<p>Don't do that.</p>\n<p>There's a special construct that handles this type of operation, and it's called <em>a copy constructor</em>.</p>\n", "OwnerUserId": "557384", "PostTypeId": "2", "Id": "42997785", "Score": "0", "CreationDate": "2017-03-24T11:00:39.117", "LastActivityDate": "2017-03-24T11:00:39.117"}, "42997720": {"ParentId": "42997440", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From the C++ standard draft N4296:</p>\n<blockquote>\n<p id=\"so_42997440_42997720_0\"><strong>3.8 Object lifetime</strong><br>\n  [...]<br>\n  The lifetime of an object of type T ends when:<br>\n  (1.3) \u2014 if T is a class\n  type with a non-trivial destructor (12.4), the destructor call starts,\n  or<br>\n  (1.4) \u2014 the storage which the object occupies is reused or\n  released.<br>\n  [...]<br>\n  4 A program may end the lifetime of any object by\n  reusing the storage which the object occupies or by explicitly calling\n  the destructor for an object of a class type with a non-trivial\n  destructor. For an object of a class type with a non-trivial\n  destructor, the program is not required to call the destructor\n  explicitly before the storage which the object occupies is reused or\n  released; however, if there is no explicit call to the destructor or\n  if a delete-expression (5.3.5) is not used to release the storage, the\n  destructor shall not be implicitly called and any program that depends\n  on the side effects produced by the destructor has undefined behavior.</br></br></br></br></br></br></p>\n</blockquote>\n<p>So yes, you can end the lifetime of an object by reusing its memory, even of one with non-trivial destructor, as long as you don't depend on the side effects of the destructor call.</p>\n<p><sub>This applies when you have non-const instances of objects like <code>struct ImmutableBounds { const void* start; const void* end; }</code></sub></p>\n", "OwnerUserId": "3435400", "LastEditorUserId": "3435400", "LastEditDate": "2017-03-24T13:48:51.100", "Id": "42997720", "Score": "2", "CreationDate": "2017-03-24T10:57:25.627", "LastActivityDate": "2017-03-24T13:48:51.100"}, "43001282": {"ParentId": "42997440", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>What you wrote is technically legal but almost certainly useless.</p>\n<p>Suppose</p>\n<pre><code>struct Immutable {\n  const int x;\n  Immutable(int val):x(val) {}\n};\n</code></pre>\n<p>for our really simple immutable type.</p>\n<pre><code>auto var = Immutable(0);\n::new (&amp;var) Immutable(1);\n</code></pre>\n<p>this is perfectly legal.</p>\n<p>And useless, because you cannot use <code>var</code> to refer to the state of the <code>Immutable(1)</code> you stored within it after the placement <code>new</code>.  Any such access is undefined behavior.</p>\n<p>You can do this:</p>\n<pre><code>auto var = Immutable(0);\nauto* pvar1 = ::new (&amp;var) Immutable(1);\n</code></pre>\n<p>and access to <code>*pvar1</code> is legal.  You can even do:</p>\n<pre><code>auto var = Immutable(0);\nauto&amp; var1 = *(::new (&amp;var) Immutable(1));\n</code></pre>\n<p>but under no circumstance may you ever refer to <code>var</code> after you placement new'd over it.</p>\n<p>Actual <code>const</code> data in C++ is a promise to the compiler that you'll never, ever change the value.  This is in comparison to references to const or pointers to const, which is just a suggestion that you won't modify the data.</p>\n<p>Members of structures declared <code>const</code> are \"actually const\".  The compiler will presume they are never modified, and won't bother to prove it.</p>\n<p>You creating a new instance in the spot where an old one was in effect violates this assumption.</p>\n<p>You are permitted to do this, but <em>you cannot use the old names or pointers</em> to refer to it.  C++ lets you shoot yourself in the foot.  Go right ahead, we dare you.</p>\n<p>This is why this technique is legal, but almost completely useless.  A good optimizer with static single assignment already knows that you would stop using <code>var</code> at that point, and creating</p>\n<pre><code>auto var1 = Immutable(1);\n</code></pre>\n<p>it could very well reuse the storage.</p>\n<hr>\n<p>Caling placement new on top of another variable is usually defined behaviour.  It is usually a bad idea, and it is <strong>fragile</strong>.</p>\n<p>Doing so ends the lifetime of the old object without calling the destructor.  References and pointers to and the name of the old object refer to the new one if some specific assumptions hold (exact same type, no const problems).</p>\n<p>Modifying data declared const, or a class containing <code>const</code> fields, results in undefined behaviour at the drop of a pin.  This includes ending the lifetime of an automatic storage field declared const and creating a new object at that location.  The old names and pointers and references are not safe to use.</p>\n<h1>[Basic.life 3.8]/8:</h1>\n<blockquote>\n<p id=\"so_42997440_43001282_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or\n  released, a new object is created at the storage location which the original object occupied, a pointer that\n  pointed to the original object, a reference that referred to the original object, or the name of the original\n  object will automatically refer to the new object and, once the lifetime of the new object has started, can be\n  used to manipulate the new object, if:</p>\n<ul>\n<li><p id=\"so_42997440_43001282_1\">(8.1)\n  the storage for the new object exactly overlays the storage location which the original object occupied,\n  and</p></li>\n<li><p id=\"so_42997440_43001282_2\">(8.2)\n  the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p></li>\n<li><p id=\"so_42997440_43001282_3\">(8.3)\n  the type of the original object is not const-qualified, and, if a class type, does not contain any non-static\n  data member whose type is const-qualified or a reference type, and</p></li>\n<li><p id=\"so_42997440_43001282_4\">(8.4)\n  the original object was a most derived object (1.8) of type\n  T\n  and the new object is a most derived\n  object of type\n  T\n  (that is, they are not base class subobjects).</p></li>\n</ul>\n</blockquote>\n<p>In short, if your immutability is encoded via <code>const</code> members, using the old name <em>or</em> pointers to the old content is <strong>undefined behavior</strong>.</p>\n<p>You may use the return value of placement new to refer to the new object, and nothing else.</p>\n<hr>\n<p>Exception possibilities make it extremely difficult to prevent code that exdcutes undefined behaviour or has to summarially exit.</p>\n<p>If you want reference semantics, either use a smart pointer to a const object or an optional const object.  Both handle object lifetime.  The first requires heap allocation but permits move (and possibly shared references), the second permits automatic storage.  Both move meanual object lifetime management out of business logic.  Now, both are nullable, but avoiding that robustly is difficult doing it manually anyhow.</p>\n<p>Also consider copy on write pointers that permit logically const data with mutation for efficiency purposes.</p>\n</hr></hr>", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2017-03-24T14:44:22.457", "Id": "43001282", "Score": "5", "CreationDate": "2017-03-24T13:53:04.203", "LastActivityDate": "2017-03-24T14:44:22.457"}, "bq_ids": {"n4140": {"so_42997440_43001282_2": {"section_id": 7195, "quality": 1.0, "length": 9}, "so_42997440_43001282_4": {"section_id": 7195, "quality": 1.0, "length": 17}, "so_42997440_43001282_3": {"section_id": 7195, "quality": 1.0, "length": 16}, "so_42997440_43001282_0": {"section_id": 7195, "quality": 1.0, "length": 43}, "so_42997440_43001282_1": {"section_id": 7195, "quality": 1.0, "length": 10}, "so_42997440_42997720_0": {"section_id": 7192, "quality": 0.6805555555555556, "length": 49}}, "n3337": {"so_42997440_43001282_2": {"section_id": 6939, "quality": 1.0, "length": 9}, "so_42997440_43001282_4": {"section_id": 6939, "quality": 1.0, "length": 17}, "so_42997440_43001282_3": {"section_id": 6939, "quality": 1.0, "length": 16}, "so_42997440_43001282_0": {"section_id": 6939, "quality": 1.0, "length": 43}, "so_42997440_43001282_1": {"section_id": 6939, "quality": 1.0, "length": 10}, "so_42997440_42997720_0": {"section_id": 6936, "quality": 0.6805555555555556, "length": 49}}, "n4659": {"so_42997440_43001282_2": {"section_id": 8704, "quality": 1.0, "length": 9}, "so_42997440_43001282_4": {"section_id": 8704, "quality": 1.0, "length": 17}, "so_42997440_43001282_3": {"section_id": 8704, "quality": 1.0, "length": 16}, "so_42997440_43001282_0": {"section_id": 8704, "quality": 1.0, "length": 43}, "so_42997440_42997720_0": {"section_id": 8701, "quality": 0.6805555555555556, "length": 49}, "so_42997440_43001282_1": {"section_id": 8704, "quality": 1.0, "length": 10}}}, "42997440": {"CommentCount": "6", "ViewCount": "143", "CreationDate": "2017-03-24T10:44:33.663", "LastActivityDate": "2017-03-24T14:44:22.457", "Title": "Is it legal to use placement new on initialised memory?", "AcceptedAnswerId": "43001282", "PostTypeId": "1", "Id": "42997440", "Score": "2", "Body": "<p>I am exploring the possibility of implementing true (partially) immutable data structures in C++. As C++ does not seem to distinguish between a variable and the object that variable stores, the only way to truly replace the object (without assignment operation!) is to use placement new:</p>\n<pre><code>auto var = Immutable(state0);\n// the following is illegal as it requires assignment to\n// an immutable object\nvar = Immutable(state1);\n// however, the following would work as it constructs a new object\n// in place of the old one\nnew (&amp;var) Immutable(state1);\n</code></pre>\n<p>Assuming that there is no non-trivial destructor to run, is this legal in C++ or should I expect undefined behaviour? If its standard-dependant, which is the minimal/maximal standard version where I can expect this to work? </p>\n", "Tags": "<c++><memory><language-lawyer><placement-new>", "OwnerUserId": "3145469", "AnswerCount": "3"}});