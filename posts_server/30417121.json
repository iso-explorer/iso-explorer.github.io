post_cb({"30417151": {"ParentId": "30417121", "CommentCount": "2", "Body": "<p>Your compiler is out of date. From the C++03 standard,</p>\n<blockquote>\n<p id=\"so_30417121_30417151_0\">An object\n  of a class with a non-trivial constructor (12.1), a non-trivial copy constructor (12.8), a non-trivial destructor\n  (12.4), or a non-trivial copy assignment operator (13.5.3, 12.8) cannot be a member of a union, nor can an\n  array of such objects.</p>\n</blockquote>\n<p>However, this restriction has been removed in C++11. Instead there is a note:</p>\n<blockquote>\n<p id=\"so_30417121_30417151_1\">[ <em>Note:</em> If any non-static data member of a union has a non-trivial default\n  constructor (12.1), copy constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move\n  assignment operator (12.8), or destructor (12.4), the corresponding member function of the union must be\n  user-provided or it will be implicitly deleted (8.4.3) for the union. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>So it's saying that, sure, you can put something with a non-trivial copy constructor inside a union, but then the union will not be copyable unless you write a copy constructor for it yourself.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "30417151", "Score": "8", "CreationDate": "2015-05-23T20:16:20.553", "LastActivityDate": "2015-05-23T20:16:20.553"}, "30417121": {"CommentCount": "0", "AcceptedAnswerId": "30417151", "PostTypeId": "1", "LastEditorUserId": "2013747", "CreationDate": "2015-05-23T20:12:25.667", "LastActivityDate": "2015-05-24T14:50:40.930", "LastEditDate": "2015-05-23T20:31:15.300", "ViewCount": "179", "FavoriteCount": "1", "Title": "Is it legal to store an STL iterator inside a union?", "Id": "30417121", "Score": "2", "Body": "<p>Does any C++ standard guarantee that STL iterators can be stored in a union? If so, which standard?</p>\n<p>For example:</p>\n<pre><code>union MyUnion {\n   std::vector&lt;int&gt;::iterator iter;\n   size_t size;\n};\n</code></pre>\n<p>The reason that I ask is that I'm porting someone else's code that stores <code>std::vector</code> and <code>std::map</code> iterators in unions, and MSVC2013 doesn't seem to like it. I'm getting error C2621: illegal union member; type ... has a copy constructor. I would like to determine whether this is a bug in the code, a bug in the MS STL implementation, or a bug in my compiler.</p>\n<p>Many thanks!</p>\n", "Tags": "<c++><stl><unions>", "OwnerUserId": "2013747", "AnswerCount": "2"}, "30417415": {"ParentId": "30417121", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Thanks to Brian's answer I was able to research more about this topic.</p>\n<p>The C++11 feature that is being used is called <em>unrestricted unions</em>. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf\" rel=\"nofollow\">In case you're interested, here is the working group proposal</a>.</p>\n<p>According to <a href=\"https://msdn.microsoft.com/en-us/library/hh567368.aspx\" rel=\"nofollow\">this page at MSDN</a>, MSVC 2013 and earlier do not support unrestricted unions.</p>\n<p><a href=\"http://blogs.msdn.com/b/vcblog/archive/2014/06/03/visual-studio-14-ctp.aspx\" rel=\"nofollow\">Visual Studio 2014 CTP does support unrestricted unions</a>.</p>\n", "OwnerUserId": "2013747", "LastEditorUserId": "2013747", "LastEditDate": "2015-05-24T14:50:40.930", "Id": "30417415", "Score": "1", "CreationDate": "2015-05-23T20:45:53.680", "LastActivityDate": "2015-05-24T14:50:40.930"}, "bq_ids": {"n4140": {"so_30417121_30417151_1": {"section_id": 5914, "quality": 0.7368421052631579, "length": 28}}, "n3337": {"so_30417121_30417151_1": {"section_id": 5686, "quality": 0.7368421052631579, "length": 28}}, "n4659": {"so_30417121_30417151_1": {"section_id": 7406, "quality": 0.7368421052631579, "length": 28}}}});