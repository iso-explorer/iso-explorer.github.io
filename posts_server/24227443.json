post_cb({"24227514": {"ParentId": "24227443", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The definition of equivalence for <code>std::set</code> when you supply a comparer is <code>!comp(a,b) &amp;&amp; !comp(b,a)</code>. With your comparison function, you won't be able to insert two <code>Task *</code>s with the same priority, because they are equivalent by that definition.</p>\n<p>What you want is <code>std::multiset</code> - in particular, C++11 <code>std::multiset</code>, because its <code>insert()</code> has this guarantee not included in C++03 (<a href=\"http://en.cppreference.com/w/cpp/container/multiset/insert\" rel=\"nofollow\">ref</a>; this is required by \u00a723.2.4 [associative.reqmts], Table 102 of the standard):</p>\n<blockquote>\n<p id=\"so_24227443_24227514_0\">If the container has elements with equivalent key, inserts at the upper bound of that range.</p>\n</blockquote>\n<p>This means that the newly inserted element will always be after the equivalent elements that are already in the container.</p>\n<p>Note that the standard ordered associative containers sort in non-descending order, so you'll need to change your functor if you want tasks sorted by decreasing priority.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-03T09:07:12.263", "Id": "24227514", "Score": "4", "CreationDate": "2014-06-15T07:35:10.980", "LastActivityDate": "2014-08-03T09:07:12.263"}, "24227443": {"CommentCount": "0", "ViewCount": "288", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2014-06-15T07:22:47.303", "LastActivityDate": "2014-08-03T09:07:12.263", "Title": "A set with custom comparison functor, predictable in case of equality", "AcceptedAnswerId": "24227514", "LastEditDate": "2014-06-15T16:01:13.877", "Id": "24227443", "Score": "2", "Body": "<p>I'm trying to build a <code>std::set</code> with a custom ordering to store \"tasks\" inside, and I'm wondering wether or not it'll be possible to get what I need with a plain <code>std</code> container.</p>\n<p>The set is like:</p>\n<pre><code>std::set&lt;Task*, CompareTasks&gt; taskList;\n</code></pre>\n<p>And <code>class Task</code> has a public <code>double priority</code> member.</p>\n<p>What I need:</p>\n<ul>\n<li>EDIT: each task <code>Task *</code> must be unique within the <code>taskList</code></li>\n<li>the tasks must be sorted in decreasing <code>priority</code>.</li>\n<li>if <code>task2</code> happens to share the same <code>priority</code> with <code>task1</code> already in the list, then \"<em>first come first served</em>\": <code>task2</code> must be inserted <em>after</em> <code>task1</code>.</li>\n</ul>\n<p>I tried with the functor:</p>\n<pre><code>class CompareTasks\n{\npublic:\n    bool operator()(Task* const&amp; a, Task* const&amp; b)\n    {\n        return a-&gt;priority &lt; b-&gt;priority;\n    }\n};\n</code></pre>\n<p>But tasks I then insert, that have an already recorded <code>priority</code>, are just.. not inserted at all. And I thus suspect that the keys of <code>taskList</code> are the priorities themselves and not the pointer values <code>Task*</code> as written in <code>std::set&lt;Task*, CompareTasks&gt;</code>. How can I check whether it's the case?</p>\n<p>More dramatically: Since the ordering must be <strong>weak</strong> in creating comparison functors for <code>std</code> containers, is there any way I'll be able to achieve this with only <code>std::set</code>?</p>\n", "Tags": "<c++><set><comparison><key>", "OwnerUserId": "3719101", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24227443_24227514_0": {"section_id": 763, "quality": 0.875, "length": 7}}, "n3337": {"so_24227443_24227514_0": {"section_id": 750, "quality": 0.875, "length": 7}}, "n4659": {"so_24227443_24227514_0": {"section_id": 823, "quality": 0.875, "length": 7}}}});