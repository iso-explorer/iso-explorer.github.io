post_cb({"45990793": {"CommentCount": "0", "ViewCount": "54", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2017-08-31T22:11:06.433", "LastActivityDate": "2017-08-31T23:06:41.217", "Title": "C++: implementation-defined accepted physical source file characters", "LastEditDate": "2017-08-31T23:06:41.217", "Id": "45990793", "Score": "1", "Body": "<p>According to the C++14 standard, </p>\n<blockquote>\n<p id=\"so_45990793_45990793_0\"><strong>\u00a72.2.1.1</strong> [...] The set of physical source file characters accepted is\n  implementation-defined. [...] Any source file character not in the\n  basic source character set is replaced by the universal-character-name\n  that designates that character. [...]</p>\n</blockquote>\n<p>Does it means that the C++ standard gives not implementation-defined or conditionally-supported support for non UCS/Unicode characters? For example, a physical source file encoding including characters without  corresponding UCS code point.</p>\n<p>The only think I can think of is, if that were the case (the compiler supports non UCS character through non UCS encodings), the compiler had to use the private UCS ranges to map those physical characters, but anyway, that solution doesn't fit to the <em>\"universal-character-name that designates that character\"</em> part, because UCS code points inside private ranges doesn't define any specific character at all.</p>\n", "Tags": "<c++><unicode><c++14><ucs>", "OwnerUserId": "1794803", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45990793_45990884_1": {"section_id": 5313, "quality": 0.75, "length": 6}, "so_45990793_45990884_0": {"section_id": 5313, "quality": 1.0, "length": 9}, "so_45990793_45990793_0": {"section_id": 5313, "quality": 0.7619047619047619, "length": 16}}, "n3337": {"so_45990793_45990884_1": {"section_id": 5110, "quality": 0.75, "length": 6}, "so_45990793_45990884_0": {"section_id": 5110, "quality": 1.0, "length": 9}, "so_45990793_45990793_0": {"section_id": 5110, "quality": 0.7619047619047619, "length": 16}}, "n4659": {"so_45990793_45990884_0": {"section_id": 6737, "quality": 1.0, "length": 9}, "so_45990793_45990884_1": {"section_id": 6737, "quality": 0.75, "length": 6}, "so_45990793_45990793_0": {"section_id": 6737, "quality": 0.7619047619047619, "length": 16}}}, "45990884": {"ParentId": "45990793", "CommentCount": "4", "Body": "<p><strike>Not really.</strike>. Kind of. The important part of the [lex.phases] quote IMO is as follows:</p>\n<blockquote>\n<p id=\"so_45990793_45990884_0\">Physical source file characters are mapped, [...], to the basic source\n  character set</p>\n</blockquote>\n<p>Only the basic source character set is supported, everything else must be somehow mapped to it ([lex.charset]):</p>\n<pre><code>a b c d e f g h i j k l m n o p q r s t u v w x y z\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n0 1 2 3 4 5 6 7 8 9\n_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \\ \" \u2019\n</code></pre>\n<p>But the standard also says it should do this <strong>if necessary</strong>. It goes on to say the following:</p>\n<blockquote>\n<p id=\"so_45990793_45990884_1\">The set of physical\n  source file characters accepted is implementation-defined.</p>\n</blockquote>\n<p>So I suppose that allows a compiler to do whatever it wants in the end so long as it <em>at least</em> supports the basic character set.</p>\n", "OwnerUserId": "27678", "PostTypeId": "2", "Id": "45990884", "Score": "1", "CreationDate": "2017-08-31T22:20:12.507", "LastActivityDate": "2017-08-31T22:20:12.507"}});