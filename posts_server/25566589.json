post_cb({"25566832": {"Id": "25566832", "PostTypeId": "2", "Body": "<p>\u00a79 [class]/p11:</p>\n<blockquote>\n<p id=\"so_25566589_25566832_0\">If a <em>class-head-name</em> contains a <em>nested-name-specifier</em>, the\n  <em>class-specifier</em> shall refer to a class that was previously declared directly in the class or namespace to which the\n  <em>nested-name-specifier</em> refers, or in an element of the inline namespace set (7.3.1) of that namespace (i.e., not merely inherited or\n  introduced by a <em>using-declaration</em>), and the <em>class-specifier</em> shall\n  appear in a namespace enclosing the previous declaration. In such\n  cases, the <em>nested-name-specifier</em> of the <em>class-head-name</em> of the\n  definition shall not begin with a <em>decltype-specifier</em>.</p>\n</blockquote>\n<p><em>class-head-name</em> is the term for the thing that names the class being defined. <em>nested-name-specifier</em> is the standardese for \"everything to the left of <code>::</code>, including the <code>::</code> itself\".</p>\n", "LastActivityDate": "2014-08-29T10:52:38.480", "CommentCount": "0", "CreationDate": "2014-08-29T10:52:38.480", "ParentId": "25566589", "Score": "0", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_25566589_25566724_0": {"length": 30, "quality": 0.967741935483871, "section_id": 5484}, "so_25566589_25566832_0": {"length": 36, "quality": 0.972972972972973, "section_id": 5855}}, "n3337": {"so_25566589_25566724_0": {"length": 30, "quality": 0.967741935483871, "section_id": 5270}, "so_25566589_25566832_0": {"length": 36, "quality": 0.972972972972973, "section_id": 5625}}, "n4659": {"so_25566589_25566724_0": {"length": 30, "quality": 0.967741935483871, "section_id": 6919}, "so_25566589_25566832_0": {"length": 36, "quality": 0.972972972972973, "section_id": 7334}}}, "25566964": {"Id": "25566964", "PostTypeId": "2", "Body": "<p>Perhaps this quote from Bjarne Stroustrup's book could serve you.</p>\n<p>From chapter 14 of <a href=\"http://www.stroustrup.com/4th.html\" rel=\"nofollow\">The C++ Programming Language, Fourth Edition</a>:</p>\n<p>----- (page 392)</p>\n<blockquote>\n<p id=\"so_25566589_25566964_0\">[...]</p>\n<p id=\"so_25566589_25566964_1\"><strong>14.2.1 Explicit Qualification</strong></p>\n<p id=\"so_25566589_25566964_2\">A member can be declared winthin a namespace definition and defined later using the\n  namespace-name::member-name notation.</p>\n<p id=\"so_25566589_25566964_3\">Members of a namespace must be\n  introduced using this notation:</p>\n</blockquote>\n<pre><code>namespace namespace-name {\n   // declarations and definitions\n}\n</code></pre>\n<blockquote>\n<p id=\"so_25566589_25566964_4\">For example:</p>\n</blockquote>\n<pre><code>namespace Parser {\n     double expr(bool); //declaration\n     double term(bool);\n     double prim(bool);\n}\n\ndouble val = Parser::expr(true); // use\n\ndouble Parser::expr(bool b) //definition\n{\n    // ...\n}\n</code></pre>\n<blockquote>\n<p id=\"so_25566589_25566964_5\">We cannot declare a new member of a namespace outside a namespace definition using the qualifier syntax (iso.7.3.1.2)....</p>\n</blockquote>\n", "LastActivityDate": "2014-08-29T11:00:40.740", "CommentCount": "1", "CreationDate": "2014-08-29T11:00:40.740", "ParentId": "25566589", "Score": "1", "OwnerUserId": "3078174"}, "25566724": {"Id": "25566724", "PostTypeId": "2", "Body": "<p>Yes, style 1 is valid.</p>\n<p><code>[namespace.memdef]/2</code> states:</p>\n<blockquote>\n<p id=\"so_25566589_25566724_0\">Members of a named namespace can also be defined outside that namespace by explicit qualification (3.4.3.2)\n  of the name being defined, provided that the entity being defined was already declared in the namespace\n  and the definition appears after the point of declaration in a namespace that encloses the declaration\u2019s\n  namespace.</p>\n</blockquote>\n", "LastActivityDate": "2014-08-29T10:45:34.550", "CommentCount": "1", "CreationDate": "2014-08-29T10:45:34.550", "ParentId": "25566589", "Score": "4", "OwnerUserId": "3959454"}, "25566894": {"Id": "25566894", "PostTypeId": "2", "Body": "<p>From <code>A.8 Classes [gram.class]</code>:</p>\n<pre><code>...\nclass-specifier:\n    class-head { member-specification_opt }\n\nclass-head:\n    class-key attribute-specifier-seq_opt class-head-name class-virt-specifier_opt\n    base-clause_opt class-key attribute-specifier-seq_opt base-clause_opt\n\nclass-head-name:\n    nested-name-specifier_opt class-name\n\nclass-virt-specifier:\n    final\n\nclass-key:\n    class\n    struct\n    union\n</code></pre>\n<p>So, an optional <code>nested-name-specifier</code>'s allowed between the <code>class-key</code> keyword and the <code>class-name</code>.  <code>nested-name-specified</code>s are documented in <code>A.4 Expressions [gram.expr]</code>:</p>\n<pre><code>nested-name-specifier:\n    ::\n    type-name ::\n    namespace-name ::\n    decltype-specifier ::\n    nested-name-specifier identifier ::\n    nested-name-specifier template_opt simple-template-id ::\n</code></pre>\n<p>So <code>namespace-name</code>s <strong><em>are</em></strong> valid in the definition.</p>\n", "LastActivityDate": "2014-08-29T10:56:52.773", "CommentCount": "0", "CreationDate": "2014-08-29T10:56:52.773", "ParentId": "25566589", "Score": "0", "OwnerUserId": "410767"}, "25566589": {"ViewCount": "76", "Body": "<p><strong>Summary:</strong></p>\n<p>Is there any documentation (eg c++ standard) to support the validity of defining a C++ class using the style:</p>\n<pre><code>namespace N { class X; }\nclass N::X { ... }\n</code></pre>\n<p><strong>Details:</strong></p>\n<p>We use a couple of styles in some of our company's code to define classes:</p>\n<pre><code>// n_x.h - style 1\nnamespace N {\n  class X;\n}\n\nclass N::X {...}\n</code></pre>\n<p>and</p>\n<pre><code>// n_y.h - style 2\nnamespace N {\n  class Y;\n}\n\nnamespace N {\n  class Y { ... };\n}\n</code></pre>\n<p>The key difference here is between <code>class N::X</code> in <em>style 1</em> and <code>namespace N { class Y {...}... </code> in <em>style 2</em>, ie we wrap class Y in <em>style 2</em> in a namespace.</p>\n<p>Both styles seem valid to me (we've never had problems compiling them on VS20xx and Clang), but a colleague has questioned whether <em>style 1</em> is valid as a tool we are using to analyse our code doesn't properly recognize <em>class X</em> to be part of the namespace when using <em>style 1</em>.</p>\n<p>My hope is that someone can provide me a reference to documentation that shows that <em>style 1</em> is a valid way of defining a class in C++.</p>\n", "AcceptedAnswerId": "25566964", "Title": "Validity of style of defining class in namespace", "CreationDate": "2014-08-29T10:36:55.703", "Id": "25566589", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-11-13T13:48:46.457", "LastEditorUserId": "74670", "LastActivityDate": "2014-11-13T13:48:46.457", "Score": "3", "OwnerUserId": "74670", "Tags": "<c++>", "AnswerCount": "4"}});