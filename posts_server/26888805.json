post_cb({"bq_ids": {"n4140": {"so_26888805_26889159_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 5540}, "so_26888805_26889285_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5540}, "so_26888805_26889285_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5543}}, "n3337": {"so_26888805_26889159_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 5326}, "so_26888805_26889285_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5326}, "so_26888805_26889285_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5329}}, "n4659": {"so_26888805_26889159_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 6995}, "so_26888805_26889285_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6976}, "so_26888805_26889285_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6976}}}, "26888805": {"ViewCount": "1157", "Body": "<p>How can the <code>operator()</code> of a lambda be declared as <code>noreturn</code> ?</p>\n<p>Ideone accepts the following code:</p>\n<pre><code>#include &lt;cstdlib&gt;  \nint main() {\n    []() [[noreturn]] { std::exit(1); }();\n    return 0;\n}\n</code></pre>\n<p>Clang 3.5 rejects it with:</p>\n<pre><code>error: 'noreturn' attribute cannot be applied to types\n</code></pre>\n<p>You can try it in godbolt: <a href=\"http://goo.gl/vsuCsF\">http://goo.gl/vsuCsF</a></p>\n<p>Which one is right?</p>\n<p><strong>Update</strong>: the relevant standard sections appear to be 5.1.2.5, 7.6.3, 7.6.4 but after reading does it still isn't 100% clear to me (i) what is the right behavior, (ii) how to mark the operator() of a lambda as <code>noreturn</code>.</p>\n", "AcceptedAnswerId": "26890547", "Title": "How to declare a lambda's operator() as noreturn?", "CreationDate": "2014-11-12T14:01:42.440", "Id": "26888805", "CommentCount": "0", "LastEditDate": "2014-11-12T14:41:30.740", "PostTypeId": "1", "LastEditorUserId": "1422197", "LastActivityDate": "2014-11-12T15:40:10.470", "Score": "13", "OwnerUserId": "1422197", "Tags": "<c++><c++11><lambda><attributes><noreturn>", "AnswerCount": "3"}, "26889159": {"Id": "26889159", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26888805_26889159_0\"><code>[C++11: 7.6.3/1]:</code> The <em>attribute-token</em> <code>noreturn</code> specifies that a function does not return. It shall appear at most once in each <em>attribute-list</em> and no <em>attribute-argument-clause</em> shall be present. <strong>The attribute may be applied to the <em>declarator-id</em> in a function declaration.</strong> The first declaration of a function shall specify the <code>noreturn</code> attribute if any declaration of that function specifies the <code>noreturn</code> attribute. If a function is declared with the <code>noreturn</code> attribute in one translation unit and the same function is declared without the <code>noreturn</code> attribute in another translation unit, the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>I concede that this wording, as is, doesn't prohibit the attribute from appearing elsewhere, but in concert with seeing no evidence anywhere in the standard for it, I don't think this is intended to work with lambda declarations.</p>\n<p><strong>Therefore, Clang would be correct.</strong></p>\n<p>It may or may not be telling that <a href=\"http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20140310/101215.html\" rel=\"nofollow\">there was a patch proposal to Clang to allow GCC-style <code>noreturn</code> attributes on lambdas</a>, but <em>not</em> the standard form.</p>\n<p>Unfortunately, this feature is not included in <a href=\"https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html#C_002b_002b-Extensions\" rel=\"nofollow\">GCC's list of extensions</a>, so I can't really see exactly what's going on here.</p>\n", "LastActivityDate": "2014-11-12T14:18:09.190", "CommentCount": "5", "CreationDate": "2014-11-12T14:18:09.190", "ParentId": "26888805", "Score": "2", "OwnerUserId": "560648"}, "26889285": {"Id": "26889285", "PostTypeId": "2", "Body": "<p>So a lambda delcarator has the following grammar the draft C++ standard section <code>5.1.2</code> <em>Lambda expressions</em>:</p>\n<pre><code>( parameter-declaration-clause ) mutableopt exception-specificationopt attribute-specifier-seqopt trailing-return-typeopt\n</code></pre>\n<p>and the noreturn attribute is indeed a valid <em>attribute-specifier-seq</em> so from a grammar perspective I don't see a restriction from section <code>7.6.3</code> <em>Noreturn attribute</em> it says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_26888805_26889285_0\">[...]The attribute may be applied to the declarator-id in a function\n  declaration.[...]</p>\n</blockquote>\n<p>which does not seem to forbid your use but it does suggest that it is not allowed. If we look at section <code>7.6.4</code> <em>Carries dependency attribute</em> it says:</p>\n<blockquote>\n<p id=\"so_26888805_26889285_1\">[...]The attribute may be applied to the declarator-id of a\n  parameter-declaration in a function declaration <strong>or lambda</strong>[...]</p>\n</blockquote>\n<p>the fact that it explicitly includes the lamda case strongly indicates that section <code>7.6.3</code> is meant to exclude lambdas and therefore <code>clang</code> would be correct. As a side note Visual Studio also rejects this code.</p>\n", "LastActivityDate": "2014-11-12T14:24:44.007", "CommentCount": "1", "CreationDate": "2014-11-12T14:24:44.007", "ParentId": "26888805", "Score": "4", "OwnerUserId": "1708801"}, "26890547": {"Id": "26890547", "PostTypeId": "2", "Body": "<p>Clang is correct. An attribute can appertain to a function being declared, or to its type; the two are different. <code>[[noreturn]]</code> must appertain to the function itself.  The difference can be seen in</p>\n<pre><code>// [[noreturn]] appertains to the entity that's being declared\nvoid f [[noreturn]] ();    // \u00a78.3 [dcl.meaning]/p1:\n                           // The optional attribute-specifier-seq following a\n                           // declarator-id appertains to the entity that is declared.\"\n[[noreturn]] void h ();    // \u00a77 [dcl.dcl]/p2:\n                           // \"The attribute-specifier-seq in a simple-declaration \n                           // appertains to each of the entities declared by\n                           // the declarators of the init-declarator-list.\"\n\n// ill-formed - [[noreturn]] appertains to the type (\u00a78.3.5 [dcl.fct]/p1: \n// \"The optional attribute-specifier-seq appertains to the function type.\")\nvoid g () [[noreturn]] {}\n</code></pre>\n<p>Indeed if you compile this in g++ it tells you that </p>\n<pre><code>warning: attribute ignored [-Wattributes]\n void g () [[noreturn]] {}\n                      ^\nnote: an attribute that appertains to a type-specifier is ignored\n</code></pre>\n<p>Note that it doesn't emit a warning that <code>g()</code> actually does return.</p>\n<p>Since an \"<em>attribute-specifier-seq</em> in the <em>lambda-declarator</em> appertains to the type of the corresponding function call operator or operator template\" (\u00a75.1.2 [expr.prim.lambda]/p5) rather than to that operator/operator template itself, you can't use <code>[[noreturn]]</code> there. More generally, the language provides no way for you to apply an attribute to the <code>operator ()</code> of a lambda itself.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-11-12T15:40:10.470", "Score": "18", "CreationDate": "2014-11-12T15:28:13.763", "ParentId": "26888805", "CommentCount": "3", "OwnerUserId": "2756719", "LastEditDate": "2014-11-12T15:40:10.470"}});