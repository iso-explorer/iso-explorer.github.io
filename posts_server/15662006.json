post_cb({"15662232": {"Id": "15662232", "PostTypeId": "2", "Body": "<p>Ok, it's simple, I just misread the standard... From the C++ 11, \u00a75 [expr] p9:</p>\n<blockquote>\n<p id=\"so_15662006_15662232_0\">Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. <em>The purpose is to yield a common type, which is also the type of\n  the result.</em> This pattern is called the usual arithmetic conversions, ...</p>\n</blockquote>\n", "LastEditorUserId": "1683161", "LastActivityDate": "2013-03-27T15:24:59.673", "Score": "2", "CreationDate": "2013-03-27T15:07:12.807", "ParentId": "15662006", "CommentCount": "2", "LastEditDate": "2013-03-27T15:24:59.673", "OwnerUserId": "1683161"}, "bq_ids": {"n4140": {"so_15662006_15662232_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5943}}, "n3337": {"so_15662006_15662232_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5714}}, "n4659": {"so_15662006_15662232_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 7428}}}, "15662006": {"ViewCount": "515", "Body": "<p>Consider the following part of a C++ program; the values printed to the console are given as comments.</p>\n<pre><code>{ // case 1\nunsigned int x = 10; \nunsigned int y = 20; \nstd::cout &lt;&lt; \"u/u x - y: \" &lt;&lt; x-y &lt;&lt; std::endl; // 4294967286\n}   \n\n{ // case 2\nint x = 10; \nint y = 20; \nstd::cout &lt;&lt; \"s/s x - y: \" &lt;&lt; x-y &lt;&lt; std::endl; // -10\n}   \n\n{ // case 3\nunsigned int x = 10; \nint y = 20; \nstd::cout &lt;&lt; \"u/s x - y: \" &lt;&lt; x-y &lt;&lt; std::endl; // 4294967286\n}   \n\n{ // case 4\nint x = 10; \nunsigned int y = 20; \nstd::cout &lt;&lt; \"s/u x - y: \" &lt;&lt; x-y &lt;&lt; std::endl; // 4294967286\n}\n</code></pre>\n<p>I'm trying to figure out how C++ (tried with gcc 4.7.2) defines the type (more specifically, its signedness) from an expression. For cases 1, 3, and 4, the usual arithmetic conversions should promote both values to an unsigned int:</p>\n<pre><code> 10 = b00000000000000000000000000001010\n 20 = b00000000000000000000000000010100\n</code></pre>\n<p>Then, it would do a 2's complement to get -20 and add it:</p>\n<pre><code> 10 = b00000000000000000000000000001010\n-20 = b11111111111111111111111111101100\n      b11111111111111111111111111110110\n</code></pre>\n<p>Interpret that as an <strong>unsigned</strong> integer, and you get 4294967286 -- very well.</p>\n<p>Obviously, you get the same calculation/result for case 2; however, the usual arithmetic conversions should result in both operands being interpreted as a signed int, and also the result seems to be interpreted as a <strong>signed</strong> integer.</p>\n<p>From this, I'm deducing, that, if the operands are signed after the usual arithmetic conversions, the result is signed. Otherwise, the result is unsigned.</p>\n<p>So, my questions are:</p>\n<ol>\n<li>Is my deduction correct?</li>\n<li>Where does the standard define this? I cannot find any reference to this in the C or C++ standard.</li>\n<li>What about other operations? I suspect that <code>+</code>, <code>*</code>, etc. will work the same way, but what about shift and logical operations?</li>\n</ol>\n<p><strong>Edit:</strong> This seems related to <a href=\"https://stackoverflow.com/questions/15314778/c11-type-of-signed-unsigned?rq=1\">C++11 type of (signed + unsigned)?</a>, but the crucial part for my question seems to be missing from the accepted answer there: will the result of an expression always be the type of both operands after the usual arithmetic conversions?</p>\n", "AcceptedAnswerId": "15662246", "Title": "Type of an expression", "CreationDate": "2013-03-27T14:56:39.343", "Id": "15662006", "CommentCount": "1", "LastEditDate": "2017-05-23T12:28:52.743", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-27T15:34:41.117", "Score": "3", "OwnerUserId": "1683161", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "2"}, "15662246": {"Id": "15662246", "PostTypeId": "2", "Body": "<p>Conversions follow the integer conversion rank principle. In an nutshell, when integral operands are:</p>\n<ul>\n<li><p>exactly the same, no conversion happens.</p></li>\n<li><p>of the same size, unsigned takes precedence.</p></li>\n<li><p>of different size, smaller is converted to larger. If larger is unsigned, smaller is converted to unsigned as well.</p></li>\n</ul>\n<p>This conversion turns the operands into the same type, which is the type of the result as well.</p>\n<p>It's covered by <code>[expr]\u00a79</code> of the C++11 standard. It also relates closely to <code>[conv]</code> and <code>[conv.rank]</code>. To which operators exactly this applies is covered in the individual operators' descriptions in subchapters of <code>[expr]</code>.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2013-03-27T15:34:41.117", "Score": "7", "CreationDate": "2013-03-27T15:07:42.370", "ParentId": "15662006", "CommentCount": "5", "LastEditDate": "2013-03-27T15:34:41.117", "OwnerUserId": "1782465"}});