post_cb({"23236726": {"Id": "23236726", "PostTypeId": "2", "Body": "<p>If you have a lot of legacy code, you could probably add a custom <code>operator!=</code> (and <code>operator==</code>) function which takes the correct arguments:</p>\n<pre><code>bool operator!=(std::basic_ios const&amp; ios, const void* ptr);\nbool operator!=(const void* ptr, std::basic_ios const&amp; ios);\n</code></pre>\n", "LastActivityDate": "2014-04-23T06:40:27.233", "CommentCount": "3", "CreationDate": "2014-04-23T06:40:27.233", "ParentId": "23236548", "Score": "1", "OwnerUserId": "440558"}, "23236827": {"Id": "23236827", "PostTypeId": "2", "Body": "<p>The operator is defined in section <code>27.5.5 Class template basic_ios</code>.</p>\n<blockquote>\n<p id=\"so_23236548_23236827_0\">27.5.5.1 Overview</p>\n<p id=\"so_23236548_23236827_1\"><code>explicit operator bool() const;</code></p>\n</blockquote>\n<p>And then</p>\n<blockquote>\n<p id=\"so_23236548_23236827_2\">27.5.5.4 basic_ios flags functions</p>\n<p id=\"so_23236548_23236827_3\"><code>explicit operator bool() const;</code></p>\n<p id=\"so_23236548_23236827_4\">Returns: !fail().</p>\n</blockquote>\n", "LastActivityDate": "2014-04-23T06:46:50.860", "CommentCount": "0", "CreationDate": "2014-04-23T06:46:50.860", "ParentId": "23236548", "Score": "0", "OwnerUserId": "648078"}, "23236548": {"ViewCount": "1541", "Body": "<p>The code below compiles in VS 2012 but not in VS 2013</p>\n<pre><code>std::ofstream stm;\nif(stm != NULL)\n{\n}\n</code></pre>\n<p>In VS 2013 you get this compilation error:</p>\n<blockquote>\n<p id=\"so_23236548_23236548_0\">binary '!=' no operator found which takes a left-hand operand of type 'std::ofstream' (or there is no acceptable conversion)</p>\n</blockquote>\n<p>I looked at the headers and in <code>&lt;xiobase&gt;</code> and I found the following:</p>\n<p><strong>VS2012</strong></p>\n<pre><code>ios_base::operator void *() const;\n</code></pre>\n<p><strong>VS2013</strong></p>\n<p><code>operator void *() const</code> has been removed and the operator bool with explicit was added instead:</p>\n<pre><code>ios_base::explicit operator bool() const;\n</code></pre>\n<p>Now my questions:</p>\n<ol>\n<li>I couldn't find any information about this change in the internet. Do you know if there is an official article about this change anywhere?</li>\n<li>I have legacy code where if(stm != NULL) is used a lot. For unrelated reasons it's preferable not to change the code. Is there a way to make it compile in VS 2013 without changing it? I couldn't find any conditional compilation directives that could restore operator <code>void*</code> or remove <code>explicit</code> from operator bool().</li>\n</ol>\n<p>PS: gcc 4.9.0 still has <code>operator void*() const</code>. So it will not have this problem.</p>\n<p><strong>UPDATE:</strong></p>\n<p>To make my legacy code compile I implemented the following overloads as it was suggested:</p>\n<pre><code>#include &lt;xiosbase&gt;\n\nbool operator==(const std::basic_ios&lt;char, char_traits&lt;char&gt;&gt; &amp;stm, int null_val)\n{\n    return static_cast&lt;bool&gt;(stm) == null_val;\n}\n\nbool operator==(int null_val, const std::basic_ios&lt;char, char_traits&lt;char&gt;&gt; &amp;stm)\n{\n    return operator==(stm, null_val);\n}\n\nbool operator!=(int null_val, const std::basic_ios&lt;char, char_traits&lt;char&gt;&gt; &amp;stm)\n{\n    return !operator==(stm, null_val);\n}\n\nbool operator!=(const std::basic_ios&lt;char, char_traits&lt;char&gt;&gt; &amp;stm, int null_val)\n{\n    return !operator==(stm, null_val);\n}\n</code></pre>\n<p>In my case the <code>char</code> value type was enough and the second parameter is int because something that is not NULL is not supported anyway.</p>\n", "AcceptedAnswerId": "23236726", "Title": "Implicit cast to bool of basic_istream/ifstream/ofstream doesn't work in Visual Studio 2013", "CreationDate": "2014-04-23T06:31:50.623", "Id": "23236548", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-04-23T07:49:10.520", "LastEditorUserId": "956332", "LastActivityDate": "2014-04-23T07:49:10.520", "Score": "3", "OwnerUserId": "956332", "Tags": "<c++><visual-studio-2012><c++11><visual-studio-2013>", "AnswerCount": "3"}, "23236824": {"Id": "23236824", "PostTypeId": "2", "Body": "<p>C++11 requires some boolean conversions to be explicit that used to be implicit. This is noted in Appendix C about compatibility with C++03:</p>\n<blockquote>\n<p id=\"so_23236548_23236824_0\">C.2.15 Clause 27: Input/output library [diff.cpp03.input.output]</p>\n<p id=\"so_23236548_23236824_1\">27.7.2.1.3, 27.7.3.4, 27.5.5.4 </p>\n<p id=\"so_23236548_23236824_2\">Change: Specify use of explicit in existing boolean conversion operators</p>\n<p id=\"so_23236548_23236824_3\">Rationale: Clarify intentions, avoid workarounds. </p>\n<p id=\"so_23236548_23236824_4\">Effect on original feature: Valid C++ 2003 code that relies on implicit boolean conversions will fail to compile with this International Standard. Such conversions occur in the following conditions:</p>\n<ul>\n<li>passing a value to a function that takes an argument of type bool;</li>\n<li>using operator== to compare to false or true;</li>\n<li>returning a value from a function with a return type of bool;</li>\n<li>initializing members of type bool via aggregate initialization;</li>\n<li>initializing a const bool&amp; which would bind to a temporary.</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2014-04-23T06:46:46.157", "CommentCount": "1", "CreationDate": "2014-04-23T06:46:46.157", "ParentId": "23236548", "Score": "6", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_23236548_23236827_1": {"length": 4, "quality": 1.0, "section_id": 2186}, "so_23236548_23236827_3": {"length": 4, "quality": 1.0, "section_id": 2186}}, "n3337": {"so_23236548_23236827_1": {"length": 4, "quality": 1.0, "section_id": 2174}, "so_23236548_23236827_3": {"length": 4, "quality": 1.0, "section_id": 2174}}, "n4659": {"so_23236548_23236827_1": {"length": 4, "quality": 1.0, "section_id": 788}, "so_23236548_23236827_3": {"length": 4, "quality": 1.0, "section_id": 788}}}});