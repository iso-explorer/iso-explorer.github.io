post_cb({"29825352": {"CommentCount": "27", "AcceptedAnswerId": "29825553", "CreationDate": "2015-04-23T13:44:00.053", "LastActivityDate": "2017-03-07T10:54:53.410", "PostTypeId": "1", "ViewCount": "3117", "FavoriteCount": "5", "Title": "Is incrementing a null pointer well-defined?", "Id": "29825352", "Score": "47", "Body": "<p>There are lots of examples of undefined/unspecified behavior when doing pointer arithmetics - pointers have to point inside the same array (or one past the end), or inside the same object, restrictions on when you can do comparisons/operations based on the above, etc.</p>\n<p>Is the following operation well-defined?</p>\n<pre><code>int* p = 0;\np++;\n</code></pre>\n", "Tags": "<c++><pointers><language-lawyer>", "OwnerUserId": "673730", "AnswerCount": "8"}, "29827202": {"ParentId": "29825352", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Given that you can increment any pointer of a well-defined size (so anything that isn't a void pointer), and the value of any pointer is just an address (there's no special handling for NULL pointers once they exist), I suppose there's no reason why an incremented null pointer wouldn't (uselessly) point to the 'one after NULL'est item.</p>\n<p>Consider this:</p>\n<pre><code>// These functions are horrible, but they do return the 'next'\n// and 'prev' items of an int array if you pass in a pointer to a cell.\nint *get_next(int *p) { return p+1; }\nint *get_prev(int *p) { return p-1; }\n\nint *j = 0;\n\nint *also_j = get_prev(get_next(j));\n</code></pre>\n<p>also_j has had maths done to it, but it's equal to j so it's a null pointer.</p>\n<p>Therefore, I would suggest that's it's well-defined, just useless.</p>\n<p>(And the null pointer appearing to have the value zero when printfed is irrelevant. The <em>value</em> of the null pointer is platform dependent. The use of a zero in the language to initialise pointer variables is a language definition.)</p>\n", "OwnerUserId": "4824832", "LastEditorUserId": "4824832", "LastEditDate": "2015-04-23T15:01:53.170", "Id": "29827202", "Score": "-2", "CreationDate": "2015-04-23T14:56:12.723", "LastActivityDate": "2015-04-23T15:01:53.170"}, "29825857": {"ParentId": "29825352", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>As said by Columbo it is UB. And from a language lawyer point of view this is the definitive answer.</p>\n<p>However all C++ compiler implementations I know will give same result :</p>\n<pre><code>int *p = 0;\nintptr_t ip = (intptr_t) p + 1;\n\ncout &lt;&lt; ip - sizeof(int) &lt;&lt; endl;\n</code></pre>\n<p>gives <code>0</code>, meaning that <code>p</code> has value 4 on a 32 bit implementation and 8 on a 64 bits one</p>\n<p>Said differently :</p>\n<pre><code>int *p = 0;\nintptr_t ip = (intptr_t) p; // well defined behaviour\nip += sizeof(int); // integer addition : well defined behaviour \nint *p2 = (int *) ip;      // formally UB\np++;               // formally UB\nassert ( p2 == p) ;  // works on all major implementation\n</code></pre>\n", "OwnerUserId": "3545273", "LastEditorUserId": "3545273", "LastEditDate": "2015-04-23T14:15:32.783", "Id": "29825857", "Score": "0", "CreationDate": "2015-04-23T14:04:14.383", "LastActivityDate": "2015-04-23T14:15:32.783"}, "29841684": {"ParentId": "29825352", "CommentCount": "5", "Body": "<p>Back in the fun C days, if p was a pointer to something, p++ was effectively adding the size of p to the pointer value to make p point at the next something. If you set the pointer p to 0, then it stands to reason that p++ would still point it at the next thing by adding the size of p to it.</p>\n<p>What's more, you could do things like add or subtract numbers from p to move it along through memory (p+4 would point at the 4th something past p.) These were good times that made sense. Depending on the compiler, you could go anywhere you wanted within your memory space. Programs ran fast, even on slow hardware because C just did what you told it to and crashed if you got too crazy/sloppy.</p>\n<p>So the real answer is that setting a pointer to 0 is well-defined and incrementing a pointer is well-defined. Any other constraints are placed on you by compiler builders, os developers and hardware designers.</p>\n", "OwnerUserId": "2624279", "PostTypeId": "2", "Id": "29841684", "Score": "-1", "CreationDate": "2015-04-24T07:49:13.790", "LastActivityDate": "2015-04-24T07:49:13.790"}, "29835506": {"ParentId": "29825352", "CommentCount": "3", "Body": "<p>It turns out it's actually undefined. There are systems for which this is true</p>\n<pre><code>int *p = NULL;\nif (*(int *)&amp;p == 0xFFFF)\n</code></pre>\n<p>Therefore, ++p would trip the undefined overflow rule (turns out that sizeof(int *) == 2)). Pointers aren't guaranteed to be unsigned integers so the unsigned wrap rule doesn't apply.</p>\n", "OwnerUserId": "14768", "PostTypeId": "2", "Id": "29835506", "Score": "1", "CreationDate": "2015-04-23T22:31:25.230", "LastActivityDate": "2015-04-23T22:31:25.230"}, "29825661": {"ParentId": "29825352", "CommentCount": "7", "Body": "<p>Operations on a pointer (like incrementing, adding, etc) are generally only valid if both the initial value of the pointer and the result point to elements of the same array (or to one past the last element).    Otherwise the result is undefined.    There are various clauses in the standard for the various operators saying this, including for incrementing and adding.</p>\n<p>(There are a couple of exceptions like adding zero to NULL or subtracting zero from NULL being valid, but that doesn't apply here).</p>\n<p>A NULL pointer does not point at anything, so incrementing it gives undefined behaviour  (the \"otherwise\" clause applies).</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "29825661", "Score": "13", "CreationDate": "2015-04-23T13:55:49.833", "LastActivityDate": "2015-04-23T13:55:49.833"}, "29825553": {"ParentId": "29825352", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>\u00a75.2.6/1:</p>\n<blockquote>\n<p id=\"so_29825352_29825553_0\">The value of the operand object is modified by adding <code>1</code> to it, unless the object is of type <code>bool</code> [..]</p>\n</blockquote>\n<p>And additive expressions involving pointers are defined in \u00a75.7/5:</p>\n<blockquote>\n<p id=\"so_29825352_29825553_1\">If both the pointer operand and the result point to elements of the\n  same array object, or one past the last element of the array object,\n  the evaluation shall not produce an overflow; <strong>otherwise, the behavior\n  is  undefined.</strong></p>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-23T15:40:16.560", "Id": "29825553", "Score": "37", "CreationDate": "2015-04-23T13:51:41.333", "LastActivityDate": "2015-04-23T15:40:16.560"}, "30343753": {"ParentId": "29825352", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From <em>ISO IEC 14882-2011 \u00a75.2.6</em>:</p>\n<blockquote>\n<p id=\"so_29825352_30343753_0\">The value of a postfix ++ expression is the value of its operand. [ Note: the value obtained is a copy of\n  the original value \u2014end note ] The operand shall be a modifiable lvalue. The type of the operand shall be\n  an arithmetic type or a pointer to a complete object type.</p>\n</blockquote>\n<p>Since a nullptr is a pointer to a complete object type. So I wouldn't see why this would be undefined behaviour.</p>\n<p>As has been said before the same document also states in <em>\u00a75.2.6/1</em>:</p>\n<blockquote>\n<p id=\"so_29825352_30343753_1\">If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is\n  undefined.</p>\n</blockquote>\n<p>This expression seems a bit ambiguous. In my interpretation, the undefined part might very well be the evaluation of the object. And I think nobody would disagree with this being the case. However, pointer arithmetics seem to only require a complete object. </p>\n<p>Of course postfix [] operators and subtractions or multiplications on pointer to array objects are only well defined, if they in fact point to the same array. Mostly important because one might be tempted to think that 2 arrays defined in succession in 1 object, can be iterated over like they were a single array. </p>\n<p>So my conclusion would be that the operation is well defined, but evaluation would not be. </p>\n", "OwnerUserId": "3243563", "LastEditorUserId": "3243563", "LastEditDate": "2015-05-20T08:51:31.577", "Id": "30343753", "Score": "0", "CreationDate": "2015-05-20T08:05:28.523", "LastActivityDate": "2015-05-20T08:51:31.577"}, "29836111": {"ParentId": "29825352", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There seems to be quite low understanding what \"undefined behaviour\" means. </p>\n<p>In C, C++, and related languages like Objective-C, there are four kinds of behaviour: There is behaviour defined by the language standard. There is implementation defined behaviour, which means the language standard explicitely says that the implementation must define the behaviour. There is unspecified behaviour, where the language standard says that several behaviours are possible. And there is undefined behaviour, <strong>where the language standard doesn't say anything about the result</strong>. Because the language standard doesn't say anything about the result, anything at all can happen with undefined behaviour. </p>\n<p>Some people here assume that \"undefined behaviour\" means \"something bad happens\". That's wrong. It means \"anything can happen\", and that includes \"something bad can happen\", not \"something bad must happen\". In practice it means \"nothing bad happens when you test your program, but as soon as it is shipped to a customer, all hell breaks loose\". Since anything can happen, the compiler can actually assume that there is no undefined behaviour in your code - because either it is true, or it is false, in which case anything can happen, which means whatever happens because of the compiler's wrong assumption is still correct. </p>\n<p>Someone claimed that when p points to an array of 3 elements, and p + 4 is calculated, nothing bad will happen. Wrong. Here comes your optimising compiler. Say this is your code: </p>\n<pre><code>int f (int x)\n{\n    int a [3], b [4];\n    int* p = (x == 0 ? &amp;a [0] : &amp;b [0]);\n    p + 4;\n    return x == 0 ? 0 : 1000000 / x;\n}\n</code></pre>\n<p>Evaluating p + 4 is undefined behaviour if p points to a [0], but not if it points to b [0]. The compiler is therefore allowed to assume that p points to b [0]. The compiler is therefore allowed to assume that x != 0, because x == 0 leads to undefined behaviour. The compiler is therefore allowed to remove the x == 0 check in the return statement and just return 1000000 / x. Which means your program crashes when you call f (0) instead of returning 0. </p>\n<p>Another assumption made was that if you increment a null pointer and then decrement it again, the result is again a null pointer. Wrong again. Apart from the possibility that incrementing a null pointer might just crash on some hardware, what about this: Since incrementing a null pointer is undefined behavour, the compiler checks whether a pointer is null and only increments the pointer if it isn't a null pointer, so p + 1 is again a null pointer. And normally it would do the same for the decrementing, but being a clever compiler it notices that p + 1 is always undefined behaviour if the result was a null pointer, therefore it can be assumed that p + 1 isn't a null pointer, therefore the null pointer check can be ommitted. Which means (p + 1) - 1 is not a null pointer if p was a null pointer. </p>\n", "OwnerUserId": "3255455", "LastEditorUserId": "294884", "LastEditDate": "2015-04-24T09:38:37.127", "Id": "29836111", "Score": "14", "CreationDate": "2015-04-23T23:27:15.887", "LastActivityDate": "2015-04-24T09:38:37.127"}, "bq_ids": {"n4140": {"so_29825352_30343753_0": {"section_id": 6009, "quality": 0.7857142857142857, "length": 22}, "so_29825352_29825553_1": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_29825352_30343753_1": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_29825352_29825553_0": {"section_id": 6009, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_29825352_30343753_0": {"section_id": 5777, "quality": 0.7857142857142857, "length": 22}, "so_29825352_29825553_1": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_29825352_30343753_1": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_29825352_29825553_0": {"section_id": 5777, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_29825352_30343753_0": {"section_id": 7508, "quality": 0.7857142857142857, "length": 22}, "so_29825352_29825553_1": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_29825352_30343753_1": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_29825352_29825553_0": {"section_id": 7508, "quality": 0.7777777777777778, "length": 7}}}});