post_cb({"36696312": {"CommentCount": "1", "ViewCount": "168", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2016-04-18T14:05:51.047", "LastActivityDate": "2016-04-18T14:06:41.323", "Title": "Why is pass by value and pass by rvalue overload c++ function call ambiguous?", "AcceptedAnswerId": "36696331", "LastEditDate": "2016-04-18T14:06:41.323", "Id": "36696312", "Score": "4", "Body": "<p>If I have, </p>\n<pre><code>void foo(Bar c);\nvoid foo(Bar&amp;&amp; c);\n\nfoo(Bar()); \n</code></pre>\n<p>why is the call to 'foo' is ambiguous?\nIsn't Bar() in the foo argument clearly an rValue?</p>\n", "Tags": "<c++><c++11><rvalue>", "OwnerUserId": "695652", "AnswerCount": "1"}, "36696331": {"ParentId": "36696312", "CommentCount": "0", "Body": "<p>Binding to a reference is an \"exact match\", as is binding to a non-reference, so both overloads are equally good.</p>\n<p>In Standardese, this is 13.3.3.1.4 (\"Reference binding\", [over.ics.ref]):</p>\n<blockquote>\n<p id=\"so_36696312_36696331_0\">When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion sequence is the identity conversion [...]</p>\n</blockquote>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "36696331", "Score": "4", "CreationDate": "2016-04-18T14:06:36.513", "LastActivityDate": "2016-04-18T14:06:36.513"}, "bq_ids": {"n4140": {"so_36696312_36696331_0": {"section_id": 625, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_36696312_36696331_0": {"section_id": 615, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_36696312_36696331_0": {"section_id": 651, "quality": 0.9285714285714286, "length": 13}}}});