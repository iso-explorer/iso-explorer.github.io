post_cb({"35666626": {"Id": "35666626", "PostTypeId": "2", "Body": "<p>Because that's how the standard says the language should work.</p>\n<blockquote>\n<p id=\"so_35666265_35666626_0\">[14.8.2.1][temp.deduct.call]<br>\n  3.If P is a cv-qualified type, the top level cv-qualifiers of P\u2019s type are ignored for type deduction. If P is a\n  reference type, the type referred to by P is used for type deduction. A <em>forwarding reference</em> is an rvalue\n  reference to a cv-unqualified template parameter. If P is a forwarding reference and the argument is an\n  lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction.</br></p>\n</blockquote>\n<p>Only an rvalue-reference to a CV-unqualified template parameter can be deduced as an l-value reference in this manner.</p>\n<p>To achieve what you are trying to do, you might be able to use a trait to extract the template template parameter.</p>\n<pre><code>#include &lt;type_traits&gt;\n\n/***\n * Extract template from template type.\n */\ntemplate &lt;typename I&gt; struct get_template;\n\ntemplate &lt;template&lt;class&gt; typename T, typename C&gt;\nstruct get_template&lt;T&lt;C&gt;&gt; {\n  template &lt;typename U&gt;\n  using temp = T&lt;U&gt;;\n};\n\n\n\n\n\ntemplate &lt;typename T&gt; struct A{};\n\nstruct B;\n\ntemplate&lt;typename W&gt;\nvoid foo(W &amp;&amp; bar) {\n  typedef typename get_template&lt;typename std::remove_reference&lt;W&gt;::type&gt;::template temp&lt;int&gt; new_type;\n  new_type my_variable;\n}\n\nint main() {\n  A&lt;B&gt; temp;\n  foo(temp);\n}\n</code></pre>\n<p>Or, just overload the function for const &amp; and &amp;&amp; as usual.</p>\n", "LastActivityDate": "2016-02-27T06:37:47.540", "CommentCount": "1", "CreationDate": "2016-02-27T06:37:47.540", "ParentId": "35666265", "Score": "2", "OwnerUserId": "3598119"}, "bq_ids": {"n4140": {"so_35666265_35666626_0": {"length": 28, "quality": 0.8235294117647058, "section_id": 304}}, "n3337": {"so_35666265_35666626_0": {"length": 28, "quality": 0.8235294117647058, "section_id": 295}}, "n4659": {"so_35666265_35666626_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 311}}}, "35666265": {"ViewCount": "111", "Body": "<p>Consider these two template functions:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T&amp;&amp; bar) {\n    // do stuff with bar, which may or may not be an instance of a templated class\n}\n\ntemplate&lt;typename U, template&lt;typename&gt; class T&gt;\nvoid foo(T&lt;U&gt;&amp;&amp; bar) {\n    // do stuff with bar, which must be an instance of a templated class\n}\n</code></pre>\n<p>Why does the former accept lvalues (by using a forwarding reference) while the latter does not?</p>\n<hr>\n<p>It looks like <a href=\"https://stackoverflow.com/questions/29851098/can-an-identity-alias-template-be-a-forwarding-reference\">Can an identity alias template be a forwarding reference?</a> may be related to this as well, but it seems to cover a different facet of the restrictions on forwarding references.</p>\n</hr>", "AcceptedAnswerId": "35666626", "Title": "Forwarding references and template templates", "CreationDate": "2016-02-27T05:52:04.067", "Id": "35666265", "CommentCount": "2", "LastEditDate": "2017-05-23T12:07:47.347", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-27T16:42:26.243", "Score": "2", "OwnerUserId": "138772", "Tags": "<c++><c++11><template-templates><template-function><forwarding-reference>", "AnswerCount": "2"}, "35672104": {"Id": "35672104", "PostTypeId": "2", "Body": "<p>If you want to retain a forwarding reference parameter, and, at the same time, deduce the type of an argument, you can use the below solution:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;typename T&gt;\nstruct tag {};\n\ntemplate &lt;typename T, typename U, template &lt;typename&gt; class C&gt;\nvoid foo(T&amp;&amp; t, tag&lt;C&lt;U&gt;&gt;)\n{\n\n}\n\ntemplate &lt;typename T&gt;\nauto foo(T&amp;&amp; t)\n    -&gt; decltype(foo(std::forward&lt;T&gt;(t), tag&lt;typename std::decay&lt;T&gt;::type&gt;{}))\n{\n    return foo(std::forward&lt;T&gt;(t), tag&lt;typename std::decay&lt;T&gt;::type&gt;{});\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/651f0f3ae9afbf39\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n", "LastActivityDate": "2016-02-27T16:16:29.963", "CommentCount": "0", "CreationDate": "2016-02-27T16:16:29.963", "ParentId": "35666265", "Score": "3", "OwnerUserId": "3953764"}});