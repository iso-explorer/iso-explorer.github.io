post_cb({"11372091": {"ParentId": "11372044", "CommentCount": "3", "Body": "<p>You got it. In C++11 the wording is more clear. \u00a73.9.1/3:</p>\n<blockquote>\n<p id=\"so_11372044_11372091_0\">The range of non-negative values of a signed integer type is a subrange of the corresponding unsigned integer type, and the value representation of each corresponding signed/unsigned type shall be the same.</p>\n</blockquote>\n<p>But, what really is the significance of the connection between the two corresponding types? They are the same size, but that doesn't matter if you just have local variables.</p>\n<blockquote>\n<p id=\"so_11372044_11372091_1\">In case anyone is curious, I'm relying at the moment on a technique for extracting the absolute value of a negative integer consisting of first a cast to the unsigned counterpart, and then the application of the unary minus operator (so that for instance -3 becomes 4 via cast and then 3 via unary minus). This would break on the example above for -8, which could not be represented in the unsigned type.</p>\n</blockquote>\n<p>You need to deal with whatever numeric ranges the machine supports. Instead of casting to the unsigned counterpart, cast to whatever unsigned type is sufficient: one larger than the counterpart if necessary. If no large enough type exists, then the machine may be incapable of doing what you want.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "11372091", "Score": "3", "CreationDate": "2012-07-07T03:47:31.293", "LastActivityDate": "2012-07-07T03:47:31.293"}, "11372186": {"ParentId": "11372044", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>For C, the answer is no, there is no such guarantee.</p>\n<p>I'll discuss types <code>int</code> and <code>unsigned int</code>; this applies equally to any corresponding pair of signed and unsigned types (other than <code>char</code> and <code>unsigned char</code>, neither of which can have padding bits).</p>\n<p>The standard, in the section you quoted, implicitly guarantees that <code>UINT_MAX &gt;= INT_MAX</code>, which means that every non-negative <code>int</code> value can be represented as an <code>unsigned int</code>.</p>\n<p>But the following would be perfectly legal (I'll use <code>**</code> to denote exponentiation):</p>\n<pre><code>CHAR_BIT == 8\nsizeof (int) == 4\nsizeof (unsigned int) == 4\nINT_MIN  = -2**31\nINT_MAX  = +2**31-1\nUINT_MAX = +2**31-1\n</code></pre>\n<p>This implies that <code>int</code> has 1 sign bit (as it must) and 31 value bits, an ordinary 2's-complement representation, and <code>unsigned int</code> has 31 value bits and one padding bit.  <code>unsigned int</code> representations with that padding bit set might either be trap representations, or extra representations of values with the padding bit unset.</p>\n<p>This might be appropriate for a machine with support for 2's-complement signed arithmetic, but poor support for unsigned arithmetic.</p>\n<p>Given these characteristics, <code>-INT_MIN</code> (the mathematical value) is outside the range of <code>unsigned int</code>.</p>\n<p>On the other hand, I seriously doubt that there are any modern systems like this. Padding bits are permitted by the standard, but are very rare, and I don't expect them to become any more common.</p>\n<p>You might consider adding something like this:</p>\n<pre><code>#if -INT_MIN &gt; UINT_MAX\n#error \"Nope\"\n#endif\n</code></pre>\n<p>to your source, so it will compile only if you can do what you want. (You should think of a better error message than <code>\"Nope\"</code>, of course.)</p>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2012-07-07T08:13:04.663", "Id": "11372186", "Score": "7", "CreationDate": "2012-07-07T04:08:57.087", "LastActivityDate": "2012-07-07T08:13:04.663"}, "11372044": {"CommentCount": "1", "AcceptedAnswerId": "11372186", "PostTypeId": "1", "LastEditorUserId": "453925", "CreationDate": "2012-07-07T03:32:56.093", "LastActivityDate": "2012-07-07T11:13:32.627", "LastEditDate": "2012-07-07T11:13:32.627", "ViewCount": "357", "FavoriteCount": "2", "Title": "Unsigned vs signed range guarantees", "Id": "11372044", "Score": "9", "Body": "<p>I've spent some time poring over the standard references, but I've not been able to find an answer to the following:</p>\n<ul>\n<li>is it technically guaranteed by the C/C++ standard that, given a signed integral type S and its unsigned counterpart U, the absolute value of each possible S is always less than or equal to the maximum value of U?</li>\n</ul>\n<p>The closest I've gotten is from section <em>6.2.6.2</em> of the C99 standard (the wording of the C++ is more arcane to me, I assume they are equivalent on this):</p>\n<blockquote>\n<p id=\"so_11372044_11372044_0\">For signed integer types, the bits of the object representation shall be divided into three\n  groups: value bits, padding bits, and the sign bit. (...) Each bit that is a value bit shall have the same value as the same bit in the object representation of the corresponding unsigned type (if there are M value bits in the signed type and Nin the unsigned type, then M\u2264N).</p>\n</blockquote>\n<p>So, in hypothetical 4-bit signed/unsigned integer types, is anything preventing the unsigned type to have 1 padding bit and 3 value bits, and the signed type having 3 value bits and 1 sign bit? In such a case the range of unsigned would be [0,7] and for signed it would be [-8,7] (assuming two's complement).</p>\n<p>In case anyone is curious, I'm relying at the moment on a technique for extracting the absolute value of a negative integer consisting of first a cast to the unsigned counterpart, and then the application of the unary minus operator (so that for instance -3 becomes 4 via cast and then 3 via unary minus). This would break on the example above for -8, which could not be represented in the unsigned type.</p>\n<p>EDIT: thanks for the replies below Keith and Potatoswatter. Now, my last point of doubt is on the meaning of \"subrange\" in the wording of the standard. If it means a strictly \"less-than\" inclusion, then my example above and Keith's below are not standard-compliant. If the subrange is intended to be potentially the whole range of unsigned, then they are.</p>\n", "Tags": "<c++><c>", "OwnerUserId": "453925", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11372044_11372091_0": {"section_id": 7212, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_11372044_11372091_0": {"section_id": 6956, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_11372044_11372091_0": {"section_id": 8721, "quality": 0.9473684210526315, "length": 18}}}});