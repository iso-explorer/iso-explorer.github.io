post_cb({"43508853": {"Id": "43508853", "PostTypeId": "2", "Body": "<p>In C++14 this is <em>implementation-defined behaviour</em>, [basic.stc.dynamic.deallocation]/4:</p>\n<blockquote>\n<p id=\"so_43508771_43508853_0\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid all pointers referring to any part of the deallocated storage.</p>\n<p id=\"so_43508771_43508853_1\">Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has <strong>implementation-defined behavior</strong>.</p>\n</blockquote>\n<p>There is a footnote:</p>\n<blockquote>\n<p id=\"so_43508771_43508853_2\">Some implementations might define that copying an invalid pointer value causes a system-generated runtime fault.</p>\n</blockquote>\n<p>This changed since C++11 where the bolded text said \"undefined behaviour\" and there was no footnote.  </p>\n<hr>\n<p>So to answer your question, <code>delete ptr;</code> is allowed to set a trap value that would cause a runtime fault for <code>std::cout &lt;&lt; ptr</code>.  The compiler documentation must specify the behaviour. This is a narrower restriction than UB in which case any unstable behaviour would be permissible.</p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2017-04-20T01:59:57.610", "Score": "15", "CreationDate": "2017-04-20T01:52:11.177", "ParentId": "43508771", "CommentCount": "8", "OwnerUserId": "1505939", "LastEditDate": "2017-04-20T01:59:57.610"}, "bq_ids": {"n4140": {"so_43508771_43508853_0": {"length": 23, "quality": 1.0, "section_id": 7183}, "so_43508771_43508853_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 7183}, "so_43508771_43508853_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7183}}, "n3337": {"so_43508771_43508853_0": {"length": 23, "quality": 1.0, "section_id": 6927}, "so_43508771_43508853_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 6927}}, "n4659": {"so_43508771_43508853_0": {"length": 16, "quality": 0.6956521739130435, "section_id": 8691}, "so_43508771_43508853_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 8671}, "so_43508771_43508853_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 8671}}}, "43508812": {"Id": "43508812", "PostTypeId": "2", "Body": "<p>In this example, <code>std::cout &lt;&lt; ptr</code> is NOT undefined behavior by default, because <code>ptr</code> is not being dereferenced at all, so it doesn't matter what its value is actually set to.</p>\n<p>By default, the STL does not define an <code>operator&lt;&lt;</code> for <code>int*</code> pointers.  It defines:</p>\n<ul>\n<li><p>an <code>operator&lt;&lt;</code> for <code>(signed|unsignd) char*</code>, used for printing null-terminated text.</p></li>\n<li><p>a generic <code>operator&lt;&lt;</code> for <code>void*</code>, which simply prints the memory address itself that the pointer is set to, not the data that is being pointed at.</p></li>\n</ul>\n<p>Since <code>int*</code> is implicitly convertible to <code>void*</code>, calling <code>std::cin &lt;&lt; ptr</code> is actually calling <code>operator&lt;&lt;(std::cin, (void*)ptr)</code>, and so prints the memory address as-is that <code>ptr</code> holds.</p>\n<p>The code would have undefined behavior only if your app defines its own <code>operator&lt;&lt;</code> for <code>int*</code> and then tries to dereference the pointer after it has been deleted.</p>\n", "LastEditorUserId": "65863", "LastActivityDate": "2017-04-20T01:56:28.223", "Score": "-1", "CreationDate": "2017-04-20T01:46:21.587", "ParentId": "43508771", "CommentCount": "8", "OwnerUserId": "65863", "LastEditDate": "2017-04-20T01:56:28.223"}, "43508771": {"ViewCount": "513", "Body": "<p>(*) As far as I know the Standard allows an implementation to modify the operand of the <code>delete</code> operator, however most implementations do not do that.</p>\n<pre><code>int* ptr = new int(0);\ndelete ptr; //delete is allowed to modify ptr, for example set it to 0\nstd::cout &lt;&lt; ptr; // UB?\n</code></pre>\n<p>Acknowledging (*), is the reading of <code>ptr</code> (in the form of printing it) well-defined? </p>\n<p>If <code>delete</code> does modify <code>ptr</code>, is it allowed to set a trap value, which would make reading <code>ptr</code> UB?</p>\n", "AcceptedAnswerId": "43508853", "Title": "Use of a deleted pointer address", "CreationDate": "2017-04-20T01:41:10.677", "Id": "43508771", "CommentCount": "2", "LastEditDate": "2017-04-21T03:18:46.513", "PostTypeId": "1", "LastEditorUserId": "2288628", "LastActivityDate": "2017-04-21T03:18:46.513", "Score": "10", "OwnerUserId": "2288628", "Tags": "<c++><undefined-behavior>", "AnswerCount": "2"}});