post_cb({"26879259": {"Id": "26879259", "PostTypeId": "2", "Body": "<p>Apparently my reputation does not allow me to post a comment and I am not sure that it is OK to post this as it can be interpreted as subjective, but here is a reason that \"a user of the language\" may find this concept troublesome.</p>\n<p>Order of initialization. If a class has aggregates as bases as well as non-static data members, what order to they get initialized in? Base classes before non-static data members? And of course, how about when the base classes have base classes or with multiple base classes. Then there is of course virtual inheritance, etc. It may even come as a surprise to a novice programmer that class members in constructor mem-initializer-lists are initialized in declaration order rather than list order. I believe that allowing further confusion with initialization (in this case of aggregates) would make the language harder to learn. Given that one of the goals for C++11 Bjarne Stroustrup lists is \"Making the language easier to teach and learn\", adding confusion is not to be taken lightly. Of course, I realize that there would be no ambiguity and that's why I avoided using that word, it would just not have an order that everyone would necessarily immediately assume correctly.</p>\n<p>I guess my view is that little is gained by allowing base classes and it could lead to confusion. It would likely necessitate careful wording in the standard to allow this.</p>\n", "LastActivityDate": "2014-11-12T04:26:18.707", "CommentCount": "1", "CreationDate": "2014-11-12T04:26:18.707", "ParentId": "26876310", "Score": "0", "OwnerUserId": "2129511"}, "bq_ids": {"n4140": {"so_26876310_26876310_1": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}}, "n3337": {"so_26876310_26876310_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}}, "n4659": {"so_26876310_26876310_1": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}}}, "26876310": {"ViewCount": "166", "Body": "<p>From C++ Draft Standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">n3337</a>:</p>\n<blockquote>\n<p id=\"so_26876310_26876310_0\">8.5.1 Aggregates [dcl.init.aggr]</p>\n<p id=\"so_26876310_26876310_1\">1 An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equalinitializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>Say I have two classes:</p>\n<pre><code>struct ABase\n{\n   int value;\n};\n\nstruct A : public ABase {};\n</code></pre>\n<p>Based on the standard, <code>ABase</code> is an aggregate type while <code>A</code> is not. That means, it's OK to create an instance of <code>ABase</code> using:</p>\n<pre><code>ABase a1{10};\n</code></pre>\n<p>but it's not OK to create an instance of <code>A</code> using:</p>\n<pre><code>A a2{20};\n</code></pre>\n<p><code>A</code> is trivially derived from <code>ABase</code> and could potentially have been treated as an aggregate. My question is what sorts of pitfalls one, a user of the language as well as an implementor of a compiler, can run into by treating <code>A</code> as an aggregate type?</p>\n", "Title": "Why can't a trivially derived class be treated as an aggregate type?", "CreationDate": "2014-11-11T23:07:49.633", "Id": "26876310", "CommentCount": "7", "LastEditDate": "2014-11-12T09:27:20.990", "PostTypeId": "1", "LastEditorUserId": "1023390", "LastActivityDate": "2014-11-12T09:27:20.990", "Tags": "<c++><c++11><language-lawyer>", "Score": "3", "OwnerUserId": "434551", "ClosedDate": "2014-11-12T09:13:46.253", "AnswerCount": "1"}});