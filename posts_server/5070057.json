post_cb({"5070057": {"ViewCount": "2464", "Body": "<p>I sometimes need a class in C++ which allocates dynamic memory. Since this can fail, I need to detect when the memory cannot be allocated. Usually, I do this as in the example below, ie. I do not allocate memory in the constructor but have a separate method for this, where a <code>bad_alloc</code> exception can be caught.</p>\n<p>Is there any way to allocate memory in the constructor and catch an exception?</p>\n<pre><code>try {\n  my_class my_instance;\n}\ncatch ...\n</code></pre>\n<p>does not work because the scope of <code>my_instance</code> is limited to the <code>try</code> block.</p>\n<p>Here is a minimal example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass my_class {\nprivate:\n  char * data;\n\npublic:\n  my_class () {\n    data = NULL;\n  }\n\n  ~my_class () {\n    delete [] data;\n  }\n\n  void init () {\n    data = new char [10000000000];\n  }\n\n  void write (int x) {\n    data[x] = 1;\n  }\n};\n\nint main() {\n  my_class my_instance;\n  try {\n    my_instance.init();\n  }\n  catch (std::bad_alloc&amp;) {\n    std::cout &lt;&lt; \"Memory overflow.\\n\";\n    return 1;\n  }\n\n  my_instance.write(10);\n\n  std::cout &lt;&lt; \"OK.\\n\";\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "5070082", "Title": "Catching a memory allocation error in a constructor?", "CreationDate": "2011-02-21T19:03:15.597", "Id": "5070057", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-02-21T19:43:54.013", "Score": "2", "OwnerUserId": "627163", "Tags": "<c++>", "AnswerCount": "5"}, "5070348": {"Id": "5070348", "PostTypeId": "2", "Body": "<p>How about using the non-throwing allocator...</p>\n<pre><code>my_class(void)\n   : data(new (std::nothrow) char[1000000])\n{\n}\n\nbool isvalid(void) const { return data != 0; }\n</code></pre>\n<hr>\n<p>Although a <em>function-try-block</em> is a good way to log the failure, it can't rescue the object (from draft 3225, section <code>[except.handle]</code>):</p>\n<blockquote>\n<p id=\"so_5070057_5070348_0\">The fully constructed base classes and members of an object shall be destroyed before entering the handler\n  of a function-try-block of a constructor for that object.</p>\n<p id=\"so_5070057_5070348_1\">The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block\n  of a constructor or destructor.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-02-21T19:37:43.830", "Score": "0", "CreationDate": "2011-02-21T19:31:46.627", "ParentId": "5070057", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2011-02-21T19:37:43.830"}, "5070402": {"Id": "5070402", "PostTypeId": "2", "Body": "<p>I'm not sure what's wrong with the constructor throwing an exception, and I certainly wouldn't use an <code>init()</code> method.  Refer to <a href=\"http://rads.stackoverflow.com/amzn/click/0201889544\" rel=\"nofollow\">The C++ Programming Language</a>, there's a note somewhere on 4 key reasons not to use one.</p>\n<p>I usually write my <code>main()</code> function like this to avoid a core dump and write to the application's debug log to make sure there is some note of what, exactly, happened.</p>\n<pre><code>int main ( int argc, char ** argv )\ntry\n{\n    // do some stuff\n    //...\n    return EXIT_SUCCESS;\n}\n    // lots of stuff, including `std::bad_alloc`.\ncatch ( const std::exception&amp; )\n{\n    // write to application debug log.\n    // ...\n    return EXIT_FAILURE;\n}\n    // any unkonwn exception, possibly from 3rd-party library.\ncatch ( ... ) \n{\n    // write to application debug log.\n    // ...\n    return EXIT_FAILURE;\n}\n</code></pre>\n", "LastActivityDate": "2011-02-21T19:36:50.893", "CommentCount": "0", "CreationDate": "2011-02-21T19:36:50.893", "ParentId": "5070057", "Score": "0", "OwnerUserId": "313063"}, "bq_ids": {"n4140": {"so_5070057_5070348_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3356}, "so_5070057_5070348_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3360}}, "n3337": {"so_5070057_5070348_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3226}, "so_5070057_5070348_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3230}}, "n4659": {"so_5070057_5070348_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 4110}, "so_5070057_5070348_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 4126}}}, "5070082": {"Id": "5070082", "PostTypeId": "2", "Body": "<p>Not really. <code>my_instance</code> will be an invalid instance that can't be used.</p>\n<p><a href=\"http://www.gotw.ca/publications/mill13.htm\" rel=\"nofollow\">http://www.gotw.ca/publications/mill13.htm</a></p>\n", "LastActivityDate": "2011-02-21T19:06:27.063", "CommentCount": "0", "CreationDate": "2011-02-21T19:06:27.063", "ParentId": "5070057", "Score": "3", "OwnerUserId": "23528"}, "5070202": {"Id": "5070202", "PostTypeId": "2", "Body": "<p>You could use little-known feature introduced in the C++ Standard in 1995 \u2014 <a href=\"http://www.drdobbs.com/184401297\" rel=\"nofollow\">function-try-block</a> as follows:</p>\n<pre><code>struct A\n{\nprivate:\n  char* data;\npublic:\n  // catch exception in the constructor\n  A() try : data( new char [10000000000] ) {}\n  catch ( std::bad_alloc ) { data = NULL; /* handle bad_alloc exception here */ }\n\n  void write (int x) {\n    if ( data ) data[x] = 1;\n  }\n};\n</code></pre>\n<p>This approach is not usable if <code>A</code> is inherited from some base class. And the fact that you can catch <code>bad_alloc</code> exception gives you nothing in the end. If you can work with the less amount of the allocated memory you could use <a href=\"http://www.cplusplus.com/reference/std/memory/get_temporary_buffer/\" rel=\"nofollow\"><code>std::get_temporary_buffer</code></a> instead of <code>new</code>:</p>\n<pre><code>struct A\n{\nprivate:\n  std::pair&lt;char*,ptrdiff_t&gt; data;\npublic:\n  // get as much memory as possible\n  A() : data( std::get_temporary_buffer&lt;char&gt;(10000000000) ) {}\n  ~A() { std::return_temporary_buffer( data.first ); }\n\n  void write (int x) {\n    if ( x &lt; data.second ) // check x is in the allocated range\n      data.first[x] = 1;\n  }\n};\n</code></pre>\n", "LastEditorUserId": "123111", "LastActivityDate": "2011-02-21T19:43:54.013", "Score": "2", "CreationDate": "2011-02-21T19:16:32.063", "ParentId": "5070057", "CommentCount": "5", "OwnerUserId": "123111", "LastEditDate": "2011-02-21T19:43:54.013"}, "5070354": {"Id": "5070354", "PostTypeId": "2", "Body": "<p>Yeah- it's called writing it in the try.</p>\n<pre><code>int main() {\n    try {\n        my_class my_instance;\n        my_instance.write(10);\n        std::cout &lt;&lt; \"OK.\\n\";\n        return 0;\n    }\n    catch (std::bad_alloc&amp;) {\n        std::cout &lt;&lt; \"Memory overflow.\\n\";\n        return 1;\n    }\n}\n</code></pre>\n", "LastActivityDate": "2011-02-21T19:31:59.917", "CommentCount": "0", "CreationDate": "2011-02-21T19:31:59.917", "ParentId": "5070057", "Score": "0", "OwnerUserId": "298661"}});