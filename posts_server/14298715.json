post_cb({"14298715": {"ViewCount": "987", "Body": "<p>I'm puzzled with this behavior of C++:</p>\n<pre><code>struct A {\n   virtual void print() const { printf(\"a\\n\"); }\n};\n\nstruct B : public A {\n   virtual void print() const { printf(\"b\\n\"); }\n};\n\nstruct C {\n   operator B() { return B(); }\n};\n\nvoid print(const A&amp; a) {\n   a.print();\n}\n\nint main() {\n   C c;\n   print(c);\n}\n</code></pre>\n<p>So, the quiz is, what is the output of the program - a or b? Well, the answer is a. But why?</p>\n", "AcceptedAnswerId": "14300750", "Title": "C++ cast operator overloading and polymorhism", "CreationDate": "2013-01-12T22:40:59.287", "Id": "14298715", "CommentCount": "36", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2013-01-12T23:01:16.443", "LastEditorUserId": "1440565", "LastActivityDate": "2013-01-13T10:21:26.630", "Score": "22", "OwnerUserId": "1267371", "Tags": "<c++><casting><polymorphism><overloading><operator-keyword>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14298715_14300750_2": {"length": 14, "quality": 0.875, "section_id": 3321}, "so_14298715_14300750_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_14298715_14300750_6": {"length": 11, "quality": 0.6111111111111112, "section_id": 3321}, "so_14298715_14300750_4": {"length": 9, "quality": 0.6, "section_id": 3321}, "so_14298715_14300750_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 3321}, "so_14298715_14300750_8": {"length": 32, "quality": 0.9411764705882353, "section_id": 3321}}, "n3337": {"so_14298715_14300750_2": {"length": 14, "quality": 0.875, "section_id": 3191}, "so_14298715_14300750_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_14298715_14300750_6": {"length": 14, "quality": 0.7777777777777778, "section_id": 3191}, "so_14298715_14300750_4": {"length": 9, "quality": 0.6, "section_id": 3191}, "so_14298715_14300750_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 3191}, "so_14298715_14300750_8": {"length": 32, "quality": 0.9411764705882353, "section_id": 3191}}, "n4659": {"so_14298715_14300750_4": {"length": 9, "quality": 0.6, "section_id": 4087}, "so_14298715_14300750_2": {"length": 14, "quality": 0.875, "section_id": 4087}, "so_14298715_14300750_8": {"length": 23, "quality": 0.6764705882352942, "section_id": 4087}, "so_14298715_14300750_3": {"length": 7, "quality": 1.0, "section_id": 4087}, "so_14298715_14300750_0": {"length": 8, "quality": 1.0, "section_id": 4087}}}, "14300750": {"Id": "14300750", "PostTypeId": "2", "Body": "<p>The problem here is a bug / misfeature / hole in the C++03 standard, with different compilers trying to patch over the problem in different ways. (This problem no longer exists in C++11 standard.)</p>\n<p>Sections 8.5.3/5 of both standards specify how a reference is initialized. Here's the C++03 version (the list numbering is mine):</p>\n<blockquote>\n<p id=\"so_14298715_14300750_0\">A reference to type <code>cv1 T1</code> is initialized by an expression of type <code>cv2 T2</code> as follows:</p>\n<ol>\n<li><p id=\"so_14298715_14300750_1\">If the initializer expression</p>\n<ol>\n<li>is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d or</li>\n<li>has a class type (i.e., <code>T2</code> is a class type) and can be implicitly converted to an lvalue of type <code>cv3 T3</code>, where <code>cv1 T1</code> is reference-compatible with <code>cv3 T3</code></li>\n</ol>\n<p id=\"so_14298715_14300750_2\">then the reference is bound directly to the initializer expression lvalue in the first case, and the reference is bound to the lvalue result of the conversion in the second case.</p></li>\n<li><p id=\"so_14298715_14300750_3\">Otherwise, the reference shall be to a non-volatile const type (i.e., <code>cv1</code> shall be <code>const</code>).</p></li>\n<li><p id=\"so_14298715_14300750_4\">If the initializer expression is an rvalue, with <code>T2</code> a class type, and <code>cv1 T1</code> is reference-compatible with <code>cv2 T2</code>, the reference is bound in one of the following ways (the choice is implementation-defined):</p>\n<ol>\n<li>The reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within that object.</li>\n<li>A temporary of type <code>cv1 T2</code> [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary. The reference is bound to the temporary or to a sub-object within the temporary.</li>\n</ol>\n<p id=\"so_14298715_14300750_5\">The constructor that would be used to make the copy shall be callable whether or not the copy is actually done.</p></li>\n<li><p id=\"so_14298715_14300750_6\">Otherwise, a temporary of type <code>cv1 T1</code> is created and initialized from the initializer expression using the rules for a non-reference copy initialization (8.5). The reference is then bound to the temporary.</p></li>\n</ol>\n</blockquote>\n<p>There are three types involved in the question at hand:</p>\n<ul>\n<li>The type of the reference to be created. The standards (both versions) denote this type as <code>T1</code>. In this case, it is <code>struct A</code>.</li>\n<li>The type of the initializer expression. The standards denote this type as <code>T2</code>. In this case, the initializer expression is the variable <code>c</code>, so <code>T2</code> is <code>struct C</code>. Note that because <code>struct A</code> is not <em>reference-compatible</em> with <code>struct C</code>, it's not possible to directly bind the reference to <code>c</code>. An intermediate is needed.</li>\n<li>The type of the intermediate. The standards denote this type as <code>T3</code>. In this case, this is <code>struct B</code>. Note that applying the conversion operator <code>C::operator B()</code> to <code>c</code> will convert the lvalue <code>c</code> to an rvalue.</li>\n</ul>\n<p>The initializations by what I labeled as 1.1 and 3 are out because the <code>struct A</code> is not reference-compatible with <code>struct C</code>. The conversion operator <code>C::operator B()</code> needs to be used. 1.2 is out   Because this conversion operator returns an rvalue, this rules 1.2 out. All that is left is option 4, create a temporary of type <code>cv1 T1</code>. Strict compliance with the 2003 version of the standard forces the creation of two temporaries for this problem, even though only one will suffice.</p>\n<p>The 2011 version of the standard fixes the problem by replacing option 3 with</p>\n<blockquote>\n<ul>\n<li><p id=\"so_14298715_14300750_7\">If the initializer expression</p>\n<ul>\n<li>is an xvalue, class prvalue, array prvalue or function lvalue and <code>cv1 T1</code> is reference-\n  compatible with <code>cv2 T2</code>, or</li>\n<li>has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be implicitly converted to an xvalue, class prvalue, or function lvalue of type <code>cv3 T3</code>, where <code>cv1 T1</code> is reference-compatible with <code>cv3 T3</code>,</li>\n</ul>\n<p id=\"so_14298715_14300750_8\">then the reference is bound to the value of the initializer expression in the first case and to the result of the conversion in the second case (or, in either case, to an appropriate base class subobject). In the second case, if the reference is an rvalue reference and the second standard con- version sequence of the user-defined conversion sequence includes an lvalue-to-rvalue conversion, the program is ill-formed.</p></li>\n</ul>\n</blockquote>\n<p>It appears that the gcc family of compilers chose strict compliance over intent (avoid creating unnecessary temporaries), while the other compilers that print \"b\" chose intent / corrections to the standard. Choosing strict compliance isn't necessarily commendable; there are other bugs/misfeatures in the 2003 version of the standard (e.g., <code>std::set</code>) where the gcc family chose sanity over strict compliance.</p>\n", "LastActivityDate": "2013-01-13T04:47:51.490", "CommentCount": "3", "CreationDate": "2013-01-13T04:47:51.490", "ParentId": "14298715", "Score": "10", "OwnerUserId": "774499"}});