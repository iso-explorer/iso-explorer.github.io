post_cb({"37075353": {"ParentId": "37075298", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-05-06T14:48:01.953", "Score": "3", "LastEditorUserId": "4342498", "LastEditDate": "2016-05-06T15:08:36.753", "Id": "37075353", "OwnerUserId": "5245033", "Body": "<p>Yes. It doesn't matter if the function is a [non-static] member of a class or not, it's guranteed to have only one instance of it's static variables.</p>\n<p>Proper technical explanation for such variables is that those are objects with <code>static duration</code> and <code>internal linkage</code> - and thus those names live until program exits, and all instances of this name refer to the same entity.</p>\n", "LastActivityDate": "2016-05-06T15:08:36.753"}, "37075934": {"ParentId": "37075298", "CommentCount": "3", "CreationDate": "2016-05-06T15:17:27.010", "OwnerUserId": "2362671", "PostTypeId": "2", "Id": "37075934", "Score": "0", "Body": "<p>Yes, it is guaranteed. Now, to answer the question \"Any risk of sharing local static variable of a method between instances?\" it might be a bit less straightforward. There might be potential risks in the initialization and utilization of the variable and these risks are specific to variables local to the method (as opposed to class variables).</p>\n<p>For the initialization, a relevant part in the standard is 6.7/4 [stmt.dcl]:</p>\n<blockquote>\n<p id=\"so_37075298_37075934_0\">Dynamic initialization of a block-scope variable with static storage\n  duration (3.7.1) or thread storage duration (3.7.2) is performed the\n  first time control passes through its declaration; such a variable is\n  considered initialized upon the completion of its initialization. If\n  the initialization exits by throwing an exception, the initialization\n  is not complete, so it will be tried again the next time control\n  enters the declaration. If control enters the declaration concurrently\n  while the variable is being initialized, the concurrent execution\n  shall wait for completion of the initialization. If control\n  re-enters the declaration recursively while the variable is being\n  initialized, the behavior is undefined.</p>\n</blockquote>\n<p>In the simple cases, everything should work as expected. When the construction and initialization of the variable is more complex, there will be risks specific to this case. For instance, if the constructor throws, it will have the opportunity to throw again on the next call. Another example would be recursive initialization which is undefined behavior.</p>\n<p>Another possible risk is the performance of the method. The compiler will need to implement a mechanism to ensure compliant initialization of the variable. This is implementation-dependent and it could very well be a lock to check if the variable is initialized, and that lock could be executed every time the method is called. When that happens, it can have a significant adverse effect on performance.</p>\n", "LastActivityDate": "2016-05-06T15:17:27.010"}, "37075298": {"CommentCount": "0", "ViewCount": "77", "PostTypeId": "1", "LastEditorUserId": "959663", "CreationDate": "2016-05-06T14:44:56.047", "LastActivityDate": "2016-05-06T16:29:44.763", "Title": "Any risk of sharing local static variable of a method between instances?", "AcceptedAnswerId": "37075353", "LastEditDate": "2016-05-06T16:29:44.763", "Id": "37075298", "Score": "0", "Body": "<p>Let's say I create:</p>\n<pre><code>class Hello {\n    public:\n       int World(int in)\n       {\n           static int var = 0;    // &lt;&lt;&lt;&lt; This thing here.\n           if(in &gt;= 0) {\n               var = in;\n           } else {\n               cout &lt;&lt; var &lt;&lt; endl;\n           }\n      }\n};\n</code></pre>\n<p>Now, if I do:</p>\n<pre><code>Hello A;\nHello B;\n\nA.World(10);\nA.World(-1);\nB.World(-1);\n</code></pre>\n<p>I'm getting output of \"10\" followed by another \"10\". The value of the <em>local</em> variable of a method just crossed over from one instance of a class to another.</p>\n<p>It's not surprising - technically methods are just functions with a hidden <code>this</code> parameter, so a static local variable should behave just like in common functions. But is it <em>guaranteed</em>? Is it a behavior enforced by standard, or is it merely a happy byproduct of how the compiler handles methods? In other words - is this behavior safe to use? (...beyond the standard risk of baffling someone unaccustomed...)</p>\n", "Tags": "<c++><methods><static-variables>", "OwnerUserId": "249618", "AnswerCount": "4"}, "37076116": {"ParentId": "37075298", "CommentCount": "1", "CreationDate": "2016-05-06T15:26:25.897", "OwnerUserId": "6255513", "PostTypeId": "2", "Id": "37076116", "Score": "1", "Body": "<p>Just one thing to add to the correct answer. If your class was templated, then the instance of <code>var</code> would only be shared amongst objects of the same instantiation type. So if you had:</p>\n<pre><code>template&lt;typename C&gt;\nclass Hello {\n        public:\n        int World(int in)\n        {\n                static int var = 0;    // &lt;&lt;&lt;&lt; This thing here.\n                if(in &gt;= 0) {\n                        var = in;\n                } else {\n                        cout &lt;&lt; var &lt;&lt; endl;\n                }\n        }\n};\n</code></pre>\n<p>And then:</p>\n<pre><code>Hello&lt;int&gt; A;\nHello&lt;int&gt; B;\nHello&lt;unsigned&gt; C;\n\nA.World(10);\nA.World(-1);\nB.World(-1);\nC.World(-1);\n</code></pre>\n<p>Then the final output would be \"0\" rather than \"10\", because the <code>Hello&lt;unsigned&gt;</code> instantiation would have its own copy of <code>var</code>.</p>\n", "LastActivityDate": "2016-05-06T15:26:25.897"}, "37075478": {"ParentId": "37075298", "CommentCount": "0", "CreationDate": "2016-05-06T14:53:45.207", "OwnerUserId": "5119903", "PostTypeId": "2", "Id": "37075478", "Score": "0", "Body": "<p>If we are talking about the Windows Compiler it's guaranteed</p>\n<p><a href=\"https://msdn.microsoft.com/en-us/library/y5f6w579.aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/y5f6w579.aspx</a></p>\n<blockquote>\n<p id=\"so_37075298_37075478_0\">The following example shows a local variable declared static in a member function. The static variable is available to the whole program; all instances of the type share the same copy of the static variable. </p>\n</blockquote>\n<p>They use an example very similar to yours.</p>\n<p>I don't know about GCC</p>\n", "LastActivityDate": "2016-05-06T14:53:45.207"}, "bq_ids": {"n4140": {"so_37075298_37075934_0": {"section_id": 3919, "quality": 0.921875, "length": 59}}, "n3337": {"so_37075298_37075934_0": {"section_id": 3779, "quality": 0.921875, "length": 59}}, "n4659": {"so_37075298_37075934_0": {"section_id": 4805, "quality": 0.96875, "length": 62}}}});