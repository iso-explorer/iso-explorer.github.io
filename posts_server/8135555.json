post_cb({"8136519": {"ParentId": "8135555", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think you can legally do this by adding a partial specialisation of <code>std::pair</code> for your type:</p>\n<pre><code>namespace std {\n    template &lt;typename T&gt;\n    struct pair&lt;T,ComponentName&gt; {\n       typedef T first_type;\n       typedef ComponentName second_type;\n\n       T first;\n       ComponentName second;\n       // The rest of the pair members:\n       // ....\n       // Any trick you like to make it fail with assignment/construction from \n       // pair&lt;std::wstring, std::wstring&gt;\n    };\n}\n</code></pre>\n<p>Justification:</p>\n<p>\u00a7 17.6.4.2.1 sets out the basic rules for specialisations in the <code>std</code> namespace:</p>\n<blockquote>\n<p id=\"so_8135555_8136519_0\">\"A program may add a template specialization for any standard library\n  template to namespace std only if the declaration depends on a\n  user-defined type and the specialization meets the standard library\n  requirements for the original template and is not explicitly\n  prohibited\"</p>\n</blockquote>\n<p>I can't see any explicit prohibition that would rule this particular case out, provided you filled out the rest of the class, within the bounds of \u00a7 20.3 .</p>\n<hr>\n<p>Alternative, possibly legal approach:</p>\n<p>Specialize <code>std::is_constructible&lt;ComponentName, std::wstring&gt;</code> such that <code>value</code> is false. This is listed as a requirement of both the assignment operator and the copy constructor for <code>std::pair</code>s of different types. I can't see any prohibitions from a quick scan of this either, but I can't find anything saying that implementations are <em>required</em> to check the requirements.</p>\n</hr>", "OwnerUserId": "168175", "LastEditorUserId": "168175", "LastEditDate": "2011-11-15T13:18:32.787", "Id": "8136519", "Score": "10", "CreationDate": "2011-11-15T12:43:48.357", "LastActivityDate": "2011-11-15T13:18:32.787"}, "8136016": {"ParentId": "8135555", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Simple:</p>\n<pre><code>enum FromString { fromString };\n\nComponentName( FromString, std::wstring const&amp; aName)\n    : name( aName )\n{}\n</code></pre>\n", "OwnerUserId": "464581", "LastEditorUserId": "140719", "LastEditDate": "2011-11-15T12:05:49.763", "Id": "8136016", "Score": "3", "CreationDate": "2011-11-15T12:00:21.913", "LastActivityDate": "2011-11-15T12:05:49.763"}, "8135555": {"CommentCount": "14", "AcceptedAnswerId": "8136519", "PostTypeId": "1", "LastEditorUserId": "96780", "CreationDate": "2011-11-15T11:20:03.983", "LastActivityDate": "2013-09-02T15:42:20.070", "LastEditDate": "2013-09-02T15:42:20.070", "ViewCount": "369", "FavoriteCount": "0", "Title": "How to avoid 'implicit' calling of a one-parameter constructor in std::pair", "Id": "8135555", "Score": "17", "Body": "<p>The original problem was how to work with <code>std::map&lt;std::wstring, std::wstring&gt; &gt;</code> in a secure way because equal types of the key and the value are extremely error-prone. So I decided to create a simple wrapper for the value:</p>\n<pre><code>    struct ComponentName\n    {\n      std::wstring name;\n\n      // I want to prohibit any implicit string-ComponentName conversions!!!\n      explicit ComponentName(const std::wstring&amp; _name) : name(_name)\n      {\n      }\n\n      bool operator&lt;(const ComponentName&amp; item_to_compare) const\n      {\n        return name &lt; item_to_compare.name;\n      }\n    };\n\n    typedef std::map&lt;std::wstring, ComponentName&gt; component_names_map;\n</code></pre>\n<p>But the following code works well!</p>\n<pre><code>component_names_map component_names;\n// Are you sure that ComponentName's constructor cannot be called implicitly? ;)\ncomponent_names_map::value_type a_pair = std::make_pair(L\"Foo\", L\"Bar\");\n</code></pre>\n<p>It works because the <code>std::pair&lt;std::wstring, ComponentName&gt;</code> copy constructor explicitly uses the string contructor of the ComponentName to assign the <code>std::pair&lt;std::wstring, std::wstring&gt;</code> instance. It's an absolutely legal operation. However it looks as an 'implicit' call of the ComponentName constructor.</p>\n<p>So I know the reason of the problem, but how can I avoid this 'implicit' <code>wstring-ComponentName</code> conversion?\nThe simplest way is to not declare the string constructor, but it makes ComponentName initialization inconvenient.</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "428692", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8135555_8136519_0": {"section_id": 6299, "quality": 1.0, "length": 20}, "so_8135555_8137176_2": {"section_id": 3967, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_8135555_8136519_0": {"section_id": 6056, "quality": 1.0, "length": 20}, "so_8135555_8137176_2": {"section_id": 3824, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_8135555_8136519_0": {"section_id": 7808, "quality": 1.0, "length": 20}, "so_8135555_8137176_2": {"section_id": 5572, "quality": 0.6666666666666666, "length": 8}}}, "8137176": {"ParentId": "8135555", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The problem (in C++03) is that most standard library implementations are not really standard conforming. In particular, the standard states that when a <code>std::pair&lt;T,U&gt;</code> is constructed from a different <code>std::pair&lt;V,W&gt;</code> the members are constructed by implicit conversions. The problem is that it is actually really hard (if even possible) to restrict that conversion in the implementation of the templated <code>pair</code> constructor, so current implementations perform <em>explicit</em> conversion of the arguments:</p>\n<pre><code>template &lt;typename T, typename U&gt;\nstruct pair {\n    // ...\n    template &lt;typename V, typename W&gt;\n    pair( pair&lt;V,W&gt; const &amp; p ) : first( p.first ), second( p.second ) {} \n};\n</code></pre>\n<p>I actually wrote a blog post about this particular case <a href=\"http://definedbehavior.blogspot.com/2011/07/i-decided-to-start-writing-few-months.html\" rel=\"nofollow\">here</a>, and for the sake of it I tried to provide the appropriate conversion constructors <a href=\"http://definedbehavior.blogspot.com/2011/07/improving-conversions-of-stdpair-s.html\" rel=\"nofollow\">here</a>, but the solution is not standard compliant (i.e. it has a different signature than those required by the standard).</p>\n<p>Note: In C++11 (\u00a720.3.2p12-14) this implicit conversion is also forbidden (From FDIS):</p>\n<pre><code>template&lt;class U, class V&gt; pair(pair&lt;U, V&gt;&amp;&amp; p);\n</code></pre>\n<blockquote>\n<p id=\"so_8135555_8137176_0\">Requires: is_constructible::value is true and is_constructible::value is true.</p>\n<p id=\"so_8135555_8137176_1\">Effects: The constructor initializes first with std::forward(p.first) and second with std::forward(p.second). </p>\n<p id=\"so_8135555_8137176_2\">Remark: This constructor shall not participate in overload resolution unless U is implicitly convertible to first_type and V is implicitly convertible to second_type.</p>\n</blockquote>\n<p>The equivalent restrictions are present in p9-11 for the equivalent for <code>template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt;&amp; p);</code> (in case the types are not <em>movable</em>)</p>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2011-11-15T14:11:05.603", "Id": "8137176", "Score": "4", "CreationDate": "2011-11-15T13:37:45.757", "LastActivityDate": "2011-11-15T14:11:05.603"}});