post_cb({"bq_ids": {"n4140": {"so_36779096_36782474_0": {"length": 43, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_36779096_36782474_0": {"length": 43, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_36779096_36782474_0": {"length": 43, "quality": 1.0, "section_id": 8704}}}, "36779670": {"Id": "36779670", "PostTypeId": "2", "Body": "<p>You are passing a valid address, and if the memory pointed to is big enough to contain the object, and its alignment is compatible with that object, then it's perfectly fine code.</p>\n<p>The alignment should be implicitly correct if <code>sizeof(T) &lt;= sizeof(storage)</code>. But you can be paranoid about it and explicitly set it with:</p>\n<pre><code>alignas(T) void* storage = 0;\n</code></pre>\n<p>Although I <em>think</em> that manually setting the alignment isn't actually needed, and <code>sizeof(T) &lt;= sizeof(storage)</code> would mean correct alignment is guaranteed, I'm not 100% sure.</p>\n<p>Note that just because the type of <code>storage</code> is <code>void*</code> doesn't mean anything. This particular placement new is defined by the standard as:</p>\n<pre><code>void* operator new(std::size_t count, void* ptr);\n</code></pre>\n<p>The address parameter is <code>void*</code>, meaning the type pointed to can be anything. The only requirement is that it's an address to valid memory.</p>\n<p>However, if <code>storage</code> ever goes out of scope, you're busted if the object contained within needs to be destructed. You need to call the destructor before <code>storage</code> goes out of scope.</p>\n<p>Also note that \"placement delete\" (this is automatically called if needed, it's not possible to write code that does it) will never actually free memory. So <code>storage</code> being on the stack is still fine even if placement delete gets called (like when a constructor throws.)</p>\n", "LastEditorUserId": "856199", "LastActivityDate": "2016-04-21T23:59:59.507", "Score": "3", "CreationDate": "2016-04-21T20:21:17.987", "ParentId": "36779096", "CommentCount": "5", "OwnerUserId": "856199", "LastEditDate": "2016-04-21T23:59:59.507"}, "36779096": {"ViewCount": "68", "Body": "<p>Assuming <code>sizeof(T) &lt;= sizeof(void*)</code>, is the following well defined / portable? ...</p>\n<pre><code>void* storage = 0;\nnew (&amp;storage) T(t);\n</code></pre>\n<p>This seems like it could be used as a sensible small-object optimisation, if so.</p>\n", "AcceptedAnswerId": "36779670", "Title": "Placement new using void* bits as storage", "CreationDate": "2016-04-21T19:45:51.773", "Id": "36779096", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-04-22T00:05:04.480", "Score": "2", "OwnerUserId": "4464083", "Tags": "<c++><placement-new>", "AnswerCount": "2"}, "36782474": {"Id": "36782474", "PostTypeId": "2", "Body": "<p>Supposing you have checked the alignment is correct , as described in Nikos C.'s answer:</p>\n<p>The <code>new</code> is legal, however the name <code>storage</code> may no longer be used to refer to the object in any way (unless <code>T</code> = <code>void *</code>).  You need to write:</p>\n<pre><code>T *ptr = new(&amp;storage) T(t);\n</code></pre>\n<p>and use <code>ptr</code> thereafter.</p>\n<p>See [basic.life]/7:</p>\n<blockquote>\n<p id=\"so_36779096_36782474_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or <strong>the name of the original object</strong> will automatically refer to the new object and, once the lifetime of the new object has started, <strong>can be used to manipulate the new object, if:</strong></p>\n<ul>\n<li>the storage for the new object exactly overlays the storage location which the original object occupied, <strong>and</strong></li>\n<li>the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), <strong>and</strong>\n  [...]</li>\n</ul>\n</blockquote>\n<p>The second bullet point is false, so the name of the original object cannot be used to manipulate the new object. </p>\n<hr>\n<p>NB: You certainly can't do anything like <code>cout &lt;&lt; storage;</code>. But it's not clear to me whether it is legal to write:</p>\n<pre><code>new(&amp;storage) T(t);\nT *ptr = reinterpret_cast&lt;T&gt;(&amp;storage);\n</code></pre>\n<p>i.e. if the name of the original object is only used in order to take its address and then that address is used to manipulate the new object, does that count as manipulating the new object via the original object's name?  In either case that issue can be avoided by using the code suggested at the top of the post.</p>\n</hr>", "LastActivityDate": "2016-04-22T00:05:04.480", "CommentCount": "4", "CreationDate": "2016-04-22T00:05:04.480", "ParentId": "36779096", "Score": "0", "OwnerUserId": "1505939"}});