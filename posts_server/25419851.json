post_cb({"25420134": {"ParentId": "25419851", "CommentCount": "1", "Body": "<p>Yes, this is possible, and libstdc++ is doing this.\nYou can have a look at the documentation of <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.0/libstdc++/api/a01523_source.html#l00890\" rel=\"nofollow\">data() in libstdc++</a></p>\n<pre><code> data() _GLIBCXX_NOEXCEPT\n { return _M_data_ptr(this-&gt;_M_impl._M_start); }\n</code></pre>\n<p>However, performing actions on this pointer may not be specified, as you are accessing an non-initialized range within your vector, without its knowledge (e.g you don't know the exact size of the memory bunch). Also, as <code>size()</code> is 0, your valid range is still empty.</p>\n", "OwnerUserId": "1810521", "PostTypeId": "2", "Id": "25420134", "Score": "0", "CreationDate": "2014-08-21T07:01:54.223", "LastActivityDate": "2014-08-21T07:01:54.223"}, "25419851": {"CommentCount": "10", "ViewCount": "3995", "PostTypeId": "1", "LastEditorUserId": "417197", "CreationDate": "2014-08-21T06:45:22.630", "LastActivityDate": "2017-11-30T19:04:52.673", "Title": "What should std::vector::data() return if the vector is empty?", "AcceptedAnswerId": "25420131", "LastEditDate": "2014-08-21T07:47:33.040", "Id": "25419851", "Score": "13", "Body": "<p>According to the draft standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">23.3.6.4 vector data</a>), data() points to the underlying array and <code>[data(), data() + size())</code> must be a valid range:</p>\n<pre><code>T* data() noexcept;\nconst T* data() const noexcept;\n\n    1 Returns: A pointer such that [data(),data() + size()) is a valid range. For a non-empty vector,\ndata() == &amp;front().\n    2 Complexity: Constant time\n</code></pre>\n<p>But what if the vector is empty? When I construct a zero-size vector:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    const int NUM = 0*10;\n    std::vector&lt; double &gt; v( NUM, 0.0 );\n    std::cerr &lt;&lt; \"V : \"&lt;&lt; v.data() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>MSVC 2010 returns null, but on Linux (with GCC 4.2.1 and Intel 12.1) I get a non-null address.</p>\n<p>Is <code>vector::data()</code> allowed to or should it return null? Could an implementation, for example, do a default-size initial allocation and return a (non-null) pointer to it?</p>\n<p><strong>Edit:</strong> Several answers focus on the validity of an empty-range. I fully agree there. </p>\n<p>I would really like to see a good reference or explanation for: Is it <em>allowed to</em>, <em>must it</em> return null or <em>may it</em> also return non-null?</p>\n", "Tags": "<c++><vector>", "OwnerUserId": "417197", "AnswerCount": "4"}, "47580845": {"ParentId": "25419851", "CommentCount": "1", "Body": "<p>None of the wording in the standard suggests a given value for data() if the vector is empty().</p>\n<p>And here's some definitive proof of why you should not assume it might be zero, even though it sometimes is:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\n\nvoid value_of_data(std::vector&lt;int&gt; const&amp; v)\n{\n    std::cout &lt;&lt; \"empty() = \" &lt;&lt; v.empty() &lt;&lt; \", \" &lt;&lt; \"data() = \" &lt;&lt; static_cast&lt;const void*&gt;(v.data()) &lt;&lt; std::endl;\n}\n\n\n\nint main()\n{\n    std::vector&lt;int&gt; v;\n    value_of_data(v);\n\n    v.resize(100, 0);\n    v.clear();\n    value_of_data(v);\n}\n</code></pre>\n<p>example output (gcc7.2, -O2, linux):</p>\n<pre><code>empty() = 1, data() = 0\nempty() = 1, data() = 0x7ebc30\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/dd1d13200c8b9a3a\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/dd1d13200c8b9a3a</a></p>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "47580845", "Score": "1", "CreationDate": "2017-11-30T19:04:52.673", "LastActivityDate": "2017-11-30T19:04:52.673"}, "25420131": {"ParentId": "25419851", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The convention for ranges is <code>[inclusive, exclusive)</code>, that is if you iterate over a range <code>[X,Y)</code> you will conceptually do the following (pseudo-code):</p>\n<pre><code>for( iterator ii = X; ii != Y; ++ii) {\n...\n}\n</code></pre>\n<p>This permits to express an empty range as <code>[X,X)</code>. Also this empty range is perfectly well defined for <strong>each address</strong>, no matter if it is valid or invalid.</p>\n<p>That said the requirements for <code>data()</code> are <strong>(emphasis mine)</strong>:</p>\n<blockquote>\n<p id=\"so_25419851_25420131_0\"><strong>23.3.6.4</strong> <strong>[vector.data]</strong></p>\n<p id=\"so_25419851_25420131_1\">T* data() noexcept; </p>\n<p id=\"so_25419851_25420131_2\">const T* data() const noexcept; </p>\n<p id=\"so_25419851_25420131_3\">Returns: A pointer such that <strong>[data(),data() + size()) is a valid range</strong>. For a\n  non-empty vector, data() == &amp;front().</p>\n</blockquote>\n<p>It seems to me that the only unconditional guarantee is that <code>[data(),data() + size())</code> should be a valid range. For <code>size() == 0</code> the member function <code>data()</code> may return any value and the range will be a valid empty range. Therefore I would say that <em>an implementation is allowed to return a non-null pointer if <code>size()</code> is zero</em>.</p>\n", "OwnerUserId": "771663", "LastEditorUserId": "661519", "LastEditDate": "2014-08-21T07:58:29.133", "Id": "25420131", "Score": "12", "CreationDate": "2014-08-21T07:01:43.707", "LastActivityDate": "2014-08-21T07:58:29.133"}, "25420087": {"ParentId": "25419851", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>There is a state that an object can be valid but unspecified:</p>\n<blockquote>\n<p id=\"so_25419851_25420087_0\"><strong>valid but unspecified state</strong> [\u00a7 17.3]</p>\n<p id=\"so_25419851_25420087_1\">an object state that is not specified except that the object\u2019s\n  invariants are met and operations on the object behave as specified\n  for its type</p>\n<p id=\"so_25419851_25420087_2\">[<em>Example:</em> If an object x of type std::vector is in a valid but\n  unspecified state, x.empty() can be called unconditionally, and\n  x.front() can be called only if x.empty() returns false. <em>\u2014end example</em>]</p>\n</blockquote>\n<p>Reading the C++ standard, the state of <code>data()</code> is not specified when the vector is empty. So, the state is <em>valid but unspecified state</em>. Therefore, the returned value of <code>data()</code> when the vector is empty can be anything (null or a random value). It depends on implementation of the compiler.</p>\n<p>In this case, following the example in \u00a717.3, you should call <code>empty()</code> before using <code>data()</code> to ensure that the returned value is as your expectation.</p>\n<pre><code>if (!v.empty())\n   do_something(v.data())\n</code></pre>\n", "OwnerUserId": "952747", "LastEditorUserId": "952747", "LastEditDate": "2016-05-26T09:13:05.957", "Id": "25420087", "Score": "0", "CreationDate": "2014-08-21T06:59:31.193", "LastActivityDate": "2016-05-26T09:13:05.957"}, "bq_ids": {"n4140": {"so_25419851_25420087_0": {"section_id": 1341, "quality": 0.8, "length": 4}, "so_25419851_25420131_3": {"section_id": 984, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_25419851_25420087_0": {"section_id": 1335, "quality": 0.8, "length": 4}, "so_25419851_25420131_3": {"section_id": 969, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_25419851_25420131_3": {"section_id": 1047, "quality": 0.6666666666666666, "length": 8}, "so_25419851_25420087_0": {"section_id": 1471, "quality": 0.8, "length": 4}, "so_25419851_25420087_1": {"section_id": 7709, "quality": 1.0, "length": 13}, "so_25419851_25420087_2": {"section_id": 7709, "quality": 0.8, "length": 16}}}});