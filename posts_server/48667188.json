post_cb({"bq_ids": {"n4140": {"so_48667188_48667370_0": {"length": 39, "quality": 0.975, "section_id": 7143}, "so_48667188_48667188_0": {"length": 15, "quality": 1.0, "section_id": 6966}}, "n3337": {"so_48667188_48667370_0": {"length": 39, "quality": 0.975, "section_id": 6887}, "so_48667188_48667188_0": {"length": 15, "quality": 1.0, "section_id": 6713}}, "n4659": {"so_48667188_48667370_0": {"length": 39, "quality": 0.975, "section_id": 8644}, "so_48667188_48667188_0": {"length": 15, "quality": 1.0, "section_id": 8465}}}, "48667188": {"ViewCount": "82", "Body": "<p>When is a type compatible with another type in C++? I have looked in the standard and cannot find a definition of type compatibility.</p>\n<p>Example of usage in the standard (n3690): Section 18.10 runtime support:</p>\n<blockquote>\n<p id=\"so_48667188_48667188_0\">If the parameter parmN is of a reference type, or of a type that is\n  not compatible with the type that results when passing an argument for\n  which there is no parameter, the behavior is undefined.</p>\n</blockquote>\n<p>Are types simply \"compatible\" with each other if they can be implicitly converted to each other?</p>\n", "Title": "When is a type compatible with another?", "CreationDate": "2018-02-07T15:14:31.307", "LastActivityDate": "2018-02-07T15:44:09.170", "CommentCount": "7", "LastEditDate": "2018-02-07T15:44:09.170", "PostTypeId": "1", "LastEditorUserId": "5376789", "Id": "48667188", "Score": "1", "OwnerUserId": "9224744", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "48667370": {"Id": "48667370", "PostTypeId": "2", "Body": "<p>C++ does not have the concept of \"compatible type\" while C does.</p>\n<p>In C, two declarations for the same entity must declare compatible types, while in C++, this constraint is replaced by <a href=\"http://www.eel.is/c++draft/basic.link#10\" rel=\"nofollow noreferrer\">[basic.link]/10</a>:</p>\n<blockquote>\n<p id=\"so_48667188_48667370_0\">After all adjustments of types (during which typedefs are replaced by their definitions), the types specified by all declarations referring to a given variable or function shall be identical, except that declarations for an array object can specify array types that differ by the presence or absence of a major array bound ([dcl.array]). A violation of this rule on type identity does not require a diagnostic.</p>\n</blockquote>\n<p>The wording you quoted is a description of <code>&lt;cstdarg&gt;</code> header, which comes from corresponding C header. So you can regard \"compatible\" here as the same concept in C.</p>\n", "LastEditorUserId": "5376789", "LastActivityDate": "2018-02-07T15:35:25.657", "Score": "1", "CreationDate": "2018-02-07T15:23:48.870", "ParentId": "48667188", "CommentCount": "2", "OwnerUserId": "5376789", "LastEditDate": "2018-02-07T15:35:25.657"}, "48667427": {"Id": "48667427", "PostTypeId": "2", "Body": "<p>When RHS variable can be assigned to LHS variable, then RHS variable's type is comparable for <b> type conversation</b>.\nYou can read more about type conversation <a href=\"http://www.edugrabs.com/type-conversion-and-type-casting-in-c/\" rel=\"nofollow noreferrer\"> here</a></p>\n", "LastActivityDate": "2018-02-07T15:26:00.120", "Score": "-1", "CreationDate": "2018-02-07T15:26:00.120", "ParentId": "48667188", "CommentCount": "1", "OwnerUserId": "5777863"}});