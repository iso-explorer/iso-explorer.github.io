post_cb({"bq_ids": {"n4140": {"so_25133383_25133725_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 7103}}, "n3337": {"so_25133383_25133725_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 6847}}, "n4659": {"so_25133383_25133725_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 8604}}}, "25133383": {"ViewCount": "296", "Body": "<p><a href=\"https://stackoverflow.com/a/5076640/321013\">Examples</a> <a href=\"https://groups.google.com/forum/#!original/comp.lang.c++.moderated/1Qz71aFnXlI/Gd71gwRaWssJ\" rel=\"nofollow noreferrer\">such as</a> enabling outputting of <code>std</code> types explain how <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow noreferrer\">ADL</a> can be used to \"inject\" a certain function/operator, depending on the type the fn/op is applied to.</p>\n<p>I was wondering wheter ADL fully applies to the global namespace, that is, whether a type declared (or made available via <code>using</code>) at <a href=\"https://stackoverflow.com/a/10269085/321013\">global namespace scope</a> makes ADL look for matching functions in the global namespace?</p>\n<p>Specifically, are these equivalent wrt. ADL?:</p>\n<pre><code>// 1 - at global namespace scope\nstruct GlobalType {};\n\ntemplate&lt; class Ch, class Tr&gt;\nstd::basic_ostream&lt;Ch, Tr&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, GlobalType const&amp; x)\n{\n    os &lt;&lt; ...;\n    return os;\n} \n\n// 2 - within namespace\nnamespace ecaps {\n\n    struct EcapsType {};\n\n    template&lt; class Ch, class Tr&gt;\n    std::basic_ostream&lt;Ch, Tr&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, EcapsType const&amp; x)\n    {\n        os &lt;&lt; ...;\n        return os;\n    } \n\n}\n\n// 3 - Type brought to global NS via using, function at global scope\nnamespace other {\n    struct OtherType {};    \n}\n\nusing other::OtherType;\n\ntemplate&lt; class Ch, class Tr&gt;\nstd::basic_ostream&lt;Ch, Tr&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, OtherType const&amp; x)\n{\n    os &lt;&lt; ...;\n    return os;\n} \n</code></pre>\n<hr>\n<p>Wrt. global namespace scope not needing ADL: (update after a now deleted answer)</p>\n<p>One <a href=\"https://groups.google.com/forum/#!original/comp.lang.c++.moderated/1Qz71aFnXlI/Gd71gwRaWssJ\" rel=\"nofollow noreferrer\">Daniel Kr\u00fcgler of Committee fame describes an ADL problem</a> as such:</p>\n<blockquote>\n<p id=\"so_25133383_25133383_0\">This unqualified call has the effect that unqualified name lookup\n  happens and as a consequence of this, the compiler searches for the\n  name <code>operator&lt;&lt;</code>. beginning <strong>from the lexical location where the\n  <code>operator&lt;&lt;</code> call is found \"upwards\"</strong> (...) starting in the current namespace and all the\n  namespaces that include that namespace (including the global\n  namespace, btw.) and - ...</p>\n</blockquote>\n<p>Emph. mine. Note how the outer namespaces are described to only be considered \"... <em>from the lexical location</em> ...\". He continues:</p>\n<blockquote>\n<p id=\"so_25133383_25133383_1\">... and - as a second route - it performs a second phase of this\n  lookup the compiler searches in the so-called associated namespaces of\n  the argument types occurring in this call.</p>\n<p id=\"so_25133383_25133383_2\">In the presented example, the first phase of the search fails, because\n  at the point where <code>#include &lt;iterator&gt;</code> exists, there is no\n  corresponding <code>operator&lt;&lt;</code> for these argument types in any namespace.\n  Note that your declaration of <code>operator&lt;&lt;</code> is provided lexically <em>after</em>\n  the point where the call of <code>operator&lt;&lt;</code> happens somewhere in some of\n  the library headers. <strong>The second phase of the search would also\n  consider locations that\n  <em>follow</em> the actual function call</strong>, but only within the associated namespaces.</p>\n</blockquote>\n<p>Bold emph. mine. So it would seem to me it <em>is</em> relevant that ADL works for the global namespace. Of course I could easily have misunderstood something.</p>\n<hr>\n<p>Note: This <em>may</em> be a case of the standard simply not explicitly mentioning it one way or another, because the global NS is just like any other namespace -- then again it may not, my knowledge of the Standard is very limited.</p>\n</hr></hr>", "Title": "Does ADL work for the global namespace?", "CreationDate": "2014-08-05T07:31:18.967", "LastActivityDate": "2014-08-07T19:32:00.727", "CommentCount": "3", "LastEditDate": "2017-05-23T11:43:39.190", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "25133383", "Score": "2", "OwnerUserId": "321013", "Tags": "<c++><namespaces><using><argument-dependent-lookup><global-namespace>", "AnswerCount": "1"}, "25133725": {"Id": "25133725", "PostTypeId": "2", "Body": "<p><strong>Completely forget my initial answer, it was plain wrong.</strong></p>\n<p>From the C++11 standard, \u00a73.4.2 on ADL (emphasis mine):</p>\n<blockquote>\n<p id=\"so_25133383_25133725_0\">When the postfix-expression in a function call (5.2.2) is an\n  unqualified-id, other namespaces <strong>not considered during the usual\n  unqualified lookup</strong> (3.4.1) may be searched, and in those namespaces,\n  namespace-scope friend function declarations (11.3) not otherwise\n  visible may be found.</p>\n</blockquote>\n<p>So in short, since unqualified lookup will always search in the global namespace, <strong>ADL will <em>never</em> apply to global namespace</strong>.</p>\n", "LastEditorUserId": "1838266", "LastActivityDate": "2014-08-05T08:24:55.420", "Score": "1", "CreationDate": "2014-08-05T07:53:01.233", "ParentId": "25133383", "CommentCount": "2", "OwnerUserId": "1838266", "LastEditDate": "2014-08-05T08:24:55.420"}});