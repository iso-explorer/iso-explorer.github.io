post_cb({"6803556": {"ViewCount": "163", "Body": "<p>I have no intention of using this in real code. I promise. </p>\n<p>Does the standard guarantee that <code>std</code> namespace is going to be found when a function argument is of type <code>container::iterator</code> and <code>container::iterator</code> isn't a <code>typedef</code> for a built-in type?</p>\n<p>For example</p>\n<pre><code>#include &lt;set&gt;\n#include &lt;algorithm&gt;\nint main()\n{\n   std::set&lt;int&gt; s;\n   find(s.begin(), s.end(), 0); //do I have a guarantee that std::find will be found?\n}\n</code></pre>\n<p>In other words, can the iterator class be defined in such a namespace that <code>std</code> won't be considered by ADL?</p>\n<p>Thanks in advance.</p>\n", "AcceptedAnswerId": "6803635", "Title": "Do custom container iterators guarantee ADL to consider namespace std?", "CreationDate": "2011-07-23T21:55:37.813", "Id": "6803556", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-02T16:06:43.257", "LastEditorUserId": "469935", "LastActivityDate": "2014-12-02T16:06:43.257", "Score": "7", "OwnerUserId": "469935", "Tags": "<c++><stl><iterator><std><argument-dependent-lookup>", "AnswerCount": "2"}, "6803628": {"Id": "6803628", "PostTypeId": "2", "Body": "<p>The exact type of <code>::iterator</code> etc. for the standard containers is <em>implementation-defined</em>, so in theory there's nothing stopping it from being a <code>typedef</code> to something outside of <code>std::</code> (e.g. a plain pointer).</p>\n<p>I can't find anything else in the standard that suggests that ADL will always work in this case, so -- unless someone corrects me -- I'm going to have to say that the answer is: no, you can't assume that <code>find</code> will be found via ADL.</p>\n", "LastActivityDate": "2011-07-23T22:09:09.377", "CommentCount": "0", "CreationDate": "2011-07-23T22:09:09.377", "ParentId": "6803556", "Score": "5", "OwnerUserId": "235825"}, "bq_ids": {"n4140": {"so_6803556_6803635_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 7104}, "so_6803556_6803635_2": {"length": 7, "quality": 1.0, "section_id": 7104}, "so_6803556_6803635_1": {"length": 18, "quality": 0.5142857142857142, "section_id": 7105}}, "n3337": {"so_6803556_6803635_0": {"length": 24, "quality": 1.0, "section_id": 6848}, "so_6803556_6803635_2": {"length": 7, "quality": 1.0, "section_id": 6848}, "so_6803556_6803635_1": {"length": 18, "quality": 0.5142857142857142, "section_id": 6849}}, "n4659": {"so_6803556_6803635_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 8605}, "so_6803556_6803635_2": {"length": 7, "quality": 1.0, "section_id": 8605}, "so_6803556_6803635_1": {"length": 18, "quality": 0.5142857142857142, "section_id": 8606}}}, "6803635": {"Id": "6803635", "PostTypeId": "2", "Body": "<p>I believe that the answer is <strong>no</strong> in the most general case, but <strong>yes</strong> for most practical implementations.</p>\n<p>According to the C++ ISO standard, \u00a73.4.2/2, there is a notion of an \"associated namespace\" for an argument, which is defined in a way that includes</p>\n<blockquote>\n<p id=\"so_6803556_6803635_0\">If T is a class type (including unions), its associated classes are: the class itself; <strong>the class of which it is a\n  member, if any</strong>; and its direct and indirect base classes. <strong>Its associated namespaces are the namespaces\n  in which its associated classes are defined.</strong></p>\n</blockquote>\n<p>This suggests that if the iterator type is really a nested type inside of some container like <code>std::set</code>, then an associated namespace for that iterator in the call to <code>find</code> would be <code>std</code>, since <code>std::set</code> is an associated class and <code>std</code> is the namespace containing <code>set</code>.  The standard then says that (\u00a73.4.2/2a)</p>\n<blockquote>\n<p id=\"so_6803556_6803635_1\">If the ordinary unqualified lookup of the name finds the declaration of a class member function, the associated namespaces and classes are not considered. Otherwise <strong>the set of declarations found by the lookup of the function name is the union of the set of declarations found using ordinary unqualified lookup and the set\n  of declarations found in the namespaces and classes associated with the argument types</strong>.</p>\n</blockquote>\n<p>This would mean that you would indeed find the <code>find</code> function in <code>namespace std</code>.</p>\n<p>However, this is <em>not</em> guaranteed to work in general.  We also have from the spec (\u00a73.4.2) that</p>\n<blockquote>\n<p id=\"so_6803556_6803635_2\">Typedef names and using-declarations used to specify the types do not contribute to this set.</p>\n</blockquote>\n<p>So, as you mentioned in your question, if the iterator type is some sort of <code>typedef</code>, this isn't guaranteed to work correctly.  But barring that, it appears that if you know that the type is not a typedef, it has to be in <code>namespace std</code> or nested in a class in <code>namespace std</code> and should get picked up for ADL.  <strong>But don't do it!</strong> :-)</p>\n", "LastEditorUserId": "501557", "LastActivityDate": "2011-07-23T22:42:50.107", "Score": "5", "CreationDate": "2011-07-23T22:11:02.350", "ParentId": "6803556", "CommentCount": "3", "OwnerUserId": "501557", "LastEditDate": "2011-07-23T22:42:50.107"}});