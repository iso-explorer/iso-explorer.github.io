post_cb({"bq_ids": {"n4140": {"so_24930921_24931369_0": {"length": 26, "quality": 0.7222222222222222, "section_id": 7117}}, "n3337": {"so_24930921_24931369_0": {"length": 26, "quality": 0.7222222222222222, "section_id": 6861}}, "n4659": {"so_24930921_24931369_0": {"length": 26, "quality": 0.7222222222222222, "section_id": 8618}}}, "24930921": {"ViewCount": "152", "Body": "<p>Consider the following Code Snippet</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nnamespace Foo {\n    void bar() {\n        std::cout&lt;&lt;\"FOO::BAR\"&lt;&lt;std::endl;\n    }\n}\nnamespace Spam {\n    void bar() {\n        std::cout&lt;&lt;\"SPAM::BAR\"&lt;&lt;std::endl;\n    }\n}\nnamespace fallbacks {\n    using Foo::bar;\n}\n\nnamespace Spam {\n    using namespace fallbacks;\n}\n\nint main() {\n    Spam::bar();\n}\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>SPAM::BAR\n</code></pre>\n<p>I understand that in this case, if Spam contains the member  it will refer to it. However if it doesn't , then the using directive's name will be found and refer to fallbacks::bar.</p>\n<p>But I cannot find any authentic source to back the above statement.</p>\n", "AcceptedAnswerId": "24931369", "Title": "Determine which member is visible in a namespace", "CreationDate": "2014-07-24T10:11:32.737", "Id": "24930921", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-07-24T10:39:25.277", "LastEditorUserId": "977038", "LastActivityDate": "2014-07-24T10:40:49.950", "Score": "3", "OwnerUserId": "977038", "Tags": "<c++>", "AnswerCount": "2"}, "24931369": {"Id": "24931369", "PostTypeId": "2", "Body": "<p><strong>Section 3.4.3</strong> of the standard describes qualified name lookup. In particular, <strong>section</strong> <strong>3.4.3.2</strong> describes the lookup of namespace members. </p>\n<blockquote>\n<p id=\"so_24930921_24931369_0\">3.4.3.2.2: For a namespace <code>X</code> and name <code>m</code>, the\n  namespace-qualified lookup set <code>S(X,m)</code> is defined as follows: Let\n  <code>S'(X,m)</code> be the set of all declarations of <code>m</code> in <code>X</code> and the inline\n  namespace set of <code>X</code> (7.3.1). If <code>S'(X,m)</code> is not empty, <code>S(X,m)</code> is\n  <code>S'(X,m)</code>; otherwise, <code>S(X,m)</code> is the union of <code>S(N_i,m)</code> for all namespaces\n  <code>N_i</code> nominated by <em>using-directives</em> in <code>X</code> and its inline namespace set.</p>\n</blockquote>\n<p><em>(Source: ISO/IEC 14882:2011: C++ Standard)</em></p>\n<p>The following example is given:</p>\n<pre><code>int x;\n\nnamespace Y {\n    void f(float);\n    void h(int);\n}\n\nnamespace Z {\n    void h(double);\n}\n\nnamespace A {\n    using namespace Y;\n    void f(int);\n    void g(int);\n    int i;\n}\n\nnamespace B {\n    using namespace Z;\n    void f(char);\n    int i;\n}\n\nnamespace AB {\n    using namespace A;\n    using namespace B;\n    void g();\n}\n\nvoid h()\n{\n    AB::g();  // g is declared directly in AB,\n              // therefore S is { AB::g() } and AB::g() is chosen\n\n    AB::f(1); // f is not declared directly in AB so the rules are\n              // applied recursively to A and B;\n              // namespace Y is not searched and Y::f(float)\n              // is not considered;\n              // S is { A::f(int), B::f(char) } and overload\n              // resolution chooses A::f(int)\n\n    AB::f(\u2019c\u2019); // as above but resolution chooses B::f(char)\n\n    AB::x++;  // x is not declared directly in AB, and\n              // is not declared in A or B , so the rules are\n              // applied recursively to Y and Z,\n              // S is { } so the program is ill-formed\n\n    AB::i++;  // i is not declared directly in AB so the rules are\n              // applied recursively to A and B,\n              // S is { A::i , B::i } so the use is ambiguous\n              // and the program is ill-formed\n\n    AB::h(16.8); // h is not declared directly in AB and\n                 // not declared directly in A or B so the rules are\n                 // applied recursively to Y and Z,\n                 // S is { Y::h(int), Z::h(double) } and overload\n                 // resolution chooses Z::h(double)\n}\n</code></pre>\n<p><em>(Source: ISO/IEC 14882:2011: C++ Standard)</em></p>\n<p>In your example, if <code>Spam</code> contains <code>bar</code>, the set <code>S</code> contains <code>{Spam::bar}</code> and lookup stops. If the namespace <code>Spam</code> does not contain <code>bar</code>, any namespaces or <code>bar</code>s declared via <code>using</code> directives inside Spam will be searched, and this logic is applied recursively until either:</p>\n<ol>\n<li>A namespace is found that contains <code>bar</code>, or</li>\n<li>the possible search paths are exhausted, in which case the program is ill-formed.</li>\n</ol>\n", "LastActivityDate": "2014-07-24T10:34:46.760", "CommentCount": "1", "CreationDate": "2014-07-24T10:34:46.760", "ParentId": "24930921", "Score": "5", "OwnerUserId": "3852968"}, "24931484": {"Id": "24931484", "PostTypeId": "2", "Body": "<p>The corresponding name look-up of qualified names is described in the following paragraphs of section 3.4.3.2 Namespace members of the C++ Standard</p>\n<p>2 For a namespace X and name m, the namespace-qualified lookup set S(X,m) is defined as follows: Let S0(X,m) be the set of all declarations of m in X and the inline namespace set of X (7.3.1). If S0(X,m) is not empty, S(X,m) is S0(X,m); otherwise, S(X,m) is the union of S(Ni,m) for all namespaces Ni nominated by using-directives in X and its inline namespace set.</p>\n<p>3 Given X::m (where X is a user-declared namespace), or given ::m (where X is the global namespace), if S(X,m) is the empty set, the program is ill-formed. Otherwise, if S(X,m) has exactly one member, or if the context of the reference is a using-declaration (7.3.3), S(X,m) is the required set of declarations of m. Otherwise if the use of m is not one that allows a unique declaration to be chosen from S(X,m), the program is ill-formed.</p>\n<p>In your case if to follow the quote \"<strong>Let S0(X,m) be the set of all declarations of m in X and the inline namespace set of X (7.3.1). If S0(X,m) is not empty, S(X,m) is S0(X,m);</strong> \" S( Spam, bar ) consists of one declaration of bar in Spam. And this declaration is the only declaration in Spam.  so this name will be found. </p>\n", "LastActivityDate": "2014-07-24T10:40:49.950", "CommentCount": "0", "CreationDate": "2014-07-24T10:40:49.950", "ParentId": "24930921", "Score": "1", "OwnerUserId": "2877241"}});