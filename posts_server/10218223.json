post_cb({"10218223": {"CommentCount": "9", "ViewCount": "2247", "CreationDate": "2012-04-18T21:22:26.143", "LastActivityDate": "2012-04-20T04:08:16.083", "Title": "How to insert a duplicate element into a vector?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "10218223", "Score": "11", "Body": "<p>I'm trying to insert a copy of an existing <code>vector</code> element to double it up. The following code worked in previous versions but fails in Visual Studio 2010.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n   vector&lt;int&gt; test;\n   test.push_back(1);\n   test.push_back(2);\n   test.insert(test.begin(), test[0]);\n   cout &lt;&lt; test[0] &lt;&lt; \" \" &lt;&lt; test[1] &lt;&lt; \" \" &lt;&lt; test[2] &lt;&lt; endl;\n   return 0;\n}\n</code></pre>\n<p>Output is <code>-17891602 1 2</code>, expected <code>1 1 2</code>.</p>\n<p>I've figured out why it's happening - the vector is being reallocated, and the reference becomes invalid before it's copied to the insertion point. The older Visual Studio apparently did things in a different order, thus proving that one possible outcome of undefined behavior is to work correctly and also proving that it's never something you should rely on.</p>\n<p>I've come up with two different ways to fix this problem. One is to use <code>reserve</code> to make sure that no reallocation takes place:</p>\n<pre><code>   test.reserve(test.size() + 1);\n   test.insert(test.begin(), test[0]);\n</code></pre>\n<p>The other is to make a copy from the reference so that there's no dependency on the reference remaining valid:</p>\n<pre><code>template&lt;typename T&gt;\nT make_copy(const T &amp; original)\n{\n    return original;\n}\n\n   test.insert(test.begin(), make_copy(test[0]));\n</code></pre>\n<p>Although both work, neither one feels like a natural solution. Is there something I'm missing?</p>\n", "Tags": "<c++><visual-studio-2010><vector>", "OwnerUserId": "5987", "AnswerCount": "2"}, "10240126": {"ParentId": "10218223", "CommentCount": "1", "Body": "<p>The issue is that <code>vector::insert</code> takes a reference to a value as the second parameter and not a value.  You don't need the template to make a copy, just use a copy constructor to create another object, which will be pass by reference.  This copy remains valid even if the vector is resized.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n   vector&lt;int&gt; test;\n   test.push_back(1);\n   test.push_back(2);\n   test.insert(test.begin(), int(test[0]));\n   cout &lt;&lt; test[0] &lt;&lt; \" \" &lt;&lt; test[1] &lt;&lt; \" \" &lt;&lt; test[2] &lt;&lt; endl;\n   return 0;\n}\n</code></pre>\n", "OwnerUserId": "567749", "PostTypeId": "2", "Id": "10240126", "Score": "4", "CreationDate": "2012-04-20T04:08:16.083", "LastActivityDate": "2012-04-20T04:08:16.083"}, "bq_ids": {"n4140": {"so_10218223_10220042_1": {"section_id": 986, "quality": 0.9473684210526315, "length": 18}, "so_10218223_10220042_0": {"section_id": 723, "quality": 0.75, "length": 9}}, "n3337": {"so_10218223_10220042_1": {"section_id": 971, "quality": 0.9473684210526315, "length": 18}, "so_10218223_10220042_0": {"section_id": 712, "quality": 0.75, "length": 9}}, "n4659": {"so_10218223_10220042_1": {"section_id": 1049, "quality": 0.9473684210526315, "length": 18}, "so_10218223_10220042_0": {"section_id": 754, "quality": 0.75, "length": 9}}}, "10220042": {"ParentId": "10218223", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I believe this is defined behavior. In <code>\u00a723.2.3</code> of the 2011 C++ standard, table 100 lists sequence container requirements and there is an entry for this case. It gives the example expression</p>\n<pre><code>a.insert(p,t)\n</code></pre>\n<p>where <code>a</code> is a value of <code>X</code> which is a sequence container type containing elements of type <code>T</code>, <code>p</code> is a const iterator to <code>a</code>, and <code>t</code> is an lvalue or const rvalue of type <code>X::value_type</code>, i.e. <code>T</code>. </p>\n<p>The assertion for this expression is:</p>\n<blockquote>\n<p id=\"so_10218223_10220042_0\"><em>Requires:</em> <code>T</code> shall be <code>CopyInsertable</code> into <code>X</code>. For <code>vector</code> and <code>deque</code>, <code>T</code> shall also be <code>CopyAssignable</code>. \n  <br/><em>Effects:</em> Inserts a copy of <code>t</code> before <code>p</code>.</p>\n</blockquote>\n<p>The only relevant vector specific quote I could find is in <code>\u00a723.3.6.5</code> paragraph 1:</p>\n<blockquote>\n<p id=\"so_10218223_10220042_1\"><em>Remarks:</em> Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>Although this does mention the vector being reallocated, it doesn't make an exception to the previous requirements for <code>insert</code> on sequence containers.</p>\n<p>As for working around this issue, I agree with @EdChum's suggestion of just making a copy of the element and inserting that copy.</p>\n", "OwnerUserId": "185171", "LastEditorUserId": "185171", "LastEditDate": "2012-04-19T04:45:37.497", "Id": "10220042", "Score": "1", "CreationDate": "2012-04-19T00:30:33.000", "LastActivityDate": "2012-04-19T04:45:37.497"}});