post_cb({"45653336": {"CommentCount": "6", "ViewCount": "97", "PostTypeId": "1", "LastEditorUserId": "1503898", "CreationDate": "2017-08-12T18:03:01.287", "LastActivityDate": "2017-08-12T22:09:15.213", "Title": "using std::is_base_of in static_assert fails due to incomplete type", "AcceptedAnswerId": "45655346", "LastEditDate": "2017-08-12T18:18:22.660", "Id": "45653336", "Score": "3", "Body": "<p>What I am trying to do is have some classes inherit form an <code>extention</code> class. The thing is the <code>extention</code> class has to know which class it is extending.</p>\n<p>This can simply be achieved like this:</p>\n<pre><code>template&lt;typename Self&gt;\nclass Extention\n{\n    public:\n        void check() const\n        {\n            std::cout &lt;&lt; \"Extention is valid: \"\n                      &lt;&lt; std::boolalpha\n                      &lt;&lt; std::is_base_of&lt;Extention, Self&gt;::value\n                    &lt;&lt; std::endl;\n        }\n};\nclass Foo : public Extention&lt;Foo&gt; {};\nclass Bar : public Extention&lt;void&gt; {};\n</code></pre>\n<p>The <code>Foo</code> and <code>Bar</code> class show good, and bad usage of the extention.</p>\n<pre><code>Foo().check(); \u2192 Extention is valid: true\nBar().check(); \u2192 Extention is valid: false\n</code></pre>\n<p>I would like to check the validity of the template during compilation, which brought me to write</p>\n<pre><code>template&lt;typename Self&gt;\nclass Extention\n{\n    static_assert(std::is_base_of&lt;Extention, Self&gt;::value);\n};\n</code></pre>\n<p>However, gcc tels me this <code>static_assert</code> is wrong as <code>class Foo</code> has incomplete type.</p>\n<p>What am I doing wrong ?</p>\n<p>Edit: I'm using <code>-std=c++17</code>, error is not the lack of error message in the <code>static_assert</code></p>\n", "Tags": "<c++><templates><inheritance><static-assert>", "OwnerUserId": "1503898", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45653336_45655346_2": {"section_id": 5862, "quality": 1.0, "length": 8}, "so_45653336_45655346_1": {"section_id": 4706, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_45653336_45655346_2": {"section_id": 5632, "quality": 1.0, "length": 8}, "so_45653336_45655346_1": {"section_id": 4515, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_45653336_45655346_2": {"section_id": 7345, "quality": 1.0, "length": 8}, "so_45653336_45655346_1": {"section_id": 6114, "quality": 1.0, "length": 13}}}, "45655346": {"ParentId": "45653336", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_45653336_45655346_0\">What am I doing wrong ?</p>\n</blockquote>\n<p>Because of <a href=\"http://eel.is/c++draft/meta.rel\" rel=\"nofollow noreferrer\">[meta.rel]</a>, <code>std::is_base_of</code> requires that the derived type is a complete type:</p>\n<blockquote>\n<p id=\"so_45653336_45655346_1\">If\u00a0<code>Base</code> and\u00a0<code>Derived</code> are non-union class types and are not possibly cv-qualified versions of the same type, <code>Derived</code>\u00a0shall be a complete type.</p>\n</blockquote>\n<p>On the other side, <a href=\"http://eel.is/c++draft/class#mem-6\" rel=\"nofollow noreferrer\">[class.mem/6]</a> states that:</p>\n<blockquote>\n<p id=\"so_45653336_45655346_2\">A class is considered a completely-defined object type (or complete type) at the closing\u00a0<code>}</code>\u00a0of the\u00a0class-specifier. [...]</p>\n</blockquote>\n<p>That isn't your case. When you instantiate <code>Extension&lt;Foo&gt;</code>, <code>Foo</code> itself is far from being completely-defined.</p>\n<p>In other terms, you cannot use that <code>static_assert</code> at the class scope. Put it in the destructor's body (my preferred solution actually, even though it has a few drawbacks) or any other (special) member method's body if you prefer.</p>\n", "OwnerUserId": "4987285", "PostTypeId": "2", "Id": "45655346", "Score": "1", "CreationDate": "2017-08-12T22:09:15.213", "LastActivityDate": "2017-08-12T22:09:15.213"}});