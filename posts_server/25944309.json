post_cb({"25945302": {"ParentId": "25944309", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think the best summary of what the standard (now) intends by <code>volatile</code> is to be found in n3797 S7.1.6.1 /6/7</p>\n<blockquote>\n<p id=\"so_25944309_25945302_0\">What constitutes an access to an object that has volatile-qualified type is implementation-defined. If an attempt is made to refer to an object defined with a volatile-qualified type through the use of a glvalue with a non-volatile-qualified type, the program behavior is undefined.</p>\n<p id=\"so_25944309_25945302_1\">[ Note: volatile is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might be changed by means undetectable by an implementation. Furthermore, for some implementations, volatile might indicate that special hardware instructions are required to access the object. See 1.9 for detailed semantics. In general, the semantics of volatile are intended to be the same in C++ as they are in C. \u2014end note ]</p>\n</blockquote>\n<p>Sadly, this means that a standards-complying implementation is not required to do as much as that article seems to suggest. There is no obligation to store values promptly and a limited obligation to reload values that <em>might</em> have changed. The compiler is not free to elide code that loads a value that it has not stored, but it is free to elide code that stores a value that it never uses.</p>\n<p>As noted in the comments, it's better to use implementation-defined APIs or <code>atomic</code> or a <code>mutex</code>. Volatile will let you down. Stroustrup says as much in the linked <a href=\"https://stackoverflow.com/questions/4557979/when-to-use-volatile-with-multi-threading\">question</a>.</p>\n", "OwnerUserId": "1105562", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:57:17.107", "Id": "25945302", "Score": "1", "CreationDate": "2014-09-20T04:39:15.063", "LastActivityDate": "2014-09-20T04:39:15.063"}, "bq_ids": {"n4140": {"so_25944309_25945302_1": {"section_id": 5436, "quality": 0.925, "length": 37}, "so_25944309_25945302_0": {"section_id": 5435, "quality": 1.0, "length": 21}}, "n3337": {"so_25944309_25945302_1": {"section_id": 5231, "quality": 0.625, "length": 25}, "so_25944309_25945302_0": {"section_id": 5230, "quality": 0.6666666666666666, "length": 14}}, "n4659": {"so_25944309_25945302_1": {"section_id": 6863, "quality": 0.925, "length": 37}, "so_25944309_25945302_0": {"section_id": 6862, "quality": 0.5714285714285714, "length": 12}}}, "25944309": {"CommentCount": "3", "ViewCount": "197", "CreationDate": "2014-09-20T01:21:31.340", "LastActivityDate": "2014-09-20T04:39:15.063", "Title": "volatile-Correctness on Win32/pthreads Threading Functions", "PostTypeId": "1", "Id": "25944309", "Score": "1", "Body": "<p>After having read <a href=\"http://www.drdobbs.com/cpp/volatile-the-multithreaded-programmers-b/184403766\" rel=\"nofollow\">this wonderful article</a>, I starting digging around to volatile-correct some code.  One consequence of volatile-correctness (as I understand it) is that methods accessed from different threads should be volatile qualified.</p>\n<p>A simple example might be a mutex using Win32 or pthreads.  We could make a class <code>Mutex</code> and give it a field:</p>\n<pre><code>#if   defined BACKEND_WIN32\n    CRITICAL_SECTION _lock;\n#elif defined BACKEND_POSIX\n    pthread_mutex_t _lock;\n#endif\n</code></pre>\n<p>The \".acquire()\" method might look like:</p>\n<pre><code>void Mutex::acquire(void) volatile {\n    #if   defined BACKEND_WIN32\n        EnterCriticalSection(&amp;_lock);\n    #elif defined BACKEND_POSIX\n        pthread_mutex_lock(&amp;_lock);\n    #endif\n}\n</code></pre>\n<p>Trying this doesn't work.  From MSVC:</p>\n<blockquote>\n<p id=\"so_25944309_25944309_0\">error C2664: 'void EnterCriticalSection(LPCRITICAL_SECTION)' : cannot convert argument 1 from 'volatile CRITICAL_SECTION *' to 'LPCRITICAL_SECTION'</p>\n</blockquote>\n<p>From g++:</p>\n<blockquote>\n<p id=\"so_25944309_25944309_1\">error: invalid conversion from \u2018volatile pthread_mutex_t*\u2019 to \u2018pthread_mutex_t*\u2019 [-fpermissive]</p>\n</blockquote>\n<p>You'll get similar problems trying to unlock <code>_lock</code>.  Two questions:</p>\n<ul>\n<li>My impression is that these are just artifacts of the APIs being outdated.  Is this in fact the case?  Did I misunderstand something?</li>\n<li>The whole <em>purpose</em> of a lock or unlock API function is to switch between being in a critical section, therefore, is it the case that I should just use the inadequately named <code>const_cast</code> to cast away the <code>volatile</code>-ness of <code>_lock</code> before passing to these functions, with no ill effect?</li>\n</ul>\n", "Tags": "<c++><multithreading><winapi><pthreads><mutex>", "OwnerUserId": "688624", "AnswerCount": "1"}});