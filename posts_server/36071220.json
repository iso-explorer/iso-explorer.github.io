post_cb({"bq_ids": {"n4140": {"so_36071220_36071266_0": {"length": 26, "quality": 0.8387096774193549, "section_id": 4279}, "so_36071220_36071498_0": {"length": 4, "quality": 1.0, "section_id": 4309}}, "n3337": {"so_36071220_36071266_0": {"length": 26, "quality": 0.8387096774193549, "section_id": 4120}, "so_36071220_36071498_0": {"length": 4, "quality": 1.0, "section_id": 4150}}, "n4659": {"so_36071220_36071266_0": {"length": 26, "quality": 0.8387096774193549, "section_id": 5535}, "so_36071220_36071498_0": {"length": 4, "quality": 1.0, "section_id": 5569}}}, "36071266": {"Id": "36071266", "PostTypeId": "2", "Body": "<p>No, you cannot do that instead. Moving the <code>unique_ptr</code> nulls it. If it didn't, then it would not be unique. I am of course assuming that <code>attachActor</code> doesn't do something silly like this:</p>\n<pre><code>attachActor(std::unique_ptr&lt;Tony&gt;&amp;&amp;) {\n    // take the unique_ptr by r-value reference,\n    // and then don't move from it, leaving the\n    // original intact\n}\n</code></pre>\n<p>Section 20.8.1 paragraph 4.</p>\n<blockquote>\n<p id=\"so_36071220_36071266_0\">Additionally, u (the unique_ptr object) can, upon request, transfer\n  ownership to another unique pointer u2. Upon completion of such a\n  transfer, the following postconditions hold:<br>\n  \u00a0\u00a0\u00a0-- u2.p is equal to the pre-transfer u.p,<br>\n  \u00a0\u00a0\u00a0-- <strong>u.p is equal to nullptr</strong>, and<br>\n  \u00a0\u00a0\u00a0-- if the pre-transfer u.d maintained state, such state has been transferred to u2.d.  </br></br></br></p>\n</blockquote>\n", "LastEditorUserId": "440119", "LastActivityDate": "2016-03-17T21:12:15.573", "Score": "13", "CreationDate": "2016-03-17T20:40:21.510", "ParentId": "36071220", "CommentCount": "4", "LastEditDate": "2016-03-17T21:12:15.573", "OwnerUserId": "440119"}, "36071220": {"ViewCount": "5146", "Body": "<p>This code is what I want to do: </p>\n<pre><code>Tony&amp; Movie::addTony()\n{\n    Tony *newTony = new Tony;\n    std::unique_ptr&lt;Tony&gt; tony(newTony);\n    attachActor(std::move(tony));\n    return *newTony;\n}\n</code></pre>\n<p>I am wondering if I could do this instead:</p>\n<pre><code>Tony&amp; Movie::addTony()\n{\n    std::unique_ptr&lt;Tony&gt; tony(new Tony);\n    attachActor(std::move(tony));\n    return *tony.get();\n}\n</code></pre>\n<p>But will <code>*tony.get()</code> be the same pointer or null? I know I could verify, but what is the standard thing for it to do?</p>\n", "AcceptedAnswerId": "36071266", "Title": "What happens to unique_ptr after std::move()?", "CreationDate": "2016-03-17T20:37:22.843", "Id": "36071220", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-03-17T21:12:15.573", "Score": "8", "OwnerUserId": "3496846", "Tags": "<c++><unique-ptr>", "AnswerCount": "2"}, "36071498": {"Id": "36071498", "PostTypeId": "2", "Body": "<p>The standard says (\u00a7\u00a020.8.1.2.1 \u00b6\u00a016, emphasis added) that the move constructor of <code>std::unique_ptr</code></p>\n<blockquote>\n<pre><code>unique_ptr(unique_ptr&amp;&amp; u) noexcept;\n</code></pre>\n<p id=\"so_36071220_36071498_0\">Constructs a <code>unique_ptr</code> by <strong>transferring ownership</strong> from <code>u</code> to <code>*this</code>.</p>\n</blockquote>\n<p>Therefore, after you move-construct the temporary object that gets passed as argument to <code>attachActor</code> form your <code>tony</code>, <code>tony</code> no longer owns the object and hence <code>tony.get() == nullptr</code>. (This is one of the few cases where the standard library actually makes assertions about the state of a moved-away-from object.)</p>\n<p>However, the desire to return the reference can be fulfilled without resorting to naked <code>new</code> and raw pointers.</p>\n<pre><code>Tony&amp;\nMovie::addTony()\n{\n  auto tony = std::make_unique&lt;Tony&gt;();\n  auto p = tony.get();\n  attachActor(std::move(tony));\n  return *p;\n}\n</code></pre>\n<p>This code assumes that <code>attachActor</code> will not drop its argument on the floor. Otherwise, the pointer <code>p</code> would dangle after <code>attachActor</code> has <code>return</code>ed. If this cannot be relied upon, you'll have to re-design your interface and use shared pointers instead.</p>\n<pre><code>std::shared_ptr&lt;Tony&gt;\nMovie::addTony()\n{\n  auto tony = std::make_shared&lt;Tony&gt;();\n  attachActor(tony);\n  return tony;\n}\n</code></pre>\n", "LastActivityDate": "2016-03-17T20:54:22.353", "Score": "5", "CreationDate": "2016-03-17T20:54:22.353", "ParentId": "36071220", "CommentCount": "1", "OwnerUserId": "1392132"}});