post_cb({"bq_ids": {"n4140": {"so_38146184_38146416_0": {"section_id": 121, "quality": 0.8421052631578947, "length": 16}, "so_38146184_38146424_0": {"section_id": 4108, "quality": 0.5714285714285714, "length": 4}, "so_38146184_38146424_1": {"section_id": 124, "quality": 0.7647058823529411, "length": 13}, "so_38146184_38146424_2": {"section_id": 124, "quality": 1.0, "length": 33}}, "n3337": {"so_38146184_38146416_0": {"section_id": 116, "quality": 0.8421052631578947, "length": 16}, "so_38146184_38146424_1": {"section_id": 118, "quality": 0.7647058823529411, "length": 13}, "so_38146184_38146424_2": {"section_id": 118, "quality": 1.0, "length": 33}}, "n4659": {"so_38146184_38146424_2": {"section_id": 128, "quality": 1.0, "length": 33}, "so_38146184_38146424_0": {"section_id": 4868, "quality": 0.5714285714285714, "length": 4}, "so_38146184_38146424_1": {"section_id": 128, "quality": 0.9411764705882353, "length": 16}, "so_38146184_38146416_0": {"section_id": 125, "quality": 0.8421052631578947, "length": 16}}}, "38146184": {"CommentCount": "0", "ViewCount": "50", "PostTypeId": "1", "LastEditorUserId": "6022656", "CreationDate": "2016-07-01T13:04:19.773", "LastActivityDate": "2016-07-01T13:22:30.033", "Title": "Can I rely on empty parameter packs to be expanded properly?", "AcceptedAnswerId": "38146424", "LastEditDate": "2016-07-01T13:22:30.033", "Id": "38146184", "Score": "1", "Body": "<p>The following code defines function <code>subst_first</code>, which substitutes the first elements of an array of ints by the contents of another array. It works under gcc and clang (<a href=\"http://coliru.stacked-crooked.com/a/64a860ea9ccd6ed4\" rel=\"nofollow\">live demo</a>). For cases <code>//1</code>, <code>//2</code> and <code>//3</code> one of the generated <a href=\"http://en.cppreference.com/w/cpp/utility/integer_sequence\" rel=\"nofollow\"><code>index_sequence</code>'s</a> is empty. Consequently one of the parameter packs at <code>//4</code> has zero elements. This makes me feel uneasy. Can I rely on this behavior to be standard conforming? </p>\n<pre><code>template&lt;size_t n, size_t ... S1, size_t ... S2&gt;\nconstexpr\nstd::array&lt;int,3&gt;\nsubst_first_impl( std::array&lt;int,n&gt; const &amp;v1,\n                  std::array&lt;int,3&gt; const &amp;v2,\n                  size_t min_n,\n                  std::index_sequence&lt;S1...&gt;,\n                  std::index_sequence&lt;S2...&gt; )\n{    return std::array&lt;int,3&gt;{{ v1[S1]..., v2[min_n+S2]... }}; } // 4\n\ntemplate&lt;size_t n&gt;\nconstexpr\nstd::array&lt;int,3&gt;\nsubst_first( std::array&lt;int,n&gt; const &amp;v1,\n             std::array&lt;int,3&gt; const &amp;v2 )\n{   auto const min_n= std::min( size_t(3), n );\n    return subst_first_impl( v1, v2, min_n,\n                             std::make_index_sequence&lt; min_n &gt;(),\n                             std::make_index_sequence&lt; size_t(3) - min_n &gt;() );\n}\n\nint main(){\n    constexpr std::array&lt;int,3&gt;  a1{{1,2,3}};\n\n    constexpr std::array&lt;int,2&gt;  b1{{4,5}};\n    constexpr std::array&lt;int,3&gt;  b2{{6,7,8}};\n    constexpr std::array&lt;int,4&gt;  b3{{9,10,11,12}};\n    constexpr std::array&lt;int,0&gt;  b4{};\n\n    constexpr auto b1a1= subst_first( b1, a1 );\n    // ==&gt; 4, 5, 3\n\n    constexpr auto b2a1= subst_first( b2, a1 ); // 1\n    // ==&gt; 6, 7, 8\n\n    constexpr auto b3a1= subst_first( b3, a1 ); // 2\n    // ==&gt; 9, 10, 11\n\n    constexpr auto b4a1= subst_first( b4, a1 ); // 3\n    // ==&gt; 1, 2, 3\n}\n</code></pre>\n<p><strong>Note:</strong> I am not looking for a solution for substituting elements of arrays. I am interested in the behavior of <code>index_sequence</code>'s and parameter packs.</p>\n", "Tags": "<c++><c++14><variadic-templates>", "OwnerUserId": "3876684", "AnswerCount": "2"}, "38146416": {"ParentId": "38146184", "CommentCount": "0", "Body": "<p>Yes, absolutely. Quoting the standard [temp.variadic]:</p>\n<blockquote id=\"so_38146184_38146416_0\">\n<ol start=\"4\">\n<li>A pack expansion consists of a pattern and an ellipsis, the\n  instantiation of which produces <strong>zero or more</strong> instantiations of the\n  pattern in a list. The form of the pattern depends on the context in\n  which the expansion occurs.</li>\n</ol>\n</blockquote>\n<p>So the standard accommodates the expansion of packs whose size is zero.</p>\n", "OwnerUserId": "6255513", "PostTypeId": "2", "Id": "38146416", "Score": "2", "CreationDate": "2016-07-01T13:14:47.143", "LastActivityDate": "2016-07-01T13:14:47.143"}, "38146424": {"ParentId": "38146184", "CommentCount": "0", "Body": "<p>First, <code>std::make_index_sequence&lt;0&gt;</code> is perfectly valid (\u00a720.5.3 [intseq.make]):</p>\n<blockquote>\n<p id=\"so_38146184_38146424_0\"><em>[ Note: make_integer_-sequence&lt;int, 0&gt; denotes the type integer_sequence&lt;int&gt; \u2014end note ]</em></p>\n</blockquote>\n<p>So in your case, you get a <code>std::index_sequence&lt;size_t&gt;</code>. </p>\n<p>And per \u00a714.5.3/7 [temp.variadic], the instantiation of a pack expansion of length 0 is perfectly valid:</p>\n<blockquote>\n<p id=\"so_38146184_38146424_1\">The instantiation of a pack expansion that is neither a <code>sizeof...</code> expression nor a fold-expression produces a list E1, E2, ..., EN, where N is the number of elements in the pack expansion parameters. [...] </p>\n<p id=\"so_38146184_38146424_2\">All of the E<sub>i</sub> become elements in the enclosing list. [...] When <strong>N is zero</strong>, the instantiation of the expansion <strong>produces an empty list</strong>. Such an instantiation does not alter the syntactic interpretation of the enclosing construct, even in cases where omitting the list entirely would otherwise be ill-formed or would result in an ambiguity in the grammar.</p>\n</blockquote>\n", "OwnerUserId": "2666289", "PostTypeId": "2", "Id": "38146424", "Score": "2", "CreationDate": "2016-07-01T13:15:06.277", "LastActivityDate": "2016-07-01T13:15:06.277"}});