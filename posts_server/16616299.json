post_cb({"16616334": {"ParentId": "16616299", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Both languages guarantee that signed and unsigned variants of a corresponding standard integer type have the same size.</p>\n<p>C++, committee draft n3337, 3.9.1/3:</p>\n<blockquote>\n<p id=\"so_16616299_16616334_0\">3 For each of the standard signed integer types, there exists a corresponding (but different) standard un-\n  signed integer type: \u201cunsigned char\u201d, \u201cunsigned short int\u201d, \u201cunsigned int\u201d, \u201cunsigned long int\u201d,\n  and \u201cunsigned long long int\u201d, <strong>each of which occupies the same amount of storage</strong> and has the same\n  alignment requirements (3.11) as the corresponding signed integer type45; that is, each signed integer type\n  has the same object representation as its corresponding unsigned integer type. [...]</p>\n</blockquote>\n<p>For C, the wording is very similar</p>\n<p>Taken from draft n1570, 6.2.5/6:</p>\n<blockquote>\n<p id=\"so_16616299_16616334_1\">For each of the signed integer types, there is a corresponding (but different) unsigned\n  integer type (designated with the keyword unsigned) <strong>that uses the same amount of\n  storage (including sign information) and has the same alignment requirements.</strong> The type\n  _Bool and the unsigned integer types that correspond to the standard signed integer\n  types are the standard unsigned integer types. The unsigned integer types that\n  correspond to the extended signed integer types are the extended unsigned integer types.\n  The standard and extended unsigned integer types are collectively called unsigned integer\n  types.</p>\n</blockquote>\n", "OwnerUserId": "947836", "LastEditorUserId": "947836", "LastEditDate": "2013-05-17T20:01:50.280", "Id": "16616334", "Score": "14", "CreationDate": "2013-05-17T19:15:02.553", "LastActivityDate": "2013-05-17T20:01:50.280"}, "16616344": {"ParentId": "16616299", "CommentCount": "7", "Body": "<p>You could always put in some code like this</p>\n<pre><code>{\nchar s1[1 + sizeof(int) - sizeof(unsigned int)];\nchar s2[1 + sizeof(unsigned int) - sizeof(int)];\n}\n</code></pre>\n<p>(probably only in debug builds)</p>\n<p>This will give you a compile time failure if they were ever different sizes.</p>\n<p>I do this occasionally for highly (typedef)ed code I'm refactoring.</p>\n<p>But unsigned and signed varieties are always the same size.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "16616344", "Score": "0", "CreationDate": "2013-05-17T19:15:31.930", "LastActivityDate": "2013-05-17T19:15:31.930"}, "16616328": {"ParentId": "16616299", "CommentCount": "0", "Body": "<p>It's not really obsolete, more like redundant. The standard does guarantee signed and unsigned variations of a type to have the same size.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "16616328", "Score": "2", "CreationDate": "2013-05-17T19:14:11.943", "LastActivityDate": "2013-05-17T19:14:11.943"}, "bq_ids": {"n4140": {"so_16616299_16616334_0": {"section_id": 7212, "quality": 0.9230769230769231, "length": 48}, "so_16616299_16616334_1": {"section_id": 7212, "quality": 0.7213114754098361, "length": 44}}, "n3337": {"so_16616299_16616334_0": {"section_id": 6956, "quality": 0.9230769230769231, "length": 48}, "so_16616299_16616334_1": {"section_id": 6956, "quality": 0.7049180327868853, "length": 43}}, "n4659": {"so_16616299_16616334_0": {"section_id": 8721, "quality": 0.9230769230769231, "length": 48}, "so_16616299_16616334_1": {"section_id": 8721, "quality": 0.7377049180327869, "length": 45}}}, "16616299": {"CommentCount": "3", "AcceptedAnswerId": "16616334", "PostTypeId": "1", "LastEditorUserId": "103167", "CreationDate": "2013-05-17T19:11:32.677", "LastActivityDate": "2013-05-17T20:01:50.280", "LastEditDate": "2013-05-17T19:17:23.623", "ViewCount": "243", "FavoriteCount": "0", "Title": "Does the unsigned keyword affect the result of sizeof?", "Id": "16616299", "Score": "7", "Body": "<p>Do C and C++ guarantee that the unsigned equivalent of a type has the same size?</p>\n<p>Example:</p>\n<pre><code>size_t size = sizeof(unsigned int);\n</code></pre>\n<p>Is the <code>unsigned</code> completely moot here?</p>\n", "Tags": "<c++><c><sizeof><unsigned>", "OwnerUserId": "2040925", "AnswerCount": "3"}});