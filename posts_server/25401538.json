post_cb({"25401538": {"CommentCount": "8", "ViewCount": "261", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-08-20T09:43:41.083", "LastActivityDate": "2014-08-20T11:23:07.423", "Title": "Is it safe to change a function pointers signature and call it to ignore the return type?", "AcceptedAnswerId": "25402274", "LastEditDate": "2017-05-23T10:33:24.390", "Id": "25401538", "Score": "3", "Body": "<p>In our codebase we have callbacks that are stored using (eg. <code>std::function&lt;void()&gt;</code>). Sometimes we would like to bind a function with a different signature to the callback which can be done using bind. This is fine for different function parameters but trying to bind a function that returns something to a callback that is expecting a void return doesn't work, see <a href=\"https://stackoverflow.com/questions/25385876/should-stdfunction-assignment-ignore-return-type/25392559#25392559\">here</a>.</p>\n<p>The simplest solution we have found is to cast the bound function's signature to a function with the same parameters but a void return type:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nint ReturnInt()\n{\n  std::cout &lt;&lt; \"ReturnInt\" &lt;&lt; std::endl;\n  return 5;\n}\n\nstruct Struct\n{\n  int ReturnInt()\n  {\n    std::cout &lt;&lt; \"Test::Func\" &lt;&lt; std::endl;\n    return 30;\n  }\n};\n\ntemplate&lt;typename ReturnType, typename ... ArgumentTypes&gt;\nauto IgnoreResult(ReturnType (*i_Func)(ArgumentTypes ...))\n  -&gt; void (*)(ArgumentTypes ...)\n{\n  return reinterpret_cast&lt;void (*)(ArgumentTypes ...)&gt;(i_Func);\n}\n\ntemplate&lt;typename ReturnType, typename ClassType, typename ... ArgumentTypes&gt;\nauto IgnoreResult(ReturnType (ClassType::*i_Func)(ArgumentTypes ...))\n  -&gt; void (ClassType::*)(ArgumentTypes ...)\n{\n  return reinterpret_cast&lt;void (ClassType::*)(ArgumentTypes ...)&gt;(i_Func);\n}\n\n\nint main(int argc, char **argv)\n{\n  std::function&lt;void ()&gt; BoundType;\n\n  Struct instance;\n  BoundType = std::bind(IgnoreResult(&amp;Struct::ReturnInt), &amp;instance);\n  BoundType();\n\n  BoundType = std::bind(IgnoreResult(&amp;ReturnInt));\n  BoundType();\n\n  return 0;\n}\n</code></pre>\n<p>This has been tested with <strong>Visual Studio 2013 November CTP</strong>, <strong>cygwin clang 3.4.2</strong> and <strong>cygwin gcc 4.8.3</strong> and works on all platforms but calling a function pointer that has been cast to a different function signature is undefined behaviour.</p>\n<p>I know that certain calling conventions could break it but as far as I could tell from the <a href=\"http://msdn.microsoft.com/en-gb/library/984x0h58.aspx\" rel=\"nofollow noreferrer\"><strong>Microsoft</strong> calling conventions</a> the return type is passed via a register not via the stack. We are also never specifying different calling conventions and always use the defaults.</p>\n<p>Assuming that the <strong>gcc</strong>, <strong>clang</strong> and <strong>Microsoft</strong> compilers don't change their behaviour, is this a safe method to use to ignore the return type of a function when binding a callback?</p>\n", "Tags": "<c++><std-function><stdbind>", "OwnerUserId": "1985643", "AnswerCount": "3"}, "25402274": {"ParentId": "25401538", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_25401538_25402274_0\">Is it safe to change a function pointers signature and call it to ignore the return type?</p>\n</blockquote>\n<p>No, it is not, c.f. the C++ standard, section \u00a7 5.2.10 [expr.reinterpret.cast]</p>\n<blockquote>\n<p id=\"so_25401538_25402274_1\">The effect of calling a function through a pointer to a function type (8.3.5) that is not the same as the type used in the definition of the function is undefined.</p>\n</blockquote>\n<p>Even if it does <em>appear</em> to work on a particular compiler/platform, nothing guarantees you that it <em>really</em> does (hidden side effects, stack corruption...).</p>\n<p>You should consider a new design where this cast is not needed in the first place (hard to answer without more context)</p>\n", "OwnerUserId": "3510483", "PostTypeId": "2", "Id": "25402274", "Score": "4", "CreationDate": "2014-08-20T10:20:33.047", "LastActivityDate": "2014-08-20T10:20:33.047"}, "bq_ids": {"n4140": {"so_25401538_25402274_1": {"section_id": 6045, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_25401538_25402274_1": {"section_id": 5813, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_25401538_25402274_1": {"section_id": 7544, "quality": 0.8571428571428571, "length": 12}}}, "25401808": {"ParentId": "25401538", "CommentCount": "0", "Body": "<p>You can use lambdas:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nint ReturnInt()\n{\n  std::cout &lt;&lt; \"ReturnInt\" &lt;&lt; std::endl;\n  return 5;\n}\n\nstruct Struct\n{\n  int ReturnInt()\n  {\n    std::cout &lt;&lt; \"Test::Func\" &lt;&lt; std::endl;\n    return 30;\n  }\n};\n\nint main(int argc, char **argv)\n{\n  std::function&lt;void ()&gt; BoundType;\n\n  Struct instance;\n  BoundType = [&amp;instance] { instance.ReturnInt(); };\n  BoundType();\n\n  BoundType = [] { ReturnInt(); };\n  BoundType();\n\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "1147772", "PostTypeId": "2", "Id": "25401808", "Score": "4", "CreationDate": "2014-08-20T09:56:26.000", "LastActivityDate": "2014-08-20T09:56:26.000"}, "25403444": {"ParentId": "25401538", "CommentCount": "0", "Body": "<p>You might solve your problem using an approach similar to that <a href=\"http://libsigc.sourceforge.net/libsigc2/docs/reference/html/group__hide.html#gd7e18e1edbbefe13216eb344bd522f0a\" rel=\"nofollow\">employed in libsigc++2</a> (via sigc::hide_return()). </p>\n", "OwnerUserId": "2935339", "PostTypeId": "2", "Id": "25403444", "Score": "3", "CreationDate": "2014-08-20T11:23:07.423", "LastActivityDate": "2014-08-20T11:23:07.423"}});