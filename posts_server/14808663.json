post_cb({"bq_ids": {"n4140": {"so_14808663_14836911_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 300}, "so_14808663_14809603_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 4760}, "so_14808663_14836911_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 300}}, "n3337": {"so_14808663_14836911_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 291}, "so_14808663_14809603_0": {"length": 7, "quality": 0.7, "section_id": 1050}, "so_14808663_14836911_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 291}, "so_14808663_14809603_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 1050}}, "n4659": {"so_14808663_14836911_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 307}, "so_14808663_14809603_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 5581}, "so_14808663_14836911_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 307}}}, "14808663": {"ViewCount": "1434", "Body": "<p>The following code compiles fine with gcc 4.7.2 (mingw)</p>\n<pre><code>#include &lt;unordered_map&gt;\n#include &lt;tuple&gt;\n\nstruct test\n{\n        test() =default;\n    private:\n        test(test const&amp;) =delete;\n};\n\nint main()\n{\n    std::unordered_map&lt;char, test&gt; map;\n\n    map.emplace(\n        std::piecewise_construct,\n        std::forward_as_tuple('a'),\n        std::forward_as_tuple()\n    );\n}\n</code></pre>\n<p>If I change the copy constructor in <code>test</code> from <code>test(test const&amp;) =delete;</code> to <code>test(test const&amp;) =default;</code> however, the template error vomit seems to complain about <code>const test&amp;</code> not being convertible to <code>test</code> (text <a href=\"http://pastebin.com/iGTUHvZN\" rel=\"noreferrer\" title=\"here\">here</a>). Shouldn't either work? Or if not, shouldn't they both give an error?</p>\n", "AcceptedAnswerId": "14836911", "Title": "std::unordered_map::emplace issue with private/deleted copy constructor", "CreationDate": "2013-02-11T08:51:17.423", "Id": "14808663", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-02-11T10:09:42.353", "LastEditorUserId": "777186", "LastActivityDate": "2013-02-13T00:57:04.970", "Score": "10", "OwnerUserId": "657267", "Tags": "<c++><gcc><c++11><mingw><unordered-map>", "AnswerCount": "2"}, "14836911": {"Id": "14836911", "PostTypeId": "2", "Body": "<p>If you look at the template error vomit more carefully you'll see this chunk of carrot in it:</p>\n<pre><code>test.exe.cpp:8:3: error: 'constexpr test::test(const test&amp;)' is private\n</code></pre>\n<p>This is the clue to the problem.</p>\n<p>GCC 4.7.2 doesn't do access checking as part of template argument deduction (as was required by C++03.)  The <code>is_convertible</code> trait is implemented using SFINAE, which relies on template argument deduction, and if overload resolution chooses a private constructor argument deduction succeeds, but then access checking fails because the chosen constructor is private.  This is a problem with GCC 4.7 because it hadn't been changed to follow the new C++11 rule in 14.8.2 [temp.deduct] which says:</p>\n<blockquote>\n<p id=\"so_14808663_14836911_0\">-8- If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed if written using the substituted arguments. <em>[ Note:</em> Access checking is done as part of the substitution process. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>This is a huge change to the previous deduction rules, previously that paragraph said</p>\n<blockquote>\n<p id=\"so_14808663_14836911_1\">-8- If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed if written using the substituted arguments. Access checking is not done as part of the substitution process. Consequently, when deduction succeeds, an access error could still result when the function is instantiated.</p>\n</blockquote>\n<p>The change was made quite late in the C++0x process by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170\">DR 1170</a>, and makes SFINAE totally awesome in C++11 :)</p>\n<p>GCC 4.8 implements the new rules, so <code>is_convertible</code> and similar traits give the right answer for inaccessible constructors.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-02-12T16:29:21.293", "Score": "11", "CreationDate": "2013-02-12T16:18:33.637", "ParentId": "14808663", "CommentCount": "0", "OwnerUserId": "981959", "LastEditDate": "2013-02-12T16:29:21.293"}, "14809603": {"Id": "14809603", "PostTypeId": "2", "Body": "<p>The correct answer is Jonathan Wakeley's. I'll leave this as it provides useful information for people who have a similar problem related to <code>insert</code>.</p>\n<hr>\n<p>The short version is that this is caused by a problem in the Standard Library implementation used by GCC 4.7.2, which resulted from a misleading wording used in the C++11 Standard. There is a change proposal for the wording, as well as a fix of the implementation in GCC 4.8.</p>\n<hr>\n<p><strong>Long version</strong></p>\n<p><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=50641\" rel=\"nofollow\">This GCC bug entry</a> reports a very similar issue, where <code>insert</code> is used instead of <code>emplace</code>. The libstdc++ implementation of <code>insert</code> follows the Standard, which states about the <code>insert</code> function (specifically, <code>template &lt;class P&gt; pair&lt;iterator,bool&gt; insert(P&amp;&amp; obj)</code>):</p>\n<blockquote>\n<p id=\"so_14808663_14809603_0\">(\u00a723.5.4.4/5) Remarks: This signature shall not participate in overload resolution unless P is implicitly convertible to <code>value_type</code>.</p>\n</blockquote>\n<p>libstdc++ seems to have implemented this requirement using an <code>enable_if</code> statement that checks <code>std::is_convertible&lt;&gt;</code> for the types involved.</p>\n<p>The bug report linked above later states that really <code>std::is_constructible&lt;&gt;</code> should have been used, and the wording in the Standard should be changed. It links to an LWG (language working group) issue, which proposes a change to the Standard for this already (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2005\" rel=\"nofollow\">LWG issue #2005</a>, see the <em>Portland 2012</em> entry, relevant portion of the proposed change below):</p>\n<blockquote>\n<ol>\n<li><p id=\"so_14808663_14809603_1\">Change 23.5.4.4 [unord.map.modifers] around p. 1 as indicated:</p>\n<pre><code>template &lt;class P&gt;\npair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);\n</code></pre></li>\n</ol>\n<p id=\"so_14808663_14809603_2\">[...]\n  Remarks: This signature shall not participate in overload resolution unless P is <strike>implicitly convertible to value_type</strike><code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is true.</p>\n</blockquote>\n<p>The proposed change also states that the effect of the <code>insert</code> function described above should be equivalent to that of <code>emplace(std::forward&lt;P&gt;(obj))</code>. It is therefore probably safe to say that the issue described in your question is exactly the same problem.</p>\n<p>And indeed, the proposed changes seem to be reflected in recent <strong>GCC 4.8 snapshots:</strong> When you compile your code with GCC 4.8, the <code>is_convertible</code> check isn't performed and <strong>no error message appears.</strong></p>\n</hr></hr>", "LastEditorUserId": "777186", "LastActivityDate": "2013-02-13T00:57:04.970", "Score": "4", "CreationDate": "2013-02-11T09:50:22.337", "ParentId": "14808663", "CommentCount": "2", "OwnerUserId": "777186", "LastEditDate": "2013-02-13T00:57:04.970"}});