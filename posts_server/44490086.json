post_cb({"bq_ids": {"n4140": {"so_44490086_44490176_0": {"section_id": 291, "quality": 0.9305555555555556, "length": 67}}, "n3337": {"so_44490086_44490176_0": {"section_id": 282, "quality": 0.9305555555555556, "length": 67}}, "n4659": {"so_44490086_44490176_0": {"section_id": 298, "quality": 0.9305555555555556, "length": 67}}}, "44490176": {"ParentId": "44490086", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2017-06-12T01:17:31.527", "Score": "8", "LastEditorUserId": "3309790", "LastEditDate": "2017-06-12T21:53:42.313", "Id": "44490176", "OwnerUserId": "3309790", "Body": "<p>Because a function call to a function template with explicitly-specified template arguments requires the name of the template must be found by ordinary lookup; until that <a href=\"http://en.cppreference.com/w/cpp/language/adl#Notes\" rel=\"nofollow noreferrer\">ADL</a> can't kick in.</p>\n<p>From the standard: <a href=\"http://eel.is/c++draft/temp.arg.explicit#8\" rel=\"nofollow noreferrer\">$17.8.1/8 Explicit template argument specification [temp.arg.explicit]</a></p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_44490086_44490176_0\">[\u2009Note: For simple function names, argument dependent lookup applies\n  even when the function name is not visible within the scope of the\n  call. This is because the call still has the syntactic form of a\n  function call ([basic.lookup.unqual]). But when a function template\n  with explicit template arguments is used, <strong>the call does not have the\n  correct syntactic form unless there is a function template with that\n  name visible at the point of the call</strong>. If no such name is visible, the\n  call is not syntactically well-formed and argument-dependent lookup\n  does not apply. If some such name is visible, argument dependent\n  lookup applies and additional function templates may be found in other\n  namespaces. [\u2009Example:</p>\n<pre><code>namespace A {\n  struct B { };\n  template&lt;int X&gt; void f(B);\n}\nnamespace C {\n  template&lt;class T&gt; void f(T t);\n}\nvoid g(A::B b) {\n  f&lt;3&gt;(b);          // ill-formed: not a function call\n  A::f&lt;3&gt;(b);       // well-formed\n  C::f&lt;3&gt;(b);       // ill-formed; argument dependent lookup applies only to unqualified names\n  using C::f;\n  f&lt;3&gt;(b);          // well-formed because C\u200b::\u200bf is visible; then A\u200b::\u200bf is found by argument dependent lookup\n}\n</code></pre>\n<p id=\"so_44490086_44490176_1\">\u2014\u2009end example\u2009] \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>The last sentence gives a possible workaround; you can add the declaration of the function template anywhere to make the name visible for being called. e.g.</p>\n<pre><code>template&lt;typename&gt;\nvoid notfound();\n\nint main() {\n    N::C object;\n    std::cout\n        &lt;&lt; found(object) &lt;&lt; std::endl\n        &lt;&lt; notfound&lt;bool&gt;(object) &lt;&lt; std::endl\n        &lt;&lt; notfound&lt;bool, N::C&amp;&gt;(object) &lt;&lt; std::endl; // btw the 2nd template argument should be N::C&amp;\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/aDcOWYjV6DIA58cY\" rel=\"nofollow noreferrer\">LIVE</a></p>\n", "LastActivityDate": "2017-06-12T21:53:42.313"}, "44490086": {"CommentCount": "0", "ViewCount": "130", "PostTypeId": "1", "LastEditorUserId": "1116364", "CreationDate": "2017-06-12T01:02:43.067", "LastActivityDate": "2017-06-12T21:53:42.313", "Title": "ADL fails (or not done?) for function with additional (non deduced) template parameter", "AcceptedAnswerId": "44490176", "LastEditDate": "2017-06-12T01:08:06.003", "Id": "44490086", "Score": "9", "Body": "<pre><code>namespace N {\n    class C {};\n\n    template&lt;typename X&gt;\n    char const * found(X &amp;&amp; x) {\n        return \"found\";\n    }\n\n    template&lt;typename, typename X&gt;\n    char const * notfound(X &amp;&amp; x) {\n        return \"not found\";\n    }\n}\n</code></pre>\n<p>This defines a namespace <code>N</code> with a class <code>C</code> and two function templates. <code>found</code> has a single template parameter, which can be deduced from the function argument. <code>notfound</code> has an additional template parameter which cannot be deduced.</p>\n<p>Given following test code (<a href=\"http://ideone.com/rDVwtB\" rel=\"noreferrer\">on ideone</a>):</p>\n<pre><code>#include &lt;iostream&gt;\nint main() {\n    N::C object;\n    std::cout\n        &lt;&lt; found(object) &lt;&lt; std::endl\n        &lt;&lt; notfound&lt;bool&gt;(object) &lt;&lt; std::endl  // ERROR\n        &lt;&lt; notfound&lt;bool, N::C&gt;(object) &lt;&lt; std::endl; // ERROR\n}\n</code></pre>\n<p><strong>I assumed that <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"noreferrer\">argument dependent lookup</a> would find both <code>found</code> and <code>notfound</code> through the innermost enclosing namespace (which is <code>N</code>) of the argument type <code>N::C</code>.</strong></p>\n<p>However:</p>\n<pre class=\"lang-none prettyprint-override\"><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:21:6: error: \u2018notfound\u2019 was not declared in this scope\n   &lt;&lt; notfound&lt;bool&gt;(object) &lt;&lt; std::endl\n      ^~~~~~~~\nprog.cpp:21:6: note: suggested alternative:\nprog.cpp:12:15: note:   \u2018N::notfound\u2019\n  char const * notfound(X &amp;&amp; x) {\n               ^~~~~~~~\n</code></pre>\n<p>(same error for <code>notfound&lt;bool, N::C&gt;(object)</code> after commenting out the <code>notfound&lt;bool&gt;(object)</code> call)</p>\n<p><strong>Why is <code>notfound</code> not found through ADL?</strong></p>\n<hr>\n<p><em>Background:</em> I'm implementing a <code>get</code> function for some wrapper class, all in all relatively similar to <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/get\" rel=\"noreferrer\"><code>std::get(std::tuple)</code></a>. The wrapper class, being an implementation detail, lives in some namespace <code>lib::aspect::part::impl</code>. I don't want users of the library to specify <code>using lib::aspect::part::impl::get</code> for obvious reasons.</p>\n</hr>", "Tags": "<c++><c++11><templates><namespaces><argument-dependent-lookup>", "OwnerUserId": "1116364", "AnswerCount": "1"}});