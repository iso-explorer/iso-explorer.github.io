post_cb({"bq_ids": {"n4140": {"so_40572451_40573110_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 739}, "so_40572451_40573215_0": {"length": 14, "quality": 1.0, "section_id": 738}}, "n3337": {"so_40572451_40573110_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 728}, "so_40572451_40573215_0": {"length": 14, "quality": 1.0, "section_id": 727}}, "n4659": {"so_40572451_40573110_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 797}, "so_40572451_40573215_0": {"length": 14, "quality": 1.0, "section_id": 796}}}, "40573215": {"Id": "40573215", "PostTypeId": "2", "Body": "<p>Your <code>ls</code> template argument is wrong. <code>std::map</code> requires comparison to be implemented via <strong>strict weak ordering</strong>. As \u00a723.2.4/2 of the ISO C++ standard says:</p>\n<blockquote>\n<p id=\"so_40572451_40573215_0\">Each associative container is parameterized on <code>Key</code> and an ordering\n  relation <code>Compare</code> that induces a strict weak ordering (...) on\n  elements of <code>Key</code>.</p>\n</blockquote>\n<p>See also <a href=\"http://en.cppreference.com/w/cpp/concept/Compare\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/concept/Compare</a>.</p>\n<p>Among other things, this means <em>x</em> cannot be less than itself, i.e. <em>x &lt; x</em> must be false.</p>\n<p>Your <code>ls</code> functor, however, does exactly that. When <code>lhs</code> is 1 and <code>rhs</code> is 1, then <code>true</code> is returned. The fact that this is incorrect should not come as a surprise; it's really all just a very technical, formal way of explaining what the English expression <em>\"something is less than something else\"</em> actually means in terms of mathematics or computer science.</p>\n<p>In any case, since your code does not meet the requirements of <code>std::map</code>, your program has <strong>undefined behaviour</strong>.</p>\n<hr>\n<p>The solution is simple: Just don't use <code>ls</code>. Instantiate your map as <code>std::map&lt;int, std::string&gt;</code> and it will work, because the default argument is an instantation of <code>std::less</code>, which has the correct behaviour.</p>\n</hr>", "LastEditorUserId": "3313064", "LastActivityDate": "2016-11-13T11:25:04.670", "Score": "1", "CreationDate": "2016-11-13T11:18:53.790", "ParentId": "40572451", "CommentCount": "0", "OwnerUserId": "3313064", "LastEditDate": "2016-11-13T11:25:04.670"}, "40572451": {"ViewCount": "60", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;    \n\nstruct ls{\nbool operator()(int lhs, int rhs){\nreturn lhs == rhs;\n}    \n};\n\nint main(){\nmap&lt;int,string,ls&gt; m1 {{1,\"A\"},{2,\"B\"}};\nmap&lt;int,string&gt;::iterator i;\n\nfor(i=m1.begin();i!=m1.end();++i) {\n    cout&lt;&lt;i-&gt;first&lt;&lt;\" - \"&lt;&lt;i-&gt;second&lt;&lt;endl;\n}     \n\n//If we print data here only 1, \"A\" data is present.\n      m1[2] = \"C\";\n      for(i=m1.begin();i!=m1.end();++i) {     \n         cout&lt;&lt;i-&gt;first&lt;&lt;\" - \"&lt;&lt;i-&gt;second&lt;&lt;endl;\n      }\n\n//the above statement updates m1[1] as \"C\" even though we are m1[2]\n}\n</code></pre>\n", "AcceptedAnswerId": "40573110", "Title": "Why is Map[2] updating a wrong key data? Is this a proper way of doing this?", "CreationDate": "2016-11-13T09:38:45.680", "Id": "40572451", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-11-13T11:23:37.333", "LastEditorUserId": "3313064", "LastActivityDate": "2016-11-13T11:25:04.670", "Score": "-4", "OwnerUserId": "7152315", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "40573110": {"Id": "40573110", "PostTypeId": "2", "Body": "<p>The problem is that you are not respecting the contract of <code>std::map</code> third template argument which should be the comparison function.</p>\n<p>The comparison function, which defaults to <code>std::less&lt;T&gt;</code>, must provide a total ordering on the keys of your <code>std::map</code>. For this purpose the ISO standard defines that, for associative containers at \u00a723.2.4.3:</p>\n<blockquote>\n<p id=\"so_40572451_40573110_0\">The phrase \u201cequivalence of keys\u201d means the equivalence relation imposed by the comparison and not the <code>operator==</code> on keys. That is, two keys <code>k1</code> and <code>k2</code> are considered to be equivalent if for the comparison object <code>comp</code>, <code>comp(k1, k2) == false</code> &amp;&amp; <code>comp(k2, k1) == false</code>. For any two keys <code>k1</code> and <code>k2</code> in the same container, calling <code>comp(k1, k2)</code> shall always return the same value.</p>\n</blockquote>\n<p>Now in your situation you define the comparison as <code>lhs == rhs</code> which means that</p>\n<pre><code>auto b1 = ls{}(1, 2);\nauto b2 = ls{}(2, 1};\n</code></pre>\n<p>are both <code>false</code>, so both keys are considered an unique key (if <code>a</code> is not less than <code>b</code> and <code>b</code> is not less than <code>a</code> then <code>a</code> must be equal to <code>b</code>). This means that on map construction only the first pair is inserted.</p>\n<p>But then with <code>m1[2] = \"C\"</code>, since you are getting the reference to the value mapped to <code>2</code> and 2 compares equal to 1 according to your function, you update the only key present.</p>\n", "LastActivityDate": "2016-11-13T11:05:15.093", "CommentCount": "1", "CreationDate": "2016-11-13T11:05:15.093", "ParentId": "40572451", "Score": "1", "OwnerUserId": "121747"}});