post_cb({"34556181": {"Id": "34556181", "PostTypeId": "2", "Body": "<p>No, in general it doesn't.  </p>\n<p>A constexpr function can be invoked in a non-constepr context in which it is allowed to throw an exception (except of course if you manually specify it to be <code>noexcept(true)</code>). </p>\n<p>However, as part of a constant expression (such as in your example), it should behave as if specified to be <code>noexcept(true)</code> (of course, if the evaluation of the expression would result in an exception being thrown this can't result in a call to <code>std::terminate</code> as the program isn't running yet, but instead leads to a compile time error). </p>\n<p>As I would have expected, your example doesn't trigger the static assertion with MSVC and g++. I'm not sure, whether this is a bug in clang or I'm missunderstanding something in the standard.</p>\n", "LastEditorUserId": "2881849", "LastActivityDate": "2016-01-01T13:32:04.747", "Score": "2", "CreationDate": "2016-01-01T12:36:17.243", "ParentId": "34555793", "CommentCount": "4", "OwnerUserId": "2881849", "LastEditDate": "2016-01-01T13:32:04.747"}, "34558600": {"Id": "34558600", "PostTypeId": "2", "Body": "<p>No this can not be the case, because not every inovocation of constexpr function has to be able to be evaluated as subexpression of a core constant expression. We only need one argument value that allows for this. So a constexpr function can contain a <em>throw</em> statement as long as we have a argument value which does not invoke that branch.</p>\n<p>This is covered in the draft C++14 standard section <code>7.1.5</code> The constexpr specifier [dcl.constexpr] which tells us what is allowed in a constexpr function:</p>\n<blockquote>\n<p id=\"so_34555793_34558600_0\">The definition of a constexpr function shall satisfy the following constraints:</p>\n<ul>\n<li><p id=\"so_34555793_34558600_1\">it shall not be virtual (10.3);</p></li>\n<li><p id=\"so_34555793_34558600_2\">its return type shall be a literal type;</p></li>\n<li><p id=\"so_34555793_34558600_3\">each of its parameter types shall be a literal type;</p></li>\n<li><p id=\"so_34555793_34558600_4\">its function-body shall be = delete, = default, or a compound-statement that does not contain</p>\n<ul>\n<li><p id=\"so_34555793_34558600_5\">an asm-definition,</p></li>\n<li><p id=\"so_34555793_34558600_6\">a goto statement,</p></li>\n<li><p id=\"so_34555793_34558600_7\">a try-block, or</p></li>\n<li><p id=\"so_34555793_34558600_8\">a definition of a variable of non-literal type or of static or thread storage duration or for which\n  no initialization is performed.</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>which as we can see does not forbid <code>throw</code> and in fact forbids very little since the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html\" rel=\"noreferrer\">Relaxing constraints on constexpr functions</a> proposal became part of C++14.</p>\n<p>Below we see the rule that says a constexpr function is well-formed if at least one argument value exists such that it can be evaluated as a subexpression of a core constant expression:</p>\n<blockquote>\n<p id=\"so_34555793_34558600_9\">For a non-template, non-defaulted constexpr function or a non-template, non-defaulted, non-inheriting\n  constexpr constructor, <strong>if no argument values exist such that an invocation of the function or constructor\n  could be an evaluated subexpression of a core constant expression (5.19), the program is ill-formed</strong>; no\n  diagnostic required. </p>\n</blockquote>\n<p>and below this paragraph we have the following example, which shows a perfect example for this case:</p>\n<pre><code>constexpr int f(bool b)\n  { return b ? throw 0 : 0; } // OK\nconstexpr int f() { return f(true); } // ill-formed, no diagnostic required\n</code></pre>\n<p>So we would expect the output for the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nconstexpr int f(bool b)   { return b ? throw 0 : 0; } \n\nint main() {\n    std::cout &lt;&lt; noexcept( f(1) ) &lt;&lt; \"\\n\" \n              &lt;&lt; noexcept( f(0) ) &lt;&lt; \"\\n\" ; \n}\n</code></pre>\n<p>to be (<em><a href=\"http://melpon.org/wandbox/permlink/ijy45qquzXPHHDYz\" rel=\"noreferrer\">see it live with gcc</a></em>):</p>\n<pre><code> 0\n 1\n</code></pre>\n<p>Visual Studio via <a href=\"http://webcompiler.cloudapp.net/\" rel=\"noreferrer\">webcompiler</a> also produces the same result. As hvd noted, clang has a bug as documented by the bug report <a href=\"https://llvm.org/bugs/show_bug.cgi?id=15481\" rel=\"noreferrer\">noexcept should check whether the expression is a constant expression</a>.</p>\n<p><b>Defect Report 1129</b></p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1129\" rel=\"noreferrer\">Defect report 1129: Default nothrow for constexpr functions</a> asks the same question:</p>\n<blockquote>\n<p id=\"so_34555793_34558600_10\">A constexpr function is not permitted to return via an exception. This should be recognised, and a function declared constexpr without an explicit exception specification should be treated as if declared noexcept(true) rather than the usual noexcept(false). For a function template declared constexpr without an explicit exception specification, it should be considered noexcept(true) if and only if the constexpr keyword is respected on a given instantiation. </p>\n</blockquote>\n<p>and the response was:</p>\n<blockquote>\n<p id=\"so_34555793_34558600_11\">The premise is not correct: an exception is forbidden only when a constexpr function is invoked in a context that requires a constant expression. Used as an ordinary function, it can throw.</p>\n</blockquote>\n<p>and it modified 5.3.7 [expr.unary.noexcept] paragraph 3 bullet 1 (<em>addition noted with emphasis</em>):</p>\n<blockquote>\n<p id=\"so_34555793_34558600_12\">a potentially evaluated call80 to a function, member function, function pointer, or member function pointer that does not have a non-throwing exception-specification (15.4 [except.spec]), <strong>unless the call is a constant expression (5.20 [expr.const]),</strong></p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2016-01-11T12:48:48.053", "Score": "10", "CreationDate": "2016-01-01T18:00:58.187", "ParentId": "34555793", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2016-01-11T12:48:48.053"}, "bq_ids": {"n4140": {"so_34555793_34558600_9": {"length": 25, "quality": 0.9259259259259259, "section_id": 5421}, "so_34555793_34557658_0": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_34555793_34556095_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 500}, "so_34555793_34558600_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5419}, "so_34555793_34556095_4": {"length": 26, "quality": 0.896551724137931, "section_id": 6122}, "so_34555793_34556095_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 6122}, "so_34555793_34558600_4": {"length": 7, "quality": 1.0, "section_id": 5419}, "so_34555793_34558600_2": {"length": 5, "quality": 1.0, "section_id": 5419}, "so_34555793_34558600_8": {"length": 10, "quality": 1.0, "section_id": 5419}, "so_34555793_34558600_12": {"length": 15, "quality": 0.6818181818181818, "section_id": 6122}, "so_34555793_34558600_3": {"length": 6, "quality": 1.0, "section_id": 5419}}, "n3337": {"so_34555793_34558600_9": {"length": 16, "quality": 0.5925925925925926, "section_id": 5216}, "so_34555793_34556095_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 5886}, "so_34555793_34558600_12": {"length": 17, "quality": 0.7727272727272727, "section_id": 5886}, "so_34555793_34556095_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 491}, "so_34555793_34558600_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5214}, "so_34555793_34556095_4": {"length": 25, "quality": 0.8620689655172413, "section_id": 5886}, "so_34555793_34558600_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 5214}, "so_34555793_34558600_2": {"length": 5, "quality": 1.0, "section_id": 5214}, "so_34555793_34558600_8": {"length": 6, "quality": 0.6, "section_id": 6895}, "so_34555793_34558600_3": {"length": 6, "quality": 1.0, "section_id": 5214}}, "n4659": {"so_34555793_34558600_9": {"length": 20, "quality": 0.7407407407407407, "section_id": 6843}, "so_34555793_34556095_0": {"length": 8, "quality": 0.5333333333333333, "section_id": 7584}, "so_34555793_34556095_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 802}, "so_34555793_34558600_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6841}, "so_34555793_34557658_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_34555793_34558600_4": {"length": 7, "quality": 1.0, "section_id": 6841}, "so_34555793_34558600_2": {"length": 5, "quality": 1.0, "section_id": 6841}, "so_34555793_34558600_8": {"length": 10, "quality": 1.0, "section_id": 6841}, "so_34555793_34558600_3": {"length": 6, "quality": 1.0, "section_id": 6841}}}, "34555793": {"ViewCount": "1281", "Body": "<p>Does <code>constexpr</code> specifier imply <code>noexcept</code> specifier for a function? <a href=\"https://stackoverflow.com/a/14391320/1430927\">Answer</a> to <a href=\"https://stackoverflow.com/questions/14391272/does-constexpr-imply-inline\">the similar question</a> says \"yes\" concerning <code>inline</code> specifier, but <a href=\"http://ericniebler.com/2014/09/27/assert-and-constexpr-in-cxx11/\" rel=\"nofollow noreferrer\">Eric Niebler's article</a> makes me wonder about possible answer to the current one. On my mind answer can depends on context of a using a <code>constexpr</code> function: is it constant expression context or run-time context, i.e. are all the parameters of the function known at compile time or not.</p>\n<p>I expected that the answer is \"yes\", but <a href=\"http://coliru.stacked-crooked.com/a/7a9e71c47df8ae92\" rel=\"nofollow noreferrer\">simple check</a> shows that it is not the case.</p>\n<pre><code>constexpr\nbool f(int) noexcept\n{\n    return true;\n}\n\nconstexpr\nbool g(int)\n{\n    return true;\n}\n\nstatic_assert(noexcept(f(1)));\nstatic_assert(noexcept(g(2))); // comment this line to check runtime behaviour\n\n#include &lt;cassert&gt;\n#include &lt;cstdlib&gt;\n\nint\nmain(int argc, char * [])\n{\n    assert(noexcept(f(argc)));\n    assert(noexcept(g(argc)));\n    return EXIT_SUCCESS;\n}\n</code></pre>\n", "AcceptedAnswerId": "34558600", "Title": "Does constexpr imply noexcept?", "CreationDate": "2016-01-01T11:39:18.470", "Id": "34555793", "CommentCount": "5", "LastEditDate": "2017-05-23T11:53:52.040", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-08T16:17:13.877", "Score": "14", "OwnerUserId": "1430927", "Tags": "<c++><inline><c++14><constexpr><noexcept>", "AnswerCount": "4"}, "34557658": {"Id": "34557658", "PostTypeId": "2", "Body": "<p>You are allowed to throw an exception in a constexpr function.  It is designed as such so that the implementer can indicate an error to the compiler.  Consider that you have the following function:</p>\n<pre><code>constexpr int fast_sqrt(int x) {\n    return (x &lt; 0) ? throw invalid_domain() : fast_sqrt_impl(x);\n}\n</code></pre>\n<p>In this case if x is negative we need to stop compilation immediately and indicate the problem to the user via compiler error.  This follows the idea that compiler errors are better than runtime errors (fail fast).</p>\n<p>C++ standard says this in (5.20):</p>\n<blockquote>\n<p id=\"so_34555793_34557658_0\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_34555793_34557658_1\">\u2014 a throw-expression (5.17)</p>\n</blockquote>\n", "LastActivityDate": "2016-01-01T16:02:22.740", "CommentCount": "2", "CreationDate": "2016-01-01T16:02:22.740", "ParentId": "34555793", "Score": "2", "OwnerUserId": "1539607"}, "34556095": {"Id": "34556095", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/noexcept\" rel=\"nofollow\">It is said</a> of <code>noexcept</code> that:</p>\n<blockquote>\n<p id=\"so_34555793_34556095_0\">The result is\u00a0false\u00a0if the\u00a0expression\u00a0contains [...] call to any type of function that does not have non-throwing exception specification, unless it is a constant expression.</p>\n</blockquote>\n<p>Also, about <code>constexpr</code>, <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\">it is true</a> that:</p>\n<blockquote>\n<p id=\"so_34555793_34556095_1\">the\u00a0noexcept\u00a0operator always returns\u00a0true\u00a0for a constant expression</p>\n</blockquote>\n<p>Under no circumstances does it seem to imply that the <code>constexpr</code> specifier forces a <code>noexcept</code> specifier for the surrounded expression, as someone showed in the comments with a counterexample and you also verified.</p>\n<p>Anyway, from the documentation, there is the following interesting note about the relationship between <code>noexcept</code> and <code>constexpr</code>:</p>\n<blockquote>\n<p id=\"so_34555793_34556095_2\">Because the\u00a0noexcept\u00a0operator always returns\u00a0true\u00a0for a constant expression, it can be used to check if a particular invocation of a constexpr function takes the constant expression branch</p>\n</blockquote>\n<p><strong>EDIT: example with GCC</strong></p>\n<p>Thanks to @hvd for his interesting comment/example with GCC about my last quote.</p>\n<pre><code>constexpr int f(int i) {\n    return i == 0 ? i : f(i - 1);\n}\n\nint main() {\n    noexcept(f(512));\n    return noexcept(f(0)) == noexcept(f(0));\n}\n</code></pre>\n<p>The code above returns <code>0</code>, with a warning that the statement <code>noexcept(f(512))</code> has no effect.<br/>\nCommenting out that statement that supposedly has no effect, the return value changes to <code>1</code>.</p>\n<p><strong>EDIT: known bug on clang</strong></p>\n<p>Again, thanks to @hvd also for <a href=\"https://llvm.org/bugs/show_bug.cgi?id=15481\" rel=\"nofollow\">this</a> link, that is about a well known bug in <em>clang</em> regarding the code mentioned in the question.</p>\n<p>Quote from the bug report:</p>\n<blockquote>\n<p id=\"so_34555793_34556095_3\">Quoth the book of C++, [expr.unary.noexcept]p3:</p>\n<p id=\"so_34555793_34556095_4\">\"The result of the noexcept operator is false if in a potentially-evaluated context the expression would contain a potentially-evaluated call to a function, member function, function pointer, or member function pointer that does not have a non-throwing exception-specification (15.4), <em>unless the call is a constant expression (5.19)</em>\".</p>\n<p id=\"so_34555793_34556095_5\">We do not implement that last phrase.</p>\n</blockquote>\n", "LastEditorUserId": "4987285", "LastActivityDate": "2016-01-01T14:44:41.170", "Score": "5", "CreationDate": "2016-01-01T12:24:58.410", "ParentId": "34555793", "CommentCount": "8", "OwnerUserId": "4987285", "LastEditDate": "2016-01-01T14:44:41.170"}});