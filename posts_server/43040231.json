post_cb({"bq_ids": {"n4140": {"so_43040231_43040436_0": {"length": 9, "quality": 0.9, "section_id": 6708}}, "n3337": {"so_43040231_43040436_0": {"length": 9, "quality": 0.9, "section_id": 6463}}, "n4659": {"so_43040231_43040436_0": {"length": 9, "quality": 0.9, "section_id": 8183}}}, "43040440": {"Id": "43040440", "PostTypeId": "2", "Body": "<p>Comparing signed and unsigned values is \"dangerous\" in the sense that you may not get what you expect when the signed value is negative (it may well behave as a very large unsigned value, and thus <code>a &gt; b</code> gives <code>true</code> when <code>a = -1</code> and <code>b = 100</code>. (The use of <code>const int</code> works because the compiler knows the value isn't changing and thus can say \"well, this value is always 1, so it works fine here\")</p>\n<p>As long as the value you want to compare fits in <code>unsigned int</code> (on typical machines, a little over 4 billion) is fine.</p>\n", "LastActivityDate": "2017-03-27T07:36:32.597", "CommentCount": "0", "CreationDate": "2017-03-27T07:36:32.597", "ParentId": "43040231", "Score": "1", "OwnerUserId": "1919155"}, "43040436": {"Id": "43040436", "PostTypeId": "2", "Body": "<p>If you are using <code>std::string</code> with the default allocator (which is likely), then <code>size_type</code> is actually <code>size_t</code>.</p>\n<p><strong>[support.types]/6</strong> defines that <code>size_t</code> is </p>\n<blockquote>\n<p id=\"so_43040231_43040436_0\">an implementation-defined unsigned integer type that is large enough to contain the size\n  in bytes of any object.</p>\n</blockquote>\n<p>So it's not technically guaranteed to be a <code>unsigned int</code>, but I believe it is defined this way in most cases.</p>\n<p>Now regarding your second question: if you use <code>const int something = 2</code>, the compiler sees that this integer is a) never negative and b) never changes, so it's always safe to compare this variable with <code>size_t</code>. In some cases the compiler may optimize the variable out completely and simply replace all it's occurrences with <code>2</code>.</p>\n<p>I would say that it is better to use <code>size_type</code> everywhere where you are to the size of something, since it is more verbose.</p>\n", "LastEditorUserId": "1490355", "LastActivityDate": "2017-03-27T08:07:40.743", "Score": "1", "CreationDate": "2017-03-27T07:36:18.343", "ParentId": "43040231", "CommentCount": "4", "OwnerUserId": "1490355", "LastEditDate": "2017-03-27T08:07:40.743"}, "43041094": {"Id": "43041094", "PostTypeId": "2", "Body": "<p>What the compiler warns about is the comparison of unsigned and signed integer types. This is because the signed integer can be negative and the meaning is counter intuitive. This is because the signed is converted to unsigned before comparison, which means <strong>the negative number will compare greater than the positive</strong>.</p>\n<blockquote>\n<p id=\"so_43040231_43041094_0\">Is it safe to use an unsigned int in order to compare with a std::string::size_type? The compiler does not return a warning in that case but I am not sure if it is safe.</p>\n</blockquote>\n<p>Yes, they are both unsigned and then the semantics is what's expected. If their range differs the narrower are converted to a wider type.</p>\n<blockquote>\n<p id=\"so_43040231_43041094_1\">Why is the compiler not giving a warning with the original code const int pad = 1. Is the compiler automatically converting the variable pad to an unsigned int?</p>\n</blockquote>\n<p>This is because how the compiler is constructed. The compiler parses and to some extent optimizes the code before warnings are issued. The important point is that at the point this warning is being considered the compiler nows that the signed integer is <code>1</code> and then it's safe to compare with a unsigned integer.</p>\n<blockquote>\n<p id=\"so_43040231_43041094_2\">I could also replace const int pad = 1; by string::size_type pad = 1;, but the meaning of the variable pad is not really linked to a string size in my opinion. Still, would this be the best approach in that case to avoid having different types in the comparison?</p>\n</blockquote>\n<p>If you don't want it to be constant the best solution would probably be to make it at least an unsigned integer type. However you should be aware that there is no guaranteed relation between normal integer types and sizes, for example <code>unsigned int</code> may be narrower, wider or equal to <code>size_t</code> and <code>size_type</code> (the latter may also differ).</p>\n", "LastActivityDate": "2017-03-27T08:13:02.820", "CommentCount": "0", "CreationDate": "2017-03-27T08:13:02.820", "ParentId": "43040231", "Score": "1", "OwnerUserId": "4498329"}, "43040231": {"ViewCount": "185", "Body": "<p>I am going trough the book \"Accelerated C++\" by Andrew Koenig and Barbara E. Moo and I have some questions about the main example in chap 2. The code can be summarized as below, and is compiling without warning/error with g++:</p>\n<pre><code>#include &lt;string&gt;\nusing std::string;\n\nint main()\n{\n    const string greeting = \"Hello, world!\";\n    // OK\n    const int pad = 1;\n    // KO\n    // int pad = 1;\n    // OK\n    // unsigned int pad = 1;\n    const string::size_type cols = greeting.size() + 2 + pad * 2;\n    string::size_type c = 0;\n    if (c == 1 + pad)\n    {;}\n\n    return 0;\n}\n</code></pre>\n<p>However, if I replace <code>const int pad = 1;</code> by <code>int pad = 1;</code>, the g++ compiler will return a warning:</p>\n<pre><code>warning: comparison between signed and unsigned integer expressions [-Werror=sign-compare]\n    if (c == 1 + pad)\n</code></pre>\n<p>If I replace <code>const int pad = 1;</code> by <code>unsigned int pad = 1;</code>, the g++ compiler will not return a warning.</p>\n<p>I understand why g++ return the warning, but I am not sure about the three below points:</p>\n<ul>\n<li>Is it safe to use an <code>unsigned int</code> in order to compare with a <code>std::string::size_type</code>? The compiler does not return a warning in that case but I am not sure if it is safe.</li>\n<li>Why is the compiler not giving a warning with the original code <code>const int pad = 1</code>. Is the compiler automatically converting the variable <code>pad</code> to an <code>unsigned int</code>?</li>\n<li>I could also replace <code>const int pad = 1;</code> by <code>string::size_type pad = 1;</code>, but the meaning of the variable <code>pad</code> is not really linked to a string size in my opinion. Still, would this be the best approach in that case to avoid having different types in the comparison?</li>\n</ul>\n", "AcceptedAnswerId": "43041149", "Title": "Is it safe to compare an unsigned int with a std::string::size_type", "CreationDate": "2017-03-27T07:23:58.437", "Id": "43040231", "CommentCount": "3", "LastEditDate": "2017-03-27T07:30:06.850", "PostTypeId": "1", "LastEditorUserId": "5825133", "LastActivityDate": "2017-03-27T08:15:00.170", "Score": "4", "OwnerUserId": "5825133", "Tags": "<c++><unsigned><stdstring>", "AnswerCount": "4"}, "43041149": {"Id": "43041149", "PostTypeId": "2", "Body": "<p>From the compiler point of view:</p>\n<ol>\n<li>It is <em>unsafe</em> to compare signed and unsinged variables (non-constants).</li>\n<li>It is <em>safe</em> to compare 2 unsinged variables of different sizes.</li>\n<li>It is <em>safe</em> to compare an unsigned variable with a singed constant if the compiler can check that constant to be in the allowed range for the type of the signed variable (e.g. for 16-bit signed integer it is safe to use a constant in range [0..32767]).</li>\n</ol>\n<p>So the answers to your questions:</p>\n<ol>\n<li>Yes, it is safe to compare <code>unsigned int</code> and <code>std::string::size_type</code>.</li>\n<li>There is no warning because the compiler can perform the safety check (while compiling :)).</li>\n<li>There is <em>no</em> problem to use different <em>unsigned</em> types in comparison. Use <code>unsinged int</code>.</li>\n</ol>\n", "LastActivityDate": "2017-03-27T08:15:00.170", "CommentCount": "0", "CreationDate": "2017-03-27T08:15:00.170", "ParentId": "43040231", "Score": "2", "OwnerUserId": "1671661"}});