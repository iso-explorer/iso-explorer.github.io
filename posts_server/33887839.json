post_cb({"33887839": {"ViewCount": "93", "Body": "<p>I like implementing classes entirely in header files, but I don't like sprinkling <code>std::</code> all over my code.</p>\n<p>I think it would be bad to be <code>using namespace std</code> in a header file, because that would pollute the namespace of all downstream source files.</p>\n<p>So I often end up doing something like this in the header file:</p>\n<pre><code>class foo {\n    using std::vector;\n    // in this code I don't need to qualify vector with std::\n}\n</code></pre>\n<p>but this doesn't seem to work for some things, such as <code>std::unique_ptr</code>, <code>std::invalid_argument</code>, <code>std::move</code>.</p>\n<p>Is there a remedy for my wants?</p>\n", "AcceptedAnswerId": "33888228", "Title": "How to avoid littering header files with std::", "CreationDate": "2015-11-24T07:36:07.773", "Id": "33887839", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2015-11-24T08:24:49.203", "Score": "-4", "OwnerUserId": "827280", "Tags": "<c++><namespaces>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33887839_33888228_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 5509}}, "n3337": {"so_33887839_33888228_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 5295}}, "n4659": {"so_33887839_33888228_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 6944}}}, "33888275": {"Id": "33888275", "PostTypeId": "2", "Body": "<p>My suggestion would still be to get into the habit of using <code>std::</code> wherever and whenever it is needed. It's a good thing, not a bad thing, to write it out.</p>\n<p>I put everything \"in one file\", but this should work as a  header or one file solution:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;stdexcept&gt;\n\nusing std::vector;\nusing std::invalid_argument;\nusing std::unique_ptr;\n\nclass foo\n{\n\npublic:\n    foo(int x)\n    {\n        if (x &gt; 100) throw invalid_argument(\"too big\");\n        iv.push_back(x);\n    }\n\nprivate:\n    vector&lt;int&gt; iv;\n    unique_ptr&lt;int&gt; ip;\n};\n\nint main()\n{\n    foo bar(32);\n}\n</code></pre>\n<p>The <code>using</code> inside a class allows you write <code>typedef</code> in a different way (some say \"more readable\"):</p>\n<pre><code>using vector_int = std::vector&lt;int&gt;;\n</code></pre>\n<p>And to refer to (for example) a constructor of a different class: </p>\n<pre><code>class BasicTypeDecl : public TypeDecl\n{\npublic:\n    using TypeDecl::TypeDecl;\n    ...\n};\n</code></pre>\n<p>With this \"knowledge\", we could come up with:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;stdexcept&gt;\n\n\nclass foo\n{\n\npublic:\n    using intvec=std::vector&lt;int&gt;;\n    using intup = std::unique_ptr&lt;int&gt;;\n\n    foo(int x)\n        {\n            using std::invalid_argument;\n            if (x &gt; 100) throw invalid_argument(\"too big\");\n            iv.push_back(x);\n        }\n\nprivate:\n    intvec iv;\n    intup ip;\n};\n\nint main()\n{\n    foo bar(32);\n}\n</code></pre>\n<p>That has <code>std::invalid_argument</code>, but the other types are aliased with the <code>using</code> statement, and if you are using the same type multiple times, that could make some sense (in fact, you could also use it globally, to make common names for types that are used multiple times)</p>\n", "LastActivityDate": "2015-11-24T08:03:08.190", "CommentCount": "0", "CreationDate": "2015-11-24T08:03:08.190", "ParentId": "33887839", "Score": "1", "OwnerUserId": "1919155"}, "33888228": {"Id": "33888228", "PostTypeId": "2", "Body": "<p>There's nothing wrong using <code>std::</code>. In fact, I find my self reading code written by other people and when I see something like <code>stack stk;</code>, it makes me wonder if that <code>stack</code> is standard. Thus, I would recommend using it, as although you type 5 more characters, it makes your code more readable to other coders.</p>\n<p>Now as far as why what you've tried doesn't work. It doesn't because C++ doesn't allow it. According to the draft standard <em>7.3.4/p1 Using directive [namespace.udir]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_33887839_33888228_0\"><strong>A using-directive shall not appear in class scope,</strong> but may appear in namespace scope or in block scope. [ Note: When looking up a\n  namespace-name in a using-directive, only namespace names are\n  considered, see 3.4.6. \u2014 end note ] The optional\n  attribute-specifier-seq appertains to the using-directive.</p>\n</blockquote>\n<p>The above quote justifies why you can't do:</p>\n<pre><code>class Foo {\n  using namespace std;\n};\n</code></pre>\n<p>You can't do this:</p>\n<pre><code>class Foo {\n  using std::vector;\n};\n</code></pre>\n<p>Because <code>std::vector</code> is a template class (i.e., it needs <code>&lt;T&gt;</code>).</p>\n<p>Also from the draft standard <em>7.3.3/p5 The using declaration [namespace.udecl]:</em></p>\n<blockquote>\n<p id=\"so_33887839_33888228_1\">A using-declaration shall not name a template-id.</p>\n</blockquote>\n<p>Forbids you from doing this:</p>\n<pre><code>class Foo {\n  using std::vector&lt;int&gt;;\n};\n</code></pre>\n<p>What you could do if this \"bothers\" you so much. Put all your code in a namespace and drag the <code>using namespace std;</code> there:</p>\n<pre><code>namespace mine {\n  using namespace std;\n\n  struct foo {\n    unique_ptr&lt;int&gt; ptr;\n  };\n}\n</code></pre>\n<p>This however, won't save you from dragging the <code>std</code> namespace when you do <code>using namespace mine;</code>.</p>\n<p>Another option if your compiler supports C++11, make a template alias:</p>\n<pre><code>struct Foo {\n  template&lt;typename T&gt;\n  using unique_ptr = std::unique_ptr&lt;T&gt;;\n  unique_ptr&lt;int&gt; ptr;\n};\n</code></pre>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2015-11-24T08:24:49.203", "Score": "3", "CreationDate": "2015-11-24T08:00:33.440", "ParentId": "33887839", "CommentCount": "2", "OwnerUserId": "2352671", "LastEditDate": "2015-11-24T08:24:49.203"}});