post_cb({"bq_ids": {"n4140": {"so_38772637_38773012_2": {"length": 7, "quality": 0.7, "section_id": 5943}, "so_38772637_38773075_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_38772637_38773012_0": {"length": 38, "quality": 0.926829268292683, "section_id": 21}, "so_38772637_38772848_2": {"length": 4, "quality": 0.8, "section_id": 0}, "so_38772637_38773075_1": {"length": 18, "quality": 1.0, "section_id": 30}, "so_38772637_38773012_3": {"length": 54, "quality": 0.9473684210526315, "section_id": 22}, "so_38772637_38772848_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 0}, "so_38772637_38773012_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 27}}, "n3337": {"so_38772637_38773012_2": {"length": 7, "quality": 0.7, "section_id": 5714}, "so_38772637_38773075_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}, "so_38772637_38773012_0": {"length": 38, "quality": 0.926829268292683, "section_id": 18}, "so_38772637_38772848_2": {"length": 4, "quality": 0.8, "section_id": 0}, "so_38772637_38773012_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 24}, "so_38772637_38773012_3": {"length": 54, "quality": 0.9473684210526315, "section_id": 19}, "so_38772637_38772848_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 0}, "so_38772637_38773075_1": {"length": 18, "quality": 1.0, "section_id": 27}}, "n4659": {"so_38772637_38773012_2": {"length": 7, "quality": 0.7, "section_id": 7428}, "so_38772637_38773075_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_38772637_38773012_0": {"length": 38, "quality": 0.926829268292683, "section_id": 21}, "so_38772637_38772848_2": {"length": 4, "quality": 0.8, "section_id": 0}, "so_38772637_38773075_1": {"length": 18, "quality": 1.0, "section_id": 30}, "so_38772637_38773012_3": {"length": 54, "quality": 0.9473684210526315, "section_id": 22}, "so_38772637_38772848_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 0}, "so_38772637_38773012_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 27}}}, "38773012": {"Id": "38773012", "PostTypeId": "2", "Body": "<p>I'm afraid this really comes down to \"<em>because it is</em>\".</p>\n<p>Integer promotion ends at <code>int</code>; there is no promotion to types larger than <code>int</code>. So, you're left with two bog-standard implicit conversions, and it just so happens that they are equally good matches.</p>\n<blockquote>\n<p id=\"so_38772637_38773012_0\"><code>[C++14: 4.5/1]:</code> A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion rank (4.13) is less than the rank of <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned int</code>.</p>\n<p id=\"so_38772637_38773012_1\"><code>[C++14: 4.5/7]:</code> These conversions are called <em>integral promotions</em>.</p>\n<p id=\"so_38772637_38773012_2\"><code>[C++14: 5/10]:</code> <em>[..]</em> This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>\n<ul>\n<li>If either operand is of scoped enumeration type (7.2), no conversions are performed; if the other operand does not have the same type, the expression is ill-formed.</li>\n<li>If either operand is of type <code>long double</code>, the other shall be converted to <code>long double</code>.</li>\n<li>Otherwise, <strong>if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</strong></li>\n<li>Otherwise, if either operand is <code>float</code>, the other shall be converted to float.</li>\n<li><strong>Otherwise, the integral promotions (4.5) shall be performed on both operands</strong> <em>[..]</em></li>\n</ul>\n</blockquote>\n<p>Perhaps, when the use of <code>long int</code> and <code>long long int</code> became popular (particular through type aliases in <code>cstdint</code> and friends), the standard could have been modified to introduce integral promotions to these types. Then your conversion would not be ambiguous. However, lots of existing code could also have been broken.</p>\n<p>Since performing a cast instead is a cheap fix, I doubt this is deemed worthwhile to \"fix\" by the standard committee.</p>\n<p>Perhaps tellingly, the relatively new fixed-width <code>char</code> types <em>can</em> be promoted in this fashion:</p>\n<blockquote>\n<p id=\"so_38772637_38773012_3\"><code>[C++14: 4.5/2]:</code> A prvalue of type <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> (3.9.1) can be converted to a prvalue of the first of the following types that can represent all the values of its underlying type: <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>, <code>long long int</code>, or <code>unsigned long long int</code>. If none of the types in that list can represent all the values of its underlying type, a prvalue of type <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> can be converted to a prvalue of its underlying type.</p>\n</blockquote>\n", "LastEditorUserId": "560648", "LastActivityDate": "2016-08-04T16:47:30.987", "Score": "5", "CreationDate": "2016-08-04T16:41:17.297", "ParentId": "38772637", "CommentCount": "0", "LastEditDate": "2016-08-04T16:47:30.987", "OwnerUserId": "560648"}, "38772637": {"ViewCount": "559", "Body": "<p>Why is the implicit conversion of <code>int</code> to <code>int64_t</code> vs <code>int</code> to <code>double</code> ambiguous?</p>\n<p>I would have thought the integral overload would have precedence over integral to floating point?</p>\n<pre><code>#include &lt;stdint.h&gt;\n\nvoid foo(double) {}\nvoid foo(int64_t) {}\n\nint main()\n{\n    foo(5);\n    return 0;\n}\n</code></pre>\n<blockquote id=\"so_38772637_38772637_0\">\n<pre><code>main.cpp: In function \u2018int main()\u2019:\nmain.cpp:8:10: error: call of overloaded \u2018foo(int)\u2019 is ambiguous\n     foo(5);\n          ^\nmain.cpp:3:6: note: candidate: void foo(double)\n void foo(double) {}\n      ^\nmain.cpp:4:6: note: candidate: void foo(int64_t)\n void foo(int64_t) {}\n      ^\n</code></pre>\n</blockquote>\n<p>My environment is:</p>\n<ul>\n<li>x86_64</li>\n<li>g++-5.4 (with <code>-std=c++14</code>)</li>\n</ul>\n<p><code>int64_t</code> is a <code>long int</code> on my machine:</p>\n<blockquote>\n<p id=\"so_38772637_38772637_1\"><code>/usr/include/stdint.h</code>:</p>\n</blockquote>\n<pre><code> # if __WORDSIZE == 64\n typedef long int        int64_t;\n # else\n</code></pre>\n<p>I have confirmed this with a static assert in my test app:</p>\n<pre><code>static_assert(__WORDSIZE == 64, \"\");\nstatic_assert(std::is_same&lt;int64_t, long int&gt;::value, \"\");\n</code></pre>\n<p>My build flags are:</p>\n<pre><code>-std=c++14 -Werror -Wall -Wextra -m64 -msse2 -msse4.2 -mfpmath=sse \n-ftemplate-depth-128 -Wno-unused-parameter -pthread  -g -ggdb3 -O0 -fno-inline\n</code></pre>\n", "AcceptedAnswerId": "38773075", "Title": "overload ambiguous (int -> int64_t vs int -> double)", "CreationDate": "2016-08-04T16:20:39.403", "Id": "38772637", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-08-04T16:34:51.320", "LastEditorUserId": "955273", "LastActivityDate": "2016-08-04T17:15:22.970", "Score": "10", "OwnerUserId": "955273", "Tags": "<c++>", "AnswerCount": "3"}, "38772848": {"Id": "38772848", "PostTypeId": "2", "Body": "<p>The compiler is right... By default, your numeric literal <code>5</code> is of type <code>int</code>...  </p>\n<p>To make that function call, overload resolution must happen, which basically checks the viability of conversion. Note, it's going to be a case of <em>conversion</em> not <em>promotion</em></p>\n<p>Now, to explain why? I'll quote the story from cppreference: <em>(I know, not a replacement for the standard)</em></p>\n<p>In the selection of best viable function for <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution#Best_viable_function\" rel=\"nofollow noreferrer\">overload resolution</a>:</p>\n<blockquote>\n<p id=\"so_38772637_38772848_0\">F1 is determined to be a better function than F2 if implicit\n  conversions for all arguments of F1 are not worse than the implicit\n  conversions for all arguments of F2, and</p>\n<ol>\n<li>there is at least one argument of F1 whose implicit conversion is better than the corresponding implicit conversion for that argument of\n  F2</li>\n<li>or, ...</li>\n<li>or, ...  </li>\n</ol>\n</blockquote>\n<p>Now let us see what implicit <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Order_of_the_conversions\" rel=\"nofollow noreferrer\">conversion sequence</a> is:</p>\n<blockquote>\n<p id=\"so_38772637_38772848_1\">Implicit conversion sequence consists of the following, in this order:</p>\n<ol>\n<li>zero or one <em>standard conversion sequence</em>;</li>\n<li>. . . .</li>\n</ol>\n</blockquote>\n<p>Now, let us see what a <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Order_of_the_conversions\" rel=\"nofollow noreferrer\"><em>standard conversion sequence</em></a> is:</p>\n<blockquote>\n<p id=\"so_38772637_38772848_2\">A standard conversion sequence consists of the following, in this\n  order:</p>\n<ol>\n<li>zero or one lvalue transformation;</li>\n<li>zero or <strong>one numeric promotion or numeric conversion</strong>;</li>\n<li>. . . </li>\n</ol>\n</blockquote>\n<p>There you have it, from here, refer to the table in <a href=\"https://stackoverflow.com/a/38773075/1621391\">NathanOliver's answer</a>..</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-04T17:15:22.970", "Score": "0", "CreationDate": "2016-08-04T16:31:52.917", "ParentId": "38772637", "CommentCount": "4", "LastEditDate": "2017-05-23T12:08:52.783", "OwnerUserId": "1621391"}, "38773075": {"Id": "38773075", "PostTypeId": "2", "Body": "<p>From [over.ics.user] table 12 we have</p>\n<p><a href=\"https://i.stack.imgur.com/Fe5wH.png\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Fe5wH.png\"/></a></p>\n<p>As you can see integer and floating point promotions have the same rank and integer and floating point conversions have the same rank.</p>\n<p>Now we need to determine if <code>5 -&gt; int64_t</code> is a integer promotion or conversion.  If we check 4.5 we find</p>\n<blockquote>\n<p id=\"so_38772637_38773075_0\">A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned int.</p>\n</blockquote>\n<p>The promotion stops at <code>int</code> so we have to look at 4.7 which is integer conversion and we have</p>\n<blockquote>\n<p id=\"so_38772637_38773075_1\">A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped enumeration type can be converted to a prvalue of an integer type.</p>\n</blockquote>\n<p>Which is what is going on.  So <code>5 -&gt; int64_t</code> is integer conversion and <code>5 -&gt; double</code> is floating point conversion which are both ranked the same so the overload resolution is ambiguous.</p>\n", "LastActivityDate": "2016-08-04T16:45:12.980", "Score": "10", "CreationDate": "2016-08-04T16:45:12.980", "ParentId": "38772637", "CommentCount": "7", "OwnerUserId": "4342498"}});