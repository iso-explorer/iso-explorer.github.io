post_cb({"bq_ids": {"n4140": {"so_46681235_46682497_0": {"length": 14, "quality": 0.875, "section_id": 5907}}, "n3337": {"so_46681235_46682497_0": {"length": 14, "quality": 0.875, "section_id": 5679}}, "n4659": {"so_46681235_46682497_0": {"length": 14, "quality": 0.875, "section_id": 7389}}}, "46682497": {"Id": "46682497", "PostTypeId": "2", "Body": "<p>the standard says:</p>\n<blockquote>\n<p id=\"so_46681235_46682497_0\">[c++17-12.2.3.2-2]The declaration of a non-inline static data member in its class definition is not a definition and may be of an incomplete type other than cv void.</p>\n</blockquote>\n<p>now, maybe your confusion stems from believing that the two expressions</p>\n<pre><code>static const smart_enum first; // class scope\nconstexpr smart_enum smart_enum::first = ...; // namespace scope\n</code></pre>\n<p>declare different types. This is not the case because the type of a <code>constexpr T</code> is still <code>const T</code> ( in fact you can always write <code>constexpr const T</code> to mean the same thing ).</p>\n<p>So, in your code, you first declare a name 'first' of incomplete type 'const smart_enum', then you leter define it as \"constexpr smart_enum\" ( or \"constexpr <strong>inline const</strong> smart_enum\" if we add everything constexpr implies explictly ).</p>\n", "LastEditorUserId": "8631381", "LastActivityDate": "2017-10-11T07:47:10.660", "Score": "1", "CreationDate": "2017-10-11T07:40:01.920", "ParentId": "46681235", "CommentCount": "0", "OwnerUserId": "8631381", "LastEditDate": "2017-10-11T07:47:10.660"}, "46681235": {"ViewCount": "90", "Body": "<p>Consider this use case of a <code>static constexpr</code> member:</p>\n<pre><code>// smart_enum.h\nclass smart_enum {\n    // Some data, operations, etc.\n    // Cannot use constexpr here, smart_enum is incomplete at this point\n    static const smart_enum first, second;\n};\n\nconstexpr smart_enum smart_enum::first = {}, smart_enum::second = {};\n</code></pre>\n<p>Are <code>first</code> and <code>second</code> automatically <code>inline</code> variables? Or do I need to qualify them as such? Or am I unable to qualify them as inline and need to provide a definition in some source file later? I have always been confused by this \"redefinition\" from <code>const</code> to <code>constexpr</code> and would like more light to be shed on what this really means.</p>\n<p>Specifically I am wondering about the interaction of <code>const</code> declaration to <code>constexpr</code> definition and how that plays out with automatic <code>inline</code> of a <code>static constexpr</code> (<a href=\"https://stackoverflow.com/questions/45019980\">Redefinitions of constexpr static data members are allowed now? (but not inline const)?</a>)</p>\n", "AcceptedAnswerId": "46682497", "Title": "Does redeclaring a static const member as constexpr automatically qualify it to be inline?", "CreationDate": "2017-10-11T06:29:49.260", "Id": "46681235", "CommentCount": "2", "LastEditDate": "2017-10-11T06:47:16.287", "PostTypeId": "1", "LastEditorUserId": "975989", "LastActivityDate": "2017-10-11T20:10:41.263", "Score": "0", "OwnerUserId": "975989", "Tags": "<c++><c++1z><constexpr>", "AnswerCount": "1"}});