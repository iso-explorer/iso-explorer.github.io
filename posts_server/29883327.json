post_cb({"29883695": {"ParentId": "29883327", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-04-26T21:20:49.610", "Score": "3", "LastEditorUserId": "464581", "LastEditDate": "2015-04-26T21:32:35.710", "Id": "29883695", "OwnerUserId": "464581", "Body": "<p>Undefined behavior with respect to <code>const_cast</code> is defined by the C++11 standard's <strong>\u00a73.8/9</strong> (\u00a73.8 is \u201cObject lifetime\u201d):</p>\n<blockquote>\n<p id=\"so_29883327_29883695_0\"><strong>\u201d</strong> Creating a new object at the storage location that a <code>const</code> object with static, thread, or automatic storage duration occupies or, at the storage location that such a <code>const</code> object used to occupy before its lifetime ended results in undefined behavior.</p>\n</blockquote>\n<p>and <strong>\u00a77.1.6.1/4</strong> (\u00a77.1.6.1 is \u201cThe <em>cv-qualifiers</em>\u201d)</p>\n<blockquote>\n<p id=\"so_29883327_29883695_1\"><strong>\u201d</strong> Except that any class member declared <code>mutable</code> (7.1.1) can be modified, any attempt to modify a <code>const</code>\n  object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>In other words, you get UB if you modify an <strong><em>originally <code>const</code></em></strong> object, and otherwise <sup>1</sup>not.</p>\n<p>The <code>const_cast</code> itself doesn't introduce UB.</p>\n<hr>\n<p>There is additionally a non-normative note at <strong>\u00a75.2.11/7</strong> that \u201cdepending on the type\u201d a write through the pointer or reference obtained from a <code>const_cast</code>, may have undefined behavior.</p>\n<p>This non-normative note is so wooly that it has its own non-normative footnote, that explains that \u201c<code>const_cast</code> is not limited to conversions that cast away a <code>const</code>-qualifier.\u201d.</p>\n<p>However, still with that clarification I fail to think of any case where the write could be well-defined or not depending on the type, i.e., I fail to make sense of this note. Two other answers here focus on the word \u201cwrite\u201d in this note, and that's necessary to get into UB-land via \u00a73.8/9, yes. The to me rather fishy aspect is the \u201cdepending on the type\u201d, which appears to be the significant part of that note.</p>\n<hr>\n<p><sup><sup>1)</sup> Except insofar as UB-rules about other non-<code>const_cast</code>-related things get into play, e.g. nulling a pointer that's later dereferenced in a context other than as <code>typeid</code>-expression.</sup></p>\n</hr></hr>", "LastActivityDate": "2015-04-26T21:32:35.710"}, "29883410": {"ParentId": "29883327", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-04-26T20:55:07.947", "Score": "6", "LastEditorUserId": "2069064", "LastEditDate": "2015-04-26T21:25:42.120", "Id": "29883410", "OwnerUserId": "2069064", "Body": "<p>We have this in [dcl.type.cv]:</p>\n<blockquote>\n<p id=\"so_29883327_29883410_0\">Except that any class member declared <code>mutable</code> (7.1.1) can be modified, any attempt to modify a <code>const</code> object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>And there is a note (non-normative) in [expr.const.cast] which states:</p>\n<blockquote>\n<p id=\"so_29883327_29883410_1\"><em>[Note:</em> Depending on the type of the object, a <strong>write operation</strong> through the pointer, lvalue or pointer\n  to data member resulting from a <code>const_cast</code> that casts away a <em>const-qualifier</em> may produce undefined\n  behavior (7.1.6.1). <em>\u2014end note ]</em></p>\n</blockquote>\n<p>An attempt to modify an object or a write operation after a <code>const_cast</code> [may] result in undefined behavior. Here, we have no write operation. </p>\n", "LastActivityDate": "2015-04-26T21:25:42.120"}, "29883374": {"ParentId": "29883327", "CommentCount": "2", "Body": "<p>This particular example happens to be safe (have well defined behavior) because there is no <em>write</em> to an object which is declared <code>const</code>.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "29883374", "Score": "6", "CreationDate": "2015-04-26T20:51:54.117", "LastActivityDate": "2015-04-26T20:51:54.117"}, "29883327": {"CommentCount": "5", "ViewCount": "1686", "CreationDate": "2015-04-26T20:47:36.410", "LastActivityDate": "2015-04-26T21:32:35.710", "Title": "Is it safe to remove const via const_cast and invoke a non-const function that does not modify the resulting object?", "AcceptedAnswerId": "29883695", "PostTypeId": "1", "Id": "29883327", "Score": "5", "Body": "<p>I know that casting away <code>const</code>-ness should be done with care, and any attempt to remove <code>const</code>-ness from an initially <code>const</code> object followed by modifying the object results in undefined behaviour. What if we want to remove <code>const</code>-ness so that we may invoke a non-const function which doesn't modify the object? I know that we should actually mark such function <code>const</code>, but suppose I'm using a \"bad\" code that doesn't have the <code>const</code> version available. </p>\n<p>So, to summarize, is the code below \"safe\"? My guess is that as long as you don't end up modifying the object you're ok, but I'm not 100% sure.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo\n{\n    void f() // doesn't modify the instance, although is not marked const\n    {\n        std::cout &lt;&lt; \"Foo::f()\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    const Foo foo;\n    const_cast&lt;Foo&amp;&gt;(foo).f(); // is this safe?\n}\n</code></pre>\n", "Tags": "<c++><const-cast>", "OwnerUserId": "3093378", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29883327_29883410_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}, "so_29883327_29883695_0": {"section_id": 7197, "quality": 1.0, "length": 26}, "so_29883327_29883410_1": {"section_id": 6057, "quality": 0.8333333333333334, "length": 20}, "so_29883327_29883695_1": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_29883327_29883410_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}, "so_29883327_29883695_0": {"section_id": 6941, "quality": 1.0, "length": 26}, "so_29883327_29883410_1": {"section_id": 5825, "quality": 0.8333333333333334, "length": 20}, "so_29883327_29883695_1": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_29883327_29883410_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}, "so_29883327_29883695_0": {"section_id": 8706, "quality": 0.9230769230769231, "length": 24}, "so_29883327_29883410_1": {"section_id": 7555, "quality": 0.8333333333333334, "length": 20}, "so_29883327_29883695_1": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}});