post_cb({"1855825": {"ParentId": "1855773", "CommentCount": "1", "CreationDate": "2009-12-06T16:35:45.097", "Id": "1855825", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "9", "Body": "<p>Thomas's answer is correct, but I'd also like to suggest you not waste your time by \"designing an exception hierarchy\". Designing class hierarchies is a notably bad idea, particularly when you could simply derive a couple (and no more than that) of new exception types from the C++ Standard exception classes. </p>\n", "LastActivityDate": "2009-12-06T16:35:45.097"}, "1857437": {"ParentId": "1855773", "CommentCount": "0", "Body": "<p>I'd say to not use any of the built in C++ exception code. If you must have exceptions, create your own from scratch. That's the only way to be sure they will behave similar let alone be implemented in a similar manner, and to be blunt the implementation of exceptions in C++ is incompetent.</p>\n", "OwnerUserId": "204739", "PostTypeId": "2", "Id": "1857437", "Score": "-3", "CreationDate": "2009-12-07T02:20:39.320", "LastActivityDate": "2009-12-07T02:20:39.320"}, "1855773": {"CommentCount": "2", "CreationDate": "2009-12-06T16:08:38.940", "PostTypeId": "1", "AcceptedAnswerId": "1855981", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-27T14:10:58.850", "LastEditDate": "2017-05-23T11:45:41.727", "ViewCount": "1950", "FavoriteCount": "1", "Title": "Avoid slicing of exception types (C++)", "Id": "1855773", "Score": "5", "Body": "<p>I am designing an exception hierarchy in C++ for my library. The \"hierarchy\" is 4 classes derived from std::runtime_error. I would like to avoid the <a href=\"https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c\">slicing problem</a> for the exception classes so made the copy constructors protected. But apparently gcc requires to call the copy constructor when throwing instances of them, so complains about the protected copy constructors. Visual C++ 8.0 compiles the same code fine. Are there any portable way to defuse the slicing problem for exception classes? Does the standard say anything about whether an implementation could/should require copy constructor of a class which is to be thrown?</p>\n", "Tags": "<c++><exception><gcc><derived><object-slicing>", "OwnerUserId": "73248", "AnswerCount": "5"}, "1855981": {"ParentId": "1855773", "LastEditDate": "2009-12-07T01:00:16.940", "CommentCount": "1", "CreationDate": "2009-12-06T17:36:47.890", "OwnerUserId": "41747", "LastEditorUserId": "41747", "PostTypeId": "2", "Id": "1855981", "Score": "6", "Body": "<p>I would steer clear of designing an exception hierarchy distinct to your library.  Use the <code>std::exception</code> hierarchy as much as possible and <em>always</em> derive your exceptions from something within that hierarchy.  You might want to read the <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html\" rel=\"noreferrer\">exceptions portion of Marshall Cline's C++ FAQ</a> - read <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.6\" rel=\"noreferrer\">FAQ 17.6</a>, <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.9\" rel=\"noreferrer\">17.9</a>, <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.10\" rel=\"noreferrer\">17.10</a>, and <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.12\" rel=\"noreferrer\">17.12</a> in particular.</p>\n<p>As for <em>\"forcing users to catch by reference\"</em>, I don't know of a good way of doing it.  The only way that I have come up with in an hour or so of playing (it is Sunday afternoon) is based on <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.10\" rel=\"noreferrer\"><em>polymorphic throwing</em></a>:</p>\n<pre><code>class foo_exception {\npublic:\n    explicit foo_exception(std::string msg_): m_msg(msg_) {}\n    virtual ~foo_exception() {}\n    virtual void raise() { throw *this; }\n    virtual std::string const&amp; msg() const { return m_msg; }\nprotected:\n    foo_exception(foo_exception const&amp; other): m_msg(other.m_msg) {}\nprivate:\n    std::string m_msg;\n};\n\nclass bar_exception: public foo_exception {\npublic:\n    explicit bar_exception(std::string msg_):\n        foo_exception(msg_), m_error_number(errno) {}\n    virtual void raise() { throw *this; }\n    int error_number() const { return m_error_number; }\nprotected:\n    bar_exception(bar_exception const&amp; other):\n        foo_exception(other), m_error_number(other.m_error_number) {}\nprivate:\n    int m_error_number;\n};\n</code></pre>\n<p>The idea is to make the copy constructor protected and force users to call <code>Class(args).raise()</code> instead of <code>throw Class(args)</code>.  This lets you throw a polymorphicly bound exception that your users can only catch by reference.  Any attempt to catch by value <em>should</em> be greeted with a nice compiler warning.  Something like:</p>\n<blockquote>\n<p id=\"so_1855773_1855981_0\">foo.cpp:59: error: \u2018bar_exception::bar_exception(const bar_exception&amp;)\u2019 is protected</p>\n<p id=\"so_1855773_1855981_1\">foo.cpp:103: error: within this context</p>\n</blockquote>\n<p>Of course this all comes at a price since you can no longer use <code>throw</code> explicitly or you will be greeted with a similar compiler warning:</p>\n<blockquote>\n<p id=\"so_1855773_1855981_2\">foo.cpp: In function \u2018void h()\u2019:</p>\n<p id=\"so_1855773_1855981_3\">foo.cpp:31: error: \u2018foo_exception::foo_exception(const foo_exception&amp;)\u2019 is protected</p>\n<p id=\"so_1855773_1855981_4\">foo.cpp:93: error: within this context</p>\n<p id=\"so_1855773_1855981_5\">foo.cpp:31: error: \u2018foo_exception::foo_exception(const foo_exception&amp;)\u2019 is protected</p>\n<p id=\"so_1855773_1855981_6\">foo.cpp:93: error: within this context</p>\n</blockquote>\n<p>Overall, I would rely on coding standards and documentation stating the you should always catch by reference.  Make sure that your library catches exceptions that it handles by reference and throw fresh objects (e.g., <code>throw Class(constructorArgs)</code> or <code>throw;</code>).  I would expect other C++ programmers to have the same knowledge - but add a note to any documentation just to be sure.</p>\n", "LastActivityDate": "2009-12-07T01:00:16.940"}, "1855775": {"ParentId": "1855773", "LastEditDate": "2009-12-06T16:32:02.187", "CommentCount": "4", "CreationDate": "2009-12-06T16:10:22.910", "OwnerUserId": "14637", "LastEditorUserId": "14637", "PostTypeId": "2", "Id": "1855775", "Score": "15", "Body": "<p>Your exception needs to have a public copy constructor. The compiler has to be able to copy it around for exception handling to work.</p>\n<p>The solution to your problem is to always catch by reference instead:</p>\n<pre><code>try {\n    // some code...\n    throw MyException(\"lp0 is on fire!\");\n} catch (MyException const &amp;ex) {\n    // handle exception\n}\n</code></pre>\n<p>(<code>const</code>-ness is optional, but I always put it in because there's rarely a need to modify the exception object.)</p>\n", "LastActivityDate": "2009-12-06T16:32:02.187"}, "bq_ids": {"n4140": {"so_1855773_27172624_0": {"section_id": 3336, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_1855773_27172624_0": {"section_id": 3206, "quality": 1.0, "length": 23}}, "n4659": {"so_1855773_27172624_0": {"section_id": 7672, "quality": 0.5652173913043478, "length": 13}}}, "27172624": {"CommentCount": "1", "CreationDate": "2014-11-27T14:10:05.650", "CommunityOwnedDate": "2014-11-27T14:10:05.650", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-27T14:10:05.650", "ParentId": "1855773", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:08:47.433", "Id": "27172624", "Score": "0", "Body": "<p>The two portable ways I have found to stop clients of my library from catching exceptions incorrectly by value are</p>\n<ol>\n<li>Throw exceptions from inside <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.10\" rel=\"nofollow noreferrer\">virtual raise</a> methods of the exception classes, and make copy constructors protected. (Thanks D.Shawley)</li>\n<li>Throw derived exceptions from the library and publish exception base classes for clients to catch. The base classes could have protected copy constructors, which only allows the good way of catching them. (mentioned <a href=\"https://stackoverflow.com/questions/1095225/exception-slicing-is-this-due-to-generated-copy-constructor\">here</a> for a simmilar question)</li>\n</ol>\n<p>The C++ standard does state that copy constructor needs to be accessible at the point of throw. Visual C++ 8.0 in my configuration violated this part of the standard by not enforcing the presence of the copy constructor. In section 15.1.3:</p>\n<blockquote>\n<p id=\"so_1855773_27172624_0\">A throw-expression initializes a temporary object, the type of which is determined by removing any top-level cv-qualifiers from the static type of the operand of throw and adjusting the type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d, respectively.</p>\n<p id=\"so_1855773_27172624_1\">If the use of the temporary object can be eliminated without changing the meaning of the program except for the execution of constructors and destructors associated with the use of the temporary object (12.2), then the exception in the handler can be initialized directly with the argument of the throw expression. When the thrown object is a class object, and the copy constructor used to initialize the temporary copy is not accessible, the program is ill-formed (even when the temporary object could otherwise be eliminated)</p>\n</blockquote>\n<p><sup>This answer was posted by OP into the question, I removed it from the question and posted as a separate answer.</sup></p>\n", "OwnerUserId": "1816580"}});