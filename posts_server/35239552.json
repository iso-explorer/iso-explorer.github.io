post_cb({"bq_ids": {"n4140": {"so_35239552_35253265_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 456}}, "n3337": {"so_35239552_35253265_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 447}}, "n4659": {"so_35239552_35253265_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 479}}}, "35239552": {"ViewCount": "255", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/move_constructor\" rel=\"nofollow noreferrer\">cppreference</a> and <a href=\"https://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap\">this answer</a>, C++ should <em>not</em> automatically generate a move constructor if there is a user declared destructor. Checking this in practice with Clang, however, I see an auto-generated move constructor. The following code prints \"is_move_constructible: 1\":</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct TestClass\n{\n  ~TestClass()\n  {}\n};\n\nint main( int argc, char** argv )\n{\n  std::cout &lt;&lt; \"is_move_constructible: \" &lt;&lt; std::is_move_constructible&lt;TestClass&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Am I misunderstanding \"there is no user-declared destructor\" or std::is_move_constructible? I'm compiling with '-std=c++14' and Apple LLVM version 7.0.2 (clang-700.1.81).</p>\n", "AcceptedAnswerId": "35239696", "Title": "C++ Auto Generates Move Constructor With User Declared Destructor?", "CreationDate": "2016-02-06T09:44:56.340", "Id": "35239552", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:45:13.693", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-07T21:43:07.937", "Score": "5", "OwnerUserId": "1599766", "Tags": "<c++><destructor><c++14><move-constructor>", "AnswerCount": "2"}, "35253265": {"Id": "35253265", "PostTypeId": "2", "Body": "<p>For C++11 code, the accepted answer by @Alper is fine. But to make your code future-proof, note that as of Clang 3.7 (no idea which Apple version that corresponds to, sure you can find out), using <code>-std=c++1z -Wdeprecated</code> will generate the following</p>\n<pre><code>warning: definition of implicit copy constructor for 'TestClass' is deprecated because it has a user-declared destructor [-Wdeprecated]\n  ~TestClass()\n  ^\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d0d67f909a52fbaf\" rel=\"nofollow\"><strong>Live Example</strong></a></p>\n<p>The relevant part of the draft C++1z Standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf\" rel=\"nofollow\"><strong>N4567</strong></a> is</p>\n<blockquote>\n<p id=\"so_35239552_35253265_0\"><strong>12.8 Copying and moving class objects [class.copy]</strong> </p>\n<p id=\"so_35239552_35253265_1\">7 If the class definition does not explicitly declare a copy constructor, a\n  non-explicit one is declared implicitly. If the class definition\n  declares a move constructor or move assignment operator, the\n  implicitly declared copy constructor is defined as deleted; otherwise,\n  it is defined as defaulted (8.4). <strong>The latter case is deprecated if the\n  class has</strong> a user-declared copy assignment operator or <strong>a user-declared\n  destructor</strong>.</p>\n</blockquote>\n<p>Deprecated means that a future Standard may stop generating an implicit copy constructor in case of a user-declared destructor. It's best practice to change your code <strong>today</strong> to not rely on deprecated behavior (i.e. in this case, making the copy-behavior of your class explicit).</p>\n", "LastActivityDate": "2016-02-07T12:08:18.017", "CommentCount": "0", "CreationDate": "2016-02-07T12:08:18.017", "ParentId": "35239552", "Score": "2", "OwnerUserId": "819272"}, "35239696": {"Id": "35239696", "PostTypeId": "2", "Body": "<p>Types without a move constructor, but with a copy constructor that accepts <code>const T&amp;</code> arguments, satisfy <code>std::is_move_constructible</code> and implicitly-declared copy constructor has the form <code>T::T(const T&amp;)</code>.</p>\n<p>If implicitly-declared copy constructor is deleted, <code>std::is_move_constructible</code> is not satisfied as below.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct TestClass\n{\n  ~TestClass() {}\n  TestClass(const TestClass&amp;) = delete;\n};\n\nint main( int argc, char** argv )\n{\n  std::cout &lt;&lt; \"is_move_constructible: \" &lt;&lt; std::is_move_constructible&lt;TestClass&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2016-02-06T10:01:23.897", "CommentCount": "0", "CreationDate": "2016-02-06T10:01:23.897", "ParentId": "35239552", "Score": "8", "OwnerUserId": "2328763"}});