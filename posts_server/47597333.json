post_cb({"47598075": {"ParentId": "47597333", "CommentCount": "3", "Body": "<p>From <a href=\"http://eel.is/c++draft/expr.reinterpret.cast\" rel=\"nofollow noreferrer\">[expr.reinterpret.cast]</a></p>\n<blockquote>\n<p id=\"so_47597333_47598075_0\">A function pointer can be explicitly converted to a function pointer of a different type. [...] Except that converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are function types) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.</p>\n</blockquote>\n<p>It is unspecified whether casted function pointers compare equally.</p>\n<blockquote>\n<p id=\"so_47597333_47598075_1\">A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is implementation-defined.</p>\n</blockquote>\n<p>Hence it is a natural choice to convert to <code>std::intptr_t</code> or some other suitable type, provided the implementation doesn't use some wacky conversion.</p>\n<p>From <a href=\"https://gcc.gnu.org/onlinedocs/gcc-5.4.0/gcc/Arrays-and-pointers-implementation.html#Arrays-and-pointers-implementation\" rel=\"nofollow noreferrer\">GCC's documentation</a></p>\n<blockquote>\n<p id=\"so_47597333_47598075_2\">A cast from pointer to integer discards most-significant bits if the pointer representation is larger than the integer type, sign-extends<sup>1</sup> if the pointer representation is smaller than the integer type, otherwise the bits are unchanged.</p>\n</blockquote>\n<p>AKA the sane conversion. Which is probably what you'll find in most cases I'd bet.</p>\n<p><sub>[1] Future versions of GCC may zero-extend, or use a target-defined ptr_extend pattern. Do not rely on sign extension.</sub></p>\n", "OwnerUserId": "4832499", "PostTypeId": "2", "Id": "47598075", "Score": "0", "CreationDate": "2017-12-01T17:01:56.403", "LastActivityDate": "2017-12-01T17:01:56.403"}, "47597333": {"CommentCount": "9", "ViewCount": "70", "CreationDate": "2017-12-01T16:17:19.973", "LastActivityDate": "2017-12-01T17:01:56.403", "Title": "Is it well defined to use a function pointer that's been cast to another type in a comparison?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "47597333", "Score": "3", "Body": "<p>Function pointers of dissimilar types can't be directly compared :</p>\n<pre><code>#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n\nint foo() { return 0; }\nvoid bar(int) {}\n\nint main()\n{\n    // Doesn't compile, the comparison is not allowed\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (&amp;foo == &amp;bar) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>However, if one function pointer is cast to the type of the other function pointer, is it defined behavior to compare the result of that cast with the other function pointer?</p>\n<pre><code>#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n\nint foo() { return 0; }\nvoid bar(int) {}\n\nint main()\n{\n    auto cast_ptr = reinterpret_cast&lt;decltype(&amp;bar)&gt;(&amp;foo);\n\n    // Printed \"false\" when I tried it, but is this guaranteed?\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (cast_ptr == &amp;bar) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>How about if both operators have been cast to a common but different type?</p>\n<pre><code>#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n\nint foo() { return 0; }\nvoid bar(int) {}\n\nint main()\n{\n    using cast_type = void(*)();\n    auto cast_foo = reinterpret_cast&lt;cast_type&gt;(&amp;foo);\n    auto cast_bar = reinterpret_cast&lt;cast_type&gt;(&amp;bar);\n\n    // Also printed \"false\" when I tried it, but is this guaranteed?\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (cast_foo == cast_bar) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I understand that function pointers compare equal if and only if they both point to <code>nullptr</code> or to the same function. What's not clear to me is rather or not using a function pointer that's been cast to another function pointer type in a comparison is allowed.</p>\n<p><strong>Context</strong></p>\n<p>I'm maintaining a c++ library with a c compatible API. The library logs every call made to API functions. It's become useful to selectively disable this logging for certain functions at run time. The best current proposal in terms of usability is to supply a new API function which takes as an argument a pointer to the API function whose logging should be suppressed. Since the API functions have different arguments, these pointers would have different types and would need to be cast to a common function pointer type such as <code>void(*)()</code>. Then, before logging an API function call, a container of <code>void(*)()</code> would be searched for the address of the called function to know rather or not to log that call.</p>\n", "Tags": "<c++><casting><function-pointers>", "OwnerUserId": "7359094", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47597333_47598075_1": {"section_id": 6043, "quality": 0.8461538461538461, "length": 11}, "so_47597333_47598075_0": {"section_id": 6045, "quality": 1.0, "length": 32}}, "n3337": {"so_47597333_47598075_1": {"section_id": 5811, "quality": 0.8461538461538461, "length": 11}, "so_47597333_47598075_0": {"section_id": 5813, "quality": 1.0, "length": 32}}, "n4659": {"so_47597333_47598075_1": {"section_id": 7542, "quality": 0.8461538461538461, "length": 11}, "so_47597333_47598075_0": {"section_id": 7544, "quality": 1.0, "length": 32}}}});