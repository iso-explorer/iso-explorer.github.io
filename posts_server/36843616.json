post_cb({"36843616": {"CommentCount": "7", "ViewCount": "237", "PostTypeId": "1", "OwnerDisplayName": "user4832129", "CreationDate": "2016-04-25T14:34:25.567", "LastActivityDate": "2016-04-25T18:03:06.930", "Title": "Why std::(i)ostream treat signed / unsigned char as a text and not an integer?", "LastEditorDisplayName": "user4832129", "LastEditDate": "2016-04-25T18:03:06.930", "Id": "36843616", "Score": "11", "Body": "<p>This code doesn't do what it's supposed to do:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nint main()\n{\n    uint8_t small_integer;\n    std::cin &gt;&gt; small_integer;\n    std::cout &lt;&lt; small_integer;\n}\n</code></pre>\n<p>The reason is simple: <code>uint8_t</code> is a typedef for <code>unsigned char</code> and streams treat this type as a text:<br>\n<em>Visual C++ 2015 implementation</em></br></p>\n<pre><code>template&lt;class _Traits&gt; inline\n    basic_istream&lt;char, _Traits&gt;&amp; operator&gt;&gt;(\n        basic_istream&lt;char, _Traits&gt;&amp; _Istr, unsigned char&amp; _Ch)\n    {    // extract an unsigned char\n    return (_Istr &gt;&gt; (char&amp;)_Ch);\n    }\n</code></pre>\n<p>And a similar code with cast to <code>char</code> for <code>operator &lt;&lt;</code>.  </p>\n<p>My questions:</p>\n<ol>\n<li>Is this behavior (streaming operators treating signed / unsigned char as character type and not an integer) required by the standard?\nIf it is then:\n\n<ol start=\"2\">\n<li>What is the rationale behind such counterintuitive semantics?</li>\n<li>Should this be considered a defect, were there proposals to change this semantics?</li>\n</ol></li>\n</ol>\n<p>I should probably add a little explanation why I consider it counterintuitive. \nAlthough the type name contains the word char, the <code>signed</code> or <code>unsigned</code> part specify particular integer semantic and those types are generally used as byte sized integers. Even the standard defines <code>int8_t</code> / <code>uint8_t</code> through them.</p>\n<p><strong>UPD:</strong> The question is about behavior of streaming operator overloads for <code>unsigned char</code> and <code>signed char</code>.</p>\n", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "36847188": {"ParentId": "36843616", "CommentCount": "0", "Body": "<p>The standard (n3797) says the following:</p>\n<blockquote>\n<p id=\"so_36843616_36847188_0\"><em>27.7.2.2.3 basic_istream::operator&gt;&gt;</em> </p>\n</blockquote>\n<pre><code>template&lt;class charT, class traits&gt; \nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp; in, charT&amp; c);\n\ntemplate&lt;class traits&gt; \nbasic_istream&lt;char,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char,traits&gt;&amp; in, unsigned char&amp; c);\n\ntemplate&lt;class traits&gt; \nbasic_istream&lt;char,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char,traits&gt;&amp; in, signed char&amp; c);\n</code></pre>\n<blockquote>\n<p id=\"so_36843616_36847188_1\">12 E\ufb00ects: Behaves like a formatted input member (as described in 27.7.2.2.1) of in. After a sentry object is constructed <strong>a character is extracted</strong> from in, if one is available, and stored in c. Otherwise, the function calls in.setstate(failbit).  </p>\n<p id=\"so_36843616_36847188_2\"><em>27.7.3.6.4 Character inserter function templates</em> </p>\n</blockquote>\n<pre><code>// specialization \ntemplate&lt;class traits&gt; \nbasic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, char c); \n\n// signed and unsigned \ntemplate&lt;class traits&gt; \nbasic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, signed char c); \n\ntemplate&lt;class traits&gt; \nbasic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, unsigned char c); \n</code></pre>\n<blockquote>\n<p id=\"so_36843616_36847188_3\">1 E\ufb00ects: Behaves as a formatted output function ( 27.7.3.6.1) of out. Constructs a character sequence seq. If c has type char and the character type of the stream is not char, then <strong>seq consists of out.widen(c); otherwise seq consists of c</strong>. Determines padding for seq as described in 27.7.3.6.1. Inserts seq into out. Calls os.width(0). </p>\n</blockquote>\n<p>So the answer to the first question: yes, the standard requires that <code>operator &gt;&gt;</code> and <code>operator &lt;&lt;</code> behave exactly the same for <code>char</code>, <code>unsigned char</code> and <code>signed char</code>, that is they read / write a single character, not an integer. Unfortunately, standard doesn't explain why. I hope someone will shed light on 2 and 3.</p>\n", "Id": "36847188", "PostTypeId": "2", "OwnerDisplayName": "user4832129", "Score": "3", "CreationDate": "2016-04-25T17:26:37.850", "LastActivityDate": "2016-04-25T17:26:37.850"}, "36847408": {"ParentId": "36843616", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote id=\"so_36843616_36847408_0\">\n<ol>\n<li>Is this behavior required by the standard? If it is then:</li>\n</ol>\n</blockquote>\n<p>You already answered this. Yes, the standard defines how iostreams should handle signed and unsigned char.</p>\n<blockquote id=\"so_36843616_36847408_1\">\n<ol start=\"2\">\n<li>What is the rationale behind such counterintuitive semantics?</li>\n</ol>\n</blockquote>\n<p>Because <code>signed char</code> and <code>unsigned char</code> are <em>character types</em>, so they are always treated as characters by the iostreams classes.</p>\n<p>The clue is in the name: <code>signed char</code> is a signed character type. <code>unsigned char</code> is an unsigned character type.  The other integral types have <code>int</code> in their name (even if it's sometimes optional, e.g. <code>short</code> and <code>long unsigned</code> are identical to <code>short int</code> and <code>long unsigned int</code> respectively).</p>\n<p>The standard doesn't need to say <em>why</em> this is true, because it's not a design document or a rationale for the history of C and C++, it's a specification.</p>\n<p>If you want a type that behaves like an integer with only 8 bits then you'll need to create your own (e.g. using an enumeration type or a struct that holds a value) and define the relevant operator overloads.</p>\n<blockquote id=\"so_36843616_36847408_2\">\n<ol start=\"3\">\n<li>Should this be considered a defect, were there proposals to change this semantics?</li>\n</ol>\n</blockquote>\n<p>No, I don't think so. They have always been character types and it would break too much code to change that.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2016-04-25T17:44:44.423", "Id": "36847408", "Score": "1", "CreationDate": "2016-04-25T17:38:26.403", "LastActivityDate": "2016-04-25T17:44:44.423"}, "bq_ids": {"n4140": {"so_36843616_36847188_1": {"section_id": 2203, "quality": 0.8571428571428571, "length": 18}, "so_36843616_36847188_3": {"section_id": 2303, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_36843616_36847188_1": {"section_id": 2191, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_36843616_36847188_1": {"section_id": 2476, "quality": 0.8571428571428571, "length": 18}, "so_36843616_36847188_3": {"section_id": 2577, "quality": 0.9142857142857143, "length": 32}}}});