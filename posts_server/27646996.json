post_cb({"27649357": {"Id": "27649357", "PostTypeId": "2", "Body": "<p>To solve this problem I created a <code>to_raw_pointer</code> function which happens to work on any \"fancy pointer\" which implements <code>operator-&gt;()</code>.  You can find it in the <a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/include/memory\" rel=\"nofollow noreferrer\">libc++ implementation</a>.</p>\n<p>Here it is:</p>\n<pre><code>template &lt;class _Tp&gt;\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate &lt;class _Pointer&gt;\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits&lt;_Pointer&gt;::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator-&gt;());\n}\n</code></pre>\n<p>It works by calling the <code>operator-&gt;()</code> in an unconventional way.  This operator <em>must</em> either call another <code>operator-&gt;()</code>, or return a real pointer.  The overload for real pointers breaks the recursion with an identity function.  So this would be used like:</p>\n<pre><code>this-&gt;_Getal().construct(__to_raw_pointer(this-&gt;_Mylast),\n            _STD forward&lt;value_type&gt;(this-&gt;_Myfirst[_Idx]));\n</code></pre>\n<p><code>construct</code> is specified to take a real pointer, not a fancy pointer.  And there is no implicit conversion specified from fancy pointers to real pointers.  The container must use something such as <code>to_raw_pointer</code>, or <code>addressof</code>.</p>\n<p>The container is also required to call <code>construct</code> via <code>allocator_traits</code>, instead of calling it directly on the stored allocator as shown.  This is to allow <code>construct</code> to be \"defaulted\" by <code>allocator_traits</code>, as opposed to requiring the allocator to implement <code>construct</code>.</p>\n<p>Currently both <code>operator*()</code> and <code>operator-&gt;()</code> generally require the fancy pointer to be non-null prior to calling that operator on it.  However I am anticipating that this requirement will be relaxed for <code>operator-&gt;()</code> in the future.</p>\n<p><strong>Update</strong></p>\n<p>I was in a bit of a hurry when I wrote the above.  Now that I have the time, I was going to include the complete requirements on the <code>allocator::pointer</code> types.  However on re-reading the question I see that <a href=\"https://stackoverflow.com/users/627327/maxym\">Maxym</a> has already done a good job of that in the question, so I won't repeat them here.</p>\n<p>The one thing that is in the std, but is not completely obvious, is the implicit and explicit conversions among the four pointer types: <code>pointer</code>, <code>const_pointer</code>, <code>void_pointer</code>, and <code>const_void_pointer</code>:</p>\n<pre><code>implicit allocator pointer conversions:\n+--------------------------------------+\n| pointer      --&gt;  const_pointer      |\n|    |    \\               |            |\n|    |      ---------     |            |\n|   \\|/             _\\|  \\|/           |\n| void_pointer --&gt;  const_void_pointer |\n+--------------------------------------+\n\n\nexplicit allocator pointer conversions:\n+--------------------------------------+\n| pointer           const_pointer      |\n|   /|\\                  /|\\           |\n|    |                    |            |\n|    |                    |            |\n| void_pointer      const_void_pointer |\n+--------------------------------------+\n</code></pre>\n<p>That is, you can implicitly convert from non-<code>const</code> to <code>const</code>, and from non-<code>void</code> to <code>void</code>, and you can <em>explicitly</em> convert from <code>void</code> to non-<code>void</code>.  But there is no way for a container to <code>const_cast</code> (cast away <code>const</code>-ness) from an <code>allocator::const_pointer</code> or <code>allocator::const_void_pointer</code>.  Once the container goes <code>const</code>, it can never get back.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-27T14:36:29.017", "Score": "13", "CreationDate": "2014-12-25T17:28:18.690", "ParentId": "27646996", "CommentCount": "7", "OwnerUserId": "576911", "LastEditDate": "2017-05-23T10:30:40.063"}, "bq_ids": {"n4140": {"so_27646996_27646996_1": {"length": 34, "quality": 0.8717948717948718, "section_id": 6292}, "so_27646996_27646996_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6282}}, "n3337": {"so_27646996_27646996_1": {"length": 29, "quality": 0.7435897435897436, "section_id": 6052}, "so_27646996_27646996_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6042}}, "n4659": {"so_27646996_27646996_1": {"length": 33, "quality": 0.8461538461538461, "section_id": 7800}, "so_27646996_27646996_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 7789}}}, "27646996": {"ViewCount": "1189", "Body": "<p>I tried to create a custom memory allocator which uses a smart pointer. I do not post the code because it's too big and doesn't add much of information. Then I tested it with a <code>std::vector</code>. It works perfectly well on Xcode. But when I tried to build the same code in Visual Studio 12 (2013), the build failed with the following error:</p>\n<blockquote>\n<p id=\"so_27646996_27646996_0\">...vector(873): error C2660: '<code>std::_Wrap_alloc&lt; my_allocator&lt; int &gt; &gt;::construct</code>' : function does not take 2 arguments</p>\n</blockquote>\n<p>the problem is in push_back method:</p>\n<pre><code>void push_back(value_type&amp;&amp; _Val)\n    {\n    ....\n        this-&gt;_Getal().construct(this-&gt;_Mylast,\n            _STD forward&lt;value_type&gt;(this-&gt;_Myfirst[_Idx]));\n    ....\n    }\n</code></pre>\n<p>The error message is a bit confusing. Real problem is that <code>this-&gt;_Mylast</code> is of type <code>my_allocator&lt; int &gt;::pointer</code>, which is a smart pointer, and construct method expects <code>int*</code>.</p>\n<p>So, the question is simple: what are the requirements to pointer types used in a custom memory allocator? Should <code>X::pointer</code> be convertible to a raw pointer? If yes, it makes them pretty useless.</p>\n<p>Actually I would expect that line of code to look like:</p>\n<pre><code>this-&gt;_Getal().construct(addressof(*(this-&gt;_Mylast)),\n            _STD forward&lt;value_type&gt;(this-&gt;_Myfirst[_Idx]));\n</code></pre>\n<p>Let's try to find an answer in C++ standard, which says:</p>\n<blockquote>\n<p id=\"so_27646996_27646996_1\">[17.6.3.5-5] An allocator type X shall satisfy the requirements of CopyConstructible (17.6.3.1). The <code>X::pointer</code>, <code>X::const_pointer</code>, <code>X::void_pointer</code>, and <code>X::const_void_pointer</code> types shall satisfy the requirements of NullablePointer (17.6.3.3). No constructor, comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception. <code>X::pointer</code> and <code>X::const_pointer</code> shall also satisfy the requirements for a random access iterator (24.2)</p>\n</blockquote>\n<p>If we take a look at NullablePointer reqs, they add few other requirements:</p>\n<blockquote>\n<p id=\"so_27646996_27646996_2\">[17.6.3.3] A NullablePointer type is a pointer-like type that supports null values. A type P meets the requirements of NullablePointer if:<br>\n  (1.1) \u2014 P satisfies the requirements of EqualityComparable, DefaultConstructible, CopyConstructible, CopyAssignable, and Destructible...</br></p>\n</blockquote>\n<p>If I check random access iterator requirements, I also don't find any explicit mentioning of its casting to a raw pointer. But in few places the approach with <code>addressof</code> is used (e. g. 24.2.1-5).</p>\n<p>Also, it's not the only place in Microsoft's <code>std::vector</code> implementation where <code>X::pointer</code> and raw pointer are assumed to be equal. I'm wondering, what do I miss?</p>\n<p>EDIT: I'll add a piece of my_allocator deffinition here:</p>\n<pre><code>class my_allocator\n{\npublic:\n\ntypedef std::size_t          size_type;\ntypedef std::ptrdiff_t       difference_type;\ntypedef my_ptr&lt;T&gt;            pointer;\ntypedef my_ptr&lt;const T&gt;      const_pointer;\ntypedef T&amp;                   reference;\ntypedef const T&amp;             const_reference;\ntypedef T                    value_type;\ntypedef my_ptr&lt;void&gt;         void_pointer;\ntypedef my_ptr&lt;const void&gt;   const_void_pointer;\n\n&lt;constructors&gt;\n\npointer allocate(size_type n, const_void_pointer = nullptr);\nvoid deallocate(const pointer&amp; ptr, size_type elements_num);\n};\n</code></pre>\n", "AcceptedAnswerId": "27649357", "Title": "Memory allocator with custom pointer type", "CreationDate": "2014-12-25T11:59:26.380", "Id": "27646996", "CommentCount": "6", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2015-05-27T12:33:26.540", "LastEditorUserId": "36565", "LastActivityDate": "2015-05-27T14:36:29.017", "Score": "12", "OwnerUserId": "627327", "Tags": "<c++><pointers><c++11><memory-management><standard-library>", "AnswerCount": "1"}});