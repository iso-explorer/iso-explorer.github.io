post_cb({"31067961": {"Id": "31067961", "PostTypeId": "2", "Body": "<p>According to the standard, if these operations in two threads aren't synchronized, the behavior is undefined.</p>\n<p>C++11 draft N3337, </p>\n<p>[intro.multithread]/4:</p>\n<blockquote>\n<p id=\"so_31067653_31067961_0\">Two expression evaluations <em>conflict</em> if one of them modifies a memory location (1.7) and the other one\n  accesses or modifies the same memory location.</p>\n</blockquote>\n<p>[intro.multithread]/21:</p>\n<blockquote>\n<p id=\"so_31067653_31067961_1\">The execution of a program contains a <em>data race</em> if it contains two conflicting actions in different threads,\n  at least one of which is not atomic, and neither happens before the other. Any such data race results in\n  undefined behavior.</p>\n</blockquote>\n<p>The corresponding quote from C++14 is essentially the same.</p>\n<hr>\n<p>As for the execution order of <code>p = new Class;</code>, it's like in your Example 2, because first <code>new Class</code> is evaluated, and then assignment happens (provided the constructor of <code>Class</code> or <code>operator new</code> didn't throw an exception).</p>\n<p>[expr.ass]/1:</p>\n<blockquote>\n<p id=\"so_31067653_31067961_2\">In all cases, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "3959454", "LastActivityDate": "2015-06-26T08:22:52.417", "Score": "6", "CreationDate": "2015-06-26T07:56:52.827", "ParentId": "31067653", "CommentCount": "2", "OwnerUserId": "3959454", "LastEditDate": "2015-06-26T08:22:52.417"}, "bq_ids": {"n4140": {"so_31067653_31067961_2": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_31067653_31067961_0": {"length": 15, "quality": 0.9375, "section_id": 5817}, "so_31067653_31067961_1": {"length": 20, "quality": 0.8, "section_id": 5834}}, "n3337": {"so_31067653_31067961_2": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_31067653_31067961_0": {"length": 15, "quality": 0.9375, "section_id": 5588}, "so_31067653_31067961_1": {"length": 22, "quality": 0.88, "section_id": 5605}}, "n4659": {"so_31067653_31067961_2": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_31067653_31067961_0": {"length": 14, "quality": 0.875, "section_id": 7278}, "so_31067653_31067961_1": {"length": 20, "quality": 0.8, "section_id": 7296}}}, "31068139": {"Id": "31068139", "PostTypeId": "2", "Body": "<p>No, the standard does not guarantee anything like this. </p>\n<p>To fix it you need to have a memory barrier between construction of your object and assigning the pointer so that there is inter-thread happens-before relationship between them:</p>\n<pre><code>Class* tmp = new Class();\n// you need a memory barrier here\np = tmp;\n</code></pre>\n<p>In c++11 you use <code>std::atomic</code> to introduce memory barriers:</p>\n<pre><code>std::atomic&lt;Class*&gt; p;\n</code></pre>\n<p>And in this case it is better to use <code>store()</code> rather than assignment:</p>\n<pre><code>p.store(tmp, std::memory_order_release);\n</code></pre>\n", "LastEditorUserId": "4999494", "LastActivityDate": "2015-06-26T11:12:16.413", "Score": "0", "CreationDate": "2015-06-26T08:09:46.783", "ParentId": "31067653", "CommentCount": "5", "OwnerUserId": "4999494", "LastEditDate": "2015-06-26T11:12:16.413"}, "31067653": {"ViewCount": "189", "Body": "<p>Consider the following code:</p>\n<pre><code>Class* p = nullptr; //global var\n</code></pre>\n<p>This code executed by thread 1:</p>\n<pre><code>p = new Class;\n</code></pre>\n<p>This code executed on thread 2:</p>\n<pre><code>if (p != nullptr) ...; // does the standard gurantee that the pointer will be assigned only after object is constructed ?\n</code></pre>\n<p>My question is does the standard enforce when <code>p</code> will be assigned to point to allocated memory ?\nExample 1:</p>\n<ul>\n<li>new expression call operator new</li>\n<li><code>p</code> is assigned to point to newly allocated memory</li>\n<li><code>Class</code>'s c`tor is invoked and allocated memory is passed to it</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>new expression call operator new</li>\n<li><code>Class</code>'s c`tor is invoked and allocated memory is passed to it</li>\n<li><code>p</code> is assigned to point to newly allocated memory</li>\n</ul>\n", "Title": "new expression evaluation order (pointer assignment)", "CreationDate": "2015-06-26T07:39:08.330", "LastActivityDate": "2015-06-26T11:12:16.413", "CommentCount": "6", "LastEditDate": "2015-06-26T07:55:36.787", "PostTypeId": "1", "LastEditorUserId": "4745527", "Id": "31067653", "Score": "3", "OwnerUserId": "4347209", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "2"}});