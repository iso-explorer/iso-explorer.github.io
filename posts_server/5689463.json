post_cb({"5690025": {"ParentId": "5689463", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Let's see (all references are to the FDIS):</p>\n<pre><code>struct B { }; \nstruct A { B b; }; \nint main() { \n  B const&amp; b = A().b; \n}\n</code></pre>\n<p>1) 5.2.3/2 says <code>A()</code> is a prvalue.</p>\n<p>2) 5.2.5/4 says that <code>A().b</code> is a prvalue because of point 1).</p>\n<p>3) 8.5.3/5 says that <code>B const&amp; b</code> <em>binds directly</em> to <code>A().b</code> without creating a temporary.</p>\n<p>4) 12.2/5 says that the lifetime of a temporary bound to a reference is extended.</p>\n<p>So it appears at least that GCC is wrong here.</p>\n<p>Whether Clang is correct or if this is UB depends on whether the subobject of a temporary is itself a temporary. I'm quite sure the answer should be affirmative, but the Standard seems silent about the matter. Should someone submit a DR?</p>\n<p><strike><strong>EDIT:</strong> As @6502 said, 3.7.5 indicates that the lifetime of a subobject is the lifetime of its complete object.</strike></p>\n", "OwnerUserId": "279597", "LastEditorUserId": "279597", "LastEditDate": "2011-04-16T22:32:50.867", "Id": "5690025", "Score": "0", "CreationDate": "2011-04-16T22:21:24.993", "LastActivityDate": "2011-04-16T22:32:50.867"}, "5689588": {"ParentId": "5689463", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>In 12.2 paragraph 5 of N3126=10-0116 it's said that:</p>\n<blockquote>\n<p id=\"so_5689463_5689588_0\">The second context [ in which temporaries are\n  destroyed at a different point than the end of\n  the full-expression ] is when a reference\n  is bound to a temporary. The temporary\n  to which the reference is bound or the\n  temporary that is the complete object\n  of a subobject to which the reference\n  is bound persists for the lifetime of the\n  reference except ...</p>\n</blockquote>\n<p>and then follows a list of four special cases (ctor-inizializers, reference parameters, returned value, new initializer).</p>\n<p>So (in this version) seems to me that clang is correct because you're binding the reference to a subobject of a temporary.</p>\n<h2>EDIT</h2>\n<p>Thinking to the base sub-object of an object this also seems to be the only reasonable behavior. The alternative would mean doing a slicing in:</p>\n<pre><code>Derived foo();\n...\nvoid bar()\n{\n    Base&amp; x = foo(); // not very different from foo().b;\n    ...\n}\n</code></pre>\n<p>Actually after making a little experiment seems indeed that g++ differentiates between a member sub-object and a base sub-object, but I don't understand where this differentiation is made in the standard. The following is the test program I used and where it's clearly visible the different handling of the two cases... (<code>B</code> is Base, <code>D</code> is Derived and <code>C</code> is composed).</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B\n{\n    B()\n    { std::cout &lt;&lt; \"B{\" &lt;&lt; this &lt;&lt; \"}::B()\\n\"; }\n\n    B(const B&amp; x)\n    { std::cout &lt;&lt; \"B{\" &lt;&lt; this &lt;&lt; \"}::B(const B&amp; \" &lt;&lt; &amp;x &lt;&lt; \")\\n\"; }\n\n    virtual ~B()\n    { std::cout &lt;&lt; \"B{\" &lt;&lt; this &lt;&lt; \"}::~B()\\n\"; }\n\n    virtual void doit() const\n    { std::cout &lt;&lt; \"B{\" &lt;&lt; this &lt;&lt; \"}::doit()\\n\"; }\n};\n\nstruct D : B\n{\n    D()\n    { std::cout &lt;&lt; \"D{\" &lt;&lt; this &lt;&lt; \"}::D()\\n\"; }\n\n    D(const D&amp; x)\n    { std::cout &lt;&lt; \"D{\" &lt;&lt; this &lt;&lt; \"}::D(const D&amp; \" &lt;&lt; &amp;x &lt;&lt; \")\\n\"; }\n\n    virtual ~D()\n    { std::cout &lt;&lt; \"D{\" &lt;&lt; this &lt;&lt; \"}::~D()\\n\"; }\n\n    virtual void doit() const\n    { std::cout &lt;&lt; \"D{\" &lt;&lt; this &lt;&lt; \"}::doit()\\n\"; }\n};\n\nstruct C\n{\n    B b;\n\n    C()\n    { std::cout &lt;&lt; \"C{\" &lt;&lt; this &lt;&lt; \"}::C()\\n\"; }\n\n    C(const C&amp; x)\n    { std::cout &lt;&lt; \"C{\" &lt;&lt; this &lt;&lt; \"}::C(const C&amp; \" &lt;&lt; &amp;x &lt;&lt; \")\\n\"; }\n\n    ~C()\n    { std::cout &lt;&lt; \"C{\" &lt;&lt; this &lt;&lt; \"}::~C()\\n\"; }\n};\n\nD foo()\n{\n    return D();\n}\n\nvoid bar()\n{\n    std::cout &lt;&lt; \"Before calling foo()\\n\";\n    const B&amp; b = foo();\n    std::cout &lt;&lt; \"After calling foo()\\n\";\n    b.doit();\n    std::cout &lt;&lt; \"After calling b.doit()\\n\";\n\n    const B&amp; b2 = C().b;\n    std::cout &lt;&lt; \"After binding to .b\\n\";\n    b2.doit();\n    std::cout &lt;&lt; \"After calling b2.doit()\\n\";\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"Before calling bar()\\n\";\n    bar();\n    std::cout &lt;&lt; \"After calling bar()\\n\";\n    return 0;\n}\n</code></pre>\n<p>The output I get with g++ (Ubuntu/Linaro 4.4.4-14ubuntu5) 4.4.5 is</p>\n<pre><code>Before calling bar()\nBefore calling foo()\nB{0xbf9f86ec}::B()\nD{0xbf9f86ec}::D()\nAfter calling foo()\nD{0xbf9f86ec}::doit()\nAfter calling b.doit()\nB{0xbf9f86e8}::B()\nC{0xbf9f86e8}::C()\nB{0xbf9f86e4}::B(const B&amp; 0xbf9f86e8)\nC{0xbf9f86e8}::~C()\nB{0xbf9f86e8}::~B()\nAfter binding to .b\nB{0xbf9f86e4}::doit()\nAfter calling b2.doit()\nB{0xbf9f86e4}::~B()\nD{0xbf9f86ec}::~D()\nB{0xbf9f86ec}::~B()\nAfter calling bar()\n</code></pre>\n<p>In my opinion this is either a bug in g++ or a bug in what the c++ standard mandates if this is really the expected behavior or a possible acceptable behavior (but I must tell that I didn't really think about it a lot, this is just a feeling that something is wrong with this differentiation).</p>\n", "OwnerUserId": "320726", "LastEditorUserId": "320726", "LastEditDate": "2015-02-11T23:10:09.563", "Id": "5689588", "Score": "11", "CreationDate": "2011-04-16T21:02:46.237", "LastActivityDate": "2015-02-11T23:10:09.563"}, "5689804": {"ParentId": "5689463", "CommentCount": "1", "Body": "<h2>Okay, I'm doing a 180 degrees on this</h2>\n<p>After refreshing my knowledge of the standard, I have to admit\nthat it is probably right to expect the <em>object referred to by <code>b</code></em> to remain alive (be extended) for the duration of scope in which the const&amp; was initialized. I found <a href=\"http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\" rel=\"nofollow\">GotW #88</a> a helpful source for this.</p>\n<p>I fail to see how <code>A().b</code> is structurally or semantically different from </p>\n<pre><code>string f() { return \"abc\"; } // ABC initializes return-value **TEMP**\n\nvoid g() {\nconst string&amp; s = f();  // initializes with reference to a temp\n  cout &lt;&lt; s &lt;&lt; endl;    // '*&amp;s' is extended per standard\n}\n</code></pre>\n<p>Sorry for any confusion I might have caused. I was a little out of my depth there.</p>\n", "OwnerUserId": "85371", "PostTypeId": "2", "Id": "5689804", "Score": "1", "CreationDate": "2011-04-16T21:41:09.380", "LastActivityDate": "2011-04-16T21:41:09.380"}, "5689463": {"CommentCount": "2", "ViewCount": "480", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-04-16T20:37:47.093", "LastActivityDate": "2015-02-11T23:10:09.563", "Title": "Does \"T const&t = C().a;\" lengthen the lifetime of \"a\"?", "FavoriteCount": "2", "LastEditDate": "2011-10-03T13:15:26.783", "Id": "5689463", "Score": "20", "Body": "<p>The following scenario is given, to be interpreted as C++0x code:</p>\n<pre><code>struct B { }; \nstruct A { B b; }; \nint main() { \n  B const&amp; b = A().b; \n  /* is the object still alive here? */\n}\n</code></pre>\n<p>Clang and GCC (trunk version as of 2011/02) behave differently: Clang lengthens the lifetime. GCC moves <code>B</code> to a new temporary object, and then binds the reference to that new temporary. </p>\n<p>I cannot find either behavior can be derived from the words of the Standard. The expression <code>A().b</code> is not a temporary (see 5.2.5). Can anyone please explain the following to me?</p>\n<ul>\n<li>Desired behavior (the intent of the committee)</li>\n<li>The behavior as you derive it from the FDIS</li>\n</ul>\n<p>Thanks!</p>\n", "Tags": "<c++><c++11><temporary><dot-operator>", "OwnerUserId": "34509", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_5689463_5689588_0": {"section_id": 382, "quality": 0.6785714285714286, "length": 19}, "so_5689463_5689686_0": {"section_id": 3321, "quality": 0.6363636363636364, "length": 7}, "so_5689463_5689686_2": {"section_id": 3321, "quality": 0.8387096774193549, "length": 26}}, "n3337": {"so_5689463_5689588_0": {"section_id": 373, "quality": 0.6785714285714286, "length": 19}, "so_5689463_5689686_2": {"section_id": 3191, "quality": 0.8387096774193549, "length": 26}}, "n4659": {"so_5689463_5689588_0": {"section_id": 397, "quality": 0.6428571428571429, "length": 18}, "so_5689463_5689686_0": {"section_id": 4087, "quality": 0.5454545454545454, "length": 6}, "so_5689463_5689686_2": {"section_id": 4087, "quality": 0.6451612903225806, "length": 20}}}, "5689686": {"ParentId": "5689463", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Temporary objects are distinguished by the circumstances of their creation. (\u00a712.2 \"Temporaries of class type are created in various contexts\u2026\")</p>\n<p>For temporaries created by a reference declarator, \u00a712.2 refers us to \u00a78.5. C++03 and C++11 differ greatly in \u00a78.5.3, but both clearly support your code.</p>\n<p>C++03 says that either</p>\n<blockquote>\n<p id=\"so_5689463_5689686_0\">\u2014 The reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within that object.</p>\n<p id=\"so_5689463_5689686_1\">\u2014 A temporary of type \u201ccv1 T2\u201d [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary. The reference is bound to the temporary or to a sub-object within the temporary.</p>\n</blockquote>\n<p>The discussion is entirely in terms of subobjects, not distinguishing base classes from members. So, if binding a reference to a member is disallowed, then so is binding a member to a base, which rules out ScopeGuard.</p>\n<p>C++11 is more verbose, but specifies</p>\n<blockquote>\n<p id=\"so_5689463_5689686_2\">\u2014 Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be\n  const), or the reference shall be an rvalue reference. \u2026 If the initializer expression \u2026 is an xvalue, class prvalue, array prvalue or function lvalue and \u201ccv1 T1\u201d is reference-\n  compatible with \u201ccv2 T2\u201d \u2026 then the reference is bound to the value of the initializer expression.\"</p>\n</blockquote>\n<p>Combined with 6502's answer, and the pointlessness of binding a reference to a value which ends at the semicolon, it is apparent that C++11 continues to support this behavior.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2011-04-16T21:41:11.217", "Id": "5689686", "Score": "0", "CreationDate": "2011-04-16T21:18:55.473", "LastActivityDate": "2011-04-16T21:41:11.217"}});