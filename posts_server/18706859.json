post_cb({"18706859": {"CommentCount": "16", "AcceptedAnswerId": "18707097", "PostTypeId": "1", "LastEditorUserId": "-1", "LastEditorDisplayName": "user2857423", "CreationDate": "2013-09-09T20:54:30.747", "LastActivityDate": "2014-02-10T13:48:13.010", "LastEditDate": "2017-05-23T11:44:22.297", "ViewCount": "2472", "FavoriteCount": "3", "Title": "Why is this an undefined behavior?", "Id": "18706859", "Score": "59", "Body": "<p>My answer to <a href=\"https://stackoverflow.com/q/18706587/845092\">this question</a> was this function:</p>\n<pre><code>inline bool divisible15(unsigned int x) \n{\n    //286331153 = (2^32 - 1) / 15\n    //4008636143 = (2^32) - 286331153\n    return x * 4008636143 &lt;= 286331153;\n}\n</code></pre>\n<p>It perfectly worked on my machine with VS2008 compiler, however <a href=\"http://ideone.com/HKqjiw\" rel=\"nofollow noreferrer\">here</a> it doesn't work at all.</p>\n<p>Does anyone has an idea, why it I get different results on different compilers?  <code>unsigned</code> overflow isn't undefined behavior.</p>\n<p><strong>Important note:</strong> after some test it was confirmed it is faster than taking the remainder of the division by 15. (However not on all compilers)</p>\n", "Tags": "<c++><c><undefined-behavior>", "OwnerUserId": "1237747", "AnswerCount": "2"}, "18707097": {"ParentId": "18706859", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It's not Undefined Behavior, it's just a breaking change in the C language standard between C89 and C99.</p>\n<p>In C89, integer constants like 4008636143 that don't fit in an <code>int</code> or <code>long int</code> but do fit in an <code>unsigned int</code> are unsigned, but in C99, they are either <code>long int</code> or <code>long long int</code> (depending on whichever one is the smallest one that can hold the value).  As a result, the expressions all get evaluated using 64 bits, which results in the incorrect answer.</p>\n<p>Visual Studio is a C89 compiler and so results in the C89 behavior, but that Ideone link is compiling in C99 mode.</p>\n<p>This becomes more evident if you compile with GCC using <code>-Wall</code>:</p>\n<pre><code>test.c: In function \u2018divisible15\u2019:\ntest.c:8:3: warning: this decimal constant is unsigned only in ISO C90\n</code></pre>\n<p>From C89 \u00a73.1.3.2:</p>\n<blockquote>\n<p id=\"so_18706859_18707097_0\">The type of an integer constant is the first of the corresponding\n  list in which its value can be represented.  Unsuffixed decimal: int,\n  long int, unsigned long int; unsuffixed octal or hexadecimal: int,\n  unsigned int, long int, unsigned long int; [...]</p>\n</blockquote>\n<p>C99 \u00a76.4.4.1/5-6:</p>\n<blockquote>\n<p id=\"so_18706859_18707097_1\">5) The type of an integer constant is the first of the corresponding list in which its value can\n  be represented.</p>\n<pre><code>Suffix | Decimal Constant | Octal or Hexadecimal Constant\n-------+------------------+------------------------------\nnone   | int              | int\n       | long int         | unsigned int\n       | long long int    | long int\n       |                  | unsigned long int\n       |                  | long long int\n       |                  | unsigned long long int\n-------+------------------+------------------------------\n[...]\n</code></pre>\n<p id=\"so_18706859_18707097_2\">6) If an integer constant cannot be represented by any type in its list, it may have an\n  extended integer type, if the extended integer type can represent its value. If all of the\n  types in the list for the constant are signed, the extended integer type shall be signed. [...]</p>\n</blockquote>\n<p>For completeness, C++03 actually does have Undefined Behavior for when the integer constant is too big to fit in a <code>long int</code>.  From C++03 \u00a72.13.1/2:</p>\n<blockquote>\n<p id=\"so_18706859_18707097_3\">The type of an integer literal depends on its form, value, and suffix. If it is decimal and has no suffix, it has\n  the first of these types in which its value can be represented: <code>int</code>, <code>long int</code>; if the value cannot be represented\n  as a <code>long int</code>, the behavior is undefined. If it is octal or hexadecimal and has no suffix, it has the\n  first of these types in which its value can be represented: <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned\n  long int</code>. [...]</p>\n</blockquote>\n<p>The C++11 behavior is identical to C99, see C++11 \u00a72.14.2/3.</p>\n<p>To ensure that the code behaves consistently when compiled as either C89, C99, C++03, and C++11, the simple fix is to make the constant 4008636143 unsigned by suffixing it with <code>u</code> as <code>4008636143u</code>.</p>\n", "OwnerUserId": "9530", "LastEditorUserId": "9530", "LastEditDate": "2013-09-09T22:21:32.280", "Id": "18707097", "Score": "98", "CreationDate": "2013-09-09T21:11:43.823", "LastActivityDate": "2013-09-09T22:21:32.280"}, "bq_ids": {"n4140": {"so_18706859_18707097_1": {"section_id": 5341, "quality": 0.8181818181818182, "length": 9}, "so_18706859_18707097_2": {"section_id": 5342, "quality": 0.75, "length": 21}, "so_18706859_18707097_0": {"section_id": 5341, "quality": 0.7666666666666667, "length": 23}}, "n3337": {"so_18706859_18707097_1": {"section_id": 5138, "quality": 0.8181818181818182, "length": 9}, "so_18706859_18707097_2": {"section_id": 5139, "quality": 0.75, "length": 21}, "so_18706859_18707097_0": {"section_id": 5138, "quality": 0.7666666666666667, "length": 23}}, "n4659": {"so_18706859_18707097_1": {"section_id": 6762, "quality": 0.8181818181818182, "length": 9}, "so_18706859_18707097_2": {"section_id": 6763, "quality": 0.75, "length": 21}, "so_18706859_18707097_0": {"section_id": 6762, "quality": 0.7666666666666667, "length": 23}}}, "18707051": {"ParentId": "18706859", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Since you are using <code>int</code> constants, the compiler can \"use\" the overflow is undefined to shortcut the code. If you modify with U as below, it \"works\". </p>\n<pre><code>inline bool divisible15(unsigned int x) \n{\n    //286331153 = (2^32 - 1) / 15\n    //4008636143 = (2^32) - 286331153\n    return x * 4008636143u &lt;= 286331153u;\n}\n</code></pre>\n<p>testing with: </p>\n<pre><code>#include &lt;iostream&gt;\n\n\ninline bool divisible15a(unsigned int x) \n{\n    //286331153 = (2^32 - 1) / 15\n    //4008636143 = (2^32) - 286331153\n//    return x * 4008636143 &lt;= 286331153;\n    return x * 4008636143u &lt;= 286331153;\n}\n\ninline bool divisible15b(unsigned int x) \n{\n    //286331153 = (2^32 - 1) / 15\n    //4008636143 = (2^32) - 286331153\n//    return x * 4008636143 &lt;= 286331153;\n    return x * 4008636143 &lt;= 286331153;\n}\n\n\nint main()\n{\n    for(unsigned int i = 0; i &lt; 100; i++)\n    {\n    if (divisible15a(i))\n    {\n        std::cout &lt;&lt; \"a:\" &lt;&lt; i &lt;&lt; std::endl;\n    }\n    if (divisible15b(i))\n    {\n        std::cout &lt;&lt; \"b:\" &lt;&lt; i &lt;&lt; std::endl;\n    }\n    }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>a:0\nb:0\na:15\na:30\na:45\na:60\na:75\na:90\n</code></pre>\n<p>Code:</p>\n<pre><code>_Z12divisible15aj:\n.LFB1192:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    %edi, -4(%rbp)\n    movl    -4(%rbp), %eax\n    imull   $-286331153, %eax, %eax\n    cmpl    $286331153, %eax\n    setbe   %al\n    popq    %rbp\n    ret\n\n_Z12divisible15bj:\n.LFB1193:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    %edi, -4(%rbp)\n    movl    -4(%rbp), %edx\n    movl    $4008636143, %eax\n    imulq   %rdx, %rax\n    cmpq    $286331153, %rax\n    setle   %al\n    popq    %rbp\n    ret\n</code></pre>\n<p>So, yes, I agree with Carl/Adam's analysis that it doesn't fit in a 32-bit int, so therefore promoted to <code>long</code> or <code>long long</code>. </p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2013-09-09T21:21:56.107", "Id": "18707051", "Score": "9", "CreationDate": "2013-09-09T21:07:08.517", "LastActivityDate": "2013-09-09T21:21:56.107"}});