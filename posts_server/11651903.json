post_cb({"11652523": {"ParentId": "11651903", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Sadly, <code>shared_ptr</code>'s need for type-erasure makes it impossible with the current interface to achieve <em>exactly</em> what you want. <code>unique_ptr</code> manages to do that because it has static information on the actual deleter type, from where it can draw the actual \"pointer\" type. In <code>shared_ptr</code>'s case, the deleter type is lost in the type-erasure process (which is why you can't specify it in the <code>shared_ptr</code> template).</p>\n<p>Also note that <code>unique_ptr</code> doesn't provide any converting constructors like <code>shared_ptr</code> does (e.g. <code>template&lt;class Y&gt; shared_ptr(Y* p)</code>). It can't do so because <code>pointer</code> is not necessarily a real pointer type, and so it can't restrict what can be accepted (except maybe through some SFINAE with <code>std::is_convertible_to</code> or something like that... but I digress).</p>\n<p>Now, one obvious workaround is to simply <code>new</code> the resource handle, as dumb as it sounds. :/</p>\n<pre><code>std::shared_ptr&lt;SC_HANDLE&gt; sp(new SC_HANDLE(::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS)),\n    [](SC_HANDLE* p){ ::CloseServiceHandle(*p); delete p; });\n</code></pre>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2012-07-25T15:37:36.357", "Id": "11652523", "Score": "13", "CreationDate": "2012-07-25T14:52:02.817", "LastActivityDate": "2012-07-25T15:37:36.357"}, "11651903": {"CommentCount": "4", "AcceptedAnswerId": "11652523", "PostTypeId": "1", "LastEditorUserId": "241536", "CreationDate": "2012-07-25T14:20:25.890", "LastActivityDate": "2012-07-27T00:52:52.433", "LastEditDate": "2012-07-25T14:31:16.207", "ViewCount": "1745", "FavoriteCount": "5", "Title": "shared_ptr with non-pointer resources", "Id": "11651903", "Score": "23", "Body": "<p>In C++11 is it possible to use <code>shared_ptr</code> to control non-pointer resources?</p>\n<hr>\n<p>It is possible to use <code>unique_ptr</code> to manage non-pointer resources.  This is done by implementing a custom deleter class which provides:</p>\n<ol>\n<li>A <code>typedef {TYPE} pointer;</code> where <code>{TYPE}</code> is the non-pointer resource type</li>\n<li><code>operator()(pointer)</code> which frees the controlled resource</li>\n</ol>\n<p>...and then instantiating a <code>unique_ptr</code> with the custom deleter as the second template parameter.</p>\n<p>For example, under Windows it is possible to create a <code>unique_ptr</code> which manages a <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms685104%28v=vs.85%29.aspx\" rel=\"noreferrer\">service control handle</a>.  This handle type is not freed by calling <code>delete</code>, but by calling <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms682028%28v=vs.85%29.aspx\" rel=\"noreferrer\"><code>CloseServiceHandle()</code></a>.  Here is sample code which does this:</p>\n<h2>Custom Deleter</h2>\n<pre><code>struct SvcHandleDeleter\n{\n    typedef SC_HANDLE pointer;\n    SvcHandleDeleter() {};\n\n    template&lt;class Other&gt; SvcHandleDeleter(const Other&amp;) {};\n\n    void operator()(pointer h) const\n    {\n        CloseServiceHandle(h);\n    }\n};\n\n\ntypedef std::unique_ptr&lt;SC_HANDLE,SvcHandleDeleter&gt; unique_sch;\n</code></pre>\n<h2>Instantiation</h2>\n<pre><code>unique_sch scm(::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS));\n</code></pre>\n<hr>\n<p>Is it possible to use <code>shared_ptr</code> to control a non-pointer resource as well?</p>\n<p>According to the documentation, there are <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\" rel=\"noreferrer\"><code>shared_ptr</code> constructor overloads</a> which take provide the means to provide a custom deleter class, but none of the constructors accept a resource type that is not either a pointer or a wrapper around a pointer.</p>\n<p>How can this be done?</p>\n</hr></hr>", "Tags": "<c++><c++11><shared-ptr>", "OwnerUserId": "241536", "AnswerCount": "4"}, "11652406": {"ParentId": "11651903", "CommentCount": "0", "Body": "<p>Think no. Since standard provide such constructors for shared_ptr and no other one.</p>\n<pre><code>// 20.7.2.2.1, constructors:\nconstexpr shared_ptr() noexcept;\ntemplate&lt;class Y&gt; explicit shared_ptr(Y* p);\ntemplate&lt;class Y, class D&gt; shared_ptr(Y* p, D d);\ntemplate&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);\ntemplate &lt;class D&gt; shared_ptr(nullptr_t p, D d)\ntemplate &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a)\ntemplate&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T *p) noexcept;\nshared_ptr(const shared_ptr&amp; r) noexcept;\ntemplate&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;\nshared_ptr(shared_ptr&amp;&amp; r) noexcept;\ntemplate&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;\ntemplate&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);\ntemplate&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt;&amp;&amp; r);\ntemplate &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);\nconstexpr shared_ptr(nullptr_t) : shared_ptr() { }\n</code></pre>\n<p>And how you want to do for example (for unique_ptr)</p>\n<pre><code>pointer release() noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_11651903_11652406_0\">1 Postcondition: get() == nullptr. 2 Returns: The value get() had at\n  the start of the call to release.</p>\n</blockquote>\n<p>With no pointer resource? You try to hack language. It's always bad idea.</p>\n", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "11652406", "Score": "0", "CreationDate": "2012-07-25T14:47:02.547", "LastActivityDate": "2012-07-25T14:47:02.547"}, "11652330": {"ParentId": "11651903", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Well, shared_ptr will invoke the destructor of the pointed to object as soon as the last reference to the pointer is released then whatever the class contains can be released.  Just make a class maybe like this:</p>\n<pre><code>struct SvcHandle\n{\n  typedef SC_HANDLE pointer;\n  SvcHandle()\n  :M_handle(::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS))\n  { }\n\n  ~SvcHandle()\n  {\n      CloseServiceHandle(M_handle);\n  }\nprivate:\n  pointer M_handle;\n};\n</code></pre>\n<p>Then just make a shared pointer with a new SvcHandle.\nThe lifetime management of the handle will go with the shared_ptr - RAII at its finest.</p>\n", "OwnerUserId": "680359", "LastEditorUserId": "680359", "LastEditDate": "2012-07-27T00:52:52.433", "Id": "11652330", "Score": "5", "CreationDate": "2012-07-25T14:42:52.773", "LastActivityDate": "2012-07-27T00:52:52.433"}, "bq_ids": {"n4140": {"so_11651903_11652538_0": {"section_id": 4418, "quality": 0.5714285714285714, "length": 4}, "so_11651903_11652406_0": {"section_id": 4339, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_11651903_11652538_0": {"section_id": 4255, "quality": 0.5714285714285714, "length": 4}, "so_11651903_11652406_0": {"section_id": 4180, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_11651903_11652538_0": {"section_id": 5677, "quality": 0.5714285714285714, "length": 4}, "so_11651903_11652406_0": {"section_id": 5596, "quality": 0.5454545454545454, "length": 6}}}, "11652538": {"ParentId": "11651903", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>How about this?</p>\n<pre><code>auto scm = make_shared&lt;unique_sch&gt;(::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS));\n</code></pre>\n<p><strong>unique_sch</strong> is the class you mentioned in your question.\nNow use scm as a shared pointer to your resource.\nIt's not the nicest thing to dereference when needed, but you did ask if it is possible.</p>\n<p>But that's still using a pointer.\nAs can be seen in the documentation, the <strong>unique_ptr</strong> class takes a <strong>pointer</strong> class as a constructor parameter, which can in fact be anything.\n<strong>shared_ptr</strong> however takes a type as a template parameter and forcefully turns that into a pointer to that type on its constructor:</p>\n<blockquote>\n<p id=\"so_11651903_11652538_0\">template&lt; class Y, class Deleter &gt;  shared_ptr( <strong>Y*</strong> ptr, Deleter d );</p>\n</blockquote>\n<p>I think it's safe to say it can't directly be used to manage a non-pointer resource, because the <strong>shared_ptr</strong> class makes the assumption that its resource is a pointer.</p>\n", "OwnerUserId": "911325", "LastEditorUserId": "911325", "LastEditDate": "2012-07-25T15:18:07.347", "Id": "11652538", "Score": "1", "CreationDate": "2012-07-25T14:52:53.130", "LastActivityDate": "2012-07-25T15:18:07.347"}});