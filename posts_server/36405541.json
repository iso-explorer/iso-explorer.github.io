post_cb({"bq_ids": {"n4140": {"so_36405541_36406210_3": {"section_id": 6186, "quality": 0.8571428571428571, "length": 6}, "so_36405541_36406210_0": {"section_id": 6186, "quality": 0.8095238095238095, "length": 17}, "so_36405541_36407197_0": {"section_id": 6185, "quality": 1.0, "length": 17}}, "n3337": {"so_36405541_36406210_3": {"section_id": 5947, "quality": 0.8571428571428571, "length": 6}, "so_36405541_36406210_0": {"section_id": 5947, "quality": 0.6666666666666666, "length": 14}, "so_36405541_36407197_0": {"section_id": 5946, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_36405541_36406210_3": {"section_id": 7689, "quality": 0.8571428571428571, "length": 6}, "so_36405541_36406210_0": {"section_id": 7689, "quality": 0.7142857142857143, "length": 15}, "so_36405541_36407197_0": {"section_id": 7687, "quality": 1.0, "length": 17}}}, "36406119": {"ParentId": "36405541", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The compiler does not allow an implicit narrowing or non-integral promotion during the initialisation of a constexpr variable.</p>\n<p>This will work:</p>\n<pre><code>int main()\n{\n    const int PI1 = 3;\n    constexpr int PI2 = 3;\n    constexpr int PI3 = PI1;  // works\n    static_assert(PI1 == 3, \"\");  // works\n\n    const double PI1__ = 3;\n    constexpr double PI2__ = 3;\n    constexpr double PI3__ = double(PI1);  // works with explicit cast\n    static_assert(PI2__ == 3, \"\");  // works now. PI1__ isn't constexpr\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "2015579", "LastEditorUserId": "2015579", "LastEditDate": "2016-04-04T15:03:14.080", "Id": "36406119", "Score": "0", "CreationDate": "2016-04-04T14:56:56.160", "LastActivityDate": "2016-04-04T15:03:14.080"}, "36405541": {"CommentCount": "5", "ViewCount": "540", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-04-04T14:32:22.857", "LastActivityDate": "2016-04-04T15:45:48.213", "Title": "constexpr vs const vs constexpr const", "AcceptedAnswerId": "36407197", "LastEditDate": "2017-05-23T11:44:20.637", "Id": "36405541", "Score": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/13347355/6053907\">const-vs-constexpr-on-variables</a></p>\n<p>What the guy says about constexpr is right <code>if double</code> is used (or <code>float</code> of course). However, if you change the var type from <code>double</code> to an integer type like int, char, etc, everything works. Why does that happen?</p>\n<p><a href=\"http://ideone.com/DAWABE\" rel=\"nofollow noreferrer\">http://ideone.com/DAWABE</a></p>\n<pre><code>int main() \n{\n    const int PI1 = 3;\n    constexpr int PI2 = 3;\n    constexpr int PI3 = PI1;  // works\n    static_assert(PI1 == 3, \"\");  // works\n\n    const double PI1__ = 3.0;\n    constexpr double PI2__ = 3.0;\n    constexpr double PI3__ = PI1__;  // error\n    static_assert(PI1__ == 3.0, \"\");  // error\n    return 0;\n}\n</code></pre>\n<p><code>Update</code>: the following line was a mistake, I meant <code>PI3__ = PI1__</code></p>\n<pre><code>constexpr double PI3__ = PI1;  // I meant PI1__\n</code></pre>\n<p>Questions:</p>\n<ol>\n<li><p>Why <code>const int = 3</code> is  compile time constant but <code>const double = 3.0</code> is not? </p></li>\n<li><p>Is there any reason why I should use <code>constexpr const int val;</code> over <code>constexpr int val</code>? They both seem to do exactly the same.</p></li>\n</ol>\n", "Tags": "<c++><c++14><constexpr>", "OwnerUserId": "6053907", "AnswerCount": "3"}, "36407197": {"ParentId": "36405541", "CommentCount": "0", "Body": "<p>From the comments it seems like OP is asking for Standard quote which defines <code>const int</code> as a compile-time constant, but <code>const double</code> as not.</p>\n<p>The corresponding details are found in 5.19, <code>Constant Expressions</code>. In particular:</p>\n<blockquote>\n<p id=\"so_36405541_36407197_0\">...an lvalue-to-rvalue conversion (4.1) unless it is applied to a\n  non-volatile glvalue of <strong>integral or enumeration type</strong> that refers to a\n  non-volatile const object with a preceding initialization, initialized\n  with a constant expression...</p>\n</blockquote>\n<p><code>int</code> is an integral type, while <code>double</code> is not.</p>\n", "OwnerUserId": "5245033", "PostTypeId": "2", "Id": "36407197", "Score": "1", "CreationDate": "2016-04-04T15:45:48.213", "LastActivityDate": "2016-04-04T15:45:48.213"}, "36406210": {"ParentId": "36405541", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Based on your answer in the comment this is my answer. The C++ standard makes it pretty clear. GCC 5.1 works pretty fine here though: <a href=\"https://godbolt.org/g/2oV6Hk\" rel=\"nofollow\">https://godbolt.org/g/2oV6Hk</a></p>\n<blockquote>\n<p id=\"so_36405541_36406210_0\">A converted constant expression of type T is an expression, implicitly converted to type T, where the converted\n  expression is a constant expression and the implicit conversion sequence contains only\n  \u00a7 5.20 134\n  c ISO/IEC N4567</p>\n<p id=\"so_36405541_36406210_1\">[...]</p>\n<p id=\"so_36405541_36406210_2\"><strong>(4.6) \u2014 integral promotions (4.5),</strong></p>\n<p id=\"so_36405541_36406210_3\"><strong>(4.7) \u2014 integral conversions (4.7) other than narrowing conversions (8.5.4)</strong>,</p>\n<p id=\"so_36405541_36406210_4\">[...]</p>\n</blockquote>\n<p>For the reference for narrowing conversions (8.5.4/7) in n4567:</p>\n<blockquote>\n<p id=\"so_36405541_36406210_5\">A narrowing conversion is an implicit conversion</p>\n<ul>\n<li>from a floating-point type to an integer type, or</li>\n<li>from long double to double or float, or from double to float, except where the source is a constant expression and the actual value after conversion is within the range of values that can be represented (even if it cannot be represented exactly), or</li>\n<li>from an integer type or unscoped enumeration type to a \ufb02oating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type, or</li>\n<li>from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1385931", "LastEditorUserId": "1385931", "LastEditDate": "2016-04-04T15:08:17.630", "Id": "36406210", "Score": "2", "CreationDate": "2016-04-04T15:01:12.547", "LastActivityDate": "2016-04-04T15:08:17.630"}});