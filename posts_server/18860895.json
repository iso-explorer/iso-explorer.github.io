post_cb({"18861169": {"Id": "18861169", "PostTypeId": "2", "Body": "<p>If the initializer can be expressed as a literal, it is solved in C++11:</p>\n<pre><code>inline std::string operator\"\" _s(const char* p, size_t n) {\n    return std::string{p, n};\n}\n\nclass BaseClass {\n    // inline initialization using user-defined literals\n    // should allow for multiple definitions\n    std::string bstring{\".\"_s};\n};\n</code></pre>\n", "LastEditorUserId": "2289509", "LastActivityDate": "2013-09-17T23:02:33.567", "Score": "-1", "CreationDate": "2013-09-17T22:51:01.063", "ParentId": "18860895", "CommentCount": "1", "LastEditDate": "2013-09-17T23:02:33.567", "OwnerUserId": "2289509"}, "42069703": {"Id": "42069703", "PostTypeId": "2", "Body": "<p><code>\u00a73.2.6</code> and the following paragraphs from the current c++ 17 draft (n4296) define the rules when more than one definition can be present in different translation units: </p>\n<blockquote>\n<p id=\"so_18860895_42069703_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with\n  external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member\n  of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for\n  which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements. Given\n  such an entity named D defined in more than one translation unit, then [...]</p>\n</blockquote>\n<p>Obviously definitions of static data members of class type are not considered to appear in multiple translations units. Thus, <em>according to the standard, it is not allowed</em>.  </p>\n<p>The suggested answers from Cheers and hth. - Alf and Dietmar are more kind of a \"hack\",  exploiting that definitions of</p>\n<blockquote>\n<p id=\"so_18860895_42069703_1\">static data member of a class template (14.5.1.3)</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_18860895_42069703_2\">inline function with external linkage (7.1.2)</p>\n</blockquote>\n<p>are allowed in multiple TU ( FYI: static functions defined inside a class definition have external linkage and are implicitly defined as inline ) .</p>\n", "LastEditorUserId": "4884487", "LastActivityDate": "2017-02-06T14:17:30.800", "Score": "1", "CreationDate": "2017-02-06T14:04:49.837", "ParentId": "18860895", "CommentCount": "0", "LastEditDate": "2017-02-06T14:17:30.800", "OwnerUserId": "4884487"}, "42423641": {"Id": "42423641", "PostTypeId": "2", "Body": "<p>To keep the definition of a static value with the declaration in C++11 \na nested static structure can be used. In this case the static member \nis a structure and has to be defined in a .cpp file, but the values \nare in the header.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class BaseClass\n{\npublic:\n  static struct _Static {\n     std::string bstring {\".\"};\n  } global;\n};\n</code></pre>\n<p>Instead of initializing individual members the whole static structure is initialized:</p>\n<pre><code>BaseClass::_Static BaseClass::global;\n</code></pre>\n<p>The values are accessed with</p>\n<pre><code>BaseClass::global.bstring;\n</code></pre>\n<p>Note that this solution still suffers from the problem of the order of \ninitialization of the static variables. When a static value is used to \ninitialize another static variable, the first may not be initialized, \nyet.</p>\n<pre><code>// file.h\nclass File {\npublic:\n  static struct _Extensions {\n    const std::string h{ \".h\" };\n    const std::string hpp{ \".hpp\" };\n    const std::string c{ \".c\" };\n    const std::string cpp{ \".cpp\" };\n  } extension;\n};\n\n// file.cpp\nFile::_Extensions File::extension;\n\n// module.cpp\nstatic std::set&lt;std::string&gt; headers{ File::extension.h, File::extension.hpp };\n</code></pre>\n<p>In this case the static variable <em>headers</em> will contain either { \"\" } \nor { \".h\", \".hpp\" }, depending on the order of initialization created by the linker.</p>\n", "LastActivityDate": "2017-02-23T18:38:03.967", "Score": "2", "CreationDate": "2017-02-23T18:38:03.967", "ParentId": "18860895", "CommentCount": "0", "OwnerUserId": "7612635"}, "18860895": {"ViewCount": "25338", "Body": "<p>Given is a class with a static member.</p>\n<pre><code>class BaseClass\n{\npublic:\n    static std::string bstring;\n};\n</code></pre>\n<p>String has obviously to be <em>default-initialized</em> outside of the class.</p>\n<pre><code>std::string BaseClass::bstring {\".\"};\n</code></pre>\n<p>If I include the above line in the header along with the class, I get a <code>symbol multiply defined</code> error. It has to be defined in a separate <code>cpp</code> file, even with <code>include guards</code> or <code>pragma once</code>.</p>\n<p>Isn't there a way to define it in the header?</p>\n", "AcceptedAnswerId": "18861043", "Title": "How to initialize static members in the header", "CreationDate": "2013-09-17T22:25:16.030", "Id": "18860895", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-04-25T12:46:36.913", "LastEditorUserId": "1930535", "LastActivityDate": "2017-02-23T18:38:03.967", "Score": "20", "OwnerUserId": "1930535", "Tags": "<c++><class><static-members>", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_18860895_42069703_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 48}, "so_18860895_42069703_0": {"length": 59, "quality": 0.9076923076923077, "section_id": 7043}, "so_18860895_42069703_2": {"length": 4, "quality": 0.8, "section_id": 5404}}, "n3337": {"so_18860895_42069703_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 43}, "so_18860895_42069703_0": {"length": 59, "quality": 0.9076923076923077, "section_id": 6788}, "so_18860895_42069703_2": {"length": 4, "quality": 0.8, "section_id": 5199}}, "n4659": {"so_18860895_42069703_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 49}, "so_18860895_42069703_0": {"length": 59, "quality": 0.9076923076923077, "section_id": 8540}, "so_18860895_42069703_2": {"length": 4, "quality": 0.8, "section_id": 6853}}}, "18861043": {"Id": "18861043", "PostTypeId": "2", "Body": "<p>You can't define a <code>static</code> member variable more than once. If you put variable definitions into a header, it is going to be defined in each translation unit where the header is included. Since the include guards are only affecting the compilation of one translation unit, they won't help, either.</p>\n<p>However, you <em>can</em> define <code>static</code> member <em>functions</em>! Now, at first sight that may not look as if it could help except, of course, that function can have local <code>static</code> variable and returning a reference to one of these behaves nearly like a <code>static</code> member variable:</p>\n<pre><code>static std::string&amp; bstring() { static std::string rc{\".\"}; return rc; }\n</code></pre>\n<p>The local <code>static</code> variable will be initialized the first time this function is called. That is, the construction is delayed until the function is accessed the first time. Of course, if you use this function to initialize other global objects it may also make sure that the object is constructed in time. If you use multiple threads this may look like a potential data race but it isn't (unless you use C++03): the initialization of the function local <code>static</code> variable is thread-safe.</p>\n", "LastEditorUserId": "4639394", "LastActivityDate": "2015-05-01T18:53:09.600", "Score": "37", "CreationDate": "2013-09-17T22:38:51.350", "ParentId": "18860895", "CommentCount": "3", "LastEditDate": "2015-05-01T18:53:09.600", "OwnerUserId": "1120273"}, "27070265": {"Id": "27070265", "PostTypeId": "2", "Body": "<p>Regarding </p>\n<blockquote>\n<p id=\"so_18860895_27070265_0\"><strong>\u201d</strong> Isn't there a way to define [the static data member] in the header?</p>\n</blockquote>\n<p>Yes there is.</p>\n<pre><code>template&lt; class Dummy &gt;\nstruct BaseClass_statics\n{\n    static std::string bstring;\n};\n\ntemplate&lt; class Dummy &gt;\nstd::string BaseClass_statics&lt;Dummy&gt;::bstring = \".\";\n\nclass BaseClass\n    : public BaseClass_statics&lt;void&gt;\n{};\n</code></pre>\n<p>An alternative is to use a function, as Dietmar suggested. Essentially that is a Meyers' singleton (google it).</p>\n<p><em>Edit</em>: Also, since this answer was posted we've got the inline object proposal, which I think is accepted for C++17.</p>\n<p>Anyway, <strong>think twice</strong> about the design here. Globals variables are Evil\u2122. This is essentially a global.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2016-09-28T12:43:56.647", "Score": "6", "CreationDate": "2014-11-21T21:00:39.900", "ParentId": "18860895", "CommentCount": "5", "LastEditDate": "2016-09-28T12:43:56.647", "OwnerUserId": "464581"}, "18860963": {"Id": "18860963", "PostTypeId": "2", "Body": "<p>UPDATE: My answer below explains why this cannot be done in the way suggested by the question. There are at least two answers circumventing this; they may or may not solve the problem.</p>\n<hr>\n<p>The <code>bstring</code> static member has to be linked to a specific memory address.  For this to happen, it has to appear in a single object file, therefore it has to appear in a single <code>cpp</code> file.  Unless you're playing with <code>#ifdef</code>'s to make sure this happens, what you want cannot be done in the header file, as your header file may be included by more than one <code>cpp</code> files.</p>\n</hr>", "LastEditorUserId": "1653187", "LastActivityDate": "2015-04-04T21:31:01.080", "Score": "1", "CreationDate": "2013-09-17T22:31:41.933", "ParentId": "18860895", "CommentCount": "3", "LastEditDate": "2015-04-04T21:31:01.080", "OwnerUserId": "1653187"}, "18860958": {"Id": "18860958", "PostTypeId": "2", "Body": "<p>No, it can't be done in a header - at least not if the header is included more than once in your source-files, which appears to be the case, or you wouldn't get an error like that. Just stick it in one of the .cpp files and be done with it. </p>\n", "LastActivityDate": "2013-09-17T22:30:59.247", "Score": "3", "CreationDate": "2013-09-17T22:30:59.247", "ParentId": "18860895", "CommentCount": "4", "OwnerUserId": "1919155"}});