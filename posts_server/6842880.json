post_cb({"6843474": {"Id": "6843474", "PostTypeId": "2", "Body": "<p>I can't tell you the reason why they had to re-implement it, and why they chose <code>int</code> instead if <code>size_t</code> as the return type. But about the function:</p>\n<pre><code>/*\n ** Compute a string length that is limited to what can be stored in\n ** lower 30 bits of a 32-bit signed integer.\n */\nstatic int strlen30(const char *z){\n    const char *z2 = z;\n    while( *z2 ){ z2++; }\n    return 0x3fffffff &amp; (int)(z2 - z);\n}\n</code></pre>\n<p><br/><br/></p>\n<h1>Standard References on Truncation, Types, Overflow</h1>\n<p>The standard says in (ISO/IEC 14882:2003(E)) <em>3.9.1 Fundamental Types</em>, 4.:</p>\n<blockquote>\n<p id=\"so_6842880_6843474_0\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number of bits in the value representation of that particular size of integer. <sup></sup>41)</p>\n<p id=\"so_6842880_6843474_1\">...</p>\n<p id=\"so_6842880_6843474_2\"><sup>41)</sup>: This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer\n  type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer\n  type</p>\n</blockquote>\n<p>That part of the standard does not define overflow-behaviour for signed integers. If we look at <em>5. Expressions</em>, 5.:</p>\n<blockquote>\n<p id=\"so_6842880_6843474_3\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined, unless such an expression is a constant expression\n  (5.19), in which case the program is ill-formed. [Note: most existing implementations of C + + ignore integer\n  overflows. Treatment of division by zero, forming a remainder using a zero divisor, and all floating point\n  exceptions vary among machines, and is usually adjustable by a library function. ]</p>\n</blockquote>\n<p>So far for overflow.</p>\n<p>As for subtracting two pointers to array elements, <em>5.7 Additive operators</em>, 6.:</p>\n<blockquote>\n<p id=\"so_6842880_6843474_4\">When two pointers to elements of the same array object are subtracted, the result is the difference of the subscripts of the two array elements. The type of the result is an implementation-defined signed integral type; this type shall be the same type that is defined as ptrdiff_t in the  header (18.1). [...]</p>\n</blockquote>\n<p>Looking at <em>18.1</em>:</p>\n<blockquote>\n<p id=\"so_6842880_6843474_5\">The contents are the same as the Standard C library header stddef.h</p>\n</blockquote>\n<p>So let's look at the C standard (I only have a copy of C99, though), <em>7.17 Common Definitions </em>:</p>\n<blockquote id=\"so_6842880_6843474_6\">\n<ol>\n<li>The types used for size_t and ptrdiff_t should not have an integer conversion rank\n  greater than that of signed long int unless the implementation supports objects\n  large enough to make this necessary.</li>\n</ol>\n</blockquote>\n<p>No further guarantee made about <code>ptrdiff_t</code>. Then, Annex E (still in ISO/IEC 9899:TC2) gives the <em>minimum magnitude</em> for signed long int, but not a maximum:</p>\n<pre><code>#define LONG_MAX +2147483647\n</code></pre>\n<p>Now what are the maxima for <code>int</code>, the return type for <code>sqlite - strlen30()</code>? Let's skip the C++ quotation that forwards us to the C-standard once again, and we'll see in C99, Annex E, the minimum maximum for <code>int</code>:</p>\n<pre><code>#define INT_MAX +32767\n</code></pre>\n<h2><br/><br/></h2>\n<h1>Summary about the truncation part</h1>\n<ol>\n<li>Usually, <code>ptrdiff_t</code> is not bigger than <code>signed long</code>, which is not smaller than 32bits. </li>\n<li><code>int</code> is just defined to be at least 16bits long.</li>\n<li>Therefore, subtracting two pointers may give a result that does not fit into the  <code>int</code> of your platform.</li>\n<li>We remember from above that for signed types, a result that does not fit yields undefined behaviour.</li>\n<li><code>strlen30</code> does applies a bitwise or upon the pointer-subtract-result:</li>\n</ol>\n<hr>\n<pre><code>          | 32 bit                         |\nptr_diff  |10111101111110011110111110011111| // could be even larger\n&amp;         |00111111111111111111111111111111| // == 3FFFFFFF&lt;sub&gt;16&lt;/sub&gt;\n          ----------------------------------\n=         |00111101111110011110111110011111| // truncated\n</code></pre>\n<hr>\n<p>That prevents undefiend behaviour by truncation of the pointer-subtraction result to a maximum value of 3FFFFFFF<sub>16</sub> = 1073741823<sub>10</sub>.</p>\n<p>I am not sure about why they chose exactly that value, because on most machines, only the <a href=\"http://en.wikipedia.org/wiki/Signed_number_representations#One.27s_complement\" rel=\"nofollow\">most significant bit tells the signedness</a>. It could have made sense versus the standard to choose the minimum <code>INT_MAX</code>, but 1073741823 is indeed slightly strange without knowing more details (though it of course perfectly does what the comment above their function says: truncate to 30bits and prevent overflow).</p>\n<p><br/><br/></p>\n<h1>\"Why not use strlen() for this part\"</h1>\n<blockquote>\n<p id=\"so_6842880_6843474_7\">and rewrite it like this:</p>\n</blockquote>\n<pre><code>return 0x3fffffff &amp; (int)(strlen(z));\n</code></pre>\n<p>My guess is that they wanted to avoid a potential indirection. Another advantage might be fewer dependencies on the standard library, which can be useful if you write a non-hosted application. </p>\n<p>Btw, as follows from the references above, <code>(int)(strlen(z))</code> might yield undefined behaviour if the maximum for ptrdiff_t &gt; <code>INT_MAX</code>, so <code>(int)(0x3fffffff &amp; strlen(z))</code> would be better.</p>\n</hr></hr>", "LastEditorUserId": "76722", "LastActivityDate": "2011-07-27T11:38:25.897", "Score": "6", "CreationDate": "2011-07-27T11:22:27.463", "ParentId": "6842880", "CommentCount": "3", "OwnerUserId": "76722", "LastEditDate": "2011-07-27T11:38:25.897"}, "bq_ids": {"n4140": {"so_6842880_6843474_3": {"length": 38, "quality": 0.8260869565217391, "section_id": 5937}, "so_6842880_6843474_4": {"length": 24, "quality": 0.8571428571428571, "section_id": 6143}, "so_6842880_6843474_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 7213}, "so_6842880_6843474_5": {"length": 5, "quality": 0.7142857142857143, "section_id": 6704}, "so_6842880_6843474_0": {"length": 14, "quality": 0.875, "section_id": 7213}}, "n3337": {"so_6842880_6843474_3": {"length": 38, "quality": 0.8260869565217391, "section_id": 5709}, "so_6842880_6843474_0": {"length": 16, "quality": 1.0, "section_id": 6957}, "so_6842880_6843474_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 6957}, "so_6842880_6843474_5": {"length": 5, "quality": 0.7142857142857143, "section_id": 6459}, "so_6842880_6843474_4": {"length": 24, "quality": 0.8571428571428571, "section_id": 5907}}, "n4659": {"so_6842880_6843474_3": {"length": 29, "quality": 0.6304347826086957, "section_id": 7421}, "so_6842880_6843474_4": {"length": 18, "quality": 0.6428571428571429, "section_id": 7639}, "so_6842880_6843474_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 8722}, "so_6842880_6843474_5": {"length": 5, "quality": 0.7142857142857143, "section_id": 8177}, "so_6842880_6843474_0": {"length": 14, "quality": 0.875, "section_id": 8722}}}, "6853130": {"Id": "6853130", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6842880_6853130_0\">Why reimplement strlen as loop+subtraction?</p>\n</blockquote>\n<p>I suspect the real answer is that the programmer felt like it, but another potential justification/rationalisation is that the loop is inline (independent of whether <code>strlen30</code> itself is), whereas on many systems <code>strlen</code> is an out-of-line function call (e.g. Linux/GCC).  If the overwhelming majority of strings are empty or short (despite the \"special\" treatment of long ones), then that may yield a slight performance bump for the common case.  That possibility alone may be enough to get a code-happy programmer key-tapping.  For longer strings I would expect the library <code>strlen</code> to be generally optimal (allowing for it's lack of knowledge of the application specific length of strings).</p>\n<p>Some systems may not even benefit from this inlining as <code>strlen</code> provides it's own, or an inline/out-of-line hybrid with a quick inline check for empty, one-char, maybe two-char strings then a call.</p>\n", "LastActivityDate": "2011-07-28T01:15:25.747", "CommentCount": "0", "CreationDate": "2011-07-28T01:15:25.747", "ParentId": "6842880", "Score": "1", "OwnerUserId": "410767"}, "6842880": {"ViewCount": "646", "Body": "<p>Inspired by <a href=\"https://stackoverflow.com/q/6842130/57428\">this question</a> about the following code from SQLite3:</p>\n<pre><code> static int strlen30(const char *z){\n    const char *z2 = z;\n    while( *z2 ){ z2++; }\n    return 0x3fffffff &amp; (int)(z2 - z);\n }\n</code></pre>\n<p>that is accompanied by a <a href=\"http://www.sqlite.org/src/timeline?c=2008-12-10%2019:26:22\" rel=\"nofollow noreferrer\">commit message</a> saying this function helps with <code>int</code> overflows.</p>\n<p>I'm particularly interested in this part:</p>\n<pre><code> const char *z2 = z;\n while( *z2 ){ z2++; }\n</code></pre>\n<p>to me this loop advances <code>z2</code> until <code>z2</code> points onto null terminator. Then <code>z2-z</code> yields the string length.</p>\n<p>Why not use <code>strlen()</code> for this part and rewrite like this:</p>\n<pre><code>return 0x3fffffff &amp; (int)(strlen(z));\n</code></pre>\n<p>Why use loop+subtraction instead of <code>strlen()</code>? What can loop+subtraction do what <code>strlen()</code> can't?</p>\n", "AcceptedAnswerId": "6853130", "Title": "Why reimplement strlen as loop+subtraction?", "CreationDate": "2011-07-27T10:31:05.237", "Id": "6842880", "CommentCount": "16", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:26:52.280", "LastEditorUserId": "-1", "LastActivityDate": "2011-07-28T01:15:25.747", "Score": "18", "OwnerUserId": "57428", "Tags": "<c++><c><string><sqlite><strlen>", "AnswerCount": "2"}});