post_cb({"bq_ids": {"n4140": {"so_24016605_24018720_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7107}, "so_24016605_24018720_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 7083}}, "n3337": {"so_24016605_24018720_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6851}, "so_24016605_24018720_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 6827}}, "n4659": {"so_24016605_24018720_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 8608}, "so_24016605_24018720_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 8584}}}, "24017985": {"Id": "24017985", "PostTypeId": "2", "Body": "<p>In <code>[expr.prim.general]</code> (5.1.1/8-9) the parsing rules of <code>::</code> are listed. It requires that <code>::</code> is followed by the name of a namespace/class or the name of a member of a namespace/class. <code>(</code> and <code>)</code> are not allowed.</p>\n<p>More specifically in <code>[over.oper]</code> (13.5/1) the standard defines <code>operator-function-id</code> and <code>operator</code> as one of <code>new</code>, <code>delete</code>, <code>+</code>, <code>-</code>, <code>!</code>, <code>=</code>, <code>\u02c6=</code>, <code>&amp;=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>()</code>, <code>[]</code>, <code>new[]</code>, <code>*</code>, <code>&lt;</code>, <code>|=</code>, <code>&amp;&amp;</code>, <code>delete[]</code>, <code>/</code>, <code>&gt;</code>, <code>&lt;&lt;</code>, <code>||</code>, <code>%</code>, <code>+=</code>, <code>&gt;&gt;</code>, <code>++</code>, <code>\u02c6</code>, <code>-=</code>, <code>&gt;&gt;=</code>, <code>--</code>, <code>&amp;</code>, <code>*=</code>, <code>&lt;&lt;=</code>, <code>,</code>, <code>|</code>, <code>/=</code>, <code>==</code>, <code>-&gt;*</code>, <code>\u223c</code>, <code>%=</code>, <code>!=</code>, <code>-&gt;</code>. </p>\n<p><code>.</code>, <code>.*</code>, <code>::</code>, <code>?:</code> are named as an exception in clause 9 to not act as ordinary unary or binary operators.</p>\n", "LastEditorUserId": "316448", "LastActivityDate": "2014-06-03T15:46:46.157", "Score": "9", "CreationDate": "2014-06-03T14:35:57.417", "ParentId": "24016605", "CommentCount": "1", "OwnerUserId": "316448", "LastEditDate": "2014-06-03T15:46:46.157"}, "24016605": {"ViewCount": "523", "Body": "<p>I think that the <code>::</code> operator can be unary in the case of accessing the global scope. In all other cases <code>::</code> is treated as a binary operator, and the evaluation rule for the <code>::</code> operator in the case of <code>N1::N2::N3::n</code> is equivalent to the following:</p>\n<pre><code>((N1::N2)::N3)::n // Error: ::n has not been declared\n</code></pre>\n<p>But that line doesn't compile. It is very curious. There is not any information in the standard about the evaluation of <code>nested-name-specifier</code>. It would be natural if the evaluation of <code>nested-name-specified</code> is equivalent to <code>qualified/unqualified-id</code>, <strong>but it does not say this anywhere in the standard.</strong> So can we assume that evaluation of a <code>nested-name-specifier</code> is implementation-dependent?</p>\n", "AcceptedAnswerId": "24018720", "Title": "rule for :: operator in c++", "CreationDate": "2014-06-03T13:34:52.333", "LastActivityDate": "2014-06-03T15:46:46.157", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-06-03T13:57:16.193", "OwnerDisplayName": "user2953119", "LastEditorUserId": "1227469", "Id": "24016605", "Score": "11", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}, "24016898": {"Id": "24016898", "PostTypeId": "2", "Body": "<p>There's nothing implementation dependent. You are incorrectly assuming it's an operator, though. It's not. Therefore, it's neither a unary nor a binary operator, and it does not form expressions. And since it doesn't form expressions, there's no evaluation of those expressions.</p>\n", "LastActivityDate": "2014-06-03T13:47:56.827", "CommentCount": "15", "CreationDate": "2014-06-03T13:47:56.827", "ParentId": "24016605", "Score": "1", "OwnerUserId": "15416"}, "24018720": {"Id": "24018720", "PostTypeId": "2", "Body": "<p>The scope resolution operator <code>::</code> is right-associative because the recursive grammar of the <em>nested-name-specifier</em> production is right-associative:</p>\n<pre><code>nested-name-specifier:\n    ::[opt] type-name ::\n    ::[opt] namespace-name ::\n    decltype-specifier ::\n    nested-name-specifier identifier ::\n    nested-name-specifier template[opt] simple-template-id ::\n</code></pre>\n<p>The appropriate rule for recursively evaluating a <em>nested-name-specifier</em> is then 3.4.3 <strong>[basic.lookup.qual]</strong>:</p>\n<blockquote>\n<p id=\"so_24016605_24018720_0\">1 - The name of a class or namespace member or enumerator can be referred to after the <code>::</code> scope resolution operator (5.1) applied to a <em>nested-name-specifier</em> that denotes its class, namespace, or enumeration. [...]</p>\n</blockquote>\n<p>Importantly, unlike 5.1, which only discusses lookup of <em>qualified-id</em>s (in 5.1.1p8), 3.4.3p1 is unrestricted and so can be used to lookup <em>nested-name-specifier</em>s recursively.</p>\n<p>That is, in:</p>\n<pre><code>namespace A {\n    namespace B {\n        struct C {\n            struct D {\n                static int i;\n            };\n        };\n    }\n}\nA::B::C::D::i;\n</code></pre>\n<p><code>A::B::C::D::i</code> is parsed as a <em>qualified-id</em> containing recursively the <em>nested-name-specifier</em>s <code>A::B::C::D::</code>, <code>A::B::C::</code>, <code>A::B::</code>, and <code>A::</code>.  Now, to evaluate <code>A::B::C::D::i</code>:</p>\n<ul>\n<li>we use 5.1.1p8, which requires evaluation of <code>A::B::C::D</code>;</li>\n<li>we use 3.4.3p1, which requires evaluation of <code>A::B::C</code>;</li>\n<li>we use 3.4.3p1, which requires evaluation of <code>A::B</code>;</li>\n<li>we use 3.4.3p1, which requires evaluation of <code>A</code>.</li>\n</ul>\n<p>Now we have to find a sense in which <code>A</code> \"<em>denotes</em>\" a \"<em>class, namespace or enumeration</em>\".  In the absence of anything more specific, section 3 refers us to 3.4:</p>\n<blockquote>\n<p id=\"so_24016605_24018720_1\">1 - The name lookup rules apply uniformly to all names (including <em>typedef-name</em>s (7.1.3), <em>namespace-name</em>s (7.3), and <em>class-name</em>s (9.1)) wherever the grammar allows such names in the context discussed by a particular rule. [...]</p>\n</blockquote>\n<p>The lookup of <code>A</code> now proceeds according to the rules of 3.4.1 <strong>[basic.lookup.unqual]</strong> as applied to the particular context.  Since we are in global scope, 3.4.1p4 applies and we search global scope for name <code>A</code>.  We find the namespace <code>A</code>, and evaluation of <code>A::B::C::D::i</code> proceeds accordingly.</p>\n<hr>\n<p>That is, the <em>leftmost</em> (innermost) name in a <em>nested-name-specifier</em> is looked up as an unqualified name; successive names are looked up as qualified names on their inner <em>nested-name-specifier</em>.</p>\n</hr>", "LastEditorUserId": "567292", "LastActivityDate": "2014-06-03T15:16:10.870", "Score": "8", "CreationDate": "2014-06-03T15:10:56.743", "ParentId": "24016605", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2014-06-03T15:16:10.870"}});