post_cb({"35383576": {"ParentId": "35383453", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-02-13T18:17:53.617", "Score": "12", "LastEditorUserId": "560648", "LastEditDate": "2016-02-13T22:39:10.417", "Id": "35383576", "OwnerUserId": "560648", "Body": "<p><strong>No.</strong></p>\n<p>The object whose <code>x</code> is equal to <code>1</code> was destroyed.</p>\n<p>You know that, because you're the one who destroyed it.</p>\n<p>Your new <code>x</code> is uninitialised and has an unspecified value, which may be <code>1</code> in practice due to memory re-use. That's no different than for any other uninitialised value.</p>\n<hr>\n<h2>Update</h2>\n<p>Since there seems to be a lot of people throwing about assertions, here are some <em>facts</em>, direct from the standard.</p>\n<p>There is no direct statement about this case because it follows from the general rules governing what objects are and what object lifetime means.</p>\n<p>Generally, once you've grokked that C++ is an <em>abstraction</em> rather than a direct mapping of bytes, you can understand what's going on here, and why there is no such guarantee as that the OP seeks.</p>\n<p>First, some background on object lifetime and destruction:</p>\n<blockquote>\n<p id=\"so_35383453_35383576_0\"><code>[C++14: 12.4/5]:</code> <strong>A destructor is trivial if it is not user-provided and if</strong>:</p>\n<ul>\n<li>the destructor is not <code>virtual</code>,</li>\n<li>all of the direct base classes of its class have trivial destructors, and</li>\n<li>for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor.</li>\n</ul>\n<p id=\"so_35383453_35383576_1\"><strong>Otherwise, the destructor is <em>non-trivial</em>.</strong></p>\n<p id=\"so_35383453_35383576_2\"><code>[C++14: 3.8]</code>: <em>[..]</em> <strong>The lifetime of an object of type <code>T</code> ends when:</strong></p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n<p id=\"so_35383453_35383576_3\"><code>[C++14: 3.8/3]</code>: The properties ascribed to objects throughout this International Standard apply for a given object only during its lifetime. <em>[..]</em></p>\n<p id=\"so_35383453_35383576_4\"><code>[C++14: 3.8/4]</code>: <strong>A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor.</strong> <strong>For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released</strong>; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>(Most of this passage is irrelevant for your first case, as it <em>does</em> have an explicit destructor call: your second violates the rules in this paragraph and thus has undefined behaviour; it shall not be discussed further.)</p>\n<blockquote>\n<p id=\"so_35383453_35383576_5\"><code>[C++14: 12.4/2]</code>: A destructor is used to destroy objects of its class type. <em>[..]</em></p>\n<p id=\"so_35383453_35383576_6\"><code>[C++14: 12.4/11]</code>: <em>[..]</em> Destructors can also be invoked explicitly.</p>\n<p id=\"so_35383453_35383576_7\"><code>[C++14: 12.4/15]</code>: Once a destructor is invoked for an object, the object no longer exists. <em>[..]</em></p>\n</blockquote>\n<p>Now, some specifics. What if we were to inspect <code>object.x</code> before the placement-new?</p>\n<blockquote>\n<p id=\"so_35383453_35383576_8\"><code>[C++14: 12.7/1]</code>: <em>[..]</em> <strong>For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavior.</strong></p>\n</blockquote>\n<p>Wow, okay.</p>\n<p>And what if we were to inspect it after the placement-new? i.e. what value does the <code>x</code> in the new object hold? Is it guaranteed, as the question asks, that it'll be <code>1</code>? Bear in mind that <code>Class</code>'s constructor includes no initialiser for <code>x</code>:</p>\n<blockquote>\n<p id=\"so_35383453_35383576_9\"><code>[C++14: 5.3.4/17]:</code> A <em>new-expression</em> that creates an object of type <code>T</code> initializes that object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is default-initialized (8.5); if no initialization is performed, the object has indeterminate value.</li>\n<li><strong>Otherwise, the <em>new-initializer</em> is interpreted according to the initialization rules of 8.5 for direct-initialization.</strong></li>\n</ul>\n<p id=\"so_35383453_35383576_10\"><code>[C++14: 8.5/16]:</code> The initialization that occurs in the forms</p>\n<pre><code>T x(a);\nT x{a};\n</code></pre>\n<p id=\"so_35383453_35383576_11\">as well as in <code>new</code> expressions (5.3.4), <code>static_cast</code> expressions (5.2.9), functional notation type conversions (5.2.3), and base and member initializers (12.6.2) is called <em>direct-initialization</em>.</p>\n<p id=\"so_35383453_35383576_12\"><code>[C++14: 8.5/17]:</code> The semantics of initializers are as follows. The destination type is the type of the object or reference being initialized and the source type is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined. <em>[..]</em></p>\n<ul>\n<li>If the initializer is <code>()</code>, the object is value-initialized.</li>\n<li><em>[..]</em></li>\n</ul>\n<p id=\"so_35383453_35383576_13\"><code>[C++14: 8.5/8]:</code> To value-initialize an object of type <code>T</code> means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is user-provided or deleted, then the object is default-initialized.</li>\n<li><em>[..]</em></li>\n</ul>\n<p id=\"so_35383453_35383576_14\"><code>[C++14: 8.5/7]:</code> <strong>To default-initialize an object of type <code>T</code> means:</strong></p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type (Clause 9), <strong>the default constructor (12.1) for <code>T</code> is called</strong> (and the initialization is ill-formed if <code>T</code> has no default constructor or overload resolution (13.3) results in an\n  ambiguity or in a function that is deleted or inaccessible from the context of the initialization);</li>\n<li>if <code>T</code> is an array type, each element is default-initialized;\n  \u2014 <strong>otherwise, no initialization is performed.</strong></li>\n</ul>\n<p id=\"so_35383453_35383576_15\">If a program calls for the default initialization of an object of a const-qualified type <code>T</code>, <code>T</code> shall be a class type with a user-provided default constructor.</p>\n<p id=\"so_35383453_35383576_16\"><code>[C++14: 12.6.2/8]:</code> In a non-delegating constructor, if a given non-static data member or base class is not designated by a mem-initializer-id (including the case where there is no mem-initializer-list because the constructor has no\n  ctor-initializer) and the entity is not a virtual base class of an abstract class (10.4), then:</p>\n<ul>\n<li>if the entity is a non-static data member that has a brace-or-equal-initializer, the entity is initialized as specified in 8.5;</li>\n<li>otherwise, if the entity is an anonymous union or a variant member (9.5), no initialization is performed;</li>\n<li>otherwise, <strong>the entity is default-initialized</strong> (8.5).</li>\n</ul>\n<p id=\"so_35383453_35383576_17\"><code>[C++14: 8.5/12]:</code> If no initializer is specified for an object, the object is default-initialized; <strong>if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value.</strong></p>\n</blockquote>\n<p>So, does the standard guarantee that your replacement object's <code>x</code> has value <code>1</code>? No. It does not.</p>\n<p>In practice, why might it not be? Well, any number of reasons. <code>Class</code>'s destructor is non-trivial so, per 3.8, the first object's lifetime has ended immediately after you called its destructor.</p>\n<p>Technically, the compiler is then free to place an object at that location as long as it's destroyed by the time the placement-new takes effect. There's no reason for it to do so here, but there's nothing prohibiting it; more importantly, a simple <code>{ int x = 5; x = 42; }</code> in between the destructor call and the placement-new would be more than entitled to re-use that memory. It's not being used to represent any object at that point!</p>\n<p>More realistically, there are implementations (e.g. Microsoft Visual Studio) that, for debug-mode programs, write a recognisable bit-pattern into unused stack memory to aid in diagnosing program faults. There's no reason to think that such an implementation wouldn't hook into destructors in order to do that, and such an implementation would be overwriting your <code>1</code> value. There is nothing in the standard prohibiting this whatsoever.</p>\n<p>Indeed, if I replace the <code>?</code> lines in your code with <code>std::cout</code> statements, so that we <em>actually</em> inspect the values, I get a warning about an uninitialised variable and a value <code>0</code> in the case where you used a destructor:</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:19:23: warning: 'object.Class::x' is used uninitialized in this function [-Wuninitialized]\n   std::cout &lt;&lt; object.x &lt;&lt; '\\n';\n                       ^\n0\n1\n</code></pre>\n<h3><a href=\"http://coliru.stacked-crooked.com/a/a620c9a0fdb81cfe\">Live demo</a></h3>\n<p>I'm unsure how much more proof you need that the standard does not guarantee a <code>1</code> value here.</p>\n</hr>", "LastActivityDate": "2016-02-13T22:39:10.417"}, "35383453": {"CommentCount": "2", "AcceptedAnswerId": "35383576", "PostTypeId": "1", "LastEditorUserId": "5538420", "CreationDate": "2016-02-13T18:08:35.463", "LastActivityDate": "2016-02-17T11:31:02.207", "LastEditDate": "2016-02-13T22:50:13.157", "ViewCount": "180", "FavoriteCount": "1", "Title": "How are contents of an object defined when using placement new on existing object", "Id": "35383453", "Score": "6", "Body": "<p>Looking at the following example. Does the C++ standard guarantee that the value of <code>object.x</code> will be equal to <code>1</code> at the end? What if I don't call the destructor <code>object.~Class();</code>?</p>\n<pre><code>#include &lt;new&gt;\n\nclass Class\n{\npublic:\n  Class() {}\n  ~Class() {}\n  int x;\n};\n\nint main()\n{\n  Class object;\n  object.x = 1;\n  object.~Class();\n  new (&amp;object) Class();\n\n  object.x == ?\n\n  Class object_2;\n  object_2.x = 1;\n  new (&amp;object_2) Class();\n\n  object_2.x == ?\n\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><oop><standards><language-lawyer>", "OwnerUserId": "1146657", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35383453_35383576_2": {"section_id": 7189, "quality": 0.7142857142857143, "length": 5}, "so_35383453_35383576_14": {"section_id": 3286, "quality": 0.6666666666666666, "length": 4}, "so_35383453_35383576_5": {"section_id": 398, "quality": 0.75, "length": 6}, "so_35383453_35383576_15": {"section_id": 3286, "quality": 1.0, "length": 11}, "so_35383453_35383576_8": {"section_id": 444, "quality": 0.8421052631578947, "length": 16}, "so_35383453_35383576_9": {"section_id": 6098, "quality": 0.7777777777777778, "length": 7}, "so_35383453_35383576_11": {"section_id": 3295, "quality": 0.7777777777777778, "length": 14}, "so_35383453_35383576_6": {"section_id": 407, "quality": 0.5714285714285714, "length": 4}, "so_35383453_35383576_12": {"section_id": 3296, "quality": 0.7777777777777778, "length": 21}, "so_35383453_35383576_3": {"section_id": 7191, "quality": 0.7333333333333333, "length": 11}, "so_35383453_35383576_17": {"section_id": 3291, "quality": 0.75, "length": 12}, "so_35383453_35383576_16": {"section_id": 435, "quality": 0.6071428571428571, "length": 17}, "so_35383453_35383576_7": {"section_id": 411, "quality": 0.7777777777777778, "length": 7}, "so_35383453_35383576_4": {"section_id": 7192, "quality": 0.9245283018867925, "length": 49}, "so_35383453_35383576_13": {"section_id": 3287, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_35383453_35383576_11": {"section_id": 3165, "quality": 0.7777777777777778, "length": 14}, "so_35383453_35383576_2": {"section_id": 6933, "quality": 0.7142857142857143, "length": 5}, "so_35383453_35383576_14": {"section_id": 3156, "quality": 0.6666666666666666, "length": 4}, "so_35383453_35383576_5": {"section_id": 389, "quality": 0.75, "length": 6}, "so_35383453_35383576_15": {"section_id": 3156, "quality": 1.0, "length": 11}, "so_35383453_35383576_8": {"section_id": 435, "quality": 0.8421052631578947, "length": 16}, "so_35383453_35383576_6": {"section_id": 398, "quality": 0.7142857142857143, "length": 5}, "so_35383453_35383576_12": {"section_id": 3166, "quality": 0.7777777777777778, "length": 21}, "so_35383453_35383576_9": {"section_id": 5864, "quality": 0.7777777777777778, "length": 7}, "so_35383453_35383576_3": {"section_id": 6935, "quality": 0.7333333333333333, "length": 11}, "so_35383453_35383576_17": {"section_id": 3161, "quality": 0.875, "length": 14}, "so_35383453_35383576_16": {"section_id": 427, "quality": 0.8928571428571429, "length": 25}, "so_35383453_35383576_7": {"section_id": 402, "quality": 0.7777777777777778, "length": 7}, "so_35383453_35383576_4": {"section_id": 6936, "quality": 0.9245283018867925, "length": 49}, "so_35383453_35383576_13": {"section_id": 3157, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_35383453_35383576_11": {"section_id": 4057, "quality": 0.5555555555555556, "length": 10}, "so_35383453_35383576_2": {"section_id": 8697, "quality": 0.7142857142857143, "length": 5}, "so_35383453_35383576_5": {"section_id": 415, "quality": 0.75, "length": 6}, "so_35383453_35383576_15": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}, "so_35383453_35383576_8": {"section_id": 467, "quality": 0.8421052631578947, "length": 16}, "so_35383453_35383576_9": {"section_id": 7595, "quality": 0.7777777777777778, "length": 7}, "so_35383453_35383576_12": {"section_id": 4058, "quality": 0.7777777777777778, "length": 21}, "so_35383453_35383576_6": {"section_id": 425, "quality": 0.5714285714285714, "length": 4}, "so_35383453_35383576_3": {"section_id": 8700, "quality": 0.7333333333333333, "length": 11}, "so_35383453_35383576_17": {"section_id": 4053, "quality": 0.75, "length": 12}, "so_35383453_35383576_16": {"section_id": 454, "quality": 0.6071428571428571, "length": 17}, "so_35383453_35383576_7": {"section_id": 429, "quality": 0.7777777777777778, "length": 7}, "so_35383453_35383576_4": {"section_id": 8701, "quality": 0.9245283018867925, "length": 49}}}});