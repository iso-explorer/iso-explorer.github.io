post_cb({"29708537": {"ParentId": "29708242", "CommentCount": "0", "Body": "<p>Your code exhibits undefined behavior, according to the progress guarantee rule in section 1.10:</p>\n<blockquote>\n<p id=\"so_29708242_29708537_0\">The implementation may assume that any thread will eventually do one of the following:</p>\n<ul>\n<li>terminate,</li>\n<li>make  a  call  to  a  library  I/O  function,</li>\n<li>access  or  modify  a  volatile  object,  or</li>\n<li>perform  a  synchronization  operation  or  an  atomic  operation.</li>\n</ul>\n<p id=\"so_29708242_29708537_1\">[ Note:   This  is  intended  to  allow  compiler  transformations  such  as  removal  of  empty  loops,  even  when termination cannot be proven.  \u2014 end note ]</p>\n</blockquote>\n<p>Because your loop does none of these, the optimizer may assume the loop is never entered, and remove it completely.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "29708537", "Score": "1", "CreationDate": "2015-04-17T20:12:39.060", "LastActivityDate": "2015-04-17T20:12:39.060"}, "29708242": {"CommentCount": "7", "ViewCount": "139", "CreationDate": "2015-04-17T19:53:33.287", "LastActivityDate": "2015-04-18T03:28:17.180", "Title": "Why does GCC optimize away this incrementation?", "AcceptedAnswerId": "29708410", "PostTypeId": "1", "Id": "29708242", "Score": "3", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n\nuint64_t counter = 0;\n\n#define __STDC_FORMAT_MACROS\n#include &lt;inttypes.h&gt;\n\nvoid sig_handler(int signo) {\n   printf( \"%\" PRIu64 \"\\n\", counter);\n\n}\n\nint main() {\n    struct sigaction act;\n    act.sa_handler = &amp;sig_handler;\n    sigaction(SIGINT, &amp;act, NULL);\n\n    for( ;; ) {\n        counter++;\n    }\n    return 0;\n}\n</code></pre>\n<p>If I compile the code with <code>-O0</code>, I can see that the counter gets incremented when I press CTR+C. With <code>-O1</code>, this is optimized away. Why is that and how could I avoid it?</p>\n", "Tags": "<c++><gcc><optimization>", "OwnerUserId": "1091116", "AnswerCount": "2"}, "29708410": {"ParentId": "29708242", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It looks like the following section of the draft C++11 standard is relevant section <code>1.9</code> <em>[intro.execution]</em>:</p>\n<blockquote>\n<p id=\"so_29708242_29708410_0\">When the processing of the abstract machine is interrupted by receipt\n  of a signal, the values of objects which are neither</p>\n<ul>\n<li>of type volatile std::sig_atomic_t nor</li>\n<li>lock-free atomic objects (29.4)</li>\n</ul>\n<p id=\"so_29708242_29708410_1\">are unspecified during the execution of the signal handler, and the\n  value of any object not in either of these two categories that is\n  modified by the handler becomes undefined.</p>\n</blockquote>\n<p>Since <code>counter</code> is nether <em>volatile</em> nor an <em>atomic object</em> the value is unspecified and therefore the compiler is allowed to optimize it away via the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow\">as-if rule</a>.</p>\n<p>The wording changed in C++14 draft and we have the following:</p>\n<blockquote>\n<p id=\"so_29708242_29708410_2\">If a signal handler is executed as a result of a call to the raise function, then the execution of the handler is\n  sequenced after the invocation of the raise function and before its return. [ Note: When a signal is received\n  for another reason, the execution of the signal handler is usually unsequenced with respect to the rest of the\n  program. \u2014end note ]</p>\n</blockquote>\n<p>which seems to leave it unspecified in a sense, since the it is only the note that says the sequence handler is unsequenced, but if we read <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3910.html\" rel=\"nofollow\">N3910: N3910: What can signal handlers do? (CWG 1441)</a> we can see that this seems to be considered a data race and thus undefined behavior.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-04-18T03:28:17.180", "Id": "29708410", "Score": "4", "CreationDate": "2015-04-17T20:03:50.257", "LastActivityDate": "2015-04-18T03:28:17.180"}, "bq_ids": {"n4140": {"so_29708242_29708537_1": {"section_id": 5838, "quality": 0.7647058823529411, "length": 13}, "so_29708242_29708410_2": {"section_id": 5802, "quality": 0.9090909090909091, "length": 30}, "so_29708242_29708537_0": {"section_id": 5838, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_29708242_29708537_1": {"section_id": 5608, "quality": 0.7647058823529411, "length": 13}, "so_29708242_29708410_1": {"section_id": 5575, "quality": 1.0, "length": 14}, "so_29708242_29708410_0": {"section_id": 5575, "quality": 1.0, "length": 10}, "so_29708242_29708537_0": {"section_id": 5608, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_29708242_29708410_2": {"section_id": 7274, "quality": 0.8484848484848485, "length": 28}, "so_29708242_29708537_1": {"section_id": 7300, "quality": 0.7647058823529411, "length": 13}, "so_29708242_29708537_0": {"section_id": 7300, "quality": 0.8888888888888888, "length": 8}}}});