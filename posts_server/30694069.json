post_cb({"bq_ids": {"n4140": {"so_30694069_30694084_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7183}, "so_30694069_30694084_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 9}, "so_30694069_30694084_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 7183}, "so_30694069_30694084_4": {"length": 19, "quality": 0.95, "section_id": 6155}}, "n3337": {"so_30694069_30694084_4": {"length": 15, "quality": 0.75, "section_id": 5917}}, "n4659": {"so_30694069_30694084_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 8671}, "so_30694069_30694084_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 8671}, "so_30694069_30694084_3": {"length": 8, "quality": 0.5714285714285714, "section_id": 10}, "so_30694069_30694084_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 8671}, "so_30694069_30694084_4": {"length": 14, "quality": 0.7, "section_id": 7652}}}, "30694069": {"ViewCount": "2152", "Body": "<p>Is it legal to compare dangling pointers?</p>\n<pre><code>int *p, *q;\n{\n    int a;\n    p = &amp;a;\n}\n{\n    int b;\n    q = &amp;b;\n}\nstd::cout &lt;&lt; (p == q) &lt;&lt; '\\n';\n</code></pre>\n<p>Note how both <code>p</code> and <code>q</code> point to objects that have already vanished. Is this legal?</p>\n", "Title": "Is it legal to compare dangling pointers?", "CreationDate": "2015-06-07T13:27:11.320", "LastActivityDate": "2017-10-03T19:51:37.960", "CommentCount": "13", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-06-07T13:37:06.537", "LastEditorUserId": "3002139", "Id": "30694069", "Score": "68", "OwnerUserId": "252000", "Tags": "<c++><pointers><language-lawyer><dangling-pointer>", "AnswerCount": "3"}, "30694084": {"Id": "30694084", "PostTypeId": "2", "Body": "<p><strong>Introduction:</strong> The first issue is whether it is legal to use the value of <code>p</code> at all.</p>\n<p>After <code>a</code> has been destroyed, <code>p</code> acquires what is known as an <em>invalid pointer value</em>. Quote from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4430.html\">N4430</a> (for discussion of N4430's status see the \"Note\" below):</p>\n<blockquote>\n<p id=\"so_30694069_30694084_0\">When the end of the duration of a region of storage is reached, the values of all pointers representing the address of any part of the deallocated storage become <strong>invalid pointer values</strong>. </p>\n</blockquote>\n<p>The behaviour when an invalid pointer value is used is also covered in the same section of N4430 (and almost identical text appears in C++14  [basic.stc.dynamic.deallocation]/4):</p>\n<blockquote>\n<p id=\"so_30694069_30694084_1\">Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has <strong>implementation-defined behavior</strong>.</p>\n<p id=\"so_30694069_30694084_2\">[ <em>Footnote:</em> Some implementations might define that copying an invalid pointer value causes a system-generated runtime fault. \u2014 end footnote ]</p>\n</blockquote>\n<p>So you will need to consult your implementation's documentation to find out what should happen here (since C++14).</p>\n<p>The term <em>use</em> in the above quotes <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#312\">means</a> necessitating lvalue-to-rvalue conversion, as in C++14 [conv.lval/2]:</p>\n<blockquote>\n<p id=\"so_30694069_30694084_3\">When an lvalue-to-rvalue conversion is applied to an expression e, and [...]  the object to which the glvalue refers contains an invalid pointer value, the behaviour is implementation-defined.</p>\n</blockquote>\n<hr>\n<p><strong>History:</strong> In C++11 this said <em>undefined</em> rather than <em>implementation-defined</em>; it was changed by <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1438\">DR1438</a>.  See the edit history of this post for the full quotes.</p>\n<hr>\n<p><strong>Application to <code>p == q</code>:</strong> Supposing we have accepted in C++14+N4430 that the result of evaluating <code>p</code> and <code>q</code> is implementation-defined, and that the implementation does not define that a hardware trap occurs; [expr.eq]/2 says:</p>\n<blockquote>\n<p id=\"so_30694069_30694084_4\">Two pointers compare equal if they are both null, both point to the same function, or both represent the same address (3.9.2), otherwise they compare unequal.</p>\n</blockquote>\n<p>Since it's implementation-defined what values are obtained when <code>p</code> and <code>q</code> are evaluated, we can't say for sure what will happen here. But it must be either implementation-defined or unspecified.  </p>\n<p>g++ appears to exhibit unspecified behaviour in this case; depending on the <code>-O</code> switch I was able to have it say either <code>1</code> or <code>0</code>, corresponding to whether or not the same memory address was re-used for <code>b</code> after <code>a</code> had been destroyed.</p>\n<hr>\n<p><strong>Note about N4430:</strong> This is a proposed defect resolution to C++14, that hasn't been accepted yet. It cleans up a lot of wording surrounding object lifetime, invalid pointers, subobjects, unions, and array bounds access. </p>\n<p>In the C++14 text, it is defined under [basic.stc.dynamic.deallocation]/4 and subsequent paragraphs that an <em>invalid pointer value</em> arises when <code>delete</code> is used. However it's not clearly stated whether or not the same principle applies to static or automatic storage.</p>\n<p>There is a definition \"valid pointer\" in [basic.compound]/3 but it is too vague to use sensibly.The [basic.life]/5 (footnote) refers to the same text to define the behaviour of pointers to objects of static storage duration, which suggests that it was meant to apply to all types of storage.</p>\n<p>In N4430 the text is moved from that section up one level so that it does clearly apply to all storage durations. There is a note attached:</p>\n<blockquote>\n<p id=\"so_30694069_30694084_5\"><em>Drafting note:</em> this should apply to all storage durations that can end, not just to dynamic storage duration. On an implementation supporting threads or segmented stacks, thread and automatic storage may behave in the same way that dynamic storage does.</p>\n</blockquote>\n<hr>\n<p><em>My opinion:</em> I don't see any consistent way to interpret the standard (pre-N4430) other than to say that <code>p</code> acquires an invalid pointer value. The behaviour doesn't seem to be covered by any other section besides what we have already looked at. So I am happy to treat the N4430 wording as representing the intent of the standard in this case.</p>\n<hr>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2015-06-09T02:37:17.527", "Score": "54", "CreationDate": "2015-06-07T13:28:47.940", "ParentId": "30694069", "CommentCount": "42", "OwnerUserId": "1505939", "LastEditDate": "2015-06-09T02:37:17.527"}, "30714070": {"Id": "30714070", "PostTypeId": "2", "Body": "<p>Historically, there have been some systems where using a pointer as an rvalue might cause the system to fetch some information identified by some bits in that pointer.  For example, if a pointer could contain the address of an object's header along with an offset into the object, fetching a pointer could cause the system to also fetch some information from that header.  If the object has ceased to exist, the attempt to fetch information from its header could fail with arbitrary consequences.</p>\n<p>That having been said, in the vast majority of C implementations, all pointers that were alive at some particular moment in time will forever hold the same relationships with regard to the relational and subtraction operators as they had at that particular time.  Indeed, in most implementations if one has <code>char *p</code>, one may determine whether it identifies part of an object identified by <code>char *base; size_t size;</code> by checking whether <code>(size_t)(p-base) &lt; size</code>; such comparison will work even retrospectively if there is any overlap in the objects' lifetime.</p>\n<p>Unfortunately, the Standard defines no means by which code can indicate that it requires any of the latter guarantees, nor is there a standard means by which code can ask whether a particular implementation can promise any of the latter behaviors and refuse compilation if it does not.  Further, some hyper-modern implementations will regard any use of relational or subtraction operators on two pointers as a promise by the programmer that the pointers in question will always identify the same live object, and omit any code which would only be relevant if that assumption didn't hold.  Consequently, even though many hardware platforms would be able to offer guarantees that would be useful to many algorithms, there's no safe way by which code can exploit any such guarantees even if code will never need to run on hardware which does not naturally provide them.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2017-10-03T19:51:37.960", "Score": "4", "CreationDate": "2015-06-08T16:05:59.580", "ParentId": "30694069", "CommentCount": "0", "OwnerUserId": "363751", "LastEditDate": "2017-10-03T19:51:37.960"}, "30759795": {"Id": "30759795", "PostTypeId": "2", "Body": "<p>The pointers contain the addresses of the variables they reference.  The addresses are valid even when the variables that used to be stored there are released / destroyed / unavailable.\nAs long as you don't try to use the values at those addresses you are safe, meaning *p and *q will be undefined.</p>\n<p>Obviously the result is implementation defined, therefore this code example can be used to study the features of your compiler if one doesn't want to dig into to assembly code.</p>\n<p>Whether this is a meaningful practice is totally different discussion.</p>\n", "LastEditorUserId": "2038893", "LastActivityDate": "2017-08-03T06:01:55.403", "Score": "-3", "CreationDate": "2015-06-10T14:46:54.317", "ParentId": "30694069", "CommentCount": "2", "OwnerUserId": "2038893", "LastEditDate": "2017-08-03T06:01:55.403"}});