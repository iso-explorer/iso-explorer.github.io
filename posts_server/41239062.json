post_cb({"bq_ids": {"n4140": {"so_41239062_41239457_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 369}}, "n3337": {"so_41239062_41239457_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 359}}, "n4659": {"so_41239062_41239457_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 382}}}, "41239457": {"Id": "41239457", "PostTypeId": "2", "Body": "<p>The problem here is that the templated constructor hides the inherited constructor. From \u00a712.9/4:</p>\n<blockquote>\n<p id=\"so_41239062_41239457_0\">A constructor so declared [...]. It is deleted if the corresponding constructor in X is deleted (8.4.3) or if a defaulted default constructor (12.1) would be deleted, [...].</p>\n</blockquote>\n<p>The following compiles without problem:</p>\n<pre><code>struct C: A {\n    using A::A;\n};\nstatic_assert(std::is_nothrow_constructible&lt;C&gt;{}, \"\");\n</code></pre>\n", "LastEditorUserId": "2666289", "LastActivityDate": "2016-12-20T10:14:50.177", "Score": "6", "CreationDate": "2016-12-20T09:56:25.073", "ParentId": "41239062", "CommentCount": "3", "OwnerUserId": "2666289", "LastEditDate": "2016-12-20T10:14:50.177"}, "41239062": {"ViewCount": "130", "Body": "<p>Consider following two examples:</p>\n<pre><code>struct A {\n    A () noexcept = default;\n};\n\nstruct B : A {\n    B () noexcept = default;\n\n    template &lt;typename T&gt;\n    B (T) noexcept {}\n};\n\nstruct C : A {\n    using A::A;\n\n    template &lt;typename T&gt;\n    C (T) noexcept {} \n};\n</code></pre>\n<p>and usage:</p>\n<pre><code>std::cout &lt;&lt; std::is_nothrow_constructible&lt;B&gt;::value &lt;&lt; std::endl; // (X)\nstd::cout &lt;&lt; std::is_nothrow_constructible&lt;B, int&gt;::value &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; std::is_nothrow_constructible&lt;C&gt;::value &lt;&lt; std::endl; // (Y)\nstd::cout &lt;&lt; std::is_nothrow_constructible&lt;C, int&gt;::value &lt;&lt; std::endl;\n</code></pre>\n<p>Output is:</p>\n<pre><code>1\n1\n0\n1\n</code></pre>\n<p>Compiler used: GCC 4.8.1.</p>\n<p>So, If I write explicitly default <code>B</code> constructor, <code>(X)</code> produces 1, on the other hand if default <code>C</code> constructor is available because of the inheritance, <code>(Y)</code> produces 0. Why is that?</p>\n<p><strong>Does it mean that inherited constructors are not taken into account when <code>is_nothrow_constructible</code> trait is used?</strong></p>\n", "AcceptedAnswerId": "41239457", "Title": "std::is_nothrow_constructible when constructor is inherited", "CreationDate": "2016-12-20T09:38:05.027", "Id": "41239062", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-12-20T10:14:50.177", "Score": "5", "OwnerUserId": "3671410", "Tags": "<c++><c++11>", "AnswerCount": "1"}});