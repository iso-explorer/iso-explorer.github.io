post_cb({"25868107": {"CommentCount": "5", "ViewCount": "277", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2014-09-16T11:54:50.657", "LastActivityDate": "2014-09-16T12:12:54.707", "Title": "Does std::vector::erase() invalidate the iterator at the point of erase?", "AcceptedAnswerId": "25868340", "LastEditDate": "2014-09-16T12:05:09.980", "Id": "25868107", "Score": "6", "Body": "<p>C++03 Standard \u00a7 23.2.4.3/3 describes <code>std::vector::erase(iterator position)</code> and says specifically</p>\n<blockquote>\n<p id=\"so_25868107_25868107_0\">Invalidates all the iterators and references after the point of the erase.</p>\n</blockquote>\n<p>Is the iterator <em>at</em> the point of the erase not invalidated? Specifically if I have a <code>vector</code> with a single element and I copy <code>begin()</code> iterator into a local variable and then call</p>\n<pre><code>vec.erase(vec.begin())\n</code></pre>\n<p>Will that iterator I have in a local variable get invalidated or not?</p>\n<p>Will the iterators be invalidated <em>after</em> the point of erasure or <em>after and including</em> the point of erasure?</p>\n", "Tags": "<c++><vector><erase><c++03>", "OwnerUserId": "57428", "AnswerCount": "2"}, "25868425": {"ParentId": "25868107", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-16T12:11:41.270", "Score": "0", "LastEditorUserId": "3747990", "LastEditDate": "2014-09-16T12:12:54.707", "Id": "25868425", "OwnerUserId": "4007560", "Body": "<p>The complexity of <code>vector::erase()</code> says: Linear on the number of elements erased (destructions) plus the number of elements after the last element deleted (moving).</p>\n<p>It seems to me that it is implemented as a lazy grow/shrink array.  The iterator, a pointer to the data, when erased, the following data will copied into its place.  And thus the iterator you keep, will point to some data else, provided that the data you erase is not the last one.</p>\n<p>In fact, it may depend on implementation.  Yet I think a lazy grow/shrink array is the best-fit implementation for <code>vector::erase()</code>. [Since it may depends on implementation, don't count on anything like invalidate...]</p>\n", "LastActivityDate": "2014-09-16T12:12:54.707"}, "25868340": {"ParentId": "25868107", "CommentCount": "1", "CreationDate": "2014-09-16T12:07:20.873", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "25868340", "Score": "7", "Body": "<p>I'd say that your example with erasing the only element in the vector shows that the iterator at the insertion point <em>must</em> be invalidated.</p>\n<p>Anyway, in C++11, the wording has been changed (23.3.6.5/3):</p>\n<blockquote>\n<p id=\"so_25868107_25868340_0\"><em>Effects:</em> Invalidates iterators and references at or after the point of the erase.</p>\n</blockquote>\n", "LastActivityDate": "2014-09-16T12:07:20.873"}, "bq_ids": {"n4140": {"so_25868107_25868340_0": {"section_id": 988, "quality": 0.8571428571428571, "length": 6}, "so_25868107_25868107_0": {"section_id": 988, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_25868107_25868340_0": {"section_id": 973, "quality": 0.8571428571428571, "length": 6}, "so_25868107_25868107_0": {"section_id": 973, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_25868107_25868340_0": {"section_id": 1051, "quality": 0.8571428571428571, "length": 6}, "so_25868107_25868107_0": {"section_id": 1051, "quality": 0.8571428571428571, "length": 6}}}});