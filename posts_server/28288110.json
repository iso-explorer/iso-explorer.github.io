post_cb({"bq_ids": {"n4140": {"so_28288110_28288167_5": {"length": 22, "quality": 0.88, "section_id": 7061}, "so_28288110_28288167_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 3882}, "so_28288110_28288167_6": {"length": 29, "quality": 1.0, "section_id": 5555}, "so_28288110_28288167_8": {"length": 39, "quality": 1.0, "section_id": 5557}, "so_28288110_28288167_7": {"length": 15, "quality": 0.6818181818181818, "section_id": 5556}}, "n3337": {"so_28288110_28288167_5": {"length": 22, "quality": 0.88, "section_id": 6805}, "so_28288110_28288167_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 3742}, "so_28288110_28288167_6": {"length": 29, "quality": 1.0, "section_id": 5337}, "so_28288110_28288167_8": {"length": 39, "quality": 1.0, "section_id": 5339}, "so_28288110_28288167_7": {"length": 15, "quality": 0.6818181818181818, "section_id": 5338}}, "n4659": {"so_28288110_28288167_5": {"length": 22, "quality": 0.88, "section_id": 8558}, "so_28288110_28288167_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 4771}, "so_28288110_28288167_6": {"length": 18, "quality": 0.6206896551724138, "section_id": 7000}, "so_28288110_28288167_8": {"length": 39, "quality": 1.0, "section_id": 7002}, "so_28288110_28288167_7": {"length": 15, "quality": 0.6818181818181818, "section_id": 7001}}}, "28288110": {"ViewCount": "106", "Body": "<pre><code>int main()\n{\n    string s(\"some string\");\n    if (s.begin() != s.end())\n        auto it = s.begin();\n    *it = toupper (*it) ; // Error ; the identifier \"it\" is undefined \n}\n</code></pre>\n<p>Why is *it undefined? And do why we need to use dereference in the iterator dimension?</p>\n", "Title": "What is the purpose of * in C++?", "CreationDate": "2015-02-02T22:36:17.120", "LastActivityDate": "2015-04-26T14:15:08.987", "CommentCount": "0", "LastEditDate": "2015-04-26T14:15:08.987", "PostTypeId": "1", "LastEditorUserId": "951423", "Id": "28288110", "Score": "-11", "OwnerUserId": "4358961", "Tags": "<c++><iterator><dereference>", "AnswerCount": "1"}, "28288167": {"Id": "28288167", "PostTypeId": "2", "Body": "<h2>Short</h2>\n<ol>\n<li>The code doesn't work because <code>it</code> is defined in the scope of the <code>if</code> branch.</li>\n<li>Dereferencing is required to access the actual \"content\", the iterator is referencing.</li>\n</ol>\n<h2>Explanation</h2>\n<h3>1. Why is <code>it</code> undefined after the selection statement?</h3>\n<p>The standard says (emphasis mine) in <strong>\u00a7 6.4 / 1:</strong> </p>\n<blockquote>\n<p id=\"so_28288110_28288167_0\">The substatement in a selection-statement (each substatement, in the else form of the if statement) implicitly defines a block scope (3.3). <strong>If the substatement in a selection-statement is a single statement</strong> and not a compound-statement, <strong>it is as if it was rewritten to be a compound-statement containing the original substatement</strong>.</p>\n</blockquote>\n<p>The example given in the standard matches the case at hand.</p>\n<blockquote>\n<p id=\"so_28288110_28288167_1\">Example:</p>\n<p id=\"so_28288110_28288167_2\"><code>if (x) \n  int i;</code></p>\n<p id=\"so_28288110_28288167_3\">can be equivalently rewritten as</p>\n<p id=\"so_28288110_28288167_4\"><code>if (x)\n  {\n    int i;\n  }</code></p>\n</blockquote>\n<p>Now we need to know how the (implicit) block scope affects the \"visibility\" of the variable by looking at the referenced <strong>\u00a7 3.3</strong> (again emphasis mine):</p>\n<blockquote>\n<p id=\"so_28288110_28288167_5\">A name declared in a block (6.3) is local to that block; it has block scope. <strong>Its</strong> potential <strong>scope</strong> begins at its point of declaration (3.3.2) and <strong>ends at the end of its block</strong>. A variable declared at block scope is a local variable.</p>\n</blockquote>\n<p><strong>=&gt;There you go: Your variable <code>it</code> is in a block and the scope of <code>it</code> ends at the end of the block. Thus it is undefined after that block.</strong></p>\n<h3>2. Why is an iterator to be dereferenced to access the content?</h3>\n<p>The conecept of iterators is built to abstract pointers as described in chapter 24 for the Iterator library in the standard. Thus, an iterator <em>references</em> something like a pointer also references a value. \nDereferencing is the C++ way of accessing the actual referenced value.</p>\n<p>Dereferencing a pointer means \"give me the value stored at the memory address of the pointer\" whereas dereferencing an iterator means \"give me the value stored at the point, the iterator logic is refering to\".</p>\n<p>(<em>Note: A pointer is just a special kind of iterator.</em>)</p>\n<p>The standard requires every iterator type to define the dereferencing operation.</p>\n<p><strong>\u00a7 24.2.1 / 1</strong></p>\n<blockquote>\n<p id=\"so_28288110_28288167_6\">All input iterators i support the expression <code>*i</code>, resulting in a value of some object type <code>T</code>, called the <em>value type</em> of the iterator. All output iterators support the expression <code>*i = o</code> where <code>o</code> is a value of some type that is in the set of types that are writable to the particular iterator type of <code>i</code>.</p>\n</blockquote>\n<p><strong>Every iterator type is either input or output.</strong></p>\n<p><strong>\u00a7 24.2.1 / 2:</strong> Types of iterators</p>\n<blockquote>\n<p id=\"so_28288110_28288167_7\">This International Standard defines five categories of iterators, according to the operations defined on them: input iterators, output iterators, forward iterators, bidirectional iterators and random access iterators[.]</p>\n</blockquote>\n<p><strong>\u00a7 24.2.1 / 3:</strong> Correlation of iterators types</p>\n<blockquote>\n<p id=\"so_28288110_28288167_8\">Forward iterators satisfy all the requirements of input iterators and can be used whenever an input iterator is specified; Bidirectional iterators also satisfy all the requirements of forward iterators and can be used whenever a forward iterator is specified; Random access iterators also satisfy all the requirements of bidirectional iterators and can be used whenever a bidirectional iterator is specified.</p>\n</blockquote>\n<p><strong>=&gt; Iterators provide indirection (in a more generalized fashion than pointers do) and need to be dereferenced to follow the indirection, accessing <em>their</em> values.</strong></p>\n<h3>3. Working example</h3>\n<pre><code>#include &lt;string&gt;\n#include &lt;cctype&gt;\nint main()\n{\n  std::string s(\"some string\");\n  if (s.begin() != s.end())\n  {\n    auto it = s.begin();\n    *it = std::toupper(*it); \n  }\n  // it not defined here\n  return 0; \n}\n</code></pre>\n", "LastEditorUserId": "951423", "LastActivityDate": "2015-04-26T13:37:53.927", "Score": "10", "CreationDate": "2015-02-02T22:39:45.080", "ParentId": "28288110", "CommentCount": "2", "OwnerUserId": "951423", "LastEditDate": "2015-04-26T13:37:53.927"}});