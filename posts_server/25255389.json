post_cb({"bq_ids": {"n4140": {"so_25255389_25255407_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 7183}}, "n3337": {"so_25255389_25255407_1": {"length": 30, "quality": 0.7894736842105263, "section_id": 6927}}}, "25255389": {"ViewCount": "1842", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\" rel=\"nofollow\">cppreference</a> I learn that there is a constructor for <code>std::shared_ptr</code>:</p>\n<pre><code>template&lt; class Y &gt; explicit shared_ptr( Y* ptr );\n</code></pre>\n<p>And I tried a piece of code as follows:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nint main(void) {\n  /// block 1\n  {\n    std::shared_ptr&lt;std::string&gt; s1(new std::string(\"good\"));\n    std::shared_ptr&lt;std::string&gt; s2(s1.get()); /// s2\n    std::cerr &lt;&lt; s2.use_count() &lt;&lt; std::endl;\n  }\n  /// block 2\n  {\n    std::shared_ptr&lt;int&gt; i1(new int(1));\n    std::shared_ptr&lt;int&gt; i2(i1.get());  ///  i2\n    std::cerr &lt;&lt; i2.use_count() &lt;&lt; std::endl;\n  }\n  return 0;\n}\n</code></pre>\n<p>It causes segment fault for <em>block 1</em> but not for <em>block 2</em>, but both <code>use_count</code> are 1. The difference I can think about is that that <code>int</code> is a primitive type while <code>std::string</code> is managed by allocator.</p>\n<p>I read <code>bits/shared_ptr.h</code> of <code>gcc-4.9</code> and find that there is a post condition for this constructor:</p>\n<pre><code>use_count() == 1 &amp;&amp; get() == __p\n</code></pre>\n<h2>Question 1:</h2>\n<p>Should <code>std::shared_ptr</code> NOT constructed with a raw pointer that has been referenced by <em>another smart pointer</em>? In this sense, is the preferred way to use this constructor as follow?</p>\n<pre><code>std::shared_ptr&lt;T&gt;(new T(...));\n</code></pre>\n<h2>Question 2:</h2>\n<p>Does the standard has explicit requirement for this constructor, or this post condition is ONLY for <code>libstdc++</code>?</p>\n", "AcceptedAnswerId": "25255423", "Title": "segment fault for a simple std::shared_ptr construction case", "CreationDate": "2014-08-12T02:44:57.553", "Id": "25255389", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-08-12T03:20:08.190", "Score": "4", "OwnerUserId": "528929", "Tags": "<c++><c++11><memory-management><shared-ptr><smart-pointers>", "AnswerCount": "2"}, "25255407": {"PostTypeId": "2", "Body": "<p>This is undefined behavior, we can see this by going to cppreference section for <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\" rel=\"nofollow\">std::shared_ptr constructors</a> says this (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_25255389_25255407_0\"><strong>Constructing a shared_ptr using the raw pointer overload for an object\n  that is already managed by a shared_ptr leads to undefined behavior</strong>,\n  even if the object is of a type derived from\n  std::enable_shared_from_this (in other words, raw pointer overloads\n  assume ownership of the pointed-to object).</p>\n</blockquote>\n<p>Both <code>shared_ptr</code> will attempt to delete the object they believe they now hold sole ownership for. We know this is undefined behavior by going to the draft C++ standard section <code>3.7.4.2</code> <em>Deallocation functions</em> which says:</p>\n<blockquote>\n<p id=\"so_25255389_25255407_1\">If the argument given to a deallocation function in the standard\n  library is a pointer that is not the null pointer value (4.10), the\n  deallocation function shall deallocate the storage referenced by the\n  pointer, rendering invalid all pointers referring to any part of the\n  deallocated storage. Indirection through an invalid pointer value and\n  <strong>passing an invalid pointer value to a deallocation function have\n  undefined behavior.</strong> [...]</p>\n</blockquote>\n<p>Ownership can only be shared by using copy construction or copy assignment. The same cppreference page provides a correct example using the copy constructor:</p>\n<pre><code> std::cout &lt;&lt; \"constructor with object\\n\";\n std::shared_ptr&lt;Foo&gt; sh2(new Foo);\n std::shared_ptr&lt;Foo&gt; sh3(sh2);     // &lt;- using copy construction\n</code></pre>\n<p>An alternative method to creating a <code>shared_ptr</code> is to use <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\" rel=\"nofollow\">std::make_shared</a>, which is safer:</p>\n<blockquote>\n<p id=\"so_25255389_25255407_2\">Moreover, code such as f(std::shared_ptr(new int(42)), g()) can\n  cause a memory leak if g throws an exception because g() may be called\n  after new int(42) and before the constructor of shared_ptr. This\n  doesn't occur in f(std::make_shared(42), g()), since two function\n  calls are never interleaved.</p>\n</blockquote>\n", "LastActivityDate": "2014-08-12T03:20:08.190", "LastEditorUserId": "1708801", "Id": "25255407", "CommentCount": "2", "CreationDate": "2014-08-12T02:49:05.053", "ParentId": "25255389", "Score": "3", "OwnerUserId": "1708801", "LastEditDate": "2014-08-12T03:20:08.190"}, "25255423": {"PostTypeId": "2", "Body": "<p>Both of these cases are invalid uses of <code>std::shared_ptr</code>.</p>\n<p>You cannot pass the same raw pointer to <strong>two</strong> <code>std::shared_ptr</code> constructors and expect well-defined results.  <strong>Both</strong> <code>std::shared_ptr</code>s will believe that they <strong>own</strong> that pointer, and will attempt to delete it when they go out of scope.</p>\n<p>This is a double free, and is invalid.</p>\n<p>If you want to have two <code>std::shared_ptr</code>s that manage the same object, you can construct one of them with a raw pointer (or, better yet, use <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\"><code>std::make_shared</code></a>), and then copy construct/assign the second one from the first one.  This way the memory will only be deallocated (and the destructor for the object fired) when the <strong>last</strong> of those <code>std::shared_ptr</code>s goes out of scope.</p>\n<p>The reason you're getting a segmentation fault in the first case, and not the second one, is likely because <code>int</code> is a trivial type, and therefore you're not looking through a freed pointer to run the destructor of <code>int</code>, because it doesn't have one.</p>\n", "LastActivityDate": "2014-08-12T02:50:39.137", "Id": "25255423", "CommentCount": "0", "CreationDate": "2014-08-12T02:50:39.137", "ParentId": "25255389", "Score": "8", "OwnerUserId": "1007504"}});