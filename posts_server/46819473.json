post_cb({"46819473": {"ViewCount": "143", "Body": "<p>In a program written in C++ and compiled with MinGW-w64 under windows, I read several files concurrently in separate threads. Since the file names may have non ASCII characters, I cannot use the C++ standard library <code>std::ifstream</code> as it does not support <code>wchar</code> file names. So I need to use the C library with <code>_wfopen</code> from the Win32 API.</p>\n<p>However, I get a very strange bug which I have reproduced in a MCVE. After reading n bytes with fread(), the result from <code>_ftelli64</code> is sometimes not increased by n, but by a few bytes less or more.</p>\n<p>With single thread reading, the issue is gone, and with <code>std::ifstream</code> as well.</p>\n<p>It acts as if there was a race condition in fread, which would then be non-reentrant.</p>\n<p>In the following example, I replaced <code>_wfopen</code> by <code>fopen</code> as the bug is still there.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;fstream&gt;\n#include &lt;thread&gt;\n\nconstexpr const int numThreads = 8;\nconstexpr const int blockSize = 65536+8;\nconstexpr const int fileBlockCount = 48; //3MB files\n\nvoid readFile(const std::string &amp; path)\n{\n    std::cout &lt;&lt; \"Reading file \" &lt;&lt; path &lt;&lt; \"\\n\";\n    std::vector&lt;char&gt; buffer(blockSize);\n\n    FILE * f = fopen(path.c_str(), \"rb\");\n    for(int i=0;i&lt;fileBlockCount;++i)\n    {\n\n        int64_t pos_before = _ftelli64(f);\n        int64_t n = fread(buffer.data(), 1, buffer.size(),f);\n        int64_t pos_after = _ftelli64(f);\n        int64_t posMismatch = (int64_t)pos_after-(pos_before+n);\n        if(ferror(f))\n        {\n            std::cout &lt;&lt; \"fread error\\n\";\n        }\n        if(posMismatch!=0)\n        {\n            std::cout &lt;&lt; \"Error \" &lt;&lt; path\n                  &lt;&lt; \" / ftell before \" &lt;&lt; pos_before\n                  &lt;&lt; \" / fread returned \" &lt;&lt; n\n                  &lt;&lt; \" / ftell after \" &lt;&lt; pos_after\n                  &lt;&lt; \" / mismatch \" &lt;&lt; posMismatch &lt;&lt; \"\\n\";\n        }\n    }\n    fclose(f);\n}\n\nint main()\n{\n    //Generate file names\n    std::vector&lt;std::string&gt; fileNames(numThreads);\n    for(int i=0;i&lt;numThreads;++i)\n    {\n        std::ostringstream oss;\n        oss &lt;&lt; i &lt;&lt; \".dat\";\n        fileNames[i] = oss.str();\n    }\n\n\n    //Create dummy data files\n    for(int i=0;i&lt;numThreads;++i)\n    {\n        std::ofstream f(fileNames[i], std::ios_base::binary);\n        for(int j=0;j&lt;blockSize*fileBlockCount;++j)\n        {\n            f.put((char)(j&amp;255));\n        }\n    }\n\n\n    //Read data files in separate threads\n    std::vector&lt;std::thread&gt; threads;\n    for(int i=0;i&lt;numThreads;++i)\n    {\n        threads.emplace_back(readFile, fileNames[i]);\n    }\n\n    //This waits for the threads to finish\n    for(int i=0;i&lt;numThreads;++i)\n    {\n        threads[i].join();\n    }\n    threads.clear();\n\n    std::cout &lt;&lt; \"Done\";\n}\n</code></pre>\n<p>The output is randomly something like:</p>\n<pre><code>Error 3.dat / ftell before 65544 / fread returned 65544 / ftell after 131089 / mismatch 1\nError 7.dat / ftell before 0 / fread returned 65544 / ftell after 65543 / mismatch -1\nError 7.dat / ftell before 65543 / fread returned 65544 / ftell after 131088 / mismatch 1\nError 3.dat / ftell before 2162953 / fread returned 65544 / ftell after 2228498 / mismatch 1\nError 7.dat / ftell before 2162952 / fread returned 65544 / ftell after 2228497 / mismatch 1\nError 3.dat / ftell before 3080570 / fread returned 65544 / ftell after 3146112 / mismatch -2\nError 7.dat / ftell before 3080569 / fread returned 65544 / ftell after 3146112 / mismatch -1\nError 2.dat / ftell before 65544 / fread returned 65544 / ftell after 131089 / mismatch 1\nError 6.dat / ftell before 0 / fread returned 65544 / ftell after 65543 / mismatch -1\nError 6.dat / ftell before 65543 / fread returned 65544 / ftell after 131088 / mismatch 1\nError 2.dat / ftell before 2162953 / fread returned 65544 / ftell after 2228498 / mismatch 1\nError 6.dat / ftell before 2162952 / fread returned 65544 / ftell after 2228497 / mismatch 1\nError 2.dat / ftell before 3080570 / fread returned 65544 / ftell after 3146112 / mismatch -2\nError 6.dat / ftell before 3080569 / fread returned 65544 / ftell after 3146112 / mismatch -1\n</code></pre>\n<p><strong><em>EDIT : This seems related to <code>_ftelli64</code></em></strong></p>\n<p>If I replace <code>_ftelli64</code> by <code>ftell</code>, the issue is not there anymore\nSo is this a broken not reentrent implementation of <code>_ftelli64</code> ?</p>\n", "Title": "Can fread be non rentrant?", "CreationDate": "2017-10-18T21:23:02.663", "LastActivityDate": "2017-10-19T07:10:01.653", "CommentCount": "12", "LastEditDate": "2017-10-19T07:10:01.653", "PostTypeId": "1", "LastEditorUserId": "2042388", "Id": "46819473", "Score": "4", "OwnerUserId": "2042388", "Tags": "<c++><c><multithreading><file>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46819473_46820063_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 5812}}, "n3337": {"so_46819473_46820063_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 5585}}, "n4659": {"so_46819473_46820063_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 7275}}}, "46820063": {"Id": "46820063", "PostTypeId": "2", "Body": "<p>Since you're asking mostly about the C standard library, the C standard says:</p>\n<blockquote>\n<p id=\"so_46819473_46820063_0\">Each stream has an associated lock that is used to prevent data races when multiple threads of execution access a stream, and to restrict the interleaving of stream operations performed by multiple threads. Only one thread may hold this lock at a time. The lock is reentrant: a single thread may hold the lock multiple times at a given time.</p>\n<p id=\"so_46819473_46820063_1\">All functions that read, write, position, or query the position of a stream lock the stream before accessing it. They release the lock associated with the stream when the access is complete.</p>\n</blockquote>\n<p>(<a href=\"http://port70.net/~nsz/c/c11/n1570.html#7.21.2p7\" rel=\"nofollow noreferrer\">C2011 7.21.2/7-8</a>)</p>\n<p>C++ folks should note that in C, \"stream\" means the kind of thing accessed via a <code>FILE *</code>.  Of <code>fread()</code>, the standard says, in part,</p>\n<blockquote>\n<p id=\"so_46819473_46820063_2\">The file position indicator for the stream (if defined) is advanced by the number of characters successfully read.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_46819473_46820063_3\">The fread function returns the number of elements successfully read</p>\n</blockquote>\n<p>but also</p>\n<blockquote>\n<p id=\"so_46819473_46820063_4\">If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.</p>\n</blockquote>\n<p>(<a href=\"http://port70.net/~nsz/c/c11/n1570.html#7.21.8.1p2\" rel=\"nofollow noreferrer\">C2011, 7.21.8.1/2-3</a>)</p>\n<p>It seems not to characterize reaching the end of the stream as an error.</p>\n<p>Although C11 does not specifically say that <code>fread()</code> must be thread-safe, it does acknowledge the existence of multithreaded programs and define their semantics.  It specifies that in such programs,</p>\n<blockquote>\n<p id=\"so_46819473_46820063_5\">The execution of each thread proceeds as defined by the remainder of this standard.</p>\n</blockquote>\n<p>(<a href=\"http://port70.net/~nsz/c/c11/n1570.html#5.1.2.4p1\" rel=\"nofollow noreferrer\">C2011, 5.1.2.4/1</a>)</p>\n<p>That does not afford the possibility of <code>fread()</code> failing to behave as documented when called in parallel on different streams, and the locking requirements I cited earlier prevent data races and the attending undefined behavior even when it is called in parallel on <em>the same</em> stream.</p>\n<p><code>_ftelli64()</code> is not a standard library function in ISO C, but the Win32 docs specify its behavior in the same terms that that they specify the behavior of <code>ftell()</code>, which <em>is</em> a standard library function.  Both</p>\n<blockquote>\n<p id=\"so_46819473_46820063_6\">retrieve the current position of the file pointer (if any) associated with <code>stream</code>. The position is expressed as an offset relative to the beginning of the stream. </p>\n</blockquote>\n<p>(<a href=\"https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/ftell-ftelli64\" rel=\"nofollow noreferrer\">Microsoft C library documentation</a>)</p>\n<p>Microsoft's \"file pointer\" is the same thing as ISO C's \"file position\".  Overall, then, the only way I can see the observed behavior conforming is if a few of the <code>fread()</code> calls encounter errors.  You can check for this by calling <code>ferror()</code> in the event that <code>fread()</code> returns 0.  If there are errors, then all bets are off.</p>\n", "LastEditorUserId": "2402272", "LastActivityDate": "2017-10-18T22:20:32.490", "Score": "3", "CreationDate": "2017-10-18T22:14:18.047", "ParentId": "46819473", "CommentCount": "6", "LastEditDate": "2017-10-18T22:20:32.490", "OwnerUserId": "2402272"}});