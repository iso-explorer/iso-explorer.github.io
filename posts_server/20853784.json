post_cb({"bq_ids": {"n4140": {"so_20853784_20854689_1": {"length": 7, "quality": 1.0, "section_id": 5511}, "so_20853784_20854689_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 5510}, "so_20853784_20853784_0": {"length": 7, "quality": 1.0, "section_id": 5511}}, "n3337": {"so_20853784_20854689_1": {"length": 7, "quality": 1.0, "section_id": 5297}, "so_20853784_20854689_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 5296}, "so_20853784_20853784_0": {"length": 7, "quality": 1.0, "section_id": 5297}}, "n4659": {"so_20853784_20854689_1": {"length": 7, "quality": 1.0, "section_id": 6946}, "so_20853784_20854689_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 6945}, "so_20853784_20853784_0": {"length": 7, "quality": 1.0, "section_id": 6946}}}, "20854689": {"Id": "20854689", "PostTypeId": "2", "Body": "<p>Having 7.3.4 </p>\n<blockquote>\n<p id=\"so_20853784_20854689_0\">A using-directive specifies that the names in the nominated namespace\n  can be used in the scope in which the using-directive appears after\n  the  using-directive. During unqualified name lookup (3.4.1), the\n  names appear as if they were declared in the nearest enclosing\n  namespace which contains both the using-directive and the nominated\n  namespace. [ Note: In this context, \u201ccontains\u201d means \u201ccontains\n  directly or indirectly\u201d. \u2014 end note ]</p>\n<p id=\"so_20853784_20854689_1\">A using-directive does not add any members to the declarative region\n  in which it appears.</p>\n</blockquote>\n<p>Interpreting above it says a using-directive is pulling the names into a scope, but not the declaration (namespace member),\nitself.</p>\n<p>This might illustrate it:</p>\n<pre><code>namespace N {\n    template &lt;typename T&gt; void f() {};\n}\n\nusing namespace N;\n\n// error: specialization of \u2018template&lt;class T&gt; void N::f()\u2019 in different\n//        namespace\ntemplate &lt;&gt; void f&lt;int&gt;() {};\n</code></pre>\n<p>In the second example there are two unnamed namespaces:</p>\n<p>Applying some little changes:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace { int i = 0; }    // unique::i\n\nnamespace A {\n    namespace {\n        int i = 1;          // A::unique::i\n    }\n}\n\nusing namespace A;\n\nint main () {\n    // i++; // error: unique::i or A::unique::i\n    // The i having the value 1:\n    std::cout &lt;&lt; A::i &lt;&lt; std::endl; // A::unique::i\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "2249683", "LastActivityDate": "2013-12-31T09:11:24.900", "Score": "2", "CreationDate": "2013-12-31T09:04:17.717", "ParentId": "20853784", "CommentCount": "1", "LastEditDate": "2013-12-31T09:11:24.900", "OwnerUserId": "2249683"}, "20853784": {"ViewCount": "159", "Body": "<p>I am confused about using-directive.</p>\n<p>According to C++11 standard \u00a77.3.4 p.3,</p>\n<blockquote id=\"so_20853784_20853784_0\">A using-directive does not add any members to the declarative region in which it appears.</blockquote>\n<p>Additionally, C++11 standard \u00a77.3.4 does not deal with qualified name lookup.</p>\n<p>Therefore, IMHO using-directive has no effect to qualified name lookup.<br>\nFor example, I think that the following sample code should cause a compilation error.</br></p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace A {\n    namespace B {\n        int i = 1;\n    }\n    using namespace B;\n}\n\nint main()\n{\n    std::cout &lt;&lt; A::i &lt;&lt; std::endl;\n}\n</code></pre>\n<p>But both gcc and clang compile this code successfully.\n(<a href=\"http://melpon.org/wandbox/permlink/rXPjE5k12yMtlvMg\">http://melpon.org/wandbox/permlink/rXPjE5k12yMtlvMg</a>)</p>\n<p>Furthermore, C++11 standard \u00a77.3.1.1 says that an unnamed-namespace-definition behaves as if it were replaced by</p>\n<pre>\ninline<sub><i>opt</i></sub> namespace <i>unique</i> { /* empty body */ }\nusing namespace <i>unique</i>;\nnamespace <i>unique</i> { <i>namespace-body</i> }\n</pre>\n<p>and shows following example (the unnecessary part were omitted).</p>\n<pre><code>namespace { int i; }    // unique::i\n\nnamespace A {\n    namespace {\n        int i;          // A::unique::i\n    }\n}\n\nusing namespace A;\nvoid h() {\n    i++;                // error: unique::i or A::unique::i\n    A::i++;             // A::unique::i\n}\n</code></pre>\n<p>This example says that <code>A::i</code> of function <code>h</code> can refer to the unnamed namespace member <code>i</code>.</p>\n<p>Help me, I cannot understand any longer. </p>\n<p>Would you teach me the right interpretation of using-directive?</p>\n", "AcceptedAnswerId": "20854689", "Title": "Behavior of using-directive", "CreationDate": "2013-12-31T07:42:50.337", "Id": "20853784", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-12-31T07:48:58.143", "LastEditorUserId": "635608", "LastActivityDate": "2013-12-31T09:11:24.900", "Score": "8", "OwnerUserId": "1873224", "Tags": "<c++>", "AnswerCount": "1"}});