post_cb({"42137253": {"CommentCount": "3", "AcceptedAnswerId": "42137370", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2017-02-09T12:52:13.720", "LastActivityDate": "2017-02-09T15:15:12.123", "LastEditDate": "2017-02-09T15:15:12.123", "ViewCount": "121", "FavoriteCount": "0", "Title": "C++ order of specifying base classes in derived class", "Id": "42137253", "Score": "1", "Body": "<p>This may be a basic question but I haven't seen it anywhere.\nIn C++, suppose I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass B  {\npublic:\n    void f();\n};\n\nclass C  {\npublic:\n    void f();\n};\n\nclass D : public B, public C{\npublic:\n    void f();\n};\n\nvoid B::f(){cout &lt;&lt; \"bbb\" &lt;&lt; endl;}\nvoid C::f(){cout &lt;&lt; \"ccc\" &lt;&lt; endl;}\nvoid D::f(){cout &lt;&lt; \"ddd\" &lt;&lt; endl;}\n\nint main () {\n\nB *d = new D;\n\ndelete d;\nd-&gt;f();\nreturn 0;\n}\n</code></pre>\n<p>This works fine and outputs <em>\"bbb\"</em>. But if I were to switch the order of </p>\n<pre><code>class D : public B, public C{\n</code></pre>\n<p>to </p>\n<pre><code>class D : public C, public B{\n</code></pre>\n<p>I would get a <em>\"Aborted (core dumped)\"</em> error. What is the reason for this? Could someone further explain in what ways the order of the base classes matters?</p>\n<p>I know this is multiple inheritance but I am avoiding the diamond problem so not sure what's going on.</p>\n", "Tags": "<c++>", "OwnerUserId": "2499255", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_42137253_42137370_0": {"section_id": 7194, "quality": 0.9272727272727272, "length": 51}}, "n3337": {"so_42137253_42137370_0": {"section_id": 6938, "quality": 0.9272727272727272, "length": 51}}, "n4659": {"so_42137253_42137370_0": {"section_id": 8703, "quality": 0.9272727272727272, "length": 51}}}, "42137370": {"ParentId": "42137253", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The class <code>B</code> is not polymorphic (e.g. does not provide any <code>virtual</code> methods). Hence the compiler assumes that that the dynamic type of the object that <code>d</code> points to is <code>B</code>, and it tries to delete memory based on the address of the that <code>B</code> object, which in no longer matches the address of the actual <code>D</code> object. It is as one would write:</p>\n<pre><code>D * d = new D;\ndelete static_cast&lt;B *&gt;(d);\n</code></pre>\n<p>Undefined behavior right there. Why it seems to work when the order of classes inherited by <code>D</code> is <code>B</code>, <code>C</code>, is that probably in your case the address of the <code>B</code> part of the <code>D</code> object happened to be identical to the address of the <code>D</code> object itself. There are no destructors (explicitly or implicitly) defined, so only a deallocation function was called, which probably accepted the pointer provided by the respective allocation function.</p>\n<p>Note also that according to <a href=\"http://eel.is/c++draft/basic.life#7\" rel=\"nofollow noreferrer\">[basic.life]</a></p>\n<blockquote>\n<p id=\"so_42137253_42137370_0\">Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see [class.cdtor]. Otherwise, such a glvalue refers to allocated storage ([basic.stc.dynamic.deallocation]), and using the properties of the glvalue that do not depend on its value is well-defined. The program has undefined behavior if:</p>\n<ul>\n<li>the glvalue is used to access the object, or</li>\n<li>the glvalue is used to call a non-static member function of the object, or</li>\n<li>the glvalue is bound to a reference to a virtual base class ([dcl.init.ref]), or</li>\n<li>the glvalue is used as the operand of a dynamic_\u00adcast or as the operand of typeid.</li>\n</ul>\n</blockquote>\n<p>Therefore calling <code>d-&gt;f();</code> after <code>delete d;</code> in your code also causes undefined behavior.</p>\n", "OwnerUserId": "3919155", "LastEditorUserId": "3919155", "LastEditDate": "2017-02-09T13:39:01.573", "Id": "42137370", "Score": "5", "CreationDate": "2017-02-09T12:57:19.130", "LastActivityDate": "2017-02-09T13:39:01.573"}, "42137304": {"ParentId": "42137253", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>It's <em>undefined behaviour</em>, pure and simple.</p>\n<p>You can't use <code>d</code> once you've <code>delete</code>d it. Granted it's odd that it \"works\" one way and not the other, but that's the nature of <em>undefined behaviour</em>. (You can conject the reason by noting that in the first way the address of <code>D</code> is the address of <code>B</code> - note that your classes are not <em>polymorphic types</em> - , but in the second case it isn't. And the <code>delete</code> is merely releasing the memory, not immediately wiping it).</p>\n<p>But really,</p>\n<pre><code>delete d;\nd-&gt;f();\n</code></pre>\n<p>is not going to end well. Even if you do swap the order of those statements, you ought to make the base class destructors <em>virtual</em> so the correct memory is deleted.</p>\n<p><code>class D : public B, public C</code> and <code>class D : public C, public B</code>, amongst other things, exchanges the <em>order</em> in which the base classes are constructed when <code>D</code> is constructed.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2017-02-09T13:09:30.483", "Id": "42137304", "Score": "4", "CreationDate": "2017-02-09T12:54:37.503", "LastActivityDate": "2017-02-09T13:09:30.483"}});