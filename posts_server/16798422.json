post_cb({"bq_ids": {"n4140": {"so_16798422_16799424_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5944}, "so_16798422_16799424_3": {"length": 49, "quality": 0.9607843137254902, "section_id": 6182}}, "n3337": {"so_16798422_16799424_3": {"length": 49, "quality": 0.9607843137254902, "section_id": 5943}, "so_16798422_16799424_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5715}}, "n4659": {"so_16798422_16799424_3": {"length": 48, "quality": 0.9411764705882353, "section_id": 7684}, "so_16798422_16799424_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 7429}}}, "16799424": {"Id": "16799424", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16798422_16799424_0\"><strong>5 Expressions</strong></p>\n<p id=\"so_16798422_16799424_1\">10  In some contexts, an expression only appears for its side effects. Such an expression is called a discarded-value\n  expression. The expression is evaluated and its value is discarded</p>\n<p id=\"so_16798422_16799424_2\"><strong>5.18 Comma operator [expr.comma]</strong></p>\n<p id=\"so_16798422_16799424_3\">A pair of expressions separated by a comma is evaluated left-to-right;\n  the left expression is a discarded-value expression (Clause 5).83 Every\n  value computation and side effect associated with the left expression\n  is sequenced before every value computation and side effect associated\n  with the right expression. The type and value of the result are the\n  type and value of the right operand; the result is of the same value\n  category as its right operand, and is a bit-field if its right operand\n  is a glvalue and a bit-field.</p>\n</blockquote>\n<p>It sounds to me like there's nothing wrong with your statement.</p>\n<p>Looking more closely at the g++ warning, <strong>may</strong> be undefined, which tells me that the parser isn't smart enough to see that <code>a=1</code> is guaranteed to be evaluated.</p>\n", "LastEditorUserId": "2406758", "LastActivityDate": "2013-05-28T19:13:45.067", "Score": "1", "CreationDate": "2013-05-28T18:58:16.430", "ParentId": "16798422", "CommentCount": "3", "OwnerUserId": "2406758", "LastEditDate": "2013-05-28T19:13:45.067"}, "16798422": {"ViewCount": "309", "Body": "<p>I guess the answer is \"no\", but from a compiler point of view, I don't understand why.</p>\n<p>I made a very simple code which freaks out compiler diagnostics quite badly (both clang and gcc), but I would like to have confirmation that the code is not ill formatted before I report mis-diagnostics. I should point out that these are <strong>not compiler bugs</strong>, the output is correct in all cases, but I have doubts about the warnings.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(){\n  int b,a;\n  b = 3;\n  b == 3 ? a = 1 : b = 2;\n  b == 2 ? a = 2 : b = 1;\n  a = a;\n  std::cerr &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The assignment of <code>a</code> is a tautology, meaning that <code>a</code> will be initialized after the two ternary statements, regardless of <code>b</code>. GCC is perfectly happy with this code. Clang is slighly more clever and spot something silly (<code>warning: explicitly assigning a variable of type 'int' to itself [-Wself-assign]</code>), but no big deal.</p>\n<p>Now the same thing (semantically at least), but shorter syntax:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(){\n  int b,a = (b=3, \n             b == 3 ? a = 1 : b = 2, \n             b == 2 ? a = 2 : b = 1, \n             a);\n  std::cerr &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Now the compilers give me completely different warnings. Clang doesn't report anything strange anymore (which is probably correct because of the parenthesis precedence). gcc is a bit more scary and says:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:7:15: warning: operation on \u2018a\u2019 may be undefined [-Wsequence-point]\n</code></pre>\n<p>But is that true? That sequence-point warning gives me a hint that coma separated statements are not handled in the same way in practice, but I don't know if they should or not.</p>\n<p>And it gets weirder, changing the code to:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(){\n  int b,a = (b=3, \n             b == 3 ? a = 1 : b = 2, \n             b == 2 ? a = 2 : b = 1, \n             a+0); // &lt;- i just changed this line\n  std::cerr &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>and then suddenly clang realized that there might be something fishy with <code>a</code>:</p>\n<pre><code>test.cpp:7:14: warning: variable 'a' is uninitialized when used within its own initialization [-Wuninitialized]\n             a+0);\n             ^\n</code></pre>\n<p>But there was no problem with <code>a</code> before... For some reasons clang cannot spot the tautology in this case. Again, it might simply be because those are not full statements anymore. </p>\n<p><strong>The problems are:</strong></p>\n<ul>\n<li>is this code valid and well defined (in all versions)?</li>\n<li>how is the list of comma separated statements handled? Should it be different from the first version of the code with explicit statements?</li>\n<li>is GCC right to report undefined behavior and sequence point issues? (in this case clang is missing some important diagnostics) I am aware that it says <strong>may</strong>, but still...</li>\n<li>is clang right to report that <code>a</code> might be uninitialized in the last case? (then it should have the same diagnostic for the previous case)</li>\n</ul>\n<p><strong>Edit and comments:</strong></p>\n<ul>\n<li>I am getting several (rightful) comments that this code is anything but simple. This is true, but the point is that the compilers mis-diagnose when they encounter comma-separated statements in initializers. This is a bad thing. I made my code more complete to avoid the <em>\"have you tried this syntax...\"</em> comments. A much more realistic and human readable version of the problem could be written, which would exhibit wrong diagnostics, but I think this version shows more information and is more complete.</li>\n<li>in a compiler-torture test suite, this would be considered very understandable and readable, they do much much worse :) We need code like that to test and assess compilers. This would not look pretty in production code, but that is not the point here.</li>\n</ul>\n", "Title": "Are comma separated statements considered full statements? (and other diagnostic issues)", "CreationDate": "2013-05-28T17:51:06.957", "LastActivityDate": "2013-06-05T19:00:38.337", "CommentCount": "20", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-05-29T14:19:37.797", "LastEditorUserId": "401200", "Id": "16798422", "Score": "14", "OwnerUserId": "401200", "Tags": "<c++><gcc><clang><compiler-warnings>", "AnswerCount": "1"}});