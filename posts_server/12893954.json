post_cb({"12894647": {"ParentId": "12893954", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>First answer:</strong></p>\n<p>No, this is not guaranteed. See <code>[expr.sizeof]/1</code>, and the associated footnote:</p>\n<blockquote>\n<p id=\"so_12893954_12894647_0\">... sizeof(char), sizeof(signed char) and sizeof(unsigned char) are 1. The result of sizeof applied to any other fundamental type (3.9.1) is implementation-defined. [Note: in particular, sizeof(bool), sizeof(char16_t), sizeof(char32_t), and sizeof(wchar_t) are implementation-defined<sup>75</sup>. ...</p>\n<p id=\"so_12893954_12894647_1\">75) sizeof(bool) is not required to be 1.</p>\n</blockquote>\n<hr>\n<p><strong>Second Answer:</strong></p>\n<p>I'm pretty sure that the value representation for <code>bool</code> objects is implementation defined, but I can't find anything explicitly stating that. The closest that I can get is <code>[basic.types]/4</code>: </p>\n<blockquote>\n<p id=\"so_12893954_12894647_2\">... For trivially copyable types, the value representation is a set of bits in the object representation that determines a value, which is one discrete element of an implementation-defined set of values.</p>\n</blockquote>\n<hr>\n<p><strong>Third Answer:</strong></p>\n<p>I don't know, but from your description, it certainly looks like you would have to change the types.</p>\n</hr></hr>", "OwnerUserId": "485561", "LastEditorUserId": "485561", "LastEditDate": "2012-10-15T11:44:15.407", "Id": "12894647", "Score": "1", "CreationDate": "2012-10-15T11:26:30.547", "LastActivityDate": "2012-10-15T11:44:15.407"}, "12893954": {"CommentCount": "4", "ViewCount": "274", "CreationDate": "2012-10-15T10:44:12.177", "LastActivityDate": "2012-10-15T11:44:15.407", "Title": "Portable way of accessing an array of bool (C++11) from Nvidia PTX", "FavoriteCount": "0", "PostTypeId": "1", "Id": "12893954", "Score": "5", "Body": "<p>I need to do GPU computations on an boolean array <code>bool[]</code> (note, not a <code>std::vector&lt;bool&gt;</code>) which was created in CPU memory (with C++11 code) and then copied to the GPU via <code>cuMemCpy</code> or similar.</p>\n<p>First question:</p>\n<p><code>sizeof(bool)</code> reports 1 byte. Is this guaranteed by the C++11 standard?</p>\n<p>Second question:</p>\n<p>Is <code>true</code> (<code>false</code>) always represented as <code>1</code> (<code>0</code>) (in the <code>unsigned char</code> representation) or does the compiler have freedom here ? (It could use any non-zero integer less than 256 if it wanted)</p>\n<p>Third question (PTX specific):</p>\n<p>In PTX logical operations <code>or</code>, <code>xor</code>, etc. only operate on types larger than 8 bit. That is I can do logical operations on an <code>unsigned int</code> with <code>or.u32 &lt;out&gt;,&lt;in1&gt;,&lt;in2&gt;</code>. However since C++11 <code>bool</code> type seems to be 8 bits does this mean I can not operate on an array of <code>bools</code> that was copied directly from CPU to GPU memory and thus do I need to convert the array of <code>bools</code> first into some type PTX logical operations can operate on, i.e. <code>u32</code>, <code>u16</code>, etc.?</p>\n", "Tags": "<c++><c++11><boolean><gpu><ptx>", "OwnerUserId": "712302", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_12893954_12894647_2": {"section_id": 7202, "quality": 0.8333333333333334, "length": 15}, "so_12893954_12894647_0": {"section_id": 6076, "quality": 0.7619047619047619, "length": 16}}, "n3337": {"so_12893954_12894647_2": {"section_id": 6946, "quality": 0.8333333333333334, "length": 15}, "so_12893954_12894647_0": {"section_id": 5844, "quality": 0.7619047619047619, "length": 16}}, "n4659": {"so_12893954_12894647_2": {"section_id": 8711, "quality": 0.8333333333333334, "length": 15}, "so_12893954_12894647_0": {"section_id": 7572, "quality": 0.7619047619047619, "length": 16}}}});