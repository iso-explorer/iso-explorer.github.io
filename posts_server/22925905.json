post_cb({"bq_ids": {"n4140": {"so_22925905_22925905_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 3402}}, "n3337": {"so_22925905_22925905_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 3271}}, "n4659": {"so_22925905_22925905_0": {"length": 28, "quality": 0.7368421052631579, "section_id": 4159}}}, "23114389": {"Id": "23114389", "PostTypeId": "2", "Body": "<p>I think you are asking the impossible.</p>\n<p>Keep in mind that standard library implementors often rely on non-standard extensions or implementation-defined behavior. Indeed, in VC++'s complex header we find:</p>\n<pre><code>#pragma pack(push, _CRT_PACKING)\n\n// implementation\n\n#pragma pack(pop)\n</code></pre>\n<p>What you could do for your Quaternion is to place all the members inside an array, since the struct address can be reinterpret_cast to a pointer to the first member. But I guess that kind of defeats the purpose of the struct (direct member access by name).</p>\n<p>It is not exactly what you ask for, but providing an</p>\n<pre><code>operator const T*() const // can be written in a portable manner\n</code></pre>\n<p>for your struct, will allow you to write</p>\n<pre><code>Quaternion&lt;double&gt; q = {};\nconst double * p = q;\n</code></pre>\n<p>at the cost of additional runtime/memory overhead, depending on how you implement the conversion operator.</p>\n", "LastActivityDate": "2014-04-16T15:54:55.607", "CommentCount": "0", "CreationDate": "2014-04-16T15:54:55.607", "ParentId": "22925905", "Score": "2", "OwnerUserId": "632030"}, "22925905": {"ViewCount": "296", "Body": "<p>I just learned this because of <a href=\"https://stackoverflow.com/q/22919357\">this question</a>, that the standard states for <code>std::complex</code> (26.4 [complex.numbers]):</p>\n<blockquote>\n<p id=\"so_22925905_22925905_0\">4 If <code>z</code> is an lvalue expression of type <em>cv</em> <code>std::complex&lt;T&gt;</code> then:<br>\n  \u2014 the expression <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)</code> shall be well-formed,<br>\n  \u2014 <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]</code> shall designate the real part of <code>z</code>, and<br>\n  \u2014 <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]</code> shall designate the imaginary part of <code>z</code>.<br>\n  Moreover, if <code>a</code> is an expression of type <em>cv</em> <code>std::complex&lt;T&gt;*</code> and the expression <code>a[i]</code> is well-defined  for an integer expression <code>i</code>, then:<br>\n  \u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</code> shall designate the real part of <code>a[i]</code>, and<br>\n  \u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i + 1]</code> shall designate the imaginary part of <code>a[i]</code>.</br></br></br></br></br></br></p>\n</blockquote>\n<p>This is something I really want to take advantage of <em>in a standards-conforming manner</em>. There are times when I have PODs, like mathematical vectors, which are composed of a single data type. Here are two example classes:</p>\n<pre><code>template &lt;typename T, unsigned N&gt;\nstruct Vector\n{\n    T v[N];\n};\n\ntemplate &lt;typename T&gt;\nstruct Quaternion\n{\n    T r, i, j, k;\n};\n</code></pre>\n<p>From what I understand, the implementation is allowed to add padding after the last member, as well as between members. Which means that <code>sizeof(Quaterntion&lt;float&gt;)</code> may not equal <code>sizeof(float[4])</code>, and <code>sizeof(Vector&lt;double, 8&gt;)</code> may not equal <code>sizeof(double[8])</code>. This means I typically have to add some <code>static_assert</code>s to my code to make sure that I can cast my <code>Vector&lt;float, N&gt;</code>/<code>Quaterntion&lt;float&gt;</code> to a <code>float*</code>, for example, and not worry about padding (for passing to C libraries or OpenGL buffers, for example).</p>\n<p>Is there some method provided by the standard that would allow me to have the same guarantees for my little PODs, like <code>Vector</code> and <code>Quaternion</code>, as <code>std::complex</code> does? I'm aware of implementation-specific things, like <code>__attribute__((packed))</code>. I'm looking for for a non-implementation specific, standards conforming way of doing this. Since the standard requires support for this type of thing for implementations that provide <code>std::complex</code>, I'm wondering if there's also some standard way of applying this guarantee to my own classes.</p>\n", "AcceptedAnswerId": "23114389", "Title": "How can I make my objects reinterpret-castable to arrays, like std::complex?", "CreationDate": "2014-04-08T01:15:52.107", "Id": "22925905", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:28:50.653", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-16T15:54:55.607", "Score": "7", "OwnerUserId": "1287251", "Tags": "<c++><c++11>", "AnswerCount": "1"}});