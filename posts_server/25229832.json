post_cb({"25264231": {"ParentId": "25229832", "CommentCount": "0", "Body": "<p>The compiler deduces the best-fitting type from literals, or at leas what it thinks is best-fitting. That is rather lose efficiency over precision, i.e. use a double instead of float.\nIf in doubt, use brace-intializers to make it explicit:</p>\n<pre><code>auto d = double{3}; // make a double\nauto f = float{3}; // make a float\nauto i = int{3}; // make a int\n</code></pre>\n<p>The story gets more interesting if you initialize from another variable where type-conversion rules apply: While it is legal to constuct  a double form a literal, it cant be contructed from an int without possible narrowing:</p>\n<pre><code>auto xxx = double{i} // warning ! narrowing conversion of 'i' from 'int' to 'double' \n</code></pre>\n", "OwnerUserId": "3714982", "PostTypeId": "2", "Id": "25264231", "Score": "0", "CreationDate": "2014-08-12T12:23:57.033", "LastActivityDate": "2014-08-12T12:23:57.033"}, "25229958": {"ParentId": "25229832", "CommentCount": "0", "Body": "<p>When you define a variable, it is initialized with the provided initializer. This may require converting the value of the initializer to the type of the variable that's being initialized. That's what's happening when you say <code>float a = 3.0;</code>: The value of the initializer is converted to <code>float</code>, and the result of the conversion becomes the initial value of <code>a</code>.</p>\n<p>That's generally fine, but it doesn't hurt to write <code>3.0f</code> to show that you're aware of what you're doing, and especially if you want to write <code>auto a = 3.0f</code>.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "25229958", "Score": "0", "CreationDate": "2014-08-10T15:13:09.337", "LastActivityDate": "2014-08-10T15:13:09.337"}, "25254611": {"ParentId": "25229832", "CommentCount": "0", "Body": "<p>While not an error, per se, it is a little sloppy. You know you want a float, so initialize it with a float.<br/>Another programmer may come along and not be sure which part of the declaration is correct, the type or the initializer. Why not have them both be correct?<br/>\n    float Answer = 42.0f;</p>\n", "OwnerUserId": "470868", "PostTypeId": "2", "Id": "25254611", "Score": "2", "CreationDate": "2014-08-12T00:52:29.357", "LastActivityDate": "2014-08-12T00:52:29.357"}, "25229950": {"ParentId": "25229832", "LastEditDate": "2014-08-12T07:25:18.763", "CommentCount": "11", "CreationDate": "2014-08-10T15:12:38.310", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "PostTypeId": "2", "Id": "25229950", "Score": "158", "Body": "<p>It is not an error to declare <code>float a = 3.0</code> : if you do, the compiler will convert the double literal 3.0 to a float for you.</p>\n<hr>\n<p>However, you <strong>should</strong> use the float literals notation in specific scenarios.</p>\n<ol>\n<li><p><strong>For performance reasons:</strong></p>\n<p>Specifically, consider:</p>\n<pre><code>float foo(float x) { return x * 0.42; }\n</code></pre>\n<p>Here the compiler will emit a conversion (that you will pay at runtime) for each returned value. To avoid it you should declare:</p>\n<pre><code>float foo(float x) { return x * 0.42f; } // OK, no conversion required\n</code></pre></li>\n<li><p><strong>To avoid bugs when comparing results:</strong></p>\n<p>e.g. the following comparison fails :</p>\n<pre><code>float x = 4.2;\nif (x == 4.2)\n   std::cout &lt;&lt; \"oops\"; // Not executed!\n</code></pre>\n<p>We can fix it with the float literal notation :</p>\n<pre><code>if (x == 4.2f)\n   std::cout &lt;&lt; \"ok !\"; // Executed!\n</code></pre>\n<p>(Note: of course, <a href=\"//stackoverflow.com/questions/17333/most-effective-way-for-float-and-double-comparison\">this is not how you should compare float or double numbers for equality in general</a>)</p></li>\n<li><p><strong>To call the correct overloaded function (for the same reason):</strong></p>\n<p>Example:</p>\n<pre><code>void foo(float f) { std::cout &lt;&lt; \"\\nfloat\"; }\n\nvoid foo(double d) { std::cout &lt;&lt; \"\\ndouble\"; }\n\nint main()\n{       \n    foo(42.0);   // calls double overload\n    foo(42.0f);  // calls float overload\n    return 0;\n}\n</code></pre></li>\n<li><p><strong><a href=\"//stackoverflow.com/a/25229947/3510483\">As noted by Cyber</a>, in a type deduction context, it is necessary to help the compiler deduce a <code>float</code> :</strong></p>\n<p>In case of <code>auto</code> :</p>\n<pre><code>auto d = 3;      // int\nauto e = 3.0;    // double\nauto f = 3.0f;   // float\n</code></pre>\n<p>And similarly, in case of template type deduction :</p>\n<pre><code>void foo(float f) { std::cout &lt;&lt; \"\\nfloat\"; }\n\nvoid foo(double d) { std::cout &lt;&lt; \"\\ndouble\"; }\n\ntemplate&lt;typename T&gt;\nvoid bar(T t)\n{\n      foo(t);\n}\n\nint main()\n{   \n    bar(42.0);   // Deduce double\n    bar(42.0f);  // Deduce float\n\n    return 0;\n}\n</code></pre></li>\n</ol>\n<hr>\n<p><a href=\"http://coliru.stacked-crooked.com/a/266ec0198f8bc21d\"><strong>Live demo</strong></a></p>\n</hr></hr>", "LastActivityDate": "2014-08-12T07:25:18.763"}, "25229961": {"ParentId": "25229832", "CommentCount": "1", "Body": "<p>It's not an error in the sense that the compiler will reject it, but it is an error in the sense that it may not be what you want.</p>\n<p>As your book correctly states, <code>3.0</code> is a value of type <code>double</code>. There is an implicit conversion from <code>double</code> to <code>float</code>, so <code>float a = 3.0;</code> is a valid definition of a variable.</p>\n<p>However, at least conceptually, this performs a needless conversion. Depending on the compiler, the conversion may be performed at compile time, or it may be saved for run time. A valid reason for saving it for run time is that floating-point conversions are difficult and may have unexpected side effects if the value cannot be represented exactly, and it's not always easy to verify whether the value can be represented exactly.</p>\n<p><code>3.0f</code> avoids that problem: although technically, the compiler is still allowed to calculate the constant at run time (it always is), here, there is absolutely no reason why any compiler might possibly do that.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "25229961", "Score": "4", "CreationDate": "2014-08-10T15:13:43.370", "LastActivityDate": "2014-08-10T15:13:43.370"}, "25231230": {"ParentId": "25229832", "LastEditDate": "2017-05-23T12:33:44.733", "CommentCount": "2", "CreationDate": "2014-08-10T17:29:59.577", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "25231230", "Score": "13", "Body": "<p>Floating point literals without a suffix are of type <em>double</em>, this is covered in the draft C++ standard section <code>2.14.4</code> <em>Floating literals</em>:</p>\n<blockquote>\n<p id=\"so_25229832_25231230_0\">[...]The type of a floating literal is double unless explicitly specified by a suffix.[...]</p>\n</blockquote>\n<p>so is it an error to assign <code>3.0</code> a <em>double literal</em> to a <em>float</em>?:</p>\n<pre><code>float a = 3.0\n</code></pre>\n<p>No, it is not, it will be converted, which is covered in section <code>4.8</code> <em>Floating point conversions</em>:</p>\n<blockquote>\n<p id=\"so_25229832_25231230_1\">A prvalue of floating point type can be converted to a prvalue of\n  another floating point type. If the source value can be exactly\n  represented in the destination type, the result of the conversion is\n  that exact representation. If the source value is between two adjacent\n  destination values, the result of the conversion is an\n  implementation-defined choice of either of those values. Otherwise,\n  the behavior is undefined.</p>\n</blockquote>\n<p>We can read more details on the implications of this in <a href=\"http://www.gotw.ca/gotw/067.htm\" rel=\"nofollow noreferrer\">GotW #67: double or nothing</a> which says:</p>\n<blockquote>\n<p id=\"so_25229832_25231230_2\">This means that a double constant can be implicitly (i.e., silently)\n  converted to a float constant, even if doing so loses precision (i.e.,\n  data). This was allowed to remain for C compatibility and usability\n  reasons, but it's worth keeping in mind when you do floating-point\n  work.</p>\n<p id=\"so_25229832_25231230_3\">A quality compiler will warn you if you try to do something that's\n  undefined behavior, namely put a double quantity into a float that's\n  less than the minimum, or greater than the maximum, value that a float\n  is able to represent. A really good compiler will provide an optional\n  warning if you try to do something that may be defined but could lose\n  information, namely put a double quantity into a float that is between\n  the minimum and maximum values representable by a float, but which\n  can't be represented exactly as a float.</p>\n</blockquote>\n<p>So there are caveats for the general case that you should be aware of.</p>\n<p>From a practical perspective, in this case the results will <em>most likely</em> be the same even though technically there is a conversion, we can see this by trying out the following code on <a href=\"http://gcc.godbolt.org/\" rel=\"nofollow noreferrer\">godbolt</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nfloat func1()\n{\n  return 3.0; // a double literal\n}\n\n\nfloat func2()\n{\n  return 3.0f ; // a float literal\n}\n\nint main()\n{  \n  std::cout &lt;&lt; func1() &lt;&lt; \":\" &lt;&lt; func2() &lt;&lt; std::endl ;\n  return 0;\n}\n</code></pre>\n<p>and we see that the results for <code>func1</code> and <code>func2</code> are identical, using both <code>clang</code> and <code>gcc</code>:</p>\n<pre><code>func1():\n    movss   xmm0, DWORD PTR .LC0[rip]\n    ret\nfunc2():\n    movss   xmm0, DWORD PTR .LC0[rip]\n    ret\n</code></pre>\n<p>As <a href=\"https://stackoverflow.com/questions/25229832/is-float-a-3-0-a-correct-statement#comment39304567_25229950\">Pascal points out in this comment</a> you won't always be able to count on this. Using <code>0.1</code> and <code>0.1f</code> respectively causes the assembly generated to differ since the conversion must now be done explicitly. The following code:</p>\n<pre><code>float func1(float x )\n{\n  return x*0.1; // a double literal\n}\n\nfloat func2(float x)\n{\n  return x*0.1f ; // a float literal\n}\n</code></pre>\n<p>results in the following assembly:</p>\n<pre><code>func1(float):  \n    cvtss2sd    %xmm0, %xmm0    # x, D.31147    \n    mulsd   .LC0(%rip), %xmm0   #, D.31147\n    cvtsd2ss    %xmm0, %xmm0    # D.31147, D.31148\n    ret\nfunc2(float):\n    mulss   .LC2(%rip), %xmm0   #, D.31155\n    ret\n</code></pre>\n<p>Regardless whether you can determine if the conversion will have a performance impact or not, using the correct type better documents your intention. Using an explicit conversions for example <code>static_cast</code> also helps to clarify the conversion was intended as opposed to accidental, which may signify a bug or potential bug.</p>\n<p><b>Note</b></p>\n<p>As supercat points out, multiplication by e.g. <code>0.1</code> and <code>0.1f</code> is not equivalent. I am just going to quote the comment because it was excellent and a summary probably would not do it justice:</p>\n<blockquote>\n<p id=\"so_25229832_25231230_4\">For example, if f was equal to 100000224 (which is exactly\n  representable as a float), multiplying it by one tenth should yield a\n  result which rounds down to 10000022, but multiplying by 0.1f will\n  instead yield a result which erroneously rounds up to 10000023. If the\n  intention is to divide by ten, multiplication by double constant 0.1\n  will likely be faster than division by 10f, and more precise than\n  multiplication by 0.1f.</p>\n</blockquote>\n<p>My original point was to demonstrate a false example given in another question but this  finely demonstrates subtle issues can exist in toy examples.</p>\n", "LastActivityDate": "2014-08-12T15:12:31.083"}, "25229832": {"CommentCount": "8", "CreationDate": "2014-08-10T14:59:28.730", "PostTypeId": "1", "AcceptedAnswerId": "25229950", "LastEditorUserId": "1708801", "LastActivityDate": "2014-08-12T17:16:45.507", "LastEditDate": "2014-08-12T14:34:25.700", "ViewCount": "7330", "FavoriteCount": "20", "Title": "Is 'float a = 3.0;' a correct statement?", "Id": "25229832", "Score": "84", "Body": "<p>If I have the following declaration:</p>\n<pre><code>float a = 3.0 ;\n</code></pre>\n<p>is that an error? I read in a book that <code>3.0</code> is a <code>double</code> value and that I have to specify it as <code>float a = 3.0f</code>. Is it so?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3191382", "AnswerCount": "8"}, "25229947": {"ParentId": "25229832", "LastEditDate": "2014-08-12T17:16:45.507", "CommentCount": "1", "CreationDate": "2014-08-10T15:12:30.090", "OwnerUserId": "2296458", "LastEditorUserId": "2296458", "PostTypeId": "2", "Id": "25229947", "Score": "21", "Body": "<p>The compiler will turn any of the following literals into floats, because you declared the variable as a float.</p>\n<pre><code>float a = 3;     // converted to float\nfloat b = 3.0;   // converted to float\nfloat c = 3.0f;  // float\n</code></pre>\n<p>It would matter is if you used <code>auto</code> (or other type deducting methods), for example:</p>\n<pre><code>auto d = 3;      // int\nauto e = 3.0;    // double\nauto f = 3.0f;   // float\n</code></pre>\n", "LastActivityDate": "2014-08-12T17:16:45.507"}, "25242847": {"ParentId": "25229832", "LastEditDate": "2014-08-11T12:18:06.797", "CommentCount": "3", "CreationDate": "2014-08-11T12:03:15.800", "OwnerUserId": "2032021", "LastEditorUserId": "3510483", "PostTypeId": "2", "Id": "25242847", "Score": "0", "Body": "<p>If you try out the following:</p>\n<pre><code>std::cout &lt;&lt; sizeof(3.2f) &lt;&lt;\":\" &lt;&lt; sizeof(3.2) &lt;&lt; std::endl;\n</code></pre>\n<p>you will get output as:</p>\n<pre><code>4:8\n</code></pre>\n<p>that shows, size of 3.2f is taken as 4 bytes on 32-bit machine wheres 3.2 is interpreted as double value taking 8 bytes on 32-bit machine.\nThis should provide the answer that you are looking for.</p>\n", "LastActivityDate": "2014-08-11T12:18:06.797"}, "bq_ids": {"n4140": {"so_25229832_25231230_0": {"section_id": 5348, "quality": 0.875, "length": 7}, "so_25229832_25231230_1": {"section_id": 35, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_25229832_25231230_0": {"section_id": 5145, "quality": 0.875, "length": 7}, "so_25229832_25231230_1": {"section_id": 32, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_25229832_25231230_0": {"section_id": 6773, "quality": 0.875, "length": 7}, "so_25229832_25231230_1": {"section_id": 35, "quality": 0.8717948717948718, "length": 34}}}});