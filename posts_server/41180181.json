post_cb({"41180281": {"ParentId": "41180181", "CommentCount": "0", "Body": "<p>The <code>Compare</code> relation must be a <strong><em>strict</em></strong>-weak ordering</p> (in both cases) \u00a723.2.4/2:\n<blockquote>\n<p id=\"so_41180181_41180281_0\">Each associative container is parameterized on <code>Key</code> and an ordering relation <code>Compare</code> that induces a strict weak ordering (25.4) on elements of <code>Key</code>. [...]</p>\n</blockquote>\n<p>And \u00a725.4/4:</p>\n<blockquote>\n<p id=\"so_41180181_41180281_1\">The term strict refers to the requirement of an irreflexive relation (<code>!comp(x, x)</code> for all <code>x</code>), [...]</p>\n</blockquote>\n<p>Your custom <code>Compare</code> (<code>cmp</code>) fails this requirement, so the behavior of your <code>std::set&lt;int, cmp&gt;</code> is not defined.</p>\n", "OwnerUserId": "2666289", "PostTypeId": "2", "Id": "41180281", "Score": "2", "CreationDate": "2016-12-16T08:39:13.173", "LastActivityDate": "2016-12-16T08:39:13.173"}, "41180181": {"CommentCount": "5", "ViewCount": "39", "CreationDate": "2016-12-16T08:31:14.737", "LastActivityDate": "2016-12-16T08:39:13.173", "Title": "Do set and multiset differ just by a predicate?", "PostTypeId": "1", "Id": "41180181", "Score": "1", "Body": "<p>Staring with the following sample code :</p>\n<pre><code>class cmp\n{\n    public:\n            bool operator()(int a, int b) { return a&lt;=b; }\n};\n\nint main()\n{\n    set&lt;int, cmp&gt; s;\n    s.insert(2);\n    s.insert(2);\n    s.insert(4);\n    s.insert(5);\n    s.insert(6);\n    copy(s.begin(), s.end(), ostream_iterator&lt;int&gt;(cout, \"  \"));\n    cout&lt;&lt;endl;\n\n    multiset&lt;int&gt; ms;\n    ms.insert(2);\n    ms.insert(2);\n    ms.insert(4);\n    ms.insert(5);\n    ms.insert(6);\n    copy(ms.begin(), ms.end(), ostream_iterator&lt;int&gt;(cout, \"  \"));\n    cout&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>Set - contains unique value.</p>\n<p>Multiset - can contain duplicate value.</p>\n<p>But in my set implementation, i changed the predicate to accept duplicate values. If we can have this just by changing the predicate, <code>what's the purpose of having two different containers?</code> I believe functionality is also same, implementation is also same (Balanced tree). Can somebody elaborate, if i am missing something?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "3312772", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41180181_41180281_0": {"section_id": 738, "quality": 0.9333333333333333, "length": 14}, "so_41180181_41180281_1": {"section_id": 1396, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_41180181_41180281_0": {"section_id": 727, "quality": 0.9333333333333333, "length": 14}, "so_41180181_41180281_1": {"section_id": 1390, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_41180181_41180281_0": {"section_id": 796, "quality": 0.9333333333333333, "length": 14}, "so_41180181_41180281_1": {"section_id": 1514, "quality": 0.7777777777777778, "length": 7}}}});