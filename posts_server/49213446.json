post_cb({"bq_ids": {"n4140": {"so_49213446_49213482_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6005}, "so_49213446_49213482_2": {"length": 21, "quality": 1.0, "section_id": 6004}, "so_49213446_49213482_0": {"length": 11, "quality": 1.0, "section_id": 5890}}, "n3337": {"so_49213446_49213482_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5773}, "so_49213446_49213482_2": {"length": 21, "quality": 1.0, "section_id": 5772}, "so_49213446_49213482_0": {"length": 11, "quality": 1.0, "section_id": 5661}}, "n4659": {"so_49213446_49213482_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7504}, "so_49213446_49213482_2": {"length": 21, "quality": 1.0, "section_id": 7503}, "so_49213446_49213482_0": {"length": 11, "quality": 1.0, "section_id": 7373}}}, "49213446": {"ViewCount": "73", "Body": "<p>A question came up here on SO asking \"Why is this working\" when a pointer became dangling. The answers were that it's UB, which means it may work or not.</p>\n<p>I learned in a tutorial that:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo\n{\n    int member;\n    void function() { std::cout &lt;&lt; \"hello\";}\n\n};\n\nint main()\n{\n    Foo* fooObj = nullptr;\n    fooObj-&gt;member = 5; // This will cause a read access violation but...\n    fooObj-&gt;function(); // Because this doesn't refer to any memory specific to\n                        // the Foo object, and doesn't touch any of its members\n                        // It will work.\n}\n</code></pre>\n<p>Would this be the equivalent of:</p>\n<pre><code>static void function(Foo* fooObj) // Foo* essentially being the \"this\" pointer\n{\n    std::cout &lt;&lt; \"Hello\";\n    // Foo pointer, even though dangling or null, isn't touched. And so should \n    // run fine.\n}\n</code></pre>\n<p>Am I wrong about this? Is it UB even though as I explained just calling a function and not accessing the invalid Foo pointer?</p>\n", "Title": "Is this undefined behaviour in C++ calling a function from a dangling pointer", "CreationDate": "2018-03-10T19:59:00.063", "LastActivityDate": "2018-03-10T21:12:52.160", "CommentCount": "14", "LastEditDate": "2018-03-10T20:01:09.363", "PostTypeId": "1", "LastEditorUserId": "1080064", "Id": "49213446", "Score": "1", "OwnerUserId": "4696802", "Tags": "<c++><pointers><undefined-behavior><dangling-pointer>", "AnswerCount": "3"}, "49213576": {"Id": "49213576", "PostTypeId": "2", "Body": "<p>Compiler isn't obliged by standard to implement member function by passing it a pointer to the class instance. Yes, there is pseudo-pointer \"this\", but it is unrelated element, guaranteed to be \"understood\".</p>\n<p><code>nullptr</code> pointer doesn't point on any existing object, and -&gt; () calls a member of that object. From standard's view, this is nonsense and result of such operation is undefined (and potentially, catastrophic).</p>\n<p>If <code>function()</code> would be virtual, then call is allowed to fail, because address of function would be unavailable (vtable might be implemented as part of object and doesn't exist if object doesn't).</p>\n<p>if the member function (method) behaves like that and meant to be called like that it should be a static member function (method). Static method doesn't access non-static fields and doesn't call non-static methods of class. If it is static, the call could look like this as well:</p>\n<pre><code>Foo::function(); \n</code></pre>\n", "LastEditorUserId": "2742717", "LastActivityDate": "2018-03-10T20:21:14.430", "Score": "1", "CreationDate": "2018-03-10T20:14:04.783", "ParentId": "49213446", "CommentCount": "2", "OwnerUserId": "2742717", "LastEditDate": "2018-03-10T20:21:14.430"}, "49213482": {"Id": "49213482", "PostTypeId": "2", "Body": "<p>You're reasoning about what happens in practice.  Undefined behavior is allowed to do the thing you expect... but it is not guaranteed.</p>\n<p>For the non-static case, this is straightforward to prove using the rule found in <code>[class.mfct.non-static]</code>:</p>\n<blockquote>\n<p id=\"so_49213446_49213482_0\"><strong>If a non-static member function of a class <code>X</code> is called for an object that is not of type <code>X</code>, or of a type derived from <code>X</code>, the behavior is undefined.</strong></p>\n</blockquote>\n<p>Note that there's no consideration about whether the non-static member function accesses <code>*this</code>.  The object is simply required to have the correct dynamic type, and <code>*(Foo*)nullptr</code> certainly does not.</p>\n<hr>\n<p>In particular, even on platforms which use the implementation you describe, the call</p>\n<pre><code>fooObj-&gt;func();\n</code></pre>\n<p>gets converted to</p>\n<pre><code>__assume(fooObj); Foo_func(fooObj);\n</code></pre>\n<p>and is optimization-unstable.</p>\n<p>Here's an example which will work contrary to your expectations:</p>\n<pre><code>int main()\n{\n    Foo* fooObj = nullptr;\n    fooObj-&gt;func();\n    if (fooObj) {\n        fooObj-&gt;member = 5; // This will cause a read access violation!\n    }\n}\n</code></pre>\n<p>On real systems, this is likely to end up with an access violation on the commented line, because the compiler used the fact that <code>fooObj</code> <strong>can't</strong> be null in <code>fooObj-&gt;func()</code> to eliminate the <code>if</code> test following it.</p>\n<p>Don't do things that are UB even if you think you know what your platform does.  <a href=\"https://people.csail.mit.edu/nickolai/papers/wang-stack.pdf\" rel=\"nofollow noreferrer\">Optimization instability is real.</a></p>\n<hr>\n<p>Also, the Standard is even more restrictive that you might think.  This will <em>also</em> cause UB:</p>\n<pre><code>struct Foo\n{\n    int member;\n    void func() { std::cout &lt;&lt; \"hello\";}\n    static void s_func() { std::cout &lt;&lt; \"greetings\";}\n};\n\nint main()\n{\n    Foo* fooObj = nullptr;\n    fooObj-&gt;s_func(); // well-formed call to static member,\n         // but unlike Foo::s_func(), it requires *fooObj to be a valid object of type Foo\n}\n</code></pre>\n<p>The relevant portions of the Standard are found in <code>[expr.ref]</code>:</p>\n<blockquote>\n<p id=\"so_49213446_49213482_1\">The expression <code>E1-&gt;E2</code> is converted to the equivalent form <code>(*(E1)).E2</code></p>\n</blockquote>\n<p>and the accompanying footnote</p>\n<blockquote>\n<p id=\"so_49213446_49213482_2\">If the class member access expression is evaluated, the subexpression evaluation happens even if the result is unnecessary to determine the value of the entire postfix expression, for example if the <em>id-expression</em> denotes a static member.</p>\n</blockquote>\n<p>This means that the code in question definitely evaluates <code>(*fooObj)</code>, attempting to create a reference to a non-existent object.  There have been several proposals to make this allowed and only forbid allowing lvalue-&gt;rvalue conversion on such a reference, but those have been rejected this far; even forming the reference is illegal in all versions of the Standard to date.</p>\n</hr></hr>", "LastEditorUserId": "103167", "LastActivityDate": "2018-03-10T21:12:52.160", "Score": "6", "CreationDate": "2018-03-10T20:02:59.473", "ParentId": "49213446", "CommentCount": "22", "OwnerUserId": "103167", "LastEditDate": "2018-03-10T21:12:52.160"}, "49213479": {"Id": "49213479", "PostTypeId": "2", "Body": "<p>In practice this is usually how major compilers implement member functions, yes. This means that your test program would probably appear to run \"just fine\".</p>\n<p>Having said that, dereferencing a pointer pointing to <code>nullptr</code> is undefined behavior which means that all bets are off and the whole program and it's output is meaningless, anything could happen. </p>\n<p>You can never rely on this behavior, optimizers in particular could mess all of this code up because they're allowed to assume that <code>fooObj</code> is never <code>nullptr</code>.</p>\n", "LastActivityDate": "2018-03-10T20:02:41.783", "Score": "1", "CreationDate": "2018-03-10T20:02:41.783", "ParentId": "49213446", "CommentCount": "0", "OwnerUserId": "1870760"}});