post_cb({"26484734": {"CommentCount": "0", "AcceptedAnswerId": "26486274", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2014-10-21T10:42:20.007", "LastActivityDate": "2015-06-28T15:32:38.507", "LastEditDate": "2014-10-21T11:33:13.470", "ViewCount": "242", "FavoriteCount": "1", "Title": "Temporary lifetime and perfect forwarding constructor", "Id": "26484734", "Score": "7", "Body": "<p>I am having trouble understanding why the lifetime of temporaries bound to const reference parameters is cut short when there is a perfect forwarding constructor around. First of, what we know about temporaries bound to reference parameters: they last for the full expression:</p>\n<blockquote>\n<p id=\"so_26484734_26484734_0\">A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call</p>\n</blockquote>\n<p>However I found cases where this is not true (or I might simply misunderstand what a full expression is). Let's take a simple example, first we define an object with verbose constructors and destructors:</p>\n<pre><code>struct A {\n  A(int &amp;&amp;) { cout &lt;&lt; \"create A\" &lt;&lt; endl; }\n  A(A&amp;&amp;) { cout &lt;&lt; \"move A\" &lt;&lt; endl; }\n  ~A(){ cout &lt;&lt; \"kill A\" &lt;&lt; endl; }\n};\n</code></pre>\n<p>And an object wrapper B, which will be used for reference collapsing:</p>\n<pre><code>template &lt;class T&gt; struct B {\n  T value;\n  B() : value() { cout &lt;&lt; \"new B\" &lt;&lt; endl; }\n  B(const T &amp;__a) : value(__a) { cout &lt;&lt; \"create B\" &lt;&lt; endl; }\n  B(const B &amp;p) = default;\n  B(B &amp;&amp; o) = default;\n  ~B(){ cout &lt;&lt; \"kill B\" &lt;&lt; endl; };\n};\n</code></pre>\n<p>We can now use our wrapper to capture references on temporaries and use them in function calls, like so:</p>\n<pre><code>void foo(B&lt;const A&amp;&gt; a){ cout &lt;&lt; \"Using A\" &lt;&lt; endl; }\nint main(){ foo( {123} ); }\n</code></pre>\n<p>The program above prints what I would expect:</p>\n<pre><code>create A\ncreate B\nUsing A\nkill B\nkill A\n</code></pre>\n<p>So far so good. Now let's move back to <code>B</code> and add a perfect forwarding constructor for convertible types:</p>\n<pre><code>template &lt;class T&gt; struct B {\n  /* ... */\n  template &lt;class U, class = typename enable_if&lt;is_convertible&lt;U, T&gt;::value&gt;::type&gt;\n    B(U &amp;&amp;v) : value(std::forward&lt;U&gt;(v)) { \n      cout &lt;&lt; \"new forward initialized B\" &lt;&lt; endl; \n    }\n};\n</code></pre>\n<p>Compiling the same code again now gives:</p>\n<pre><code>create A\nnew forward initialized B\nkill A\nUsing A\nkill B\n</code></pre>\n<p>Note that our <code>A</code> object was now killed before it was used, which is bad! Why did the lifetime of the temporary <strong>not</strong> get extended to the full call of <code>foo</code> in this case? Also, there is no other call to the desctructor of <code>A</code>, so there is no other instance of it.</p>\n<p>I can see two possible explanations: </p>\n<ul>\n<li>either the types are not what I think they are: changing the convertible move constructor to <code>B(T &amp;&amp;v)</code> instead of <code>template &lt;class U&gt;B(U &amp;&amp;v)</code> solves the problem.</li>\n<li>or <code>{123}</code> is not a subexpression of <code>foo( {123} )</code>. Swapping <code>{123}</code> for <code>A(123)</code> also solves the issue, which makes me wonder if brace-initializers are full expressions.</li>\n</ul>\n<p>Could someone clarify what is going on here?</p>\n<p>Does this mean that adding a forwarding constructor to a class could break backward compatibility in some cases, like it did for <code>B</code>?</p>\n<p>You can find the full code <a href=\"http://ideone.com/BZ6tm4\" rel=\"noreferrer\">here</a>, with another test case crashing for references to strings.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "401200", "AnswerCount": "2"}, "26486274": {"ParentId": "26484734", "CommentCount": "3", "Body": "<p>The type inferred for <code>U</code> in the call to <code>B&lt;A const&amp;&gt;::B(U&amp;&amp;)</code> is <code>int</code>, so the only temporary that can be lifetime-extended for the call to <code>foo</code> in <code>main</code> is a prvalue <code>int</code> temporary initialized to <code>123</code>.</p>\n<p>The member <code>A const&amp; value</code> is bound to a temporary <code>A</code>, but that <code>A</code> is created in the <em>mem-initializer-list</em> of the constructor <code>B&lt;A const&amp;&gt;::B(U&amp;&amp;)</code> so its lifetime is extended only for the duration of that member initialization <strong>[class.temporary]</strong>/5:</p>\n<blockquote>\n<p id=\"so_26484734_26486274_0\">\u2014 A temporary bound to a reference member in a constructor\u2019s <em>ctor-initializer</em> (12.6.2) persists until the constructor exits.</p>\n</blockquote>\n<p>Note that a <em>mem-initializer-list</em> is the part after the colon in a <em>ctor-initializer</em>:</p>\n<pre><code>  template &lt;class U, class = typename enable_if&lt;is_convertible&lt;U, T&gt;::value&gt;::type&gt;\n    B(U &amp;&amp;v) : value(std::forward&lt;U&gt;(v)) { \n             ^--- ctor-initializer\n               ^--- reference member\n                    ^--- temporary A\n</code></pre>\n<p>This is why <code>kill A</code> is printed <em>after</em> <code>new forward initialized B</code>.</p>\n<blockquote>\n<p id=\"so_26484734_26486274_1\">Does this mean that adding a forwarding constructor to a class could break backward compatibility in some cases, like it did for <code>B</code>?</p>\n</blockquote>\n<p>Yes. In this case it's difficult to see why the forwarding constructor would be necessary; it's certainly dangerous where you have a reference member that a temporary could be bound to.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "26486274", "Score": "5", "CreationDate": "2014-10-21T12:04:53.607", "LastActivityDate": "2014-10-21T12:04:53.607"}, "26486136": {"ParentId": "26484734", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>void foo(B&lt;const A&amp;&gt; b);\n\nfoo( {123} );\n</code></pre>\n<p>is semantically equivalent to:</p>\n<pre><code>B&lt;const A&amp;&gt; b = {123};\n</code></pre>\n<p>that for a <em>non-explicit</em> constructor is semantically equivalent to:</p>\n<pre><code>B&lt;const A&amp;&gt; b{123};\n</code></pre>\n<p>going further, since your <em>forwarding-constructor</em> takes anything, it actually is initialized with <code>int</code>, not <code>A</code>:</p>\n<pre><code>B&lt;const A&amp;&gt;::B(int&amp;&amp; v)\n</code></pre>\n<p>That is, a temporary instance of <code>A</code> is created on the constructor's initialization list:</p>\n<pre><code>B(int&amp;&amp; v) : value(A{v}) {}\n//    created here ^      ^ destroyed here\n</code></pre>\n<p>which is <em>legal</em>, just like you can type <code>const A&amp; a{123};</code>.</p>\n<p>This <code>A</code> instance is destroyed after the <code>B</code>'s construction is finished, and you end up with a <em>dangling reference</em> within the body of <code>foo</code>.</p>\n<p>The situation changes when you build the instance in a call expression, then the <code>A</code> temporary ends its lifetime at the end of the call expression:</p>\n<pre><code> foo( A{123} );\n //           ^ A is destroyed here\n</code></pre>\n<p>so it stays alive within <code>foo</code>, and the <em>forwarding-constructor</em> selected for <code>B&lt;const A&amp;&gt;</code> is instantiated with a type <code>A&amp;&amp;</code>. </p>\n", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "LastEditDate": "2015-06-28T15:32:38.507", "Id": "26486136", "Score": "3", "CreationDate": "2014-10-21T11:58:06.143", "LastActivityDate": "2015-06-28T15:32:38.507"}, "bq_ids": {"n4140": {"so_26484734_26484734_0": {"section_id": 382, "quality": 0.8571428571428571, "length": 12}, "so_26484734_26486274_0": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_26484734_26484734_0": {"section_id": 373, "quality": 0.8571428571428571, "length": 12}, "so_26484734_26486274_0": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_26484734_26484734_0": {"section_id": 397, "quality": 0.7857142857142857, "length": 11}}}});