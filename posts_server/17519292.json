post_cb({"17519549": {"ParentId": "17519292", "CommentCount": "0", "Body": "<p>That is indeed undefined behaviour, the correct way of doing it is to call the destructor of every object allocated in that block of memory explicitly and then deallocate the memory block itself.</p>\n<pre><code>obj-&gt;~FooBar();\ndelete[] memory;\n</code></pre>\n<p>Remember that placement new just construct the object, it doesnt allocate the memory, so the object shouldnt free it. If YOU allocate the memory, you should free it, if you constructed the object, you should only deconstruct it.</p>\n", "OwnerUserId": "1297125", "PostTypeId": "2", "Id": "17519549", "Score": "5", "CreationDate": "2013-07-08T05:11:37.027", "LastActivityDate": "2013-07-08T05:11:37.027"}, "17519743": {"ParentId": "17519292", "LastEditDate": "2017-05-23T12:24:15.203", "CommentCount": "3", "CreationDate": "2013-07-08T05:35:01.720", "OwnerUserId": "951423", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "17519743", "Score": "6", "Body": "<p>The C++ standard tells you why it is undefined what you're doing.\nIt may be the case that the deallocation that is invoked by <code>delete</code> uses the prepended size info of the allocated block and deallocates it properly but you can't rely on that.</p>\n<h3>\u00a75.3.5 Delete</h3>\n<blockquote>\n<p id=\"so_17519292_17519743_0\">The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.\n  delete-expression:  </p>\n<ul>\n<li>::delete cast-expression  </li>\n<li>::delete [ ] cast-expression</li>\n</ul>\n<p id=\"so_17519292_17519743_1\">The first alternative is for non-array objects, and the second is for arrays. Whenever the delete keyword is immediately followed by empty square brackets, it shall be interpreted as the second alternative. [...]</p>\n</blockquote>\n<p>That to be said, now we come to the more interesting part:</p>\n<blockquote>\n<p id=\"so_17519292_17519743_2\">2 [...] In the first alternative (delete object), the value of the operand of delete may be a null pointer value, a pointer to a non-array object created by a previous new-expression, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). <strong>If not, the behavior is undefined.</strong> [...]</p>\n</blockquote>\n<ol>\n<li>The pointer to your object was not created by the new expression but only object construction was done via placement new.</li>\n<li>The pointer at the address <code>obj</code> (which should, cast to <code>void*</code> be the same as <code>memory</code> cast to <code>void*</code> but afaik you can't even rely on that) points to was allocated using <code>new[]</code> so using <code>delete[]</code> is mandatory.</li>\n</ol>\n<p>See those related questions: </p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/4255598/delete-vs-delete\">delete vs delete[] [duplicate]</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1553382/is-delete-equal-to-delete\">Is delete[] equal to delete?</a></li>\n</ul>\n<hr>\n<p>If you want to have a pre-allocated storage for several objects of the same type:\nconsider using <code>std::vector&lt;FooBar&gt;::reserve()</code>. </p>\n<p><code>emplace_back()</code> or <code>push_back()</code> will then do in-place construction of the objects. </p>\n</hr>", "LastActivityDate": "2013-07-08T05:52:27.973"}, "17519292": {"CreationDate": "2013-07-08T04:41:21.013", "CommentCount": "12", "ViewCount": "247", "PostTypeId": "1", "ClosedDate": "2013-07-08T07:23:41.047", "LastEditorUserId": "1091386", "LastActivityDate": "2013-07-08T05:52:27.973", "LastEditDate": "2013-07-08T05:15:24.243", "AcceptedAnswerId": "17519743", "FavoriteCount": "1", "Title": "C++ delete, but not just the type", "Id": "17519292", "Score": "3", "Body": "<p>Assume I want to allocate only 256 bytes memory blocks</p>\n<pre><code>char * memory = new char[256];\n</code></pre>\n<p>than I use placement new to create a FooBar object (sizeof(Foobar)&lt;=256)</p>\n<pre><code>FooBar * obj = new (memory) FooBar();\n</code></pre>\n<p>does</p>\n<pre><code>delete obj; //this also calls the destructor of FooBar\n</code></pre>\n<p>delete all the 256 bytes of memory?</p>\n<p>Does the standard guarantee that the whole \"memory\" buffer is deallocated by just \"deleting obj\"? Or it is based on the type \"FooBar\" and therefore this operation has undefined behaviour?</p>\n<p>Assumption: FooBar is the only object in the memory buffer.</p>\n<p>This is not duplicate question, please first understand the question. It is not immediately evident what this code does.</p>\n", "Tags": "<c++><allocation><placement-new><delete-operator>", "OwnerUserId": "1829943", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17519292_17519743_1": {"section_id": 6105, "quality": 0.9444444444444444, "length": 17}, "so_17519292_17519743_2": {"section_id": 6106, "quality": 0.9629629629629629, "length": 26}, "so_17519292_17519743_0": {"section_id": 6105, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_17519292_17519743_1": {"section_id": 5871, "quality": 0.9444444444444444, "length": 17}, "so_17519292_17519743_2": {"section_id": 5872, "quality": 0.9629629629629629, "length": 26}, "so_17519292_17519743_0": {"section_id": 5871, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_17519292_17519743_1": {"section_id": 7602, "quality": 0.9444444444444444, "length": 17}, "so_17519292_17519743_2": {"section_id": 7603, "quality": 0.9629629629629629, "length": 26}, "so_17519292_17519743_0": {"section_id": 7602, "quality": 0.8181818181818182, "length": 9}}}});