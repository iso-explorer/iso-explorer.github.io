post_cb({"26614734": {"Id": "26614734", "PostTypeId": "2", "Body": "<p>C99 allows a feature called <em>flexible array members</em>. This is described in \u00a76.7.2.1/18 of the C11 standard:</p>\n<blockquote>\n<p id=\"so_26614439_26614734_0\">As a special case, the last element of a structure with more than one\n  named member may have an incomplete array type; this is called a\n  flexible array member. In most situations, the flexible array member\n  is ignored.</p>\n</blockquote>\n<p>They are not a part of C++, but some compilers allow their use as an extension. For example, <a href=\"https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions\" rel=\"nofollow\">GCC</a> explicitly notes this on their C extensions page:</p>\n<blockquote>\n<p id=\"so_26614439_26614734_1\">Some features that are in ISO C99 but not C90 or C++ are also, as\n  extensions, accepted by GCC in C90 mode and in C++.</p>\n</blockquote>\n<p>For compatibility, Clang generally implements GNU extensions. Note that using <code>sizeof</code> on said member either appears to be a GCC bug or extension:</p>\n<blockquote>\n<p id=\"so_26614439_26614734_2\">Flexible array members have incomplete type, and so the sizeof\n  operator may not be applied. As a quirk of the original implementation\n  of zero-length arrays, sizeof evaluates to zero.</p>\n</blockquote>\n<p>Additionally, a flexible array member being the sole data member in class is a GNU extension.</p>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-10-28T17:29:43.907", "Score": "1", "CreationDate": "2014-10-28T17:29:43.907", "ParentId": "26614439", "CommentCount": "0"}, "bq_ids": {"n4140": {"so_26614439_26614579_0": {"length": 19, "quality": 1.0, "section_id": 5869}}, "n3337": {"so_26614439_26614579_0": {"length": 19, "quality": 1.0, "section_id": 5640}}, "n4659": {"so_26614439_26614579_0": {"length": 19, "quality": 1.0, "section_id": 7352}}}, "26614579": {"Id": "26614579", "PostTypeId": "2", "Body": "<p>According to the C++ Standard (9.2 Class members)</p>\n<blockquote>\n<p id=\"so_26614439_26614579_0\">9 <strong>Non-static (9.4) data members shall not have incomplete types</strong>. In\n  particular, a class C shall not contain a non-static member of class\n  C, but it can contain a pointer or reference to an object of class C.</p>\n</blockquote>\n<p>So it is either a compiler feature or its bug.</p>\n<p>An array as a non-static data member of a class is stored where the corresponding object of that class was allocated.</p>\n<p>As for C then C allows to define flexible array members of structures.</p>\n<p>From the C Standard (6.7.2.1 Structure and union specifiers)</p>\n<blockquote>\n<p id=\"so_26614439_26614579_1\">18 As a special case, the last element of a structure with more than\n  one named member <strong>may have an incomplete array type</strong>; this is called a\n  flexible array member</p>\n</blockquote>\n<p>But in this case a structure shall have <strong>more than one named member</strong>.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-10-28T17:37:55.633", "Score": "2", "CreationDate": "2014-10-28T17:21:37.347", "ParentId": "26614439", "CommentCount": "0", "OwnerUserId": "2877241", "LastEditDate": "2014-10-28T17:37:55.633"}, "26614649": {"Id": "26614649", "PostTypeId": "2", "Body": "<p>No way. <strong>char array[]</strong> is same as pointer to char. That means that you can do this.</p>\n<pre><code>char* pointer;\nchar array[];\narray=pointer;\n</code></pre>\n<p>Pointers have value, which was in memory when was pointer created. Simply points somewhere into memory.<br>\nArrays work the same way as pointers. If <strong>int</strong> have 4bytes, <strong>array[5]</strong> points to int 5*4=20 after bytes that pointer.</br></p>\n<pre><code>int array[];\narray[5];\n*(array+5);\n</code></pre>\n<p>C++ doesnt throw exception after crossing the array. Usually shoud program crash because pointers by default point to place somewhere in memory out of the program.</p>\n", "LastEditorUserId": "3797407", "LastActivityDate": "2014-10-28T17:32:22.740", "Score": "0", "CreationDate": "2014-10-28T17:25:47.323", "ParentId": "26614439", "CommentCount": "0", "OwnerUserId": "3797407", "LastEditDate": "2014-10-28T17:32:22.740"}, "26614576": {"Id": "26614576", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26614439_26614576_0\">Why is it possible to declare array data members with no size?</p>\n</blockquote>\n<p>In standard C++, it isn't. In C, you can put one at the end of a struct, to allow a variable-size array - but you must make sure you allocate enough storage for whatever size you want to use. Some C++ compilers may allow this as a non-standard extension.</p>\n<blockquote>\n<p id=\"so_26614439_26614576_1\">Does this mean that obj2's array data member is stored in automatic storage, but the size is determined dynamically at runtime ?</p>\n</blockquote>\n<p>No, it means there isn't any storage for the array, and you're writing over other parts of the stack. That's not a good idea.</p>\n<p>If you want a dynamic array, use <code>std::vector</code>.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-10-28T17:35:34.550", "Score": "4", "CreationDate": "2014-10-28T17:21:26.540", "ParentId": "26614439", "CommentCount": "1", "OwnerUserId": "204847", "LastEditDate": "2014-10-28T17:35:34.550"}, "26615052": {"Id": "26615052", "PostTypeId": "2", "Body": "<p>Move your test into a new function called from the main(),  then you should see the stack-smashing.</p>\n", "LastActivityDate": "2014-10-28T17:47:14.720", "CommentCount": "0", "CreationDate": "2014-10-28T17:47:14.720", "ParentId": "26614439", "Score": "0", "OwnerUserId": "1698661"}, "26614439": {"ViewCount": "391", "Body": "<p>I'm trying to understand how arrays work in C++. Some good threads on SO, but one question I have that I can't find the answer to is:</p>\n<p>Why is it possible to declare array data members with no size? I thought in C++ an array size had to be a compile-time constant?</p>\n<p>Example:</p>\n<pre><code>#include&lt;iostream&gt;\n\nclass Object{\n\npublic:\n      Object(std::size_t n){  \n\n        for(std::size_t i = 0; i&lt;n; ++i) { array[i] ='X'; }\n\n        //prints 0 because 'sizeof' is compile-time operator\n        std::cout &lt;&lt; \"compile-time size: \" &lt;&lt; sizeof(array) &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"run-time size \" &lt;&lt; n &lt;&lt; std::endl;\n      }\n\nprivate:\n      char array[];\n};  \n\nint main( int argc, char** argv )\n{\n  Object obj(10);      //10 chars\n\n  std::size_t n;\n  std::cin &gt;&gt; n;\n  Object obj2(n);      //n chars in automatic storage i.e. on the stack??\n}\n\nInput: \n  n = 1000\nOutput: \n  compile-time size: 0\n  run-time size 10\n  compile-time size: 0\n  run-time size 1000\n</code></pre>\n<p>Does this mean that obj2's array data member is stored in automatic storage, but the size is determined dynamically at runtime ?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "26614579", "Title": "Array data members declared with no size", "CreationDate": "2014-10-28T17:14:16.407", "Id": "26614439", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-10-28T17:47:14.720", "Score": "0", "OwnerUserId": "4074699", "Tags": "<c++><arrays>", "AnswerCount": "5"}});