post_cb({"24502115": {"Id": "24502115", "PostTypeId": "2", "Body": "<p>My opinion: yes, it is possible in C++.  There have been several SO threads on this topic, none of which reached any solid conclusion. <a href=\"https://stackoverflow.com/questions/8428605/can-i-access-multidimensional-array-using-a-pointer\">Here is one example</a>.</p>\n<p>In some cases we can be sure that there is actually a valid object in memory immediately after the end of the old object. One case is standard-layout structs; another is multi-dimensional arrays. I originally wrote this post with a multi-dimensional array, but I have edited it to use the standard layout struct case, to avoid any objections about what the term \"array object\" means in the Standard.</p>\n<pre><code>struct\n{\n    int a[2];\n    int b[2];\n} foo;\n\nif ( sizeof foo == 4 * sizeof(int) )\n{\n    int *p = &amp;foo.a[0];\n\n    ++p;    // (1)\n    ++p;    // (2)\n    *p = 3; // (3)\n    ++p;    // (4)\n    *p = 5; // (5)\n}\n</code></pre>\n<p>Which line causes undefined behaviour (if any)? <code>p</code> is (initially, anyway) a pointer into the array of type <code>int[2]</code> which is designated by <code>foo.a</code>.</p>\n<p>After line <code>(2)</code>, <code>p</code> is now a one-past-the-end pointer. Is this dereferenceable?</p>\n<p>The case of incrementing the pointer is covered by the section on the <code>+</code> operator (it is defined to have the same effect on <code>p</code> as <code>p = p + 1</code>). Here is a quote from C++11 [expr.add]#7:</p>\n<blockquote>\n<p id=\"so_24501573_24502115_0\">Unless both pointers point to elements of the same array object, or\n  one past the last element of the array object, the behavior is undefined.</p>\n</blockquote>\n<p>Line (2) does not cause UB by this clause. What about line (3)?</p>\n<p>As far as I can see, there is no clause in the C++ standard that says dereferencing a one-past-the-end pointer causes undefined behaviour. In several places it says that iterators \"might not be dereferencable\", or \"the library does not assume that the iterator is dereferenceable\". But it carefully avoids saying \"the iterator is not dereferenceable\".</p>\n<p>From the fact that we proved there is no padding, and the rules about standard-layout structs saying that elements cannot be reordered; we can conclude that now <code>p</code> must hold the address of the element <code>foo.b[0]</code>.  Therefore, <code>p</code> is a pointer into the subobject <code>foo.b</code>, <em>as well as</em> being a one-past-the-end pointer for <code>foo.a</code>. </p>\n<hr>\n<p>Note that in C99 it is different. The text <strong>in C99</strong> for the <code>+</code> operator has (emphasis mine):</p>\n<blockquote>\n<p id=\"so_24501573_24502115_1\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined. <strong>If the result points one past the last element of the array object, it\n  shall not be used as the operand of a unary * operator that is evaluated.</strong></p>\n</blockquote>\n<p>So, in C99 line (3) causes undefined behaviour. However C++ deliberately omits the bolded line. </p>\n<hr>\n<p><strong>Rationale:</strong> I don't know what the actual rationale is. However, my \"mental model\" for C's pointers is that it permits the compiler to implement \"fat pointers\", i.e. bounds-checked pointers. A pointer may contain the bounds of the (sub-)object that it was pointed to; and so the executable can detect array bounds errors at runtime just based on the pointer value.</p>\n<p>I believe the C99 text is compatible with this; and the compiler can produce an executable that aborts on line <code>(3)</code>. </p>\n<p>However , as already stated, C++ does not have equivalent text and I can find no justification in the C++ Standard for considering <code>(3)</code> to cause UB; nor <code>(4)</code> or <code>(5)</code>.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-01T03:53:36.880", "Score": "2", "CreationDate": "2014-07-01T03:37:47.353", "ParentId": "24501573", "CommentCount": "11", "OwnerUserId": "1505939", "LastEditDate": "2017-05-23T12:31:29.167"}, "24501664": {"Id": "24501664", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24501573_24501664_0\">Is it possible that:</p>\n<p id=\"so_24501573_24501664_1\">One array's off-the-end pointer points to another array's first element?</p>\n</blockquote>\n<p>I'm not sure by what you mean by off the end pointer. As c++ iterators use half open ranges, I'm assuming you mean the pointer that represents the end position in an iteration. As that is one past the end, yes, it might overlap a next array, and hence it may not be dereferenced.</p>\n<p>When using pointers as iterators, addresses and not values are compared. End implies the next address beyond end.</p>\n", "LastEditorUserId": "1400817", "LastActivityDate": "2014-07-01T02:39:34.043", "Score": "1", "CreationDate": "2014-07-01T02:31:04.650", "ParentId": "24501573", "CommentCount": "0", "OwnerUserId": "1400817", "LastEditDate": "2014-07-01T02:39:34.043"}, "24501573": {"ViewCount": "204", "Body": "<p>Considering that C++ does not have bound checking for built-in type arrays, Is it possible that:</p>\n<p>One array's off-the-end pointer points to another array's first element?</p>\n", "Title": "Will off-the-end pointer overlap with other object?", "CreationDate": "2014-07-01T02:16:25.173", "LastActivityDate": "2014-07-01T03:53:36.880", "CommentCount": "17", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-07-01T03:39:12.133", "OwnerDisplayName": "user3792254", "LastEditorUserId": "1505939", "Id": "24501573", "Score": "4", "Tags": "<c++><arrays><language-lawyer>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_24501573_24502115_1": {"length": 20, "quality": 0.6060606060606061, "section_id": 6142}, "so_24501573_24502115_0": {"length": 15, "quality": 0.9375, "section_id": 6143}, "so_24501573_24501664_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 6106}}, "n3337": {"so_24501573_24502115_1": {"length": 20, "quality": 0.6060606060606061, "section_id": 5906}, "so_24501573_24502115_0": {"length": 15, "quality": 0.9375, "section_id": 5907}, "so_24501573_24501664_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 5872}}, "n4659": {"so_24501573_24502115_0": {"length": 9, "quality": 0.5625, "section_id": 7639}, "so_24501573_24501664_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 7603}}}, "24501607": {"Id": "24501607", "PostTypeId": "2", "Body": "<p>Yes, a pointer beyond the end of an array could point to another object. Dereferencing a pointer beyond the end of an array results in undefined behavior.</p>\n", "LastActivityDate": "2014-07-01T02:22:47.453", "CommentCount": "1", "CreationDate": "2014-07-01T02:22:47.453", "ParentId": "24501573", "Score": "4", "OwnerUserId": "766900"}, "24501608": {"Id": "24501608", "PostTypeId": "2", "Body": "<p>Reading beyond the bound of an array might result in dirty read.</p>\n<ol>\n<li>It could be possible you may hit another array body</li>\n<li>but it could also be possible that you may hit an unallocated region or </li>\n<li>in case of int pointer you may point to a 4 byte region shared by an array of two shorts.</li>\n<li>Your pointer may try to access a region which does not belongs to your process.  Fatal error!</li>\n</ol>\n<p>Not recommended to go beyond the bounds. </p>\n<p>Regards\nKajal</p>\n", "LastEditorUserId": "1304519", "LastActivityDate": "2014-07-01T02:52:51.733", "Score": "1", "CreationDate": "2014-07-01T02:22:57.390", "ParentId": "24501573", "CommentCount": "0", "OwnerUserId": "1304519", "LastEditDate": "2014-07-01T02:52:51.733"}});