post_cb({"15181074": {"ParentId": "15180990", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From \"Working Draft C++, 2012-11-02\" </p>\n<blockquote>\n<p id=\"so_15180990_15181074_0\"><strong>18.9 Initializer lists [support.initlist]</strong><br>\n  2 An object of type initializer_list provides access to an array of objects of type const E. [ Note: A pair of pointers or a pointer plus a length would be obvious representations for initializer_list. initializer_list is used to implement initializer lists as specified in 8.5.4. <strong>Copying an initializer list does not copy the underlying elements</strong>. \u2014 end note ]</br></p>\n</blockquote>\n<p>If I copy the initializer list into a <code>std::vector</code> for example, it works perfectly. You should define your <code>choices</code> as a regular container, not as <code>std::initializer_list</code> </p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nstruct A {\n    A(const std::initializer_list&lt;std::string&gt; &amp;args) : v(args) {}\n    void dump() {\n        std::copy(v.begin(), v.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, \"\\n\"));\n    }\n\n    std::vector&lt;std::string&gt; v;\n};\n\nint main(int argc, char **argv)\n{\n    A a({\"Hello, \", \"world!\"});\n    a.dump();\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "1741542", "LastEditorUserId": "1741542", "LastEditDate": "2013-03-03T00:38:30.403", "Id": "15181074", "Score": "2", "CreationDate": "2013-03-03T00:26:17.403", "LastActivityDate": "2013-03-03T00:38:30.403"}, "15180990": {"CommentCount": "0", "ViewCount": "860", "PostTypeId": "1", "LastEditorUserId": "419", "CreationDate": "2013-03-03T00:14:38.967", "LastActivityDate": "2013-03-03T01:06:23.087", "LastEditDate": "2013-03-03T01:06:23.087", "AcceptedAnswerId": "15181074", "OwnerDisplayName": "user1508519", "Title": "C++ initializer_list iterator returning wrong value", "Id": "15180990", "Score": "0", "Body": "<p>I have a class defined like this:</p>\n<pre><code>initializer_list&lt;string&gt; choices;\ninitializer_list&lt;string&gt;::iterator current_choice;\nbool has_choices = false;\nMenuItem(Position position, string prompt) { this-&gt;position = position; this-&gt;prompt = prompt; }\nMenuItem(Position position, string prompt, initializer_list&lt;string&gt; choices) : MenuItem(position, prompt) {\n    this-&gt;choices = choices;\n    this-&gt;current_choice = this-&gt;choices.begin();\n    this-&gt;text = *(this-&gt;current_choice);\n    this-&gt;has_choices = true;\n}\n</code></pre>\n<p>The current menu item is defined as \n    MenuItem* current_menu_item = &amp;menuItems[menuItemIndex];</p>\n<p>When I iterate over the initializer_list in the constructor, the correct values are outputted. But later in the code when I try to switch the values, like so:</p>\n<pre><code> if (c == KEY_RIGHT) {\n    if (current_menu_item-&gt;has_choices)\n    {\n        if (current_menu_item-&gt;current_choice != current_menu_item-&gt;choices.end()) {\n            current_menu_item-&gt;current_choice++;\n            current_menu_item-&gt;text = *(current_menu_item-&gt;current_choice);\n        }\n    }\n}\n</code></pre>\n<p>It shows the first value of the initializer_list for the next menu item object, and I press right, then crashes. If the next object is selected, and I press right, it crashes.</p>\n<p>The objects are put into a vector like so</p>\n<pre><code>menuItems.push_back(MenuItem(Position(5, 15), \"Religion: \", { \"*\", \"*\", \"*\", \"Protestant\" }));\nmenuItems.push_back(MenuItem(Position(30, 5), \"Do you smoke? \", { \"Yes\", \"No\" }));\n</code></pre>\n<p>I've tried debugging at various points throughout the code, but I cannot seem to pinpoint where or why it goes wrong. </p>\n<hr>\n<p>Nevermind, two people pointed out I should use a regular container instead of an initializer_list. Thanks everybody for their answers. I feel dumb now. All I had to do was change the initializer_list to a vector, without changing any other code. I love C++.</p>\n</hr>", "Tags": "<c++><initializer-list>", "AnswerCount": "3"}, "15181061": {"ParentId": "15180990", "CommentCount": "0", "Body": "<p>Your second constructor copies choices by value. Therefore, <code>current_choice</code> as iterator validity depends on liveliness of parameter choices. Parameters like <code>{ \"*\", \"*\", \"*\", \"Protestant\" }</code> are kept in stack therefore if the method which calls <code>push_back</code> returns then <code>choices</code> might disappear and current_choice as iterator becomes a dangling \"pointer\".</p>\n", "OwnerUserId": "1952879", "PostTypeId": "2", "Id": "15181061", "Score": "0", "CreationDate": "2013-03-03T00:23:10.113", "LastActivityDate": "2013-03-03T00:23:10.113"}, "bq_ids": {"n4140": {"so_15180990_15181074_0": {"section_id": 6955, "quality": 0.7631578947368421, "length": 29}}, "n3337": {"so_15180990_15181074_0": {"section_id": 6702, "quality": 0.7631578947368421, "length": 29}}, "n4659": {"so_15180990_15181074_0": {"section_id": 8452, "quality": 0.7631578947368421, "length": 29}}}, "15181063": {"ParentId": "15180990", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Shouldn't you increment after (not before) you dereference the iterator?</p>\n<pre><code>current_menu_item-&gt;text = *(current_menu_item-&gt;current_choice);\ncurrent_menu_item-&gt;current_choice++;\n</code></pre>\n<p>Otherwise, there is a possibility you are dereferencing the end iterator.</p>\n<p>Also, another problem, as pointed out by mfontanini, when you call <code>MenuItem(Position(5, 15), \"Religion: \", { \"*\", \"*\", \"*\", \"Protestant\" })</code>, etc. that initializer list <strong>expires</strong> at the end of expression, which means your internal intializer list points to invalid memory (initializer lists only copy over pointers). The solution is to use a standard container like <code>std::vector</code>.</p>\n", "OwnerUserId": "906773", "LastEditorUserId": "906773", "LastEditDate": "2013-03-03T00:40:09.887", "Id": "15181063", "Score": "1", "CreationDate": "2013-03-03T00:24:50.807", "LastActivityDate": "2013-03-03T00:40:09.887"}});