post_cb({"10403080": {"Id": "10403080", "PostTypeId": "2", "Body": "<p>It is normal for the offsets to be different between a base class and a derived class, especially when multiple inheritance is involved. The compiler provides invisible fixups to modify a pointer address whenever it converts from one type to another.</p>\n<p>It has to be this way, because each pointer type must be consistent in the kind of object it points to. <code>A* p1 = new A</code> and <code>A* p2 = new B</code> must use the same offsets for p1 and p2.</p>\n", "LastEditorUserId": "5987", "LastActivityDate": "2012-05-01T19:32:52.877", "Score": "0", "CreationDate": "2012-05-01T19:26:20.003", "ParentId": "10401579", "CommentCount": "1", "LastEditDate": "2012-05-01T19:32:52.877", "OwnerUserId": "5987"}, "10401579": {"ViewCount": "388", "Body": "<p>using gcc/g++ 4.6.1  Is this a compiler bug or a language feature?  Though the compiler didn't yell at me so I guess it is a least a compiler shortcoming.</p>\n<p>I have a parent class with operator <code>new</code> overloaded:</p>\n<pre><code>class C{ // just here to be faithful to the original code\n  int y;\n}\n\nclass A{\npublic:\n  void* operator new(size_t enfacia_size, uint count){\n      size_t total_size \n      = enfacia_size\n      + item::size() * count; // the 'tail'\n      ;\n      this_type *new_pt = (this_type *)malloc(total_size);\n      new_pt-&gt;count = count;\n      return new_pt;\n  }\n  uint count;\n}\n\nclass B : public C, public A{\npublic:\n    int i;\n};\n</code></pre>\n<p>The object itself is variable length, so it needs to know how long it is.  Hence there is a <code>count</code> field. In this call the count is found at offset 0:</p>\n<pre><code>...\nnew A *pt = new(10) A;  // offset_of(A,count)==0\nnew B *pt = new(10) B;  // offset_of(B,count)==4\n</code></pre>\n<p>Here is the problem, inside of operator <code>new</code>, the value for <code>count</code> is always written at offset 0, whether it was called from the parent or from the child. So, when used in inheritance the program crashes .. Is there an issue with static methods and inheritance?   What is going on with this?</p>\n", "Title": "operator new field value has wrong offset in multiple inheritance", "CreationDate": "2012-05-01T17:24:51.057", "LastActivityDate": "2012-05-07T22:32:08.473", "CommentCount": "4", "LastEditDate": "2012-05-07T22:32:08.473", "PostTypeId": "1", "LastEditorDisplayName": "user1040049", "Id": "10401579", "Score": "0", "OwnerUserId": "1368207", "Tags": "<c++><operator-overloading><new-operator>", "AnswerCount": "8"}, "10455807": {"Id": "10455807", "PostTypeId": "2", "Body": "<p>Yes field move in multiple inheritance, here is an example showing a moving field, with the same code form as he original example.  The only significant difference being that instead of being called 'operator new' the method is called 'method'.  After the code example is the debugger output showing the field moved, and the value correctly assigned to the field even through it moved:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;stdlib.h&gt;\ntypedef unsigned int uint;\n\nclass C{ // just here to be faithful to the original code\n  int y;\n};\n\n\nclass A{\npublic:\n  typedef A this_type;\n\n  void* method(uint count){\n    void *vp;\n    vp = (void *)this;\n    this_type *p;\n    p = (this_type *)vp;\n    p-&gt;count = count;   \n  };\n\n  uint count;\n};\n\nclass B : public C, public A{\npublic:\n    typedef B this_type;\n    int i;\n};\n\nint main(){\n  int j;\n\n  A a;\n  a.method(5);\n  j++;\n\n  B b;\n  b.method(5);\n  j++;\n\n};\n</code></pre>\n<p>Debugger output:</p>\n<pre><code>(gdb) b main\nBreakpoint 1 at 0x80484a1: file try_offsets_2.ex.cc, line 36.\n(gdb) r\nStarting program: /try_offsets_2 \nBreakpoint 1, main () at try_offsets_2.ex.cc:36\n(gdb) n\n(gdb) \n$1 = (A *) 0xbffff758\n(gdb) x /10x &amp;a\n0xbffff758: 0x00000005  0x003dbff4  0x08048500  0x003dbff4\n0xbffff768: 0x00000000  0x0027d113  0x00000001  0xbffff804\n0xbffff778: 0xbffff80c  0x0012eff4\n(gdb) n\n(gdb) x /10x &amp;b\n0xbffff74c: 0x003dc324  0x00000005  0x00296c55  0x00000005\n0xbffff75c: 0x003dbff5  0x08048500  0x003dbff4  0x00000000\n0xbffff76c: 0x0027d113  0x00000001\n(gdb) \n</code></pre>\n<p>Notice the 5, which was at offset 0 in the parent is at offset 4 in the child.  Notice also that though the parent method was inherited to the child that its type was updated so that it correctly wrote to the field at offset 4.  </p>\n", "LastActivityDate": "2012-05-04T20:36:01.413", "Score": "0", "CreationDate": "2012-05-04T20:36:01.413", "ParentId": "10401579", "CommentCount": "10", "OwnerUserId": "1368207"}, "bq_ids": {"n4140": {"so_10401579_10403000_1": {"length": 27, "quality": 0.84375, "section_id": 7193}, "so_10401579_10403000_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}}, "n3337": {"so_10401579_10403000_1": {"length": 27, "quality": 0.84375, "section_id": 6937}, "so_10401579_10403000_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}}, "n4659": {"so_10401579_10403000_1": {"length": 26, "quality": 0.8125, "section_id": 8702}, "so_10401579_10403000_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}}}, "10457799": {"Id": "10457799", "PostTypeId": "2", "Body": "<p>This code also has a void pointer in a method cast to the local type:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;stdlib.h&gt;\ntypedef unsigned int uint;\n\nclass C{ // just here to be faithful to the original code\n  int y;\n};\n\n\nclass A{\npublic:\n  typedef A this_type;\n\n  void* method(uint count){\n    void *vp;\n    vp = (void *)this;\n    this_type *p;\n    p = (this_type *)vp;\n    p-&gt;count = count;   \n  };\n\n  uint count;\n};\n\nclass B : public C, public A{\npublic:\n    typedef B this_type;\n    int i;\n};\n\nint main(){\n  int j;\n\n  A a;\n  a.method(5);\n  j++;\n\n  B b;\n  b.method(5);\n  j++;\n\n};\n</code></pre>\n<p>And it works as expected:</p>\n<pre><code>(gdb) b main\nBreakpoint 1 at 0x80484a1: file try_offsets_2.ex.cc, line 36.\n(gdb) r\nStarting program: /try_offsets_2 \nBreakpoint 1, main () at try_offsets_2.ex.cc:36\n(gdb) n\n(gdb) \n$1 = (A *) 0xbffff758\n(gdb) x /10x &amp;a\n0xbffff758:    0x00000005    0x003dbff4    0x08048500    0x003dbff4\n0xbffff768:    0x00000000    0x0027d113    0x00000001    0xbffff804\n0xbffff778:    0xbffff80c    0x0012eff4\n(gdb) n\n(gdb) x /10x &amp;b\n0xbffff74c:    0x003dc324    0x00000005    0x00296c55    0x00000005\n0xbffff75c:    0x003dbff5    0x08048500    0x003dbff4    0x00000000\n0xbffff76c:    0x0027d113    0x00000001\n(gdb)\n</code></pre>\n<p>You can see count for the child was set.  Yes, I know how this works, and yes of course this is the expected result. The reason being, the 'this' pointer is correctly set when method() is called.</p>\n<p>The question, the original question here, is that operator new does not produce the expect result for the child, instead acting like the parent type.  Yet, operator new with assignment in it is inherited without any noise from the compiler.</p>\n<p>I think, the real answer to all of this is that operator new differs from other methods in that it is not passed a phantom first operand of a this pointer.  And how could it as n.m. pointed out above, as the object does not exist yet.  Though the type definition already exist, the means by which the compiler communicates type to child methods in multiple inheritance is through the phantom first operand this pointer that has been set to point to the proper area of the object for the type the method was defined under.  </p>\n<p>If the compiler gave us a this_type in the manner of a this pointer, then operator new could access fields in the allocation it has created simply by casting the void *.  This would be very helpful in many situations.</p>\n<p>But the bottom line question that remains to me is why the compiler does not give an error for the illegal assignment, and then  goes and generates code that yields wrong values for the child, as shown in the original code.  (and Jon, yes, I called new on the child and it assigned count as a parent, no warning, etc. that is fair to say, an unexpected outcome in the eyes of any usual programmer).</p>\n", "LastEditorUserId": "1368207", "LastActivityDate": "2012-05-05T01:07:55.720", "Score": "0", "CreationDate": "2012-05-05T00:38:27.740", "ParentId": "10401579", "CommentCount": "3", "LastEditDate": "2012-05-05T01:07:55.720", "OwnerUserId": "1368207"}, "10457465": {"Id": "10457465", "PostTypeId": "2", "Body": "<p>Here's another solution:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef unsigned int uint;\n\nclass C{ // just here to be faithful to the original code\n  int y;\n};\n\nclass A{\npublic:\n  uint count;\n};\n\nclass B : public C, public A{\npublic:\n    int i;\n};\n\ntemplate&lt;typename T&gt;\nstruct A_allocation_helper : T\n{\n  void* operator new(size_t enfacia_size, uint count){\n    size_t total_size\n      = enfacia_size\n      + sizeof(int) * count; // the 'tail'\n      ;\n    T *new_pt = (T *)malloc(total_size);\n    new_pt-&gt;count = count;\n    return new_pt;\n  };\n\n};\n\n\nint main(){\n  B *b_pt = new(5) A_allocation_helper&lt;B&gt;;\n  return b_pt-&gt;count;\n};\n</code></pre>\n<p>Now the code that does the memory allocation knows the correct type, instead of it being done by a type that only knows about the base.</p>\n", "LastActivityDate": "2012-05-04T23:42:19.470", "Score": "0", "CreationDate": "2012-05-04T23:42:19.470", "ParentId": "10401579", "CommentCount": "1", "OwnerUserId": "981959"}, "10426799": {"Id": "10426799", "PostTypeId": "2", "Body": "<p>This compiles fine:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;stdlib.h&gt;\ntypedef unsigned int uint;\n\nclass C{ // just here to be faithful to the original code\n  int y;\n};\n\nclass A{\npublic:\n  typedef A this_type;\n\n  void* operator new(size_t enfacia_size, uint count){\n      size_t total_size \n    = enfacia_size\n    + sizeof(int) * count; // the 'tail'\n    ;\n      this_type *new_pt = (this_type *)malloc(total_size);\n      new_pt-&gt;count = count;\n      return new_pt;\n  };\n  uint count;\n};\n\nclass B : public C, public A{\npublic:\n    int i;\n};\n\nint main(){\n  B *b_pt = new(5) B;  \n  uint j=0;\n  j++;\n};\n</code></pre>\n<p>Here is the \"problem\" shown in gdb:</p>\n<pre><code>(gdb) b main\nBreakpoint 1 at 0x80484e1: file try_offsets.ex.cc, line 32.\n(gdb) r\nStarting program try_offsets \nBreakpoint 1, main () at try_offsets.cc:32\n(gdb) n\n(gdb) p &amp;(b_pt-&gt;count)\n$1 = (uint *) 0x804a00c\n(gdb) x/10 b_pt\n0x804a008:  5   0   0   0\n0x804a018:  0   0   0   0\n0x804a028:  0   135129\n(gdb) p b_pt\n$2 = (B *) 0x804a008\n(gdb) \n</code></pre>\n<p>Notice that count is at 0x804a00c, but assigning to count wrote to 0x804a008.  Now with the variation pointed out by Rob where this type is set to the child via a template:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;stdlib.h&gt;\ntypedef unsigned int uint;\n\nclass C{ // just here to be faithful to the original code\n  int y;\n};\n\ntemplate&lt;typename this_type&gt;\nclass A{\npublic:\n\n  void* operator new(size_t enfacia_size, uint count){\n      size_t total_size \n    = enfacia_size\n    + sizeof(int) * count; // the 'tail'\n    ;\n      this_type *new_pt = (this_type *)malloc(total_size);\n      new_pt-&gt;count = count;\n      return new_pt;\n  };\n  uint count;\n};\n\nclass B : public C, public A&lt;B&gt;{\npublic:\n    int i;\n};\n\nint main(){\n  B *b_pt = new(5) B;  \n  uint j=0;\n  j++;\n};\n</code></pre>\n<p>We get the correct behavior:</p>\n<pre><code>(gdb) b main\nBreakpoint 1 at 0x80484e1: file try_offsets.ex.cc, line 32.\n(gdb) r\nStarting program\nBreakpoint 1, main () at try_offsets.cc:32\n(gdb) n\n(gdb) p &amp;(b_pt-&gt;count)\n$1 = (uint *) 0x804a00c\n(gdb) x/10 b_pt\n0x804a008:  0   5   0   0\n0x804a018:  0   0   0   0\n0x804a028:  0   135129\n(gdb) \n</code></pre>\n<p>It is interesting though, with this solution it will not compile when this_type is set to 'A':</p>\n<pre><code>class B : public C, public A&lt;A&gt;{\npublic:\n    int i;\n};\n</code></pre>\n<p>gives:</p>\n<pre><code>try_offsets.cc:26:31: error: type/value mismatch at argument 1 in template parameter list for \u2018template&lt;class this_type&gt; class A\u2019\ntry_offsets.cc:26:31: error:   expected a type, got \u2018A\u2019\n</code></pre>\n<p>The solution I settled on:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;stdlib.h&gt;\ntypedef unsigned int uint;\n\nclass C{ // just here to be faithful to the original code\n  int y;\n};\n\n\nclass A{\npublic:\n  typedef A this_type;\n\n  A(uint count):count(count){;}\n\n  void* operator new(size_t enfacia_size, uint count){\n      size_t total_size \n    = enfacia_size\n    + sizeof(int) * count; // the 'tail'\n    ;\n      this_type *new_pt = (this_type *)malloc(total_size);\n      return new_pt;\n  };\n  uint count;\n};\n\nclass B : public C, public A{\npublic:\n    B(uint count):A(count){;}\n    int i;\n};\n\nint main(){\n  B *b_pt = new(5) B(5);  \n  uint j=0;\n  j++;\n};\n</code></pre>\n<p>Though this breaks an old convention.  It is normal for an allocator to write the length of an allocation just above the allocation point.  That is, for example, how delete/free knows how long a block on the heap is.  Also, as operator delete can not take arguments, this is how we get information to it.</p>\n", "LastActivityDate": "2012-05-03T07:15:57.177", "Score": "0", "CreationDate": "2012-05-03T07:15:57.177", "ParentId": "10401579", "CommentCount": "3", "OwnerUserId": "1368207"}, "10449212": {"Id": "10449212", "PostTypeId": "2", "Body": "<p>You're making some strange claims about \"fields moving due to inheritance\" but no such thing happens.</p>\n<p>Try  this program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n\nstruct C\n{\n    int i;\n};\n\nstruct A\n{\n    int count;\n\n    void f()\n    {\n        uintptr_t pt = reinterpret_cast&lt;uintptr_t&gt;(this);\n        uintptr_t pc = reinterpret_cast&lt;uintptr_t&gt;(&amp;count);\n        std::cout &lt;&lt; \"Offset of A::count within A is \" &lt;&lt; (pc - pt) &lt;&lt; '\\n';\n    }\n};\n\nstruct B : C, A\n{\n    void g()\n    {\n        uintptr_t pt = reinterpret_cast&lt;uintptr_t&gt;(this);\n        uintptr_t pc = reinterpret_cast&lt;uintptr_t&gt;(&amp;count);\n        std::cout &lt;&lt; \"Offset of A::count within B is \" &lt;&lt; (pc - pt) &lt;&lt; '\\n';\n    }\n};\n\nint main()\n{\n    A a;\n    a.f();\n    B b;\n    b.f();\n    b.g();\n}\n</code></pre>\n<p>This produces:</p>\n<pre><code>Offset of A::count within A is 0\nOffset of A::count within A is 0\nOffset of A::count within B is 4\n</code></pre>\n<p>It doesn't matter if you call A::f on an object of type B or an object of type A,  it's still A::f and it still accesses A:count at a fixed offset.  When you call B::g <em>then</em> the function knows the A::count member is at a different offset from <code>this</code></p>\n<p>The same thing happens in your <code>operator new</code>, that function is a member of A and knows nothing about B. When you access <code>this_type::count</code> you are accessing <code>A::count</code>. It is irrelevant that you call it for a B, only <code>A::operator new</code> exists (the function isn't copied to produce <code>B::operator new</code> as you seem to think).</p>\n<p>The template version works because then the type <code>this_type</code> refers to B not A, so the function accesses <code>B::count</code></p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2012-05-06T02:27:53.247", "Score": "0", "CreationDate": "2012-05-04T12:54:35.893", "ParentId": "10401579", "CommentCount": "1", "LastEditDate": "2012-05-06T02:27:53.247", "OwnerUserId": "981959"}, "10402040": {"Id": "10402040", "PostTypeId": "2", "Body": "<p>This cannot possibly work. <code>operator new</code> does not get to know the type of object being allocated. Only the size. There might be no object at all since you can call the operator directly.</p>\n<p>Defining <code>this_type</code> in each derived class differently (I guess you have missed this part in the presentation) will not affect the meaning of it in the base class methods.</p>\n", "LastActivityDate": "2012-05-01T18:02:57.913", "Score": "0", "CreationDate": "2012-05-01T18:02:57.913", "ParentId": "10401579", "CommentCount": "2", "OwnerUserId": "775806"}, "10403000": {"Id": "10403000", "PostTypeId": "2", "Body": "<p>The solution you propose invokes Undefined Behavior by accessing members of a non-POD class outside of the lifetime of that class.</p>\n<p>Reading from \u00a73.8 of C++2003,</p>\n<blockquote>\n<p id=\"so_10401579_10403000_0\">The lifetime of an object of type T begins\n  when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if T is a class type with a non-trivial constructor (12.1), the constructor call has completed.</li>\n</ul>\n</blockquote>\n<p>Since your <code>B</code> object has a non-trivial constructor, the lifetime begins after <code>B</code>'s constructor  has completed. <code>A</code>'s constructor runs before <code>B</code>'s constructor completes, thus before the lifetime of <code>B</code>.</p>\n<blockquote>\n<p id=\"so_10401579_10403000_1\">Before the lifetime of an object has started but after the storage which the object will occupy has been allocated \u2026 any pointer that refers to the storage location where the object will be \u2026 located\n  may be used but only in limited ways. \u2026\n  If the object [<em>satisfies certain conditions, which yours does</em>], the program has\n  undefined behavior if:</p>\n<ul>\n<li>the pointer is used to access a non-static data member or call a non-static member function of the object,\n  or</li>\n<li>the pointer is implicitly converted (4.10) to a pointer to a base class type, or</li>\n<li>the pointer is used as the operand of a static_cast (5.2.9) (except when the conversion is to\n  void*, or to void* and subsequently to char*, or unsigned char*).</li>\n<li>the pointer is used as the operand of a dynamic_cast (5.2.7).</li>\n</ul>\n</blockquote>\n<p>So, any solution that you propose that violates one of those four conditions invokes Undefined Behavior. Specificially, the code in your question uses the pointer as an operand of a <code>static_cast</code>, and uses it to access a non-static data member.</p>\n<p><hr/>\nHaving said all that, here is a program which, while not defined by the C++ standard, might still be valid for your particular compiler. That is, this isn't a C++ program, but it might be MSVC++ program or a G++ program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nclass C{ // just here to be faithful to the original code\n  int y;\n};\n\ntemplate &lt;class this_type&gt;\nclass A {\npublic:\n  void* operator new(size_t enfacia_size, unsigned int count){\n      size_t total_size\n      = enfacia_size\n      + 42 * count; // the 'tail'\n      ;\n      this_type *new_pt = (this_type *)malloc(total_size);\n      new_pt-&gt;count = count;\n      return new_pt;\n  }\n  unsigned int count;\n};\n\nclass B : public C, public A&lt;B&gt;{\npublic:\n    int i;\n};\n\nint main () {\n  B *b = new(10) B;\n  std::cout &lt;&lt; b-&gt;count &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "8747", "LastActivityDate": "2012-05-01T19:26:21.993", "Score": "3", "CreationDate": "2012-05-01T19:20:06.723", "ParentId": "10401579", "CommentCount": "5", "LastEditDate": "2012-05-01T19:26:21.993", "OwnerUserId": "8747"}});