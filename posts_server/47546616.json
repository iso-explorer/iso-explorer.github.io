post_cb({"bq_ids": {"n4140": {"so_47546616_47546665_1": {"length": 18, "quality": 0.9, "section_id": 5846}, "so_47546616_47546665_0": {"length": 26, "quality": 0.896551724137931, "section_id": 7113}}, "n3337": {"so_47546616_47546665_1": {"length": 18, "quality": 0.9, "section_id": 5616}, "so_47546616_47546665_0": {"length": 26, "quality": 0.896551724137931, "section_id": 6857}}, "n4659": {"so_47546616_47546665_1": {"length": 18, "quality": 0.9, "section_id": 7325}, "so_47546616_47546665_0": {"length": 26, "quality": 0.896551724137931, "section_id": 8614}}}, "47546616": {"ViewCount": "5412", "Body": "<p>What does C++ syntax <code>struct A::B:A {};</code> mean? Where is this name definition (or access) described in the C++ standard?</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B;\n\nstruct A {\n    struct B;\n};\n\nstruct A::B:A {\n};\n\nint main() {\n    A::B::A::B b;\n    std::cout&lt;&lt;\"Sizeof A::B::A::B is \" &lt;&lt; sizeof(A::B::A::B)&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n", "Title": "What does C++ syntax \u201cA::B:A {};\u201d mean", "CreationDate": "2017-11-29T06:45:15.087", "LastActivityDate": "2017-11-30T07:53:48.353", "CommentCount": "4", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2017-11-29T07:04:50.657", "LastEditorUserId": "3936440", "Id": "47546616", "Score": "45", "OwnerUserId": "7807948", "Tags": "<c++><struct><syntax><scope-resolution>", "AnswerCount": "2"}, "47546665": {"Id": "47546665", "PostTypeId": "2", "Body": "<p>This definition </p>\n<pre><code>struct A {\n    struct B;\n};\n</code></pre>\n<p>Defines a struct <code>A</code> with a declaration of a nested struct <code>B</code><sup>1</sup>. The fully qualified name of <code>B</code> is <code>A::B</code>, you could say <code>B</code> is inside the \"namespace\" of <code>A</code>. Then this:</p>\n<pre><code>struct A::B : A { // Note I added spaces\n};\n</code></pre>\n<p>Is the definition of <code>A::B</code>, and the single <code>:</code> specifies that it is <em>derived</em> from <code>A</code>.</p>\n<p>Now, the interesting part is <code>A::B::A::B</code>. Let's dissect it:</p>\n<ol>\n<li><code>A::B</code> names the nested structure.</li>\n<li><code>A::B::A</code> accesses the injected class name <code>A</code> inside <code>B</code>. The injection is due to the inheritance.</li>\n<li><code>A::B::A::B</code> names the nested structure <code>B</code> in <code>A</code> again.</li>\n</ol>\n<p>And you can continue ad-infinitum, or at least until your compiler meets its translation limit<sup>2</sup>.</p>\n<p>A fun intellectual exercise, but avoid like the plague in actual code. </p>\n<hr>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.qual#1\" rel=\"noreferrer\">[class.qual]/1</a> explains how the lookup works</p>\n<blockquote>\n<p id=\"so_47546616_47546665_0\">If the <em>nested-name-specifier</em> of a <em>qualified-id</em> nominates a class, the\n  name specified after the <em>nested-name-specifier</em> is looked up in the\n  scope of the class ([class.member.lookup]), except for the cases\n  listed below. The name shall represent one or more members of that\n  class or of one of its base classes (Clause [class.derived]).</p>\n</blockquote>\n<p>And the text above allows us to name the base class because <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class#2\" rel=\"noreferrer\">[class]/2</a></p>\n<blockquote>\n<p id=\"so_47546616_47546665_1\">The <em>class-name</em> is also inserted into the scope of the class itself;\n  this is known as the <em>injected-class-name</em>. For purposes of access\n  checking, the <em>injected-class-name</em> is treated as if it were a public\n  member name.</p>\n</blockquote>\n<p>The above clearly says that starting a fully qualified name with <code>A::</code> allows you to specify a member or a base class. Since <code>A</code> has no bases, you can only specify <code>A::B</code> (a \"member type\"). But <code>A::B</code> also nominates a class. So we may specify a base or member of <em>that</em> as well with <code>A::B::</code>, which allows us to name <code>A::B::A</code>. Now rinse and repeat.</p>\n<hr>\n<p><sub>\n<sup>1</sup> - Note it's a completely other <code>B</code>. Not at all related to the global <code>struct B</code>.<br>\n<sup>2</sup> - A recommended minimum of 256 according to <a href=\"https://timsong-cpp.github.io/cppwp/n4659/implimits#2.36\" rel=\"noreferrer\">[implimits]/2.36</a></br></sub></p>\n<p></p></hr></hr>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-11-30T07:53:48.353", "Score": "97", "CreationDate": "2017-11-29T06:48:27.293", "ParentId": "47546616", "CommentCount": "6", "OwnerUserId": "817643", "LastEditDate": "2017-11-30T07:53:48.353"}, "47546839": {"Id": "47546839", "PostTypeId": "2", "Body": "<p>First of all <code>struct B;</code> is a forward declaration of struct <code>B</code> in global namespace. It might be confusing because it is actually not relevant in this example. This global <code>B</code> can be accessed as <code>::B</code> or as just <code>B</code>.</p>\n<pre><code>struct A {\n    struct B;\n};\n</code></pre>\n<p>Is a definition of struct <code>A</code> in global namespace with a forward declaration of <em>nested</em> struct <code>B</code> (not the same as previously declared <code>B</code> in global namespace). This nested <code>B</code> can be accessed as <code>::A::B</code> or <code>A::B</code>.</p>\n<pre><code>struct A::B:A {\n};\n</code></pre>\n<p>Is a definition of nested struct <code>B</code> of struct <code>A</code> that inherits from <code>A</code> (with access specifier omitted). It can be rewritten to:</p>\n<pre><code>struct A::B\n:   public A\n{\n};\n</code></pre>\n<p>Note that writing definition of nested struct <code>B</code> inside of <code>A</code> definition like this won't work:</p>\n<pre><code>struct A {\n    struct B: A { // error: A is incomplete at this point\n    };\n};\n</code></pre>\n<p>And finally <code>A::B::A</code> is referring to the base class of nested struct <code>B</code>, that is to <code>A</code>, so <code>A::B::A::B</code> is equivalent to just <code>A::B</code>.</p>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2017-11-29T07:05:15.730", "Score": "17", "CreationDate": "2017-11-29T07:00:08.983", "ParentId": "47546616", "CommentCount": "13", "OwnerUserId": "7860670", "LastEditDate": "2017-11-29T07:05:15.730"}});