post_cb({"bq_ids": {"n4140": {"so_12991507_13038457_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 6146}}, "n3337": {"so_12991507_13038457_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 5909}}, "n4659": {"so_12991507_13038457_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 7642}}}, "13038457": {"Id": "13038457", "PostTypeId": "2", "Body": "<p>The problem appears to be due to unintended excessive right-shifting.  You mention that your ideone post doesn't reproduce the problem.  While testing, I noticed that in your ideone post, the type of digit was actually still set to 16-bit.  The moment I changed this to 32 bit (to reflect the SO code snippet) and tried to compile under gcc, I got a bunch of warnings about excessive right shift.  Running the program resulted in an infinite loop, which, combined with the right-shift warnings and the fact that you get different behavior on your platform strongly suggests undefined behavior is occurring.</p>\n<p>More specifically, there are places where you're getting bit-size mismatches between int types (ie, you still have a few chunks of code to update).</p>\n<p>The trouble maker appears to be setFromZ.  Here you have the integer type specified by Z, and the integer type specified by base::value_type.  The two are not guaranteed to have the same number of bits, so the bit-shift and bit-mask code in that function are not working correctly when a bit mismatch occurs.  And a mismatch is occurring for several instantiations of that template that occur in your ideone code, when uint32_t is the digit type (at least in my environment).</p>\n<p>Edit: Confirmation that excessive right-shift is undefined according to standard:  Reference: <a href=\"https://stackoverflow.com/questions/3394259/weird-behavior-of-right-shift-operator\">SO Post</a>, see accepted answer, which quotes the standard.</p>\n<blockquote>\n<p id=\"so_12991507_13038457_0\">(C++98 \u00a75.8/1) states that:\n  The behavior is\n  undefined if the right operand is negative, or <em>greater than or equal</em>\n  to the length in bits of the promoted left operand.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-23T20:51:11.833", "Score": "2", "CreationDate": "2012-10-23T20:12:02.993", "ParentId": "12991507", "CommentCount": "4", "OwnerUserId": "1718130", "LastEditDate": "2017-05-23T12:03:27.983"}, "12991507": {"ViewCount": "259", "Body": "<p>Im trying to convert my <a href=\"http://calccrypto.wikidot.com/programming%3ainteger\" rel=\"nofollow\">arbitrary precision integer</a> class to be able to use digits that are not just 8 bits per digit. Ive stumbled upon a weird problem: I am able to use <code>uint16_t</code>\nfor my base digit type, but not <code>uint32_t</code>. My code will return bad results. The example I used to find what was going wrong is <code>0x1111111111111111 * 0x1111111111111111</code>, which should be<code>0x123456789abcdf00fedcba987654321</code>. However, I am getting <code>0x123456789abcdf0fedcba987654321</code>.</p>\n<p>I thought that I had changed all of the hardcoded types so that changing the base digit type would not matter, but apparently not.</p>\n<p>Here is the relevant code:</p>\n<pre><code>typedef uint32_t                          digit;            // original code uses uint8_t; uint16_t works too\ntypedef uint64_t                          double_digit;     // int type to hold overflow values\n\ntypedef std::deque &lt;digit&gt;                base;\n\nconst digit NEG1 = -1;                    // uint8_t -&gt; 255, uint32_t -&gt; 4294967295\nconst digit BITS = sizeof(digit) &lt;&lt; 3;    // sizeof gives the number of bytes, so multiply that by 8 to get the number of bits\nconst digit HIGH_BIT = 1 &lt;&lt; (BITS - 1);   // uint8_t -&gt; 128\n\n        // left bit shift. sign is maintained\n        integer operator&lt;&lt;(uint64_t shift){\n            if (!*this || !shift)\n                return *this;\n            base out = digits;\n            for(uint64_t i = 0; i &lt; (shift / BITS); i++)\n                out.push_back(0);\n            shift %= BITS;\n            if (shift){\n                out.push_back(0);\n                return integer(out, _sign) &gt;&gt; (BITS - shift);\n            }\n            return integer(out, _sign);\n        }\n\n        // right bit shift. sign is maintained\n        integer operator&gt;&gt;(uint64_t shift){\n            if (shift &gt;= bits())\n                return integer(0);\n            base out = digits;\n            for(uint64_t i = 0; i &lt; (shift / BITS); i++)\n                out.pop_back();\n            shift %= BITS;\n            if (shift){\n                base v;\n                for(d_size i = out.size() - 1; i != 0; i--)\n                    v.push_front(((out[i] &gt;&gt; shift) | (out[i - 1] &lt;&lt; (BITS - shift))) &amp; NEG1);\n                v.push_front(out[0] &gt;&gt; shift);\n                out = v;\n            }\n            return integer(out, _sign);\n        }\n\n        // operator+ calls this\n        integer add(integer &amp; lhs, integer &amp; rhs){\n            base out;\n            base::reverse_iterator i = lhs.digits.rbegin(), j = rhs.digits.rbegin();\n            bool carry = false;\n            double_digit sum;\n            for(; ((i != lhs.digits.rend()) &amp;&amp; (j != rhs.digits.rend())); i++, j++){\n                sum = *i + *j + carry;\n                out.push_front(sum);\n                carry = (sum &gt; NEG1);\n            }\n            for(; i != lhs.digits.rend(); i++){\n                sum = *i + carry;\n                out.push_front(sum);\n                carry = (sum &gt; NEG1);\n            }\n            for(; j != rhs.digits.rend(); j++){\n                sum = *j + carry;\n                out.push_front(sum);\n                carry = (sum &gt; NEG1);\n            }\n            if (carry)\n                out.push_front(1);\n            return integer(out);\n        }\n\n        // operator* calls this\n        // Long multiplication\n        integer long_mult(integer &amp; lhs, integer &amp; rhs){\n            unsigned int zeros = 0;\n            integer row, out = 0;\n            for(base::reverse_iterator i = lhs.digits.rbegin(); i != lhs.digits.rend(); i++){\n                row.digits = base(zeros++, 0); // zeros on the right hand side\n                digit carry = 0;\n                for(base::reverse_iterator j = rhs.digits.rbegin(); j != rhs.digits.rend(); j++){\n                    double_digit prod = (double_digit(*i) * double_digit(*j)) + carry;// multiply through\n                    row.digits.push_front(prod &amp; NEG1);\n                    carry = prod &gt;&gt; BITS;\n                }\n                if (carry)\n                    row.digits.push_front(carry);\n                out = add(out, row);\n            }\n            return out;\n        }\n</code></pre>\n<p>Is there something obvious that I missed that might cause incorrect calculations? I have stared at this code for a little too long in one burst.</p>\n<p>The full modified code is <a href=\"http://calccrypto.wikidot.com/local--files/home/integer.h\" rel=\"nofollow\">here</a>.</p>\n<p><strong>EDIT</strong>: I have tested the code on <a href=\"http://ideone.com/nbY6VB\" rel=\"nofollow\">ideone</a>, and it is returning the correct value for this calculation, but my computer still does not. Is there any good explanation for this? </p>\n", "AcceptedAnswerId": "13038457", "Title": "Arithmetic in nonstandard base", "CreationDate": "2012-10-20T18:39:39.080", "Id": "12991507", "CommentCount": "3", "LastEditDate": "2012-10-23T09:47:56.197", "PostTypeId": "1", "LastEditorUserId": "341683", "LastActivityDate": "2012-10-23T20:51:11.833", "Score": "0", "OwnerUserId": "341683", "Tags": "<c++><c++11><integer-arithmetic>", "AnswerCount": "1"}});