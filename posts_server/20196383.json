post_cb({"20196889": {"Id": "20196889", "PostTypeId": "2", "Body": "<p>Thanks to people reaction I understood the problem better.\nIt becomes more clear when we rid from <code>std::vector</code>:</p>\n<pre><code>class Data;\nclass A {\n  const Data&amp; getData( int i ) const { return a[i]; }\n  Data* a;\n};\n</code></pre>\n<p>to return <code>i</code>-th element of array <code>a</code> one needs to know where is it in the memory. For this one needs to know <code>sizeof(Data)</code>, which is not possible for incomplete type.</p>\n<p>The exactly same problem std::vector should have.</p>\n", "LastActivityDate": "2013-11-25T15:31:36.797", "CommentCount": "1", "CreationDate": "2013-11-25T15:31:36.797", "ParentId": "20196383", "Score": "3", "OwnerUserId": "747050"}, "20196749": {"Id": "20196749", "PostTypeId": "2", "Body": "<p>So, the C++ Standard is not particularly clear on this point. The problem that you are hitting is whether or not you can instantiate <code>vector&lt;Data&gt;</code> when you <code>Data</code> is not a complete type.</p>\n<p>If we look at Section 17.6.4.8 Paragraph 2, we find the following statement:</p>\n<blockquote>\n<p id=\"so_20196383_20196749_0\">In particular, the effects are undefined in the following cases:</p>\n<ul>\n<li>...</li>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for that component.</li>\n</ul>\n</blockquote>\n<p><code>std::vector</code> does not explicitly allow incomplete types for the template argument, so this is technically invalid code.</p>\n<hr>\n<p>This would mean that this is invalid code, even if your compiler accepts it.</p>\n<pre><code>class Data;\nclass A {\n    std::vector&lt;Data&gt; a;\n};\n</code></pre>\n</hr>", "LastEditorUserId": "47453", "LastActivityDate": "2013-11-25T15:31:54.553", "Score": "4", "CreationDate": "2013-11-25T15:24:28.080", "ParentId": "20196383", "CommentCount": "9", "OwnerUserId": "47453", "LastEditDate": "2013-11-25T15:31:54.553"}, "20196383": {"ViewCount": "215", "Body": "<p>If I have a header like this:</p>\n<pre><code>#include &lt;vector&gt;\n\nclass Data;\nclass A {\n  // const Data&amp; getData( int i ) const { return a[i]; }\n  std::vector&lt;Data&gt; a;\n};\n</code></pre>\n<p>the compiler compiles it normally, because it doesn't need to know a bit about Data type.</p>\n<p>Retuning a value by reference does not depend on a class implementation and therefore do not require any knowledge of the class internals.\nBut when I uncomment the accessor compiler starts to complain on <code>invalid use of incomplete type  'class Data'</code>. Why? </p>\n", "AcceptedAnswerId": "20196889", "Title": "Why does compiler need complete type when reference is used?", "CreationDate": "2013-11-25T15:07:49.367", "Id": "20196383", "CommentCount": "5", "LastEditDate": "2013-11-25T15:18:49.523", "PostTypeId": "1", "LastEditorUserId": "747050", "LastActivityDate": "2013-11-25T18:06:21.110", "Score": "2", "OwnerUserId": "747050", "Tags": "<c++><class>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_20196383_20196749_0": {"length": 5, "quality": 1.0, "section_id": 6324}}, "n3337": {"so_20196383_20196749_0": {"length": 5, "quality": 1.0, "section_id": 6081}}, "n4659": {"so_20196383_20196749_0": {"length": 5, "quality": 1.0, "section_id": 7834}}}, "20197058": {"Id": "20197058", "PostTypeId": "2", "Body": "<p>Because knowing that there exists a class <code>Data</code> is not enough to know what <code>std::vector&lt;Data&gt;::operator[](size_t i)</code> should do, or even whether it exists. This is fundamental to the nature of class templates.</p>\n", "LastActivityDate": "2013-11-25T15:40:07.650", "CommentCount": "6", "CreationDate": "2013-11-25T15:40:07.650", "ParentId": "20196383", "Score": "1", "OwnerUserId": "560648"}, "20197095": {"Id": "20197095", "PostTypeId": "2", "Body": "<p>It does not require a complete type in the declaration. It requires a complete type before the vector constructor and destructor (or any other members really) are called. This is when the size of the struct or class needs to be defined.</p>\n<p>In your code, the A's constructor and Destructor are declared as default, and thus are defined in the header file. The vector cannot allocate or deallocate stuff of a size it does not know, so it barfs. You can solve this by explicitly declaring your destructor and constructor in \"A.h\", and making sure Data is defined before any of your member functions are defined.</p>\n<p>The following code works and is valid.</p>\n<pre><code>//\"A.h\"\nclass Data; // forward declaration only\nclass A\n{\npublic:\n  A();\n  ~A();\n  const Data&amp; getData( int i ) const;\n  std::vector&lt;Data&gt; a;\n};\n\n//\"A.cpp\"\n#include \"A.h\"\nclass Data {int i;}; // actual class here before the definition of A::A(),...\n\nA::A(){}\nA::~A(){}\nData&amp; A::getData(int i) const {return a[i];}\n</code></pre>\n", "LastEditorUserId": "985296", "LastActivityDate": "2013-11-25T18:06:21.110", "Score": "1", "CreationDate": "2013-11-25T15:41:54.730", "ParentId": "20196383", "CommentCount": "0", "OwnerUserId": "1756405", "LastEditDate": "2013-11-25T18:06:21.110"}});