post_cb({"bq_ids": {"n4140": {"so_13045693_13046160_1": {"length": 15, "quality": 1.0, "section_id": 6536}, "so_13045693_13046160_2": {"length": 19, "quality": 1.0, "section_id": 6536}, "so_13045693_13046160_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 6536}}, "n3337": {"so_13045693_13046160_1": {"length": 15, "quality": 1.0, "section_id": 6291}, "so_13045693_13046160_2": {"length": 19, "quality": 1.0, "section_id": 6291}, "so_13045693_13046160_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 6291}}, "n4659": {"so_13045693_13046160_1": {"length": 15, "quality": 1.0, "section_id": 8018}, "so_13045693_13046160_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 8018}, "so_13045693_13046160_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 8018}}}, "13045693": {"ViewCount": "1162", "Body": "<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;algorithm&gt;\nusing std::cerr;\nusing std::cout;\nusing std::stringstream;\nusing std::string;\nusing std::for_each;\n\nvoid convert(const string&amp; a_value)\n{\n    unsigned short i;\n    if (stringstream(a_value) &gt;&gt; i)\n        cout &lt;&lt; a_value &lt;&lt; \" converted to \" &lt;&lt; i &lt;&lt; \".\\n\";\n    else\n        cerr &lt;&lt; a_value &lt;&lt; \" failed to convert.\\n\";\n}\n\nint main()\n{\n    string inputs[] = { \"abc\", \"10\", \"999999999999999999999\", \"-10\", \"0\" };\n    for_each(inputs, inputs + (sizeof(inputs)/sizeof(inputs[0])), convert);\n    return 0;\n}\n</code></pre>\n<p>Output from Visual Studio Compiler (v7, v8, v9, v10):</p>\n<pre>\nabc failed to convert.\n10 converted to 10.\n999999999999999999999 failed to convert.\n-10 converted to 65526.\n0 converted to 0.\n</pre>\n<p>Output from g++ (v4.1.2, <a href=\"http://ideone.com/T2sMF3\" rel=\"noreferrer\">v4.3.4</a>):</p>\n<pre>\nabc failed to convert.\n10 converted to 10.\n999999999999999999999 failed to convert.\n-10 failed to convert.\n0 converted to 0.\n</pre>\n<p>I expected the <code>\"-10\"</code> to fail to be converted to an <code>unsigned short</code> but it succeeds with the VC compilers. Is this a:</p>\n<ul>\n<li>bug in the VC compilers ?</li>\n<li>bug in the GNU compilers and I have an incorrect expectation ?</li>\n<li>an implementation defined behaviour ?</li>\n</ul>\n", "AcceptedAnswerId": "13046170", "Title": "Negative numeric string (e.g. \"-10\") to unsigned short", "CreationDate": "2012-10-24T08:44:45.263", "Id": "13045693", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2012-10-24T09:30:17.127", "Score": "10", "OwnerUserId": "1033896", "Tags": "<c++>", "AnswerCount": "2"}, "13046170": {"Id": "13046170", "PostTypeId": "2", "Body": "<p>The answer depends on what version of C++ you are using.  C++03 and\nearlier required the input to conform to what <code>sscanf</code> does (using here\nthe <code>\"%hi\"</code> input specifier), and <code>sscanf</code> reads an integral value into\na (signed) short, with no overflow detection; the results are then\nassigned (with implicit conversion) to your <code>unsigned short</code>.  C++11\nrequires the equivalent of calling <code>strtoull</code>, which doesn't allow the\n<code>-</code> sign, and requires an error in case of overflow (which is undefined\nbehavior in <code>sscanf</code>, and thus C++03).</p>\n<p>In practice, all reasonable implementations of C++03 did check for\noverlow, and the \"undefined behavior\" in such cases corresponded to that\nwhich is now required.  On the other hand, they were <em>required</em> to\naccept the minus sign, which is now (logically) forbidden. </p>\n<p>EDIT (correction):\nOn rereading the requirements of <code>strtoull</code>, I find that it does require accepting the minus sign.  So as stupid as it seems, the standard does require input to an unsigned integral type to accept the minus sign.  (Note too that the behavior of <code>strtoull</code> depends on the global C locale, which may accept additional posibilities.)</p>\n<p>EDIT (further clarification):\nAs ectamur points out, this should be an error (in C++11), because <code>(unsigned long long)( -10 )</code> will be too large to be represented in an <code>unsigned short</code>.  On the other hand, it is still undefined behavior in pre-C++03 (which is perhaps what VC++ is conforming to---so whatever they do is \"correct\").</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2012-10-24T09:30:17.127", "Score": "5", "CreationDate": "2012-10-24T09:13:27.493", "ParentId": "13045693", "CommentCount": "0", "OwnerUserId": "649665", "LastEditDate": "2012-10-24T09:30:17.127"}, "13046160": {"Id": "13046160", "PostTypeId": "2", "Body": "<p>g++ is correct.  The arithmetic extractors for unsigned integer types are defined in 27.7.2.2.2p1 as depending on <code>num_get&lt;&gt;</code>; 22.4.2.1.2p3 states that:</p>\n<blockquote>\n<p id=\"so_13045693_13046160_0\">Stage 3: The sequence of <code>char</code>s accumulated in stage 2 (the field) is converted to a numeric value by the rules of [...] \u2014 For an unsigned integer value, the function <code>strtoull</code>.</p>\n</blockquote>\n<p>and that the number stored should be</p>\n<blockquote>\n<p id=\"so_13045693_13046160_1\">\u2014 the most positive representable value, if the field represents a value too large positive to be represented in <code>val</code>. <code>ios_base::failbit</code> is assigned to <code>err</code>.</p>\n</blockquote>\n<p>On the operation of <code>strtoull</code>, C++ defers to C, which is a little unclear on the result of trying to convert a negative-sign field with <code>strtoull</code>; it states that \"<em>the value resulting from the conversion is negated (in the return type)</em>\", which for <code>unsigned long long</code> would result in sign wrap (to <code>ULONGLONG_MAX - 10 + 1</code>).</p>\n<p>So <code>strtoull</code> returns a value too large to be representable in <code>unsigned short</code>, and <code>num_get</code> is required to store <code>USHORT_MAX</code> and set the fail bit.</p>\n<p>On the other hand, 22.4.2.1.2p3 also states that the number stored should be (my emphasis):</p>\n<blockquote>\n<p id=\"so_13045693_13046160_2\">\u2014 the most negative representable value <strong>or zero for an unsigned integer type</strong>, if the field represents a value too large negative to be represented in <code>val</code>. <code>ios_base::failbit</code> is assigned to <code>err</code>.</p>\n</blockquote>\n<p>The presence of this clause indicates that the rules of <code>strtoull</code> are not to be followed strictly for a field with negative sign; under this interpretation <code>num_get</code> is required to store <code>0</code> and set the fail bit.</p>\n<p>In either case the conversion is required to fail.</p>\n", "LastActivityDate": "2012-10-24T09:12:54.537", "CommentCount": "2", "CreationDate": "2012-10-24T09:12:54.537", "ParentId": "13045693", "Score": "3", "OwnerUserId": "567292"}});