post_cb({"33572962": {"ParentId": "33572861", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You haven't written a copy constructor. From <code>[class.copy]</code> in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_33572861_33572962_0\">A non-template constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;, and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>\n</blockquote>\n<p>(I see no provision for a <em>template</em> constructor to be called a copy constructor)</p>\n<p>and consequently</p>\n<blockquote>\n<p id=\"so_33572861_33572962_1\">If the class definition does not explicitly declare a copy constructor, one is declared implicitly</p>\n</blockquote>\n<p>The difference between the two examples is whether or not you have a move constructor:</p>\n<blockquote>\n<p id=\"so_33572861_33572962_2\">If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4)</p>\n</blockquote>\n", "OwnerUserId": "1084944", "LastEditorUserId": "1084944", "LastEditDate": "2015-11-06T18:07:48.173", "Id": "33572962", "Score": "4", "CreationDate": "2015-11-06T18:06:53.893", "LastActivityDate": "2015-11-06T18:07:48.173"}, "33572861": {"CommentCount": "4", "ViewCount": "52", "PostTypeId": "1", "OwnerDisplayName": "user4085386", "LastEditorDisplayName": "user4085386", "CreationDate": "2015-11-06T18:00:00.723", "LastActivityDate": "2015-11-06T18:58:46.477", "LastEditDate": "2015-11-06T18:58:46.477", "AcceptedAnswerId": "33572962", "FavoriteCount": "0", "Title": "Why does C++11 fail to treat two template typenames T == U in constructor in a template class?", "Id": "33572861", "Score": "0", "Body": "<blockquote>\n<p id=\"so_33572861_33572861_0\">I could not find a short and better title. :(</p>\n</blockquote>\n<p>Suppose I have a <strong>simple C++11 template class</strong> definition as below:</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate &lt;typename T&gt;\nclass A\n{\npublic:\n    T v;\n    A(){};\n    template &lt;typename U&gt;\n    A(const A&lt;U&gt;&amp; a); // copy ctor\n    A(A&lt;T&gt;&amp;&amp; a); // move ctor\n};\n\ntemplate &lt;typename T&gt;\ntemplate &lt;typename U&gt;\nA&lt;T&gt;::A(const A&lt;U&gt;&amp; a) // copy ctor\n{\n    v = a.v;\n}\n\ntemplate &lt;typename T&gt; // move ctor\nA&lt;T&gt;::A(A&lt;T&gt;&amp;&amp; a)\n{\n    v = std::move(a.v); // although moving PODs does not make sense in my example\n}\n</code></pre>\n<p>Now, my <strong>C++11 code</strong> uses the <strong>above C++11 class</strong> as follows:</p>\n<pre><code>int main()\n{\n    A&lt;char&gt; a;\n    A&lt;float&gt; b(a); // okay\n    A&lt;char&gt; c(a); // gcc output is as below:\n                 // error: use of deleted function 'constexpr A&lt;char&gt;::A(const A&lt;char&gt;&amp;)'\n                 // note: 'constexpr A&lt;char&gt;::A(const A&lt;char&gt;&amp;)' is implicitly declared\n                 // as deleted because 'A&lt;char&gt;' declares a move constructor or move\n                 // assignment operator\n    return 0;\n}\n</code></pre>\n<p>It gives the error <code>use of deleted function 'constexpr A&lt;char&gt;::A(const A&lt;char&gt;&amp;)'</code>.</p>\n<p>However, it <strong>compiles and runs properly</strong> when I am <strong>not using any move semantics in the class definition</strong> as below:</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate &lt;typename T&gt;\nclass A\n{\npublic:\n    T v;\n    A(){};\n    template &lt;typename U&gt;\n    A(const A&lt;U&gt;&amp; a);\n  //  A(A&lt;T&gt;&amp;&amp; a); // removed move ctor\n};\n\ntemplate &lt;typename T&gt;\ntemplate &lt;typename U&gt;\nA&lt;T&gt;::A(const A&lt;U&gt;&amp; a)\n{\n    v = a.v;\n}\n</code></pre>\n<p>My questions are:</p>\n<ol>\n<li><p><strong>Why the gcc compiler is treating</strong> the <code>template &lt;typename U&gt;</code> in <strong>copy ctor</strong>  differently in the two situations?</p></li>\n<li><p>Why does it <strong>fail to treat typenames</strong> <code>T == U</code> in <strong>the presence of move ctor</strong>?</p></li>\n<li><p>Why do I <strong>need to explicitly write yet</strong> another template\nfunction <code>template &lt;typename T&gt; A&lt;T&gt;::A(const A&lt;U&gt;&amp; a)</code> when using\n<strong>move ctor</strong>?</p></li>\n</ol>\n", "Tags": "<class><templates><c++11><copy-constructor><move-semantics>", "AnswerCount": "2"}, "33573054": {"ParentId": "33572861", "CommentCount": "2", "Body": "<p>Defining the move constructor disabled the copy constructor. What you want is a <em>converting constructor</em>, which as the name implies, converts its argument to the type of the class. If your copy/move constructors don't do anything special, either omit or <code>default</code> them. To explain the final piece of your confusion, the reason you can omit the template arguments in your fake copy constructor is because of the <em>injected class name</em>. Meaning that wherever you see <code>A</code>, it's silently substituted for <code>A&lt;T&gt;</code>. I've included it for clarity.</p>\n<pre><code>template &lt;typename T&gt;\nclass A\n{\npublic:\n    T v;\n    A() = default;\n\n    template &lt;typename U&gt;\n    A&lt;T&gt;(const A&lt;U&gt;&amp; a);\n\n    A(const A&lt;T&gt;&amp; a) = default;\n    A(A&lt;T&gt;&amp;&amp; a) = default;\n};\n</code></pre>\n", "OwnerUserId": "5534635", "PostTypeId": "2", "Id": "33573054", "Score": "1", "CreationDate": "2015-11-06T18:12:06.450", "LastActivityDate": "2015-11-06T18:12:06.450"}, "bq_ids": {"n4140": {"so_33572861_33572962_2": {"section_id": 456, "quality": 1.0, "length": 17}, "so_33572861_33572962_1": {"section_id": 456, "quality": 1.0, "length": 10}, "so_33572861_33572962_0": {"section_id": 451, "quality": 0.96, "length": 24}}, "n3337": {"so_33572861_33572962_2": {"section_id": 447, "quality": 1.0, "length": 17}, "so_33572861_33572962_1": {"section_id": 447, "quality": 1.0, "length": 10}, "so_33572861_33572962_0": {"section_id": 442, "quality": 0.96, "length": 24}}, "n4659": {"so_33572861_33572962_2": {"section_id": 479, "quality": 1.0, "length": 17}, "so_33572861_33572962_1": {"section_id": 479, "quality": 1.0, "length": 10}, "so_33572861_33572962_0": {"section_id": 474, "quality": 0.96, "length": 24}}}});