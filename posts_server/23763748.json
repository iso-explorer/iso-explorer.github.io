post_cb({"34477904": {"ParentId": "23763748", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Although scope plays a role the real issue is about object lifetime and more exactly for object with <em>non-trivial initialization</em> when does the lifetime begin.</p>\n<p>This is closely related to <a href=\"https://stackoverflow.com/q/33649370/1708801\">Can initializing expression use the variable itself?</a> and <a href=\"https://stackoverflow.com/q/32608458/1708801\">Is passing a C++ object into its own constructor legal?</a>. Although my answers to those questions do not neatly answer this question, so it does not seem like a duplicate.</p>\n<p>The key portion of the draft C++ standard we are concerned with here is section <code>3.8</code> <em>[basic.life]</em> which says:</p>\n<blockquote>\n<p id=\"so_23763748_34477904_0\">The lifetime of an object is a runtime property of the object. <strong>An object is said to have non-trivial initialization\n  if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial\n  default constructor</strong>. [ Note: initialization by a trivial copy/move constructor is non-trivial initialization. \u2014\n  end note ] <strong>The lifetime of an object of type T begins when</strong>:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object <strong>has non-trivial initialization, its initialization is complete.</strong></li>\n</ul>\n</blockquote>\n<p>So in this case we satisfy the first bullet, storage has been obtained.</p>\n<p>The second bullet is where we find trouble:</p>\n<ul>\n<li>do we have non-trivial initialization</li>\n<li>and if so is the initialization complete</li>\n</ul>\n<p><b>Non-trivial initialization case</b></p>\n<p>We can get a base reasoning from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#363\" rel=\"nofollow noreferrer\">defect report 363</a> which asks:</p>\n<blockquote>\n<p id=\"so_23763748_34477904_1\">And if so, what is the semantics of the self-initialization of UDT?\n  For example</p>\n<pre><code> #include &lt;stdio.h&gt;\n\n struct A {\n        A()           { printf(\"A::A() %p\\n\",            this);     }\n        A(const A&amp; a) { printf(\"A::A(const A&amp;) %p %p\\n\", this, &amp;a); }\n        ~A()          { printf(\"A::~A() %p\\n\",           this);     }\n };\n\n int main()\n {\n  A a=a;\n }\n</code></pre>\n<p id=\"so_23763748_34477904_2\">can be compiled and prints:</p>\n<pre><code>A::A(const A&amp;) 0253FDD8 0253FDD8\nA::~A() 0253FDD8\n</code></pre>\n</blockquote>\n<p>and the proposed resolution was:</p>\n<blockquote>\n<p id=\"so_23763748_34477904_3\">3.8 [basic.life] paragraph 6 indicates that the references here are valid. It's permitted to take the address of a class object before it\n  is fully initialized, and it's permitted to pass it as an argument to\n  a reference parameter as long as the reference can bind directly.\n  [...]</p>\n</blockquote>\n<p>So before the lifetime of an object begins we are limited in what we can do with an object. We can see from the defect report binding a reference to <code>x</code> is valid as long as it binds directly.</p>\n<p>What we can do is covered in section <code>3.8</code>(<em>The same section and paragraph the defect report quotes</em>) says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_23763748_34477904_4\">Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any glvalue that refers to the\n  original object may be used but only in limited ways. For an object\n  under construction or destruction, see 12.7. Otherwise, such a glvalue\n  refers to allocated storage (3.7.4.2), and using the properties of the\n  glvalue that do not depend on its value is well-defined. <strong>The program\n  has undefined behavior if</strong>:</p>\n<ul>\n<li><p id=\"so_23763748_34477904_5\">an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</p></li>\n<li><p id=\"so_23763748_34477904_6\"><strong>the glvalue is used to access a non-static data member or call a non-static member function of the\n  object, or</strong></p></li>\n<li><p id=\"so_23763748_34477904_7\">the glvalue is bound to a reference to a virtual base class (8.5.3), or</p></li>\n<li><p id=\"so_23763748_34477904_8\">the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.</p></li>\n</ul>\n</blockquote>\n<p>In your case we are accessing a non-static data member here, see emphasis above:</p>\n<pre><code>r = ...;\n</code></pre>\n<p>So if <code>T</code> has non-trivial initialization then this line invokes undefined behavior and so would reading from <code>r</code> which would also be an access, covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3714.html#1531\" rel=\"nofollow noreferrer\">defect report 1531</a>.</p>\n<p>If <code>x</code> has static storage duration it will be zero-initialized but as far as I can tell this does not count as <em>it's initialization is complete</em> since the constructor would be called during dynamic initialization.</p>\n<p><b>Trivial Initialization case</b></p>\n<p>If <code>T</code> has trivial initializaton then the lifetime begins once storage is obtained and writing to <code>r</code> is well defined behavior. Although note that reading <code>r</code> before it has initialized will invoke undefined behavior <a href=\"https://stackoverflow.com/a/23415662/1708801\">since it would produce an indeterminate value</a>. If <code>x</code> has static storage duration then it is zero-initialized and we don't have this issue.</p>\n<p>Should it compile, in either cases whether you are invoking undefined behavior or not this allowed to compile. The compiler is not obligated to produce a diagnostic for undefined behavior although it may. It is only obligated to produce a diagnostic for ill-formed code which none of the troublesome cases here are.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:48.897", "Id": "34477904", "Score": "1", "CreationDate": "2015-12-27T05:38:58.697", "LastActivityDate": "2015-12-27T05:50:41.310"}, "24067465": {"ParentId": "23763748", "PostTypeId": "2", "CommentCount": "9", "Body": "<p><strong>It undoubtedly should compile, but may conditionally lead to undefined behavior.</strong></p>\n<ul>\n<li>If <code>T</code> is a non-primitive type, undefined behavior if it is assigned.</li>\n<li>If <code>T</code> is a primitive type, well-defined behavior if it is non-local, and undefined behavior if it is not assigned before reading (except for character types, where it is defined to give an unspecified value).</li>\n</ul>\n<hr>\n<p>The relevant part of the Standard is this rule from 3.8, Object lifetime:</p>\n<blockquote>\n<p id=\"so_23763748_24067465_0\"><strong>The lifetime of an object of type <code>T</code> begins when:</strong></p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object has non-trivial initialization, <strong>its initialization is complete.</strong></li>\n</ul>\n</blockquote>\n<p>So the lifetime of <code>x</code> hasn't started yet.  In the same section, we find the rule that governs using <code>x</code>:</p>\n<blockquote>\n<p id=\"so_23763748_24067465_1\">Similarly, <strong>before the lifetime of an object has started</strong> but after the storage which the  object  will  occupy has  been  allocated  or,  after  the  lifetime  of  an  object  has  ended  and  before  the  storage  which  the  object occupied is reused or released, <strong>any glvalue that refers to the original object may be used but only in limited ways</strong>.  For an object under construction or destruction, see 12.7.  Otherwise, <strong>such a glvalue refers to allocated storage (3.7.4.2), and using the properties of the glvalue that do not depend on its value is well-defined.</strong> The program <strong>has undefined behavior if</strong>:</p>\n<ul>\n<li><strong>an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</strong></li>\n<li>the glvalue is used to access a non-static data member or <strong>call a non-static member function of the object</strong>, or</li>\n<li>the glvalue is bound to a reference to a virtual base class (8.5.3), or</li>\n<li>the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.</li>\n</ul>\n</blockquote>\n<p>If your type is non-primitive, then trying to assign it is actually a call to <code>T::operator=</code>, a non-static member function.  Full-stop, that is undefined behavior according to case 2.</p>\n<p>Primitive types are assigned without invoking a member function, so let's now take a closer look at section 4.1, Lvalue-to-rvalue conversion, to see when exactly that lvalue-to-rvalue conversion will be undefined behavior:</p>\n<blockquote>\n<p id=\"so_23763748_24067465_2\">When an lvalue-to-rvalue conversion occurs in an unevaluated operand or a subexpression thereof (Clause 5) the value contained in the referenced object is not accessed.  In all other cases, the result of the conversion is determined according to the following rules:</p>\n<ul>\n<li>If <code>T</code> is (possibly <em>cv-qualified</em>) <code>std::nullptr_t</code>, the result is a null pointer constant (4.10).</li>\n<li>Otherwise, if <code>T</code> has a class type, the conversion copy-initializes a temporary of type <code>T</code> from the glvalue and the result of the conversion is a prvalue for the temporary.</li>\n<li>Otherwise, if the object to which the glvalue refers contains an invalid pointer value (3.7.4.2, 3.7.4.3), the behavior is implementation-defined.</li>\n<li><strong>Otherwise,  if <code>T</code> is a (possibly <em>cv-qualified</em>) unsigned character type (3.9.1), and the object to which the glvalue refers contains an indeterminate value (5.3.4, 8.5, 12.6.2), and that object does not have automatic storage duration or the glvalue was the operand of a unary <code>&amp;</code> operator or it was bound to a reference, the result is an unspecified value.</strong></li>\n<li><strong>Otherwise, if the object to which the glvalue refers contains an indeterminate value, the behavior is undefined.</strong></li>\n<li>Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</li>\n</ul>\n</blockquote>\n<p>(note that these rules reflect a rewrite for the upcoming C++14 standard in order to make them easier to understand, but I don't think there's an actual change in the behavior here)</p>\n<p>Your variable <code>x</code> has<sup>1</sup> an indeterminate value at the time an lvalue-reference is made and passed to <code>f()</code>.  As long as that variable has primitive type and its value is assigned before it is read (a read is lvalue-to-rvalue conversion), the code is fine.</p>\n<p>If the variable isn't assigned before being read, the effect depends on <code>T</code>.  Character types will cause code that executes and uses an arbitrary but legal character value.  All other types cause undefined behavior.</p>\n<hr>\n<p><sup>1</sup> Unless <code>x</code> has static storage duration, for example a global variable.  In that case it is zero-initialized before execution, according to section 3.6.2 Initialization of non-local variables:</p>\n<blockquote>\n<p id=\"so_23763748_24067465_3\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n</blockquote>\n<p>In this case of static storage duration it is not possible to run into lvalue-to-rvalue conversion of an unspecified value.  But zero-initialization is not a valid state for all types, so still be careful of that.</p>\n</hr></hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2014-06-05T19:46:46.353", "Id": "24067465", "Score": "1", "CreationDate": "2014-06-05T18:23:56.803", "LastActivityDate": "2014-06-05T19:46:46.353"}, "23764160": {"ParentId": "23763748", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Syntactically it is, however if you try this</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef int T;\nbool f(T&amp; x)\n{\n    return true;\n}\nint main()\n{\n    T x = (f(x) ? x : T());\n    cout &lt;&lt; x;\n}\n</code></pre>\n<p>it outputs some random junk.\nHowever, if you modify</p>\n<pre><code>bool f(T&amp; x)\n{\n    x = 10;\n    return true;\n}\n</code></pre>\n<p>then it outputs 10.\nIn the first case, the object <code>x</code> is declared, and the compiler assigns some pseudo-arbitrary value (so you do not initialize it), whereas in the second you specifically assign a value (<code>T()</code>, i.e. <code>0</code>) after the declaration, i.e. you initialize it.</p>\n<p>I think your question is similar to this one:\n<a href=\"https://stackoverflow.com/questions/9820027/using-newly-declared-variable-in-initialization-int-x-x1\">Using newly declared variable in initialization (int x = x+1)?</a></p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:04.293", "Id": "23764160", "Score": "2", "CreationDate": "2014-05-20T15:30:58.017", "LastActivityDate": "2014-06-05T21:04:19.360"}, "23763748": {"CommentCount": "13", "AcceptedAnswerId": "23764160", "PostTypeId": "1", "LastEditorUserId": "493122", "CreationDate": "2014-05-20T15:14:30.160", "LastActivityDate": "2015-12-27T05:50:41.310", "LastEditDate": "2014-06-05T18:57:03.613", "ViewCount": "252", "FavoriteCount": "3", "Title": "C++ Using a reference to the variable being defined", "Id": "23763748", "Score": "7", "Body": "<p>Is the following code valid C++, according to the standard (discounting the ...s)?</p>\n<pre><code>bool f(T&amp; r)\n{\n    if(...)\n    {\n        r = ...;\n        return true;\n    }\n    return false;\n}\n\nT x = (f(x) ? x : T());\n</code></pre>\n<p>It is known to compile in the GCC versions this project uses (4.1.2 and 3.2.3... don't even get me started...), but <em>should</em> it?</p>\n<p><strong>Edit</strong>: I added some details, for example as to how f() conceptually looks like in the original code. Basically, it's meant to be initialize <em>x</em> in certain conditions.</p>\n", "Tags": "<c++><scope><language-lawyer><self-reference><object-lifetime>", "OwnerUserId": "128240", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_23763748_34477904_6": {"section_id": 7194, "quality": 1.0, "length": 10}, "so_23763748_24067465_3": {"section_id": 7151, "quality": 0.8666666666666667, "length": 13}, "so_23763748_34477904_7": {"section_id": 7194, "quality": 0.8571428571428571, "length": 6}, "so_23763748_24067465_1": {"section_id": 7194, "quality": 0.9272727272727272, "length": 51}, "so_23763748_34477904_0": {"section_id": 7189, "quality": 0.8461538461538461, "length": 33}, "so_23763748_34477904_8": {"section_id": 7194, "quality": 0.8333333333333334, "length": 5}, "so_23763748_34477904_4": {"section_id": 7194, "quality": 0.9272727272727272, "length": 51}, "so_23763748_34477904_5": {"section_id": 6185, "quality": 1.0, "length": 5}, "so_23763748_24067465_0": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_23763748_24067465_2": {"section_id": 9, "quality": 0.7391304347826086, "length": 17}}, "n3337": {"so_23763748_34477904_6": {"section_id": 6938, "quality": 1.0, "length": 10}, "so_23763748_24067465_3": {"section_id": 6895, "quality": 0.8666666666666667, "length": 13}, "so_23763748_34477904_7": {"section_id": 359, "quality": 0.5714285714285714, "length": 4}, "so_23763748_24067465_1": {"section_id": 6938, "quality": 0.9272727272727272, "length": 51}, "so_23763748_34477904_0": {"section_id": 6933, "quality": 0.8461538461538461, "length": 33}, "so_23763748_34477904_8": {"section_id": 6938, "quality": 0.8333333333333334, "length": 5}, "so_23763748_34477904_4": {"section_id": 6938, "quality": 0.9272727272727272, "length": 51}, "so_23763748_34477904_5": {"section_id": 5946, "quality": 1.0, "length": 5}, "so_23763748_24067465_0": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_23763748_24067465_2": {"section_id": 6, "quality": 0.6956521739130435, "length": 16}}, "n4659": {"so_23763748_34477904_6": {"section_id": 8702, "quality": 0.9, "length": 9}, "so_23763748_24067465_3": {"section_id": 4051, "quality": 0.6, "length": 9}, "so_23763748_34477904_7": {"section_id": 8703, "quality": 0.8571428571428571, "length": 6}, "so_23763748_24067465_1": {"section_id": 8703, "quality": 0.9272727272727272, "length": 51}, "so_23763748_34477904_0": {"section_id": 8697, "quality": 0.7435897435897436, "length": 29}, "so_23763748_34477904_4": {"section_id": 8703, "quality": 0.9272727272727272, "length": 51}, "so_23763748_34477904_5": {"section_id": 7687, "quality": 1.0, "length": 5}, "so_23763748_24067465_0": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_23763748_34477904_8": {"section_id": 8703, "quality": 0.8333333333333334, "length": 5}}}});