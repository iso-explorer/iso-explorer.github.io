post_cb({"bq_ids": {"n4140": {"so_28330471_28330636_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 2689}, "so_28330471_28330636_0": {"length": 4, "quality": 0.8, "section_id": 2710}, "so_28330471_28330636_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 2710}}, "n3337": {"so_28330471_28330636_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 2651}, "so_28330471_28330636_0": {"length": 4, "quality": 0.8, "section_id": 2671}, "so_28330471_28330636_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 2671}}, "n4659": {"so_28330471_28330636_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 3429}, "so_28330471_28330636_0": {"length": 4, "quality": 0.8, "section_id": 3450}, "so_28330471_28330636_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3450}}}, "28330471": {"ViewCount": "731", "Body": "<p>I came across a Youtube video on c++11 concurrency (part 3) and the following code, which compiles and generates correct result in the video. </p>\n<p>However, I got a compile error of this code using Visual Studio 2012. The compiler complains about the argument type of <code>toSin(list&lt;double&gt;&amp;&amp;)</code>. If I change the argument type to <code>list&lt;double&gt;&amp;</code>, the code compiled. </p>\n<p>My question is what is returned from <code>move(list)</code> in the <code>_tmain()</code>, is it a rvalue reference or just a reference? </p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;list&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvoid toSin(list&lt;double&gt;&amp;&amp; list)\n{\n    //this_thread::sleep_for(chrono::seconds(1));\n    for_each(list.begin(), list.end(), [](double &amp; x)\n    {\n        x = sin(x);\n    });\n\n    for_each(list.begin(), list.end(), [](double &amp; x)\n    {\n        int count = static_cast&lt;int&gt;(10*x+10.5);\n        for (int i=0; i&lt;count; ++i)\n        {\n            cout.put('*');\n        }\n        cout &lt;&lt; endl;\n    });\n}    \n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    list&lt;double&gt; list;\n\n    const double pi = 3.1415926;\n    const double epsilon = 0.00000001;\n    for (double x = 0.0; x&lt;2*pi+epsilon; x+=pi/16)\n    {\n        list.push_back(x);\n    }\n\n    thread th(&amp;toSin, /*std::ref(list)*/std::move(list));\n    th.join();    \n\n    return 0;\n}\n</code></pre>\n", "Title": "visual studio implementation of \"move semantics\" and \"rvalue reference\"", "CreationDate": "2015-02-04T20:06:27.640", "LastActivityDate": "2015-02-04T20:48:06.047", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "Id": "28330471", "Score": "5", "OwnerUserId": "4530116", "Tags": "<c++><c++11><visual-studio-2012><move-semantics><rvalue-reference>", "AnswerCount": "2"}, "28330636": {"Id": "28330636", "PostTypeId": "2", "Body": "<p>What is returned from <code>std::move</code> is indeed an rvalue reference, but that doesn't matter because the <code>thread</code> constructor does not use perfect forwarding for its arguments.  First it copies/moves them to storage owned by the new thread.  Then, inside the new thread, the supplied function is called using the copies.</p>\n<p>Since the copies are not temporary objects, this step won't bind to rvalue-reference parameters.</p>\n<p>What the Standard says (30.3.1.2):</p>\n<blockquote>\n<p id=\"so_28330471_28330636_0\">The new thread of execution executes</p>\n<pre><code>INVOKE( DECAY_COPY(std::forward&lt;F&gt;(f)),  DECAY_COPY(std::forward&lt;Args&gt;(args))... )\n</code></pre>\n<p id=\"so_28330471_28330636_1\">with  the  calls  to\n  <code>DECAY_COPY</code> being  evaluated  in  the  constructing  thread. </p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_28330471_28330636_2\">In several places in this Clause the operation <code>DECAY_COPY(x)</code> is used. All such uses mean call the function <code>decay_copy(x)</code> and use the result, where <code>decay_copy</code> is defined as follows:</p>\n<pre><code>template &lt;class T&gt; decay_t&lt;T&gt; decay_copy(T&amp;&amp; v)\n{ return std::forward&lt;T&gt;(v); }\n</code></pre>\n</blockquote>\n<p>The value category is lost.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2015-02-04T20:22:13.763", "Score": "-1", "CreationDate": "2015-02-04T20:16:28.960", "ParentId": "28330471", "CommentCount": "7", "OwnerUserId": "103167", "LastEditDate": "2015-02-04T20:22:13.763"}, "28330984": {"Id": "28330984", "PostTypeId": "2", "Body": "<p>This appears to be a bug in MSVC2012.  (and on quick inspection, MSVC2013 and MSVC2015)</p>\n<p><code>thread</code> does not use perfect forwarding directly, as storing a reference to data (temporary or not) in the originating thread and using it in the spawned thread would be extremely error prone and dangerous.</p>\n<p>Instead, it copies each argument into <code>decay_t&lt;?&gt;</code>'s internal data.</p>\n<p>The bug is that when it calls the worker function, it simply passes that internal copy to your procedure.  Instead, it should <em>move</em> that internal data into the call.</p>\n<p>This does not seem to be fixed in compiler version 19, which I think is MSVC2015 (did not double check), based off compiling your code over here</p>\n<p>This is both due to the wording of the standard (it is supposed to invoke a <code>decay_t&lt;F&gt;</code> with <code>decay_t&lt;Ts&gt;...</code> -- which means rvalue binding, not lvalue binding), and because the local data stored in the thread will never be used again after the invocation of your procedure (so logically it should be treated as expiring data, not persistent data).</p>\n<p>Here is a work around:</p>\n<pre><code>template&lt;class F&gt;\nstruct thread_rvalue_fix_wrapper {\n  F f;\n  template&lt;class...Args&gt;\n  auto operator()(Args&amp;...args)\n  -&gt; typename std::result_of&lt;F(Args...)&gt;::type\n  {\n      return std::move(f)( std::move(args)... );\n  }\n};\ntemplate&lt;class F&gt;\nthread_rvalue_fix_wrapper&lt; typename std::decay&lt;F&gt;::type &gt;\nthread_rvalue_fix( F&amp;&amp; f ) { return {std::forward&lt;F&gt;(f)}; }\n</code></pre>\n<p>then</p>\n<pre><code>thread th(thread_rvalue_fix(&amp;toSin), /*std::ref(list)*/std::move(list));\n</code></pre>\n<p>should work.  (tested in MSVC2015 online compiler linked above)  Based off personal experience, it should also work in MSVC2013.  I don't know about MSVC2012.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-02-04T20:48:06.047", "Score": "6", "CreationDate": "2015-02-04T20:39:33.297", "ParentId": "28330471", "CommentCount": "7", "OwnerUserId": "1774667", "LastEditDate": "2015-02-04T20:48:06.047"}});