post_cb({"29011468": {"ParentId": "25893828", "CommentCount": "1", "Body": "<p>You must have a metafunction that rebinds the type of container.\nBecause you cannot just replace first template parameter:</p>\n<pre><code>vector&lt;int, allocator&lt;int&gt; &gt; input;\nvector&lt;double, allocator&lt;int&gt; &gt; just_replaced;\nvector&lt;double, allocator&lt;double&gt; &gt; properly_rebound;\n</code></pre>\n<p>So, just write such a metafunction for known set of containers.</p>\n<pre><code>template&lt;class Container, class NewValue&gt; class rebinder;\n\n// example for vectors with standard allocator\ntemplate&lt;class V, class T&gt; class rebinder&lt; std::vector&lt;V&gt;, T &gt; {\npublic:\n  typedef std::vector&lt;T&gt; type;\n};\n// example for lists with arbitrary allocator\ntemplate&lt;class V, class A, class T&gt; class rebinder&lt; std::list&lt;V,A&gt;, T &gt; {\n  typedef typename A::template rebind&lt;T&gt;::other AT; // rebind the allocator\npublic:\n  typedef std::list&lt;T,AT&gt; type; // rebind the list\n};\n// example for arrays\ntemplate&lt;class V, size_t N&gt; class rebinder&lt; std::array&lt;V,N&gt;, T &gt; {\npublic:\n  typedef std::array&lt;T,N&gt; type;\n};\n</code></pre>\n<p>Rules of rebinding may vary for different containers.</p>\n<p>Also you might require a metafunction that extracts value type from arbitrary container, not only std-conformant (<code>typedef *unspecified* value_type</code>)</p>\n<pre><code>template&lt;class Container&gt; class get_value_type {\npublic:\n  typedef typename Container::value_type type; // common implementation\n};\ntemplate&lt;class X&gt; class get_value_type&lt; YourTrickyContainer&lt;X&gt; &gt; {\n  ......\npublic:\n  typedef YZ type;\n};\n</code></pre>\n", "OwnerUserId": "2488993", "PostTypeId": "2", "Id": "29011468", "Score": "0", "CreationDate": "2015-03-12T13:44:46.890", "LastActivityDate": "2015-03-12T13:44:46.890"}, "25893828": {"CommentCount": "7", "ViewCount": "2105", "PostTypeId": "1", "LastEditorUserId": "369310", "LastActivityDate": "2016-12-03T09:57:02.723", "Body": "<p>I was wondering if it's possible to write a template function that can take any other arbitrary template as a parameter and properly match the template name (i.e. not just the resulting class). What I know to work is this:</p>\n<pre><code>template&lt;template&lt;typename ...&gt; class TemplateT, typename... TemplateP&gt;\nvoid f(const TemplateT&lt;TemplateP...&gt;&amp; param);\n</code></pre>\n<p>Which will match for instance for <code>f(std::vector&lt;int&gt;())</code> or <code>f(std::list&lt;int&gt;())</code> but will not work for <code>f(std::array&lt;int, 3&gt;())</code>, as the second parameter is a <code>size_t</code> and no type.</p>\n<p>Now I guess one could do something crazy like:</p>\n<pre><code>template&lt;template&lt;typename ...&gt; class TemplateT, size... Sizes, typename... TemplateP&gt;\nvoid f(const TemplateT&lt;Sizes..., TemplateP...&gt;&amp; param);\n</code></pre>\n<p>Hoping that the compiler would properly derive either the <code>TemplateP</code> ellipsis or the <code>Sizes</code> ellipsis to be empty. But not only is it ugly, it also will still just work for templates that take either types or <code>size_t</code> parameters. It still won't match arbitrary templates for instance with <code>bool</code> parameters.</p>\n<p>Same goes for an approach with overloading:</p>\n<pre><code>template&lt;template&lt;typename ...&gt; class TemplateT, typename... TemplateP&gt;\nvoid f(const TemplateT&lt;TemplateP...&gt;&amp; param);\n\ntemplate&lt;template&lt;typename ...&gt; class TemplateT, size... Sizes&gt;\nvoid f(const TemplateT&lt;Sizes...&gt;&amp; param);\n</code></pre>\n<p>Furthermore, such approach wont' work if we would like to mix <code>size_t</code> and <code>typenames</code>. So what would be required to match anything would be something like this, where there are no constraints at all to what is allowed in the ellipsis:</p>\n<pre><code>template&lt;template&lt;...&gt; class TemplateT, ... Anything&gt;\nvoid f(const TemplateT&lt;Anything...&gt;&amp; param);\n</code></pre>\n<p>That syntax doesn't work but maybe there's other syntax to define something like this? </p>\n<p>This is mainly me wondering what is possible in the language, thought there might actually be a use for it, if you have different templates where the first parameter is always fixed and you would like to change it based on the return type and keep everything else. Something like this:</p>\n<pre><code>template&lt;\n    template&lt;typename ValueT, ...&gt; class TemplateT,\n    ... Anything,\n    typename ValueT,\n    typename ResultT = decltype(some_operation_on_value_t(std::declval&lt;ValueT&gt;())&gt;\nTemplateT&lt;ResultT, Anything...&gt; f(const TemplateT&lt;ValueT, Anything...&gt;&amp; in);\n</code></pre>\n<p>So, any way to make this work in a completely generic way using pattern matching?</p>\n<p>This is not purely a thought experiment, as the use case for this where I was stuck was to create pure functional primitives that operate on containers and will implicitly construct immutable result containers. If the result container has a different data type we need to know the type the container operates on, so the only requirement on any container would be that the first parameter of the template needs to be the input type so it can be replaced with a different output type in the result, but the code should be oblivious to any template argument coming after that and should not care whether it's a type or a value.</p>\n", "Title": "C++ variadic template template argument that matches any kind of parameters", "FavoriteCount": "12", "LastEditDate": "2016-12-03T09:57:02.723", "Id": "25893828", "Score": "37", "CreationDate": "2014-09-17T14:50:34.013", "Tags": "<c++><templates><c++11><variadic-templates><template-templates>", "OwnerUserId": "369310", "AnswerCount": "3"}, "29915578": {"ParentId": "25893828", "LastEditDate": "2015-04-29T07:51:01.903", "CommentCount": "2", "CreationDate": "2015-04-28T09:31:10.913", "OwnerUserId": "1978011", "LastEditorUserId": "1978011", "PostTypeId": "2", "Id": "29915578", "Score": "3", "Body": "<p>Your interesting construct has two levels with variadic templates.</p>\n<ul>\n<li>An outer variadic template parameter list <code>TemplateP</code> &amp; <code>Sizes</code> for a <em>function template</em></li>\n<li>An inner parameter pack as the template parameters of your template template parameter <code>TemplateT</code>, a <em>class template</em></li>\n</ul>\n<p>First, let's look at the inner <code>TemplateT</code> class: why can the ellipsis operator not not match something like <code>TemplateT&lt; int, 2 &gt;</code>? Well, the standard defines variadic templates in \u00a714.5.3 as</p>\n<pre><code>template&lt;class ... Types&gt; struct Tuple { };\ntemplate&lt;T ...Values&gt; struct Tuple2 { };\n</code></pre>\n<p>where the template argument pack in the first case may <strong>only</strong> match types and in the second version <strong>only</strong> values of type <code>T</code>. In particular,</p>\n<pre><code>Tuple &lt; 0 &gt;    error;  // error, 0 is not a type!\nTuple &lt; T, 0 &gt; error2; // T is a type, but zero is not!\nTuple2&lt; T &gt;    error3; // error, T is not a value\nTuple2&lt; T, 0 &gt; error4; // error, T is not a value\n</code></pre>\n<p>are all malformed. Furthermore, it is not possible to fall back to something like</p>\n<pre><code>template&lt;class ... Types, size_t ...Sizes&gt; struct Tuple { };\n</code></pre>\n<p>because the standard states in \u00a714.1.11:</p>\n<blockquote>\n<p id=\"so_25893828_29915578_0\">If a template-parameter of a primary class template or alias template is a template parameter pack, it\n  shall be the last template-parameter. A template parameter pack of a function template shall not be followed\n  by another template parameter unless that template parameter can be deduced from the parameter-type-list\n  of the function template or has a default argument (14.8.2).</p>\n</blockquote>\n<p>In other words, for class templates only <strong>one</strong> variadic parameter pack may appear in the definition. Therefore the above (double)-variadic class definition is malformed. Because the inner class always needs such a combination, it is impossible to write something as general as you conceived.</p>\n<hr>\n<p>What can be rescued? For the outer function template, some shards can be put together, but you won't like it. As long as the second parameter pack can be deduced from the first, two parameter packs may appear (in a function template). Therefore, a function such as</p>\n<pre><code>template &lt; typename... Args, size_t... N &gt; void g(const std::array&lt; Args, N &gt; &amp;...arr);\ng(std::array&lt; double, 3 &gt;(), std::array&lt; int, 5&gt;());\n</code></pre>\n<p>is allowed, because the integer values can be deduced. Of course, this would have to be specialized for every container type and is far from what you had imagined.</p>\n</hr>", "LastActivityDate": "2015-04-29T07:51:01.903"}, "bq_ids": {"n4140": {"so_25893828_29915578_0": {"section_id": 64, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_25893828_29915578_0": {"section_id": 59, "quality": 0.8666666666666667, "length": 26}}, "n4659": {"so_25893828_29915578_0": {"section_id": 66, "quality": 0.9666666666666667, "length": 29}}}, "40932248": {"ParentId": "25893828", "LastEditDate": "2017-05-23T12:13:51.060", "CommentCount": "0", "CreationDate": "2016-12-02T12:27:07.987", "OwnerUserId": "2748628", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "40932248", "Score": "0", "Body": "<p>It would be awesome if we had such thing, as it would allow us to write a <a href=\"https://stackoverflow.com/a/35064803/2748628\"><code>is_same_template</code></a> trait in a breeze.<br>\nUntil then, we specialize all the way.</br></p>\n", "LastActivityDate": "2016-12-02T12:27:07.987"}});