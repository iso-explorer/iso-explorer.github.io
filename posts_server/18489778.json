post_cb({"18490078": {"ParentId": "18489778", "CommentCount": "0", "Body": "<p>The key is that access specifiers are not checked until the conversion sequence is selected, so the code <em>feels</em> like:</p>\n<pre><code>struct base {};\nstruct derived : base {};\nstruct conv { \n   operator base() const;\n   operator derived();\n};\nvoid fn(base);\nint main() {\n   conv c;\n   fn(c);\n}\n</code></pre>\n<p>At this point there are different valid conversion sequences:</p>\n<ul>\n<li>adding <code>const</code> qualification, then user conversion to base</li>\n<li>user conversion to derived, derived to base conversion</li>\n</ul>\n<p>The second conversion is a better conversion sequence and it is selected.</p>\n<p>This is treated in the standard in 13.3.3.1/2:</p>\n<blockquote>\n<p id=\"so_18489778_18490078_0\">Implicit conversion sequences are concerned only with the type, cv-qualification, and value category of the argument and how these are converted to match the corresponding properties of the parameter. Other properties, such as the lifetime, storage class, alignment, or accessibility of the argument and whether or not the argument is a bit-field are ignored. So, <em>although an implicit conversion sequence can be defined for a given argument-parameter pair, the conversion from the argument to the parameter might still be ill-formed in the final analysis</em>.</p>\n</blockquote>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "18490078", "Score": "2", "CreationDate": "2013-08-28T13:58:02.553", "LastActivityDate": "2013-08-28T13:58:02.553"}, "18489813": {"ParentId": "18489778", "CommentCount": "2", "Body": "<p>Your <code>c</code> object is non-const, so in the first case the <code>Derive</code> overload is an exact const-correct match that can still implicitly convert to <code>Base</code>. In the second example <code>Derive</code> can't convert to <code>Base</code> so the direct <code>Base</code> conversion has to be selected.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "18489813", "Score": "4", "CreationDate": "2013-08-28T13:48:27.593", "LastActivityDate": "2013-08-28T13:48:27.593"}, "18489778": {"CommentCount": "2", "AcceptedAnswerId": "18490078", "ClosedDate": "2013-08-29T09:52:13.603", "CreationDate": "2013-08-28T13:46:17.030", "LastActivityDate": "2013-08-28T13:58:02.553", "PostTypeId": "1", "ViewCount": "86", "Title": "Why the following code is error (about overload resolution)", "Id": "18489778", "Score": "0", "Body": "<p>Given the following code in gcc-4.8.1</p>\n<pre><code>struct Base\n{\n};\n\nstruct Derive : private Base\n{\n};\n\nvoid fn(Base, int);\n\nstruct Conv\n{\n    operator Base() const;\n    operator Derive();\n};\n\nint main()\n{\n    Conv c;\n    fn(c, 0);\n    return 0;\n}\n</code></pre>\n<p>When I gave above code, I got an error.I think compiler will select <code>Conv::operator Base()</code> but actually the compiler selected <code>Conv::operator Derive()</code> </p>\n<p>But when I gave the following code, the compiler selected <code>Conv::operator Base()</code></p>\n<pre><code>struct Base\n{\n};\n\nstruct Derive// : private Base\n{\n};\n\nvoid fn(Base, int);\n\nstruct Conv\n{\n    operator Base() const;\n    operator Derive();\n};\n\nint main()\n{\n    Conv c;\n    fn(c, 0);\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><overloading>", "OwnerUserId": "2482012", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_18489778_18490078_0": {"section_id": 607, "quality": 1.0, "length": 45}}, "n3337": {"so_18489778_18490078_0": {"section_id": 597, "quality": 1.0, "length": 45}}, "n4659": {"so_18489778_18490078_0": {"section_id": 633, "quality": 1.0, "length": 45}}}});