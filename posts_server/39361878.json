post_cb({"bq_ids": {"n4140": {"so_39361878_39362463_0": {"length": 55, "quality": 0.9821428571428571, "section_id": 986}, "so_39361878_39362463_1": {"length": 30, "quality": 0.967741935483871, "section_id": 972}, "so_39361878_39362416_0": {"length": 9, "quality": 1.0, "section_id": 972}}, "n3337": {"so_39361878_39362463_0": {"length": 42, "quality": 0.75, "section_id": 971}, "so_39361878_39362463_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 961}, "so_39361878_39362416_0": {"length": 9, "quality": 1.0, "section_id": 961}}, "n4659": {"so_39361878_39362416_0": {"length": 9, "quality": 1.0, "section_id": 1034}, "so_39361878_39362463_1": {"length": 30, "quality": 0.967741935483871, "section_id": 1034}, "so_39361878_39362463_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 1049}}}, "39361878": {"ViewCount": "79", "Body": "<p>Consider this code:</p>\n<pre><code>int main()\n{\n\n    std::vector&lt;std::string&gt; v;\n\n    v.push_back(\"hello\");\n    v.push_back(\"stack\");\n\n    std::string &amp;s = v[0];\n\n    v.push_back(\"overflow\");\n\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>After running (using <code>g++ (Ubuntu 4.8.4-2ubuntu1~14.04.1) 4.8.4</code>) this prints only an empty line, <code>hello</code> is not printed. If I comment out <code>v.push_back(\"stack\");</code> then a segmentation fault appears.</p>\n<p>Now I understand why this is happening. Adding more elements to vector is triggering a grow operation under the hood and my old reference becomes invalid after that. This is not my question.</p>\n<p>My question is whether this behavior - modifying a vector or other STL container after taking a reference/pointer - is defined as undefined behavior in C++ standard? If yes, where? If no then what the standard says about this type of situation?</p>\n", "AcceptedAnswerId": "39362463", "Title": "Taking reference to vector element before adding more element to vector", "CreationDate": "2016-09-07T05:35:41.073", "Id": "39361878", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2016-09-07T07:22:34.417", "Score": "2", "OwnerUserId": "377953", "Tags": "<c++><vector><stl>", "AnswerCount": "2"}, "39362416": {"Id": "39362416", "PostTypeId": "2", "Body": "<p>C++14 [vector.capacity]/6:</p>\n<blockquote>\n<p id=\"so_39361878_39362416_0\">Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence.</p>\n</blockquote>\n<p>[vector.modifiers]/6 covers that <code>push_back</code> may cause reallocation, with iterators not being invalidated only if it did not reallocate.</p>\n<p>I can't actually find any text that defines what it means for a reference to be invalidated, but it is clearly implied that using the referred-to value after invalidation would be undefined behaviour.</p>\n", "LastActivityDate": "2016-09-07T06:16:08.690", "CommentCount": "1", "CreationDate": "2016-09-07T06:16:08.690", "ParentId": "39361878", "Score": "3", "OwnerUserId": "1505939"}, "39362463": {"Id": "39362463", "PostTypeId": "2", "Body": "<p>The act of modifying the container is not prohibited just because you acquired an iterator, reference, or pointer by some means. It is the iterator, reference, or pointer itself that is <em>potentially</em> invalidated.</p>\n<p><strong>\u00a723.3.6.6 [vector.modifiers]</strong> (includes the <code>push_back</code> member family)</p>\n<blockquote id=\"so_39361878_39362463_0\">\n<ol>\n<li>Remarks: <strong>Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before\n  the insertion point remain valid.</strong> If an exception is thrown other than\n  by the copy constructor, move constructor, assignment operator, or\n  move assignment operator of <code>T</code> or by any InputIterator operation there\n  are no effects. If an exception is thrown while inserting a single\n  element at the end and <code>T</code> is CopyInsertable or\n  <code>is_nothrow_move_constructible&lt;T&gt;::value</code> is true, there are no effects.\n  Otherwise, if an exception is thrown by the move constructor of a\n  non-CopyInsertable <code>T</code>, the effects are unspecified.</li>\n</ol>\n</blockquote>\n<p>If no resize happens only references, pointers, and iterators (including the end-iterator) past the insertion point are invalid. Great, but what happens if a reallocation happens? Interestingly, we find that in:</p>\n<p><strong>\u00a723.3.6.3 [vector.capacity]</strong> </p>\n<blockquote id=\"so_39361878_39362463_1\">\n<ol start=\"6\">\n<li>Remarks: <strong>Reallocation invalidates all the references, pointers, and\n  iterators referring to the elements in the sequence.</strong> No reallocation\n  shall take place during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the\n  vector greater than the value of capacity().</li>\n</ol>\n</blockquote>\n<p>I'm not entirely convinced this completely answers your question, however. If your wondering what happened to the prior memory that occupied the vector, that's up to the standard library, but it no longer contains viable content. The container no longer owns the memory (as far as you know), and neither do you.</p>\n", "LastEditorUserId": "1322972", "LastActivityDate": "2016-09-07T07:22:34.417", "Score": "2", "CreationDate": "2016-09-07T06:19:06.237", "ParentId": "39361878", "CommentCount": "0", "OwnerUserId": "1322972", "LastEditDate": "2016-09-07T07:22:34.417"}});