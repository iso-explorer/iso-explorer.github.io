post_cb({"621672": {"CommentCount": "1", "CreationDate": "2009-03-07T10:57:03.550", "LastEditorUserId": "-1", "LastActivityDate": "2009-03-07T10:57:03.550", "ParentId": "621542", "LastEditDate": "2017-05-23T12:03:05.600", "OwnerDisplayName": "jalf", "PostTypeId": "2", "Id": "621672", "Score": "6", "Body": "<p><a href=\"https://stackoverflow.com/questions/598148/is-it-legal-to-use-the-increment-operator-in-a-c-function-call\">Read this</a></p>\n<p>It's not an exact copy of your question, but my answer (and a few others) cover your question as well.</p>\n<p>There are very good optimization reasons why the compiler might not just choose right-to-left but also interleave them.</p>\n<p>The standard doesn't even guarantee a sequential ordering. It <em>only</em> guarantees that when the function gets called, all arguments have been fully evaluated.</p>\n<p>And yes, I have seen a few versions of GCC do exactly this. For your example, foo(0,0) would be called, and i would be 2 afterwards. (I can't give you the exact version number of the compiler. It was a while ago - but I wouldn't be surprised to see this behavior pop up again. It's an efficient way to schedule instructions)</p>\n", "OwnerUserId": "33213"}, "621556": {"ParentId": "621542", "CommentCount": "0", "Body": "<p>I expect that most modern compilers would attempt to interleave the instructions computing the arguments, given that they are required by the C++ standard to be independent and thus lack any interdependencies.  Doing this should help to keep a deeply-pipelined CPU's execution units full and thereby increase throughput.  (At least I would expect that a compiler that claims to be an optimising compiler would do so when optimisation flags are given.)</p>\n", "OwnerUserId": "47984", "PostTypeId": "2", "Id": "621556", "Score": "2", "CreationDate": "2009-03-07T08:54:27.713", "LastActivityDate": "2009-03-07T08:54:27.713"}, "5390973": {"ParentId": "621542", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>All arguments are evaluated. Order not defined (as per standard). But all implementations of C/C++ (that I know of) evaluate function arguments from <strong>right to left</strong>.  <em>EDIT: CLang is an exception (see comment below).</em></p>\n<p>I believe that the right-to-left evaluation order has been very very old (since the first C compilers). Certainly way before C++ was invented, and most implementations of C++ would be keeping the same evaluation order because early C++ implementations simply translated into C. </p>\n<p>There are some technical reasons for evaluating function arguments right-to-left. In stack architectures, arguments are typically pushed onto the stack. In C/C++, you can call a function with more arguments than actually specified -- the extra arguments are simiply ignored. If arguments are evaluated left-to-right, and pushed left-to-right, then the stack slot right under the stack pointer will hold the last argument, and there is no way for the function to get at the offset of any particular argument (because the actual number of arguments pushed depends on the caller).</p>\n<p>In a right-to-left push order, the stack slot right under the stack pointer will always hold the first argument, and the next slot holds the second argument etc. Argument offsets will always be deterministic for the function (which may be written and compiled elsewhere into a library, separately from where it is called).</p>\n<p>Now, right-to-left push order does not mandate right-to-left evaluation order, but in early compilers, memory is scarce. In right-to-left evaluation order, the same stack can be used in-place (essentially, after evaluating the argument -- which may be an expression or a funciton call! -- the return value is already at the right position on the stack). In left-to-right evaluation, the argument values must be stored separately and the pushed back to the stack in reverse order.</p>\n", "OwnerUserId": "650891", "LastEditorUserId": "650891", "LastEditDate": "2015-09-16T02:34:20.187", "Id": "5390973", "Score": "3", "CreationDate": "2011-03-22T12:10:50.000", "LastActivityDate": "2015-09-16T02:34:20.187"}, "621548": {"CommentCount": "11", "CreationDate": "2009-03-07T08:48:37.947", "LastEditorUserId": "66692", "LastActivityDate": "2009-03-07T11:30:11.973", "ParentId": "621542", "PostTypeId": "2", "LastEditorDisplayName": "dirkgently", "LastEditDate": "2009-03-07T11:30:11.973", "Id": "621548", "Score": "49", "Body": "<p>It depends on the argument type, the called function's calling convention, the archtecture and the compiler. On an x86, the <a href=\"http://en.wikipedia.org/wiki/X86_calling_conventions#pascal\" rel=\"noreferrer\">Pascal</a> calling convention evaluates arguments left to right whereas in the C calling convention (<a href=\"http://msdn.microsoft.com/en-us/library/zkwh89ks(VS.80).aspx\" rel=\"noreferrer\">__cdecl</a>) it is right to left. Most programs which run on multiple platforms do take into account the calling conventions to skip surprises. </p>\n<p>There is a nice <a href=\"http://blogs.msdn.com/oldnewthing/archive/2004/01/08/48616.aspx\" rel=\"noreferrer\">article</a> on Raymond Chen' blog if you are interested. You may also want to take a look at the <a href=\"http://gcc.gnu.org/onlinedocs/gccint/Stack-and-Calling.html\" rel=\"noreferrer\">Stack and Calling</a> section of the GCC manual.</p>\n<p><strong>Edit:</strong> So long as we are splitting hairs: My answer treats this not as a language question but as a platform one. The language standard does not gurantee or prefer one over the other and leaves it as <strong>unspecified</strong>. Note the wording. It does not say this is undefined. Unspecified in this sense means something you cannot count on, non-portable behavior. I don't have the C spec/draft handy but it should be similar to that from my n2798 draft (C++) </p>\n<blockquote>\n<p id=\"so_621542_621548_0\">Certain other aspects and operations of the abstract machine are described in this International Standard as unspecified (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine. An instance of the abstract machine can thus have more than one possible execution sequence for a given program and a given input.</p>\n</blockquote>\n", "OwnerUserId": "66692", "OwnerDisplayName": "dirkgently"}, "621542": {"CommentCount": "5", "CreationDate": "2009-03-07T08:41:19.540", "PostTypeId": "1", "AcceptedAnswerId": "621548", "LastEditorUserId": "560648", "LastActivityDate": "2015-09-16T02:34:20.187", "AnswerCount": "6", "LastEditDate": "2012-02-29T13:43:31.377", "ViewCount": "18558", "FavoriteCount": "19", "Title": "Compilers and argument order of evaluation in C++", "Id": "621542", "Score": "51", "Body": "<p>Okay, I'm aware that the standard dictates that a C++ implementation may choose in which order arguments of a function are evaluated, but are there any implementations that actually 'take advantage' of this in a scenario where it would actually affect the program?</p>\n<p>Classic Example:</p>\n<pre><code>int i = 0;\nfoo(i++, i++);\n</code></pre>\n<p>Note: I'm not looking for someone to tell me that the order of evaluation can't be relied on, I'm well aware of that. I'm only interested in whether any compilers actually do evaluate out of a left-to-right order because my guess would be that if they did lots of poorly written code would break (rightly so, but they would still probably complain).</p>\n", "Tags": "<c++><compiler-construction><order-of-evaluation>", "OwnerUserId": "75002", "OwnerDisplayName": "Cypherjb"}, "621554": {"ParentId": "621542", "CommentCount": "3", "Body": "<p>Last time I saw differences was between VS2005 and GCC 3.x on an x86 hardware in 2007.\nSo it's (was?) a very likely situation. So I never rely on evaluation order anymore. Maybe it's better now.</p>\n", "OwnerUserId": "15124", "Id": "621554", "PostTypeId": "2", "OwnerDisplayName": "Robert Gould", "Score": "1", "CreationDate": "2009-03-07T08:52:07.470", "LastActivityDate": "2009-03-07T08:52:07.470"}, "8785485": {"ParentId": "621542", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I found answer in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\">c++ standards</a>.</p>\n<p>Paragraph 5.2.2.8: </p>\n<blockquote>\n<p id=\"so_621542_8785485_0\">The order of evaluation of arguments is unspecified. All side effects of argument expression evaluations take effect before the function is entered. The order of evaluation of the postfix expression and the argument expression list is\n  unspecified.</p>\n</blockquote>\n<p>In other words, It depends on compiler only.</p>\n", "OwnerUserId": "1116052", "LastEditorUserId": "520162", "LastEditDate": "2012-01-17T15:06:45.350", "Id": "8785485", "Score": "7", "CreationDate": "2012-01-09T08:15:44.420", "LastActivityDate": "2012-01-17T15:06:45.350"}, "bq_ids": {"n4140": {"so_621542_621548_0": {"section_id": 5799, "quality": 0.8636363636363636, "length": 38}}, "n3337": {"so_621542_621548_0": {"section_id": 5572, "quality": 0.9090909090909091, "length": 40}}, "n4659": {"so_621542_621548_0": {"section_id": 7258, "quality": 0.8636363636363636, "length": 38}}}});