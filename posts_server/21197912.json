post_cb({"21197947": {"Id": "21197947", "PostTypeId": "2", "Body": "<p><code>std::thread</code>'s destructor will call <code>std::terminate</code> if the thread has not been joined or detached.</p>\n<p>So unfortunately you cannot create an anonymous thread object like this - you need a reference to the <code>thread</code> object in order to call either <code>join()</code> or <code>detach()</code>.</p>\n<p>Scott Meyers gave a talk at Going Native 2013 where he created an RAII class that wraps a thread and calls join in the destructor.  You could do something similar:</p>\n<pre><code>class ThreadRAII {\npublic:\n  ThreadRAII(std::thread&amp;&amp; thread): t(std::move(thread)) {}\n  ~ThreadRAII() { if (t.joinable()) { t.join(); }\n\nprivate:\n  std::thread t;\n};\n</code></pre>\n<p>See his <a href=\"http://scottmeyers.blogspot.com/2013/12/threadraii-thread-suspension-trouble.html\" rel=\"nofollow\" title=\"blog post\">blog post</a>  or <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/An-Effective-Cpp11-14-Sampler\" rel=\"nofollow\" title=\"talk\">talk</a> for more info.</p>\n<p>You could use it like this</p>\n<pre><code>(ThreadRAII(std::thread(Foo)));\n</code></pre>\n<p>However, the only reason you'd want to create a thread in this way is if you don't care when (or if) it ends, so in this case, join doesn't make much sense.  You should modify the destructor to detach instead:</p>\n<pre><code>~ThreadRAII() { if (t.joinable()) { t.detach(); }\n</code></pre>\n<p>As suggested in the comments, you could make it even easier to use by perfect forwarding to an internal thread on construction:</p>\n<pre><code>class ThreadRAII2 {\npublic:    \n\n    template &lt;typename Func, typename ...Args&gt;\n    explicit ThreadRAII2(Func&amp;&amp; func, Args&amp;&amp;... args) :\n        t(func, std::forward&lt;Args&gt;(args)...) {  }\n\n    ~ThreadRAII2() { \n        if (t.joinable()) t.detach(); \n    }\nprivate:\n    std::thread t;\n};\n</code></pre>\n<p>Then you can use it just like you originally wanted to, no detach necessary:</p>\n<pre><code>(ThreadRAII2(Foo));\n</code></pre>\n<p>Or, if <code>Foo</code> takes arguments (for example <code>Foo(int)</code>):</p>\n<pre><code>(ThreadRAII2(Foo, 42));\n</code></pre>\n", "LastEditorUserId": "914991", "LastActivityDate": "2014-01-18T18:13:00.083", "Score": "10", "CreationDate": "2014-01-17T23:35:55.150", "ParentId": "21197912", "CommentCount": "4", "LastEditDate": "2014-01-18T18:13:00.083", "OwnerUserId": "914991"}, "bq_ids": {"n4140": {"so_21197912_21197942_2": {"length": 34, "quality": 0.85, "section_id": 2717}}, "n3337": {"so_21197912_21197942_2": {"length": 34, "quality": 0.85, "section_id": 2678}}, "n4659": {"so_21197912_21197942_2": {"length": 34, "quality": 0.85, "section_id": 3457}}}, "21197912": {"ViewCount": "1665", "Body": "<p>Consider the following short program:</p>\n<pre><code>#include &lt;thread&gt;\n\nint Foo() {\nwhile (1);\n}\n\nint main(){\n    std::thread t(Foo);\n    std::thread s(Foo);\n\n    // (std::thread(Foo));\n\n    t.join();\n}\n</code></pre>\n<p>This compiles and runs (forever), with </p>\n<pre><code>g++ -Wl,--no-as-needed DoubleBufferTest.cc -o DoubleBufferTest -std=c++0x -pthread\n</code></pre>\n<p>In the commented out line, I am trying to use the technique described <a href=\"https://stackoverflow.com/questions/9790679/anonymous-object-with-one-argument-cannot-be-declared\">here</a> to declare a new thread anonymously.  However, when that line is commented back in, I can compile but running gives the following error:</p>\n<pre><code>terminate called without an active exception            \nAborted (core dumped)                                   \n</code></pre>\n<p>How can I correctly declare a thread anonymously?</p>\n<p>Note, I am on <code>g++ 4.4.7</code>.</p>\n", "AcceptedAnswerId": "21198006", "Title": "How can I declare an std::thread anonymously?", "CreationDate": "2014-01-17T23:31:00.497", "Id": "21197912", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:58:48.170", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-18T18:13:00.083", "Score": "8", "OwnerUserId": "391161", "Tags": "<c++><multithreading><c++11><stdthread>", "AnswerCount": "3"}, "21197942": {"Id": "21197942", "PostTypeId": "2", "Body": "<p>I don't think this (the technique you are referring to) is possible with threads.</p>\n<p>Take a look here;</p>\n<blockquote>\n<p id=\"so_21197912_21197942_0\">30.3.1.3 thread destructor [thread.thread.destr]</p>\n<p id=\"so_21197912_21197942_1\">~thread();</p>\n<p id=\"so_21197912_21197942_2\">If joinable() then terminate(), otherwise no effects. [ Note: Either implicitly\n  detaching or joining a joinable() thread in its destructor could result in \n  difficult to debug correctness (for detach) or performance (for join) bugs\n  encountered only when an exception is raised. Thus the programmer must ensure \n  that the destructor is never executed while the thread is still joinable. \n  \u2014 end note ]</p>\n</blockquote>\n<p>Basically the temporary anonymous object (i.e. thread) you are creating is destructed right when execution continues to the next line which violates the above rule.</p>\n", "LastEditorUserId": "319403", "LastActivityDate": "2014-01-17T23:39:36.357", "Score": "4", "CreationDate": "2014-01-17T23:35:19.990", "ParentId": "21197912", "CommentCount": "0", "LastEditDate": "2014-01-17T23:39:36.357", "OwnerUserId": "2820379"}, "21198006": {"Id": "21198006", "PostTypeId": "2", "Body": "<p>You can do it like this:</p>\n<pre><code>std::thread(Foo).detach();\n</code></pre>\n", "LastActivityDate": "2014-01-17T23:41:10.757", "Score": "11", "CreationDate": "2014-01-17T23:41:10.757", "ParentId": "21197912", "CommentCount": "6", "OwnerUserId": "576911"}});