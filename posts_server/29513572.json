post_cb({"29513887": {"ParentId": "29513572", "CommentCount": "0", "Body": "<p>Well, no, it's not a case of undefined behaviour.   It is a case of unspecified behaviour.</p>\n<p>It is unspecified whether the expression <code>len_ = len</code> will be evaluated before or after <code>buffer(len+1)</code>.   From the output you have described, g++ evaluates <code>buffer(len+1)</code> first, and clang evaluates <code>len_ = len</code> first.</p>\n<p>Both possibilities are correct, since the order of evaluation of those two sub-expressions is unspecified .   Both expressions will be evaluated (so the behaviour does not qualify as being undefined) but the standard does not specify the order.</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "29513887", "Score": "11", "CreationDate": "2015-04-08T11:54:35.777", "LastActivityDate": "2015-04-08T11:54:35.777"}, "29513843": {"ParentId": "29513572", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is <a href=\"http://en.wikipedia.org/wiki/Unspecified_behavior\" rel=\"nofollow noreferrer\">unspecified behavior</a>, <code>len_ = len</code> is <em>indeterminately sequenced</em> with respect to the execution of the body of <code>buffer()</code>, which means that one will be executed before the other but it is not specified which order but there is an ordering so evaluations can not overlap therefore no undefined behavior. This means <code>gcc</code>, <code>clang</code> and <code>Visual Studio</code> are all correct. On other hand <em>unsequenced evaluations</em> allow for overlapping evaluations which can lead to undefined behavior as noted below.</p>\n<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft C++11 standard</a> section <code>1.9</code> <em>[intro.execution]</em>:</p>\n<blockquote>\n<p id=\"so_29513572_29513843_0\">[...]Every evaluation in the calling function (including other function calls) that is not otherwise specifically\n  sequenced before or after the execution of the body of the called function is indeterminately sequenced with\n  respect to the execution of the called function.9[...]</p>\n</blockquote>\n<p>and <em>indeterminately sequenced</em> is covered a little before this and says:</p>\n<blockquote>\n<p id=\"so_29513572_29513843_1\">[...]Evaluations A and B are indeterminately sequenced when either A\n  is sequenced before B or B is sequenced before A, but it is unspecified which. [ Note: Indeterminately\n  sequenced evaluations cannot overlap, but either could be executed first. \u2014end note ]</p>\n</blockquote>\n<p>which is different than <em>unsequenced evaluations</em>:</p>\n<blockquote>\n<p id=\"so_29513572_29513843_2\">[...]If A is not sequenced before\n  B and B is not sequenced before A, then A and B are unsequenced. [ Note: The execution of unsequenced\n  evaluations can overlap. \u2014end note ][...]</p>\n</blockquote>\n<p>which can lead to undefined behavior (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_29513572_29513843_3\"><strong>Except where noted, evaluations of operands of individual operators and of subexpressions of individual\n  expressions are unsequenced</strong>. [ Note: In an expression that is evaluated more than once during the execution\n  of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be\n  performed consistently in different evaluations. \u2014end note ] The value computations of the operands of an\n  operator are sequenced before the value computation of the result of the operator. <strong>If a side effect on a scalar\n  object is unsequenced relative to either another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, the behavior is undefined</strong>[...]</p>\n</blockquote>\n<p><b> Pre C++11</b></p>\n<p><a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow noreferrer\">Pre C++11</a> the order of evaluation of sub-expressions is also unspecified but it uses <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">sequence points</a> as opposed to ordering. In this case, there is a sequence point at function entry and function exit which ensures there is no undefined behavior. From section <code>1.9</code>:</p>\n<blockquote>\n<p id=\"so_29513572_29513843_4\">[...]The sequence points at function-entry and function-exit\n  (as described above) are features of the function calls as evaluated, whatever the syntax of the expression that calls the\n  function might be.</p>\n</blockquote>\n<p><b>Nailing down order of evaluation</b></p>\n<p>The different choices made by each compiler may seem unintuitive depending on your perspective and expectations. The subject of nailing down order of evaluation is the subject of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4421.html#158\" rel=\"nofollow noreferrer\">EWG issue 158: N4228 Refining Expression Evaluation Order for Idiomatic C++</a>, which is being considered for C++17 but seems controversial <a href=\"http://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/\" rel=\"nofollow noreferrer\">based on the reactions to a poll on the subject</a>. The paper covers a much more <a href=\"https://stackoverflow.com/q/27158812/1708801\">complicated case</a> from <em>\"The C++ Programming Language\" 4th edition</em>. Which shows even those with deep experience in C++ can get tripped up.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:28:28.463", "Id": "29513843", "Score": "18", "CreationDate": "2015-04-08T11:52:55.950", "LastActivityDate": "2015-10-20T19:00:02.600"}, "bq_ids": {"n4140": {"so_29513572_29513843_3": {"section_id": 5811, "quality": 0.9384615384615385, "length": 61}, "so_29513572_29513843_0": {"section_id": 5811, "quality": 0.9565217391304348, "length": 22}, "so_29513572_29513843_1": {"section_id": 5809, "quality": 0.8333333333333334, "length": 20}, "so_29513572_29513843_4": {"section_id": 5811, "quality": 0.7058823529411765, "length": 12}, "so_29513572_29513843_2": {"section_id": 5809, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_29513572_29513843_3": {"section_id": 5584, "quality": 0.9384615384615385, "length": 61}, "so_29513572_29513843_0": {"section_id": 5584, "quality": 0.9565217391304348, "length": 22}, "so_29513572_29513843_1": {"section_id": 5582, "quality": 0.8333333333333334, "length": 20}, "so_29513572_29513843_4": {"section_id": 5584, "quality": 0.7058823529411765, "length": 12}, "so_29513572_29513843_2": {"section_id": 5582, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_29513572_29513843_3": {"section_id": 7272, "quality": 0.8461538461538461, "length": 55}, "so_29513572_29513843_1": {"section_id": 7270, "quality": 0.8333333333333334, "length": 20}, "so_29513572_29513843_4": {"section_id": 7273, "quality": 0.7058823529411765, "length": 12}, "so_29513572_29513843_2": {"section_id": 7270, "quality": 0.6666666666666666, "length": 10}}}, "29513572": {"CommentCount": "1", "AcceptedAnswerId": "29513843", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-04-08T11:40:09.327", "LastActivityDate": "2015-10-20T19:00:02.600", "LastEditDate": "2015-04-09T02:10:09.660", "ViewCount": "749", "FavoriteCount": "3", "Title": "Sequence Point ambiguity, undefined behavior?", "Id": "29513572", "Score": "20", "Body": "<p>Today I came across some code that exhibits different behavior on\nclang++ (3.7-git), g++ (4.9.2) and Visual Studio 2013. After some reduction\nI came up with this snippet which highlights the issue:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint len_ = -1;\n\nchar *buffer(int size_)\n{\n    cout &lt;&lt; \"len_: \" &lt;&lt; len_ &lt;&lt; endl;\n    return new char[size_];\n}\n\nint main(int argc, char *argv[])\n{\n    int len = 10;\n    buffer(len+1)[len_ = len] = '\\0';\n    cout &lt;&lt; \"len_: \" &lt;&lt; len_ &lt;&lt; endl;\n}\n</code></pre>\n<p>g++ (4.9.2) gives this output:</p>\n<pre><code>len_: -1\nlen_: 10\n</code></pre>\n<p>So g++ evaluates the argument to buffer, then buffer(..) itself and after that it evaluates the index argument to the array operator. Intuitively this makes sense to me.</p>\n<p>clang (3.7-git) and Visual Studio 2013 both give:</p>\n<pre><code>len_: 10\nlen_: 10\n</code></pre>\n<p>I suppose clang and VS2013 evaluates everything possible before it decends into buffer(..). This makes less intuitive sense to me.</p>\n<p>I guess the gist of my question is whether or not this is a clear case of undefined behavior.</p>\n<p>Edit: Thanks for clearing this up, and unspecified behavior is the term I should have used.</p>\n", "Tags": "<c++><unspecified-behavior>", "OwnerUserId": "4763638", "AnswerCount": "2"}});