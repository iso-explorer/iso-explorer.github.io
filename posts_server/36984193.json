post_cb({"bq_ids": {"n4140": {"so_36984193_36985664_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 121}}, "n3337": {"so_36984193_36985664_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 116}}, "n4659": {"so_36984193_36985664_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 125}}}, "36985664": {"Id": "36985664", "PostTypeId": "2", "Body": "<p>A <em>pattern</em> is defined in the standard under <a href=\"http://eel.is/c++draft/temp.variadic#4\" rel=\"nofollow\">[temp.variadic]/4</a>: (via <a href=\"https://stackoverflow.com/users/2756719/t-c\">@t.c.</a>)</p>\n<blockquote>\n<p id=\"so_36984193_36985664_0\">A <em>pack expansion</em> consists of a <em>pattern</em> and an ellipsis, the instantiation of which produces zero or more instantiations of the pattern in a list (described below). The form of the pattern depends on the context in which the expansion occurs. Pack expansions can occur in the following contexts:</p>\n<ul>\n<li>In a function parameter pack ([<a href=\"http://eel.is/c++draft/dcl.fct\" rel=\"nofollow\">dcl.fct</a>]); the pattern is the <a href=\"http://eel.is/c++draft/dcl.fct#parameter-declaration\" rel=\"nofollow\"><em>parameter-declaration</em></a> without the ellipsis.</li>\n<li>In a template parameter pack that is a pack expansion ([<a href=\"http://eel.is/c++draft/temp.param\" rel=\"nofollow\">temp.param</a>]):\n  \n  <ul>\n<li>if the template parameter pack is a <a href=\"http://eel.is/c++draft/dcl.fct#parameter-declaration\" rel=\"nofollow\"><em>parameter-declaration</em></a>; the pattern is the <a href=\"http://eel.is/c++draft/dcl.fct#parameter-declaration\" rel=\"nofollow\"><em>parameter-declaration</em></a> without the ellipsis;</li>\n<li>if the template parameter pack is a <a href=\"http://eel.is/c++draft/temp.param#type-parameter\" rel=\"nofollow\"><em>type-parameter</em></a> with a <a href=\"http://eel.is/c++draft/temp#template-parameter-list\" rel=\"nofollow\"><em>template-parameter-list</em></a>; the pattern is the corresponding <a href=\"http://eel.is/c++draft/temp.param#type-parameter\" rel=\"nofollow\"><em>type-parameter</em></a> without the ellipsis. </li>\n</ul></li>\n<li>In an <a href=\"http://eel.is/c++draft/dcl.init#initializer-list\" rel=\"nofollow\"><em>initializer-list</em></a> ([<a href=\"http://eel.is/c++draft/dcl.fct\" rel=\"nofollow\">dcl.init</a>]); the pattern is an <a href=\"http://eel.is/c++draft/dcl.init#initializer-clause\" rel=\"nofollow\"><em>initializer-clause</em></a>.</li>\n<li>In a <a href=\"http://eel.is/c++draft/class.derived#base-specifier-list\" rel=\"nofollow\"><em>base-specifier-list</em></a> (Clause [<a href=\"http://eel.is/c++draft/class.derived\" rel=\"nofollow\">class.derived</a>]; the pattern is a <a href=\"http://eel.is/c++draft/class.derived#base-specifier\" rel=\"nofollow\"><em>base-specifier</em></a>.</li>\n<li>In a <a href=\"http://eel.is/c++draft/class.base.init#mem-initializer-list\" rel=\"nofollow\"><em>mem-initializer-list</em></a> ([<a href=\"http://eel.is/c++draft/class.base.init\" rel=\"nofollow\">class.base.init</a>]) for a <a href=\"http://eel.is/c++draft/class.base.init#mem-initializer\" rel=\"nofollow\"><em>mem-initializer</em></a> whose <a href=\"http://eel.is/c++draft/class.base.init#mem-initializer-id\" rel=\"nofollow\"><em>mem-initializer-id</em></a> denotes a base class; the pattern is the <a href=\"http://eel.is/c++draft/class.base.init#mem-initializer\" rel=\"nofollow\"><em>mem-initializer</em></a>.</li>\n<li>In a <a href=\"http://eel.is/c++draft/temp.names#template-argument-list\" rel=\"nofollow\"><em>template-argument-list</em></a> ([<a href=\"http://eel.is/c++draft/temp.arg\" rel=\"nofollow\">temp.arg</a>]); the pattern is a <a href=\"http://eel.is/c++draft/temp.names#template-argument\" rel=\"nofollow\"><em>template-argument</em></a>.</li>\n<li>In a <a href=\"http://eel.is/c++draft/except.spec#dynamic-exception-specification\" rel=\"nofollow\"><em>dynamic-exception-specification</em></a> ([<a href=\"http://eel.is/c++draft/except.spec\" rel=\"nofollow\">except.spec</a>]); the pattern is a <a href=\"http://eel.is/c++draft/dcl.name#type-id\" rel=\"nofollow\"><em>type-id</em></a>.</li>\n<li>In an <a href=\"http://eel.is/c++draft/dcl.attr.grammar#attribute-list\" rel=\"nofollow\"><em>attribute-list</em></a> ([<a href=\"http://eel.is/c++draft/dcl.attr.grammar\" rel=\"nofollow\">dcl.attr.grammar</a>]); the pattern is an <a href=\"http://eel.is/c++draft/dcl.attr.grammar#attribute\" rel=\"nofollow\"><em>attribute</em></a>.</li>\n<li>In an <a href=\"http://eel.is/c++draft/dcl.attr.grammar#alignment-specifier\" rel=\"nofollow\"><em>alignment-specifier</em></a> ([<a href=\"http://eel.is/c++draft/dcl.align\" rel=\"nofollow\">dcl.align</a>]); the pattern is the <a href=\"http://eel.is/c++draft/dcl.attr.grammar#alignment-specifier\" rel=\"nofollow\"><em>alignment-specifier</em></a> without the ellipsis.</li>\n<li>In a <a href=\"http://eel.is/c++draft/expr.prim.lambda#capture-list\" rel=\"nofollow\"><em>capture-list</em></a> ([<a href=\"http://eel.is/c++draft/expr.prim.lambda\" rel=\"nofollow\">expr.prim.lambda</a>]); the pattern is a <a href=\"http://eel.is/c++draft/expr.prim.lambda#capture\" rel=\"nofollow\"><em>capture</em></a>.</li>\n<li>In a <code>sizeof...</code> expression ([<a href=\"http://eel.is/c++draft/expr.sizeof\" rel=\"nofollow\">expr.sizeof</a>]); the pattern is an <a href=\"http://eel.is/c++draft/lex.name#identifier\" rel=\"nofollow\"><em>identifier</em></a>.</li>\n<li>In a <a href=\"http://eel.is/c++draft/expr.prim.fold#fold-expression\" rel=\"nofollow\"><em>fold-expression</em></a> ([<a href=\"http://eel.is/c++draft/expr.prim.fold\" rel=\"nofollow\">expr.prim.fold</a>]); the pattern is the <a href=\"http://eel.is/c++draft/expr.cast#cast-expression\" rel=\"nofollow\"><em>cast-expression</em></a> that contains an unexpanded parameter pack. </li>\n</ul>\n</blockquote>\n<p>The above quote from the standard draft talks about what <em>part of the grammar</em> described in the links is the \"pattern\" that is being expanded.  To understand it, you need to know how the C++ grammar is described and the exceptions about how it is used in the standard text itself; however, if you have basic BNF knowledge and a bit of patience, you can work it out.  The names are often useful as well.</p>\n<hr>\n<p>However, you can use <code>...</code> and mostly understand it without going nearly that deep.</p>\n<p>The <em>general</em> rule is simple: you have some bit of C++ grammar (called the <em>pattern</em>) parsed in the usual way, where a pack of types is treated like a single type, and a pack of literals is treated like a single literal.  Then, at the end of it, you have a <em>...</em> expander.  It then takes all of the unexpanded packs in the bit of C++ grammar immediately before (the <em>pattern</em>) and expands it.</p>\n<p>How this works in each context is <em>different</em>; it isn't just a macro expansion.  The contexts in which <code>...</code> is valid are enumerated above; the effects of the expansion are listed in the standard at each point where it is valid.</p>\n<p>In the most mundane use cases of <code>...</code>, the pattern is an expression, and the expression gets expanded as-if it was each copy separated by <code>,</code> (not <code>operator,</code>, but the other \"normal\" one), usually in a context where a list of things is expected (function call, initializer list, etc).</p>\n<p>There are function parameter declaration contexts (where <code>...</code> both expands the types of the function parameters, and introduces a new pack of the paramter names), in template parameter lists (where it introduces a pack usually), etc.</p>\n<p><code>sizeof...</code> is a bit strange: for <code>sizeof...</code> it counts how many elements are in the pack passed in the <code>()</code>.  This works differently, as the <code>...</code> does not apply to the \"structure on the left\".</p>\n<p>For <code>alignas(X...)</code>, we end up with <code>alignas(X@0), alignas(X@1), ...</code> (where <code>@0</code> is my pseudocode for the first element of the pack), as <code>alignas(X@0, X@1, ...)</code> is not valid C++ (again @T.C. in comments below).</p>\n<p>For inheritance, it creates a set of base classes.  For mem-initializer-lists, it lets you pass ctor arguments to said pack of base classes.  For lambdas, it gives you limited capture of packs (not full on expression capture with expansion last I checked).</p>\n<p>The pattern is the thing expanded.  Importantly, an expanded pattern is not expanded by another pattern expander: so <code>std::array&lt; Ts, sizeof...(Ts) &gt;...</code> is a pack of arrays of various types, each one with a number of elements determined by how big the pack itself is.  <code>sizeof...(Ts)</code> \"counts as expanding\" the <code>Ts</code> in its <code>()</code>, even though <code>...</code> isn't to \"its right\", because the language defines the <code>Ts</code> in the <code>()</code> as the pattern that is expanded by the <code>...</code>.</p>\n<p>The pattern in the general case cannot be called an expression, because types are not expressions, and some patterns are expressions (or at least expand into lists of expressions).  And in some cases, <code>...</code> expands a type-pattern into an expanded package of types (like in the throw expression).</p>\n<p>The general rule, that you treat <code>...</code> as expanding the thing on the left in an appropriate way in the local context, works for almost everything except <code>sizeof...</code> (which is a magical operator that tells you how many elements are in a parameter pack).  It is only going to be in corner cases where this doesn't produce a decent model.  And in my experience, at worse it will result in code that doesn't compile when you think it should; you can learn workarounds in that case.  Like, remembering that a bare statement \"has no local context\", so you cannot do <code>a = std::get&lt;Is&gt;(tup))...;</code>, but rather the workaround <code>(void)(int[]){0,(a = std::get&lt;Is&gt;(tup)),0)...};</code> (might have to typedef that <code>int[]</code>) where we provide a context (creating an array) for the pack expansion to work in.</p>\n<p>C++1z's fold expressions are another quirky spot where <code>...</code> does not apply on the left; here, they wanted to have an expansion of a binary operator, so \"on the left\" doesn't make as much sense as the usual \"unary\" expansion.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2016-05-02T16:02:17.647", "Score": "7", "CreationDate": "2016-05-02T15:06:13.150", "ParentId": "36984193", "CommentCount": "4", "OwnerUserId": "1774667", "LastEditDate": "2016-05-02T16:02:17.647"}, "36984683": {"Id": "36984683", "PostTypeId": "2", "Body": "<p>The pattern is defined by its association with the <code>...</code> expansion syntax. So <code>validate(ts)</code> alone is just a fragment of meaningless text. But <code>validate(ts)...</code> makes the <code>validate(ts)</code> part the pattern of the expansion. So it's a matter of how <code>...</code> affects the associated code.</p>\n<p>Usually, unpack syntax designates that the stuff to the left of the <code>...</code> is the pattern. With C++17's fold expressions, this becomes a bit more complex. But generally speaking, if you want to know what the pattern is, find the <code>...</code>, and look at the expression immediately to the left of it.</p>\n<p>The specific limitations on what can be in the pattern depend entirely on where the expansion is taking place and what kind it of pack is involved (type vs. non-type, etc). The pattern needs to be whatever would be legal code for whatever context it is expanded within.</p>\n", "LastActivityDate": "2016-05-02T14:17:32.560", "CommentCount": "0", "CreationDate": "2016-05-02T14:17:32.560", "ParentId": "36984193", "Score": "0", "OwnerUserId": "734069"}, "36984193": {"ViewCount": "224", "Body": "<p>I understand that when an ellipsis (...) occurs to the right of a pattern containing a parameter pack, the pattern is expanded once for each parameter in the pack. However, though I have been able to find isolated examples of patterns with their expansion, I have been unable to find a definition of what constitutes a pattern. From what I can see, whitespace plays no role in the definition of the pattern, but parentheses do. For instance, in this example:</p>\n<pre><code>template&lt;typename ... Ts&gt;\nvoid func(Ts)\n{\n    do_something(validate(Ts)...);\n}\n</code></pre>\n<p>the <code>do_something</code> line would be expanded to:</p>\n<pre><code>    do_something(validate(var1), validate(var2), validate(var3))\n</code></pre>\n<p>if <code>Ts</code> happened to represent three variables. By contrast:</p>\n<pre><code>    do_something(validate(Ts...));\n</code></pre>\n<p>would be expanded to:</p>\n<pre><code>    do_something(validate(var1, var2, var3));\n</code></pre>\n<p>So clearly parentheses have something to do with determining where the pattern begins and ends. I can also see that whitespace does not. But that only gets me so far. I'd like to know exactly what constitutes a pattern, and how it will be expanded. I tried searching through the C++ Standard, but found too many instances of \"parameter pack\" to make that effective. Could someone please give me a definition of \"pattern\", or a link to a definition, or both?</p>\n<p>UPDATE: To limit the scope of my question, I'd like to focus on the case where a pattern occurs within a function call. I've edited the title accordingly. Sorry I didn't make that clear from the beginning.</p>\n", "AcceptedAnswerId": "36985664", "Title": "Definition of \"pattern\" for parameter pack expansion, especially within a function call", "CreationDate": "2016-05-02T13:54:50.817", "Id": "36984193", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-02T15:41:13.797", "LastEditorUserId": "523124", "LastActivityDate": "2016-05-02T16:02:17.647", "Score": "5", "OwnerUserId": "523124", "Tags": "<c++><c++11>", "AnswerCount": "2"}});