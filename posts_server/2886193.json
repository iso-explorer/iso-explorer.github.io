post_cb({"2886193": {"ViewCount": "1721", "Body": "<p>In a typical implementation of the <em>Visitor</em> pattern, the class must account for all variations (descendants) of the base class.  There are many instances where the same method content in the visitor is applied to the different methods.  A templated virtual method would be ideal in this case, but for now, this is not allowed.  </p>\n<h2>So, can templated methods be used to resolve virtual methods of the parent class?</h2>\n<p>Given (the foundation):</p>\n<pre><code>struct Visitor_Base; // Forward declaration.\n\nstruct Base\n{\n  virtual accept_visitor(Visitor_Base&amp; visitor) = 0;\n};\n\n// More forward declarations\nstruct Base_Int;\nstruct Base_Long;\nstruct Base_Short;\nstruct Base_UInt;\nstruct Base_ULong;\nstruct Base_UShort;\n\nstruct Visitor_Base\n{\n  virtual void operator()(Base_Int&amp; b) = 0;\n  virtual void operator()(Base_Long&amp; b) = 0;\n  virtual void operator()(Base_Short&amp; b) = 0;\n  virtual void operator()(Base_UInt&amp; b) = 0;\n  virtual void operator()(Base_ULong&amp; b) = 0;\n  virtual void operator()(Base_UShort&amp; b) = 0;\n};\n\nstruct Base_Int : public Base\n{\n  void accept_visitor(Visitor_Base&amp; visitor)\n  {\n     visitor(*this);\n  }\n};\n\nstruct Base_Long : public Base\n{\n  void accept_visitor(Visitor_Base&amp; visitor)\n  {\n     visitor(*this);\n  }\n};\n\nstruct Base_Short : public Base\n{\n  void accept_visitor(Visitor_Base&amp; visitor)\n  {\n     visitor(*this);\n  }\n};\n\nstruct Base_UInt : public Base\n{\n  void accept_visitor(Visitor_Base&amp; visitor)\n  {\n     visitor(*this);\n  }\n};\n\nstruct Base_ULong : public Base\n{\n  void accept_visitor(Visitor_Base&amp; visitor)\n  {\n     visitor(*this);\n  }\n};\n\nstruct Base_UShort : public Base\n{\n  void accept_visitor(Visitor_Base&amp; visitor)\n  {\n     visitor(*this);\n  }\n};\n</code></pre>\n<p>Now that the foundation is laid, here is where the kicker comes in (templated methods):  </p>\n<pre><code>struct Visitor_Cout : public Visitor_Base\n{\n  template &lt;class Receiver&gt;\n  void operator() (Receiver&amp; r)\n  {\n     std::cout &lt;&lt; \"Visitor_Cout method not implemented.\\n\";\n  }\n};\n</code></pre>\n<p>Intentionally, <code>Visitor_Cout</code> does not contain the keyword <code>virtual</code> in the method declaration.  All the other attributes of the method signatures match the parent declaration (or perhaps <em>specification</em>).  </p>\n<p>In the big picture, this design allows developers to implement common visitation functionality that differs only by the type of the target object (the object receiving the visit).  The implementation above is my suggestion for alerts when the derived visitor implementation hasn't implement an optional method.  </p>\n<h2>Is this legal by the C++ specification?</h2>\n<p>(I don't trust when some says that it works with compiler <em>XXX</em>.  This is a question against the general language.)</p>\n", "AcceptedAnswerId": "2886229", "Title": "Visitor and templated virtual methods", "CreationDate": "2010-05-21T23:16:16.800", "Id": "2886193", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-02-14T00:04:53.753", "LastEditorUserId": "634576", "LastActivityDate": "2016-02-14T00:04:53.753", "Score": "9", "OwnerUserId": "225074", "Tags": "<c++><templates><operator-overloading><visitor><virtual-method>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_2886193_2886218_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 113}}, "n3337": {"so_2886193_2886218_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 108}}, "n4659": {"so_2886193_2886218_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 117}}}, "2886229": {"Id": "2886229", "PostTypeId": "2", "Body": "<p>oh, I see what you're after.  Try something like this:</p>\n<pre><code>\n\ntemplate &lt; typename Impl &gt;\nstruct Funky_Visitor_Base : Visitor_Base\n{\n  // err...\n  virtual void operator()(Base_Int&amp; b) { Impl::apply(b) }\n  virtual void operator()(Base_Long&amp; b) { Impl::apply(b) }\n  virtual void operator()(Base_Short&amp; b) { Impl::apply(b) }\n  virtual void operator()(Base_UInt&amp; b) { Impl::apply(b) }\n  virtual void operator()(Base_ULong&amp; b) { Impl::apply(b) }\n\n  // this actually needs to be like so:\n  virtual void operator()(Base_UShort&amp; b)\n  {\n    static_cast&lt;impl *const&gt;(this)-&gt;apply(b) \n  }\n};\n\nstruct weird_visitor : Funky_Visitor_Base&lt;weird_visitor&gt;\n{\n  // Omit this if you want the compiler to throw a fit instead of runtime error.\n  template &lt; typename T &gt;\n  void apply(T &amp; t)\n  {\n    std::cout &lt;&lt; \"not implemented.\";\n  }\n\n  void apply(Base_UInt &amp; b) { std::cout &lt;&lt; \"Look what I can do!\"; }\n};\n</code></pre>\n<p>That said, you should look into the acyclic visitor pattern.  It has misunderstood visitors built into the framework so you don't have to implement functions for stuff you'll never call.</p>\n<p>Funny thing is that I actually used something very similar to this to build an acyclic visitor for a list of types.  I applied a metafunction that basically builds Funky_Visitor_Base and turns an operator (something with an apply() like I show) into a visitor for that complete list.  The objects are reflective so the apply() itself is actually a metafunction that builds based on whatever type it's hitting.  Pretty cool and weird actually.</p>\n", "LastEditorUserId": "301883", "LastActivityDate": "2010-05-21T23:51:27.747", "Score": "6", "CreationDate": "2010-05-21T23:28:37.270", "ParentId": "2886193", "CommentCount": "3", "OwnerUserId": "301883", "LastEditDate": "2010-05-21T23:51:27.747"}, "2886218": {"Id": "2886218", "PostTypeId": "2", "Body": "<p>In your derived visitor class, <code>Visitor_Cout</code>, the <code>operator()</code> template does not override the <code>operator()</code> in the <code>Visitor_Base</code>.  Per the C++03 standard (14.5.2/4):</p>\n<blockquote>\n<p id=\"so_2886193_2886218_0\">A specialization of a member function template does not override a virtual function from a base class.  [Example:</p>\n</blockquote>\n<pre><code>class B {\n    virtual void f(int);\n};\n\nclass D : public B {\n    template &lt;class T&gt; void f(T);  // does not override B::f(int)\n    void f(int i) { f&lt;&gt;(i); }      // overriding function that calls\n                                   // the template instantiation\n};\n</code></pre>\n<blockquote>\n<p id=\"so_2886193_2886218_1\">\u2014end example]</p>\n</blockquote>\n", "LastActivityDate": "2010-05-21T23:24:34.960", "CommentCount": "0", "CreationDate": "2010-05-21T23:24:34.960", "ParentId": "2886193", "Score": "2", "OwnerUserId": "151292"}});