post_cb({"46794267": {"Id": "46794267", "PostTypeId": "2", "Body": "<p>You can see at <a href=\"http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html\" rel=\"nofollow noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html</a>:</p>\n<blockquote>\n<p id=\"so_46794072_46794267_0\">Second, the \u2018##\u2019 token paste operator has a special meaning when placed between a comma and a variable argument. If you write</p>\n</blockquote>\n<pre><code>#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)\n</code></pre>\n<blockquote>\n<p id=\"so_46794072_46794267_1\">and the variable argument is left out when the eprintf macro is used, then the comma before the \u2018##\u2019 will be deleted. This does not happen if you pass an empty argument, nor does it happen if the token preceding \u2018##\u2019 is anything other than a comma.</p>\n</blockquote>\n<pre><code>eprintf (\"success!\\n\")\n \u2192 fprintf(stderr, \"success!\\n\");\n</code></pre>\n<blockquote>\n<p id=\"so_46794072_46794267_2\">The above explanation is ambiguous about the case where the only macro parameter is a variable arguments parameter, as it is meaningless to try to distinguish whether no argument at all is an empty argument or a missing argument. CPP retains the comma when conforming to a specific C standard. Otherwise the comma is dropped as an extension to the standard.</p>\n</blockquote>\n<p>So, (unless appropriate extension used) <code>OUTPUT_ARGS_COUNT()</code> is counted as 1 empty argument (comma kept with <code>##__VA_ARGS__</code>).</p>\n", "LastActivityDate": "2017-10-17T15:53:14.990", "CommentCount": "6", "CreationDate": "2017-10-17T15:53:14.990", "ParentId": "46794072", "Score": "2", "OwnerUserId": "2684539"}, "bq_ids": {"n4140": {"so_46794072_46794610_0": {"length": 17, "quality": 1.0, "section_id": 514}}, "n3337": {"so_46794072_46794610_0": {"length": 17, "quality": 1.0, "section_id": 505}}, "n4659": {"so_46794072_46794610_0": {"length": 17, "quality": 1.0, "section_id": 535}}}, "46794072": {"ViewCount": "51", "Body": "<p><a href=\"https://stackoverflow.com/questions/11761703/overloading-macro-on-number-of-arguments/11763277#11763277\">Overloading Macro on Number of Arguments</a></p>\n<p><a href=\"https://codecraft.co/2014/11/25/variadic-macros-tricks/\" rel=\"nofollow noreferrer\">https://codecraft.co/2014/11/25/variadic-macros-tricks/</a></p>\n<p>I've been looking at the two links above, trying to get the following code to work:</p>\n<pre><code>#define _GET_NUMBER(_0, _1, _2, _3, _4, _5, NAME, ...) NAME\n#define OUTPUT_ARGS_COUNT(...) _GET_NUMBER(_0, ##__VA_ARGS__, 5, 4, 3, 2, 1, 0)\n\n...\n\ncout &lt;&lt; OUTPUT_ARGS_COUNT(\"HelloWorld\", 1.2) &lt;&lt; endl;\ncout &lt;&lt; OUTPUT_ARGS_COUNT(\"HelloWorld\") &lt;&lt; endl;\ncout &lt;&lt; OUTPUT_ARGS_COUNT() &lt;&lt; endl;\n</code></pre>\n<p>This compiles, runs, and gives the following output:</p>\n<pre><code>2\n1\n1\n</code></pre>\n<p>I can not for the life of me figure out why the call OUTPUT_ARGS_COUNT() is giving me 1 instead of 0.  I have an ok understanding of the code I'm trying to use, but it's a tad greek to me still so I guess it's possible that I'm not applying something correctly despite the fact I literally copied and pasted the example code from the link on stack overflow.</p>\n<p>I'm compiling using g++ 5.4.0 20160609.</p>\n<p>Any ideas or additional resources you can point me to would be greatly appreciated.</p>\n", "AcceptedAnswerId": "46794610", "Title": "Why won't my variadic macro accept no arguments correctly?", "CreationDate": "2017-10-17T15:43:21.320", "Id": "46794072", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-10-17T16:11:23.777", "Score": "1", "OwnerUserId": "2146208", "Tags": "<c++><c><macros><g++><variadic-macros>", "AnswerCount": "2"}, "46794610": {"Id": "46794610", "PostTypeId": "2", "Body": "<p>The C standard specifies</p>\n<blockquote>\n<p id=\"so_46794072_46794610_0\">If the identifier-list in the macro definition does not end with an ellipsis, [...]. Otherwise, <strong><em>there shall be more arguments in the invocation than there are parameters in the macro definition (excluding the ...)</em></strong></p>\n</blockquote>\n<p>(<a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.10.3p4\" rel=\"nofollow noreferrer\">C2011 6.10.3/4</a>; emphasis added)</p>\n<p>C++11 contains language to the same effect in paragraph 16.3/4.</p>\n<p>In both cases, then, if your macro invocation were interpreted to have zero arguments then your program would be non-conforming.  On the other hand, the preprocessor does recognize and support empty macro arguments -- that is, arguments consisting of zero preprocessing tokens.  In principle, then, there is an ambiguity here between no argument and a single empty argument, but in practice, only the latter interpretation results in a conforming program.</p>\n<p>That g++ opts for the latter interpretation (the other answer quotes its documentation to that effect) is thus reasonable and appropriate, but it is not safe to rely upon it if you want your code to be portable.  A compiler that takes the alternative interpretation would behave differently, possibly by providing the behavior you expected, but also possibly by rejecting the code.</p>\n", "LastActivityDate": "2017-10-17T16:11:23.777", "CommentCount": "0", "CreationDate": "2017-10-17T16:11:23.777", "ParentId": "46794072", "Score": "1", "OwnerUserId": "2402272"}});