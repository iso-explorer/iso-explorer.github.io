post_cb({"27464124": {"ParentId": "27463785", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_27463785_27464124_0\">Why is the compiler forbidding my original code?</p>\n</blockquote>\n<p>Because it is forbidden by the Standard:</p>\n<blockquote>\n<p id=\"so_27463785_27464124_1\">8.5.3 References 5<br>\n  ...<br>\n  Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be\n  const), or the reference shall be an rvalue reference.<br>\n  [ Example:<br>\n  double&amp; rd2 = 2.0; // error: not an lvalue and reference not const<br>\n  ...</br></br></br></br></br></p>\n</blockquote>\n<p>'</p>\n<blockquote>\n<p id=\"so_27463785_27464124_2\">What is it guarding against?</p>\n</blockquote>\n<p>Inadvertently modifying an object that is going to be destructed after the function call.</p>\n<blockquote>\n<p id=\"so_27463785_27464124_3\">What is it about each of the three workarounds above that satisfies the compiler?</p>\n</blockquote>\n<p><code>1</code> Creates a named object and <code>3</code> a copy.<br>\n<code>2</code> Works because the lifetime of the object is simply extended, and changes to it are prevented at the same time.</br></p>\n<blockquote>\n<p id=\"so_27463785_27464124_4\">What would MSVC allow it, but not g++?</p>\n</blockquote>\n<p>Because it is a language extension. Disable it by going to <code>Property Pages-&gt;C/C++-&gt;Language-&gt;Disable Language Extensions</code> and you'll get an error.</p>\n", "OwnerUserId": "1707560", "PostTypeId": "2", "Id": "27464124", "Score": "5", "CreationDate": "2014-12-13T22:06:22.143", "LastActivityDate": "2014-12-13T22:06:22.143"}, "27463785": {"CommentCount": "5", "AcceptedAnswerId": "27463830", "PostTypeId": "1", "LastEditorUserId": "104458", "CreationDate": "2014-12-13T21:26:26.117", "LastActivityDate": "2017-05-08T09:02:49.957", "LastEditDate": "2017-04-11T15:02:50.100", "ViewCount": "4934", "FavoriteCount": "3", "Title": "Can't pass temporary object as reference", "Id": "27463785", "Score": "12", "Body": "<p>This is a very minimal example:</p>\n<pre><code>class Foo\n{\npublic:\n    Foo(int x) {};\n};\n\nvoid ProcessFoo(Foo&amp; foo)\n{\n}\n\nint main()\n{\n    ProcessFoo(Foo(42));\n    return 0;\n}\n</code></pre>\n<p>The above compiles fine on Visual Studio, but generates an error on Linux and Mac.</p>\n<p>Compiling the above generates this:</p>\n<pre><code>$ g++ -std=c++11 -c newfile.cpp\n\nnewfile.cpp: In function \u2018int main()\u2019:\nnewfile.cpp:23:23: error: invalid initialization of non-const reference of type \u2018Foo&amp;\u2019 from an rvalue of type \u2018Foo\u2019\n     ProcessFoo(Foo(42));\n                       ^\nnewfile.cpp:14:6: note: in passing argument 1 of \u2018void ProcessFoo(Foo&amp;)\u2019\n void ProcessFoo(Foo&amp; foo)\n</code></pre>\n<p>I've found three workarounds:</p>\n<ol>\n<li>Avoid the use of an inline a temp variable for the invocation of ProcessFoo.</li>\n</ol>\n<p>Like this:</p>\n<pre><code>Foo foo42(42);\nProcessFoo(foo42);\n</code></pre>\n<ol start=\"2\">\n<li><p>ProcessFoo takes a const reference: <code>void ProcessFoo(const Foo&amp; foo)</code></p></li>\n<li><p>ProcessFoo just lets Foo get passed by value. <code>void ProcessFoo(Foo foo)</code></p></li>\n</ol>\n<p>Why is the compiler forbidding my original code? (What is it guarding against)?  What is it about each of the three workarounds above that satisfies the compiler?  What would MSVC allow it, but not g++?</p>\n", "Tags": "<c++><visual-c++><c++11>", "OwnerUserId": "104458", "AnswerCount": "4"}, "27464123": {"ParentId": "27463785", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_27463785_27464123_0\">Why is the compiler forbidding my original code?</p>\n</blockquote>\n<p>MSVC has an extension that allows temporaries to bind to non-const lvalue-references. Of course this isn't a standard-conforming feature so I would stay away from it to be portable. For example, it doesn't work with the latest versions of GCC and Clang as you've seen.</p>\n<blockquote>\n<p id=\"so_27463785_27464123_1\">What is it about each of the three workarounds above that satisfies the compiler? </p>\n</blockquote>\n<p>Back in C++03, expressions could only be lvalues or rvalues. References could only designate the \"lvalueness\" of an object, and so it was used with the intention of aliasing a preexisting object. By contrast, rvalues don't exist beyond the expression in which they appear. Also, the end result of references was normally to copy or modify the object, and it doesn't make much sense to the language to modify an rvalue like <code>55</code> for example.</p>\n<p>The rules allow you to bind an rvalue to a lvalue-reference to const, in which case the temporary's lifetime is extended to the lifetime of the reference. When you take an object by value the object is copied.</p>\n<p>With C++11 we have rvalue-references and xvalues which were made for the purpose of exchanging ownership. With this is lessens the usefulness of lvalue-references to const. Moreover, taking by-value causes a move if it is an rvalue.</p>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "27464123", "Score": "2", "CreationDate": "2014-12-13T22:06:18.967", "LastActivityDate": "2014-12-13T22:06:18.967"}, "27463830": {"ParentId": "27463785", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>By design, C++ only allows a temporary to be passed to a const reference, value, or rvalue reference.  The idea is that a function taking a non-const reference parameter is stating that it wants to modify the parameter and allowing it to go back to the caller.  Doing so with a temporary is meaningless and most likely an error.</p>\n<p>And I don't know what version of g++ you're running.  It doesn't work here: <a href=\"http://coliru.stacked-crooked.com/a/43096cb398cbc973\" rel=\"noreferrer\">http://coliru.stacked-crooked.com/a/43096cb398cbc973</a></p>\n", "OwnerUserId": "1738399", "LastEditorUserId": "1738399", "LastEditDate": "2014-12-13T21:40:09.220", "Id": "27463830", "Score": "6", "CreationDate": "2014-12-13T21:31:27.513", "LastActivityDate": "2014-12-13T21:40:09.220"}, "27463850": {"ParentId": "27463785", "CommentCount": "1", "Body": "<p>Once you declared the prototype for ProcessFoo as</p>\n<pre><code>void ProcessFoo(Foo&amp; foo)\n</code></pre>\n<p>You are conveying your intent as the formal parameter \"foo\" is subject to modification as it is not being passed by const &amp;.</p>\n<p>At the call-site,</p>\n<pre><code>ProcessFoo(Foo(42));\n</code></pre>\n<p>Foo(42) is creating a temporary stack object that is not modifiable. It is okay to pass-by-value or pass-by-ref-to-const to a method.</p>\n<p>As you listed yourself, satisfying those constraints, makes the compiler happy.</p>\n<ol>\n<li>is giving you an object that is not compiler generated and is under your control. </li>\n<li>Informs the compiler that the method guarantees const-ness of the object.</li>\n<li>Informs the compiler that this (temporary) object is passed by value and hence no issues.</li>\n</ol>\n", "OwnerUserId": "1340410", "PostTypeId": "2", "Id": "27463850", "Score": "2", "CreationDate": "2014-12-13T21:34:04.080", "LastActivityDate": "2014-12-13T21:34:04.080"}, "bq_ids": {"n4140": {"so_27463785_27464124_1": {"section_id": 3321, "quality": 0.6190476190476191, "length": 13}}, "n3337": {"so_27463785_27464124_1": {"section_id": 3191, "quality": 0.6190476190476191, "length": 13}}, "n4659": {"so_27463785_27464124_1": {"section_id": 4087, "quality": 0.6190476190476191, "length": 13}}}});