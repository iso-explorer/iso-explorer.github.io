post_cb({"32322613": {"ParentId": "32322255", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>In C++14, <code>auto</code> is not allowed in template arguments, whether in a lambda or not. Clang and Visual Studio are both right to reject this code.</p>\n<p>The C++14 standard reference is [dcl.spec.auto]. The <code>auto</code> specifier is allowed in the following contexts:</p>\n<ul>\n<li>In the <em>decl-specifier-seq</em> of a function declarator (<em>e.g.</em>, <code>auto f();</code>) (paragraph 2)</li>\n<li>In a <em>conversion-function-id</em> (<em>i.e.,</em> an <code>operator auto()</code> in a class) (paragraph 2)</li>\n<li>In the <em>trailing-return-type</em> of a function declarator (<em>e.g.</em>, <code>auto f() -&gt; auto;</code>) (paragraph 2)</li>\n<li>In the <em>decl-specifier-seq</em> of a <em>parameter-declaration</em> (as one of the <em>decl-specifiers</em>) of a lambda (paragraph 3); -this is what allows generic lambdas to exist-</li>\n<li>In the declaration of a variable at block scope or namespace scope (paragraph 4)</li>\n<li>In the declaration of a for loop control variable (paragraph 4), including a range-based for loop (paragraph 5)</li>\n<li>In the condition of an <code>if</code> or <code>switch</code> statement or a loop (paragraph 5)</li>\n<li>In a <code>new</code> expression, <em>i.e.,</em> <code>new auto(42)</code> (paragraph 5)</li>\n<li>In the declaration of a static data member in the definition of a class (paragraph 5)</li>\n</ul>\n<p>Finally,</p>\n<blockquote>\n<p id=\"so_32322255_32322613_0\">A program that uses <code>auto</code> or <code>decltype(auto)</code> in a context not explicitly allowed in this section is ill-formed.</p>\n</blockquote>\n<p>Therefore, <code>auto</code> is not allowed in template parameters, since that case isn't enumerated in [dcl.spec.auto].</p>\n<p>I don't know why gcc allows it. It might be related to Concepts Lite, but I don't know if Concepts Lite actually allows this usage. It could just be an unrelated extension that is easy to implement. I assume that</p>\n<pre><code>[](std::pair&lt;auto, auto&gt; value) { /* ... */ }\n</code></pre>\n<p>is translated into</p>\n<pre><code>struct __some_unique_name {\n    template &lt;typename T1, typename T2&gt;\n    auto operator()(std::pair&lt;T1, T2&gt; value) const { /* ... */ }\n    // ...\n};\n</code></pre>\n", "OwnerUserId": "481267", "LastEditorUserId": "893406", "LastEditDate": "2015-09-02T01:35:30.677", "Id": "32322613", "Score": "8", "CreationDate": "2015-09-01T02:26:54.280", "LastActivityDate": "2015-09-02T01:35:30.677"}, "32322255": {"CommentCount": "6", "AcceptedAnswerId": "32322613", "PostTypeId": "1", "LastEditorUserId": "1601448", "CreationDate": "2015-09-01T01:33:49.273", "LastActivityDate": "2015-09-02T01:35:30.677", "LastEditDate": "2015-09-01T02:21:40.720", "ViewCount": "643", "FavoriteCount": "1", "Title": "Is auto in template parameter list in lambdas part of the standard?", "Id": "32322255", "Score": "6", "Body": "<p>Today, I stumbled across the following code snippet:</p>\n<pre><code>#include &lt;utility&gt;\n\nint main()\n{\n\n  auto a = [](std::pair&lt;auto, auto&gt; value)\n  {\n\n  };\n\n  a(std::pair&lt;int, bool&gt;{ 3, true });\n}\n</code></pre>\n<p><a href=\"http://cpp.sh/5p34\">http://cpp.sh/5p34</a></p>\n<p>I have only one question: is this code supported by the standard?</p>\n<p>It compiles in GCC (with <code>-std=c++14</code>), but not clang or Visual Studio 2015 (VC++14).</p>\n<p>This seems like it should be part of the standard because if lambdas should have the same template support as regular functions, then this should be supported.</p>\n<p>This seems to convert to all template types, not just <code>std::pair</code>.</p>\n", "Tags": "<c++><templates><c++11><lambda><type-deduction>", "OwnerUserId": "1601448", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32322255_32322613_0": {"section_id": 5450, "quality": 1.0, "length": 8}, "so_32322255_32324037_1": {"section_id": 5447, "quality": 0.6666666666666666, "length": 10}, "so_32322255_32324037_2": {"section_id": 5445, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_32322255_32322613_0": {"section_id": 5244, "quality": 0.875, "length": 7}}, "n4659": {"so_32322255_32324037_1": {"section_id": 6874, "quality": 0.6666666666666666, "length": 10}, "so_32322255_32322613_0": {"section_id": 6877, "quality": 1.0, "length": 8}, "so_32322255_32324037_2": {"section_id": 6872, "quality": 0.5714285714285714, "length": 4}}}, "32324037": {"ParentId": "32322255", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As far as I can tell this is part of <a href=\"https://github.com/cplusplus/concepts-ts/blob/master/html/concepts.pdf\" rel=\"nofollow noreferrer\">concepts lite</a> and gcc is allowing this as an extension in C++14 similar to the issue in <a href=\"https://stackoverflow.com/q/30665506/1708801\">'auto' not allowed in function prototype with Clang</a> although unlike the previous case using <code>-pedantic</code> does not produce a warning like it should for extensions.</p>\n<p>As far as I can tell the most relevant changes from the concepts lite proposal linked above that allow this are to section <code>7.1.6.4</code> <em>[dcl.spec.auto]</em> and <code>8.3.5</code> <em>[dcl.fct]</em> ; from <code>7.1.6.4</code>:</p>\n<blockquote>\n<p id=\"so_32322255_32324037_0\">Modify paragraph 3 to allow the use of auto within the parameter type of a lambda or function.</p>\n<ol start=\"3\">\n<li><p id=\"so_32322255_32324037_1\">If the auto type-specifier appears <s>as one of the decl-specifiers in the decl-specifier-seq of a parameter-declaration</s> <strong>in a\n  parameter type</strong> of a lambda-expression, the lambda is a generic lambda\n  (5.1.2). [ Example:</p>\n<p id=\"so_32322255_32324037_2\">auto glambda = [](int i, auto a) { return i; }; // OK: a generic lambda</p></li>\n</ol>\n<p id=\"so_32322255_32324037_3\">end example ] <strong>Similarly, if the auto type-specifier appears in a parameter type of a function declaration, the function declaration\n  declares an abbreviated function template (8.3.5). [ Example:</strong></p>\n<pre><code>void f(const auto&amp;, int); // OK: an abbreviated function template\n</code></pre>\n<p id=\"so_32322255_32324037_4\"><strong>\u2014 end example ]</strong></p>\n</blockquote>\n<p>and from <code>8.3.5</code>:</p>\n<blockquote>\n<p id=\"so_32322255_32324037_5\">Add the following paragraphs after paragraph 15.</p>\n<ol start=\"16\">\n<li><p id=\"so_32322255_32324037_6\">An abbreviated function template is a function declaration whose parameter-type-list includes one or more placeholders (7.1.6.4,\n  7.1.6.5). An abbreviated function template is equivalent to a function template (14.5.6) whose template-parameter-list includes one invented\n  templateparameter for each occurrence of a placeholder in the\n  parameter-declaration-clause, in order of appearance. If the\n  placeholder is designated by the auto type-specifier, then the\n  corresponding invented template parameter is a type\n  template-parameter. Otherwise, the placeholder is designated by a\n  constrained-type-specifier, and the corresponding invented parameter\n  matches the type and form of the prototype parameter (?) of the\n  concept designated by the constrainedtype- specifier (14.9.5). The\n  invented template-parameter is a parameter pack if the corresponding\n  parameter-declaration declares a function parameter pack and the type\n  of the parameter contains only one placeholder. If the prototype\n  parameter of the designated concept declares a template parameter\n  pack, the corresponding parameter-declaration shall declare a function\n  parameter pack. The adjusted function parameters of an abbreviated\n  function template are derived from the parameter-declaration-clause by\n  replacing each occurrence of a placeholder with the name of the\n  corresponding invented template-parameter. If the replacement of a\n  placeholder with the name of a template parameter results in an\n  invalid parameter declaration, the program is ill-formed. [ Example:</p>\n<pre><code>template&lt;typename T&gt; class Vec { };\ntemplate&lt;typename T, typename U&gt; class Pair { };\n\nvoid f1(const auto&amp;, auto);\nvoid f2(Vec&lt;auto*&gt;...);\nvoid f3(auto (auto::*)(auto));\n\ntemplate&lt;typename T, typename U&gt;\nvoid f1(const T&amp;, U); // redeclaration of f1(const auto&amp;, auto)\ntemplate&lt;typename... T&gt;\nvoid f2(Vec&lt;T*&gt;...); // redeclaration of f2(Vec&lt;auto*&gt;...)\ntemplate&lt;typename T, typename U, typename V&gt;\nvoid f3(T (U::*)(V)); // redeclaration of f3(auto (auto::*)(auto))\n</code></pre></li>\n</ol>\n<p id=\"so_32322255_32324037_7\">[...]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:29.687", "Id": "32324037", "Score": "2", "CreationDate": "2015-09-01T05:18:27.483", "LastActivityDate": "2015-09-01T05:18:27.483"}});