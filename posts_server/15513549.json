post_cb({"15513639": {"ParentId": "15513549", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This code exhibits undefined behavior from multiple threads. See N3485 27.2.3 [iostreams.threadsafety]/1:</p>\n<blockquote>\n<p id=\"so_15513549_15513639_0\">Concurrent access to a stream object (27.8, 27.9), stream buffer object (27.6), or C Library stream (27.9.2) by multiple threads may result in a data race (1.10) unless otherwise specified (27.4). [ Note: Data races result in undefined behavior (1.10). \u2014end note ]</p>\n</blockquote>\n<p>In the general case, streams are not safe to use across threads. You must protect the stream using a lock, such as <code>std::mutex</code>.</p>\n<p>Note that even if streams were safe to access across threads this code would probably not do what you want. Consider this line:</p>\n<pre><code>myfile &lt;&lt; matchSet.testCase &lt;&lt; \",\" &lt;&lt; corr.match &lt;&lt; corr.editDistance &lt;&lt; \"\\n\";\n</code></pre>\n<p>which is the same as</p>\n<pre><code>myfile &lt;&lt; matchSet.testCase;\nmyfile &lt;&lt; \",\";\nmyfile &lt;&lt; corr.match;\nmyfile &lt;&lt; corr.editDistance;\nmyfile &lt;&lt; \"\\n\";\n</code></pre>\n<p>Note the race condition. Let's say that your implementation's <code>operator&lt;&lt;</code> for streams is synchronized for you by the implementation. You still have a potential race in this outer code. For instance, here is one possible execution of this across 2 threads:</p>\n<pre><code>   Thread 1                              Thread 2\n======================================================================\nmyfile &lt;&lt; matchSet.testCase;\n                                         myfile &lt;&lt; matchSet.testCase;\nmyfile &lt;&lt; \",\";\n                                         myfile &lt;&lt; \",\";\nmyfile &lt;&lt; corr.match;\nmyfile &lt;&lt; corr.editDistance;\nmyfile &lt;&lt; \"\\n\";\n                                         myfile &lt;&lt; corr.match;\n                                         myfile &lt;&lt; corr.editDistance;\n                                         myfile &lt;&lt; \"\\n\";\n</code></pre>\n<p>Instead of getting that to write as a single line, you'll get output from each thread mixed up together, resulting in gibberish.</p>\n", "OwnerUserId": "82320", "LastEditorUserId": "82320", "LastEditDate": "2013-03-20T01:31:02.233", "Id": "15513639", "Score": "2", "CreationDate": "2013-03-20T01:23:02.623", "LastActivityDate": "2013-03-20T01:31:02.233"}, "15513549": {"CommentCount": "0", "ViewCount": "3223", "PostTypeId": "1", "LastEditorUserId": "1452181", "CreationDate": "2013-03-20T01:12:03.530", "LastActivityDate": "2013-03-20T04:38:12.173", "Title": "ofstream shared by mutiple threads - crashes after awhile", "AcceptedAnswerId": "15513639", "LastEditDate": "2013-03-20T04:38:12.173", "Id": "15513549", "Score": "2", "Body": "<p>this function takes a ofstream as a reference, then builds struct packets and threads off the structs with the ofstream to a trie matching class. A stack is returned with n matches in order of match distance. The ofstream, packet, and stack are then passed by reference to a print function that writes the matches to the same output file - waiting for when the ofstream is not in use. The problem is the ofstream crashes after half the matches are written.</p>\n<p>The ofstream, packet, and outfile header</p>\n<pre><code>void Match_Import_Start(Trie &amp; tri)\n{\n    stack&lt;Trie::MatchesT&gt; out;\n    ofstream myfile;\n    Trie::MatchesT matchSet;\n\n    myfile.open(outFile.c_str() );\n    myfile &lt;&lt; \"DESCRIPTION,SUGGESTED.DESCRIPTION,EDIT\" &lt;&lt; \"\\n\"; //write header\n    myfile.close();\n\n    Match_Import (tri, myfile, out, matchSet);\n\n    return;\n}\n</code></pre>\n<p>spawn threads from record list</p>\n<pre><code>void Match_Import(Trie &amp;tri, ofstream &amp;myfile, stack&lt;Trie::MatchesT&gt; out, Trie::MatchesT matchSet)\n{   \n    out=parse_CSV_file(timeFile); //read in records\n\n    settingT x;\n\n    x.score=0;\n\n    boost::thread_group tgroup; //http://stackoverflow.com/questions/8744279/create-threads-in-a-loop\n    while (!out.empty() ) {\n        matchSet=out.top();\n        out.pop();\n\n        tgroup.create_thread(boost::bind( MaxDistanceCorrections, boost::ref(tri), matchSet, boost::ref(myfile), boost::ref(x) ) );\n    }\n    tgroup.join_all();\n\n    return;\n}\n</code></pre>\n<p>check for valid return from match</p>\n<pre><code>void MaxDistanceCorrections(Trie &amp; tri, Trie::MatchesT matchSet, ofstream &amp;myfile, settingT &amp;x)\n{\n    if (!matchSet.candidateStack.empty() ) ) {\n        matchSet.candidateStack.sort(compareCorrMain);\n        PrintCorrections(tri, matchSet, myfile, x);\n        return;\n\n    } else {        \n        tri.suggest(matchSet); //send out to trie match\n\n         if (matchSet.candidateStack.empty() ) { }// modify match parameters\n\n        MaxDistanceCorrections(tri, matchSet, myfile, x);\n    }\n}\n</code></pre>\n<p>and print when ofstream is available</p>\n<pre><code>void PrintCorrections(Trie &amp;tri, Trie::MatchesT &amp;matchSet, ofstream &amp;myfile, settingT &amp;x)\n{   \n    while (true) {\n        if (!myfile.is_open() ) { \n          myfile.open(outFile.c_str(), ios::out | ios::app);\n          break;\n        }  \n     }\n\n    while (!matchSet.candidateStack.empty() ) {\n        Trie::CorrectionT corr=matchSet.candidateStack.back();\n        matchSet.candidateStack.pop_back();\n\n        const bool flagGood=scoreSuggest (corr); //score\n        if (flagGood ) x.score++;\n\n        myfile &lt;&lt; matchSet.testCase &lt;&lt; \",\" &lt;&lt; corr.match &lt;&lt; \",\" &lt;&lt; corr.editDistance &lt;&lt; \"\\n\";\n\n    }\n    myfile.close();\n\n    return;\n}\n</code></pre>\n<p>Fairly new at mutithreading, these functions worked fine as a single thread. </p>\n<p>Should the check for ofstream available be placed within the while loop that spins off the candidate matches? Once the ofstream is available then starting the print sequence should tie-up the ofstream form other threads.</p>\n<p>Is there a better way to reserve use of an ofstream shared by multiple threads?</p>\n", "Tags": "<c++><boost-thread><ofstream>", "OwnerUserId": "1452181", "AnswerCount": "2"}, "15513649": {"ParentId": "15513549", "CommentCount": "8", "Body": "<p>If you are new to multi-threading then let this be a lesson in why you should use mutex locks.</p>\n<p>The <code>fstream</code> object is just that - an object.  You must protect it against simultaneous access by using a mutex.</p>\n<p>If you just want threads to be able to write information to a file, you could instead pass a file name (as a <code>string</code>) instead of an <code>fstream</code>.  The thread could then open the file with exclusive read/write access.  This would use a local <code>fstream</code> object, and the locking would be handled by the operating system.</p>\n", "OwnerUserId": "1553090", "PostTypeId": "2", "Id": "15513649", "Score": "2", "CreationDate": "2013-03-20T01:23:58.857", "LastActivityDate": "2013-03-20T01:23:58.857"}, "bq_ids": {"n4140": {"so_15513549_15513639_0": {"section_id": 1907, "quality": 0.6875, "length": 22}}, "n3337": {"so_15513549_15513639_0": {"section_id": 1896, "quality": 0.6875, "length": 22}}, "n4659": {"so_15513549_15513639_0": {"section_id": 2177, "quality": 0.6875, "length": 22}}}});