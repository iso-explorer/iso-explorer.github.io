post_cb({"22143606": {"Id": "22143606", "PostTypeId": "2", "Body": "<p>The usual rules on type promotion in binary operations apply. To quote the Standard (chapter 5. expressions)</p>\n<blockquote>\n<p id=\"so_22143032_22143606_0\">9.Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield\n  result types in a similar way. The purpose is to yield a common type, which is also the type of the result.</p>\n<p id=\"so_22143032_22143606_1\">This pattern is called the <strong>usual arithmetic conversions</strong>, which are defined as follows:</p>\n<p id=\"so_22143032_22143606_2\">If either operand is of scoped enumeration type (7.2), no conversions are performed; </p>\n<p id=\"so_22143032_22143606_3\">if the other operand does not have the same type, the expression is ill-formed.</p>\n<p id=\"so_22143032_22143606_4\">If either operand is of type long double, the other shall be converted to long double.</p>\n<p id=\"so_22143032_22143606_5\">Otherwise, if either operand is double, the other shall be converted to double.</p>\n<p id=\"so_22143032_22143606_6\">Otherwise, if either operand is float, the other shall be converted to float.</p>\n<p id=\"so_22143032_22143606_7\">Otherwise, the integral promotions (4.5) shall be performed on both operands</p>\n</blockquote>\n", "LastActivityDate": "2014-03-03T10:00:05.283", "CommentCount": "0", "CreationDate": "2014-03-03T10:00:05.283", "ParentId": "22143032", "Score": "3", "OwnerUserId": "2567683"}, "bq_ids": {"n4140": {"so_22143032_22143606_3": {"length": 8, "quality": 1.0, "section_id": 5943}, "so_22143032_22143606_6": {"length": 7, "quality": 1.0, "section_id": 5943}, "so_22143032_22143606_7": {"length": 6, "quality": 1.0, "section_id": 5943}, "so_22143032_22143606_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5943}, "so_22143032_22143606_2": {"length": 7, "quality": 1.0, "section_id": 5943}, "so_22143032_22143606_4": {"length": 9, "quality": 1.0, "section_id": 5943}, "so_22143032_22143606_1": {"length": 7, "quality": 0.875, "section_id": 5943}, "so_22143032_22143606_5": {"length": 7, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_22143032_22143606_3": {"length": 8, "quality": 1.0, "section_id": 5714}, "so_22143032_22143606_6": {"length": 7, "quality": 1.0, "section_id": 5714}, "so_22143032_22143606_7": {"length": 6, "quality": 1.0, "section_id": 5714}, "so_22143032_22143606_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5714}, "so_22143032_22143606_2": {"length": 7, "quality": 1.0, "section_id": 5714}, "so_22143032_22143606_4": {"length": 9, "quality": 1.0, "section_id": 5714}, "so_22143032_22143606_1": {"length": 7, "quality": 0.875, "section_id": 5714}, "so_22143032_22143606_5": {"length": 7, "quality": 1.0, "section_id": 5714}}, "n4659": {"so_22143032_22143606_3": {"length": 8, "quality": 1.0, "section_id": 7428}, "so_22143032_22143606_6": {"length": 7, "quality": 1.0, "section_id": 7428}, "so_22143032_22143606_7": {"length": 6, "quality": 1.0, "section_id": 7428}, "so_22143032_22143606_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 7428}, "so_22143032_22143606_2": {"length": 7, "quality": 1.0, "section_id": 7428}, "so_22143032_22143606_4": {"length": 9, "quality": 1.0, "section_id": 7428}, "so_22143032_22143606_1": {"length": 7, "quality": 0.875, "section_id": 7428}, "so_22143032_22143606_5": {"length": 7, "quality": 1.0, "section_id": 7428}}}, "22143032": {"ViewCount": "5181", "Body": "<p>I have the following piece of code (feel free to change the float with double):</p>\n<pre><code>class A\n{\n    public:\n        void setValueFloat(float v) {\n              m_floatValue = v / 3.6;  // m/s &lt;-&gt; km/h conversion\n        }\n        void setValueInt(int v1, int v2) { \n              m_intValue1 = v1; m_intValue2 = v2;\n        }\n\n        bool conditionIsOk()\n        {\n             if(m_intValue1 &gt; m_intValue2)\n             {\n                  if(m_intValue1 - m_intValue2 &gt; m_floatValue)\n                  {\n                      return true;\n                  }\n             }\n             return false;\n        }\n\n    private:\n        int m_intValue1, m_intValue2;\n        float m_floatValue;\n\n};\n</code></pre>\n<p>and somewhere else:</p>\n<pre><code>A a;\nint something = 5; // Intentionally int\nint somethingElse = 6; //these are just some numbers, not production data!!!\nint moreStuff = 7;\n\na.setValueFloat(something);\na.setValueInt(somethingElse, moreStuff);\nif(a.conditionIsOk())\n{\n   // Yippee!\n}\n</code></pre>\n<p>And the questions:</p>\n<ol>\n<li><p>How safe is it to compare the result of an arithmetic operation on <code>int</code>s to a <code>float</code> given the situation above?</p></li>\n<li><p>Is it necessary to <code>(float)m_intValue1 - (float)m_intValue2 &gt; m_floatValue</code> for this situation?</p></li>\n<li><p>Where in the C / C++ standard can I find a line about exactly this situation?</p></li>\n<li><p>What typecasts will be done by default for the simple situation <code>m_intValue1 - m_intValue2 &gt; m_floatValue</code> ? (and how can I show this to someone else in a way that he also sees it (visually), \"just believing that it works\" is not enough :) )</p></li>\n</ol>\n", "AcceptedAnswerId": "22143456", "Title": "About comparing an integer and a float/double in C/C++", "CreationDate": "2014-03-03T09:32:36.703", "Id": "22143032", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2014-03-03T12:52:27.367", "Score": "2", "OwnerUserId": "186193", "Tags": "<c++><c><floating-point><comparison><int>", "AnswerCount": "2"}, "22143456": {"Id": "22143456", "PostTypeId": "2", "Body": "<ol>\n<li><p>This depends on the actual implementation (i.e. which compiler and which architecture are used). On typical systems with 32 bit <code>int</code>s and IEEE754 binary32 <code>float</code>s integers can be represented exactly up to +-2^24 as floats, so not for the full range of possible values. So no, it is not safe in general, but may be safe if the used range of your integers (or in this case rather the difference!) and floats is limited appropriately.</p></li>\n<li><p>No! In fact <code>m_intValue1 - m_intValue2 &gt; m_floatValue</code> is better as the conversion to float happens after the computation of the difference (see note about difference in the above point). You can be explicit and write <code>static_cast&lt;float&gt;(m_intValue1 - m_intValue2) &gt; m_floatValue</code>, but this is not necessary.</p></li>\n<li><p>Conversions are covered in chapter 4 of the C++ standard (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">draft N3242</a>). In particular 4.9 Floating-integral conversions, also note 5\u00a710 \"usual arithmetic conversions\" which also applies to comparisons. As the question is also tagged with C, in the C standard (see <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">darft N1570</a>) the corresponding section is 6.3.1 and in particular 6.3.1.4 and 6.3.1.8.</p></li>\n<li><p>See answers to 2. and 3.</p></li>\n</ol>\n", "LastEditorUserId": "2361316", "LastActivityDate": "2014-03-03T12:52:27.367", "Score": "5", "CreationDate": "2014-03-03T09:52:31.627", "ParentId": "22143032", "CommentCount": "0", "OwnerUserId": "2361316", "LastEditDate": "2014-03-03T12:52:27.367"}});