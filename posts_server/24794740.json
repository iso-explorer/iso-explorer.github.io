post_cb({"bq_ids": {"n4140": {"so_24794740_24794786_1": {"length": 51, "quality": 0.9622641509433962, "section_id": 5768}, "so_24794740_24795077_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 3222}, "so_24794740_24795077_1": {"length": 6, "quality": 1.0, "section_id": 3222}, "so_24794740_24794740_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 3222}, "so_24794740_24794740_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 5800}}, "n3337": {"so_24794740_24794786_1": {"length": 51, "quality": 0.9622641509433962, "section_id": 5541}, "so_24794740_24795077_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 3096}, "so_24794740_24794740_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3096}, "so_24794740_24794740_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 5573}, "so_24794740_24795077_1": {"length": 6, "quality": 1.0, "section_id": 3096}}, "n4659": {"so_24794740_24794786_1": {"length": 51, "quality": 0.9622641509433962, "section_id": 7225}, "so_24794740_24795077_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 3979}, "so_24794740_24794740_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 3979}, "so_24794740_24794740_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 7259}, "so_24794740_24795077_1": {"length": 6, "quality": 1.0, "section_id": 3979}}}, "24795077": {"Id": "24795077", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24794740_24795077_0\">If I understand right, the standard said that as soon as a null reference being created the program behavior is being undefined.</p>\n</blockquote>\n<p>Yes that is correct. The text that assures this is:</p>\n<blockquote>\n<p id=\"so_24794740_24795077_1\">A reference shall be initialized to refer to a valid object or function.</p>\n</blockquote>\n<p>The result of dereferencing a null pointer is certainly not a valid object or function.</p>\n<p>You also quote the following text:</p>\n<blockquote>\n<p id=\"so_24794740_24795077_2\">[Note: in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the \u201cobject\u201d obtained by dereferencing a null pointer, which causes undefined behavior. As described in 9.6, a reference cannot be bound directly to a bit-field. ]</p>\n</blockquote>\n<p>However, \"Note\" means that it is <em>non-normative</em>, i.e. the text is meant to be explanatory but does not actually constitute a part of the standard specification. And, somewhat surprisingly, it  turns out that the Standard doesn't actually say anywhere (that I'm aware of) that <code>*p</code> causes undefined behaviour.</p>\n<p>It <em>does</em> say that lvalue-to-prvalue conversion on <code>*p</code> causes undefined behaviour, but it also says that this conversion is not performed in the case of binding a reference.  </p>\n<p>This came up in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1102\" rel=\"nofollow\">issue 1102</a> .</p>\n", "LastActivityDate": "2014-07-17T04:48:35.393", "Score": "1", "CreationDate": "2014-07-17T04:48:35.393", "ParentId": "24794740", "CommentCount": "4", "OwnerUserId": "1505939"}, "24794837": {"Id": "24794837", "PostTypeId": "2", "Body": "<p>\"Undefined behavior\" means that anything can happen and the compiler is not obligated to do anything specific. In this case here, nothing catastrophic happens on the null pointer dereference, it just brings the program in an invalid state by creating a null reference. Which causes problems later on.</p>\n<p>Of course it would be desirable if the error could be detected earlier, but the only way to do so would be for the compiler to add explicit null pointer checks to all dereference operations, which would only waste performance in a well behaved (no null pointers used incorrectly) program. Since null pointer dereferences usually quickly lead to crashes anyway, this is probably not seen as being worth it even in debug mode.</p>\n", "LastActivityDate": "2014-07-17T04:21:26.447", "Score": "1", "CreationDate": "2014-07-17T04:21:26.447", "ParentId": "24794740", "CommentCount": "5", "OwnerUserId": "56338"}, "24794786": {"Id": "24794786", "PostTypeId": "2", "Body": "<p>\"Undefined behavior\" does not mean \"Crash Now\".</p>\n<p>It is defined in the C++ standard, section 1.3.24</p>\n<blockquote>\n<p id=\"so_24794740_24794786_0\"><strong>Behavior for which this International Standard imposes no requirements</strong></p>\n<p id=\"so_24794740_24794786_1\">[ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. Permissible undefined\n  behavior <strong>ranges from ignoring the situation completely with\n  unpredictable results, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message)</strong>. Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed.</p>\n</blockquote>\n<ul>\n<li>The program is not required to crash as soon as you bind your null reference.</li>\n<li>Having a compiler generate code to check those cases would incur a dramatic overhead on the program, which is not acceptable.</li>\n</ul>\n", "LastEditorUserId": "3510483", "LastActivityDate": "2014-07-17T04:22:34.773", "Score": "4", "CreationDate": "2014-07-17T04:14:55.103", "ParentId": "24794740", "CommentCount": "9", "LastEditDate": "2014-07-17T04:22:34.773", "OwnerUserId": "3510483"}, "24794740": {"ViewCount": "250", "Body": "<p>When bad C++ code tries to create a null reference like the following:</p>\n<pre><code>int &amp;ptr2ref(int *p){\n    return *p;\n}\n\nint calc(int &amp;v){\n    return v*2;\n}\n\n...\nint &amp;i = ptr2ref(nullptr);\ncalc(i);\n</code></pre>\n<p>At least in Visual C++ it crashed in the return statement of function <code>calc</code> (debug mode).</p>\n<p>However, the answer of <a href=\"https://stackoverflow.com/questions/4364536/c-null-reference\">this question</a> quotes</p>\n<p>8.3.2/1:</p>\n<blockquote>\n<p id=\"so_24794740_24794740_0\">A reference shall be initialized to\n  refer to a valid object or function.\n  [Note: in particular, a null reference\n  cannot exist in a well-defined\n  program, because the only way to\n  create such a reference would be to\n  bind it to the \u201cobject\u201d obtained by\n  dereferencing a null pointer, which\n  causes undefined behavior. As\n  described in 9.6, a reference cannot\n  be bound directly to a bit-field. ]</p>\n</blockquote>\n<p>1.9/4:</p>\n<blockquote>\n<p id=\"so_24794740_24794740_1\">Certain other operations are described\n  in this International Standard as\n  undefined (for example, the effect of\n  dereferencing the null pointer)</p>\n</blockquote>\n<p>If I understand right, the standard said that as soon as a null reference being created the program behavior is being undefined. <strong>So if a compiler intended to generate useful debug information</strong> it should crash at function <code>ptr2ref</code> in the above example, since there is where the null reference being created (and the deferencing happening).</p>\n<p>Am I missed something? Are there any issue stops the compiler generate such code <strong>in at lest debug mode</strong>?</p>\n<p><strong>Undefined Behaviour</strong></p>\n<p>I know people will argue that \"undefined\" means roughly everything. My argument is, given the fact that the standard did not specify how long a simple <code>int main(){}</code> shall take to compile, no one will accept a compile time to be more than a day. So the problem is about <strong>implementation options</strong>, not the standard itself. <strong>I quoted the standard here is just to say that crash on <code>ptr2ref</code> IS an option</strong>.</p>\n<p>Furthermore, there is already a lot of additional checking happening in debug mode, for example, the stack was always checked to see if there are any corruption before returning from the function. Compare to those I don't think add a relatively simple check will be too expansive in <strong>debug mode</strong>.</p>\n", "Title": "Crash behavior on null reference", "CreationDate": "2014-07-17T04:07:58.870", "LastActivityDate": "2014-07-17T05:27:21.003", "CommentCount": "6", "LastEditDate": "2017-05-23T12:21:25.433", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "24794740", "Score": "1", "OwnerUserId": "812034", "Tags": "<c++><reference><nullreferenceexception>", "AnswerCount": "3"}});