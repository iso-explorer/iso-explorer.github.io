post_cb({"44698412": {"ViewCount": "47", "Body": "<p>As mentioned <a href=\"https://stackoverflow.com/questions/1661529/is-meyers-implementation-of-the-singleton-pattern-thread-safe\">there</a>, Meyer's singleton is thread-safe in C++11.</p>\n<p>So I would expect this code to be fine:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\nstruct key_type {\n    int value;\n    key_type() : value(0) { }\n};  \n\n\nvoid * thread1(void*) {\n    static key_type local_key;\n    printf(\"thread has key %d\\n\", local_key.value);\n    return NULL;\n}   \n\nint main()\n{\n    pthread_t t[2];\n    pthread_create(&amp;t[0], NULL, thread1, NULL);\n    pthread_create(&amp;t[1], NULL, thread1, NULL);\n    pthread_join(t[0], NULL);\n    pthread_join(t[1], NULL);\n}   \n</code></pre>\n<p>(code overly simplified on purpose, I know I can do zero-initialization trivially.)</p>\n<p>I'm compiling with g++-7.1.0. Helgrind (valgrind-3.12.0) reports a <em>possible</em> data race between the read of <code>local_key.value</code> and the ctor, which sets <code>value</code>.</p>\n<pre><code>==29036== Possible data race during read of size 4 at 0x601058 by thread #3\n==29036== Locks held: none\n==29036==    at 0x4006EA: thread1(void*) (datarace-simplest.cpp:12)\n==29036==    by 0x4C32D06: mythread_wrapper (hg_intercepts.c:389)\n==29036==    by 0x4E45493: start_thread (pthread_create.c:333)\n==29036==    by 0x59DEAFE: clone (clone.S:97)\n==29036== \n==29036== This conflicts with a previous write of size 4 by thread #2\n==29036== Locks held: none\n==29036==    at 0x400780: key_type::key_type() (datarace-simplest.cpp:6)\n==29036==    by 0x4006DF: thread1(void*) (datarace-simplest.cpp:11)\n==29036==    by 0x4C32D06: mythread_wrapper (hg_intercepts.c:389)\n==29036==    by 0x4E45493: start_thread (pthread_create.c:333)\n==29036==    by 0x59DEAFE: clone (clone.S:97)\n==29036==  Address 0x601058 is 0 bytes inside data symbol \"_ZZ7thread1PvE9local_key\"\n</code></pre>\n<p>I thought that the c++11 standard (\u00a76.7) guaranteed that <code>local_key</code> was initialized just once and for all, so that further accesses dealt with variables whose ctor was guaranteed not to be still running.</p>\n<blockquote>\n<p id=\"so_44698412_44698412_0\">Otherwise such a variable is initialized the first time\n  control passes through its declaration; such a variable is considered\n  initialized upon the completion of its initialization. [...] If control enters the declaration concurrently while\n  the variable is being initialized, the concurrent execution shall wait\n  for completion of the initialization. [...]</p>\n</blockquote>\n<p>Am I wrong ? Is it a helgrind defect ? Is this use case known to slip through the cracks so that helgrind reports a <em>possible</em> race ?</p>\n", "AcceptedAnswerId": "44708592", "Title": "helgrind reports possible race between use of singleton and its constructor", "CreationDate": "2017-06-22T11:41:32.607", "Id": "44698412", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-06-22T20:14:05.430", "Score": "0", "OwnerUserId": "1543085", "Tags": "<c++><thread-safety><valgrind>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_44698412_44698412_0": {"length": 31, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_44698412_44698412_0": {"length": 31, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_44698412_44698412_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 4805}}}, "44699985": {"Id": "44699985", "PostTypeId": "2", "Body": "<p>I <em>think</em> this is a hellgrind defect. The standard guarantees that the static initialization is sequenced before the read later, and evidence (see below) suggests that not only the decision whether or not to run the constructor, but actually the whole constructor is behind a lock.</p>\n<p>Modifying your example such that the constructor reads</p>\n<pre><code>key_type() : value(0) {\n    sleep (1);\n    pthread_yield();\n    value = 42;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/lK9ofs\" rel=\"nofollow noreferrer\">outputs</a> 42 twice. This suggests that the lock acquired when testing if necessary and starting with the initialization is not released until the constructor finishes.</p>\n", "LastActivityDate": "2017-06-22T12:53:13.300", "CommentCount": "0", "CreationDate": "2017-06-22T12:53:13.300", "ParentId": "44698412", "Score": "0", "OwnerUserId": "1116364"}, "44708592": {"Id": "44708592", "PostTypeId": "2", "Body": "<p>Disassembling the function thread1, I see calls to __cxa_guard_acquire\nand __cxa_guard_release, which I think we can reasonably assume is what\nprotects the constructor. However, such calls are not intercepted\nby helgrind, and so, helgrind does not observe any synchronisation. This is a bug/weakness in Valgrind/helgrind worth filing a bug on valgrind bugzilla. Note however that quickly reading the code, the calls to  __cxa_guard_acquire and __cxa_guard_release seems to not match directly a pair of lock/unlock: it looks like the code might just call acquire, and then not call release:</p>\n<pre><code>   00x000000000040077e &lt;+24&gt;:   mov    $0x600d00,%edi\n   0x0000000000400783 &lt;+29&gt;:    callq  0x400610 &lt;__cxa_guard_acquire@plt&gt;\n   0x0000000000400788 &lt;+34&gt;:    test   %eax,%eax\n   0x000000000040078a &lt;+36&gt;:    setne  %al\n   0x000000000040078d &lt;+39&gt;:    test   %al,%al\n   0x000000000040078f &lt;+41&gt;:    je     0x4007a5 &lt;thread1(void*)+63&gt;\n   0x0000000000400791 &lt;+43&gt;:    mov    $0x600d08,%edi\n   0x0000000000400796 &lt;+48&gt;:    callq  0x40082e &lt;key_type::key_type()&gt;\n   0x000000000040079b &lt;+53&gt;:    mov    $0x600d00,%edi\n   0x00000000004007a0 &lt;+58&gt;:    callq  0x400650 &lt;__cxa_guard_release@plt&gt;\n   0x00000000004007a5 &lt;+63&gt;:    mov    0x20055d(%rip),%eax        # 0x600d08 &lt;_ZZ7thread1PvE9local_key&gt;\n</code></pre>\n<p>After debugging a little bit, it looks like the guard is located just before\nlocal_key, and becomes set to 1 after the object is constructed.\nNot very clear to me what __cxa_guard_release has to do. Some more reading of the c++ runtime library code is needed I guess to understand how helgrind could (maybe) be instructed about what happens there.</p>\n<p>Note also that the valgrind drd tool similarly suffers from the same bug/weakness.</p>\n", "LastActivityDate": "2017-06-22T20:14:05.430", "CommentCount": "2", "CreationDate": "2017-06-22T20:14:05.430", "ParentId": "44698412", "Score": "0", "OwnerUserId": "3035584"}});