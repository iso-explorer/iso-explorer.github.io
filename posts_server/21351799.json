post_cb({"bq_ids": {"n4140": {"so_21351799_21351799_2": {"length": 24, "quality": 0.8571428571428571, "section_id": 6074}, "so_21351799_21351799_3": {"length": 16, "quality": 0.8, "section_id": 6009}}, "n3337": {"so_21351799_21351799_2": {"length": 24, "quality": 0.8571428571428571, "section_id": 5842}, "so_21351799_21351799_3": {"length": 16, "quality": 0.8, "section_id": 5777}}, "n4659": {"so_21351799_21351799_2": {"length": 19, "quality": 0.6785714285714286, "section_id": 7570}, "so_21351799_21351799_3": {"length": 16, "quality": 0.8, "section_id": 7508}}}, "25319705": {"Id": "25319705", "PostTypeId": "2", "Body": "<p>C and C++ are different languages.  C++ has operator overloading and C does not.  The <strong>++</strong> operators, whether prefix or postfix, are operators which can be overloaded in C++.  C++ also has references and C does not.</p>\n<p>In C, <strong>++i</strong> and <strong>i++</strong> both yield a value which is not an <em>lvalue</em>.  This is desirable, as otherwise you could run afoul with undefined behaviour by trying to modify the same scalar within the same sequence-point boundaries.</p>\n<p>Food for thought: In C, the comma operator also produces a value which is not an lvalue, so to \"drop\" <em>lvalueness</em>, you can do:</p>\n<pre><code>(0, lvalue)\n</code></pre>\n", "LastActivityDate": "2014-08-15T00:43:45.017", "CommentCount": "0", "CreationDate": "2014-08-15T00:43:45.017", "ParentId": "21351799", "Score": "1", "OwnerUserId": "413771"}, "44905474": {"Id": "44905474", "PostTypeId": "2", "Body": "<p>It is true that</p>\n<ul>\n<li><p>pre increment/decrement operator (++var or --var) yields an lvalue (i.e a modifiable object)</p></li>\n<li><p>post increment/decrement operator (var++ or var--) yields an rvalue (i.e a temporary object).</p></li>\n</ul>\n<p>Consider following code with pre increment/decrement operator</p>\n<pre><code>{\n\nint i = 0;\n\nint* pi = &amp;(++i);\n\n}\n</code></pre>\n<p>It\u00b4s OK because in fact its pseudo code is</p>\n<pre><code>i = i+1; // pre increment i\n\nint* pi = &amp;i; // then evaluate its address and assign it to pi \n</code></pre>\n<p>Now consider the same code but with post increment/decrement operator and its consequences if it was accepted by the compiler</p>\n<pre><code>{\n\nint i = 0;\n\nint* pi = &amp;(i++); // Not OK !! because virtually it is a temporary variable\n\n}\n</code></pre>\n<p>Its pseudo code would be</p>\n<pre><code>int i = 0;\n\nint tmp = i; // compiler creates a temporary variable to save value of i\n\nint* pi = &amp;tmp; // then would take the address of a temporary variable \n\ni = i + 1; // the post increment happening only after the assignment !!!\n</code></pre>\n<p>I hope this help clarifying a bit ;)</p>\n", "LastEditorUserId": "2482410", "LastActivityDate": "2017-07-04T14:38:10.337", "Score": "0", "CreationDate": "2017-07-04T12:00:40.630", "ParentId": "21351799", "CommentCount": "0", "OwnerUserId": "8253708", "LastEditDate": "2017-07-04T14:38:10.337"}, "21351799": {"ViewCount": "1199", "Body": "<p>I just learned the following facts:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_21351799_21351799_0\">The result of a prefix increment (++var_name) is an R-value in C (at least, I am\n    sure that it is not a L-value in C), but it is an L-value in C++.</p></li>\n<li><p id=\"so_21351799_21351799_1\">The result of a postfix increment (var_name++) is an R-value in C (at least, I am\n    sure that it is not a L-value in C). This is also true in C++ (It says the result\n    is a prvalue).</p></li>\n</ul>\n</blockquote>\n<p>I checked these in VS2010 (.cpp and .c) and Ubuntu (gcc and g++). </p>\n<p>In p.109 (5.3.2) of C++ Standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a>, it is written</p>\n<blockquote>\n<p id=\"so_21351799_21351799_2\"><em>The operand of prefix ++ is modified by adding 1, or set to true if it is bool (this use is deprecated). The\n  operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to\n  a completely-defined object type. <strong>The result is the updated operand; it is an lvalue</strong>, and...</em></p>\n</blockquote>\n<p>and in p.101, (5.2.6)</p>\n<blockquote>\n<p id=\"so_21351799_21351799_3\">The value of a postfix ++ expression is the value of its operand. ... <strong>The result is a\n  prvalue</strong>. The type of the result is the cv-unqualified version of the type of the operand. See also 5.7 and 5.17.</p>\n</blockquote>\n<p>(I don't know the difference between R-value and prvalue though).</p>\n<p>As to C standard <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf</a>,\nprefix ++ is described in 6.5.3.1 and postfix is in 6.5.2.4, but from the description, I can't get a clear, definite answer.</p>\n<p>I would like to know the reasons that make them being R-value or L-value. All I know is that</p>\n<p><code>We can assign a value to a (modifiable) L-value, for example, a variable name. R-value is a value of an expression.</code></p>\n<p><strong>But I don't know the details why postfix ++ is not a L-value in C and C++, and why prefix ++ is not in C.</strong> (I saw something like \"postfix ++...store...in a temporary address, then...\", but I still don't get it).</p>\n<p>And another question is that why prefix ++ is different in C and C++? Making prefix ++ a L-value (in C++) has many advantages? If so, why C doesn't change this? (Other reasons than backward compatibility, or at least why changing it will cause a lot of problems).</p>\n", "Title": "postfix (prefix) increment, L-value and R-value (in C and C++)", "CreationDate": "2014-01-25T14:30:29.680", "LastActivityDate": "2017-07-04T14:38:10.337", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-01-25T15:10:46.210", "LastEditorUserId": "2793118", "Id": "21351799", "Score": "4", "OwnerUserId": "565739", "Tags": "<c++><c><operators><operand><operands>", "AnswerCount": "2"}});