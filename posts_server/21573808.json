post_cb({"bq_ids": {"n4140": {"so_21573808_36488572_2": {"length": 52, "quality": 0.8, "section_id": 302}, "so_21573808_36488572_1": {"length": 52, "quality": 0.8, "section_id": 302}, "so_21573808_36488572_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 282}}, "n3337": {"so_21573808_36488572_2": {"length": 52, "quality": 0.8, "section_id": 293}, "so_21573808_36488572_1": {"length": 52, "quality": 0.8, "section_id": 293}, "so_21573808_36488572_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 273}}, "n4659": {"so_21573808_36488572_2": {"length": 61, "quality": 0.9384615384615385, "section_id": 309}, "so_21573808_36488572_1": {"length": 61, "quality": 0.9384615384615385, "section_id": 309}, "so_21573808_36488572_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 289}}}, "36488572": {"Id": "36488572", "PostTypeId": "2", "Body": "<p>You should have provided the signature of your member function <code>fun</code>. Let's assume that it has the following signature:</p>\n<pre><code>class YourClassObj\n{\npublic:\n    template&lt;typename ...Args&gt;\n    SomeType fun(Args ...args) {...}\n    ...\n};\n</code></pre>\n<p>Then the following call:</p>\n<pre><code>fun(obj, {1, 2, 3});\n</code></pre>\n<p>with a forwarding function, causes actually a non-deduced context related to failing to deduce type for <code>{1,2,3}</code>. As per the Standard:</p>\n<blockquote>\n<p id=\"so_21573808_36488572_0\">14.8.2.1 Deducing template arguments from a function call [temp.deduct.call]</p>\n<blockquote>\n<p id=\"so_21573808_36488572_2\">Template argument deduction is done by comparing each function template parameter type (call it <code>P</code>) with the type of the corresponding argument of the call (call it <code>A</code>) as described below. If <code>P</code> is a dependent type, removing references and cv-qualifiers from <code>P</code> gives <code>std::initializer_list&lt;P'&gt;</code> or <code>P'[N]</code> for some <code>P'</code> and <code>N</code> and the argument is a non-empty initializer list (8.5.4), then deduction is performed instead for each element of the initializer list, taking <code>P'</code> as a function template parameter type and the initializer element as its argument, and in the <code>P'[N]</code> case, if <code>N</code> is a non-type template parameter, <code>N</code> is deduced from the length of the initializer list. <strong>Otherwise, an initializer list argument causes the parameter to be considered a non-deduced context</strong> (14.8.2.5).</p>\n</blockquote>\n</blockquote>\n<p>Examples from the standard:</p>\n<blockquote id=\"so_21573808_36488572_3\">\n<pre><code>   template&lt;class T&gt; void f(std::initializer_list&lt;T&gt;);\n   f({1,2,3}); // T deduced to int\n   template&lt;class T&gt; void g(T);\n   g({1,2,3}); // error: no argument deduced for T\n</code></pre>\n</blockquote>\n<p><code>std::forward</code> essentially does template type deduction from function call. Scott Meyers describes in his <em>Effective Modern C++</em> book this situation as one of the <a href=\"https://books.google.com.hk/books?id=rjhIBQAAQBAJ&amp;pg=PA207&amp;lpg=PA207&amp;dq=perfect%20forwarding%20failure%20cases&amp;source=bl&amp;ots=Fl2GW6yxsS&amp;sig=hWsluXOfJAq6wKf4UZaZvYLqRRw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwiWpPOeyv3LAhUGBiwKHT7oAY0Q6AEIKDAC#v=onepage&amp;q=perfect%20forwarding%20failure%20cases&amp;f=false\" rel=\"nofollow\"><em>perfect forwarding failure cases</em></a>. As he said in the book, one simple workaround is to use <code>auto</code>:</p>\n<pre><code>auto __il = {1,2,3};\nfun(obj, __il);\n</code></pre>\n<p>should compile fine, since <code>auto</code> deduces <code>{1,2,3}</code> to be a <code>std::initializer_list&lt;int&gt;</code>. You can read the whole chapter for more detailed explanation.</p>\n<p>And by the way, the other approach with a function <code>il</code> returning a <code>std::initializer_list&lt;T&gt;</code> should also compile, if the original <code>fun</code> signature is actually the same as what I assumed (tested with gcc-4.9.1).</p>\n", "LastEditorUserId": "6141807", "LastActivityDate": "2016-04-07T22:55:13.243", "Score": "1", "CreationDate": "2016-04-07T22:48:46.177", "ParentId": "21573808", "CommentCount": "0", "OwnerUserId": "6141807", "LastEditDate": "2016-04-07T22:55:13.243"}, "21573808": {"ViewCount": "1402", "Body": "<p>I have the following code:</p>\n<pre><code>#define RETURNS(...) -&gt; decltype((__VA_ARGS__)) { return (__VA_ARGS__); }\n\ntemplate &lt;typename This, typename... Args&gt;\nauto fun(This &amp;&amp;this_, Args&amp;&amp;... args) RETURNS(this_.fun(std::forward&lt;Args&gt;(args)...))\n</code></pre>\n<p>For better or worse, this allows me to use fun(o, args...) and o.f(args...) interchangeably.  The difficulty in using this comes when using an initializer list as an argument.  E.g.</p>\n<pre><code>fun(obj, {1, 2, 3}); // Where obj.fun eventually takes a std::vector&lt;int&gt;.\n</code></pre>\n<p>This fails due to a substitution error, so Clang says.  Note, <code>obj.fun({1, 2, 3});</code> works.</p>\n<p>As I understand it from other questions, this is because initializer lists don't always play nicely with template argument deduction.</p>\n<p>The closest I have to my desired syntax is by making the initializer list more explicit.  To avoid verbosity, I have the following:</p>\n<pre><code>template &lt;typename T&gt; std::initializer_list&lt;T&gt; il(std::initializer_list&lt;T&gt; &amp;&amp;li) { return li; }\n\nfun(obj, il({1, 2, 3}));\n</code></pre>\n<p>Is there a way of getting my desired syntax or closer to it?</p>\n<hr>\n<p>Clang's error report in my test program is:</p>\n<pre><code>subst.cpp:16:5: error: no matching function for call to 'fun'\n    fun(x, {1, 2, 3});\n    ^~~\nsubst.cpp:6:6: note: candidate template ignored: substitution failure [with This\n      = X &amp;, Args = &lt;&gt;]: too few arguments to function call, single argument 'v'\n      was not specified\nauto fun(This &amp;&amp;this_, Args&amp;&amp;... args) RETURNS(this_.fun(std::forward&lt;Args&gt;(args)...))\n     ^                                                                              ~\n</code></pre>\n</hr>", "AcceptedAnswerId": "36488572", "Title": "Using Initializer Lists with Variadic Templates", "CreationDate": "2014-02-05T09:53:30.173", "Id": "21573808", "CommentCount": "8", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-02-05T12:53:12.127", "LastEditorUserId": "24913", "LastActivityDate": "2016-04-07T22:55:13.243", "Score": "2", "OwnerUserId": "24913", "Tags": "<c++><c++11><variadic-templates><initializer-list><type-deduction>", "AnswerCount": "1"}});