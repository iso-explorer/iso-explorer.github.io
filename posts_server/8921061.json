post_cb({"8922558": {"ParentId": "8921061", "CommentCount": "1", "Body": "<p>There is a subtle issue here: it's a problem of evaluation.</p>\n<p>Normally, dereferencing a null pointer is <em>Undefined Behavior</em>; however there is a corner case (at least on gcc), that invoking <code>typeid(*p)</code> where <code>p</code> is null is a valid expression.</p>\n<p>Therefore the issue here resides in your level of indirection:</p>\n<pre><code>int* p = 0;\n\ngetname(*p);       // p is null, *p invokes undefined behavior\n\ntypeid(*p).name(); // p is null, but it's probably okay in `typeid`\n                   // because it's an unevaluated operand here\n</code></pre>\n<hr>\n<p>For those interesting in delving deeper, the <code>typeid</code> expression is described in detail in <strong>\u00a75.2.8</strong> (C++11).</p>\n<blockquote>\n<p id=\"so_8921061_8922558_0\"><strong>2/</strong> When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers to a <code>std::type_info</code> object representing the type of the most derived object (1.8) (that is, the dynamic type) to which the glvalue refers. If the glvalue expression is obtained by applying the unary <code>*</code> operator to a pointer and the pointer is a null pointer value (4.10), the <code>typeid</code> expression throws the <code>std::bad_typeid</code> exception (18.7.3).</p>\n</blockquote>\n<p>Okay, so <code>typeid(*p)</code> is defined if <code>p</code> points to a polymorphic class... and in this case it throws.</p>\n<blockquote>\n<p id=\"so_8921061_8922558_1\"><strong>3/</strong> When <code>typeid</code> is applied to an expression other than a glvalue of a polymorphic class type, the result refers to a <code>std::type_info</code> object representing the static type of the expression. Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) conversions are not applied to the expression. If the type of the expression is a class type, the class shall be completely-defined. The expression is an unevaluated operand\n  (Clause 5).</p>\n</blockquote>\n<p>Interestingly, no mention of null pointers for non-polymorphic classes. I suspect the <em>unevaluated operand</em> is what allows this, but have yet to find the citation.</p>\n<blockquote>\n<p id=\"so_8921061_8922558_2\"><strong>6/</strong> If the header <code>&lt;typeinfo&gt;</code> (18.7.1) is not included prior to a use of <code>typeid</code>, the program is ill-formed.</p>\n</blockquote>\n<p>No diagnostic seems required. At least on gcc I think it fires off a warning though.</p>\n</hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "8922558", "Score": "3", "CreationDate": "2012-01-19T07:41:19.470", "LastActivityDate": "2012-01-19T07:41:19.470"}, "8921061": {"CommentCount": "12", "ViewCount": "853", "CreationDate": "2012-01-19T04:34:59.327", "LastActivityDate": "2012-01-19T07:41:19.470", "Title": "Why is gcc 4.7.0 giving me a segfault on this code while online ideone(gcc 4.5.1) doesnt?", "AcceptedAnswerId": "8921121", "PostTypeId": "1", "Id": "8921061", "Score": "2", "Body": "<p>I have the following code (works only on gcc):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n#include &lt;typeinfo&gt;\n#include &lt;cxxabi.h&gt;\n\nconst std::string demangle (const char* name) {\n\n    int status = -4;\n    char* res = abi::__cxa_demangle(name, 0, 0, &amp;status);\n    const char* const demangled_name = (status == 0) ? res : name;\n    std::string ret_val(demangled_name);\n    std::free(res);\n\n    return ret_val;\n}\n\ntemplate &lt;typename T&gt;\nconst std::string getname (T x)\n{\n    return demangle(typeid(x).name());\n}\n\nint main()\n{\n   std::add_const&lt;int&gt;::type *p = static_cast&lt;const int *&gt;(0); \n   std::cout &lt;&lt; getname(*p) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>On my local computer (with gcc 4.7.0(experimental) it crashes (run with gdb gives a segfault). However, with ideone.com, it prints \"int\" as expected. Heres, <a href=\"http://ideone.com/hnfWh\" rel=\"nofollow\">a link to the example</a>. Also, getting rid of the template and calling <code>demangle(typeid(x).name())</code> directly fixes the problem, so what is wrong with the template?</p>\n<p><strong>EDIT</strong>\nI forgot to include the <code>type_traits</code> header (doh!) which fixed the problem, however I would still like to know what is going on a little better.</p>\n", "Tags": "<c++><gcc><c++11><segmentation-fault>", "OwnerUserId": "906773", "AnswerCount": "2"}, "8921121": {"ParentId": "8921061", "CommentCount": "6", "Body": "<pre><code>std::add_const&lt;int&gt;::type *p = static_cast&lt;const int *&gt;(0); \n</code></pre>\n<p><code>p</code> is a null pointer, and dereferencing it (i.e <code>*p</code>) invokes give undefined behaviour (UB). You are lucky that it gives segfault. And since it is <em>actually</em> UB, all compilers (and all versions) may not give segfault, for that is what UB means, i.e anything could happen.</p>\n<p>Why don't you try this instead:</p>\n<pre><code>std::cout &lt;&lt; getname(int()) &lt;&lt; std::endl;\n</code></pre>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "8921121", "Score": "3", "CreationDate": "2012-01-19T04:45:38.460", "LastActivityDate": "2012-01-19T04:45:38.460"}, "bq_ids": {"n4140": {"so_8921061_8922558_0": {"section_id": 6021, "quality": 0.9285714285714286, "length": 39}, "so_8921061_8922558_2": {"section_id": 6025, "quality": 0.875, "length": 7}, "so_8921061_8922558_1": {"section_id": 6022, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_8921061_8922558_0": {"section_id": 5789, "quality": 0.9285714285714286, "length": 39}, "so_8921061_8922558_2": {"section_id": 5793, "quality": 0.875, "length": 7}, "so_8921061_8922558_1": {"section_id": 5790, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_8921061_8922558_0": {"section_id": 7520, "quality": 0.9285714285714286, "length": 39}, "so_8921061_8922558_2": {"section_id": 7524, "quality": 0.875, "length": 7}, "so_8921061_8922558_1": {"section_id": 7521, "quality": 0.8285714285714286, "length": 29}}}});