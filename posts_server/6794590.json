post_cb({"bq_ids": {"n4140": {"so_6794590_6795706_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5313}, "so_6794590_6795706_1": {"length": 63, "quality": 0.875, "section_id": 5313}, "so_6794590_6795706_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 5313}}, "n3337": {"so_6794590_6795706_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5110}, "so_6794590_6795706_1": {"length": 63, "quality": 0.875, "section_id": 5110}, "so_6794590_6795706_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 5110}}, "n4659": {"so_6794590_6795706_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6737}, "so_6794590_6795706_1": {"length": 63, "quality": 0.875, "section_id": 6737}, "so_6794590_6795706_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 6737}}}, "33055406": {"Id": "33055406", "PostTypeId": "2", "Body": "<p>In principle, questions of encoding only matter when you output your strings by making them visible to humans, which is not a question of how the programming language is defined, as its definition deals only with coding computation. So, when you decide, whether what you see in your editor is going to be the same as what you see in the output (any kind of images, be they on the screen or in a pdf), you should ask yourselves which convention the way your user-interaction library and your operating system were coded assumes. (Here is, for example, this kind of information <a href=\"http://www.macieira.org/blog/2012/05/source-code-must-be-utf-8-and-qstring-wants-it/\" rel=\"nofollow\">for Qt5</a>: with Qt5, what you see as a user of the application and what you see as its programmer coincides, if the contents of the old-fashioned string literals for your QStrings are encoded as utf8 in your source files, unless you turn on another setting in the course of the application's execution).</p>\n<p>As a conclusion, I think Kerrek SB is right, and Damon is wrong: indeed, the methods of specifying a literal in the code ought to specify its type, not the encoding that is used in the source file for filling its contents, as the type of a literal is what concerns computation done to it. Something like <code>u\"string\"</code> is just an array of \u201cunicode codeunits\u201d (that is, values of type <code>char16_t</code>), whatever the operating system or any other service software later does to them and however their job looks for you or for another user. You just get to the problem of adding another convention for yourselves, that makes a correspondence between the \u201cmeaning\u201d of numbers under computation (namely, they present the codes of Unicode), and their representation on your screen as you work in your text editor. How and whether you as a programmer use that \u201cmeaning\u201d is another question, and how you could enforce this other correspondence is naturally going to be implementation-defined, because it has nothing to do with coding computation, only with comfortability of a tool's use.</p>\n", "LastEditorUserId": "5431230", "LastActivityDate": "2015-10-21T12:06:06.860", "Score": "0", "CreationDate": "2015-10-10T15:02:43.800", "ParentId": "6794590", "CommentCount": "0", "OwnerUserId": "5431230", "LastEditDate": "2015-10-21T12:06:06.860"}, "6794590": {"ViewCount": "2763", "Body": "<p>You can write UTF-8/16/32 string literals in C++11 by prefixing the string literal with <code>u8</code>/<code>u</code>/<code>U</code> respectively. How must the compiler interpret a UTF-8 file that has non-ASCII characters inside of these new types of string literals? I understand the standard does not specify file encodings, and that fact alone would make the interpretation of non-ASCII characters inside source code completely undefined behavior, making the feature just a tad less useful.</p>\n<p>I understand you can still escape single unicode characters with <code>\\uNNNN</code>, but that is not very readable for, say, a full Russian, or French sentence, which typically contain more than one unicode character.</p>\n<p>What I understand from various sources is that <code>u</code> should become equivalent to <code>L</code> on current Windows implementations and <code>U</code> on e.g. Linux implementations. So with that in mind, I'm also wondering what the required behavior is for the old string literal modifiers...</p>\n<p>For the code-sample monkeys:</p>\n<pre><code>string utf8string a = u8\"L'h\u00f4tel de ville doit \u00eatre l\u00e0-bas. \u00c7a c'est un fait!\";\nstring utf16string b = u\"L'h\u00f4tel de ville doit \u00eatre l\u00e0-bas. \u00c7a c'est un fait!\";\nstring utf32string c = U\"L'h\u00f4tel de ville doit \u00eatre l\u00e0-bas. \u00c7a c'est un fait!\";\n</code></pre>\n<p>In an ideal world, all of these strings produce the same content (as in: characters after conversion), but my experience with C++ has taught me that this is most definitely implementation defined and probably only the first will do what I want. </p>\n", "AcceptedAnswerId": "6794646", "Title": "How does file encoding affect C++11 string literals?", "CreationDate": "2011-07-22T18:40:27.083", "Id": "6794590", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-19T01:55:55.503", "LastEditorUserId": "500104", "LastActivityDate": "2015-10-21T12:06:06.860", "Score": "10", "OwnerUserId": "256138", "Tags": "<c++><encoding><c++11><string-literals>", "AnswerCount": "3"}, "6794646": {"Id": "6794646", "PostTypeId": "2", "Body": "<p>In GCC, use <code>-finput-charset=charset</code>:</p>\n<blockquote>\n<p id=\"so_6794590_6794646_0\">Set the input character set, used for translation from the character set of the input file to the source character set used by GCC.  If the locale does not specify, or GCC cannot get this information from the locale, the default is UTF-8.  This can be overridden by either the locale or this command line option. Currently the command line option takes precedence if there's a conflict.  charset can be any encoding supported by the system's \"iconv\" library routine.</p>\n</blockquote>\n<p>Also check out the options <code>-fexec-charset</code> and <code>-fwide-exec-charset</code>.</p>\n<p>Finally, about string literals:</p>\n<pre><code>char     a[] = \"Hello\";\nwchar_t  b[] = L\"Hello\";\nchar16_t c[] = u\"Hello\";\nchar32_t d[] = U\"Hello\";\n</code></pre>\n<p>The size modifier of the string literal (<code>L</code>, <code>u</code>, <code>U</code>) merely determines the <strong>type</strong> of the literal.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2011-07-22T18:59:28.510", "Score": "7", "CreationDate": "2011-07-22T18:45:51.013", "ParentId": "6794590", "CommentCount": "5", "OwnerUserId": "596781", "LastEditDate": "2011-07-22T18:59:28.510"}, "6795706": {"Id": "6795706", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6794590_6795706_0\">How must the compiler interpret a UTF-8 file that has non-ASCII characters inside of these new types of string literals. I understand the standard does not specify file encodings, and that fact alone would make the interpretation of non-ASCII characters inside source code completely undefined behavior, making the feature just a tad less useful.</p>\n</blockquote>\n<p>From n3290, 2.2 Phases of translation [lex.phases]</p>\n<blockquote>\n<p id=\"so_6794590_6795706_1\">Physical source file characters are mapped, in an\n  implementation-defined manner, to the basic source character set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary. The set of physical source file characters accepted is\n  implementation-defined. [<em>Here's a bit about trigraphs.</em>] Any source\n  file character not in the basic source character set (2.3) is replaced\n  by the universal-character-name that designates that character. (An\n  implementation may use any internal encoding, so long as an actual\n  extended character encountered in the source file, and the same\n  extended character expressed in the source file as a\n  universal-character-name (i.e., using the \\uXXXX notation), are\n  handled equivalently except where this replacement is reverted in a\n  raw string literal.)</p>\n</blockquote>\n<p>There are a lot of Standard terms being used to describe how an implementation deals with encodings. Here's my attempt at as somewhat simpler, step-by-step description of what happens:</p>\n<blockquote>\n<p id=\"so_6794590_6795706_2\">Physical source file characters are mapped, in an\n  implementation-defined manner, to the basic source character set [...]</p>\n</blockquote>\n<p>The issue of file encodings is handwaved; the Standard only cares about the basic source character set and leaves room for the implementation to get there.</p>\n<blockquote>\n<p id=\"so_6794590_6795706_3\">Any source\n  file character not in the basic source character set (2.3) is replaced\n  by the universal-character-name that designates that character.</p>\n</blockquote>\n<p>The basic source set is a simple list of allowed characters. <em>It is not ASCII</em> (see further). Anything not in this list is 'transformed' (conceptually at least) to a <code>\\uXXXX</code> form.</p>\n<p>So no matter what kind of literal or file encoding is used, the source code is conceptually transformed into the basic character set + a bunch of <code>\\uXXXX</code>. I say conceptually because what the implementations actually do is usually simpler, e.g. because they can deal with Unicode directly. The important part is that what the Standard call an extended character (i.e. not from the basic source set) should be indistinguishable in use from its equivalent <code>\\uXXXX</code> form. Note that C++03 is available on e.g. EBCDIC platforms, so your reasoning in terms of ASCII is flawed from the get go.</p>\n<p>Finally, the process I described happens to (non raw) string literals too. That means your code is equivalent as if you'd have written:</p>\n<pre><code>string utf8string a = u8\"L'h\\u00F4tel de ville doit \\u00EAtre l\\u00E0-bas. \\u00C7a c'est un fait!\";\nstring utf16string b = u\"L'h\\u00F4tel de ville doit \\u00EAtre l\\u00E0-bas. \\u00C7a c'est un fait!\";\nstring utf32string c = U\"L'h\\u00F4tel de ville doit \\u00EAtre l\\u00E0-bas. \\u00C7a c'est un fait!\";\n</code></pre>\n", "LastActivityDate": "2011-07-22T20:24:39.583", "CommentCount": "4", "CreationDate": "2011-07-22T20:24:39.583", "ParentId": "6794590", "Score": "4", "OwnerUserId": "726300"}});