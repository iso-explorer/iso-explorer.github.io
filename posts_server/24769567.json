post_cb({"24769786": {"ParentId": "24769567", "CommentCount": "4", "Body": "<p>All types but <code>char</code> can have padding bits (aka non-value bits).<br>\n<code>struct</code>s often even have whole padding bytes.<br>\nAlso, some types have multiple representations of the same value, and some have trap representations.</br></br></p>\n<p>For most floating point, there are numerous NaN's and two zeroes.<br>\nIn a segmented architecture, pointers with ddifferent representations might compare equal.</br></p>\n<p>Most implementations restrict <code>bool</code> to one representation for each value, which has advantages and downsides. (Ever seen <code>a</code> and <code>!a</code> both being false / true?)</p>\n<p>So, your hashing method might not be appropriate...<br>\nPerhaps do a pre-transformation for the affected primitive types?<br>\nAnd explicitly pass all members for the <code>struct</code>?</br></br></p>\n", "OwnerUserId": "3204551", "PostTypeId": "2", "Id": "24769786", "Score": "1", "CreationDate": "2014-07-15T23:25:50.663", "LastActivityDate": "2014-07-15T23:25:50.663"}, "24769605": {"ParentId": "24769567", "CommentCount": "6", "Body": "<p>There are no guarantees. You don't show where the void pointer key is used, but I have a feeling you will use a cast which has undefined behavior.</p>\n", "OwnerUserId": "2068573", "PostTypeId": "2", "Id": "24769605", "Score": "0", "CreationDate": "2014-07-15T23:04:33.870", "LastActivityDate": "2014-07-15T23:04:33.870"}, "24777237": {"ParentId": "24769567", "CommentCount": "0", "Body": "<p>The real problem is that <code>hash(x)==hash(y)</code> should hold for any <code>x==y</code>, regardless of type. I would expect the problem to be bigger for floats, as +0.0 and -0.0 are equal but have different representations.</p>\n<p>For <code>bool</code> at least you can fix the representation problem by specializing <code>hashAlg&lt;bool&gt;(bool b)</code> to just return <code>int(b)</code>. In fact, you probably want to do the same for all small types (so also char and short). Hashing them using the formula given can only produce unintended collisions.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "24777237", "Score": "0", "CreationDate": "2014-07-16T09:34:06.753", "LastActivityDate": "2014-07-16T09:34:06.753"}, "24769567": {"CommentCount": "2", "ViewCount": "152", "PostTypeId": "1", "LastEditorUserId": "577829", "CreationDate": "2014-07-15T23:01:16.860", "LastActivityDate": "2014-07-16T09:34:06.753", "Title": "C++: Are there any guarantees about the binary representation of boolean?", "AcceptedAnswerId": "24769786", "LastEditDate": "2014-07-15T23:07:46.140", "Id": "24769567", "Score": "1", "Body": "<p>I am working on a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html\" rel=\"nofollow\">new hashing system</a>. Part of the implementation requires passing a pointer to some memory location into an algorithm functor with a signature like this:</p>\n<pre><code>void\noperator()(void const* key, std::size_t len) noexcept\n{\n    unsigned char const* p = static_cast&lt;unsigned char const*&gt;(key);\n    unsigned char const* const e = p + len;\n    std::size_t h = 14695981039346656037u;\n    for (; p &lt; e; ++p)\n        h = (h ^ *p) * 1099511628211u;\n    return h;\n}\n</code></pre>\n<p>When operating on fundamental types, I just pass in a pointer to the start of the type and the size:</p>\n<pre><code>template &lt;class HASHALG&gt;\nvoid hash_append(HASHALG&amp; hashAlg, char const input)\n{\n    hashAlg(&amp;input, sizeof(input));\n}\n</code></pre>\n<p>The reason I ask if there any guarantees about the binary representation of boolean, is because I want to know if the following will behave as expected:</p>\n<pre><code>template &lt;class HASHALG&gt;\nvoid hash_append(HASHALG&amp; hashAlg, bool const input)\n{\n    hashAlg(&amp;input, sizeof(input));\n}\n</code></pre>\n<p>What I am afraid might happen is that compilers may choose that a true bool can have any non-zero integral representation. i.e.:</p>\n<pre><code>10110010 =&gt; true\n10101010 =&gt; true\n10100010 =&gt; true\n00100010 =&gt; true\n01100110 =&gt; true\n00000000 =&gt; false\n</code></pre>\n<p>If this is the case, then hashing as bytes is not valid, because the same value(<code>true</code>) can produce many different hashes.</p>\n<p>I have searched the standard, and all I can find is the following two sections:</p>\n<blockquote>\n<p id=\"so_24769567_24769567_0\">(3.9.1.7) Types bool, char, char16_t, char32_t, wchar_t, and the signed and unsigned integer types are collectively called integral types. A synonym for integral type is integer type. The representations of integral types shall define values by use of a pure binary numeration system.</p>\n<p id=\"so_24769567_24769567_1\">(4.5.6) A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true becoming one.</p>\n</blockquote>\n<p>So I know that an int will have an integral representation, and I know that when converted to an int, it will be either 1 or 0, but does the standard guarantee that it will have a fixed representation? It seems like in most cases compilers would just implement this:</p>\n<pre><code>true =&gt; 00000001\nfalse =&gt; 00000000\n</code></pre>\n<p>If there is no guarantee that this will be the representation, I don't want to get burned by some obscure edge case.</p>\n", "Tags": "<c++><algorithm><hash>", "OwnerUserId": "577829", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_24769567_24769567_0": {"section_id": 7216, "quality": 0.9032258064516129, "length": 28}, "so_24769567_24769567_1": {"section_id": 26, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_24769567_24769567_0": {"section_id": 6960, "quality": 0.9032258064516129, "length": 28}, "so_24769567_24769567_1": {"section_id": 23, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_24769567_24769567_0": {"section_id": 8725, "quality": 0.9354838709677419, "length": 29}, "so_24769567_24769567_1": {"section_id": 26, "quality": 0.9333333333333333, "length": 14}}}});