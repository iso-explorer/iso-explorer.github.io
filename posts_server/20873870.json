post_cb({"20873903": {"ParentId": "20873870", "CommentCount": "2", "CreationDate": "2014-01-01T22:21:00.177", "OwnerUserId": "2439734", "PostTypeId": "2", "Id": "20873903", "Score": "3", "Body": "<p>Return type of a method is not used in an overload resolution.</p>\n<p>Why ? Many reasons, but the simplest is because you wouldn't be able to guess what function is called when the returned value is ignored, which is perfectly legal.</p>\n<p>E.g.:</p>\n<pre><code>int f();\ndouble f();\n\n\nf(); // Which one would you call ?\n</code></pre>\n<p>Other more complicated reasons can be easily found:</p>\n<pre><code>int f();\ndouble f();\n\nvoid g(int);\nvoid g(double);\n\ng(f()); // Which f and g do you call ?\n</code></pre>\n<p>Not to mention <code>auto</code> and so on...</p>\n", "LastActivityDate": "2014-01-01T22:21:00.177"}, "20873926": {"ParentId": "20873870", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-01-01T22:25:07.813", "Score": "0", "LastEditorUserId": "560648", "LastEditDate": "2014-01-01T22:30:09.070", "Id": "20873926", "OwnerUserId": "560648", "Body": "<p>This has nothing to do with the vector; <strong>you can't overload on return type</strong>.</p>\n<blockquote>\n<p id=\"so_20873870_20873926_0\"><code>[C++11: 13.1/2]:</code> Certain function declarations cannot be overloaded:</p>\n<ul>\n<li><strong>Function declarations that differ only in the return type cannot be overloaded.</strong></li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p>As for the rationale: well, how would the compiler know which function you meant to call? It can only choose based on the arguments you give it.</p>\n<p>Your expectation is rather akin to walking into a restaurant, and initiating the following interaction:</p>\n<blockquote>\n<p id=\"so_20873870_20873926_1\"><code>&lt;mike_warren&gt;</code> Good evening. I would like my favourite meal, please.<br>\n<code>&lt;waiter&gt;</code> What is your favourite meal, sir?<br>\n<code>&lt;mike_warren&gt;</code> That information is not available to you.<br>\n<code>&lt;waiter&gt;</code> Could you provide any hints or tips that may enable me to determine which food you would like served?<br>\n<code>&lt;mike_warren&gt;</code> No, sorry. You will only find out what my favourite food is after you have served it.<br>\n<code>&lt;waiter&gt;</code> Sir, that doesn't make a lot of sense. I cannot serve your favourite food without knowing in advance what it is\u2026 only from that information will the chef know how to prepare your meal.<br>\n<code>&lt;mike_warren&gt;</code> Then I think we have a problem.<br>\n<code>&lt;waiter&gt;</code> Leave before I call the police.  </br></br></br></br></br></br></br></p>\n</blockquote>\n", "LastActivityDate": "2014-01-01T22:30:09.070"}, "20873890": {"ParentId": "20873870", "CommentCount": "2", "CreationDate": "2014-01-01T22:19:02.557", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "20873890", "Score": "3", "Body": "<p>Return type does not take part in overload resolution.</p>\n", "LastActivityDate": "2014-01-01T22:19:02.557"}, "20873870": {"CommentCount": "0", "AcceptedAnswerId": "20873903", "ClosedDate": "2014-05-06T11:14:02.377", "CreationDate": "2014-01-01T22:17:03.767", "LastActivityDate": "2014-01-01T22:38:07.170", "PostTypeId": "1", "ViewCount": "306", "Title": "Overloading a function that returns a vector so that it can return a vector of different type", "Id": "20873870", "Score": "0", "Body": "<p>I have had this problem at numerous times in my code (and now, I think there is no circumventing it): For some reason, when I try to write a method that returns a <code>std::vector&lt;long double&gt;</code> and try to overload it with the same method name that returns a different <code>std::vector</code>, say, <code>std::vector&lt;std::complex&lt;long double&gt; &gt;</code>, I get an error message akin to :\n<code>std::vector&lt;std::vector&lt;long double&gt; &gt; cannot be overloaded with std::vector&lt;long double&gt;</code>\neven though I the necessary classes #include'd. <strong>Why is this?? Is there any rationale behind this??</strong></p>\n<p>Here is some code simulating the problem:</p>\n<pre><code>#ifndef MATRIXALGORITHMS_H\n#define MATRIXALGORITHMS_H\n#include &lt;complex&gt;\n#include &lt;vector&gt;\n\nclass MatrixAlgorithms\n{\n    public:\n        MatrixAlgorithms();\n        //two algorithms that are not strictly for matrices; they are for solving quadratic and cubic polynomials\n        //quadratic method; the roots might be real, so there should be two versions of this algorithm\n        std::vector&lt;long double&gt; quadraticFormula(long double, long double, long double);\n        std::vector&lt;std::complex&lt;long double&gt; &gt; quadraticFormula(long double, long double, long double);\n    protected:\n    private:\n};\n\n#endif // MATRIXALGORITHMS_H\n</code></pre>\n<p>I tried to compile it and it gave me the aforementioned error....</p>\n", "Tags": "<c++><vector><method-overloading><complex-numbers>", "OwnerUserId": "2027839", "AnswerCount": "4"}, "20873937": {"CommentCount": "0", "CreationDate": "2014-01-01T22:26:01.570", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-01T22:38:07.170", "ParentId": "20873870", "PostTypeId": "2", "LastEditorDisplayName": "user1508519", "LastEditDate": "2017-05-23T12:03:44.403", "Id": "20873937", "Score": "1", "Body": "<p>The return type is not part of a function's signature. It doesn't really make much sense. How do you expect type deduction to work when only the return type changes? i.e.:</p>\n<pre><code>auto func = ambiguous(0.0, 0.0, 0.0); // Which one to use?\n</code></pre>\n<p>You can specify an out parameter. This is a common idiom in Microsoft:</p>\n<pre><code>quadraticFormula(long double, long double, long double, TypeOne&amp; out);\n</code></pre>\n<p>Although this will require your users to rely on Intellisense or documentation. The other option is to rename your functions.</p>\n<pre><code>quadraticFormulaOne(...);\nquadraticFormulaTwo(...);\n</code></pre>\n<p>But this can be annoying if there's a lot of them.</p>\n<hr/>\n<blockquote>\n<p id=\"so_20873870_20873937_0\">C++ (subsection 7.4.1 of Bjarne Stroustrup's \"The C++ Programming\n  Language\"): \"Return types are not considered in overload resolution.\n  The reason is to keep resolution for an individual operator or\n  function call context-independent. Consider:</p>\n<pre><code>float sqrt(float);\ndouble sqrt(double);\n\nvoid f(double da, float fla)\n{\n    float fl = sqrt(da);     // call sqrt(double)\n    double d = sqrt(da); // call sqrt(double)\n    fl = sqrt(fla);            // call sqrt(float)\n    d = sqrt(fla);             // call sqrt(float)\n}\n</code></pre>\n<p id=\"so_20873870_20873937_1\">If the return type were taken into account, it would no longer be\n  possible to look at a call of sqrt() in isolation and determine which\n  function was called.\"</p>\n</blockquote>\n<p>See <a href=\"https://stackoverflow.com/questions/442026/function-overloading-by-return-type\">Function overloading by return type?</a> for an extensive discussion.</p>\n", "OwnerDisplayName": "user1508519"}, "bq_ids": {"n4140": {"so_20873870_20873926_0": {"section_id": 557, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_20873870_20873926_0": {"section_id": 548, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_20873870_20873926_0": {"section_id": 580, "quality": 0.7142857142857143, "length": 5}}}});