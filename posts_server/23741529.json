post_cb({"bq_ids": {"n4140": {"so_23741529_23743884_1": {"length": 30, "quality": 1.0, "section_id": 455}, "so_23741529_23743884_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 300}}, "n3337": {"so_23741529_23743884_1": {"length": 30, "quality": 1.0, "section_id": 446}, "so_23741529_23743884_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 291}}, "n4659": {"so_23741529_23743884_1": {"length": 30, "quality": 1.0, "section_id": 478}, "so_23741529_23743884_0": {"length": 27, "quality": 0.7941176470588235, "section_id": 307}}}, "23743884": {"Id": "23743884", "PostTypeId": "2", "Body": "<p>gcc is correct.</p>\n<p>There are a couple of issues here which unfortunately have become conflated in your question:</p>\n<p>First, the behavior of gcc &lt; 4.7 is not fundamentally different; all versions of gcc since (at least) 4.4 reject the very similar program:</p>\n<pre><code>struct S;\n\ntemplate&lt;typename, typename&gt; struct U {};\ntemplate&lt;typename T&gt; struct U&lt;S, T&gt; {};\ntemplate&lt;typename T&gt; struct U&lt;T, S&gt; {};\n\nstruct S {\n  S() = default;\n  template&lt;typename T, typename = typename U&lt;S, T&gt;::type&gt; S(T) {}\n};\n\nint main() {   \n  S a;\n  S b(a);\n}\n</code></pre>\n<p>Note that the only real difference is that the copy-initialization is explicit rather than contained in a function call.  Clang accepts this program, by the way.</p>\n<p>Next, it's not fundamental to this issue that the copy constructor be involved (rule 12.8p6 in C++11); here's another similar program that gcc (all versions) rejects and clang accepts:</p>\n<pre><code>struct S {};\n\ntemplate&lt;typename, typename&gt; struct U {};\ntemplate&lt;typename T&gt; struct U&lt;S, T&gt; {};\ntemplate&lt;typename T&gt; struct U&lt;T, S&gt; {};\n\nvoid f(S);\ntemplate&lt;typename T&gt; typename U&lt;S, T&gt;::type f(T);\n\nint main() {   \n  S a;\n  f(a);\n}\n</code></pre>\n<p>The difference between clang and gcc is in the application of 14.8.2p8:</p>\n<blockquote>\n<p id=\"so_23741529_23743884_0\">[...] [ Note: The evaluation of the substituted types and expressions can result in side effects such as the instantiation of class template specializations and/or function template specializations, the generation of implicitly-defined functions, etc. Such side effects are not in the \"immediate context\" and can result in the program being ill-formed. \u2014 end note ]</p>\n</blockquote>\n<p>The ambiguity in the template specialization <code>ambiguous&lt;int, int&gt;</code> is outside the immediate context, so the program is ill-formed. (A supporting argument for this is that template specialization ambiguity does not appear in the succeeding list of reasons for type deduction to fail).</p>\n<p>MSVC is different again; it accepts the following program that both clang and gcc reject:</p>\n<pre><code>template&lt;typename T&gt; struct U { typedef typename T::type type; };\nstruct S {\n    S() = default;\n    template&lt;typename T, typename = typename U&lt;T&gt;::type&gt; S(T) {}\n};\n\nint main() {\n    S a;\n    S b(a);\n}\n</code></pre>\n<p>This is down to rule 12.8p6:</p>\n<blockquote>\n<p id=\"so_23741529_23743884_1\">A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv-qualified) X and either there are no other parameters or else all other parameters have default arguments. A member function template is never instantiated to produce such a constructor signature.</p>\n</blockquote>\n<p>However, in order to determine whether a member function template instantiation is a constructor ill-formed with regard to 12.8p6, it is necessary to instantiate its declaration (cf. 14.7.1p9).  Note that MSVC rejects the following program, so it isn't even consistent:</p>\n<pre><code>template&lt;typename T&gt; struct U { typedef typename T::type type; };\nstruct S {\n    S() = default;\n    template&lt;typename T&gt; S(T, typename U&lt;T&gt;::type *p = 0) {}\n};\n\nint main() {\n    S a;\n    S b(a);\n}\n</code></pre>\n<p>This has some highly amusing behavior effects; MSVC accepts the following (ill-formed) program:</p>\n<pre><code>template&lt;typename T&gt; struct U { typedef typename T::type type; };\nstruct S {\n    S() = default;\n    template&lt;typename T, typename = typename U&lt;T&gt;::type&gt; S(T) {}\n};\ntemplate&lt;typename T&gt; typename U&lt;T&gt;::type f(T) { return 0; }\n\nint main() {\n    S a;\n    S b(a);  // XXX\n    f(a);\n}\n</code></pre>\n<p>However if the copy-initialization <code>S b(a)</code> is commented out, the program is rejected!</p>\n", "LastActivityDate": "2014-05-19T17:37:40.643", "CommentCount": "2", "CreationDate": "2014-05-19T17:37:40.643", "ParentId": "23741529", "Score": "6", "OwnerUserId": "567292"}, "23741529": {"ViewCount": "401", "Body": "<p>In the following example, <code>GCC &gt;= 4.7</code> instantiates the template constructor (which you can observe by reading the error messages) although only the implicitly generated copy-constructor should be needed.</p>\n<pre><code>#include &lt;type_traits&gt;\n\n// 'ambiguous' is ambiguous for 'ambiguous&lt;int, int&gt;'\ntemplate&lt;typename A, typename B&gt; \nstruct ambiguous : std::false_type {};\n\ntemplate&lt;typename T&gt; \nstruct ambiguous&lt;int, T&gt; : std::true_type {};\n\ntemplate&lt;typename T&gt; \nstruct ambiguous&lt;T, int&gt; : std::true_type {};\n\n// quantity\ntemplate&lt;typename Type&gt;\nclass quantity\n{\npublic:\n    quantity() = default;\n\n    // Copy-constructor is implicitly created\n\n    // Template constructor\n    template&lt;\n        typename T,\n        typename = typename std::enable_if&lt;ambiguous&lt;Type, T&gt;::value&gt;::type\n    &gt;\n    quantity(quantity&lt;T&gt;) {}\n\n    template&lt;\n        typename T,\n        typename = typename std::enable_if&lt;ambiguous&lt;Type, T&gt;::value&gt;::type\n    &gt;\n    void set(quantity&lt;T&gt;) {}\n};\n\n// main\nint main()\n{   \n    quantity&lt;int&gt; a;\n    quantity&lt;float&gt; b;\n    b.set(a);\n}\n</code></pre>\n<p>The above code compiles in <code>GCC &lt; 4.7</code>, <code>clang</code> and <code>MSVS</code> (don't know which version, I used the one from <a href=\"http://rextester.com/runcode\" rel=\"noreferrer\">http://rextester.com/runcode</a>). In <code>GCC &gt;= 4.7</code> compilation fails with the following message:</p>\n<pre><code>main.cpp: In substitution of \u2018template&lt;class T, class&gt; quantity&lt;Type&gt;::quantity(quantity&lt;T&gt;) [with T = int; &lt;template-parameter-1-2&gt; = &lt;missing&gt;]\u2019:\nmain.cpp:39:12:   required from here\nmain.cpp:23:9: error: ambiguous class template instantiation for \u2018struct ambiguous&lt;int, int&gt;\u2019\n         typename = typename std::enable_if&lt;ambiguous&lt;Type, T&gt;::value&gt;::type\n         ^\nmain.cpp:9:8: error: candidates are: struct ambiguous&lt;int, T&gt;\n struct ambiguous&lt;int, T&gt; : std::true_type {};\n        ^\nmain.cpp:12:8: error:                 struct ambiguous&lt;T, int&gt;\n struct ambiguous&lt;T, int&gt; : std::true_type {};\n        ^\nmain.cpp: In function \u2018int main()\u2019:\nmain.cpp:31:10: error:   initializing argument 1 of \u2018void quantity&lt;Type&gt;::set(quantity&lt;T&gt;) [with T = int; &lt;template-parameter-2-2&gt; = void; Type = float]\u2019\n     void set(quantity&lt;T&gt;) {}\n</code></pre>\n<p>So when invoking <code>b.set(a);</code>, <code>GCC</code> apparently looks for a copy constructor and on the way instantiates the template constructor which in turn instantiates <code>ambiguous&lt;int, int&gt;</code> which is (uhm...) ambiguous.</p>\n<p><strong>Question</strong>: Is <code>GCC</code> right to instantiate the template constructor even though a copy constructor is needed?</p>\n", "AcceptedAnswerId": "23743884", "Title": "GCC: template constructor instantiated when copy-constructor needed", "CreationDate": "2014-05-19T15:23:13.807", "Id": "23741529", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-05-19T17:37:40.643", "Score": "8", "OwnerUserId": "3491462", "Tags": "<c++><gcc><copy-constructor>", "AnswerCount": "1"}});