post_cb({"29227193": {"Id": "29227193", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29226578_29227193_0\">Is it safe to use std map without a lock in multi-thread environment? Where It is guaranteed that two threads never be manipulating the same entry in the map.</p>\n</blockquote>\n<p>You can freely manipulate different existing entries in the map (only the values, as the map APIs forbid mutation of the keys) but should use some synchronisation facility to write out the changes before any other thread attempts to access or mutate them.</p>\n<p>For <code>unordered_map</code>, <code>insert</code> (even by <code>[]</code>), <code>emplace</code>, <code>erase</code>, <code>reserve</code>, <code>rehash</code> (explicit or automatic), <code>operator=</code>, <code>clear</code> can't be done safely while other threads are doing more than accessing/mutating elements that they had already found the addresses of, as the above functions can modify the underlying hash table data structure and per-bucket linked lists that track elements.  \"more than\" includes things like <code>find</code>, <code>[]</code> even on an existing element, <code>at</code>, <code>equal_range</code>, even <code>empty</code>, <code>size</code> and <code>load_factor</code> and all the <code>bucket</code> operations.</p>\n", "LastActivityDate": "2015-03-24T07:38:44.420", "CommentCount": "0", "CreationDate": "2015-03-24T07:38:44.420", "ParentId": "29226578", "Score": "1", "OwnerUserId": "410767"}, "29226724": {"Id": "29226724", "PostTypeId": "2", "Body": "<p>Threads accessing only const members of a map will not race with each other. This is specified in the requirements on library types, at the beginning of the library specification.</p>\n<p>Threads accessing non-const members can race with threads accessing const or non-const members.</p>\n<p>In other words, they're like pretty much any other object and have no extra thread safety guarantees. The standard library does not currently contain special thread safe containers.</p>\n", "LastActivityDate": "2015-03-24T07:03:48.403", "CommentCount": "1", "CreationDate": "2015-03-24T07:03:48.403", "ParentId": "29226578", "Score": "2", "OwnerUserId": "365496"}, "29226685": {"Id": "29226685", "PostTypeId": "2", "Body": "<p>As per <code>C++11 23.2.2 Container data races /2</code>:</p>\n<blockquote>\n<p id=\"so_29226578_29226685_0\">Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified concurrently.</p>\n</blockquote>\n<p>Section <code>17.6.5.9</code> simply states the limitations applied to the implementation so that <em>it</em> won't cause data races.</p>\n<p>That text basically means you have to handle your <em>own</em> race conditions, the containers themselves don't do this.</p>\n", "LastEditorUserId": "14860", "LastActivityDate": "2015-03-24T07:06:17.973", "Score": "2", "CreationDate": "2015-03-24T07:01:13.517", "ParentId": "29226578", "CommentCount": "0", "OwnerUserId": "14860", "LastEditDate": "2015-03-24T07:06:17.973"}, "29226578": {"ViewCount": "1185", "Body": "<p>Is it safe to use std map without a lock in multi-thread environment? \nWhere It is guaranteed that two threads never be manipulating the same entry in the map.</p>\n<p>There is already a question on this but I am particularly interested in the case where multiple threads are accessing different entries in the map. particularly unordered maps.</p>\n", "AcceptedAnswerId": "29226623", "Title": "thread safety in std::map", "CreationDate": "2015-03-24T06:53:34.193", "Id": "29226578", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-03-24T07:38:44.420", "Score": "0", "OwnerUserId": "3145716", "Tags": "<c++><c++11><stl>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_29226578_29226685_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 718}}, "n3337": {"so_29226578_29226685_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 707}}, "n4659": {"so_29226578_29226685_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 749}}}, "29226623": {"Id": "29226623", "PostTypeId": "2", "Body": "<p>It is safe as long as none of the threads are modifying the map. It is also safe if threads are modifying different elements of the map (provided the elements themselves don't cause race conditions by, for example, modifying some global state):</p>\n<p>In <strong>17.6.5.9 Data race avoidance</strong>, the standard library guarantees that concurrent <code>const</code> access to containers is safe (at least as far s the containers go. If the elements allow mutation via <code>const</code> access there could be data races at the element level.)</p>\n<p>In <strong>23.2.2 Container data races</strong> further guarantees are made: non-const concurrent access is safe if the modifications/reads are to different <em>elements</em> of the container<sup>1</sup>.</p>\n<p>As soon as you have one thread making modifications to the container or to the same element in the container while others read or write, you are open to race conditions and undefined behaviour.</p>\n<hr>\n<p><sup>1 With the exception of <code>std::vector&lt;bool&gt;</code></sup></p>\n</hr>", "LastEditorUserId": "661519", "LastActivityDate": "2015-03-24T07:34:33.353", "Score": "8", "CreationDate": "2015-03-24T06:55:56.810", "ParentId": "29226578", "CommentCount": "4", "OwnerUserId": "661519", "LastEditDate": "2015-03-24T07:34:33.353"}});