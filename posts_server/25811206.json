post_cb({"bq_ids": {"n4140": {"so_25811206_25814596_4": {"length": 29, "quality": 0.6041666666666666, "section_id": 73}, "so_25811206_25814596_7": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}, "so_25811206_25814596_2": {"length": 25, "quality": 0.8620689655172413, "section_id": 72}, "so_25811206_25814596_9": {"length": 38, "quality": 0.8260869565217391, "section_id": 73}}, "n3337": {"so_25811206_25814596_4": {"length": 29, "quality": 0.6041666666666666, "section_id": 68}, "so_25811206_25814596_7": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}, "so_25811206_25814596_2": {"length": 25, "quality": 0.8620689655172413, "section_id": 67}, "so_25811206_25814596_9": {"length": 38, "quality": 0.8260869565217391, "section_id": 68}}, "n4659": {"so_25811206_25814596_4": {"length": 29, "quality": 0.6041666666666666, "section_id": 75}, "so_25811206_25814596_9": {"length": 38, "quality": 0.8260869565217391, "section_id": 75}}}, "25812660": {"Id": "25812660", "PostTypeId": "2", "Body": "<p>Depending on your definition of \"similar\", you could change your <code>B</code> template definition into</p>\n<pre><code>template &lt;typename V, typename W = A&lt;V&gt;&gt;\nstruct B\n{\n};\n</code></pre>\n<p>and inside struct <code>B</code>, you can access the inner template as</p>\n<pre><code>W::template AA&lt; some_type &gt;\n</code></pre>\n<p>Your users would, however, need to provide the AA-like template wrapped in a class, just as your <code>struct A</code>.</p>\n<p>You could also lower your requirements on compiler compatibility and require MSVC 2013+.</p>\n", "LastActivityDate": "2014-09-12T16:19:43.243", "CommentCount": "0", "CreationDate": "2014-09-12T16:19:43.243", "ParentId": "25811206", "Score": "1", "OwnerUserId": "303704"}, "25814596": {"Id": "25814596", "PostTypeId": "2", "Body": "<p>Your code is not a valid C++ code. See the quotes below.</p>\n<hr>\n<h3>C++03</h3>\n<blockquote>\n<p id=\"so_25811206_25814596_0\"><strong>14.2 Names of template specializations [temp.names]</strong></p>\n<p id=\"so_25811206_25814596_1\"><em>14.2/4</em></p>\n<p id=\"so_25811206_25814596_2\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a <em>postfix-expression</em>, or after <em>nested-name-specifier</em> in a <em>qualified-id</em>, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2), the member template name must be prefixed by the keyword <code>template</code>. Otherwise the name is assumed to name a non-template.</p>\n<p id=\"so_25811206_25814596_3\"><em>14.2/5</em></p>\n<p id=\"so_25811206_25814596_4\">If a name prefixed by the keyword <code>template</code> is not the name of a member template, the program is ill-formed. [<em>Note:</em> the keyword <code>template</code> may not be applied to non-template members of class templates.] Furthermore, names of member templates shall not be prefixed by the keyword <code>template</code> if the <em>postfix-expression</em> or <em>qualified-id</em> does not appear in the scope of a template. [<em>Note:</em> just as is the case with the <code>typename</code> prefix, the <code>template</code> prefix is allowed in cases where it is not strictly necessary; i.e., when the expression on the left of the <code>-&gt;</code> or <code>.</code>, or the <em>nested-name-specifier</em> is not dependent on a <em>template-parameter</em>.]</p>\n</blockquote>\n<hr>\n<h3>C++11</h3>\n<blockquote>\n<p id=\"so_25811206_25814596_5\"><strong>14.2 Names of template specializations [temp.names]</strong></p>\n<p id=\"so_25811206_25814596_6\"><em>14.2/4</em></p>\n<p id=\"so_25811206_25814596_7\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a <em>postfix-expression</em> or after a <em>nested-name-specifier</em> in a <em>qualified-id</em>, and the object expression of the <em>postfix-expression</em> is type-dependent or the <em>nested-name-specifier</em> in <em>the qualified-id</em> refers to a dependent type, but the name is not a member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword <code>template</code>. Otherwise the name is assumed to name a non-template.</p>\n<p id=\"so_25811206_25814596_8\"><em>14.2/5</em></p>\n<p id=\"so_25811206_25814596_9\">A name prefixed by the keyword <code>template</code> shall be a <em>template-id</em> or the name shall refer to a class template. [ <em>Note:</em> The keyword <code>template</code> may not be applied to non-template members of class templates. <em>\u2014 end note</em> ] [ <em>Note:</em> As is the case with the <code>typename</code> prefix, the <code>template</code> prefix is allowed in cases where it is not strictly necessary; i.e., when the <em>nested-name-specifier</em> or the expression on the left of the <code>-&gt;</code> or <code>.</code> is not dependent on a <em>template-parameter</em>, or the use does not appear in the scope of a template. <em>\u2014 end note</em> ] [ <em>Example:</em></p>\n<pre><code>// ...\n\ntemplate &lt;class T&gt; struct B {\n  template &lt;class T2&gt; struct C { };\n};\n\n// OK: T::template C names a class template:\ntemplate &lt;class T, template &lt;class X&gt; class TT = T::template C&gt; struct D { };\n\nD&lt;B&lt;int&gt; &gt; db;\n</code></pre>\n<p id=\"so_25811206_25814596_10\"><em>\u2014 end example</em> ]</p>\n</blockquote>\n<hr>\n<h3>Standard-compliant code</h3>\n<p>So the correct syntax in this situation is:</p>\n<pre><code>template &lt;typename T&gt;\nstruct A\n{\n    template &lt;typename U&gt;\n    struct AA\n    {\n    };\n};\n\ntemplate &lt;typename V, template &lt;typename&gt; class W = A&lt;V&gt;::template AA&gt;\n//                                                      ^^^^^^^^^^^\nstruct B\n{\n};\n</code></pre>\n<p>Unfortunately <em>VC2010</em> doesn't understand the valid syntax, too.</p>\n</hr></hr></hr>", "LastEditorUserId": "3043539", "LastActivityDate": "2014-09-13T08:12:35.090", "Score": "2", "CreationDate": "2014-09-12T18:30:10.063", "ParentId": "25811206", "CommentCount": "0", "OwnerUserId": "3043539", "LastEditDate": "2014-09-13T08:12:35.090"}, "25811206": {"ViewCount": "599", "Body": "<p>I'm trying to do something like the following:</p>\n<pre><code>template &lt;typename T&gt;\nstruct A\n{\n    template &lt;typename U&gt;\n    struct AA\n    {\n    };\n};\n\ntemplate &lt;typename V, template &lt;typename&gt; class W = A&lt;V&gt;::AA&gt; // Causes C3202\nstruct B\n{\n};\n</code></pre>\n<p>But the Visual Studio 2010 compiler spits out:</p>\n<p><strong>error C3202: 'AA' : invalid default argument for template parameter '', expected a class template</strong></p>\n<p>If I replace B with the following template:</p>\n<pre><code>// Replace \"T\" with \"int\"\ntemplate &lt;typename V, template &lt;typename&gt; class W = A&lt;int&gt;::AA&gt;\nstruct B\n{\n};\n</code></pre>\n<p>the code compiles fine, but isn't what I want.  If the original isn't legal C++, is there an alternative that provides a similar interface for users of the \"B\" template?</p>\n", "AcceptedAnswerId": "25812660", "Title": "Can a template template parameter default reference other template type parameters?", "CreationDate": "2014-09-12T14:58:47.143", "Id": "25811206", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2014-09-13T08:12:35.090", "Score": "8", "OwnerUserId": "2632078", "Tags": "<c++><templates><template-templates>", "AnswerCount": "2"}});