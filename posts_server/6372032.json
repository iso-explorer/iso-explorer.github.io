post_cb({"6372032": {"CreationDate": "2011-06-16T12:45:34.833", "ViewCount": "2330", "FavoriteCount": "0", "Id": "6372032", "AcceptedAnswerId": "6374353", "Score": "5", "Title": "Dynamic initialization phase of static variables", "LastEditorUserId": "785937", "CommentCount": "4", "Body": "<p>The standard specifically states that dynamic initialization of static duration variables (namespace scope and class static members) does not have to occur before main is executed:\n \"It is implementation-defined whether or not the dynamic initialization (8.5, 9.4, 12.1, 12.6.1) of an object of namespace scope is done before the first statement of main.\" IS 3.6.2(3)\nIs it not how dynamic initialization is [always?] implemented? What better/easier way to guarantee that the objects are initialized before use? </p>\n", "Tags": "<c++>", "LastEditDate": "2011-06-16T13:19:53.110", "LastActivityDate": "2011-06-16T15:25:02.887", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "785937"}, "6372144": {"CommentCount": "4", "Body": "<p>The dynamic initialization of static duration variables (namespace scope and class static members) <strong>ALWAYS</strong> occurs before main is executed.<br>\nThe order in which these static duration variables get initialized is not defined.</br></p>\n", "CreationDate": "2011-06-16T12:52:03.383", "ParentId": "6372032", "Id": "6372144", "LastActivityDate": "2011-06-16T12:52:03.383", "PostTypeId": "2", "Score": "1", "OwnerUserId": "452307"}, "bq_ids": {"n4140": {"so_6372032_6373620_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 7153}}, "n3337": {"so_6372032_6373620_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 6897}}}, "6374353": {"CommentCount": "1", "Body": "<p>I believe the intention here is to allow dynamic load libraries. </p>\n<p>Static variables defined in the libraries are not guaranteed to be initialized before main, but must happen before anything in the specific library is used.</p>\n", "CreationDate": "2011-06-16T15:25:02.887", "ParentId": "6372032", "Id": "6374353", "LastActivityDate": "2011-06-16T15:25:02.887", "PostTypeId": "2", "Score": "4", "OwnerUserId": "597607"}, "6373188": {"CommentCount": "0", "Body": "<p>This isn't a direct answer, but it might be interesting for comparison's sake to go over how a similar language (Ada) handles this same situation.</p>\n<p>In Ada packages (the rough equivalent to namespaces) can have data with initializations which effectively have the same lifetime as the program, much like Cish statics (for simplicity we will ignore generic packages, which like templates may be created in lower scopes). The process of doing these initializations is called \"elaboration\". </p>\n<p>Ada guarantees that all packages will be elaborated at the start of the main routine. However, it is quite possible to create \"elaboration\" code that will not work if another package has not yet been elaborated yet. In general, the compiler gets to pick the elaboration order. So writing code that will not work unless the compiler happens to pick the order you need is considered a \"Bounded Error\".</p>\n<p>Obviously this isn't ideal, as it is often desirable to use non-builtin data types in other packages, and sometimes this will include some with initializations that will need to be elaborated. So Ada provides some <code>pragma</code>s to allow you to ask the compiler to elaborate some or all of your dependencies before the current package. </p>\n<p>It isn't perfect. It is quite possible to write code for which there really is no valid elaboration order. If you do this (or don't get the pragma's right and the compiler can't figure it out either), you get a <code>Program_Error</code> exception raised during elaboration. Some debuggers have trouble stepping through elaboration code, so these errors can be a major PITA to track down. Nonetheless, I really miss this facility in C++. It is the difference between being able to use complex objects in \"static\" declarations if you are careful, and having to avoid them altogether.</p>\n", "CreationDate": "2011-06-16T14:04:06.280", "ParentId": "6372032", "Id": "6373188", "LastActivityDate": "2011-06-16T14:04:06.280", "PostTypeId": "2", "Score": "2", "OwnerUserId": "29639"}, "6373620": {"LastActivityDate": "2011-06-16T14:40:05.820", "CommentCount": "0", "Body": "<p>The answer to your question is in the next sentence (in 3.6.2 of ISO/IEC 14882-2003) after the one you've quoted.</p>\n<blockquote>\n<p id=\"so_6372032_6373620_0\">It is implementation-defined whether\n  or not the dynamic initialization\n  (8.5, 9.4, 12.1, 12.6.1) of an object\n  of namespace scope is done before the\n  first statement of main. <strong>If the\n  initialization is deferred to some\n  point in time after the first\n  statement of main, it shall occur\n  before the first use of any function\n  or object defined in the same\n  translation unit as the object to be\n  initialized.</strong></p>\n</blockquote>\n<p>Obviously to make sure that some variable <code>X</code> is initialized you just have to use in function <code>main</code> (directly or indirectly) any function or variable defined in the same translation unit as the variable <code>X</code> (e.g. if you directly or indirectly use <code>X</code> in function <code>main</code> then you may be sure it is already initialized).</p>\n", "CreationDate": "2011-06-16T14:31:28.720", "LastEditDate": "2011-06-16T14:40:05.820", "ParentId": "6372032", "Id": "6373620", "LastEditorUserId": "569852", "PostTypeId": "2", "Score": "4", "OwnerUserId": "569852"}});