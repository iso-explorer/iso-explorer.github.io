post_cb({"31652888": {"ParentId": "25788127", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Explicit specializations enable the definition of a function (or class) to change based on the template arguments the template is specialized with.  They are not \"new declarations\".</p>\n<p>GCC is correct to warn for the use of <code>static</code> on the explicit specializations 7.1.1/1:</p>\n<blockquote>\n<p id=\"so_25788127_31652888_0\">A storage-class-specifier shall not be specified in an explicit specialization (14.7.3) or an explicit instantiation (14.7.2) directive.</p>\n</blockquote>\n<p>Therefore, it seems that the advice from your MISRA checker to apply 'static' is wrong for 5 and 11 and I would also question that <code>foo</code> is somehow being reused.  There is just one entity <code>foo</code> that happens to have different definitions.</p>\n<p>A function with internal linkage is not visible outside of this translation unit.  An explicit specialization is only considered once the primary template itself has been selected by overload resolution.</p>\n<p>Consider the following:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f (T);              // #1\n\ntemplate &lt;&gt;\nvoid f&lt;int*&gt; (int*);     // #2\n\ntemplate &lt;typename T&gt;\nvoid f (T*);             // #3\n\nvoid b() {\n  int * i;\n  f(i);                  // Calls #3\n}\n</code></pre>\n<p>Lookup for <code>f</code> finds two templates, #1 - <code>f(T)</code> and #3 - <code>f(T*)</code>.  <code>T</code> is deduced to <code>int*</code> for #1 and <code>int</code> for #3 (14.8.2).  Overload resolution takes place with the specializations #1 -&gt; <code>f(int*)</code> and #3 -&gt; <code>f(int*)</code>.  Neither is a best match so partial ordering (14.5.6.2) takes place.  The result of partial ordering is that #3 is more specialized than #1.  The compiler therefore chooses #3 as the best match.  <strong>NB:</strong> The explicit specialization has taken no part in any of the above steps.</p>\n<p>If there wasn't an #3.  Then #1 would have been selected as the best match by overload resolution.  Then the compiler searches the list of specialziations.  The deduced argument list <code>int*</code> matches the argument list used in the explicit specailziation and so the definition #2 is called.</p>\n<p>Regarding the quoted paragraph:</p>\n<blockquote id=\"so_25788127_31652888_1\">\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1), only function declarations with external linkage from the template definition context are found.</li>\n</ul>\n</blockquote>\n<p>This restriction originated back when templates could be exported (C++ '03 14/6).  The idea was to allow templates to be defined outside of the current translation unit.  This lookup restriction would have helped ensure that changing a non-exported template to be exported would not result in a different meaning program.</p>\n<p>Regarding your question on what this means for static function templates and C++ '03, well the reality is that only one compiler vendor that I know of ever implemented exported templates in full.  There's a good chance that most compiler vendors followed the C++ 11 advice for a long time now anyway.  From a MISRA compliance perspective, the best option is to follow the advice in <a href=\"https://stackoverflow.com/users/201787/metal\">metal's</a> comment to your question.  Place the template in an unnamed namespace.</p>\n<p>In C++ '03, the names will be uncallable from outside of the translation unit and for C++ '11 onwards they have internal linkage implicitly (3.5/4):</p>\n<blockquote>\n<p id=\"so_25788127_31652888_2\">An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has\n  internal linkage.</p>\n</blockquote>\n", "OwnerUserId": "11698", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:55.947", "Id": "31652888", "Score": "0", "CreationDate": "2015-07-27T12:16:54.597", "LastActivityDate": "2015-07-27T12:16:54.597"}, "bq_ids": {"n4140": {"so_25788127_31652888_1": {"section_id": 224, "quality": 0.75, "length": 12}, "so_25788127_31652888_2": {"section_id": 7137, "quality": 1.0, "length": 11}, "so_25788127_31652888_0": {"section_id": 5391, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_25788127_31652888_1": {"section_id": 217, "quality": 0.75, "length": 12}, "so_25788127_31652888_2": {"section_id": 6881, "quality": 1.0, "length": 11}, "so_25788127_25788127_0": {"section_id": 217, "quality": 0.6190476190476191, "length": 13}, "so_25788127_31652888_0": {"section_id": 5185, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_25788127_31652888_1": {"section_id": 232, "quality": 0.75, "length": 12}, "so_25788127_31652888_2": {"section_id": 8638, "quality": 1.0, "length": 11}, "so_25788127_31652888_0": {"section_id": 6817, "quality": 0.7777777777777778, "length": 7}}}, "25788127": {"CommentCount": "5", "ViewCount": "521", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-11T12:59:18.800", "LastActivityDate": "2017-03-07T10:16:53.597", "Title": "Static function template and MISRA C++", "AcceptedAnswerId": "31652888", "LastEditDate": "2017-05-23T12:17:14.027", "Id": "25788127", "Score": "3", "Body": "<p>The following function template with specializations should be used within the same <code>.cpp</code> file only, so I\u2019d like to make it <code>static</code>. The following code compiles (without warnings) using both MS Visual C++ 2008 and GCC 4.8.1 and works as intended. (Adding <code>static</code> to the beginning of lines 5 and 11 would cause GCC to issue an error but not MSVC.)</p>\n<pre><code> 1  template &lt;class T&gt;\n 2  static bool foo(const T param);\n 3\n 4  template &lt;&gt;\n 5  bool foo&lt;int&gt;(const int param)\n 6  {\n 7      return doSomethingWithInt(param);\n 8  }\n 9\n10  template &lt;&gt;\n11  bool foo&lt;bool&gt;(const bool param)\n12  {\n13      return doSomethingWithBool(param);\n14  }\n</code></pre>\n<p>However, MISRA C++ checker complains:</p>\n<ul>\n<li>(MISRA2008.3-3-2) Apply the static keyword to declaration of 'foo' (1)</li>\n<li>(MISRA2008.3-3-2) Apply the static keyword to declaration of 'foo' (5)</li>\n<li>(MISRA2008.2-10-5-b) Identifier 'foo' is being reused (5)</li>\n<li>(MISRA2008.3-3-2) Apply the static keyword to declaration of 'foo' (11)</li>\n<li>(MISRA2008.2-10-5-b) Identifier 'foo' is being reused (11)</li>\n</ul>\n<p>I tried to find out what\u2019s wrong and found a hint in a <a href=\"https://stackoverflow.com/a/17662745/711006\">C++ standard quote</a>:</p>\n<blockquote>\n<p id=\"so_25788127_25788127_0\">For a function call that depends on a template parameter, if the\n  function name is an unqualified-id but not a template-id, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1), only\n  function declarations with <strong>external linkage</strong> from the template\n  definition context are found.</li>\n</ul>\n</blockquote>\n<p>Does it mean that the compilers discard the <code>static</code> specification and there is no way to actually make static function templates in C++03?</p>\n", "Tags": "<c++><templates><static><c++03><misra>", "OwnerUserId": "711006", "AnswerCount": "1"}});