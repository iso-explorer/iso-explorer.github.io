post_cb({"bq_ids": {"n4140": {"so_24593942_24594393_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7128}}, "n3337": {"so_24593942_24594393_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6872}}, "n4659": {"so_24593942_24594393_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 8629}}}, "24594393": {"Id": "24594393", "PostTypeId": "2", "Body": "<p>In the standard, at:</p>\n<blockquote>\n<p id=\"so_24593942_24594393_0\"><strong>\u00a73.4.5/3</strong></p>\n<p id=\"so_24593942_24594393_1\">If the unqualified-id is ~type-name, the type-name is looked up in the context of the entire postfix-expression.</p>\n</blockquote>\n<p>therefore it would seem that <code>~string</code> should be looked up in the context of the <code>std::</code> namespace.</p>\n<p>In fact, considering that a corresponding home-made version works as follows on both GCC and Clang:</p>\n<pre><code>namespace STD {\nclass STRING {};\n}\n\nint main() {\n    STD::STRING* a = new STD::STRING();\n    a-&gt;~STRING();\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3cfc60d477795753\"><kbd>Live demo with clang++</kbd></a> <a href=\"http://coliru.stacked-crooked.com/a/53863f1188888286\"><kbd>Live demo with g++</kbd></a></p>\n<p>I'll go ahead and say this is most likely a bug.</p>\n<hr>\n<p>Apparently, given that <code>std::string</code> is really <code>std::basic_string&lt;char&gt;</code> if you call:</p>\n<pre><code>a-&gt;~basic_string();\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/592087ecc3f4c0aa\"><kbd>Live demo with clang++</kbd></a> <a href=\"http://coliru.stacked-crooked.com/a/2cb7a19fb4098bf5\"><kbd>Live demo with g++</kbd></a></p>\n<p>then everything compiles fine.</p>\n<p>I still remain of the idea that this a bug, considering that the following example (taken from the standard), shows that <code>typedef</code>s should also work:</p>\n<pre><code>struct B {\n    virtual ~B() { }\n};\n\nstruct D : B {\n    ~D() { } \n};\n\nD D_object;\n\ntypedef B B_alias;\n\nB* B_ptr = &amp;D_object;\n\nvoid f() {\nD_object.B::~B();\n    B_ptr-&gt;~B();\n    B_ptr-&gt;~B_alias();\n    B_ptr-&gt;B_alias::~B();\n    B_ptr-&gt;B_alias::~B_alias();\n}\n</code></pre>\n<p>This notion, together with \u00a73.4.5/3 should guarantee that:</p>\n<pre><code>p-&gt;~string();\n</code></pre>\n<p>should work.</p>\n</hr>", "LastEditorUserId": "493122", "LastActivityDate": "2014-07-06T10:16:05.027", "Score": "11", "CreationDate": "2014-07-06T09:23:24.777", "ParentId": "24593942", "CommentCount": "6", "LastEditDate": "2014-07-06T10:16:05.027", "OwnerUserId": "493122"}, "24593942": {"ViewCount": "2117", "Body": "<p>I am surprised that the following simple code won't compile (with gcc, version 4.8.1)</p>\n<pre><code>#include &lt;string&gt;\nvoid test()\n{\n  std::string* p = new std::string(\"Destruct me\");\n  p-&gt;std::~string();\n}\n</code></pre>\n<p>It says: error: scope \u2018std\u2019 before \u2018~\u2019 is not a class-name. Yet reading the standard, I would say the syntax says it should be \"<em>postfix-expresssion</em> -&gt; <em>pseudo-constructor-name</em>\", where <em>pseudo-constructor-name</em> can be of the form \"<em>nested-name-specifier</em> ~ <em>type-name</em>\", and <em>nested-name-specifier</em> can be \"<em>identifier</em>::\".</p>\n<p>Leaving out \"std::\" leads to the complaint that a class name was expected before the left paren, and putting it after the tilde to the complaint that a class name was expected before \"::\". After some trying I found that it will compile when written <code>p-&gt;std::string::~string();</code> (but not when one writes <code>p-&gt;std::string::~std::string();</code> instead). But qualifying the destructor with its own type name is not a neutral operation; I gather from the example in 12.4:13 of the standard (but curiously not from the normative text) that this forces the destructor of the exact static (base) class to be called, rather than as a virtual function that of (the most derived type of) the actual object pointed to. Here it makes no difference, but in similar cases it would; why would the syntax force exclusively using the static type?</p>\n<p>However, with clang instead of gcc even the mentioned variant gives a syntax error. The error messages of clang are more amusing though, if you're in the mood for for this kind of humour when reading error messages: for <code>p-&gt;std::string::~string();</code> it gives \"expected the class name after '~' to name a destructor\" (and so it does; one wonders which kind of class names would not name a destructor if prefixed by a tilde), and for my initial trial <code>p-&gt;std::~string()</code> it retorts \"qualified member access refers to a member in namespace 'std'\" (again one wonders what is wrong with that; indeed the destructor to be called lives in the namespace 'std'). I've tried all 8 reasonable combinations (std:: and/or string:: before the tilde, and/or std:: after it) and none of them compile with clang.</p>\n<p>I can make it compile, even with clang, using <code>using std::string;</code>. But what I find curious is that I can find no indication in the standard that such a declaration was intended to be necessary in such cases.In fact I can find nothing that addresses the issue of calling the destructor of a namespace-qualified class at all. Am I missing something obvious?</p>\n<p>As a final note, I'd like to add that it strikes me as odd that one have to use a namespace qualification at all when calling a destructor. Since this is member access from a well specified object (here <code>*p</code>) shouldn't argument-dependent lookup make explicitly qualifying the namespace unnecessary?</p>\n", "AcceptedAnswerId": "24594393", "Title": "How to explicitly call a namespace-qualified destructor?", "CreationDate": "2014-07-06T08:11:46.380", "Id": "24593942", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-07-06T08:33:56.930", "LastEditorUserId": "1436796", "LastActivityDate": "2014-07-06T10:16:05.027", "Score": "21", "OwnerUserId": "1436796", "Tags": "<c++><g++><standards><clang++>", "AnswerCount": "1"}});