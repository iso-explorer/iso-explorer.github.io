post_cb({"6084137": {"CommentCount": "12", "CreationDate": "2011-05-21T20:03:40.900", "PostTypeId": "1", "AcceptedAnswerId": "6084177", "LastEditorUserId": "4370109", "LastActivityDate": "2015-07-30T18:35:20.450", "LastEditDate": "2015-07-30T18:35:20.450", "ViewCount": "206", "FavoriteCount": "1", "Title": "Why this program doesn't consume memory?", "Id": "6084137", "Score": "1", "Body": "<p>It's bothering me what <code>delete []</code> actually does, so I just tried some code and I was shocked with the results </p>\n<p>Test #1:</p>\n<pre><code>int main()\n{\n    int *d;\n    while(true)\n    {\n        d = new int[10];\n        delete []d;\n    }\n}\n</code></pre>\n<p>The program doesn't consume any memory at all, as expected.</p>\n<p>Test #2:</p>\n<pre><code>int main()\n{\n    int *d;\n    while(true)\n    {\n        d = new int[10];\n        delete [](d + 5);\n    }\n}\n</code></pre>\n<p>Though in every loop there should be at least 20 bytes (for the five ints it reserves at the beginning of array) reserved which are not deleted this program also doesn't consume any memory!</p>\n<p>Test #3:</p>\n<pre><code>int main()\n{\n    int *d;\n    while(true)\n    {\n        d = new int[10];\n        delete []d;\n        *d=1;\n    }\n}\n</code></pre>\n<p>This one caused access violation as expected (seems all the memory is deleted after <code>delete []d</code>).</p>\n<p>Test #4:        </p>\n<pre><code>int main()\n{\n    int *d;\n    while(true)\n    {\n        d = new int[10];\n        delete [](d+5);\n        *d=1;\n    }\n}\n</code></pre>\n<p>This one was the most amazing, though the while doesn't consume any memory the program doesn't produce any access violations either, I'm just wondering where *d is storing it's data?</p>\n<p>(By the way all programs are compiled using no-optimization!)</p>\n<p>Now the main question :</p>\n<p>What if I allocated an array and I've done working with half of it, can't I by any chance release that half and keep the other half?</p>\n", "Tags": "<c++><arrays><delete-operator>", "OwnerUserId": "651687", "AnswerCount": "5"}, "6084202": {"ParentId": "6084137", "CommentCount": "0", "Body": "<pre><code>delete [](d + 5);\n</code></pre>\n<p>It sounds like you are expecting this to free just part of the memory allocated by <code>new int[10]</code>.</p>\n<p>This is not the case, it causes <em>undefined behavior</em> and could cause anything to happen.</p>\n<p>On some memory managers, if you ask them to free a block by passing a pointer, if you don't pass a pointer to the beginning of the block then they may free the entire block that <em>contains</em> the pointer that you pass. This may well be happening in your case.</p>\n<p>Another consideration is that <code>new int[10]</code> does not initialize the memory allocated so the operating system can just allocate some address space and doesn't need to back the allocation with any physical storage. This means that even if you call <code>new int[10]</code> in a loop without any <code>delete[]</code> you may see no rising memory usage in many memory monitoring tools, even up to the point when <code>new[]</code> throws a <code>std::bad_alloc</code> exception when you exhaust the logicalbvg address space. (This is likely to take some time just allocating 10 bytes at a time.)</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "6084202", "Score": "1", "CreationDate": "2011-05-21T20:14:32.773", "LastActivityDate": "2011-05-21T20:14:32.773"}, "6084178": {"ParentId": "6084137", "CommentCount": "4", "Body": "<p>Are you running these tests under a release build?  Have you looked at the generated assembly instructions?  How are you measuring memory consumption?  You're ony allocating 40 bytes and then immediately clearing it.</p>\n<p>Also, doing something like <code>delete [](d + 5)</code> is invoking undefined behavior.  You need to pass in the pointer returned by <code>operator new</code> in order for <code>delete</code> to work correctly.</p>\n", "OwnerUserId": "1053", "PostTypeId": "2", "Id": "6084178", "Score": "0", "CreationDate": "2011-05-21T20:09:26.460", "LastActivityDate": "2011-05-21T20:09:26.460"}, "6084177": {"ParentId": "6084137", "LastEditDate": "2011-05-21T20:25:13.373", "CommentCount": "0", "CreationDate": "2011-05-21T20:09:23.760", "OwnerUserId": "308661", "LastEditorUserId": "308661", "PostTypeId": "2", "Id": "6084177", "Score": "5", "Body": "<blockquote>\n<p id=\"so_6084137_6084177_0\">it's bothering me what <code>delete []</code>\n  actually does</p>\n</blockquote>\n<p>You're not supposed to worry about what <code>delete[]</code> actually does. It's for all intents and purposes a black box with certain rules on how to use it properly. The only time you need to worry about what it needs to actually do is if you're writing a compiler or a C++ runtime (e.g. operating systems, etc.)</p>\n<p>With respect to those \"certain rules on how to use it properly\", Test #2 and #4 invokes undefined behavior:</p>\n<blockquote>\n<p id=\"so_6084137_6084177_1\"><strong>ISO C++ 2003 Standard 5.3.5 Delete [expr.delete]</strong></p>\n<p id=\"so_6084137_6084177_2\"><em>1</em> The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.</p>\n</blockquote>\n<pre><code>    delete-expression:\n        ::opt delete cast-expression\n        ::opt delete [ ] cast-expression\n</code></pre>\n<blockquote>\n<p id=\"so_6084137_6084177_3\">The first alternative is for non-array\n  objects, and the second is for arrays.\n  The operand shall have a pointer type,\n  or a class type having a single\n  conversion function (12.3.2) to a\n  pointer type. The result has type\n  void.</p>\n<p id=\"so_6084137_6084177_4\"><em>2</em> If the operand has a class type, the\n  operand is converted to a pointer type\n  by calling the above-mentioned\n  conversion function, and the converted\n  operand is used in place of the\n  original operand for the remainder of\n  this section. In either alternative,\n  if the value of the operand of delete\n  is the null pointer the operation has\n  no effect. In the first alternative\n  (delete object), the value of the\n  operand of delete shall be a pointer\n  to a non-array object or a pointer to\n  a sub-object (1.8) representing a base\n  class of such an object (clause 10).\n  If not, the behavior is undefined.\n  <strong>In the second alternative (delete array), the value of the operand of\n  delete shall be the pointer value\n  which resulted from a previous array\n  new-expression. If not, the\n  behavior is undefined.</strong> [Note: this\n  means that the syntax of the\n  delete-expression must match the type\n  of the object allocated by new, not\n  the syntax of the new-expression. ]</p>\n</blockquote>\n<p>\"Undefined Behavior\" means that <strong>anything can happen</strong>, including the behavior you just described.</p>\n<p>These expressions that you have in Tests #2 and #4 are in violation of 5.3.5/2 and will cause undefined behavior (Test #3 will also cause undefined behavior, but for a different reason).</p>\n<pre><code>d = new int[10];\ndelete [](d + 5);\n</code></pre>\n<p>The <code>delete[]</code> line violates 5.3.5/2 because pointer value you pass to <code>delete[]</code> wasn't the same value that was given to you from <code>new int[]</code>.</p>\n<p>So if the <code>new int[]</code> command gives you <code>0xA01D2CE9</code> and you pass in <code>0xA01D2CE9 + 5</code> to <code>delete[]</code>, you cannot possibly reason about or predict what will happen because <em>you have broken the rules of the language</em>. What will actually happen will be dependent on how the compiler and/or the operating system handles <code>new[]</code> and <code>delete[]</code>. That can range from nothing wrong happening to completely crashing your system, and everywhere in between.</p>\n<p>In other words, just don't write things like <code>delete [](d + 5);</code>.</p>\n", "LastActivityDate": "2011-05-21T20:25:13.373"}, "6084151": {"ParentId": "6084137", "CommentCount": "0", "Body": "<pre><code>delete [](d + 5);\n</code></pre>\n<p>(from your test #2) is definitively something you should <strong>not</strong> do, this will corrupt the memory if not segfault. It actually segfaults on my platform.</p>\n<p>The outcome of your tests will depend on many things, among other things the platform your run these tests on, the internals of <code>new/delete</code> etc.</p>\n", "OwnerUserId": "288875", "PostTypeId": "2", "Id": "6084151", "Score": "1", "CreationDate": "2011-05-21T20:06:06.477", "LastActivityDate": "2011-05-21T20:06:06.477"}, "6084159": {"ParentId": "6084137", "LastEditDate": "2013-01-03T09:43:58.497", "CommentCount": "3", "CreationDate": "2011-05-21T20:07:00.047", "OwnerUserId": "649233", "LastEditorUserId": "356440", "PostTypeId": "2", "Id": "6084159", "Score": "2", "Body": "<p>When you say \"doesn't consume any memory\", are you talking about when viewed inside of a \"task-manager\" style performance monitor?  Because if-so, 40-bytes will not show up as \"memory usage\" ... you're going to have to allocate a lot more memory for it to show up in most standard process performance monitors.</p>\n", "LastActivityDate": "2013-01-03T09:43:58.497"}, "bq_ids": {"n4140": {"so_6084137_6084177_4": {"section_id": 6106, "quality": 0.8243243243243243, "length": 61}, "so_6084137_6084177_3": {"section_id": 6105, "quality": 0.64, "length": 16}, "so_6084137_6084177_2": {"section_id": 6105, "quality": 0.9, "length": 9}}, "n3337": {"so_6084137_6084177_4": {"section_id": 5872, "quality": 0.8243243243243243, "length": 61}, "so_6084137_6084177_3": {"section_id": 5871, "quality": 0.84, "length": 21}, "so_6084137_6084177_2": {"section_id": 5871, "quality": 0.9, "length": 9}}, "n4659": {"so_6084137_6084177_4": {"section_id": 7603, "quality": 0.8243243243243243, "length": 61}, "so_6084137_6084177_3": {"section_id": 7602, "quality": 0.64, "length": 16}, "so_6084137_6084177_2": {"section_id": 7602, "quality": 0.9, "length": 9}}}});