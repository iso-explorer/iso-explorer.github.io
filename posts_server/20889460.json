post_cb({"20889599": {"Id": "20889599", "PostTypeId": "2", "Body": "<p>With clang you can do e.g.:</p>\n<pre><code> clang -Imyinclude -P -E -nostdinc -nobuiltininc main.cpp\n</code></pre>\n<p>There does not seem to be a way to preserve the system <code>#include</code> lines it cannot find though.</p>\n<p>This doesn't work for gcc, as its preprocessor will stop when using <code>-nostdinc</code> and it can't find an <code>#included</code> header file.</p>\n", "LastEditorUserId": "126769", "LastActivityDate": "2014-01-02T18:51:04.393", "Score": "2", "CreationDate": "2014-01-02T18:43:26.277", "ParentId": "20889460", "CommentCount": "0", "OwnerUserId": "126769", "LastEditDate": "2014-01-02T18:51:04.393"}, "bq_ids": {"n4140": {"so_20889460_38163793_0": {"length": 15, "quality": 1.0, "section_id": 518}, "so_20889460_38163793_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 532}, "so_20889460_38163793_2": {"length": 16, "quality": 1.0, "section_id": 531}}, "n3337": {"so_20889460_38163793_0": {"length": 15, "quality": 1.0, "section_id": 509}, "so_20889460_38163793_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 523}, "so_20889460_38163793_2": {"length": 16, "quality": 1.0, "section_id": 522}}, "n4659": {"so_20889460_38163793_0": {"length": 15, "quality": 1.0, "section_id": 539}, "so_20889460_38163793_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 553}, "so_20889460_38163793_2": {"length": 16, "quality": 1.0, "section_id": 552}}}, "20889460": {"ViewCount": "1532", "Body": "<p>I want the preprocessor to read in the includes of local headers, but ignore the includes of system headers.  To put it another way, how do I get the preprocessor to skip over preprocessing directives of the form:</p>\n<pre><code>#include &lt;h-char-sequence&gt; new-line\n</code></pre>\n<p>but still process directives of the form:</p>\n<pre><code>#include \"q-char-sequence\" new-line\n</code></pre>\n<hr>\n<p>As a code example, observe the following file:</p>\n<pre><code>#include &lt;iostream&gt;     //system\n#include \"class_a.hpp\"  //local\n#include &lt;string&gt;       //system\n#include \"class_b.hpp\"  //local\n\nint main() {}\n</code></pre>\n<p>how can I get the output of the preprocessor to be:</p>\n<pre><code>#include &lt;iostream&gt;\nclass A{};\n#include &lt;string&gt;\nclass B{};\n\nint main() {}\n</code></pre>\n<hr>\n<p>Local include files may include other local include files, and the preprocessor would recursively bring them all in; much like it normally does.  It would still print all of the system file headers, but it would not bring in their contents.</p>\n<hr>\n<p>on gcc, my call looks like this so far: <code>g++ -E -P main.cpp</code>, where <code>-E</code> stops after preprocessing, and <code>-P</code> excludes the generation of line markers.<br>\nI can't seem to find a flag that excludes the processing of system headers.</br></p>\n</hr></hr></hr>", "AcceptedAnswerId": "38163793", "Title": "How do I run the preprocessor on local headers only?", "CreationDate": "2014-01-02T18:33:42.227", "Id": "20889460", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-07-02T18:26:14.693", "LastEditorUserId": "4370109", "LastActivityDate": "2016-10-05T00:45:56.450", "Score": "18", "OwnerUserId": "908939", "Tags": "<c++><gcc><clang><c-preprocessor><header-files>", "AnswerCount": "3"}, "20889690": {"Id": "20889690", "PostTypeId": "2", "Body": "<p>You could put a <code>#define SYSTEM_HEADERS 0</code> in a configuration header  and do it like this</p>\n<pre><code>#include \"config.h\" // the configuration header\n#include \"class_a.hpp\"\n#include \"class_b.hpp\"\n\n#if SYSTEM_HEADERS // which is #if 0\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#endif\n</code></pre>\n<p>and when you want system headers you could make it <code>#define SYSTEM_HEADERS 1</code> which will include system headers.</p>\n", "LastEditorUserId": "1794792", "LastActivityDate": "2014-01-02T18:56:10.207", "Score": "1", "CreationDate": "2014-01-02T18:48:57.197", "ParentId": "20889460", "CommentCount": "1", "OwnerUserId": "1794792", "LastEditDate": "2014-01-02T18:56:10.207"}, "38163793": {"Id": "38163793", "PostTypeId": "2", "Body": "<p>How much effort are you willing to go to?  There's an obnoxiously obscure way to do it but it requires you to set up a dummy directory to hold surrogates for the system headers.  OTOH, it doesn't require any changes in any of your source code.  The same technique works equally well for C code.</p>\n<h3>Setup</h3>\n<p>Files:</p>\n<pre><code>./class_a.hpp\n./class_b.hpp\n./example.cpp\n./system-headers/iostream\n./system-headers/string\n</code></pre>\n<p>The 'system headers' such as <code>./system-headers/iostream</code> contain a single line (there is no <code>#</code> on that line!):</p>\n<pre><code>include &lt;iostream&gt;\n</code></pre>\n<p>The class headers each contain a single line like:</p>\n<pre><code>class A{};\n</code></pre>\n<p>The contents of <code>example.cpp</code> are what you show in the question:</p>\n<pre><code>#include &lt;iostream&gt;     //system\n#include \"class_a.hpp\"  //local\n#include &lt;string&gt;       //system\n#include \"class_b.hpp\"  //local\n\nint main() {}\n</code></pre>\n<h3>Running the C preprocessor</h3>\n<p>Running the C preprocessor like this produces the output shown:</p>\n<pre><code>$ cpp -Dinclude=#include -I. -Isystem-headers example.cpp\n# 1 \"example.cpp\"\n# 1 \"&lt;built-in&gt;\"\n# 1 \"&lt;command-line&gt;\"\n# 1 \"example.cpp\"\n# 1 \"system-headers/iostream\" 1\n #include &lt;iostream&gt;\n# 2 \"example.cpp\" 2\n# 1 \"class_a.hpp\" 1\nclass A{};\n# 3 \"example.cpp\" 2\n# 1 \"system-headers/string\" 1\n #include &lt;string&gt;\n# 4 \"example.cpp\" 2\n# 1 \"class_b.hpp\" 1\nclass B{};\n# 5 \"example.cpp\" 2\n\nint main() {}\n$\n</code></pre>\n<p>If you eliminate the <code># n</code> lines, that output is:</p>\n<pre><code>$ cpp -Dinclude=#include -I. -Isystem-headers example.cpp | grep -v '^# [0-9]'\n #include &lt;iostream&gt;\nclass A{};\n #include &lt;string&gt;\nclass B{};\n\nint main() {}\n$\n</code></pre>\n<p>which, give or take the space at the beginning of the lines containing <code>#include</code>, is what you wanted.</p>\n<h3>Analysis</h3>\n<p>The <code>-Dinclude=#include</code> argument is equivalent to <code>#define include #include</code>.  When the preprocessor generates output from a macro, even if it looks like a directive (such as <code>#include</code>), it is not a preprocessor directive.  Quoting the C++11 standard ISO/IEC 14882:2011 (not that this has changed between versions AFAIK \u2014 and is, verbatim, what it says in the C11 standard, ISO/IEC 9899:2011 too, in \u00a76.10.3):</p>\n<blockquote>\n<h3>\u00a716.3 Macro replacement</h3>\n<p id=\"so_20889460_38163793_0\">\u00b68 If a <code>#</code> preprocessing token, followed by an identifier, occurs lexically at the point at which a preprocessing directive could begin, the identifier is not subject to macro replacement.</p>\n<p id=\"so_20889460_38163793_1\">\u00a716.3.4 Rescanning and further replacement</p>\n<p id=\"so_20889460_38163793_2\">\u00b62 If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file\u2019s preprocessing tokens), it is not replaced. \u2026</p>\n<p id=\"so_20889460_38163793_3\">\u00b63 The resulting completely macro-replaced preprocessing token sequence is not processed as a preprocessing directive even if it resembles one, \u2026</p>\n</blockquote>\n<p>When the preprocessor encounters <code>#include &lt;iostream&gt;</code>, it looks in the current directory and finds no file, then looks in <code>./system-headers</code> and finds the file <code>iostream</code> so it processes that into the output.  It contains a single line, <code>include &lt;iostream&gt;</code>.  Since <code>include</code> is a macro, it is expanded (to <code>#include</code>) but further expansion is prevented, and the <code>#</code> is not processed as a directive because of \u00a716.3.4\u00a0\u00b63.  Thus, the output contains <code>#include &lt;iostream&gt;</code>.</p>\n<p>When the preprocessor encounters <code>#include \"class_a.hpp\"</code>, it looks in the current directory and finds the file and includes its contents in the output.</p>\n<p>Rinse and repeat for the other headers.  If <code>class_a.hpp</code> contained <code>#include &lt;iostream&gt;</code>, then that ends up expanding to <code>#include &lt;iostream&gt;</code> again (with the leading space).  If your <code>system-headers</code> directory is missing any header, then the preprocessor will search in the normal locations and find and include that.  If you use the compiler rather than <code>cpp</code> directly, you can prohibit it from looking in the system directories with <code>-nostdinc</code> \u2014 so the preprocessor will generate an error if <code>system-headers</code> is missing a (surrogate for a) system header.</p>\n<pre><code>$ g++ -E -nostdinc -Dinclude=#include -I. -Isystem-headers example.cpp | grep -v '^# [0-9]'\n #include &lt;iostream&gt;\nclass A{};\n #include &lt;string&gt;\nclass B{};\n\nint main() {}\n$\n</code></pre>\n<p>Note that it is very easy to generate the surrogate system headers:</p>\n<pre><code>for header in algorithm chrono iostream string \u2026\ndo echo \"include &lt;$header&gt;\" &gt; system-headers/$header\ndone\n</code></pre>\n<p>JFTR, testing was done on Mac OS X 10.11.5 with GCC 6.1.0.  If you're using GCC (the GNU Compiler Collection, with leading example compilers <code>gcc</code> and <code>g++</code>), your mileage shouldn't vary very much with any plausible alternative version.</p>\n<p>If you're uncomfortable using the macro name <code>include</code>, you can change it to anything else that suits you \u2014 <code>syzygy</code>, <code>apoplexy</code>, <code>nadir</code>, <code>reinclude</code>, \u2026  \u2014 and change the surrogate headers to use that name, and define that name on the preprocessor (compiler) command line.  One advantage of <code>include</code> is that it's improbable that you have anything using that as a macro name.</p>\n<h3>Automatically generating surrogate headers</h3>\n<p><a href=\"https://stackoverflow.com/users/196561/osgx\">osgx</a> <a href=\"https://stackoverflow.com/questions/20889460/how-do-i-run-the-preprocessor-on-local-headers-only#comment63755844_38163793\">asks</a>:</p>\n<blockquote>\n<p id=\"so_20889460_38163793_4\">How can we automate the generation of mock system headers?</p>\n</blockquote>\n<p>There are a variety of options. One is to analyze your code (with <code>grep</code> for example) to find the names that are, or might be, referenced and generate the appropriate surrogate headers.  It doesn't matter if you generate a few unused headers \u2014 they won't affect the process. Note that if you use <code>#include &lt;sys/wait.h&gt;</code>, the surrogate must be <code>./system-headers/sys/wait.h</code>; that slightly complicates the shell code shown, but not by very much. Another way would look at the headers in the system header directories (<code>/usr/include</code>, <code>/usr/local/include</code>, etc) and generate surrogates for the headers you find there.\nFor example, <code>mksurrogates.sh</code> might be:</p>\n<pre><code>#!/bin/sh\n\nsysdir=\"./system-headers\"\nfor header in \"$@\"\ndo\n    mkdir -p \"$sysdir/$(dirname $header)\"\n    echo \"include &lt;$header&gt;\" &gt; \"$sysdir/$header\"\ndone\n</code></pre>\n<p>And we can write <code>listsyshdrs.sh</code> to find the system headers referenced in source code under a named directory:</p>\n<pre><code>#!/bin/sh\n\ngrep -h -e '^[[:space:]]*#[[:space:]]*include[[:space:]]*&lt;[^&gt;]*&gt;' -r \"${@:-.}\" |\nsed 's/^[[:space:]]*#[[:space:]]*include[[:space:]]*&lt;\\([^&gt;]*\\)&gt;.*/\\1/' |\nsort -u\n</code></pre>\n<p>With a bit of formatting added, that generated a list of headers like this when I scanned the source tree with my answers to SO questions:</p>\n<pre><code>algorithm         arpa/inet.h       assert.h          cassert\nchrono            cmath             cstddef           cstdint\ncstdlib           cstring           ctime             ctype.h\ndirent.h          errno.h           fcntl.h           float.h\ngetopt.h          inttypes.h        iomanip           iostream\nlimits.h          locale.h          map               math.h\nmemory.h          netdb.h           netinet/in.h      pthread.h\nsemaphore.h       signal.h          sstream           stdarg.h\nstdbool.h         stddef.h          stdint.h          stdio.h\nstdlib.h          string            string.h          sys/ipc.h\nsys/mman.h        sys/param.h       sys/ptrace.h      sys/select.h\nsys/sem.h         sys/shm.h         sys/socket.h      sys/stat.h\nsys/time.h        sys/timeb.h       sys/times.h       sys/types.h\nsys/wait.h        termios.h         time.h            unistd.h\nutility           vector            wchar.h\n</code></pre>\n<p>So, to generate the surrogates for the source tree under the current directory:</p>\n<pre><code>$ sh mksurrogatehdr.sh $(sh listsyshdrs.sh)\n$ ls -lR system-headers\ntotal 344\n-rw-r--r--   1 jleffler  staff   20 Jul  2 17:27 algorithm\ndrwxr-xr-x   3 jleffler  staff  102 Jul  2 17:27 arpa\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 assert.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 cassert\n-rw-r--r--   1 jleffler  staff   17 Jul  2 17:27 chrono\n-rw-r--r--   1 jleffler  staff   16 Jul  2 17:27 cmath\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 cstddef\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 cstdint\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 cstdlib\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 cstring\n-rw-r--r--   1 jleffler  staff   16 Jul  2 17:27 ctime\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 ctype.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 dirent.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 errno.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 fcntl.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 float.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 getopt.h\n-rw-r--r--   1 jleffler  staff   21 Jul  2 17:27 inttypes.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 iomanip\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 iostream\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 limits.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 locale.h\n-rw-r--r--   1 jleffler  staff   14 Jul  2 17:27 map\n-rw-r--r--   1 jleffler  staff   17 Jul  2 17:27 math.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 memory.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 netdb.h\ndrwxr-xr-x   3 jleffler  staff  102 Jul  2 17:27 netinet\n-rw-r--r--   1 jleffler  staff   20 Jul  2 17:27 pthread.h\n-rw-r--r--   1 jleffler  staff   22 Jul  2 17:27 semaphore.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 signal.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 sstream\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 stdarg.h\n-rw-r--r--   1 jleffler  staff   20 Jul  2 17:27 stdbool.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 stddef.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 stdint.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 stdio.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 stdlib.h\n-rw-r--r--   1 jleffler  staff   17 Jul  2 17:27 string\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 string.h\ndrwxr-xr-x  16 jleffler  staff  544 Jul  2 17:27 sys\n-rw-r--r--   1 jleffler  staff   20 Jul  2 17:27 termios.h\n-rw-r--r--   1 jleffler  staff   17 Jul  2 17:27 time.h\n-rw-r--r--   1 jleffler  staff   19 Jul  2 17:27 unistd.h\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 utility\n-rw-r--r--   1 jleffler  staff   17 Jul  2 17:27 vector\n-rw-r--r--   1 jleffler  staff   18 Jul  2 17:27 wchar.h\n\nsystem-headers/arpa:\ntotal 8\n-rw-r--r--  1 jleffler  staff  22 Jul  2 17:27 inet.h\n\nsystem-headers/netinet:\ntotal 8\n-rw-r--r--  1 jleffler  staff  23 Jul  2 17:27 in.h\n\nsystem-headers/sys:\ntotal 112\n-rw-r--r--  1 jleffler  staff  20 Jul  2 17:27 ipc.h\n-rw-r--r--  1 jleffler  staff  21 Jul  2 17:27 mman.h\n-rw-r--r--  1 jleffler  staff  22 Jul  2 17:27 param.h\n-rw-r--r--  1 jleffler  staff  23 Jul  2 17:27 ptrace.h\n-rw-r--r--  1 jleffler  staff  23 Jul  2 17:27 select.h\n-rw-r--r--  1 jleffler  staff  20 Jul  2 17:27 sem.h\n-rw-r--r--  1 jleffler  staff  20 Jul  2 17:27 shm.h\n-rw-r--r--  1 jleffler  staff  23 Jul  2 17:27 socket.h\n-rw-r--r--  1 jleffler  staff  21 Jul  2 17:27 stat.h\n-rw-r--r--  1 jleffler  staff  21 Jul  2 17:27 time.h\n-rw-r--r--  1 jleffler  staff  22 Jul  2 17:27 timeb.h\n-rw-r--r--  1 jleffler  staff  22 Jul  2 17:27 times.h\n-rw-r--r--  1 jleffler  staff  22 Jul  2 17:27 types.h\n-rw-r--r--  1 jleffler  staff  21 Jul  2 17:27 wait.h\n$\n</code></pre>\n<p>This assumes that header file names contain no spaces, which is not unreasonable \u2014 it would be a brave programmer who created header file names with spaces or other tricky characters.</p>\n<p>A full production-ready version of <code>mksurrogates.sh</code> would accept an argument specifying the surrogate header directory.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-05T00:45:56.450", "Score": "15", "CreationDate": "2016-07-02T19:36:08.407", "ParentId": "20889460", "CommentCount": "7", "OwnerUserId": "15168", "LastEditDate": "2017-05-23T12:02:20.613"}});