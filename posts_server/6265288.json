post_cb({"bq_ids": {"n4140": {"so_6265288_6272139_0": {"length": 6, "quality": 0.75, "section_id": 4292}}, "n3337": {"so_6265288_6272139_0": {"length": 6, "quality": 0.75, "section_id": 4133}}, "n4659": {"so_6265288_6272139_0": {"length": 6, "quality": 0.75, "section_id": 5550}}}, "6265288": {"ViewCount": "1287", "Body": "<p><em>Howard Hinnant</em> <a href=\"http://home.roadrunner.com/~hinnant/unique_ptr03.html\" rel=\"nofollow\">explained</a> that <code>unique_ptr</code> can also use a <strong>custom storage type</strong>. He mentions as an example \"<em>shared memory</em>\".</p>\n<p>He only gives the rough idea (which is fine for a quick intro). But can anyone complete his example for a <em>\"custom storage type\"</em> (be it shared memory or not)?</p>\n<blockquote>\n<p id=\"so_6265288_6265288_0\">To support placing <code>unique_ptr</code> into shared memory, the custom deleter can contain a <strong>custom pointer type</strong> (typically not a real pointer in shared memory applications). One simply places a <em>nested type</em> called <em>pointer</em> which emulates pointer behavior within your deleter, publicly accessible:</p>\n</blockquote>\n<pre><code>template &lt;class T&gt;\nclass MyDeleter\n{\npublic:\n    class pointer\n    {\n     public:\n        friend bool operator==(pointer x, pointer y);\n        friend bool operator!=(pointer x, pointer y);\n        // ...\n    };\n\n    void operator()(pointer p);\n};\n\nvoid test()\n{\n    unique_ptr&lt;int, MyDeleter&lt;int&gt; &gt; p;\n    MyDeleter&lt;int&gt;::pointer p2 = p.get();  // A custom pointer type used for storage\n}\n</code></pre>\n<p>I suspect that <code>// ...</code> must be extended, and <code>test()</code> will probably do some additional things in a real \"custom storage type\" example.</p>\n<p>Can someone tell me where he/she</p>\n<ul>\n<li>has actually already <strong>used this customization</strong>,</li>\n<li>and in that <strong>context</strong>,</li>\n<li>which what <strong>customization code</strong>, (at <code>//...</code> probably)</li>\n<li>and how <strong>client code</strong> uses it? (at <code>test()</code> probably)</li>\n</ul>\n", "AcceptedAnswerId": "6271763", "Title": "unique_ptr custom storage type example?", "CreationDate": "2011-06-07T12:41:34.323", "Id": "6265288", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-01-07T08:23:43.140", "LastEditorUserId": "472245", "LastActivityDate": "2014-01-07T08:23:43.140", "Score": "2", "OwnerUserId": "472245", "Tags": "<c++11><unique-ptr>", "AnswerCount": "2"}, "6271763": {"Id": "6271763", "PostTypeId": "2", "Body": "<p>You might be interested in <a href=\"http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html\" rel=\"nofollow\">boost::offset_ptr</a> which served as the motivating use case for this customization point in <code>unique_ptr</code>.  <code>offset_ptr</code> is a fully developed pointer type which could be installed into a custom deleter using a simple typedef.  Its use case is to put <code>unique_ptr</code> into shared memory.</p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2011-06-07T21:30:20.730", "Score": "2", "CreationDate": "2011-06-07T21:16:23.633", "ParentId": "6265288", "CommentCount": "0", "OwnerUserId": "576911", "LastEditDate": "2011-06-07T21:30:20.730"}, "6272139": {"Id": "6272139", "PostTypeId": "2", "Body": "<p>20.7.1.2/3 tells us</p>\n<blockquote>\n<p id=\"so_6265288_6272139_0\">The type unique_ptr&lt;T, D&gt;::pointer shall satisfy the requirements of NullablePointer (17.6.3.3).</p>\n</blockquote>\n<p>According to 17.6.3.3, given a type <code>P</code>, these requirements are:</p>\n<ul>\n<li><code>P</code> is <em>EqualityComparable</em>, <em>DefaultConstructible</em>, <em>CopyConstructible</em>,\n<em>CopyAssignable</em>, and <em>Destructible</em></li>\n<li>Lvalues of <code>P</code> are <em>swappable</em></li>\n<li>Value-initializing an object of type P produces the <em>null value</em> of the type, and the null value shall be equivalent only to itself</li>\n<li>An object of type <code>P</code> can be <em>contextually converted</em> to <code>bool</code></li>\n<li>An object of type <code>P</code> can be initialized with and assigned <code>nullptr</code>, and this produces the null value</li>\n<li>An object of type <code>P</code> can be equality compared to <code>nullptr</code>, and the comparison is true if and only if the object has the null value</li>\n<li>None of the required operations may throw (but need no explicit <code>noexcept</code> or <code>throw()</code>)</li>\n</ul>\n<p>Note specifically that <code>operator*</code> and <code>operator-&gt;</code> are not actually required. Also note that the builtin numeric types satisfy all the requirements except <code>nullptr</code> initialization/assignment.</p>\n<p>For example, the following type should fulfill all the requirements:</p>\n<pre><code>class handle {\n    int id;\n  public:\n    // default and nullptr constructors folded together\n    handle(std::nullptr_t = nullptr) : id(0) { }\n\n    explicit operator bool() { return l.id != 0; }\n\n    friend bool operator ==(handle l, handle r) { return l.id == r.id; }\n    friend bool operator !=(handle l, handle r) { return !(l == r); }\n\n    // default copy ctor and operator= are fine\n\n    // explicit nullptr assignment and comparison unneeded\n    // because of implicit nullptr constructor\n\n    // swappable requirement fulfilled by std::swap\n}\n</code></pre>\n", "LastEditorUserId": "279597", "LastActivityDate": "2011-06-07T22:43:25.643", "Score": "2", "CreationDate": "2011-06-07T22:04:23.073", "ParentId": "6265288", "CommentCount": "2", "OwnerUserId": "279597", "LastEditDate": "2011-06-07T22:43:25.643"}});