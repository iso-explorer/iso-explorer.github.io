post_cb({"13927116": {"CommentCount": "4", "AcceptedAnswerId": "13927212", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-18T05:54:50.567", "LastActivityDate": "2012-12-18T07:45:51.517", "LastEditDate": "2017-05-23T12:16:57.687", "ViewCount": "224", "FavoriteCount": "5", "Title": "Why a simple mention of base pointer/reference in subsequent privately derived classes is forbidden?", "Id": "13927116", "Score": "14", "Body": "<pre><code>struct B {};\nstruct D : private B {\n  B* fun () { return new D; }  // ok\n}\nstruct DD : public D {\n  B* foo () { return 0; } // error: \u2018struct B B::B\u2019 is inaccessible !\n};\n</code></pre>\n<p>This error seems unreasonable to me. If we can use simple <code>B*</code> in global scope then why not in its privately derived classes? <a href=\"http://ideone.com/ZFJdQU\" rel=\"nofollow noreferrer\">g++ demo</a>.</p>\n<p>We are Not trying to convert <code>DD*</code> to <code>B*</code>, which is forbidden by the language rules (<a href=\"https://stackoverflow.com/questions/9661936/inheritance-a-is-an-inaccessible-base-of-b\">this</a>, <a href=\"https://stackoverflow.com/questions/4847100/c-inheritance-inaccessible-base\">this</a>, <a href=\"https://stackoverflow.com/questions/3674876/why-is-this-not-allowed-in-c\">this</a> are related questions).<br>\nNote that, if I change <code>B* foo()</code> to <code>int foo()</code>, things go fine.</br></p>\n", "Tags": "<c++><compiler-errors><language-lawyer>", "OwnerUserId": "514235", "AnswerCount": "3"}, "13927334": {"ParentId": "13927116", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>My best guess is that it's not forbidden, C++ simply doesn't see the B type inside that statement or in better terms the label <code>B</code> means nothing.</p>\n<p>Some good read about</p>\n<ul>\n<li><a href=\"http://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates/\" rel=\"nofollow noreferrer\">http://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates/</a></li>\n<li><a href=\"https://stackoverflow.com/a/7376212/1797612\">https://stackoverflow.com/a/7376212/1797612</a></li>\n<li><a href=\"https://stackoverflow.com/questions/7374588/list-of-c-name-resolution-and-overloading-rules/7376212#comment8901983_7374588\">List of C++ name resolution (and overloading) rules</a></li>\n</ul>\n", "OwnerUserId": "1797612", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:59.137", "Id": "13927334", "Score": "1", "CreationDate": "2012-12-18T06:14:26.280", "LastActivityDate": "2012-12-18T06:20:34.740"}, "13927212": {"ParentId": "13927116", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>So apparently the compiler thinks <code>B</code> is referring to the private constructor of <code>B</code> rather than the type.</p>\n<p>Qualifying <code>B</code> apparently fixes that error:</p>\n<pre><code>class B* foo () { return 0; }\n</code></pre>\n<p>or this:</p>\n<pre><code>::B* foo () { return 0; }\n</code></pre>\n<p>I don't know why that's happening, but maybe this will help.</p>\n<hr>\n<p>Update: maybe it's related to 11.2.4 of standard? The only problem is that my standardese isn't good enough to fully understand it.</p>\n<p><img alt=\"\" src=\"https://i.stack.imgur.com/8QpLG.png\"/></p>\n<p>(sorry for the image, copy/pasting isn't working for me)</p>\n</hr>", "OwnerUserId": "964135", "LastEditorUserId": "964135", "LastEditDate": "2012-12-18T06:25:42.083", "Id": "13927212", "Score": "7", "CreationDate": "2012-12-18T06:02:56.300", "LastActivityDate": "2012-12-18T06:25:42.083"}, "bq_ids": {"n4140": {"so_13927116_13928484_1": {"section_id": 6677, "quality": 0.8709677419354839, "length": 27}}, "n3337": {"so_13927116_13928484_1": {"section_id": 6432, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_13927116_13928484_1": {"section_id": 8152, "quality": 0.8709677419354839, "length": 27}}}, "13928484": {"ParentId": "13927116", "CommentCount": "1", "Body": "<p>A quick look-up for <em>injected-class-name</em> in the Standard yields:</p>\n<blockquote>\n<p id=\"so_13927116_13928484_0\"><strong>\u00a711.1 [class.access.spec]</strong></p>\n<p id=\"so_13927116_13928484_1\"><strong>5/</strong> [ <em>Note:</em> In a derived class, the lookup of a base class name will find the injected-class-name instead of the name of the base class in the scope in which it was declared. The injected-class-name might be less accessible than the name of the base class in the scope in which it was declared. <em>\u2014end note</em> ]</p>\n<p id=\"so_13927116_13928484_2\"><em>[ Example:</em></p>\n<pre><code>class A { };\nclass B : private A { };\nclass C : public B {\n    A *p; // error: injected-class-name A is inaccessible\n    ::A *q; // OK\n};\n</code></pre>\n<p id=\"so_13927116_13928484_3\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>I believe this is eerily close to your example ;)</p>\n<hr>\n<p>Note clang 3.0's stack, which is slightly more explicit:</p>\n<pre><code>$ clang++ -fsyntax-only test.cpp\ntest.cpp:6:5: error: 'B' is a private member of 'B'\n    B* foo () { return 0; } // error: \u2018struct B B::B\u2019 is inaccessible !\n    ^\ntest.cpp:2:12: note: constrained by private inheritance here\nstruct D : private B {\n           ^~~~~~~~~\ntest.cpp:1:8: note: member is declared here\nstruct B {};\n       ^\n1 error generated.\n</code></pre>\n<p>Here we see that <code>B</code> is accessed through <code>D</code>, instead of directly picked up in the global namespace.</p>\n</hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "13928484", "Score": "7", "CreationDate": "2012-12-18T07:45:51.517", "LastActivityDate": "2012-12-18T07:45:51.517"}});