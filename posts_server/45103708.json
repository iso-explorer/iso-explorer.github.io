post_cb({"45103897": {"ParentId": "45103708", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2017-07-14T13:10:32.207", "Score": "5", "LastEditorUserId": "4832499", "LastEditDate": "2017-07-14T13:59:36.373", "Id": "45103897", "OwnerUserId": "4832499", "Body": "<p>Sounds like what you're looking for is <a href=\"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow noreferrer\">CRTP</a></p>\n<pre><code>template&lt;typename Concrete&gt;\nstruct Resource\n{\n    Resource() { ResourceManager::notifyCreation(*static_cast&lt;Concrete*&gt;(this)); }\n    ~Resource() { ResourceManager::notifyDestruction(*static_cast&lt;Concrete*&gt;(this)); }\n};\n\nstruct MyResource : Resource&lt;MyResource&gt;\n{\n\n};\n</code></pre>\n<p>Note that <code>MyResource</code> is not yet finished constructed when the call to <code>notifyCreation</code> is made. The address of the <code>MyResource</code> instance can be taken, but that's about all that can be done to the instance. (Thanks to Caleth for pointing this out)</p>\n<p>In particular from <a href=\"http://eel.is/c++draft/class.cdtor#4\" rel=\"nofollow noreferrer\">[class.cdtor]</a></p>\n<blockquote>\n<p id=\"so_45103708_45103897_0\">If the operand of <code>typeid</code> refers to the object under construction or destruction and the static type of the operand is neither the constructor or destructor's class nor one of its bases, the behavior is undefined.</p>\n</blockquote>\n<p>Therefore <code>ResourceManager</code> would have to be implemented somewhat like this to enable using <code>typeid</code></p>\n<pre><code>struct ResourceManager\n{\n    template&lt;typename T&gt;\n    void notifyCreation(T&amp;&amp;)\n    {\n        add(typeid(T));  // can't apply to an expression\n    }\n    template&lt;typename T&gt;\n    void notifyDestruction(T&amp;&amp;)\n    {\n        remove(typeid(T));  // can't apply to an expression\n    }\n};\n</code></pre>\n", "LastActivityDate": "2017-07-14T13:59:36.373"}, "45103708": {"CommentCount": "8", "AcceptedAnswerId": "45103897", "CreationDate": "2017-07-14T13:01:35.887", "LastActivityDate": "2017-07-14T14:43:39.820", "PostTypeId": "1", "ViewCount": "101", "FavoriteCount": "1", "Title": "Type of an object changing during construction", "Id": "45103708", "Score": "5", "Body": "<p>I just discoverd the following behaviour : having an object of type <code>B</code> derived from type <code>A</code>, the final type during the construction of <code>A</code> is <code>A</code> and not <code>B</code>. This can be observed with the following example :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nclass A\n{\n    public:\n        A() { std::cout &lt;&lt; &amp;typeid(*this) &lt;&lt; std::endl; }\n};\n\nclass B : public A\n{\n    public:\n        B() : A() { std::cout &lt;&lt; &amp;typeid(*this) &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    A a;\n    B b;\n    return 0;\n}\n</code></pre>\n<p>A run of this code (compiled with gcc 4.8.5) is the following :</p>\n<pre><code>0x400ae0\n0x400ae0\n0x400ac0\n</code></pre>\n<p>We can see that the type returned by typeid in <code>A::A()</code> is <code>A</code> and not <code>B</code>, and then the final type changes to become <code>B</code>.</p>\n<p><strong>Why ?</strong></p>\n<p><strong>Is it possible to know the \"real\" final type during the construction of the parent class ?</strong></p>\n<p>My context is the following :</p>\n<p>I have a parent class <code>Resource</code> and several classes inheriting from it. I also have a <code>ResourceManager</code> notified by each creation of a resource, and having to know the final type of the created resource. What I'm doing to avoid duplicated code is the following, but it doesn't work :</p>\n<pre><code>class Resource\n{\n  public:\n    Resource() { ResourceManager::notifyCreation(*this); }\n    ~Resource() { ResourceManager::notifyDestruction(*this); }\n};\nclass MyResource : public Resource\n{\n  // I don't have to care to the manager here\n};\n</code></pre>\n<p>I know I can do the notification in each constructor/destructor of the children, but it's less robust (possible bug if a resource is instanciated without notification to the manager).\n<strong>Have you any idea for a workaround ?</strong></p>\n", "Tags": "<c++><inheritance><typeid>", "OwnerUserId": "3378179", "AnswerCount": "2"}, "45104450": {"ParentId": "45103708", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-07-14T13:38:41.340", "Score": "1", "LastEditorUserId": "1143850", "LastEditDate": "2017-07-14T14:43:39.820", "Id": "45104450", "OwnerUserId": "1143850", "Body": "<p>There is no good way to do it in a constructor as in your example, but you can provide a special constructor for <code>A</code>, i.e.</p>\n<pre><code> A(const std::type_info &amp;info) {\n    std::cout &lt;&lt; info.name() &lt;&lt; std::endl;\n }\n</code></pre>\n<p>and in <code>B</code></p>\n<pre><code>B() : A(typeid(*this)) {\n    std::cout &lt;&lt; typeid(*this).name() std::endl;\n}\n</code></pre>\n<p>if you do it outside the constructor, you can also provide a virtual function in 'A' and overwrite it in 'B'.</p>\n", "LastActivityDate": "2017-07-14T14:43:39.820"}, "bq_ids": {"n4140": {"so_45103708_45103897_0": {"section_id": 448, "quality": 0.95, "length": 19}}, "n3337": {"so_45103708_45103897_0": {"section_id": 439, "quality": 0.95, "length": 19}}, "n4659": {"so_45103708_45103897_0": {"section_id": 470, "quality": 1.0, "length": 20}}}});