post_cb({"27117236": {"ParentId": "27117169", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-25T01:16:34.797", "Score": "0", "LastEditorUserId": "318857", "LastEditDate": "2014-11-25T04:45:38.933", "Id": "27117236", "OwnerUserId": "318857", "Body": "<p><code>string[]</code> is sort of a type, but it's a misleading one; you can't just copy <code>string[]s</code> around and expect it to do what you want.  It's essentially another way of writing <code>string *</code>.</p>\n<p>If you want an array of <code>string</code>s that you can pass around, use <code>std::vector&lt;std::string&gt;</code> (by value) or <code>boost::shared_array&lt;std::string&gt;</code> (by reference) or similar.  <code>boost::shared_array</code> will probably act closest to what you're expecting from a Java array type.</p>\n", "LastActivityDate": "2014-11-25T04:45:38.933"}, "27117390": {"ParentId": "27117169", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-25T01:37:51.353", "Score": "4", "LastEditorUserId": "464581", "LastEditDate": "2014-11-25T01:43:41.933", "Id": "27117390", "OwnerUserId": "464581", "Body": "<p><code>string[]</code> is an incomplete array type.</p>\n<p>An incomplete array type can be completed:</p>\n<blockquote>\n<p id=\"so_27117169_27117390_0\"><strong>C++11 \u00a73.9/6</strong>:<br>\n<strong>\u201d</strong>  The\n  declared type of an array object might be an array of unknown size and therefore be incomplete at one point\n  in a translation unit and complete later on; the array types at those two points (\u201carray of unknown bound of <code>T</code>\u201d and \u201carray of <code>N</code> <code>T</code>\u201d) are different types.</br></p>\n</blockquote>\n<p>Usually this happens with a declaration like</p>\n<pre><code>extern int x[];\n</code></pre>\n<p>in some header, and then in an implementation file,</p>\n<pre><code>int x[42];\n</code></pre>\n<p>In addition to being incomplete due to unknown length, an array type can be incomplete due to an incomplete item type.</p>\n<pre><code>struct Blah;\nextern Blah x[42];\n\nauto main() -&gt; int {}\n</code></pre>\n<p>This does not, however, allow an array of <code>void</code>.</p>\n<hr>\n<p>In passing, it's worth noting e.g. <code>unique_ptr&lt;T&gt;</code> is different from <code>unique_ptr&lt;T[]&gt;</code>. The latter is restricted in the conversions it supports. Which is because if you convert a pointer to an array of type <code>T</code>, to pointer to array of type <code>T_base</code> or <code>T_derived</code>, then e.g. the item size can be different, foiling the indexing (and much else).</p>\n</hr>", "LastActivityDate": "2014-11-25T01:43:41.933"}, "27117169": {"CommentCount": "10", "ViewCount": "190", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-11-25T01:09:25.893", "LastActivityDate": "2014-11-25T09:08:38.800", "AnswerCount": "5", "LastEditDate": "2017-05-23T11:43:42.330", "LastEditorDisplayName": "user3920237", "Title": "Is string[] not a type?", "Id": "27117169", "Score": "4", "Body": "<p>A user posted an <a href=\"https://stackoverflow.com/a/27114829/3920237\">answer</a> which says:</p>\n<blockquote>\n<p id=\"so_27117169_27117169_0\">So, take the <code>Hash</code> by reference</p>\n<pre><code>void topWords(Hash const&amp; t, std::string const&amp; word, std::string* topA); \n</code></pre>\n<p id=\"so_27117169_27117169_1\">Also, </p>\n<ul>\n<li><code>string[]</code> is not a type in C++</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>The original function posted by the question asker looks like:</p>\n<pre><code>void topWords(Hash t, string word, string topA[]); \n</code></pre>\n<p>I'm aware that in Java, the syntax for declaring an array is:</p>\n<pre><code>int[] anArray;\n</code></pre>\n<p>whereas in C++ it is:</p>\n<pre><code>int anArray[someNumber];\n</code></pre>\n<p>I suspect this is what the answerer was referring to, but maybe they meant something else. So I consulted <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">n3337</a>:</p>\n<p><sup>formatting note: irrelevant stuff omitted, newlines added for readability</sup></p>\n<p>\u00a7 8.3.4 [dcl.array]</p>\n<blockquote>\n<p id=\"so_27117169_27117169_2\">1 In a declaration <code>T D</code> where <code>D</code> has the form</p>\n<blockquote>\n<p id=\"so_27117169_27117169_12\">D1 [ <em>constant-expression</em><sub>opt</sub> ]\n    <em>attribute-specifier-seq</em><sub>opt</sub></p>\n</blockquote>\n<p id=\"so_27117169_27117169_4\">and the type of the identifier in the declaration <code>T D1</code> is\n  \u201c<em>derived-declarator-type-list</em> <code>T</code>\u201d, then the type of the identifier\n  of <code>D</code> is an array type; </p>\n<p id=\"so_27117169_27117169_5\">... </p>\n<p id=\"so_27117169_27117169_6\"><code>T</code> is called the array <em>element type</em>; </p>\n<p id=\"so_27117169_27117169_7\">... </p>\n<p id=\"so_27117169_27117169_8\">If the <em>constant-expression</em> (5.19) is present, it shall be an\n  integral constant expression and its value shall be greater than zero.\n  The constant expression specifies the <em>bound of</em> (number of elements\n  in) the array. If the value of the constant expression is <code>N</code>, the\n  array has <code>N</code> elements numbered <code>0</code> to <code>N-1</code>, and the type of the\n  identifier of D is \u201c<em>derived-declarator-type-list array</em> of <code>N T</code>\u201d. </p>\n<p id=\"so_27117169_27117169_9\">...</p>\n<p id=\"so_27117169_27117169_10\">Except as noted below, if the constant expression is omitted, the type\n  of the identifier of <code>D</code> is \u201c<em>derived-declarator-type-list</em> array of\n  unknown bound of <code>T</code>\u201d, an incomplete object type. The type\n  \u201c<em>derived-declarator-type-list</em> array of <code>N T</code>\u201d is a different type\n  from the type \u201c<em>derived-declarator-type-list</em> array of unknown bound\n  of <code>T</code>\u201d, see 3.9.</p>\n<p id=\"so_27117169_27117169_11\">...</p>\n</blockquote>\n<p>So <code>anArray</code> should be an array of <code>someNumber int</code>. And <code>topA</code> is adjusted to be <code>pointer to std::string</code>. Where does my  understanding fail?</p>\n<hr/>\n<p>In order to avoid invalidating the current answers, I'll post this as an update. Some of you seem to be misunderstanding the nature of my question. I'm not asking about Java vs C++ nor arrays vs pointers, but rather from a language lawyer's point of view why <code>string[]</code> would not be considered a type.</p>\n<p>If we take a look at \u00a73.9/6:</p>\n<blockquote>\n<p id=\"so_27117169_27117169_13\">... The declared type of an array object might be an array of unknown\n  size and therefore be incomplete at one point in a translation unit\n  and complete later on; the array types at those two points (\u201carray of\n  unknown bound of <code>T</code>\u201d and \u201carray of <code>N T</code>\u201d) are different types. ... [\n  <em>Example:</em></p>\n<pre><code>extern int arr[]; // the type of array is incomplete\n</code></pre>\n</blockquote>\n<p>So <code>arr</code> <em>clearly</em> has a type.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerDisplayName": "user3920237"}, "27122565": {"ParentId": "27117169", "CommentCount": "0", "CreationDate": "2014-11-25T09:08:38.800", "OwnerUserId": "85371", "PostTypeId": "2", "Id": "27122565", "Score": "2", "Body": "<blockquote>\n<pre><code>extern int arr[]; // the type of array is incomplete\n</code></pre>\n<p id=\"so_27117169_27122565_0\"><em>So arr clearly has a type.</em></p>\n</blockquote>\n<p><code>arr</code> has a type. That doesn't make <code>int[]</code> a complete type. <code>arr</code> has incomplete type until the array dimension is defined as well (potentially in another TU).</p>\n<blockquote>\n<p id=\"so_27117169_27122565_1\">[...] <em>type of the identifier of D is \u201cderived-declarator-type-list array of unknown bound of T\u201d, an incomplete object type</em></p>\n</blockquote>\n<p>Referring to the concrete type of <code>arr</code> before that time (e.g. with <code>sizeof</code>) would be an error.</p>\n", "LastActivityDate": "2014-11-25T09:08:38.800"}, "27117272": {"ParentId": "27117169", "CommentCount": "0", "CreationDate": "2014-11-25T01:22:07.283", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "27117272", "Score": "2", "Body": "<p>If you keep going through \u00a78.3.4, we get this paragraph (bold emphasis mine):</p>\n<blockquote>\n<p id=\"so_27117169_27117272_0\">An object of <strong>array type</strong> contains a contiguously allocated non-empty set of N subobjects of type T. The\n  <strong>type</strong> \u201c<em>derived-declarator-type-list</em> array of N T\u201d is a different type from the <strong>type</strong> \u201c<em>derived-declarator-type-list</em> array\n  of <strong>unknown bound of T</strong>\u201d, see 3.9. Any type of the form \u201c<em>cv-qualifier-seq</em> array of N T\u201d is adjusted to \u201carray\n  of N <em>cv-qualifier-seq</em> T\u201d, and similarly for \u201carray of unknown bound of T\u201d and \u201carray of runtime bound of T\u201d.\n  The optional <em>attribute-specifier-seq</em> appertains to the array.</p>\n</blockquote>\n<p>With example:</p>\n<pre><code>typedef int A[5], AA[2][3];\ntypedef const A CA; // type is \u201carray of 5 const int\u201d\n</code></pre>\n<p>Since the standard mentions array type, and shows an example clearly indicating that the type of a variable is an array, I think that's sufficient evidence that an array, in general, is a type. It's a weird type that doesn't play as nicely as the other fundamental types, but it's a type nevertheless. And that paragraph specifically mentions the type \"unknown bound of T\", which would be your <code>string[]</code> too. </p>\n", "LastActivityDate": "2014-11-25T01:22:07.283"}, "27117237": {"ParentId": "27117169", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-25T01:16:52.830", "Score": "4", "LastEditorUserId": "179910", "LastEditDate": "2014-11-25T01:25:05.550", "Id": "27117237", "OwnerUserId": "179910", "Body": "<p>Your understanding seems to be mostly correct--since <code>topA</code> is a formal parameter, its type is adjusted from <code>array of T</code> to <code>pointer to T</code>. Likewise, <code>anArray</code> would be an array of someNumber ints.</p>\n<p>For what it's worth, there are limited circumstances under which you can have empty brackets in C++ and still have an array, not a pointer. The most common would be an <code>extern</code> declaration like:</p>\n<pre><code>extern int anArray[];\n</code></pre>\n<p>...which declares <code>anArray</code> to be an array of ints, the number of which is specified where it is defined.</p>\n<p>If somebody starts with a parameter declared as: <code>string topA[]</code>, it's true that the compiler will adjust that to <code>string *topA</code>, <em>but</em> in most cases, <em>you</em> probably want to change that to: <code>std::vector&lt;std::string&gt; &amp;topA</code> (or <code>std::vector&lt;std::string&gt; const &amp;topA</code>, if you're not going to modify the content of the array).</p>\n", "LastActivityDate": "2014-11-25T01:25:05.550"}, "bq_ids": {"n4140": {"so_27117169_27117169_4": {"section_id": 3228, "quality": 1.0, "length": 9}, "so_27117169_27117169_8": {"section_id": 3228, "quality": 0.8275862068965517, "length": 24}, "so_27117169_27122565_1": {"section_id": 3228, "quality": 0.8888888888888888, "length": 8}, "so_27117169_27117169_6": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_27117169_27117390_0": {"section_id": 7204, "quality": 0.9, "length": 27}, "so_27117169_27117169_13": {"section_id": 7204, "quality": 0.9310344827586207, "length": 27}, "so_27117169_27117272_0": {"section_id": 3228, "quality": 0.7619047619047619, "length": 32}, "so_27117169_27117169_10": {"section_id": 3228, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_27117169_27117169_4": {"section_id": 3101, "quality": 1.0, "length": 9}, "so_27117169_27117169_8": {"section_id": 3101, "quality": 0.8620689655172413, "length": 25}, "so_27117169_27122565_1": {"section_id": 3101, "quality": 0.8888888888888888, "length": 8}, "so_27117169_27117169_6": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_27117169_27117272_0": {"section_id": 3101, "quality": 0.7619047619047619, "length": 32}, "so_27117169_27117390_0": {"section_id": 6948, "quality": 0.9, "length": 27}, "so_27117169_27117169_13": {"section_id": 6948, "quality": 0.9310344827586207, "length": 27}, "so_27117169_27117169_10": {"section_id": 3101, "quality": 0.8518518518518519, "length": 23}}, "n4659": {"so_27117169_27117169_6": {"section_id": 4038, "quality": 1.0, "length": 4}, "so_27117169_27117169_8": {"section_id": 3985, "quality": 0.8275862068965517, "length": 24}, "so_27117169_27122565_1": {"section_id": 3985, "quality": 0.8888888888888888, "length": 8}, "so_27117169_27117169_4": {"section_id": 3985, "quality": 0.8888888888888888, "length": 8}, "so_27117169_27117272_0": {"section_id": 3985, "quality": 0.8095238095238095, "length": 34}, "so_27117169_27117390_0": {"section_id": 8713, "quality": 0.8666666666666667, "length": 26}, "so_27117169_27117169_13": {"section_id": 8713, "quality": 0.896551724137931, "length": 26}, "so_27117169_27117169_10": {"section_id": 3985, "quality": 0.8518518518518519, "length": 23}}}});