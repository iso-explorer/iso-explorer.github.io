post_cb({"bq_ids": {"n4140": {"so_27405418_27405419_7": {"length": 29, "quality": 0.8529411764705882, "section_id": 31}, "so_27405418_27406408_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6708}, "so_27405418_27405419_5": {"length": 7, "quality": 0.875, "section_id": 5943}, "so_27405418_27405419_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 6138}, "so_27405418_27405419_8": {"length": 13, "quality": 0.8125, "section_id": 32}, "so_27405418_27405419_6": {"length": 8, "quality": 0.8, "section_id": 45}, "so_27405418_27406408_1": {"length": 22, "quality": 0.8461538461538461, "section_id": 6709}, "so_27405418_27405419_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5341}, "so_27405418_27405419_4": {"length": 22, "quality": 0.9166666666666666, "section_id": 5943}}, "n3337": {"so_27405418_27405419_7": {"length": 29, "quality": 0.8529411764705882, "section_id": 28}, "so_27405418_27406408_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6463}, "so_27405418_27405419_5": {"length": 7, "quality": 0.875, "section_id": 5714}, "so_27405418_27405419_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 5902}, "so_27405418_27405419_8": {"length": 13, "quality": 0.8125, "section_id": 29}, "so_27405418_27405419_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 5917}, "so_27405418_27405419_6": {"length": 8, "quality": 0.8, "section_id": 42}, "so_27405418_27406408_1": {"length": 22, "quality": 0.8461538461538461, "section_id": 6464}, "so_27405418_27405419_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5138}, "so_27405418_27405419_4": {"length": 22, "quality": 0.9166666666666666, "section_id": 5714}}, "n4659": {"so_27405418_27405419_7": {"length": 29, "quality": 0.8529411764705882, "section_id": 31}, "so_27405418_27406408_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 8183}, "so_27405418_27405419_5": {"length": 7, "quality": 0.875, "section_id": 7428}, "so_27405418_27405419_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 7635}, "so_27405418_27405419_8": {"length": 11, "quality": 0.6875, "section_id": 32}, "so_27405418_27405419_6": {"length": 8, "quality": 0.8, "section_id": 46}, "so_27405418_27406408_1": {"length": 22, "quality": 0.8461538461538461, "section_id": 8184}, "so_27405418_27405419_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 6762}, "so_27405418_27405419_4": {"length": 22, "quality": 0.9166666666666666, "section_id": 7428}}}, "27405419": {"Id": "27405419", "PostTypeId": "2", "Body": "<p><strong>Yes, and the result is what you would expect.</strong></p>\n<p>Let's break it down.</p>\n<p>What is the value of <code>r</code> at this point? Well, the underflow is well-defined and results in <code>r</code> taking on its maximum value by the time the comparison is run. <a href=\"http://en.cppreference.com/w/cpp/types/size_t\"><code>std::size_t</code> has no specific known bounds</a>, but we can make reasonable assumptions about its range when compared to that of an <code>int</code>:</p>\n<blockquote>\n<p id=\"so_27405418_27405419_0\"><code>std::size_t</code> is the unsigned integer type of the result of the sizeof operator. <em>[..]</em> <code>std::size_t</code> can store the maximum size of a theoretically possible object of any type (including array).</p>\n</blockquote>\n<p>And, just to get it out of the way, the expression <code>-1</code> is unary <code>-</code> applied to the literal <code>1</code>, and has type <code>int</code> on any system:</p>\n<blockquote>\n<p id=\"so_27405418_27405419_1\"><code>[C++11: 2.14.2/2]:</code> The type of an integer literal is the first of the corresponding list in Table 6 in which its value can be represented. <em>[..]</em></p>\n</blockquote>\n<p><em>(I won't cite all the text that describes how applying unary <code>-</code> to an <code>int</code> results in an <code>int</code>, but it does.)</em></p>\n<p>It's more than reasonable to suggest that, on the majority of systems, an <code>int</code> is not going to be able to hold <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>.</p>\n<p>Now, what happens to those operands?</p>\n<blockquote>\n<p id=\"so_27405418_27405419_2\"><code>[C++11: 5.10/1]:</code> The <code>==</code> (equal to) and the <code>!=</code> (not equal to) operators have the same semantic restrictions, conversions, and result type as the relational operators except for their lower precedence and truth-value result. <em>[..]</em></p>\n<p id=\"so_27405418_27405419_3\"><code>[C++11: 5.9/2]:</code> The usual arithmetic conversions are performed on operands of arithmetic or enumeration type. <em>[..]</em></p>\n</blockquote>\n<p>Let's examine these \"usual arithmetic conversions\":</p>\n<blockquote>\n<p id=\"so_27405418_27405419_4\"><code>[C++11: 5/9]:</code> Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result.</p>\n<p id=\"so_27405418_27405419_5\">This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>\n<ul>\n<li>If either operand is of scoped enumeration type (7.2), no conversions are performed; if the other\n  operand does not have the same type, the expression is ill-formed.</li>\n<li>If either operand is of type <code>long double</code>, the other shall be converted to long double`.</li>\n<li>Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</li>\n<li>Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.</li>\n<li>Otherwise, the integral promotions (4.5) shall be performed on both operands.<sup>59</sup> Then the following rules shall be applied to the promoted operands:\n  <ul>\n<li>If both operands have the same type, no further conversion is needed.</li>\n<li>Otherwise, if both operands have signed integer types or both have unsigned integer types, the\n  operand with the type of lesser integer conversion rank shall be converted to the type of the\n  operand with greater rank.</li>\n<li><strong>Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type shall be converted to\n  the type of the operand with unsigned integer type.</strong></li>\n<li>Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type shall be converted to the type of the operand with signed integer type.</li>\n<li>Otherwise, both operands shall be converted to the unsigned integer type corresponding to the\n  type of the operand with signed integer type.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>I've highlighted the passage that takes effect here and, as for <em>why</em>:</p>\n<blockquote>\n<p id=\"so_27405418_27405419_6\"><code>[C++11: 4.13/1]</code>: Every integer type has an <em>integer conversion rank</em> defined as follows</p>\n<ul>\n<li><em>[..]</em></li>\n<li>The rank of <code>long long int</code> shall be greater than the rank of <code>long int</code>, which shall be greater than the rank of <code>int</code>, which shall be greater than the rank of <code>short int</code>, which shall be greater than the rank of <code>signed char</code>.</li>\n<li>The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.</li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p>All integral types, even the fixed-width ones, are composed of the standard integral types; therefore, logically, <code>std::size_t</code> must be <code>unsigned long long</code>, <code>unsigned long</code>, or <code>unsigned int</code>.</p>\n<ul>\n<li><p>If <code>std::size_t</code> is <code>unsigned long long</code>, or <code>unsigned long</code>, then the rank of <code>std::size_t</code> is greater than the rank of <code>unsigned int</code> and, therefore, also of <code>int</code>.</p></li>\n<li><p>If <code>std::size_t</code> is <code>unsigned int</code>, the rank of <code>std::size_t</code> is equal to the rank of <code>unsigned int</code> and, therefore, also of <code>int</code>.</p></li>\n</ul>\n<p>Either way, per the <em>usual arithmetic conversions</em>, the signed operand is converted to the type of the unsigned operand (and, crucially, <em>not</em> the other way around!). Now, what does this conversion entail?</p>\n<blockquote>\n<p id=\"so_27405418_27405419_7\"><code>[C++11: 4.7/2]:</code> <strong>If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits used to represent the unsigned type).</strong> <em>[ Note:</em> In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). <em>\u2014end note ]</em></p>\n<p id=\"so_27405418_27405419_8\"><code>[C++11: 4.7/3]:</code> If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>This means that <code>std::size_t(-1)</code> is equivalent to <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>; it's crucial that the value <em>n</em> in the above clause relates to the number of bits used to represent the <em>unsigned</em> type, not the source type. Otherwise, we'd be doing <code>std::size_t((unsigned int)-1)</code>, which is not the same thing at all \u2014 it could be many orders of magnitude smaller than our desired value!</p>\n<p>Indeed, now that we know the conversions are all well-defined, we can test this value:</p>\n<pre><code>std::cout &lt;&lt; (std::size_t(-1) == std::numeric_limits&lt;size_t&gt;::max()) &lt;&lt; '\\n';\n// \"1\"\n</code></pre>\n<p>And, just to illustrate my point from earlier, on my 64-bit system:</p>\n<pre><code>std::cout &lt;&lt; std::is_same&lt;unsigned long, std::size_t&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; std::is_same&lt;unsigned long, unsigned int&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; std::hex &lt;&lt; std::showbase\n          &lt;&lt; std::size_t(-1) &lt;&lt; ' '\n          &lt;&lt; std::size_t(static_cast&lt;unsigned int&gt;(-1)) &lt;&lt; '\\n';\n// \"1\"\n// \"0\"\n// \"0xffffffffffffffff 0xffffffff\"\n</code></pre>\n", "LastEditorUserId": "560648", "LastActivityDate": "2014-12-10T16:41:24.507", "Score": "13", "CreationDate": "2014-12-10T15:58:35.833", "ParentId": "27405418", "CommentCount": "9", "OwnerUserId": "560648", "LastEditDate": "2014-12-10T16:41:24.507"}, "27406408": {"Id": "27406408", "PostTypeId": "2", "Body": "<pre><code>size_t r = 0;\nr--;\nconst bool result = (r == -1);\n</code></pre>\n<p>Strictly speaking, the value of <code>result</code> is implementation-defined. In practice, it's almost certain to be <code>true</code>; I'd be surprised if there were an implementation where it's <code>false</code>.</p>\n<p>The value of <code>r</code> after <code>r--</code> is the value of <code>SIZE_MAX</code>, a macro defined in <code>&lt;stddef.h&gt;</code> / <code>&lt;cstddef&gt;</code>.</p>\n<p>For the comparison <code>r == -1</code>, the <em>usual arithmetic conversions</em> are performed on both operands. The first step in the usual arithmetic conversions is to apply the <em>integral promotions</em> to both operands.</p>\n<p><code>r</code> is of type <code>size_t</code>, an implementation-defined unsigned integer type. <code>-1</code> is an expression of type <code>int</code>.</p>\n<p>On most systems, <code>size_t</code> is at least as wide as <code>int</code>. On such systems, the integral promotions cause the value of <code>r</code> either to be converted to <code>unsigned int</code> or to keep its existing type (the former can happen if <code>size_t</code> has the same width as <code>int</code>, but a lower conversion rank). Now the left operand (which is unsigned) has at least the rank of the right operand (which is signed). The right operand is converted to the type of the left operand. This conversion yields the same value as <code>r</code>, and so the equality comparison yields <code>true</code>.</p>\n<p>That's the \"normal\" case.</p>\n<p>Suppose we have an implementation where <code>size_t</code> is 16 bits (let's say it's a <code>typedef</code> for <code>unsigned short</code>) and <code>int</code> is 32 bits. So <code>SIZE_MAX == 65535</code> and <code>INT_MAX == 2147483647</code>. Or we could have a 32-bit <code>size_t</code> and a 64-bit <code>int</code>. I doubt that any such implementation exists, but nothing in the standard forbids it (see below).</p>\n<p>Now the left side of the comparison has type <code>size_t</code> and value <code>65535</code>. Since <em>signed</em> <code>int</code> can represent all the values of type <code>size_t</code>, the integral promotions convert the value to <code>65535</code> <em>of type <code>int</code></em>.  Both side of the <code>==</code> operator have type <code>int</code>, so the usual arithmetic conversions have nothing to do. The expression is equivalent to <code>65535 == -1</code>, which is clearly <code>false</code>.</p>\n<p>As I mentioned, this kind of thing is unlikely to happen with an expression of type <code>size_t</code> -- but it can easily happen with narrower unsigned types. For example, if <code>r</code> is declared as an <code>unsigned short</code>, or an <code>unsigned char</code>, or even a plain <code>char</code> on a system where that type is signed, the value of <code>result</code> will probably be <code>false</code>. (I say probably because <code>short</code> or even <code>unsigned char</code> can have the same width as <code>int</code>, in which case <code>result</code> will be <code>true</code>.)</p>\n<p>In practice, you can avoid the potential problem by doing the conversion explicitly rather than relying on the implementation-defined usual arithmetic conversions:</p>\n<pre><code>const bool result = (r == (size_t)-1);\n</code></pre>\n<p>or</p>\n<pre><code>const bool result = (r == SIZE_MAX);\n</code></pre>\n<p>C++11 standard references:</p>\n<ul>\n<li>5.10 [expr.eq] Equality operators</li>\n<li>5.9 [expr.rel] Relational operators (specifies that the usual arithmetic conversions are performed)</li>\n<li>5 [expr] Expressions, paragraph 9: Usual arithmetic conversions</li>\n<li>4.5 [conv.prom] Integral promotions</li>\n<li>18.2 [support.types] <code>size_t</code></li>\n</ul>\n<p>18.2 paragraphs 6-7:</p>\n<blockquote>\n<p id=\"so_27405418_27406408_0\">6 The type <code>size_t</code> is an implementation-defined unsigned integer type\n  that is large enough to contain the size in bytes of any object.</p>\n<p id=\"so_27405418_27406408_1\">7 [ <em>Note:</em> It is recommended that implementations choose types for\n  <code>ptrdiff_t</code> and <code>size_t</code> whose integer conversion ranks (4.13) are no\n  greater than that of <code>signed long int</code> unless a larger size is\n  necessary to contain all the possible values. \u2014 end note ]</p>\n</blockquote>\n<p>So there's no prohibition on making <code>size_t</code> narrower than <code>int</code>. I can <em>almost</em> plausibly imagine a system where <code>int</code> is 64 bits, but no single object can be bigger than 2<sup>32</sup>-1 bytes so <code>size_t</code> is 32 bits.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2014-12-10T19:07:29.650", "Score": "20", "CreationDate": "2014-12-10T16:46:38.103", "ParentId": "27405418", "CommentCount": "11", "OwnerUserId": "827263", "LastEditDate": "2014-12-10T19:07:29.650"}, "27405418": {"ViewCount": "901", "Body": "<p>Consider the following<sup>\u2020</sup>:</p>\n<pre><code>size_t r = 0;\nr--;\nconst bool result = (r == -1);\n</code></pre>\n<p>Does the comparison whose result initialises <code>result</code> have well-defined behaviour?<br>\nAnd is its result <code>true</code>, as I'd expect?</br></p>\n<hr>\n<p><sup>This Q&amp;A was written because I was unsure of two factors in particular.<br>\nThey may both be identified by use of the term \"crucial[ly]\" in my answer.</br></sup></p>\n<p><sup><sup>\u2020</sup> This example is inspired by an approach for loop conditions when the counter is unsigned:<br>\n<code>for (size_t r = m.size() - 1; r != -1; r--)</code></br></sup></p>\n</hr>", "AcceptedAnswerId": "27406408", "Title": "Is comparing an underflowed, unsigned integer to -1 well-defined?", "CreationDate": "2014-12-10T15:58:35.833", "Id": "27405418", "CommentCount": "6", "FavoriteCount": "6", "PostTypeId": "1", "LastActivityDate": "2014-12-10T19:07:29.650", "Score": "22", "OwnerUserId": "560648", "Tags": "<c++><c++11><language-lawyer><unsigned-integer><signed-integer>", "AnswerCount": "2"}});