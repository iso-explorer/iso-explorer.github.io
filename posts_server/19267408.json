post_cb({"19272035": {"ParentId": "19267408", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The cases where copy and move elision is allowed is found in section 12.8 \u00a731 of the Standard (version N3690):</p>\n<blockquote>\n<p id=\"so_19267408_19272035_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>in a <code>return</code> statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</li>\n<li>[...] </li>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>(The two cases I left out refer to the case of throwing and catching exception objects which I consider less important for optimization.) </p>\n<p>Hence in a return statement copy elision can only occur, if the expression is <strong>the name of a local variable.</strong> If you write <code>std::move(var)</code>, then it is not the name of a variable anymore. Therefore the compiler cannot elide the move, if it should conform to the standard. </p>\n<p>Stephan T. Lavavej talked about this at <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/Don-t-Help-the-Compiler\">Going Native 2013</a> and explained exactly your situation and why to avoid <code>std::move()</code> here. Start watching at minute 38:04. Basically, when returning a local variable of the return type then it is usually treated as an rvalue hence enabling move by default. </p>\n", "OwnerUserId": "1335865", "LastEditorUserId": "1335865", "LastEditDate": "2013-10-09T12:42:09.987", "Id": "19272035", "Score": "23", "CreationDate": "2013-10-09T12:28:41.920", "LastActivityDate": "2013-10-09T12:42:09.987"}, "19267408": {"CommentCount": "12", "AcceptedAnswerId": "19272035", "PostTypeId": "1", "LastEditorUserId": "1774667", "CreationDate": "2013-10-09T09:00:27.590", "LastActivityDate": "2013-10-09T18:48:20.700", "LastEditDate": "2013-10-09T18:48:20.700", "ViewCount": "6296", "FavoriteCount": "11", "Title": "Why does std::move prevent RVO?", "Id": "19267408", "Score": "33", "Body": "<p>In many cases when returning a local from a function, RVO kicks in. However, I thought that explicitly using <code>std::move</code> would at least enforce moving when RVO does not happen, but that RVO is still applied when possible. However, it seems that this is not the case.</p>\n<pre><code>#include \"iostream\"\n\nclass HeavyWeight\n{\npublic:\n    HeavyWeight()\n    {\n        std::cout &lt;&lt; \"ctor\" &lt;&lt; std::endl;\n    }\n\n    HeavyWeight(const HeavyWeight&amp; other)\n    {\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n\n    HeavyWeight(HeavyWeight&amp;&amp; other)\n    {\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n};\n\nHeavyWeight MakeHeavy()\n{\n    HeavyWeight heavy;\n    return heavy;\n}\n\nint main()\n{\n    auto heavy = MakeHeavy();\n    return 0;\n}\n</code></pre>\n<p>I tested this code with VC++11 and GCC 4.71, debug and release (<code>-O2</code>) config. The copy ctor is never called. The move ctor is only called by VC++11 in debug config. Actually, everything seems to be fine with these compilers in particular, but to my knowledge, RVO is optional.</p>\n<p>However, if I explicitly use <code>move</code>:</p>\n<pre><code>HeavyWeight MakeHeavy()\n{\n    HeavyWeight heavy;\n    return std::move(heavy);\n}\n</code></pre>\n<p>the move ctor is always called. So trying to make it \"safe\" makes it worse.</p>\n<p>My questions are:<br>\n - Why does <code>std::move</code> prevent RVO?<br>\n - When is it better to \"hope for the best\" and rely on RVO, and when should I explicitly use <code>std::move</code>? Or, in other words, how can I let the compiler optimization do its work and still enforce move if RVO is not applied?</br></br></p>\n", "Tags": "<c++><c++11><move-semantics><rvo>", "OwnerUserId": "2799917", "AnswerCount": "2"}, "19267500": {"ParentId": "19267408", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_19267408_19267500_0\">how can I let the compiler optimization do its work and still enforce move if RVO is not applied?</p>\n</blockquote>\n<p>Like this:</p>\n<pre><code>HeavyWeight MakeHeavy()\n{\n    HeavyWeight heavy;\n    return heavy;\n}\n</code></pre>\n<p>Transforming the return into a move is mandatory.</p>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "19267500", "Score": "13", "CreationDate": "2013-10-09T09:04:40.603", "LastActivityDate": "2013-10-09T09:04:40.603"}, "bq_ids": {"n4140": {"so_19267408_19272035_0": {"section_id": 480, "quality": 0.9848484848484849, "length": 65}}, "n3337": {"so_19267408_19272035_0": {"section_id": 471, "quality": 0.9393939393939394, "length": 62}}, "n4659": {"so_19267408_19272035_0": {"section_id": 502, "quality": 0.9848484848484849, "length": 65}}}});