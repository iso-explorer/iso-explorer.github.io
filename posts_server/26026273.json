post_cb({"26029043": {"ParentId": "26026273", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It's a good question because it's difficult to demonstrate. We can take advantage of other rules in the C++ Standard to show that a variable in an anonymous namespace can have external linkage.</p>\n<p>Templating on an int* with external linkage will succeed while templating on an int* with internal linkage will fail.</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace {\n    // not externally linked, won't compile\n    // const int i = 5;\n\n    // external linkage, compiles\n    extern int i;\n    int i = 5;\n}\n\ntemplate&lt;int* int_ptr&gt;\nstruct temp_on_extern_linked_int {\n    temp_on_extern_linked_int() {\n        std::cout &lt;&lt; *int_ptr &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    temp_on_extern_linked_int&lt;&amp;i&gt;();\n}\n</code></pre>\n<p>As shown the program compiles and runs.</p>\n<pre><code>$ g++-4.8 main.cpp -o main\n$ ./main\n5\n</code></pre>\n<p>Uncommenting the other definition of <code>i</code> causes the compile to fail.</p>\n<pre><code>$ g++-4.8 main.cpp -o main\nmain.cpp: In function 'int main()':\nmain.cpp:17:30: error: '&amp; {anonymous}::i' is not a valid template argument of\ntype 'int*' because '{anonymous}::i' does not have external linkage\n  temp_on_extern_linked_int&lt;&amp;i&gt;();\n                              ^\n</code></pre>\n<p>The compiler is quite helpful. It explicitly states that because <code>i</code> doesn't have external linkage the compile failed.</p>\n<p>The commented definition of <code>i</code> has internal linkage because it is qualified const without extern. (\u00a73.4.6)</p>\n<p><code>Variables at namespace scope that are declared const and not extern have internal linkage.</code></p>\n<p>Part of the trick is not compiling as C++11.</p>\n<p><a href=\"https://stackoverflow.com/questions/14597463/why-did-c03-require-template-parameters-to-have-external-linkage\">Why did C++03 require template parameters to have external linkage?</a></p>\n", "OwnerUserId": "1128289", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:10.713", "Id": "26029043", "Score": "1", "CreationDate": "2014-09-25T01:25:52.347", "LastActivityDate": "2014-09-25T01:34:08.550"}, "26040522": {"ParentId": "26026273", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You are looking at a defect in the standard.</p>\n<p>The change that makes unnamed namespace members have internal linkage happened fairly late in the C++11 standardization process, in November 2010 (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1113\" rel=\"nofollow\">CWG issue 1113</a>). As a result, a number of places in the standard needs to be changed, but weren't. One of which is the footnote you quoted.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1603\" rel=\"nofollow\">CWG issue 1603</a>, currently in \"ready\" status (read: the resolution is likely to be adopted at the next committee meeting), will fix this and a number of other issues related to giving internal linkage to unnamed namespace members.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-09-25T14:26:55.417", "Id": "26040522", "Score": "5", "CreationDate": "2014-09-25T13:58:42.403", "LastActivityDate": "2014-09-25T14:26:55.417"}, "26026273": {"CommentCount": "1", "AcceptedAnswerId": "26040522", "CreationDate": "2014-09-24T20:53:05.230", "LastActivityDate": "2014-09-25T14:26:55.417", "PostTypeId": "1", "ViewCount": "351", "FavoriteCount": "1", "Title": "Example of entity declared in a anonymous namespace that has external linkage", "Id": "26026273", "Score": "7", "Body": "<p>Given the statements below (emphasis mine) in \u00a73.5/4 and in the Note [94] in \u00a77.3.1.1/1, I'd like to have one single example of an entity declared in a unnamed namespace that has external linkage. </p>\n<p>\u00a73.5/4</p>\n<blockquote>\n<p id=\"so_26026273_26026273_0\"><strong>An unnamed namespace or a namespace declared directly or indirectly\n  within an unnamed namespace has internal linkage</strong>. All other namespaces\n  have external linkage. <strong>A name having namespace scope that has not been\n  given internal linkage above has the same linkage as the enclosing\n  namespace if it is the name of</strong></p>\n<ul>\n<li>a variable; or</li>\n<li>a function; or</li>\n<li>a named class (Clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage\n  purposes (7.1.3); or</li>\n<li>a named enumeration (7.2), or an unnamed enumeration defined in a typedef declaration in which the enumeration has the typedef name for\n  linkage purposes (7.1.3); or</li>\n<li>an enumerator belonging to an enumeration with linkage; or</li>\n<li>a template.</li>\n</ul>\n</blockquote>\n<p>Note [94] on \u00a77.3.1.1/1:</p>\n<blockquote>\n<p id=\"so_26026273_26026273_1\">Although entities in an unnamed namespace might have external linkage,\n  they are effectively qualified by a name unique to their translation\n  unit and therefore can never be seen from any other translation unit.</p>\n</blockquote>\n", "Tags": "<c++><c++11><namespaces><language-lawyer><linkage>", "OwnerUserId": "2548699", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26026273_26026273_1": {"section_id": 5482, "quality": 0.9565217391304348, "length": 22}, "so_26026273_26026273_0": {"section_id": 7137, "quality": 1.0, "length": 31}, "so_26026273_26026610_0": {"section_id": 7139, "quality": 0.9833333333333333, "length": 59}}, "n3337": {"so_26026273_26026273_1": {"section_id": 5268, "quality": 0.9565217391304348, "length": 22}, "so_26026273_26026273_0": {"section_id": 6881, "quality": 1.0, "length": 31}, "so_26026273_26026610_0": {"section_id": 6883, "quality": 0.9833333333333333, "length": 59}}, "n4659": {"so_26026273_26026610_0": {"section_id": 8640, "quality": 0.9833333333333333, "length": 59}, "so_26026273_26026273_0": {"section_id": 8638, "quality": 1.0, "length": 31}}}, "26026610": {"ParentId": "26026273", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>For example</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace\n{\n    extern int x = 10;\n\n    void f( int y )\n    {\n        extern int x;\n        std::cout &lt;&lt; x + y &lt;&lt; std::endl;\n    }\n}\n\nint main() \n{\n    int y =  15;\n\n    f( y );\n\n    return 0;\n}\n</code></pre>\n<p>According to the C++ Standard</p>\n<blockquote>\n<p id=\"so_26026273_26026610_0\">6 The name of a function declared in block scope and the name of a\n  variable declared by a block scope extern declaration have linkage. If\n  there is a visible declaration of an entity with linkage having the\n  same name and type, ignoring entities declared outside the innermost\n  enclosing namespace scope, the block scope declaration declares that\n  same entity and receives the linkage of the previous declaration. If\n  there is more than one such matching entity, the program is\n  ill-formed. Otherwise, if no matching entity is found, the block scope\n  entity receives external linkage</p>\n</blockquote>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-09-25T03:42:29.400", "Id": "26026610", "Score": "0", "CreationDate": "2014-09-24T21:13:56.537", "LastActivityDate": "2014-09-25T03:42:29.400"}});