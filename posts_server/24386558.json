post_cb({"bq_ids": {"n4140": {"so_24386558_24387253_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 12}}, "n3337": {"so_24386558_24387253_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 9}}, "n4659": {"so_24386558_24387253_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 13}}}, "24386654": {"Id": "24386654", "PostTypeId": "2", "Body": "<p>It declares <code>f1</code> to be a function type, with an <code>int</code> parameter and no return type.</p>\n<p>It's equivalent to the old-school declaration</p>\n<pre><code>typedef void f(int);\n</code></pre>\n", "LastActivityDate": "2014-06-24T12:28:02.643", "Score": "3", "CreationDate": "2014-06-24T12:28:02.643", "ParentId": "24386558", "CommentCount": "0", "OwnerUserId": "204847"}, "24386558": {"ViewCount": "233", "Body": "<p>What exactly does the following code declare;</p>\n<pre><code>using f1 = void(int);\n</code></pre>\n<p>I know that the following;</p>\n<pre><code>using f2 = void(*)(int);\nusing f3 = void(&amp;)(int);\n</code></pre>\n<p><code>f2</code> is a pointer to a function and <code>f3</code> would be the reference.</p>\n", "AcceptedAnswerId": "24387253", "Title": "Function using alias", "CreationDate": "2014-06-24T12:23:29.287", "Id": "24386558", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-06-24T13:02:35.850", "Score": "3", "OwnerUserId": "3747990", "Tags": "<c++><c++11><using>", "AnswerCount": "2"}, "24387253": {"Id": "24387253", "PostTypeId": "2", "Body": "<h2>What is it?</h2>\n<p>It's a <em>function type</em>. When you declare a function, such as:</p>\n<pre><code>void func(int);\n</code></pre>\n<p>its type is not a pointer nor a reference. The above function's type is <code>void(int)</code>. </p>\n<p>We can \"prove\" it by using <em>type traits</em> as follows:</p>\n<pre><code>void func(int) {}\n\nint main() {\n    std::cout &lt;&lt; std::is_same&lt;decltype(func), void(int)&gt;::value &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::is_same&lt;decltype(func), void(*)(int)&gt;::value &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::is_same&lt;decltype(func), void(&amp;)(int)&gt;::value &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3ded7d25d4442c4e\" rel=\"nofollow\"><kbd>Live demo</kbd></a></p>\n<p>The above code will return <code>true</code> only for the first row. </p>\n<h2>Is it the same as a pointer or a reference?</h2>\n<p>No, but a function lvalue can be implicitly converted to a function pointer as per:</p>\n<blockquote>\n<p id=\"so_24386558_24387253_0\"><strong>\u00a74.3/1 Function-to-pointer conversion [conv.func]</strong></p>\n<p id=\"so_24386558_24387253_1\">An lvalue of function type T can be converted to a prvalue of type \u201cpointer to T.\u201d The result is a pointer to the function.</p>\n</blockquote>\n<p>The relationship between a function type <code>A(Args...)</code> and its reference (namely <code>A(&amp;)(Args...)</code>) is basically the same as the relationship between any type <code>T</code> and its reference (namely <code>T&amp;</code>).</p>\n<h2>Where's it used?</h2>\n<p>It's often used as a template parameter.</p>\n<p>For example <code>std::function</code> takes a function type to be stored inside the <code>std::function</code> object and you can declare such an object with:</p>\n<pre><code>std::function&lt;void(int)&gt; fn;\n</code></pre>\n", "LastEditorUserId": "493122", "LastActivityDate": "2014-06-24T13:02:35.850", "Score": "4", "CreationDate": "2014-06-24T12:57:23.830", "ParentId": "24386558", "CommentCount": "1", "LastEditDate": "2014-06-24T13:02:35.850", "OwnerUserId": "493122"}});