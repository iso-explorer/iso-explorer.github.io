post_cb({"14345674": {"Id": "14345674", "PostTypeId": "2", "Body": "<p>In C++ the type of an expression does not depend on the code environment (usually).</p>\n<p>Therefore the subexpression 2 * 2000000000 has the same type and value on the same system, no matter what the context of the containing expression, it is <code>int</code> (as both operands of the * operator are <code>int</code>s). And it would 4000000000, but on your architecture it changed it changed to -294967296 because of an overflow.</p>\n<p>Casting it to <code>long long</code> won't change the value, because the <code>long long</code> can represent -294967296 just fine.</p>\n<p>Actually it is much more interesting that <code>cout &lt;&lt; (unsigned int)(2 * 2000000000) &lt;&lt; endl;</code> works. As <code>unsinged int</code> cannot hold -294967296, overflow happens again. -294967296 and 4000000000 are congruent modulo 2^32 so this will be the new value. (Updated from the better answer of GManNickG).</p>\n<p>To illustrate the deeper problem you can try</p>\n<pre><code>cout &lt;&lt; (unsigned int)(2 * 2000000000 / 2) &lt;&lt; endl;\n</code></pre>\n<p>The division will be executed on -294967296 and the binary representation of -147483648 will be converted to unsigned which is 4147483648</p>\n", "LastEditorUserId": "680982", "LastActivityDate": "2013-01-15T21:59:47.457", "Score": "1", "CreationDate": "2013-01-15T19:49:32.870", "ParentId": "14345548", "CommentCount": "4", "OwnerUserId": "680982", "LastEditDate": "2013-01-15T21:59:47.457"}, "14345622": {"Id": "14345622", "PostTypeId": "2", "Body": "<p>In an int, the value of <code>4,000,000,000</code> is written as <code>1110 1110 0110 1011 0010 1000 0000 0000</code></p>\n<p>In an unsigned int, the value of <code>4,000,000,000</code> is written as <code>1110 1110 0110 1011 0010 1000 0000 0000</code></p>\n<p>Looking at these two, you can see that they are the same. </p>\n<p>The difference comes from the way the bits are read in a <code>int</code> and <code>unsigned int</code>. in a regular <code>int</code> the <a href=\"http://en.wikipedia.org/wiki/Most_significant_bit\" rel=\"nofollow\">most significant bit</a> is used to tell if the number is negative or not. </p>\n", "LastEditorUserId": "1496443", "LastActivityDate": "2013-01-15T19:53:30.480", "Score": "3", "CreationDate": "2013-01-15T19:46:36.583", "ParentId": "14345548", "CommentCount": "0", "OwnerUserId": "1496443", "LastEditDate": "2013-01-15T19:53:30.480"}, "14345948": {"Id": "14345948", "PostTypeId": "2", "Body": "<p>Note that signed integer overflow is undefined behavior. As a conclusion, anything can happen. Including innocently correct results.</p>\n<hr>\n<p>Both integer literals <code>2</code> and <code>2000000000</code> are 32bit wide. The result will overflow, as your compiler tells you:</p>\n<pre><code>warning: integer overflow in expression [-Woverflow]\n</code></pre>\n<p>The result of the multiplication is still a 32bit signed integer. And, in this case, the result of the overflow is luckily the correct result, when viewed as an unsigned 32bit integer. You can observe this when casting the bit pattern to a 32bit <code>unsigned int</code>. </p>\n<p>However, if you cast the value to an integer type of a larger width (e.g. 64bit), the leading bytes will be padded with <code>ff</code> (<a href=\"http://en.wikipedia.org/wiki/Sign_extension\" rel=\"nofollow\">sign extension</a>), and thus giving false results.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    long long x = 2 * 2000000000;     // 8 byte width\n    unsigned int y = 2 * 2000000000;  // 4 byte width\n    unsigned long z = 2 * 2000000000; // 8 byte width\n    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; \" \" &lt;&lt; std::dec &lt;&lt; x &lt;&lt; std::endl;\n    // output is: ffffffffee6b2800 -294967296\n    std::cout &lt;&lt; std::hex &lt;&lt; y &lt;&lt; \" \" &lt;&lt; std::dec &lt;&lt; y &lt;&lt; std::endl;\n    // output is: ee6b2800 4000000000\n    std::cout &lt;&lt; std::hex &lt;&lt; z &lt;&lt; \" \" &lt;&lt; std::dec &lt;&lt; z &lt;&lt; std::endl;\n    // output is: ffffffffee6b2800 18446744073414584320\n\n}\n</code></pre>\n</hr>", "LastEditorUserId": "1025391", "LastActivityDate": "2013-01-15T20:36:55.293", "Score": "0", "CreationDate": "2013-01-15T20:07:31.043", "ParentId": "14345548", "CommentCount": "0", "OwnerUserId": "1025391", "LastEditDate": "2013-01-15T20:36:55.293"}, "bq_ids": {"n4140": {"so_14345548_14346544_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5937}, "so_14345548_14346544_1": {"length": 29, "quality": 0.90625, "section_id": 31}}, "n3337": {"so_14345548_14346544_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5709}, "so_14345548_14346544_1": {"length": 29, "quality": 0.90625, "section_id": 28}}, "n4659": {"so_14345548_14346544_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7421}, "so_14345548_14346544_1": {"length": 29, "quality": 0.90625, "section_id": 31}}}, "14346544": {"Id": "14346544", "PostTypeId": "2", "Body": "<p>Way too much confusion going on in people trying to answer this question.</p>\n<p>Let's examine:</p>\n<p><code>2 * 2000000000</code></p>\n<p>This is an <code>int</code> multiplied by an <code>int</code>. \u00a75/4 tells us:</p>\n<blockquote>\n<p id=\"so_14345548_14346544_0\">If during the evaluation of an expression, the result is not mathematically de\ufb01ned or not in the range of representable values for its type, the behavior is unde\ufb01ned.</p>\n</blockquote>\n<p>This result is mathematically defined, but is it in the range of representable values for <code>int</code>? </p>\n<p>That depends. On many common architectures <code>int</code> has 32 bits to represent values, giving it a maximum value of 2,147,483,647. Since the mathematical result of this is 4,000,000,000, such an architecture would not be able to represent the value and the behavior is undefined. (This pretty much kills the question, because now the behavior of the entire program is undefined.) </p>\n<p>But that's just dependent on the platform. If <code>int</code> was 64 bits wide instead (note: <code>long long</code> is guaranteed to have at least 64 bits to represent values), the result would fit just fine.</p>\n<p>Let's just fix up the problem a bit though and go straight to this:</p>\n<pre><code>int x = -294967296; // -294,967,296\n</code></pre>\n<p>And let's further say this fits within the range of <code>int</code> (which for 32 bit <code>int</code> it does).</p>\n<p>Now let's cast this to an <code>unsigned int</code>:</p>\n<pre><code>unsigned int y = static_cast&lt;unsigned int&gt;(x);\n</code></pre>\n<p>What is the value of <code>y</code>? <strong>It has nothing to do with the bit representation of <code>x</code></strong>.</p>\n<p>There is no \"bit cast\" where the compiler simply treats the bits as an unsigned quantity. Conversions work with <em>values</em>. The <em>value</em> of a <code>signed int</code> converted to an <code>unsigned int</code> is defined in \u00a74.7/2:</p>\n<blockquote>\n<p id=\"so_14345548_14346544_1\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type). [Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014end note ]</p>\n</blockquote>\n<p>For us on our 32-bit (<code>unsigned</code>) <code>int</code> system, this means 4000000000. This works regardless of bits: two's-compliment, one's-compliment, magic's-compliment, etc. These are irrelevant.</p>\n<p>The <em>reason</em> you see the value you wanted in the first palce (ignoring UB) is that on your two's-compliment machine, the difference between signed and unsigned integers is indeed a matter of viewing bits differently. So when you multiplied those two <code>int</code>'s, you were \"really\" multiplying two unsigned integers, ignoring the overflow, and viewing the result as a signed integer. Then the cast changes your view once more.</p>\n<p>But the casting works independently of bits!</p>\n", "LastEditorUserId": "87234", "LastActivityDate": "2013-01-15T21:03:35.260", "Score": "4", "CreationDate": "2013-01-15T20:43:29.973", "ParentId": "14345548", "CommentCount": "0", "OwnerUserId": "87234", "LastEditDate": "2013-01-15T21:03:35.260"}, "14345548": {"ViewCount": "478", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // the following is expected to not print 4000000000\n    // because the result of an expression with two `int`\n    // returns another `int` and the actual result \n    // doesn't fit into an `int` \n    cout &lt;&lt; 2 * 2000000000 &lt;&lt; endl; // prints -294967296\n\n    // as such the following produces the correct result\n    cout &lt;&lt; 2 * 2000000000U &lt;&lt; endl; // prints 4000000000\n}\n</code></pre>\n<p>I played a bit around with casting the result to different integer types, and came accross some weird behavior. </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // unexpectedly this does print the correct result\n    cout &lt;&lt; (unsigned int)(2 * 2000000000) &lt;&lt; endl; // prints 4000000000\n\n    // this produces the same wrong result as the original statement\n    cout &lt;&lt; (long long)(2 * 2000000000) &lt;&lt; endl; // prints -294967296\n}\n</code></pre>\n<p>I expected both of the following statements to not produce the correct result, how come one did succeed and the other didn't?</p>\n", "AcceptedAnswerId": "14346544", "Title": "Integer casting bug?", "CreationDate": "2013-01-15T19:41:03.040", "Id": "14345548", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-15T20:54:50.870", "LastEditorUserId": "1025391", "LastActivityDate": "2013-01-15T21:59:47.457", "Score": "2", "OwnerUserId": "119290", "Tags": "<c++><casting><integer><integer-overflow>", "AnswerCount": "5"}, "14345795": {"Id": "14345795", "PostTypeId": "2", "Body": "<p>In the third (weird) case, the running program does this:</p>\n<pre><code>2 * 2000000000       = binary number (11101110011010110010100000000000)\nprint it as unsigned = 4000000000 \n                   (interprets the first bit (1) as part of the unsigned number)\n</code></pre>\n<p>The fourth case:</p>\n<pre><code>2 * 2000000000       = binary number (11101110011010110010100000000000, same as above) \nprint it as signed   = -294967296 \n                   (interprets the first bit (1) as negative number)\n</code></pre>\n<p>The important thing to learn is that the expression 2 * 2000000000 results in a byte sequence, and then it is interpreted as the cast operation says.  </p>\n", "LastActivityDate": "2013-01-15T19:57:52.587", "CommentCount": "0", "CreationDate": "2013-01-15T19:57:52.587", "ParentId": "14345548", "Score": "0", "OwnerUserId": "446717"}});