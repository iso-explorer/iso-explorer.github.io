post_cb({"24147994": {"ParentId": "24147150", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-06-10T18:06:54.383", "Score": "1", "LastEditorUserId": "1708801", "LastEditDate": "2014-06-14T06:40:54.877", "Id": "24147994", "OwnerUserId": "3576470", "Body": "<p>In <em>C</em> macros are just replacement text that means that the text the macro represents is copied instead of the macro name, you can put even <em>C</em> keywords in macro.</p>\n<pre><code>#define [identifier name] [value]\n</code></pre>\n<p>In the code the <em>identifier name</em> is replace by the <em>value</em>. Your definition was:</p>\n<pre><code>#define MACRO  40\n</code></pre>\n<p><code>40</code> is already an int.\nso <code>for(int i = 0; i &lt; 40; i++)</code> no cast is required.</p>\n", "LastActivityDate": "2014-06-14T06:40:54.877"}, "24147202": {"ParentId": "24147150", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-06-10T17:20:13.213", "Score": "9", "LastEditorUserId": "2455888", "LastEditDate": "2014-06-10T17:36:40.913", "Id": "24147202", "OwnerUserId": "1325084", "Body": "<p>In C and C++, macros are quite literally in-place replacement. The preprocessor will encounter these <code>#define</code>s and replace them as it finds them. That's how you can nest macros inside of macros and it only takes 1 pass to preprocess.</p>\n", "LastActivityDate": "2014-06-10T17:36:40.913"}, "24148306": {"ParentId": "24147150", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-06-10T18:24:51.217", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:20.657", "Id": "24148306", "OwnerUserId": "1708801", "Body": "<p>The <a href=\"http://en.wikipedia.org/wiki/C_preprocessor\" rel=\"nofollow noreferrer\">preprocessor</a> expands macros before the compiler even sees anything. We can see that preprocessing numbers don't have a type by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow noreferrer\">draft C99 standard</a> section <code>6.4.8</code> <em>Preprocessing numbers</em> which says:</p>\n<blockquote>\n<p id=\"so_24147150_24148306_0\">A preprocessing number does not have type or a value; it acquires both\n  after a successful conversion (as part of translation phase 7) to a\n  floating constant token or an integer constant token.</p>\n</blockquote>\n<p>The same section in the draft C++ standard is <code>2.10</code>.</p>\n<p>As we can see in <a href=\"http://en.wikipedia.org/wiki/C_preprocessor\" rel=\"nofollow noreferrer\">C preprocessor Wikipedia article</a> macro expansion happens in phase 4.</p>\n<p>The conversion of integer constants in C terminology and integer literals in C++ terminology is covered in the draft C99 standard section <code>6.4.4.1</code> <em>Integer constants</em> and the following table in paragraph <em>5</em> which says:</p>\n<blockquote>\n<p id=\"so_24147150_24148306_1\">The type of an integer constant is the first of the corresponding list\n  in which its value can be represented</p>\n</blockquote>\n<pre>\n                                           Octal or Hexadecimal\nSuffix        Decimal Constant                 Constant\n---------------------------------------------------------------------------\nnone          int                           int\n              long int                      unsigned int\n              long long int                 long int                                \n                                            unsigned long int\n                                            long long int\n                                            unsigned long long int\n---------------------------------------------------------------------------\nu or U        unsigned int                  unsigned int\n              unsigned long int             unsigned long int\n              unsigned long long int        unsigned long long int\n---------------------------------------------------------------------------\nl or L        long int                      long int\n              long long int                 unsigned long int\n                                            long long int\n                                            unsigned long long int\n---------------------------------------------------------------------------\nBoth u or U   unsigned long int             unsigned long int\nand  l or L   unsigned long long int        unsigned long long int\n---------------------------------------------------------------------------\nll or LL      long long int                 long long int\n                                            unsigend long long int\n---------------------------------------------------------------------------\nBoth u or U   unsigned long long int        unsigned long long int\nand  ll or LL\n---------------------------------------------------------------------------\n</pre>\n<p>Table is a modified version of the one from this <a href=\"https://stackoverflow.com/a/21383314/1708801\">answer</a>. The section that covers this in the draft C++ standard is section <code>2.14.2</code> which also has a similar table.</p>\n<p>So in your example <code>40</code> has no suffix and is a decimal constant and the first type it can be represented from that section of the table is <em>int</em>.</p>\n<p>At this point we now end up with the effects of using <code>40</code> with the <code>&lt;</code> operator. Since <code>i</code> and <code>40</code> are both <em>arithmetic types</em> then the  usual arithmetic conversions will be performed, which in this case will still be <em>int</em>. For <em>C99</em> this is covered in section <code>6.3.1.8</code> and C++ section <em>5</em>.</p>\n", "LastActivityDate": "2014-06-11T13:07:00.420"}, "24147344": {"ParentId": "24147150", "CommentCount": "0", "CreationDate": "2014-06-10T17:28:18.890", "OwnerUserId": "134554", "PostTypeId": "2", "Id": "24147344", "Score": "2", "Body": "<p>The compiler never sees the macro; the preprocessor expands all macros before the source text is fed into the compiler.  </p>\n<p>All the <em>compiler</em> sees is</p>\n<pre><code>for(int i = 0; i &lt; 40; i++) {...}\n</code></pre>\n<p>and the type of the constant expression <code>40</code> is determined based on the rules in section 6.4.4.1 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">2011 C standard</a> or section 2.13 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow\">online C++ standard</a>.  </p>\n", "LastActivityDate": "2014-06-10T17:28:18.890"}, "24147220": {"ParentId": "24147150", "CommentCount": "0", "CreationDate": "2014-06-10T17:21:32.363", "OwnerUserId": "1491895", "PostTypeId": "2", "Id": "24147220", "Score": "5", "Body": "<p>C macros are simply textual replacements, they have no types. Everything involving types is done <em>after</em> the macro substitution, and acts the same as if you'd typed the replacement in the original code.</p>\n", "LastActivityDate": "2014-06-10T17:21:32.363"}, "bq_ids": {"n4140": {"so_24147150_24148306_0": {"section_id": 5332, "quality": 0.65, "length": 13}, "so_24147150_24148306_1": {"section_id": 5341, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_24147150_24148306_0": {"section_id": 5129, "quality": 0.65, "length": 13}, "so_24147150_24148306_1": {"section_id": 5138, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_24147150_24148306_0": {"section_id": 6753, "quality": 0.65, "length": 13}, "so_24147150_24148306_1": {"section_id": 6762, "quality": 0.8181818181818182, "length": 9}}}, "24147150": {"CommentCount": "9", "AcceptedAnswerId": "24148306", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-10T17:16:46.120", "LastActivityDate": "2014-06-14T06:40:54.877", "LastEditDate": "2017-05-23T11:59:35.097", "ViewCount": "1624", "FavoriteCount": "2", "Title": "Are C macros implicitly cast?", "Id": "24147150", "Score": "5", "Body": "<p>I've searched SO, but haven't found an answer to this specific questions. Forgive me if it's already been answered.</p>\n<p>If you have the following: </p>\n<pre><code>#define MACRO  40\n</code></pre>\n<p>You don't assign it to a variable you use it in a loop:</p>\n<pre><code>for(int i = 0; i &lt; MACRO; i++) {...\n</code></pre>\n<p>The perprocessor then creates:</p>\n<pre><code>for(int i = 0; i &lt; 40; i++) {...\n</code></pre>\n<p>Would the compiler then implicitly cast it to an int since the comparison is with type <code>int i</code>?  I've looked at this question <a href=\"https://stackoverflow.com/questions/8584383/type-of-define-variables\">Type of #define variables</a>, and quite a few answers down Edgar Bonet implies that there is an order in which the compiler chooses how to treat the macro?</p>\n<p>This question, <a href=\"https://stackoverflow.com/questions/14603882/how-does-c-implicitly-cast-arguments-to-a-comparator-such-as\">How does C++ implicitly cast arguments to a comparator such as  &lt;?</a>, was also suggested, but only describes how implicit casting works with a comparison with two types.  Since a macro doesn't really have a type I'm not sure if this applies.</p>\n", "Tags": "<c++><c><macros><types><c-preprocessor>", "OwnerUserId": "3714897", "AnswerCount": "5"}});