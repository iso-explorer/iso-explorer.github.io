post_cb({"30994012": {"CommentCount": "4", "AcceptedAnswerId": "30994298", "PostTypeId": "1", "LastEditorUserId": "3639428", "CreationDate": "2015-06-23T04:46:07.277", "LastActivityDate": "2015-06-23T05:12:16.693", "LastEditDate": "2015-06-23T04:54:57.863", "ViewCount": "312", "FavoriteCount": "2", "Title": "How to override base classes' virtual functions that have identical names in multiple inheritance?", "Id": "30994012", "Score": "5", "Body": "<p>Suppose I have two base classes <code>B1</code> and <code>B2</code>, and a class <code>D</code> that derives from both B1 and B2 as follows:</p>\n<pre><code>class B1 {\npublic:\n  // ...\n  virtual void foo() final { cout &lt;&lt; \"Hello, B1\\n\"; }\n};\n\nclass B2 {\npublic:\n  // ...\n  virtual void foo() { cout &lt;&lt; \"Good riddance, B2!\\n\"; }\n};\n\nclass D :public B1, public B2 {\n  // ...\n};\n</code></pre>\n<p>In designing the class <code>D</code>, I want to override the member function called <code>foo()</code> from B2; however, <code>foo()</code> in B1 is marked <code>final</code> and prevents me from overriding <code>foo()</code> in B2. What is the best approach to override <code>foo()</code> from B2?</p>\n", "Tags": "<c++><design><multiple-inheritance>", "OwnerUserId": "3639428", "AnswerCount": "1"}, "30994298": {"ParentId": "30994012", "CommentCount": "2", "Body": "<p>I don't think what you want to do is possible in the manner you've shown in the question. From N3337, <em>\u00a710.3/2 [class.virtual]</em></p>\n<blockquote>\n<p id=\"so_30994012_30994298_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it overrides <code>Base::vf</code>. ...</p>\n</blockquote>\n<p><code>D::foo</code> matches all those criteria for <code>B1::foo</code> and <code>B2::foo</code>, hence it overrides <em>both</em>. And since <code>B1::foo</code> is <code>final</code>, the code is ill-formed. </p>\n<p>One workaround is to introduce an extra level of inheritance. Define a class, say <code>D2</code>, that derives from <code>B2</code> and overrides <code>B2::foo</code>. Then <code>D</code> can derive from <code>B1</code> and <code>D2</code> instead.</p>\n<pre><code>class D2 : public B2{\npublic:\n  virtual void foo() override { cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n'; }\n};\n\nclass D :public B1, public D2 \n{};\n\nD d;\n// d.foo();    // error - ambiguous\n\nD2&amp; d2 = d;\nd2.foo();   // calls D2::foo\nB2&amp; b2 = d;\nb2.foo();   // calls D2::foo\n\nB1&amp; b1 = d;\nb1.foo();   // calls B1::foo\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/20b3ab598fe7dfb5\">Live demo</a></p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "30994298", "Score": "8", "CreationDate": "2015-06-23T05:12:16.693", "LastActivityDate": "2015-06-23T05:12:16.693"}, "bq_ids": {"n4140": {"so_30994012_30994298_0": {"section_id": 7003, "quality": 0.9375, "length": 30}}, "n3337": {"so_30994012_30994298_0": {"section_id": 6749, "quality": 0.9375, "length": 30}}, "n4659": {"so_30994012_30994298_0": {"section_id": 8500, "quality": 0.9375, "length": 30}}}});