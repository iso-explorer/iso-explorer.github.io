post_cb({"6440983": {"ParentId": "6440812", "PostTypeId": "2", "CommentCount": "1", "Body": "<h3>3.9.1    Fundamental types   [basic.fundamental]</h3>\n<blockquote>\n<p id=\"so_6440812_6440983_0\">Types char16_t and char32_t denote distinct types with the same size, signedness, and alignment as uint_least16_t and uint_least32_t, respectively, in , called the underlying types.</p>\n</blockquote>\n<p>This means char16_t is at least 16 bits (but may be larger)</p>\n<p>But I also believe:</p>\n<blockquote>\n<p id=\"so_6440812_6440983_1\">The value of a char16_t literal containing a single c-char is equal to its ISO 10646 code point value, provided that the code point is representable with a single 16-bit code unit.</p>\n</blockquote>\n<p>provides the same guarantees (though less explicitly (as you have to know that ISO 10646 is UCS (Note UCS is compatible but not exactly the same as Unicode))).</p>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2011-06-22T14:38:22.980", "Id": "6440983", "Score": "10", "CreationDate": "2011-06-22T13:50:42.283", "LastActivityDate": "2011-06-22T14:38:22.980"}, "6440946": {"ParentId": "6440812", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_6440812_6440946_0\">The value of a <code>char16_t</code> literal containing a single c-char is equal to its ISO 10646 code point value, provided that the code point is representable with a single 16-bit code unit.</p>\n</blockquote>\n<p>This is impossible to satisfy if <code>char16_t</code> isn't at least 16 bits wide, so by contradiction, it's guaranteed to be <em>at least</em> that wide.</p>\n", "OwnerUserId": "166749", "LastEditorUserId": "166749", "LastEditDate": "2011-06-22T13:55:30.700", "Id": "6440946", "Score": "5", "CreationDate": "2011-06-22T13:48:40.063", "LastActivityDate": "2011-06-22T13:55:30.700"}, "6440812": {"CommentCount": "2", "AcceptedAnswerId": "6440983", "PostTypeId": "1", "LastEditorUserId": "134841", "CreationDate": "2011-06-22T13:40:01.140", "LastActivityDate": "2012-06-19T20:49:38.733", "LastEditDate": "2012-06-19T20:49:38.733", "ViewCount": "1308", "FavoriteCount": "2", "Title": "C++ What does the size of char16_t depend on?", "Id": "6440812", "Score": "11", "Body": "<p>This is also related to <code>char32_t</code> and any <code>intXX_t</code>. The specification points out that:</p>\n<p><code>2.14.3.2</code>: </p>\n<blockquote>\n<p id=\"so_6440812_6440812_0\">The value of a char16_t literal\n  containing a single c-char is equal to\n  its ISO 10646 code point value,\n  provided that the code point is\n  representable with a single 16-bit\n  code unit.</p>\n</blockquote>\n<p><code>5.3.3.1</code>:</p>\n<blockquote>\n<p id=\"so_6440812_6440812_1\">[..] in particular [..]\n  sizeof(char16_t), sizeof(char32_t),\n  and sizeof(wchar_t) are\n  implementation-defined</p>\n</blockquote>\n<p>I can not see anything about the <code>intXX_t</code> types, apart from the comment that they are \"optional\" (<code>18.4.1</code>).</p>\n<p>If a <code>char16_t</code> isn`t guaranteed to be 2 bytes, is it guaranteed to be 16 bit (even on architectures where 1 byte != 8 bit)?</p>\n", "Tags": "<c++><c++11><char16-t><char32-t>", "OwnerUserId": "547231", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_6440812_6440983_1": {"section_id": 5344, "quality": 0.9545454545454546, "length": 21}, "so_6440812_6440812_1": {"section_id": 6076, "quality": 1.0, "length": 5}, "so_6440812_6440946_0": {"section_id": 5344, "quality": 0.9545454545454546, "length": 21}, "so_6440812_6440983_0": {"section_id": 7214, "quality": 1.0, "length": 16}, "so_6440812_6440812_0": {"section_id": 5344, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_6440812_6440983_1": {"section_id": 5141, "quality": 0.9545454545454546, "length": 21}, "so_6440812_6440812_1": {"section_id": 5844, "quality": 1.0, "length": 5}, "so_6440812_6440946_0": {"section_id": 5141, "quality": 0.9545454545454546, "length": 21}, "so_6440812_6440983_0": {"section_id": 6958, "quality": 1.0, "length": 16}, "so_6440812_6440812_0": {"section_id": 5141, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_6440812_6440983_1": {"section_id": 6767, "quality": 0.9545454545454546, "length": 21}, "so_6440812_6440812_1": {"section_id": 7572, "quality": 1.0, "length": 5}, "so_6440812_6440946_0": {"section_id": 6767, "quality": 0.9545454545454546, "length": 21}, "so_6440812_6440983_0": {"section_id": 8723, "quality": 1.0, "length": 16}, "so_6440812_6440812_0": {"section_id": 6767, "quality": 0.9545454545454546, "length": 21}}}, "6441030": {"ParentId": "6440812", "CommentCount": "0", "Body": "<p>It can't be guaranteed to be exactly 16 bits, since there are platforms which don't support types that small (for example, DSPs often can't address anything smaller than their word size, which may be 24, 32 or 64 bits). Your first quote guarantees that it will be at least 16 bits.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "6441030", "Score": "2", "CreationDate": "2011-06-22T13:54:26.567", "LastActivityDate": "2011-06-22T13:54:26.567"}});