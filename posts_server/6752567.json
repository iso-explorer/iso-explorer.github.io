post_cb({"bq_ids": {"n4140": {"so_6752567_6752688_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}, "so_6752567_6752688_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 31}}, "n3337": {"so_6752567_6752688_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}, "so_6752567_6752688_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 28}}, "n4659": {"so_6752567_6752688_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}, "so_6752567_6752688_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 31}}}, "6752688": {"Id": "6752688", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6752567_6752688_0\">Is it guaranteed that if I cast a 16 bit type to an 8 bit type that the leading byte will be lost?</p>\n</blockquote>\n<p>Depends on whether you are working with signed or unsigned types (see section 4.7 \u00a72 and \u00a73):</p>\n<blockquote>\n<p id=\"so_6752567_6752688_1\">If the destination type is <strong>unsigned</strong>, the resulting value is the least unsigned integer congruent to the source integer (modulo 2^n where n is the number of bits used to represent the unsigned type). [Note: In a two's complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation).]</p>\n<p id=\"so_6752567_6752688_2\">If the destination type is <strong>signed</strong>, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is <strong>implementation-defined</strong>.</p>\n</blockquote>\n<p>Since you are working with unsigned types, the behavior is well-specified.</p>\n", "LastActivityDate": "2011-07-19T19:07:09.890", "Score": "18", "CreationDate": "2011-07-19T19:07:09.890", "ParentId": "6752567", "CommentCount": "2", "OwnerUserId": "252000"}, "6752567": {"ViewCount": "5902", "Body": "<p>I've had a good look around and can't find a similar question so apologies if it has been asked before.</p>\n<p>I'm just playing around with types and numbers and I am wondering if the following behaviour can be guaranteed.\nIf I declare 2 variables as </p>\n<pre><code>unsigned char BIT_8 = 0;\nunsigned short int BIT_16 = 0xFF01;\n</code></pre>\n<p>and then do the following (ignoring C style cast for now, unless that can affect it?)</p>\n<pre><code>cout &lt;&lt; \"BIT_16: \" &lt;&lt; BIT_16 &lt;&lt; \"\\n\";\ncout &lt;&lt; \"BIT_8: \" &lt;&lt; (int)BIT_8 &lt;&lt; \"\\n\";\nBIT_8 = BIT_16;\ncout &lt;&lt; \"BIT_8 after: \" &lt;&lt; (int)BIT_8 &lt;&lt; \"\\n\";\nBIT_8 = BIT_16 &gt;&gt; 8;\ncout &lt;&lt; \"BIT_8 after shift: \" &lt;&lt; (int)BIT_8 &lt;&lt; \"\\n\";\n</code></pre>\n<p>I get the output</p>\n<pre><code>BIT_16: 65281\nBIT_8: 0\nBIT_8 after: 1\nBIT_8 after shift: 255\n</code></pre>\n<p>Is it guaranteed that if I cast a 16 bit type to an 8 bit type that the leading byte will be lost? or is it undefined and the above results are luck?</p>\n", "AcceptedAnswerId": "6752688", "Title": "Casting a large number type to a smaller type", "CreationDate": "2011-07-19T18:58:41.180", "Id": "6752567", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2011-07-19T19:07:09.890", "Score": "15", "OwnerUserId": "681647", "Tags": "<c++><types>", "AnswerCount": "1"}});