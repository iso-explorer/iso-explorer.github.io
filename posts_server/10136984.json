post_cb({"bq_ids": {"n4140": {"so_10136984_10137837_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 466}}, "n3337": {"so_10136984_10137837_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 457}}, "n4659": {"so_10136984_10137837_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 489}}}, "10136984": {"ViewCount": "698", "Body": "<blockquote>\n<p id=\"so_10136984_10136984_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/7748104/preventing-non-const-lvalues-from-resolving-to-rvalue-reference-instead-of-const\">Preventing non-const lvalues from resolving to rvalue reference instead of const lvalue reference</a><br>\n<a href=\"https://stackoverflow.com/questions/9287250/conflict-between-copy-constructor-and-forwarding-constructor\">Conflict between copy constructor and forwarding constructor</a> </br></br></p>\n</blockquote>\n<p>I have these classes that I need for storing std::unique_ptr (adapted boost::any):</p>\n<pre><code>class any\n{\npublic:\n  any()\n    : content(0)\n  {\n  }\n\n  any(any const&amp;) = delete;\n\n  any(any &amp;&amp; other)\n    : content(other.content)\n  {\n    content = 0;\n  }\n\n  template&lt;typename ValueType&gt;\n  any(ValueType const&amp; value)\n    : content(new holder&lt;ValueType&gt;(value))\n  {\n  }\n\n  template&lt;typename ValueType&gt;\n  any(ValueType &amp;&amp; value,\n    typename std::enable_if&lt;!std::is_lvalue_reference&lt;ValueType&gt;::value,\n    void&gt;::type* = 0)\n    : content(new holder&lt;ValueType&gt;(std::move(value)))\n  {\n  }\n\n  ~any()\n  {\n    delete content;\n  }\n\npublic: // modifiers\n\n  any &amp; swap(any &amp; rhs)\n  {\n    std::swap(content, rhs.content);\n    return *this;\n  }\n\n  any &amp; operator=(const any &amp;) = delete;\n\n  any &amp; operator=(any &amp;&amp; rhs)\n  {\n    return swap(rhs);\n  }\n\n  template&lt;typename ValueType&gt;\n  any &amp; operator=(ValueType const&amp; rhs)\n  {\n    any(rhs).swap(*this);\n    return *this;\n  }\n\n  template&lt;typename ValueType&gt;\n  typename std::enable_if&lt;!std::is_lvalue_reference&lt;ValueType&gt;::value,\n    any&amp;&gt;::type operator=(ValueType &amp;&amp; rhs)\n  {\n    any(std::move(rhs)).swap(*this);\n    return *this;\n  }\n\npublic: // queries\n\n  bool empty() const\n  {\n    return !content;\n  }\n\n  const std::type_info &amp; type() const\n  {\n    return content ? content-&gt;type() : typeid(void);\n  }\n\nprivate: // types\n\n  class placeholder\n  {\n  public: // structors\n\n  virtual ~placeholder()\n  {\n  }\n\n  public: // queries\n    virtual const std::type_info &amp; type() const = 0;\n  };\n\n  template&lt;typename ValueType&gt;\n  class holder : public placeholder\n  {\n  public: // structors\n    template &lt;class T&gt;\n    holder(T &amp;&amp; value)\n      : held(std::forward&lt;T&gt;(value))\n    {\n    }\n\n    holder &amp; operator=(const holder &amp;) = delete;\n\n  public: // queries\n    virtual const std::type_info &amp; type() const\n    {\n      return typeid(ValueType);\n    }\n\n  public:\n\n    ValueType held;\n  };\n\nprivate: // representation\n\n  template&lt;typename ValueType&gt;\n  friend ValueType * any_cast(any *);\n\n  template&lt;typename ValueType&gt;\n  friend ValueType * unsafe_any_cast(any *);\n\n  placeholder * content;\n};\n</code></pre>\n<p>and this test case:</p>\n<pre><code>any a;\nany b(a);\n\nb = a;\n</code></pre>\n<p>and this one:</p>\n<pre><code>std::map&lt;int, int&gt; map({{1,1},{2,2}});\nany b(map);\nstd::cout &lt;&lt; map.size() &lt;&lt; std::endl; // displays 0\n</code></pre>\n<p>To my horror, under gdb, I've noticed that the move constructor and the move assignment operator are called when constructing and assigning <code>b</code> (even from map), even though I did not tag <code>a</code> with <code>std::move</code> and it is not a temporary. Can someone explain why?</p>\n", "Title": "why are move constructor and move assignment operator called and not copy?", "CreationDate": "2012-04-13T07:42:44.343", "Id": "10136984", "CommentCount": "2", "LastEditDate": "2017-05-23T11:56:28.023", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-04-16T06:52:49.977", "Tags": "<c++><boost><stl><c++11>", "Score": "0", "OwnerUserId": "1095108", "ClosedDate": "2012-04-13T16:10:14.983", "AnswerCount": "1"}, "10137837": {"Id": "10137837", "PostTypeId": "2", "Body": "<p>My first answer was wrong. After reading through your very unreadable code again I see that you have explicitly provided a move and default constructor, but no copy constructor. If a class has <em>any</em> user defined constructor (of which you have two), the compiler will not generate any other constructors for that class. Hence, <strong>your class does not have a copy constructor</strong>.</p>\n<p><strong>Edit</strong>: So, back to my original answer (prompted by your comment). \u00a712.8/7 [class.copy] says:</p>\n<blockquote>\n<p id=\"so_10136984_10137837_0\">A member function template is never instantiated to perform the copy\n  of a class object to an object of its class type.  [Example:</p>\n<pre><code>struct S { \n    template&lt;typename T&gt; S(T); \n    template&lt;typename T&gt; S(T&amp;&amp;);\n    S(); \n}; \n\nS f(); \nconst S g; \n\nvoid h() { \n    S a( f() );          // does not instantiate member template; \n                         // uses the implicitly generated move\n    constructor S a(g);  // does not instantiate the member template; \n                         // uses the implicitly generated copy constructor\n}\n</code></pre>\n<p id=\"so_10136984_10137837_1\">\u2014end example ]</p>\n</blockquote>\n<p>Since your copy contructor is a member-template, but your move constructor is not, the later is chosen here (your case is different from the example in that respect).</p>\n", "LastEditorUserId": "160206", "LastActivityDate": "2012-04-13T09:02:07.240", "Score": "0", "CreationDate": "2012-04-13T08:47:59.647", "ParentId": "10136984", "CommentCount": "7", "OwnerUserId": "160206", "LastEditDate": "2012-04-13T09:02:07.240"}});