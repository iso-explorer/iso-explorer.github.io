post_cb({"bq_ids": {"n4140": {"so_28176415_28176643_4": {"length": 7, "quality": 1.0, "section_id": 5947}, "so_28176415_28176643_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_28176415_28176643_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 382}, "so_28176415_28176643_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}}, "n3337": {"so_28176415_28176643_4": {"length": 7, "quality": 1.0, "section_id": 5717}, "so_28176415_28176643_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_28176415_28176643_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 373}, "so_28176415_28176643_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}}, "n4659": {"so_28176415_28176643_4": {"length": 7, "quality": 1.0, "section_id": 7433}, "so_28176415_28176643_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_28176415_28176643_1": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_28176415_28176643_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 397}}}, "28176415": {"ViewCount": "243", "Body": "<p>I know the standard has an exception about extending the lifetime of temporaries that basically says binding a const reference in a constructor won't extend the lifetime, but does this also apply to literals?  For example:</p>\n<pre><code>class C {\n    private:\n        const int&amp; ref;\n    public:\n        C(const int&amp; in)\n            : ref{in}\n        { }\n};\n</code></pre>\n<p>If I had a function returning an object of this type</p>\n<pre><code>C f() {\n    C c(2);\n    return c;\n}\n</code></pre>\n<p>Would the value of <code>c.ref</code> be undefined in the caller if I <strong>know</strong> it's bound to a literal?</p>\n", "AcceptedAnswerId": "28176643", "Title": "Can a const int ref in a constructor safely bind to a literal?", "CreationDate": "2015-01-27T17:29:19.603", "Id": "28176415", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-18T18:47:08.537", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T18:47:08.537", "Score": "9", "OwnerUserId": "1013719", "Tags": "<c++><reference><language-lawyer><temporary><object-lifetime>", "AnswerCount": "2"}, "28176547": {"Id": "28176547", "PostTypeId": "2", "Body": "<p>Short answer: Evaluating <code>c.ref</code> will almost certainly be illegal (invoke undefined behavior).</p>\n<p>Long answer:\nWhen binding a reference to an integer literal, what you are really doing is the following:</p>\n<p>The integer literal refers to what is known as \"<a href=\"https://stackoverflow.com/questions/25674834/what-is-a-value-not-associated-with-an-object\">a value that is not associated with an object</a>\".</p>\n<p>To bind a reference to it, an object needs to be created that holds the same value. The reason for that is that a reference (or pointer) must always point to an object (which in turn is nothing more than a bit of memory). Therefore, a <em>temporary</em> object is created which holds the value.</p>\n<p>Temporary objects are guaranteed to last as long as the expression they are created by is being evaluated. Since your object exists for longer, the temporary object that held your value is being destroyed early and the reference may not be accessed anymore.</p>\n<p>Note that if you access <code>c.ref</code> within the expression that created <code>c</code>, you would actually be fine.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-27T17:35:49.577", "Score": "1", "CreationDate": "2015-01-27T17:35:49.577", "ParentId": "28176415", "CommentCount": "0", "OwnerUserId": "65678", "LastEditDate": "2017-05-23T11:59:46.120"}, "28176643": {"Id": "28176643", "PostTypeId": "2", "Body": "<p><strong>No</strong>. You will not be able to use the reference after the constructor finishes execution.<br>\nWhen a prvalue of non-class type is bound to a <code>const</code>-reference of that same type, a temporary is always introduced. Thus the constructor's parameter reference will refer to a temporary that is destroyed once the reference goes out of scope. After that happens, the member reference is dangling, and attempting to access the stored value behind that reference results in UB. \n[dcl.init.ref]/5:</br></p>\n<blockquote>\n<p id=\"so_28176415_28176643_0\">A reference to type \u201c<em>cv1</em> <code>T1</code>\u201d is initialized by an expression of\n  type \u201c<em>cv2</em> <code>T2</code>\u201d as follows:</p>\n<ul>\n<li>If the reference is an lvalue reference and the initializer expression\n  <ul>\n<li>is an lvalue (but is not a bit-field), and [..]</li>\n<li>has a class type (i.e., <code>T2</code> is a class type) [..]</li>\n</ul></li>\n<li><p id=\"so_28176415_28176643_1\">Otherwise, the reference shall be an lvalue reference to a non-volatile <code>const</code> type (i.e., <em>cv1</em> shall be const), or the reference\n  shall be an rvalue reference. </p>\n<ul>\n<li><p id=\"so_28176415_28176643_2\">If the initializer expression</p>\n<ul>\n<li>is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and [..]</li>\n<li>has a class type  [..]</li>\n</ul></li>\n<li><p id=\"so_28176415_28176643_3\">Otherwise: (5.2.2.1)</p>\n<ul>\n<li>If <code>T1</code> is a class type [..]</li>\n<li><strong>If <code>T1</code> is a non-class type, a temporary of type \u201c<em>cv1</em> <code>T1</code>\u201d is created and copy-initialized (8.5) from the initializer expression.\n  The reference is then bound to the temporary.</strong></li>\n</ul></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>And integer literals are, unsurprisingly, indeed prvalues. [expr.prim.general]/1:</p>\n<blockquote>\n<p id=\"so_28176415_28176643_4\">A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p>Finally, in case this is unclear, [class.temporary]/5:</p>\n<blockquote>\n<p id=\"so_28176415_28176643_5\">The temporary to which the reference is bound or the temporary that is\n  the complete object of a subobject to which the reference is bound\n  persists for the lifetime of the reference except:</p>\n<ul>\n<li><strong>A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits.</strong></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-27T17:49:30.013", "Score": "6", "CreationDate": "2015-01-27T17:40:44.520", "ParentId": "28176415", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2015-01-27T17:49:30.013"}});