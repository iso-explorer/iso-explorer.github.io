post_cb({"bq_ids": {"n4140": {"so_4892652_4892763_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 529}, "so_4892652_4892763_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 530}}, "n3337": {"so_4892652_4892763_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 520}, "so_4892652_4892763_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 521}}, "n4659": {"so_4892652_4892763_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 550}, "so_4892652_4892763_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 551}}}, "4892652": {"ViewCount": "816", "Body": "<p>Can I safely expect this</p>\n<pre><code>#define TEMPLATE_DECL_BEGIN_0 template &lt;\n#define TEMPLATE_DECL_BEGIN_1 TEMPLATE_DECL_BEGIN_0 typename Arg0\n#define TEMPLATE_DECL_BEGIN_2 TEMPLATE_DECL_BEGIN_1 , typename Arg1\n#define TEMPLATE_DECL_BEGIN_3 TEMPLATE_DECL_BEGIN_2 , typename Arg2\n#define TEMPLATE_DECL(N) TEMPLATE_DECL_BEGIN_ ## N &gt;\n\nTEMPLATE_DECL(0)\nTEMPLATE_DECL(1)\nTEMPLATE_DECL(2)\nTEMPLATE_DECL(3)\n</code></pre>\n<p>to generate </p>\n<pre><code>template &lt; &gt;\ntemplate &lt; typename Arg0 &gt;\ntemplate &lt; typename Arg0 , typename Arg1 &gt;\ntemplate &lt; typename Arg0 , typename Arg1 , typename Arg2 &gt;\n</code></pre>\n<p>on any reasonably standard <strong>C</strong> preprocessor?</p>\n<p>My worry is about macro expansion after concatenation after previous replacement: does it work so that after <em>N</em> gets replaced for example by <em>2</em> then</p>\n<pre><code>TEMPLATE_DECL_BEGIN_2\n</code></pre>\n<p>becomes</p>\n<pre><code>TEMPLATE_DECL_BEGIN_1 , typename Arg1\n</code></pre>\n<p>?</p>\n", "AcceptedAnswerId": "4892763", "Title": "Macro concatenation and further expansion", "CreationDate": "2011-02-03T22:47:28.663", "Id": "4892652", "CommentCount": "2", "LastEditDate": "2016-03-06T23:26:57.553", "PostTypeId": "1", "LastEditorUserId": "4370109", "LastActivityDate": "2016-03-06T23:26:57.553", "Score": "1", "OwnerUserId": "239769", "Tags": "<c++><c-preprocessor>", "AnswerCount": "1"}, "4892763": {"Id": "4892763", "PostTypeId": "2", "Body": "<p>Yes. From 6.10.3.3\u00a73 of the C99 standard:</p>\n<blockquote>\n<p id=\"so_4892652_4892763_0\">For both object-like and function-like macro invocations, before the replacement list is \n  reexamined for more macro names to replace, each instance of a ## preprocessing token \n  in the replacement list (not from an argument) is deleted and the preceding preprocessing \n  token is concatenated with the following preprocessing token.</p>\n</blockquote>\n<p>And 6.10.3.4\u00a73 :</p>\n<blockquote>\n<p id=\"so_4892652_4892763_1\">After all parameters in the replacement list have been substituted and #and ## \n  processing has taken place, all placemarker preprocessing tokens are removed. Then, the \n  resulting preprocessing token sequence is rescanned, along with all subsequent \n  preprocessing tokens of the source \ufb01le, for more macro names to replace.</p>\n</blockquote>\n<p>The standard guarantees that <code>x ## y</code> happens before replacing more macro names, so if you construct a macro name at that time, it will be replaced.</p>\n<p>This is from the C99 standard, but I highly doubt they changed this secion from the C89 standard, which would be the version that really applies to C++.</p>\n", "LastActivityDate": "2011-02-03T23:00:07.933", "CommentCount": "1", "CreationDate": "2011-02-03T23:00:07.933", "ParentId": "4892652", "Score": "3", "OwnerUserId": "60777"}});