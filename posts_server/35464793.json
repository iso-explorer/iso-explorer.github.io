post_cb({"35464793": {"CommentCount": "0", "ViewCount": "142", "CreationDate": "2016-02-17T18:28:41.153", "LastActivityDate": "2016-02-17T18:47:48.060", "Title": "Why chained prefix increment/decrement for builtin type is not UB for C++?", "AcceptedAnswerId": "35464886", "PostTypeId": "1", "Id": "35464793", "Score": "8", "Body": "<p>In cpprefernce.com <a href=\"http://en.cppreference.com/w/cpp/language/operator_incdec\" rel=\"noreferrer\">example</a> for prefix increment there is such code:</p>\n<pre><code>int n1 = 1;\n...\nint n3 = ++ ++n1;\n</code></pre>\n<p>Why chained increment in this case does not lead to UB? Is rule for at most once modified not violated in this case?</p>\n", "Tags": "<c++><prefix-operator>", "OwnerUserId": "432358", "AnswerCount": "2"}, "35464886": {"ParentId": "35464793", "CommentCount": "1", "Body": "<p>In C++11 and later, UB occurs when there are two writes or a write and a read that are unsequenced and access the same memory location. But <code>++x</code> is equivalent to <code>x+=1</code>, so <code>++ ++n1</code> is equivalent to <code>(n1+=1)+=1</code>, and here the reads and writes happen in a strict sequence because of the properties of assignment and compound assignment operators: first <code>n1</code> is read, then one plus the original value is written, then the resulting value is read again, then one plus that value is written back.</p>\n<p>In C++03, this <em>was</em> UB, because of the old rule you allude to: there is no sequence point between the two modifications. But in C++11 there are no longer any sequence points; instead there is the \"sequenced before\" partial order.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "35464886", "Score": "11", "CreationDate": "2016-02-17T18:34:18.433", "LastActivityDate": "2016-02-17T18:34:18.433"}, "bq_ids": {"n4140": {"so_35464793_35464872_1": {"section_id": 5811, "quality": 0.9565217391304348, "length": 22}, "so_35464793_35464872_0": {"section_id": 6074, "quality": 0.8857142857142857, "length": 31}}, "n3337": {"so_35464793_35464872_1": {"section_id": 5584, "quality": 0.9565217391304348, "length": 22}, "so_35464793_35464872_0": {"section_id": 5842, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_35464793_35464872_0": {"section_id": 7570, "quality": 0.6857142857142857, "length": 24}, "so_35464793_35464872_1": {"section_id": 7272, "quality": 0.6956521739130435, "length": 16}}}, "35464872": {"ParentId": "35464793", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>See <a href=\"https://stackoverflow.com/a/35464886/1621391\">Brian's</a> answer for simpler terms, .</p>\n<p>It's legal cause the C++ standard says so, emphasis are mine... Going by the C++14 draft</p>\n<p><strong>5.3.2 Increment and decrement [expr.pre.incr]</strong></p>\n<blockquote>\n<p id=\"so_35464793_35464872_0\">The operand of prefix ++ is modified by adding 1, or set to true if it\n  is bool (this use is deprecated). The operand shall be a modifiable\n  lvalue. The type of the operand shall be an arithmetic type or a\n  pointer to a completely-defined object type. <strong>The result is the\n  updated operand; it is an lvalue</strong>, and it is a bit-field if the\n  operand is a bit-field. If x is not of type bool, the expression ++x\n  is equivalent to x+=1</p>\n</blockquote>\n<p>So, this is perfectly legal</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int x =8;\n    int y = ++ ++ ++ ++ ++ ++ ++ ++ x;\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y;\n\n}\n</code></pre>\n<p>Output</p>\n<pre><code>16 16\n</code></pre>\n<p><strong>1.9 Program execution [intro.execution]</strong> </p>\n<blockquote>\n<p id=\"so_35464793_35464872_1\"><strong>15</strong>...If a side effect on a scalar object is unsequenced relative to either\n  another side effect on the <strong>same scalar object</strong> or a value computation\n  using the value of the <strong>same scalar object</strong>, the behavior is undefined. ...</p>\n</blockquote>\n<p>And it's attached example:</p>\n<pre><code>void f(int, int);\nvoid g(int i, int* v) {\ni = v[i++]; // the behavior is undefined\ni = 7, i++, i++; // i becomes 9\ni = i++ + 1; // the behavior is undefined\ni = i + 1; // the value of i is incremented\nf(i = -1, i = -1); // the behavior is undefined\n}\n</code></pre>\n", "OwnerUserId": "1621391", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:50.140", "Id": "35464872", "Score": "2", "CreationDate": "2016-02-17T18:33:12.210", "LastActivityDate": "2016-02-17T18:47:48.060"}});