post_cb({"bq_ids": {"n4140": {"so_35464793_35464872_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 6074}, "so_35464793_35464872_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5811}}, "n3337": {"so_35464793_35464872_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 5842}, "so_35464793_35464872_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5584}}, "n4659": {"so_35464793_35464872_0": {"length": 24, "quality": 0.6857142857142857, "section_id": 7570}, "so_35464793_35464872_1": {"length": 16, "quality": 0.6956521739130435, "section_id": 7272}}}, "35464886": {"Id": "35464886", "PostTypeId": "2", "Body": "<p>In C++11 and later, UB occurs when there are two writes or a write and a read that are unsequenced and access the same memory location. But <code>++x</code> is equivalent to <code>x+=1</code>, so <code>++ ++n1</code> is equivalent to <code>(n1+=1)+=1</code>, and here the reads and writes happen in a strict sequence because of the properties of assignment and compound assignment operators: first <code>n1</code> is read, then one plus the original value is written, then the resulting value is read again, then one plus that value is written back.</p>\n<p>In C++03, this <em>was</em> UB, because of the old rule you allude to: there is no sequence point between the two modifications. But in C++11 there are no longer any sequence points; instead there is the \"sequenced before\" partial order.</p>\n", "LastActivityDate": "2016-02-17T18:34:18.433", "CommentCount": "1", "CreationDate": "2016-02-17T18:34:18.433", "ParentId": "35464793", "Score": "11", "OwnerUserId": "481267"}, "35464793": {"ViewCount": "142", "Body": "<p>In cpprefernce.com <a href=\"http://en.cppreference.com/w/cpp/language/operator_incdec\" rel=\"noreferrer\">example</a> for prefix increment there is such code:</p>\n<pre><code>int n1 = 1;\n...\nint n3 = ++ ++n1;\n</code></pre>\n<p>Why chained increment in this case does not lead to UB? Is rule for at most once modified not violated in this case?</p>\n", "AcceptedAnswerId": "35464886", "Title": "Why chained prefix increment/decrement for builtin type is not UB for C++?", "CreationDate": "2016-02-17T18:28:41.153", "Id": "35464793", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-02-17T18:47:48.060", "Score": "8", "OwnerUserId": "432358", "Tags": "<c++><prefix-operator>", "AnswerCount": "2"}, "35464872": {"Id": "35464872", "PostTypeId": "2", "Body": "<p>See <a href=\"https://stackoverflow.com/a/35464886/1621391\">Brian's</a> answer for simpler terms, .</p>\n<p>It's legal cause the C++ standard says so, emphasis are mine... Going by the C++14 draft</p>\n<p><strong>5.3.2 Increment and decrement [expr.pre.incr]</strong></p>\n<blockquote>\n<p id=\"so_35464793_35464872_0\">The operand of prefix ++ is modified by adding 1, or set to true if it\n  is bool (this use is deprecated). The operand shall be a modifiable\n  lvalue. The type of the operand shall be an arithmetic type or a\n  pointer to a completely-defined object type. <strong>The result is the\n  updated operand; it is an lvalue</strong>, and it is a bit-field if the\n  operand is a bit-field. If x is not of type bool, the expression ++x\n  is equivalent to x+=1</p>\n</blockquote>\n<p>So, this is perfectly legal</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int x =8;\n    int y = ++ ++ ++ ++ ++ ++ ++ ++ x;\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y;\n\n}\n</code></pre>\n<p>Output</p>\n<pre><code>16 16\n</code></pre>\n<p><strong>1.9 Program execution [intro.execution]</strong> </p>\n<blockquote>\n<p id=\"so_35464793_35464872_1\"><strong>15</strong>...If a side effect on a scalar object is unsequenced relative to either\n  another side effect on the <strong>same scalar object</strong> or a value computation\n  using the value of the <strong>same scalar object</strong>, the behavior is undefined. ...</p>\n</blockquote>\n<p>And it's attached example:</p>\n<pre><code>void f(int, int);\nvoid g(int i, int* v) {\ni = v[i++]; // the behavior is undefined\ni = 7, i++, i++; // i becomes 9\ni = i++ + 1; // the behavior is undefined\ni = i + 1; // the value of i is incremented\nf(i = -1, i = -1); // the behavior is undefined\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-17T18:47:48.060", "Score": "2", "CreationDate": "2016-02-17T18:33:12.210", "ParentId": "35464793", "CommentCount": "4", "OwnerUserId": "1621391", "LastEditDate": "2017-05-23T12:07:50.140"}});