post_cb({"bq_ids": {"n4140": {"so_14924827_14925081_0": {"length": 11, "quality": 1.0, "section_id": 399}}, "n3337": {"so_14924827_14925081_0": {"length": 11, "quality": 1.0, "section_id": 390}}}, "14925081": {"PostTypeId": "2", "Body": "<p>First, it seems that there is an issue with your compiler that uses the wrong noexcept specification. According to the standard, <em>12.4.3</em>:</p>\n<blockquote>\n<p id=\"so_14924827_14925081_0\">A declaration of a destructor that does not have an <em>exception-specification</em> is implicitly considered to have the same <em>exception-specification</em> as an implicit declaration</p>\n</blockquote>\n<p>An implicit declaration of a destructor would be <code>noexcept</code> if all the members and bases' destructors are <code>noexcept</code> as well. So your explicit destructor declaration should be equivalent to:</p>\n<pre><code>~Foo() noexcept {} // or:\n~Foo() noexcept(true) {}\n</code></pre>\n<p>but instead your compiler is treating it as:</p>\n<pre><code>~Foo() noexcept(false) {}\n</code></pre>\n<p>Second, the reason the <em>exception-specification</em> of a <em>destructor</em> affects the decision on whether to move or not is because destruction is involved in the operation. Just as <code>noexcept</code> on a <em>move-constructor</em> and a <em>move-assignment</em> operation affect the decision, move won't be used if there is a possibility that an exception might be thrown mid-process.</p>\n", "LastActivityDate": "2013-02-17T19:46:00.857", "LastEditorUserId": "927034", "Id": "14925081", "CommentCount": "0", "CreationDate": "2013-02-17T19:23:30.937", "ParentId": "14924827", "Score": "6", "OwnerUserId": "927034", "LastEditDate": "2013-02-17T19:46:00.857"}, "14924827": {"ViewCount": "246", "Body": "<p>Given the following code (<a href=\"http://liveworkspace.org/code/5oact\" rel=\"nofollow\">http://liveworkspace.org/code/5oact</a>):</p>\n<pre><code>class Foo\n {\n     public:\n         Foo()\n         {\n             log(__PRETTY_FUNCTION__);\n         }\n         Foo(const Foo&amp; other)\n         {\n             log(__PRETTY_FUNCTION__);\n         }\n         Foo&amp; operator=(const Foo&amp; other)\n         {\n             log(__PRETTY_FUNCTION__);\n             return *this;\n         }\n         Foo(Foo&amp;&amp; other) noexcept\n         {\n             log(__PRETTY_FUNCTION__);\n         }\n         Foo&amp; operator=(Foo&amp;&amp; other) noexcept\n         {\n             log(__PRETTY_FUNCTION__);\n             return *this;\n         }\n         ~Foo(){}\n };\n</code></pre>\n<p>Using the class like this:</p>\n<pre><code>std::vector&lt;Foo&gt; tt;\n\ntt.emplace_back();\ntt.emplace_back();\ntt.emplace_back();\ntt.emplace_back();\n</code></pre>\n<p>I get the following output:</p>\n<pre><code>Foo::Foo()\nFoo::Foo()\nFoo::Foo(const Foo&amp;)\nFoo::Foo()\nFoo::Foo(const Foo&amp;)\nFoo::Foo(const Foo&amp;)\nFoo::Foo()\n</code></pre>\n<p>and if I remove the custom destructor I get the following output:</p>\n<pre><code>Foo::Foo()\nFoo::Foo()\nFoo::Foo(Foo&amp;&amp;)\nFoo::Foo()\nFoo::Foo(Foo&amp;&amp;)\nFoo::Foo(Foo&amp;&amp;)\nFoo::Foo()\n</code></pre>\n<p>Why the compiler uses the copy constructor instead of the move when I declare a destructor? I understand that the move operation can't throw (and if I remove the <code>noexcept</code> from the code, the compiler won't use it at all), but what the destructor has to do with that?</p>\n", "AcceptedAnswerId": "14925081", "Title": "What is the criteria that the compiler uses to decide if a move operation is safe?", "CreationDate": "2013-02-17T18:59:41.980", "Id": "14924827", "CommentCount": "10", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-02-17T19:46:00.857", "Score": "4", "OwnerUserId": "561327", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "1"}});