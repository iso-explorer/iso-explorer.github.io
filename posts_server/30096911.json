post_cb({"bq_ids": {"n4140": {"so_30096911_30097049_3": {"length": 53, "quality": 1.0, "section_id": 474}, "so_30096911_30097049_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7207}, "so_30096911_30097049_2": {"length": 49, "quality": 1.0, "section_id": 461}, "so_30096911_30097049_1": {"length": 19, "quality": 0.95, "section_id": 5850}, "so_30096911_30097049_4": {"length": 32, "quality": 1.0, "section_id": 401}, "so_30096911_30097049_5": {"length": 45, "quality": 0.9, "section_id": 3274}}, "n3337": {"so_30096911_30097049_3": {"length": 41, "quality": 0.7735849056603774, "section_id": 465}, "so_30096911_30097049_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 6951}, "so_30096911_30097049_2": {"length": 37, "quality": 0.7551020408163265, "section_id": 452}, "so_30096911_30097049_1": {"length": 19, "quality": 0.95, "section_id": 5620}, "so_30096911_30097049_4": {"length": 32, "quality": 1.0, "section_id": 392}, "so_30096911_30097049_5": {"length": 45, "quality": 0.9, "section_id": 3145}}, "n4659": {"so_30096911_30097049_3": {"length": 40, "quality": 0.7547169811320755, "section_id": 497}, "so_30096911_30097049_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 8716}, "so_30096911_30097049_2": {"length": 36, "quality": 0.7346938775510204, "section_id": 484}, "so_30096911_30097049_1": {"length": 11, "quality": 0.55, "section_id": 7329}, "so_30096911_30097049_4": {"length": 31, "quality": 0.96875, "section_id": 419}, "so_30096911_30097049_5": {"length": 45, "quality": 0.9, "section_id": 4032}}}, "30096911": {"ViewCount": "646", "Body": "<p>With the introduction of c++11, <a href=\"http://en.cppreference.com/w/cpp/concept/TriviallyCopyable\" rel=\"nofollow\">trivially copyableness</a> has gotten quite relevant. Most notably in the use of 'std::atomic'. The basics are quite simple. A class <code>foo</code> is trivially copyable if:</p>\n<pre><code>foo* src = new foo();\nfoo* dest = malloc(sizeof(foo));\nmemcpy(dest, src, sizeof(foo));\n</code></pre>\n<p>Has the same effect as:</p>\n<pre><code>foo* src = new foo();\nfoo* dest = new foo(src);\n</code></pre>\n<p>So an object where copying the memory will have the same effect as a copy constructor. However there, of course, is a catch. There's not only copy constructors. But also move constructors, move assignment operators. Etc.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/types/is_trivially_copyable\" rel=\"nofollow\">std::is_trivially_copyable</a> can be used to test whether an object is trivially copyable. So with trial and error it is possible to make an object trivially copyable. </p>\n<p>But of course a well defined set of rules would be a bit nicer:). So hereby my request. </p>\n", "AcceptedAnswerId": "30097049", "Title": "Which rules determine whether an object is trivially copyable", "CreationDate": "2015-05-07T09:24:03.477", "Id": "30096911", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-05-07T11:56:59.030", "LastEditorUserId": "3243563", "LastActivityDate": "2017-02-07T08:25:40.653", "Score": "5", "OwnerUserId": "3243563", "Tags": "<c++><c++11><move>", "AnswerCount": "1"}, "30097049": {"Id": "30097049", "PostTypeId": "2", "Body": "<p>The most well-defined set of rules would come directly from the standard. Here are the relevant entries from standard draft N4296:</p>\n<p>Trivially-copyable types are defined in <strong>[basic.types]/9</strong></p>\n<blockquote>\n<p id=\"so_30096911_30097049_0\">Cv-unqualified scalar types, trivially copyable class types, arrays of such types, and nonvolatile\n  const-qualified versions of these types are collectively called <em>trivially copyable</em> types.</p>\n</blockquote>\n<p>Trivially-copyable classes are defined in <strong>[class]/6</strong></p>\n<blockquote>\n<p id=\"so_30096911_30097049_1\">A trivially copyable class is a class that: has no non-trivial copy constructors, has no non-trivial move constructors, has no non-trivial copy assignment operators, has no non-trivial move assignment operators, and has a trivial destructor.</p>\n</blockquote>\n<p>Copy/move constructors in <strong>[class.copy]/12</strong></p>\n<blockquote>\n<p id=\"so_30096911_30097049_2\">A copy/move constructor for class X is trivial if it is not user-provided, its parameter-type-list is equivalent to the parameter-type-list of an implicit declaration, and if class X has no virtual functions and no virtual base classes, and class X has no non-static data members of volatile-qualified type, and the constructor selected to copy/move each direct base class subobject is trivial, and for each non-static data member of X that is of class type (or array thereof), the constructor selected\n  to copy/move that member is trivial; otherwise the copy/move constructor is non-trivial.</p>\n</blockquote>\n<p>Copy/move assignment operators in <strong>[class.copy]/25</strong></p>\n<blockquote>\n<p id=\"so_30096911_30097049_3\">A copy/move assignment operator for class X is trivial if it is not user-provided, its parameter-type-list is equivalent to the parameter-type-list of an implicit declaration, and if class X has no virtual functions and no virtual base classes, and class X has no non-static data members of volatile-qualified type, and the assignment operator selected to copy/move each direct base class subobject is trivial, and for each non-static data member of X that is of class type (or array thereof), the assignment operator\n  selected to copy/move that member is trivial;\n  otherwise the copy/move assignment operator is non-trivial.</p>\n</blockquote>\n<p>Destructors in <strong>[class.dtor]/5</strong></p>\n<blockquote>\n<p id=\"so_30096911_30097049_4\">A destructor is trivial if it is not user-provided and if: the destructor is not virtual, all of the direct base classes of its class have trivial destructors, for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor. Otherwise, the destructor is non-trivial.</p>\n</blockquote>\n<p>User-provided constructors in <strong>[dcl.fct.def.default]/5</strong></p>\n<blockquote>\n<p id=\"so_30096911_30097049_5\">Explicitly-defaulted functions and implicitly-declared functions are collectively called defaulted functions,\n  and the implementation shall provide implicit definitions for them (12.1 12.4, 12.8), which might mean defining them as deleted. A function is user-provided if it is user-declared and not explicitly defaulted or\n  deleted on its first declaration. A user-provided explicitly-defaulted function (i.e., explicitly defaulted after its\n  first declaration) is defined at the point where it is explicitly defaulted; if such a function is implicitly defined\n  as deleted, the program is ill-formed. </p>\n</blockquote>\n<p>The short answer is that the short answer is sometimes more helpful than the long answer.</p>\n", "LastEditorUserId": "496161", "LastActivityDate": "2017-02-07T08:25:40.653", "Score": "10", "CreationDate": "2015-05-07T09:29:28.070", "ParentId": "30096911", "CommentCount": "0", "OwnerUserId": "496161", "LastEditDate": "2017-02-07T08:25:40.653"}});