post_cb({"1230017": {"Id": "1230017", "PostTypeId": "2", "Body": "<p>So if I get it right, the cast to unsigned char is to gaurantee an unsigned byte-by-byte copy. But then you cast it back for the return. The function looks a bit dodgy what exactly is the context/reason for setting it up this way? A quick fix might be to replace all this with a memcpy() (but as commented, do not use that on iterator objects) -- otherwise just remove the redundant casts.</p>\n", "LastEditorUserId": "149746", "LastActivityDate": "2009-08-04T22:23:14.707", "Score": "0", "CreationDate": "2009-08-04T21:27:16.617", "ParentId": "1229751", "CommentCount": "4", "OwnerUserId": "149746", "LastEditDate": "2009-08-04T22:23:14.707"}, "1229953": {"Id": "1229953", "PostTypeId": "2", "Body": "<p>The code as written is working as intended according to standard 4.7 (2), although this is guaranteed only for machines with two's complement representation.</p>\n<p>If alloc_storage returns a char*, and 'char' is signed, then if I understand 4.7 (3) correctly the result would be implementation defined if the iterator's value type is unsigned and you'd drop the cast and pass the char* to copy.</p>\n", "LastEditorUserId": "147442", "LastActivityDate": "2009-08-04T21:19:33.510", "Score": "1", "CreationDate": "2009-08-04T21:07:42.223", "ParentId": "1229751", "CommentCount": "0", "OwnerUserId": "147442", "LastEditDate": "2009-08-04T21:19:33.510"}, "1229751": {"ViewCount": "3435", "Body": "<p>I'm wondering if it is necessary to reinterpret_cast in the function below.  ITER_T might be a char*, unsigned char*, std::vector&lt;unsigned char&gt; iterator, or something else like that.  It doesn't seem to hurt so far, but does the casting ever affect how the bytes are copied at all?</p>\n<pre><code>template&lt;class ITER_T&gt;\nchar *copy_binary(\n  unsigned char length,\n  const ITER_T&amp; begin)\n{\n  // alloc_storage() returns a char*\n  unsigned char* stg = reinterpret_cast&lt;unsigned char*&gt;(alloc_storage(length));\n  std::copy(begin, begin + length, stg);\n  return reinterpret_cast&lt;char*&gt;(stg);\n}\n</code></pre>\n", "Title": "reinterpret casting to and from unsigned char* and char*", "CreationDate": "2009-08-04T20:25:12.810", "LastActivityDate": "2009-10-11T19:57:44.597", "CommentCount": "1", "PostTypeId": "1", "OwnerDisplayName": "travis", "Id": "1229751", "Score": "3", "Tags": "<c++><templates><casting>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_1229751_1551599_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 31}, "so_1229751_1551599_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7210}, "so_1229751_1551599_2": {"length": 18, "quality": 1.0, "section_id": 31}, "so_1229751_1551599_5": {"length": 10, "quality": 0.625, "section_id": 6042}, "so_1229751_1551599_4": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}}, "n3337": {"so_1229751_1551599_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 28}, "so_1229751_1551599_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6954}, "so_1229751_1551599_2": {"length": 18, "quality": 1.0, "section_id": 28}, "so_1229751_1551599_5": {"length": 10, "quality": 0.625, "section_id": 5810}, "so_1229751_1551599_4": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}}, "n4659": {"so_1229751_1551599_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 31}, "so_1229751_1551599_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 8719}, "so_1229751_1551599_2": {"length": 18, "quality": 1.0, "section_id": 31}, "so_1229751_1551599_5": {"length": 10, "quality": 0.625, "section_id": 7541}, "so_1229751_1551599_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}}, "1551599": {"Id": "1551599", "PostTypeId": "2", "Body": "<p>The short answer is yes, it could affect.</p>\n<p><em>char</em> and <em>unsigned char</em> are convertible types (3.9.1 in C++ Standard 0x n2800) so you can assign one to the other. <strong>You don't need the cast at all.</strong></p>\n<blockquote>\n<p id=\"so_1229751_1551599_0\">[3.9.1] ... A char, a signed char, and an unsigned\n  char occupy the same amount of storage\n  and have the same alignment\n  requirements; that is, they have the\n  <strong><em>same object representation</em></strong>.  </p>\n</blockquote>\n<p><br/> </p>\n<blockquote>\n<p id=\"so_1229751_1551599_1\">[4.7] ...</p>\n<p id=\"so_1229751_1551599_2\"><strong>2</strong> If the destination type is\n  unsigned, the resulting value is the\n  least unsigned integer congruent to\n  the source integer (modulo 2n where n\n  is the number of bits used to\n  represent the unsigned type). </p>\n<p id=\"so_1229751_1551599_3\"><em>[ Note:\n  In a two\u2019s complement representation,\n  this conversion is conceptual and\n  there is <strong>no change in the bit pattern</strong>\n  (if there is no truncation). \u2014end note\n  ]</em></p>\n<p id=\"so_1229751_1551599_4\"><strong>3</strong> If the destination type is signed,\n  <strong><em>the value is unchanged</em></strong> if it can be\n  represented in the destination type\n  (and bit-field width); otherwise, the\n  value is implementation-defined.</p>\n</blockquote>\n<p>Therefore even in the worst case you will get the best (less implementation-defined) conversion. Anyway in most implementations this will not change anything in the bit pattern, and you will not even have a conversion if look into the generated assembler.</p>\n<pre><code>template&lt;class ITER_T&gt;\nchar *copy_binary( unsigned char length, const ITER_T&amp; begin)\n{\n  char* stg = alloc_storage(length);\n  std::copy(begin, begin + length, stg);\n  return stg;\n}\n</code></pre>\n<p>Using reinterpret_cast you depend on the compiler:</p>\n<blockquote>\n<p id=\"so_1229751_1551599_5\">[5.2.10.3] The mapping performed by\n  reinterpret_cast is\n  <strong><em>implementation-defined</em></strong>. [ Note: it\n  might, or might not, produce a\n  representation different from the\n  original value. \u2014end note ]</p>\n</blockquote>\n<p>Note: <a href=\"https://stackoverflow.com/questions/277655/why-do-c-streams-use-char-instead-of-unsigned-char\">This</a> is an interesting related post.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-10-11T19:57:44.597", "Score": "1", "CreationDate": "2009-10-11T19:57:44.597", "ParentId": "1229751", "CommentCount": "0", "OwnerUserId": "147336", "LastEditDate": "2017-05-23T10:09:38.603"}, "1229919": {"Body": "<p><code>reinterpret_casts</code> are used for low-level implementation defined casts. According to the standard, <code>reinterpret_casts</code> can be used for the following conversions (C++03 5.2.10):</p>\n<ul>\n<li>Pointer to an integral type</li>\n<li>Integral type to Pointer</li>\n<li>A pointer to a function can be converted to a pointer to a function of a different type</li>\n<li>A pointer to an object can be converted to a pointer to an object of different type</li>\n<li>Pointer to member functions or pointer to data members can be converted to functions or objects of a different type. The result of such a pointer conversion is unspecified, except the pointer a converted back to its original type.</li>\n<li>An expression of type A can be converted to a reference to type B if a pointer to type A can be explicitly converted to type B using a <code>reinterpret_cast</code>.</li>\n</ul>\n<p>That said, using the <code>reinterpret_cast</code> is not a good solution in your case, since casting to different types are unspecified by the standard, though casting from <code>char *</code> to <code>unsigned char *</code> and back should work on most machines.</p>\n<p>In your case I would think about using a <code>static_cast</code> or not casting at all by defining <code>stg</code> as type <code>char *</code>:</p>\n<pre><code>template&lt;class ITER_T&gt;\nchar *copy_binary(\n  unsigned char length,\n  const ITER_T&amp; begin)\n{\n  // alloc_storage() returns a char*\n  char* stg = alloc_storage(length);\n  std::copy(begin, begin + length, stg);\n  return stg;\n}\n</code></pre>\n", "CreationDate": "2009-08-04T21:00:03.347", "ParentId": "1229751", "CommentCount": "2", "LastEditDate": "2009-08-04T21:25:55.510", "Id": "1229919", "PostTypeId": "2", "LastActivityDate": "2009-08-04T21:25:55.510", "LastEditorUserId": "94526", "CommunityOwnedDate": "2009-08-04T21:25:55.510", "Score": "6", "OwnerUserId": "94526"}});