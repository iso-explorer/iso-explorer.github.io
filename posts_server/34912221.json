post_cb({"34912592": {"ParentId": "34912221", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Your conclusion that </p>\n<pre><code>pair&lt;const type_index, std::string&gt; p = {typeid(int), \"int\"};\n</code></pre>\n<p>becomes</p>\n<pre><code>pair&lt;const type_index, std::string&gt; p(typeid(int), \"int\");\n</code></pre>\n<p>is not accurate because the first statement is <em>copy-list-initialization</em> while the second is <em>direct-initialization</em>. The two are identical, except that <em>copy-list-initialization</em> is ill-formed if an <code>explicit</code> constructor is chosen (and narrowing conversions are not allowed in the former).</p>\n<p>So if the <code>pair</code> constructor in question was defined as</p>\n<pre><code>template&lt;class U1, class U2&gt;\nexplicit constexpr pair(U1&amp;&amp; x, U2&amp;&amp; y);\n</code></pre>\n<p><em>direct-initialization</em> would still succeed, but <em>copy-list-initialization</em> would fail. Quoting from right below the parts of <em>[over.match.list]</em> you quoted</p>\n<blockquote>\n<p id=\"so_34912221_34912592_0\">In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<hr>\n<p>Other than that, everything else you've said is correct. The <code>pair</code> constructor is an implicit conversion because the constructor is not <code>explicit</code> and it's considered for overload resolution according to the second bullet of <em>[over.match.list]</em> because <code>pair</code> doesn't have an initializer list constructor.</p>\n</hr>", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2016-01-20T23:35:38.470", "Id": "34912592", "Score": "3", "CreationDate": "2016-01-20T23:24:06.447", "LastActivityDate": "2016-01-20T23:35:38.470"}, "34912221": {"CommentCount": "0", "AcceptedAnswerId": "34912592", "PostTypeId": "1", "LastEditorUserId": "4338785", "CreationDate": "2016-01-20T22:54:37.537", "LastActivityDate": "2016-01-20T23:35:38.470", "LastEditDate": "2016-01-20T22:56:59.727", "ViewCount": "412", "FavoriteCount": "1", "Title": "Is list-initialization an implicit conversion?", "Id": "34912221", "Score": "6", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;typeinfo&gt;\n#include &lt;typeindex&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nclass Base{\npublic:\n    virtual ~Base() {}\n\n};\n\nclass Derived: public Base { };\n\nint main(){\n\n    int arr[10];\n    Derived d;\n    Base *p = &amp;d;\n\n    std::map&lt;std::type_index, std::string&gt; proper_name = {\n        {typeid(int), \"int\"}, {typeid(double), \"double\"}, {typeid(float), \"float\"}, {typeid(char), \"char\"},\n        {typeid(Base), \"Base\"}, {typeid(Derived), \"Derived\"}, {typeid(std::string), \"String\"},\n        {typeid(int[10]), \"Ten int Array\"}, {typeid(p), \"Base Pointer\"}};\n\n}\n</code></pre>\n<p>I'm trying to make sense of the implicit conversions that occur in this list-initialization. From <code>13.3.1.7</code> of N3337:</p>\n<blockquote>\n<p id=\"so_34912221_34912221_0\">When objects of non-aggregate class type T are list-initialized (8.5.4), overload resolution selects the constructor in two phases: </p>\n<ol>\n<li><p id=\"so_34912221_34912221_1\">Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the argument list consists of the initializer list as a single argument.</p></li>\n<li><p id=\"so_34912221_34912221_2\">If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</p></li>\n</ol>\n</blockquote>\n<p><code>8.5.4</code>:</p>\n<blockquote>\n<p id=\"so_34912221_34912221_3\">A constructor is an initializer-list constructor if its first parameter is of type <code>std::initializer_list&lt;E&gt;</code> or reference to possibly cv-qualified <code>std::initializer_list&lt;E&gt;</code> for some type <code>E</code>, and either there are no other parameters or else all other parameters have default arguments</p>\n</blockquote>\n<p>So <a href=\"http://www.cplusplus.com/reference/map/map/map/\">the following</a> list of constructors for <code>std::map</code> indicates </p>\n<p><code>map (initializer_list&lt;value_type&gt; il,\n     const key_compare&amp; comp = key_compare(),\n     const allocator_type&amp; alloc = allocator_type())</code>;</p>\n<p>is the candidate function, <code>value_type</code> in this case is <code>pair&lt;const type_index, std::string&gt;</code>. Lastly from <code>13.3.3.1.5</code>: </p>\n<blockquote>\n<p id=\"so_34912221_34912221_4\">If the parameter type is <code>std::initializer_list&lt;X&gt;</code> or \u201carray of <code>X</code>\u201d135 and all the elements of the initializer list can be implicitly converted to <code>X</code>, the implicit conversion sequence is the worst conversion necessary to convert an element of the list to <code>X</code>.</p>\n</blockquote>\n<p>So it is a valid conversion as long as the elements of the braced-list implicitly convert to <code>pair&lt;const type_index, std::string&gt;</code>. But those elements are also braced-lists themselves. <code>Pair</code> does not take an initializer-list constructor, <a href=\"http://en.cppreference.com/w/cpp/utility/pair/pair\">from here</a> it seems that copy-initialization from a braced-init list uses the second part of <code>13.3.1.7</code> to construct the object. So the following:</p>\n<pre><code>pair&lt;const type_index, std::string&gt; p = {typeid(int), \"int\"}\n</code></pre>\n<p>becomes:</p>\n<pre><code>pair&lt;const type_index, std::string&gt; p(typeid(int), \"int\")\n</code></pre>\n<p>but is this considered an implicit conversion? How can use of a two-argument constructor be considered an implicit conversion? What are the standard's comments on this?</p>\n", "Tags": "<c++><c++11><language-lawyer><list-initialization>", "OwnerUserId": "4338785", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34912221_34912221_4": {"section_id": 630, "quality": 0.9047619047619048, "length": 19}, "so_34912221_34912221_3": {"section_id": 3324, "quality": 1.0, "length": 25}, "so_34912221_34912221_2": {"section_id": 599, "quality": 1.0, "length": 20}, "so_34912221_34912221_0": {"section_id": 599, "quality": 0.9230769230769231, "length": 12}, "so_34912221_34912592_0": {"section_id": 599, "quality": 1.0, "length": 6}, "so_34912221_34912221_1": {"section_id": 599, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_34912221_34912221_4": {"section_id": 621, "quality": 0.9523809523809523, "length": 20}, "so_34912221_34912221_3": {"section_id": 3194, "quality": 1.0, "length": 25}, "so_34912221_34912221_2": {"section_id": 589, "quality": 1.0, "length": 20}, "so_34912221_34912221_0": {"section_id": 589, "quality": 0.9230769230769231, "length": 12}, "so_34912221_34912592_0": {"section_id": 589, "quality": 1.0, "length": 6}, "so_34912221_34912221_1": {"section_id": 589, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_34912221_34912221_4": {"section_id": 658, "quality": 0.9047619047619048, "length": 19}, "so_34912221_34912592_0": {"section_id": 622, "quality": 1.0, "length": 6}, "so_34912221_34912221_0": {"section_id": 622, "quality": 0.9230769230769231, "length": 12}, "so_34912221_34912221_3": {"section_id": 4090, "quality": 0.96, "length": 24}, "so_34912221_34912221_2": {"section_id": 622, "quality": 1.0, "length": 20}, "so_34912221_34912221_1": {"section_id": 622, "quality": 0.9285714285714286, "length": 13}}}});