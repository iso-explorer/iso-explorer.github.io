post_cb({"bq_ids": {"n4140": {"so_31755029_31755465_0": {"length": 26, "quality": 1.0, "section_id": 135}}, "n3337": {"so_31755029_31755465_0": {"length": 26, "quality": 1.0, "section_id": 129}}, "n4659": {"so_31755029_31755465_0": {"length": 26, "quality": 1.0, "section_id": 139}}}, "31755465": {"Id": "31755465", "PostTypeId": "2", "Body": "<p>Your code is ill-formed, no diagnostic required, according to [temp.class.spec]:</p>\n<blockquote>\n<p id=\"so_31755029_31755465_0\">A partial specialization <strong>shall be declared before the first use</strong> of a class\n  template specialization that would make use of the partial specialization as the result of an implicit or\n  explicit instantiation <strong>in every translation unit</strong> in which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<p>That said, for such a case, you don't need a partial specialization at all, and can simply forward along your members:</p>\n<pre><code>// from the primary\nvoid print() {\n    print(\"T1\", d_t1);\n    print(\"T2\", d_t2);\n}\n</code></pre>\n<p>Where:</p>\n<pre><code>// has print()\ntemplate &lt;typename T,\n          typename = std::enable_if_t&lt;has_print&lt;T&gt;::value&gt;&gt;\nvoid print(const char* name, const T&amp; val) {\n    std::cout &lt;&lt; name &lt;&lt; \" is: \";\n    val.print();\n    std::cout &lt;&lt; std::endl;\n}\n\n// has noPrint()\ntemplate &lt;typename T,\n          typename = std::enable_if_t&lt;has_noprint&lt;T&gt;::value&gt;&gt;\nvoid print(const char* /* unused */, const T&amp; val) {\n    std::cout &lt;&lt; \"NoPrint: \";\n    val.noPrint();\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I'll leave the implementation of those type traits as an exercise to the reader. For a guide to several different ways of how to write such a thing, see <a href=\"https://stackoverflow.com/q/30189926/2069064\">this question</a>, with solutions involving <a href=\"https://stackoverflow.com/a/30197624/2069064\"><code>std::experimental::is_detected</code></a>, <a href=\"https://stackoverflow.com/a/30190799/2069064\"><code>void_t</code></a>, <a href=\"https://stackoverflow.com/a/30190317/2069064\">overload resolution with trailing-return-type</a>, <a href=\"https://stackoverflow.com/a/30195655/2069064\"><code>can_apply</code></a>, and <a href=\"https://stackoverflow.com/a/30191562/2069064\"><code>REQUIRES</code></a>. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-31T21:40:32.707", "Score": "3", "CreationDate": "2015-07-31T21:29:19.250", "ParentId": "31755029", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T12:29:50.150"}, "31755029": {"ViewCount": "114", "Body": "<p>This a follow-up to [question]: <a href=\"https://stackoverflow.com/questions/31751138/no-generated-code-for-explicitly-specialized-template-even-with-explicit-instant\">No generated code for explicitly specialized template even with explicit instantiation</a>.</p>\n<p>I am using partial specializations in a .cpp file to handle special cases while not forcing all the code into a header file. A simplified example of what I'm doing is given below. This works with both gcc and clang, but given the answer to the question above, I'm wondering if I'm just getting lucky that the linker is finding compatible symbols.</p>\n<p>I'm starting with a class template defined in foo.hpp:</p>\n<pre><code>#pragma once\n\ntemplate &lt;typename T1, typename T2&gt;\nclass foo\n{\npublic:\n  foo (T1 t1, T2 t2) : d_t1(t1), d_t2(t2) {}\n  ~foo () = default;\n\n  void print ();\nprivate:\n  T1 d_t1;\n  T2 d_t2;\n};\n</code></pre>\n<p>Note that the print() method is declared, but not defined.</p>\n<p>Now in the foo.cpp, I define the print() method.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T1, typename T2&gt;\nvoid\nfoo&lt;T1,T2&gt;::print()\n{\n    std::cout &lt;&lt; \"T1 is: \";\n    d_t1.print();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"T2 is: \";\n    d_t2.print();\n    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Note that this implementation assumes that both T1 and T2 will have a method called print(). In my real world code, the types which are used as arguments to this template usually conform to this interface, but sometimes they don't and I deal with that through partial specialization in the .cpp file. This template is not meant for really generic usage, it only needs to work with a small number of types which I know up-front.</p>\n<p>So for instance, I might have 3 types such as</p>\n<pre><code>class HasPrint\n{\npublic:\n  HasPrint () = default;\n  ~HasPrint () = default;\n\n  void print ();\n\n};\n\nclass AlsoHasPrint\n{\npublic:\n  AlsoHasPrint () = default;\n  ~AlsoHasPrint () = default;\n\n  void print ();\n\n};\n\nclass NoPrint\n{\npublic:\n  NoPrint () = default;\n  ~NoPrint () = default;\n\n  void noPrint ();\n\n};\n</code></pre>\n<p>Note that 'HasPrint' and 'AlsoHasPrint' classes have a print() method, while the 'NoPrint' class has a noPrint() method. In the bodies of these classes the print/noPrint methods simply print the name of the class.</p>\n<p>To handle the case of someone using NoPrint as one of the template arguments, I define a partial specialization in the foo.cpp file:</p>\n<pre><code>template &lt;typename T2&gt;\nclass foo &lt;NoPrint, T2&gt;\n{\npublic:\n  foo (NoPrint n1, T2 t2) : d_n1(n1), d_t2(t2) {}\n  ~foo () = default;\n\n  void print ()\n  {\n    std::cout &lt;&lt; \"NoPrint is: \";\n    d_n1.noPrint();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"T2 is: \";\n    d_t2.print();\n    std::cout &lt;&lt; std::endl;\n  }\nprivate:\n  NoPrint d_n1;\n  T2 d_t2;\n};\n</code></pre>\n<p>Then to get all the code I need generated for all the permutations that I use, I include (in the foo.cpp file) the following explicit instantiations of foo.</p>\n<pre><code>template class foo&lt;HasPrint, HasPrint&gt;;\ntemplate class foo&lt;HasPrint, AlsoHasPrint&gt;;\ntemplate class foo&lt;AlsoHasPrint, AlsoHasPrint&gt;;\ntemplate class foo&lt;NoPrint, HasPrint&gt;;\n</code></pre>\n<p>The result of the last explicit instantiation is that code is generated for an expansion of the template using the NoPrint object and calling the method noPrint().</p>\n<p>In a separate test.cpp file, I have the driver for my test program.</p>\n<pre><code>#include \"foo.hpp\"\n#include \"hasprint.hpp\"\n#include \"alsohasprint.hpp\"\n#include \"noprint.hpp\"\n\nint\nmain (int argc, char** argv)\n{\n  HasPrint h1;\n  HasPrint h2;\n  AlsoHasPrint a1;\n  NoPrint n1;\n  foo&lt;HasPrint, HasPrint&gt; f1 (h1, h2);\n  foo&lt;HasPrint, AlsoHasPrint&gt; f2 (h1, a1);\n  foo&lt;AlsoHasPrint, AlsoHasPrint&gt; f3 (a1, a1);\n  foo&lt;NoPrint, HasPrint&gt; f4 (n1, h1);\n\n\n  f1.print();\n  f2.print();\n  f3.print();\n  f4.print();\n}\n</code></pre>\n<p>This works as expected on both gcc 4.8.3 and clang 3.2. The result is:</p>\n<pre><code>T1 is: HasPrint\nT2 is: HasPrint\n\nT1 is: HasPrint\nT2 is: AlsoHasPrint\n\nT1 is: AlsoHasPrint\nT2 is: AlsoHasPrint\n\nNoPrint is: NoPrint\nT2 is: HasPrint\n</code></pre>\n<p>This keeps the header for foo.hpp nice and clean at the expense of needing to use explicit instantiation for each set of types for which I use the template, and a partial specialization if one of the argument types does not conform to the interface. </p>\n<p>Given that I'm using the type Foo&lt; NoPrint, HasPrint &gt; in the test driver, without informing the compiler that a specialization exists, is this \"well-formed\" or am I just getting lucky?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "31755465", "Title": "Is partial specialization in a cpp file not \"well-formed\"", "CreationDate": "2015-07-31T20:54:49.527", "Id": "31755029", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:58:19.643", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-31T21:40:32.707", "Score": "2", "OwnerUserId": "5178460", "Tags": "<c++><templates><c++11><partial-specialization>", "AnswerCount": "1"}});