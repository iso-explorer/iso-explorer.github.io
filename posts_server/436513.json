post_cb({"436802": {"Id": "436802", "PostTypeId": "2", "Body": "<p>For questions such as this, i like to look into the Rationale document for C, which often provides answers to C++ mysteries as well, that sometimes arise for me when reading the Standard. It has this to say about it:</p>\n<blockquote>\n<p id=\"so_436513_436802_0\">Three types of char are specified: signed, plain, and unsigned.  A plain char may be represented as either signed or unsigned, depending upon the implementation, as in prior practice.  The type signed char was introduced to make available a one-byte signed integer type on those systems which implement plain char as unsigned.  For reasons of symmetry, the keyword signed is allowed as part of the type name of other integral types. </p>\n</blockquote>\n<p><a href=\"http://www.lysator.liu.se/c/rat/title.html\" rel=\"noreferrer\">Rationale for C</a></p>\n", "OwnerDisplayName": "litb", "LastActivityDate": "2009-01-12T20:01:42.470", "Score": "20", "CreationDate": "2009-01-12T20:01:42.470", "ParentId": "436513", "CommentCount": "2", "OwnerUserId": "34509"}, "436561": {"Body": "<p>Here is your answer from the standard:</p>\n<blockquote>\n<p id=\"so_436513_436561_0\">3.9.1  Fundamental types                           [basic.fundamental]</p>\n<p id=\"so_436513_436561_1\">Objects declared as characters (<code>char</code>) shall be large enough to store   any member of the implementation's basic character set.  If a character from this set is stored in a character object, the integral value of that character object is equal to the value of the single character literal form of that character.  It is implementation-defined whether a <code>char</code> object can hold negative values.  Characters can be explicitly declared <code>unsigned</code> or <code>signed</code>. <strong><em>Plain <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are three distinct types.</em></strong>  A <code>char</code>, a <code>signed char</code>, and an <code>unsigned char</code>  occupy the same amount of storage and have the same alignment requirements (<em>basic.types</em>); that is, they have the same object  representation.   For character types, all bits of the object representation participate in the value representation.  For unsigned character types, all possible bit patterns of the value representation represent numbers. These requirements do not hold for other types.  In any particular\n  implementation, a plain <code>char</code> object can take on either the same values as a <code>signed char</code> or an <code>unsigned char</code>; which one is implementation-defined.</p>\n</blockquote>\n", "CreationDate": "2009-01-12T18:58:48.243", "ParentId": "436513", "CommentCount": "0", "LastEditDate": "2018-03-07T08:47:37.047", "PostTypeId": "2", "OwnerDisplayName": "Greg Rogers", "LastEditorUserId": "65863", "LastActivityDate": "2018-03-07T08:47:37.047", "Id": "436561", "Score": "55", "OwnerUserId": "5963"}, "436538": {"Body": "<p>that's correct, <code>char</code>, <code>unsigned char</code> and <code>signed char</code> are separate types. It probably would have been nice if <code>char</code> was just a synonym for either <code>signed char</code> or <code>unsigned char</code> depending on your compilers implementation, but the standard says they are separate types.</p>\n", "CreationDate": "2009-01-12T18:51:10.567", "ParentId": "436513", "CommentCount": "0", "LastEditDate": "2014-11-03T12:40:33.250", "PostTypeId": "2", "OwnerDisplayName": "Evan Teran", "LastEditorUserId": "13430", "LastActivityDate": "2014-11-03T12:40:33.250", "Id": "436538", "Score": "13", "OwnerUserId": "13430"}, "436628": {"Body": "<p>While most integral types like <code>short</code> and <code>int</code> default to being <code>signed</code>, <code>char</code> does not have a default signage in C++.  </p>\n<p>It's a common mistake that C++ programmers run into when they use <code>char</code> as an 8 bit integer type.</p>\n", "CreationDate": "2009-01-12T19:18:29.420", "ParentId": "436513", "CommentCount": "2", "LastEditDate": "2017-10-16T23:41:06.577", "PostTypeId": "2", "LastEditorDisplayName": "Rob Kennedy", "LastActivityDate": "2017-10-16T23:41:06.577", "LastEditorUserId": "16287", "Id": "436628", "OwnerDisplayName": "Shmoopty", "Score": "16", "OwnerUserId": "16287"}, "bq_ids": {"n4140": {"so_436513_436561_1": {"length": 107, "quality": 0.9469026548672567, "section_id": 7210}}, "n3337": {"so_436513_436561_1": {"length": 107, "quality": 0.9469026548672567, "section_id": 6954}}, "n4659": {"so_436513_436561_1": {"length": 103, "quality": 0.911504424778761, "section_id": 8719}}}, "436513": {"ViewCount": "14576", "Body": "<p>The code below compiles, but has different behavior for the char type than for the int types.</p>\n<p>In particular</p>\n<pre><code>   cout &lt;&lt; getIsTrue&lt; isX&lt;int8&gt;::ikIsX  &gt;() &lt;&lt; endl;\n   cout &lt;&lt; getIsTrue&lt; isX&lt;uint8&gt;::ikIsX  &gt;() &lt;&lt; endl;\n   cout &lt;&lt; getIsTrue&lt; isX&lt;char&gt;::ikIsX  &gt;() &lt;&lt; endl;\n</code></pre>\n<p>result in 3 instantiations of templates for three types: int8, uint8 and char. What gives?</p>\n<p>The same is not true for ints: int and uint32 which result in the same template instantiation, and signed int another.</p>\n<p>The reason seems to be that C++ sees char, signed char and unsigned char as three different types. Whereas int is the same as a signed int. Is this right or am I missing something?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef   signed char       int8;\ntypedef unsigned char      uint8;\ntypedef   signed short      int16;\ntypedef unsigned short     uint16;\ntypedef   signed int        int32;\ntypedef unsigned int       uint32;\ntypedef   signed long long  int64;\ntypedef unsigned long long uint64;\n\nstruct TrueType {};\nstruct FalseType {};\n\ntemplate &lt;typename T&gt;\nstruct isX\n{\n   typedef typename T::ikIsX ikIsX;\n};\n\n\n// This  int==int32 is ambiguous\n//template &lt;&gt;            struct isX&lt;int  &gt;    { typedef FalseType ikIsX; };  // Fails\ntemplate &lt;&gt;            struct isX&lt;int32  &gt;  { typedef FalseType ikIsX; };\ntemplate &lt;&gt;            struct isX&lt;uint32 &gt;  { typedef FalseType ikIsX; };\n\n\n// Whay isn't this ambiguous? char==int8\ntemplate &lt;&gt;            struct isX&lt;char  &gt;  { typedef FalseType ikIsX; };\ntemplate &lt;&gt;            struct isX&lt;int8  &gt;  { typedef FalseType ikIsX; };\ntemplate &lt;&gt;            struct isX&lt;uint8 &gt;  { typedef FalseType ikIsX; };\n\n\ntemplate &lt;typename T&gt; bool getIsTrue();\ntemplate &lt;&gt;           bool getIsTrue&lt;TrueType&gt;() { return true; }\ntemplate &lt;&gt;           bool getIsTrue&lt;FalseType&gt;() { return false; }\n\nint main(int, char **t )\n{\n   cout &lt;&lt; sizeof(int8) &lt;&lt; endl;  // 1\n   cout &lt;&lt; sizeof(uint8) &lt;&lt; endl; // 1\n   cout &lt;&lt; sizeof(char) &lt;&lt; endl;  // 1\n\n   cout &lt;&lt; getIsTrue&lt; isX&lt;int8&gt;::ikIsX  &gt;() &lt;&lt; endl;\n   cout &lt;&lt; getIsTrue&lt; isX&lt;uint8&gt;::ikIsX  &gt;() &lt;&lt; endl;\n   cout &lt;&lt; getIsTrue&lt; isX&lt;char&gt;::ikIsX  &gt;() &lt;&lt; endl;\n\n   cout &lt;&lt; getIsTrue&lt; isX&lt;int32&gt;::ikIsX  &gt;() &lt;&lt; endl;\n   cout &lt;&lt; getIsTrue&lt; isX&lt;uint32&gt;::ikIsX  &gt;() &lt;&lt; endl;\n   cout &lt;&lt; getIsTrue&lt; isX&lt;int&gt;::ikIsX  &gt;() &lt;&lt; endl;\n\n}\n</code></pre>\n<p>I'm using g++ 4.something</p>\n", "AcceptedAnswerId": "436561", "Title": "char!=(signed char), char!=(unsigned char)", "CreationDate": "2009-01-12T18:41:08.420", "Id": "436513", "CommentCount": "2", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2018-03-07T13:56:52.457", "LastEditorDisplayName": "Martin York", "LastEditorUserId": "1000551", "LastActivityDate": "2018-03-07T13:56:52.457", "Score": "35", "OwnerUserId": "48956", "Tags": "<c++><char>", "AnswerCount": "4"}});