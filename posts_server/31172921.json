post_cb({"31172921": {"CommentCount": "1", "ViewCount": "568", "PostTypeId": "1", "LastEditorUserId": "1013719", "CreationDate": "2015-07-01T22:45:50.730", "LastActivityDate": "2015-07-02T01:56:30.640", "Title": "Different overloads with std::function parameters is ambiguous with bind (sometimes)", "FavoriteCount": "2", "LastEditDate": "2015-07-02T01:56:30.640", "Id": "31172921", "Score": "3", "Body": "<p>I have two overloads of a function <code>foo</code> which take different <code>std::function</code>s which results in an ambiguity issue for the latter when used with the result of a <code>std::bind</code>.  I don't understand why <em>only</em> this is ambiguous.</p>\n<pre><code>void foo(std::function&lt;void(int)&gt;) {}\nvoid foo(std::function&lt;int()&gt;) {}\n\nvoid take_int(int) { }\nint ret_int() { return 0; }\n</code></pre>\n<p>When using <code>int()</code> with a <code>bind</code> function I get an ambiguity error</p>\n<pre><code>foo(std::bind(ret_int)); // ERROR\n</code></pre>\n<p>With the gcc-5.1 error (and similar with clang)</p>\n<pre><code>error: call to 'foo' is ambiguous\n  foo(std::bind(ret_int));\n  ^~~\nnote: candidate function\nvoid foo(std::function&lt;void(int)&gt;) {}\n     ^\nnote: candidate function\nvoid foo(std::function&lt;int()&gt;) {}\n</code></pre>\n<p>However all of the following work</p>\n<pre><code>foo(std::bind(take_int, _1));\nfoo(take_int);\n\nfoo(ret_int);\nfoo([](){ return ret_int(); });\n\nstruct TakeInt {\n  void operator()(int) const { }\n};\n\nstruct RetInt {\n  int operator()() const { return 0; }\n};\n\nfoo(TakeInt{});\nfoo(RetInt{});\n</code></pre>\n<p>Looking at the <code>std::function</code> constructor</p>\n<pre><code>template&lt; class F &gt; \nfunction( F f );\n</code></pre>\n<p>it would make sense to me that any function with multiple overloads on different <code>std::function</code> types should have ambiguities, but it's only an issue with the call to bind.  I then thought \"maybe there's some magic happening to handle function types and lambdas and it doesn't deal with actual classes,\" but it handles those too.</p>\n<p>There's a note on en.cppreference that says [since c++14]</p>\n<blockquote>\n<p id=\"so_31172921_31172921_0\">This constructor does not participate in overload resolution unless f is Callable for argument types Args... and return type R</p>\n</blockquote>\n", "Tags": "<c++><overloading><c++14><std-function><stdbind>", "OwnerUserId": "1013719", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31172921_31173681_2": {"section_id": 4660, "quality": 0.8333333333333334, "length": 10}, "so_31172921_31172921_0": {"section_id": 4660, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_31172921_31173681_2": {"section_id": 6030, "quality": 0.6666666666666666, "length": 8}, "so_31172921_31172921_0": {"section_id": 6030, "quality": 0.6666666666666666, "length": 8}}}, "31173681": {"ParentId": "31172921", "LastEditDate": "2015-07-02T01:17:59.557", "CommentCount": "3", "CreationDate": "2015-07-02T00:14:02.517", "Score": "4", "LastEditorUserId": "1013719", "PostTypeId": "2", "Id": "31173681", "OwnerUserId": "1013719", "Body": "<p>The problem exists in how bind is allowed to be called.  As <a href=\"http://en.cppreference.com/w/cpp/utility/functional/bind\" rel=\"nofollow\">cppreference states</a></p>\n<blockquote>\n<p id=\"so_31172921_31173681_0\">If some of the arguments that are supplied in the call to g() are not matched by any placeholders stored in g, the unused arguments are evaluated and discarded.</p>\n</blockquote>\n<p>In other words, you need to pass <em>at least</em> as many arguments as the underlying functor expects.</p>\n<p>This means that the following is valid</p>\n<pre><code>int f();\nauto b = std::bind(f);\nb(1, 2, 3); // arguments aren't used\n</code></pre>\n<p>So saying</p>\n<pre><code>auto b = std::bind(ret_int)\nb(1);\n</code></pre>\n<p>Works, with the <code>1</code> discarded, therefore the following is valid, and overload selection becomes ambiguous</p>\n<pre><code>std::function&lt;void(int)&gt; f = std::bind(ret_int);\n</code></pre>\n<p>The inverse is not true, however</p>\n<pre><code>std::function&lt;int()&gt; f = std::bind(take_int);\n</code></pre>\n<p>because <code>take_int</code> cannot be called with no arguments.</p>\n<p>Takeaway: lambda &gt; bind</p>\n<hr>\n<p>This specific case seems broken under C++14 though</p>\n<p>N4140 20.9.11.2.1/8</p>\n<blockquote>\n<p id=\"so_31172921_31173681_1\"><code>template&lt;class F&gt; function(F f);</code></p>\n<p id=\"so_31172921_31173681_2\">Remarks: These constructors shall not participate in overload resolution unless f is Callable for argument types ArgTypes... and <strong>return type R</strong></p>\n</blockquote>\n<p>because <code>ret_int</code> does not return <code>void</code> when called with no arguments.</p>\n</hr>", "LastActivityDate": "2015-07-02T01:17:59.557"}});