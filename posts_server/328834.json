post_cb({"328900": {"ParentId": "328834", "CommentCount": "0", "Body": "<p>Nothing will happen if you call free with a NULL parameter, or delete with an NULL operand. Both are defined to accept NULL and perform no action.</p>\n<p>There are any number of thing you can change in C++ code which can affect how fast it runs. Often the most useful (in approximate order) are:</p>\n<ul>\n<li>Use good algorithms. This is a big topic, but for example, I recently halved the running time of a bit of code by using a std::vector instead of a std::list, in a case where elements were being added and removed only at the end.</li>\n<li>Avoid repeating long calculations.</li>\n<li>Avoid creating and copying objects unnecessarily (but anything which happens less than 10 million times per minute won't make any significant difference, unless you're handling something <em>really big</em>, like a vector of 10 million items).</li>\n<li>Compile with optimisation.</li>\n<li>Mark commonly-used functions (again, anything called more than 100 million times in your 10 minute runtime), as inline.</li>\n</ul>\n<p>Having said that, divideandconquer is absolutely right - you can't effectively speed your program up unless you know what it spends its time doing. Sometimes this can be guessed correctly when you know how the code works, other times it's very surprising. So it's best to profile. Even if you can't profile the code to see exactly where the time is spent, if you measure what effect your changes have you can often figure it out eventually.</p>\n", "OwnerUserId": "13005", "Id": "328900", "PostTypeId": "2", "OwnerDisplayName": "onebyone.livejournal.com", "Score": "4", "CreationDate": "2008-11-30T14:27:22.237", "LastActivityDate": "2008-11-30T14:27:22.237"}, "329131": {"CommentCount": "1", "CreationDate": "2008-11-30T18:03:12.193", "LastEditorUserId": "39992", "LastActivityDate": "2012-04-15T16:16:51.713", "ParentId": "328834", "PostTypeId": "2", "LastEditorDisplayName": "strager", "LastEditDate": "2012-04-15T16:16:51.713", "Id": "329131", "Score": "55", "Body": "<p>Some performance notes about new/delete and malloc/free:</p>\n<p>malloc and free <strong>do not</strong> call the constructor and deconstructor, respectively.  This means your classes won't get initalized or deinitialized automatically, which could be bad (e.g. uninitalized pointers)!  This doesn't matter for POD data types like char and double, though, since they don't really have a ctor.</p>\n<p>new and delete <strong>do</strong> call the constructor and deconstructor.  This means your class instances are initalized and deinitialized automatically.  However, normally there's a performance hit (compared to plain allocation), but that's for the better.</p>\n<p>I suggest staying consistent with new/malloc usage unless you have a reason (e.g. realloc).  This way, you have less dependencies, reducing your code size and load time (only by a smidgin, though).  Also, you won't mess up by free'ing something allocated with new, or deleting something allocated with malloc.  (This will most likely cause a crash!)</p>\n", "OwnerUserId": "39992", "OwnerDisplayName": "strager"}, "328905": {"ParentId": "328834", "CommentCount": "0", "Body": "<p>On question 2:<br>\nPrevious answers are excellent. But I just wanted to add something about pre-optimization. Assuming a program of moderate complexity, the 90/10 rule usually applies - i.e. 90% of the execution time is spent in 10% of the code. \"Optimized\" code is often harder to read and to maintain. So, always solve the problems first, then see where the bottlenecks are (profiling is a good tool).<br/></br></p>\n", "OwnerUserId": "36828", "Id": "328905", "PostTypeId": "2", "OwnerDisplayName": "E Dominique", "Score": "2", "CreationDate": "2008-11-30T14:35:32.220", "LastActivityDate": "2008-11-30T14:35:32.220"}, "328909": {"CommentCount": "0", "CreationDate": "2008-11-30T14:40:08.950", "LastEditorUserId": "-1", "LastActivityDate": "2008-11-30T15:03:48.373", "ParentId": "328834", "PostTypeId": "2", "LastEditorDisplayName": "cic", "LastEditDate": "2017-05-23T12:09:33.837", "Id": "328909", "Score": "7", "Body": "<p>Question one: nothing will happen.</p>\n<p>From the current draft of ISO/IEC 14882 (or: C++):</p>\n<blockquote>\n<h2>20.8.15 C Library [c.malloc]</h2>\n<p id=\"so_328834_328909_0\">The contents [of <code>&lt;cstdlib&gt;</code>, that is: where <code>free</code> lives,] are the same as the Standard C library [(see intro.refs for that)] header <code>&lt;stdlib.h&gt;</code>, with the following changes: [nothing that effects this answer].</p>\n</blockquote>\n<p>So, from ISO/IEC 9899:1999 (or: C):</p>\n<blockquote>\n<h2>7.20.3.2 The <code>free</code> function</h2>\n<p id=\"so_328834_328909_1\">If [the] <code>ptr</code> [parameter] is a null pointer, <strong>no action occurs</strong>.</p>\n</blockquote>\n<p>From the C++ standard again, for information about <code>delete</code> this time:</p>\n<blockquote>\n<h2>3.7.4.2 Deallocation functions [basic.stc.dynamic.deallocation]</h2>\n<p id=\"so_328834_328909_2\">The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, <strong>the call has no effect</strong>.</p>\n</blockquote>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/240212/what-is-the-difference-between-newdelete-and-mallocfree\">What is the difference between <code>new</code>/<code>delete</code> and <code>malloc</code>/<code>free</code>?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/135474/what-happens-when-you-try-to-free-already-freed-memory-in-c\">What happens when you try to <code>free()</code> already <code>free</code>d memory in c?</a></li>\n</ul>\n", "OwnerUserId": "4771", "OwnerDisplayName": "cic"}, "329094": {"ParentId": "328834", "CommentCount": "0", "Body": "<p>As others have pointed out deleting (or freeing) a NULL pointer will not do anything. However if you had allocated some memory then whether to use free() or delete depends upon the method you used to allocate them. For example, if you had used malloc() to allocate memory then you should free() and if you had used new to allocate then you should use delete. However, be careful not to mix the memory allocations. Use a single way to allocate and deallocate them.</p>\n<p>For the second question, it will be very difficult to generalize without seeing the actual code. It should be taken on a case by case basis.</p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "329094", "Score": "2", "CreationDate": "2008-11-30T17:30:50.043", "LastActivityDate": "2008-11-30T17:30:50.043"}, "328841": {"ParentId": "328834", "CommentCount": "0", "Body": "<p>Answer 1: Both <code>free(p)</code> and <code>delete p</code> work fine with a NULL pointer.</p>\n<p>Answer 2: Impossible to answer without seeing the slow parts of the code. You should profile the code! If you are using Linux I suggest using Callgrind (part of <a href=\"http://valgrind.org/\" rel=\"noreferrer\">Valgrind</a>) to find out what parts of the execution takes the most time.</p>\n", "OwnerUserId": "20444", "Id": "328841", "PostTypeId": "2", "OwnerDisplayName": "divideandconquer.se", "Score": "13", "CreationDate": "2008-11-30T13:13:57.347", "LastActivityDate": "2008-11-30T13:13:57.347"}, "328834": {"CommentCount": "6", "CreationDate": "2008-11-30T13:06:00.327", "PostTypeId": "1", "LastEditorUserId": "13295", "FavoriteCount": "11", "LastActivityDate": "2012-04-15T16:16:51.713", "LastEditDate": "2009-07-06T23:06:12.220", "ViewCount": "55633", "LastEditorDisplayName": "Konrad Rudolph", "Title": "C++: delete vs. free and performance", "Id": "328834", "Score": "20", "Body": "<ol>\n<li><p>Consider:</p>\n<pre><code>char *p=NULL;\nfree(p) // or\ndelete p;\n</code></pre>\n<p>What will happen if i use <code>free</code> and <code>delete</code> on <code>p</code>?</p></li>\n<li><p>If a program taking more time for execution, suppose 10 minutes, is there any way to reduce its running time to 5 minutes?</p></li>\n</ol>\n", "Tags": "<c++><pointers><performance>", "OwnerUserId": "41522", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_328834_328909_2": {"section_id": 7182, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_328834_328909_2": {"section_id": 6926, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_328834_328909_2": {"section_id": 8690, "quality": 0.9444444444444444, "length": 17}}}, "329534": {"CommentCount": "0", "CreationDate": "2008-11-30T22:41:35.187", "LastEditorUserId": "-1", "LastActivityDate": "2008-11-30T23:01:44.570", "ParentId": "328834", "PostTypeId": "2", "LastEditorDisplayName": "Mike Dunlavey", "LastEditDate": "2017-05-23T11:46:33.167", "Id": "329534", "Score": "1", "Body": "<p>Good answers all.</p>\n<p>On the performance issue, <a href=\"https://stackoverflow.com/questions/266373/one-could-use-a-profiler-but-why-not-just-halt-the-program\">this</a> provides a method that most can't imagine will work, but a few know it does, surprisingly well.</p>\n<p>The 90/10 rule is true. In my experience, there usually are multiple trouble spots, and they usually are at mid-levels of the call stack. They often are caused by using over-general data structures, but you should never fix something unless you've proven that it actually is a problem. Performance problems are amazingly unpredictable.</p>\n<p>Fixing any single performance problem may not give you the speedup you need, but each one you fix makes the remaining ones take a larger percentage of the remaining time, so they become easier to find. The speedups combine in a compounded fashion, so you may be surprised at the final result.</p>\n<p>When you can no longer find significant problems that you can fix, you've done about as well as you can. Sometimes, at that point, a redesign (such as using code generation) can set off a further round of speedups.</p>\n", "OwnerUserId": "23771", "OwnerDisplayName": "Mike Dunlavey"}});