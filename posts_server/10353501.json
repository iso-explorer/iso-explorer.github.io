post_cb({"10354022": {"ParentId": "10353501", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I believe the key phrase here is</p>\n<blockquote>\n<p id=\"so_10353501_10354022_0\">creating a new static or not</p>\n</blockquote>\n<p>If this happens during destruction  of static objects, and would cause a recreation  of some of the already destroyed static objects, when would <em>they</em> then be destroyed? What if it causes a loop? How is the system supposed to be tracking all of this? Are the possible benefits worth the trouble?</p>\n<p>Probably not, as the language standard explicitly decides not to define this.</p>\n", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2012-04-27T16:12:42.647", "Id": "10354022", "Score": "2", "CreationDate": "2012-04-27T16:04:02.140", "LastActivityDate": "2012-04-27T16:12:42.647"}, "10353501": {"CommentCount": "0", "AcceptedAnswerId": "10354022", "CreationDate": "2012-04-27T15:31:31.740", "LastActivityDate": "2012-04-27T16:12:42.647", "PostTypeId": "1", "ViewCount": "587", "FavoriteCount": "0", "Title": "Static destruction of local-static object", "Id": "10353501", "Score": "1", "Body": "<p>Help me understand this... see bold.  From the Standard 3.6.3 Termination (2)</p>\n<blockquote>\n<p id=\"so_10353501_10353501_0\">2 If a function contains a block-scope object of static or thread\n  storage duration that has been destroyed and the function is called\n  during the destruction of an object with static or thread storage\n  duration, the program has <strong>unde\ufb01ned behavior if the \ufb02ow of control\n  passes through the de\ufb01nition of the previously destroyed blockscope\n  object</strong>. Likewise, the behavior is unde\ufb01ned if the block-scope object\n  is used indirectly (i.e., through a pointer) after its destruction.</p>\n</blockquote>\n<pre><code>Manager&amp; GetManager()\n{\n    static Manager localMan;\n    return localMan;\n}\n</code></pre>\n<p>Then somewhere else...</p>\n<pre><code>{\n   static User localUser;\n   localUser.DoSomething(); //localUser calls GetManager and uses the reference returned.\n}\n</code></pre>\n<p>Then in the User destructor...</p>\n<pre><code>User::~User()\n{\n   GetManager().DoSomethingOneLastTime();\n}\n\n//Now lets say Main exits and static destruction begins.\n//Somehow localMan is destructed before User.\n//Then user calls the GetManager() function in it's destructor.\n//What case is this defined, and what case makes this undefined?\n</code></pre>\n<p>Is the standard saying that if the local static localMan object that was statically created with the odr-use rule was destructed, and then the function was called again (creating a new static or not) this is undefined? It looks like it leaves room for there is defined behavior, but if it passes through the definition of the destructed object it is not.</p>\n<p>Anyone have clear insight on this?</p>\n", "Tags": "<c++><static><local><termination><destruction>", "OwnerUserId": "1202165", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_10353501_10353501_0": {"section_id": 7157, "quality": 0.9024390243902439, "length": 37}}, "n3337": {"so_10353501_10353501_0": {"section_id": 6901, "quality": 0.9024390243902439, "length": 37}}, "n4659": {"so_10353501_10353501_0": {"section_id": 8664, "quality": 0.9024390243902439, "length": 37}}}});