post_cb({"21384604": {"CommentCount": "9", "AcceptedAnswerId": "21385079", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-01-27T15:20:56.040", "LastActivityDate": "2014-01-28T16:15:57.770", "LastEditDate": "2017-05-23T12:30:14.647", "ViewCount": "498", "FavoriteCount": "2", "Title": "Why will two-phase lookup fail to choose overloaded version of 'swap'?", "Id": "21384604", "Score": "8", "Body": "<p>I am studying <a href=\"https://stackoverflow.com/a/8439357/368896\">this fascinating answer</a> to a <a href=\"https://stackoverflow.com/q/11562/368896\">subtle question</a> regarding the <strong>best practice to implement the <code>swap</code> function for user-defined types</strong>.  (My question was initially motivated by a <a href=\"https://stackoverflow.com/a/321039/368896\">discussion of the illegality of adding types to namespace <code>std</code></a>.)</p>\n<p>I will not re-print the code snippet from the above-linked answer here.</p>\n<p>Instead, I would like to <em>understand</em> the answer.</p>\n<p>The answer I've linked above states, beneath the first code snippet, in regards to <strong>overloading <code>swap</code> in <code>namespace std</code></strong> (rather than <em>specializing</em> it in that namespace):</p>\n<blockquote>\n<p id=\"so_21384604_21384604_0\">If your compiler prints out something different then it is not\n  correctly implementing \"two-phase lookup\" for templates.</p>\n</blockquote>\n<p>The answer then goes on to point out that <strong>specializing <code>swap</code> in <code>namespace std</code></strong> (as opposed to <em>overloading</em> it) <strong>produces a different result</strong> (the desired result in the case of <em>specialization</em>).</p>\n<p>However, the answer proceeds with an additional case: <strong>specializing swap for a user-defined <em>template</em> class</strong> - in which case, again, the desired result is not achieved.</p>\n<p>Unfortunately, the answer simply <em>states</em> the facts; it does not explain <strong>why</strong>.</p>\n<p>Can someone please elaborate on that answer, and describe the process of lookup in the two specific code snippets provided in that answer:</p>\n<ul>\n<li><p><strong>overloading <code>swap</code> in <code>namespace std</code> for a user-defined non-template class</strong> (as in the first code snippet of the linked answer)</p></li>\n<li><p><strong>specializing <code>swap</code> in <code>namespace std</code> for a user-defined template class</strong> (as in the final code snippet of the linked answer)</p></li>\n</ul>\n<p>In both cases, the generic <code>std::swap</code> is called, rather than the user-defined <code>swap</code>.  Why?</p>\n<p>(This will shed light on the nature of two-phase lookup, and the reason for the <a href=\"https://stackoverflow.com/a/2684544/368896\">best practice for implementing user-defined <code>swap</code></a>; thanks.)</p>\n", "Tags": "<c++><templates><c++11><swap><argument-dependent-lookup>", "OwnerUserId": "368896", "AnswerCount": "2"}, "21386142": {"ParentId": "21384604", "CommentCount": "4", "CreationDate": "2014-01-27T16:28:49.363", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "21386142", "Score": "4", "Body": "<p>It is impossible to overload <code>swap</code> in <code>namespace std</code> for a user defined type.  Introduction an overload (as opposed to a specialization) in <code>namespace std</code> is undefined behavior (illegal under the standard, no diagnosis required).</p>\n<p>It is impossible to specialize a function in general for a <code>template</code> class (as opposed to a <code>template</code> class <em>instance</em> -- ie, <code>std::vector&lt;int&gt;</code> is an instance, while <code>std::vector&lt;T&gt;</code> is the entire <code>template</code> class).  What appears to be a specialization is actually an overload.  So the first paragraph applies.</p>\n<p>The best practice for implementing user-defined <code>swap</code> is to introduce a <code>swap</code> function or overload in the same namespace as your <code>template</code> or <code>class</code> lives in.</p>\n<p>Then, if <code>swap</code> is called in the right context (<code>using std::swap;  swap(a,b);</code>), which is how it is called in <code>std</code> library, ADL will kick in, and your overload will be found.</p>\n<p>The other option is to do a full specialization of <code>swap</code> in <code>std</code> for your particular type.  This is impossible (or impractical) for <code>template</code> classes, as you need to specialize for each and every instance of your <code>template</code> class that exists.  For other classes, it is fragile, as specialization applies to only that particular type: subclasses will have to be respecialized in <code>std</code> as well.</p>\n<p>In general, specialization of functions is extremely fragile, and you are better off introducing overrides.  As you cannot introduce overrides into <code>std</code>, the only place they will be reliably found from is in your own <code>namespace</code>.  Such overrides in your own namespace are preferred over overrides in <code>std</code> as well.</p>\n<p>There are two ways to inject a <code>swap</code> into your namespace.  Both work for this purpose:</p>\n<pre><code>namespace test {\n  struct A {};\n  struct B {};\n  void swap(A&amp;, A&amp;) { std::cout &lt;&lt; \"swap(A&amp;,A&amp;)\\n\"; }\n  struct C {\n    friend void swap(C&amp;, C&amp;) { std::cout &lt;&lt; \"swap(C&amp;, C&amp;)\\n\"; }\n  };\n\n  void bob() {\n    using std::swap;\n    test::A a, b;\n    swap(a,b);\n    test::B x, y;\n    swap(x, y);\n    C u, v;\n    swap(u, v);\n  }\n}\n\nvoid foo() {\n  using std::swap;\n  test::A a, b;\n  swap(a,b);\n  test::B x, y;\n  swap(x, y);\n  test::C u, v;\n  swap(u, v);\n\n  test::bob();\n}\nint main() {\n  foo();\n  return 0;\n}\n</code></pre>\n<p>the first is to inject it into the <code>namespace</code> directly, the second is to include it as an inline <code>friend</code>.  The inline <code>friend</code> for \"external operators\" is a common pattern that basically means you can only find <code>swap</code> via ADL, but in this particular context does not add much.</p>\n", "LastActivityDate": "2014-01-27T16:28:49.363"}, "21385079": {"ParentId": "21384604", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2014-01-27T15:41:31.237", "Score": "7", "LastEditorUserId": "819272", "LastEditDate": "2014-01-28T16:15:57.770", "Id": "21385079", "OwnerUserId": "819272", "Body": "<h2>Preamble with plenty of Standardese</h2>\n<p>The call to <code>swap()</code> in the example entails a dependent name because its arguments <code>begin[0]</code> and <code>begin[1]</code> depend on the template parameter <code>T</code> of the surrounding <code>algorithm()</code> function template. Two-phase name lookup for such dependent names is defined in the Standard as follows:</p>\n<p><strong>14.6.4.2 Candidate functions [temp.dep.candidate]</strong></p>\n<blockquote>\n<p id=\"so_21384604_21385079_0\">1 For a function call where the post\ufb01x-expression is a dependent name,\n  the candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2) except that: </p>\n<p id=\"so_21384604_21385079_1\">\u2014 For the part of the lookup using unquali\ufb01ed name lookup (3.4.1), only function declarations from the template de\ufb01nition\n  context are found. </p>\n<p id=\"so_21384604_21385079_2\">\u2014 For the part of the lookup using associated\n  namespaces (3.4.2), only function declarations found in either the\n  template de\ufb01nition context or the template instantiation context are\n  found.</p>\n</blockquote>\n<p>Unqualified lookup is defined by</p>\n<p><strong>3.4.1 Unquali\ufb01ed name lookup [basic.lookup.unqual]</strong></p>\n<blockquote>\n<p id=\"so_21384604_21385079_3\">1 In all the cases listed in 3.4.1, the scopes are searched for a\n  declaration in the order listed in each of the respective categories;\n  <strong>name lookup ends as soon as a declaration is found</strong> for the name. If no\n  declaration is found, the program is ill-formed.</p>\n</blockquote>\n<p>and argument-dependent lookup (ADL) as</p>\n<p><strong>3.4.2 Argument-dependent name lookup [basic.lookup.argdep]</strong></p>\n<blockquote>\n<p id=\"so_21384604_21385079_4\">1 When the postfix-expression in a function call (5.2.2) is <strong>an\n  unqualified-id</strong>, other namespaces not considered during the usual\n  unqualified lookup (3.4.1) may be searched, and in those namespaces,\n  namespace-scope friend function or function template declarations\n  (11.3) not otherwise visible may be found. These modifications to the\n  search <strong>depend on the types of the arguments</strong> (and for template template\n  arguments, the namespace of the template argument).</p>\n</blockquote>\n<h2>Applying the Standard to the example</h2>\n<p>The <strong>first example</strong> calls <code>exp::swap()</code>. This is not a dependent name and does not require two-phase name lookup. Because the call to swap is qualified, ordinary lookup takes place which finds only the generic <code>swap(T&amp;, T&amp;)</code> function template. </p>\n<p>The <strong>second example</strong> (what @HowardHinnant calls \"the modern solution\") calls <code>swap()</code> and also has an overload <code>swap(A&amp;, A&amp;)</code> in the same namespace as where <code>class A</code> lives (the global namespace in this case). Because the call to swap is unqualified, both ordinary lookup and ADL take place at the point of definition (again only finding the generic <code>swap(T&amp;, T&amp;)</code>) but another ADL takes place at the point of instantiation (i.e where <code>exp::algorithm()</code> is being called in <code>main()</code>) and this picks up <code>swap(A&amp;, A&amp;)</code> which is a better match during overload resolution. </p>\n<p>So far so good. Now for the encore: the <strong>third example</strong> calls <code>swap()</code> and has a specialization <code>template&lt;&gt; swap(A&amp;, A&amp;)</code> inside <code>namespace exp</code>. The lookup is the same as in the second example, but now ADL does not pick up the template specialization because it is not in an associated namespace of <code>class A</code>. However, even though the specialization <code>template&lt;&gt; swap(A&amp;, A&amp;)</code> does not play a role during overload resolution, it is still instantiated at the point of use.</p>\n<p>Finally, the <strong>fourth example</strong> calls <code>swap()</code> and has an overload <code>template&lt;class T&gt; swap(A&lt;T&gt;&amp;, A&lt;T&gt;&amp;)</code> inside <code>namespace exp</code> for <code>template&lt;class T&gt; class A</code> living in the global namespace. The lookup is the same as in the third example, and again ADL does not pick up the overload <code>swap(A&lt;T&gt;&amp;, A&lt;T&gt;&amp;)</code> because it is not in an associated namespace of the class template <code>A&lt;T&gt;</code>. And in this case, there is also no specialization that has to be instantiated at the point of use, so the generic <code>swap(T&amp;, T&amp;)</code> is being callled here.</p>\n<h2>Conclusion</h2>\n<p>Even though you are not allowed to add new overloads to <code>namespace std</code>, and only explicit specializations, it would not even work because of the various intricacies of two-phase name lookup.</p>\n", "LastActivityDate": "2014-01-28T16:15:57.770"}, "bq_ids": {"n4140": {"so_21384604_21385079_4": {"section_id": 7103, "quality": 0.9, "length": 36}, "so_21384604_21385079_0": {"section_id": 224, "quality": 0.7647058823529411, "length": 13}, "so_21384604_21385079_3": {"section_id": 7087, "quality": 0.9545454545454546, "length": 21}, "so_21384604_21385079_1": {"section_id": 224, "quality": 0.7142857142857143, "length": 10}, "so_21384604_21385079_2": {"section_id": 224, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_21384604_21385079_4": {"section_id": 6847, "quality": 0.85, "length": 34}, "so_21384604_21385079_0": {"section_id": 217, "quality": 0.5882352941176471, "length": 10}, "so_21384604_21385079_3": {"section_id": 6831, "quality": 0.9545454545454546, "length": 21}, "so_21384604_21385079_1": {"section_id": 217, "quality": 0.7142857142857143, "length": 10}, "so_21384604_21385079_2": {"section_id": 217, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_21384604_21385079_4": {"section_id": 8604, "quality": 0.9, "length": 36}, "so_21384604_21385079_1": {"section_id": 232, "quality": 0.7142857142857143, "length": 10}, "so_21384604_21385079_3": {"section_id": 8588, "quality": 0.9545454545454546, "length": 21}, "so_21384604_21385079_0": {"section_id": 232, "quality": 0.7647058823529411, "length": 13}, "so_21384604_21385079_2": {"section_id": 232, "quality": 0.8333333333333334, "length": 15}}}});