post_cb({"bq_ids": {"n4140": {"so_14616979_14617173_0": {"length": 26, "quality": 0.7222222222222222, "section_id": 5518}}, "n3337": {"so_14616979_14617173_0": {"length": 26, "quality": 0.7222222222222222, "section_id": 5304}}, "n4659": {"so_14616979_14617173_0": {"length": 26, "quality": 0.7222222222222222, "section_id": 6953}}}, "14616979": {"ViewCount": "463", "Body": "<p>I've read the last C++11 draft (n3337 - is it the last one?), and I got a question for a possible implementation I've been working on.</p>\n<p>Let's say we have this code:</p>\n<pre><code>extern \"Objective C\" {\n  class Object {\n    public:\n      static Object *alloc();\n      Object *init();\n  };\n};\n</code></pre>\n<p>Then calling</p>\n<pre><code>Object *x = Object::alloc()-&gt;init();\n</code></pre>\n<p>The question is that I didn't understand if it is allowed for the compiler to control the calling convention of extern \"X\" blocks: the idea would be to \"translate\" the calls to objc_msgSend(blablabla) - would that be conformant to the standard, or would it be considered an extension (since it wouldn't just modify the symbol name, but as well as a complex \"calling convention\" here)? Of course I could implement this by making a weak function that is called as __thiscall and then calls and returns the method itself - but the question continues, would it be conformant?</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "14617173", "Title": "C++ Standard regarding external linkage and calling conventions", "CreationDate": "2013-01-31T01:27:58.463", "Id": "14616979", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-01-31T04:12:34.787", "Score": "0", "OwnerUserId": "1934349", "Tags": "<c++><objective-c><extern><linkage>", "AnswerCount": "1"}, "14617173": {"Id": "14617173", "PostTypeId": "2", "Body": "<p>Everything you describe sounds to be in line with the intent of the language linkage feature.</p>\n<p>Class members are specifically excluded from <code>\"C\"</code> language linkage. According to examples in the Standard (C++11 \u00a77.5/4), function pointer types within class member declarations, <code>extern</code> declarations in any context, and all other function declarations do inherit the enclosing <code>extern \"C\" {}</code> block. You're defining a language linkage besides <code>\"C\"</code> but it would be least surprising to follow its example, perhaps with extra mapping between <code>this</code> and <code>self</code>.</p>\n<p>The requirements are open, according to \u00a77.5/2:</p>\n<blockquote>\n<p id=\"so_14616979_14617173_0\">Use of a <em>string-literal</em> other than \"C\" or \"C++\" is conditionally-supported, with implementation-defined semantics. [ Note: Therefore, a linkage-specification with a string- literal that is unknown to the implementation requires a diagnostic. \u2014 end note ] [ Note: It is recommended that the spelling of the string-literal be taken from the document defining that language. For example, Ada (not ADA) and Fortran or FORTRAN, depending on the vintage. \u2014 end note ]</p>\n</blockquote>\n<p>You could switch to a completely different language within the braces an it would be alright. (Although, grammatically, I suppose everything should parse as a C++ <em>declaration</em> or <em>declaration-seq</em>.)</p>\n<p>According to that, though, you should use <code>extern \"Objective-C\"</code> with a hyphen since the definitive document's title is \"The Objective-C Programming Language.\"</p>\n<p><strong>EDIT:</strong> To be sure, calling through <code>objc_msgSend</code> doesn't affect anything that the Standard specifies. Nowhere does it say how C++ functions are called. The added intermediate function is just machine-level instructions, beyond language semantics, and no different from the special instructions used to call into Pascal, Fortran, etc., e.g. by altering the order of parameters on the stack. I don't mean to compare your scheme to \"switching to a completely different language within the braces,\" just to emphasize that there's plenty of headroom.</p>\n<p>Taking the <code>extern \"C\"</code> specification in the Standard as an example, it breaks a lot of things by fundamentally changing the ODR rule because C isn't required to support any mangling. So your scheme is allowed to break <em>at least</em> that much.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2013-01-31T04:12:34.787", "Score": "1", "CreationDate": "2013-01-31T01:51:04.167", "ParentId": "14616979", "CommentCount": "6", "LastEditDate": "2013-01-31T04:12:34.787", "OwnerUserId": "153285"}});