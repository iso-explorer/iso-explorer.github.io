post_cb({"26010140": {"ParentId": "26009080", "CommentCount": "3", "CreationDate": "2014-09-24T06:35:59.687", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26010140", "Score": "0", "Body": "<p>As you've noted the following is not allowed:</p>\n<pre><code>extern int a[5];\nint a[6];\n</code></pre>\n<p>anyway there's a catch for</p>\n<pre><code>extern int a[];\nint a[6];\n</code></pre>\n<p>\u00a73.5/10</p>\n<blockquote>\n<p id=\"so_26009080_26010140_0\">After all adjustments of types (during which typedefs (7.1.3) are replaced by their definitions), the types\n  specified by all declarations referring to a given variable or function shall be identical, <strong>except that declarations\n  for an array object can specify array types that differ by the presence or absence of a major array\n  bound (8.3.4)</strong>. A violation of this rule on type identity does not require a diagnostic.</p>\n</blockquote>\n<p>That's actually an exception to the rule. This won't work if the type is different</p>\n<pre><code>extern int arr[];\nfloat arr[6];\n</code></pre>\n", "LastActivityDate": "2014-09-24T06:35:59.687"}, "26009080": {"CommentCount": "2", "CreationDate": "2014-09-24T05:17:01.020", "PostTypeId": "1", "AcceptedAnswerId": "26010140", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-24T06:35:59.687", "AnswerCount": "1", "LastEditDate": "2017-05-23T12:21:40.977", "ViewCount": "50", "FavoriteCount": "1", "Title": "Formal understanding of the complete type concept", "Id": "26009080", "Score": "3", "Body": "<p>I'm trying to understand that concept formally. Section 13/1 says:</p>\n<blockquote>\n<p id=\"so_26009080_26009080_0\">two declarations in the same scope that declare the same name but with\n  <strong>different types</strong> are called overloaded declarations. <strong>Only function</strong> and\n  <strong>function template</strong> declarations <strong>can be  overloaded</strong>; variable and type\n  declarations cannot be overloaded.</p>\n</blockquote>\n<p>That formally means, for example that programs contains the following:</p>\n<pre><code>extern int a[5];\nint a[6];\n</code></pre>\n<p>are ill-formed because of the types <code>int[5]</code> and <code>int[6]</code> are different. </p>\n<p>Now consider the declaration</p>\n<pre><code>extern int a[];\nint a[6];\n</code></pre>\n<p>The standard says that 3.9/6:</p>\n<blockquote>\n<p id=\"so_26009080_26009080_1\">The declared type of an array object might be an array of unknown size\n  and therefore be incomplete at one point in a translation unit and\n  complete later on; <strong>the array types at those two points (\u201carray of\n  unknown bound of T\u201d and \u201carray of N T\u201d) are different types</strong>.</p>\n</blockquote>\n<p>But, as @MattMcNabb said in the <a href=\"https://stackoverflow.com/questions/25967060/is-a-pointer-to-an-array-of-unknow-size-incomplete/25967260?noredirect=1#comment40694455_25967260\">comment</a> earlier these declaration declared variables of the same type. And it's natural and logical, but what the Standard means in there is not clear.  </p>\n", "Tags": "<c++><arrays>", "OwnerDisplayName": "user2953119"}, "bq_ids": {"n4140": {"so_26009080_26009080_1": {"section_id": 7204, "quality": 0.9642857142857143, "length": 27}, "so_26009080_26009080_0": {"section_id": 554, "quality": 0.92, "length": 23}, "so_26009080_26010140_0": {"section_id": 7143, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_26009080_26009080_1": {"section_id": 6948, "quality": 0.9642857142857143, "length": 27}, "so_26009080_26009080_0": {"section_id": 545, "quality": 0.92, "length": 23}, "so_26009080_26010140_0": {"section_id": 6887, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_26009080_26009080_0": {"section_id": 577, "quality": 0.92, "length": 23}, "so_26009080_26009080_1": {"section_id": 8713, "quality": 0.9285714285714286, "length": 26}, "so_26009080_26010140_0": {"section_id": 8644, "quality": 0.9512195121951219, "length": 39}}}});