post_cb({"19962398": {"Id": "19962398", "PostTypeId": "2", "Body": "<p>As per the Standard, if a lambda doesn't capture any variable, then it is implicitly convertible to function pointer.</p>\n<p>Based on that, I came up with <code>is_stateless&lt;&gt;</code> meta-function which tells you whether a lambda is <em>stateless</em> or not.</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T, typename U&gt;\nstruct helper : helper&lt;T, decltype(&amp;U::operator())&gt;\n{};\n\ntemplate &lt;typename T, typename C, typename R, typename... A&gt;\nstruct helper&lt;T, R(C::*)(A...) const&gt; \n{\n    static const bool value = std::is_convertible&lt;T, R(*)(A...)&gt;::value;\n};\n\ntemplate&lt;typename T&gt;\nstruct is_stateless\n{\n    static const bool value = helper&lt;T,T&gt;::value;\n};\n</code></pre>\n<p>And here is the test code:</p>\n<pre><code>int main() \n{\n    int a;\n    auto l1 = [a](){ return 1; };\n    auto l2 = [](){ return 2; };\n    auto l3 = [&amp;a](){ return 2; };\n\n    std::cout&lt;&lt;std::boolalpha&lt;&lt;is_stateless&lt;decltype(l1)&gt;::value&lt;&lt; \"\\n\";\n    std::cout&lt;&lt;std::boolalpha&lt;&lt;is_stateless&lt;decltype(l2)&gt;::value&lt;&lt; \"\\n\";\n    std::cout&lt;&lt;std::boolalpha&lt;&lt;is_stateless&lt;decltype(l3)&gt;::value&lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>false\ntrue\nfalse\n</code></pre>\n<p><a href=\"http://ideone.com/4HptwM\">Online Demo</a>.</p>\n", "LastActivityDate": "2013-11-13T19:14:26.250", "CommentCount": "22", "CreationDate": "2013-11-13T19:14:26.250", "ParentId": "19961873", "Score": "12", "OwnerUserId": "415784"}, "19961873": {"ViewCount": "1550", "Body": "<p>How would I go about testing if a lambda is stateless, that is, if it captures anything or not?\nMy guess would be using overload resolution with a function pointer overload, or template specialization?</p>\n<pre><code>int a;\nauto l1 = [a](){ return 1; };\nauto l2 = [](){ return 2; };\n// test l1 and l2, get a bool for statelessness.\n</code></pre>\n", "AcceptedAnswerId": "19962398", "Title": "Test if a lambda is stateless?", "CreationDate": "2013-11-13T18:44:58.813", "Id": "19961873", "CommentCount": "9", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-08-19T06:22:33.407", "LastEditorUserId": "726300", "LastActivityDate": "2016-01-19T09:45:55.193", "Score": "11", "OwnerUserId": "480212", "Tags": "<c++><c++11><lambda><c++14>", "AnswerCount": "5"}, "19962132": {"Id": "19962132", "PostTypeId": "2", "Body": "<p>Per \u00a7 5.1.2/6</p>\n<blockquote>\n<p id=\"so_19961873_19962132_0\">The closure type for a non-generic lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function with C ++ language linkage (7.5) having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator. For a generic lambda with no lambda-capture, the closure type has a public non-virtual non-explicit const conversion function template to pointer to function.</p>\n</blockquote>\n<p>If it's convertible to a pointer to function, then <strong><em>MAYBE</em></strong> it has to not capture anything (stateless). In action:</p>\n<pre><code>int v = 1;\nauto lambda1 = [ ]()-&gt;void {};\nauto lambda2 = [v]()-&gt;void {};\n\nusing ftype = void(*)();\n\nftype x = lambda1; // OK\nftype y = lambda2; // Error\n</code></pre>\n<p>You can also use <a href=\"http://en.cppreference.com/w/cpp/types/is_convertible\" rel=\"nofollow\"><code>std::is_convertible</code></a>:</p>\n<pre><code>static_assert(is_convertible&lt;decltype(lambda1), ftype&gt;::value, \"no capture\");\nstatic_assert(is_convertible&lt;decltype(lambda2), ftype&gt;::value, \"by capture\");\n</code></pre>\n", "LastEditorUserId": "952747", "LastActivityDate": "2013-11-13T22:29:12.093", "Score": "5", "CreationDate": "2013-11-13T18:58:37.867", "ParentId": "19961873", "CommentCount": "4", "OwnerUserId": "952747", "LastEditDate": "2013-11-13T22:29:12.093"}, "19971779": {"Id": "19971779", "PostTypeId": "2", "Body": "<pre><code>#include &lt;type_traits&gt; // std::true_type, std::false_type\n#include &lt;utility&gt;     // std::declval\n\ntemplate&lt;typename Lambda&gt;\nauto is_captureless_lambda_tester(int)\n-&gt; decltype( +std::declval&lt;Lambda&gt;(), void(), std::true_type {} );\n\ntemplate&lt;typename Lambda&gt;\nauto is_captureless_lambda_tester(long)\n-&gt; std::false_type;\n\ntemplate&lt;typename Lambda&gt;\nusing is_captureless_lambda = decltype( is_captureless_lambda_tester&lt;Lambda&gt;(0) );\n</code></pre>\n<p>Does not work for polymorphic lambdas, require as a precondition that the argument be a closure type. (E.g. <code>is_captureless_lambda&lt;int&gt;</code> is <code>std::true_type</code>.)</p>\n", "LastActivityDate": "2013-11-14T07:18:11.437", "CommentCount": "1", "CreationDate": "2013-11-14T07:18:11.437", "ParentId": "19961873", "Score": "6", "OwnerUserId": "726300"}, "bq_ids": {"n4140": {"so_19961873_19962132_0": {"length": 55, "quality": 0.9482758620689655, "section_id": 5965}}, "n3337": {"so_19961873_19962132_0": {"length": 38, "quality": 0.6551724137931034, "section_id": 5734}}, "n4659": {"so_19961873_19962132_0": {"length": 47, "quality": 0.8103448275862069, "section_id": 7456}}}, "34873353": {"Id": "34873353", "PostTypeId": "2", "Body": "<p>An option could be to explicitly look a the size of the type, a stateless should in principle have the same size as other stateless types (I picked <code>std::true_type</code> for a reference type).</p>\n<pre><code>#include&lt;cassert&gt;\n#include&lt;type_traits&gt;\n\ntemplate&lt;class T&gt;\nstruct is_stateless_lambda : std::integral_constant&lt;bool, sizeof(T) == sizeof(std::true_type)&gt;{};\n\nint main(){\n\n  auto l1 = [a](){ return 1; };\n  auto l2 = [](){ return 2; };\n  auto l3 = [&amp;a](){ return 2; };\n\n  assert( boost::is_stateless_lambda&lt;decltype(l1)&gt;::value == false );\n  assert( boost::is_stateless_lambda&lt;decltype(l2)&gt;::value == true );\n  assert( boost::is_stateless_lambda&lt;decltype(l3)&gt;::value == false );\n}\n</code></pre>\n<p>I don't know how portable this solution is. In any case check my other solution: <a href=\"https://stackoverflow.com/a/34873139/225186\">https://stackoverflow.com/a/34873139/225186</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-19T09:44:26.923", "Score": "0", "CreationDate": "2016-01-19T09:44:26.923", "ParentId": "19961873", "CommentCount": "0", "OwnerUserId": "225186", "LastEditDate": "2017-05-23T12:31:24.053"}, "34873139": {"Id": "34873139", "PostTypeId": "2", "Body": "<p>Boost.TypeTraits <code>is_stateless</code> <em>seems</em> to do the job for whatever reason without much drama:</p>\n<pre><code>#include&lt;boost/type_traits.hpp&gt;\n#include&lt;cassert&gt;\nint main(){\n  auto l1 = [a](){ return 1; };\n  auto l2 = [](){ return 2; };\n  auto l3 = [&amp;a](){ return 2; };\n\n  assert( boost::is_stateless&lt;decltype(l1)&gt;::value == false );\n  assert( boost::is_stateless&lt;decltype(l2)&gt;::value == true );\n  assert( boost::is_stateless&lt;decltype(l3)&gt;::value == false );\n}\n</code></pre>\n<p><code>boost::is_stateless</code> is simple the combination of other conditions, it can be expressed in terms of standard type traits I suppose:</p>\n<pre><code>::boost::is_stateless = \n::boost::has_trivial_constructor&lt;T&gt;::value\n&amp;&amp; ::boost::has_trivial_copy&lt;T&gt;::value\n&amp;&amp; ::boost::has_trivial_destructor&lt;T&gt;::value\n&amp;&amp; ::boost::is_class&lt;T&gt;::value\n&amp;&amp; ::boost::is_empty&lt;T&gt;::value\n</code></pre>\n<p><a href=\"http://www.boost.org/doc/libs/1_60_0/libs/type_traits/doc/html/boost_typetraits/reference/is_stateless.html\" rel=\"nofollow noreferrer\">http://www.boost.org/doc/libs/1_60_0/libs/type_traits/doc/html/boost_typetraits/reference/is_stateless.html</a></p>\n<p>Check my other answer based on <code>sizeof</code>: <a href=\"https://stackoverflow.com/a/34873353/225186\">https://stackoverflow.com/a/34873353/225186</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-19T09:45:55.193", "Score": "0", "CreationDate": "2016-01-19T09:35:36.417", "ParentId": "19961873", "CommentCount": "0", "OwnerUserId": "225186", "LastEditDate": "2017-05-23T12:15:20.657"}});