post_cb({"8854462": {"ParentId": "8854354", "CommentCount": "12", "Body": "<p>The order does not matter for the compiler (the initialization order is always base classes first, and always base classes in the order of derivation, and members in the order of declaration), but it does matter for the reader: It is very confusing if the order in which you give the initializers does not match the order in which they are executed. While in most cases it doesn't matter, in some cases you can create subtle bugs, e.g.</p>\n<pre><code>struct Derived: Base\n{\n  int member;\n  Derived();\n}\n\nDerived::Derived():\n  member(3),\n  Base(member) // This is executed *before* member is initialized!\n{\n}\n</code></pre>\n<p>This bug would stand out more clearly if the initializers were given in the correct order:</p>\n<pre><code>Derived::Derived():\n  Base(member), // Now we see immediately that member is uninitialized\n  member(3),\n{\n}\n</code></pre>\n", "OwnerUserId": "1032073", "PostTypeId": "2", "Id": "8854462", "Score": "4", "CreationDate": "2012-01-13T17:11:08.387", "LastActivityDate": "2012-01-13T17:11:08.387"}, "8854478": {"ParentId": "8854354", "CommentCount": "0", "Body": "<p>It doesn't matter in which order you list the initializers in the constructor initialization list. Members are initialized in the order they are declared and base(s) are initialized before members.</p>\n<p>However, listing initializers in a different order that that can bite you if a subobject's initial value depends on the values of other subobjects.</p>\n<pre><code>class A\n{\n  int y, x;\n  A(int x_value): x(x_value), y(x) {}\n};\n</code></pre>\n<p>Since y is initialized before x, it gets a garbage value, and the order of the initializer list just hides the bug. That's why this deserves a compiler warning.</p>\n", "OwnerUserId": "155693", "PostTypeId": "2", "Id": "8854478", "Score": "4", "CreationDate": "2012-01-13T17:12:15.663", "LastActivityDate": "2012-01-13T17:12:15.663"}, "8854435": {"ParentId": "8854354", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_8854354_8854435_0\">Would example 1 do something different to example 2?</p>\n</blockquote>\n<p><strong>No</strong>. Initialisation order is dictated by the standard, not by the order in which you write the initialisers:</p>\n<blockquote>\n<p id=\"so_8854354_8854435_1\"><code>[C++11: 12.6.2/10]:</code> In a non-delegating constructor, initialization\n  proceeds in the following order:</p>\n<ul>\n<li>First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</li>\n<li><strong>Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers)</strong>.</li>\n<li><strong>Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers)</strong>.</li>\n<li>Finally, the compound-statement of the constructor body is executed.</li>\n</ul>\n</blockquote>\n<p>In fact, if you write them in any other order and one depends on the other, <a href=\"http://codepad.org/n8fJhz6l\">you may well be warned about it</a>:</p>\n<pre><code>struct T {\n   std::vector&lt;int&gt; v;\n   int w;\n\n   T(int w) : w(w), v(0, w) {}\n};\n\nint main() {\n   T t(3);\n}\n\n// g++ 4.1.2:\n// t.cpp: In constructor 'T::T(int)':\n// Line 3: warning: 'T::w' will be initialized after\n// Line 2: warning:   '__gnu_debug_def::vector&lt;int, std::allocator&lt;int&gt; &gt; T::v'\n// Line 5: warning:   when initialized here\n</code></pre>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "8854435", "Score": "7", "CreationDate": "2012-01-13T17:09:26.733", "LastActivityDate": "2012-01-13T17:09:26.733"}, "bq_ids": {"n4140": {"so_8854354_8854435_1": {"section_id": 438, "quality": 0.75, "length": 6}}, "n3337": {"so_8854354_8854435_1": {"section_id": 429, "quality": 0.75, "length": 6}}, "n4659": {"so_8854354_8854435_1": {"section_id": 458, "quality": 0.75, "length": 6}}}, "8854354": {"CommentCount": "7", "ViewCount": "1608", "CreationDate": "2012-01-13T17:03:33.447", "LastActivityDate": "2012-01-13T17:12:15.663", "PostTypeId": "1", "AcceptedAnswerId": "8854435", "FavoriteCount": "1", "Title": "Does the order of base-class initializers and member variable initializers matter?", "Id": "8854354", "Score": "1", "Body": "<p>Is the order of the initializers for a class' constructor significant?</p>\n<p>So say I have:</p>\n<pre><code>class MyClass : BaseClass\n{\n      int a, b, c;\n\n   public:\n      MyClass(int);\n}\n</code></pre>\n<p><strong>e.g. 1:</strong></p>\n<pre><code>MyClass::MyClass(int forBase) :\n  a(7),\n  b(14),\n  c(28),\n  BaseClass(forBase) { }\n</code></pre>\n<p><strong>e.g. 2:</strong></p>\n<pre><code>MyClass::MyClass(int forBase) :\n  BaseClass(forBase),\n  a(7),\n  b(14),\n  c(28) { }\n</code></pre>\n<p>Would example 1 do something different to example 2?</p>\n", "Tags": "<c++><constructor><initialization>", "OwnerUserId": "594137", "AnswerCount": "3"}});