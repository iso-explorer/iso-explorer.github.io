post_cb({"13994552": {"ParentId": "13993798", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The body of a member function is compiled as if it was defined after the class. Therefore everything declared in the class is in scope at that point.</p>\n<p>However, the declaration of the function is still inside the class declaration  and can only see names that precede it.</p>\n<pre><code>template &lt;typename A&gt;\nstruct S {\n    template &lt;typename B&gt;\n    auto f(B b) -&gt;\n        decltype(a.f(b)); // error - a is not visible here\n\n    A a;\n};\n\ntemplate &lt;typename A&gt;\ntemplate &lt;typename B&gt;\n    auto S&lt;A&gt;::f(B b) -&gt;\n        decltype(a.f(b))\n    {\n        return a.f(b);   // a is visible here\n    }\n</code></pre>\n", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2012-12-21T17:31:50.283", "Id": "13994552", "Score": "2", "CreationDate": "2012-12-21T17:26:22.493", "LastActivityDate": "2012-12-21T17:31:50.283"}, "14005063": {"ParentId": "13993798", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>template &lt;typename A&gt;\nstruct S {\n    A a;\n    template &lt;typename B&gt;\n    auto f(B b) -&gt;\n        decltype(a.f(b))\n    {\n    }\n};\n</code></pre>\n<p>This works because within a trailing return type, members of the surrounding class are visible. Not all members, but only the members that are declared prior to it (in a trailing return type, the class is <em>not</em> considered to be complete, as opposed to function bodies). So what is done here:</p>\n<ul>\n<li>As we are in a template, a lookup is done to see whether <code>a</code> is dependent or not. Since <code>a</code> was declared prior to <code>f</code>, <code>a</code> is found to refer to a class member. </li>\n<li><p>By the template rules in C++, it is found that <code>a</code> refers to a member of the current instantiation since it is a member of instantiations of the surrounding template. In C++, this notion is used mainly to decide whether names are dependent: If a name is known to refer to the surrounding template's members, it is not necessarily needed to be looked up when instantiating, because the compiler already knows the code of the template (which is used as the basis of the class type instantiated from it!). Consider:</p>\n<pre><code>template&lt;typename T&gt;\nstruct A {\n  typedef int type;\n  void f() {\n    type x;\n    A&lt;T&gt;::type y;\n  }\n};\n</code></pre></li>\n</ul>\n<p>In C++03, the second line declaring <code>y</code> would be an error, because <code>A&lt;T&gt;::type</code> was a dependent name and needed a <code>typename</code> in front of it. Only the first line was accepted. In C++11, this inconsistency was fixed and both type names are non-dependent and won't need a <code>typename</code>. If you change the typedef to <code>typedef T type;</code> then both declarations, <code>x</code> and <code>y</code> will use a dependent type, but <em>neither</em> will need a <code>typename</code>, because you still name a member of the current instantiation and the compiler knows that you name a type. </p>\n<ul>\n<li>So <code>a</code> is a member of the current instantiation. But it is dependent, because the type used to declare it (<code>A</code>) is dependent. However this doesn't matter in your code. Whether dependent or not, <code>a</code> is found and the code valid. </li>\n</ul>\n<hr>\n<pre><code>template &lt;typename A&gt;\nstruct S {\n    template &lt;typename B&gt;\n    auto f(B b) -&gt;\n        decltype(a.f(b))\n    {\n    }\n    A a;\n};\n</code></pre>\n<p>In this code, again <code>a</code> is looked up to see whether it is dependent and/or whether it is a member of the current instantiation. But since we learned above that members declared after the trailing return type are not visible, we fail to find a declaration for <code>a</code>. In C++, besides the notion \"member of the current instantiation\", there is another notion: </p>\n<ul>\n<li><p><em>member of an unknown specialization</em>. This notion is used to refer to the case where a name might instead refer to a member of a class that depends on template parameters. If we had accessed <code>B::a</code>, then the <code>a</code> would be a member of an unknown specialization because it is <em>unknown</em> what declarations will be visible when <code>B</code> is substituted at instantiation. </p></li>\n<li><p><em>neither a member of the current, nor a member of an unknown specialization.</em> This is the case for all other names. <em>Your case fits here</em>, because it is known that <code>a</code> can never be a member of any instantiation when instantiation happens (remember that name lookup cannot find <code>a</code>, since it is declared after <code>f</code>). </p></li>\n</ul>\n<p>Since <code>a</code> is not made dependent by any rule, the lookup that did not find any declaration is <em>binding</em>, meaning there is no other lookup at instantiation that could find a declaration. Non-dependent names are lookup up at template definition time. Now GCC rightfully gives you an error (but note that as always, an ill-formed template is not required to be diagnosed immediately).</p>\n<hr>\n<pre><code>template &lt;typename A&gt;\nstruct S {\n    template &lt;typename B&gt;\n    auto f(B b) -&gt;\n        decltype(this-&gt;a.f(b))\n    {\n    }\n    A a;\n};\n</code></pre>\n<p>In this case, you added <code>this</code> and GCC accepted. The name <code>a</code> that follows <code>this-&gt;</code> again is lookup at to see whether it might be a member of the current instantiation. But again because of the member visibility in trailing return types, no declaration is found. Hence the name is deemed not to be a member of the current instantiation. Since there is no way that at instantiation, <code>S</code> could have additional members that <code>a</code> could match (there are no base classes of <code>S</code> that depend on template parameters), the name is also not a member of an unknown specialization. </p>\n<p>Again C++ has no rules to make <code>this-&gt;a</code> dependent. However it uses <code>this-&gt;</code>, so the name <em>must</em> refer to some member of <code>S</code> when it is instantiated! So the C++ Standard says</p>\n<blockquote>\n<p id=\"so_13993798_14005063_0\">Similarly, if the id-expression in a class member access expression for which the type of the object expression is the current instantiation does not refer to a member of the current instantiation or a member of an unknown specialization, the program is ill-formed even if the template containing the member access expression is not instantiated; no diagnostic required.</p>\n</blockquote>\n<p>Again no diagnostic is required for this code (and GCC actually doesn't give it). The id-expression <code>a</code> in the member access expression <code>this-&gt;a</code> was dependent in C++03 because the rules in that Standard were not as elaborated and fine-tuned as in C++11. For a moment let's imagine C++03 had <code>decltype</code> and trailing return types. What would this mean?</p>\n<ul>\n<li>The lookup would have been delayed until instantiation, because <code>this-&gt;a</code> would be dependent</li>\n<li>The lookup at instantiation of, say, <code>S&lt;SomeClass&gt;</code> would fail, because <code>this-&gt;a</code> would not be found at instantiation time (as we said, trailing return types do not see members declared later). </li>\n</ul>\n<p>Hence, the early rejection of that code by C++11 is good and useful.</p>\n</hr></hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2013-07-12T18:40:50.310", "Id": "14005063", "Score": "4", "CreationDate": "2012-12-22T17:42:15.487", "LastActivityDate": "2013-07-12T18:40:50.310"}, "13993798": {"CommentCount": "2", "CreationDate": "2012-12-21T16:32:41.373", "PostTypeId": "1", "AcceptedAnswerId": "14005063", "LastEditorUserId": "500104", "LastActivityDate": "2013-07-12T18:40:50.310", "LastEditDate": "2012-12-21T17:08:38.003", "ViewCount": "941", "FavoriteCount": "1", "Title": "Class member visibility in member function declaration signature", "Id": "13993798", "Score": "3", "Body": "<p>Why does this work:</p>\n<pre><code>template &lt;typename A&gt;\nstruct S {\n    A a;\n    template &lt;typename B&gt;\n    auto f(B b) -&gt;\n        decltype(a.f(b))\n    {\n    }\n};\n</code></pre>\n<p>But this does not (<code>a</code> and <code>f</code> swapped places):</p>\n<pre><code>template &lt;typename A&gt;\nstruct S {\n    template &lt;typename B&gt;\n    auto f(B b) -&gt;\n        decltype(a.f(b))\n    {\n    }\n    A a;\n};\n</code></pre>\n<p>saying that <code>a</code> is not declared in that scope (inside decltype) but adding explicit <code>this-&gt;</code> makes it work.</p>\n", "Tags": "<c++><c++11><decltype><trailing-return-type>", "OwnerUserId": "1554020", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13993798_14005063_0": {"section_id": 196, "quality": 1.0, "length": 29}, "so_13993798_13995360_1": {"section_id": 5949, "quality": 0.9777777777777777, "length": 44}, "so_13993798_13995360_2": {"section_id": 3263, "quality": 0.8, "length": 4}, "so_13993798_13995360_0": {"section_id": 197, "quality": 1.0, "length": 26}}, "n3337": {"so_13993798_14005063_0": {"section_id": 190, "quality": 1.0, "length": 29}, "so_13993798_13995360_1": {"section_id": 5719, "quality": 0.9777777777777777, "length": 44}, "so_13993798_13995360_2": {"section_id": 3135, "quality": 0.8, "length": 4}, "so_13993798_13995360_0": {"section_id": 191, "quality": 1.0, "length": 26}}, "n4659": {"so_13993798_13995360_1": {"section_id": 7435, "quality": 1.0, "length": 45}, "so_13993798_14005063_0": {"section_id": 202, "quality": 1.0, "length": 29}, "so_13993798_13995360_0": {"section_id": 203, "quality": 1.0, "length": 26}}}, "13995360": {"ParentId": "13993798", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>The Standard says (section 14.6.2.1):</p>\n<blockquote>\n<p id=\"so_13993798_13995360_0\">If, for a given set of template arguments, a specialization of a template is instantiated that refers to a member of the current instantiation with a qualified-id or class member access expression, the name in the qualified-id or class member access expression is looked up in the template instantiation context.</p>\n</blockquote>\n<p><code>this-&gt;a</code> is a class-member access expression, therefore this rule applies and lookup takes place at the point of instantiation, where <strike><code>S&lt;A&gt;</code> is complete</strike>.</p>\n<hr>\n<p>Finally, this doesn't solve your problem at all, because section 5.1.1 says:</p>\n<blockquote>\n<p id=\"so_13993798_13995360_1\">If a declaration declares a member function or member function template of a class X, <strong>the expression <code>this</code> is a prvalue of type \u201cpointer to <em>cv-qualifier-seq</em> <code>X</code>\u201d between the optional <em>cv-qualifier-seq</em> and the end of the <em>function-definition</em>, <em>member-declarator</em>, or <em>declarator</em></strong>. It shall not appear before the optional <em>cv-qualifier-seq</em>\n  and it shall not appear within the declaration of a static member function (although its type and value category are defined within a static member function as they are within a non-static member function).</p>\n</blockquote>\n<p>So you can't use <code>this-&gt;</code> here, since it is before the <em>cv-qualifier-seq</em> part of the function declaration.</p>\n<p>Wait, no it isn't!  Section 8.4.1 says</p>\n<blockquote>\n<p id=\"so_13993798_13995360_2\">The declarator in a <em>function-definition</em> shall have the form</p>\n<p id=\"so_13993798_13995360_3\"><code>D1  (</code><em><code>parameter-declaration-clause</code></em><code>)</code> <em><code>cv-qualifier-seq opt ref-qualifier opt exception-specification opt attribute-specifier-seq opt trailing-return-type opt</code></em></p>\n</blockquote>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-12-21T19:31:17.537", "Id": "13995360", "Score": "2", "CreationDate": "2012-12-21T18:30:24.430", "LastActivityDate": "2012-12-21T19:31:17.537"}});