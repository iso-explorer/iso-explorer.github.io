post_cb({"38926797": {"PostTypeId": "2", "Body": "<p>The \"rvalue\" in \"rvalue reference\" refers to the kind of value that the reference can <em>bind to</em>:</p>\n<ul>\n<li>lvalue references can bind to lvalues</li>\n<li>rvalue references can bind to rvalues</li>\n<li>(+ a bit more)</li>\n</ul>\n<p>That's all there's to it. Importantly, it does <em>not</em> refer to the value that get when you <em>use</em> the reference. Once you have a reference variable (any kind of reference!), the id-expression naming that variable is always an lvalue. Rvalues occur in the wild only as either temporary values, or as the values of function call expressions, or as the value of a cast expression, or as the result of decay or of <code>this</code>.</p>\n<p>There's a certain analogy here with dereferencing a pointer: dereferencing a pointer is always an lvalue, no matter how that pointer was obtained: <code>*p</code>, <code>*(p + 1)</code>, <code>*f()</code> are all lvalues. It doesn't matter how you came by the thing; once you have it, it's an lvalue.</p>\n<p>Stepping back a bit, maybe the most interesting aspect of all this is that rvalue references are a mechanism to convert an rvalue into an lvalue. No such mechanism had existed prior to C++11 that produced mutable lvalues. While lvalue-to-rvalue conversion has been part of the language since its very beginnings, it took much longer to discover the need for rvalue-to-lvalue conversion.</p>\n", "LastActivityDate": "2016-08-12T21:43:45.057", "LastEditorUserId": "596781", "Id": "38926797", "CommentCount": "0", "CreationDate": "2016-08-12T21:38:36.133", "ParentId": "38926753", "Score": "7", "OwnerUserId": "596781", "LastEditDate": "2016-08-12T21:43:45.057"}, "38926753": {"ViewCount": "1374", "Body": "<p>I was wondering about a c++ behaviour when an r-value is passed among functions.</p>\n<p>Look at this simple code:</p>\n<pre><code>#include &lt;string&gt;\n\nvoid foo(std::string&amp;&amp; str) {\n  // Accept a rvalue of str\n}\n\nvoid bar(std::string&amp;&amp; str) {\n  // foo(str);          // Does not compile. Compiler says cannot bind lvalue into rvalue.\n  foo(std::move(str));  // It feels like a re-casting into a r-value?\n}\n\nint main(int argc, char *argv[]) {\n  bar(std::string(\"c++_rvalue\"));\n  return 0;\n}\n</code></pre>\n<p>I know when I'm inside <code>bar</code> function I need to use <code>move</code> function in order to invoke <code>foo</code> function. My question now is why?</p>\n<p>When I'm inside the <code>bar</code> function the variable <code>str</code> should already be an <em>r-value</em>, but the compiler acts like it is a <em>l-value</em>.</p>\n<p>Can somebody quote some reference to the standard about this behaviour?\nThanks!</p>\n", "AcceptedAnswerId": "38926870", "Title": "r-value parameters in a function", "CreationDate": "2016-08-12T21:33:42.300", "Id": "38926753", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-08-12T23:13:32.707", "LastEditorUserId": "493106", "LastActivityDate": "2016-08-13T01:49:50.340", "Score": "14", "OwnerUserId": "6040181", "Tags": "<c++><c++11><rvalue>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_38926753_38926870_1": {"length": 19, "quality": 0.95, "section_id": 7230}, "so_38926753_38926870_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 7230}}, "n3337": {"so_38926753_38926870_1": {"length": 19, "quality": 0.95, "section_id": 6974}, "so_38926753_38926870_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 6974}}}, "38928447": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38926753_38928447_0\">My question now is why?</p>\n</blockquote>\n<p>I'm adding another answer because I want to emphasize an answer to the \"why\".</p>\n<p>Even though <em>named</em> rvalue references can bind to an rvalue, they are treated as lvalues when used. For example:</p>\n<pre><code>struct A {};\n\nvoid h(const A&amp;);\nvoid h(A&amp;&amp;);\n\nvoid g(const A&amp;);\nvoid g(A&amp;&amp;);\n\nvoid f(A&amp;&amp; a)\n{\n    g(a);  // calls g(const A&amp;)\n    h(a);  // calls h(const A&amp;)\n}\n</code></pre>\n<p>Although an rvalue can bind to the <code>a</code> parameter of <code>f()</code>, once bound, <code>a</code> is now treated as an lvalue. In particular, calls to the overloaded functions <code>g()</code> and <code>h()</code> resolve to the <code>const A&amp;</code> (lvalue) overloads. <strong>Treating <code>a</code> as an rvalue within <code>f</code> would lead to error prone code:</strong> First the \"move version\" of <code>g()</code> would be called, which would likely pilfer <code>a</code>, and then the pilfered <code>a</code> would be sent to the move overload of <code>h()</code>.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#More%20on%20A&amp;&amp;\" rel=\"nofollow\">Reference</a>.</p>\n", "LastActivityDate": "2016-08-13T01:49:50.340", "Id": "38928447", "CommentCount": "0", "CreationDate": "2016-08-13T01:49:50.340", "ParentId": "38926753", "Score": "2", "OwnerUserId": "576911"}, "38926870": {"PostTypeId": "2", "Body": "<p><code>str</code> is a rvalue reference, i.e. <strong>it is a reference only to rvalues</strong>. But it is still a reference, which is a lvalue. You can use <code>str</code> as a variable, which also implies that it is an lvalue, not a temporary rvalue.</p>\n<p>An <em>lvalue</em> is, according to \u00a73.10.1.1:</p>\n<blockquote>\n<p id=\"so_38926753_38926870_0\">An <em>lvalue</em> (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [ <em>Example</em>: <strong>If <em>E</em> is an expression of pointer type, then <em>*E</em> is an lvalue expression referring to the object or function to which <em>E</em> points</strong>. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. \u2014<em>end example</em> ]</p>\n</blockquote>\n<p>And an <em>rvalue</em> is, according to \u00a73.10.1.4:</p>\n<blockquote>\n<p id=\"so_38926753_38926870_1\">An <em>rvalue</em> (so called, historically, because rvalues could appear on the right-hand side of an assignment\n  expression) is an xvalue, <strong>a temporary object</strong> (12.2) or subobject thereof, or <strong>a value that is not associated with an object</strong>.</p>\n</blockquote>\n<p>Based on this, <code>str</code> is not a temporary object, and it <em>is</em> associated with an object (with the object called <code>str</code>), and so it is not an rvalue.</p>\n<p>The example for the lvalue uses a pointer, but it is the same thing for references, and naturally for rvalue references (which are only a special type of references).</p>\n<p>So, in your example, <code>str</code> <em>is</em> an <em>lvalue</em>, so you have to <code>std::move</code> it to call <code>foo</code> (which only accepts rvalues, not lvalues).</p>\n", "LastActivityDate": "2016-08-12T21:43:24.417", "Id": "38926870", "CommentCount": "0", "CreationDate": "2016-08-12T21:43:24.417", "ParentId": "38926753", "Score": "8", "OwnerUserId": "3980929"}});