post_cb({"11091445": {"ParentId": "11091385", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>In this case, I'd say it's undefined behaviour. <code>bc</code> is a <code>const</code> object, so are all its subobjects (less <code>mutable</code>s)<sup>1</sup>, therefore <code>bc.v</code> should be, too and modifying a <code>const</code> object, however achieved, is UB<sup>2</sup>.</p>\n<p>[1] C++03 3.9.3/3:</p>\n<blockquote>\n<p id=\"so_11091385_11091445_0\">Each non-static, non-mutable, non-reference data member of a const-qualified class object is const-\n  qualified...</p>\n</blockquote>\n<p>[2] C++03 7.1.5.1/4:</p>\n<blockquote>\n<p id=\"so_11091385_11091445_1\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const\n  object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p><strong>EDIT</strong> responding to the edit of the question: No, the modified version of the code does not cause undefined behavior. It may be bad practice, but actually may be useful at times. You can eg. use it to implement iterators to your classes via const-iterators (DRY):</p>\n<pre><code>class const_iterator\n{\npublic:\n  const T&amp; dereference() const; // complicated\n};\n\nclass iterator : public const_iterator\n{\npublic:\n  T&amp; dereference() const { return const_cast&lt;T&amp;&gt;(const_iterator::dereference()); }\n};\n</code></pre>\n<p>Of course that relies on the fact that <code>iterator</code>s can only be made from mutable containers, that the const and non-const versions do not differ (no COW and such) etc., but that is fairly common.</p>\n", "OwnerUserId": "51831", "LastEditorUserId": "51831", "LastEditDate": "2012-06-18T22:18:23.280", "Id": "11091445", "Score": "3", "CreationDate": "2012-06-18T21:35:55.127", "LastActivityDate": "2012-06-18T22:18:23.280"}, "11091466": {"ParentId": "11091385", "CommentCount": "4", "Body": "<p>In your particular case it is undefined behavior as the object <strong>is</strong> const, not just the reference. It would be <em>bad practice</em> (and dangerously close to Undefined Behavior) in the following case:</p>\n<pre><code>void f( const BreakConst&amp; b ) {\n   bc.break_stuff();\n}\nint main() {\n   BreakConst b;\n   f( b );\n}\n</code></pre>\n<p>The difference is that in this case the actual object is not const, even if the reference at the level of <code>f</code> is. The dangerously close to Undefined Behavior comes from the fact that the member function casting away const-ness cannot possibly know whether the object on which it has been called is const or not, so you have lost all control.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "11091466", "Score": "3", "CreationDate": "2012-06-18T21:37:18.227", "LastActivityDate": "2012-06-18T21:37:18.227"}, "11091385": {"CommentCount": "13", "AcceptedAnswerId": "11091445", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-06-18T21:30:47.783", "LastActivityDate": "2012-06-18T22:47:40.113", "AnswerCount": "3", "LastEditDate": "2017-05-23T12:29:10.620", "ViewCount": "158", "FavoriteCount": "1", "Title": "Modify const variable in const member bad pratice or UB?", "Id": "11091385", "Score": "3", "Body": "<p>Is the code below bad practice or undefined behavior? Essentially i am calling a const func to modify a member which is not marked as mutable. Link to <a href=\"http://ideone.com/ga5hm\" rel=\"nofollow noreferrer\">demo</a></p>\n<p>Credits to Mehrdad for inspiring this question (his question <a href=\"https://stackoverflow.com/questions/11077566/does-this-code-subvert-the-c-type-system\">Does this code subvert the C++ type system?</a>) and david for minor demo improvements.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct BreakConst\n{\n    int v;\n    int *p;\n    BreakConst() { v = 0; p = &amp;v; } \n    void break_stuff() const { ++*p; }\n};\nvoid f(const BreakConst&amp; bc) {\n    bc.break_stuff();\n}\n</code></pre>\n<h3>Original Version that most answers are based on:</h3>\n<p>Answered by David Rodr\u00edguez, jpalecek, Mehrdad<br>\nYes: This is \"Undefined behavior\"</br></p>\n<pre><code>int main()\n{\n    const BreakConst bc;\n    cout &lt;&lt; bc.v &lt;&lt; endl;   // 0\n    bc.break_stuff();       // O:)\n    cout &lt;&lt; bc.v &lt;&lt; endl;   // 1\n\n    return 0;\n}\n</code></pre>\n<h3>New Alternative Question:</h3>\n<p>Answered by Mehrdad<br>\nNo: This is not \"Undefined behavior\"</br></p>\n<pre><code>int main()\n{\n    BreakConst bc;\n    cout &lt;&lt; bc.v &lt;&lt; endl;   // 0\n    f(bc);                  // O:)\n    cout &lt;&lt; bc.v &lt;&lt; endl;   // 1\n\n    return 0;\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>0\n1\n</code></pre>\n", "Tags": "<c++>", "OwnerDisplayName": "user34537"}, "11091552": {"ParentId": "11091385", "PostTypeId": "2", "CommentCount": "3", "Body": "<h3><em>After</em> your edit:</h3>\n<p><strong>No</strong>, it's not undefined. You're allowed to modify a mutable object through a const reference; it's completely allowed and legal.</p>\n<hr>\n<h3><em>Before</em> your edit:</h3>\n<p>Yes, it must be undefined, because the standard (I'm looking at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf#page=164\" rel=\"nofollow\">draft here</a>) clearly says:</p>\n<blockquote>\n<h3>\u00a77.1.6.1.4</h3>\n<p id=\"so_11091385_11091552_0\">Except that any class member declared <code>mutable</code> (\u00a777.1.1) can be modified, any attempt to modify a <code>const</code> object during its lifetime (\u00a73.8) results in undefined behavior.</p>\n</blockquote>\n<p>So yes -- since the member isn't mutable, modifying it is obviously undefined behavior.</p>\n<p>I don't know <em>why</em> the rule is that way, whether this is intentional, whether it is indeed a loophole, whether it's also violating another rule, how you're supposed to tell just by looking at it, etc... but regarding the question of whether it's UB: yes, it's undefined according to the standard.</p>\n</hr>", "OwnerUserId": "541686", "LastEditorUserId": "541686", "LastEditDate": "2012-06-18T22:29:34.980", "Id": "11091552", "Score": "2", "CreationDate": "2012-06-18T21:45:43.283", "LastActivityDate": "2012-06-18T22:29:34.980"}, "bq_ids": {"n4140": {"so_11091385_11091552_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}, "so_11091385_11091445_1": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}, "so_11091385_11091445_0": {"section_id": 4706, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_11091385_11091552_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}, "so_11091385_11091445_1": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}, "so_11091385_11091445_0": {"section_id": 6971, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_11091385_11091445_0": {"section_id": 6103, "quality": 0.5454545454545454, "length": 6}, "so_11091385_11091445_1": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}, "so_11091385_11091552_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}});