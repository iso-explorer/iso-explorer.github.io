post_cb({"854537": {"ParentId": "851584", "CommentCount": "1", "Body": "<p>This is a known <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57\" rel=\"nofollow noreferrer\">bug</a> in gcc.\nIt has been fixed in gcc-4.4, which compiles the original source just fine.</p>\n", "OwnerUserId": "50617", "PostTypeId": "2", "Id": "854537", "Score": "4", "CreationDate": "2009-05-12T19:50:20.117", "LastActivityDate": "2009-05-12T19:50:20.117"}, "1282096": {"ParentId": "851584", "CommentCount": "0", "Body": "<pre><code>template &lt;bool&gt; class A {};\ntypedef A&lt;static_cast&lt;bool&gt;(1&gt;0)&gt; B;//buggy\nint main() { B b; }\n</code></pre>\n", "Id": "1282096", "PostTypeId": "2", "OwnerDisplayName": "none", "Score": "-2", "CreationDate": "2009-08-15T15:08:29.097", "LastActivityDate": "2009-08-15T15:08:29.097"}, "851760": {"ParentId": "851584", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>I am not so sure that this is a bug in g++ (since version 4.2.4).  The code now passes in g++ 4.4 (see UPDATE below).  In order to have this code compile for other versions of compilers you can add a set of parenthesis around the default argument:</p>\n<pre><code>template&lt;typename A, typename B&gt;\nclass Foo { };\n\nstruct Bar {\n  void method ( Foo&lt;int,int&gt; const&amp; stuff = ( Foo&lt;int,int&gt;() ) );\n};\n</code></pre>\n<p>IMO, these parenthesis are necessary as there is an additional requirement that the default argument can refer to a member of the class that may be declared later in the class body:</p>\n<pre><code>struct Bar {\n  void method ( int i = j);  // 'j' not declared yet\n  static const int j = 0;\n};\n</code></pre>\n<p>The above code is legal, and when the declaration for 'method' is being parsed the member 'j' has not yet been seen.  The compiler therefore can only parse the default argument using <em>syntax</em> checking only, (ie. matching parenthesis and commas).  When g++ is parsing your original declaration, what it is actually seeing is the following:</p>\n<pre><code>void method ( Foo&lt;int,int&gt; const&amp; stuff = Foo&lt;int // Arg 1 with dflt.\n              , int&gt;() );                         // Arg 2 - syntax error\n</code></pre>\n<p>Adding the extra set of parenthesis ensures that the default argument is handled correctly.  </p>\n<p>The following case shows an example where g++ succeeds but Comeau still generates a syntax error:</p>\n<pre><code>template&lt;int J, int K&gt;\nclass Foo { };\n\nstruct Bar {\n  void method ( Foo&lt;0, 0&gt; const &amp; i = ( Foo&lt;j, k&gt; () ) );\n  static const int j = 0;\n  static const int k = 0;\n};\n</code></pre>\n<p><strong>EDIT:</strong></p>\n<p>In response to the comment: \"You could just as well have a function call with multiple arguments there\", the reason that this does not cause a problem is that the comma's inside the function call are surrounded in parenthesis:</p>\n<pre><code>int foo (int, int, int);\nstruct Bar {\n  void method ( int j =\n                    foo (0, 0, 0) ); // Comma's here are inside ( )\n};\n</code></pre>\n<p>It is possible therefore, to parse this using the <em>syntax</em> of the expression only.  In C++, all '(' must be matched with ')' and so this is easy to parse.  The reason for the problem here is that '&lt;' does not need to be matched, since it is overloaded in C++ and so can be the less than operator or the start of a template argument list.  The following example shows where '&lt;' is used in the default argument and implies the less than operator:</p>\n<pre><code>template&lt;int I, int J&gt;\nclass Foo { };\n\nstruct Bar {\n  template &lt;typename T&gt; struct Y { };\n\n  void method ( ::Foo&lt;0,0&gt; const&amp; stuff = Foo&lt;10 , Y &lt; int &gt;  = Y&lt;int&gt;() );\n\n  struct X {\n    ::Foo&lt;0, 0&gt; operator&lt; (int);\n  };\n\n  static X Foo;\n};\n</code></pre>\n<p>The above \"Foo&lt;10\" is a call to the \"operator&lt;\" defined in 'X', not the start of the template argument list.  Again, Comeau generates syntax errors on the above code and g++ (including 3.2.3) parse this correctly.</p>\n<p>FYI, the appropriate references are a note in 8.3.6/5:</p>\n<blockquote>\n<p id=\"so_851584_851760_0\">[Note: in member function declarations, names in default argument expressions are looked\n  up as described in 3.4.1...</p>\n</blockquote>\n<p>and then in 3.4.1/8</p>\n<blockquote>\n<p id=\"so_851584_851760_1\">A name used in the definition of a member function (9.3) of class X following the function\u2019s declaratorid29)\n  shall be declared in one of the following ways:</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_851584_851760_2\">\u2014 shall be a member of class X or be a member of a base class of X (10.2), or</p>\n</blockquote>\n<p>This bullet here, is the part that forces the compiler to \"delay\" lookup for the meaning of the default argument until all of the class members have been declared.</p>\n<p><strong>&lt;UPDATE&gt;</strong> </p>\n<p>As pointed out by \"Employed Russian\", g++ 4.4 is now able to parse all of these examples.  However, until the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#325\" rel=\"nofollow noreferrer\">DR</a> has been addressed by the C++ standards committee I am not yet ready to call this a \"bug\".  I believe that long term extra parenthesis will be required to ensure portability to other compilers/tools (and maybe even future versions of g++).</p>\n<p>It has been my experience that the C++ standard does not dictate that compiler vendors should all use the same parser technology and they also cannot expect that all technologies are equally powerful.  As a result, parsing requirements normally don't require that vendors perform superhuman feats.  To illustrate this consider the following two examples:</p>\n<pre><code>typedef T::TYPE TYPE;\nT::TYPE t;\n</code></pre>\n<p>If 'T' is dependent, then given each context 'TYPE' <strong>must</strong> be a typename, however the standard still requires the <em>typename</em> keyword.  These examples are unambiguous and can only mean one thing, however the standard (in order to allow for all parser technologies) still requires the <em>typename</em> keyword.  </p>\n<p>It's possible that the DR may be addressed in such a way that a compiler which fails to parse these examples will still be \"standard conforming\" as long as extra parenthesis allows the code to parse.</p>\n<p><strong>&lt;/UPDATE&gt;</strong> </p>\n", "OwnerUserId": "11698", "LastEditorUserId": "256138", "LastEditDate": "2014-05-22T08:05:05.573", "Id": "851760", "Score": "12", "CreationDate": "2009-05-12T08:38:08.670", "LastActivityDate": "2014-05-22T08:05:05.573"}, "851645": {"ParentId": "851584", "CommentCount": "2", "Body": "<p>Looks like a compiler bug.  I tried it on IBM's xlC compiler V7.0 (which I've found to be more standard-conforming than gcc) and it compiles okay.</p>\n", "OwnerUserId": "82570", "PostTypeId": "2", "Id": "851645", "Score": "2", "CreationDate": "2009-05-12T07:55:37.210", "LastActivityDate": "2009-05-12T07:55:37.210"}, "bq_ids": {"n4140": {"so_851584_851760_0": {"section_id": 3256, "quality": 0.6363636363636364, "length": 7}, "so_851584_851760_2": {"section_id": 187, "quality": 0.8333333333333334, "length": 5}, "so_851584_851760_1": {"section_id": 7093, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_851584_851760_0": {"section_id": 3128, "quality": 0.6363636363636364, "length": 7}, "so_851584_851760_2": {"section_id": 181, "quality": 0.8333333333333334, "length": 5}, "so_851584_851760_1": {"section_id": 6838, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_851584_851760_0": {"section_id": 4014, "quality": 0.6363636363636364, "length": 7}, "so_851584_851760_2": {"section_id": 192, "quality": 0.8333333333333334, "length": 5}, "so_851584_851760_1": {"section_id": 8594, "quality": 0.8333333333333334, "length": 10}}}, "851584": {"CommentCount": "1", "ViewCount": "7254", "PostTypeId": "1", "LastEditorUserId": "19863", "CreationDate": "2009-05-12T07:34:07.870", "LastActivityDate": "2014-05-22T08:05:05.573", "Title": "default template class argument confuses g++?", "AcceptedAnswerId": "851760", "LastEditDate": "2009-05-12T07:52:49.040", "Id": "851584", "Score": "9", "Body": "<p>Yesterday I ran into a g++ (3.4.6) compiler problem for code that I have been compiling without a problem using the Intel (9.0) compiler. Here's a code snippet that shows what happened:</p>\n<pre><code>template&lt;typename A, typename B&gt;\nclass Foo { };\n\nstruct Bar {\n   void method ( Foo&lt;int,int&gt; const&amp; stuff = Foo&lt;int,int&gt;() );\n};\n</code></pre>\n<p>The g++ compiler error is:</p>\n<pre><code>foo.cpp:5: error: expected `,' or `...' before '&gt;' token\nfoo.cpp:5: error: wrong number of template arguments (1, should be 2)\nfoo.cpp:2: error: provided for `template&lt;class A, class B&gt; struct Foo'\nfoo.cpp:5: error: default argument missing for parameter 2 of `void Bar::method(const Foo&lt;int, int&gt;&amp;, int)'\n</code></pre>\n<p>Apparently, the default argument is not accepted when written this way, and the compiler assumes that instead of the second template argument a new function argument is specified, for which it then expects a default value because the <code>stuff</code> argument has one. I can help the compiler by creating a typedef, and then everything compiles fine: </p>\n<pre><code>template&lt;typename A, typename B&gt;\nclass Foo { };\n\nstruct Bar {\n   typedef Foo&lt;int,int&gt; FooType;\n   void method ( FooType const&amp; stuff = FooType() );\n};\n</code></pre>\n<p>So I can solve my problem, but I don't understand what is going on. Do I miss a C++ (template?) language feature here and am I doing something wrong, or is the g++ compiler wrong in not accepting the first piece of code? </p>\n<p>Note BTW that this also compiles ...</p>\n<pre><code>template&lt;typename A, typename B&gt;\nclass Foo { };\n\nvoid method ( Foo&lt;int,int&gt; const&amp; stuff = Foo&lt;int,int&gt;() );\n</code></pre>\n", "Tags": "<c++><templates><gcc><g++><intel>", "OwnerUserId": "19863", "AnswerCount": "4"}});