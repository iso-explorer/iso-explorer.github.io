post_cb({"2669681": {"ViewCount": "1016", "Body": "<p>I have a question, here are two classes below:</p>\n<pre><code>  class Base{\n      public:\n          virtual void toString();       // generic implementation\n  }\n\n  class Derive : public Base{\n      public:\n          ( virtual ) void toString();   // specific implementation\n  }\n</code></pre>\n<p>The question is:</p>\n<ul>\n<li><p>If I wanna subclass of class <strong>Derive</strong> perform polymophism using a pointer of type <strong>Base</strong>, is keyword virtual in the bracket necessary? </p></li>\n<li><p>If the answer is no, what's the difference between member function <strong>toString</strong> of class <strong>Derive</strong> with and without virtual?</p></li>\n</ul>\n", "AcceptedAnswerId": "2670232", "Title": "Behavior of virtual function in C++", "CreationDate": "2010-04-19T17:58:56.223", "Id": "2669681", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-04-20T00:43:25.537", "LastEditorUserId": "258355", "LastActivityDate": "2010-04-20T00:43:25.537", "Score": "10", "OwnerUserId": "258355", "Tags": "<c++><virtual-functions>", "AnswerCount": "7"}, "2669713": {"Id": "2669713", "PostTypeId": "2", "Body": "<p>The compiler already knows from the 'virtual' keyword in the base class that toString is a virtual method.  No need to repeat it.</p>\n", "LastActivityDate": "2010-04-19T18:03:26.827", "CommentCount": "1", "CreationDate": "2010-04-19T18:03:26.827", "ParentId": "2669681", "Score": "1", "OwnerUserId": "163551"}, "2671807": {"Id": "2671807", "PostTypeId": "2", "Body": "<p>It's a matter of good style, and the user-programmer knows what's going on. In C++0x you can use [[override]] to make it more explicit and visible. You can use [[base_check]] to force the usage of [[override]].</p>\n<p>If you don't want or can't do that, simply use the virtual keyword.</p>\n<p>If you derive without virtual toString, and you cast an instance of Derive back to Base, calling toString() would actually call Base's toString(), since as far as it know's that's an instance of Base.</p>\n", "LastActivityDate": "2010-04-20T00:34:35.543", "CommentCount": "0", "CreationDate": "2010-04-20T00:34:35.543", "ParentId": "2669681", "Score": "0", "OwnerUserId": "190140"}, "2669692": {"Id": "2669692", "PostTypeId": "2", "Body": "<p>That keyword there is strictly optional and makes no difference at all.</p>\n", "LastActivityDate": "2010-04-19T18:00:45.393", "CommentCount": "1", "CreationDate": "2010-04-19T18:00:45.393", "ParentId": "2669681", "Score": "10", "OwnerUserId": "155693"}, "bq_ids": {"n4140": {"so_2669681_2670232_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 7003}}, "n3337": {"so_2669681_2670232_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 6749}}, "n4659": {"so_2669681_2670232_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 8500}}}, "2669773": {"Id": "2669773", "PostTypeId": "2", "Body": "<p><strong><em>A function once a virtual always a virtual</em></strong>.</p>\n<p>So in any event if the virtual keyword is not used in the subsequent classes, it does not prevent the function/method from being 'virtual' i.e. be overridden. So the following guideline might help from a team development point-of-view :-</p>\n<ul>\n<li>If the function/method is supposed to\nbe overridden, always use the\n'virtual' keyword. This is especially\ntrue when used in interface / base\nclasses.</li>\n<li>If the derived class is supposed to\nbe sub-classed further explicity\nstate the 'virtual' keyword for every\nfunction/method that can be\noverridden.</li>\n<li>If the function/method in the derived\nclass is not supposed to be\nsub-classed again, then the keyword\n'virtual' is to be commented\nindicating that the function/method\nwas overridden but there are no\nfurther classes that override it\nagain. This ofcourse does not prevent\nsomeone from overriding in the\nderived class unless the class\nis made final (non-derivable), but it\nindicates that the method is not supposed to be\noverridden.\nEx: <code>/*virtual*/ void someFunc();</code></li>\n</ul>\n", "LastEditorUserId": "79298", "LastActivityDate": "2010-04-19T21:44:13.760", "Score": "1", "CreationDate": "2010-04-19T18:13:01.710", "ParentId": "2669681", "CommentCount": "6", "OwnerUserId": "79298", "LastEditDate": "2010-04-19T21:44:13.760"}, "2669710": {"Id": "2669710", "PostTypeId": "2", "Body": "<p>The <code>virtual</code> property is inherited from the base class and is assumed to be present even if you don't type it out.</p>\n", "LastActivityDate": "2010-04-19T18:02:55.630", "CommentCount": "0", "CreationDate": "2010-04-19T18:02:55.630", "ParentId": "2669681", "Score": "7", "OwnerUserId": "143642"}, "2670232": {"Id": "2670232", "PostTypeId": "2", "Body": "<p>C++03 \u00a710.3/2:</p>\n<blockquote>\n<p id=\"so_2669681_2670232_0\">If a virtual member function vf is\n  declared in a class Base and in a\n  class Derived, derived directly or\n  indirectly from Base, a member\n  function vf with the same name and\n  same parameter list as Base::vf is\n  declared, then <strong>Derived::vf is also\n  virtual (whether or not it is so\n  declared)</strong> and it overrides\n  Base::vf.</p>\n</blockquote>\n", "LastActivityDate": "2010-04-19T19:33:41.697", "CommentCount": "1", "CreationDate": "2010-04-19T19:33:41.697", "ParentId": "2669681", "Score": "13", "OwnerUserId": "153285"}, "2670753": {"Id": "2670753", "PostTypeId": "2", "Body": "<p>It doesn't matter to the <em>compiler</em> whether or not you supply the <strong>virtual</strong> keyword on derived versions of the function. </p>\n<p>However, it's a good idea to supply it anyway, so that anyone looking at your code will be able to tell it's a virtual function. </p>\n", "LastActivityDate": "2010-04-19T20:46:59.130", "CommentCount": "0", "CreationDate": "2010-04-19T20:46:59.130", "ParentId": "2669681", "Score": "0", "OwnerUserId": "390876"}});