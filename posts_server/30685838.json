post_cb({"30685881": {"ParentId": "30685838", "CommentCount": "0", "Body": "<p>Yes, it is defined as <code>-1</code></p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">N4296</a> \u00a7 21.4 / 5 provides the class template for <code>std::basic_string</code> which includes the line</p>\n<pre><code>static const size_type npos = -1;\n</code></pre>\n", "OwnerUserId": "1013719", "PostTypeId": "2", "Id": "30685881", "Score": "2", "CreationDate": "2015-06-06T17:52:06.673", "LastActivityDate": "2015-06-06T17:52:06.673"}, "30685838": {"CommentCount": "0", "ViewCount": "650", "PostTypeId": "1", "LastEditorUserId": "2898458", "CreationDate": "2015-06-06T17:46:35.313", "LastActivityDate": "2015-06-06T18:15:53.003", "Title": "Is std::string::npos == -1 always true?", "AcceptedAnswerId": "30686035", "LastEditDate": "2015-06-06T17:48:48.443", "Id": "30685838", "Score": "7", "Body": "<p>The title is relatively self explanatory.  I recognize the similarity to other answers, but all of those have different arrangements of operators (and therefore different casting rules).  So I require an answer that clarifies this particular case.</p>\n<p>If someone could point out the section of the standard that explains this, I will gladly vote up and accept the answer.</p>\n", "Tags": "<c++><casting><language-lawyer>", "OwnerUserId": "2898458", "AnswerCount": "3"}, "30685969": {"ParentId": "30685838", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There is a loophole for the question you literally asked.</p>\n<p>If <code>int</code> has (strictly) greater integer conversion rank than <code>string::size_type</code> and <code>int</code> can store the full range of values of <code>string::size_type</code>, then <code>string::npos == -1</code> will be false, as both arguments will get promoted to <code>int</code>, rather than being promoted to <code>string::size_type</code>.</p>\n<p>An environment where this happens would be rather unusual.</p>\n<p>This comes from the <em>usual arithmetic conversions</em>:</p>\n<blockquote>\n<p id=\"so_30685838_30685969_0\">...</p>\n<p id=\"so_30685838_30685969_1\">Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the\n  rank of the type of the other operand, the operand with signed integer type shall be converted to\n  the type of the operand with unsigned integer type</p>\n<p id=\"so_30685838_30685969_2\">Otherwise, if the type of the operand with signed integer type can represent all of the values of\n  the type of the operand with unsigned integer type, the operand with unsigned integer type shall\n  be converted to the type of the operand with signed integer type.</p>\n<p id=\"so_30685838_30685969_3\">Otherwise, both operands shall be converted to the unsigned integer type corresponding to the\n  type of the operand with signed integer type.</p>\n</blockquote>\n", "OwnerUserId": "1084944", "LastEditorUserId": "1084944", "LastEditDate": "2015-06-06T18:08:05.657", "Id": "30685969", "Score": "5", "CreationDate": "2015-06-06T18:02:06.637", "LastActivityDate": "2015-06-06T18:08:05.657"}, "bq_ids": {"n4140": {"so_30685838_30685969_1": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_30685838_30686035_0": {"section_id": 1557, "quality": 0.92, "length": 23}, "so_30685838_30685969_2": {"section_id": 5943, "quality": 1.0, "length": 25}, "so_30685838_30685969_3": {"section_id": 5943, "quality": 1.0, "length": 13}}, "n3337": {"so_30685838_30685969_1": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_30685838_30686035_0": {"section_id": 1551, "quality": 0.92, "length": 23}, "so_30685838_30685969_2": {"section_id": 5714, "quality": 1.0, "length": 25}, "so_30685838_30685969_3": {"section_id": 5714, "quality": 1.0, "length": 13}}, "n4659": {"so_30685838_30685969_1": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_30685838_30686035_0": {"section_id": 1707, "quality": 0.88, "length": 22}, "so_30685838_30685969_3": {"section_id": 7428, "quality": 1.0, "length": 13}, "so_30685838_30685969_2": {"section_id": 7428, "quality": 1.0, "length": 25}}}, "30686035": {"ParentId": "30685838", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><em>NO</em>, it is not always true. It is however a bit more complicated than it seems at first glance:</p>\n<p>In the beginning, let us see what <code>std::string</code> is (21.3/1):</p>\n<blockquote>\n<p id=\"so_30685838_30686035_0\">The header <code>&lt;string&gt;</code> defines the <code>basic_string</code> class template for manipulating varying-length sequences\n  of char-like objects and four typedefs, <code>string</code>, <code>u16string</code>, <code>u32string</code>, and <code>wstring</code>, that name the specializations\n  <code>basic_string&lt;char&gt;</code>, <code>basic_string&lt;char16_t&gt;</code>, <code>basic_string&lt;char32_t&gt;</code>, and <code>basic_string&lt;wchar_t&gt;</code>, respectively.</p>\n</blockquote>\n<p>Start out with 21.4/5:</p>\n<blockquote id=\"so_30685838_30686035_1\">\n<pre><code>template&lt;class charT, class traits = char_traits&lt;charT&gt;,\n    class Allocator = allocator&lt;charT&gt; &gt;\nclass basic_string {\n    typedef typename allocator_traits&lt;Allocator&gt;::size_type size_type;\n    static const size_type npos = -1;\n// [other members omitted]\n};\n</code></pre>\n</blockquote>\n<p>Note that while <code>npos</code> is initialized with <code>-1</code>, its type depends on <code>Allocator::size_type</code>, which means that without further knowledge, we cannot simply assume that <code>string::npos == -1</code> will even compile.</p>\n<p>Now, as <code>string</code> uses the default allocator (the template parameter has the default value in the typedef provided by the standard library after all), let us check 20.6.9:</p>\n<blockquote id=\"so_30685838_30686035_2\">\n<pre><code>typedef size_t size_type;\n</code></pre>\n</blockquote>\n<p>Now, we can essentially rewrite the question as: <code>size_t(-1) == -1</code>. What happens now depends on the types of the subexpressions: The left hand side obviously has type <code>size_t</code>, while the right hand side is an integer literal, which has type <code>int</code>, when written like this (without further qualifiers).</p>\n<p>The result is <code>true</code> if <code>size_t</code> is at least as large as <code>int</code> (for standards fanatics: Has a larger integer conversion rank as defined in 4.13). Otherwise, the <em>left hand side</em> will get promoted to <code>int</code>, causing a comparision like <code>0xFFFF == -1</code> (for <code>size_t</code> being <code>uint16_t</code> and <code>int</code> having 32 bit), which is <code>false</code>.</p>\n<p>Note that while 16 bit systems themselves are not very common anymore (except for some remnants in very small form factors), <code>int</code> is not restricted to 32 bit by the standard. A compiler targetting x86_64 with <code>64</code> bit <code>size_t</code> and 128 bit <code>int</code> would be technically compliant.</p>\n<p>All quotes are from the C++11 standard (ISO/IEC 14882:2011).</p>\n", "OwnerUserId": "65678", "LastEditorUserId": "65678", "LastEditDate": "2015-06-06T18:15:53.003", "Id": "30686035", "Score": "7", "CreationDate": "2015-06-06T18:09:54.290", "LastActivityDate": "2015-06-06T18:15:53.003"}});