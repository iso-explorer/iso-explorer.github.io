post_cb({"24292233": {"ParentId": "24289069", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>If your goal is to have a one-liner with no external machinery, you can use a lambda that accepts <code>std::initializer_list</code>:</p>\n<pre><code>template &lt;typename Functor, typename... Arguments&gt;\nvoid IterateThrough3(Functor functor, Arguments&amp;&amp;... arguments)\n{\n    [](std::initializer_list&lt;int&gt;){}(\n        {((void)functor(std::forward&lt;Arguments&gt;(arguments)), 0)...}\n    );\n}\n</code></pre>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-06-18T18:28:39.767", "Id": "24292233", "Score": "1", "CreationDate": "2014-06-18T18:03:17.610", "LastActivityDate": "2014-06-18T18:28:39.767"}, "bq_ids": {"n4140": {"so_24289069_24289162_1": {"section_id": 5991, "quality": 0.7272727272727273, "length": 16}, "so_24289069_24289162_0": {"section_id": 3326, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_24289069_24289162_1": {"section_id": 5759, "quality": 0.7272727272727273, "length": 16}, "so_24289069_24289162_0": {"section_id": 3196, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_24289069_24289162_0": {"section_id": 4092, "quality": 0.9230769230769231, "length": 12}}}, "24289069": {"CommentCount": "9", "AcceptedAnswerId": "24289162", "PostTypeId": "1", "LastEditorUserId": "3043539", "CreationDate": "2014-06-18T15:09:03.773", "LastActivityDate": "2014-06-18T18:28:39.767", "LastEditDate": "2014-06-18T18:11:02.117", "ViewCount": "1147", "FavoriteCount": "1", "Title": "Iterating through parameters of a variadic function template using variadic lambda", "Id": "24289069", "Score": "7", "Body": "<p>Suppose we have the following function template:</p>\n<pre><code>template &lt;typename Functor, typename... Arguments&gt;\nvoid IterateThrough(Functor functor, Arguments&amp;&amp;... arguments)\n{\n    // apply functor to all arguments\n}\n</code></pre>\n<p>This function is usually implemented as follows:</p>\n<pre><code>template &lt;typename Functor, typename... Arguments&gt;\nvoid IterateThrough1(Functor functor, Arguments&amp;&amp;... arguments)\n{\n    int iterate[]{0, (functor(std::forward&lt;Arguments&gt;(arguments)), void(), 0)...};\n    static_cast&lt;void&gt;(iterate);\n}\n</code></pre>\n<p>Another way:</p>\n<pre><code>struct Iterate\n{\n    template &lt;typename... Arguments&gt;\n    Iterate(Arguments&amp;&amp;... arguments)\n    {\n    }\n};\n\ntemplate &lt;typename Functor, typename... Arguments&gt;\nvoid IterateThrough2(Functor functor, Arguments&amp;&amp;... arguments)\n{\n    Iterate{(functor(std::forward&lt;Arguments&gt;(arguments)), void(), 0)...};\n}\n</code></pre>\n<p>I have found yet another approach which uses a variadic lambda:</p>\n<pre><code>template &lt;typename Functor, typename... Arguments&gt;\nvoid IterateThrough3(Functor functor, Arguments&amp;&amp;... arguments)\n{\n    [](...){}((functor(std::forward&lt;Arguments&gt;(arguments)), void(), 0)...);\n}\n</code></pre>\n<p>What pros and cons has this method in comparison with first two?</p>\n", "Tags": "<c++><templates><c++11><lambda><variadic-functions>", "OwnerUserId": "3043539", "AnswerCount": "3"}, "24289242": {"ParentId": "24289069", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>When you use the variadic lambda, the order of evaluation of arguments is unspecified as per the language specification (which in turn means the evaluation of <code>functor(argument)</code> could be in <em>any</em> order unknown to the programmer). That is the only difference. You can search \"order of evaluation of arguments\" on this site, you will see many topics on it.</p>\n<p>As for the variadic templated constructor approach, that should work as long as you use list-initialization to invoke it, otherwise it would have the same problem as the lambda. Note that GCC (upto 4.8.2) has bug, so this doesn't work, though I don't have any idea whether it is fixed with the recent version of GCC.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2014-06-18T15:28:43.513", "Id": "24289242", "Score": "2", "CreationDate": "2014-06-18T15:15:48.110", "LastActivityDate": "2014-06-18T15:28:43.513"}, "24289162": {"ParentId": "24289069", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The calls to <code>functor</code> are now unsequenced. The compiler can call <code>functor</code> with your expanded arguments in any order it wants. As an example, <code>IterateThrough3(functor, 1, 2)</code> could do <code>functor(1); functor(2);</code> or it could do <code>functor(2); functor(1);</code>, whereas the other two always do <code>functor(1); functor(2);</code>.</p>\n<p>Section 8.5.4/4 of the standard requires that any expressions inside a <code>{}</code> initialiser are evaluated left-to-right.</p>\n<blockquote>\n<p id=\"so_24289069_24289162_0\">Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack\n  expansions (14.5.3), are evaluated in the order in which they appear.</p>\n</blockquote>\n<p>Section 5.2.2/4 states that arguments to a function call can be evaluated in any order.</p>\n<blockquote>\n<p id=\"so_24289069_24289162_1\">When a function is called, each parameter (8.3.5) shall be initialized (8.5, 12.8, 12.1) with its corresponding\n  argument. [Note: Such initializations are indeterminately sequenced with respect to each other (1.9) \u2014\n  end note ]</p>\n</blockquote>\n<p>This might not cover the wording of the order of evaluation (which I can't find ATM), but it is well known that arguments to functions are evaluated in an unspecified order. EDIT: see @dyp's comment for a relevant standard quote.</p>\n", "OwnerUserId": "2491746", "LastEditorUserId": "2491746", "LastEditDate": "2014-06-18T15:20:51.903", "Id": "24289162", "Score": "4", "CreationDate": "2014-06-18T15:12:29.537", "LastActivityDate": "2014-06-18T15:20:51.903"}});