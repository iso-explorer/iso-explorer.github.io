post_cb({"20919283": {"ParentId": "20918981", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>If you dynamically allocate an array type, you get a pointer to its first element.</p>\n<blockquote>\n<p id=\"so_20918981_20919283_0\"><em>\u00a75.3.4 [expr.new]</em> Entities created by a new-expression have dynamic storage duration. If the entity is a non-\n  array object, [...]. If it is an array, the new-expression returns a pointer to the initial element of the array.</p>\n</blockquote>\n<p>So since you're allocating an array type object, you get an <code>int*</code> out of it:</p>\n<pre><code>int *p = new Array;\n</code></pre>\n<p>This is no different to not using the typedef:</p>\n<pre><code>int *p = new int[2];\n</code></pre>\n<p>This also doesn't match your <code>T *p = new T;</code> rule. That is, you definitely can't do this:</p>\n<pre><code>int (*p)[2] = new int[2];\n</code></pre>\n<hr>\n<p>I realise this confusion may have been caused by thinking of <code>new ...[]</code> as a special type of expression different to <code>new ...</code>, where <code>new Array</code> fits into the latter case. We often suggest it might be by saying things like \"<code>new[]</code> should always match with <code>delete[]</code>\". Well that rule is a little misleading. What is really meant here is that <code>new</code> with an array type should always be matched with <code>delete[]</code>.</p>\n</hr>", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2014-01-04T21:59:26.827", "Id": "20919283", "Score": "12", "CreationDate": "2014-01-04T09:37:55.667", "LastActivityDate": "2014-01-04T21:59:26.827"}, "20925726": {"ParentId": "20918981", "CommentCount": "0", "Body": "<p>The problem here is that array type syntax in C and C++ is a jumbled mess, and <code>typedef</code>ing an array type to something that doesn't <em>look</em> so jumbled doesn't make it any less so.</p>\n<p>The result, in an expression, of dynamically allocating an array is a <em>pointer</em>, not an array. The types are different.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "20925726", "Score": "2", "CreationDate": "2014-01-04T19:32:55.163", "LastActivityDate": "2014-01-04T19:32:55.163"}, "bq_ids": {"n4140": {"so_20918981_20919283_0": {"section_id": 6082, "quality": 0.8, "length": 16}}, "n3337": {"so_20918981_20919283_0": {"section_id": 5850, "quality": 0.8, "length": 16}}, "n4659": {"so_20918981_20919283_0": {"section_id": 7578, "quality": 0.8, "length": 16}}}, "20918981": {"CommentCount": "22", "ViewCount": "331", "PostTypeId": "1", "ClosedDate": "2014-01-04T23:32:18.730", "LastEditorUserId": "2340064", "CreationDate": "2014-01-04T09:02:34.303", "LastActivityDate": "2014-01-04T21:59:26.827", "Title": "Why Array *new Array; fails in C++?", "AcceptedAnswerId": "20919283", "LastEditDate": "2014-01-04T19:21:39.543", "Id": "20918981", "Score": "9", "Body": "<p>I always thought <code>T *p = new T;</code> was valid C++ for all <code>T</code>... until I tried</p>\n<pre><code>int main()\n{\n    typedef int Array[2];\n    Array *p = new Array;\n}\n</code></pre>\n<p>and got this cute error I couldn't decipher:</p>\n<pre><code>error C2440: 'initializing' : cannot convert from 'int *' to 'Array (*)'\n</code></pre>\n<p>Could someone please explain why this is an error?</p>\n", "Tags": "<c++><arrays><pointers><new-operator><typedef>", "OwnerUserId": "541686", "AnswerCount": "2"}});