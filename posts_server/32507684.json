post_cb({"32507684": {"CommentCount": "23", "ViewCount": "185", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-09-10T16:57:08.860", "LastActivityDate": "2015-09-10T18:13:58.270", "Title": "Does delete[] deallocate memory in one shot after invoking destructors?", "AcceptedAnswerId": "32508591", "LastEditDate": "2017-05-23T10:27:13.000", "Id": "32507684", "Score": "6", "Body": "<p>I understand that, when we write <code>delete []</code> on a pointer created by a corresponding <code>new []</code>, the program will look for the accounting information on the array and find out the array's element size (a counter). Then the program invokes the element's destructor on each of them. Finally memory (what memory??) is deallocated by a function named <code>operator delete</code>.</p>\n<p>What I am asking is whether <code>delete[]</code> will deallocate the entire memory, allocated by the <code>new[]</code> expression, in <em>one shot</em> because that information (total amount of memory) is available <strong>after</strong> all elements are destroyed, or will it <strong>successively</strong> deallocate the memory occupied by the array elements that it has invoked destructors on?</p>\n<p>A related follow-up quesion is asked <a href=\"https://stackoverflow.com/questions/32508952/does-delete-non-array-form-know-the-total-amount-of-memory-allocated-by-either\">Does delete (non array form) know the total amount of memory allocated by either new or new[]</a></p>\n", "Tags": "<c++><memory-management>", "OwnerUserId": "1021388", "AnswerCount": "3"}, "32508177": {"ParentId": "32507684", "CommentCount": "0", "CreationDate": "2015-09-10T17:26:19.543", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "32508177", "Score": "1", "Body": "<p>5.3.5/2:</p>\n<blockquote>\n<p id=\"so_32507684_32508177_0\">In the first alternative (delete object), the value of the operand of\n  delete may be a null pointer value, a pointer to a non-array object\n  created by a previous new-expression, or a pointer to a subobject\n  (1.8) representing a base class of such an object (Clause 10). If not,\n  the behavior is undefined.</p>\n</blockquote>\n<p>This clearly shows us that the behavior in your proposed situation is undefined by the standard, which leaves \"not leaking memory\" or \"leaking memory\" as the two most likely undefined behaviors (it seems that heap corruption could be a much less likely third possibility just for completeness). Just don't write such code and you avoid possible problems.</p>\n", "LastActivityDate": "2015-09-10T17:26:19.543"}, "32508591": {"ParentId": "32507684", "CommentCount": "0", "CreationDate": "2015-09-10T17:52:05.410", "OwnerUserId": "388520", "PostTypeId": "2", "Id": "32508591", "Score": "2", "Body": "<p>All of the memory will be released to the underlying allocator at once.  This is mandated by the C++ standard, although not especially clearly. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a> is the closest approximation to the official C++11 standard available online for free.  Look at section 5.3.5, [expr.delete], which spells out the code that an invocation of <code>delete[]</code> expands to.  In particular, <code>operator delete[]</code> is called <em>once</em> in step 7, <em>after</em> destructors have been invoked for all elements of the array (step 6).</p>\n<p>You can also deduce this behavior from the wording in 18.6.1.2 [new.delete.array] regarding what pointers are valid to pass to <code>operator delete[]</code>: \"... shall be the value returned by an earlier call to <code>operator new[]</code> (... caveats ...)\".  Since <code>operator new[]</code> returns one pointer to an entire array, <code>operator delete[]</code> must also be invoked once for an entire array.</p>\n", "LastActivityDate": "2015-09-10T17:52:05.410"}, "32508511": {"ParentId": "32507684", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-09-10T17:46:12.597", "Score": "0", "LastEditorUserId": "5089383", "LastEditDate": "2015-09-10T17:52:21.000", "Id": "32508511", "OwnerUserId": "5089383", "Body": "<p>In practice your example</p>\n<pre><code>auto pi = new int[10];\n...\ndelete pi;\n</code></pre>\n<p>works just fine and is quite common in working programs.  I'll trust those here who looked it up in the standard, that it is undefined behavior.  So I won't suggest you take advantage of the fact that it routinely works.\nIn practice, the allocator keeps track of the total size and deallocation frees the correct total size, so pairing new[] with delete only causes the destructors of elements past the zeroeth to fail to be called and does no harm for arrays of objects with trivial destruction.  But coding undefined behavior is not a great idea even when you are confident every compiler behaves OK for that particular UB.</p>\n<p>Edit: now that you removed all that from your question to ask only the more trivial part of the original question:  </p>\n<p>I assume the standard does not go into any such detail, so an implementation could do either.  But I'm also confident any real implementation frees the entire contiguous chunk in one shot after calling all the destructors.  (The implementation would also have no choice but to do it the sane way for cases where delete[] is overridden)</p>\n", "LastActivityDate": "2015-09-10T17:52:21.000"}, "bq_ids": {"n4140": {"so_32507684_32508177_0": {"section_id": 6106, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_32507684_32508177_0": {"section_id": 5872, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_32507684_32508177_0": {"section_id": 7603, "quality": 0.9629629629629629, "length": 26}}}});