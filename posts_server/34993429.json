post_cb({"34993429": {"ViewCount": "1523", "Body": "<p>In the following program the <code>a</code> member variable is not copied when B is virtually derived from A and instances of C (not B) are copied.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass A {\npublic:\n    A() { a = 0; printf(\"A()\\n\"); }\n\n    int a;\n};\n\nclass B : virtual public A {\n};\n\nclass C : public B {\npublic:\n    C() {}\n    C(const C &amp;from) : B(from) {}\n};\n\ntemplate&lt;typename T&gt;\nvoid\ntest() {\n    T t1;\n    t1.a = 3;\n    printf(\"pre-copy\\n\");\n    T t2(t1);\n    printf(\"post-copy\\n\");\n    printf(\"t1.a=%d\\n\", t1.a);\n    printf(\"t2.a=%d\\n\", t2.a);\n}\n\nint\nmain() {\n    printf(\"B:\\n\");\n    test&lt;B&gt;();\n\n    printf(\"\\n\");\n\n    printf(\"C:\\n\");\n    test&lt;C&gt;();\n}\n</code></pre>\n<p>output:</p>\n<pre><code>B:\nA()\npre-copy\npost-copy\nt1.a=3\nt2.a=3\n\nC:\nA()\npre-copy\nA()\npost-copy\nt1.a=3\nt2.a=0\n</code></pre>\n<p>Note that if B is normally derived from A (you delete the <code>virtual</code>) then <code>a</code> is copied.</p>\n<p>Why isn't <code>a</code> copied in the first case (<code>test&lt;C&gt;()</code> with B virtually derived from A?</p>\n", "AcceptedAnswerId": "34995780", "Title": "Why does using a virtual base class change the behavior of the copy constructor", "CreationDate": "2016-01-25T13:07:52.980", "Id": "34993429", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-01-25T21:12:11.103", "Score": "17", "OwnerUserId": "1439401", "Tags": "<c++>", "AnswerCount": "4"}, "34993875": {"Id": "34993875", "PostTypeId": "2", "Body": "<p>Consider a diamond inheritance where you pass the <code>C</code> object to copy from, to both <code>B1</code> and <code>B2</code> ctors:</p>\n<pre><code>class A { public: int a };\n\nclass B1: virtual public A {};\nclass B2: virtual public A {};\n\nclass C: public B1, public B2 {\npublic:\n    C(const C &amp;from): B1(from), B2(from) {}\n};\n</code></pre>\n<p>(see <a href=\"http://coliru.stacked-crooked.com/a/b81fad6cf00c664a\">http://coliru.stacked-crooked.com/a/b81fad6cf00c664a</a>). </p>\n<p>Which one should initialize the <code>a</code> member? The first, the latter, both (in which order)? What if the <code>B1</code> and <code>B2</code> cctors initialize <code>a</code> in different ways?</p>\n<p>This is why <em>you</em> need to call the <code>A</code> cctor explicitly, otherwise the members of the <code>A</code> class get default constructed.</p>\n<p>What I really found funny is that defaulting the <code>C</code> cctor the compiler manages to copy the <code>a</code> member, but this is another question.</p>\n", "LastEditorUserId": "2140449", "LastActivityDate": "2016-01-25T16:53:04.430", "Score": "10", "CreationDate": "2016-01-25T13:30:14.720", "ParentId": "34993429", "CommentCount": "9", "OwnerUserId": "2140449", "LastEditDate": "2016-01-25T16:53:04.430"}, "34995780": {"Id": "34995780", "PostTypeId": "2", "Body": "<p>The C++11 standard says in 12.6.2/10:</p>\n<blockquote>\n<p id=\"so_34993429_34995780_0\">In a non-delegating constructor, initialization proceeds in the\n  following order:<br>\n  \u2014 First, and <strong>only for the constructor of the most derived class</strong> (1.8), virtual base classes are initialized in the order\n  they appear on a depth-first left-to-right traversal of the directed\n  acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of\n  appearance of the base classes in the derived class\n  base-specifier-list.<br>\n  \u2014 [direct base classes etc. ...]</br></br></p>\n</blockquote>\n<p>This says it, basically -- the most derived class is responsible for initialization in whatever way it defines it (in the OP: it doesn't, which leads to default initialization). The subsequent example in the standard features a similar scenario as in the OP here, just with an int argument to the ctor; only the default ctor of the virtual base is called, because no explicit \"mem-initializer\" for the virtual base is provided in the most derived class.</p>\n<p>Of interest, although nor directly applying here, is also 12.6.2/7:</p>\n<blockquote>\n<p id=\"so_34993429_34995780_1\">A mem-initializer [the <code>A()</code> in a possible <code>B(): A() {}</code>. -pas] where the mem-initializer-id denotes a virtual base\n  class is ignored during execution of a constructor of any class that\n  is not the most derived class.</p>\n</blockquote>\n<p>(I find that pretty tough. The language basically says \"I don't care what you coded, I'm gonna ignore it.\" There are not so many places where it can do that, violating as-if.) That constructor of a not-most-derived-class would be <code>B()</code>. The sentence does not directly apply here because there is no explicit constructor in <code>B</code>, so there is no mem-initializer either. But although I could not find wording for that in the standard one must assume (and it is consistent) that the same rule applies for the <em>generated</em> copy constructor.</p>\n<p>For completeness, Stroustrup says in \"The C++ Programming Language\" (4.ed, 21.2.5.1) about a most derived class D with a virtual base V down the road somewhere: </p>\n<blockquote>\n<p id=\"so_34993429_34995780_2\">The fact that V wasn't explicitly mentioned as a base of D is irrelevant. Knowledge of a virtual base and the obligation to initialize it \"bubbles up\" to the most derived class. <strong>A virtual base is always considered a direct base of its most derived class.</strong></p>\n</blockquote>\n<p>That is exactly what Sam Varshavchik said in an earlier post.</p>\n<p>Stroustrup then goes on to discuss that deriving a class DD from D makes it necessary to move V's intialization to DD, which \"can be a nuisance. That ought to encourage us not to overuse virtual base classes.\"</p>\n<p>I find it fairly obscure and dangerous that a base class stays uninitialized (well, more precisely: default-initialized) unless the most-derived class explicitly does something.</p>\n<p>The author of the most-derived class must dive deep into\nan inheritance hierarchy s/he may have no interest in or documentation about and cannot rely on e.g. the library s/he uses to do the right thing (the library can't).</p>\n<p>I'm also not sure I agree with the rationale given in other posts (\"which of the various intermediate classes should perform the initialization?\"). The standard has a clear notion of the initialization order (\"depth-first left-to-right traversal\"). Couldn't it mandate that the first class encountered which virtually inherits from a base performs the initialization?</p>\n<p>The interesting fact that the default copy ctor <em>does</em> initialize the virtual base is prescribed in 12.8/15:</p>\n<blockquote>\n<p id=\"so_34993429_34995780_3\">Each base or non-static data member is copied/moved in the manner\n  appropriate to its type:<br>\n  [...]<br>\n  \u2014 otherwise, the base or member is\n  direct-initialized with the corresponding base or member of x. </br></br></p>\n<p id=\"so_34993429_34995780_4\">Virtual\n  base class subobjects shall be initialized only once by the\n  implicitly-defined copy/move constructor (see 12.6.2).</p>\n</blockquote>\n<p>In any event, because <code>C</code> is the most derived class it is <code>C</code>'s (and not <code>B</code>'s) responsibility to copy-construct the virtual base <code>A</code>.</p>\n", "LastEditorUserId": "3150802", "LastActivityDate": "2016-01-25T21:12:11.103", "Score": "11", "CreationDate": "2016-01-25T15:07:06.537", "ParentId": "34993429", "CommentCount": "0", "OwnerUserId": "3150802", "LastEditDate": "2016-01-25T21:12:11.103"}, "34993867": {"Id": "34993867", "PostTypeId": "2", "Body": "<p>The best way to understand virtual inheritance is by understanding that virtually-inherited classes are always subclassed by the most derived class.</p>\n<p>In other words, the class hierarchy in the example ends up being, in a manner of speaking:</p>\n<pre><code>class A {\n};\n\nclass B {\n};\n\nclass C : public B, public A {\n};\n</code></pre>\n<p>That's what, from some abstract viewpoint, is happening here. The \"most derived\", or the \"top-level\" class, becomes the direct \"parent\" of all virtual classes in its hierarchy.</p>\n<p>Consequently, you are defining C's copy constructor, which copy-constructs <code>B</code>, however since <code>A</code> is no longer a subclass of <code>B</code>, nothing copy-constructs <code>A</code>, hence the behavior you're seeing.</p>\n<p>Note that all of what I just said is applicable to the <code>C</code> class only. The <code>B</code> class, by itself, is derived from <code>A</code> as you'd expect. It's just that when you declare additional subclasses of a class with virtual superclasses, all virtual superclasses \"float\" to the newly-defined subclass.</p>\n", "LastActivityDate": "2016-01-25T13:30:04.353", "CommentCount": "4", "CreationDate": "2016-01-25T13:30:04.353", "ParentId": "34993429", "Score": "14", "OwnerUserId": "3943312"}, "bq_ids": {"n4140": {"so_34993429_34995780_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 464}, "so_34993429_34995780_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 438}, "so_34993429_34995780_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 434}, "so_34993429_34995780_3": {"length": 17, "quality": 1.0, "section_id": 464}}, "n3337": {"so_34993429_34995780_3": {"length": 17, "quality": 1.0, "section_id": 455}, "so_34993429_34995780_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 429}, "so_34993429_34995780_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 426}, "so_34993429_34995780_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 455}}, "n4659": {"so_34993429_34995780_3": {"length": 17, "quality": 1.0, "section_id": 487}, "so_34993429_34995780_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 458}, "so_34993429_34995780_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 452}, "so_34993429_34995780_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 487}}}, "34993709": {"Id": "34993709", "PostTypeId": "2", "Body": "<p>Virtual inheritance is a funny beast, in that copy construction isn't \"inherited\" in the same way that it would be normally. Your <code>A</code> base is being default-constructed because you are not explicitly copy-constructing it:</p>\n<pre><code>class C : public B {\npublic:\n    C() {}\n    C(const C &amp;from) : A(from), B(from) {}\n};\n</code></pre>\n", "LastActivityDate": "2016-01-25T13:22:59.560", "CommentCount": "6", "CreationDate": "2016-01-25T13:22:59.560", "ParentId": "34993429", "Score": "19", "OwnerUserId": "560648"}});