post_cb({"bq_ids": {"n4140": {"so_30064094_30064173_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 639}, "so_30064094_30064173_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 603}}, "n3337": {"so_30064094_30064173_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 629}, "so_30064094_30064173_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 593}}, "n4659": {"so_30064094_30064173_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 667}, "so_30064094_30064173_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 629}}}, "30064397": {"Id": "30064397", "PostTypeId": "2", "Body": "<p>Overload resolution occurs in the following steps:</p>\n<ol>\n<li>A set of candidate functions is assembled. This set of candidates consists of both non-template functions and specializations of function templates. If template parameter deduction fails on a function template, it's silently removed from the set of candidates.</li>\n<li>A subset of candidate functions are determined to be <em>viable</em>. That means the number of parameters it has is compatible with the number of arguments and that each argument can be implicitly converted to the corresponding parameter type. (Note that a function if viable even if a conversion is ambiguous; but in that case this function might still be chosen, and then you get a compilation error afterward).</li>\n<li>Viable functions are compared. For a given pair of viable functions, the one that, in a sense, requires less implicit conversion in order to initialize the function's parameters from the given arguments, is considered \"better\" than the other function. Note that it's possible that given two functions, neither one is better than the other. Often, these rules are sufficient to establish that a single viable function is better than all the others. That function would then win overload resolution.</li>\n<li>If there are two functions and neither is better than the other, then in some circumstances [1] a tie-breaker rule is applied that might still determine that one is better than the other. If rule 3 could not determine which one of two viable functions is better, but only one is a non-template, the non-template is better; if both are template specializations, but one is generated from a template that's <em>more specialized</em> than the other, that function is better. After the tie-breaker, if there's a single best viable function (better than all the others), that function wins overload resolution. If the ambiguity remains, overload resolution fails and the call is ambiguous.</li>\n</ol>\n<p>It's important to remember that step 4 comes after step 3; the \"genericness\" or \"templateness\" is <strong>exclusively a tie-breaker rule.</strong></p>\n<p>Let's go over all your examples in your first code block.</p>\n<p>(1) Deduction succeeds on the first and third overloads; <code>Hrg</code> cannot be deduced for the second. The candidates are therefore the first and third (rule 1). Both are viable (rule 2). The first overload would bind <code>i</code> to <code>int&amp;</code> while the third would bind <code>i</code> to <code>const int&amp;</code>. Binding to the less cv-qualified reference is preferred (rule 3). (Barry has the specific quote from the standard.) The first (generic) overload wins.</p>\n<p>(2) <code>Hrg</code> cannot be deduced for the third overload, so it is not a candidate (rule 1). The first and second are candidates and are viable (rule 2). The first and second overloads both match exactly with no conversions required and are indistinguishable by rule 3. The second wins because it's more specialized (rule 4).</p>\n<p>(5) Deduction of <code>Hrg</code> fails for the second overload, so it is not a candidate, while the first and third are (rule 1). Note that for the first overload, <code>A</code> is deduced as <code>const int</code>, producing an identical signature to the third overload. They are both viable (rule 2) and are indistinguishable by the end of rule 3. The third overload wins because it's more specialized (rule 4).</p>\n<p>(6) Deduction of <code>Hrg</code> fails for the third overload, so it is not a candidate, while the first and second are (rule 1). The second overload is not viable (rule 2) since <code>int&amp;</code> cannot bind to <code>ri</code>, which is <code>const</code>. The first overload, the generic one, is the only viable function, so it wins.</p>\n<p>I leave the overload resolution in the second code block as an exercise for the reader.</p>\n<p>[1] As T.C. points out in comments, there is a subtlety here. The tie-breaker rule only applies when, for a given pair of functions, the implicit conversion sequences required to initialize the parameters from the arguments are equally ranked for every pair of corresponding parameters. If the first function has a better implicit conversion sequence for one parameter and the second has a better implicit conversion sequence for a different parameter, the tie-breaker rule isn't applied, and the ambiguity remains. This case doesn't occur in the example in the question, though.</p>\n", "LastEditorUserId": "481267", "LastActivityDate": "2015-05-05T23:15:55.710", "Score": "4", "CreationDate": "2015-05-05T22:37:49.920", "ParentId": "30064094", "CommentCount": "2", "LastEditDate": "2015-05-05T23:15:55.710", "OwnerUserId": "481267"}, "30064173": {"Id": "30064173", "PostTypeId": "2", "Body": "<p>Going in order through the four distinct test cases. In all cases, the conversion sequences are all the same - there are no conversions required, so we would have to move on to the next stage of overload resolution. </p>\n<pre><code>foo(wt, i); // 1) generic\n</code></pre>\n<p>There are two potential overloads here. The everything and the <code>Hrg&lt;true&gt;</code></p>\n<pre><code>template &lt;class Hrm, class A&gt; void foo(Hrm&amp; h, A&amp; a);\ntemplate &lt;template &lt;bool&gt; class Hrg&gt; void foo(Hrg&lt;true&gt;&amp; h, const int&amp; a);\n</code></pre>\n<p>In [over.ics.rank], we have (thanks @dyp):</p>\n<blockquote>\n<p id=\"so_30064094_30064173_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence <code>S2</code> if...<br>\n  \u2014 <code>S1</code> and <code>S2</code> are reference bindings (8.5.3), and the types to which the references refer are the same\n  type except for top-level <em>cv</em>-qualifiers, and the type to which the reference initialized by <code>S2</code> refers\n  is more <em>cv</em>-qualified than the type to which the reference initialized by <code>S1</code> refers..</br></p>\n</blockquote>\n<p><code>const int</code> is more <em>cv</em>-qualified than <code>int</code>, so the <code>int</code> overload is preferred - which would be the generic one.</p>\n<pre><code>foo(wf, i);  // 2) specialized int\n</code></pre>\n<p>Here the two overloads are </p>\n<pre><code>template &lt;class Hrm, class A&gt; void foo(Hrm&amp; h, A&amp; a)\ntemplate &lt;template &lt;bool&gt; class Hrg&gt; void foo(Hrg&lt;false&gt;&amp; h, int&amp; a)\n</code></pre>\n<p>Both conversion sequences are identical here, so nothing in that section can distinguish one from the other. So we move onto [over.match.best]:</p>\n<blockquote>\n<p id=\"so_30064094_30064173_1\">Given these definitions, a viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function\n  <code>F2</code> if for all arguments <em>i</em>, ICS<em>i</em>(<code>F1</code>) is not a worse conversion sequence than ICS<em>i</em>(<code>F2</code>), and then<br>\n  \u2014 ...<br>\n  \u2014 <code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized\n  than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</br></br></p>\n</blockquote>\n<p>The rules concerning \"more specialized than\" are complicated but basically mean that the second overload is viable for a strict subset of the types for which the first is viable for, hence it is preferred. </p>\n<pre><code>foo(wt, ri); // 5) specialized const-int\n</code></pre>\n<p>Here, we have the same two overloads as in the first case:</p>\n<pre><code>template &lt;class Hrm, class A&gt; void foo(Hrm&amp; h, A&amp; a);\ntemplate &lt;template &lt;bool&gt; class Hrg&gt; void foo(Hrg&lt;true&gt;&amp; h, const int&amp; a);\n</code></pre>\n<p>The conversion sequences are both identical, but the second overload is more specialized than the first, so the specialized overload is preferred for the same reasons as it was in (2).</p>\n<pre><code>foo(wf, ri); // 6) generic\n</code></pre>\n<p>Here the \"generic\" overload is the only viable overload. </p>\n<p><strong>UPDATE</strong> The new tests you added are more straightforward than the previous four. Given the two <code>foo</code> overloads:</p>\n<pre><code>template &lt;class Hrg&gt; void foo(Hrg&amp; h, int&amp; a);\ntemplate &lt;class Hrg&gt; void foo(Hrg&amp; h, const int&amp; a);\n</code></pre>\n<p>When called with <code>ri</code>, only the second overload is viable. But when called with <code>i</code>, the first overload is preferred for the same reasons as (1) above - <code>int</code> is less <em>cv</em>-qualified than <code>const int</code>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-05T22:50:36.763", "Score": "2", "CreationDate": "2015-05-05T22:16:40.457", "ParentId": "30064094", "CommentCount": "3", "LastEditDate": "2015-05-05T22:50:36.763", "OwnerUserId": "2069064"}, "30064094": {"ViewCount": "128", "Body": "<p>I have the following code, which may seem convoluted but comes from real code:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class Hrm, class A&gt;\nvoid foo(Hrm&amp; h, A&amp; a)\n{\n  cout &lt;&lt; \"generic\" &lt;&lt; endl;\n}\n\ntemplate &lt;template &lt;bool&gt; class Hrg&gt;\nvoid foo(Hrg&lt;false&gt;&amp; h, int&amp; a)\n{\n  cout &lt;&lt; \"specialized int\" &lt;&lt; endl;\n}\n\ntemplate &lt;template &lt;bool&gt; class Hrg&gt;\nvoid foo(Hrg&lt;true&gt;&amp; h, const int&amp; a)\n{\n  cout &lt;&lt; \"specialized const-int\" &lt;&lt; endl;\n}\n\ntemplate &lt;bool W&gt;\nstruct what;\n\ntemplate&lt;&gt; struct what&lt;true&gt; { };\ntemplate&lt;&gt; struct what&lt;false&gt; { };\n\n\nint main() {\n  what&lt;true&gt; wt;\n  what&lt;false&gt; wf; \n\n  int i = 5;\n  const int&amp; ri = i;\n\n  foo(wt, i);  // 1) generic\n  foo(wf, i);  // 2) specialized int\n  foo(wt, ri); // 5) specialized const-int\n  foo(wf, ri); // 6) generic\n  return 0;\n}\n</code></pre>\n<p><a href=\"https://ideone.com/8JO2uR\" rel=\"nofollow\">Ideone link</a>.</p>\n<p>I understand <code>4</code>: there is no specialization for a false <code>Hrg</code> with a <code>const int</code>, so the generic version is called. </p>\n<p>My question is, why are the given functions called for the other cases? <code>3</code> seems to called the specialized const version because <code>const int</code> matches \"more directly\" than <code>A</code>. I'd like to know why that happens more specifically.</p>\n<p>And, what about <code>1</code> and <code>2</code>? Particularly, <strong><code>1</code> very surprising to me</strong>: why is the <code>generic</code> version called instead of specialized const-int?</p>\n<hr>\n<p>An additional note: if I change the two <code>foo</code> specializations to:</p>\n<pre><code>template &lt;template &lt;bool&gt; class Hrg&gt;\nvoid _foo(Hrg&lt;false&gt;&amp; h, int&amp; a)\n{\n  cout &lt;&lt; \"specialized int\" &lt;&lt; endl;\n}\n\ntemplate &lt;template &lt;bool&gt; class Hrg&gt;\nvoid _foo(Hrg&lt;true&gt;&amp; h, const int&amp; a)\n{\n  cout &lt;&lt; \"specialized const-int\" &lt;&lt; endl;\n}\n\ntemplate &lt;class Hrg&gt;\nvoid foo(Hrg&amp; h, int&amp; a)\n{\n  return _foo(h, a);\n}\n\ntemplate &lt;class Hrg&gt;\nvoid foo(Hrg&amp; h, const int&amp; a)\n{\n  return _foo(h, a);\n}\n</code></pre>\n<p>Then the output becomes:</p>\n<pre><code>foo(wt, i);     // a) specialized const-int\nfoo(wf, i);     // b) specialized int\nfoo(wt, ri);    // c) specialized const-int\n//foo(wf, ri);  // d) compilation error\n</code></pre>\n<p>Which is a much more intuitive result for me.</p>\n</hr>", "AcceptedAnswerId": "30064397", "Title": "How does C++ resolve specialized templates considering constness, templated-ness, and genericness?", "CreationDate": "2015-05-05T22:09:17.750", "Id": "30064094", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-05-05T22:19:59.627", "LastEditorUserId": "15055", "LastActivityDate": "2015-05-05T23:15:55.710", "Score": "6", "OwnerUserId": "15055", "Tags": "<c++><templates><overloading><function-overloading><overload-resolution>", "AnswerCount": "2"}});