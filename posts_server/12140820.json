post_cb({"12141719": {"Id": "12141719", "PostTypeId": "2", "Body": "<p>Overloaded functions in C++ work because the compiler encodes each unique method and parameter list combination into a unique name for the linker. This encoding process is called mangling,\nand the inverse process demangling.<br/></p>\n<p>But there is no such thing in C. When the compiler encounters a symbol (either a variable or function name) that is not defined in the current module, it assumes that it is defined in some other module, generates a linker symbol table entry, and leaves it for the linker to handle. In here we have no parameter checking.<br/></p>\n<p>And also if there is no type conversion in here. In main, you send a value to foo. Here it's assembly code :<br/></p>\n<pre><code>movl    $65, (%esp)\ncall    foo\n</code></pre>\n<p>And foo reads it by taking it away from stack. Since it's input value defined as char, It store the input value in <code>al</code> register ( one byte ):</p>\n<pre><code>movb    %al, -4(%ebp)\n</code></pre>\n<p>So for given inputs greater than 256, you will see variable <code>a</code> in foo, circulates over 256.</p>\n<p>About your second question, In C symbols for initialized variables and functions are defined as strong and multiple strong symbbols are not allowed, but I not sure whether is it the case with C++ or not.</p>\n", "LastActivityDate": "2012-08-27T12:09:35.580", "CommentCount": "0", "CreationDate": "2012-08-27T12:09:35.580", "ParentId": "12140820", "Score": "1", "OwnerUserId": "861949"}, "12140936": {"Id": "12140936", "PostTypeId": "2", "Body": "<p>Q1. According to C99 specification, section 6.5.2.2.9, it is an undefined behavior in C:</p>\n<blockquote>\n<p id=\"so_12140820_12140936_0\">If the function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function, the behavior is undefined.</p>\n</blockquote>\n<p>The expression \"points to\" a function taking an <code>int</code>, while the function is defined as taking a <code>char</code>.</p>\n<p>Q2. The case with variables is also undefined behavior, because you are reading or assigning an <code>int</code> to/from <code>char</code>. Assuming 4-byte integers, this will access three bytes past the memory location where it is valid. You can test this by declaring more variables, like this:</p>\n<pre><code>char a = 'A';\nchar b = 'B';\nchar c = 'C';\nchar d = 'D';\n</code></pre>\n", "LastEditorUserId": "908515", "LastActivityDate": "2012-08-27T11:47:44.430", "Score": "5", "CreationDate": "2012-08-27T11:17:15.980", "ParentId": "12140820", "CommentCount": "3", "OwnerUserId": "335858", "LastEditDate": "2012-08-27T11:47:44.430"}, "12140988": {"Id": "12140988", "PostTypeId": "2", "Body": "<p>That's why you put declarations into headers, so even a C compiler can catch the problem.</p>\n<p>1)</p>\n<p>The results of this is pretty much random; in your case, the \"char\" parameter might be passed as an int (like in a register, or even on the stack to keep alignment, or whatever). Or you got lucky due to endianess, which keeps the lowest order byte first.</p>\n<p>2)</p>\n<p>Likely to be a lucky outcome due to endianess and some added '0' bytes to fill up the segment. Again, don't rely on it.</p>\n", "LastActivityDate": "2012-08-27T11:21:08.363", "CommentCount": "7", "CreationDate": "2012-08-27T11:21:08.363", "ParentId": "12140820", "Score": "2", "OwnerUserId": "826751"}, "bq_ids": {"n4140": {"so_12140820_12140936_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 5988}}, "n3337": {"so_12140820_12140936_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 5756}}, "n4659": {"so_12140820_12140936_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 7488}}}, "12190808": {"Id": "12190808", "PostTypeId": "2", "Body": "<p>Just so you know, I've accidentally found the paragraph in C11 standard that covers both issues - it's 6.2.7.2:</p>\n<blockquote>\n<p id=\"so_12140820_12190808_0\">All declarations that refer to the same object or function shall have\n  compatible type; otherwise, the behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2012-08-30T06:07:36.510", "CommentCount": "0", "CreationDate": "2012-08-30T06:07:36.510", "ParentId": "12140820", "Score": "1", "OwnerUserId": "1576085"}, "12140820": {"ViewCount": "877", "Body": "<p>I have 2 questions regarding different declarations of the same function and global variable in two files in case of C and C++ as well.</p>\n<ol>\n<li><p><strong>Different function declarations</strong></p>\n<p>Consider the following code fragments:</p>\n<p><strong>file_1.c</strong></p>\n<pre><code>void foo(int a);\n\nint main(void)\n{\n    foo('A');\n}\n</code></pre>\n<p><strong>file_2.c</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid foo(char a)\n{\n    printf(\"%c\", a); //prints 'A' (gcc)\n}\n</code></pre>\n<p>As we can see, the prototype differs from the definition located in\n<strong>file_2.c</strong>, however, the function prints expected value.</p>\n<p>If it comes to C++, the above program is invalid due to undefined\nreference to <code>foo(int)</code> at link time. It's probably caused by\npresence of other function signatures - in comparison with C, where\na function name doesn't contain any extra characters indicating the\ntype of function arguments.</p>\n<p>But when it comes to C then what? Since the prototypes with the same\nname have the same signature regardless of the number of arguments\nand its types, linker won't issue an error. But which type\nconversions are performed in here? Does it look like this: <code>'A'</code> -&gt;\n<code>int</code> -&gt; back to <code>char</code>? Or maybe this behavior is\nundefined/implementation-defined ?</p></li>\n<li><p><strong>Different declarations of a global variable</strong></p>\n<p>We've got two files and two different declarations of the same\nglobal variable:</p>\n<p><strong>file_1.c</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nextern int a;\n\nint main(void)\n{\n    printf(\"%d\", a); //prints 65 (g++ and gcc)\n}\n</code></pre>\n<p><strong>file_2.c</strong></p>\n<pre><code>char a = 'A';\n</code></pre>\n<p>Both in C and C++ the output is 65.</p>\n<p>Though I'd like to know what both standards say about that kind of\nsituation.</p>\n<p>In the C11 standard I've found the following fragment:</p>\n<blockquote>\n<p id=\"so_12140820_12140820_0\"><strong>J.5.11 Multiple external definitions</strong> <em>(Annex J.5 Common extensions)</em><br>\n  There may be more than one external definition for the identifier of\n  an object, with or without the explicit use of the keyword extern; if\n  the definitions disagree, or more than one is initialized, the\n  behavior is undefined (6.9.2).</br></p>\n</blockquote>\n<p>Notice that it refers to presence of two and more definitions, in\nmy code there is only one, so I'm not sure whether this article is a good point of     reference in\nthis case...</p></li>\n</ol>\n", "AcceptedAnswerId": "12140936", "Title": "Different declarations of the same function/global variable in two files", "CreationDate": "2012-08-27T11:06:17.867", "Id": "12140820", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-10-11T11:16:27.103", "LastEditorUserId": "3749523", "LastActivityDate": "2015-10-11T11:16:27.103", "Score": "6", "OwnerUserId": "1576085", "Tags": "<c++><c><function><global-variables><forward-declaration>", "AnswerCount": "4"}});