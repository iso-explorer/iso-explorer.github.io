post_cb({"25745759": {"CommentCount": "11", "AcceptedAnswerId": "25758367", "CreationDate": "2014-09-09T13:21:45.243", "LastActivityDate": "2014-09-10T20:02:16.927", "PostTypeId": "1", "ViewCount": "1107", "FavoriteCount": "9", "Title": "Clang vs GCC vs MSVC template conversion operator - which compiler is right?", "Id": "25745759", "Score": "23", "Body": "<p>I have simple code with conversion operator and it seems like all compilers are giving different results, was curious which compiler, if any, is correct?\nI tried different combinations as well, but below ones are the most interesting. Code was compiled using C++11 flag, but the same behavior might be observed in C++03 as well.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct call_operator {\n    template&lt;typename T&gt;\n    operator T() {\n        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n        return {};\n    }\n\n    template&lt;typename T&gt;\n    operator const T&amp;() const {\n        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n        static T t;\n        return t;\n    }\n\n    template&lt;typename T&gt;\n    operator T&amp;() const {\n        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n        static T t;\n        return t;\n    }\n};\n\nint main() {\n    (void)static_cast&lt;int&gt;(call_operator());\n    (void)static_cast&lt;const int&amp;&gt;(call_operator());\n    (void)static_cast&lt;int&amp;&gt;(call_operator());\n}\n</code></pre>\n<p>clang-3.6:</p>\n<pre><code>operator int\noperator const int &amp;\noperator int &amp;\n</code></pre>\n<p>g++-4.9:</p>\n<pre><code>operator T\noperator const T&amp;\noperator T&amp;\n</code></pre>\n<p>msvc 2014 CTP:</p>\n<pre><code>call_operator.cpp(17): error C2440: 'static_cast': cannot convert from 'call_operator' to ' const int &amp;'\n</code></pre>\n<p>after removal of:</p>\n<pre><code>template&lt;typename T&gt;\noperator T();\n</code></pre>\n<p>msvc compiles:</p>\n<pre><code>call_operator::operator const int &amp;\ncall_operator::operator const int &amp;\ncall_operator::operator int &amp;\n</code></pre>\n<p>furthermore, after removal of const in </p>\n<pre><code>template&lt;typename T&gt;\noperator const T&amp;();\n</code></pre>\n<p>clang-3.6:</p>\n<pre><code>call_operator.cpp:26:9: error: ambiguous conversion for static_cast from 'call_operator' to 'int' (void)static_cast&lt;int&gt;(call_operator());\n</code></pre>\n<p>g++-4.9:</p>\n<pre><code>operator T\noperator const T&amp;\noperator T&amp;\n</code></pre>\n<p>msvc 2014 CTP:</p>\n<pre><code>call_operator.cpp(16): error C2440: 'static_cast': cannot convert from 'call_operator' to 'int'\n</code></pre>\n", "Tags": "<c++><visual-c++><gcc><c++11><clang>", "OwnerUserId": "1293787", "AnswerCount": "1"}, "25758367": {"ParentId": "25745759", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><strong>In short</strong>: Clang is correct (though in one case, for the wrong reason). GCC is wrong in the second case. MSVC is wrong in the first case.</p>\n<p>Let's start from <code>static_cast</code> (\u00a75.2.9 [expr.static.cast]/p4, all quotes are from N3936):</p>\n<blockquote>\n<p id=\"so_25745759_25758367_0\">An expression <code>e</code> can be explicitly converted to a type <code>T</code> using a\n  <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code>\n  is well-formed, for some invented temporary variable <code>t</code> (8.5).\n  The effect of such an explicit conversion is the same as performing\n  the declaration and initialization and then using the temporary\n  variable as the result of the conversion. The expression <code>e</code> is used\n  as a glvalue if and only if the initialization uses it as a glvalue.</p>\n</blockquote>\n<p>Accordingly, the three <code>static_cast</code>s here are effectively three initializations:</p>\n<pre><code>int t1(call_operator{});\nconst int &amp; t2(call_operator{});\nint &amp; t3(call_operator{});\n</code></pre>\n<p>Note that we rewrote <code>call_operator()</code> as <code>call_operator{}</code> for exposition purposes only, as <code>int t1(call_operator());</code> is the most vexing parse. There is a small semantic difference between those two forms of initialization, but that difference is immaterial to this discussion.</p>\n<h3><code>int t1(call_operator{});</code></h3>\n<p>The applicable rule for this initialization is set out in \u00a78.5 [dcl.init]/p17:</p>\n<blockquote>\n<p id=\"so_25745759_25758367_1\">if the source type is a (possibly cv-qualified) class type, conversion\n  functions are considered. The applicable conversion functions are\n  enumerated (13.3.1.5), and the best one is chosen through overload\n  resolution (13.3). The user-defined conversion so selected is called\n  to convert the initializer expression into the object being\n  initialized. If the conversion cannot be done or is ambiguous, the\n  initialization is ill-formed.</p>\n</blockquote>\n<p>We proceed to \u00a713.3.1.5 [over.match.conv], which says:</p>\n<blockquote>\n<p id=\"so_25745759_25758367_2\">Assuming that \u201c<code>cv1 T</code>\u201d is the type of the object being initialized,\n  and \u201c<code>cv S</code>\u201d is the type of the initializer expression, with <code>S</code> a\n  class type, the candidate functions are selected as follows:</p>\n<ul>\n<li>The conversion functions of <code>S</code> and its base classes are considered. Those non-explicit conversion functions that are not hidden within <code>S</code>\n  and yield type <code>T</code> or a type that can be converted to type <code>T</code> via a\n  standard conversion sequence (13.3.3.1.1) are candidate functions. For\n  direct-initialization, those explicit conversion functions that are\n  not hidden within <code>S</code> and yield type <code>T</code> or a type that can be\n  converted to type <code>T</code> with a qualification conversion (4.4) are also\n  candidate functions. Conversion functions that return a cv-qualified\n  type are considered to yield the cv-unqualified version of that type\n  for this process of selecting candidate functions. Conversion\n  functions that return \u201creference to cv2 <code>X</code>\u201d return lvalues or\n  xvalues, depending on the type of reference, of type \u201ccv2 <code>X</code>\u201d and are\n  therefore considered to yield <code>X</code> for this process of selecting\n  candidate functions. </li>\n</ul>\n<p id=\"so_25745759_25758367_3\">2 The argument list has one argument, which is the initializer\n  expression. [ <em>Note</em>: This argument will be compared against the\n  implicit object parameter of the conversion functions. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>The candidate set, after template argument deduction, is:</p>\n<pre><code>operator T() - with T = int\noperator const T&amp; () const - with T = int\noperator T&amp;() const - with T = int\n</code></pre>\n<p>The argument list consists of the single expression <code>call_operator{}</code>, which is non-const. It therefore converts better to the non-const implicit object parameter of <code>operator T()</code> than to the other two. Accordingly, <code>operator T()</code> is the best match and is selected by overload resolution.</p>\n<h3><code>const int &amp; t2(call_operator{});</code></h3>\n<p>This initialization is governed by \u00a78.5.3 [dcl.init.ref]/p5:</p>\n<blockquote>\n<p id=\"so_25745759_25758367_4\">A reference to type \u201ccv1 <code>T1</code>\u201d is initialized by an expression of type\n  \u201ccv2 <code>T2</code>\u201d as follows:</p>\n<ul>\n<li><p id=\"so_25745759_25758367_5\">If the reference is an lvalue reference and the initializer expression</p>\n<ul>\n<li>is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 <code>T2</code>,\u201d or</li>\n<li>has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be converted to an lvalue of type\n  \u201ccv3 <code>T3</code>,\u201d where \u201ccv1 <code>T1</code>\u201d is reference-compatible with \u201ccv3 <code>T3</code>\u201d \n  (this conversion is selected by enumerating the applicable conversion\n  functions (13.3.1.6) and choosing the best one through overload\n  resolution (13.3)).</li>\n</ul></li>\n</ul>\n<p id=\"so_25745759_25758367_6\">then the reference is bound to the initializer expression lvalue in\n  the first case and to the lvalue result of the conversion in the\n  second case (or, in either case, to the appropriate base class\n  subobject of the object).</p>\n</blockquote>\n<p>Note that this step considers only conversion functions returning lvalue references. </p>\n<p>Clang appears to deduce the candidate set as<sup>*</sup>:</p>\n<pre><code>operator const T&amp; () const - with T = int\noperator T&amp;() const - with T = int\n</code></pre>\n<p>It's obvious that the two functions are tied on the implicit object parameter since both are <code>const</code>. Further, since both are direct reference bindings, by \u00a713.3.3.1.4 [ics.ref]/p1, the conversion required from the return type of either function to <code>const int &amp;</code> is the identity conversion. (<strong>Not</strong> Qualification Adjustment - that refers to the conversion described in \u00a74.4 [conv.qual], and is only applicable to pointers.)</p>\n<p>However, it appears that the deduction performed by Clang for <code>operator T&amp;()</code> in this case is incorrect<sup>\u2021</sup>. \u00a714.8.2.3 [temp.deduct.conv]/p5-6:</p>\n<blockquote>\n<p id=\"so_25745759_25758367_7\">5 In general, the deduction process attempts to find template argument\n  values that will make the deduced <code>A</code> identical to <code>A</code>. However, there\n  are two cases that allow a difference:</p>\n<ul>\n<li>If the original <code>A</code> is a reference type, <code>A</code> can be more cv-qualified than the deduced A (i.e., the type referred to by the\n  reference)</li>\n<li>The deduced <code>A</code> can be another pointer or pointer to member type that can be converted to <code>A</code> via a qualification conversion.</li>\n</ul>\n<p id=\"so_25745759_25758367_8\">6 These alternatives are considered only if type deduction would\n  otherwise fail. If they yield more than one possible deduced <code>A</code>, the\n  type deduction fails.</p>\n</blockquote>\n<p>Since type deduction can succeed by deducing <code>T</code> as <code>const int</code> for <code>operator T&amp;()</code> for an exact match between the deduced type and the destination type, the alternatives shouldn't be considered, <code>T</code> should have been deduced as <code>const int</code>, and the candidate set is actually</p>\n<pre><code>operator const T&amp; () const - with T = int\noperator T&amp;() const - with T = const int\n</code></pre>\n<p>Once again, both standard conversion sequences from the result are identity conversions. GCC (and EDG, thanks to @Jonathan Wakely for testing) correctly deduces <code>T</code> in <code>operator T&amp;()</code> to be <code>const int</code> in this case<sup>*</sup>.</p>\n<p>Regardless of the correctness of the deduction, however, the tiebreaker here is the same. Because, according to the partial ordering rules for function templates, <code>operator const T&amp; ()</code> is more specialized than <code>operator T&amp;()</code> (due to the special rule in \u00a714.8.2.4 [temp.deduct.partial]/p9), the former wins by the tiebreaker in \u00a713.3.3 [over.match.best]/p1, 2nd list, last bullet point:</p>\n<blockquote>\n<p id=\"so_25745759_25758367_9\"><code>F1</code> and <code>F2</code> are function template specializations, and the function\n  template for <code>F1</code> is more specialized than the template for <code>F2</code>\n  according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>Thus, in this case, Clang gets the right result, but for (partially) the wrong reason. GCC gets the right result, for the right reason.</p>\n<h3><code>int &amp; t3(call_operator{});</code></h3>\n<p>There is no fight here. <code>operator const T&amp;();</code> simply can't possibly be used to initialize a <code>int &amp;</code>. There is only one viable function, <code>operator T&amp;()</code> with <code>T = int</code>, so it is the best viable function.</p>\n<h3>What if <code>operator const T&amp;();</code> isn't <code>const</code>?</h3>\n<p>The only interesting case here is the initialization <code>int t1(call_operator{});</code>. The two strong contenders are:</p>\n<pre><code>operator T() - with T = int\noperator const T&amp; () - with T = int\n</code></pre>\n<p>Note that the rule regarding ranking standard conversion sequences - \u00a713.3.3 [over.match.best]/p1, 2nd list, 2nd bullet point:</p>\n<blockquote>\n<p id=\"so_25745759_25758367_10\">the context is an initialization by user-defined conversion (see 8.5,\n  13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the\n  standard conversion sequence from the return type of <code>F2</code> to the\n  destination type.</p>\n</blockquote>\n<p>and \u00a713.3.3.2 [over.ics.rank]/p2:</p>\n<blockquote>\n<p id=\"so_25745759_25758367_11\">Standard conversion sequence <code>S1</code> is a better conversion sequence than\n  standard conversion sequence <code>S2</code> if</p>\n<ul>\n<li><code>S1</code> is a proper subsequence of <code>S2</code> (comparing the conversion sequences in the canonical form defined by 13.3.3.1.1, excluding any\n  Lvalue Transformation; the identity conversion sequence is considered\n  to be a subsequence of any non-identity conversion sequence)</li>\n</ul>\n</blockquote>\n<p>cannot distinguish these two, because the conversion necessary to get an <code>int</code> from a <code>const int &amp;</code> is an <em>lvalue-to-rvalue</em> conversion, which is an Lvalue Transformation. After excluding the Lvalue Transformation, the standard conversion sequences from the result to the destination type are identical; nor does any of the other rules in \u00a713.3.3.2 [over.ics.rank] apply.</p>\n<p>Thus the only rule that could possibly distinguish between these two functions is again the \"more specialized\" rule. The question is then whether one of <code>operator T()</code> and <code>operator const T&amp;()</code> is more specialized than the other. The answer is no. The detailed partial ordering rules are rather complex, but an analogous situation is easily found in the example in \u00a714.5.6.2 [temp.func.order]/p2, which labels a call to <code>g(x)</code> as ambiguous given:</p>\n<blockquote id=\"so_25745759_25758367_12\">\n<pre><code>template&lt;class T&gt; void g(T);\ntemplate&lt;class T&gt; void g(T&amp;);\n</code></pre>\n</blockquote>\n<p>A quick perusal of the procedure specified in \u00a714.8.2.4 [temp.deduct.partial] confirms that given one template taking a <code>const T&amp;</code> and the other taking a <code>T</code> by value, neither is more specialized than the other<sup>**</sup>. Thus, in this case, there is no unique best viable function, the conversion is ambiguous, and the code is ill-formed.<sup>\u2020</sup></p>\n<hr>\n<p><sub><sup>*</sup> The type deduced by Clang and GCC for the <code>operator T&amp;()</code> case is determined by running the code with <code>operator const T&amp;()</code> removed. </sub></p>\n<p><sub><sup>**</sup> Briefly, during the deduction for partial ordering, before any comparison is done, reference types are replaced with the types referred to, and then top-level cv-qualifiers are stripped, so both <code>const T&amp;</code> and <code>T</code> yield the same signature. However, \u00a714.8.2.4 [temp.deduct.partial]/p9 contains a special rule for when both types at issue were reference types, which makes <code>operator const T&amp;()</code> more specialized than <code>operator T&amp;()</code>; that rule doesn't apply when one of the types is not a reference type.</sub> </p>\n<p><sub><sup>\u2020</sup> GCC appears to not consider <code>operator const T&amp;()</code> a viable conversion for this case, but does consider <code>operator T&amp;()</code> a viable conversion.</sub></p>\n<p><sub><sup>\u2021</sup> This appears to be Clang <a href=\"http://llvm.org/bugs/show_bug.cgi?id=20783\">bug 20783</a>. </sub></p>\n</hr>", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-09-10T20:02:16.927", "Id": "25758367", "Score": "22", "CreationDate": "2014-09-10T06:05:44.870", "LastActivityDate": "2014-09-10T20:02:16.927"}, "bq_ids": {"n4140": {"so_25745759_25758367_2": {"section_id": 595, "quality": 0.9333333333333333, "length": 14}, "so_25745759_25758367_8": {"section_id": 306, "quality": 0.9411764705882353, "length": 16}, "so_25745759_25758367_5": {"section_id": 3321, "quality": 1.0, "length": 5}, "so_25745759_25758367_12": {"section_id": 1438, "quality": 1.0, "length": 4}, "so_25745759_25758367_11": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}, "so_25745759_25758367_4": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_25745759_25758367_7": {"section_id": 317, "quality": 1.0, "length": 18}, "so_25745759_25758367_3": {"section_id": 594, "quality": 0.75, "length": 15}, "so_25745759_25758367_9": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_25745759_25758367_10": {"section_id": 603, "quality": 0.9259259259259259, "length": 25}, "so_25745759_25758367_6": {"section_id": 3321, "quality": 1.0, "length": 20}, "so_25745759_25758367_0": {"section_id": 6030, "quality": 0.9444444444444444, "length": 34}, "so_25745759_25758367_1": {"section_id": 3296, "quality": 0.8974358974358975, "length": 35}}, "n3337": {"so_25745759_25758367_2": {"section_id": 585, "quality": 0.9333333333333333, "length": 14}, "so_25745759_25758367_8": {"section_id": 297, "quality": 0.9411764705882353, "length": 16}, "so_25745759_25758367_5": {"section_id": 3191, "quality": 1.0, "length": 5}, "so_25745759_25758367_12": {"section_id": 1432, "quality": 1.0, "length": 4}, "so_25745759_25758367_11": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}, "so_25745759_25758367_4": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_25745759_25758367_7": {"section_id": 307, "quality": 1.0, "length": 18}, "so_25745759_25758367_3": {"section_id": 584, "quality": 0.75, "length": 15}, "so_25745759_25758367_9": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_25745759_25758367_10": {"section_id": 593, "quality": 0.9259259259259259, "length": 25}, "so_25745759_25758367_6": {"section_id": 3191, "quality": 1.0, "length": 20}, "so_25745759_25758367_0": {"section_id": 5798, "quality": 0.9444444444444444, "length": 34}, "so_25745759_25758367_1": {"section_id": 3166, "quality": 0.8974358974358975, "length": 35}}, "n4659": {"so_25745759_25758367_2": {"section_id": 618, "quality": 0.9333333333333333, "length": 14}, "so_25745759_25758367_8": {"section_id": 313, "quality": 0.9411764705882353, "length": 16}, "so_25745759_25758367_7": {"section_id": 312, "quality": 0.9444444444444444, "length": 17}, "so_25745759_25758367_12": {"section_id": 1304, "quality": 1.0, "length": 4}, "so_25745759_25758367_11": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}, "so_25745759_25758367_6": {"section_id": 4087, "quality": 1.0, "length": 20}, "so_25745759_25758367_5": {"section_id": 4087, "quality": 1.0, "length": 5}, "so_25745759_25758367_3": {"section_id": 617, "quality": 0.75, "length": 15}, "so_25745759_25758367_9": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}, "so_25745759_25758367_10": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_25745759_25758367_4": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_25745759_25758367_1": {"section_id": 4058, "quality": 0.8974358974358975, "length": 35}}}});