post_cb({"bq_ids": {"n4140": {"so_30555121_30555275_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4809}, "so_30555121_30555257_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4809}}, "n3337": {"so_30555121_30555275_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4615}, "so_30555121_30555257_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4615}}, "n4659": {"so_30555121_30555275_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 6219}, "so_30555121_30555257_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 6219}}}, "30555275": {"Id": "30555275", "PostTypeId": "2", "Body": "<p>The standard <code>duration_cast</code> can only be used to convert to a specialization of <code>duration</code>. [time.duration.cast]/p1:</p>\n<blockquote>\n<pre><code>template &lt;class ToDuration, class Rep, class Period&gt;\nconstexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);\n</code></pre>\n<p id=\"so_30555121_30555275_0\"><em>Remarks</em>: This function shall not participate in overload resolution unless <code>ToDuration</code> is an instantiation of <code>duration</code>.</p>\n</blockquote>\n<p>If <code>ToDuration</code> is not a specialization of <code>duration</code>, then the signature is removed from overload resolution (by SFINAE or a similar technique), and the call fails unless another function template called <code>duration_cast</code> is available.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-05-31T08:22:18.143", "Score": "2", "CreationDate": "2015-05-31T08:17:04.973", "ParentId": "30555121", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2015-05-31T08:22:18.143"}, "30555257": {"Id": "30555257", "PostTypeId": "2", "Body": "<p>Visual C++ 2015 RC issues the following error when substituting <code>duration_cast&lt;Milliseconds&gt;</code> in your code:</p>\n<pre><code>error C2770: invalid explicit template argument(s) for 'enable_if&lt;std::chrono::_Is_duration&lt;_Ty&gt;::value,_To&gt;::type std::chrono::duration_cast(const std::chrono::duration&lt;_Rep,_Period&gt; &amp;)'\n</code></pre>\n<p>The <code>std::chrono::_Is_duration&lt;_Ty&gt;</code> trait is an internal implementation detail of the standard library used in MSVC; it's there to make things work according to the standard and make the error message easier to understand: you need to give <code>duration_cast</code> a template argument that really is a specialization of the <code>std::chrono::duration</code> template. Derived-to-base relationships are not considered in this case.</p>\n<p>[20.12.5.7] in the standard (N4431 draft) has the following description:</p>\n<pre><code>template &lt;class ToDuration, class Rep, class Period&gt;\n  constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);\n</code></pre>\n<blockquote>\n<p id=\"so_30555121_30555257_0\"><em>Remarks:</em> This function shall not participate in overload resolution unless <code>ToDuration</code> is an instantiation of <code>duration</code>.</p>\n</blockquote>\n<hr>\n<p>Base class template specializations are considered when deducing template arguments from the types of the arguments of a function call [14.8.2.1], but not when matching arguments to class template partial specializations [14.5.5.1], which is what happens for the <code>_Is_duration</code> trait.</p>\n</hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2015-05-31T11:32:40.430", "Score": "1", "CreationDate": "2015-05-31T08:14:20.847", "ParentId": "30555121", "CommentCount": "0", "OwnerUserId": "4326278", "LastEditDate": "2015-05-31T11:32:40.430"}, "30555444": {"Id": "30555444", "PostTypeId": "2", "Body": "<p>You need to provide your own <code>duration_cast</code>.</p>\n<pre><code>template&lt; typename my_dest, typename my_source &gt;\nmy_dest duration_cast( my_source const &amp; value )\n    { return duration_cast&lt; my_dest::duration &gt;( value ); }\n</code></pre>\n<p>It's not allowed to put this in <code>namespace std::chrono</code>, so you can't call this as <code>std::chrono::duration_cast</code>. One alternative is to add <code>using std::chrono::duration_cast</code> and <code>using my_namespace::duration_cast</code> to your namespace, and qualify with calls with that instead. (In the example, you're not using a namespace, so only the <code>using std</code>\u2026 is needed.)</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2015-06-01T00:24:32.770", "Score": "1", "CreationDate": "2015-05-31T08:38:51.707", "ParentId": "30555121", "CommentCount": "9", "OwnerUserId": "153285", "LastEditDate": "2015-06-01T00:24:32.770"}, "30555121": {"ViewCount": "441", "Body": "<p>I'm cleaning up my timer class using <code>std::chrono</code>. Everything else went smooth except that I cannot seem to apply <code>duration_cast</code> to derived classes. Well, I made it work in a different way, but I'd still like to know what I missed.</p>\n<p>See <a href=\"http://ideone.com/TuVs4g\" rel=\"nofollow\">here</a> for the error message.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n\ntypedef std::chrono::high_resolution_clock Clock;\n\nclass Milliseconds : public std::chrono::milliseconds\n{\npublic:\n    typedef std::chrono::milliseconds Base;\n    typedef Base::rep Type;\n\n    using Base::Base;\n};\n\ninline Milliseconds::Type millisecondsSinceEpoch()\n{\n    return std::chrono::duration_cast&lt;Milliseconds::Base&gt;(Clock::now().time_since_epoch()).count();\n    //duration_cast&lt;Milliseconds&gt; ERROR!\n}\n\nint main() {\n    using namespace std;\n    cout &lt;&lt; millisecondsSinceEpoch() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "30555275", "Title": "How to use `duration_cast` for a derived class?", "CreationDate": "2015-05-31T07:55:41.390", "Id": "30555121", "CommentCount": "2", "LastEditDate": "2015-05-31T11:36:07.960", "PostTypeId": "1", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-01T00:24:32.770", "Score": "2", "OwnerUserId": "3998522", "Tags": "<c++><c++11><chrono>", "AnswerCount": "3"}});