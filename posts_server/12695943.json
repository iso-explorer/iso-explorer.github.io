post_cb({"12695992": {"Id": "12695992", "PostTypeId": "2", "Body": "<p>While it's theoretically possible to run C or C++ on an architecture that uses non-power-of-2 arithmetic, the <code>|</code>, <code>&amp;</code>, and <code>^</code> operators are defined to have bitwise behavior, so such a machine would need to emulate binary arithmetic.</p>\n<p>It's therefore completely safe and portable.</p>\n", "LastActivityDate": "2012-10-02T18:21:50.400", "CommentCount": "0", "CreationDate": "2012-10-02T18:21:50.400", "ParentId": "12695943", "Score": "12", "OwnerUserId": "103167"}, "12696029": {"Id": "12696029", "PostTypeId": "2", "Body": "<h2>C++</h2>\n<p>The important part of the C++11 standard is \u00a73.9.1/7 (<em>ISO/IEC 14882:2011(E)</em>):</p>\n<blockquote>\n<p id=\"so_12695943_12696029_0\">The representations of integral types shall define values by use of a pure binary numeration system.</p>\n</blockquote>\n<p>This is clarified in a footnote:</p>\n<blockquote>\n<p id=\"so_12695943_12696029_1\">49) A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position. (Adapted from the American National Dictionary for Information Processing Systems.)</p>\n</blockquote>\n<p>The results of shift operators are defined mathematically. For example, for <code>E1 &lt;&lt; E2</code>:</p>\n<blockquote>\n<p id=\"so_12695943_12696029_2\">If E1 has an unsigned type, the value of the result is E1 \u00d7 2<sup>E2</sup> , reduced modulo one more than the maximum value representable in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1 \u00d7 2<sup>E2</sup> is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>The bitwise operators are specifically defined as being bitwise. For example, for bitwise OR:</p>\n<blockquote>\n<p id=\"so_12695943_12696029_3\">The usual arithmetic conversions are performed; the result is the bitwise exclusive OR function of the operands. </p>\n</blockquote>\n<p>Of course, under the as-if rule, the representation does not truly have to be the pure binary numeration system. The compiler must only produce a program that acts <em>as if</em> it were.</p>\n<h2>C</h2>\n<p>In C99 (<em>ISO/IEC 9899:TC3</em>), pure binary notation is only guaranteed for bit-fields and objects of type <code>unsigned char</code> (\u00a76.2.6.1/3):</p>\n<blockquote>\n<p id=\"so_12695943_12696029_4\">Values stored in unsigned bit-fields and objects of type unsigned char shall be represented using a pure binary notation.</p>\n</blockquote>\n<p>Again clarified in a footnote:</p>\n<blockquote>\n<p id=\"so_12695943_12696029_5\">A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral powers of 2, except perhaps the bit with the highest position. (Adapted from the American National Dictionary for Information Processing Systems.)</p>\n</blockquote>\n<p>The standard specifically points out that bitwise operations depend on the internal representation (\u00a76.5/4):</p>\n<blockquote>\n<p id=\"so_12695943_12696029_6\">Some operators (the unary operator ~, and the binary operators &lt;&lt;, &gt;&gt;, &amp;, ^, and |,\n  collectively described as <em>bitwise operators</em>) are required to have operands that have\n  integer type. These operators yield values that depend on the internal representations of\n  integers, and have implementation-defined and undefined aspects for signed types.</p>\n</blockquote>\n", "LastEditorUserId": "701092", "LastActivityDate": "2012-12-22T18:58:17.473", "Score": "18", "CreationDate": "2012-10-02T18:24:39.903", "ParentId": "12695943", "CommentCount": "4", "OwnerUserId": "150634", "LastEditDate": "2012-12-22T18:58:17.473"}, "12695985": {"Id": "12695985", "PostTypeId": "2", "Body": "<p>Bit shifting to the right always decreases the value of the integer, whereas bit shifting to the left will always increase the value.  This is irrespective of the endianness of the machine, so to answer your question: \"Yes, this is sound because bit shifting works the same no matter the endianness of the system\"</p>\n<p>Does that answer your question?</p>\n", "LastActivityDate": "2012-10-02T18:21:33.120", "CommentCount": "10", "CreationDate": "2012-10-02T18:21:33.120", "ParentId": "12695943", "Score": "1", "OwnerUserId": "1287910"}, "bq_ids": {"n4140": {"so_12695943_12696029_5": {"length": 26, "quality": 0.9285714285714286, "section_id": 7216}, "so_12695943_12696029_3": {"length": 9, "quality": 0.9, "section_id": 6161}, "so_12695943_12696029_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 7216}, "so_12695943_12696029_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7216}, "so_12695943_12696029_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 6147}}, "n3337": {"so_12695943_12696029_5": {"length": 26, "quality": 0.9285714285714286, "section_id": 6960}, "so_12695943_12696029_3": {"length": 9, "quality": 0.9, "section_id": 5922}, "so_12695943_12696029_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 6960}, "so_12695943_12696029_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6960}, "so_12695943_12696029_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 5910}}, "n4659": {"so_12695943_12696029_5": {"length": 26, "quality": 0.9285714285714286, "section_id": 8725}, "so_12695943_12696029_3": {"length": 9, "quality": 0.9, "section_id": 7658}, "so_12695943_12696029_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 8725}, "so_12695943_12696029_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 8725}, "so_12695943_12696029_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 7643}}}, "12695943": {"ViewCount": "721", "Body": "<p>I've noticed that many C/C++ programmers implement sets of flags using something like the following:</p>\n<pre><code>#define FLAG_1 (1 &lt;&lt; 0)\n#define FLAG_2 (1 &lt;&lt; 1)\n#define FLAG_3 (1 &lt;&lt; 2)\n\nunsigned int my_flags = 0; /* no flag set */\nmy_flags |= FLAG_2; /* set flag 2 */\n</code></pre>\n<p>But is this approach actually sound?  It seems to me like it's making assumptions about the binary representation of unsigned ints that isn't part of the C/C++ language standard.  For example, that \"0\" is actually 0x0000.</p>\n<p>Am I wrong?  Or am I right in theory, but not in practice given currently standard hardware?</p>\n", "Title": "Are bit flags using ints in C/C++ actually safe?", "CreationDate": "2012-10-02T18:19:04.457", "LastActivityDate": "2012-12-22T18:58:17.473", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-02T18:24:41.443", "LastEditorUserId": "893", "Id": "12695943", "Score": "14", "OwnerUserId": "387887", "Tags": "<c++><c>", "AnswerCount": "4"}, "12695984": {"Id": "12695984", "PostTypeId": "2", "Body": "<p>The current C and C++ standards both limit unsigned integer representations to a pure binary representation, so what you have above is entirely safe and guaranteed to work.</p>\n", "LastActivityDate": "2012-10-02T18:21:32.887", "CommentCount": "11", "CreationDate": "2012-10-02T18:21:32.887", "ParentId": "12695943", "Score": "6", "OwnerUserId": "179910"}});