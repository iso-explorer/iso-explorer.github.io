post_cb({"27871269": {"ParentId": "27871124", "CommentCount": "20", "Body": "<p>The encoding of the source code file doesn't affect the behavior of <code>mbstowcs</code>. After all, the internal implementation of the function is unaware of what source code might be calling it.</p>\n<p>On the MSDN documentation you linked is:</p>\n<blockquote>\n<p id=\"so_27871124_27871269_0\">mbstowcs uses the current locale for any locale-dependent behavior; _mbstowcs_l is identical except that it uses the locale passed in instead. For more information, see <a href=\"http://msdn.microsoft.com/en-us/library/wyzd2bce.aspx\" rel=\"nofollow\">Locale</a>.</p>\n</blockquote>\n<p>That linked page about locales then references <a href=\"http://msdn.microsoft.com/en-us/library/x99tb11d.aspx\" rel=\"nofollow\">setlocale</a> which is how the behavior of <code>mbstowcs</code> can be affected.</p>\n<p>Now, taking a look at your proposed way of passing UTF-8:</p>\n<pre><code>mbstowcs (dest, u8\"Hello, world!\", 1024);\n</code></pre>\n<p>Unfortunately, that isn't going to work properly as far as I know once you use interesting data. If it even compiles, it only does do because the compiler would have to be treating <code>u8</code> the same as a <code>char*</code>. And as far as <code>mbstowcs</code> is concerned, it will believe the string is encoded under whatever the locale is set for.</p>\n<p>Even more unfortunately, I don't believe there's any way (on the Windows / Visual Studio platform) to set a locale such that UTF-8 would be used.</p>\n<p>So that would happen to work for ASCII characters (the first 128 characters) only because they happen to have the exact same binary values in various ANSI encodings as well as UTF-8. If you try with any characters beyond that (for instance anything with an accent or umlaut) then you'll see problems.</p>\n<hr>\n<p>Personally, I think <code>mbstowcs</code> and such are rather limited and clunky. I've found the Window's API function <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/dd319072%28v=vs.85%29.aspx\" rel=\"nofollow\">MultiByteToWideChar</a> to be more effective in general. In particular it can easily handle UTF-8 just by passing <code>CP_UTF8</code> for the code page parameter.</p>\n</hr>", "OwnerUserId": "126027", "PostTypeId": "2", "Id": "27871269", "Score": "3", "CreationDate": "2015-01-10T00:04:02.350", "LastActivityDate": "2015-01-10T00:04:02.350"}, "27871267": {"ParentId": "27871124", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>mbstowcs()</code> semantics are defined in terms of the currently installed C locale. If you are processing string with different encodings you will need to use <code>setlocale()</code> to change what encoding is currently being used. The relevant statement in the C standard is in 7.22.8 paragraph 1:</p>\n<blockquote>\n<p id=\"so_27871124_27871267_0\">The behavior of the multibyte string functions is affected by the <code>LC_CTYPE</code> category of\n  the current locale.</p>\n</blockquote>\n<p>I don't know enough about the C library but as far as I know none of these functions is really thread-safe. I consider it much easier to deal with different encodings and, in general, cultural conventions, using the C++ <code>std::locale</code> facilities. With respect to encoding conversions you'd look at the <code>std::codecvt&lt;...&gt;</code> facets. Admittedly, these aren't easy to use, though.</p>\n<p>The <em>current locale</em> needs a bit of clarification: the program has a current global locale. Initially, this locale is somehow set up by the system and is possibly controlled by the user's environment in some form. For example, on UNIX system there are environment variables which choose the initial locale. Once the program is running, it can change the current locale, however. How that is done depends a bit on what is being used exactly:  a running C++ program actually has two locales: one used by the C library and one used by the C++ library.</p>\n<p>The C locale is used for all locale dependent function from the C library, e.g., <code>mbstowcs()</code> but also for <code>tolower()</code> and <code>printf()</code>. The C++ locale is used for all locale dependent function which are specific to the C++ library. Since C++ uses locale objects the global locale is just used as the default for entities not setting a locale specifically, and primarily for the stream (you'd set a stream's locale using <code>s.imbue(loc)</code>). Depending on which locale you set, there are different methods to set the global locale:</p>\n<ol>\n<li>For the C locale you use <code>setlocale()</code>.</li>\n<li>For the C++ locale you use <code>std::locale::global()</code>.</li>\n</ol>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2015-01-10T00:21:11.813", "Id": "27871267", "Score": "1", "CreationDate": "2015-01-10T00:03:51.563", "LastActivityDate": "2015-01-10T00:21:11.813"}, "bq_ids": {"n4140": {"so_27871124_27871124_0": {"section_id": 6242, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_27871124_27871124_0": {"section_id": 6002, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_27871124_27871124_0": {"section_id": 7746, "quality": 0.5454545454545454, "length": 6}}}, "27871124": {"CommentCount": "18", "ViewCount": "2217", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-01-09T23:46:20.750", "LastActivityDate": "2015-01-10T20:13:15.190", "Title": "Does the multibyte-to-wide-string conversion function \"mbstowcs\", when passed a string literal, use the encoding of the source file?", "FavoriteCount": "2", "LastEditDate": "2017-05-23T12:00:24.320", "Id": "27871124", "Score": "2", "Body": "<p><strong>ADDENDUM</strong> A tentative answer of my own appears at the bottom of the question.</p>\n<hr>\n<p>I am converting an archaic VC6 C++/MFC project to VS2013 and Unicode, based on the recommendations <a href=\"http://utf8everywhere.org\" rel=\"nofollow noreferrer\">at utf8everywhere.org</a>.</p>\n<p>Along the way, I have been studying Unicode, UTF-16, UCS-2, UTF-8, the standard library and STL support of Unicode &amp; UTF-8 (or, rather, the standard library's lack of support), <a href=\"http://site.icu-project.org/\" rel=\"nofollow noreferrer\">ICU</a>, <a href=\"http://www.boost.org/doc/libs/1_57_0/libs/locale/doc/html/index.html\" rel=\"nofollow noreferrer\">Boost.Locale</a>, and of course the Windows SDK and MFC's API that requires UTF-16 <code>wchar</code>'s.</p>\n<p>As I have been studying the above issues, a question continues to recur that I have not been able to answer to my satisfaction in a clarified way.</p>\n<p>Consider the C library function <code>mbstowcs</code>.  This function has the following signature:</p>\n<pre><code>size_t mbstowcs (wchar_t* dest, const char* src, size_t max);\n</code></pre>\n<p>The second parameter <code>src</code> is (according to <a href=\"http://www.cplusplus.com/reference/cstdlib/mbstowcs/\" rel=\"nofollow noreferrer\">the documentation</a>) a</p>\n<blockquote>\n<p id=\"so_27871124_27871124_0\">C-string with the multibyte characters to be interpreted. The\n  multibyte sequence shall begin in the initial shift state.</p>\n</blockquote>\n<p>My question is in regards to this <strong>multibyte string</strong>.  It is my understanding that the <strong>encoding</strong> of a multibyte string can differ from string to string, and the encoding <strong>is not specified</strong> by the standard.  Nor does a particular encoding seem to be specified by the <a href=\"http://msdn.microsoft.com/en-us/library/k1f9b8cy.aspx\" rel=\"nofollow noreferrer\">MSVC documentation</a> for this function.</p>\n<p>My understanding at this point is that on Windows, this multibyte string is expected to be encoded with the ANSI code page of the active locale.  But my clarity begins to fade at this point.</p>\n<p><strong>I have been wondering whether the encoding of the source code file <em>itself</em> makes a difference in the behavior of <code>mbstowcs</code>, at least on Windows.</strong>  And, I'm also confused about what happens at <strong>compile time</strong> vs. what happens at <strong>run time</strong> for the code snippet above.</p>\n<p>Suppose you have a <strong>string literal</strong> passed to <code>mbstowcs</code>, like this:</p>\n<pre><code>wchar_t dest[1024];\nmbstowcs (dest, \"Hello, world!\", 1024);\n</code></pre>\n<p>Suppose this code is <strong>compiled</strong> on a Windows machine.  Suppose that the code page of the <strong>source code file itself</strong> is <em>different</em> than the code page of the current locale on the machine on which the <strong>compiler</strong> runs.  Will the compiler take into consideration the source code file's encoding?  Will the resulting binary be <em>effected</em> by the fact that the code page of the source code file is different than the code page of the active locale on which the compiler runs?</p>\n<p>On the other hand, maybe I have it wrong - maybe the active locale of the <strong>runtime machine</strong> determines the code page that is expected of the string literal.  Therefore, does the code page with which the <em>source code file</em> is saved need to <strong>match</strong> the code page of the computer on which the program ultimately <strong>runs</strong>?  That seems so whacked to me that I find it hard to believe this would be the case.  But as you can see, my clarity is lacking here.</p>\n<p>On the other hand, if we change the call to <code>mbstowcs</code> to explicitly pass a UTF-8 string:</p>\n<pre><code>wchar_t dest[1024];\nmbstowcs (dest, u8\"Hello, world!\", 1024);\n</code></pre>\n<p>... I assume that <code>mbstowcs</code> will always do the right thing - regardless of the code page of the source file, the current locale of the compiler, or the current locale of the computer on which the code runs.  Am I correct about this?</p>\n<p>I would appreciate clarity on these matters, in particular in regards to the specific questions I have raised above.  If any or all of my questions are ill-formed, I would appreciate knowing that, as well.</p>\n<hr>\n<p><strong>ADDENDUM</strong> From the lengthy comments beneath @TheUndeadFish's answer, and from <a href=\"https://stackoverflow.com/a/1866668/368896\">the answer to a question on a very similar topic here</a>, I <em>believe</em> I have a tentative answer to my own question that I'd like to propose.</p>\n<p>Let's follow the <strong>raw bytes</strong> of the source code file to see how the <em>actual bytes</em> are transformed through the entire process of compilation to runtime behavior:</p>\n<ul>\n<li><p>The C++ standard 'ostensibly' requires that all characters in any source code file be a (particular) 96-character subset of ASCII called the <code>basic source character set</code>.  (But see following bullet points.)</p>\n<p>In terms of the actual byte-level encoding of these 96 characters in the source code file, the standard does not specify any particular encoding, but all 96 characters are ASCII characters, so in practice, there is never a question about what encoding the source file is in, because all encodings in existence represent these 96 ASCII characters using the same raw bytes.</p></li>\n<li><p>However, <strong>character literals</strong> and <strong>code comments</strong> might commonly contain characters outside these basic 96.</p>\n<p>This is typically supported by the compiler (even though this isn't required by the C++ standard).  The source code's character set is called the <code>source character set</code>.  But the compiler needs to have these same characters available in its internal character set (called the <code>execution character set</code>), or else those missing characters will be replaced by some other (dummy) character (such as a square or a question mark) prior to the compiler actually processing the source code - see the discussion that follows.</p>\n<p>How the compiler determines the encoding that is used to encode the characters of the source code file (when characters appear that are outside the <code>basic source character set</code>) is implementation-defined.</p>\n<p>Note that it is possible for the compiler to use a <em>different</em> character set (encoded however it likes) for its internal <code>execution character set</code> than the character set represented by the encoding of the source code file!</p>\n<p>This means that even if the compiler knows about the encoding of the source code file (which implies that the compiler also knows about all the characters in the source code's character set), the compiler might still be forced to convert some characters in the source code's character set to <em>different</em> characters in the <code>execution character set</code> (thereby losing information).  The standard states that this is acceptable, but that the compiler must not convert any characters in the <code>source character set</code> to the NULL character in the <code>execution character set</code>.</p>\n<p>Nothing is said by the C++ standard about the <em>encoding</em> used for the <code>execution character set</code>, just as nothing is said about the <em>characters</em> that are required to be supported in the <code>execution character set</code> (other than the characters in the <code>basic execution character set</code>, which include all characters in the <code>basic source character set</code> plus a handful of additional ones such as the <code>NULL</code> character and the backspace character).</p>\n<p><strong>It is not really seemingly documented anywhere very clearly, even by Microsoft, how any of this process is handled in MSVC.</strong>  I.e., how the compiler figures out what the encoding and corresponding character set of the source code file is, and/or what the choice of <code>execution character set</code> is, and/or what the encoding is that will be used for the <code>execution character set</code> during compilation of the source code file.</p>\n<p>It seems that in the case of MSVC, the compiler will make a best-guess effort in its attempt to select an encoding (and corresponding character set) for any given source code file, falling back on the current locale's default code page of the machine the compiler is running on.  Or you can take special steps to save the source code files as Unicode using an editor that will provide the proper byte-order mark (BOM) at the beginning of each source code file.  This includes UTF-8, for which the BOM is typically optional or excluded - in the case of source code files read by the MSVC compiler, you <em>must</em> include the UTF-8 BOM.</p>\n<p>And in terms of the <code>execution character set</code> and its encoding for MSVC, continue on with the next bullet point.</p></li>\n<li><p>The compiler proceeds to read the source file and converts the raw bytes of the characters of the source code file from the encoding for the <code>source character set</code> into the (potentially different) encoding of the corresponding character in the <code>execution character set</code> (which will be the same character, if the given character is present in both character sets).</p>\n<p><strong>Ignoring code comments and character literals</strong>, all such characters are typically in the <code>basic execution character set</code> noted above.  This is a subset of the ASCII character set, so encoding issues are irrelevant (all of these characters are, in practice, encoded identically on all compilers).</p>\n<p>Regarding the <strong>code comments and character literals</strong>, though: the code comments are discarded, and if the character literals contain only characters in the <code>basic source character set</code>, then no problem - these characters will belong in the <code>basic execution character set</code> and still be ASCII.</p>\n<p>But if the character literals in the source code contain characters outside of the <code>basic source character set</code>, then these characters are, as noted above, converted to the <code>execution character set</code> (possibly with some loss).  But as noted, neither the characters, nor the encoding for this character set is defined by the C++ standard.  Again, the MSVC documentation seems to be very weak on what this encoding and character set will be.  Perhaps it is the default ANSI encoding indicated by the active locale on the machine on which the compiler runs?  Perhaps it is UTF-16?</p></li>\n<li><p>In any case, the raw bytes that will be burned into the executable for the character string literal correspond exactly to the compiler's encoding of the characters in the <code>execution character set</code>.</p></li>\n<li><p>At <strong>runtime</strong>, <code>mbstowcs</code> is called and it is passed the bytes from the previous bullet point, unchanged.</p>\n<p>It is now time for the C runtime library to interpret the bytes that are passed to <code>mbstowcs</code>.</p>\n<p><strong>Because no locale is provided with the call to <code>mbstowcs</code>, the C runtime has no idea what encoding to use when it receives these bytes - this is arguably the weakest link in this chain.</strong></p>\n<p>It is not documented by the C++ (or C) standard what encoding should be used to read the bytes passed to <code>mbstowcs</code>.  <strong>I am not sure if the standard states that the input to <code>mbstowcs</code> is expected to be in the same <code>execution character set</code> as the characters in the <code>execution character set</code> of the compiler, OR if the encoding is expected to be the same for the compiler as for the C runtime implementation of <code>mbstowcs</code></strong>.</p>\n<p>But my tentative guess is that in the MSVC C runtime, apparently the locale of the current <strong>running thread</strong> will be used to determine both the runtime <code>execution character set</code>, and the encoding representing this character set, that will be used to interpret the bytes passed to <code>mbstowcs</code>.</p>\n<p>This means that it will be very easy for these bytes to be mis-interpreted as different characters than were encoded in the source code file - very ugly, as far as I'm concerned.</p>\n<p>If I'm right about all this, then if you want to <strong>force</strong> the C runtime to use a particular encoding, you should call the Window SDK's <code>MultiByteToWideChar</code>, as @HarryJohnston's comment indicates, because you can pass the desired encoding to that function.</p></li>\n<li><p>Due to the above mess, there really isn't an <em>automatic</em> way to deal with character literals in source code files.</p>\n<p>Therefore, as <a href=\"https://stackoverflow.com/a/1866668/368896\">https://stackoverflow.com/a/1866668/368896</a> mentions, if there's a chance you'll have non-ASCII characters in your character literals, you should use <em>resources</em> (such as <code>GetText</code>'s method, which also works via <code>Boost.Locale</code> on Windows in conjunction with the <code>xgettext</code> .exe that ships with <a href=\"http://poedit.net/\" rel=\"nofollow noreferrer\">Poedit</a>), and in your source code, simply write functions to load the resources as raw (unchanged) bytes.</p>\n<p>Make sure to save your resource files as UTF-8, and then make sure to call functions at runtime that explicitly support UTF-8 for their <code>char *</code>'s and <code>std::string</code>'s, such as (from the recommendations at <a href=\"http://utf8everywhere.org\" rel=\"nofollow noreferrer\">utf8everywhere.org</a>) using <code>Boost.Nowide</code> (not really in Boost yet, I think) to convert from UTF-8 to <code>wchar_t</code> at the last possible moment prior to calling any Windows API functions that write text to dialog boxes, etc. (and using the <code>W</code> forms of these Windows API functions).  For console output, you must call the <code>SetConsoleOutputCP</code>-type functions, such as is also described at <a href=\"https://stackoverflow.com/a/1866668/368896\">https://stackoverflow.com/a/1866668/368896</a>.</p></li>\n</ul>\n<p>Thanks to those who took the time to read the lengthy proposed answer here.</p>\n</hr></hr>", "Tags": "<c++><windows><encoding><utf-8><visual-studio-2013>", "OwnerUserId": "368896", "AnswerCount": "2"}});