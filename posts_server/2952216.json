post_cb({"2952216": {"CommentCount": "6", "ViewCount": "416", "PostTypeId": "1", "LastEditorUserId": "252000", "CreationDate": "2010-06-01T18:21:50.847", "LastActivityDate": "2010-06-01T19:32:12.210", "Title": "delegating into private parts", "AcceptedAnswerId": "2952398", "LastEditDate": "2010-06-01T19:05:00.007", "Id": "2952216", "Score": "12", "Body": "<p>Sometimes, C++'s notion of privacy just baffles me :-)</p>\n<pre><code>class Foo\n{\n    struct Bar;\n    Bar* p;\n\npublic:\n\n    Bar* operator-&gt;() const\n    {\n        return p;\n    }\n};\n\nstruct Foo::Bar\n{\n    void baz()\n    {\n        std::cout &lt;&lt; \"inside baz\\n\";\n    }\n};\n\nint main()\n{\n    Foo::Bar b;   // error: 'struct Foo::Bar' is private within this context\n\n    Foo f;\n    f-&gt;baz();     // fine\n}\n</code></pre>\n<p>Since <code>Foo::Bar</code> is <code>private</code>, I cannot declare <code>b</code> in <code>main</code>. Yet I can call methods from <code>Foo::Bar</code> just fine. Why the hell is this allowed? Was that an accident or by design?</p>\n<hr>\n<p>Oh wait, it gets better:</p>\n<pre><code>Foo f;\nauto x = f.operator-&gt;();   // :-)\nx-&gt;baz();\n</code></pre>\n<p>Even though I am not allowed to name the type <code>Foo::Bar</code>, it works just fine with <code>auto</code>...</p>\n<hr>\n<p>Noah wrote:</p>\n<blockquote>\n<p id=\"so_2952216_2952216_0\">type names defined within a class definition cannot be used outside their class without qualification.</p>\n</blockquote>\n<p>Just for fun, here is how you can get at the type from outside:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nconst Foo some_foo();\n\ntypedef typename std::remove_pointer&lt;decltype( some_foo().operator-&gt;() )&gt;::type Foo_Bar;\n</code></pre>\n</hr></hr>", "Tags": "<c++><operator-overloading><private><delegation><pimpl-idiom>", "OwnerUserId": "252000", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2952216_2952216_0": {"section_id": 5933, "quality": 1.0, "length": 11}}, "n3337": {"so_2952216_2952216_0": {"section_id": 5705, "quality": 1.0, "length": 11}}, "n4659": {"so_2952216_2952216_0": {"section_id": 7403, "quality": 1.0, "length": 11}}}, "2952398": {"ParentId": "2952216", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Trying to find anything in the standard that would spell it out in detail but I can't.  The only thing I can find is 9.9:</p>\n<p><i>Type names obey exactly the same scope rules as other names.  In particular, type names defined within a class definition cannot be used outside their class without qualification.</i></p>\n<p>Essentially, the <em>name</em> of Foo::Bar is private to Foo, not the definition.  Thus you can use Bars outside of Foo, you just can't refer to them by type since that name is private.</p>\n<p>The name lookup rules for members would also seem to have some effect on this.  I don't see anything that specifically references \"nested class\" and thus they wouldn't be allowed to (if my lack of finding anything in fact is because it's not there).</p>\n", "OwnerUserId": "301883", "LastEditorUserId": "301883", "LastEditDate": "2010-06-01T18:57:37.363", "Id": "2952398", "Score": "6", "CreationDate": "2010-06-01T18:49:21.130", "LastActivityDate": "2010-06-01T18:57:37.363"}, "2952681": {"ParentId": "2952216", "CommentCount": "0", "Body": "<p>I think this is by design. You cannot explicitly create instance of <code>Foo::Bar</code> but it could be returned from member functions and then you could pass it to other member functions. This lets you to hide implementation details of your class.</p>\n", "OwnerUserId": "123111", "PostTypeId": "2", "Id": "2952681", "Score": "1", "CreationDate": "2010-06-01T19:32:12.210", "LastActivityDate": "2010-06-01T19:32:12.210"}, "2952420": {"ParentId": "2952216", "CommentCount": "3", "Body": "<p>I can't provide a full answer, but maybe a starting point. The C++ 1998 specification includes the following code example under <strong>paragraph 11.3 <code>[class.access]</code> (p. 175)</strong>:</p>\n<pre><code>class A\n{\n    class B { };\npublic:\n    typedef B BB;\n};\n\nvoid f()\n{\n    A::BB x;   // OK, typedef name A::BB is public\n    A::B y;    // access error, A::B is private\n}\n</code></pre>\n<p>In this example, a private type is \"published\" through a public <code>typedef</code>. Although it's not the same thing as publishing a type through a member function signature, it's similar.</p>\n", "OwnerUserId": "240733", "PostTypeId": "2", "Id": "2952420", "Score": "3", "CreationDate": "2010-06-01T18:53:10.620", "LastActivityDate": "2010-06-01T18:53:10.620"}});