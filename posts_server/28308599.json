post_cb({"bq_ids": {"n4140": {"so_28308599_28308748_1": {"length": 9, "quality": 1.0, "section_id": 603}, "so_28308599_28308748_0": {"length": 110, "quality": 0.9322033898305084, "section_id": 355}, "so_28308599_28309212_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 161}, "so_28308599_28309212_0": {"length": 60, "quality": 0.8823529411764706, "section_id": 321}, "so_28308599_28309212_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 603}}, "n3337": {"so_28308599_28308748_1": {"length": 9, "quality": 1.0, "section_id": 593}, "so_28308599_28309212_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 593}, "so_28308599_28309212_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 155}, "so_28308599_28309212_0": {"length": 60, "quality": 0.8823529411764706, "section_id": 311}, "so_28308599_28308748_0": {"length": 110, "quality": 0.9322033898305084, "section_id": 345}}, "n4659": {"so_28308599_28308748_1": {"length": 9, "quality": 1.0, "section_id": 629}, "so_28308599_28309212_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 629}, "so_28308599_28309212_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 165}, "so_28308599_28309212_0": {"length": 60, "quality": 0.8823529411764706, "section_id": 329}, "so_28308599_28308748_0": {"length": 110, "quality": 0.9322033898305084, "section_id": 365}}}, "28308599": {"ViewCount": "144", "Body": "<p>I have two template operators in class:</p>\n<pre><code>    template&lt;class T&gt;\n    size_t operator()(const T&amp; t) const {\n        static_assert(boost::is_pod&lt;T&gt;(), \"Not a POD type\");\n        return sizeof t;\n    }\n\n    template&lt;typename... T&gt;\n    size_t operator()(const boost::variant&lt;T...&gt;&amp; t) const\n    {\n        return boost::apply_visitor(boost::bind(*this, _1), t);\n    }\n</code></pre>\n<p>I pass <code>boost::variant&lt;some, pod, types, here&gt;</code> as an argument to these operators. GCC 4.8 and llvm 6.0 compile the code fine, choosing <code>boost::variant</code> parameterized operator. gcc 4.7 chooses <code>const T&amp; t</code> parameterized operator and thus fails to compile due to static assert.</p>\n<p>So, I have a question, what are the rules for choosing between these two?\nI think gcc 4.7 must have a bug, but I don't have any proof.</p>\n", "AcceptedAnswerId": "28308748", "Title": "What are the rules for choosing between a variadic template method and a usual template method?", "CreationDate": "2015-02-03T20:58:12.073", "Id": "28308599", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-02-03T21:59:31.817", "Score": "5", "OwnerUserId": "827880", "Tags": "<c++><templates><gcc><boost>", "AnswerCount": "2"}, "28309212": {"Id": "28309212", "PostTypeId": "2", "Body": "<p>The key section is in [temp.deduct.partial]:</p>\n<blockquote>\n<p id=\"so_28308599_28309212_0\">Two sets of types are used to determine the partial ordering. For each of the templates involved there is\n  the original function type and the transformed function type. [ Note: The creation of the transformed type\n  is described in 14.5.6.2. \u2014end note ] The deduction process uses the transformed type as the argument\n  template and the original type of the other template as the parameter template. This process is done twice\n  for each type involved in the partial ordering comparison: once using the transformed template-1 as the\n  argument template and template-2 as the parameter template and again using the transformed template-2\n  as the argument template and template-1 as the parameter template.</p>\n</blockquote>\n<p>That's really dense, even for the C++ standard, but what it basically means is this. Take our two overloads:</p>\n<pre><code>template &lt;class T&gt; // #1\nsize_t operator()(const T&amp; t) const\n\ntemplate &lt;typename... T&gt; // #2\nsize_t operator()(const boost::variant&lt;T...&gt;&amp; t)\n</code></pre>\n<p>And we're going to basically assign some unique type(s) to each one and try to see if the other applies. So let's pick some type <code>A</code>  for the <code>#1</code>, and <code>B,C,D</code> for <code>#2</code>. Does <code>operator()(const A&amp;)</code>  work for <code>#2</code>? No. Does <code>operator()(const boost::variant&lt;B,C,D&gt;&amp;)</code> work for <code>#1</code>? Yes. Thus, the partial ordering rules indicate <code>#2</code> is more specialized than <code>#1</code>. </p>\n<p>And so, from [temp.func.order]:</p>\n<blockquote>\n<p id=\"so_28308599_28309212_1\">The deduction process determines whether one of the templates is more specialized than the other. If\n  so, the more specialized template is the one chosen by the partial ordering process.</p>\n</blockquote>\n<p>And from [over.match.best]:</p>\n<blockquote>\n<p id=\"so_28308599_28309212_2\">[A] viable function <code>F1</code> is defined to be a better function than another viable function\n  <code>F2</code> if<br>\n  \u2014 [..]<br>\n  \u2014 <code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized\n  than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</br></br></p>\n</blockquote>\n<p>Thus, <code>#2</code> should be chosen in any case where it applies. If GCC chooses <code>#1</code>, that is nonconforming behavior and is a bug.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-02-03T21:43:07.547", "Score": "3", "CreationDate": "2015-02-03T21:35:06.517", "ParentId": "28308599", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2015-02-03T21:43:07.547"}, "28308748": {"Id": "28308748", "PostTypeId": "2", "Body": "<p>In general the compiler just treats all deduced template instantiations as potential overloads, picking the \"best viable function\" (\u00a7 13.3.3).</p>\n<p>Indeed this means GCC 4.7 has a bug then.</p>\n<p>See \u00a714.8.3: Overload resolution</p>\n<p>describes that all template instances will join in the set of candidates as any non-template declared overload:</p>\n<blockquote>\n<p id=\"so_28308599_28308748_0\">A function template can be overloaded either by (non-template) functions of its\n  name or by (other) function templates of the same name. When a call to that\n  name is written (explicitly, or implicitly using the operator notation),\n  template argument deduction (14.8.2) and checking of any explicit template\n  arguments (14.3) are performed for each function template to find the template\n  argument values (if any) that can be used with that function template to\n  instantiate a function template specialization that can be invoked with the\n  call arguments. For each function template, if the argument deduction and\n  checking succeeds, the template- arguments (deduced and/or explicit) are used\n  to synthesize the declaration of a single function template specialization\n  <strong>which is added to the candidate functions set to be used in overload\n  resolution</strong>. If, for a given function template, argument deduction fails, no\n  such function is added to the set of candidate functions for that template. <strong>The\n  complete set of candidate functions includes all the synthesized declarations</strong>\n  and all of the non-template overloaded functions of the same name. <strong>The\n  synthesized declarations are treated like any other functions in the remainder\n  of overload resolution</strong>, except as explicitly noted in 13.3.3.</p>\n</blockquote>\n<p>In the case of your question, the overloads end up being indistinguishable (<em>credit: @Piotr S</em>). In such cases \"partial ordering\" is applied (\u00a714.5.6.2):</p>\n<blockquote>\n<p id=\"so_28308599_28308748_1\">F1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2</p>\n</blockquote>\n<p>Note that things can get pretty tricky, when e.g. the \"open template\" version took a <code>T&amp;</code> instead of <code>T const&amp;</code> (non const references are preferred, all else being equal).</p>\n<p>When you had several overloads that end up having the same \"rank\" for overload resolution, the call is <em>ill-formed</em> and the compiler will diagnose an ambiguous function invocation.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-02-03T21:59:31.817", "Score": "0", "CreationDate": "2015-02-03T21:07:31.560", "ParentId": "28308599", "CommentCount": "5", "OwnerUserId": "85371", "LastEditDate": "2015-02-03T21:59:31.817"}});