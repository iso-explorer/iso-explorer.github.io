post_cb({"21940769": {"ViewCount": "90", "Body": "<p>I actually got the idea of this question when I was discussing on another question of mine (<a href=\"https://stackoverflow.com/questions/21932544/member-not-zeroed-a-clang-bug\">Member not zeroed, a clang++ bug?</a>).  That question is about C++11 value-initialization, but when I saw the C++03 value-initialization rule someone posted there, I am confused.</p>\n<p>The value-initialization rule from C++03 is:</p>\n<blockquote>\n<p id=\"so_21940769_21940769_0\">To value-initialize an object of type T means:</p>\n<ul>\n<li>if T is a class type (clause 9) with a user-declared constructor (12.1), then the default constructor for T is called (and the\n  initialization is ill-formed if T has no accessible default\n  constructor);</li>\n<li>if T is a non-union class type without a user-declared constructor, then every non-static data member and base-class component of T is\n  value-initialized;</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized</li>\n</ul>\n</blockquote>\n<p>Please look at the second bullet which defines the value-initialize process for a type without user-declared constructor.  This rule doesn't mention a constructor call.  As we can see from the description of other cases of value-initialize or from the description of default-initialize, if constructor should be called, it will be explicitly mentioned in the text of the standard.  I know there is certain initialization form that constructor doesn't get called (e.g. {}-initialization for aggregates), but should it be the case for value-initialize of <code>non-union class type without a user-declared constructor</code>?  The implicitly declared constructor of such a type could easily be non-trivial.  For example:</p>\n<pre><code>class A {\npublic:\n    virtual void f() {}\n};\n</code></pre>\n<p>According to the rule in C++03, if the implicitly declared non-trivial constructor doesn't get called in the process of the value-initialization of an object of <code>A</code>, how does the vptr of the object get setup?  (I know things related to vptr is all implementation-defined, but this doesn't change the major point I'm trying to make here.)</p>\n<p>(Someone would argue that the absence of mentioning a constructor call in the rule doesn't mean constructor won't get called.  OK.  Let's say constructor will get called according to some other rule I may have overlooked, but since all members need to be value-initialized anyway, wouldn't that cause the members' constructors to be called more than once?)</p>\n<p>Asking a question for C++03 when it's already C++11 everywhere may seem worthless.  Yeah, that's a valid point.  However, I think I could more or less learn something if I finally figure this out (whether I am wrong and why).</p>\n<p>EDIT: Maybe I shouldn't have used vptr as an example. My point is, wouldn't skipping the call to a non-trivial constructor cause some potential problem for the validity of the object?  After all, it's called non-trivial for a reason.</p>\n", "Title": "Certain case of value-initialization in C++03 doesn't call constructor?", "CreationDate": "2014-02-21T17:10:57.167", "LastActivityDate": "2014-02-21T17:46:57.223", "CommentCount": "2", "LastEditDate": "2017-05-23T12:14:19.830", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "21940769", "Score": "4", "OwnerUserId": "3237645", "Tags": "<c++><language-lawyer><c++03>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_21940769_21940769_0": {"length": 4, "quality": 1.0, "section_id": 3287}}, "n3337": {"so_21940769_21940769_0": {"length": 4, "quality": 1.0, "section_id": 3157}}}, "21941170": {"Id": "21941170", "PostTypeId": "2", "Body": "<p>When a class <code>X</code> has no user-provided constructor, its default constructor does exactly what a constructor of the form <code>X::X() {}</code> would (<code>C++03[class.ctor]\u00a76</code>). And as far as the standard is concerned, this is defined to perform default initialisation of all members and base class subobjects, <em>and nothing else.</em> So \"calling the <strong>generated</strong> default constructor\" is identical to \"default-initialising all data members and base class subobjects.\"</p>\n<p>So this actually does \"less\" than the value initialisation you quoted - as that value initialisation value-initialises all data members and base class subobjects. So it does all the constructor does, and more.</p>\n<p>As far as implementation-specific things (like the vtable pointer) go, these are outside of the scope of the standard. It is a compiler's responsibility to make sure all of its implementation-specific mechanisms work regardless of constructor calls mandated by the standard.</p>\n", "CommentCount": "4", "LastEditorUserId": "1782465", "LastActivityDate": "2014-02-21T17:46:57.223", "CreationDate": "2014-02-21T17:29:51.450", "ParentId": "21940769", "Score": "0", "OwnerUserId": "1782465", "LastEditDate": "2014-02-21T17:46:57.223"}, "21941043": {"PostTypeId": "2", "Body": "<p>As far as the Standard is concerned, the constructor is not responsible for setting up the vtable. There is nothing responsible for setting up the vtable; vtables don't exist, as far as the Standard is concerned.</p>\n<p>Rather, the vtable is a consequence of the <em>other</em> rules the compiler has to follow, relating to virtual function binding and such. So whether or not the constructor is called, the vtable's going to be set up <em>somewhere</em>, because otherwise the compiler will have trouble meeting its other obligations. That doesn't contradict the value-initialization rule; rather, it adds nuance to the practicalities of implementing the rule.</p>\n", "LastActivityDate": "2014-02-21T17:23:43.290", "Id": "21941043", "CommentCount": "4", "CreationDate": "2014-02-21T17:23:43.290", "ParentId": "21940769", "Score": "0", "OwnerUserId": "787480"}});