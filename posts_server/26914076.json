post_cb({"26930995": {"ParentId": "26914076", "CommentCount": "0", "Body": "<p>I don't know if it's too late to answer this, but your code compiles fine in GCC 4.9.2!</p>\n<pre><code>~$g++ -std=c++11 test.cpp \n~$./a.out \n99\nFinal: 99\n\n~$gcc --version\ngcc (GCC) 4.9.2\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n", "OwnerUserId": "2754510", "PostTypeId": "2", "Id": "26930995", "Score": "3", "CreationDate": "2014-11-14T13:22:22.423", "LastActivityDate": "2014-11-14T13:22:22.423"}, "bq_ids": {"n4140": {"so_26914076_36884406_1": {"section_id": 434, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_26914076_36884406_1": {"section_id": 426, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_26914076_36884406_1": {"section_id": 452, "quality": 0.9333333333333333, "length": 28}}}, "26914076": {"CommentCount": "4", "ViewCount": "663", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-11-13T16:49:32.203", "LastActivityDate": "2016-04-27T10:12:37.773", "Title": "Initialization list bug in gcc?", "FavoriteCount": "1", "LastEditDate": "2017-05-23T10:29:52.967", "Id": "26914076", "Score": "12", "Body": "<p>Consider the following code, where <code>B</code> is a virtual base class inherited by <code>D</code> through <code>B1</code> and <code>B2</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass B\n{\nprotected:\n    int x;\n\nprotected:\n\n    B(int x) : x{x}{std::cout &lt;&lt; x &lt;&lt; std::endl;}\n};\n\nclass B1 : virtual public B\n{\nprotected:\n\n    B1() : B(0){}\n};\n\nclass B2 : virtual public B\n{\nprotected:\n\n    B2() : B(10){}\n};\n\nclass D : public B1, public B2\n{\npublic:\n\n    D() : B(99), B1(), B2() {}\n    void print() {std::cout &lt;&lt; \"Final: \" &lt;&lt; x &lt;&lt; std::endl;}\n};\n\nint main() {\n    D d;\n    d.print();\n    return 0;\n}\n</code></pre>\n<p>See working example <a href=\"http://ideone.com/8BKK3t\" rel=\"nofollow noreferrer\">here</a>. I use outputs in <code>B</code>'s constructor and after <code>D</code> has been completely constructed to keep track of what's going on. Everything works fine, when I compile the above example with g++-4.8.1. It prints</p>\n<pre><code>99\nFinal: 99\n</code></pre>\n<p>because <code>B</code>s constructor is called once from the most derived class (<code>D</code>) and that also determines the final value of <code>x</code>.</p>\n<p>Now comes the strange part: If I change the line</p>\n<pre><code>D() : B(99), B1(), B2() {}\n</code></pre>\n<p>to the new uniform initialization syntax, i.e.</p>\n<pre><code>D() : B{99}, B1{}, B2{} {}\n</code></pre>\n<p>strange things happen. For one, it doesn't compile anymore, with the error</p>\n<pre><code>prog.cpp: In constructor \u2018D::D()\u2019:\nprog.cpp:17:5: error: \u2018B1::B1()\u2019 is protected\n     B1() : B(0){}\n     ^\nprog.cpp:31:27: error: within this context\n     D() : B{99}, B1{}, B2{} {}\n</code></pre>\n<p>(and the same for <code>B2</code>, see <a href=\"http://ideone.com/G5Ux5u\" rel=\"nofollow noreferrer\">here</a>) which doesn't make sense because I am using it in a derived class, so <code>protected</code> should be fine. If I correct for that and make the constructors of <code>B1</code> and <code>B2</code> public instead of protected, everything gets totally messed up (see <a href=\"http://ideone.com/hKCnWe\" rel=\"nofollow noreferrer\">here</a>), as the output becomes</p>\n<pre><code>99\n0\n10\nFinal: 10\n</code></pre>\n<p>So, in fact, the parts of <code>B1</code>s and <code>B2</code>s constructors that initialize <code>B</code> are still executed and even change the value of <code>x</code>. This should not be the case for virtual inheritance. And remember, the <em>only things I have changed</em> are</p>\n<ul>\n<li>public instead of protected constructors in <code>B1</code> and <code>B2</code></li>\n<li>use <code>classname{}</code> syntax in member initialization list of <code>D</code> instead of <code>classname()</code>.</li>\n</ul>\n<p>I cannot believe such a basic thing goes wrong in gcc. But I tested it with clang on my local machine and there, all three cases compile and run as intended (i.e. like the first example above). If it's not a bug, can someone please point me to what I am missing?</p>\n<p>EDIT: My first search somehow didn't bring it up, but now I found <a href=\"https://stackoverflow.com/questions/12313292/why-does-this-snippet-using-uniform-initialization-compile-with-g4-6-but-not-g?rq=1\">this other question</a>, showing at least the protected/public error. However, this was gcc-4.7, so I would have expected it to be dealt with in gcc-4.8. So, should I conclude initializer lists are just fundamentally messed up in gcc!?</p>\n", "Tags": "<c++><c++11><gcc><initializer-list>", "OwnerUserId": "3749537", "AnswerCount": "2"}, "36884406": {"ParentId": "26914076", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Regarding multiple calls of virtual base class constructor: I could reproduce the issue with the following code (with GCC 5.1.0).</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct V {\n    V(){std::cout &lt;&lt; \"V()\\n\";}\n};\n\nstruct A : virtual V {\n    A() : V{} {std::cout &lt;&lt; \"A()\\n\";}\n};\n\nstruct B : A {\n    B(): V{}, A{} {std::cout &lt;&lt; \"B()\\n\";}\n};\n\nint main(int argc, char **argv) {\n    B b{};\n}\n</code></pre>\n<p>This results in the following output:</p>\n<pre><code>V()\nV()\nA()\nB()\n</code></pre>\n<p>I don't think this is correct accoring to the C++ standard:</p>\n<blockquote>\n<p id=\"so_26914076_36884406_0\">[class.base.init]/7</p>\n<p id=\"so_26914076_36884406_1\">...\n  The initialization performed by each mem-initializer constitutes a full-expression. Any expression in a mem-initializer is evaluated as part of the full-expression that performs the initialization. A mem-initializer\n  where the mem-initializer-id denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.</p>\n</blockquote>\n<p>When the call of the A constructor is changed to use parenthesis instead of braces the resulting executable works as expected and only calls V() once.</p>\n<p>I've created a bug report for GCC regarding this issue: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70818\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70818</a></p>\n<p>Edit: I missed that there already has been a bug report about this: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55922\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55922</a></p>\n", "OwnerUserId": "3789351", "LastEditorUserId": "3789351", "LastEditDate": "2016-04-27T10:12:37.773", "Id": "36884406", "Score": "1", "CreationDate": "2016-04-27T08:31:47.847", "LastActivityDate": "2016-04-27T10:12:37.773"}});