post_cb({"29932110": {"Id": "29932110", "PostTypeId": "2", "Body": "<p>It is impossible to declare a function parameter of array type. In particular the C++ standard (\u00a78.3.5/5) specifies: </p>\n<blockquote>\n<p id=\"so_29931718_29932110_0\">After determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively.</p>\n</blockquote>\n<p>So, if you attempt to create a function taking a parameter with array type, that parameter will be \"adjusted\" by the compiler to become a pointer instead.</p>\n<p>Likewise, when/if you attempt to pass an array to a function, the what will actually be passed is the address of the first element of that array.</p>\n", "LastActivityDate": "2015-04-29T00:09:50.960", "CommentCount": "0", "CreationDate": "2015-04-29T00:09:50.960", "ParentId": "29931718", "Score": "2", "OwnerUserId": "179910"}, "bq_ids": {"n4140": {"so_29931718_29932110_0": {"length": 16, "quality": 1.0, "section_id": 3241}, "so_29931718_29931857_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 3296}}, "n3337": {"so_29931718_29932110_0": {"length": 16, "quality": 1.0, "section_id": 3114}, "so_29931718_29931857_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 3166}}, "n4659": {"so_29931718_29932110_0": {"length": 12, "quality": 0.75, "section_id": 3997}, "so_29931718_29931857_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 4058}}}, "29931718": {"ViewCount": "79", "Body": "<p>Is it possible to pass raw table to function by value? I believe that it's impossible, but I'm looking for official sources to confirm that.</p>\n<hr>\n<p>I know how to pass table by reference:</p>\n<pre><code>template&lt;typename T, size_t N, size_t M&gt;\nvoid first_example(T (&amp;table_in_function)[N][M]) {\n  //...\n }\n //...\nint a[50][20];\n//...\nfirst_example(a);\n</code></pre>\n<p>or by <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow\">std::array</a>, but as I sad, I'm looking for solution for raw tables. Simple idea, remove <code>&amp;</code>, is obviously wrong. Also I am not looking for something like:</p>\n<pre><code>template&lt;typename T, size_t N, size_t M&gt;\nvoid third_example(T (&amp;temp_ref)[N][M]) {\n  T local_table[N][M];\n  //...\n }\n</code></pre>\n<p>I accept solutions like magic code and meta-programming.</p>\n</hr>", "AcceptedAnswerId": "29932110", "Title": "Table pass by value", "CreationDate": "2015-04-28T23:31:28.470", "LastActivityDate": "2015-04-29T09:15:35.953", "CommentCount": "5", "LastEditDate": "2015-04-29T09:15:35.953", "PostTypeId": "1", "Tags": "<c++><c++14>", "Id": "29931718", "AnswerCount": "3", "Score": "1", "OwnerUserId": "2349936", "ClosedDate": "2015-04-29T11:58:04.357", "LastEditorUserId": "2349936"}, "29931857": {"Id": "29931857", "PostTypeId": "2", "Body": "<p>The canonical way to handle this <em>is</em> to use <code>std::array</code> (or an equivalent wrapper type).</p>\n<p>Beyond that, you are out of luck, because C++ bans direct copy-initialisation of arrays:</p>\n<blockquote>\n<p id=\"so_29931718_29931857_0\"><code>[C++11: 8.5/16]:</code> <em>[..]</em> The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being initialized and the <em>source type</em> is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</p>\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</li>\n<li>If the destination type is a reference type, see 8.5.3.</li>\n<li>If the destination type is an array of characters, an array of <code>char16_t</code>, an array of <code>char32_t</code>, or an array of <code>wchar_t</code>, and the initializer is a string literal, see 8.5.2.</li>\n<li>If the initializer is <code>()</code>, the object is value-initialized.</li>\n<li><strong>Otherwise, if the destination type is an array, the program is ill-formed.</strong>\n<em>[..]</em></li>\n</ul>\n</blockquote>\n<p>The only reason that you can appear to pass arrays directly into functions is, as you know, because their names actually decay to pointers (resulting in what I call pass-by-handle). Despite appearances in consequential usage syntax, this is functionally not any different for you than pass-by-reference.</p>\n<p>The above quote means that anything you could do to work around array name decay would only see you run into the more fundamental problem that arrays may not be directly copied.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-04-29T00:01:28.687", "Score": "2", "CreationDate": "2015-04-28T23:45:03.797", "ParentId": "29931718", "CommentCount": "5", "OwnerUserId": "560648", "LastEditDate": "2015-04-29T00:01:28.687"}, "29931763": {"Id": "29931763", "PostTypeId": "2", "Body": "<p>This is impossible. C-style arrays automatically decay to pointers when passed into a function.</p>\n<p>You'll have to explicitly copy the array.</p>\n", "LastActivityDate": "2015-04-28T23:35:50.297", "CommentCount": "0", "CreationDate": "2015-04-28T23:35:50.297", "ParentId": "29931718", "Score": "1", "OwnerUserId": "565635"}});