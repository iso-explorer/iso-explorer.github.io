post_cb({"25880625": {"ParentId": "25879865", "CommentCount": "0", "Body": "<p>In C++11, <code>std::function</code>'s constructor taking an arbitrary functor type is specified as (quoting N3337 \u00a720.8.11.2.1 [func.wrap.func.con]/p7):</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<p id=\"so_25879865_25880625_0\">7 <em>Requires</em>: <code>F</code> shall be <code>CopyConstructible</code>. <code>f</code> shall be <code>Callable</code> (20.8.11.2) for argument types <code>ArgTypes</code> and return type <code>R</code>. The\n  copy constructor and destructor of <code>A</code> shall not throw exceptions.</p>\n</blockquote>\n<p>Violation of a <em>Requires</em> clause (passing an <code>f</code> not <code>Callable</code> for argument types <code>ArgTypes</code> and return type <code>R</code>) is undefined behavior, so the library is free to do whatever it wants in that case. The library may take the constructor out of overload resolution, but it doesn't have to, and if it doesn't, then you will have issues with overload resolution and <code>std::is_convertible</code>- it will report that pretty much everything under the sun is convertible to <code>std::function</code> (including stuff like <code>double</code>!).</p>\n<p>Hence, in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2132\" rel=\"nofollow\">LWG issue 2132</a>, the standard was modified to require implementations to remove these constructors from overload resolution (via SFINAE or a similar technique) if the functor isn't <code>Callable</code> for the specified argument types and return type. It now reads:</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<p id=\"so_25879865_25880625_1\">7 <em>Requires</em>: <code>F</code> shall be <code>CopyConstructible</code>.</p>\n<p id=\"so_25879865_25880625_2\">8 <em>Remarks</em>: These constructors shall not participate in overload\n  resolution unless <code>f</code> is <code>Callable</code> (20.9.11.2) for argument types\n  <code>ArgTypes...</code> and return type <code>R</code>.</p>\n</blockquote>\n<p>So if your standard library implements this resolution, then <code>std::is_convertible&lt;std::function&lt;void(int)&gt;, std::function&lt;void()&gt;&gt;::value</code> is <code>false</code>. Otherwise, it's implementation-dependent.</p>\n<blockquote>\n<p id=\"so_25879865_25880625_3\">I would assume that when these functions return true, the conversion can be made. Or am I missing something?</p>\n</blockquote>\n<p>Type traits such as <code>std::is_convertible</code>, <code>std::is_constructible</code>, or <code>std::is_assignable</code> only considers the immediate context - i.e., whether there's a matching function signature that's accessible and not deleted. They don't check if the function's body would compile when instantiated.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25880625", "Score": "4", "CreationDate": "2014-09-17T00:50:52.713", "LastActivityDate": "2014-09-17T00:50:52.713"}, "25879865": {"CommentCount": "1", "ViewCount": "526", "PostTypeId": "1", "LastEditorUserId": "149392", "CreationDate": "2014-09-16T23:18:02.457", "LastActivityDate": "2014-09-17T00:50:52.713", "Title": "std::is_convertible inconsistant with std::function", "AcceptedAnswerId": "25880625", "LastEditDate": "2014-09-16T23:20:36.033", "Id": "25879865", "Score": "5", "Body": "<p>I noticed some strange results with std::is_convertible and std::is_assignable when std::function object and std::bind are involved.</p>\n<p>I would assume that when these functions return true, the conversion can be made. Or am I missing something?</p>\n<p>The following code prints different results on different compilers, and I would expect it to print 0 since these types cannot be assigned.</p>\n<pre><code>#include &lt;type_traits&gt; \n#include &lt;functional&gt; \n#include &lt;iostream&gt; \n\nint main()\n{\n    std::cout &lt;&lt; std::is_convertible&lt;std::function&lt;void(int)&gt;, std::function&lt;void()&gt;&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It prints 0 on the following compilers:</p>\n<ul>\n<li>gcc 4.8 and gcc 4.9</li>\n<li>clang 3.4 (but not the one from ubuntu 12.04)</li>\n</ul>\n<p>It prints 1 on the following compilers:</p>\n<ul>\n<li>gcc 4.7</li>\n<li>VC++12 (VS2013)</li>\n<li>clang 3.2</li>\n</ul>\n<p>Is there any correct answer?\nAre these bugs in compilers or am I messing with stuff that is compiler specific?</p>\n", "Tags": "<c++><gcc><c++11><std>", "OwnerUserId": "3161376", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25879865_25880625_2": {"section_id": 4660, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_25879865_25880625_0": {"section_id": 4470, "quality": 0.8, "length": 12}}, "n4659": {"so_25879865_25880625_2": {"section_id": 6030, "quality": 0.6153846153846154, "length": 8}}}});