post_cb({"30272152": {"Id": "30272152", "PostTypeId": "2", "Body": "<p>Reliance of a program on <code>malloc()</code> can occur in both C and C++, even if the program doesn't directly use them.   It is a quality of implementation matter for the compiler and standard library rather than a requirement by the standards.</p>\n<p>This really depends on how the both the compiler startup code (code that sets things up so <code>main()</code> can be called) works and how standard library code is implemented.</p>\n<p>In both C and C++, for example, startup code (in hosted environments) needs to collect information about command line arguments (possibly copy to some allocated buffer), connect to standard files/streams (like <code>std::cout</code> and <code>std::cin</code>  in C++, and `stdout and stdin in C).  Any of these things can involve dynamic memory allocation (e.g. for buffers associated with standard streams) or execute code that is not actually needed by the program.</p>\n", "LastActivityDate": "2015-05-16T05:26:59.447", "CommentCount": "0", "CreationDate": "2015-05-16T05:26:59.447", "ParentId": "30271822", "Score": "4", "OwnerUserId": "4706785"}, "30271877": {"Id": "30271877", "PostTypeId": "2", "Body": "<p>It will always need malloc. Because the binary has to be loaded and also the shared libraries.</p>\n", "LastActivityDate": "2015-05-16T04:36:24.250", "CommentCount": "2", "CreationDate": "2015-05-16T04:36:24.250", "ParentId": "30271822", "Score": "-1", "OwnerUserId": "1898070"}, "30271849": {"Id": "30271849", "PostTypeId": "2", "Body": "<p>If you use any <code>STL</code> like <code>std::lib</code> or <code>std::map</code>. Or even <code>std::cout</code>, there will be dynamic memory allocations behind the scene.</p>\n", "LastActivityDate": "2015-05-16T04:29:26.223", "CommentCount": "0", "CreationDate": "2015-05-16T04:29:26.223", "ParentId": "30271822", "Score": "0", "OwnerUserId": "2797746"}, "bq_ids": {"n4140": {"so_30271822_30275587_2": {"length": 9, "quality": 0.75, "section_id": 6265}, "so_30271822_30275587_3": {"length": 12, "quality": 0.8, "section_id": 6266}, "so_30271822_30275587_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 7145}, "so_30271822_30275587_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 6264}}, "n3337": {"so_30271822_30275587_2": {"length": 9, "quality": 0.75, "section_id": 6025}, "so_30271822_30275587_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 6024}, "so_30271822_30275587_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6889}, "so_30271822_30275587_3": {"length": 12, "quality": 0.8, "section_id": 6026}}, "n4659": {"so_30271822_30275587_2": {"length": 9, "quality": 0.75, "section_id": 7771}, "so_30271822_30275587_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 7770}, "so_30271822_30275587_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 8646}, "so_30271822_30275587_3": {"length": 12, "quality": 0.8, "section_id": 7772}}}, "30275587": {"Id": "30275587", "PostTypeId": "2", "Body": "<p>C++ has two kinds of implementations, hosted and freestanding. Hosted implementations do assume that <code>malloc</code> is present and often do use it for internal purposes. Freestanding implementations assume that only the <code>new</code> function is present, because it supports the C++ keyword <code>new</code>, but it is easy to ensure that this function doesn't get called.</p>\n<p>The difference between the two is that in a freestanding implementation, you can control program startup and the set of required headers and libraries is limited. Program startup is controlled by setting the entry point.</p>\n<pre><code>g++ -ffreestanding -e _entry program.cpp\n</code></pre>\n<p><code>program.cpp</code> might be:</p>\n<pre><code>extern \"C\" int entry()\n{\n    return 0;\n}\n</code></pre>\n<p>The <code>extern \"C\"</code> is necessary to prevent C++ name mangling, which might make it difficult to figure out what the name of <code>entry</code> is during linking. Then, don't use <code>new</code>, <code>std::string</code>, stream I/O, STL, or the like, and avoid <code>at_exit</code>.</p>\n<p>This should give you control over the startup and cleanup code and limit what the compiler can implicitly rely on being available from the standard library. Note, however, that this can be a challenging environment. Not only will you prevent initialization of heaps, I/O streams, and the like, but you will also prevent setup of exceptions, RTTI, and the calling of static storage object constructors, among other things. You will have to write code or use libraries to manually opt into several features of C++ you might want to use. If you go this route, you may want to peruse this wiki <a href=\"http://wiki.osdev.org/C%2B%2B\" rel=\"nofollow\">http://wiki.osdev.org/C%2B%2B</a>. You may want to at least call global constructors, which is pretty easy to do.</p>\n<h2>Explanation</h2>\n<p><strong>The standard</strong></p>\n<p>C++ has the notion of a \"freestanding implementation\", in which fewer headers are available.</p>\n<p>3.6.1 Main function [basic.start.main]</p>\n<blockquote>\n<p id=\"so_30271822_30275587_0\">1 [snip] It is implementation-defined whether a program in a freestanding environment is required to define a main function.</p>\n</blockquote>\n<p>17.6.1.3 Freestanding implementations [compliance]</p>\n<blockquote>\n<p id=\"so_30271822_30275587_1\">1 Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this\n  International Standard describes the set of available headers.</p>\n<p id=\"so_30271822_30275587_2\">2 A freestanding implementation has an implementation-defined set of headers. This set shall include at least\n  the headers shown in Table 16.</p>\n<p id=\"so_30271822_30275587_3\">3 The supplied version of the header &lt;cstdlib&gt; shall declare at least the functions abort, atexit, at_quick_exit, exit, and quick_exit (18.5). [snip]</p>\n</blockquote>\n<p>Table 16 lists <code>ciso646</code>, <code>cstddef</code>, <code>cfloat</code>, <code>limits</code>, <code>climits</code>, <code>cstdint</code>, <code>cstdlib</code>, <code>new</code>, <code>typeinfo</code>, <code>exception</code>, <code>initializer_list</code>, <code>cstdalign</code>, <code>cstdarg</code>, <code>cstdbool</code>, <code>type_traits</code>, and <code>atomic</code>.</p>\n<p>Most of the above headers contain simple definitions of types, constants, and templates. The only ones that may seem problematic are <code>typeinfo</code>, <code>exception</code>, <code>cstdlib</code>, and <code>new</code>. The first two support RTTI and exceptions, respectively, which you can ensure are disabled with additional compiler flags. <code>cstdlib</code> and <code>new</code> you can simply ignore by not calling <code>exit</code>/<code>at_exit</code> and not using <code>new</code> expressions. The reason for avoiding <code>at_exit</code> is it might call <code>new</code> internally. Nothing else in the freestanding fragment should call call anything in <code>cstdlib</code> or <code>new</code>.</p>\n<p><strong>The options</strong></p>\n<p>The most important option above is <code>-e _entry</code>, which gives you control over what runs when your program starts.</p>\n<p><code>-ffreestanding</code> tells the compiler and the standard library (rather, its freestanding fragment) not to assume that the entire standard library is present (even if it still is). It may prevent the generation of surprising code. Note that this option doesn't actually restrict which headers are available to <em>you</em>. You can still use <code>iostream</code>, for instance, though it may be a bad idea if you also changed the entry point. What it does is it prevents the code supporting the <em>freestanding</em> headers from calling anything outside the <em>freestanding</em> headers, and prevents the compiler from generating any such calls implicitly.</p>\n", "LastActivityDate": "2015-05-16T12:18:10.593", "CommentCount": "0", "CreationDate": "2015-05-16T12:18:10.593", "ParentId": "30271822", "Score": "2", "OwnerUserId": "2482998"}, "30271822": {"ViewCount": "219", "Body": "<p>I have a C++ application running bare-metal that I want to make as small as possible.</p>\n<p>I am not using dynamic memory allocation anywhere.  I am using no STL functions.  I've also overridden all the varieties of \"delete\" and \"new\" with empty functions.  Nonetheless, when I look at a sorted list of symbols I see that malloc() is still one of the largest items in my compiled binary.  I could shrink my binary by about 25% if I could get rid of it.</p>\n<p><strong>Do C++ runtimes generally require malloc() for behind-the-scenes type work?</strong></p>\n<p>(I'm using Xilinx's fork of gcc for the Microblaze architecture, if that matters)</p>\n", "AcceptedAnswerId": "30272152", "Title": "Does C++ runtime always require malloc()?", "CreationDate": "2015-05-16T04:25:16.627", "Id": "30271822", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-05-16T12:18:10.593", "Score": "4", "OwnerUserId": "4883383", "Tags": "<c++><malloc><xilinx><standard-library><bare-metal>", "AnswerCount": "4"}});