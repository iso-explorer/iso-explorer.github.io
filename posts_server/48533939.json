post_cb({"bq_ids": {"n4140": {"so_48533939_48534097_0": {"length": 49, "quality": 0.9423076923076923, "section_id": 7193}, "so_48533939_48534097_2": {"length": 10, "quality": 1.0, "section_id": 7193}}, "n3337": {"so_48533939_48534097_0": {"length": 46, "quality": 0.8846153846153846, "section_id": 6937}, "so_48533939_48534097_2": {"length": 10, "quality": 1.0, "section_id": 6937}}, "n4659": {"so_48533939_48534097_0": {"length": 51, "quality": 0.9807692307692307, "section_id": 8702}, "so_48533939_48534097_2": {"length": 10, "quality": 1.0, "section_id": 8702}}}, "48534138": {"Id": "48534138", "PostTypeId": "2", "Body": "<p>No, you should not try to protect against abusing the code. The power of C++ lets abuses like this be possible, but you have to trust (and document) that the intended use is obeyed.</p>\n<p>Are we going to go around putting up 12-foot-high fences around all of our bridges to deter and protect jumpers (at high costs), or should we just use the efficient and normal guardrail and trust that everyone will adhere to the intended and reasonable use case?</p>\n", "LastActivityDate": "2018-01-31T03:46:41.480", "CommentCount": "1", "CreationDate": "2018-01-31T03:46:41.480", "ParentId": "48533939", "Score": "0", "OwnerUserId": "2096824"}, "48534097": {"Id": "48534097", "PostTypeId": "2", "Body": "<p>Well, it's not actually possible to do that. Or at least, not without <em>significant</em> pain.</p>\n<p>See, after the destructor of a class has finished executing, all of its subobjects stop existing. So the moment the second call of your destructor tries to access any of its subobjects, you invoke UB.</p>\n<p>So if you're going to be double-destruction safe, you would need to store state outside of the class to be able to tell if a particular instance was destroyed. And since you can have any number of instances of a class, the only way to handle this is to have the constructor allocate some memory and register the <code>this</code> pointer with something, which the destructor can check with.</p>\n<p>And this has to happen for every instance of every double-destruction safe subobject of that object. That's a <em>huge</em> amount of overhead, all to stop something that shouldn't be happening.</p>\n<hr>\n<p>And as Raymond Chen pointed out, merely the <em>act</em> of invoking double-destruction on any non-trivially-destructible type is undefined behavior.</p>\n<p>[basic.life]/1 tells us that an object with a non-trivial destructor has its lifetime ended when the destructor is called. And [basic.life]/6 tells us:</p>\n<blockquote>\n<p id=\"so_48533939_48534097_0\">Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that represents the address of the storage location where the object will be or was located may be used but only in limited ways. [...] Indirection through such a pointer is permitted but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:</p>\n<p id=\"so_48533939_48534097_1\">...</p>\n<p id=\"so_48533939_48534097_2\">the pointer is used to access a non-static data member or call a non-static member function of the object, or </p>\n</blockquote>\n<p>A destructor is a \"non-static member function of the object\". So in fact, it is impossible to make a C++ type double-destruction safe.</p>\n</hr>", "LastEditorUserId": "734069", "LastActivityDate": "2018-01-31T03:49:51.000", "Score": "2", "CreationDate": "2018-01-31T03:41:44.463", "ParentId": "48533939", "CommentCount": "5", "OwnerUserId": "734069", "LastEditDate": "2018-01-31T03:49:51.000"}, "48533939": {"ViewCount": "84", "Body": "<p>I have a situation in which an allocator for a container concurrently accessed needs to call both placement new and the destructor.</p>\n<pre><code>    template&lt; class U &gt; void destroy(U* p){\n            p-&gt;~U();\n    }\n</code></pre>\n<p>as it is I can end up calling the destruction repeatedly.\nThis brought me to think whether something like this should be OK.</p>\n<pre><code>   std::vector&lt;int&gt;* p = (std::vector&lt;int&gt;*)malloc(sizeof(std::vector&lt;int&gt;));\n   ::new (*p) std::vector&lt;int&gt;(30);\n   (*p)[10] = 5;\n   p-&gt;~std::vector&lt;int&gt;();\n   p-&gt;~std::vector&lt;int&gt;();\n   free(p);\n</code></pre>\n<p>I think this will work as long as the destruction of <code>std::vector</code> sets the data pointer to null or size to zero and when called again there is not a double free.</p>\n<p><strong>So, should classes be made such that accidental (or benign) double destruction should be equivalent to a single destruction?</strong></p>\n<p>In other words, should destruction be for example an idempotent operation?</p>\n<p>(Note for simplicity that the destructor is not virtual in this example)</p>\n<p>I find the question is similar to the problem of how to allow a moved class to be destructed later. </p>\n<hr>\n<p>Some answers put runtime cost to make the case against supporting double destruction. \nThere are costs, but they are similar to the cost of moving objects.\nIn other words, if it is cheap to move, it is cheap to allow double destruction (if DD is not UB in the first place for other reasons, such as the standard).</p>\n<p>To be specific:</p>\n<pre><code>class dummyvector{\n   int* ptr;\n   public:\n   dummyvector() : ptr(new int[10]){}\n   dummyvector(dummyvector const&amp; other) = delete; // for simplicity\n   dummyvector(dummyvector&amp;&amp; other) : ptr(other.ptr){\n      other.ptr = nullptr; // this makes the moved object unusable (e.g. set) but still destructable \n   }\n   dummyvector&amp; operator=(dummyvector const&amp;) = delete; // for simplicity\n   void set(int val){for(int i = 0; i != 10; ++i) ptr[i]=val;}\n   int sum(){int ret = 0; for(int i = 0; i != 10; ++i) ret += ptr[i]; return ret;}\n   ~dummyvector(){\n      delete[] ptr;\n      ptr = nullptr; // this is the only extra cost for allowing double free (if it was not UB)\n      // ^^ this line commented would be fine in general but not for double free (not even in principle)\n   }\n};\n</code></pre>\n</hr>", "AcceptedAnswerId": "48534033", "Title": "Should classes be resilient to double destroy?", "CreationDate": "2018-01-31T03:23:39.120", "LastActivityDate": "2018-02-05T18:15:29.790", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2018-02-05T18:15:29.790", "LastEditorUserId": "225186", "Id": "48533939", "Score": "1", "OwnerUserId": "225186", "Tags": "<c++><destructor>", "AnswerCount": "3"}, "48534033": {"Id": "48534033", "PostTypeId": "2", "Body": "<p>Given that destruction implies the end of the object's lifetime, handling double-destruction is paying a cost (the additional work to leave the memory in a redestructable state) for a benefit no well-formed code should ever encounter.</p>\n<p>Saying double-destruction is okay is equivalent to saying use-after-free is fine; sure, an allocator that allows it in specific circumstances might keep buggy code working, but that doesn't mean it's a feature worth preserving in the allocator if it prevents the allocator from working efficiently and correctly in non-pathological cases.</p>\n<p>If you're ever in a position where double destruction is a possibility, you're probably in a position where use-after-destruction is possible, and now you've got to make every operation on your class check for and \"handle\" (whatever that means) the possibility of being called on a destroyed instance. You've compromised normal operations to allow for misuse, and that's a terrible road to start down.</p>\n<p>Short version: Don't protect against double-destruction; the moment you're double destroyed, the code in question was entering undefined behavior territory anyway, and it's not your job to handle it. Write code that doesn't do terrible things in the first place.</p>\n", "LastActivityDate": "2018-01-31T03:33:47.480", "CommentCount": "11", "CreationDate": "2018-01-31T03:33:47.480", "ParentId": "48533939", "Score": "6", "OwnerUserId": "364696"}});