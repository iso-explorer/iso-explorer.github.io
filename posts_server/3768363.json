post_cb({"3768363": {"CommentCount": "0", "CreationDate": "2010-09-22T10:33:21.790", "PostTypeId": "1", "AcceptedAnswerId": "4248640", "LastEditorUserId": "1848654", "LastActivityDate": "2017-02-26T18:11:24.993", "LastEditDate": "2017-02-26T18:11:24.993", "ViewCount": "3177", "FavoriteCount": "4", "Title": "Character sets - Not clear", "Id": "3768363", "Score": "10", "Body": "<p>The standard defines</p>\n<ul>\n<li><p>basic source character set</p></li>\n<li><p>basic execution character set and its wide char counterpart</p></li>\n</ul>\n<p>It also defines 'execution character set' and its wide char counterpart as follows</p>\n<blockquote>\n<p id=\"so_3768363_3768363_0\">$2.2/3- \"The execution character set\n  and the execution wide-character set\n  are supersets of the basic execution\n  character set and the basic execution\n  wide-character set, respectively. The\n  values of the members of the execution\n  character sets are\n  implementation-defined, and any\n  additional members are\n  locale-specific.\"</p>\n</blockquote>\n<p>Q1. I don't think I understand this completely, particularly the last statement. Any pointers on this aspect?</p>\n<p>Further,</p>\n<blockquote>\n<p id=\"so_3768363_3768363_1\">$3.9.1 - \"Objects declared as\n  characters (char) shall be large\n  enough to store any member of the\n  implementation\u2019s basic character set.\"</p>\n</blockquote>\n<p>Q2. In 3.9.1 the phrase 'basic character set' means 'basic execution character set'?</p>\n", "Tags": "<c++><character-encoding>", "OwnerUserId": "418110", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_3768363_4248640_1": {"section_id": 5316, "quality": 0.8421052631578947, "length": 32}, "so_3768363_3768363_0": {"section_id": 5316, "quality": 0.8571428571428571, "length": 24}, "so_3768363_3768363_1": {"section_id": 7210, "quality": 0.9230769230769231, "length": 12}, "so_3768363_4248640_3": {"section_id": 5768, "quality": 0.8333333333333334, "length": 20}, "so_3768363_4248640_0": {"section_id": 551, "quality": 0.625, "length": 5}, "so_3768363_4248640_2": {"section_id": 5313, "quality": 0.75, "length": 15}}, "n3337": {"so_3768363_4248640_1": {"section_id": 5113, "quality": 0.8421052631578947, "length": 32}, "so_3768363_3768363_0": {"section_id": 5113, "quality": 0.8571428571428571, "length": 24}, "so_3768363_3768363_1": {"section_id": 6954, "quality": 0.9230769230769231, "length": 12}, "so_3768363_4248640_3": {"section_id": 5541, "quality": 0.8333333333333334, "length": 20}, "so_3768363_4248640_0": {"section_id": 542, "quality": 0.625, "length": 5}, "so_3768363_4248640_2": {"section_id": 5110, "quality": 0.75, "length": 15}}, "n4659": {"so_3768363_4248640_1": {"section_id": 6740, "quality": 0.631578947368421, "length": 24}, "so_3768363_3768363_0": {"section_id": 6740, "quality": 0.8214285714285714, "length": 23}, "so_3768363_3768363_1": {"section_id": 8719, "quality": 0.9230769230769231, "length": 12}, "so_3768363_4248640_3": {"section_id": 7225, "quality": 0.8333333333333334, "length": 20}, "so_3768363_4248640_0": {"section_id": 572, "quality": 0.625, "length": 5}, "so_3768363_4248640_2": {"section_id": 6737, "quality": 0.75, "length": 15}}}, "4248640": {"ParentId": "3768363", "CommentCount": "2", "Body": "<p>You need do distinguish between the source character set, the execution character set, the wire execution character set and it's basic versions:</p>\n<p><strong>The basic source character set:</strong></p>\n<blockquote>\n<p id=\"so_3768363_4248640_0\">\u00a72.1.1: The basic source character set consists of 96 characters [\u2026]</p>\n</blockquote>\n<p>This character set has exactly 96 characters. They fit into 7 bit. Characters like <code>@</code> are not included.</p>\n<p>Let's get some example binary representations for a few basic source characters. They can be completely arbitrary and there is no need these correspond to ASCII values.</p>\n<pre><code>A -&gt; 0000000\nB -&gt; 0100100\nC -&gt; 0011101\n</code></pre>\n<p><strong>The basic execution character set \u2026</strong></p>\n<blockquote>\n<p id=\"so_3768363_4248640_1\">\u00a72.1.3: The basic execution character set and the basic execution wide-character set shall each contain all the members of the basic source character set, plus control characters representing alert, backspace, and carriage return, plus a null character (respectively, null wide character), whose representation has all zero bits.</p>\n</blockquote>\n<p>As stated the basic execution character set contains all members of basic source character set. It still doesn't include any other character like <code>@</code>. The basic execution character set can have a different binary representation.</p>\n<p>As stated the basic execution character set contains representations for carriage return, a null character and other characters.</p>\n<pre><code>A          -&gt; 10110101010\nB          -&gt; 00001000101    &lt;- basic source character set\nC          -&gt; 10101011111\n----------------------------------------------------------\nnull       -&gt; 00000000000\nBackspace  -&gt; 11111100011\n</code></pre>\n<p>If the basic execution character set is 11 bits long (like in this example) the char data type shall be large enough to store 11 bits but it may be longer.</p>\n<p><strong>\u2026 and The basic execution wide character set:</strong></p>\n<p>The basic execution wide character is used for wide characters (wchar_t). It basicallly the same as the basic execution wide character set but can have different binary representations as well.</p>\n<pre><code>A          -&gt; 1011010101010110101010\nB          -&gt; 0000100010110101011111    &lt;- basic source character set\nC          -&gt; 1010100101101000011011\n---------------------------------------------------------------------\nnull       -&gt; 0000000000000000000000\nBackspace  -&gt; 1111110001100000000001\n</code></pre>\n<p>The only fixed member is the null character which needs to be a sequence of <code>0</code> bits.</p>\n<p><strong>Converting between basic character sets:</strong></p>\n<blockquote>\n<p id=\"so_3768363_4248640_2\">\u00a72.1.1.5: Each source character set member, escape sequence, or universal-character-name in character literals and string literals is converted to a member of the execution character set (2.13.2, 2.13.4).</p>\n</blockquote>\n<p>Then a c++ source file is compiled each character of the source character set is converted into the basic execution (wide) character set.</p>\n<p>Example:</p>\n<pre><code>const char* string0   =  \"BA\\bC\";\nconst wchar_t string1 = L\"BA\\bC\";\n</code></pre>\n<p>Since <code>string0</code> is a normal character it will be converted to the basic execution character set and <code>string1</code> will be converted to the basic execution wide character set.</p>\n<pre><code>string0 -&gt; 00001000101 10110101010 11111100011 10101011111\nstring1 -&gt; 0000100010110101011111 1011010101010110101010    // continued\n           1111110001100000000001 1010100101101000011011\n</code></pre>\n<p><strong>Something about file encodings:</strong></p>\n<p>There are several kind of file encodings. For example <a href=\"http://en.wikipedia.org/wiki/ASCII\" rel=\"noreferrer\"><code>ASCII</code></a> which is 7 bit long. <a href=\"http://en.wikipedia.org/wiki/Windows-1252\" rel=\"noreferrer\"><code>Windows-1252</code></a> which is 8 bit long (known as <code>ANSI</code>).\n<code>ASCII</code> doesn't contain non-English characters. <code>ANSI</code> contains some European characters like <code>\u00e4 \u00d6 \u00e4 \u00d5 \u00f8</code>.</p>\n<p>Newer file encodings like <a href=\"http://en.wikipedia.org/wiki/UTF8\" rel=\"noreferrer\"><code>UTF-8</code></a> or <a href=\"http://en.wikipedia.org/wiki/UTF-32\" rel=\"noreferrer\"><code>UTF-32</code></a> can contain characters of any language. <code>UTF-8</code> is characters are variable in length. <code>UTF-32</code> are 32 bit characters long.</p>\n<p><strong>File enconding requirements:</strong></p>\n<p>Most compilers offer command line switch to specify the file encoding of the source file.</p>\n<p>A c++ source file needs to be encoded in an file encoding which has a representation of the basic source character set. For example: The file encoding of the source file needs to have a representation of the <code>;</code> character.</p>\n<p>If you can type the character <code>;</code> within the encoding chosen as the encoding of the source file that encoding is not suitable as a c++ source file encoding.</p>\n<p><strong>Non-basic character sets:</strong></p>\n<p>Characters not included in the basic source character set belong to the source character set. The source character set is equivalent to the file encoding.</p>\n<p>For example: the <code>@</code> character is not include in the basic source character but it may be included in the source character set. The chosen file encoding of the input source file might contain a representation of <code>@</code>. If it doesn't contain a representation for <code>@</code> you can't use the character <code>@</code> within strings.</p>\n<p>Characters not included in the basic (wide) character set belong to the execution (wide) character set.</p>\n<p>Remember that the compiler converts the character from the source character set to the execution character set and the execution wide character set. Therefore there needs to be way how these characters can be converted.</p>\n<p>For example: If you specify <code>Windows-1252</code> as the encoding of the source character set and specify <code>ASCII</code> as the execution wide character set there is no way to convert this string:</p>\n<pre><code>const char* string0 = \"string with European characters \u00f6, \u00c4, \u00f4, \u00d0.\";\n</code></pre>\n<p>These characters can not be represented in <code>ASCII</code>.</p>\n<p><strong>Specifying character sets:</strong></p>\n<p>Here are some examples how to specify the character sets using gcc. The default values are included.</p>\n<pre><code>-finput-charset=UTF-8         &lt;- source character set\n-fexec-charset=UTF-8          &lt;- execution character set\n-fwide-exec-charset=UTF-32    &lt;- execution wide character set\n</code></pre>\n<p>With UTF-8 and UTF-32 as default encoding c++ source files can contain strings with character of any language. UTF-8 characters can the converted both ways without problems.</p>\n<p><strong>The extended character set:</strong></p>\n<blockquote>\n<p id=\"so_3768363_4248640_3\">\u00a71.1.3: multibyte character, a sequence of one or more bytes representing a member of the extended character set of either the source or the execution environment. The extended character set is a superset of the basic character set (2.2).</p>\n</blockquote>\n<p>Multibyte character are longer than an entry of the normal characters. They contain an escape sequence marking them as multibyte character.</p>\n<p>Multibyte characters are processed according the locale set in the user's runtime environment. These multibyte characters are converted at runtime to the encoding set in user's environment.</p>\n", "OwnerUserId": "339387", "PostTypeId": "2", "Id": "4248640", "Score": "16", "CreationDate": "2010-11-22T18:05:56.030", "LastActivityDate": "2010-11-22T18:05:56.030"}});