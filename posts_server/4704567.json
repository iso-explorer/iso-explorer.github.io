post_cb({"4704741": {"ParentId": "4704567", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Overload resolution picks the function that is the closest match to the supplied argument.  You supplied a Test.  No conversion necessary -- identity conversion used.  Thus function resolution chooses f(Test).  Test can't be copied from rvalue, which you supplied, but overload resolution has succeeded already...conversion to int is never checked.</p>\n<p><code>g(Eater)</code> is chosen because the types don't exactly match, the identity conversion is NOT used, and the compiler has to find a conversion routine that works.  <code>g(Slurper)</code> doesn't because you can't make one out of the supplied argument.</p>\n<p>\"Why doesn't this one fail: <code>struct A { operator int(); }; void f(A&amp;); void f(int); void g() { f(A()); }</code>\"</p>\n<p>Because f(A&amp;) is not a viable overload for the supplied argument.  In this case the parameter is a reference and the fact that temps don't bind to non-const is allowed to effect the resolution.  In this case it does and the that version of the function becomes a non-candidate, leaving only the one and it works.</p>\n", "OwnerUserId": "301883", "LastEditorUserId": "301883", "LastEditDate": "2011-01-16T10:41:16.547", "Id": "4704741", "Score": "3", "CreationDate": "2011-01-16T09:58:09.677", "LastActivityDate": "2011-01-16T10:41:16.547"}, "4704939": {"ParentId": "4704567", "CommentCount": "0", "Body": "<p>Basically, for overload resolution, it is assumed that an object of type A can be converted to an object of type A regardless of any cv-qualification on either of the two. </p>\n<p>From draft n1905:</p>\n<p><strong>13.3.3.1: Overloading.Overload Resolution.Best Viable Function.Implicit Conversion Sequences</strong></p>\n<blockquote>\n<p id=\"so_4704567_4704939_0\">6 <strong>When the parameter type is not a reference</strong>, the implicit conversion sequence models a copy-initialization of the parameter from the argument expression.  The implicit conversion sequence is the one required to convert the argument\n  expression to an rvalue of the type of the parameter. [ <em>Note</em>: when the parameter has a class type, this is a conceptual\n  conversion defined for the purposes of clause 13; the actual initialization is defined in terms of constructors and is not\n  a conversion.  \u2014 <em>end note</em> ] <strong>Any difference in top-level cv-qualification is subsumed by the initialization itself and does\n  not constitute a conversion.</strong>  [ <em>Example</em>: a parameter of type A can be initialized from an argument of type const  A.\n  The implicit conversion sequence for that case is the identity sequence; it contains no \u201cconversion\u201d from const  A to\n  A.  \u2014 <em>end example</em> ] <strong>When the parameter has a class type and the argument expression has the same type, the implicit\n  conversion sequence is an identity conversion</strong>. [...]</p>\n</blockquote>\n", "OwnerUserId": "530177", "PostTypeId": "2", "Id": "4704939", "Score": "0", "CreationDate": "2011-01-16T11:02:04.650", "LastActivityDate": "2011-01-16T11:02:04.650"}, "bq_ids": {"n4140": {"so_4704567_4704939_0": {"section_id": 611, "quality": 0.8588235294117647, "length": 73}}, "n3337": {"so_4704567_4704939_0": {"section_id": 601, "quality": 0.8588235294117647, "length": 73}}, "n4659": {"so_4704567_4704939_0": {"section_id": 637, "quality": 0.8588235294117647, "length": 73}}}, "4704567": {"CommentCount": "16", "ViewCount": "649", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-01-16T09:05:54.147", "LastActivityDate": "2011-01-16T11:02:04.650", "Title": "Function with parameter type that has a copy-constructor with non-const ref chosen?", "AcceptedAnswerId": "4704741", "LastEditDate": "2011-01-16T10:47:27.570", "Id": "4704567", "Score": "2", "Body": "<p>Some time ago I was confused by the following behavior of some code when I wanted to write a <code>is_callable&lt;F, Args...&gt;</code> trait. Overload resolution won't call functions accepting arguments by non-const ref, right? Why doesn't it reject in the following because the constructor wants a <code>Test&amp;</code>? I expected it to take <code>f(int)</code>!</p>\n<pre><code>struct Test {\n  Test() { }\n\n  // I want Test not be copyable from rvalues!\n  Test(Test&amp;) { }\n\n  // But it's convertible to int\n  operator int() { return 0; }\n};\n\nvoid f(int) { }\nvoid f(Test) { }\n\nstruct WorksFine { };\nstruct Slurper { Slurper(WorksFine&amp;) { } };\nstruct Eater { Eater(WorksFine) { } };\n\nvoid g(Slurper) { }\nvoid g(Eater) { } // chooses this, as expected\n\nint main() {\n  // Error, why?\n  f(Test());\n\n  // But this works, why?\n  g(WorksFine());\n}\n</code></pre>\n<p>Error message is</p>\n<pre><code>m.cpp: In function 'int main()':\nm.cpp:33:11: error: no matching function for call to 'Test::Test(Test)'\nm.cpp:5:3: note: candidates are: Test::Test(Test&amp;)\nm.cpp:2:3: note:                 Test::Test()\nm.cpp:33:11: error:   initializing argument 1 of 'void f(Test)'\n</code></pre>\n<p>Can you please explain why one works but the other doesn't?</p>\n", "Tags": "<c++><rvalue><overload-resolution><const-reference>", "OwnerUserId": "34509", "AnswerCount": "2"}});