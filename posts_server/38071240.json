post_cb({"bq_ids": {"n4140": {"so_38071240_38072162_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 1395}, "so_38071240_38072162_3": {"length": 4, "quality": 1.0, "section_id": 1396}, "so_38071240_38072162_2": {"length": 4, "quality": 1.0, "section_id": 1396}, "so_38071240_38071466_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 714}, "so_38071240_38072162_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 1396}}, "n3337": {"so_38071240_38072162_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 1389}, "so_38071240_38071466_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 703}, "so_38071240_38072162_2": {"length": 4, "quality": 1.0, "section_id": 1390}, "so_38071240_38072162_3": {"length": 4, "quality": 1.0, "section_id": 1390}, "so_38071240_38072162_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 1390}}, "n4659": {"so_38071240_38072162_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 1513}, "so_38071240_38072162_3": {"length": 4, "quality": 1.0, "section_id": 1514}, "so_38071240_38072162_2": {"length": 4, "quality": 1.0, "section_id": 1514}, "so_38071240_38071466_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 744}, "so_38071240_38072162_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 1514}}}, "38072162": {"Id": "38072162", "PostTypeId": "2", "Body": "<p>Per \u00a725.4/3 (emphasis and <em>foot-notes</em> are mine):</p>\n<blockquote>\n<p id=\"so_38071240_38072162_0\">For algorithms other than those described in 25.4.3<sup>*</sup> to work\n  correctly, comp<sup>**</sup> has to induce a <strong>strict weak ordering</strong> on the values.</p>\n</blockquote>\n<p><sub><em><sup>*</sup> 25.4.3 is the section for binary search algorithms.</em></sub><br/>\n<sub><em><sup>**</sup> <code>comp</code> is the custom comparator.</em></sub></p>\n<p>Since <code>std::sort</code> is defined in 25.4.1 and <code>std::min_element</code> is in 25.4.7, then you only need a <strong>strict weak ordering</strong> on the values, i.e.:</p>\n<blockquote>\n<p id=\"so_38071240_38072162_1\">The term strict refers to the requirement of an irreflexive relation (!comp(x, x) for all x), and the term weak to requirements that are not as strong as those for a total ordering, but stronger than those for a partial ordering. If we define equiv(a, b) as !comp(a, b) &amp;&amp; !comp(b, a), then the requirements are that comp and equiv both be transitive relations:</p>\n<p id=\"so_38071240_38072162_2\">(4.1) \u2014 comp(a, b) &amp;&amp; comp(b, c) implies comp(a, c)</p>\n<p id=\"so_38071240_38072162_3\">(4.2) \u2014 equiv(a, b) &amp;&amp; equiv(b, c) implies equiv(a, c)</p>\n</blockquote>\n<p>As far as I understand your relation, it does not match the <em>equiv</em> requirement since you may have two nodes where <code>!comp(a, b) &amp;&amp; !comp(b, a)</code> but <code>a != b</code>. Typically, if you have <code>a</code> and <code>c</code> on one branch and <code>b</code> on another one, the above won't work because <code>equiv(a, b) == equiv(b, c) == true</code> but <code>equiv(a, c) == false</code>.</p>\n", "LastEditorUserId": "2666289", "LastActivityDate": "2016-06-28T12:33:03.560", "Score": "1", "CreationDate": "2016-06-28T09:22:48.857", "ParentId": "38071240", "CommentCount": "0", "OwnerUserId": "2666289", "LastEditDate": "2016-06-28T12:33:03.560"}, "38071240": {"ViewCount": "56", "Body": "<p>Can <code>std::min_element</code> (and also <code>std::sort</code> and similar functions from <code>&lt;algorithm&gt;</code>) be used on types with only a partial order?</p>\n<p>For example:</p>\n<pre><code>auto it = std::min_element(vec.cbegin(), vec.cend(), [](const node* a, const node* b) {\n    return a-&gt;precedes(*b);\n});\n</code></pre>\n<p>Here <code>node</code> represents nodes in an DAG (directed acyclic graph), and <code>a.precedes(b)</code> tests it <code>a</code> is an ancestor of <code>b</code>. But if <code>a</code> and <code>b</code> are on different branches, it also returns <code>false</code>, and in that case <code>a.precedes(b) == b.precedes(a) == false</code>.</p>\n", "AcceptedAnswerId": "38072162", "Title": "using min_element on partial order", "CreationDate": "2016-06-28T08:43:13.097", "Id": "38071240", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-06-28T12:33:03.560", "Score": "2", "OwnerUserId": "4108376", "Tags": "<c++><graph><stl-algorithm>", "AnswerCount": "2"}, "38071466": {"Id": "38071466", "PostTypeId": "2", "Body": "<p>From the C++11 standard \u00a7 23.2.1:</p>\n<blockquote>\n<p id=\"so_38071240_38071466_0\"><code>a &lt; b</code> convertible to <code>bool</code>. <code>lexicographical_-compare(a.begin(), a.end(), b.begin(), b.end())</code> pre[condition]: <code>&lt;</code> is defined for values of <code>T</code>. <code>&lt;</code> is a <strong>total ordering</strong> relationship.</p>\n</blockquote>\n<p>So, no that won't work.</p>\n", "LastActivityDate": "2016-06-28T08:54:19.293", "CommentCount": "1", "CreationDate": "2016-06-28T08:54:19.293", "ParentId": "38071240", "Score": "0", "OwnerUserId": "1312406"}});