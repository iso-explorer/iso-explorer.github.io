post_cb({"18367788": {"Id": "18367788", "PostTypeId": "2", "Body": "<p>References in C++ language can be thought of as \"alternative names\" for other objects. A name always refers to an object, it cannot exist without that object, i.e. a reference cannot \"refer to nothing\". This means that a reference has to be bound to the target object immediately, at the moment of reference creation, and stay bound to that object as long as that reference exists. The language is specifically designed to enforce that rule as much as possible. In case of reference members inside a non-aggregate class type, such members have to be explicitly initialized in constructor initializer list.</p>\n<p>Strictly speaking a program that calls for default initialization of a reference is ill-formed. In everyday nomenclature, it is supposed to be an \"error\", not a \"warning\". So, the real \"why\" here is why your compiler issued a mere warning (albeit formally any diagnostic message is sufficient to report ill-formed code).</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-08-21T21:17:46.747", "Score": "10", "CreationDate": "2013-08-21T21:11:55.000", "ParentId": "18367698", "CommentCount": "1", "OwnerUserId": "187690", "LastEditDate": "2013-08-21T21:17:46.747"}, "18367698": {"ViewCount": "1610", "Body": "<p>I have the following code:</p>\n<pre><code>class A {\n public:\n  A() { }\n};\n\nclass B {\n private:\n  const A &amp;a;\n\n public:\n  B() : a() { }\n  B(const A &amp;ina) : a(ina) { }\n};\n</code></pre>\n<p>Compiling results in the following:</p>\n<blockquote>\n<p id=\"so_18367698_18367698_0\">ab.cpp: In constructor 'B::B()':</p>\n<p id=\"so_18367698_18367698_1\">ab.cpp:11: warning: default-initialization of 'const A&amp; B::a', which has reference type</p>\n</blockquote>\n<p>Why does this result in a warning and how do I fix it?</p>\n", "AcceptedAnswerId": "18367788", "Title": "Why does default-initialization of reference type member result in compiler warning?", "CreationDate": "2013-08-21T21:05:54.290", "Id": "18367698", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2013-08-21T21:19:57.133", "Score": "1", "OwnerUserId": "698282", "Tags": "<c++><reference><const><compiler-warnings>", "AnswerCount": "4"}, "18367780": {"Id": "18367780", "PostTypeId": "2", "Body": "<p>A reference should always refer to a variable. Therefore default initialization in the 1st constructor for B does not make sense. In effect having a reference that was default-initialized is the same as having a pointer that was not initialized at all: both refer to (or point to) a random place in memory. Thus the warning.</p>\n", "LastActivityDate": "2013-08-21T21:11:14.703", "CommentCount": "0", "CreationDate": "2013-08-21T21:11:14.703", "ParentId": "18367698", "Score": "1", "OwnerUserId": "2540407"}, "18367743": {"Id": "18367743", "PostTypeId": "2", "Body": "<p>It is UB. References have to always be initialized.</p>\n", "LastActivityDate": "2013-08-21T21:09:07.580", "CommentCount": "0", "CreationDate": "2013-08-21T21:09:07.580", "ParentId": "18367698", "Score": "2", "OwnerUserId": "341065"}, "bq_ids": {"n4140": {"so_18367698_18367907_3": {"length": 21, "quality": 0.9130434782608695, "section_id": 3319}, "so_18367698_18367907_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3317}}, "n3337": {"so_18367698_18367907_3": {"length": 21, "quality": 0.9130434782608695, "section_id": 3189}, "so_18367698_18367907_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3187}}, "n4659": {"so_18367698_18367907_3": {"length": 21, "quality": 0.9130434782608695, "section_id": 4085}, "so_18367698_18367907_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 502}}}, "18367907": {"Id": "18367907", "PostTypeId": "2", "Body": "<p>From the standard :</p>\n<blockquote>\n<p id=\"so_18367698_18367907_0\"><strong>8.5.3 References [dcl.init.ref]</strong></p>\n<ol>\n<li><p id=\"so_18367698_18367907_1\">A variable declared to be a T&amp; or T&amp;&amp;, that is, \u201creference to type T\u201d (8.3.2), shall be initialized by an object, or function, of type T or by an object that can be converted into a T.</p></li>\n<li><p id=\"so_18367698_18367907_2\">[...]</p></li>\n<li><p id=\"so_18367698_18367907_3\">The initializer can be omitted for a reference only in a parameter declaration (8.3.5), in the declaration of a function return type, in the declaration of a class member within its class definition (9.2), and where the extern specifier is explicitly used.</p></li>\n</ol>\n</blockquote>\n<p>The constructor of <code>B</code> is wrong because internally it calls the default constructor of a reference, this is not possible.</p>\n<p>A reference member has to be initialize int the <em>member-initialization-list</em> of the constructors. That's why your default constructor is ill-formed.</p>\n", "LastActivityDate": "2013-08-21T21:19:57.133", "CommentCount": "0", "CreationDate": "2013-08-21T21:19:57.133", "ParentId": "18367698", "Score": "4", "OwnerUserId": "1394283"}});