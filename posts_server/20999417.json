post_cb({"bq_ids": {"n4140": {"so_20999417_24539642_4": {"length": 12, "quality": 0.8571428571428571, "section_id": 160}, "so_20999417_24539642_5": {"length": 12, "quality": 0.8, "section_id": 160}, "so_20999417_24539642_2": {"length": 7, "quality": 0.875, "section_id": 160}, "so_20999417_24539642_3": {"length": 6, "quality": 1.0, "section_id": 160}, "so_20999417_24539642_6": {"length": 42, "quality": 0.9767441860465116, "section_id": 161}, "so_20999417_24539642_1": {"length": 39, "quality": 0.975, "section_id": 160}}, "n3337": {"so_20999417_24539642_4": {"length": 12, "quality": 0.8571428571428571, "section_id": 154}, "so_20999417_24539642_5": {"length": 12, "quality": 0.8, "section_id": 154}, "so_20999417_24539642_2": {"length": 7, "quality": 0.875, "section_id": 154}, "so_20999417_24539642_3": {"length": 6, "quality": 1.0, "section_id": 154}, "so_20999417_24539642_6": {"length": 42, "quality": 0.9767441860465116, "section_id": 155}, "so_20999417_24539642_1": {"length": 39, "quality": 0.975, "section_id": 154}}, "n4659": {"so_20999417_24539642_4": {"length": 12, "quality": 0.8571428571428571, "section_id": 164}, "so_20999417_24539642_5": {"length": 12, "quality": 0.8, "section_id": 164}, "so_20999417_24539642_2": {"length": 7, "quality": 0.875, "section_id": 164}, "so_20999417_24539642_3": {"length": 6, "quality": 1.0, "section_id": 164}, "so_20999417_24539642_6": {"length": 42, "quality": 0.9767441860465116, "section_id": 165}, "so_20999417_24539642_1": {"length": 38, "quality": 0.95, "section_id": 164}}}, "20999417": {"ViewCount": "80", "Body": "<p>Today I see the following code in stl_pair.h: </p>\n<pre><code>#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n\ntemplate &lt;class _T1, class _T2&gt;\ninline bool operator!=(const pair&lt;_T1, _T2&gt;&amp; __x, const pair&lt;_T1, _T2&gt;&amp; __y) {\n  return !(__x == __y);\n}\n\ntemplate &lt;class _T1, class _T2&gt;\ninline bool operator&gt;(const pair&lt;_T1, _T2&gt;&amp; __x, const pair&lt;_T1, _T2&gt;&amp; __y) {\n  return __y &lt; __x;\n}\n\n#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n</code></pre>\n<p>i don't think the template functions have any association with the partial specialization\nof function templates.\nam i wrong ?</p>\n", "Title": "why should the macro __STL_FUNCTION_TMPL_PARTIAL_ORDER enclose the template function in std_pair.h", "CreationDate": "2014-01-08T15:12:40.453", "LastActivityDate": "2014-07-02T19:38:48.373", "CommentCount": "4", "LastEditDate": "2014-07-02T19:38:48.373", "PostTypeId": "1", "LastEditorUserId": "819272", "Id": "20999417", "Score": "4", "OwnerUserId": "2861706", "Tags": "<c++><templates><overload-resolution><argument-deduction>", "AnswerCount": "1"}, "24539642": {"Id": "24539642", "PostTypeId": "2", "Body": "<h2>How a function call is being treated by the compiler</h2>\n<p>Calling a function template in C++ goes through the Holy Trinity of <strong>Name Lookup</strong> (section 3.4 in the Standard), <strong>Template Argument Deduction</strong> (section 14.8.2) and <strong>Overload resolution</strong> (section 13.3). </p>\n<p>Apart from reading these sections in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\"><strong>C++ Standard,</strong></a> you can read about it in the excellent book <a href=\"http://rads.stackoverflow.com/amzn/click/0201734842\" rel=\"nofollow\"><strong>C++ Templates: The Complete Guide</strong></a>, or watch the first three Core C++ videos by Stephan T. Lavavej</p>\n<ul>\n<li><a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-1-of-n\" rel=\"nofollow\"><strong>Core C++, 1 of n</strong></a></li>\n<li><a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-2-of-n\" rel=\"nofollow\"><strong>Core C++, 2 of n</strong></a></li>\n<li><a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-Cpp-3-of-n\" rel=\"nofollow\"><strong>Core C++, 3 of n</strong></a></li>\n</ul>\n<h2>A glimpse into the Standard</h2>\n<p>As you already found out yourself, the macro was originally in the SGI implementation of the STL, at a time when there was not C++ Standard yet and compiler support for function templates was very sketchy.</p>\n<blockquote>\n<p id=\"so_20999417_24539642_0\">// * __STL_FUNCTION_TMPL_PARTIAL_ORDER: defined if the compiler\n  supports //   partial ordering of function templates.  (a.k.a partial\n  specialization //   of function templates.)</p>\n</blockquote>\n<p>To find out what partial ordering of function templates is used for, here's a quote (which will become much clearer if you read the book and watch the linked videos).</p>\n<p><strong>14.5.6.2 Partial ordering of function templates [temp.func.order]</strong></p>\n<blockquote>\n<p id=\"so_20999417_24539642_1\">1 <strong>If a function template is overloaded, the use of a function template\n  specialization might be ambiguous</strong> because template argument deduction\n  (14.8.2) may associate the function template specialization with more\n  than one function template declaration. <strong>Partial ordering of overloaded\n  function template declarations is used</strong> in the following contexts <strong>to\n  select the function template to which a function template\n  specialization refers</strong>: </p>\n<p id=\"so_20999417_24539642_2\">\u2014 during overload resolution for a call to a\n  function template specialization (13.3.3); </p>\n<p id=\"so_20999417_24539642_3\">\u2014 when the address of a\n  function template specialization is taken; </p>\n<p id=\"so_20999417_24539642_4\">\u2014 when a placement operator\n  delete that is a function template specialization is selected to match\n  a placement operator new (3.7.4.2, 5.3.4); </p>\n<p id=\"so_20999417_24539642_5\">\u2014 when a friend function\n  declaration (14.5.4), an explicit instantiation (14.7.2) or an\n  explicit specialization (14.7.3) refers to a function template\n  specialization. </p>\n<p id=\"so_20999417_24539642_6\">2 Partial ordering selects which of two function\n  templates is more specialized than the other by transforming each\n  template in turn (see next paragraph) and performing template argument\n  deduction using the function type. <strong>The deduction process determines\n  whether one of the templates is more specialized than the other. If\n  so, the more specialized template is the one chosen by the partial\n  ordering process</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2014-07-02T19:38:21.730", "CommentCount": "0", "CreationDate": "2014-07-02T19:38:21.730", "ParentId": "20999417", "Score": "0", "OwnerUserId": "819272"}});