post_cb({"46961876": {"CommentCount": "7", "ViewCount": "71", "PostTypeId": "1", "LastEditorUserId": "193848", "CreationDate": "2017-10-26T18:58:34.487", "LastActivityDate": "2017-10-27T01:28:35.367", "Title": "C++ Calling a callback that takes no argument with an argument - or a better solution", "LastEditDate": "2017-10-26T21:48:16.597", "Id": "46961876", "Score": "1", "Body": "<p>I am building a c++ class library for embedded projects.\nOne concept I have is a class named Task.\nTask has 2 members: \nAn integer id and a callback function pointer </p>\n<p>The callbacks are created by the user and given to the constructor of the class.</p>\n<p>I want to give the following options to the user:</p>\n<ul>\n<li>The user may use functions of type <code>void(*)(void)</code></li>\n<li>The user may use function of type <code>void (*)(unsigned int)</code>. That parameter should be the id of the task, when the callback is called.</li>\n<li>The user may use a combination of the above function types for different tasks</li>\n</ul>\n<p>The tasks also have an execute() method that calls the callback function. This method should also provide the task id as an argument, if needed</p>\n<p>One solution would be to add a boolean member in Task called 'has_arguments' and overload the constructor to set it with regard to the type of function pointer it was given in the code.\nI could also use a union for the callback member or use a void pointer and cast it to whatever suitable during execution.\nThe execution of the task would involve checking the 'has_arguments' member, casting the pointer to the appropriate type and calling the callback in the right way.</p>\n<p>But is there any way to avoid this extra member and check?</p>\n<p>I tried  to always cast the function pointers to void(*)(unsigned int) and always provide the argument when I called them. And it worked.</p>\n<p>So is it that bad to call a functions that takes no arguments, with an argument?\nIt worked for me, but I suppose that it is a really bad practice.\nAny other ideas on what I could implement instead?</p>\n<p>I don't want to dictate to the users to make functions with variable arguments lists. I want to leave them the freedom to use simple task agnostic functions, \nor make more intelligent functions that are aware of their task ID</p>\n", "Tags": "<c++><function><pointers><callback>", "OwnerUserId": "8839561", "AnswerCount": "4"}, "46962807": {"ParentId": "46961876", "CommentCount": "0", "Body": "<p>Calling a function through a function pointer that has been casted to a different type invokes undefined behaviour (cf. <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.reinterpret.cast#6\" rel=\"nofollow noreferrer\">thins online C++ standard draft</a> concerning casting of function pointers):</p>\n<blockquote>\n<p id=\"so_46961876_46962807_0\">A function pointer can be explicitly converted to a function pointer\n  of a different type. <strong>The effect of calling a function through a\n  pointer to a function type ([dcl.fct]) that is not the same as the\n  type used in the definition of the function is undefined.</strong> Except that\n  converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to\n  T2\u201d (where T1 and T2 are function types) and back to its original type\n  yields the original pointer value, the result of such a pointer\n  conversion is unspecified. [ Note: see also [conv.ptr] for more\n  details of pointer conversions.  \u2014 end note ]</p>\n</blockquote>\n<p>Hence, you should not use it / do it as described in your question.</p>\n<p>A way to overcome this problem would be to enforce that correct function pointers are stored for the one and for the other case. This could be done through a discriminator / type data member and two separate function pointer members (or a union of these two separate function pointers) as described in the answer of @Slava.</p>\n<p>Another approach could be to distinguish different task types and use inheritance and overriding to perform the callbacks correctly. Of course, this influences the way you will create / use your tasks. But maybe it solves your problem in a more extensible way than with type members and unions. </p>\n<pre><code>typedef void(*VoidCallbackType)(void) ;\ntypedef void(*IdCallbackType)(unsigned) ;\n\nstruct Task {\n\n    virtual void doCallback() = 0;\n};\n\nstruct TaskWithId : Task {\n\n    unsigned id;\n    IdCallbackType cb;\n\n    TaskWithId(unsigned id, IdCallbackType cb) : id(id), cb(cb) { }\n    virtual void doCallback() {\n        cb(id);\n    }\n};\n\nstruct TaskWithoutId: Task {\n\n    VoidCallbackType cb;\n\n    TaskWithoutId(VoidCallbackType cb) : cb(cb) { }\n    virtual void doCallback() {\n        cb();\n    }\n};\n</code></pre>\n", "OwnerUserId": "2630032", "PostTypeId": "2", "Id": "46962807", "Score": "1", "CreationDate": "2017-10-26T19:59:55.187", "LastActivityDate": "2017-10-26T19:59:55.187"}, "46961990": {"ParentId": "46961876", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_46961876_46961990_0\">So is it that bad to call a functions that takes no arguments with an argument?</p>\n</blockquote>\n<p>Yes of course!</p>\n<blockquote>\n<p id=\"so_46961876_46961990_1\">It worked for me, but I suppose that it is a really bad practice</p>\n</blockquote>\n<p>\"It worked for me\" isn't a very valid argument if your program has undefined behavior. Because it might not work for me.</p>\n<blockquote>\n<p id=\"so_46961876_46961990_2\">Any other ideas how I could implement instead?</p>\n</blockquote>\n<p>A tagged union is really the best way to implement this sort of thing in my opinion. You can always use <code>boot::variant</code> or <code>std::variant</code> for a safer tagged union if you can.</p>\n<p>Really, having just one extra member (which is a <code>bool</code>) isn't going to destroy your performance, same for the additional branches that you will have to introduce, even on embedded. Measure first, you can then always optimize if you find that the branches are indeed bottlenecks. :)</p>\n", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "46961990", "Score": "2", "CreationDate": "2017-10-26T19:05:52.360", "LastActivityDate": "2017-10-26T19:05:52.360"}, "46962040": {"ParentId": "46961876", "LastEditDate": "2017-10-26T19:16:31.137", "CommentCount": "0", "CreationDate": "2017-10-26T19:08:42.127", "OwnerUserId": "432358", "LastEditorUserId": "432358", "PostTypeId": "2", "Id": "46962040", "Score": "1", "Body": "<p>If you cannot use <code>std::function</code> due to limitation of embedded platform use <code>union</code> and a tag, then properly set <code>type</code> by overloaded setter or ctor and in call use a <code>switch</code> on <code>type</code>:</p>\n<pre><code>struct Task {\n    enum CallbackType {\n        cbVoid,\n        cbId\n   };\n   using VoidCb = void(*)(void);\n   using IdCb = void(*)(unsigned);\n\n   int          id = 0;\n   CallbackType type;\n   union {\n       VoidCb vcb;\n       IdCb  idcb;\n   } function;\n\n   Task( VoidCb cb ) : type( cbVoid ), function( cb ) {}\n   Task( IdCb cb ) : type( cbId ), function( cb ) {}\n\n   void call() {\n       switch( type ) {\n           case cbVoid : function.vcb(); return;\n           case cbId : function.idcb( id ); return;\n       }\n   }\n};\n</code></pre>\n", "LastActivityDate": "2017-10-26T19:16:31.137"}, "46965837": {"ParentId": "46961876", "LastEditDate": "2017-10-27T01:28:35.367", "CommentCount": "4", "CreationDate": "2017-10-27T00:41:49.097", "OwnerUserId": "315052", "LastEditorUserId": "315052", "PostTypeId": "2", "Id": "46965837", "Score": "0", "Body": "<p>You can create something under the covers that looks like the same interface. That is, auto-create helper wrapper functions that can throw away the task id if the callback doesn't want it.</p>\n<pre><code>class Task {\n\n    template &lt;void (*CB)(void)&gt; struct task_void {\n        static void cb (int) { CB(); }\n        operator Task () const { return Task(*this); }\n    };\n\n    template &lt;void (*CB)(int)&gt; struct task_int {\n        static void cb (int id) { CB(id); }\n        operator Task () const { return Task(*this); }\n    };\n\n    static volatile int next_id_;\n\n    int id_;\n    void (*cb_)(int);\n\n    template &lt;typename CB&gt; Task (CB) : id_(next_id_++), cb_(CB::cb) {}\n\npublic:\n    template &lt;void (*CB)(void)&gt; static Task make () { return task_void&lt;CB&gt;(); }\n    template &lt;void (*CB)(int)&gt; static Task make () { return task_int&lt;CB&gt;(); }\n    void execute () { cb_(id_); }\n};\n</code></pre>\n<p>The private constructor is accessible to the helper templates for initialization. The helper templates can choose to hide the parameter or not.</p>\n<p>So now, you can create a task with either kind of callback.</p>\n<pre><code>void cb_void () {\n    std::cout &lt;&lt; __func__ &lt;&lt; std::endl;\n}\n\nvoid cb_int (int id) {\n    std::cout &lt;&lt; __func__ &lt;&lt; ':' &lt;&lt; id &lt;&lt; std::endl;\n}\n\n//...\n    Task t1 = Task::make&lt;cb_void&gt;();\n    Task t2 = Task::make&lt;cb_int&gt;();\n    t1.execute();\n    t2.execute();\n</code></pre>\n", "LastActivityDate": "2017-10-27T01:28:35.367"}, "bq_ids": {"n4140": {"so_46961876_46961990_0": {"section_id": 47, "quality": 0.6666666666666666, "length": 4}, "so_46961876_46962807_0": {"section_id": 6045, "quality": 0.8928571428571429, "length": 50}}, "n3337": {"so_46961876_46961990_0": {"section_id": 554, "quality": 0.6666666666666666, "length": 4}, "so_46961876_46962807_0": {"section_id": 5813, "quality": 0.8928571428571429, "length": 50}}, "n4659": {"so_46961876_46961990_0": {"section_id": 48, "quality": 0.6666666666666666, "length": 4}, "so_46961876_46962807_0": {"section_id": 7544, "quality": 0.875, "length": 49}}}});