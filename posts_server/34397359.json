post_cb({"34397464": {"ParentId": "34397359", "CommentCount": "3", "Body": "<p>Arrays size must be compile-time constants, but in the second example the initialization of <code>A::i</code> doesn't happen until <em>run-time</em>.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "34397464", "Score": "4", "CreationDate": "2015-12-21T14:00:41.207", "LastActivityDate": "2015-12-21T14:00:41.207"}, "34397474": {"ParentId": "34397359", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You're performing an l-t-r conversion on <code>i</code>, but for [expr.const]/(2.7) not to be violated here, (2.7.3) must be applicable:</p>\n<p><a href=\"https://i.stack.imgur.com/RBM98.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/RBM98.png\"/></a></p>\n<p><sup>(2.7.1) concerns complete objects, (2.7.2) talks about string literals and (2.7.4) is about objects whose lifetime began within the evaluation of the expression - inapplicable since <code>a</code>'s declaration precedes <code>b</code>'s.</sup></p>\n<p>Define <code>a</code> as <code>constexpr</code> and the code is compliant.</p>\n<hr>\n<p>A little addendum to clarify what the standard says: The expression inside the brackets must be a converted constant expression of type <code>std::size_t</code> (<a href=\"http://eel.is/c++draft/dcl.array#1\" rel=\"nofollow noreferrer\">[dcl.array]/1</a>), which is defined in <a href=\"http://eel.is/c++draft/expr.const#4\" rel=\"nofollow noreferrer\">[expr.const]/4</a> as</p>\n<blockquote>\n<p id=\"so_34397359_34397474_0\">A <em>converted constant expression of type</em> <code>T</code> is an expression, implicitly converted to type <code>T</code>, where the converted\n  expression is a constant expression and [\u2026requirements that are met\u2026]</p>\n</blockquote>\n<p>Thus, really, the standard is interested in whether or not </p>\n<pre><code>constexpr std::size_t s = a; \n</code></pre>\n<p>would be valid. Which it isn't, for the aforementioned reasons - trying to use a subobject of a previously defined, non-<code>constexpr</code> object. </p>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-12-21T19:24:14.653", "Id": "34397474", "Score": "17", "CreationDate": "2015-12-21T14:00:57.720", "LastActivityDate": "2015-12-21T19:24:14.653"}, "34397359": {"CommentCount": "0", "AcceptedAnswerId": "34397474", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-12-21T13:55:28.487", "LastActivityDate": "2015-12-21T19:24:14.653", "LastEditDate": "2015-12-21T14:21:35.710", "ViewCount": "811", "FavoriteCount": "1", "Title": "Why are these snippets handled differently by GCC?", "Id": "34397359", "Score": "15", "Body": "<p>The first snippet compiles without any warnings (<a href=\"https://goo.gl/Jgo7TO\" rel=\"noreferrer\">live example</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n  constexpr A(): i(5){}\n  constexpr operator int() { return 5; }\n  int i;\n};\n\nint main() {\n    A a;\n    int b[a]{ 0, 1, 2, 3, 4 };\n    std::cout &lt;&lt; b[4] &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Now alter the above snippet by returning <code>i</code> in the conversion operator (<a href=\"https://goo.gl/JB6MsK\" rel=\"noreferrer\">live example</a>):</p>\n<pre><code>constexpr operator int() { return i; }\n</code></pre>\n<p>GCC warns that <code>b</code> is a VLA.</p>\n<p>To me, both variants seem to conform to paragraph \u00a75.19 [expr.const]/3 in C++14.</p>\n", "Tags": "<c++><gcc><g++><language-lawyer><c++14>", "OwnerUserId": "411165", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34397359_34397474_0": {"section_id": 6186, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_34397359_34397474_0": {"section_id": 3191, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_34397359_34397474_0": {"section_id": 7689, "quality": 0.7333333333333333, "length": 11}}}});