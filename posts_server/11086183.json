post_cb({"11086183": {"CommentCount": "4", "ViewCount": "12923", "PostTypeId": "1", "LastEditorUserId": "140011", "CreationDate": "2012-06-18T15:37:09.200", "LastActivityDate": "2012-06-18T22:24:20.750", "Title": "Encode/Decode std::string to UTF-16", "LastEditDate": "2012-06-18T22:24:20.750", "Id": "11086183", "Score": "4", "Body": "<p>I have to handle a file format (both read from and write to it) in which strings are encoded in UTF-16 (2 bytes per character). Since characters out of the ASCII table are rarely used in the application  domain, all of the strings in my C++ model classes are stored in instances of std::string (UTF-8 encoded).</p>\n<p>I'm looking for a library (searched in STL and Boost with no luck) or a set of C/C++ functions to handle this std::string &lt;-&gt; UTF-16 conversion when loading from or saving to file format (actually modeled as a bytestream) including the generation/recognition of surrogate pairs and all that Unicode stuffs (I'm admittedly no expert with)...</p>\n<p>Any suggestions? Thanks!</p>\n<p>EDIT: forgot to mention it should be cross-platform (Win / Mac) and cannot use C++11.</p>\n", "Tags": "<c++><utf-16><stdstring>", "OwnerUserId": "140011", "AnswerCount": "2"}, "11086361": {"ParentId": "11086183", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>C++11 has this functionality:</p>\n<pre><code>std::string s = u8\"Hello, World!\";\n\n// #include &lt;codecvt&gt;\nstd::wstring_convert&lt;std::codecvt&lt;char16_t,char,std::mbstate_t&gt;,char16_t&gt; convert;\n\nstd::u16string u16 = convert.from_bytes(s);\nstd::string u8 = convert.to_bytes(u16);\n</code></pre>\n<p>However to my knowledge the only implementation that has this so far is libc++. C++11 also has <code>std::codecvt_utf8_utf16&lt;char16_t&gt;</code> which some other implementations have. Specifically, <code>codecvt_utf8_utf16</code> works in VS 2010 and above, and since wchar_t is used by Windows to represent UTF-16 you can use this to <a href=\"https://stackoverflow.com/a/11040983/365496\">convert between UTF-8 and Windows' native encoding</a>.</p>\n<hr>\n<blockquote>\n<p id=\"so_11086183_11086361_0\">The specialization <code>codecvt&lt;char16_t, char, mbstate_t&gt;</code> converts between the UTF-16 and UTF-8 encoding\n  schemes, and the specialization <code>codecvt&lt;char32_t, char, mbstate_t&gt;</code> converts between the UTF-32 and\n  UTF-8 encoding schemes.</p>\n<p id=\"so_11086183_11086361_1\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 [locale.codecvt] 22.4.1.4/3</em></p>\n</blockquote>\n<hr>\n<p>Oh, and std::codecvt specializations have protected destructors, and wstring_convert requires access to the destructor so you really need an adapter:</p>\n<pre><code>template &lt;class Facet&gt;\nclass usable_facet : public Facet {\npublic:\n    using Facet::Facet; // inherit constructors\n    ~usable_facet() {}\n\n    // workaround for compilers without inheriting constructors:\n    // template &lt;class ...Args&gt; usable_facet(Args&amp;&amp; ...args) : Facet(std::forward&lt;Args&gt;(args)...) {}\n};\n\ntemplate&lt;typename internT, typename externT, typename stateT&gt; \nusing codecvt = usable_facet&lt;std::codecvt&lt;internT, externT, stateT&gt;&gt;;\n\nstd::wstring_convert&lt;codecvt&lt;char16_t,char,std::mbstate_t&gt;&gt; convert;\n</code></pre>\n</hr></hr>", "OwnerUserId": "365496", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:24.620", "Id": "11086361", "Score": "10", "CreationDate": "2012-06-18T15:46:24.547", "LastActivityDate": "2012-06-18T16:23:42.377"}, "bq_ids": {"n4140": {"so_11086183_11086361_0": {"section_id": 6507, "quality": 0.8095238095238095, "length": 17}}, "n3337": {"so_11086183_11086361_0": {"section_id": 6262, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_11086183_11086361_0": {"section_id": 7989, "quality": 0.8095238095238095, "length": 17}}}, "11086502": {"ParentId": "11086183", "CommentCount": "0", "Body": "<p>Did you look at <a href=\"http://www.boost.org/doc/libs/1_49_0/libs/locale/doc/html/index.html\" rel=\"nofollow noreferrer\">Boost.Locale</a>?  <a href=\"http://www.boost.org/doc/libs/1_49_0/libs/locale/doc/html/charset_handling.html\" rel=\"nofollow noreferrer\">This page</a>, in particular, describes how to do UTF to UTF conversions and how to integrate it with IOStreams.</p>\n", "OwnerUserId": "67013", "PostTypeId": "2", "Id": "11086502", "Score": "4", "CreationDate": "2012-06-18T15:54:00.303", "LastActivityDate": "2012-06-18T15:54:00.303"}});