post_cb({"19578336": {"Id": "19578336", "PostTypeId": "2", "Body": "<p>I don't think the code is doing what you think it does. This line:</p>\n<pre><code>foo = reinterpret_cast&lt;void(*)()&gt;(Test());\n</code></pre>\n<p>means that you receive a <code>void*</code> from <code>Test()</code>. You then procede to <code>reinterpret_cast</code> this <strong>pointer-to-object</strong> into a <strong>pointer-to-function</strong>. This is not allowed and therefore the code yields undefined behavior and therefore any output of the compiler is valid.</p>\n<p>The relevant parts of the standard are</p>\n<blockquote>\n<h3>5.2.10 Reinterpret cast [expr.reinterpret.cast]</h3>\n<p id=\"so_19578237_19578336_0\"><sup>8</sup> Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning of such a conversion is implementation-defined, except that if an implementation supports conversions in both directions, converting a prvalue of one type to the other type and back, possibly with dierent cv- qualification, shall yield the original pointer value.</p>\n<p id=\"so_19578237_19578336_1\"><sup>9</sup> The null pointer value (4.10) is converted to the null pointer value of the destination type. [<em>Note:</em> A null pointer constant of type <code>std::nullptr_t</code> cannot be converted to a pointer type, and a null pointer constant of integral type is not necessarily converted to a null pointer value. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<h3>4.10 Pointer conversions [conv.ptr]</h3>\n<p id=\"so_19578237_19578336_2\"><sup>1</sup> A <em>null pointer constant</em> is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> <strong>of that type</strong> and is <strong>distinguishable from every other value of object pointer or function pointer type</strong>.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Here's a reduced test case taking <code>std::function</code> (and its possible bugs) out of the equation:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    using fp_t = void(*)();\n    void* vn = nullptr;\n    fp_t foo = reinterpret_cast&lt;fp_t&gt;(vn); // GCC: warning, Clang: silence\n    //fp_t foo = reinterpret_cast&lt;fp_t&gt;(nullptr); // error (GCC and Clang!)\n    std::cout &lt;&lt; !!foo &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1bc9722f228bdabb\" rel=\"nofollow\"><strong>Live example</strong></a></p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2013-10-25T06:18:20.853", "Score": "4", "CreationDate": "2013-10-24T23:09:41.280", "ParentId": "19578237", "CommentCount": "11", "LastEditDate": "2013-10-25T06:18:20.853", "OwnerUserId": "2073257"}, "bq_ids": {"n4140": {"so_19578237_19578336_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 6047}, "so_19578237_19578336_2": {"length": 29, "quality": 0.8055555555555556, "section_id": 39}, "so_19578237_19578336_1": {"length": 28, "quality": 0.8484848484848485, "section_id": 6048}}, "n3337": {"so_19578237_19578336_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 5815}, "so_19578237_19578336_2": {"length": 35, "quality": 0.9722222222222222, "section_id": 36}, "so_19578237_19578336_1": {"length": 28, "quality": 0.8484848484848485, "section_id": 5816}}, "n4659": {"so_19578237_19578336_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 7546}, "so_19578237_19578336_2": {"length": 29, "quality": 0.8055555555555556, "section_id": 39}, "so_19578237_19578336_1": {"length": 28, "quality": 0.8484848484848485, "section_id": 7547}}}, "19578652": {"Id": "19578652", "PostTypeId": "2", "Body": "<p>Looks like a bug to me. First, here's a <a href=\"http://ideone.com/QLw6E2\">simplified example</a> that doesn't play any games with casts:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\ntypedef void (*VF)();\n\nVF Test() {\n    return nullptr;\n}\n\nint main(int argc, char* argv[]) {\n    std::function&lt;void()&gt; foo(Test());\n    std::cout &lt;&lt; !!foo &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>It still prints 1 with GCC. It shouldn't:</p>\n<blockquote>\n<p id=\"so_19578237_19578652_0\"><strong>20.8.11.2.1</strong><br>\n<code>template&lt;class F&gt; function(F f);</code><br>\n<code>template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);</code><br>\n<strong>7</strong> <em>Requires:</em> <code>F</code>\n  shall be <code>CopyConstructible</code>. <code>f</code> shall be <code>Callable</code> (20.8.11.2) for\n  argument types <code>ArgTypes</code> and return type <code>R</code>. The copy constructor and\n  destructor of <code>A</code> shall not throw exceptions.<br>\n<strong>8</strong> <em>Postconditions:</em> <code>!*this</code>\n  if any of the following hold:</br></br></br></br></p>\n<ul>\n<li><code>f</code> is a <code>NULL</code> function pointer.</li>\n<li><code>f</code> is a <code>NULL</code> pointer to member.</li>\n<li><code>F</code> is an instance of the function class template, and <code>!f</code></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2013-10-24T23:39:24.677", "Score": "5", "CreationDate": "2013-10-24T23:39:24.677", "ParentId": "19578237", "CommentCount": "1", "OwnerUserId": "1670129"}, "19578237": {"ViewCount": "399", "Body": "<p>I'm using the standard function wrapper from the C++11 library, and I am seeing some strange behavior with its boolean operator. If I create a <code>std::function</code> object the boolean operator returns false. This is still true if I assign <code>nullptr</code> to the object and check again. The problem appears when I assign it a void pointer which I have cast into a function pointer. Consider the following program:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nvoid* Test() {\n    return nullptr;\n}\n\nint main(int argc, char* argv[]) {\n    std::function&lt;void()&gt; foo;\n    std::cout &lt;&lt; !!foo &lt;&lt; std::endl;\n\n    foo = nullptr;\n    std::cout &lt;&lt; !!foo &lt;&lt; std::endl;\n\n    foo = reinterpret_cast&lt;void(*)()&gt;(Test());\n    std::cout &lt;&lt; !!foo &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>What I expect as output is <code>0 0 0</code> but the result is <code>0 0 1</code> (see <a href=\"http://ideone.com/1JA0Zc\" rel=\"nofollow\">demo</a>). Can anyone explain why the boolean operator returns true when it contains a null, non-callable function pointer? And please also mention a workaround to check for <code>nullptr</code> in <code>std::function</code></p>\n<p>NOTE: I've already tried checking if the target is null (with <code>foo.target&lt;void*&gt;() == nullptr</code>) instead of using the boolean operator, but it seems as if no matter what the function object contains, the target is always null (even when the function object is perfectly fine with being called). </p>\n", "AcceptedAnswerId": "19578652", "Title": "Strange behavior with std::function", "CreationDate": "2013-10-24T22:58:56.663", "Id": "19578237", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-10-25T06:18:20.853", "Score": "4", "OwnerUserId": "976724", "Tags": "<c++><c++11><std-function>", "AnswerCount": "2"}});