post_cb({"bq_ids": {"n4140": {"so_48677746_48677990_4": {"length": 21, "quality": 0.6774193548387096, "section_id": 3296}, "so_48677746_48677990_2": {"length": 16, "quality": 1.0, "section_id": 3325}, "so_48677746_48677990_6": {"length": 17, "quality": 1.0, "section_id": 388}, "so_48677746_48677990_5": {"length": 7, "quality": 0.875, "section_id": 592}, "so_48677746_48677990_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 3287}}, "n3337": {"so_48677746_48677990_2": {"length": 15, "quality": 0.9375, "section_id": 3195}, "so_48677746_48677990_4": {"length": 21, "quality": 0.6774193548387096, "section_id": 3166}, "so_48677746_48677990_6": {"length": 17, "quality": 1.0, "section_id": 379}, "so_48677746_48677990_5": {"length": 7, "quality": 0.875, "section_id": 582}, "so_48677746_48677990_3": {"length": 14, "quality": 0.7368421052631579, "section_id": 3157}}, "n4659": {"so_48677746_48677990_4": {"length": 27, "quality": 0.8709677419354839, "section_id": 4048}, "so_48677746_48677990_6": {"length": 17, "quality": 1.0, "section_id": 405}, "so_48677746_48677990_2": {"length": 16, "quality": 1.0, "section_id": 4091}, "so_48677746_48677990_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 4070}, "so_48677746_48677990_5": {"length": 7, "quality": 0.875, "section_id": 615}, "so_48677746_48677990_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 4049}}}, "48677746": {"ViewCount": "567", "Body": "<p>This code compiles fine with GCC 5.X, MSVC, but GCC 6.X gives error:</p>\n<blockquote>\n<p id=\"so_48677746_48677746_0\"><em>\"converting to 'a' from initializer list would use explicit\n  constructor 'a::a()'\"</em>, clang <em>\"chosen constructor is explicit in\n  copy-initialization\"</em>.</p>\n</blockquote>\n<p>Removing <code>explicit</code> or changing to <code>a c{}</code> fixes the problem, but I`m curious why it works this way.</p>\n<pre><code>class a\n{\npublic:\n    explicit a () {}\n};\nstruct b\n{\n    a c;\n};\n\nint main() {\n    b d{};\n}\n</code></pre>\n", "Title": "Explicit default constructor", "CreationDate": "2018-02-08T04:48:12.783", "LastActivityDate": "2018-03-09T11:07:35.980", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-03-09T11:07:35.980", "LastEditorUserId": "8226643", "Id": "48677746", "Score": "18", "OwnerUserId": "8409995", "Tags": "<c++><c++11><c++14><language-lawyer>", "AnswerCount": "1"}, "48677990": {"Id": "48677990", "PostTypeId": "2", "Body": "<p><code>b</code> is an <a href=\"http://eel.is/c++draft/dcl.init.aggr#1\" rel=\"nofollow noreferrer\">aggregate</a>. When you initialize it using an initializer list, the elements in the list will initialize the first <em>n</em> members of the aggregate, where <em>n</em> is the number of elements in the list. The remaining elements of the aggregate are <em>copy-list-initialized</em>.</p>\n<p>So in your example, <code>c</code> will be <em>copy-list-initialized</em>, but that is ill-formed if the chosen constructor is <code>explicit</code>, hence the error.</p>\n<p>The relevant standard quotes are</p>\n<p><em><a href=\"http://eel.is/c++draft/dcl.init.aggr#3\" rel=\"nofollow noreferrer\">[dcl.init.aggr]/3</a></em></p>\n<blockquote>\n<p id=\"so_48677746_48677990_0\">When an aggregate is initialized by an initializer list as specified in [dcl.init.list], the elements of the initializer list are taken as initializers for the elements of the aggregate.\n  The <em>explicitly initialized</em> elements of the aggregate are determined as follows: <br>\n  ... <br>\n  \u2014 If the initializer list is an <em>initializer-list</em>, the explicitly initialized elements of the aggregate are the first <em>n</em> elements of the aggregate, where <em>n</em> is the number of elements in the initializer list.<br>\n  \u2014 Otherwise, the initializer list must be <code>{}</code>, and there are no explicitly initialized elements.</br></br></br></p>\n</blockquote>\n<p><em><a href=\"http://eel.is/c++draft/dcl.init.aggr#5\" rel=\"nofollow noreferrer\">[dcl.init.aggr]/5</a></em></p>\n<blockquote>\n<p id=\"so_48677746_48677990_1\">For a non-union aggregate, each element that is not an explicitly initialized element is initialized as follows:  <br>\n  ... <br>\n  \u2014 Otherwise, if the element is not a reference, the element is copy-initialized from an empty initializer list ([dcl.init.list]).</br></br></p>\n</blockquote>\n<p>The effect of copy initializing <code>c</code> from an empty initializer list is described in</p>\n<p><em><a href=\"http://eel.is/c++draft/dcl.init.list#3\" rel=\"nofollow noreferrer\">[dcl.init.list]/3</a></em></p>\n<blockquote>\n<p id=\"so_48677746_48677990_2\">List-initialization of an object or reference of type <code>T</code> is defined as follows: <br>\n  ... <br>\n  \u2014 Otherwise, if the initializer list has no elements and <code>T</code> is a class type with a default constructor, the object is value-initialized.</br></br></p>\n</blockquote>\n<p><em><a href=\"http://eel.is/c++draft/dcl.init#8\" rel=\"nofollow noreferrer\">[dcl.init]/8</a></em></p>\n<blockquote>\n<p id=\"so_48677746_48677990_3\">To <em>value-initialize</em> an object of type <code>T</code> means: <br>\n  ... <br>\n  \u2014 if <code>T</code> is a (possibly cv-qualified) class type with either no default constructor ([class.ctor]) or a default constructor that is user-provided or deleted, then the object is default-initialized;</br></br></p>\n</blockquote>\n<p><em><a href=\"http://eel.is/c++draft/dcl.init#7\" rel=\"nofollow noreferrer\">[dcl.init]/7</a></em></p>\n<blockquote>\n<p id=\"so_48677746_48677990_4\">To <em>default-initialize</em> an object of type <code>T</code> means: <br>\n  \u2014 If T is a (possibly cv-qualified) class type, constructors are considered. The applicable constructors are enumerated ([over.match.ctor]), and the best one for the initializer () is chosen through overload resolution. The constructor thus selected is called, with an empty argument list, to initialize the object.</br></p>\n</blockquote>\n<p><em><a href=\"http://eel.is/c++draft/over.match.ctor\" rel=\"nofollow noreferrer\">[over.match.ctor]</a></em></p>\n<blockquote>\n<p id=\"so_48677746_48677990_5\">... For copy-initialization, the candidate functions are all the converting constructors of that class.</p>\n</blockquote>\n<p><em><a href=\"http://eel.is/c++draft/class.conv.ctor#1\" rel=\"nofollow noreferrer\">[class.conv.ctor]/1</a></em></p>\n<blockquote>\n<p id=\"so_48677746_48677990_6\">A constructor declared without the <em>function-specifier</em> <code>explicit</code> specifies a conversion from the types of its parameters (if any) to the type of its class. Such a constructor is called a <em>converting constructor</em>.</p>\n</blockquote>\n<p>In the example above, <code>a</code> has no converting constructors, so overload resolution fails. The (non-normative) example in <em>[class.conv.ctor]/2</em> even contains a very similar case</p>\n<blockquote id=\"so_48677746_48677990_7\">\n<pre><code>  struct Z {\n    explicit Z();\n    explicit Z(int);\n    explicit Z(int, int);\n  };\n\n  Z c = {};                       // error: copy-list-initialization\n</code></pre>\n</blockquote>\n<hr>\n<p>You can avoid the error by providing a default member initializer for <code>c</code></p>\n<pre><code>struct b\n{\n    a c{};  // direct-list-initialization, explicit ctor is OK\n};\n</code></pre>\n</hr>", "LastEditorUserId": "241631", "LastActivityDate": "2018-02-13T20:57:05.553", "Score": "21", "CreationDate": "2018-02-08T05:10:23.303", "ParentId": "48677746", "CommentCount": "8", "OwnerUserId": "241631", "LastEditDate": "2018-02-13T20:57:05.553"}});