post_cb({"30474166": {"ParentId": "30473958", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-05-27T05:51:16.870", "Score": "7", "LastEditorUserId": "657267", "LastEditDate": "2015-05-27T06:57:15.470", "Id": "30474166", "OwnerUserId": "657267", "Body": "<p>[expr.unary.op]</p>\n<blockquote>\n<p id=\"so_30473958_30474166_0\">The operand of <code>~</code> shall have integral or unscoped enumeration type; the\n  result is the one\u2019s complement of\u3000its operand. <strong>Integral promotions are\n  performed.</strong></p>\n</blockquote>\n<p>[expr.shift]</p>\n<blockquote>\n<p id=\"so_30473958_30474166_1\">The shift operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> group left-to-right. [...] The operands shall be of integral or unscoped enumeration type and <strong>integral promotions are performed</strong>.</p>\n</blockquote>\n<p>What's the integral promotion of <code>uint8_t</code> (which is usually going to be <code>unsigned_char</code> behind the scenes)?</p>\n<p>[conv.prom]</p>\n<blockquote>\n<p id=\"so_30473958_30474166_2\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or\n  <code>wchar_t</code> whose integer conversion rank (4.13) is less than the rank of\n  <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all\n  the values of the source type; otherwise, the source prvalue can be\n  converted to a prvalue of type <code>unsigned int</code>.</p>\n</blockquote>\n<p>So <code>int</code>, because all of the values of a <code>uint8_t</code> can be represented by <code>int</code>.</p>\n<p>What is <code>int(12) &lt;&lt; 1</code> ? <code>int(24)</code>.</p>\n<p>What is <code>~int(12)</code> ? <code>int(-13)</code>.</p>\n", "LastActivityDate": "2015-05-27T06:57:15.470"}, "30474373": {"ParentId": "30473958", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2015-05-27T06:08:02.367", "Score": "4", "LastEditorUserId": "320726", "LastEditDate": "2015-05-27T06:33:23.937", "Id": "30474373", "OwnerUserId": "320726", "Body": "<p>For performance reasons the C and C++ language consider <code>int</code> to be the \"most natural\" integer type and instead types that are \"smaller\" than an <code>int</code> are considered sort of \"storage\" type.</p>\n<p>When you use a storage type in an expression it gets automatically converted to an <code>int</code> or to an <code>unsigned int</code> implicitly. For example:</p>\n<pre><code>// Assume a char is 8 bit\nunsigned char x = 255;\nunsigned char one = 1;\n\nint y = x + one; // result will be 256 (too large for a byte!)\n++x;             // x is now 0\n</code></pre>\n<p>what happened is that <code>x</code> and <code>one</code> in the first expression have been implicitly converted to integers, the addition has been computed and the result has been stored back in an integer. In other words the computation has NOT been performed using two unsigned chars.</p>\n<p>Likewise if you have a <code>float</code> value in an expression the first thing the compiler will do is promoting it to a <code>double</code> (in other words <code>float</code> is a storage type and <code>double</code> is instead the natural size for floating point numbers). This is the reason for which if you use <code>printf</code> to print floats you don't need to say <code>%lf</code> int the format strings and <code>%f</code> is enough (<code>%lf</code> is needed for <code>scanf</code> however because that function <strong>stores a result</strong> and a <code>float</code> can be smaller than a <code>double</code>).</p>\n<p>C++ complicated the matter quite a bit because when passing parameters to  functions you can discriminate between <code>int</code>s and smaller types. Thus it's not ALWAYS true that a conversion is performed in every expression... for example you can have:</p>\n<pre><code>void foo(unsigned char x);\nvoid foo(int x);\n</code></pre>\n<p>where</p>\n<pre><code>unsigned char x = 255, one = 1;\nfoo(x);       // Calls foo(unsigned char), no promotion\nfoo(x + one); // Calls foo(int), promotion of both x and one to int\n</code></pre>\n", "LastActivityDate": "2015-05-27T06:33:23.937"}, "30473958": {"CommentCount": "2", "ViewCount": "2350", "PostTypeId": "1", "LastEditorUserId": "4750730", "CreationDate": "2015-05-27T05:34:19.687", "LastActivityDate": "2015-05-27T06:57:15.470", "Title": "What is going on with bitwise operators and integer promotion?", "AcceptedAnswerId": "30474166", "LastEditDate": "2015-05-27T06:09:34.233", "Id": "30473958", "Score": "9", "Body": "<p>I have a simple program. <strong><em>Notice that I use an unsigned fixed-width integer 1 byte in size.</em></strong></p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main()\n{\n    uint8_t x = 12;\n    std::cout &lt;&lt; (x &lt;&lt; 1) &lt;&lt; '\\n';\n    std::cout &lt;&lt; ~x;\n\n    std::cin.clear();\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n    std::cin.get();\n\n    return 0;\n}\n</code></pre>\n<p>My output is the following.</p>\n<pre><code>24\n-13\n</code></pre>\n<p><em>I tested larger numbers and operator <code>&lt;&lt;</code> always gives me positive numbers, while operator <code>~</code> always gives me negative numbers. I then used <code>sizeof()</code> and found...</em></p>\n<blockquote>\n<p id=\"so_30473958_30473958_0\"><em>When I use the left shift bitwise operator(<code>&lt;&lt;</code>), I receive an unsigned 4 byte integer.</em></p>\n<p id=\"so_30473958_30473958_1\"><em>When I use the bitwise not operator(<code>~</code>), I receive a signed 4 byte integer.</em></p>\n</blockquote>\n<p>It seems that the bitwise not operator(<code>~</code>) does a signed integral promotion like the arithmetic operators do. However, the left shift operator(<code>&lt;&lt;</code>) seems to promote to an unsigned integral.</p>\n<p>I feel obligated to know when the compiler is changing something behind my back. If I'm correct in my analysis, do all the bitwise operators promote to a 4 byte integer? And why are some signed and some unsigned? I'm so confused!</p>\n<p><strong>Edit:</strong> My assumption of always getting positive or always getting negative values was wrong. But from being wrong, I understand what was really happening thanks to the great answers below.</p>\n", "Tags": "<c++><bitwise-operators><unsigned-integer><integer-promotion><signed-integer>", "OwnerUserId": "4750730", "AnswerCount": "4"}, "30474020": {"ParentId": "30473958", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-05-27T05:39:58.217", "Score": "2", "LastEditorUserId": "2193734", "LastEditDate": "2015-05-27T06:06:36.690", "Id": "30474020", "OwnerUserId": "2193734", "Body": "<p>Look into <a href=\"http://en.wikipedia.org/wiki/Two%27s_complement\" rel=\"nofollow\">two's complement</a> and how computer stores negative integers.<br>\nTry this  </br></p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\nint main()\n{\nuint8_t x = 1;\nint shiftby=0;\nshiftby=8*sizeof(int)-1;\nstd::cout &lt;&lt; (x &lt;&lt; shiftby) &lt;&lt; '\\n'; // or std::cout &lt;&lt; (x &lt;&lt; 31) &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; ~x;\n\nstd::cin.clear();\nstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\nstd::cin.get();\nreturn 0;\n}\n</code></pre>\n<p>The output is -2147483648</p>\n<p>In general if the first bit of a signed number is 1 it is considered negative. when you take a large number and shift it. If you shift it so that the first bit is 1 it will be negative</p>\n<p><b> ** EDIT ** </b><br>\nWell I can think of a reason why shift operators would use unsigned int. Consider right shift operation <code>&gt;&gt;</code> if you right shift -12 you will get <strong>122</strong> instead of -6. This is because it adds a zero in the beginning without considering the sign</br></p>\n", "LastActivityDate": "2015-05-27T06:06:36.690"}, "30474339": {"ParentId": "30473958", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-05-27T06:05:07.823", "Score": "3", "LastEditorUserId": "153285", "LastEditDate": "2015-05-27T06:19:56.217", "Id": "30474339", "OwnerUserId": "719263", "Body": "<blockquote>\n<p id=\"so_30473958_30474339_0\">I tested larger numbers and operator &lt;&lt; always gives me positive\n  numbers, while operator ~ always gives me negative numbers. I then\n  used sizeof() and found...</p>\n</blockquote>\n<p>Wrong, test it:</p>\n<pre><code>uint8_t v = 1;\nfor (int i=0; i&lt;32; i++) cout &lt;&lt; (v&lt;&lt;i) &lt;&lt; endl;\n</code></pre>\n<p>gives:</p>\n<pre><code>1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n1048576\n2097152\n4194304\n8388608\n16777216\n33554432\n67108864\n134217728\n268435456\n536870912\n1073741824\n-2147483648\n</code></pre>\n<p><code>uint8_t</code> is an 8-bit long unsigned integer type, which can represent values in the range [0,255], as that range in included in the range of <code>int</code> it is promoted to <code>int</code> (not <code>unsigned int</code>). Promotion to <code>int</code> has precedence over promotion to <code>unsigned</code>.</p>\n", "LastActivityDate": "2015-05-27T06:19:56.217"}, "bq_ids": {"n4140": {"so_30473958_30474166_1": {"section_id": 6146, "quality": 0.8571428571428571, "length": 12}, "so_30473958_30474166_2": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_30473958_30474166_0": {"section_id": 6073, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_30473958_30474166_1": {"section_id": 5909, "quality": 0.8571428571428571, "length": 12}, "so_30473958_30474166_2": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}, "so_30473958_30474166_0": {"section_id": 5841, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_30473958_30474166_1": {"section_id": 7642, "quality": 0.8571428571428571, "length": 12}, "so_30473958_30474166_2": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_30473958_30474166_0": {"section_id": 7569, "quality": 0.9333333333333333, "length": 14}}}});