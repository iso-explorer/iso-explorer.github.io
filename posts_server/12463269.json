post_cb({"12463335": {"ParentId": "12463269", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Returning a lambda that captures a local variable by reference is the same as returning a reference to a local variable directly; it results in undefined behaviour:</p>\n<blockquote>\n<h3>5.1.2 Lambda expressions [expr.prim.lambda]</h3>\n<p id=\"so_12463269_12463335_0\">22 - [ Note: If an entity is implicitly or explicitly captured by reference, invoking the function call operator of the corresponding lambda-expression after the lifetime of the entity has ended is likely to result in undefined behavior. \u2014end note ]</p>\n</blockquote>\n<p>Specifically, the undefined behaviour in this case is in lvalue-to-rvalue conversion:</p>\n<blockquote>\n<h3>4.1 Lvalue-to-rvalue conversion [conv.lval]</h3>\n<p id=\"so_12463269_12463335_1\">1 - A glvalue (3.10) of a non-function, non-array type T can be converted to a prvalue.\n  If T is an incomplete type, a program that necessitates this conversion is ill-formed. If the object to which the glvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior.</p>\n</blockquote>\n<p>The compiler is not required to diagnose this form of undefined behaviour, although as compiler support for lambdas improves it is likely that compilers will be able to diagnose this case and offer an appropriate warning.</p>\n<p>Since lambda closure types are well defined, just opaque, your example is equivalent to:</p>\n<pre><code>struct lambda {\n    int &amp;y;\n    lambda(int &amp;y): y(y) {};\n    int operator()(int toAdd) {\n        y += toAdd;\n        return y;\n    };\n} f{y};\nreturn f;\n</code></pre>\n<p>In general terms, C++ solves the <a href=\"http://en.wikipedia.org/wiki/Funarg_problem\" rel=\"noreferrer\">funarg problem</a> by making it the responsibility of the programmer and providing facilities (mutable lambda capture, move semantics, <code>unique_ptr</code> etc.) to allow the programmer to solve it efficiently.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-09-17T17:21:56.873", "Id": "12463335", "Score": "10", "CreationDate": "2012-09-17T16:21:33.563", "LastActivityDate": "2012-09-17T17:21:56.873"}, "bq_ids": {"n4140": {"so_12463269_12463335_0": {"section_id": 5982, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_12463269_12463335_1": {"section_id": 5, "quality": 0.9629629629629629, "length": 26}, "so_12463269_12463335_0": {"section_id": 5750, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_12463269_12463335_0": {"section_id": 7479, "quality": 0.8636363636363636, "length": 19}}}, "12463269": {"CommentCount": "1", "AcceptedAnswerId": "12463335", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-09-17T16:17:39.000", "LastActivityDate": "2012-09-18T18:19:01.253", "LastEditDate": "2012-09-18T18:19:01.253", "ViewCount": "1184", "FavoriteCount": "1", "Title": "C++11 Lambda closure involving a stack variable by reference that leaves scope is allowed but getting undefined behavior?", "Id": "12463269", "Score": "4", "Body": "<p>I know C++ fairly well.  I have used lambdas and closures in other languages.  For my learning, I wanted to see what I could do with these in C++.  </p>\n<p>Fully knowing the \"danger\" and expecting the compiler to reject this, I created a lambda in a function using a function stack variable by reference and returned the lambda.  The compiler allowed it and strange things occurred.</p>\n<p>Why did the compiler allow this?  Is this just a matter of the compiler not being able to detect that I did something very, very bad and the results are just \"undefined behavior\"?  Is this a compiler issue?  Does the spec have anything to say about this?</p>\n<p>Tested on a recent mac, with MacPorts-installed gcc 4.7.1 and the -std=c++11 compile option.</p>\n<p>Code used:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// This is the same as actsWicked() except for the commented out line\nfunction&lt;int (int)&gt; actsStatic() {\n  int y = 0;\n  // cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; \" at creation\" &lt;&lt; endl;\n\n  auto f = [&amp;y](int toAdd) {\n    y += toAdd;\n    return y;\n   };\n  return f;\n}\n\nfunction&lt;int (int)&gt; actsWicked() {\n  int y = 0;\n  cout &lt;&lt; \"actsWicked: y = \" &lt;&lt; y &lt;&lt; \" at creation\" &lt;&lt; endl;\n\n  auto f = [&amp;y](int toAdd) {\n    y += toAdd;\n    return y;\n   };\n  return f;\n}\n\nvoid test(const function&lt;int (int)&gt;&amp; f, const int arg, const int expected) {\n  const int result = f(arg);\n  cout &lt;&lt; \"arg: \" &lt;&lt; arg\n       &lt;&lt; \" expected: \" &lt;&lt; expected &lt;&lt; \" \"\n       &lt;&lt; (expected == result ? \"=\" : \"!\") &lt;&lt; \"= \"\n       &lt;&lt; \"result: \" &lt;&lt; result &lt;&lt; endl;\n}\n\nint main(int argc, char **argv) {\n\n  auto s = actsStatic();\n  test(s, 1, 1);\n  test(s, 1, 2);\n  test(actsStatic(), 1, 1);\n  test(s, 1, 3);\n\n  auto w = actsWicked();\n  test(w, 1, 1);\n  test(w, 1, 2);\n  test(actsWicked(), 1, 1);\n  test(w, 1, 3);\n\n  return 0;\n}\n</code></pre>\n<p>Results:</p>\n<pre><code>arg: 1 expected: 1 == result: 1\narg: 1 expected: 2 == result: 2\narg: 1 expected: 1 != result: 3\narg: 1 expected: 3 != result: 4\nactsWicked: y = 0 at creation\narg: 1 expected: 1 == result: 1\narg: 1 expected: 2 == result: 2\nactsWicked: y = 0 at creation\narg: 1 expected: 1 == result: 1\narg: 1 expected: 3 != result: 153207395\n</code></pre>\n", "Tags": "<c++><lambda><c++11>", "OwnerUserId": "1663621", "AnswerCount": "1"}});