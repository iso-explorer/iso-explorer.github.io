post_cb({"bq_ids": {"n4140": {"so_44089539_44089539_1": {"length": 44, "quality": 0.8979591836734694, "section_id": 382}}, "n3337": {"so_44089539_44089539_1": {"length": 44, "quality": 0.8979591836734694, "section_id": 373}}, "n4659": {"so_44089539_44089539_1": {"length": 45, "quality": 0.9183673469387755, "section_id": 397}}}, "44089539": {"ViewCount": "88", "Body": "<ul>\n<li>Background:</li>\n</ul>\n<p>I noticed that the signature of std::max is:</p>\n<p><strong>template&lt;typename T&gt;<br/>\nconst T&amp; max(const T&amp;, const T&amp;);</strong></p>\n<p>and I wondered about the implications of returning a reference to a const\nT...</p>\n<p>If we pass in two L-values, it makes sense we could return a reference to\none of the two. But if we pass in two PR-values, what is being returned and\nis it a safe thing to use?</p>\n<h1>Problem:</h1>\n<p>I spoke with some colleagues and here is a minimal working example of the\nissue: <a href=\"http://cpp.sh/4en4\" rel=\"nofollow noreferrer\">http://cpp.sh/4en4</a></p>\n<pre><code>#include &lt;iostream&gt;\nint glob = 100;\nclass temp{\n  int* val;\npublic:\n  temp(int n = 0){\n    val = new int(n);\n  }\n  void print() const{ std::cout &lt;&lt; \"I store \" &lt;&lt; *val &lt;&lt; std::endl; }\n  ~temp(){\n    std::cout &lt;&lt; \"temp object died\" &lt;&lt; std::endl;\n    delete val;\n    val = &amp;glob;\n  }\n};\nconst temp&amp; foo(const temp&amp; a){\n  return a;    \n}\n\nint main(){\n  const temp&amp; b = foo(2); \n  std::cout &lt;&lt; \"Is it safe?\" &lt;&lt; std::endl;\n  b.print(); \n}\n</code></pre>\n<p>Without optimization:</p>\n<pre>temp object died\nIs it safe?\nI store 100</pre>\n<p>With moderate:</p>\n<pre>temp object died\nIs it safe?\nI store -1992206527</pre>\n<p>Running this with different levels of optimization gives different\nresults. In all cases, though, it seems that returning the reference does\nnot prolong the lifetime of the local object; its desctructor is still\ncalled, although in one case we seem to recover a reference to the\ndestroyed object and in the other, we seem to have a dangling pointer.</p>\n<h1>The Standard:</h1>\n<p>Quoting from the C++ Standard, document number N4618:</p>\n<blockquote>\n<p id=\"so_44089539_44089539_0\">12.2 item 6:</p>\n<p id=\"so_44089539_44089539_1\">... when a reference is bound to a temporary. The temporary to which the\n  reference is\n  bound or the temporary that is the complete object of a subobject to which\n  the reference is bound persists\n  for the lifetime of the reference except: <br/>\n  (6.1) \u2014 A temporary object bound to a reference parameter in a function\n  call (5.2.2) persists until the completion\n  of the full-expression containing the call. <br/>\n  (6.2) \u2014 The lifetime of a temporary bound to the returned value in a\n  function return statement (6.6.3) is not\n  extended; the temporary is destroyed at the end of the full-expression in\n  the return statement.\"</p>\n</blockquote>\n<p>From (6.1), it would seem a temporary foo(2) should exist for the entire\nstatement that initializes b.</p>\n<p>From (6.2), it would seem that the local 'a' gets destroyed, which\nactually destroys the temporary foo(2), resulting in b taking on a\ndestructed value.</p>\n<h1>My Questions:</h1>\n<p>1a. What is the full-expression that contains the temporary generated by\n<code>foo(2)</code> in <code>const temp&amp; b = foo(2);</code></p>\n<p>1b. Can a 2nd const reference extend the lifetime of a temporary?</p>\n<ol start=\"2\">\n<li>Why is std::max implemented as such, given the apparent danger?</li>\n</ol>\n", "Title": "Can a Second Const Reference Extend the Lifetime of a Temporary", "CreationDate": "2017-05-20T18:38:45.870", "LastActivityDate": "2017-11-18T23:29:42.677", "CommentCount": "9", "LastEditDate": "2017-11-18T23:29:42.677", "PostTypeId": "1", "LastEditorUserId": "1366368", "Id": "44089539", "Score": "1", "OwnerUserId": "8041641", "Tags": "<c++><temporary-objects><const-reference><prvalue>", "AnswerCount": "0"}});