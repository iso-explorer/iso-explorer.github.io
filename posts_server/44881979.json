post_cb({"44881979": {"CommentCount": "9", "ViewCount": "58", "CreationDate": "2017-07-03T09:23:05.063", "LastActivityDate": "2017-07-03T10:21:35.333", "Title": "heterogeneous containers lookup in C++98", "AcceptedAnswerId": "44883041", "PostTypeId": "1", "Id": "44881979", "Score": "1", "Body": "<p>In a project I'm working on, I'm forced to use c++98. Having the need to perform fast lookups in certain vectors of structures, using only a few elements of those structures as keys, I have so far happily been passing to <code>std::lower_bound</code> and <code>std::upper_bound</code> a <code>value</code> parameter with a type different than those structure's and a comparison functor that would handle this heterogeneous case properly.</p>\n<p>It all works as expected, but today I suddenly realized this might not be allowed by the standard, and I found confirmation of this hunch in a few papers, like <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1313.html\" rel=\"nofollow noreferrer\">this one</a> which also proposes an amendment to the standard which, I'm learning now, has been implemented in C++0x, as <a href=\"http://umich.edu/~eecs381/handouts/HeteroLookup.pdf\" rel=\"nofollow noreferrer\">this other paper confirms</a>.</p>\n<p><strong>My question is</strong>: is the fact my code works as expected, <strong>despite NOT abiding by the letter of the standard</strong>, a mere coincidence, a side-effect of the specific implementation, a non-guaranteed result should I change compiler and whatnot? </p>\n<p>In other words, should I really really really change my code to be standard-compliant (which would greatly complicate it), or can I just not bother and let it be, considering this codebase is not going to be compiled with anything else but g++ for the time being?</p>\n", "Tags": "<c++><comparison><containers><c++-standard-library><c++98>", "OwnerUserId": "566849", "AnswerCount": "1"}, "44883041": {"ParentId": "44881979", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Only you can decide if keeping the status quo is worth the risk. However, if you move to <code>C++11</code>, the wording has changed to allow for what you are doing. </p>\n<p>I would think it is rather unlikely compiler vendors will change how their Standard Library works for an old version of the Standard. So I can't see that it is very likely that your <code>C++98</code> code will break unless you move it to an untested compiler. And even if that happened, you could always implement your own (drop-in-replacement) version of <code>std::lower_bound</code> to accomodate.</p>\n<p>According to my reading of the <code>C++11</code> Standard you are fine.</p>\n<blockquote>\n<p id=\"so_44881979_44883041_0\"><strong>25.4.3.1</strong> lower_bound <strong>[</strong> lower.bound <strong>]</strong></p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\nForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);\n\ntemplate&lt;class ForwardIterator, class T, class Compare&gt;\nForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);\n</code></pre>\n<p id=\"so_44881979_44883041_1\"><strong>1</strong> Requires: The elements e of [first,last) shall be partitioned with respect to the expression e &lt;\n  value or comp(e, value).</p>\n<p id=\"so_44881979_44883041_2\"><strong>2</strong> Returns: The furthermost iterator i in the range [first,last] such that for any iterator j in the range [first,i) the following corresponding conditions hold: *j &lt; value or comp(*j, value) != false.</p>\n<p id=\"so_44881979_44883041_3\"><strong>3</strong> Complexity: At most log 2 (last \u2212 f irst) + O(1) comparisons.</p>\n</blockquote>\n<p>Requirement <strong>2</strong> does not dictate that <code>value</code> be of the same type as <code>*e</code>.</p>\n<p>Also the document you reference says:</p>\n<blockquote>\n<p id=\"so_44881979_44883041_4\">But is it legal? The standard's position on this question is not encouraging. For one thing, 25.3 says that for the algorithms to work correctly, the comparison object has to induce a strict weak ordering on the values.</p>\n</blockquote>\n<p>This comes from the <code>C++03</code> Standard and is <strong>not</strong> the wording I find in the <code>C++11</code> Standard which states this:</p>\n<blockquote>\n<p id=\"so_44881979_44883041_5\"><strong>25.4</strong> Sorting and related operations <strong>[</strong> alg.sorting <strong>]</strong></p>\n<p id=\"so_44881979_44883041_6\"><strong>3</strong> For all algorithms that take Compare, there is a version that uses operator&lt; instead. That is, comp(*i,\n  *j) != false defaults to *i &lt; *j != false. For algorithms other than those described in <strong>25.4.3</strong> to work correctly, comp has to induce a strict weak ordering on the values.</p>\n</blockquote>\n<p>It gives a clear exemption to the algorithm used by <code>std::lower_bound</code>:</p>\n<blockquote>\n<p id=\"so_44881979_44883041_7\"><strong>25.4.3</strong> Binary search <strong>[</strong> alg.binary.search <strong>]</strong></p>\n<p id=\"so_44881979_44883041_8\"><strong>1</strong> All of the algorithms in this section are versions of binary search and assume that the sequence being searched is partitioned with respect to an expression formed by binding the search key to an argument of the implied or explicit comparison function.</p>\n</blockquote>\n<p>This wording allows \"an argument\" to the comparison function to be of different type to the container elements. It simply needs to match the \"search key\".</p>\n", "OwnerUserId": "3807729", "LastEditorUserId": "3807729", "LastEditDate": "2017-07-03T10:21:35.333", "Id": "44883041", "Score": "1", "CreationDate": "2017-07-03T10:15:49.323", "LastActivityDate": "2017-07-03T10:21:35.333"}, "bq_ids": {"n4140": {"so_44881979_44883041_8": {"section_id": 1421, "quality": 1.0, "length": 22}, "so_44881979_44883041_2": {"section_id": 1423, "quality": 0.7777777777777778, "length": 14}, "so_44881979_44883041_6": {"section_id": 1395, "quality": 0.8666666666666667, "length": 26}, "so_44881979_44883041_1": {"section_id": 1422, "quality": 0.7, "length": 7}}, "n3337": {"so_44881979_44883041_8": {"section_id": 1415, "quality": 1.0, "length": 22}, "so_44881979_44883041_1": {"section_id": 1416, "quality": 0.7, "length": 7}, "so_44881979_44883041_6": {"section_id": 1389, "quality": 0.8666666666666667, "length": 26}, "so_44881979_44883041_2": {"section_id": 1417, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_44881979_44883041_8": {"section_id": 1541, "quality": 1.0, "length": 22}, "so_44881979_44883041_2": {"section_id": 1543, "quality": 0.7777777777777778, "length": 14}, "so_44881979_44883041_6": {"section_id": 1513, "quality": 0.8, "length": 24}, "so_44881979_44883041_1": {"section_id": 1542, "quality": 0.7, "length": 7}}}});