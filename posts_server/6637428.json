post_cb({"8598106": {"ParentId": "6637428", "CommentCount": "0", "CreationDate": "2011-12-22T00:30:08.273", "OwnerUserId": "985139", "PostTypeId": "2", "Id": "8598106", "Score": "0", "Body": "<p>The consensus seemed to be that this was a legitimate bug in gcc.  Since I saw no indication a bug report had been filed, I'm doing so now.  The report can be viewed at:</p>\n<p><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51651\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51651</a></p>\n", "LastActivityDate": "2011-12-22T00:30:08.273"}, "6637568": {"ParentId": "6637428", "CommentCount": "3", "CreationDate": "2011-07-09T21:25:04.840", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6637568", "Score": "2", "Body": "<p><code>eof()</code> should only return true if you have already attempted to read past the end. In neither case should it be true. This may be a bug in your implementation.</p>\n", "LastActivityDate": "2011-07-09T21:25:04.840"}, "6637428": {"CommentCount": "4", "ViewCount": "407", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-07-09T20:59:11.407", "LastActivityDate": "2011-12-22T00:30:08.273", "Title": "Different EOF behavior with read versus ignore", "FavoriteCount": "1", "LastEditDate": "2011-07-09T22:13:11.267", "Id": "6637428", "Score": "5", "Body": "<p>I was recently just tripped up by a subtle distinction between the behavior of <code>std::istream::read</code> versus <code>std::istream::ignore</code>.  Basically, <code>read</code> extracts N bytes from the input stream, and stores them in a buffer.  The <code>ignore</code> function extracts N bytes from the input stream, but simply discards them rather than storing them in a buffer.  So, my understanding was that <code>read</code> and <code>ignore</code> are basically the same in every way, except for the fact that <code>read</code> saves the extracted bytes whereas <code>ignore</code> just discards them.</p>\n<p>But there is another subtle difference between <code>read</code> and <code>ignore</code> which managed to trip me up.  If you read to the end of a stream, the EOF condition is not triggered.  You have to read <em>past</em> the end of a stream in order for the EOF condition to be triggered.  But with ignore it is different: you only need to read to the <em>end</em> of a stream.</p>\n<p>Consider:</p>\n<pre><code>#include &lt;sstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    {\n        std::stringstream ss;\n        ss &lt;&lt; \"abcd\";\n        char buf[1024];\n        ss.read(buf, 4);\n        std::cout &lt;&lt; \"EOF: \" &lt;&lt; std::boolalpha &lt;&lt; ss.eof() &lt;&lt; std::endl;\n    }\n\n    {\n        std::stringstream ss;\n        ss &lt;&lt; \"abcd\";\n        ss.ignore(4);\n        std::cout &lt;&lt; \"EOF: \" &lt;&lt; std::boolalpha &lt;&lt; ss.eof() &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>On GCC 4.4.5, this prints out:</p>\n<pre><code>EOF: false\nEOF: true\n</code></pre>\n<p>So, why is the behavior different here?  This subtle difference managed to confuse me enough to wonder why there is a difference.  Is there some compelling reason that EOF is triggered \"early\" with a call to ignore?</p>\n", "Tags": "<c++><iostream>", "OwnerUserId": "469408", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_6637428_6637643_0": {"section_id": 2232, "quality": 0.8571428571428571, "length": 18}}, "n3337": {"so_6637428_6637643_0": {"section_id": 2220, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_6637428_6637643_0": {"section_id": 2505, "quality": 0.8095238095238095, "length": 17}}}, "6637643": {"ParentId": "6637428", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I'm going to go out on a limb here and answer my own question:  it really looks like this is a bug in GCC.</p>\n<p>The standard reads in 27.6.1.3 paragraph 23:</p>\n<blockquote>\n<p id=\"so_6637428_6637643_0\">[istream::ignore] behaves as an\n  <strong>unformatted input function</strong> (as\n  described in 27.6.1.3, paragraph 1). \n  After constructing a sentry object,\n  extracts characters and discards them.\n  Characters are extracted until any of\n  the following occurs:</p>\n<ul>\n<li>if n != numeric_limits::max()\n  (18.2.1), n characters are extracted</li>\n<li>end-of-file occurs on the input sequence (in which case the function\n  calls setstate(eofbit), which may\n  throw ios_base::failure(27.4.4.3));</li>\n<li>c == delim for the next available input character c (in which case c is\n  extracted). Note: The last condition\n  will never occur if delim ==\n  traits::eof()</li>\n</ul>\n</blockquote>\n<p>My (somewhat tentative) interpretation is that GCC is wrong here, because of the bold parts above.  Ignore should behave as an <em>unformatted input function</em>, (like <code>read()</code>), which means that end-of-file should only occur on the input sequence if there is an attempt to extract additional bytes <em>after</em> the last byte in the stream has been extracted.</p>\n<p>I'll submit a bug report if I find that enough people agree with this answer.</p>\n", "OwnerUserId": "469408", "LastEditorUserId": "469408", "LastEditDate": "2011-07-09T21:58:01.673", "Id": "6637643", "Score": "2", "CreationDate": "2011-07-09T21:40:25.193", "LastActivityDate": "2011-07-09T21:58:01.673"}});