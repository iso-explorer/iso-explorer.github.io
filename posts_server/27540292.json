post_cb({"bq_ids": {"n4140": {"so_27540292_27540394_1": {"length": 24, "quality": 0.7272727272727273, "section_id": 37}}, "n3337": {"so_27540292_27540394_1": {"length": 24, "quality": 0.7272727272727273, "section_id": 34}}, "n4659": {"so_27540292_27540394_1": {"length": 22, "quality": 0.6666666666666666, "section_id": 37}}}, "27540394": {"Id": "27540394", "PostTypeId": "2", "Body": "<p>The problem is your datatype - your function <code>double Product_2np1(int k)</code> returns <code>double</code> while <code>prod</code> is an <code>int</code>. I do not know which compiler you are using (maybe Turbo C) - but you should have got at least a warning regarding this. Normally the type conversion happens from smaller to larger - hence is think the result here i undefined - see this <a href=\"http://ideone.com/KEXXWh\" rel=\"nofollow\">Sample on Ideone</a>. The problem is that we are trying a forced conversion from <code>int</code> to <code>double</code> which is the problem.</p>\n<pre><code>#include &lt;cstdio&gt;\n\nint main()\n{\n    printf(\"%lf\", 2);\n    printf(\"\\n%lf\", 2.0);\n    return 0; \n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Success time: 0 memory: 3340 signal:0\n0.000000\n2.000000\n</code></pre>\n<p>From the C standard (1999):<br>\n<strong>6.3.1.4 Real floating and integer</strong> </br></p>\n<blockquote>\n<p id=\"so_27540292_27540394_0\">1 When a finite value of real floating type is converted to an integer\n  type other than _Bool, the fractional part is discarded (i.e., the\n  value is truncated toward zero). If the value of the integral part\n  cannot be represented by the integer type, the behavior is undefined.</p>\n</blockquote>\n<p>From the C++ standard (2003):  </p>\n<blockquote>\n<p id=\"so_27540292_27540394_1\"><strong>4.9 Floating-integral conversions [conv.fpint]</strong>   1 An rvalue of a floating point type can be converted to an rvalue of an integer type.\n  The conversion truncates; that is, the fractional part is discarded.\n  The behavior is undefined if the truncated value cannot be represented\n  in the destination type. [Note: If the destination type is bool, see\n  4.12. ]</p>\n</blockquote>\n", "LastEditorUserId": "418729", "LastActivityDate": "2014-12-18T06:50:13.697", "Score": "0", "CreationDate": "2014-12-18T06:24:25.467", "ParentId": "27540292", "CommentCount": "10", "OwnerUserId": "418729", "LastEditDate": "2014-12-18T06:50:13.697"}, "27540292": {"ViewCount": "74", "Body": "<p>I wrote this  small function that will take and integer <em>k</em>, and return the product:</p>\n<p><strong>2(0)+1 <sup>.</sup> 2(1)+1 <sup>.</sup> 2(2)+1 <sup>.</sup> ... 2n+1 || for n=0,n&lt;(k/2)-1</strong>\nif  <em>k</em> is even, (or 0, I'm not sure if technically zero is an even number) And 0 if k is odd. </p>\n<p>This was part of a larger project but I was able to isolate the problem to this function, and I pulled it out to try and figure out what was going on. Here is my function. </p>\n<pre><code>double Product_2np1(int k)\n {\n    int prod = 1;\n    if(k % 2 == 0)\n      {\n       for(int n = 0; n &lt;(k/2);n++){\n       prod = prod * ((2*n)+ 1);\n      }\n      return prod;\n    }else return 0;\n }\n\n\nint main(){\n    for(int i=0; i&lt;5;i++)\n       {\n         std::cout &lt;&lt;\"k= \" &lt;&lt; i&lt;&lt; \"==&gt;\" &lt;&lt; Product_2np1(i) &lt;&lt; std::endl;\n       }\nreturn 0; \n}\n</code></pre>\n<p>The output: </p>\n<ul>\n<li>k= 0 ==&gt; 2.64619e-260</li>\n<li>k= 1 ==&gt; 0</li>\n<li>k= 2 ==&gt; 2.64619e-260</li>\n<li>k= 3 ==&gt; 0</li>\n<li>k= 4 ==&gt; 2.64619e-260</li>\n<li>k= 5 ==&gt; 0</li>\n</ul>\n<p>Now this was nonsense to me, so I went back into the function and threw in some prints to see what was going on. Changing <code>Product_2np1</code> to this:</p>\n<pre><code>double Product_2np1(int k)\n {\n    int prod = 1;\n    if(k % 2 == 0)\n      {\n       for(int n = 0; n &lt;(k/2);n++){\n       std::cout &lt;&lt; \"(2*\" &lt;&lt; n &lt;&lt; \")+ 1)\" &lt;&lt;std:endl;\n      }\n      return 1;\n    }else return 0;\n }\n</code></pre>\n<p>and In main I only had the k=4 case evaluate:</p>\n<pre><code>int main(){\n     Product_2np1(4);\nreturn 0; \n}\n</code></pre>\n<p>This gave me the output:</p>\n<ul>\n<li>2(0)+1</li>\n<li>2(1)+1</li>\n</ul>\n<p>Using my handy-dandy TI-86 I punched this in to make sure I wasn't loosing it and I get</p>\n<ul>\n<li>2(0)+1 = 0+1 =1 </li>\n<li>2(1)+1 = 2+1 =3 </li>\n</ul>\n<p>and multiplying those together should give me 3, not 2.64619e-260. </p>\n<p>So I have to ask you folks what could possibly be going on here? </p>\n", "AcceptedAnswerId": "27540394", "Title": "How could this loop print the correct statement then evaluate it incorrectly?", "CreationDate": "2014-12-18T06:15:17.870", "Id": "27540292", "CommentCount": "1", "LastEditDate": "2014-12-18T06:39:24.127", "PostTypeId": "1", "LastEditorUserId": "3750079", "LastActivityDate": "2014-12-18T06:50:13.697", "Score": "0", "OwnerUserId": "3750079", "Tags": "<c++><algorithm>", "AnswerCount": "1"}});