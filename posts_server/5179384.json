post_cb({"5179384": {"CommentCount": "0", "AcceptedAnswerId": "5182960", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2011-03-03T10:20:40.567", "LastActivityDate": "2012-11-06T23:13:09.910", "LastEditDate": "2012-11-06T23:13:09.910", "ViewCount": "1631", "FavoriteCount": "0", "Title": "What happens with adjacent string literal concatenation when there is a modifier(L, u8, etc.)", "Id": "5179384", "Score": "8", "Body": "<p>It is valid in C\u00a0and C++ to break a string literal because the preprocessor or the compiler will\nconcatenate adjacent string literals.</p>\n<pre><code>const char *zStr = \"a\" \"b\"; // valid\n</code></pre>\n<p>What happens when string literals are prefixed with <code>L</code> (wide characters), <code>u</code> (UTF-16), <code>U</code> (UTF-32), <code>u8</code> (UTF-8), and raw string literals (<code>R\"foo(this is a \"raw string literal\" with double quotes)foo\"</code>)?</p>\n<p>For example, is the following allowed:</p>\n<pre><code>const wchar_t *zStr = L\"a\" \"b\"; // valid?\n</code></pre>\n", "Tags": "<c++><c++11><string-literals>", "OwnerUserId": "457352", "AnswerCount": "2"}, "5179432": {"ParentId": "5179384", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Yes, that particular example is allowed by C++0x. Any combination of prefixless and L-prefixed literals will be treated as though all are L-prefixed.</p>\n<p>EDIT: Citation -- N3242 (current C++0x working draft) \u00a72.14.5/13:</p>\n<blockquote>\n<p id=\"so_5179384_5179432_0\">In translation phase 6 (2.2), adjacent string literals are concatenated. If both string literals have the same encoding-prefix, the resulting concatenated string literal has that encoding-prefix. If one string literal has no encoding-prefix, it is treated as a string literal of the same encoding-prefix as the other operand.</p>\n</blockquote>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2011-03-03T19:19:08.797", "Id": "5179432", "Score": "2", "CreationDate": "2011-03-03T10:25:23.697", "LastActivityDate": "2011-03-03T19:19:08.797"}, "bq_ids": {"n4140": {"so_5179384_5182960_1": {"section_id": 5362, "quality": 0.8181818181818182, "length": 9}, "so_5179384_5179432_0": {"section_id": 5362, "quality": 1.0, "length": 28}, "so_5179384_5182960_0": {"section_id": 5362, "quality": 1.0, "length": 11}}, "n3337": {"so_5179384_5182960_1": {"section_id": 5158, "quality": 0.8181818181818182, "length": 9}, "so_5179384_5179432_0": {"section_id": 5158, "quality": 1.0, "length": 28}, "so_5179384_5182960_0": {"section_id": 5158, "quality": 1.0, "length": 11}}, "n4659": {"so_5179384_5182960_1": {"section_id": 6786, "quality": 0.8181818181818182, "length": 9}, "so_5179384_5179432_0": {"section_id": 6786, "quality": 0.7142857142857143, "length": 20}, "so_5179384_5182960_0": {"section_id": 6786, "quality": 0.7272727272727273, "length": 8}}}, "5182960": {"ParentId": "5179384", "CommentCount": "7", "Body": "<p>In C++0x your example is valid according to [lex.string]/p13:</p>\n<blockquote>\n<p id=\"so_5179384_5182960_0\">... If one string literal has no\n  encoding-prefix, it is treated as a\n  string literal of the same\n  encoding-prefix as the other operand.\n  ...</p>\n</blockquote>\n<p>In C++03 this same section said that this code had undefined behavior:</p>\n<blockquote>\n<p id=\"so_5179384_5182960_1\">... If a narrow string literal token\n  is adjacent to a wide string literal\n  token, the behavior is undefined. ...</p>\n</blockquote>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "5182960", "Score": "11", "CreationDate": "2011-03-03T15:41:00.393", "LastActivityDate": "2011-03-03T15:41:00.393"}});