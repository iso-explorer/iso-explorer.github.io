post_cb({"33694305": {"Id": "33694305", "PostTypeId": "2", "Body": "<p>This seems to be a bug; with the explicit using declaration, Clang has to consider the base overload. There's no reason for it not to.</p>\n<p>Your code isn't correct, though, because there's no reason to prefer the restricted version to the base version when both are valid, so I believe you should get an ambiguity error if you pass something that isn't default-constructible.</p>\n", "LastActivityDate": "2015-11-13T13:53:37.653", "CommentCount": "0", "CreationDate": "2015-11-13T13:53:37.653", "ParentId": "33694192", "Score": "2", "OwnerUserId": "8922"}, "bq_ids": {"n4140": {"so_33694192_33696684_5": {"length": 10, "quality": 1.0, "section_id": 5504}, "so_33694192_33696684_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 5504}, "so_33694192_33696684_3": {"length": 10, "quality": 1.0, "section_id": 5504}, "so_33694192_33696684_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6991}}, "n3337": {"so_33694192_33696684_5": {"length": 10, "quality": 1.0, "section_id": 5290}, "so_33694192_33696684_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 5290}, "so_33694192_33696684_3": {"length": 10, "quality": 1.0, "section_id": 5290}}, "n4659": {"so_33694192_33696684_5": {"length": 7, "quality": 0.7, "section_id": 6938}, "so_33694192_33696684_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 6938}, "so_33694192_33696684_3": {"length": 7, "quality": 0.7, "section_id": 6938}, "so_33694192_33696684_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 8489}}}, "33696684": {"Id": "33696684", "PostTypeId": "2", "Body": "<p>Consider \u00a710.2:</p>\n<blockquote>\n<p id=\"so_33694192_33696684_0\">In the declaration set, <strong><em>using-declaration</em>s are replaced by the set of\n  designated members that are not</strong> hidden or <strong>overridden by members of the\n  derived class (7.3.3),</strong></p>\n</blockquote>\n<p>And \u00a77.3.3 goes </p>\n<blockquote>\n<p id=\"so_33694192_33696684_1\">When a <em>using-declaration</em> brings names from a base class into a derived class scope, [\u2026] <strong>member function templates in the derived class override and/or hide member functions and member function templates with the same name, <em>parameter-type-list</em> (8.3.5 [dcl.fct]), cv-qualification, and <em>ref-qualifier</em> (if any) in a base class (rather than conflicting).</strong></p>\n</blockquote>\n<p>Clearly, the only difference in your example lies within the return types. Thus Clang is correct and GCC is bugged.</p>\n<p>The wording was introduced by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1764\"><strong>CWG #1764</strong></a>:</p>\n<blockquote>\n<p id=\"so_33694192_33696684_2\">According to 7.3.3 [namespace.udecl] paragraph 15,</p>\n<blockquote>\n<p id=\"so_33694192_33696684_5\">When a using-declaration brings names from a base class into a derived class scope, [\u2026]</p>\n</blockquote>\n<p id=\"so_33694192_33696684_4\">The algorithm for class-scope name lookup given in 10.2\n  [class.member.lookup], however, does not implement this requirement;\n  there is nothing that removes a hidden base class member (replacing\n  the <em>using-declaration</em>, per paragraph 3) from the result set.</p>\n</blockquote>\n<p>The resolution was moved to DR in February 2014, so perhaps GCC didn't implement it yet.</p>\n<hr>\n<p>As mentioned in @TartanLlama's answer, you can introduce a counterpart to handle the other case. Something along the lines of</p>\n<pre><code>template &lt;typename Arg, typename=std::enable_if_t&lt;std::is_constructible&lt;Arg&gt;{}&gt;&gt;\ndecltype(auto) foo(Arg a) const\n{\n    return T::foo(a);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b6af626f82c1a2d6\"><strong>Demo</strong></a>.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-13T15:58:31.083", "Score": "6", "CreationDate": "2015-11-13T15:52:55.877", "ParentId": "33694192", "CommentCount": "5", "OwnerUserId": "3647361", "LastEditDate": "2015-11-13T15:58:31.083"}, "33694192": {"ViewCount": "147", "Body": "<p>After having hitten problems with another design, I decided make make a wrapper class to add overloads to a some member functions of the base class if and only if viable overloads do not already exist in the base class. Basically, here is what I am trying to do:</p>\n<pre><code>template&lt;typename T&gt;\nstruct wrapper: T\n{\n    using T::foo;\n\n    template&lt;typename Arg&gt;\n    auto foo(Arg) const\n        -&gt; std::enable_if_t&lt;not std::is_constructible&lt;Arg&gt;::value, bool&gt;\n    {\n        return false;\n    }\n};\n\nstruct bar\n{\n    template&lt;typename Arg&gt;\n    auto foo(Arg) const\n        -&gt; bool\n    {\n        return true;\n    }\n};\n</code></pre>\n<p>In this simple example, <code>wrapper</code> adds an overloaded <code>foo</code> only if the one from the base class is not viable (I simplified the <code>std::enable_if</code> to the simplest possible thing; the original one involved the detection idiom). However, g++ and clang++ disagree. Take the following <code>main</code>:</p>\n<pre><code>int main()\n{\n    assert(wrapper&lt;bar&gt;{}.foo(0));\n}\n</code></pre>\n<p>g++ is ok with it: the <code>foo</code> from <code>wrapper&lt;bar&gt;</code> is SFINAEd out so it uses the one from <code>bar</code> instead. On the other hand, <a href=\"http://coliru.stacked-crooked.com/a/c8d0b90de78b0d71\">clang++ seems to assume</a> that  <code>wrapper&lt;bar&gt;::foo</code> <em>always</em> shadows <code>bar::foo</code>, even when SFINAEd out. Here is the error message:</p>\n<blockquote id=\"so_33694192_33694192_0\">\n<pre><code>main.cpp:30:26: error: no matching member function for call to 'foo'\n    assert(wrapper&lt;bar&gt;{}.foo(0));\n       ~~~~~~~~~~~~~~~^~~\n\n/usr/include/assert.h:92:5: note: expanded from macro 'assert'\n  ((expr)                                                               \\\n        ^\n\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/type_traits:2388:44: note: candidate template ignored: disabled by 'enable_if' [with Arg = int]\n    using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;\n                                               ^\n\n1 error generated.\n</code></pre>\n</blockquote>\n<p>So, who is right? Should this code be rejected just like clang++ does, or should it work and call <code>bar::foo</code>?</p>\n", "AcceptedAnswerId": "33696684", "Title": "Does a SFINAEd-out function shadows an explicitly imported overload from the base class", "CreationDate": "2015-11-13T13:46:35.173", "Id": "33694192", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-11-13T15:58:31.083", "Score": "10", "OwnerUserId": "1364752", "Tags": "<c++><c++11><language-lawyer><sfinae><shadowing>", "AnswerCount": "3"}, "33694480": {"Id": "33694480", "PostTypeId": "2", "Body": "<p>As @SebastianRedl says, this looks like a clang bug (Edit: looks like we were <a href=\"https://stackoverflow.com/a/33696684/496161\">wrong</a>).</p>\n<p>Regardless of which compiler is correct, a possible workaround would be to define two versions of <code>wrapper&lt;T&gt;::foo</code>: one for when <code>T::foo</code> does not exist, which provides a custom implementation; and one for when it does, which forwards the call to the base version:</p>\n<pre><code>template&lt;typename T&gt;\nstruct wrapper: T\n{\n    template&lt;typename Arg, typename U=T&gt;\n    auto foo(Arg) const\n        -&gt; std::enable_if_t&lt;!has_foo&lt;U&gt;::value, bool&gt;\n    {\n        return false;\n    }\n\n    template&lt;typename Arg, typename U=T&gt;\n    auto foo(Arg a) const\n        -&gt; std::enable_if_t&lt;has_foo&lt;U&gt;::value, bool&gt;\n    {\n        return T::foo(a); //probably want to perfect forward a\n    }\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/52aa6c80df23dd85\" rel=\"nofollow noreferrer\"><kbd>Live Demo</kbd></a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-13T15:55:53.597", "Score": "1", "CreationDate": "2015-11-13T14:02:06.987", "ParentId": "33694192", "CommentCount": "0", "OwnerUserId": "496161", "LastEditDate": "2017-05-23T11:53:14.777"}});