post_cb({"47195509": {"ParentId": "46909105", "CommentCount": "14", "Body": "<p><strong>The question is meaningless. Sorry.</strong> This is the only \"lawyer\" answer possible.</p>\n<p>It is meaningless because the C++ and the C language ignore each others, as they ignore anything else.</p>\n<p>Nothing in either language is described in term of low level implementation (which is ridiculous for languages often described as \"high level assembly\"). Both C and C++ are specified (if you can call that a specification) at a very abstract level, and the high and low levels are never reconnected. This generates endless debates about what undefined behaviors means in practice, how unions work, etc.</p>\n", "OwnerUserId": "963864", "PostTypeId": "2", "Id": "47195509", "Score": "3", "CreationDate": "2017-11-09T06:44:01.447", "LastActivityDate": "2017-11-09T06:44:01.447"}, "47200415": {"ParentId": "46909105", "CommentCount": "0", "Body": "<p>I can identify two parts of this question that should be addressed separately.</p>\n<hr>\n<h2>Object lifetime</h2>\n<blockquote>\n<p id=\"so_46909105_47200415_0\">It has been established (see below) placement new is required to create objects</p>\n</blockquote>\n<p>I posit that this area of the standard contains ambiguity, omission, contradiction, and/or gratuitous incompatibility with existing practice, and should therefore be considered <strong>broken</strong>. </p>\n<p>The only people who should be interested in what a broken part of the standard actually says are the people responsible for fixing the breakage. Other people (language users and language implementors alike) should defer to existing practice and common sense. Both of which say that one does not need <code>new</code> to create an <code>int</code>, <code>malloc</code> is enough.</p>\n<p><a href=\"https://wg21.link/P0593R1\" rel=\"nofollow noreferrer\">This document</a> identifies the problem and proposes a fix (thanks @T.C. for the link)</p>\n<hr>\n<h2>C compatibility</h2>\n<blockquote>\n<p id=\"so_46909105_47200415_1\">Assume int is the same for C and C++</p>\n</blockquote>\n<p>It is not enough to assume that.</p>\n<p>One also needs to assume that <code>int*</code> is the same, that the same memory is accessible by C and C++ functions linked together in a program, and that the C++ implementation does not define the semantics of calls to functions written in the C programming language to be wiping your hard drive and stealing your girlfriend. In other words, that C and C++ implementations are <em>compatible enough</em>.</p>\n<p>None of this is stipulated by the standard or should be assumed.\nIndeed, there are C implementations that are incompatible with each other, so they cannot be both compatible with the same C++ implementation. </p>\n<p>The only thing the standard says is \"Every implementation shall provide for linkage to functions written in the C programming language\" (dcl.link) What is the semantics of such linkage is left undefined. </p>\n<p>Here, as before, the best course of action is to defer to existing practice and common sense. Both of which say that a C++ implementation usually comes bundled with a <em>compatible enough</em> C implementation, with the linkage working as one would expect.</p>\n</hr></hr>", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "47200415", "Score": "4", "CreationDate": "2017-11-09T11:14:27.203", "LastActivityDate": "2017-11-09T11:14:27.203"}, "46909105": {"CommentCount": "12", "ViewCount": "407", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2017-10-24T11:15:21.493", "LastActivityDate": "2017-11-09T14:09:27.420", "Title": "Existence of objects created in C functions", "FavoriteCount": "2", "LastEditDate": "2017-10-26T08:06:02.593", "Id": "46909105", "Score": "18", "Body": "<p>It has been established (see below) placement <code>new</code> is required to create objects</p>\n<pre><code>int* p = (int*)malloc(sizeof(int));\n*p = 42;  // illegal, there isn't an int\n</code></pre>\n<p>Yet that is a pretty standard way of creating objects in C.</p>\n<p>The question is, does the <code>int</code> exist if it is created in C, and returned to C++?</p>\n<p>In other words, is the following guaranteed to be legal? Assume <code>int</code> is the same for C and C++.</p>\n<p>foo.h</p>\n<pre><code>#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint* foo(void);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>foo.c</p>\n<pre><code>#include \"foo.h\"\n#include &lt;stdlib.h&gt;\n\nint* foo(void) {\n    return malloc(sizeof(int));\n}\n</code></pre>\n<p>main.cpp</p>\n<pre><code>#include \"foo.h\"\n#include&lt;cstdlib&gt;\n\nint main() {\n    int* p = foo();\n    *p = 42;\n    std::free(p);\n}\n</code></pre>\n<p>Links to discussions on mandatory nature of placement <code>new</code>:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/41624685/is-placement-new-legally-required-for-putting-an-int-into-a-char-array\">Is placement new legally required for putting an int into a char array?</a></li>\n<li><a href=\"https://stackoverflow.com/a/46841038/4832499\">https://stackoverflow.com/a/46841038/4832499</a></li>\n<li><a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/rt2ivJnc4hg/Lr541AYgCQAJ\" rel=\"noreferrer\">https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/rt2ivJnc4hg/Lr541AYgCQAJ</a></li>\n<li><a href=\"https://www.reddit.com/r/cpp/comments/5fk3wn/undefined_behavior_with_reinterpret_cast/dal28n0/\" rel=\"noreferrer\">https://www.reddit.com/r/cpp/comments/5fk3wn/undefined_behavior_with_reinterpret_cast/dal28n0/</a></li>\n<li><a href=\"https://stackoverflow.com/questions/40873520/reinterpret-cast-creating-a-trivially-default-constructible-object/40874245#40874245\">reinterpret_cast creating a trivially default-constructible object</a></li>\n</ul>\n", "Tags": "<c++><c><language-lawyer><object-lifetime>", "OwnerUserId": "4832499", "AnswerCount": "5"}, "46909166": {"ParentId": "46909105", "LastEditDate": "2017-11-09T07:46:38.850", "CommentCount": "1", "CreationDate": "2017-10-24T11:18:02.617", "OwnerUserId": "817643", "LastEditorUserId": "817643", "PostTypeId": "2", "Id": "46909166", "Score": "4", "Body": "<p>Yes! But only because <code>int</code> is a fundamental type. Its initialization is vacuous operation:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.init#7\" rel=\"nofollow noreferrer\">[dcl.init]/7</a>:</p>\n<blockquote>\n<p id=\"so_46909105_46909166_0\">To default-initialize an object of type T means:</p>\n<ul>\n<li><p id=\"so_46909105_46909166_1\">If T is a (possibly cv-qualified) class type, constructors are considered. The applicable constructors are enumerated\n  ([over.match.ctor]), and the best one for the initializer () is chosen\n  through overload resolution. The constructor thus selected is called,\n  with an empty argument list, to initialize the object.</p></li>\n<li><p id=\"so_46909105_46909166_2\">If T is an array type, each element is default-initialized.</p></li>\n<li><p id=\"so_46909105_46909166_3\"><strong>Otherwise, no initialization is performed.</strong></p></li>\n</ul>\n</blockquote>\n<p>Emphasis mine. Since \"not initializing\" an <code>int</code> is akin to default initialing it, it's lifetime begins once storage is allocated:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.life#1\" rel=\"nofollow noreferrer\">[basic.life]/1</a>:</p>\n<blockquote>\n<p id=\"so_46909105_46909166_4\">The lifetime of an object or reference is a runtime property of the\n  object or reference. An object is said to have non-vacuous\n  initialization if it is of a class or aggregate type and it or one of\n  its subobjects is initialized by a constructor other than a trivial\n  default constructor. The lifetime of an object of type T begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object has non-vacuous initialization, its initialization is complete,</li>\n</ul>\n</blockquote>\n<p>Allocation of storage can be done in any way acceptable by the C++ standard. Yes, even just calling <code>malloc</code>. Compiling C code with a C++ compiler would be a very bad idea otherwise. And yet, <a href=\"https://isocpp.org/wiki/faq/mixing-c-and-cpp#overview-mixing-langs\" rel=\"nofollow noreferrer\">the C++ FAQ has been suggesting it for years</a>.</p>\n<hr>\n<p>In addition, since the <a href=\"https://timsong-cpp.github.io/cppwp/n4659/memory#c.malloc-2\" rel=\"nofollow noreferrer\">C++ standard</a> defers to the <a href=\"http://port70.net/~nsz/c/c11/n1570.html#7.22.3.4p2\" rel=\"nofollow noreferrer\">C standard</a> where <code>malloc</code> is concerned. I think that wording should be brought forth as well. And here it is:</p>\n<p><strong>7.22.3.4 The malloc function - Paragraph 2</strong>:</p>\n<blockquote>\n<p id=\"so_46909105_46909166_5\">The malloc function allocates space for an object whose size is\n  specified by size and whose value is indeterminate.</p>\n</blockquote>\n<p>The \"value is indeterminate\" part kinda indicates there's an object there. Otherwise, how could it have any value, let alone an indeterminate one?</p>\n</hr>", "LastActivityDate": "2017-11-09T07:46:38.850"}, "46910105": {"ParentId": "46909105", "LastEditDate": "2017-11-09T14:09:27.420", "CommentCount": "20", "CreationDate": "2017-10-24T12:03:47.370", "OwnerUserId": "3435400", "LastEditorUserId": "3435400", "PostTypeId": "2", "Id": "46910105", "Score": "0", "Body": "<p>No, the <code>int</code> does not exist, as explained in the linked Q/As. An important standard quote reads like this in C++14:</p>\n<blockquote>\n<p id=\"so_46909105_46910105_0\"><strong>1.8 The C ++ object model [intro.object]</strong><br>\n<em>[...]</em> An object is created by a definition (3.1), by a new-expression (5.3.4) or by the\n  implementation (12.2) when needed. <em>[...]</em></br></p>\n</blockquote>\n<p>(12.2 is a paragraph about temporary objects)</p>\n<p>The C++ standard has no rules for interfacing C and C++ code. A C++ compiler can only analyze objects created by C++ code, but not some bits passed to it form an external source like a C program, or a network interface, etc.</p>\n<p>Many rules are tailored to make optimizations possible. Some of them are only possible if the compiler does not have to assume uninitialized memory contains valid objects. For example, the rule that one may not read an uninitialized <code>int</code> would not make sense otherwise, because if <code>int</code>s may exist anywhere, why would it be illegal to read an indeterminate <code>int</code> value?</p>\n<p>This would be a standard compliant way to write the program:</p>\n<pre><code>int main() {\n    void* p = foo();\n    int i = 42;\n    memcpy(p, &amp;i, sizeof(int));\n    //std::free(p);   //this works only if C and C++ use the same heap.\n}\n</code></pre>\n", "LastActivityDate": "2017-11-09T14:09:27.420"}, "46913207": {"ParentId": "46909105", "LastEditDate": "2017-10-25T06:52:55.163", "CommentCount": "14", "CreationDate": "2017-10-24T14:29:21.500", "OwnerUserId": "8631381", "LastEditorUserId": "8631381", "PostTypeId": "2", "Id": "46913207", "Score": "4", "Body": "<p>I think the question is badly posed. In C++ we only have the concepts of translation units and linkage, the latter simply meaning under which circumstances names declared in different TUs refer to the same entity or not.</p>\n<p>Nothing is virtually said about the linking process as such, the correctness of which must be guaranteed by the compiler/linker anyway; even if the code snippets above were purely C++ sources (with malloc replaced with a nice new int) the result would be still implementation defined ( eg. consider object files compiled with incompatible compiler options/ABIs/runtimes ).</p>\n<p>So, either we talk in full generality and conclude that any program made of more than one TU is potentially wrong or we must take for granted that the linking process is 'valid' ( only the implementation knows ) and hence take for granted that <em>if</em> a function from some source language ( in this case C ) primises to return a 'pointer to an existing int' then the the same function in the destination language (C++) must still be a 'pointer to an existing int' (otherwise, following [dcl.link], we could't say that the linkage has been 'achieved', returning to the <em>no man's land</em>).</p>\n<p>So, in my opinion, the real problem is assessing what an 'existing' int is in C and C++, comparatively. As I read the correponding standards, in both languages an int lifetime basically begins when its storage is reserved for it: in the OP case of an allocated(in C)/dynamic(in c++) storage duration object, this occurs (on C side) when the effective type of the lvalue *pointer_to_int becomes int (eg. when it's assigned a value; until then, the not-yet-an-int may trap(*)).</p>\n<p>This does not happen in the OP case, the malloc result has no effective type yet. So, that int does not exist neither in C nor in C++, it's just a reinterpreted pointer.</p>\n<p>That said, the c++ part of the OP code assigns just after returning from foo(); if this was intended, then we could say that given that malloc() in C++ is required having C semantics, a placement new on the c++ side would suffice to make it valid (as the provided links show).</p>\n<p>So, summarizing, either the C code should be fixed to return a pointer to an existing int (by assigning to it) or the c++ code should be fixed by adding placement new. (sorry for the lengthy arguing ... :))\n<hr>\n(*) here I'm not claiming that the <em>only</em> issue is the existence of trap representation; if it were, one could argue that the result of foo() is an indeterminate value on C++ side, hence something that you can safely assign to. Clearly this is not the case because there are also aliasing rules to take into account ...</hr></p>\n", "LastActivityDate": "2017-10-25T06:52:55.163"}, "bq_ids": {"n4140": {"so_46909105_46909166_0": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_46909105_46909166_2": {"section_id": 3286, "quality": 1.0, "length": 5}, "so_46909105_46910105_0": {"section_id": 5790, "quality": 0.6153846153846154, "length": 8}, "so_46909105_46909166_1": {"section_id": 3296, "quality": 0.7037037037037037, "length": 19}, "so_46909105_46909166_4": {"section_id": 7189, "quality": 0.78125, "length": 25}}, "n3337": {"so_46909105_46909166_0": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_46909105_46909166_2": {"section_id": 3156, "quality": 1.0, "length": 5}, "so_46909105_46910105_0": {"section_id": 5563, "quality": 0.6153846153846154, "length": 8}, "so_46909105_46909166_1": {"section_id": 3166, "quality": 0.7037037037037037, "length": 19}, "so_46909105_46909166_4": {"section_id": 6933, "quality": 0.78125, "length": 25}}, "n4659": {"so_46909105_46909166_2": {"section_id": 4048, "quality": 1.0, "length": 5}, "so_46909105_46909166_1": {"section_id": 4048, "quality": 0.8888888888888888, "length": 24}, "so_46909105_46909166_4": {"section_id": 8697, "quality": 0.875, "length": 28}}}});