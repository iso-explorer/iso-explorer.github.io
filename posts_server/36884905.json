post_cb({"36884905": {"CommentCount": "8", "ViewCount": "87", "CreationDate": "2016-04-27T08:54:06.443", "LastActivityDate": "2016-04-27T09:24:39.577", "Title": "Recursive descent parser, initialization of variable with itself, dilemma", "PostTypeId": "1", "Id": "36884905", "Score": "2", "Body": "<p>I want to know whether conforming C++ compiler is required to support the following code:</p>\n<pre><code>int a(a);      // no other a is visible, we mean initialization of a with itself\n</code></pre>\n<p>Visual Studio 2013 does not support it (undeclared identifier), however some other compilers compile it.</p>\n<p>And here is our dilemma: for possible expression check we need to dispose information about <code>a</code> (including its type) since it can be part of expression, however there is another possibility that it is function, in this case we are only constructing type expression (and symbol <code>a</code> is probably not in the symbol table yet).</p>\n<p>I think that recursive descent parser is more likely to run in this dilemma, since it is very structural in nature and supporting this specific case will be like a special 'crutch' (type expression is being constructed when we encounter <code>a</code> inside <code>()</code> and we are at some level of recursion). So I assume that visual studio uses recursive descent strategy.</p>\n<p>So with all this in mind, whether it is worth compiler writer's effort and whether it is justified to support such code (especially when using recursive descent)?</p>\n", "Tags": "<c++><parsing><ambiguity><recursive-descent>", "OwnerUserId": "1812165", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36884905_36885464_0": {"section_id": 7049, "quality": 0.8235294117647058, "length": 14}, "so_36884905_36885464_1": {"section_id": 7049, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_36884905_36885464_0": {"section_id": 6794, "quality": 0.8235294117647058, "length": 14}, "so_36884905_36885464_1": {"section_id": 6794, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_36884905_36885464_0": {"section_id": 8546, "quality": 0.8235294117647058, "length": 14}, "so_36884905_36885464_1": {"section_id": 8546, "quality": 0.7777777777777778, "length": 7}}}, "36885464": {"ParentId": "36884905", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>[basic.scope.pdecl]</p>\n<blockquote>\n<p id=\"so_36884905_36885464_0\">The <em>point of declaration</em> for a name is immediately after its complete\n  declarator (Clause 8) and before its <em>initializer</em> (if any), except as\n  noted below. [ <em>Example:</em></p>\n<pre><code>unsigned char x = 12;\n{ unsigned char x = x; }\n</code></pre>\n<p id=\"so_36884905_36885464_1\">Here the second x is initialized with its own (indeterminate) value. <em>\u2014end example</em>]</p>\n</blockquote>\n<p>In <code>int a(a);</code>, the declarator ends at the opening brace of the initializer, so yes, compilers are required to allow this (GCC helpfully gives an <code>-Wuninitialized</code> warning if it's an automatic variable).</p>\n", "OwnerUserId": "657267", "LastEditorUserId": "657267", "LastEditDate": "2016-04-27T09:24:39.577", "Id": "36885464", "Score": "1", "CreationDate": "2016-04-27T09:18:37.013", "LastActivityDate": "2016-04-27T09:24:39.577"}});