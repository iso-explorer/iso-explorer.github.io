post_cb({"21567291": {"ViewCount": "8446", "Body": "<p>I have the following piece of code that prompts the user for their name and state:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    std::string name;\n    std::string state;\n\n    if (std::cin &gt;&gt; name &amp;&amp; std::getline(std::cin, state))\n    {\n        std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and you live in \" &lt;&lt; state;\n    }\n}\n</code></pre>\n<p>What I find is that the name has been successfully extracted, but not the state. Here is the input and resulting output:</p>\n<blockquote id=\"so_21567291_21567291_0\">\n<pre><code>Input:\n\n\"John\"\n\"New Hampshire\"\n\nOutput:\n\n\"Your name is John and you live in \"\n</code></pre>\n</blockquote>\n<p>Why has the name of the state been omitted from the output? I've given the proper input, but the code somehow ignores it. Why does this happen?</p>\n", "Title": "Why does std::getline() skip input after a formatted extraction?", "CreationDate": "2014-02-05T02:01:25.903", "LastActivityDate": "2016-12-23T16:02:16.907", "CommentCount": "0", "FavoriteCount": "32", "PostTypeId": "1", "LastEditDate": "2016-12-23T16:02:16.907", "LastEditorUserId": "1413395", "Id": "21567291", "Score": "61", "OwnerUserId": "701092", "Tags": "<c++><input><iostream><istream><c++-faq>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_21567291_21567292_3": {"length": 17, "quality": 1.0, "section_id": 2182}}, "n3337": {"so_21567291_21567292_3": {"length": 17, "quality": 1.0, "section_id": 2170}}, "n4659": {"so_21567291_21567292_3": {"length": 17, "quality": 1.0, "section_id": 2455}}}, "21567292": {"Id": "21567292", "PostTypeId": "2", "Body": "<h1>Why does this happen?</h1>\n<p>This has little to do with the input you provided yourself but rather with the default behavior <code>std::getline()</code> exhibits. When you provided your input for the name (<code>std::cin &gt;&gt; name</code>), you not only submitted the following characters, but also an implicit newline was appended to the stream:</p>\n<blockquote id=\"so_21567291_21567292_0\">\n<pre><code>\"John\\n\"\n</code></pre>\n</blockquote>\n<p>A newline is always appended to your input when you select <kbd>Enter</kbd> or <kbd>Return</kbd> when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into <code>name</code> until the next I/O operation where it is either discarded or consumed. When the flow of control reaches <code>std::getline()</code>, the newline will be discarded, but the input will cease immediately. The reason this happens is because the default functionality of this function dictates that it should (it attempts to read a line and stops when it finds a newline).</p>\n<p>Because this leading newline inhibits the expected functionality of your program, it follows that it must be skipped our ignored somehow. One option is to call <code>std::cin.ignore()</code> after the the first extraction. It will discard the next available character so that the newline is no longer intrusive.</p>\n<hr>\n<h1>In-Depth Explanation:</h1>\n<p>This is the overload of <code>std::getline()</code> that you called:</p>\n<blockquote id=\"so_21567291_21567292_1\">\n<pre><code>template&lt;class charT&gt;\nstd::basic_istream&lt;charT&gt;&amp; getline( std::basic_istream&lt;charT&gt;&amp; input,\n                                    std::basic_string&lt;charT&gt;&amp; str )\n</code></pre>\n</blockquote>\n<p>Another overload of this function takes a delimiter of type <code>charT</code>. A delimiter character is a character that represents the boundary between sequences of input. This particular overload sets the delimiter to the newline character <code>input.widen('\\n')</code> by default since one was not supplied.</p>\n<p>Now, these are a few of the conditions whereby <code>std::getline()</code> terminates input:</p>\n<ul>\n<li>If the stream has extracted the maximum amount of characters a <code>std::basic_string&lt;charT&gt;</code> can hold</li>\n<li>If the end-of-file (EOF) character has been found</li>\n<li>If the delimiter has been found</li>\n</ul>\n<p>The third condition is the one we're dealing with. Your input into <code>state</code> is represented thusly:</p>\n<blockquote id=\"so_21567291_21567292_2\">\n<pre><code>\"John\\nNew Hampshire\"\n     ^\n     |\n next_pointer\n</code></pre>\n</blockquote>\n<p>where <code>next_pointer</code> is the next character to be parsed. Since the character stored at the next position in the input sequence is the delimiter, <code>std::getline()</code> will quietly discard that character, increment <code>next_pointer</code> to the next available character, and stop input. This means that the rest of the characters that you have provided still remain in the buffer for the next I/O operation. You'll notice that if you perform another read from the line into <code>state</code>, your extraction will yield the correct result as the last call to <code>std::getline()</code> discarded the delimiter.</p>\n<hr>\n<p>You may have noticed that you don't typically run into this problem when extracting with the formatted input operator (<code>operator&gt;&gt;()</code>). This is because input streams use whitespace as delimiters for input and have the <code>std::skipws</code><sup>1</sup> manipulator set on by default. Streams will discard the leading whitespace from the stream when beginning to perform formatted input.<sup>2</sup></p>\n<p>Unlike the formatted input operators, <code>std::getline()</code> is an <em>unformatted</em> input function. And all unformatted input functions have the following code somewhat in common:</p>\n<pre><code>typename std::basic_istream&lt;charT&gt;::sentry ok(istream_object, true);\n</code></pre>\n<p>The above is a sentry object which is instantiated in all formatted/unformatted I/O functions in a standard C++ implementation. Sentry objects are used for preparing the stream for I/O and determining whether or not it is in a fail state. You'll only find that in the <em>unformatted</em> input functions, the second argument to the sentry constructor is <code>true</code>. That argument means that leading whitespace will <em>not</em> be discarded from the beginning of the input sequence. Here is the relevant quote from the Standard [\u00a727.7.2.1.3/2]:</p>\n<blockquote>\n<pre><code> explicit sentry(basic_istream&lt;charT, traits&gt;&amp; is, bool noskipws = false);\n</code></pre>\n<p id=\"so_21567291_21567292_3\">[...] If <code>noskipws</code> is zero and <code>is.flags() &amp; ios_base::skipws</code> is nonzero, the function extracts and discards each character as long as the next available input character <code>c</code> is a whitespace character. [...]</p>\n</blockquote>\n<p>Since the above condition is false, the sentry object will not discard the whitespace. The reason <code>noskipws</code> is set to <code>true</code> by this function is because the point of <code>std::getline()</code> is to read raw, unformatted characters into a <code>std::basic_string&lt;charT&gt;</code> object.</p>\n<hr>\n<h1>The Solution:</h1>\n<p>There's no way to stop this behavior of <code>std::getline()</code>. What you'll have to do is discard the new line yourself before <code>std::getline()</code> runs (but do it <em>after</em> the formatted extraction). This can be done by using <code>ignore()</code> to discard the rest of the input until we reach a fresh new line:</p>\n<pre><code>if (std::cin &gt;&gt; name &amp;&amp;\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') &amp;&amp;\n    std::getline(std::cin, state))\n{ ... }\n</code></pre>\n<p>You'll need to include <code>&lt;limits&gt;</code> to use <code>std::numeric_limits</code>. <code>std::basic_istream&lt;...&gt;::ignore()</code> is a function that discards a specified amount of characters until it either finds a delimiter or reaches the end of the stream (<code>ignore()</code> also discards the delimiter if it finds it). The <code>max()</code> function returns the largest amount of characters that a stream can accept.</p>\n<p>Another way to discard the whitespace is to use the <code>std::ws</code> function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:</p>\n<pre><code>if (std::cin &gt;&gt; name &amp;&amp; std::getline(std::cin &gt;&gt; std::ws, state))\n{ ... }\n</code></pre>\n<p><strong>What's the difference?</strong></p>\n<p>The difference is that <code>ignore(std::streamsize count = 1, int_type delim = Traits::eof())</code><sup>3</sup> indiscriminately discards characters until it either discards <code>count</code> characters, finds the delimiter (specified by the second argument <code>delim</code>) or hits the end of the stream. <code>std::ws</code> is only used for discarding whitespace characters from the beginning of the stream.</p>\n<p>If you are mixing formatted input with unformatted input and you need to discard residual whitespace, use <code>std::ws</code>. Otherwise, if you need to clear out invalid input regardless of what it is, use <code>ignore()</code>. In our example, we only need to clear whitespace since the stream consumed your input of <code>\"John\"</code> for the <code>name</code> variable. All that was left was the newline character.</p>\n<hr>\n<p><sub>1: <code>std::skipws</code> is manipulator that tells the input stream to discard leading whitespace when performing formatted input. This can be turned off with the <code>std::noskipws</code> manipulator.</sub></p>\n<p><sub>2: Input streams deem certain characters as whitespace by default, such the space character, newline character, form feed, carriage return, etc.</sub></p>\n<p><sub>3: This is the signature of <code>std::basic_istream&lt;...&gt;::ignore()</code>. You can call it with zero arguments to discard a single character from the stream, one argument to discard a certain amount of characters, or two arguments to discard <code>count</code> characters or until it reaches <code>delim</code>, whichever one comes first. You normally use <code>std::numeric_limits&lt;std::streamsize&gt;::max()</code> as the value of <code>count</code> if you don't know how many characters there are before the delimiter, but you want to discard them anyway.</sub></p>\n</hr></hr></hr></hr>", "LastEditorUserId": "3556914", "LastActivityDate": "2016-08-02T03:56:26.337", "Score": "72", "CreationDate": "2014-02-05T02:01:25.903", "ParentId": "21567291", "CommentCount": "4", "OwnerUserId": "701092", "LastEditDate": "2016-08-02T03:56:26.337"}, "22660390": {"Id": "22660390", "PostTypeId": "2", "Body": "<p>Everything will be OK if you change your initial code in the following way:</p>\n<pre><code>if ((cin &gt;&gt; name).get() &amp;&amp; std::getline(cin, state))\n</code></pre>\n", "LastEditorUserId": "2074608", "LastActivityDate": "2014-03-26T12:21:13.553", "Score": "9", "CreationDate": "2014-03-26T12:01:34.927", "ParentId": "21567291", "CommentCount": "3", "OwnerUserId": "3464068", "LastEditDate": "2014-03-26T12:21:13.553"}});