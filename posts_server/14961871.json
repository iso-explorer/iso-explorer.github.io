post_cb({"14962321": {"ParentId": "14961871", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The char traits and the various char overloads are not related.</p>\n<p>The char traits are about the char type and handling of the <em>output stream</em>, whereas the char overloads have to do with the char types <em>inserted</em>. Think of <code>basic_ostream&lt;wchar_t&gt;</code> vs. <code>operator&lt;&lt;(basic_ostream, char)</code> for example.</p>\n<p>You must also consider that it is implementation defined, whether a plain char is <code>signed</code> or <code>unsigned</code>. Also </p>\n<blockquote>\n<p id=\"so_14961871_14962321_0\"><strong>3.9.1 Fundamental types [basic.fundamental]</strong><br>\n  1 ... Plain char, signed char, and unsigned char are three distinct types.</br></p>\n</blockquote>\n<p>So, an overload for just <code>char</code> or <code>const char*</code> doesn't cover all possibilities. I guess, defining these overloads is just to be complete and for covering all fundamental types.</p>\n", "OwnerUserId": "1741542", "LastEditorUserId": "1741542", "LastEditDate": "2013-02-19T16:59:52.163", "Id": "14962321", "Score": "1", "CreationDate": "2013-02-19T16:23:05.627", "LastActivityDate": "2013-02-19T16:59:52.163"}, "14962153": {"ParentId": "14961871", "CommentCount": "1", "Body": "<p>The overloads are necessary to allow the operator to be used without specifying all the template types.  If the types match, the compiler just uses the right overload.  If they don't match, it either has to do implicit conversions (undesirable) or you have to specify all the template types explicitly, and I'm not even sure there is syntax that would allow you to do so.</p>\n", "OwnerUserId": "3279", "PostTypeId": "2", "Id": "14962153", "Score": "1", "CreationDate": "2013-02-19T16:15:33.660", "LastActivityDate": "2013-02-19T16:15:33.660"}, "bq_ids": {"n4140": {"so_14961871_14962321_0": {"section_id": 7210, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_14961871_14962321_0": {"section_id": 6954, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_14961871_14962321_0": {"section_id": 8719, "quality": 0.6923076923076923, "length": 9}}}, "14961871": {"CommentCount": "4", "ViewCount": "173", "PostTypeId": "1", "LastEditorUserId": "749762", "CreationDate": "2013-02-19T16:03:19.697", "LastActivityDate": "2013-02-19T16:59:52.163", "Title": "Why do overloads of 'operator<<' exist for the 'char' partial-specializations of std::basic_ostream?", "LastEditDate": "2013-02-19T16:12:09.410", "Id": "14961871", "Score": "2", "Body": "<p>I would like to know <em>why</em> the following <code>operator&lt;&lt;</code> overloads exist for <code>basic_ostream</code>'s <code>char</code> partial-specializations:</p>\n<pre><code>template&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,\n                                        char ch );\ntemplate&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,\n                                        signed char ch );\ntemplate&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,\n                                        unsigned char ch );\ntemplate&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,  \n                                        const char* s );\ntemplate&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,\n                                        const signed char* s );\ntemplate&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,traits&gt;&amp; os,\n                                        const unsigned char* s );\n</code></pre>\n<hr>\n<p><strong>Why I Care To Know</strong>:</p>\n<p>I find the overloads at best redundant, and generally cumbersome:</p>\n<ol>\n<li><p>The following overloads for non-specialized template types already exist, and provide the <code>char</code> and <code>char*</code> functionality:</p>\n<pre><code>template&lt; class CharT, class Traits&gt;\nbasic_ostream&lt;CharT,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;CharT,Traits&gt;&amp; os,\n                                         CharT ch );\ntemplate&lt; class CharT, class Traits&gt;\nbasic_ostream&lt;CharT,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;CharT,Traits&gt;&amp; os,\n                                         char ch );\ntemplate&lt; class CharT, class Traits &gt;\nbasic_ostream&lt;CharT,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;CharT,Traits&gt;&amp; os,\n                                         const CharT* s );\ntemplate&lt; class CharT, class Traits &gt;\nbasic_ostream&lt;CharT,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;CharT,Traits&gt;&amp; os,\n                                         const char* s );\n</code></pre></li>\n<li><p><code>signed char</code> and <code>unsigned char</code> are not character-types, ( there are no <code>char_traits</code> for them, ) and they should be usable as integer-values, ( especially in the <code>stdint.h</code> context of <code>int8_t</code>, <code>uint8_t</code>, etc. )  Yet these overloads contrast against both of those points; one has to play games to get around these annoyances such as:</p>\n<ul>\n<li>explicitly cast <code>signed char</code> to <code>signed short</code>, <code>unsigned char</code> to <code>unsigned short</code>, and <code>signed char*</code> or <code>unsigned char*</code> to <code>void*</code> for each use-case.\n<ul>\n<li>which requires workaround function-overloading or template partial-specializations in user code.</li>\n</ul></li>\n<li>using the <code>wchar_t</code> equivalent <code>basic_ostream</code> to avoid these undesired function-overloads.\n<ul>\n<li>which likely reduces performance of user code.</li>\n</ul></li>\n</ul>\n<p>In both cases, the user code looks uglier than it need be.</p></li>\n</ol>\n</hr>", "Tags": "<c++><integer><char><operator-overloading><ostream>", "OwnerUserId": "749762", "AnswerCount": "2"}});