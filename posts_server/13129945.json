post_cb({"13130018": {"ParentId": "13129945", "CommentCount": "0", "Body": "<p>In C++11, for the C headers that are explicitly named in the C++ standard, the following holds:</p>\n<ul>\n<li><p>An implementation is <strong>required</strong> for the &lt;foo.h&gt; versions to add them in the global namespace, and <strong>allowed</strong> to add them to the <code>std::</code> namespace.</p></li>\n<li><p>An implementation is <strong>required</strong> for the &lt;cfoo&gt; versions to add them in the <code>std::</code> namespace, and <strong>allowed</strong> to add them to the global namespace.</p></li>\n</ul>\n", "OwnerUserId": "396551", "PostTypeId": "2", "Id": "13130018", "Score": "4", "CreationDate": "2012-10-29T21:34:46.827", "LastActivityDate": "2012-10-29T21:34:46.827"}, "13130022": {"ParentId": "13129945", "CommentCount": "0", "Body": "<p>My personal style is to always fully qualify names so it is clear where they come from. That is, I would use <code>std::uint8_t</code>. That is, I would include <code>&lt;cstdint&gt;</code> and use qualified names.</p>\n<p>That said, note that use of <code>std::uint8_t</code> is only indicated if you really mean to use a type with <em>exactly</em> 8 bits. If the platform you are running your code on doesn't have such a type, e.g., because it uses 9 bit units as its basic entity, the program is supposed not to compile. If you want to use the smallest <code>unsigned</code> with 8 bits available, you want to use <code>uint_least8_t</code>.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "13130022", "Score": "1", "CreationDate": "2012-10-29T21:35:04.093", "LastActivityDate": "2012-10-29T21:35:04.093"}, "13129945": {"CommentCount": "4", "ViewCount": "1483", "CreationDate": "2012-10-29T21:27:39.417", "LastActivityDate": "2012-10-29T21:50:26.533", "Title": "Use types in <cstdint> with ot without namespace", "AcceptedAnswerId": "13130023", "PostTypeId": "1", "Id": "13129945", "Score": "7", "Body": "<p>In C++ 11 I can choose whether I want to use the types defined in  with or without the namespace std::</p>\n<p>At least my compiler (g++ 4.7) accepts both variants.</p>\n<p>My question is: What is the recommended way to use the typedefs from cstdint. With or without the namespace? What are the advantages or disadvantages? Or is it only a matter of style?</p>\n<p>so variant a):</p>\n<pre><code>#include &lt;cstdint&gt;\nstd::uint8_t n = 21;\n</code></pre>\n<p>resp:</p>\n<pre><code>#include &lt;cstdint&gt;\nusing std::uint8_t;\nuint8_t n = 21;\n</code></pre>\n<p>or variant b):</p>\n<pre><code>#include &lt;cstdint&gt;\nuint8_t n = 21;\n</code></pre>\n", "Tags": "<c++><stl><c++11>", "OwnerUserId": "468102", "AnswerCount": "4"}, "13130101": {"ParentId": "13129945", "CommentCount": "0", "Body": "<p>The reason for wrapping things in the <code>std</code> namespace in the <code>&lt;cstdint&gt;</code> header is to avoid name collisions, which are quite unpleasant when they happen. However, in this case, it is very unlikely that the types will be found somewhere else. So I would use <code>&lt;stdint.h&gt;</code>, especially because this feature was introduced in <code>C</code> before it was added to <code>C++</code>, and hence the <code>&lt;stdint.h&gt;</code> header is older than <code>&lt;cstdint&gt;</code>, and therefore available in older compilers.</p>\n<p>If you have decided that you want these names in the global namespace, you should also prefer <code>&lt;stdint.h&gt;</code> to <code>&lt;cstdint&gt;</code> followed by <code>using namespace std</code>, as the latter will dump all the other <code>std</code> stuff from other <code>&lt;cfoo&gt;</code> headers yhou have included into the global namspace too, which you probably do not want, as many other standard names are much more collision-prone than the likes of uint8_t.</p>\n", "OwnerUserId": "1061433", "PostTypeId": "2", "Id": "13130101", "Score": "2", "CreationDate": "2012-10-29T21:42:39.440", "LastActivityDate": "2012-10-29T21:42:39.440"}, "13130023": {"ParentId": "13129945", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Prefer names declared in the <code>std</code> namespace. The reason is given in \u00a717.6.1.3/4 (<em>ISO/IEC 14882:2011(E)</em>, C++11):</p>\n<blockquote>\n<p id=\"so_13129945_13130023_0\">Except as noted in Clauses 18 through 30 and Annex D, the contents of each header <em>cname</em> shall be the same as that of the corresponding header <em>name</em><code>.h</code>, as specified in the C standard library (1.2) or the C Unicode TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace <code>std</code>. It is unspecified whether these names are first declared within the global namespace scope and are then injected into namespace <code>std</code> by explicit <em>using-declarations</em> (7.3.3).</p>\n</blockquote>\n<p>If you use the names from the <code>&lt;c</code><em>name</em><code>&gt;</code> headers without <code>std</code>, your program is relying on unspecified requirements.</p>\n<p>This was different in C++03 and earlier where names were only supposed to appear in the <code>std</code> namespace. However, the reality was that many implementations were simply injecting the contents of the C standard library headers <code>&lt;</code><em>name</em><code>.h&gt;</code> into <code>std</code> and so this was accommodated for in C++11. The corresponding section (\u00a717.4.1.2/4) from the C++03 standard says:</p>\n<blockquote>\n<p id=\"so_13129945_13130023_1\">Except as noted in clauses 18 through 27, the contents of each header <em>cname</em> shall be the same as that of the corresponding header <em>name</em><code>.h</code>, as specified in ISO/IEC 9899:1990 Programming Languages C (Clause 7), or ISO/IEC:1990 Programming Languages\u2014C AMENDMENT 1: C Integrity, (Clause 7), as appropriate, as if by inclusion. In the C++ Standard Library, however, the declarations and definitions (except for names which are defined as macros in C) are within namespace scope (3.3.5) of the namespace <code>std</code>.</p>\n</blockquote>\n<p>Further to this, qualifying names with <code>std::</code> helps to avoid collisions - you know exactly what you're getting if you fully qualify it. If you're really going to do <code>using namespace std</code> or <code>using std::something</code>, at least do it in as minimal a scope as you can.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2012-10-29T21:50:26.533", "Id": "13130023", "Score": "5", "CreationDate": "2012-10-29T21:35:07.100", "LastActivityDate": "2012-10-29T21:50:26.533"}, "bq_ids": {"n4140": {"so_13129945_13130023_1": {"section_id": 6259, "quality": 0.5609756097560976, "length": 23}, "so_13129945_13130023_0": {"section_id": 6259, "quality": 0.9166666666666666, "length": 44}}, "n3337": {"so_13129945_13130023_1": {"section_id": 6019, "quality": 0.5609756097560976, "length": 23}, "so_13129945_13130023_0": {"section_id": 6019, "quality": 0.9166666666666666, "length": 44}}, "n4659": {"so_13129945_13130023_1": {"section_id": 7763, "quality": 0.5365853658536586, "length": 22}, "so_13129945_13130023_0": {"section_id": 7763, "quality": 0.8541666666666666, "length": 41}}}});