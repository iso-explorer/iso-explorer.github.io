post_cb({"20735255": {"ViewCount": "678", "Body": "<p>I'm currently writing exception-safe code and my design requires no throw guarantee for\nset::find method.\nI assume the comparator object always succeeds.\nDoes it imply set::find method will always succeed?</p>\n<p>I thought about such a possibility after I have seen that according to <a href=\"http://en.cppreference.com/w/cpp/container/set/erase\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/set/erase</a>, set::erase method, with the same assumption, should always succeed and maybe there's a find in it (then it would be definetely worth a comment in documentation!)</p>\n<p>The direct source for the problem is that I need to check whether an element is in a set and remove it from the set -- all that having no throw guarantee (it's in a catch block).</p>\n", "Title": "std::set::find exception guarantees", "CreationDate": "2013-12-22T23:37:39.120", "LastActivityDate": "2013-12-24T23:34:58.503", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "Id": "20735255", "Score": "3", "OwnerUserId": "3128048", "Tags": "<c++><exception><stl><set>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20735255_20735326_1": {"length": 7, "quality": 0.5833333333333334, "section_id": 744}, "so_20735255_20735326_2": {"length": 9, "quality": 1.0, "section_id": 750}}, "n3337": {"so_20735255_20735326_1": {"length": 7, "quality": 0.5833333333333334, "section_id": 733}, "so_20735255_20735326_2": {"length": 9, "quality": 1.0, "section_id": 738}}, "n4659": {"so_20735255_20735326_1": {"length": 7, "quality": 0.5833333333333334, "section_id": 802}, "so_20735255_20735326_2": {"length": 9, "quality": 1.0, "section_id": 810}}}, "20735530": {"Id": "20735530", "PostTypeId": "2", "Body": "<p>C++11 <strong>\u00a723.2.4.1 Exception safety guarantees [associative.reqmts.except]</strong> lists all the exception safety requirements for associative containers (including <code>set</code>) and there is no mention made of <code>find</code>. So no, the standard does not guarantee that <code>find</code> never throws.</p>\n<p>In the absence of undefined behavior and assuming a non-throwing comparator, I find it extremely unlikely that an implementation of the C++ standard library exists which will throw an exception from <code>set::find</code>. I would personally be comfortable with (a) wrapping <code>set::find</code> in a <code>noexcept</code> forwarding function so that the program will crash if such an \"impossible\" thing ever occurs, or (b) wrapping a particular <code>set::find</code> call in</p>\n<pre><code>auto it = foo.end();\ntry {\n  it = foo.find(bar);\n} catch(...) {}\n</code></pre>\n<p>and simply treating an exception as \"not found.\"</p>\n<p>Note that the ordering relation of associative containers is an easily-overlooked source of undefined behavior: \u00a7 23.2.4/2 requires the ordering relation to induce a strict weak ordering (as described in \u00a725.4) on the key elements. An associative container instantiated with an ordering relation that is <strong>not</strong> a strict weak ordering does not have defined behavior, one possible outcome of which is throwing an exception from <code>find</code>.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2013-12-24T23:34:58.503", "Score": "0", "CreationDate": "2013-12-23T00:20:06.520", "ParentId": "20735255", "CommentCount": "5", "LastEditDate": "2013-12-24T23:34:58.503", "OwnerUserId": "923854"}, "20735326": {"Id": "20735326", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/container/set/find\" rel=\"nofollow\"><code>std::set::find</code></a>:</p>\n<blockquote>\n<p id=\"so_20735255_20735326_0\">Return value</p>\n<p id=\"so_20735255_20735326_1\">Iterator to an element with key <code>key</code>. If no such element is found, past-the-end (see <a href=\"http://en.cppreference.com/w/cpp/container/set/end\" rel=\"nofollow\">end()</a>) iterator is returned.</p>\n</blockquote>\n<p>Neither the documentation nor the C++ Standard explicitly list any exception safety guarantees. However, the same rules spelled out for <a href=\"http://en.cppreference.com/w/cpp/container/set/erase\" rel=\"nofollow\"><code>std::set::erase</code></a> apply here (\u00a723.2.4.1 Exception safety guarantees [associative.reqmts.except]):</p>\n<blockquote>\n<p id=\"so_20735255_20735326_2\"><code>erase(k)</code> does not throw an exception unless that exception is thrown by the container\u2019s <code>Compare</code> object (if any).</p>\n</blockquote>\n<p>In essence, unless the <code>Compare</code> object throws an exception, <code>std::set::find</code> does not throw. Bjarne Stroustrup has the following to say in <a href=\"http://www.stroustrup.com/3rd_safe.pdf\" rel=\"nofollow\">The C++ Programming Language, Special Edition - Appendix E</a>:</p>\n<blockquote>\n<p id=\"so_20735255_20735326_3\">Fortunately, predicates rarely do anything that might throw an exception. However, user-defined <code>&lt;</code>, <code>==</code>, and <code>!=</code> predicates must be taken into account when considering exception safety.</p>\n</blockquote>\n<p>If you aren't providing any user-defined predicates you can assume <code>std::set::find</code> does not throw an exception. If you are, you should mark them as <a href=\"http://en.cppreference.com/w/cpp/language/noexcept_spec\" rel=\"nofollow\"><code>noexcept</code></a> to work safely in your scenario.</p>\n", "LastEditorUserId": "1889329", "LastActivityDate": "2013-12-23T22:57:39.547", "Score": "1", "CreationDate": "2013-12-22T23:46:56.310", "ParentId": "20735255", "CommentCount": "0", "LastEditDate": "2013-12-23T22:57:39.547", "OwnerUserId": "1889329"}});