post_cb({"bq_ids": {"n4140": {"so_13268608_13268608_1": {"length": 5, "quality": 0.625, "section_id": 1871}, "so_13268608_13268882_0": {"length": 8, "quality": 1.0, "section_id": 44}, "so_13268608_13268608_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 3491}}, "n3337": {"so_13268608_13268608_1": {"length": 5, "quality": 0.625, "section_id": 4855}, "so_13268608_13268608_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 3356}, "so_13268608_13268882_0": {"length": 8, "quality": 1.0, "section_id": 41}}, "n4659": {"so_13268608_13268608_1": {"length": 5, "quality": 0.625, "section_id": 2043}, "so_13268608_13268608_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 4254}, "so_13268608_13268882_0": {"length": 8, "quality": 1.0, "section_id": 45}}}, "13268882": {"Id": "13268882", "PostTypeId": "2", "Body": "<p>This has nothing to do with <code>boost::variant</code>, but with the order in which C++ selects the conversions to apply. Before trying to use user-defined conversions (remember that <code>std::string</code> is a user-defined class for this purpose), the compiler will try built-in conversions. There is no built-in conversion from <code>const char*</code> to <code>int</code>, but according to \u00a74.12 in the standard:</p>\n<blockquote>\n<p id=\"so_13268608_13268882_0\">A prvalue of [...] pointer [...] type can be converted to a prvalue of type bool.</p>\n</blockquote>\n<p>So the compiler happily converts your <code>const char*</code> to a <code>bool</code> and never gets to consider converting it to a <code>std::string</code>.</p>\n", "LastActivityDate": "2012-11-07T11:30:59.980", "CommentCount": "1", "CreationDate": "2012-11-07T11:30:59.980", "ParentId": "13268608", "Score": "9", "OwnerUserId": "25824"}, "13268753": {"Id": "13268753", "PostTypeId": "2", "Body": "<p>I don't think this is anything particularly to do with <code>boost::variant</code>, it's about which constructor gets selected by overload resolution. The same thing happens with an overloaded function:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nvoid foo(bool) {\n    std::cout &lt;&lt; \"bool\\n\";\n}\n\nvoid foo(std::string) {\n    std::cout &lt;&lt; \"string\\n\";\n}\n\nint main() {\n    foo(\"hi\");\n}\n</code></pre>\n<p>output:</p>\n<pre><code>bool\n</code></pre>\n<p>I don't know of a way to change what constructors a Variant has [edit: as James says, you can write another class that uses the Variant in its implementation. Then you can provide a <code>const char*</code> constructor that does the right thing.]</p>\n<p>Maybe you could change the types in the Variant. Another overloading example:</p>\n<pre><code>struct MyBool {\n    bool val;\n    explicit MyBool(bool val) : val(val) {}\n};\n\nvoid bar(MyBool) {\n    std::cout &lt;&lt; \"bool\\n\";\n}\n\nvoid bar(const std::string &amp;) {\n    std::cout &lt;&lt; \"string\\n\";\n}\n\nint main() {\n    bar(\"hi\");\n}\n</code></pre>\n<p>output:</p>\n<pre><code>string\n</code></pre>\n<p>Unfortunately now you have to write <code>bar(MyBool(true))</code> instead of <code>foo(true)</code>. Even worse in the case of your variant with <code>string/bool/int</code>, if you just change it to a variant of <code>string/MyBool/int</code> then <code>MyVariant(true)</code> would call the <code>int</code> constructor.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-11-07T11:34:17.293", "Score": "10", "CreationDate": "2012-11-07T11:23:02.877", "ParentId": "13268608", "CommentCount": "3", "OwnerUserId": "13005", "LastEditDate": "2012-11-07T11:34:17.293"}, "13268608": {"ViewCount": "2138", "Body": "<p>I have declared a <code>boost::variant</code> which accepts three types: <code>string</code>, <code>bool</code> and <code>int</code>. The following code is showing that my variant accepts <code>const char*</code> and converts it to <code>bool</code>. Is it a normal behavior for <code>boost::variant</code> to accept and convert types not on its list? </p>\n<pre><code>#include &lt;iostream&gt;\n#include \"boost/variant/variant.hpp\"\n#include \"boost/variant/apply_visitor.hpp\"\n\nusing namespace std;\nusing namespace boost;\n\ntypedef variant&lt;string, bool, int&gt; MyVariant;\n\nclass TestVariant\n    : public boost::static_visitor&lt;&gt;\n{\npublic:\n    void operator()(string &amp;v) const\n    {\n        cout &lt;&lt; \"type: string -&gt; \" &lt;&lt; v &lt;&lt; endl;\n    }\n    template&lt;typename U&gt;\n    void operator()(U &amp;v)const\n    {\n        cout &lt;&lt; \"type: other -&gt; \" &lt;&lt; v &lt;&lt; endl;\n    }\n};\n\nint main(int argc, char **argv) \n{\n    MyVariant s1 = \"some string\";\n    apply_visitor(TestVariant(), s1);\n\n    MyVariant s2 = string(\"some string\");\n    apply_visitor(TestVariant(), s2);\n\n    return 0;\n}\n</code></pre>\n<p>output:</p>\n<blockquote>\n<p id=\"so_13268608_13268608_0\">type: other -&gt; 1<br>\n  type: string -&gt; some string</br></p>\n</blockquote>\n<p>If I remove the bool type from MyVariant and change it to this:</p>\n<pre><code>typedef variant&lt;string, int&gt; MyVariant;\n</code></pre>\n<p><code>const char*</code> is no more converted to <code>bool</code>. This time it's converted to <code>string</code> and this is the new output:</p>\n<blockquote>\n<p id=\"so_13268608_13268608_1\">type: string -&gt; some string<br>\n   type: string -&gt; some string</br></p>\n</blockquote>\n<p>This indicates that <code>variant</code> tries to convert other types first to <code>bool</code> and then to <code>string</code>. If the type conversion is something inevitable and should always happen, is there any way to give conversion to <code>string</code> a higher priority?</p>\n", "AcceptedAnswerId": "13268753", "Title": "boost::variant - why is \"const char*\" converted to \"bool\"?", "CreationDate": "2012-11-07T11:15:37.867", "Id": "13268608", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-11-07T11:21:31.647", "LastEditorUserId": "69537", "LastActivityDate": "2012-11-07T11:34:17.293", "Score": "14", "OwnerUserId": "69537", "Tags": "<c++><boost><boost-variant>", "AnswerCount": "2"}});