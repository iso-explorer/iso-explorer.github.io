post_cb({"18146466": {"ParentId": "18146267", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-08-09T12:16:57.230", "Score": "29", "LastEditorUserId": "63550", "LastEditDate": "2013-08-10T21:50:52.367", "Id": "18146466", "OwnerUserId": "1394283", "Body": "<p>In that example we can just quote the standard:</p>\n<blockquote>\n<p id=\"so_18146267_18146466_0\"><strong>12.2 Temporary objects [class.temporary]</strong></p>\n<p id=\"so_18146267_18146466_1\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true even if that evaluation ends in throwing an exception. The value computations and side effects of destroying a temporary object are associated only with the full-expression, not with any specific subexpression.</p>\n</blockquote>\n<p>That is after the semicolon of your line:</p>\n<pre><code>const char * s = (s1+s2).c_str(); // &lt;- Here\n</code></pre>\n<p>So here:</p>\n<pre><code>printf(\"%s\\n\",s); // This line will now cause undefined behaviour.\n</code></pre>\n<p>Why? Because as your object is destructed, you don't know anymore what is at this place now...</p>\n<p>The bad thing here is that, with <em>Undefined behaviour</em>, your program may seem to work at the first time, but... It will crash for sure at the worst time...</p>\n<p>You can do:</p>\n<pre><code>printf( \"%s\\n\", (s1+s2).c_str() );\n</code></pre>\n<p>It will work because the object is not destructed yet (remember, after the semicolon...).</p>\n", "LastActivityDate": "2013-08-10T21:50:52.367"}, "18146267": {"CommentCount": "2", "AcceptedAnswerId": "18146288", "PostTypeId": "1", "ClosedDate": "2013-08-10T13:19:04.817", "LastEditorUserId": "63550", "CreationDate": "2013-08-09T12:06:13.987", "LastActivityDate": "2013-08-10T21:50:52.367", "LastEditDate": "2013-08-10T21:47:53.040", "ViewCount": "1474", "FavoriteCount": "3", "Title": "Is it safe to use (str1 + str2).c_str()?", "Id": "18146267", "Score": "36", "Body": "<p>I have tested this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n{\n    string s1(\"a\"),s2(\"b\");\n    const char * s = (s1+s2).c_str();\n    printf(\"%s\\n\",s);\n}\n</code></pre>\n<p>It returns \"ab\".</p>\n<p>As far as I know, since <code>(s1 +s2)</code> is a temporary object and may disappear somehow (I have no idea about that), then <code>const char * s</code> may point to undefined memory and may get dumped.</p>\n<p>So is it safe to use the <code>.c_str()</code> like that?</p>\n", "Tags": "<c++><string>", "OwnerUserId": "1291716", "AnswerCount": "4"}, "18146653": {"ParentId": "18146267", "CommentCount": "0", "CreationDate": "2013-08-09T12:26:31.347", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "18146653", "Score": "4", "Body": "<p>Like most programming constructs, it's \"safe\" if you use it correctly, and it's not \"safe\" if you're sloppy. In this case, using it correctly means paying attention to object lifetimes. The <code>+</code> operator creates a temporary object which gets destroyed at the end of the statement, and the returned <code>const char*</code> is no longer valid after the statement that created it. So you can pass the result of <code>c_str()</code> directly to a function, but you can't save the pointer and use it later.</p>\n", "LastActivityDate": "2013-08-09T12:26:31.347"}, "18146288": {"ParentId": "18146267", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-08-09T12:07:44.767", "Score": "57", "LastEditorUserId": "320726", "LastEditDate": "2013-08-09T12:22:16.407", "Id": "18146288", "OwnerUserId": "320726", "Body": "<p>It's not safe in your example. It's safe however in</p>\n<pre><code>printf(\"%s\\n\", (a + b).c_str());\n</code></pre>\n<p>The reason is that temporary values (like the result of <code>a + b</code>) are destroyed at the end of the full expression. In your example the <code>const char *</code> survives the full expression containing the temporary and dereferencing it is undefined behaviour.</p>\n<p>The worst part of \"undefined behaviour\" is that things may apparently work anyway... (UB code crashes only if you're making your demo in front of a vast audience that includes your parents ;-) )</p>\n", "LastActivityDate": "2013-08-09T12:22:16.407"}, "18146473": {"ParentId": "18146267", "CommentCount": "0", "CreationDate": "2013-08-09T12:17:15.157", "OwnerUserId": "546205", "PostTypeId": "2", "Id": "18146473", "Score": "5", "Body": "<p>It's not safe, but you can easily assign to a new variable, and the pointer will be safe in the scope of that variable:</p>\n<pre><code>string s1(\"a\"), s2(\"b\") , s3;\ns3 = s1 + s2;\nprintf(\"%s\\n\", s3.c_str());\n\n//other operations with s3\n</code></pre>\n", "LastActivityDate": "2013-08-09T12:17:15.157"}, "bq_ids": {"n4140": {"so_18146267_18146466_1": {"section_id": 380, "quality": 0.9393939393939394, "length": 31}}, "n3337": {"so_18146267_18146466_1": {"section_id": 371, "quality": 0.9393939393939394, "length": 31}}, "n4659": {"so_18146267_18146466_1": {"section_id": 395, "quality": 0.9393939393939394, "length": 31}}}});