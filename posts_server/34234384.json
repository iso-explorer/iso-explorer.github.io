post_cb({"34234384": {"CommentCount": "2", "ViewCount": "223", "PostTypeId": "1", "LastEditorUserId": "1364752", "CreationDate": "2015-12-11T23:43:56.217", "LastActivityDate": "2015-12-12T00:28:50.383", "Title": "Variadic function pointer conversion", "FavoriteCount": "3", "LastEditDate": "2015-12-12T00:01:41.287", "Id": "34234384", "Score": "7", "Body": "<p>I am writing a library with many function objects whose classes have several <code>operator()</code> overloads that do not depend on the state of the classes and do not alter it. Now, I tried to make my code work with many old-style APIs (it is not a random need, I actually had to deal with such APIs) and therefore decided to make the function objects convertible to any function pointer corresponding to one of the overloads. At some point, I realized that I had too many such conversions to function pointer operators and that I should theorically be able to write a single variadic conversion operator. Here is a class implementing such a variadic operator:</p>\n<pre><code>struct foobar\n{\n    template&lt;typename... Args&gt;\n    using fptr_t = void(*)(Args... args);\n\n    template&lt;typename... Args&gt;\n    operator fptr_t&lt;Args...&gt;() const\n    {\n        return [](Args... args) {\n            // Whatever\n        };\n    }\n};\n</code></pre>\n<p>As you can see, I used the lambda conversion to function pointer to implement the conversion operator, which is not a problem since every function object I have is stateless. The goal was to be able to use the class as follows:</p>\n<pre><code>int main()\n{\n    void(*foo)(int) = foobar();\n    void(*bar)(float, double) = foobar();\n}\n</code></pre>\n<p>g++ has no problem compiling this code with the expected semantics. However, clang++ <a href=\"http://coliru.stacked-crooked.com/a/dd578d1a7c7b8042\" rel=\"nofollow\">rejects it</a> with a template substitution failure error:</p>\n<blockquote id=\"so_34234384_34234384_0\">\n<pre><code>main.cpp:21:11: error: no viable conversion from 'foobar' to 'void (*)(int)'\n    void(*foo)(int) = foobar();\n          ^           ~~~~~~~~\nmain.cpp:11:5: note: candidate function [with Args = int]\n    operator fptr_t&lt;Args...&gt;() const\n    ^\n1 error generated.\n</code></pre>\n</blockquote>\n<p>Note that clang++ has no problem with such conversion operators as long as no variadic templates are involved. If I use a single template parameter, it will have no problem compiling the code. Now, should the code above be accepted or rejected by the compiler?</p>\n", "Tags": "<c++><function-pointers><language-lawyer><c++14><variadic-templates>", "OwnerUserId": "1364752", "AnswerCount": "1"}, "34234505": {"ParentId": "34234384", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A lambda can only be converted to a function pointer if it does not capture, so your code should work. This is justified in the standard <em>5.1.2/p6 Lambda expressions [expr.prim.lambda]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_34234384_34234505_0\"><strong>The closure type for a non-generic lambda-expression with no\n  lambda-capture has a public non-virtual non-explicit const conversion\n  function to pointer to function with C++ language linkage (7.5) having\n  the same parameter and return types as the closure type\u2019s function\n  call operator.</strong> The value returned by this conversion function shall be the \n  address of a function that, when invoked, has the same effect as invoking the \n  closure type\u2019s function call operator. </p>\n</blockquote>\n<p><strong>So I would file it as a CLANG bug.</strong></p>\n<p>As a work around for CLANG, you can convert it to a <code>std::function</code> as shown below:</p>\n<pre><code>struct foobar\n{\n    template&lt;typename... Args&gt;\n    using fptr_t = void(*)(Args... args);\n\n    template&lt;typename... Args&gt;\n    operator std::function&lt;void(Args...)&gt;() const\n    {\n        return [](Args... args) {\n            //...\n        };\n    }\n};\n\nint main()\n{\n    std::function&lt;void(int)&gt; f1 = foobar();\n    std::function&lt;void(double, float)&gt; f2 = foobar();\n    f1(1);\n    f2(2.0, 1.0f);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/bc8e3fa733390be4\" rel=\"nofollow\"><strong>Live Demo</strong></a></p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2015-12-12T00:28:50.383", "Id": "34234505", "Score": "1", "CreationDate": "2015-12-11T23:56:03.627", "LastActivityDate": "2015-12-12T00:28:50.383"}, "bq_ids": {"n4140": {"so_34234384_34234505_0": {"section_id": 5965, "quality": 0.9534883720930233, "length": 41}}, "n3337": {"so_34234384_34234505_0": {"section_id": 5734, "quality": 0.8837209302325582, "length": 38}}, "n4659": {"so_34234384_34234505_0": {"section_id": 7456, "quality": 0.8604651162790697, "length": 37}}}});