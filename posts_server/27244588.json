post_cb({"27244588": {"CommentCount": "22", "ViewCount": "77", "PostTypeId": "1", "ClosedDate": "2014-12-02T17:15:16.093", "LastEditorUserId": "149392", "CreationDate": "2014-12-02T08:09:04.017", "LastActivityDate": "2014-12-02T15:14:49.113", "Title": "regarding array declaration in c++", "LastEditDate": "2014-12-02T15:14:49.113", "Id": "27244588", "Score": "-2", "Body": "<pre><code>int main(){\n\n        int n;\n\n        scanf(\"%d\",&amp;n);\n\n        int a[n];\n}\n</code></pre>\n<p>In the above where does the space for array a[] , get allocated ? In stack or heap ? </p>\n", "Tags": "<c++>", "OwnerUserId": "4231763", "AnswerCount": "3"}, "27245211": {"ParentId": "27244588", "CommentCount": "3", "Body": "<p>In the C11 standard, it describes in \u00a76.7.6.2/4 what actually makes an array a variable length array:</p>\n<blockquote>\n<p id=\"so_27244588_27245211_0\">If the size is an integer constant expression and the element type has\n  a known constant size, the array type is not a variable length array\n  type; otherwise, the array type is a <em>variable length array</em> type.</p>\n</blockquote>\n<p>Yet in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a> (C++11 draft), [dcl.array] says:</p>\n<blockquote>\n<p id=\"so_27244588_27245211_1\">If the <em>constant-expression</em> (5.19) is present, it shall be an\n  integral constant expression and its value shall be greater than zero.</p>\n</blockquote>\n<p>The language about \"variable length array\"s are completely missing, so they don't exist in C++.</p>\n<p>The draft talks about object lifetime in [basic.life]. In C, VLAs cannot have static or thread storage duration. \u00a76.2.4/7 then says:</p>\n<blockquote>\n<p id=\"so_27244588_27245211_2\">For such an object that does have a variable length array type, its\n  lifetime extends from the declaration of the object until execution of\n  the program leaves the scope of the declaration.<sup>35)</sup> If the\n  scope is entered recursively, a new instance of the object is created\n  each time. The initial value of the object is indeterminate.</p>\n</blockquote>\n<p>GCC, which allows VLAs in C++ as an <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html\" rel=\"nofollow\">extension</a>, mimics the same semantics:</p>\n<blockquote>\n<p id=\"so_27244588_27245211_3\">Variable-length automatic arrays are allowed in ISO C99, and as an\n  extension GCC accepts them in C90 mode and in C++. These arrays are\n  declared like any other automatic arrays, but with a length that is\n  not a constant expression. The storage is allocated at the point of\n  declaration and deallocated when the block scope containing the\n  declaration exits.</p>\n</blockquote>\n<p>Clang also allows VLAs for compatibility with some <a href=\"http://clang.llvm.org/compatibility.html#vla\" rel=\"nofollow\">restrictions</a>.</p>\n<p>So more than likely, VLAs are allocated on the stack.</p>\n", "Id": "27245211", "PostTypeId": "2", "OwnerDisplayName": "user3920237", "Score": "2", "CreationDate": "2014-12-02T08:46:17.880", "LastActivityDate": "2014-12-02T08:46:17.880"}, "27245103": {"ParentId": "27244588", "CommentCount": "2", "Body": "<p>If your compiler compiles that, it's most likely going to be on the stack. In standard parlance, if you care to apply that to a construct that's not actually standard-conforming, it has automatic storage duration, meaning you don't have to clean it up yourself and it will become invalid at the end of the scope.</p>\n<p>What you have there is a VLA (variable length array), a construct from C that allows you to have arrays whose dimensions are known only at runtime. Usually, the way they work is similar to the \"function\" <code>alloca</code>, which decreases the stack pointer by an amount known at runtime and \"returns\" the pointer to it. I put \"function\" in quotes because doing this requires some low-level hackery that's not provided for by normal function scope semantics.</p>\n<p>VLAs don't exist in C++, so you're using a compiler extension, and the precise semantics of VLAs in that extension depend on your compiler. Since this is likely gcc, I'll leave you a link to <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html\" rel=\"nofollow\">the relevant part of its documentation</a>.</p>\n", "OwnerUserId": "4301306", "PostTypeId": "2", "Id": "27245103", "Score": "3", "CreationDate": "2014-12-02T08:38:48.993", "LastActivityDate": "2014-12-02T08:38:48.993"}, "27245426": {"ParentId": "27244588", "CommentCount": "1", "Body": "<p>Compiler must know what is the size of all array int the code before execute the project.\nYou cant assign it while the program runs.</p>\n", "OwnerUserId": "4312311", "PostTypeId": "2", "Id": "27245426", "Score": "0", "CreationDate": "2014-12-02T09:00:09.303", "LastActivityDate": "2014-12-02T09:00:09.303"}, "bq_ids": {"n4140": {"so_27244588_27245211_0": {"section_id": 4706, "quality": 0.5909090909090909, "length": 13}, "so_27244588_27245211_1": {"section_id": 3228, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_27244588_27245211_0": {"section_id": 4515, "quality": 0.5454545454545454, "length": 12}, "so_27244588_27245211_1": {"section_id": 3101, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_27244588_27245211_0": {"section_id": 6103, "quality": 0.5909090909090909, "length": 13}, "so_27244588_27245211_1": {"section_id": 3985, "quality": 0.8181818181818182, "length": 9}}}});