post_cb({"bq_ids": {"n4140": {"so_3983536_3987551_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 6007}, "so_3983536_3987551_2": {"length": 11, "quality": 1.0, "section_id": 6007}, "so_3983536_3987551_0": {"length": 14, "quality": 1.0, "section_id": 6007}}, "n3337": {"so_3983536_3987551_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5775}, "so_3983536_3987551_2": {"length": 11, "quality": 1.0, "section_id": 5775}, "so_3983536_3987551_0": {"length": 14, "quality": 1.0, "section_id": 5775}}, "n4659": {"so_3983536_3987551_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 7506}, "so_3983536_3987551_2": {"length": 11, "quality": 1.0, "section_id": 7506}, "so_3983536_3987551_0": {"length": 14, "quality": 1.0, "section_id": 7506}}}, "3983536": {"ViewCount": "164", "Body": "<pre><code>//CCodeWrapperIF.h\npublic ref class CCodeWrapperIF\n{\npublic:\n  CCodeWrapperIF// Default constructor\n\npublic:\n\n  static UINT8 funny;\n\n  void foo(void);\n\n}\n\n\n//CCodeWrapperIF.cpp\nextern \"C\"\n{\n #include \"CCodeWrapperIF.h\"\n}\n\n[DllImport(\"CCode.DLL\", CallingConvention = CallingConvention::Cdecl)]\nextern \"C\" void CCode_Foo(void);\n\nCCodeWrapperIF::CCodeWrapperIF(void)\n{\n\n}\n\nCCodeWrapperIF::foo(void)\n{\n   CCode_Foo();\n}\n\n\n\n//a.h\npublic ref class A\n{\nprivate:  static CCodeWrapperIF^ CCode_IFObject;\nA(void)\n{\n   CCode_IFObject=gcnew CCodeWrapperIF();\n}\n\n}\n\n//b.h\n\n\npublic ref class B\n{\n   private:  static CCodeWrapperIF^ CCode_IFObject;\n\n   B(void)\n   {\n\n   }\n}\n\n\n//main.h\nint main(cli::array&lt;System::String ^&gt; ^args)\n{\n  A^  aObj=gcnew A();\n  B^  bObj=gcnew B();\n\n  // Funny thing is :  bObj-&gt;CCode_IFObject-&gt;funny has correct value always!\n  // while if you watch the value of bObj-&gt;CCode_IFObject acturally it is not defined!! \n}\n</code></pre>\n<p>can anyone explain this?</p>\n", "Title": "cli C++ funny static value in wrapper", "CreationDate": "2010-10-21T01:05:34.133", "LastActivityDate": "2010-10-23T00:07:22.177", "CommentCount": "1", "LastEditDate": "2010-10-21T01:41:29.020", "PostTypeId": "1", "LastEditorUserId": "72508", "Id": "3983536", "Score": "0", "OwnerUserId": "445549", "Tags": "<c++-cli>", "AnswerCount": "1"}, "3987551": {"Id": "3987551", "PostTypeId": "2", "Body": "<p>Static members don't need an instance.</p>\n<p><code>bObj-&gt;CCode_IFObject-&gt;funny</code> is converted at compile-time to refer directly to <code>CCodeWrapperIF::funny</code>.</p>\n<p>EDIT: Adding relevant text from the standard, section <strong>Class member access</strong> <code>[expr.ref]</code>, wording from the C++0x FCD</p>\n<blockquote>\n<p id=\"so_3983536_3987551_0\">If E2 is declared to have type \u201creference to T,\u201d then E1.E2 is an lvalue; the type of E1.E2 is T. Otherwise, one of the following rules applies.</p>\n<p id=\"so_3983536_3987551_1\">\u2014  If E2 is a static data member and the type of E2 is T, then E1.E2 is an lvalue; the expression designates the named member of the class. The type of E1.E2 is T.</p>\n<p id=\"so_3983536_3987551_2\">\u2014  If E2 is a non-static data member ... the expression designates the named member of the object designated by the first expression.</p>\n<p id=\"so_3983536_3987551_3\">...</p>\n</blockquote>\n<p>As you can see, for non-static members the \"object delegated by the first expression\" must be valid.  But static members can be identified by the dot notation just like non-static members, and the first expression does not have to be any object at all, only the class matters.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2010-10-23T00:07:22.177", "Score": "0", "CreationDate": "2010-10-21T12:42:22.880", "ParentId": "3983536", "CommentCount": "5", "OwnerUserId": "103167", "LastEditDate": "2010-10-23T00:07:22.177"}});