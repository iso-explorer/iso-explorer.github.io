post_cb({"bq_ids": {"n4140": {"so_49033889_49035607_0": {"length": 13, "quality": 0.8125, "section_id": 5451}, "so_49033889_49035607_5": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_49033889_49035607_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}, "so_49033889_49035607_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}, "so_49033889_49035607_4": {"length": 5, "quality": 1.0, "section_id": 5440}}, "n3337": {"so_49033889_49035607_5": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_49033889_49035607_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}, "so_49033889_49035607_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}, "so_49033889_49035607_4": {"length": 5, "quality": 1.0, "section_id": 5235}}, "n4659": {"so_49033889_49035607_4": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_49033889_49035607_0": {"length": 14, "quality": 0.875, "section_id": 6890}, "so_49033889_49035607_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}, "so_49033889_49035607_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6867}, "so_49033889_49035607_3": {"length": 19, "quality": 1.0, "section_id": 6867}, "so_49033889_49035607_5": {"length": 5, "quality": 1.0, "section_id": 6867}}}, "49034784": {"Id": "49034784", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_49033889_49034784_0\">However, doesn't decltype(auto) also form a reference to xvalue/lvalue?</p>\n</blockquote>\n<p>No.</p>\n<p>Part of <code>decltype(auto)</code>'s magic is that it knows <code>ret</code> is an lvalue, <a href=\"https://stackoverflow.com/a/24109944/560648\">so it will not form a reference</a>.</p>\n<p>If you'd written <code>return (ret)</code>, it would indeed have resolved to a reference type and you'd be returning a reference to a local variable.</p>\n<p><strong>tl;dr: <code>decltype(auto)</code> is not always the same as <code>auto&amp;&amp;</code>.</strong></p>\n", "LastActivityDate": "2018-02-28T16:56:13.110", "CommentCount": "8", "CreationDate": "2018-02-28T16:56:13.110", "ParentId": "49033889", "Score": "4", "OwnerUserId": "560648"}, "49033889": {"ViewCount": "140", "Body": "<p>Consider this quote from <em>C++ Templates: The Complete Guide (2nd Edition)</em>:</p>\n<blockquote>\n<pre><code>decltype(auto) ret{std::invoke(std::forward&lt;Callable&gt;(op),\n                               std::forward&lt;Args&gt;(args)...)};\n...\nreturn ret;\n</code></pre>\n<p id=\"so_49033889_49033889_0\">Note that declaring <code>ret</code> with <code>auto&amp;&amp;</code> is not correct. As a\n  reference, <code>auto&amp;&amp;</code> extends the lifetime of the returned value until\n  the end of its scope <strong>but not beyond the <code>return</code> statement to the\n  caller of the function</strong>.</p>\n</blockquote>\n<p>The author says that <code>auto&amp;&amp;</code> is not appropriate for perfect-forwarding a return value. However, doesn't <code>decltype(auto)</code> also form a reference to xvalue/lvalue?\nIMO, <code>decltype(auto)</code> then suffers from the same issue. Then, what's the point of the author?</p>\n<p><strong>EDIT:</strong></p>\n<p>The above code snippet shall go inside this function template.</p>\n<pre><code>template&lt;typename Callable, typename... Args&gt;\ndecltype(auto) call(Callable&amp;&amp; op, Args&amp;&amp;... args) {\n    // here\n}\n</code></pre>\n", "AcceptedAnswerId": "49035607", "Title": "Perfect-forwarding a return value with auto&&", "CreationDate": "2018-02-28T16:10:12.907", "LastActivityDate": "2018-03-01T02:39:55.970", "CommentCount": "9", "LastEditDate": "2018-02-28T17:13:42.167", "PostTypeId": "1", "LastEditorUserId": "5645940", "Id": "49033889", "Score": "7", "OwnerUserId": "5645940", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "49035607": {"Id": "49035607", "PostTypeId": "2", "Body": "<p>There are two deductions here. One from the return expression, and one from the <code>std::invoke</code> expression. Because <a href=\"http://eel.is/c++draft/dcl.type.simple#4.2\" rel=\"nofollow noreferrer\"><code>decltype(auto)</code> is deduced to be the declared type for unparenthesized id-expression</a>, we can focus on the deduction from the <code>std::invoke</code> expression.</p>\n<p>Quoted from <a href=\"http://eel.is/c++draft/dcl.type.auto.deduct#5\" rel=\"nofollow noreferrer\">[dcl.type.auto.deduct] paragraph 5:</a></p>\n<blockquote>\n<p id=\"so_49033889_49035607_0\">If the placeholder is the <code>decltype(auto)</code> <em>type-specifier</em>, <code>T</code> shall be the placeholder alone. The type deduced for <code>T</code> is determined as described in [dcl.type.simple], as though <code>e</code> had been the operand of the <code>decltype</code>.</p>\n</blockquote>\n<p>And quoted from <a href=\"http://eel.is/c++draft/dcl.type.simple#4\" rel=\"nofollow noreferrer\">[dcl.type.simple] paragraph 4</a>:</p>\n<blockquote>\n<p id=\"so_49033889_49035607_1\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<ul>\n<li><p id=\"so_49033889_49035607_2\">if <code>e</code> is an unparenthesized id-expression naming a structured binding ([dcl.struct.bind]), <code>decltype(e)</code> is the referenced type as given in the specification of the structured binding declaration;</p></li>\n<li><p id=\"so_49033889_49035607_3\">otherwise, if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access, <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</p></li>\n<li><p id=\"so_49033889_49035607_4\">otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p></li>\n<li><p id=\"so_49033889_49035607_5\">otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p></li>\n<li><p id=\"so_49033889_49035607_6\">otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p></li>\n</ul>\n</blockquote>\n<p>Note <code>decltype(e)</code> is deduced to be <code>T</code> instead of <code>T&amp;&amp;</code> if <code>e</code> is a prvalue. This is the difference from <code>auto&amp;&amp;</code>. </p>\n<p>So if <code>std::invoke(std::forward&lt;Callable&gt;(op), std::forward&lt;Args&gt;(args)...)</code> is a prvalue, for example, the return type of <code>Callable</code> is not a reference, i.e. returning by value, <code>ret</code> is deduced to be the same type instead of a reference, which perfectly forwards the semantic of returning by value.</p>\n", "LastEditorUserId": "5376789", "LastActivityDate": "2018-03-01T02:39:55.970", "Score": "5", "CreationDate": "2018-02-28T17:43:45.540", "ParentId": "49033889", "CommentCount": "1", "OwnerUserId": "5376789", "LastEditDate": "2018-03-01T02:39:55.970"}});