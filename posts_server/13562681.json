post_cb({"13562751": {"PostTypeId": "2", "Body": "<p>According to <a href=\"https://stackoverflow.com/questions/13521030/\">this</a> question, the Standard does not define that you can take member function pointers to members of Standard objects.</p>\n<p>And <code>_Pairib</code> is an MSVC implementation detail- naturally you won't find a similar thing in GCC.</p>\n", "LastActivityDate": "2012-11-26T10:19:51.777", "LastEditorUserId": "-1", "Id": "13562751", "CommentCount": "0", "CreationDate": "2012-11-26T10:19:51.777", "ParentId": "13562681", "Score": "0", "OwnerUserId": "298661", "LastEditDate": "2017-05-23T12:14:37.513"}, "13562681": {"ViewCount": "893", "Body": "<p>I've been hanging around a problem for at least two weeks, being blocked by stuff that I'm not able to understand and making questions in SO that doesn't really pointed to the real problem (silly me!). Finally now, I wish I had found the real point of my headache in this question.</p>\n<p>I've been using a template struct as helper to detect whether or not a given type has a member method or not, this template struct looks like this:</p>\n<pre><code>template\n&lt;\n    typename Type,\n    typename Return,\n    typename Parameter,\n    Return (Type::*)(Parameter)\n&gt; struct W {};\n</code></pre>\n<p>The main idea arround the <code>struct W</code> is to put as fourth parameter a member function pointer to the member function I need to test using the SFINAE trick, <a href=\"https://stackoverflow.com/questions/13468736/how-to-find-if-a-method-of-a-particular-prototype-exists-inside-a-class/13469404#13469404\">in a previous question</a> an alternative was suggested and it helped me so much to understand many concepts that I've been missing, but in the end, it doesn't solves my real problem.</p>\n<p>The piece of code that i'm working on, must work in both Linux and Windows platforms, the compiler i'm using for windows is MSVC (Visual Stuido 2010 10.0) and gcc (Devian 4.4.5-8) on Linux side. The problem is that the same piece of code doesn't compile in MSVC but it does in gcc (I was shocked, usually is the oposite, cause MSVC is less standard-strict).</p>\n<p>The origin of the problem was that my SFINAE approach fails to detect the method <code>set::insert</code> while compiling under MSVC, in order to look for this fail i wrote a <a href=\"http://ideone.com/0BkRKJ\" rel=\"nofollow noreferrer\">simple test</a>:</p>\n<pre><code>#include &lt;set&gt;\n\nint main(int argc, char **argv)\n{\n    typedef std::set&lt;int&gt; setint;\n\n    std::pair&lt;setint::iterator, bool&gt; (setint::*p_1)(const setint::value_type &amp;) = &amp;setint::insert;\n    W&lt;setint, std::pair&lt;setint::iterator, bool&gt;, const setint::value_type &amp;, &amp;setint::insert&gt; w_1;\n\n    return 0;\n}\n</code></pre>\n<p>As i mentioned before: this sample compiles without problem using gcc, but while using MSVC gives an error at the declaration of <code>w_1</code>:</p>\n<pre><code>error C2440: 'specialization' : cannot convert from 'overloaded-function' to 'std::pair&lt;_Ty1,_Ty2&gt; (__thiscall std::set&lt;_Kty&gt;::* )(const int &amp;)'\n    with\n    [\n        _Ty1=std::_Tree_const_iterator&lt;std::_Tree_val&lt;std::_Tset_traits&lt;int,std::less&lt;int&gt;,std::allocator&lt;int&gt;,false&gt;&gt;&gt;,\n        _Ty2=bool,\n        _Kty=int\n    ]\n    None of the functions with this name in scope match the target type\n</code></pre>\n<p>While creating a function pointer works as expected, so the declaration of <code>p_1</code> compiles; but with the same signature as template parameter does not. This is why the <code>set::insert</code> detection fails during the symbols substitution of SFINAE. The error text <code>cannot convert from 'overloaded-function'</code> doesn't provides me any clue about what's going on (or i'm not able to find any, due my poor english understanding).</p>\n<p>At first sight, i've been thinking that the problem is the symbols substitution, but it would make sense if it failed in both MSVC and gcc as well. So for now i'm wondering if the problem is some MSVC compiler-specific way to do things.</p>\n<p><strong>Any clue about why is it failing under MSVC and how to make gcc and MSVC works in the same way?</strong></p>\n<p>Extra question: <code>std::map</code> and <code>std::set</code> provides a nested type <code>_Pairib</code> as return type for <code>::insert</code> method under the MSVC implementation of red-black tree (or whatever is under <code>map</code> and <code>set</code>), there's no equivalent in the gcc implementation?</p>\n<p><strong>EDIT:</strong></p>\n<p>After reading the <a href=\"https://stackoverflow.com/a/13563449/499359\">chill answer</a>, I've looked into the MSVC's <code>std::set</code> implementation.</p>\n<p><code>std::set</code> is a derived class of <code>std::_Tree</code> that provides the method i want to check:</p>\n<pre><code>// class std::_Tree, file xtree in the path 'VisualStudioPath/VC/include/'\n_Pairib insert(const value_type&amp; _Val)\n    {    // try to insert node with value _Val, favoring right side\n    return (insert(_Val, false));\n    }\n</code></pre>\n<p>This insert method belongs to the <code>std::_Tree</code> scope, not to <code>std::set</code> scope, but it is into the public scope and is a inherited method as well, so <strong>why it isn't accesible during the name substitution?</strong></p>\n", "AcceptedAnswerId": "13563449", "Title": "MSVC pointer to overloaded function in template parameter", "CreationDate": "2012-11-26T10:16:10.917", "Id": "13562681", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:57:59.040", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-27T08:34:51.700", "Score": "3", "OwnerUserId": "499359", "Tags": "<c++><templates><visual-c++><gcc><sfinae>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13562681_13563449_1": {"length": 28, "quality": 0.9032258064516129, "section_id": 91}}, "n3337": {"so_13562681_13563449_1": {"length": 28, "quality": 0.9032258064516129, "section_id": 86}}}, "13563449": {"PostTypeId": "2", "Body": "<p>The cause for failing is that in the VC stdlib, the <code>insert</code> is not actually a member of the <code>set</code> class template itself, but is inherited:</p>\n<p>Test case,</p>\n<pre><code>template\n&lt;\n    typename Type,\n    typename Return,\n    typename Parameter,\n    Return (Type::*)(Parameter)\n&gt; struct W {};\n\nstruct A { void foo (int); };\n\nstruct B : public A {};\n\nint main(int argc, char **argv)\n{\n    void (B::*p)(int) = &amp;B::foo;\n    // W&lt;B, void, int, &amp;B::foo&gt; w; // error\n    W&lt;A, void, int, &amp;A::foo&gt; w;\n\n    return 0;\n}\n</code></pre>\n<p>PS. The error is error in both some GCC and some MSVC.</p>\n<blockquote>\n<p id=\"so_13562681_13563449_0\">But it is on the public scope and is an inherited method as well, so I don't get why isn't it accesible.</p>\n</blockquote>\n<p>Because no conversion is allowed in this case, \"14.3.2. Template non-type arguments [#5]\"</p>\n<blockquote>\n<p id=\"so_13562681_13563449_1\">For a non-type template-parameter of type pointer to member function,\n  if the template-argument is of type std::nullptr_t, the null member\n  pointer conversion (4.11) is applied; <strong>otherwise, no conversions apply</strong>.\n  If the template-argument represents a set of overloaded member\n  functions, the matching member function is selected from the set\n  (13.4).</p>\n</blockquote>\n<p>PPS. So, you do the conversion explicitly and voila, you don't need to care for possible base classes:</p>\n<pre><code>W&lt;setint,\n  std::pair&lt;setint::iterator, bool&gt;,\n  const setint::value_type &amp;,\n  static_cast&lt;std::pair&lt;setint::iterator, bool&gt; (setint::*)(const setint::value_type &amp;)&gt; (&amp;setint::insert)&gt; w_1;\n</code></pre>\n", "LastActivityDate": "2012-11-27T08:34:51.700", "LastEditorUserId": "390807", "Id": "13563449", "CommentCount": "3", "CreationDate": "2012-11-26T10:58:30.223", "ParentId": "13562681", "Score": "2", "OwnerUserId": "390807", "LastEditDate": "2012-11-27T08:34:51.700"}});