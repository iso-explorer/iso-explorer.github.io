post_cb({"712534": {"CommentCount": "0", "CreationDate": "2009-04-03T04:22:44.937", "LastEditorUserId": "12711", "LastActivityDate": "2009-04-03T04:38:52.510", "ParentId": "712334", "PostTypeId": "2", "LastEditorDisplayName": "Michael Burr", "LastEditDate": "2009-04-03T04:38:52.510", "Id": "712534", "Score": "2", "Body": "<p>Writing to a const object through a cast that removes the const is undefined behavior - so at the point where you do this:</p>\n<pre><code>(*pTOCONST) = 7;\n</code></pre>\n<p>all bets are off.  </p>\n<p>From the C++ standard 7.1.5.1 (The cv-qualifiers):</p>\n<blockquote>\n<p id=\"so_712334_712534_0\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const\n  object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>Because of this, the compiler is free to assume that the value of <code>IAMCONST</code> will not change, so it can optimize away the access to the actual storage. In fact, if the address of the const object is never taken, the compiler may eliminate the storage for the object altogether.</p>\n<p>Also note that (again in 7.1.5.1):</p>\n<blockquote>\n<p id=\"so_712334_712534_1\">A  variable  of  non-volatile const-qualified integral or enumeration type initialized by an integral constant  expression  can  be used in integral constant expressions (5.19). </p>\n</blockquote>\n<p>Which means IAMCONST can be used in compile-time constant expressions (ie., to provide a value for an enumeration or the size of an array).  What would it even mean to change that at runtime?</p>\n", "OwnerUserId": "12711", "OwnerDisplayName": "Michael Burr"}, "712334": {"CommentCount": "2", "AcceptedAnswerId": "712349", "PostTypeId": "1", "LastEditorUserId": "4774918", "LastEditorDisplayName": "ojblass", "CreationDate": "2009-04-03T02:20:15.263", "LastActivityDate": "2017-06-21T20:57:01.280", "AnswerCount": "5", "LastEditDate": "2017-06-21T20:57:01.280", "ViewCount": "855", "FavoriteCount": "3", "Title": "Does the evil cast get trumped by the evil compiler?", "Id": "712334", "Score": "7", "Body": "<p>This is not academic code or a hypothetical quesiton.  The original problem was converting code from HP11 to HP1123 Itanium.  Basically it boils down to a compile error on HP1123 Itanium.  It has me really scratching my head when reproducing it on Windows for study.  I have stripped all but the most basic aspects... You may have to press control D to exit a console window if you run it as is:</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\nusing namespace std;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    char blah[6];\n    const int IAMCONST = 3;\n    int *pTOCONST;\n    pTOCONST = (int *)  &amp;IAMCONST;\n    (*pTOCONST) = 7;\n    printf(\"IAMCONST %d \\n\",IAMCONST);\n    printf(\"WHATISPOINTEDAT %d \\n\",(*pTOCONST));\n    printf(\"Address of IAMCONST %x   pTOCONST %x\\n\",&amp;IAMCONST, (pTOCONST));\n    cin &gt;&gt; blah;    \n    return 0;\n}\n</code></pre>\n<p>Here is the output</p>\n<pre><code>IAMCONST 3\nWHATISPOINTEDAT 7\nAddress of IAMCONST 35f9f0   pTOCONST 35f9f0\n</code></pre>\n<p>All I can say is what the heck?  Is it undefined to do this?  It is the most counterintuitive thing I have seen for such a simple example.</p>\n<p><strong>Update:</strong></p>\n<p>Indeed after searching for a while the Menu Debug &gt;&gt; Windows &gt;&gt; Disassembly had exactly the optimization that was described below.</p>\n<pre><code>    printf(\"IAMCONST %d \\n\",IAMCONST);\n0024360E  mov         esi,esp \n00243610  push        3    \n00243612  push        offset string \"IAMCONST %d \\n\" (2458D0h) \n00243617  call        dword ptr [__imp__printf (248338h)] \n0024361D  add         esp,8 \n00243620  cmp         esi,esp \n00243622  call        @ILT+325(__RTC_CheckEsp) (24114Ah) \n</code></pre>\n<p>Thank you all!</p>\n", "Tags": "<c++>", "OwnerUserId": "66519", "OwnerDisplayName": "ojblass"}, "712412": {"ParentId": "712334", "CommentCount": "7", "Body": "<p>You are lucky the compiler is doing the optimization.  An alternative treatment would be to place the const integer into read-only memory, whereupon trying to modify the value would cause a core dump.</p>\n", "OwnerUserId": "15168", "Id": "712412", "PostTypeId": "2", "OwnerDisplayName": "Jonathan Leffler", "Score": "4", "CreationDate": "2009-04-03T03:00:35.557", "LastActivityDate": "2009-04-03T03:00:35.557"}, "712613": {"ParentId": "712334", "CommentCount": "4", "Body": "<p>It doesn't matter if the compiler optimizes or not.  You asked for trouble and you're lucky you got the trouble yourself instead of waiting for customers to report it to you.</p>\n<p>\"All I can say is what the heck? Is it undefined to do this? It is the most counterintuitive thing I have seen for such a simple example.\"</p>\n<p>If you really believe that then you need to switch to a language you can understand, or change professions.  For the sake of yourself and your customers, stop using C or C++ or C#.</p>\n<pre><code>const int IAMCONST = 3;\n</code></pre>\n<p>You said it.</p>\n<pre><code>int *pTOCONST;\npTOCONST = (int *)  &amp;IAMCONST;\n</code></pre>\n<p>Guess why the compiler complained if you omitted your evil cast.  The compiler might have been telling the truth before you lied to it.</p>\n<p>\"Does the evil cast get trumped by the evil compiler?\"</p>\n<p>No.  The evil cast gets trumped by itself.  Whether or not your compiler tried to tell you the truth, the compiler was not evil.</p>\n", "OwnerUserId": "23705", "Id": "712613", "PostTypeId": "2", "OwnerDisplayName": "Windows programmer", "Score": "-3", "CreationDate": "2009-04-03T05:03:56.663", "LastActivityDate": "2009-04-03T05:03:56.663"}, "712342": {"CommentCount": "5", "CreationDate": "2009-04-03T02:25:43.907", "LastEditorUserId": "15168", "LastActivityDate": "2009-04-03T02:57:01.117", "ParentId": "712334", "PostTypeId": "2", "LastEditorDisplayName": "Jonathan Leffler", "LastEditDate": "2009-04-03T02:57:01.117", "Id": "712342", "Score": "6", "Body": "<p>The constant value IAMCONST is being inlined into the printf call.  </p>\n<p>What you're doing is at best wrong and in all likelihood is undefined by the C++ standard. My <strong>guess</strong> is that the C++ standard leaves the compiler free to inline a const primitive which is local to a function declaration.  The reason being that the value should not be able to change.</p>\n<p>Then again, it's C++ where should and can are very different words.  </p>\n", "OwnerUserId": "23283", "OwnerDisplayName": "JaredPar"}, "712349": {"CommentCount": "4", "CreationDate": "2009-04-03T02:27:35.993", "LastEditorUserId": "20713", "LastActivityDate": "2009-04-03T03:50:20.070", "ParentId": "712334", "PostTypeId": "2", "LastEditorDisplayName": "ephemient", "LastEditDate": "2009-04-03T03:50:20.070", "Id": "712349", "Score": "24", "Body": "<p>Looks like the compiler is optimizing</p>\n<pre><code>printf(\"IAMCONST %d \\n\",IAMCONST);\n</code></pre>\n<p>into</p>\n<pre><code>printf(\"IAMCONST %d \\n\",3);\n</code></pre>\n<p>since you <em>said</em> that <code>IAMCONST</code> is a <code>const int</code>.</p>\n<p>But since you're taking the address of <code>IAMCONST</code>, it has to actually be located on the stack somewhere, and the <code>const</code>ness can't be enforced, so the memory at that location (<code>*pTOCONST</code>) is mutable after all.</p>\n<p>In short: you casted away the <code>const</code>ness, don't do that.  Poor, defenseless C...</p>\n<h3>Addendum</h3>\n<p>Using GCC for x86, with <code>-O0</code> (no optimizations), the generated assembly</p>\n<pre><code>main:\n    leal    4(%esp), %ecx\n    andl    $-16, %esp\n    pushl   -4(%ecx)\n    pushl   %ebp\n    movl    %esp, %ebp\n    pushl   %ecx\n    subl    $36, %esp\n    movl    $3, -12(%ebp)\n    leal    -12(%ebp), %eax\n    movl    %eax, -8(%ebp)\n    movl    -8(%ebp), %eax\n    movl    $7, (%eax)\n    movl    -12(%ebp), %eax\n    movl    %eax, 4(%esp)\n    movl    $.LC0, (%esp)\n    call    printf\n    movl    -8(%ebp), %eax\n    movl    (%eax), %eax\n    movl    %eax, 4(%esp)\n    movl    $.LC1, (%esp)\n    call    printf\n</code></pre>\n<p>copies from <code>*(bp-12)</code> on the stack to <code>printf</code>'s arguments.  However, using <code>-O1</code> (as well as <code>-Os</code>, <code>-O2</code>, <code>-O3</code>, and other optimization levels),</p>\n<pre><code>main:\n    leal    4(%esp), %ecx\n    andl    $-16, %esp\n    pushl   -4(%ecx)\n    pushl   %ebp\n    movl    %esp, %ebp\n    pushl   %ecx\n    subl    $20, %esp\n    movl    $3, 4(%esp)\n    movl    $.LC0, (%esp)\n    call    printf\n    movl    $7, 4(%esp)\n    movl    $.LC1, (%esp)\n    call    printf\n</code></pre>\n<p>you can clearly see that the constant <code>3</code> is used instead.</p>\n<p>If you are using Visual Studio's <code>CL.EXE</code>, <code>/Od</code> disables optimization.  This varies from compiler to compiler.</p>\n<p>Be warned that the C specification <a href=\"http://en.wikipedia.org/wiki/Type_punning\" rel=\"noreferrer\">allows</a> the C compiler to assume that the target of any <code>int *</code> pointer never overlaps the memory location of a <code>const int</code>, so you really shouldn't be doing this at all if you want predictable behavior.</p>\n", "OwnerUserId": "20713", "OwnerDisplayName": "ephemient"}, "bq_ids": {"n4140": {"so_712334_712534_1": {"section_id": 5908, "quality": 0.6, "length": 9}, "so_712334_712534_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_712334_712534_1": {"section_id": 5680, "quality": 0.6, "length": 9}, "so_712334_712534_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_712334_712534_1": {"section_id": 7687, "quality": 0.5333333333333333, "length": 8}, "so_712334_712534_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}});