post_cb({"37536718": {"Id": "37536718", "PostTypeId": "2", "Body": "<p>The problem you're encountering seems to be <a href=\"http://eel.is/c++draft/implimits\" rel=\"nofollow\">exceeding the implementation-defined limits</a>, which would then make invocations to <code>fib</code> not a <a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow\">constant expression</a>:</p>\n<blockquote>\n<p id=\"so_37536573_37536718_0\">A <em>conditional-expression</em> <code>e</code> is a core constant expression unless\n  the evaluation of <code>e</code>, following the rules of the abstract machine\n  ([intro.execution]), would evaluate one of the following expressions:</p>\n<ul>\n<li>an expression that would exceed the implementation-defined limits (see Annex [implimits]);</li>\n</ul>\n</blockquote>\n<p>In particular:</p>\n<blockquote id=\"so_37536573_37536718_1\">\n<ul>\n<li>Recursive <code>constexpr</code> function invocations [512].</li>\n</ul>\n</blockquote>\n<p>And possibly:</p>\n<blockquote id=\"so_37536573_37536718_2\">\n<ul>\n<li>Size of an object [262 144]. </li>\n</ul>\n</blockquote>\n<p>as well.</p>\n<p>The indicator would be that clang considers <code>int arr[fib(3)];</code> fine but complains about <code>int arr[fib(45)];</code>, giving a rather misleading diagnostic.</p>\n<p>To get around this problem, I would use an iterative algorithm for fibonacci which would be faster and get around your recursive depth issue.</p>\n", "Score": "2", "LastActivityDate": "2016-05-31T04:14:35.750", "CreationDate": "2016-05-31T04:14:35.750", "ParentId": "37536573", "CommentCount": "1", "OwnerUserId": "6292850"}, "37536573": {"ViewCount": "248", "Body": "<p>Take the following constexpr example:  </p>\n<pre><code>#include &lt;iostream&gt;\n\nconstexpr int fib(const int i)\n{\n  if (i == 0) return 0;\n  if (i == 1) return 1;\n  return fib(i-1) + fib(i-2);\n}\n\nint main(){\n  std::cout &lt;&lt; fib(45) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Despite being constexpr, it is <strong>not</strong> evaluated at compile time.<br>\nThe trick I've learned to enforce the compile time evaluation, is as followed:  </br></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n#define COMPILATION_EVAL(e) (std::integral_constant&lt;decltype(e), e&gt;::value)\n\nconstexpr int fib(const int i)\n{\n  if (i == 0) return 0;\n  if (i == 1) return 1;\n  return fib(i-1) + fib(i-2);\n}\n\nint main(){\n  std::cout &lt;&lt; COMPILATION_EVAL(fib(45)) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>This works is g++, however I get the following error in clang++:  </p>\n<pre><code>clang++-3.9 --std=c++1z -o main main.cpp \n\nmain.cpp:14:33: error: non-type template argument is not a constant expression\n  std::cout &lt;&lt; COMPILATION_EVAL(fib(45)) &lt;&lt; '\\n';\n                                ^~~~~~~\nmain.cpp:4:66: note: expanded from macro 'COMPILATION_EVAL'\n#define COMPILATION_EVAL(e) (std::integral_constant&lt;decltype(e), e&gt;::value)\n                                                                 ^\nmain.cpp:9:3: note: constexpr evaluation hit maximum step limit; possible infinite loop?\n  if (i == 1) return 1;\n  ^\nmain.cpp:10:21: note: in call to 'fib(7)'\n  return fib(i-1) + fib(i-2);\n                    ^\nmain.cpp:10:21: note: in call to 'fib(9)'\nmain.cpp:10:10: note: in call to 'fib(11)'\n  return fib(i-1) + fib(i-2);\n         ^\nmain.cpp:10:10: note: in call to 'fib(12)'\nmain.cpp:10:10: note: in call to 'fib(13)'\nmain.cpp:10:21: note: (skipping 23 calls in backtrace; use -fconstexpr-backtrace-limit=0 to see all)\n  return fib(i-1) + fib(i-2);\n                    ^\nmain.cpp:10:10: note: in call to 'fib(41)'\n  return fib(i-1) + fib(i-2);\n         ^\nmain.cpp:10:10: note: in call to 'fib(42)'\nmain.cpp:10:10: note: in call to 'fib(43)'\nmain.cpp:10:10: note: in call to 'fib(44)'\nmain.cpp:14:33: note: in call to 'fib(45)'\n  std::cout &lt;&lt; COMPILATION_EVAL(fib(45)) &lt;&lt; '\\n';\n                                ^\n1 error generated.  \n</code></pre>\n<p>I've tried increasing the constexpr-steps, but clang will still not compile the code:  </p>\n<pre><code>clang++-3.9 -fconstexpr-depth=99999999 -fconstexpr-backtrace-limit=9999999 -fconstexpr-steps=99999999 --std=c++1z -o main main.cpp\n</code></pre>\n<p>What must I do for clang to compile this code as is?  </p>\n<p><strong>clang++:</strong> </p>\n<pre><code>clang version 3.9.0-svn267343-1~exp1 (trunk)\n</code></pre>\n<p><strong>g++:</strong> </p>\n<pre><code>g++ (Ubuntu 5.1.0-0ubuntu11~14.04.1) 5.1.0\n</code></pre>\n", "AcceptedAnswerId": "37599241", "Title": "Why can't I resolve a constant expression after increasing -fconstexpr-steps?", "CreationDate": "2016-05-31T03:56:03.203", "Id": "37536573", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2016-06-02T19:14:10.720", "Score": "4", "OwnerUserId": "908939", "Tags": "<c++><constexpr><clang++><c++1z><compile-time-constant>", "AnswerCount": "4"}, "37536869": {"Id": "37536869", "PostTypeId": "2", "Body": "<p>When evaluating a <code>constexpr</code> you are not allowed to have undefined behavior according to 5.20 [expr.const] paragraph 2.6:</p>\n<blockquote>\n<p id=\"so_37536573_37536869_0\">an operation that would have undefined behavior as specified in Clauses 1 through 16 of this International Standard [Note: including, for example, signed integer overflow (Clause 5) ... ]</p>\n</blockquote>\n<p>Overflowing a signed integer object is undefined behavior and <code>fib(45)</code> is a pretty large value (I would have expected overflows earlier than that...). I would imagine that the code compiles OK (but, of course, eventually the results are wrong) if you used</p>\n<pre><code>constexpr unsigned int fib(unsigned int i) { ... }\n</code></pre>\n", "Score": "2", "LastActivityDate": "2016-05-31T04:31:32.550", "CreationDate": "2016-05-31T04:31:32.550", "ParentId": "37536573", "CommentCount": "1", "OwnerUserId": "1120273"}, "37536853": {"Id": "37536853", "PostTypeId": "2", "LastEditDate": "2016-06-02T18:05:20.460", "CommentCount": "5", "LastEditorUserId": "6210", "LastActivityDate": "2016-06-02T18:05:20.460", "CreationDate": "2016-05-31T04:30:12.593", "ParentId": "37536573", "Score": "1", "Body": "<p>Given that the complexity of naive Fibonacci is <code>O(2^N)</code>, <code>99999999</code> is much less than <code>2^45</code>. So you can try putting in <code>-fconstexpr-steps=35184372088832</code>, but I suspect that will hit some internal compiler limits. </p>\n", "OwnerUserId": "6210"}, "bq_ids": {"n4140": {"so_37536573_37536718_1": {"length": 5, "quality": 1.0, "section_id": 47}, "so_37536573_37536869_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 6185}, "so_37536573_37536718_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6185}}, "n4659": {"so_37536573_37536718_1": {"length": 5, "quality": 1.0, "section_id": 48}, "so_37536573_37536869_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 7687}, "so_37536573_37536718_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 7687}}}, "37599241": {"Id": "37599241", "PostTypeId": "2", "LastEditDate": "2016-06-02T19:14:10.720", "CommentCount": "3", "LastEditorUserId": "1774667", "LastActivityDate": "2016-06-02T19:14:10.720", "CreationDate": "2016-06-02T18:10:25.433", "ParentId": "37536573", "Score": "2", "Body": "<p>clang does not memoize constexpr function invocations.</p>\n<p><a href=\"https://stackoverflow.com/questions/24591466/constexpr-depth-limit-with-clang-fconstexpr-depth-doesnt-seem-to-work\">Here is someone strugging with a similar problem</a>.</p>\n<p>The number of steps in fib(47) is on the order of <code>2^45</code>, or <code>35184372088832</code>.  If you send this many steps at <code>-fconstexpr-steps=</code>, <a href=\"http://coliru.stacked-crooked.com/a/d31db7f3c8f4aece\" rel=\"nofollow\">you get:</a>:</p>\n<pre><code>error: invalid integral value '35184372088832' in '-fconstexpr-steps 35184372088832'\n</code></pre>\n<p>basically, value too big.  Even if it wasn't, the compiler would probably blow up before it ran that many steps, due to lack of memoization.  (well, phi^47 is closer to the number of recursive steps, but that is still 36 bits of size, and clang stores <code>constexpr-steps</code> in a 32 bit unsigned int, so no dice)</p>\n<p>Memoization is the thing where you keep track of what values map to what results.  So g++ evaluates fib(47) by first evaluating fib(46) then all the way down to fib(1) and fib(0).  Then it evaluates fib(45), but <em>it already did so when it calculated fib(46)</em>, so it just looks up the result and uses it.</p>\n<p>g++ runs O(N+1) steps to calculate fib(47).  Clang does not memoize and keep track of the result of previous calls to fib, so it explores the binary tree of recursive calls.  This takes more than any reasonable number of steps, and it hits not a depth limit or a recursion limit, but rather a step limit.</p>\n<p>The cost to memoizing is that it uses more memory.</p>\n<p>In order to make clang compile the program as is, you'll have to modify the clang compiler source code itself to add memoization to its constexpr evaluation engine.</p>\n", "OwnerUserId": "1774667"}});