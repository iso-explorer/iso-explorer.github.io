post_cb({"22055724": {"CommentCount": "2", "ViewCount": "120", "PostTypeId": "1", "ClosedDate": "2014-03-12T23:01:56.617", "LastEditorUserId": "827263", "CreationDate": "2014-02-26T23:22:10.403", "LastActivityDate": "2014-02-26T23:58:10.677", "Title": "Is it thread safe to dump results from threads into a vector?", "AcceptedAnswerId": "22055905", "LastEditDate": "2014-02-26T23:50:29.550", "Id": "22055724", "Score": "0", "Body": "<p>I'm learning the C++11 features and wrote some code along the following lines</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;thread&gt;\nusing std::thread;\nusing std::vector;\n\ndouble Computation(int arg)\n{\n    // some long-running computation\n    return 42.0;\n}\n\ndouble ConcurrentComputations()\n{\n    const int N = 8; // number of threads\n    vector&lt;thread&gt; thr;\n    vector&lt;double&gt; res(N);\n    const int arg = 123456; // something or other\n    // Kick off threads which dump their results into res\n    for(int i=0; i&lt;N; ++i)\n        thr.push_back(thread ([&amp;res, i, arg]()\n                {  res[i] =  Computation(arg); } ));\n    // Wait for them to finish and get results\n    double sum = 0;\n    for(int i=0; i&lt;N; ++i) {\n        thr[i].join();\n        sum += res[i];\n    }\n    return sum;\n}\n</code></pre>\n<p>Looking at it again in the cold light of day, I don't think I really should have been taking a reference to a <code>vector</code> in the lambda function and dumping data into it. I was thinking of the vector as a regular array and relying on the implementation of <code>operator[]</code> to simply add <code>i</code> to <code>&amp;res.front()</code> (maybe I should have captured <code>&amp;res.front()</code> instead, and now that I've read further in Stroustrup 4ed I can see I should maybe use futures and promises).</p>\n<p>Nevertheless, my question is, is it reasonable to think that in practice I can get away with the code that I wrote?</p>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "834521", "AnswerCount": "2"}, "22055905": {"ParentId": "22055724", "CommentCount": "1", "Body": "<p>You're code is actually fine! (Code is generally broken by default when threads are mixed in, but not in this case.)</p>\n<p>The declaration <code>vector&lt;double&gt; res(N);</code> will initialize the array with enough space for all the results, so the vector will never be resized in the loop.</p>\n<p>Each thread only writes to a different element of the vector, and there's implicit memory barriers in the thread constructor and join() method that keep ordering as you'd expect.</p>\n<p>Now, as to whether this is actually supported by the standard -- hmm, probably not (most references I find to thread-safety regarding std::vector only give guarantees for reads, not writes). Capturing the front wouldn't help either, because you're still doing a write to an element of the vector either way.</p>\n<p>(Note that I've personally used this exact pattern successfully across platforms without encountering any problems.)</p>\n", "OwnerUserId": "21475", "PostTypeId": "2", "Id": "22055905", "Score": "5", "CreationDate": "2014-02-26T23:35:13.740", "LastActivityDate": "2014-02-26T23:35:13.740"}, "22056219": {"ParentId": "22055724", "CommentCount": "3", "Body": "<p>I believe your code is (almost) legal, with well defined behavior (see below for the explanation of the \"almost\" part).</p>\n<p>The important parts of the standard are these:</p>\n<blockquote>\n<p id=\"so_22055724_22056219_0\"><strong>17.6.5.9/5</strong> A C++ standard library function shall not access objects indirectly accessible via its arguments or via elements of its container arguments except by invoking functions required by its specification on those container elements.</p>\n<p id=\"so_22055724_22056219_1\"><strong>17.6.5.9/6</strong> Operations on iterators obtained by calling a standard library container or string member function may access the underlying container, but shall not modify it.</p>\n</blockquote>\n<p><code>res[i]</code> is equivalent to <code>*(res.begin() + i)</code> (Table 101 in 23.2.3) This is the only hitch: I can't prove from the text of the standard that <code>res.begin()</code> doesn't modify the vector. If we postulate a reasonable implementation that doesn't do something egregious like this, then the rest is smooth sailing: a call to <code>begin</code> is followed by <code>operator+</code> and <code>operator*</code> on the resulting iterator, both of which may only access the container but not modify it. Concurrent accesses to a shared object are OK, they don't cause data races.</p>\n<p><code>res[i]</code> returns a <code>double&amp;</code>, and then an assignment to this <code>double</code> object is performed. This is a modification - but no two threads modify the same object, so no races here, either.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "22056219", "Score": "3", "CreationDate": "2014-02-26T23:58:10.677", "LastActivityDate": "2014-02-26T23:58:10.677"}, "bq_ids": {"n4140": {"so_22055724_22056219_0": {"section_id": 6350, "quality": 0.9583333333333334, "length": 23}, "so_22055724_22056219_1": {"section_id": 6351, "quality": 0.9375, "length": 15}}, "n3337": {"so_22055724_22056219_0": {"section_id": 6107, "quality": 0.9583333333333334, "length": 23}, "so_22055724_22056219_1": {"section_id": 6108, "quality": 0.9375, "length": 15}}, "n4659": {"so_22055724_22056219_0": {"section_id": 7859, "quality": 0.9583333333333334, "length": 23}, "so_22055724_22056219_1": {"section_id": 7860, "quality": 0.9375, "length": 15}}}});