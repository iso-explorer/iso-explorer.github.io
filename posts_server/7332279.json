post_cb({"7332416": {"ParentId": "7332279", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Assignment operators are <strong>hidden</strong> by derived class by default (as compiler always generates a <code>T&amp; operator = ()</code> for any <code>class T</code>, if not specified). Which makes the inherited <code>operator =</code> not usable.</p>\n<p><strong>Yes</strong> when you specify them with <code>using</code> keyword; they become <strong>usable</strong>. <a href=\"http://www.ideone.com/baGH8\" rel=\"nofollow\">Demo</a>. So your code snippet does make sense.</p>\n<pre><code>public: using TestA::operator=;\n</code></pre>\n", "OwnerUserId": "514235", "LastEditorUserId": "514235", "LastEditDate": "2011-09-07T11:07:15.683", "Id": "7332416", "Score": "3", "CreationDate": "2011-09-07T10:33:36.977", "LastActivityDate": "2011-09-07T11:07:15.683"}, "7332349": {"ParentId": "7332279", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>Assignment operator isn't inherited by derived.  If you use your overloaded assignment operator in your derived, from your base, you might encounter slicing: <code>sizeof(base) != sizeof(derived)</code></p>\n", "OwnerUserId": "174614", "LastEditorUserId": "174614", "LastEditDate": "2011-09-07T10:35:29.720", "Id": "7332349", "Score": "0", "CreationDate": "2011-09-07T10:27:46.490", "LastActivityDate": "2011-09-07T10:35:29.720"}, "7332279": {"CommentCount": "6", "AcceptedAnswerId": "7332416", "CreationDate": "2011-09-07T10:21:58.390", "LastActivityDate": "2011-09-07T11:19:48.333", "PostTypeId": "1", "ViewCount": "1138", "FavoriteCount": "2", "Title": "Sub-classes, assignment operator overloading?", "Id": "7332279", "Score": "6", "Body": "<p>If I have the given below classes:</p>\n<pre><code>class TestA\n{\n    public:\n        const TestA &amp;operator=(const int A){return *this;}\n};\n\nclass TestB : public TestA\n{\n    public:\n        //Inheritance?\n};\n</code></pre>\n<p>The question presumes both class TestA and class TestB have exactly the same contents in terms of variables: Is the assignment operator (or any other operator) inherited?</p>\n<p>Is the following valid?</p>\n<pre><code>class TestB : public TestA\n{\n    public:\n        using TestA::operator=;\n        //Inheritance?\n};\n</code></pre>\n<p>If it is valid, would it make a difference?</p>\n", "Tags": "<c++><subclass>", "OwnerUserId": "889894", "AnswerCount": "4"}, "7332866": {"ParentId": "7332279", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The question's example code as I'm writing this:</p>\n<pre><code>class TestA\n{\n    public:\n        const TestA &amp;operator=(const int A){return *this;}\n};\n\nclass TestB : public TestA\n{\n    public:\n        //Inheritance?\n};\n</code></pre>\n<h3>Q1: \"Is the assignment operator (or any other operator) inherited?\"</h3>\n<p>Yes, of course. The only member functions that are not inherited in C++98, are constructors. However, the base class implementations are by default <strong>hidden</strong> by the automatically generated <em>copy assignment</em> operator. Example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass TestA\n{\n    public:\n        TestA const&amp; operator=( int const )\n        {\n            cout &lt;&lt; \"TestA = int\" &lt;&lt; endl;\n            return *this;\n        }\n};\n\nclass TestB : public TestA\n{\n    public:\n        // Automatically generated copy assignment operator.\n};\n\nint main()\n{\n    TestB   o;\n\n    cout &lt;&lt; \"Calling automatically generated copy assignment:\" &lt;&lt; endl;\n    cout &lt;&lt; \"(should be nothing here -&gt;) \";  o = TestB();\n    cout &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; \"Calling base class assignment operator:\" &lt;&lt; endl;\n    // o = 42;     // won't compile, because it's hidden.\n    cout &lt;&lt; \"(should be output here -&gt;) \";  o.TestA::operator=( 42 );   // OK.\n    cout &lt;&lt; endl;\n}\n</code></pre>\n<p>Considering all the answers so far that have confused hiding and inheritance, and just to clear up the terminology here, N3290 (which is identical to C++11 standard), says this:</p>\n<blockquote>\n<p id=\"so_7332279_7332866_0\"><strong>N3290 \u00a710/2:</strong><br>\n  \"Inherited members can be referred to in expressions in the same manner\n  as other members of the derived class, unless their names are hidden or ambiguous\"</br></p>\n</blockquote>\n<p>In the example code above <code>TestA::operator=</code> is hidden, but see the answer to Q3.</p>\n<h3>Q2: Is the following valid?</h3>\n<p>This question refers to use of <code>using</code> in the derived class, like</p>\n<pre><code>class TestB : public TestA\n{\n    public:\n        using TestA::operator=;\n        //Inheritance?\n};\n</code></pre>\n<p>Yes, that is valid.</p>\n<p>It would not be valid in C++98 for a constructor, because constructors are not inherited.</p>\n<h3>Q3: If it is valid, would it make a difference?</h3>\n<p>Yes, it makes the base class assignment operator(s) directly accessible in the derived class.</p>\n<p>For example, you can then remove the out-commenting in the example above,</p>\n<pre><code>// o = 42;     // won't compile, because it's hidden.\n</code></pre>\n<p>and it will still compile,</p>\n<pre><code>o = 42;        // compiles fine with \"using\".\n</code></pre>\n<p>Cheers &amp; hth.,</p>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2011-09-07T11:19:48.333", "Id": "7332866", "Score": "3", "CreationDate": "2011-09-07T11:11:41.597", "LastActivityDate": "2011-09-07T11:19:48.333"}, "7332350": {"ParentId": "7332279", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I have found some related answer from C++ 11 standard :</p>\n<p><strong>12.8 Copying and moving class objects</strong></p>\n<p>Because a copy/move assignment operator is implicitly declared for a class if not declared by the user, a base class copy/move assignment operator is always hidden by the corresponding assignment operator of a derived class (13.5.3). A using-declaration (7.3.3) that brings in from a base class an assignment operator with a parameter type that could be that of a copy/move assignment operator for the derived class is not considered an explicit declaration of such an operator and does not suppress the implicit declaration of the derived class operator; the operator introduced by the using-declaration is hidden by the implicitly-declared operator in the derived class.</p>\n", "OwnerUserId": "833538", "LastEditorUserId": "833538", "LastEditDate": "2011-09-07T11:03:03.483", "Id": "7332350", "Score": "2", "CreationDate": "2011-09-07T10:27:52.490", "LastActivityDate": "2011-09-07T11:03:03.483"}, "bq_ids": {"n4140": {"so_7332279_7332866_0": {"section_id": 6975, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_7332279_7332866_0": {"section_id": 6721, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_7332279_7332866_0": {"section_id": 8474, "quality": 0.8823529411764706, "length": 15}}}});