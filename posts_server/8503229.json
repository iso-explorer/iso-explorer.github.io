post_cb({"8503296": {"Id": "8503296", "PostTypeId": "2", "Body": "<p>It still happens. With floating point arithemitic it is sometimes necessary to ensure that the caluculations are dcarried out in the right order to ensure that this event is unlikely to happen. (also it can reduce rounding errors!)</p>\n", "LastActivityDate": "2011-12-14T10:55:00.143", "CommentCount": "1", "CreationDate": "2011-12-14T10:55:00.143", "ParentId": "8503229", "Score": "0", "OwnerUserId": "892256"}, "8503357": {"Id": "8503357", "PostTypeId": "2", "Body": "<p>Personally, I have never seen an architecture where <em>overflow</em> would cause memory outside the variable to be overwritten.</p>\n<p>I think you should read <em>overflow</em> as you leave a domain that is well defined (like the positive values of a signed integer) and enter one that is not well defined.</p>\n<p>Concretely, lets take the max short value, <code>0x7FFF</code>. If you add one to it you get <code>0x8000</code>. This value has different meaning depending on if you use one-complement or two-complement negative numbers, both of which are allowed by the C standard.</p>\n", "LastActivityDate": "2011-12-14T10:58:43.193", "CommentCount": "0", "CreationDate": "2011-12-14T10:58:43.193", "ParentId": "8503229", "Score": "2", "OwnerUserId": "623133"}, "8503355": {"Id": "8503355", "PostTypeId": "2", "Body": "<p>There are two main overflows in Computer buisness</p>\n<p>Arithmetic overflow: like in your example which is defined and needed for work</p>\n<p>Negativ example:</p>\n<pre><code>int a = std::numeric_limits&lt;int&gt;::max()/2;\nint b = a + a + 3; // b becomes negativ and the plane crashes\n</code></pre>\n<p>Positiv example:</p>\n<pre><code>double a = std::numeric_limits&lt;double&gt;::max()/2;\ndouble b = a + a + 3; // b becomes Inf and it is determined\n</code></pre>\n<p>Thats how the overflow is defined for Processor integer and floatingpoint units and it will not go awayand has to be handled.</p>\n<p>Memory Overflow: Still happens if things do not match like </p>\n<ul>\n<li>memory size</li>\n<li>calling conventions</li>\n<li>data type size of client server</li>\n<li>memory alignment</li>\n<li>...</li>\n</ul>\n<p>A lot of security issues are based on memory overflow.</p>\n<p>Read wikipedia for more facets of overflows:\n<a href=\"http://en.wikipedia.org/wiki/Overflow\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Overflow</a></p>\n", "LastEditorUserId": "101635", "LastActivityDate": "2011-12-14T11:25:25.603", "Score": "0", "CreationDate": "2011-12-14T10:58:39.473", "ParentId": "8503229", "CommentCount": "0", "OwnerUserId": "101635", "LastEditDate": "2011-12-14T11:25:25.603"}, "8503335": {"Id": "8503335", "PostTypeId": "2", "Body": "<p>The content of addresses almost never really \"overflowed\". For example we would expect primitive integers to roll over their values. See <a href=\"http://www.pbm.com/~lindahl/mel.html\" rel=\"nofollow\">http://www.pbm.com/~lindahl/mel.html</a>.</p>\n<p>I think overflow is when the pointers move beyond their desired limits so that you have pointers that point to unexpected places.</p>\n<blockquote>\n<p id=\"so_8503229_8503335_0\">He had located the data he was working on near the top of memory --\n  the largest locations the instructions could address -- so, after the\n  last datum was handled, incrementing the instruction address would\n  make it overflow. The carry would add one to the operation code,\n  changing it to the next one in the instruction set: a jump\n  instruction. Sure enough, the next program instruction was in address\n  location zero, and the program went happily on its way.</p>\n</blockquote>\n", "LastActivityDate": "2011-12-14T10:57:25.067", "CommentCount": "0", "CreationDate": "2011-12-14T10:57:25.067", "ParentId": "8503229", "Score": "2", "OwnerUserId": "314290"}, "8504241": {"Id": "8504241", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8503229_8504241_0\">I don't know whether it's UB</p>\n</blockquote>\n<p>It is undefined, as specified in C++11 5/4:</p>\n<blockquote>\n<p id=\"so_8503229_8504241_1\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p>\n</blockquote>\n<p>(As you say, it is defined for unsigned types, since they are defined by 3.9.1/4 to obey modular arithmetic)</p>\n<blockquote>\n<p id=\"so_8503229_8504241_2\">on a modern architecture, will I actually see arithmetic overflow of bits in memory?</p>\n</blockquote>\n<p>On all the modern architectures I know of (x86, ARM, 68000, and various DSPs), arithmetic is modular, with fixed-width 2s-complement results; on those architectures that can write the result to memory rather than registers, it will never overwrite more memory than the result size. For addition and subtraction, there is no difference to the CPU between signed and unsigned arithmetic. Overflow (signed or unsigned) can be detected from the state of CPU flags after the operation.</p>\n<p>I could imagine a compiler for, say, a 32-bit DSP that tried to implement arithmetic on 8 or 16-bit values packed into a larger word, where overflow would affect the rest of the word; however, all compilers I've seen for such architectures just defined <code>char</code>, <code>short</code> and <code>int</code> to be 32-bit types.</p>\n<blockquote>\n<p id=\"so_8503229_8504241_3\">Or is that really more of a historical thing?</p>\n</blockquote>\n<p>It would have happened on Babbage's Difference Engine, since \"memory\" is a single number; if you partition it into smaller numbers, and don't insert guard digits, then overflow from one will alter the value of the next. However, you couldn't run any non-trivial C++ program on this architecture.</p>\n<p>Historically, I believe some processors would produce an exception on overflow - that would be why the behaviour is undefined.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2011-12-14T12:19:09.933", "Score": "7", "CreationDate": "2011-12-14T12:11:56.723", "ParentId": "8503229", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2011-12-14T12:19:09.933"}, "bq_ids": {"n4140": {"so_8503229_8504241_1": {"length": 13, "quality": 1.0, "section_id": 5937}}, "n3337": {"so_8503229_8504241_1": {"length": 13, "quality": 1.0, "section_id": 5709}}, "n4659": {"so_8503229_8504241_1": {"length": 13, "quality": 1.0, "section_id": 7421}}}, "8503229": {"ViewCount": "247", "Body": "<p>I believe that during arithmetic overflow (in the context of an integer variable being assigned a value too large for it to hold), bits beyond the end of the variable could be overwritten.</p>\n<p>But in the following C++11 program does this really still hold? I don't know whether it's UB, or disallowed, or implementation-specific or what, but when I take the variable past its maximum value, on a <em>modern</em> architecture, will I <em>actually</em> see arithmetic overflow of bits in memory? Or is that really more of a historical thing?</p>\n<pre><code>int main() {\n   // (not unsigned; unsigned is defined to wrap-around)\n   int x = std::numeric_limits&lt;int&gt;::max();\n   x++;\n}\n</code></pre>\n", "AcceptedAnswerId": "8504241", "Title": "Is \"overflow\" a historical term, or does physical overflowing really still happen?", "CreationDate": "2011-12-14T10:50:53.690", "Id": "8503229", "CommentCount": "11", "LastEditDate": "2011-12-15T15:16:29.000", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2011-12-15T15:16:29.000", "Score": "-3", "OwnerUserId": "560648", "Tags": "<c++>", "AnswerCount": "5"}});