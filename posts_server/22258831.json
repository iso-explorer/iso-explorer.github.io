post_cb({"22352944": {"ParentId": "22258831", "CommentCount": "10", "Body": "<p>Clang and EDG are right.</p>\n<p>Here's how this works. The standard says (same source as your quote):</p>\n<blockquote>\n<p id=\"so_22258831_22352944_0\">In addition, for each non-explicit conversion function declared in <code>T</code> of the form</p>\n<pre><code>operator conversion-type-id () attribute-specifier-seq[opt] cv-qualifier ;\n</code></pre>\n<p id=\"so_22258831_22352944_1\">where [various conditions fulfilled in your example], a <em>surrogate call function</em> with the unique name <em>call-function</em> and having the form</p>\n<pre><code>R call-function ( conversion-type-id F, P1 a1, ... ,Pn an) { return F (a1, ... ,an); }\n</code></pre>\n<p id=\"so_22258831_22352944_2\">is also considered as a candidate function. [do the same for inherited conversions]^128</p>\n</blockquote>\n<p>And the footnote points out that this may yield multiple surrogates with undistinguishable signatures, and if those aren't displaced by clearly better candidates, the call is ambiguous.</p>\n<p>Following this scheme, your type has two conversion operators, yielding two surrogates:</p>\n<pre><code>// for operator F();\nvoid call-function-1(void (*F)()) { return F(); }\n// for operator F() const;\nvoid call-function-2(void (*F)()) { return F(); }\n</code></pre>\n<p>Your example does not contain any other candidates.</p>\n<p>The compiler then does overload resolution. Because the signatures of the two call functions are identical, it will use the same conversion sequence for both - in particular, it will use the non-const overload of the conversion function <em>in both cases</em>! So the two functions cannot be distinguished, and the call is ambiguous.</p>\n<p>The key to understanding this is that the conversion that is actually used in passing the object to the surrogate doesn't have to use the conversion function the surrogate was generated for!</p>\n<p>I can see two ways GCC and MSVC may arrive at the wrong answer here.</p>\n<p>Option 1 is that they see the two surrogates with identical signatures, and somehow meld them into one.</p>\n<p>Option 2, more likely, is that they thought, \"hey, we don't need to do the expensive searching for a conversion for the object here, we already know that it will use the conversion function that the surrogate was generated for\". It seems like a sounds optimization, except in this edge case, where this assumption is wrong. Anyway, by tying the conversion to the source conversion function, one of the surrogates uses identity-user-identity as the conversion sequence for the object, while the other uses const-user-identity, making it worse.</p>\n", "OwnerUserId": "8922", "PostTypeId": "2", "Id": "22352944", "Score": "6", "CreationDate": "2014-03-12T13:24:36.910", "LastActivityDate": "2014-03-12T13:24:36.910"}, "22258831": {"CommentCount": "4", "ViewCount": "646", "PostTypeId": "1", "LastEditorUserId": "809044", "CreationDate": "2014-03-07T19:18:19.070", "LastActivityDate": "2015-06-30T09:20:07.610", "Title": "Unexpected ambiguity of surrogate call functions in C++", "FavoriteCount": "2", "LastEditDate": "2015-06-30T09:20:07.610", "Id": "22258831", "Score": "21", "Body": "<p>On the following code clang and EDG diagnose an ambiguous function call, while gcc and Visual Studio accept the code.</p>\n<pre><code>struct s\n{\n    typedef void(*F)();\n    operator F();       //#1\n    operator F() const; //#2\n};\n\nvoid test(s&amp; p)\n{\n    p(); //ambiguous function call with clang/EDG; gcc/VS call #1\n}\n</code></pre>\n<p>According to the C++ standard draft (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf</a>) section 13.3.1.1.2 2 says;</p>\n<blockquote>\n<p id=\"so_22258831_22258831_0\">a surrogate call function with the unique name call-function and having the form R call-function ( conversion-type-id F, P1 a1, ... ,Pn an) { return F (a1,... ,an); } is also considered as a candidate function.</p>\n</blockquote>\n<p>In the code above that seems to mean that two call function definitions (one for each conversion function) are being considered, but both call functions have identical signatures (therefore the ambiguity) since the cv-qualifiers of the conversion operator do not seem to be taken into account in the call function signature.</p>\n<p>I would have expected #1 to be called as with gcc and Visual Studio. So if clang/EDG are instead right in rejecting the above code, could someone please shed some light on the reason as to <strong>why</strong> the standard stipulates that there should be an ambiguity in this case and <strong>which code benefits</strong> from that property of surrogate call functions? Who is right: clang(3.5)/EDG(310) or gcc (4.8.2)/VS(2013)?  </p>\n", "Tags": "<c++><gcc><clang><language-lawyer>", "OwnerUserId": "809044", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22258831_22352944_0": {"section_id": 579, "quality": 1.0, "length": 7}, "so_22258831_22258831_0": {"section_id": 579, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_22258831_22352944_0": {"section_id": 569, "quality": 1.0, "length": 7}, "so_22258831_22258831_0": {"section_id": 569, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_22258831_22352944_0": {"section_id": 602, "quality": 1.0, "length": 7}, "so_22258831_22258831_0": {"section_id": 602, "quality": 0.9285714285714286, "length": 13}}}});