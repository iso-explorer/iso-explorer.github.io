post_cb({"bq_ids": {"n4140": {"so_14910368_14910501_0": {"length": 41, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_14910368_14910501_0": {"length": 41, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_14910368_14910501_0": {"length": 41, "quality": 1.0, "section_id": 7604}}}, "14910501": {"Id": "14910501", "PostTypeId": "2", "Body": "<p>See <a href=\"http://code4thought.wordpress.com/tag/inheritance/\" rel=\"nofollow\">this post</a></p>\n<p>A quick summary:</p>\n<ul>\n<li>You are telling the machine to delete an instance of A</li>\n<li>As this is a class which we call through pointer/reference maybe we should use a virtual table (VT)?</li>\n<li>There is no virtual members in A thus no VT is used</li>\n<li>We call the standard destructor of A\u2026</li>\n<li>Bang! We are trying to delete class A but it happens that the pointer\nhas lead us to object of B which contains VT which A didn't know of.\nsizeof(A) is 1 (as AFAIK it\u2019s not legal to have size equal 0) and\nsizeof(B) is 4 (due to presence of VT). We wish to delete 1 byte, but\nthere is a block of 4 bytes. Due to DEBUG heap monitoring, the error\nwas caught.</li>\n</ul>\n<p>The solution of course is to declare the base class's (<code>A</code>'s) <code>dtor</code> as <code>virtual</code> so <code>B</code>'s <code>dtor</code> will always be called.</p>\n<p>EDIT: For the first case, here's what the standard has to say:</p>\n<blockquote>\n<p id=\"so_14910368_14910501_0\">\u00a75.3 In the first alternative (delete object), if the static type of the object to be deleted is different from its\n  dynamic type, <strong>the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined</strong>. In the second alternative (delete\n  array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>So both cases lead us to the realm of undefined behavior which of course differs from one implementation to the other. But it stands to reason that for most implementations the first case is easier to handle or at least easier to contemplate than the second which is just an esoteric anti-pattern.</p>\n", "LastEditorUserId": "372912", "LastActivityDate": "2013-02-16T14:59:56.837", "Score": "3", "CreationDate": "2013-02-16T12:52:52.410", "ParentId": "14910368", "CommentCount": "1", "OwnerUserId": "372912", "LastEditDate": "2013-02-16T14:59:56.837"}, "14923208": {"Id": "14923208", "PostTypeId": "2", "Body": "<p>As others have pointed out, you are deleting an object whose static type is different from its dynamic type, and since the static type doesn't have a virtual destructor, you get undefined behavior.  This includes the behavior of sometimes working and sometimes not working as you are seeing.  However, I think you are interested in a little deeper understanding of what is happening with your particular compiler.</p>\n<p>Class <code>A</code> has no members at all, so its data layout ends up looking like this:</p>\n<pre><code>struct A {\n};\n</code></pre>\n<p>Since class <code>B</code> derives from class <code>A</code>, class <code>A</code> becomes embedded within B.  When class <code>B</code> has no virtual functions, the layout ends up looking like this:</p>\n<pre><code>struct B {\n  A __a_part;\n  int x;\n};\n</code></pre>\n<p>The compiler can convert a <code>B*</code> to an <code>A*</code> by just taking the address of <code>__a_part</code>, as if the compiler had a function like this:</p>\n<p>A* convertToAPointer(B* bp) { return &amp;bp-&gt;__a_part; }</p>\n<p>Since <code>__a_part</code> is the first member of <code>B</code>, the <code>B*</code> and the <code>A*</code> point to the same address.</p>\n<p>Code like this:</p>\n<pre><code>A* bptr = new B;\ndelete bptr;\n</code></pre>\n<p>Is effectively doing something like this:</p>\n<pre><code>// Allocate a new B\nvoid* vp1 = allocateMemory(sizeof(B));\nB* bp = static_cast&lt;B*&gt;(vp1);\nbp-&gt;B(); // assume for a second that this was a legal way to construct\n\n// Convert the B* to an A*\nA* bptr = &amp;bp-&gt;__a_part;\n\n// Deallocate the A*\nvoid* vp2 = ap;\ndeallocateMemory(vp2);\n</code></pre>\n<p>In this case, <code>vp2</code> and <code>vp1</code> are the same.  The system is allocating and deallocating the same memory address, so the program runs without an error.</p>\n<p>When class <code>B</code> has a virtual member function (the destructor in this case).  The compiler adds a virtual table pointer, so class B ends up looking like this:</p>\n<pre><code>struct B {\n  B_vtable* __vptr;\n  A __a_part;\n};\n</code></pre>\n<p>The issue here is that <code>__a_part</code> is no longer the first member, and the <code>convertToAPointer</code> operation will now change the address of the pointer, so <code>vp2</code> and <code>vp1</code> no longer point to the same address.  Since a different memory location is being deallocated than the one that was allocated, you get the error.</p>\n", "LastActivityDate": "2013-02-17T16:21:22.510", "CommentCount": "2", "CreationDate": "2013-02-17T16:21:22.510", "ParentId": "14910368", "Score": "1", "OwnerUserId": "951890"}, "14910368": {"ViewCount": "230", "Body": "<p>I'm wondering why I get an exception on the <code>delete</code> part in one case here, but not in the other.</p>\n<h2>No exception case</h2>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\npublic:\n    ~A() { cout &lt;&lt; \"A dtor\" &lt;&lt; endl; }\n};\n\nclass B : public A\n{\npublic:\n    int x;\n    ~B() { cout &lt;&lt; \"B dtor\" &lt;&lt; endl; }\n};\n\n\nA* f() { return new B; }\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    cout &lt;&lt; sizeof(B) &lt;&lt; \" \" &lt;&lt; sizeof(A) &lt;&lt; endl;\n    A* bptr= f();\n    delete bptr;\n}\n</code></pre>\n<p>Herethe output is <code>4 1 .. A dtor</code>, since A has 1 byte for identity and B has 4 because of <code>int x</code>.</p>\n<h2>Exception case</h2>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\npublic:\n    ~A() { cout &lt;&lt; \"A dtor\" &lt;&lt; endl; }\n};\n\nclass B : public A\n{\npublic:\n    virtual ~B() { cout &lt;&lt; \"B dtor\" &lt;&lt; endl; }\n};\n\n\nA* f() { return new B; }\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    cout &lt;&lt; sizeof(B) &lt;&lt; \" \" &lt;&lt; sizeof(A) &lt;&lt; endl;\n    A* bptr= f();\n    delete bptr;\n}\n</code></pre>\n<p>Here the output is <code>4 1 .. A dtor</code>, since A has 1 byte for identity and B has 4 because of the <code>vptr</code> that's needed for its virtual destructor.\n<strong>But then a debug assertion fails inside the <code>delete</code> call (<code>_BLOCK_TYPE_IS_VALID</code>)</strong>.</p>\n<h2>Environment</h2>\n<p>I'm running Windows 7 with Visual Studio 2010 SP1Rel.</p>\n", "AcceptedAnswerId": "14923208", "Title": "C++ Debug Assertion Fails Only With VPTR", "CreationDate": "2013-02-16T12:37:38.387", "Id": "14910368", "CommentCount": "12", "PostTypeId": "1", "LastActivityDate": "2013-02-17T16:21:22.510", "Score": "4", "OwnerUserId": "602372", "Tags": "<c++><exception><memory-management>", "AnswerCount": "2"}});