post_cb({"55539": {"Id": "55539", "PostTypeId": "2", "Body": "<p>I would be worried about padding being added for things like Matrix[5][5] to make each row word aligned, but that could be simply my own superstition.</p>\n", "OwnerDisplayName": "Josh Matthews", "LastActivityDate": "2008-09-11T00:12:30.003", "Score": "0", "CreationDate": "2008-09-11T00:12:30.003", "ParentId": "55532", "CommentCount": "0", "OwnerUserId": "3830"}, "57934": {"Id": "57934", "PostTypeId": "2", "Body": "<p>@Konrad Rudolph:</p>\n<p>I get those two (row major/column major) mixed up myself, but I do know this: It's well-defined.</p>\n<p>int x[3][5], for example, is an array of size 3, whose elements are int arrays of size 5. (\u00a76.5.2.1) Adding all the rules from the standard about arrays, addressing, etc. you get that the second subscript references consecutive integers, wheras the first subscript will reference consecutive 5-int objects. (So 3 is the bigger number; you have 5 ints between <strong>x[1]</strong>[0] and <strong>x[2]</strong>[0].)</p>\n", "OwnerDisplayName": "aib", "LastActivityDate": "2008-09-11T23:43:24.430", "Score": "1", "CreationDate": "2008-09-11T23:43:24.430", "ParentId": "55532", "CommentCount": "0", "OwnerUserId": "1088"}, "55660": {"Body": "<p>From the C++ standard, referring to the <code>sizeof</code> operator:</p>\n<blockquote>\n<p id=\"so_55532_55660_0\">When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of <code>n</code> elements is <code>n</code> times the size of an element.</p>\n</blockquote>\n<p>From this, I'd say that <code>double[4][4]</code> and <code>double[16]</code> would have to have the same underlying representation.  </p>\n<p>I.e., given </p>\n<pre><code>sizeof(double[4]) = 4*sizeof(double)\n</code></pre>\n<p>and</p>\n<pre><code>sizeof(double[4][4]) = 4*sizeof(double[4])\n</code></pre>\n<p>then we have</p>\n<pre><code>sizeof(double[4][4]) = 4*4*sizeof(double) = 16*sizeof(double) = sizeof(double[16])\n</code></pre>\n<p>I think a standards-compliant compiler would have to implement these the same, and I think that this isn't something that a compiler would accidentally break.  The standard way of implementing multi-dimensional arrays works as expected.  Breaking the standard would require extra work, for likely no benefit.</p>\n<p>The C++ standard also states that an array consists of contiguously-allocated elements, which eliminates the possibility of doing anything strange using pointers and padding.</p>\n", "CreationDate": "2008-09-11T01:42:11.113", "ParentId": "55532", "CommentCount": "0", "LastEditDate": "2008-09-11T02:03:45.663", "PostTypeId": "2", "LastEditorDisplayName": "Derek Park", "LastActivityDate": "2008-09-11T02:03:45.663", "LastEditorUserId": "872", "Id": "55660", "OwnerDisplayName": "Derek Park", "Score": "3", "OwnerUserId": "872"}, "bq_ids": {"n4140": {"so_55532_55660_0": {"length": 15, "quality": 0.9375, "section_id": 6077}}, "n3337": {"so_55532_55660_0": {"length": 15, "quality": 0.9375, "section_id": 5845}}, "n4659": {"so_55532_55660_0": {"length": 15, "quality": 0.9375, "section_id": 7573}}}, "55580": {"Id": "55580", "PostTypeId": "2", "Body": "<p>Each array element should be laid out sequentially in memory by the compiler. The two declarations whilst different types are the same underlying memory structure.</p>\n", "OwnerDisplayName": "Henk", "LastActivityDate": "2008-09-11T00:53:53.180", "Score": "1", "CreationDate": "2008-09-11T00:53:53.180", "ParentId": "55532", "CommentCount": "0", "OwnerUserId": "4613"}, "55579": {"Id": "55579", "PostTypeId": "2", "Body": "<p>I don't think there is a problem with padding introduced by having a <strong>multi-dimensional</strong> array.</p>\n<p>Each element in an array must satisfy the padding requirements imposed by the architecture.   An array [N][M] is always going to have the same in memory representation as one of [M*N].</p>\n", "OwnerDisplayName": "Rob Walker", "LastActivityDate": "2008-09-11T00:53:49.513", "Score": "2", "CreationDate": "2008-09-11T00:53:49.513", "ParentId": "55532", "CommentCount": "0", "OwnerUserId": "3631"}, "55532": {"ViewCount": "534", "Body": "<p>This came up from <a href=\"https://stackoverflow.com/questions/55093/how-to-deal-with-arrays-declared-on-the-stack-in-c#55183\">this answer to a previous question of mine</a>.\nIs it guaranteed for the compiler to treat <code>array[4][4]</code> the same as <code>array[16]</code>?</p>\n<p>For instance, would either of the below calls to <code>api_func()</code> be safe?</p>\n<pre><code>void api_func(const double matrix[4][4]);\n\n// ...\n\n{\n  typedef double Matrix[4][4];\n\n  double* array1 = new double[16];\n  double array2[16];\n\n  // ...\n\n  api_func(reinterpret_cast&lt;Matrix&amp;&gt;(array1));\n  api_func(reinterpret_cast&lt;Matrix&amp;&gt;(array2));\n}\n</code></pre>\n", "AcceptedAnswerId": "55660", "Title": "Casting between multi- and single-dimentional arrays", "CreationDate": "2008-09-11T00:06:58.097", "Id": "55532", "CommentCount": "0", "LastEditDate": "2017-05-23T11:44:16.657", "PostTypeId": "1", "OwnerDisplayName": "Owen", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-22T12:18:28.940", "Score": "3", "OwnerUserId": "4790", "Tags": "<c++><arrays>", "AnswerCount": "6"}, "55937": {"Id": "55937", "PostTypeId": "2", "Body": "<p>A bigger question is: do you really need to perform such a cast?</p>\n<p>Although you <em>might</em> be able to get away with it, it would still be more readable and maintainable to avoid altogether.  For example, you could consistently use double[m*n] as the actual type, and then work with a class that wraps this type, and perhaps overloads the [] operator for ease of use.  In that case, you might also need an intermediate class to encapsulate a single row -- so that code like my_matrix[3][5] still works as expected.</p>\n", "OwnerDisplayName": "Tyler", "LastActivityDate": "2008-09-11T07:24:35.517", "Score": "0", "CreationDate": "2008-09-11T07:24:35.517", "ParentId": "55532", "CommentCount": "0", "OwnerUserId": "3561"}});