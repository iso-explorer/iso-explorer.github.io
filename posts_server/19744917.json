post_cb({"19744929": {"ParentId": "19744917", "CommentCount": "5", "Body": "<p>Move the static definition out of the class declaration:</p>\n<pre><code>class Spreadsheet \n{\n   ...\n   static int sCounter;\n};\n\nint Spreadsheet::sCounter = 0;\n</code></pre>\n", "OwnerUserId": "952747", "PostTypeId": "2", "Id": "19744929", "Score": "1", "CreationDate": "2013-11-02T17:52:35.050", "LastActivityDate": "2013-11-02T17:52:35.050"}, "19744977": {"ParentId": "19744917", "LastEditDate": "2013-11-02T18:37:52.930", "CommentCount": "5", "CreationDate": "2013-11-02T17:57:44.033", "OwnerUserId": "947836", "LastEditorUserId": "947836", "PostTypeId": "2", "Id": "19744977", "Score": "3", "Body": "<p>Read the error message again:</p>\n<blockquote>\n<p id=\"so_19744917_19744977_0\">ISO C++ forbids in-class initialization of <strong>non-const</strong> static member \u2018Spreadsheet::sCounter\u2019\n           static int sCounter = 0;</p>\n</blockquote>\n<p>If you want to initialize a <code>static</code> member in class definition, it needs to be <code>const</code>, that's all there is to it.</p>\n<p>Normal class members are initialized when an object of that class is constructed. You can think of in-class initializers as a syntactic sugar for member initializer lists (or think of them as similar to default function arguments). You can still override it and initialize them with a different expression the old way (in a constructor).</p>\n<p>Static members are different. They don't belong to any class instance and as such need to have memory allocated for them and be initialized separately. As they have static storage duration, that's somewhere at the programs startup.</p>\n<p>Constant static members are an exception. As they can't be written to, the standard allows \nyou to initialize them in class declaration and they're basically treated as a value, not an object. That is, until you do something with them that requires them to be stored somewhere, for example take their address. This hasn't changed in C++11.</p>\n<p>Standardese quotes, from n3337 draft, chapter 9.4.2 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_19744917_19744977_1\">2 The declaration of a static data member in its class de\ufb01nition is not a de\ufb01nition and may be of an incomplete\n  type other than cv-quali\ufb01ed void. <strong>The de\ufb01nition for a static data member shall appear in a namespace\n  cope enclosing the member\u2019s class de\ufb01nition.</strong> In the de\ufb01nition at namespace scope, the name of the static\n  data member shall be quali\ufb01ed by its class name using the :: operator. The initializer expression in the\n  de\ufb01nition of a static data member is in the scope of its class (3.3.7). [...]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_19744917_19744977_2\">3 <strong>If a non-volatile const static data member is of integral or enumeration type, its declaration in the class\n  de\ufb01nition can specify a brace-or-equal-initializer</strong> in which every initializer-clause that is an assignment\n  expression is a constant expression (5.19). A static data member of literal type can be declared in the\n  class de\ufb01nition with the constexpr speci\ufb01er; if so, its declaration shall specify a brace-or-equal-initializer\n  in which every initializer-clause that is an assignment-expression is a constant expression. [Note: In both\n  these cases, the member may appear in constant expressions. \u2014end note ] <strong>The member shall still be de\ufb01ned\n  in a namespace scope if it is odr-used (3.2)</strong> in the program and the namespace scope de\ufb01nition shall not\n  contain an initializer.</p>\n</blockquote>\n", "LastActivityDate": "2013-11-02T18:37:52.930"}, "19745822": {"ParentId": "19744917", "LastEditDate": "2013-11-02T19:37:29.617", "CommentCount": "1", "CreationDate": "2013-11-02T19:17:35.493", "OwnerUserId": "187690", "LastEditorUserId": "187690", "PostTypeId": "2", "Id": "19745822", "Score": "1", "Body": "<ul>\n<li><p>C++98 allows in-class initializers for static <code>const</code> members of integral or enum types.</p></li>\n<li><p>C++11 additionally allows in-class initializers for non-static members.</p></li>\n</ul>\n<p>Your code does not fall into either category. It was never supposed to compile in C++98 and it is not supposed to compile in C++11. In C++ you are not allowed to provide in-class initializers for non-const static members.</p>\n<p>Note also that the original C++98 feature has not been extended to non-integral non-enum types</p>\n<pre><code>struct S {\n  static const double d = 5; // still an error even in C++11\n};\n</code></pre>\n<p>BTW, the semantics of and the rationale behind in-class initializers for static const and non-static class data members is completely different. Despite being similar syntactically, these are actually two different features, not an extension of the former onto the latter.</p>\n<ul>\n<li><p>In-class initializers for static const data members exist to facilitate \"early\" Integral Constant Expressions, i.e. they turn a static constant onto an ICE at the point of class definition (as opposed to the later point of static member definition). </p></li>\n<li><p>In-class initializers for non-static data member facilitate implicit initialization of class members in constructors. In other words, what in C++11 looks like in-class initializers for non-static data members do not really initialize anything yet. (There's nothing to initialize at that point.) All these in-class initializers do is supply the compiler with information that is used later for generating class constructors. These constructors will do they job even later, when you actually begin defining objects of that class type.</p></li>\n</ul>\n", "LastActivityDate": "2013-11-02T19:37:29.617"}, "bq_ids": {"n4140": {"so_19744917_19744977_1": {"section_id": 5907, "quality": 0.75, "length": 39}, "so_19744917_19744977_2": {"section_id": 5908, "quality": 0.8125, "length": 52}}, "n3337": {"so_19744917_19744977_1": {"section_id": 5679, "quality": 0.75, "length": 39}, "so_19744917_19744977_2": {"section_id": 5680, "quality": 0.8125, "length": 52}}, "n4659": {"so_19744917_19744977_1": {"section_id": 7389, "quality": 0.7307692307692307, "length": 38}}}, "19744917": {"CommentCount": "2", "ViewCount": "4642", "PostTypeId": "1", "LastEditorUserId": "1798341", "CreationDate": "2013-11-02T17:51:22.263", "LastActivityDate": "2013-11-02T19:37:29.617", "Title": "Static member initialization not working with GCC even with C++11 enabled", "AcceptedAnswerId": "19744977", "LastEditDate": "2013-11-02T18:06:53.650", "Id": "19744917", "Score": "0", "Body": "<p>I am using GCC 4.8.2:</p>\n<pre><code>$ g++ --version                          \ng++ (GCC) 4.8.2\nCopyright (C) 2013 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n<p>And I have this class definition:</p>\n<pre><code>#pragma once\n\n#include \"SpreadsheetCell.h\"\n\nclass Spreadsheet \n{\n    public:\n        Spreadsheet(int inWidth, int inHeight);\n        Spreadsheet(const Spreadsheet&amp; src);\n        ~Spreadsheet();\n\n        int getId() const;\n        int getWidth() const;\n        int getHeight() const;\n        void setCellAt(int x, int y, const SpreadsheetCell&amp; cell);\n        SpreadsheetCell getCellAt(int x, int y) const;\n\n        Spreadsheet&amp; operator=(const Spreadsheet&amp; rhs);\n    private:\n        bool inRange(int val, int upper) const;\n        void copyFrom(const Spreadsheet&amp; src);\n        void freeMemory();\n\n        int mWidth, mHeight, mId;\n        SpreadsheetCell** mCells;\n\n        static int sCounter = 0;\n};\n</code></pre>\n<p>When I try to compile it, I get:</p>\n<pre><code>$ make SpreadsheetTest &amp;&amp; SpreadsheetTest\ng++ -Wall -g -std=c++11 -c Spreadsheet.cpp\nIn file included from Spreadsheet.cpp:3:0:\nSpreadsheet.h:27:31: error: ISO C++ forbids in-class initialization of non-const static member \u2018Spreadsheet::sCounter\u2019\n         static int sCounter = 0;\n                               ^\nMakefile:11: recipe for target 'Spreadsheet.o' failed\nmake: *** [Spreadsheet.o] Error 1\n</code></pre>\n<p><strong>The strange thing is that if I remove the <code>static</code> modifier from <code>sCounter</code> declaration, it compiles normally.</strong></p>\n<p>What is going on?</p>\n<h2>Edit:</h2>\n<p>It seems like this feature is available since GCC 4.7:\n<a href=\"http://gcc.gnu.org/projects/cxx0x.html\" rel=\"nofollow\">http://gcc.gnu.org/projects/cxx0x.html</a></p>\n<h2>Edit 2:</h2>\n<p>I'm trying to find the official reference, but I took this piece of code from the book \"Professional C++\" - 2nd edition, from Gregoire, Solter &amp; Kleper (Chapter 7, page 181, subsection \"static Data Members\") and it is supposed to work.</p>\n<blockquote>\n<p id=\"so_19744917_19744917_0\">With C++11, that's all you need to do. If you are using C++ pior to C++11, it is a little bit clumsier [...]</p>\n</blockquote>\n<p>And then it suggests me to do the traditional way.</p>\n<p>Are the authors wrong?</p>\n", "Tags": "<c++><gcc><c++11>", "OwnerUserId": "1798341", "AnswerCount": "3"}});