post_cb({"2474018": {"ViewCount": "12093", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct foo\n{\n    // (a):\n    void bar() { std::cout &lt;&lt; \"gman was here\" &lt;&lt; std::endl; }\n\n    // (b):\n    void baz() { x = 5; }\n\n    int x;\n};\n\nint main()\n{\n    foo* f = 0;\n\n    f-&gt;bar(); // (a)\n    f-&gt;baz(); // (b)\n}\n</code></pre>\n<p>We expect <code>(b)</code> to crash, because there is no corresponding member <code>x</code> for the null pointer. In practice, <code>(a)</code> doesn't crash because the <code>this</code> pointer is never used.</p>\n<p>Because <code>(b)</code> dereferences the <code>this</code> pointer (<code>(*this).x = 5;</code>), and <code>this</code> is null, the program enters undefined behavior, as dereferencing null is always said to be undefined behavior.</p>\n<p>Does <code>(a)</code> result in undefined behavior? What about if both functions (and <code>x</code>) are static?</p>\n", "AcceptedAnswerId": "2474021", "Title": "When does invoking a member function on a null instance result in undefined behavior?", "CreationDate": "2010-03-18T23:20:44.907", "Id": "2474018", "CommentCount": "6", "FavoriteCount": "43", "PostTypeId": "1", "LastEditDate": "2015-09-30T18:44:57.410", "LastEditorUserId": "4859814", "LastActivityDate": "2015-09-30T18:44:57.410", "Score": "99", "OwnerUserId": "87234", "Tags": "<c++><undefined-behavior><language-lawyer><standards-compliance><null-pointer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_2474018_2474021_0": {"length": 4, "quality": 1.0, "section_id": 5988}, "so_2474018_2474021_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 7192}, "so_2474018_2474021_2": {"length": 9, "quality": 0.9, "section_id": 6005}, "so_2474018_2474021_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 5900}, "so_2474018_2474021_3": {"length": 11, "quality": 1.0, "section_id": 5890}}, "n3337": {"so_2474018_2474021_3": {"length": 11, "quality": 1.0, "section_id": 5661}, "so_2474018_2474021_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5}, "so_2474018_2474021_2": {"length": 9, "quality": 0.9, "section_id": 5773}, "so_2474018_2474021_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 5672}, "so_2474018_2474021_0": {"length": 4, "quality": 1.0, "section_id": 5756}}, "n4659": {"so_2474018_2474021_3": {"length": 11, "quality": 1.0, "section_id": 7373}, "so_2474018_2474021_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 8701}, "so_2474018_2474021_2": {"length": 9, "quality": 0.9, "section_id": 7504}, "so_2474018_2474021_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 7382}, "so_2474018_2474021_0": {"length": 4, "quality": 1.0, "section_id": 7488}}}, "3826144": {"Id": "3826144", "PostTypeId": "2", "Body": "<p>Obviously undefined means it's <strong>not defined</strong>, but sometimes it can be predictable. The information I'm about to provide should never be relied on for working code since it certainly isn't guaranteed, but it might come in useful when debugging.</p>\n<p>You might think that calling a function on an object pointer will dereference the pointer and cause UB. In practice if the function isn't virtual, the compiler will have converted it to a plain function call passing the pointer as the first parameter <em>this</em>, bypassing the dereference and creating a time bomb for the called member function. If the member function doesn't reference any member variables or virtual functions, it might actually succeed without error. Remember that succeeding falls within the universe of \"undefined\"!</p>\n<p>Microsoft's MFC function <a href=\"http://msdn.microsoft.com/en-us/library/d64ehwhz(v=vs.80).aspx\" rel=\"noreferrer\">GetSafeHwnd</a> actually relies on this behavior. I don't know what they were smoking.</p>\n<p>If you're calling a virtual function, the pointer must be dereferenced to get to the vtable, and for sure you're going to get UB (probably a crash but remember that there are no guarantees).</p>\n", "LastActivityDate": "2010-09-29T21:51:49.873", "CommentCount": "4", "CreationDate": "2010-09-29T21:51:49.873", "ParentId": "2474018", "Score": "24", "OwnerUserId": "5987"}, "2474021": {"Id": "2474021", "PostTypeId": "2", "Body": "<p>Both <code>(a)</code> and <code>(b)</code> result in undefined behavior. It's always undefined behavior to call a member function through a null pointer. If the function is static, it's technically undefined as well, but there's some dispute.</p>\n<hr>\n<p>The first thing to understand is why it's undefined behavior to dereference a null pointer. In C++03, there's actually a bit of ambiguity here.</p>\n<p>Although <em>\"dereferencing a null pointer results in undefined behavior\"</em> is mentioned in notes in both \u00a71.9/4 and \u00a78.3.2/4, it's never explicitly stated. (Notes are non-normative.)</p>\n<p>However, one can try to deduced it from \u00a73.10/2: </p>\n<blockquote>\n<p id=\"so_2474018_2474021_0\">An lvalue refers to an object or function.</p>\n</blockquote>\n<p>When dereferencing, the result is an lvalue. A null pointer <em>does not</em> refer to an object, therefore when we use the lvalue we have undefined behavior. The problem is that the previous sentence is never stated, so what does it mean to \"use\" the lvalue? Just even generate it at all, or to use it in the more formal sense of perform lvalue-to-rvalue conversion?</p>\n<p>Regardless, it definitely cannot be converted to an rvalue (\u00a74.1/1):</p>\n<blockquote>\n<p id=\"so_2474018_2474021_1\">If the object to which the lvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior.</p>\n</blockquote>\n<p>Here it's definitely undefined behavior.</p>\n<p>The ambiguity comes from whether or not it's undefined behavior to deference <em>but not use</em> the value from an invalid pointer (that is, get an lvalue but not convert it to an rvalue). If not, then <code>int *i = 0; *i; &amp;(*i);</code> is well-defined. This is an <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"noreferrer\">active issue</a>.</p>\n<p>So we have a strict \"dereference a null pointer, get undefined behavior\" view and a weak \"use a dereferenced null pointer, get undefined behavior\" view. </p>\n<p>Now we consider the question.</p>\n<hr>\n<p>Yes, <code>(a)</code> results in undefined behavior. In fact, if <code>this</code> is null then <em>regardless of the contents of the function</em> the result is undefined.</p>\n<p>This follows from \u00a75.2.5/3:</p>\n<blockquote>\n<p id=\"so_2474018_2474021_2\">If <code>E1</code> has the type \u201cpointer to class X,\u201d then the expression <code>E1-&gt;E2</code> is converted to the equivalent form <code>(*(E1)).E2;</code></p>\n</blockquote>\n<p><code>*(E1)</code> will result in undefined behavior with a strict interpretation, and <code>.E2</code> converts it to an rvalue, making it undefined behavior for the weak interpretation.</p>\n<p>It also follows that it's undefined behavior directly from (\u00a79.3.1/1):</p>\n<blockquote>\n<p id=\"so_2474018_2474021_3\">If a nonstatic member function of a class X is called for an object that is not of type X, or of a type derived from X, the behavior is undefined.</p>\n</blockquote>\n<hr>\n<p>With static functions, the strict versus weak interpretation makes the difference. Strictly speaking, it is undefined:</p>\n<blockquote>\n<p id=\"so_2474018_2474021_4\">A static member may be referred to using the class member access syntax, in which case the object-expression is evaluated.</p>\n</blockquote>\n<p>That is, it's evaluated just as if it were non-static and we once again dereference a null pointer with <code>(*(E1)).E2</code>.</p>\n<p>However, because <code>E1</code> is not used in a static member-function call, if we use the weak interpretation the call is well-defined. <code>*(E1)</code> results in an lvalue, the static function is resolved, <code>*(E1)</code> is discarded, and the function is called. There is no lvalue-to-rvalue conversion, so there's no undefined behavior.</p>\n<p>In C++0x, as of n3126, the ambiguity remains. For now, be safe: use the strict interpretation.</p>\n</hr></hr></hr>", "LastEditorUserId": "87234", "LastActivityDate": "2012-10-18T21:57:37.727", "Score": "95", "CreationDate": "2010-03-18T23:21:13.253", "ParentId": "2474018", "CommentCount": "10", "OwnerUserId": "87234", "LastEditDate": "2012-10-18T21:57:37.727"}});