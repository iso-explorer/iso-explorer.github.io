post_cb({"17995160": {"ParentId": "17994955", "PostTypeId": "2", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_17994955_17995160_0\">Why are even (2) and (4) being treated as declarations?</p>\n</blockquote>\n<p>Parentheses in declarations can be used to change the association order in declarators and possibly change the meaning of the construct from declaration to expression. They have the same precedence as <code>[]</code> and group left to right.</p>\n<p>For example:</p>\n<pre><code>int*a[1];   // brackets have higher precedence - this is an array of pointers\nint(*a)[1]; // pointer to an array\n</code></pre>\n<p>Now if you consider <code>A*p;</code> and <code>A(*p);</code> the parentheses here are redundant because they didn't change the way this is parsed. Adding more of them doesn't change a thing - it is still a valid declaration.</p>\n<blockquote>\n<p id=\"so_17994955_17995160_1\">What is the descriptions of foo in statements (3) and (4)?</p>\n</blockquote>\n<p>The declarations are the same as <code>A* foo();</code></p>\n", "OwnerUserId": "947836", "LastEditorUserId": "947836", "LastEditDate": "2013-08-01T14:19:17.070", "Id": "17995160", "Score": "1", "CreationDate": "2013-08-01T13:16:36.180", "LastActivityDate": "2013-08-01T14:19:17.070"}, "17994955": {"CommentCount": "11", "AcceptedAnswerId": "18000366", "CreationDate": "2013-08-01T13:08:23.893", "LastActivityDate": "2013-08-01T17:09:28.120", "PostTypeId": "1", "ViewCount": "254", "FavoriteCount": "1", "Title": "Most vexing parse and pointer indirection/dereferencing", "Id": "17994955", "Score": "4", "Body": "<p>Minimal code:</p>\n<pre><code>struct A {\n  A(int = 0) {}\n};\n\nint i = 0, *p = &amp;i;\nint* foo () { return p; }\n\nint main () {\n  A(); // calls `A::A(int=0)`\n  A(i);  // calls `A::A(int=0)`\n\n  A(*p); // &lt;--- (1) same as local `A *p;`\n  {\n    A((*p));   // &lt;--- (2) same as local `A *p;`\n  }\n  A (*foo());  // &lt;--- (3) ??\n  {\n    A ((*foo()));  // &lt;--- (4) ??\n  }\n}\n</code></pre>\n<p>Was expecting at least <code>A((*p))</code> would invoke <code>A::A(int=0)</code>. Even putting multiple braces around <code>*p</code>, treats the statement as <code>A *p;</code>.<br>\nThe same holds true for <code>foo</code> related statement, where the constructor <code>A::A(int=0)</code> is not called.\nHere is a <a href=\"http://ideone.com/nY7nhi\" rel=\"nofollow\">demo</a>.</br></p>\n<p><strong>Question</strong>:  </p>\n<ol>\n<li>Why are even (2) and (4) being treated as declarations?</li>\n<li>What is the descriptions of <code>foo</code> in statements (3) and (4)?</li>\n</ol>\n", "Tags": "<c++><pointers><language-lawyer><dereference><most-vexing-parse>", "OwnerUserId": "514235", "AnswerCount": "2"}, "18000366": {"ParentId": "17994955", "CommentCount": "0", "Body": "<p>When parsing a construct that could either be a declaration or an expression - known as the Most Vexing Parse ambiguity - the standard says \"the resolution is to consider any construct that could possibly be a declaration a declaration\".</p>\n<p>Both (2) and (4) are valid declarations, therefore they must be parsed as declarations. Both (3) and (4) declare a function <code>foo</code> of type <code>A*()</code> aka \"function taking no parameter returning pointer to <code>A</code>\"</p>\n<p><code>6.8 Ambiguity resolution [stmt.ambig]</code></p>\n<blockquote>\n<p id=\"so_17994955_18000366_0\">There is an ambiguity in the grammar involving expression-statements and declarations: An expression-statement with a function-style explicit type conversion (5.2.3) as its leftmost subexpression can be indistinguishable from a declaration where the first declarator starts with a (. <strong>In those cases the statement is a declaration.</strong> [Note: To disambiguate, the whole statement might have to be examined to determine if it is an expression-statement or a declaration. This disambiguates many examples. [Example: assuming T is a simple-type-specifier (7.1.5),</p>\n</blockquote>\n<pre><code>T(a)-&gt;m = 7; // expression-statement\nT(a)++; //expression-statement\nT(a,5)&lt;&lt;c; //expression-statement\nT(*d)(int); //declaration\nT(e)[5]; //declaration\nT(f) = { 1, 2 }; // declaration\nT(*g)(double(3)); // declaration\n</code></pre>\n<blockquote>\n<p id=\"so_17994955_18000366_1\">In the last example above, g, which is a pointer to T, is initialized to double(3). This is of course illformed for semantic reasons, but that does not affect the syntactic analysis. \u2014end example]</p>\n</blockquote>\n<p><code>8.2 Ambiguity resolution [dcl.ambig.res]</code></p>\n<blockquote>\n<p id=\"so_17994955_18000366_2\">The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 6.8 can also occur in the context of a declaration. In that context, the choice is between a function declaration with a redundant set of parentheses around a parameter name and an object declaration with a function-style cast as the initializer. Just as for the ambiguities mentioned in 6.8, <strong>the resolution is to consider any construct that could possibly be a declaration a declaration</strong>. [Note: a declaration can be explicitly disambiguated by a nonfunction-style cast, by a = to indicate initialization or by removing the redundant parentheses around the parameter name. ] [Example:</p>\n</blockquote>\n<pre><code>struct S {\n    S(int);\n};\n\nvoid foo(double a)\n{\n    S w(int(a)); // function declaration\n    S x(int()); // function declaration\n    S y((int)a); // object declaration\n    S z = int(a); // object declaration\n}\n</code></pre>\n<blockquote>\n<p id=\"so_17994955_18000366_3\">\u2014end example]</p>\n</blockquote>\n", "OwnerUserId": "1690864", "PostTypeId": "2", "Id": "18000366", "Score": "1", "CreationDate": "2013-08-01T17:09:28.120", "LastActivityDate": "2013-08-01T17:09:28.120"}, "bq_ids": {"n4140": {"so_17994955_18000366_2": {"section_id": 3201, "quality": 0.9454545454545454, "length": 52}, "so_17994955_18000366_1": {"section_id": 3922, "quality": 0.8333333333333334, "length": 15}, "so_17994955_18000366_0": {"section_id": 3921, "quality": 0.5681818181818182, "length": 25}}, "n3337": {"so_17994955_18000366_2": {"section_id": 3075, "quality": 0.9454545454545454, "length": 52}, "so_17994955_18000366_1": {"section_id": 3781, "quality": 0.8333333333333334, "length": 15}, "so_17994955_18000366_0": {"section_id": 3781, "quality": 0.7272727272727273, "length": 32}}, "n4659": {"so_17994955_18000366_2": {"section_id": 3962, "quality": 0.8, "length": 44}, "so_17994955_18000366_0": {"section_id": 4807, "quality": 0.5681818181818182, "length": 25}, "so_17994955_18000366_1": {"section_id": 4808, "quality": 0.8333333333333334, "length": 15}}}});