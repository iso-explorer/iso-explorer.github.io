post_cb({"35247597": {"ParentId": "34213087", "CommentCount": "0", "Body": "<p>As already mentioned by other users, calls to <code>shared_from_this</code> on instances that are not owned by <code>shared_ptr</code>s will result in an undefined behavior (usually an exception, but there are no guarantees).</p>\n<p>So, why one more answer?</p>\n<p>Because I did myself the same question once and got almost the same answer, then I started struggling with another question that immediately arose after that - <em>how can I guarantee thus that all the instances are managed by a <code>shared_ptr</code></em>?</p>\n<p>For the sake of completeness, I add another answer with a few details about this aspect.<br>\nHere a simple solution that had not been mentioned before.</br></p>\n<p>So simple a solution, indeed: <em>private constructors</em>, <em>factory method</em> and <em>variadic template</em>s.<br>\nIt follows a snippet that mixes all of them together in a minimal example:</br></p>\n<pre><code>#include&lt;memory&gt;\n#include&lt;utility&gt;\n\nclass C: public std::enable_shared_from_this&lt;C&gt; {\n    C() = default;\n    C(const C &amp;) = default;\n    C(C &amp;&amp;) = default;\n    C&amp; operator=(const C &amp;) = default;\n    C&amp; operator=(C &amp;&amp;c) = default;\n\npublic:\n    template&lt;typename... Args&gt;\n    static std::shared_ptr&lt;C&gt; create(Args&amp;&amp;... args) noexcept {\n        return std::shared_ptr&lt;C&gt;{new C{std::forward&lt;Args&gt;(args)...}};\n    }\n\n    std::shared_ptr&lt;C&gt; ptr() noexcept {\n        return shared_from_this();\n    }\n};\n\nint main() {\n    std::shared_ptr&lt;C&gt; c1 = C::create();\n    std::shared_ptr&lt;C&gt; c2 = C::create(*c1);\n    std::shared_ptr&lt;C&gt; c3 = c2-&gt;ptr();\n    // these won't work anymore...\n    // C c4{};\n    // std::shared_ptr&lt;C&gt; c5 = std::make_shared&lt;C&gt;();\n    // std::shared_ptr&lt;C&gt; c6{new C{}};\n    // C c7{*c1};\n    // ... and so on ...\n}\n</code></pre>\n<p>The basic (trivial?) idea is to forbid the explicit construction of new instances, but by using the factory method here called <code>create</code>.<br>\nVariadic templates are used to avoid writing several factory methods, nothing more. Perfect forwarding helps us to do that the right way.</br></p>\n<p>Pretty simple, isn't it?<br>\nAnyway it took me a while to figure out that, so I hope this will help future readers once across the same doubt.</br></p>\n", "OwnerUserId": "4987285", "PostTypeId": "2", "Id": "35247597", "Score": "1", "CreationDate": "2016-02-06T23:06:36.200", "LastActivityDate": "2016-02-06T23:06:36.200"}, "34213390": {"ParentId": "34213087", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_34213087_34213390_0\">The documentation of this base class says there should be a shared pointer which owns this [object] before calling shared_from_this.</p>\n</blockquote>\n<p>Okay, cool.</p>\n<blockquote>\n<p id=\"so_34213087_34213390_1\">Is it safe to allocate the [object] with new and call shared_from_this to manage the object?</p>\n</blockquote>\n<p>No. There should be a shared pointer which owns this [object] before calling shared_from_this.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "34213390", "Score": "2", "CreationDate": "2015-12-10T23:06:12.333", "LastActivityDate": "2015-12-10T23:06:12.333"}, "34213087": {"CommentCount": "0", "ViewCount": "369", "CreationDate": "2015-12-10T22:43:58.060", "LastActivityDate": "2016-02-06T23:06:36.200", "Title": "Using shared_from_this() without managed shared pointer in C++11", "AcceptedAnswerId": "34213161", "PostTypeId": "1", "Id": "34213087", "Score": "5", "Body": "<p>Let's say I have a class which is a child class of enable_shared_from_this. The documentation of this base class says there should be a shared pointer which owns this class before calling shared_from_this. Is it safe to allocate the class with new and call shared_from_this to manage the object?</p>\n", "Tags": "<c++><pointers><c++11><std><shared-ptr>", "OwnerUserId": "4309871", "AnswerCount": "4"}, "34213161": {"ParentId": "34213087", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>No, it's not safe. You should only call <code>shared_from_this</code> if the object is managed by a <code>shared_ptr</code>, not allocated via <code>new</code> (without an associated <code>shared_ptr</code>). For example this code</p>\n<pre><code>struct Test: std::enable_shared_from_this&lt;Test&gt; {\n  std::shared_ptr&lt;Test&gt; getptr() {\n    return shared_from_this();\n  }\n};\n\nTest *test = new Test;\nstd::shared_ptr&lt;Test&gt; test2 = test-&gt;getptr();\n</code></pre>\n<p>will throw <code>std::bad_weak_ptr</code> (at least when using <code>libstdc++</code>). But this is OK:</p>\n<pre><code>std::shared_ptr&lt;Test&gt; test(new Test);\nstd::shared_ptr&lt;Test&gt; test2 = test-&gt;getptr();\n</code></pre>\n", "OwnerUserId": "471164", "LastEditorUserId": "471164", "LastEditDate": "2015-12-10T22:53:51.090", "Id": "34213161", "Score": "1", "CreationDate": "2015-12-10T22:48:41.813", "LastActivityDate": "2015-12-10T22:53:51.090"}, "34213285": {"ParentId": "34213087", "CommentCount": "0", "Body": "<p>From the standard:</p>\n<blockquote>\n<p id=\"so_34213087_34213285_0\">\u00a7 20.8.2.4</p>\n<p id=\"so_34213087_34213285_1\">shared_ptr shared_from_this();</p>\n<p id=\"so_34213087_34213285_2\">shared_ptr shared_from_this() const;</p>\n<p id=\"so_34213087_34213285_3\">7 *Requires: enable_shared_from_this shall be an accessible base class of T. <strong>this shall be a\n  subobject of an object t of type T. There shall be at least one shared_ptr instance p that owns &amp;t.</strong></p>\n<p id=\"so_34213087_34213285_4\">8 Returns: A shared_ptr object r that shares ownership with p.</p>\n<p id=\"so_34213087_34213285_5\">9 Postconditions: r.get() == this</p>\n</blockquote>\n<p>If you call <code>shared_from_this()</code> within a class that is not managed by a <code>shared_ptr</code> the result will be <strong>undefined behaviour</strong> because you have not fulfilled one of the documented preconditions of the method.</p>\n<p>I know from experience that in [the current version of] libc++ the result is an exception being thrown. However, like all <em>undefined behavior</em> this must not be relied upon.</p>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "34213285", "Score": "3", "CreationDate": "2015-12-10T22:58:56.160", "LastActivityDate": "2015-12-10T22:58:56.160"}, "bq_ids": {"n4140": {"so_34213087_34213285_3": {"section_id": 4503, "quality": 0.7857142857142857, "length": 11}}, "n3337": {"so_34213087_34213285_3": {"section_id": 4334, "quality": 0.7857142857142857, "length": 11}}, "n4659": {"so_34213087_34213285_4": {"section_id": 5660, "quality": 0.8, "length": 4}}}});