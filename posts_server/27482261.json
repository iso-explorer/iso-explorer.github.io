post_cb({"27482261": {"CommentCount": "4", "ViewCount": "318", "CreationDate": "2014-12-15T10:43:10.940", "LastActivityDate": "2014-12-15T11:36:07.540", "Title": "Using reference to pointer as a sequence in C++11 range for loop", "PostTypeId": "1", "Id": "27482261", "Score": "5", "Body": "<p>The only difference between the following two snippets of code is the usage of reference. I understand why the first snippet does not compile and am seeking help in understanding why the second one compiles. </p>\n<p>The first snippet:</p>\n<pre><code>int a[2][3] = {0,1,2,3,4,5};\nfor (auto row : a)\n  for (auto column : row)\n    cout &lt;&lt; column &lt;&lt; endl;\n</code></pre>\n<p>The above code does not compile because the type of 'row' is pointer to int, which is not a sequence.</p>\n<p>The second snippet:</p>\n<pre><code>int a[2][3] = {0,1,2,3,4,5};\nfor (auto &amp;row : a)\n  for (auto column : row)\n    cout &lt;&lt; column &lt;&lt; endl;\n</code></pre>\n<p>This code compiles. If I understand correctly how auto works, 'row' is a reference to pointer to int. But why can this reference be viewed as a sequence more than a regular pointer?  </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2725810", "AnswerCount": "3"}, "27482380": {"ParentId": "27482261", "CommentCount": "0", "CreationDate": "2014-12-15T10:50:41.923", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "27482380", "Score": "5", "Body": "<p>Deduction of the type is done via template argument deduction.</p>\n<pre><code>template &lt;typename U&gt;\nvoid foo(U&amp;); // Equivalent to auto&amp;\n\nfoo(row);\n</code></pre>\n<p>This will always deduce <code>U</code> to be the <strong>exact type</strong> of <code>row</code> (if it's an lvalue as in this case), which gives us the array type we desired.<br>\nOnly for non-reference parameters is the array-to-pointer decay performed.</br></p>\n", "LastActivityDate": "2014-12-15T10:50:41.923"}, "27483146": {"ParentId": "27482261", "CommentCount": "0", "Body": "<p><code>std::begin</code> and <code>std::end</code> don't have overloads for pointer types. Ranged-based for loop are defined to use these functions. If you want to prevent the array-to-pointer conversion from happening, you can bind a reference to the array.</p>\n<p>\u00a78.5.3</p>\n<blockquote>\n<p id=\"so_27482261_27483146_0\"><code>5</code> A reference to type \"<em>cv1</em> <code>T1</code>\" is initialized by an expression\n  of type \"<em>cv2</em> <code>T2</code>\" as follows:</p>\n<blockquote>\n<p id=\"so_27482261_27483146_5\">\u2014 If the reference is an lvalue reference and the initializer\n    expression</p>\n<blockquote>\n<p id=\"so_27482261_27483146_9\">\u2014 is an lvalue (but is not a bit-field), and \"<em>cv1</em> <code>T1</code>\" is\n      reference-compatible with \"<em>cv2</em> <code>T2</code>,\" or</p>\n<p id=\"so_27482261_27483146_10\">\u2014 has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not\n      reference-related to <code>T2</code>, and can be implicitly converted to an\n      lvalue of type \"<em>cv3</em> <code>T3</code>,\" where \"<em>cv1</em> <code>T1</code>\" is\n      reference-compatible with \"<em>cv3</em> <code>T3</code>\"<sup>106</sup> (this conversion\n      is selected by enumerating the applicable conversion functions\n      (13.3.1.6) and choosing the best one through overload resolution\n      (13.3)),</p>\n</blockquote>\n<p id=\"so_27482261_27483146_8\">then the reference is bound to the initializer expression lvalue in\n    the first case and to the lvalue result of the conversion in the\n    second case (or, in either case, to the appropriate base class\n    subobject of the object). [ <em>Note:</em> The usual lvalue-to-rvalue (4.1),\n    array-to-pointer (4.2), and function-to-pointer (4.3) standard\n    conversions are not needed, and therefore are suppressed, when such\n    direct bindings to lvalues are done. \u2014 <em>end note</em> ]</p>\n</blockquote>\n</blockquote>\n<p>Since the second bullet point doesn't apply, then the reference binds <em>directly</em> to the array and no conversion happens.</p>\n", "Id": "27483146", "PostTypeId": "2", "OwnerDisplayName": "user3920237", "Score": "0", "CreationDate": "2014-12-15T11:36:07.540", "LastActivityDate": "2014-12-15T11:36:07.540"}, "bq_ids": {"n4140": {"so_27482261_27483146_0": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_27482261_27483146_6": {"section_id": 3321, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_7": {"section_id": 3321, "quality": 0.7741935483870968, "length": 24}, "so_27482261_27483146_2": {"section_id": 3321, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_9": {"section_id": 3321, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_8": {"section_id": 3321, "quality": 0.8947368421052632, "length": 34}, "so_27482261_27483146_4": {"section_id": 3321, "quality": 0.8947368421052632, "length": 34}, "so_27482261_27483146_5": {"section_id": 3321, "quality": 1.0, "length": 5}, "so_27482261_27483146_10": {"section_id": 3321, "quality": 0.7741935483870968, "length": 24}, "so_27482261_27483146_1": {"section_id": 3321, "quality": 1.0, "length": 5}, "so_27482261_27483146_3": {"section_id": 3321, "quality": 0.7741935483870968, "length": 24}}, "n3337": {"so_27482261_27483146_0": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_27482261_27483146_6": {"section_id": 3191, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_7": {"section_id": 3191, "quality": 0.8064516129032258, "length": 25}, "so_27482261_27483146_9": {"section_id": 3191, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_4": {"section_id": 3191, "quality": 0.8947368421052632, "length": 34}, "so_27482261_27483146_3": {"section_id": 3191, "quality": 0.8064516129032258, "length": 25}, "so_27482261_27483146_8": {"section_id": 3191, "quality": 0.8947368421052632, "length": 34}, "so_27482261_27483146_2": {"section_id": 3191, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_10": {"section_id": 3191, "quality": 0.8064516129032258, "length": 25}, "so_27482261_27483146_5": {"section_id": 3191, "quality": 1.0, "length": 5}, "so_27482261_27483146_1": {"section_id": 3191, "quality": 1.0, "length": 5}}, "n4659": {"so_27482261_27483146_0": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_27482261_27483146_5": {"section_id": 4087, "quality": 1.0, "length": 5}, "so_27482261_27483146_7": {"section_id": 4087, "quality": 0.7741935483870968, "length": 24}, "so_27482261_27483146_6": {"section_id": 4087, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_8": {"section_id": 4087, "quality": 0.8947368421052632, "length": 34}, "so_27482261_27483146_3": {"section_id": 4087, "quality": 0.7741935483870968, "length": 24}, "so_27482261_27483146_4": {"section_id": 4087, "quality": 0.8947368421052632, "length": 34}, "so_27482261_27483146_2": {"section_id": 4087, "quality": 0.6666666666666666, "length": 4}, "so_27482261_27483146_10": {"section_id": 4087, "quality": 0.7741935483870968, "length": 24}, "so_27482261_27483146_1": {"section_id": 4087, "quality": 1.0, "length": 5}, "so_27482261_27483146_9": {"section_id": 4087, "quality": 0.6666666666666666, "length": 4}}}, "27482333": {"ParentId": "27482261", "CommentCount": "0", "CreationDate": "2014-12-15T10:47:23.710", "OwnerUserId": "5597", "PostTypeId": "2", "Id": "27482333", "Score": "4", "Body": "<p>Each element of the outer iteration is an array. In the first case <code>auto</code> takes the element by value so array to pointer decay happens and you can't then loop over a single pointer.</p>\n<p>In the second case you get a reference to the array, which you can of course iterate over.</p>\n", "LastActivityDate": "2014-12-15T10:47:23.710"}});