post_cb({"10855011": {"ParentId": "10854948", "CommentCount": "0", "Body": "<p>For class to be copyable, it needs to have a copy constructor. Whether you write your own, or compiler generates one for you, it doesn't matter \u2014 it has to be available for <code>test a; test b(a);</code> to be a valid operation.</p>\n<p>You explicitly force compiler to delete the copy constructor \u2014 this is new version of old \"make copy constructor private\" trick. It disallows copying. So don't be surprised that you can't copy. Because you told the  compiler to not allow it.</p>\n", "OwnerUserId": "16102", "PostTypeId": "2", "Id": "10855011", "Score": "8", "CreationDate": "2012-06-01T17:47:46.337", "LastActivityDate": "2012-06-01T17:47:46.337"}, "10855009": {"ParentId": "10854948", "CommentCount": "0", "Body": "<p>This line:</p>\n<pre><code>test obj2(obj1)\n</code></pre>\n<p>is trying to call the copy constructor.</p>\n", "OwnerUserId": "1131467", "PostTypeId": "2", "Id": "10855009", "Score": "0", "CreationDate": "2012-06-01T17:47:36.357", "LastActivityDate": "2012-06-01T17:47:36.357"}, "10855018": {"ParentId": "10854948", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard word on implicitly generated copy constructors is <em>[class.copy]/7</em>:</p>\n<blockquote>\n<p id=\"so_10854948_10855018_0\">If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor. </p>\n</blockquote>\n<p>and <em>[class.copy]/13</em>:</p>\n<blockquote>\n<p id=\"so_10854948_10855018_1\">A copy/move constructor that is defaulted and not defined as deleted is implicitly defined if it is odr-used (3.2) or when it is explicitly defaulted after its first declaration. [Note:The copy/move constructor is implicitly defined even if the implementation elided its odr-use (3.2, 12.2). \u2014end note] If the implicitly-defined constructor would satisfy the requirements of a constexpr constructor (7.1.5), the implicitly-defined constructor isconstexpr.</p>\n</blockquote>\n<p>So a <em>copy-constructor</em> is still generated for <code>test</code>, and its getting invoked by statement 2. I would believe that \"Inside C++ Object Model\" is talking about when a <em>copy-constructor</em> isn't trivial.</p>\n", "OwnerUserId": "927034", "LastEditorUserId": "927034", "LastEditDate": "2012-06-01T20:08:13.360", "Id": "10855018", "Score": "2", "CreationDate": "2012-06-01T17:48:08.747", "LastActivityDate": "2012-06-01T20:08:13.360"}, "bq_ids": {"n4140": {"so_10854948_10855018_0": {"section_id": 456, "quality": 0.9473684210526315, "length": 36}, "so_10854948_10855018_1": {"section_id": 462, "quality": 0.8205128205128205, "length": 32}}, "n3337": {"so_10854948_10855018_0": {"section_id": 447, "quality": 0.9473684210526315, "length": 36}, "so_10854948_10855018_1": {"section_id": 453, "quality": 0.8205128205128205, "length": 32}}, "n4659": {"so_10854948_10855018_0": {"section_id": 479, "quality": 0.9473684210526315, "length": 36}, "so_10854948_10855018_1": {"section_id": 485, "quality": 0.8205128205128205, "length": 32}}}, "10854948": {"CommentCount": "5", "ViewCount": "1617", "PostTypeId": "1", "LastEditorUserId": "275567", "CreationDate": "2012-06-01T17:41:24.497", "LastActivityDate": "2012-06-01T20:08:13.360", "Title": "When is default constructor generated in C++", "LastEditDate": "2012-06-01T18:09:07.097", "Id": "10854948", "Score": "1", "Body": "<p>As per \"Inside C++ Object Model\" a copy constructor is generated (if not declared by the programmer) by the compiler only when at least any one of the below four conditions are true:</p>\n<ol>\n<li><p>When the class contains a member object of a class for which a copy constructor exists (either explicitly declared by the class designer, as in the case of the previous String class, or synthesized by the compiler, as in the case of class Word)</p></li>\n<li><p>When the class is derived from a base class for which a copy constructor exists (again, either explicitly declared or synthesized)</p></li>\n<li><p>When the class declares one or more virtual functions</p></li>\n<li><p>When the class is derived from an inheritance chain in which one or more base classes are virtual</p></li>\n</ol>\n<p>Which means if I have a class with just constructor then copy constructor will not be provided by the compiler.</p>\n<p>Lets take an example:</p>\n<pre><code>class test\n{\n    test(){}\n};\nint main()\n{\n    test obj1;       //statement 1\n    test obj2(obj1); //statement 2\n}\n</code></pre>\n<p>Above code works fine. Now the problem comes when I add the following lines in class test:</p>\n<pre><code>test(const test&amp; rhs) = delete;\n</code></pre>\n<p>\"= delete\" ensures that copy constructor is not automatically provided. After adding above line I am getting an error for statement 2 which says <code>Use of deleted function test::test(const test&amp;)</code>.</p>\n<p>My question is: as per \"Inside C++ Object Model\" I don't need a copy constructor for the above class so when I am explicitly saying not to generate a copy constructor (using delete) why am I getting an error? Since I was expecting that the compiler won't need a copy constructor for the above class.</p>\n<p>I am using gcc version 4.6.3.</p>\n", "Tags": "<c++>", "OwnerUserId": "1431221", "AnswerCount": "3"}});