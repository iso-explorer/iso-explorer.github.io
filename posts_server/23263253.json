post_cb({"bq_ids": {"n4140": {"so_23263253_23275446_0": {"length": 9, "quality": 1.0, "section_id": 96}, "so_23263253_23271415_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 96}, "so_23263253_23275446_4": {"length": 7, "quality": 1.0, "section_id": 175}}, "n3337": {"so_23263253_23275446_0": {"length": 9, "quality": 1.0, "section_id": 91}, "so_23263253_23275446_4": {"length": 7, "quality": 1.0, "section_id": 169}, "so_23263253_23271415_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 91}}, "n4659": {"so_23263253_23275446_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 100}, "so_23263253_23271415_0": {"length": 18, "quality": 0.6923076923076923, "section_id": 100}, "so_23263253_23275446_4": {"length": 7, "quality": 1.0, "section_id": 180}}}, "23263253": {"ViewCount": "340", "Body": "<p>I have a problem with this code snippet:</p>\n<pre><code>template &lt;typename T&gt;\nstruct S\n{\n  static int a;\n};\n\ntemplate &lt;typename T&gt;\ndecltype(S&lt;T&gt;::a) S&lt;T&gt;::a;\n</code></pre>\n<p><code>clang-3.4</code> says:</p>\n<pre><code>s.cpp:8:25: error: redefinition of 'a' with a different type: 'decltype(S&lt;T&gt;::a)' vs 'int'\ndecltype(S&lt;T&gt;::a) S&lt;T&gt;::a;\n                        ^\ns.cpp:4:14: note: previous definition is here\n  static int a;\n             ^\n1 error generated.\n</code></pre>\n<p>But <code>gcc-4.8.2</code> accepts. Which of the compilers is right? Should I avoid such code in the future?</p>\n", "Title": "static member of class template error", "CreationDate": "2014-04-24T08:05:27.437", "LastActivityDate": "2014-04-24T17:10:06.590", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-04-24T13:31:58.627", "LastEditorUserId": "2684539", "Id": "23263253", "Score": "18", "OwnerUserId": "1095108", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "3"}, "23267948": {"Id": "23267948", "PostTypeId": "2", "Body": "<p>For me clang is broken here.</p>\n<p>All combinations with decltype will fail. Without decltype it works.</p>\n<pre><code>template &lt;typename T&gt;\nstruct S\n{   \n      static int a;\n\n      using type = decltype( a );\n      typedef decltype( a ) type2;\n};  \n\ntemplate &lt;typename T&gt;\n1) decltype(S&lt;T&gt;::a) S&lt;T&gt;::a;\n2) int S&lt;T&gt;::a;\n3) typename S&lt;T&gt;::type S&lt;T&gt;::a;\n4) typename S&lt;T&gt;::type2 S&lt;T&gt;::a;\n</code></pre>\n<p>1 gcc works, clang fails</p>\n<p>2 gcc + clang works</p>\n<p>3 gcc works, clang fails</p>\n<p>4 gcc works, clang fails</p>\n<p>I did some more tries to work around the problem, but could not have any success.</p>\n<p>There are some more discussions on that kind of problems:\n<a href=\"https://stackoverflow.com/questions/1819131/c-static-member-initalization-template-fun-inside\">C++ Static member initalization (template fun inside)</a></p>\n<p>Edit:\nI found that this topic is simply \"not resolved\" in the standard until now and clang did not implemented it:\nTake a look at:\n<a href=\"http://clang.llvm.org/cxx_dr_status.html\" rel=\"nofollow noreferrer\">http://clang.llvm.org/cxx_dr_status.html</a> ( point 205 )</p>\n<p>I hope that I did not misunderstood the page. Feel free to correct my interpretation. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-24T11:52:19.127", "Score": "2", "CreationDate": "2014-04-24T11:44:05.717", "ParentId": "23263253", "CommentCount": "9", "LastEditDate": "2017-05-23T12:24:11.837", "OwnerUserId": "878532"}, "23275446": {"Id": "23275446", "PostTypeId": "2", "Body": "<p>I think Clang <em>might</em> be right in rejecting this. 14.2p2 says about <code>decltype(e)</code></p>\n<blockquote>\n<p id=\"so_23263253_23275446_0\">If an expression e involves a template parameter, decltype(e) denotes a unique dependent type.</p>\n</blockquote>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2\" rel=\"nofollow\">DR #2</a>, the discussion trace says</p>\n<blockquote>\n<p id=\"so_23263253_23275446_1\">My opinion (which I think matches several posted on the reflector recently) is that the out-of-class definition must match the declaration in the template.</p>\n<p id=\"so_23263253_23275446_2\">...</p>\n<p id=\"so_23263253_23275446_3\">In general, if you can match the declarations up using only information from the template, then the declaration is valid.</p>\n</blockquote>\n<p>I think it still matches if one of them uses a typedef (as demonstrated in the DR), because <code>S&lt;T&gt;::type</code> is a member of the current instantiation and the type aliased can be looked up directly. But a <code>decltype(e)</code>, as specified above, will always denote a unique type (during template parse time) except with respect to another <code>decltype(e)</code> that specifies an equivalent expression.</p>\n<hr>\n<p>Why did I say <em>might</em>? Because of 14.6p8</p>\n<blockquote>\n<p id=\"so_23263253_23275446_4\">No diagnostic shall be issued for a template for which a valid specialization can be generated. </p>\n</blockquote>\n<p>One could read this as saying the type equivalence check is simply delayed till after instantiation. This, however, would contradict the discussion trace in the DR I think, because they say \"if you can match the declarations up using only information from the template, then the declaration is valid\" (and I assume the author of this statement meant to be exhaustive about the situations when the declaration is valid).</p>\n</hr>", "LastActivityDate": "2014-04-24T17:10:06.590", "Score": "3", "CreationDate": "2014-04-24T17:10:06.590", "ParentId": "23263253", "CommentCount": "0", "OwnerUserId": "34509"}, "23271415": {"Id": "23271415", "PostTypeId": "2", "Body": "<p>Clang is demanding that the definition match the declaration at template definition time, whereas GCC and others defer matching until instantiation time (which never even happens for your example).</p>\n<p>Clang accepts this:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nstruct S\n{\n  static int a;\n};\n\ntemplate &lt;typename T&gt;\ntypename std::enable_if&lt; true, int &gt;::type S&lt;T&gt;::a; // Resolves before instantiation\n</code></pre>\n<p>but rejects this small change:</p>\n<pre><code>template &lt;typename T&gt;\ntypename std::enable_if&lt; std::is_same&lt; T, T &gt;::value, int &gt;::type S&lt;T&gt;::a;\n</code></pre>\n<p>I cannot recall where the standard dictates when object declaration matching occurs, but I suspect that Clang is within its rights to reject the code. The intent of the standard, if I recall correctly, is that each declaration matches exactly one definition, and that mapping may be determined before instantiation time.</p>\n<p>With the looser rule that GCC is apparently applying, you could have two member declarations and two definitions, but each definition may finalize either of the declarations depending on the template parameters.</p>\n<p>The code which GCC and MSVC are accepting is ill-formed, no diagnosis required\u2026 pending finding the actual standardese buried somewhere in \u00a73 [basic], \u00a77 [dcl.dcl], \u00a78 [dcl.decl], \u00a714 [temp], or maybe somewhere else.</p>\n<hr>\n<p>I still cannot find what rule matches object definitions to preceding declarations, but \u00a714.4/2 dictates that <code>decltype(\u2026)</code> cannot be the equivalent (I assume in the declarative sense) to <code>int</code>.</p>\n<blockquote>\n<p id=\"so_23263253_23271415_0\">If an expression <em>e</em> involves a template parameter, <code>decltype(e)</code>\n  denotes a unique dependent type. Two such <em>decltype-specifiers</em> refer\n  to the same type only if their expressions are equivalent (14.5.6.1).\n  [<em>Note:</em> however, it may be aliased, e.g., by a <em>typedef-name.</em> \u2014 <em>end\n  note</em> ]</p>\n</blockquote>\n<p>I'm pretty sure that equivalence, not mere aliasing, is necessary for the definition to match the declaration. \u00a714.5.6.1 delves pretty deep into this territory, except it is specifically discussing function signatures.</p>\n</hr>", "LastEditorUserId": "153285", "LastActivityDate": "2014-04-24T15:05:36.300", "Score": "3", "CreationDate": "2014-04-24T14:10:28.813", "ParentId": "23263253", "CommentCount": "0", "LastEditDate": "2014-04-24T15:05:36.300", "OwnerUserId": "153285"}});