post_cb({"bq_ids": {"n4140": {"so_15891106_15891160_1": {"length": 20, "quality": 1.0, "section_id": 243}, "so_15891106_15891160_0": {"length": 7, "quality": 0.7, "section_id": 7043}, "so_15891106_15891160_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 234}}, "n3337": {"so_15891106_15891160_1": {"length": 20, "quality": 1.0, "section_id": 235}, "so_15891106_15891160_0": {"length": 6, "quality": 0.6, "section_id": 48}, "so_15891106_15891160_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 227}}, "n4659": {"so_15891106_15891160_1": {"length": 18, "quality": 0.9, "section_id": 250}, "so_15891106_15891160_0": {"length": 7, "quality": 0.7, "section_id": 8540}, "so_15891106_15891160_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 244}}}, "15891160": {"Id": "15891160", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15891106_15891160_0\">If a template class is used, then all member functions of the class should be implicitly instantiated - whether used or not?</p>\n</blockquote>\n<p><strong>No</strong>, this is definitely not the case. Per Paragraph 14.7.1/10 of the C++11 Standard (and Paragraph 14.7.1/9 of the C++03 Standard) very clearly specifies:</p>\n<blockquote>\n<p id=\"so_15891106_15891160_1\">An implementation shall not implicitly instantiate a function template, a member template, a <strong>non-virtual\n  member function</strong>, a member class, or a static data member of a class template that does not require instantiation.</p>\n</blockquote>\n<p>As for when instantiation is required, Paragraph 14.7.1/2 specifies:</p>\n<blockquote>\n<p id=\"so_15891106_15891160_2\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly\n  specialized, the specialization of the member is implicitly instantiated <strong>when the specialization is referenced\n  in a context that requires the member definition to exist</strong>; [...]</p>\n</blockquote>\n<p>This is certainly not the case if a member function is never referenced.</p>\n<hr>\n<p>Unfortunately, I can't provide an official reference on what the rules were before C++03, but to the best of my knowledge the same \"lazy\" instantiation mechanism was adopted in C++98.</p>\n</hr>", "LastActivityDate": "2013-04-09T00:07:19.897", "CommentCount": "5", "CreationDate": "2013-04-09T00:07:19.897", "ParentId": "15891106", "Score": "5", "OwnerUserId": "1932150"}, "15891106": {"ViewCount": "445", "Body": "<p>Suppose I have a public class and a private implementation class (e.g. PIMPL pattern), and I wish to wrap the private class with a template smart pointer class with a checked delete, as follows:</p>\n<p><strong><code>PublicClass.h</code></strong></p>\n<pre><code>class PrivateClass;\n\n// simple smart pointer with checked delete\ntemplate&lt;class X&gt; class demo_ptr\n{\npublic:\n    demo_ptr (X* p) : the_p(p) { }\n    ~demo_ptr () {\n        // from boost::checked_delete: don't allow compilation of incomplete type\n        typedef char type_must_be_complete[ sizeof(X)? 1: -1 ];\n        (void) sizeof(type_must_be_complete);\n        delete the_p;\n    }\nprivate:\n    X* the_p;\n};\n\n// public-facing class that wishes to wrap some private implementation guts\nclass PublicClass\n{\npublic:\n    PublicClass();\n    ~PublicClass();\n\nprivate:\n    demo_ptr&lt;PrivateClass&gt; pvt;\n};\n</code></pre>\n<p><strong><code>PublicClass.cpp</code></strong></p>\n<pre><code>#include \"PublicClass.h\"\n\nclass PrivateClass\n{\npublic:\n    // implementation stuff goes here...\n    PrivateClass() {}\n};\n//---------------------------------------------------------------------------\nPublicClass::PublicClass() : pvt(new PrivateClass()) {}\n\nPublicClass::~PublicClass() {}\n</code></pre>\n<p><strong><code>main.cpp</code></strong></p>\n<pre><code>#include \"PublicClass.h\"\n\nint main()\n{\n    PublicClass *test = new PublicClass();\n    delete test;\n    return 0;\n}\n</code></pre>\n<p>This code compiles successfully on Visual C++ 2008, but fails to compile on an old version of C++ Builder.  In particular, <code>main.cpp</code> does not compile because <code>demo_ptr&lt;PrivateClass&gt;::~demo_ptr</code> is being instantiated by <code>main.cpp</code>, and that destructor won't compile because it can't do <code>sizeof</code> on an incomplete type for <code>PrivateClass</code>.  Clearly, it is not useful for the compiler to be instantiating <code>~demo_ptr</code> in the consuming <code>main.cpp</code>, since it will never be able to generate a sensible implementation (seeing as how <code>~PrivateClass</code> is not accessible).  (<code>PublicClass.cpp</code> compiles fine on all tested compilers.)</p>\n<p>My question is: what does the C++ standard say about implicit instantiation of a template class's member functions?  Might it be one of the following?  In particular, <em>has this changed over the years?</em></p>\n<ul>\n<li>If a template class is used, then all member functions of the class should be implicitly instantiated - whether used or not?</li>\n<li>Or: template class functions should only be implicitly instantiated one at a time if actually used.  If a particular template class function isn't used, then it shouldn't be implicitly instantiated - even if other template class functions are used and instantiated.</li>\n</ul>\n<p>It seems clear that the second case is the case <em>today</em> because this same pattern is used with PIMPL and <code>unique_ptr</code> with its checked delete, but maybe that was not the case in the past?  Was the first case acceptable compiler behavior in the past?</p>\n<p>Or in other words, was the compiler buggy, or did it accurately follow the C++98 standard, and the standard changed over the years?</p>\n<p>(Fun fact: if you remove the checked delete in C++ Builder, and have function inlining turned off, the project will happily compile.  <code>PublicClass.obj</code> will contain a correct <code>~demo_ptr</code> implementation, and <code>main.obj</code> will contain an incorrect <code>~demo_ptr</code> implementation with undefined behavior.  The function used will depend on the order in which these files are fed to the linker.)</p>\n<p><strong>UPDATE:  This is due to a compiler bug, as noted by Andy Prowl, which is still not fixed in C++ Builder XE8.  I've reported the bug to Embarcadero:</strong> <a href=\"https://quality.embarcadero.com/browse/RSP-13126\" rel=\"nofollow\">bcc32 compiler causes undefined behavior when using std::auto_ptr with PIMPL idiom because template instantiation rules do not follow C++ spec</a></p>\n", "AcceptedAnswerId": "15891160", "Title": "Is it valid for a C++ compiler to implicitly instantiate ALL member functions of a template class?", "CreationDate": "2013-04-09T00:01:25.830", "Id": "15891106", "CommentCount": "9", "LastEditDate": "2015-12-08T22:45:43.000", "PostTypeId": "1", "LastEditorUserId": "562766", "LastActivityDate": "2015-12-08T22:45:43.000", "Score": "3", "OwnerUserId": "562766", "Tags": "<c++><windows><c++11><c++builder>", "AnswerCount": "2"}, "15891211": {"Id": "15891211", "PostTypeId": "2", "Body": "<p><code>unique_ptr</code> is a funny beast.</p>\n<p>Unlike <code>auto_ptr</code>, which called the destructor of the referenced object from the smart pointer destructor, <code>unique_ptr::~unique_ptr</code> merely invokes a deleter function which has been previously stored.</p>\n<p>The deleter function is stored in the <code>unique_ptr</code> <em>constructor</em>, which is called for each and every <code>PublicClass</code> constructor.  The user-defined constructor is defined in a context where <code>PrivateClass::~PrivateClass</code> is available, so that's ok.  But what about other implicitly-generated <code>PublicClass</code> constructors, such as a move constructor?  They're generated at the point of use; they also need to initialize the <code>unique_ptr</code> member, meaning they must supply a deleter.  But without <code>PrivateClass::~PrivateClass</code>, they can't.</p>\n<p>Wait, your question mentions <code>unique_ptr</code>, but your code isn't using it.  Weird...</p>\n<p>Even when the destructor is invoked from the smart pointer destructor, it can still be ODR-used from the containing class <em>constructors</em>.  This is for exception-safety -- the constructor needs the capability to tear down a partially-constructed class, which includes destruction of members.</p>\n<p>It looks like C++Builder may be generating a <code>PublicClass</code> copy or more constructor, even though your program doesn't use it.  That doesn't fall afoul of the rule Andy mentioned, because <code>PublicClass</code> isn't a template.  I think the compiler is entitled to generate a defaulted copy constructor for <code>PublicClass</code> when it processes the class definition, since you can't provide an out-of-class definition for a defaulted member.  Respecting the rule of three for <code>demo_ptr</code> will preclude <code>PublicClass</code> having a copy constructor, and therefore may solve your problem.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2013-04-09T01:47:35.240", "Score": "1", "CreationDate": "2013-04-09T00:14:47.883", "ParentId": "15891106", "CommentCount": "5", "OwnerUserId": "103167", "LastEditDate": "2013-04-09T01:47:35.240"}});