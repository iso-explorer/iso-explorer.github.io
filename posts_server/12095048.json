post_cb({"12095048": {"ViewCount": "2766", "Body": "<p>I've been trying to wrap my head around how move semantics in C++11 are supposed to work, and I'm having a good deal of trouble understanding what conditions a moved-from object needs to satisfy. Looking at the <a href=\"https://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object\">answer here</a> doesn't really resolve my question, because can't see how to apply it to pimpl objects in a sensible way, despite arguments that <a href=\"http://herbsutter.com/gotw/_100/\" rel=\"nofollow noreferrer\">move semantics are perfect for pimpls</a>.</p>\n<p>The easiest illustration of my problem involves the pimpl idiom, like so:</p>\n<pre><code>class Foo {\n    std::unique_ptr&lt;FooImpl&gt; impl_;\npublic:\n    // Inlining FooImpl's constructors for brevity's sake; otherwise it \n    // defeats the point.\n    Foo() : impl_(new FooImpl()) {}\n\n    Foo(const Foo &amp; rhs) : impl_(new FooImpl(*rhs.impl_)) {}\n\n    Foo(Foo &amp;&amp; rhs) : impl_(std::move(rhs.impl_)) {}\n\n    Foo &amp; operator=(Foo rhs) \n    {\n        std::swap(impl_, rhs.impl_);\n\n        return *this;\n    }\n\n    void do_stuff () \n    {\n        impl_-&gt;do_stuff;\n    }\n};\n</code></pre>\n<p>Now, what can I do once I've moved from a <code>Foo</code>? I can destroy the moved-from object safely, and I can assign to it, both of which are absolutely crucial. However, if I try to <code>do_stuff</code> with my <code>Foo</code>, it will explode. Before I added move semantics for my definition of <code>Foo</code>, every <code>Foo</code> satisfied the invariant that it could <code>do_stuff</code>, and that's no longer the case. There don't seem to be many great alternatives, either, since (for example) putting the moved-from <code>Foo</code> would involve a new dynamic allocation, which partially defeats the purpose of move semantics. I could check whether <code>impl_</code> in <code>do_stuff</code> and initialize it to a default <code>FooImpl</code> if it is, but that adds a (usually spurious) check, and if I have a lot of methods it would mean remembering to do the check in every one. </p>\n<p>Should I just give up on the idea that being able to <code>do_stuff</code> is a reasonable invariant?</p>\n", "AcceptedAnswerId": "12095473", "Title": "What constitutes a valid state for a \"moved from\" object in C++11?", "CreationDate": "2012-08-23T15:23:50.457", "Id": "12095048", "CommentCount": "6", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:54:16.613", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-22T15:38:11.450", "Score": "19", "OwnerUserId": "85467", "Tags": "<c++><c++11><move-semantics><pimpl-idiom><invariants>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12095048_12095473_1": {"length": 23, "quality": 0.92, "section_id": 6365}}, "n3337": {"so_12095048_12095473_1": {"length": 23, "quality": 0.92, "section_id": 6122}}, "n4659": {"so_12095048_12095473_1": {"length": 23, "quality": 0.92, "section_id": 7876}}}, "12095473": {"Id": "12095473", "PostTypeId": "2", "Body": "<p>You define and document for your types what a 'valid' state is and what operation can be performed on moved-from objects of your types.</p>\n<p>Moving an object of a standard library type puts the object into an unspecified state, which can be queried as normal to determine valid operations.</p>\n<blockquote>\n<p id=\"so_12095048_12095473_0\"><strong>17.6.5.15 Moved-from state of library types \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n  [lib.types.movedfrom]</strong></p>\n<p id=\"so_12095048_12095473_1\">Objects of types defined in the C++ standard library may be moved from\n  (12.8). Move operations may be explicitly specified or implicitly\n  generated. Unless otherwise specified, such moved-from objects shall\n  be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>The object being in a 'valid' state means that all the requirements the standard specifies for the type still hold true. That means you can use any operation on a moved-from, standard library type for which the preconditions hold true.</p>\n<p>Normally the state of an object is known so you don't have to check if it meets the preconditions for each operation you want to perform. The only difference with moved-from objects is that you don't know the state, so you do have to check. For example, you should not pop_back() on a moved-from string until you have queried the state of the string to determine that the preconditions of pop_back() are met.</p>\n<pre><code>std::string s = \"foo\";\nstd::string t(std::move(s));\nif (!s.empty()) // empty has no preconditions, so it's safe to call on moved-from objects\n    s.pop_back(); // after verifying that the preconditions are met, pop_back is safe to call on moved-from objects\n</code></pre>\n<p>The state is probably unspecified because it would be onerous to create a single useful set of requirements for all different implementations of the standard library.</p>\n<hr>\n<p>Since you are responsible not only for the specification but also the implementation of your types, you can simply specify the state and obviate the need for querying. For example it would be perfectly reasonable to specify that moving from your pimpl type object causes do_stuff to become an invalid operation with undefined behavior (via dereferencing a null pointer). The language is designed such that moving only occurs either when it's not possible to do anything to the moved-from object, or when the user has very obviously and very explicitly indicated a move operation, so a user should never be surprised by a moved-from object.</p>\n<hr>\n<p>Also note that the 'concepts' defined by the standard library do not make any allowances for moved-from objects. That means that in order to meet the requirements for any of the concepts defined by the standard library, moved-from objects of your types must still fulfill the concept requirements. This means that if objects of your type don't remain in a valid state (as defined by the relevant concept) then you cannot use it with the standard library (or the result is undefined behavior).</p>\n</hr></hr>", "LastEditorUserId": "365496", "LastActivityDate": "2013-02-02T21:25:39.847", "Score": "20", "CreationDate": "2012-08-23T15:46:17.487", "ParentId": "12095048", "CommentCount": "1", "LastEditDate": "2013-02-02T21:25:39.847", "OwnerUserId": "365496"}, "12095310": {"Id": "12095310", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12095048_12095310_0\">However, if I try to do_stuff with my Foo, it will explode.</p>\n</blockquote>\n<p>Yes. So will this:</p>\n<pre><code>vector&lt;int&gt; first = {3, 5, 6};\nvector&lt;int&gt; second = std::move(first);\nfirst.size();  //Value returned is undefined. May be 0, may not\n</code></pre>\n<p>The rule the standard uses is to leave the object in a <em>valid</em> (meaning that the object works) but <em>unspecified</em> state. This means that the <em>only</em> functions you can call are those that have no conditions on the current state of the object. For <code>vector</code>, you can use its copy/move assignment operators, as well as <code>clear</code> and <code>empty</code>, and several other operations. So you can do this:</p>\n<pre><code>vector&lt;int&gt; first = {3, 5, 6};\nvector&lt;int&gt; second = std::move(first);\nfirst.clear();  //Cause the vector to become empty.\nfirst.size(); //Now the value is guaranteed to be 0.\n</code></pre>\n<p>For your case, copy/move assignment (from either side) should still work, as should the destructor. But all other functions of yours have a precondition based on the state of not having been moved from.</p>\n<p>So I don't see your problem.</p>\n<p>If you wanted to ensure that no instance of a Pimpl'd class could be empty, then you would implement proper copy semantics and forbid moving. Movement <em>requires</em> the possibility of an object being in an empty state.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2012-08-23T16:20:56.067", "Score": "7", "CreationDate": "2012-08-23T15:38:18.333", "ParentId": "12095048", "CommentCount": "8", "LastEditDate": "2012-08-23T16:20:56.067", "OwnerUserId": "734069"}});