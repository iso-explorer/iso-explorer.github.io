post_cb({"bq_ids": {"n4140": {"so_23712259_23712371_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5313}, "so_23712259_23712374_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 5313}}, "n3337": {"so_23712259_23712371_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5110}, "so_23712259_23712374_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 5110}}, "n4659": {"so_23712259_23712371_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6737}, "so_23712259_23712374_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 6737}}}, "23712371": {"Id": "23712371", "PostTypeId": "2", "Body": "<p>I think the first \"phase of translation\" handles that (C++11 2.2/1:1.):</p>\n<blockquote>\n<p id=\"so_23712259_23712371_0\">Any source file character not in the basic source character set (2.3) is replaced by the universal-character-name that designates that character.</p>\n</blockquote>\n<p>So your input files are encoded in the source character set, which includes the basic source character set, but in the program text all non-basic characters are replaced by their universal-character-name.</p>\n", "LastActivityDate": "2014-05-17T14:20:38.517", "Score": "5", "CreationDate": "2014-05-17T14:20:38.517", "ParentId": "23712259", "CommentCount": "0", "OwnerUserId": "596781"}, "23712259": {"ViewCount": "246", "Body": "<p>According to ISO/IEC 14882:2011(\u00a72.14.3), <em>character-literal</em>, which is also called constants, is illustrated as below.</p>\n<pre><code>character-literal:\n    \u2019 c-char-sequence \u2019\n    u\u2019 c-char-sequence \u2019\n    U\u2019 c-char-sequence \u2019\n    L\u2019 c-char-sequence \u2019\n\n...\n\nc-char:\n    any member of the source character set except\n        the single-quote \u2019, backslash \\, or new-line character\n    escape-sequence\n    universal-character-name\n</code></pre>\n<p>At a glance, it seems <strong>directly putting in unicode instead of using <em>universal-character-name</em> in <em>character-literal</em></strong> is illegal. However most compilers, such as g++ and visual studio c++, do not bother at all with it, which is somewhat confusing. Does each implementation automatically convert these unicodes to <em>universal-character-name</em> before compile begins regardless of the standard?</p>\n", "AcceptedAnswerId": "23712371", "Title": "Is it illegal directly putting in unicode in character-literal instead of using universal-character-name?", "CreationDate": "2014-05-17T14:08:13.537", "Id": "23712259", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-29T13:14:58.550", "LastEditorUserId": "3647351", "LastActivityDate": "2014-05-29T13:14:58.550", "Score": "7", "OwnerUserId": "3647351", "Tags": "<c++><c++11><unicode>", "AnswerCount": "2"}, "23712374": {"Id": "23712374", "PostTypeId": "2", "Body": "<p>It's implementation-defined:</p>\n<p>\u00a72.2 Phases of translation:</p>\n<blockquote id=\"so_23712259_23712374_0\">\n<ol>\n<li>[...] The set of physical source file characters accepted is implementation-defined. [...] Any source file character not in the basic\n  source character set (2.3) is replaced by the universal-character-name that designates that character. (An implementation may use any internal encoding, so long as an actual extended character\n  encountered in the source file, and the same extended character expressed in the source file as a\n  universal-character-name (i.e., using the \\uXXXX notation), are handled equivalently [...].)</li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2014-05-17T14:21:05.913", "Score": "3", "CreationDate": "2014-05-17T14:21:05.913", "ParentId": "23712259", "CommentCount": "0", "OwnerUserId": "2128694"}});