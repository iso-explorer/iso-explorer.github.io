post_cb({"bq_ids": {"n4140": {"so_7567883_7569028_0": {"length": 74, "quality": 0.9367088607594937, "section_id": 3919}, "so_7567883_7569028_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 3919}, "so_7567883_7569028_1": {"length": 14, "quality": 1.0, "section_id": 3919}, "so_7567883_7569028_3": {"length": 10, "quality": 1.0, "section_id": 3919}, "so_7567883_7569028_6": {"length": 7, "quality": 0.875, "section_id": 3919}}, "n3337": {"so_7567883_7569028_0": {"length": 74, "quality": 0.9367088607594937, "section_id": 3779}, "so_7567883_7569028_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 3779}, "so_7567883_7569028_1": {"length": 14, "quality": 1.0, "section_id": 3779}, "so_7567883_7569028_6": {"length": 7, "quality": 0.875, "section_id": 3779}, "so_7567883_7569028_3": {"length": 10, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_7567883_7569028_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 4805}, "so_7567883_7569028_1": {"length": 14, "quality": 1.0, "section_id": 4805}, "so_7567883_7569028_3": {"length": 10, "quality": 1.0, "section_id": 4805}, "so_7567883_7569028_6": {"length": 7, "quality": 0.875, "section_id": 4805}}}, "7567883": {"ViewCount": "1376", "Body": "<blockquote>\n<p id=\"so_7567883_7567883_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/10585928/is-static-init-thread-safe-with-vc2010\">Is static init thread-safe with VC2010?</a> </br></p>\n</blockquote>\n<p>I know that gcc and llvm-clang emit code to initialise local static variables in a threadsafe manner (which allows one to escape the static order initialisation fiasco by wrapping global statics in functions).</p>\n<p><a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2004/03/08/85901.aspx\" rel=\"nofollow noreferrer\">This msdn blog post</a>, however, is the best documentation I can find of vcc's behaviour in these circumstances, and purports that static initialisation cannot ever be threadsafe, because the initialiser for a local static could recursively call into the same scope.</p>\n<p>I don't buy this argument - it is clearly a programming error if the initialiser relies on its own result.</p>\n<p>So, given that this article is from 2004, that gcc and clang can do it, and that <a href=\"http://msdn.microsoft.com/en-us/library/s1sb61xd.aspx\" rel=\"nofollow noreferrer\">the current msvc documentation</a> is ambiguous (stating that 'assigning' to a local static isn't threadsafe, but nothing more):</p>\n<p><strong>Is the initialisation of local statics now threadsafe in MSVC?</strong></p>\n<p><strong>If not, why not, since it is clearly possible for gcc to do this, but very difficult for the programmer to add in afterwards.</strong></p>\n", "AcceptedAnswerId": "7569028", "Title": "Thread-safe initialisation of local statics: MSVC", "CreationDate": "2011-09-27T10:47:48.307", "LastActivityDate": "2013-04-15T00:22:04.833", "CommentCount": "3", "LastEditDate": "2017-05-23T10:34:29.643", "PostTypeId": "1", "Tags": "<c++><visual-c++><thread-safety>", "Id": "7567883", "AnswerCount": "2", "Score": "7", "OwnerUserId": "233201", "ClosedDate": "2013-01-15T22:16:26.253", "LastEditorUserId": "-1"}, "7567939": {"Id": "7567939", "PostTypeId": "2", "Body": "<p>I heard it is already implemented in vs2010, but can not find any reference. Anyway in c++0x standard such initializations are explicitly required to be thread-safe, so sooner or later ms would comply I guess. </p>\n", "LastActivityDate": "2011-09-27T10:53:45.943", "CommentCount": "1", "CreationDate": "2011-09-27T10:53:45.943", "ParentId": "7567883", "Score": "1", "OwnerUserId": "383522"}, "7569028": {"Id": "7569028", "PostTypeId": "2", "Body": "<p>The C++0x Standard says:</p>\n<p><strong>\u00a76.7 Declaration statement [stmt.dcl]</strong></p>\n<blockquote>\n<p id=\"so_7567883_7569028_0\"><strong>4/</strong> The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage duration (3.7.2) is performed before any other initialization takes place. Constant initialization (3.6.2) of a block-scope entity with static storage duration, if applicable, is performed before its block is first entered.\n  An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization.</p>\n<p id=\"so_7567883_7569028_1\">If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration.</p>\n<p id=\"so_7567883_7569028_2\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.<sup>88</sup></p>\n<p id=\"so_7567883_7569028_3\">If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p>\n<p id=\"so_7567883_7569028_4\"><em>[ Example:</em></p>\n</blockquote>\n<pre><code>int foo(int i) {\n  static int s = foo(2*i); // recursive call - undefined\n  return i+1;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_7567883_7569028_5\"><em>\u2014end example ]</em></p>\n<p id=\"so_7567883_7569028_6\"><em>88) The implementation must not introduce any deadlock around execution of the initializer.</em></p>\n</blockquote>\n<p>As expected, it is quite complete.</p>\n<p>However the fact is that even older versions of gcc already complied with this, and in fact do even better: in case of recursive initialization, an exception is thrown.</p>\n<p>Finally, regarding a programmer adding it afterward: you can normally do it if you have something like Compare And Swap available, and use a sufficiently small variable, relying on zero-initialization of the variable to mark its non-computed state. However I do agree it's much easier if it's baked in.</p>\n<p>I am afraid I stopped followed VC++ progresses though, so I don't know where it stands now. My only advice would be... look it up at assembly level.</p>\n", "LastActivityDate": "2011-09-27T12:23:44.383", "CommentCount": "0", "CreationDate": "2011-09-27T12:23:44.383", "ParentId": "7567883", "Score": "1", "OwnerUserId": "147192"}});