post_cb({"10938350": {"Id": "10938350", "PostTypeId": "2", "Body": "<p>UTF-8 character literal would have to have variable length - for <strike>many</strike> most of them, it's not possible to store single character in <code>char</code> or <code>wchar</code>, what type should it have, then? As we don't have variable length types in C, nor in C++, except for arrays of fixed size types, the only reasonable type for it would be <code>const char *</code> - and C strings are required to be null-terminated, so it wouldn't change anything.</p>\n<p>As for the edit:</p>\n<p>Quote from the C++11 standard:</p>\n<blockquote>\n<p id=\"so_10938306_10938350_0\">The glyphs for the members of the basic source character set are intended to identify characters from the subset of ISO/IEC 10646 which corresponds to the ASCII character set. However, because the mapping from source file characters to the source character set (described in translation phase 1) is specified as implementation-defined, an implementation is required to document how the basic source characters are represented in source files.</p>\n</blockquote>\n<p>(footnote at 2.3.1).</p>\n<p>I think that it's good reason for not guaranteeing it. Although, as you noted in comment here, for most (or every) mainstream compiler, the ASCII-ness of character literals is implementation guaranteed.</p>\n", "LastEditorUserId": "809387", "LastActivityDate": "2012-06-07T19:37:40.850", "Score": "8", "CreationDate": "2012-06-07T19:11:15.147", "ParentId": "10938306", "CommentCount": "14", "OwnerUserId": "809387", "LastEditDate": "2012-06-07T19:37:40.850"}, "10938306": {"ViewCount": "3999", "Body": "<p>Why is there no UTF-8 character literal in C11 or C++11 even though there are UTF-8 string literals? I understand that, generally-speaking, a character literal represents a single ASCII character which is identical to a single-octet UTF-8 code point, but neither C nor C++ says the encoding has to be ASCII.</p>\n<p>Basically, if I read the standard right, there's no guarantee that <code>'0'</code> will represent the integer 0x30, yet <code>u8\"0\"</code> must represent the char sequence 0x30 0x00.</p>\n<p>EDIT:</p>\n<p>I'm aware not every UTF-8 code point would fit in a char. Such a literal would only be useful for single-octet code points (aka, ASCII), so I guess calling it an \"ASCII character literal\" would be more fitting, so the question still stands. I just chose to frame the question with UTF-8 because there are UTF-8 string literals. The only way I can imagine portably guaranteeing ASCII values would be to write a constant for each character, which wouldn't be so bad considering there are only 128, but still...</p>\n", "AcceptedAnswerId": "10939076", "Title": "Why is there no ASCII or UTF-8 character literal in C11 or C++11?", "CreationDate": "2012-06-07T19:08:39.260", "Id": "10938306", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-02-19T20:23:52.317", "LastEditorUserId": "1774667", "LastActivityDate": "2015-06-23T17:48:22.907", "Score": "17", "OwnerUserId": "1195206", "Tags": "<c++><utf-8><c++11><ascii><c11>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_10938306_30872695_2": {"length": 28, "quality": 0.6511627906976745, "section_id": 5344}, "so_10938306_10938350_0": {"length": 40, "quality": 0.975609756097561, "section_id": 5314}}, "n3337": {"so_10938306_30872695_2": {"length": 28, "quality": 0.6511627906976745, "section_id": 5141}, "so_10938306_10938350_0": {"length": 40, "quality": 0.975609756097561, "section_id": 5111}}, "n4659": {"so_10938306_30872695_2": {"length": 38, "quality": 0.8837209302325582, "section_id": 6766}, "so_10938306_10938350_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 6738}}}, "10938641": {"Id": "10938641", "PostTypeId": "2", "Body": "<p>If you don't trust that your compiler will treat <code>'0'</code> as ASCII character 0x30, then you could use <code>static_cast&lt;char&gt;(0x30)</code> instead.</p>\n", "LastActivityDate": "2012-06-07T19:33:00.507", "CommentCount": "5", "CreationDate": "2012-06-07T19:33:00.507", "ParentId": "10938306", "Score": "0", "OwnerUserId": "222329"}, "19731575": {"Id": "19731575", "PostTypeId": "2", "Body": "<p>As you are aware, UTF-8-encoded characters need several octets, thus <code>char</code>s, so the natural type for them is <code>char[]</code>, which is indeed the type for a <code>u8</code>-prefixed string literal! So C11 is right on track here, just that it sticks to its syntax conventions using <code>\"</code> for a <em>string</em>, needing to be used as an array of char, rather than your implied semantic-based proposal to use <code>'</code> instead.</p>\n<p>About <code>\"0\"</code> versus <code>u8\"0\"</code>, you are reading right, only the latter is guaranteed to be identical to <code>{ 0x30, 0 }</code>, even on EBCDIC systems. By the way, the very fact the former is not can be handled conveniently in your code, if you pay attention to the <code>__STDC_MB_MIGHT_NEQ_WC__</code> predefined identifier.</p>\n", "LastActivityDate": "2013-11-01T17:03:08.410", "CommentCount": "0", "CreationDate": "2013-11-01T17:03:08.410", "ParentId": "10938306", "Score": "0", "OwnerUserId": "656988"}, "30872695": {"Id": "30872695", "PostTypeId": "2", "Body": "<p>For C++ this has been addressed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4540.html#119\" rel=\"noreferrer\">Evolution Working Group issue 119: Adding u8 character literals</a> whose <em>Motivation</em> section says:</p>\n<blockquote>\n<p id=\"so_10938306_30872695_0\">We have five encoding-prefixes for string-literals (none, L, u8, u, U)\n  but only four for character literals -- the missing one is u8. If the\n  narrow execution character set is not ASCII, u8 character literals\n  would provide a way to write character literals with guaranteed ASCII\n  encoding (the single-code-unit u8 encodings are exactly ASCII). Adding\n  support for these literals would add a useful feature and make the\n  language slightly more consistent.</p>\n<p id=\"so_10938306_30872695_1\">EWG discussed the idea of adding u8 character literals in Rapperswil and accepted the change. This paper provides wording for that\n  extension.</p>\n</blockquote>\n<p>This was incorporated into the working draft using the wording from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4267.html\" rel=\"noreferrer\">N4267: Adding u8 character literals</a> and we can find the wording in at this time latest draft standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\" rel=\"noreferrer\">N4527</a> and note as section <code>2.14.3</code> say they are limited to code points that fit into a single UTF-8 code unit:</p>\n<blockquote>\n<p id=\"so_10938306_30872695_2\">A character literal that begins with u8, such as u8'w', is a character\n  literal of type char, known as a UTF-8 character literal. The value of\n  a UTF-8 character literal is equal to its ISO10646 code point value,\n  provided that the code point value is representable with a single\n  UTF-8 code unit (that is, provided it is a US-ASCII character). A\n  UTF-8 character literal containing multiple c-chars is ill-formed.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-06-23T17:48:22.907", "Score": "7", "CreationDate": "2015-06-16T16:01:50.413", "ParentId": "10938306", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-06-23T17:48:22.907"}, "10939076": {"Id": "10939076", "PostTypeId": "2", "Body": "<p>It is perfectly acceptable to write non-portable C code, and this is one of many good reasons to do so.  Feel free to assume that your system uses ASCII or some superset thereof, and warn your users that they shouldn't try to run your program on an EBCDIC system.</p>\n<p>If you are feeling very generous, you can encode a check.  The <code>gperf</code> program is known to generate code that includes such a check.</p>\n<pre><code>_Static_assert('0' == 48, \"must be ASCII-compatible\");\n</code></pre>\n<p>Or, for pre-C11 compilers,</p>\n<pre><code>extern int must_be_ascii_compatible['0' == 48 ? 1 : -1];\n</code></pre>\n<p>If you are on C11, you can use the <code>u</code> or <code>U</code> prefix on character constants, but not the <code>u8</code> prefix...</p>\n<pre><code>/* This is useless, doesn't do what you want... */\n_Static_assert(0, \"this code is broken everywhere\");\nif (c == '\u3005') ...\n\n/* This works as long as wchar_t is UTF-16 or UTF-32 or UCS-2... */\n/* Note: you shouldn't be using wchar_t, though... */\n_Static_assert(__STDC_ISO_10646__, \"wchar_t must be some form of Unicode\");\nif (c == L'\u3005') ...\n\n/* This works as long as char16_t is UTF-16 or UCS-2... */\n_Static_assert(__STDC_UTF_16__, \"char16_t must be UTF-16\");\nif (c == u'\u3005') ...\n\n/* This works as long as char32_t is UTF-32... */\n_Static_assert(__STDC_UTF_32__, \"char32_t must be UTF-32\");\nif (c == U'\u3005') ...\n</code></pre>\n<p><strong>There are</strong> some projects that are written in very portable C and have been ported to non-ASCII systems (<a href=\"http://httpd.apache.org/docs/2.0/platform/ebcdic.html\" rel=\"noreferrer\">example</a>).  This required a non-trivial amount of porting effort, and there's no real reason to make the effort unless you know you want to run your code on EBCDIC systems.</p>\n<p><strong>On standards:</strong> The people writing the C standard have to contend with every possible C implementation, including some downright bizarre ones.  There are known systems where <code>sizeof(char) == sizeof(long)</code>, <code>CHAR_BIT != 8</code>, integral types have trap representations, <code>sizeof(void *) != sizeof(int *)</code>, <code>sizeof(void *) != sizeof(void (*)())</code>, <code>va_list</code> are heap-allocated, etc.  It's a nightmare.</p>\n<p>Don't beat yourself up trying to write code that will run on systems you've never even heard of, and don't search to hard for guarantees in the C standard.</p>\n<p>For example, as far as the C standard is concerned, the following is a valid implementation of <code>malloc</code>:</p>\n<pre><code>void *malloc(void) { return NULL; }\n</code></pre>\n<p>Note that while <code>u8\"...\"</code> constants are guaranteed to be UTF-8, <code>u\"...\"</code> and <code>U\"...\"</code> have no guarantees except that the encoding is 16-bits and 32-bits per character, respectively, and the actual encoding must be documented by the implementation.</p>\n<p><strong>Summary:</strong> Safe to assume ASCII compatibility in 2012.</p>\n", "LastActivityDate": "2012-06-07T20:07:51.727", "CommentCount": "3", "CreationDate": "2012-06-07T20:07:51.727", "ParentId": "10938306", "Score": "9", "OwnerUserId": "82294"}});