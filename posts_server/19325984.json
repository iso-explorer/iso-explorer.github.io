post_cb({"19327299": {"ParentId": "19325984", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_19325984_19327299_0\"><strong>17.6.4.2.1/1</strong> The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace\n  within namespace <code>std</code> unless otherwise specified. A program may add a\n  template specialization for any standard library template to namespace\n  <code>std</code> only if the declaration depends on a user-defined type and the\n  specialization meets the standard library requirements for the\n  original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>So yes, I believe that, technically, your code exhibits undefined behavior. Perhaps you can write a simple class that takes a pair of iterators in its constructor and implements <code>begin()</code> and <code>end()</code> methods. Then you can write something like</p>\n<pre><code>for (const auto&amp; elem: as_range(equal_range(...))) {}\n</code></pre>\n", "OwnerUserId": "1670129", "LastEditorUserId": "815724", "LastEditDate": "2013-10-13T19:29:18.770", "Id": "19327299", "Score": "7", "CreationDate": "2013-10-11T21:09:09.723", "LastActivityDate": "2013-10-13T19:29:18.770"}, "bq_ids": {"n4140": {"so_19325984_19327299_0": {"section_id": 6299, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_19325984_19327299_0": {"section_id": 6056, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_19325984_19327299_0": {"section_id": 7808, "quality": 0.9428571428571428, "length": 33}}}, "19325984": {"CommentCount": "0", "AcceptedAnswerId": "19327299", "CreationDate": "2013-10-11T19:41:29.790", "LastActivityDate": "2013-10-13T19:29:18.770", "PostTypeId": "1", "ViewCount": "802", "FavoriteCount": "3", "Title": "Can I specialize std::begin and std::end for the return value of equal_range()?", "Id": "19325984", "Score": "9", "Body": "<p>The <code>&lt;algorithm&gt;</code> header provides <code>std::equal_range()</code>, as well as some containers having it as a member function. What bothers me with this function is that it returns a pair of iterators, making it tedious to iterate from the begin iterator to the end iterator. I'd like to be able to use <code>std::begin()</code> and <code>std::end()</code> so that I can use the C++11 range-based for-loop.</p>\n<p>Now, I've heard contradictory information in regards to specializing <code>std::begin()</code> and <code>std::end()</code> - I've been told that adding anything to the std namespace results in undefined behavior, whereas I have also been told that you can provide your own specializations of <code>std::begin()</code> and <code>std::end()</code>.</p>\n<p>This is what I am doing right now:</p>\n<pre><code>namespace std\n{\n    template&lt;typename Iter, typename = typename iterator_traits&lt;Iter&gt;::iterator_category&gt;\n    Iter begin(pair&lt;Iter, Iter&gt; const &amp;p)\n    {\n        return p.first;\n    }\n    template&lt;typename Iter, typename = typename iterator_traits&lt;Iter&gt;::iterator_category&gt;\n    Iter end(pair&lt;Iter, Iter&gt; const &amp;p)\n    {\n        return p.second;\n    }\n}\n</code></pre>\n<p>And this does work: <a href=\"http://ideone.com/wHVfkh\">http://ideone.com/wHVfkh</a></p>\n<p>But I am wondering, what are the downsides to doing this? Is there a better way to do this?</p>\n", "Tags": "<c++><c++11><stl><iterator><template-specialization>", "OwnerUserId": "1959975", "AnswerCount": "1"}});