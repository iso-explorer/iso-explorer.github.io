post_cb({"29970349": {"ParentId": "29970221", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Your original case relied upon aggregate initialization [dcl.init.list]:</p>\n<blockquote>\n<p id=\"so_29970221_29970349_0\">List-initialization of an object or reference of type T is defined as follows:<br>\n  ...<br>\n  \u2014 Otherwise, if <code>T</code> is an aggregate, aggregate initialization is performed</br></br></p>\n</blockquote>\n<p>Where an aggregate and aggregate initialiazation are, from [dcl.init.aggr], emphasis mine:</p>\n<blockquote>\n<p id=\"so_29970221_29970349_1\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or\n  protected non-static data members (Clause 11), <strong>no base classes (Clause 10)</strong>, and no virtual functions (10.3).</p>\n<p id=\"so_29970221_29970349_2\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list\n  are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each\n  member is copy-initialized from the corresponding initializer-clause.</p>\n</blockquote>\n<p>But now, since <code>point</code> has a base class (<code>serializable&lt;point&gt;</code>), <code>point</code> is no longer an aggregate and no longer supports aggregate initialization. </p>\n<p>The solution is to simply provide such a constructor to initialize <code>point</code>:</p>\n<pre><code>struct point : public serializable&lt;point&gt;\n{\n    template &lt;typename... T&gt;\n    point(T... ts) \n    : coord{ts...}\n    { } \n\n    float coord[3];\n};\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-04-30T14:29:43.877", "Id": "29970349", "Score": "8", "CreationDate": "2015-04-30T14:24:08.077", "LastActivityDate": "2015-04-30T14:29:43.877"}, "29970221": {"CommentCount": "0", "AcceptedAnswerId": "29970349", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-04-30T14:18:05.560", "LastActivityDate": "2015-04-30T21:03:07.453", "LastEditDate": "2015-04-30T21:03:07.453", "ViewCount": "346", "FavoriteCount": "1", "Title": "Enable default initializer list constructor", "Id": "29970221", "Score": "7", "Body": "<p>I believe modern C++ initializer lists are very useful for initializing objects, to the point of removing the need for defining your own constructor:</p>\n<pre><code>struct point\n{\n    float coord[3];\n};\n\npoint p = {1.f, 2.f, 3.f}; // nice !\n</code></pre>\n<p>However, this doesn't work when my class inherits from another class:</p>\n<pre><code>template&lt;typename T&gt;\nclass serializable\n{\n    protected:\n        serializable() = default;\n    ...\n    // other stuff\n}\n\nstruct point : public serializable&lt;point&gt;\n{\n    float coord[3];\n};\npoint p = {1.f, 2.f, 3.f}; // Doesn't work :(\n</code></pre>\n<p>I tried adding <code>point() = default;</code> to my point class, but that didn't work either. How can I still initialize point with an initializer list?</p>\n", "Tags": "<c++><c++11><inheritance><initializer-list><list-initialization>", "OwnerUserId": "1503898", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29970221_29970349_1": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}, "so_29970221_29970349_2": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}, "so_29970221_29970349_0": {"section_id": 3325, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_29970221_29970349_1": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}, "so_29970221_29970349_2": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}, "so_29970221_29970349_0": {"section_id": 3195, "quality": 1.0, "length": 11}}, "n4659": {"so_29970221_29970349_1": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}, "so_29970221_29970349_2": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}, "so_29970221_29970349_0": {"section_id": 4091, "quality": 1.0, "length": 11}}}});