post_cb({"bq_ids": {"n4140": {"so_14597463_14597463_6": {"length": 10, "quality": 0.5263157894736842, "section_id": 224}, "so_14597463_14597463_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 7141}, "so_14597463_14597463_12": {"length": 10, "quality": 0.5263157894736842, "section_id": 224}}, "n3337": {"so_14597463_14597463_6": {"length": 13, "quality": 0.6842105263157895, "section_id": 217}, "so_14597463_14597463_9": {"length": 13, "quality": 0.5652173913043478, "section_id": 217}, "so_14597463_14597463_12": {"length": 13, "quality": 0.6842105263157895, "section_id": 217}, "so_14597463_14597463_1": {"length": 13, "quality": 0.5652173913043478, "section_id": 217}, "so_14597463_14597463_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6885}}, "n4659": {"so_14597463_14597463_6": {"length": 10, "quality": 0.5263157894736842, "section_id": 232}, "so_14597463_14597463_12": {"length": 10, "quality": 0.5263157894736842, "section_id": 232}, "so_14597463_14597463_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 8642}}}, "14597928": {"Id": "14597928", "PostTypeId": "2", "Body": "<p>As far as I know, it's purely historical -- it seems to have originally been banned because cfront's name mangling wasn't sufficient to handle it correctly.</p>\n<p>At one point, Anthony Williams wrote <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1353.html\" rel=\"nofollow\">a paper</a> proposing that it would be allowed, and telling how to do it -- but AFAIK, that paper has never been accepted nor its requirements edited into the standard. I suspect that's as much a matter of timing as anything else though. It was proposed in 2001, so what they were working on at the time (C++ 2003) wasn't intended to add much new material, and by the time they started working in earnest on C++11, it seems to have been mostly forgotten.</p>\n", "LastActivityDate": "2013-01-30T06:24:50.367", "CommentCount": "1", "CreationDate": "2013-01-30T06:24:50.367", "ParentId": "14597463", "Score": "3", "OwnerUserId": "179910"}, "14597463": {"ViewCount": "1440", "Body": "<h2>Background</h2>\n<p>In C++03, symbols used as template arguments must have external linkage; this restriction was removed in C++11, as explored in <a href=\"https://stackoverflow.com/questions/14595992/why-stdsort-doesnt-accept-compare-classes-declared-within-a-function\"><em>this</em> previous question</a>:</p>\n<blockquote>\n<p id=\"so_14597463_14597463_0\">In C++03, template arguments could not have internal linkage:</p>\n<blockquote>\n<p id=\"so_14597463_14597463_9\"><code>[C++03: 14.6.4.2/1]:</code> For a function call that depends on a template parameter, if the function name is an <em>unqualified-id</em> but not a <em>template-id</em>, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li><strong>For the part of the lookup using unqualified name lookup</strong> (3.4.1), <strong>only function declarations with external linkage from the template definition context are found</strong>.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations with external linkage found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n<p id=\"so_14597463_14597463_10\"><em>[..]</em></p>\n</blockquote>\n<p id=\"so_14597463_14597463_3\">This was changed (issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#561\" rel=\"nofollow noreferrer\">#561: \"Internal linkage functions in dependent name lookup\"</a>) in C++11:</p>\n<blockquote>\n<p id=\"so_14597463_14597463_11\"><code>[C++11: C.2.6]:</code> 14.6.4.2 <br/>\n<strong>Change</strong>: Allow dependent calls of functions with internal linkage <br/>\n<strong>Rationale:</strong> Overly constrained, simplify overload resolution rules.</p>\n</blockquote>\n<p id=\"so_14597463_14597463_5\">resulting in:</p>\n<blockquote>\n<p id=\"so_14597463_14597463_12\"><code>[C++11: 14.6.4.2/1]:</code> For a function call that depends on a template parameter, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2, 3.4.3) except that:</p>\n<ul>\n<li><strong>For the part of the lookup using unqualified name lookup</strong> (3.4.1) or qualified name lookup (3.4.3), <strong>only function declarations from the template definition context are found.</strong></li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n<p id=\"so_14597463_14597463_13\"><em>[..]</em></p>\n</blockquote>\n<p id=\"so_14597463_14597463_8\">(Spot the missing <em>\"with external linkage\"</em> qualification.)</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#561\" rel=\"nofollow noreferrer\">Issue #561 (\"Internal linkage functions in dependent name lookup\")</a>, the proposal that led to the restriction being removed in C++11, asks:</p>\n<blockquote>\n<p id=\"so_14597463_14597463_14\">Furthermore, is it really necessary to exclude internal linkage functions from the lookup? Doesn't the ODR give implementations sufficient latitude to handle this case without another wrinkle on name lookup?</p>\n</blockquote>\n<p>With the later answer:</p>\n<blockquote>\n<p id=\"so_14597463_14597463_15\">The consensus of the group was that <em>[..]</em> internal-linkage functions should be found by the lookup (although they may result in errors if selected by overload resolution).</p>\n</blockquote>\n<hr>\n<h2>Question</h2>\n<p><strong>What was the original practical rationale for the restriction?</strong></p>\n<p>It seems like there must have been one, since the original standard wording went out of its way to limit lookup to symbols with external linkage.</p>\n<p>Is it just that \"[internal-linkage functions] may result in errors if selected by overload resolution\", and that through the 2000s opinion shifted over how important this was? Or did something else change, perhaps as an indirect consequence of new wording elsewhere for a different C++11 feature?</p>\n</hr>", "AcceptedAnswerId": "14598244", "Title": "Why did C++03 require template parameters to have external linkage?", "CreationDate": "2013-01-30T05:43:40.267", "Id": "14597463", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:08:27.283", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-30T07:17:41.167", "Score": "13", "OwnerUserId": "560648", "Tags": "<c++><templates>", "AnswerCount": "2"}, "14598244": {"Id": "14598244", "PostTypeId": "2", "Body": "<p>I would suspect it's related to the infamous <code>export</code> template feature of C++98. Think about it. Once you allow the possibility of template definitions appearing in separate translation units, but still not truly compilable until the template arguments are specified (i.e., the template is instantiated), you get into this twilight zone where the TU with the definition of the template and the TU with the instantiation have to obey linker-visibility rules (i.e., separation model) while sharing their contexts in terms of overload resolution. The solution to that problem is to allow only functions with external linkage in the dependent name lookups.</p>\n<p>Here's an example. One of the lesser known \"feature\" of exported templates is that you could have, in the template's TU, some functions or classes with internal linkage (i.e., marked <code>static</code> or in an un-named namespace). What if the TU with the instantiation has a internal-linkage function too, one that would be ambiguous with or possibly superceded by the one in the template's TU? That's a bit of a surreal problem, I know, it's the bizarro world of exported templates. The only way to avoid very surprising behavior is to rule out all internal-linkage functions from the lookups. Consider also that no-one had a clear idea of how to actually implement exported templates, and it would probably seem even more impossible to implement without this restriction.</p>\n<p>And so, once exported templates are out, the restriction on dependent name lookups seems clearly useless and it was taken out without much debate. At least, that makes perfect sense to me, but, of course, it's speculation.</p>\n<p>Here's a concrete example:</p>\n<pre><code>// in exptemp.h\nexport template &lt;typename T&gt; bool is_valid(T value);\n\n// in exptemp.cpp\nnamespace {\n  bool is_space(char c) {\n    return (c == ' ') || (c == '\\t');\n  };\n};\n\ntemplate &lt;typename T&gt;\nbool is_valid(T value) {\n  return is_space(value);\n};\n\n// in test.cpp\n#include \"exptemp.h\"\n\nnamespace {\n  bool is_space(char c) {\n    return (c == ' ') || (c == '\\t') || (c == '\\n');\n  };\n};\n\nint main() {\n  char c = '\\n';\n  return is_valid(c);   // will this return 0 or 1 ?!?!?\n};\n</code></pre>\n", "LastEditorUserId": "491645", "LastActivityDate": "2013-01-30T07:17:41.167", "Score": "8", "CreationDate": "2013-01-30T06:51:45.177", "ParentId": "14597463", "CommentCount": "3", "LastEditDate": "2013-01-30T07:17:41.167", "OwnerUserId": "491645"}});