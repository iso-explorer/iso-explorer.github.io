post_cb({"39777331": {"ViewCount": "180", "Body": "<p>Consider this code:</p>\n<pre><code>int x = 0;\n\ntemplate&lt;int&amp; I&gt;\nstruct SR {};\n\ntemplate&lt;int* I&gt;\nstruct SP {};\n\nSR&lt;(x)&gt; sr;\nSP&lt;&amp;(x)&gt; sp;\n\nint main(void)\n{\n}\n</code></pre>\n<p>clang++ 3.8.0 complains:</p>\n<pre><code>main.cpp:10:5: error: non-type template argument does not refer to any declaration\nSP&lt;&amp;(x)&gt; sp;\n    ^~~\nmain.cpp:6:15: note: template parameter is declared here\ntemplate&lt;int* I&gt;\n              ^\n</code></pre>\n<p>g++ 6.1.0 complains:</p>\n<pre><code>main.cpp:10:8: error: template argument 1 is invalid\n SP&lt;&amp;(x)&gt; sp;\n        ^\n</code></pre>\n<p>Naturally, everything works fine if I remove the parentheses, as in <code>SP&lt;&amp;x&gt; sp;</code>.  But I can't find anything in the C++14 Standard that would make a difference here.  Further, why is the reference case okay but the pointer case bad?  Are the compilers correct to reject the program?</p>\n", "AcceptedAnswerId": "39777847", "Title": "Do parentheses make a pointer template argument invalid?", "CreationDate": "2016-09-29T18:17:35.473", "Id": "39777331", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-09-29T18:52:51.903", "Score": "7", "OwnerUserId": "459640", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39777331_39777847_1": {"length": 13, "quality": 0.5909090909090909, "section_id": 87}, "so_39777331_39777847_0": {"length": 46, "quality": 0.9787234042553191, "section_id": 87}}, "n3337": {"so_39777331_39777847_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 82}, "so_39777331_39777847_0": {"length": 40, "quality": 0.851063829787234, "section_id": 82}}, "n4659": {"so_39777331_39777847_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 90}}}, "39777847": {"Id": "39777847", "PostTypeId": "2", "Body": "<p>My reading of the standard is that it should be allowed, but I suppose the implementors of GCC and Clang disagree with my interpretation, and they're probably correct. For a definitive answer, it might be a good idea to ask the std-discussion@isocpp.org mailing list (I'll shoot them an email). The wording might be a defect.</p>\n<p>According to [temp.arg.nontype], one of the possible forms for a non-type template argument is:</p>\n<blockquote>\n<p id=\"so_39777331_39777847_0\">... a constant expression (5.19) that designates the address of a complete object with static storage duration and external or internal linkage or a function with external or internal linkage, including function\n  templates and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as <code>&amp;</code><em>id-expression,</em> where the <em>id-expression</em> is the name of an object or function, except that the\n  <code>&amp;</code> may be omitted if the name refers to a function or array and shall be omitted if the corresponding\n  <em>template-parameter</em> is a reference ...</p>\n</blockquote>\n<p>It all hinges on what \"ignoring parentheses\" means. GCC and Clang both accept <code>(&amp;x)</code> but not <code>&amp;(x)</code>; they seem to have decided that \"ignoring parentheses\" means only on the outside, not around the <em>id-expression.</em> If this was the intent of the standards committee, the language should be clarified.</p>\n<p><strong>Edit:</strong> In the <a href=\"http://eel.is/c++draft/temp.arg.nontype\" rel=\"nofollow\">C++17 draft</a>, this is unambiguously allowed, since the form of allowable non-type template arguments has been relaxed considerably:</p>\n<blockquote>\n<p id=\"so_39777331_39777847_1\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a converted constant expression ([expr.const]) of the type of the <em>template-parameter.</em> For a non-type <em>template-parameter</em> of reference or pointer type, the value of the constant expression shall not refer to (or for a pointer type, shall not be the address of):</p>\n<ul>\n<li>a subobject ([intro.object]),</li>\n<li>a temporary object ([class.temporary]),</li>\n<li>a string literal ([lex.string]),</li>\n<li>the result of a <code>typeid</code> expression ([expr.typeid]), or</li>\n<li>a predefined <code>__func__</code> variable ([dcl.fct.def.general]).</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "481267", "LastActivityDate": "2016-09-29T18:52:51.903", "Score": "4", "CreationDate": "2016-09-29T18:46:58.633", "ParentId": "39777331", "CommentCount": "2", "OwnerUserId": "481267", "LastEditDate": "2016-09-29T18:52:51.903"}});