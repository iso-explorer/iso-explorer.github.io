post_cb({"23681954": {"CommentCount": "4", "AcceptedAnswerId": "23682092", "CreationDate": "2014-05-15T14:58:47.503", "LastActivityDate": "2014-05-15T15:19:17.693", "PostTypeId": "1", "ViewCount": "449", "FavoriteCount": "2", "Title": "in c++, why there is a requirment that lists must be sorted before merging", "Id": "23681954", "Score": "2", "Body": "<p>In the c++, list data structure has a merge function which basically removes all objects in the source list and put into destination list. </p>\n<p><code>// source list will be empty after this operation\ndestinationList.merge(sourceList);</code></p>\n<p>According to tutorials/examples, lists must be sorted before merging operation. </p>\n<p><code>destinationList.sort();\nsourceList.sort();\ndestinationList.merge(sourceList);</code></p>\n<p>I confused because if there is a requirement of sorting lists, why c++ doesn't enforce it by calling sort function in the merge function ? </p>\n<p>Another thing, i can first merge unsorted lists, then i can sort merged list, isn't this same ?</p>\n<p><code>destinationList.merge(sourceList);\ndestinationList.sort();\n</code></p>\n<p>Thank you</p>\n", "Tags": "<c++><list><linked-list>", "OwnerUserId": "1516116", "AnswerCount": "3"}, "23682092": {"ParentId": "23681954", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_23681954_23682092_0\">why there is a requirement that lists must be sorted before merging?</p>\n</blockquote>\n<p>The purpose of <code>merge</code> is to merge two sorted lists to create a new sorted list, without the overhead of performing another sort. Merging can be done in linear time, while sorting is <code>O(n*log(n))</code>.</p>\n<blockquote>\n<p id=\"so_23681954_23682092_1\">why c++ doesn't enforce it by calling sort function in the merge function ?</p>\n</blockquote>\n<p>Because, if the list is already sorted, that would be horribly inefficient.</p>\n<blockquote>\n<p id=\"so_23681954_23682092_2\">Another thing, i can first merge unsorted lists, then i can sort merged list, isn't this same ?</p>\n</blockquote>\n<p>No. The merge algorithm requires that the inputs be sorted, and produces a sorted list from them. It works by comparing the first elements of the input lists, taking the lower one, and appending that to the output list.</p>\n<p>You could achieve the same thing by appending the two lists then sorting the result; but again that would be inefficient if the lists are already sorted.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2014-05-15T15:19:17.693", "Id": "23682092", "Score": "14", "CreationDate": "2014-05-15T15:05:22.533", "LastActivityDate": "2014-05-15T15:19:17.693"}, "23682279": {"ParentId": "23681954", "CommentCount": "0", "Body": "<p>One of the driving priniciples of C++ design is \"Don't pay for what you don't use\".</p>\n<p>You are possibly referring to the requirement of </p>\n<blockquote>\n<p id=\"so_23681954_23682279_0\">\u00a723.3.5.5 <code>list</code> operations</p>\n<p id=\"so_23681954_23682279_1\"><code>void merge(list&amp; x);</code></p>\n<p id=\"so_23681954_23682279_2\"><code>void merge(list&amp;&amp; x);</code></p>\n<p id=\"so_23681954_23682279_3\"><code>template  void merge(list&amp; x, Compare comp);</code></p>\n<p id=\"so_23681954_23682279_4\"><code>template  void merge(list&amp;&amp; x, Compare comp);</code></p>\n<p id=\"so_23681954_23682279_5\"><sup>22</sup> <em>Requires:</em> <code>comp</code> shall define a strict weak ordering (25.4), and both the list and the argument list shall be sorted according to this ordering.</p>\n</blockquote>\n<p>What happens in an actual implementation is that the merge operation doesn't just take two lists and copies the elements from one into another, it merely exploits the underlying representation of some kind of linked list like structure, and relinks elements from one list into another. It will do this by going through both lists and taking the next bigger element. Since the lists are both sorted already, it can do this by always just looking at the first element of both lists. An operation in linear time <em>O(n)</em>.</p>\n<p>Would you always concatenate them (an operation possible by a splice like operation in constant time) and then sort them, the complexity would raise to <em>O(n log n)</em>. This is undesired if you already have sorted lists.</p>\n<p>If you don't, then splicing them together, and sorting afterwards is the thing you want to do. </p>\n<p>Offering all these functionalities seperately (splice, merge, sort), the user can chose what is the most efficient thing to combine his lists, based on his knowledge of them being already sorted or not.</p>\n", "OwnerUserId": "833362", "PostTypeId": "2", "Id": "23682279", "Score": "2", "CreationDate": "2014-05-15T15:13:58.390", "LastActivityDate": "2014-05-15T15:13:58.390"}, "23682348": {"ParentId": "23681954", "CommentCount": "0", "Body": "<p>A slightly different take assuming you mean 'combining' rather than 'merging' here.</p>\n<p>There is no requirement that lists be sorted before they are <em>combined together</em>.\nThere are 3 separate slightly different ways to combine lists depending on your requirements</p>\n<p>Merging sorted lists:</p>\n<pre><code>list1.merge( list2 ) // Complexity linear. Assumes list1 &amp; list2 are sorted\n</code></pre>\n<p>Moving all elements of a list into another:</p>\n<pre><code>list1.splice( std::end( list1 ), list2 ) //Complexity: constant\n</code></pre>\n<p>Copying some elements of one list into another:</p>\n<pre><code>list1.insert( it1, it2 )// Complexity: linear, it1 &amp; it2 are iterators pointing into list2\n</code></pre>\n<p>So infact the C++ standard provides multiple algorithms each with the optimal complexity for that particular task.</p>\n", "OwnerUserId": "2235800", "PostTypeId": "2", "Id": "23682348", "Score": "0", "CreationDate": "2014-05-15T15:17:03.830", "LastActivityDate": "2014-05-15T15:17:03.830"}, "bq_ids": {"n4140": {"so_23681954_23682279_5": {"section_id": 944, "quality": 0.8571428571428571, "length": 12}, "so_23681954_23682279_3": {"section_id": 943, "quality": 1.0, "length": 5}, "so_23681954_23682279_4": {"section_id": 943, "quality": 1.0, "length": 5}}, "n3337": {"so_23681954_23682279_5": {"section_id": 932, "quality": 0.8571428571428571, "length": 12}, "so_23681954_23682279_3": {"section_id": 931, "quality": 1.0, "length": 5}, "so_23681954_23682279_4": {"section_id": 931, "quality": 1.0, "length": 5}}, "n4659": {"so_23681954_23682279_5": {"section_id": 1005, "quality": 0.8571428571428571, "length": 12}, "so_23681954_23682279_3": {"section_id": 1004, "quality": 1.0, "length": 5}, "so_23681954_23682279_4": {"section_id": 1004, "quality": 1.0, "length": 5}}}});