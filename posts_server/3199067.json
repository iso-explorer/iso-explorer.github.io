post_cb({"3288602": {"Id": "3288602", "PostTypeId": "2", "Body": "<p>You have to use an technology based on compile-time instrumentation. While valgrind could check all function calls at run-time (malloc, free), it could not check just <strong>code</strong>.</p>\n<p>Depending your architecture, <strong>IBM PurifyPlus</strong> find some of these problem. Therefore, you should find a valid license (or use your company one) to use-it, or try-it with the trial version.</p>\n", "LastActivityDate": "2010-07-20T09:27:04.453", "CommentCount": "0", "CreationDate": "2010-07-20T09:27:04.453", "ParentId": "3199067", "Score": "2", "OwnerUserId": "135720"}, "3199107": {"Id": "3199107", "PostTypeId": "2", "Body": "<p>I don't think any static tool can catch that, but if you use <a href=\"http://valgrind.org/\" rel=\"nofollow noreferrer\">Valgrind</a> along with some unit tests or whatever code is crashing (seg fault), you can easily find where the memory is bring referenced and where it was allocated originally.</p>\n", "LastActivityDate": "2010-07-07T21:43:30.953", "CommentCount": "1", "CreationDate": "2010-07-07T21:43:30.953", "ParentId": "3199067", "Score": "1", "OwnerUserId": "177324"}, "3264887": {"Id": "3264887", "PostTypeId": "2", "Body": "<p>There are runtime based solutions which instrument the code to check invalid pointer accesses. I've only used mudflap so far (which is integrated in GCC since version 4.0). mudflap tries to track each pointer (and reference) in the code and checks each access if the pointer/reference actually points to an alive object of its base type. Here is an example:</p>\n<pre><code>#include &lt;stdio.h&gt;\nstruct S {\n    S(int &amp; value): value_(value) {}\n    int &amp; value_;\n};\n\nS function() {\n    int value = 0;\n    return S(value);   // implicitly returning reference to local value\n}\nint main()\n{\n    S x=function();\n    printf(\"%s\\n\",x.value_); //&lt;-oh noes!\n}\n</code></pre>\n<p>Compile this with mudflap enabled:</p>\n<pre><code>g++ -fmudflap s.cc -lmudflap\n</code></pre>\n<p>and running gives:</p>\n<pre><code>$ ./a.out\n*******\nmudflap violation 1 (check/read): time=1279282951.939061 ptr=0x7fff141aeb8c size=4\npc=0x7f53f4047391 location=`s.cc:14:24 (main)'\n      /opt/gcc-4.5.0/lib64/libmudflap.so.0(__mf_check+0x41) [0x7f53f4047391]\n      ./a.out(main+0x7f) [0x400c06]\n      /lib64/libc.so.6(__libc_start_main+0xfd) [0x7f53f358aa7d]\nNearby object 1: checked region begins 332B before and ends 329B before\nmudflap object 0x703430: name=`argv[]'\nbounds=[0x7fff141aecd8,0x7fff141aece7] size=16 area=static check=0r/0w liveness=0\nalloc time=1279282951.939012 pc=0x7f53f4046791\nNearby object 2: checked region begins 348B before and ends 345B before\nmudflap object 0x708530: name=`environ[]'\nbounds=[0x7fff141aece8,0x7fff141af03f] size=856 area=static check=0r/0w liveness=0\nalloc time=1279282951.939049 pc=0x7f53f4046791\nNearby object 3: checked region begins 0B into and ends 3B into\nmudflap dead object 0x7089e0: name=`s.cc:8:9 (function) int value'\nbounds=[0x7fff141aeb8c,0x7fff141aeb8f] size=4 area=stack check=0r/0w liveness=0\nalloc time=1279282951.939053 pc=0x7f53f4046791\ndealloc time=1279282951.939059 pc=0x7f53f4046346\nnumber of nearby objects: 3\nSegmentation fault\n</code></pre>\n<p>A couple of points to consider: </p>\n<ol>\n<li>mudflap can be fine tuned in what exactly it should check and do. read <a href=\"http://gcc.gnu.org/wiki/Mudflap_Pointer_Debugging\" rel=\"noreferrer\">http://gcc.gnu.org/wiki/Mudflap_Pointer_Debugging</a> for details.</li>\n<li>The default behaviour is to raise a SIGSEGV on a violation, this means you can find the violation in your debugger. </li>\n<li>mudflap can be a bitch, in particular when your are interacting with libraries that are not compiled with mudflap support. </li>\n<li>It wont't bark on the place where the dangling reference is created (return S(value)), only when the reference is dereferenced. If you need this, then you'll need a static analysis tool. </li>\n</ol>\n<p>P.S. one thing to consider was, to add a <strong>NON-PORTABLE</strong> check to the copy constructor of S(), which asserts that value_ is not bound to an integer with a shorter life span (for example, if *this is located on an \"older\" slot of the stack that the integer it is bound to). This is higly-machine specific and possibly tricky to get right of course, but should be OK as long it's only for debugging.</p>\n", "LastActivityDate": "2010-07-16T12:38:23.247", "CommentCount": "1", "CreationDate": "2010-07-16T12:38:23.247", "ParentId": "3199067", "Score": "8", "OwnerUserId": "385433"}, "3199121": {"Id": "3199121", "PostTypeId": "2", "Body": "<p>Your code shouldn't even compile. The compilers I know of will either fail to compile the code, or at the very least throw a warning.</p>\n<p>If you meant <code>return S(value)</code> instead, then for heavens sake <strong>COPY PASTE THE CODE YOU POST HERE</strong>.</p>\n<p>Rewriting and introducing typos just means it is impossible for us to actually guess which errors you're <em>asking</em> about, and which ones were accidents we're supposed to ignore.</p>\n<p>When you post a question anywhere on the internet, if that question includes code, <strong>POST THE EXACT CODE</strong>.</p>\n<p>Now, assuming this was actually a typo, the code is perfectly legal, and there's no reason why <em>any</em> tool should warn you.</p>\n<p>As long as you don't try to dereference the dangling reference, the code is perfectly safe.</p>\n<p>It is possible that some static analysis tools (Valgrind, or MSVC with /analyze, for example) can warn you about this, but there doesn't seem to be much point because you're not doing anything wrong. You're returning an object which happens to contain a dangling reference. You're not directly returning a reference to a local object (which compilers typically <em>do</em> warn about), but a higher level object with behavior that might make it perfectly safe to use, even though it contains a reference to a local object that's gone out of scope.</p>\n", "LastActivityDate": "2010-07-07T21:44:59.687", "CommentCount": "0", "CreationDate": "2010-07-07T21:44:59.687", "ParentId": "3199067", "Score": "1", "OwnerUserId": "33213"}, "3199124": {"Id": "3199124", "PostTypeId": "2", "Body": "<p>I think this is not possible to catch all these, although some compilers may give warnings in some cases. </p>\n<p>It's as well to remember that references are really pointers under the hood, and many of the shoot-self-in-foot scenarios possible with pointers are still possible..</p>\n<p>To clarify what I mean about \"pointers under the hood\", take the following two classes. One uses references, the other pointers.</p>\n<pre><code>class Ref\n{\n  int &amp;ref;\npublic:\n  Ref(int &amp;r) : ref(r) {};\n  int get() { return ref; };\n};\n\nclass Ptr\n{\n  int *ptr;\npublic:\n  Ptr(int *p) : ptr(p) {};\n  int get() { return *ptr; };\n};\n</code></pre>\n<p>Now, compare at the generated code for the two. </p>\n<pre><code>@@Ref@$bctr$qri proc    near  // Ref::Ref(int &amp;ref)\n    push      ebp\n    mov       ebp,esp\n    mov       eax,dword ptr [ebp+8]\n    mov       edx,dword ptr [ebp+12]\n    mov       dword ptr [eax],edx\n    pop       ebp\n    ret \n\n@@Ptr@$bctr$qpi proc    near  // Ptr::Ptr(int *ptr)\n    push      ebp\n    mov       ebp,esp\n    mov       eax,dword ptr [ebp+8]\n    mov       edx,dword ptr [ebp+12]\n    mov       dword ptr [eax],edx\n    pop       ebp\n    ret \n\n@@Ref@get$qv    proc    near // int Ref:get()\n    push      ebp\n    mov       ebp,esp\n    mov       eax,dword ptr [ebp+8]\n    mov       eax,dword ptr [eax]\n    mov       eax,dword ptr [eax]\n    pop       ebp\n    ret \n\n@@Ptr@get$qv    proc    near // int Ptr::get()\n    push      ebp\n    mov       ebp,esp\n    mov       eax,dword ptr [ebp+8]\n    mov       eax,dword ptr [eax]\n    mov       eax,dword ptr [eax]\n    pop       ebp\n    ret \n</code></pre>\n<p>Spot the difference? There isn't any.</p>\n", "LastEditorUserId": "1737", "LastActivityDate": "2010-07-16T20:36:56.980", "Score": "4", "CreationDate": "2010-07-07T21:45:14.550", "ParentId": "3199067", "CommentCount": "6", "OwnerUserId": "1737", "LastEditDate": "2010-07-16T20:36:56.980"}, "3300627": {"Id": "3300627", "PostTypeId": "2", "Body": "<p>This is perfectly valid code.</p>\n<p>If you call your function and bind the temporary to a const reference the scope gets prolonged.</p>\n<pre><code>const S&amp; s1 = function(); // valid\n\nS&amp; s2 = function(); // invalid\n</code></pre>\n<p>This is explicitly allowed in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">C++ standard</a>.</p>\n<p>See 12.2.4:</p>\n<blockquote>\n<p id=\"so_3199067_3300627_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression.</p>\n</blockquote>\n<p>and 12.2.5:</p>\n<blockquote>\n<p id=\"so_3199067_3300627_1\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except: [...]</p>\n</blockquote>\n", "LastEditorUserId": "54710", "LastActivityDate": "2010-07-21T15:13:20.667", "Score": "0", "CreationDate": "2010-07-21T14:56:44.073", "ParentId": "3199067", "CommentCount": "1", "OwnerUserId": "54710", "LastEditDate": "2010-07-21T15:13:20.667"}, "bq_ids": {"n4140": {"so_3199067_3300627_0": {"length": 10, "quality": 1.0, "section_id": 381}, "so_3199067_3300627_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 382}}, "n3337": {"so_3199067_3300627_0": {"length": 10, "quality": 1.0, "section_id": 372}, "so_3199067_3300627_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 373}}, "n4659": {"so_3199067_3300627_0": {"length": 9, "quality": 0.9, "section_id": 396}, "so_3199067_3300627_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 397}}}, "3264925": {"Id": "3264925", "PostTypeId": "2", "Body": "<p>There is a guideline I follow after having been beaten by this exact thing:</p>\n<blockquote>\n<p id=\"so_3199067_3264925_0\">When a class has a reference member (or a pointer to something that can have a lifetime you don't control), make the object non-copyable.</p>\n</blockquote>\n<p>This way, you reduce the chances of escaping the scope with a dangling reference.</p>\n", "LastActivityDate": "2010-07-16T12:43:14.673", "CommentCount": "1", "CreationDate": "2010-07-16T12:43:14.673", "ParentId": "3199067", "Score": "1", "OwnerUserId": "373025"}, "3199067": {"ViewCount": "3051", "Body": "<p>Suppose the following piece of code</p>\n<pre><code>struct S {\n    S(int &amp; value): value_(value) {}\n    int &amp; value_;\n};\n\nS function() {\n    int value = 0;\n    return S(value);   // implicitly returning reference to local value\n}\n</code></pre>\n<p>compiler does not produce warning (-Wall), this error can be hard to catch.</p>\n<p>What tools are out there to help catch such problems</p>\n", "AcceptedAnswerId": "3264887", "Title": "C++ catching dangling reference", "CreationDate": "2010-07-07T21:38:57.980", "Id": "3199067", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2010-07-21T15:13:20.667", "Score": "12", "OwnerUserId": "206328", "Tags": "<c++><debugging><reference>", "AnswerCount": "7"}});