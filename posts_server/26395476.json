post_cb({"26395566": {"PostTypeId": "2", "Body": "<p>On some cases it is possible to add an exception specification like this and handle them with safety. Note that the object is only deleted when no exception is thrown.</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nstruct A{\n    bool a;\n\n    A():a(1){}\n    ~A()throw(int){\n        if(a)a=0,throw 0;\n    }\n};\n\nint main(){\n    A*a=new A();\n    try{\n        delete a;\n    }catch(int&amp;){\n        delete a;\n        cout&lt;&lt;\"here\"&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-10-16T08:52:03.727", "LastEditorUserId": "640731", "Id": "26395566", "CommentCount": "1", "CreationDate": "2014-10-16T03:04:51.717", "ParentId": "26395476", "Score": "0", "OwnerUserId": "3948753", "LastEditDate": "2014-10-16T08:52:03.727"}, "26395768": {"PostTypeId": "2", "Body": "<p>Others have answered from the standard, but I think another example illustrates the conceptual problem best:</p>\n<pre><code>struct foo {\n    char *buf;\n\n    foo() : buf(new char[100]) {}\n\n    ~foo() {\n        if(buf[0] == 'a')\n            throw 1;\n        delete[] buf;\n    }\n};\n\nint main() {\n    foo *f = new f;\n    try {\n        delete f;\n    } catch(int a) {\n        // Now what?\n    }\n}\n</code></pre>\n<p>This is a bit simplistic, of course, but shows the problem.  What's the right thing for <code>delete f</code> to have done?  Whichever way it goes, you end up with either a partially destructed object or a memory leak.</p>\n", "LastActivityDate": "2014-10-16T03:30:51.297", "Id": "26395768", "CommentCount": "0", "CreationDate": "2014-10-16T03:30:51.297", "ParentId": "26395476", "Score": "0", "OwnerUserId": "274460"}, "26395489": {"PostTypeId": "2", "Body": "<p>Whenever you throw an exception while exception processing is ongoing, you get a special exception that can't be caught and this leads to an abort.</p>\n<p>You can use <a href=\"http://en.cppreference.com/w/cpp/error/uncaught_exception\" rel=\"nofollow\"><code>std::uncaught_exception</code></a> to detect if exception handling is already in progress and avoid throwing in that case.</p>\n", "LastActivityDate": "2014-10-16T03:06:21.330", "LastEditorUserId": "5987", "Id": "26395489", "CommentCount": "4", "CreationDate": "2014-10-16T02:55:14.560", "ParentId": "26395476", "Score": "3", "OwnerUserId": "5987", "LastEditDate": "2014-10-16T03:06:21.330"}, "26395492": {"PostTypeId": "2", "Body": "<p>Throwing an exception during <em>stack-unwinding</em> this will lead to <code>std::terminate</code> being called whose default action is to call <code>std::abort</code>.</p>\n<p><a href=\"https://www.cert.org/\" rel=\"nofollow\">CERT</a> has a good explanation in their <a href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/ERR33-CPP.+Destructors+must+not+throw+exceptions\" rel=\"nofollow\">ERR33-CPP. Destructors must not throw exceptions</a> document which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_26395476_26395492_0\">A destructor is very likely to be called during stack unwinding\n  resulting from an exception being thrown. <strong>If the destructor itself\n  throws an exception, having been called as the result of an exception\n  being thrown, then the function std::terminate() is called with the\n  default effect of calling std::abort()</strong>. This could provide the\n  opportunity for a denial-of-service attack. Hence, destructors must\n  satisfy the no-throw guarantee, that is, they must not throw an\n  exception if they themselves have been called as the result of an\n  exception being thrown.</p>\n</blockquote>\n<p>This is covered in the draft C++ standard section <code>15.2</code> <em>Constructors and destructors</em> which says:</p>\n<blockquote>\n<p id=\"so_26395476_26395492_1\">The process of calling destructors for automatic objects constructed\n  on the path from a try block to a throw-expression is called \u201cstack\n  unwinding.\u201d If a destructor called during stack unwinding exits with\n  an exception, std::terminate is called (15.5.1). [ Note: So\n  destructors should generally catch exceptions and not let them\n  propagate out of the destructor. \u2014end note ]</p>\n</blockquote>\n<p>Note that in C++11 destructors are specified implicitly <code>noexcept(true)</code> as long as none of the functions it calls allows exceptions. So in this case throwing from a destructor would call <code>std::terminate</code> regardless.</p>\n<p>From section <code>12.4</code> <em>Destructors</em>:</p>\n<blockquote>\n<p id=\"so_26395476_26395492_2\">A declaration of a destructor that does not have an\n  exception-specification is implicitly considered to have the same\n  exception-specification as an implicit declaration (15.4).</p>\n</blockquote>\n<p>and <code>15.4</code> says:</p>\n<blockquote>\n<p id=\"so_26395476_26395492_3\">An implicitly declared special member function (Clause 12) shall have\n  an exception-specification. If f is an implicitly declared default\n  constructor, copy constructor, move constructor, destructor, copy\n  assignment operator, or move assignment operator, its implicit\n  exception-specification specifies the type-id T if and only if T is\n  allowed by the exception-specification of a function directly invoked\n  by f\u2019s implicit definition; f shall allow all exceptions if any\n  function it directly invokes allows all exceptions, and f <strong>shall allow\n  no exceptions if every function it directly invokes allows no\n  exceptions.</strong></p>\n</blockquote>\n<p>Theoretically you could use <a href=\"http://en.cppreference.com/w/cpp/error/uncaught_exception\" rel=\"nofollow\">std::uncaught_exception</a> to detect <em>stack-unwinding</em> in the destructor but in <a href=\"http://www.gotw.ca/gotw/047.htm\" rel=\"nofollow\">GotW #47</a> Herb Sutter explains why this technique is not as useful as it seems.</p>\n<p>Although Herb has very recently proposed a fix in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4152.pdf\" rel=\"nofollow\">N4152: uncaught\n_exceptions</a></p>\n", "LastActivityDate": "2014-10-17T02:06:03.517", "LastEditorUserId": "1708801", "Id": "26395492", "CommentCount": "0", "CreationDate": "2014-10-16T02:55:51.483", "ParentId": "26395476", "Score": "4", "OwnerUserId": "1708801", "LastEditDate": "2014-10-17T02:06:03.517"}, "bq_ids": {"n4140": {"so_26395476_26395492_1": {"length": 29, "quality": 0.8055555555555556, "section_id": 3345}, "so_26395476_26395492_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 399}, "so_26395476_26395492_3": {"length": 49, "quality": 0.9423076923076923, "section_id": 3376}}, "n3337": {"so_26395476_26395492_1": {"length": 30, "quality": 0.8333333333333334, "section_id": 3215}, "so_26395476_26395492_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 390}, "so_26395476_26395492_3": {"length": 52, "quality": 1.0, "section_id": 3246}}}, "26395476": {"ViewCount": "167", "Body": "<p>I have read that it is not a good idea to throw from a destructor because of stack unwinding. I am not sure I understand that fully. So I tried the following example</p>\n<pre><code>struct foo\n{\n    ~foo()\n    {\n        throw 1;\n    }\n};\n\n\nstruct bar\n{\n    ~bar()\n    {\n        throw 2;\n    }\n};\n\nint main()\n{\n    try \n    {\n        foo a;\n        bar b;\n        throw 3;\n    }catch(int a)\n    {\n        std::cout &lt;&lt; a;\n    }\n}\n</code></pre>\n<p>Now I was expecting that the a would be 1 because first 3 is thrown then destructor of b is called which throws 2 and then destructor of a is called which throws 1. Apparently this is not the case and this might explain why its not a good idea to throw from destructors. My question is why was abort() called the destructor of b was called ? </p>\n", "AcceptedAnswerId": "26395489", "Title": "Why cant you throw from a destructor. Example", "CreationDate": "2014-10-16T02:52:54.053", "Id": "26395476", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-10-17T02:06:03.517", "Score": "3", "OwnerUserId": "990502", "Tags": "<c++><exception><destructor>", "AnswerCount": "4"}});