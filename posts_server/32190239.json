post_cb({"32190386": {"Id": "32190386", "PostTypeId": "2", "Body": "<p>It's not <em>inconsistent.</em> The existing behaviour is both easy to specify and easy to implement, and your compiler is implementing it correctly. See [lex.comment] in the standard.</p>\n<blockquote>\n<p id=\"so_32190239_32190386_0\">The characters <code>/*</code> start a comment, which terminates with the characters <code>*/</code>. These comments do not\n  nest. The characters <code>//</code> start a comment, which terminates with the next new-line character. If there is a\n  form-feed or a vertical-tab character in such a comment, only white-space characters shall appear between it\n  and the new-line that terminates the comment; no diagnostic is required. <em>[ Note:</em> The comment characters\n  <code>//</code>, <code>/*</code>, and <code>*/</code> have no special meaning within a <code>//</code> comment and are treated just like other characters.\n  Similarly, the comment characters <code>//</code> and <code>/*</code> have no special meaning within a <code>/*</code> comment. \u2014 <em>end note ]</em></p>\n</blockquote>\n<p>As you can see, <code>//</code> can be used to comment out both <code>/*</code> and <code>*/</code>. It's just that comments don't nest, so if the <code>//</code> is already inside a <code>/*</code>, then the <code>//</code> has no effect at all.</p>\n", "LastActivityDate": "2015-08-24T19:38:51.427", "CommentCount": "4", "CreationDate": "2015-08-24T19:38:51.427", "ParentId": "32190239", "Score": "4", "OwnerUserId": "481267"}, "bq_ids": {"n4140": {"so_32190239_32190386_0": {"length": 49, "quality": 0.875, "section_id": 5328}}, "n3337": {"so_32190239_32190386_0": {"length": 49, "quality": 0.875, "section_id": 5125}}, "n4659": {"so_32190239_32190386_0": {"length": 49, "quality": 0.875, "section_id": 6749}}}, "32190484": {"Id": "32190484", "PostTypeId": "2", "Body": "<p>When a comment starts, everything until the end of the comment is treated as a comment.</p>\n<p>So <code>zero // one */ two</code> all by itself could have <code>zero // one */</code> be the end of a <code>/* */</code> comment from a previous line, two <code>two</code> outside the comment, or it could be a new single-line comment that starts <code>// one */ two</code>, with <code>zero</code> out side the comment.</p>\n<p>As a theory why this was done, <code>//</code> is not a valid C token or token sequence.  So there are no programs with <code>//</code> outside of a comment or string in C.</p>\n<p>However, <code>//</code> within a comment would be legal.  So a header file containing:</p>\n<pre><code>/* this is a C style comment\n// with some cool\n// slashes */\n</code></pre>\n<p>would break if we made <code>//</code> comment out the trailing <code>*/</code>.  Within a <code>/* */</code> comment, <code>//</code> is ignored.  Compatibility with C was not to be broken for no good reason.</p>\n<p>And within a <code>//</code>, everything gets ignored until the end of the line.  No sneaky <code>/*</code> or allowed.</p>\n<p>The parsing rule is really easy -- start a comment, slurp and discard until you see the end token (either a newline, or a <code>*/</code> depending), then continue parsing.</p>\n<p>As C++ is not designed to be parsed by regular expressions, your difficulty parsing it with regular expressions was either not considered, or not considered important.</p>\n", "LastActivityDate": "2015-08-24T19:45:24.183", "CommentCount": "0", "CreationDate": "2015-08-24T19:45:24.183", "ParentId": "32190239", "Score": "0", "OwnerUserId": "1774667"}, "32190239": {"ViewCount": "148", "Body": "<p>So we know that</p>\n<pre><code>// This doesn't affect anything\n\n/*\nThis doesn't affect anything either\n*/\n\n/*\n/* /* /*\nThis doesn't affect anything\n*/\nThis does because comments aren't recursive\n\n/* /*\nThis doesn't affect anything\n*/ */\nThis throws an error because the second * / is unmatched since comments aren't recursive\n</code></pre>\n<p>I've heard that the reason they aren't recursive is because they would <a href=\"https://softwareengineering.stackexchange.com/questions/81072/why-do-most-programming-languages-not-nest-block-comments\">slow down the compiler</a>, and I guess that makes sense. However nowadays when I'm parsing c++ code in a higher level language (say Python), I can simply use the regular expression</p>\n<pre><code>\"\\/[\\/]+((?![\\n])[\\s\\S])*\\r*\\n\"\n</code></pre>\n<p>to match <code>// single line comments</code>, and use</p>\n<pre><code>\"\\/\\*((?!\\*\\/)[\\s\\S])*\\*\\/\"\n</code></pre>\n<p>to match <code>/* multiline comments */</code>, then loop through all single line comments, remove them, then loop through all multi-line comments and remove them. Or vice versa. But that's where I'm stuck. It seems that doing one or the other isn't sufficient, because:</p>\n<pre><code>// /*\nAn error is thrown because the /* is ignored\n*/\n\n/*\nThis doesn't affect things because of mysterious reasons\n// */\n</code></pre>\n<p>and</p>\n<pre><code>/*\nThis throws an error because the second * / is unmatched\n// */ */\n</code></pre>\n<p>What is the reason for this behavior? Is it also an artifact of the way the compilers parse things?  To be clear I don't want to change the behavior of c++, I would just like to know the reasoning behind the second set of examples behaving they way they do.</p>\n<p>Edit:</p>\n<p>So yes, to be more explicit, my question is why the following three (seemingly reasonable) ways of explaining this behavior don't work:</p>\n<ol>\n<li><p>Simply ignore all characters on a line after // regardless of whether they are /* or * /, even if you are in a multiline comment.</p></li>\n<li><p>Allow a / * or */ followed by a // to still have effect. </p></li>\n<li><p>Both of the above.</p></li>\n</ol>\n<p>I understand why nested comments aren't allowed, because they would require a stack and arbitrarily high amounts of memory. But these three cases would not.</p>\n<p>Edit again:</p>\n<p>If anyone is interested, here is the following code to extract comments of a c/c++ file in python following the correct commenting rules discussed here:</p>\n<pre><code>import re\ncommentScanner = re.Scanner([\n  (r\"\\/[\\/]+((?![\\n])[\\s\\S])*\\r*(\\n{1})?\", lambda scanner, token: (\"//\", token)),\n  (r\"\\/\\*((?!\\*\\/)[\\s\\S])*\\*\\/\", lambda scanner, token: (\"/* ... */\", token)),\n  (r\"[\\s\\S]\", lambda scanner, token: None)\n])\ncommentScanner.scan(\"fds a45fsa//kjl fds4325lkjfa/*jfds/\\nk\\lj\\/*4532jlfds5342a  l/*a/*b/*c\\n//fdsafa\\n\\r\\n/*jfd//a*/fd// fs54fdsa3\\r\\r//\\r/*\\r\\n2a\\n\\n\\nois\")\n</code></pre>\n", "AcceptedAnswerId": "32190386", "Title": "Why is commenting out multiline comments in c++ inconsistent?", "CreationDate": "2015-08-24T19:30:37.023", "Id": "32190239", "CommentCount": "27", "LastEditDate": "2017-04-12T07:31:17.257", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-24T21:28:16.570", "Score": "-1", "OwnerUserId": "2924421", "Tags": "<c++><regex><compiler-construction><comments>", "AnswerCount": "3"}, "32191196": {"Id": "32191196", "PostTypeId": "2", "Body": "<p>Yeah like everything inside a comment is just text, but when you remove the comment delimiter,<br>\nthe exposed text becomes available to be parsed again.<br>\nSo if part of that text had comment delimiter literals, they become parse-able as a new comment <em>delimiter</em>.  </br></br></p>\n<p>And its always a first come, first serve issue, i.e. left to right order.  </p>\n<p>It might be a little simplistic to think that parsing comments is simplistic.<br>\nThe fact is that quotes must be parsed at the very same time (both single/double) and whatever is first encountered comments/quote, is served first.  </br></p>\n<p>Finally, everything inside a comment being skipped means that if you remove the outter<br>\ncomment layer, everything remaining <em>not</em> a valid comment will be parsed as<br>\npart of the language. That means there is no certainty about any exposed comment format,<br>\nand the chances of getting a parse error is great, if not inevitable.  </br></br></br></p>\n<p>I believe also that C++ has a line continuation form for <code>//</code> style comments as well.<br>\nFor example:  </br></p>\n<pre><code>// single line continuation\\\ncontinuation               \\  \nend here \ncode\n</code></pre>\n<p>So the formula to parse C++ comments with regular expressions is that you have<br>\nto parse (match) every single character in the file.<br>\nIf you just go straight for the comments it <em>will</em> inject the match into<br>\nthe wrong place.  </br></br></br></p>\n<p>A good regex to parse comments is below. I originally got this off a Perl group<br>\nand slightly modified it for single line comment and continuation.<br>\nWith it you could remove comments or just find comments.   </br></br></p>\n<p>Raw regex:  </p>\n<pre><code>   # (/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/|//(?:[^\\\\]|\\\\\\n?)*?\\n)|(\"(?:\\\\[\\S\\s]|[^\"\\\\])*\"|'(?:\\\\[\\S\\s]|[^'\\\\])*'|[\\S\\s][^/\"'\\\\]*)\n\n\n   (                                # (1 start), Comments \n        /\\*                              # Start /* .. */ comment\n        [^*]* \\*+\n        (?: [^/*] [^*]* \\*+ )*\n        /                                # End /* .. */ comment\n     |  \n        //                               # Start // comment\n        (?: [^\\\\] | \\\\ \\n? )*?           # Possible line-continuation\n        \\n                               # End // comment\n   )                                # (1 end)\n|  \n   (                                # (2 start), Non - comments \n        \"\n        (?: \\\\ [\\S\\s] | [^\"\\\\] )*        # Double quoted text\n        \"\n     |  '\n        (?: \\\\ [\\S\\s] | [^'\\\\] )*        # Single quoted text\n        ' \n     |  [\\S\\s]                           # Any other char\n        [^/\"'\\\\]*                        # Chars which doesn't start a comment, string, escape,\n                                         # or line continuation (escape + newline)\n   )                                # (2 end)\n</code></pre>\n<p>Enhanced (preserve formatting), mostly used to <em>delete</em> comments.<br>\nUse multi-line mode:  </br></p>\n<pre><code>   # ((?:(?:^[ \\t]*)?(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/(?:[ \\t]*\\r?\\n(?=[ \\t]*(?:\\r?\\n|/\\*|//)))?|//(?:[^\\\\]|\\\\(?:\\r?\\n)?)*?(?:\\r?\\n(?=[ \\t]*(?:\\r?\\n|/\\*|//))|(?=\\r?\\n))))+)|(\"(?:\\\\[\\S\\s]|[^\"\\\\])*\"|'(?:\\\\[\\S\\s]|[^'\\\\])*'|(?:\\r?\\n|[\\S\\s])[^/\"'\\\\\\s]*)\n\n   (                                # (1 start), Comments \n        (?:\n             (?: ^ [ \\t]* )?                  # &lt;- To preserve formatting\n             (?:\n                  /\\*                              # Start /* .. */ comment\n                  [^*]* \\*+\n                  (?: [^/*] [^*]* \\*+ )*\n                  /                                # End /* .. */ comment\n                  (?:                              # &lt;- To preserve formatting \n                       [ \\t]* \\r? \\n                                      \n                       (?=\n                            [ \\t]*                  \n                            (?: \\r? \\n | /\\* | // )\n                       )\n                  )?\n               |  \n                  //                               # Start // comment\n                  (?:                              # Possible line-continuation\n                       [^\\\\] \n                    |  \\\\ \n                       (?: \\r? \\n )?\n                  )*?\n                  (?:                              # End // comment\n                       \\r? \\n                               \n                       (?=                              # &lt;- To preserve formatting\n                            [ \\t]*                          \n                            (?: \\r? \\n | /\\* | // )\n                       )\n                    |  (?= \\r? \\n )\n                  )\n             )\n        )+                               # Grab multiple comment blocks if need be\n   )                                # (1 end)\n\n|                                 ## OR\n\n   (                                # (2 start), Non - comments \n        \"\n        (?: \\\\ [\\S\\s] | [^\"\\\\] )*        # Double quoted text\n        \"\n     |  '\n        (?: \\\\ [\\S\\s] | [^'\\\\] )*        # Single quoted text\n        ' \n     |  (?: \\r? \\n | [\\S\\s] )            # Linebreak or Any other char\n        [^/\"'\\\\\\s]*                      # Chars which doesn't start a comment, string, escape,\n                                         # or line continuation (escape + newline)\n   )                                # (2 end)\n</code></pre>\n", "LastEditorUserId": "557597", "LastActivityDate": "2015-08-24T20:42:03.760", "Score": "1", "CreationDate": "2015-08-24T20:29:29.343", "ParentId": "32190239", "CommentCount": "0", "OwnerUserId": "557597", "LastEditDate": "2015-08-24T20:42:03.760"}});