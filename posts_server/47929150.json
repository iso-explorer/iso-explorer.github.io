post_cb({"bq_ids": {"n4140": {"so_47929150_47931046_10": {"length": 31, "quality": 0.6888888888888889, "section_id": 5789}, "so_47929150_47931046_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 5785}}, "n3337": {"so_47929150_47931046_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 5558}, "so_47929150_47931046_10": {"length": 31, "quality": 0.6888888888888889, "section_id": 5562}}, "n4659": {"so_47929150_47931046_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 7242}, "so_47929150_47931046_10": {"length": 31, "quality": 0.6888888888888889, "section_id": 7246}}}, "47929217": {"Id": "47929217", "PostTypeId": "2", "Body": "<p>Answer:  You can't.</p>\n<p>The minimum amount you can write to a file (or read from it), is a <code>char</code> or <code>unsigned char</code>.  For all practical purposes, a char has exactly eight bits.</p>\n<p>You are going to need to have a one char buffer, and a count of the number of bits it holds.  When that number reaches 8, you need to write it out, and reset the count to 0.  You will also need a way to flush the buffer at the end.  (Not that you <em>cannot</em> write 22 bits to a file - you can only write 16 or 24.  You will need some way to mark which bits at the end are unused.)</p>\n<p>Something like:</p>\n<pre><code>struct BitBuffer {\n    FILE* file; // Initialization skipped.\n    unsigned char buffer = 0;\n    unsigned count = 0;\n\n    void outputBit(unsigned char bit) {\n         buffer &lt;&lt;= 1;         // Make room for next bit.\n         if (bit) buffer |= 1; // Set if necessary.\n         count++;              // Remember we have added a bit.\n         if (count == 8) {\n             fwrite(&amp;buffer, sizeof(buffer), 1, file); // Error handling elided.\n             buffer = 0;\n             count = 0;\n         }\n    }\n};\n</code></pre>\n", "LastEditorUserId": "771073", "LastActivityDate": "2017-12-21T17:16:13.560", "Score": "4", "CreationDate": "2017-12-21T16:40:07.367", "ParentId": "47929150", "CommentCount": "2", "OwnerUserId": "771073", "LastEditDate": "2017-12-21T17:16:13.560"}, "47931046": {"Id": "47931046", "PostTypeId": "2", "Body": "<p>The OP asked:</p>\n<blockquote>\n<p id=\"so_47929150_47931046_0\">How can I write bit-by-bit each character of this result as a binary to \".dat\" file? (not as string)</p>\n</blockquote>\n<p>You can not and here is why...</p>\n<hr>\n<blockquote>\n<p id=\"so_47929150_47931046_1\"><strong>Memory model</strong></p>\n<p id=\"so_47929150_47931046_2\">Defines the semantics of a computer memory storage for the purpose of C++ abstract machine.</p>\n<p id=\"so_47929150_47931046_3\">The memory available to a C++ program is one or more contiguous sequences of <em><code>bytes</code></em>. Each byte in memory has a unique <em>address</em>.</p>\n<p id=\"so_47929150_47931046_4\"><strong>Byte</strong></p>\n<p id=\"so_47929150_47931046_5\">A <em><code>byte</code></em> is the smallest addressable unit of memory. It is defined as a contiguous sequence of bits, large enough to hold the value of any UTF-8 code unit (256 distinct values) and of <code>(since C++14)</code> any member of the <em>basic execution character set</em> (the 96 characters that are required to be <code>single-byte</code>). Similar to C, C++ supports <code>bytes</code> of sizes 8 bits and greater.</p>\n<p id=\"so_47929150_47931046_6\">The types <code>char</code>, <code>unsigned char</code>, and <code>signed char</code> use one byte for both storage and value representation. The number of bits in a byte is accessible as <code>CHAR_BIT</code> or <code>std::numeric_limits&lt;unsigned char&gt;::digits</code>.</p>\n</blockquote>\n<p>Compliments of <code>cppreference.com</code></p>\n<p>You can find this page here: <a href=\"http://en.cppreference.com/w/cpp/language/memory_model\" rel=\"nofollow noreferrer\">cppreference:memory model</a></p>\n<hr>\n<p>This comes from the 2017-03-21: standard</p>\n<blockquote>\n<p id=\"so_47929150_47931046_7\">\u00a9ISO/IEC N4659</p>\n<p id=\"so_47929150_47931046_8\"><strong>4.4 The C++ memory model</strong> <strong>[intro.memory]</strong></p>\n<ol>\n<li>The fundamental storage unit in the C++ memory model is the <em>byte</em>. A byte is at least large enough to contain any member of the basic execution character set (5.3) and the eight-bit code units of the Unicode UTF-8 encoding form and is composed of a contiguous sequence of bits,<sup>4</sup> the number of which is implementation-defined. The least significant bit is called the <em>low-order bit</em>; the most significant bit is called the <em>high-order bit</em>. The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte has a unique address.</li>\n<li>[ <em>Note</em>: The representation of types is described in 6.9. \u2014<em>end note</em> ]</li>\n<li>A <em>memory location</em> is either an object of scalar type or a maximal sequence of adjacent bit-fields all having nonzero width. [ <em>Note</em>: Various features of the language, such as references and virtual functions, might involve additional memory locations that are not accessible to programs but are managed by the implementation. \u2014<em>end note</em> ] Two or more threads of execution (4.7) can access separate memory locations without interfering\n  with each other.</li>\n<li>[ <em>Note</em>: Thus a bit-field and an adjacent non-bit-field are in separate memory locations, and therefore can be concurrently updated by two threads of execution without interference. The same applies to two bit-fields, if one is declared inside a nested struct declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field declaration. It is not safe to concurrently update two bit-fields in the same struct if all fields between them are also bit-fields of nonzero width. \u2014<em>end note</em> ]</li>\n<li><p id=\"so_47929150_47931046_9\">[ <em>Example</em>: A structure declared as</p>\n<pre><code>struct {\n    char a;\n    int b:5,\n    c:11,\n    :0,\n    d:8;\n    struct {int ee:8;} e;\n}\n</code></pre>\n<p id=\"so_47929150_47931046_10\">contains four separate memory locations: The field a and bit-fields d and e.ee are each separate memory\n  locations, and can be modified concurrently without interfering with each other. The bit-fields b and c\n  together constitute the fourth memory location. The bit-fields b and c cannot be concurrently modified, but\n  b and a, for example, can be. \u2014<em>end example</em> ]\n  <hr>\n<sup> 4) The number of bits in a byte is reported by the macro <strong>CHAR_BIT</strong> in the header <code>&lt;climits&gt;</code>.</sup></hr></p></li>\n</ol>\n</blockquote>\n<p>This version of the standard can be found here: \n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">www.open-std.org</a> section <code>\u00a7 4.4</code>  on pages 8 &amp; 9.</p>\n<hr>\n<p>The smallest possible memory module that can be written to in a program is 8 contiguous bits or more for a standard byte. Even with bit fields, the <code>1 byte</code> requirement still holds. You can manipulate, toggle, set, individual bits within a <code>byte</code> but you can not write individual <code>bits</code>.</p>\n<p>What can be done is to have a <code>byte</code> buffer with a count of bits written. When your required bits are written you will need to have the rest of the unused bits marked as <code>padding</code> or <code>un-used buffer bits</code>. </p>\n<p><strong>Edit</strong></p>\n<p><strong>[<em>Note:</em>]</strong> -- When using <code>bit fields</code> or <code>unions</code> one thing that you must take into consideration is the <code>endian</code> of the specific architecture.</p>\n</hr></hr></hr>", "LastEditorUserId": "1757805", "LastActivityDate": "2017-12-21T19:57:02.647", "Score": "0", "CreationDate": "2017-12-21T18:50:41.080", "ParentId": "47929150", "CommentCount": "0", "OwnerUserId": "1757805", "LastEditDate": "2017-12-21T19:57:02.647"}, "47929150": {"ViewCount": "111", "Body": "<p>I'm trying to implement a Huffman tree.</p>\n<p>Content of my simple .txt file that I want to do a simple test:</p>\n<pre><code>aaaaabbbbccd\n</code></pre>\n<p>Frequencies of characters: a:5, b:4, c:2, d:1</p>\n<p>Code Table: (Data type of <strong>1</strong>s and <strong>0</strong>s: <strong>string</strong>)</p>\n<pre><code>a:0\nd:100\nc:101\nb:11         \n</code></pre>\n<p>Result that I want to write as binary: (22 bits)</p>\n<pre><code>0000011111111101101100          \n</code></pre>\n<p>How can I write <strong><em>bit-by-bit</em></strong> each character of this result as a binary to \".dat\" file? (not as string)</p>\n", "AcceptedAnswerId": "47931046", "Title": "Writing bits to file?", "CreationDate": "2017-12-21T16:35:09.880", "LastActivityDate": "2017-12-21T19:57:02.647", "CommentCount": "6", "LastEditDate": "2017-12-21T19:03:32.343", "PostTypeId": "1", "LastEditorUserId": "44729", "Id": "47929150", "Score": "0", "OwnerUserId": "8498981", "Tags": "<c++><binary><ofstream><huffman-code>", "AnswerCount": "2"}});