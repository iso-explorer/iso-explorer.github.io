post_cb({"17354693": {"ParentId": "17354679", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Because template arguments must be evaluated at compile time, and the compiler won't know the address of a local variable until run-time (in order to bind a reference to an object, the compiler needs to know the address of that object).</p>\n<p>Notice, that the C++11 Standard tells exactly what non-type template arguments can be provided in paragraph 14.3.2/1:</p>\n<blockquote>\n<p id=\"so_17354679_17354693_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<p id=\"so_17354679_17354693_1\">\u2014 for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression\n  (5.19) of the type of the <em>template-parameter</em>; or</p>\n<p id=\"so_17354679_17354693_2\">\u2014 the name of a non-type template-parameter; or</p>\n<p id=\"so_17354679_17354693_3\">\u2014 a constant expression (5.19) that designates the address of an object with static storage duration and\n  external or internal linkage or a function with external or internal linkage, including function templates\n  and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as\n  &amp; <em>id-expression</em>, except that the &amp; may be omitted if the name refers to a function or array and shall\n  be omitted if the corresponding template-parameter is a reference; or</p>\n<p id=\"so_17354679_17354693_4\">\u2014 a constant expression that evaluates to a null pointer value (4.10); or</p>\n<p id=\"so_17354679_17354693_5\">\u2014 a constant expression that evaluates to a null member pointer value (4.11); or</p>\n<p id=\"so_17354679_17354693_6\">\u2014 a pointer to member expressed as described in 5.3.1; or</p>\n<p id=\"so_17354679_17354693_7\">\u2014 an address constant expression of type <code>std::nullptr_t</code>. </p>\n</blockquote>\n<p>As you can see, local variables are not in this list.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-06-27T23:11:12.780", "Id": "17354693", "Score": "6", "CreationDate": "2013-06-27T23:06:10.070", "LastActivityDate": "2013-06-27T23:11:12.780"}, "17354726": {"ParentId": "17354679", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The \"value\" of a template needs to be present at compile time.</p>\n<pre><code>template&lt;int x&gt; struct X {};\n</code></pre>\n<p>Even if you do not bind a reference or pass a pointer here, the compiler must know the value of the passed elements at compile time.</p>\n<p>Replacing <code>int &amp;x</code> with <code>int x</code> is on purpose here. Stuff about int&amp; is answered correctly. I just wanted to point that it applies to all non-typed template arguments. </p>\n<ul>\n<li>The \"value\" of a reference is a reference (implementation dependent actually a pointer in most of them)\n<ul>\n<li>The address of the object must be known at compile time</li>\n</ul></li>\n<li>The \"value\" of a pointer <code>template&lt;int*&gt;</code> is an address...\n<ul>\n<li>... which in turn must be known here, too, of course.</li>\n</ul></li>\n<li>The \"value\" of a value-type is the value itself which also must be known at compile time</li>\n</ul>\n<p>\u00a0</p>\n<pre><code>X&lt;local_var&gt; x; // will not work, local_var does not exist at compile time\nX&lt;1&gt; x; // works since 1 is known\n</code></pre>\n<p>I just wanted to (in addition to Andy's answer) prevent any conclusions that would suggest to use a value type instead of a reference.</p>\n", "OwnerUserId": "951423", "LastEditorUserId": "963864", "LastEditDate": "2013-06-28T00:25:04.660", "Id": "17354726", "Score": "0", "CreationDate": "2013-06-27T23:09:55.747", "LastActivityDate": "2013-06-28T00:25:04.660"}, "17354679": {"CommentCount": "1", "AcceptedAnswerId": "17354693", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2013-06-27T23:05:05.257", "LastActivityDate": "2013-06-28T00:25:04.660", "LastEditDate": "2013-06-27T23:07:14.933", "ViewCount": "355", "FavoriteCount": "1", "Title": "local variable as a non-typename argument", "Id": "17354679", "Score": "6", "Body": "<p>Why is it illegal to use a local variable as a non-type argument?</p>\n<p>For example, in the next code <code>local_var</code> cannot be argument to <code>X</code>.</p>\n<pre><code>template&lt;int&amp; x&gt; struct X {};\n\nvoid f(int local_var)\n{\n    X&lt;local_var&gt; x;\n}\n</code></pre>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "1003615", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17354679_17354693_1": {"section_id": 87, "quality": 0.9090909090909091, "length": 10}, "so_17354679_17354693_3": {"section_id": 87, "quality": 0.975609756097561, "length": 40}, "so_17354679_17354693_6": {"section_id": 87, "quality": 0.8, "length": 4}, "so_17354679_17354693_7": {"section_id": 87, "quality": 1.0, "length": 5}, "so_17354679_17354693_4": {"section_id": 87, "quality": 0.8571428571428571, "length": 6}, "so_17354679_17354693_5": {"section_id": 87, "quality": 0.875, "length": 7}, "so_17354679_17354693_0": {"section_id": 87, "quality": 1.0, "length": 5}}, "n3337": {"so_17354679_17354693_1": {"section_id": 82, "quality": 0.9090909090909091, "length": 10}, "so_17354679_17354693_3": {"section_id": 82, "quality": 0.975609756097561, "length": 40}, "so_17354679_17354693_6": {"section_id": 82, "quality": 0.8, "length": 4}, "so_17354679_17354693_7": {"section_id": 5947, "quality": 1.0, "length": 5}, "so_17354679_17354693_4": {"section_id": 36, "quality": 0.8571428571428571, "length": 6}, "so_17354679_17354693_5": {"section_id": 82, "quality": 0.875, "length": 7}, "so_17354679_17354693_0": {"section_id": 82, "quality": 1.0, "length": 5}}, "n4659": {"so_17354679_17354693_1": {"section_id": 90, "quality": 0.6363636363636364, "length": 7}, "so_17354679_17354693_4": {"section_id": 7690, "quality": 0.7142857142857143, "length": 5}, "so_17354679_17354693_5": {"section_id": 7689, "quality": 0.625, "length": 5}}}});