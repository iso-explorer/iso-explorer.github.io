post_cb({"bq_ids": {"n4140": {"so_25653647_25653843_1": {"length": 48, "quality": 0.96, "section_id": 489}, "so_25653647_25653843_0": {"length": 21, "quality": 1.0, "section_id": 5492}}, "n3337": {"so_25653647_25653843_1": {"length": 48, "quality": 0.96, "section_id": 480}, "so_25653647_25653843_0": {"length": 21, "quality": 1.0, "section_id": 5278}}, "n4659": {"so_25653647_25653843_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 6926}}}, "25653843": {"Id": "25653843", "PostTypeId": "2", "Body": "<p>This is a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58751\" rel=\"nofollow\">GCC bug</a>. \u00a77.3.3 [namespace.udecl]/p3 requires that </p>\n<blockquote>\n<p id=\"so_25653647_25653843_0\">In a <em>using-declaration</em> used as a <em>member-declaration</em>, the\n  <em>nested-name-specifier</em> shall name a base class of the class being defined. If such a <em>using-declaration</em> names a constructor, the\n  <em>nested-name-specifier</em> shall name a direct base class of the class being defined...</p>\n</blockquote>\n<p><code>A</code> is a direct base of <code>B</code>, so <code>using A::A;</code> is allowed.</p>\n<p>The standard specifies that (\u00a712.9 [class.inhctor]/p8):</p>\n<blockquote>\n<p id=\"so_25653647_25653843_1\">An implicitly-defined inheriting constructor performs the set of\n  initializations of the class that would be performed by a user-written\n  <code>inline</code> constructor for that class with a <em>mem-initializer-list</em> whose\n  only <em>mem-initializer</em> has a <em>mem-initializer-id</em> that names the base\n  class denoted in the nested-name-specifier of the using-declaration\n  and an expression-list as specified below, and where the\n  compound-statement in its function body is empty (12.6.2). If that\n  user-written constructor would be ill-formed, the program is\n  ill-formed. Each expression in the expression-list is of the form\n  <code>static_cast&lt;T&amp;&amp;&gt;(p)</code>, where <code>p</code> is the name of the corresponding\n  constructor parameter and <code>T</code> is the declared type of <code>p</code>.</p>\n</blockquote>\n<p>Thus the corresponding user-written constructor is</p>\n<pre><code>B::B(int x) : A(static_cast&lt;int&amp;&amp;&gt;(x)) { }\n</code></pre>\n<p>which is well-formed.</p>\n", "LastActivityDate": "2014-09-03T21:20:05.647", "CommentCount": "0", "CreationDate": "2014-09-03T21:20:05.647", "ParentId": "25653647", "Score": "4", "OwnerUserId": "2756719"}, "25653742": {"Id": "25653742", "PostTypeId": "2", "Body": "<p>It appears to compile with clang, but not gcc (at least on my machine). Even with, gcc, however, the <a href=\"http://ideone.com/Q5m3ll\" rel=\"nofollow\">code compiles and works fine</a> if you simply add a <code>explicit A()</code> constructor to the base class.</p>\n<p><strong>EDIT</strong> Apparently, as pointed out in the comment by @T.C., this is a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58751\" rel=\"nofollow\">known bug</a> in GCC.</p>\n", "LastActivityDate": "2014-09-03T21:12:20.830", "CommentCount": "0", "CreationDate": "2014-09-03T21:12:20.830", "ParentId": "25653647", "Score": "1", "OwnerUserId": "125405"}, "25653647": {"ViewCount": "207", "Body": "<p>I'm trying to compile the following simple code using g++ 4.9.0:</p>\n<pre><code>struct A {\n    explicit A(int x) { }\n};\n\nstruct B : public virtual A {\n    using A::A;\n};\n\nint main(int argc, char** argv) {\n    B b(0);\n    return 0;\n}\n</code></pre>\n<p>But I get the following error:</p>\n<pre><code>$ g++ -std=c++11 main.cpp\nmain.cpp: In function \u2018int main(int, char**)\u2019:\nmain.cpp:10:10: error: use of deleted function \u2018B::B(int)\u2019\n     B b(0);\n          ^\nmain.cpp:6:14: note: \u2018B::B(int)\u2019 is implicitly deleted because the default definition would be ill-formed:\n     using A::A;\n              ^\nmain.cpp:6:14: error: no matching function for call to \u2018A::A()\u2019\nmain.cpp:6:14: note: candidates are:\nmain.cpp:2:14: note: A::A(int)\n     explicit A(int x) { }\n              ^\nmain.cpp:2:14: note:   candidate expects 1 argument, 0 provided\nmain.cpp:1:8: note: constexpr A::A(const A&amp;)\n struct A {\n        ^\nmain.cpp:1:8: note:   candidate expects 1 argument, 0 provided\nmain.cpp:1:8: note: constexpr A::A(A&amp;&amp;)\nmain.cpp:1:8: note:   candidate expects 1 argument, 0 provided\n</code></pre>\n<p>Am I doing something wrong? Is it a compiler bug?</p>\n", "AcceptedAnswerId": "25653843", "Title": "Why can't I inherit the constructors of a virtual base?", "CreationDate": "2014-09-03T21:04:52.147", "Id": "25653647", "CommentCount": "3", "LastEditDate": "2014-09-03T21:17:26.957", "PostTypeId": "1", "LastEditorUserId": "3235496", "LastActivityDate": "2014-09-03T21:20:05.647", "Score": "2", "OwnerUserId": "565635", "Tags": "<c++><gcc4.9>", "AnswerCount": "2"}});