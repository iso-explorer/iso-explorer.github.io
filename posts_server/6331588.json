post_cb({"bq_ids": {"n4140": {"so_6331588_22031971_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 6182}}, "n3337": {"so_6331588_22031971_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5943}}, "n4659": {"so_6331588_22031971_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 7684}}}, "6491414": {"Id": "6491414", "PostTypeId": "2", "Body": "<p>As several have already said, and I want to add only one thing, sizeof is an operator taking either an expression or a cast expression. \nFor this reason I took the habit to write paranthesis to a sizeof <strong>only</strong> if it is a cast expression.</p>\n<pre><code> char *arr;\n struct xxx { ... } v;\n</code></pre>\n<p>I will write</p>\n<pre><code>sizeof arr \nsizeof v\n</code></pre>\n<p>but </p>\n<pre><code>sizeof (struct xxx)       /* Note the space after the sizeof, it's important */\nsizeof (char *)\n</code></pre>\n<p>I do the same with <code>return</code> no parenthesis, as it is not a function call, and if I put parenthesis it's because the expression following needs them.</p>\n", "LastActivityDate": "2011-06-27T10:18:26.593", "Score": "1", "CreationDate": "2011-06-27T10:18:26.593", "ParentId": "6331588", "CommentCount": "0", "OwnerUserId": "146377"}, "6331639": {"Id": "6331639", "PostTypeId": "2", "Body": "<p>In C then the array is decaying to a pointer, because of the different specification of the comma operator with relation to rvalues and lvalues (not the only place such a difference can be found). In C++ then the array stays an array, yielding the correct result.</p>\n", "LastActivityDate": "2011-06-13T14:16:01.260", "Score": "23", "CreationDate": "2011-06-13T14:16:01.260", "ParentId": "6331588", "CommentCount": "0", "OwnerUserId": "298661"}, "6331679": {"Id": "6331679", "PostTypeId": "2", "Body": "<p>In C, comma operator doesn't produce an lvalue, consequently the array <code>arr</code> which is an lvalue <em>decays</em> into a pointer type which is a rvalue (in this case). So <code>sizeof(0,arr)</code> becomes equivalent to <code>sizeof(char*)</code>, due to <em>lvalue-to-rvalue</em> conversion.</p>\n<p>But in C++, comma operator produces an lvalue. There is no <em>lvalue-to-rvalue</em> conversion. So  <code>sizeof(0,arr)</code> remains same, which is equivalent to <code>sizeof(char[100])</code>.</p>\n<p>By the way, <code>sizeof</code> is not a function, its an operator. So the following is completely valid C++ (and C, if you imagine <code>printf</code> instead of <code>cout</code>):</p>\n<pre><code>int a[100], b[200], c[300], d[400];\ncout &lt;&lt; sizeof(a,b,c,d) &lt;&lt; endl;\n</code></pre>\n<p>Demo : <a href=\"http://www.ideone.com/CtEhn\" rel=\"noreferrer\">http://www.ideone.com/CtEhn</a></p>\n<p>You might think that I've passed 4 operands to <code>sizeof</code> but that is wrong. <code>sizeof</code> operates on <em>the result</em> of the comma operators. And its because of the many comma operators you see many operands. </p>\n<p>4 operands &lt;=&gt; 3 comma operators; just like in <code>1+2+3+4</code>, there're 3 operators, 4 operands.</p>\n<p>The above is equivalent to the following (valid in C++0x):</p>\n<pre><code>auto &amp; result = (a,b,c,d); //first all comma operators operate on the operands.\ncout &lt;&lt; sizeof (result) &lt;&lt; endl; //sizeof operates on the result\n</code></pre>\n<p>Demo : <a href=\"http://www.ideone.com/07VNf\" rel=\"noreferrer\">http://www.ideone.com/07VNf</a></p>\n<p>So its the <em>comma</em> operator which makes you <em>feel</em> that there are many <em>arguments</em>. Here <em>comma</em> is an operator, but in function call, <em>comma</em> is NOT an operator, its simply argument separator.</p>\n<pre><code>function(a,b,c,d); //here comma acts a separator, not operator.\n</code></pre>\n<p>So <code>sizeof(a,b,c,d)</code> operates on the <em>type</em> of the result of <code>,</code> operators, exactly in the same way, <code>sizeof(1+2+3+4)</code> operates on the <em>type</em> of the result of <code>+</code> operators.</p>\n<p>Also note that you <strong>cannot</strong> write <code>sizeof(int, char, short)</code>, precisely because <em>comma</em> operator cannot operate on  <em>types</em>. It operates on <em>value</em> only.  I think, <code>sizeof</code> is the only operator in C and C++, which can operate on <em>types</em> as well. In C++, there is one more operator which can operates on <em>types</em>. Its name is <code>typeid</code>.</p>\n", "LastEditorUserId": "485561", "LastActivityDate": "2011-11-25T05:34:43.787", "Score": "42", "CreationDate": "2011-06-13T14:19:55.417", "ParentId": "6331588", "CommentCount": "3", "LastEditDate": "2011-11-25T05:34:43.787", "OwnerUserId": "415784"}, "22031971": {"Id": "22031971", "PostTypeId": "2", "Body": "<p>The best way to see what could be going on here is look at the grammar in the standard. If we look at the draft C99 standard section <code>6.5.3</code> <em>Unary operators</em> paragraph <em>1</em> we can see that the grammar for sizeof is:</p>\n<pre><code>sizeof unary-expression\nsizeof ( type-name )\n</code></pre>\n<p>So the second one does not apply but how does the <code>sizeof unary-expression</code> apply in this case? If we look at section <code>A.2.1</code> <em>Expressions</em> from the draft standard and work through the grammar like so:</p>\n<pre><code>unary-expression -&gt; postfix-expression -&gt; primary-expression -&gt; ( expression )\n</code></pre>\n<p>we get the parenthesizes around an <em>expression</em> and now we just have to look at the grammar for <em>comma operator</em> from section <code>6.5.17</code> <em>Comma operator</em> and we see:</p>\n<pre><code>expression:\n  assignment-expression\n  expression , assignment-expression\n</code></pre>\n<p>So we have now have:</p>\n<pre><code>sizeof( expression , assignment-expression )\n                   ^\n                   |\n                   comma operator\n</code></pre>\n<p>both <em>expression</em> and <em>assignment-expression</em> can take us to <em>primary-expression</em> which has the following grammar:</p>\n<pre><code>primary-expression:\n  identifier\n  constant\n  string-literal\n  ( expression )\n</code></pre>\n<p>and <code>0</code> is a <em>constant</em> and <code>arr</code> is an <em>identifier</em> so we have:</p>\n<pre><code> sizeof( constant , identifier )\n</code></pre>\n<p>So what does the <em>comma operator</em> do here? Section <code>6.5.17</code> paragraph <em>2</em> says:</p>\n<blockquote>\n<p id=\"so_6331588_22031971_0\">The left operand of a comma operator is evaluated as a void expression; there is a\n  sequence point after its evaluation. Then the right operand is evaluated; the result has its type and value.<sup>97)</sup></p>\n</blockquote>\n<p>since the comma operator is not one of the exceptions where a array is not converted to a pointer it yields a pointer(<em>this is covered in section</em> <code>6.3.2.1</code> <em>Lvalues, arrays, and function designators</em>) which means we end up with:</p>\n<pre><code>sizeof( char * )\n</code></pre>\n<p>In <em>C++</em> the grammar is pretty similar so we end in the same place but the comma operators works differently. The C++ draft standard section <code>5.18</code> <em>Comma operator</em> says:</p>\n<blockquote>\n<p id=\"so_6331588_22031971_1\">[...]The type and value of the result are the type and value of the right operand; the result is of the same value category as its right operand[...]</p>\n</blockquote>\n<p>so and <em>array-to-pointer</em> conversion is not not required and so we end up with:</p>\n<pre><code>sizeof( char[100] ) \n</code></pre>\n", "LastActivityDate": "2014-02-26T04:45:27.783", "Score": "2", "CreationDate": "2014-02-26T04:45:27.783", "ParentId": "6331588", "CommentCount": "0", "OwnerUserId": "1708801"}, "6331750": {"Id": "6331750", "PostTypeId": "2", "Body": "<p>It is a comma operator. And the difference you are talking about has absolutely nothing to do with <code>sizeof</code>. The difference is really in lvalue-to-rvalue, array-to-pointer and similar decay behaviors between C and C++ languages. </p>\n<p>C language is rather trigger-happy in this regard: arrays decay to pointers practically immediately (with the exception of very few specific contexts), which is why the result of <code>0, arr</code> expression has <code>char *</code> type. It is equivalent to <code>0, (char *) arr</code>. </p>\n<p>In C++ language arrays preserve they \"arrayness\" much longer. When used in the context of <code>,</code> operator arrays don't decay to pointers (and lvalues do not decay to rvalues), which is why in C++ the type of <code>0, arr</code> expression is still <code>char[100]</code>.</p>\n<p>This is what explains the difference in <code>sizeof</code> behavior in that example. <code>?:</code> operator is another example of an operator that demonstrates the similar difference in decay behavior, i.e. <code>sizeof(0 ? arr : arr)</code> will give you different results in C and C++. Basically, it all stems from the fact that C operators don't usually preserve the lvalueness of their operands. A lot of operators can be used to demonstrate this behavior.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2011-06-13T17:23:59.657", "Score": "6", "CreationDate": "2011-06-13T14:25:58.303", "ParentId": "6331588", "CommentCount": "1", "LastEditDate": "2011-06-13T17:23:59.657", "OwnerUserId": "187690"}, "6331588": {"ViewCount": "1863", "Body": "<p>In C.1.3 of the C++ IS (2003. It's in the C++11 IS, too), the standard points out a difference between ISO C and C++; namely, for</p>\n<pre><code>char arr[100];\n</code></pre>\n<p><code>sizeof(0, arr)</code> returns <code>sizeof(char*)</code> in C, but <code>100</code> in C++.</p>\n<p>I can find no documentation for <code>sizeof</code> taking two arguments. The obvious fallback is the comma operator, but I don't think so: <code>sizeof(arr)</code> in C is <code>100</code>; <code>sizeof(0, arr)</code> is <code>sizeof(char*)</code>. Both <code>sizeof(0, arr)</code> and <code>sizeof(arr)</code> are <code>100</code> in C++.</p>\n<p>I may be missing the whole point of the IS in this context. Can anyone help? This is similar to a question discussed back in '09, but no one referred to the IS, and I don't think the correct answer was given.</p>\n<hr>\n<p><strong>Edit</strong>: Actually, the IS is talking about the comma operator. So, for some reason <code>(0, arr)</code> returns a <code>char*</code> in C, but a <code>char[100]</code> in C++. Why?</p>\n</hr>", "AcceptedAnswerId": "6331639", "Title": "sizeof taking two arguments", "CreationDate": "2011-06-13T14:11:44.893", "Id": "6331588", "CommentCount": "4", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2011-08-02T09:19:37.723", "LastEditorUserId": "415784", "LastActivityDate": "2014-02-26T04:45:27.783", "Score": "32", "OwnerUserId": "785937", "Tags": "<c++><c><arrays><pointers><comma-operator>", "AnswerCount": "7"}, "6331994": {"Id": "6331994", "PostTypeId": "2", "Body": "<p><code>sizeof</code> doesn't take two arguments.  But it's not a function, either,\nso the <code>(...)</code> don't delimit function arguments, they're just an\noptional part of the syntax, and enforce grouping.  When you write\n<code>sizeof(0, arr)</code>, the argument to <code>sizeof</code> is the single expression <code>0,\narr</code>.  A single expression with a comma operator, which evaluates the\nexpression to the left of the comma, throws out its value (but not its\nside effects), then evaluates the expression to the right of the comma,\nand uses its value as the value of the complete expression.</p>\n<p>I'm not sure about C, but this could be a difference between the\nlangauges.  In C++, the array-to-pointer conversion doesn't occur unless\nit is needed; in C, if I recall correctly, the standard says that it\nalways takes place except in certain contexts.  Including as the\noperator of <code>sizeof</code>.  In this case, since the comma operator doesn't\nhave an constraints with regards to the types of its operands, the\narray-to-pointer conversion doesn't take place in C++.  In C, an\noperatand of the comma operator isn't listed in the exceptions, so the\narray-to-pointer conversion does take place.  (In this case, the array\nis an operand of the comma operator, and not of <code>sizeof</code>.)</p>\n", "LastActivityDate": "2011-06-13T14:44:58.140", "Score": "3", "CreationDate": "2011-06-13T14:44:58.140", "ParentId": "6331588", "CommentCount": "0", "OwnerUserId": "649665"}, "6331663": {"Id": "6331663", "PostTypeId": "2", "Body": "<p>This is not <code>sizeof</code> taking two arguments. <code>sizeof</code> is an operator, not a function. </p>\n<p>Consider that <code>(0, arr)</code> is an expression using the comma operator, and everything else falls into place.</p>\n", "LastActivityDate": "2011-06-13T14:18:32.367", "Score": "5", "CreationDate": "2011-06-13T14:18:32.367", "ParentId": "6331588", "CommentCount": "3", "OwnerUserId": "560648"}});