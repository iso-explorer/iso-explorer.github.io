post_cb({"10940711": {"Id": "10940711", "PostTypeId": "2", "Body": "<p>It is a bug in g++, which was introduced between 4.7.0-11 and <a href=\"http://packages.debian.org/changelogs/pool/main/g/gcc-4.7/gcc-4.7_4.7.0-12/changelog\" rel=\"nofollow\">4.7.0-12</a> (I tested those two Debian versions). <a href=\"http://packages.debian.org/changelogs/pool/main/g/gcc-snapshot/gcc-snapshot_20120601-1/changelog\" rel=\"nofollow\">gcc-snapshot (20120601-1)</a> is fine, too, unfortunately, I don't know what are the differences between those too - 4.7.0-12 is 6 days later and a different branch, and I don't have a gcc repository here to compare). I couldn't find the relevant entry in gcc's bugzilla.</p>\n<p>The relevant section of the standard is </p>\n<blockquote>\n<p id=\"so_10939543_10940711_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with\n  external linkage (7.1.2), class template (Clause 14), <strong>non-static function template</strong> (14.5.6), static data member\n  of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for\n  which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements ... then the program shall behave as if there were a single definition of D <em>[D is that class/function/whatever]</em>. </p>\n</blockquote>\n<p>When you apply this paragraph to <code>my_transform</code>, you see that it is a non-static function template, it satisfies the requirements (omitted for brevity), so the program should behave as if there was only one definition in the whole program. That holds regardless of what is inside it, so it doesn't matter if the <code>operator()</code> of the lambda is or isn't <code>inline</code> (it should be, but doesn't matter really<sup>1</sup>).</p>\n<p>BTW the poor man's lambda function equivalent (which should really be equivalent AFAIK)</p>\n<pre><code>template &lt;class Iterator, typename Iterator::value_type x&gt;\nvoid\nmy_transform(Iterator begin, Iterator end)\n{\n  struct Foo {\n    auto operator()(typename Iterator::value_type y) const -&gt; decltype(x+y) { return x+y; }\n  };\n  std::transform(begin, end, begin,\n                 Foo());\n}\n</code></pre>\n<p>still works.</p>\n<p><sub>1: I'm not sure if it itself could be subject to ODR, since it has no linkage (cf. 5.1.2/3 and 3.5/8)</sub></p>\n<p><sub>Just to be sure I don't forget it, the bug was introduced by commit <a href=\"http://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;a=commitdiff;h=f899a730d4f41b6a20b5508059a450f3a9347316\" rel=\"nofollow\">f899a730d4f41b6a20b5508059a450f3a9347316</a></sub></p>\n", "LastEditorUserId": "51831", "LastActivityDate": "2012-06-18T22:40:36.790", "Score": "4", "CreationDate": "2012-06-07T22:26:34.803", "ParentId": "10939543", "CommentCount": "3", "OwnerUserId": "51831", "LastEditDate": "2012-06-18T22:40:36.790"}, "bq_ids": {"n4140": {"so_10939543_10940711_0": {"length": 53, "quality": 0.8688524590163934, "section_id": 7043}}, "n3337": {"so_10939543_10940711_0": {"length": 54, "quality": 0.8852459016393442, "section_id": 6788}}, "n4659": {"so_10939543_10940711_0": {"length": 53, "quality": 0.8688524590163934, "section_id": 8540}}}, "10939543": {"ViewCount": "454", "Body": "<p>In my code, I have got function templates containing lambda expressions which depend on some of the template parameters. Recently I got linker errors, maybe due to an update of my g++-compiler, but unfortunately, I do not know exactly.</p>\n<p>I will give a small example that demonstrates the issue. Because it is a linker issue, we have to create a couple of files to demonstrate it. We have <code>common.hpp</code>, which contains a common template function, two modules <code>a.cpp</code>/<code>a.hpp</code> and <code>b.cpp</code>/<code>b.hpp</code> making use of that function and a <code>main.cpp</code> module containing the <code>main</code> function.</p>\n<pre><code>// common.hpp\n#include &lt;algorithm&gt;\n\ntemplate &lt;class Iterator, typename Iterator::value_type x&gt;\nvoid\nmy_transform(Iterator begin, Iterator end)\n{\n  std::transform(begin, end, begin,\n                 [] (typename Iterator::value_type y) { return x+y; });\n}\n</code></pre>\n<p>File <code>a.cpp</code>:</p>\n<pre><code>// a.cpp\n#include \"common.hpp\"\n#include \"a.hpp\"\n\nvoid a(std::vector&lt;int&gt;&amp; vec)\n{\n  my_transform&lt;std::vector&lt;int&gt;::iterator, 5&gt;(vec.begin(), vec.end());\n}\n</code></pre>\n<p>File <code>a.hpp</code></p>\n<pre><code>#include &lt;vector&gt;\nvoid a(std::vector&lt;int&gt;&amp; vec);\n</code></pre>\n<p>File <code>b.cpp</code>:</p>\n<pre><code>// b.cpp\n#include \"common.hpp\"\n#include \"b.hpp\"\n\nvoid b(std::vector&lt;int&gt;&amp; vec)\n{\n  my_transform&lt;std::vector&lt;int&gt;::iterator, 5&gt;(vec.begin(), vec.end());\n}\n</code></pre>\n<p>File <code>b.hpp</code></p>\n<pre><code>#include &lt;vector&gt;\nvoid b(std::vector&lt;int&gt;&amp; vec);\n</code></pre>\n<p>File <code>main.cpp</code></p>\n<pre><code>int main() { return 0; }\n</code></pre>\n<p>If I compile and link using</p>\n<pre><code>g++-4.7 -std=c++11 -c a.cpp\ng++-4.7 -std=c++11 -c b.cpp\ng++-4.7 -std=c++11 -c main.cpp\ng++ a.o b.o main.o\n</code></pre>\n<p>I get a <code>multiple-definition</code> error:</p>\n<pre><code>b.cpp:(.text+0x30): multiple definition of `void my_transform&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;, 17&gt;(__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;)::{lambda(int)#1}::operator int (*)(int)() const'\na.o:a.cpp:(.text+0x30): first defined here\n</code></pre>\n<p>Basically it says that the lambda expression was already defined in a. Okay. If I change the template parameter in <code>b</code> from 5 to 7, everything works.</p>\n<p>Questions:</p>\n<ol>\n<li>Is this what I should expect or is it a bug in <code>g++</code>? I am very sure that I compiled this code with an earlier version of the debian package of <code>g++-4.7</code>.</li>\n<li>Are there any workarounds apart from not using lambdas? If the resulting symbols were static there wouldn't be any problems for example, I think. <strong>Update: Workaround: Make my_transform <code>static</code> or <code>inline</code>.</strong></li>\n</ol>\n<p>This question is not very important. There is no problem with the \"do not use lambdas here\" approach, but I am curious. :)</p>\n", "AcceptedAnswerId": "10940711", "Title": "C++11 Lambdas and Templates cause strange linker behaviour", "CreationDate": "2012-06-07T20:42:09.127", "Id": "10939543", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-06-07T21:16:47.880", "LastEditorUserId": "898813", "LastActivityDate": "2012-06-18T22:40:36.790", "Score": "4", "OwnerUserId": "898813", "Tags": "<c++><templates><c++11><g++><multiple-definition-error>", "AnswerCount": "2"}, "10940272": {"Id": "10940272", "PostTypeId": "2", "Body": "<p>This looks like a compiler/linker issue 4.6.1 does not have it.</p>\n<p>What does this command output on your system?</p>\n<pre><code>nm -C a.o | grep 'lambda(int)#1'\n</code></pre>\n<p>?</p>\n<p>With 4.6.1, there's one weak symbol (an instantiation of <code>std::transform</code>) and one local symbol (<code>operator()</code> for the lambda). There's no <code>operator int (*)(int)() const</code> (what appears to cause the problem) defined at all.</p>\n", "LastActivityDate": "2012-06-07T21:39:36.363", "CommentCount": "0", "CreationDate": "2012-06-07T21:39:36.363", "ParentId": "10939543", "Score": "1", "OwnerUserId": "775806"}});