post_cb({"30195104": {"ParentId": "30194370", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-05-12T15:19:00.507", "Score": "3", "LastEditorUserId": "701092", "LastEditDate": "2015-05-12T16:05:09.193", "Id": "30195104", "OwnerUserId": "701092", "Body": "<p>From \u00a712.8/28 [class.copy]:</p>\n<blockquote>\n<p id=\"so_30194370_30195104_0\">It is unspecified whether subobjects representing virtual base classes are assigned more than once by the\n  implicitly-defined copy/move assignment operator. [ Example:</p>\n<pre><code>struct V { };\nstruct A : virtual V { };\nstruct B : virtual V { };\nstruct C : B, A { };\n</code></pre>\n<p id=\"so_30194370_30195104_1\">It is unspecified whether the virtual base class subobject <code>V</code> is assigned twice by the implicitly-defined copy-/move assignment operator for <code>C</code>. \u2014 end example ]</p>\n</blockquote>\n<p>The behavior of your program is unspecified according to the standard. Visual Studio decides to call the assignment operator once while GCC and Clang do so twice. The result of a move operation leaves the move-from object in a valid but unspecified state, so subsequently moving from the temporary again will leave <code>s</code> with an unspecified value, but per the above clause this is allowed to happen. So to answer your question, there is no correct behavior for this program.</p>\n", "LastActivityDate": "2015-05-12T16:05:09.193"}, "bq_ids": {"n4140": {"so_30194370_30195104_0": {"section_id": 477, "quality": 0.875, "length": 14}, "so_30194370_30195104_1": {"section_id": 477, "quality": 0.7857142857142857, "length": 11}}, "n3337": {"so_30194370_30195104_0": {"section_id": 468, "quality": 0.875, "length": 14}, "so_30194370_30195104_1": {"section_id": 468, "quality": 0.7857142857142857, "length": 11}}, "n4659": {"so_30194370_30195104_1": {"section_id": 500, "quality": 0.8571428571428571, "length": 12}, "so_30194370_30195104_0": {"section_id": 500, "quality": 0.9375, "length": 15}}}, "30194370": {"CommentCount": "4", "ViewCount": "51", "CreationDate": "2015-05-12T14:48:57.350", "LastActivityDate": "2015-05-12T16:05:09.193", "Title": "Move semantics in the presence of virtual bases", "AcceptedAnswerId": "30195104", "PostTypeId": "1", "Id": "30194370", "Score": "0", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nstruct Name { string s; Name(string s) : s(move(s)) { } };\n\nstruct A : virtual Name { A(string s) : Name(move(s)) { } };\n\nstruct B : virtual Name { B(string s) : Name(move(s)) { } };\n\nstruct C : A, B { C(string s) : A(string()), B(string()), Name(move(s)) { } };\n\nC f() { return C(\"abcdefghijklmnopqrstuvwxyz\"); }\n\nint main()\n{\n    C c1(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    C c2(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    C ff = f();\n    c1 = f();\n    c2 = ff;\n    cout &lt;&lt; \"C1 = \" &lt;&lt; c1.s &lt;&lt; \" \" &lt;&lt; \"C2 = \" &lt;&lt; c2.s &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>gcc (4.9.2) (<a href=\"http://ideone.com/G7uzCQ\" rel=\"nofollow\">http://ideone.com/G7uzCQ</a>) and clang++ both print different values for C1 and C2 whereas Visual Studio 2013 and 2015 consistently print the lower case alphabet sequence for both C1 and C2.</p>\n<p>Who is right? or is it just some loop hole in the standard?</p>\n", "Tags": "<c++11><move-semantics><virtual-inheritance><diamond-problem>", "OwnerUserId": "601567", "AnswerCount": "1"}});