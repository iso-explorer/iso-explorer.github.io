post_cb({"bq_ids": {"n4140": {"so_12829008_12829045_0": {"length": 24, "quality": 0.75, "section_id": 6163}}, "n3337": {"so_12829008_12829045_0": {"length": 25, "quality": 0.78125, "section_id": 5924}}, "n4659": {"so_12829008_12829045_0": {"length": 24, "quality": 0.75, "section_id": 7660}}}, "12829065": {"Id": "12829065", "PostTypeId": "2", "Body": "<p>When the left side determines the result, the right side is not evaluated.</p>\n<p>In the first case, the right side is <code>y++ &lt; 10</code>, and this is not evaluated. In the second case, the right side is <code>(y++ &lt; 10)</code>, and this is not evaluated.</p>\n<p>There is no rule that expressions in parentheses are evaluated first. Parentheses only group operands.</p>\n", "LastActivityDate": "2012-10-10T21:57:37.047", "Score": "1", "CreationDate": "2012-10-10T21:57:37.047", "ParentId": "12829008", "CommentCount": "0", "OwnerUserId": "298225"}, "12829096": {"Id": "12829096", "PostTypeId": "2", "Body": "<p>Even with parentheses short-circuiting <em>must</em> still take place. Consider if you have an expression involving pointers:</p>\n<pre><code>int* ptr = 0;\nint bar = 5;\nbool result = (ptr != 0) &amp;&amp; (*ptr == bar || bar &gt; 10);\n</code></pre>\n<p>You clearly can't safely evaluate the right-hand side of the <code>&amp;&amp;</code> there, but the parentheses are required to make the precedence work as intended. The parentheses simply determine the order of operations <em>that are actually performed</em> not that they happen in a particular order.</p>\n", "LastActivityDate": "2012-10-10T22:00:08.537", "Score": "0", "CreationDate": "2012-10-10T22:00:08.537", "ParentId": "12829008", "CommentCount": "0", "OwnerUserId": "251738"}, "12829008": {"ViewCount": "2011", "Body": "<p>consider this code (C++) :</p>\n<pre><code>int x = -4 , y = 5 ;\nbool result = x &gt; 0 &amp;&amp; y++ &lt; 10 ;\n</code></pre>\n<p>the expression (x &gt; 0) will be evaluated first , and because (x &gt; 0 = false) and due to short-circuit evaluation , the other expression (y++ &lt; 10) won't be evaluated and the value of y will remain 5 .</p>\n<p>now consider the following code :</p>\n<pre><code>int x = -4 , y = 5 ;\nbool result = (x &gt; 0) &amp;&amp; (y++ &lt; 10) ;\n</code></pre>\n<p>it is expected that the expressions in parentheses will be evaluated first so that before the logical AND is performed , the expression (y++ &lt; 10) would have been evaluated and the value of y has became 6 \n , but the reality is that the value of y remains 5 . which means that even with the parentheses the evaluation is short-circuited and the expression (y++ &lt; 10) is ignored .</p>\n<p>What is the explanation for this case ?! </p>\n", "Title": "Parentheses and logical operators", "CreationDate": "2012-10-10T21:53:59.800", "LastActivityDate": "2012-10-10T22:00:08.537", "CommentCount": "3", "LastEditDate": "2012-10-10T21:55:31.337", "PostTypeId": "1", "LastEditorUserId": "1419515", "Id": "12829008", "Score": "4", "OwnerUserId": "1445043", "Tags": "<java><c++><logical-operators><short-circuiting>", "AnswerCount": "3"}, "12829045": {"Id": "12829045", "PostTypeId": "2", "Body": "<p>The explanation is in the question - <strong>short-circuiting</strong>.</p>\n<p>In C++, evaluation of <code>&amp;&amp;</code> (and <code>||</code> for that matter) is guaranteed to be left-to-right, and as soon as a <code>false</code> is encountered (respectively <code>true</code> for <code>||</code>), evaluation is <strong>guaranteed</strong> to stop.</p>\n<p>Similar for Java I guess.</p>\n<p>The parenthesis are redundant and not relevant in this case - it has nothing to do with operator precedence. It simply has to do with how <code>&amp;&amp;</code> works:</p>\n<p>In fact, the two versions </p>\n<pre><code>x &gt; 0 &amp;&amp; y++ &lt; 10\n(x &gt; 0) &amp;&amp; (y++ &lt; 10)\n</code></pre>\n<p>are equivalent, because <code>++</code> has the highest precedence, followed by <code>&lt;,&gt;</code>, and finally <code>&amp;&amp;</code>. Pedantically, you should have written it as:</p>\n<pre><code>(x &gt; 0) &amp;&amp; ((y++) &lt; 10)\n</code></pre>\n<h3>5.14 Logical AND operator [expr.log.and]</h3>\n<blockquote>\n<p id=\"so_12829008_12829045_0\">1 The <code>&amp;&amp;</code> operator groups left-to-right. The operands are both implicitly converted to type bool (clause 4). The result\n  is true if both operands are <code>true</code> and <code>false</code> otherwise. <strong>Unlike &amp;, &amp;&amp; guarantees left-to-right evaluation: the second\n  operand is not evaluated if the first operand is <code>false</code>.</strong> (emphasis mine)</p>\n</blockquote>\n", "LastActivityDate": "2012-10-10T21:56:17.753", "Score": "10", "CreationDate": "2012-10-10T21:56:17.753", "ParentId": "12829008", "CommentCount": "2", "OwnerUserId": "673730"}});