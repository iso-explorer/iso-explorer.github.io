post_cb({"41777551": {"CommentCount": "4", "ViewCount": "132", "CreationDate": "2017-01-21T09:09:29.207", "LastActivityDate": "2017-01-21T17:01:12.687", "Title": "How to generate uniformly distributed random reals for custom types without reinventing the wheel?", "AcceptedAnswerId": "41782071", "PostTypeId": "1", "Id": "41777551", "Score": "2", "Body": "<p>I was going to use <code>std::uniform_real_distribution</code> with some non-builtin floating-point-like types, e.g. <a href=\"http://half.sourceforge.net/half_8hpp_source.html\" rel=\"nofollow noreferrer\"><code>half_float::half</code></a> or <a href=\"http://www.boost.org/doc/libs/1_63_0/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/float128.html\" rel=\"nofollow noreferrer\"><code>boost::multiprecision::float128</code></a>. But what I get is</p>\n<blockquote>\n<p id=\"so_41777551_41777551_0\">/opt/gcc-5.2/include/c++/5.2.0/bits/random.h:1868:7: error: static assertion failed: template argument not a floating point type</p>\n</blockquote>\n<p>from g++ 5.2. Here's the example program (compile with <code>g++ -std=c++11 -fext-numeric-literals test.cpp -o test</code>):</p>\n<pre><code>#include &lt;random&gt;\n#include &lt;boost/multiprecision/float128.hpp&gt;\n#include &lt;half.hpp&gt;\n\ntemplate&lt;typename Float&gt;\nvoid test()\n{\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_real_distribution&lt;Float&gt; rnd(Float(1),Float(10));\n}\n\nint main()\n{\n    test&lt;float&gt;();\n    test&lt;double&gt;();\n    test&lt;long double&gt;();\n    test&lt;boost::multiprecision::float128&gt;(); // doesn't compile\n    test&lt;half_float::half&gt;(); // doesn't compile\n}\n</code></pre>\n<p>So, how is one supposed to generate uniformly distributed random reals for such custom types? Is there a way to go without reinventing the wheel?</p>\n", "Tags": "<c++><random><floating-point>", "OwnerUserId": "673852", "AnswerCount": "2"}, "41777846": {"ParentId": "41777551", "CommentCount": "4", "Body": "<p>As you can see from <a href=\"http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution\" rel=\"nofollow noreferrer\">here</a>, <code>uniform_real_distribution</code> is defined as:</p>\n<pre><code>template&lt;\u00a0class\u00a0RealType\u00a0=\u00a0double\u00a0&gt;\nclass\u00a0uniform_real_distribution;\n</code></pre>\n<p>Where <code>RealType</code> is:</p>\n<blockquote>\n<p id=\"so_41777551_41777846_0\">The result type generated by the generator. The effect is undefined if this is not one of\u00a0float,\u00a0double, or\u00a0long\u00a0double.</p>\n</blockquote>\n<p>It seems that your compiler explicitly forbids to use a custom type as a solution to deal with (let me say) <em>unaccepted types</em>. Therefore I would say that you have no chance to get it working.</p>\n", "OwnerUserId": "4987285", "PostTypeId": "2", "Id": "41777846", "Score": "0", "CreationDate": "2017-01-21T09:43:51.997", "LastActivityDate": "2017-01-21T09:43:51.997"}, "41782071": {"ParentId": "41777551", "CommentCount": "0", "Body": "<p>The standard random number facilities which work with <code>RealType</code> type as defined in the Standard, must have <code>float</code>, <code>double</code> or <code>long double</code> as type template argument, as in 26.5.1.1.d:</p>\n<blockquote>\n<p id=\"so_41777551_41782071_0\">Throughout this subclause 26.5, the effect of instantiating a template:</p>\n<p id=\"so_41777551_41782071_1\">&lt;...&gt;</p>\n<p id=\"so_41777551_41782071_2\">d) that has a template type parameter named <code>RealType</code> is undefined unless the corresponding template argument is cv-unqualified and is one of <code>float</code>, <code>double</code>, or <code>long double</code>.</p>\n</blockquote>\n<p>One solution is to replace <code>std::uniform_real_distribution</code> with <code>boost::random::uniform_real_distribution</code>. The latter does accept non-builtin float types. Here's an example with a reasonable type<sup>*</sup>:</p>\n<pre><code>#include &lt;random&gt;\n#include &lt;boost/random/uniform_real_distribution.hpp&gt;\n#include &lt;boost/multiprecision/float128.hpp&gt;\n\ntemplate&lt;typename Float&gt;\nvoid test()\n{\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    boost::random::uniform_real_distribution&lt;Float&gt; rnd(Float(1),Float(10));\n}\n\nint main()\n{\n    test&lt;float&gt;();\n    test&lt;double&gt;();\n    test&lt;long double&gt;();\n    test&lt;boost::multiprecision::float128&gt;();\n}\n</code></pre>\n<p><sub><sup>*</sup><code>half_float::half</code> doesn't work because its multiplication by a constant results in a <code>float</code>, while <code>half_float::half(float)</code> constructor is explicit, and Boost's implementation doesn't call it explicitly</sub></p>\n", "OwnerUserId": "673852", "PostTypeId": "2", "Id": "41782071", "Score": "0", "CreationDate": "2017-01-21T17:01:12.687", "LastActivityDate": "2017-01-21T17:01:12.687"}, "bq_ids": {"n4140": {"so_41777551_41782071_0": {"section_id": 3487, "quality": 0.8333333333333334, "length": 5}, "so_41777551_41782071_2": {"section_id": 3487, "quality": 1.0, "length": 15}, "so_41777551_41777846_0": {"section_id": 3487, "quality": 0.6153846153846154, "length": 8}}, "n3337": {"so_41777551_41782071_0": {"section_id": 3352, "quality": 0.8333333333333334, "length": 5}, "so_41777551_41782071_2": {"section_id": 3352, "quality": 1.0, "length": 15}, "so_41777551_41777846_0": {"section_id": 3352, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_41777551_41782071_0": {"section_id": 4250, "quality": 0.8333333333333334, "length": 5}, "so_41777551_41782071_2": {"section_id": 4250, "quality": 1.0, "length": 15}, "so_41777551_41777846_0": {"section_id": 4250, "quality": 0.6153846153846154, "length": 8}}}});