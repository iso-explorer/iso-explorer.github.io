post_cb({"bq_ids": {"n4140": {"so_13680587_13686519_0": {"length": 23, "quality": 0.92, "section_id": 6365}, "so_13680587_13680696_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 4658}, "so_13680587_13686519_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 4681}, "so_13680587_13686519_3": {"length": 7, "quality": 0.875, "section_id": 4682}}, "n3337": {"so_13680587_13686519_0": {"length": 23, "quality": 0.92, "section_id": 6122}, "so_13680587_13680696_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 4469}, "so_13680587_13686519_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 4490}, "so_13680587_13686519_3": {"length": 7, "quality": 0.875, "section_id": 4491}}, "n4659": {"so_13680587_13686519_0": {"length": 23, "quality": 0.92, "section_id": 7876}, "so_13680587_13680696_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6027}, "so_13680587_13686519_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 823}, "so_13680587_13686519_3": {"length": 7, "quality": 0.875, "section_id": 6052}}}, "13680587": {"ViewCount": "6872", "Body": "<p><code>std::function</code> provides a constructor from an rvalue ref.\nWhat happens to the moved function object by standard? Will it be empty so that calling it again has no effects?</p>\n", "AcceptedAnswerId": "13680662", "Title": "Move semantic with std::function", "CreationDate": "2012-12-03T09:43:40.697", "Id": "13680587", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-12-03T09:54:28.710", "LastEditorUserId": "46642", "LastActivityDate": "2012-12-03T15:36:10.657", "Score": "9", "OwnerUserId": "989331", "Tags": "<c++><c++11><standards>", "AnswerCount": "4"}, "13680696": {"Id": "13680696", "PostTypeId": "2", "Body": "<p>[func.wrap.func.con]:</p>\n<pre><code>function(function&amp;&amp; f);\ntemplate &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);\n</code></pre>\n<blockquote>\n<p id=\"so_13680587_13680696_0\">Effects: If !f, *this has no target; otherwise, move-constructs the target of f into the target of *this, leaving f in a valid state with an unspecified value.</p>\n</blockquote>\n", "LastActivityDate": "2012-12-03T09:49:58.393", "CommentCount": "0", "CreationDate": "2012-12-03T09:49:58.393", "ParentId": "13680587", "Score": "0", "OwnerUserId": "1782465"}, "13680785": {"Id": "13680785", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13680587_13680785_0\">What happens to the moved function object by standard?</p>\n</blockquote>\n<p>It will be in a valid state (thus the object can be used), but the actual state that it is in is unspecified. The last part means that calling any function that requires the object to be in a <em>specific</em> state will not necessarily work.</p>\n<blockquote>\n<p id=\"so_13680587_13680785_1\">Will it be empty so that calling it again has no effects?</p>\n</blockquote>\n<p>You <em>cannot</em> assume it will be. Calling the function requires that it actually have a function to call. That's part of its state. And since the state is unspecified, the results of calling it are unspecified.</p>\n<p>If you want to use the object in some meaningful way again, simply create a new <code>function</code> and assign it to it:</p>\n<pre><code>function&lt;...&gt; old;\nfunction&lt;...&gt; new_ = std::move(old);\nold = function&lt;...&gt;(...); //Reset to known state.\nold(...); //Call is well-defined.\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-12-03T10:03:49.733", "Score": "5", "CreationDate": "2012-12-03T09:55:32.517", "ParentId": "13680587", "CommentCount": "0", "OwnerUserId": "734069", "LastEditDate": "2012-12-03T10:03:49.733"}, "13686519": {"Id": "13686519", "PostTypeId": "2", "Body": "<p>There is too much confusion around this question.  I'm going to try to lay things out clearly...</p>\n<p>This section describes the moved-from state of std-defined objects:</p>\n<p>17.6.5.15 [lib.types.movedfrom]</p>\n<blockquote>\n<p id=\"so_13680587_13686519_0\">Objects of types defined in the C++ standard library may be moved from\n  (12.8). Move operations may be explicitly specified or implicitly\n  generated. Unless otherwise specified, such moved-from objects shall\n  be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>What does this mean?  This means that given a std-defined moved-from object, you can do anything with that object that doesn't require a priori knowledge of the state of that object.  The class of actions that require no a priori knowledge of the current state are those that have no preconditions.</p>\n<p>For example you can call <code>clear()</code> on a moved-from <code>vector</code> because there are no preconditions on <code>vector::clear()</code>.  But you can't call <code>pop_back()</code> because that does have preconditions.</p>\n<p>Looking specifically at the call operator of <code>function</code>:</p>\n<p>20.8.11.2.4 [func.wrap.func.inv]</p>\n<pre><code>R operator()(ArgTypes... args) const\n</code></pre>\n<blockquote>\n<p id=\"so_13680587_13686519_1\">Effects: INVOKE(f, std::forward(args)..., R) (20.8.2), where\n  f is the target ob- ject (20.8.1) of *this.</p>\n<p id=\"so_13680587_13686519_2\">Returns: Nothing if R is void, otherwise the return value of INVOKE\n  (f, std::forward( args)..., R).</p>\n<p id=\"so_13680587_13686519_3\">Throws: bad_function_call if !*this; otherwise, any exception thrown\n  by the wrapped callable object.</p>\n</blockquote>\n<p>Note that there is no precondition or Requires clause.  That means that calling the call operator of <code>function</code> of a moved-from <code>function</code> is not undefined behavior.  No matter what state the <code>function</code> is in, you're not going to violate any preconditions with this call.</p>\n<p>Note that in no case does the specification say that the call will have no effect.  So having no effect is not a possibility.</p>\n<p>The call will either call the wrapped function, or throw a <code>bad_function_call</code>.  Those are the only two choices.  And which behavior it has depends on the state of the <code>function</code> object.  And the state of the <code>function</code> object is unspecified ([lib.types.movedfrom]).</p>\n", "LastActivityDate": "2012-12-03T15:36:10.657", "CommentCount": "4", "CreationDate": "2012-12-03T15:36:10.657", "ParentId": "13680587", "Score": "13", "OwnerUserId": "576911"}, "13680662": {"Id": "13680662", "PostTypeId": "2", "Body": "<p>Under 20.8.11.2.1p6, <code>function(function &amp;&amp;f)</code> leaves <em><code>f</code> in a valid state with an unspecified value</em>.</p>\n<p>The empty state is a valid state, so you should expect that the moved from function object can be empty.</p>\n<p>Because <code>function</code> performs type erasure, and function objects can be arbitrarily expensive, the optimisation to leave the moved from object empty makes sense:</p>\n<pre><code>std::function&lt;void()&gt; g{std::bind{f, std::array&lt;int, 1000&gt;{}}};\nstd::function&lt;void()&gt; h{std::move{g}};\n</code></pre>\n<p>After <code>h</code> has been constructed by move from <code>g</code>, one would expect the contained <code>bind</code> have been transferred from <code>g</code> to <code>h</code> rather than copying, so <code>g</code> would be left empty.</p>\n<p>For the following program, gcc 4.5.1 prints <code>empty</code>:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\nvoid f() {}\nint main() {\n    std::function&lt;void()&gt; g{f}, h{std::move(g)};\n    std::cout &lt;&lt; (g ? \"not empty\\n\" : \"empty\\n\");\n}\n</code></pre>\n<p>This is not necessarily the most optimal behaviour; inlining small callables (e.g. function pointers) creates a situation where copying the callable is more efficient than moving it and emptying the moved from object, so another implementation could leave <code>g</code> in a non-empty callable state.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-12-03T10:02:36.300", "Score": "10", "CreationDate": "2012-12-03T09:48:01.347", "ParentId": "13680587", "CommentCount": "7", "OwnerUserId": "567292", "LastEditDate": "2012-12-03T10:02:36.300"}});