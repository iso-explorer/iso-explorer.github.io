post_cb({"40201381": {"Id": "40201381", "PostTypeId": "2", "Body": "<p>I don't think you can do that. Quoting N4606:</p>\n<blockquote>\n<p id=\"so_40201020_40201381_0\">\u00a714.3.3 [temp.arg.template]/1</p>\n<p id=\"so_40201020_40201381_1\">A <em>template-argument</em> for a template <em>template-parameter</em> shall be the\n  name of a class template or an alias template, expressed as\n  <em>id-expression</em>.</p>\n</blockquote>\n<p>A variable template doesn't fit this requirement.</p>\n<hr>\n<p>You could cheat a little and use a proxy type to select the template:</p>\n<pre><code>template &lt; typename Tuple, class Proxy&gt;\nstruct PutTupleInTV;\n\ntemplate &lt; typename... Types, class Proxy&gt;\nstruct PutTupleInTV&lt;std::tuple&lt;Types...&gt;, Proxy&gt;\n{\n    static constexpr auto value = Proxy::template value&lt;Types...&gt;;\n};\n</code></pre>\n<p>and then for </p>\n<pre><code>template&lt;typename...&gt; struct foo{};\ntemplate&lt;typename... Ts&gt; constexpr foo&lt;Ts...&gt; foo_v{};\nstruct use_foo\n{\n    template&lt;typename... Ts&gt;\n    static constexpr auto value = foo_v&lt;Ts...&gt;;\n};\n</code></pre>\n<p>you could say</p>\n<pre><code>PutTupleInTV&lt;tup, use_foo&gt;::value\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/SQSgDXjoJHHTj4vj\">live demo</a></p>\n</hr>", "LastActivityDate": "2016-10-23T09:20:33.717", "CommentCount": "2", "CreationDate": "2016-10-23T09:20:33.717", "ParentId": "40201020", "Score": "6", "OwnerUserId": "2456565"}, "bq_ids": {"n4140": {"so_40201020_40201381_1": {"length": 10, "quality": 1.0, "section_id": 92}}, "n3337": {"so_40201020_40201381_1": {"length": 10, "quality": 1.0, "section_id": 87}}, "n4659": {"so_40201020_40201381_1": {"length": 10, "quality": 1.0, "section_id": 95}}}, "40201020": {"ViewCount": "211", "Body": "<p>Say you have a tuple type and you want to extract its template parameter pack in order to instantiate another template. If that is a type template, then I can have a utility like this:</p>\n<pre><code>template &lt; typename Tuple, template &lt;typename...&gt; typename What &gt;\nstruct PutTupleInT;\n\ntemplate &lt; typename... Types, template &lt;typename...&gt; typename What &gt;\nstruct PutTupleInT&lt;std::tuple&lt;Types...&gt;, What&gt;\n{\n    using Result = What&lt;Types...&gt;;\n};\n</code></pre>\n<p>But what if the desired template is a variable template? While <code>template &lt;typename...&gt; typename What</code> is the \"placeholder\" for a type template, then what is the \"placeholder\" for a variable template?</p>\n<p>I've tried the following for clang-4.0.0 (the only compiler by now that supports non-type template parameters with auto type), but it failed. Actually I am not sure if this is a correct syntax for C++17.</p>\n<pre><code>template &lt; typename Tuple, template &lt;typename...&gt; auto What &gt;\nstruct PutTupleInV;\n\ntemplate &lt; typename... Types, template &lt;typename...&gt; auto What &gt;\nstruct PutTupleInV&lt;std::tuple&lt;Types...&gt;, What&gt;\n{\n    static constexpr auto value = What&lt;Types...&gt;;\n};\n</code></pre>\n", "AcceptedAnswerId": "40201381", "Title": "Variable template template?", "CreationDate": "2016-10-23T08:29:59.370", "Id": "40201020", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-10-24T15:44:30.093", "LastEditorUserId": "371239", "LastActivityDate": "2016-10-24T15:44:30.093", "Score": "8", "OwnerUserId": "371239", "Tags": "<c++><c++14><c++1z><template-templates><variable-templates>", "AnswerCount": "2"}, "40201135": {"Id": "40201135", "PostTypeId": "2", "Body": "<p>PutTupleInTV is not the same name as PutTupleInV. You are not specializing the template PutTupleInV but using specializing syntax to create something new, called PutTupleInTV.</p>\n", "LastActivityDate": "2016-10-23T08:47:25.493", "CommentCount": "1", "CreationDate": "2016-10-23T08:47:25.493", "ParentId": "40201020", "Score": "0", "OwnerUserId": "1064375"}});