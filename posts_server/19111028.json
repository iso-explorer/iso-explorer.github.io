post_cb({"19111606": {"Id": "19111606", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19111028_19111606_0\">So what are the benefits and the usage of <code>std::dynarray</code>, when we can use <code>std::vector</code> which is more dynamic (Re-sizable)?</p>\n</blockquote>\n<p><code>dynarray</code> is smaller and simpler than <code>vector</code>, because it doesn't need to manage separate size and capacity values, and it doesn't need to store an allocator.</p>\n<p>However the main performance benefit is intended to come from the fact that implementations are encouraged to allocate <code>dynarray</code> on the stack when possible, avoiding any heap allocation. e.g.</p>\n<pre><code>std::dynarray&lt;int&gt; d(5);   // can use stack memory for elements\nauto p = new std::dynarray&lt;int&gt;(6);  // must use heap memory for elements\n</code></pre>\n<p>This optimisation requires cooperation from the compiler, it can't be implemented as a pure library type, and the necessary compiler magic has not been implemented and noone is sure how easy it is to do. Because of the lack  of implementation experience, at the C++ committee meeting in Chicago last week it was decided to pull <code>std::dynarray</code> from C++14 and to issue a separate array extensions TS (technical specification) document defining <code>std::experimental::dynarray</code> and arrays of runtime bound (ARBs, similar to C99 VLAs.)  This means <code>std::dynarray</code> will almost certainly not be in C++14.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-10-01T08:45:17.740", "Score": "71", "CreationDate": "2013-10-01T08:39:59.227", "ParentId": "19111028", "CommentCount": "11", "OwnerUserId": "981959", "LastEditDate": "2013-10-01T08:45:17.740"}, "bq_ids": {"n4140": {"so_19111028_19111069_3": {"length": 15, "quality": 0.7142857142857143, "section_id": 4102}, "so_19111028_19111069_1": {"length": 9, "quality": 0.9, "section_id": 4040}, "so_19111028_19111069_2": {"length": 4, "quality": 0.8, "section_id": 3079}}, "n3337": {"so_19111028_19111069_3": {"length": 15, "quality": 0.7142857142857143, "section_id": 3949}, "so_19111028_19111069_2": {"length": 4, "quality": 0.8, "section_id": 2956}, "so_19111028_19111069_1": {"length": 9, "quality": 0.9, "section_id": 3890}}, "n4659": {"so_19111028_19111069_3": {"length": 15, "quality": 0.7142857142857143, "section_id": 5011}, "so_19111028_19111069_1": {"length": 9, "quality": 0.9, "section_id": 4944}, "so_19111028_19111069_2": {"length": 4, "quality": 0.8, "section_id": 3839}}}, "19111028": {"ViewCount": "11660", "Body": "<p>C++14 presents <a href=\"http://en.cppreference.com/w/cpp/container/dynarray\"><code>std::dynarray</code></a>:</p>\n<blockquote>\n<p id=\"so_19111028_19111028_0\">std::dynarray is a sequence container that encapsulates arrays with a\n  size that is fixed at construction and does not change throughout the\n  lifetime of the object.</p>\n</blockquote>\n<p><code>std::dynarray</code> must be allocated in run-time as same as <code>std::vector</code>.</p>\n<p>So what are the benefits and the usage of <code>std::dynarray</code> while we can use <code>std::vector</code> which is more dynamic (and also re-sizable)?</p>\n", "AcceptedAnswerId": "19111606", "Title": "std::dynarray vs std::vector", "CreationDate": "2013-10-01T08:05:37.903", "Id": "19111028", "CommentCount": "12", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2016-12-01T05:05:21.743", "LastEditorUserId": "734069", "LastActivityDate": "2016-12-01T05:05:21.743", "Score": "74", "OwnerUserId": "952747", "Tags": "<c++><stdvector>", "AnswerCount": "2"}, "19111069": {"Id": "19111069", "PostTypeId": "2", "Body": "<p>As you said yourself, <code>std::dynarray</code> is for a <em>fixed-size</em> dynamic array. It is not resizable. It's roughly speaking an improvement over <code>new T[N]</code> and over <code>std::unique_ptr&lt;T[]&gt;(new T[N])</code>.</p>\n<p>Not needing to resize or manage capacity means you can implement the data structure with less complexity and in less space.</p>\n<p>Moreover, <code>std::dynarray</code> is a weird animal that allows the implementation to implement it in different, non-specific ways, e.g. it's possible to put the array on the stack. Calling an allocation function is \"optional\". You can specify an allocator to construct the elements of the array, but that is not part of the type.</p>\n<p>You might also wonder why we need <code>std::dynarray</code> <em>and</em> variable-length arrays. VLAs in C++14 are much more restrictive; they can only be local, automatic variables and offer no way to specify an allocation policy, and of course they don't have a standard container interface.</p>\n<hr>\n<p>Some examples from 23.3.4.2 of a \"current draft\" (take that, Google cache):</p>\n<blockquote>\n<pre><code>explicit dynarray(size_type c);\n</code></pre>\n<p id=\"so_19111028_19111069_0\"><em>Effects:</em> Allocates storage for <code>c</code> elements. <strong>May or may not invoke the global <code>operator new</code>.</strong></p>\n</blockquote>\n<p></p>\n<blockquote>\n<pre><code>template &lt;class Alloc&gt;\ndynarray(size_type c, const Alloc&amp; alloc);\n</code></pre>\n<p id=\"so_19111028_19111069_1\"><em>Effects:</em> Equivalent to the preceding constructors except that <strong>each element is constructed with uses-allocator construction</strong>.</p>\n</blockquote>\n<p>Whether or not you <em>can</em> use a given allocator to construct the array elements is a global trait:</p>\n<blockquote>\n<p id=\"so_19111028_19111069_2\">template \n     struct uses_allocator, Alloc&gt; : true_type { };</p>\n<p id=\"so_19111028_19111069_3\"><em>Requires:</em> <code>Alloc</code> shall be an Allocator (17.6.3.5). [<em>Note:</em> Specialization of this trait informs other library components that <code>dynarray</code> can be constructed with an allocator, even though it does not have a nested allocator_type.]</p>\n</blockquote>\n<p><strong>Edit:</strong> Jonathan Wakely's answer is bound to be far more authoritative and insightful.</p>\n</hr>", "LastEditorUserId": "596781", "LastActivityDate": "2013-10-01T09:06:27.873", "Score": "30", "CreationDate": "2013-10-01T08:08:05.720", "ParentId": "19111028", "CommentCount": "2", "OwnerUserId": "596781", "LastEditDate": "2013-10-01T09:06:27.873"}});