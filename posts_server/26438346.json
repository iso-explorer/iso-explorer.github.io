post_cb({"26438346": {"CommentCount": "4", "ViewCount": "52", "CreationDate": "2014-10-18T09:42:02.320", "LastActivityDate": "2014-10-18T10:57:34.370", "Title": "How to detect cast from bool", "AcceptedAnswerId": "26438713", "PostTypeId": "1", "Id": "26438346", "Score": "0", "Body": "<p>I found error in my code that I think should be marked with warning. Compiled with /W4 but it don't show any warning (only about unreferenced formal parameter).</p>\n<pre><code>#include &lt;cstdio&gt;\n\nvoid A(int item, unsigned int count, unsigned team_count)\n{\n    printf(\"A, count, team count\\n\");\n}\n\nvoid A(int item, unsigned int count=1, bool is_team=true)\n{\n    printf(\"A, count, is_team\\n\");\n    return A(item, count, is_team ? count : 0);\n}\n\nint main()\n{\n    A(0, false); // &lt;- bool to unsigned int\n    return 0;\n}\n</code></pre>\n<p>Here bool is casted to unsigned int. Is there any way to detect that?\nTried Cppcheck but it don't find this.</p>\n", "Tags": "<c++><visual-studio-2008>", "OwnerUserId": "867354", "AnswerCount": "3"}, "26438696": {"ParentId": "26438346", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-10-18T10:22:09.590", "Score": "2", "LastEditorUserId": "2877241", "LastEditDate": "2014-10-18T10:29:35.823", "Id": "26438696", "OwnerUserId": "2877241", "Body": "<p>Here is an example how you can achieve what you want</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f( int ) { std::cout &lt;&lt; \"f( int )\" &lt;&lt; std::endl; }\nvoid f( bool ) = delete;\n\nint main() \n{\n    f( true );\n\n    return 0;\n}\n</code></pre>\n<p>Compiler error</p>\n<pre><code>prog.cpp:8:10: error: use of deleted function \u2018void f(bool)\u2019\n  f( true );\n          ^\n</code></pre>\n<p>Applied to your code the example will look like</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid A( int item, unsigned int count, unsigned team_count )\n{\n    std::cout &lt;&lt; \"A, count, team count\" &lt;&lt; std::endl;\n}\n\nvoid A( int item, unsigned int count = 1, bool is_team = true )\n{\n    std::cout &lt;&lt; \"A, count, is_team\" &lt;&lt; std::endl;\n    return A( item, count, is_team ? count : 0 );\n}\n\nvoid A( int, bool ) = delete;\n\nint main() \n{\n    A( 0, false );\n\n    return 0;\n}\n</code></pre>\n<p>Error:</p>\n<pre><code>prog.cpp:18:14: error: use of deleted function \u2018void A(int, bool)\u2019\n  A( 0, false );\n              ^\n</code></pre>\n", "LastActivityDate": "2014-10-18T10:29:35.823"}, "26439011": {"ParentId": "26438346", "CommentCount": "0", "CreationDate": "2014-10-18T10:57:34.370", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "26439011", "Score": "0", "Body": "<p>A very safe way to prevent such things is to wrap your count types in classes without implementing automatic conversions.</p>\n<pre><code>class Count\n{\nprivate:\n    int m_count;\npublic:\n    explicit Count(int count) : m_count(count)\n    {\n        assert(m_count &gt;= 0);\n    }\n\n    int Get() const { return m_count; }\n};\n\nclass TeamCount\n{\nprivate:\n    int m_count;\npublic:\n    explicit TeamCount(int count) : m_count(count)\n    {\n        assert(m_count &gt;= 0);\n    }\n\n    int Get() const { return m_count; }\n};\n\n// ...\n\nvoid A(int item, Count count, TeamCount team_count);\nvoid A(int item, Count count = Count(1), bool is_team = true);\n\n// ...\n\nA(0, false); // &lt;- compiler error\nA(0, TeamCount(0), false); // &lt;- compiler error\nA(0, Count(0), false); // OK\n</code></pre>\n<p>You can do a similar thing with your other primitive type parameters.</p>\n", "LastActivityDate": "2014-10-18T10:57:34.370"}, "bq_ids": {"n4140": {"so_26438346_26438713_0": {"section_id": 33, "quality": 1.0, "length": 11}}, "n3337": {"so_26438346_26438713_0": {"section_id": 30, "quality": 1.0, "length": 11}}, "n4659": {"so_26438346_26438713_0": {"section_id": 33, "quality": 1.0, "length": 11}}}, "26438713": {"ParentId": "26438346", "CommentCount": "2", "CreationDate": "2014-10-18T10:22:59.620", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26438713", "Score": "1", "Body": "<p>The standard says this is acceptable <em>\u00a74.7/p4</em> Integral Conversions:</p>\n<blockquote>\n<p id=\"so_26438346_26438713_0\">If the source type is bool, the value false is converted to zero and the value true is converted to one.</p>\n</blockquote>\n<p>Regarding how to detect this (since it's not an error) and depending on your use-case, you could either do some <a href=\"http://clang.llvm.org/docs/LibTooling.html\" rel=\"nofollow\">clang-tooling</a> yourself or write a wrapper with some template deduction magic on the lines of:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename T, typename U&gt;\nvoid A(int item, T, U) {\n    static_assert(!std::is_same&lt;T, unsigned int&gt;::value || \n                  (!std::is_same&lt;U, unsigned int&gt;::value &amp;&amp; \n                   !std::is_same&lt;U, bool&gt;::value), \n                  \"Something was wrong\");\n}\n\ntemplate&lt;&gt;\nvoid A(int item, unsigned int count, unsigned int team_count)\n{\n    printf(\"A, count, team count\\n\");\n}\n\ntemplate&lt;unsigned int count = 1, bool is_team = true&gt;\nvoid A(int item, unsigned int, bool)\n{\n    printf(\"A, count, is_team\\n\");\n    return A(item, count, is_team ? count : 0);\n}\n\nint main()\n{\n    // A(0, false); - not acceptable\n    // A(0, 22); - not acceptable\n    A(0, static_cast&lt;unsigned int&gt;(2), false);\n    A(0, static_cast&lt;unsigned int&gt;(33), static_cast&lt;unsigned int&gt;(45));\n    return 0;\n}\n</code></pre>\n<p><kbd><a href=\"http://ideone.com/jsBSth\" rel=\"nofollow\">Example</a></kbd></p>\n<p>Note that the base template deduction mechanism doesn't require C++11, although some functions used above do.</p>\n", "LastActivityDate": "2014-10-18T10:22:59.620"}});