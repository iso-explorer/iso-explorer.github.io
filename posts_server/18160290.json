post_cb({"18160890": {"ParentId": "18160290", "CommentCount": "0", "Body": "<p>I believe the applicable part of the standard in this case is \u00a73.3.7/1:2 and 3:</p>\n<blockquote>\n<p id=\"so_18160290_18160890_0\">2) A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S. No diagnostic is required for a violation of this rule.</p>\n<p id=\"so_18160290_18160890_1\">3) If reordering member declarations in a class yields an alternate valid program under (1) and (2), the program is ill-formed, no diagnostic is required.</p>\n</blockquote>\n<p>The name <code>Money</code> used in the definition of <code>Person</code> in the context of the definition of the return type of <code>Person::get</code> refers to <code>::Money</code>, but when reevaluated in the completed scope of <code>Person</code> refers to <code>::Person::Money</code>. </p>\n<p>Likewise, reordering the member declarations so the <code>typedef</code> of <code>Person::Money</code> precedes that of <code>Person::get</code> yields a an alternate valid program.</p>\n<p>As such, it appears that your code is ill-formed, but since no diagnostic is required both VC++ and gcc are equally conforming in this regard. I certainly prefer that the violation be diagnosed (as gcc does) rather than accepted silently (as VC++ does).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "18160890", "Score": "0", "CreationDate": "2013-08-10T10:12:12.260", "LastActivityDate": "2013-08-10T10:12:12.260"}, "18160321": {"ParentId": "18160290", "CommentCount": "0", "Body": "<p>The line</p>\n<pre><code>typedef long double Money;\n</code></pre>\n<p>is a give away</p>\n<p>i.e. <code>a</code> is of type <code>Money</code> and <code>Money</code> is a <code>long double</code></p>\n", "OwnerUserId": "892256", "PostTypeId": "2", "Id": "18160321", "Score": "0", "CreationDate": "2013-08-10T08:59:40.167", "LastActivityDate": "2013-08-10T08:59:40.167"}, "18160419": {"ParentId": "18160290", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In the standard it is said :</p>\n<blockquote>\n<p id=\"so_18160290_18160419_0\"><strong>7.1.3 The typedef speci\ufb01er [dcl.typedef ]</strong></p>\n<p id=\"so_18160290_18160419_1\">In a given scope, a typedef speci\ufb01er shall not be used to rede\ufb01ne the name of any type declared in that scope to refer to a different type.</p>\n</blockquote>\n<p>It means that C++ requires that <code>Money</code> has to be of the same type when it's first seen and later reevaluated.</p>\n<p>You program is not valid because the first time <code>Money</code> is evaluated it's of type <code>double</code> and when it's reevaluated it's of type <code>long double</code>... All in the class scope...</p>\n<p>If you remove you <code>get()</code> function for example, <code>Money</code> will be evaluated as <code>long double</code> when you will declare <code>a</code>.</p>\n<hr>\n<p>From the comments, I'm trying to explain more what I mean :</p>\n<p>Effectively, the two typedefs are defined in different scopes. But during the first evaluation of <code>Money</code> (for the <code>get()</code> definition), its type is <code>double</code>, due to the typedef done in the global scope.</p>\n<p>Later, with the second typedef, we redefine <code>Money</code> to be of type <code>long double</code>.</p>\n<p>Here we are trying to redefine a type declared before, in the same scope (class scope).</p>\n<hr>\n<p>It seems that Visual Studio 2010 and 2012 are ok with that.</p>\n<p>I tested it with g++ 4.2.1 and 4.8.1 and I'm getting this error :</p>\n<pre><code>error: declaration of \u2018typedef long double Person::Money\u2019\nerror: changes meaning of \u2018Money\u2019 from \u2018typedef double Money\u2019\n</code></pre>\n</hr></hr>", "OwnerUserId": "1394283", "LastEditorUserId": "1394283", "LastEditDate": "2013-08-10T09:58:17.547", "Id": "18160419", "Score": "3", "CreationDate": "2013-08-10T09:12:04.320", "LastActivityDate": "2013-08-10T09:58:17.547"}, "18160335": {"ParentId": "18160290", "CommentCount": "0", "Body": "<p>This is invalid C++ code, so there is no answer to your question. C++ requires that when <code>Money</code> is first seen, and when <code>Money</code> is later reevaluated, it is the same type in both cases. GCC generates a hard error for this. Other compilers may accept it, but if they do, the standard does not say which typedef is used.</p>\n<p>If you remove your <code>get()</code> function, the type of <code>a</code> is <code>long double</code>, since the local typedef shadows the global one. In that case, the local typedef appears before <code>Money</code> is used, and there is no issue.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "18160335", "Score": "1", "CreationDate": "2013-08-10T09:00:07.003", "LastActivityDate": "2013-08-10T09:00:07.003"}, "18160461": {"ParentId": "18160290", "CommentCount": "4", "Body": "<p>The easiest way is to check it:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef char Money;\n\nclass Person\n{\n    public:\n        void checkType()\n    {\n        if (sizeof(char) == sizeof(long))\n        {\n            std::cout &lt;&lt; \"This test is bullshit\" &lt;&lt; std::endl;\n\n        else if (sizeof(Money) == sizeof(char))\n        {\n            std::cout &lt;&lt; \"It's a char. Global scope is what matters\" &lt;&lt; std::endl;\n        }\n        else if (sizeof(Money) == sizeof(long))\n        {\n            std::cout &lt;&lt; \"It's a long. Inner scope is what matters\" &lt;&lt; std::endl;\n        }\n    }\n\n    private:\n        typedef long Money;\n};\n\nint main()\n{\n  Person p;\n\n  p.checkType();\n\n  system(\"pause\");\n\n  return 0;\n}\n</code></pre>\n<p>And the answer is.... long! (in VS2012, anyway)</p>\n", "OwnerUserId": "2657990", "PostTypeId": "2", "Id": "18160461", "Score": "0", "CreationDate": "2013-08-10T09:17:06.843", "LastActivityDate": "2013-08-10T09:17:06.843"}, "18160290": {"CommentCount": "5", "ViewCount": "113", "PostTypeId": "1", "LastEditorUserId": "2223579", "CreationDate": "2013-08-10T08:55:44.933", "LastActivityDate": "2013-08-10T10:12:12.260", "Title": "what\u2019s the type of this class member a?", "LastEditDate": "2013-08-10T09:09:40.457", "Id": "18160290", "Score": "0", "Body": "<p>My code is :</p>\n<pre><code>typedef double Money;\nclass Person\n{\n    Money get(){return a;}\nprivate:\n    typedef long double Money;\n    Money a;\n};\n</code></pre>\n<p>I define this class, I want to know the type of <code>a</code>: <code>double</code> or <code>long double</code>?</p>\n<p>the return type of function <code>get()</code> is <code>double</code>, is it right?</p>\n<p>I have used function <code>std:is_same</code> to test the type of <code>a</code></p>\n<pre><code>typedef double Money;\nclass Person\n{\npublic:\n    Money get(){return a;}\n    void test()\n    {\n        cout&lt;&lt;is_same&lt;decltype(a), double&gt;::value&lt;&lt;endl;  // false\n        cout&lt;&lt;is_same&lt;decltype(a), long double&gt;::value&lt;&lt;endl; //true\n    }\nprivate:\n    typedef long double Money;\n    Money a;\n};\n</code></pre>\n<p>so the type of <code>a</code> is <code>long double</code>.</p>\n", "Tags": "<c++>", "OwnerUserId": "2223579", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_18160290_18160890_1": {"section_id": 7070, "quality": 1.0, "length": 11}, "so_18160290_18160419_1": {"section_id": 5412, "quality": 0.8333333333333334, "length": 10}, "so_18160290_18160890_0": {"section_id": 7070, "quality": 1.0, "length": 15}}, "n3337": {"so_18160290_18160890_1": {"section_id": 6814, "quality": 1.0, "length": 11}, "so_18160290_18160419_1": {"section_id": 5207, "quality": 0.8333333333333334, "length": 10}, "so_18160290_18160890_0": {"section_id": 6814, "quality": 1.0, "length": 15}}, "n4659": {"so_18160290_18160419_1": {"section_id": 6834, "quality": 0.8333333333333334, "length": 10}, "so_18160290_18160890_0": {"section_id": 8568, "quality": 1.0, "length": 15}}}});