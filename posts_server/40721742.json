post_cb({"40721742": {"CommentCount": "0", "ViewCount": "93", "PostTypeId": "1", "LastEditorUserId": "2805305", "CreationDate": "2016-11-21T13:47:47.963", "LastActivityDate": "2016-11-21T14:38:34.450", "Title": "Bit operations with integer promotion", "AcceptedAnswerId": "40722601", "LastEditDate": "2016-11-21T14:05:22.447", "Id": "40721742", "Score": "2", "Body": "<p>tl;dr Is bit manipulation safe and behaving as expected when it goes through integer promotion (with types shorter than <code>int</code>)?</p>\n<p>e.g.</p>\n<pre><code>uint8_t a, b, c;\na = b &amp; ~c;\n</code></pre>\n<hr>\n<p>This is a rough MCVE of what I have:</p>\n<pre><code>struct X { // this is actually templated\n  using U = unsigned; // U is actually a dependent name and can change\n  U value;\n};\n\ntemplate &lt;bool B&gt; auto foo(X x1, X x2) -&gt; X\n{\n  if (B)\n    return {x1.value | x2.value};\n  else\n    return {x1.value &amp; ~x2.value};\n}\n</code></pre>\n<p>This works great, but when <code>U</code> is changed to a integer type shorter than <code>int</code>, e.g. <code>std::uint8_t</code> then due to integer promotions I get a warning:</p>\n<blockquote>\n<p id=\"so_40721742_40721742_0\">warning: narrowing conversion of '(int)(((unsigned\n  char)((int)x1.X::value)) | ((unsigned char)((int)x2.X::value)))' from\n  'int' to 'X::U {aka unsigned char}' inside { } [-Wnarrowing]</p>\n</blockquote>\n<p>So I added a <code>static_cast</code>:</p>\n<pre><code>struct X {\n  using U = std::uint8_t;\n  U value;\n};\n\ntemplate &lt;bool B&gt; auto foo(X x1, X x2) -&gt; X\n{\n  if (B)\n    return {static_cast&lt;X::U&gt;(x1.value | x2.value)};\n  else\n    return {static_cast&lt;X::U&gt;(x1.value &amp; ~x2.value)};\n}\n</code></pre>\n<p>The question: Can the integer promotion and then the narrowing cast mess with the intended results (*)? Especially since these are casts change signedness back and forward (<code>unsigned char</code> -&gt; <code>int</code> -&gt; <code>unsigned char</code>). What about if <code>U</code> is signed, i.e. <code>std::int8_t</code> (it won't be signed in my code, but curious about the behavior if it would be).</p>\n<p>My common sens says the code is perfectly ok, but my C++ paranoia says there is at least a chance of implementation defined behavior.</p>\n<p>(*) is case it's not clear (or I messed up) the intended behavior is to set or clear the bits (<code>x1</code> is the value, <code>x2</code> is the mask, <code>B</code> is the set/clear op)</p>\n</hr>", "Tags": "<c++><bit-manipulation><integer-promotion>", "OwnerUserId": "2805305", "AnswerCount": "1"}, "40722601": {"ParentId": "40721742", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>If you use unsigned types, all will be OK. The standard mandates that for unsigned target integer types, narrowing is perfectly defined:</p>\n<blockquote>\n<p id=\"so_40721742_40722601_0\">4.7 Integral conversions [conv.integral]\n  <br/>...<br/>\n  2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2n where n is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>But if the target type is signed, the result is <em>implementation defined</em>, per the next paragraph (emphasize mine):</p>\n<blockquote>\n<p id=\"so_40721742_40722601_1\">3 If the destination type is signed, the value is unchanged if it can be represented in the destination type;\n  otherwise, the value is <strong>implementation-defined</strong>.</p>\n</blockquote>\n<p>In common implementations everything will be ok because it is simpler for the compiler to simply do narrowing conversions by only keeping low level bytes for either unsigned or signed types. But the standard only requires that the implementation <em>defines</em> what will happen. An implementation could document that narrowing a value to a signed type when the original value cannot be represented in the target type gives <code>0</code>, and still be conformant.</p>\n<hr>\n<p>By the way, as C++ and C often process conversions the same way, it should be noted that C standard is slightly different because the last case could raise a signal:</p>\n<blockquote>\n<p id=\"so_40721742_40722601_2\">6.3.1.3 [Conversions] Signed and unsigned integers\n  <br/>...<br/>3 Otherwise, the new type is signed and the value cannot be represented in it; either the\n  result is implementation-defined <strong>or an implementation-defined signal is raised</strong>.</p>\n</blockquote>\n<p>Still a confirmation that C and C++ are different languages...</p>\n</hr>", "OwnerUserId": "3545273", "LastEditorUserId": "3545273", "LastEditDate": "2016-11-21T14:38:34.450", "Id": "40722601", "Score": "2", "CreationDate": "2016-11-21T14:32:15.163", "LastActivityDate": "2016-11-21T14:38:34.450"}, "bq_ids": {"n4140": {"so_40721742_40722601_1": {"section_id": 32, "quality": 0.9166666666666666, "length": 11}, "so_40721742_40722601_0": {"section_id": 31, "quality": 0.8571428571428571, "length": 18}}, "n3337": {"so_40721742_40722601_1": {"section_id": 29, "quality": 0.9166666666666666, "length": 11}, "so_40721742_40722601_0": {"section_id": 28, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_40721742_40722601_1": {"section_id": 32, "quality": 0.9166666666666666, "length": 11}, "so_40721742_40722601_0": {"section_id": 31, "quality": 0.8571428571428571, "length": 18}}}});