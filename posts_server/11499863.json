post_cb({"11499863": {"CommentCount": "0", "ViewCount": "1765", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2012-07-16T07:30:14.210", "LastActivityDate": "2012-07-18T06:17:04.670", "Title": "ambiguous partial specializations with std::enable_if", "FavoriteCount": "2", "LastEditDate": "2012-07-16T12:03:33.053", "Id": "11499863", "Score": "6", "Body": "<p>I have a problem encountered at a condtion like below:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n#define TRACE void operator()() const { std::cerr &lt;&lt; \"@\" &lt;&lt; __LINE__ &lt;&lt; std::endl; }\n\ntemplate &lt;class T&gt;\nstruct check : std::true_type {};\n\ntemplate &lt;class F, class T, class Check=void&gt;\nstruct convert {\n  TRACE;// first case\n};\n\ntemplate &lt;class F, class T&gt;\nstruct convert&lt;F*, T, typename std::enable_if&lt;(check&lt;F&gt;::value &amp;&amp; check&lt;T&gt;::value), void&gt;::type&gt; {\n  TRACE; // second case\n};\n\ntemplate &lt;class T&gt;\nstruct convert&lt;int*, T, typename std::enable_if&lt;(check&lt;T&gt;::value), void&gt;::type&gt; {\n  TRACE; // third case\n};\n</code></pre>\n<p>Then </p>\n<pre><code>convert&lt;int*, int&gt; c;\nc();\n</code></pre>\n<p>will report ambiguous class template instantiation in g++-4.5, g++-4.6, g++-4.7 and clang++-3.1(all with option -std=c++0x)</p>\n<p>But if i replace the check in third case to </p>\n<pre><code>typename std::enable_if&lt;(check&lt;int&gt;::value &amp;&amp; check&lt;T&gt;::value), void&gt;:type\n</code></pre>\n<p>Then clang++-3.1 works fine.</p>\n<p>Is it compilers bug or by standard?</p>\n", "Tags": "<c++><templates><partial-specialization><disambiguation>", "OwnerUserId": "988809", "AnswerCount": "2"}, "11500029": {"ParentId": "11499863", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You have </p>\n<pre><code>template &lt;class F, class T&gt;\nstruct convert&lt;F*, T, typename std::enable_if&lt;(check&lt;F&gt;::value &amp;&amp; check&lt;T&gt;::value), void&gt;::type&gt; {\n  TRACE; // second case\n};\n</code></pre>\n<p>and</p>\n<pre><code>template &lt;class T&gt;\nstruct convert&lt;int*, T, typename std::enable_if&lt;(check&lt;T&gt;::value), void&gt;::type&gt; {\n  TRACE; // third case\n};\n</code></pre>\n<p>When you use <code>convert&lt;int*, int&gt; c;</code>, the compiler can't chose which of the structs he needs to use, because they both fit. </p>\n<p>Note that you use <code>check&lt;F&gt;::value</code> in the first template. That means even if you pass, for example, an <code>int *</code>, you will have <code>check&lt;int&gt;::value</code>, not <code>check&lt;int *&gt;::value</code></p>\n", "OwnerUserId": "1490355", "LastEditorUserId": "1490355", "LastEditDate": "2012-07-16T07:49:48.483", "Id": "11500029", "Score": "0", "CreationDate": "2012-07-16T07:44:40.263", "LastActivityDate": "2012-07-16T07:49:48.483"}, "bq_ids": {"n4140": {"so_11499863_11501098_0": {"section_id": 330, "quality": 0.8787878787878788, "length": 29}}, "n3337": {"so_11499863_11501098_0": {"section_id": 320, "quality": 0.8787878787878788, "length": 29}}, "n4659": {"so_11499863_11501098_0": {"section_id": 339, "quality": 0.8787878787878788, "length": 29}}}, "11501098": {"ParentId": "11499863", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A similar issues arose in this <a href=\"https://stackoverflow.com/q/1180325/819272\">question</a></p>\n<p>Because both the second and third partial specializations are a match for <code>convert&lt;int*, int&gt;</code>, the compiler will build two test function templates with the two partially specialized class templates supplied as arguments:</p>\n<pre><code>template &lt;class F, class T&gt; \nvoid fun2(convert&lt;F*, T, typename std::enable_if&lt;\n    (check&lt;F&gt;::value &amp;&amp; check&lt;T&gt;::value), void&gt;::type&gt;\n);\n\ntemplate &lt;class T&gt; \nvoid fun3(convert&lt;int*, T, typename std::enable_if&lt;\n    (check&lt;T&gt;::value), void&gt;::type&gt;\n);\n</code></pre>\n<p>The compiler then checks whether one function template is more specialized than the other by cross-substituting a set of transformed-parameters of one function into the other, and check whether all the template arguments can be deduced. If this works both ways, then neither function is more specialized than the other and ambiguity ensues.</p>\n<p>The problem here is that the <code>std::enable_if&lt;\n        (check&lt;F&gt;::value &amp;&amp; check&lt;T&gt;::value), void&gt;::type&gt;</code> is a non-deduced context, that will not be evaluated during this argument deduction game. The compiler only checks if the general expressions have the same structural form (where anything in front of a <code>::</code> delimiter is deduced), not if they have the same value (<code>true_type</code> in this case). </p>\n<p>Only by adding the extra <code>check&lt;int&gt;::value</code> in the third partial specialization, does the third specialization become more specialized than the second. Another \"fix\" would be to manually put <code>true_type</code> into the <code>Check</code> parameter, however, the compiler does not do that for you during argument deduction.</p>\n<p><strong>UPDATE</strong>: In response to Johannes Schaub - litb: you're right, the code with the <code>std::check&lt;int&gt;</code> put into the <code>std::enable_if</code> doesn't compile on Ideone and MSVC++ 2010. What to make of it? According to <strong>14.8.2.4 clause 11 [temp.deduct.partial]</strong> </p>\n<blockquote>\n<p id=\"so_11499863_11501098_0\">In most cases, all template parameters must have values in order for\n  deduction to succeed, but for partial ordering purposes a template\n  parameter may remain without a value provided it is not used in the\n  types being used for partial ordering. [ Note: A template parameter\n  used in a non-deduced context is considered used. \u2014 end note ]\n  [Example:</p>\n<pre><code>template &lt;class T&gt; T f(int); // #1\ntemplate &lt;class T, class U&gt; T f(U); // #2\nvoid g() {\n    f&lt;int&gt;(1); // calls #1\n}\n</code></pre>\n</blockquote>\n<p>For the code by the OP, I interpret this that the unused parameter would be the <code>std::enable_if</code> expression. My guess would be that Clang 3.1 does some expression matching that Ideone and MSVC++ don't do. I don't understand if in the context of the above quote, this is required or not by the Standard: should only unused template parameters be ignored, or also unused template expressions? There are other parts in the Standard where phrases like \"not requiring implementations to use heroic e\ufb00orts\" appear. Perhaps Clang is more heroic than MSVC++ or Ideone in this respect.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:44.250", "Id": "11501098", "Score": "0", "CreationDate": "2012-07-16T09:04:18.920", "LastActivityDate": "2012-07-18T06:17:04.670"}});