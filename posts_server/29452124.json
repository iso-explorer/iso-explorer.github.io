post_cb({"29457645": {"Id": "29457645", "PostTypeId": "2", "Body": "<p>I found a way to let the compiler and interal mechanism to figure it out for me. I don't have a problem with cross compiling, in that case <code>::std::type_info</code> isn't consistent, either.</p>\n<pre><code>typedef void (*throw_op)(void*);\nthrow_op dataThrow;\n\ntemplate&lt;typename T&gt;\n[[ noreturn ]] void throwing(void* data)\n{\n    throw static_cast&lt;T*&gt;(data);\n}\n[[ noreturn ]] void bad_cast()\n{\n    throw ::std::bad_cast{};\n}\n\ntemplate&lt;typename B&gt;\nB&amp; poly_load()\n{\n    if(data == nullptr)\n        bad_cast();\n    try {\n        dataThrow(data);\n    } catch (B* ptr) {\n        return *ptr;\n    } catch (...) {\n        bad_cast();\n    }\n}\n</code></pre>\n<p>All you have to do is add the following line to the store operation:</p>\n<pre><code>dataThrow = throwing&lt;D&gt;;\n</code></pre>\n<hr>\n<p>How does this work? It takes advantages of exceptions and how they are caught. Note here that this makes <code>poly_load</code> ?much? slower than the simple <code>load</code> function, thus I'll keep the both around.</p>\n<p>C++ says that when an exception of type <code>D*</code> is being thrown you can catch that exception with a catch-clause <code>B*</code> where <code>B</code> is any ancestor of <code>D</code>.</p>\n<p>Minimal example:</p>\n<pre><code>struct Base {\n    virtual ~Base() {}\n    virtual void foo() = 0;\n};\n\nstruct Derived : public virtual Base {\n    void foo() override {\n        ::std::cout &lt;&lt; \"Hello from Derived\" &lt;&lt; ::std::endl;\n    }\n};\n\nint main() {\n    Derived d{};\n    store(d);\n\n    // .....\n\n    poly_load&lt;Base&gt;().foo();\n}\n</code></pre>\n</hr>", "LastEditorUserId": "3102935", "LastActivityDate": "2015-04-05T13:16:34.570", "Score": "3", "CreationDate": "2015-04-05T13:11:22.833", "ParentId": "29452124", "CommentCount": "1", "LastEditDate": "2015-04-05T13:16:34.570", "OwnerUserId": "3102935"}, "29452928": {"Id": "29452928", "PostTypeId": "2", "Body": "<p>what about something like this:</p>\n<pre><code>void* data;\n\nclass Wrapper{ virtual ~Wrapper()=0; };\ntemplate&lt;typename T&gt; class SpecificWrapper: public Wrapper {\n    public:\n        T* value;\n        Wrapper(T* ptr): value(ptr){}\n        ~Wrapper() {}\n}\n\ntemplate&lt;typename D&gt;\nvoid store(D&amp;&amp; object)\n{\n    Wrapper* wrapper = new SpecificWrapper&lt;D&gt;(&amp;object);\n    if(data!= ::std::nullptr)\n        delete reinterpret_cast&lt;Wrapper*&gt;(data);\n    data = (void*)wrapper;\n}\n\ntemplate&lt;typename B&gt;\nB&amp; load()\n{\n    //always safe because we know type being correct\n    Wrapper *w = reinterpret_cast&lt;Wrapper*&gt;(data);\n    SpecificWrapper&lt;B&gt; * w1 = dynamic_cast&lt;SpecificWrapper&lt;B&gt;&gt;(w);\n\n    if(w1==::std::nullptr) throw ::std::bad_cast{};\n\n    return w1-&gt;value;\n}\n</code></pre>\n<p>The idea is to use a wrapper type hierarchy to do the type erasure while keeping type information. In this way you can statically determine that the type of the <code>data</code> variable even if it is declared as <code>void*</code> is always the top level <code>Wrapper</code> class, allowing you to always perform safe casts. You need to be careful of the lifetime of the wrapper object though...</p>\n", "LastEditorUserId": "686184", "LastActivityDate": "2015-04-05T00:50:55.160", "Score": "-1", "CreationDate": "2015-04-05T00:39:09.437", "ParentId": "29452124", "CommentCount": "4", "LastEditDate": "2015-04-05T00:50:55.160", "OwnerUserId": "686184"}, "29467699": {"Id": "29467699", "PostTypeId": "2", "Body": "<p>The self-answer with exceptions is pretty cool. Here's a self-contained version:</p>\n<pre><code>class polymorphic_erasure {\n    std::function&lt; void() &gt; throw_self;\n\npublic:\n    template&lt; typename static_type &gt;\n    polymorphic_erasure( static_type &amp; o )\n        : throw_self( [ &amp; o ] { throw &amp; o; } )\n        {}\n\n    polymorphic_erasure()\n        : throw_self( [] { throw std::bad_cast(); } )\n        {}\n\n    template&lt; typename want_type &gt;\n    want_type &amp; get() const {\n        try {\n            throw_self();\n        } catch ( want_type * result ) {\n            return * result;\n        } catch ( ... ) {}\n        throw std::bad_cast();\n    }\n};\n</code></pre>\n<p>Demo: <a href=\"http://coliru.stacked-crooked.com/a/a12114a210c77a45\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/a12114a210c77a45</a></p>\n<p>Note, though, that you can't assign with a polymorphic base type and then <code>get</code> the derived object \u2014 you still need a <code>dynamic_cast</code> for that. And there's no RTTI or polymorphism here. (Perhaps it needs a different name.) Although exceptions do use RTTI for classes, <code>polymorphic_erasure</code> only throws pointers. The exception-based functionality is complementary: It classifies the object into a type hierarchy and nothing more.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2015-04-06T08:27:19.823", "Score": "0", "CreationDate": "2015-04-06T08:18:09.667", "ParentId": "29452124", "CommentCount": "0", "LastEditDate": "2015-04-06T08:27:19.823", "OwnerUserId": "153285"}, "29453071": {"Id": "29453071", "PostTypeId": "2", "Body": "<p>Actually, you should be using an equality test on your <code>type_info</code> instances.</p>\n<p><code>reinterpret_cast</code> provides no guarantees except when casting back to the exact original type.  Even</p>\n<pre><code>Derived* d = get_derived();\nBase* b = reinterpret_cast&lt;Base*&gt;(d);\n</code></pre>\n<p>will not give a correct result (if the <code>Base</code> subobject is not stored at offset zero within <code>Derived</code>, which is guaranteed only for standard-layout types).</p>\n<p>The complete rule is found in section 5.2.10:</p>\n<blockquote>\n<p id=\"so_29452124_29453071_0\">An object pointer can be explicitly converted to an object pointer of a different type.     When a prvalue <code>v</code> of object pointer type is converted to the object pointer type \"pointer to <em><code>cv</code></em> <code>T</code>\", the result is <code>static_cast&lt;</code> <em><code>cv</code></em>\n<code>T*&gt;(static_cast&lt;</code> <em><code>cv</code></em> <code>void*&gt;(v))</code>.  Converting a prvalue of type \"pointer to <code>T1</code>\" to the type \"pointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value.</p>\n</blockquote>\n<p>Only <code>static_cast</code> and <code>dynamic_cast</code> can perform base subobject adjustments, and those don't kick in when either type is <code>void*</code> (after type erasure).</p>\n<p>However, it appears that the Boost developers have worked out all the difficulties. See <code>boost::variant::polymorphic_get</code></p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2015-04-05T01:16:19.793", "Score": "1", "CreationDate": "2015-04-05T01:04:16.120", "ParentId": "29452124", "CommentCount": "7", "LastEditDate": "2015-04-05T01:16:19.793", "OwnerUserId": "103167"}, "bq_ids": {"n4140": {"so_29452124_29453071_0": {"length": 46, "quality": 1.0, "section_id": 6046}}, "n3337": {"so_29452124_29453071_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 5814}}, "n4659": {"so_29452124_29453071_0": {"length": 45, "quality": 0.9782608695652174, "section_id": 7545}}}, "29452492": {"Id": "29452492", "PostTypeId": "2", "Body": "<p>As far as I know, the only reliable and portable method for determining derivation is to use dynamic_cast in a try catch block. If it's cast-able, it won't throw a bad_cast exception. Do this test in the your store routine, if it doesn't throw, store the data, otherwise set it to NULL.  Don't forget to check for that in your load routine.</p>\n", "LastEditorUserId": "3150445", "LastActivityDate": "2015-04-05T00:21:26.413", "Score": "0", "CreationDate": "2015-04-04T23:24:00.557", "ParentId": "29452124", "CommentCount": "4", "LastEditDate": "2015-04-05T00:21:26.413", "OwnerUserId": "3150445"}, "29452124": {"ViewCount": "394", "Body": "<p>Is there a way to determine from two <code>const ::std::type_info</code> objects, let's name them <code>B</code> and <code>D</code> if the type described by D is derived from type B?</p>\n<p>I ask because I want to erase the type of an object I get but later on be able to check if it can be safely promoted.</p>\n<pre><code>void* data;\nconst ::std::type_info* D;\n\ntemplate&lt;typename D&gt;\nvoid store(D&amp;&amp; object)\n{\n    D = &amp;typeid(object);\n    data = ::std::addressof(object);\n}\n\ntemplate&lt;typename B&gt;\nB&amp; load()\n{\n    // if(typeid(B) != (*D)) throw ::std::bad_cast{};\n    return *reinterpret_cast&lt;B*&gt;(data); // &lt;- also problematic\n}\n</code></pre>\n<p>I want to be able to use it like this:</p>\n<pre><code>class Base {};\nclass Derived : Base {};\n\nDerived d;\nstore(d);\n// ....\nload&lt;Base&gt;();\n</code></pre>\n<p>Thus it is not suitable to just use an equality compare for the typeids. I am pretty sure this could be possible in a similar way that dynamic_cast can figure this out. What I want is that in every case where <code>D&amp;</code> could be assigned to <code>B&amp;</code> allowing B as the type argument of <code>load()</code> - without knowing <code>D</code> at that time.</p>\n", "AcceptedAnswerId": "29457645", "Title": "Can we determine at runtime if two type_info's would be castable?", "CreationDate": "2015-04-04T22:32:05.823", "Id": "29452124", "CommentCount": "9", "LastEditDate": "2015-04-04T22:57:55.940", "PostTypeId": "1", "LastEditorUserId": "3102935", "LastActivityDate": "2015-04-06T08:27:19.823", "Score": "4", "OwnerUserId": "3102935", "Tags": "<c++><dynamic-cast><typeid><typeinfo>", "AnswerCount": "5"}});