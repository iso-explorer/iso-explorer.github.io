post_cb({"49198185": {"Id": "49198185", "PostTypeId": "2", "Body": "<p>It's valid C++ to emit an error here.</p>\n<p>See [class.member.lookup]:</p>\n<blockquote>\n<p id=\"so_49198037_49198185_0\">If the name of an overloaded function is unambiguously found, <strong>overload resolution  also takes place before\n  access control</strong>.</p>\n</blockquote>\n<p>So the appropriate overload is selected first  (the template), and then access control happens, which causes a compiler error.</p>\n", "LastActivityDate": "2018-03-09T16:31:45.747", "Score": "1", "CreationDate": "2018-03-09T16:31:45.747", "ParentId": "49198037", "CommentCount": "3", "OwnerUserId": "27678"}, "49198037": {"ViewCount": "41", "Body": "<p>I noticed something which I think is pretty interesting behaviour.</p>\n<p>Consider the following example code which I tried to keep as generic as possible:</p>\n<pre><code>class Base\n{\npublic:\n  virtual void func() {}\n};\n\nclass Subclass : public Base\n{\npublic:\n  void func() {}\n};\n\nclass ApplyingClass\n{\npublic:\n  static void callFunc(Base&amp; base) { base.func(); }\nprivate:\n  template &lt;class T&gt;\n  static void callFunc(T&amp; t) { t.func(); }\n};\n\nint main()\n{\n  Subclass s;\n  Base&amp; b = s;\n\n  // Error: ApplyingClass::callFunc(T&amp; t) with T=Subclass is private.\n  ApplyingClass::callFunc(s);\n\n  // works\n  ApplyingClass::callFunc(b);\n\n  return 0;\n}\n</code></pre>\n<p>It seems that inside main(), due to the template method being present, the compiler sees the template \"ApplyingClass::callFunc(T&amp; t)\" as the right fit for the function call \"ApplyingClass::callFunc(s)\" and throws an Error since the method is not accessible from outside it's class.</p>\n<p>This seems logical, yet I expected the compiler to still go and try to use \"ApplyingClass::callFunc(Base&amp; base)\" since the method signature fits and this is the only <i>accessible</i> fitting method.</p>\n<p>To take my point a bit further; if I were to remove the private template method from ApplyingClass, both function calls inside main() would be valid.</p>\n<p>My question now is whether this is part of the C++ specification or if this is compiler specific behaviour (this was tested using the Visual Studio 2017 ver 15.5.7 compiler).</p>\n", "AcceptedAnswerId": "49198185", "Title": "C++ Template Method Overloading and Class Access with Polymorphism", "CreationDate": "2018-03-09T16:23:14.923", "LastActivityDate": "2018-03-09T20:37:38.453", "CommentCount": "0", "LastEditDate": "2018-03-09T20:37:38.453", "PostTypeId": "1", "LastEditorUserId": "2350479", "Id": "49198037", "Score": "1", "OwnerUserId": "2350479", "Tags": "<c++><templates><visual-studio-2017><polymorphism><function-overloading>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_49198037_49198185_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6996}}, "n3337": {"so_49198037_49198185_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6742}}, "n4659": {"so_49198037_49198185_0": {"length": 13, "quality": 1.0, "section_id": 8494}}}});