post_cb({"bq_ids": {"n4140": {"so_32188099_32188647_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 336}, "so_32188099_32188647_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 336}, "so_32188099_32188647_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 336}, "so_32188099_32188647_7": {"length": 9, "quality": 0.9, "section_id": 336}, "so_32188099_32188647_6": {"length": 5, "quality": 0.8333333333333334, "section_id": 336}, "so_32188099_32188647_4": {"length": 9, "quality": 0.9, "section_id": 336}, "so_32188099_32188647_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 336}}, "n3337": {"so_32188099_32188647_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 326}, "so_32188099_32188647_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 326}, "so_32188099_32188647_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 326}, "so_32188099_32188647_7": {"length": 9, "quality": 0.9, "section_id": 326}, "so_32188099_32188647_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 326}, "so_32188099_32188647_4": {"length": 9, "quality": 0.9, "section_id": 326}, "so_32188099_32188647_6": {"length": 5, "quality": 0.8333333333333334, "section_id": 326}}, "n4659": {"so_32188099_32188647_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 345}, "so_32188099_32188647_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 345}, "so_32188099_32188647_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 345}, "so_32188099_32188647_7": {"length": 9, "quality": 0.9, "section_id": 345}, "so_32188099_32188647_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 345}, "so_32188099_32188647_4": {"length": 9, "quality": 0.9, "section_id": 345}, "so_32188099_32188647_6": {"length": 5, "quality": 0.8333333333333334, "section_id": 345}}}, "32188647": {"Id": "32188647", "PostTypeId": "2", "Body": "<p>Since <code>minus</code> is a function template, a compiler won't attempt to deduce type <code>T</code> based on it when used as an argument in a function call for parameter <code>T(*bf)(T,T)</code>, as it's one of the <em>non-deduced contexts</em>:</p>\n<p>\u00a7 14.8.2.5 [temp.deduct.type]/p5:</p>\n<blockquote>\n<p id=\"so_32188099_32188647_0\">The non-deduced contexts are:</p>\n<p id=\"so_32188099_32188647_1\"><sup>(5.5)</sup> \u2014 A function parameter for which argument deduction cannot be done because the associated function\n  argument is a function, or a set of overloaded functions (13.4), and one or more of the following apply:</p>\n<blockquote>\n<p id=\"so_32188099_32188647_5\"><sup>(5.5.1)</sup> \u2014 more than one function matches the function parameter type (resulting in an ambiguous deduction), or</p>\n<p id=\"so_32188099_32188647_6\"><sup>(5.5.2)</sup> \u2014 no function matches the function parameter type, or</p>\n<p id=\"so_32188099_32188647_7\"><sup>(5.5.3)</sup> \u2014 <strong>the set of functions supplied as an argument contains one or more function templates.</strong></p>\n</blockquote>\n</blockquote>\n<p>As such, type <code>T</code> is deduced based on the first and the second arguments (vectors), and then used to define the function pointer type itself. This is why it works for a <em>plain</em> function.</p>\n<hr>\n<blockquote>\n<p id=\"so_32188099_32188647_8\"><em>I expected to be able to abstract out the lambda expression by writing a higher-order function lift_binary that takes a <code>T(*)(T,T)</code> as a parameter because I thought that's the type of the lambda.</em></p>\n</blockquote>\n<p>A lambda has some implementation-defined and unique type. Conversion to a function pointer is possible, since the lambda's type defines a conversion operator for that purpose. However, a compiler doesn't consider a lambda expression as a set of overloaded functions and tries to deduce type <code>T</code> based on what you pass as the argument for <code>T(*bf)(T,T)</code>. Obviously, this is bound to fail, because lambda's (class-)type can't be matched against a function pointer type.</p>\n<p>To work around that, you can make <code>T</code> for this parameter <em>non-deducible</em> on your own (this is known as the <a href=\"https://stackoverflow.com/a/31942739/3953764\">identity trick</a>):</p>\n<pre><code>template &lt;typename T&gt; struct identity { using type = T; };\ntemplate &lt;typename T&gt; using identity_t = typename identity&lt;T&gt;::type;\n\ntemplate&lt;typename T&gt;\nvector&lt;T&gt; lift_binary (const vector&lt;T&gt; &amp; v1\n                     , const vector&lt;T&gt; &amp; v2\n                     , identity_t&lt;T(T,T)&gt;* bf);\n//                     ~~~~~~~~~~~~~~~~~~^\n\n// ...\n\nlift_binary(v1, v2, [] (auto x, auto y) { return x - y; } );\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/da36d2d93b0ec09f\" rel=\"nofollow noreferrer\"><strong>DEMO</strong></a></p>\n<p>For a non-generic lambda, you can instead force its conversion to a pointer to a function at the call site with an unary plus operator:</p>\n<pre><code>lift_binary(v1, v2, +[] (T x, T y) { return x - y; });\n//                  ^\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b60d9f45680fa6e9\" rel=\"nofollow noreferrer\"><strong>DEMO 2</strong></a></p>\n<p>Or explicitly cast a generic lambda, (also at the call site), so that it can match <code>T(*)(T,T)</code>:</p>\n<pre><code>lift_binary(v1, v2, static_cast&lt;T(*)(T,T)&gt;([] (auto x, auto y) { return x - y; }));\n//                  ~~~~~~~~~~~~~~~~~~~~~^\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/06526f11cc57383b\" rel=\"nofollow noreferrer\"><strong>DEMO 3</strong></a></p>\n<p>...Or, since <code>T</code> has been already deduced in <code>operator-</code>, you can pass it in a template argument list:</p>\n<pre><code>return lift_binary&lt;T&gt;(v1, v2, [] (auto x, auto y) { return x - y; } );\n//                ~~^\n</code></pre>\n<hr>\n<p>Side note: you can always declare the <code>lift_binary</code> function as follows:</p>\n<pre><code>template &lt;typename T, typename F&gt;     \nauto lift_binary(const vector&lt;T&gt;&amp; v1, const vector&lt;T&gt;&amp; v2, F bf)\n</code></pre>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-24T18:55:28.977", "Score": "3", "CreationDate": "2015-08-24T17:55:56.290", "ParentId": "32188099", "CommentCount": "2", "OwnerUserId": "3953764", "LastEditDate": "2017-05-23T12:07:41.530"}, "32188099": {"ViewCount": "243", "Body": "<p>From these SE questions, <a href=\"https://stackoverflow.com/questions/28746744/passing-lambda-as-function-pointer\">Passing lambda as function pointer</a>, <a href=\"https://stackoverflow.com/questions/8109571/lambda-as-function-parameter\">Lambda as function parameter</a>, <a href=\"https://stackoverflow.com/questions/16750624/cannot-pass-lambda-function-as-function-reference\">Cannot pass lambda function as function reference?</a>, I'm given to understand that I may pass stateless, non-capturing lambdas to functions that expect function pointers.  Accordingly, I try a template to lift a binary function of type <code>T (*bf)(T, T)</code> over <code>std::vectors</code>:</p>\n<pre><code>template&lt;typename T&gt;\nvector &lt;T&gt; lift_binary (const vector&lt;T&gt; &amp; v1, const vector&lt;T&gt; &amp; v2, \n        T (* bf)(T, T))\n{   auto result = vector&lt;T&gt; ();\n    result.resize(v1.size());\n    transform (v1.begin(), v1.end(), v2.begin(), result.begin(), bf);\n    return result;   }\n</code></pre>\n<p>This works when <code>bf</code> is a named function, for example</p>\n<pre><code>template&lt;typename T&gt; T minus (T x, T y) { return x - y; }\n\ntemplate&lt;typename T&gt;\nvector&lt;T&gt; operator- (const vector&lt;T&gt; &amp;v1, const vector&lt;T&gt; &amp;v2)\n{   return lift_binary (v1, v2, minus);   }\n\nint main()\n{   auto v1 = vector&lt;double&gt; ({1, 2, 3});\n    auto v2 = vector&lt;double&gt; ({10, 20, 30});\n    auto v3 = v1 - v2;\n    cout &lt;&lt; v3[0] &lt;&lt; \" \" &lt;&lt; v3[1] &lt;&lt; \" \" &lt; v3[2] &lt;&lt; \" \" &lt;&lt; endl;\n    return 0;   }\n</code></pre>\n<p>produces</p>\n<blockquote>\n<p id=\"so_32188099_32188099_0\">-9 -18 -27</p>\n</blockquote>\n<p>But it's no good with any of the three following lambda functions (the second one is uncommented, for instance):</p>\n<pre><code>template&lt;typename T&gt;\nvector&lt;T&gt; operator- (const vector&lt;T&gt; &amp;v1, const vector&lt;T&gt; &amp;v2)\n// {   return lift_binary (v1, v2, [] (T x, T y) -&gt; T { return x - y; } );   }\n   {   return lift_binary (v1, v2, [] (T x, T y) { return x - y; } );   }\n// {   return lift_binary (v1, v2, [] (auto x, auto y) { return x - y; } );   }\n// {   return lift_binary (v1, v2, minus);   }\n</code></pre>\n<p>When compiled like this</p>\n<pre><code>g++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>The compiler can't match the parameter type <code>T (*bf)(T, T)</code> against the types of the lambdas:</p>\n<pre><code>main.cpp: In instantiation of 'std::vector&lt;_RealType&gt; operator-(const std::vector&lt;_RealType&gt;&amp;, const std::vector&lt;_RealType&gt;&amp;) [with T = double]':\nmain.cpp:37:20:   required from here\nmain.cpp:26:31: error: no matching function for call to 'lift_binary(const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;, operator-(const std::vector&lt;_RealType&gt;&amp;, const std::vector&lt;_RealType&gt;&amp;) [with T = double]::&lt;lambda(double, double)&gt;)'\n        {   return lift_binary (v1, v2, [] (T x, T y) { return x - y; } );   }\n                               ^\nmain.cpp:13:16: note: candidate: template&lt;class T&gt; std::vector&lt;_RealType&gt; lift_binary(const std::vector&lt;_RealType&gt;&amp;, const std::vector&lt;_RealType&gt;&amp;, T (*)(T, T))\n     vector &lt;T&gt; lift_binary (const vector&lt;T&gt; &amp; v1, const vector&lt;T&gt; &amp; v2, T (* bf)(T, T))\n                ^\nmain.cpp:13:16: note:   template argument deduction/substitution failed:\nmain.cpp:26:31: note:   mismatched types 'T (*)(T, T)' and 'operator-(const std::vector&lt;_RealType&gt;&amp;, const std::vector&lt;_RealType&gt;&amp;) [with T = double]::&lt;lambda(double, double)&gt;'\n        {   return lift_binary (v1, v2, [] (T x, T y) { return x - y; } );   }\n</code></pre>\n<p>I get comparable errors with the other two lambda expressions.  This leads me to think that no kind of generic lambda will match the parameter's function pointer type, but that doesn't jibe with what I have been able to find and read.  I must be doing something else wrong.</p>\n<p>Here is a coliru project with this sample online:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/77756b84eb401156\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/77756b84eb401156</a></p>\n<p>and here is the entire code snippet in a block:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt; \n\nusing std::cout;\nusing std::endl;\nusing std::vector;\n\ntemplate&lt;typename T&gt;\nvector &lt;T&gt; lift_binary (const vector&lt;T&gt; &amp; v1, const vector&lt;T&gt; &amp; v2, T (* bf)(T, T))\n{   auto result = vector&lt;T&gt; ();\n    result.resize(v1.size());\n    transform (v1.begin(), v1.end(), v2.begin(), result.begin(), bf);\n    return result;   }\n\ntemplate&lt;typename T&gt;\nT minus (T x, T y)\n{   return x - y;   }\n\ntemplate&lt;typename T&gt;\nvector&lt;T&gt; operator- (const vector&lt;T&gt; &amp;v1, const vector&lt;T&gt; &amp;v2)\n// {   return lift_binary (v1, v2, [] (T x, T y) -&gt; T { return x - y; } );   }\n   {   return lift_binary (v1, v2, [] (T x, T y) { return x - y; } );   }\n// {   return lift_binary (v1, v2, [] (auto x, auto y) { return x - y; } );   }\n// {   return lift_binary (v1, v2, minus);   }\n\ntemplate&lt;typename T&gt;\nvector&lt;T&gt; operator+(const vector&lt;T&gt; &amp; v1, const vector&lt;T&gt; &amp; v2)\n{   return lift_binary (v1, v2, [] (T x, T y) -&gt; T { return x + y; } );   }\n\nint main()\n{   auto v1 = vector&lt;double&gt; ({1, 2, 3});\n    auto v2 = vector&lt;double&gt; ({10, 20, 30});\n    auto v3 = v1 - v2;\n    cout &lt;&lt; v3[0] &lt;&lt; \" \" \n         &lt;&lt; v3[1] &lt;&lt; \" \" \n         &lt;&lt; v3[2] &lt;&lt; \" \" &lt;&lt; endl;\n    return 0;   }\n</code></pre>\n<p><strong>EDIT</strong>:</p>\n<p>The following works:</p>\n<pre><code>template&lt;typename T&gt;\nvector&lt;T&gt; operator- (const vector&lt;T&gt; &amp;v1, const vector&lt;T&gt; &amp;v2)\n{   auto result = vector&lt;T&gt; ();\n    result.resize(v1.size());\n    transform (v1.begin(), v1.end(), v2.begin(), result.begin(),\n               [] (T x, T y) { return x - y; } );\n    return result;   }\n</code></pre>\n<p>and the whole motivation for the original question is just to allow me to abstract over this pattern so that I DRY (don't repeat your(my)self) when implementing other binary operators like <code>+</code>, <code>*</code>, etc.</p>\n<p>I expected to be able to abstract out the lambda expression by writing a higher-order function <code>lift_binary</code> that takes a <code>T(*)(T,T)</code> as a parameter because I thought that's the type of the lambda.</p>\n", "AcceptedAnswerId": "32188647", "Title": "binary generic lambda not matching ptr-to-function parameters?", "CreationDate": "2015-08-24T17:25:12.437", "Id": "32188099", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:51.780", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-24T18:55:28.977", "Score": "1", "OwnerUserId": "520997", "Tags": "<c++><lambda><c++14>", "AnswerCount": "1"}});