post_cb({"38584106": {"ParentId": "38583989", "LastEditDate": "2016-07-26T15:28:10.737", "CommentCount": "3", "CreationDate": "2016-07-26T07:55:55.903", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "PostTypeId": "2", "Id": "38584106", "Score": "8", "Body": "<p>Because the initialization of a static data member is considered part of the characterization of the class even though the static data member is defined at namespace scope (outside the class definition).</p>\n<p>From the standard, <a href=\"http://eel.is/c++draft/class.static.data#2\" rel=\"nofollow\">$9.2.3.2/2 Static data members\n[class.static.data]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_38583989_38584106_0\"><strong>The initializer expression in the definition of a static data member is in the scope of its class</strong> ([basic.scope.class]).</p>\n<p id=\"so_38583989_38584106_1\">[ Example:</p>\n<pre><code>class process {\n  static process* run_chain;\n  static process* running;\n};\n\nprocess* process::running = get_main();\nprocess* process::run_chain = running;\n</code></pre>\n<p id=\"so_38583989_38584106_2\">The static data member <code>run_chain</code> of class <code>process</code> is defined in global\n  scope; the notation <code>process::run_chain</code> specifies that the member\n  <code>run_chain</code> is a member of class <code>process</code> and in the scope of class\n  <code>process</code>. In the static data member definition, the initializer\n  expression refers to the static data member <code>running</code> of class <code>process</code>. \n  \u2014 end example ]</p>\n</blockquote>\n", "LastActivityDate": "2016-07-26T15:28:10.737"}, "38583989": {"CommentCount": "0", "ViewCount": "180", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-07-26T07:49:56.530", "LastActivityDate": "2016-07-26T15:28:10.737", "Title": "Access to private static function during static member initialization", "AcceptedAnswerId": "38584106", "LastEditDate": "2017-05-23T12:22:59.840", "Id": "38583989", "Score": "10", "Body": "<p>I have a class with a static member. This will be initialized using a private static function of the same class. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass A\n{\npublic:\n    static std::string const s;\n\nprivate:\n    static std::string make()\n    {\n        return \"S\";\n    }\n};\n\nstd::string const A::s = A::make();\n\nint main()\n{\n    std::cout &lt;&lt; A::s &lt;&lt; std::endl;\n    // std::cout &lt;&lt; A::make() &lt;&lt; std::endl; // &lt;-- Does not work\n    return 0;\n}\n</code></pre>\n<p>My question is: Because of which rule is this allowed? Clearly the commented part does not work, because I am not allowed to access a private function from outside the class. So why is the initialization of the private static member during startup a special case? (And on a side note: what is the intention of this rule? Is it to allow this exact case?)</p>\n<p>I am aware of other mechanisms to initialize a static member (like here: <a href=\"https://stackoverflow.com/questions/185844/initializing-private-static-members\">Initializing private static members</a>). But in my case the member is const, so as far as I know the only way to set it is via direct initalization at the place of definition.</p>\n", "Tags": "<c++><initialization><language-lawyer><static-methods><static-members>", "OwnerUserId": "4773496", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38583989_38584106_0": {"section_id": 5907, "quality": 0.8181818181818182, "length": 9}, "so_38583989_38584106_2": {"section_id": 5907, "quality": 0.9166666666666666, "length": 33}}, "n3337": {"so_38583989_38584106_0": {"section_id": 5679, "quality": 0.8181818181818182, "length": 9}, "so_38583989_38584106_2": {"section_id": 5679, "quality": 0.9166666666666666, "length": 33}}, "n4659": {"so_38583989_38584106_0": {"section_id": 7389, "quality": 0.8181818181818182, "length": 9}, "so_38583989_38584106_2": {"section_id": 7389, "quality": 0.9444444444444444, "length": 34}}}});