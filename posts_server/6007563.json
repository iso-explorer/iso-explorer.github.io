post_cb({"6007870": {"Id": "6007870", "PostTypeId": "2", "Body": "<p>Try this:</p>\n<pre><code>struct push_back {\n    void\n    operator()(std::vector&lt;int&gt;&amp; vector, int i) const\n    {\n        vector.push_back(i);\n    }\n};\n\n// somewhere else:\nstd::vector&lt;int&gt; vec;\nstd::tr1::bind(push_back(), std::tr1::ref(vec), 1)();\n</code></pre>\n<p>With C++03 note that <code>push_back</code> cannot be a local type; with C++11 it can but it would be more idiomatic (and completely equivalent) to use a lambda.</p>\n<p>In all likeliness your implementation provides overloads for <code>std::vector&lt;T&gt;::push_back</code> and thus its address would have to be disambiguated. If this is what happened, your compiler should have provided you with an appropriate error message. In <em>all</em> cases, you should explain what you mean by \"it's not possible\".</p>\n<hr>\n<blockquote>\n<p id=\"so_6007563_6007870_0\">The point is not to use such helper\n  functions. \u2013 magenta</p>\n</blockquote>\n<p>Then why didn't you put it in the question? I can't read your mind.</p>\n<p>You can also try this:</p>\n<pre><code>std::vector&lt;int&gt; vec;\nvoid (std::vector&lt;int&gt;::*push_back)(int const&amp;) = &amp;std::vector&lt;int&gt;::push_back;\nstd::tr1::bind(push_back(), std::tr1::ref(vec), 1)();\n</code></pre>\n<p>Which I believe is not guaranteed to success.</p>\n</hr>", "LastEditorUserId": "726300", "LastActivityDate": "2011-05-15T11:42:31.640", "Score": "3", "CreationDate": "2011-05-15T10:37:45.050", "ParentId": "6007563", "CommentCount": "2", "OwnerUserId": "726300", "LastEditDate": "2011-05-15T11:42:31.640"}, "6007838": {"Id": "6007838", "PostTypeId": "2", "Body": "<p>You should be more specific why this doesn't seem to work for you.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tr1/functional&gt;\n#include &lt;vector&gt;\n\nint main(int argc, char* argv[]) {\n    std::vector&lt;int&gt; vec;\n    std::tr1::bind(&amp;std::vector&lt;int&gt;::push_back, std::tr1::ref(vec), 1)();\n    std::cout &lt;&lt; \"vec.size = \" &lt;&lt; vec.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"vec[0] = \" &lt;&lt; vec[0] &lt;&lt; std::endl;\n    return 0;\n}\n\n$ gcc -o test -lstdc++ test.cpp &amp;&amp; ./test\nvec.size = 1\nvec[0] = 1\n</code></pre>\n<p><strong>Update:</strong> Luc Danton is right, the issue here is the overloaded <code>push_back</code>.  See question <a href=\"https://stackoverflow.com/q/4248357/49604\">Are there boost::bind issues with VS2010 ?</a>.  Also, note that the issue is not limited to <code>push_back</code>, see <a href=\"https://stackoverflow.com/q/2295969/49604\">Visual Studio 2010 and boost::bind</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-15T12:09:21.043", "Score": "5", "CreationDate": "2011-05-15T10:31:10.243", "ParentId": "6007563", "CommentCount": "2", "OwnerUserId": "49604", "LastEditDate": "2017-05-23T11:55:36.037"}, "6008660": {"Id": "6008660", "PostTypeId": "2", "Body": "<p>The bottom line is that what you're trying to do isn't possible in <em>portable</em> C++. <code>std::vector&lt;&gt;::push_back</code> is guaranteed to be overloaded in C++11 compilers, as at a minimum there must be an overload for lvalues and an overload for rvalues.</p>\n<p><em>Usually</em>, when taking the address of an overloaded member function, \u00a713.4/1 in the C++11 FDIS tells us that we can control which overload we're taking the address of thusly:</p>\n<blockquote>\n<p id=\"so_6007563_6008660_0\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a pointer to function or a pointer to member function for a specific function from the overload set. A function template name is considered to name a set of overloaded functions in such contexts. <strong>The function selected is the one whose type is identical to the function type of the target type required in the context.</strong> [ <em>Note:</em> That is, the class of which the function is a member is ignored when matching a pointer-to-member-function type. <em>\u2014end note</em> ] The target can be</p>\n<ul>\n<li>an object or reference being initialized,</li>\n<li>the left side of an assignment,</li>\n<li>a parameter of a function,</li>\n<li>a parameter of a user-defined operator,</li>\n<li>the return value of a function, operator function, or conversion,</li>\n<li><strong>an explicit type conversion</strong>, or</li>\n<li>a non-type template-parameter.</li>\n</ul>\n<p id=\"so_6007563_6008660_1\">The overloaded function name can be preceded by the <code>&amp;</code> operator. An overloaded function name shall not be used without arguments in contexts other than those listed. [ <em>Note:</em> Any redundant set of parentheses surrounding the overloaded function name is ignored. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p><em>The problem</em> comes from \u00a717.6.5.5/2:</p>\n<blockquote>\n<p id=\"so_6007563_6008660_2\">An implementation may declare additional non-virtual member function signatures within a class by adding arguments with default values to a member function signature; <strong>hence, the address of a member function of a class in the C++ standard library has an unspecified type.</strong></p>\n</blockquote>\n<p>Consequently, it is not portable to ever take the address of a standard library class member function, as the type of such an expression is by definition unknowable except on an implementation-by-implementation basis.</p>\n<p>Luc Danton's proposed workaround (specifically, using a lambda) is also what I would recommend:</p>\n<pre><code>std::vector&lt;int&gt; vec;\n[&amp;](){ vec.push_back(1); }();\n</code></pre>\n", "LastEditorUserId": "636019", "LastActivityDate": "2011-05-15T13:31:56.503", "Score": "4", "CreationDate": "2011-05-15T13:24:57.693", "ParentId": "6007563", "CommentCount": "1", "OwnerUserId": "636019", "LastEditDate": "2011-05-15T13:31:56.503"}, "6007563": {"ViewCount": "1830", "Body": "<p>Why my VS2010 can't compile this code:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;vector&gt;\nint main()\n{\n    std::vector&lt;int&gt; vec;\n    std::bind(&amp;std::vector&lt;int&gt;::push_back, std::ref(vec), 1)();\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "6007870", "Title": "Using std::tr1::bind with std::vector::push_back", "CreationDate": "2011-05-15T09:25:46.483", "Id": "6007563", "CommentCount": "4", "LastEditDate": "2011-05-15T18:52:44.223", "PostTypeId": "1", "LastEditorUserId": "754349", "LastActivityDate": "2011-05-15T18:52:44.223", "Score": "2", "OwnerUserId": "754349", "Tags": "<c++><visual-studio-2010><bind>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_6007563_6008660_2": {"length": 24, "quality": 0.96, "section_id": 6341}, "so_6007563_6008660_1": {"length": 23, "quality": 0.8214285714285714, "section_id": 641}, "so_6007563_6008660_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 641}}, "n3337": {"so_6007563_6008660_2": {"length": 24, "quality": 0.96, "section_id": 6098}, "so_6007563_6008660_1": {"length": 23, "quality": 0.8214285714285714, "section_id": 631}, "so_6007563_6008660_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 631}}, "n4659": {"so_6007563_6008660_2": {"length": 14, "quality": 0.56, "section_id": 7709}, "so_6007563_6008660_1": {"length": 23, "quality": 0.8214285714285714, "section_id": 669}, "so_6007563_6008660_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 669}}}, "6007653": {"Id": "6007653", "PostTypeId": "2", "Body": "<p>It should propably lok like this:</p>\n<pre><code>std::vector&lt;int&gt; vec;\nstd::tr1::bind(&amp;std::vector&lt;int&gt;::push_back, std::tr1::ref(vec), _1)(1);\n</code></pre>\n", "LastActivityDate": "2011-05-15T09:48:16.883", "CommentCount": "1", "CreationDate": "2011-05-15T09:48:16.883", "ParentId": "6007563", "Score": "0", "OwnerUserId": "746961"}});