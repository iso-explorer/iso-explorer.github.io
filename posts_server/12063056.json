post_cb({"12063056": {"CommentCount": "6", "ViewCount": "75", "PostTypeId": "1", "LastEditorUserId": "23897", "CreationDate": "2012-08-21T21:07:00.937", "LastActivityDate": "2012-08-22T01:18:17.657", "Title": "Is it possible for C++ subclasses to share the same template?", "AcceptedAnswerId": "12063092", "LastEditDate": "2012-08-22T01:18:17.657", "Id": "12063056", "Score": "4", "Body": "<p>Is it possible for subclasses to share the same template? For example:</p>\n<pre><code>template &lt;class T&gt;\nclass A\n{\nprivate:\n  T _aObj;\npublic:\n  class B\n  {\n  public:\n    T _bObj;\n  };\n};\n</code></pre>\n<p>Where T can be used in both <code>A</code> and <code>B</code>?</p>\n<p>When I've tried this, I get the following error:</p>\n<blockquote>\n<p id=\"so_12063056_12063056_0\">error: A::B is not a template</p>\n</blockquote>\n", "Tags": "<c++><templates><scope><nested-class>", "OwnerUserId": "675637", "AnswerCount": "3"}, "12063092": {"ParentId": "12063056", "CommentCount": "0", "Body": "<p>Yes that works fine (on a standards-complying compiler).</p>\n<p>A way of thinking why this is logical is because <code>B</code> is not simply part of <code>A</code>, it is part of <code>A&lt;T&gt;</code>! <code>T</code> is not only part of the type for <code>A</code>, but also for <code>B</code> (the correct name for it would be <code>A&lt;T&gt;::B</code>.)</p>\n", "OwnerUserId": "565635", "PostTypeId": "2", "Id": "12063092", "Score": "6", "CreationDate": "2012-08-21T21:10:07.430", "LastActivityDate": "2012-08-21T21:10:07.430"}, "12063094": {"ParentId": "12063056", "CommentCount": "0", "Body": "<p>It sure is, although some C++ compilers will not allow it (the Freescale HCS12 compiler comes to mind).  But any flavor of GCC or MSVC will do compile this no problem.</p>\n", "OwnerUserId": "1607746", "PostTypeId": "2", "Id": "12063094", "Score": "1", "CreationDate": "2012-08-21T21:10:25.293", "LastActivityDate": "2012-08-21T21:10:25.293"}, "12063166": {"ParentId": "12063056", "CommentCount": "0", "Body": "<p>From the latest available public <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3376.pdf\" rel=\"nofollow\">draft</a> of the Standard, the scoping and access rules for nested classes are as follows:</p>\n<p><strong>9.7 Nested class declarations [class.nest]</strong></p>\n<blockquote>\n<p id=\"so_12063056_12063166_0\">1 A class can be declared within another class. A class declared\n  within another is called a nested class. The name of a nested class is\n  local to its enclosing class. The nested class is in the scope of its\n  enclosing class.</p>\n</blockquote>\n<p><strong>11.7 Nested classes [class.access.nest]</strong></p>\n<blockquote>\n<p id=\"so_12063056_12063166_1\">1 A nested class is a member and as such has the same access rights as\n  any other member. The members of an enclosing class have no special\n  access to members of a nested class; the usual access rules (Clause\n  11) shall be obeyed.</p>\n</blockquote>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "12063166", "Score": "1", "CreationDate": "2012-08-21T21:16:21.167", "LastActivityDate": "2012-08-21T21:16:21.167"}, "bq_ids": {"n4140": {"so_12063056_12063166_1": {"section_id": 6700, "quality": 0.9583333333333334, "length": 23}, "so_12063056_12063166_0": {"section_id": 5925, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_12063056_12063166_1": {"section_id": 6455, "quality": 0.9583333333333334, "length": 23}, "so_12063056_12063166_0": {"section_id": 5697, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_12063056_12063166_1": {"section_id": 8174, "quality": 0.9583333333333334, "length": 23}, "so_12063056_12063166_0": {"section_id": 7399, "quality": 0.8928571428571429, "length": 25}}}});