post_cb({"7356662": {"ParentId": "7356603", "CommentCount": "0", "Body": "<p>\u00a715.1.3 says</p>\n<blockquote>\n<p id=\"so_7356603_7356662_0\">The type of the throw-expression shall not be an incomplete type, or a\n  pointer or reference to an incomplete type, other than void*, const\n  void*, volatile void*, or const volatile void*.</p>\n</blockquote>\n<p>Which seems to imply that you can have a reference to an incomplete type.</p>\n<p>I'm not quite good at interpreting the standard yet, so take that how you will.</p>\n", "OwnerUserId": "726361", "PostTypeId": "2", "Id": "7356662", "Score": "4", "CreationDate": "2011-09-09T02:53:02.417", "LastActivityDate": "2011-09-09T02:53:02.417"}, "7357299": {"ParentId": "7356603", "CommentCount": "1", "Body": "<p>The C++ standard doesn't explicitly say, as far as I know, that you can have a reference to an incomplete type. But the standard does have a section that specifies when a type <em>must</em> be complete:</p>\n<blockquote>\n<p id=\"so_7356603_7357299_0\"><strong>3.2 One definition rule [basic.def.odr]</strong></p>\n<p id=\"so_7356603_7357299_1\"><em>4.</em> Exactly one definition of a class is required in a translation\n  unit if the class is used in a way that requires the class type to be\n  complete. [<em>Example:</em> the following complete translation unit is\n  well-formed, even though it never defines <code>X</code>:</p>\n<pre><code>    struct X;     // declare X as a struct type\n    struct X* x1; // use X in pointer formation\n    X* x2;        // use X in pointer formation\n</code></pre>\n<p id=\"so_7356603_7357299_2\"><em>\u2014end example</em>] [<em>Note:</em> the rules for declarations and expressions\n  describe in which contexts complete class types are required. A class\n  type <code>T</code> must be complete if:</p>\n<ul>\n<li>an object of type <code>T</code> is defined (3.1, 5.3.4), or</li>\n<li>an lvalue-to-rvalue conversion is applied to an lvalue referring to\n  an object of type <code>T</code> (4.1), or</li>\n<li>an expression is converted (either implicitly or explicitly) to\n  type <code>T</code> (clause 4, 5.2.3, 5.2.7, 5.2.9, 5.4), or</li>\n<li>an expression that is not a null pointer constant, and has type\n  other than <code>void *</code> is converted to the type pointer to <code>T</code> or reference\n  to <code>T</code> using an implicit conversion (clause 4), a <code>dynamic_cast</code> (5.2.7)\n  or a <code>static_cast</code> (5.2.9), or</li>\n<li>a class member access operator is applied to an expression of type\n  <code>T</code> (5.2.5), or</li>\n<li>the <code>typeid</code> operator (5.2.8) or the <code>sizeof</code> operator (5.3.3) is\n  applied to an operand of type <code>T</code>, or</li>\n<li>a function with a return type or argument type of type <code>T</code> is defined\n  (3.1) or called (5.2.2), or</li>\n<li>an lvalue of type <code>T</code> is assigned to (5.17). ]</li>\n</ul>\n</blockquote>\n<p>It appears that in every other case, including declarations of references to incomplete types, the type can be incomplete.</p>\n", "OwnerUserId": "308661", "PostTypeId": "2", "Id": "7357299", "Score": "4", "CreationDate": "2011-09-09T04:55:18.723", "LastActivityDate": "2011-09-09T04:55:18.723"}, "bq_ids": {"n4140": {"so_7356603_7356662_0": {"section_id": 3346, "quality": 0.8421052631578947, "length": 16}, "so_7356603_7357299_2": {"section_id": 7042, "quality": 0.8125, "length": 13}, "so_7356603_7357299_1": {"section_id": 7042, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_7356603_7356662_0": {"section_id": 3234, "quality": 0.8947368421052632, "length": 17}, "so_7356603_7357299_2": {"section_id": 6787, "quality": 0.8125, "length": 13}, "so_7356603_7357299_1": {"section_id": 6787, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_7356603_7356662_0": {"section_id": 4113, "quality": 0.8421052631578947, "length": 16}, "so_7356603_7357299_2": {"section_id": 8539, "quality": 0.8125, "length": 13}, "so_7356603_7357299_1": {"section_id": 8539, "quality": 0.9565217391304348, "length": 22}}}, "7356603": {"CommentCount": "0", "ViewCount": "1314", "PostTypeId": "1", "LastEditorUserId": "927034", "CreationDate": "2011-09-09T02:38:43.683", "LastActivityDate": "2013-05-16T18:03:20.397", "Title": "References to incomplete types", "AcceptedAnswerId": "7357299", "LastEditDate": "2013-05-16T18:03:20.397", "Id": "7356603", "Score": "1", "Body": "<p>According to the C++03 standard, is it valid to have references to incomplete types? I'm not aware of any implementation that implements references as any other than non-null pointers, so such code ought to work. However, I wonder whether references to incomplete types are standard conforming.</p>\n<p>I would appreciate answers with quotes and references to the C++ standard.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "927034", "AnswerCount": "2"}});