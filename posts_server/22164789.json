post_cb({"22165202": {"ParentId": "22164789", "PostTypeId": "2", "CommentCount": "8", "Body": "<p><sup><strong>Note;</strong> <code>gcc</code> and <code>clang</code> shows the correct behavior when trying to compile the provided snippet.</sup></p>\n<hr>\n<h2>Why is <code>vc++</code> wrong to accept the snippet?</h2>\n<ol>\n<li><p>A <em>function template</em> can never be instantiated in a way that produces a <em>copy-constructor</em>, as can be read in the two following quotes from the c++ standard:</p>\n<blockquote>\n<p id=\"so_22164789_22165202_0\">[<strong>class.copy</strong>]</p>\n<p id=\"so_22164789_22165202_1\">2) <strong>A <em>non-template</em> constructor for class X is a <em>copy constructor</em> if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code>, or <code>const volatile X&amp;</code></strong> and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>\n<p id=\"so_22164789_22165202_2\">...</p>\n<p id=\"so_22164789_22165202_3\">6) A declaration of a constructor for class <code>X</code> is ill-formed if its first parameter is of type (optionally cv-qualified) <code>X</code> and either there are no other parameters or else all other parameters have default arguments. <strong>A member function template is never instantiated to produce such a constructor signature.</strong></p>\n</blockquote></li>\n<li><p>If a <em>move-constructor</em> is explicitly declared the implicitly generated <em>copy-constructor</em> won't be callable, see the following:</p>\n<blockquote>\n<p id=\"so_22164789_22165202_4\">[<strong>class.copy</strong>]</p>\n<p id=\"so_22164789_22165202_5\">7) If a class definition does not explicitly declare a copy constructor, one is declared <em>implicitly</em>. <strong>If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted</strong>; otherwise, it is defined as defaulted (8.4)</p>\n</blockquote></li>\n</ol>\n<hr>\n<pre><code>struct Obj {\n  template&lt;typename T&gt;\n  Obj (T const&amp;) { }\n  Obj (Obj&amp;&amp;) { }\n};\n\n...\n\nObj a;\nObj b (a);\n</code></pre>\n<p>Having the previously mentioned quotes from the c++ standard in mind we can easily see that the above definition of <code>Obj</code> would be semantically equivalent of the below since our explicitly declared <em>move-constructor</em> will make our implicitly declared copy-constructor <code>= delete;</code>.</p>\n<pre><code>struct Obj {\n  template&lt;typename T&gt;\n  Obj (T const&amp;) { }\n  Obj (Obj const&amp;) = delete;\n  Obj (Obj&amp;&amp;) { }\n};\n</code></pre>\n<p>According to the rules of <em>overload resolution</em> deleted functions still participate when trying to find the best match, but if they win the battle of having the best fit the program is ill-formed. This is exactly what is happening in the snippet.</p>\n<p><code>Obj (Obj const&amp;) = delete</code> is a better fit than <code>template&lt;typename T&gt; Obj (T const&amp;)</code>, but since the copy-constructor isn't callable the snippet fails to compile.</p>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-03-04T07:26:47.620", "Id": "22165202", "Score": "4", "CreationDate": "2014-03-04T07:09:47.520", "LastActivityDate": "2014-03-04T07:26:47.620"}, "22164789": {"CommentCount": "3", "AcceptedAnswerId": "22165202", "PostTypeId": "1", "ClosedDate": "2014-04-01T05:05:42.737", "LastEditorUserId": "3237645", "CreationDate": "2014-03-04T06:43:44.657", "LastActivityDate": "2014-03-04T07:26:47.620", "LastEditDate": "2014-03-04T06:55:06.370", "ViewCount": "126", "FavoriteCount": "4", "Title": "template constructor cannot be selected?", "Id": "22164789", "Score": "6", "Body": "<pre><code>template &lt;typename T&gt;\nclass A {\npublic:\n    template&lt;class C&gt; A(const A&lt;C&gt;&amp;) {}\n    A(A&amp;&amp;) {}\n};\n\nvoid f(A&lt;int&gt;&amp; a)\n{\n    A&lt;int&gt; b(a);\n}\n</code></pre>\n<p>The above code doesn't compile in g++/clang++ reporting copy constructor is deleted because of user-provided move constructor (though vc++ compiles OK).  Is there any standard requirement that prevents a template constructor from being selected during overload resolution (I know it's not a copy constructor though)?  Or is there a requirement that when initializer has the same type as the initializee, it has to select a copy constructor?</p>\n", "Tags": "<c++><templates><constructor><language-lawyer>", "OwnerUserId": "3237645", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22164789_22165202_3": {"section_id": 455, "quality": 1.0, "length": 30}, "so_22164789_22165202_1": {"section_id": 451, "quality": 0.96, "length": 24}, "so_22164789_22165202_5": {"section_id": 456, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_22164789_22165202_3": {"section_id": 446, "quality": 1.0, "length": 30}, "so_22164789_22165202_1": {"section_id": 442, "quality": 0.96, "length": 24}, "so_22164789_22165202_5": {"section_id": 447, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_22164789_22165202_5": {"section_id": 479, "quality": 0.9629629629629629, "length": 26}, "so_22164789_22165202_1": {"section_id": 474, "quality": 0.96, "length": 24}, "so_22164789_22165202_3": {"section_id": 478, "quality": 1.0, "length": 30}}}});