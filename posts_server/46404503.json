post_cb({"46411490": {"ParentId": "46404503", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Sure, no problem.</p>\n<pre><code>template&lt;class Lhs, class F&gt;\nstruct foldable_binop_t {\n  Lhs lhs;\n  F f;\n  template&lt;class Rhs&gt;\n  auto operator*(Rhs&amp;&amp; rhs) &amp;&amp;\n  -&gt; foldable_binop_t&lt; std::result_of_t&lt;F&amp;(Lhs&amp;&amp;, Rhs&amp;&amp;)&gt;, F &gt;\n  {\n    return { f(std::forward&lt;Lhs&gt;(lhs), std::forward&lt;Rhs&gt;(rhs)), std::forward&lt;F&gt;(f) };\n  }\n  Lhs operator()() &amp;&amp; { return std::forward&lt;Lhs&gt;(lhs); }\n  operator Lhs() &amp;&amp; { return std::move(*this)(); }\n  Lhs get() &amp;&amp; { return std::move(*this); }\n};\ntemplate&lt;class F&gt;\nstruct foldable_t {\n  F f;\n  template&lt;class Lhs&gt;\n  friend foldable_binop_t&lt;Lhs, F&gt; operator*( Lhs&amp;&amp; lhs, foldable_t&amp;&amp; self ) {\n    return {std::forward&lt;Lhs&gt;(lhs), std::forward&lt;F&gt;(self.f)};\n  }\n  template&lt;class Rhs&gt;\n  foldable_binop_t&lt;Rhs, F&gt; operator*( Rhs&amp;&amp; rhs ) &amp;&amp; {\n    return {std::forward&lt;Rhs&gt;(rhs), std::forward&lt;F&gt;(f)};\n  }\n};\ntemplate&lt;class F&gt;\nfoldable_t&lt;F&gt; foldable(F f) { return {std::move(f)}; }\n</code></pre>\n<p>test code:</p>\n<pre><code>template&lt;class...Xs&gt;\nauto result( Xs... xs ) {\n  auto maxer = [](auto&amp;&amp;...args){return (std::max)(decltype(args)(args)...);};\n  return ((0 * foldable(maxer)) * ... * xs).get();\n}\ntemplate&lt;class...Xs&gt;\nauto result2( Xs... xs ) {\n  auto maxer = [](auto&amp;&amp;...args){return (std::max)(decltype(args)(args)...);};\n  return (foldable(maxer) * ... * xs).get();\n}\n\nint main() {\n  int x = result2( 0, 7, 10, 11, -3 ); // or result\n  std::cout &lt;&lt; x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/bc21cba50abe19f2\" rel=\"nofollow noreferrer\">Live example</a>.</p>\n<p>Personally I find</p>\n<pre><code>  auto maxer = [](auto&amp;&amp;...args){return (std::max)(decltype(args)(args)...);};\n</code></pre>\n<p>annoying to write all the time, so</p>\n<pre><code>#define RETURNS(...) \\\n  noexcept(noexcept(__VA_ARGS__)) \\\n  -&gt; decltype(__VA_ARGS__) \\\n  { return __VA_ARGS__; }\n\n#define OVERLOADS_OF(...) \\\n  [](auto&amp;&amp;...args) \\\n  RETURNS( __VA_ARGS__( decltype(args)(args)... ) )\n</code></pre>\n<p>makes it </p>\n<pre><code>template&lt;class...Xs&gt;\nauto result3( Xs... xs ) {\n  return (foldable(OVERLOADS_OF((std::max))) * ... * xs).get();\n}\n</code></pre>\n<p>or even</p>\n<pre><code>template&lt;class...Xs&gt;\nconstexpr auto result4( Xs... xs )\n  RETURNS( (foldable(OVERLOADS_OF((std::max))) * ... * xs).get() )\n</code></pre>\n<p>which is seems more expressive, and gets noexcept / constexpr right, etc.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2017-09-25T18:47:18.620", "Id": "46411490", "Score": "2", "CreationDate": "2017-09-25T18:04:30.627", "LastActivityDate": "2017-09-25T18:47:18.620"}, "46404936": {"ParentId": "46404503", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If you want to use fold expressions here then you need to somehow use an operator to invoke <code>std::max</code> rather than a function call. Here's an example abusing <code>operator^</code> to that end:</p>\n<pre><code>namespace detail {\n    template&lt;typename T, std::size_t N = sizeof(T)&gt;\n    struct type_size : std::integral_constant&lt;std::size_t, N&gt; { };\n\n    template&lt;typename T, auto M, typename U, auto N&gt;\n    constexpr auto operator ^(type_size&lt;T, M&gt;, type_size&lt;U, N&gt;) noexcept {\n        return type_size&lt;void, std::max(M, N)&gt;{};\n    }\n}\n\ntemplate&lt;typename... T&gt;\nconstexpr std::size_t max_sizeof() noexcept {\n    using detail::type_size;\n    return (type_size&lt;T&gt;{} ^ ... ^ type_size&lt;void, 0&gt;{});\n    // or, if you don't care to support empty packs\n    // return (type_size&lt;T&gt;{} ^ ...);\n}\n</code></pre>\n<p><kbd><strong><a href=\"https://wandbox.org/permlink/Ph5E7pvNhCbttSFh\" rel=\"nofollow noreferrer\">Online Demo</a></strong></kbd></p>\n<hr>\n<p>EDIT: @Barry's suggestion of removing <code>T</code> from <code>type_size</code> (renamed <code>max_val</code> here):</p>\n<pre><code>namespace detail {\n    template&lt;auto N&gt;\n    struct max_val : std::integral_constant&lt;decltype(N), N&gt; { };\n\n    template&lt;auto M, auto N, auto R = std::max(M, N)&gt;\n    constexpr max_val&lt;R&gt; operator ^(max_val&lt;M&gt;, max_val&lt;N&gt;) noexcept {\n        return {};\n    }\n}\n\ntemplate&lt;typename... T&gt;\nconstexpr std::size_t max_sizeof() noexcept {\n    using detail::max_val;\n    return (max_val&lt;sizeof(T)&gt;{} ^ ... ^ max_val&lt;std::size_t{}&gt;{});\n    // or, if you don't care to support empty packs\n    // return (max_val&lt;sizeof(T)&gt;{} ^ ...);\n}\n</code></pre>\n<p><kbd><strong><a href=\"https://wandbox.org/permlink/jadPTr62sVdmfNEc\" rel=\"nofollow noreferrer\">Online Demo</a></strong></kbd></p>\n<p>Externally, both implementations are equivalent; in terms of implementation, I personally prefer the former, but YMMV. :-]</p>\n</hr>", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2017-09-25T19:50:35.803", "Id": "46404936", "Score": "16", "CreationDate": "2017-09-25T12:10:35.600", "LastActivityDate": "2017-09-25T19:50:35.803"}, "46404676": {"ParentId": "46404503", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Just to play with c++17 fold expressions</p>\n<pre><code>template &lt;typename ... Ts&gt;\nconstexpr std::size_t max_sizeof ()\n {\n   std::size_t  ret { 0 };\n\n   return ( (ret = (sizeof(Ts) &gt; ret ? sizeof(Ts) : ret)), ... ); \n }\n</code></pre>\n<p>or, using the fact that <code>std::max()</code> is <code>constexpr</code> starting from C++14 (so it is in C++17)</p>\n<pre><code>template &lt;typename ... Ts&gt;\nconstexpr std::size_t max_sizeof ()\n {\n   std::size_t  ret { 0 };\n\n   return ( (ret = std::max(sizeof(Ts), ret)), ... ); \n }\n</code></pre>\n<p>Not really different from your original version.</p>\n", "OwnerUserId": "6022656", "LastEditorUserId": "6022656", "LastEditDate": "2017-09-25T12:05:30.213", "Id": "46404676", "Score": "6", "CreationDate": "2017-09-25T11:57:39.780", "LastActivityDate": "2017-09-25T12:05:30.213"}, "46405296": {"ParentId": "46404503", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_46404503_46405296_0\">I would like to write equivalent function using fold expressions and <code>std::max</code>. For example for 3 elements it should expand to</p>\n<p id=\"so_46404503_46405296_1\"><code>return std::max(sizeof (A), std::max(sizeof(B), sizeof (C)));</code></p>\n</blockquote>\n<p>Another possible solution (based on recursion, <strong>not</strong> of fold expression) is the following</p>\n<pre><code>template &lt;typename T0&gt;\nconstexpr std::size_t max_sizeof ()\n { return sizeof(T0); }\n\ntemplate &lt;typename T0, typename T1, typename ... Ts&gt;\nconstexpr std::size_t max_sizeof ()\n { return std::max(sizeof(T0), max_sizeof&lt;T1, Ts...&gt;()); }\n</code></pre>\n", "OwnerUserId": "6022656", "PostTypeId": "2", "Id": "46405296", "Score": "1", "CreationDate": "2017-09-25T12:29:29.137", "LastActivityDate": "2017-09-25T12:29:29.137"}, "46404503": {"CommentCount": "7", "AcceptedAnswerId": "46404838", "LastEditDate": "2017-09-25T21:05:27.877", "LastEditorUserId": "719662", "CreationDate": "2017-09-25T11:47:48.657", "LastActivityDate": "2017-09-25T21:05:27.877", "PostTypeId": "1", "ViewCount": "2700", "Title": "Can I implement max(A, max(B, max(C, D))) using fold expressions?", "Id": "46404503", "OwnerUserId": "700825", "Body": "<p>While trying to play around with C++17 fold expressions, I tried to implement max <code>sizeof</code> where result is maximum of the <code>sizeof</code> of types.\nI have an ugly fold version that uses variable and a lambda, but I am unable to think of a way to use fold expressions and <code>std::max()</code> to get the same result.</p>\n<p>This is my fold version:</p>\n<pre><code>template&lt;typename... T&gt;\nconstexpr size_t max_sizeof(){\n    size_t max=0;\n    auto update_max = [&amp;max](const size_t&amp; size) {if (max&lt;size) max=size; };\n    (update_max(sizeof (T)), ...);\n    return max;\n}\n\n\nstatic_assert(max_sizeof&lt;int, char, double, short&gt;() == 8);\nstatic_assert(max_sizeof&lt;char, float&gt;() == sizeof(float));\nstatic_assert(max_sizeof&lt;int, char&gt;() == 4);\n</code></pre>\n<p>I would like to write equivalent function using fold expressions and <code>std::max()</code>.\nFor example for 3 elements it should expand to </p>\n<pre><code>return std::max(sizeof (A), std::max(sizeof(B), sizeof (C)));\n</code></pre>\n<p>Is it possible to do that?</p>\n", "Tags": "<c++><templates><variadic-templates><c++1z><fold-expression>", "Score": "24", "AnswerCount": "8"}, "46410376": {"ParentId": "46404503", "CommentCount": "2", "Body": "<p>Just for fun, a variation on the theme on the brilliant solution from ildjarn</p>\n<pre><code>namespace detail\n {\n   template &lt;std::size_t N&gt;\n   struct tSizeH : std::integral_constant&lt;std::size_t, N&gt; { };\n\n   template &lt;std::size_t M, std::size_t N&gt;\n   constexpr tSizeH&lt;std::max(M, N)&gt; operator^ (tSizeH&lt;M&gt;, tSizeH&lt;N&gt;);\n }\n\ntemplate &lt;typename ... T&gt;\nconstexpr std::size_t max_sizeof() noexcept\n { return decltype((detail::tSizeH&lt;sizeof(T)&gt;{} ^ ...))::value; }\n</code></pre>\n<p>A little simplified because (a) the helper class use only the <code>sizeof()</code> of the type (resolved directly in <code>max_sizeof()</code>, (b) no use of the terminal value based on <code>void</code> and zero, (c) the <code>operator^()</code> is declared but unimplemented (there is no need of implement it: interest only for the return type) and (d) <code>max_sizeof()</code> use <code>decltype()</code> instead of calling <code>operator^()</code> (so there is no need of implement it).</p>\n", "OwnerUserId": "6022656", "PostTypeId": "2", "Id": "46410376", "Score": "0", "CreationDate": "2017-09-25T16:55:42.017", "LastActivityDate": "2017-09-25T16:55:42.017"}, "46404838": {"ParentId": "46404503", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Probably not what you wanted to hear, but no. It isn't possible to do that (purely<sup>1</sup>) with fold expressions. Their very grammar simply doesn't allow for it:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.prim.fold\" rel=\"noreferrer\">[expr.prim.fold]</a></p>\n<blockquote>\n<p id=\"so_46404503_46404838_0\">A fold expression performs a fold of a template parameter pack over a\n  <strong>binary operator</strong>.</p>\n<pre class=\"lang-none prettyprint-override\"><code>fold-expression:\n  ( cast-expression fold-operator ... )\n  ( ... fold-operator cast-expression )\n  ( cast-expression fold-operator ... fold-operator cast-expression )\nfold-operator: one of\n  + \u2003\u2002- \u2003\u2002* \u2003\u2002/ \u2003\u2002% \u2003\u2002^ \u2003\u2002&amp; \u2003\u2002| \u2003\u2002&lt;&lt; \u2003\u2002&gt;&gt; \n  +=\u2003\u2002-=\u2003\u2002*=\u2003\u2002/=\u2003\u2002%=\u2003\u2002^=\u2003\u2002&amp;=\u2003\u2002|=\u2003\u2002&lt;&lt;=\u2003\u2002&gt;&gt;=\u2003\u2002=\n  ==\u2003\u2002!=\u2003\u2002&lt; \u2003\u2002&gt; \u2003\u2002&lt;=\u2003\u2002&gt;=\u2003\u2002&amp;&amp;\u2003\u2002||\u2003\u2002,  \u2003\u2002.* \u2003\u2002-&gt;*\n</code></pre>\n</blockquote>\n<p>Simply because a function call expression is not a binary operator in the pure grammar sense.</p>\n<hr>\n<p><sub>\n<sup>1</sup> Refer to the other superb answers.\n</sub></p>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-09-25T12:08:22.993", "Id": "46404838", "Score": "24", "CreationDate": "2017-09-25T12:06:20.630", "LastActivityDate": "2017-09-25T12:08:22.993"}, "46406640": {"ParentId": "46404503", "CommentCount": "2", "Body": "<p>Not a fold expression, but another way that c++17 offers - <code>if constexpr</code>:</p>\n<pre><code>template&lt;class X, class Y, class...Ts&gt;\nconstexpr std::size_t max_sizeof()\n{\n    auto base = std::max(sizeof(X), sizeof(Y));\n\n    if constexpr (sizeof...(Ts) == 0)\n    {\n        // nothing\n    }\n    else if constexpr (sizeof...(Ts) == 1)\n    {\n        base = std::max(base, sizeof(Ts)...);\n    }\n    else\n    {\n        base = std::max(base, max_sizeof&lt;Ts...&gt;());\n    }\n    return base;\n}\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "46406640", "Score": "1", "CreationDate": "2017-09-25T13:38:31.533", "LastActivityDate": "2017-09-25T13:38:31.533"}, "bq_ids": {"n4659": {"so_46404503_46404838_0": {"section_id": 7481, "quality": 1.0, "length": 10}}}, "46408751": {"ParentId": "46404503", "CommentCount": "0", "Body": "<p>Since nobody posted this one as an answer yet, the easiest way to do this with minimal effort is to just use the overload of <a href=\"http://en.cppreference.com/w/cpp/algorithm/max\" rel=\"noreferrer\"><code>std::max()</code></a> that is ready-made for this problem: the one that takes an <code>initializer_list</code>:</p>\n<pre><code>template&lt;typename... T&gt;\nconstexpr size_t max_sizeof() {\n    return std::max({sizeof(T)...});\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "46408751", "Score": "16", "CreationDate": "2017-09-25T15:20:35.350", "LastActivityDate": "2017-09-25T15:20:35.350"}});