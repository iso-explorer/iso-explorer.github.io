post_cb({"bq_ids": {"n4140": {"so_36508157_36508299_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7042}}, "n3337": {"so_36508157_36508299_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 6787}}, "n4659": {"so_36508157_36508299_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 8539}}}, "36508403": {"Id": "36508403", "PostTypeId": "2", "Body": "<p>My suggestion:</p>\n<ol>\n<li><p>Update the definition of <code>P</code> slightly to define a derived typename.</p>\n<pre><code>template&lt;class T&gt;\nclass Ptr {\npublic:\n    using ptr_t = T*;\n    ptr_t ptr;\n};\n</code></pre></li>\n<li><p>Update A.hpp, B.hpp and C.hpp to rely only on forward declarations of <code>B</code>, <code>C</code>, and <code>A</code>, respectively.</p>\n<p>The updated version of A.hpp.</p>\n<pre><code>#ifndef TEST_INCLUDE_A\n#define TEST_INCLUDE_A 1\n\n#include \"P.hpp\"\n\nclass B;\n\nclass A {\n   public:\n      typedef Ptr&lt;A&gt; ptr;   // This does not seem useful any longer\n                            // It can probably be removed.\n      Ptr&lt;B&gt; b_ptr;\n};\n\n#endif\n</code></pre>\n<p>Update B.hpp and C.hpp similarly.</p></li>\n</ol>\n", "LastActivityDate": "2016-04-08T20:04:39.547", "CommentCount": "0", "CreationDate": "2016-04-08T20:04:39.547", "ParentId": "36508157", "Score": "1", "OwnerUserId": "434551"}, "36508422": {"Id": "36508422", "PostTypeId": "2", "Body": "<p>For the purpose of resolving the circular dependency, you're just going to have to give the compiler a hand and impart some foreknowledge of what <code>ptr</code> is going to be in the other class, that is: you know that <code>A::ptr</code> is <code>Ptr&lt;A&gt;</code>, and so on.</p>\n<p><a href=\"http://ideone.com/J6sqnG\" rel=\"nofollow\">online demo</a></p>\n<pre><code>class A;\nclass B;\n\ntemplate&lt;typename T&gt;\nstruct Ptr { T* ptr_t; };\n\nclass A {\npublic:\n    using ptr = Ptr&lt;A&gt;;\n    Ptr&lt;B&gt; b;\n};\n\nclass B {\npublic:\n    using ptr = Ptr&lt;B&gt;;\n    Ptr&lt;A&gt; a;\n};\n\nint main() {\n    A a;\n    B b;\n    a.b.ptr_t = &amp;b;\n    b.a.ptr_t = &amp;a;\n\n    A::ptr aptr;\n    B::ptr bptr;\n    aptr.ptr_t = &amp;a;\n    bptr.ptr_t = &amp;b;\n    a.b = bptr;\n    b.a = aptr;\n}\n</code></pre>\n", "LastActivityDate": "2016-04-08T20:05:40.640", "CommentCount": "0", "CreationDate": "2016-04-08T20:05:40.640", "ParentId": "36508157", "Score": "2", "OwnerUserId": "257645"}, "36508157": {"ViewCount": "51", "Body": "<p>I have a few classes (<code>A</code>, <code>B</code>, <code>C</code>) each with a member with a templated (<code>Ptr&lt;...&gt;</code>) type depending on the incomplete type of another class (circular). I'd like to typedef the types (<code>::ptr</code>) as shown below. This seems not to work \u2013 my compiler tells me the following:</p>\n<pre><code>In file included from B.hpp:6:0,\n                 from A.hpp:6:\nC.hpp:13:8: error: \u2018ptr\u2019 in \u2018class A\u2019 does not name a type\n     A::ptr a;\n        ^\n</code></pre>\n<p>However using <code>T*</code> instead of <code>T::ptr</code> makes it working. How can I fix that?</p>\n<p>A.hpp:</p>\n<pre><code>#ifndef TEST_INCLUDE_A\n#define TEST_INCLUDE_A 1\n\nclass A;\n\n#include \"B.hpp\"\n\n#include \"P.hpp\"\n\nclass A {\npublic:\n    typedef Ptr&lt;A&gt; ptr;\n    B::ptr b;\n};\n\n#endif\n</code></pre>\n<p>B.hpp:</p>\n<pre><code>#ifndef TEST_INCLUDE_B\n#define TEST_INCLUDE_B 1\n\nclass B;\n\n#include \"C.hpp\"\n\n#include \"P.hpp\"\n\nclass B {\npublic:\n    typedef Ptr&lt;B&gt; ptr;\n    C::ptr c;\n};\n\n#endif\n</code></pre>\n<p>C.hpp:</p>\n<pre><code>#ifndef TEST_INCLUDE_C\n#define TEST_INCLUDE_C 1\n\nclass C;\n\n#include \"A.hpp\"\n\n#include \"P.hpp\"\n\nclass C {\npublic:\n    typedef Ptr&lt;C&gt; ptr;\n    A::ptr a;\n};\n\n#endif\n</code></pre>\n<p>P.hpp:</p>\n<pre><code>#ifndef TEST_INCLUDE_PTR\n#define TEST_INCLUDE_PTR 1\n\ntemplate&lt;class T&gt;\nclass Ptr {\npublic:\n    T* ptr_t;\n};\n\n#endif\n</code></pre>\n", "AcceptedAnswerId": "36508422", "Title": "Typedefs in circular-dependend classes", "CreationDate": "2016-04-08T19:49:26.900", "Id": "36508157", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-04-08T20:05:40.640", "Score": "1", "OwnerUserId": "2175501", "Tags": "<c++><class><templates><typedef><circular-dependency>", "AnswerCount": "3"}, "36508299": {"Id": "36508299", "PostTypeId": "2", "Body": "<p>There are certain operations that you can only do on a complete type. One of them is, from [basic.def.odr]:</p>\n<blockquote>\n<p id=\"so_36508157_36508299_0\">A class type <code>T</code> must be complete if:<br>\n  \u2014 [...]<br>\n  \u2014 a class member access operator is applied to an expression of type <code>T</code> (5.2.5), or<br>\n  \u2014 [...]</br></br></br></p>\n</blockquote>\n<p>Writing <code>A::ptr</code> requires <code>A</code> to be complete. <code>A</code> is not complete at the point where we're defining <code>C</code>, so this is an error.</p>\n<p>On the other hand, when you write <code>A*</code> however, that does <em>not</em> require <code>A</code> to be complete. Having pointers (or references) to incomplete types as members is fine. </p>\n", "LastActivityDate": "2016-04-08T19:57:27.890", "CommentCount": "0", "CreationDate": "2016-04-08T19:57:27.890", "ParentId": "36508157", "Score": "1", "OwnerUserId": "2069064"}});