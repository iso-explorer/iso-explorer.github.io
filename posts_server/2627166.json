post_cb({"2627179": {"Id": "2627179", "PostTypeId": "2", "Body": "<p>The difference is more prominent when you are passing a big struct/class.</p>\n<pre><code>struct MyData {\n    int a,b,c,d,e,f,g,h;\n    long array[1234];\n};\nvoid DoWork(MyData md);\nvoid DoWork(const MyData&amp; md);\n</code></pre>\n<p>when you use use 'normal' parameter, you pass the parameter by value and hence creating a copy of the parameter you pass. if you are using const reference, you pass it by reference and the original data is not copied.</p>\n<p>in both cases, the original data cannot be modified from inside the function.</p>\n<p><strong>EDIT:</strong><br>\nIn certain cases, the original data might be able to get modified as pointed out by <a href=\"https://stackoverflow.com/users/19563/charles-bailey\">Charles Bailey</a> in his <a href=\"https://stackoverflow.com/questions/2627166/difference-between-const-reference-and-normal-parameter/2627535#2627535\">answer</a>.</br></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-08-30T03:25:51.593", "Score": "18", "CreationDate": "2010-04-13T05:30:23.050", "ParentId": "2627166", "CommentCount": "0", "OwnerUserId": "109747", "LastEditDate": "2017-05-23T11:47:01.620"}, "2627166": {"ViewCount": "27279", "Body": "<pre><code>void DoWork(int n);\nvoid DoWork(const int &amp;n);\n</code></pre>\n<p>Whats the diff</p>\n", "AcceptedAnswerId": "2627179", "Title": "Difference between const reference and normal parameter", "CreationDate": "2010-04-13T05:26:04.320", "Id": "2627166", "CommentCount": "1", "FavoriteCount": "12", "PostTypeId": "1", "LastActivityDate": "2017-05-25T09:57:21.190", "Score": "14", "OwnerUserId": "313670", "Tags": "<c++><parameters><reference><const>", "AnswerCount": "7"}, "3598165": {"Id": "3598165", "PostTypeId": "2", "Body": "<p>Firstly, there is no concept of cv-qualified references. So the terminology 'const reference' is not correct and is usually used to describle 'reference to const'. It is better to start talking about what is meant.</p>\n<blockquote>\n<p id=\"so_2627166_3598165_0\">$8.3.2/1- \"Cv-qualified references are ill-formed except when the\n  cv-qualifiers are introduced through the use of a typedef (7.1.3) or\n  of a template type argument (14.3), in which case the cv-qualifiers\n  are ignored.\"</p>\n</blockquote>\n<p>Here are the differences</p>\n<blockquote>\n<p id=\"so_2627166_3598165_1\">$13.1 - \"Only the const and volatile type-specifiers at the outermost\n  level of the parameter type specification are ignored in this fashion;\n  const and volatile type-specifiers buried within a parameter type\n  specification are significant and can be used to distinguish\n  overloaded function declarations.112). In particular, for any type T,\n  \u201cpointer to T,\u201d \u201cpointer to const T,\u201d and \u201cpointer to volatile T\u201d are\n  considered distinct parameter types, as are \u201creference to T,\u201d\n  \u201creference to const T,\u201d and \u201creference to volatile T.\u201d</p>\n</blockquote>\n<pre><code>void f(int &amp;n){\n   cout &lt;&lt; 1; \n   n++;\n}\n\nvoid f(int const &amp;n){\n   cout &lt;&lt; 2;\n   //n++; // Error!, Non modifiable lvalue\n}\n\nint main(){\n   int x = 2;\n\n   f(x);        // Calls overload 1, after the call x is 3\n   f(2);        // Calls overload 2\n   f(2.2);      // Calls overload 2, a temporary of double is created $8.5/3\n}\n</code></pre>\n", "LastEditorUserId": "5771029", "LastActivityDate": "2017-01-09T22:43:30.400", "Score": "0", "CreationDate": "2010-08-30T05:53:13.583", "ParentId": "2627166", "CommentCount": "0", "OwnerUserId": "418110", "LastEditDate": "2017-01-09T22:43:30.400"}, "2627535": {"Id": "2627535", "PostTypeId": "2", "Body": "<p>The important difference is that when passing by <code>const</code> reference, no new object is created. In the function body, the parameter is effectively an alias for the object passed in.</p>\n<p>Because the reference is a <code>const</code> reference the function body cannot directly change the value of that object. This has a similar property to passing by value where the function body also cannot change the value of the object that was passed in, in this case because the parameter is a copy.</p>\n<p>There are crucial differences. If the parameter is a <code>const</code> reference, but the object passed it was not in fact <code>const</code> then the value of the object may be changed during the function call itself.</p>\n<p>E.g.</p>\n<pre><code>int a;\n\nvoid DoWork(const int &amp;n)\n{\n    a = n * 2;  // If n was a reference to a, n will have been doubled \n\n    f();  // Might change the value of whatever n refers to \n}\n\nint main()\n{\n    DoWork(a);\n}\n</code></pre>\n<p>Also if the object passed in was not actually <code>const</code> then the function could (even if it is ill advised) change its value with a cast.</p>\n<p>e.g.</p>\n<pre><code>void DoWork(const int &amp;n)\n{\n    const_cast&lt;int&amp;&gt;(n) = 22;\n}\n</code></pre>\n<p>This would cause undefined behaviour if the object passed in was actually <code>const</code>.</p>\n<p>When the parameter is passed by const reference, extra costs include dereferencing, worse object locality, fewer opportunities for compile optimizing.</p>\n<p>When the parameter is passed by value and extra cost is the need to create a parameter copy. Typically this is only of concern when the object type is large.</p>\n", "LastActivityDate": "2010-04-13T06:49:05.130", "CommentCount": "0", "CreationDate": "2010-04-13T06:49:05.130", "ParentId": "2627166", "Score": "19", "OwnerUserId": "19563"}, "bq_ids": {"n4140": {"so_2627166_3598165_1": {"length": 38, "quality": 0.926829268292683, "section_id": 558}, "so_2627166_3598165_0": {"length": 12, "quality": 0.631578947368421, "section_id": 3218}}, "n3337": {"so_2627166_3598165_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 3092}, "so_2627166_3598165_1": {"length": 38, "quality": 0.926829268292683, "section_id": 549}}, "n4659": {"so_2627166_3598165_0": {"length": 12, "quality": 0.631578947368421, "section_id": 3975}, "so_2627166_3598165_1": {"length": 38, "quality": 0.926829268292683, "section_id": 581}}}, "42057612": {"Id": "42057612", "PostTypeId": "2", "Body": "<p>There are three methods you can pass values in the function </p>\n<ol>\n<li><p>Pass by value</p>\n<pre><code>void f(int  n){\n    n=n+10;\n}\n\nint main(){\n    int x = 3;\n    f(x);\n    cout &lt;&lt; x&lt;&lt;endl;\n}\n</code></pre>\n<p>Output: 3. Disadvantage: When parameter <code>x</code> pass through <code>f</code> function then compiler creates a copy in memory in of x. So wastage of memory.</p></li>\n<li><p>Pass by reference </p>\n<pre><code>void f(int  &amp;n){\n    n=n+10;\n}\n\nint main(){\n    int x = 3;\n    f(x);\n    cout &lt;&lt; x&lt;&lt;endl;\n}\n</code></pre>\n<p>Output: 13. It eliminate pass by value disadvantage, but if programmer do not want to change the value then use constant reference</p></li>\n<li><p>Constant reference</p>\n<pre><code>void f(const int  &amp;n){\n    n=n+10; // Error: assignment of read-only reference  \u2018n\u2019\n}\n\nint main(){\n    int x = 3;\n    f(x);\n    cout &lt;&lt; x&lt;&lt;endl;\n}\n</code></pre>\n<p>Output: Throw error at <code>n=n+10</code> because when we pass const reference parameter argument then it is read-only parameter, you cannot change value of n.</p></li>\n</ol>\n", "LastEditorUserId": "1336087", "LastActivityDate": "2017-05-25T09:57:21.190", "Score": "2", "CreationDate": "2017-02-05T21:38:13.253", "ParentId": "2627166", "CommentCount": "1", "OwnerUserId": "6164211", "LastEditDate": "2017-05-25T09:57:21.190"}, "2627259": {"Id": "2627259", "PostTypeId": "2", "Body": "<p>Since none of you mentioned nothing about the const keyword...</p>\n<blockquote>\n<p id=\"so_2627166_2627259_0\">The <strong>const</strong> keyword modifies the type of a type declaration or the type of a function parameter, preventing the value from varying. (Source: MS)</p>\n</blockquote>\n<p>In other words: passing a parameter by reference exposes it to modification by the callee. Using the <strong>const</strong> keyword prevents the modification.</p>\n", "LastActivityDate": "2010-04-13T05:52:04.533", "CommentCount": "0", "CreationDate": "2010-04-13T05:52:04.533", "ParentId": "2627166", "Score": "2", "OwnerUserId": "138255"}, "2627185": {"Id": "2627185", "PostTypeId": "2", "Body": "<p>With</p>\n<pre><code> void DoWork(int n);\n</code></pre>\n<p><code>n</code> is a copy of the value of the actual parameter, and it is legal to change the value of <code>n</code> within the function. With </p>\n<pre><code>void DoWork(const int &amp;n);\n</code></pre>\n<p><code>n</code> is a reference to the actual parameter, and it is not legal to change its value.</p>\n", "LastActivityDate": "2010-04-13T05:32:05.570", "CommentCount": "0", "CreationDate": "2010-04-13T05:32:05.570", "ParentId": "2627166", "Score": "3", "OwnerUserId": "1605"}, "2627177": {"Id": "2627177", "PostTypeId": "2", "Body": "<p>The first method passes <code>n</code> by value, i.e. a copy of <code>n</code> is sent to the function. The second one passes <code>n</code> by reference which basically means that a pointer to the <code>n</code> with which the function is called is sent to the function.</p>\n<p>For integral types like <code>int</code> it doesn't make much sense to pass as a const reference since the size of the reference is usually the same as the size of the reference (the pointer). In the cases where making a copy is expensive it's usually best to pass by const reference.</p>\n", "LastActivityDate": "2010-04-13T05:29:07.923", "CommentCount": "3", "CreationDate": "2010-04-13T05:29:07.923", "ParentId": "2627166", "Score": "0", "OwnerUserId": "125672"}});