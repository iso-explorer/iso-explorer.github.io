post_cb({"bq_ids": {"n4140": {"so_14408796_14409088_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 2714}}, "n3337": {"so_14408796_14409088_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 2675}}, "n4659": {"so_14408796_14409088_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 3454}}}, "14408796": {"ViewCount": "568", "Body": "<p>I am using <code>std::thread</code> and gcc as my compiler in implementing the parallel-merge as described in <a href=\"http://rads.stackoverflow.com/amzn/click/0262033844\" rel=\"nofollow noreferrer\">Cormen's Introduction to Algorithms</a>.</p>\n<p>I think I got the code to work.  It passes all randomly seeded arrays that are not too big.  However, when I try to merge two arrays that are large (1e6 elements each), I get the following termination:</p>\n<pre><code>terminate called without an active exception\nterminate called recursively\nterminate called recursively\n</code></pre>\n<p>Using gdb doesn't help: it becomes corrupted during the run.</p>\n<p>I am pretty certain that the run has failed due to too many threads spawned.</p>\n<p><em>What can I do to confirm that this error is due to too many std::threads spawned?</em></p>\n<p><strong>NOTES</strong></p>\n<ol>\n<li>Code works up to n=1e4, fails by n=1e5</li>\n<li><h1>define DEBUG if you want to see output, but I don't recommend this except for small n like 10 or 50.</h1></li>\n<li>STRBUF_SIZE/use of fprintf is ugly, but iostream doesn't flush well in threads - this is hacky, but works (no need to focus here).</li>\n<li>I tried following Barnes53's suggestion by using a try/catch block around the threads, but this didn't work, apparently.</li>\n<li>I know that spawning a gazillion threads is a bad thing - at this point, I am just trying to implement what's in the book and to see if it works, and perhaps discover what its limitations are.</li>\n</ol>\n<p><strong>UPDATE</strong></p>\n<ol>\n<li><a href=\"https://stackoverflow.com/a/14409088/975129\">GManNickG's answer below</a> helped: not every run, but during some runs of 1e5, I can see that, indeed, resources are gone.</li>\n<li>I will probably look into some kind of k-way parallel sort, where I can control the number of threads spawned, if this algorithm is not salvageable.</li>\n</ol>\n<p><strong>CODE</strong></p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n#include &lt;cassert&gt;\n\n#define STRBUF_SIZE 1024\n\nclass Random\n{\npublic:\n    Random( unsigned int seed=::time(nullptr))\n        : m_seed( seed )\n    { }\n    // between [ 0 .. n-1 ]\n    unsigned int rand_uint( unsigned int n )\n    {\n        return static_cast&lt;unsigned int&gt;\n                     (static_cast&lt;float&gt;(n) * rand_r( &amp;m_seed ) / RAND_MAX);\n    }\n    unsigned int getSeed() const { return m_seed; }\nprivate:\n    unsigned int m_seed;\n};\n\ntemplate&lt;typename T&gt;\nchar* dump( char* line, T it1, T it2 )\n{\n    char buf[80];\n    line[0] = '\\0';\n    for( T it=it1; it!=it2; ++it )\n    {\n        sprintf( buf, \"%u \", *it );\n        strcat(  line, buf );\n    }\n    return line;\n}\n\ntemplate&lt; typename T, class It &gt;\nIt binary_search_it( It beg, It end, const T&amp; value )\n{\n    auto low  = beg;\n    auto high = std::max( beg, end );   // end+1\n    while( low &lt; high )\n    {\n        auto mid = low + std::distance( low, high ) / 2;\n        if ( value &lt;= *mid )\n            high = mid;\n        else\n            low = mid + 1;\n    }\n    return high;\n}\n\ntemplate&lt; class InputIt, class OutputIt &gt;\nvoid p_merge( \n    char const*  msg, \n    unsigned     depth,\n    unsigned     parent_lvl_id,\n    unsigned     lr,\n    InputIt  p1, InputIt  r1, \n    InputIt  p2, InputIt  r2, \n    OutputIt p3, OutputIt r3\n    )\n{\n#ifdef DEBUG\n    char buff[STRBUF_SIZE];\n#endif\n    unsigned sum_prev  = pow( 2, depth ) - 1;\n    unsigned lvl_id    = 2*parent_lvl_id + lr;\n    unsigned thread_no = sum_prev + lvl_id + 1;\n\n    unsigned limit0    = sum_prev + 1;\n    unsigned limit1    = pow( 2, depth+1 ) - 1;\n\n#ifdef DEBUG\n    char msg_dep[256];\n    sprintf( msg_dep, \"%s [%2d] %-10d [%d,%d]\", msg, depth, thread_no, limit0, limit1 );\n    fprintf( stderr, \"%s\\n\", msg_dep );\n#endif\n\n    if ( thread_no&lt;limit0 || thread_no&gt;limit1 )\n    {\n        fprintf( stderr, \"OUT OF BOUNDS\\n\" );\n        exit( 1 );\n    }\n\n    auto n1 = std::distance( p1, r1 );\n    auto n2 = std::distance( p2, r2 );\n#ifdef DEBUG\n    fprintf( stderr, \"%s dist[v1]=%2ld   : %s\\n\", msg_dep, n1, dump( buff, p1, r1 ) );\n    fprintf( stderr, \"%s dist[v2]=%2ld   : %s\\n\", msg_dep, n2, dump( buff, p2, r2 ) );\n#endif\n    if ( n1&lt;n2 )\n    {\n        std::swap( p1, p2 );\n        std::swap( r1, r2 );\n        std::swap( n1, n2 );\n#ifdef DEBUG\n      fprintf( stderr, \"%s swapped[v1]   : %s\\n\", msg_dep, dump( buff, p1, r1 ));\n      fprintf( stderr, \"%s swapped[v2]   : %s\\n\", msg_dep, dump( buff, p2, r2 ));\n#endif\n    }\n    if ( n1==0 )\n    {\n#ifdef DEBUG\n      fprintf( stderr, \"%s done              \\n\", msg_dep );\n#endif\n        return;\n    }\n    auto q1 = p1 + n1 / 2;   // midpoint\n    auto q2 = binary_search_it( p2, r2, *q1 );  // &lt;q1   q2[q1]   &gt;=q1\n    auto q3 = p3 + std::distance( p1, q1 ) + std::distance( p2, q2 );\n    *q3 = *q1;\n\n#ifdef DEBUG\n    fprintf( stderr, \"%s q1[median]=%u  : %s\\n\", msg_dep, *q1, dump( buff, p1, r1 ));\n    fprintf( stderr, \"%s q2[fulcrum]=%u : %s\\n\", msg_dep, *q2, dump( buff, p2, r2 ));\n    fprintf( stderr, \"%s q3(copied)=%u  : %s\\n\", msg_dep, *q3, dump( buff, p3, r3 ));\n#endif\n\n#ifdef DEBUG\n    auto d1 = std::distance( p1,   q1-1 );\n    auto d2 = std::distance( q1+1, r1   );\n    fprintf( stderr, \"%s q1[dist_L]=%ld  : %s\\n\", msg_dep, d1, dump( buff, p1, r1 ));\n    fprintf( stderr, \"%s q1[dist_M]=%ld  : %s\\n\", msg_dep, d2, dump( buff, p1, r1 ));\n#endif\n\n\n    try {\n        std::thread t1{ \n            [&amp;](){ p_merge( \"LESS\", depth+1, lvl_id, 0, p1, q1,   p2, q2,   p3, r3 ); } \n        };\n        std::thread t2{ \n            [&amp;](){ p_merge( \"MORE\", depth+1, lvl_id, 1, q1+1, r1, q2, r2, q3+1, r3 ); } \n        };\n        t1.join();\n        t2.join();\n    }\n    catch( ... )\n    {\n        fprintf( stderr, \"OK - I am dying during a std::thread spawn\\n\" );\n        exit( 1 );\n    }\n\n#ifdef DEBUG\n    fprintf( stderr, \"%s synchronized\\n\", msg_dep );\n#endif\n}\n\nint\nmain( int argv, char* argc[] )\n{\n    // ok up to 1e4, fails by 1e5\n    unsigned n = 1e5; \n    Random   r;\n    std::vector&lt;unsigned&gt; v1( n ), v2( n ), v3( 2 * n );\n\n#ifdef DEBUG\n    fprintf( stderr, \"SEED = %u\\n\", r.getSeed() );\n#endif\n\n    std::generate( v1.begin(), v1.end(), [&amp;]() { return r.rand_uint(n); } );\n    std::generate( v2.begin(), v2.end(), [&amp;]() { return r.rand_uint(n); } );\n\n#ifdef DEBUG\n    char buff[STRBUF_SIZE];\n    fprintf( stderr, \"%s\\n\", dump( buff, v1.begin(), v1.end() ));\n    fprintf( stderr, \"%s\\n\", dump( buff, v2.begin(), v2.end() ));\n#endif\n\n    std::sort( v1.begin(), v1.end() );\n    std::sort( v2.begin(), v2.end() );\n\n    p_merge( \"TOP \", 0, 0, 0,\n        v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin(), v3.end() );\n\n    assert( std::is_sorted( v3.begin(), v3.end() ));\n\n#ifdef DEBUG\n    fprintf( stderr, \"FINAL : %s\\n\", dump( buff, v3.begin(), v3.end() ));\n#endif\n}\n</code></pre>\n", "AcceptedAnswerId": "14409088", "Title": "How do I verify if runtime failure is due to too many threads spawned?", "CreationDate": "2013-01-18T22:37:26.290", "Id": "14408796", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:07:01.127", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-19T18:41:11.980", "Score": "4", "OwnerUserId": "975129", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "2"}, "14409088": {"Id": "14409088", "PostTypeId": "2", "Body": "<p>You can catch <code>std::system_error</code> and check if the code is <code>resource_unavailable_try_again</code>:</p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;system_error&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nclass thread_collection\n{\npublic:\n    thread_collection() :\n    mStop(false)\n    {}\n\n    ~thread_collection()\n    {\n        clear();\n    }\n\n    template &lt;typename Func, typename... Args&gt;\n    bool add(Func&amp;&amp; func, Args&amp;&amp;... args)\n    {\n        try\n        {\n            mThreads.emplace_back(std::forward&lt;Func&gt;(func),\n                                  std::cref(mStop),\n                                  std::forward&lt;Args&gt;(args)...);\n        }\n        catch (const std::system_error&amp; e)\n        {\n            if (e.code().value() == std::errc::resource_unavailable_try_again)\n                return false; // not possible to make more threads right now\n            else\n                throw; // something else\n        }\n\n        return true; // can keep going\n    }\n\n    void clear()\n    {\n        mStop = true;\n        for (auto&amp; thread : mThreads)\n        {\n            if (thread.joinable())\n                thread.join();\n        }\n\n        mThreads.clear();\n        mStop = true;\n    }\n\n    std::size_t size() const\n    {\n        return mThreads.size();\n    }\n\nprivate:\n    thread_collection(const thread_collection&amp;);\n    thread_collection&amp; operator=(const thread_collection&amp;);\n\n    std::atomic&lt;bool&gt; mStop;\n    std::vector&lt;std::thread&gt; mThreads;\n};\n\nvoid worker(const std::atomic&lt;bool&gt;&amp; stop)\n{\n    while (!stop)\n        std::this_thread::yield();\n}\n\nint main()\n{\n    thread_collection threads;\n\n    try\n    {\n        while (threads.add(worker))\n            continue;\n\n        std::cout &lt;&lt; \"Exhausted thread resources!\" &lt;&lt; std::endl;\n    }\n    catch (const std::exception&amp; e)\n    {\n        std::cout &lt;&lt; \"Stopped for some other reason: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"Made: \" &lt;&lt; threads.size() &lt;&lt; \" threads.\" &lt;&lt; std::endl;\n    threads.clear();\n}\n</code></pre>\n<p><em>(Run this at your own risk!)</em></p>\n<p>According \u00a730.3.1.2/4, this is the error code used to indicate thread creation failure:</p>\n<blockquote>\n<p id=\"so_14408796_14409088_0\">Error conditions:<br>\n  resource_unavailable_try_again \u2014 the system lacked the necessary resources to create another thread, or the system-imposed limit on the number of threads in a process would be exceeded.</br></p>\n</blockquote>\n<p>Note this could be thrown by your own arguments being copied to the resulting thread. To guarantee against this, you need to pre-construct your arguments, then no-throw move them to your thread function.</p>\n<p>That said, you're much better off putting a limit on thread creation anyway. There's no point in having more threads running than cores can execute. Use <code>std::thread::hardware_concurrency</code> to get that number.</p>\n", "LastEditorUserId": "87234", "LastActivityDate": "2013-01-19T18:41:11.980", "Score": "5", "CreationDate": "2013-01-18T23:06:57.277", "ParentId": "14408796", "CommentCount": "4", "OwnerUserId": "87234", "LastEditDate": "2013-01-19T18:41:11.980"}, "14416390": {"Id": "14416390", "PostTypeId": "2", "Body": "<pre><code>try {\n    std::thread t1{ \n        [&amp;](){ p_merge( \"LESS\", depth+1, lvl_id, 0, p1, q1,   p2, q2,   p3, r3 ); } \n    };\n    std::thread t2{ \n        [&amp;](){ p_merge( \"MORE\", depth+1, lvl_id, 1, q1+1, r1, q2, r2, q3+1, r3 ); } \n    };\n    t1.join();\n    t2.join();\n}\ncatch( ... )\n{\n    fprintf( stderr, \"OK - I am dying during a std::thread spawn\\n\" );\n    exit( 1 );\n}\n</code></pre>\n<p>This code may not do what you expect.  If constructing <code>t2</code> throws an exception then <code>t1</code> will be destroyed but because that thread is joinable it will call <code>std::terminate()</code> so your <code>catch</code> will not handle the exception.</p>\n<p>One reason you're seeing <code>terminate called recursively</code> could be that lots of threads have that same problem at once, so lots of threads call <code>terminate()</code> at similar times.</p>\n<p>This would work instead:</p>\n<pre><code>std::thread t1;\nstd::thread t2;\n\ntry {\n    t1 = std::thread{ \n        [&amp;](){ p_merge( \"LESS\", depth+1, lvl_id, 0, p1, q1,   p2, q2,   p3, r3 ); } \n    };\n    t2 = std::thread{ \n        [&amp;](){ p_merge( \"MORE\", depth+1, lvl_id, 1, q1+1, r1, q2, r2, q3+1, r3 ); } \n    };\n}\ncatch( ... )\n{\n    fprintf( stderr, \"OK - I am dying during a std::thread spawn\\n\" );\n    exit( 1 );\n}\n\nt1.join();\nt2.join();\n</code></pre>\n<p>I don't think it's a problem here because the only place in <code>p_merge</code> that can throw is inside a <code>try</code> block, but you should also be aware that if an exception leaves the function run by <code>std::thread</code> that will also call <code>std::terminate()</code> so it that's not what you want then you should pass <code>noexcept</code> functions (or just non-throwing functions) to <code>std::thread</code>.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-01-19T17:39:39.607", "Score": "2", "CreationDate": "2013-01-19T16:33:28.633", "ParentId": "14408796", "CommentCount": "0", "OwnerUserId": "981959", "LastEditDate": "2013-01-19T17:39:39.607"}});