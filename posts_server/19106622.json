post_cb({"bq_ids": {"n4140": {"so_19106622_19114118_0": {"section_id": 71, "quality": 0.8970588235294118, "length": 61}}, "n3337": {"so_19106622_19114118_0": {"section_id": 66, "quality": 0.8970588235294118, "length": 61}}, "n4659": {"so_19106622_19114118_0": {"section_id": 73, "quality": 0.9411764705882353, "length": 64}}}, "19114585": {"ParentId": "19106622", "CommentCount": "0", "Body": "<p>You are right, the theoretical clean distinction between lexer and parser is not always possible. I remember a porject I worked on as a student. We were to implement a C compiler, and the grammar we used as a basis would treat typedefined names as types in some cases, as identifiers in others. So the lexer had to switch between these two modes. The way I implemented this back then was using special empty rules, which reconfigured the lexer depending on context. To accomplish this, it was vital to know that the parser would <em>always</em> use exactly one token of look-ahead. So any change to lexer behaviour would have to occur at least one lexiacal token before the affected location. In the end, this worked quite well.</p>\n<p>In the C++ case of <code>&gt;&gt;</code> you mention, I don't know what compilers actually do. willj quoted how the specification phrases this, but implementations are allowed to do things differently internally, as long as the visible result is the same. So here is how I'd try to tackle this: upon reading a <code>&gt;</code>, the lexer would emit token <code>GREATER</code>, but also switch to a state where each subsequent <code>&gt;</code> <em>without a space in between</em> would be lexed to <code>GREATER_REPEATED</code>. Any other symbol would switch the state back to normal. Instead of state switches, you could also do this by lexing the regular expression <code>&gt;+</code>, and emitting multiple tokens from this rule. In the parser, you could then use rules like the following:</p>\n<pre><code>rightAngleBracket: GREATER | GREATER_REPEATED;\nrightShift: GREATER GREATER_REPEATED;\n</code></pre>\n<p>With a bit of luck, you could make template argument rules use rightAngleBracket, while expressions would use rightShift. Depending on how much look-ahead your parser has, it might be neccessary to introduce additional non-terminals to hold longer sequences of ambiguous content, until you encounter some context which allows you to eventually make the decision between these cases.</p>\n", "OwnerUserId": "1468366", "PostTypeId": "2", "Id": "19114585", "Score": "0", "CreationDate": "2013-10-01T11:07:11.800", "LastActivityDate": "2013-10-01T11:07:11.800"}, "19114118": {"ParentId": "19106622", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The C++ standard requires that an implementation perform lexical analysis to produce a stream of tokens, before the parsing stage. According to the lexical analysis rules, two consecutive <code>&gt;</code> characters (not followed by <code>=</code>) will always be interpreted as one <code>&gt;&gt;</code> token. The grammar provided with the C++ standard is defined in terms of these tokens.</p>\n<p>The requirement that in certain contexts (such as when expecting a <code>&gt;</code> within a template-id) the implementation should interpret <code>&gt;&gt;</code> as two <code>&gt;</code> is not specified within the grammar. Instead the rule is specified as a special case:</p>\n<blockquote>\n<h3>14.2 Names of template specializations [temp.names] ###</h3>\n<p id=\"so_19106622_19114118_0\">After name lookup (3.4) finds that a name is a <em>template-name</em> or that an <em>operator-function-id</em> or a <em>literal-operator-id</em> refers to a set of overloaded functions any member of which is a function template if this is\n  followed by a <code>&lt;</code>, the <code>&lt;</code> is always taken as the delimiter of a <em>template-argument-list</em> and never as the less-than\n  operator. When parsing a template-argument-list, the first non-nested <code>&gt;</code> is taken as the ending delimiter\n  rather than a greater-than operator. Similarly, the first non-nested <code>&gt;&gt;</code> is treated as two consecutive but\n  distinct <code>&gt;</code> tokens, the first of which is taken as the end of the <em>template-argument-list</em> and completes the\n  <em>template-id</em>. [ Note: The second <code>&gt;</code> token produced by this replacement rule may terminate an enclosing\n  <em>template-id</em> construct or it may be part of a different construct (e.g. a cast).\u2014end note ]</p>\n</blockquote>\n<p>Note the earlier rule, that in certain contexts <code>&lt;</code> should be interpreted as the <code>&lt;</code> in a <em>template-argument-list</em>. This is another example of a construct that requires context in order to disambiguate the parse.</p>\n<p>The C++ grammar contains many such ambiguities which cannot be resolved during parsing without information about the context. The most well known of these is known as the <a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow\">Most Vexing Parse</a>, in which an <em>identifier</em> may be interpreted as a <em>type-name</em> depending on context.</p>\n<p>Keeping track of the aforementioned context in C++ requires an implementation to perform some semantic analysis in parallel with the parsing stage. This is commonly implemented in the form of semantic actions that are invoked when a particular grammatical construct is recognised in a given context. These semantic actions then build a data structure that represents the context and permits efficient queries. This is often referred to as a <a href=\"http://en.wikipedia.org/wiki/Symbol_table\" rel=\"nofollow\">symbol table</a>, but the structure required for C++ is pretty much the entire <a href=\"http://en.wikipedia.org/wiki/Abstract_syntax_tree\" rel=\"nofollow\">AST</a>.</p>\n<p>These kind of context-sensitive semantic actions can also be used to resolve ambiguities. For example, on recognising an <em>identifier</em> in the context of a <em>namespace-body</em>, a semantic action will check whether the name was previously defined as a template. The result of this will then be fed back to the parser. This can be done by marking the <em>identifier</em> token with the result, or replacing it with a special token that will match a different grammar rule.</p>\n<p>The same technique can be used to mark a <code>&lt;</code> as the beginning of a <em>template-argument-list</em>, or a <code>&gt;</code> as the end. The rule for context-sensitive replacement of <code>&gt;&gt;</code> with two <code>&gt;</code> poses essentially the same problem and can be resolved using the same method.</p>\n", "OwnerUserId": "1690864", "LastEditorUserId": "1690864", "LastEditDate": "2013-10-01T10:49:34.950", "Id": "19114118", "Score": "5", "CreationDate": "2013-10-01T10:41:00.037", "LastActivityDate": "2013-10-01T10:49:34.950"}, "19106622": {"CommentCount": "23", "AcceptedAnswerId": "19114118", "PostTypeId": "1", "LastEditorUserId": "404264", "CreationDate": "2013-10-01T01:40:17.400", "LastActivityDate": "2013-10-01T11:07:11.800", "LastEditDate": "2013-10-01T07:48:39.990", "ViewCount": "1178", "FavoriteCount": "1", "Title": "Compiler: limitation of lexical analysis", "Id": "19106622", "Score": "4", "Body": "<p>In classic Compiler theory, the first 2 phases are Lexical Analysis and Parsing. They're in a pipeline. Lexical Analysis recognizes tokens as the input of Parsing. </p>\n<p>But I came across some cases which are hard to be correctly recognized in Lexical Analysis. For example, the following code about C++ template:</p>\n<p><code>\nmap&lt;int, vector&lt;int&gt;&gt;\n</code></p>\n<p>the <code>&gt;&gt;</code> would be recognized as bitwise right shift in a \"regular\" Lexical Analysis, but it's not correct. My feeling is it's hard to divide the handling of this kind of grammars into 2 phases, the lexing work has to be done in the parsing phase, because correctly parsing the <code>&gt;&gt;</code> relies on the grammar, not only the simple lexical rule.</p>\n<p>I'd like to know the theory and practice about this problem. Also, I'd like to know how does C++ compiler handle this case? </p>\n", "Tags": "<c++><parsing><compiler-construction>", "OwnerUserId": "404264", "AnswerCount": "2"}});