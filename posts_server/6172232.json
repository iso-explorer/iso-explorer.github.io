post_cb({"6172232": {"CommentCount": "11", "AcceptedAnswerId": "6177338", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2011-05-30T04:16:38.503", "LastActivityDate": "2011-05-30T14:15:47.710", "LastEditDate": "2011-05-30T13:52:46.820", "ViewCount": "3033", "FavoriteCount": "2", "Title": "Is it undefined behaviour to delete a null void* pointer?", "Id": "6172232", "Score": "28", "Body": "<p>I know that <code>delete</code>ing a null pointer is a no-op:</p>\n<blockquote>\n<p id=\"so_6172232_6172232_0\">In either alternative, if the value of the operand of delete is the null pointer the operation has no effect.<br>\n<sub>(C++ Standard <code>5.3.5 [expr.delete] p2</code>)</sub> </br></p>\n</blockquote>\n<p>And also that deleting a <code>void*</code> pointer is undefined behaviour because the destructor can't be called as there are no objects of type <code>void</code>:  </p>\n<blockquote>\n<p id=\"so_6172232_6172232_1\">In the first alternative (<code>delete object</code>), the value of the operand of delete shall be <strong>a pointer to a non-array object or a pointer to a sub-object representing a base class of such an object.</strong> If not, the behavior is undefined.<br>\n<sub>(C++ Standard <code>5.3.5 [expr.delete] p2</code>)</sub></br></p>\n</blockquote>\n<p>Now, normally I take it that things that are listed first overrule things that are listed later on, but what about null <code>void*</code> pointer as the following?</p>\n<pre><code>void* p = 0;\ndelete p; // UB or well-defined?\n</code></pre>\n", "Tags": "<c++><undefined-behavior><void-pointers><language-lawyer><null-pointer>", "OwnerUserId": "500104", "AnswerCount": "3"}, "6177338": {"ParentId": "6172232", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2011-05-30T14:08:00.533", "Score": "12", "LastEditorUserId": "136208", "LastEditDate": "2011-05-30T14:15:47.710", "Id": "6177338", "OwnerUserId": "136208", "Body": "<p>I wonder how you can reach up a situation where you are deleting a pointer only if it is null.  But staying in language lawyering mode...</p>\n<h1>In C++ 03</h1>\n<p>5.3.5/1</p>\n<blockquote>\n<p id=\"so_6172232_6177338_0\">the operand of delete shall have a pointer type or a class type having a single conversion to a pointer type.</p>\n</blockquote>\n<p>void* is a pointer type so a null void pointer meets the static requirement.</p>\n<p>5.3.5/2</p>\n<blockquote>\n<p id=\"so_6172232_6177338_1\">In either alternative [<code>delete</code> and <code>delete[]</code>], if the value of the operand of delete is the null pointer the operation has no effect.</p>\n</blockquote>\n<p>And this gives the wanted behavior.</p>\n<p>5.3.5/3</p>\n<blockquote>\n<p id=\"so_6172232_6177338_2\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand's dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>This is not relevant, a null pointer doesn't reference an object on which to check the additional constraint.</p>\n<h1>In C++ 0X</h1>\n<p>5.3.5/1</p>\n<blockquote>\n<p id=\"so_6172232_6177338_3\">The operand shall have a pointer to object type, or a class type having a single non-explicit conversion function (12.3.2) to a pointer to object type.</p>\n</blockquote>\n<p>void* isn't a pointer to object type, so should be rejected.</p>\n", "LastActivityDate": "2011-05-30T14:15:47.710"}, "6172305": {"ParentId": "6172232", "PostTypeId": "2", "CommentCount": "18", "CreationDate": "2011-05-30T04:33:29.007", "Score": "8", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:47.853", "Id": "6172305", "OwnerUserId": "415784", "Body": "<p>\u00a75.3.5/3 says,</p>\n<blockquote>\n<p id=\"so_6172232_6172305_0\">In the first alternative (delete\n  object), if the static type of the\n  operand is different from its dynamic\n  type, the static type shall be a base\n  class of the operand\u2019s dynamic type\n  and the static type shall have a\n  virtual destructor or the behavior is\n  undefined. In the second alternative\n  (delete array) if the dynamic type of\n  the object to be deleted differs from\n  its static type, the behavior is\n  undefined<sup>73</sup></p>\n</blockquote>\n<p>In the footnote it says,</p>\n<blockquote>\n<p id=\"so_6172232_6172305_1\">73 - <strong>This implies that an object cannot be deleted using a pointer of type void* because there are no objects of type void.</strong></p>\n</blockquote>\n<p>So yeah, its UB. </p>\n<p>Now once it enters into the city of undefined behaviour, it doesn't matter whether its null or not, since its behaviour cannot <em>remain</em> well-defined precisely for the reason that it <em>already</em> got a residence in the city of undefined behavior.</p>\n<hr>\n<p>EDIT:</p>\n<p>Got another topic which also quotes the same and says its UB:</p>\n<p><a href=\"https://stackoverflow.com/questions/941832/is-it-safe-to-delete-a-void-pointer/941959#941959\">Is it safe to delete a void pointer?</a></p>\n</hr>", "LastActivityDate": "2011-05-30T05:12:53.840"}, "bq_ids": {"n4140": {"so_6172232_6177338_1": {"section_id": 6106, "quality": 0.5454545454545454, "length": 6}, "so_6172232_6172232_1": {"section_id": 6106, "quality": 0.8181818181818182, "length": 18}, "so_6172232_6172305_1": {"section_id": 6105, "quality": 0.7857142857142857, "length": 11}, "so_6172232_6172305_0": {"section_id": 6107, "quality": 0.8717948717948718, "length": 34}, "so_6172232_6177338_2": {"section_id": 6107, "quality": 0.88, "length": 22}, "so_6172232_6177338_0": {"section_id": 39, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_6172232_6177338_3": {"section_id": 5871, "quality": 0.8823529411764706, "length": 15}, "so_6172232_6172232_1": {"section_id": 5872, "quality": 0.8181818181818182, "length": 18}, "so_6172232_6172305_1": {"section_id": 5871, "quality": 0.7142857142857143, "length": 10}, "so_6172232_6177338_1": {"section_id": 5872, "quality": 0.5454545454545454, "length": 6}, "so_6172232_6172305_0": {"section_id": 5873, "quality": 0.8717948717948718, "length": 34}, "so_6172232_6177338_2": {"section_id": 5873, "quality": 0.88, "length": 22}, "so_6172232_6177338_0": {"section_id": 5871, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_6172232_6172305_1": {"section_id": 7602, "quality": 0.7857142857142857, "length": 11}, "so_6172232_6177338_3": {"section_id": 8732, "quality": 0.5882352941176471, "length": 10}, "so_6172232_6172232_1": {"section_id": 7603, "quality": 0.8181818181818182, "length": 18}, "so_6172232_6177338_2": {"section_id": 7604, "quality": 0.88, "length": 22}, "so_6172232_6172305_0": {"section_id": 7604, "quality": 0.8717948717948718, "length": 34}, "so_6172232_6177338_1": {"section_id": 7603, "quality": 0.5454545454545454, "length": 6}, "so_6172232_6177338_0": {"section_id": 39, "quality": 0.5833333333333334, "length": 7}}}, "6172300": {"ParentId": "6172232", "CommentCount": "1", "CreationDate": "2011-05-30T04:32:04.360", "OwnerUserId": "165520", "PostTypeId": "2", "Id": "6172300", "Score": "2", "Body": "<p>I believe its undefined behaviour. <code>new void</code> isn't allowed (you are not allowed to create objects of type <code>void</code>) so calling <code>delete</code> on a <code>void*</code> should not make sense either. It doesn't matter if it is pointing to <code>NULL</code> or not. I would never use such thing anywhere in my code. </p>\n", "LastActivityDate": "2011-05-30T04:32:04.360"}});