post_cb({"35131094": {"ParentId": "35130890", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>There are no negative integer constants. There are only positive ones with the unary <code>-</code> operator applied.</p>\n<p>Since <code>2147483648 &gt; INT_MAX</code>, that promotes <code>2147483648</code> to the next larger signed (because you did not append <code>u</code>) integer type, <em>before</em> the <code>-</code> is applied.</p>\n<hr>\n<p>By the way, that is why <code>INT_MIN</code> is usually defined as <code>(-INT_MAX - 1)</code> in <code>&lt;limits.h&gt;</code>. ;-)</p>\n</hr>", "OwnerUserId": "60281", "LastEditorUserId": "60281", "LastEditDate": "2016-02-01T13:21:54.300", "Id": "35131094", "Score": "11", "CreationDate": "2016-02-01T12:54:58.473", "LastActivityDate": "2016-02-01T13:21:54.300"}, "35130890": {"CommentCount": "12", "ViewCount": "178", "CreationDate": "2016-02-01T12:45:16.573", "LastActivityDate": "2016-02-01T13:21:54.300", "Title": "Understanding 2^31 and -2^31 integer promotion", "AcceptedAnswerId": "35131094", "PostTypeId": "1", "Id": "35130890", "Score": "4", "Body": "<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"sizeof(int): %zu\\n\", sizeof(int));\n    printf(\"%d\\n\", 2147483648u &gt; -2147483648);\n    printf(\"%d\\n\", ((unsigned int)2147483648u) &gt; ((int)-2147483648));\n    printf(\"%d\\n\", 2147483648u != -2147483648);\n    printf(\"%d\\n\", ((unsigned int)2147483648u) != ((int)-2147483648));\n    return 0;\n}\n</code></pre>\n<p>The output of this code in both C and C++, on cygwin64 and an rhel6.4 machine with gcc 5.2.0 is:</p>\n<pre><code>sizeof(int): 4\n1\n0\n1\n0\n</code></pre>\n<p>According to \"<a href=\"http://en.cppreference.com/w/c/language/conversion#Integer_promotions\" rel=\"nofollow\">Integer promotions</a>\", <code>2147483648u</code> will be of type <code>unsigned int</code> (even without the <code>u</code> suffix) and <code>-2147483648</code> of type <code>int</code> (as usual). Why the different results with explicit casting?</p>\n<p>According to the \"<a href=\"http://en.cppreference.com/w/c/language/conversion#Usual_arithmetic_conversions\" rel=\"nofollow\">Usual arithmetic conversions</a>\", this paragraph applies:</p>\n<blockquote>\n<p id=\"so_35130890_35130890_0\">Otherwise, the signedness is different: If the operand with the\n  unsigned type has conversion rank greater or equal than the rank of\n  the type of the signed operand, then the operand with the signed type\n  is implicitly converted to the unsigned type</p>\n</blockquote>\n<p>This means that the correct result is as if:</p>\n<pre><code>2147483648u &gt; 2147483648u\n2147483648u != 2147483648u\n</code></pre>\n<p>were performed, because in 32 bits, signed -2^31 and unsigned 2^31 have the same representation. In other words, the result with casting is correct. What is going on?</p>\n<p>I have the feeling that somehow, a higher-rank integer promotion is applied without casting, so I'm getting e.g. a 64-bit signed promotion on both sides -- but why?</p>\n<p>Both executables are compiled as 64-bit, can this play a role?</p>\n", "Tags": "<c++><c><implicit-conversion><integer-promotion>", "OwnerUserId": "189186", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35130890_35130890_0": {"section_id": 5943, "quality": 0.7391304347826086, "length": 17}}, "n3337": {"so_35130890_35130890_0": {"section_id": 5714, "quality": 0.7391304347826086, "length": 17}}, "n4659": {"so_35130890_35130890_0": {"section_id": 7428, "quality": 0.7391304347826086, "length": 17}}}});