post_cb({"4540862": {"Id": "4540862", "PostTypeId": "2", "Body": "<p>The accepted answer in the duplicate question is why, but the standard also explicitly states why this is so:</p>\n<p>8.3.6/9:</p>\n<p>\"\n<em>Example</em>: the declaration of X::mem1() in the following example is ill-formed because no object is supplied for the nonstatic member X::a used as an initializer.</p>\n<pre><code>int b;\nclass X\n  int a;\n  int mem1(int i = a);    // error: nonstatic member a\n                          // used as default argument\n  int mem2(int i = b);    // OK: use X::b\n  static int b;\n};\n</code></pre>\n<p>The declaration of X::mem2() is meaningful, however, since no object is needed to access the static member X::b.  Classes, objects and members are described in clause 9.\n\"</p>\n<p>... and since there exists no syntax to supply the object necessary to resolve the value of <code>X::a</code> at that point, it's effectively impossible to use non-static member variables as initializers for default arguments.</p>\n", "LastActivityDate": "2010-12-27T18:25:51.483", "CommentCount": "0", "CreationDate": "2010-12-27T18:25:51.483", "ParentId": "4539406", "Score": "2", "OwnerUserId": "301883"}, "4539511": {"Id": "4539511", "PostTypeId": "2", "Body": "<p>For one reason, because <code>f</code> is public, but <code>mem</code> is private. As such, code like this:</p>\n<pre><code>int main() { \n    X x;\n    x.f();\n    return 0;\n}\n</code></pre>\n<p>...would involve outside code retrieving X's private data.</p>\n<p>Aside from that, it would (or at least could) also make code generation a bit tricky. Normally, if the compiler is going to use a default argument, it gets the value it's going to pass as part of the function declaration. Generating code to pass that value as a parameter is trivial. When you might be passing a member of an object (possibly nested arbitrarily deeply) and then add in things like the possibility of it being a dependent name in a template, that might (for example) name another object with a conversion to the correct target type, and you have a recipe for making code generation pretty difficult. I don't know for sure, but I suspect somebody thought about things like that, and decided it was better to stay conservative, and <em>possibly</em> open thins up later, if a good reason was found to do so. Given the number of times I've seen problems arise from it, I'd guess it'll stay the way it is for a long time, simply because it rarely causes problems.</p>\n", "LastActivityDate": "2010-12-27T15:00:01.157", "CommentCount": "1", "CreationDate": "2010-12-27T15:00:01.157", "ParentId": "4539406", "Score": "1", "OwnerUserId": "179910"}, "4539444": {"Id": "4539444", "PostTypeId": "2", "Body": "<p>ISO C++ section 8.3.6/9</p>\n<blockquote>\n<p id=\"so_4539406_4539444_0\"><strong>a nonstatic member shall not be used in a default argument expression</strong>, even if it\n  is not evaluated, unless it appears as the id-expression of a class member access expression (5.2.5) or unless it is used to form a pointer to member (5.3.1).</p>\n</blockquote>\n<p>Also check out the example given in that section.</p>\n", "LastActivityDate": "2010-12-27T14:50:18.700", "CommentCount": "2", "CreationDate": "2010-12-27T14:50:18.700", "ParentId": "4539406", "Score": "1", "OwnerUserId": "165520"}, "4539539": {"Id": "4539539", "PostTypeId": "2", "Body": "<p>Default arguments have to be known at compile-time. When you talk about something like a function invocation, then the function is known at compile-time, even if the return value isn't, so the compiler can generate that code, but when you default to a member variable, the compiler doesn't know where to find that instance at compile-time, meaning that it would effectively have to pass a parameter (<code>this</code>) to find mem. Notice that you can't do something like <code>void func(int i, int f = g(i));</code> and the two are effectively the same restriction.</p>\n<p>I also think that this restriction is silly. But then, C++ is full of silly restrictions.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2010-12-27T15:14:06.290", "Score": "6", "CreationDate": "2010-12-27T15:05:21.607", "ParentId": "4539406", "CommentCount": "13", "OwnerUserId": "298661", "LastEditDate": "2010-12-27T15:14:06.290"}, "4540233": {"Id": "4540233", "PostTypeId": "2", "Body": "<p>As DeadMG has mentioned above, somethig like</p>\n<pre>void func(int i, int f = g(i))</pre>\n<p>is illegal for the same reason. i suppose, however, that it is not simply a silly restriction. To allow such a construction, we need to restrict evaluation order for function  parameters (as we need to calculate this before this-&gt;mem), but the c++ standard explicitly declines any assumptions on the evaluation order.</p>\n", "LastActivityDate": "2010-12-27T16:45:28.170", "CommentCount": "0", "CreationDate": "2010-12-27T16:45:28.170", "ParentId": "4539406", "Score": "5", "OwnerUserId": "396672"}, "8783150": {"Id": "8783150", "PostTypeId": "2", "Body": "<p>As all the other answers just discuss the problem, I thought I would post a solution.</p>\n<p>As used in other languages without default arguments (Eg C# pre 4.0)</p>\n<p>Simply use overloading to provide the same result:</p>\n<pre><code>struct X\n{\n   X():mem(42){}\n   void f(int param)\n   {\n      //do something\n   }\n   void f()\n   {\n      f(mem);\n   }\nprivate: \n   int mem;\n};\n</code></pre>\n", "LastActivityDate": "2012-01-09T01:54:23.520", "CommentCount": "0", "CreationDate": "2012-01-09T01:54:23.520", "ParentId": "4539406", "Score": "1", "OwnerUserId": "932588"}, "bq_ids": {"n4140": {"so_4539406_6363678_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 3260}, "so_4539406_4539444_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 3260}}, "n3337": {"so_4539406_6363678_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 3132}, "so_4539406_4539444_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 3132}}, "n4659": {"so_4539406_4539444_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 4018}}}, "6363678": {"Id": "6363678", "PostTypeId": "2", "Body": "<p>Your code (simplified):</p>\n<pre><code>struct X\n{\n   int mem;\n   void f(int param = mem); //ERROR\n};\n</code></pre>\n<p>You want to use a non-static member data as default value for a parameter of a member function. The first question which comes to mind is this : which <em>specific instance</em> of the class the default value <code>mem</code> belongs to?</p>\n<pre><code>X x1 = {100};  //mem = 100\nX x2 = {200};  //mem = 200\n\nx1.f(); //param is 100 or 200? or something else?\n</code></pre>\n<p>Your answer might be <code>100</code> as <code>f()</code> is invoked on the object <code>x1</code>  which has <code>mem = 100</code>. If so, then it requires the implementation to implement <code>f()</code> as:</p>\n<pre><code>void f(X* this, int param = this-&gt;mem);\n</code></pre>\n<p>which in turn requires the first argument to be initialized first before initialization of other argument. But the C++ standard doesn't specify any initialization order of the function arguments. Hence that isn't allowed. Its for the same reason that C++ Standard doesn't allow even this:</p>\n<pre><code>int f(int a, int b = a); //\u00a78.3.6/9\n</code></pre>\n<p>In fact, \u00a78.3.6/9 explicitly says,</p>\n<blockquote>\n<p id=\"so_4539406_6363678_0\">Default arguments are evaluated each\n  time the function is called. <em>The order\n  of evaluation of function arguments is\n  unspecified</em>. <strong>Consequently, parameters\n  of a function shall not be used in\n  default argument expressions</strong>, even if\n  they are not evaluated.</p>\n</blockquote>\n<p>And rest of the section is an interesting read.</p>\n<hr>\n<p>An interesting topic related to \"default\" arguments (not related to this topic though):</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/5637679/default-argument-in-the-middle-of-parameter-list\">Default argument in the middle of parameter list?</a></li>\n</ul>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-06-15T20:12:15.200", "Score": "33", "CreationDate": "2011-06-15T20:07:14.657", "ParentId": "4539406", "CommentCount": "6", "OwnerUserId": "415784", "LastEditDate": "2017-05-23T12:10:45.110"}, "4540580": {"Id": "4540580", "PostTypeId": "2", "Body": "<p>Default arguments are evaluated in two distinct steps, in different contexts.<br>\nFirst, the name lookup for the default argument is performed in the context of the declaration.<br>\nSecondly, the evaluation of the default argument is performed in the context of the actual function call.</br></br></p>\n<p>To keep the implementation from becoming overly complicated, some restrictions are applied to the expressions that can be used as default arguments.</p>\n<ul>\n<li>Variables with non-static lifetime can't be used, because they might not exist at the time of the call.</li>\n<li>Non-static member variables can't be used, because they need an (implicit) <code>this-&gt;</code> qualification, which can typically not be evaluated at the call site.</li>\n</ul>\n", "LastActivityDate": "2010-12-27T17:40:15.280", "CommentCount": "0", "CreationDate": "2010-12-27T17:40:15.280", "ParentId": "4539406", "Score": "0", "OwnerUserId": "430719"}, "4539406": {"ViewCount": "4394", "Body": "<pre><code>struct X\n{\n   X():mem(42){}\n   void f(int param = mem) //ERROR\n   {\n      //do something\n   }\nprivate: \n   int mem;\n};\n</code></pre>\n<p>Can anyone give me just one reason as to why this is illegal in C++?! That is to say, I know that it is an error, I know what the error means, I just can't understand why would this be illegal!</p>\n", "AcceptedAnswerId": "6363678", "Title": "Nonstatic member as a default argument of a nonstatic member function", "CreationDate": "2010-12-27T14:42:24.187", "Id": "4539406", "CommentCount": "8", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2012-03-20T18:35:23.480", "LastEditorUserId": "597607", "LastActivityDate": "2012-03-20T18:35:23.480", "Score": "23", "OwnerUserId": "469935", "Tags": "<c++><default-value><member-functions>", "AnswerCount": "9"}, "4539512": {"Id": "4539512", "PostTypeId": "2", "Body": "<p>Compiler has to know addresses to maintain default values at compile time. Addresses of non-static member variables are unknown at compile time.</p>\n", "LastActivityDate": "2010-12-27T15:00:10.473", "CommentCount": "2", "CreationDate": "2010-12-27T15:00:10.473", "ParentId": "4539406", "Score": "1", "OwnerUserId": "496138"}});