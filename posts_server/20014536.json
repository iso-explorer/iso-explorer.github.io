post_cb({"20014536": {"CommentCount": "0", "ViewCount": "1371", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-11-16T04:07:00.740", "LastActivityDate": "2013-11-16T04:14:05.610", "Title": "operator overloading - inline non-member functions", "AcceptedAnswerId": "20014588", "LastEditDate": "2017-05-23T12:24:56.457", "Id": "20014536", "Score": "1", "Body": "<p>OK, so I can get my code to work, but there's something that's bugging me.  It has to do with operator overloading and making non-member functions inline.  Here's a very simple program that implements a complex number object:</p>\n<p>Contained in Complex.h</p>\n<pre><code>using namespace std;\n\nclass Complex {\n private:\n  double real;\n  double imaginary;\n\n public:\n\n  Complex(void);\n  Complex(double r, double i);\n  double getReal();\n  double getImaginary();\n  string toString();\n};\n\ninline Complex operator+(Complex lhs, Complex rhs);\n</code></pre>\n<p>...and in Complex.cc</p>\n<pre><code>#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include \"Complex.h\"\n\nusing namespace std;\n\nComplex::Complex(void)\n{\n...not important...\n}\n\nComplex::Complex(double r, double i)\n{\n  real = r;\n  imaginary = i;\n}\n\ndouble Complex::getReal()\n{\n  return real;\n}\n\ndouble Complex::getImaginary()\n{\n  return imaginary;\n}\n\nstring Complex::toString()\n{\n...what you would expect, not important here...\n}\n\n\ninline Complex operator+(Complex lhs, Complex rhs)\n{\n  double result_real = lhs.getReal() + rhs.getReal();\n  double result_imaginary = lhs.getImaginary() + rhs.getImaginary();\n\n  Complex result(result_real, result_imaginary);\n\n  return(result);\n}\n</code></pre>\n<p>and finally in plus_overload_test.cc</p>\n<pre><code>using namespace std;\n\n#include &lt;iostream&gt;\n#include \"Complex.h\"\n\nint main(void)\n{\n  Complex c1(1.0,3.0);\n  Complex c2(2.5,-5.2);\n\n  Complex c3 = c1 + c2;\n\n  cout &lt;&lt; \"c3 is \" &lt;&lt; c3.toString() &lt;&lt; endl;\n\n  return(0);\n}\n</code></pre>\n<p>Compiling with g++ using a makefile that does the linking this produces the error:</p>\n<pre><code>plus_overload_test.cc:(.text+0x5a): undefined reference to `operator+(Complex, Complex)'\n</code></pre>\n<p>If I just remove the \"inline\" from before the operator+ in Complex.h and Complex.cc then everything compiles and works as it should.  Why does the inline modifier cause this error?  Everyone, for example:</p>\n<p><a href=\"https://stackoverflow.com/questions/4421706/operator-overloading/4421719#4421719\">Operator overloading</a></p>\n<p>and</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/operators\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/operators</a></p>\n<p>seems to recommend that for overloading binary operators the functions should be non-member and inline.  So why am I encountering an error when I make them inline?</p>\n<p>And, yes, I realize that the inline modifier may be a red herring since modern compilers should take care of this.  But I remain curious.</p>\n<p>Cheers!</p>\n", "Tags": "<c++><overloading><inline><operator-keyword><non-member-functions>", "OwnerUserId": "2980771", "AnswerCount": "1"}, "20014588": {"ParentId": "20014536", "CommentCount": "1", "Body": "<p>An <code>inline</code> function must be defined in every file where it's used.</p>\n<p>In case you want the precise wording from the standard (\u00a77.1.2/4): </p>\n<blockquote>\n<p id=\"so_20014536_20014588_0\">An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly the same definition in every case.</p>\n</blockquote>\n<p>With it marked <code>inline</code>, but defined in only one translation unit, you weren't meeting your side of your contract with the compiler (so to speak).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "20014588", "Score": "1", "CreationDate": "2013-11-16T04:14:05.610", "LastActivityDate": "2013-11-16T04:14:05.610"}, "bq_ids": {"n4140": {"so_20014536_20014588_0": {"section_id": 5404, "quality": 1.0, "length": 13}}, "n3337": {"so_20014536_20014588_0": {"section_id": 5199, "quality": 1.0, "length": 13}}, "n4659": {"so_20014536_20014588_0": {"section_id": 6853, "quality": 1.0, "length": 13}}}});