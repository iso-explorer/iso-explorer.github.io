post_cb({"bq_ids": {"n4140": {"so_16879988_16879995_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 7192}}, "n3337": {"so_16879988_16879995_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 6936}}, "n4659": {"so_16879988_16879995_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 8701}}}, "16879988": {"ViewCount": "1165", "Body": "<p>I do this:</p>\n<pre><code>MyClass myObject = *new MyClass();\n</code></pre>\n<p>But a lot of people say I should do this:</p>\n<pre><code>MyClass *myObject = new MyClass();\n</code></pre>\n<p>Is there a performance difference. Or a logical reason to use the second method at all? I just prefer to use the first method to get rid of the pointer confusions.</p>\n", "AcceptedAnswerId": "16879995", "Title": "new vs *new in C++", "CreationDate": "2013-06-02T05:13:14.360", "Id": "16879988", "CommentCount": "10", "FavoriteCount": "6", "PostTypeId": "1", "LastActivityDate": "2013-06-02T06:00:35.500", "Score": "13", "OwnerUserId": "2444393", "Tags": "<c++><pointers><dynamic><stack>", "AnswerCount": "3"}, "16879995": {"Id": "16879995", "PostTypeId": "2", "Body": "<p><strong>Both are not same!</strong><br>\nFirst gives you a Undefined behavior<sup>[Ref 1:]</sup> or a memory leak while second doesn't if you call <code>delete</code> later.</br></p>\n<pre><code>MyClass myObject = *new MyClass();\n</code></pre>\n<p>Allocates a object of type <code>MyClass</code> on freestore and then copies that object to <code>myObject</code>. You lose the pointer to the dynanically allocated object and thus can never deallocate it.<br>\nIf <code>MyClass</code> destructor has <em>side effects</em> and your program depends on those side effects then it gives you <strong>Undefined Behavior</strong> if not then what you have is a simple plain <strong>memory leak</strong>.</br></p>\n<pre><code>MyClass *myObject = new MyClass();\n</code></pre>\n<p>Allocates a object of type <code>MyClass</code> on freestore and the points <code>myObject</code> to the address where the dynamically allocated object is placed. You still have the pointer to the object, which you can deallocate by calling <code>delete</code> later on.</p>\n<hr>\n<p>If your question is, what is the best way to do this,<br>\nThe answer is to not use dynamically allocated object at all:       </br></p>\n<pre><code>MyClass obj;\n</code></pre>\n<p><strong>Good Read:</strong> </p>\n<p><a href=\"https://stackoverflow.com/questions/6500313/why-should-new-be-used-as-little-as-possible\">Why should C++ programmers minimize use of 'new'?</a></p>\n<hr>\n<p><sup>[Ref 1:]</sup><br>\n<strong>C++11 Standard: 3.8.4:</strong> </br></p>\n<blockquote>\n<p id=\"so_16879988_16879995_0\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to\n  the destructor or if a delete-expression (5.3.5) is not used to release the storage, <strong>the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</strong></p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-02T06:00:35.500", "Score": "28", "CreationDate": "2013-06-02T05:14:24.320", "ParentId": "16879988", "CommentCount": "11", "OwnerUserId": "452307", "LastEditDate": "2017-05-23T12:00:00.947"}, "16880014": {"Id": "16880014", "PostTypeId": "2", "Body": "<p>The first example says: Allocate memory on the stack for an instance of MyObject, then allocate memory on the heap for another one, construct the one on the heap, copy its contents to the one on the stack, and then lose track of the heap pointer so it can't be freed.</p>\n<p>The second one says: Allocate a pointer on the stack, allocate space for an instance of MyObject on the heap, construct it, and assign the pointer to its address so it can be freed later.</p>\n<p>The second case uses less memory, is faster, and doesn't leak memory. The first case says \"I don't understand C++\".</p>\n", "LastActivityDate": "2013-06-02T05:19:42.387", "CommentCount": "0", "CreationDate": "2013-06-02T05:19:42.387", "ParentId": "16879988", "Score": "22", "OwnerUserId": "2192494"}, "16880011": {"Id": "16880011", "PostTypeId": "2", "Body": "<p>The first is nonsense.</p>\n<pre><code>MyClass myObject = *new MyClass();\n</code></pre>\n<p>The part after the <code>=</code> allocates memory and creates a new <code>MyClass</code> object.\nThe first part creates a new <code>MyClass</code> object by calling copy constructor with the RHS <code>MyClass</code> object. Then the memory allocated in the RHS leaks because you don't have a saved pointer to delete it with.</p>\n<p>The above statement is the same as writing.</p>\n<pre><code>MyClass myObject;\n</code></pre>\n<p>Followed by</p>\n<pre><code>Leak memory equal to size of MyClass.\n</code></pre>\n<p>First of all decide whether you want an object on the stack or on the heap.</p>\n<p>If you want an object on the stack, then do</p>\n<pre><code>MyClass myObject;\n</code></pre>\n<p>This creates a MyClass Object - it serves well for most purposes.</p>\n<p>If you need an object on the heap, then do</p>\n<pre><code>MyClass *myObject = new MyClass();\n</code></pre>\n<p>The first way - allocating on the stack is more efficient. You do heap allocation for other reasons</p>\n<ol>\n<li>At compile time, you don't know how many objects you need to create.</li>\n<li>Use classes polymorphically.</li>\n</ol>\n", "LastEditorUserId": "922712", "LastActivityDate": "2013-06-02T05:24:42.267", "Score": "2", "CreationDate": "2013-06-02T05:19:37.247", "ParentId": "16879988", "CommentCount": "4", "OwnerUserId": "922712", "LastEditDate": "2013-06-02T05:24:42.267"}});