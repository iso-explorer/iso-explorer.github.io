post_cb({"13758060": {"Id": "13758060", "PostTypeId": "2", "Body": "<p>As you say, the standard says:</p>\n<blockquote>\n<p id=\"so_13754778_13758060_0\">literal words and characters in constant width type</p>\n</blockquote>\n<p>So, if a literal space were to be included in a rule, it would have to be rendered in a constant width type. Close examination of the standard will reveal that the space in the production you refer to is narrower than the constant width type. (Also your attempt to quote the standard is a misrepresentation because it renders in constant-width type that which should be rendered in italics, with a consequent semantic change.)</p>\n<hr>\n<p>Ok, that was the \"aspiring language lawyer\" answer; furthermore, it doesn't really work because it fails on all the productions which are of the form:</p>\n<pre><code>One of:\n0 1 2 3 4 5 6 7 8 9\n</code></pre>\n<p>I think, in reality, the answer is that whitespace is not part of the formal grammar, because it serves only to separate tokens; furthermore, that statement is mostly true of the grammar itself, whose tokens are separated by whitespace without that whitespace being a token, except that indentation in the grammar matters, unlike indentation in a program.</p>\n<hr>\n<p><strong>Addendum to answer the addendum</strong></p>\n<p>It's not actually true that <code>const</code> and <code>volatile</code> need to be separated by whitespace. They simply need to be separate tokens. Example:</p>\n<pre><code>#define A(x)x\nA(const)A(volatile)A(int)A(x)A(;)\n</code></pre>\n<p>Again, more seriously, Chapter 2 (with particular reference to 2.2 and 2.5, but you have to read the entire text) describe how the program text is processed in order to produce a stream of tokens. All of the rules in which you claim whitespace must be ignored are in this part of the grammar, and all of the rules in which you claim whitespace might be required are not.</p>\n<p>These are really two separate grammars, but the lexical grammar is necessarily incomplete because you need to consider the operation of the preprocessor in order to apply it.</p>\n<p>I believe that everything I said can be gleaned from the standard. Here are some excerpts:</p>\n<blockquote>\n<p id=\"so_13754778_13758060_1\">2.2(3) The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments)\u2026 The process of dividing a source file\u2019s characters into preprocessing tokens is context-dependent.</p>\n<p id=\"so_13754778_13758060_2\">\u2026</p>\n<p id=\"so_13754778_13758060_3\">2.2(7) White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The resulting tokens are syntactically and semantically analyzed and translated as a translation unit.</p>\n</blockquote>\n<p>I think that all this makes it clear that there are two grammars, one lexical -- that is, it produces a lexeme (token) from a sequence of graphemes (characters) -- and the other syntactic -- that is, it produces an abstract syntax tree from a sequence of lexemes (tokens). In neither case (with a small exception, which I'll get to in a minute) is whitespace considered anything other than something which stops two lexemes from running into each other if the lexical grammar would otherwise allow that. (See the algorithm in 2.5(3).)</p>\n<p><code>C++</code> is not syntactically pretty, so there are almost always exceptions. One of these, inherited from <code>C</code>, is the difference between:</p>\n<pre><code>#define A(X)(X)\n</code></pre>\n<p>and</p>\n<pre><code>#define A (X)(X)\n</code></pre>\n<p>Preprocessing directives have their own parsing rules, and this one is typified by the definition:</p>\n<blockquote>\n<p id=\"so_13754778_13758060_4\"><i>lparen</i>:<br>\n  \u00a0\u00a0a <code>(</code> character not immediately preceded by white-space</br></p>\n</blockquote>\n<p>This, I would say, is the exception that proves the rule [Note 1]. The fact that it is necessary to say that this <code>(</code> is not preceded by white-space shows that the normal use of the token <code>(</code> in a syntactic rule does not say anything about its blancospatial context.</p>\n<p>So, to paraphrase Ray Cummings (not Albert Einstein, as is sometimes claimed), \"time and white-space are all that separate one token from another.\" [Note 2] </p>\n<hr>\n<p>[Note 1] I use the phrase here in its original legal sense, as per<a href=\"http://en.wikipedia.org/wiki/Exception_that_proves_the_rule\" rel=\"nofollow\">Cicero</a>.</p>\n<p>[Note 2]:</p>\n<blockquote>\n<p id=\"so_13754778_13758060_5\">\"Time,\" said George, \"why I can give you a definition of time. It's what keeps everything from happening at once.\"</p>\n<p id=\"so_13754778_13758060_6\">A ripple of laughter went about the little group of men.</p>\n<p id=\"so_13754778_13758060_7\">\"Quite so,\" agreed the Chemist. \"And, gentlemen, that's not so funny as it sounds. As a matter of fact, it is really not a bad scientific definition. Time and space are all that separate one event from another\u2026</p>\n</blockquote>\n<p>-- From <i>The man who mastered time</i>, by Ray Cummings, 1929, Ace Books. See <a href=\"http://books.google.com.pe/books?id=Imx5-W7OAbwC&amp;lpg=PP1&amp;pg=PA5#v=onepage&amp;q&amp;f=false\" rel=\"nofollow\">first page, in Google books</a></p>\n</hr></hr></hr>", "LastEditorUserId": "1566221", "LastActivityDate": "2012-12-07T19:03:14.967", "Score": "3", "CreationDate": "2012-12-07T06:28:45.610", "ParentId": "13754778", "CommentCount": "8", "LastEditDate": "2012-12-07T19:03:14.967", "OwnerUserId": "1566221"}, "13754778": {"ViewCount": "481", "Body": "<p>At the risk of asking a question deemed too nit-picky, I have spent a long time trying to justify (as a single example of something that occurs throughout the standard in different contexts) the following definition of an <code>integer literal</code> in \u00a72.14.2 of the C++11 standard, specifically in regards to one detail, the presence of whitespace in the syntax notation itself.</p>\n<p>(Note that this example - the definition of an integer literal - is not the point of my question.  The point of my question is to ask about the syntax description notation used by the C++ standard <em>itself</em>, specifically in regards to whitespace between grammatical category names.  The example I give here - the definition of an integer literal - is specifically chosen <em>only</em> because it acts as an example that is simple and clear-cut.)</p>\n<p>(Abbreviated for concision, from \u00a72.14.2):</p>\n<pre><code>integer-literal:\n    decimal-literal integer-suffix_opt\n\ndecimal-literal:\n    nonzero-digit\n    decimal-literal digit\n</code></pre>\n<p>(with <code>nonzero-digit</code> and <code>digit</code> as expected, [0] 1 ... 9).  (Note: The above text is all in italics in the standard.)</p>\n<p>This all makes sense to me, assuming that the SPACE between the syntax category descriptives <em><code>decimal-literal</code></em> and <em><code>digit</code></em> is understood to NOT be present in the actual source code, but is only present in the syntax description itself as it appears here in section \u00a72.14.2.</p>\n<p>This convention - placing a space between category descriptives within the notation, where it is understood that the space is not to be present in the source code - is used in other places in the specification.  The example here is just a clear-cut case where the space is clearly not supposed to be present in the source code.  (See addendum to this question for counterexamples from the standard where whitespace or other separator/s <em>must</em> be present, or is optional, between category descriptives when those category descriptives are replaced by actual tokens in the source code.)</p>\n<p>Again, at the risk of being nit-picky, I cannot find anywhere in the standard a statement of convention that spaces are NOT to be present in the source code when interpreting notation such as in this example.</p>\n<p>The standard does discuss notational convention in \u00a71.6.1 (and thereafter).  The only relevant text that I can find regarding this is:</p>\n<blockquote>\n<p id=\"so_13754778_13754778_0\">In the syntax notation used in this International Standard, syntactic\n  categories are indicated by italic type, and literal words and\n  characters in constant width type. Alternatives are listed on separate\n  lines except in a few cases where a long set of alternatives is marked\n  by the phrase \u201cone of.\u201d</p>\n</blockquote>\n<p>I would not be so nit-picky; however, I find the notation used within the standard to be somewhat tricky, so I would like to be clear on all of the details.  I appreciate anyone willing to take the time to fill me in on this.</p>\n<p><strong>ADDENDUM</strong>  In response to comments in which a claim is made similar to \"<em>it's obvious that whitespace should not be included in the final source code, so there's no need for the standard to explicitly state this</em>\": I have chosen a trivial example in this question, where it <em>is</em> obvious.  There are many cases in the standard where it <em>isn't</em> obvious without a. priori knowledge of the language (in my opinion), such as \u00a78.0.4 discussing \"const\" and \"volatile\":</p>\n<pre><code>cv-qualifier-seq:\n    cv-qualifier cv-qualifier-seq_opt\n</code></pre>\n<p>... Note the <em>opposite</em> assumption here (whitespace, or another separator or separators, is <em>required</em> in the final source code), but that's not possible to deduce from the syntax notation itself.</p>\n<p>There are also cases where a space is <em>optional</em>, such as:</p>\n<pre><code>noptr-abstract-declarator:\n    noptr-abstract-declarator_opt parameters-and-qualifiers\n</code></pre>\n<p>(In this example, to make a point, I won't give the section number or paraphrase what is being discussed; I'll just ask if it's obvious from the grammar notation itself that, in <em>this</em> context, whitespace in the final source code is optional between the tokens.)</p>\n<p>I suspect that the comments along these lines - \"it's obvious, so that's what it must be\" - are the result of the fact that the example I've chosen is so obvious.  That's exactly why I chose the example.</p>\n", "AcceptedAnswerId": "13758060", "Title": "In the C++ standard, where does it indicate the spacing protocol for the replacement of category descriptives by the source code it represents?", "CreationDate": "2012-12-06T23:52:55.447", "Id": "13754778", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-12-07T15:44:49.663", "LastEditorUserId": "368896", "LastActivityDate": "2012-12-07T19:20:54.063", "Score": "10", "OwnerUserId": "368896", "Tags": "<c++><c++11><standards>", "AnswerCount": "4"}, "13757463": {"Id": "13757463", "PostTypeId": "2", "Body": "<p>I'm reasonably certain there is no more direct explanation of this fact in the standard. </p>\n<p>The notation used is similar enough to typical BNF that they take many of the same general conventions for granted, including the fact that whitespace in the notation has no significance beyond separating the tokens of the BNF itself -- that if/when whitespace has significance in the source code beyond separating tokens, they'll include notation to specify it directly (e.g., for most preprocessing directives, the <code>new-line</code> is specified directly:</p>\n<p># ifdef <em>identifier new-line group<sub>opt</sub></em></p>\n<p>or:</p>\n<p># include <em>&lt; h-char-sequence&gt; new-line</em></p>\n<p>The blame for that <em>probably</em> goes back to the Algol 68 standard, which went so far overboard in its attempts at precisely specifying syntax that it was essentially impossible for anybody to read without weeks of full-time study<sup>1</sup>. Since then, any more than the most cursory explanation of the syntax description language leads to rejection on the basis that it's too much like Algol 68 and will undoubtedly fail because it's too formal and nobody will ever read or understand it.</p>\n<hr>\n<p><sup>1</sup> How could it be that bad you ask? It basically went like this: they started with a formal English description of a syntax description language. That wasn't used to define Algol 68 though -- it was used to specify (even more precisely) <em>another</em> syntax description language. That <em>second</em> syntax description language was then used to specify the syntax of Algol 68 itself. So, you had to learn two separate syntax description languages <em>before</em> you could start to read the Algol 68 syntax itself at all. As you can undoubtedly guess, almost nobody ever did.</p>\n</hr>", "LastActivityDate": "2012-12-07T05:30:46.173", "Score": "6", "CreationDate": "2012-12-07T05:30:46.173", "ParentId": "13754778", "CommentCount": "3", "OwnerUserId": "179910"}, "bq_ids": {"n4140": {"so_13754778_13769502_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 5313}, "so_13754778_13769502_10": {"length": 9, "quality": 1.0, "section_id": 5322}, "so_13754778_13758060_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 5313}, "so_13754778_13769502_13": {"length": 18, "quality": 1.0, "section_id": 5322}, "so_13754778_13769502_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 491}, "so_13754778_13758060_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5313}, "so_13754778_13754778_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5783}, "so_13754778_13769502_12": {"length": 16, "quality": 1.0, "section_id": 5322}, "so_13754778_13758060_4": {"length": 4, "quality": 0.8, "section_id": 491}, "so_13754778_13769502_9": {"length": 4, "quality": 1.0, "section_id": 491}, "so_13754778_13758060_0": {"length": 6, "quality": 1.0, "section_id": 5783}, "so_13754778_13769502_11": {"length": 20, "quality": 1.0, "section_id": 5322}, "so_13754778_13754916_0": {"length": 28, "quality": 1.0, "section_id": 5327}}, "n3337": {"so_13754778_13769502_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 5110}, "so_13754778_13769502_10": {"length": 9, "quality": 1.0, "section_id": 5119}, "so_13754778_13769502_9": {"length": 4, "quality": 1.0, "section_id": 482}, "so_13754778_13769502_13": {"length": 18, "quality": 1.0, "section_id": 5119}, "so_13754778_13769502_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 482}, "so_13754778_13758060_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5110}, "so_13754778_13754778_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5556}, "so_13754778_13769502_12": {"length": 16, "quality": 1.0, "section_id": 5119}, "so_13754778_13758060_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 5110}, "so_13754778_13758060_4": {"length": 4, "quality": 0.8, "section_id": 482}, "so_13754778_13758060_0": {"length": 6, "quality": 1.0, "section_id": 5556}, "so_13754778_13769502_11": {"length": 20, "quality": 1.0, "section_id": 5119}, "so_13754778_13754916_0": {"length": 28, "quality": 1.0, "section_id": 5124}}, "n4659": {"so_13754778_13769502_12": {"length": 15, "quality": 0.9375, "section_id": 6743}, "so_13754778_13769502_10": {"length": 9, "quality": 1.0, "section_id": 6743}, "so_13754778_13769502_9": {"length": 4, "quality": 1.0, "section_id": 506}, "so_13754778_13769502_13": {"length": 18, "quality": 1.0, "section_id": 6743}, "so_13754778_13769502_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 506}, "so_13754778_13758060_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 6737}, "so_13754778_13754778_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 7240}, "so_13754778_13769502_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6737}, "so_13754778_13758060_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 6737}, "so_13754778_13758060_4": {"length": 4, "quality": 0.8, "section_id": 506}, "so_13754778_13758060_0": {"length": 6, "quality": 1.0, "section_id": 7240}, "so_13754778_13769502_11": {"length": 20, "quality": 1.0, "section_id": 6743}, "so_13754778_13754916_0": {"length": 28, "quality": 1.0, "section_id": 6748}}}, "13754916": {"Id": "13754916", "PostTypeId": "2", "Body": "<p>\u00a72.7.1</p>\n<blockquote>\n<p id=\"so_13754778_13754916_0\">There are five kinds of tokens: identifiers, keywords, literals,\n  operators, and other separators. Blanks, horizontal and vertical tabs,\n  newlines, formfeeds, and comments (collectively, \u201cwhite space\u201d), as\n  described below, are ignored <strong>except as they serve to separate tokens</strong>.</p>\n</blockquote>\n<p>So, if a literal is a token, and whitespace serves to seperate tokens, space in between the digits of a literal would be interpreted as two separate tokens, and therefore cannot be part of the same literal.</p>\n", "LastActivityDate": "2012-12-07T00:08:20.003", "Score": "8", "CreationDate": "2012-12-07T00:08:20.003", "ParentId": "13754778", "CommentCount": "15", "OwnerUserId": "440119"}, "13769502": {"Id": "13769502", "PostTypeId": "2", "Body": "<p>The Standard actually has two separate grammars.</p>\n<p>The preprocessor grammar, described in sections 2 and 16, defines how a sequence of source characters is converted to a sequence of preprocessing tokens and whitespace characters, in translation phases 1-6.  In some of these phases and parts of this grammar, whitespace is significant.</p>\n<p>Whitespace characters which are not part of preprocessing tokens stop being significant after translation phase 4.  The Standard explicitly says at the start of translation phase 7 to discard whitespace characters between preprocessing tokens.</p>\n<p>The language grammar defines how a sequence of tokens (converted from preprocessing tokens) are syntactically and semantically interpreted in translation phase 7.  There is no such thing as whitespace in this grammar.  (By this point, <code>' '</code> is a <em>character-literal</em> just like <code>'c'</code> is.)</p>\n<p>In both grammars, the space between grammar components visible in the Standard has nothing to do with source or execution whitespace characters, it's just there to make the Standard legible.  When the preprocessor grammar depends on whitespace, it spells it out with words, for example:</p>\n<blockquote>\n<p id=\"so_13754778_13769502_0\"><em>c-char</em>:</p>\n<p id=\"so_13754778_13769502_1\">any member of the source character set except the single-quote <code>'</code>, backslash <code>\\</code>, or new-line character</p>\n<p id=\"so_13754778_13769502_2\"><em>escape-sequence</em></p>\n<p id=\"so_13754778_13769502_3\"><em>universal-character-name</em></p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_13754778_13769502_4\"><em>control-line</em>:</p>\n<p id=\"so_13754778_13769502_5\">...</p>\n<p id=\"so_13754778_13769502_6\"><code># define</code> <em>identifier lparen identifier-list</em>[opt] <code>)</code> <em>replacement-list newline</em></p>\n<p id=\"so_13754778_13769502_7\">...</p>\n<p id=\"so_13754778_13769502_8\"><em>lparen</em>:</p>\n<p id=\"so_13754778_13769502_9\">a <code>(</code> character not immediately preceded by white-space</p>\n</blockquote>\n<p>So there may not be whitespace between digits of an <em>integer-literal</em> because the preprocessor grammar does not allow it.</p>\n<p>One other important rule here is from C++11 2.5p3:</p>\n<blockquote>\n<p id=\"so_13754778_13769502_10\">If the input stream has been parsed into preprocessing tokens up to a given character:</p>\n<ul>\n<li><p id=\"so_13754778_13769502_11\">If the next character begins a sequence of characters that could be the prefix and initial double quote of a raw string literal, such as <code>R\"</code>, the next preprocessing token shall be a raw string literal. ...</p></li>\n<li><p id=\"so_13754778_13769502_12\">Otherwise, if the next three characters are <code>&lt;::</code> and the subsequent character is neither <code>:</code> nor <code>&gt;</code>, the <code>&lt;</code> is treated as a preprocessor token by itself and not as the first character of the alternative token <code>&lt;:</code>.</p></li>\n<li><p id=\"so_13754778_13769502_13\">Otherwise, the next preprocessing token is the longest sequence of characters that could constitute a preprocessing token, even if that would cause further lexical analysis to fail.</p></li>\n</ul>\n</blockquote>\n<p>So there must be whitespace between <code>const</code> and <code>volatile</code> tokens because otherwise, the longest-token-possible rule would convert that to a single <em>identifier</em> token <code>constvolatile</code>.</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2012-12-07T19:20:54.063", "Score": "3", "CreationDate": "2012-12-07T19:09:28.590", "ParentId": "13754778", "CommentCount": "1", "LastEditDate": "2012-12-07T19:20:54.063", "OwnerUserId": "459640"}});