post_cb({"bq_ids": {"n4140": {"so_40454514_40454850_3": {"length": 47, "quality": 0.94, "section_id": 761}, "so_40454514_40454850_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 753}}, "n3337": {"so_40454514_40454850_3": {"length": 47, "quality": 0.94, "section_id": 748}, "so_40454514_40454850_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 741}}, "n4659": {"so_40454514_40454850_3": {"length": 47, "quality": 0.94, "section_id": 821}, "so_40454514_40454850_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 813}}}, "40454850": {"Id": "40454850", "PostTypeId": "2", "Body": "<p>The standard states the requirements and guarantees, but doesn't explicitly force the underlying data structures and algorithms.</p>\n<blockquote>\n<p id=\"so_40454514_40454850_0\">N4140 \u00a723.2.5 [unord.req]/1</p>\n<p id=\"so_40454514_40454850_1\">Unordered associative containers provide an ability for fast retrieval\n  of data based on keys. The worstcase complexity for most operations is\n  linear, but the average case is much faster.</p>\n</blockquote>\n<p>This is a little weird, because it states the worst case complexity as a fact, instead of just allowing it.</p>\n<blockquote>\n<p id=\"so_40454514_40454850_2\">N4140 \u00a723.2.5 [unord.req]/9</p>\n<p id=\"so_40454514_40454850_3\">The elements of an unordered associative container are organized into\n  <em>buckets</em>. Keys with the same hash code appear in the same bucket. The number of buckets is automatically increased as elements are added to\n  an unordered associative container, so that the average number of\n  elements per bucket is kept below a bound. <em>Rehashing invalidates\n  iterators, changes ordering between elements, and changes which\n  buckets elements appear in, but does not invalidate pointers or\n  references to elements</em>.</p>\n</blockquote>\n<p>The above does seem to invalidate <code>std::set</code> as a possible data type, but should allow a <code>set</code>-like data structure if it allowed moving elements between its instances without invalidating pointers or references.</p>\n<p>That leaves one hurdle: <code>set</code>s would require a comparator/<code>operator&lt;</code> to be defined (with strict weak ordering semantics), while unordered associative containers make no such requirement. In this case you could simply fall back to linked list if it isn't defined, though.</p>\n<p>So, as far as I can tell, you could replace the linked list with a set-like structure, if the aforementioned conditions were met. That being said, it does feel like a problem that you shouldn't have experienced in the first place, had you used a proper hashing algorithm.</p>\n", "LastActivityDate": "2016-11-06T21:41:59.210", "CommentCount": "1", "CreationDate": "2016-11-06T21:41:59.210", "ParentId": "40454514", "Score": "3", "OwnerUserId": "2456565"}, "40454514": {"ViewCount": "154", "Body": "<p>When a hash value for an element in a <code>unordered_set</code> is computed it is placed in a \"bucket\" together with other -- different -- elements but same hash value.</p>\n<p>My experience is that the elements in such a bucket are stored in a singly linked list. Meaning, it gets <em>very</em> slow when searching inside a bucket with a bad hash function.</p>\n<p>Is the singly linked list a requirement by the standard or just one possible implementation? Could one implement <code>unordered_set</code> with <code>set</code>s as buckets?</p>\n", "AcceptedAnswerId": "40454850", "Title": "Does the C++ standard define the structure of a bucket for unordered_set?", "CreationDate": "2016-11-06T21:04:34.940", "Id": "40454514", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-11-06T21:41:59.210", "Score": "4", "OwnerUserId": "472245", "Tags": "<c++><unordered-set><hash-function>", "AnswerCount": "1"}});