post_cb({"7113621": {"Id": "7113621", "PostTypeId": "2", "Body": "<p>In addition to the other notes, <code>sizeof</code> is a compile-time operator, so <code>clear()</code> will not zero out any members added by derived classes (except as noted due to padding weirdness).</p>\n<p>There's nothing really \"subtle\" about this; <code>memset</code> is a horrible thing to be using in C++. In the rare cases where you really can just fill memory with zeros and expect sane behaviour, <strong>and</strong> you really need to fill the memory with zeros, <strong>and</strong> zero-initializing everything via the initializer list the civilized way is somehow unacceptable, use <code>std::fill</code> instead.</p>\n", "LastActivityDate": "2011-08-18T20:19:04.157", "CommentCount": "4", "CreationDate": "2011-08-18T20:19:04.157", "ParentId": "7113422", "Score": "4", "OwnerUserId": "523612"}, "7113474": {"Id": "7113474", "PostTypeId": "2", "Body": "<p>The compiler is likely to add padding bytes to A. So <code>sizeof(A)</code> extends beyond <code>char type</code> (until the end of the padding). However in case of inheritance the compiler might not add the padded bytes. So the call to <code>memset</code> will overwrite part of the subclass.</p>\n", "LastEditorUserId": "75889", "LastActivityDate": "2011-08-19T09:31:34.443", "Score": "17", "CreationDate": "2011-08-18T20:06:09.757", "ParentId": "7113422", "CommentCount": "9", "OwnerUserId": "75889", "LastEditDate": "2011-08-19T09:31:34.443"}, "7115595": {"Id": "7115595", "PostTypeId": "2", "Body": "<p>The <code>clear</code> method of the base class will only set the values of the class members.  </p>\n<p>According to alignment rules, the compiler is allowed to insert padding so that the next data member will occur on the aligned boundary.  Thus there will be padding after the <code>type</code> data member.  The first data member of the descendant will occupy this slot and be free from the effects of <code>memset</code>, since the <code>sizeof</code> the base class does not include the size of the descendant.  Size of parent != size of child (unless child has no data members).  <strong>See slicing</strong>.</p>\n<p>Packing of structures is not a part of the language standard.  Hopefully, with a good compiler, the size of a packed structure does not include any extra bytes after the last.  Even so, a packed descendant inheriting from a packed parent should produce the same result:  parent sets only the data members in the parent.</p>\n", "LastActivityDate": "2011-08-19T00:05:08.917", "CommentCount": "0", "CreationDate": "2011-08-19T00:05:08.917", "ParentId": "7113422", "Score": "0", "OwnerUserId": "225074"}, "bq_ids": {"n4140": {"so_7113422_7114379_0": {"length": 13, "quality": 1.0, "section_id": 6981}}, "n3337": {"so_7113422_7114379_0": {"length": 13, "quality": 1.0, "section_id": 6727}}, "n4659": {"so_7113422_7114379_0": {"length": 13, "quality": 1.0, "section_id": 8479}}}, "31666469": {"Id": "31666469", "PostTypeId": "2", "Body": "<p><strong>Briefly</strong>: It seems to me that the only one potentional problem is in that I can not found any info about \"padding bytes\" guarantees in C89, C2003 standarts....Do they have some extraordinary volatile or readonly behavior - I can not find even what does term \"padding bytes\" mean by the standarts...</p>\n<p><strong>Detailed</strong>:</p>\n<p>For objects of POD types it is guaranteed by the C++2003 standard that:</p>\n<ul>\n<li>when you memcpy the contents of your object into an array of char or unsigned char, and then memcpy the contents back into your object, the object will hold its original value</li>\n<li><p>guaranteed that there will be no padding in the beginning of a POD object</p></li>\n<li><p>can break C++ rules about: goto statement, lifetime</p></li>\n</ul>\n<p>For C89 there is also exist some guarantees about structures:</p>\n<ul>\n<li><p>When used for a mixture of union structures if structs have same begining, then first compoments have perfect mathing</p></li>\n<li><p>sizeof structures in C is equal to the amount of memory to store all the components, the place under the padding between the components, place padding under the following structures</p></li>\n<li><p>In C components of the structure are given addresses. There is a guarantee that the components of the address are in ascending order. And the address of the first component coincides with the start address of the structure. Regardless of which endian the computer where the program runs</p></li>\n</ul>\n<p>So It seems to me that such rules is appropriate to C++ also, and all is fine. I really think that in hardware level nobody will restrict you from write in padding bytes for non-const object.</p>\n", "LastActivityDate": "2015-07-28T02:36:23.630", "CommentCount": "0", "CreationDate": "2015-07-28T02:36:23.630", "ParentId": "7113422", "Score": "0", "OwnerUserId": "1154447"}, "7114379": {"Id": "7114379", "PostTypeId": "2", "Body": "<p>In theory, the compiler can lay out base classes differently.  C++03 \u00a710 paragraph 5 says:</p>\n<blockquote>\n<p id=\"so_7113422_7114379_0\">A base class subobject might have a layout (3.7) different from the layout of a most derived object of the same type.</p>\n</blockquote>\n<p>As <a href=\"https://stackoverflow.com/questions/7113422/why-can-it-be-dangerous-to-use-this-pod-struct-as-a-base-class/7113474#7113474\">StackedCrooked mentioned</a>, this might happen by the compiler adding padding to the end of the base class <code>A</code> when it exists as its own object, but the compiler might not add that padding when it's a base class.  This would cause <code>A::clear()</code> to overwrite the first few bytes of the members of the subclass.</p>\n<p>However in practice, I have not been able to get this to happen with either GCC or Visual Studio 2008.  Using this test:</p>\n<pre><code>struct A\n{\n  void clear() { memset(this, 0, sizeof(A)); }\n\n  int age;\n  char type;\n};\n\nstruct B : public A\n{\n  char x;\n};\n\nint main(void)\n{\n  B b;\n  printf(\"%d %d %d\\n\", sizeof(A), sizeof(B), ((char*)&amp;b.x - (char*)&amp;b));\n  b.x = 3;\n  b.clear();\n  printf(\"%d\\n\", b.x);\n\n  return 0;\n}\n</code></pre>\n<p>And modifying <code>A</code>, <code>B</code>, or both to be 'packed' (with <a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.80%29.aspx\" rel=\"nofollow noreferrer\"><code>#pragma pack</code></a> in VS and <a href=\"http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Type-Attributes.html\" rel=\"nofollow noreferrer\"><code>__attribute__((packed))</code></a> in GCC), I couldn't get <code>b.x</code> to be overwritten in any case.  Optimizations were enabled.  The 3 values printed for the sizes/offsets were always 8/12/8, 8/9/8, or 5/6/5.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-18T21:29:08.833", "Score": "2", "CreationDate": "2011-08-18T21:29:08.833", "ParentId": "7113422", "CommentCount": "1", "OwnerUserId": "9530", "LastEditDate": "2017-05-23T12:15:00.127"}, "7113422": {"ViewCount": "1016", "Body": "<p>I had this conversation with a colleague, and it turned out to be interesting. Say we have the following POD class</p>\n<pre><code>struct A { \n  void clear() { memset(this, 0, sizeof(A)); } \n\n  int age; \n  char type; \n};\n</code></pre>\n<p><code>clear</code> is intended to clear all members, setting to <code>0</code> (byte wise). What could go wrong if we use <code>A</code> as a base class? There's a subtle source for bugs here. </p>\n", "AcceptedAnswerId": "7113474", "Title": "Why can it be dangerous to use this POD struct as a base class?", "CreationDate": "2011-08-18T20:02:49.197", "Id": "7113422", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-07-28T02:36:23.630", "Score": "23", "OwnerUserId": "34509", "Tags": "<c++><pod><memset>", "AnswerCount": "5"}});