post_cb({"26496567": {"ParentId": "26387054", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First I did some more test using your code and I can confirm that <code>L\"\u041f\u0440\u0435\u0441\u0442\u0443\u043f\u043b\u0435\u043d\u0438\u0435 \u0438 \u043d\u0430\u043a\u0430\u0437\u0430\u043d\u0438\u0435\"</code> is a correct UTF16 string. I controlled the code of the individual characters, and they are correctly <code>0x41f, 0x440, 0x435, 0x441, 0x442, 0x443, 0x43f, 0x43b, 0x435, 0x43d, 0x438, 0x435, 0x20, 0x438, 0x20, 0x43d, 0x430, 0x43a, 0x430, 0x437, 0x430, 0x43d, 0x438, 0x435</code></p>\n<p>I could not find any reference about it, but it looks like simply calling <code>imbue</code> is not enough. <code>imbue</code> it a method from <code>basic_ios</code> which is an ancestor of <code>cout</code> and <code>wcout</code>. It does act on numeric conversions, but on all my tests, it has no effect on the charset used for output.</p>\n<p>By default, the locale used in a C++ (or C) program is ... the <code>C</code> locale which knows nothing about unicode. All printable ASCII characters (below 128) are outputted as is, and others are replaced with a <code>?</code>. It is exactly what your program does.</p>\n<p>To make it work correctly, you have to select a locale that knows about unicode characters with <code>setlocale</code>. Once this is done, you can change the numeric conversion by calling <code>imbue</code>, and <em>as you selected a unicode charset</em> all will be fine.</p>\n<p>So provided your current locale uses an UTF-8 charset, you only have to add</p>\n<pre><code>setlocale(LC_ALL, \"\");\n</code></pre>\n<p>as first line in your program, and the output will be as expected :</p>\n<pre><code>0: \"\u041f\u0440\u0435\u0441\u0442\u0443\u043f\u043b\u0435\u043d\u0438\u0435\"\n1: \"\u0438\"\n2: \"\u043d\u0430\u043a\u0430\u0437\u0430\u043d\u0438\u0435\"\n\nI counted 3 words.\nand the last word was \"\u043d\u0430\u043a\u0430\u0437\u0430\u043d\u0438\u0435\"\n</code></pre>\n<p>If your current locale does not use UTF-8, choose one that is installed on you system and that supports it. I used <code>setlocale(LC_ALL, \"fr_FR.UTF-8\");</code>, or even <code>setlocale(LC_ALL, \"en_US.UTF-8\");</code> and both worked.</p>\n<p>Edit : </p>\n<p>In fact, the best way to correctly output unicode to screen is to use <code>setlocale(LC_ALL, \"\");</code>. It automatically adapts to the current charset. I tested with a stripped down variant using Latin1 charset (my system speaks natively french and not russian ...)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;locale&gt;\n\nusing namespace std;\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t ws[] = { 0xe8, 0xe9, 0 };\n\n    wcout &lt;&lt; ws &lt;&lt; endl;\n}\n</code></pre>\n<p>I tried it under Linux using UTF-8 charset and ISO-8859-1 (latin1) (resp <code>export LANG=fr_FR.UTF-8</code> and <code>export LANG=fr_FR.ISO-8859-1</code>) and I got correctly <code>\u00e8\u00e9</code> in the proper charset. I tried it also under Windows XP, with codepage 851 (oem) and 1252 (ansi) (resp. <code>chcp 850</code> and <code>chcp 1252</code> with Lucida console charset), and got <code>\u00e8\u00e9</code> on the console too.</p>\n<p>Edit 2 :</p>\n<p>Of course, you can also set a global C++ locale with <code>locale::global(locale(\"\");</code> with default locale or <code>locale::global(locale(\"ru_RU.UTF-8\");</code> with russian locale, but it is more than simply calling <code>setlocale</code>. According to the documentation of Gnu implementation of C++ Standard Library about <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html#std.localization.locales\">locale</a> : <em>there is only one relation (of the C++ locale mechanism) to the C locale mechanism: the global C locale is modified if a named C++ locale object is set as the global locale\", that is: <code>std::locale::global(std::locale(\"\"));</code> affects the C functions as if the following call was made: <code>std::setlocale(LC_ALL, \"\");</code>. On the other hand, there is no vice versa, that is, calling setlocale has no whatsoever on the C++ locale mechanism, in particular on the working of locale(\"\")</em>.</p>\n<p>So it really looks like there was an underlying C library mechanizme that should be first enabled with <code>setlocale</code> to allow <code>imbue</code> conversion to work correctly.</p>\n", "OwnerUserId": "3545273", "LastEditorUserId": "3545273", "LastEditDate": "2014-10-22T06:55:52.430", "Id": "26496567", "Score": "10", "CreationDate": "2014-10-21T21:21:09.663", "LastActivityDate": "2014-10-22T06:55:52.430"}, "26520333": {"ParentId": "26387054", "CommentCount": "0", "Body": "<p>In this answer, I'm taking the questions in reverse order, and adding another (with answer) that came up along the way.</p>\n<h2>Is there way to use <code>imbue</code> rather than setting the global locale to do what I want?</h2>\n<p><strong>Yes.</strong> By default, <code>std::wcout</code> is synchronized to the underlying <code>stdout</code> C stream.  So <code>std::wcout</code> <em>can</em> use <code>imbue</code> if that synchronization is turned off, allowing the C++ stream to operate independently.  So to modify the original code to use <code>imbue</code> and work as intended only a single line need be added, calling <a href=\"http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio\" rel=\"noreferrer\"><code>std::ios_base::sync_with_stdio</code></a>:</p>\n<pre><code>std::ios_base::sync_with_stdio(false);\nstd::wcout.imbue(ru);\n</code></pre>\n<h2>Why didn't the original version work?</h2>\n<p>The standard (I'm referring to INCITS/ISO/IEC 14882-2011[2012]) says very little about the tie to the underlying <code>stdio</code> stream, but in 27.4.3 it says  </p>\n<blockquote>\n<p id=\"so_26387054_26520333_0\">The object <code>wcout</code> controls output to a stream buffer associated with the object <code>stdout</code>, declared in <code>&lt;cstdio&gt;</code></p>\n</blockquote>\n<p>Further, without explicitly setting a global locale, the locale is the <code>\"C\"</code> locale which is US English ASCII, so this appears to imply that <code>stdout</code> will, by default, have an ASCII mapping.  Since no Cyrillic characters are represented in ASCII, the underlying <code>stdout</code> is what converts the proper Russian into a series of <code>?</code> characters.</p>\n<h2>Why must the <code>sync_with_stdio</code> call precede <code>imbue</code>?</h2>\n<p>According to 27.5.3.4 of the standard:</p>\n<blockquote>\n<p id=\"so_26387054_26520333_1\">If any input or output operation has occurred using the standard streams prior to the call,\n  the effect is implementation-defined. Otherwise, called with a false argument, it allows the standard streams to operate independently of the standard C streams.</p>\n</blockquote>\n", "OwnerUserId": "3191481", "PostTypeId": "2", "Id": "26520333", "Score": "6", "CreationDate": "2014-10-23T02:27:30.583", "LastActivityDate": "2014-10-23T02:27:30.583"}, "26496650": {"ParentId": "26387054", "CommentCount": "0", "Body": "<p>I don't know what languages you're planning on supporting, but there are languages where your algorithm doesn't apply, eg. Japanese. I suggest checking out the word iterators in International Components for Unicode. <a href=\"http://userguide.icu-project.org/boundaryanalysis\" rel=\"nofollow\">http://userguide.icu-project.org/boundaryanalysis</a></p>\n", "OwnerUserId": "395029", "PostTypeId": "2", "Id": "26496650", "Score": "1", "CreationDate": "2014-10-21T21:26:15.410", "LastActivityDate": "2014-10-21T21:26:15.410"}, "bq_ids": {"n4140": {"so_26387054_26520333_1": {"section_id": 1973, "quality": 0.9473684210526315, "length": 18}, "so_26387054_26520333_0": {"section_id": 1931, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_26387054_26520333_0": {"section_id": 1920, "quality": 0.9166666666666666, "length": 11}, "so_26387054_26520333_1": {"section_id": 1962, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_26387054_26520333_0": {"section_id": 2202, "quality": 0.9166666666666666, "length": 11}, "so_26387054_26520333_1": {"section_id": 2244, "quality": 0.9473684210526315, "length": 18}}}, "26387054": {"CommentCount": "12", "AcceptedAnswerId": "26520333", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-10-15T16:04:30.807", "LastActivityDate": "2014-10-23T02:27:30.583", "LastEditDate": "2017-05-23T10:30:49.210", "ViewCount": "5211", "FavoriteCount": "3", "Title": "How can I use std::imbue to set the locale for std::wcout?", "Id": "26387054", "Score": "16", "Body": "<p>I am trying to use the <code>std::locale</code> mechanism in C++11 to count words in different languages.  Specifically, I have <code>std::wstringstream</code> which contains the title of a famous Russian novel (\"Crime and Punishment\" in English).  What I want to do is to use the appropriate locale (<code>ru_RU.utf8</code> on my Linux machine) to read the stringstream, count the words and print the results. I should also probably note that my system is set to use the <code>en_US.utf8</code> locale.</p>\n<p>The desired result is this:</p>\n<pre><code>0: \"\u041f\u0440\u0435\u0441\u0442\u0443\u043f\u043b\u0435\u043d\u0438\u0435\"\n1: \"\u0438\"\n2: \"\u043d\u0430\u043a\u0430\u0437\u0430\u043d\u0438\u0435\"\n\nI counted 3 words.\nand the last word was \"\u043d\u0430\u043a\u0430\u0437\u0430\u043d\u0438\u0435\"\n</code></pre>\n<p>That all works when I set the global locale, but not when I attempt to <code>imbue</code> the <code>wcout</code> stream.  When I try that, I get this result instead:</p>\n<pre><code>0: \"????????????\"\n1: \"?\"\n2: \"?????????\"\n\nI counted 3 words.\nand the last word was \"?????????\"\n</code></pre>\n<p>Also, when I attempt to use a solution suggested in the comments, (which can be activate by changing <code>#define USE_CODECVT 0</code> to <code>#define USE_CODECVT 1</code>) I get the error mentioned in <a href=\"https://stackoverflow.com/questions/15615136/is-codecvt-not-a-std-header\">this other question</a>.  </p>\n<p>Those interested in experimenting with the code, or with compiler settings or both may wish to use <a href=\"http://coliru.stacked-crooked.com/a/6d7bc409f511b0ae\" rel=\"nofollow noreferrer\">this live code</a>.</p>\n<h2>My questions</h2>\n<ol>\n<li>Why does that not work?  Is it because <code>wcout</code> is already open?</li>\n<li>Is there way to use <code>imbue</code> rather than setting the global locale to do what I want?</li>\n</ol>\n<p>If it makes a difference, I'm using g++ 4.8.3. The full code is shown below.</p>\n<h2>getwords.cpp</h2>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;locale&gt;\n\n#define USE_CODECVT 0\n#define USE_IMBUE   1\n\n#if USE_CODECVT\n#include &lt;codecvt&gt;\n#endif \nusing namespace std;\n\nint main()\n{\n#if USE_CODECVT\n    locale ru(\"ru_RU.utf8\", \n        new codecvt_utf8&lt;wchar_t, 0x10ffff, consume_header&gt;{});\n#else\n    locale ru(\"ru_RU.utf8\");\n#endif\n#if USE_IMBUE\n    wcout.imbue(ru);\n#else\n    locale::global(ru);\n#endif\n    wstringstream in{L\"\u041f\u0440\u0435\u0441\u0442\u0443\u043f\u043b\u0435\u043d\u0438\u0435 \u0438 \u043d\u0430\u043a\u0430\u0437\u0430\u043d\u0438\u0435\"};\n    in.imbue(ru);\n    wstring word;\n    unsigned wordcount = 0;\n    while (in &gt;&gt; word) {\n        wcout &lt;&lt; wordcount &lt;&lt; \": \\\"\" &lt;&lt; word &lt;&lt; \"\\\"\\n\";\n        ++wordcount;\n    }\n    wcout &lt;&lt; \"\\nI counted \" &lt;&lt; wordcount &lt;&lt; \" words.\\n\"\n        &lt;&lt; \"and the last word was \\\"\" &lt;&lt; word &lt;&lt; \"\\\"\\n\";\n}\n</code></pre>\n", "Tags": "<c++><c++11><locale>", "OwnerUserId": "3191481", "AnswerCount": "3"}});