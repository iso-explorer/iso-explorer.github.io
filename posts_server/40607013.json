post_cb({"40609620": {"ParentId": "40607013", "CommentCount": "3", "Body": "<p>For me it is a logical error to say a enum can be based on an another enum. If you think that the base is the storage type where the values defined in the enum are stored in, I can not get it as a logic expression to say the storage type is an enum. Because the enum is not only the storage type, it also contains a set of valid values.</p>\n<p>If we can write something like:</p>\n<pre><code>enum A: int { ONE, TWO };\n</code></pre>\n<p>what should mean:</p>\n<pre><code>enum B: A{};\n</code></pre>\n<p>Because A defines not only the underlaying type ( I call this the storage type ) but also a set of valid values, should B only a subset of the enum A which means that you can define only values already defined in A?</p>\n<p>Is it now valid to say we habe the values ONE,TWO already defined also in B?\nAnd is it now possible to add more values like:</p>\n<pre><code>    enum B: A{THREE};\n</code></pre>\n<p>and all valid values are now ONE,TWO,THREE ?</p>\n<p>or is the meaning we get only the subset:</p>\n<pre><code>    enum B: A{ONE};\n</code></pre>\n<p>which means B can only use values already defined in A. Simply that makes it difficult to me to make a enum a base of another enum.</p>\n<p>If you open that door, you also can also come to the idea that you want to use the underlaying storage type from other kinds of types like bitfields.</p>\n<pre><code>struct A { unsigned int a : 3; unsigned int B: 2; };\n</code></pre>\n<p>should then</p>\n<pre><code>enum B: A { ONE, TWO };\n</code></pre>\n<p>also be valid? I believe not! ;)</p>\n<p>From the logical point ( my point of view ) the underlaying type of the enum is its storage type. And it makes no sense to make an enum as an underlaying storage type for another enum at all.</p>\n", "OwnerUserId": "878532", "PostTypeId": "2", "Id": "40609620", "Score": "3", "CreationDate": "2016-11-15T12:15:52.760", "LastActivityDate": "2016-11-15T12:15:52.760"}, "40614120": {"ParentId": "40607013", "CommentCount": "1", "Body": "<p>When you add things to C++, you tend to add the minimium amount that solves a problem.</p>\n<p>The <code>enum A:int</code> syntax lets you specify exactly how the <code>enum A</code> is stored as an integer.  That is all it does, and it solves the problem.</p>\n<p><code>enum A:B</code> where <code>B</code> is an enum could have many meanings.  <code>A</code> could extend <code>B</code>, or <code>A</code> could be a subset of the <code>B</code> underlying type with different names, or <code>A</code> could be an enum strictly restricted to have a subset of the values that can be stored within <code>B</code>, or <code>A</code> could be an enum whose values are restricted to the \"hull\" of <code>B</code> values.</p>\n<p>Of these, the \"same underlying type\" solution (with the <code>:int</code> syntax) lines up with <code>enum A:std::underlying_type_t&lt;B&gt;</code>.  So there is already a way to do that, and it isn't particularly burdensome.</p>\n<p>Until someone makes a suggestion for what <code>enum A:B</code> should mean and convinces enough of the committee, it is unlikely to be permitted.  And when there are multiple different reasonable meanings, this makes it harder for any one meaning to be chosen.  One would need a strong use case why one particular meaning was best, and why it is worth the effort to put it in the standard.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "40614120", "Score": "2", "CreationDate": "2016-11-15T15:48:33.190", "LastActivityDate": "2016-11-15T15:48:33.190"}, "40607077": {"ParentId": "40607013", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Well, not exactly the same, but I think you could use <a href=\"http://en.cppreference.com/w/cpp/types/underlying_type\" rel=\"nofollow noreferrer\"><code>std::underlying_type</code></a>:</p>\n<pre><code>enum foo : unsigned { first_foo, second_foo };\nenum bar : std::underlying_type_t&lt;foo&gt; { best_foo = first_foo };\n</code></pre>\n", "OwnerUserId": "752976", "LastEditorUserId": "752976", "LastEditDate": "2016-11-15T10:11:42.143", "Id": "40607077", "Score": "3", "CreationDate": "2016-11-15T10:08:31.470", "LastActivityDate": "2016-11-15T10:11:42.143"}, "40607013": {"CommentCount": "7", "ViewCount": "263", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2016-11-15T10:05:49.673", "LastActivityDate": "2016-11-15T15:48:33.190", "Title": "Why can't I have an enum as the underlying type of another enum?", "AcceptedAnswerId": "40614120", "LastEditDate": "2016-11-15T10:12:57.640", "Id": "40607013", "Score": "2", "Body": "<p>Why isn't this valid C++?:</p>\n<pre><code>enum foo : unsigned { first_foo, second_foo };\nenum bar : foo { best_foo = first_foo };\n</code></pre>\n<p>GCC 5.4.0 says:</p>\n<pre><code>/tmp/a.cpp:3:16: error: underlying type \u2018foo\u2019 of \u2018bar\u2019 must be an integral type\n     enum bar : foo { best_foo = first_foo };\n</code></pre>\n<p>I can understand why I would get this error if <code>foo</code> were a <code>float</code>, or some struct, or what-not. But this seems perfectly legit to me in terms of semantics, type safety etc. What am I missing?</p>\n", "Tags": "<c++><c++11><enums><subclassing>", "OwnerUserId": "1593077", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_40607013_40607125_1": {"section_id": 7216, "quality": 1.0, "length": 14}, "so_40607013_40607125_2": {"section_id": 7216, "quality": 0.8181818181818182, "length": 9}, "so_40607013_40607125_0": {"section_id": 5461, "quality": 0.875, "length": 7}}, "n3337": {"so_40607013_40607125_1": {"section_id": 6960, "quality": 1.0, "length": 14}, "so_40607013_40607125_2": {"section_id": 6960, "quality": 0.8181818181818182, "length": 9}, "so_40607013_40607125_0": {"section_id": 5248, "quality": 0.875, "length": 7}}, "n4659": {"so_40607013_40607125_1": {"section_id": 8725, "quality": 1.0, "length": 14}, "so_40607013_40607125_2": {"section_id": 8725, "quality": 0.8181818181818182, "length": 9}, "so_40607013_40607125_0": {"section_id": 6895, "quality": 0.875, "length": 7}}}, "40607125": {"ParentId": "40607013", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>C++11 [dcl.enum]/2:</p>\n<blockquote>\n<p id=\"so_40607013_40607125_0\">The <em>type-specifier-seq</em> of an <em>enum-base</em> shall name an integral type; any cv-qualification is ignored.</p>\n</blockquote>\n<p>Enums are not themselves integral types \u2013 [basic.fundamental]/7:</p>\n<blockquote>\n<p id=\"so_40607013_40607125_1\">Types <code>bool</code>, <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and the signed and unsigned integer types are collectively called <em>integral</em> types.</p>\n</blockquote>\n<p>This is accompanied by a non-normative footnote:</p>\n<blockquote>\n<p id=\"so_40607013_40607125_2\">Therefore, enumerations are not integral; however, enumerations can be promoted to integral types as specified in [conv.prom].</p>\n</blockquote>\n<p>To achieve the effect I think you're looking for, however, is still simple:</p>\n<pre><code>enum bar : std::underlying_type&lt;foo&gt;::type { best_foo = first_foo };\n</code></pre>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2016-11-15T10:15:50.587", "Id": "40607125", "Score": "7", "CreationDate": "2016-11-15T10:10:46.737", "LastActivityDate": "2016-11-15T10:15:50.587"}});