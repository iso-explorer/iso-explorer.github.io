post_cb({"13661081": {"ParentId": "13660958", "CommentCount": "1", "CreationDate": "2012-12-01T16:00:47.953", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "13661081", "Score": "1", "Body": "<p>Inside templates, expressions can be <em>type-dependent</em> or <em>value-dependent</em>. From 14.6.2:</p>\n<blockquote>\n<p id=\"so_13660958_13661081_0\">types and expressions may depend on the type and/or value of template parameters</p>\n</blockquote>\n<p>In your case, <code>counter</code> is a template argument, and the declaration of <code>v</code> depends on it, making <code>v[0]</code> a <em>value-dependent</em> expression. Thus the name <code>foo</code> is a dependent-name which you must disambiguate as a template name by saying:</p>\n<pre><code>v[0].template foo&lt;1&gt;();\n</code></pre>\n", "LastActivityDate": "2012-12-01T16:00:47.953"}, "13661049": {"ParentId": "13660958", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-12-01T15:55:41.037", "Score": "1", "LastEditorUserId": "415784", "LastEditDate": "2012-12-01T16:21:35.897", "Id": "13661049", "OwnerUserId": "415784", "Body": "<p>You have to use <code>template</code> as:</p>\n<pre><code>v[0].template foo&lt;1&gt;();  \n\nauto &amp;o = v[0];\no.template foo&lt;1&gt;();     \n</code></pre>\n<p>Because the declaration of <code>v</code> depends on the template argument, which makes <code>v</code> a dependent name.</p>\n<p>Here the <code>template</code> keyword tells compiler that whatever follows is a <em>template</em> (in your case, <code>foo</code> is indeed a template). If <code>foo</code> is not a template, then the <code>template</code> keyword is not required (in fact, it would be an error).</p>\n<p>The problem is that <code>o.foo&lt;1&gt;()</code> can be parsed/interpreted in two ways: one is just as you expect (a function call), the other way is this:</p>\n<pre><code>(o.foo) &lt; 1  //partially parsed\n</code></pre>\n<p>that is,  <code>foo</code> is a member data (not function), and you've comparing it with <code>1</code>. So to tell the compiler that <code>&lt;</code> is not used to compare <code>o.foo</code> with <code>1</code>, rather it is used to pass template argument <code>1</code> to the function template, you're required to use <code>template</code> keyword.</p>\n", "LastActivityDate": "2012-12-01T16:21:35.897"}, "13660958": {"CommentCount": "19", "ViewCount": "113", "CreationDate": "2012-12-01T15:41:57.933", "LastActivityDate": "2012-12-01T16:21:35.897", "Title": "Strange compilation behaviour when calling a template method from another template object", "AcceptedAnswerId": "13661049", "PostTypeId": "1", "Id": "13660958", "Score": "4", "Body": "<p>Could someone explain why the following c++ code is not behaving as expected:</p>\n<pre><code>struct Object {   \n  template&lt; int i &gt;\n  void foo(){ } \n};\n\ntemplate&lt;int counter&gt;\nstruct Container {\n  Object v[counter];\n\n  void test(){\n    // this works as expected\n    Object a; a.foo&lt;1&gt;();\n\n    // This works as well:\n    Object *b = new Object(); b-&gt;foo&lt;1&gt;();\n\n    // now try the same thing with the array:  \n    v[0] = Object(); // that's fine (just testing access to the array)\n\n# if defined BUG1\n    v[0].foo&lt;1&gt;();   // compilation fails \n# elif defined BUG2\n    (v[0]).foo&lt;1&gt;(); // compilation fails\n# elif defined BUG3\n    auto &amp;o = v[0];\n    o.foo&lt;1&gt;();      // compilation fails\n# else\n    Object &amp;o = v[0];\n    o.foo&lt;1&gt;();      // works\n# endif\n  }\n};\n\nint main(){\n  Container&lt;10&gt; container;\n}\n</code></pre>\n<p>The code above compiles fine without flag. If one of the flag BUG1 to BUG3 is set, the compilation fails with either GCC 4.6 or 4.7 and with clang 3.2 (which seems to indicate it is not a GCC bug).</p>\n<p>Lines 21 to 29 are doing exactly the same thing semantically (ie calling a method of the first element of the Object array), but only the last version compiles. The problem only seems to arise when I try to call a templated method from a template object.</p>\n<p>BUG1 is just the \"normal\" way of writing the call.</p>\n<p>BUG2 is the same thing, but the array access is protected by parenthesis in case there was a precedence problem (but there shouldn't be any).</p>\n<p>BUG3 shows that type inference is not working either (needs to be compiled with c++11 support).</p>\n<p>The last version works fine, but I don't understand why using a temporary variable to store the reference solves the problem.</p>\n<p>I am curious to know why the other three are not valid.</p>\n<p>Thanks</p>\n", "Tags": "<c++><templates><compilation><compiler-errors>", "OwnerUserId": "401200", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13660958_13661081_0": {"section_id": 188, "quality": 1.0, "length": 9}}, "n3337": {"so_13660958_13661081_0": {"section_id": 182, "quality": 1.0, "length": 9}}, "n4659": {"so_13660958_13661081_0": {"section_id": 193, "quality": 1.0, "length": 9}}}});