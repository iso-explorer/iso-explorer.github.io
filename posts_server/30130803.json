post_cb({"bq_ids": {"n4140": {"so_30130803_30131242_1": {"length": 18, "quality": 1.0, "section_id": 641}, "so_30130803_30131242_2": {"length": 41, "quality": 0.9318181818181818, "section_id": 641}, "so_30130803_30131242_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 641}}, "n3337": {"so_30130803_30131242_1": {"length": 18, "quality": 1.0, "section_id": 631}, "so_30130803_30131242_2": {"length": 41, "quality": 0.9318181818181818, "section_id": 631}, "so_30130803_30131242_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 631}}, "n4659": {"so_30130803_30131242_1": {"length": 18, "quality": 1.0, "section_id": 669}, "so_30130803_30131242_2": {"length": 37, "quality": 0.8409090909090909, "section_id": 669}, "so_30130803_30131242_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 669}}}, "30131179": {"Id": "30131179", "PostTypeId": "2", "Body": "<p>First, <code>std::bind</code> is (almost) entirely outmoded by C++11 lambdas. Don't use std::bind if you can help it. One of these is much clearer than the others, using your example code:</p>\n<pre><code>const auto lambda  = [=] { foo-&gt;print(); }; // Clear!\nconst auto binderv = std::bind( static_cast&lt;void(Foo::*)()&gt;( &amp;Foo::print ), foo ); // Gets the void version\nconst auto binderi = std::bind( static_cast&lt;void(Foo::*)(int)&gt;( &amp;Foo::print ), foo, std::placeholders::_1 ); // Gets the int version\n\n//const auto binderv2 = std::bind( &amp;Foo::print, foo ); // Error! Can't tell which Foo::print()\n//const auto binderi2 = std::bind( &amp;Foo::print, foo, std::placeholders::_1 ); // Error! Can't tell which Foo::print()\n\nlambda();   // prints \"void\"\nbinderv();  // prints \"void\"\nbinderi(1); // prints \"int\"\n</code></pre>\n<p>Second, how does the compiler know which overloaded function to call? The same way it would if you were using non-member functions:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid call( void (*fn)() )\n{\n    fn();\n}\n\nvoid print()    { std::cout &lt;&lt; \"void\\n\"; }\nvoid print(int) { std::cout &lt;&lt; \"int\\n\";  }\n\nint main()\n{\n    call( &amp;print ); // prints \"void\"\n}\n</code></pre>\n<p>Only one of those overloaded functions fits the called function's prototype, so the compiler knows. In the case of <code>std::bind</code> above, it can't quite tell, but you can force it with a cast, as I did.</p>\n<p>Lambdas or <code>std::function</code> can wrap either of the member functions, but note that you can't overload a function on different <code>std::function</code> signatures. See <a href=\"https://stackoverflow.com/a/4732106/201787\">here</a>.</p>\n<hr>\n<p><em>Update</em>: </p>\n<p>The right way to handle your question #3 -- to have one function call functions with drastically different signatures like yours -- is to use some intermediary like a functor (lambda, <code>std::function</code>, <code>std::bind</code>, hand-rolled functor) to erase the differences.</p>\n<p><code>std::function&lt;void()&gt;</code> objects that have the same signature, regardless of what the real functions you're calling have as their signature. <code>std::function</code> is more expensive (in terms of storing and calling) than a lambda but it has the advantage of having a typename that you can use if you need to store it in a container or something. Lambdas can sometimes be inlined away by the compiler if you play your cards right, so efficiency may still favor lambdas.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-08T19:48:46.340", "Score": "0", "CreationDate": "2015-05-08T19:09:41.327", "ParentId": "30130803", "CommentCount": "3", "OwnerUserId": "201787", "LastEditDate": "2017-05-23T12:22:55.200"}, "30131242": {"Id": "30131242", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30130803_30131242_0\">Since there are two functions (overloaded) with the same name: <code>print</code>, when I pass the address of class function: <code>&amp;Foo::print</code>, how did the compiler knows that I am actually calling <code>Foo::print(void)</code> but not <code>Foo::print(int)</code>?</p>\n</blockquote>\n<p>This is allowed because of   [over.over]/p1:</p>\n<blockquote>\n<p id=\"so_30130803_30131242_1\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a\n  pointer to function or a pointer to member function for a specific function from the overload set.</p>\n</blockquote>\n<p>The compiler can use the target type of the parameter-type-list to determine which function from the overload set the pointer-to-member refers:</p>\n<blockquote>\n<p id=\"so_30130803_30131242_2\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a\n  pointer to function or a pointer to member function for a specific function from the overload set. A function\n  template name is considered to name a set of overloaded functions in such contexts. The function selected\n  is the one whose type is identical to the function type of the target type required in the context. [ Note: .. ] The target can be</p>\n<p id=\"so_30130803_30131242_3\">\u00a0\u00a0\u00a0\u00a0 \u2014 an object or reference being initialized (8.5, 8.5.3, 8.5.4),<br>\n  \u00a0\u00a0\u00a0\u00a0 \u2014 the left side of an assignment (5.18),<br>\n  \u00a0\u00a0\u00a0\u00a0 <strong>\u2014 a parameter of a function (5.2.2),</strong><br>\n  \u00a0\u00a0\u00a0\u00a0  \u2014 [..]</br></br></br></p>\n</blockquote>\n<p>The name <code>Foo:print</code> represents an overload set which the compiler looks through to find a match. The target type <code>Foo::print(void)</code> is present in the overload set, so the compiler resolves the name to that overload.</p>\n<blockquote>\n<p id=\"so_30130803_30131242_4\">Is there another way that I can generalize the code above such that the second parameter of <code>void call(Foo*, xxx)</code> can be passed using both <code>Foo::print(void)</code> and <code>Foo::print(int)</code></p>\n</blockquote>\n<p>There isn't a general way to do it with the name itself. The name has to be resolved to an overload. Instead, try changing the code to accept a function object like a lambda:</p>\n<pre><code>template&lt;class Callable&gt;\nvoid call(Foo* foo, Callable&amp;&amp; callback) {\n    callback(foo);\n}\n\nint main()\n{\n    call(foo, [] (Foo* f) { f-&gt;print(); f-&gt;print(1); });\n}\n</code></pre>\n", "LastEditorUserId": "701092", "LastActivityDate": "2015-05-08T19:20:37.477", "Score": "1", "CreationDate": "2015-05-08T19:13:35.063", "ParentId": "30130803", "CommentCount": "1", "OwnerUserId": "701092", "LastEditDate": "2015-05-08T19:20:37.477"}, "30130803": {"ViewCount": "855", "Body": "<p>My question is about using std::function to class methods. Suppose I have the following class hierarchy:</p>\n<pre><code>class Foo {\npublic:\n    virtual void print() {\n        cout &lt;&lt; \"In Foo::print()\" &lt;&lt; endl;\n    }\n\n    virtual void print(int) {\n        cout &lt;&lt; \"In Foo::print(int)\" &lt;&lt; endl;\n    }\n};\n\nclass Bar : public Foo {\npublic:\n    virtual void print() override {\n        cout &lt;&lt; \"In Bar::print()\" &lt;&lt; endl;\n    }\n\n    virtual void print(int) override {\n        cout &lt;&lt; \"In Bar::print(int)\" &lt;&lt; endl;\n    }\n}\n</code></pre>\n<p>Now there is another function which is supposed to dynamically call one of the two class methods depends on its input:</p>\n<pre><code>void call(Foo* foo, void (Foo::*func)(void)) {\n    (foo-&gt;*func)();\n}\n\nFoo* foo = new Foo();\nBar* bar = new Bar();\ncall(foo, &amp;Foo::print);\ncall(bar, &amp;Foo::print);\n</code></pre>\n<p>When I compile the above code snippet using g++/clang++, it works as expected, where the output is:</p>\n<pre><code>In Foo::print()\nIn Bar::print()\n</code></pre>\n<p>My questions are then:</p>\n<ol>\n<li><p>since there are two functions (overloaded) with the same name: print, when I pass the address of class function: <code>&amp;Foo::print</code>, how did the compiler know that I am actually calling <code>Foo::print(void)</code> but not <code>Foo::print(int)</code>?</p></li>\n<li><p>is there another way that I can generalize the code above such that the second parameter of <code>void call(Foo*, xxx)</code> can be passed using both <code>Foo::print(void)</code> and <code>Foo::print(int)</code></p></li>\n<li><p>is there anyway to achieve this feature using new feature in C++11 <code>std::function</code> ? I understand that in order to use <code>std::function</code> with a non-static class method, I have to use <code>std::bind</code> to bind each class method with a specific class object, but that would be too inefficient for me because I have many class objects to be bound.</p></li>\n</ol>\n", "AcceptedAnswerId": "30131242", "Title": "Using std::function for memberfunctions", "CreationDate": "2015-05-08T18:45:58.467", "Id": "30130803", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-10-13T15:59:34.880", "LastEditorUserId": "3204551", "LastActivityDate": "2015-10-13T15:59:34.880", "Score": "1", "OwnerUserId": "2100747", "Tags": "<c++><c++11><c++-standard-library><std-function><member-functions>", "AnswerCount": "2"}});