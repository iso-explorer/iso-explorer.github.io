post_cb({"bq_ids": {"n4140": {"so_2613562_2613578_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 3301}}, "n3337": {"so_2613562_2613578_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 3171}}, "n4659": {"so_2613562_2613578_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 4067}}}, "2613578": {"Id": "2613578", "PostTypeId": "2", "Body": "<p>This goes from <code>8.5/16</code> first bullet to <code>8.5.4</code> list-initialization and from <code>8.5.4/3</code> third bullet to <code>8.5.1</code> aggregate initialization and then <code>8.5.1/4</code> says</p>\n<blockquote>\n<p id=\"so_2613562_2613578_0\">An array of unknown size initialized with a brace-enclosed initializer-list containing n initializer-clauses, where shall be greater than zero, is de\ufb01ned as having elements </p>\n</blockquote>\n<p>The only difference if the object is an array between <code>= { ... }</code> and <code>{ ... }</code> is that the first is called <em>copy-list-initialization</em> and the second is called <em>direct-list-initialization</em>, so both are kinds of list-initialization. The elements of the array are copy-initialized from the elements of the initializer list in both cases. </p>\n<p><strike>Notice that there is a subtle difference between those forms if the array has a size and the list is empty, in which case <code>8.5.4</code> second bullet applies:</strike></p>\n<pre><code>struct A {\n  explicit A();\n};\n\nA a[1]{};    // OK: explicit constructor can be used by direct initialization\nA a[1] = {}; // ill-formed: copy initialization cannot use explicit constructor\n</code></pre>\n<p>This difference does not apply to lists that have content in which case third bullet applies again, though</p>\n<pre><code>struct A {\n  explicit A(int);\n};\n\nA a[1]{0};    // ill-formed: elements are copy initialized by 8.5.1\nA a[1] = {0}; // ill-formed: same.\n</code></pre>\n<p></p>\n<p>The FCD changed this compared to the previous draft, and initialization with an empty initializer list now always works even with explicit default constructors. This is because the FCD states that the elements are value-initialized, and value initialization doesn't care about explicitness since it doesn't do overload resolution on default constructors (it couldn't figure out better or worse matches anyway). The previous draft used normal overload resolution on the constructors and thus rejected explicit default constructors during copy initialization. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#990\" rel=\"nofollow noreferrer\">This defect report</a> did that change. </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-04-10T14:09:20.237", "Score": "4", "CreationDate": "2010-04-10T13:41:07.193", "ParentId": "2613562", "CommentCount": "10", "LastEditDate": "2010-04-10T14:09:20.237", "OwnerUserId": "34509"}, "2613570": {"Id": "2613570", "PostTypeId": "2", "Body": "<p>Yes, it is valid, and has been for decades, even in C. The size is simply set to the number of elements supplied. I don't know the reference, unfortunately.</p>\n<p>(Added bonus...) If you need the number of elements use <code>sizeof(x)/sizeof(*x)</code>. It's safer than hard-coding a constant that may become invalid if you add or remove entries.</p>\n<p>EDIT: As pointed out in the comments, the code in question is missing an <code>=</code> (a fact that I missed), without which it isn't valid in any current standard of C or C++.</p>\n", "LastEditorUserId": "9990", "LastActivityDate": "2010-04-11T00:05:59.607", "Score": "0", "CreationDate": "2010-04-10T13:39:37.233", "ParentId": "2613562", "CommentCount": "1", "LastEditDate": "2010-04-11T00:05:59.607", "OwnerUserId": "9990"}, "2613562": {"ViewCount": "703", "Body": "<p>Is this list-initialization of an array of unknown size valid in C++0x?  </p>\n<pre><code>int main() { int x[]{0, 1,2,3,4}; return x[0]; }\n</code></pre>\n<p>I believe it is valid, but would appreciate some confirmation. </p>\n<p>If anyone could quote from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">C++0x-FCD</a> to support their case, it would be greatly appreciated. </p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "2613578", "Title": "Is this list-initialization of an array of unknown size valid in C++0x?", "CreationDate": "2010-04-10T13:34:18.370", "Id": "2613562", "CommentCount": "0", "LastEditDate": "2011-10-02T10:37:05.773", "PostTypeId": "1", "LastEditorUserId": "34509", "LastActivityDate": "2011-10-02T10:37:05.773", "Score": "3", "OwnerUserId": "51103", "Tags": "<c++><arrays><initialization><c++11>", "AnswerCount": "2"}});