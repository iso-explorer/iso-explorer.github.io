post_cb({"22816963": {"ParentId": "22812183", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#667\">CWG issue 667</a> addressed this exact issue with a change that was incorporated into the C++ working draft near <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3225.pdf\">N3225</a>. N3225 \u00a7 12.1 [class.ctor]/5 states:</p>\n<blockquote>\n<p id=\"so_22812183_22816963_0\">A default constructor is trivial if it is neither user-provided nor deleted and if:</p>\n<ul>\n<li>its class has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>no non-static data member of its class has a <em>brace-or-equal-initializer</em>, and</li>\n<li>all the direct base classes of its class have trivial default constructors, and</li>\n<li>for all the non-static data members of its class that are of class type (or array thereof), each such class has a trivial default constructor.</li>\n</ul>\n<p id=\"so_22812183_22816963_1\">Otherwise, the default constructor is <em>non-trivial</em>.</p>\n</blockquote>\n<p>This was (obviously) changed before C++11 release. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1135\">CWG DR 1135</a> was created to address <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3296.html#FI1\">a Finland national body comment on the C++11 candidate draft</a>:</p>\n<blockquote>\n<p id=\"so_22812183_22816963_2\">It should be allowed to explicitly default a non-public special member function on its first declaration. It is very likely that users will want to default protected/private constructors and copy constructors without having to write such defaulting outside the class.</p>\n</blockquote>\n<p>The resolution of this issue removed the \"nor deleted\" text from 12.1 as well as the sections describing trivial destructors, trivial copy/move constructors, and trivial copy/move assignment operators. I think this change cut too broad a swath, and it was likely not intentional to make your <code>struct A</code> trivial. Indeed, on face value it's ridiculous that this program is ill-formed:</p>\n<pre><code>int x = 42;\nint y = 13;\nA a_x{x};\nA a_y{y};\na_x = a_y;\n</code></pre>\n<p>but this program is not, since <code>A</code> is trivially copyable (<a href=\"http://coliru.stacked-crooked.com/a/f6a7a279120b2bd0\">Clang agrees</a>, <a href=\"http://coliru.stacked-crooked.com/a/8d861db014de948c\">GCC does not</a>):</p>\n<pre><code>int x = 42;\nint y = 13;\nA a_x{x};\nA a_y{y};\nstd::memcpy(&amp;a_x, &amp;a_y, sizeof(a_x));\n</code></pre>\n<p>The existence of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1496\">CWG issue 1496 \"Triviality with deleted and missing default constructors\"</a> seems to indicate that the committee is aware of the problem (or at least a closely related problem):</p>\n<blockquote>\n<p id=\"so_22812183_22816963_3\">A default constructor that is defined as deleted is trivial, according to 12.1 [class.ctor] paragraph 5. This means that, according to 9 [class] paragraph 6, such a class can be trivial. If, however, the class has no default constructor because it has a user-declared constructor, the class is not trivial. Since both cases prevent default construction of the class, it is not clear why there is a difference in triviality between the cases.</p>\n</blockquote>\n<p>although there is no resolution as yet.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-04-02T16:10:39.547", "Id": "22816963", "Score": "7", "CreationDate": "2014-04-02T15:59:41.063", "LastActivityDate": "2014-04-02T16:10:39.547"}, "22812183": {"CommentCount": "13", "AcceptedAnswerId": "22816963", "PostTypeId": "1", "LastEditorUserId": "3237645", "CreationDate": "2014-04-02T12:54:27.310", "LastActivityDate": "2014-04-03T03:32:19.780", "LastEditDate": "2014-04-03T03:32:19.780", "ViewCount": "516", "FavoriteCount": "6", "Title": "A deleted default constructor could still be trivial?", "Id": "22812183", "Score": "18", "Body": "<p>Looking at the definition of trivial default constructor in the standards:</p>\n<blockquote>\n<p id=\"so_22812183_22812183_0\">A default constructor is trivial if it is not user-provided and if:</p>\n<ul>\n<li>its class has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>no non-static data member of its class has a brace-or-equal-initializer, and</li>\n<li>all the direct base classes of its class have trivial default constructors, and</li>\n<li>for all the non-static data members of its class that are of class type (or array thereof), each such class has a trivial default\n  constructor.</li>\n</ul>\n<p id=\"so_22812183_22812183_1\">Otherwise, the default constructor is non-trivial.</p>\n</blockquote>\n<p>It seems that the definition of a default constructor's triviality doesn't rule out the possibility of a <code>deleted</code> default constructor:</p>\n<pre><code>struct A {\n    int&amp; a;  // the implicitly defaulted default constructor will be defined as deleted\n};\n\nstruct B {\n    B()=delete;  // explicitly deleted\n};\n\nint main() {\n    static_assert(is_trivial&lt;A&gt;::value, \"\");\n    static_assert(is_trivial&lt;B&gt;::value, \"\");\n}\n</code></pre>\n<p>The above code runs without any assertion failure.  The type has trivial default constructor and is trivially copyable, so it's a <code>\"trivial class\"</code>.</p>\n<p>Wouldn't making this kind of type as <code>\"trivial class\"</code> bring trouble?  E.g., for things like object lifetime, byte-wise copy equivalence, <code>goto</code> statement allowance etc.</p>\n<p><strong>EDIT: The following example of goto allowance is not valid.  Thank you for @Casey's comment.  Another example of byte-wise copy equivalence is added to replace this one.</strong></p>\n<p><s>Take <code>goto</code> statement allowance as an example, the standards says:</s></p>\n<blockquote>\n<p id=\"so_22812183_22812183_2\">It is possible to transfer into a block, but not in a way that\n  bypasses declarations with initialization. A program that jumps87 from\n  a point where a variable with automatic storage duration is not in\n  scope to a point where it is in scope is ill-formed unless the\n  variable has scalar type, class type with a trivial default\n  constructor and a trivial destructor, a cv-qualified version of one of\n  these types, or an array of one of the preceding types and is declared\n  without an initializer (8.5).</p>\n</blockquote>\n<p>So for the following code:</p>\n<pre><code>class A {\n    int&amp; a;\npublic:\n    A(int&amp; aa): a{aa} {}\n    A()=default;  // this is necessary otherwise no default constructor will be implicitly declared then the type will not be trivial\n};\n\nint i;\n\nint main() {\n    static_assert(is_trivial&lt;A&gt;::value, \"\");\n    goto L;\n    A a{i};\nL:\n    return 0;\n}\n</code></pre>\n<p>It is well-formed according to the rules because <code>A</code> has a trivial default constructor and a trivial destructor (the assertion passes OK).  On the opposite, the code is ill-formed in C++03 (with C++11-only syntax removed, i.e. the line of <code>A()=default;</code>), because <code>A</code> is not a <code>POD</code> in C++03, and C++03 allows <code>goto</code> to cross definition of <code>POD</code> type only.</p>\n<p>Take byte-wise copy equivalence as an example, the standard says:</p>\n<blockquote>\n<p id=\"so_22812183_22812183_3\">For any trivially copyable type T, if two pointers to T point to\n  distinct T objects obj1 and obj2, where neither obj1 nor obj2 is a\n  base-class subobject, if the underlying bytes (1.7) making up obj1 are\n  copied into obj2,41 obj2 shall subsequently hold the same value as\n  obj1.</p>\n</blockquote>\n<p>So <code>memcpy()</code> on trivially copyable type is well-defined:</p>\n<pre><code>class A {\n    int&amp; a;\npublic:\n    A(int&amp; aa): a{aa} {}\n    A()=default;  // this is necessary otherwise no default constructor will be implicitly declared then the type will not be trivial\n    void* addr() {return &amp;a;}\n};\n\nint i = 0;\nint j = 0;\n\nint main() {\n    static_assert(is_trivial&lt;A&gt;::value, \"\");\n    A a{i};\n    A b{j};\n    cout &lt;&lt; a.addr() &lt;&lt; \" \" &lt;&lt; b.addr() &lt;&lt; \"\\n\";\n    // a = b;  // this will be ill-formed because the implicitly defaulted copy assignment is defined as deleted\n    memcpy(&amp;a, &amp;b, sizeof(A));  // this is well-defined because A is trivial\n    cout &lt;&lt; a.addr() &lt;&lt; \" \" &lt;&lt; b.addr() &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>It is well-defined according to the rules because <code>A</code> is a trivial type (the assertion passes OK).  The result shows that a reference is made to refer to different objects at different times.  On the opposite, the code is undefined in C++03 (with C++11-only syntax removed, i.e. the line of <code>A()=default;</code>), because <code>A</code> is not a <code>POD</code> in C++03, and C++03 allows byte-wise copy equivalence of <code>POD</code> type only.</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "3237645", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22812183_22812183_1": {"section_id": 369, "quality": 1.0, "length": 4}, "so_22812183_22816963_1": {"section_id": 369, "quality": 1.0, "length": 4}, "so_22812183_22812183_0": {"section_id": 369, "quality": 1.0, "length": 4}, "so_22812183_22812183_3": {"section_id": 7201, "quality": 0.9354838709677419, "length": 29}, "so_22812183_22812183_2": {"section_id": 3918, "quality": 0.9512195121951219, "length": 39}, "so_22812183_22816963_0": {"section_id": 369, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_22812183_22812183_1": {"section_id": 359, "quality": 1.0, "length": 4}, "so_22812183_22816963_1": {"section_id": 359, "quality": 1.0, "length": 4}, "so_22812183_22812183_0": {"section_id": 359, "quality": 1.0, "length": 4}, "so_22812183_22812183_3": {"section_id": 6945, "quality": 0.9354838709677419, "length": 29}, "so_22812183_22812183_2": {"section_id": 3778, "quality": 0.9512195121951219, "length": 39}, "so_22812183_22816963_0": {"section_id": 359, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_22812183_22812183_3": {"section_id": 8710, "quality": 0.9354838709677419, "length": 29}, "so_22812183_22812183_2": {"section_id": 4804, "quality": 0.975609756097561, "length": 40}, "so_22812183_22816963_0": {"section_id": 470, "quality": 0.5714285714285714, "length": 4}}}});