post_cb({"bq_ids": {"n4140": {"so_33893537_34232265_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1566}}, "n3337": {"so_33893537_34232265_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1561}}}, "34232265": {"PostTypeId": "2", "Body": "<p>The method using <code>memcpy</code> is standard-compliant at least since C++11 because</p>\n<ol>\n<li><p>As explained in <a href=\"https://stackoverflow.com/a/12199969/471164\">this answer</a> copy-on-write implementation of <code>std::string</code> is not allowed, because it violates standard invalidation of iterators/references requirements.</p></li>\n<li><p><code>std::string</code>'s characters are stored in contiguous memory, quoting 21.4.1.5:</p>\n<blockquote>\n<p id=\"so_33893537_34232265_0\">The char-like objects in a basic_string object shall be stored contiguously. That is, for any basic_string\n  object s, the identity &amp;*(s.begin() + n) == &amp;*s.begin() + n shall hold for all values of n such that 0\n  &lt;= n &lt; s.size().</p>\n</blockquote></li>\n</ol>\n<p>So it is the fastest standard-compliant of the methods in your list (at least according to your benchmark results).</p>\n<p>In fact, this should be safe even with a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=21334\" rel=\"nofollow noreferrer\">non-standard-compliant implementation</a> that does copy-on-write because non-const <code>operator[]</code> should make a copy of the string, for example:</p>\n<pre><code>std::string s1(\"foo\");\nstd::string s2 = s1;\nstd::cout &lt;&lt; static_cast&lt;const void*&gt;(s1.data()) &lt;&lt; \" \"\n          &lt;&lt; static_cast&lt;const void*&gt;(s2.data()) &lt;&lt; \"\\n\";\ns2[0];\nstd::cout &lt;&lt; static_cast&lt;const void*&gt;(s1.data()) &lt;&lt; \" \"\n          &lt;&lt; static_cast&lt;const void*&gt;(s2.data()) &lt;&lt; \"\\n\";\n</code></pre>\n<p>prints</p>\n<pre><code>0x1782028 0x1782028\n0x1782028 0x1782058\n</code></pre>\n<p>when I compile it with gcc 4.8.4 and a fairly old version of libstdc++ and run. Note that the pointers are different after the call to non-const <code>operator[]</code> meaning that the data has been copied.</p>\n<p>Knowing that non-const <code>operator[]</code> does some checks in COW implementation, it might be possible to speed up even more by calling const <code>operator[]</code>:</p>\n<pre><code>const std::string &amp;crep = rep;\nmemcpy(&amp;r5[3], &amp;crep[1], 7);\n</code></pre>\n<p>which is indeed faster on my system:</p>\n<pre><code>Benchmark              Time(ns)    CPU(ns) Iterations\n-----------------------------------------------------\nbench_memcpy_const            2          2  314215561 \nbench_memcpy                  3          3  276899830 \n</code></pre>\n", "LastActivityDate": "2015-12-11T21:25:11.927", "LastEditorUserId": "-1", "Id": "34232265", "CommentCount": "0", "CreationDate": "2015-12-11T20:45:31.550", "ParentId": "33893537", "Score": "2", "OwnerUserId": "471164", "LastEditDate": "2017-05-23T10:28:18.473"}, "33893537": {"ViewCount": "787", "Body": "<p>I have to replace a few (fixed) amount of characters in a long string: I'm wondering what is the fastest, but standard compliant way.</p>\n<p>Here is a sample code with 6 different methods; in the comment of the method I've added the time in milliseconds to execute the operation 1 million times in a test environment, with optimizations enabled.</p>\n<pre><code>const char* pluto = \"Cia1234567Ciao!\";\nstd::string rep = \"87654321\";\nstd::string r1 = pluto, r2 = pluto, r3 = pluto, r4 = pluto, r5 = pluto, r6 = pluto;\n\n// (1) 300 msec\nr1.replace(3, 7, rep.substr(1));  \n\n// (2) 40 msec\nstd::copy(rep.begin() + 1, rep.end(), r2.begin() + 3);\n\n// (3) 32 msec\nfor (int i = 1; i &lt; 8; ++i)\n    r3[2 + i] = rep[i];\n\n// (4) 14 msec\n{\n    const char *c = rep.c_str() + 1;\n    for (int i = 0; i &lt; 7; ++i)\n        r4[3 + i] = *c++;\n}\n\n// (5) 3 msec (BEST)\nmemcpy(&amp;r5[3], &amp;rep[1], 7);\n\n// (6) 100 msec\nr6.replace(3, 7, rep.c_str() + 1);\n</code></pre>\n<p>So the fastest way seems (5), but I fear that this method may not work correctly with the \"copy-on-write\" <code>std::string</code> optimization that many compilers use.</p>\n<p>IMHO (5) is also the more readable.</p>\n<p>I wonder why (4) is twice as fast as (3), I thought that <code>operator[]</code> of <code>std::string</code> was quite optimized...</p>\n<hr>\n<p><strong>UPDATE</strong>:</p>\n<p>After reading comments I've updated my code to use the google benchmark library and the results of (3) and (4) seems to be the same, the other differences still apply:</p>\n<pre><code>Run on (2 X 3000 MHz CPU s)\n2015-11-24 14:46:50\nBenchmark                   Time(ns)    CPU(ns) Iterations\n-----------------------------------------------------------\n(1) bench_replace_substr        293        264     2651515\n(2) bench_std_copy               39         39    19662921\n(3) bench_op_bracket             15         15    39772727\n(4) bench_op_bracket_2           15         15    44871795\n(5) bench_memcpy                  4          4    75000000\n(6) bench_replace                80         80     8333333\n</code></pre>\n<p>So the differences in (3) and (4) are gone, but the rest of the results are the same :)</p>\n</hr>", "AcceptedAnswerId": "34232265", "Title": "Fastest (and safest) method to replace characters in std::string", "CreationDate": "2015-11-24T12:17:31.873", "Id": "33893537", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-11-24T13:58:39.127", "LastEditorUserId": "1563037", "LastActivityDate": "2015-12-11T21:25:11.927", "Score": "8", "OwnerUserId": "1563037", "Tags": "<c++><string><optimization>", "AnswerCount": "1"}});