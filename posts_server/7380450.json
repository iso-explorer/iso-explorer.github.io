post_cb({"7380488": {"ParentId": "7380450", "CommentCount": "0", "Body": "<p>Because the compiler introduces the default assignment operator in myderived. Override it and call your base assignment operator yourself. Or perhaps a using directive will help? Try using mybase::operator= in myderived body.</p>\n", "OwnerUserId": "927034", "PostTypeId": "2", "Id": "7380488", "Score": "2", "CreationDate": "2011-09-11T18:48:48.143", "LastActivityDate": "2011-09-11T18:48:48.143"}, "7380475": {"ParentId": "7380450", "PostTypeId": "2", "CommentCount": "15", "CreationDate": "2011-09-11T18:47:35.940", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:29:09.360", "Id": "7380475", "OwnerUserId": "308661", "Body": "<p>This line:</p>\n<pre><code>a = b;  \n</code></pre>\n<p>obviously requires that <code>myderived</code> have overloaded the copy assignment operator. It can be implicitly generated by the compiler, or defined by the <code>myderived</code> class explicitly:</p>\n<blockquote>\n<p id=\"so_7380450_7380475_0\"><strong>12.8 Copying class objects [class.copy]</strong></p>\n<p id=\"so_7380450_7380475_1\"><em>9.</em> A user-declared copy assignment operator <code>X::operator=</code> is a\n  non-static non-template member function of class <code>X</code> with exactly one\n  parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const\n  volatile X&amp;</code>.</p>\n</blockquote>\n<p>You have attempted to create a user-declared copy assignment operator in your <code>mybase</code> class, but it's not actually a copy assignment operator according to the C++ standard. Imagine if we did a type substitution for <code>This</code> with <code>myderived</code>:</p>\n<pre><code>// Hypothetical class generated by the compiler from\n// the mybase template class with This = myderived\nstruct mybase_myderived \n{\n    myderived&amp; operator =(const myderived &amp;other) \n    { \n        // ...\n    } \n};\n</code></pre>\n<p>Clearly that's not a copy assignment operator, because the parameter <code>other</code> is of type <code>const myderived&amp;</code>, not <code>const mybase&amp;</code>. Had the <code>other</code> parameter be of type <code>const mybase&amp;</code>, or <code>mybase</code>, or <code>mybase&amp;</code>, then it would be a valid copy assignment operator, which can be called by the default copy assignment operator in <code>myderived</code>. But it isn't in this case, so the compiler still generates a default copy assignment operator for <code>mybase</code>, which of course does nothing in this case.</p>\n<p>The compiler-generated default copy assignment operator in <code>myderived</code> calls the compiler-generated default copy assignment operator in <code>mybase</code>. So what ends up happening, as As a result, the <code>operator=(const myderived &amp;other)</code> overload is never called.</p>\n<p>The reason why the compiler doesn't just call <code>mybase::operator=</code> directly is because it's been hidden by the compiler-generated copy assignment operator in <code>myderived</code>, as Alf P. Steinbach points out in <a href=\"https://stackoverflow.com/questions/7380450/why-isnt-my-assignment-operator-getting-called/7380491#7380491\">this answer</a>.</p>\n", "LastActivityDate": "2011-09-11T19:11:05.983"}, "7380491": {"ParentId": "7380450", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2011-09-11T18:49:37.460", "Score": "5", "LastEditorUserId": "464581", "LastEditDate": "2011-09-11T19:14:44.873", "Id": "7380491", "OwnerUserId": "464581", "Body": "<p><code>mybase::operator=</code> is <em>hidden</em> by the automatically generated copy assignment operator <code>myderived::operator=</code>.</p>\n<p>You can use a <code>using</code> declaration to make the base class operator visible in the derived class.</p>\n<p><strong>EDIT:</strong> added example per request:</p>\n<pre><code>template&lt;typename This&gt;\nstruct mybase\n{\n    This&amp; operator =(const This &amp;other)\n    {\n        //__debugbreak();  // The debugger should break here, but doesn't.\n        return static_cast&lt;This &amp;&gt;(*this);\n    }\n};\n\nstruct myderived : mybase&lt;myderived&gt;\n{\n    using mybase&lt;myderived&gt;::operator=;\n    int x;\n};\n\nint main()\n{\n    myderived a = myderived();  // And yes, I know it's redundant...\n    myderived b = myderived();\n    a = b;\n}\n</code></pre>\n<p>This compiles fine with Visual C++ 10.0 and with Comeau Online. The latter means, in practice, that it's good standard C++. However, the code does not compile with MinGW g++ 4.4.1 (compiler bug).</p>\n<p><strong>EDIT 2:</strong> Actually, checking now, with Visual C++ 10.0 it compiles but the base class operator is not invoked. So maybe g++ is correct. <code>using</code> is generally the way to bring in a base class assignment operator (or whatever), but in this case it has the same signature as the derived class\u2019 copy assignment operator, and I do not yet know whether Visual C++ behavior is correct or not  \u2013  it is a corner case of the language.</p>\n<p><strong>EDIT 3:</strong> I checked N3290 (the standard draft that is identical to C++11), and it says</p>\n<blockquote>\n<p id=\"so_7380450_7380491_0\"><strong>\u00a712.8/18:</strong><br>\n  If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy assignment operator is defined as deleted; otherwise, it is defined as defaulted (8.4).</br></p>\n</blockquote>\n<p>I personally interpret that as saying that with the <code>using</code> declaration in place the class \u201cdeclares\u201d a copy assignment operator, and that one should therefore not be implicitly generated (as it seems that Visual C++ 10.0 does). However, this is a corner case of the language. Others may possibly interpret this differently, and as noted above, compilers differ!</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2011-09-11T19:14:44.873"}, "7380481": {"ParentId": "7380450", "CommentCount": "4", "Body": "<p>Because the default assignment operator in derived will hide the overloaded in base.</p>\n", "OwnerUserId": "174614", "PostTypeId": "2", "Id": "7380481", "Score": "6", "CreationDate": "2011-09-11T18:48:02.500", "LastActivityDate": "2011-09-11T18:48:02.500"}, "7380450": {"CommentCount": "0", "ViewCount": "781", "CreationDate": "2011-09-11T18:43:03.937", "LastActivityDate": "2011-09-11T19:14:44.873", "Title": "Why isn't my assignment operator getting called?", "AcceptedAnswerId": "7380491", "PostTypeId": "1", "Id": "7380450", "Score": "1", "Body": "<p>I'm confused... why isn't my assignment operator getting called here?</p>\n<pre><code>template&lt;typename This&gt;\nstruct mybase\n{\n    This&amp; operator =(const This &amp;other)\n    {\n        __debugbreak();  // The debugger should break here, but doesn't.\n        return static_cast&lt;This &amp;&gt;(*this):\n    }\n};\n\nstruct myderived : mybase&lt;myderived&gt;\n{\n    int x;\n};\n\nint main()\n{\n    myderived a = myderived();  // And yes, I know it's redundant...\n    myderived b = myderived();\n    a = b;\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><operator-overloading><assignment-operator>", "OwnerUserId": "541686", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_7380450_7380475_1": {"section_id": 466, "quality": 0.9444444444444444, "length": 17}, "so_7380450_7380491_0": {"section_id": 467, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_7380450_7380475_1": {"section_id": 457, "quality": 0.9444444444444444, "length": 17}, "so_7380450_7380491_0": {"section_id": 458, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_7380450_7380475_1": {"section_id": 489, "quality": 0.9444444444444444, "length": 17}, "so_7380450_7380491_0": {"section_id": 490, "quality": 0.9333333333333333, "length": 28}}}});