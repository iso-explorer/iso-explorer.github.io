post_cb({"bq_ids": {"n4140": {"so_45815301_45815368_0": {"length": 14, "quality": 0.6666666666666666, "section_id": 6167}, "so_45815301_45815382_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 6182}}, "n3337": {"so_45815301_45815368_0": {"length": 14, "quality": 0.6666666666666666, "section_id": 5928}, "so_45815301_45815382_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5943}}, "n4659": {"so_45815301_45815368_0": {"length": 14, "quality": 0.6666666666666666, "section_id": 7664}, "so_45815301_45815382_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7684}}}, "45818909": {"Id": "45818909", "PostTypeId": "2", "Body": "<h1>It depends.</h1>\n<p>First, let's assume that <code>x++</code> by itself does not invoke undefined behavior. Think about signed overflow, incrementing a past-the-end-pointer, or the postfix-increment-operator might be user-defined).<br>\nFurther, let's assume that invoking <code>f()</code> and <code>g()</code> with their arguments and destroying the temporaries does not invoke undefined behavior.<br>\nThat are quite a lot of assumptions, but if they are broken the answer is trivial.</br></br></p>\n<p>Now, if the comma is the built-in comma-operator, the comma in a braced-init-list, or the comma in a mem-initializer-list, the left and right side are sequenced either before or after each other (and you know which), so don't interfere, making the behavior well-defined.</p>\n<pre><code>struct X {\n    int f, g;\n    explicit X(int x) : f(x++), g(x++) {}\n};\n// Demonstrate that the order depends on member-order, not initializer-order:\nstruct Y {\n    int g, f;\n    explicit Y(int x) : f(x++), g(x++) {}\n};\nint y[] = { f(x++), g(x++) };\n</code></pre>\n<p>Otherwise, if <code>x++</code> invokes a user-defined operator-overload for postfix-increment, you have indeterminate sequencing of the two instances of <code>x++</code> and thus unspecified behavior.</p>\n<pre><code>std::list&lt;int&gt; list{1,2,3,4,5,6,7};\nauto x = begin(list);\nusing T = decltype(x);\n\nvoid h(T, T);\nh(f(x++), g(x++));\nstruct X {\n    X(T, T) {}\n}\nX(f(x++), g(x++));\n</code></pre>\n<p>And in the final case, you get full-blown undefined behavior as the two postfix-increments of <code>x</code> are unsequenced.</p>\n<pre><code>int x = 0;\n\nvoid h(int, int);\nh(f(x++), g(x++));\nstruct X {\n    X(int, int) {}\n}\nX(f(x++), g(x++));\n</code></pre>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2017-08-22T14:05:45.617", "Score": "12", "CreationDate": "2017-08-22T13:24:12.667", "ParentId": "45815301", "CommentCount": "0", "OwnerUserId": "3204551", "LastEditDate": "2017-08-22T14:05:45.617"}, "45815382": {"Id": "45815382", "PostTypeId": "2", "Body": "<p>To quote C++11 (n3337) <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.comma\" rel=\"noreferrer\">[expr.comma/1]</a>:</p>\n<blockquote>\n<p id=\"so_45815301_45815382_0\">A pair of expressions separated by a comma is evaluated left-to-right;\n  the left expression is a discarded-value expression (Clause [expr]).\n  <strong>Every value computation and side effect associated with the left\n  expression is sequenced before every value computation and side effect\n  associated with the right expression.</strong></p>\n</blockquote>\n<p>And I take \"every\" to mean \"every\"<sup>1</sup>. The evaluation of the second <code>x++</code> cannot happen before the call sequence to <code>f</code> is completed and <code>f</code> returns.<sup>2</sup></p>\n<hr>\n<p><sub>\n<sup>1</sup> Destructor calls aren't associated with sub-expressions, only with full expressions. So you'll see those executed in reverse order to temporary object creation at the end of the full expression.<br>\n<sup>2</sup> This paragraph only applies to the comma when used as an operator. When the comma has a special meaning (such when designating a function call argument sequence) this does not apply.\n</br></sub></p>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2017-08-22T13:08:03.403", "Score": "50", "CreationDate": "2017-08-22T10:37:58.693", "ParentId": "45815301", "CommentCount": "12", "OwnerUserId": "817643", "LastEditDate": "2017-08-22T13:08:03.403"}, "45815368": {"Id": "45815368", "PostTypeId": "2", "Body": "<h3>No, it isn't undefined behavior.</h3>\n<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow noreferrer\">this evaluation order and sequencing reference</a> the left hand side of the comma is fully evaluated before the right hand side (see <a href=\"http://en.cppreference.com/w/cpp/language/eval_order#Rules\" rel=\"nofollow noreferrer\">rule</a> 9):</p>\n<blockquote>\n<p id=\"so_45815301_45815368_0\">9) Every value computation and side effect of the first (left) argument of the built-in comma operator , is sequenced before every value computation and side effect of the second (right) argument.</p>\n</blockquote>\n<p>That means an expression like <code>f(x++), g(x++)</code> is <em>not</em> undefined.</p>\n<p>Note that this is only valid for the <em>built-in</em> comma operator.</p>\n", "LastEditorUserId": "440558", "LastActivityDate": "2017-09-17T11:14:09.963", "Score": "23", "CreationDate": "2017-08-22T10:37:11.017", "ParentId": "45815301", "CommentCount": "2", "OwnerUserId": "440558", "LastEditDate": "2017-09-17T11:14:09.963"}, "45815301": {"ViewCount": "4572", "Body": "<p>I was reading this question:</p>\n<p><a href=\"https://stackoverflow.com/q/4176328/1593077\">Undefined behavior and sequence points</a></p>\n<p>and, specifically, the <a href=\"https://stackoverflow.com/a/4183735/1593077\">C++11 answer</a>, and I understand the idea of \"sequencing\" of evaluations. But - is there sufficient sequencing when I write:</p>\n<p><code>f(x++), g(x++);</code> ?</p>\n<p>That is, am I guaranteed that <code>f()</code> gets the original value of <code>x</code> and <code>g()</code> gets a once-incremented <code>x</code>?</p>\n<p>Notes for nitpickers:</p>\n<ul>\n<li>Assume that <code>operator++()</code> has defined behavior (even if we've overriden it) and so do <code>f()</code> and <code>g()</code>, that no exceptions will be thrown, etc. - this question is not about that.</li>\n<li>Assume that <code>operator,()</code> has not been overloaded.</li>\n</ul>\n", "AcceptedAnswerId": "45815368", "Title": "With C++11, is it undefined behavior to write f(x++), g(x++)?", "CreationDate": "2017-08-22T10:34:09.923", "Id": "45815301", "CommentCount": "13", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-08-22T18:44:59.087", "LastEditorUserId": "1593077", "LastActivityDate": "2017-09-17T11:14:09.963", "Score": "39", "OwnerUserId": "1593077", "Tags": "<c++><c++11><expression><undefined-behavior>", "AnswerCount": "3"}});