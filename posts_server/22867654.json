post_cb({"23087392": {"Id": "23087392", "PostTypeId": "2", "Body": "<p>From the C++ standard N3797 S3.5/2-3</p>\n<blockquote>\n<p id=\"so_22867654_23087392_0\">A name is said to have linkage when it might denote the same object, reference, function, type, template, namespace or value as a name introduced by a declaration in another scope:</p>\n<p id=\"so_22867654_23087392_1\">\u2014 When a name has external linkage , the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit.</p>\n<p id=\"so_22867654_23087392_2\">\u2014 When a name has internal linkage , the entity it denotes can be referred to by names from other scopes in the same translation unit.</p>\n<p id=\"so_22867654_23087392_3\">\u2014 When a name has no linkage , the entity it denotes cannot be referred to by names from other scopes.</p>\n<p id=\"so_22867654_23087392_4\">A name having namespace scope (3.3.6) has internal linkage if it is the name of</p>\n<p id=\"so_22867654_23087392_5\">\u2014 a variable, function or function template that is explicitly declared static; or,</p>\n<p id=\"so_22867654_23087392_6\">\u2014 a non-volatile variable that is explicitly declared const or constexpr and neither explicitly declared extern nor previously declared to have external linkage; or</p>\n<p id=\"so_22867654_23087392_7\">\u2014 a data member of an anonymous union.</p>\n</blockquote>\n<p>My reading is that in the following code:</p>\n<pre><code>public:\n  static constexpr int SOME_VALUE=5;\n  constexpr int SOME_VALUE=5;\n};\nstatic constexpr int SOME_VALUE=5;\nconstexpr int SOME_VALUE=5;\n</code></pre>\n<p>All 4 instances of <code>SOME_VALUE</code> have internal linkage. They should link with a reference to <code>SOME_VALUE</code> in the same translation unit and not be visible elsewhere.</p>\n<p>Obviously the first one is a declaration and not a definition. It needs a definition within the same translation unit. If GCC says so and MSVC does not, then MSVC is wrong.</p>\n<p>For the purposes of replacing an enum, number 2 should work fine. It still has internal linkage without the <code>static</code> keyword.</p>\n<p>[Edited in response to comment]</p>\n", "LastEditorUserId": "1105562", "LastActivityDate": "2014-04-16T23:17:52.797", "Score": "1", "CreationDate": "2014-04-15T14:56:17.950", "ParentId": "22867654", "CommentCount": "5", "LastEditDate": "2014-04-16T23:17:52.797", "OwnerUserId": "1105562"}, "23089865": {"Id": "23089865", "PostTypeId": "2", "Body": "<p>Nowadays, the preferred way is:</p>\n<pre><code>enum class : int C { SOME_VALUE = 5 };\n</code></pre>\n", "LastActivityDate": "2014-04-15T16:50:29.163", "CommentCount": "3", "CreationDate": "2014-04-15T16:50:29.163", "ParentId": "22867654", "Score": "1", "OwnerUserId": "2200999"}, "23319236": {"Id": "23319236", "PostTypeId": "2", "Body": "<p>You have three options here:</p>\n<ol>\n<li><p>If your class is template, then put the definition of static member in header itself. Compiler is required to identify it as one definition only across multiple translation units (see [basic.def.odr]/5)</p></li>\n<li><p>If your class is non-template you can easily put it in source file</p></li>\n<li><p>Alternatively declare constexpr static member function getSomeValue():</p>\n<pre><code>class C\n{\npublic:\n    static constexpr int getSomeValue() { return 27; }\n};\n</code></pre></li>\n</ol>\n", "LastActivityDate": "2014-04-27T04:00:04.733", "CommentCount": "0", "CreationDate": "2014-04-27T04:00:04.733", "ParentId": "22867654", "Score": "7", "OwnerUserId": "575285"}, "43621912": {"Id": "43621912", "PostTypeId": "2", "Body": "<p>For the record, the <code>static constexpr</code> version will work like you'd expected in C++17. From N4618 Annex D.1 <a href=\"http://eel.is/c++draft/depr.static_constexpr\" rel=\"nofollow noreferrer\">[depr.static_constexpr]</a>:</p>\n<blockquote>\n<h3>D.1 Redeclaration of <code>static constexpr</code> data members [depr.static_constexpr]</h3>\n<p id=\"so_22867654_43621912_0\">For compatibility with prior C++ International Standards, a <code>constexpr</code> static data member may be redundantly redeclared outside the class with no initializer. This usage is deprecated. [<em>Example:</em></p>\n</blockquote>\n<pre><code>struct A {\n static constexpr int n = 5; // de\ufb01nition (declaration in C++ 2014)\n};\n\nconstexpr int A::n; // redundant declaration (de\ufb01nition in C++ 2014)\n</code></pre>\n<blockquote>\n<p id=\"so_22867654_43621912_1\">\u2014<em>end example</em>]</p>\n</blockquote>\n<p>The relevant standard text that allows this is N4618 9.2.3 <a href=\"http://eel.is/c++draft/class.static.data#3\" rel=\"nofollow noreferrer\">[class.static.data]/3</a>:</p>\n<blockquote>\n<p id=\"so_22867654_43621912_2\">[...] An inline static data member may be de\ufb01ned in the class de\ufb01nition and may specify a <em>brace-or-equal-initializer</em>. If the member is declared with the <code>constexpr</code> speci\ufb01er, it may be redeclared in namespace scope with no initializer (this usage is deprecated; see D.1). [...]</p>\n</blockquote>\n<p>This comes with the same machinery that introduced the non-<code>constexpr</code> version of the same thing, <a href=\"https://stackoverflow.com/q/38043442/166389\"><em>inline static data members</em></a>.</p>\n<pre><code>struct A {\n static inline int n = 5; // de\ufb01nition (illegal in C++ 2014)\n}; \n\ninline int A::n; // illegal\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-25T22:24:46.597", "Score": "3", "CreationDate": "2017-04-25T22:17:12.940", "ParentId": "22867654", "CommentCount": "1", "LastEditDate": "2017-05-23T11:46:50.813", "OwnerUserId": "166389"}, "23349028": {"Id": "23349028", "PostTypeId": "2", "Body": "<p>I'd go with enum class:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/enum\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/enum</a></p>\n<p><a href=\"http://www.stroustrup.com/C++11FAQ.html#enum\" rel=\"nofollow\">http://www.stroustrup.com/C++11FAQ.html#enum</a></p>\n<p>From the first link:</p>\n<pre><code>enum class Color { RED, GREEN=20, BLUE};\nColor r = Color::BLUE;\nswitch(r) {\n    case Color::RED : std::cout &lt;&lt; \"red\\n\"; break;\n    case Color::GREEN : std::cout &lt;&lt; \"green\\n\"; break;\n    case Color::BLUE : std::cout &lt;&lt; \"blue\\n\"; break;\n}\n// int n = r; // error: no scoped enum to int conversion\nint n = static_cast&lt;int&gt;(r); // OK, n = 21\n</code></pre>\n", "LastActivityDate": "2014-04-28T18:53:22.807", "CommentCount": "1", "CreationDate": "2014-04-28T18:53:22.807", "ParentId": "22867654", "Score": "3", "OwnerUserId": "1110209"}, "bq_ids": {"n4140": {"so_22867654_23087392_4": {"length": 7, "quality": 0.875, "section_id": 7136}, "so_22867654_23087392_6": {"length": 16, "quality": 1.0, "section_id": 7136}, "so_22867654_23087392_5": {"length": 7, "quality": 1.0, "section_id": 7136}, "so_22867654_23087392_7": {"length": 4, "quality": 1.0, "section_id": 369}, "so_22867654_23087392_0": {"length": 19, "quality": 0.95, "section_id": 7135}, "so_22867654_23087392_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7135}, "so_22867654_23087392_3": {"length": 10, "quality": 1.0, "section_id": 7135}, "so_22867654_23087392_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7135}}, "n3337": {"so_22867654_23087392_5": {"length": 7, "quality": 1.0, "section_id": 6880}, "so_22867654_23087392_4": {"length": 7, "quality": 0.875, "section_id": 6880}, "so_22867654_23087392_6": {"length": 15, "quality": 0.9375, "section_id": 6880}, "so_22867654_23087392_7": {"length": 4, "quality": 1.0, "section_id": 359}, "so_22867654_23087392_0": {"length": 19, "quality": 0.95, "section_id": 6879}, "so_22867654_23087392_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6879}, "so_22867654_23087392_3": {"length": 10, "quality": 1.0, "section_id": 6879}, "so_22867654_23087392_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6879}}, "n4659": {"so_22867654_23087392_4": {"length": 7, "quality": 0.875, "section_id": 8637}, "so_22867654_23087392_5": {"length": 7, "quality": 1.0, "section_id": 8637}, "so_22867654_43621912_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 7390}, "so_22867654_43621912_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 6305}, "so_22867654_23087392_7": {"length": 4, "quality": 1.0, "section_id": 382}, "so_22867654_23087392_0": {"length": 19, "quality": 0.95, "section_id": 8636}, "so_22867654_23087392_6": {"length": 13, "quality": 0.8125, "section_id": 8637}, "so_22867654_23087392_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 8636}, "so_22867654_23087392_3": {"length": 10, "quality": 1.0, "section_id": 8636}, "so_22867654_23087392_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8636}}}, "22867654": {"ViewCount": "6147", "Body": "<p>Let me start by stating my intent. In the olden (C++) days, we would have code like:</p>\n<pre><code>class C\n{\npublic:\n  enum {SOME_VALUE=27};\n};\n</code></pre>\n<p>Then we could use <code>SOME_VALUE</code> throughout our code as a compile time constant and wherever the compiler would see <code>C::SOME_VALUE</code>, it would just insert the literal 27.</p>\n<p>Now days, it is seems more acceptable to change that code to something like:</p>\n<pre><code>class C\n{\npublic:\n  static constexpr int SOME_VALUE=27;\n};\n</code></pre>\n<p>This looks much cleaner, gives <code>SOME_VALUE</code> a well defined type and seems to be the preferred approach as of C++11. The (unforseen at least for me) problem is that this also causes scenarios where <code>SOME_VALUE</code> needs to be made external. That is, in some cpp file somewhere, we need to add:</p>\n<pre><code>constexpr int C::SOME_VALUE; // Now C::SOME_VALUE has external linkage\n</code></pre>\n<p>The cases that cause this seem to be when const references to <code>SOME_VALUE</code> are used, which happens quite often in C++ Standard Library code (See the example at the bottom of this question). I am using gcc 4.7.2 as my compiler by the way. </p>\n<p>Due to this dilemma, I am forced to revert back to defining <code>SOME_VALUE</code> as an enum (i.e., old school) in order to avoid having to add a definition to a cpp file for some, but not all of my static constexpr member variables. Isn't there some way to tell the compiler that <code>constexpr int SOME_VALUE=27</code> means that <code>SOME_VALUE</code> should be treated <em>only</em> as a compile time constant and never an object with external linkage? If you see a const reference used with it, create a temporary. If you see its address taken, generate a compile time error if that's what's needed, because it's a compile time constant and nothing more.</p>\n<p>Here is some seemingly benign sample code that causes us to need to add the definition for <code>SOME_VALUE</code> in a cpp file (once again, tested with gcc 4.7.2):</p>\n<pre><code>#include &lt;vector&gt;\n\nclass C\n{\npublic:\n  static constexpr int SOME_VALUE=5;\n};\n\nint main()\n{\n  std::vector&lt;int&gt; iv;\n\n  iv.push_back(C::SOME_VALUE); // Will cause an undefined reference error\n                               // at link time, because the compiler isn't smart\n                               // enough to treat C::SOME_VALUE as the literal 5\n                               // even though it's obvious at compile time\n}\n</code></pre>\n<p>Adding the following line to the code at file scope will resolve the error:</p>\n<pre><code>constexpr int C::SOME_VALUE;\n</code></pre>\n", "AcceptedAnswerId": "43621912", "Title": "enum vs constexpr for actual static constants inside classes", "CreationDate": "2014-04-04T16:02:15.650", "Id": "22867654", "CommentCount": "15", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2016-11-12T17:04:00.807", "LastEditorUserId": "608639", "LastActivityDate": "2017-04-25T22:24:46.597", "Score": "57", "OwnerUserId": "473798", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "6"}, "22917858": {"Id": "22917858", "PostTypeId": "2", "Body": "<p>you can do this</p>\n<pre><code>class C\n{\npublic:\n  static const int SOME_VALUE=5;\n};\n\nint main()\n{\n  std::vector&lt;int&gt; iv;\n  iv.push_back(C::SOME_VALUE); \n}\n</code></pre>\n<p>This is not even C++11, just C++98 </p>\n", "LastActivityDate": "2014-04-07T16:21:51.403", "CommentCount": "9", "CreationDate": "2014-04-07T16:21:51.403", "ParentId": "22867654", "Score": "-1", "OwnerUserId": "2144010"}});