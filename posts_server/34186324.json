post_cb({"34211359": {"ParentId": "34186324", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>No, there is no technical reason to use the canonical copy assignment operator signature.</strong></p>\n<p>As seen in the standard, [dcl.fct.def.delete] \u00a78.4.3:</p>\n<blockquote id=\"so_34186324_34211359_0\">\n<ol start=\"2\">\n<li>A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed.\n  [ Note: This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member\n  to the function. It applies even for references in expressions that are not potentially-evaluated. <strong>If a function\n  is overloaded, it is referenced only if the function is selected by overload resolution.</strong> \u2014 end note ]</li>\n</ol>\n</blockquote>\n<p>Therefore a deleted function's name, in this case <code>operator=</code>, may only be used if the compiler finds a preferable overload resolution. However, such an overload cannot exist, as <code>X</code> and <code>const X&amp;</code> are indistinguishable as parameters ([over.ics.rank] \u00a713.3.3.2) and the return value is ignored.</p>\n<p><strong>That being said</strong>, there <em>is</em> a stylistic reason to use the canonical signature. The mere fact that this question exists shows that anyone reading your code may <em>not</em> know the meaning and assume it is doing something special. For readability's sake, I would recommend you use the familiar <code>X&amp; operator=(const X&amp;) = delete;</code>.</p>\n", "OwnerUserId": "1922722", "LastEditorUserId": "1922722", "LastEditDate": "2015-12-14T17:11:36.840", "Id": "34211359", "Score": "6", "CreationDate": "2015-12-10T20:43:03.927", "LastActivityDate": "2015-12-14T17:11:36.840"}, "bq_ids": {"n4140": {"so_34186324_34211359_0": {"section_id": 3277, "quality": 0.8823529411764706, "length": 30}}, "n3337": {"so_34186324_34211359_0": {"section_id": 3148, "quality": 0.8823529411764706, "length": 30}}, "n4659": {"so_34186324_34211359_0": {"section_id": 4035, "quality": 0.8823529411764706, "length": 30}}}, "34186324": {"CommentCount": "12", "ViewCount": "285", "PostTypeId": "1", "LastEditorUserId": "343443", "CreationDate": "2015-12-09T18:26:39.750", "LastActivityDate": "2015-12-14T17:11:36.840", "Title": "How to forbid assignment", "AcceptedAnswerId": "34211359", "LastEditDate": "2015-12-09T18:46:39.950", "Id": "34186324", "Score": "11", "Body": "<p>Is there a reason to use the \u201ccanonical\u201d signatures for <code>operator=</code></p>\n<pre><code>class X {\n  X&amp; operator=(const X&amp;) = delete;\n  X&amp; operator=(X&amp;&amp;) = delete;\n};\n</code></pre>\n<p>instead of just</p>\n<pre><code>class X {\n  void operator=(X) = delete;\n};\n</code></pre>\n<p>when all you want to do is <code>delete</code> it?</p>\n<p><strong>Upd:</strong><br>\nAlso, consider a situation when <code>X</code> has an explicitly declared move or copy constructor.</br></p>\n<pre><code>class X {\npublic:\n  X(X&amp;&amp;);\n};\n</code></pre>\n<p>In that case <code>op=(X&amp;&amp;)</code> and <code>op=(const X&amp;)</code> are implicitly deleted, but I want to explicitly express that assignment is not allowed.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "343443", "AnswerCount": "1"}});