post_cb({"12190063": {"Id": "12190063", "PostTypeId": "2", "Body": "<p>If you want to see the memory layout of all class types in memory under MSVC, add the <code>/d1reportAllClassLayout</code> switch to the compiler command line.</p>\n<p>If you want to see what one class is layed out like, add <code>/d1reportSingleClassLayoutNNNNN</code> where <code>NNNNN</code> is the name of the class.</p>\n", "LastEditorUserId": "500104", "LastActivityDate": "2012-09-26T22:57:22.227", "Score": "1", "CreationDate": "2012-08-30T04:47:25.197", "ParentId": "3454954", "CommentCount": "0", "LastEditDate": "2012-09-26T22:57:22.227", "OwnerUserId": "1634978"}, "3455001": {"Id": "3455001", "PostTypeId": "2", "Body": "<p>C <code>struct</code>s (and C++ PODs, for compatibility) <a href=\"https://stackoverflow.com/questions/118068/why-doesnt-gcc-optimize-structs/118177#118177\">are required by the standard to have sequential layout</a>.</p>\n<p>The only difference between compilers is alignment, but fortunately, both MSVC and GCC support <code>#pragma pack</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-08-11T03:09:16.870", "Score": "2", "CreationDate": "2010-08-11T03:09:16.870", "ParentId": "3454954", "CommentCount": "4", "LastEditDate": "2017-05-23T11:43:55.950", "OwnerUserId": "287586"}, "bq_ids": {"n4140": {"so_3454954_3455012_1": {"length": 12, "quality": 0.5714285714285714, "section_id": 3298}, "so_3454954_3455012_4": {"length": 17, "quality": 0.85, "section_id": 5876}, "so_3454954_3455012_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 5873}}, "n3337": {"so_3454954_3455012_1": {"length": 12, "quality": 0.5714285714285714, "section_id": 3168}, "so_3454954_3455012_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 5644}, "so_3454954_3455012_4": {"length": 18, "quality": 0.9, "section_id": 5647}, "so_3454954_3455012_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 5650}}, "n4659": {"so_3454954_3455012_4": {"length": 17, "quality": 0.85, "section_id": 7361}, "so_3454954_3455012_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 7356}}}, "3454979": {"Id": "3454979", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3454954_3454979_0\">Is the way C++ structs are laid out\n  set by the standard, or at least\n  common across compilers?</p>\n</blockquote>\n<p>There is no guarantee in the standard. I would not depend on compilers having the same alignment</p>\n<blockquote>\n<p id=\"so_3454954_3454979_1\">I have a struct where one of its\n  members needs to be aligned on 16 byte\n  boundaries, and this would be easier\n  if I can guarantee the ordering of the\n  fields.</p>\n</blockquote>\n<p>Compilers will not change the order of the fields.  </p>\n<p>Here are some links on how to set them for both GCC and MSVC:<br>\nFor GCC: <a href=\"http://developer.apple.com/mac/library/documentation/DeveloperTools/gcc-4.0.1/gcc/Structure_002dPacking-Pragmas.html\" rel=\"nofollow noreferrer\">http://developer.apple.com/mac/library/documentation/DeveloperTools/gcc-4.0.1/gcc/Structure_002dPacking-Pragmas.html</a><br>\nMSVC: <a href=\"http://msdn.microsoft.com/en-us/library/ms253935(VS.80).aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/ms253935(VS.80).aspx</a>  and <a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1(VS.80).aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/2e70t5y1(VS.80).aspx</a> </br></br></p>\n<p>I would keep them as structures and use an extern \"C\" to ensure that it works properly. Maybe not needed but that would definitely work.</p>\n", "LastEditorUserId": "313137", "LastActivityDate": "2010-08-11T03:25:01.667", "Score": "4", "CreationDate": "2010-08-11T03:02:19.597", "ParentId": "3454954", "CommentCount": "0", "LastEditDate": "2010-08-11T03:25:01.667", "OwnerUserId": "313137"}, "3455012": {"Id": "3455012", "PostTypeId": "2", "Body": "<p>C and C++ both guarantee that fields will be laid out in memory in the same order as you define them. For C++ that's only guaranteed for a POD type<sup>1</sup> (anything that would be legitimate as a C struct [Edit: C89/90 -- not, for example, a C99 VLA] will also qualify as a POD).</p>\n<p>The compiler is free to insert padding between members and/or at the end of the struct. Most compilers give you some way to control that (e.g., <code>#pragma pack(N)</code>), but it does vary between compilers.</p>\n<p><sup>1</sup>Well, there is one corner case they didn't think of, where it isn't guaranteed for a POD type -- an access specifier breaks the ordering guarantee:</p>\n<pre><code>struct x { \n    int x;\n    int y;\npublic:\n    int z;\n};\n</code></pre>\n<p>This is a POD type, but the <code>public:</code> between <code>y</code> and <code>z</code> means they could theoretically be re-ordered. I'm pretty sure this is purely theoretical though -- I don't know of any compiler that does reorder the members in this situation (and unless memory fails me even worse than usual today, this is fixed in C++0x).</p>\n<p>Edit: the relevant parts of the standard (at least most of them) are \u00a79/4:</p>\n<blockquote>\n<p id=\"so_3454954_3455012_0\">A POD-struct is an aggregate class that has no non-volatile \n          data members of type pointer to member, non-POD-struct, non- \n          POD-union (or array of such types) or reference, and has no \n          user-defined copy assignment operator and no user-defined \n          destructor. </p>\n</blockquote>\n<p>and \u00a78.5.1/1: </p>\n<blockquote>\n<p id=\"so_3454954_3455012_1\">An aggregate is an array or a class (clause 9) with no user- \n          declared constructors (12.1), no private or protected non- \n          static data members (clause 11), no base classes (clause 10) \n          and no virtual functions (10.3).</p>\n</blockquote>\n<p>and \u00a79.2/12:</p>\n<blockquote>\n<p id=\"so_3454954_3455012_2\">...the order of allocation of non-static data members \n          separated by an access-specifier is unspecified (11.1). </p>\n</blockquote>\n<p>Though that's restricted somewhat by \u00a79.2/17:</p>\n<blockquote>\n<p id=\"so_3454954_3455012_3\">A pointer to a POD-struct object, suitably converted using \n          a reinterpret_cast, points to its initial member... </p>\n</blockquote>\n<p>Therefore, (even if preceded by a <code>public:</code>, the first member you define must come first in memory. Other members separated by <code>public:</code> specifiers could theoretically be rearranged.</p>\n<p>I should also point out that there's some room for argument about this. In particular, there's also a rule in \u00a79.2/14: </p>\n<blockquote>\n<p id=\"so_3454954_3455012_4\">Two POD-struct (clause 9) types are layout-compatible if they have the same number of nonstatic data members, and corresponding nonstatic data members (in order) have layout-compatible types (3.9).</p>\n</blockquote>\n<p>Therefore, if you have something like:</p>\n<pre><code>struct A { \n    int x;\npublic:\n    int y;\npublic:\n    int z;\n};\n</code></pre>\n<p>It is required to be layout compatible with:</p>\n<pre><code>struct B {\n    int x;\n    int y;\n    int z;\n};\n</code></pre>\n<p>I'm pretty sure this is/was <em>intended</em> to mean that the members of the two structs must be laid out the same way in memory. Since the second one clearly can't have its members rearranged, the first one shouldn't be either. Unfortunately, the standard never really defines what \"layout compatible\" means, rendering the argument rather weak at best.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2010-08-11T03:54:56.527", "Score": "12", "CreationDate": "2010-08-11T03:10:58.783", "ParentId": "3454954", "CommentCount": "3", "LastEditDate": "2010-08-11T03:54:56.527", "OwnerUserId": "179910"}, "3454990": {"Id": "3454990", "PostTypeId": "2", "Body": "<p>Structures are laid out sequentially in memory. However, the way they're aligned in memory varies based on the operating system.</p>\n<p>For things bigger than 4 bytes, there's a difference between Windows and Linux. Linux aligns them as if they're 4 bytes, so for example a double (8 bytes) could start at p+4, p+8, p+12, etc. where p is the start of the structure. In Windows, a double (8 bytes) needs to start at an address that's a multiple of 8 so p+8, p+16, p+24, etc.</p>\n", "LastEditorUserId": "344612", "LastActivityDate": "2010-08-11T03:14:29.383", "Score": "0", "CreationDate": "2010-08-11T03:05:55.583", "ParentId": "3454954", "CommentCount": "3", "LastEditDate": "2010-08-11T03:14:29.383", "OwnerUserId": "344612"}, "3454967": {"Id": "3454967", "PostTypeId": "2", "Body": "<p>C++ inherits from c the need/desire to work efficiently on many platforms, and therefore leaves certain things up to the compiler. Aside from requiring elements to appear in the specified order, this is one of them.</p>\n<p>But many compilers support <code>#pragma</code>s and options to let you establish come control of the packing. See your compiler's documentation.</p>\n", "LastEditorUserId": "2509", "LastActivityDate": "2010-08-11T03:05:06.303", "Score": "5", "CreationDate": "2010-08-11T02:58:48.797", "ParentId": "3454954", "CommentCount": "2", "LastEditDate": "2010-08-11T03:05:06.303", "OwnerUserId": "2509"}, "3454954": {"ViewCount": "1748", "Body": "<p>Is the way C++ structs are laid out set by the standard, or at least common across compilers?</p>\n<p>I have a struct where one of its members needs to be aligned on 16 byte boundaries, and this would be easier if I can guarantee the ordering of the fields.</p>\n<p>Also, for non-virtual classes, is the address of the first element also likely to be the address of the struct?</p>\n<p>I'm most interested in GCC and MSVS.</p>\n", "AcceptedAnswerId": "3455012", "Title": "How are structs laid out in memory in C++?", "CreationDate": "2010-08-11T02:54:47.247", "Id": "3454954", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-09-26T22:57:22.227", "Score": "6", "OwnerUserId": "393526", "Tags": "<c++><visual-c++><memory><gcc><struct>", "AnswerCount": "6"}});