post_cb({"bq_ids": {"n4140": {"so_25316779_25316835_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 564}}, "n3337": {"so_25316779_25316835_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 555}}, "n4659": {"so_25316779_25316835_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 587}}}, "25316779": {"ViewCount": "720", "Body": "<pre><code>class C\n{\npublic:\n    void foo() const {}\nprivate:\n    void foo() {}\n};\n\nint main()\n{\n    C c;\n    c.foo();\n}\n</code></pre>\n<p>MSVC 2013 doesn't like this:</p>\n<pre><code>&gt; error C2248: 'C::foo' : cannot access private member declared in class 'C'\n</code></pre>\n<p>If I cast to a <code>const</code> reference, it works:</p>\n<pre><code>const_cast&lt;C const &amp;&gt;(c).foo();\n</code></pre>\n<p>Why can't I call the <code>const</code> method on the non<code>const</code> object?</p>\n", "AcceptedAnswerId": "25316835", "Title": "On a nonconst object, why won't C++ call the const version of a method with public-const and private-nonconst overloads?", "CreationDate": "2014-08-14T20:11:29.523", "Id": "25316779", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-08-15T06:27:24.227", "Score": "26", "OwnerUserId": "805659", "Tags": "<c++><const><private><public>", "AnswerCount": "2"}, "25316802": {"Id": "25316802", "PostTypeId": "2", "Body": "<p>The object is not <code>const</code>, so the non-<code>const</code> overload is a better match. Overload resolution happens before access checking. This ensures that overload resolution is not inadvertently changed by changing the access of a member function.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2014-08-15T06:27:24.227", "Score": "24", "CreationDate": "2014-08-14T20:13:01.387", "ParentId": "25316779", "CommentCount": "1", "LastEditDate": "2014-08-15T06:27:24.227", "OwnerUserId": "661519"}, "25316835": {"Id": "25316835", "PostTypeId": "2", "Body": "<p>From the standard:</p>\n<blockquote>\n<p id=\"so_25316779_25316835_0\">13.3.3 If a best viable function exists and is unique, overload resolution succeeds and produces it as the result.\n  Otherwise overload resolution fails and the invocation is ill-formed. <strong>When overload resolution succeeds, and\n  the best viable function is not accessible (Clause 11) in the context in which it is used, the program is\n  ill-formed.</strong></p>\n</blockquote>\n", "LastActivityDate": "2014-08-14T20:15:05.610", "Score": "22", "CreationDate": "2014-08-14T20:15:05.610", "ParentId": "25316779", "CommentCount": "5", "OwnerUserId": "1707560"}});