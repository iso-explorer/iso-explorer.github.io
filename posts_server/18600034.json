post_cb({"18601535": {"Id": "18601535", "PostTypeId": "2", "Body": "<p>I think that all this wording is there to describe what will happen in dynamic loaded libraries, but without explicitly naming them.</p>\n<p>To summarize how I interpret it: a non-local variable with static storage duration and dynamic initialization will:</p>\n<ol>\n<li>be initialized before the \ufb01rst odr-use of anything in its translation unit;</li>\n<li>possibly, before starting <code>main</code>, but possibly after it.</li>\n</ol>\n<p>I interpret the footnote 34 as (but remember that footnotes are not normative):</p>\n<blockquote>\n<p id=\"so_18600034_18601535_0\">When anything in a TU is ord-used, then every non-local variable with static storage duration having initialization with side-e\ufb00ects must be initialized, even the variables that are not odr-used.</p>\n</blockquote>\n<p>So, if there is a TU where nothing is ord-used, then its dynamic initializations may not happen.</p>\n<h1>Example</h1>\n<h3>h1.h</h3>\n<pre><code>extern int count;\nstruct S\n{\n    S();\n};\n</code></pre>\n<h3>h1.cpp</h3>\n<pre><code>#include \"h1.h\"\n\nint count;\nS::S()\n{\n   ++count;\n}\n</code></pre>\n<h3>h2.cpp</h3>\n<pre><code>#include \"h1.h\"\nS s;\n</code></pre>\n<h3>main.cpp</h3>\n<pre><code>#include \"h1.h\"\n#include &lt;stdio.h&gt;\nint main()\n{\n    printf(\"%d\\n\", count);\n}\n</code></pre>\n<p>This could print 0 or 1: since anything in TU h2 is never odr-used, it is unspecified when the code initialization of <code>s</code> will be done, if at all.</p>\n<p>Naturally, sane compilers will initialize <code>s</code> before main, so it will surely print <code>1</code>:</p>\n<pre><code>$ g++ main.cpp h2.cpp h1.cpp -o test1\n$ ./test1\n1\n</code></pre>\n<p>Now, imagine that <code>h2.cpp</code> is in a shared library:</p>\n<pre><code>$ g++ -shared -fPIC h2.cpp -o h2.so\n</code></pre>\n<p>And the main file is now:</p>\n<h3>main2.cpp</h3>\n<pre><code>#include \"h1.h\"\n#include &lt;dlfcn.h&gt;\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"%d\\n\", count);\n    dlopen(\"./h2.so\", RTLD_NOW);\n    printf(\"%d\\n\", count);\n    return 0;\n}\n</code></pre>\n<p>Compile and run:</p>\n<pre><code>$ g++ -shared -fPIC h2.cpp -o h2.so\n$ g++ -rdynamic main.cpp h1.cpp -ldl -o test2\n$ ./test2\n0\n1\n</code></pre>\n<p>See? The initialization of <code>s</code> has been delayed! The nice part is that it is impossible to reference anything in the dynamic loaded library without first loading it, and loading it will trigger the dynamic initialization. So all is well.</p>\n<p>If you think that using <code>dlopen</code> is cheating, remember that there are compilers that support delay loading shared libraries (VC++ for example), where the system call to load the library will be generated automatically by the compiler just the first time it is needed.</p>\n", "LastActivityDate": "2013-09-03T21:08:32.737", "CommentCount": "3", "CreationDate": "2013-09-03T21:08:32.737", "ParentId": "18600034", "Score": "5", "OwnerUserId": "865874"}, "18600034": {"ViewCount": "637", "Body": "<p>I am trying to learn about initialization of static objects.  Static initialization seems pretty straight forward, assuming you understand constant expressions and <code>constexpr</code>.  Dynamic initialization seems quite a bit more tricky.</p>\n<p>[basic.start.init]/4</p>\n<blockquote>\n<p id=\"so_18600034_18600034_0\">It is implementation-de\ufb01ned whether the dynamic initialization of a non-local variable with static storage duration is done before the \ufb01rst statement of main. If the initialization is deferred to some point in time after the \ufb01rst statement of main, it shall occur before the \ufb01rst odr-use (3.2) of any function or variable de\ufb01ned in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>footnote 34</p>\n<blockquote>\n<p id=\"so_18600034_18600034_1\">A non-local variable with static storage duration having initialization with side-e\ufb00ects must be initialized even if it is not odr-used (3.2, 3.7.1).</p>\n</blockquote>\n<p>[basic.start.init]/5</p>\n<blockquote>\n<p id=\"so_18600034_18600034_2\">It is implementation-de\ufb01ned whether the dynamic initialization of a non-local variable with static or thread storage duration is done before the \ufb01rst statement of the initial function of the thread. If the initialization is deferred to some point in time after the \ufb01rst statement of the initial function of the thread, it shall occur before the \ufb01rst odr-use (3.2) of any variable with thread storage duration de\ufb01ned in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>I assume that \"the initial function of the thread\" refers to main, and not just threads started with std::thread.</p>\n<p>h1.h</p>\n<pre><code>#ifndef H1_H_\n#define H1_H_\n\nextern int count;\n\n#endif\n</code></pre>\n<p>tu1.cpp</p>\n<pre><code>#include \"h1.h\"\n\nstruct S\n{\n   S()\n   {\n      ++count;\n   }\n};\n\nS s;\n</code></pre>\n<p>tu2.cpp</p>\n<pre><code>#include \"h1.h\"\n\nint main(int argc, char *argv[])\n{\n   return count;\n}\n</code></pre>\n<p>tu3.cpp</p>\n<pre><code>#include \"h1.h\"\n\nint count;\n</code></pre>\n<p>So, if a compiler defers dynamic initialization, it seems that footnote 34 states that <code>s</code> must be initialized at some point.  Since there are no other variables with dynamic initialization in the translation unit, there is no other variable to odr-use to force initialization of the variables in tu1.  At what point is <code>s</code> guaranteed to have been initialized?</p>\n<p>Is main guaranteed to return 1?  Also, is there some way to change this program such that it is no longer guaranteed to return 1?  Alternatively, if it isn't guaranteed, is there some way to change this program such that it becomes guaranteed?</p>\n<hr>\n<p>I broke the code up so that the definition of <code>s</code> is in a different translation unit from <code>main</code>.  This avoids the question of whether <code>main</code> is odr used.  Given that <code>s</code> is the only object in the translation unit, is it guaranteed that <code>main</code> will return 1?</p>\n</hr>", "AcceptedAnswerId": "18601535", "Title": "Is static object guaranteed to be initialized", "CreationDate": "2013-09-03T19:30:16.933", "Id": "18600034", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-09-03T20:31:23.613", "LastEditorUserId": "2012007", "LastActivityDate": "2013-09-03T21:08:32.737", "Score": "12", "OwnerUserId": "2012007", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_18600034_18600034_0": {"length": 30, "quality": 0.8571428571428571, "section_id": 7153}, "so_18600034_18601535_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 7153}, "so_18600034_18600034_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 7153}, "so_18600034_18600034_2": {"length": 37, "quality": 0.8809523809523809, "section_id": 7154}}, "n3337": {"so_18600034_18600034_0": {"length": 30, "quality": 0.8571428571428571, "section_id": 6897}, "so_18600034_18601535_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 6897}, "so_18600034_18600034_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 6897}, "so_18600034_18600034_2": {"length": 37, "quality": 0.8809523809523809, "section_id": 6898}}, "n4659": {"so_18600034_18600034_0": {"length": 21, "quality": 0.6, "section_id": 8657}, "so_18600034_18601535_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 8657}, "so_18600034_18600034_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 8657}, "so_18600034_18600034_2": {"length": 26, "quality": 0.6190476190476191, "section_id": 8659}}}, "18600428": {"Id": "18600428", "PostTypeId": "2", "Body": "<p>\"the first odr-use of any function or variable de\ufb01ned in the same translation unit as the variable to be initialized\" includes the variable to be initialized.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2013-09-03T20:10:04.720", "Score": "0", "CreationDate": "2013-09-03T19:54:47.237", "ParentId": "18600034", "CommentCount": "8", "OwnerUserId": "103167", "LastEditDate": "2013-09-03T20:10:04.720"}, "18600426": {"Id": "18600426", "PostTypeId": "2", "Body": "<p>Without searching for the right pages in the definition I can say that your program is guaranteed to return 1. Every static or global initialization is done before the first command in the main. Global variables are initializes first an then the constructors of global objects are executed. Statics within a function/method scope a initialized before first use. But there is a trap:</p>\n<pre><code>int count;\n\nstruct A\n{\n   A()\n   {\n     count=5;\n   }\n};\n\nstruct B\n{\n   B()\n   {\n     count=count*2;\n   }\n};\n\n\nA a;\nB b;\n\nvoid main(void)\n{\n  return count;\n}\n</code></pre>\n<p>As mentioned in a commentary of Ben Voigt, the result is defined if both instances are create in the same translation unit. So in my sample, the result is 10. If the instances are create in different files (and compiled separately to different .obj files) the result is not defined.</p>\n", "LastEditorUserId": "1922748", "LastActivityDate": "2013-09-03T20:15:55.663", "Score": "3", "CreationDate": "2013-09-03T19:54:36.017", "ParentId": "18600034", "CommentCount": "6", "OwnerUserId": "1922748", "LastEditDate": "2013-09-03T20:15:55.663"}});