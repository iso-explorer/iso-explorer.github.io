post_cb({"bq_ids": {"n4140": {"so_31318762_31319260_1": {"length": 18, "quality": 1.0, "section_id": 5977}, "so_31318762_31319260_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5975}}, "n3337": {"so_31318762_31319260_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5743}, "so_31318762_31319260_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 5745}}, "n4659": {"so_31318762_31319260_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7475}, "so_31318762_31319260_1": {"length": 18, "quality": 1.0, "section_id": 7474}}}, "31319260": {"Id": "31319260", "PostTypeId": "2", "Body": "<p>It looks like unspecified behavior. The following paragraph from the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow\">C++14 draft standard: N3936</a> section <code>5.1.2</code> Lambda Expressions <em>[expr.prim.lambda]</em> makes me think this:</p>\n<blockquote>\n<p id=\"so_31318762_31319260_0\">An entity is captured by reference if it is implicitly or explicitly\n  captured but not captured by copy. It is unspecified whether\n  additional unnamed non-static data members are declared in the closure\n  type for entities captured by reference. [...]</p>\n</blockquote>\n<p>which different for entities captured by copy:</p>\n<blockquote>\n<p id=\"so_31318762_31319260_1\">Every id-expression within the compound-statement of a\n  lambda-expression that is an odr-use (3.2) of an entity captured by\n  copy is transformed into an access to the corresponding unnamed data\n  member of the closure type.</p>\n</blockquote>\n<p>Thanks to dyp for pointing out some relevant documents which I somehow missed. It looks like <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#750\" rel=\"nofollow\">defect report 750: Implementation constraints on reference-only closure objects</a> provides the rationale for the current wording, and it says:</p>\n<blockquote>\n<p id=\"so_31318762_31319260_2\">Consider an example like:</p>\n<pre><code>void f(vector&lt;double&gt; vec) {\n  double x, y, z;\n  fancy_algorithm(vec, [&amp;]() { /* use x, y, and z in various ways */ });\n}\n</code></pre>\n<p id=\"so_31318762_31319260_3\">5.1.2 [expr.prim.lambda] paragraph 8 requires that the closure class for this lambda will have three reference members, and paragraph 12\n  requires that it be derived from std::reference_closure, implying two\n  additional pointer members. Although 8.3.2 [dcl.ref] paragraph 4\n  allows a reference to be implemented without allocation of storage,\n  current ABIs require that references be implemented as pointers. The\n  practical effect of these requirements is that the closure object for\n  this lambda expression will contain five pointers. If not for these\n  requirements, however, it would be possible to implement the closure\n  object as a single pointer to the stack frame, generating data\n  accesses in the function-call operator as offsets relative to the\n  frame pointer. The current specification is too tightly constrained.</p>\n</blockquote>\n<p>which echos your exact points about allowing potential optimizations and was implemented as part of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf\" rel=\"nofollow\">N2927</a> which includes the following:</p>\n<blockquote>\n<p id=\"so_31318762_31319260_4\">The new wording no longer specifies any rewrite or closure members for \"by reference\" capture.\n  Uses of entities captured \"by reference\" affect the original entities, and the mechanism to\n  achieve this is left entirely to the implementation.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-10T11:44:12.480", "Score": "6", "CreationDate": "2015-07-09T13:39:44.287", "ParentId": "31318762", "CommentCount": "6", "OwnerUserId": "1708801", "LastEditDate": "2015-07-10T11:44:12.480"}, "31318762": {"ViewCount": "383", "Body": "<p>I recently needed a lambda that captured multiple local variables by reference, so I made a test snippet to investigate its efficiency, and compiled it with <code>-O3</code> using clang 3.6:</p>\n<pre><code>void do_something_with(void*);\n\nvoid test()\n{\n    int a = 0, b = 0, c = 0;\n\n    auto func = [&amp;] () {\n        a++;\n        b++;\n        c++;\n    };\n\n    do_something_with((void*)&amp;func);\n}\n</code></pre>\n<hr>\n<pre><code>movl   $0x0,0x24(%rsp)\nmovl   $0x0,0x20(%rsp)\nmovl   $0x0,0x1c(%rsp)\n\nlea    0x24(%rsp),%rax\nmov    %rax,(%rsp)\nlea    0x20(%rsp),%rax\nmov    %rax,0x8(%rsp)\nlea    0x1c(%rsp),%rax\nmov    %rax,0x10(%rsp)\n\nlea    (%rsp),%rdi\ncallq  ...\n</code></pre>\n<p>Clearly the lambda only needs the address of one of the variables, from which all the others could be obtained by relative addressing.</p>\n<p>Instead, the compiler created a struct on the stack containing pointers to <em>each</em> local variable, and then passed the address of the struct to the lambda. It's much in the same way as if I had written:</p>\n<pre><code>int a = 0, b = 0, c = 0;\n\nstruct X\n{\n    int *pa, *pb, *pc;\n};\n\nX x = {&amp;a, &amp;b, &amp;c};\n\nauto func = [p = &amp;x] () {\n    (*p-&gt;pa)++;\n    (*p-&gt;pb)++;\n    (*p-&gt;pc)++;\n};\n</code></pre>\n<p>This is inefficient for various reasons, but most worryingly because it could lead to heap-allocation if too many variables are captured.</p>\n<p>My questions:</p>\n<ol>\n<li><p>The fact that both clang and gcc do this at <code>-O3</code> makes me suspect that something in the standard actually forces closures to be implemented inefficiently. Is this the case?</p></li>\n<li><p>If so, then for what reasoning? It cannot be for binary compatibility of lambdas between compilers, because any code that knows about the type of the lambda is guaranteed to lie in the same translation unit.</p></li>\n<li><p>If not, then why is this optimisation missing from two major compilers?</p></li>\n</ol>\n<hr>\n<p>EDIT:<br>\nHere is an example of the more efficient code that I would like to have seen from the compiler. This code uses less stack space, the lambda now only performs one pointer indirection instead of two, and the lambda's size does not grow in the number of captured variables:</br></p>\n<pre><code>struct X\n{\n    int a = 0, b = 0, c = 0;\n} x;\n\nauto func = [&amp;x] () {\n    x.a++;\n    x.b++;\n    x.c++;\n};\n</code></pre>\n<hr>\n<pre><code>movl   $0x0,0x8(%rsp)\nmovl   $0x0,0xc(%rsp)\nmovl   $0x0,0x10(%rsp)\n\nlea    0x8(%rsp),%rax\nmov    %rax,(%rsp)\n\nlea    (%rsp),%rdi\ncallq  ...\n</code></pre>\n</hr></hr></hr>", "AcceptedAnswerId": "31319260", "Title": "Does the C++ standard force capture-by-reference of local variables to be inefficient?", "CreationDate": "2015-07-09T13:20:55.220", "LastActivityDate": "2015-07-10T11:44:12.480", "CommentCount": "16", "LastEditDate": "2015-07-10T10:48:42.227", "PostTypeId": "1", "Tags": "<c++><lambda><language-lawyer><compiler-optimization>", "Id": "31318762", "AnswerCount": "1", "Score": "11", "OwnerUserId": "5075760", "ClosedDate": "2015-07-09T14:23:53.040", "LastEditorUserId": "5075760"}});