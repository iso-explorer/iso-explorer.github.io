post_cb({"20830711": {"Id": "20830711", "PostTypeId": "2", "Body": "<p>While as a general principle I agree with the point of view that creating objects in well defined order is preferable, from thread safety perspective the implementation posted in the question is safer than constructing the singleton object within getInstance. In the latter case unless the programmer explicitly use atomic operations, the contructor can, in theory be invoked more than once. Following is dis-assembly using VS2013 (debug with no optimizations) for x86 target for this code.</p>\n<pre><code>singleton* singleton::getInstance() {\n    static singleton rc;\n    return &amp;rc;\n} \n\nstatic singleton* getInstance()\n{\n    00E85820  push        ebp  \n    00E85821  mov         ebp,esp  \n    00E85823  push        0FFFFFFFFh  \n    00E85825  push        0E89E6Eh  \n    00E8582A  mov         eax,dword ptr fs:[00000000h]  \n    00E85830  push        eax  \n    00E85831  sub         esp,0C0h  \n    00E85837  push        ebx  \n    00E85838  push        esi  \n    00E85839  push        edi  \n    00E8583A  lea         edi,[ebp-0CCh]  \n    00E85840  mov         ecx,30h  \n    00E85845  mov         eax,0CCCCCCCCh  \n    00E8584A  rep stos    dword ptr es:[edi]  \n    00E8584C  mov         eax,dword ptr ds:[00E8F000h]  \n    00E85851  xor         eax,ebp  \n    00E85853  push        eax  \n    00E85854  lea         eax,[ebp-0Ch]  \n    00E85857  mov         dword ptr fs:[00000000h],eax  \n    static singleton ref;\n    00E8585D  mov         eax,dword ptr ds:[00E8F330h]  \n    00E85862  and         eax,1  \n    00E85865  jne         singleton::getInstance+6Ch (0E8588Ch)  \n    00E85867  mov         eax,dword ptr ds:[00E8F330h]  \n    00E8586C  or          eax,1  \n    00E8586F  mov         dword ptr ds:[00E8F330h],eax  \n    00E85874  mov         dword ptr [ebp-4],0  \n    00E8587B  mov         ecx,0E8F32Ch  \n    00E85880  call        singleton::singleton (0E810D2h)  \n    00E85885  mov         dword ptr [ebp-4],0FFFFFFFFh  \n    return &amp;ref;\n    00E8588C  mov         eax,0E8F32Ch  \n}\n</code></pre>\n<p>dword ptr ds:[00E8F330h]   is used as flag to check whether to call constructor or not.</p>\n<p>As expected , no atomic compare and exchange instructions are emitted by the compiler. Therefore, if thread B executes instruction at 00E8585D before thread A executes instruction 00E8586F, the constructor will be invoked by both. However, to see this in practice, we would probably need to use special test cases where multiple threads are spawned (on a multicore processor) and blocked on an event/semaphore, . Then signal the semaphore to release all thread at once, and hopefully we will see the constructor will be called more than once. The same applies if you do a new singleton() inside getInstance.</p>\n<p>This issue is not specific to singletons.</p>\n", "LastActivityDate": "2013-12-29T22:18:42.277", "CommentCount": "2", "CreationDate": "2013-12-29T22:18:42.277", "ParentId": "20826018", "Score": "0", "OwnerUserId": "3134769"}, "20826018": {"ViewCount": "119", "Body": "<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nclass singleton\n{\n      private:\n      static singleton* ref;\n      singleton()\n      {\n                 cout&lt;&lt;\"singleton ctor\"&lt;&lt;endl;\n      }\n      public:\n      static singleton* getInstance()\n      {\n         return ref;\n      }\n};\n\nsingleton* singleton::ref=new singleton();\n\nint main()\n{\n\n    singleton* ref=singleton::getInstance()\n}\n</code></pre>\n", "Title": "Is the following singleton implementation thread safe?", "CreationDate": "2013-12-29T14:16:08.753", "LastActivityDate": "2013-12-30T15:50:57.507", "CommentCount": "4", "LastEditDate": "2013-12-29T14:16:43.667", "PostTypeId": "1", "LastEditorUserId": "150634", "Id": "20826018", "Score": "1", "OwnerUserId": "1242638", "Tags": "<c++><multithreading>", "AnswerCount": "3"}, "20826036": {"Id": "20826036", "PostTypeId": "2", "Body": "<p>If you mean by thread safe that different threads will get the correct (same) pointer by calling <code>singleton::getInstance</code>, than: yes, it is thread safe.</p>\n<p>And (as pointed out in the comment) you should create all you non trivial static variables in a well-defined order in the main function (or another function)!</p>\n<p>So write this:</p>\n<pre><code>singleton* singleton::ref = NULL;\n\nint main()\n{\n    singleton::ref = new singleton();\n    // create objects which use the singleton\n    singleton* ref = singleton::getInstance();\n    // create threads...\n\n}\n</code></pre>\n", "LastEditorUserId": "316448", "LastActivityDate": "2013-12-29T14:29:46.823", "Score": "-1", "CreationDate": "2013-12-29T14:17:53.793", "ParentId": "20826018", "CommentCount": "1", "OwnerUserId": "316448", "LastEditDate": "2013-12-29T14:29:46.823"}, "bq_ids": {"n4140": {"so_20826018_20826645_0": {"length": 13, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_20826018_20826645_0": {"length": 13, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_20826018_20826645_0": {"length": 13, "quality": 1.0, "section_id": 4805}}}, "20826645": {"Id": "20826645", "PostTypeId": "2", "Body": "<p>There are no threads in your example. Assuming there are more objects initialized during static initialization which may be spawning threads and access <code>singleton::ref</code>, the code is prone to access uninitialized memory and it isn't thread-safe. If the first thread is started after entering <code>main()</code> the code is thread-safe.</p>\n<p>In case you want to make sure the object is properly constructed upon first access and, at the same time, make the construction thread-safe even when accessed during static initialization from multiple threads, you'd use</p>\n<pre><code>singleton* singleton::getInstance() {\n    static singleton rc;\n    return &amp;rc;\n}\n</code></pre>\n<p>The relevant section in the standard which guarantees that the above is thread safe is 6.7 [stmt.dcl] paragraph 4:</p>\n<blockquote>\n<p id=\"so_20826018_20826645_0\">... If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization ...</p>\n</blockquote>\n<p>The object would be constructed the first time <code>getInstance()</code> is called. Even if multiple threads concurrently call <code>getInstance()</code> the object will be constructed only once and the concurrent calls to <code>getInstance()</code> will block until construction is complete. You can make sure that the construction of <code>getInstance()</code> happens during static initialization by using it in the implementation of <code>singleton</code>:</p>\n<pre><code>static singleton* constructionDummy = singleton::getInstance();\n</code></pre>\n<p>Note that singletons generally cause major problems, doubly so in multi-threaded programs. In addition to the problems singletons already create in single-threaded programs they further introduce the potential for data races and, in an attempt to address the data races, tend to introduce serialization. With the possible exception of singletons which set up strictly immutable data I recommend to <strong>not</strong> use them.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2013-12-30T15:50:57.507", "Score": "3", "CreationDate": "2013-12-29T15:19:47.223", "ParentId": "20826018", "CommentCount": "4", "OwnerUserId": "1120273", "LastEditDate": "2013-12-30T15:50:57.507"}});