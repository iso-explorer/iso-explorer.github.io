post_cb({"15702143": {"ViewCount": "588", "Body": "<p>In 14.8.2.4p10 of the C++11 draft, there is written</p>\n<blockquote>\n<p id=\"so_15702143_15702143_0\">If for each type being considered a given template is at least as specialized for all types and more specialized for some set of types and the other template is not more specialized for any types or is not at least as specialized for any types, then the given template is more specialized than the other template. </p>\n</blockquote>\n<p>Why is there a \"or is not at least as specialized for any types\"? As far as I can see, if we have a list of types</p>\n<pre><code>T1, T2, T3\nU1, U2, U3\n</code></pre>\n<p>And if all Ts are at least as specialized and some are more specialized. And none of the Us are more specialized, then it seems to me that it follows that the set of T as a whole is more specialized than the set of U, logically speaking. Why is there then that mentioned fallback for when none of the Us are at least as specialized than the corresponding Ts?</p>\n", "AcceptedAnswerId": "15710873", "Title": "When is a template more specialized than the other? 'And'/'Or' confusion with logics.", "CreationDate": "2013-03-29T11:15:03.610", "Id": "15702143", "CommentCount": "15", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-10-16T19:08:25.067", "Score": "13", "OwnerUserId": "34509", "Tags": "<c++><c++11><partial-ordering>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15702143_15710873_0": {"length": 9, "quality": 1.0, "section_id": 329}, "so_15702143_15706659_2": {"length": 11, "quality": 1.0, "section_id": 329}, "so_15702143_15706659_5": {"length": 11, "quality": 1.0, "section_id": 329}, "so_15702143_15706659_6": {"length": 5, "quality": 1.0, "section_id": 329}, "so_15702143_15706659_3": {"length": 5, "quality": 1.0, "section_id": 329}, "so_15702143_15702143_0": {"length": 30, "quality": 1.0, "section_id": 329}, "so_15702143_15710873_1": {"length": 8, "quality": 1.0, "section_id": 329}}, "n3337": {"so_15702143_15710873_0": {"length": 9, "quality": 1.0, "section_id": 319}, "so_15702143_15706659_2": {"length": 11, "quality": 1.0, "section_id": 319}, "so_15702143_15706659_5": {"length": 11, "quality": 1.0, "section_id": 319}, "so_15702143_15706659_6": {"length": 5, "quality": 1.0, "section_id": 319}, "so_15702143_15706659_3": {"length": 5, "quality": 1.0, "section_id": 319}, "so_15702143_15702143_0": {"length": 30, "quality": 1.0, "section_id": 319}, "so_15702143_15710873_1": {"length": 8, "quality": 1.0, "section_id": 319}}, "n4659": {"so_15702143_15710873_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 335}, "so_15702143_15706659_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 336}, "so_15702143_15706659_5": {"length": 6, "quality": 0.5454545454545454, "section_id": 336}, "so_15702143_15706659_6": {"length": 4, "quality": 0.8, "section_id": 165}, "so_15702143_15706659_3": {"length": 4, "quality": 0.8, "section_id": 165}, "so_15702143_15710873_1": {"length": 6, "quality": 0.75, "section_id": 147}}}, "15710873": {"Id": "15710873", "PostTypeId": "2", "Body": "<p>Update: This has now been added as an <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1705\" rel=\"nofollow\">official C++ Issue</a></p>\n<hr>\n<p>I have finally figured out how to read the paragraph in question. Below I have bulleted it</p>\n<blockquote>\n<p id=\"so_15702143_15710873_0\">If for each type being considered a given template is at least as specialized for all types, and</p>\n<ul>\n<li>more specialized for some set of types and the other template is not more specialized for any types, or </li>\n<li>{the other template} is not at least as specialized for any types, </li>\n</ul>\n<p id=\"so_15702143_15710873_1\">then the given template is more specialized than the other template.</p>\n</blockquote>\n<p>This way the following first template is also more specialized than the second template</p>\n<pre><code>template&lt;typename T&gt; void f(T*);\ntemplate&lt;typename T&gt; void f(T);\n</code></pre>\n<p>Note that the first template's parameter is at least as specialized as the second template, but is not defined to be \"more specialized\" - that term only applies for the case where both  parameters were references and certain conditions apply (see paragraph 9 of 14.8.2.4) . The rules are apparently <em>not</em> meant to follow any formal ordering laws. The second template is not at least as specialized  as the first template. This means that the second bullet applies, and not the first. </p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2013-10-16T19:08:25.067", "Score": "6", "CreationDate": "2013-03-29T20:24:08.557", "ParentId": "15702143", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2013-10-16T19:08:25.067"}, "15706659": {"Id": "15706659", "PostTypeId": "2", "Body": "<p><em>This answer is based on an incorrect parsing of the Standard paragraph's abstract syntax tree. The grouping of conditions assumed in the \"Back to the Standard\" section turned out not to be the intended one. The intended grouping is the one Johannes Schaub has shown in his answer.</em></p>\n<hr>\n<blockquote>\n<p id=\"so_15702143_15706659_0\">Why is there then that mentioned fallback for when none of the Us are at least as specialized than the corresponding Ts?</p>\n</blockquote>\n<p>I agree with you that the second part (actually, the whole second condition) is redundant.</p>\n<hr>\n<p><strong>Some vocabulary of reference:</strong></p>\n<p>Let's have some fun with logics and introduce 3 fundamental relations between two templates for a pair of corresponding parameters:</p>\n<ul>\n<li><em>More specialized than</em>: for parameters <code>Ti</code> and <code>Ui</code> respectively, one template matches the other but <strong>not</strong> vice versa. I will indicate this as <code>Ti &lt; Ui</code>;</li>\n<li><em>Equally specialized</em>: for parameters <code>Ti</code> and <code>Ui</code> respectively, one template matches the other <strong>and</strong> vice versa. I will indicate this as <code>Ti == Ui</code>;</li>\n<li><em>Specialization-incomparable</em>: for parameters <code>Ti</code> and <code>Ui</code> respectively, <strong>none</strong> of the templates matches the other for the particular parameter. I will indicate this as <code>T1 ~ U1</code>.</li>\n</ul>\n<p>For instance, in the code snippet below:</p>\n<pre><code>template&lt;typename X&gt; struct A { };\ntemplate&lt;typename X&gt; struct B { };\n\ntemplate&lt;typename X&gt; void foo(A&lt;X&gt;, X, A&lt;X&gt;) { } // 1\ntemplate&lt;typename X&gt; void foo(X,    X, B&lt;X&gt;) { } // 2\n</code></pre>\n<p>For the first parameter, (1) is more specialized than (<code>&lt;</code>) (2); for the second parameter, (1) is equally specialized as (or \"<em>as specialized as</em>\", <code>==</code>) (2); for the third parameter, (1) is specialization-incomparable to (<code>~</code>) (2).</p>\n<p>And let' now define a derived relation:</p>\n<ul>\n<li>A template (1) is <em>at least as specialized as</em> another template (2) for respective parameters <code>Ti</code> and <code>Ui</code> when <code>(Ti &lt; Ui)</code> or <code>(Ti == Ui)</code>, i.e. when either (1) is more specialized than (2) or (1) is as specialized as (2). In the above example, therefore, <code>T1 &lt;= U1</code>, <code>T2 &lt;= U2</code>, and <code>U2 &lt;= T2</code>.</li>\n</ul>\n<hr>\n<p><strong>Back to the Standard:</strong></p>\n<p>With the help of a couple of parentheses, the quote above becomes (A &amp;&amp; (B1 || B2)):</p>\n<blockquote>\n<p id=\"so_15702143_15706659_1\">[...] for each type being considered:</p>\n<p id=\"so_15702143_15706659_2\"><strong>(</strong> a given template is at least as specialized for all types and\n  more specialized for some set of types <strong>)</strong> </p>\n<pre><code>                                 AND \n</code></pre>\n<p id=\"so_15702143_15706659_3\"><strong>(</strong> the other template is not more specialized for any types</p>\n<pre><code>                                 OR\n</code></pre>\n<p id=\"so_15702143_15706659_4\">is not at least as specialized for any types <strong>)</strong></p>\n</blockquote>\n<p>Given two templates to be ordered with respect to the corresponding sequences of parameter types <code>T1, ..., Tn</code> and <code>U1, ..., Un</code>, the condition (A):</p>\n<blockquote>\n<p id=\"so_15702143_15706659_5\">[...] a given template is <em>at least as specialized</em> for all types and more specialized for some set of types [...]</p>\n</blockquote>\n<p>Means that for each <code>i = 1..n</code>, <code>Ti &lt;= Ui</code>, and for some <code>j</code>s in <code>1..n</code>, it applies the stricter condition that <code>Tj &lt; Uj</code>. Dropping the index <code>i</code>, this means that for each parameter:</p>\n<pre><code>(T &lt; U) || (T == U) // (A)\n</code></pre>\n<p>This condition is put in logical conjunction (\"and\") with another condition (B), which is in turn the logical disjunction (\"or\") of two sub-conditions, (B1) and (B2). Let's start examining sub-condition (B1):</p>\n<blockquote>\n<p id=\"so_15702143_15706659_6\">[...] the other template is not more specialized for any types [...]</p>\n</blockquote>\n<p>This means that for any <code>i</code>, it is never the case that <code>Ui &lt; Ti</code>, which means that either:</p>\n<ul>\n<li><code>Ti</code> is more specialized than <code>Ui</code> (<code>Ti &lt; Ui</code>); or</li>\n<li><code>Ti</code> and <code>Ui</code> are equally specialized (<code>Ui == Ti</code>); or</li>\n<li><code>Ti</code> and <code>Ui</code> are specialization-incomparable (<code>Ui ~ Ti</code>):</li>\n</ul>\n<p>More formally:</p>\n<pre><code>!(U &lt; T) &lt;==&gt; (T &lt; U) || (T == U) || (T ~ U) // (B1)\n</code></pre>\n<p>Now let's see the second sub-condition (B2), which is put in logical disjunction with (B1):</p>\n<blockquote>\n<p id=\"so_15702143_15706659_7\">[...] is not at least as specialized for any types [...]</p>\n</blockquote>\n<p>This is the negation of <code>U &lt;= T</code>, which means:</p>\n<pre><code>!(U &lt;= T) &lt;==&gt; !((U == T) || (U &lt; T)) ==&gt; !(U == T) &amp;&amp; !(U &lt; T)\n</code></pre>\n<p>So in other words, <code>T</code> and <code>U</code> are not equally-specialized, nor <code>U</code> is more specialized than <code>T</code>. Therefore, the only possibilities left are that:</p>\n<pre><code>(T &lt; U) || (T ~ U) // (B2)\n</code></pre>\n<p>Now it is evident that (B2) implies (B1), because (B2) is more restrictive. Therefore, their disjunct (B) will be coincident with (B1), and (B2) is redundant:</p>\n<pre><code>(T &lt; U) || (T ~ U) || (T == U) // (B)\n</code></pre>\n<p>But what is also evident here is that (A) is stricter than (B), so the conjunction of (A) and (B) is equivalent to (A). </p>\n<hr>\n<p><strong>Conclusion:</strong></p>\n<p>The whole condition (B) is redundant.</p>\n</hr></hr></hr></hr>", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-29T20:37:09.063", "Score": "5", "CreationDate": "2013-03-29T15:51:52.660", "ParentId": "15702143", "CommentCount": "19", "OwnerUserId": "1932150", "LastEditDate": "2013-03-29T20:37:09.063"}});