post_cb({"22479641": {"CommentCount": "0", "CreationDate": "2014-03-18T12:37:01.440", "PostTypeId": "1", "AcceptedAnswerId": "22481091", "LastEditorUserId": "1132850", "LastActivityDate": "2014-03-18T14:28:43.190", "LastEditDate": "2014-03-18T14:28:43.190", "ViewCount": "406", "FavoriteCount": "1", "Title": "Intel C++ compiler (icpc 14.0): \"a derived class is not allowed here\"", "Id": "22479641", "Score": "7", "Body": "<p>I'm using ICC 14.0.2 on Linux. This code snippet compiles with GCC and CLang, but not ICC:</p>\n<pre><code>template&lt;int N, bool B&gt;\nstruct A;\n\ntemplate&lt;int N&gt;\nstruct A&lt;N,false&gt;\n{\n  template&lt;int M&gt;\n  struct Nested {};\n};\n\ntemplate&lt;int N&gt;\nstruct A&lt;N,true&gt; : public A&lt;N,false&gt; {};\n\ntemplate struct A&lt;1,true&gt;::Nested&lt;2&gt;;    // explicit instantiation\n</code></pre>\n<p>Trying to compile this with the three compilers:</p>\n<pre><code>$ g++ -c -std=c++11 testcase.cc\n$ clang++ -c -std=c++11 testcase.cc\n$ icpc -c -std=c++11 testcase.cc\ntestcase.cc(17): error: invalid qualifier for \"A&lt;1, false&gt;::Nested&lt;2&gt;\" (a derived class is not allowed here)\n  template struct A&lt;1,true&gt;::Nested&lt;2&gt;;\n                             ^\n\ncompilation aborted for testcase.cc (code 2)\n</code></pre>\n<p>I couldn't find any useful information about this error message.</p>\n<p>In my case, the explicit instantiation (of more complicated classes) is part of a unit test, and I can work around the problem by instantiating an object instead, which ICC happily compiles:</p>\n<pre><code>void foo()\n{\n  A&lt;1,true&gt;::Nested&lt;2&gt;();\n}\n</code></pre>\n<p>Still I would like to now if ICC is right with its error or whether this is a compiler bug.</p>\n<p>Thanks for your time!</p>\n<p><strong>Update</strong>\nThank you Filip for the detailed analysis. <a href=\"http://software.intel.com/en-us/forums/topic/507581\" rel=\"nofollow\">I reported</a> the issue to the Intel developers. Indeed the partial specialization has nothing to do with the problem (as I initially suspected), so even this simpler snippet reproduces the problem:</p>\n<pre><code>template&lt;int N&gt;\nstruct A\n{\n  template&lt;int M&gt;\n  struct Nested {};\n};\n\ntemplate&lt;int N&gt;\nstruct B : public A&lt;N&gt; {};\n\ntemplate struct B&lt;1&gt;::Nested&lt;2&gt;;\n</code></pre>\n", "Tags": "<c++><compiler-errors><language-lawyer><icc>", "OwnerUserId": "1132850", "AnswerCount": "1"}, "22481091": {"ParentId": "22479641", "CommentCount": "2", "Body": "<p><sup> <strong>Note:</strong> <code>gcc</code> and <code>clang</code> are showing the correct behavior...</sup></p>\n<hr>\n<p><strong>THE BUG IS IN <code>icc</code>!</strong></p>\n<p>The snippet accepted by both <em>gcc</em> and <em>clang</em> is legal and should not trigger a diagnostic.</p>\n<hr>\n<p>The author responsible for the code inside <code>icc</code> that issues the provided diagnostic did probably trip over the below snippet, taken from the Standard, which says that names in a <code>Base</code> that depends on a <em>template-parameter</em> should not be available inside the definition of the <code>Derived</code> class.</p>\n<blockquote>\n<p id=\"so_22479641_22481091_0\">14.6.2 <strong>Dependent Names</strong> <code>[temp.dep]</code></p>\n<blockquote>\n<p id=\"so_22479641_22481091_2\"><sup>3</sup> <strong>In the definition of a class or class template, if a base class depends on a\n    <em>template-parameter</em>, the base class scope is not examined</strong> during\n    unqualified name lookup either at the point of definition of the class\n    template or member or during an instantiation of the class template or\n    member. </p>\n</blockquote>\n</blockquote>\n<hr>\n<p>As stated it is important to note that <code>[temp.dep]p3</code> says that the <em>base class scope is not examined in the <strong>definition</strong> of a class</em>, it doesn't say that such names are not inherited when being accessed from the outside.</p>\n<p>Your \"work around\" shows that the name (in this case <code>template&lt;int&gt; struct Nested</code>) is indeed (correctly) inherited and available inside <code>A&lt;1, true&gt;</code>, but <code>icc</code> seems to confuse <em>explicit instantiation</em> with the rules of names inside the <em>definition of the class</em>.</p>\n</hr></hr></hr>", "OwnerUserId": "1090079", "PostTypeId": "2", "Id": "22481091", "Score": "7", "CreationDate": "2014-03-18T13:36:53.823", "LastActivityDate": "2014-03-18T13:36:53.823"}, "bq_ids": {"n4140": {"so_22479641_22481091_2": {"section_id": 190, "quality": 1.0, "length": 27}, "so_22479641_22481091_1": {"section_id": 190, "quality": 1.0, "length": 27}}, "n3337": {"so_22479641_22481091_2": {"section_id": 184, "quality": 1.0, "length": 27}, "so_22479641_22481091_1": {"section_id": 184, "quality": 1.0, "length": 27}}, "n4659": {"so_22479641_22481091_2": {"section_id": 195, "quality": 0.8148148148148148, "length": 22}, "so_22479641_22481091_1": {"section_id": 195, "quality": 0.8148148148148148, "length": 22}}}});