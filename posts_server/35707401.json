post_cb({"35707401": {"ViewCount": "119", "Body": "<p>The C standard 6.5.3.2 Address and indirection operators (3) says:</p>\n<blockquote>\n<p id=\"so_35707401_35707401_0\">\"The unary &amp; operator returns the address of its operand. If the operand has type \u2018\u2018type\u2019\u2019, the result has type \u2018\u2018pointer to type\u2019\u2019. If the operand is the result of a unary * operator, neither that operator nor the &amp; operator is evaluated and the result is as if both were omitted, except that the constraints on the operators still apply and the result is not an lvalue.\"</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_35707401_35707401_1\">\"83) Thus, &amp;*E is equivalent to E (even if E is a null pointer), and &amp;(E1[E2]) to ((E1)+(E2)). It is always true that if E is a function designator or an lvalue that is a valid operand of the unary &amp; operator, *&amp;E is a function designator or an lvalue equal to E. If *P is an lvalue and T is the name of an object pointer type, *(T)P is an lvalue that has a type compatible with that to which T points.\"</p>\n</blockquote>\n<p>So if I understand well, <code>&amp;*E</code> is behave as if we would delete <code>&amp;*</code>. However,</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;typeinfo&gt;\n\nint main()\n{\n    float A[2];\n    printf( \"name: %s\\n\", typeid( &amp;*A ).name());\n    printf( \"name: %s\\n\", typeid( A ).name());\n    getchar();\n    return 0;\n}\n</code></pre>\n<p>will give:</p>\n<pre><code>name: Pf\nname: A2_f\n</code></pre>\n<p>So they aren't the same.</p>\n<p>What is wrong? What is I'm misunderstanding? I would appreciate your help,\nThanks.</p>\n</hr>", "AcceptedAnswerId": "35707480", "Title": "C++: &*A is not equivalent to A for array declaration?", "CreationDate": "2016-02-29T18:59:39.557", "Id": "35707401", "CommentCount": "7", "LastEditDate": "2016-02-29T19:09:11.650", "PostTypeId": "1", "LastEditorUserId": "1413395", "LastActivityDate": "2016-02-29T19:15:30.737", "Score": "2", "OwnerUserId": "2148758", "Tags": "<c++><arrays><dereference>", "AnswerCount": "3"}, "35707581": {"Id": "35707581", "PostTypeId": "2", "Body": "<p>In case of <a href=\"http://en.cppreference.com/w/cpp/language/typeid\" rel=\"nofollow\"><code>typeid</code></a> </p>\n<blockquote>\n<p id=\"so_35707401_35707581_0\">Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed.  </p>\n</blockquote>\n<p>So, <code>&amp;*A</code> and <code>A</code> are not same in this case. <code>A</code> will not decay to pointer to its first element in <code>typeid( A ).name()</code>.  </p>\n<p>The same behavior can be seen with <code>sizeof</code> operator  </p>\n<pre><code>int main()\n{\n    float A[10];\n    printf( \"name: %zu\\n\", sizeof( &amp;*A )); // &amp;*A --&gt; float * type\n    printf( \"name: %zu\\n\", sizeof( A ));   // A   --&gt; float[10] type\n    getchar();\n    return 0;\n}\n</code></pre>\n<p>Output:  </p>\n<pre><code>name: 8\nname: 40\n</code></pre>\n", "LastEditorUserId": "2455888", "LastActivityDate": "2016-02-29T19:15:30.737", "Score": "4", "CreationDate": "2016-02-29T19:10:04.570", "ParentId": "35707401", "CommentCount": "0", "OwnerUserId": "2455888", "LastEditDate": "2016-02-29T19:15:30.737"}, "35707480": {"Id": "35707480", "PostTypeId": "2", "Body": "<p>These aren't the same.</p>\n<p>The <code>&amp;*A</code> gives you the address of the 1st element in the <code>A</code> array as a decayed pointer <code>float*</code>, and <code>A</code> is a particular array type as declared with <code>float A[2]</code>.</p>\n", "LastEditorUserId": "1413395", "LastActivityDate": "2016-02-29T19:10:52.373", "Score": "9", "CreationDate": "2016-02-29T19:03:57.473", "ParentId": "35707401", "CommentCount": "1", "OwnerUserId": "1413395", "LastEditDate": "2016-02-29T19:10:52.373"}, "35707598": {"Id": "35707598", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/35707480/2069064\">\u03c0\u03ac\u03bd\u03c4\u03b1 \u1fe5\u03b5\u1fd6's</a> answer explains why <code>&amp;*A</code> and <code>A</code> are different for the simple case when <code>A</code> is an array.</p>\n<p>But more generally, since C++ allows overloading of <code>operator*</code> and <code>operator&amp;</code>, the two could be widely different. For a smart pointer like <code>std::unique_ptr&lt;int&gt; p</code>, <code>&amp;*p</code> is an <code>int*</code>, which isn't even close to the same type as <code>p</code>. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-29T19:11:12.850", "Score": "5", "CreationDate": "2016-02-29T19:11:12.850", "ParentId": "35707401", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T10:34:01.443"}, "bq_ids": {"n4140": {"so_35707401_35707581_0": {"length": 5, "quality": 1.0, "section_id": 6172}}, "n3337": {"so_35707401_35707581_0": {"length": 5, "quality": 1.0, "section_id": 5933}}, "n4659": {"so_35707401_35707581_0": {"length": 5, "quality": 1.0, "section_id": 7670}}}});