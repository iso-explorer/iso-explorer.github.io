post_cb({"9304917": {"ParentId": "9304894", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-02-16T02:59:06.940", "Score": "11", "LastEditorUserId": "148870", "LastEditDate": "2012-02-16T18:20:04.450", "Id": "9304917", "OwnerUserId": "148870", "Body": "<p><code>reserve()</code> just makes sure that the vector's allocated memory is <em>at least</em> large enough to contain the number of items passed as its argument. Thus...</p>\n<ol>\n<li>Whichever the max value of all those passed will be the minimum resulting capacity effectively reserved.</li>\n<li>See #1.</li>\n<li>Yes.</li>\n<li>The vector allocates as much memory when <code>reserve()</code> is called as is necessary to store the number of items passed to <code>reserve()</code>.</li>\n</ol>\n<hr>\n<p>To quote from the actual standard:</p>\n<pre><code>void reserve(size_type n)\n</code></pre>\n<blockquote>\n<p id=\"so_9304894_9304917_0\">If <code>n</code> is less than or equal to <code>capacity()</code>, this call has no effect.\n  Otherwise, it is a request for allocation of additional memory. If the\n  request is successful, then <code>capacity()</code> is greater than or equal to <code>n</code>;\n  otherwise, <code>capacity()</code> is unchanged. In either case, <code>size()</code> is\n  unchanged.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2012-02-16T18:20:04.450"}, "bq_ids": {"n4140": {"so_9304894_9304933_5": {"section_id": 969, "quality": 0.9714285714285714, "length": 34}, "so_9304894_9304933_6": {"section_id": 970, "quality": 0.9090909090909091, "length": 10}, "so_9304894_9304933_8": {"section_id": 972, "quality": 0.75, "length": 27}}, "n3337": {"so_9304894_9304933_5": {"section_id": 958, "quality": 0.9714285714285714, "length": 34}, "so_9304894_9304933_6": {"section_id": 959, "quality": 0.9090909090909091, "length": 10}, "so_9304894_9304933_8": {"section_id": 961, "quality": 0.8055555555555556, "length": 29}}, "n4659": {"so_9304894_9304933_5": {"section_id": 1031, "quality": 0.9714285714285714, "length": 34}, "so_9304894_9304933_6": {"section_id": 1032, "quality": 0.9090909090909091, "length": 10}, "so_9304894_9304933_8": {"section_id": 1034, "quality": 0.75, "length": 27}}}, "9304933": {"ParentId": "9304894", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-02-16T03:01:08.363", "Score": "3", "LastEditorUserId": "452307", "LastEditDate": "2012-02-16T03:20:39.313", "Id": "9304933", "OwnerUserId": "452307", "Body": "<blockquote>\n<p id=\"so_9304894_9304933_0\">Suppose <code>reserve(N)</code> is called multiple times one after another immediately. Will the earlier <code>reserve(N1)</code> get added up or overwritten ?</p>\n</blockquote>\n<p>Unlike <code>std::string</code> it is not possible to call <code>reserve()</code> for <code>std::vector</code> to shrink the <code>capacity()</code>.Calling <code>reserve()</code> with an argument that is less than the current <code>capacity()</code> is a no-op. Hence the last <code>reserve()</code> call which increases the current capacity will hold good.</p>\n<blockquote>\n<p id=\"so_9304894_9304933_1\">If the earlier <code>reserve(N1)</code> gets overwritten with the latest call, then what happens if the latest <code>reserve(Nn)</code> demands less number of slots ?</p>\n</blockquote>\n<p>Calling <code>reserve()</code> with an argument that is less than the current <code>capacity()</code> is a no-op.</p>\n<blockquote>\n<p id=\"so_9304894_9304933_2\">After declaring vector if we have simply push_back() X elements, and then we call reserve(N). Will the already push_back() X elements counted in N ?    </p>\n</blockquote>\n<p><code>reserve()</code> just allocates(reserves) enough number of elements so Yes. Note that after calling <code>reserve()</code> only the <code>capacity()</code> of the vector is changed the <code>size()</code> remains unaffected.If you would need to create as many elements and not just reserve memory you should be using <code>resize()</code>.</p>\n<blockquote>\n<p id=\"so_9304894_9304933_3\">Suppose, if the vector has some <code>X</code> pushed elements and now if we <code>push_back()</code> 1 more element <code>(X+1)</code>, then that object would have to get relocated; but we haven't yet performed <code>push_back()</code>. What happens if we call <code>reserve()</code> now ? Will the object get relocated immediately ? If not, then how is the space reserved ?     </p>\n</blockquote>\n<p>Yes, the relocation will happen but it depends. As said before, <code>reserve()</code> allocates enough memory to store as many elements as the argument passed to it. So if this number of elements is greater than what can be accommodated in current vector <code>capacity()</code>, relocation will happen.</p>\n<p>Standard References:<br>\n<strong>C++03 23.2.4.2 vector capacity [lib.vector.capacity]</strong> </br></p>\n<blockquote>\n<p id=\"so_9304894_9304933_4\"><code>void reserve(size_type n);</code></p>\n<p id=\"so_9304894_9304933_5\"><strong>Effects:</strong> A directive that informs a vector of a planned change in size, so that it can manage the storage allocation accordingly. After <code>reserve()</code>, <code>capacity()</code> is greater or equal to the argument of reserve if reallocation happens; and equal to the previous value of <code>capacity()</code> otherwise. Reallocation happens at this point if and only if the current capacity is less than the argument of <code>reserve()</code>.</p>\n<p id=\"so_9304894_9304933_6\"><strong>Complexity:</strong> It does not change the size of the sequence and takes at most linear time in the size of the sequence.</p>\n<p id=\"so_9304894_9304933_7\"><strong>Throws:</strong> length_error if <code>n &gt; max_size()</code>.248)</p>\n<p id=\"so_9304894_9304933_8\"><strong>Notes:</strong> Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. It is guaranteed that no reallocation takes place during insertions that happen after a call to <code>reserve()</code> until the time when an insertion would make the size of the vector greater than the size specified in the most recent call to <code>reserve()</code>.</p>\n</blockquote>\n", "LastActivityDate": "2012-02-16T03:20:39.313"}, "9304894": {"CommentCount": "1", "ViewCount": "1461", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2012-02-16T02:55:55.030", "LastActivityDate": "2015-07-03T17:22:06.593", "Title": "Behavior of vector's reserve( ) method ", "AcceptedAnswerId": "9304917", "LastEditDate": "2015-07-03T17:22:06.593", "Id": "9304894", "Score": "5", "Body": "<p>I wanted to know the behavior of <code>std::vector::reserve()</code> in following situations:</p>\n<ol>\n<li>Suppose <code>reserve(N)</code> is called multiple times one after another immediately.\nWill the earlier <code>reserve(N1)</code> get added up or overwritten ?</li>\n<li>If the earlier <code>reserve(N1)</code> gets overwritten with the latest call,\nthen what happens if the latest <code>reserve(Nn)</code> demands less number of slots ?</li>\n<li>After declaring <code>vector</code> if we have simply <code>push_back()</code> X elements,\nand then we call <code>reserve(N)</code>. Will the already <code>push_back()</code> X\nelements counted in <code>N</code> ?</li>\n<li>Suppose, if the <code>vector</code> has some X pushed elements and now if we\n<code>push_back()</code> 1 more element (X+1), then that object would have to\nget relocated; but we haven't yet performed <code>push_back()</code>. What\nhappens if we call <code>reserve()</code> now ? Will the object get relocated\nimmediately ? If not, then how is the space reserved ?</li>\n</ol>\n", "Tags": "<c++><methods><stdvector>", "OwnerUserId": "514235", "AnswerCount": "2"}});