post_cb({"bq_ids": {"n4140": {"so_46309228_46311003_1": {"length": 22, "quality": 0.5945945945945946, "section_id": 147}, "so_46309228_46311003_0": {"length": 5, "quality": 0.625, "section_id": 94}, "so_46309228_46311003_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 327}}, "n3337": {"so_46309228_46311003_1": {"length": 22, "quality": 0.5945945945945946, "section_id": 141}, "so_46309228_46311003_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 317}, "so_46309228_46311003_0": {"length": 5, "quality": 0.625, "section_id": 89}}, "n4659": {"so_46309228_46311003_1": {"length": 36, "quality": 0.972972972972973, "section_id": 98}, "so_46309228_46311003_2": {"length": 7, "quality": 1.0, "section_id": 98}, "so_46309228_46311003_0": {"length": 8, "quality": 1.0, "section_id": 97}}}, "46309228": {"ViewCount": "234", "Body": "<p>Consider a simple example:</p>\n<pre><code>int x;\n\ntemplate &lt;template &lt;auto&gt; class TT&gt;\nstruct Foo {\n   void foo() {\n      TT&lt;(x)&gt; tt;\n      static_cast&lt;void&gt;(tt);\n   }\n};\n\ntemplate &lt;decltype(auto)&gt;\nstruct Bar { };\n\n\nint main() {\n    Foo&lt;Bar&gt; foobar;\n    foobar.foo();\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/8ONvvMTCTqW7Aenm\" rel=\"noreferrer\">[clang]</a> seems to deal with the idea of <code>decltype(auto)</code> placeholder despite the use of <code>auto</code> in template template parameter declaration without a problem. </p>\n<p><a href=\"https://wandbox.org/permlink/7THzOxieKVDoi1Gk\" rel=\"noreferrer\">[gcc]</a> on the other hand - not very well:</p>\n<blockquote>\n<p id=\"so_46309228_46309228_0\">prog.cc:6:13: error: the value of 'x' is not usable in a constant expression</p>\n</blockquote>\n<hr>\n<p>As usually - which behaviour is expected according to standard? Or maybe everything is possible and the code is ill-formed (this time I suppose not but cannot rule it out definitively)?</p>\n<p>PS. Sorry for breaking one of the compilers again ;)</p>\n</hr>", "AcceptedAnswerId": "46311003", "Title": "Are placeholders types of non-type template parameters interchangeable in case of template template parameter", "CreationDate": "2017-09-19T20:25:28.200", "Id": "46309228", "CommentCount": "14", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-09-19T20:30:12.537", "LastEditorUserId": "4324224", "LastActivityDate": "2017-09-20T14:01:41.153", "Score": "18", "OwnerUserId": "4324224", "Tags": "<c++><templates><language-lawyer><c++1z>", "AnswerCount": "1"}, "46311003": {"Id": "46311003", "PostTypeId": "2", "Body": "<p>The original answer here had <code>Foo&lt;Bar&gt;</code> ill-formed, I actually now think it's well-formed. But ultimately, clang bug based.</p>\n<hr/>\n<p><s>I actually think even <code>Foo&lt;Bar&gt;</code> is ill-formed.</s> The new rules, following <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html\" rel=\"nofollow noreferrer\">P0522</a> are that:</p>\n<blockquote>\n<p id=\"so_46309228_46311003_0\">A <em>template-argument</em> matches a template <em>template-parameter</em> <code>P</code> when <code>P</code> is at least as specialized as the <em>template-argument</em> <code>A</code></p>\n</blockquote>\n<p>where:</p>\n<blockquote>\n<p id=\"so_46309228_46311003_1\">A template <em>template-parameter</em> <code>P</code> is at least as specialized as a template <em>template-argument</em> <code>A</code> if, given the following rewrite to two function templates, the function template corresponding to <code>P</code> is at least as specialized as the function template corresponding to <code>A</code> according to the partial ordering rules for function templates ([temp.func.order]). Given an invented class template <code>X</code> with the template parameter list of <code>A</code> (including default arguments):</p>\n<ul>\n<li>Each of the two function templates has the same template parameters, respectively, as <code>P</code> or <code>A</code>.</li>\n<li>Each function template has a single function parameter whose type is a specialization of <code>X</code> with template arguments corresponding to the template parameters from the respective function template where, for each template parameter <code>PP</code> in the template parameter list of the function template, a corresponding template argument <code>AA</code> is formed. If <code>PP</code> declares a parameter pack, then <code>AA</code> is the pack expansion <code>PP...</code> ([temp.variadic]); otherwise, <code>AA</code> is the <em>id-expression</em> <code>PP</code>.</li>\n</ul>\n<p id=\"so_46309228_46311003_2\">If the rewrite produces an invalid type, then <code>P</code> is not at least as specialized as <code>A</code>.</p>\n</blockquote>\n<p>Which means that to verify if <code>Foo&lt;Bar&gt;</code> itself is okay, we synthesize:</p>\n<pre><code>template &lt;decltype(auto) I&gt; struct X;\n\ntemplate &lt;auto I&gt;           void __f(X&lt;I&gt; ); // P\ntemplate &lt;decltype(auto) I&gt; void __f(X&lt;I&gt; ); // A\n</code></pre>\n<p>All the types here are valid (so the last statement doesn't apply). Now, typically when we do partial ordering it's in the context of either overload resolution or picking a class template specialization, in which case what we're looking for is the <a href=\"http://eel.is/c++draft/over#match.best-1.7\" rel=\"nofollow noreferrer\">\"more specialized\"</a> function template, where <code>F</code> is <a href=\"http://eel.is/c++draft/temp.deduct.partial#10\" rel=\"nofollow noreferrer\">more specialized than</a> <code>G</code> if <code>F</code> is at least as specialized as <code>G</code> and <code>G</code> is not at least as specialized as <code>F</code>. </p>\n<p>But in this context, we don't care about which is more specialized. We only need <code>P</code> to be at least as specialized as <code>A</code>. All that means that deduction has to succeed from <code>A</code> to <code>P</code>. So if we synthesize some unique type <code>U</code> with some value <code>V</code>, can we deduce <code>X&lt;I&gt;</code> from <code>X&lt;V&gt;</code>? Yes. Hence, <code>P</code> is at least as specialized as <code>A</code>, so the template-argument <code>Bar</code> matches the template-parameter <code>TT</code>. </p>\n<hr/>\n<p>Now, passing that point, I'd say this a clang bug. The template <em>template-parameter</em> is <code>template &lt;auto&gt;</code>, which is what we should use to validate the expression. With a non-type template parameter <code>auto</code>, we'd try to use <code>x</code> as a value - but <code>x</code> isn't a valid constant expression, so this should fail. clang appears to be using <code>template &lt;decltype(auto) &gt;</code> directly - which I'm not sure is valid.</p>\n<p>That said, I'm not sure this case has even been considered - I don't see any wording one way or the other and it's worth raising an issue.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-09-20T14:01:41.153", "Score": "7", "CreationDate": "2017-09-19T23:12:34.877", "ParentId": "46309228", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2017-09-20T14:01:41.153"}});