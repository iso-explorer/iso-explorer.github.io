post_cb({"11069605": {"CommentCount": "8", "AcceptedAnswerId": "11073450", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2012-06-17T07:20:07.927", "LastActivityDate": "2017-09-18T01:48:24.183", "LastEditDate": "2012-06-18T04:31:08.067", "ViewCount": "1638", "FavoriteCount": "6", "Title": "initializing a non-copyable member (or other object) in-place from a factory function", "Id": "11069605", "Score": "21", "Body": "<p>A class must have a valid copy or move constructor for any of this syntax to be legal:</p>\n<pre><code>C x = factory();\nC y( factory() );\nC z{ factory() };\n</code></pre>\n<p>In C++03 it was fairly common to rely on copy elision to prevent the compiler from touching the copy constructor. Every class has a valid copy constructor <em>signature</em> regardless of whether a definition exists.</p>\n<p>In C++11 a non-copyable type should define <code>C( C const &amp; ) = delete;</code>, rendering any reference to the function invalid regardless of use (same for non-moveable). (C++11 \u00a78.4.3/2). GCC, for one, will complain when trying to return such an object by value. Copy elision ceases to help. </p>\n<p>Fortunately, we also have new syntax to express intent instead of relying on a loophole. The <code>factory</code> function can return a <em>braced-init-list</em> to construct the result temporary in-place:</p>\n<pre><code>C factory() {\n    return { arg1, 2, \"arg3\" }; // calls C::C( whatever ), no copy\n}\n</code></pre>\n<hr>\n<p><strong>Edit:</strong> If there's any doubt, this <code>return</code> statement is parsed as follows:</p>\n<ol>\n<li>6.6.3/2: \"A return statement with a braced-init-list initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.\"</li>\n<li>8.5.4/1: \"list-initialization in a copy-initialization context is called copy-list-initialization.\" \u00b63: \"if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7).\"</li>\n</ol>\n<p>Do not be misled by the name <em>copy-list-initialization</em>. 8.5:</p>\n<blockquote>\n<p id=\"so_11069605_11069605_0\">13: The form of initialization (using parentheses or <code>=</code>) is generally insignificant, but does matter when the\n  initializer or the entity being initialized has a class type; see below. If the entity being initialized does not\n  have class type, the expression-list in a parenthesized initializer shall be a single expression.</p>\n<p id=\"so_11069605_11069605_1\">14:   The initialization that occurs in the form\n  <code>T x = a;</code>\n  as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called <em>copy-initialization.</em></p>\n</blockquote>\n<p>Both copy-initialization and its alternative, <em>direct-initialization</em>, always defer to list-initialization when the initializer is a braced-init-list. There is no semantic effect in adding the <code>=</code>, which is one reason list-initialization is informally called uniform initialization.</p>\n<p>There are differences: direct-initialization may invoke an explicit constructor, unlike copy-initialization. Copy-initialization initializes a temporary and copies it to initialize the object, when converting.</p>\n<p>The specification of <em>copy-list-initialization</em> for <code>return { list }</code> statements merely specifies the exact equivalent syntax to be <code>temp T = { list };</code>, where <code>=</code> denotes copy-initialization. It does not immediately imply that a copy constructor is invoked.</p>\n<p><strong>-- End edit.</strong></p>\n<hr>\n<p>The function result can then be received into an rvalue reference to prevent copying the temporary to a local:</p>\n<pre><code>C &amp;&amp; x = factory(); // applies to other initialization syntax\n</code></pre>\n<hr>\n<p>The question is, how to initialize a nonstatic member from a factory function returning non-copyable, non-moveable type? The reference trick doesn't work because a reference member doesn't extend the lifetime of a temporary.</p>\n<p>Note, I'm not considering aggregate-initialization. This is about defining a constructor.</p>\n</hr></hr></hr>", "Tags": "<c++><c++11><initialization><copy-elision>", "OwnerUserId": "153285", "AnswerCount": "2"}, "46270524": {"ParentId": "11069605", "CommentCount": "0", "Body": "<p>Issues like this were among the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html\" rel=\"nofollow noreferrer\">prime motivations</a> for the <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">change in C++17</a> to allow these initializations (and exclude the copies from the language, not merely as an optimization).</p>\n", "OwnerUserId": "8586227", "PostTypeId": "2", "Id": "46270524", "Score": "1", "CreationDate": "2017-09-18T01:48:24.183", "LastActivityDate": "2017-09-18T01:48:24.183"}, "11073450": {"ParentId": "11069605", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>On your main question:</p>\n<blockquote>\n<p id=\"so_11069605_11073450_0\">The question is, how to initialize a nonstatic member from a factory function returning non-copyable, non-moveable type?</p>\n</blockquote>\n<p>You don't.</p>\n<p>Your problem is that you are trying to conflate two things: how the return value is generated and how the return value is <em>used</em> at the call site. These two things don't connect to each other. Remember: the definition of a function cannot affect how it is used (in terms of language), since that definition is not necessarily available to the compiler. Therefore, C++ does not allow the way the return value was generated to affect anything (outside of elision, which is an optimization, not a language requirement).</p>\n<p>To put it another way, this:</p>\n<pre><code>C c = {...};\n</code></pre>\n<p>Is different from this:</p>\n<pre><code>C c = [&amp;]() -&gt; C {return {...};}()\n</code></pre>\n<p>You have a function which returns a type by value. It is returning a prvalue expression of type <code>C</code>. If you want to store this value, thus giving it a name, you have exactly two options:</p>\n<ol>\n<li><p>Store it as a <code>const&amp;</code> or <code>&amp;&amp;</code>. This will extend the lifetime of the temporary to the lifetime of the control block. You can't do that with member variables; it can only be done with automatic variables in functions.</p></li>\n<li><p>Copy/move it into a value. You can do this with a member variable, but it obviously requires the type to be copyable or moveable.</p></li>\n</ol>\n<p>These are the only options C++ makes available to you if you want to store a prvalue expression. So you can either make the type moveable or return a freshly allocated pointer to memory and store that instead of a value.</p>\n<p>This limitation is a big part of the reason why moving was created in the first place: to be able to pass things by value and avoid expensive copies. The language couldn't be changed to force elision of return values. So instead, they reduced the cost in many cases.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2012-06-18T17:04:43.123", "Id": "11073450", "Score": "2", "CreationDate": "2012-06-17T17:42:38.203", "LastActivityDate": "2012-06-18T17:04:43.123"}, "bq_ids": {"n4140": {"so_11069605_11069605_0": {"section_id": 3293, "quality": 0.967741935483871, "length": 30}, "so_11069605_11069605_1": {"section_id": 3294, "quality": 0.7619047619047619, "length": 16}}, "n3337": {"so_11069605_11069605_0": {"section_id": 3163, "quality": 0.967741935483871, "length": 30}, "so_11069605_11069605_1": {"section_id": 3164, "quality": 0.7619047619047619, "length": 16}}, "n4659": {"so_11069605_11069605_1": {"section_id": 4056, "quality": 0.7619047619047619, "length": 16}}}});