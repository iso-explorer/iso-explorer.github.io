post_cb({"2587445": {"ViewCount": "586", "Body": "<p>So this is something that I've always wondered but was never quite sure about. So it is strictly a matter of curiosity, not a real problem.</p>\n<p>As far as I understand, whenyou do something like <code>#include &lt;cstdlib&gt;</code> everything (except macros of course) are declared in the <code>std::</code> namespace. Every implementation that I've ever seen does this by doing something like the following:</p>\n<pre><code>#include &lt;stdlib.h&gt;\nnamespace std {\n    using ::abort;\n    // etc....\n}\n</code></pre>\n<p>Which of course has the effect of things being in both the global namespace and <code>std</code>. Is this behavior guaranteed? Or is it possible that an implementation could put these things in <code>std</code> but not in the global namespace? The only way I can think of to do that would be to have your libstdc++ implement every c function itself placing them in <code>std</code> directly instead of just including the existing libc headers (because there is no mechanism to remove something from a namespace). Which is of course a lot of effort with little to no benefit.</p>\n<p>The essence of my question is, is the following program strictly conforming and guaranteed to work?</p>\n<pre><code>#include &lt;cstdio&gt;\nint main() {\n    ::printf(\"hello world\\n\");\n}\n</code></pre>\n<p><strong>EDIT:</strong> The closest I've found is this (17.4.1.2p4):</p>\n<blockquote>\n<p id=\"so_2587445_2587445_0\">Except as noted in clauses 18 through\n  27, the contents of each header cname\n  shall be the same as that of the\n  corresponding header name.h, as\n  specified in ISO/IEC 9899:1990\n  Programming Languages C (Clause 7), or\n  ISO/IEC:1990 Programming Languages\u2014C\n  AMENDMENT 1: C Integrity, (Clause 7),\n  as appropriate, as if by inclusion. In\n  the C + + Standard Library, however,\n  the declarations and definitions\n  (except for names which are defined as\n  macros in C) are within namespace\n  scope (3.3.5) of the namespace std.</p>\n</blockquote>\n<p>which to be honest I could interpret either way. \"the contents of each header cname shall be the same as that of the corresponding header name.h, as specified in ISO/IEC 9899:1990 Programming Languages C\" tells me that they may be required in the global namespace, but \"In the C + + Standard Library, however, the declarations and definitions (except for names\nwhich are defined as macros in C) are within namespace scope (3.3.5) of the namespace std.\" says they are in std (but doesn't specify any other scoped they are in).</p>\n", "AcceptedAnswerId": "2588103", "Title": "are C functions declared in <c____> headers guaranteed to be in the global namespace as well as std?", "CreationDate": "2010-04-06T18:51:52.540", "Id": "2587445", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-11-10T01:48:16.120", "LastEditorUserId": "13430", "LastActivityDate": "2014-11-10T01:48:16.120", "Score": "14", "OwnerUserId": "13430", "Tags": "<c++><c><namespaces>", "AnswerCount": "3"}, "2587495": {"Id": "2587495", "PostTypeId": "2", "Body": "<p>At the present time, no. In fact, even though the code will work with every compiler I now of, it's really <em>not</em> supposed to work at all -- <code>#include</code>ing one of the c* headers is only supposed to give you access to the names inside of namespace std.</p>\n<p>Since implementation of this was such a pain (getting it right essentially required duplicating the entire C library as a C++ library in the right namespace), in C++ 0x they've changed the requirements a bit -- your code is now <em>allowed</em> to work, though (at least if memory serves) it's still not required to work.</p>\n", "LastActivityDate": "2010-04-06T19:00:22.290", "CommentCount": "2", "CreationDate": "2010-04-06T19:00:22.290", "ParentId": "2587445", "Score": "3", "OwnerUserId": "179910"}, "2588103": {"Id": "2588103", "PostTypeId": "2", "Body": "<p>Here's a nice synopsis of the situation (with some relaity vs. what the standard says) from Stephan T. Lavavej of the MSVC team (<a href=\"http://blogs.msdn.com/vcblog/archive/2008/08/28/the-mallocator.aspx#8904359\" rel=\"noreferrer\">http://blogs.msdn.com/vcblog/archive/2008/08/28/the-mallocator.aspx#8904359</a>):</p>\n<blockquote>\n<p id=\"so_2587445_2588103_0\"><code>&gt;</code> also, <code>&lt;cstddef&gt;</code>, <code>&lt;cstdlib&gt;</code>, and <code>std::size_t</code> etc should be used!</p>\n<p id=\"so_2587445_2588103_1\">I used to be very careful about that. C++98 had a splendid dream wherein <code>&lt;cfoo&gt;</code> would declare everything within namespace std, and <code>&lt;foo.h&gt;</code> would include <code>&lt;cfoo&gt;</code> and then drag everything into the global namespace with using-declarations. (This is D.5 [depr.c.headers].)</p>\n<p id=\"so_2587445_2588103_2\">This was ignored by lots of implementers (some of which had very little control over the C Standard Library headers). So, C++0x has been changed to match reality. As of the N2723 Working Paper, <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf\" rel=\"noreferrer\">http://open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf</a> , now <code>&lt;cfoo&gt;</code> is guaranteed to declare everything within namespace std, and may or may not declare things within the global namespace. <code>&lt;foo.h&gt;</code> is the opposite: it is guaranteed to declare everything within the global namespace, and may or may not declare things within namespace std.</p>\n<p id=\"so_2587445_2588103_3\">In reality and in C++0x, including <code>&lt;cfoo&gt;</code> is no safeguard against everything getting declared in the global namespace anyways. That's why I'm ceasing to bother with <code>&lt;cfoo&gt;</code>.</p>\n<p id=\"so_2587445_2588103_4\">This was Library Issue 456, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456</a> .</p>\n<p id=\"so_2587445_2588103_5\">(C++0x still deprecates the  headers from the C Standard Library, which is hilarious.)</p>\n</blockquote>\n<p>I've never been fond of the <code>&lt;cfoo&gt;</code> headers myself, and found that I've always use <code>&lt;foo.h&gt;</code>. Now I feel like I can stop being anxious about my lack of C++ 'purity' in that regard.</p>\n", "LastActivityDate": "2010-04-06T20:35:56.953", "CommentCount": "5", "CreationDate": "2010-04-06T20:35:56.953", "ParentId": "2587445", "Score": "8", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_2587445_2587445_0": {"length": 23, "quality": 0.5609756097560976, "section_id": 6259}}, "n3337": {"so_2587445_2587445_0": {"length": 23, "quality": 0.5609756097560976, "section_id": 6019}}, "n4659": {"so_2587445_2587445_0": {"length": 22, "quality": 0.5365853658536586, "section_id": 7763}}}, "2587465": {"Id": "2587465", "PostTypeId": "2", "Body": "<p>I cannot speak for the standards, as I have not read them, but one could envision a C++ environment that is not built on top of a C environment, or where the C environment is a compatibility layer on top of underlying C++ APIs.  In such a case, these guarantees may not be made.  I would be surprised if such an implementation would be prohibited from being a compliant implementation.</p>\n", "LastActivityDate": "2010-04-06T18:55:02.677", "CommentCount": "1", "CreationDate": "2010-04-06T18:55:02.677", "ParentId": "2587445", "Score": "0", "OwnerUserId": "1385039"}});