post_cb({"13157393": {"ParentId": "13157164", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>In <code>ISO/IEC 14882:2011</code>, \u00a7C.2.12, Clause 23: \"containers library\":</p>\n<blockquote>\n<p id=\"so_13157164_13157393_0\">Change: Complexity of size() member functions now constant</p>\n<p id=\"so_13157164_13157393_1\">Rationale: Lack of specification of complexity of size() resulted in divergent implementations with inconsistent performance characteristics.</p>\n<p id=\"so_13157164_13157393_2\">Effect on original feature: Some container implementations that conform to C++ 2003 may not conform to the specified size() requirements in this International Standard. Adjusting containers such as std::list to the stricter requirements may require incompatible changes.</p>\n</blockquote>\n<hr>\n<p>For the comments:</p>\n<p>In 23.3.5.5 - \"list operations\", again in <code>ISO/IEC 14882:2011</code>:</p>\n<blockquote>\n<p id=\"so_13157164_13157393_3\">list provides three splice operations that destructively move elements from one list to another. The behavior of splice operations is undefined if get_allocator() != x.get_allocator().</p>\n<p id=\"so_13157164_13157393_4\">void splice(const_iterator position, list&amp; x);<br>\n  void splice(const_iterator position, list&amp;&amp; x);<br>\n<strong>Requires</strong>: &amp;x != this.<br>\n<strong>Effects</strong>: Inserts the contents of x before position and x becomes empty. Pointers and references to the moved elements of x now refer to those same elements but as members of *this. Iterators referringto the moved elements will continue to refer to their elements, but they now behave as iterators into *this, not into x.<br>\n<strong>Complexity</strong>: Constant time.</br></br></br></br></p>\n<p id=\"so_13157164_13157393_5\">void splice(const_iterator position, list&amp; x, const_iterator i);<br>\n  void splice(const_iterator position, list&amp;&amp; x, const_iterator i);<br>\n<strong>Effects</strong>: Inserts an element pointed to by i from list x before position and removes the element from x. The result is unchanged if position == i or position == ++i. Pointers and references to *i continue to refer to this same element but as a member of *this. Iterators to *i (including i itself) continue to refer to the same element, but now behave as iterators into *this, not into x.<br>\n<strong>Requires</strong>: i is a valid dereferenceable iterator of x.<br>\n<strong>Complexity</strong>: Constant time.</br></br></br></br></p>\n<p id=\"so_13157164_13157393_6\">void splice(const_iterator position, list&amp; x, const_iterator first, const_iterator last);<br>\n  void splice(const_iterator position, list&amp;&amp; x, const_iterator first, const_iterator last);<br>\n<strong>Effects</strong>: Inserts elements in the range [first,last) before position and removes the elements from x.\n  <strong>Requires</strong>: [first, last) is a valid range in x. The result is undefined if position is an iterator in the range [first,last). Pointers and references to the moved elements of x now refer to those same elements but as members of *this. Iterators referring to the moved elements will continue to refer to their elements, but they now behave as iterators into *this, not into x.<br>\n<strong>Complexity</strong>: Constant time if &amp;x == this; otherwise, linear time.</br></br></br></p>\n</blockquote>\n</hr>", "OwnerUserId": "435800", "LastEditorUserId": "435800", "LastEditDate": "2012-10-31T12:16:26.137", "Id": "13157393", "Score": "9", "CreationDate": "2012-10-31T11:57:25.360", "LastActivityDate": "2012-10-31T12:16:26.137"}, "bq_ids": {"n4140": {"so_13157164_13157393_3": {"section_id": 924, "quality": 0.9444444444444444, "length": 17}, "so_13157164_13157393_4": {"section_id": 926, "quality": 0.6956521739130435, "length": 32}, "so_13157164_13157393_5": {"section_id": 929, "quality": 0.6346153846153846, "length": 33}, "so_13157164_13157210_0": {"section_id": 936, "quality": 0.8333333333333334, "length": 5}, "so_13157164_13157393_6": {"section_id": 934, "quality": 0.5142857142857142, "length": 36}}, "n3337": {"so_13157164_13157393_3": {"section_id": 912, "quality": 0.9444444444444444, "length": 17}, "so_13157164_13157393_4": {"section_id": 914, "quality": 0.6956521739130435, "length": 32}, "so_13157164_13157393_5": {"section_id": 917, "quality": 0.6346153846153846, "length": 33}, "so_13157164_13157210_0": {"section_id": 924, "quality": 0.8333333333333334, "length": 5}, "so_13157164_13157393_6": {"section_id": 922, "quality": 0.5142857142857142, "length": 36}}, "n4659": {"so_13157164_13157393_3": {"section_id": 985, "quality": 0.9444444444444444, "length": 17}, "so_13157164_13157393_5": {"section_id": 991, "quality": 0.6346153846153846, "length": 33}, "so_13157164_13157210_0": {"section_id": 997, "quality": 0.8333333333333334, "length": 5}, "so_13157164_13157393_4": {"section_id": 987, "quality": 0.6956521739130435, "length": 32}}}, "13157164": {"CommentCount": "6", "AcceptedAnswerId": "13157210", "CreationDate": "2012-10-31T11:45:05.290", "LastActivityDate": "2012-10-31T12:16:26.137", "PostTypeId": "1", "ViewCount": "1343", "FavoriteCount": "2", "Title": "Why isn't std::list.size() constant-time?", "Id": "13157164", "Score": "16", "Body": "<p>This code ran for 0.012 seconds:</p>\n<pre><code> std::list&lt;int&gt; list;\n list.resize(100);\n int size;\n for(int i = 0 ; i &lt; 10000; i++)\n     size = list.size();\n</code></pre>\n<p>This one for 9.378 seconds:</p>\n<pre><code> std::list&lt;int&gt; list;\n list.resize(100000);\n int size;\n for(int i = 0 ; i &lt; 10000; i++)\n     size = list.size();\n</code></pre>\n<p>In my opinion it would be possible to implement std::list in such way, that size would be stored in a private variable but according to this it is computed again each time I call size. Can anyone explain why?</p>\n", "Tags": "<c++><performance><list><size>", "OwnerUserId": "712237", "AnswerCount": "2"}, "13157210": {"ParentId": "13157164", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>There is a conflict between constant time <code>size()</code> and constant time <code>list.splice</code>. The committee chose to favour <code>splice</code>.</p>\n<p>When you splice nodes between two lists, you would have to count the nodes moved to update the sizes of the two lists. That takes away a lot of the advantage of splicing nodes by just changing a few internal pointers.</p>\n<hr>\n<p>As noted in the comments, C++11 has changed this by giving up O(1) for some rare(?) uses of <code>splice</code>:</p>\n<pre><code>void splice(const_iterator position, list&amp; x, const_iterator first, const_iterator last);\nvoid splice(const_iterator position, list&amp;&amp; x, const_iterator first, const_iterator last);\n</code></pre>\n<blockquote>\n<p id=\"so_13157164_13157210_0\"><em>Complexity</em>: Constant time if <code>&amp;x == this</code>; otherwise, linear time.</p>\n</blockquote>\n</hr>", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2012-10-31T12:05:54.727", "Id": "13157210", "Score": "16", "CreationDate": "2012-10-31T11:47:31.620", "LastActivityDate": "2012-10-31T12:05:54.727"}});