post_cb({"36657451": {"Id": "36657451", "PostTypeId": "2", "Body": "<p>At a high level, you could use a smart pointer, as <a href=\"https://stackoverflow.com/questions/16049329/write-only-pointer-type\">discussed here</a>.  </p>\n<p>You are talking of somehow giving a variable another attribute (at least).  If the variable has the given attribute then take different actions with accessing it (read or write).</p>\n<p>For that, you would need to modify the compiler.  It's possible.  For example, the 8051 compilers have attributes that allow for bit access and page access of variables.  Many compilers for embedded systems have syntaxes for placing variables in specific memory blocks.  </p>\n<p>I recommend trying a smart-pointer wrapper first.  </p>\n<p>Another idea is to place the variables into a class and provide <em>getters</em> and <em>setters</em> to model your environment (don't allow direct access).  </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-15T21:53:19.677", "Score": "0", "CreationDate": "2016-04-15T21:53:19.677", "ParentId": "36657121", "CommentCount": "3", "LastEditDate": "2017-05-23T11:52:43.660", "OwnerUserId": "225074"}, "36657277": {"Id": "36657277", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36657121_36657277_0\">I know the concept behind volatile variables. </p>\n</blockquote>\n<p>ok...</p>\n<blockquote>\n<p id=\"so_36657121_36657277_1\">Basically all reads and writes to that variable must occur. </p>\n</blockquote>\n<p>Not \"basically\", absolutely.</p>\n<blockquote>\n<p id=\"so_36657121_36657277_2\">Is there a way to allow the optimizer to get away with only doing all of the writes and assuming that the reads will always stay the same (unless modified by writing).</p>\n</blockquote>\n<p>No</p>\n<p>&lt;- snip -&gt;</p>\n<p>volatile is there to model read/write access to memory mapped I/O. 'Writing' to such I/O often triggers activity in the electronics even if the value written is the same as the one previously written.</p>\n<p>There is no other use for volatile - no, not even in multithreading (where it won't do what you wanted anyway).</p>\n<p>From \u00a77.1.6.1</p>\n<blockquote>\n<p id=\"so_36657121_36657277_3\">[ Note: volatile is a <em>hint</em> to the implementation to avoid aggressive optimization involving the object\n  because the value of the object might be changed by means undetectable by an implementation. Furthermore,\n  for some implementations, volatile might indicate that special hardware instructions are required to access\n  the object. See 1.9 for detailed semantics. In general, the semantics of volatile are intended to be the\n  same in C++ as they are in C. \u2014 end note ]</p>\n</blockquote>\n<p>The implication here being that unless you understand exactly what the implementation is doing with the volatile variable, you have no place using it.</p>\n<p>It's use is not portable so if used at all, should be wrapped in an implementation-specific specialisation of whatever concept you are dealing with.</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2016-04-15T21:58:15.570", "Score": "4", "CreationDate": "2016-04-15T21:40:55.333", "ParentId": "36657121", "CommentCount": "4", "LastEditDate": "2016-04-15T21:58:15.570", "OwnerUserId": "2015579"}, "36657947": {"Id": "36657947", "PostTypeId": "2", "Body": "<p><del>How about simply casting away the volatility on reads?</del></p>\n<p>Turned out to not be simple, at all.</p>\n<p>The following seems to only work reliably on clang. And only when making the hw_reg_read alias before doing the volatile write.</p>\n<pre><code>volatile int * hw_reg = (int*)0x0001003B;\n\nint main()\n{\n    /*obtain nonvolatile alias*/\n    int* hw_reg_read = const_cast&lt;int*&gt;(hw_reg);\n\n    /*volatile write*/\n    *hw_reg = 42;\n\n    /*nonvolatile read*/\n    int i = *hw_reg_read;\n\n    return i;\n}\n</code></pre>\n<p>I will leave it here as scarecrow, for now.</p>\n", "LastEditorUserId": "67634", "LastActivityDate": "2016-04-15T23:45:41.683", "Score": "1", "CreationDate": "2016-04-15T22:39:09.723", "ParentId": "36657121", "CommentCount": "3", "LastEditDate": "2016-04-15T23:45:41.683", "OwnerUserId": "67634"}, "bq_ids": {"n4140": {"so_36657121_36657277_3": {"length": 37, "quality": 0.925, "section_id": 5436}}, "n3337": {"so_36657121_36657277_3": {"length": 25, "quality": 0.625, "section_id": 5231}}, "n4659": {"so_36657121_36657277_3": {"length": 37, "quality": 0.925, "section_id": 6863}}}, "36657579": {"Id": "36657579", "PostTypeId": "2", "Body": "<p>I think this is probably what I am looking for:</p>\n<pre><code>template&lt;class T&gt;\nclass smartWriter{\n    volatile T* Volatile;  //Use this for writes\n    T* NotVol;  //Use this for reads\n    public:\n        smartWriter(T* add) : Volatile(add),NotVol(add){\n        }\n        operator T&amp;() const{\n            return *NotVol;  //reads involve the non volatile one\n        }\n        void operator=(T data){\n            *Volatile = data;  //writes involve the volatile one\n        }\n\n};\n\nint main(int argc,char** args){\n    smartWriter&lt;int&gt; smtVar(((int*)0xdeadbeaf)) ;  //Initialize var with address \"0xdeadbeef\"\n    smtVar = 12;  //Optimizer can not get rid of this\n    int other = smtVar;  //Optimizer might get rid of this?\n\n    system(\"Pause\");\n}\n</code></pre>\n<p>Thanks for sparking my imagination with the smart pointer thing....</p>\n", "LastEditorUserId": "6149078", "LastActivityDate": "2016-04-15T22:27:23.013", "Score": "0", "CreationDate": "2016-04-15T22:02:58.967", "ParentId": "36657121", "CommentCount": "3", "LastEditDate": "2016-04-15T22:27:23.013", "OwnerUserId": "6149078"}, "36657121": {"ViewCount": "67", "Body": "<p>I know the concept behind <code>volatile</code> variables.  Basically all reads and writes to that variable <strong>must</strong> occur.  Is there a way to allow the optimizer to get away with only doing all of the writes and assuming that the reads will always stay the same (unless modified by writing).</p>\n<p>Also (along the same lines) is there a way to define a new type of memory for the compiler to store variables.  For example if I have a micro controller with an SD card can I define the SD card as a place to store memory (or do I explicitly have to do all of the read/writes on my own).</p>\n<p>For the record I am using gcc as my compiler if there is anything I can do specifically (and only) on gcc</p>\n", "AcceptedAnswerId": "36657579", "Title": "Give an optimizer greater \"License\"", "CreationDate": "2016-04-15T21:28:53.040", "Id": "36657121", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2016-04-15T23:45:41.683", "Score": "3", "OwnerUserId": "6149078", "Tags": "<c++><c><gcc><optimization>", "AnswerCount": "4"}});