post_cb({"9827431": {"Id": "9827431", "PostTypeId": "2", "Body": "<p><code>Owner</code> doesn't actually own <code>owned</code> it just has a reference to it, so when it is destroyed owned destructor won't be called.</p>\n", "LastActivityDate": "2012-03-22T17:29:11.930", "CommentCount": "3", "CreationDate": "2012-03-22T17:29:11.930", "ParentId": "9827376", "Score": "1", "OwnerUserId": "401196"}, "9827376": {"ViewCount": "122", "Body": "<p>Take these two classes for instance:</p>\n<pre><code>struct Owned {\n    Owned() : i() { }\n\n    void print() { cout &lt;&lt; ++i &lt;&lt; endl; }\n\n    int i;\n};\n\nstruct Owner {\n    Owner(Owned&amp; o) : o(o) { }\n\n    Owned&amp; o;\n\n    ~Owner() { o.print(); }\n};\n</code></pre>\n<p>Is it dangerous to use them in this way?</p>\n<pre><code>int main() {\n    Owned owned;\n    Owner owner(owned);\n}\n</code></pre>\n<p>It seems that, depending on the order in which they are destructed, that this could cause the destructor of <code>owner</code> to call a function on a destroyed <code>owned</code>. Is the order of destruction of local variables defined, and how can you make a situation where two instances refer to each other work?</p>\n<p>Forgive me if this is common knowledge, I haven't read anything about it anywhere though.</p>\n", "AcceptedAnswerId": "9827438", "Title": "Is it dangerous to have local variables refer to other local variables?", "CreationDate": "2012-03-22T17:26:36.243", "Id": "9827376", "CommentCount": "0", "LastEditDate": "2012-03-23T10:05:17.633", "PostTypeId": "1", "LastEditorUserId": "21234", "LastActivityDate": "2012-03-23T10:05:17.633", "Score": "2", "OwnerUserId": "726361", "Tags": "<c++><reference><destructor>", "AnswerCount": "4"}, "9827438": {"Id": "9827438", "PostTypeId": "2", "Body": "<p>Local variables are destroyed in the opposite order of being created. In your case, you're fine, since <code>owner</code> will always be destroyed before <code>owned</code>.</p>\n<p><code>\u00a76.6 [stmt.jump] p2</code></p>\n<blockquote>\n<p id=\"so_9827376_9827438_0\">On exit from a scope (however accomplished), objects with automatic storage duration (3.7.3) that have been constructed in that scope are destroyed in the reverse order of their construction.</p>\n</blockquote>\n<p>However, care has to be taken if you can reassign the owned member after construction.</p>\n<blockquote>\n<p id=\"so_9827376_9827438_1\">how can you make a situation where two instances refer to each other work?</p>\n</blockquote>\n<p>Don't have them access each other in their destructor. Or make clear who exactly gets destroyed first, maybe with a callback or flag that gets passed. Example:</p>\n<pre><code>struct two;\nstruct one{\n  two* other;\n\n  one(two* o = nullptr) : other(o) {}\n  ~one(){ if(other) other.other = nullptr; }\n};\n\nstruct two{\n  one* other;\n  two(one* o = nullptr) : other(o) {}\n  ~one(){ if(other) other.other = nullptr; } \n};\n</code></pre>\n<p>This will ensure that both objects never reference a non-existent one.</p>\n<p>Mutually referencing objects are very rare anyways.</p>\n", "LastEditorUserId": "500104", "LastActivityDate": "2012-03-22T17:34:36.653", "Score": "5", "CreationDate": "2012-03-22T17:29:33.913", "ParentId": "9827376", "CommentCount": "4", "OwnerUserId": "500104", "LastEditDate": "2012-03-22T17:34:36.653"}, "9827424": {"Id": "9827424", "PostTypeId": "2", "Body": "<p>This is safe, local objects are destroyed in the reverse order in which they are created.</p>\n", "LastActivityDate": "2012-03-22T17:28:55.843", "CommentCount": "2", "CreationDate": "2012-03-22T17:28:55.843", "ParentId": "9827376", "Score": "0", "OwnerUserId": "39742"}, "bq_ids": {"n4140": {"so_9827376_9827438_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3909}}, "n3337": {"so_9827376_9827438_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3769}}, "n4659": {"so_9827376_9827438_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 4795}}}, "9827509": {"Id": "9827509", "PostTypeId": "2", "Body": "<p>What you've written isn't dangerous in anyway, variables in the same scope in C++ are destructed in a defined (reverse-ordered manner).  Something like this, however, is dangerous, </p>\n<pre><code>int main() {\n    Owner owner();\n    {\n        Owned owned;\n        owner.setOwned(owned);\n    }\n\n    owner.doSomethingWithOwned();\n}\n</code></pre>\n<p>Because owned no longer exists, it was forced out of scope.  This also applies to setting local variables to be references in objects on the heap.  </p>\n", "LastActivityDate": "2012-03-22T17:33:52.020", "CommentCount": "3", "CreationDate": "2012-03-22T17:33:52.020", "ParentId": "9827376", "Score": "1", "OwnerUserId": "1284568"}});