post_cb({"bq_ids": {"n4140": {"so_43735443_43736209_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 264}}, "n3337": {"so_43735443_43736209_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 255}}}, "43736209": {"CommentCount": "0", "Body": "<p>That is not possible, specialization must reside in the same namespace as template itself:</p>\n<blockquote>\n<p id=\"so_43735443_43736209_0\">14.7.3 Explicit specialization [temp.expl.spec]</p>\n<p id=\"so_43735443_43736209_1\">2\n  An explicit specialization shall be declared in a namespace enclosing the specialized template. An explicit\n  specialization whose declarator-id or class-head-name is not qualified shall be declared in the nearest enclosing\n  namespace of the template, or, if the namespace is inline (7.3.1), any namespace from its enclosing namespace\n  set. Such a declaration may also be a definition. If the declaration is not a definition, the specialization may\n  be defined later (7.3.1.2).</p>\n</blockquote>\n<p>so you have to rewrite your code like this:</p>\n<pre><code>namespace Nested {\nclass A {};\n} // namespace Nested\n\ntemplate&lt;&gt; void my_function&lt;Nested::A&gt;() {\n    std::cout &lt;&lt; \"my_function specialization for A\" &lt;&lt; std::endl;\n}\n</code></pre>\n", "CreationDate": "2017-05-02T11:00:18.920", "ParentId": "43735443", "Id": "43736209", "LastActivityDate": "2017-05-02T11:00:18.920", "PostTypeId": "2", "Score": "3", "OwnerUserId": "7860670"}, "43735443": {"CreationDate": "2017-05-02T10:18:47.343", "ViewCount": "56", "Id": "43735443", "AcceptedAnswerId": "43736209", "Score": "0", "Title": "How to explicitly specialize a function template from within another namespace?", "LastEditorUserId": "2664470", "CommentCount": "1", "Body": "<p>For readability reasons, I would like to specialize a function template close to the definition of a class which is declared inside a namespace:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt; void my_function() {\n    std::cout &lt;&lt; \"my_function default\" &lt;&lt; std::endl;\n}\n\nnamespace Nested {\n    class A {};\n    template&lt;&gt; void my_function&lt;A&gt;() {\n        std::cout &lt;&lt; \"my_function specialization for A\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>However, with the above code I get the following error from clang++ 4.0:</p>\n<pre><code> error: no function template matches function template specialization 'my_function'\n</code></pre>\n<p>This seems to be a namespacing problem. How can I get the above to work (without moving the template function specialization out of the <code>Nested</code> namespace)?</p>\n<p>Edit: I have also tried adding <code>::my_function</code> in the specialization:</p>\n<pre><code>test.cpp: error: definition or redeclaration of 'my_function' cannot name the global scope\n        template&lt;&gt; void ::my_function&lt;A&gt;() {\n                        ~~^\n</code></pre>\n", "Tags": "<c++><templates><namespaces><template-specialization><explicit-specialization>", "LastEditDate": "2017-05-02T10:37:07.703", "LastActivityDate": "2017-05-02T11:00:18.920", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "2664470"}});