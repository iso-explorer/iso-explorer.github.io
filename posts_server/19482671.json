post_cb({"19482688": {"ParentId": "19482671", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Any iterator type needs to be dereferenceable and incrementable, but you can not dereference or increment <code>void*</code>. Since you linked <code>cppreference.com</code>, it starts <a href=\"http://en.cppreference.com/w/cpp/concept/Iterator\" rel=\"nofollow\">here</a>.</p>\n<hr>\n<p>Regarding your updated question: It is for safety reasons. If you want a pointer to the individual bytes in memory, you'd use <code>char*</code>, <code>unsigned char*</code> or something like that. <code>void*</code> is basically just a way to store an address and it is not supposed to be used to access anything. Only when you know what it points to, you are supposed to cast it to a pointer to that type.</p>\n<p>The reason you are allowed to add (or subtract) from it is AFAIK for backward compatibility. For a <code>void* p;</code> you are allowed to write <code>p += 1;</code>, but you are <em>not</em> allowed to increment it with <code>++p;</code> as per</p>\n<blockquote>\n<h3>5.3.2 Increment and decrement [expr.pre.incr]</h3>\n<p id=\"so_19482671_19482688_0\"><sup>1</sup> The operand of prefix <code>++</code> is modified by adding <code>1</code>, or set to <code>true</code> if it is <code>bool</code> (this use is deprecated). The operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to a <strong>completely-defined</strong> object type.</p>\n</blockquote>\n<p>(emphasis mine).</p>\n</hr>", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-10-21T15:49:49.763", "Id": "19482688", "Score": "30", "CreationDate": "2013-10-20T20:47:42.587", "LastActivityDate": "2013-10-21T15:49:49.763"}, "19482858": {"ParentId": "19482671", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Why you can't have an iterator for void type?</h2>\n<p>Per <code>\u00a73.9.1/9</code> and <code>\u00a75.7</code>, Type <code>void</code> is not a complete type and additive operators can not be applied to incomplete pointer types:</p>\n<blockquote>\n<p id=\"so_19482671_19482858_0\">The void type has an empty set of values. The void type is an <strong>incomplete</strong> type that cannot be &gt; completed...</p>\n<p id=\"so_19482671_19482858_1\">... operand is <sub><em>(shall be)</em></sub> a pointer to a <strong>completely-defined</strong> object ...</p>\n</blockquote>\n<p>Therefore you can not have an iterator for voids.</p>\n<p>\u00a0</p>\n<h2>Why you see that error?</h2>\n<blockquote>\n<p id=\"so_19482671_19482858_2\">error: forming reference to void</p>\n</blockquote>\n<p>Declaring <code>std::iterator_traits</code>, it somewhere tries to declare a reference to the entry type which is <code>void</code> in your case. but per <code>\u00a78.3.2/5</code>  declaring a reference to <code>void</code> is not legal, because you can not define a valid object of <code>void</code>:</p>\n<blockquote>\n<p id=\"so_19482671_19482858_3\">A reference shall be initialized to refer to a valid object</p>\n</blockquote>\n", "OwnerUserId": "952747", "LastEditorUserId": "952747", "LastEditDate": "2016-06-28T10:20:06.297", "Id": "19482858", "Score": "13", "CreationDate": "2013-10-20T21:06:26.697", "LastActivityDate": "2016-06-28T10:20:06.297"}, "19482696": {"ParentId": "19482671", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The answer is simple because you can not dereference <code>void*</code>. Also void has no size so you cant move to the next item. The iterator type must be incremental and dereferenceable.</p>\n<p><strong>EDIT:-</strong></p>\n<blockquote>\n<p id=\"so_19482671_19482696_0\"><strong>Is it for safety concerns, i.e preventing people from writing bad\n  thing ?</strong></p>\n</blockquote>\n<p>Yes this is for safety reason. You cant do what you have tried to do that in your edit. <code>void*</code> is just used to store the address and if you are using it to access anything then it would not be allowed.</p>\n<p>You can write <code>wut = wut + 1</code> for <code>void * wut</code></p>\n", "OwnerUserId": "1501794", "LastEditorUserId": "1501794", "LastEditDate": "2013-10-21T19:30:21.643", "Id": "19482696", "Score": "7", "CreationDate": "2013-10-20T20:48:19.913", "LastActivityDate": "2013-10-21T19:30:21.643"}, "bq_ids": {"n4140": {"so_19482671_19482858_0": {"section_id": 7218, "quality": 0.8461538461538461, "length": 11}, "so_19482671_19482688_0": {"section_id": 6074, "quality": 0.8695652173913043, "length": 20}, "so_19482671_19482858_3": {"section_id": 3222, "quality": 1.0, "length": 5}, "so_19482671_19482858_1": {"section_id": 6074, "quality": 1.0, "length": 4}}, "n3337": {"so_19482671_19482858_0": {"section_id": 6962, "quality": 0.8461538461538461, "length": 11}, "so_19482671_19482688_0": {"section_id": 5842, "quality": 0.8695652173913043, "length": 20}, "so_19482671_19482858_3": {"section_id": 3096, "quality": 1.0, "length": 5}, "so_19482671_19482858_1": {"section_id": 5842, "quality": 1.0, "length": 4}}, "n4659": {"so_19482671_19482688_0": {"section_id": 7570, "quality": 0.6521739130434783, "length": 15}, "so_19482671_19482858_3": {"section_id": 3979, "quality": 1.0, "length": 5}, "so_19482671_19482858_1": {"section_id": 7570, "quality": 1.0, "length": 4}}}, "19482671": {"CommentCount": "4", "ViewCount": "1270", "PostTypeId": "1", "LastEditorUserId": "2246367", "CreationDate": "2013-10-20T20:46:17.983", "LastActivityDate": "2016-06-28T10:20:06.297", "Title": "Why void* isn't an iterator type?", "AcceptedAnswerId": "19482688", "LastEditDate": "2013-10-21T11:28:19.153", "Id": "19482671", "Score": "17", "Body": "<p>I've tested the following code with GCC 4.8, that doesn't compile because we can't form reference to void.\n</p>\n<pre><code>#include &lt;iterator&gt;\nint main()\n{\n    std::iterator_traits&lt;void*&gt; test;\n}\n</code></pre>\n<p>Does that mean that void* isn't an <a href=\"http://en.cppreference.com/w/cpp/concept/RandomAccessIterator\">iterator</a> ? (meaning the concept here)</p>\n<p><strong>EDIT:</strong></p>\n<p>Okay the question was ill formed. What I'm actually asking is why does C++ need such a behavior for void* ? Is it for safety concerns, i.e preventing people from writing bad thing ?</p>\n<p>Because while deferencing a void is illegal, pointer arithmetic is :</p>\n<pre class=\"lang-c prettyprint-override\"><code>int main()\n{\n    std::uint8_t test[] = {1,2,3};\n    void * wut = test;\n    std::uint8_t * p2 = static_cast&lt;std::uint8_t *&gt;(wut + 1);\n    std::cout &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(*p2) &lt;&lt; std::endl; \n}\n</code></pre>\n<p>So even if, as you said, void hasn't a size, from the point of view of GCC, it does. And it is the size of the smallest adressable unit in a computer.</p>\n", "Tags": "<c++><gcc><iterator>", "OwnerUserId": "2246367", "AnswerCount": "3"}});