post_cb({"38626627": {"ParentId": "38609960", "CommentCount": "4", "Body": "<p>This is more than likely not a bug, but instead your version of <code>delete</code> is not being called, and instead the Visual Studio's debug runtime library's version of the global <code>delete</code> is called.  Having two or more versions of the global <code>delete</code> operator in the same program is undefined behavior.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_delete\" rel=\"nofollow\">this reference (<strong>Global replacements</strong>)</a>, the behavior is stated to be undefined when this occurs.</p>\n<p>From the C++ ISO standard:</p>\n<blockquote>\n<p id=\"so_38609960_38626627_0\">3.7.4 Dynamic storage duration [basic.stc.dynamic]<br>\n  //...</br></p>\n<p id=\"so_38609960_38626627_1\"><strong>\u00a72</strong>  The library provides default definitions for the global allocation\n  and deallocation functions. Some global allocation and deallocation\n  functions are replaceable (18.6.1). <strong>A C++ program shall provide at\n  most one definition of a replaceable allocation or deallocation\n  function.</strong></p>\n</blockquote>\n<hr>\n<p>Running with Visual Studio 2015 using the release version Visual Studio runtime library does not produce this error, and the replacement global <code>delete</code> does in fact get called.</p>\n<p><a href=\"http://rextester.com/NZR88334\" rel=\"nofollow\">Visual Studio 2015 online compiler results.</a></p>\n</hr>", "OwnerUserId": "3133316", "PostTypeId": "2", "Id": "38626627", "Score": "1", "CreationDate": "2016-07-28T03:32:08.287", "LastActivityDate": "2016-07-28T03:32:08.287"}, "38609960": {"CommentCount": "10", "ViewCount": "166", "PostTypeId": "1", "LastEditorUserId": "493613", "CreationDate": "2016-07-27T10:09:50.703", "LastActivityDate": "2016-07-28T03:32:08.287", "Title": "Debug assertion failure with stringstream::imbue and custom global operator new", "AcceptedAnswerId": "38626627", "LastEditDate": "2016-07-27T10:42:28.237", "Id": "38609960", "Score": "3", "Body": "<p>I apologize for this rather localized question, but I was hoping to get someone else's view on it to make sure I'm not doing something obviously wrong.</p>\n<p>I believe I've run into a bug in either the Visual C++ Runtime library, or somewhere in Microsoft's implementation of <code>std::stringstream</code>.  The issue only manifests itself with a combination of when:</p>\n<ol>\n<li><code>imbue()</code> is called to change the locale on a <code>stringstream</code>, and</li>\n<li>A custom global <code>operator new</code> is used which <em>returns a pointer offset from the base address returned by <code>malloc()</code> used to allocate the block.</em></li>\n</ol>\n<p>I've been able to reproduce this with the following minimal test case:</p>\n<pre><code>#include &lt;sstream&gt;\n\nstatic void *localMalloc(size_t bytes)\n{\n    unsigned char *ptr = static_cast&lt;unsigned char *&gt;( malloc(bytes + 64) );\n    ptr += 64;\n    printf(\"malloc of %d bytes: %ph\\n\", bytes, ptr);\n    return ptr;\n}\n\nvoid *operator new(size_t bytes) { return localMalloc(bytes); }\nvoid *operator new[](size_t bytes) { return localMalloc(bytes); }\nvoid operator delete(void *ptr) throw() { /* do nothing */ }\nvoid operator delete[](void *ptr) throw() { /* do nothing */ }\n\nstruct DecimalSeparator : std::numpunct&lt;char&gt;\n{\n    char do_decimal_point() const\n    {\n        return '.';\n    }\n};\n\nint main()\n{\n    std::stringstream ss;\n    ss.imbue(std::locale(std::locale(), new DecimalSeparator));\n    ss &lt;&lt; 5;  // &lt;-- is_block_type_valid(header-&gt;_block_use) assertion failure here\n    return 0;\n}\n</code></pre>\n<p>If either:</p>\n<ol>\n<li>The <code>ptr += 64;</code> line in <code>localMalloc()</code> or</li>\n<li>The <code>ss.imbue()</code> call in <code>main()</code></li>\n</ol>\n<p>are commented out, the code works as expected, and the assertion does not happen.</p>\n<p>I have attempted to step into the code using the debugger as much as I possibly can, but I am currently unable to pinpoint the location at where the code fails in the STL as Visual Studio dumps me into raw disassembly mode after stepping out of <code>basic_stringbuf::overflow()</code> making debugging nearly impossible.  As far as I can tell, I haven't seen any invalid memory writes outside of the memory being allocated, so I'm not completely sure where the CRT is checking the heap or why it thinks the pointer is invalid.</p>\n<p>Note that <code>operator delete</code> is intentionally ignoring the free in this test case for brevity.  It makes no difference if <code>free()</code> is properly called on the memory block or not.</p>\n<p>So far, tests on the following compilers and platforms have resulted in:</p>\n<ol>\n<li>VS2015 Update 2: fails</li>\n<li>VS2015 Update 3: fails</li>\n<li>VS2015 Update 3 + KB3165756: fails</li>\n<li>clang-703.0.31 on OSX: <strong>OK</strong></li>\n</ol>\n<p>Does anyone see anything odd here that I missed?</p>\n", "Tags": "<c++><windows><assert><stringstream>", "OwnerUserId": "493613", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38609960_38626627_1": {"section_id": 7174, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_38609960_38626627_1": {"section_id": 6918, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_38609960_38626627_1": {"section_id": 8682, "quality": 0.9166666666666666, "length": 22}}}});