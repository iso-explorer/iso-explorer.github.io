post_cb({"1774187": {"CommentCount": "1", "AcceptedAnswerId": "1774195", "CreationDate": "2009-11-21T01:29:40.923", "LastActivityDate": "2009-11-21T01:41:10.183", "PostTypeId": "1", "ViewCount": "1812", "FavoriteCount": "3", "Title": "Is the order of initialization guaranteed by the standard?", "Id": "1774187", "Score": "8", "Body": "<p>In the following code snippet d1's initializer is passed d2 which has not been constructed yet (correct?), so is the d.j in D's copy constructor an uninitialized memory access?</p>\n<pre><code>struct D\n{\n    int j;\n\n    D(const D&amp; d) { j = d.j; }\n    D(int i) { j = i; }\n};\n\nstruct A\n{\n    D d1, d2;\n    A() : d2(2), d1(d2) {}\n};\n</code></pre>\n<p>Which section of C++ standard discusses order of initialization of data members?</p>\n", "Tags": "<c++>", "OwnerUserId": "179189", "AnswerCount": "5"}, "1774195": {"ParentId": "1774187", "CommentCount": "3", "Body": "<p>I don't have the standard handy right now so I can't quote the section, but structure or class member initialisation <em>always</em> happens in declared order. The order in which members are mentioned in the constructor initialiser list is not relevant.</p>\n<p>Gcc has a warning <code>-Wreorder</code> that warns when the order is different:</p>\n<pre>\n       -Wreorder (C++ only)\n           Warn when the order of member initializers given in the code does\n           not match the order in which they must be executed.  For instance:\n\n                   struct A {\n                     int i;\n                     int j;\n                     A(): j (0), i (1) { }\n                   };\n\n           The compiler will rearrange the member initializers for i and j to\n           match the declaration order of the members, emitting a warning to\n           that effect.  This warning is enabled by -Wall.\n</pre>\n", "OwnerUserId": "893", "PostTypeId": "2", "Id": "1774195", "Score": "11", "CreationDate": "2009-11-21T01:33:17.313", "LastActivityDate": "2009-11-21T01:33:17.313"}, "1774204": {"ParentId": "1774187", "CommentCount": "0", "Body": "<p>In your example it will fail:</p>\n<pre><code>struct A\n{\n    D d1, d2;    \n    A() : d2(2), d1(d2) {}\n};\n\nd1: is initialised first as it is declared first.\nd2: is then initialized.\n</code></pre>\n<p>As a result the initializer list will construct d1 using a reference to an invalid object (d2).</p>\n<p>This is one reason to turn up your compilers warning level as high as possable.<br>\nAnd additionaly force it to report all warnings as errors.</br></p>\n", "OwnerUserId": "14065", "PostTypeId": "2", "Id": "1774204", "Score": "6", "CreationDate": "2009-11-21T01:37:45.277", "LastActivityDate": "2009-11-21T01:37:45.277"}, "1774211": {"ParentId": "1774187", "CommentCount": "0", "Body": "<p>This phenomenon is explained/highlighted in Item 13 of Meyer's <em>Effective C++</em>. It says that the destructor must destroy elements in the inverse order of its constructors, therefore all constructors must initialize elements in the same order, therefore they initialize them in the order in which they're declared (instead of the sequence of the initialization lists).</p>\n", "OwnerUserId": "49942", "PostTypeId": "2", "Id": "1774211", "Score": "2", "CreationDate": "2009-11-21T01:39:59.483", "LastActivityDate": "2009-11-21T01:39:59.483"}, "1774213": {"ParentId": "1774187", "CommentCount": "0", "Body": "<p>The C++ standard (ISO/IEC 14882:2003 12.6.2/5, <em>Initializing bases and members</em>) says:</p>\n<blockquote>\n<p id=\"so_1774187_1774213_0\">Initialization shall proceed in the following order:</p>\n<p id=\"so_1774187_1774213_1\">\u2014  First, and only for the constructor of the most derived class as described below, virtual base classes shall be initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base class names in the derived\n  class base-specifier-list.</p>\n<p id=\"so_1774187_1774213_2\">\u2014  Then, direct base classes shall be initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).</p>\n<p id=\"so_1774187_1774213_3\">\u2014 Then, nonstatic data members shall be initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).</p>\n<p id=\"so_1774187_1774213_4\">\u2014  Finally, the body of the constructor is executed.</p>\n</blockquote>\n<p>Bullet point 3 guarantees the order of nonstatic data member initialization.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "1774213", "Score": "11", "CreationDate": "2009-11-21T01:41:10.183", "LastActivityDate": "2009-11-21T01:41:10.183"}, "1774200": {"ParentId": "1774187", "CommentCount": "0", "Body": "<p>Yes.  A good compiler should warn you that <code>A::d2</code> will be initialized after <code>A::d1</code>.</p>\n", "OwnerUserId": "456", "PostTypeId": "2", "Id": "1774200", "Score": "1", "CreationDate": "2009-11-21T01:35:19.243", "LastActivityDate": "2009-11-21T01:35:19.243"}, "bq_ids": {"n4140": {"so_1774187_1774213_3": {"section_id": 438, "quality": 1.0, "length": 15}, "so_1774187_1774213_2": {"section_id": 438, "quality": 1.0, "length": 13}, "so_1774187_1774213_1": {"section_id": 438, "quality": 0.875, "length": 28}}, "n3337": {"so_1774187_1774213_3": {"section_id": 429, "quality": 1.0, "length": 15}, "so_1774187_1774213_2": {"section_id": 429, "quality": 1.0, "length": 13}, "so_1774187_1774213_1": {"section_id": 429, "quality": 0.875, "length": 28}}, "n4659": {"so_1774187_1774213_3": {"section_id": 458, "quality": 1.0, "length": 15}, "so_1774187_1774213_2": {"section_id": 458, "quality": 1.0, "length": 13}, "so_1774187_1774213_1": {"section_id": 458, "quality": 0.875, "length": 28}}}});