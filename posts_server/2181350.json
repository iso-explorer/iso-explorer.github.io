post_cb({"bq_ids": {"n4140": {"so_2181350_2181396_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5507}}, "n3337": {"so_2181350_2181396_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5293}}, "n4659": {"so_2181350_2181396_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6942}}}, "2181350": {"ViewCount": "669", "Body": "<p>I have the following class hierarchy:</p>\n<pre><code>template &lt;typename T&gt;\nclass base\n{\npublic:\n   void f() {}\n};\n\nclass class_a : public base&lt;class_a&gt; {};\n\nclass class_b : public base&lt;class_b&gt;, \n                public class_a \n{ \n   using base&lt;class_b&gt;::f; \n};\n\nint main()\n{\n   class_b b;\n   b.f();\n   return 0;\n}\n</code></pre>\n<p>Comeu and Intel C++ v11 claim all is well, however GCC (4.4.1) and VC++ 2008 seem to complain ( <a href=\"http://codepad.org/KQPDsqSp\" rel=\"nofollow noreferrer\">http://codepad.org/KQPDsqSp</a> ), eg:</p>\n<pre><code>g++ -pedantic -Wall -o test test.cpp \ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:5: error: \u2018void base&lt;T&gt;::f() [with T = class_b]\u2019 is inaccessible\ntest.cpp:14: error: within this context \n</code></pre>\n<p>I believe the code is well formed as it is, however I could be wrong, I'm hoping someone from the SO C++ community could provide some insight into this issue.</p>\n<p><strong>Note:</strong> Adding \"public\" before the using directive in class_b, resolves the issue for both gcc and VS. Should the accessor section of the class in which the using directive is applied override the derivation mode (public, private) of the base class?</p>\n<p>In short is this</p>\n<ul>\n<li>A compiler error - if so which compiler GCC,VS or Comeu,Intel</li>\n<li>Is the above code well formed?</li>\n<li>Does the accessor section in which a using directive is called override the derivation mode of the base?</li>\n</ul>\n", "Title": "C++ Compiler error with CRTP", "CreationDate": "2010-02-02T01:27:48.107", "LastActivityDate": "2010-02-02T03:06:05.563", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2010-02-02T03:02:19.857", "LastEditorDisplayName": "Matthieu N.", "OwnerDisplayName": "Matthieu N.", "Id": "2181350", "Score": "6", "Tags": "<c++><templates><compiler-errors><crtp>", "AnswerCount": "1"}, "2181396": {"Id": "2181396", "PostTypeId": "2", "Body": "<p>What you are doing here, is resolving an ambiguity by importing the symbol into the classes <strong>private</strong> namespace. Hence it's method shadowing and changing it's visibility to private. You can't have two functions with the exact same prototype both private and public, hence the f is now private.</p>\n<p>At least GCC believes that <a href=\"http://gcc.gnu.org/ml/gcc-prs/2001-07/msg00591.html\" rel=\"nofollow noreferrer\">using should be able to change the visibility</a> of a function.</p>\n<p>Vague references however found in <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=6936\" rel=\"nofollow noreferrer\">GCC bug database</a>, show that using in fact shouldn't be affected by scope. </p>\n<p>Most importantly, a direct answer (C++ Standard '03 -- 7.3.3/15)</p>\n<blockquote>\n<p id=\"so_2181350_2181396_0\">The alias created by the using-declaration has the usual accessibility for a member-declaration.</p>\n</blockquote>\n<p>Hence the answers would be:</p>\n<ul>\n<li>it's a bug in Comeau </li>\n<li>no, the code is not well formed, at least C++03-wise (can't find anything related in C++0x N3000)</li>\n<li>yes, you can change access scope</li>\n</ul>\n", "LastEditorUserId": "233522", "LastActivityDate": "2010-02-02T03:06:05.563", "Score": "3", "CreationDate": "2010-02-02T01:41:34.983", "ParentId": "2181350", "CommentCount": "6", "OwnerUserId": "233522", "LastEditDate": "2010-02-02T03:06:05.563"}});