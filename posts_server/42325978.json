post_cb({"42326123": {"Id": "42326123", "PostTypeId": "2", "Body": "<p>It's not definied by standard, so this question can't really be answered because multiple implementations of standard library can implement this stuff as they please.</p>\n<p>And no, <code>*left</code> and <code>*right</code> are not deleted (aka it doesn't do something like <code>delete left</code>, it just erases them from memory). Just like <code>new Node</code> doesn't allocate additional memory to set <code>*left</code> / <code>*right</code>.</p>\n<p>You haven't explicitly defined ctor or dtor, so nothing speciall will happen. However if you will define constructor / destructor those will be called by <code>new</code> &amp; <code>delete</code>.\n//edit: Ofc they're called now, without user-defined ctor/dtor, but don't do anything useful to you.</p>\n", "LastActivityDate": "2017-02-19T10:28:37.190", "CommentCount": "0", "CreationDate": "2017-02-19T10:28:37.190", "ParentId": "42325978", "Score": "0", "OwnerUserId": "6668238"}, "42325978": {"ViewCount": "160", "Body": "<p>I am not getting how the \"delete\" operator is actually implemented behind the scenes in C++. For example:</p>\n<pre><code>class Node{\n  int i;\n  Node *left,*right;\n};\n\nint main()    {\n  Node* a = new Node; // somehow the object 'a' is initialised with its data members\n  delete a;\n}\n</code></pre>\n<p>What exactly does <code>delete a;</code> do behind the scenes? Like is \nthere any default destructor called upon or what? Also, as <code>a</code> contains left and right pointers, is the object <code>a-&gt;left</code> and <code>a-&gt;right</code> also deleted?\nWhat happens at the <strong>core machine level</strong>?</p>\n", "Title": "How does the 'delete' operator actually work behind the scenes in C++ in dynamic memory allocation (heap)?", "CreationDate": "2017-02-19T10:09:42.983", "LastActivityDate": "2017-02-20T00:25:57.760", "CommentCount": "2", "LastEditDate": "2017-02-19T10:16:45.923", "PostTypeId": "1", "LastEditorUserId": "1402846", "Id": "42325978", "Score": "2", "OwnerUserId": "7468779", "Tags": "<c++><c++11><heap-memory><delete-operator>", "AnswerCount": "4"}, "42326525": {"Id": "42326525", "PostTypeId": "2", "Body": "<p>c++ calls a default <strong>destructor</strong> when the scope of the object ends </p>\n<p>The purpose of <strong>delete</strong> is to return the memory (i.e free the memory) so it is available to the computer for use </p>\n<p>Basically when you allocate memory during runtime using <strong>New</strong> or something else it is your responsibility to free that memory after the Task is done \nIf you don't free memory and the pointer / object dies then the memory you used is wasted and the computer can not use that memory and this is called memory leak. </p>\n<p>If you lose too much memory through memory leak , your heap/free store won't have enough memory to run your Operating System and eventually you'll have to reboot the system </p>\n", "LastEditorUserId": "6738494", "LastActivityDate": "2017-02-19T11:25:14.900", "Score": "0", "CreationDate": "2017-02-19T11:13:16.880", "ParentId": "42325978", "CommentCount": "0", "OwnerUserId": "6738494", "LastEditDate": "2017-02-19T11:25:14.900"}, "bq_ids": {"n4140": {"so_42325978_42326111_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 400}, "so_42325978_42326111_8": {"length": 6, "quality": 0.6666666666666666, "section_id": 407}, "so_42325978_42326111_11": {"length": 55, "quality": 0.8461538461538461, "section_id": 407}, "so_42325978_42326111_9": {"length": 7, "quality": 0.7777777777777778, "section_id": 407}, "so_42325978_42326111_14": {"length": 53, "quality": 0.828125, "section_id": 7174}, "so_42325978_42326111_4": {"length": 15, "quality": 1.0, "section_id": 401}, "so_42325978_42326111_13": {"length": 41, "quality": 0.8723404255319149, "section_id": 7174}, "so_42325978_42326111_6": {"length": 15, "quality": 1.0, "section_id": 402}, "so_42325978_42326111_12": {"length": 30, "quality": 0.6666666666666666, "section_id": 7173}, "so_42325978_42326111_10": {"length": 10, "quality": 0.8333333333333334, "section_id": 407}, "so_42325978_42326111_3": {"length": 9, "quality": 1.0, "section_id": 401}}, "n3337": {"so_42325978_42326111_8": {"length": 5, "quality": 0.5555555555555556, "section_id": 398}, "so_42325978_42326111_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 391}, "so_42325978_42326111_9": {"length": 6, "quality": 0.6666666666666666, "section_id": 398}, "so_42325978_42326111_14": {"length": 53, "quality": 0.828125, "section_id": 6918}, "so_42325978_42326111_4": {"length": 15, "quality": 1.0, "section_id": 392}, "so_42325978_42326111_13": {"length": 41, "quality": 0.8723404255319149, "section_id": 6918}, "so_42325978_42326111_6": {"length": 15, "quality": 1.0, "section_id": 393}, "so_42325978_42326111_12": {"length": 30, "quality": 0.6666666666666666, "section_id": 6917}, "so_42325978_42326111_10": {"length": 9, "quality": 0.75, "section_id": 398}, "so_42325978_42326111_3": {"length": 9, "quality": 1.0, "section_id": 392}}, "n4659": {"so_42325978_42326111_8": {"length": 6, "quality": 0.6666666666666666, "section_id": 425}, "so_42325978_42326111_10": {"length": 10, "quality": 0.8333333333333334, "section_id": 425}, "so_42325978_42326111_3": {"length": 9, "quality": 1.0, "section_id": 419}, "so_42325978_42326111_14": {"length": 57, "quality": 0.890625, "section_id": 8682}, "so_42325978_42326111_4": {"length": 15, "quality": 1.0, "section_id": 419}, "so_42325978_42326111_13": {"length": 41, "quality": 0.8723404255319149, "section_id": 8682}, "so_42325978_42326111_6": {"length": 15, "quality": 1.0, "section_id": 420}, "so_42325978_42326111_12": {"length": 36, "quality": 0.8, "section_id": 8681}, "so_42325978_42326111_11": {"length": 55, "quality": 0.8461538461538461, "section_id": 425}, "so_42325978_42326111_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 417}, "so_42325978_42326111_9": {"length": 7, "quality": 0.7777777777777778, "section_id": 425}}}, "42327703": {"Id": "42327703", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42325978_42327703_0\">What exactly does <code>delete a;</code> do behind the scenes?</p>\n</blockquote>\n<p>It <em>probably</em> just goes to the location of the free store where the object pointed to by <code>a</code> is stored, and marks the memory as available for future allocations. <em>Perhaps</em> the memory is additionally zeroed out or otherwise tampered with if you have told your compiler to create a debug-friendly version of the program.</p>\n<p>Whatever the compiler does, the only <em>guaranteed</em> effect is that a subsequent <code>delete a</code> or an attempt to dereference <code>a</code> causes undefined behaviour.</p>\n<p>C++ defines a language, not an implementation.</p>\n<p>Applying the <em>as-if rule</em>, perhaps nothing happens at all because compiler optimisation has shown that this piece of code isn't needed to create the required observable behaviour of the program.</p>\n<blockquote>\n<p id=\"so_42325978_42327703_1\">Like is there any default destructor called upon or what?</p>\n</blockquote>\n<p>If you don't write a destructor, then the compiler will insert a <code>public</code> one automatically.</p>\n<blockquote>\n<p id=\"so_42325978_42327703_2\">Also, as <code>a</code> contains <code>left</code> and <code>right</code> pointers, is the object <code>a-&gt;left</code> and <code>a-&gt;right</code> also deleted?</p>\n</blockquote>\n<p>Careful with your wording. <code>a-&gt;left</code> and <code>a-&gt;right</code> <em>are</em> two objects, just like <code>a-&gt;i</code>. C++ uses the word \"object\" much more liberally than certain other programming languages.</p>\n<p>All three objects are deleted, yes. However, <code>a-&gt;left</code> and <code>a-&gt;right</code> each may or may not point to some other <code>Node</code> object. Those other <code>Node</code> objects are not deleted.</p>\n<p>After all, <strong>why should they?</strong> Who says that those two other <code>Node</code> objects are only pointed to by <code>a-&gt;left</code> and <code>a-&gt;right</code>? Consider this:</p>\n<pre><code>struct Node{\n  int i;\n  Node *left,*right;\n};\n\nint main()    {\n  Node* a = new Node;\n  Node l;\n  Node r;\n  a-&gt;left = &amp;l;\n  a-&gt;right = &amp;r;\n  delete a;\n}\n</code></pre>\n<p>If <code>delete</code> worked in a transitive way, then your code would attempt to delete the local objects <code>l</code> and <code>r</code> which aren't even allocated on the free store; this would be a disaster with undefined behaviour.</p>\n<blockquote>\n<p id=\"so_42325978_42327703_3\">What happens at the core machine level?</p>\n</blockquote>\n<p>C++ doesn't say what happens at the core machine level.</p>\n", "LastActivityDate": "2017-02-19T13:20:36.800", "CommentCount": "1", "CreationDate": "2017-02-19T13:20:36.800", "ParentId": "42325978", "Score": "0", "OwnerUserId": "3313064"}, "42326111": {"Id": "42326111", "PostTypeId": "2", "Body": "<h2>Nomenclature</h2>\n<p>According to the C++ standard <em>\u00a712.4 Destructors/p4,p6,p7,p8,p12 [class.dtor]</em> (<strong>Emphasis mine</strong>):</p>\n<blockquote>\n<p id=\"so_42325978_42326111_0\"><sup>4</sup> <strong>If a class has no user-declared destructor, a\n  destructor is implicitly declared as defaulted</strong> (8.4). An implicitly\n  declared destructor is an inline public member of its class.</p>\n<p id=\"so_42325978_42326111_1\"><sup>6</sup> <strong>A destructor is trivial if it is not user-provided</strong>\n  and if:</p>\n<p id=\"so_42325978_42326111_2\"><sup>(6.1)</sup> \u2014 the destructor is not virtual,</p>\n<p id=\"so_42325978_42326111_3\"><sup>(6.2)</sup> \u2014 all of the direct base classes of its class have\n  trivial destructors, and</p>\n<p id=\"so_42325978_42326111_4\"><sup>(6.3)</sup> \u2014 for all of the non-static data members of its class\n  that are of class type (or array thereof), each such class has a\n  trivial destructor. </p>\n<p id=\"so_42325978_42326111_5\">Otherwise, the destructor is non-trivial.</p>\n<p id=\"so_42325978_42326111_6\"><sup>7</sup> <strong>A destructor that is defaulted and not defined as\n  deleted is implicitly defined when it is odr-used</strong> (3.2) or when it\n  is explicitly defaulted after its first declaration.</p>\n<p id=\"so_42325978_42326111_7\"><sup>12</sup> <strong>A destructor is invoked implicitly</strong></p>\n<p id=\"so_42325978_42326111_8\"><sup>(12.1)</sup> \u2014 for a constructed object with static storage\n  duration (3.7.1) at program termination (3.6.4),</p>\n<p id=\"so_42325978_42326111_9\"><sup>(12.2)</sup> \u2014 for a constructed object with thread storage\n  duration (3.7.2) at thread exit,</p>\n<p id=\"so_42325978_42326111_10\"><sup>(12.3)</sup> \u2014 for a constructed object with automatic storage\n  duration (3.7.3) when the block in which an object is created exits\n  (6.7),</p>\n<p id=\"so_42325978_42326111_11\"><sup>(12.4)</sup> \u2014 for a constructed temporary object when its\n  lifetime ends (4.4, 12.2). In each case, the context of the invocation\n  is the context of the construction of the object. <strong>A destructor is\n  also invoked implicitly through use of a delete-expression (5.3.5) for\n  a constructed object allocated by a new-expression (5.3.4); the\n  context of the invocation is the delete-expression.</strong> [ Note: An array\n  of class type contains several subobjects for each of which the\n  destructor is invoked. \u2014 end note ] A destructor can also be invoked\n  explicitly. A destructor is potentially invoked if it is invoked or as\n  specified in 5.3.4, 12.6.2, and 15.1. A program is ill-formed if a\n  destructor that is potentially invoked is deleted or not accessible\n  from the context of the invocation.</p>\n</blockquote>\n<p><strong>DR;TL</strong></p>\n<p>In C++ if a <code>class</code>, <code>struct</code> or <code>union</code> doesn't have a user declared destructor, then the compiler will always implicitly declare one trivial destructor for it. That is, although you haven't declared a destructor for your <code>Node</code> class the compiler is obliged by the C++ standard to declare a trivial one for you.</p>\n<p>This implicitly declared trivial destructor will be defined once upon your class is <em>odr-used</em>. That is, when any expression anywhere in the program takes the address of or binds a reference directly to an object of your class.</p>\n<p>Calling <code>delete</code> upon a <code>Node</code> object that was previously allocated with <code>new</code> will evoke its implicitly defined destructor and the heap storage allocated for that object by <code>new</code> will be reclaimed (i.e., freed).</p>\n<p>Since the implicit declared destructor is trivial, any storage pointed by member pointers <code>left</code> and <code>right</code> will not be touched at all. Meaning that, if you've allocated any memory that is being pointed only by the <code>left</code> and <code>right</code> member pointers of a <code>Node</code> object. After calling delete upon this object the memory that was being pointed by member pointers <code>left</code> and <code>right</code> will be orphan (i.e., you'll have a memory leak).</p>\n<h2>What Happens At Core Machine Level</h2>\n<p>What happens at core machine level may vary from vendor to vendor, from operating system to operating system and from machine to machine as the core behaviour of a delete expression is not specified by the C++ standard. Any compiler vendor can do anything it feels like it to (e.g., optimizations), as long as the observable behaviour conforms with the C++ standard.</p>\n<p>More or less though, vendors are doing similar things. For example lets take into account the following piece of code:</p>\n<pre><code>class Node {\n  int i;\n  Node *left, *right;\n};\n\nint main() {\n  Node *n = new Node;\n  delete n;\n}\n</code></pre>\n<p>The generated assembly code for the above piece of code for GCC version 6.2 compiler is:</p>\n<pre><code>main:\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 16\n        mov     edi, 24\n        call    operator new(unsigned long)\n        mov     QWORD PTR [rbp-8], rax\n        mov     rax, QWORD PTR [rbp-8]\n        mov     esi, 24\n        mov     rdi, rax\n        call    operator delete(void*, unsigned long)\n        mov     eax, 0\n        leave\n        ret\n</code></pre>\n<p>In the assembly code generated for our simple example, the construction of the <code>n</code> object is represented by the code snippet below:</p>\n<pre><code>sub     rsp, 16\nmov     edi, 24\ncall    operator new(unsigned long)\nmov     QWORD PTR [rbp-8], rax\n</code></pre>\n<p>Since the object is trivially constructible the only thing the compiler does is allocation of memory for the object by calling the implicitly declared global operator <code>new</code>.</p>\n<p>The destruction process of the object is represented by the code snippet below:</p>\n<pre><code>rax, QWORD PTR [rbp-8]\nmov     esi, 24\nmov     rdi, rax\ncall    operator delete(void*, unsigned long)\n</code></pre>\n<p>Notice, that the destruction process is done in reverse order with respect the steps taken in the construction process. At the end the implicitly declared global operator <code>delete</code> is called to free the previously allocated memory.</p>\n<p>In our example neither a constructor nor a destructor is called since in our case the observable behaviour of the program doesn't change if they are not called.</p>\n<p>Now the rightfull question is where in heck <code>operator delete</code> is?</p>\n<p>In order to preserve the nomenclaturstic style of this answer lets quote the C++ standard from <code>\u00a73.7.4 Dynamic storage duration [basic.stc.dynamic]\\p1, p2</code> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_42325978_42326111_12\"><sup>1</sup> <strong>Objects can be created dynamically during program\n  execution (1.9), using new-expressions (5.3.4), and destroyed using\n  delete-expressions (5.3.5). A C++ implementation provides access to,\n  and management of, dynamic storage via the global allocation functions\n  operator new and operator new[] and the global deallocation functions\n  operator delete and operator delete[].</strong> [ Note: The non-allocating\n  forms described in 18.6.2.3 do not perform allocation or deallocation.\n  \u2014 end note ]</p>\n<p id=\"so_42325978_42326111_13\"><sup>2</sup> <strong>The library provides default definitions for the global\n  allocation and deallocation functions.</strong> Some global allocation and\n  deallocation functions are replaceable (18.6.2). A C++ program shall\n  provide at most one definition of a replaceable allocation or\n  deallocation function. Any such function definition replaces the\n  default version provided in the library (17.5.4.6). <strong>The following\n  allocation and deallocation functions (18.6) are implicitly declared\n  in global scope in each translation unit of a program.</strong></p>\n<pre><code>void* operator new(std::size_t); \nvoid* operator new(std::size_t, std::align_val_t); void operator delete(void*) noexcept; \nvoid operator delete(void*, std::size_t) noexcept;\nvoid operator delete(void*, std::align_val_t) noexcept;\nvoid operator delete(void*, std::size_t, std::align_val_t) noexcept;\nvoid* operator new[](std::size_t);\nvoid* operator new[](std::size_t, std::align_val_t);\nvoid operator delete[](void*) noexcept;\nvoid operator delete[](void*, std::size_t) noexcept;\nvoid operator delete[](void*, std::align_val_t) noexcept;\nvoid operator delete[](void*, std::size_t, std::align_val_t) noexcept;\n</code></pre>\n<p id=\"so_42325978_42326111_14\">These implicit declarations introduce only the function names operator\n  <code>new</code>, <code>operator new[]</code>, <code>operator delete</code>, and <code>operator delete[]</code>. [\n  Note: The implicit declarations do not introduce the names <code>std</code>,\n  <code>std::size_t</code>, <code>std::align_val_t</code>, or any other names that the library\n  uses to declare these names. Thus, a new-expression, delete-expression\n  or function call that refers to one of these functions without\n  including the header  is well-formed. However, referring to std\n  or std::size_t or std::align_val_t is ill-formed unless the name has\n  been declared by including the appropriate header. \u2014 end note ]\n  Allocation and/or deallocation functions may also be declared and\n  defined for any class (12.5).</p>\n</blockquote>\n<p>The answer is the delete operator is implicitly declared in global scope in each translation unit of your program.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2017-02-20T00:25:57.760", "Score": "6", "CreationDate": "2017-02-19T10:26:54.493", "ParentId": "42325978", "CommentCount": "2", "OwnerUserId": "2352671", "LastEditDate": "2017-02-20T00:25:57.760"}});