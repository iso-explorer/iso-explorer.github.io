post_cb({"bq_ids": {"n4140": {"so_20966681_20966744_1": {"length": 21, "quality": 0.75, "section_id": 7179}, "so_20966681_20966744_0": {"length": 8, "quality": 0.8, "section_id": 3337}}, "n3337": {"so_20966681_20966744_1": {"length": 20, "quality": 0.7142857142857143, "section_id": 6923}, "so_20966681_20966744_0": {"length": 8, "quality": 0.8, "section_id": 3207}}, "n4659": {"so_20966681_20966744_1": {"length": 21, "quality": 0.75, "section_id": 8687}, "so_20966681_20966744_0": {"length": 8, "quality": 0.8, "section_id": 4104}}}, "20966744": {"Id": "20966744", "PostTypeId": "2", "Body": "<p>Objects that are thrown are typically copied/moved to, or directly constructed in, a memory area reserved for them - distinct from the normal function call stack and \"heap\".  So, the address of the local <code>str</code> object in <code>some_function()</code> can't be expected to match the address of the string instance caught in <code>main()</code>.  This model allows the lifetimes of the thrown objects to be decoupled from the stack unwinding that happens until they're caught.  (It also means that it <strong><em>may</em></strong> be possible - you'd want to check your implementation documentation if you cared - to throw an exception even when the remaining stack and/or heap is insufficient to store the value thrown, though many exception objects use further dynamically storage - for example, for <code>std::string</code> objects with text longer than any internal short-string-optimisation buffer).</p>\n<p>See 15.1/4:</p>\n<blockquote>\n<p id=\"so_20966681_20966744_0\">The memory for the exception object is <strong>allocated in an unspecified way</strong>, except as noted in 3.7.4.1.</p>\n</blockquote>\n<p>In 3.7.4.1:</p>\n<blockquote>\n<p id=\"so_20966681_20966744_1\">[ Note: In particular, <strong>a global allocation function is not called to allocate storage for</strong> objects with static\n  storage duration (3.7.1), for objects or references with thread storage duration (3.7.2), for objects of type\n  std::type_info (5.2.8), or for <strong>an exception object</strong> (15.1). \u2014end note ]</p>\n</blockquote>\n", "LastEditorUserId": "410767", "LastActivityDate": "2014-01-07T08:29:22.640", "Score": "11", "CreationDate": "2014-01-07T08:08:41.537", "ParentId": "20966681", "CommentCount": "0", "OwnerUserId": "410767", "LastEditDate": "2014-01-07T08:29:22.640"}, "20966681": {"ViewCount": "209", "Body": "<p>I have doubt in C++ exception :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nvoid some_function()\n{\n    string str(\"Hello,World!\");\n    throw(str);\n}\n\nint main()\n{\n    try\n    {\n        some_function();\n    }\n    catch (string&amp; e)\n    {\n        cout &lt;&lt; e &lt;&lt; endl;\n        e = \"Hello, the world!\";\n        cout &lt;&lt; e &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>debug in my PC:</p>\n<ol>\n<li>in <code>some_function</code> the <code>str</code> addr: <code>0x003CF820</code></li>\n<li>int <code>main</code> the <code>e</code> addr: <code>0x003CF738</code></li>\n</ol>\n<p>I have three question,</p>\n<ol>\n<li>catch parameter is <code>string&amp;</code>, why we get diff addr in main() ?  </li>\n<li>is <code>str</code> not a temp value ? why we can use a temp value reference ?</li>\n<li>where is <code>e</code> store in memory ?</li>\n</ol>\n<p>can some one help me ? thanks .</p>\n", "AcceptedAnswerId": "20966744", "Title": "where C++ exception parameter store in memory?", "CreationDate": "2014-01-07T08:04:29.003", "Id": "20966681", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-01-07T08:29:22.640", "Score": "4", "OwnerUserId": "802815", "Tags": "<c++>", "AnswerCount": "1"}});