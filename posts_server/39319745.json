post_cb({"bq_ids": {"n4140": {"so_39319745_39319745_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 311}, "so_39319745_39320518_0": {"length": 17, "quality": 1.0, "section_id": 6045}, "so_39319745_39319745_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6078}}, "n3337": {"so_39319745_39319745_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 302}, "so_39319745_39320518_0": {"length": 17, "quality": 1.0, "section_id": 5813}, "so_39319745_39319745_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5846}}, "n4659": {"so_39319745_39319745_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 319}, "so_39319745_39320518_0": {"length": 17, "quality": 1.0, "section_id": 7544}, "so_39319745_39319745_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7574}}}, "39320518": {"Id": "39320518", "PostTypeId": "2", "Body": "<p>This is a bug. The following code compiles fine:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f() { }\n\nint main() {\n    auto fptr = &amp;f&lt;int&gt;;\n    return sizeof(fptr);\n}\n</code></pre>\n<hr>\n<p>Note that at first I didn't read the question attentively. I was under the impression that the function <code>f&lt;int&gt;</code> is indeed overloaded, for example as below:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f() { }\n\ntemplate&lt;typename T&gt;\nvoid f(T) { }\n\nint main() {\n    sizeof(&amp;f&lt;int&gt;);\n}\n</code></pre>\n<p>Under such reading of the question I prepared the following answer, which I still want to share with the community:</p>\n<hr>\n<p>I wouldn't qualify it as a bug.</p>\n<p>The argument for qualifying it as a bug is the following - all function pointers have the same size, so why does it matter which function is meant inside the <code>sizeof</code> operator?</p>\n<p>I am going to defeat that argument.</p>\n<p>First of all, it starts from the wrong premise. The C++ standard only guarantees that</p>\n<blockquote>\n<p id=\"so_39319745_39320518_0\">converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to\n  <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are function types) and back to its original type yields the original pointer value</p>\n</blockquote>\n<p>which doesn't necessarily mean that the size of pointers to functions of different types is the same. I admit, however, that in practice this is true.</p>\n<p>Next, even if we accept the premise and logic behind the argument, then we must also accept the claim that the following program should also compile without any problem:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f() { }\n\ntemplate&lt;typename T&gt;\nvoid f(T) { }\n\nint main() {\n    auto fptr = &amp;f&lt;int&gt;;\n    return sizeof(fptr);\n    // fptr is not used anywhere else, so the compiler must not\n    // whine about the ambiguity on its declaration line\n}\n</code></pre>\n<p>Continuing in this manner, we would argue that compilation ambiguities should never be reported provided that they are eliminated by subsequent code.</p>\n</hr></hr>", "LastActivityDate": "2016-09-04T19:08:12.610", "CommentCount": "0", "CreationDate": "2016-09-04T19:08:12.610", "ParentId": "39319745", "Score": "2", "OwnerUserId": "6394138"}, "39319745": {"ViewCount": "87", "Body": "<p>As mentioned by <a href=\"http://eel.is/c++draft/expr.sizeof#3\" rel=\"nofollow\">[5.3.3/3]</a> (<em>expr.sizeof</em>, working draft):</p>\n<blockquote>\n<p id=\"so_39319745_39319745_0\">The\u00a0sizeof\u00a0operator can be applied to a pointer to a function, but shall not be applied directly to a function.</p>\n</blockquote>\n<p>The following minimal, working example compiles fine:</p>\n<pre><code>void f() { }\n\nint main() {\n    sizeof(&amp;f);\n}\n</code></pre>\n<p>I would expect that also the one below would work:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f() { }\n\nint main() {\n    sizeof(&amp;f&lt;int&gt;);\n}\n</code></pre>\n<p>Anyway, even if it compiles with clang (v3.8), it does not using GCC (v6.1).<br>\nThe error is:</br></p>\n<blockquote>\n<p id=\"so_39319745_39319745_1\">error: address of overloaded function with no contextual type information</p>\n</blockquote>\n<p>I suspect it's a bug of GCC (I will open a ticket if confirmed).<br>\nAm I right or I'm missing something here and GCC is right indeed?</br></p>\n<hr>\n<p>Meanwhile, I opened <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=77474\" rel=\"nofollow\">an issue</a> to GCC.</p>\n</hr>", "AcceptedAnswerId": "39320518", "Title": "sizeof and function template: sizeof(&f) vs sizeof(&f<int>)", "CreationDate": "2016-09-04T17:42:35.143", "Id": "39319745", "CommentCount": "8", "LastEditDate": "2016-09-04T19:34:52.527", "PostTypeId": "1", "LastEditorUserId": "4987285", "LastActivityDate": "2016-09-04T19:34:52.527", "Score": "3", "OwnerUserId": "4987285", "Tags": "<c++><templates><gcc><clang><language-lawyer>", "AnswerCount": "1"}});