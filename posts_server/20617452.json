post_cb({"20619962": {"ParentId": "20617452", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Here's a minimal example exposing the problem:</p>\n<pre><code>struct noncopyable\n{\n    noncopyable(int) {};\n    noncopyable(noncopyable const&amp;) = delete;\n};\n\nint main()\n{\n    noncopyable f0 = {1};\n    noncopyable f1 = 1;\n}\n</code></pre>\n<p>Although the two initializations of <code>f0</code> and <code>f1</code> have the same form (are both <em>copy-initialization</em>), <code>f0</code> uses list-initialization which directly calls a constructor, whereas the initialization of <code>f1</code> is essentially equivalent to <code>foo f1 = foo(1);</code> (create a temporary and copy it to <code>f1</code>).</p>\n<p>This slight difference also manifests in the array case:</p>\n<pre><code>noncopyable f0[] = {{1}, {2}, {3}, {4}};\nnoncopyable f1[] = {1, 2, 3, 4};\n</code></pre>\n<p>Aggregate-initialization is defined as copy-initialization of the members [dcl.init.aggr]/2</p>\n<blockquote>\n<p id=\"so_20617452_20619962_0\">Each member is copy-initialized from the corresponding <em>initializer-clause</em>.</p>\n</blockquote>\n<p>Therefore, <code>f1</code> essentially says <code>f1[0] = 1, f1[1] = 2, ..</code> (this notation shall describe the initializations of the array elements), which has the same problem as above. OTOH, <code>f0[0] = {1}</code> (as an initialization) uses list-initialization again, which directly calls the constructor and does not (semantically) create a temporary.</p>\n<hr>\n<p><strike>You could make your converting constructors <code>explicit</code> ;) this could avoid some confusion.</strike></p>\n<p>Edit: Won't work, copy-initialization from a braced-init-list may not use an explicit constructor. That is, for</p>\n<pre><code>struct expl\n{\n    explicit expl(int) {};\n};\n</code></pre>\n<p>the initialization <code>expl e = {1};</code> is ill-formed. For the same reason, <code>expl e[] = {{1}};</code> is ill-formed. <code>expl e {1};</code> is well-formed, still.</p>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-12-17T15:51:58.263", "Id": "20619962", "Score": "2", "CreationDate": "2013-12-16T20:09:56.700", "LastActivityDate": "2013-12-17T15:51:58.263"}, "20617452": {"CommentCount": "8", "ViewCount": "416", "PostTypeId": "1", "LastEditorUserId": "572743", "CreationDate": "2013-12-16T17:53:02.407", "LastActivityDate": "2013-12-18T10:25:22.860", "Title": "Initialization of member array objects avoiding move constructor", "AcceptedAnswerId": "20619962", "LastEditDate": "2013-12-18T10:25:22.860", "Id": "20617452", "Score": "2", "Body": "<p>I'm trying to create and initialize a class that contains a  member array of a non-trivial class, which contains some state and (around some corners) <code>std::atomic_flag</code>. As of C++11 one should be able to initialize member arrays.</p>\n<p>The code (stripped down to minimum) looks like this:</p>\n<pre><code>class spinlock\n{\n    std::atomic_flag flag;\n    bool try_lock() { return !flag.test_and_set(std::memory_order_acquire); }\npublic:\n    spinlock() : flag(ATOMIC_FLAG_INIT){};\n    void lock()     { while(!try_lock()) ; }\n    void unlock()   { flag.clear(std::memory_order_release); }\n};\n\nclass foo\n{\n    spinlock lock;\n    unsigned int state;\npublic:\n    foo(unsigned int in) : state(in) {}\n};\n\nclass bar\n{\n    foo x[4] = {1,2,3,4}; // want each foo to have different state\npublic:\n    //...\n};\n</code></pre>\n<p>If I understand the compiler output correctly, this seems <strong>not</strong> to construct the member array, but to construct temporaries and invoke the move/copy constructor, which subsequently calls move constructors in sub-classes, and that one happens to be deleted in <code>std::atomic_flag</code>. The compiler output that I get (gcc 4.8.1) is:</p>\n<pre><code>[...] error: use of deleted function 'foo::foo(foo&amp;&amp;)'\nnote: 'foo::foo(foo&amp;&amp;)' is implicitly deleted because the default definition would be ill-formed\nerror: use of deleted function 'spinlock::spinlock(spinlock&amp;&amp;)'\nnote: 'spinlock::spinlock(spinlock&amp;&amp;)' is implicitly deleted because [...]\nerror: use of deleted function 'std::atomic_flag::atomic_flag(const std::atomic_flag&amp;)'\nIn file included from [...]/i686-w64-mingw32/4.8.1/include/c++/atomic:41:0\n[etc]\n</code></pre>\n<p>If I remove the array and instead just put a single <code>foo</code> member inside <code>bar</code>, I can properly initialize it using standard constructor initializers, or using the new in-declaration initialization, no problem whatsoever. Doing the same thing with a member array fails with the above error, no matter what I try.</p>\n<p>I don't really mind that array elements are apparently constructed as temporaries and then moved rather than directly constructed, but the fact that it doesn't compile is obviously somewhat of a showstopper.</p>\n<p>Is there a way I either force the compiler to construct (not move) the array elements, or a way I can work around this?</p>\n", "Tags": "<gcc><c++11><initialization><move><member-variables>", "OwnerUserId": "572743", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20617452_20619962_0": {"section_id": 3299, "quality": 1.0, "length": 5}}, "n3337": {"so_20617452_20619962_0": {"section_id": 3169, "quality": 1.0, "length": 5}}, "n4659": {"so_20617452_20619962_0": {"section_id": 4065, "quality": 0.8, "length": 4}}}});