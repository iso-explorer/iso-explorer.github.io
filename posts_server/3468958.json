post_cb({"3469023": {"ParentId": "3468958", "CommentCount": "2", "Body": "<p>The only change <code>static_cast</code> should make to a pointer is for word-alignment.  So, in theory, of <code>myObjectVoid</code> pointed to the last byte in memory, it's possible that it might be 'aligned-up\" to 0, but I don't see that as a realistic concern.</p>\n", "OwnerUserId": "12725", "PostTypeId": "2", "Id": "3469023", "Score": "0", "CreationDate": "2010-08-12T14:55:31.257", "LastActivityDate": "2010-08-12T14:55:31.257"}, "3469375": {"ParentId": "3468958", "CommentCount": "1", "Body": "<p>No, the second check is not reasonable. It is not possible for <code>static_cast</code> to turn a non-null pointer into a null pointer. The only thing <code>static_cast</code> may change about the supplied value in your case (being a pointer) is to adjust the address. Otherwise it's strictly concerned with advising the rest of the compiler's type analysis that the result of the expression should be treated as the target type. For a pointer, that means that dereferencing finds the right address within the target object, and that increment and decrement strides are appropriate to the type's size.</p>\n", "OwnerUserId": "31818", "PostTypeId": "2", "Id": "3469375", "Score": "0", "CreationDate": "2010-08-12T15:33:35.657", "LastActivityDate": "2010-08-12T15:33:35.657"}, "3469264": {"ParentId": "3468958", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No. If the pointer refers to a valid object, and the conversion is valid, then the result will also refer to a valid object, so it won't be null. If either is invalid, then the code is incorrect and the result is undefined. So the only way for valid usage to give a null result is to start with null.</p>\n<p>In the specific case of converting between object pointers and void pointers, the standard has this to say (5.2.9/10):</p>\n<blockquote>\n<p id=\"so_3468958_3469264_0\">A value of type \"pointer to object\" converted to \"pointer to <code>void</code>\" and back to the original pointer type will have its original value.</p>\n</blockquote>\n<p>and this (4.10/3)</p>\n<blockquote>\n<p id=\"so_3468958_3469264_1\">The result of converting a \"pointer to T\" to a \"pointer to <code>void</code>\" points to the start of the storage location where the object of type T resides</p>\n</blockquote>\n<p>so the original and final object pointers will be the same, and the <code>void</code> pointer will be null if and only if the object pointers are.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2010-08-12T15:32:00.993", "Id": "3469264", "Score": "5", "CreationDate": "2010-08-12T15:20:50.917", "LastActivityDate": "2010-08-12T15:32:00.993"}, "3469335": {"ParentId": "3468958", "CommentCount": "0", "Body": "<p>static_cast can change the pointer value, if you cast between object parts on different offsets: </p>\n<pre><code>class A{ int x; }; class B{ int y; };\nclass C : A,B {};\n\nC *c=new C(); \n\nB *b=c; \n// The B part comes after the A part in C. Pointer adjusted\n\nC *c2=static_cast&lt;C*&gt;(b); \n// Pointer gets adjusted back, points to the beginning of the C part\n</code></pre>\n<p>However, \"The null pointer value (4.10) is converted to the null pointer value of the\ndestination type.\" (5.2.9-8), i.e. <em>if</em> <code>c</code> is <code>NULL</code>, then <code>b</code> is also <code>NULL</code> (and not adjusted) and thus <code>c2</code> is set to <code>NULL</code>. The whole thing means: if static casting a non-NULL <code>myObjectVoid</code> yields <code>NULL</code>, then the value of <code>myObjectVoid</code> was obtained by circumventing the type system somehow. And it means, that the compiler might throw your second check away because \"it can't happen anyway\". </p>\n", "OwnerUserId": "385433", "PostTypeId": "2", "Id": "3469335", "Score": "7", "CreationDate": "2010-08-12T15:28:53.120", "LastActivityDate": "2010-08-12T15:28:53.120"}, "bq_ids": {"n4140": {"so_3468958_3469264_0": {"section_id": 6044, "quality": 0.75, "length": 12}}, "n3337": {"so_3468958_3469264_1": {"section_id": 37, "quality": 0.9285714285714286, "length": 13}, "so_3468958_3469264_0": {"section_id": 5812, "quality": 0.75, "length": 12}}, "n4659": {"so_3468958_3469264_0": {"section_id": 7543, "quality": 0.75, "length": 12}}}, "3468958": {"CommentCount": "2", "ViewCount": "5622", "CreationDate": "2010-08-12T14:49:07.993", "LastActivityDate": "2010-08-12T15:59:04.243", "Title": "Can static_cast turn a non-null pointer into a null pointer?", "AcceptedAnswerId": "3469335", "PostTypeId": "1", "Id": "3468958", "Score": "6", "Body": "<p>I need to write code for a callback function (it will be called from within ATL, but that's not really important):</p>\n<pre><code>HRESULT callback( void* myObjectVoid )\n{\n    if( myObjectVoid == 0 ) {\n       return E_POINTER;\n    }\n    CMyClass* myObject = static_cast&lt;CMyClass*&gt;( myObjectVoid );\n    return myObject-&gt;CallMethod();\n}\n</code></pre>\n<p>here the <code>void*</code> is guaranteed to be a pointer to <code>CMyClass</code>, so <code>static_cast</code> is legal. My concern is the code must be as portable (to newer versions of Visual C++ at least) as possible. So to be super-paranoic I'm inclined to check the <code>CMyClass*</code> pointer as well - I mean what if it turns out to be null?</p>\n<pre><code>    if( myObjectVoid == 0 ) {\n       return E_POINTER;\n    }\n    CMyClass* myObject = static_cast&lt;CMyClass*&gt;( myObjectVoid );\n    if( myObject == 0 ) {\n       return E_POINTER;\n    }\n</code></pre>\n<p>Is the second check reasonable? Is it possible for <code>static_cast</code> to turn a non-null pointer into a null pointer?</p>\n", "Tags": "<c++><visual-c++><pointers><static-cast>", "OwnerUserId": "57428", "AnswerCount": "4"}});