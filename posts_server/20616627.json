post_cb({"20616721": {"ParentId": "20616627", "CommentCount": "0", "Body": "<p>You'll need to give the class and the class template different names or put them into different namespaces: classes and class templates cannot have exactly the same name.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "20616721", "Score": "0", "CreationDate": "2013-12-16T17:17:12.000", "LastActivityDate": "2013-12-16T17:17:12.000"}, "20616709": {"ParentId": "20616627", "CommentCount": "0", "Body": "<p>As the error says, a class template can't have the same name as a non-template.</p>\n<p>You will have to rename either the base class or the template.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "20616709", "Score": "0", "CreationDate": "2013-12-16T17:16:32.153", "LastActivityDate": "2013-12-16T17:16:32.153"}, "20616771": {"ParentId": "20616627", "CommentCount": "1", "Body": "<p>Unfortunately, there is no way of doing so. I think the relevant portion of the standard is:</p>\n<blockquote>\n<p id=\"so_20616627_20616771_0\">A class template shall not have the same name as any other template,\n  class, function, object, enumeration, enumerator, namespace, or type\n  in the same scope (3.3), except as specified in (14.5.4). Except that\n  a function template can be overloaded either by (non-template)\n  functions with the same name or by other function templates with the\n  same name (14.8.3), a template name declared in namespace scope or in\n  class scope shall be unique in that scope.</p>\n</blockquote>\n<p>However, the methods that should accept every type of <code>DataBuffer</code> could be made template too, so that inheriting from a common base would become unnecessary.</p>\n", "OwnerUserId": "2528057", "PostTypeId": "2", "Id": "20616771", "Score": "1", "CreationDate": "2013-12-16T17:19:50.557", "LastActivityDate": "2013-12-16T17:19:50.557"}, "20616627": {"CommentCount": "1", "ViewCount": "91", "CreationDate": "2013-12-16T17:12:46.073", "LastActivityDate": "2013-12-16T17:19:50.557", "Title": "Use non-templated version of class as parent", "AcceptedAnswerId": "20616771", "PostTypeId": "1", "Id": "20616627", "Score": "0", "Body": "<p>I am working on porting a project from C# to C++ and am having an issue when using templates, I need to have both a non-templated and a templated version of a class with one parented to another, ie:</p>\n<pre><code>class DataBuffer // Holds generic databuffer functions (getting size in bytes etc)\n{\npublic:\n    int32 getVal() { return 10; }\n};\n\ntemplate &lt;typename T&gt;\nclass DataBuffer&lt;T&gt; : public DataBuffer // Able to retrieve data as a type...\n{\npublic:\n    int32 getSizeOfT() { return sizeof(T); }\n};\n</code></pre>\n<p>I have methods that accept any type of DataBuffer as a parameter, so templating the entire class is not possible, is there any way of doing this without renaming the base class?</p>\n<p>Any help would be greatly appreciated.</p>\n<p>EDIT:\nThis code does not compile, and throws the following error at compile time:</p>\n<pre><code>error C2989: 'DataBuffer' : class template has already been declared as a non-class template\n</code></pre>\n", "Tags": "<c++><visual-studio><templates>", "OwnerUserId": "3105639", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_20616627_20616771_0": {"section_id": 52, "quality": 0.9318181818181818, "length": 41}}, "n3337": {"so_20616627_20616771_0": {"section_id": 47, "quality": 0.9318181818181818, "length": 41}}, "n4659": {"so_20616627_20616771_0": {"section_id": 53, "quality": 0.9318181818181818, "length": 41}}}});