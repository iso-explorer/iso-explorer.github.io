post_cb({"4009509": {"ParentId": "4009463", "CommentCount": "0", "Body": "<p>When you dynamically allocate memory using <code>operator new</code>, you have the guarantee that:</p>\n<blockquote>\n<p id=\"so_4009463_4009509_0\">The pointer returned shall be suitably aligned so that it can be converted to a pointer of any complete object type and then used to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation function)  (C++03 3.7.3.1/2).</p>\n</blockquote>\n<p><code>vector</code> does not create an array of char; it uses an allocator.  The default allocator uses <code>::operator new</code> to allocate memory.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "4009509", "Score": "4", "CreationDate": "2010-10-24T17:43:33.960", "LastActivityDate": "2010-10-24T17:43:33.960"}, "4009551": {"ParentId": "4009463", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_4009463_4009551_0\">An alignment requirement for an object\n  of type X where sizeof(X) == n is at\n  least the requirement that address of\n  X be divisible by n or something like\n  that</p>\n</blockquote>\n<p>No. The alignment requirement of a type is always a factor of its size, but need not be equal to its size. It is usually equal to the greatest of the alignment requirements of all the members of a class.</p>\n<p>An array of 5M char, on its own account, need only have an alignment requirement of 1, the same as the alignment requirement of a single <code>char</code>.</p>\n<p>So, the text you quote about the alignment of memory allocated via global operator <code>new</code>, (and <code>malloc</code> has a similar although IIRC not identical requirement) in effect means that a large allocation must obey the most stringent alignment requirement of any type in the system. Further to that, implementations often exclude large SIMD types from this, and require that memory for SIMD be specially allocated. This is slightly dubious, but I think they justify it on the basis that non-standard, extension types can impose arbitrary special requirements.</p>\n<p>So in practice the number which you think is 5000000 is often 4 :-)</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-10-24T18:03:42.260", "Id": "4009551", "Score": "3", "CreationDate": "2010-10-24T17:55:21.277", "LastActivityDate": "2010-10-24T18:03:42.260"}, "4009463": {"CommentCount": "0", "AcceptedAnswerId": "4009551", "CreationDate": "2010-10-24T17:30:58.773", "LastActivityDate": "2010-10-24T18:03:42.260", "PostTypeId": "1", "ViewCount": "3244", "FavoriteCount": "2", "Title": "Alignment of char arrays", "Id": "4009463", "Score": "5", "Body": "<p>How is STL vector usually implemented? It has a raw storage of char[] which it occasionally resizes by a certain factor and then calls placement new when an element is pushed_back (a very interesting grammatical form I should note  - linguists should study such verb forms as pushed_back :)<br>\nAnd then there are the alignment requirements. So a natural question arises how can I call a placement new on a char[] and be sure the alignment requirements are satisfied. So I searched the C++ standard of 2003 for the word \"alignment\" and found these:</br></p>\n<p><em>Paragraph 3.9 Clause 5</em></p>\n<p><strong>Object types have alignment requirements (3.9.1, 3.9.2). The alignment of a complete object type is an implementation-defined integer value representing a number of bytes; an object is allocated at an address that meets the alignment requirements of its object type.</strong></p>\n<p><em>Paragraph 5.3.4 Clause 10:</em> </p>\n<p><strong>A new-expression passes the amount of space requested to the allocation function as the first argument of type std::size_t. That argument shall be no less than the size of the object being created; it may be greater than the size of the object being created only if the object is an array. For arrays of char and unsigned char, the difference between the result of the new-expression and the address returned by the allocation function shall be an integral multiple of the most stringent alignment requirement (3.9) of any object type whose size is no greater than the size of the array being created. [Note: Because allocation functions are assumed to return pointers to storage that is appropriately aligned for objects of any type, this constraint on array allocation overhead permits the common idiom of allocating character arrays into which objects of other types will later be placed. ]</strong></p>\n<p>These two give a perfectly satisfactory answer for my above question, but...</p>\n<p>Statement1:<br>\nAn alignment requirement for an object of type X where sizeof(X) == n is at least the requirement that address of X be divisible by n or something like that (put all the architecture-dependent things into the \"or something like that\").</br></p>\n<p><em><strong>Question1:</strong></em></p> Please confirm, refine, or deny the above statement1.\n<p>Statement2: If statement1 is correct then from the second quote in the standard it follows that an array of 5000000 chars is allocated at an address divisible by 5000000 which is completely unnecessary if I just need the array of char as such, not as a raw storage for possible placement of other objects.</p>\n<p><em><strong>Question2:</strong></em></p> So, are the chances of successfully allocating 1000 chars really lower than 500 shorts(provided short is 2 bytes)? Is it practically a problem?\n", "Tags": "<c++><alignment>", "OwnerUserId": "469935", "AnswerCount": "3"}, "4009495": {"ParentId": "4009463", "CommentCount": "16", "Body": "<p>Q1: Alignment isn't related to size.</p>\n<p>Q2: Theoretically yes, but you will hardly find an architecture that has a type with such huge alignment. SSE requires 16 bytes alignment (the biggest I have seen).</p>\n", "OwnerUserId": "211659", "PostTypeId": "2", "Id": "4009495", "Score": "1", "CreationDate": "2010-10-24T17:38:47.863", "LastActivityDate": "2010-10-24T17:38:47.863"}, "bq_ids": {"n4140": {"so_4009463_4009509_0": {"section_id": 7177, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_4009463_4009509_0": {"section_id": 6921, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_4009463_4009509_0": {"section_id": 8685, "quality": 0.8888888888888888, "length": 24}}}});