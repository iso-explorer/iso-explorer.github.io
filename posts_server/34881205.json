post_cb({"34882387": {"ParentId": "34881205", "CommentCount": "0", "Body": "<p>A C++ standard header is allowed to include any other C++ header. Therefore you can get implementation-dependent access to <code>std::bad_alloc</code> without including <code>&lt;new&gt;</code>, and to <code>std::size_t</code> with including <code>&lt;cstddef&gt;</code> et al. I'm too lazy to look it up in your edition of the standard, but in the N4296 draft it's in \u00a717.6.5.2:</p>\n<blockquote>\n<p id=\"so_34881205_34882387_0\">A C++ header may include other C++ headers.</p>\n</blockquote>\n<p>You can try this with a compiler.</p>\n<pre><code>int main()\n{\n    std::size_t x;    // error\n    std::bad_alloc y; // error\n}\n</code></pre>\n<p>Now let's add a completely unrelated <code>#include</code>:</p>\n<pre><code>#include &lt;complex&gt;\n\nint main()\n{\n    std::size_t x;    // probably not an error anymore, depends on compiler\n    std::bad_alloc y; // probably not an error anymore, depends on compiler\n}\n</code></pre>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "34882387", "Score": "3", "CreationDate": "2016-01-19T16:48:14.300", "LastActivityDate": "2016-01-19T16:48:14.300"}, "34883435": {"ParentId": "34881205", "CommentCount": "2", "Body": "<p>Your quote says that those global functions exist and are implicitly declared as described.  Thus when you invoke <code>new</code>, the global function in the standard library is called.  The implementation of the global function <code>new</code> is the one throwing <code>std::bad_alloc</code>, and that implementation had access to <code>&lt;new&gt;</code> at the time of compilation, thus knows how to throw an <code>std::bad_alloc</code>.  Your code doesn't need to know what a <code>std::bad_alloc</code> is, unless you're trying to catch it.  But other than catching it, this is like you calling any other function from some other library that may be throwing some arbitrary exception.  You don't need to know about the details of that exception unless you're trying to catch it, but that doesn't stop the callee from being able to throw it.</p>\n", "OwnerUserId": "1987633", "PostTypeId": "2", "Id": "34883435", "Score": "4", "CreationDate": "2016-01-19T17:37:29.567", "LastActivityDate": "2016-01-19T17:37:29.567"}, "34881533": {"ParentId": "34881205", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The name <code>std::size_t</code> is just a typedef for some other integer type, perhaps <code>unsigned long</code> or <code>unsigned long long</code>. The compiler knows the real parameter type for <code>new</code>, even if the name <code>size_t</code> isn't visible.</p>\n<p>Similar for <code>bad_alloc</code>. The runtime code throwing a <code>bad_alloc</code> surely includes the <code>&lt;new&gt;</code> header, even if your program does not.</p>\n", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2016-01-19T17:43:55.930", "Id": "34881533", "Score": "4", "CreationDate": "2016-01-19T16:08:29.660", "LastActivityDate": "2016-01-19T17:43:55.930"}, "34881205": {"CommentCount": "3", "ViewCount": "233", "PostTypeId": "1", "LastEditorUserId": "3313064", "CreationDate": "2016-01-19T15:54:06.720", "LastActivityDate": "2016-01-19T17:43:55.930", "Title": "New throws bad_alloc despite <new> header not being defined?", "AcceptedAnswerId": "34883435", "LastEditDate": "2016-01-19T16:22:10.993", "Id": "34881205", "Score": "5", "Body": "<p>How is it that a <code>new</code> expression in a program can throw a <code>bad_alloc</code> error despite there being no <code>#include &lt;new&gt;</code> (since this error <a href=\"http://en.cppreference.com/w/cpp/memory/new/bad_alloc\" rel=\"nofollow\">is defined in the <code>&lt;new&gt;</code> header</a>)?</p>\n<p>From 3.7.4. of N3337:</p>\n<blockquote>\n<p id=\"so_34881205_34881205_0\">The library provides default definitions for the global allocation and deallocation functions. Some global allocation and deallocation functions are replaceable (18.6.1). A C++ program shall provide at most one definition of a replaceable allocation or deallocation function. Any such function definition replaces the default version provided in the library (17.6.4.6). The following allocation and deallocation functions (18.6) are implicitly declared in global scope in each translation unit of a program.</p>\n<pre><code>void* operator new(std::size_t);\n\nvoid* operator new[](std::size_t);\n\nvoid operator delete(void*);\n\nvoid operator delete[](void*);\n</code></pre>\n<p id=\"so_34881205_34881205_1\">These implicit declarations introduce only the function names <code>operator new</code>, <code>operator new[]</code>, <code>operator delete</code>, and <code>operator delete[]</code>. [ <strong>Note: The implicit declarations do not introduce the names <code>std</code>, <code>std::size_t</code>, or any other names that the library uses to declare these names. Thus, a new-expression,\n  delete-expression or function call that refers to one of these functions without including the header <code>&lt;new&gt;</code> is well-formed. However, referring to <code>std</code> or <code>std::size_t</code> is ill-formed unless the name has been declared by including the appropriate header. \u2014end note</strong> ] Allocation and/or deallocation functions can also be declared and defined for any class</p>\n</blockquote>\n<p>This still isn't clear to me. The implicit declarations use <code>std::size_t</code> but do not introduce them (and the same must be the case for <code>bad_alloc</code>)? And <code>std::size_t</code> doesn't need to be introduced before a <code>new</code> expression can be used? Can any sense be made of how this is, or do I have to take it at face value?</p>\n", "Tags": "<c++><c++11><bad-alloc>", "OwnerUserId": "5627734", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_34881205_34881205_0": {"section_id": 7174, "quality": 0.8723404255319149, "length": 41}, "so_34881205_34882387_0": {"section_id": 6331, "quality": 1.0, "length": 5}, "so_34881205_34881205_1": {"section_id": 7174, "quality": 0.8870967741935484, "length": 55}}, "n3337": {"so_34881205_34881205_0": {"section_id": 6918, "quality": 0.8723404255319149, "length": 41}, "so_34881205_34882387_0": {"section_id": 6088, "quality": 1.0, "length": 5}, "so_34881205_34881205_1": {"section_id": 6918, "quality": 0.8870967741935484, "length": 55}}, "n4659": {"so_34881205_34881205_0": {"section_id": 8682, "quality": 0.8723404255319149, "length": 41}, "so_34881205_34882387_0": {"section_id": 7841, "quality": 1.0, "length": 5}, "so_34881205_34881205_1": {"section_id": 8682, "quality": 0.8870967741935484, "length": 55}}}});