post_cb({"13734444": {"ParentId": "13734282", "CommentCount": "0", "Body": "<p>In C++, an object is uniquely determined by a pair of data: its address and its type.</p>\n<p>As you rightly observed, both <code>C</code> and <code>D</code> contain two distinct subobjects <code>A</code> for which this must be true. However, depending on how you lay out <code>B</code> in memory, you can see how it might not be possible to put both <code>A</code>-subobjects at different addresses within an 8-byte structure.</p>\n<p>Why don't you print out the actual numerical addresses of the subobjects?</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "13734444", "Score": "1", "CreationDate": "2012-12-05T23:32:26.547", "LastActivityDate": "2012-12-05T23:32:26.547"}, "13734434": {"ParentId": "13734282", "CommentCount": "0", "Body": "<p>The standard definitely mandates that the address of each object of the same type is different. The relevant clause is 5.10 [expr.eq] paragraph 1:</p>\n<blockquote>\n<p id=\"so_13734282_13734434_0\">Two pointers of the same type compare equal if and only if they are both null, both point to the same function, or both represent the same address (3.9.2).</p>\n</blockquote>\n<p>This is needed to, well, distinguish the two objects. Objects have both a value and an identity. For a base class subobject it is reasonable to have the same address as the containing class. For a member of a class, you can distinguish the identity of the two objects by their type, i.e., it is OK for them to have the same address. For two object of the same type you'd still need something to distinguish the objects for their identity.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "13734434", "Score": "3", "CreationDate": "2012-12-05T23:31:21.237", "LastActivityDate": "2012-12-05T23:31:21.237"}, "13734282": {"CommentCount": "1", "AcceptedAnswerId": "13734434", "PostTypeId": "1", "LastEditorUserId": "1707560", "CreationDate": "2012-12-05T23:16:58.860", "LastActivityDate": "2012-12-05T23:32:26.547", "LastEditDate": "2012-12-05T23:21:30.817", "ViewCount": "102", "FavoriteCount": "1", "Title": "References to the same base classes must have separate offsets in memory", "Id": "13734282", "Score": "8", "Body": "<p>I've discovered some inconsistencies between compilers with this program,</p>\n<pre><code>struct A {\n};\n\nstruct B : public A {\n    float m;\n};\n\nstruct C : public A {\n    B b;\n    float n;\n};\n\nstruct D : public A {\n    float n;\n    B b;\n};\n\nstatic_assert(sizeof(A) == 1, \"\");\nstatic_assert(sizeof(B) == 4, \"\");\nstatic_assert(sizeof(C) == 8, \"\"); // most compilers say this is 12\nstatic_assert(sizeof(D) == 8, \"\");\n</code></pre>\n<p>Most compilers assert on sizeof(C) == 8 saying that the sizeof(C) is actually 12. The only compiler I've found that doesn't and says it's 8 is Microsoft Visual Studio 2010.</p>\n<p>The reason I've been told, by someone smarter then me, is that there are two separate references of A within B that need to retain individual offsets different from one another. First, the A derived from C is at offset 0 and the second A inside member b can not be at the same offset as the first A at 0 so 4 bytes of padding is inserted.</p>\n<p>As most compiler's have implemented this behavior I was wondering what case do you need to make sure both A's have different references? Looking for some intuition on why this is the case?</p>\n<p>Someone said it may be a condition required by the standard and we were curious on what is the reason for it?</p>\n<p>Thank you</p>\n", "Tags": "<c++><sizeof><diamond-problem>", "OwnerUserId": "381452", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13734282_13734366_0": {"section_id": 6981, "quality": 0.9583333333333334, "length": 23}, "so_13734282_13734434_0": {"section_id": 6155, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_13734282_13734366_0": {"section_id": 6727, "quality": 0.9583333333333334, "length": 23}, "so_13734282_13734434_0": {"section_id": 5917, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_13734282_13734366_0": {"section_id": 8479, "quality": 0.9583333333333334, "length": 23}, "so_13734282_13734434_0": {"section_id": 7652, "quality": 0.6111111111111112, "length": 11}}}, "13734366": {"ParentId": "13734282", "CommentCount": "4", "Body": "<p>Yes, this is mentioned in 10p8:</p>\n<blockquote>\n<p id=\"so_13734282_13734366_0\">A base class subobject may be of zero size (Clause 9); however, <strong>two\n  subobjects that have the same class type and that belong to the same\n  most derived object must not be allocated at the same address (5.10)</strong>.</p>\n</blockquote>\n<p>In <code>C</code> you have two <code>A</code>s, one is inherited and the other is part of <code>B</code>. Microsoft aggressively and wrongly employs the empty base class optimization here when it shouldn't. I believe it is known bug, but it really is hard to find the bug report on Microsoft Connect.</p>\n", "OwnerUserId": "906773", "PostTypeId": "2", "Id": "13734366", "Score": "3", "CreationDate": "2012-12-05T23:24:27.353", "LastActivityDate": "2012-12-05T23:24:27.353"}});