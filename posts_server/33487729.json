post_cb({"33487977": {"Id": "33487977", "PostTypeId": "2", "Body": "<p>Templates are a special case in C++ regarding multiple definitions, as long as they're the same. See the \"One Definition Rule\" section of <a href=\"https://isocpp.org/std/the-standard\" rel=\"nofollow\">the C++ standard</a>:</p>\n<blockquote>\n<p id=\"so_33487729_33487977_0\">There can be more than one definition of a class type (Clause 9),\n  enumeration type (7.2), inline function with external linkage (7.1.2),\n  class template (Clause 14), non-static function template (14.5.6),\n  static data member of a class template (14.5.1.3), member function of\n  a class template (14.5.1.1), or template specialization for which some\n  template parameters are not specified (14.7, 14.5.5) in a program\n  provided that each definition appears in a different translation unit,\n  and provided the definitions satisfy the following requirements. ....</p>\n</blockquote>\n<p>This is then followed by a list of conditions that make sure the template definitions are identical across translation units.</p>\n<p>This specific quote is from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">the 2014 working draft</a>, section 3.2 (\"One Definition Rule\"), subsection 6.</p>\n", "LastActivityDate": "2015-11-02T22:12:05.850", "CommentCount": "1", "CreationDate": "2015-11-02T22:12:05.850", "ParentId": "33487729", "Score": "0", "OwnerUserId": "37020"}, "33487918": {"Id": "33487918", "PostTypeId": "2", "Body": "<p>A header that causes linking problems when included in multiple translation units is one that will (attempt to) define some <em>object</em> (not just, for an obvious example, a type) in each source file where it's included.</p>\n<p>For example, if you had something like: <code>int f = 0;</code> in a header, then each source file into which it was included would attempt to define <code>f</code>, and when you tried to link the object files together you'd get a complaint about multiple definitions of <code>f</code>.</p>\n<p>The \"technique\" used in this header is simple: it doesn't attempt to define any actual objects. Rather, it includes some typedefs, and the definition of one fairly large class--but not any instances of that class or any instance of anything else either. That class includes a number of member functions, but they're all defined inside the function definition, which implicitly defines them as inline functions (so defining separately in each translation unit in which they're used is not only allowed, but required).</p>\n<p>In short, the header only defines <em>types</em>, not objects, so there's nothing there to cause linker collisions when it's included in multiple source files that are linked together.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2015-11-02T22:56:59.063", "Score": "2", "CreationDate": "2015-11-02T22:08:22.247", "ParentId": "33487729", "CommentCount": "2", "OwnerUserId": "179910", "LastEditDate": "2015-11-02T22:56:59.063"}, "bq_ids": {"n4140": {"so_33487729_33487977_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 7043}}, "n3337": {"so_33487729_33487977_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 6788}}, "n4659": {"so_33487729_33487977_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 8540}}}, "33487926": {"Id": "33487926", "PostTypeId": "2", "Body": "<p>Headers only include libraries like <a href=\"http://www.boost.org/\" rel=\"nofollow\">Boost C++ Libraries</a> use (mostly) stand-alone templates and as so are compiled at compile-time and don't require any linkage to binary libraries (that would need separate compilation).  One designed to <em>never</em> need linkage is the great <a href=\"https://github.com/philsquared/Catch\" rel=\"nofollow\">Catch</a></p>\n", "LastActivityDate": "2015-11-02T22:08:43.220", "CommentCount": "0", "CreationDate": "2015-11-02T22:08:43.220", "ParentId": "33487729", "Score": "0", "OwnerUserId": "1312406"}, "33487729": {"ViewCount": "122", "Body": "<p>After reading <a href=\"https://stackoverflow.com/questions/14909997/why-arent-my-include-guards-preventing-recursive-inclusion-and-multiple-symbol\">this question</a> I thought I understood everything, but then I saw <a href=\"https://github.com/zaphoyd/websocketpp/blob/master/websocketpp/connection.hpp\" rel=\"nofollow noreferrer\">this file</a> from a popular header-only library.</p>\n<p>The library uses the <code>#ifndef</code> line, but the SO question points out that this is NOT adequate protection against multiple definition errors in multiple TUs.</p>\n<p>So one of the following must be true:</p>\n<ol>\n<li>It is possible to avoid multiple definition linker errors in ways other than described in the SO question. Perhaps the library is using techniques not mentioned in to the other SO question that are worthy of additional explanation.</li>\n<li>The library assumes you won't include its header files in more than translation unit -- this seems fragile since a robust library shouldn't make this assumption on its users.</li>\n</ol>\n<p>I'd appreciate having some light shed on this seemingly simple curiosity.</p>\n", "AcceptedAnswerId": "33487918", "Title": "How does this header-only library guard against linker problems?", "CreationDate": "2015-11-02T21:56:25.367", "Id": "33487729", "CommentCount": "8", "LastEditDate": "2017-05-23T10:27:12.550", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-02T23:54:12.770", "Score": "0", "OwnerUserId": "3758484", "Tags": "<c++>", "AnswerCount": "5"}, "33487903": {"Id": "33487903", "PostTypeId": "2", "Body": "<p>If the header defines items, as opposed to just declaring them, then it's possible to include it in more than one translation unit (i.e. cpp file) and have multiple definitions and hence linker errors.</p>\n<p>I've used boost's unit test framework which is header only.  I include a specified header in only one of my own cpp files to get my project to compile.  But I include <strong>other</strong> unit test headers in other cpp files which presumably use the items that are defined in the specified header.</p>\n", "LastActivityDate": "2015-11-02T22:07:12.790", "CommentCount": "2", "CreationDate": "2015-11-02T22:07:12.790", "ParentId": "33487729", "Score": "0", "OwnerUserId": "1320751"}, "33489153": {"Id": "33489153", "PostTypeId": "2", "Body": "<p>This header file can indeed be included in difference source files without causing \"multiple symbol definition\" errors.</p>\n<p>This happens because it is fine to have multiple identically named symbols in different object files as long as these symbols are either weak or local.</p>\n<p>Let's take a closer look at the header file. It (potentially) defines several objects like this <code>helper</code>:</p>\n<pre><code>static int const helper[] = {0,7,8,13};\n</code></pre>\n<p>Each translation unit that includes this header file will have this <code>helper</code> in it. However, there will be no \"multiple symbol definition\" errors, since <code>helper</code> is <code>static</code> and thus has internal linkage. The symbols created for <code>helper</code>s will be local and linker will just happily put them all in the resulting executable.</p>\n<p>The header file also defines a class template <code>connection</code>. But it is also okay. Class templates can be defined multiple times in different translation units.</p>\n<p>In fact, even regular class types can be defined multiple times (I've noticed that you've asked about this in the comments). Symbols created for member functions are usually weak symbols. Once again, weak symbols don't cause \"multiple symbol definition\" errors, because they can be redefined. Linker will just keep redefining weak symbols with names he has already seen until there will be just one symbol per member function left.</p>\n<p>There are also other cases, where certain things (like inline functions and enumerations) can be defined several times in different translation units (see \u00a73.2). And mechanisms of achieving this can be different (see class templates and inline functions). But the general rule is not to place stuff with global linkage in header files. As long as you follow this rule, you're really unlikely to stumble upon multiple symbol definitions problems.</p>\n<p>And yes, include guards have nothing to do with this.</p>\n", "LastActivityDate": "2015-11-02T23:54:12.770", "CommentCount": "0", "CreationDate": "2015-11-02T23:54:12.770", "ParentId": "33487729", "Score": "0", "OwnerUserId": "4656786"}});