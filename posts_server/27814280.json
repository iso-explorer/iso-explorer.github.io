post_cb({"bq_ids": {"n4140": {"so_27814280_27814376_0": {"length": 17, "quality": 1.0, "section_id": 458}}, "n3337": {"so_27814280_27814376_0": {"length": 17, "quality": 1.0, "section_id": 449}}, "n4659": {"so_27814280_27814376_0": {"length": 17, "quality": 1.0, "section_id": 481}}}, "27814376": {"Id": "27814376", "PostTypeId": "2", "Body": "<p>When you comment out both the lines that explicitly <code>default</code> and <code>delete</code> the copy constructor, the compiler is free to implicitly generate a move constructor (and move assignment operator) for you.</p>\n<p>By explicitly <code>default</code>ing or <code>delete</code>ing the copy constructor, you suppress the implicit generation of the move constructor. </p>\n<p>From N3337, <em>\u00a712.8/9</em> <strong>[class.copy]</strong></p>\n<blockquote>\n<p id=\"so_27814280_27814376_0\">If the definition of a class <code>X</code> does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if <br/>\n  \u2014 <code>X</code> does not have a user-declared copy constructor, <br/>\n  \u2014 <code>...</code></p>\n</blockquote>\n<p>When the move constructor is no longer generated, the return value from <code>toButterfly()</code> must be copied, but that fails regardless of whether you've defaulted or deleted the copy constructor.</p>\n<p>In the case where you <code>default</code> the copy constructor, the compiler is unable to generate a default copy constructor implementation because of the presence of the <code>unique_ptr</code> data member (which is not copyable).</p>\n<p>When you <code>delete</code> the copy constructor, if it gets selected via overload resolution, that is an error.</p>\n<hr>\n<p>You shouldn't have to explicitly delete the copy constructor since, as explained above, the presence of the <code>unique_ptr</code> data member implicitly deletes it, but if you want to do that, then you'll need to also explicitly default the move constructor (and the move assignment operator too, if you want move assignment to work)</p>\n<pre><code>ButterflyWithBigResource(ButterflyWithBigResource&amp;&amp;) = default;\nButterflyWithBigResource&amp; operator=(ButterflyWithBigResource&amp;&amp;) = default;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/cc026c4c8f235287\" rel=\"noreferrer\">Live demo</a></p>\n</hr>", "LastEditorUserId": "241631", "LastActivityDate": "2015-01-07T07:31:53.903", "Score": "7", "CreationDate": "2015-01-07T07:25:33.697", "ParentId": "27814280", "CommentCount": "5", "OwnerUserId": "241631", "LastEditDate": "2015-01-07T07:31:53.903"}, "27814280": {"ViewCount": "1752", "Body": "<p>My questions concerns how to return an object that does not have a copy constructor. As an example let's imagine that I have some <code>bigResource</code> that sits in the heap, and let's say I keep track of it using a <code>unique_ptr</code>. Now suppose I give ownership of this resource to a caterpillar. Then I have a <code>CaterpillarWithBigResource</code>. Now at some point, this <code>CaterpillarWithBigResource</code> is going to turn into a <code>ButterflyWithBigResource</code>, so the <code>Caterpillar</code> object will have to transfer ownership to the <code>Butterfly</code> object. </p>\n<p>I have written the following code to model the situation:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass ButterflyWithBigResource {\npublic:\n\n    //    If I uncomment just this line, I get an error\n    //    ButterflyWithBigResource(const ButterflyWithBigResource&amp; other) = default;\n\n    //    If I uncomment just this line, I get an error\n    //    ButterflyWithBigResource(const ButterflyWithBigResource&amp; other) = delete;\n\n    //   With both above lines commented out, I get no errors, and the program runs fine.\n\n    ButterflyWithBigResource(std::unique_ptr&lt;int&gt;&amp;&amp; bigResource) :\n    bigResource(std::move(bigResource)) {\n\n    }\n\n    const int&amp; getResource() {\n        return *bigResource;\n    }\n\nprivate:\n    std::unique_ptr&lt;int&gt; bigResource;\n};\n\nclass CaterpillarWithBigResource {\npublic:\n\n    CaterpillarWithBigResource(int bigResource) :\n    bigResource(new int(bigResource)) {\n\n    }\n\n    ButterflyWithBigResource toButterfly() &amp;&amp; {\n        return ButterflyWithBigResource(std::move(bigResource));\n    }\nprivate:\n    std::unique_ptr&lt;int&gt; bigResource;\n};\n\n/*\n * \n */\nint main(int argc, char** argv) {\n    CaterpillarWithBigResource caterpillarWithBigResource(5);\n    ButterflyWithBigResource butterflyWithBigResource(std::move(caterpillarWithBigResource).toButterfly());\n    std::cout &lt;&lt; butterflyWithBigResource.getResource() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Notice that neither the <code>Caterpillar</code> nor the <code>Butterfly</code> have default copy constructors, because they each have a <code>unique_ptr</code>. However, I wouldn't expect this to be problem, so only move constructors should necessary. After all, I am only transferring ownership from the <code>Caterpillar</code> to the <code>Butterfly</code>.</p>\n<p>In fact when I compile the program with <code>g++ -c -g -std=c++11 -MMD -MP -MF</code> using <code>g++</code> version <code>4.8.2</code> it works just fine. </p>\n<p>But now the weird thing is if I remind the compiler that the <code>Butterfly</code>'s copy constructor is deleted by adding the line <code>ButterflyWithBigResource(const ButterflyWithBigResource&amp; other) = delete;</code>, the program no longer compiles, and the compiler complains that copy constructor is deleted, so that I can't return the <code>Butterfly</code> in the <code>toButterfly</code> method.</p>\n<p>If I then try to tell it that everything is ok by instead having the line <code>ButterflyWithBigResource(const ButterflyWithBigResource&amp; other) = default;</code>, I again get the same error.</p>\n<p>What I want to happen is for the <code>Butterfly</code> constructed in the <code>toButterfly</code> method to be moved to <code>toButterfly</code>'s return address, and then later used as the argument of <code>Butterfly</code>'s move constructor when constructing <code>butterflyWithBigResource</code> in <code>main()</code>. Is there a way to make this happen? </p>\n", "AcceptedAnswerId": "27814376", "Title": "How to return an object with no copy constructor", "CreationDate": "2015-01-07T07:18:32.163", "Id": "27814280", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-01-07T07:25:53.170", "LastEditorUserId": "241631", "LastActivityDate": "2015-01-07T07:31:53.903", "Score": "7", "OwnerUserId": "3211274", "Tags": "<c++><c++11><copy-constructor><move-semantics><move-constructor>", "AnswerCount": "1"}});