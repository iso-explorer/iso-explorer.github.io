post_cb({"29632309": {"CommentCount": "2", "ViewCount": "92", "PostTypeId": "1", "LastEditorUserId": "4193063", "CreationDate": "2015-04-14T16:11:40.377", "LastActivityDate": "2015-04-15T08:48:00.100", "Title": "c++ method as template argument", "AcceptedAnswerId": "29633003", "LastEditDate": "2015-04-15T08:48:00.100", "Id": "29632309", "Score": "4", "Body": "<p>I am trying to specialize std::unordered_map for a class X with a custom hash and a custom equality. The problem is that both the equality and hash functions do not depend only on the object(s) of class X but also on data in another (fixed) object of another class Y. Here is a toy example (with only the hash function) of what I want to do:</p>\n<pre><code>#include &lt;unordered_map&gt;\nusing namespace std;\nstruct Y {\n  bool b;\n  struct X {\n    size_t i;\n  };\n  size_t hash(const X &amp;x) {\n    return x.i + b;\n  }\n  unordered_map&lt;X, int, hash&gt; mymap;\n};\n</code></pre>\n<p>The problem is that the function hash in the template specialization is a method and the compiler complains (\"call to non-static member function without an object argument\"). What I want is that y.mymap uses y.hash(). Any way to do this?</p>\n<p>Note that in the real code Y is also a template, in case it matters.</p>\n<p>Thanks!</p>\n<p>EDIT: To clarify, instead of the boolean b in my code I have a vector with data that is needed in comparing objects of type X. Some data is added when an X is created, so the vector is not constant, but the data for a given X does not change after it is added, so the hash for a given X never changes (so in a sense it depends only on X as required for a hash). The main reason I use this approach is to save memory since this data is a lot and is usually shared.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "4193063", "AnswerCount": "2"}, "29632634": {"ParentId": "29632309", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Unfortunately what you want to do is not legal. See 17.6.3.5/Table 26:</p>\n<blockquote>\n<p id=\"so_29632309_29632634_0\"><code>h(k)</code> The value returned shall depend only on the argument k.</p>\n</blockquote>\n<p>It's pretty clear that you aren't allowed to have the hash depend on a member of <code>Y</code> as well as <code>X</code>.</p>\n<p>EDIT: Just in case you meant for <code>b</code> to be const in your <code>Y</code> class there is a solution (I didn't compile this yet, I will if I get a chance):</p>\n<pre><code>struct Y\n{\n    explicit Y(bool config) : b(config), hash_(config), mymap(0, hash_) { }\n    const bool b;\n\n    struct X\n    {\n        size_t i;\n    };\n\n    struct Hash\n    {\n        explicit Hash(bool b) : b_(b) { }\n        size_t operator()(const X&amp; x) const\n        {\n            return x.i + b_;\n        }\n\n    private:\n        bool b_;\n    };\n\n    Hash hash_;\n    unordered_map&lt;X, int, Hash&gt; mymap;\n};\n</code></pre>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2015-04-14T16:46:25.703", "Id": "29632634", "Score": "2", "CreationDate": "2015-04-14T16:29:03.743", "LastActivityDate": "2015-04-14T16:46:25.703"}, "bq_ids": {"n4140": {"so_29632309_29632634_0": {"section_id": 6288, "quality": 0.8, "length": 4}}, "n3337": {"so_29632309_29632634_0": {"section_id": 6048, "quality": 0.8, "length": 4}}, "n4659": {"so_29632309_29632634_0": {"section_id": 7795, "quality": 0.8, "length": 4}}}, "29633003": {"ParentId": "29632309", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You can use <code>function&lt;size_t(X const&amp;)&gt;</code> and e.g. <code>bind</code>, but as type erasure is not necessary in this case, here is a simpler solution:</p>\n<pre><code>struct Y {\n    bool b;\n    struct X {\n        size_t i;\n        bool operator==(X x) const {return i == x.i;}\n    };\n    size_t hash(const X &amp;x) {\n      return x.i + b;\n    }\n\n    struct Hasher {\n        Y* this_;\n        template &lt;typename T&gt;\n        auto operator()(T&amp;&amp; t) const\n          -&gt; decltype(this_-&gt;hash(std::forward&lt;T&gt;(t))) {\n            return    this_-&gt;hash(std::forward&lt;T&gt;(t));\n        }\n    };\n\n    unordered_map&lt;X, int, Hasher&gt; mymap;\n\n    Y() : b(false),\n          mymap(0, {this}) {}\n};\n</code></pre>\n<p>As mentioned by @dyp in the comments, you have to be careful with special member functions since we implicitly store <code>this</code> in <code>mymap</code> - i.e. the compiler-generated definitions would copy the <code>this_</code> pointer. An example implementation of the move constructor could be</p>\n<pre><code>Y(Y&amp;&amp; y) : b(y.b), mymap(std::make_move_iterator(std::begin(y.mymap)),\n                         std::make_move_iterator(std::end  (y.mymap)), 0, {this}) {}\n</code></pre>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-14T17:59:34.263", "Id": "29633003", "Score": "2", "CreationDate": "2015-04-14T16:48:11.930", "LastActivityDate": "2015-04-14T17:59:34.263"}});