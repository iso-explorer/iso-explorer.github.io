post_cb({"19013071": {"CommentCount": "1", "AcceptedAnswerId": "19013921", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-09-25T19:01:03.757", "LastActivityDate": "2013-09-26T09:40:22.697", "LastEditDate": "2013-09-25T19:49:37.790", "ViewCount": "445", "FavoriteCount": "1", "Title": "template method and default template argument", "Id": "19013071", "Score": "9", "Body": "<p>My problem can be resumed by the following piece of code:</p>\n<pre><code>template &lt;typename T&gt; struct C2;\n\ntemplate &lt;typename T&gt; \nstruct C1\n{\n  template &lt;typename Type,\n        template &lt;typename Ti&gt; class Container = C2&gt;\n  void m() {}\n};\n\n\ntemplate &lt;typename T&gt; \nstruct C2\n{\n  template &lt;typename Type = int,\n        template &lt;typename Ti&gt; class Container = C2&gt; // &lt;-- Here is the problem!\n  void m() {}\n\n};\n</code></pre>\n<p>The gnu compiler, version 4.8.1 fails with the following message:</p>\n<pre><code>test-temp.C:16:47: error: invalid use of type \u2018C2&lt;T&gt;\u2019 as a default value for a template template-parameter\n      template &lt;typename Ti&gt; class Container = C2&gt; \n</code></pre>\n<p>It refers to default template parameter C2 for the the method C2::m.</p>\n<p>Apparently (it is my opinion), the compiler is seeing <code>C2&lt;T&gt;</code> as default parameter instead of <code>C2</code> (without <code>&lt;T&gt;</code>). So, when it finds the instruction it fails because type <code>C2&lt;T&gt;</code> does not match with <code>Container</code>.</p>\n<p>However, clang++, just for exactly the same code, compiles fine!</p>\n<p>My questions:</p>\n<ol>\n<li>Which compiler has the truth? </li>\n<li>Is there some alternative for expressing the same sense with the current version of gnu compiler?</li>\n</ol>\n<p>Thanks in advance</p>\n<p>Leandro</p>\n", "Tags": "<c++><templates><c++11><default-arguments><scope-resolution>", "OwnerUserId": "1561081", "AnswerCount": "2"}, "19013921": {"ParentId": "19013071", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I think Clang is correct, and g++ is in error, quote from the draft Standard (bold emphasis is mine)</p>\n<p><strong>14.6.1 Locally declared names [temp.local]</strong></p>\n<blockquote>\n<p id=\"so_19013071_19013921_0\">1 Like normal (non-template) classes, class templates have an\n  injected-class-name (Clause 9). The injectedclass-name can be used as\n  a template-name or a type-name. When it is used with a\n  template-argument-list, <strong>as a template-argument for a template\n  template-parameter</strong>, or as the \ufb01nal identi\ufb01er in the\n  elaborated-typespeci\ufb01er of a friend class template declaration, it\n  refers to the class template itself. Otherwise, it is equivalent to\n  the template-name followed by the template-parameters of the class\n  template enclosed in &lt;&gt;.</p>\n</blockquote>\n<p>You can use the <code>::</code> scope resolution operator to beat g++ into submission</p>\n<pre><code>template &lt;typename T&gt; \nstruct C2\n{\n  template &lt;typename Type = int,\n        template &lt;typename Ti&gt; class Container = ::C2&gt; \n                                              // ^^ &lt;-- here is the solution!\n  void m() {}\n\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/500aac62d9227415\"><strong>Live Example</strong></a>.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-09-25T19:55:37.917", "Id": "19013921", "Score": "9", "CreationDate": "2013-09-25T19:47:10.530", "LastActivityDate": "2013-09-25T19:55:37.917"}, "bq_ids": {"n4140": {"so_19013071_19013921_0": {"section_id": 179, "quality": 0.8947368421052632, "length": 34}}, "n3337": {"so_19013071_19013921_0": {"section_id": 173, "quality": 0.8947368421052632, "length": 34}}, "n4659": {"so_19013071_19013921_0": {"section_id": 184, "quality": 0.8947368421052632, "length": 34}}}, "19024335": {"ParentId": "19013071", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>So does the 14.6.1  reference in TemplateRex's answer mean that G++ is correct (and Clang and VC++ are wrong) to accept this, since it uses X as the template argument to a template template parameter?</p>\n<pre><code>template&lt; template&lt; typename &gt; class T &gt;\nclass factory { };\n\ntemplate&lt; typename T &gt;\nclass X\n{\n      friend class factory&lt; X &gt;;  // ***\n};\n\nint main()\n{\n}\n</code></pre>\n<p>In this example G++ treats X as the name of the class template, whereas Clang and VC++ treat it as the injected class name.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2013-09-26T09:40:22.697", "Id": "19024335", "Score": "0", "CreationDate": "2013-09-26T09:26:44.007", "LastActivityDate": "2013-09-26T09:40:22.697"}});