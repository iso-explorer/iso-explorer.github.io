post_cb({"bq_ids": {"n4140": {"so_44241289_44241651_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 6204}}, "n3337": {"so_44241289_44241651_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5964}}, "n4659": {"so_44241289_44241651_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7707}}}, "44242188": {"Id": "44242188", "PostTypeId": "2", "Body": "<p>Yes, there's a faster way to read lines and create strings.</p>\n<p>Query the file size, then load it into a buffer. Then iterate over the buffer replacing the newlines with nuls and storing the pointer to the next line.</p>\n<p>It will be quite a bit faster if, as is likely, your platform has a call to load a file into memory. </p>\n", "LastActivityDate": "2017-05-29T12:11:39.063", "CommentCount": "1", "CreationDate": "2017-05-29T12:11:39.063", "ParentId": "44241289", "Score": "1", "OwnerUserId": "3310281"}, "44241289": {"ViewCount": "348", "Body": "<p>There is a large text file of 6.53 GiB. Each line of it can be a data line or comment line. Comment lines are usually short, less than 80 characters, while a data line contains more than 2 million characters and is variable-length.</p>\n<p><strong>Considering each data line needs to be dealt with as a unit, is there a simple way to read lines safe and fast in C++?</strong></p>\n<p><strong>safe</strong> (safe for variable-length data lines): The solution is as easy to use as <code>std::getline()</code>. Since the length is changing, it is hoped to avoid extra memory management.</p>\n<p><strong>fast</strong>: The solution can achieve as fast as <code>readline()</code> in <code>python 3.6.0</code>, or even as fast as <code>fgets()</code> of <code>stdio.h</code>.</p>\n<p><strong>A Pure C solution is welcomed.</strong> The interface for further processing is provided both in C and C++.</p>\n<hr>\n<p><strong>UPDATE 1</strong>: Thanks to short but invaluable comment from <a href=\"https://stackoverflow.com/users/841108/basile-starynkevitch\">Basile Starynkevitch</a>, the perfect solution comes up: <a href=\"http://man7.org/linux/man-pages/man3/getline.3.html\" rel=\"nofollow noreferrer\"><code>POSIX getline()</code></a>. Since further processing only involves converting from character to number and does not use many features of string class, a char array would be sufficient in this application.</p>\n<hr>\n<p><strong>UPDATE 2</strong>: Thanks to comments from <a href=\"https://stackoverflow.com/users/620382/zulan\">Zulan</a> and <a href=\"https://stackoverflow.com/users/3807729/galik\">Galik</a>, who both report comparable performance among <code>std::getline()</code>, <code>fgets()</code> and <code>POSIX getline()</code>, another possible solution is to use a better standard library implementation such as <code>libstdc++</code>. Moreover, here is a <a href=\"http://info.prelert.com/blog/stdgetline-is-the-poor-relation\" rel=\"nofollow noreferrer\">report</a> claiming that the Visual C++ and libc++ implementations of <code>std::getline</code> is not well optimised.</p>\n<p>Moving from <code>libc++</code> to <code>libstdc++</code> changes the results a lot. With libstdc++ 3.4.13 / Linux 2.6.32 on a different platform, <code>POSIX getline()</code>, <code>std::getline()</code> and <code>fgets()</code> show comparable performance. At the beginning, codes were run under the default settings of clang in Xcode 8.3.2 (8E2002), thus <code>libc++</code> is used.</p>\n<hr>\n<p>More details and some efforts (very long):</p>\n<p><code>getline()</code> of <code>&lt;string&gt;</code> can handle arbitrary long lines but is a bit slow. Is there an alternative in C++ for <code>readline()</code> in python?</p>\n<pre><code>// benchmark on Mac OS X with libc++ and SSD:\nreadline() of python                         ~550 MiB/s\n\nfgets() of stdio.h, -O0 / -O2               ~1100 MiB/s\n\ngetline() of string, -O0                      ~27 MiB/s\ngetline() of string, -O2                     ~150 MiB/s\ngetline() of string + stack buffer, -O2      ~150 MiB/s\n\ngetline() of ifstream, -O0 / -O2             ~240 MiB/s\nread() of ifstream, -O2                      ~340 MiB/s\n\nwc -l                                        ~670 MiB/s\n\ncat data.txt | ./read-cin-unsync              ~20 MiB/s\n\ngetline() of stdio.h (POSIX.1-2008), -O0    ~1300 MiB/s\n</code></pre>\n<ul>\n<li><p>Speeds are rounded very roughly, only to show the magnitude, and all code blocks are run several times to assure that the values are representative.</p></li>\n<li><p>'-O0 / -O2' means the speeds are very similar for both optimization levels</p></li>\n<li><p>Codes are shown as follows.</p></li>\n</ul>\n<hr>\n<blockquote>\n<p id=\"so_44241289_44241289_0\"><code>readline()</code> of python</p>\n</blockquote>\n<pre><code># readline.py\n\nimport time\nimport os\n\nt_start = time.perf_counter()\n\nfname = 'data.txt'\nfin = open(fname, 'rt')\n\ncount = 0\n\nwhile True:\n    l = fin.readline()\n    length = len(l)\n    if length == 0:     # EOF\n        break\n    if length &gt; 80:     # data line\n        count += 1\n\nfin.close()\n\nt_end = time.perf_counter()\ntime = t_end - t_start\n\nfsize = os.path.getsize(fname)/1024/1024   # file size in MiB\nprint(\"speed: %d MiB/s\" %(fsize/time))\nprint(\"reads %d data lines\" %count)\n\n# run as `python readline.py` with python 3.6.0\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_44241289_44241289_1\"><code>fgets()</code> of <code>stdio.h</code></p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[]){\n  clock_t t_start = clock();\n\n  if(argc != 2) {\n    fprintf(stderr, \"needs one input argument\\n\");\n    return EXIT_FAILURE;\n  }\n\n  FILE* fp = fopen(argv[1], \"r\");\n  if(fp == NULL) {\n    perror(\"Failed to open file\");\n    return EXIT_FAILURE;\n  }\n\n  // maximum length of lines, determined previously by python\n  const int SIZE = 1024*1024*3;\n  char line[SIZE];\n\n  int count = 0;\n  while(fgets(line, SIZE, fp) == line) {\n    if(strlen(line) &gt; 80) {\n      count += 1;\n    }\n  }\n\n  clock_t t_end = clock();\n\n  const double fsize = 6685;  // file size in MiB\n\n  double time = (t_end-t_start) / (double)CLOCKS_PER_SEC;\n\n  fprintf(stdout, \"takes %.2f s\\n\", time);\n  fprintf(stdout, \"speed: %d MiB/s\\n\", (int)(fsize/time));\n  fprintf(stdout, \"reads %d data lines\\n\", count);\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_44241289_44241289_2\"><code>getline()</code> of <code>&lt;string&gt;</code></p>\n</blockquote>\n<pre><code>// readline-string-getline.cpp\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n  clock_t t_start = clock();\n\n  if(argc != 2) {\n    fprintf(stderr, \"needs one input argument\\n\");\n    return EXIT_FAILURE;\n  }\n\n  // manually set the buffer on stack\n  const int BUFFERSIZE = 1024*1024*3;   // stack on my platform is 8 MiB\n  char buffer[BUFFERSIZE];\n  ifstream fin;\n  fin.rdbuf()-&gt;pubsetbuf(buffer, BUFFERSIZE);\n  fin.open(argv[1]);\n\n  // default buffer setting\n  // ifstream fin(argv[1]);\n\n  if(!fin) {\n    perror(\"Failed to open file\");\n    return EXIT_FAILURE;\n  }\n\n  // maximum length of lines, determined previously by python\n  const int SIZE = 1024*1024*3;\n  string line;\n  line.reserve(SIZE);\n\n  int count = 0;\n  while(getline(fin, line)) {\n    if(line.size() &gt; 80) {\n      count += 1;\n    }\n  }\n\n  clock_t t_end = clock();\n\n  const double fsize = 6685;  // file size in MiB\n\n  double time = (t_end-t_start) / (double)CLOCKS_PER_SEC;\n\n  fprintf(stdout, \"takes %.2f s\\n\", time);\n  fprintf(stdout, \"speed: %d MiB/s\\n\", (int)(fsize/time));\n  fprintf(stdout, \"reads %d data lines\\n\", count);\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_44241289_44241289_3\"><code>getline()</code> of <code>ifstream</code></p>\n</blockquote>\n<pre><code>// readline-ifstream-getline.cpp\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n  clock_t t_start = clock();\n\n  if(argc != 2) {\n    fprintf(stderr, \"needs one input argument\\n\");\n    return EXIT_FAILURE;\n  }\n\n  ifstream fin(argv[1]);\n  if(!fin) {\n    perror(\"Failed to open file\");\n    return EXIT_FAILURE;\n  }\n\n  // maximum length of lines, determined previously by python\n  const int SIZE = 1024*1024*3;\n  char line[SIZE];\n\n  int count = 0;\n  while(fin.getline(line, SIZE)) {\n    if(strlen(line) &gt; 80) {\n      count += 1;\n    }\n  }\n\n  clock_t t_end = clock();\n\n  const double fsize = 6685;  // file size in MiB\n\n  double time = (t_end-t_start) / (double)CLOCKS_PER_SEC;\n\n  fprintf(stdout, \"takes %.2f s\\n\", time);\n  fprintf(stdout, \"speed: %d MiB/s\\n\", (int)(fsize/time));\n  fprintf(stdout, \"reads %d data lines\\n\", count);\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_44241289_44241289_4\"><code>read()</code> of <code>ifstream</code></p>\n</blockquote>\n<pre><code>// seq-read-bin.cpp\n// sequentially read the file to see the speed upper bound of\n// ifstream\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\n\nint main(int argc, char* argv[]) {\n  clock_t t_start = clock();\n\n  if(argc != 2) {\n    fprintf(stderr, \"needs one input argument\\n\");\n    return EXIT_FAILURE;\n  }\n\n  ifstream fin(argv[1], ios::binary);\n\n  const int SIZE = 1024*1024*3;\n  char str[SIZE];\n\n  while(fin) {\n    fin.read(str,SIZE);\n  }\n\n  clock_t t_end = clock();\n  double time = (t_end-t_start) / (double)CLOCKS_PER_SEC;\n\n  const double fsize = 6685;  // file size in MiB\n\n  fprintf(stdout, \"takes %.2f s\\n\", time);\n  fprintf(stdout, \"speed: %d MiB/s\\n\", (int)(fsize/time));\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_44241289_44241289_5\">use <code>cat</code>, then read from <code>cin</code> with <code>cin.sync_with_stdio(false)</code></p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nint main(void) {\n  clock_t t_start = clock();\n\n  string input_line;\n\n  cin.sync_with_stdio(false);\n\n  while(cin) {\n    getline(cin, input_line);\n  }\n\n  double time = (clock() - t_start) / (double)CLOCKS_PER_SEC;\n\n  const double fsize = 6685;  // file size in MiB\n\n  fprintf(stdout, \"takes %.2f s\\n\", time);\n  fprintf(stdout, \"speed: %d MiB/s\\n\", (int)(fsize/time));\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_44241289_44241289_6\"><code>POSIX getline()</code></p>\n</blockquote>\n<pre><code>// readline-c-getline.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main(int argc, char *argv[]) {\n\n  clock_t t_start = clock();\n\n  char *line = NULL;\n  size_t len = 0;\n  ssize_t nread;\n\n  if (argc != 2) {\n    fprintf(stderr, \"Usage: %s &lt;file&gt;\\n\", argv[1]);\n    exit(EXIT_FAILURE);\n  }\n\n  FILE *stream = fopen(argv[1], \"r\");\n  if (stream == NULL) {\n    perror(\"fopen\");\n    exit(EXIT_FAILURE);\n  }\n\n  int length = -1;\n  int count = 0;\n  while ((nread = getline(&amp;line, &amp;len, stream)) != -1) {\n    if (nread &gt; 80) {\n      count += 1;\n    }\n  }\n\n  free(line);\n  fclose(stream);\n\n  double time = (clock() - t_start) / (double)CLOCKS_PER_SEC;\n  const double fsize = 6685;  // file size in MiB\n  fprintf(stdout, \"takes %.2f s\\n\", time);\n  fprintf(stdout, \"speed: %d MiB/s\\n\", (int)(fsize/time));\n  fprintf(stdout, \"reads %d data lines.\\n\", count);\n  // fprintf(stdout, \"length of MSA: %d\\n\", length-1);\n\n  exit(EXIT_SUCCESS);\n}\n</code></pre>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "AcceptedAnswerId": "44244985", "Title": "how to read extreme long lines from text file fast and safe in C++?", "CreationDate": "2017-05-29T11:21:30.240", "Id": "44241289", "CommentCount": "35", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-30T15:33:18.397", "LastEditorUserId": "5256415", "LastActivityDate": "2017-05-30T15:33:18.397", "Score": "7", "OwnerUserId": "5256415", "Tags": "<c++><performance>", "AnswerCount": "3"}, "44244985": {"Id": "44244985", "PostTypeId": "2", "Body": "<p>As I commented, on Linux &amp; POSIX systems, you could consider using <a href=\"http://man7.org/linux/man-pages/man3/getline.3.html\" rel=\"nofollow noreferrer\">getline(3)</a>; I guess that the following could compile both as C and as C++ (assuming you do have some valid <code>fopen</code>-ed <code>FILE*fil;</code> ...)</p>\n<pre><code>char* linbuf = NULL; /// or nullptr in C++\nsize_t linsiz = 0;\nssize_t linlen = 0;\n\nwhile((linlen=getline(&amp;linbuf, &amp;linsiz,fil))&gt;=0) {\n  // do something useful with linbuf; but no C++ exceptions\n}\nfree(linbuf); linsiz=0;\n</code></pre>\n<p>I guess this might work (or be easily adapted) to C++. But then, beware of C++ exceptions, they should not go thru the while loop (or you should ensure that an appropriate destructor or <code>catch</code> is doing <code>free(linbuf);</code>).</p>\n<p>Also <code>getline</code> could fail (e.g. if it calls a failing <code>malloc</code>) and you might need to handle that failure sensibly.</p>\n", "LastEditorUserId": "841108", "LastActivityDate": "2017-05-29T14:49:27.417", "Score": "1", "CreationDate": "2017-05-29T14:32:08.913", "ParentId": "44241289", "CommentCount": "0", "OwnerUserId": "841108", "LastEditDate": "2017-05-29T14:49:27.417"}, "44241651": {"Id": "44241651", "PostTypeId": "2", "Body": "<p>Well, the C standard library is a subset of the C++ standard library. From n4296 draft from C++ 2014 standard:</p>\n<blockquote>\n<p id=\"so_44241289_44241651_0\">17.2 The C standard library [library.c]</p>\n<p id=\"so_44241289_44241651_1\">The C++ standard library also makes available the facilities of the C standard library, suitably adjusted to\n  ensure static type safety.</p>\n</blockquote>\n<p>So provided you explain in a comment that a performance bottleneck requires it, it is perfectly fine to use <code>fgets</code> in a C++ program - simply you should carefully encapsulate it in an utility class, in order to preserve the OO high level structures.</p>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2017-05-29T12:06:43.460", "Score": "5", "CreationDate": "2017-05-29T11:41:45.860", "ParentId": "44241289", "CommentCount": "6", "OwnerUserId": "3545273", "LastEditDate": "2017-05-29T12:06:43.460"}});