post_cb({"bq_ids": {"n4140": {"so_2772742_2772880_0": {"length": 24, "quality": 0.8, "section_id": 764}}, "n3337": {"so_2772742_2772880_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 751}}, "n4659": {"so_2772742_2772880_0": {"length": 24, "quality": 0.8, "section_id": 824}}}, "2774391": {"Id": "2774391", "PostTypeId": "2", "Body": "<p>i ask this question <a href=\"http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/c630514d-34f8-4b83-8df8-70990d1c1e83\" rel=\"nofollow noreferrer\">here</a> but give no response =)\nthanks for your feedback.</p>\n<p>i also create some simple console test (just to be sure):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;hash_set&gt;\nint main(int argc, char* argv[])\n{   \n  stdext::hash_set&lt;int&gt; hs1, hs2;\n  hs1.insert(10);\n  hs1.insert(15);\n  hs2.insert(15);\n  hs2.insert(10);\n  std::cout &lt;&lt; ((hs1 == hs2) ? \"It works!\" : \"It NOT works\") &lt;&lt; std::endl;\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<p>and compile it.\nusing vs2008 command prompt:</p>\n<pre><code>cl.exe HashSetTest.cpp /oHashSetTest2008.exe \n</code></pre>\n<p>using vs2010 command prompt:</p>\n<pre><code>cl.exe HashSetTest.cpp /oHashSetTest2010.exe\n</code></pre>\n<p>I really see different results =)</p>\n", "LastActivityDate": "2010-05-05T15:05:27.840", "CommentCount": "0", "CreationDate": "2010-05-05T15:05:27.840", "ParentId": "2772742", "Score": "1", "OwnerUserId": "255208"}, "2774236": {"Id": "2774236", "PostTypeId": "2", "Body": "<p>It looks like equality comparisons are broken for both <code>hash_set</code> and <code>unordered_set</code> in Visual C++ 2010.</p>\n<p>I implemented a naive equality function for unordered containers using the language from the standard <a href=\"https://stackoverflow.com/questions/2772742/hash-set-equality-operator-doesnt-work-in-vs2010/2772880#2772880\">quoted by Matthieu</a> to verify that it's a bug (just to be sure):</p>\n<pre><code>template &lt;typename UnorderedContainer&gt;\nbool are_equal(const UnorderedContainer&amp; c1, const UnorderedContainer&amp; c2)\n{\n    typedef typename UnorderedContainer::value_type Element;\n    typedef typename UnorderedContainer::const_iterator Iterator;\n    typedef std::pair&lt;Iterator, Iterator&gt; IteratorPair;\n\n    if (c1.size() != c2.size())\n        return false;\n\n    for (Iterator it(c1.begin()); it != c1.end(); ++it)\n    {\n        IteratorPair er1(c1.equal_range(*it));\n        IteratorPair er2(c2.equal_range(*it));\n\n        if (std::distance(er1.first, er1.second) != \n            std::distance(er2.first, er2.second))\n            return false;\n\n        // A totally naive implementation of is_permutation:\n        std::vector&lt;Element&gt; v1(er1.first, er1.second);\n        std::vector&lt;Element&gt; v2(er2.first, er2.second);\n\n        std::sort(v1.begin(), v1.end());\n        std::sort(v2.begin(), v2.end());\n\n        if (!std::equal(v1.begin(), v1.end(), v2.begin()))\n            return false;\n    }\n\n    return true;\n}\n</code></pre>\n<p>It returns that <code>hs1</code> and <code>hs2</code> from your example are equal.  (Somebody let me know if you spot a bug in that code; I didn't really test it extensively...)</p>\n<p>I'll file a defect report on Microsoft Connect.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-05-05T14:44:36.523", "Score": "4", "CreationDate": "2010-05-05T14:44:36.523", "ParentId": "2772742", "CommentCount": "2", "OwnerUserId": "151292", "LastEditDate": "2017-05-23T12:04:26.480"}, "2772742": {"ViewCount": "695", "Body": "<p>Sample code:</p>\n<pre><code>std::hash_set&lt;int&gt; hs1; // also i try std::unordered_set&lt;int&gt; - same effect \nstd::hash_set&lt;int&gt; hs2;\n\nhs1.insert(15);\nhs1.insert(20);\n\nhs2.insert(20);\nhs2.insert(15);\n\nassert(hs1 == hs2);\n</code></pre>\n<p>hash_set doesn't stores elements in some order defined by hash function... why?\nPlease note that this code works in VS2008 using stdext::hash_set.</p>\n", "AcceptedAnswerId": "2774236", "Title": "<hash_set> equality operator doesn't work in VS2010", "CreationDate": "2010-05-05T11:31:15.153", "Id": "2772742", "CommentCount": "2", "LastEditDate": "2010-05-05T19:19:52.930", "PostTypeId": "1", "LastEditorUserId": "3043", "LastActivityDate": "2010-05-05T19:19:52.930", "Score": "4", "OwnerUserId": "255208", "Tags": "<c++><visual-studio-2010>", "AnswerCount": "3"}, "2772880": {"Id": "2772880", "PostTypeId": "2", "Body": "<p>Finally found the reference in the final draft at 23.2.5, note 11:</p>\n<blockquote>\n<p id=\"so_2772742_2772880_0\">Two unordered containers <code>a</code> and <code>b</code> compare equal if <code>a.size() == b.size()</code> and, for every equivalent-key group <code>[Ea1,Ea2)</code> obtained from <code>a.equal_range(Ea1)</code>, there exists an equivalent-key group <code>[Eb1,Eb2)</code> obtained from <code>b.equal_range(Ea1)</code>, such that <code>distance(Ea1, Ea2) == distance(Eb1, Eb2)</code> and <code>is_permutation(Ea1, Ea2, Eb1)</code> returns <code>true</code>.</p>\n</blockquote>\n<p>I would bet <code>hash_set</code> is now implemented in term of <code>unordered_set</code> (to begin with), but I still don't understand why in your case it would fail.</p>\n<p>The complexity requirement is O(N) in the average case but degenerates to O(N<sup>2</sup>) in the worst case because of the linear-chaining implementation requirement.</p>\n", "LastActivityDate": "2010-05-05T11:51:47.070", "CommentCount": "1", "CreationDate": "2010-05-05T11:51:47.070", "ParentId": "2772742", "Score": "2", "OwnerUserId": "147192"}});