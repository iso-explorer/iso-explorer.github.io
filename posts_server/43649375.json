post_cb({"44145697": {"ParentId": "43649375", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2017-05-23T21:56:05.060", "Score": "3", "LastEditorUserId": "2630032", "LastEditDate": "2017-05-23T22:08:59.960", "Id": "44145697", "OwnerUserId": "2630032", "Body": "<p>I'd turn it around and initialise the vector with the \"real\" objects of type <code>C</code>, let the members <code>field0 .. field2</code> be of type \"reference to C\", i.e. <code>C&amp;</code>, and initialise them with the respective elements of the vector. The advantage of this \"turn around\" is that the various <code>C</code>-elements are placed one after each other in the vector, which is the most compact way and without padding, while still providing \"named\" data members (i.e. <code>field0..field2</code>) for accessing the elements without exposing the vector member itself.</p>\n<p>The custom \"static\" code can then be done with a comma expression, which lets you place almost arbitrary code. For code that is not allowed in comma expressions, e.g. the declaration of variables, one could still call member functions or use lambda-expressions. So we do not need any dummy members for \"static\" code executed between the various fields.</p>\n<p>The only place where we needed a dummy member is for code to be executed after the last <code>field_x</code>; so the overhead is a single <code>char</code>-value, and the \"static\" code here is again solved with a comma expression. </p>\n<p>See the following code, which demonstrates the approach. Note that you actually do not have to touch class <code>C</code>; member functions/data <code>C::setX</code>,<code>C::print</code>, and <code>int x</code> have been introduced for demonstration purpose only: </p>\n<pre><code>class C{\npublic:\n    void ini(){/* some code */}\n\n    // the following methods and data members are actually not necessary; they have been introduced just for demonstration purpose:\n    void setX(int _x) { x = _x;  };\n    void print() { cout &lt;&lt; x &lt;&lt; endl; }\n    int x;\n};\n\nclass D{\nprotected:\n    std::vector&lt;C&gt; regis = std::vector&lt;C&gt;(3); //will ini(); later\npublic:\n    C &amp;field0 = (regis[0].setX(5),printAllRegis(\"at field0:\"),regis[0]);\n    C &amp;field1 = (regis[1].setX(7),printAllRegis(\"at field1:\"),regis[1]);\n    C &amp;field2 = (regis[2].setX(regis[0].x + regis[1].x),printAllRegis(\"at field2:\"),regis[2]);\n    char dummy = (cout &lt;&lt; \"after field2: \", field2.print(), '0');\n    D(){ }\n\n    void ini(){\n        for(auto ele:regis){ ele.ini(); }\n    }\n\n    void printAllRegis(string header) {\n        int i=0;\n        cout &lt;&lt; header &lt;&lt; endl;\n        for(auto ele:regis){ cout &lt;&lt; \"  field\" &lt;&lt; i++ &lt;&lt; \":\"; ele.print(); }\n    }\n};\n\nint main() {\n\n    D d;\n    /* Output:\n     at field0:\n       field0:5\n       field1:0\n       field2:0\n     at field1:\n       field0:5\n       field1:7\n       field2:0\n     at field2:\n       field0:5\n       field1:7\n       field2:12\n     after field2: 12\n     */\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2017-05-23T22:08:59.960"}, "44040892": {"ParentId": "43649375", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-05-18T07:07:41.077", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:43.057", "Id": "44040892", "OwnerUserId": "7478597", "Body": "<p>Looking at this question, it reminds me to my own \"Object with properties\" concept. I consider it rather as pragmatical than elegant but I dare to present it:</p>\n<p>To establish the dependency between <code>Field</code> and <code>Object</code>, I introduced a back-reference to <code>Object</code> in <code>Field</code>. At the cost of an additional member, this has certain conveniencies.</p>\n<p>class Field \u2013 the base class required to store fields:</p>\n<pre><code>class Object; // forward reference\n\n// super class of all object fields\nclass Field {\n  // variables:\n  private:\n    // parent object\n    Object &amp;_obj;\n  // methods:\n  protected:\n    // constructor.\n    Field(Object &amp;obj);\n    // destructor.\n    ~Field();\n    // disabled:\n    Field(const Field&amp;) = delete;\n    Field operator=(const Field&amp;) = delete;\n}\n</code></pre>\n<p>The corresponding class Object \u2013 the field container:</p>\n<pre><code>#include &lt;vector&gt;\n\n// super class of objects which may contain fields\nclass Object {\n  // friends:\n  friend class Field;\n  // variables:\n  private:\n    // table of all registered fields\n    std::vector&lt;Field*&gt; _pFields;\n  // methods:\n  protected:\n    // constructor.\n    Object() = default;\n    // destructor.\n    virtual ~Object() = default;\n    // disabled:\n    Object(const Object&amp;) = delete;\n    Object&amp; operator=(const Object&amp;) = delete;\n};\n</code></pre>\n<p>The implementation of class <code>Field</code> has to \"know\" both classes:</p>\n<pre><code>#include &lt;algorithm&gt;\n\n// implementation of class Field\n\nField::Field(Object &amp;obj): _obj(obj)\n{\n  _obj._pFields.push_back(this);\n}\n\nField::~Field()\n{\n  _obj.erase(\n    std::find(\n      _obj._pField.begin(), _obj._pField.end(), this));\n}\n</code></pre>\n<p>The template for field instances:</p>\n<pre><code>// a class template for derived fields\ntemplate &lt;typename VALUE&gt;\nclass FieldT: public Field {\n  // variables:\n  private:\n    // the value\n    VALUE _value;\n  // methods:\n  public:\n    // constructor.\n    FieldT(Object &amp;obj, const VALUE &amp;value):\n      Field(obj), _value(value)\n    { }\n    // copy constructor.\n    FieldT(Object &amp;obj, const FieldT &amp;field):\n      Field(obj), _value(field._value)\n    { }\n    // disabled:\n    FieldT(const FieldT&amp;) = delete;\n    FieldT&amp; operator=(const FieldT&amp;) = delete;\n};\n</code></pre>\n<p>The advantages and disadvantages as considered by me:</p>\n<p>Pros:</p>\n<ol>\n<li><p>The object would never register non-fields.</p></li>\n<li><p>You may never forget to construct fields explicitly because the C++ compiler will remind you in this case. (Fields are not default constructable.)</p></li>\n<li><p>You may decide in a copy constructor of a derived <code>Object</code> whether to copy the field or initialize it with a constant (or alternative) value instead.</p></li>\n</ol>\n<p>Cons:</p>\n<ol>\n<li><p>It requires explicitly written code in every derived <code>Object</code> which might be considered as tedious. (I, personally, like explicit code to a certain amount to make maintenance easier.)</p></li>\n<li><p>It is not foolproof.\nE.g. fields created with <code>new</code> are \"begging\" for memory leaks. (Although... I never considered to simply delete the <code>operator new()</code>. I've to check out this soon.)</p></li>\n</ol>\n<p>So, how could this look in real-life:</p>\n<pre><code>// storage of a 2d vector\nstruct Vec2f {\n  float x, y;\n  Vec2f(float x, float y): x(x), y(y) { }\n};\n\n// storage of a 2d circle\nclass Circle: public Object {\n  // fields:\n  public:\n    // center\n    FieldT&lt;Vec2f&gt; center;\n    // radius\n    FieldT&lt;float&gt; radius;\n // methods:\n public:\n   // constructor.\n   explicit Circle(float x, float y, float r):\n     Object(),\n     center(*this, Vec2f(x, y)),\n     radius(*this, r)\n   { }\n   // copy constructor.\n   Circle(const Circle &amp;circle):\n     Object(),\n     center(*this, center),\n     radius(*this, radius)\n  { }\n};\n</code></pre>\n<p><em>Note:</em></p>\n<p>You may wonder why the fields are public \u2013 this is intentional. In my real-life incarnation, these fields have a lot more i.e. getter and setter as well as (optional) signal slots to install guardians and modification notifier. My intention was to free me from the tedious writing of access methods in the objects.</p>\n<p>In real-life this concept has even more potential:</p>\n<ul>\n<li><p>It's sufficient for generic I/O classes which may write and read XML files or other formats.</p></li>\n<li><p>It can be obtained in a second concept of generic GUI classes to simplify the creation of user interfaces in a generic way.</p></li>\n</ul>\n<p><strong>Worth of the costs for administrational extra data:</strong></p>\n<p>Some extra bytes seems often enough worth to me if they promise a lot of safed development time. Of course, there are counter examples where I consider every single bit e.g. the vertex data when loading geometry for visual simulation. (For the vertex data example, I never considered a property concept to access every single vertex. Instead, I used the properties to access arrays of vertices as once.)</p>\n<p><strong>Concerning the additional requirement of additional construction details:</strong></p>\n<blockquote>\n<p id=\"so_43649375_44040892_0\"><code>class D{\n      int field1=5;\n      { do something very custom; }\n      //^ have to be executed after \"field1=5;\" but before \"field2=7\"\n      int field2=7;\n      int field3=8;\n      { do something very custom ; }//have to be executed after \"field3=8;\"\n  };</code></p>\n</blockquote>\n<p>I would choose a simple solution which has nothing to do with the above concept:</p>\n<pre><code>class D {\n  int field1 = 5;\n  struct InitBefore {\n    InitBefore() {\n      // do something very custom;\n    }\n  } initBefore;\n  int field2 = 7;\n  int field3 = 8;\n  struct InitAfter {\n    InitAfter() {\n      // do something very custom;\n    }\n  } initAfter;\n  // the rest...\n};\n</code></pre>\n<p>Unfortunately, this doesn't fulfill the extra requirement:</p>\n<blockquote>\n<p id=\"so_43649375_44040892_1\">without wasting 1 char for each block.</p>\n</blockquote>\n<p>(The reason can be found in <a href=\"https://stackoverflow.com/questions/3849334/sizeof-empty-structure-is-0-in-c-and-1-in-c-why\">SO: sizeof empty structure is 0 in C and 1 in C++ why?</a>.)</p>\n<p>May be, it could be solved exploiting the sequence operator and static methods applied to the constructor of the appropriate member. This even seems so ugly to me that I don't dare to sketch code for this.</p>\n<p>May be, it could be solved to make an embedded, private derived class of the respective field where the \"very custom code\" can be added in the constructor. Due to the fact that fields actually have data the empty struct/class problem should be prevented.</p>\n<p>Actually, I never cared about the non-zero <code>struct</code>s/<code>class</code>es because I needed this trick itself only in rare cases (where only a few resp. instances are expected).</p>\n<p>As there are (at the time of writing) still 7 days until the bounty is over I will keep this in mind...</p>\n", "LastActivityDate": "2017-05-18T08:16:26.723"}, "43649375": {"CommentCount": "6", "AcceptedAnswerId": "43649443", "PostTypeId": "1", "LastEditorUserId": "3577745", "CreationDate": "2017-04-27T05:34:59.587", "LastActivityDate": "2017-05-25T03:52:22.310", "LastEditDate": "2017-05-19T12:07:03.897", "ViewCount": "462", "FavoriteCount": "2", "Title": "non static block in c++", "Id": "43649375", "Score": "9", "Body": "<p>Is there non-static block in C++?</p>\n<p>If no, how to emulate it elegantly?</p>\n<p>I want to replace something like :-</p>\n<pre><code>class C{\n    public: void ini(){/* some code */}\n};\nclass D{\n    std::vector&lt;C*&gt; regis; //will ini(); later\n    public: C field1; \n    public: C field2;  \n    public: C field3;             //whenever I add a new field, I have to ... #1\n    public: D(){\n        regis.push_back(&amp;field1);\n        regis.push_back(&amp;field2);\n        regis.push_back(&amp;field3); //#1 ... also add a line here\n    }\n    public: void ini(){\n        for(auto ele:regis){\n            ele-&gt;ini();\n        }\n    }\n};\n</code></pre>\n<p>with :-</p>\n<pre><code>class D{\n    std::vector&lt;C*&gt; regis;                        \n    public: C field1;{regis.push_back(&amp;field1);}//less error-prone (because it is on-site)\n    public: C field2;{regis.push_back(&amp;field2);}\n    public: C field3;{regis.push_back(&amp;field3);}\n    public: D(){    }  //&lt;-- empty\n    public: void ini(){\n        for(auto ele:regis){\n            ele-&gt;ini();\n        }\n    }\n};\n</code></pre>\n<p>I found many questions related to <strong>static-block</strong> in C++, but didn't found any one about <strong>non-static-block</strong>.</p>\n<p>To make it easy to answer, here is <a href=\"http://ideone.com/p77Y7s\" rel=\"nofollow noreferrer\">a full code</a>.     </p>\n<p>It can be done using <a href=\"https://en.wikipedia.org/wiki/X_Macro\" rel=\"nofollow noreferrer\">X-MACRO (wiki link)</a>, but I am trying to avoid it.     </p>\n<h2><strong>Edit</strong></h2>\n<p>In real case, <code>fieldX</code> can has any types that derived from a certain <code>C</code>.       </p>\n<p>I consider another bad workaround :-     </p>\n<pre><code>class D{\n    std::vector&lt;C*&gt; regis;     \n    char f(C&amp; c){   regis.push_back(&amp;c); return 42;}                 \n    public: C field1; char dummyWaste1=f(field1);\n    public: C field2; char dummyWaste2=f(field2);\n    public: C field3; char dummyWaste3=f(field3);\n</code></pre>\n<h2><strong>Edit2 (bounty reason)</strong></h2>\n<p>skypjack's answer is very useful, but I am curious to find out more alternatives.<br>\nThe final objective is to emulate general non-static block that has more variety.<br>\nIn other words, it would be nice if new solution can solve this :-     </br></br></p>\n<pre><code>class D{\n    int field1=5;\n    { do something very custom; /* may access field1 which must = 5 */}\n    //^ have to be executed after \"field1=5;\" but before \"field2=7\"\n    int field2=7;\n    int field3=8;\n    { do something very custom ; /* e.g. \"field1=field2+field3\" */}\n    //^ have to be executed after \"field3=8;\"\n};\n</code></pre>\n<p>without wasting 1 <code>char</code> (or more - for alignment) for each block.      </p>\n", "Tags": "<c++><initialization><c++14><non-static>", "OwnerUserId": "3577745", "AnswerCount": "7"}, "44162459": {"ParentId": "43649375", "CommentCount": "0", "CreationDate": "2017-05-24T15:16:54.820", "OwnerUserId": "4070330", "PostTypeId": "2", "Id": "44162459", "Score": "1", "Body": "<p>This may be an overkill here, but alternative still: instead of maintaining D.h and D.cpp write small app, that will generate D.h and D.cpp on base of D.txt, and maintain D.txt. So when you will need to add a new field to D (or some other change), you just add a line to D.txt and run generator.</p>\n", "LastActivityDate": "2017-05-24T15:16:54.820"}, "43649443": {"ParentId": "43649375", "PostTypeId": "2", "CommentCount": "16", "CreationDate": "2017-04-27T05:40:47.240", "Score": "6", "LastEditorUserId": "4987285", "LastEditDate": "2017-05-20T06:48:55.303", "Id": "43649443", "OwnerUserId": "4987285", "Body": "<blockquote>\n<p id=\"so_43649375_43649443_0\">how to emulate it elegantly?</p>\n</blockquote>\n<p>You can initialize <code>regis</code> directly:</p>\n<pre><code>std::vector&lt;C*&gt; regis = { &amp;field1, &amp;field2, &amp;field3 };\n</code></pre>\n<p>That is, define your class as:</p>\n<pre><code>class D{\npublic:\n    C field1;\n    C field2;\n    C field3;\n\n    void ini(){\n        for(auto ele:regis){\n            ele-&gt;ini();\n        }\n    }\n\nprivate:\n    std::vector&lt;C*&gt; regis = { &amp;field1, &amp;field2, &amp;field3 };\n};\n</code></pre>\n<p>Otherwise, if you can add a constructor to <code>C</code>, revert the logic and have it adding itself to the vector:</p>\n<pre><code>#include&lt;vector&gt;\n\nstruct C {\n    C(std::vector&lt;C*&gt; &amp;vec) {\n        vec.push_back(this);\n        // ...\n    }\n\n    void ini() {}\n};\n\nclass D{\n    std::vector&lt;C*&gt; regis{};\n\npublic:\n    C field1 = regis;\n    C field2 = regis;\n    C field3 = regis;\n\n    void ini(){\n        for(auto ele:regis){\n            ele-&gt;ini();\n        }\n    }\n};\n\nint main() { D d{}; d.ini(); }\n</code></pre>\n<p><strong>------ EDIT ------</strong></p>\n<p>As requested in the comments:</p>\n<blockquote>\n<p id=\"so_43649375_43649443_1\"><code>C</code> is a holy class for me. Is it possible to not hack <code>C</code>?</p>\n</blockquote>\n<p>Here is a possible alternative that doesn't require you to modify <code>C</code>:</p>\n<pre><code>#include&lt;vector&gt;\n\nstruct C {\n    void ini() {}\n};\n\nstruct Wrapper {\n    Wrapper(std::vector&lt;C*&gt; &amp;vec) {\n        vec.push_back(*this);\n        // ...\n    }\n\n    operator C *() { return &amp;c; }\n\nprivate:\n    C c;\n};\n\nclass D{\n    std::vector&lt;C*&gt; regis{};\n\npublic:\n    Wrapper field1{regis};\n    Wrapper field2{regis};\n    Wrapper field3{regis};\n\n    void ini(){\n        for(auto ele:regis){\n            ele-&gt;ini();\n        }\n    }\n};\n\nint main() { D d{}; d.ini(); }\n</code></pre>\n", "LastActivityDate": "2017-05-20T06:48:55.303"}, "44069604": {"ParentId": "43649375", "CommentCount": "2", "CreationDate": "2017-05-19T12:02:27.843", "OwnerUserId": "4324224", "PostTypeId": "2", "Id": "44069604", "Score": "3", "Body": "<p>Maybe you are looking for a dummy fields initialized by lambda capturing <code>this</code> pointer invoked immediately after declaration:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct C { };\n\nclass D{\n    int field1=5;\n    int dummy1{[&amp;]{ std::cout &lt;&lt; field1 &lt;&lt; std::endl; return 0;}()};\n    int field2=7;\n    int field3=8;\n    int dummy2{[&amp;]{ std::cout &lt;&lt; (field1 + field2 + field3) &lt;&lt; std::endl; return 0;}()};\n};\n\nint main() {\n    D d;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>5  \n20\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/z87WQDc97Wlwn9eR\" rel=\"nofollow noreferrer\">[live demo]</a></p>\n", "LastActivityDate": "2017-05-19T12:02:27.843"}, "44171445": {"ParentId": "43649375", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2017-05-25T02:43:07.770", "Score": "1", "LastEditorUserId": "3750062", "LastEditDate": "2017-05-25T03:52:22.310", "Id": "44171445", "OwnerUserId": "3750062", "Body": "<p>I think it might be smarter to create this the other way around. Instead of artificially enhancing your structure with an additional vector of pointers for iteration purposes, enhance a vector with named fields.</p>\n<p>A strong indicator for why you would want to do this is that the layout and naming scheme of your fields already sounds exactly like an array. Think about it, your names are just covering up that you most likely access consecutive fields with indices.</p>\n<pre><code>class C {\npublic:\n    int value; // For code example\n    void ini() { value = 42; };\n};\n\nclass D {\n    std::array&lt;C, 4 /*or w/e you need*/ &gt; storage;\npublic:\n    // Reference initializers are compulsory, so less chance of forgetting &amp; bugs\n    int field_index = 0;\n    C&amp; field1 = storage.at(field_index++);\n    C&amp; field2 = storage.at(field_index++);\n    void ini(){\n        for(auto&amp; ele: storage) {\n            ele.ini();\n        }\n    }\n    // We can even do some templating due to std::array\n    template&lt;size_t I&gt; C&amp; field() { \n        return std::get&lt;I&gt;(storage); \n    }\n};\n</code></pre>\n<p>Now you can add additional stored <code>C</code>s by increasing the size count of the array, and name any field by simply adding an additional member line. Of course you could also store the array as a member instead of inheriting from it in case you need the member overloads or want a flat hierarchy.</p>\n<p>Additional plus: Since all access indices are constant expression, any good compiler might inline the actual access, no matter if done by index or by field.</p>\n<pre><code>int main() {\n     D d; d.ini();\n     int s = d.field1.value + d.field2.value;\n     // alternatively d.field&lt;0&gt;().value + d.field&lt;1&gt;().value;\n     printf(\"%i\", s); // Compiler can deduce to printf(\"%i\", 84);\n}\n</code></pre>\n<p>For example the above will compile to basically little more than <code>printf(\"%i\", 84)</code> with both clang and gcc. You can check this with your own compiler or see the link to <a href=\"https://godbolt.org/g/50VjyY\" rel=\"nofollow noreferrer\">https://godbolt.org/g/50VjyY</a>.</p>\n<hr>\n<p>Edit: I realized that maybe initialization semantics are the initial reasoning for listing multiple consecutive fields. But any initialization you would normally do on the fields directly can arguably also be done in the array initializer. Assume some constructor</p>\n<pre><code>// Replace this (from your structure)\nD::D(/*some arguments*/) : field1(args), field2(otherargs) {}\n\n// with this\nD::D(/*same arguments*/) : storage{C{args}, C{otherargs}} {}\n</code></pre>\n<hr>\n<p>Edit 2: Although it might not accurately answer the fundamental problem of how to nicely express the above <strong>data representation</strong>, it should be noted that there is indeed a way to execute arbitrary code in the way you might have originally intended it to but you have to <em>very</em> careful. </p>\n<pre><code>class D{\n    std::vector&lt;C*&gt; regis;                        \npublic:\n    C field1 = (regis.push_back(&amp;field1), C{});\n    C field2 = (regis.push_back(&amp;field2), C{});\n    C field3 = (regis.push_back(&amp;field3), C{});\n    D(){    }  //&lt;-- empty\n    void ini(){\n        for(auto ele:regis){\n            ele-&gt;ini();\n        }\n    }\n};\n</code></pre>\n<p>Here you need to acknowledge than <em>any</em> initialization in the initializer list of any other constructor you might add later will remove the push_back of the respective pointer! This will likely introduce an hard to find bug and cause obscure side effect. For this reason I would never advise for using the comma operator <code>,</code> in default member initializers.</p>\n<p>By using the standard correctly, you can theoretically use values of previous members</p>\n<blockquote>\n<p id=\"so_43649375_44171445_0\">12.6.2.5</p>\n<p id=\"so_43649375_44171445_1\">Initialization shall proceed in the following order:</p>\n<p id=\"so_43649375_44171445_2\"><strong>...</strong></p>\n<p id=\"so_43649375_44171445_3\">[...] nonstatic data members shall be initialized in the order they were declared in the class definition.</p>\n</blockquote>\n<p>Note that this will also apply to the other initialization with array as well and is not exclusive to your original approach.</p>\n</hr></hr>", "LastActivityDate": "2017-05-25T03:52:22.310"}, "bq_ids": {"n4140": {"so_43649375_44171445_3": {"section_id": 438, "quality": 1.0, "length": 10}}, "n3337": {"so_43649375_44171445_3": {"section_id": 429, "quality": 1.0, "length": 10}}, "n4659": {"so_43649375_44171445_3": {"section_id": 458, "quality": 1.0, "length": 10}}}, "44048542": {"ParentId": "43649375", "CommentCount": "1", "CreationDate": "2017-05-18T13:02:32.030", "OwnerUserId": "3783662", "PostTypeId": "2", "Id": "44048542", "Score": "2", "Body": "<p>something like this?</p>\n<pre><code>class D\n{\npublic:\n    D()\n    {   \n        objects.emplace(\"field1\", std::make_unique&lt;C&gt;());\n        //{ do something very custom; }\n        //^ have to be executed after \"field1=5;\" but before \"field2=7\"\n        objects.emplace(\"field2\", std::make_unique&lt;C&gt;());\n        objects.emplace(\"field3\", std::make_unique&lt;C&gt;());\n        //{ do something very custom; }//have to be executed after \"field3=8;\"\n\n        // if you want you can store the pointers in the vector. but since you store everything in the map you maybe wanna drop the vector \n        for (const auto&amp; o : objects)\n        {\n            regis.emplace_back(o.second.get());\n        }\n    }\n\nprivate:\n    void ini()\n    {\n        for (auto ele : regis){\n            ele-&gt;ini();\n        }\n\n        /* or use the map to iterate \n        for (const auto&amp; o : objects)\n        {\n            o.second-&gt;ini();\n        }       \n        */\n\n        // to acces a specific field:\n        //objects[\"field1\"]-&gt;any_obj_from_c;\n    }\n    std::vector&lt;C*&gt; regis; //will ini(); later\n    std::map&lt;std::string, std::unique_ptr&lt;C&gt;&gt; objects;\n};\n</code></pre>\n", "LastActivityDate": "2017-05-18T13:02:32.030"}});