post_cb({"6841130": {"ViewCount": "6197", "Body": "<p>I recently saw this code being used in a source file in a C++ project:</p>\n<pre><code>using namespace std;\n#include &lt;iostream&gt;\n</code></pre>\n<p>Ignoring all issues of whether it's a good idea to have <code>using namespace std</code> at all, is the above code even legal?  There is no code in the file before these two lines.</p>\n<p>I would have thought that this wouldn't compile, since <code>namespace std</code> hasn't been declared in scope until the <code>#include &lt;iostream&gt;</code> directive includes it into the file, but using the build system for the project this was compiling just fine.  If someone has a link to a relevant part of the spec, that would be most appreciated.  </p>\n", "AcceptedAnswerId": "6970046", "Title": "Ordering of using namespace std; and includes?", "CreationDate": "2011-07-27T07:55:36.970", "Id": "6841130", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-07T15:05:56.283", "LastEditorUserId": "5640", "LastActivityDate": "2015-08-07T15:05:56.283", "Score": "10", "OwnerUserId": "501557", "Tags": "<c++><language-lawyer><using-directives>", "AnswerCount": "6"}, "6970226": {"Id": "6970226", "PostTypeId": "2", "Body": "<p>I think there's a flaw in the standard (including C++0x) with respect to this case.</p>\n<p>We have in section 3.3.6 (<code>[basic.scope.namespace]</code>):</p>\n<blockquote>\n<p id=\"so_6841130_6970226_0\">The declarative region of a namespace-definition is its namespace-body.  The potential scope denoted by an original-namespace-name is the concatenation of the declarative  regions established by each of the namespace-de\ufb01nitions in the same declarative region with that original-namespace-name. Entities declared in a namespace-body are said to be members of the namespace, and names introduced by these declarations into the declarative region of the namespace are said to be member names of the namespace. A namespace member name has namespace scope.  Its potential scope includes its namespace from the name\u2019s point of declaration (3.3.2) onwards; and for each using-directive (7.3.4) that nominates the member\u2019s namespace, the member\u2019s potential scope includes that portion of the potential scope of the using-directive that follows the member\u2019s point of declaration.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_6841130_6970226_1\">The outermost declarative region of a translation unit is also a namespace, called the global namespace.  A name declared in the global namespace has global namespace scope (also called global scope). The potential scope of such a name begins at its point of declaration (3.3.2) and ends at the end of the translation unit that is its declarative region. Names with global namespace scope are said to be global name.</p>\n</blockquote>\n<p>So <code>namespace std</code> is a member of the global namespace, and the scope of the name starts at the <em>point of declaration</em>.</p>\n<p>And 3.3.2 (<code>[basic.scope.pdecl]</code>) tells us:</p>\n<blockquote>\n<p id=\"so_6841130_6970226_2\">The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer (if any), except as noted below.</p>\n</blockquote>\n<p>And none of the exceptions apply to namespaces.</p>\n<p>So a namespace name cannot be used before its <em>declarator</em>, but a namespace name isn't a declarator.  Oops.</p>\n", "LastActivityDate": "2011-08-07T01:56:54.730", "CommentCount": "0", "CreationDate": "2011-08-07T01:56:54.730", "ParentId": "6841130", "Score": "1", "OwnerUserId": "103167"}, "6841534": {"Id": "6841534", "PostTypeId": "2", "Body": "<p>This code is undefined behavior [lib.using.headers]:</p>\n<blockquote>\n<p id=\"so_6841130_6841534_0\">A translation unit shall include a header only outside of any external declaration or definition, and shall include the header lexically before the first reference to any of the entities it declares or first defines in that translation unit.</p>\n</blockquote>\n<p>You reference <code>std</code> and then include a header that declares it. Even this is still undefined behavior:</p>\n<pre><code>#include &lt;string&gt;\nusing namespace std;\n#include &lt;iostream&gt;\n</code></pre>\n", "LastActivityDate": "2011-07-27T08:35:24.300", "CommentCount": "12", "CreationDate": "2011-07-27T08:35:24.300", "ParentId": "6841130", "Score": "1", "OwnerUserId": "277176"}, "6842302": {"Id": "6842302", "PostTypeId": "2", "Body": "<p>I don't think it's legal, but the standard isn't 100% clear about it.\nBasically, name lookup (as defined in \u00a73.4) can't find a previous\ndeclaration of the namespace, because there isn't one.  Everything\nhinges on whether:</p>\n<pre><code>using namespace std;\n</code></pre>\n<p>is a declaration of the namespace or not.  And I don't see any text in\n\u00a77.3.4 which says that a using-directive declares the nominated\nnamespace.  G++ allows your code, but IMHO, this is a bug. </p>\n", "LastActivityDate": "2011-07-27T09:45:05.087", "CommentCount": "0", "CreationDate": "2011-07-27T09:45:05.087", "ParentId": "6841130", "Score": "3", "OwnerUserId": "649665"}, "bq_ids": {"n4140": {"so_6841130_6841534_0": {"length": 15, "quality": 0.75, "section_id": 6270}, "so_6841130_6970226_0": {"length": 65, "quality": 0.9027777777777778, "section_id": 7067}, "so_6841130_6970226_2": {"length": 14, "quality": 0.875, "section_id": 7049}, "so_6841130_6970226_1": {"length": 37, "quality": 0.8043478260869565, "section_id": 7069}}, "n3337": {"so_6841130_6841534_0": {"length": 15, "quality": 0.75, "section_id": 6030}, "so_6841130_6970226_0": {"length": 65, "quality": 0.9027777777777778, "section_id": 6811}, "so_6841130_6841229_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5286}, "so_6841130_6970226_2": {"length": 14, "quality": 0.875, "section_id": 6794}, "so_6841130_6970226_1": {"length": 38, "quality": 0.8260869565217391, "section_id": 6813}}, "n4659": {"so_6841130_6970226_0": {"length": 52, "quality": 0.7222222222222222, "section_id": 8564}, "so_6841130_6841534_0": {"length": 14, "quality": 0.7, "section_id": 7776}, "so_6841130_6970226_2": {"length": 14, "quality": 0.875, "section_id": 8546}, "so_6841130_6970226_1": {"length": 37, "quality": 0.8043478260869565, "section_id": 8566}}}, "6970046": {"Id": "6970046", "PostTypeId": "2", "Body": "<p>A perhaps interesting data point.  When I compile the following:</p>\n<pre><code>using namespace std;\nusing namespace no_such_namespace;\n</code></pre>\n<p>with g++ 4.5.2, I get:</p>\n<pre><code>c.cpp:2:17: error: \u2018no_such_namespace\u2019 is not a namespace-name\nc.cpp:2:34: error: expected namespace-name before \u2018;\u2019 token\n</code></pre>\n<p>Neither <code>std</code> nor <code>no_such_namespace</code> has been defined as a namespace at that point, but g++ complains only about the second.  I don't <em>think</em> there's anything special about the identifier <code>std</code> in the absence of a declaration of it.  I think @James Kanze is right that this is a bug in g++.</p>\n<p>EDIT: <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29556\" rel=\"nofollow\">And it's been reported.</a> (5 years ago!)</p>\n<p>UPDATE: Now it's more than 8 years, and still hasn't been assigned to anyone, much less fixed. g++ 4.9.2 exhibits the problem. clang++ 3.5 doesn't, but it issues a warning for <code>std</code> and a fatal error for <code>no_such_namespace</code>:</p>\n<pre><code>c.cpp:1:17: warning: using directive refers to implicitly-defined namespace 'std'\nusing namespace std;\n                ^\nc.cpp:2:17: error: expected namespace name\nusing namespace no_such_namespace;\n                ^\n1 warning and 1 error generated.\n</code></pre>\n", "LastEditorUserId": "827263", "LastActivityDate": "2015-01-26T05:37:25.770", "Score": "5", "CreationDate": "2011-08-07T01:06:28.010", "ParentId": "6841130", "CommentCount": "0", "OwnerUserId": "827263", "LastEditDate": "2015-01-26T05:37:25.770"}, "6841229": {"Id": "6841229", "PostTypeId": "2", "Body": "<p>From SO/IEC 14882:2003</p>\n<blockquote>\n<p id=\"so_6841130_6841229_0\">[7.3.3.9]  The entity declared by a using-declaration shall be known in the context using it according to its definition at the point of the using-declaration. <strong>Definitions added to the namespace after the using-declaration are not considered when a use of the name is made.</strong></p>\n<p id=\"so_6841130_6841229_1\">[3.4.3.2.2]  Given X::m (where X is a user-declared namespace), or given ::m (where X is the global namespace), let S be the set of all declarations of m in X and in the transitive closure of all namespaces nominated by using-directives in X and its used namespaces, except that using-directives are ignored in any namespace, including X, directly containing one or more declarations of m. No namespace is searched more than once in the lookup of a name. If S is the empty set, the program is ill-formed. Otherwise, if S has exactly one member, or if the <strong>context of the reference is a using-declaration (7.3.3)</strong>, S is the required set of declarations of m. Otherwise if the use of m is not one that allows a unique declaration to be chosen from S, the program is ill-formed</p>\n</blockquote>\n<p>So if it happens to work, it's a fluke and not portable.</p>\n", "LastEditorUserId": "458742", "LastActivityDate": "2011-07-27T08:13:20.250", "Score": "2", "CreationDate": "2011-07-27T08:07:28.110", "ParentId": "6841130", "CommentCount": "2", "OwnerUserId": "458742", "LastEditDate": "2011-07-27T08:13:20.250"}, "15929963": {"Id": "15929963", "PostTypeId": "2", "Body": "<p>Recently i faced the same issue and been advised by my tech lead that; using namespace does not guarantee the visibility of the methods until the namespace with related methods are included in the file using .h file.\nincluding the header file resolved the issue.</p>\n", "LastActivityDate": "2013-04-10T15:20:47.797", "CommentCount": "0", "CreationDate": "2013-04-10T15:20:47.797", "ParentId": "6841130", "Score": "0", "OwnerUserId": "2148088"}});