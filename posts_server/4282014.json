post_cb({"4282014": {"CommentCount": "2", "AcceptedAnswerId": "4282024", "PostTypeId": "1", "LastEditorUserId": "1288", "CreationDate": "2010-11-26T01:45:50.560", "LastActivityDate": "2012-09-18T03:15:39.470", "LastEditDate": "2012-09-18T03:15:39.470", "ViewCount": "8327", "FavoriteCount": "6", "Title": "C++ Abstract class can't have a method with a parameter of that class", "Id": "4282014", "Score": "13", "Body": "<p>I created this .h file</p>\n<pre><code>#pragma once\n\nnamespace Core\n{\n    class IComparableObject\n    {\n    public:\n            virtual int CompareTo(IComparableObject obj)=0;\n    };\n}\n</code></pre>\n<p>But compiler doesn't like <strong>IComparableObject obj</strong> param if the method is virtual pure, while</p>\n<pre><code>virtual int CompareTo(IComparableObject obj) {}\n</code></pre>\n<p>It's ok, however I want it as virtual pure. How can I manage to do it?  Is it possible?</p>\n", "Tags": "<c++>", "OwnerUserId": "312907", "AnswerCount": "4"}, "4283406": {"ParentId": "4282014", "CommentCount": "2", "Body": "<p>Well I have to give an unexpected answer here! Dennycrane said you can do this:</p>\n<pre>\nvirtual int CompareTo(IComparableObject const &amp;obj;)=0;\n</pre>\n<p>but this is not correct either. Oh yes, it compiles, but it is useless because it can never be implemented correctly. </p>\n<p>This issue is fundamental to the collapse of (statically typed) Object Orientation, so it is vital that programmers using OO recognize the issue. The problem has a name, it is called <strong>the covariance problem</strong> and it destroys OO utterly as a general programming paradigm; that is, a way of representing and independently implementing general abstractions.</p>\n<p>This explanation will be a bit long and sloppy so bear with me and try to read between the lines.</p>\n<p>First, an abstract class with a pure virtual method taking no arguments can be easily implemented in any derived class, since the method has access to the non-static data variables of the derived class via the this pointer. The this pointer has the type of a pointer to the derived class, and so we can say it <strong>varies</strong> along with the class, in fact it is <strong>covariant</strong> with the derived class type. </p>\n<p>Let me call this kind of polymorphism first order, it clearly supports dispatching predicates on the object type. Indeed, the return type of such a method may also vary down with the object and class type, that is, the return type is <strong>covariant</strong>.</p>\n<p>Now, I will generalise the idea of a method with no arguments to allow arbitrary scalar arguments (such as ints) claiming this changes nothing: this is merely a family of methods indexed by the scalar type. The important property here is that the scalar type is closed. In a derived class exactly the same scalar type must be used. in other words, the type is <strong>invariant</strong>.</p>\n<p>General introduction of invariant parameters to a virtual function still permits polymorphism, but the result is still first order. </p>\n<p>Unfortunately, such functions have limited utility, although they are very useful when the abstraction is only first order: a good example is device drivers.</p>\n<p>But what if you want to model something which is actually interesting, that is, it is at least a relation?</p>\n<p>The answer to this is: you cannot do it. This is a mathematical fact and has nothing to do with the programming language involved. Lets suppose you have an abstraction for say, numbers, and you want to add one number to another number, or compare them (as in the OP's example). Ignoring symmetry, if you have N implementations, you will have to write N^2 functions to perform the operations. If you add a new implementation of the abstraction, you have to write N+1 new functions.</p>\n<p>Now, I have the first proof that OO is screwed: you cannot fit N^2 methods into a virtual dispatch schema because such a schema is linear. N classes gives you N methods you can implement and for N&gt;1, N^2 &gt; N, so OO is screwed, QED.</p>\n<p>In a C++ context you can see the problem: consider :</p>\n<pre>\nstruct MyComparable : IComparableObject {\n  int CompareTo(IComparableObject &amp;other;) { .. }\n};\n</pre>\n<p>Arggg! We're screwed! We can't fill in the <code> .. </code> part here because we only have a reference to an abstraction, which has no data in it to compare to. Of course this <strong>must</strong> be the case, because there are an open/indeterminate/infinite number of possible implementations. There's no possible way to write a single comparison routine as an axiom.</p>\n<p>Of course, if you have various property routines, or a common universal representation you can do it, but this does not count, because then the mapping to the universal representation is parameterless and thus the abstraction is only first order.  For example if you have various integer representations and you add them by converting both to GNU gmp's data type mpz, then you are using two covariant projection functions and a single global non-polymorphic comparison or addition function.</p>\n<p>This is not a counter example, it is a non-solution of the problem, which is to represent a relation or method which is covariant in at least two variables (at least self and other).</p>\n<p>You may think you could solve this with:</p>\n<pre>\nstruct MyComparable : IComparableObject {\n  int CompareTo(MyComparable &amp;other;) { .. }\n};\n</pre>\n<p>After all you can implement this interface because you know the representation of other now, since it is MyComparable.</p>\n<p>Do not laugh at this solution, because it is exactly what Bertrand Meyer did in Eiffel, and it is what many people do in C++ with a small change to try to work around the fact it isn't type safe and doesn't actually override the base-class function:</p>\n<pre>\nstruct MyComparable : IComparableObject {\n  int CompareTo(IComparableObject &amp;other;) {\n     try \n       MyComparable &amp;sibling; = dynamic_cast(other);\n       ...\n    catch (..) { return 0; }\n  }\n};\n</pre>\n<p>This isn't a solution. It says that two things aren't equal just because they have different representations. That does not meet the requirement, which is to compare two things in the abstract. Two numbers, for example, cannot fail to be equal just because the representation used is different: zero equals zero, even if one is an mpz and the other an int. Remember: the idea is to properly represent an abstraction, and that means the behaviour must depend only on the abstract value, not the details of a particular implementation.</p>\n<p>Some people have tried double dispatch. Clearly, that cannot work either. There is no possible escape from the basic issue here: you cannot stuff a square into a line.\nvirtual function dispatch is linear, second order problems are quadratic, so OO cannot represent second order problems.</p>\n<p>Now I want to be very clear here that C++ and other statically typed OO languages are broken, <strong>not</strong> because they can't solve this problem, because it cannot be solved, and it isn't a problem: its a simple fact. The reason these languages and the OO paradigm in general are broken is because they <strong>promise</strong> to deliver general abstractions and then fail to do so. In the case of C++ this is the promise:</p>\n<pre>\nstruct IComparableObject { virtual int CompareTo(IComparableObject obj)=0; };\n</pre>\n<p>and here is where the implicit contract is broken:</p>\n<pre>\nstruct MyComparable : IComparableObject {\n  int CompareTo(IComparableObject &amp;other;) { throw 00; }\n};\n</pre>\n<p>because the implementation I gave there is effectively the only possible one.</p>\n<p>Well before leaving, you may ask: What is the <strong>right way (TM)</strong>.\nThe answer is: use functional programming. In C++ that means templates.</p>\n<pre><code>template&lt;class T, class U&gt; int compare(T,U);\n</code></pre>\n<p>So if you have N types to compare, and you actually compare all combinations, then yes indeed you have to provide N^2 specialisations. Which shows templates <strong>deliver</strong> on the promise, at least in this respect. It's a fact: you can't dispatch at run time over an open set of types if the function is variant in more than one parameter.</p>\n<p>BTW: in case you aren't convinced by theory .. just go look at the ISO C++ Standard library and see how much virtual function polymorphism is used there, compared to functional programming with templates.. </p>\n<p>Finally please note carefully that I am not saying classes and such like are useless, I use virtual function polymorphism myself: I'm saying that this is limited to particular problems and not a general way to represent abstractions, and therefore not worthy of being called a paradigm.</p>\n", "OwnerUserId": "518287", "PostTypeId": "2", "Id": "4283406", "Score": "7", "CreationDate": "2010-11-26T07:52:15.977", "LastActivityDate": "2010-11-26T07:52:15.977"}, "4282024": {"CommentCount": "5", "CreationDate": "2010-11-26T01:50:35.017", "CommunityOwnedDate": "2010-11-26T01:54:59.143", "LastEditorUserId": "-1", "LastActivityDate": "2010-11-26T01:56:10.873", "ParentId": "4282014", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:02:26.530", "Id": "4282024", "Score": "23", "Body": "<p>You are trying to pass <code>obj</code> by value. You cannot pass an abstract class instance by value, because no abstract class can ever be instantiated (directly). To do what you want, you have to pass <code>obj</code> by reference, for example like so:</p>\n<pre><code>virtual int CompareTo(IComparableObject const &amp;obj)=0;\n</code></pre>\n<p>It works when you give an implementation for <code>CompareTo</code> because then the class is not abstract any longer. But be aware that <a href=\"https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c\">slicing</a> occurs! You don't want to pass <code>obj</code> by value.</p>\n", "OwnerUserId": "514460"}, "bq_ids": {"n4140": {"so_4282014_4282044_0": {"section_id": 7020, "quality": 1.0, "length": 16}}, "n3337": {"so_4282014_4282044_0": {"section_id": 6766, "quality": 1.0, "length": 16}}, "n4659": {"so_4282014_4282044_0": {"section_id": 8517, "quality": 1.0, "length": 16}}}, "4282044": {"ParentId": "4282014", "CommentCount": "0", "Body": "<p>From C++03, \u00a710.4 3:</p>\n<blockquote>\n<p id=\"so_4282014_4282044_0\">An abstract class shall not be used as a parameter type, as a function return type, or as the type of an explicit conversion. Pointers and references to an abstract class can be declared.</p>\n</blockquote>\n<p>Passing <code>obj</code> as a const reference is allowed.</p>\n", "OwnerUserId": "90527", "PostTypeId": "2", "Id": "4282044", "Score": "2", "CreationDate": "2010-11-26T01:56:18.437", "LastActivityDate": "2010-11-26T01:56:18.437"}, "4282038": {"ParentId": "4282014", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>When the <code>CompareTo</code> member function is pure virtual, <code>IComparableObject</code> is an abstract class.</p>\n<p>You can't directly copy an object of an abstract class.</p>\n<p>When you pass an object by value you're directly <em>copying</em> that object.</p>\n<p>Instead of passing by value, you can pass by reference to <code>const</code>.</p>\n<p>That is, formal argument type <code>IComparableObject const&amp;</code>.</p>\n<hr>\n<p>By the way, the function should probably be declared <code>const</code> so that it can be called on <code>const</code> object.</p>\n<p>Also, instead of <code>#pragma once</code>, which is non-standard (but supported by most compilers), consider an ordinary include guard.</p>\n<p>Also, when posting code that illustrates a problem, be sure to post exact code. In this case, there's a missing semicolon at the end, indicating manual typing of the code (and so that there could be other typos not so easily identified as such, but instead misidentified as part of your problem). Simply copy and paste <em>real code</em>.</p>\n<hr>\n<p>Cheers &amp; hth.,</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2010-11-26T02:10:20.967", "Id": "4282038", "Score": "2", "CreationDate": "2010-11-26T01:54:30.580", "LastActivityDate": "2010-11-26T02:10:20.967"}});