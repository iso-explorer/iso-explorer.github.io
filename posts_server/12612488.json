post_cb({"12613099": {"ParentId": "12612488", "PostTypeId": "2", "CommentCount": "31", "Body": "<blockquote>\n<p id=\"so_12612488_12613099_0\">This too:</p>\n</blockquote>\n<pre><code>// valid: char -&gt; type\nalignas(int) char c[sizeof(int)];\nint * i = reinterpret_cast&lt;int*&gt;(c);\n</code></pre>\n<p>That is not correct. The aliasing rules state under which circumstances it is legal/illegal to access an object through an lvalue of a different type. There is an specific rule that says that you can access any object through a pointer of type <code>char</code> or <code>unsigned char</code>, so the first case is correct. That is, A =&gt; B does not necessarily mean B =&gt; A. You can access an <code>int</code> through a pointer to <code>char</code>, but you cannot access a <code>char</code> through a pointer to <code>int</code>.</p>\n<hr>\n<p>For the benefit of Alf:</p>\n<blockquote>\n<p id=\"so_12612488_12613099_1\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non- static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n</hr>", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2012-09-27T03:04:22.860", "Id": "12613099", "Score": "5", "CreationDate": "2012-09-27T02:09:46.137", "LastActivityDate": "2012-09-27T03:04:22.860"}, "12614819": {"ParentId": "12612488", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Regarding the validity of \u2026</p>\n<pre><code>alignas(int) char c[sizeof(int)];\nint * i = reinterpret_cast&lt;int*&gt;(c);\n</code></pre>\n<p>The <code>reinterpret_cast</code> itself is OK or not, in the sense of producing a useful pointer value, depending on the compiler. And in this example the result isn't used, in particular, the character array isn't accessed. So there is not much more that can be said about the example as-is: it just <em>depends</em>.</p>\n<p>But let's consider an extended version that does touch on the aliasing rules:</p>\n<pre><code>void foo( char* );\n\nalignas(int) char c[sizeof( int )];\n\nfoo( c );\nint* p = reinterpret_cast&lt;int*&gt;( c );\ncout &lt;&lt; *p &lt;&lt; endl;\n</code></pre>\n<p>And let's only consider the case where the compiler guarantees a useful pointer value, one that would place the pointee in the same bytes of memory (the reason that this depends on the compiler is that the standard, in \u00a75.2.10/7, only guarantees it for pointer conversions where the <em>types</em> are alignment-compatible, and otherwise leave it as \"unspecified\" (but then, the whole of \u00a75.2.10 is somewhat inconsistent with \u00a79.2/18).</p>\n<p>Now, one interpretation of the standard's \u00a73.10/10, the so called \"strict aliasing\" clause (but note that the standard does not ever use the term \"strict aliasing\"),</p>\n<blockquote>\n<p id=\"so_12612488_12614819_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non- static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a <code>char</code> or <code>unsigned</code> <code>char</code> type.</li>\n</ul>\n</blockquote>\n<p>is that, as it itself says, concerns the <em>dynamic type</em> of the object residing in the <code>c</code> bytes.</p>\n<p>With that interpretation, the read operation on <code>*p</code> is OK if <code>foo</code> has placed an <code>int</code> object there, and otherwise not. So in this case, a <code>char</code> array is accessed via an <code>int*</code> pointer. And nobody is in any doubt that <em>the other way</em> is valid: even though <code>foo</code> may have placed an <code>int</code> object in those bytes, you <em>can</em> freely access that object as a sequence of <code>char</code> values, by the last dash of \u00a73.10/10.</p>\n<p>So with this (usual) interpretation, after <code>foo</code> has placed an <code>int</code> there, we can access it as <code>char</code> objects, so at least one <code>char</code> object exists within the memory region named <code>c</code>; and we can access it as <code>int</code>, so at least that one <code>int</code> exists there also; and so <a href=\"https://stackoverflow.com/a/12613099/464581\">David\u2019s assertion in another answer</a> that <code>char</code> objects cannot be accessed as <code>int</code>, is incompatible with this usual interpretation.</p>\n<p>David's assertion is also incompatible with the most common use of placement new.</p>\n<p>Regarding what other possible interpretations there are, that perhaps could be compatible with David's assertion, well, I can't think of any that make sense.</p>\n<p>So in conclusion, as far as the Holy Standard is concerned, merely casting oneself a <code>T*</code> pointer to the array is practically useful or not depending on the compiler, and accessing the pointed to could-be-value is valid or not depending on what's present. In particular, think of a trap representation of <code>int</code>: you would not want that blowing up on you, if the bitpattern happened to be that. So to be safe you have to know what's in there, the bits, and as the call to <code>foo</code> above illustrates <em>the compiler can in general not know that</em>, like, the g++ compiler's strict alignment-based optimizer can in general not know that\u2026</p>\n", "OwnerUserId": "464581", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:07.537", "Id": "12614819", "Score": "2", "CreationDate": "2012-09-27T05:46:55.137", "LastActivityDate": "2012-09-27T07:39:11.067"}, "12612488": {"CommentCount": "24", "AcceptedAnswerId": "12615861", "PostTypeId": "1", "LastEditorUserId": "75889", "CreationDate": "2012-09-27T00:45:24.040", "LastActivityDate": "2016-03-31T17:44:11.063", "LastEditDate": "2016-03-31T17:44:11.063", "ViewCount": "2506", "FavoriteCount": "11", "Title": "Aliasing `T*` with `char*` is allowed. Is it also allowed the other way around?", "Id": "12612488", "Score": "22", "Body": "<p><strong>Note:</strong> This question has been renamed and reduced to make it more focused and readable. Most of the comments refer to the old text.</p>\n<p>--</p>\n<p>According to the standard, objects of different type may not share the same memory location. So this would not be legal:</p>\n<pre><code>std::array&lt;short, 4&gt; shorts;\nint* i = reinterpret_cast&lt;int*&gt;(shorts.data()); // Not OK\n</code></pre>\n<p>The standard, however, allows an exception to this rule: any object may be accessed through a pointer to <code>char</code> or <code>unsigned char</code>:</p>\n<pre><code>int i = 0;\nchar * c = reinterpret_cast&lt;char*&gt;(&amp;i); // OK\n</code></pre>\n<p>However, it is not clear to me whether this is also allowed the other way around. For example:</p>\n<pre><code>char * c = read_socket(...);\nunsigned * u = reinterpret_cast&lt;unsigned*&gt;(c); // huh?\n</code></pre>\n", "Tags": "<c++><language-lawyer><strict-aliasing><type-punning>", "OwnerUserId": "75889", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_12612488_12615861_2": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_12612488_12613099_1": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_12612488_12615861_0": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_12612488_12614819_0": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_12612488_12615861_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_12612488_12615861_2": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_12612488_12613099_1": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_12612488_12615861_0": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_12612488_12614819_0": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_12612488_12615861_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_12612488_12615861_2": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_12612488_12614819_0": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_12612488_12615861_0": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_12612488_12613099_1": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_12612488_12615861_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}, "12615861": {"ParentId": "12612488", "CommentCount": "9", "Body": "<p>Some of your code is questionable due to the pointer conversions involved. Keep in mind that in those instances <code>reinterpret_cast&lt;T*&gt;(e)</code> has the semantics of <code>static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(e))</code> because the types that are involved are standard-layout. (I would in fact recommend that you <em>always</em> use <code>static_cast</code> via <code>cv void*</code> when dealing with storage.)</p>\n<p>A close reading of the Standard suggests that during a pointer conversion to or from <code>T*</code> it is assumed that there really is an actual object <code>T*</code> involved -- which is hard to fulfill in some of your snippet, even when 'cheating' thanks to the triviality of types involved (more on this later). That would be besides the point however because...</p>\n<p><strong>Aliasing is not about pointer conversions.</strong> This is the C++11 text that outlines the rules that are commonly referred to as 'strict aliasing' rules, from 3.10 Lvalues and rvalues [basic.lval]:</p>\n<blockquote>\n<p id=\"so_12612488_12615861_0\">10 If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<p>(This is paragraph 15 of the same clause and subclause in C++03, with some minor changes in the text with e.g. 'lvalue' being used instead of 'glvalue' since the latter is a C++11 notion.)</p>\n<p>In the light of those rules, let's assume that an implementation provides us with <code>magic_cast&lt;T*&gt;(p)</code> which 'somehow' converts a pointer to another pointer type. Normally this <em>would</em> be <code>reinterpret_cast</code>, which yields unspecified results in some cases, but as I've explained before this is not so for pointers to standard-layout types. Then it's plainly true that all of your snippets are correct (substituting <code>reinterpret_cast</code> with <code>magic_cast</code>), because no glvalues are involved whatsoever with the results of <code>magic_cast</code>.</p>\n<p>Here is a snippet that <em>appears</em> to incorrectly use <code>magic_cast</code>, but which I will argue is correct:</p>\n<pre><code>// assume constexpr max\nconstexpr auto alignment = max(alignof(int), alignof(short));\nalignas(alignment) char c[sizeof(int)];\n// I'm assuming here that the OP really meant to use &amp;c and not c\n// this is, however, inconsequential\nauto p = magic_cast&lt;int*&gt;(&amp;c);\n*p = 42;\n*magic_cast&lt;short*&gt;(p) = 42;\n</code></pre>\n<p>To justify my reasoning, assume this superficially different snippet:</p>\n<pre><code>// alignment same as before\nalignas(alignment) char c[sizeof(int)];\n\nauto p = magic_cast&lt;int*&gt;(&amp;c);\n// end lifetime of c\nc.~decltype(c)();\n// reuse storage to construct new int object\nnew (&amp;c) int;\n\n*p = 42;\n\nauto q = magic_cast&lt;short*&gt;(p);\n// end lifetime of int object\np-&gt;~decltype(0)();\n// reuse storage again\nnew (p) short;\n\n*q = 42;\n</code></pre>\n<p>This snippet is carefully constructed. In particular, in <code>new (&amp;c) int;</code> I'm allowed to use <code>&amp;c</code> even though <code>c</code> was destroyed due to the rules laid out in paragraph 5 of 3.8 Object lifetime [basic.life]. Paragraph 6 of same gives very similar rules to references to storage, and paragraph 7 explains what happens to variables, pointers and references that used to refer to an object once its storage is reused -- I will refer collectively to those as 3.8/5-7.</p>\n<p>In this instance <code>&amp;c</code> is (implicitly) converted to <code>void*</code>, which is one of the correct use of a pointer to storage that has not been yet reused. Similarly <code>p</code> is obtained from <code>&amp;c</code> before the new <code>int</code> is constructed. Its definition could perhaps be moved to after the destruction of <code>c</code>, depending on how deep the implementation magic is, but certainly not after the <code>int</code> construction: paragraph 7 would apply and this is not one of the allowed situations. The construction of the <code>short</code> object also relies on <code>p</code> becoming a pointer to storage.</p>\n<p>Now, because <code>int</code> and <code>short</code> are trivial types, I don't have to use the explicit calls to destructors. I don't need the explicit calls to the constructors, either (that is to say, the calls to the usual, Standard placement new declared in <code>&lt;new&gt;</code>). From 3.8 Object lifetime [basic.life]:</p>\n<blockquote>\n<p id=\"so_12612488_12615861_1\">1 [...] The lifetime of an object of type T begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n<p id=\"so_12612488_12615861_2\">The lifetime of an object of type T ends when:</p>\n<ul>\n<li>if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>This means that I can rewrite the code such that, after folding the intermediate variable <code>q</code>, I end up with the original snippet.</p>\n<p>Do note that <code>p</code> cannot be folded away. That is to say, the following is defintively incorrect:</p>\n<pre><code>alignas(alignment) char c[sizeof(int)];\n*magic_cast&lt;int*&gt;(&amp;c) = 42;\n*magic_cast&lt;short*&gt;(&amp;c) = 42;\n</code></pre>\n<p>If we assume that an <code>int</code> object is (trivially) constructed with the second line, then that must mean <code>&amp;c</code> becomes a pointer to storage that has been reused. Thus the third line is incorrect -- although due to 3.8/5-7 and not due to aliasing rules strictly speaking.</p>\n<p>If we don't assume that, then the second line <em>is</em> a violation of aliasing rules: we're reading what is actually a <code>char c[sizeof(int)]</code> object through a glvalue of type <code>int</code>, which is not one of the allowed exception. By comparison, <code>*magic_cast&lt;unsigned char&gt;(&amp;c) = 42;</code> would be fine (we would assume a <code>short</code> object is trivially constructed on the third line).</p>\n<p>Just like Alf, I would also recommend that you explicitly make use of the Standard placement new when using storage. Skipping destruction for trivial types is fine, but when encountering <code>*some_magic_pointer = foo;</code> you're very much likely facing either a violation of 3.8/5-7 (no matter how magically that pointer was obtained) or of the aliasing rules. This means storing the result of the new expression, too, since you most likely can't reuse the magic pointer once your object is constructed -- due to 3.8/5-7 again.</p>\n<p>Reading the bytes of an object (this means using <code>char</code> or <code>unsigned char</code>) is fine however, and you don't even to use <code>reinterpret_cast</code> or anything magic at all. <code>static_cast</code> via <code>cv void*</code> is arguably fine for the job (although I do feel like the Standard could use some better wording there).</p>\n", "OwnerUserId": "726300", "PostTypeId": "2", "Id": "12615861", "Score": "16", "CreationDate": "2012-09-27T07:02:51.263", "LastActivityDate": "2012-09-27T07:02:51.263"}});