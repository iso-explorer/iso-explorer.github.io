post_cb({"bq_ids": {"n4140": {"so_41909225_41910370_0": {"length": 51, "quality": 0.8793103448275862, "section_id": 5328}}, "n3337": {"so_41909225_41910370_0": {"length": 49, "quality": 0.8448275862068966, "section_id": 5125}}, "n4659": {"so_41909225_41910370_0": {"length": 51, "quality": 0.8793103448275862, "section_id": 6749}}}, "41910370": {"Id": "41910370", "PostTypeId": "2", "Body": "<p>Lexing a source file <em>is</em> a good job for regexes. But for such a task, let's use a better regex engine than <code>std::regex</code>. Let's use PCRE (or <code>boost::regex</code>) at first. At the end of this post, I'll show what you can do with a less feature-packed engine.</p>\n<p>We only need to do partial lexing, ignoring all unrecognized tokens that won't affect string literals. What we need to handle is:</p>\n<ul>\n<li>Singleline comments</li>\n<li>Multiline comments</li>\n<li>Character literals</li>\n<li>String literals</li>\n</ul>\n<p>We'll be using the extended (<code>x</code>) option, which ignores whitespace in the pattern.</p>\n<h1>Comments</h1>\n<p>Here's what <code>[lex.comment]</code> says:</p>\n<blockquote>\n<p id=\"so_41909225_41910370_0\">The characters <code>/*</code> start a comment, which terminates with the characters <code>*/</code>. These comments do not nest.\n  The characters <code>//</code> start a comment, which terminates immediately before the next new-line character. If\n  there is a form-feed or a vertical-tab character in such a comment, only white-space characters shall appear\n  between it and the new-line that terminates the comment; no diagnostic is required. <em>[ Note: The comment\n  characters <code>//</code>, <code>/*</code>, and <code>*/</code> have no special meaning within a <code>//</code> comment and are treated just like other\n  characters. Similarly, the comment characters <code>//</code> and <code>/*</code> have no special meaning within a <code>/*</code> comment.\n  \u2014 end note ]</em></p>\n</blockquote>\n<pre class=\"lang-none prettyprint-override\"><code># singleline comment\n// .* (*SKIP)(*FAIL)\n\n# multiline comment\n| /\\* (?s: .*? ) \\*/ (*SKIP)(*FAIL)\n</code></pre>\n<p>Easy peasy. If you match anything there, just <code>(*SKIP)(*FAIL)</code> - meaning that you throw away the match. The <code>(?s: .*? )</code> applies the <code>s</code> (singleline) modifier to the <code>.</code> metacharacter, meaning it's allowed to match newlines.</p>\n<h1>Character literals</h1>\n<p>Here's the grammar from <code>[lex.ccon]</code>:</p>\n<blockquote id=\"so_41909225_41910370_1\">\n<pre class=\"lang-none prettyprint-override\"><code> character-literal:  \n    encoding-prefix(opt) \u2019 c-char-sequence \u2019\n  encoding-prefix:\n    one of u8 u U L\n  c-char-sequence:\n    c-char\n    c-char-sequence c-char\n  c-char:\n    any member of the source character set except the single-quote \u2019, backslash \\, or new-line character\n    escape-sequence\n    universal-character-name\n  escape-sequence:\n    simple-escape-sequence\n    octal-escape-sequence\n    hexadecimal-escape-sequence\n  simple-escape-sequence: one of \\\u2019 \\\" \\? \\\\ \\a \\b \\f \\n \\r \\t \\v\n  octal-escape-sequence:\n    \\ octal-digit\n    \\ octal-digit octal-digit\n    \\ octal-digit octal-digit octal-digit\n  hexadecimal-escape-sequence:\n    \\x hexadecimal-digit\n    hexadecimal-escape-sequence hexadecimal-digit\n</code></pre>\n</blockquote>\n<p>Let's <em>define</em> a few things first, which we'll need later on:</p>\n<pre class=\"lang-none prettyprint-override\"><code>(?(DEFINE)\n  (?&lt;prefix&gt; (?:u8?|U|L)? )\n  (?&lt;escape&gt; \\\\ (?:\n    ['\"?\\\\abfnrtv]         # simple escape\n    | [0-7]{1,3}           # octal escape\n    | x [0-9a-fA-F]{1,2}   # hex escape\n    | u [0-9a-fA-F]{4}     # universal character name\n    | U [0-9a-fA-F]{8}     # universal character name\n  ))\n)\n</code></pre>\n<ul>\n<li><code>prefix</code> is defined as an optional <code>u8</code>, <code>u</code>, <code>U</code> or <code>L</code></li>\n<li><code>escape</code> is defined as per the standard, except that I've merged <code>universal-character-name</code> into it for the sake of simplicity</li>\n</ul>\n<p>Once we have these, a character literal is pretty simple:</p>\n<pre class=\"lang-none prettyprint-override\"><code>(?&amp;prefix) ' (?&gt; (?&amp;escape) | [^'\\\\\\r\\n]+ )+ ' (*SKIP)(*FAIL)\n</code></pre>\n<p>We throw it away with <code>(*SKIP)(*FAIL)</code></p>\n<h1>Simple strings</h1>\n<p>They're defined in almost the same way as character literals. Here's a part of <code>[lex.string]</code>:</p>\n<blockquote id=\"so_41909225_41910370_2\">\n<pre class=\"lang-none prettyprint-override\"><code>  string-literal:\n    encoding-prefix(opt) \" s-char-sequence(opt) \"\n    encoding-prefix(opt) R raw-string\n  s-char-sequence:\n    s-char\n    s-char-sequence s-char\n  s-char:\n    any member of the source character set except the double-quote \", backslash \\, or new-line character\n    escape-sequence\n    universal-character-name\n</code></pre>\n</blockquote>\n<p>This will mirror the character literals:</p>\n<pre class=\"lang-none prettyprint-override\"><code>(?&amp;prefix) \" (?&gt; (?&amp;escape) | [^\"\\\\\\r\\n]+ )* \"\n</code></pre>\n<p>The differences are:</p>\n<ul>\n<li>The character sequence is optional this time (<code>*</code> instead of <code>+</code>)</li>\n<li>The double quote is disallowed when unescaped instead of the single quote</li>\n<li>We actually <em>don't</em> throw it away :)</li>\n</ul>\n<h1>Raw strings</h1>\n<p>Here's the raw string part:</p>\n<blockquote id=\"so_41909225_41910370_3\">\n<pre class=\"lang-none prettyprint-override\"><code>  raw-string:\n    \" d-char-sequence(opt) ( r-char-sequence(opt) ) d-char-sequence(opt) \"\n  r-char-sequence:\n    r-char\n    r-char-sequence r-char\n  r-char:\n    any member of the source character set, except a right parenthesis )\n    followed by the initial d-char-sequence (which may be empty) followed by a double quote \".\n  d-char-sequence:\n    d-char\n    d-char-sequence d-char\n  d-char:\n    any member of the basic source character set except:\n    space, the left parenthesis (, the right parenthesis ), the backslash \\,\n    and the control characters representing horizontal tab,\n    vertical tab, form feed, and newline.\n</code></pre>\n</blockquote>\n<p>The regex for this is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>(?&amp;prefix) R \" (?&lt;delimiter&gt;[^ ()\\\\\\t\\x0B\\r\\n]*) \\( (?s:.*?) \\) \\k&lt;delimiter&gt; \"\n</code></pre>\n<ul>\n<li><code>[^ ()\\\\\\t\\x0B\\r\\n]*</code> is the set of characters that are allowed in delimiters (<code>d-char</code>)</li>\n<li><code>\\k&lt;delimiter&gt;</code> refers to the previously matched delimiter</li>\n</ul>\n<h1>The full pattern</h1>\n<p>The full pattern is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>(?(DEFINE)\n  (?&lt;prefix&gt; (?:u8?|U|L)? )\n  (?&lt;escape&gt; \\\\ (?:\n    ['\"?\\\\abfnrtv]         # simple escape\n    | [0-7]{1,3}           # octal escape\n    | x [0-9a-fA-F]{1,2}   # hex escape\n    | u [0-9a-fA-F]{4}     # universal character name\n    | U [0-9a-fA-F]{8}     # universal character name\n  ))\n)\n\n# singleline comment\n// .* (*SKIP)(*FAIL)\n\n# multiline comment\n| /\\* (?s: .*? ) \\*/ (*SKIP)(*FAIL)\n\n# character literal\n| (?&amp;prefix) ' (?&gt; (?&amp;escape) | [^'\\\\\\r\\n]+ )+ ' (*SKIP)(*FAIL)\n\n# standard string\n| (?&amp;prefix) \" (?&gt; (?&amp;escape) | [^\"\\\\\\r\\n]+ )* \"\n\n# raw string\n| (?&amp;prefix) R \" (?&lt;delimiter&gt;[^ ()\\\\\\t\\x0B\\r\\n]*) \\( (?s:.*?) \\) \\k&lt;delimiter&gt; \"\n</code></pre>\n<p>See <a href=\"https://regex101.com/r/0rNMKt/2\" rel=\"nofollow noreferrer\">the demo here</a>.</p>\n<h1><code>boost::regex</code></h1>\n<p>Here's a simple demo program using <a href=\"http://www.boost.org/doc/libs/1_63_0/libs/regex/doc/html/index.html\" rel=\"nofollow noreferrer\"><code>boost::regex</code></a>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;boost/regex.hpp&gt;\n\nstatic void test()\n{\n    boost::regex re(R\"regex(\n        (?(DEFINE)\n          (?&lt;prefix&gt; (?:u8?|U|L) )\n          (?&lt;escape&gt; \\\\ (?:\n            ['\"?\\\\abfnrtv]         # simple escape\n            | [0-7]{1,3}           # octal escape\n            | x [0-9a-fA-F]{1,2}   # hex escape\n            | u [0-9a-fA-F]{4}     # universal character name\n            | U [0-9a-fA-F]{8}     # universal character name\n          ))\n        )\n\n        # singleline comment\n        // .* (*SKIP)(*FAIL)\n\n        # multiline comment\n        | /\\* (?s: .*? ) \\*/ (*SKIP)(*FAIL)\n\n        # character literal\n        | (?&amp;prefix)? ' (?&gt; (?&amp;escape) | [^'\\\\\\r\\n]+ )+ ' (*SKIP)(*FAIL)\n\n        # standard string\n        | (?&amp;prefix)? \" (?&gt; (?&amp;escape) | [^\"\\\\\\r\\n]+ )* \"\n\n        # raw string\n        | (?&amp;prefix)? R \" (?&lt;delimiter&gt;[^ ()\\\\\\t\\x0B\\r\\n]*) \\( (?s:.*?) \\) \\k&lt;delimiter&gt; \"\n    )regex\", boost::regex::perl | boost::regex::no_mod_s | boost::regex::mod_x | boost::regex::optimize);\n\n    std::string subject(R\"subject(\nstd::cout &lt;&lt; L\"hello\" &lt;&lt; \" world\";\nstd::cout &lt;&lt; \"He said: \\\"bananas\\\"\" &lt;&lt; \"...\";\nstd::cout &lt;&lt; \"\";\nstd::cout &lt;&lt; \"\\x12\\23\\x34\";\nstd::cout &lt;&lt; u8R\"hello(this\"is\\a\\\"\"\"\"single\\\\(valid)\"\nraw string literal)hello\";\n\n\"\" // empty string\n'\"' // character literal\n\n// this is \"a string literal\" in a comment\n/* this is\n   \"also inside\"\n   //a comment */\n\n// and this /*\n\"is not in a comment\"\n// */\n\n\"this is a /* string */ with nested // comments\"\n    )subject\");\n\n    std::cout &lt;&lt; boost::regex_replace(subject, re, \"String\\\\($&amp;\\\\)\", boost::format_all) &lt;&lt; std::endl;\n}\n\nint main(int argc, char **argv)\n{\n    try\n    {\n        test();\n    }\n    catch(std::exception ex)\n    {\n        std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>(I left syntax highlighting disabled because it goes nuts on this code)</p>\n<p>For some reason, I had to take the <code>?</code> quantifier out of <code>prefix</code> (change <code>(?&lt;prefix&gt; (?:u8?|U|L)? )</code> to <code>(?&lt;prefix&gt; (?:u8?|U|L) )</code> and <code>(?&amp;prefix)</code> to <code>(?&amp;prefix)?</code>) to make the pattern work. I believe it's a bug in boost::regex, as both PCRE and Perl work just fine with the original pattern.</p>\n<h1>What if we don't have a fancy regex engine at hand?</h1>\n<p>Note that while this pattern technically uses recursion, it never nests recursive calls. Recursion could be avoided by inlining the relevant reusable parts into the main pattern.</p>\n<p>A couple of other constructs can be avoided at the price of reduced performance. We can safely replace the atomic groups <code>(?&gt;</code>...<code>)</code> with normal groups <code>(?:</code>...<code>)</code> if we don't nest quantifiers in order to avoid <a href=\"http://www.regular-expressions.info/catastrophic.html\" rel=\"nofollow noreferrer\">catastrophic backtracking</a>.</p>\n<p>We can also avoid <code>(*SKIP)(*FAIL)</code> if we add one line of logic into the replacement function: All the alternatives to skip are grouped in a capturing group. If the capturing group matched, just ignore the match. If not, then it's a string literal.</p>\n<p>All of this means we can implement this in JavaScript, which has one of the simplest regex engines you can find, at the price of breaking the DRY rule and making the pattern illegible. The regex becomes this monstrosity once converted:</p>\n<pre class=\"lang-none prettyprint-override\"><code>(\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\/|(?:u8?|U|L)?'(?:\\\\(?:['\"?\\\\abfnrtv]|[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})|[^'\\\\\\r\\n])+')|(?:u8?|U|L)?\"(?:\\\\(?:['\"?\\\\abfnrtv]|[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})|[^\"\\\\\\r\\n])*\"|(?:u8?|U|L)?R\"([^ ()\\\\\\t\\x0B\\r\\n]*)\\([\\s\\S]*?\\)\\2\"\n</code></pre>\n<p>And here's an interactive demo you can play with:</p>\n<p><div class=\"snippet\" data-babel=\"false\" data-console=\"true\" data-hide=\"false\" data-lang=\"js\">\n<div class=\"snippet-code\">\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function run() {\r\n    var re = /(\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\/|(?:u8?|U|L)?'(?:\\\\(?:['\"?\\\\abfnrtv]|[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})|[^'\\\\\\r\\n])+')|(?:u8?|U|L)?\"(?:\\\\(?:['\"?\\\\abfnrtv]|[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})|[^\"\\\\\\r\\n])*\"|(?:u8?|U|L)?R\"([^ ()\\\\\\t\\x0B\\r\\n]*)\\([\\s\\S]*?\\)\\2\"/g;\r\n    \r\n    var input = document.getElementById(\"input\").value;\r\n    var output = input.replace(re, function(m, ignore) {\r\n        return ignore ? m : \"String(\" + m + \")\";\r\n    });\r\n    document.getElementById(\"output\").innerText = output;\r\n}\r\n\r\ndocument.getElementById(\"input\").addEventListener(\"input\", run);\r\nrun();</code></pre>\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;h2&gt;Input:&lt;/h2&gt;\r\n&lt;textarea id=\"input\" style=\"width: 100%; height: 50px;\"&gt;\r\nstd::cout &lt;&lt; L\"hello\" &lt;&lt; \" world\";\r\nstd::cout &lt;&lt; \"He said: \\\"bananas\\\"\" &lt;&lt; \"...\";\r\nstd::cout &lt;&lt; \"\";\r\nstd::cout &lt;&lt; \"\\x12\\23\\x34\";\r\nstd::cout &lt;&lt; u8R\"hello(this\"is\\a\\\"\"\"\"single\\\\(valid)\"\r\nraw string literal)hello\";\r\n\r\n\"\" // empty string\r\n'\"' // character literal\r\n\r\n// this is \"a string literal\" in a comment\r\n/* this is\r\n   \"also inside\"\r\n   //a comment */\r\n\r\n// and this /*\r\n\"is not in a comment\"\r\n// */\r\n\r\n\"this is a /* string */ with nested // comments\"\r\n&lt;/textarea&gt;\r\n&lt;h2&gt;Output:&lt;/h2&gt;\r\n&lt;pre id=\"output\"&gt;&lt;/pre&gt;</code></pre>\n</div>\n</div>\n</p>\n", "LastEditorUserId": "3764814", "LastActivityDate": "2017-01-29T00:59:15.517", "Score": "4", "CreationDate": "2017-01-28T13:30:12.503", "ParentId": "41909225", "CommentCount": "2", "OwnerUserId": "3764814", "LastEditDate": "2017-01-29T00:59:15.517"}, "41909524": {"Id": "41909524", "PostTypeId": "2", "Body": "<p>Read the relevant sections from the C++ standard, they are called <code>lex.ccon</code> and <code>lex.string</code>.</p>\n<p>Then convert each rule you find there into a regular expression (if you really want to use regular expressions; it might turn out that they are not capable of doing this job).</p>\n<p>Then, build more complicated regular expressions out of them. Be sure to name your regular expressions exactly as the rules from the C++ standard, so that you can recheck them later.</p>\n<p>If, instead of using regular expressions, you want to use an existing tool, here is one: <a href=\"http://clang.llvm.org/doxygen/Lexer_8cpp_source.html\" rel=\"nofollow noreferrer\">http://clang.llvm.org/doxygen/Lexer_8cpp_source.html</a>. Have a look at the <code>LexStringLiteral</code> function.</p>\n", "LastEditorUserId": "225757", "LastActivityDate": "2017-01-28T12:13:46.657", "Score": "2", "CreationDate": "2017-01-28T11:57:10.193", "ParentId": "41909225", "CommentCount": "7", "OwnerUserId": "225757", "LastEditDate": "2017-01-28T12:13:46.657"}, "41911933": {"Id": "41911933", "PostTypeId": "2", "Body": "<p>Regular expressions can be tricky for beginners but once you understand it's basics and well tested <strong>divide and conquer</strong> strategy, it will be your goto tool.</p>\n<p>What you need to search for quote (\") not starting with () back slash and read all characters upto next quote.</p>\n<p>The regex I came up is <code>(\".*?[^\\\\]\")</code>. See a code snippet below.</p>\n<pre><code>std::string in_line = \"std::cout &lt;&lt; \\\"He said: \\\\\\\"bananas\\\\\\\"\\\" &lt;&lt; \\\"...\\\";\";\n\nstd::regex re(R\"((\".*?[^\\\\]\"))\");\nin_line = std::regex_replace(in_line, re, \"String($1)\");\n\nstd::cout &lt;&lt; in_line &lt;&lt; endl;\n</code></pre>\n<p>Output:</p>\n<pre><code>std::cout &lt;&lt; String(\"He said: \\\"bananas\\\"\") &lt;&lt; String(\"...\");\n</code></pre>\n<p><strong>Regex Explanation:</strong></p>\n<pre><code>(\".*?[^\\\\]\")\n</code></pre>\n<p>Options: Case\u00a0sensitive; Numbered\u00a0capture; Allow\u00a0zero-length\u00a0matches; Regex\u00a0syntax\u00a0only</p>\n<ul>\n<li>Match the regex below and capture its match into backreference number 1 <code>(\".*?[^\\\\]\")</code>\n<ul>\n<li>Match the character \u201c\"\u201d literally <code>\"</code></li>\n<li>Match any single character that is NOT a line break character (line feed, carriage return) <code>.*?</code>\n<ul>\n<li>Between zero and unlimited times, as few times as possible, expanding as needed (lazy) <code>*?</code></li>\n</ul></li>\n<li>Match any character that is NOT the backslash character <code>[^\\\\]</code></li>\n<li>Match the character \u201c\"\u201d literally <code>\"</code></li>\n</ul></li>\n</ul>\n<p>String($1)</p>\n<ul>\n<li>Insert the character string \u201cString\u201d literally <code>String</code></li>\n<li>Insert an opening parenthesis <code>(</code></li>\n<li>Insert the text that was last matched by capturing group number 1 <code>$1</code></li>\n<li>Insert a closing parenthesis <code>)</code></li>\n</ul>\n", "LastActivityDate": "2017-01-28T16:12:30.077", "CommentCount": "0", "CreationDate": "2017-01-28T16:12:30.077", "ParentId": "41909225", "Score": "1", "OwnerUserId": "5214807"}, "41909225": {"ViewCount": "629", "Body": "<p>I'm currently working on a C++ preprocessor and I need to match string constants with more than 0 letters like this <code>\"hey I'm a string</code>.\nI'm currently working with this one here <code>\\\"([^\\\\\\\"]+|\\\\.)+\\\"</code> but it fails on one of my test cases.</p>\n<p>Test cases:</p>\n<pre><code>std::cout &lt;&lt; \"hello\" &lt;&lt; \" world\";\nstd::cout &lt;&lt; \"He said: \\\"bananas\\\"\" &lt;&lt; \"...\";\nstd::cout &lt;&lt; \"\";\nstd::cout &lt;&lt; \"\\x12\\23\\x34\";\n</code></pre>\n<p>Expected output:</p>\n<pre><code>std::cout &lt;&lt; String(\"hello\") &lt;&lt; String(\" world\");\nstd::cout &lt;&lt; String(\"He said: \\\"bananas\\\"\") &lt;&lt; String(\"...\");\nstd::cout &lt;&lt; \"\";\nstd::cout &lt;&lt; String(\"\\x12\\23\\x34\");\n</code></pre>\n<p>On the second one I instead get</p>\n<pre><code>std::cout &lt;&lt; String(\"He said: \\\")bananas\\\"String(\" &lt;&lt; \")...\";\n</code></pre>\n<p>Short repro code (using the regex by AR.3):</p>\n<pre><code>std::string in_line = \"std::cout &lt;&lt; \\\"He said: \\\\\\\"bananas\\\\\\\"\\\" &lt;&lt; \\\"...\\\";\";\nstd::regex r(\"\\\"([^\\\"]+|\\\\.|(?&lt;=\\\\\\\\)\\\")+\\\"\");\nin_line = std::regex_replace(in_line, r, \"String($&amp;)\");\n</code></pre>\n", "Title": "Regex for matching C++ string constant", "CreationDate": "2017-01-28T11:26:01.880", "LastActivityDate": "2017-01-30T15:05:30.463", "CommentCount": "21", "LastEditDate": "2017-01-30T15:05:30.463", "PostTypeId": "1", "LastEditorUserId": "7026860", "Id": "41909225", "Score": "5", "OwnerUserId": "7026860", "Tags": "<c++><regex><string><c-preprocessor>", "AnswerCount": "3"}});