post_cb({"17409303": {"ParentId": "17409162", "CommentCount": "2", "Body": "<p>Beware of <code>union</code> and <code>reinterpret_cast&lt;double*&gt;(&amp;bits)</code>, for both of these methods are UB. Pretty much all you can do is memcpy.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "17409303", "Score": "5", "CreationDate": "2013-07-01T16:28:51.023", "LastActivityDate": "2013-07-01T16:28:51.023"}, "17409162": {"CommentCount": "4", "AcceptedAnswerId": "17409305", "CreationDate": "2013-07-01T16:20:37.917", "LastActivityDate": "2013-07-01T17:04:03.623", "PostTypeId": "1", "ViewCount": "1375", "FavoriteCount": "2", "Title": "Double from long bits", "Id": "17409162", "Score": "4", "Body": "<p>I have an <code>unsigned long long</code> (or <code>uint64_t</code>) value and want to convert it to a <code>double</code>. The double shall have the same bit pattern as the <code>long</code> value. This way I can set the bits of the double \"by hand\".</p>\n<pre><code>unsigned long long bits = 1ULL;\ndouble result = /* some magic here */ bits;\n</code></pre>\n<p>I am looking for a way to do this.</p>\n", "Tags": "<c++><gcc><double><long-integer>", "OwnerUserId": "432354", "AnswerCount": "4"}, "17409305": {"ParentId": "17409162", "CommentCount": "2", "Body": "<p>The portable way to do this is with <code>memcpy</code> (you may also be able to conditionally do it with <code>reinterpret_cast</code> or a union, but those aren't certain to be portable because they violate the letter of the strict-alias rules):</p>\n<pre><code>// First, static assert that the sizes are the same\nmemcpy(&amp;result, &amp;bits, sizeof(bits));\n</code></pre>\n<p>But before you do make sure you know exactly what you're doing and what floating point representation is being used (although IEEE754 is a popular/common choice). You'll want to avoid all kinds of problem values like infinity, NaN, and denormal numbers.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "17409305", "Score": "12", "CreationDate": "2013-07-01T16:28:51.893", "LastActivityDate": "2013-07-01T16:28:51.893"}, "17409309": {"ParentId": "17409162", "CommentCount": "5", "Body": "<p>The following uses a void pointer. </p>\n<pre><code>unsigned long long bits = 1ULL;\nvoid* tempPtr=(void*)&amp;bits;\ndouble result = *(double*)tempPtr;\n</code></pre>\n", "OwnerUserId": "2460632", "PostTypeId": "2", "Id": "17409309", "Score": "-2", "CreationDate": "2013-07-01T16:29:05.237", "LastActivityDate": "2013-07-01T16:29:05.237"}, "17409509": {"ParentId": "17409162", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is called a <em>type pun</em> - referring to the same object in memory via two different types. In C++ it's done with <code>reinterpret_cast</code></p>\n<pre><code>double result = reinterpret_cast&lt;double&amp;&gt;(bits);\n</code></pre>\n<p>per C++11 standard <strong>5.2.10/11 Reinterpret cast [expr.reinterpret.cast]</strong>:</p>\n<blockquote>\n<p id=\"so_17409162_17409509_0\">An lvalue expression of type T1 can be cast to the type \u201creference to T2\u201d if an expression of type \u201cpointer to\n  T1\u201d can be explicitly converted to the type \u201cpointer to T2\u201d using a reinterpret_cast. That is, a reference\n  cast reinterpret_cast&lt;T&amp;&gt;(x) has the same effect as the conversion *reinterpret_cast&lt;T*&gt;(&amp;x) with\n  the built-in &amp; and * operators (and similarly for reinterpret_cast&lt;T&amp;&amp;&gt;(x)). The result refers to the same\n  object as the source lvalue, but with a different type. The result is an lvalue for an lvalue reference type or\n  an rvalue reference to function type and an xvalue for an rvalue reference to object type. No temporary is\n  created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.</p>\n</blockquote>\n<p>The premise:</p>\n<blockquote>\n<p id=\"so_17409162_17409509_1\">...if an expression of type \u201cpointer to T1\u201d can be explicitly converted to the type \u201cpointer to T2\u201d using a reinterpret_cast.</p>\n</blockquote>\n<p>is covered in p7 of the same section:</p>\n<blockquote>\n<p id=\"so_17409162_17409509_2\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v)) if both T1 and T2 are standard-layout types (3.9) and the alignment\n  requirements of T2 are no stricter than those of T1, or if either type is void.</p>\n</blockquote>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2013-07-01T17:04:03.623", "Id": "17409509", "Score": "-1", "CreationDate": "2013-07-01T16:40:23.740", "LastActivityDate": "2013-07-01T17:04:03.623"}, "bq_ids": {"n4140": {"so_17409162_17409509_2": {"section_id": 6046, "quality": 0.7741935483870968, "length": 24}, "so_17409162_17409509_1": {"section_id": 6050, "quality": 1.0, "length": 10}}, "n3337": {"so_17409162_17409509_2": {"section_id": 5814, "quality": 0.9354838709677419, "length": 29}, "so_17409162_17409509_1": {"section_id": 5818, "quality": 1.0, "length": 10}, "so_17409162_17409509_0": {"section_id": 5818, "quality": 0.875, "length": 56}}, "n4659": {"so_17409162_17409509_2": {"section_id": 7545, "quality": 0.7419354838709677, "length": 23}, "so_17409162_17409509_1": {"section_id": 7549, "quality": 1.0, "length": 10}}}});