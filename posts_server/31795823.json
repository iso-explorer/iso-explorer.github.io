post_cb({"31796009": {"ParentId": "31795823", "CommentCount": "2", "Body": "<p>No, the lifetime of <code>count</code> is not extended because you capture it by reference. <a href=\"https://stackoverflow.com/a/6937829/241631\">Lifetime extension rules</a> are listed in <em>\u00a712.2 [class.temporary]</em>, items 4 &amp; 5, and neither include capture by reference in a lambda.</p>\n<p>Invoking the lambda returned by <code>genfunc</code> will result in undefined behavior. This is mentioned in a note in <em>\u00a75.1.2/24 [expr.prim.lambda]</em></p>\n<blockquote>\n<p id=\"so_31795823_31796009_0\">[ <em>Note:</em> If an entity is implicitly or explicitly captured by reference, invoking the function call operator of the corresponding lambda-expression after the lifetime of the entity has ended is likely to result in undefined\n  behavior. <em>\u2014end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "31796009", "Score": "6", "CreationDate": "2015-08-03T20:17:13.190", "LastActivityDate": "2015-08-03T20:17:13.190"}, "31796051": {"ParentId": "31795823", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_31795823_31796051_0\">does the life of the automatic get extended to the life of the lambda function?</p>\n</blockquote>\n<p>No. The lambda might be confusing here, so let's rewrite it to be a struct:</p>\n<pre><code>struct X\n{\n    int operator()() const { return ref++; }\n\n    int&amp; ref;\n};\n\nauto genfunc (int start)\n{\n    int count=start;\n    return X{count};\n}\n</code></pre>\n<p>The <code>X</code> object that we created holds a reference (<code>ref</code>) to a temporary (<code>count</code>) that goes out of scope as soon as the object is returned. There's nothing special about the lambda - a dangling reference is a dangling reference.</p>\n<p>There's no reason to keep the reference though, just capture by-value:</p>\n<pre><code>auto genfunc (int start)\n{\n     return [start]() mutable {\n         return start++;\n     };\n}\n</code></pre>\n<p>Note the required <code>mutable</code> keyword.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31796051", "Score": "5", "CreationDate": "2015-08-03T20:20:18.813", "LastActivityDate": "2015-08-03T20:20:18.813"}, "31795823": {"CommentCount": "0", "ViewCount": "82", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2015-08-03T20:04:37.763", "LastActivityDate": "2015-08-03T20:22:03.573", "Title": "What is the life span of an automatic bound to a lamba function?", "AcceptedAnswerId": "31796009", "LastEditDate": "2015-08-03T20:19:19.103", "Id": "31795823", "Score": "1", "Body": "<p>If an automatic is bound to a lambda function, does the life of the automatic get extended to the life of the lambda function?</p>\n<p>Simplest case:</p>\n<pre><code>auto genfunc (int start)\n{\n     int count=start;\n     return [&amp;count] {\n         return count++;\n     };\n}\n</code></pre>\n<p>Is this fine, or undefined behavior?</p>\n", "Tags": "<c++><c++11><lambda><c++14>", "OwnerUserId": "2963099", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31795823_31796009_0": {"section_id": 5982, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_31795823_31796009_0": {"section_id": 5750, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_31795823_31796009_0": {"section_id": 7479, "quality": 0.8636363636363636, "length": 19}}}});