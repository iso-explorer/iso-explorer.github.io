post_cb({"42528917": {"CommentCount": "11", "ViewCount": "146", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2017-03-01T10:15:00.797", "LastActivityDate": "2017-03-02T16:39:43.793", "Title": "Declaring variable with name `this` inside lambda inside parentheses leads to different results on 3 different compilers", "FavoriteCount": "1", "LastEditDate": "2017-03-01T16:40:43.227", "Id": "42528917", "Score": "6", "Body": "<p>In C++ it's possible to declare variable inside parentheses like <code>int (x) = 0;</code>. But it seems that if you use <code>this</code> instead of variable name, then constructor is used instead: <code>A (this);</code> calls <code>A::A(B*)</code>. So the first question is why it's different for <code>this</code>, is it because variables can't be named <code>this</code>? And to complicate matters a bit lets put <code>this</code> inside a lambda - </p>\n<pre><code>struct B;\nstruct A\n{\n  A (B *) {}\n};\n\nstruct B \n{\n  B ()\n  {\n    [this] { A (this); } ();\n  }\n};\n</code></pre>\n<p>Now gcc calls <code>A::A(B*)</code>, msvc prints error about missing default constructor and clang prints <code>expected expression</code> (<a href=\"https://godbolt.org/g/Vxe0fF\" rel=\"nofollow noreferrer\">https://godbolt.org/g/Vxe0fF</a>). It's even funnier in msvc - it really creates variable with name <code>this</code> that you can use, so it's definitely a bug (<a href=\"https://godbolt.org/g/iQaaPH\" rel=\"nofollow noreferrer\">https://godbolt.org/g/iQaaPH</a>). Which compiler is right and what are the reasons for such behavior?</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "3256948", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42528917_42559940_2": {"section_id": 5977, "quality": 0.9333333333333333, "length": 14}, "so_42528917_42559940_0": {"section_id": 5966, "quality": 0.8484848484848485, "length": 28}}, "n3337": {"so_42528917_42559940_2": {"section_id": 5745, "quality": 0.9333333333333333, "length": 14}, "so_42528917_42559940_0": {"section_id": 5735, "quality": 0.8484848484848485, "length": 28}}, "n4659": {"so_42528917_42559940_2": {"section_id": 7474, "quality": 1.0, "length": 15}, "so_42528917_42559940_0": {"section_id": 7460, "quality": 0.8484848484848485, "length": 28}}}, "42559940": {"ParentId": "42528917", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-03-02T15:50:44.520", "Score": "1", "LastEditorUserId": "5632316", "LastEditDate": "2017-03-02T16:39:43.793", "Id": "42559940", "OwnerUserId": "5632316", "Body": "<p>In the C++ standard \u00a75.1.5 (article 7 for C++11, article 8 later standard) [expr.prim.lambda]:</p>\n<blockquote>\n<p id=\"so_42528917_42559940_0\">The lambda-expression\u2019s compound-statement yields the function-body (8.4) of the function call operator, but\n  for purposes of name lookup (3.4), determining the type and value of this (9.2.2.1) and transforming id-\n  expressions referring to non-static class members into class member access expressions using (*this) (9.2.2),\n  the compound-statement is considered in the context of the lambda-expression. [ Example:</p>\n</blockquote>\n<pre><code>struct S1 {\n  int x, y;\n  int operator()(int);\n  void f() {\n    [=]()-&gt;int {\n      return operator()(this-&gt;x + y); // equivalent to S1::operator()(this-&gt;x + (*this).y)\n                                      // this has type S1*\n               };\n  }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_42528917_42559940_1\">\u2014 end example ]</p>\n</blockquote>\n<p>Thus, gcc is right. You will notice that their is no exception about the fact that you are capturing <code>this</code>. Their is, however a precision since C++14 in the case where you capture <code>*this</code>, still in \u00a75.1.5 (article 17):</p>\n<blockquote>\n<p id=\"so_42528917_42559940_2\">If *this is captured by copy, each odr-use of this is transformed into a pointer to the corresponding\n  unnamed data member of the closure type, cast (5.4) to the type of this.</p>\n</blockquote>\n", "LastActivityDate": "2017-03-02T16:39:43.793"}});