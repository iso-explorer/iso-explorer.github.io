post_cb({"bq_ids": {"n4140": {"so_36852367_36852367_1": {"length": 56, "quality": 0.9032258064516129, "section_id": 3326}}, "n3337": {"so_36852367_36852367_1": {"length": 56, "quality": 0.9032258064516129, "section_id": 3196}}, "n4659": {"so_36852367_36852367_1": {"length": 56, "quality": 0.9032258064516129, "section_id": 4092}}}, "38172664": {"Id": "38172664", "PostTypeId": "2", "Body": "<p>This note is not related to evaluation order. As it was stated in one of comments, it's about order of converting actual parameters to rvalues and standard does not define such order.\nYou should receive following warning (gcc):</p>\n<pre><code>17:58: warning: operation on 'i' may be undefined [-Wsequence-point]\n</code></pre>\n<p>I modified a program slightly to demonstrate how evaluation of arguments work with {} and (). </p>\n<p><strong>With such modification, program does not depend on order of converting lvalue to rvalue, thus does not have ambiguity which disappointed you.</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct MyType {\n  MyType(int i, int j)\n    : sum(i + j)\n  {\n\n  }\n\n  int sum;\n};\n\nint main()\n{\n  int i = 0;\n  int a,b;\n  std::cout &lt;&lt; MyType{ (a = ++i), (b = ++i) }.sum &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Here clauses are evaluated in order they appear: a=\" &lt;&lt; a &lt;&lt; \", b=\" &lt;&lt; b &lt;&lt; std::endl;\n  i = 0;\n  std::cout &lt;&lt; MyType( (a = ++i), (b = ++i) ).sum &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Here order of evaluation depends on implementation: a=\" &lt;&lt; a &lt;&lt; \", b=\" &lt;&lt; b &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And the output of this program for clang and gcc:</p>\n<p>clang:</p>\n<pre><code>3\nHere clauses are evaluated in order they appear: a=1, b=2\n3\nHere order of evaluation depends on implementation: a=1, b=2\n</code></pre>\n<p>gcc:</p>\n<pre><code>3\nHere clauses are evaluated in order they appear: a=1, b=2\n3\nHere order of evaluation depends on implementation: a=2, b=1\n</code></pre>\n<p>As you can see, in case of curly brackets, clauses are evaluated in order of appearance under both compilers, which corresponds to the note you provided.</p>\n", "LastActivityDate": "2016-07-03T17:42:57.990", "CommentCount": "3", "CreationDate": "2016-07-03T17:42:57.990", "ParentId": "36852367", "Score": "0", "OwnerUserId": "6493253"}, "38205997": {"Id": "38205997", "PostTypeId": "2", "Body": "<p>The answer seems to be that yes, this is a bug in both GCC and MSVC.</p>\n<p>This is the status of this issue:</p>\n<ol>\n<li>There are several bugs against GCC regarding init-list rules. Most of them have gone completely unacknowledged by the GCC team. This at least implies that G++ does have bugs here because the issues have not been closed as invalid</li>\n<li>I have received unofficial word from the MSVC compiler team that this is in fact a bug in their compiler and they are working internally to fix it. However, I have no external bug to point to. As of MSVC 2015 Update 3, the old behavior remains.</li>\n<li>Clang, which at this point is by far the most pedantic standards-complaint compiler, implements it the way the standard seems to read.</li>\n</ol>\n<p>My personal investigation, discussions with C++ experts at conferences, and unofficial answers I've received from compiler developers indicates that this is a bug in MSVC and GCC, but I'm always reluctant to answer my own questions on StackOverflow. But here we are.</p>\n", "LastActivityDate": "2016-07-05T14:26:47.183", "CommentCount": "0", "CreationDate": "2016-07-05T14:26:47.183", "ParentId": "36852367", "Score": "3", "OwnerUserId": "29975"}, "36852367": {"ViewCount": "405", "Body": "<p>According to the n4296 C++ standard document:</p>\n<blockquote>\n<p id=\"so_36852367_36852367_0\">[dcl.init.list] (8.5.4.4) (pg223-224)</p>\n<p id=\"so_36852367_36852367_1\">Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (14.5.3), are evaluated in the order in which they appear. That is,\n  every value computation and side effect associated with a given\n  initializer-clause is sequenced before every value computation and\n  side effect associated with any initializer-clause that follows it in\n  the comma-separated list of the initializer-list. <em>[Note: This\n  evaluation ordering holds regardless of the semantics of the\n  initialization; for example, it applies when the elements of the\n  initializer-list are interpreted as arguments of a constructor call,\n  even though ordinarily there are no sequencing constraints on the\n  arguments of a call. \u2014end note ]</em></p>\n<p id=\"so_36852367_36852367_2\">(emphasis mine)</p>\n</blockquote>\n<p>The note was added here: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1030\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1030</a></p>\n<p>This reads to me that the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct MyType {\n  MyType(int i, int j, int k, int l)\n    : sum(i + j + k + l)\n  {\n\n  }\n\n  int sum;\n};\n\nint main()\n{\n  int i = 0;\n  std::cout &lt;&lt; MyType{ ++i, ++i, ++i, ++i }.sum &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Should print \"10\".</p>\n<p>This is my reasoning:</p>\n<ul>\n<li>MyType is being initialized via a braced-init-list</li>\n<li>braced-init-lists are evaluated in order</li>\n<li>even when it is <em>interpreted as arguments of a constructor call</em></li>\n<li>this means that it should be evaluated as MyType(1,2,3,4)</li>\n</ul>\n<p>That is to say, the above code should behave exactly like this code:</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  int i = 0;\n  std::initializer_list&lt;int&gt; il{++i, ++i, ++i, ++i};\n  std::cout &lt;&lt; *il.begin() + *(il.begin() + 1) + *(il.begin() + 2) + *(il.begin() + 3) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>But it does not. The first example prints '16' and the second example prints '10'</p>\n<p>Literally every compiler from every vendor that I can get my hands on prints '16', <em>seemingly</em> ignoring that part of the standard and not inserting sequence points.</p>\n<p>What am I missing here?</p>\n<p>Note: The following seem to be related to this question:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/25115189/optimization-bug-regarding-gcc-stdthread\">(Optimization?) Bug regarding GCC std::thread</a></li>\n<li><a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51253\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51253</a></li>\n</ul>\n", "Title": "Are there sequence points in braced initializer lists when they apply to constructors?", "CreationDate": "2016-04-25T22:41:33.233", "LastActivityDate": "2016-07-05T14:26:47.183", "CommentCount": "12", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:01.060", "LastEditorUserId": "-1", "Id": "36852367", "Score": "19", "OwnerUserId": "29975", "Tags": "<c++><c++11><gcc><visual-c++><clang>", "AnswerCount": "2"}});