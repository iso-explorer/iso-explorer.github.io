post_cb({"37085442": {"Id": "37085442", "PostTypeId": "2", "Body": "<p>GCC's page on <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Volatiles.html\" rel=\"nofollow\">Volatile access</a> gives some insight into how it works:</p>\n<blockquote>\n<p id=\"so_37083614_37085442_0\">The standard encourages compilers to refrain from optimizations concerning accesses to volatile objects, but leaves it implementation defined as to what constitutes a volatile access. The minimum requirement is that at a sequence point all previous accesses to volatile objects have stabilized and no subsequent accesses have occurred. Thus an implementation is free to reorder and combine volatile accesses that occur between sequence points, but cannot do so for accesses across a sequence point. The use of volatile does not allow you to violate the restriction on updating objects multiple times between two sequence points. </p>\n</blockquote>\n<p>In C standardese:</p>\n<blockquote>\n<p id=\"so_37083614_37085442_1\">\u00a75.1.2.3 </p>\n<p id=\"so_37083614_37085442_2\">2 Accessing a volatile object, modifying an object, modifying a file,\n  or calling a function that does any of those operations are all <em>side\n  effects</em>, <sup>11)</sup> which are changes in the state of the\n  execution environment. Evaluation of an expression may produce side\n  effects. At certain specified points in the execution sequence called\n  <em>sequence points</em>, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have\n  taken place. (A summary of the sequence points is given in annex C.)</p>\n<p id=\"so_37083614_37085442_3\">3 In the abstract machine, all expressions are evaluated as specified\n  by the semantics. An actual implementation need not evaluate part of\n  an expression if it can deduce that its value is not used and that no\n  needed side effects are produced (including any caused by calling a\n  function or accessing a volatile object).</p>\n<p id=\"so_37083614_37085442_4\"><em>[...]</em></p>\n<p id=\"so_37083614_37085442_5\">5 The least requirements on a conforming implementation are:</p>\n<ul>\n<li>At sequence points, volatile objects are stable in the sense that previous accesses are complete and subsequent accesses have not yet\n  occurred. <em>[...]</em></li>\n</ul>\n</blockquote>\n<p><sub>I chose the C standard because the language is simpler but the rules are essentially the same in C++. See the \"as-if\" rule.</sub></p>\n<p>Now on my machine, <code>-O1</code> doesn't optimize away the call to <code>foo()</code>, so let's use <code>-fdump-tree-optimized</code> to see the difference:</p>\n<p><code>-O1</code></p>\n<pre><code>*[definition to foo() omitted]*\n\n;; Function int main() (main, funcdef_no=4, decl_uid=2131, cgraph_uid=4, symbol_order=4) (executed once)\n\nint main() ()\n{\n  struct A a;\n\n  &lt;bb 2&gt;:\n  a.x ={v} 12;\n  a.x ={v} 13;\n  a = foo ();\n  a ={v} {CLOBBER};\n  return 0;\n} \n</code></pre>\n<p>And <code>-O3</code>:</p>\n<pre><code>*[definition to foo() omitted]*\n\n;; Function int main() (main, funcdef_no=4, decl_uid=2131, cgraph_uid=4, symbol_order=4) (executed once)\n\nint main() ()\n{\n  struct A ret;\n  struct A a;\n\n  &lt;bb 2&gt;:\n  a.x ={v} 12;\n  a.x ={v} 13;\n  ret.x ={v} 12;\n  ret ={v} {CLOBBER};\n  a ={v} {CLOBBER};\n  return 0;\n}\n</code></pre>\n<p><code>gdb</code> reveals in both cases that <code>a</code> is ultimately optimized out, but we're worried about <code>foo()</code>. The dumps show us that GCC reordered the accesses so that <code>foo()</code> is not even necessary and subsequently all of the code in <code>main()</code> is optimized out. Is this really true? Let's see the assembly output for <code>-O1</code>:</p>\n<pre><code>foo():\n        mov     eax, 12\n        ret\nmain:\n        call    foo()\n        mov     eax, 0\n        ret\n</code></pre>\n<p>This essentially confirms what I said above. Everything is optimized out: the only difference is whether or not the call to <code>foo()</code> is as well.</p>\n", "LastActivityDate": "2016-05-07T06:48:39.593", "CommentCount": "1", "CreationDate": "2016-05-07T06:48:39.593", "ParentId": "37083614", "Score": "0", "OwnerUserId": "6292850"}, "bq_ids": {"n4140": {"so_37083614_37085442_5": {"length": 4, "quality": 0.8, "section_id": 5804}, "so_37083614_37085442_3": {"length": 15, "quality": 0.5357142857142857, "section_id": 5797}}, "n3337": {"so_37083614_37085442_5": {"length": 4, "quality": 0.8, "section_id": 5577}, "so_37083614_37085442_3": {"length": 15, "quality": 0.5357142857142857, "section_id": 5570}}, "n4659": {"so_37083614_37085442_5": {"length": 4, "quality": 0.8, "section_id": 7262}, "so_37083614_37085442_3": {"length": 15, "quality": 0.5357142857142857, "section_id": 7256}}}, "37084941": {"Id": "37084941", "PostTypeId": "2", "Body": "<p>Visual C++ 2015 does not optimize away the assignments:</p>\n<pre><code>A a;\nmov         dword ptr [rsp+8],0Ch  &lt;-- write 1\na.x = 13;\nmov         dword ptr [a],0Dh      &lt;-- write2\na = foo();\nmov         dword ptr [a],0Ch      &lt;-- write3\nmov         eax,dword ptr [rsp+8]  \nmov         dword ptr [rsp+8],eax  \nmov         eax,dword ptr [rsp+8]  \nmov         dword ptr [rsp+8],eax  \n}\nxor         eax,eax  \nret  \n</code></pre>\n<p>The same happens both with  /O2 (Maximize speed) and /Ox (Full optimization).</p>\n<p>The volatile writes are kept also by gcc 3.4.4 using both -O2 and -O3</p>\n<pre><code>_main:\npushl   %ebp\nmovl    $16, %eax\nmovl    %esp, %ebp\nsubl    $8, %esp\nandl    $-16, %esp\ncall    __alloca\ncall    ___main\nmovl    $12, -4(%ebp)  &lt;-- write1\nxorl    %eax, %eax\nmovl    $13, -4(%ebp)  &lt;-- write2\nmovl    $12, -8(%ebp)  &lt;-- write3\nleave\nret\n</code></pre>\n<p>Using both of these compilers, if I remove the volatile keyword, main() becomes essentially empty.</p>\n<p>I'd say you have a case where the compiler over-agressively (and incorrectly IMHO) decides that since 'a' is not used, operations on it arent' necessary and overlooks the volatile member. Making 'a' itself volatile could get you what you want, but as I don't have a compiler that reproduces this, I can't say for sure.</p>\n<p>Last (while this is admittedly Microsoft specific), <a href=\"https://msdn.microsoft.com/en-us/library/12a04hfd.aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/12a04hfd.aspx</a> says:</p>\n<blockquote>\n<p id=\"so_37083614_37084941_0\">If a struct member is marked as volatile, then volatile is propagated to the whole structure.</p>\n</blockquote>\n<p>Which also points towards the behavior you are seeing being a compiler problem.</p>\n<p>Last, if you make 'a' a global variable, it is somewhat understandable that the compiler is less eager to deem it unused and drop it. Global variables are extern by default, so it is not possible to say that a global 'a' is unused just by looking at the main function. Some other compilation unit (.cpp file) might be using it.</p>\n", "LastEditorUserId": "5820440", "LastActivityDate": "2016-05-07T16:42:20.103", "Score": "2", "CreationDate": "2016-05-07T05:40:59.513", "ParentId": "37083614", "CommentCount": "2", "OwnerUserId": "5820440", "LastEditDate": "2016-05-07T16:42:20.103"}, "37083614": {"ViewCount": "188", "Body": "<p>Consider this code:</p>\n<pre><code>struct A{ \n  volatile int x;\n  A() : x(12){\n  }\n};\n\nA foo(){\n  A ret;\n  //Do stuff\n  return ret;\n}\n\nint main()\n{\n  A a;\n  a.x = 13;\n  a = foo();\n}\n</code></pre>\n<p>Using <code>g++ -std=c++14 -pedantic -O3</code> I get this assembly:</p>\n<pre><code>foo():\n        movl    $12, %eax\n        ret\nmain:\n        xorl    %eax, %eax\n        ret\n</code></pre>\n<p>According to my estimation the variable <code>x</code> should be written to at least three times (possibly four), yet it not even written <strong>once</strong> (the function foo isn't even called!)</p>\n<p>Even worse when you add the <code>inline</code> keyword to <code>foo</code> this is the result:</p>\n<pre><code>main:\n        xorl    %eax, %eax\n        ret\n</code></pre>\n<p>I thought that volatile means that every single read or write <strong>must</strong> happen even if the compiler can not see the point of the read/write.</p>\n<p>What is going on here?</p>\n<p><strong>Update:</strong></p>\n<p>Putting the declaration of <code>A a;</code> outside main like this:</p>\n<pre><code>A a;\nint main()\n{  \n  a.x = 13;\n  a = foo();\n}\n</code></pre>\n<p>Generates this code:</p>\n<pre><code>foo():\n        movl    $12, %eax\n        ret\nmain:\n        movl    $13, a(%rip)\n        xorl    %eax, %eax\n        movl    $12, a(%rip)\n        ret\n        movl    $12, a(%rip)\n        ret\na:\n        .zero   4\n</code></pre>\n<p>Which is closer to what you would expect....I am even more confused then ever</p>\n", "AcceptedAnswerId": "37084941", "Title": "Volatile not working as expected", "CreationDate": "2016-05-07T01:38:52.007", "Id": "37083614", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-07T05:57:09.380", "LastEditorUserId": "149341", "LastActivityDate": "2016-05-07T16:42:20.103", "Score": "9", "OwnerUserId": "6149078", "Tags": "<c++><g++><language-lawyer><volatile>", "AnswerCount": "2"}});