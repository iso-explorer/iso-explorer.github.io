post_cb({"30177732": {"ParentId": "30177621", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2015-05-11T21:10:40.897", "Score": "3", "LastEditorUserId": "298661", "LastEditDate": "2015-05-11T21:12:42.237", "Id": "30177732", "OwnerUserId": "298661", "Body": "<blockquote>\n<p id=\"so_30177621_30177732_0\">As always with variables which have been std::move'd, it is unsafe to\n  use them afterwards</p>\n</blockquote>\n<p>That's not true at all. It's perfectly safe to use things that have been moved from. There are lots of places where they <em>must</em> be used after being moved from by Standard, for example <code>std::swap</code> or even just destructing locals.</p>\n<p>What you <em>can't</em> do is assume that they have any <em>specific</em> valid state. But they must have <em>some</em> valid state. If you are authoring <code>A</code> and it does not abide by these rules, then <code>A</code> is broken and should be fixed, rather than band-aiding over the problem.</p>\n", "LastActivityDate": "2015-05-11T21:12:42.237"}, "30177621": {"CommentCount": "8", "ViewCount": "123", "CreationDate": "2015-05-11T21:03:30.240", "LastActivityDate": "2015-05-11T21:46:46.197", "Title": "C++ disallow cast to rvalue reference", "AcceptedAnswerId": "30177658", "PostTypeId": "1", "Id": "30177621", "Score": "0", "Body": "<p>As always with variables which have been <code>std::move</code>'d, it is unsafe to use them afterwards.</p>\n<p>As I have written a code where I encourage the user to apply <code>std::move</code> on various occasions, I want to avoid that it is used in a wrong way, at least in a few crucial places (so to say selectively \"protect against Machiavelli\").</p>\n<p>Therefore, is the following overload of <code>std::move</code> a valid way to go? Or would you discourage from using it?</p>\n<pre><code>struct A\n{\n     void do_something() const { /* ... whatever ... */ }\n};\n\nnamespace std\n{\n    auto move(A&amp; t) noexcept = delete;\n    auto move(A const&amp; t) noexcept = delete;\n    //possibly the same for volatile qualifier\n\n    //possibly also specialize static_cast&lt;A const&amp;&gt;, static_cast&lt;A&amp;&gt;, etc.\n}\n\n// possibly set up another function \"my_private_move\"\n// which I can use exclusively where it is appropriate.\n\nint main()\n{\n    A a;\n    // auto a_moved = std::move(a);      //disallow move of lvalue ref\n    a.do_something();                    //otherwise this could be problematic\n\n    A(A{});                             //direct initialization via move constructor is ok\n    auto x2 = A{};                      \n}\n</code></pre>\n", "Tags": "<c++><c++11><move>", "OwnerUserId": "2412846", "AnswerCount": "3"}, "30178190": {"ParentId": "30177621", "CommentCount": "1", "CreationDate": "2015-05-11T21:46:46.197", "OwnerUserId": "4754242", "PostTypeId": "2", "Id": "30178190", "Score": "0", "Body": "<blockquote>\n<p id=\"so_30177621_30178190_0\">A a;<br/>\n  auto a_moved = std::move(a);   //disallow move of lvalue ref<br/>\n  a.do_something();                    //otherwise this could be problematic<br/></p>\n</blockquote>\n<p>The point of std::move() is to take an lvalue and return an rvalue so your move constructor or move assignment can be called. So either make the move constructor and move assignment deleted or your users just have to know what are they doing. Here's some information on std::move() <a href=\"http://en.cppreference.com/w/cpp/utility/move\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/utility/move</a></p>\n", "LastActivityDate": "2015-05-11T21:46:46.197"}, "bq_ids": {"n4140": {"so_30177621_30177658_0": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_30177621_30177658_0": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_30177621_30177658_0": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}}}, "30177658": {"ParentId": "30177621", "CommentCount": "9", "CreationDate": "2015-05-11T21:06:27.840", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "30177658", "Score": "7", "Body": "<p>Your code exhibits undefined behavior, as per [namespace.std]:</p>\n<blockquote>\n<p id=\"so_30177621_30177658_0\">The behavior of a C++ program is undefined if it <strong>adds declarations or definitions to namespace <code>std</code></strong> or to a\n  namespace within namespace <code>std</code> unless otherwise specified. A program may add a template specialization\n  for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type\n  and the specialization meets the standard library requirements for the original template and is not explicitly\n  prohibited.</p>\n</blockquote>\n<p>Your use case does not fall under the \"otherwise specified\" umbrella. Besides being undefined, it's of questionable value... you're disallowing this:</p>\n<pre><code>A a; \nf(std::move(a)); \n// just don't use a here\n</code></pre>\n<p>despite that being potentially a performance improvement over <code>f(a)</code>. But the user can still write the cast explicitly to accomplish the same result:</p>\n<pre><code>f(static_cast&lt;A&amp;&amp;&gt;(a)); // slightly more verbose move\n</code></pre>\n", "LastActivityDate": "2015-05-11T21:06:27.840"}});