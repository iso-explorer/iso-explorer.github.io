post_cb({"28128270": {"ParentId": "28128174", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>That's because you're trying to perform aggregate initialization on <code>Boo</code>. See \u00a78.5.4/3:</p>\n<blockquote>\n<p id=\"so_28128174_28128270_0\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<p id=\"so_28128174_28128270_1\">\u2014 If <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).</p>\n</blockquote>\n<p>You're intending to copy-construct your <code>Boo</code>... but really you're doing aggregate initialization, which leads to trying to construct <code>int z</code> from a <code>Boo</code>, hence the error</p>\n<blockquote>\n<p id=\"so_28128174_28128270_2\">error: no viable conversion from 'Boo' to 'int'</p>\n</blockquote>\n<p>Note that you could reproduce your problem in much less code and without any templates:</p>\n<pre><code>Boo b;\nBoo b2{b}; // error\n</code></pre>\n<p>The fix is simple. Just don't use list-initialization:</p>\n<pre><code>template &lt;typename T&gt;\nstruct Foo { \n    Foo (int n, int p, string s, T t = {})\n    : m_n {n}, m_p {p}, m_s {s}, m_t(t)\n    //                           ^^^^^^\n{};\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-01-24T17:40:59.017", "Id": "28128270", "Score": "6", "CreationDate": "2015-01-24T17:34:06.850", "LastActivityDate": "2015-01-24T17:40:59.017"}, "28128174": {"CommentCount": "1", "ViewCount": "3611", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-01-24T17:24:02.987", "LastActivityDate": "2015-02-07T13:58:02.873", "Title": "Cannot convert Type in initialization", "AcceptedAnswerId": "28128270", "LastEditDate": "2015-02-07T13:58:02.873", "Id": "28128174", "Score": "4", "Body": "<p>I think I miss something and I don't know what exactly. Let's take a look at code snippet. </p>\n<pre><code>template &lt;typename T&gt;\nstruct Foo { \n    Foo (int n, int p, string s, T t = {})\n    : m_n {n}, m_p {p}, m_s {s}, m_t {t}\n    {}\n\n    const int m_n;\n    const int m_p;\n    const string m_s;\n    T m_t;\n};\n</code></pre>\n<p>And usage looks like this:</p>\n<pre><code>Foo&lt;int&gt; f_int1 {1, 2, \"A\", 155};\nFoo&lt;int&gt; f_int2 {1, 2, \"A\"};\n</code></pre>\n<p>Everything is like intended. But when I want to have a user defined type as a T parameter of Foo, some errors occur. Consider:</p>\n<pre><code>struct Boo {\n    int z;\n    int l;\n};\n</code></pre>\n<p>And usage:</p>\n<pre><code>Foo&lt;Boo&gt; f_boo1 {1, 2, \"A\"};\nFoo&lt;Boo&gt; f_boo2 {1, 2, \"A\", {1, 2}};\n</code></pre>\n<p>These both instructions give (gcc 4.8.1):</p>\n<pre><code>cannot convert \u2018Boo\u2019 to \u2018int\u2019 in initialization\n</code></pre>\n<p>I can create Boo objects like this:</p>\n<pre><code>Boo boo1 {};\nBoo boo2 {1, 2};\n</code></pre>\n<p>So, could you tell me where the problem is?</p>\n<p>Possible solution:</p>\n<pre><code>struct Boo {\n    Boo () : z {}, l {} {}\n    Boo (int p1, int p2) : z {p1}, l {p2} {}\n\n    int z;\n    int l;\n};\n</code></pre>\n<p>And both below instructions work as intended:</p>\n<pre><code>Foo&lt;Boo&gt; f_boo1 {1, 2, \"A\"};\nFoo&lt;Boo&gt; f_boo2 {1, 2, \"A\", {1, 2}};\n</code></pre>\n<p>For me, that's ok, I don't see any reason why not to add two constructors to the class, but what if the type is not mine? Should I write simple wrapper with the constructors?</p>\n<p>Thanks,\nArtur</p>\n", "Tags": "<c++><templates><c++11><list-initialization>", "OwnerUserId": "3671410", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28128174_28128270_1": {"section_id": 3325, "quality": 0.8, "length": 4}, "so_28128174_28128270_0": {"section_id": 3325, "quality": 1.0, "length": 6}}, "n3337": {"so_28128174_28128270_1": {"section_id": 3195, "quality": 0.8, "length": 4}, "so_28128174_28128270_0": {"section_id": 3195, "quality": 1.0, "length": 6}}, "n4659": {"so_28128174_28128270_1": {"section_id": 4091, "quality": 0.8, "length": 4}, "so_28128174_28128270_0": {"section_id": 4091, "quality": 1.0, "length": 6}}}});