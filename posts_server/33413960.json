post_cb({"33413960": {"ViewCount": "720", "Body": "<p>I recently started to learn modern template metaprogramming and I wrote myself an index_of function for types.</p>\n<pre><code>template&lt;std::size_t Index, class C, class A&gt; struct mp_index_of_impl{};\ntemplate&lt;std::size_t Index, class C,template&lt;class...&gt; class A,class ...Ts&gt;\nstruct mp_index_of_impl&lt;Index,C,A&lt;C,Ts...&gt;&gt;{\n    using type = std::integral_constant&lt;std::size_t,Index&gt;;\n};\ntemplate&lt;std::size_t Index, class C,template&lt;class...&gt; class A,class ...Ts,class T1&gt;\nstruct mp_index_of_impl&lt;Index,C,A&lt;T1,Ts...&gt;&gt;{\n    using type = typename mp_index_of_impl&lt;Index + 1,C,A&lt;Ts...&gt;&gt;::type;\n};\ntemplate&lt;std::size_t Index, class C,template&lt;class...&gt; class A&gt; struct mp_index_of_impl&lt;Index,C,A&lt;&gt;&gt;{\n    //static_assert(false,\"Does not contain type\");\n    using type = std::integral_constant&lt;std::size_t,0&gt;;\n};\n</code></pre>\n<p>The problem is my last specialization</p>\n<pre><code>template&lt;std::size_t Index, class C,template&lt;class...&gt; class A&gt; \nstruct mp_index_of_impl&lt;Index,C,A&lt;&gt;&gt;{\n      //throw a compile error here\n};\n</code></pre>\n<p>I tried to use static_assert like  this</p>\n<pre><code>template&lt;std::size_t Index, class C,template&lt;class...&gt; class A&gt; struct mp_index_of_impl&lt;Index,C,A&lt;&gt;&gt;{\n    static_assert(false,\"Does not contain type\");\n};\n</code></pre>\n<p>But this will throw a compile error every time, even if it is not matched.</p>\n<p>I want to throw a compile error with a custom error message if this template specialization is matched. How would I do this?</p>\n", "AcceptedAnswerId": "33414109", "Title": "Force a compile time error in a template specialization", "CreationDate": "2015-10-29T12:14:56.713", "Id": "33413960", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-10-29T12:35:28.470", "LastEditorUserId": "2069064", "LastActivityDate": "2015-10-29T12:35:28.470", "Score": "4", "OwnerUserId": "944430", "Tags": "<c++><templates><c++11><template-meta-programming>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33413960_33414336_0": {"length": 17, "quality": 0.5862068965517241, "section_id": 175}}, "n3337": {"so_33413960_33414336_0": {"length": 18, "quality": 0.6206896551724138, "section_id": 169}}, "n4659": {"so_33413960_33414336_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 180}}}, "33414336": {"Id": "33414336", "PostTypeId": "2", "Body": "<p>To get a truly well-formed solution here is a little annoying. You're running into [temp.res]/8:</p>\n<blockquote>\n<p id=\"so_33413960_33414336_0\">If no valid specialization can\n  be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic\n  required... If a hypothetical instantiation of a template immediately\n  following its definition would be ill-formed due to a construct that does not depend on a template parameter,\n  the program is ill-formed; no diagnostic is required.</p>\n</blockquote>\n<p>So what we need to do is avoid anything that could do <code>static_assert(false, ...)</code>. In this case, we have a partial opening. We could specialize on the case where we only have one type left and assert that this is what we're looking for:</p>\n<pre><code>template&lt;std::size_t Index, class C,template&lt;class...&gt; class A, class Last&gt;\nstruct mp_index_of_impl&lt;Index,C,A&lt;Last&gt;&gt;{\n    static_assert(std::is_same&lt;C, Last&gt;::value,\"Does not contain type\");\n    using type = std::integral_constant&lt;std::size_t, Index&gt;;\n};\n</code></pre>\n<p>This would not handle the case of empty lists, but for that at top level you can add another <code>static_assert</code> for non-emptiness:</p>\n<pre><code>template&lt;std::size_t Index, class C,template&lt;class...&gt; class A&gt;\nstruct mp_index_of_impl&lt;Index,C,A&lt;&gt;&gt;{ };\n\ntemplate &lt;typename T&gt; is_empty : std::false_type { };\ntemplate &lt;template &lt;class...&gt; class A&gt; is_empty&lt;A&lt;&gt;&gt; : std::true_type { };\n\ntemplate &lt;class C, class X&gt;\nstruct mp_index_of\n: mp_index_of_impl&lt;0, C, X&gt;\n{\n    static_assert(!is_empty&lt;X&gt;::value, \"Does not contain type\");\n};\n</code></pre>\n<p>Although, in practice, <a href=\"https://stackoverflow.com/a/33414109/2069064\">TartanLlama's solution</a> will probably get you by every compiler, and I would probably just use it. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-29T12:31:35.557", "Score": "2", "CreationDate": "2015-10-29T12:31:35.557", "ParentId": "33413960", "CommentCount": "0", "LastEditDate": "2017-05-23T10:29:57.447", "OwnerUserId": "2069064"}, "33414109": {"Id": "33414109", "PostTypeId": "2", "Body": "<p>If you put a <code>static_assert(false,...)</code> in a template specialization then it is always impossible to generate valid code from it. This is <em>ill-formed, no diagnostic required</em>.</p>\n<p>A workaround to this is to make your <code>static_assert</code> depend on the template parameter:</p>\n<pre><code>template&lt;typename T&gt;\nstruct assert_false : std::false_type\n{ };\n\ntemplate &lt;typename T&gt;\ninline T getValue(AnObject&amp;)\n{\n    static_assert( assert_false&lt;T&gt;::value , \"Does not contain type\");\n}\n</code></pre>\n", "LastActivityDate": "2015-10-29T12:20:57.663", "Score": "8", "CreationDate": "2015-10-29T12:20:57.663", "ParentId": "33413960", "CommentCount": "6", "OwnerUserId": "496161"}});