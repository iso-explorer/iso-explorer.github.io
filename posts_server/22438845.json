post_cb({"22438845": {"ViewCount": "112", "Body": "<p>I am not sure if my question is correct, but I have the following example, where the main thread creates two additional threads.\nSince I am not using join command at the end of the main, it will continue execution and in the same time, the two created threads will work in parallel. But since the main is terminated before they finish their execution, I am getting the following output:</p>\n<p><strong>terminate called without an active exception</strong></p>\n<p><strong>Aborted (core dumped)</strong></p>\n<p>Here's the code:</p>\n<pre><code>#include &lt;iostream&gt;       // std::cout\n#include &lt;thread&gt;         // std::thread\n#include &lt;chrono&gt;\n\nvoid foo()\n{\n    std::chrono::milliseconds dura( 2000 );\n    std::this_thread::sleep_for( dura );\n    std::cout &lt;&lt; \"Waited for 2Sec\\n\";\n}\n\nvoid bar(int x)\n{\n    std::chrono::milliseconds dura( 4000 );\n    std::this_thread::sleep_for( dura );\n    std::cout &lt;&lt; \"Waited for 4Sec\\n\";\n}\n\nint main()\n{\n  std::thread first (foo);\n  std::thread second (bar,0);\n\n  return 0;\n}\n</code></pre>\n<p>So my question is how to keep these two threads working even if the main thread terminated?</p>\n<p>I am asking this because in my main program, I have an event handler ,and for each event I create a corresponding thread. But the main problem when the handler creates a new thread, the handler will continue execution. Until it is destroyed which will cause also the newly created thread to be destroyed. So my question is how to keep the thread alive in this case?</p>\n<p>Also if I use a join it will convert back to serialization.</p>\n<pre><code> void ho_commit_indication_handler(message &amp;msg, const boost::system::error_code &amp;ec)\n {\n     .....\n }\n\n void event_handler(message &amp;msg, const boost::system::error_code &amp;ec)\n{\n   if (ec)\n   {\n    log_(0, __FUNCTION__, \" error: \", ec.message());\n    return;\n   }\n\nswitch (msg.mid())\n{\n    case n2n_ho_commit:\n    {\n        boost::thread thrd(&amp;ho_commit_indication_handler, boost::ref(msg), boost::ref(ec));\n    }\n    break\n}\n};\n</code></pre>\n<p>Thanks a lot.</p>\n", "AcceptedAnswerId": "22438938", "Title": "Keeping threads alive even if the main thead has terminated", "CreationDate": "2014-03-16T15:31:12.123", "Id": "22438845", "CommentCount": "0", "LastEditDate": "2014-03-16T15:44:51.483", "PostTypeId": "1", "LastEditorUserId": "2399465", "LastActivityDate": "2014-03-16T15:50:48.937", "Score": "0", "OwnerUserId": "2399465", "Tags": "<multithreading><c++11>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22438845_22438938_3": {"length": 12, "quality": 1.0, "section_id": 3382}, "so_22438845_22438938_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 3382}}, "n3337": {"so_22438845_22438938_3": {"length": 12, "quality": 1.0, "section_id": 3251}, "so_22438845_22438938_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 3251}}, "n4659": {"so_22438845_22438938_3": {"length": 12, "quality": 1.0, "section_id": 4142}, "so_22438845_22438938_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 4142}}}, "22438938": {"Id": "22438938", "PostTypeId": "2", "Body": "<p>Keeping the threads alive is a bad idea, because it causes a call to <code>std::terminate</code>. You should definitively <code>join</code> the threads:</p>\n<pre><code>int main()\n{\n  std::thread first (foo);\n  std::thread second (bar, 0);\n  first.join();\n  second.join();\n}\n</code></pre>\n<p>An alternative is to <code>detach</code> the threads. However you still need to assert that the main thread lives longer (by e.g. using a mutex / condition_variable).</p>\n<p>This excerpt from the C++11 standard is relevant here:</p>\n<blockquote>\n<p id=\"so_22438845_22438938_0\"><strong>15.5.1</strong> The <code>std::terminate()</code> function [except.terminate]</p>\n<p id=\"so_22438845_22438938_1\"><em>1</em> In some situations exception handling must be abandoned for less subtle error\n  handling techniques. [ Note: These situations are:</p>\n<p id=\"so_22438845_22438938_2\">[...]</p>\n<p id=\"so_22438845_22438938_3\">-- when the destructor or the copy assignment operator is invoked on an\n  object of type <code>std::thread</code> that refers to a joinable thread</p>\n</blockquote>\n<p>Hence, you have to call either <code>join</code> or <code>detach</code> on threads <em>before</em> scope exit.</p>\n<hr>\n<p>Concerning your edit: You have to store the threads in a list (or similar) and wait for every one of them before <code>main</code> is done. A better idea would be to use a thread pool (because this limits the total number of threads created).</p>\n</hr>", "LastEditorUserId": "985296", "LastActivityDate": "2014-03-16T15:50:48.937", "Score": "0", "CreationDate": "2014-03-16T15:38:23.903", "ParentId": "22438845", "CommentCount": "9", "LastEditDate": "2014-03-16T15:50:48.937", "OwnerUserId": "985296"}});