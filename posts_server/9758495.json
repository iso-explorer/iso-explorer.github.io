post_cb({"bq_ids": {"n4140": {"so_9758495_9758495_0": {"length": 71, "quality": 0.8658536585365854, "section_id": 6809}}, "n3337": {"so_9758495_9758495_0": {"length": 71, "quality": 0.8658536585365854, "section_id": 6564}}, "n4659": {"so_9758495_9758495_0": {"length": 66, "quality": 0.8048780487804879, "section_id": 8300}}}, "9758765": {"Id": "9758765", "PostTypeId": "2", "Body": "<p>The rationale for <code>std::quick_exit</code> is discussed in <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1327.htm\" rel=\"noreferrer\">N1327</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2440.htm\" rel=\"noreferrer\">N2440</a>. The key differences between <code>quick_exit</code>, <code>_Exit</code>, and <code>exit</code> concerns the handling of static destructors and flushing critical information to stable storage:</p>\n<ul>\n<li><code>std::_Exit</code>: doesn't execute static destructors or flush critical IO.</li>\n<li><code>std::exit</code>: executes static destructors and flushes critical IO.</li>\n<li><code>std::quick_exit</code>: doesn't execute static destructors, but does flush critical IO.</li>\n</ul>\n<p>(As mentioned, <code>std::abort</code> just sends <code>SIGABRT</code>.)</p>\n", "LastActivityDate": "2012-03-18T13:37:44.073", "CommentCount": "2", "CreationDate": "2012-03-18T13:37:44.073", "ParentId": "9758495", "Score": "18", "OwnerUserId": "596219"}, "9759272": {"Id": "9759272", "PostTypeId": "2", "Body": "<p>There's a good write-up <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2440.htm\" rel=\"noreferrer\">available here</a>, I'll just summarize it.  This feature was added to specifically deal with the difficulty of ending a program cleanly when you use threads.  By nature, the exit is started by a highly asynchronous event, the user closing the user interface, the admin shutting down the machine, etcetera.  This happens without regard to the state of the threads the program started, they are almost always in a highly unpredictable state.</p>\n<p>In an ideal world, the program's main() function asks the threads to exit, typically by signaling an event, waits for the threads to end and then exits main() for a clean shutdown through exit().  That ideal is however <em>very</em> hard to achieve.  A thread could be buried deep inside a system call, say, waiting for some I/O to complete.  Or it is blocking on a synchronization object that needs to be signaled by another thread in the right order.  The outcome is rarely pleasant, real programs often deadlock on exit.  Or crash when the shutdown order is unexpected.</p>\n<p>There's a simple and very tempting workaround for this problem: call _exit() instead.  Kaboom, program ended, the operating system brooms up the shrapnel.  But clearly without any cleanup at all, very messy sometimes with artifacts like a half-written file or an incomplete dbase transaction.</p>\n<p>std::quick_exit() offers the alternative.  Similar to _exit() but with still the option to execute some code, whatever was registered with at_quick_exit.</p>\n", "LastEditorUserId": "17034", "LastActivityDate": "2016-03-04T13:23:45.290", "Score": "32", "CreationDate": "2012-03-18T14:49:58.760", "ParentId": "9758495", "CommentCount": "1", "OwnerUserId": "17034", "LastEditDate": "2016-03-04T13:23:45.290"}, "9758495": {"ViewCount": "4618", "Body": "<p>C++11 introduces a new way of finishing program execution\u2014<code>std::quick_exit</code>.</p>\n<p>Quoting the N3242 18.5 (p. 461):</p>\n<blockquote>\n<pre><code>[[noreturn]] void quick_exit(int status) noexcept;\n</code></pre>\n<p id=\"so_9758495_9758495_0\">Effects: Functions registered by calls to <code>at_quick_exit</code> are called\n  in the reverse order of their registration, except that a function\n  shall be called after any previously registered functions that had\n  already been called at the time it was registered. Objects shall not\n  be destroyed as a result of calling <code>quick_exit</code>. If control leaves a\n  registered function called by <code>quick_exit</code> because the function does not\n  provide a handler for a thrown exception, <code>terminate()</code> shall be called.\n  [ Note: <code>at_quick_exit</code> may call a registered function from a different\n  thread than the one that registered it, so registered functions should\n  not rely on the identity of objects with thread storage duration. \u2014\n  end note ] After calling registered functions, <code>quick_exit</code> shall call\n  <code>_Exit(status)</code>. [ Note: The standard file buffers are not flushed. See: ISO C 7.20.4.4. \u2014 end note ]</p>\n</blockquote>\n<p>As the definition of <code>std::abort(void)</code> and <code>std::_Exit(int status)</code> differ only in ability to pass the status to the parent process, it raises my question.</p>\n<p>Does it mean that the only difference in semantics between <code>std::quick_exit</code> and <code>std::abort</code> are that <code>std::quick_exit</code> calls functions registered using <code>std::at_quick_exit</code> and allows to set the returned status?</p>\n<p>What was the rationale for introducing this function?</p>\n", "AcceptedAnswerId": "9759272", "Title": "What is the difference between std::quick_exit and std::abort and why was std::quick_exit needed?", "CreationDate": "2012-03-18T13:00:03.797", "Id": "9758495", "CommentCount": "0", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2012-03-18T16:19:25.223", "LastEditorUserId": "246886", "LastActivityDate": "2016-03-04T13:23:45.290", "Score": "33", "OwnerUserId": "13767", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "3"}, "9758609": {"Id": "9758609", "PostTypeId": "2", "Body": "<p><code>std::abort</code> will terminate your application without calling any functions registered using \"at_exit/at_quick_exit\". On the other hand, <code>std::quick_exit</code> will, as you pointed out, call the functions registered using <code>std::at_quick_exit</code>.</p>\n<p><code>std::abort</code> typically <em>aborts</em> your application, this should be called when some abnormal situation happens and your application has to be closed without doing any cleanups. From the <code>std::abort</code> documentation:</p>\n<blockquote>\n<p id=\"so_9758495_9758609_0\">Causes abnormal program termination unless SIGABRT is being caught by\n  a signal handler passed to signal and the handler does not return.</p>\n</blockquote>\n<p>When you want to perform some cleanups, <code>std::quick_exit</code> will be more appropiate. This last function also lets you stop your application gracefully, since it ends up calling <code>std::_Exit</code> instead of signaling a signal like <code>std::abort</code>(which signals SIGABRT, making the application stop abnormally). </p>\n<p><code>std::exit</code> allows you to exit your application gracefully, while still cleaning up automatic, thread local and static variables. <code>std::quick_exit</code> does not. That's why there is a \"quick_\" in its name, it's faster since it skips the clean up phase.</p>\n<p>Therefore, there is an actual semantic difference between both functions. One stops the application abnormally, and the other performs a gracefull exit, allowing you to do some clean ups.</p>\n", "LastEditorUserId": "525217", "LastActivityDate": "2012-03-18T13:31:10.093", "Score": "2", "CreationDate": "2012-03-18T13:14:08.440", "ParentId": "9758495", "CommentCount": "4", "OwnerUserId": "525217", "LastEditDate": "2012-03-18T13:31:10.093"}});