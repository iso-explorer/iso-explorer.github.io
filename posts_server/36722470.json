post_cb({"36725226": {"ParentId": "36722470", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>There are two unresolved issues regarding <code>friend</code> function templates defined in class templates: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1545\" rel=\"nofollow\">1545</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2174\" rel=\"nofollow\">2174</a>. The former questions the extent to which it's valid at all and the latter is about odr violations that may arise based on the actual instantiations of those function templates. I am unsure which compiler is right (having previously believed that both were wrong), but it may simply be under- or poorly specified in the standard what the correct behavior is in this situation. </p>\n<p>The code <em>should</em> ideally compile (pending issue resolution):</p>\n<pre><code>template&lt;typename ...Args&gt;\nclass obj {\n bool p = false;\n\n template&lt;typename T, typename... Args2&gt;\n friend T get(const obj&lt;Args2...&gt; &amp;o) { return o.p; }\n};\n\ntemplate&lt;typename T, typename... Args&gt;\nT get(const obj&lt;Args...&gt; &amp;o);\n</code></pre>\n<p>The <code>friend</code> declaration first declares <code>get</code>, so this creates a new member of the innermost enclosing namespace: <code>::get</code>. The external declaration just redeclares the same function, so there really is just the one <code>::get</code>. From [temp.over.link]:</p>\n<blockquote>\n<p id=\"so_36722470_36725226_0\">Two expressions involving template parameters are considered equivalent if two function definitions containing\n  the expressions would satisfy the one-definition rule (3.2), except that the tokens used to name the\n  template parameters may differ as long as a token used to name a template parameter in one expression is\n  replaced by another token that names the same template parameter in the other expression. For determining\n  whether two dependent names (14.6.2) are equivalent, only the name itself is considered, not the result of name lookup in the context of the template.</p>\n</blockquote>\n<p>Using different template parameter names (<code>Args...</code> vs <code>Args2...</code>) is fine - this second declaration of the function template <code>::get</code> is valid and allows for lookup to find it. </p>\n<p>This brings us to:</p>\n<pre><code>bool test(const obj&lt;int, float, double&gt; &amp;a) {\n#ifdef UNQUAL\n    return get&lt;int&gt;(a);     // unqualified\n#else\n    return ::get&lt;int&gt;(a);   // qualified\n#endif\n}\n</code></pre>\n<p>Both of these <em>should</em> work - since we redeclared the function to be in namespace scope, we don't even have to worry about ADL. Both calls should find <code>::get&lt;int&gt;(obj&lt;int, float, double&gt; )</code>, which is a <code>friend</code>, and so the code should compile and link. gcc allows the unqualified call but not the qualified call, clang allows neither. </p>\n<p>We could sidestep both CWG issues entirely by simply <em>not</em> defining the function template inside the class:</p>\n<pre><code>template&lt;typename ...Args&gt;\nclass obj {\n bool p = false;\n\n template&lt;typename T, typename... Args2&gt;\n friend T get(const obj&lt;Args2...&gt; &amp;o);\n};\n\ntemplate&lt;typename T, typename... Args&gt;\nT get(const obj&lt;Args...&gt; &amp;o) { return o.p; }\n</code></pre>\n<p>With this formulation, both compiles allow <em>both</em> qualified and unqualified invocation of <code>get</code>. </p>\n<hr/>\n<p>If we rewrite the code such that <code>obj</code> is a class and not a class template, but all else being equal:</p>\n<pre><code>class obj {\n    bool p = false;\n\n    template &lt;class T&gt;\n    friend T get(const obj&amp; o) { return o.p; }\n};\n\ntemplate &lt;class T&gt; T get(const obj&amp; );\n\nbool test(const obj&amp; a) {\n#ifdef UNQUAL\n    return get&lt;int&gt;(a);\n#else\n    return ::get&lt;int&gt;(a);\n#endif\n}\n</code></pre>\n<p>Both compilers allow both invocations. But there is no difference that I'm aware of in the rules between <code>obj</code> being a normal class and a class template. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-04-20T18:17:12.940", "Id": "36725226", "Score": "5", "CreationDate": "2016-04-19T17:17:56.767", "LastActivityDate": "2016-04-20T18:17:12.940"}, "36722470": {"CommentCount": "8", "AcceptedAnswerId": "36725226", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2016-04-19T15:11:35.137", "LastActivityDate": "2016-04-20T19:15:31.343", "LastEditDate": "2016-04-20T13:49:01.260", "ViewCount": "216", "FavoriteCount": "2", "Title": "template object's template friend functions and namespaces", "Id": "36722470", "Score": "8", "Body": "<p>In the following C++ example code, GCC 6 and Clang 3.8 disagree on what the correct behaviour is:</p>\n<p>This contrived example \"works\" -- as in the <code>test()</code> function returns <code>o.p</code> in GCC. In clang, it calls the (undefined) function <code>get&lt;int, int, float, double&gt;</code>:</p>\n<pre><code>template&lt;typename ...Args&gt;\nclass obj {\n bool p = false;\n\n template&lt;typename T, typename... Args2&gt;\n friend T get(const obj&lt;Args2...&gt; &amp;o) { return o.p; }\n};\n\ntemplate&lt;typename T, typename... Args&gt;\nT get(const obj&lt;Args...&gt; &amp;o);\n\n\nbool test(const obj&lt;int, float, double&gt; &amp;a) {\n return get&lt;int&gt;(a);\n}\n</code></pre>\n<p>Putting the same code in a namespace causes GCC to do the same thing clang does.</p>\n<pre><code>namespace ns {\n\ntemplate&lt;typename ...Args&gt;\nclass obj {\n bool p = false;\n\n template&lt;typename T, typename... Args2&gt;\n friend T get(const obj&lt;Args2...&gt; &amp;o) { return o.p; }\n};\n\ntemplate&lt;typename T, typename... Args&gt;\nT get(const obj&lt;Args...&gt; &amp;o);\n\n}\n\nbool test(const ns::obj&lt;int, float, double&gt; &amp;a) {\n return ns::get&lt;int&gt;(a);\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/sWrXQO\">https://godbolt.org/g/sWrXQO</a> and <a href=\"https://godbolt.org/g/9tIXwe\">https://godbolt.org/g/9tIXwe</a></p>\n<p>Which compiler is \"correct\" and is there in general a way to <em>define</em> a friend member template function inline without having to declare it and then define it separately. That is, things like:</p>\n<pre><code>struct Foo {\n friend bool bar() { return true; } // declares *and* defines a free function bar\n template&lt;typename T&gt; T bar2() { return true; }  // doesn't work!\n};\n</code></pre>\n", "Tags": "<c++><templates><friend><argument-dependent-lookup>", "OwnerUserId": "390318", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36722470_36725226_0": {"section_id": 157, "quality": 0.9245283018867925, "length": 49}}, "n3337": {"so_36722470_36725226_0": {"section_id": 151, "quality": 0.6792452830188679, "length": 36}}, "n4659": {"so_36722470_36725226_0": {"section_id": 161, "quality": 0.9433962264150944, "length": 50}}}});