post_cb({"bq_ids": {"n4140": {"so_15328244_15328382_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3913}}, "n3337": {"so_15328244_15328382_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3773}}}, "15328244": {"ViewCount": "341", "Body": "<p>I understand that when objects are returned by-value from a function, their copy-constructors are called. If a class has a deleted copy-constructor, returning by value will fail.</p>\n<pre><code>struct X {\n    X(const X &amp;) = delete;\n};\n\nX f() {\n   return X{};\n}\n</code></pre>\n<blockquote>\n<p id=\"so_15328244_15328244_0\"><code>error: call to deleted constructor of 'X'</code></p>\n</blockquote>\n<p>C++11 gives us extended-initializers. And I read somewhere on a SO post that this</p>\n<pre><code>X f() {\n    return {};\n}\n</code></pre>\n<p>is the same as</p>\n<pre><code>X f() {\n    return X{};\n}\n</code></pre>\n<p>So why doesn't the below code give me an error? It passes and I even get to call the function in main:</p>\n<pre><code>struct D {\n   D(const D &amp;) = delete;\n};\n\nD f() { return {}; }\n\nint main()\n{\n   f();\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/4yc7Hy$2171\" rel=\"noreferrer\">Here is a demo.</a> No error is reported. I find that weird because I believe that the copy-constructor should be called. Can anyone explain why no error is given?</p>\n", "AcceptedAnswerId": "15328382", "Title": "Why is the copy-constructor not called when returning by-value a list-initialized object?", "CreationDate": "2013-03-10T22:06:50.937", "Id": "15328244", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-03-10T22:27:48.900", "Score": "7", "OwnerUserId": "1594090", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "15328382": {"Id": "15328382", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15328244_15328382_0\">And I read somewhere on a SO post that this [...] is the same as [...]</p>\n</blockquote>\n<p>They were wrong. They're <em>similar</em>, but not the same.</p>\n<p>By using the braced-init-list, you are able to initialize the return value <em>in-place</em>. If you create a temporary, then what you're doing is creating the temporary and then copying it into the return value. Any compiler worth its salt will elide it, but the copy constructor still must be accessible.</p>\n<p>But since the braced-init-list initializes the return value in-place, you don't need access to the copy constructor.</p>\n<p>From the standard, section 6.6.3, p2:</p>\n<blockquote>\n<p id=\"so_15328244_15328382_1\">A return statement with a braced-init-list initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>\n</blockquote>\n<p>Note that \"copy-list-initialization\" is not similar to \"copy-initialization\"; it doesn't do any copying and therefore it doesn't require an accessible copy constructor. The only difference between \"copy-list-initialization\" and \"direct-list-initialization\" is that the former will choke on <code>explicit</code> constructors.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2013-03-10T22:27:48.900", "CommentCount": "19", "CreationDate": "2013-03-10T22:20:14.010", "ParentId": "15328244", "Score": "12", "OwnerUserId": "734069", "LastEditDate": "2013-03-10T22:27:48.900"}});