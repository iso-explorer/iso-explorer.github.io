post_cb({"4275946": {"Id": "4275946", "PostTypeId": "2", "Body": "<p>You ask, how is it that</p>\n<pre><code>class C { C() = default; };\n</code></pre>\n<p>can be more efficient than</p>\n<pre><code>class C { C(){} };\n</code></pre>\n<p>Well, both constructors do nothing, so it's meaningless to talk about efficiency for that example.</p>\n<p>But more generally, in e.g. a copy constructor one can imagine that copying one POD item at a time will not be recognized as optimizable by simple optimizer, whereas with automatic generation it might just do a <code>memcpy</code>. Who knows. It's a Quality of Implementation issue, and I can easily imagine also the <em>opposite</em>.</p>\n<p>So, measure, if it matters.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2010-11-25T10:20:00.540", "CommentCount": "4", "CreationDate": "2010-11-25T10:20:00.540", "ParentId": "4275861", "Score": "7", "OwnerUserId": "464581"}, "4278729": {"Id": "4278729", "PostTypeId": "2", "Body": "<p>Take performance claims \"with a grain of salt\".</p>\n<p>I've heard a high-rated MIT professor make a claim like that for his favorite thing, and the only reason nobody asked him \"why\" was because he was a high-rated MIT professor.</p>\n<p>Such constructors and destructors might have other advantages, but claims about performance (outside of big-O) are seldom even meaningful except in highly contrived circumstances.</p>\n", "LastActivityDate": "2010-11-25T15:44:12.213", "CommentCount": "0", "CreationDate": "2010-11-25T15:44:12.213", "ParentId": "4275861", "Score": "1", "OwnerUserId": "23771"}, "4275944": {"Id": "4275944", "PostTypeId": "2", "Body": "<p>To be honest, I can't see it either.</p>\n<p>Among other things, I can see why one should use </p>\n<pre><code>class C { C() = default; };\n</code></pre>\n<p>that seems to me the same as</p>\n<pre><code>class C { };\n</code></pre>\n<p>Or, if other constructors are provided, as:</p>\n<pre><code>class C { \n    C() {}\n    // other constructors.\n};\n</code></pre>\n<p>I fail to see the <strong>real problem</strong> the author is writing about here.</p>\n", "LastActivityDate": "2010-11-25T10:19:49.197", "CommentCount": "4", "CreationDate": "2010-11-25T10:19:49.197", "ParentId": "4275861", "Score": "0", "OwnerUserId": "347137"}, "bq_ids": {"n4140": {"so_4275861_4417899_1": {"length": 4, "quality": 1.0, "section_id": 369}, "so_4275861_4417899_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 369}, "so_4275861_4417899_3": {"length": 4, "quality": 1.0, "section_id": 461}, "so_4275861_4417899_2": {"length": 5, "quality": 0.625, "section_id": 461}, "so_4275861_4417899_4": {"length": 4, "quality": 1.0, "section_id": 4706}, "so_4275861_4417899_5": {"length": 19, "quality": 0.7916666666666666, "section_id": 5850}}, "n3337": {"so_4275861_4417899_1": {"length": 4, "quality": 1.0, "section_id": 359}, "so_4275861_4417899_5": {"length": 20, "quality": 0.8333333333333334, "section_id": 5620}, "so_4275861_4417899_3": {"length": 4, "quality": 1.0, "section_id": 452}, "so_4275861_4417899_2": {"length": 5, "quality": 0.625, "section_id": 452}, "so_4275861_4417899_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 359}, "so_4275861_4417899_4": {"length": 4, "quality": 1.0, "section_id": 4515}}, "n4659": {"so_4275861_4417899_2": {"length": 5, "quality": 0.625, "section_id": 484}, "so_4275861_4417899_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 470}, "so_4275861_4417899_5": {"length": 17, "quality": 0.7083333333333334, "section_id": 7329}, "so_4275861_4417899_4": {"length": 4, "quality": 1.0, "section_id": 6103}}}, "4417899": {"Id": "4417899", "PostTypeId": "2", "Body": "<p>It makes no sense whatsoever to talk about \"manual definition of a special member function (even if it's trivial)\", because user-provided special member functions are, by definition, non-trivial.  This non-triviality comes into play when using type traits, and also POD-ness, and many optimizations are only possible with trivial or POD types.</p>\n<p>A better restatement of the same quote would be:</p>\n<p><em>The defaulted special member functions enable <strong>libraries</strong> to detect that calls to these functions may be omitted entirely.</em></p>\n<p>From section 12.1 <code>[class.ctor]</code></p>\n<blockquote>\n<p id=\"so_4275861_4417899_0\">A default constructor is <em>trivial</em> if it\n  is neither user-provided nor deleted\n  and if:</p>\n<ul>\n<li>its class has no virtual\n  functions (10.3) and no virtual base\n  classes (10.1), and </li>\n<li>no non-static\n  data member of its class has a\n  brace-or-equal-initializer, and </li>\n<li>all\n  the direct base classes of its class\n  have trivial default constructors, and</li>\n<li>for all the non-static data members\n  of its class that are of class type\n  (or array thereof), each such class\n  has a trivial default constructor.</li>\n</ul>\n<p id=\"so_4275861_4417899_1\">Otherwise, the default constructor is\n  <em>non-trivial</em>.</p>\n</blockquote>\n<p>From section 12.8 <code>[class.copy]</code>:</p>\n<blockquote>\n<p id=\"so_4275861_4417899_2\">A copy/move constructor for class X is\n  <em>trivial</em> if it is neither user-provided\n  nor deleted and if</p>\n<ul>\n<li>class X has no\n  virtual functions (10.3) and no\n  virtual base classes (10.1), and</li>\n<li>the constructor selected to copy/move\n  each direct base class subobject is\n  trivial, and </li>\n<li>for each non-static\n  data member of X that is of class type\n  (or array thereof), the constructor\n  selected to copy/move that member is\n  trivial;</li>\n</ul>\n<p id=\"so_4275861_4417899_3\">otherwise the copy/move\n  constructor is <em>non-trivial</em>.</p>\n</blockquote>\n<p>From section 9, <code>[class]</code>:</p>\n<blockquote>\n<p id=\"so_4275861_4417899_4\">A <em>trivially copyable</em> class is a class\n  that: </p>\n<ul>\n<li>has no non-trivial copy\n  constructors (12.8), </li>\n<li>has no\n  non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment\n  operators (13.5.3, 12.8), </li>\n<li>has no\n  non-trivial move assignment operators\n  (13.5.3, 12.8), and </li>\n<li>has a trivial\n  destructor (12.4).</li>\n</ul>\n<p id=\"so_4275861_4417899_5\">A <em>trivial class</em> is a class that has a\n  trivial default constructor (12.1) and\n  is trivially copyable. [ Note:  in\n  particular, a trivially copyable or\n  trivial class does not have virtual\n  functions or virtual base classes. \u2014\n  end note ]</p>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2010-12-11T17:21:06.850", "Score": "2", "CreationDate": "2010-12-11T17:15:32.073", "ParentId": "4275861", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2010-12-11T17:21:06.850"}, "4275861": {"ViewCount": "304", "Body": "<p>I read this <a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=514&amp;WT.rss_f=Guide&amp;WT.rss_a=C%20%200x%20Features%20That%20I%20Like,%20Part%20I%20&amp;WT.rss_ev=a\" rel=\"nofollow\">article</a> from D. Kalev this morning about the new c++11 feature \"defaulted and deleted functions\", and can't understand the part about performance, namely:</p>\n<blockquote>\n<p id=\"so_4275861_4275861_0\">the manual definition of a special member function (even if it's trivial) is usually less efficient than an implicitly-defined one. </p>\n</blockquote>\n<p>By googling to find an answer, I found another <a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=15\" rel=\"nofollow\">article</a> of the same author:</p>\n<blockquote>\n<p id=\"so_4275861_4275861_1\">the synthesized constructor and copy constructor enable the implementation to create code that's more efficient than user-written code, because it can apply optimizations that aren't always possible otherwise.</p>\n</blockquote>\n<p>There is no explication, but I read time to time similar claims.</p>\n<p>But how is it that writing:</p>\n<pre><code>class C { C() = default; };\n</code></pre>\n<p>can be more efficient than</p>\n<pre><code>class C { C(){} };\n</code></pre>\n<p>? I though a compiler would be smart enough to detect such situation and optimize that. In other words how is it easier for the compiler to optimize when it sees <code>=default</code> instead of <code>{}</code> (void body function)?</p>\n<p>Edit: the question was edited to add the \"c++11\" tag, but this question remains in c++03 context: just replace <code>class C {C()=default;};</code> by <code>class C {};</code>, so not really a c++11 specific question.</p>\n", "Title": "Why would the implicitly generated constructor (et al.) be more efficient than a user-defined (trivial) one?", "CreationDate": "2010-11-25T10:08:34.620", "LastActivityDate": "2013-06-05T13:51:11.480", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-06-05T13:51:11.480", "LastEditorUserId": "525217", "Id": "4275861", "Score": "9", "OwnerUserId": "234232", "Tags": "<c++><performance><c++11><constructor>", "AnswerCount": "4"}});