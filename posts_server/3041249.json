post_cb({"3041285": {"ParentId": "3041249", "CommentCount": "0", "Body": "<p>\u00a712.2/3: \"Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.\"</p>\n<p>IOW, you're safe -- the <code>A</code> object must not be destroyed until after <code>foo</code> returns.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "3041285", "Score": "5", "CreationDate": "2010-06-14T22:05:35.610", "LastActivityDate": "2010-06-14T22:05:35.610"}, "3041264": {"ParentId": "3041249", "LastEditDate": "2010-06-14T22:21:22.687", "CommentCount": "1", "CreationDate": "2010-06-14T22:01:38.007", "OwnerUserId": "151292", "LastEditorUserId": "151292", "PostTypeId": "2", "Id": "3041264", "Score": "17", "Body": "<p>Temporary objects exist up until the end of the full expression in which they are created.  </p>\n<p>In your example, the <code>A</code> object created by <code>A(4)</code> will exist <em>at least</em> until the expression ends just after the return from the call to <code>foo()</code>.</p>\n<p>This behavior is guaranteed by the language standard:</p>\n<blockquote>\n<p id=\"so_3041249_3041264_0\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true even if that evaluation ends in throwing an exception (C++03 \u00a712.2/3).</p>\n</blockquote>\n<p>The lifetime of the temporary may be extended by binding a reference to it (in which case its lifetime is extended until the end of the lifetime of the reference), or by using it as an initializer in a constructor's initializer list (in which case its lifetime is extended until the object being constructed is fully constructed).</p>\n", "LastActivityDate": "2010-06-14T22:21:22.687"}, "3041269": {"ParentId": "3041249", "CommentCount": "0", "CreationDate": "2010-06-14T22:02:06.487", "Id": "3041269", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "2", "Body": "<p>The temporary lasts until the end of the expression it is part of - which in this case is a function call.</p>\n", "LastActivityDate": "2010-06-14T22:02:06.487"}, "3041249": {"CommentCount": "0", "ViewCount": "786", "LastActivityDate": "2010-06-14T22:21:22.687", "Body": "<p>Is a temporary created as part of an argument to a function call guaranteed to stay around until the called function ends, even if the temporary isn't passed directly to the function?</p>\n<p>There's virtually no chance that was coherent, so here's an example:</p>\n<pre><code>class A {\npublic:\n    A(int x) : x(x) {printf(\"Constructed A(%d)\\n\", x);}\n    ~A() {printf(\"Destroyed A\\n\");}\n\n    int x;\n    int* y() {return &amp;x;}\n};\n\nvoid foo(int* bar) {\n    printf(\"foo(): %d\\n\", *bar);\n}\n\nint main(int argc, char** argv) {\n    foo(A(4).y());\n}\n</code></pre>\n<p>If <code>A(4)</code> were passed directly to <code>foo</code> it would definitely not be destroyed until after the <code>foo</code> call ended, but instead I'm calling a method on the temporary and losing any reference to it. I would instinctively think the temporary <code>A</code> would be destroyed before <code>foo</code> even starts, but testing with GCC 4.3.4 shows it isn't; the output is:</p>\n<blockquote>\n<p id=\"so_3041249_3041249_0\">Constructed A(4)<br>\n  foo(): 4<br>\n  Destroyed A</br></br></p>\n</blockquote>\n<p>The question is, <strong>is GCC's behavior guaranteed by the spec</strong>? Or is a compiler allowed to destroy the temporary <code>A</code> before the call to <code>foo</code>, invaliding the pointer to its member I'm using?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "3041264", "FavoriteCount": "0", "Title": "When are temporaries created as part of a function call destroyed?", "Id": "3041249", "Score": "17", "CreationDate": "2010-06-14T21:58:07.703", "Tags": "<c++><memory-management><specifications>", "OwnerUserId": "309308", "AnswerCount": "4"}, "3041284": {"ParentId": "3041249", "CommentCount": "1", "Body": "<p>The lifetime of your temp object <code>A(4)</code> will last long enough to call <code>y()</code></p>\n<p>The memory pointed to in the return of <code>y()</code> is not reliable, depending on threading and allocations it may be reallocated and the value changed before the call to <code>foo()</code> makes use of it.</p>\n", "OwnerUserId": "37558", "PostTypeId": "2", "Id": "3041284", "Score": "-1", "CreationDate": "2010-06-14T22:05:30.147", "LastActivityDate": "2010-06-14T22:05:30.147"}, "bq_ids": {"n4140": {"so_3041249_3041264_0": {"section_id": 380, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_3041249_3041264_0": {"section_id": 371, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_3041249_3041264_0": {"section_id": 395, "quality": 0.8695652173913043, "length": 20}}}});