post_cb({"43045261": {"ParentId": "43043397", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This seems like a <code>gcc</code> bug. I reported it as issue <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80242\" rel=\"nofollow noreferrer\"><strong>#80242</strong></a>.</p>\n<hr>\n<p><code>gcc</code> complains about the validity of <code>i</code> as a template argument:</p>\n<blockquote>\n<p id=\"so_43043397_43045261_0\"><strong>error</strong>: template argument 1 is invalid</p>\n</blockquote>\n<hr>\n<p>I've followed the <a href=\"http://eel.is/c++draft/gram\" rel=\"nofollow noreferrer\">C++ grammar</a> from <a href=\"http://eel.is/c++draft/dcl.decl#nt:trailing-return-type\" rel=\"nofollow noreferrer\"><em><code>trailing-return-type</code></em></a> to <a href=\"http://eel.is/c++draft/temp.names#nt:template-argument\" rel=\"nofollow noreferrer\"><em><code>template-argument</code></em></a>, which needs to be a <a href=\"http://eel.is/c++draft/expr.const#nt:constant-expression\" rel=\"nofollow noreferrer\"><em><code>constant-expression</code></em></a>:</p>\n<blockquote>\n<p id=\"so_43043397_43045261_1\"><em>template-argument</em>:</p>\n<ul>\n<li><em>constant-expression</em> <strong>&lt;-</strong></li>\n<li><em>type-id</em></li>\n<li><em>id-expression</em></li>\n</ul>\n</blockquote>\n<hr>\n<p>The real question then becomes: <strong>\"is <code>i</code> a valid <em><code>constant-expression</code></em>?\"</strong>.</p>\n<p>I think the answer is <strong>\"yes\"</strong>, because <a href=\"http://eel.is/c++draft/expr.const#4\" rel=\"nofollow noreferrer\"><strong>\u00a78.20.4</strong> <em>[expr.const]</em></a> says:</p>\n<blockquote>\n<p id=\"so_43043397_43045261_2\">A <em>converted constant expression</em> of type <code>T</code> is an expression, implicitly converted to type <code>T</code>, where the converted expression is a constant expression and the implicit conversion sequence contains only:</p>\n<ul>\n<li>user-defined conversions,</li>\n</ul>\n<p id=\"so_43043397_43045261_3\"><em>[...]</em></p>\n<p id=\"so_43043397_43045261_4\">(Note: Such expressions may be used in new expressions, as case expressions, as enumerator initializers if the underlying type is fixed, as array bounds, <strong>and as non-type template arguments</strong>. )</p>\n</blockquote>\n<p>There is a sequence of implicit conversions that, starting from <code>i</code>, will produce a <em>converted constant expression</em> which is a <em>constant expression</em>. Given:</p>\n<pre><code>template &lt;int&gt;\nstruct bar { };\n\ntemplate &lt;class I&gt;\nauto foo(I i) -&gt; bar&lt;i&gt; { }\n\nint main()\n{\n    foo(std::integral_constant&lt;int, 1&gt;{}); // (0)\n}\n</code></pre>\n<ul>\n<li><p>In the context of the function call at <strong>(0)</strong>, the argument <code>i</code> is an instance of <code>std::integral_constant&lt;int, 1&gt;</code>.</p></li>\n<li><p><a href=\"http://en.cppreference.com/w/cpp/types/integral_constant\" rel=\"nofollow noreferrer\"><code>std::integral_constant</code></a> provides a <code>constexpr</code> user-defined conversion to the underlying <code>value_type</code>. </p></li>\n<li><p><em>Converted constant expressions</em> explicitly allow <em>user-defined conversions</em>, as seen above in <a href=\"http://eel.is/c++draft/expr.const#4\" rel=\"nofollow noreferrer\"><strong>\u00a78.20.4</strong> <em>[expr.const]</em></a>.</p></li>\n<li><p><code>std::integral_constant::operator value_type()</code> will return the non-type template argument <code>1</code>. This is a <em>core constant expression</em> as it doesn't violate any of the rules specified in <a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow noreferrer\"><strong>\u00a78.20.2</strong> <em>[expr.const]</em></a>.</p></li>\n<li><p>Therefore, the <em>converted constant expression</em> is a <em>constant expression</em>.</p></li>\n</ul>\n</hr></hr></hr>", "OwnerUserId": "598696", "LastEditorUserId": "598696", "LastEditDate": "2017-03-28T20:40:26.663", "Id": "43045261", "Score": "5", "CreationDate": "2017-03-27T11:32:55.457", "LastActivityDate": "2017-03-28T20:40:26.663"}, "43045636": {"ParentId": "43043397", "CommentCount": "1", "Body": "<p>I believe that both your examples are wrong. Based on the standard wording <em>5.20 Constant expressions [expr.const]/p2.7</em>:</p>\n<blockquote>\n<p id=\"so_43043397_43045636_0\"><sup>2</sup> A conditional-expression e is a core constant expression\n  unless the evaluation of e, following the rules of the abstract\n  machine (1.9), would evaluate one of the following expressions:j</p>\n<p id=\"so_43043397_43045636_1\">...</p>\n<p id=\"so_43043397_43045636_2\">- an lvalue-to-rvalue conversion (4.1) unless it is applied to:</p>\n</blockquote>\n<p>Function parameters can't be constant expressions since in order to pass them as template parameters you're applying lvalue to rvalue conversion on them.</p>\n<p>In both CLANG and GCC if you instatiate the templates you are going to get an error based on the wording above. I believe that since in the examples non of the template is instatiated no diagnostic is required thus both compilers are correct.</p>\n", "OwnerUserId": "2352671", "PostTypeId": "2", "Id": "43045636", "Score": "5", "CreationDate": "2017-03-27T11:51:10.953", "LastActivityDate": "2017-03-27T11:51:10.953"}, "bq_ids": {"n4140": {"so_43043397_43045261_2": {"section_id": 6186, "quality": 1.0, "length": 17}, "so_43043397_43045636_0": {"section_id": 6185, "quality": 0.8571428571428571, "length": 12}, "so_43043397_43045261_4": {"section_id": 6186, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_43043397_43045261_2": {"section_id": 5947, "quality": 0.8235294117647058, "length": 14}, "so_43043397_43045261_4": {"section_id": 5947, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_43043397_43045261_2": {"section_id": 7689, "quality": 0.8823529411764706, "length": 15}, "so_43043397_43045261_4": {"section_id": 7689, "quality": 0.9444444444444444, "length": 17}, "so_43043397_43045636_0": {"section_id": 7687, "quality": 0.7142857142857143, "length": 10}}}, "43043397": {"CommentCount": "16", "ViewCount": "640", "PostTypeId": "1", "LastEditorUserId": "4324224", "CreationDate": "2017-03-27T10:00:38.813", "LastActivityDate": "2017-03-28T20:40:26.663", "Title": "Can one use parameter value directly (not its type but value itself) in trailing return type syntax", "AcceptedAnswerId": "43045261", "LastEditDate": "2017-03-28T08:48:53.697", "Id": "43043397", "Score": "17", "Body": "<p>Consider the minimal example:</p>\n<pre><code>template &lt;int&gt;\nstruct bar { };\n\nint main() \n{\n    [](auto i) -&gt; bar&lt;i&gt; { return {}; };\n}\n</code></pre>\n<p>Or even: </p>\n<pre><code>template &lt;int&gt;\nstruct bar {};\n\ntemplate &lt;class I&gt;\nauto foo(I i) -&gt; bar&lt;i&gt; {}\n</code></pre>\n<p>clang compiles both forms without problems but gcc find the usages invalid <a href=\"https://wandbox.org/permlink/tqyAogSOLYDrNNbg\" rel=\"nofollow noreferrer\">(ex. 1)</a>, <a href=\"https://wandbox.org/permlink/nFfclJRdpv7ltiD9\" rel=\"nofollow noreferrer\">(ex. 2)</a></p>\n<p>The question might look silly however the type of parameter can have the constexpr conversion operator overloaded (in this case type of <code>i</code> deduced from value passed to lambda/foo to <code>int</code> in constexpr manner) and in this scenario it would be quite convenient not to be forced to do some workarounds to access it directly...</p>\n", "Tags": "<c++><c++11><language-lawyer><trailing-return-type>", "OwnerUserId": "4324224", "AnswerCount": "2"}});