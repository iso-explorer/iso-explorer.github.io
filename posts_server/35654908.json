post_cb({"35655406": {"Id": "35655406", "PostTypeId": "2", "Body": "<p>Let's see your examples one by one, and what they really mean.</p>\n<pre><code>typedef void(functionPtr)(int);\n\nvoid function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n\n    functionPtr fun = function;\n    fun(5);\n\n    return 0;\n}\n</code></pre>\n<p>Here you are creating a typedef <code>functionPtr</code> for functions which take and <code>int</code>, and don't return values. <code>functionPtr</code> is not actually a typedef for a function pointer, but of an actual function.</p>\n<p>Then you are trying to declare a new function <code>fun</code>, and assign to it <code>function</code>. Unfortunately you cannot assign to functions, so this does not work.</p>\n<pre><code>int main() {\n\n    functionPtr fun;\n    fun(5);\n\n    return 0;\n}\n</code></pre>\n<p>Again, you are declaring a function <code>fun</code> with the signature you specified. But you don't define it, so rightfully you fail the linking phase.</p>\n<pre><code>typedef void(functionPtr)(int);\n\nvoid function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n\n    functionPtr function;\n    function(5);\n\n    return 0;\n}\n</code></pre>\n<p>What happens here? You define the <code>typedef</code>, and in the main you write <code>functionPtr function;</code>. This basically is simply a prototype for the function you have already written, <code>function</code>. It restates that this function exists, but otherwise it does nothing. In fact, you can write:</p>\n<pre><code>typedef void(functionPtr)(int);\n\nvoid function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n\n    functionPtr function;\n    functionPtr function;\n    functionPtr function;\n    void function(int);\n\n    function(5);\n\n    return 0;\n}\n</code></pre>\n<p>How many times you want, it won't change a thing. The <code>function(5)</code> you are calling after is always the same thing.</p>\n<p>One thing you can do in C++ is to declare the prototype of a function using such a typedef, but you cannot define it in that way.</p>\n<pre><code>typedef void(*functionPtr)(int);\n\nfunctionPtr function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Here you are defining a function which returns a function pointer, but then you do not return it. The compiler, depending on your settings, may or may not complain. But again <code>function</code> is completely separated from <code>functionPtr</code>. You have essentially written</p>\n<pre><code>void (*)(int)   function(int a) {\n    ...\n}\n</code></pre>\n<p>The last example, the one where you have a function returning a function, is simply not allowed, because it would be meaningless.</p>\n", "LastActivityDate": "2016-02-26T15:19:30.953", "CommentCount": "0", "CreationDate": "2016-02-26T15:19:30.953", "ParentId": "35654908", "Score": "3", "OwnerUserId": "1356926"}, "46406804": {"Id": "46406804", "PostTypeId": "2", "Body": "<pre><code>typedef void functionPtr (int);\n\nvoid function (int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n\n    functionPtr *func;\n    func = function;\n    func(5);\n    return 0;\n}\n</code></pre>\n<p>You can use it in this way, I had tested.\nThere really a litter tricky about this issue.</p>\n", "LastActivityDate": "2017-09-25T13:47:02.493", "CommentCount": "1", "CreationDate": "2017-09-25T13:47:02.493", "ParentId": "35654908", "Score": "-1", "OwnerUserId": "8668957"}, "35655727": {"Id": "35655727", "PostTypeId": "2", "Body": "<p>The most interesting of your examples is this one, reproduced here without the use of typedef:</p>\n<pre><code>void function(int a) { // declaration and definition of 'function'\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n    void function(int); // declaration of 'function'\n    function(5);\n}\n</code></pre>\n<p>In most contexts in C++, the re-declaration of <code>function</code> in local scope would shadow the global <code>::function</code>. So expecting a linker-error there makes sense - <code>main()::function</code> has no definition right? </p>\n<p>Except functions are special in this regard. From a note in [basic.scope.pdel]:</p>\n<blockquote>\n<p id=\"so_35654908_35655727_0\">Function declarations at block scope\n  and variable declarations with the extern specifier at block scope refer to declarations that are <strong>members of\n  an enclosing namespace</strong>, but they do not introduce new names into that scope.</p>\n</blockquote>\n<p>So that code example is exactly equivalent to:</p>\n<pre><code>void function(int a) { /* ... */ }\nvoid function(int ); // just redeclaring it again, which is ok\n\nint main() {\n    function(5);\n}\n</code></pre>\n<p>You can also verify this by putting the global <code>function</code> into some namespace, <code>N</code>. At this point, the local scope declaration would add a name to <code>::</code>, but it wouldn't have a definition - hence you do get a linker error. </p>\n<hr/>\n<p>The other interesting thing you touched on is the notion of function-to-pointer conversion, [conv.func]:</p>\n<blockquote>\n<p id=\"so_35654908_35655727_1\">An lvalue of function type T can be converted to a prvalue of type \u201cpointer to T\u201d. The result is a pointer to\n  the function.</p>\n</blockquote>\n<p>When you have a function call expression - if the thing you're calling is a function type, it is first converted to a pointer-to-function. That's why these are equivalent:</p>\n<pre><code>fun(5);         // OK, call function pointed to by 'fun'\n(*fun)(5);      // OK, first convert *fun back to 'fun'\nfunction(5);    // OK, first convert to pointer to 'function'\n(*function)(5); // OK, unary* makes function get converted to a pointer\n                // which then gets dereferenced back to function-type\n                // which then gets converted back to a pointer\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-02-26T15:39:48.950", "Score": "4", "CreationDate": "2016-02-26T15:33:53.390", "ParentId": "35654908", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2016-02-26T15:39:48.950"}, "bq_ids": {"n4140": {"so_35654908_35655727_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 12}, "so_35654908_35655727_0": {"length": 22, "quality": 1.0, "section_id": 7059}}, "n3337": {"so_35654908_35655727_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 9}, "so_35654908_35655727_0": {"length": 22, "quality": 1.0, "section_id": 6803}}, "n4659": {"so_35654908_35655727_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 13}, "so_35654908_35655727_0": {"length": 22, "quality": 1.0, "section_id": 8556}}}, "35655142": {"Id": "35655142", "PostTypeId": "2", "Body": "<p>Well, it is confusing a bit.</p>\n<p>Function type and pointer to function type are indeed two different types (no more similar than <code>int</code> and pointer to <code>int</code>). However, there is a rule, that a function type <strong>decays</strong> to pointer to function type in almost all contexts. Here <em>decaying</em> loosely means <em>converted</em> (there is a difference between type conversion and decaying, but you are probably not interested in it right now).</p>\n<p>What is important, is that <strong>almost</strong> every time you use a function type, you end up with pointer to function type. Note the almost, however - almost every time is not <strong>always</strong>!</p>\n<p>And you are hitting some cases when it doesn't. </p>\n<pre><code>typedef void(functionPtr)(int);\nfunctionPtr fun = function;\n</code></pre>\n<p>This code attempts to copy one function (not the pointer! the function!) to another. But of course, this is not possible - you can't copy functions in C++. The compiler doesn't allow this, and I can't believe you got it compiled (you are saying you got linker errors?)</p>\n<p>Now, this code:</p>\n<pre><code>typedef void(functionPtr)(int);\nfunctionPtr function;\nfunction(5);\n</code></pre>\n<p><code>function</code> does not shadow anything. Compiler knows it is not a function pointer which can be called, and just calls your original <code>function</code>.</p>\n", "LastEditorUserId": "5245033", "LastActivityDate": "2016-02-26T18:08:11.570", "Score": "6", "CreationDate": "2016-02-26T15:06:08.363", "ParentId": "35654908", "CommentCount": "6", "OwnerUserId": "5245033", "LastEditDate": "2016-02-26T18:08:11.570"}, "35654908": {"ViewCount": "1194", "Body": "<p>I have a problem with understanding some C++ syntax combined with function pointers and function declarations, that is:</p>\n<p>Usually when we want to declare a type of function we make something like:</p>\n<pre><code>typedef void(*functionPtr)(int);\n</code></pre>\n<p>and this is fine for me. From now on functionPtr is a type, that represents\npointer to the function, that returns void and takes int by a value as an argument.</p>\n<p>We can use it as follows:</p>\n<pre><code>typedef void(*functionPtr)(int);\n\nvoid function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n\n    functionPtr fun = function;\n    fun(5);\n\n    return 0;\n}\n</code></pre>\n<p>And we get <code>5</code> printed on a screen.</p>\n<p>we have got pointer to function <code>fun</code>, we assign some existing pointer to function - <code>function</code> and we execute this function by a pointer. Cool.</p>\n<p>Now as I read in some books, function and pointer to function are treated somehow the same, so in fact after declaration of <code>function()</code> function everytime we say function we mean real function and pointer to function at the same type, so following compiles and every instruction gives the same result (5 printed on a screen):</p>\n<pre><code>int main() {\n\n    functionPtr fun = function;\n    fun(5);\n    (*fun)(5);\n    (*function)(5);\n    function(5);\n\n    return 0;\n}\n</code></pre>\n<p>So now as long as I can imagine, that pointers to functions and functions are pretty much the same, then it's somehow fine for me.</p>\n<p>Then I though, if pointer to function and real function is the same, then why cannot I do following:</p>\n<pre><code>typedef void(functionPtr)(int); //removed *\n\nvoid function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n\n    functionPtr fun = function;\n    fun(5);\n\n    return 0;\n}\n</code></pre>\n<p>This gives me following error:</p>\n<blockquote>\n<p id=\"so_35654908_35654908_0\">prog.cpp:12:14: warning: declaration of 'void fun(int)' has 'extern' and is initialized\n    functionPtr fun = function;</p>\n</blockquote>\n<p>therefore I understood, that for some reason compiler now understands, that fun is <strong>already existing</strong> function. Then I tried following:</p>\n<pre><code>int main() {\n\n    functionPtr fun;\n    fun(5);\n\n    return 0;\n}\n</code></pre>\n<p>And I got linking error. I somehow understand, that as compiler now treats fun as already existing function, then due to the fact, that fun is nowhere defined, I will get linking error. Therefore I changed the name of the variable:</p>\n<pre><code>typedef void(functionPtr)(int);\n\nvoid function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\nint main() {\n\n    functionPtr function;\n    function(5);\n\n    return 0;\n}\n</code></pre>\n<p>So now function in main shadows global name function, so <code>function(5)</code> is used from declaration <code>functionPtr function;</code> It works fine and prints 5 on the screen.</p>\n<p>So now I am shocked. Why did this happen? Also misleading thing is, that when function pointer is declared like this:</p>\n<pre><code>typedef void(*functionPtr)(int);\n</code></pre>\n<p>i can create function of type functionPtr in following manner:</p>\n<pre><code>functionPtr function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>whereas, when declaring something like:</p>\n<pre><code>typedef void(functionPtr)(int);\n</code></pre>\n<p>makes this:</p>\n<pre><code>functionPtr function(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>being interpreted by a compiler as function returning function. If this is so, why previous declaration (<code>typedef void(functionPtr)(int);</code>) knew, that this is a function returning void and not function returning functionPtr?</p>\n<p>Could someone please explain what is really happening underhood for me?</p>\n<p>I am using g++ C++ compiler with C++14 option enabled.</p>\n", "AcceptedAnswerId": "35655142", "Title": "Explanation of function pointers", "CreationDate": "2016-02-26T14:55:29.973", "Id": "35654908", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-02-26T15:05:11.550", "LastEditorUserId": "4764736", "LastActivityDate": "2017-09-25T13:47:02.493", "Score": "17", "OwnerUserId": "4764736", "Tags": "<c++><function><pointers><typedef>", "AnswerCount": "4"}});