post_cb({"4895389": {"Id": "4895389", "PostTypeId": "2", "Body": "<p>The 'virtualness' of a function is propagated implicitly, however at least one compiler I use will generate a warning if the <code>virtual</code> keyword is not used explicitly, so you may want to use it if only to keep the compiler quiet.</p>\n<p>From a purely stylistic point-of-view, including the <code>virtual</code> keyword clearly 'advertises' the fact to the user that the function is virtual.  This will be important to anyone further  sub-classing B without having to check A's definition.  For deep class hierarchies, this becomes especially important.</p>\n", "LastActivityDate": "2011-02-04T07:00:50.447", "CommentCount": "3", "CreationDate": "2011-02-04T07:00:50.447", "ParentId": "4895294", "Score": "66", "OwnerUserId": "168986"}, "4895621": {"Id": "4895621", "PostTypeId": "2", "Body": "<p>Adding the \"virtual\" keyword is good practice as it improves readability , but it is not necessary. Functions declared virtual in the base class, and having the same signature in the derived classes are considered \"virtual\" by default.</p>\n", "LastActivityDate": "2011-02-04T07:38:24.120", "CommentCount": "0", "CreationDate": "2011-02-04T07:38:24.120", "ParentId": "4895294", "Score": "9", "OwnerUserId": "102062"}, "4895369": {"Id": "4895369", "PostTypeId": "2", "Body": "<p>There is no difference for the compiler, when you write the <code>virtual</code> in the derived class or omit it. </p>\n<p>But you need to look at the base class to get this information. Therfore I would recommend to add the <code>virtual</code> keyword also in the derived class, if you want to show to the human that this function is virtual.</p>\n", "LastActivityDate": "2011-02-04T06:57:04.560", "CommentCount": "0", "CreationDate": "2011-02-04T06:57:04.560", "ParentId": "4895294", "Score": "7", "OwnerUserId": "266487"}, "25414336": {"Id": "25414336", "PostTypeId": "2", "Body": "<p>The <code>virtual</code> keyword is not necessary in the derived class. Here's the supporting documentation, from the C++ Draft Standard (N3337) (emphasis mine):</p>\n<blockquote>\n<p id=\"so_4895294_25414336_0\"><strong>10.3 Virtual functions</strong></p>\n<p id=\"so_4895294_25414336_1\">2 If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (<strong>whether or not it is so declared</strong>) and it overrides <code>Base::vf</code>.</p>\n</blockquote>\n", "LastActivityDate": "2014-08-20T21:01:02.943", "CommentCount": "0", "CreationDate": "2014-08-20T21:01:02.943", "ParentId": "4895294", "Score": "28", "OwnerUserId": "434551"}, "bq_ids": {"n4140": {"so_4895294_25414336_1": {"length": 31, "quality": 0.96875, "section_id": 7003}}, "n3337": {"so_4895294_25414336_1": {"length": 31, "quality": 0.96875, "section_id": 6749}}, "n4659": {"so_4895294_25414336_1": {"length": 31, "quality": 0.96875, "section_id": 8500}}}, "4895297": {"Id": "4895297", "PostTypeId": "2", "Body": "<p>They are exactly the same.  There is no difference between them other than that the first approach requires more typing and is potentially clearer.</p>\n", "LastActivityDate": "2011-02-04T06:47:37.463", "CommentCount": "7", "CreationDate": "2011-02-04T06:47:37.463", "ParentId": "4895294", "Score": "136", "OwnerUserId": "151292"}, "4895294": {"ViewCount": "50303", "Body": "<p>With the struct definition given below...</p>\n<pre><code>struct A {\n    virtual void hello() = 0;\n};\n</code></pre>\n<p>Approach #1:</p>\n<pre><code>struct B : public A {\n    virtual void hello() { ... }\n};\n</code></pre>\n<p>Approach #2:</p>\n<pre><code>struct B : public A {\n    void hello() { ... }\n};\n</code></pre>\n<p>Is there any difference between these two ways to override the hello function?</p>\n", "AcceptedAnswerId": "4895297", "Title": "C++ \"virtual\" keyword for functions in derived classes. Is it necessary?", "CreationDate": "2011-02-04T06:46:57.703", "Id": "4895294", "CommentCount": "2", "FavoriteCount": "32", "PostTypeId": "1", "LastEditDate": "2013-07-08T22:29:24.017", "LastEditorUserId": "881229", "LastActivityDate": "2016-07-28T09:19:05.010", "Score": "164", "OwnerUserId": "556384", "Tags": "<c++><override><virtual-functions>", "AnswerCount": "8"}, "22438626": {"Id": "22438626", "PostTypeId": "2", "Body": "<p>I will certainly include the Virtual keyword for the child class, because\ni. Readability.\nii. This child class my be derived further down, you don't want the constructor of the further derived class to call this virtual function.</p>\n", "LastActivityDate": "2014-03-16T15:11:37.730", "CommentCount": "2", "CreationDate": "2014-03-16T15:11:37.730", "ParentId": "4895294", "Score": "0", "OwnerUserId": "2264698"}, "26375213": {"Id": "26375213", "PostTypeId": "2", "Body": "<p>No, the <code>virtual</code> keyword on derived classes' virtual function overrides is not required.  But it is worth mentioning a related pitfall: a failure to override a virtual function.</p>\n<p>The <em>failure to override</em> occurs if you intend to override a virtual function in a derived class, but make an error in the signature so that it declares a new and different virtual function.  This function may be an <em>overload</em> of the base class function, or it might differ in name.  Whether or not you use the <code>virtual</code> keyword in the derived class function declaration, the compiler would not be able to tell that you intended to override a function from a base class.</p>\n<p>This pitfall is, however, thankfully addressed by the C++11 <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11#Explicit_overrides_and_final\" rel=\"noreferrer\">explicit override</a> language feature, which allows the source code to clearly specify that a member function is intended to override a base class function:</p>\n<pre><code>struct Base {\n    virtual void some_func(float);\n};\n\nstruct Derived : Base {\n    virtual void some_func(int) override; // ill-formed - doesn't override a base class method\n};\n</code></pre>\n<p>The compiler will issue a compile-time error and the programming error will be immediately obvious (perhaps the function in Derived should have taken a <code>float</code> as the argument).</p>\n<p>Refer to <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11#Explicit_overrides_and_final\" rel=\"noreferrer\">WP:C++11</a>.</p>\n", "LastEditorUserId": "994153", "LastActivityDate": "2015-12-01T19:54:51.753", "Score": "23", "CreationDate": "2014-10-15T05:39:18.647", "ParentId": "4895294", "CommentCount": "0", "OwnerUserId": "994153", "LastEditDate": "2015-12-01T19:54:51.753"}, "38632101": {"Id": "38632101", "PostTypeId": "2", "Body": "<p>There's a considerable difference when you have templates and start taking base class(es) as template parameter(s):</p>\n<pre><code>struct None {};\n\ntemplate&lt;typename... Interfaces&gt;\nstruct B : public Interfaces\n{\n    void hello() { ... }\n};\n\nstruct A {\n    virtual void hello() = 0;\n};\n\ntemplate&lt;typename... Interfaces&gt;\nvoid t_hello(const B&lt;Interfaces...&gt;&amp; b) // different code generated for each set of interfaces (a vtable-based clever compiler might reduce this to 2); both t_hello and b.hello() might be inlined properly\n{\n    b.hello();   // indirect, non-virtual call\n}\n\nvoid hello(const A&amp; a)\n{\n    a.hello();   // Indirect virtual call, inlining is impossible in general\n}\n\nint main()\n{\n    B&lt;None&gt;  b;         // Ok, no vtable generated, empty base class optimization works, sizeof(b) == 1 usually\n    B&lt;None&gt;* pb = &amp;b;\n    B&lt;None&gt;&amp; rb = b;\n\n    b.hello();          // direct call\n    pb-&gt;hello();        // pb-relative non-virtual call (1 redirection)\n    rb-&gt;hello();        // non-virtual call (1 redirection unless optimized out)\n    t_hello(b);         // works as expected, one redirection\n    // hello(b);        // compile-time error\n\n\n    B&lt;A&gt;     ba;        // Ok, vtable generated, sizeof(b) &gt;= sizeof(void*)\n    B&lt;None&gt;* pba = &amp;ba;\n    B&lt;None&gt;&amp; rba = ba;\n\n    ba.hello();         // still can be a direct call, exact type of ba is deducible\n    pba-&gt;hello();       // pba-relative virtual call (usually 3 redirections)\n    rba-&gt;hello();       // rba-relative virtual call (usually 3 redirections unless optimized out to 2)\n    //t_hello(b);       // compile-time error (unless you add support for const A&amp; in t_hello as well)\n    hello(ba);\n}\n</code></pre>\n<p>The fun part of it is that you can now define interface and non-interface functions <em>later</em> to defining classes. That is useful for interworking interfaces between libraries (don't rely on this as a standard design process of a <em>single</em> library). It costs you nothing to allow this for all of your classes - you might even <code>typedef</code> B to something if you'd like.</p>\n<p>Note that, if you do this, you might want to declare copy / move constructors as templates, too: allowing to construct from different interfaces allows you to 'cast' between different <code>B&lt;&gt;</code> types.</p>\n<p>It's questionable whether you should add support for <code>const A&amp;</code> in <code>t_hello()</code>. The usual reason for this rewrite is to move away from inheritance-based specialization to template-based one, mostly for performance reasons. If you continue to support the old interface, you can hardly detect (or deter from) old usage.</p>\n", "LastActivityDate": "2016-07-28T09:19:05.010", "CommentCount": "0", "CreationDate": "2016-07-28T09:19:05.010", "ParentId": "4895294", "Score": "1", "OwnerUserId": "6292621"}});