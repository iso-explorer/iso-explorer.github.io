post_cb({"45628834": {"Id": "45628834", "PostTypeId": "2", "Body": "<p>From N4296 (~C++14):</p>\n<blockquote>\n<p id=\"so_45628694_45628834_0\">3.8 Object lifetime [basic.life]</p>\n<p id=\"so_45628694_45628834_1\">...</p>\n<p id=\"so_45628694_45628834_2\">The lifetime of an object of type T ends when:</p>\n<p id=\"so_45628694_45628834_3\">(1.3) \u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_45628694_45628834_4\">(1.4) \u2014 the storage which the object occupies is reused or released.</p>\n</blockquote>\n<p>Then:</p>\n<blockquote>\n<p id=\"so_45628694_45628834_5\">12.4 Destructors [class.dtor]</p>\n<p id=\"so_45628694_45628834_6\">...</p>\n<p id=\"so_45628694_45628834_7\">A destructor is trivial if it is not user-provided and if:</p>\n<p id=\"so_45628694_45628834_8\">(5.4) \u2014 the destructor is not <code>virtual</code>,</p>\n<p id=\"so_45628694_45628834_9\">(5.5) \u2014 all of the direct base classes of its class have trivial destructors, and</p>\n<p id=\"so_45628694_45628834_10\">(5.6) \u2014 for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor.</p>\n<p id=\"so_45628694_45628834_11\">Otherwise, the destructor is <em>non-trivial</em>.</p>\n</blockquote>\n<p>So basically, for simple enough classes, this is safe, but if you have any kind of resource-owning classes involved it is not going to be legal.</p>\n<p>Take care, though, that in your example your destructor is user-provided, hence non-trivial.</p>\n", "LastEditorUserId": "1171191", "LastActivityDate": "2017-08-11T07:07:02.117", "Score": "7", "CreationDate": "2017-08-11T06:56:55.640", "ParentId": "45628694", "CommentCount": "0", "OwnerUserId": "1171191", "LastEditDate": "2017-08-11T07:07:02.117"}, "45628969": {"Id": "45628969", "PostTypeId": "2", "Body": "<p>Well, theoretically you should be fine, however from any other point of view, this will end up with lots of memory leaks and will turn out to be a maintenance nightmare. If your class is empty (just like in the example) you will loose an unimaginable amount of <strong>1 byte</strong> per instantiation (the first entry of the log below), and from the point that you will put this in real classes this amount will just multiply. And if you use valgrind you will see something like:</p>\n<pre><code>==15044== HEAP SUMMARY:\n==15044==     in use at exit: 72,705 bytes in 2 blocks\n==15044==   total heap usage: 3 allocs, 1 frees, 73,729 bytes allocated\n==15044== \n==15044== 1 bytes in 1 blocks are definitely lost in loss record 1 of 2\n==15044==    at 0x4C2E0EF: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==15044==    by 0x4007C8: main (del.cpp:11)\n==15044== \n==15044== 72,704 bytes in 1 blocks are still reachable in loss record 2 of 2\n==15044==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==15044==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==15044==    by 0x40106B9: call_init.part.0 (dl-init.c:72)\n==15044==    by 0x40107CA: call_init (dl-init.c:30)\n==15044==    by 0x40107CA: _dl_init (dl-init.c:120)\n==15044==    by 0x4000C69: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)\n==15044== \n==15044== LEAK SUMMARY:\n==15044==    definitely lost: 1 bytes in 1 blocks\n==15044==    indirectly lost: 0 bytes in 0 blocks\n==15044==      possibly lost: 0 bytes in 0 blocks\n==15044==    still reachable: 72,704 bytes in 1 blocks\n==15044==         suppressed: 0 bytes in 0 blocks\n</code></pre>\n<p>(and yes, now I am scratching my head where did those 72704 bytes go missing from a tiny little application like this)</p>\n", "LastActivityDate": "2017-08-11T07:06:06.470", "CommentCount": "2", "CreationDate": "2017-08-11T07:06:06.470", "ParentId": "45628694", "Score": "-1", "OwnerUserId": "186193"}, "47563505": {"Id": "47563505", "PostTypeId": "2", "Body": "<p>The main problem is that even if have empty dtor's, other background things, like the release of virtual method tables, will happen. My personal approach in such cases is to make a private dtor and use a member method (name it destroy if you want) for filtering the delete operator. For example</p>\n<pre><code>class A\n{\n     bool _may_be_deleted;\n\npublic:\n\n    A(bool may_be_deleted)\n    : _may_be_deleted(may_be_deleted){;}\n\n    void allow_delete()\n    {\n        _prevent_delete = false;\n    }\n\n    static bool destroy(A*);\n\nprivate:\n\n    virtual ~A(){;}\n};\n\nbool A::destroy(A *pA)\n{\n    if(pA-&gt;_may_be_deleted)\n    {\n        delete pA;\n        return true;\n    }\n    return false;\n}\n\nint main(int argc, char* argv[])\n{\n    A* pA = new A(false);\n    A::destroy(pA);     //returns false and A is not deleted\n    pA-&gt;allow_delete();\n    A::destroy(pA);     //Ok, now A is destroyed and returns true;\n}\n</code></pre>\n<p>Hope that helps.</p>\n", "LastActivityDate": "2017-11-29T23:22:15.920", "CommentCount": "0", "CreationDate": "2017-11-29T23:22:15.920", "ParentId": "45628694", "Score": "0", "OwnerUserId": "4575304"}, "bq_ids": {"n4140": {"so_45628694_45628896_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 407}, "so_45628694_45628896_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 407}, "so_45628694_45628834_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_45628694_45628834_9": {"length": 9, "quality": 1.0, "section_id": 401}, "so_45628694_45628834_4": {"length": 5, "quality": 1.0, "section_id": 7189}, "so_45628694_45628896_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 407}, "so_45628694_45628834_10": {"length": 15, "quality": 1.0, "section_id": 401}, "so_45628694_45628896_5": {"length": 35, "quality": 0.875, "section_id": 407}, "so_45628694_45628834_3": {"length": 7, "quality": 0.875, "section_id": 7189}, "so_45628694_45628896_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 407}}, "n3337": {"so_45628694_45628896_3": {"length": 9, "quality": 0.75, "section_id": 398}, "so_45628694_45628896_4": {"length": 5, "quality": 0.5555555555555556, "section_id": 398}, "so_45628694_45628834_9": {"length": 9, "quality": 1.0, "section_id": 392}, "so_45628694_45628834_4": {"length": 5, "quality": 1.0, "section_id": 6933}, "so_45628694_45628896_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 398}, "so_45628694_45628834_10": {"length": 15, "quality": 1.0, "section_id": 392}, "so_45628694_45628834_3": {"length": 7, "quality": 0.875, "section_id": 6933}, "so_45628694_45628896_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 398}, "so_45628694_45628834_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}}, "n4659": {"so_45628694_45628896_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 425}, "so_45628694_45628896_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 425}, "so_45628694_45628834_9": {"length": 9, "quality": 1.0, "section_id": 419}, "so_45628694_45628834_4": {"length": 5, "quality": 1.0, "section_id": 8701}, "so_45628694_45628896_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 425}, "so_45628694_45628834_10": {"length": 15, "quality": 1.0, "section_id": 419}, "so_45628694_45628896_5": {"length": 35, "quality": 0.875, "section_id": 425}, "so_45628694_45628834_3": {"length": 7, "quality": 0.875, "section_id": 8697}, "so_45628694_45628896_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 425}, "so_45628694_45628834_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}}}, "45628694": {"ViewCount": "1522", "Body": "<p>Using the <code>delete</code> operator on an object normally leads to two things: calling the object's destructor (and its virtual base destructors, if present) and freeing the memory afterwards.</p>\n<p>If override the <code>delete</code> operator on a class giving it an empty implementation <code>{}</code>, the destructor will still be called, but the memory does not get freed.</p>\n<p>Assuming the destructor is also empty, will the <code>delete</code> then have any effect or would it be safe to continue using the \"deleted\" object (i.e. is there undefined behaviour)?</p>\n<pre><code>struct Foo {\n    static void operator delete(void* ptr) {}\n    Foo() {}\n    ~Foo() {}\n    void doSomething() { ... }\n}\n\nint main() {\n    Foo* foo = new Foo();\n    delete foo;\n    foo-&gt;doSomething(); // safe?\n}\n</code></pre>\n<p>Not that this would make much sense as it is, but I'm investigating in a \"deferred delete\" (gc) mechanism where objects won't get deleted instantly when <code>delete</code> gets called but shortly afterwards.</p>\n<p><strong>Update</strong></p>\n<p>Referring to some answers that mention memory leaks: let's assume the overloaded <code>delete</code> operator is not empty, but does store its <code>ptr</code> argument in a (let's say <em>static</em>, for the sake of simplicity) <code>set</code>:</p>\n<pre><code>struct Foo {\n    static std::unordered_set&lt;void*&gt; deletedFoos;\n    static void operator delete(void* ptr) {\n        deletedFoos.insert(ptr);\n    }\n    Foo() {}\n    ~Foo() {}\n}\n</code></pre>\n<p>And this <code>set</code> gets cleaned up periodically:</p>\n<pre><code>for (void* ptr : Foo::deletedFoos) {\n    ::operator delete(ptr);\n}\nFoo::deletedFoos.clear();\n</code></pre>\n", "AcceptedAnswerId": "45628896", "Title": "Override delete operator with empty implementation", "CreationDate": "2017-08-11T06:48:10.900", "Id": "45628694", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-08-11T09:55:22.710", "LastEditorUserId": "333698", "LastActivityDate": "2017-11-29T23:22:15.920", "Score": "22", "OwnerUserId": "8328160", "Tags": "<c++>", "AnswerCount": "5"}, "45631457": {"Id": "45631457", "PostTypeId": "2", "Body": "<p>Whether your hack can work depends on the members of the class.  The destructor will <strong>always</strong> call the destructors of the class members.  If you have any members that are strings, vectors, or other objects with an 'active' destructor, these objects will be destroyed, even tough the memory allocated for the containing object is still allocated.</p>\n", "LastActivityDate": "2017-08-11T09:21:18.743", "CommentCount": "0", "CreationDate": "2017-08-11T09:21:18.743", "ParentId": "45628694", "Score": "1", "OwnerUserId": "2430669"}, "45628896": {"Id": "45628896", "PostTypeId": "2", "Body": "<p>From n4296:</p>\n<blockquote>\n<p id=\"so_45628694_45628896_0\">A destructor is invoked implicitly</p>\n<p id=\"so_45628694_45628896_1\">(11.1) \u2014 for a constructed object with static storage duration (3.7.1)\n  at program termination (3.6.3),</p>\n<p id=\"so_45628694_45628896_2\">(11.2) \u2014 for a constructed object with thread storage duration (3.7.2)\n  at thread exit,</p>\n<p id=\"so_45628694_45628896_3\">(11.3) \u2014 for a constructed object with automatic storage duration\n  (3.7.3) when the block in which an object is created exits (6.7),</p>\n<p id=\"so_45628694_45628896_4\">(11.4) \u2014 for a constructed temporary object when its lifetime ends\n  (12.2).</p>\n<p id=\"so_45628694_45628896_5\">In each case, the context of the invocation is the context of the\n  construction of the object. A destructor is also invoked implicitly\n  through use of a delete-expression (5.3.5) for a constructed object\n  allocated by a new-expression (5.3.4); the context of the invocation\n  is the delete-expression. [ Note: An array of class type contains\n  several subobjects for each of which the destructor is invoked. \u2014end\n  note ] A destructor can also be invoked explicitly. </p>\n</blockquote>\n<p>Thus, the very use of delete expression that calls delete operator, you implicitly call  destructor as well. Object's life ended, it's an undefined behavior what happens if you will call a method for that object.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    static void operator delete(void* ptr) {}\n    Foo() {}\n    ~Foo() { std::cout &lt;&lt; \"Destructor called\\n\"; }\n    void doSomething() { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" called\\n\"; }\n};\n\nint main() {\n    Foo* foo = new Foo();\n    delete foo;\n    foo-&gt;doSomething(); \n   // safe? No, an UB. Object's life is ended by delete expression.\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Destructor called\nvoid Foo::doSomething() called\n</code></pre>\n<p>used: gcc HEAD 8.0.0 20170809  with -O2</p>\n<p>The question  starts with assumption that redefining delete operator and behaviour of object would omit destruction of object. Redefining destructor of  object itself will not redefine destructors of its fields.\nIn fact it won't exist anymore from semantics point of view. It will not deallocate memory, which might be a thing if object is stored in memory pool. But it would delete  abstract 'soul' of object, so to say. Calling methods or accessing fields of object after that is UB. \nIn particular case, depending  on operation system, that memory may stay forever allocated. Which is an unsafe behavior. It also unsafe to assume that  compiler would generate sensible code. It may omit actions altogether.</p>\n<p>Let me add some data to object:</p>\n<pre><code>struct Foo {\n    int a;\n    static void operator delete(void* ptr) {}\n    Foo(): a(5) {}\n    ~Foo() { std::cout &lt;&lt; \"Destructor called\\n\"; }\n    void doSomething() { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" called\\n\"; }\n};\n\nint main() {\n    Foo* foo = new Foo();\n    delete foo;\n    foo-&gt;doSomething(); // safe?\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Destructor called\nvoid Foo::doSomething() a= 566406056 called\n</code></pre>\n<p>Hm? We didn't initialized memory?  Let's add same call before destruction.</p>\n<pre><code>int main() {\n    Foo* foo = new Foo();\n    foo-&gt;doSomething(); // safe!\n    delete foo;\n    foo-&gt;doSomething(); // safe?\n}\n</code></pre>\n<p>Output here:</p>\n<pre><code>void Foo::doSomething() a= 5 called\nDestructor called\nvoid Foo::doSomething() a= 5 called\n</code></pre>\n<p>What? Of course, compiler just omitted initialization of a in first case. Could it be because class doesn't do anything else? In this case it is possible. But this:</p>\n<pre><code>struct Foo {\n    int a, b;\n    static void operator delete(void* ptr) {}\n    Foo(): a(5), b(10) {}\n    ~Foo() { std::cout &lt;&lt; \"Destructor called\\n\"; }\n    void doSomething() { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" a= \" &lt;&lt; a &lt;&lt; \" called\\n\"; }\n};\n\nint main() {\n    Foo* foo = new Foo();\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" b= \" &lt;&lt; foo-&gt;b &lt;&lt; \"\\n\"; \n    delete foo;\n    foo-&gt;doSomething(); // safe?\n}\n</code></pre>\n<p>will generate similar undefined value:</p>\n<pre><code>int main() b= 10\nDestructor called\nvoid Foo::doSomething() a= 2017741736 called\n</code></pre>\n<p>Compiler had considered field <code>a</code> unused by the time of death of <code>foo</code> and thus \"dead\" without impact on further code. <code>foo</code> went down with all \"hands\" and none of them formally do exist anymore. Not to mention that on Windows, using MS compiler those programs would likely crash when <code>Foo::doSomething()</code>  would try to revive the dead member. Placement new would allow us to play Dr.Frankenstein role:</p>\n<pre><code>    #include &lt;iostream&gt;\n#include &lt;new&gt;\nstruct Foo {\n    int a;\n    static void operator delete(void* ptr) {}\n    Foo()              {std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" a= \" &lt;&lt; a &lt;&lt; \" called\\n\"; }\n    Foo(int _a): a(_a) {std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" a= \" &lt;&lt; a &lt;&lt; \" called\\n\"; }\n    ~Foo() { std::cout &lt;&lt; \"Destructor called\\n\"; }\n    void doSomething() { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" a= \" &lt;&lt; a &lt;&lt; \" called\\n\"; }\n};\n\nint main() {\n    Foo* foo = new Foo(5);\n    foo-&gt;~Foo(); \n\n    Foo *revenant = new(foo) Foo();\n    revenant-&gt;doSomething(); \n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Foo::Foo(int) a= 5 called\nDestructor called\nFoo::Foo() a= 1873730472 called\nvoid Foo::doSomething() a= 1873730472 called\n</code></pre>\n<p>Irregardless to wit if we call destructor or not, compilers  are allowed to decide that  revenant isn't same thing as original object, so we can't reuse  old data, only allocated memory.</p>\n<p>Curiously enough,  while still performing UB, if we remove delete operator from <code>Foo</code>, that operation seem to work as expected with GCC. We do not call delete in this case, yet removal and addition of it changes  compiler behavior, which, I believe, is an artifact of implementation.</p>\n", "LastEditorUserId": "2742717", "LastActivityDate": "2017-08-11T11:26:25.953", "Score": "19", "CreationDate": "2017-08-11T07:01:09.877", "ParentId": "45628694", "CommentCount": "1", "OwnerUserId": "2742717", "LastEditDate": "2017-08-11T11:26:25.953"}});