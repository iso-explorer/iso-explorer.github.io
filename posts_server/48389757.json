post_cb({"bq_ids": {"n4140": {"so_48389757_48390021_2": {"length": 59, "quality": 0.921875, "section_id": 3919}}, "n3337": {"so_48389757_48390021_2": {"length": 59, "quality": 0.921875, "section_id": 3779}}, "n4659": {"so_48389757_48390021_2": {"length": 62, "quality": 0.96875, "section_id": 4805}}}, "48390021": {"Id": "48390021", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48389757_48390021_0\">Is using an instance pointer and new in that implementation still\n  guaranteed to be thread safe (a race condition could be a potential\n  reason for that error)?</p>\n</blockquote>\n<p>Yes, it is thread safe.</p>\n<p>From N4659:</p>\n<blockquote>\n<p id=\"so_48389757_48390021_1\">9.7 Declaration statement [stmt.dcl]</p>\n<p id=\"so_48389757_48390021_2\"><strong>Dynamic initialization of a block-scope variable with static storage\n  duration</strong> (6.7.1) or thread storage duration (6.7.2) <strong>is performed the\n  first time control passes through its declaration; such a variable is\n  considered initialized upon the completion of its initialization</strong>. If\n  the initialization exits by throwing an exception, the initialization\n  is not complete, so it will be tried again the next time control\n  enters the declaration. <strong>If control enters the declaration concurrently\n  while the variable is being initialized, the concurrent execution\n  shall wait for completion of the initialization.</strong> If control\n  re-enters the declaration recursively while the variable is being\n  initialized, the behavior is undefined.</p>\n</blockquote>\n<p>As <code>myInstance</code> is a block-scope variable with a static storage duration which is dynamically initialized, the code is thread-safe even if multiple threads are involved.</p>\n", "LastActivityDate": "2018-01-22T20:49:47.227", "CommentCount": "1", "CreationDate": "2018-01-22T20:49:47.227", "ParentId": "48389757", "Score": "1", "OwnerUserId": "5507349"}, "48390850": {"Id": "48390850", "PostTypeId": "2", "Body": "<p>Just as FYI, wanted to add the below reference which explains when to use a pointer and when not:\n<a href=\"https://isocpp.org/wiki/faq/ctors#construct-on-first-use-v2\" rel=\"nofollow noreferrer\">https://isocpp.org/wiki/faq/ctors#construct-on-first-use-v2</a></p>\n<p>Basically using a pointer will not leak since the OS will reclaim memory once the process exists, this is likely the best approach in most of the cases. However if the singleton needs to close another resource, i.e. a file, in destructor, then that's a problem. In that case don't use the static local variable as pointer but just a static local object. Make sure that any other static objects that use this object in destructors are used in their constructors as well, to make sure when the program exists, calls their destructors in correct order.</p>\n", "LastActivityDate": "2018-01-22T21:53:58.623", "CommentCount": "3", "CreationDate": "2018-01-22T21:53:58.623", "ParentId": "48389757", "Score": "0", "OwnerUserId": "5352221"}, "48389757": {"ViewCount": "90", "Body": "<p>I came over <a href=\"https://stackoverflow.com/questions/48388574/inserting-into-map-that-is-member-of-singleton\">this question</a> recently, and got doubts about the <code>Instance()</code> function implementation:</p>\n<pre><code>class Configuration\n{\npublic:\n    static Configuration* Instance() {\n        static Configuration * myInstance = new Configuration();\n        return myInstance;\n    }\n\n    int i;\n    // delete copy and move constructors and assign operators\n    Configuration(Configuration const&amp;) = delete;             // Copy  construct\n    Configuration(Configuration&amp;&amp;) = delete;                  // Move construct\n    Configuration&amp; operator=(Configuration const&amp;) = delete;  // Copy assign\n    Configuration&amp; operator=(Configuration &amp;&amp;) = delete;      // Move assign\n\nprotected:\n    Configuration() {\n\n    }\n    ~Configuration() {}\n\n    // ...\n}\n</code></pre>\n<p>Unfortunately the OP doesn't seem to be able to provide a MCVE that reproduces that <em>read access violation</em> they claim.</p>\n<ul>\n<li>Is using an instance pointer and <code>new</code> in that implementation still guaranteed to be thread safe (a race condition could be a potential reason for that error)?</li>\n</ul>\n<p>Here's an example of the <a href=\"http://coliru.stacked-crooked.com/a/6c9af039425749e6\" rel=\"nofollow noreferrer\">working code</a>, there's only a single thread involved though.</p>\n", "AcceptedAnswerId": "48390021", "Title": "Is using new thread safe to instantiate a singleton in an implementation similar to Scott Meyer's singleton idiom?", "CreationDate": "2018-01-22T20:29:28.657", "LastActivityDate": "2018-01-22T21:53:58.623", "CommentCount": "15", "LastEditDate": "2018-01-22T21:04:34.233", "PostTypeId": "1", "LastEditorDisplayName": "user9212993", "OwnerDisplayName": "user9212993", "Id": "48389757", "Score": "0", "Tags": "<c++><c++11>", "AnswerCount": "2"}});