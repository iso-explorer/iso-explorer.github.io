post_cb({"9476036": {"CommentCount": "2", "ViewCount": "563", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-02-28T03:35:40.600", "LastActivityDate": "2013-11-24T01:51:42.693", "Title": "c++ only: unary minus for 0x80000000", "FavoriteCount": "0", "LastEditDate": "2017-03-20T10:29:31.190", "Id": "9476036", "Score": "3", "Body": "<p>This question is supposedly for language-lawyers.</p>\n<p>Suppose that signed and unsigned int are both 32 bits wide. As stated in the n3337.pdf draft, 5.3.1.8,</p>\n<p><code>(-(0x80000000u)) = 0x100000000u-0x80000000u = 0x80000000u</code></p>\n<p>But I can not find the answer to the question: what will be unary minus for <strong>signed</strong> 0x80000000? Is it UB, implementation defined, or ... ?</p>\n<p><strong>The question is mostly about run-time calculation.</strong></p>\n<p>Say</p>\n<pre><code>   signed int my_minus(signed int i) { return -i;}\n   ....\n   int main() {\n       signed int a = -0x7FFFFFFF; // a looks like 0x80000001\n       signed int b = a - 1;       // b looks like 0x80000000\n       std::cout &lt;&lt; my_minus(b);\n       ....\n   }\n</code></pre>\n<p>Still, your comments on other 2 cases are welcome:</p>\n<ul>\n<li><p>Compile-time constant folding, say, <code>-(INT_MIN)</code></p></li>\n<li><p>Compile-time calculation of <code>constexpr</code> (if there is a difference with compile-time constant folding).</p></li>\n</ul>\n<hr>\n<p>( Please look at <a href=\"https://meta.stackexchange.com/questions/123713/is-splitting-a-question-a-good-practice\">https://meta.stackexchange.com/questions/123713/is-splitting-a-question-a-good-practice</a> before voting for duplicate. ) </p>\n</hr>", "Tags": "<c++><standards><language-lawyer><unary-operator>", "OwnerUserId": "1123502", "AnswerCount": "2"}, "9476111": {"ParentId": "9476036", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-02-28T03:50:53.583", "Score": "3", "LastEditorUserId": "153285", "LastEditDate": "2012-02-28T03:57:27.890", "Id": "9476111", "OwnerUserId": "153285", "Body": "<p>Signed integral types obey the rules of mathematical integers without added computer bullshit. So <code>-std::numeric_limits&lt; signed_type &gt;::min()</code> is going to be undefined behavior, if the given type cannot represent the resulting number.</p>\n<p>In a <code>constexpr</code>, the implementation is <em>required</em> to reject that expression, as anything causing undefined behavior renders a constant expression invalid, as a diagnosable rule. In this case the rule is one of the forbidden items in \u00a75.19,</p>\n<blockquote>\n<p id=\"so_9476036_9476111_0\">\u2014 a result that is not mathematically defined or not in the range of representable values for its type;</p>\n</blockquote>\n<p>In constant folding, the compiler is most likely to insert the overflowed value.</p>\n", "LastActivityDate": "2012-02-28T03:57:27.890"}, "9476130": {"ParentId": "9476036", "CommentCount": "0", "CreationDate": "2012-02-28T03:52:56.253", "OwnerUserId": "116908", "PostTypeId": "2", "Id": "9476130", "Score": "4", "Body": "<p>Signed integer overflow is always undefined, as far as I know.  From the C++ spec section <strong>5 Expressions</strong>, paragraph 4:</p>\n<blockquote>\n<p id=\"so_9476036_9476130_0\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined. [<em>Note:</em> most existing implementations of C++ ignore integer overflows. Treatment of division by zero, forming a remainder using a zero divisor, and all floating point exceptions vary among machines, and is usually adjustable by a library function. <em>\u2014endnote</em>]</p>\n</blockquote>\n", "LastActivityDate": "2012-02-28T03:52:56.253"}, "bq_ids": {"n4140": {"so_9476036_9476130_0": {"section_id": 5937, "quality": 0.95, "length": 38}, "so_9476036_9476111_0": {"section_id": 3401, "quality": 1.0, "length": 8}}, "n3337": {"so_9476036_9476130_0": {"section_id": 5709, "quality": 0.95, "length": 38}, "so_9476036_9476111_0": {"section_id": 3270, "quality": 1.0, "length": 8}}, "n4659": {"so_9476036_9476130_0": {"section_id": 7421, "quality": 0.725, "length": 29}, "so_9476036_9476111_0": {"section_id": 4158, "quality": 1.0, "length": 8}}}});