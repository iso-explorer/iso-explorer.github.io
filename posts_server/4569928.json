post_cb({"bq_ids": {"n4140": {"so_4569928_4569975_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 85}, "so_4569928_4569975_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 7141}, "so_4569928_4569975_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 85}}, "n3337": {"so_4569928_4569975_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 80}, "so_4569928_4569975_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 80}, "so_4569928_4569975_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6885}}, "n4659": {"so_4569928_4569975_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 88}, "so_4569928_4569975_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 88}, "so_4569928_4569975_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 8642}}}, "4569928": {"ViewCount": "1751", "Body": "<p>I have such code which works well:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nchar x[11]= \"ABCDEFGHIJ\";\nchar y[11];\n\nstruct F {\n    char operator () (char c) const \n    { return c+1; }\n};\n\nint main()\n{\n    std::transform(x, x+10, y, F());\n    y[10] = 0; std::cout &lt;&lt;y &lt;&lt;std::endl;\n}\n</code></pre>\n<p>But if I change it to this style:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nchar x[11]= \"ABCDEFGHIJ\";\nchar y[11];\n\nint main()\n{\n    struct F {\n        char operator () (char c) const \n        { return c+1; }\n    };\n    std::transform(x, x+10, y, F());\n    y[10] = 0; std::cout &lt;&lt;y &lt;&lt;std::endl;\n}\n</code></pre>\n<p>It will not compile, saying:</p>\n<blockquote>\n<p id=\"so_4569928_4569928_0\">error: no matching function for call to \u2018transform(char [11], char*, char [11], main()::F)\u2019</p>\n</blockquote>\n<p>What's wrong?</p>\n<p>gcc version is 4.4, which does not recognize lambda expressions.</p>\n", "AcceptedAnswerId": "4569975", "Title": "Why code using local struct as parameter for STL function does not compile in g++?", "CreationDate": "2010-12-31T11:53:14.820", "Id": "4569928", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-12-31T12:10:45.137", "LastEditorUserId": "165520", "LastActivityDate": "2010-12-31T12:16:26.930", "Score": "11", "OwnerUserId": "358242", "Tags": "<c++><templates><stl><g++><c++11>", "AnswerCount": "2"}, "4569943": {"Id": "4569943", "PostTypeId": "2", "Body": "<p>g++ 4.5.1 <a href=\"http://ideone.com/z1GhE\" rel=\"nofollow\">compiles your code</a> (with <code>-std=c++0x</code> option). </p>\n<p>Your second code sample is ill-formed in C++03<sup>1</sup> but valid in C++0x</p>\n<p><code>std::transform</code> is</p>\n<pre><code>template &lt; class InputIterator, class OutputIterator, class UnaryOperator &gt;\n  OutputIterator transform ( InputIterator first1, InputIterator last1,\n                             OutputIterator result, UnaryOperator op );\n</code></pre>\n<p>However g++ 4.4 <a href=\"http://wiki.apache.org/stdcxx/C++0xCompilerSupport\" rel=\"nofollow\">doesn't support local types as template arguments</a> (even with -<code>std=c++0x</code> option] so you get an error.</p>\n<p><sub>1 : A local type, a type with no linkage, an unnamed type or a type compounded from any of these types shall not be used as a template-argument for a template type-parameter. (ISO C++03 \u00a714.3.1.2)</sub> </p>\n", "LastEditorUserId": "165520", "LastActivityDate": "2010-12-31T12:00:59.293", "Score": "4", "CreationDate": "2010-12-31T11:55:28.513", "ParentId": "4569928", "CommentCount": "1", "OwnerUserId": "165520", "LastEditDate": "2010-12-31T12:00:59.293"}, "4569975": {"Id": "4569975", "PostTypeId": "2", "Body": "<p>In C++-98/03 the second code is not valid, since F is a local type; in facts, at \u00a714.3.1.2 it's stated that</p>\n<blockquote>\n<p id=\"so_4569928_4569975_0\">A local type, a type with no linkage, an unnamed type or a type compounded from any of these types shall not be used as a template-argument for a template type-parameter.</p>\n<p id=\"so_4569928_4569975_1\">[Example:</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; class X { /* ... */ };\nvoid f()\n{\n    struct S { /* ... */ };\n    X&lt;S&gt; x3;         // error: local type used as template-argument\n    X&lt;S*&gt; x4;        // error: pointer to local type used as template-argument\n}\n</code></pre>\n<blockquote>\n<p id=\"so_4569928_4569975_2\">\u2014end example] [Note: a template type argument may be an incomplete type (3.9). ]</p>\n</blockquote>\n<p>In C++-0x this limitation is removed; in the same section, the new standard draft (N3126) explicitly shows this in the example:</p>\n<blockquote>\n<p id=\"so_4569928_4569975_3\">[ Example:</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; class X { };\ntemplate &lt;class T&gt; void f(T t) { }\nstruct { } unnamed_obj;\n\nvoid f() {\n    struct A { };\n    enum { e1 };\n    typedef struct { } B;\n    B b;\n    X&lt;A&gt; x1;             // OK\n    X&lt;A*&gt; x2;            // OK\n    X&lt;B&gt; x3;             // OK\n    f(e1);               // OK\n    f(unnamed_obj);      // OK\n    f(b);                // OK\n}\n</code></pre>\n<blockquote>\n<p id=\"so_4569928_4569975_4\">\u2014 end example ] [ Note: a template type argument may be an incomplete type (3.9). \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "214671", "LastActivityDate": "2010-12-31T12:16:26.930", "Score": "10", "CreationDate": "2010-12-31T12:01:28.420", "ParentId": "4569928", "CommentCount": "6", "OwnerUserId": "214671", "LastEditDate": "2010-12-31T12:16:26.930"}});