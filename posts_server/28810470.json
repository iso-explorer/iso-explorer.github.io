post_cb({"28817538": {"ParentId": "28810470", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>aswrapper</h2>\n<p>N4140 [expr.static.cast]/2:</p>\n<blockquote>\n<p id=\"so_28810470_28817538_0\">An lvalue of type \u201c<em>cv1</em> <code>B</code>,\u201d where <code>B</code> is a class type, can be cast to type \u201creference to <em>cv2</em> <code>D</code>,\u201d where <code>D</code> is a class derived (Clause 10) from <code>B</code>, if a valid standard conversion from \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists (4.10), <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code> is neither a virtual base class of <code>D</code> nor a base class of a virtual base class of <code>D</code>. The result has type \u201c<em>cv2</em> <code>D</code>.\u201d An xvalue of type \u201c<em>cv1</em> <code>B</code>\u201d may be cast to type \u201crvalue reference to <em>cv2</em> <code>D</code>\u201d with the same constraints as for an lvalue of type \u201c<em>cv1</em> <code>B</code>.\u201d If the object of type \u201c<em>cv1</em> <code>B</code>\u201d is actually a subobject of an object of type <code>D</code>, the result refers to the enclosing object of type <code>D</code>. Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>So your function <code>aswrapper</code> has defined behavior only if the <code>T&amp;</code> passed to it actually refers to a <code>T</code> base object of a <code>Wrapper&lt;T&gt;</code>. Both calls in the example program convert a <code>Base&amp;</code> to <code>Wrapper&lt;Base&gt;&amp;</code>, but neither argument is actually a base object of a <code>Wrapper&lt;Base&gt;&amp;</code>, so the resulting behavior is undefined.</p>\n<h2>asT</h2>\n<p>[expr.reinterpret.cast]:</p>\n<blockquote>\n<p id=\"so_28810470_28817538_1\">...</p>\n<p id=\"so_28810470_28817538_2\">7 An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of object pointer type is converted to the object pointer type \u201cpointer to <em>cv</em> <code>T</code>\u201d, the result is <code>static_cast&lt;cv T*&gt;(static_cast&lt;cv void*&gt;(v))</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value.</p>\n<p id=\"so_28810470_28817538_3\">...</p>\n<p id=\"so_28810470_28817538_4\">11 A glvalue expression of type <code>T1</code> can be cast to the type \u201creference to <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>. The result refers\n  to the same object as the source glvalue, but with the specified type. [ Note: That is, for lvalues, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in <code>&amp;</code> and <code>*</code> operators (and similarly for <code>reinterpret_cast&lt;T&amp;&amp;&gt;(x)</code>). \u2014end note ] No temporary is created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.</p>\n</blockquote>\n<p>so <code>asT&lt;T&gt;(WrapperT&amp; foo)</code> is equivalent to <code>*reinterpret_cast&lt;T*&gt;(&amp;foo)</code> which is equivalent to <code>*static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;foo))</code>. A pointer to <code>Wrapper&lt;Base&gt;</code> can of course be cast to <code>void*</code> per [expr.static.cast]/4:</p>\n<blockquote>\n<p id=\"so_28810470_28817538_5\">An expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of such an explicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion. The expression <code>e</code> is used as a glvalue if and only if the initialization uses it as a glvalue.</p>\n</blockquote>\n<p>since any pointer type implicitly converts to <code>void*</code> per [conv.ptr]/2:</p>\n<blockquote>\n<p id=\"so_28810470_28817538_6\">A prvalue of type \u201cpointer to <em>cv</em> <code>T</code>,\u201d where <code>T</code> is an object type, can be converted to a prvalue of type \u201cpointer to <em>cv</em> <code>void</code>\u201d. The result of converting a non-null pointer value of a pointer to object type to a \u201cpointer to\n  <em>cv</em> <code>void</code>\u201d represents the address of the same byte in memory as the original pointer value. The null pointer value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>That <code>void*</code> can be converted to any object pointer type via [expr.static.cast]/13:</p>\n<blockquote>\n<p id=\"so_28810470_28817538_7\">A prvalue of type \u201cpointer to <em>cv1</em> <code>void</code>\u201d can be converted to a prvalue of type \u201cpointer to *cv*2 <code>T</code>,\u201d where <code>T</code> is an object type and <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>. The null pointer\n  value is converted to the null pointer value of the destination type. If the original pointer value represents the address <code>A</code> of a byte in memory and <code>A</code> satisfies the alignment requirement of <code>T</code>, then the resulting pointer\n  value represents the same address as the original pointer value, that is, <code>A</code>. The result of any other such pointer conversion is unspecified. A value of type pointer to object converted to \u201cpointer to <em>cv</em> <code>void</code>\u201d and back, possibly with different cv-qualification, shall have its original value.</p>\n</blockquote>\n<p>Given the above <code>asT</code> is well-formed - which you knew already since the compiler didn't diagnose it. However, the two calls in the example program have unspecified behavior since the alignment of <code>Wrapper&lt;Base&gt;</code> may not satisfy the alignment requirement of <code>Derived1</code> or <code>Derived2</code>. Even if the alignment requirement <em>was</em> satisfied, the calls to <code>exec</code> most likely fall afoul of the strict aliasing restrictions in 3.10/10 since you are treating what is presumably the object representation of a <code>Wrapper&lt;Base&gt;</code> as if it were a <code>Derived</code>.</p>\n<p>Written with <code>reinterpret_cast</code> as it is, <code>asT&lt;Base&gt;(Wrapper&lt;Base&gt;&amp;)</code> even has undefined behavior. Certainly the alignment requirement is satisfied since <code>Wrapper&lt;Base&gt;</code> derives from <code>Base</code>, but actually using the returned glvalue to access memory only has defined behavior if the address of a <code>Wrapper&lt;Base&gt;</code> is the same as the address of its <code>Base</code> subobject. This would be the case if <code>Wrapper&lt;Base&gt;</code> were standard-layout, but otherwise object layouts are unspecified.</p>\n<h2>Summary</h2>\n<p>The program has several occurrences of undefined behavior. The appearance of working correctly is an artifact of the object layouts chosen by the implementation.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2015-03-02T19:39:04.383", "Id": "28817538", "Score": "2", "CreationDate": "2015-03-02T19:06:50.320", "LastActivityDate": "2015-03-02T19:39:04.383"}, "28810470": {"CommentCount": "5", "ViewCount": "307", "CreationDate": "2015-03-02T13:02:19.837", "LastActivityDate": "2015-03-02T19:39:04.383", "Title": "Simulating covariance and contravariance in templates with polymorphic parameters using reinterpret_cast and static_cast?", "AcceptedAnswerId": "28817538", "PostTypeId": "1", "Id": "28810470", "Score": "1", "Body": "<p>Let's say I have a simple polymorphic inheritance:</p>\n<pre><code>struct Base\n{\n    virtual void exec() { std::cout &lt;&lt; \"base\" &lt;&lt; std::endl; }\n    virtual ~Base() { }\n};\n\nstruct Derived1 : public Base\n{\n    void exec() override { std::cout &lt;&lt; \"derived1\" &lt;&lt;std::endl; }\n};\n\nstruct Derived2 : public Base\n{\n    void exec() override { std::cout &lt;&lt; \"derived2\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>And I also have a template <code>Wrapper</code> class that stores some generic data:</p>\n<pre><code>template&lt;typename T&gt; struct Wrapper : public T\n{\n    bool b{true};     \n};\n</code></pre>\n<p>Can I safely convert from <code>Wrapper&lt;Derived1&gt;</code> to <code>Base</code> and from <code>Base</code> to <code>Wrapper&lt;Derived1&gt;</code> using the following casts?</p>\n<pre><code>template&lt;typename T&gt; auto&amp; asWrapper(T&amp; mX) \n{ \n    return static_cast&lt;Wrapper&lt;T&gt;&amp;&gt;(mX); \n}\n\ntemplate&lt;typename T, typename TWrapper&gt; auto&amp; asT(TWrapper&amp; mX) \n{ \n    return reinterpret_cast&lt;T&amp;&gt;(mX); \n}\n</code></pre>\n<p>Example that seems to work:</p>\n<pre><code>int main()\n{\n    auto d1 = std::make_unique&lt;Wrapper&lt;Derived1&gt;&gt;();\n    auto d2 = std::make_unique&lt;Wrapper&lt;Derived2&gt;&gt;();\n\n    Base* bd1 = d1.get();\n    Base* bd2 = d2.get();\n\n    bd1-&gt;exec();\n    bd2-&gt;exec();\n\n    auto&amp; bl1 = asWrapper(*bd1);\n    auto&amp; bl2 = asWrapper(*bd2);\n\n    std::cout &lt;&lt; bl1.b &lt;&lt; \" \" &lt;&lt; bl2.b &lt;&lt; std::endl;\n    bl1.b = false;\n    std::cout &lt;&lt; bl1.b &lt;&lt; \" \" &lt;&lt; bl2.b &lt;&lt; std::endl;\n    bl2.b = false;\n    std::cout &lt;&lt; bl1.b &lt;&lt; \" \" &lt;&lt; bl2.b &lt;&lt; std::endl;\n\n    asT&lt;Derived1&gt;(bl1).exec();\n    asT&lt;Derived2&gt;(bl2).exec();\n\n    return 0;\n}\n</code></pre>\n<p>Executable example: <a href=\"http://ideone.com/MRy9Hy\" rel=\"nofollow\">http://ideone.com/MRy9Hy</a></p>\n<hr>\n<p>It seems to work, but I'm not convinced of the safety of this approach. Is it standard-compliant? Could it cause undefined behavior?</p>\n</hr>", "Tags": "<c++><templates><polymorphism><c++14><reinterpret-cast>", "OwnerUserId": "598696", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28810470_28817538_7": {"section_id": 6039, "quality": 0.9178082191780822, "length": 67}, "so_28810470_28817538_5": {"section_id": 6030, "quality": 0.9444444444444444, "length": 34}, "so_28810470_28817538_0": {"section_id": 6028, "quality": 0.8450704225352113, "length": 60}, "so_28810470_28817538_2": {"section_id": 6046, "quality": 0.9565217391304348, "length": 44}, "so_28810470_28817538_4": {"section_id": 6050, "quality": 0.8113207547169812, "length": 43}, "so_28810470_28817538_6": {"section_id": 40, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_28810470_28817538_7": {"section_id": 5807, "quality": 0.5616438356164384, "length": 41}, "so_28810470_28817538_5": {"section_id": 5798, "quality": 0.9444444444444444, "length": 34}, "so_28810470_28817538_0": {"section_id": 5796, "quality": 0.8309859154929577, "length": 59}, "so_28810470_28817538_4": {"section_id": 5818, "quality": 0.6037735849056604, "length": 32}, "so_28810470_28817538_2": {"section_id": 5814, "quality": 0.8695652173913043, "length": 40}, "so_28810470_28817538_6": {"section_id": 37, "quality": 0.6341463414634146, "length": 26}}, "n4659": {"so_28810470_28817538_7": {"section_id": 7538, "quality": 0.5068493150684932, "length": 37}, "so_28810470_28817538_0": {"section_id": 7527, "quality": 0.704225352112676, "length": 50}, "so_28810470_28817538_2": {"section_id": 7545, "quality": 0.9347826086956522, "length": 43}, "so_28810470_28817538_4": {"section_id": 7549, "quality": 0.8113207547169812, "length": 43}, "so_28810470_28817538_6": {"section_id": 43, "quality": 0.5365853658536586, "length": 22}}}});