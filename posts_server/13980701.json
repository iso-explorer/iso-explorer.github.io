post_cb({"13980701": {"ViewCount": "186", "Body": "<p>I'd like to calculate the amount of memory in bytes that an object uses. Given</p>\n<pre><code>struct A\n{\n    float data[16];\n    int index;\n};\n\nstruct B\n{\n    A a;\n};\n</code></pre>\n<p>Is the following the correct way to do this?</p>\n<pre><code>template &lt;class Type&gt;\nsize_t footprint();\n\ntemplate &lt;&gt;\nsize_t footprint&lt;A&gt;()\n{\n    return sizeof(float) * 16 + sizeof(int);\n}\n\ntemplate &lt;&gt;\nsize_t footprint&lt;B&gt;()\n{\n    return footprint&lt;A&gt;();\n}\n</code></pre>\n<p>I'm not sure about footprint() since I've heard that compilers may add extra information just to store member variables, and I'm not sure about footprint() since it refers to a class object. Does that require some memory as well?</p>\n<p>EDIT: Okay, say the situation changed such that we're not using a static array but an actual pointer:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct A\n{\n    A(int size_)\n    {\n        data = new float[size_];\n        size = size_;\n    }\n\n    ~A()\n    {\n        delete [] data;\n    }\n\n    float* data;\n    int size;\n};\n\nstruct B\n{\n    B() : a(16) {}\n\n    A a;\n};\n\nsize_t footprint(const A&amp; a)\n{\n    return sizeof(float) * a.size + sizeof(int);\n}\n\nsize_t footprint(const B&amp; b)\n{\n    return footprint(b.a);\n}\n\nint main()\n{\n    A a(16);\n    B b;\n\n    cout &lt;&lt; \"sizeof(A) = \" &lt;&lt; sizeof(A) &lt;&lt; endl;\n    cout &lt;&lt; \"sizeof(B) = \" &lt;&lt; sizeof(B) &lt;&lt; endl;\n    cout &lt;&lt; \"footprint(a) = \" &lt;&lt; footprint(a) &lt;&lt; endl;\n    cout &lt;&lt; \"footprint(b) = \" &lt;&lt; footprint(b) &lt;&lt; endl;\n}\n</code></pre>\n<p>Here you would need to actually have a special sizeof function (here called footprint) right?</p>\n", "AcceptedAnswerId": "13980863", "Title": "How do I calculate the amount of memory a class object uses in C++?", "CreationDate": "2012-12-20T21:25:33.727", "Id": "13980701", "CommentCount": "8", "LastEditDate": "2012-12-20T21:36:11.737", "PostTypeId": "1", "LastEditorUserId": "129963", "LastActivityDate": "2012-12-21T09:24:19.663", "Score": "-1", "OwnerUserId": "129963", "Tags": "<c++>", "AnswerCount": "7"}, "13980863": {"Id": "13980863", "PostTypeId": "2", "Body": "<p>The correct way to do this is with <code>sizeof(A)</code> or <code>sizeof(B)</code>. Adding up the sizes of the members is not correct because the compiler is free to put in extra space, called padding, to properly align things. <code>sizeof</code> accounts for this padding.</p>\n<p>You also expressed concerns over your array decaying into a pointer. This is not the case with <code>sizeof</code>. <code>sizeof(an array)</code> will give the total number of bytes that array takes up, provided  it is still in array form and hasn't decayed into a pointer. The fact of the matter is that the standard explicitly disallows this decay to happen in <code>sizeof</code>, so you're safe there:</p>\n<p>C++11 N3485 \u00a7 5.3.3/4 [emphasis mine]:</p>\n<blockquote>\n<p id=\"so_13980701_13980863_0\">The lvalue-to-rvalue (4.1), <strong>array-to-pointer</strong> (4.2), and function-to-pointer (4.3) standard conversions are not\n  applied to the operand of sizeof.</p>\n</blockquote>\n<p><code>sizeof(A) == 16 * sizeof(float) + sizeof(int) + sizeof(additional padding)</code></p>\n", "LastEditorUserId": "962089", "LastActivityDate": "2012-12-20T21:46:06.177", "Score": "3", "CreationDate": "2012-12-20T21:36:31.767", "ParentId": "13980701", "CommentCount": "3", "OwnerUserId": "962089", "LastEditDate": "2012-12-20T21:46:06.177"}, "13980967": {"Id": "13980967", "PostTypeId": "2", "Body": "<p>In a dynamic allocation situation, it gets MUCH more complex. The best solution to actually account for your class's usage is to implement your own operator::new(size_t size) [and perhaps call malloc to allocat size number of bytes], and then account the size - however, that will not account for the overhead of the allocator itself, which will be anything from around 12 bytes upwards per call to new. And the allocator may also round up the actual size that is being allocated. </p>\n", "LastActivityDate": "2012-12-20T21:43:02.767", "CommentCount": "3", "CreationDate": "2012-12-20T21:43:02.767", "ParentId": "13980701", "Score": "1", "OwnerUserId": "1919155"}, "13981629": {"Id": "13981629", "PostTypeId": "2", "Body": "<p>I have not seen one issue mentioned yet.  When you do</p>\n<pre><code>float * data = new float[size_];\ndelete [] data;\n</code></pre>\n<p>then sizeof(float) * size_ is the amount of memory allocated.  But when you do</p>\n<pre><code>std::string * data = new std::string[size_];\ndelete [] data;\n</code></pre>\n<p>when the delete happens it needs to know what size_ was during the new() so it knows how many times to call the std::string destructor.  C++ can sometimes add a few bytes to an allocation to keep track of how many array members you allocated.</p>\n", "LastActivityDate": "2012-12-20T22:33:15.617", "CommentCount": "0", "CreationDate": "2012-12-20T22:33:15.617", "ParentId": "13980701", "Score": "1", "OwnerUserId": "1862101"}, "bq_ids": {"n4140": {"so_13980701_13980863_0": {"length": 7, "quality": 0.875, "section_id": 6079}}, "n3337": {"so_13980701_13980863_0": {"length": 7, "quality": 0.875, "section_id": 5847}}, "n4659": {"so_13980701_13980863_0": {"length": 7, "quality": 0.875, "section_id": 7575}}}, "13981526": {"Id": "13981526", "PostTypeId": "2", "Body": "<p>As an addition to the previous answers, compilers provide you with ways to control how padding behaves (and thus you can have an impact on sizeof(A), if memory footprint is especially important for you at that point of your program, if you want to send your structure over a network, or whatever).</p>\n<p>You can have a look at <code>#pragma pack</code> statements for achieving such a goal.</p>\n", "LastActivityDate": "2012-12-20T22:23:13.210", "CommentCount": "0", "CreationDate": "2012-12-20T22:23:13.210", "ParentId": "13980701", "Score": "1", "OwnerUserId": "715286"}, "13987378": {"Id": "13987378", "PostTypeId": "2", "Body": "<p>In light of the comments above, I think another answer is required. </p>\n<p>I can think of a few pretty good solutions to limit the amount of memory that the cache uses:\n1. Start of day, allocate X KB of memory (whatever your cache is \"allowed\" to use). Cut this up into sections as they are needed. When full, take the oldest and reuse it (may need more than one if they are not all the same size). </p>\n<p>You need some way to mark something \"recently used\" or \"aged\", so that you can throw away things that are the oldest. Possibly via the use of a <a href=\"http://en.wikipedia.org/wiki/Splay_tree\" rel=\"nofollow\">Splay Tree</a> which automatically re-orders when you fetch something so the most recent objects are at the top of the tree.</p>\n<ol>\n<li><p>Similar to the above, but use fixed number of fixed size blocks of data - say for example 16 or 32 (or 256, or 500 or whatever makes most sense for what size your typical cache entry is). At start of day, put all the cache-entries in a \"free\" container (e.g. a list). When you need a new cache entry, fetch the top of the free list. If the list is empty, find the oldest one and reuse that for the cache. </p></li>\n<li><p>If your objects stored are different types and sizes, you may find that making your own heap, and using a operator::new() for your class is a better option (obviously also a corresponding operator::delete()). There are various solutions for how to make your own heap (free storage as it is sometimes called in C++). I would be inclined to have something that has rounds to a limited set of sizes, that way you don't get such bad fragmentation. </p></li>\n</ol>\n", "LastActivityDate": "2012-12-21T09:24:19.663", "CommentCount": "0", "CreationDate": "2012-12-21T09:24:19.663", "ParentId": "13980701", "Score": "1", "OwnerUserId": "1919155"}, "13980839": {"Id": "13980839", "PostTypeId": "2", "Body": "<p>Since the example has a statically allocated array then using the sizeof(A) will give you the correct size. However sometimes the size will be different than you expect due to bit-padding.</p>\n<p>However if you have dynamically allocated array you need to do something like this:</p>\n<pre><code>lengthOfArray*sizeof(arrayElement);\n</code></pre>\n", "LastActivityDate": "2012-12-20T21:34:29.320", "CommentCount": "0", "CreationDate": "2012-12-20T21:34:29.320", "ParentId": "13980701", "Score": "1", "OwnerUserId": "1457647"}, "13980887": {"Id": "13980887", "PostTypeId": "2", "Body": "<p>Not only is <code>return sizeof(float) * 16 + sizeof(int);</code> quite cumbersome for more complex object, but it may also be incorrect. The C language specification allows the compiler to \"pad\" structures. Say for example we have</p>\n<pre><code>class X {\npublic:\n    int i;\n    char c;\n    double d;\n};\n</code></pre>\n<p>Your method for sizing the structure would say that it takes up 4 + 1 + 8 (or some such), but the actual <code>sizeof(X)</code> would give 4 + 4 + 8. With extreme mixing of small and large data types, we could easily see an error of 50-75%. [The exact layout of members is dependant on the compiler, processor architecture, compiler switches and so on]. </p>\n", "LastActivityDate": "2012-12-20T21:38:52.737", "CommentCount": "0", "CreationDate": "2012-12-20T21:38:52.737", "ParentId": "13980701", "Score": "1", "OwnerUserId": "1919155"}});