post_cb({"34318661": {"ViewCount": "566", "Body": "<p>I am trying to write non-intrusive boost::serialization routines for a nested class with a private member. Unfortunately, I fail to convince g++ that the serialization routine is a friend of the inner class. It seems g++ requires a forward declaration of the serialization routine, which in turn would need a forward declaration of the nested class, which in turn cannot be done in C++. Am I missing something or is this just not possible? clang++ in contrast does not need a forward declaration and has no problems with the code below. The following code illustrates the problem:</p>\n<pre><code>#include &lt;boost/archive/text_oarchive.hpp&gt;\n\nclass Outer;\n//class Outer::Inner;   // Not valid C++\n\nnamespace boost\n{\n    namespace serialization\n    {\n        template &lt;class Archive&gt;\n        void serialize(Archive &amp;ar, Outer&amp; outer, const unsigned int version);\n        //template &lt;class Archive&gt;\n        //void serialize(Archive &amp;ar, Outer::Inner&amp; inner, const unsigned int version); // Cannot be done since forward declaration of nested class not possible.\n    }\n}\n\nclass Outer\n{\n    class Inner\n    {\n        int member_{42};\n\n        template &lt;class Archive&gt;\n        friend void boost::serialization::serialize(Archive &amp;ar, Outer::Inner &amp;inner, const unsigned int version);  // This does not work with gcc since the compiler seems to expect a forward declaration, which cannot be done (see above).\n    };\n\n    Inner inner_;\n\n    template &lt;class Archive&gt;\n    friend void boost::serialization::serialize(Archive &amp;ar, Outer &amp;outer, const unsigned int version);\n    template &lt;class Archive&gt;\n    friend void boost::serialization::serialize(Archive &amp;ar, Inner &amp;inner, const unsigned int version);\n};\n\nnamespace boost\n{\n    namespace serialization\n    {\n        template &lt;class Archive&gt;\n        void serialize(Archive &amp;ar, Outer&amp; outer, const unsigned int version)\n        {\n            ar &amp; outer.inner_;\n        }\n\n        template &lt;class Archive&gt;\n        void serialize(Archive &amp;ar, Outer::Inner&amp; inner, const unsigned int version)\n        {\n            ar &amp; inner.member_;\n        }\n    }\n}\n\nint main()\n{\n    Outer outer;\n\n    boost::archive::text_oarchive(std::cout) &lt;&lt; outer;\n}\n</code></pre>\n<p>To be compiled with <code>-std=c++11</code> and <code>-lboost_serialization</code>. Compilation with g++ complains that <code>member_</code> is private even though a friend declaration is present. Is g++ right in refusing the friend declaration in the inner class?</p>\n", "AcceptedAnswerId": "34319363", "Title": "Friend declaration in nested classes requiring forward declaration", "CreationDate": "2015-12-16T17:42:28.213", "Id": "34318661", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-12-17T06:16:04.233", "Score": "4", "OwnerUserId": "1225999", "Tags": "<c++><templates><nested><boost-serialization><friend-function>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34318661_34319363_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 3208}}, "n3337": {"so_34318661_34319363_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 3082}}, "n4659": {"so_34318661_34319363_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 3965}}}, "34319363": {"Id": "34319363", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/dcl.meaning#1\" rel=\"nofollow\">[dcl.meaning]/1</a>:</p>\n<blockquote>\n<p id=\"so_34318661_34319363_0\"><strong>When the <em>declarator-id</em> is qualified, the declaration shall refer to\n  a previously declared member of the class or namespace to which the\n  qualifier refers</strong> (or, in the case of a namespace, of an element of the\n  inline namespace set of that namespace ([namespace.def])) or to a\n  specialization thereof; [...].</p>\n</blockquote>\n<p>In other words, a declaration (including a friend declaration) with a qualified name  must refer to something previously declared. So GCC is sort of correct in rejecting the code, but it should have rejected it earlier, and the diagnostic is rather confusing. (Note that it will reject it on the spot if the thing being friended is a previously-undeclared plain function and not a template.)</p>\n<p>Also, requiring friend access sort of defeats the point of non-intrusive serialization in the first place (which is to allow you to serialize a class without changing its definition).</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-12-17T06:16:04.233", "Score": "2", "CreationDate": "2015-12-16T18:21:11.200", "ParentId": "34318661", "CommentCount": "3", "LastEditDate": "2015-12-17T06:16:04.233", "OwnerUserId": "2756719"}});