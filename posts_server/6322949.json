post_cb({"6322949": {"CommentCount": "1", "AcceptedAnswerId": "6322985", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2011-06-12T16:02:19.580", "LastActivityDate": "2017-11-23T12:53:09.597", "LastEditDate": "2017-11-23T12:53:09.597", "ViewCount": "14679", "FavoriteCount": "6", "Title": "Downcasting using the 'static_cast' in C++", "Id": "6322949", "Score": "11", "Body": "<p>Consider:</p>\n<pre><code>class base\n{\n    base();\n    virtual void func();\n}\n\nclass derived : public base\n{\n    derived();\n    void func();\n    void func_d();\n    int a;\n}\n\n\nmain\n{\n    base *b = new base();\n    sizeof(*b); // Gives 4.\n    derived * d = static_cast&lt;derived*&gt;(b);\n    sizeof(*d); // Gives 8- means whole derived obj size..why?\n    d-&gt;func_d();\n}\n</code></pre>\n<p>In the above code I did downcasting of a base pointer which points to base object to derived class pointer. I am wondering how the derived pointer has the whole derived class object. I can call the derived class function (declared in derived class only). I did not get the concept here.</p>\n", "Tags": "<c++>", "OwnerUserId": "784688", "AnswerCount": "3"}, "6322956": {"ParentId": "6322949", "CommentCount": "2", "Body": "<p><code>sizeof</code> exists at compile-time. It neither knows nor cares that at run-time, your base object doesn't point to a <code>derived</code>. You are attempting to influence compile-time behaviour with a run-time variable, which is fundamentally impossible.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6322956", "Score": "6", "CreationDate": "2011-06-12T16:03:45.280", "LastActivityDate": "2011-06-12T16:03:45.280"}, "6323081": {"ParentId": "6322949", "PostTypeId": "2", "CommentCount": "22", "Body": "<p>The only cast that does runtime checking is <code>dynamic_cast&lt;&gt;()</code>. If there is any possibility that a cast will not work at runtime then this cast should be used.</p>\n<p>Thus casting from leaf-&gt;root (up casting) <code>static_cast&lt;&gt;()</code> works fine.<br>\nBut casting from root-&gt;leaf (down casting) is dangerous and (in my opinion) should always be done with <code>dynamic_cast&lt;&gt;()</code> as there will be dependencies on run-time information. The cost is slight, but always worth paying for safety.</br></p>\n", "OwnerUserId": "14065", "LastEditorUserId": "63550", "LastEditDate": "2017-11-23T12:50:52.520", "Id": "6323081", "Score": "8", "CreationDate": "2011-06-12T16:29:03.000", "LastActivityDate": "2017-11-23T12:50:52.520"}, "bq_ids": {"n4140": {"so_6322949_6322985_0": {"section_id": 6037, "quality": 0.8805970149253731, "length": 59}}, "n3337": {"so_6322949_6322985_0": {"section_id": 5805, "quality": 0.9104477611940298, "length": 61}}, "n4659": {"so_6322949_6322985_0": {"section_id": 7536, "quality": 0.7761194029850746, "length": 52}}}, "6322985": {"ParentId": "6322949", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Using <code>static_cast</code> to cast an object to a type it doesn't actually have yields <em>undefined behavior</em>.  The symptoms of UB vary widely.  There's nothing that says UB can't allow the derived member function to be called successfully (but there's nothing that guarantees that it will, so don't count on it).</p>\n<p>Here is the rule for downcasting using <code>static_cast</code>, found in section 5.2.9 (<code>[expr.static.cast]</code>) of the C++ standard (C++0x wording):</p>\n<blockquote>\n<p id=\"so_6322949_6322985_0\">A prvalue of type \"pointer to <em>cv1</em> <code>B</code>\", where <code>B</code> is a class type, can be converted to a prvalue of type \"pointer to <em>cv2</em> <code>D</code>\", where <code>D</code> is a class derived from <code>B</code>, if a valid standard conversion from \"pointer to <code>D</code>\" to \"pointer to <code>B</code>\" exists, <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code>\n  is neither a virtual base class of <code>D</code> nor a base class of a virtual base class of <code>D</code>. The null pointer value is converted to the null pointer value of the destination type. If the prvalue of type \"pointer to <em>cv1</em> <code>B</code>\" points\n  to a <code>B</code> that is actually a subobject of an object of type <code>D</code>, the resulting pointer points to the enclosing object\n  of type <code>D</code>. Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-06-12T16:15:02.907", "Id": "6322985", "Score": "16", "CreationDate": "2011-06-12T16:09:17.443", "LastActivityDate": "2011-06-12T16:15:02.907"}});