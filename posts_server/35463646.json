post_cb({"35466496": {"Id": "35466496", "PostTypeId": "2", "Body": "<p>A bit of terminology first: we can argue that you are not so much looking for the aggregate initialization arity but the <em>maximum</em> aggregate initialization arity. E.g. the aptly named <code>A2</code> can be aggregate initialized from 0, 1, and 2 arguments so its maximum arity is 2.</p>\n<p>Let\u2019s turn 'is aggregate initializable from N arguments' into a trait (although with a shorter name):</p>\n<pre><code>struct filler { template&lt;typename type&gt; operator type () const; };\n\ntemplate&lt;typename Arg&gt; void accept(Arg);\n\ntemplate&lt;typename Aggr, std::size_t... Indices,\n         typename = decltype( accept&lt;Aggr&gt;({ (static_cast&lt;void&gt;(Indices), filler {})... }) )&gt;\nvoid aggregate_arity_test(std::index_sequence&lt;Indices...&gt;);\n\ntemplate&lt;typename Aggr, int N, typename Sfinae = void&gt;\nstruct has_aggregate_arity: std::false_type {};\n\ntemplate&lt;typename Aggr, int N&gt;\nstruct has_aggregate_arity&lt;Aggr, N, std::void_t&lt;decltype( aggregate_arity_test&lt;Aggr&gt;(std::make_index_sequence&lt;N&gt;()) )&gt;&gt;\n: std::true_type {};\n</code></pre>\n<p>(We use <code>accept&lt;Aggr&gt;({ args... })</code> because that\u2019s the same as checking for <code>Aggr aggr = { args... };</code>, i.e. copy-list-initialization and what people have in mind when they talk about aggregate initialization. <code>Aggr aggr { args.. };</code> is direct-list-initialization, but you can still check against that if that\u2019s what you care about.)</p>\n<p>Now we can find an arity for which initialization fails in not too many instantiations with iterated doubling (i.e. we will check at arity 0, then arity 1, arity 2, arity 4, arity 8, ..., arity 2<sup>i</sup>):</p>\n<pre><code>template&lt;typename Aggr, int Acc = 0&gt;\nstruct find_failing_init_fast: std::conditional_t&lt;\n    has_aggregate_arity&lt;Aggr, Acc&gt;::value,\n    find_failing_init_fast&lt;Aggr, Acc == 0 ? 1 : Acc * 2&gt;,\n    std::integral_constant&lt;int, Acc&gt;\n&gt; {};\n</code></pre>\n<p>Now it\u2019s a matter of a binary search inside <code>[0, N)</code> where <code>N</code> is an arity for which initialization fails:</p>\n<pre><code>// binary search invariant:\n//   has_aggregate_arity&lt;Aggr, Low&gt; &amp;&amp; !has_aggregate_arity&lt;Aggr, High&gt;\ntemplate&lt;typename Aggr, int Low, int High&gt;\nstruct max_aggregate_arity_impl\n: std::conditional_t&lt;\n    has_aggregate_arity&lt;Aggr, midpoint(Low, High)&gt;::value\n      &amp;&amp; !has_aggregate_arity&lt;Aggr, midpoint(Low, High) + 1&gt;::value,\n    std::integral_constant&lt;int, midpoint(Low, High)&gt;,\n    std::conditional&lt;\n        has_aggregate_arity&lt;Aggr, midpoint(Low, High)&gt;::value,\n        max_aggregate_arity_impl&lt;Aggr, midpoint(Low, High), High&gt;,\n        max_aggregate_arity_impl&lt;Aggr, Low, midpoint(Low, High)&gt;\n    &gt;\n&gt;::type {};\n\n// special case that 'errors' out (important for SFINAE purposes)\n// as the invariant obviously cannot be maintained\ntemplate&lt;typename Aggr&gt;\nstruct max_aggregate_arity_impl&lt;Aggr, 0, 0&gt; {};\n\ntemplate&lt;typename Aggr&gt;\nstruct max_aggregate_arity\n: max_aggregate_arity_impl&lt;Aggr, 0, find_failing_init_fast&lt;Aggr&gt;::value&gt; {};\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/462b1e3dfa1898b8\" rel=\"nofollow\">Live On Coliru</a></kbd></p>\n", "LastEditorUserId": "726300", "LastActivityDate": "2016-02-17T20:11:15.643", "Score": "2", "CreationDate": "2016-02-17T19:57:23.070", "ParentId": "35463646", "CommentCount": "2", "OwnerUserId": "726300", "LastEditDate": "2016-02-17T20:11:15.643"}, "bq_ids": {"n4140": {"so_35463646_35465666_1": {"length": 10, "quality": 0.625, "section_id": 3303}, "so_35463646_35465666_3": {"length": 34, "quality": 0.6415094339622641, "section_id": 3304}}, "n3337": {"so_35463646_35465666_1": {"length": 10, "quality": 0.625, "section_id": 3173}}, "n4659": {"so_35463646_35465666_1": {"length": 9, "quality": 0.5625, "section_id": 4069}, "so_35463646_35465666_3": {"length": 36, "quality": 0.6792452830188679, "section_id": 4070}}}, "35465666": {"Id": "35465666", "PostTypeId": "2", "Body": "<h3>Discussion</h3>\n<p>(The discussion is based on another answer of mine which I will delete now.)</p>\n<p>As in the original question, the following answer checks whether the invocation of the constructor of the aggregate is possible with a given number of arguments. For aggregates, one can base a binary search on this pattern by using the following properties from the standard:</p>\n<blockquote>\n<p id=\"so_35463646_35465666_0\">8.5.1 (6):</p>\n<p id=\"so_35463646_35465666_1\">An initializer-list is <strong>ill-formed if the number of initializer-clauses\n  exceeds the number of members or elements to initialize</strong>. [ Example:\n  char cv[4] = { \u2019a\u2019, \u2019s\u2019, \u2019d\u2019, \u2019f\u2019, 0 }; // error is ill-formed. \u2014 end\n  example ]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_35463646_35465666_2\">8.5.1 (7):</p>\n<p id=\"so_35463646_35465666_3\">If there are <strong>fewer initializer-clauses in the list than there are\n  members in the aggregate, then each member not explicitly initialized\n  shall be initialized from its default member initializer</strong> (9.2) or, if\n  there is no default member initializer, from an empty initializer list\n  (8.5.4). [ Example: struct S { int a; const char* b; int c; int d =\n  b[a]; }; S ss = { 1, \"asdf\" }; initializes ss.a with 1, ss.b with\n  \"asdf\", ss.c with the value of an expression of the form int{} (that\n  is, 0), and ss.d with the value of ss.b[ss.a] (that is, \u2019s\u2019), and in\n  struct X { int i, j, k = 42; }; X a[] = { 1, 2, 3, 4, 5, 6 }; X b[2] =\n  { { 1, 2, 3 }, { 4, 5, 6 } }; a and b have the same value \u2014 end\n  example ]</p>\n</blockquote>\n<p>However, as you already implied by the question title, a binary search will in general not work with non-aggregates, first due to the fact that those are usually not callable with less parameters than necessary, and next due to the fact that non-aggregates can have <code>explicit</code> constructors so that the \"conversion-to-anything\" trick via the struct <code>filler</code> won't work.</p>\n<h3>Implementation</h3>\n<p>First ingredient is an <code>is_callable</code> check from <a href=\"https://stackoverflow.com/a/35349542/2412846\">here</a>:</p>\n<pre><code>template&lt;typename V, typename ... Args&gt;\nstruct is_constructible_impl\n{\n    template&lt;typename C&gt; static constexpr auto test(int) -&gt; decltype(C{std::declval&lt;Args&gt;() ...}, bool{}) { return true; }\n    template&lt;typename&gt; static constexpr auto test(...) { return false; }\n    static constexpr bool value = test&lt;V&gt;(int{});\n    using type = std::integral_constant&lt;bool, value&gt;;\n};\n\ntemplate&lt;typename ... Args&gt;\nusing is_constructible = typename is_callable_impl&lt;Args...&gt;::type;\n</code></pre>\n<p>Note that this one is usable also with a fewer number of parameters than necessary (unlike your check).</p>\n<p>Next a helper function which takes an integer argument and returns whether the aggregate is callable with the corresponding number of constructor arguments:    </p>\n<pre><code>template&lt;typename A, size_t ... I&gt;\nconstexpr auto check_impl(std::index_sequence&lt;I ...&gt;)\n{\n    return is_constructible&lt;A, decltype(I, filler{}) ...&gt;::value;\n}\n\ntemplate&lt;typename A, size_t N&gt;\nconstexpr auto check()\n{\n    return check_impl&lt;A&gt;(std::make_index_sequence&lt;N&gt;{});\n}\n</code></pre>\n<p>And finally the binary search:</p>\n<pre><code>template&lt;typename A, size_t Low, size_t Up, size_t i = Low + (Up - Low)/2&gt;\nstruct binary_search\n   : public std::conditional_t&lt;check&lt;A, i&gt;() &amp;&amp; !check&lt;A,i+1&gt;()\n                           , std::integral_constant&lt;size_t, i&gt;\n                           , std::conditional_t&lt;check&lt;A, i&gt;()\n                                              , binary_search&lt;A, i, Up&gt;\n                                              , binary_search&lt;A, Low, i&gt; &gt;\n                              &gt;\n{};\n</code></pre>\n<p>Use it as</p>\n<pre><code>int main()\n{\n    static_assert(binary_search&lt;A2,0,10&gt;::value==2);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/6826375c5d23fc3c\" rel=\"nofollow noreferrer\"><kbd>Live on Coliru</kbd></a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-18T08:37:35.057", "Score": "2", "CreationDate": "2016-02-17T19:14:32.740", "ParentId": "35463646", "CommentCount": "6", "OwnerUserId": "2412846", "LastEditDate": "2017-05-23T11:50:35.657"}, "35463646": {"ViewCount": "308", "Body": "<p>How to define arity of an aggregate in logarithmic (at least base two) compilation time (strictly speaking, in logarithmic number of instantiations)?</p>\n<p>What I can do currently is to achieve desired in a linear time:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\nstruct filler { template&lt; typename type &gt; operator type (); };\n\ntemplate&lt; typename A, typename index_sequence = std::index_sequence&lt;&gt;, typename = void &gt;\nstruct aggregate_arity\n    : index_sequence\n{\n\n};\n\ntemplate&lt; typename A, std::size_t ...indices &gt;\nstruct aggregate_arity&lt; A, std::index_sequence&lt; indices... &gt;, std::__void_t&lt; decltype(A{(indices, std::declval&lt; filler &gt;())..., std::declval&lt; filler &gt;()}) &gt; &gt;\n    : aggregate_arity&lt; A, std::index_sequence&lt; indices..., sizeof...(indices) &gt; &gt;\n{\n\n};\n\nstruct A0 {};\nstruct A1 { double x; };\nstruct A2 { int i; char c; }; \nstruct C50 { template&lt; typename ...Args, typename = std::enable_if_t&lt; (sizeof...(Args) &lt; 51) &gt; &gt; C50(Args &amp;&amp;...) { ; } };\n\nstatic_assert(aggregate_arity&lt;  A0 &gt;::size() == 0);\nstatic_assert(aggregate_arity&lt;  A1 &gt;::size() == 1);\nstatic_assert(aggregate_arity&lt;  A2 &gt;::size() == 2);\nstatic_assert(aggregate_arity&lt; C50 &gt;::size() == 50);\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9d8231ebd1f9911b\" rel=\"nofollow\">Live example</a>.</p>\n<p>Please correct me if term \"arity\" is poor.</p>\n<p>I think it is possible in principle: firstly one need to double arity trials starting from one until SFINAE failed (surely, in soft manner), then use bisection.</p>\n", "AcceptedAnswerId": "35465666", "Title": "Arity of aggregate in logarithmic time", "CreationDate": "2016-02-17T17:29:21.370", "Id": "35463646", "CommentCount": "3", "LastEditDate": "2016-02-18T06:32:57.993", "PostTypeId": "1", "LastEditorUserId": "1430927", "LastActivityDate": "2016-02-18T08:37:35.057", "Score": "3", "OwnerUserId": "1430927", "Tags": "<c++><c++11><aggregate><c++14><typetraits>", "AnswerCount": "2"}});