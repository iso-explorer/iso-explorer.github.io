post_cb({"41276869": {"CommentCount": "0", "AcceptedAnswerId": "41277125", "PostTypeId": "1", "LastEditorUserId": "6235787", "CreationDate": "2016-12-22T06:19:01.607", "LastActivityDate": "2016-12-22T07:02:32.783", "LastEditDate": "2016-12-22T06:29:50.037", "ViewCount": "283", "FavoriteCount": "1", "Title": "What will happen if I assign negative value to an unsigned char?", "Id": "41276869", "Score": "2", "Body": "<p>In C++ primer it says that \"if we assign an out of range value to an object of unsigned type the result is the remainder of the value modulo the number of values the target type can hold.\"</p>\n<p>It gives the example: </p>\n<pre><code>int main(){\n\n\nunsigned char i = -1;\n// As per the book the value of i is 255 .\n}\n</code></pre>\n<p>Can anybody please explain it to me how this works.  </p>\n", "Tags": "<c><c++11><unsigned>", "OwnerUserId": "6235787", "AnswerCount": "4"}, "41277091": {"ParentId": "41276869", "CommentCount": "4", "Body": "<p>The literal <code>1</code> is of type <code>int</code>. For this explanation, let's assume that <code>sizeof(int) == 4</code> as it most probably is. So then <code>1</code> in binary would look like this:</p>\n<pre><code>00000000 00000000 00000000 00000001 \n</code></pre>\n<p>Now let's apply the unary minus operator to get the <code>-1</code>. We're assuming <em>two's complement</em> is used as it most probably is (look up two's complement for more explanation). We get:</p>\n<pre><code>11111111 11111111 11111111 11111111\n</code></pre>\n<p>Note that in the above numbers the first bit is the sign bit.</p>\n<p>As you try to assign this number to <code>unsigned char</code>, for which holds <code>sizeof(unsigned char) == 1</code>, the value would be truncated to:</p>\n<pre><code>11111111\n</code></pre>\n<p>Now if you convert this to decimal, you'll get <code>255</code>. Here the first bit is not seen as a sign bit, as the type is <code>unsigned</code>.</p>\n", "OwnerUserId": "5212827", "PostTypeId": "2", "Id": "41277091", "Score": "1", "CreationDate": "2016-12-22T06:35:24.213", "LastActivityDate": "2016-12-22T06:35:24.213"}, "41277144": {"ParentId": "41276869", "CommentCount": "0", "Body": "<p>It's equivalent in C to C++, though worded differently:</p>\n<blockquote>\n<p id=\"so_41276869_41277144_0\"><strong>6.3.1.3 Signed and unsigned integers</strong></p>\n<p id=\"so_41276869_41277144_1\">1 When a value with integer type is converted to another integer type other than <strong>_Bool</strong>, if the value can be represented by the new type, it is unchanged.</p>\n<p id=\"so_41276869_41277144_2\">2 Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented by the new type until the value is in the range of the new type.</p>\n<p id=\"so_41276869_41277144_3\">3 Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.</p>\n</blockquote>\n", "OwnerUserId": "3553031", "PostTypeId": "2", "Id": "41277144", "Score": "1", "CreationDate": "2016-12-22T06:39:39.537", "LastActivityDate": "2016-12-22T06:39:39.537"}, "41277125": {"ParentId": "41276869", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_41276869_41277125_0\">the result is the remainder of the value modulo the number of values the target type can hold</p>\n</blockquote>\n<p>Start with \"the number of values the target type can hold\". For <code>unsigned char</code>, what is this? The range is from 0 to 255, inclusive, so there are a total of 256 values that can be represented (or \"held\").</p>\n<p>In general, the number of values that can be represented in a particular unsigned integer representation is given by 2<sup>n</sup>, where <em>n</em> is the number of bits used to store that type.</p>\n<p>An <code>unsigned char</code> is an 8-bit type, so 2<sup>8</sup> == 256, just as we already knew.</p>\n<p>Now, we need to perform a <em>modulo</em> operation. In your case of assigning -1 to <code>unsigned char</code>, you would have <code>-1 MOD 256 == 255</code>.</p>\n<p>In general, the formula is: <strong>x MOD 2<sup>n</sup></strong>, where x is the value you're attempting to assign and <em>n</em> is the bit width of the type to which you are trying to assign.</p>\n<p>More formally, this is laid out in the C++11 language standard (\u00a7 3.9.1/4). It says:</p>\n<blockquote>\n<p id=\"so_41276869_41277125_1\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup>n</sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.<sup>*</sup></p>\n<p id=\"so_41276869_41277125_2\"><sup>*</sup> This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n<p>Perhaps an easier way to think about modulo arithmetic (and the description that you'll most commonly see used) is that overflow and underflow <em>wrap around</em>. You started with -1, which underflowed the range of an <code>unsigned char</code> (which is 0\u2013255), so it wrapped around to the maximum representable value (which is 255).</p>\n", "OwnerUserId": "366904", "LastEditorUserId": "366904", "LastEditDate": "2016-12-22T07:02:32.783", "Id": "41277125", "Score": "3", "CreationDate": "2016-12-22T06:38:22.177", "LastActivityDate": "2016-12-22T07:02:32.783"}, "41276995": {"ParentId": "41276869", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In Stroustrup's words:</p>\n<blockquote>\n<p id=\"so_41276869_41276995_0\">If the destination type is <code>unsigned</code>, the resulting value is simply as many bits from the source as will fit in the destination (high-order bits are thrown away if necessary). More precisely, the result is the least unsigned integer congruent to the source integer modulo 2 to the nth, where n is the number of bits used to represent the unsigned type.</p>\n</blockquote>\n<p>Excerpt from C++ standard N3936:</p>\n<blockquote>\n<p id=\"so_41276869_41276995_1\">For each of the standard <strong>signed</strong> integer types, there exists a corresponding (but different) standard unsigned\n  integer type: \u201c<strong>unsigned char</strong>\u201d, \u201cunsigned short int\u201d, \u201cunsigned int\u201d, \u201cunsigned long int\u201d,\n  and \u201cunsigned long long int\u201d, each of which occupies the same amount of storage and has the same\n  alignment requirements (3.11) as the corresponding signed integer type47; that is, each signed integer type\n  has the <strong>same</strong> object representation as its corresponding unsigned integer type.</p>\n</blockquote>\n", "OwnerUserId": "1465553", "LastEditorUserId": "1465553", "LastEditDate": "2016-12-22T06:38:04.197", "Id": "41276995", "Score": "0", "CreationDate": "2016-12-22T06:28:21.873", "LastActivityDate": "2016-12-22T06:38:04.197"}, "bq_ids": {"n4140": {"so_41276869_41277125_1": {"section_id": 7213, "quality": 0.875, "length": 14}, "so_41276869_41277144_1": {"section_id": 6035, "quality": 0.5294117647058824, "length": 9}, "so_41276869_41276995_0": {"section_id": 31, "quality": 0.5294117647058824, "length": 18}, "so_41276869_41277125_2": {"section_id": 7213, "quality": 0.9642857142857143, "length": 27}, "so_41276869_41276995_1": {"section_id": 7212, "quality": 0.9423076923076923, "length": 49}}, "n3337": {"so_41276869_41277125_1": {"section_id": 6957, "quality": 1.0, "length": 16}, "so_41276869_41277144_1": {"section_id": 5930, "quality": 0.5294117647058824, "length": 9}, "so_41276869_41276995_0": {"section_id": 28, "quality": 0.5294117647058824, "length": 18}, "so_41276869_41277125_2": {"section_id": 6957, "quality": 0.9642857142857143, "length": 27}, "so_41276869_41276995_1": {"section_id": 6956, "quality": 0.9423076923076923, "length": 49}}, "n4659": {"so_41276869_41277125_1": {"section_id": 8722, "quality": 0.875, "length": 14}, "so_41276869_41277144_1": {"section_id": 7534, "quality": 0.5294117647058824, "length": 9}, "so_41276869_41276995_0": {"section_id": 31, "quality": 0.5294117647058824, "length": 18}, "so_41276869_41277125_2": {"section_id": 8722, "quality": 0.9642857142857143, "length": 27}, "so_41276869_41276995_1": {"section_id": 8721, "quality": 0.9423076923076923, "length": 49}}}});