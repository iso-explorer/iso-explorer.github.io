post_cb({"22262444": {"CommentCount": "0", "Body": "<p>I just ran across this issue, with clang++:</p>\n<pre><code>foo.cpp:17:8: error: must use a typedef to declare a conversion to 'void (*(int))()'\n</code></pre>\n<p>and there's a C++11 STL template which covers the identity&lt;T&gt; functionality:</p>\n<pre><code>#include &lt;type_traits&gt;\n\u2026\nstruct foo {\n     void bar( ) const { }\n     operator std::common_type&lt;void(foo::*)( )const&gt;::type( ) { return &amp;foo::bar; }\n};\n</code></pre>\n", "CreationDate": "2014-03-07T23:06:44.987", "ParentId": "6998750", "Id": "22262444", "LastActivityDate": "2014-03-07T23:06:44.987", "PostTypeId": "2", "Score": "1", "OwnerUserId": "2903943"}, "6999445": {"CommentCount": "3", "Body": "<p>Answering the \"Are there cases where a typedef is absolutely necessary?\" from the question title, here is one example of where a typedef is needed:</p>\n<pre><code>f(unsigned char());   // compiler error!\ntypedef unsigned char Byte;\nf(Byte());            // fine!\n</code></pre>\n<p>See the results here: <a href=\"http://ideone.com/JPUra\" rel=\"nofollow\">http://ideone.com/JPUra</a></p>\n", "CreationDate": "2011-08-09T16:20:49.863", "OwnerDisplayName": "user802003", "ParentId": "6998750", "Id": "6999445", "LastActivityDate": "2011-08-09T16:20:49.863", "PostTypeId": "2", "Score": "3"}, "6999650": {"CommentCount": "3", "Body": "<p>It seems that the grammar demands using a typedef in your case. A <em>conversion-function-id</em> must be of the form <strong>operator</strong> <em>conversion-type-id</em>. The <em>conversion-type-id</em> cannot contain parentheses. So you must use typedef when converting to a pointer-to-function type, or to a pointer-to-member-function type.</p>\n", "CreationDate": "2011-08-09T16:37:15.750", "ParentId": "6998750", "Id": "6999650", "LastActivityDate": "2011-08-09T16:37:15.750", "PostTypeId": "2", "Score": "2", "OwnerUserId": "775806"}, "6999978": {"CommentCount": "3", "Body": "<p>Ah, I just remembered the <code>identity</code> meta-function. It is possible to write</p>\n<pre><code>operator typename identity&lt;void (Testable::*)() const&gt;::type() const;\n</code></pre>\n<p>with the following definition of <code>identity</code>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct identity\n{\n    typedef T type;\n};\n</code></pre>\n<p>You could argue that <code>identity</code> still uses a <code>typedef</code>, but this solution is \"good\" enough for me.</p>\n", "CreationDate": "2011-08-09T17:03:31.660", "ParentId": "6998750", "Id": "6999978", "LastActivityDate": "2011-08-09T17:03:31.660", "PostTypeId": "2", "Score": "9", "OwnerUserId": "252000"}, "bq_ids": {"n4140": {"so_6998750_6999394_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 7223}}, "n3337": {"so_6998750_6999394_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 6967}}}, "6999394": {"CommentCount": "2", "Body": "<p>One case (unrelated to your question) where a <code>typedef</code> is required is when using the </p>\n<p><code>va_arg()</code> macro.  Quoting the C99 standard (7.15.1.1):</p>\n<blockquote>\n<p id=\"so_6998750_6999394_0\">type* va_arg(va_list ap, <em>type</em>);</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_6998750_6999394_1\">The parameter <em>type</em> shall be a\n  type name specified such that the type of a pointer to an object that\n  has the specified type can be obtained simply by postfixing a * to\n  <em>type</em></p>\n</blockquote>\n", "CreationDate": "2011-08-09T16:16:34.600", "ParentId": "6998750", "Id": "6999394", "LastActivityDate": "2011-08-09T16:16:34.600", "PostTypeId": "2", "Score": "3", "OwnerUserId": "827263"}, "6999002": {"CommentCount": "0", "Body": "<p>My analysis says that it is not possible without using <code>typedef</code>. The compiler sees <code>(</code> as the first token and assumes you are overloading <code>() operator</code>, which shouldn't have any arguments (The arguments would come in next set of parenthesis). Putting any set of extra parenthesis wouldn't help either - but would actually confuse the compiler and hence set of more errors.</p>\n<p>Most of the STL code is on top of <code>typedef</code>initions, and we should/must use them! </p>\n", "CreationDate": "2011-08-09T15:47:52.687", "ParentId": "6998750", "Id": "6999002", "LastActivityDate": "2011-08-09T15:47:52.687", "PostTypeId": "2", "Score": "2", "OwnerUserId": "264325"}, "6999868": {"LastActivityDate": "2011-08-09T17:44:35.353", "CommentCount": "3", "Body": "<p>In C++11, you can do it like this (gcc 4.5.2):</p>\n<pre><code>operator decltype((void (Testable::*)() const)(0))() const ;\n</code></pre>\n<p>I'm not saying it's pretty...</p>\n", "CreationDate": "2011-08-09T16:53:49.403", "LastEditDate": "2011-08-09T17:44:35.353", "ParentId": "6998750", "Id": "6999868", "LastEditorUserId": "428857", "PostTypeId": "2", "Score": "2", "OwnerUserId": "428857"}, "6999060": {"LastActivityDate": "2011-08-09T16:32:42.603", "CommentCount": "0", "Body": "<p>A <code>typedef</code> is not a macro your second example is not equivalent to the first. In the first case your <code>typedef</code> is defining a functor then using that type in a cast operator of the functor type. In the second the operator is using bad syntax as there is no operator specified because there is no type. I'm not sure how to write it but there is a way usually.</p>\n<p><strike>Typedefs aren't really necessary except for making human readable code in TMP and even then it depends on what kind of human you are.</strike></p>\n<p>Since I can't come up with the alternative syntax maybe typedefs are necessary in some cases. I just thought of another one possibly. Say you had a template with specializations which contained a static method with a return type like below:</p>\n<pre><code>template &lt;typename T&gt;\nstruct WhateverHandler\n{\n   typedef T rType;\n   static rType Whatever() { return rType(); }\n};\n\ntemplate &lt;&gt;\nstruct WhateverHandler&lt;std::string&gt;\n{\n   typedef std::string rType;\n   static rType Whatever() { return rType(); }\n};\n</code></pre>\n<p>I think in this case also you would need the typedef in order to call the static method regardless of specialization as otherwise the method could confuse the compiler because the return types would differ but it wouldn't be a proper overload.</p>\n<pre><code>template &lt;typename T&gt;\nstruct WhateverUser\n{\n   typename WhateverHandler&lt;T&gt;::rType DoWhatever()\n   {\n       return WhateverHandler&lt;T&gt;::template Whatever();\n   }\n};\n</code></pre>\n", "CreationDate": "2011-08-09T15:51:18.317", "LastEditDate": "2011-08-09T16:32:42.603", "ParentId": "6998750", "Id": "6999060", "LastEditorUserId": "516725", "PostTypeId": "2", "Score": "1", "OwnerUserId": "516725"}, "6998750": {"CreationDate": "2011-08-09T15:30:06.243", "ViewCount": "903", "FavoriteCount": "5", "Id": "6998750", "AcceptedAnswerId": "6999978", "Score": "36", "Title": "Are there cases where a typedef is absolutely necessary?", "CommentCount": "7", "Body": "<p>Consider the following excerpt from the <a href=\"http://www.artima.com/cppsource/safebool.html\" rel=\"noreferrer\">safe bool idiom</a>:</p>\n<pre><code>typedef void (Testable::*bool_type)() const;\noperator bool_type() const;\n</code></pre>\n<p>Is it possible to declare the conversion function without the typedef? The following does not compile:</p>\n<pre><code>operator (void (Testable::*)() const)() const;\n</code></pre>\n", "Tags": "<c++><type-conversion><typedef><coercion><safe-bool-idiom>", "LastActivityDate": "2014-03-07T23:06:44.987", "PostTypeId": "1", "AnswerCount": "8", "OwnerUserId": "252000"}});