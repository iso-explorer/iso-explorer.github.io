post_cb({"bq_ids": {"n4140": {"so_12374746_12375019_0": {"section_id": 7226, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_12374746_12375019_0": {"section_id": 6970, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_12374746_12375019_0": {"section_id": 8736, "quality": 0.6666666666666666, "length": 8}}}, "12375019": {"ParentId": "12374746", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In function parameter lists (as well as everywhere else), a cv qualification on an array type is shuffled right to qualify the array element type.  For example, with <code>T = int [5]</code>, <code>const T &amp;</code> is converted to <code>int const (&amp;) [5]</code>.</p>\n<blockquote>\n<h3>3.9.3 CV-quali\ufb01ers [basic.type.quali\ufb01er]</h3>\n<p id=\"so_12374746_12375019_0\">2 - [...] Any cv-qualifiers applied to an array type affect the array element type, not the array type (8.3.4).</p>\n</blockquote>\n<p>So the call to <code>func</code> with an argument of type <code>int const [5]</code> is deduced as a call to either of:</p>\n<pre><code>void func&lt;int [5]&gt;(int const (&amp;) [5])\nvoid func&lt;int const (&amp;) [5]&gt;(int const (&amp; &amp;&amp;) [5])\n// where the above collapses to\n// 'void func&lt;int const (&amp;) [5]&gt;(int const (&amp;) [5])'\n</code></pre>\n<p>Both overloads are viable, but the former is preferred:</p>\n<p>Let T1 be the <code>const T &amp;</code> template and T2 be the <code>T &amp;&amp;</code> template; that is, their parameter types are T1 := <code>const T &amp;</code> and T2 := <code>T &amp;&amp;</code>.  Then the transformed argument types (14.5.6.2:3) can be written A1 := <code>const C &amp;</code>, A2 := <code>D &amp;&amp;</code> for synthesized types <code>C</code>, <code>D</code>.</p>\n<p>Now, we attempt to order T1 against T2 (14.8.2.4:2), first using A1 as the argument template and P2 as the parameter template.  We remove references (14.8.2.4:5) giving A1 -&gt; <code>const C</code> and T2 -&gt; <code>T</code>, then remove cv-qualification (14.8.2.4:7) giving A1 -&gt; <code>C</code> and T2 -&gt; <code>T</code>.  The template <code>T</code> can be deduced to <code>C</code> (14.8.2.4:8) so <em>A1 is at least as specialised as P2</em>; conversely, A2 -&gt; <code>D</code> -&gt; <code>D</code>, P1 -&gt; <code>const T</code> -&gt; <code>T</code>, and <code>T</code> can be deduced to <code>D</code>, so <em>A2 is at least as specialised as P1</em>.</p>\n<p>This would usually imply that neither is more specialised than the other; however, because the <code>P</code> and <code>A</code> types are reference types 14.8.2.4:9 applies, and since A1 is an lvalue reference and P2 is not, T1 is considered more specialized than T2.  (A tie between reference types can also be broken by cv-qualification under the same clause.)</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-09-12T17:08:25.880", "Id": "12375019", "Score": "7", "CreationDate": "2012-09-11T17:35:37.870", "LastActivityDate": "2012-09-12T17:08:25.880"}, "12374820": {"ParentId": "12374746", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You're confusing rvalue references (like <code>int&amp;&amp;</code>) and universal references (which are made from temp\u00adlate parameters, as in <code>template &lt;typename T&gt; ... T&amp;&amp;</code>).</p>\n<p>Rvalue references indeed don't bind to lvalues. But universal references bind to anything. The question is just who's a better match.</p>\n<p>The type you have is <code>int const [5]</code>. Now let's see:</p>\n<ul>\n<li><p>against <code>T const &amp;</code>: Matches with <code>T = int[5]</code>.</p></li>\n<li><p>against <code>T &amp;&amp;</code>: Matches with <code>T = int const (&amp;)[5]</code>.</p></li>\n</ul>\n<p>The former is a better match, in the following sense: Both templates produce identical overloads. But <code>T = int[5]</code> is <strong>more specialised</strong> than <code>T = int const (&amp;)[5]</code>. You can see this because <code>T = int const (&amp;)[5]</code> can be realised as <code>T = U const &amp;</code> with <code>U = int[5]</code>.</p>\n<p>Note that to bind an lvalue to a universal reference, the type itself has to be deduced as a reference type.</p>\n<p>(Obviously <code>array</code> doesn't match <code>const T &amp;</code>, because it is not const. It can only match <code>T&amp;&amp;</code>, dedu\u00adcing <code>T = int (&amp;)[5]</code>).</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-09-11T18:42:22.943", "Id": "12374820", "Score": "3", "CreationDate": "2012-09-11T17:21:40.767", "LastActivityDate": "2012-09-11T18:42:22.943"}, "12374746": {"CommentCount": "1", "ViewCount": "185", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-09-11T17:17:10.480", "LastActivityDate": "2012-09-12T17:08:25.880", "Title": "Why do arrays of const preferentially bind to const T& parameters instead of T&& parameters?", "AcceptedAnswerId": "12375019", "LastEditDate": "2017-05-23T12:27:15.830", "Id": "12374746", "Score": "5", "Body": "<p>It's generally a bad idea to overload a function template taking a \"T&amp;&amp;\" parameter, because that can bind to anything, but let's suppose we do it anyway:</p>\n<pre><code>template&lt;typename T&gt;\nvoid func(const T&amp; param)\n{\n  std::cout &lt;&lt; \"const T&amp;\\n\";\n}\n\ntemplate&lt;typename T&gt;\nvoid func(T&amp;&amp; param)\n{\n  std::cout &lt;&lt; \"T&amp;&amp;\\n\";\n}\n</code></pre>\n<p>My understanding has been that the <code>const T&amp;</code> overload will get called for arguments that are const lvalues, and the <code>T&amp;&amp;</code> overload will get called for all other argument types.  But consider what happens when we call <code>func</code> with arrays of const and non-const contents:</p>\n<pre><code>int main()\n{\n  int array[5] = {};\n  const int constArray[5] = {};\n\n  func(array);             // calls T&amp;&amp; overload\n  func(constArray);        // calls const T&amp; overload\n}\n</code></pre>\n<p>VC10, VC11, and gcc 4.7 agree on the results shown.  My question is why the second call invokes the <code>const T&amp;</code> overload.  The simple answer is that <code>constArray</code> has a const in it, but I think that's too simple.  The type T that is deduced (regardless of the template selected) is \"array of 5 const ints\" so the type of <code>param</code> in the <code>const T&amp;</code> overload would be \"reference to const array of 5 const ints\".  But the array named constArray is not itself declared const.  So why doesn't the call to <code>func(constArray)</code> invoke the <code>T&amp;&amp;</code> overload, thus yielding a type for <code>param</code> of \"reference to array of 5 const ints\"?  </p>\n<p>This question is motivated by the discussion associated with the question at <a href=\"https://stackoverflow.com/questions/12258608/c-template-function-argument-deduce-and-function-resolution\">c++ template function argument deduce and function resolution</a>, but I think that thread got sidetracked on other issues and did not clarify the question I'm now asking here.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1426649", "AnswerCount": "2"}});