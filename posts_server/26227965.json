post_cb({"26228269": {"ParentId": "26227965", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The reason a <em>trivially copyable class</em> (C++11 mostly uses the concepts <em>trivial class</em> and <em>standard-layout class</em> instead of <em>POD</em>) can be memcpy'ed is not related to dynamic allocation as other answers/comments suggest. Granted, if you do try a shallow copy of a type that has dynamic allocation, you are inviting trouble. But you could very well have a type with a pointer that does dynamic allocation in a user provided constructor (as long as it has a default constructor) and qualify as <em>trivial class</em>.</p>\n<p>The actual reason a memcpy can be guaranteed is that <em>trivially copyable</em> (and also <em>standard-layout</em>) types are required to occupy contiguous bytes of storage whereas other objects are not.</p>\n<p>N3690</p>\n<blockquote>\n<p id=\"so_26227965_26228269_0\">1.8.5 Unless it is a bit-field (9.6), a most derived object shall have a non-zero size and shall occupy one or more\n  bytes of storage. Base class subobjects may have zero size. An object of trivially copyable or standard-layout\n  type (3.9) shall occupy contiguous bytes of storage.</p>\n</blockquote>\n", "OwnerUserId": "1707560", "LastEditorUserId": "1707560", "LastEditDate": "2014-10-07T04:10:12.100", "Id": "26228269", "Score": "3", "CreationDate": "2014-10-07T03:50:36.317", "LastActivityDate": "2014-10-07T04:10:12.100"}, "26228217": {"ParentId": "26227965", "CommentCount": "1", "Body": "<p>A particular case where this kind of serialization fails is on types with virtual members.  If a type has a virtual member then it has a vtable.  This table will contain pointers to the implementation for each of the virtual members.</p>\n<p>If the serialized data in the char array crosses a process boundary (you send it over the network, or you write it to disk and read it back in from a different process) then the vtable pointers you wrote out may no longer be valid, and invoking any virtual member would cause undefined behavior.</p>\n", "OwnerUserId": "501250", "PostTypeId": "2", "Id": "26228217", "Score": "2", "CreationDate": "2014-10-07T03:42:45.200", "LastActivityDate": "2014-10-07T03:42:45.200"}, "26227965": {"CommentCount": "14", "ViewCount": "1006", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-10-07T03:05:41.420", "LastActivityDate": "2015-12-21T21:34:10.327", "Title": "memcpy a non-POD object", "AcceptedAnswerId": "26228269", "LastEditDate": "2017-05-23T12:08:11.280", "Id": "26227965", "Score": "2", "Body": "<p>For objects of POD types it is guaranteed by the standard that when you memcpy the contents of your object into an array of \nchar or unsigned char, and then memcpy the contents back into your object, the object will hold its original value. </p>\n<p>Now note that there is no such guarantee for objects of non-POD types. So my question is why is this so?</p>\n<p><a href=\"https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special\">Source of the text above</a></p>\n", "Tags": "<c++>", "OwnerUserId": "1248779", "AnswerCount": "3"}, "26228082": {"ParentId": "26227965", "CommentCount": "1", "Body": "<p>I'm not sure that strictly speaking the standard does allow you to <code>memcpy</code> into an array of <code>char</code> and back again, although you'd certainly get away with it with PODs.</p>\n<p>But things get murkier when you start looking at all the complicated things C++ can do. Consider the following:</p>\n<pre><code>struct ex1;\n\nstruct ex2\n{\n    ex2(std::unique_ptr&lt;ex1&gt; ptr) : member{ptr} {}\nprivate:\n    std::unique_ptr&lt;ex1&gt; member;\n};\n</code></pre>\n<p>The struct <code>ex2</code> is move-only because it has a move-only member variable. So what happens if we use <code>memcpy</code> to construct a bit-for-bit identical copy of an <code>ex2</code> instance? We end up with two objects which both think they own the member pointer. What happens when the second one of these gets deleted? You get the idea.</p>\n", "OwnerUserId": "2797826", "PostTypeId": "2", "Id": "26228082", "Score": "2", "CreationDate": "2014-10-07T03:22:41.090", "LastActivityDate": "2014-10-07T03:22:41.090"}, "bq_ids": {"n4140": {"so_26227965_26228269_0": {"section_id": 5794, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_26227965_26228269_0": {"section_id": 5567, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_26227965_26228269_0": {"section_id": 7253, "quality": 0.9333333333333333, "length": 28}}}});