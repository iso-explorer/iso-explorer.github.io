post_cb({"bq_ids": {"n4140": {"so_41027701_41075328_1": {"length": 44, "quality": 1.0, "section_id": 332}, "so_41027701_41075328_3": {"length": 41, "quality": 1.0, "section_id": 335}}, "n3337": {"so_41027701_41075328_1": {"length": 44, "quality": 1.0, "section_id": 322}, "so_41027701_41075328_3": {"length": 41, "quality": 1.0, "section_id": 325}}, "n4659": {"so_41027701_41075328_1": {"length": 44, "quality": 1.0, "section_id": 341}, "so_41027701_41075328_3": {"length": 41, "quality": 1.0, "section_id": 344}}}, "41027701": {"ViewCount": "92", "Body": "<p>I'm trying to create a sample class which has different specializations according to whether its template parameter can be constructed with certain parameters. In my sample, with a simple <code>int</code>. I've tried with:</p>\n<pre><code>template&lt;class A_t&gt;\nstruct creator\n{\n    A_t* ptr = nullptr;\n};\n\ntemplate&lt;class A_t&gt;\nstruct creator&lt;decltype(A_t(int()))&gt;\n{\n    A_t* ptr = new A_t(5);\n};\n\nstruct A\n{\n    int i;\n\n    A(int i) : i(i) {}\n};\n\nint main() {\n    std::cout &lt;&lt; creator&lt;A&gt;().ptr &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>My intention is that it prints a memory address of a automatically constructed object. However, it is printing a 0. So, it's taking the non-specialized template.</p>\n<p><code>A_t</code> is deducible with that syntax, among other things because <code>A_t</code> is given explicitly. Besides, <code>decltype(A_t(int())</code> has type <code>A_t</code> (and not <code>A_t&amp;&amp;</code> for example), a simple test:</p>\n<pre><code>std::cout &lt;&lt; std::is_same&lt;decltype(A(int()), A&gt;::value &lt;&lt; std::endl;\n</code></pre>\n<p>prints 1.</p>\n<p>However, that implementation works:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class A_t, class = A_t&gt;\nstruct creator\n{\n    A_t* ptr = nullptr;\n};\n\ntemplate&lt;class A_t&gt;\nstruct creator&lt;A_t, decltype(A_t(int()))&gt;\n{\n    A_t* ptr = new A_t(5);\n};\n\nstruct A\n{\n    int i;\n\n    A(int i) : i(i) {}\n};\n\nint main() {\n    std::cout &lt;&lt; creator&lt;A&gt;().ptr &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d3bfa27026028b2e\" rel=\"nofollow noreferrer\">Coliru</a> test with two classes, one accepting an <code>int</code> as parameter, and other which doesn't.</p>\n<p>Why is the first approach not working?</p>\n", "AcceptedAnswerId": "41075328", "Title": "SFINAE for constructor parameters", "CreationDate": "2016-12-07T21:28:47.583", "Id": "41027701", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-12-07T23:02:36.010", "LastEditorUserId": "1794803", "LastActivityDate": "2016-12-10T12:07:03.243", "Score": "2", "OwnerUserId": "1794803", "Tags": "<c++><class><constructor><sfinae>", "AnswerCount": "1"}, "41075328": {"Id": "41075328", "PostTypeId": "2", "Body": "<p>My best gloss of the thinking behind your question is:</p>\n<p>For a given instantiating type <code>U</code> =&gt; <code>A_t</code>, if the conversion\n<code>U(int)</code> is undefined then the substitution <code>U(int)</code> =&gt; <code>A_t(int)</code>\nwill fail in the context <code>decltype(A_t(int()))</code> and the specialization:</p>\n<pre><code>template&lt;class A_t&gt;\nstruct creator&lt;decltype(A_t(int()))&gt;\n{\n    A_t* ptr = new A_t(5);\n};\n</code></pre>\n<p>will be eliminated, leaving only the base template instantiation. But if the \nconversion <code>U(int)</code> is defined that substitution will succeed.</p>\n<p>Then, because:</p>\n<pre><code>std::is_same&lt;U,decltype(U(int()))&gt;::value == true\n</code></pre>\n<p>both candidates:</p>\n<pre><code>// Tweedledum, with of U =&gt; A_t\nstruct creator&lt;U&gt;\n{\n    U* ptr = nullptr;\n};\n</code></pre>\n<p>and:</p>\n<pre><code>// Tweedledee, with U =&gt; decltype(A_t(int()))\nstruct creator&lt;U&gt;\n{\n    U* ptr = new U(5);\n};\n</code></pre>\n<p>are in the running. </p>\n<p>Then, the <em>most specialized</em> candidate will be chosen, which will be <code>Tweedledee</code>, \nbecause satisfying <code>U</code> =&gt; <code>decltype(A_t(int()))</code> constrains <code>U</code> more precisely than\nthe bare <code>U =&gt; A_t</code>.</p>\n<p>This reasoning relies implicitly on it being <em>deducible</em> for <code>Teedledee</code> that <code>U</code> = <code>decltype(A_t(int()))</code> when <code>U</code> =&gt; <code>A_t</code>;\nwhich boils down to it being deducible that <code>U(int)</code> = <code>A_t(int)</code> in the sole template argument <code>decltype(A_t(int()))</code>.</p>\n<p>You believe that is so and then wonder how gcc can pick <code>Tweedledum</code>.</p>\n<p>As @WhozCraig pointed out, clang++ expressly rejects your deducibility premiss:-</p>\n<pre><code>$ clang++-3.8 -Wall -Wextra -pedantic -std=c++14 main.cpp\nmain.cpp:10:8: warning: class template partial specialization contains a template parameter that cannot be deduced; this partial specialization will never be used\nstruct creator&lt;decltype(A_t(int()))&gt;\n       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmain.cpp:9:16: note: non-deducible template parameter 'A_t'\ntemplate&lt;class A_t&gt;\n               ^\n</code></pre>\n<p><a href=\"http://rextester.com/EFIRA27724\" rel=\"nofollow noreferrer\">So does MSVC++</a>.</p>\n<p>And it turns out that gcc has been induced into a diagnostic lapse here by\nthe unlucky phrasing of your SFINAE locution, <code>decltype(A_t(int()))</code></p>\n<p>If you replace that with <code>decltype(A_t{int()})</code>, then gcc also <a href=\"http://coliru.stacked-crooked.com/a/b9200ca3c4784551\" rel=\"nofollow noreferrer\">gets with the program</a>:</p>\n<pre><code>$ g++-6 -Wall -Wextra -pedantic -std=c++14 main.cpp\nmain.cpp:10:8: error: template parameters not deducible in partial specialization:\n struct creator&lt;decltype(A_t{int()})&gt;\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmain.cpp:10:8: note:         \u2018A_t\u2019\n</code></pre>\n<p>After that, clang++ is the only compiler of the three that will\ncompile the program at all - and instantiates <code>creator&lt;A&gt;</code> from the base template.</p>\n<p>This eventual consensus that <code>A_t</code> is <em>not</em> deducible in <code>decltype(A_t{int()})</code>\nis endorsed by the C++14 Standard:</p>\n<blockquote>\n<p id=\"so_41027701_41075328_0\">Deducing template arguments from a type        [temp.deduct.type]</p>\n<p id=\"so_41027701_41075328_1\">1 Template arguments can be deduced in several different contexts, but in each case\n  a type that is specified in terms of template parameters (call it P) is compared\n  with an actual type (call it A), and an attempt is made to find template argument\n  values (a type for a type parameter, a value for a non-type parameter, or a \n  template for a template parameter) that will make P, after substitution of the \n  deduced values (call it the deduced A), compatible with A.</p>\n<p id=\"so_41027701_41075328_2\">...</p>\n<p id=\"so_41027701_41075328_3\">4 In most cases, the types, templates, and non-type values that are used to compose\n  P participate in template argument deduction... In certain contexts, however,\n  the value does not participate in type deduction, but instead uses the values \n  of template arguments that were either deduced elsewhere or explicitly specified. \n  If a template parameter is used only in non-deduced contexts and is not explicitly \n  specified, template argument deduction fails.</p>\n<p id=\"so_41027701_41075328_4\">5 The non-deduced contexts are:</p>\n<p id=\"so_41027701_41075328_5\">...</p>\n<p id=\"so_41027701_41075328_6\">(5.2) - The expression of a decltype-specifier.</p>\n<p id=\"so_41027701_41075328_7\">...</p>\n</blockquote>\n<p>Para 4 also explains why your second approach succeeds.</p>\n", "LastActivityDate": "2016-12-10T12:07:03.243", "CommentCount": "0", "CreationDate": "2016-12-10T12:07:03.243", "ParentId": "41027701", "Score": "1", "OwnerUserId": "1362568"}});