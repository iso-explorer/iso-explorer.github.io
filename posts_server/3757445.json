post_cb({"3757454": {"ParentId": "3757445", "CommentCount": "1", "Body": "<p>In fact, neither are legal C++.  You cannot declare a variable in a switch case unless it is scoped:</p>\n<pre><code>switch(val)  \n{  \ncase 0:  \n  {\n    int newVal = 42;  // now valid\n  }\n  break;\ncase 1:  \n  {\n    int newVal2;      // still Valid\n    newVal2 = 42;  \n  }\n  break;\ncase 2:\n  break;\n}\n</code></pre>\n<p>The fact that your compiler permits case 1 is a defect of your compiler, or possibly an extension. At least, according to the standard.</p>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "3757454", "Score": "4", "CreationDate": "2010-09-21T05:09:53.060", "LastActivityDate": "2010-09-21T05:09:53.060"}, "3757445": {"CommentCount": "2", "ViewCount": "3274", "CreationDate": "2010-09-21T05:06:11.947", "LastActivityDate": "2010-09-21T05:47:34.103", "Title": "Switch-Case: declaration-with-initialization & declaration-and-then-assignment", "PostTypeId": "1", "Id": "3757445", "Score": "5", "Body": "<p>In the switch-case statements <strong>declaration-with-initialization</strong> is invalid but <strong>declaration-and-then-assignment</strong> is allowed. As shown in the following code snippet. </p>\n<p>What is difference between these two type of initializations from the compiler side? And why is the first type of initialization invalid and second type a valid one.</p>\n<pre><code>switch(val)  \n{  \ncase 0:  \n  int newVal = 42;  //Invalid\n  break;\ncase 1:  \n  int newVal2;      //Valid\n  newVal2 = 42;  \n  break;\ncase 2:\n  break;\n}\n</code></pre>\n", "Tags": "<c++><switch-statement><jump-table>", "OwnerUserId": "122668", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_3757445_3757620_1": {"section_id": 3918, "quality": 0.8888888888888888, "length": 8}, "so_3757445_3757620_0": {"section_id": 3918, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_3757445_3757620_1": {"section_id": 3778, "quality": 0.8888888888888888, "length": 8}, "so_3757445_3757620_0": {"section_id": 3778, "quality": 0.8518518518518519, "length": 23}}, "n4659": {"so_3757445_3757620_1": {"section_id": 4804, "quality": 0.8888888888888888, "length": 8}, "so_3757445_3757620_0": {"section_id": 4804, "quality": 0.8888888888888888, "length": 24}}}, "3757620": {"ParentId": "3757445", "CommentCount": "3", "Body": "<p>Effectively, the rule is that you can't jump into a block past a declaration that has an  initialization (or past the declaration of a non-POD type variable).  The C++ standard says (C++03 \u00a76.7):</p>\n<blockquote>\n<p id=\"so_3757445_3757620_0\">It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A program that jumps<sup>(77)</sup> from a point where a local variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed unless the variable has POD type (3.9) and is declared without an initializer (8.5).</p>\n<p id=\"so_3757445_3757620_1\"><sup>(*) The transfer from the condition of a <code>switch</code> statement to a <code>case</code> label is considered a jump in this respect.</sup></p>\n</blockquote>\n<p><code>int newVal = 42;</code> is a declaration that has an initializer (the <code>= 42</code> part).  The program is ill-formed because if <code>val</code> is <code>1</code> or <code>2</code>, you'll jump into the switch block past the initialization.</p>\n<p><code>int newVal2;</code> is also a declaration; because <code>int</code> is a POD type and the declaration has no initializer, you can jump past this declaration.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "3757620", "Score": "9", "CreationDate": "2010-09-21T05:47:34.103", "LastActivityDate": "2010-09-21T05:47:34.103"}});