post_cb({"bq_ids": {"n4140": {"so_48685439_48685527_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 7104}, "so_48685439_48685631_1": {"length": 22, "quality": 1.0, "section_id": 7104}, "so_48685439_48685631_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 7104}}, "n3337": {"so_48685439_48685527_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6848}, "so_48685439_48685631_1": {"length": 22, "quality": 1.0, "section_id": 6848}, "so_48685439_48685631_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 6848}}, "n4659": {"so_48685439_48685527_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 8605}, "so_48685439_48685631_1": {"length": 22, "quality": 1.0, "section_id": 8605}, "so_48685439_48685631_0": {"length": 37, "quality": 0.8409090909090909, "section_id": 8605}}}, "48685527": {"Id": "48685527", "PostTypeId": "2", "Body": "<p>It works if you put operator+ into namespace N.  You should usually do this, because then ADL can help you resolve the operator.</p>\n<p>Clang 5 even tells you explicitly that you should do this.</p>\n<p>You may be thinking that ADL will result in a lookup in the global namespace because one of the arguments is <code>int</code>.  But this is not so, because:</p>\n<blockquote>\n<p id=\"so_48685439_48685527_0\">1) For arguments of fundamental type, the associated set of namespaces and classes is empty</p>\n</blockquote>\n<p>That is, it is not the case that a type like <code>int</code> will cause ADL to look for your operator in the global namespace.</p>\n<p>See here: <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/adl</a></p>\n", "LastEditorUserId": "4323", "LastActivityDate": "2018-02-08T12:36:08.880", "Score": "2", "CreationDate": "2018-02-08T12:27:56.530", "ParentId": "48685439", "CommentCount": "4", "OwnerUserId": "4323", "LastEditDate": "2018-02-08T12:36:08.880"}, "48685439": {"ViewCount": "76", "Body": "<p>First of all feel free to suggest better title for this question.</p>\n<p>Consider following program:</p>\n<pre><code>#include &lt;numeric&gt;\nnamespace N { class C {}; }\nint operator+( int i, N::C ) { return i+1; }\nint main() {\n     N::C a[10];\n     std::accumulate( a, a+10, 0 );\n} \n</code></pre>\n<p><code>g++</code> 5.4.0: Compile successfully ( See live demo <a href=\"http://rextester.com/WDC91550\" rel=\"nofollow noreferrer\">here</a> )</p>\n<p><code>clang++</code> 3.8.0 ( See live demo <a href=\"http://rextester.com/TNZY85319\" rel=\"nofollow noreferrer\">here</a> )</p>\n<p>Error(s):</p>\n<pre><code>In file included from source_file.cpp:3:\n/usr/include/c++/v1/numeric:75:25: error: invalid operands to binary expression ('int' and 'N::C')\n        __init = __init + *__first;\n                 ~~~~~~ ^ ~~~~~~~~\nsource_file.cpp:8:11: note: in instantiation of function template specialization 'std::__1::accumulate&lt;N::C *, int&gt;' requested here\n     std::accumulate( a, a+10, 0 );\n          ^\n/usr/include/c++/v1/iterator:640:1: note: candidate template ignored: could not match 'reverse_iterator&lt;type-parameter-0-0&gt;' against 'N::C'\noperator+(typename reverse_iterator&lt;_Iter&gt;::difference_type __n, const reverse_iterator&lt;_Iter&gt;&amp; __x)\n^\n/usr/include/c++/v1/iterator:1044:1: note: candidate template ignored: could not match 'move_iterator&lt;type-parameter-0-0&gt;' against 'N::C'\noperator+(typename move_iterator&lt;_Iter&gt;::difference_type __n, const move_iterator&lt;_Iter&gt;&amp; __x)\n^\n/usr/include/c++/v1/iterator:1400:1: note: candidate template ignored: could not match '__wrap_iter&lt;type-parameter-0-0&gt;' against 'N::C'\noperator+(typename __wrap_iter&lt;_Iter&gt;::difference_type __n,\n^\n1 error generated.\n</code></pre>\n<p><code>Microsoft Visual C++</code> 19.00.23506 ( See live demo <a href=\"http://rextester.com/PXKIZ54707\" rel=\"nofollow noreferrer\">here</a> )</p>\n<p>Error(s):</p>\n<pre><code>C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\numeric(20): error C2672: 'operator __surrogate_func': no matching overloaded function found\nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\numeric(30): note: see reference to function template instantiation '_Ty std::_Accumulate&lt;_Iter,_Ty,_Fn2&gt;(_InIt,_InIt,_Ty,_Fn2)' being compiled\n        with\n        [\n            _Ty=int,\n            _Iter=N::C *,\n            _Fn2=std::plus&lt;void&gt;,\n            _InIt=N::C *\n        ]\nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\numeric(38): note: see reference to function template instantiation '_Ty std::accumulate&lt;_InIt,_Ty,std::plus&lt;void&gt;&gt;(_InIt,_InIt,_Ty,_Fn2)' being compiled\n        with\n        [\n            _Ty=int,\n            _InIt=N::C *,\n            _Fn2=std::plus&lt;void&gt;\n        ]\nsource_file.cpp(8): note: see reference to function template instantiation '_Ty std::accumulate&lt;N::C*,int&gt;(_InIt,_InIt,_Ty)' being compiled\n        with\n        [\n            _Ty=int,\n            _InIt=N::C *\n        ]\nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\numeric(20): error C2893: Failed to specialize function template 'unknown-type std::plus&lt;void&gt;::operator ()(_Ty1 &amp;&amp;,_Ty2 &amp;&amp;) const'\nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\numeric(20): note: With the following template arguments:\nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\numeric(20): note: '_Ty1=int &amp;'\nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\numeric(20): note: '_Ty2=N::C &amp;'\n\n    Error(s):\n    In file included from source_file.cpp:3:\n    /usr/include/c++/v1/numeric:75:25: error: invalid operands to binary expression ('int' and 'N::C')\n            __init = __init + *__first;\n                     ~~~~~~ ^ ~~~~~~~~\n    source_file.cpp:8:11: note: in instantiation of function template specialization 'std::__1::accumulate&lt;N::C *, int&gt;' requested here\n         std::accumulate( a, a+10, 0 );\n              ^\n    /usr/include/c++/v1/iterator:640:1: note: candidate template ignored: could not match 'reverse_iterator&lt;type-parameter-0-0&gt;' against 'N::C'\n    operator+(typename reverse_iterator&lt;_Iter&gt;::difference_type __n, const reverse_iterator&lt;_Iter&gt;&amp; __x)\n    ^\n    /usr/include/c++/v1/iterator:1044:1: note: candidate template ignored: could not match 'move_iterator&lt;type-parameter-0-0&gt;' against 'N::C'\n    operator+(typename move_iterator&lt;_Iter&gt;::difference_type __n, const move_iterator&lt;_Iter&gt;&amp; __x)\n    ^\n    /usr/include/c++/v1/iterator:1400:1: note: candidate template ignored: could not match '__wrap_iter&lt;type-parameter-0-0&gt;' against 'N::C'\n    operator+(typename __wrap_iter&lt;_Iter&gt;::difference_type __n,\n    ^\n    1 error generated.\n</code></pre>\n<p>This program surprisingly compiles without any error on Intel C++ compiler also. </p>\n<p>So, the question is which compilers are right here ? Is this code ill formed ? What does the standard says about this ?</p>\n", "AcceptedAnswerId": "48685631", "Title": "Inconsistency in name lookup among different compilers", "CreationDate": "2018-02-08T12:22:57.907", "Id": "48685439", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2018-02-08T12:36:08.880", "Score": "3", "OwnerUserId": "3777958", "Tags": "<c++><operator-overloading><language-lawyer><overload-resolution><name-lookup>", "AnswerCount": "2"}, "48685631": {"Id": "48685631", "PostTypeId": "2", "Body": "<p>Like John Zwinck said, put the operator into <code>namespace N</code>. The reason being that ADL considers only the the innermost enclosing namespace of the class in question.</p>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.lookup.argdep#2.2\" rel=\"nofollow noreferrer\">[basic.lookup.argdep]/2</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_48685439_48685631_0\">For each argument type T in the function call, there is a set of zero\n  or more associated namespaces and a set of zero or more associated\n  classes to be considered. The sets of namespaces and classes are\n  determined entirely by the types of the function arguments (and the\n  namespace of any template template argument). Typedef names and\n  using-declarations used to specify the types do not contribute to this\n  set. The sets of namespaces and classes are determined in the\n  following way:</p>\n<ul>\n<li>[...]</li>\n<li>If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its\n  direct and indirect base classes. <strong>Its associated namespaces are the\n  innermost enclosing namespaces of its associated classes</strong>.\n  Furthermore, if T is a class template specialization, its associated\n  namespaces and classes also include: the namespaces and classes\n  associated with the types of the template arguments provided for\n  template type parameters (excluding template template parameters); the\n  namespaces of which any template template arguments are members; and\n  the classes of which any member templates used as template template\n  arguments are members. [\u2009Note: Non-type template arguments do not\n  contribute to the set of associated namespaces.\u2009\u2014\u2009end note\u2009]</li>\n</ul>\n</blockquote>\n<p>With only a special exception to be made if that namespace is an inline namespace. </p>\n<blockquote>\n<p id=\"so_48685439_48685631_1\">If an associated namespace is an inline namespace, its enclosing\n  namespace is also included in the set. If an associated namespace\n  directly contains inline namespaces, those inline namespaces are also\n  included in the set.</p>\n</blockquote>\n<p>So your <code>operator+</code> should not be found by ADL, and as such should not participate in overload resolution inside <code>std::accumulate</code>.</p>\n", "LastActivityDate": "2018-02-08T12:33:04.323", "Score": "3", "CreationDate": "2018-02-08T12:33:04.323", "ParentId": "48685439", "CommentCount": "7", "OwnerUserId": "817643"}});