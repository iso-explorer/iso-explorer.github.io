post_cb({"bq_ids": {"n4140": {"so_8752111_8752126_0": {"length": 23, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_8752111_8752126_0": {"length": 23, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_8752111_8752126_0": {"length": 23, "quality": 1.0, "section_id": 7604}}}, "8757879": {"Id": "8757879", "PostTypeId": "2", "Body": "<p>In your source code there is no memory leak, since you don't have any member variable that is created dynamically.</p>\n<p>Consider the modified example below Case 1:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass base\n{\n   int a;\n public: \n   base() {a =0;}\n   ~base() \n     {\n       cout&lt;&lt;\"\\nBase Destructor called\";\n\n     }\n };\n class derv :public base\n {\n   int *b;\n\n  public:\n   derv() { b = new int;}\n  ~derv()\n  {\n      cout&lt;&lt;\"\\nDerv Destructor called\"; \n      delete b;\n  }\n };\n int main()\n {\n    base *pb = new derv();\n    delete pb;\n }\n</code></pre>\n<p>In this case the output will be,</p>\n<pre><code>   Base Destructor called\n</code></pre>\n<p>In this case there is a memory leak, because 'b' is created dynamically using 'new' which should be deleted using 'delete' keyword. Since derv destructor is not being called it's not deleted so there is memory leak.</p>\n<p>Consider the below case 2:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass base\n{\n   int a;\n public: \n   base() {a =0;}\n   virtual ~base() \n     {\n       cout&lt;&lt;\"\\nBase Destructor called\";\n\n     }\n };\n class derv :public base\n {\n   int *b;\n\n  public:\n   derv() { b = new int;}\n  ~derv()\n  {\n      cout&lt;&lt;\"\\nDerv Destructor called\"; \n      delete b;\n  }\n };\n int main()\n {\n    base *pb = new derv();\n    delete pb;\n }\n</code></pre>\n<p>In the case 2 output will be,</p>\n<pre><code>Derv Destructor called \nBase Destructor called\n</code></pre>\n<p>In this case there is no memory leak.because derv destructor is called and b is getting deleted.</p>\n<p>Destructor can be defined as Virtual in base class to make sure the derived class destructor to be called when we delete base class pointer which is pointing to derived class object.</p>\n<p>We can say 'Destructor must be virtual when derived class has dynamically created members'.</p>\n", "LastActivityDate": "2012-01-06T12:37:08.220", "Score": "-1", "CreationDate": "2012-01-06T12:37:08.220", "ParentId": "8752111", "CommentCount": "2", "OwnerUserId": "316737", "CommunityOwnedDate": "2012-01-06T12:37:08.220"}, "8752111": {"ViewCount": "2777", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass base\n{\n   int a;\n public: \n   base() {a =0;}\n };\n class derv :public base\n {\n   int b;\n  public:\n   derv() {b =1;}\n };\n int main()\n {\n    base *pb = new derv();\n    delete pb;\n }\n</code></pre>\n<p>I don't have a virtual destructor in derv class, does it delete only base part of derv object?? </p>\n", "AcceptedAnswerId": "8752126", "Title": "Possible memory leak without a virtual destructor?", "CreationDate": "2012-01-06T00:58:05.083", "Id": "8752111", "CommentCount": "3", "LastEditDate": "2013-07-01T14:11:07.990", "PostTypeId": "1", "LastEditorUserId": "569101", "LastActivityDate": "2013-07-01T14:11:07.990", "Score": "11", "OwnerUserId": "791403", "Tags": "<c++><polymorphism><dynamic-memory-allocation><virtual-destructor>", "AnswerCount": "3"}, "8752171": {"Id": "8752171", "PostTypeId": "2", "Body": "<p>There is no memory leak in your code. There would have been a memory leak if you needed to free some memory in the derived class destructor.  </p>\n", "LastActivityDate": "2012-01-06T01:06:26.067", "CommentCount": "1", "CreationDate": "2012-01-06T01:06:26.067", "ParentId": "8752111", "Score": "-1", "OwnerUserId": "920843"}, "8752126": {"Id": "8752126", "PostTypeId": "2", "Body": "<p>It might.</p>\n<p>Because <code>base</code> does not have a virtual destructor, your code exhibits undefined behavior.  Anything might happen.  It might appear to work as you expect.  It might leak memory.  It might cause your program to crash.  It might format your hard drive.</p>\n<p>A citation was requested.  C++11 \u00a75.3.5/3 states that, for a scalar <code>delete</code> expression (i.e., not a <code>delete[]</code> expression):</p>\n<blockquote>\n<p id=\"so_8752111_8752126_0\">if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>The static type (<code>base</code>) is different from the dynamic type (<code>derv</code>) and the static type does not have a virtual destructor, so the behavior is undefined.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2012-01-06T01:10:10.747", "Score": "19", "CreationDate": "2012-01-06T01:00:38.737", "ParentId": "8752111", "CommentCount": "19", "OwnerUserId": "151292", "LastEditDate": "2012-01-06T01:10:10.747"}});