post_cb({"26994929": {"Id": "26994929", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/20816214/560648\">Accessibility is orthogonal to deletedness</a>:</p>\n<blockquote>\n<p id=\"so_26994755_26994929_0\"><code>[C++11: 11.2/1]:</code> If a class is declared to be a base class (Clause 10) for another class using the <code>public</code> access specifier, the <code>public</code> members of the base class are accessible as <code>public</code> members of the derived class and <code>protected</code> members of the base class are accessible as <code>protected</code> members of the derived class. If a class is declared to be a base class for another class using the <code>protected</code> access specifier, the <code>public</code> and <code>protected</code> members of the base class are accessible as <code>protected</code> members of the derived class. If a class is declared to be a base class for another class using the <code>private</code> access specifier, the <code>public</code> and <code>protected</code> members of the base class are accessible as <code>private</code> members of the derived class.</p>\n</blockquote>\n<p>There is this:</p>\n<blockquote>\n<p id=\"so_26994755_26994929_1\"><code>[C++11: 8.4.3/2]:</code> A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed. <em>[ Note:</em> This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member to the function. It applies even for references in expressions that are not potentially-evaluated. If a function is overloaded, it is referenced only if the function is selected by overload resolution. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>But you never \"refer to\" the deleted destructor.</p>\n<p>(I still can't explain why the inheritance example doesn't compile.)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-18T12:57:05.450", "Score": "1", "CreationDate": "2014-11-18T12:57:05.450", "ParentId": "26994755", "CommentCount": "0", "OwnerUserId": "560648", "LastEditDate": "2017-05-23T12:30:50.013"}, "26995331": {"Id": "26995331", "PostTypeId": "2", "Body": "<p>My guess is that this is what happens.</p>\n<p>The implicitly generated <code>B()</code> constructor will first of all construct its base class subobject of type <code>A</code>. The language then states that if an exception is thrown during execution of the body of the <code>B()</code> constructor, the <code>A</code> subobject must be destroyed. Hence the need to access the deleted <code>~A()</code> - it is formally needed for when the constructor throws. Of course, since the generated body of <code>B()</code> is empty this can never ever happen, but the requirement that <code>~A()</code> should be accessible is still there.</p>\n<p>Of course, this is 1) just a guess from my side of why there is an error in the first place and 2) not in any way a quote of the standardese to say whether this would actually be formally ill-formed or just an implementation detail in gcc. Could perhaps give you a clue of where in the standard to look though...</p>\n", "LastActivityDate": "2014-11-18T13:18:16.197", "CommentCount": "0", "CreationDate": "2014-11-18T13:18:16.197", "ParentId": "26994755", "Score": "3", "OwnerUserId": "30579"}, "bq_ids": {"n4140": {"so_26994755_26995534_0": {"length": 6, "quality": 1.0, "section_id": 369}, "so_26994755_26995534_1": {"length": 11, "quality": 0.6875, "section_id": 461}, "so_26994755_26994929_1": {"length": 30, "quality": 0.8333333333333334, "section_id": 3277}, "so_26994755_26994929_0": {"length": 69, "quality": 0.971830985915493, "section_id": 6678}}, "n3337": {"so_26994755_26995534_0": {"length": 6, "quality": 1.0, "section_id": 359}, "so_26994755_26995534_1": {"length": 11, "quality": 0.6875, "section_id": 452}, "so_26994755_26994929_1": {"length": 30, "quality": 0.8333333333333334, "section_id": 3148}, "so_26994755_26994929_0": {"length": 69, "quality": 0.971830985915493, "section_id": 6433}, "so_26994755_26994755_1": {"length": 17, "quality": 1.0, "section_id": 398}}, "n4659": {"so_26994755_26995534_0": {"length": 6, "quality": 1.0, "section_id": 382}, "so_26994755_26995534_1": {"length": 11, "quality": 0.6875, "section_id": 484}, "so_26994755_26994929_1": {"length": 30, "quality": 0.8333333333333334, "section_id": 4035}, "so_26994755_26994929_0": {"length": 69, "quality": 0.971830985915493, "section_id": 8153}}}, "26995534": {"Id": "26995534", "PostTypeId": "2", "Body": "<p>The first part is not ill-formed because the standard text doesn't apply - no object of type A is declared there.</p>\n<p>For the second part, let's review how object construction works. The standard says (15.2/2) that if any part of construction throws, all fully constructed subobjects up to that point are destroyed in reverse order of construction.</p>\n<p>This means that the code underlying a constructor, if all written out by hand, would look something like this:</p>\n<pre><code>// Given:\nstruct C : A, B {\n   D d;\n   C() : A(), B(), d() { /* more code */ }\n};\n\n// This is the expanded constructor:\nC() {\n  A();\n  try {\n    B();\n    try {\n      d.D();\n      try {\n        /* more code */\n      } catch(...) { d.~D(); throw; }\n    } catch(...) { ~B(); throw; }\n  } catch(...) { ~A(); throw; }\n}\n</code></pre>\n<p>For your simpler class, the expanded code for the default constructor (whose definition is required by the <code>new</code> expression) would look like this:</p>\n<pre><code>B::B() {\n  A();\n  try {\n    // nothing to do here\n  } catch(...) {\n    ~A(); // error: ~A() is deleted.\n    throw;\n  }\n}\n</code></pre>\n<p>Making this work for cases where no exception can possibly be thrown after initialization for some subobject has been completed is just too complex to specify. Therefore, this doesn't actually happen, because the default constructor for B is implicitly defined as deleted in the first place, due to the last bullet point in N3797 12.1/4:</p>\n<blockquote>\n<p id=\"so_26994755_26995534_0\">A defaulted default constructor for class X is defined as deleted if:</p>\n<ul>\n<li>[...]</li>\n<li>any direct or virtual base class or non-static data member has a type with a destructor that is deleted or inaccessible from the defaulted default constructor.</li>\n</ul>\n</blockquote>\n<p>The equivalent language exists for copy/move constructors as the fourth bullet in 12.8/11.</p>\n<p>There is also an important paragraph in 12.6.2/10:</p>\n<blockquote>\n<p id=\"so_26994755_26995534_1\">In a non-delegating constructor, the destructor for each direct or virtual base class and for each non-static data member of class type is potentially invoked.</p>\n</blockquote>\n", "LastEditorUserId": "8922", "LastActivityDate": "2014-11-18T13:38:28.973", "Score": "12", "CreationDate": "2014-11-18T13:29:16.717", "ParentId": "26994755", "CommentCount": "5", "OwnerUserId": "8922", "LastEditDate": "2014-11-18T13:38:28.973"}, "26994755": {"ViewCount": "1466", "Body": "<p>Consider the following text:</p>\n<blockquote>\n<p id=\"so_26994755_26994755_0\"><code>[C++11: 12.4/11]:</code> Destructors are invoked implicitly</p>\n<ul>\n<li>for constructed objects with static storage duration (3.7.1) at program termination (3.6.3),</li>\n<li>for constructed objects with thread storage duration (3.7.2) at thread exit,</li>\n<li>for constructed objects with automatic storage duration (3.7.3) when the block in which an object is created exits (6.7),</li>\n<li>for constructed temporary objects when the lifetime of a temporary object ends (12.2),</li>\n<li>for constructed objects allocated by a <em>new-expression</em> (5.3.4), through use of a <em>delete-expression</em> (5.3.5),</li>\n<li>in several situations due to the handling of exceptions (15.3).</li>\n</ul>\n<p id=\"so_26994755_26994755_1\"><strong>A program is ill-formed if an object of class type or array thereof is declared and the destructor for the class is not accessible at the point of the declaration.</strong> Destructors can also be invoked explicitly.</p>\n</blockquote>\n<p>Then why does this program compile successfully?</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A \n{\n    A(){ };\n    ~A() = delete;\n};\n\nA* a = new A;\n\nint main() {}\n\n// g++ -std=c++11 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>Is GCC just being permissive?</p>\n<hr>\n<p>I'm inclined to say so, since it rejects the following yet <a href=\"https://stackoverflow.com/a/26994351/560648\">the standard appears to have no particular rule specific to deleted destructors in an inheritance hierarchy</a> (the only loosely relevant wording is pertinent to the generation of defaulted default constructors):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A \n{\n    A() {};\n    ~A() = delete;\n};\n\nstruct B : A {};\n\nB *b = new B; // error: use of deleted function\n\nint main() {}\n</code></pre>\n</hr>", "AcceptedAnswerId": "26995534", "Title": "Why am I permitted to declare an object with a deleted destructor?", "CreationDate": "2014-11-18T12:49:05.507", "Id": "26994755", "CommentCount": "18", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:08:38.670", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-18T13:38:28.973", "Score": "18", "OwnerUserId": "560648", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "4"}, "26994927": {"Id": "26994927", "PostTypeId": "2", "Body": "<p>It's that <code>B</code>'s destructor is generated by the compiler at the line of your error and it has a call to <code>A</code>'s destructor which is deleted, hence the error.  In the first example nothing is trying to call <code>A</code>'s destructor hence no error.</p>\n", "LastActivityDate": "2014-11-18T12:57:01.670", "CommentCount": "8", "CreationDate": "2014-11-18T12:57:01.670", "ParentId": "26994755", "Score": "3", "OwnerUserId": "1312406"}});