post_cb({"bq_ids": {"n4140": {"so_34616086_34616086_6": {"length": 34, "quality": 0.85, "section_id": 5878}, "so_34616086_34616086_5": {"length": 33, "quality": 0.7021276595744681, "section_id": 5878}, "so_34616086_34616086_1": {"length": 33, "quality": 0.7021276595744681, "section_id": 5878}, "so_34616086_34616086_3": {"length": 34, "quality": 0.85, "section_id": 5878}}, "n3337": {"so_34616086_34616086_6": {"length": 34, "quality": 0.85, "section_id": 5649}, "so_34616086_34616086_5": {"length": 33, "quality": 0.7021276595744681, "section_id": 5649}, "so_34616086_34616086_1": {"length": 33, "quality": 0.7021276595744681, "section_id": 5649}, "so_34616086_34616086_3": {"length": 34, "quality": 0.85, "section_id": 5649}}, "n4659": {"so_34616086_34641113_3": {"length": 29, "quality": 0.6744186046511628, "section_id": 7362}}}, "34616086": {"ViewCount": "753", "Body": "<h1>Background</h1>\n<p>Discussions on the mostly un-or-implementation-defined nature of type-punning via a <code>union</code> typically quote the following bits, here via @ecatmur ( <a href=\"https://stackoverflow.com/a/31557852/2757035\">https://stackoverflow.com/a/31557852/2757035</a> ), on an exemption for standard-layout <code>struct</code>s having a \"common initial sequence\" of member types:</p>\n<blockquote>\n<p id=\"so_34616086_34616086_0\">C11 (<strong>6.5.2.3 Structure and union members</strong>; <strong>Semantics</strong>):</p>\n<blockquote>\n<p id=\"so_34616086_34616086_5\">[...] if a union contains several structures that share a common initial sequence (see below), and if the union object currently\n    contains one of these structures, it is permitted to inspect the\n    common initial part of any of them <strong>anywhere that a declaration of\n    the completed type of the union is visible</strong>. Two structures share a\n    <em>common initial sequence</em> if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or\n    more initial members.</p>\n</blockquote>\n<p id=\"so_34616086_34616086_2\">C++03 (<strong>[class.mem]/16</strong>):</p>\n<blockquote>\n<p id=\"so_34616086_34616086_6\">If a POD-union contains two or more POD-structs that share a common initial sequence, and if the POD-union object currently contains one\n    of these POD-structs, it is permitted to inspect the common initial\n    part of any of them. Two POD-structs share a common initial sequence\n    if corresponding members have layout-compatible types (and, for\n    bit-fields, the same widths) for a sequence of one or more initial\n    members.</p>\n</blockquote>\n<p id=\"so_34616086_34616086_4\">Other versions of the two standards have similar language; since C++11\n  the terminology used is <em>standard-layout</em> rather than <em>POD</em>.</p>\n</blockquote>\n<p>Since no reinterpretation is required, this isn't really type-punning, just name substitution applied to <code>union</code> member accesses. A proposal for C++17 (the infamous P0137R1) makes this explicit using language like 'the access is as if the other struct member was nominated'.</p>\n<p>But please note the bold - \"<strong>anywhere that a declaration of the completed type of the union is visible</strong>\" - a clause that exists in C11 but nowhere in C++ drafts for 2003, 2011, or 2014 (all nearly identical, but later versions replace \"POD\" with the new term <em>standard layout</em>). In any case, the 'visible declaration of <code>union</code> type bit is totally absent in the corresponding section of any C++ standard.</p>\n<p>@loop and @Mints97, here - <a href=\"https://stackoverflow.com/a/28528989/2757035\">https://stackoverflow.com/a/28528989/2757035</a> - show that this line was also <strong>absent in C89, first appearing in C99</strong> and remaining in C since then (though, again, never filtering through to C++).</p>\n<h1>Standards discussions around this</h1>\n<p>[snipped - see my answer]</p>\n<h1>Questions</h1>\n<p>From this, then, my questions were:</p>\n<ul>\n<li><p><strong>What does this mean?</strong> What is classed as a 'visible declaration'? Was this clause intended to narrow down - or expand up - the range of contexts in which such 'punning' has defined behaviour?</p></li>\n<li><p><strong>Are we to assume that this omission in C++ is very deliberate?</strong></p></li>\n<li><p><strong>What is the reason for C++ differing from C?</strong> Did C++ just 'inherit' this from C89 and then either decide - or worse, <em>forget</em> - to update alongside C99?</p></li>\n<li><p>If the difference is intentional, then <strong>what benefits or drawbacks are there to the 2 different treatments in C vs C++?</strong></p></li>\n<li><p><strong>What, if any, interesting ramifications does it have at compile- or runtime?</strong> For example, @ecatmur, in a comment replying to my pointing this out on his original answer (link as above), speculated as follows.</p></li>\n</ul>\n<blockquote>\n<p id=\"so_34616086_34616086_7\">I'd imagine it permits more aggressive optimization; C can assume that\n  function arguments <code>S* s</code> and <code>T* t</code> do not alias even if they share a\n  common initial sequence as long as no <code>union { S; T; }</code> is in view,\n  while C++ can make that assumption only at link time. Might be worth\n  asking a separate question about that difference.</p>\n</blockquote>\n<p>Well, here I am, asking! I'm very interested in any thoughts about this, especially: other relevant parts of the (either) Standard, quotes from committee members or other esteemed commentators, insights from developers who might have noticed a practical difference due to this - assuming any compiler even <em>bothers</em> to enforce C's added clause - and etc. The aim is to generate a useful catalogue of relevant facts about this C clause and its (intentional or not) omission from C++. So, let's go!</p>\n", "AcceptedAnswerId": "34641113", "Title": "union 'punning' structs w/ \"common initial sequence\": Why does C (99+), but not C++, stipulate a 'visible declaration of the union type'?", "CreationDate": "2016-01-05T16:06:09.797", "Id": "34616086", "CommentCount": "8", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:45:40.193", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-05T15:55:07.283", "Score": "18", "OwnerUserId": "2757035", "Tags": "<c++><c><struct><unions><type-punning>", "AnswerCount": "2"}, "34616921": {"Id": "34616921", "PostTypeId": "2", "Body": "<p>I suspect it means that the access to these common parts is permitted not only through the union type, but outside of the union. That is, suppose we have this:</p>\n<pre><code>union u {\n  struct s1 m1;\n  struct s2 m2;\n};\n</code></pre>\n<p>Now suppose that in some function we have a <code>struct s1 *p1</code> pointer which we know was lifted from the <code>m1</code> member of such a union. We can cast this to a <code>struct s2 *</code> pointer and still access the members which are in common with <code>struct s1</code>.   But somewhere in the scope, a declaration of <code>union u</code> has to be visible. And it has to be the complete declaration, which informs the compiler that the members are <code>struct s1</code> and <code>struct s2</code>.</p>\n<p>The likely intent is that if there is such a type in scope, then the compiler has knowledge that <code>struct s1</code> and <code>struct s2</code> are aliased, and so an access through a <code>struct s1 *</code> pointer is suspected of really accessing a <code>struct s2</code> or vice versa.</p>\n<p>In the absence of any visible union type which joins those types this way, there is no such knowledge; strict aliasing can be applied.</p>\n<p>Since the wording is absent from C++, then to take advantage of the \"common initial members relaxation\" rule in that language, you have to route the accesses through the union type, as is commonly done anyway:</p>\n<pre><code>union u *ptr_any;\n// ...\nptr_any-&gt;m1.common_initial_member = 42;\nfun(ptr_any-&gt;m2.common_initial_member);  // pass 42 to fun\n</code></pre>\n", "LastActivityDate": "2016-01-05T16:47:34.940", "CommentCount": "25", "CreationDate": "2016-01-05T16:47:34.940", "ParentId": "34616086", "Score": "4", "OwnerUserId": "1250772"}, "34641113": {"Id": "34641113", "PostTypeId": "2", "Body": "<p>I've found my way through the labyrinth to some great sources on this, and I think I've got a pretty comprehensive summary of it. I'm posting this as an answer because it seems to explain both the (IMO very misguided) intention of the C clause and the fact that C++ does not inherit it. This will evolve over time if I discover further supporting material or the situation changes.</p>\n<p>This is my first time trying to sum up a very complex situation, which seems ill-defined even to many language architects, so I'll welcome clarifications/suggestions on how to improve this answer - or simply a better answer if anyone has one.</p>\n<h1>Finally, some concrete commentary</h1>\n<p>Through vaguely related threads, I found the following answer by @tab - and much appreciated the contained links to (illuminating, if not conclusive) GCC and Working Group defect reports: <a href=\"https://stackoverflow.com/a/19807355\">answer by tab on StackOverflow</a></p>\n<p>The GCC link contains some interesting discussion and reveals a sizeable amount of confusion and conflicting interpretations on part of the Committee and compiler vendors - surrounding the subject of <code>union</code> member <code>struct</code>s, punning, and aliasing in both C and C++.</p>\n<p>At the end of that, we're linked to the main event - another BugZilla thread, <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65892\" rel=\"nofollow noreferrer\">Bug 65892</a>, containing an <strong>extremely</strong> useful discussion. In particular, we find our way to the first of two pivotal documents:</p>\n<h1>Origin of the added line in C99</h1>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n685.htm\" rel=\"nofollow noreferrer\"><strong>C proposal N685</strong></a> is the origin of the added clause regarding visibility of a <code>union</code> type declaration. Through what some claim (see GCC thread #2) is a total misinterpretation of the \"common initial sequence\" allowance, N685 was indeed <strong>intended to allow relaxation of aliasing rules for \"common initial sequence\" <code>struct</code>s within a TU aware of some <code>union</code> containing instances of said <code>struct</code> types</strong>, as we can see from this quote:</p>\n<blockquote>\n<p id=\"so_34616086_34641113_0\">The proposed solution is to require that a union declaration be visible\n  if aliases through a common initial sequence (like the above) are possible.\n  Therefore the following TU provides this kind of aliasing if desired:</p>\n</blockquote>\n<pre><code>union utag {\n    struct tag1 { int m1; double d2; } st1;\n    struct tag2 { int m1; char c2; } st2;\n};\n\nint similar_func(struct tag1 *pst2, struct tag2 *pst3) {\n     pst2-&gt;m1 = 2;\n     pst3-&gt;m1 = 0;   /* might be an alias for pst2-&gt;m1 */\n     return pst2-&gt;m1;\n}\n</code></pre>\n<p>Judging by the GCC discussion and comments below such as @ecatmur's, this proposal - which seems to mandate speculatively allowing aliasing for any <code>struct</code> type that has some instance within some <code>union</code> visible to this TU - <strong>seems to have received great derision and rarely been implemented</strong>.</p>\n<p>It's obvious how difficult it would be to satisfy this interpretation of the added clause without totally crippling many optimisations - for little benefit, as few coders would want this guarantee, and those who do can just turn on <code>fno-strict-aliasing</code> (which IMO indicates larger problems). If implemented, this allowance is more likely to catch people out and spuriously interact with other declarations of <code>union</code>s, than to be useful.</p>\n<h1>Omission of the line from C++</h1>\n<p>Following on from this and a comment I made elsewhere, <a href=\"https://stackoverflow.com/a/19805106\">@Potatoswatter in this answer here on SO</a> states that:</p>\n<blockquote>\n<p id=\"so_34616086_34641113_1\">The visibility part was purposely omitted from C++ because it's widely considered to be ludicrous and unimplementable.</p>\n</blockquote>\n<p>In other words, <strong>it looks like C++ deliberately avoided adopting this added clause, likely due to its widely pereceived absurdity.</strong> On asking for an \"on the record\" citation of this, Potatoswatter provided the following key info about the thread's participants:</p>\n<blockquote>\n<p id=\"so_34616086_34641113_2\">The folks in that discussion are essentially \"on the record\" there. Andrew Pinski is a hardcore GCC backend guy. Martin Sebor is an active C committee member. Jonathan Wakely is an active C++ committee member and language/library implementer. That page is more authoritative, clear, and complete than anything I could write.</p>\n</blockquote>\n<p>Potatoswatter, in the same SO thread linked above, concludes that C++ deliberately excluded this line, leaving no special treatment (or, at best, implementation-defined treatment) for pointers into the common initial sequence. Whether their treatment will in future be specifically defined, versus any other pointers, remains to be seen; compare to my final section below about C. At present, though, it is not (and again, IMO, this is good).</p>\n<h1>What does this mean for C++ and practical C implementations?</h1>\n<p>So, with the nefarious line from N685... '<em>cast</em> aside'... we're back to assuming pointers into the common initial sequence are not special in terms of aliasing. Still. it's worth confirming what this paragraph in C++ means without it. Well, the 2nd GCC thread above links to another gem:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1719\" rel=\"nofollow noreferrer\"><strong>C++ defect 1719</strong></a>. This proposal has reached <strong>DRWP</strong> status: \"A DR issue whose resolution is reflected in the current Working Paper. The Working Paper is a draft for a future version of the Standard\" - <a href=\"https://social.msdn.microsoft.com/Forums/sqlserver/en-US/700569a7-18d3-4ddd-af0b-62bfe5aaf4d1/what-is-the-fastest-way-to-find-a-defect-in-the-c-standard-core-language-defect-report?forum=vcgeneral\" rel=\"nofollow noreferrer\">cite</a>. This is either post C++14 or at least after the final draft I have here (N3797) - and puts forward a <strong>significant, and in my opinion illuminating, rewrite of this paragraph's wording</strong>, as follows. I'm bolding what I consider to be the important changes, and <em>{these comments}</em> are mine:</p>\n<blockquote>\n<p id=\"so_34616086_34641113_3\">In a standard-layout <strong>union with an active member</strong> <em>{\"active\" indicates a <code>union</code> instance, not just type}</em> (9.5 [class.union])\n  of struct type <code>T1</code>, it is permitted to <strong>read</strong> <em>{formerly \"inspect\"}</em> a non-static data member <code>m</code>\n<strong>of another union member</strong> of struct type <code>T2</code> provided <code>m</code> is part of the\n  common initial sequence of <code>T1</code> and <code>T2</code>. [<em>Note</em>: Reading a volatile object\n  through a non-volatile glvalue has undefined behavior (7.1.6.1\n  [dcl.type.cv]). \u2014end note]</p>\n</blockquote>\n<p>This seems to clarify the meaning of the old wording: to me, it says that any specifically allowed <strong>'punning' among <code>union</code> member <code>struct</code>s with common initial sequences must be done <em>via an instance</em> of the parent <code>union</code></strong> - rather than being based on the type of the <code>structs</code> (e.g. pointers to them passed to some function). This wording seems to rule out any other interpretation, <em>a la</em> N685. C would do well to adopt this, I'd say. Hey, speaking of which, see below!</p>\n<p>The upshot is that - as nicely demonstrated by @ecatmur and in the GCC tickets - this leaves <strong>such <code>union</code> member <code>struct</code>s by definition in C++, and practically in C, subject to the same strict aliasing rules as any other 2 officially unrelated pointers.</strong> The explicit guarantee of being able to read the common initial sequence of inactive <code>union</code> member <code>struct</code>s is now more clearly defined, not including vague and unimaginably tedious-to-enforce \"visibility\" as <em>attempted</em> by N685 for C. By this definition, the main compilers have been behaving as intended for C++. As for C?</p>\n<h1>Possible reversal of this line in C / clarification in C++</h1>\n<p>It's also very worth noting that C committee member Martin Sebor is looking to get this fixed in that fine language, too:</p>\n<blockquote>\n<p id=\"so_34616086_34641113_4\"><strong>Martin Sebor 2015-04-27 14:57:16 UTC</strong> If one of you can explain the problem with it I'm willing to write up a paper and submit it to WG14 and request to have the standard changed.</p>\n<p id=\"so_34616086_34641113_5\"><strong>Martin Sebor 2015-05-13 16:02:41 UTC</strong> I had a chance to discuss this issue with Clark Nelson last week.  Clark has worked on improving the aliasing parts of the C specification in the past, for example in N1520 (<a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1520.htm\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1520.htm</a>). He agreed that like the issues pointed out in N1520, this is also an outstanding problem that would be worth for WG14 to revisit and fix.\"</p>\n</blockquote>\n<p>Potatoswatter inspiringly concludes:</p>\n<blockquote>\n<p id=\"so_34616086_34641113_6\">The C and C++ committees (via Martin and Clark) will try to find a consensus and hammer out wording so the standard can finally say what it means.</p>\n</blockquote>\n<p>We can only hope!</p>\n<p>Again, all further thoughts are welcome.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-05T15:55:07.283", "Score": "11", "CreationDate": "2016-01-06T19:23:26.293", "ParentId": "34616086", "CommentCount": "3", "OwnerUserId": "2757035", "LastEditDate": "2017-05-23T12:08:47.433"}});