post_cb({"bq_ids": {"n4140": {"so_28923515_28923630_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 135}, "so_28923515_28923515_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 102}}, "n3337": {"so_28923515_28923515_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 97}, "so_28923515_28923630_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 129}}, "n4659": {"so_28923515_28923515_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 106}, "so_28923515_28923630_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 139}}}, "28923515": {"ViewCount": "33", "Body": "<p>I want to define a member function for only pointers template parameters and for the rest of parameters types in another way. I tried the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T, class W&gt;\nstruct A\n{\n    void foo();\n};\n\ntemplate&lt;class T, class W&gt; void A&lt;T*, W*&gt;::foo(){ std::cout &lt;&lt; \"foo\" &lt;&lt; std::endl; }\nint main(){  }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/0ff2f89c7d12c94d\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>It's not clear why it's not working. I put pointers template arguments in the same order they were specified in the template declaration. Actually <code>N4296::14.5.1/3 [temp.class]</code>:</p>\n<blockquote>\n<p id=\"so_28923515_28923515_0\">The template argument list following the class template name in the\n  member definition shall name the parameters in the same order as the\n  one used in the template parameter list of the member.</p>\n</blockquote>\n<p>So why is the code not working? I put the parameters in the same order.</p>\n", "AcceptedAnswerId": "28923630", "Title": "Define a function outside a class template for pointers", "CreationDate": "2015-03-08T05:46:23.290", "Id": "28923515", "CommentCount": "5", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-03-08T06:06:01.810", "Score": "0", "Tags": "<c++><templates><pointers>", "AnswerCount": "1"}, "28923630": {"Id": "28923630", "PostTypeId": "2", "Body": "<p>You have to define the <em>entire struct</em> as a partial specialization, you can't just pick and choose individual members to specialize</p>\n<p>[temp.class.spec] </p>\n<blockquote>\n<p id=\"so_28923515_28923630_0\">1 [...] A partial specialization shall be declared before the \ufb01rst use of a class template specialization that would make use of the partial specialization as the result of an implicit or explicit instantiation in every translation unit in which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T, class W&gt;\nstruct A\n{\n  void foo();\n};\n\ntemplate&lt;class T, class W&gt;\nstruct A&lt;T*, W*&gt;\n{\n  void foo();\n};\n\ntemplate&lt;class T, class W&gt; void A&lt;T*, W*&gt;::foo() { std::cout &lt;&lt; \"foo\" &lt;&lt; std::endl; }\n\nint main() {}\n</code></pre>\n", "LastActivityDate": "2015-03-08T06:06:01.810", "CommentCount": "0", "CreationDate": "2015-03-08T06:06:01.810", "ParentId": "28923515", "Score": "0", "OwnerUserId": "657267"}});