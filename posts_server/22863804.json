post_cb({"bq_ids": {"n4140": {"so_22863804_22863899_5": {"length": 7, "quality": 0.6363636363636364, "section_id": 914}, "so_22863804_22863899_2": {"length": 7, "quality": 0.6363636363636364, "section_id": 914}, "so_22863804_22863899_4": {"length": 12, "quality": 0.8, "section_id": 810}, "so_22863804_22864073_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 914}, "so_22863804_22863899_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 810}}, "n3337": {"so_22863804_22863899_2": {"length": 8, "quality": 0.7272727272727273, "section_id": 902}, "so_22863804_22863899_5": {"length": 8, "quality": 0.7272727272727273, "section_id": 902}, "so_22863804_22863899_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 801}}, "n4659": {"so_22863804_22864073_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 975}, "so_22863804_22863899_2": {"length": 7, "quality": 0.6363636363636364, "section_id": 975}, "so_22863804_22863899_5": {"length": 7, "quality": 0.6363636363636364, "section_id": 975}}}, "22863899": {"Id": "22863899", "PostTypeId": "2", "Body": "<h2>Based on the January 2012 working draft</h2>\n<blockquote>\n<p id=\"so_22863804_22863899_0\">The January 2012 working draft contains the C++11 standard plus minor editorial changes.  </p>\n</blockquote>\n<p><a href=\"http://isocpp.org/std/the-standard\" rel=\"nofollow\">Source</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">working draft</a></p>\n<p>For <code>vector</code>:</p>\n<blockquote>\n<p id=\"so_22863804_22863899_1\"><code>void resize(size_type sz);</code><br>\n  E\ufb00ects: If <code>sz &lt;= size()</code>, equivalent to <code>erase(begin() + sz, end());</code>. If <code>size() &lt; sz</code>, appends\n  <code>sz - size()</code> value-initialized elements to the sequence.</br></p>\n</blockquote>\n<p><code>vector::erase</code> does not specify the order of removal. I would expect it to be in order from <code>begin() + sz</code> to <code>end()</code>, because that makes sense to me, but that is just my expectation. I can't find anything about it in the standard.</p>\n<p>The implementation of <code>vector</code> distributed with Visual Studio 2013 does appear to indeed erase in that order, as does MinGW's g++ 4.8.1 as well as g++ 4.7.3 (not MinGW). These are the compilers I happen to have easy access to.</p>\n<p>In the same standard, for <code>list</code>:</p>\n<blockquote>\n<p id=\"so_22863804_22863899_2\"><code>void resize(size_type sz);</code><br>\n  1 E\ufb00ects: If <code>size() &lt; sz</code>, appends <code>sz - size()</code> value-initialized elements to the sequence. If <code>sz &lt;= size()</code>, equivalent to</br></p>\n</blockquote>\n<pre><code>list&lt;T&gt;::iterator it = begin();\nadvance(it, sz);\nerase(it, end());\n</code></pre>\n<p>and</p>\n<blockquote>\n<p id=\"so_22863804_22863899_3\"><code>void resize(size_type sz, const T&amp; c);</code><br>\n  E\ufb00ects:</br></p>\n</blockquote>\n<pre><code>if (sz &gt; size())\n    insert(end(), sz-size(), c);\nelse if (sz &lt; size()) {\n    iterator i = begin();\n    advance(i, sz);\n    erase(i, end());\n}\nelse\n    ; // do nothing\n</code></pre>\n<p>It then goes on to specify absolutely nothing useful about ordering for <code>list::erase</code>.</p>\n<p>The implementation of <code>list</code> distributed with Visual Studio 2013 does appear to erase in reverse order, while MinGW's g++ 4.8.1 and g++ 4.7.3 (not MinGW) do not.</p>\n<h2>Based on the latest working draft at the time of writing</h2>\n<p><a href=\"http://isocpp.org/files/papers/N3797.pdf\" rel=\"nofollow\">Working draft</a></p>\n<p>For <code>vector</code></p>\n<blockquote>\n<p id=\"so_22863804_22863899_4\"><code>void resize(size_type sz);</code><br>\n  E\ufb00ects: If <code>sz &lt;= size()</code>, equivalent to calling <code>pop_back()</code> <code>size() - sz</code> times. If <code>size() &lt; sz</code>,\n  appends <code>sz - size()</code> default-inserted elements to the sequence.</br></p>\n</blockquote>\n<p>This indicates that elements are removed in reverse order.</p>\n<p>For <code>list</code>:</p>\n<blockquote>\n<p id=\"so_22863804_22863899_5\"><code>void resize(size_type sz);</code><br>\n  1 E\ufb00ects: If <code>size() &lt; sz</code>, appends <code>sz - size()</code> value-initialized elements to the sequence. If <code>sz &lt;= size()</code>, equivalent to</br></p>\n</blockquote>\n<pre><code>list&lt;T&gt;::iterator it = begin();\nadvance(it, sz);\nerase(it, end());\n</code></pre>\n<p>and</p>\n<blockquote>\n<p id=\"so_22863804_22863899_6\"><code>void resize(size_type sz, const T&amp; c);</code><br>\n  E\ufb00ects:</br></p>\n</blockquote>\n<pre><code>if (sz &gt; size())\n    insert(end(), sz-size(), c);\nelse if (sz &lt; size()) {\n    iterator i = begin();\n    advance(i, sz);\n    erase(i, end());\n}\nelse\n    ; // do nothing\n</code></pre>\n<p>It then goes on to specify absolutely nothing useful about ordering for <code>list::erase</code>.</p>\n<p>For <code>deque</code> the standard specifies the same behavior as for <code>vector</code>.</p>\n", "LastEditorUserId": "2700399", "LastActivityDate": "2014-04-05T07:47:40.780", "Score": "14", "CreationDate": "2014-04-04T13:14:33.193", "ParentId": "22863804", "CommentCount": "12", "OwnerUserId": "2700399", "LastEditDate": "2014-04-05T07:47:40.780"}, "22863804": {"ViewCount": "624", "Body": "<p>If I have a standard C++ container <code>std::vector&lt;Bar&gt;</code> and I shrink it by calling <code>.resize()</code> with a size smaller than the current <code>.size()</code>, in which order are the extra elements destroyed?</p>\n<p>(Implementation choices are interesting if you can find two implementations which differ.) </p>\n<p>(This was inspired by a comment from <a href=\"https://stackoverflow.com/users/649665/james-kanze\">James Kanze</a>.)</p>\n", "AcceptedAnswerId": "22863899", "Title": "When shrinking a container via resize, in which order are the elements destroyed?", "CreationDate": "2014-04-04T13:09:59.800", "Id": "22863804", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:20:53.810", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-05T07:47:40.780", "Score": "26", "OwnerUserId": "15416", "Tags": "<c++>", "AnswerCount": "3"}, "22864073": {"Id": "22864073", "PostTypeId": "2", "Body": "<p>It depends on the container. For example the effect of applying resize to vectors is the following</p>\n<pre><code>12 Effects: If sz &lt;= size(), equivalent to calling pop_back() size() - sz times\n</code></pre>\n<p>So for vectors the order of destroying of elemeents starts from the last element.</p>\n<p>For lists the approach is other</p>\n<blockquote>\n<p id=\"so_22863804_22864073_0\">Effects: If size() &lt; sz, appends sz - size() default-inserted elements\n  to the sequence. If sz &lt;= size(), equivalent to list::iterator it =\n  begin(); advance(it, sz); erase(it, end());</p>\n</blockquote>\n<p>But there is nothing said in which order the elements are erased.</p>\n", "LastActivityDate": "2014-04-04T13:23:12.083", "CommentCount": "13", "CreationDate": "2014-04-04T13:23:12.083", "ParentId": "22863804", "Score": "3", "OwnerUserId": "2877241"}, "22865268": {"Id": "22865268", "PostTypeId": "2", "Body": "<p>With the exception of <code>std::basic_string</code> and\n<code>std::forward_list</code>, the standard defines <code>resize</code> in terms of\n<code>erase</code> (in cases where the new size is smaller than the\noriginal size), so the question is really: does <code>erase(\u00a0begin, end\u00a0)</code> specify any order of destruction.  And all that I can\nfind here is in Table 100, which says that <code>erase( q1, q2 )</code>\n\"Erases the elements in the range <code>[q1, q2)</code>\".  Which (to me, at\nleast) still leaves the question open: when the standard uses\nthe notation <code>[q1, q2)</code> (where <code>q1</code> and <code>q2</code> are iterators),\ndoes it imply in order, or not?  A priori, I would think not.\nAt least in the <code>&lt;algorithms&gt;</code> section, it explicitly states\nwhen the operations must be in order (and the fact that it\nexplicitly states it in some specific cases sort of suggests\nthat it isn't required in cases where it isn't specified).</p>\n<p>For what it's worth: for <code>std::list&lt;&gt;::resize()</code>, g++ calls\ndelete in ascending order; VS in descending order.  In the case\nof VS, this is different than the order of destruction of\n<code>std::list&lt;&gt;::erase</code> (which may be legal, if the order of\ndestruction is unspecified, and allowed to vary from one call to\nthe next).</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2014-04-04T14:33:45.443", "Score": "5", "CreationDate": "2014-04-04T14:15:08.727", "ParentId": "22863804", "CommentCount": "2", "OwnerUserId": "649665", "LastEditDate": "2014-04-04T14:33:45.443"}});