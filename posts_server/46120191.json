post_cb({"bq_ids": {"n4140": {"so_46120191_46120385_0": {"length": 38, "quality": 0.95, "section_id": 3314}}, "n3337": {"so_46120191_46120385_0": {"length": 34, "quality": 0.85, "section_id": 3184}}, "n4659": {"so_46120191_46120385_0": {"length": 38, "quality": 0.95, "section_id": 4080}}}, "46120289": {"Id": "46120289", "PostTypeId": "2", "Body": "<p>An embedded <code>null</code> is NOT Undefined Behavior. It <em>could</em> be a logic error, if you work with functions that expect Strings to be null-terminated. But there's nothing wrong or evil or undefined about accessing the full breadth of an array you've successfully allocated, regardless of its contents.</p>\n<p>One thing to observe though: if you attempt to store this data in a <code>std::string</code> (which is how you should handle all strings, TBH), <em>how</em> you store the string can be important.</p>\n<pre><code>std::string str1 = foo; //contents of str1 becomes \"abc\".\nstd::string str2 = std::string(foo, sizeof(foo)); //contents of str2 becomes \"abc\\0def\"\n</code></pre>\n", "LastActivityDate": "2017-09-08T15:51:39.103", "CommentCount": "0", "CreationDate": "2017-09-08T15:51:39.103", "ParentId": "46120191", "Score": "3", "OwnerUserId": "5241642"}, "46120565": {"Id": "46120565", "PostTypeId": "2", "Body": "<p>Accessing a C string beyound the terminating null character per se <em>never</em> is undefined behaviour. Still, we <em>can</em> yield undefined behaviour this way, but for a totally different reason:</p>\n<p>If the terminating null character happens to reside at the last position in the char array reserved for the string, then we access this underlying array out of its bounds if we access the string beyond its end. And this out-of-bounds-access is what really yields the undefined behaviour...</p>\n<p>Edit:</p>\n<blockquote>\n<p id=\"so_46120191_46120565_0\">[aside: is that UB?]</p>\n</blockquote>\n<p>UB, undefined behaviour, is behaviour that cannot be defined, because there is no meaningful behaviour for. Relying on undefined behaviour can result in anything, including getting the expected results, but can fail miserably any other time (e. g. on another platform, after switching compiler version, after simply recompiling, even after just restarting one and the same program). Thus a program relying on undefined behaviour is considered not to be well defined.</p>\n<p>Example: Dereferencing a pointer pointing to an object that has already been deleted (a \"dangling pointer\"), or close to the question: accessing an array out of bounds (could result in trying to access memory not asigned to the current process or even not existing, but could read or (<em>bad!!!</em>) overwrite memory of a totally different object that happens to be located at the given address (it does not even have to be the same object every time your program runs, not even within one single program run).</p>\n<p>Undefined behaviour is not to be mixed up with unspecified behaviour (or synonymously, implementation defined behaviour): In this case, the behaviour for a given input is well defined, but it is left to the compiler vendor to define the behaviour within some given reasonable limitations.</p>\n<p>Example: right shift of negative integers - it can occur with or without sign extension (so can be an arithmetic or a logical shift). Which one applies is not specified by the standard, though, but using right shift on negative integers is well defined.</p>\n", "LastEditorUserId": "1312382", "LastActivityDate": "2017-09-08T16:37:49.037", "Score": "2", "CreationDate": "2017-09-08T16:07:36.247", "ParentId": "46120191", "CommentCount": "4", "OwnerUserId": "1312382", "LastEditDate": "2017-09-08T16:37:49.037"}, "46120191": {"ViewCount": "43", "Body": "<p>If I have an embedded null terminator [aside: is that UB?], is it well-defined for me to access the values after it?</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nconst char foo[] = \"abc\\0def\";\nint main() {\n  printf(\"%s\", foo+4);\n  return sizeof(foo);\n}\n</code></pre>\n<p>For the record, it prints what you might expect:</p>\n<pre><code>def\n</code></pre>\n", "Title": "Is accessing parts of a string after an embedded null terminator UB?", "CreationDate": "2017-09-08T15:45:37.440", "LastActivityDate": "2017-09-08T16:37:49.037", "CommentCount": "2", "LastEditDate": "2017-09-08T15:48:59.773", "PostTypeId": "1", "LastEditorUserId": "65863", "Id": "46120191", "Score": "0", "OwnerUserId": "1572626", "Tags": "<c++><undefined-behavior>", "AnswerCount": "3"}, "46120385": {"Id": "46120385", "PostTypeId": "2", "Body": "<p>[dcl.init.string] states</p>\n<blockquote>\n<p id=\"so_46120191_46120385_0\">An array of narrow character type (3.9.1), char16_t array, char32_t array, or wchar_t array can be initialized by a narrow string literal, char16_t string literal, char32_t string literal, or wide string literal, respectively, or by an appropriately-typed string literal enclosed in braces (2.14.5). <strong>Successive characters of the value of the string literal initialize the elements of the array.</strong></p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>So the embedded null it not a problem, it just becomes a element of the array.  Since the array is sized to container all the characters and escape sequeneces we know there are elements after that embedded null and it is safe to access those.</p>\n<p>Really the only issue with the embedded null is that any C function is going to stop when it hits that null and won't full process the string.  You might consider using a <code>std::string</code> instead which doesn't have those issues.</p>\n", "LastActivityDate": "2017-09-08T15:56:21.633", "CommentCount": "0", "CreationDate": "2017-09-08T15:56:21.633", "ParentId": "46120191", "Score": "2", "OwnerUserId": "4342498"}});