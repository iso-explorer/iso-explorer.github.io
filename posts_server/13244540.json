post_cb({"bq_ids": {"n4140": {"so_13244540_13245532_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 6259}}, "n3337": {"so_13244540_13245532_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 6019}}, "n4659": {"so_13244540_13245532_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 7763}}}, "13244610": {"Id": "13244610", "PostTypeId": "2", "Body": "<p>To be honest, I don't see the point of casting from int to int. You can simply write:</p>\n<pre><code>int l = y1;\n</code></pre>\n<p>but if you really want to convert int to int, below code shall work.</p>\n<pre><code>int l = static_cast&lt;int&gt;(y1); \n</code></pre>\n", "LastEditorUserId": "951757", "LastActivityDate": "2012-11-06T04:58:40.933", "Score": "1", "CreationDate": "2012-11-06T04:53:24.197", "ParentId": "13244540", "CommentCount": "0", "OwnerUserId": "951757", "LastEditDate": "2012-11-06T04:58:40.933"}, "13244540": {"ViewCount": "742", "Body": "<p>In a couple of my projects, the following code:</p>\n<pre><code>#include &lt;functional&gt;\n\nclass SmallClass\n{\npublic:\n    int x1, y1;\n\n    void TestFunc()\n    {\n        auto BadLambda = [&amp;]()\n        {\n            int g = x1 + 1; //ok\n            int h = y1 + 1; //c2296\n\n            int l = static_cast&lt;int&gt;(y1); //c2440\n        };\n\n        int y1_copy = y1; //it works if you create a local copy\n        auto GoodLambda = [&amp;]()\n        {\n            int h = y1_copy + 1; //ok\n            int l = this-&gt;y1 + 1; //ok\n        };\n    }\n};\n</code></pre>\n<p>generates</p>\n<blockquote>\n<p id=\"so_13244540_13244540_0\">error C2296: '+' : illegal, left operand has type 'double (__cdecl\n  *)(double)'</p>\n</blockquote>\n<p>or alternatively</p>\n<blockquote>\n<p id=\"so_13244540_13244540_1\">error C2440: 'static_cast' : cannot convert from 'double (__cdecl\n  *)(double)' to 'int'</p>\n</blockquote>\n<p>You get the picture. It also happens if catching by value.</p>\n<p>The error seems to be tied to the member name \"y1\". It happened in different classes, different projects and with (seemingly) any type for y1; for example, this code:</p>\n<pre><code>[...]\nMyClass y1;\n\nvoid TestFunc()\n{\n    auto BadLambda = [&amp;]()-&gt;void\n    {\n        int l = static_cast&lt;int&gt;(y1); //c2440\n    };\n}\n</code></pre>\n<p>generates both these errors:</p>\n<blockquote>\n<p id=\"so_13244540_13244540_2\">error C2440: 'static_cast' : cannot convert from 'MyClass' to 'int' No\n  user-defined-conversion operator available that can perform this\n  conversion, or the operator cannot be called</p>\n<p id=\"so_13244540_13244540_3\">error C2440: 'static_cast' : cannot convert from 'double (__cdecl\n  *)(double)' to 'int' There is no context in which this conversion is possible</p>\n</blockquote>\n<p>It seems to be linked to the \"functional\" library. It happens (on my machine) in a minimal project which includes only \"functional\" (yes, it's supposed to be between brackets, but I fail at HTML).</p>\n<p>It doesn't seem to be a known bug, and I'm at a loss. Any ideas as to why this happens? (I don't need a workaround; there are a few in the code already).</p>\n<p>Edit: it is, indeed, related to functions from math.h:</p>\n<p><code>\n_CRT_NONSTDC_DEPRECATE(_cabs) _CRTIMP double  __cdecl cabs(<em>In</em> struct _complex _X);\n_CRT_NONSTDC_DEPRECATE(_j0) _CRTIMP double  __cdecl j0(<em>In</em> double _X);\n_CRT_NONSTDC_DEPRECATE(_j1) _CRTIMP double  __cdecl j1(<em>In</em> double _X);\n_CRT_NONSTDC_DEPRECATE(_jn) _CRTIMP double  __cdecl jn(<em>In</em> int _X, <em>In</em> double _Y);\n_CRT_NONSTDC_DEPRECATE(_y0) _CRTIMP double  __cdecl y0(<em>In</em> double _X);\n_CRT_NONSTDC_DEPRECATE(_y1) _CRTIMP double  __cdecl y1(<em>In</em> double _X);\n_CRT_NONSTDC_DEPRECATE(_yn) _CRTIMP double  __cdecl yn(<em>In</em> int _X, <em>In</em> double _Y);\n</code></p>\n<p>Using any of those function names triggers the bug. It happens when including math.h, cmath or functional. Maybe someone has a clue as to how those names got in the scope of my lambda expressions?</p>\n<p>Edit: solved. It's a lambda name resolution issue in VS2010 (and possibly other older compilers). Avoid using unqualified names in lambdas if you define global names or use \"using namespace x\".</p>\n<p>Using Visual Studio 2010 Express version 10.0.40219.1 SP1Rel.</p>\n", "AcceptedAnswerId": "13245532", "Title": "Weird bug with C++ lambda expressions in VS2010 ( variable y1 )", "CreationDate": "2012-11-06T04:44:55.573", "Id": "13244540", "CommentCount": "10", "LastEditDate": "2012-11-06T15:18:56.363", "PostTypeId": "1", "LastEditorUserId": "1801919", "LastActivityDate": "2012-11-06T17:17:18.407", "Score": "3", "OwnerUserId": "1801919", "Tags": "<c++><visual-studio-2010><lambda>", "AnswerCount": "3"}, "13244582": {"Id": "13244582", "PostTypeId": "2", "Body": "<p>The class compiles on my VS2010, I only edited one line: <code>int l = static_cast(y1); //c2440</code></p>\n<p>was changed to: <code>int l = static_cast&lt;int&gt;(y1);</code></p>\n<p>Although a seemingly cool bug, try and use a good convention for naming variables. Make them descriptive but not too long. Read the book : \"Practice of Programming\" by Rob Pike and Kernighan to get a better perspective on naming variables and using a consistent style and formatting.</p>\n<h2>EDIT:</h2>\n<p>I <code>#include &lt;cmath&gt;</code> and <code>using namespace std;</code>. I get no errors, but if I create a <code>class MyClass{};</code> and create an object <code>MyClass y1</code>, I get an error stating <code>\"..previous definition 'function'\"</code>.  The <code>y1</code> inside class <code>SimpleClass</code> is never affected. </p>\n", "LastEditorUserId": "1680957", "LastActivityDate": "2012-11-06T05:48:01.550", "Score": "0", "CreationDate": "2012-11-06T04:50:38.217", "ParentId": "13244540", "CommentCount": "3", "OwnerUserId": "1680957", "LastEditDate": "2012-11-06T05:48:01.550"}, "13245532": {"Id": "13245532", "PostTypeId": "2", "Body": "<p>The use of <code>y1</code> conflicts with the <code>y1</code> in <code>&lt;cmath&gt;</code> (the Bessel function of the second kind, order 1). This is why the <code>std::</code> namespace is a Good Thing(sm) and why it should not be circumvented with <code>using namespace std;</code>. (<code>using std::string</code> is fine, though, imho.) Of course, not all C++ <code>cmath</code> headers properly place all names only in namespace <code>std</code>, but they should; there are too many short names in the math library.</p>\n<p>C++ name resolution rules are complicated, and I don't pretend to understand all the little dusty corners. It's quite possible that unqualified names in a lambda are not looked up in exactly the same way as unqualified names in the actual body of a member function. Outside of member functions, unqualified names can only refer to class members which have already been declared. (<code>this-&gt;y1</code> is not an unqualified name, though.)</p>\n<hr>\n<p><strong>EDIT</strong>: It turns out to be a bug in VC10 which applies incorrect name resolution rules in lambdas. Name resolution bugs in lambda expressions were reported <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/713679\" rel=\"nofollow\">several</a> <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/736295\" rel=\"nofollow\">times</a> but these bugs are marked as fixed in VC12 (having said that, I have no idea how to find bug reports which have not been marked as fixed). I stand by my suggestions below, although the one about using explicit <code>this-&gt;</code> is perhaps more controversial, but I've been burned a few times by unexpected name lookup and explicit qualification can help.</p>\n<hr>\n<p>On the whole, my suggestions are:</p>\n<p>1) Never use <code>using namespace std;</code> and</p>\n<p>2) Always use <code>this-&gt;</code> if that is what you mean. (Or, at a minimum, use the trailing <code>_</code> convention for class data members.)</p>\n<hr>\n<p><strong>EDIT</strong> Use of <code>std</code> namespace by C library headers.</p>\n<blockquote>\n<p id=\"so_13244540_13245532_0\">17.6.1.2(4): In the C++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace std. It is unspecified whether these names are first declared within the global namespace scope and are then injected into namespace std by explicit using-declarations (7.3.3).</p>\n</blockquote>\n<p>In other words, the names <em>must</em> be in <code>std::</code> and <em>may</em> be in the global namespace. So using <code>std::</code> consistently doesn't hurt. It might not help, but it also might protect you from some future standard library that doesn't inject these names into the global namespace.</p>\n</hr></hr></hr>", "LastEditorUserId": "1566221", "LastActivityDate": "2012-11-06T17:17:18.407", "Score": "3", "CreationDate": "2012-11-06T06:24:06.917", "ParentId": "13244540", "CommentCount": "2", "OwnerUserId": "1566221", "LastEditDate": "2012-11-06T17:17:18.407"}});