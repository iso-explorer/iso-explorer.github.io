post_cb({"bq_ids": {"n4140": {"so_27314485_27314556_4": {"length": 81, "quality": 0.9204545454545454, "section_id": 3296}, "so_27314485_27314556_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3296}, "so_27314485_27314556_3": {"length": 6, "quality": 1.0, "section_id": 3296}}, "n3337": {"so_27314485_27314556_4": {"length": 81, "quality": 0.9204545454545454, "section_id": 3166}, "so_27314485_27314556_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3166}, "so_27314485_27314556_3": {"length": 6, "quality": 1.0, "section_id": 3166}}, "n4659": {"so_27314485_27314556_4": {"length": 60, "quality": 0.6818181818181818, "section_id": 4058}, "so_27314485_27314556_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 4058}, "so_27314485_27314556_3": {"length": 6, "quality": 1.0, "section_id": 4058}}}, "27314485": {"ViewCount": "8784", "Body": "<p>I want to use an <code>std::atomic_int</code> variable. In my code, I have:</p>\n<pre><code>#include &lt;atomic&gt;\n\nstd::atomic_int stop = 0;\n\nint main()\n{\n    // Do something\n}\n</code></pre>\n<p>And this gives me a compile error:</p>\n<pre><code>use of deleted function 'std::__atomic_base&lt;_IntTp&gt;::__atomic_base(const std::__atomic_base&lt;_IntTp&gt;&amp;) [with _ITp = int]'\n std::atomic_int stop = 0;\n                        ^\n</code></pre>\n<p>Any idea on what's going on?</p>\n", "AcceptedAnswerId": "27314556", "Title": "\"Use of deleted function\" error with std::atomic_int", "CreationDate": "2014-12-05T11:06:21.427", "Id": "27314485", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-05T11:26:06.427", "LastEditorUserId": "3320135", "LastActivityDate": "2014-12-05T16:33:16.310", "Score": "11", "OwnerUserId": "3320135", "Tags": "<c++><c++11><stdatomic>", "AnswerCount": "1"}, "27314556": {"Id": "27314556", "PostTypeId": "2", "Body": "<p>Your code is attempting to construct a temporary <code>std::atomic_int</code> on the RHS, then use the <code>std::atomic_int</code> copy constructor (which is <code>delete</code>d) to initialise <code>stop</code>, like so:</p>\n<pre><code>std::atomic_int stop = std::atomic_int(0);\n</code></pre>\n<p>That's because <em>copy-initialisation</em>, as you are performing here, is not quite equivalent to other kinds of initialisation.</p>\n<blockquote>\n<p id=\"so_27314485_27314556_0\"><code>[C++11: 8.5/16]:</code> The semantics of initializers are as follows <em>[..]</em></p>\n<p id=\"so_27314485_27314556_1\"><strong>If the initializer is a (non-parenthesized) braced-init-list, the object or reference is <em>list-initialized</em></strong> (8.5.4).</p>\n</blockquote>\n<p>(this allows for option 3, at the end of this answer)</p>\n<blockquote>\n<p id=\"so_27314485_27314556_2\"><em>[..]</em></p>\n<p id=\"so_27314485_27314556_3\"><strong>If the destination type is a (possibly cv-qualified) class type:</strong></p>\n<ul>\n<li>If the initialization is <em>direct-initialization</em>, or <strong>if it is <em>copy-initialization</em> where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered.</strong> The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n</ul>\n</blockquote>\n<p>(this almost describes your code but not quite; the key here is that, perhaps contrary to intuition, <code>std::atomic_int</code>'s constructors are not considered at all in your case!)</p>\n<blockquote id=\"so_27314485_27314556_4\">\n<ul>\n<li><strong>Otherwise (i.e., for the remaining <em>copy-initialization</em> cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed.</strong> The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified version of the destination type. The temporary is a prvalue. <strong>The result of the call (which is the temporary for the constructor case) is then used to <em>direct-initialize</em>, according to the rules above, the object that is the destination of the <em>copy-initialization</em>.</strong> In certain cases, an implementation is permitted to eliminate the copying inherent in this <em>direct-initialization</em> by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</li>\n</ul>\n</blockquote>\n<p>(this is your scenario; so, although the copy can be elided, it still must be possible)</p>\n<blockquote id=\"so_27314485_27314556_5\">\n<ul>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<hr>\n<p>Here's the fix, anyway; use <em>direct-initialisation</em> or <em>list-initialisation</em>:</p>\n<pre><code>std::atomic_int stop(0);     // option 1\nstd::atomic_int stop{0};     // option 2\nstd::atomic_int stop = {0};  // option 3\n</code></pre>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2014-12-05T16:33:16.310", "Score": "11", "CreationDate": "2014-12-05T11:09:30.870", "ParentId": "27314485", "CommentCount": "8", "OwnerUserId": "560648", "LastEditDate": "2014-12-05T16:33:16.310"}});