post_cb({"bq_ids": {"n4140": {"so_22540292_22540625_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 989}}, "n3337": {"so_22540292_22540625_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 974}}, "n4659": {"so_22540292_22540625_0": {"length": 21, "quality": 0.875, "section_id": 1052}}}, "22540625": {"Id": "22540625", "PostTypeId": "2", "Body": "<p>The destructor should only be called for the element(s) being erased; if you are seeing it called for the others, then your <code>vector</code> implementation isn't conformant. C++11 23.3.6.5\nspecifies</p>\n<blockquote>\n<p id=\"so_22540292_22540625_0\"><em>Complexity</em>: The destructor of T is called the number of times equal to the number of the elements\n  erased, but the move assignment operator of T is called the number of times equal to the number of\n  elements in the vector after the erased elements.</p>\n</blockquote>\n<p>Older standards specified similar behaviour, but with copy rather than move-assignment.</p>\n<p>Your example shows <code>1</code> five times because the remaining destructors are called when the vector is destroyed at the end of <code>main</code>. You can see this more clearly if you output something immediately after the call to <code>erase</code>.</p>\n", "LastActivityDate": "2014-03-20T17:23:48.240", "CommentCount": "1", "CreationDate": "2014-03-20T17:23:48.240", "ParentId": "22540292", "Score": "4", "OwnerUserId": "204847"}, "22540292": {"ViewCount": "89", "Body": "<p>My question is about optimizing the <code>vector::erase</code> function. </p>\n<p>Since we know the vector is a continuous memory chunk and also know each element's size in the container, why does the <code>vector&lt;myclass&gt; v</code>'s <code>erase(v.begin())</code> method still call all the destructors of elements in <code>v</code>? Can it do a bytewise shift? </p>\n<p>Example:\nSay you have</p>\n<pre><code>//compiled with g++ 4.7\n#include&lt;iostream&gt;\nusing namespace std;\nclass barebone{\npublic:\n  ~barebone(){\n    cout &lt;&lt; \"1\" &lt;&lt; endl;\n  }\n};\n\nint main(){\n    vector&lt;barebone&gt; x(5);\n    x.erase(x.begin());\n    cout &lt;&lt; \"done\" &lt;&lt; endl;\n}\n</code></pre>\n<p>This will call destructor for each elements in container (5 times). This will show 5 ones. a bytewise shift will be faster and call destructor only once </p>\n<p><strong>EDIT</strong>: From the reply erase() call destructor once with output </p>\n<p>1\n   done\n   1\n   1\n   1\n   1</p>\n", "AcceptedAnswerId": "22540625", "Title": "faster deletion of vector type", "CreationDate": "2014-03-20T17:08:47.137", "Id": "22540292", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-03-20T17:37:47.000", "LastEditorUserId": "2789784", "LastActivityDate": "2014-03-20T17:37:47.000", "Score": "0", "OwnerUserId": "2789784", "Tags": "<c++><vector><stdvector>", "AnswerCount": "2"}, "22540859": {"Id": "22540859", "PostTypeId": "2", "Body": "<p>I don't buy it.  I wrote a test program, and after the erase the destructor is called only one time.  I suggest that you do the same and see for yourself.  </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass TestObject\n{\n    public:\n    static int counter;\n    TestObject()  { std::cout &lt;&lt; \"constructed!\" &lt;&lt; std::endl; }\n    ~TestObject() { std::cout &lt;&lt; \"destructed!\" &lt;&lt; std::endl; counter++;}\n};\n\nint TestObject::counter = 0;\n\nint main()\n{\n   std::vector&lt;TestObject&gt; to(5);\n   to.erase(to.begin());\n   std::cout &lt;&lt; \"destructed \" &lt;&lt; TestObject::counter &lt;&lt; \" times\" &lt;&lt; std::endl;\n\n   to.push_back(TestObject());\n\n   return 0;\n}\n</code></pre>\n<p>Here is the output.</p>\n<p>Compiling the source code.... $g++ -std=c++11 main.cpp -o demo -lm\n-pthread -lgmpxx -lgmp -lreadline 2&gt;&amp;1</p>\n<p>Executing the program.... $demo  constructed! constructed! constructed! constructed! constructed! destructed! destructed 1 times constructed! destructed! destructed! destructed! destructed! destructed! destructed!</p>\n<p>Clearly, the destructor executed once after the erase.  Now if you had the erase as the last thing followed by a cout in your own example it is possible that you thought that it was destroyed 5 times by the erase.</p>\n", "LastActivityDate": "2014-03-20T17:34:15.067", "CommentCount": "0", "CreationDate": "2014-03-20T17:34:15.067", "ParentId": "22540292", "Score": "0", "OwnerUserId": "2993440"}});