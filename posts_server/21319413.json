post_cb({"bq_ids": {"n4140": {"so_21319413_21319414_2": {"length": 13, "quality": 0.52, "section_id": 5937}, "so_21319413_21319413_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 6185}}, "n3337": {"so_21319413_21319414_2": {"length": 13, "quality": 0.52, "section_id": 5709}, "so_21319413_21319413_0": {"length": 20, "quality": 0.7407407407407407, "section_id": 5946}}, "n4659": {"so_21319413_21319414_2": {"length": 13, "quality": 0.52, "section_id": 7421}, "so_21319413_21319413_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 7687}}}, "21320640": {"Id": "21320640", "PostTypeId": "2", "Body": "<p>When we talk about <em>undefined behavior</em>, it is important to remember that the Standard leaves the behavior undefined for these cases.  It does not prohibit implementations from making stronger guarantees.  For example some implementations may guarantee that signed integer overflow wraps around, while others may guarantee saturation.</p>\n<p>Requiring compilers to process constant expressions involving undefined behavior would limit the guarantees that an implementation could make, restricting them to producing some value without side effects (what the Standard calls <em>indeterminate value</em>).  That excludes a lot of the extended guarantees found in the real world.</p>\n<p>For example, some implementation or companion standard (i.e. POSIX) may define the behavior of integral division by zero to generate a signal.  That's a side effect which would be lost if the expression were calculated at compile-time instead.</p>\n<p>So, these expressions are rejected at compile-time to avoid loss of side effects in the execution environment.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-01-24T04:06:52.800", "Score": "19", "CreationDate": "2014-01-23T22:27:51.500", "ParentId": "21319413", "CommentCount": "12", "OwnerUserId": "103167", "LastEditDate": "2014-01-24T04:06:52.800"}, "21319413": {"ViewCount": "2170", "Body": "<p>I was researching what is allowed in a <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"noreferrer\">core constant expression*</a>, which is covered in section <code>5.19</code> <em>Constant expressions</em> paragraph <em>2</em> of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"noreferrer\">draft C++ standard</a> which says:</p>\n<blockquote>\n<p id=\"so_21319413_21319413_0\">A conditional-expression is a core constant expression unless it involves one of the following as a potentially evaluated subexpression (3.2), but subexpressions of logical AND (5.14), logical OR (5.15), and conditional (5.16) operations that are not evaluated are not considered [ Note: An overloaded operator invokes a function.\u2014end note ]:</p>\n</blockquote>\n<p>and lists out the exclusions in the bullets that follows and includes (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_21319413_21319413_1\">\u2014 <strong>an operation that would have undefined behavior</strong> [ Note: including, for example, signed integer overflow (Clause 5), certain pointer arithmetic (5.7), division by zero (5.6), or certain shift operations (5.8) \u2014end note ];</p>\n</blockquote>\n<p><em>Huh</em>? Why do <em>constant expressions</em> need this clause to cover <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"noreferrer\">undefined behavior</a>? Is there something special about <em>constant expressions</em> that requires <em>undefined behavior</em> to have a special carve out in the exclusions?</p>\n<p>Does having this clause give us any advantages or tools we would not have without it?</p>\n<p>For reference, this looks like the last revision of the proposal for <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf\" rel=\"noreferrer\">Generalized Constant Expressions</a>.</p>\n", "Title": "Why do constant expressions have an exclusion for undefined behavior?", "CreationDate": "2014-01-23T21:12:02.447", "LastActivityDate": "2015-05-31T14:55:09.270", "CommentCount": "4", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2014-12-15T16:44:38.760", "LastEditorUserId": "1708801", "Id": "21319413", "Score": "42", "OwnerUserId": "1708801", "Tags": "<c++><c++11><undefined-behavior><sfinae><constexpr>", "AnswerCount": "3"}, "21320161": {"Id": "21320161", "PostTypeId": "2", "Body": "<p>There is another point to excluding undefined behavior from constant expressions: constant expressions should, by definition, be evaluated by the compiler at compile time. Allowing a constant expression to invoke undefined behavior would allow the compiler itself to show undefined behavior. And a compiler that formats your hard-drive because you <em>compile</em> some evil code is not something you want to have.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-01-28T04:54:53.697", "Score": "6", "CreationDate": "2014-01-23T21:55:41.857", "ParentId": "21319413", "CommentCount": "6", "OwnerUserId": "2445184", "LastEditDate": "2014-01-28T04:54:53.697"}, "21319414": {"Id": "21319414", "PostTypeId": "2", "Body": "<p>The wording is actually the subject of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1313\" rel=\"nofollow noreferrer\">defect report #1313</a> which says:</p>\n<blockquote>\n<p id=\"so_21319413_21319414_0\">The requirements for constant expressions do not currently, but should, exclude expressions that have undefined behavior, such as pointer arithmetic when the pointers do not point to elements of the same array.</p>\n</blockquote>\n<p>The resolution being the current wording we have now, so this clearly was intended, so what tools does this give us?</p>\n<p>Let's see what happens when we try to create a <em>constexpr variable</em> with an expression that contains <em>undefined behavior</em>, we will use <code>clang</code> for all the following examples. This code (<em><a href=\"http://coliru.stacked-crooked.com/a/5f177328ad8c52a7\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>constexpr int x = std::numeric_limits&lt;int&gt;::max() + 1 ;\n</code></pre>\n<p>produces the following error:</p>\n<pre><code>error: constexpr variable 'x' must be initialized by a constant expression\n    constexpr int x = std::numeric_limits&lt;int&gt;::max() + 1 ;\n                  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: value 2147483648 is outside the range of representable values of type 'int'\n    constexpr int x = std::numeric_limits&lt;int&gt;::max() + 1 ;\n                                       ^\n</code></pre>\n<p>This code (<em><a href=\"http://coliru.stacked-crooked.com/a/6f51c0b7b8e697f1\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>constexpr int x = 1 &lt;&lt; 33 ;  // Assuming 32-bit int\n</code></pre>\n<p>produces this error:</p>\n<pre><code>error: constexpr variable 'x' must be initialized by a constant expression\n    constexpr int x = 1 &lt;&lt; 33 ;  // Assuming 32-bit int\n             ^   ~~~~~~~\nnote: shift count 33 &gt;= width of type 'int' (32 bits)\n    constexpr int x = 1 &lt;&lt; 33 ;  // Assuming 32-bit int\n                  ^\n</code></pre>\n<p>and this code which has undefined behavior in a constexpr function:</p>\n<pre><code>constexpr const char *str = \"Hello World\" ;      \n\nconstexpr char access( int index )\n{\n    return str[index] ;\n}\n\nint main()\n{\n    constexpr char ch = access( 20 ) ;\n}\n</code></pre>\n<p>produces this error:</p>\n<pre><code>error: constexpr variable 'ch' must be initialized by a constant expression\n    constexpr char ch = access( 20 ) ;\n                   ^    ~~~~~~~~~~~~\n\n note: cannot refer to element 20 of array of 12 elements in a constant expression\n    return str[index] ;\n           ^\n</code></pre>\n<p>Well that is useful the compiler can detect <em>undefined behavior</em> in <em>constexpr</em>, or at least what <code>clang</code> believes is <em>undefined</em>. Note, <code>gcc</code> behaves the same except in the case of undefined behavior with right and left shift, <code>gcc</code> will usually produce a warning in these cases but still sees the expression as constant.</p>\n<p>We can use this functionality via <em>SFINAE</em> to detect whether an addition expression would cause overflow, the following contrived example was inspired by dyp's <a href=\"https://stackoverflow.com/a/19877048/1708801\">clever answer here</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\ntemplate &lt;typename T1, typename T2&gt;\nstruct addIsDefined\n{\n     template &lt;T1 t1, T2 t2&gt;\n     static constexpr bool isDefined()\n     {\n         return isDefinedHelper&lt;t1,t2&gt;(0) ;\n     }\n\n     template &lt;T1 t1, T2 t2, decltype( t1 + t2 ) result = t1+t2&gt;\n     static constexpr bool isDefinedHelper(int)\n     {\n         return true ;\n     }\n\n     template &lt;T1 t1, T2 t2&gt;\n     static constexpr bool isDefinedHelper(...)\n     {\n         return false ;\n     }\n};\n\n\nint main()\n{    \n    std::cout &lt;&lt; std::boolalpha &lt;&lt;\n      addIsDefined&lt;int,int&gt;::isDefined&lt;10,10&gt;() &lt;&lt; std::endl ;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt;\n     addIsDefined&lt;int,int&gt;::isDefined&lt;std::numeric_limits&lt;int&gt;::max(),1&gt;() &lt;&lt; std::endl ;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt;\n      addIsDefined&lt;unsigned int,unsigned int&gt;::isDefined&lt;std::numeric_limits&lt;unsigned int&gt;::max(),std::numeric_limits&lt;unsigned int&gt;::max()&gt;() &lt;&lt; std::endl ;\n}\n</code></pre>\n<p>which results in (<em><a href=\"http://coliru.stacked-crooked.com/a/98fabf47c1bc031e\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>true\nfalse\ntrue\n</code></pre>\n<p>It is not evident that the standard requires this behavior but apparently this <a href=\"https://stackoverflow.com/questions/19593938/is-left-shifting-a-negative-integer-undefined-behavior-in-c11#comment29091986_19593938\">comment by Howard Hinnant</a> indicates it indeed is:</p>\n<blockquote>\n<p id=\"so_21319413_21319414_1\">[...] and is also constexpr, meaning UB is caught at compile time</p>\n</blockquote>\n<p><b>Update</b></p>\n<p>Somehow I missed <a href=\"http://wg21.cmeerw.net/cwg/issue695\" rel=\"nofollow noreferrer\">Issue 695 Compile-time calculation errors in constexpr functions</a> which revolves over the wording of section <code>5</code> paragraph <em>4</em> which used to say (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_21319413_21319414_2\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined, <strong>unless such an expression appears where an integral constant expression is required (5.19 [expr.const]), in which case the program is ill-formed</strong>. </p>\n</blockquote>\n<p>and goes on to say:</p>\n<blockquote>\n<p id=\"so_21319413_21319414_3\">intended as an acceptable Standardese circumlocution for \u201cevaluated at compile time,\u201d a concept that is not directly defined by the Standard. It is not clear that this formulation adequately covers constexpr functions.</p>\n</blockquote>\n<p>and a later note says:</p>\n<blockquote>\n<p id=\"so_21319413_21319414_4\">[...]There is a tension between wanting to diagnose errors at compile time versus not diagnosing errors that will not actually occur at runtime.[...]The consensus of the CWG was that an expression like 1/0 should simply be considered non-constant; <strong>any diagnostic would result from the use of the expression in a context requiring a constant expression.</strong></p>\n</blockquote>\n<p>which if I am reading correctly confirms the intention was to be able to diagnose undefined behavior at compile time in the context requiring a constant expression.</p>\n<p>We can not definitely say this was the intent but is does strongly suggest it was. The difference in how <code>clang</code> and <code>gcc</code> treat undefined shifts does leave some room for doubt.</p>\n<p>I filed a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60049\" rel=\"nofollow noreferrer\">gcc bug report: Right and left shift undefined behavior not an error in a constexpr</a>. Although it seems like this is conforming, it does break SFINAE and we can see from my answer to <a href=\"https://stackoverflow.com/a/27744080/170880\">Is it a conforming compiler extension to treat non-constexpr standard library functions as constexpr?</a> that divergence in implementation observable to SFINAE users seems undesirable to the committee. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-31T14:55:09.270", "Score": "38", "CreationDate": "2014-01-23T21:12:02.447", "ParentId": "21319413", "CommentCount": "5", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:54:09.493"}});