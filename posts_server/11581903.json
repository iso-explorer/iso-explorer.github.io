post_cb({"bq_ids": {"n4140": {"so_11581903_11661602_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 6007}, "so_11581903_11661602_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5997}, "so_11581903_11581903_0": {"length": 33, "quality": 0.868421052631579, "section_id": 7230}, "so_11581903_11661184_4": {"length": 10, "quality": 1.0, "section_id": 5940}, "so_11581903_11661184_2": {"length": 5, "quality": 1.0, "section_id": 5940}, "so_11581903_11661602_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 6133}, "so_11581903_11661184_5": {"length": 21, "quality": 0.9130434782608695, "section_id": 5940}, "so_11581903_11661184_3": {"length": 13, "quality": 1.0, "section_id": 5940}, "so_11581903_11661184_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 5940}, "so_11581903_11661602_3": {"length": 14, "quality": 0.7, "section_id": 5999}, "so_11581903_11661184_1": {"length": 13, "quality": 1.0, "section_id": 5940}}, "n3337": {"so_11581903_11661602_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5765}, "so_11581903_11581903_0": {"length": 33, "quality": 0.868421052631579, "section_id": 6974}, "so_11581903_11661184_3": {"length": 13, "quality": 1.0, "section_id": 5711}, "so_11581903_11661184_4": {"length": 10, "quality": 1.0, "section_id": 5711}, "so_11581903_11661184_2": {"length": 5, "quality": 1.0, "section_id": 5711}, "so_11581903_11661602_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 5897}, "so_11581903_11661184_5": {"length": 21, "quality": 0.9130434782608695, "section_id": 5711}, "so_11581903_11661602_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 5775}, "so_11581903_11661184_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 5711}, "so_11581903_11661602_3": {"length": 14, "quality": 0.7, "section_id": 5767}, "so_11581903_11661184_1": {"length": 13, "quality": 1.0, "section_id": 5711}}, "n4659": {"so_11581903_11661602_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 7630}, "so_11581903_11661602_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 7498}, "so_11581903_11661184_4": {"length": 10, "quality": 1.0, "section_id": 7424}, "so_11581903_11661184_5": {"length": 21, "quality": 0.9130434782608695, "section_id": 7424}, "so_11581903_11661184_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 7424}, "so_11581903_11661602_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 7506}, "so_11581903_11661184_3": {"length": 13, "quality": 1.0, "section_id": 7424}, "so_11581903_11661184_2": {"length": 5, "quality": 1.0, "section_id": 7424}, "so_11581903_11661602_3": {"length": 12, "quality": 0.6, "section_id": 7500}, "so_11581903_11661184_1": {"length": 13, "quality": 1.0, "section_id": 7424}}}, "11661649": {"Id": "11661649", "PostTypeId": "2", "Body": "<p>What I gather from what I've read is that calling something an xvalue is a fancy way of saying:</p>\n<p>An xvalue is just an rvalue whose storage may have been deallocated, so using it means you have to verify its existence by yourself.</p>\n<p>Generally, it's one or more levels of indirection away from an actual rvalue.</p>\n<p>By contrast, an rvalue is guaranteed to have its storage space existing as long as it is in scope.</p>\n<p>I may be wrong but this is what I've understood.</p>\n", "LastActivityDate": "2012-07-26T02:53:45.273", "CommentCount": "7", "CreationDate": "2012-07-26T02:53:45.273", "ParentId": "11581903", "Score": "0", "OwnerUserId": "541686"}, "11661602": {"Id": "11661602", "PostTypeId": "2", "Body": "<p>Clause 5, which describes the syntax of valid expressions, lists for each expression syntax the conditions in which the expression is an lvalue, an xvalue, or a prvalue.  The complete list of possible xvalues from clause 5 is:</p>\n<blockquote>\n<p id=\"so_11581903_11661602_0\">5.2.2 paragraph 10: A function call is ... an xvalue if the result type is an rvalue reference to object type.</p>\n</blockquote>\n<p>(In the technical language of the Standard, \"object type\" doesn't mean the same as \"class type\".  \"Object type\" includes fundamental types, pointers, and arrays, and excludes only function types.  An rvalue reference to function type is always treated as an lvalue, not xvalue.)</p>\n<p>The most notable functions which return an rvalue reference are of course <code>std::move</code> and sometimes <code>std::forward</code>.</p>\n<blockquote>\n<p id=\"so_11581903_11661602_1\">5.2.5 paragraph 4: If <code>E2</code> is a non-static data member ... if <code>E1</code> is an xvalue, then <code>E1.E2</code> is an xvalue</p>\n</blockquote>\n<p>(On the other hand, a data member lookup <code>E1-&gt;E2</code> is always an lvalue.)</p>\n<p>Similarly, if <code>E1</code> is an xvalue, then the data member lookup <code>E1.*E2</code> is an xvalue:</p>\n<blockquote>\n<p id=\"so_11581903_11661602_2\">5.5 paragraph 6: The result of a <code>.*</code> expression whose second operand is a pointer to a data member is of the same value category (3.10) as its first operand.</p>\n</blockquote>\n<p>For the various types of casts:</p>\n<ul>\n<li><code>dynamic_cast&lt;Type&gt;(expr)</code>: 5.2.7 paragraph 2</li>\n<li><code>static_cast&lt;Type&gt;(expr)</code>: 5.2.9 paragraph 1</li>\n<li><code>reinterpret_cast&lt;Type&gt;(expr)</code>: 5.2.10 paragraph 1</li>\n<li><code>const_cast&lt;Type&gt;(expr)</code>: 5.2.11 paragraph 1</li>\n<li><code>(Type) expr</code>: 5.4 paragraph 1</li>\n</ul>\n<p>the expression is an xvalue if and only if <code>Type</code> is an rvalue reference to object type.  The same is also true for <code>Type(expr)</code>, since</p>\n<blockquote>\n<p id=\"so_11581903_11661602_3\">5.2.3 paragraph 1: If the expression list [in parentheses following a type name] is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4).</p>\n</blockquote>\n<p>(On the other hand, <code>Type{expr}</code> is always a prvalue.)</p>\n<p>Section 5.16 on the conditional operator ends up saying that <code>A ? B : C</code> can sometimes be an xvalue if B and/or C is an xvalue.  But the complete rules are difficult to summarize.</p>\n<p>If an expression ends up calling a user-defined overloaded operator function, then section 5.2.2 applies to that expression, not the one that describes the built-in operator's behavior.  (See the expression <code>a + a</code> in the example @James posted.)</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2012-07-26T03:02:44.640", "Score": "4", "CreationDate": "2012-07-26T02:47:40.470", "ParentId": "11581903", "CommentCount": "0", "OwnerUserId": "459640", "LastEditDate": "2012-07-26T03:02:44.640"}, "11581903": {"ViewCount": "2944", "Body": "<p>I'm trying to understand the C++11 concepts.</p>\n<p>The standard draft which I have says:</p>\n<blockquote>\n<p id=\"so_11581903_11581903_0\">An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually near the end of its lifetime (so that its\n      resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving\n      rvalue references (8.3.2). [ Example: The result of calling a function whose return type is an rvalue\n      reference is an xvalue. \u2014end example ]</p>\n</blockquote>\n<p>OK, so what exactly <em>are</em> the \"certain kinds of expressions\" that produce xvalues? This part of the spec does not detail a list of these expressions.</p>\n<p>I understand lvalue and prvalue (at least I think, I understand).</p>\n", "AcceptedAnswerId": "11661184", "Title": "What expressions create xvalues?", "CreationDate": "2012-07-20T15:01:47.660", "Id": "11581903", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-07-26T01:30:56.673", "LastEditorUserId": "500104", "LastActivityDate": "2012-07-26T03:02:44.640", "Score": "21", "OwnerUserId": "1183123", "Tags": "<c++><c++11><language-lawyer><xvalue>", "AnswerCount": "3"}, "11661184": {"Id": "11661184", "PostTypeId": "2", "Body": "<p>There is a helpful non-normative note in the introduction to \u00a75 (C++11 \u00a75[expr]/6):</p>\n<blockquote>\n<p id=\"so_11581903_11661184_0\">[ Note: An expression is an xvalue if it is:</p>\n<ul>\n<li><p id=\"so_11581903_11661184_1\">the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to object type,</p></li>\n<li><p id=\"so_11581903_11661184_2\">a cast to an rvalue reference to object type,</p></li>\n<li><p id=\"so_11581903_11661184_3\">a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or</p></li>\n<li><p id=\"so_11581903_11661184_4\">a <code>.*</code> pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.</p></li>\n</ul>\n<p id=\"so_11581903_11661184_5\">In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether named or not. \u2014end note ]</p>\n</blockquote>\n<p>Searching through the rest of \u00a75, this list appears exhaustive.  The list is followed by an example:</p>\n<blockquote>\n<pre><code>struct A {\n    int m;\n};\n\nA&amp;&amp; operator+(A, A);\nA&amp;&amp; f();\nA a;\nA&amp;&amp; ar = static_cast&lt;A&amp;&amp;&gt;(a);\n</code></pre>\n<p id=\"so_11581903_11661184_6\">The expressions <code>f()</code>, <code>f().m</code>, <code>static_cast&lt;A&amp;&amp;&gt;(a)</code>, and <code>a + a</code> are xvalues. The expression <code>ar</code> is an lvalue.</p>\n</blockquote>\n<p>There are two common ways to get an xvalue expression:</p>\n<ul>\n<li><p>Use <code>std::move</code> to move an object.  <code>std::move</code> performs a <code>static_cast</code> to an rvalue reference type and returns the rvalue reference.</p></li>\n<li><p>Use <code>std::forward</code> to forward an rvalue.  <code>std::forward</code> is typically used in a function template to enable perfect forwarding of a function argument.</p>\n<p>If the argument provided to the function template was an rvalue, the parameter type will be an rvalue reference, which is an lvalue.  In this case, <code>std::forward</code> performs a <code>static_cast</code> to an rvalue reference type and returns the rvalue reference.</p>\n<p>(Note:  If the argument provided to the function template was an lvalue, the parameter type will be an lvalue reference and <code>std::forward</code> will return an lvalue reference.)</p></li>\n</ul>\n", "LastEditorUserId": "151292", "LastActivityDate": "2012-07-26T02:07:40.890", "Score": "17", "CreationDate": "2012-07-26T01:43:28.273", "ParentId": "11581903", "CommentCount": "5", "OwnerUserId": "151292", "LastEditDate": "2012-07-26T02:07:40.890"}});