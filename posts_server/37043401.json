post_cb({"bq_ids": {"n4140": {"so_37043401_37043401_0": {"length": 4, "quality": 0.8, "section_id": 5}, "so_37043401_37055970_5": {"length": 7, "quality": 1.0, "section_id": 6173}, "so_37043401_37055970_3": {"length": 12, "quality": 1.0, "section_id": 9}, "so_37043401_37055970_1": {"length": 9, "quality": 1.0, "section_id": 5997}, "so_37043401_37055970_4": {"length": 8, "quality": 1.0, "section_id": 9}, "so_37043401_37055970_0": {"length": 9, "quality": 0.9, "section_id": 763}, "so_37043401_37055970_2": {"length": 11, "quality": 1.0, "section_id": 6175}}, "n3337": {"so_37043401_37043401_0": {"length": 4, "quality": 0.8, "section_id": 2}, "so_37043401_37055970_5": {"length": 7, "quality": 1.0, "section_id": 5934}, "so_37043401_37055970_3": {"length": 12, "quality": 1.0, "section_id": 6}, "so_37043401_37055970_1": {"length": 9, "quality": 1.0, "section_id": 5765}, "so_37043401_37055970_2": {"length": 11, "quality": 1.0, "section_id": 5936}, "so_37043401_37055970_0": {"length": 9, "quality": 0.9, "section_id": 750}, "so_37043401_37055970_4": {"length": 8, "quality": 1.0, "section_id": 6}}, "n4659": {"so_37043401_37043401_0": {"length": 4, "quality": 0.8, "section_id": 5}, "so_37043401_37055970_5": {"length": 7, "quality": 1.0, "section_id": 7675}, "so_37043401_37055970_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 4087}, "so_37043401_37055970_1": {"length": 9, "quality": 1.0, "section_id": 7498}, "so_37043401_37055970_4": {"length": 8, "quality": 1.0, "section_id": 10}, "so_37043401_37055970_0": {"length": 8, "quality": 0.8, "section_id": 616}, "so_37043401_37055970_2": {"length": 11, "quality": 1.0, "section_id": 7677}}}, "37043401": {"ViewCount": "295", "Body": "<p>Consider the minimal example below:</p>\n<pre><code>#include&lt;utility&gt;\n\nstruct S { };\n\nint main() {\n    S s;\n    std::move(s) = S{};\n}\n</code></pre>\n<p>It compiles with no errors.<br>\nIf I use non class types instead, I get an error.<br>\nAs an example, the code below doesn't compile:</br></br></p>\n<pre><code>#include&lt;utility&gt;\n\nint main() {\n    int i;\n    std::move(i) = 42;\n}\n</code></pre>\n<p>The same happens with enums, scoped enums, and so on.<br>\nThe error (from GCC) is:</br></p>\n<blockquote>\n<p id=\"so_37043401_37043401_0\">using xvalue (rvalue reference) as lvalue</p>\n</blockquote>\n<p>What's the rationale behind this?  </p>\n<p>I guess it's right, but I'd like to understand what's the reason for which I can do that with all the types but the non class ones.</p>\n", "AcceptedAnswerId": "37055970", "Title": "xvalues: differences between non class types and class types", "CreationDate": "2016-05-05T05:55:43.433", "Id": "37043401", "CommentCount": "12", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2016-05-05T17:18:28.777", "LastEditorUserId": "4987285", "LastActivityDate": "2016-05-06T09:16:07.043", "Score": "9", "OwnerUserId": "4987285", "Tags": "<c++><c++11><move><rvalue><xvalue>", "AnswerCount": "2"}, "37055970": {"Id": "37055970", "PostTypeId": "2", "Body": "<p><sub>\nI'm trying to reply to my own question with a bunch of links to the standard.<br>\nI'm quite sure that I'll write something that is <em>terribly</em> wrong and someone will come banding words with me.<br>\nWell, I did my best to explain how one can deduce from the standard what's described in the question.<br>\nFeel free to downvote if needed, but please let me know what's wrong so as to be able to fix the answer and understand the error.<br>\nThank you.\n</br></br></br></br></sub></p>\n<hr>\n<p><a href=\"http://eel.is/c++draft/basic.types#8\" rel=\"nofollow\">3.9/8</a> (types):</p>\n<blockquote>\n<p id=\"so_37043401_37055970_0\">An\u00a0<em>object type</em>\u00a0is a (possibly cv-qualified) type that is not a function type, not a reference type, and not\u00a0<em>cv</em> void.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/expr.call#10\" rel=\"nofollow\">5.2.2/10</a> (expressions, function call):</p>\n<blockquote>\n<p id=\"so_37043401_37055970_1\">A function call is [...] an xvalue if the result type is an rvalue reference to object type</p>\n</blockquote>\n<p>Thus <code>std::move</code> is an <em>xvalue</em> expression in either cases.</p>\n<p><a href=\"http://eel.is/c++draft/expr.ass#3\" rel=\"nofollow\">5.18/3</a> (assignment):</p>\n<blockquote>\n<p id=\"so_37043401_37055970_2\">If the left operand is not of class type, the expression is implicitly converted [...] to the cv-unqualified type of the left operand.</p>\n</blockquote>\n<p>This does not add useful information, but it's for the sake of completeness.</p>\n<p><s>\n<a href=\"http://eel.is/c++draft/conv.lval#2\" rel=\"nofollow\">4.1/2</a> (lvalue-to-rvalue conversion):</s></p>\n<blockquote>\n<p id=\"so_37043401_37055970_3\">Otherwise, if\u00a0T\u00a0has a class type, the conversion copy-initializes a temporary of type\u00a0T\u00a0from the glvalue and the result of the conversion is a prvalue for the temporary.</p>\n<p id=\"so_37043401_37055970_4\">Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/class.temporary\" rel=\"nofollow\">12.2</a> (temporary objects) does the rest.</p>\n<p>So, as mentioned by @xaxxon in the comments, I was actually trying to do (let me write) <code>42 = 0;</code> and it is not a valid expression in C++.\n</p></hr>\n<p>As correctly pointed out in the comments by @bogdan, the right part of the standard to which to refer in this case is <a href=\"http://eel.is/c++draft/expr.ass#1\" rel=\"nofollow\">5.18/1</a> (Assignment):</p>\n<blockquote>\n<p id=\"so_37043401_37055970_5\">All require a modifiable lvalue as their left operand [...]</p>\n</blockquote>\n<p>While <a href=\"http://eel.is/c++draft/expr#2\" rel=\"nofollow\">5/2</a> and <a href=\"http://eel.is/c++draft/expr#3\" rel=\"nofollow\">5/3</a> clarify that the statement applies to built-in operators only.</p>\n", "LastEditorUserId": "4987285", "LastActivityDate": "2016-05-06T09:16:07.043", "Score": "1", "CreationDate": "2016-05-05T16:47:44.327", "ParentId": "37043401", "CommentCount": "9", "LastEditDate": "2016-05-06T09:16:07.043", "OwnerUserId": "4987285"}, "37045177": {"Id": "37045177", "PostTypeId": "2", "Body": "<p>C++ allows assignment to class object rvalues, but not primitive type rvalues;</p>\n<p>An example,</p>\n<pre><code>string s1, s2;\ns1 + s2 = \"asdf\"; // ok since rvalue s1 + s2 is an object\n\nint i1, i2;\ni1 + i2 = 10;  // error, since i1 + i2 is a primitive type\n</code></pre>\n<p>The same rule applies to your question. std::move(s) returns a rvalue of an object type, but std::move(i) returns a rvalue of a primitive type.</p>\n", "LastActivityDate": "2016-05-05T07:42:43.753", "CommentCount": "2", "CreationDate": "2016-05-05T07:42:43.753", "ParentId": "37043401", "Score": "4", "OwnerUserId": "2663486"}});