post_cb({"bq_ids": {"n4140": {"so_34899524_34899663_0": {"length": 18, "quality": 0.9, "section_id": 603}, "so_34899524_34899663_1": {"length": 6, "quality": 1.0, "section_id": 126}}, "n3337": {"so_34899524_34899663_0": {"length": 18, "quality": 0.9, "section_id": 593}, "so_34899524_34899663_1": {"length": 6, "quality": 1.0, "section_id": 120}}, "n4659": {"so_34899524_34899663_0": {"length": 18, "quality": 0.9, "section_id": 629}, "so_34899524_34899663_1": {"length": 6, "quality": 1.0, "section_id": 131}}}, "34899663": {"Id": "34899663", "PostTypeId": "2", "Body": "<p>1) Because there is no problem here. There is template function, function template specialization and overloading. You can call template specialization like this:</p>\n<pre><code>wow.foo&lt;int&gt;(3);\n</code></pre>\n<p>2) Overload has better match, than template specialization, if compiler can call this function with arg.</p>\n<p>n4926 13.3.3/1.7</p>\n<blockquote>\n<p id=\"so_34899524_34899663_0\">Given these definitions, a viable function F1 is defined to be a\n  better function than another viable function F2 if for all arguments\n  i, ICSi(F1) is not a worse conversion sequence than ICSi(F2) , and\n  then</p>\n<p id=\"so_34899524_34899663_1\">F1 is not a function template specialization and F2 is a function\n  template specialization</p>\n</blockquote>\n", "LastActivityDate": "2016-01-20T12:07:58.447", "CommentCount": "0", "CreationDate": "2016-01-20T12:07:58.447", "ParentId": "34899524", "Score": "1", "OwnerUserId": "1498580"}, "34899524": {"ViewCount": "34", "Body": "<p>Consider</p>\n<pre><code>Class Wow{\n    public:\n        //main metod\n        template&lt;typename T&gt;\n        void foo(T t){\n            cout &lt;&lt; t &lt;&lt; endl;\n        }\n\n        template&lt;&gt;\n        void foo&lt;int&gt;(int t){\n            cout &lt;&lt; \"specialization\" &lt;&lt; endl;\n        }\n\n        void foo(int t){\n            cout &lt;&lt; \"overloading\" &lt;&lt; endl;\n        }\n}\n</code></pre>\n<p>and the main is</p>\n<pre><code>Wow wow;\nwow.foo(2.2);\nwow.foo(1);\n</code></pre>\n<p>this outputs</p>\n<pre><code>2.2\noverloading\n</code></pre>\n<p>My question is why does that even compile?\npractically, <code>foo</code> is defined twice as <code>void foo(int)</code>.</p>\n<p>1) why does this pass?</p>\n<p>2) why does the compiler choose the overloading one?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "34899663", "Title": "not getting expected ambiguity on template specialization and overloading c++", "CreationDate": "2016-01-20T12:02:27.407", "Id": "34899524", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-01-20T12:07:58.447", "Score": "1", "OwnerUserId": "913098", "Tags": "<c++><method-overloading><template-specialization>", "AnswerCount": "1"}});