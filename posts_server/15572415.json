post_cb({"bq_ids": {"n4140": {"so_15572415_15572442_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 72}}, "n3337": {"so_15572415_15572442_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 67}}}, "15572442": {"PostTypeId": "2", "Body": "<p>The problem is syntactic. You should use the <code>template</code> disambiguator in this case, so that your invocation of a member function template will be correctly parsed:</p>\n<pre><code>return (G.template getSC&lt;SC&lt;T&gt; &gt;().value * S.template getSC&lt;SC&lt;T&gt; &gt;().value);\n//        ^^^^^^^^^                          ^^^^^^^^^\n</code></pre>\n<p>This disambiguator helps the compiler recognizing that what follows <code>G.</code> is a <em>member template specialization</em> and not, for instance, a data member called <code>getSC</code> followed by a <code>&lt;</code> (less than).</p>\n<p>The Standard reference for the <code>template</code> disambiguator is Paragraph 14.2/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15572415_15572442_0\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a postfix-expression or after a <em>nested-name-specifier</em> in a <em>qualified-id</em>, and the object expression of the <em>postfix-expression</em> is type-dependent or the <em>nested-name-specifier</em> in the qualified-id refers to a dependent type, but the name is not a member of the current instantiation (14.6.2.1), <strong>the member template name must be prefixed by the keyword <code>template</code>. Otherwise the name is assumed to name a non-template.</strong>[ <em>Example:</em></p>\n<pre><code>struct X {\ntemplate&lt;std::size_t&gt; X* alloc();\ntemplate&lt;std::size_t&gt; static X* adjust();\n};\ntemplate&lt;class T&gt; void f(T* p) {\nT* p1 = p-&gt;alloc&lt;200&gt;(); // ill-formed: &lt; means less than\nT* p2 = p-&gt;template alloc&lt;200&gt;(); // OK: &lt; starts template argument list\nT::adjust&lt;100&gt;(); // ill-formed: &lt; means less than\nT::template adjust&lt;100&gt;(); // OK: &lt; starts template argument list\n}\n</code></pre>\n<p id=\"so_15572415_15572442_1\">\u2014<em>end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2013-03-26T23:56:26.287", "LastEditorUserId": "1932150", "Id": "15572442", "CommentCount": "10", "CreationDate": "2013-03-22T14:12:03.347", "ParentId": "15572415", "Score": "41", "OwnerUserId": "1932150", "LastEditDate": "2013-03-26T23:56:26.287"}, "15572415": {"ViewCount": "3506", "Body": "<p>This code fails to compile on g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3, with this error</p>\n<pre><code>test.cpp: In function \u2018T mul(V&amp;, V&amp;)\u2019:\ntest.cpp:38:27: error: expected primary-expression before \u2018&gt;\u2019 token\ntest.cpp:38:29: error: expected primary-expression before \u2018)\u2019 token\ntest.cpp:38:53: error: expected primary-expression before \u2018&gt;\u2019 token\ntest.cpp:38:55: error: expected primary-expression before \u2018)\u2019 token\n</code></pre>\n<p>but it compiles and executes correctly on Microsoft C/C++ Optimizing Compiler Version 15.00.21022.08 for x64</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n\ntemplate &lt;class T&gt;\nclass SM\n{\npublic:\n    T value;\n};\n\ntemplate &lt;class T&gt;\nclass SC : public SM&lt;T&gt;\n{\n};\n\nclass PSSM {\n\npublic:\n    template &lt;class T&gt;\n    T &amp; getSC() { return sc; }\n\nprivate:\n    SC&lt;double&gt; sc;\n};\n\nclass USSM {\n\npublic:\n    template &lt;class T&gt;\n    T &amp; getSC() { return sc; }\n\nprivate:\n    SC&lt;std::complex&lt;double&gt; &gt; sc;\n};\n\ntemplate &lt;class T, class V&gt;\nT mul( V &amp; G, V &amp; S) {\n    return (G.getSC&lt;SC&lt;T&gt; &gt;().value * S.getSC&lt;SC&lt;T&gt; &gt;().value); // error is here\n}\n\n\nint main() {\n    PSSM p;\n    PSSM q;\n    p.getSC&lt;SC&lt;double&gt; &gt;().value = 5; \n    q.getSC&lt;SC&lt;double&gt; &gt;().value = 3; \n\n    std::cout &lt;&lt; mul&lt;double&gt;(p,q);\n\n}\n</code></pre>\n<p>I don't understand where the problem is. Can anyone understand how to work around it, or explain the nature of the problem in g++?</p>\n", "AcceptedAnswerId": "15572442", "Title": "expected primary-expression before \">\" in g++ but not in microsoft compiler", "CreationDate": "2013-03-22T14:10:17.350", "Id": "15572415", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-03-22T14:19:47.340", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-26T23:56:26.287", "Score": "20", "OwnerUserId": "78374", "Tags": "<c++><templates>", "AnswerCount": "1"}});