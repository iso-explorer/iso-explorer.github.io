post_cb({"34667733": {"CommentCount": "6", "ViewCount": "531", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2016-01-08T00:41:20.803", "LastActivityDate": "2016-01-08T01:27:45.073", "Title": "Why do I get a type deduction error for a lambda returning lambda with multiple return paths?", "AcceptedAnswerId": "34667761", "LastEditDate": "2016-01-08T01:18:46.217", "Id": "34667733", "Score": "6", "Body": "<p>I have the following code:</p>\n<pre><code>int main() {\n    auto f = [] {\n        if (1) return [] { return 1; };\n        else return [] { return 2; };\n    };\n    return f()();\n}\n</code></pre>\n<p>which raises the following compiler error using GCC 5.2.1:</p>\n<pre><code>error: inconsistent types \u2018main()::&lt;lambda()&gt;::&lt;lambda()&gt;\u2019 and \n       \u2018main()::&lt;lambda()&gt;::&lt;lambda()&gt;\u2019 deduced for lambda \n       return type else return [] { return 2; };\n</code></pre>\n<p>Now obviously those two types look to be the same, so I'm not sure if this is GCC with a misleading error message or if it's actually a bug. According to my knowledge this should compile; the lambda return type should be deduced to be <code>std::function&lt;int()&gt;</code>. Interestingly, if I pre-declare the lambda return and return the same variable twice, it works.</p>\n<p>Can anyone shed some light as to what is happening? I found similar looking questions, many attributed to GCC bugs, but this looks different.</p>\n", "Tags": "<c++><lambda><c++14><return-type><return-type-deduction>", "OwnerUserId": "5760230", "AnswerCount": "3"}, "34667776": {"ParentId": "34667733", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Those types are <em>not</em> the same. Each lambda is an instance of a unique, unnamed type. <code>std::function</code> is a template that can be implicitely converted to from appropriate callable objects including lambdas, but no instantiation of <code>std::function</code> is type or parent type of any lambda so it cannot be deduced.</p>\n<p>However, you can tell the compiler that you want it to return <code>std::function</code> and it will work:</p>\n<pre><code>auto f = []() -&gt; std::function&lt;int()&gt; {\n    if (1) return [] { return 1; };\n    else return [] { return 2; };\n}\n</code></pre>\n", "OwnerUserId": "4538344", "LastEditorUserId": "4538344", "LastEditDate": "2016-01-08T01:05:05.457", "Id": "34667776", "Score": "1", "CreationDate": "2016-01-08T00:45:54.277", "LastActivityDate": "2016-01-08T01:05:05.457"}, "34667764": {"ParentId": "34667733", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Every lambda has its own, unique type:</p>\n<blockquote>\n<p id=\"so_34667733_34667764_0\">The lambda expression constructs an unnamed prvalue temporary object of <strong>unique</strong> unnamed non-union non-aggregate type[...].</p>\n</blockquote>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">here</a>, emphasize mine.</p>\n<p>Also, lambdas have nothing to do with <code>std::function</code>, that is another different type. In particular,</p>\n<pre><code>[] { return 1; }\n</code></pre>\n<p>and </p>\n<pre><code>[] { return 2; }\n</code></pre>\n<p>have different types. This is why deduction fails.</p>\n", "OwnerUserId": "3002139", "LastEditorUserId": "3002139", "LastEditDate": "2016-01-08T00:51:12.387", "Id": "34667764", "Score": "2", "CreationDate": "2016-01-08T00:44:50.163", "LastActivityDate": "2016-01-08T00:51:12.387"}, "34667761": {"ParentId": "34667733", "PostTypeId": "2", "CommentCount": "9", "Body": "<blockquote>\n<p id=\"so_34667733_34667761_0\">Now obviously those two types are the same, </p>\n</blockquote>\n<p>No, they're not. The type of every lambda expression is a unique, distinct type.</p>\n<p>From [expr.prim.lambda]/3:</p>\n<blockquote>\n<p id=\"so_34667733_34667761_1\">The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a unique, unnamed non-union class type \u2014 called the <em>closure type</em> \u2014 whose properties are described below.</p>\n</blockquote>\n<p>Therefore, return type deduction for <code>f</code> <em>fails</em> and does not result in  <code>std::function&lt;int()&gt;</code>. The latter is an unrelated library type that isn't somehow magically the \"common type\" of any closure type.</p>\n<p>Of course each of the unique closure types can be <em>converted</em> to <code>std::function&lt;int()&gt;</code>, so if you provide the return type, everything works:</p>\n<pre><code>auto f = []() -&gt; std::function&lt;int()&gt; {\n    return 1 ? []() { return 1; }\n             : []() { return 2; };\n};\n</code></pre>\n<p>Or, as a plain function:</p>\n<pre><code>std::function&lt;int()&gt; f() {\n    return 1 ? []() { return 1; }\n             : []() { return 2; };\n}\n</code></pre>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2016-01-08T01:27:45.073", "Id": "34667761", "Score": "13", "CreationDate": "2016-01-08T00:44:39.270", "LastActivityDate": "2016-01-08T01:27:45.073"}, "bq_ids": {"n4140": {"so_34667733_34667761_1": {"section_id": 5962, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_34667733_34667761_1": {"section_id": 5731, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_34667733_34667761_1": {"section_id": 7451, "quality": 0.8947368421052632, "length": 17}}}});