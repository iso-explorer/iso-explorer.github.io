post_cb({"29255482": {"ParentId": "29255322", "CommentCount": "1", "Body": "<p>You can't use constexpr, because <strong>std::string</strong> does not have a trivial <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\">destructor</a>. Check the requirements on cppreference.</p>\n", "OwnerUserId": "1846228", "PostTypeId": "2", "Id": "29255482", "Score": "5", "CreationDate": "2015-03-25T12:19:12.937", "LastActivityDate": "2015-03-25T12:19:12.937"}, "29255322": {"CommentCount": "17", "AcceptedAnswerId": "29255535", "PostTypeId": "1", "ClosedDate": "2015-03-25T17:30:52.423", "LastEditorUserId": "-1", "CreationDate": "2015-03-25T12:11:52.137", "LastActivityDate": "2015-03-30T20:49:12.703", "LastEditDate": "2017-05-23T12:02:20.300", "ViewCount": "1887", "FavoriteCount": "1", "Title": "Why must a string be constructed at run-time?", "Id": "29255322", "Score": "21", "Body": "<p>Can C-Strings or <code>std::string</code>s be created as <code>constexpr</code> or must they be created at run-time?</p>\n<p>With gcc 4.9.2 I can do this:</p>\n<pre><code>constexpr const char foo[] = \"blee\";\n</code></pre>\n<p>(Sadly the November 2013 Customer Technology Preview does not allow Visual Studio to support this: <a href=\"https://stackoverflow.com/a/29255013/2642059\">https://stackoverflow.com/a/29255013/2642059</a>)</p>\n<p>But even with gcc 4.9.2 I cannot do this:</p>\n<pre><code>constexpr const std::string foo = \"blee\";\n</code></pre>\n<p>I get the error:</p>\n<pre><code>error: the type 'const string {aka const std::basic_string&lt;char&gt;}' of constexpr variable 'foo' \n       is not literal\n\n constexpr const std::string foo = \"blee\";\n                                   ^\nnote: 'std::basic_string&lt;char&gt;' is not literal because:\n     class basic_string\n           ^\nnote:   'std::basic_string&lt;char&gt;' has a non-trivial destructor\n</code></pre>\n<p>But I would like more clarification on <em>why</em> a <code>std::string</code> is not a literal. That is to say: <strong>Why must a string be constructed at run-time?</strong></p>\n<p>As pointed out this question can partially be answered by this: <a href=\"https://stackoverflow.com/questions/27123306/is-it-possible-to-use-stdstring-in-a-constexpr\">Is it possible to use std::string in a constexpr?</a> but it does not touch on the why <code>std::string</code> can not be a literal which is core to the question.</p>\n", "Tags": "<c++><c++11><literals><stdstring><constexpr>", "OwnerUserId": "2642059", "AnswerCount": "2"}, "29255535": {"ParentId": "29255322", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>There is a proposal for a <em>constexpr</em> string: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4121.pdf\" rel=\"noreferrer\">Compile-Time String: std::string_literal</a> and it says:</p>\n<blockquote>\n<p id=\"so_29255322_29255535_0\">The purpose of <code>std::string_literal</code>, like <code>std::string</code>, is to\n  provide a convenience utility for working with text.  Unlike\n  <code>std::string</code>, an instantiation of <code>std::string_literal</code> is a literal\n  type and so can be  used at compile\u00adtime.  That is, it may be the type\n  of an <code>constexpr</code> object, and it may be the type of a parameter,\n  return value or local variable of a <code>constexpr</code> function</p>\n</blockquote>\n<p>which also confirms that indeed <code>std::string</code> is not a <em>literal type</em>.</p>\n<p><strong>So why not just make <code>std::string</code> a literal type?</strong></p>\n<p>We get a hint why from the proposal above why this not possible:</p>\n<blockquote>\n<p id=\"so_29255322_29255535_1\">This would require a massive core language change to make something\n  <strong>like dynamic memory available at compile\u00ad-time</strong>, or to make something\n  like VLA/ARB and permit them in literal types. Given the violently\n  negative reaction of Rapperswil Evolution to not only N4025 (Classes\n  of  Runtime Size), but anything that vaguely resembles VLA/ARBs, we\n  can expect this not to happen any time soon, so this idea is a\n  non\u00adstarter.</p>\n</blockquote>\n<p><code>std::string</code> requires dynamic memory which is not available at compile time.</p>\n<p><b>Why constexpr can not be applied to std::string but can to array of char</b></p>\n<p><code>constexpr</code> applied to an object shall be applied to a <em>literal type</em> which does not apply to <code>std::string</code> but applies to an array of <code>const char</code>. From the draft C++11 standard section <code>7.1.5</code> <em>[dcl.constexpr]</em> (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_29255322_29255535_2\">A <code>constexpr</code> specifier used in an object declaration declares the\n  object as <code>const</code>. Such an <strong>object shall have literal type and shall\n  be initialized</strong>. If it is initialized by a constructor call, that\n  call shall be a constant expression (5.19). [\u2026]</p>\n</blockquote>\n<p>and from section <code>3.9</code> <em>[basic.types]</em>:</p>\n<blockquote>\n<p id=\"so_29255322_29255535_3\">A type is a literal type if it is:</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote id=\"so_29255322_29255535_4\">\n<ul>\n<li>a scalar type; or</li>\n<li>an array of literal type</li>\n</ul>\n</blockquote>\n<p><em>Arithmetic types</em> are scalar types and include <em>char</em>, which covers the array of <code>const char</code></p>\n<p>and for classes:</p>\n<blockquote>\n<p id=\"so_29255322_29255535_5\">a class type (Clause 9) that has all of the following properties:</p>\n<ul>\n<li><strong>it has a trivial destructor,</strong></li>\n<li>every constructor call and full-expression in the brace-or-equal-initializers for non-static data members (if any) is a constant expression (5.19),</li>\n<li><strong>it is an aggregate type (8.5.1) or has at least one <code>constexpr</code> constructor or constructor template that is not a copy or move\n  constructor</strong>, and</li>\n<li>all of its non-<code>static</code> data members and base classes are of literal types.</li>\n</ul>\n</blockquote>\n<p><code>std::string</code> does not meet that criteria.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-03-30T20:49:12.703", "Id": "29255535", "Score": "26", "CreationDate": "2015-03-25T12:22:01.660", "LastActivityDate": "2015-03-30T20:49:12.703"}, "bq_ids": {"n4140": {"so_29255322_29255535_2": {"section_id": 5425, "quality": 0.95, "length": 19}, "so_29255322_29255535_4": {"section_id": 7208, "quality": 1.0, "length": 5}, "so_29255322_29255535_5": {"section_id": 7208, "quality": 1.0, "length": 6}}, "n3337": {"so_29255322_29255535_2": {"section_id": 5220, "quality": 0.95, "length": 19}, "so_29255322_29255535_4": {"section_id": 6952, "quality": 1.0, "length": 5}, "so_29255322_29255535_5": {"section_id": 6952, "quality": 1.0, "length": 6}}, "n4659": {"so_29255322_29255535_2": {"section_id": 6847, "quality": 0.75, "length": 15}, "so_29255322_29255535_4": {"section_id": 8717, "quality": 1.0, "length": 5}, "so_29255322_29255535_5": {"section_id": 8717, "quality": 1.0, "length": 6}}}});