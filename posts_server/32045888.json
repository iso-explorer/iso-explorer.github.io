post_cb({"32046531": {"CommentCount": "2", "Body": "<p>Stealing the quote from TartanLlama:</p>\n<blockquote>\n<p id=\"so_32045888_32046531_0\">[expr.add]/5 \"[for pointer addition, ] if both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.\"</p>\n</blockquote>\n<p>So the compiler can assume that your pointer points to the <code>a</code> array, or one past the end. If it points one past the end, you cannot defererence it. But as you do, it surely can't be one past the end, so it can only be inside the array.</p>\n<p>So now you have your code (reduced)</p>\n<pre><code>b = 1;\n*pa1 = 2;\n</code></pre>\n<p>where <code>pa</code> points inside an array <code>a</code> and <code>b</code> is a separate variable. And when you print them, you get exactly <code>1</code> and <code>2</code>, the values you have assigned them.</p>\n<p>An optimizing compiler can figure that out, without even storing a <code>1</code>or a <code>2</code> to memory. It can just print the final result.</p>\n", "CreationDate": "2015-08-17T09:08:29.483", "ParentId": "32045888", "Id": "32046531", "LastActivityDate": "2015-08-17T09:08:29.483", "PostTypeId": "2", "Score": "4", "OwnerUserId": "597607"}, "32046166": {"CommentCount": "1", "Body": "<p>The first thing to say is that a sample of one test on one compiler generating code on one architecture is not the basis on which to draw a conclusion on the behaviour of the language.</p>\n<p>c++ (and c) are general purpose languages created with the intention of being portable. i.e. a well formed program written in c++ on one system should run on any other (barring calls to system-specific services).</p>\n<p>Once upon a time, for various reasons including backward-compatibility and cost, memory maps were not contiguous on all processors.</p>\n<p>For example I used to write code on a 6809 system where half the memory was paged in via a PIA addressed in the non-paged part of the memory map. My c compiler was able to cope with this because pointers were, for that compiler, a 'mystical' type which knew how to write to the PIA. </p>\n<p>The 80386 family has an addressing mode where addresses are organised in groups of 16 bytes. Look up <code>FAR</code> pointers and you'll see different pointer arithmetic.</p>\n<p>This is the history of pointer development in c++. Not all chip manufacturers have been \"well behaved\" and the language accommodates them all (usually) without needing to rewrite source code.</p>\n", "CreationDate": "2015-08-17T08:47:05.587", "ParentId": "32045888", "Id": "32046166", "LastActivityDate": "2015-08-17T08:47:05.587", "PostTypeId": "2", "Score": "5", "OwnerUserId": "2015579"}, "32046434": {"LastActivityDate": "2015-08-17T10:43:55.973", "CommentCount": "1", "Body": "<p>If you turn off the optimiser the code works as expected.</p>\n<p>By using pointer arithmetic that is undefined you are fooling the optimiser.\nThe optimiser has figured out that there is no code writing to <code>b</code>, so it can safely store it in a register. As it turns out, you have acquired the address of <code>b</code> in a non-standard way and modify the value in a way the optimiser doesn't see.</p>\n<p>If you read the C standard, it says that pointers may be mystical. <code>gcc</code> pointers are not mystical. They are stored in ordinary memory and consist of the same type of bytes that make up all other data types. The behaviour you encountered is due to your code not respecting the limitations stated for the optimiser level you have chosen.</p>\n<p><strong>Edit:</strong></p>\n<p>The revised code is still UB. The standard doesn't allow referencing <code>a[1]</code> even if the pointer value happens to be identical to another pointer value. So the optimiser <em>is</em> allowed to store the value of <code>b</code> in a register.</p>\n", "CreationDate": "2015-08-17T09:03:17.000", "LastEditDate": "2015-08-17T10:43:55.973", "ParentId": "32045888", "Id": "32046434", "LastEditorUserId": "646887", "PostTypeId": "2", "Score": "3", "OwnerUserId": "646887"}, "bq_ids": {"n4140": {"so_32045888_32046531_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 6142}}, "n3337": {"so_32045888_32046531_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 5906}}}, "32050082": {"CommentCount": "8", "Body": "<p>I think your confusion comes from assuming that the compiler will execute things in some particular order. That is not the case. The compiler will generate code that will behave <em>as if</em> it has executed your code in the order it is in, applying the usual rules of sequence points and undefined behavior.</p>\n<p>So in your example, even when the bit patterns of <code>pa1</code> and <code>pb</code> are exactly the same, the compiler is allowed to assume that the value of <code>b</code> cannot change because there are no legal statements in your code that change its value. The <code>*pa1 = 2</code> statement can't possibly change <code>b</code> with the reasoning: since <code>pa1</code> was initialized to a pointer derived from <code>a</code> it must point inside the array <code>a</code> otherwise dereferencing <code>pa1</code> would be invoking undefined behavior (as other answers have pointed out with relevant references to the standard) and the compiler is free to whatever it wants when it sees undefined behavior, <em>including assuming that your code didn't invoke undefined behavior</em>. And since the value of <code>b</code> cannot have changed in any legal way the code that sets up the second argument to your last call to <code>printf</code> can be generated at any time. Including at compile time where the compiler is allowed to know beforehand that its value must be <code>1</code>, because there are no statements in your code that can possibly change its value, so instead of wasting CPU time reading the value of that variable it can legally translate that printf call to <code>printf(\"b = %d *pa1 = %d\\n\", 1, *pa1);</code>.</p>\n<p>To rephrase this. Even though in most cases people say that undefined behavior can mean anything including nasal demons and formatting your hard drive, in practice undefined behavior in most modern compilers is implemented as \"assume it didn't happen if that lets you generate more efficient code\". Since a modification to <code>b</code> couldn't happen without undefined behavior, therefore the compiler is allowed to act as if it didn't happen.</p>\n<p>This has nothing to do with pointers being magic or not magic. There are known examples of compilers assuming that undefined behavior can't happen that don't involve pointers at all. <a href=\"https://stackoverflow.com/questions/7682477/why-does-integer-overflow-on-x86-with-gcc-cause-an-infinite-loop\">Like signed integer wrap around for example.</a></p>\n", "CreationDate": "2015-08-17T12:12:43.960", "ParentId": "32045888", "Id": "32050082", "LastActivityDate": "2015-08-17T12:12:43.960", "PostTypeId": "2", "Score": "3", "OwnerUserId": "939410"}, "32045888": {"CreationDate": "2015-08-17T08:31:34.670", "ViewCount": "291", "FavoriteCount": "0", "Id": "32045888", "Score": "-3", "Title": "Are pointer variables just integers with some operators or are they \"mystical\"?", "LastEditorUserId": "-1", "CommentCount": "21", "Body": "<p>In the discussion about my previous C++ question, I have been told that pointers are </p>\n<ul>\n<li>\"<a href=\"https://stackoverflow.com/questions/32043314/overwriting-an-object-with-an-object-of-same-type/32043636#comment51987347_32043314\">a simple value type much like an integer</a>\"</li>\n<li>not \"<a href=\"https://stackoverflow.com/questions/32043314/overwriting-an-object-with-an-object-of-same-type/32043636#comment51988103_32043636\">mystical</a>\"  </li>\n<li>\"<a href=\"https://stackoverflow.com/questions/32043314/overwriting-an-object-with-an-object-of-same-type/32043636#comment51987714_32043636\">The Bit pattern (object representation) contains the value (value representation) (\u00a73.9/4) for trivially copyable types, which a pointer is.</a>\"</li>\n</ul>\n<p>This does <em>not</em> sound right! If nothing is mystical and a pointer is its representation, then I can do the following. Can I?</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int a[1] = { 0 }, *pa1 = &amp;a[0] + 1, b = 1, *pb = &amp;b;\n    if (memcmp (&amp;pa1, &amp;pb, sizeof pa1) == 0) {\n        printf (\"pa1 == pb\\n\");\n        *pa1 = 2;\n    }\n    else {\n        printf (\"pa1 != pb\\n\");\n        pa1 = &amp;a[0]; // ensure well defined behaviour in printf\n    }\n    printf (\"b = %d *pa1 = %d\\n\", b, *pa1);\n    return 0;\n }\n</code></pre>\n<p>This is a C and C++ question.</p>\n<p>Testing with <a href=\"http://www.tutorialspoint.com/compile_cpp_online.php\" rel=\"nofollow noreferrer\">Compile and Execute C Online</a> with GNU GCC v4.8.3: <code>gcc -O2 -Wall</code> gives </p>\n<pre><code>pa1 == pb                                                                                                                                                                                       \nb = 1 *pa1 = 2    \n</code></pre>\n<p>Testing with <a href=\"http://www.tutorialspoint.com/compile_cpp_online.php\" rel=\"nofollow noreferrer\">Compile and Execute C++ Online</a> with GNU GCC v4.8.3: <code>g++ -O2 -Wall</code> </p>\n<pre><code>pa1 == pb                                                                                                                                                                                       \nb = 1 *pa1 = 2        \n</code></pre>\n<p>So <strong>the modification of <code>b</code> via <code>(&amp;a)[1]</code> fails</strong> with GCC in C and C++.</p>\n<p>Of course, I would like an answer based on standard quotes.</p>\n<p>EDIT: To respond to criticism about UB on <code>&amp;a + 1</code>, now <code>a</code> is an array of 1 element.</p>\n<p>Related: <a href=\"https://stackoverflow.com/questions/32043795/dereferencing-an-out-of-bound-pointer-that-contains-the-address-of-an-object-ar\">Dereferencing an out of bound pointer that contains the address of an object (array of array)</a></p>\n", "Tags": "<c++><c><pointers><language-lawyer><undefined-behavior>", "LastEditDate": "2017-05-23T12:01:38.150", "LastActivityDate": "2015-08-17T12:12:43.960", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "963864"}});