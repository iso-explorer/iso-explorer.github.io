post_cb({"bq_ids": {"n4140": {"so_27058847_27059232_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 5964}}, "n3337": {"so_27058847_27059232_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 5733}}, "n4659": {"so_27058847_27059232_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 7453}}}, "27059232": {"Id": "27059232", "PostTypeId": "2", "Body": "<p>Problem is, that you use <code>std::function</code>, that actually use <code>type-erasure</code> and virtual calls.\nYou can simply use template parameter, instead of <code>std::function</code>. Call of lambda function will be inlined, due n3376 5.1.2/5</p>\n<blockquote>\n<p id=\"so_27058847_27059232_0\">The closure type for a lambda-expression has a <strong>public inline function\n  call operator (13.5.4)</strong> whose param- eters and return type are\n  described by the lambda-expression\u2019s parameter-declaration-clause and\n  trailing- return-type respectively</p>\n</blockquote>\n<p>So, just simply write</p>\n<pre><code>  template&lt;typename Function&gt;\n  inline void forEach(Function f) {\n    for (size_t index = 0; index != d_size; ++index)\n      f(*this, index);\n  }\n</code></pre>\n<p><a href=\"http://ideone.com/8kR3Mw\" rel=\"noreferrer\">Live example</a></p>\n", "LastActivityDate": "2014-11-21T10:33:05.770", "CommentCount": "4", "CreationDate": "2014-11-21T10:33:05.770", "ParentId": "27058847", "Score": "6", "OwnerUserId": "1498580"}, "27058847": {"ViewCount": "256", "Body": "\n<h2>Motivation</h2>\n<p>I created a header file which wraps Matlab's mex functionality in c++11 classes; especially for MxNxC images. Two functions I created are forEach, which iterates over each pixel in the image, and also a forKernel, which given a kernel and pixel in the image, iterates over the kernel around that pixel, handling all kinds of nifty, boiler-plate indexing mathematics.</p>\n<p>The idea is that one could program sliding-windows like this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>image.forEach([](Image &amp;image, size_t row, size_t col) {\n  //kr and lc specify which pixel is the center of the kernel\n  image.forKernel&lt;double&gt;(row, col, kernel, kr, kc, [](Image &amp;image, double w, size_t row, size_t col) {\n    // w is the weight/coefficient of the kernel, row/col are the corresponding coordinates in the image.\n    // process ...\n  });\n});\n</code></pre>\n<h2>Problem</h2>\n<p>This provides a nice way to</p>\n<ul>\n<li>increase readability: the two function calls are a lot clearer than the corresponding 4 for-loops to do the same,</li>\n<li>stay flexible: lambda functions allow you to scope all kinds of variables by value or reference, which are invisible to the implementer of forEach / forKernel, and</li>\n<li>increase execution time, unfortunately: this executes around 8x slower than using just for loops.</li>\n</ul>\n<p>The latter point is the problem, of course. I was hoping g++ would be able to optimize the lambda-functions out and inline all the code. This does not happen. Hence I created a minimal working example on 1D data:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct Data {\n  size_t d_size;\n  double *d_data;\n  Data(size_t size) : d_size(size), d_data(new double[size]) {}\n  ~Data() { delete[] d_data; }\n  double &amp;operator[](size_t i) { return d_data[i]; }\n\n\n  inline void forEach(std::function&lt;void(Data &amp;, size_t)&gt; f) {\n    for (size_t index = 0; index != d_size; ++index)\n      f(*this, index);\n  }\n};\n\n\n\nint main() {\n  Data im(50000000);\n  im.forEach([](Data &amp;im, size_t i) {\n    im[i] = static_cast&lt;double&gt;(i);\n  });\n\n  double sum = 0;\n  im.forEach([&amp;sum](Data &amp;im, size_t i) {\n    sum += im[i];\n  });\n\n  std::cout &lt;&lt; sum &lt;&lt; '\\n';\n}\n</code></pre>\n<p>source: <a href=\"http://ideone.com/hviTwx\" rel=\"nofollow noreferrer\">http://ideone.com/hviTwx</a></p>\n<p>I'm guessing the compiler is not able to compile the code for forEach per lambda-function, as the lambda function is not a template variable. The good thing is that one can compile once and link to it more often with different lambda functions, but the bad thing is that it is slow.</p>\n<p>Moreover, the situation discussed in the motivation already contains templates for the data type (double, int, ...), hence the 'good thing' is overruled anyway.</p>\n<p>A fast way to implement the previous would be like this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct Data {\n  size_t d_size;\n  double *d_data;\n  Data(size_t size) : d_size(size), d_data(new double[size]) {}\n  ~Data() { delete[] d_data; }\n  double &amp;operator[](size_t i) { return d_data[i]; }\n};\n\n\n\nint main() {\n  size_t len = 50000000;\n  Data im(len);\n  for (size_t index = 0; index != len; ++index)\n    im[index] = static_cast&lt;double&gt;(index);\n\n  double sum = 0;\n  for (size_t index = 0; index != len; ++index)\n    sum += im[index];\n\n  std::cout &lt;&lt; sum &lt;&lt; '\\n';\n}\n</code></pre>\n<p>source: <a href=\"http://ideone.com/UajMMz\" rel=\"nofollow noreferrer\">http://ideone.com/UajMMz</a></p>\n<p>It is about 8x faster, but also less readable, especially when we consider more complicated structures like images with kernels.</p>\n<h2>Question</h2>\n<p>Is there a way to provide the lambda function as a template argument, such that forEach is compiled for each call, and optimized for each specific instance of the lambda function? Can the lambda function be inlined somehow, since lambda functions are typically not recursive this should be trivial, but what is the syntax?</p>\n<p>I found some related posts:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/8611756/why-c-lambda-is-slower-than-ordinary-function-when-called-multiple-times\">Why C++ lambda is slower than ordinary function when called multiple times?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/18619035/understanding-the-overhead-of-lambda-functions-in-c11\">Understanding the overhead of lambda functions in C++11</a></li>\n<li><a href=\"https://stackoverflow.com/questions/3218821/c0x-lambda-overhead\">C++0x Lambda overhead</a></li>\n</ul>\n<p>But they do not give a solution in the form of a minimal working example, and they do not discuss the possibility of inlining a lambda function. The answer to my question should do that: change the Data.forEach member function and it's call such that is as fast as possible / allows for as many <strong>running time optimizations</strong> (not optimizations at run time, but at compile time that decrease runtime) as possible.</p>\n<h2>Regarding the suggestion of forEveR</h2>\n<p>Thank you for creating that fix, it's a huge improvement yet still approximately 2x as slow:</p>\n<ul>\n<li>test0.cc: <a href=\"http://ideone.com/hviTwx\" rel=\"nofollow noreferrer\">http://ideone.com/hviTwx</a></li>\n<li>test1.cc: <a href=\"http://ideone.com/UajMMz\" rel=\"nofollow noreferrer\">http://ideone.com/UajMMz</a></li>\n<li>test2.cc: <a href=\"http://ideone.com/8kR3Mw\" rel=\"nofollow noreferrer\">http://ideone.com/8kR3Mw</a></li>\n</ul>\n<p>Results:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>herbert@machine ~ $ g++ -std=c++11 -Wall test0.cc -o test0\nherbert@machine ~ $ g++ -std=c++11 -Wall test1.cc -o test1\nherbert@machine ~ $ g++ -std=c++11 -Wall test2.cc -o test2\nherbert@machine ~ $ time ./test0\n1.25e+15\n\nreal    0m2.563s\nuser    0m2.541s\nsys     0m0.024s\nherbert@machine ~ $ time ./test1\n1.25e+15\n\nreal    0m0.346s\nuser    0m0.320s\nsys     0m0.026s\nherbert@machine ~ $ time ./test2\n1.25e+15\n\nreal    0m0.601s\nuser    0m0.575s\nsys     0m0.026s\nherbert@machine ~ $ \n</code></pre>\n<p>I re-ran the code with -O2, which fixes the problem. runtimes of test1 and test2 ar now very similar. Thank you @stijn and @forEveR.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>herbert@machine ~ $ g++ -std=c++11 -Wall -O2 test0.cc -o test0\nherbert@machine ~ $ g++ -std=c++11 -Wall -O2 test1.cc -o test1\nherbert@machine ~ $ g++ -std=c++11 -Wall -O2 test2.cc -o test2\n\nherbert@machine ~ $ time ./test0\n1.25e+15\n\nreal    0m0.256s\nuser    0m0.229s\nsys 0m0.028s\nherbert@machine ~ $ time ./test1\n1.25e+15\n\nreal    0m0.111s\nuser    0m0.078s\nsys 0m0.033s\nherbert@machine ~ $ time ./test2\n1.25e+15\n\nreal    0m0.108s\nuser    0m0.076s\nsys 0m0.032s\nherbert@machine ~ $ \n</code></pre>\n", "AcceptedAnswerId": "27059232", "Title": "Fast and generic use of lambda functions", "CreationDate": "2014-11-21T10:10:50.227", "Id": "27058847", "CommentCount": "10", "LastEditDate": "2017-05-23T11:49:27.653", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-21T10:44:00.740", "Score": "4", "OwnerUserId": "853462", "Tags": "<c++><matlab><c++11><lambda>", "AnswerCount": "1"}});