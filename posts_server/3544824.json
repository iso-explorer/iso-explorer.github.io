post_cb({"bq_ids": {"n4140": {"so_3544824_3544824_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 568}, "so_3544824_3544838_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5504}, "so_3544824_3544838_1": {"length": 13, "quality": 1.0, "section_id": 5502}}, "n3337": {"so_3544824_3544824_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 559}, "so_3544824_3544838_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5290}, "so_3544824_3544838_1": {"length": 13, "quality": 1.0, "section_id": 5288}}, "n4659": {"so_3544824_3544824_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 591}, "so_3544824_3544838_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 6938}, "so_3544824_3544838_1": {"length": 13, "quality": 1.0, "section_id": 6936}}}, "3544838": {"Id": "3544838", "PostTypeId": "2", "Body": "<p>The C++ standard (C++03 \u00a77.3.3/12) explains:</p>\n<blockquote>\n<p id=\"so_3544824_3544838_0\">When a <em>using-declaration</em> brings names from a base class into a derived class scope, member functions in the derived class override and/or hide member functions with the same name and parameter types in a base class (rather than conflicting).</p>\n</blockquote>\n<p>In your example, <code>B2::fb()</code> hides the <code>B1::fb()</code> introduced by the using declaration.</p>\n<p>As for why it is ill-formed to have both <code>using B1::d;</code> and <code>int d;</code> in the definition of <code>B2</code>, the C++ standard (C++03 \u00a77.3.3/10) explains:</p>\n<blockquote>\n<p id=\"so_3544824_3544838_1\">Since a <em>using-declaration</em> is a declaration, the restrictions on declarations of the same name in the same declarative region also apply to <em>using-declarations.</em></p>\n</blockquote>\n<p>So, it is ill-formed for the same reason that the following is ill-formed:  it results in two objects with the same name in a single declarative region:</p>\n<pre><code>struct S { int d; int d; };\n</code></pre>\n", "LastEditorUserId": "151292", "LastActivityDate": "2010-08-23T05:01:14.610", "Score": "9", "CreationDate": "2010-08-23T04:53:42.693", "ParentId": "3544824", "CommentCount": "3", "OwnerUserId": "151292", "LastEditDate": "2010-08-23T05:01:14.610"}, "3544824": {"ViewCount": "1626", "Body": "<pre><code>struct B1{\n  int d;\n  void fb(){};\n};\n\nstruct B2 : B1{\n  using B1::d;\n  using B1::fb;\n\n  int d;               // why this gives error?\n  void fb(){}          // and this does not?\n};\n\nint main(){}\n</code></pre>\n<p>Is it because, <code>B1::fb()</code> is treated as <code>B1::fb(B1*)</code> <code>and B2::fb()</code> treated as <code>B2::fb(B2*)</code>? That is, does the implicit parameter, help in distinguishing these?</p>\n<blockquote>\n<p id=\"so_3544824_3544824_0\">$13.3.1/4-</p>\n<p id=\"so_3544824_3544824_1\">For nonconversion functions introduced\n  by a using-declaration into a derived\n  class, the function is considered to\n  be a member of the derived class for\n  the purpose of defining the type of\n  the implicit object parameter.</p>\n</blockquote>\n", "AcceptedAnswerId": "3544838", "Title": "Using declaration (Derived class)", "CreationDate": "2010-08-23T04:48:17.823", "Id": "3544824", "CommentCount": "0", "LastEditDate": "2010-08-23T04:51:08.513", "PostTypeId": "1", "LastEditorUserId": "225647", "LastActivityDate": "2010-08-23T05:01:14.610", "Score": "6", "OwnerUserId": "418110", "Tags": "<c++><derived-class><using-declaration>", "AnswerCount": "1"}});