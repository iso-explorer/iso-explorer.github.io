post_cb({"38859414": {"Id": "38859414", "PostTypeId": "2", "Body": "<p>From [res.on.data.races]/2 we have</p>\n<blockquote>\n<p id=\"so_38859102_38859414_0\">A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const arguments, including this.</p>\n</blockquote>\n<p>So all non-const methods are allowed to modify state and all <code>const</code> functions must not modify the state of the object.</p>\n<p>The rule of thumb is if you have data shared between multiple threads and at least one of them is a writer then you need synchronization.</p>\n", "LastActivityDate": "2016-08-09T19:59:11.520", "CommentCount": "1", "CreationDate": "2016-08-09T19:59:11.520", "ParentId": "38859102", "Score": "1", "OwnerUserId": "4342498"}, "38859295": {"Id": "38859295", "PostTypeId": "2", "Body": "<p>In general, as a rule of thumb, if all methods you call on any object are const, you don't need to synchronise around it. As soon as you do one thing non const on it, you need to synchronise every time you touch it.</p>\n<p>This isn't bullet proof, it's a rule of thumb, for example a function can declare itself const and then cast away the const and do dangerous things, or it can have declared members mutable and so let itself touch it even when const. Also the opposite is true also, that you can use lock free programming techniques to avoid needing to synchronise and maintaining coherence.</p>\n", "LastActivityDate": "2016-08-09T19:50:43.750", "CommentCount": "0", "CreationDate": "2016-08-09T19:50:43.750", "ParentId": "38859102", "Score": "1", "OwnerUserId": "6476520"}, "38859170": {"Id": "38859170", "PostTypeId": "2", "Body": "<p>It's quite easy, really: If you ever \"write to the map\" <strong>at the same time</strong> as you \"read from the map\", then you need to <em>synchronize</em> those operations - for example by protecting them with a mutex.</p>\n<p>With \"write to the map\", I mean calling any non-const member function of the map, and with \"read from the map\", I mean calling any const member function.</p>\n<p>With <strong>at the same time</strong>, I mean that there are more than one thread that <em>might</em> write or read the map. Hence, a single threaded program will not need synchronization.</p>\n<p>If you up to a certain point in time write to the map and then know with absolute certainty that no more writes will be done, all reads from the map after that can be done unsynchronized. For example, if you set up a map in a factory function of sorts on one thread and after the set up never write to it again, then any other thread can read unsynchronized from it. Note that when the map goes out of scope, its destructor will run and it will be written to; before this happens, all possible unsynchronized reads must already have been completed.</p>\n", "LastEditorUserId": "6345", "LastActivityDate": "2016-08-10T07:25:13.677", "Score": "3", "CreationDate": "2016-08-09T19:42:31.410", "ParentId": "38859102", "CommentCount": "2", "OwnerUserId": "6345", "LastEditDate": "2016-08-10T07:25:13.677"}, "38859102": {"ViewCount": "72", "Body": "<p>I Have a std::map with a combination of tuple as a key and vector of values like</p>\n<p><code>using ReqList=map&lt;const Attrib,vector&lt;REQ&gt;,less&lt;key_comp&gt;&gt;;</code>// Attrib is a tuple.</p>\n<p>with this map the threads will lookup for the key and do insert if the key is new or just populate the vector if there is already a key then some form of remove like </p>\n<p><code>ReqList l;\nbegin(l[A])=move(l[A].back());</code>//removing first element from vector of values</p>\n<p>I been doing insert,lookup,manipulate value, and sort of removing (the first element)..So does the every mentioned operation or function call needs to be Mutexed ? or I can put only certain things under Mutex. Does the std::map provide any default synchronization?</p>\n", "Title": "What are all the operations/functions that has to be Mutexed when using std::map", "CreationDate": "2016-08-09T19:38:13.097", "LastActivityDate": "2016-08-10T07:25:13.677", "CommentCount": "2", "PostTypeId": "1", "Id": "38859102", "Score": "1", "OwnerUserId": "5198101", "Tags": "<c++><c++11><vector><stdmap>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_38859102_38859414_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6348}}, "n3337": {"so_38859102_38859414_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6105}}, "n4659": {"so_38859102_38859414_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7857}}}, "38859162": {"Id": "38859162", "PostTypeId": "2", "Body": "<p>If you have one thread reading from the map, and another thread writing to the map, and you don't know precisely how those operations will be synchronised with each other, <em>mutex everything</em>. Protect <em>every</em> access to your map. Standard containers provide you no guarantees and no likelihood of synchronisation.</p>\n", "LastActivityDate": "2016-08-09T19:42:10.973", "CommentCount": "0", "CreationDate": "2016-08-09T19:42:10.973", "ParentId": "38859102", "Score": "1", "OwnerUserId": "560648"}, "38859634": {"Id": "38859634", "PostTypeId": "2", "Body": "<pre><code>template&lt;class T&gt;\nstruct rw_locked {\n  template&lt;class F&gt;\n  auto read( F&amp;&amp; f ) const {\n    auto lock = read_lock();\n    return std::forward&lt;F&gt;(f)(t);\n  }\n  auto write( F&amp;&amp; f ) {\n    auto lock = write_lock();\n    return std::forward&lt;F&gt;(f)(t);\n  }\nprivate:\n  auto read_lock() const {\n    return std::shared_lock&lt;std::shared_timed_mutex&gt;(m);\n  }\n  auto write_lock() {\n    return std::unique_lock&lt;std::shared_timed_mutex&gt;(m);\n  }\n  mutable std::shared_timed_mutex m;\n  T t;\n};\n</code></pre>\n<p>now simply do:</p>\n<pre><code>rw_locked&lt; std::map&lt; int, int &gt; &gt; m;\nm.read( [&amp;](auto&amp;&amp;m) {\n  // code to read\n} );\nm.write( [&amp;](auto&amp;&amp;m) {\n  // code to write\n} );\n</code></pre>\n<p>and it will for the most part guard correctly.</p>\n<p>Technically you can call non-const <code>begin</code> in a read lock and it would be defined, but writing through the resulting iterator would not be.  So the above doesn't let you get the non-const iterator.</p>\n<p>Do not return iterators or pointers to data in the <code>map</code> in the above code, or it won't protect you.</p>\n", "LastActivityDate": "2016-08-09T20:14:33.587", "CommentCount": "0", "CreationDate": "2016-08-09T20:14:33.587", "ParentId": "38859102", "Score": "0", "OwnerUserId": "1774667"}});