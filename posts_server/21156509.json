post_cb({"21156832": {"Id": "21156832", "PostTypeId": "2", "Body": "<p>If you get a bad access on the second access it means your compiler doesn't copy the initializer list to <code>aa</code> but have <code>aa</code> point to the process's const data section (e.g. where the string literals are stored).</p>\n<p>As others have pointed out, changing a const produces undefined behavior. In Visual Studio, your code will not produce any errors.</p>\n<p>The problem surfaces when multiple references to the same const object (or array in C) occur. Changing one will change all of them and only in optimized builds. This sort of bug is hard to track.</p>\n", "LastActivityDate": "2014-01-16T08:34:26.497", "CommentCount": "1", "CreationDate": "2014-01-16T08:34:26.497", "ParentId": "21156509", "Score": "2", "OwnerUserId": "3005057"}, "21156509": {"ViewCount": "137", "Body": "<p>It seems that const on array will cause the memory used to store the array mark read-only in memory. But why const on int won't do the same thing?</p>\n<p>Code is here:</p>\n<pre><code>int main(int argc, const char * argv[])\n{\n\n    const int vv = 10 ;\n    int * p = (int *)&amp;vv ;\n    *p = 5 ; // work well\n\n    const int aa[3] = {11, 12, 13} ;\n    int * pp = (int *)&amp;aa[1] ;\n    *pp = 100 ; // EXC_BAD_ACCESS\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "21156631", "Title": "Does const on value different const on array", "CreationDate": "2014-01-16T08:16:02.373", "Id": "21156509", "CommentCount": "6", "LastEditDate": "2014-01-16T08:18:48.410", "PostTypeId": "1", "LastEditorUserId": "1009479", "LastActivityDate": "2014-01-16T09:58:46.997", "Score": "-1", "OwnerUserId": "1079899", "Tags": "<c++><c><arrays>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_21156509_21156967_0": {"length": 15, "quality": 0.5357142857142857, "section_id": 5435}, "so_21156509_21156631_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5435}, "so_21156509_21156631_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}}, "n3337": {"so_21156509_21156631_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5230}, "so_21156509_21156631_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}}, "n4659": {"so_21156509_21156631_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 6862}, "so_21156509_21156631_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}}}, "21156550": {"Id": "21156550", "PostTypeId": "2", "Body": "<p>Any attempt to modify data that is <code>const</code> results in <em>undefined behaviour</em> (UB). That means that your code might seem to \"work well\", but it cannot be relied on for anything.</p>\n<p>Both your examples are UB.</p>\n", "LastActivityDate": "2014-01-16T08:18:37.143", "CommentCount": "1", "CreationDate": "2014-01-16T08:18:37.143", "ParentId": "21156509", "Score": "2", "OwnerUserId": "661519"}, "21158073": {"Id": "21158073", "PostTypeId": "2", "Body": "<p>Your first part of code is pretty correct. You are modifying the value stored at location using its reference. This is defined behavior. The compiler checks this variable won't be on left side of an expression.</p>\n<p>Use the following to keep value pointed by it to be constant.</p>\n<pre><code>const int * p = (int *)&amp;vv\n</code></pre>\n", "LastEditorUserId": "302164", "LastActivityDate": "2014-01-16T09:58:46.997", "Score": "0", "CreationDate": "2014-01-16T09:35:47.863", "ParentId": "21156509", "CommentCount": "0", "OwnerUserId": "3201848", "LastEditDate": "2014-01-16T09:58:46.997"}, "21156967": {"Id": "21156967", "PostTypeId": "2", "Body": "<p>look ISO/IEC 9899 TC3 -&gt;\u00a76.7.3 part 5 there is said: </p>\n<blockquote>\n<p id=\"so_21156509_21156967_0\">If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined. If an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined.</p>\n</blockquote>\n<p>So I guess this is clear enough for C, isn't it?</p>\n", "LastActivityDate": "2014-01-16T08:42:05.910", "CommentCount": "1", "CreationDate": "2014-01-16T08:42:05.910", "ParentId": "21156509", "Score": "1", "OwnerUserId": "2003898"}, "21156631": {"Id": "21156631", "PostTypeId": "2", "Body": "<p>Both the first and the second, as stated in \u00a77.1.6.1/4, results in <em>undefined behavior</em>:</p>\n<blockquote>\n<p id=\"so_21156509_21156631_0\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>This is, in fact, one of those cases where a C++-style cast (like <code>static_cast</code>), except for <code>const_cast</code>, <a href=\"http://coliru.stacked-crooked.com/a/5b9501a7507f3374\" rel=\"nofollow\">would have warned you</a>.</p>\n<p>In the C standard the same reference is made at \u00a76.7.3/5:</p>\n<blockquote>\n<p id=\"so_21156509_21156631_1\">If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "493122", "LastActivityDate": "2014-01-16T08:31:29.177", "Score": "3", "CreationDate": "2014-01-16T08:23:03.377", "ParentId": "21156509", "CommentCount": "6", "OwnerUserId": "493122", "LastEditDate": "2014-01-16T08:31:29.177"}});