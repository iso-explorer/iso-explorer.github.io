post_cb({"27784878": {"ParentId": "27762691", "CommentCount": "0", "CreationDate": "2015-01-05T17:41:10.230", "OwnerUserId": "836116", "PostTypeId": "2", "Id": "27784878", "Score": "0", "Body": "<p>While Dietmar's answer is sufficient I decided to go a different, much more simple, route.  Since I am creating instances of a class and I am accessing those instances in the threads, I chose to update those class' data during the threading and then called the updated data once the thread have finished executing.</p>\n<p>This way I do not have to deal with annoying problems like data races nor grabbing output from async in a vector of shared_future.  Here is my revised code in case anyone else would like to implement something similar:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n#include &lt;future&gt;\n\nusing namespace std; //Tacky, but good enough fo a poc D:\n\nclass mLaser\n{\npublic:\n    mLaser(int clen, float mamt, int time_left)\n    {\n        mlCLen = clen;\n        mlMAmt = mamt;\n        mCTime_left = time_left;\n        bIsCompleted = false;\n    }\n\n    int getCLen()\n    {\n        return mlCLen;\n    }\n\n    float getMAmt()\n    {\n        return mlMAmt;\n    }\n\n    void setMCOld(int old)\n    {\n        mCTime_old = old;\n    }\n\n    void mCycle()\n    {\n        if (!bIsCompleted)\n        {\n            int mCTime_new = GetTickCount(); //Get current tick count for comparison to mCOld_time\n\n            if (mCTime_old != ((mCTime_new + 500) / 1000)) //Do calculations to see if time has passed since mCTime_old was set\n            {\n                //If it has then update mCTime_old and remove one second from mCTime_left.\n                mCTime_old = ((mCTime_new + 500) / 1000);\n                mCTime_left -= 1000;\n            }\n\n            cur_time = mCTime_left;\n        }\n\n        else\n        {\n            mCTime_left = 0;\n        }\n    }\n\n    int getCTime()\n    {\n        return cur_time;\n    }\n\n    int getCTLeft()\n    {\n        return mCTime_left;\n    }\n\n    void mCComp()\n    {\n        bIsCompleted = true;\n    }\n\n    bool getCompleted()\n    {\n        return bIsCompleted;\n    }\n\nprivate:\n    int mlCLen; //Time of a complete mining cycle\n    float mlMAmt; //Amoung of ore produced by one mining cycle (not used yet)\n    int cur_time; //The current time remaining in the current mining cycle; will be removing this as it is just a copy of mCTime_left that I was going to use for another possiblity to make this code work\n    int mCTime_left; //The current time remaining in the current mining cycle\n    int mCTime_old; //The last time that mCycle was called\n\n    bool bIsCompleted; //Flag to check if a mining cycle has already been accounted for as completed\n};\n\nvoid sMCycle(mLaser&amp; ml, int i1, thread&amp; _thread); //Start a mining cycle thread\n\n//Some global defines\nrandom_device rd;\nmt19937 gen(rd());\n\nuniform_int_distribution&lt;&gt; laser(1, 10); //A random range for the number of mlaser entities to use\nuniform_int_distribution&lt;&gt; cLRand(30, 90); //A random time range in seconds of mining cycle lengths\nuniform_real_distribution&lt;float&gt; mARand(34.0f, 154.3f); //A random float range of the amount of ore produced by one mining cycle (not used yet)\n\nint main()\n{\n    //Init some variables for later use\n    vector&lt;mLaser&gt; mlasers; //Vector to hold mlaser objects\n    vector&lt;thread&gt; mthreads; //Vector to hold threads\n    vector&lt;shared_future&lt;int&gt;&gt; futr; //Vector to hold shared_futures (not used yet, might not be used if I can get the code working like this)\n\n    int lasers; //Number of lasers to create\n    int cycle_time; //Mining cycle time\n    int active_miners = 0; //Number of active mining cycle threads (one for each laser)\n    float mining_amount; //Amount of ore produced by one mining cycle (not used yet)\n\n    lasers = laser(gen); //Get a random number\n    active_miners = lasers; //Set this to that random number for the while loop later on\n\n    //Create the mlaser objects and push them into the mlasers vector\n    for (int i = 0; i &lt; lasers; i++)\n    {\n        int clength = cLRand(gen);\n\n        mlasers.push_back(mLaser(clength, mARand(gen), (clength * 1000)));\n\n        //Also push thread obects into mthreads for each laser object\n        mthreads.push_back(thread());\n    }\n\n    //Setup data for mining cycles\n    for (int i = 0; i &lt; mlasers.size(); i++)\n    {\n        int mCTime_start = GetTickCount(); //Get cycle start time\n        mlasers.at(i).setMCOld(((mCTime_start + 500) / 1000));\n    }\n\n    //Print initial display for mining cycles\n    for (int i = 0; i &lt; mlasers.size(); i++)\n    {\n        cout &lt;&lt; \"Mining Laser \" &lt;&lt; i + 1 &lt;&lt; \" cycle will complete in \" &lt;&lt; (mlasers.at(i).getCTLeft() + 500) / 1000 &lt;&lt; \" seconds...\" &lt;&lt; endl;\n    }\n\n    while (active_miners &gt; 0)\n    {   \n        for (int i = 0; i &lt; mlasers.size(); i++)\n        {\n            //futr.push_back(async(launch::async, [mlasers, i, &amp;mthreads]{return sMCycle(mlasers.at(i), i + 1, mthreads.at(i)); }));\n            async(launch::async, [&amp;mlasers, i, &amp;mthreads]{return sMCycle(mlasers.at(i), i + 1, mthreads.at(i)); }); //Launch a thread for the current mlaser object\n            //mthreads.at(i) = thread(bind(&amp;mLaser::mCycle, ref(mlasers.at(i)), mlasers.at(i).getCLen(), mlasers.at(i).getMAmt()));\n        }\n\n        //Output information from loops\n        //cout &lt;&lt; \" \\r\" &lt;&lt; flush; //Return cursor to start of line and flush the buffer for the next info\n\n        system(\"CLS\");\n\n        for (int i = 0; i &lt; mlasers.size(); i++)\n        {\n            if (mlasers.at(i).getCTLeft() != 0) //If mining cycle is not completed\n            {\n                cout &lt;&lt; \"Mining Laser \" &lt;&lt; i + 1 &lt;&lt; \" cycle will complete in \" &lt;&lt; (mlasers.at(i).getCTLeft() + 500) / 1000 &lt;&lt; \" seconds...\" &lt;&lt; endl;\n            }\n\n            else if (mlasers.at(i).getCTLeft() == 0) //If it is completed\n            {\n                if (!mlasers.at(i).getCompleted())\n                {\n                    mlasers.at(i).mCComp();\n                    active_miners -= 1;\n                }\n\n                cout &lt;&lt; \"Mining Laser \" &lt;&lt; i + 1 &lt;&lt; \" has completed its mining cycle!\" &lt;&lt; endl;\n            }\n        }\n    }\n\n\n    /*for (int i = 0; i &lt; mthreads.size(); i++)\n    {\n        mthreads.at(i).join();\n    }*/\n\n\n    //string temp = futr.get();\n    //float out = strtof(temp.c_str(),NULL);\n\n    //cout &lt;&lt; out &lt;&lt; endl;\n\n    system(\"Pause\");\n    return 0;\n}\n\nvoid sMCycle(mLaser&amp; ml, int i1,thread&amp; _thread)\n{\n    //Start thread\n    _thread = thread(bind(&amp;mLaser::mCycle, ref(ml)));\n\n    //Join the thread\n    _thread.join();\n}\n</code></pre>\n", "LastActivityDate": "2015-01-05T17:41:10.230"}, "27762691": {"CommentCount": "0", "ViewCount": "46", "CreationDate": "2015-01-04T05:25:54.940", "LastActivityDate": "2015-01-05T17:41:10.230", "Title": "Unexpected Output While Using Threads", "AcceptedAnswerId": "27762766", "PostTypeId": "1", "Id": "27762691", "Score": "0", "Body": "<p>I am working on a proof of concept test program for a game where certain actions are threaded and information is output to the command window for each thread. So far I have gotten the basic threading process to work but it seems that the couting in my called function is not being written for each thread and instead each thread is overwriting the others output.</p>\n<p>The desired or expected output is that each thread will output the information couted within the mCycle function of mLaser.  Essentially this is meant to be a timer of sorts for each object counting down the time until that object has completed its task.  There should be an output for each thread, so if five threads are running there should be five counters counting down independently.</p>\n<p>The current output is such that each thread is outputting its own information with in the same space which then overwrites what another thread is attempting to output.</p>\n<p>Here is an example of the current output of the program:</p>\n<blockquote>\n<p id=\"so_27762691_27762691_0\">Time until cycle Time until cycle 74 is complete: 36 is complete:</p>\n<p id=\"so_27762691_27762691_1\">92 seconds 2 seconds  ress any key to continue . . .</p>\n</blockquote>\n<p>You can see the aberrations where numbers and other text are in places they should not be if you examine how the information is couted from mCycle.</p>\n<p>What should be displayed is more long these lines:</p>\n<blockquote>\n<p id=\"so_27762691_27762691_2\">Time until cycle 1 is complete:</p>\n<p id=\"so_27762691_27762691_3\">92 seconds</p>\n<p id=\"so_27762691_27762691_4\">Time until cycle 2 is complete:</p>\n<p id=\"so_27762691_27762691_5\">112 seconds</p>\n<p id=\"so_27762691_27762691_6\">Time until cycle 3 is complete:</p>\n<p id=\"so_27762691_27762691_7\">34 seconds</p>\n<p id=\"so_27762691_27762691_8\">Cycle 4 has completed!</p>\n</blockquote>\n<p>I am not sure if this is due to some kind of thread locking going on due to how my code is structured or just an oversight in my coding for the output. If I could get a fresh pair of eyes to look over the code and point anything out that could be the fault I would appreciate it.</p>\n<p>Here is my code, it should be compilable in any MSVS 2013 install (no custom libraries used)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n#include &lt;future&gt;\n\nusing namespace std;\n\nclass mLaser\n{\npublic:\n    mLaser(int clen, float mamt)\n    {\n        mlCLen = clen;\n        mlMAmt = mamt;\n    }\n\n    int getCLen()\n    {\n        return mlCLen;\n    }\n\n    float getMAmt()\n    {\n        return mlMAmt;\n    }\n\n    void mCycle(int i1, int mCLength)\n    {\n        bool bMCycle = true;\n\n        int mCTime_left = mCLength * 1000;\n        int mCTime_start = GetTickCount(); //Get cycle start time\n        int mCTime_old = ((mCTime_start + 500) / 1000);\n\n        cout &lt;&lt; \"Time until cycle \" &lt;&lt; i1 &lt;&lt; \" is complete: \" &lt;&lt; endl;\n\n        while (bMCycle)\n        {\n            cout &lt;&lt; ((mCTime_left + 500) / 1000) &lt;&lt; \" seconds\";\n\n            bool bNChange = true;\n\n            while (bNChange)\n            {\n                //cout &lt;&lt; \".\";\n\n                int mCTime_new = GetTickCount();\n\n                if (mCTime_old != ((mCTime_new + 500) / 1000))\n                {\n                    //cout &lt;&lt; mCTime_old &lt;&lt; \" \" &lt;&lt; ((mCTime_new+500)/1000) &lt;&lt; endl;\n                    mCTime_old = ((mCTime_new + 500) / 1000);\n                    mCTime_left -= 1000;\n                    bNChange = false;\n                }\n            }\n            cout &lt;&lt; \" \\r\" &lt;&lt; flush;\n            if (mCTime_left == 0)\n            {\n                bMCycle = false;\n            }\n        }\n\n        cout &lt;&lt; \"Mining Cycle \" &lt;&lt; i1 &lt;&lt; \" finished\" &lt;&lt; endl;\n        system(\"Pause\");\n\n        return true;\n    }\n\n\n    private:\n    int mlCLen;\n    float mlMAmt;\n};\n\nstring sMCycle(mLaser ml, int i1, thread&amp; thread);\n\nint main()\n{\n    vector&lt;mLaser&gt; mlasers;\n    vector&lt;thread&gt; mthreads;\n    future&lt;string&gt; futr;\n\n    random_device rd;\n    mt19937 gen(rd());\n\n    uniform_int_distribution&lt;&gt; laser(1, 3);\n    uniform_int_distribution&lt;&gt; cLRand(30, 90);\n    uniform_real_distribution&lt;float&gt; mARand(34.0f, 154.3f);\n\n    int lasers;\n    int cycle_time;\n    float mining_amount;\n\n    lasers = laser(gen);\n\n    for (int i = 0; i &lt; lasers-1; i++)\n    {    \n        mlasers.push_back(mLaser(cLRand(gen), mARand(gen)));\n        mthreads.push_back(thread());\n    }\n\n    for (int i = 0; i &lt; mlasers.size(); i++)\n    {\n        futr = async(launch::async, [mlasers, i, &amp;mthreads]{return sMCycle(mlasers.at(i), i + 1, mthreads.at(i)); });\n\n        //mthreads.at(i) = thread(bind(&amp;mLaser::mCycle, ref(mlasers.at(i)), mlasers.at(i).getCLen(), mlasers.at(i).getMAmt()));\n    }\n\n    for (int i = 0; i &lt; mthreads.size(); i++)\n    {\n        //mthreads.at(i).join();\n    }\n\n\n    //string temp = futr.get();\n    //float out = strtof(temp.c_str(),NULL);\n\n    //cout &lt;&lt; out &lt;&lt; endl; \n\n    system(\"Pause\");\n    return 0;\n}\n\nstring sMCycle(mLaser ml, int i1, thread&amp; t1)\n{\n    t1 = thread(bind(&amp;mLaser::mCycle, ref(ml), ml.getCLen(), ml.getMAmt()));\n    //t1.join();\n\n    return \"122.0\";\n}\n</code></pre>\n", "Tags": "<c++><multithreading><command-line-interface>", "OwnerUserId": "836116", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27762691_27762766_0": {"section_id": 1922, "quality": 0.8157894736842105, "length": 31}}, "n3337": {"so_27762691_27762766_0": {"section_id": 1911, "quality": 0.8157894736842105, "length": 31}}, "n4659": {"so_27762691_27762766_0": {"section_id": 2193, "quality": 0.8157894736842105, "length": 31}}}, "27762766": {"ParentId": "27762691", "CommentCount": "1", "CreationDate": "2015-01-04T05:40:49.827", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "27762766", "Score": "3", "Body": "<p>Although writing from multiple threads concurrently to <code>std::cout</code> has to be data race free, there is no guarantee that concurrent writes won't be interleaved. I'm not sure if one write operation of one thread can be interleaved with one write operation from another thread but they can certainly be interleaved between write operations (I think individual outputs from different threads can be interleaved).</p>\n<p>What the standard has to say about concurrent access to the standard stream objects (i.e. <code>std::cout</code>, <code>std::cin</code>, etc.) is in 27.4.1 [iostream.objects.overview] paragraph 4:</p>\n<blockquote>\n<p id=\"so_27762691_27762766_0\">Concurrent access to a synchronized (27.5.3.4) standard iostream object\u2019s formatted and unformatted input (27.7.2.1) and output (27.7.3.1) functions or a standard C stream by multiple threads shall not result in a data race (1.10). [ Note: Users must still synchronize concurrent use of these objects and streams by multiple threads if they wish to avoid interleaved characters. \u2014end note ]</p>\n</blockquote>\n<p>If you want to have output appear in some sort of unit, you will need to synchronize access to <code>std::cout</code>, e.g., by using a mutex.</p>\n", "LastActivityDate": "2015-01-04T05:40:49.827"}});