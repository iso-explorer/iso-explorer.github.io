post_cb({"bq_ids": {"n4140": {"so_26408426_26408699_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 5873}, "so_26408426_26411022_0": {"length": 22, "quality": 0.5365853658536586, "section_id": 548}}, "n3337": {"so_26408426_26408699_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 5644}, "so_26408426_26411022_0": {"length": 22, "quality": 0.5365853658536586, "section_id": 539}, "so_26408426_26411022_1": {"length": 23, "quality": 0.575, "section_id": 5650}}, "n4659": {"so_26408426_26408699_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7356}, "so_26408426_26411022_0": {"length": 22, "quality": 0.5365853658536586, "section_id": 569}}}, "26408426": {"ViewCount": "162", "Body": "<p>There are various <code>pragma</code>s for controlling the struct/class layout, such as <code>pragma pack</code>. But as far as I know, there's no <code>pragma</code> for saying \"I don't care about the layout. It's internal, the code doesn't rely on it. Reorder it for best performance/size.\". AFAIK, that's the typical case, and it could improve performance/size in many cases. Also, even if the programmer was careful enough to reorder it for performance/size, a different target architecture might have a different optimal layout.</p>\n<p><strong>Edit:</strong> to clarify, I'm talking about the order of members. Padding is already controllable.</p>\n<p>Also, PVS-Studio has a relevant <a href=\"http://www.viva64.com/en/d/0150/\" rel=\"nofollow\">message</a>. That's what I'm talking about - why can't this be done by a compiler with a <code>pragma</code>?</p>\n", "AcceptedAnswerId": "26411022", "Title": "Is there a pragma for not caring about struct/class layout? If not, why?", "CreationDate": "2014-10-16T15:36:39.370", "Id": "26408426", "CommentCount": "8", "LastEditDate": "2014-10-16T15:52:48.493", "PostTypeId": "1", "LastEditorUserId": "2604492", "LastActivityDate": "2014-10-16T18:04:53.953", "Score": "0", "OwnerUserId": "2604492", "Tags": "<c++><c><struct><memory-layout>", "AnswerCount": "2"}, "26408699": {"Id": "26408699", "PostTypeId": "2", "Body": "<p>The language specifically calls out that class members will be ordered in memory the same way they are in each access level (like <code>private</code>). There is no way a pragma could override this behavior.</p>\n<p>See 9.2/14:</p>\n<blockquote>\n<p id=\"so_26408426_26408699_0\">Nonstatic data members of a (non-union) class with the same access\n  control (Clause 11) are allocated so that later members have higher\n  addresses within a class object. The order of allocation of non-static\n  data members with different access control is unspecified</p>\n</blockquote>\n<p>Bear in mind that reordering members changes the order in which sub-object constructors and destructors would be called, and possibly other things. It seems extremely risky even given a pragma for the compiler to make these sorts of changes behind the scenes (what if you have a member that depends on the initialization of another member).</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2014-10-16T17:54:33.813", "Score": "2", "CreationDate": "2014-10-16T15:49:24.700", "ParentId": "26408426", "CommentCount": "4", "OwnerUserId": "251738", "LastEditDate": "2014-10-16T17:54:33.813"}, "26411022": {"Id": "26411022", "PostTypeId": "2", "Body": "<p>Such a pragma would be permitted by the language standard, but I'm not aware of any compiler that implements such a thing.</p>\n<p>In C, the behavior of <code>#pragma</code> is specified in section 6.10.6 of <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">the standard</a> (the link is to the latest draft):</p>\n<blockquote>\n<p id=\"so_26408426_26411022_0\">A preprocessing directive of the form<br>\n<code></code><strong># pragma</strong> <em>pp-tokens</em><sub><em>opt</em></sub> <strong>new-line</strong><br>\n  where the preprocessing token <strong><code>STDC</code></strong> does not immediately\n  follow <strong><code>pragma</code></strong> in the directive (prior to any macro replacement)\n  causes the implementation to behave in an implementation-defined\n  manner. The behavior might cause translation to fail or cause the\n  translator or the resulting program to behave in a non-conforming\n  manner. Any such pragma that is not recognized by the implementation\n  is ignored.</br></br></p>\n</blockquote>\n<p>So a <code>#pragma</code> <em>can</em>, in effect, violate the rules of the language.</p>\n<p>The relevant rule in this case is that struct members are laid out in the order in which they're declared. 6.7.2.1 paragraph 15:</p>\n<blockquote>\n<p id=\"so_26408426_26411022_1\">Within a structure object, the non-bit-field members and the units in\n  which bit-fields reside have addresses that increase in the order in\n  which they are declared. A pointer to a structure object, suitably\n  converted, points to its initial member (or if that member is a\n  bit-field, then to the unit in which it resides), and vice versa.\n  There may be unnamed padding within a structure object, but not at its\n  beginning.</p>\n</blockquote>\n<p>The bad news: The C standard requires struct members to be laid out in the order in which they're declared. The first member must be at offset 0. There may be arbitrary padding between members, or after the last one, but they cannot be reordered.</p>\n<p>The good news: The language permits an implementation to define a <code>#pragma</code> that specifies a layout that violates the above rule.</p>\n<p>The bad news: As far as I know, no implementation actually does so. Even if one did, there are other implementations that do not, so any code that uses such a <code>#pragma</code> would be non-portable. (Though at least if the name of the <code>#pragma</code> is unique, any compilers that don't recognize it are required to ignore it, so your code would still compile.)</p>\n<p>That's for C.  The C++ rules for <code>#pragma</code> are very similar to the C rules. I'm reasonably sure the C++ rules for struct layout are also similar to C's; inheritance makes things a little more complex.</p>\n", "LastActivityDate": "2014-10-16T18:04:53.953", "CommentCount": "0", "CreationDate": "2014-10-16T18:04:53.953", "ParentId": "26408426", "Score": "1", "OwnerUserId": "827263"}});