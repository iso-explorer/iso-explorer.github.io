post_cb({"bq_ids": {"n4140": {"so_27392743_27392989_0": {"length": 37, "quality": 0.925, "section_id": 2717}}, "n3337": {"so_27392743_27392989_0": {"length": 37, "quality": 0.925, "section_id": 2678}}, "n4659": {"so_27392743_27392989_0": {"length": 35, "quality": 0.875, "section_id": 3457}}}, "27392743": {"ViewCount": "6284", "Body": "<p>Given below:</p>\n<pre><code>void test() \n{\n  std::chrono::seconds dura( 20 );\n  std::this_thread::sleep_for( dura );\n}\n\nint main()\n{\n  std::thread th1(test);\n  std::chrono::seconds dura( 5 );\n  std::this_thread::sleep_for( dura );\n  return 0;\n}\n</code></pre>\n<p><code>main</code> will exit after 5 seconds, what will happen to <code>th1</code> that's still executing?</p>\n<p>Does it continue executing until completion even if the <code>th1</code> thread object you defined in <code>main</code> goes out of scope and gets destroyed?</p>\n<p>Does <code>th1</code> simply sits there after it's finished executing or somehow gets cleaned up when the program terminates?</p>\n<p>What if the thread was created in a function, not <code>main</code> - does the thread stays around until the program terminates or when the function goes out of scope?</p>\n<p>Is it safe to simply not call <code>join</code> for a thread if you want some type of timeout behavior on the thread?</p>\n", "AcceptedAnswerId": "27392989", "Title": "C++11: What happens if you don't call join() for std::thread", "CreationDate": "2014-12-10T03:13:42.377", "Id": "27392743", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-10T15:49:25.220", "LastEditorUserId": "1708801", "LastActivityDate": "2017-07-11T07:39:48.650", "Score": "17", "OwnerUserId": "4322021", "Tags": "<c++><multithreading><c++11><stdthread>", "AnswerCount": "3"}, "27392780": {"Id": "27392780", "PostTypeId": "2", "Body": "<p><code>std::thread::~thread()</code></p>\n<blockquote>\n<p id=\"so_27392743_27392780_0\">If *this has an associated thread (<code>joinable() == true</code>), <code>std::terminate()</code> is called</p>\n</blockquote>\n<p>Source: <a href=\"http://en.cppreference.com/w/cpp/thread/thread/~thread\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/thread/thread/~thread</a></p>\n<p>This means that program like this is not at all well-formed or safe.</p>\n<p>Note, however, that <code>boost::thread::~thread()</code> calls <code>detach()</code> instead in this case.\n(as user <em>dyp</em> stated in comments, this behavior is deprecated in more recent versions)</p>\n<p>You could always workaround this using RAII. Just wrap your thread inside another class, that will have desired behavior on destruction.</p>\n", "LastEditorUserId": "1607442", "LastActivityDate": "2014-12-10T03:29:05.807", "Score": "5", "CreationDate": "2014-12-10T03:18:13.953", "ParentId": "27392743", "CommentCount": "3", "OwnerUserId": "1607442", "LastEditDate": "2014-12-10T03:29:05.807"}, "45028177": {"Id": "45028177", "PostTypeId": "2", "Body": "<p>In C++11, you must explicitly specify 'what happens' when the newly created thread goes out of scope (our it's dtor is called). Sometimes, when we are sure that the main thread, is continuing, and our threads are acting as 'pipeline', it is safe to 'detach()' them; and sometimes when we are waiting for our WORKER threads to complete their operations, we 'join()' them.</p>\n<p>As <a href=\"http://www.boost.org/doc/libs/1_57_0/doc/html/thread/thread_management.html#thread.thread_management.thread.destructor\" rel=\"nofollow noreferrer\">this</a> says, the programmer must ensure that the destructor is never executed while the thread is still joinable.</p>\n<p>Specify your multi-threaded strategy. In this example, <code>std::terminate()</code> is called.</p>\n", "LastEditorUserId": "7560000", "LastActivityDate": "2017-07-11T07:39:48.650", "Score": "1", "CreationDate": "2017-07-11T07:33:53.163", "ParentId": "27392743", "CommentCount": "0", "OwnerUserId": "7560000", "LastEditDate": "2017-07-11T07:39:48.650"}, "27392989": {"Id": "27392989", "PostTypeId": "2", "Body": "<p>If you have not detached or joined a thread when the destructor is called it will call <code>std::terminate</code>, we can see this by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">draft  C++11 standard</a> we see that section <code>30.3.1.3</code> <em>thread destructor</em> says:</p>\n<blockquote>\n<p id=\"so_27392743_27392989_0\">If joinable(), calls std::terminate(). Otherwise, has no effects. [\n  Note: Either implicitly detaching or joining a joinable() thread in\n  its destructor could result in difficult to debug correctness (for\n  detach) or performance (for join) bugs encountered only when an\n  exception is raised. Thus the programmer must ensure that the\n  destructor is never executed while the thread is still joinable. \u2014end\n  note ]</p>\n</blockquote>\n<p>as for a rationale for this behavior we can find a good summary in <a href=\"https://akrzemi1.wordpress.com/2012/11/14/not-using-stdthread/\" rel=\"noreferrer\">(Not) using std::thread</a> </p>\n<blockquote>\n<p id=\"so_27392743_27392989_1\">Why does the destructor of a joinable thread have to call\n  std::terminate? After all, the destructor could join with the child\n  thread, or it could detach from the child thread, or it could cancel\n  the thread. In short, you cannot join in the destructor as this would\n  result in unexpected (not indicated explicitly in the code) program\n  freeze in case f2 throws.</p>\n</blockquote>\n<p>and an example follows and also says:</p>\n<blockquote>\n<p id=\"so_27392743_27392989_2\">You cannot detach as it would risk the situation where main thread\n  leaves the scope which the child thread was launched in, and the child\n  thread keeps running and keeps references to the scope that is already\n  gone.</p>\n</blockquote>\n<p>The article references <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html\" rel=\"noreferrer\">N2802: A plea to reconsider detach-on-destruction for thread objects</a> which is argument against the previous proposal which was detach on destruction if joinable and it notes that one of the two alternatives would be to join which could lead to deadlocks the other alternative is what we have today which is <code>std::terminate</code> on destruction if joinable.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-12-10T04:43:00.397", "Score": "14", "CreationDate": "2014-12-10T03:44:24.550", "ParentId": "27392743", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-12-10T04:43:00.397"}});