post_cb({"41642359": {"CommentCount": "9", "AcceptedAnswerId": "42542260", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2017-01-13T19:45:50.963", "LastActivityDate": "2017-06-10T06:59:07.160", "LastEditDate": "2017-01-13T20:30:28.837", "ViewCount": "988", "FavoriteCount": "1", "Title": "Why does alias template give a conflicting declaration?", "Id": "41642359", "Score": "41", "Body": "<p>The port of some C++11 code from Clang to g++</p>\n<pre><code>template&lt;class T&gt;\nusing value_t = typename T::value_type;\n\ntemplate&lt;class&gt;\nstruct S\n{\n    using value_type = int;\n    static value_type const C = 0;\n};\n\ntemplate&lt;class T&gt; \nvalue_t&lt;S&lt;T&gt;&gt; // gcc error, typename S&lt;T&gt;::value_type does work\nconst S&lt;T&gt;::C;\n\nint main() \n{    \n    static_assert(S&lt;int&gt;::C == 0, \"\");\n}\n</code></pre>\n<p>gives different behavior for Clang (versions 3.1 through SVN trunk) versus for any g++ version. For the latter I get errors <a href=\"http://melpon.org/wandbox/permlink/I4RqLPAfxQQrD5ZF\" rel=\"noreferrer\"><strong>like this</strong></a></p>\n<blockquote id=\"so_41642359_41642359_0\">\n<pre><code>prog.cc:13:13: error: conflicting declaration 'value_t&lt;S&lt;T&gt; &gt; S&lt; &lt;template-parameter-1-1&gt; &gt;::C'\n const S&lt;T&gt;::C;\n             ^\nprog.cc:8:29: note: previous declaration as 'const value_type S&lt; &lt;template-parameter-1-1&gt; &gt;::C'\n     static value_type const C = 0;\n                             ^\nprog.cc:13:13: error: declaration of 'const value_type S&lt; &lt;template-parameter-1-1&gt; &gt;::C' outside of class is not definition [-fpermissive] const S&lt;T&gt;::C;\n</code></pre>\n</blockquote>\n<p>If instead of the template alias <code>value_t&lt;S&lt;T&gt;&gt;</code> I use the full <code>typename S&lt;T&gt;::value_type</code> then <a href=\"http://melpon.org/wandbox/permlink/Kk1OXnp9UO28Pi4c\" rel=\"noreferrer\"><strong>g++ also works</strong></a>.</p>\n<p><strong>Question</strong>: aren't template aliases supposed to be completely interchangeable with their underlying expression? Is this a g++ bug?</p>\n<p><strong>Update</strong>: Visual C++ also accepts the alias template in the out-of-class definition.</p>\n", "Tags": "<c++><c++11><templates><g++><template-aliases>", "OwnerUserId": "819272", "AnswerCount": "1"}, "42542260": {"ParentId": "41642359", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The problem relies on SFINAE. If you rewrite your member function to be <code>value_t&lt;S&lt;T&gt;&gt;</code>, like the outside declaration, then GCC will happily compile it:</p>\n<pre><code>template&lt;class T&gt;\nstruct S\n{\n    using value_type = int;\n    static const value_t&lt;S&lt;T&gt;&gt; C = 0;\n};\n\ntemplate&lt;class T&gt; \nconst value_t&lt;S&lt;T&gt;&gt; S&lt;T&gt;::C;\n</code></pre>\n<p>Because the expression is now <em>functionally</em> equivalent. Things like <em>substitution failure</em> come into play on alias-templates, but as you see, the member function <code>value_type const C</code> doesn't have the same \"prototype\" as <code>value_t&lt;S&lt;T&gt;&gt; const S&lt;T&gt;::C</code>. First one doesn't have to perform SFINAE, whereas the second one requires it. So clearly both declarations have different functionality, hence GCC's tantrum.</p>\n<p>Interestingly, Clang compiles it without a sign of abnormality. I assume it just so happens that the order of Clang's analyses are reversed, compared to GCC's. Once the alias-template expression is resolved and fine (i.e. it is well-formed), clang then compares both declarations and check it they are equivalent (which in this case they are, given both expressions resolve to <code>value_type</code>).</p>\n<p>Now, which one is correct from the standard's eyes? It's still an unresolved issue to whether consider alias-template's SFNIAE as part of its declaration's functionality. Quoting <a href=\"http://eel.is/c++draft/temp.alias#2\" rel=\"nofollow noreferrer\">[temp.alias]/2</a>:</p>\n<blockquote>\n<p id=\"so_41642359_42542260_0\">When a template-id refers to the specialization of an alias template, it is equivalent to the associated type obtained by substitution of its template-arguments for the template-parameters in the type-id of the alias template.</p>\n</blockquote>\n<p>In other words, these two are equivalent:</p>\n<pre><code>template&lt;class T&gt;\nstruct Alloc { /* ... */ };\n\ntemplate&lt;class T&gt;\nusing Vec = vector&lt;T, Alloc&lt;T&gt;&gt;;\n\nVec&lt;int&gt; v;\nvector&lt;int, Alloc&lt;int&gt;&gt; u;\n</code></pre>\n<p><code>Vec&lt;int&gt;</code> and <code>vector&lt;int, Alloc&lt;int&gt;&gt;</code> are equivalent types, because after substitution is performed, both types end up being <code>vector&lt;int, Alloc&lt;int&gt;&gt;</code>. Note how \"after substitution\" means that the equivalence is only checked once all template arguments are replaced with the template parameters. That is, comparison starts when <code>T</code> in <code>vector&lt;T, Alloc&lt;T&gt;&gt;</code> is replaced with <code>int</code> from <code>Vec&lt;int&gt;</code>. Maybe that's what Clang is doing with <code>value_t&lt;S&lt;T&gt;&gt;</code>? But then there's the following quote from <a href=\"http://eel.is/c++draft/temp.alias#3\" rel=\"nofollow noreferrer\">[temp.alias]/3</a>:</p>\n<blockquote>\n<p id=\"so_41642359_42542260_1\">However, if the template-id is dependent, subsequent template argument substitution still applies to the template-id. [Example:</p>\n<pre><code>template&lt;typename...&gt; using void_t = void;\ntemplate&lt;typename T&gt; void_t&lt;typename T::foo&gt; f();\nf&lt;int&gt;(); // error, int does not have a nested type foo\n</code></pre>\n<p id=\"so_41642359_42542260_2\">\u2009\u2014\u2009end example]</p>\n</blockquote>\n<p>Here's the problem: the expression <em>has</em> to be well-formed, so the compiler needs to check whether the substitution is fine. When there is a dependence in order to perform template argument substitution (e.g. <code>typename T::foo</code>), the functionality of the whole expression changes, and the definition of \"equivalence\" differs. For example, the following code won't compile (GCC and Clang):</p>\n<pre><code>struct X\n{\n    template &lt;typename T&gt;\n    auto foo(T) -&gt; std::enable_if_t&lt;sizeof(T) == 4&gt;;\n};\n\ntemplate &lt;typename T&gt;\nauto X::foo(T) -&gt; void\n{}\n</code></pre>\n<p>Because the outer <code>foo</code>'s prototype is functionally different from the inner one. Doing <code>auto X::foo(T) -&gt; std::enable_if_t&lt;sizeof(T) == 4&gt;</code> instead makes the code compile fine. It's so because the return type of <code>foo</code> is an expression that is dependent on the result of <code>sizeof(T) == 4</code>, so after template substitution, its prototype might be different from each instance of it. Whereas, <code>auto X::foo(T) -&gt; void</code>'s return type is never different, which conflicts with the declaration inside <code>X</code>. This is the very same issue that's happening with your code. So GCC seems to be correct in this case.</p>\n", "OwnerUserId": "3646096", "LastEditorUserId": "3980929", "LastEditDate": "2017-06-10T06:59:07.160", "Id": "42542260", "Score": "5", "CreationDate": "2017-03-01T21:20:17.873", "LastActivityDate": "2017-06-10T06:59:07.160"}, "bq_ids": {"n4140": {"so_41642359_42542260_0": {"section_id": 166, "quality": 1.0, "length": 17}}, "n3337": {"so_41642359_42542260_0": {"section_id": 160, "quality": 1.0, "length": 17}}, "n4659": {"so_41642359_42542260_0": {"section_id": 170, "quality": 1.0, "length": 17}, "so_41642359_42542260_1": {"section_id": 171, "quality": 0.9090909090909091, "length": 10}}}});