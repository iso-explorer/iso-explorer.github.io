post_cb({"bq_ids": {"n4140": {"so_16870789_16870814_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 3343}, "so_16870789_16870871_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 3354}}, "n3337": {"so_16870789_16870814_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 3213}, "so_16870789_16870871_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 3224}}, "n4659": {"so_16870789_16870814_1": {"length": 15, "quality": 0.625, "section_id": 4109}, "so_16870789_16870871_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 4121}}}, "16870871": {"Id": "16870871", "PostTypeId": "2", "Body": "<p>Calling of the destructor is part of <em>stack unwinding</em>, which is done when the exception \"bubbles up\" the call stack... <em>except</em> when the exception is unhandled. In that case, whether or not the stack is unwound <a href=\"http://www.csci.csusb.edu/dick/c++std/cd2/except.html\" rel=\"nofollow\">is implementation-defined</a>:</p>\n<blockquote>\n<p id=\"so_16870789_16870871_0\">If no matching handler is found in a program, the function <code>terminate()</code> (<code>except.terminate</code>)  is  called.  Whether or not the stack is unwound before calling <code>terminate()</code> is implementation-defined.</p>\n</blockquote>\n<p>To handle this more gracefully, you could use a function try block:</p>\n<pre><code>int main()\ntry {\n  // main body\n} catch (...) {\n  std::cerr &lt;&lt; \"Unhandled exception\\n\";\n  std::terminate();\n}\n</code></pre>\n<p>... although this will swallow the exception and make it hard to debug.</p>\n", "LastActivityDate": "2013-06-01T08:46:09.613", "CommentCount": "0", "CreationDate": "2013-06-01T08:46:09.613", "ParentId": "16870789", "Score": "4", "OwnerUserId": "14637"}, "16870789": {"ViewCount": "272", "Body": "<p>I have my smart pointer implementation as bellow which is NOT deallocating memory at exceptions .. </p>\n<pre><code>template &lt;class T&gt;\nclass SMARTPOINTER\n{\npublic:\n   SMARTPOINTER(T* pointee) : SMART_POINTEE(pointee) {\n    cout &lt;&lt;\"\\n Inside class SMARTPOINTER CONSTURCTOR \\n\";\n   }\n\n   ~SMARTPOINTER() {\n     cout &lt;&lt;\"\\n Inside class SMARTPOINTER DESTRUCTOR \\n\";\n      delete SMART_POINTEE;\n   }\n\n   T&amp; operator*() const\n   {\n      cout &lt;&lt;\"\\n Inside class SMARTPOINTER operator* \\n\";\n      return *SMART_POINTEE;\n   }\n\n   T* operator-&gt;() const\n   {\n      cout &lt;&lt;\"\\n Inside class SMARTPOINTER operator-&gt;()  \\n\";\n      return SMART_POINTEE;\n   }\n\nprivate:\n   T* SMART_POINTEE;\n\n};\n\nclass Widget\n{\npublic:\n\n  Widget() {\n      cout &lt;&lt;\"\\n Inside Widget CONSTRUCTOR \\n\";\n  }\n\n   void Fun() { \n     cout &lt;&lt;\"\\n Inside Widget::Fun() \\n\";\n   }\n\n  ~Widget() {\n      cout &lt;&lt;\"\\n Inside Widget DESTRUCTOR \\n\";\n  }\n\n};\n\nclass THROWME{\n\n};\n\nint main() {\n\nSMARTPOINTER&lt;Widget&gt; sp(new Widget);\nsp-&gt;Fun();\nthrow new THROWME;\n(*sp).Fun();\n\nreturn 0 ;\n}\n</code></pre>\n<p>I find that the output is </p>\n<pre><code>Inside Widget CONSTRUCTOR \n\n Inside class SMARTPOINTER CONSTURCTOR \n\n Inside class SMARTPOINTER operator-&gt;()  \n\n Inside Widget::Fun() \nuncaught exception of type THROWME*\nAborted.\n</code></pre>\n<p>As far as I know Smart pointers are supposed to help me in such cases!! I do not find destruction of Widget getting called via smart pointer . </p>\n<p>So I must be missing some implementation here . </p>\n<p><strong>EDIT AFTER COMMENTS READ</strong> </p>\n<p>With try catch i got my result  . But i still dont know if its right approach \nchange in code </p>\n<pre><code>  int main() {\n        try {\n        SMARTPOINTER&lt;Widget&gt; sp(new Widget);\n        sp-&gt;Fun();\n        THROWME tm;\n        throw tm;\n        (*sp).Fun();\n        }\n        catch(...) {\n          cout &lt;&lt;\"\\n **SOME EXCEPTION CAUGHT**  \\n\";\n        }\n        return 0 ;\n        }\n</code></pre>\n<p><strong>result</strong> </p>\n<pre><code> Inside Widget CONSTRUCTOR \n\n Inside class SMARTPOINTER CONSTURCTOR \n\n Inside class SMARTPOINTER operator-&gt;()  \n\n Inside Widget::Fun() \n\n Inside class SMARTPOINTER DESTRUCTOR \n\n Inside Widget DESTRUCTOR \n\n **SOME EXCEPTION CAUGHT**\n</code></pre>\n", "Title": "Smart pointer not able to deallocate memory", "CreationDate": "2013-06-01T08:35:10.010", "Id": "16870789", "CommentCount": "11", "LastEditDate": "2013-06-01T08:54:00.857", "PostTypeId": "1", "LastEditorUserId": "1636300", "LastActivityDate": "2013-06-01T08:54:00.857", "Tags": "<c++><pointers><memory><smart-pointers>", "Score": "3", "OwnerUserId": "1636300", "ClosedDate": "2013-06-01T09:01:01.987", "AnswerCount": "2"}, "16870814": {"Id": "16870814", "PostTypeId": "2", "Body": "<p>The destructor is not being called as the unhandled exception <code>THROWME</code> causes <code>std::terminate</code> to be called. See also <a href=\"https://stackoverflow.com/questions/8311457/are-destructors-called-after-a-throw-in-c\">this question</a>, specifically the first quotation in the accepted answer:</p>\n<blockquote>\n<p id=\"so_16870789_16870814_0\">C++11 15.2 Constructors and destructors [except.ctor]</p>\n<p id=\"so_16870789_16870814_1\">1 As control passes from a throw-expression to a handler, destructors are invoked for all automatic objects constructed since <strong>the try block</strong> was entered. The automatic objects are destroyed in the reverse order of the completion of their construction.</p>\n</blockquote>\n<p>As you have no try block to handle the exception, no destructor is called.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-01T08:37:51.387", "Score": "4", "CreationDate": "2013-06-01T08:37:51.387", "ParentId": "16870789", "CommentCount": "0", "OwnerUserId": "2361316", "LastEditDate": "2017-05-23T10:25:52.980"}});