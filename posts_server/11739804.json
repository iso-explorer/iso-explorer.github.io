post_cb({"bq_ids": {"n4140": {"so_11739804_11739951_1": {"length": 5, "quality": 0.625, "section_id": 3218}, "so_11739804_11739951_2": {"length": 13, "quality": 0.7647058823529411, "section_id": 3223}}, "n3337": {"so_11739804_11739951_1": {"length": 5, "quality": 0.625, "section_id": 3092}, "so_11739804_11739951_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 3097}}, "n4659": {"so_11739804_11739951_1": {"length": 5, "quality": 0.625, "section_id": 3975}, "so_11739804_11739951_2": {"length": 13, "quality": 0.7647058823529411, "section_id": 3980}}}, "11739804": {"ViewCount": "159", "Body": "<p>Suppose to have the code</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A{\n  int y;\n  int&amp; x;\n  A():y(0),x(y){}\n};\n\n\n\nvoid f(int&amp; x){\n  x++;\n}\n\nvoid g(const A&amp; a){\n  f(a.x);\n  //f(a.y);\n}\n\n\nint main(){\n  A a;\n  g(a);\n  std::cout&lt;&lt;a.y&lt;&lt;std::endl;\n\n}\n</code></pre>\n<p>inside g()\ncalling f() on y is not allowed because a is passed with the const modifier\nhowever, the value of y can be modified inside g() by calling f on x;</p>\n<p>With pointers, a similar things can be obtained very similarly</p>\n<pre><code>struct B{\n  int* x;  \n}\n</code></pre>\n<p>and </p>\n<pre><code>g(const B&amp;){\n   *x++;\n}\n</code></pre>\n<p>is allowed. This is perfectly clear: We have a const pointer to non-const int.\nBut in the previous reference example, if references ARE the object, why do in this case they behave as pointers? What are the design policies under this behavior?</p>\n", "AcceptedAnswerId": "11739951", "Title": "Design reasons for the behavior of reference members of classes passed by const reference", "CreationDate": "2012-07-31T12:10:55.057", "Id": "11739804", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2012-07-31T13:03:54.543", "Score": "3", "OwnerUserId": "1296119", "Tags": "<c++><reference>", "AnswerCount": "3"}, "11739910": {"Id": "11739910", "PostTypeId": "2", "Body": "<p>In C++ references are usually implemented by pointers.  (I think that the <code>sizeof</code> a reference and pointer are the same).</p>\n<p>Indeed I usually think of references as pointers, but with different syntax.</p>\n", "LastActivityDate": "2012-07-31T12:19:00.643", "CommentCount": "4", "CreationDate": "2012-07-31T12:19:00.643", "ParentId": "11739804", "Score": "0", "OwnerUserId": "4834"}, "11739951": {"Id": "11739951", "PostTypeId": "2", "Body": "<p>The actual language in the standard is</p>\n<blockquote>\n<p id=\"so_11739804_11739951_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>8.3.2 References [dcl.ref]</h3>\n<p id=\"so_11739804_11739951_1\">1 - [...]\n  [ Note: A reference can be thought of as a name of an object. \u2014end note ]</p>\n</blockquote>\n<p>So if a reference is a <em>name</em> of an object, not an object itself, then it makes sense that causing the enclosing structure to be <code>const</code> makes the name <code>const</code> (which is meaningless, as references can't be rebound), but not the object itself.</p>\n<p>We also see</p>\n<blockquote>\n<p id=\"so_11739804_11739951_2\">6 - \n  If a typedef, a type template-parameter, or a decltype-speci\ufb01er denotes a type TR\n  that is a reference to a type T, an attempt to create the type \u201clvalue reference to <em>cv</em> TR\u201d creates the type \u201clvalue reference to T\u201d [...]</p>\n</blockquote>\n<p>Since member access on a <em>cv</em> object creates a <em>cv</em> lvalue, the same applies and the <em>cv</em> qualification is extinguished.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-07-31T12:29:00.683", "Score": "3", "CreationDate": "2012-07-31T12:21:50.560", "ParentId": "11739804", "CommentCount": "2", "OwnerUserId": "567292", "LastEditDate": "2012-07-31T12:29:00.683"}, "11739943": {"Id": "11739943", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11739804_11739943_0\">if references ARE the object</p>\n</blockquote>\n<p>references are <em>not</em> objects though - they're references to objects.</p>\n<p>You're right that making a reference itself const isn't very useful: since they're non-reseatable, they can't be mutated like pointers in any case.</p>\n<p>In fact, it might be more helpful to think of a reference as a const pointer (not a pointer-to-const!) with special syntax.</p>\n<p>Note that if you <em>want</em> an indirection which does propogate constness from the referee to the referent (ie, to prevent the <code>f(a.x)</code> call here), you can write a smart pointer-style thing to do it.</p>\n<hr>\n<p>Concrete example</p>\n<pre><code>struct A\n{\n    int x;\n    int *p;\n    int &amp;r;\n\n    A() : x(0), p(&amp;x), r(x) {}\n};\n</code></pre>\n<p>Now in <code>A a</code>:</p>\n<ul>\n<li><code>a.x</code> is a mutable int</li>\n<li><code>a.p</code> is a mutable pointer (so we can reseat it) to a mutable int (we can change the value of the integer it points to)</li>\n<li>and <code>a.r</code> is a reference to a mutable int\n<ul>\n<li>note that since we can't mutate (reseat) references anyway, it doesn't mean anything for the reference itself to be either const or mutable</li>\n</ul></li>\n</ul>\n<p>... but in <code>const A b</code>:</p>\n<ul>\n<li><code>b.x</code> is a constant integer</li>\n<li><code>b.p</code> is a constant pointer (so we can't reseat it) to a mutable int</li>\n<li><code>b.r</code> is a reference to a mutable int\n<ul>\n<li>note how the constness is applied to the member of A (the pointer or reference) and does <em>not</em> propogate through to the referent.</li>\n</ul></li>\n</ul>\n</hr>", "LastEditorUserId": "212858", "LastActivityDate": "2012-07-31T13:03:54.543", "Score": "4", "CreationDate": "2012-07-31T12:21:27.917", "ParentId": "11739804", "CommentCount": "3", "OwnerUserId": "212858", "LastEditDate": "2012-07-31T13:03:54.543"}});