post_cb({"22315804": {"ParentId": "22315683", "LastEditDate": "2014-03-11T03:28:34.540", "CommentCount": "1", "CreationDate": "2014-03-11T03:21:25.717", "OwnerUserId": "1583065", "LastEditorUserId": "1583065", "PostTypeId": "2", "Id": "22315804", "Score": "1", "Body": "<p>You can test parts of this with a little experiment:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n    float f;\n    std::string s;\n\n    std::cin &gt;&gt; f;\n    std::cin &gt;&gt; s;\n\n    std::cout &lt;&lt; f &lt;&lt; std::endl;\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Then compile:</p>\n<pre><code>$ g++ --version\ng++ (GCC) 4.8.2\n...\n\n$ g++ -std=c++11 -pedantic -Wextra -Wall ./fltest.cpp\n</code></pre>\n<p>And run with input that you know has more digits than a <code>float</code> has:</p>\n<pre><code>$ echo '3.1415926535 foo' | ./a.out\n3.14159\nfoo\n</code></pre>\n<p>So it seems that the extraneous extra precision is discarded (a single-precision floating-point number has a litte more than 7 decimal digits of precision.</p>\n<p>You can play with the input and output precision to see what effects these have by putting, say:</p>\n<pre><code>std::cin.precision(7);\n</code></pre>\n<p>before the <code>std::cin &gt;&gt; f;</code> line or, say:</p>\n<pre><code>std::cout.precision(10);\n</code></pre>\n<p>before the <code>std::cout &lt;&lt; f;</code> line.</p>\n", "LastActivityDate": "2014-03-11T03:28:34.540"}, "22315925": {"ParentId": "22315683", "CommentCount": "1", "Body": "<p>See the info for \"(1) arithmetic types\" in the <a href=\"http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/\" rel=\"nofollow\">std::istream::operator&gt;&gt; docs</a>.  This uses <code>num_get::get()</code> and the relevant part of the docs for that states \"The function stops reading characters from the sequence as soon as one character cannot be part of a valid numerical expression\".</p>\n<p>So from the documentation it seems that all available digits will be read, but they won't all be used if the float type is too \"narrow\".</p>\n", "OwnerUserId": "2067682", "PostTypeId": "2", "Id": "22315925", "Score": "3", "CreationDate": "2014-03-11T03:34:47.610", "LastActivityDate": "2014-03-11T03:34:47.610"}, "22315683": {"CommentCount": "0", "ViewCount": "1296", "CreationDate": "2014-03-11T03:09:03.960", "LastActivityDate": "2014-03-11T03:42:53.957", "Title": "Reading float with C++ input operator", "AcceptedAnswerId": "22315925", "PostTypeId": "1", "Id": "22315683", "Score": "2", "Body": "<p>Consider</p>\n<pre><code>float num;\ncin &gt;&gt; num;\n</code></pre>\n<p>Is it well defined how many characters of the input this code can consume. I am particularly interested in the case where the input stream may have the <code>num</code> specified in a much higher precision than what the <code>float</code> type can represent. So, in this case is it standardized whether the code would read all of it (up to but not including the next non-numeric input), or just up to the max precision of <code>float</code>.</p>\n", "Tags": "<c++><input><floating-point><floating-point-conversion>", "OwnerUserId": "617371", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_22315683_22315876_7": {"section_id": 6536, "quality": 1.0, "length": 19}, "so_22315683_22315876_6": {"section_id": 6536, "quality": 1.0, "length": 15}, "so_22315683_22315876_3": {"section_id": 6536, "quality": 0.8, "length": 4}, "so_22315683_22315876_0": {"section_id": 6536, "quality": 0.9333333333333333, "length": 14}, "so_22315683_22315876_5": {"section_id": 6536, "quality": 1.0, "length": 10}, "so_22315683_22315876_1": {"section_id": 6536, "quality": 0.8333333333333334, "length": 5}, "so_22315683_22315876_4": {"section_id": 6536, "quality": 0.8333333333333334, "length": 5}, "so_22315683_22315876_2": {"section_id": 6536, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_22315683_22315876_7": {"section_id": 6291, "quality": 1.0, "length": 19}, "so_22315683_22315876_6": {"section_id": 6291, "quality": 1.0, "length": 15}, "so_22315683_22315876_3": {"section_id": 6291, "quality": 0.8, "length": 4}, "so_22315683_22315876_0": {"section_id": 6291, "quality": 0.9333333333333333, "length": 14}, "so_22315683_22315876_5": {"section_id": 6291, "quality": 1.0, "length": 10}, "so_22315683_22315876_1": {"section_id": 6291, "quality": 0.8333333333333334, "length": 5}, "so_22315683_22315876_4": {"section_id": 6291, "quality": 0.8333333333333334, "length": 5}, "so_22315683_22315876_2": {"section_id": 6291, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_22315683_22315876_0": {"section_id": 8018, "quality": 0.9333333333333333, "length": 14}, "so_22315683_22315876_6": {"section_id": 8018, "quality": 1.0, "length": 15}, "so_22315683_22315876_7": {"section_id": 8018, "quality": 0.7368421052631579, "length": 14}, "so_22315683_22315876_4": {"section_id": 8018, "quality": 0.8333333333333334, "length": 5}, "so_22315683_22315876_5": {"section_id": 8018, "quality": 0.9, "length": 9}, "so_22315683_22315876_1": {"section_id": 8018, "quality": 0.8333333333333334, "length": 5}, "so_22315683_22315876_2": {"section_id": 8018, "quality": 0.8333333333333334, "length": 5}}}, "22315876": {"ParentId": "22315683", "LastEditDate": "2014-03-11T03:42:53.957", "CommentCount": "1", "CreationDate": "2014-03-11T03:28:57.197", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "PostTypeId": "2", "Id": "22315876", "Score": "3", "Body": "<p>The input is defined in std::num_get 22.4.2.1.2:</p>\n<blockquote>\n<p id=\"so_22315683_22315876_0\">Stage 3: The sequence of chars accumulated in stage 2 (the field) is\n  converted to a numeric value by the rules of one of the functions\n  declared in the header : </p>\n<p id=\"so_22315683_22315876_1\">\u2014 For a signed integer value, the function strtoll. </p>\n<p id=\"so_22315683_22315876_2\">\u2014 For an unsigned integer value, the function strtoull.</p>\n<p id=\"so_22315683_22315876_3\">\u2014 For a floating-point value, the function strtold. </p>\n<p id=\"so_22315683_22315876_4\">The numeric value to be stored can be one of:</p>\n<p id=\"so_22315683_22315876_5\">\u2014 zero, if the conversion function fails to convert the entire field. ios_base::failbit is assigned to err.</p>\n<p id=\"so_22315683_22315876_6\">\u2014 the most positive representable value, if the field\n  represents a value too large positive to be represented in val.\n  ios_base::failbit is assigned to err. </p>\n<p id=\"so_22315683_22315876_7\">\u2014 the most negative representable value or zero for an unsigned integer type, if the field\n  represents a value too large negative to be represented in val.\n  ios_base::failbit is assigned to err.</p>\n</blockquote>\n<p>Hence, the stream will consume all valid patterns of numbers (even after overflow) and the state will be set accordingly.</p>\n", "LastActivityDate": "2014-03-11T03:42:53.957"}});