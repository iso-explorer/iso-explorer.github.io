post_cb({"bq_ids": {"n4140": {"so_28920949_28921140_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 6142}, "so_28920949_28921140_0": {"length": 34, "quality": 0.7727272727272727, "section_id": 5986}}, "n3337": {"so_28920949_28921140_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 5906}, "so_28920949_28921140_0": {"length": 35, "quality": 0.7954545454545454, "section_id": 5754}}, "n4659": {"so_28920949_28921140_0": {"length": 32, "quality": 0.7272727272727273, "section_id": 7486}}}, "28921140": {"Id": "28921140", "PostTypeId": "2", "Body": "<p>First, you need to recall that subscripting on a pointer is essentially syntactical sugar designed to make it easier to operate with arrays. Perversely, it achieves that by performing arithmetic on pointers to elements of such arrays.</p>\n<p>So, given <code>int array[3]</code>, and a pointer <code>int* ptr = &amp;array[0]</code>, <code>ptr[2]</code> is a pointer to the 3rd element of <code>array</code>.</p>\n<p>For precisely the same reason, and due to how the names of arrays decay into pointers, <code>array[2]</code> is a pointer to the 3rd element of <code>array</code>.</p>\n<p>You can even change the \"starting point\": given <code>int* ptr = &amp;array[1]</code>, <code>ptr[1]</code> is also a pointer to the 3rd element of <code>array</code>, because you're essentially writing <code>(array+1+1)</code>.</p>\n<p>There is no reason that you cannot apply the same logic to the pointer called <code>this</code>. However, it's well-defined if <em>and only if</em> the object was allocated as part of an array, and you are not trying to read beyond the bounds of that array.</p>\n<p>Here's an example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct T\n{\n   int x;\n\n   T(int x) : x(x) {};\n   void bar() { std::cout &lt;&lt; x &lt;&lt; std::endl; }\n   void foo() { this[1].bar(); }  // or (this+1).bar()\n};\n\nint main()\n{\n   T array[4] = { T(0), T(1), T(2), T(3) };\n   array[0].foo();  // OK, outputs 1\n   array[1].foo();  // OK, outputs 2\n   array[2].foo();  // OK, outputs 3\n   array[3].foo();  // undefined; `this[1]` is the same as `array[4]`, so\n                    //   evaluating that pointer has UB, never mind invoking\n                    //   bar() through it and printing a member variable!\n}\n</code></pre>\n<p>And here's the relevant standard wording:</p>\n<blockquote>\n<p id=\"so_28920949_28921140_0\"><code>[C++11: 5.2.1/2]:</code> A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type \u201cpointer to <code>T</code>\u201d and the other shall have unscoped enumeration or integral type. The result is an lvalue of type \u201c<code>T</code>.\u201d The type \u201c<code>T</code>\u201d shall be a completely-defined object type. The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code> <em>[ Note:</em> see 5.3 and 5.7 for details of <code>*</code> and <code>+</code> and 8.3.4 for details of arrays. <em>\u2014end note ]</em></p>\n<p id=\"so_28920949_28921140_1\"><code>[C++11: 5.7/5]:</code> When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. <em>[..]</em></p>\n</blockquote>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-03-07T23:11:35.080", "Score": "3", "CreationDate": "2015-03-07T23:06:27.073", "ParentId": "28920949", "CommentCount": "0", "OwnerUserId": "560648", "LastEditDate": "2015-03-07T23:11:35.080"}, "28921117": {"Id": "28921117", "PostTypeId": "2", "Body": "<p>Pointer arithmetic assumes it is working over an array.   Given an array any type <code>t</code></p>\n<pre><code>t x[6];\n</code></pre>\n<p>then <code>x+5</code> is equal to <code>&amp;x[5]</code>.   </p>\n<p>So, <code>this + 5u</code> assumes that <code>*this</code> is an element of an array (or a <code>std::vector</code>) with at least 5 subsequent elements, and gives the address of the sixth element (since array indexing starts at zero).</p>\n<p>If <code>*this</code> is not an element of an array followed by at least 5 elements, then evaluating <code>this + 5</code> and any subsequent attempt to iterate elements over the vector and dereference the pointers will have undefined behaviour.</p>\n<p>Let's say you have a member function that does this;</p>\n<pre><code>void Foo::something()\n{\n    std::vector&lt;decltype(this)&gt; foo{this, this + 5u};\n\n    for (auto &amp;iter: foo)\n         iter-&gt;ChangeMe();     //  member function of Foo that changes something\n}\n</code></pre>\n<p>then using it like this</p>\n<pre><code>Foo x[6];\nx[0].something();    // okay ... will iterate over all elements of x\nx[5].something();    // undefined behaviour, since the loop will fall off the end of x\n</code></pre>\n<p>Whether it is useful or not depends on what you are doing.  I suggest not ... it is rare that an object needs to access elements of an array (or container) that contains it.</p>\n", "LastEditorUserId": "4491408", "LastActivityDate": "2015-03-08T04:02:26.040", "Score": "0", "CreationDate": "2015-03-07T23:03:44.033", "ParentId": "28920949", "CommentCount": "6", "OwnerUserId": "4491408", "LastEditDate": "2015-03-08T04:02:26.040"}, "28920949": {"ViewCount": "98", "Body": "<p>What does <code>this[5]</code> do? Have I invoked some kind of undefined behavior? What about:</p>\n<pre><code>std::vector&lt;decltype(this)&gt; foo{this, this + 5u};\n</code></pre>\n<p>Is this useful? I want to know what the effects of pointer arithmetic on <code>this</code> are. Here's a test program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct Foo\n{\n    int n = 1;\n\n    void foo()\n    {\n        std::vector&lt;decltype(this)&gt; foo{this, this + 5u};\n        for (decltype(foo.size()) i = 0; i != foo.size(); ++i)\n        {\n            std::cout &lt;&lt; foo[i]-&gt;n &lt;&lt; \"\\n\";\n        }\n    }\n};\n\nint main()\n{\n    Foo{}.foo();\n}\n\n/* OUTPUT:\n * 1\n * 0\n */\n</code></pre>\n", "Title": "Effect of subscripting the this pointer", "CreationDate": "2015-03-07T22:45:48.520", "LastActivityDate": "2015-03-08T04:02:26.040", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-03-07T22:57:52.367", "LastEditorUserId": "4645413", "Id": "28920949", "Score": "3", "OwnerUserId": "4645413", "Tags": "<c++>", "AnswerCount": "3"}, "28921078": {"Id": "28921078", "PostTypeId": "2", "Body": "<p><code>this</code> inside non-static member functions of class <code>C</code> is a special variable of type <code>C * const</code> which points to class instance \"start\" in memory.</p>\n<p>Pointer arithmetic with <code>this</code> is defined by same rules as for usual pointers, so</p>\n<pre><code>this[5]\n</code></pre>\n<p>is similar to</p>\n<pre><code>struct T\n{\n  ...\n};\n\nT t[10];\n\nt[5]; // this\n</code></pre>\n<p>\u2014 it's accessing of 6-th element of \"array\", or</p>\n<pre><code>*(C *)((void *)this + sizeof(C) * 5)\n</code></pre>\n<p>In general this doesn't make sense for <code>this</code>.</p>\n<p>In following code:</p>\n<pre><code>std::vector&lt;decltype(this)&gt; foo{this, this + 5u};\n</code></pre>\n<p>you define vector of <code>C *</code> pointers and initialize them with:</p>\n<pre><code>{(void *)this, (void *)this + sizeof(C) * 1, (void *)this + sizeof(C) * 2, (void *)this + sizeof(C) * 3, (void *)this + sizeof(C) * 4}\n</code></pre>\n<p>In general this doesn't make sense either.</p>\n<p>If <code>C</code> is of \"simple\" type (POD or has no parent/derived classes), then when bunch of <code>C</code> instances are continuous memory (e.g. in array or <code>vector</code>), then you can access in that way (this[1]) adjacent elements.</p>\n<p>But if your class is part of complex hierarchy, then <code>this[1]</code> may point on some place not aligned with <code>C</code> type, since in complex hierarchy classes are aligned in non-trivial way in memory.</p>\n<p><strong>UPDATE:</strong> question was updated with example </p>\n<p>In this example: </p>\n<pre><code>struct Foo\n{\n    int n = 1;\n\n    void foo()\n    {\n        std::vector&lt;decltype(this)&gt; foo{this, this + 5u};\n        for (decltype(foo.size()) i = 0; i != foo.size(); ++i)\n        {\n            std::cout &lt;&lt; foo[i]-&gt;n &lt;&lt; \"\\n\";\n        }\n    }\n};\n\nint main()\n{\n    Foo{}.foo();\n}\n</code></pre>\n<p>Foo is POD type, it will most probably take 4, 8 or 16 bytes in memory depending on alignment options and is system 32-bit or 64-bit. Lets assume <code>sizeof(Foo) == 4</code>.</p>\n<p><code>Foo{}</code> will create instance of Foo on stack. Then <code>foo()</code> method will be called.</p>\n<p>Inside <code>foo()</code> method <code>this</code> will point on <code>Foo</code> instance start in stack memory. Lets assume it's 0xAABBCC00.</p>\n<p>This line:</p>\n<pre><code>std::vector&lt;decltype(this)&gt; foo{this, this + 5u};\n</code></pre>\n<p>will create vector of <code>Foo *</code>, and initialize it with <code>{0xAABBCC00, 0xAABBCC04, 0xAABBCC08, 0xAABBCC0C}</code>.</p>\n<p>Then you iterate over <code>foo</code>:</p>\n<pre><code>        for (decltype(foo.size()) i = 0; i != foo.size(); ++i)\n        {\n            std::cout &lt;&lt; foo[i]-&gt;n &lt;&lt; \"\\n\";\n        }\n</code></pre>\n<p><code>foo[0]</code> is <code>this</code>, so all will be ok.</p>\n<p><code>foo[1]-&gt;n</code> is <code>(Foo *)((void *)0xAABBCC04)-&gt;n</code> which is simply <code>*(int *)(Foo *)((void *)0xAABBCC04)</code>, because <code>n</code> is placed at begin of <code>Foo</code> structure \u2014 this is reading of some not directly initialized memory that is adjacent to <code>this</code>.\nThis read and read of <code>foo[2]-&gt;</code>, <code>foo[3]-&gt;</code>, <code>foo[4]-&gt;</code> has undefined behaviour and usually lead to reading some garbage or segmentation faults.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-03-08T01:12:34.703", "Score": "1", "CreationDate": "2015-03-07T23:00:36.257", "ParentId": "28920949", "CommentCount": "0", "OwnerUserId": "391865", "LastEditDate": "2015-03-08T01:12:34.703"}});