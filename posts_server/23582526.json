post_cb({"23582553": {"ParentId": "23582526", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Since, you are not calling <code>A::f()</code>, these will happen:</p>\n<pre><code>f(10.5); // cast to int\nstring s=\"Hi\";\nf(s);  //I do not know any B::f(), with string argument.\n</code></pre>\n<p>To be more exact, in the first line of the code I pasted,\nthe compiler will try to call <code>f(int a)</code>. You pass <code>10.5</code> and the function waits for an integer. However, <code>10.5</code> can be casted to an <code>int</code>, by cutting its decimal digits. This function is the one of <code>namespace B</code>.</p>\n<p>[EDIT]</p>\n<p>The default <code>namespace</code> is the one you have your functions inside. In order to not the use the default, you have to specify it yourself, be the <code>::</code> operator.</p>\n<p>If you remove the <code>f()</code> inside the <code>namespace B</code>, then the compiler will go to the <code>namespace A</code>, which is the 'outer' <code>namespace</code>.</p>\n<p>Maybe this analogy with the <code>scope of the variables</code> can help.</p>\n<pre><code>int main() {\n\n  int a = 10;\n\n  {\n    int a = 5;\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n  }\n\n  return 0;\n}\n</code></pre>\n<p>The output is <code>5</code>. When it's time to print <code>a</code>, the compiler will go and find the last declared <code>a</code>, except otherwise told by us.</p>\n", "OwnerUserId": "2411320", "LastEditorUserId": "2411320", "LastEditDate": "2014-05-10T15:09:56.433", "Id": "23582553", "Score": "1", "CreationDate": "2014-05-10T14:57:31.840", "LastActivityDate": "2014-05-10T15:09:56.433"}, "23582874": {"ParentId": "23582526", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This is what is known as <em>name hiding</em>:</p>\n<blockquote>\n<p id=\"so_23582526_23582874_0\">A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived class (10.2).</p>\n</blockquote>\n<p>The declaration of <code>B::f</code> is hiding both overloads of <code>A::f</code> despite the <code>using namespace</code> declaration. The technical reason for which it wasn't working was because of the way unqualified lookup works. The compiler first searches the most local namespace for the symbol, and works its way up until it finds it. Implicit conversions are allowed which was why <code>B::f</code> was consistently being called and why the overload for <code>std::string</code> could not be chosen. To fix this, you can add the outer namespace function in explicitly using a <code>using</code> declaration:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>using A::f;\nvoid f(int) { ... }\n\nvoid call()\n{\n    // ...\n}\n</code></pre>\n<p><a href=\"http://ideone.com/fkYqKw\" rel=\"nofollow\"><strong>Here is a demo.</strong></a></p>\n", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2014-05-10T15:32:07.887", "Id": "23582874", "Score": "1", "CreationDate": "2014-05-10T15:26:55.857", "LastActivityDate": "2014-05-10T15:32:07.887"}, "23582526": {"CommentCount": "0", "AcceptedAnswerId": "23583080", "PostTypeId": "1", "LastEditorUserId": "1390091", "CreationDate": "2014-05-10T14:54:51.383", "LastActivityDate": "2014-05-10T15:44:56.360", "LastEditDate": "2014-05-10T15:19:50.680", "ViewCount": "102", "FavoriteCount": "1", "Title": "How Name Lookup is applied in Namespaces", "Id": "23582526", "Score": "1", "Body": "<p>I don't understand why the following code gives error:</p>\n<pre><code>namespace  A\n{\n    void f(double x){cout&lt;&lt;\"A::f(double)\\n\";}\n\n    void f(string s){cout&lt;&lt;\"A::f(string)\\n\";}\n\n    namespace B\n    {\n        using namespace A;\n        void f(int x){cout&lt;&lt;\"B::f\\n\";}\n\n        void call()\n        {\n            f(10);  // calls B::f, expected\n            f(10.5); // calls B::f, why??\n            string s=\"Hi\";\n            f(s);  // error, why??\n        }\n    }\n}\n</code></pre>\n<p>My understanding was to search a name, compiler starts from current scope and continuously search enclosing scope and then global scope until it finds correct (correct means <em>signature match or convertible</em> in case of method) one, or gives error if none is present. So at first I tried without <code>using namespace A</code> in <code>B</code>. Then the first two call invoked <code>B::f</code> as expected, but <code>f(s)</code> was giving error. I thought names in enclosing scope are by default visible to inner scope, but clearly I was wrong. Then I place <code>using namespace A</code> and thought <code>f(10.5)</code> will call <code>A::f</code> for better type matching, and the problem with <code>f(s)</code> will be solved, but this is not the case (my understanding was <code>using</code> keyword bring everything to current scope from the scope which is being used). Can someone help me to understand how name lookup is applied here, thanks in advance.</p>\n<p><strong>Note</strong>\nI know how to make it work. I wanted to know why this is so? what C++ standard says about this in easy to understand language. Why my understanding is wrong?</p>\n", "Tags": "<c++><namespaces><overload-resolution><name-lookup>", "OwnerUserId": "1390091", "AnswerCount": "4"}, "23583080": {"ParentId": "23582526", "CommentCount": "1", "Body": "<p>That to understand the compiler behaviour it is important to reference to the following quote from the C++ Standard</p>\n<blockquote>\n<p id=\"so_23582526_23583080_0\">2 A using-directive specifies that the names in the nominated\n  namespace can be used in the scope in which the using-directive\n  appears after the using-directive. During unqualified name lookup\n  (3.4.1), the names appear as if they were declared in the nearest\n  enclosing namespace which contains both the using-directive and the\n  nominated namespace. [ Note: In this context, \u201ccontains\u201d means\n  \u201ccontains directly or indirectly\u201d. \u2014end note ]</p>\n</blockquote>\n<p>In your example \"the nearest enclosing namespace which contains both the using-directive and the\nnominated namespace.\" is namespace A. That is functions</p>\n<pre><code>void f(double x){cout&lt;&lt;\"A::f(double)\\n\";}\n\nvoid f(string s){cout&lt;&lt;\"A::f(string)\\n\";}\n</code></pre>\n<p>are not members of namespace B for the purpose of the unqualified lookup.</p>\n<p>Accotding to other quote from the C++ Standard</p>\n<blockquote>\n<p id=\"so_23582526_23583080_1\">1 A name can be hidden by an explicit declaration of that same name in\n  a nested declarative region or derived class (10.2).</p>\n</blockquote>\n<p>these function declarations are hidden by the explicit declaration of f in namespace B. So the compiler found name f in namespace B and it stopped the further search of the name.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "23583080", "Score": "0", "CreationDate": "2014-05-10T15:44:56.360", "LastActivityDate": "2014-05-10T15:44:56.360"}, "23582623": {"ParentId": "23582526", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You are running into something called <strong>implicit conversion</strong>. Check out <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\" rel=\"nofollow\">this page</a>, or <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">another one</a>.</p>\n<p>As pointed out in other answer, only the current scope is explored by the compiler, and he tries to convert the given argument to the one expected, and fails if he can't.</p>\n", "OwnerUserId": "193789", "LastEditorUserId": "193789", "LastEditDate": "2014-05-10T15:12:17.490", "Id": "23582623", "Score": "0", "CreationDate": "2014-05-10T15:03:52.513", "LastActivityDate": "2014-05-10T15:12:17.490"}, "bq_ids": {"n4140": {"so_23582526_23582874_0": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}, "so_23582526_23583080_1": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}, "so_23582526_23583080_0": {"section_id": 5510, "quality": 0.8947368421052632, "length": 34}}, "n3337": {"so_23582526_23582874_0": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}, "so_23582526_23583080_1": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}, "so_23582526_23583080_0": {"section_id": 5296, "quality": 0.8947368421052632, "length": 34}}, "n4659": {"so_23582526_23582874_0": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}, "so_23582526_23583080_1": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}, "so_23582526_23583080_0": {"section_id": 6945, "quality": 0.8947368421052632, "length": 34}}}});