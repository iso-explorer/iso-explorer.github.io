post_cb({"17055835": {"CreationDate": "2013-06-12T00:16:15.833", "AcceptedAnswerId": "17056041", "Tags": "<c++><stl>", "AnswerCount": "3", "OwnerUserId": "233522", "Body": "<p>I have a templated class using a <code>std::vector</code> of it's template argument. The argument may not be default constructible. I want to <strong>reduce</strong> the size of the vector (cut it to a given size). Obviously</p>\n<pre><code>vec.resize( reduced_size );\n</code></pre>\n<p>...doesn't work as it requires a default constructor.</p>\n<p>I could of course:</p>\n<ol>\n<li>create the default constructor for any used type (which requires me to add it when it might not be a good design choice)</li>\n<li>pass a default value to the function (useless clutter of the interface)</li>\n<li>pass a construction method to the template (also useless clutter)</li>\n</ol>\n<p>While writing the question, I noticed that I can <code>erase</code> the elements from the vector up to the end:</p>\n<pre><code>vec.erase ( vec.begin() + position, vec.end() );\n</code></pre>\n<p>... however, I'm not sure if this will be as efficient as <code>resize</code>.</p>\n<p>Is there an efficient way to reduce a vector's size without a default constructor?</p>\n<p>C++11 solutions are acceptable.</p>\n<hr>\n<p><strong>EDIT:</strong> Seems that both MSVC and GCC implement shrinking resize as a erase call, so that answers my performance question. </p>\n</hr>", "CommentCount": "6", "PostTypeId": "1", "ViewCount": "585", "FavoriteCount": "1", "LastActivityDate": "2013-06-12T00:56:03.023", "Id": "17055835", "LastEditorUserId": "233522", "Title": "Reducing the size of a std::vector without a default constructor", "Score": "5", "LastEditDate": "2013-06-12T00:56:03.023"}, "17056041": {"LastActivityDate": "2013-06-12T00:43:32.910", "ParentId": "17055835", "Id": "17056041", "Score": "2", "Body": "<p>In my implementation, it looks like we have (with a few simplifications):</p>\n<pre><code>void std::vector&lt;T,A&gt;::resize(size_type __new_size)\n{\n    if (__new_size &gt; size())\n        _M_default_append(__new_size - size());\n    else if (__new_size &lt; size())\n        _M_erase_at_end(begin() + __new_size);\n}\n\nauto std::vector&lt;T,A&gt;::erase(iterator __first, iterator __last) -&gt; iterator\n{\n    if (__first != __last)\n    {\n        if (__last != end())\n            _GLIBCXX_MOVE3(__last, end(), __first);\n        _M_erase_at_end(__first + (end() - __last));\n    }\n    return __first;\n}\n</code></pre>\n<p>where <code>_M_...</code> are private member functions.  You really want the effects of <code>_M_erase_at_end</code>.  I would guess it would be hard or impossible for a compiler to optimize the <code>_M_default_append</code> call out of <code>v.resize(sz)</code>, but relatively easy to notice in <code>v.erase(iter, v.end())</code> that <code>__last == end()</code> and optimize away the <code>_GLIBCXX_MOVE3</code> and the <code>+ (end() - __last)</code>.  So <code>erase()</code> could very well be more efficient than <code>resize()</code> here.</p>\n<p>I would expect most implementations to be a similar story: a few simple <code>if</code> tests, and then calling some identical method to call destructors for elements at the end.</p>\n", "CommentCount": "6", "PostTypeId": "2", "OwnerUserId": "459640", "CreationDate": "2013-06-12T00:43:32.910"}, "17055922": {"LastActivityDate": "2013-06-12T00:28:02.013", "ParentId": "17055835", "Id": "17055922", "Score": "1", "Body": "<p>Your idea to use <code>erase</code> is the right route.  To reduce the amount of confusion, I would write a container based algorithm:</p>\n<pre><code>template&lt;typename Container&gt;\nContainer&amp;&amp; reduce_size( Container&amp;&amp; c, std::size_t amount ) {\n  using std::begin; using std::end; // enable ADL\n  amount = std::min( amount, std::size_t(end(c)-begin(c)) ); // paranoid!\n  c.erase( end(c)-amount, end(c) );\n  return std::forward&lt;Container&gt;(c); // I like my container-algorithms to pass through\n}\n</code></pre>\n<p>which will be as fast as your <code>erase</code> implementation (well, one more branch and check).</p>\n<p>Use:</p>\n<pre><code>std::vector&lt; Foo &gt; blah;\nblah.emplace_back( 7 );\nreduce_size( blah, 10 );\n</code></pre>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "1774667", "CreationDate": "2013-06-12T00:28:02.013"}, "bq_ids": {"n3337": {"so_17055835_17055912_0": {"section_id": 801, "quality": 1.0, "length": 4}}}, "17055912": {"CreationDate": "2013-06-12T00:27:01.217", "LastActivityDate": "2013-06-12T00:37:35.783", "LastEditorUserId": "179910", "ParentId": "17055835", "Score": "1", "Id": "17055912", "OwnerUserId": "179910", "Body": "<p>Sure -- when you call <code>resize</code>, you can supply a second parameter passing a value of the correct type that would (theoretically) be used to fill in the empty spots if you use <code>resize</code> to increase the size of the vector. In C++03, that argument has a default value of <code>T()</code>, which is where the default ctor comes into things (in C++11, they use overloading instead, so you can call <code>resize()</code> to reduce size without any further difficulty).</p>\n<p>By passing a value of your own, you avoid the need for the default ctor. As noted above, in C++11, the default ctor won't be needed/used even if you don't pass the second argument.</p>\n<p>I doubt this will give any real improvement compared to using <code>erase</code> though. In particular, the specification in the standard is (\u00a723.3.6.3/9): </p>\n<blockquote>\n<p id=\"so_17055835_17055912_0\">If <code>sz &lt;= size()</code>, equivalent to <code>erase(begin() + sz, end());</code>.</p>\n</blockquote>\n<p>As such, there seems to be no real reason for any difference between <code>resize</code> and <code>erase</code> in this case.</p>\n", "CommentCount": "5", "PostTypeId": "2", "LastEditDate": "2013-06-12T00:37:35.783"}});