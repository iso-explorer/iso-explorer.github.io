post_cb({"13485192": {"CommentCount": "1", "AcceptedAnswerId": "13485406", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2012-11-21T01:50:27.117", "LastActivityDate": "2016-04-21T12:37:36.340", "LastEditDate": "2016-04-21T12:37:36.340", "ViewCount": "915", "FavoriteCount": "1", "Title": "#include file derived from macro __FILE__?", "Id": "13485192", "Score": "5", "Body": "<p>Observe the following program:  </p>\n<pre><code>#include __FILE__\nmain(){}\n</code></pre>\n<p>The preprocessor gets stuck in infinite recursion including a copy of itself inside itself and complaining about <code>main()</code> already being defined.  </p>\n<hr>\n<p>If I can use macros to include files, \ncan I derive a file name based on <code>__FILE__</code> and include it?</p>\n<hr>\n<p>For example, I'd like to include <code>\"foo.h\"</code> whilst inside <code>\"foo.cpp\"</code>, but derive it from <code>__FILE__</code>.</p>\n<ul>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Concatenation.html\" rel=\"nofollow\"><code>##</code></a> will concatenate macros.  </li>\n<li>It is also possible to <a href=\"http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification\" rel=\"nofollow\">Stringify</a> macros.  </li>\n</ul>\n<p>Can it be done with the preprocessor?  </p>\n</hr></hr>", "Tags": "<c++><macros><include><c-preprocessor>", "OwnerUserId": "908939", "AnswerCount": "2"}, "13485307": {"ParentId": "13485192", "CommentCount": "0", "Body": "<p>The best I've come up with is this:</p>\n<pre><code>#define foo(x) #x\n#include foo(x)\n</code></pre>\n<blockquote>\n<p id=\"so_13485192_13485307_0\">prog.cpp:2:16: error: x: No such file or directory</p>\n</blockquote>\n", "OwnerUserId": "1343", "PostTypeId": "2", "Id": "13485307", "Score": "0", "CreationDate": "2012-11-21T02:07:09.737", "LastActivityDate": "2012-11-21T02:07:09.737"}, "bq_ids": {"n4140": {"so_13485192_13485406_0": {"section_id": 506, "quality": 0.851063829787234, "length": 40}}, "n3337": {"so_13485192_13485406_0": {"section_id": 497, "quality": 0.851063829787234, "length": 40}}, "n4659": {"so_13485192_13485406_0": {"section_id": 527, "quality": 0.851063829787234, "length": 40}}}, "13485406": {"ParentId": "13485192", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The C standard specifies three forms of <code>#include</code>:</p>\n<pre><code>#include &lt;file&gt;\n#include \"file\"\n#include ANYTHING ELSE\n</code></pre>\n<p>In the former two cases, no macro expansion takes place, so there's no way to vary the behavior.  In the third case, C99 says (\u00a76.10.2p4):</p>\n<blockquote>\n<p id=\"so_13485192_13485406_0\">The preprocessing tokens after <code>#include</code> in the directive are [macro-expanded]. The directive resulting after all replacements shall match one of the two previous forms [footnote: Note that adjacent string literals are not concatenated into a single string literal].  The method by which a sequence of preprocessing tokens between a &lt; and a &gt; preprocessing token pair or a pair of \" characters is combined into a single header name preprocessing token is implementation-defined.</p>\n</blockquote>\n<p>Slightly different, but effectively equivalent, wording appears in C++98 \u00a716.2p4.</p>\n<p>Any sentence with \"shall\" in it imposes a hard requirement: in this case, the program is ill-formed if <code>ANYTHING ELSE</code> expands to anything but a sequence of tokens beginning with <code>&lt;</code> and ending with <code>&gt;</code>, or beginning and ending with <code>\"</code>.  The exact interpretation of that sequence of tokens is implementation defined, but note that the footnote specifically forbids string-literal concatenation.</p>\n<p>So, as the expansion of <code>__FILE__</code> is a string constant, the only ways to use it in an <code>#include</code> are</p>\n<pre><code>#include __FILE__\n</code></pre>\n<p>which, as you discovered, leads to infinite recursion, and</p>\n<pre><code>#define LT &lt;\n#define GT &gt;\n#include LT __FILE__ etc GT\n</code></pre>\n<p>which has amusing, but useless, effects on all the compilers I can conveniently test.  Assuming that the above is in a file named <code>test.c</code>:</p>\n<ul>\n<li>GCC attempts to open a file named <code>\"test.c\" etc</code>, with the quotation marks and space included verbatim.</li>\n<li>clang is even more literal, and looks for that same filename but with leading and trailing spaces.</li>\n<li>MSVC macro-expands <em>only</em> the <code>LT</code> (it is my considered opinion that this is a conformance violation), complains that there is no matching <code>&gt;</code>, and then attempts to open a file named <code>__FILE__ etc GT</code>.</li>\n</ul>\n<p>(<a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.7.2/cpp/Computed-Includes.html\" rel=\"nofollow\">GCC's behavior is documented here</a>; you are on your own for anything else.)</p>\n<p>tl;dr: There is no way to do what you want from inside the preprocessor.  I recommend working out the name of the file-to-be-included from your build system and notifying the compiler of it with a <code>-D</code> switch (on a Unixy system you will need double quotation, <code>-DINCLUDEME='\"includeme.h\"'</code>; I don't speak CMD)</p>\n", "OwnerUserId": "388520", "LastEditorUserId": "388520", "LastEditDate": "2016-02-12T19:34:14.223", "Id": "13485406", "Score": "5", "CreationDate": "2012-11-21T02:18:59.743", "LastActivityDate": "2016-02-12T19:34:14.223"}});