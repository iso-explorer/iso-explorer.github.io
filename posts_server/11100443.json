post_cb({"bq_ids": {"n4140": {"so_11100443_11100685_1": {"length": 7, "quality": 0.875, "section_id": 5923}, "so_11100443_11100497_0": {"length": 7, "quality": 0.875, "section_id": 5923}}, "n3337": {"so_11100443_11100685_1": {"length": 7, "quality": 0.875, "section_id": 5695}, "so_11100443_11100497_0": {"length": 7, "quality": 0.875, "section_id": 5695}}, "n4659": {"so_11100443_11100685_1": {"length": 7, "quality": 0.875, "section_id": 7397}, "so_11100443_11100497_0": {"length": 7, "quality": 0.875, "section_id": 7397}}}, "11100443": {"ViewCount": "653", "Body": "<p>My question is about pointing to chunks of memory of an odd size.</p>\n<p>Let's say I have a <code>struct</code> declared like so:</p>\n<pre><code>typedef struct{\n   int32 val1  : 29; \n   int32 val2  : 26;\n   char  val3;\n}MyStruct;\n</code></pre>\n<p>Let's assume declaring specific bit fields in the struct is desireable (why we'd use the bit fields is not the question).</p>\n<p>If I wanted to declare a pointer that points to one of those fields, I might try something like this:</p>\n<pre><code>MyStruct test;\nint32 *myPtr = &amp;(test.val1);\n</code></pre>\n<p>Except that this produces the error \"<em>taking the address of a bit field is not allowed</em>\".</p>\n<p>Assuming that we would want to, is there a way to point to those fields in this way? I know that C++ will probably pad the fields to the next byte (which in this case would be 32 bits).</p>\n", "AcceptedAnswerId": "11100497", "Title": "C++ pointer of specific bit size", "CreationDate": "2012-06-19T11:59:17.160", "Id": "11100443", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-06-19T12:44:04.303", "Score": "5", "OwnerUserId": "1205577", "Tags": "<c++><pointers><struct><bit-fields>", "AnswerCount": "3"}, "11100685": {"Id": "11100685", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11100443_11100685_0\">Except that this produces the error \"taking the address of a bit field is not allowed\".</p>\n</blockquote>\n<p>This is explicitly disallowed by the standard. See <strong>[class.bit]</strong> 9.6/3:</p>\n<blockquote>\n<p id=\"so_11100443_11100685_1\">The address-of operator &amp; shall not be applied to a bit-field, so there are no pointers to bitfields.</p>\n</blockquote>\n<p>A byte (which is <code>CHAR_BIT</code> bits wide, where <code>CHAR_BIT</code> is at least 8) is the minimum you can address. </p>\n<blockquote>\n<p id=\"so_11100443_11100685_2\">Assuming that we would want to, is there a way to point to those fields in this way?</p>\n</blockquote>\n<p>No. You can have a pointer to an object of the enclosing <code>struct</code> type though. This is a direct carry over from C; See <a href=\"http://c-faq.com/struct/bitfields.html\">C FAQ 2.26</a>:</p>\n<blockquote>\n<p id=\"so_11100443_11100685_3\">Bit-fields are inconvenient when you also want to be able to manipulate some collection of bits as a whole (perhaps to copy a set of flags). </p>\n</blockquote>\n<p>You may want to look at other alternatives such <code>std::bitset</code> or <a href=\"http://www.boost.org/doc/libs/1_36_0/libs/dynamic_bitset/dynamic_bitset.html\"><code>boost::dynamic_bitset</code></a>.</p>\n", "LastActivityDate": "2012-06-19T12:14:54.220", "CommentCount": "0", "CreationDate": "2012-06-19T12:14:54.220", "ParentId": "11100443", "Score": "6", "OwnerUserId": "66692"}, "11101197": {"Id": "11101197", "PostTypeId": "2", "Body": "<p>There's no way to get a pointer to a bit field.  If you're willing to\nimplement an equivalent structure yourself, however, using shifts and\nmasks, you should be able to define a smart pointer into it.  Something \nlike:</p>\n<pre><code>class BitFieldPointer\n{\n    unsigned* myData;\n    unsigned  myMask;\n    unsigned  myShift;\n\n    class DereferenceProxy\n    {\n        BitFieldPointer const* myOwner;\n    public:\n        DereferenceProxy(BitFieldPointer const* owner) : myOwner( owner ) {} operator unsigned() const\n        {\n            return (*myOwner-&gt;myData &amp;&amp; myOwner-&gt;myMask) &gt;&gt; myOwner-&gt;myShift;\n        }\n\n        void operator=( unsigned new_value ) const\n        {\n            *myData = (*myOwner-&gt;myData &amp;&amp; ~myOwner-&gt;myMask) |\n                    ((new_value &lt;&lt; myOwner-&gt;myShift) &amp;&amp; myOwner-&gt;myMask);\n        }\n    };\npublic:\n    //  ...\n    DereferenceProxy operator*() const\n    {\n        return DereferenceProxy(this);\n    }\n};\n</code></pre>\n<p>(This is just a rough idea.  You'll probably want both a pointer and a\npointer to const, and the lifetime of the proxy vs. that of its owner\nmay be an issue.)</p>\n", "LastActivityDate": "2012-06-19T12:44:04.303", "CommentCount": "0", "CreationDate": "2012-06-19T12:44:04.303", "ParentId": "11100443", "Score": "0", "OwnerUserId": "649665"}, "11100497": {"Id": "11100497", "PostTypeId": "2", "Body": "<p>In C++, the smallest addressable value must have a size of at least 1 byte. So No you cannot take address of an bit field with pointers.</p>\n<p><strong>C++03 Standard 9.6 Bit-fields:</strong><br>\n<strong>Para 3:</strong></br></p>\n<blockquote>\n<p id=\"so_11100443_11100497_0\">...The address-of operator&amp; shall not be applied to a bit-field, so there are no pointers to bit-fields.\n  ....</p>\n</blockquote>\n", "LastEditorUserId": "452307", "LastActivityDate": "2012-06-19T12:10:34.643", "Score": "11", "CreationDate": "2012-06-19T12:02:34.663", "ParentId": "11100443", "CommentCount": "0", "OwnerUserId": "452307", "LastEditDate": "2012-06-19T12:10:34.643"}});