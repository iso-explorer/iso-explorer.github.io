post_cb({"bq_ids": {"n4140": {"so_11494403_11494486_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5876}, "so_11494403_11494486_1": {"length": 24, "quality": 0.7741935483870968, "section_id": 6046}}, "n3337": {"so_11494403_11494486_0": {"length": 22, "quality": 1.0, "section_id": 5647}, "so_11494403_11494486_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5814}}, "n4659": {"so_11494403_11494486_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 7361}, "so_11494403_11494486_1": {"length": 23, "quality": 0.7419354838709677, "section_id": 7545}}}, "11494403": {"ViewCount": "1137", "Body": "<p>From the discussion of this question <a href=\"https://stackoverflow.com/q/11486622/819272\">How is access for private variables implemented in C++ under the hood?</a> I posed a variation: instead of accessing a private data member, can one call private member functions through casting and relying on layout-compatibility?</p>\n<p>Some code (inspired by Herb Sutter's column <a href=\"http://www.gotw.ca/gotw/076.htm\" rel=\"nofollow noreferrer\">Uses and Abuses of Access Rights</a> )</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass X \n{ \npublic:\n  X() : private_(1) { /*...*/ }\n\nprivate: \n  int Value() { return private_; }\n  int private_; \n};\n\n// Nasty attempt to simulate the object layout\n// (cross your fingers and toes).\n//\nclass BaitAndSwitch\n    // hopefully has the same data layout as X\n{   // so we can pass him off as one\npublic:\n  int Value() { return private_; }\nprivate:\n  int private_;\n};\n\nint f( X&amp; x )\n{\n  // evil laughter here\n  return (reinterpret_cast&lt;BaitAndSwitch&amp;&gt;(x)).Value();\n}\n\nint main()\n{\n    X x;\n    std::cout &lt;&lt; f(x) &lt;&lt; \"\\n\"; // prints 0, not 1\n    return 0;\n}; \n</code></pre>\n<p>Note: this works (at least on Ideone)! Is there any way the new <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow noreferrer\">C++11 Standard</a> gives a <strong>guaranteed</strong> or at least an <strong>implementation-defined</strong> way to circumvent the access control by relying on layout-compatibility and reinterpret_cast / static_cast?</p>\n<p><strong>EDIT1</strong>: output on <a href=\"http://ideone.com/eQgi6\" rel=\"nofollow noreferrer\">Ideone</a></p>\n<p><strong>EDIT2</strong>: In Sutter's column he lists two reasons why the above code is not guaranteed to work (although it works in practice)</p>\n<blockquote>\n<p id=\"so_11494403_11494403_0\">a) The object layouts of X and BaitAndSwitch are not guaranteed to be\n  the same, although in practice they probably always will be.</p>\n<p id=\"so_11494403_11494403_1\">b) The results of the reinterpret_cast are undefined, although most\n  compilers will let you try to use the resulting reference in the way\n  the hacker intended.</p>\n</blockquote>\n<p>Does the new C++11 Standard now provide these layout / reinterpret_cast guarantees?</p>\n", "AcceptedAnswerId": "11494486", "Title": "Can one access private member functions through casting to layout-compatible types?", "CreationDate": "2012-07-15T18:14:38.160", "Id": "11494403", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:45:39.863", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-15T20:36:00.687", "Score": "6", "OwnerUserId": "819272", "Tags": "<c++><casting><c++11><access-control><private-methods>", "AnswerCount": "1"}, "11494486": {"Id": "11494486", "PostTypeId": "2", "Body": "<p>Yes, you could create a type that uses the same layout as the type you're trying to pilfer from, then <code>reinterpret_cast</code> from that type to your layout compatible type. But this is only protected by the standard if <strong><em>both</em></strong> the source and destination types are standard layout types (and of course, it only actually works if their layouts are the same). So if the source has virtual functions, you're screwed.</p>\n<p>This seems to satisfy both of Sutter's issues here. The rules of standard layout ensure that two types that are both standard layout that define the same members in the same order are layout-compatible (section 9.2, paragraph 17):</p>\n<blockquote>\n<p id=\"so_11494403_11494486_0\">Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).</p>\n</blockquote>\n<p>And the rules for <code>reinterpret_cast</code> specify the meaning of the conversion between two standard layout types (section 5.2.10, paragraph 7):</p>\n<blockquote>\n<p id=\"so_11494403_11494486_1\">An object pointer can be explicitly converted to an object pointer of a different type.\n  When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both T1 and T2 are standard-layout types (3.9) and the alignment requirements of T2 are no stricter than those of T1, or if either type is void.</p>\n</blockquote>\n", "LastEditorUserId": "734069", "LastActivityDate": "2012-07-15T20:36:00.687", "Score": "3", "CreationDate": "2012-07-15T18:26:30.737", "ParentId": "11494403", "CommentCount": "3", "OwnerUserId": "734069", "LastEditDate": "2012-07-15T20:36:00.687"}});