post_cb({"44950083": {"CommentCount": "4", "ViewCount": "57", "CreationDate": "2017-07-06T13:17:27.733", "LastActivityDate": "2017-07-06T19:19:15.180", "Title": "Default ctor not generated when there's a template copy ctor", "PostTypeId": "1", "Id": "44950083", "Score": "1", "Body": "<pre><code>template&lt;class T&gt;\nclass MyClass {\n public:\n  //MyClass() = default;\n\n template&lt;class X&gt;\n MyClass(MyClass&lt;X&gt;&amp; other)\n {\n  val = other.getVal();\n }\n\n T getVal()\n {\n  return val;\n }\n\n private:\n  T val;\n};\n\nmain()\n{\n MyClass&lt;double&gt; xd;       //this one causing the problem\n MyClass&lt;double&gt; xd1(xd);  //this one is fine\n\n MyClass&lt;int&gt; xi(xd);\n}\n</code></pre>\n<p>This code will not compile.\nBut if you uncomment MyClass() = default, then everything is fine.\nAs far as I remember the <strong>template ctor not preventing compiler from generating the default ctor and copy ctor as well</strong>. \nAnd indeed the compiler complaining only when trying to create object through the default ctor, but not for copy construction (which in this case is compiler generated)\nThe code was compiled with g++ 5.4.0 and 7.1.0. Same behavior with both</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "4491746", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44950083_44950815_1": {"section_id": 369, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_44950083_44950815_1": {"section_id": 359, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_44950083_44950815_1": {"section_id": 381, "quality": 0.8333333333333334, "length": 15}}}, "44950815": {"ParentId": "44950083", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is not a copy constructor:</p>\n<pre><code>template&lt;class X&gt;\nMyClass(MyClass&lt;X&gt;&amp; other) {\n    val = other.getVal();\n}\n</code></pre>\n<p>This is a constructor taking a mutable lvalue reference to many different type than this class.</p>\n<p>This is a copy constructor:</p>\n<pre><code>MyClass(const MyClass&amp;) {\n    // ...\n}\n</code></pre>\n<p>You can test if a function bus a special function by trying to put <code>= default</code> after it's signature. If the compiler complains about your misuse of defaulted functions, you function is not a special one.</p>\n<p>When any other constructor than special constructors is added, the default constructor is not generated. That function being a template makes no different effect than a non template one. In that case, <code>MyClass() = default</code> is indeed required.</p>\n<p>From cppreference:</p>\n<blockquote>\n<p id=\"so_44950083_44950815_0\">If no user-declared constructors of any kind are provided for a class type (struct, class, or union), the compiler will always declare a default constructor as an inline public member of its class.</p>\n</blockquote>\n<p>On the contrary, if a user provided constructor is declared, no implicitly defined default constructor is defined.</p>\n<p>And from <code>[class.ctor]\u00a75</code>:</p>\n<blockquote>\n<p id=\"so_44950083_44950815_1\">A default constructor for a class X is a constructor of class X that can be called without an argument. If there is no user-declared constructor for class X, a constructor having no parameters is implicitly declared as defaulted (8.4).</p>\n</blockquote>\n<p>Since your class has a user provided constructor, no implicitly declared/defined constructor is generated. Again, you can always force it's generation with <code>= default</code>.</p>\n", "OwnerUserId": "2104697", "LastEditorUserId": "2104697", "LastEditDate": "2017-07-06T19:19:15.180", "Id": "44950815", "Score": "7", "CreationDate": "2017-07-06T13:47:46.227", "LastActivityDate": "2017-07-06T19:19:15.180"}});