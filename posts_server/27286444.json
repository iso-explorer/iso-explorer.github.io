post_cb({"bq_ids": {"n4140": {"so_27286444_27286579_0": {"length": 61, "quality": 0.953125, "section_id": 3919}, "so_27286444_27286579_1": {"length": 30, "quality": 0.9375, "section_id": 3919}}, "n3337": {"so_27286444_27286579_0": {"length": 61, "quality": 0.953125, "section_id": 3779}, "so_27286444_27286579_1": {"length": 30, "quality": 0.9375, "section_id": 3779}}, "n4659": {"so_27286444_27286579_0": {"length": 49, "quality": 0.765625, "section_id": 4805}, "so_27286444_27286579_1": {"length": 27, "quality": 0.84375, "section_id": 4805}}}, "27286444": {"ViewCount": "374", "Body": "<p>Is this singleton thread safe for the pre-C++11 compilers ?\nAs we know for C++11 it is thread safe.</p>\n<pre><code>class Singleton\n{\nprivate:\n   Singleton(){};\n\npublic:\n   static Singleton&amp; instance()\n   {\n      static Singleton INSTANCE;\n      return INSTANCE;\n   }\n};\n</code></pre>\n", "AcceptedAnswerId": "27286579", "Title": "Is returning local static object thread safe for pre-c++11 compilers", "CreationDate": "2014-12-04T04:43:09.787", "Id": "27286444", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-12-04T04:57:10.207", "LastEditorUserId": "1716427", "LastActivityDate": "2014-12-04T21:42:22.697", "Score": "4", "OwnerUserId": "1716427", "Tags": "<c++><multithreading><c++11><singleton>", "AnswerCount": "1"}, "27286579": {"Id": "27286579", "PostTypeId": "2", "Body": "<p>In C++11 what makes this thread safe is the following from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>6.7</code> <em>Declaration statement</em> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_27286444_27286579_0\">The zero-initialization (8.5) of all block-scope variables with static\n  storage duration (3.7.1) or thread storage duration (3.7.2) is\n  performed before any other initialization takes place. [...] Otherwise\n  such a variable is initialized the first time control passes through\n  its declaration; such a variable is considered initialized upon the\n  completion of its initialization. If the initialization exits by\n  throwing an exception, the initialization is not complete, so it will\n  be tried again the next time control enters the declaration. <strong>If\n  control enters the declaration concurrently while the variable is\n  being initialized, the concurrent execution shall wait for completion\n  of the initialization.</strong> [...]</p>\n</blockquote>\n<p>while pre C++11 section <code>6.7</code> says:</p>\n<blockquote>\n<p id=\"so_27286444_27286579_1\">[...]Otherwise such an object is initialized the first time control passes\n  through its declaration; such an object is considered initialized upon\n  the completion of its initialization. If the initialization exits by\n  throwing an exception, the initialization is not complete, so it will\n  be tried again the next time control enters the declaration.[...]</p>\n</blockquote>\n<p>which does not have the same guarantee that C++11 has and so it would seem pre C++11 it is not specified and therefore you can not count on it. Although this does not prevent implementations from making stronger guarantees. </p>\n<p>This make sense since pre C++11 the memory model did not including threading.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-12-04T21:42:22.697", "Score": "7", "CreationDate": "2014-12-04T04:57:06.360", "ParentId": "27286444", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2014-12-04T21:42:22.697"}});