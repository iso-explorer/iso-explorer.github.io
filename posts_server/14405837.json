post_cb({"14406177": {"Id": "14406177", "PostTypeId": "2", "Body": "<p>Both of those are fine.</p>\n<p>\u00a75.16 says (extraordinarily abridged):</p>\n<blockquote>\n<p id=\"so_14405837_14406177_0\">2 If either the second or the third operand has type void</p>\n</blockquote>\n<p>Nope.</p>\n<blockquote>\n<p id=\"so_14405837_14406177_1\">3 Otherwise, if the second and third operand have di\ufb00erent types </p>\n</blockquote>\n<p>Nope.</p>\n<blockquote>\n<p id=\"so_14405837_14406177_2\">4 If the second and third operands are glvalues of the same value category </p>\n</blockquote>\n<p>Nope. (In the first, both are prvalues and in the second one is a glvalue  and one is a prvalue.)</p>\n<blockquote>\n<p id=\"so_14405837_14406177_3\">5 Otherwise, the result is a prvalue</p>\n</blockquote>\n<p>Okay, so both of these result in prvalues. So the binding is fine, but what's the binding to?</p>\n<blockquote>\n<p id=\"so_14405837_14406177_4\">6  Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are per- formed on the second and third operands.</p>\n</blockquote>\n<p>Okay, so both are now rvalues if they weren't already.</p>\n<blockquote>\n<p id=\"so_14405837_14406177_5\">6 (continued)  After those conversions, one of the following shall hold:  </p>\n<p id=\"so_14405837_14406177_6\">The second and third operands have the same type; the result is of that type. If the operands have class type, the result is a prvalue temporary of the result type, which is copy-initialized from either the second operand or the third operand depending on the value of the \ufb01rst operand.</p>\n</blockquote>\n<p>Okay, so it's either <code>std::string(first_operand)</code> or <code>std::string(second_operand)</code>.</p>\n<p>Regardless, the result of the conditional expression is a new prvalue temporary, and it's that value that's extended by binding to your references.</p>\n", "LastActivityDate": "2013-01-18T19:26:46.440", "CommentCount": "11", "CreationDate": "2013-01-18T19:26:46.440", "ParentId": "14405837", "Score": "5", "OwnerUserId": "87234"}, "bq_ids": {"n4140": {"so_14405837_14406177_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6169}, "so_14405837_14406177_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 6172}, "so_14405837_14406177_0": {"length": 6, "quality": 1.0, "section_id": 6168}, "so_14405837_14406177_6": {"length": 26, "quality": 0.9285714285714286, "section_id": 6172}, "so_14405837_14406177_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 6172}, "so_14405837_14406177_2": {"length": 7, "quality": 1.0, "section_id": 6170}}, "n3337": {"so_14405837_14406177_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 5933}, "so_14405837_14406177_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 5933}, "so_14405837_14406177_0": {"length": 6, "quality": 1.0, "section_id": 5929}, "so_14405837_14406177_6": {"length": 26, "quality": 0.9285714285714286, "section_id": 5933}, "so_14405837_14406177_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5930}, "so_14405837_14406177_2": {"length": 7, "quality": 1.0, "section_id": 5931}}, "n4659": {"so_14405837_14406177_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7667}, "so_14405837_14406177_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 7670}, "so_14405837_14406177_0": {"length": 6, "quality": 1.0, "section_id": 7665}, "so_14405837_14406177_6": {"length": 15, "quality": 0.5357142857142857, "section_id": 7667}, "so_14405837_14406177_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 7667}, "so_14405837_14406177_2": {"length": 7, "quality": 1.0, "section_id": 7668}}}, "14405837": {"ViewCount": "406", "Body": "<p>local lvalue references-to-const and rvalue references can extend the lifetime of temporaries:</p>\n<pre><code>const std::string&amp; a = std::string(\"hello\");\nstd::string&amp;&amp; b = std::string(\"world\");\n</code></pre>\n<p>Does that also work when the initializer is not a simple expression, but uses the conditional operator?</p>\n<pre><code>std::string&amp;&amp; c = condition ? std::string(\"hello\") : std::string(\"world\");\n</code></pre>\n<p>What if one of the results is a temporary object, but the other one isn't?</p>\n<pre><code>std::string d = \"hello\";\nconst std::string&amp; e = condition ? d : std::string(\"world\");\n</code></pre>\n<p>Does C++ mandate the lifetime of the temporary be extended when the condition is false?</p>\n<p>The question came up while answering <a href=\"https://stackoverflow.com/q/14404904/252000\">this question</a> about non-copyable objects.</p>\n", "AcceptedAnswerId": "14406177", "Title": "Lifetime extension and the conditional operator", "CreationDate": "2013-01-18T19:06:00.800", "Id": "14405837", "CommentCount": "17", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:56:45.060", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-18T19:26:46.440", "Score": "19", "OwnerUserId": "252000", "Tags": "<c++><c++11><rvalue-reference><object-lifetime><temporary-objects>", "AnswerCount": "2"}, "14406020": {"Id": "14406020", "PostTypeId": "2", "Body": "<pre><code>std::string d = \"hello\";\nconst std::string&amp; e = condition ? d : std::string(\"world\");\n</code></pre>\n<blockquote>\n<p id=\"so_14405837_14406020_0\">Does C++ mandate the lifetime of the temporary be extended when the condition is false?</p>\n</blockquote>\n<p>It will be. The conditional is an rvalue expression, and when bound with a <code>const</code> reference the compiler will create an unnamed object and bind the reference to it. What I am not 100% sure is whether the temporary whose lifetime is extended is <code>std::string(\"world\")</code> or whether a copy of it is (conceptually) made (and elided).</p>\n", "LastActivityDate": "2013-01-18T19:16:41.757", "CommentCount": "12", "CreationDate": "2013-01-18T19:16:41.757", "ParentId": "14405837", "Score": "3", "OwnerUserId": "36565"}});