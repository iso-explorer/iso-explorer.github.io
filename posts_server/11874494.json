post_cb({"11874560": {"ParentId": "11874494", "CommentCount": "0", "Body": "<p>Inclusion guards are local to a translation unit. This means that when you do <code>#define VAR</code> in one <code>.cpp</code> file, it is not defined in any other files. </p>\n", "OwnerUserId": "1440565", "PostTypeId": "2", "Id": "11874560", "Score": "-1", "CreationDate": "2012-08-08T23:12:51.143", "LastActivityDate": "2012-08-08T23:12:51.143"}, "11874580": {"ParentId": "11874494", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Your code is formally incorrect in both C and C++ due to multiple definitions of variable <code>var</code>. It is just that this type of error was traditionally overlooked by C compilers as a popular non-standard extension. This extension is even mentioned in C language specification</p>\n<blockquote>\n<p id=\"so_11874494_11874580_0\"><strong>J.5 Common extensions</strong></p>\n<p id=\"so_11874494_11874580_1\">The following extensions are widely used in many systems, but are not portable to all\n  implementations. [...]</p>\n<p id=\"so_11874494_11874580_2\"><strong>J.5.11 Multiple external definitions</strong></p>\n<p id=\"so_11874494_11874580_3\">There may be more than one external definition for the identifier of an object, with or\n  without the explicit use of the keyword extern; if the definitions disagree, or more than\n  one is initialized, the behavior is undefined (6.9.2).</p>\n</blockquote>\n<p>But formally, you have absolutely the same multiple-definition error in both C and C++ languages. Ask your C compiler to behave more pedantically (disable extensions, if it has an option for that) and your C compiler shall also generate the very same error as your C++ compiler.</p>\n<p>Again, you code contains multiple definitions of variable <code>var</code>, which is an error in both C and C++. Your <code>#ifdef</code> directives do not solve anything at all. Preperocessor directives cannot help you here. Preprocessor works locally and independently in each translation unit. It can't see across translation units.</p>\n<p>If you want to create a <em>global</em> variable (i.e. the same variable shared by all translation units), you need to make <em>one and only one definition</em> of that variable</p>\n<pre><code>int var;\n</code></pre>\n<p>in one and only one translation unit. All other translation units should receive non-defining declarations of <code>var</code></p>\n<pre><code>extern int var;\n</code></pre>\n<p>The latter is typically placed in a header file.</p>\n<p>If you need an individual, independent variable <code>var</code> in each translation unit, simply define it in each translation unit as</p>\n<pre><code>static int var;\n</code></pre>\n<p>(although in C++ this usage of <code>static</code> is now deprecated and superseded by nameless namespaces).</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-08-08T23:37:19.463", "Id": "11874580", "Score": "12", "CreationDate": "2012-08-08T23:15:06.860", "LastActivityDate": "2012-08-08T23:37:19.463"}, "11874545": {"ParentId": "11874494", "CommentCount": "1", "Body": "<p>The visibility of global variables in compilation modules is subtly different between C and C++.</p>\n<p>If these are intended to be different variables, enclose them in an anonymous namespace in each file.</p>\n<pre><code>namespace {\n int var;\n}\n</code></pre>\n<p>If they are intended to be the SAME variable, one of them needs an <code>extern</code> decl-specifier, to avoid multiple definitions.</p>\n<pre><code>extern int var;\n</code></pre>\n<p>Your <code>#define VAR</code> isn't doing anything in the example you've posted. The definition is not carried across compilation modules.</p>\n", "OwnerUserId": "279130", "PostTypeId": "2", "Id": "11874545", "Score": "-1", "CreationDate": "2012-08-08T23:10:43.670", "LastActivityDate": "2012-08-08T23:10:43.670"}, "11874494": {"CommentCount": "6", "ViewCount": "260", "CreationDate": "2012-08-08T23:05:01.150", "LastActivityDate": "2012-08-08T23:37:19.463", "Title": "Complicated when compiling in c++ but not in c (gcc)", "AcceptedAnswerId": "11874580", "PostTypeId": "1", "Id": "11874494", "Score": "6", "Body": "<p>I have problem with multiply declaration in c++, but not in c.\nYou could see code for more information.</p>\n<p>file main.c</p>\n<pre><code>#ifndef VAR\n#define VAR\nint var;\n#endif\nint main(){}\n</code></pre>\n<p>file other.c</p>\n<pre><code>#ifndef VAR\n#define VAR\nint var;\n#endif\n</code></pre>\n<p>Compile with gcc</p>\n<pre><code>gcc main.c other.c\n&gt;&gt; success\n</code></pre>\n<p>Compile with g++</p>\n<pre><code>g++ main.c other.c\nOutput:\n/tmp/ccbd0ACf.o:(.bss+0x0): multiple definition of `var'\n/tmp/cc8dweC0.o:(.bss+0x0): first defined here\ncollect2: ld returned 1 exit status\n</code></pre>\n<hr>\n<p>My gcc and g++ version:</p>\n<pre><code>gcc --version\ngcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\ng++ --version\ng++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n</hr>", "Tags": "<c++><c><gcc><compiler-errors><g++>", "OwnerUserId": "1398479", "AnswerCount": "4"}, "11874551": {"ParentId": "11874494", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The two <code>#define</code> directives have nothing to do with one another, as they are in different translation units (i.e., source files). The compiler processes the two source files in total isolation, so <code>defined(VAR)</code> is always false, and the contents of the <code>#ifndef</code> are always included.</p>\n<p>If you mean to have one variable shared between multiple source files, there is a simple way to go about it: <em>define</em> it in one source file, and <em>declare</em> it in the other:</p>\n<pre><code>// other.cpp\nint var;        // Definition.\n\n// main.cpp\nextern int var; // Declaration.\n</code></pre>\n<p>When linking, these will refer to the same <code>var</code>. Better yet, declare the variable in a header:</p>\n<pre><code>// other.h\nextern int var;\n</code></pre>\n<p>Then files that need <code>var</code> can simply include the header:</p>\n<pre><code>// main.cpp\n#include \"other.h\"\n</code></pre>\n<p>The difference you observe between C and C++ has to do with the treatment of globally declared identifiers in C versus C++. In C, any number of <em>tentative definitions</em> (having no storage class specifier and no initializer) may be merged together by the linker into a single symbol\u2014so long as all actual definitions for that symbol ultimately have the same linkage and storage class. This is done using <em>weak</em> linker symbols.</p>\n<p>C++, however, has no notion of a tentative definition, and treats an external declaration without storage class specifier as a definition. Thus G++ generates <em>strong</em> linker symbols, resulting in a conflict at link-time.</p>\n", "OwnerUserId": "246886", "LastEditorUserId": "246886", "LastEditDate": "2012-08-08T23:21:30.467", "Id": "11874551", "Score": "0", "CreationDate": "2012-08-08T23:11:31.440", "LastActivityDate": "2012-08-08T23:21:30.467"}, "bq_ids": {"n4140": {"so_11874494_11874580_3": {"section_id": 7043, "quality": 0.5454545454545454, "length": 12}}, "n3337": {"so_11874494_11874580_3": {"section_id": 6788, "quality": 0.5454545454545454, "length": 12}}, "n4659": {"so_11874494_11874580_3": {"section_id": 8540, "quality": 0.5454545454545454, "length": 12}}}});