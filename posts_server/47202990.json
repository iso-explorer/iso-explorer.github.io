post_cb({"47202990": {"CommentCount": "4", "ViewCount": "75", "CreationDate": "2017-11-09T13:23:14.813", "LastActivityDate": "2017-11-10T09:36:43.323", "Title": "How does std::future affects the lifetime of an associated std::packaged_task?", "AcceptedAnswerId": "47219655", "PostTypeId": "1", "Id": "47202990", "Score": "3", "Body": "<p>I have an <code>std::packaged_task</code> containing a lambda that captures a variable by copy. When this <code>std::packaged_task</code> is deleted, I would expect the variable living inside the lambda to be destructed, but I noticed that if I get the associated <code>std::future</code> for this <code>std::packaged_task</code>, the <code>future</code> object extends the lifetime of the variable inside the lambda.</p>\n<p>For example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;future&gt;\n\nclass Dummy\n{\npublic:\n    Dummy() {std::cout &lt;&lt; this &lt;&lt; \": default constructed;\" &lt;&lt; std::endl;}\n    Dummy(const Dummy&amp;) {std::cout &lt;&lt; this &lt;&lt; \": copy constructed;\" &lt;&lt; std::endl;}\n    Dummy(Dummy&amp;&amp;) {std::cout &lt;&lt; this &lt;&lt; \": move constructed;\" &lt;&lt; std::endl;}\n    ~Dummy() {std::cout &lt;&lt; this &lt;&lt; \": destructed;\" &lt;&lt; std::endl;}\n};\n\nint main()\n{\n    std::packaged_task&lt;void()&gt;* p_task;\n    {\n        Dummy ScopedDummy;\n        p_task = new std::packaged_task&lt;void()&gt;([ScopedDummy](){std::cout &lt;&lt; \"lambda call with: \" &lt;&lt; &amp;ScopedDummy &lt;&lt; std::endl;});\n        std::cout &lt;&lt; \"p_task completed\" &lt;&lt; std::endl;\n    }\n    {\n        std::future&lt;void&gt; future_result;\n        {\n            future_result = p_task-&gt;get_future();\n            (*p_task)();\n            delete p_task;\n        }\n        std::cout &lt;&lt; \"after p_task has been deleted, the scope of future_result determines the scope of the dummy inside p_task\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; \"p_task cleans up when future_result dies\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>A possible output is:</p>\n<pre><code>0x7fff9cf873fe: default constructed;\n0x7fff9cf873ff: copy constructed;\n0x1904b38: move constructed;\n0x7fff9cf873ff: destructed;\n0x7fff9cf873fe: destructed;\nlambda call with: 0x1904b38\nafter p_task has been deleted, the scope of future_result determines the scope of the dummy inside p_task\n0x1904b38: destructed;\np_task cleans up when future_result dies\n</code></pre>\n<p>So the object inside the lambda has its lifetime extended by the scope of <code>future_result</code>.</p>\n<p>If we comment out the line <code>future_result = p_task-&gt;get_future();</code>, a possible output is:</p>\n<pre><code>0x7fff57087896: default constructed;\n0x7fff57087897: copy constructed;\n0x197cb38: move constructed;\n0x7fff57087897: destructed;\n0x7fff57087896: destructed;\nlambda call with: 0x197cb38\n0x197cb38: destructed;\nafter p_task has been deleted, the scope of future_result determines the scope of the dummy inside p_task\np_task cleans up when future_result dies\n</code></pre>\n<p>I have been wondering what mechanism comes into play here, does <code>std::future</code> contains some link that keeps associated objects alive?</p>\n", "Tags": "<c++><c++11><lambda><object-lifetime><std-future>", "OwnerUserId": "8908713", "AnswerCount": "1"}, "47219655": {"ParentId": "47202990", "CommentCount": "0", "Body": "<p>looking at <a href=\"https://gcc.gnu.org/onlinedocs/gcc-7.2.0/libstdc++/api/a00074_source.html#l01476\" rel=\"nofollow noreferrer\">gcc7.2.0 packaged_task sources</a>, we read:</p>\n<pre><code>packaged_task(allocator_arg_t, const _Alloc &amp;__a, _Fn &amp;&amp;__fn)\n    : _M_state(__create_task_state&lt;_Res(_ArgTypes...)&gt;(std::forward&lt;_Fn&gt;(__fn), __a)){}\n\n~packaged_task()\n{\n  if (static_cast&lt;bool&gt;(_M_state) &amp;&amp; !_M_state.unique())\n    _M_state-&gt;_M_break_promise(std::move(_M_state-&gt;_M_result));\n}\n</code></pre>\n<p>where <code>_M_state</code> is a shared_ptr to the internal packaged_task shared state. So, it turns out that <em>gcc</em> stores the callable as part of the packaged_task <em>shared state</em>, hence binding the callable lifetime to whom among packaged_task,future,shared_future dies last.</p>\n<p>in comparison, <em>clang</em> does not, destroying the callable when the packaged task gets destroyed ( in fact, my copy of clang will store the callable as a proper member ).</p>\n<p>Who's right ? the standard is not very clear about the stored task lifetime; from one side, we have</p>\n<blockquote>\n<p id=\"so_47202990_47219655_0\"><strong>[[futures.task]]</strong></p>\n<p id=\"so_47202990_47219655_1\">packaged_task defines a type for <strong>wrapping a function or callable object</strong> so that the return value of the function or callable object is stored in a future when it is invoked.</p>\n<p id=\"so_47202990_47219655_2\">packaged_task(F&amp;&amp; f)[...]Constructs a new packaged_task object with a shared state and initializes the <strong>object\u2019s stored task</strong> with std::forward(f).</p>\n<p id=\"so_47202990_47219655_3\">packaged_task(packaged_task&amp;&amp; rhs)[...]<strong>Moves the stored task</strong> from rhs to *this.</p>\n<p id=\"so_47202990_47219655_4\">reset()[...]Effects: As if *this = packaged_task(std::move(f)), where f is the task <strong>stored in *this</strong>.</p>\n</blockquote>\n<p>that suggests the callable is owned by the packaged_task, but we also have</p>\n<blockquote>\n<p id=\"so_47202990_47219655_5\"><strong>[[futures.state]]</strong></p>\n<p id=\"so_47202990_47219655_6\">-Many of the classes introduced in this subclause use some state to communicate results. <strong>This shared state consists of some state information and some (possibly not yet evaluated) result</strong>, which can be a (possibly void) value or an exception. [ Note: Futures, promises, and tasks defined in this clause reference such shared state. \u2014endnote]</p>\n<p id=\"so_47202990_47219655_7\">-[ Note: The result can be any kind of object <strong>including a function to compute that result</strong>, as by async [...]]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_47202990_47219655_8\"><strong>[futures.task.members]</strong></p>\n<p id=\"so_47202990_47219655_9\">-packaged_task(F&amp;&amp; f);[...]Invoking a copy of f shall behave the same as invoking f[...]\n  -~packaged_task(); Effects: Abandons any shared state</p>\n</blockquote>\n<p>suggesting that a callable can be stored in the shared state and that one should not rely on any callable per-instance behaviour ( <strong>this may be interpreted to include the callable end of lifetime side-effects</strong>; by the way, this also implies that your callable is not strictly valid, because it behaves differently from its copy ); moreover, nothing is mentioned about the stored task in the dtor.</p>\n<p>All in all, I think clang follows the wording more consistently, although nothing seems <em>explicitly</em> forbidding gcc behavior. That said, I agree this should be better documented because it may result in surprising bugs otherwise ...</p>\n", "OwnerUserId": "8631381", "PostTypeId": "2", "Id": "47219655", "Score": "4", "CreationDate": "2017-11-10T09:36:43.323", "LastActivityDate": "2017-11-10T09:36:43.323"}, "bq_ids": {"n4140": {"so_47202990_47219655_2": {"section_id": 3172, "quality": 0.75, "length": 9}, "so_47202990_47219655_7": {"section_id": 3068, "quality": 0.8181818181818182, "length": 9}, "so_47202990_47219655_1": {"section_id": 3167, "quality": 1.0, "length": 16}, "so_47202990_47219655_6": {"section_id": 3067, "quality": 0.8918918918918919, "length": 33}, "so_47202990_47219655_4": {"section_id": 3190, "quality": 0.8, "length": 4}}, "n3337": {"so_47202990_47219655_2": {"section_id": 3045, "quality": 0.75, "length": 9}, "so_47202990_47219655_7": {"section_id": 2945, "quality": 0.8181818181818182, "length": 9}, "so_47202990_47219655_1": {"section_id": 3041, "quality": 1.0, "length": 16}, "so_47202990_47219655_6": {"section_id": 2944, "quality": 0.8918918918918919, "length": 33}, "so_47202990_47219655_4": {"section_id": 3064, "quality": 0.8, "length": 4}}, "n4659": {"so_47202990_47219655_2": {"section_id": 3934, "quality": 0.75, "length": 9}, "so_47202990_47219655_7": {"section_id": 3828, "quality": 0.8181818181818182, "length": 9}, "so_47202990_47219655_1": {"section_id": 3929, "quality": 1.0, "length": 16}, "so_47202990_47219655_6": {"section_id": 3827, "quality": 0.8918918918918919, "length": 33}, "so_47202990_47219655_4": {"section_id": 3952, "quality": 0.8, "length": 4}}}});