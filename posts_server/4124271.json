post_cb({"4124299": {"Id": "4124299", "PostTypeId": "2", "Body": "<p>Probably the <a href=\"http://en.wikipedia.org/wiki/Assignment_operator_%28C%2B%2B%29\" rel=\"nofollow\">assignment operator</a>. The compiler normally generates a default one for you, but that feature is disabled since your class has non-trivial copy semantics.</p>\n", "LastActivityDate": "2010-11-08T13:36:07.863", "CommentCount": "0", "CreationDate": "2010-11-08T13:36:07.863", "ParentId": "4124271", "Score": "1", "OwnerUserId": "464709"}, "4124271": {"ViewCount": "3703", "Body": "<p>Consider the following:</p>\n<pre><code>class A {\npublic:\n    const int c; // must not be modified!\n\n    A(int _c)\n    :   c(_c)\n    {\n        // Nothing here\n    }\n\n    A(const A&amp; copy)\n    : c(copy.c)\n    {\n        // Nothing here\n    }    \n};\n\n\n\nint main(int argc, char *argv[])\n{\n    A foo(1337);\n\n    vector&lt;A&gt; vec;\n    vec.push_back(foo); // &lt;-- compile error!\n\n    return 0;\n}\n</code></pre>\n<p>Obviously, the copy constructor is not enough. What am I missing?</p>\n<p>EDIT:\nOfc. I cannot change this-&gt;c in operator=() method, so I don't see how operator=() would be used (although required by std::vector).</p>\n", "AcceptedAnswerId": "4137633", "Title": "std::vector of objects and const-correctness", "CreationDate": "2010-11-08T13:33:10.237", "Id": "4124271", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2010-11-08T14:03:12.493", "LastEditorUserId": "275297", "LastActivityDate": "2015-03-09T17:46:12.513", "Score": "12", "OwnerUserId": "275297", "Tags": "<c++><vector><const-correctness>", "AnswerCount": "9"}, "28948498": {"Id": "28948498", "PostTypeId": "2", "Body": "<p>I recently ran into the same situation and I used a std::set instead, because its mechanism for adding an element (insert) does not require the = operator (uses the &lt; operator), unlike vector's mechanism (push_back).</p>\n<p>If performance is a problem you may try unordered_set or something else similar.</p>\n", "LastActivityDate": "2015-03-09T17:46:12.513", "CommentCount": "0", "CreationDate": "2015-03-09T17:46:12.513", "ParentId": "4124271", "Score": "0", "OwnerUserId": "4292392"}, "4124752": {"Id": "4124752", "PostTypeId": "2", "Body": "<p>You also need to implement a copy constructor, which will look like this:<code></code></p>\n<pre><code>class A {\npublic:\n    const int c; // must not be modified!\n\n    A(int _c)\n    ...\n\n    A(const A&amp; copy)\n    ...  \n\n    A&amp; operator=(const A&amp; rhs)\n    {\n        int * p_writable_c = const_cast&lt;int *&gt;(&amp;c);\n        *p_writable_c = rhs.c;\n        return *this;\n    }\n\n};\n</code></pre>\n<p></p>\n<p>The special <code>const_cast</code> template takes a pointer type and casts it back to a writeable form, for occasions such as this.</p>\n<p>It should be noted that <code>const_cast</code> is not always safe to use, see <a href=\"https://stackoverflow.com/questions/357600/is-const-cast-safe\">here</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-11-08T14:29:47.660", "Score": "0", "CreationDate": "2010-11-08T14:29:47.660", "ParentId": "4124271", "CommentCount": "0", "OwnerUserId": "341459", "LastEditDate": "2017-05-23T12:24:45.347"}, "4137633": {"Id": "4137633", "PostTypeId": "2", "Body": "<p>I'm not sure why nobody said it, but the correct answer is to drop the <code>const</code>, or store <code>A*</code>'s in the vector (using the appropriate smart pointer).</p>\n<p>You can give your class terrible semantics by having \"copy\" invoke UB or doing nothing (and therefore not being a copy), but why all this trouble dancing around UB and bad code? What do you get by making that <code>const</code>? (Hint: Nothing.) Your problem is conceptual: <strong>If a class has a const member, the class is const. Objects that are const, fundamentally, cannot be assigned.</strong></p>\n<p>Just make it a non-const <em>private</em>, and expose its value immutably. To users, this is equivalent, const-wise. It allows the implicitly generated functions to work just fine.</p>\n", "LastActivityDate": "2010-11-09T19:30:22.340", "CommentCount": "3", "CreationDate": "2010-11-09T19:30:22.340", "ParentId": "4124271", "Score": "16", "OwnerUserId": "87234"}, "4124302": {"Id": "4124302", "PostTypeId": "2", "Body": "<p>The stored type must meet the CopyConstructible <strong>and Assignable</strong> requirements, which means that operator= is needed too.</p>\n", "LastActivityDate": "2010-11-08T13:36:41.363", "CommentCount": "0", "CreationDate": "2010-11-08T13:36:41.363", "ParentId": "4124271", "Score": "2", "OwnerUserId": "451980"}, "4124304": {"Id": "4124304", "PostTypeId": "2", "Body": "<p>You're missing an assignment operator (or copy assignment operator), one of <a href=\"http://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)\" rel=\"noreferrer\">the big three</a>.</p>\n", "LastActivityDate": "2010-11-08T13:36:41.903", "CommentCount": "1", "CreationDate": "2010-11-08T13:36:41.903", "ParentId": "4124271", "Score": "7", "OwnerUserId": "338803"}, "4125170": {"Id": "4125170", "PostTypeId": "2", "Body": "<p>Workaround without <code>const_cast</code>.</p>\n<pre><code>A&amp; operator=(const A&amp; right) \n{ \n    if (this == &amp;right) return *this; \n    this-&gt;~A();\n    new (this) A(right);\n    return *this; \n} \n</code></pre>\n", "LastEditorUserId": "99594", "LastActivityDate": "2010-11-09T17:37:13.553", "Score": "0", "CreationDate": "2010-11-08T15:21:40.317", "ParentId": "4124271", "CommentCount": "9", "OwnerUserId": "124161", "LastEditDate": "2010-11-09T17:37:13.553"}, "4124309": {"Id": "4124309", "PostTypeId": "2", "Body": "<p>An STL container element must be <strong>copy-constructible and assignable</strong><sup>1</sup>(which your class <code>A</code> isn't). You need to overload <code>operator =</code>.</p>\n<p><sub>1\n: <code>\u00a723.1</code> says <code>The  type  of  objects  stored  in  these  components  must  meet  the  requirements  of CopyConstructible\ntypes (20.1.3), and the additional requirements of Assignabletypes</code></sub></p>\n<hr>\n<p><strong>EDIT</strong> :</p>\n<p><strong>Disclaimer</strong>: I am not sure whether the following piece of code is 100% safe. If it invokes UB or something please let me know.</p>\n<pre><code>A&amp; operator=(const A&amp; assign)\n{\n    *const_cast&lt;int*&gt; (&amp;c)= assign.c;\n    return *this;\n}\n</code></pre>\n<hr>\n<p><strong>EDIT 2</strong></p>\n<p>I think the above code snippet invokes Undefined Behaviour because trying to cast away the const-ness of a <code>const</code> qualified variable invokes <code>UB</code>.</p>\n</hr></hr>", "LastEditorUserId": "165520", "LastActivityDate": "2010-11-08T14:47:15.827", "Score": "15", "CreationDate": "2010-11-08T13:37:14.090", "ParentId": "4124271", "CommentCount": "13", "OwnerUserId": "165520", "LastEditDate": "2010-11-08T14:47:15.827"}, "bq_ids": {"n4140": {"so_4124271_4124422_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 472}, "so_4124271_4124422_1": {"length": 5, "quality": 1.0, "section_id": 472}, "so_4124271_4124422_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 467}, "so_4124271_4124422_2": {"length": 5, "quality": 1.0, "section_id": 369}}, "n3337": {"so_4124271_4124422_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 463}, "so_4124271_4124422_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 458}, "so_4124271_4124422_1": {"length": 5, "quality": 1.0, "section_id": 463}, "so_4124271_4124422_0": {"length": 18, "quality": 0.5806451612903226, "section_id": 453}, "so_4124271_4124422_2": {"length": 5, "quality": 1.0, "section_id": 359}}, "n4659": {"so_4124271_4124422_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 495}, "so_4124271_4124422_1": {"length": 5, "quality": 1.0, "section_id": 495}, "so_4124271_4124422_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 490}, "so_4124271_4124422_2": {"length": 5, "quality": 1.0, "section_id": 382}}}, "4124422": {"Id": "4124422", "PostTypeId": "2", "Body": "<p>I think the STL implementation of vector functions you are using require an assignment operator (refer Prasoon's quote from the Standard). However as per the quote below, since the assignment operator in your code is implicitly defined (since it is not defined explicitly), your program is ill-formed due to the fact that your class also has a const non static data member.</p>\n<p>C++03</p>\n<blockquote>\n<p id=\"so_4124271_4124422_0\">$12.8/12 - \"An implicitly-declared\n  copy assignment operator is implicitly\n  defined when an object of its class\n  type is assigned a value of its class\n  type or a value of a class type\n  derived from its class type. A program\n  is illformed if the class for which a\n  copy assignment operator is implicitly\n  defined has: </p>\n<p id=\"so_4124271_4124422_1\"><strong>\u2014 a nonstatic data member of const type, or</strong></p>\n<p id=\"so_4124271_4124422_2\">\u2014 a nonstatic data\n  member of reference type, or </p>\n<p id=\"so_4124271_4124422_3\">\u2014 a\n  nonstatic data member of class type\n  (or array thereof) with an\n  inaccessible copy assignment operator,\n  or </p>\n<p id=\"so_4124271_4124422_4\">\u2014 a base class with an inaccessible\n  copy assignment operator.</p>\n</blockquote>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-11-08T13:54:51.083", "Score": "0", "CreationDate": "2010-11-08T13:49:38.477", "ParentId": "4124271", "CommentCount": "0", "OwnerUserId": "418110", "LastEditDate": "2010-11-08T13:54:51.083"}});