post_cb({"23432573": {"ParentId": "23431386", "CommentCount": "0", "Body": "<p>In C++, virtual and static don't mix.</p>\n<ul>\n<li><code>virtual</code> = concrete operation depends on the type of an object.</li>\n<li><code>static</code> = you don't need an object.</li>\n</ul>\n<p>It is certainly possible to imagine such a thing, however. If C++ had something like meta types, allowing you to treat regular <strong>types as objects</strong>, then it would not be such a strange idea anymore.</p>\n<p>Pseudo-code (using an <strong>imaginary</strong> syntax):</p>\n<pre><code>void f(Class base_class)\n{\n   base_class.StaticMethod();\n}\n\nstruct Base\n{\n  virtual static StaticMethod(); // impossible in C++\n};\n\nstruct Derived : Base\n{\n  virtual static StaticMethod(); // impossible in C++\n};\n\nf(Base); // impossible in C++\nf(Derived); // impossible in C++\n</code></pre>\n<p>The desire to create something like static virtual functions is sometimes a symptom for the real need (which C++ cannot fulfill out of the box): treating types as objects.</p>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "23432573", "Score": "1", "CreationDate": "2014-05-02T16:14:28.927", "LastActivityDate": "2014-05-02T16:14:28.927"}, "23431606": {"ParentId": "23431386", "CommentCount": "3", "Body": "<p>Making <code>static virtual</code> methods isn't possible, quoting <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">C++11 standard N3337 - 10.3.10</a>:</p>\n<blockquote>\n<p id=\"so_23431386_23431606_0\">[ Note: The virtual specifier implies membership, so a virtual\n  function cannot be a nonmember (7.1.2) function. <strong>Nor can a virtual\n  function be a static member</strong>, since a virtual function call <strong>relies on a\n  specific object for determining which function to invoke</strong>. A virtual\n  function declared in one class can be declared a friend in another\n  class. \u2014end note ]</p>\n</blockquote>\n", "OwnerUserId": "1149736", "PostTypeId": "2", "Id": "23431606", "Score": "0", "CreationDate": "2014-05-02T15:22:57.823", "LastActivityDate": "2014-05-02T15:22:57.823"}, "23431386": {"CommentCount": "8", "ViewCount": "89", "PostTypeId": "1", "LastEditorUserId": "2544357", "CreationDate": "2014-05-02T15:11:29.210", "LastActivityDate": "2014-05-02T16:14:28.927", "Title": "Calling a derived-class implementation of a pure virtual function statically using a function in the base class", "AcceptedAnswerId": "23432573", "LastEditDate": "2014-05-02T15:25:22.787", "Id": "23431386", "Score": "0", "Body": "<p>There's some discussion of this topic elsewhere in stackoverflow, but I haven't really found a clear answer to my question.</p>\n<p>My setup is like this:</p>\n<pre><code>class BaseClass\n{\n    virtual short return_number_for_thing1(std::string thing1)=0; //note the pure virtual\n    virtual short return_number_for_thing2(std::string thing2)=0;\n    virtual short return_number_for_thing(std::string thing); //virtual is probably not necessary here, I can get rid of it if need be\n}\n\nshort BaseClass::return_number_for_thing(std::string thing)\n{ //pretend thing1 and thing2 are enum'ed somewhere\n    if      (thing == thing1) return return_number_for_thing1(thing);\n    else if (thing == thing2) return return_number_for_thing2(thing);\n}\n\nclass DerivedClass1 : BaseClass\n{\n    short return_number_for_thing1(std::string thing1);\n    short return_number_for_thing2(std::string thing2);\n}\n\nclass DerivedClass2 : BaseClass\n{\n    short return_number_for_thing1(std::string thing1);\n    short return_number_for_thing2(std::string thing2);\n}\n</code></pre>\n<p>My question is, why can't I write code like this:</p>\n<pre><code>short number_i_want = DerivedClass2::return_number_for_thing(thing);\n</code></pre>\n<p>I sort of understand that trying to call return_number_for_thing from a BaseClass pointer doesn't make sense, since it doesn't know whether to call the routines for DerivedClass1 or DerivedClass2, but if I give it the scope of DerivedClass2, shouldn't it be able to figure out what I want? For now, I create a blank instance of DerivedClass2 or DerivedClass1 when I need to, but it seems to me that I shouldn't have to do that.</p>\n", "Tags": "<c++><inheritance><static><pure-virtual>", "OwnerUserId": "2544357", "AnswerCount": "3"}, "23431797": {"ParentId": "23431386", "CommentCount": "0", "Body": "<p>You can make a function virtual or static , not both.  </p>\n<p>A virtual function must have a vtable pointer which requires an instance of an object, a static function cannot (by definition) have an instance to which it relates. </p>\n<p>If you declare the functions as e.g:</p>\n<pre><code>virtual short return_number_for_thing1(std::string thing1)=0;\n</code></pre>\n<p>then you must create an instance and use it e.g. <code>m_Instance-&gt;return_number_for_thing1(...)</code> (but since you are not using any member variables it would seem this doesnt really make sense).</p>\n<p>If you declare the functions as static:</p>\n<pre><code>static short return_number_for_thing1(std::string thing1)\n</code></pre>\n<p>Then you must invoke the function statically <code>BaseClass::return_number_for_thing1()</code>, if you provide a static version of the same function in the derived class it now becomes an override and you choose which one you call at compile time with either <code>BaseClass::return_number_for_thing1</code> or <code>DerivedClass::return_number_for_thing1</code>..</p>\n<p>Your question still doesnt really make sense as stated since you cannot use a virtual function statically.  Statically implies that you want to use it without any instance , its simply like a c function but hidden in the namespace of the class (and obeys privacy).   Virtual functions require an instance on which to operate.</p>\n", "OwnerUserId": "481111", "PostTypeId": "2", "Id": "23431797", "Score": "1", "CreationDate": "2014-05-02T15:33:37.827", "LastActivityDate": "2014-05-02T15:33:37.827"}, "bq_ids": {"n4140": {"so_23431386_23431606_0": {"section_id": 7011, "quality": 0.875, "length": 35}}, "n3337": {"so_23431386_23431606_0": {"section_id": 6757, "quality": 0.875, "length": 35}}, "n4659": {"so_23431386_23431606_0": {"section_id": 8508, "quality": 0.875, "length": 35}}}});