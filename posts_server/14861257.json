post_cb({"14861257": {"CommentCount": "1", "AcceptedAnswerId": "14861421", "PostTypeId": "1", "LastEditorUserId": "392046", "CreationDate": "2013-02-13T19:17:41.510", "LastActivityDate": "2013-02-13T20:04:12.900", "LastEditDate": "2013-02-13T19:18:29.287", "ViewCount": "534", "FavoriteCount": "1", "Title": "thread local statics in c++ and gcc", "Id": "14861257", "Score": "2", "Body": "<p>I am trying to understand the behavior of local statics with gcc and c++ (pre c++11 and post). A lot of times, in a member function I find myself doing something like so:</p>\n<pre><code>struct Foo\n{\n    void foo() \n    {\n        static const bool bar = someFunc();\n        //etc\n    }\n};\n</code></pre>\n<p>For example where <code>someFunc()</code> is <code>getenv(\"SOME_ENV_VAR\")</code>. In the above code, what are the rules governing <code>bar</code>? I believe, but do not have a reference, that gcc will compile a synchronization mechanism (not sure what) to protect the above local static from multiple threads. How do things change if it is no longer <code>const</code>? or if we make it thread local with <code>__thread</code>? And if <code>foo()</code> is not a member function?</p>\n", "Tags": "<c++><multithreading><gcc><static><const>", "OwnerUserId": "970171", "AnswerCount": "1"}, "14861421": {"ParentId": "14861257", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>The rules are actually defined by C++ std and not gcc: <a href=\"http://cpp0x.centaur.ath.cx/stmt.dcl.html\" rel=\"nofollow\">http://cpp0x.centaur.ath.cx/stmt.dcl.html</a></p>\n<p>I'd say that:</p>\n<ul>\n<li>gcc will protect initialization but not usage of the static; the variable is initialized the first time block is entered</li>\n<li>const does not affect it, as long as it's static storage</li>\n<li>__thread vars are initialized using their own initialization and are not protected by any extra lock (as pointed in comments by jmetcalfe)</li>\n<li>static should be at block scope, so any block will do, even just {} pair.</li>\n<li>(by Aurelien, see comments) someFunc will be called only once</li>\n</ul>\n<p>There're other issues like re-entering from recursion and no deadlocks allowed, it is all described in the link above. Also, C++ 03 and 11 std versions are a bit different on this topic.</p>\n<p>Quote:</p>\n<blockquote>\n<p id=\"so_14861257_14861421_0\">If control enters the declaration concurrently while the variable is\n  being initialized, the concurrent execution shall wait for completion\n  of the initialization</p>\n</blockquote>\n<p>$6.7.4, C++11</p>\n<p>which means that it <strong>is</strong> thread-safe - but only in the new standard. Anyway in gcc this is controlled by -f[no-]threadsafe-statics option.</p>\n<p>I'm also interested in the downvote, I mean, if you think the link is wrong it would be nice to tell why, so that me and others know.</p>\n", "OwnerUserId": "119224", "LastEditorUserId": "119224", "LastEditDate": "2013-02-13T20:04:12.900", "Id": "14861421", "Score": "2", "CreationDate": "2013-02-13T19:26:15.960", "LastActivityDate": "2013-02-13T20:04:12.900"}, "bq_ids": {"n4140": {"so_14861257_14861421_0": {"section_id": 3919, "quality": 1.0, "length": 13}}, "n3337": {"so_14861257_14861421_0": {"section_id": 3779, "quality": 1.0, "length": 13}}, "n4659": {"so_14861257_14861421_0": {"section_id": 4805, "quality": 1.0, "length": 13}}}});