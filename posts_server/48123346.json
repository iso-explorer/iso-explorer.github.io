post_cb({"48123764": {"Id": "48123764", "PostTypeId": "2", "Body": "<p>Yakk already addresses the designated initializer part of your question. I'll address the last part of your question. Is <code>S::S::S var</code> (within this context) valid? No, per <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.qual#2\" rel=\"nofollow noreferrer\">class.qual#2</a>:</p>\n<blockquote>\n<p id=\"so_48123346_48123764_0\">In a lookup in which function names are not ignored<sup>34</sup> and the\n  nested-name-specifier nominates a class C:</p>\n<ul>\n<li><p id=\"so_48123346_48123764_1\">if the name specified after the nested-name-specifier, when looked up in C, is the injected-class-name of C (Clause [class]), or</p></li>\n<li><p id=\"so_48123346_48123764_2\">in a using-declarator of a using-declaration that is a member-declaration, if the name specified after the\n  nested-name-specifier is the same as the identifier or the\n  simple-template-id's template-name in the last component of the\n  nested-name-specifier, </p></li>\n</ul>\n<p id=\"so_48123346_48123764_3\">the name is instead considered to name the constructor of class C.</p>\n</blockquote>\n<p>In order to make it valid, you need to explicitly say <code>struct S::S::S var</code>. So clang 3.9 is wrong.</p>\n<p>Also, Rob's comment is not relevant here. <code>S::S</code> is only an injected class name when looked up inside the class definition.</p>\n", "LastActivityDate": "2018-01-06T02:35:30.990", "Score": "3", "CreationDate": "2018-01-06T02:35:30.990", "ParentId": "48123346", "CommentCount": "0", "OwnerUserId": "9179939"}, "bq_ids": {"n4140": {"so_48123346_48123764_3": {"length": 5, "quality": 1.0, "section_id": 7114}, "so_48123346_48123764_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7114}, "so_48123346_48123764_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 7114}, "so_48123346_48123764_1": {"length": 9, "quality": 1.0, "section_id": 7114}}, "n3337": {"so_48123346_48123764_3": {"length": 5, "quality": 1.0, "section_id": 6858}, "so_48123346_48123764_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6858}, "so_48123346_48123764_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5662}, "so_48123346_48123764_1": {"length": 9, "quality": 1.0, "section_id": 6858}}, "n4659": {"so_48123346_48123764_3": {"length": 5, "quality": 1.0, "section_id": 8615}, "so_48123346_48123764_2": {"length": 14, "quality": 1.0, "section_id": 8615}, "so_48123346_48123764_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 8615}, "so_48123346_48123764_1": {"length": 9, "quality": 1.0, "section_id": 8615}}}, "48123723": {"Id": "48123723", "PostTypeId": "2", "Body": "<p>Designated initializers are a C feature coming to C++ in <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b2a\" rel=\"tag\" title=\"show questions tagged 'c++2a'\">c++2a</a>.  They are a common extension in C++ mode.  Clearly they are restricted to pod (C-like) types at this point.  No surprises they break.</p>\n<p>In general, different compilers can produce different errors for incorrect code, especially when working with extensions to C++.  The C++ standard never mandates the content of a diagnostic (there may be an exception, but I do not recall what).</p>\n<p>gcc has an extension that lets you name object constructors.  This is conflicting with your pathological use of struct namespaces.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2018-01-06T03:16:03.853", "Score": "3", "CreationDate": "2018-01-06T02:25:46.300", "ParentId": "48123346", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2018-01-06T03:16:03.853"}, "48123346": {"ViewCount": "175", "Body": "<p>This began with an observation.  I changed some code that looked a bit like this (edit: I took out the designated initializers here, which weren't in the original code either):</p>\n<pre><code>struct S {\n    enum E { E1, E2 } member;\n}\n\n// file1.cc\nS v1 = { S::E1 };\n\n// file2.cc\nS v2 = { S::S::E2 };\n</code></pre>\n<p>Note that <code>file2.cc</code> excessively-qualifies <code>E2</code>.  Yet this works in both g++ and clang++.  (Edit 2: the g++ on this particular VM is g++-5.4.1, but the original code's been through earlier and later g++ versions, plus multiple clang versions.)  And indeed, we can write:</p>\n<pre><code>S v3 = { S::S::S::S::S::S::S::E1 };\n</code></pre>\n<p>(however many <code>S::</code>s we like), wherever we like.  I changed things so that <code>S</code> was no longer a plain <code>struct</code>, but rather a templated one, after which this stopped working.  Not that big a deal but it got me curious, so I experimented.</p>\n<p>If we change this to a non-POD type:</p>\n<pre><code>struct S {\n    S() { std::cout &lt;&lt; \"made an S\" &lt;&lt; std::endl; }\n    enum E { E1, E2 } member;\n}\n</code></pre>\n<p>(with appropriate <code>#include</code>) it's no longer allowed.  Clang and g++ produce different diagnostics.  Here's clang's complaint:</p>\n<pre><code>namespace.cc:8:3: error: no matching constructor for initialization of 'S'\nS x = { .member = S::S::E1 };\nnamespace.cc:3:8: note: candidate constructor (the implicit copy constructor)\n      not viable: cannot convert argument of incomplete type 'void' to\n      'const S &amp;' for 1st argument\nstruct S {\n       ^\nnamespace.cc:3:8: note: candidate constructor (the implicit move constructor)\n      not viable: cannot convert argument of incomplete type 'void' to 'S &amp;&amp;'\n      for 1st argument\nstruct S {\n       ^\nnamespace.cc:4:3: note: candidate constructor not viable: requires 0 arguments,\n      but 1 was provided\n  S() { std::cout &lt;&lt; \"made an S\\n\"; }\n  ^\n1 error generated.\n</code></pre>\n<p>and g++'s:</p>\n<pre><code>namespace.cc:8:28: error: could not convert \u2018{E1}\u2019 from \u2018&lt;brace-enclosed initializer list&gt;\u2019 to \u2018S\u2019\n S x = { .member = S::S::E1 };\n</code></pre>\n<p>These seem to be following different rules.  What's going on here?</p>\n<p>Next, let's try another bit of abuse.  Here's the entire program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct S {\n  S() { std::cout &lt;&lt; \"made an S\\n\"; }\n  enum E { E1, E2 } member;\n};\n\nint main() {\n  std::cout &lt;&lt; S::S::S::S::S::E1 &lt;&lt; std::endl;\n#ifdef DECL\n  S::S::S var;\n#endif\n  return 0;\n}\n</code></pre>\n<p>This code compiles (without <code>-DDECL</code>) in both compilers:</p>\n<pre><code>$ clang++-3.9 -std=c++11 -Wall -O namespace.cc\n$ ./a.out\n0\n$ g++ -Wall -std=c++11 -O namespace.cc\n$ ./a.out\n0\n</code></pre>\n<p>(No <code>S</code> is constructed here despite the complaint clang emits for the variable <code>member</code> initializer in the earlier code.)  Enabling the variable in <code>main</code>, though, results in a failure with g++, but not with clang:</p>\n<pre><code>$ clang++-3.9 -std=c++11 -DDECL -Wall -O namespace.cc\n$ ./a.out \n0\nmade an S\n$ g++ -std=c++11 -DDECL -Wall -O namespace.cc\nnamespace.cc: In function \u2018int main()\u2019:\nnamespace.cc:11:3: error: \u2018S::S\u2019 names the constructor, not the type\n   S::S::S var;\n   ^\nnamespace.cc:11:11: error: expected \u2018;\u2019 before \u2018var\u2019\n   S::S::S var;\n           ^\nnamespace.cc:11:14: error: statement cannot resolve address of overloaded function\n   S::S::S var;\n              ^\n</code></pre>\n<p>Which compiler is right, and why?  What exactly <em>are</em> the rules for this \"overqualified\" name ?</p>\n", "AcceptedAnswerId": "48123764", "Title": "odd C++ namespace resolution quirk and g++ vs clang++", "CreationDate": "2018-01-06T01:09:14.497", "LastActivityDate": "2018-01-06T03:16:03.853", "CommentCount": "17", "LastEditDate": "2018-01-06T01:36:01.717", "PostTypeId": "1", "LastEditorUserId": "1256452", "Id": "48123346", "Tags": "<c++><c++11><language-lawyer>", "Score": "4", "OwnerUserId": "1256452", "ClosedDate": "2018-01-06T03:08:57.457", "AnswerCount": "2"}});