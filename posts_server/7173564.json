post_cb({"7173651": {"ParentId": "7173564", "CommentCount": "3", "Body": "<p>Perhaps I'm getting this wrong but if you have:</p>\n<pre><code>// example.h\nnamespace SomeNamespace\n{\n    class SomeClass\n    {\n    public:\n        void someMemberFunction();\n    };\n\n    void someFreeFunction();\n};\n</code></pre>\n<p>You can also simply write:</p>\n<pre><code>#include \"example.h\"\n\n// example.cpp\nnamespace SomeNamespace\n{\n    void SomeClass::someMemberFunction()\n    {\n    }\n\n    void someFreeFunction()\n    {\n    }\n}\n</code></pre>\n", "OwnerUserId": "279259", "PostTypeId": "2", "Id": "7173651", "Score": "2", "CreationDate": "2011-08-24T10:05:54.003", "LastActivityDate": "2011-08-24T10:05:54.003"}, "7173564": {"CommentCount": "2", "ViewCount": "151", "CreationDate": "2011-08-24T09:59:50.037", "LastActivityDate": "2011-08-24T10:10:54.587", "Title": "Defining namespaced member vs free functions without qualification", "AcceptedAnswerId": "7173719", "PostTypeId": "1", "Id": "7173564", "Score": "0", "Body": "<p>I sometimes declare classes in nested namespaces and when it comes to defining their member functions, I prefer not to have to qualify each one with these  nested namespace names, especially if they are long-ish.</p>\n<p>Adding \"using namespace \"  (or, for more precise targetting, \"using ::SomeClass\")  before I define the member functions seems to obviate the need to qualify each definition, but I can't find anywhere in the spec that guarantees this, and I'm worried that it might be a behaviour that only works with GCC.  I note that there doesn't appear to be a similar mechanism for skipping the need to add the qualifiers when defining free functions(?).</p>\n<p>As an example of what I mean:</p>\n<p>Header:</p>\n<pre><code>// example.h\nnamespace SomeNamespace\n{\n    class SomeClass\n    {\n    public:\n        void someMemberFunction();\n    };\n\n    void someFreeFunction();\n};\n</code></pre>\n<p>Implementation:</p>\n<pre><code>// example.cpp\n#include \"example.h\"\n\nusing namespace SomeNamespace;\n\nvoid SomeClass::someMemberFunction()\n{\n    // OK: seems to define SomeNamespace::SomeClass::someMemberFunction(),\n    // even though we didn't qualify it with SomeNamespace::\n}\n\nvoid someFreeFunction()\n{\n    // Not what we wanted; declares and defines ::someFreeFunction(), not\n    // SomeNamespace::someFreeFunction() (quite understandably)\n}\n\nint main()\n{\n    SomeClass a;\n    a.someMemberFunction(); // Ok; it is defined above.\n    SomeNamespace::someFreeFunction(); // Undefined!\n    return 0;\n}\n</code></pre>\n<p>So my question: is the above way of definining SomeClass::someMemberFunction() legal, and where in the spec is this mentioned?  If legal, is it advisable? It certainly cuts down on clutter! :)</p>\n<p>Many thanks :)</p>\n", "Tags": "<c++><namespaces>", "OwnerUserId": "900727", "AnswerCount": "2"}, "7173719": {"ParentId": "7173564", "CommentCount": "5", "Body": "<p>When you define a member-function, the compiler realizes that it is a member-function that must belong to a previously declared class, so it looks that class up, as specified in Section 9.3.5 of the standard:</p>\n<blockquote>\n<p id=\"so_7173564_7173719_0\">If the definition of a member function is lexically outside its class\n  definition, the member function name shall be qualified by its class\n  name using the :: operator. [Note: a name used in a member function\n  definition (that is, in the parameter-declaration-clause including\n  the default arguments (8.3.6), or in the member function body, or, for\n  a constructor function (12.1), in a mem-initializer expression\n  (12.6.2)) is looked up as described in 3.4. ] [Example: </p>\n<pre><code>struct X {\n    typedef int T; \n    static T count; \n    void f(T); \n}; \n\nvoid X::f(T t = count) { }\n</code></pre>\n<p id=\"so_7173564_7173719_1\">The member function <code>f</code> of class <code>X</code> is defined in global scope; the\n  notation <code>X::f</code> specifies that the function <code>f</code> is a member of class <code>X</code> and\n  in the scope of class <code>X</code>. In the function definition, the parameter\n  type <code>T</code> refers to the typedef member <code>T</code> declared in class <code>X</code> and the\n  default argument count refers to the static data member count\n  declared in class <code>X</code>. ]</p>\n</blockquote>\n<p>Basically, what you are doing is fine. However, there is another (preferable) way to cut down on the clutter when using nested namespaces, or namespaces with long names (or both) - define an alias:</p>\n<pre><code>namespace short_name = averylong::nested::namespacename;\n</code></pre>\n", "OwnerUserId": "160206", "PostTypeId": "2", "Id": "7173719", "Score": "0", "CreationDate": "2011-08-24T10:10:54.587", "LastActivityDate": "2011-08-24T10:10:54.587"}, "bq_ids": {"n4140": {"so_7173564_7173719_1": {"section_id": 5884, "quality": 0.9696969696969697, "length": 32}, "so_7173564_7173719_0": {"section_id": 5884, "quality": 0.7692307692307693, "length": 30}}, "n3337": {"so_7173564_7173719_1": {"section_id": 5655, "quality": 0.9696969696969697, "length": 32}, "so_7173564_7173719_0": {"section_id": 5655, "quality": 0.7692307692307693, "length": 30}}, "n4659": {"so_7173564_7173719_0": {"section_id": 7367, "quality": 0.7692307692307693, "length": 30}, "so_7173564_7173719_1": {"section_id": 7367, "quality": 0.9696969696969697, "length": 32}}}});