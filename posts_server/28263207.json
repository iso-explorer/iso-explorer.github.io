post_cb({"28263207": {"ViewCount": "322", "Body": "<p>Let's say I have some lambdas with <strong>exactly the same captures</strong> and <strong>exactly the same signatures</strong>.</p>\n<pre><code>int captured;\nauto l0 = [&amp;captured](int x){ captured += x; }; \nauto l1 = [&amp;captured](int x){ captured -= x; };\nauto l2 = [&amp;captured](int x){ captured = x + 1; };\n</code></pre>\n<p>Now, let's say I need to store these lambdas in an <code>std::vector</code>, to call them at runtime.</p>\n<p>I cannot use a raw function pointer, as the captured variable forces the lambda to be a functor, rather than a conventional function.</p>\n<p>I could use <code>std::function</code>, but it's overkill, since I know for sure that all the lambdas have the same signature and the same captures. Since <code>std::function</code> supports lambdas with same signature <strong>but different captures</strong>, I'm <em>(very probably)</em> paying an additional runtime cost that could be <em>(?)</em> avoided.</p>\n<pre><code>std::vector&lt;decltype(l0)&gt; v0; // Ok\nv0.emplace_back(l0);          // Ok\nv1.emplace_back(l1);          // Nope: `decltype(l0) != decltype(l1)`\nv2.emplace_back(l2);          // Nope: `decltype(l0) != decltype(l2)`\n</code></pre>\n<p>I would like something to find out a common type between all lambdas, but <code>std::common_type</code> does not work.</p>\n<pre><code>// Nope: does not compile\nusing LCT = std::common_type_t&lt;decltype(l0), decltype(l1), decltype(l2)&gt;;\n</code></pre>\n<p>Basically, <strong>I need something between a raw function pointer and <code>std::function</code>.</strong> Does anything like that exist? And...  can anything like that be actually implemented?</p>\n", "AcceptedAnswerId": "28265416", "Title": "Common type of lambdas with same signature and captures", "CreationDate": "2015-02-01T13:29:00.937", "Id": "28263207", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2015-02-02T02:43:27.123", "Score": "3", "OwnerUserId": "598696", "Tags": "<c++><c++11><types><lambda><c++14>", "AnswerCount": "4"}, "28264768": {"Id": "28264768", "PostTypeId": "2", "Body": "<p>Remember what a lambda is: shorthand for a function object which could be written by hand in C++98.</p>\n<p>Your three lambdas are equivalent to the following:</p>\n<pre><code>int captured;\n\nstruct l0_t {\n    int&amp; captured;\n    l0_t(int&amp; _captured) : captured(_captured) {}\n    void operator()(int x) const { captured += x; }\n} l0(captured);\n\nstruct l1_t {\n    int&amp; captured;\n    l1_t(int&amp; _captured) : captured(_captured) {}\n    void operator()(int x) const { captured -= x; }\n} l1(captured);\n\nstruct l2_t {\n    int&amp; captured;\n    l2_t(int&amp; _captured) : captured(_captured) {}\n    void operator()(int x) const { captured = x + 1; }\n} l2(captured);\n</code></pre>\n<p>Given that, if you want to be able to treat these three objects polymorphically, then you need some kind of virtual dispatch, and that is exactly what <code>std::function</code> or <code>boost::variant</code> would give you.</p>\n<p>If you were willing to move away from lambdas, a simpler solution would be a single class with three different member functions, and a <code>vector</code> of pointers to member functions of that class, given that there's no reason for every element of the vector to have its own reference to the captured object:</p>\n<pre><code>struct f {\n    int&amp; captured;\n    f(int&amp; _captured) : captured(_captured) {}\n    void f0(int x) const { captured += x; }\n    void f1(int x) const { captured -= x; }\n    void f2(int x) const { captured = x + 1; }\n};\n\nint captured = 0;\nf multiplex(captured);\nstd::vector&lt;decltype(&amp;f::f0)&gt; fv { &amp;f::f0, &amp;f::f1, &amp;f::f2 };\nfor (auto&amp;&amp; fn : fv) {\n    (multiplex.*fn)(42);\n    std::cout &lt;&lt; captured &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "1639256", "LastActivityDate": "2015-02-01T19:44:01.173", "Score": "2", "CreationDate": "2015-02-01T16:10:37.870", "ParentId": "28263207", "CommentCount": "0", "OwnerUserId": "1639256", "LastEditDate": "2015-02-01T19:44:01.173"}, "28270441": {"Id": "28270441", "PostTypeId": "2", "Body": "<p>It does not exist.</p>\n<p>You can use <code>std::function</code>.  You can use <code>boost::variant</code>.  Or you can write your own type erasure type.</p>\n<p>A <code>one_of_these_function</code> that stores a <code>boost::variant</code> or reimplements it, and exposes a particular <code>operator()</code> signature that uses a visitor on the variant to invoke the right method would solve your problem reasonably efficiently.</p>\n<p>Another slightly insane option would be writing your own function like class based off \"fastest possible delegates\" techniques, presume that the above lambdas are the size of one pointer and can be treated as trivially copyable and use tomfoolery to pseudo-store them and invoke <code>operator()</code> on a pointer to said stored pointer.  I can tell you it works, but it may not be polite to the language.</p>\n", "LastActivityDate": "2015-02-02T02:43:27.123", "CommentCount": "0", "CreationDate": "2015-02-02T02:43:27.123", "ParentId": "28263207", "Score": "0", "OwnerUserId": "1774667"}, "bq_ids": {"n4140": {"so_28263207_28263286_0": {"length": 13, "quality": 0.8125, "section_id": 5962}}, "n3337": {"so_28263207_28263286_0": {"length": 13, "quality": 0.8125, "section_id": 5731}}, "n4659": {"so_28263207_28263286_0": {"length": 12, "quality": 0.75, "section_id": 7451}}}, "28265416": {"Id": "28265416", "PostTypeId": "2", "Body": "<p>Based on your answer to my comment, I think this is (very roughly) what you want:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;typename L, typename R, typename... Args&gt; struct lambda_hack\n{\n    using storage_type = std::aligned_storage_t&lt;sizeof(L), std::alignment_of&lt;L&gt;::value&gt;;\n    static storage_type storage;\n    static void init_data(const L&amp; arg) { new(&amp;storage) L(arg); }\n    template&lt;typename LL&gt; static R call_target(Args... args) { return reinterpret_cast&lt;LL&amp;&gt;(storage)(args...); }\n\n    template&lt;typename LL&gt; lambda_hack(LL&amp;&amp;) : target(call_target&lt;LL&gt;) { }\n    using target_type = R(*)(Args...);\n    target_type target;\n    R operator()(Args... args) const { return target(args...); }\n};\n\ntemplate&lt;typename L, typename R, typename... Args&gt; \ntypename lambda_hack&lt;L, R, Args...&gt;::storage_type lambda_hack&lt;L, R, Args...&gt;::storage;\n\nint main()\n{\n    int captured = 7;\n    auto l0 = [&amp;captured](int x){ captured += x; }; \n    auto l1 = [&amp;captured](int x){ captured -= x; };\n    auto l2 = [&amp;captured](int x){ captured = x + 1; };\n\n    using lhack = lambda_hack&lt;decltype(l0), void, int&gt;;\n    lhack::init_data(l0);\n    std::vector&lt;lhack&gt; v{l0, l1, l2};\n    for(auto&amp; h : v)\n    {\n        std::cout &lt;&lt; \"'captured' before: \" &lt;&lt; captured &lt;&lt; '\\n';\n        h(3);\n        std::cout &lt;&lt; \"'captured' after: \" &lt;&lt; captured &lt;&lt; '\\n' &lt;&lt; '\\n';\n    }\n    std::cout &lt;&lt; captured &lt;&lt; '\\n'; // prints '4', as expected\n}\n</code></pre>\n<p>The functor stored in the <code>std::vector</code> is just the size of one non-member function pointer. The actual captured data is stored separately, only once. Calling <code>operator()</code> on such a functor has the overhead of just one indirection through that pointer (better than a virtual function call).</p>\n<p>It compiles and runs on GCC 4.9.1 and Clang 3.5.0 in C++14 mode, and VC++ 2013.</p>\n<p>Consider this to be an <strong>alpha version</strong> of what you would actually use in production. It needs refining (for example, it doesn't destroy the static storage properly). I'd like to first see if this is indeed what you were looking for.</p>\n<p>The first thing to address is probably the fact that <code>storage</code> shouldn't be <code>static</code>. Since a set of such lambdas will be inherently very closely related, you'll probably want to store them in a container, as you mentioned in the question. Since <code>storage</code> needs to be available for as long as that container lives, I'd store it in the container itself (subclass <code>std::vector</code>, maybe?...) and destroy its contents when the container is destroyed.</p>\n", "LastEditorUserId": "4326278", "LastActivityDate": "2015-02-01T17:42:40.517", "Score": "2", "CreationDate": "2015-02-01T17:15:05.767", "ParentId": "28263207", "CommentCount": "7", "OwnerUserId": "4326278", "LastEditDate": "2015-02-01T17:42:40.517"}, "28263286": {"Id": "28263286", "PostTypeId": "2", "Body": "<p>C++ Standard section \u00a7 5.1.2 [expr.prim.lambda] :</p>\n<blockquote>\n<p id=\"so_28263207_28263286_0\">The type of the lambda-expression (which is also the type of the closure object) is a <strong>unique</strong>, unnamed non union class type \u2014 called the closure type</p>\n</blockquote>\n<p>Each lambda has a different type : <code>l0</code>, <code>l1</code> and <code>l2</code> have no common type.</p>\n<p>So consider either a <code>std::vector&lt;&gt;</code> of a variant type, e.g. <a href=\"http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html\" rel=\"nofollow\">boost.variant</a> (if you know the set of the lambda types), or use <code>std::function&lt;&gt;</code>, which seems appropriate here too.</p>\n<hr>\n<p><strong>Example</strong> with <a href=\"http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html\" rel=\"nofollow\">boost::variant</a> :</p>\n<pre><code>int main () {\n    int captured = 42;\n    auto l0 = [&amp;captured](int x){ captured += x; }; \n    auto l1 = [&amp;captured](int x){ captured -= x; };\n    auto l2 = [&amp;captured](int x){ captured = x + 1; };\n\n    std::vector&lt;boost::variant&lt; decltype(l0), decltype(l1), decltype(l2)&gt;&gt; variant;\n    variant.push_back(l0);\n    variant.push_back(l1);\n    variant.push_back(l2);\n\n    auto f =  boost::get&lt;decltype(l1)&gt;(variant[1]);\n\n    int i = 1;\n    f(i);\n    std::cout &lt;&lt; captured;\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/ed5d1de81744a00b\" rel=\"nofollow\">Demo</a></strong></p>\n<p><strong>Note:</strong></p>\n<p>As pointed by Johannes Schaub, a lambda variant like this one is not default constructible, i.e. you cant write :</p>\n<pre><code>boost::variant&lt; decltype(l0), decltype(l1), decltype(l2)&gt; v;\n</code></pre>\n<p>Whereas <code>std::function&lt;&gt;</code> are default constructible..</p>\n</hr>", "LastEditorUserId": "3510483", "LastActivityDate": "2015-02-01T14:02:56.813", "Score": "5", "CreationDate": "2015-02-01T13:36:30.827", "ParentId": "28263207", "CommentCount": "2", "OwnerUserId": "3510483", "LastEditDate": "2015-02-01T14:02:56.813"}});