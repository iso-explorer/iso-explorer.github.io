post_cb({"21599832": {"ParentId": "21598635", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In your specific case a declaration doesn't mean an instantiation</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n\ntemplate &lt;typename T&gt; class Stack {\n  typedef typename T::ThisDoesntExist StaticAssert; // T::NotExisting doesn't exist at all!\n};\n\n\nvoid f1(Stack&lt;char&gt;); // No instantiation, compiles\n\nclass Exercise {\n  Stack&lt;double&gt; &amp;rsd; // No instantiation, compiles (references don't need instantiation, are similar to pointers in this)\n\n  Stack&lt;int&gt;    si; // Instantiation! Doesn't compile!!\n};\n\n\nint main(){\n\n  Stack&lt;char&gt; *sc; // No Instantiation, this compiles successfully since a pointer doesn't need instantiation\n\n  f1(*sc); // Instantiation of Stack&lt;char&gt;! Doesn't compile!!\n\n  int iObj = sizeof(Stack&lt; std::string &gt;); // Instantiation of Stack&lt;std::string&gt;, doesn't compile!!\n\n}\n</code></pre>\n<p>notice the pointer/reference stuff: they don't require instantiation since no data is actually allocated (a pointer is just a few bytes to contain the address, has no need to have all the data stored.. take a look at the <a href=\"http://en.wikipedia.org/wiki/Opaque_pointer\">pimpl idiom</a> ).</p>\n<p><strong>Only when stuff is allocated</strong> then the template has to be completely resolved (and that happens at compile-time, that's why they usually need both declaration and definition.. there's no linking phase yet)</p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "1728537", "LastEditDate": "2014-02-06T11:08:50.027", "Id": "21599832", "Score": "8", "CreationDate": "2014-02-06T10:14:26.750", "LastActivityDate": "2014-02-06T11:08:50.027"}, "21598635": {"CommentCount": "3", "AcceptedAnswerId": "21599832", "PostTypeId": "1", "LastEditorUserId": "1809544", "CreationDate": "2014-02-06T09:24:52.807", "LastActivityDate": "2014-02-06T11:08:50.027", "LastEditDate": "2014-02-06T09:38:23.333", "ViewCount": "573", "FavoriteCount": "4", "Title": "How is a template instantiated?", "Id": "21598635", "Score": "13", "Body": "<p>It's an exercise from <em>C++ Primer 5th Edition</em>:</p>\n<blockquote>\n<p id=\"so_21598635_21598635_0\">Exercise 16.27: For each labeled statement explain what, if any,\n  instantiations happen. If a template is instantiated, explain why; if\n  not, explain why not.  P.677</p>\n</blockquote>\n<pre><code>template &lt;typename T&gt; class Stack { };\n\nvoid f1(Stack&lt;char&gt;);                   // (a)\n\nclass Exercise {\n    Stack&lt;double&gt; &amp;rsd;                 // (b)\n    Stack&lt;int&gt;    si;                   // (c)\n};\n\nint main() {\n    Stack&lt;char&gt; *sc;                    // (d)\n    f1(*sc);                            // (e)\n    int iObj = sizeof(Stack&lt; string &gt;); // (f)\n}\n</code></pre>\n<p>Below is what I tried:</p>\n<p>(a) <code>Stack&lt;char&gt;</code> is instantiated , but no member of it is instantiated.</p>\n<p>(b) <code>Stack&lt;double&gt;</code> is instantiated , but no member of it is instantiated.</p>\n<p>(c) <code>Stack&lt;int&gt;</code> and its default constructor are instantiated.</p>\n<p>(d) (e) totally no idea...</p>\n<p>(f) <code>Stack&lt; string &gt;</code> is instantiated , but no member of it is instantiated.</p>\n<p>Am I right? Can anyone tell me how this code is instantiated? </p>\n", "Tags": "<c++><templates><instantiation>", "OwnerUserId": "1809544", "AnswerCount": "2"}, "21599387": {"ParentId": "21598635", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Regarding e and d I will quote the standard 14.7.1 </p>\n<blockquote>\n<p id=\"so_21598635_21599387_0\">Unless a function template specialization has been explicitly\n  instantiated or explicitly specialized, the function template\n  specialization is implicitly instantiated when the specialization is\n  referenced in a context that requires a function definition to exist.\n  Unless a call is to a function template explicit specialization or to\n  a member function of an explicitly specialized class template, a\n  default argument for a function template or a member function of a\n  class template is implicitly instantiated when the function is called\n  in a context that requires the value of the default argument.</p>\n</blockquote>\n<p>Example also from the standard </p>\n<pre><code>template&lt;class T&gt; struct Z {\nvoid f();\nvoid g();\n};\n\nvoid h() \n{\nZ&lt;int&gt; a;     // instantiation of class Z&lt;int&gt; required\nZ&lt;char&gt;* p;   // instantiation of class Z&lt;char&gt; not required\nZ&lt;double&gt;* q; // instantiation of class Z&lt;double&gt; not required\na.f();        // instantiation of Z&lt;int&gt;::f() required\np-&gt;g();       // instantiation of class Z&lt;char&gt; required, and instantiation of Z&lt;char&gt;::g() required\n}\n</code></pre>\n<p>This means that no instantiation happens in d. While it will be instantiated in e if that function actually needed to call a function from that type ( could be a copy constructor or any other function called inside the function). </p>\n", "OwnerUserId": "2794292", "LastEditorUserId": "2794292", "LastEditDate": "2014-02-06T10:03:01.727", "Id": "21599387", "Score": "3", "CreationDate": "2014-02-06T09:55:07.423", "LastActivityDate": "2014-02-06T10:03:01.727"}, "bq_ids": {"n4140": {"so_21598635_21599387_0": {"section_id": 235, "quality": 0.9615384615384616, "length": 50}}, "n3337": {"so_21598635_21599387_0": {"section_id": 228, "quality": 0.9615384615384616, "length": 50}}, "n4659": {"so_21598635_21599387_0": {"section_id": 245, "quality": 0.9615384615384616, "length": 50}}}});