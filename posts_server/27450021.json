post_cb({"27515618": {"Id": "27515618", "PostTypeId": "2", "Body": "<p>You are comparing memory addresses. The example that follow explains how to compare 2 strings:</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n#include &lt;cstring&gt; //prototype for strcmp()\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n using namespace std;\n\n cout &lt;&lt; strcmp(\"A\", \"Z\"); // will print -1\n cout &lt;&lt; strcmp(\"Z\", \"A\"); // will print 1\n\n return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-12-16T23:08:05.193", "CommentCount": "0", "CreationDate": "2014-12-16T23:08:05.193", "ParentId": "27450021", "Score": "0", "OwnerUserId": "4276132"}, "27520055": {"Id": "27520055", "PostTypeId": "2", "Body": "<p>A String is representing a pointer to memory area. So you at first compare only memory addresses with such code </p>\n<pre><code>\"Z\"&lt; \"A\"\n</code></pre>\n<p>comparing strings is done with functions. They depend on \"what kind of string\" you have. You have char array strings, but they mid also be objects. These objects have other comparision functions. For instance the CString in MFC has the Compare but also the CompareNoCase function.</p>\n<p>For your strings you best use the strcmp. If you debug and step in you see what the function does: it compares every char of both strings and return an integer if the first difference occurs or zero if the same.</p>\n<pre><code>int result = strcmp(\"Z\", \"A\");\n</code></pre>\n<p>Here you find some further <a href=\"http://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm\" rel=\"nofollow\">sample code</a></p>\n", "LastActivityDate": "2014-12-17T07:11:00.923", "CommentCount": "0", "CreationDate": "2014-12-17T07:11:00.923", "ParentId": "27450021", "Score": "0", "OwnerUserId": "760765"}, "27450045": {"Id": "27450045", "PostTypeId": "2", "Body": "<p>You are comparing memory addresses. Apparently your compiler places the string literals in memory in the order it encounters them, so the first is \"lesser\" than the second.</p>\n<p>Since in the first snippet it sees \"A\" first and \"Z\" second, \"A\" is lesser. Since it sees \"Z\" first in the second, \"Z\" is lesser. In the last snippet, it already has literals \"A\" and \"Z\" placed when the second command rolls around.</p>\n", "LastEditorDisplayName": "user3920237", "LastActivityDate": "2014-12-12T20:17:47.743", "Score": "86", "CreationDate": "2014-12-12T18:43:10.293", "ParentId": "27450021", "CommentCount": "10", "OwnerUserId": "4301306", "LastEditDate": "2014-12-12T20:17:47.743"}, "27450121": {"Id": "27450121", "PostTypeId": "2", "Body": "<p>If you want to compare actual C++ strings, you need to declare C++ strings:</p>\n<pre><code>int main() \n{\n  const std::string a(\"A\");\n  const std::string z(\"Z\");\n\n  cout &lt;&lt; (z &lt; a) &lt;&lt; endl; // false\n  cout &lt;&lt; (a &lt; z) &lt;&lt; endl; // true\n}\n</code></pre>\n", "LastActivityDate": "2014-12-12T18:47:58.780", "CommentCount": "0", "CreationDate": "2014-12-12T18:47:58.780", "ParentId": "27450021", "Score": "7", "OwnerUserId": "87189"}, "27450123": {"Id": "27450123", "PostTypeId": "2", "Body": "<p>In the statement:</p>\n<pre><code>cout &lt;&lt; (\"A\"&lt; \"Z\");\n</code></pre>\n<p>You have created 2 <a href=\"http://en.cppreference.com/w/cpp/language/string_literal\">string literals</a>: <code>\"A\"</code> and <code>\"Z\"</code>. These are of type <code>const char *</code> which is a pointer to a null terminated array of characters. The comparison here is comparing the pointers and not the values that they point to. It's this comparing of memory addresses here which is what gives you the compiler warning. The result of the comparison is going to be determined by where the compiler allocated the memory to which is going to be somewhat arbitrary from compiler to compiler. In this case it looks like the first literal found is getting assigned the first memory address by your compiler.</p>\n<p>Just like in C to compare these string literals properly you need to use <a href=\"http://en.cppreference.com/w/c/string/byte/strcmp\"><code>strcmp</code></a> which will do a value comparison.</p>\n<p>However when you do something the more idiomatic c++ way by doing:</p>\n<pre><code>cout &lt;&lt; (std::string(\"A\") &lt; std::string(\"Z\"));\n</code></pre>\n<p>Then you get the proper comparison of the values as that comparison operator is defined for <code>std::string</code>.</p>\n", "LastEditorUserId": "296460", "LastActivityDate": "2014-12-12T18:53:49.177", "Score": "13", "CreationDate": "2014-12-12T18:48:10.690", "ParentId": "27450021", "CommentCount": "0", "OwnerUserId": "296460", "LastEditDate": "2014-12-12T18:53:49.177"}, "27450079": {"Id": "27450079", "PostTypeId": "2", "Body": "<p>String literals have static storage duration. In all these comparisons there are compared addresses of memory allocated by the compiler for string literals. It seems that the first string literal that is encountered by the compiler is stored in memory with a lower address compared with the next encountered string literal.</p>\n<p>Thus in this program</p>\n<pre><code>int main() \n{ \n  cout &lt;&lt; (\"Z\"&lt; \"A\");\n  cout &lt;&lt; (\"A\"&lt; \"Z\");\n}\n</code></pre>\n<p>string literal \"Z\" was alllocated with a lower address than string literal \"A\" because it was found first by the compiler.</p>\n<p>Take into account that comparison</p>\n<pre><code>  cout &lt;&lt; (\"A\"&lt; \"A\");\n</code></pre>\n<p>can give different results depending on the options of the compiler because the compiler may either allocate two extents of memory for the string literals or use only one copy of the string literals that are the same.</p>\n<p>From the C++ Standard (2.14.5 String literals)</p>\n<blockquote>\n<p id=\"so_27450021_27450079_0\">12 Whether all string literals are distinct (that is, are stored in\n  nonoverlapping objects) is implementation defined. The effect of\n  attempting to modify a string literal is undefined.</p>\n</blockquote>\n<p>The same is valid for C.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-12-12T18:53:09.140", "Score": "19", "CreationDate": "2014-12-12T18:45:28.330", "ParentId": "27450021", "CommentCount": "1", "OwnerUserId": "2877241", "LastEditDate": "2014-12-12T18:53:09.140"}, "bq_ids": {"n4140": {"so_27450021_27450079_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 5361}, "so_27450021_27451656_0": {"length": 26, "quality": 1.0, "section_id": 5356}, "so_27450021_27451656_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}}, "n3337": {"so_27450021_27451656_0": {"length": 26, "quality": 1.0, "section_id": 5153}, "so_27450021_27451656_3": {"length": 13, "quality": 1.0, "section_id": 5913}, "so_27450021_27451656_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_27450021_27451656_5": {"length": 20, "quality": 1.0, "section_id": 5913}, "so_27450021_27450079_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 5157}, "so_27450021_27451656_7": {"length": 20, "quality": 1.0, "section_id": 5913}}, "n4659": {"so_27450021_27450079_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6789}, "so_27450021_27451656_0": {"length": 26, "quality": 1.0, "section_id": 6781}, "so_27450021_27451656_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 7709}, "so_27450021_27451656_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}}}, "27451656": {"Body": "<p>In C++, the results are unspecified. I will be using <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a> for C++11. </p>\n<p>First, we have to look at what the type of a string literal is.</p>\n<p>\u00a72.14.5</p>\n<blockquote>\n<p id=\"so_27450021_27451656_0\"><code>9</code> Ordinary string literals and UTF-8 string literals are also\n  referred to as narrow string literals. A narrow string literal has\n  type \"array of <em>n</em> <code>const char</code>\", where <em>n</em> is the size of the string\n  as defined below, and has static storage duration (3.7).</p>\n</blockquote>\n<p>Arrays are colloquially said to <em>decay</em> to pointers.</p>\n<p>\u00a74.2</p>\n<blockquote>\n<p id=\"so_27450021_27451656_1\"><code>1</code> An lvalue or rvalue of type \"array of <code>N T</code>\" or \"array of unknown\n  bound of <code>T</code>\" can be converted to a prvalue of type \"pointer to <code>T</code>\".\n  The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>Since your string literals both contain one character, they're the same type (<code>char[2]</code>, including the null character.)</p>\n<p>Therefore the following paragraph applies:</p>\n<p>\u00a75.9</p>\n<blockquote>\n<p id=\"so_27450021_27451656_2\"><code>2</code> [...]</p>\n<p id=\"so_27450021_27451656_3\">Pointers to objects or functions of the same type (after pointer\n  conversions) can be compared, with a result defined as follows:</p>\n<blockquote>\n<p id=\"so_27450021_27451656_6\">[...]</p>\n<p id=\"so_27450021_27451656_7\">\u2014 If two pointers <code>p</code> and <code>q</code> of the same type point to different\n    objects that are not members of the same object or elements of the\n    same array or to different functions, or if only one of them is null,\n    the results of <code>p&lt;q</code>, <code>p&gt;q</code>, <code>p&lt;=q</code>, and <code>p&gt;=q</code> are unspecified.</p>\n</blockquote>\n</blockquote>\n<p>Unspecified means that the behavior depends on the implementation. We can see that GCC gives a warning about this:</p>\n<pre><code>warning: comparison with string literal results in unspecified behaviour [-Waddress]\n     std::cout &lt;&lt; (\"Z\" &lt; \"A\");\n</code></pre>\n<p>The behavior <em>may</em> change across compilers or compiler settings but in practice for what happens, see Wintermute's <a href=\"https://stackoverflow.com/a/27450045/3920237\">answer</a>.</p>\n", "CreationDate": "2014-12-12T20:32:27.897", "ParentId": "27450021", "CommentCount": "0", "LastEditDate": "2017-05-23T12:32:39.127", "PostTypeId": "2", "LastEditorDisplayName": "user3920237", "OwnerDisplayName": "user3920237", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-12T20:39:07.020", "Id": "27451656", "Score": "7"}, "27450021": {"ViewCount": "2436", "Body": "<p>I'm a c++ newbie (just oldschool c).   My son asked for help with this and I'm unable to explain it.   If he had asked me \"how do I compare strings\" I would have told him to use strcmp(), but that isn't what is confusing me.   Here is what he asked:</p>\n<pre><code>int main() \n{ \n  cout &lt;&lt; (\"A\"&lt; \"Z\");\n}\n</code></pre>\n<p>will print 1</p>\n<pre><code>int main() \n{ \n  cout &lt;&lt; (\"Z\"&lt; \"A\");\n}\n</code></pre>\n<p>will also print 1, but</p>\n<pre><code>int main() \n{ \n  cout &lt;&lt; (\"Z\"&lt; \"A\");\n  cout &lt;&lt; (\"A\"&lt; \"Z\");\n}\n</code></pre>\n<p>will then print 10.   Individually both cout statements print 1, but executed in a row I get a different answer?  </p>\n", "AcceptedAnswerId": "27450045", "Title": "C++ Comparison of String Literals", "CreationDate": "2014-12-12T18:41:04.497", "Id": "27450021", "CommentCount": "4", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-09-12T09:57:40.270", "LastEditorUserId": "3777958", "LastActivityDate": "2015-09-12T09:57:40.270", "Score": "60", "OwnerUserId": "938512", "Tags": "<c++><string-literals>", "AnswerCount": "8"}, "27519452": {"Id": "27519452", "PostTypeId": "2", "Body": "<p>The string constants (\"A\" and \"Z\") in C++ are represented by the C concept - array of characters where the last character is '\\0'.  Such constants have to be compared with strcmp() type of function.</p>\n<p>If you would like to use the C++ std::string comparison you have to explicitly state it:</p>\n<pre><code>cout &lt;&lt; (std::string( \"A\") &lt; \"Z\");\n</code></pre>\n", "LastActivityDate": "2014-12-17T06:20:04.310", "CommentCount": "0", "CreationDate": "2014-12-17T06:20:04.310", "ParentId": "27450021", "Score": "0", "OwnerUserId": "2038893"}});