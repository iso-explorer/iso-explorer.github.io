post_cb({"bq_ids": {"n4140": {"so_28028606_28028747_1": {"length": 28, "quality": 1.0, "section_id": 304}}, "n3337": {"so_28028606_28028747_1": {"length": 28, "quality": 1.0, "section_id": 295}}, "n4659": {"so_28028606_28028747_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 311}}}, "28028799": {"Id": "28028799", "PostTypeId": "2", "Body": "<p>The compiler does the right thing. In a line like</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T&amp;&amp; param){}\n</code></pre>\n<p><code>T</code> is being deduced as reference if you pass a lvalue, and a simple type if you pass a rvalue. So <code>int x; f(x);</code> deduces <code>T</code> as <code>int&amp;</code>, and <code>f(1)</code> deduces <code>T</code> as <code>int</code>.</p>\n<p>That's how perfect forwarding works. Basically, you have the following rules for reference collapsing:</p>\n<pre><code>&amp; &amp;   -&gt; &amp;\n&amp; &amp;&amp;  -&gt; &amp;\n&amp;&amp; &amp;  -&gt; &amp;\n&amp;&amp; &amp;&amp; -&gt; &amp;&amp;\n</code></pre>\n<p>See also </p>\n<p><a href=\"https://stackoverflow.com/q/14302849/3093378\">Syntax for universal references</a></p>\n<p>for more details.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-19T16:25:10.213", "Score": "0", "CreationDate": "2015-01-19T16:05:09.547", "ParentId": "28028606", "CommentCount": "0", "LastEditDate": "2017-05-23T12:24:16.873", "OwnerUserId": "3093378"}, "28028747": {"Id": "28028747", "PostTypeId": "2", "Body": "<p>The behaviour is correct. Perfect forwarding is implemented by deducing an lvalue reference for the type when the argument is an lvalue.</p>\n<p>You're saying</p>\n<blockquote>\n<p id=\"so_28028606_28028747_0\">By the reference collapsing rules the type of the argument (<code>T&amp;&amp;</code>) should become <code>CValue&amp;</code> (as <code>T&amp;&amp; &amp;</code> -&gt; <code>T&amp;</code>), but <code>T</code> itself should be simply <code>CValue</code>, surely?</p>\n</blockquote>\n<p>But where would the <code>&amp;</code> in <code>T&amp;&amp; &amp;</code> come from if <code>T</code> was just <code>CValue</code>? The entire reason why <code>T&amp;&amp;</code> works as a forwarding reference is that the <code>T</code> becomes an lvalue reference, <code>CValue&amp;</code> in your case, and then reference collapsing gets <code>T &amp;&amp;</code> -&gt; <code>CValue &amp; &amp;&amp;</code> -&gt; <code>CValue &amp;</code>.</p>\n<p>The relevant section of the standard is C++11 14.8.2.1/3 (<code>P</code> is the function template parameter type and <code>A</code> s the type of the argument in the call, defined in 14.8.2.1/1):</p>\n<blockquote>\n<p id=\"so_28028606_28028747_1\">If <code>P</code> is a cv-qualified type, the top level cv-qualifiers of <code>P</code>\u2019s type are ignored for type deduction. If <code>P</code> is a\n  reference type, the type referred to by <code>P</code> is used for type deduction. <strong>If <code>P</code> is an rvalue reference to a cv-unqualified\n  template parameter and the argument is an lvalue, the type \u201clvalue reference to <code>A</code>\u201d is used in\n  place of <code>A</code> for type deduction.</strong></p>\n</blockquote>\n<p>(Emphasis mine)</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2015-01-19T16:11:08.587", "Score": "1", "CreationDate": "2015-01-19T16:02:33.277", "ParentId": "28028606", "CommentCount": "0", "LastEditDate": "2015-01-19T16:11:08.587", "OwnerUserId": "1782465"}, "28028606": {"ViewCount": "232", "Body": "<p>I'm trying to get my head around perfect forwarding in C++, and so I've written the following quick and dirty bit of code to test this.</p>\n<pre><code>class CValue\n{\npublic:\n\n    CValue(int i) :\n        m_i(i)\n    {\n        printf(\"Default constructor called!\\r\\n\");\n    }\n\n    CValue(const CValue&amp; src) :\n        m_i(src.m_i)\n    {\n        printf(\"Copy constructor called!\\r\\n\");\n    }\n\n    CValue(CValue&amp;&amp; src) :\n        m_i(src.m_i)\n    {\n        printf(\"Move constructor called!\\r\\n\");\n    }\n\n    CValue&amp; operator=(const CValue&amp; src)\n    {\n        m_i = src.m_i;\n        printf(\"Copy assignment called!\\r\\n\");\n        return *this;\n    }\n\n    CValue&amp; operator=(CValue&amp;&amp; src)\n    {\n        m_i = src.m_i;\n        printf(\"Move assignment called!\\r\\n\");\n        return *this;\n    }\n\n    int     m_i;\n};\n\ntemplate &lt;typename T&gt;\nvoid PerfectForwarding(T&amp;&amp; tValue)\n{\n    T tValue1 = tValue;\n    tValue1.m_i = 10;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CValue v(0);\n    PerfectForwarding(v);\n\n    printf(\"%d\\r\\n\", v.m_i);\n\n    return 0;\n}\n</code></pre>\n<p>When I build and run this code as a console application I get the answer 10, when I was expecting 0. </p>\n<p>It seems that the line: </p>\n<pre><code>T tValue1 = tValue;\n</code></pre>\n<p>in the PerfectForwarding function is being resolved to: </p>\n<pre><code>CValue&amp; tValue1 = tValue;\n</code></pre>\n<p>instead of: </p>\n<pre><code>CValue tValue1 = tValue;\n</code></pre>\n<p>So the compiler is resolving T to be CValue&amp;, which I didn't expect.</p>\n<p>I tried invoking the function from _tmain by explicitly declaring the template parameter type, i.e.</p>\n<pre><code>PerfectForwarding&lt;CValue&gt;(v);\n</code></pre>\n<p>but this fails to compile with the following error:</p>\n<pre><code>error C2664: 'void PerfectForwarding&lt;CValue&gt;(T &amp;&amp;)' : cannot convert\n              argument 1 from 'CValue' to 'CValue &amp;&amp;'\n              with\n              [\n                  T=CValue\n              ]\nYou cannot bind an lvalue to an rvalue reference\n</code></pre>\n<p>I can force the desired behaviour through changing the line in the PerfectForwarding function to the following:</p>\n<pre><code>typename std::remove_reference&lt;T&gt;::type tValue1 = tValue;\n</code></pre>\n<p>but I didn't think this should be necessary. By the reference collapsing rules the type of the argument (T&amp;&amp;) should become CValue&amp; (as T&amp;&amp; &amp; -&gt; T&amp;), but T itself should be simply CValue, surely? Is this a bug in the VC12 compiler's handling of rvalue references, or am I misunderstanding something about rvalue references and templates? </p>\n<p>I'm using Visual Studio 2013 (VC12 compiler) in debug with all optimisation turned off.</p>\n", "AcceptedAnswerId": "28028750", "Title": "Should template parameter T be resolving to T& when a function takes argument of T&& and is passed an lvalue?", "CreationDate": "2015-01-19T15:56:26.190", "LastActivityDate": "2015-01-19T16:25:10.213", "CommentCount": "7", "LastEditDate": "2015-01-19T16:21:02.283", "PostTypeId": "1", "Tags": "<c++><templates><c++11><perfect-forwarding>", "Id": "28028606", "AnswerCount": "3", "Score": "3", "OwnerUserId": "4470577", "ClosedDate": "2015-01-23T19:24:14.400", "LastEditorUserId": "4470577"}, "28028750": {"Id": "28028750", "PostTypeId": "2", "Body": "<p>When the compiler sees just <code>T&amp;&amp;</code> it's going to try to deduce <code>T</code> to something that allows the function to be called with whatever you're giving it.  So you wind up with <code>T</code> being <code>Cvalue&amp;</code> when called with an lvalue so the reference collapsing (as you've pointed out) can kick in.</p>\n<p>This matters when you try to forward the argument.  <code>std::forward&lt;T&gt;(v)</code> will either forward the argument as an lvalue or an rvalue depending on what <code>T</code> is.  If it has been deduced to an lvalue reference, it will forward it as an lvalue, if it hasn't, it will be forwarded as an rvalue.  The type <code>T</code> is the only thing that distinguishes.</p>\n<p><em>By the reference collapsing rules the type of the argument (T&amp;&amp;) should become CValue&amp; (as T&amp;&amp; &amp; -&gt; T&amp;), but T itself should be simply CValue, surely?</em> <br/>\nIf called with an lvalue it goes <code>(T&amp;&amp; v)</code> \"okay, I can't bind an rvalue reference to an lvalue, but if I make <code>T</code> itself be an lvalue reference then this works.\"  <code>T</code> is deduced to be <code>Cvalue&amp;</code> so that <code>(T&amp;&amp; v)</code> expands to <code>(Cvalue&amp; &amp;&amp; v)</code>.  Now the reference is collapsed <code>(Cvalue&amp; v)</code>.  The type <code>T</code> must be an lvalue-reference type for this to work.</p>\n<p>If you provide the template parameter explicitly then you're not really addressing the issue.  The first way around this is the <code>remove_reference</code> as you've found.  You could also use <code>auto</code> which makes more sense since this is generic programming</p>\n<pre><code>auto tValue1 = tValue;\n</code></pre>\n<p>In any case, the <code>auto</code> won't deduce to a reference.  For what you've provided, you'd be better off using a <code>const</code> lvalue reference which can bind to both lvalues and rvalues.</p>\n<pre><code>template &lt;typename T&gt;\nvoid PerfectForwarding(const T&amp; tValue)\n{\n    T tValue1 = tValue;\n    tValue1.m_i = 10;\n}\n</code></pre>\n<p>this doesn't allow for forwarding, but it's not a forwarding function as-is anyway.</p>\n<p>If you wanted to handle lvalues differently you could provide two overloads</p>\n<pre><code>template &lt;typename T&gt;\nvoid PerfectForwarding(T&amp; tValue);\n\ntemplate &lt;typename T&gt;\nvoid PerfectForwarding(T&amp;&amp; tValue);\n</code></pre>\n<p>When called with an lvalue, the former will be preferred.</p>\n", "LastEditorUserId": "1013719", "LastActivityDate": "2015-01-19T16:07:59.373", "Score": "3", "CreationDate": "2015-01-19T16:02:44.517", "ParentId": "28028606", "CommentCount": "9", "LastEditDate": "2015-01-19T16:07:59.373", "OwnerUserId": "1013719"}});