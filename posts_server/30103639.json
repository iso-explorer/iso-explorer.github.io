post_cb({"30104433": {"Id": "30104433", "PostTypeId": "2", "Body": "<p>Here we forward the work to helper types:</p>\n<pre><code>namespace details {\n  template&lt;class...Ts&gt;\n  struct sum_t {};\n\n  template&lt;class T&gt;\n  struct sum_t&lt;T&gt; {\n    T operator()(T t)const{ return std::forward&lt;T&gt;(t); }\n  };\n\n  template&lt;class T, class...Ts&gt;\n  struct sum_t&lt;T,Ts...&gt; {\n    auto operator()(T t, Ts...ts)const\n    -&gt; decltype( std::declval&lt;T&gt;() + sum_t&lt;Ts...&gt;{}(std::declval&lt;Ts&gt;()...) )\n    {\n      return std::forward&lt;T&gt;(t) + sum_t&lt;Ts...&gt;{}(std::forward&lt;Ts&gt;(ts)...);\n    }\n  };\n}\n\ntemplate&lt;class...Ts&gt;\nauto sum(Ts...ts)\n-&gt; decltype( details::sum_t&lt;Ts...&gt;{}(std::declval&lt;Ts&gt;()...) )\n// -&gt; std::result_of_t&lt;details::sum_t&lt;Ts...&gt;(Ts...)&gt;\n// above line is C++14 and cleaner version of previous line\n{\n  return details::sum_t&lt;Ts...&gt;{}(std::forward&lt;Ts&gt;(ts)...);\n}\n</code></pre>\n<p>the basic problem was that a template function cannot see itself when calculating its own return type in a <code>-&gt; decltype</code> clause.</p>\n<p>There are a few work arounds.  The above should work, because a template class can see other specializations of its partial specialization in its own body.  Another approach would be to use Koenig lookup (ADL) to defer the searching for its recursive call until the point of instantiation, where it can find itself.  I find that second approach more confusing.</p>\n<p>If I was to write my own <code>sum</code> for production, I'd have it optionally take the type I expect it to return, and if it did it would accept a zero length sum (creating a default instance), but not requires that the type be default constructable if I pass 1 or more arguments.  But I like over-engineered generic code:</p>\n<pre><code>template&lt;class R0=void,class...Ts,class R=std::conditional_t&lt;\n  !std::is_same&lt;R0,void&gt;{},\n  R0,\n  std::result_of_t&lt;details::sum_t&lt;Ts...&gt;(Ts...)&gt;\n&gt;&gt;\nR sum(Ts...ts)\n{\n  return details::sum_t&lt;R, Ts...&gt;{}(std::forward&lt;Ts&gt;(ts)...);\n}\n</code></pre>\n<p>where I modify <code>sum_t</code> to take the return type as the first parameter:</p>\n<pre><code>namespace details {\n  template&lt;class R,class...Ts&gt;\n  struct sum_t {\n    R operator()()const{ return {}; }\n  };\n\n  template&lt;class R, class T&gt;\n  struct sum_t&lt;R, T&gt; {\n    using R0 = std::conditional_t&lt;!std::is_same&lt;R,void&gt;{},R,T&gt;;\n    R0 operator()(T t)const{ return std::forward&lt;T&gt;(t); }\n  };\n\n  template&lt;class R, class T, class...Ts&gt;\n  struct sum_t&lt;R, T,Ts...&gt; {\n    using R0 = std::conditional_t&lt;\n      !std::is_same&lt;R,void&gt;{},\n      R,\n      decltype( std::declval&lt;T&gt;() + sum_t&lt;void,Ts...&gt;{}(std::declval&lt;Ts&gt;()...) )\n    &gt;;\n    R0 operator()(T t, Ts...ts)const\n    {\n      return std::forward&lt;T&gt;(t) + sum_t&lt;void,Ts...&gt;{}(std::forward&lt;Ts&gt;(ts)...);\n    }\n  };\n}\n</code></pre>\n<p>which makes me want to be able to write \"do this sum, but cast each sub-sum to <code>R</code> before continuing\" or somesuch.</p>\n<p>In C++1z, you'll want to use a fold-expression instead.  Being able to set <code>R</code> is still useful, as if you are adding up an expression template, it may only be valid as an expression template until the end of the current scope.</p>\n<p>To fix this problem in C++14, you may have to use continuation passing style with the <code>R</code> return value.</p>\n<p>We could then fold return type deduction into the game to allow</p>\n<pre><code>Matrix m = sum( many_matrices... );\n</code></pre>\n<p>to work in Eigen (for example).</p>\n<p>When you first start to write generic code, you have to ask yourself \"how deep down the rabbit hole do we want to go?\"</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-05-07T15:30:43.567", "Score": "3", "CreationDate": "2015-05-07T14:44:24.553", "ParentId": "30103639", "CommentCount": "3", "LastEditDate": "2015-05-07T15:30:43.567", "OwnerUserId": "1774667"}, "bq_ids": {"n4140": {"so_30103639_30103878_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7049}, "so_30103639_30104794_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 215}}, "n3337": {"so_30103639_30103878_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6794}, "so_30103639_30104794_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 209}}, "n4659": {"so_30103639_30103878_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 8546}, "so_30103639_30104794_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 223}}}, "30103639": {"ViewCount": "634", "Body": "<p>Why the code below does not compile?</p>\n<pre><code>template &lt;typename T&gt;\nT sum(T t){\n    return t;\n}\n\ntemplate &lt;typename T, typename ...U&gt;\nauto sum(T t, U... u) -&gt; decltype(t + sum(u...)) {\n    return t + sum(u...);\n}\n\nint main() {\n    sum(1, 1.5, 2);\n}\n</code></pre>\n<p>Compilation error:</p>\n<pre><code>error: no matching function for call to \u2018sum(int, double, int)\u2019\n sum(1, 1.5, 2);\n</code></pre>\n<p>What would be a good workaround to implement this feature?</p>\n", "AcceptedAnswerId": "30104433", "Title": "Variadic template recursive return type deduction compilation error", "CreationDate": "2015-05-07T14:11:45.140", "Id": "30103639", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-05-07T14:30:39.310", "LastEditorUserId": "4862483", "LastActivityDate": "2015-05-07T15:30:43.567", "Score": "6", "OwnerUserId": "4862483", "Tags": "<c++><c++11><variadic-templates><return-type-deduction>", "AnswerCount": "3"}, "30103878": {"Id": "30103878", "PostTypeId": "2", "Body": "<p>Quoted from [basic.scope.pdecl]:</p>\n<blockquote>\n<p id=\"so_30103639_30103878_0\">The point of declaration for a name is immediately after its complete\n  declarator (Clause 8) and before its initializer (if any)</p>\n</blockquote>\n<p>The declaration of the second function template is complete after the trailing return type <code>decltype(t + sum(u...))</code>. So, when parsing <code>decltype(t + sum(u...))</code>, the second template is not in scope yet, and the compiler can only see the first template which does not match the call.</p>\n<p>One possible fix:</p>\n<pre><code>template &lt;typename... T&gt;\nstruct ReturnType;\n\ntemplate &lt;typename T&gt;\nstruct ReturnType&lt;T&gt; {\n  typedef T Type;\n};\n\ntemplate &lt;typename T, typename... U&gt;\nstruct ReturnType&lt;T, U...&gt; {\n  typedef typename ReturnType&lt;U...&gt;::Type Type_;\n  typedef decltype(std::declval&lt;T&gt;() + std::declval&lt;Type_&gt;()) Type;\n};\n\ntemplate &lt;typename T&gt;\nT sum(T t){\n    return t;\n}\n\ntemplate &lt;typename T, typename ...U&gt;\ntypename ReturnType&lt;T, U...&gt;::Type sum(T t, U... u) {\n    return t + sum(u...);\n}\n</code></pre>\n", "LastEditorUserId": "1348273", "LastActivityDate": "2015-05-07T15:13:24.397", "Score": "2", "CreationDate": "2015-05-07T14:22:12.943", "ParentId": "30103639", "CommentCount": "10", "LastEditDate": "2015-05-07T15:13:24.397", "OwnerUserId": "1348273"}, "30104794": {"Id": "30104794", "PostTypeId": "2", "Body": "<p>In the interests of completeness, since on this version of <a href=\"https://stackoverflow.com/questions/29995642/create-n-dimensional-vector-with-given-sizes/30002714#30002714\">a similar question</a>, <a href=\"https://stackoverflow.com/a/30104433/2069064\">Yakk</a> posted the template specialization solution that I used in the other one, I will provide the ADL solution that he used there:</p>\n<pre><code>namespace N { \n    struct adl {}; \n\n    template &lt;typename A, typename T&gt;\n    T sum(A, T t){ \n        return t;\n    }   \n\n    template &lt;typename A, typename T, typename ...U&gt;\n    auto sum(A a, T t, U... u) -&gt; decltype(t + sum(a, u...)) {\n        return t + sum(a, u...);\n    }   \n}\n\ntemplate &lt;typename... Args&gt;\nauto sum(Args... args) -&gt; decltype(sum(N::adl{}, args...))\n{\n    return sum(N::adl{}, args...);\n}\n</code></pre>\n<p>The reason this works is that the <code>sum</code> used in the trailing-return-type of <code>N::sum</code> is a dependent name, and has the following lookup rules from [temp.dep.res]:</p>\n<blockquote>\n<p id=\"so_30103639_30104794_0\">In resolving dependent names, names from the following sources are considered:<br>\n  (1.1) \u2014 Declarations that are visible at the point of definition of the template.<br>\n  (1.2) \u2014 Declarations from namespaces associated with the types of the function arguments both from the\n  instantiation context (14.6.4.1) and from the definition context.</br></br></p>\n</blockquote>\n<p>Since lookup includes declarations that are visible at <em>point of definition</em> and the <em>definition context</em>, <code>N::sum</code> can find itself recursively. </p>\n<p>However, I agree with Yakk that this approach is more confusing. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-07T14:58:43.190", "Score": "3", "CreationDate": "2015-05-07T14:58:43.190", "ParentId": "30103639", "CommentCount": "1", "LastEditDate": "2017-05-23T10:33:45.623", "OwnerUserId": "2069064"}});