post_cb({"bq_ids": {"n4140": {"so_37631962_37632676_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5466}, "so_37631962_37632676_2": {"length": 41, "quality": 0.7884615384615384, "section_id": 5467}, "so_37631962_37632676_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 6036}}, "n3337": {"so_37631962_37632676_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5252}, "so_37631962_37632676_2": {"length": 41, "quality": 0.7884615384615384, "section_id": 5253}, "so_37631962_37632676_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 5804}}, "n4659": {"so_37631962_37632676_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 6900}, "so_37631962_37632676_2": {"length": 41, "quality": 0.7884615384615384, "section_id": 6901}, "so_37631962_37632676_1": {"length": 38, "quality": 0.8444444444444444, "section_id": 7535}}}, "37632676": {"Id": "37632676", "PostTypeId": "2", "Body": "<p>I think that that book is either wrong, or you have misinterpreted what it is saying about the underlying type of the enum.  The C++ 11 spec says:</p>\n<p>\u00a7 7.2</p>\n<blockquote>\n<p id=\"so_37631962_37632676_0\">6 For an enumeration whose underlying type is not fixed, the underlying type is an integral type that can\n  represent all the enumerator values defined in the enumeration. If no integral type can represent all the\n  enumerator values, the enumeration is ill-formed. It is implementation-defined which integral type is used\n  as the underlying type except that the underlying type shall not be larger than <code>int</code> unless the value of an\n  enumerator cannot fit in an <code>int</code> or <code>unsigned int</code>. If the <em>enumerator-list</em> is empty, the underlying type is\n  as if the enumeration had a single enumerator with value 0.</p>\n</blockquote>\n<p>Furthermore:</p>\n<p>\u00a7 5.2.9  </p>\n<blockquote>\n<p id=\"so_37631962_37632676_1\">10 A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is\n  unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting\n  value is unspecified (and might not be in that range). A value of floating-point type can also be converted\n  to an enumeration type. The resulting value is the same as converting the original value to the underlying\n  type of the enumeration (4.9), and subsequently to the enumeration type.</p>\n</blockquote>\n<p>I think the book might be trying to explain the following clause:</p>\n<p>\u00a7 7.2</p>\n<blockquote>\n<p id=\"so_37631962_37632676_2\">7 For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the\n  underlying type. Otherwise, for an enumeration where <em>e<sub>min</sub></em> is the smallest enumerator and <em>e<sub>max</sub></em> is the\n  largest, the values of the enumeration are the values in the range <em>b<sub>min</sub></em> to <em>b<sub>max</sub></em>, defined as follows: Let <em>K</em>\n  be 1 for a two\u2019s complement representation and 0 for a one\u2019s complement or sign-magnitude representation.\n  <em>b<sub>max</sub></em> is the smallest value greater than or equal to <em>max</em>(|<em>e<sub>min</sub></em>| \u2212 <em>K</em>, |<em>e<sub>max<sub></sub></sub></em>|) and equal to 2<sup><em>M</em></sup> \u2212 1, where\n  <em>M</em> is a non-negative integer. <em>b<sub>min</sub></em> is zero if <em>e<sub>min</sub></em> is non-negative and \u2212(<em>bmax</em></p></blockquote> + <em>K</em>) otherwise. The size of\n  the smallest bit-field large enough to hold all the values of the enumeration type is <em>max</em>(<em>M</em>, 1) if <em>bmin</em> is\n  zero and <em>M</em> + 1 otherwise. It is possible to define an enumeration that has values not defined by any of its\n  enumerators. If the <em>enumerator-list</em> is empty, the values of the enumeration are as if the enumeration had a\n  single enumerator with value 0.\n\n", "LastActivityDate": "2016-06-04T16:43:48.557", "CommentCount": "0", "CreationDate": "2016-06-04T16:43:48.557", "ParentId": "37631962", "Score": "0", "OwnerUserId": "1603365"}, "37631962": {"ViewCount": "100", "Body": "<p>Consider the code:</p>\n<pre><code>enum spect{violet,indigo,blue,green=8};\nspect band = spect (94);\n</code></pre>\n<p>According to the rule of limits in enumeration, the upper limit would be 2^4-1=15 and the lower would be 0 (Ref : C++ Primer Plus book).</p>\n<p>But<code>94&gt;15</code> so it should give a warning or error. But my program is running fine. Why?</p>\n", "AcceptedAnswerId": "37632676", "Title": "Why initializing enumeration variable out of range do not give me a warning or error?", "CreationDate": "2016-06-04T15:31:02.403", "Id": "37631962", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2016-06-04T16:43:48.557", "Score": "-1", "OwnerUserId": "4514288", "Tags": "<c++><enumeration>", "AnswerCount": "1"}});