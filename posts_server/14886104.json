post_cb({"14886104": {"CommentCount": "5", "ViewCount": "102", "PostTypeId": "1", "ClosedDate": "2013-02-15T13:59:52.580", "LastEditorUserId": "508343", "CreationDate": "2013-02-14T23:45:16.210", "LastActivityDate": "2013-02-15T00:12:34.883", "Title": "Why does VC++ 2012 not support specifying the default value of members of a class in its definition?", "AcceptedAnswerId": "14886228", "LastEditDate": "2013-02-15T00:12:34.883", "Id": "14886104", "Score": "-1", "Body": "<pre><code>struct A\n{\n    int a = 8; // VC++ 2012 rejects this.\n};\n</code></pre>\n<p>I think the code above is more convenient and more expressive than the legal code as follows:</p>\n<pre><code>struct A\n{\n    A();\n\n    int a;\n};\n\nA::A()\n    : a(8)\n{}\n</code></pre>\n<p>I believe one of the strongest motivations to add new features into the C++ language is making C++ more expressive.</p>\n<p>I just wonder why VC++ 2012 not support this?</p>\n", "Tags": "<c++><class><struct><initialization><default>", "OwnerUserId": "508343", "AnswerCount": "2"}, "14886228": {"ParentId": "14886104", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++11 supports <code>Default Member Initialization</code>.</p>\n<p><strong>\u00a7 12.6.2</strong> </p>\n<blockquote>\n<p id=\"so_14886104_14886228_0\">9 If a given non-static data member has both a\n  brace-or-equal-initializer and a mem-initializer, the initialization\n  specified by the mem-initializer is performed, and the non-static data\n  member\u2019s brace-or-equal-initializer is ignored. [ Example: Given</p>\n</blockquote>\n<pre><code>struct A {\n  int i = /* some integer expression with side effects */ ;\n  A(int arg) : i(arg) { }\n  // ...\n};\n</code></pre>\n<blockquote>\n<p id=\"so_14886104_14886228_1\">the A(int) constructor will simply initialize i to the value of arg,\n  and the side effects in i\u2019s brace-or-equalinitializer will not take\n  place. \u2014end example ]</p>\n</blockquote>\n<p>You could initialize member by:</p>\n<pre><code>struct A\n{\n    int a = 8; \n    int b{3}; // OR\n};\n</code></pre>\n<p>If you define constructor to initialize <code>a,b</code>, constructor initializer lists override defaults.</p>\n<p><code>I just wonder why VC++ 2012 not support this?</code></p>\n<p>VS2012 hasn't implemented it yet.</p>\n", "OwnerUserId": "951757", "LastEditorUserId": "951757", "LastEditDate": "2013-02-15T00:06:14.220", "Id": "14886228", "Score": "2", "CreationDate": "2013-02-14T23:56:27.890", "LastActivityDate": "2013-02-15T00:06:14.220"}, "bq_ids": {"n4140": {"so_14886104_14886228_0": {"section_id": 436, "quality": 0.9444444444444444, "length": 17}, "so_14886104_14886228_1": {"section_id": 436, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_14886104_14886228_0": {"section_id": 428, "quality": 0.9444444444444444, "length": 17}, "so_14886104_14886228_1": {"section_id": 428, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_14886104_14886228_0": {"section_id": 455, "quality": 0.8333333333333334, "length": 15}, "so_14886104_14886228_1": {"section_id": 455, "quality": 0.8, "length": 12}}}, "14886108": {"ParentId": "14886104", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><strong>Edit</strong> this answers the original question, \"why does C++ not support ...\"</p>\n<p>Actually, since C++11, initialization of non-static data members at the point of declaration is supported:</p>\n<pre><code>struct A\n{\n    int a = 8; // perfectly legal C++\n};\n\n#include &lt;iostream&gt;\nint main()\n{\n  A a1;\n  std::cout &lt;&lt; a1.a &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Output: 8.</p>\n<p>This initializes data member <code>A::a</code> to 8, and has the implication that <code>A</code> is no longer an aggregate, but it wouldn't be one with the user provided constructor either.</p>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2013-02-14T23:52:11.357", "Id": "14886108", "Score": "2", "CreationDate": "2013-02-14T23:45:53.030", "LastActivityDate": "2013-02-14T23:52:11.357"}});