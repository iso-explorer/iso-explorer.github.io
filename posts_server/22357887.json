post_cb({"22360283": {"ParentId": "22357887", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I think I found it after trying to reduce the error. First, the comparison doesn't seem required to make the program ill-formed. Then, the error message contained the dtor, so I tried not to instantiate the dtor. Result:</p>\n<pre><code>#include &lt;map&gt;\n\nstruct A {\n    A(A&amp; ); // &lt;-- const missing\n};\n\nint main() {\n    std::map&lt;int, A&gt;* m = new std::map&lt;int, A&gt;();\n    // note: dtor not (necessarily?) instantiated\n}\n</code></pre>\n<p>But the output message still contains, now for the line where the ctor of <code>m</code> is called:</p>\n<blockquote>\n<p id=\"so_22357887_22360283_0\">error: the parameter for this explicitly-defaulted copy constructor is const, but a member or base requires it to be non-const</p>\n<pre><code> constexpr pair(const pair&amp;) = default;\n</code></pre>\n</blockquote>\n<p>Which hints to [dcl.fct.def.default]/4</p>\n<blockquote>\n<p id=\"so_22357887_22360283_1\">A user-provided explicitly-defaulted function (i.e., explicitly defaulted after its\n  first declaration) is defined at the point where it is explicitly defaulted; <strong>if such a function is implicitly defined as deleted, the program is ill-formed</strong>.</p>\n</blockquote>\n<p>[emphasis mine]</p>\n<p>If, as I assume, [class.copy]/11 says that this ctor <em>should be</em> defined as deleted, then it is defined as deleted immediately - not only when it's odr-used. Therefore, an instantiation shouldn't be required to make the program ill-formed.</p>\n", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2014-03-12T18:29:14.997", "Id": "22360283", "Score": "2", "CreationDate": "2014-03-12T18:12:25.047", "LastActivityDate": "2014-03-12T18:29:14.997"}, "22359998": {"ParentId": "22357887", "CommentCount": "12", "Body": "<p>The copy constructor of <code>std::pair</code> isn't <em>needed</em> in this case, but because it is default defined inline in the declaration of <code>std::pair</code>, it is automatically instantiated along with the instantiation of <code>std::pair</code> itself.</p>\n<p>It would be possible for the standard library to provide a non-inline default definition of the copy constructor:</p>\n<pre><code>template&lt;class _T1, class _T2&gt;\n  struct pair\n  {\n// ...\n    constexpr pair(const pair&amp;);\n// ...\n  };\n// ...\ntemplate&lt;class _T1, class _T2&gt;\nconstexpr pair&lt;_T1, _T2&gt;::pair(const pair&amp;) = default;\n</code></pre>\n<p>However this would not accord with the strict letter of the standard (clause 20.3.2), where the copy constructor is default defined inline:</p>\n<blockquote id=\"so_22357887_22359998_0\">\n<pre><code>  constexpr pair(const pair&amp;) = default;\n</code></pre>\n</blockquote>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "22359998", "Score": "3", "CreationDate": "2014-03-12T17:58:38.050", "LastActivityDate": "2014-03-12T17:58:38.050"}, "22357887": {"CommentCount": "6", "AcceptedAnswerId": "22359998", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-03-12T16:29:19.930", "LastActivityDate": "2014-04-16T14:46:31.407", "LastEditDate": "2017-05-23T12:34:17.993", "ViewCount": "2221", "FavoriteCount": "6", "Title": "Comparing two map::iterators: why does it need the copy constructor of std::pair?", "Id": "22357887", "Score": "17", "Body": "<p>The very simple code below compiles and links without a warning in C++98 but gives an incomprehensible compile error in C++11 mode.</p>\n<pre><code>#include &lt;map&gt;\n\nstruct A {\n    A(A&amp; ); // &lt;-- const missing\n};\n\nint main() {\n    std::map&lt;int, A&gt; m;\n    return m.begin() == m.end(); // line 9\n}\n</code></pre>\n<p>The error with <code>-std=c++11</code> is, gcc version 4.9.0 20140302 (experimental) (GCC):</p>\n<pre>\n\nali@X230:~/tmp$ ~/gcc/install/bin/g++ -std=c++11 cctor.cpp \nIn file included from /home/ali/gcc/install/include/c++/4.9.0/bits/stl_algobase.h:64:0,\n                 from /home/ali/gcc/install/include/c++/4.9.0/bits/stl_tree.h:61,\n                 from /home/ali/gcc/install/include/c++/4.9.0/map:60,\n                 from cctor.cpp:1:\n/home/ali/gcc/install/include/c++/4.9.0/bits/stl_pair.h: In instantiation of \u2018struct std::pair\u2019:\ncctor.cpp:9:31:   required from here\n/home/ali/gcc/install/include/c++/4.9.0/bits/stl_pair.h:127:17: error: \u2018constexpr std::pair::pair(const std::pair&amp;) [with _T1 = const int; _T2 = A]\u2019 declared to take const reference, but implicit declaration would take non-const\n       constexpr pair(const pair&amp;) = default;\n                 ^\n</pre>\n<p>with clang version 3.5 (trunk 202594)</p>\n<pre>\nali@X230:~/tmp$ clang++ -Weverything -std=c++11 cctor.cpp \nIn file included from cctor.cpp:1:\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/4.7/../../../../include/c++/4.7/map:60:\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/4.7/../../../../include/c++/4.7/bits/stl_tree.h:63:\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/4.7/../../../../include/c++/4.7/bits/stl_algobase.h:65:\n/usr/lib/gcc/x86_64-linux-gnu/4.7/../../../../include/c++/4.7/bits/stl_pair.h:119:17: error: the parameter for this explicitly-defaulted copy constructor is const, but\n      a member or base requires it to be non-const\n      constexpr pair(const pair&amp;) = default;\n                ^\ncctor.cpp:9:22: note: in instantiation of template class 'std::pair' requested here\n    return m.begin() == m.end(); // line 9\n                     ^\n1 error generated.\n</pre>\n<p>I have been looking at the code in <code>bits/stl_tree.h</code> and I don't understand why it is trying to instantiate <code>std::pair</code>. </p>\n<p><strong>Why does it need the copy constructor of <code>std::pair</code> in C++11?</strong> </p>\n<hr>\n<p><sub>Note: the above code was extracted from <a href=\"https://stackoverflow.com/q/22341818/341970\">Equality operator (==) unsupported on map iterators for non-copyable maps</a>.</sub></p>\n<hr>\n<p><strong>SOLUTION</strong></p>\n<p>There are two unfortunate issues here.</p>\n<p>Poor quality error messages: Line 8 should already give a compile error although the error messages are only complaining about line 9 . Getting an error on line 8 would be quite helpful and understanding the real problem would be much easier. I will probably submit a bug report / feature request if this issue is still present in gcc / clang trunk.</p>\n<p>The other issue is what <a href=\"https://stackoverflow.com/a/22359998/341970\">ecatmur</a> writes. Consider the following code:  </p>\n<pre><code>struct A {\n    A() = default;\n    A(A&amp; ); // &lt;-- const missing\n};\n\ntemplate&lt;class T&gt;\nstruct B {\n    B() = default;\n    B(const B&amp; ) = default;\n    T t;\n};\n\nint main() {\n  B&lt;A&gt; b;  \n}\n</code></pre>\n<p>It fails to compile. Even though the copy constructor is not needed anywhere, it is still instantiated because it is defaulted inline, in the body of the class; this leads to the compile error. This can be fixed by moving the copy constructor out of the body of the class:</p>\n<pre><code>template&lt;class T&gt;\nstruct B {\n    B() = default;\n    B(const B&amp; );\n    T t;\n};\n\ntemplate &lt;class T&gt;\nB&lt;T&gt;::B(const B&amp; ) = default;\n</code></pre>\n<p>Everything is OK then. Unfortunately, <code>std::pair</code> has a default defined inline copy constructor.</p>\n</hr></hr>", "Tags": "<c++><gcc><c++11><clang><std-pair>", "OwnerUserId": "341970", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_22357887_22360283_1": {"section_id": 3274, "quality": 1.0, "length": 20}}, "n3337": {"so_22357887_22360283_1": {"section_id": 3145, "quality": 1.0, "length": 20}}, "n4659": {"so_22357887_22360283_1": {"section_id": 4032, "quality": 1.0, "length": 20}}}, "22358674": {"ParentId": "22357887", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><code>std::map</code> uses <code>std::pair</code> to store key-value pairs, where the key (the first element) is <code>const</code>.</p>\n<p>The compiler error relates to the required copy constructor for <code>std::pair</code>, even if it isn't being used (which I don't think it is).</p>\n<p><code>std::pair&lt;int, A&gt;</code> has to be generated. This is first required with the call to map::begin.\nSince no explicit copy constructor is given for this type, the implicit one used.</p>\n<p>The implicit constructor will have signature T::T(const T&amp;) <em>only if</em> all non-static members of T, (type S), have copy constructors S::S(const S&amp;) (the same requirement has to hold for T's base types copy constructors).\nOtherwise a copy constructor with signature T::T(T&amp;) is used instead.</p>\n<p>A's copy constructor fails this requirement, so std::pair::pair has the wrong signature for the STL, which requires T::T(const T&amp;).</p>\n", "OwnerUserId": "2464207", "LastEditorUserId": "2464207", "LastEditDate": "2014-03-12T17:52:45.377", "Id": "22358674", "Score": "0", "CreationDate": "2014-03-12T16:59:49.963", "LastActivityDate": "2014-03-12T17:52:45.377"}});