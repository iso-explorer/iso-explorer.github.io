post_cb({"bq_ids": {"n4140": {"so_24048701_24088981_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6043}, "so_24048701_24088981_2": {"length": 10, "quality": 1.0, "section_id": 5768}}, "n3337": {"so_24048701_24088981_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5811}, "so_24048701_24088981_2": {"length": 10, "quality": 1.0, "section_id": 5541}}, "n4659": {"so_24048701_24088981_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7542}, "so_24048701_24088981_2": {"length": 10, "quality": 1.0, "section_id": 7225}}}, "24088981": {"Id": "24088981", "PostTypeId": "2", "Body": "<p>If you have a C++11-compliant compiler, then its documentation tells you.</p>\n<p>As already mentioned by Igor in the comments, the rules for <code>reinterpret_cast</code> include:</p>\n<blockquote>\n<p id=\"so_24048701_24088981_0\">A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is <em>implementation-defined</em>.</p>\n</blockquote>\n<p>That term doesn't just mean \"non-portable\", it adds specific requirements, found in 1.3.10:</p>\n<blockquote>\n<p id=\"so_24048701_24088981_1\">implementation-defied behavior</p>\n<p id=\"so_24048701_24088981_2\">behavior, for a well-formed program construct and correct data, that depends on the implementation and\n  that each implementation documents</p>\n</blockquote>\n<p>If your compiler does not document whether a pointer converted to integer is actually a memory address, then it is not a C++ compiler.</p>\n", "LastActivityDate": "2014-06-06T19:07:01.467", "CommentCount": "1", "CreationDate": "2014-06-06T19:07:01.467", "ParentId": "24048701", "Score": "3", "OwnerUserId": "103167"}, "24048701": {"ViewCount": "287", "Body": "<p>Is there a C++11 standards compliant (or if not compliant, at least generally acceptable) way to determine if an address is aligned with a cache line boundary?</p>\n<p>E.g. something like this:</p>\n<pre><code>T* p = SOMETHING;\nbool aligned = reinterpret_cast&lt; std::uintptr_t &gt; (p) % CACHE_LINE_SIZE == 0;\n</code></pre>\n", "AcceptedAnswerId": "24088981", "Title": "how to determine if an address is cache aligned?", "CreationDate": "2014-06-04T22:32:41.913", "Id": "24048701", "CommentCount": "16", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-06-06T19:36:30.990", "LastEditorUserId": "683918", "LastActivityDate": "2014-06-07T02:50:43.300", "Score": "8", "OwnerUserId": "683918", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "24088890": {"Id": "24088890", "PostTypeId": "2", "Body": "<p>There's a <code>std::align</code> function but it's apparently not much in demand: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57350\" rel=\"nofollow noreferrer\">it's missing in gcc 4.9<strike> and badly bugged in MSVC</strike></a>.</p>\n<p>The proposed implementation of it (it's short enough to just read) is </p>\n<pre><code>inline void *align( std::size_t alignment, std::size_t size,\n                    void *&amp;ptr, std::size_t &amp;space ) {\n    std::uintptr_t pn = reinterpret_cast&lt; std::uintptr_t &gt;( ptr );\n    std::uintptr_t aligned = ( pn + alignment - 1 ) &amp; - alignment;\n    std::size_t padding = aligned - pn;\n    if ( space &lt; size + padding ) return nullptr;\n    space -= padding;\n    return ptr = reinterpret_cast&lt; void * &gt;( aligned );\n}\n</code></pre>\n<p>... a bit overkill here because to simply test for an already-aligned pointer it boils down to your method exactly (with bitbashing not %, but no matter).  Its implementation is, <a href=\"https://stackoverflow.com/users/1670129/igor-tandetnik\">as @IgorTandetnik points out</a>, \"unsurprising to those who know the addressing structure of the underlying machine\"</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-07T02:50:43.300", "Score": "3", "CreationDate": "2014-06-06T19:00:32.817", "ParentId": "24048701", "CommentCount": "0", "OwnerUserId": "1290731", "LastEditDate": "2017-05-23T12:07:22.943"}});