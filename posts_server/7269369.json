post_cb({"7269423": {"ParentId": "7269369", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If A is a byte then struct will align to the nearest boundary. Rather if A is smaller than a boundary then yes it will be bigger. EX a struct of RGB is the same size as a struct of RGBA.</p>\n<p>I don't have sample code that will do that. You have to dump memory and see the holes. If you then assume that everything is size aligned and cast a structure onto a wad of memory you will have bad data. This is why WADs had padding for alignment. As your compositions get more complicated, the ability to close holes by the compiler is diminished. Eventually padding will be introduced and any assumptions of memory layout will become more and more wrong.</p>\n", "OwnerUserId": "664328", "LastEditorUserId": "664328", "LastEditDate": "2011-09-01T11:47:51.450", "Id": "7269423", "Score": "0", "CreationDate": "2011-09-01T11:06:24.620", "LastActivityDate": "2011-09-01T11:47:51.450"}, "7269448": {"ParentId": "7269369", "CommentCount": "2", "Body": "<p>Being able to use A inside of S means that the compiler already has knowledge of the structure of A and has already added padding bytes to it. I see no reason for it to add further padding to S, as it already is aligned.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "7269448", "Score": "5", "CreationDate": "2011-09-01T11:08:19.270", "LastActivityDate": "2011-09-01T11:08:19.270"}, "7269516": {"ParentId": "7269369", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>While the struct can be padded, on all systems I know, the compiler will pad so that the alignment of the structure is the same as the largest alignment of its members.  It does this so that an array of the structure will always be correctly aligned. </p>\n<p>So:</p>\n<pre><code>struct S \n{\n   char a;\n} // Size 1, no padding\n\nstruct S2 \n{\n   unsigned int a;\n   char b;\n} // Size 8, 3 bytes padding (assuming 32 bit integer)\n</code></pre>\n<p>Edit:  Note, that compilers can also add internal padding, to keep the alignment of the data correct.</p>\n<p>The C/C++ standard doesn't specify any of these detail.  What you want is the C ABI (application binary interface) for the system you're running on, which should specify default layout for structs (compilers can choose to override this if they see fit, see also #pragma pack).  For an example, look at the <a href=\"http://x86-64.org/documentation/abi.pdf\" rel=\"nofollow\">X86_64 ABI</a> page 13, which states:</p>\n<blockquote>\n<p id=\"so_7269369_7269516_0\">Aggregates and Unions Structures and unions assume the alignment of\n  their most strictly aligned compo- nent. Each member is assigned to\n  the lowest available offset with the appropriate alignment. The size\n  of any object is always a multiple of the object\u2018s alignment. An array\n  uses the same alignment as its elements, except that a local or global\n  array variable of length at least 16 bytes or a C99 variable-length\n  array variable always has alignment of at least 16 bytes. Structure\n  and union objects can require padding to meet size and alignment\n  constraints. The contents of any padding is unde\ufb01ned.</p>\n</blockquote>\n", "OwnerUserId": "862231", "LastEditorUserId": "862231", "LastEditDate": "2011-09-01T11:27:00.100", "Id": "7269516", "Score": "3", "CreationDate": "2011-09-01T11:15:33.880", "LastActivityDate": "2011-09-01T11:27:00.100"}, "7269874": {"ParentId": "7269369", "CommentCount": "0", "Body": "<p>The relevant text is 5.3.3/2 \"When applied to a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array.\"</p>\n<p>An implementation is allowed to add extra bytes for the purposes of array bound checks (e.g. <code>\"this is the 5th array member out of a total of 12\"</code>, as this is within the leeway granted here and not explicitly banned by any other requirement.</p>\n<p>(Presumably, that implementation would also store a \"1 out of 1\" indication for structs that aren't part of an array; in C++ the types <code>S</code> and <code>S[1]</code> are quite interchangable)</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "7269874", "Score": "2", "CreationDate": "2011-09-01T11:51:42.710", "LastActivityDate": "2011-09-01T11:51:42.710"}, "7269459": {"ParentId": "7269369", "CommentCount": "5", "Body": "<p>A struct <em>can</em> be padded (it's allowed for compilers do whatever they like, for example padding a six-octet type to eight to align with page boundaries). It's unlikely to happen though.</p>\n<p><del>std::array <em>will</em> be bigger, because it stores some extra information in the class, like the array's length.</del> Typing on auto-pilot; read std::vector without thinking.</p>\n", "OwnerUserId": "314722", "PostTypeId": "2", "Id": "7269459", "Score": "0", "CreationDate": "2011-09-01T11:08:56.620", "LastActivityDate": "2011-09-01T11:08:56.620"}, "7269793": {"ParentId": "7269369", "CommentCount": "5", "Body": "<p><strong>ISO/IEC 14882(10/2008) 1.8.5</strong>:</p>\n<blockquote>\n<p id=\"so_7269369_7269793_0\">Unless it is a bit-field (9.6), a most derived object shall have a non-zero size and shall occupy one or more\n  bytes of storage. Base class subobjects may have zero size.</p>\n</blockquote>\n<p>This means that an <em>empty</em> struct has a size of 1 although the size of \"all data members\" (there are none) is zero, as would a zero-length bitfield (according to 9.6.2 this would have to be an <em>unnamed</em> bitfield, though).<br>\nNeither really applies though, as you did not ask for an empty struct, and your member <em>is</em> named (so it can't be zero-length).</br></p>\n<p>Similar would be true if your <code>a</code> member was of type <code>void</code>, but <strong>3.9.5</strong> does not allow that (<em>\"[...] the void types are incomplete types (3.9.1). Objects shall not be defined to have an incomplete type\"</em>).</p>\n<p>So in short, as you said you are mostly interested about what the standard says: no, the standard does not explicitly define such a case.</p>\n<p>However, it <em>also does not forbid</em> the compiler to add padding or apply alignment, and most compilers will pad/align structures to machine word size by default (unless explicitly told otherwise).</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "7269793", "Score": "1", "CreationDate": "2011-09-01T11:43:37.063", "LastActivityDate": "2011-09-01T11:43:37.063"}, "7269369": {"CommentCount": "17", "AcceptedAnswerId": "7269516", "PostTypeId": "1", "ClosedDate": "2011-09-01T13:19:16.877", "LastEditorUserId": "-1", "CreationDate": "2011-09-01T11:01:08.833", "LastActivityDate": "2011-09-01T11:51:42.710", "LastEditDate": "2017-05-23T12:29:09.130", "ViewCount": "298", "FavoriteCount": "2", "Title": "Can wrapping a type in a struct cause additional padding?", "Id": "7269369", "Score": "12", "Body": "<blockquote>\n<p id=\"so_7269369_7269369_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/3585033/size-of-struct-with-a-single-element\">Size of struct with a single element</a> </br></p>\n</blockquote>\n<p>Given any type <code>A</code> and the following struct:</p>\n<pre><code>struct S\n{\n    A a;\n};\n</code></pre>\n<p>Are there any cases where <code>sizeof(S)</code> is greater than <code>sizeof(A)</code>?</p>\n<p>For example, can <code>sizeof(std::array&lt;T, n&gt;)</code> be greater than <code>sizeof(T[n])</code>?</p>\n", "Tags": "<c++><arrays><class><struct><padding>", "OwnerUserId": "252000", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_7269369_7269793_0": {"section_id": 5794, "quality": 0.95, "length": 19}}, "n3337": {"so_7269369_7269793_0": {"section_id": 5567, "quality": 0.95, "length": 19}}, "n4659": {"so_7269369_7269793_0": {"section_id": 7253, "quality": 0.95, "length": 19}}}});