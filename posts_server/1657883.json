post_cb({"1657883": {"ViewCount": "207541", "Body": "<p>How can I write a function that accepts a variable number of arguments? Is this possible, how?</p>\n", "AcceptedAnswerId": "1657924", "Title": "Variable number of arguments in C++?", "CreationDate": "2009-11-01T18:25:01.853", "Id": "1657883", "CommentCount": "5", "FavoriteCount": "70", "PostTypeId": "1", "LastEditDate": "2013-04-02T17:25:27.730", "LastEditorUserId": "161746", "LastActivityDate": "2017-10-26T10:27:40.443", "Score": "165", "OwnerUserId": "161746", "Tags": "<c++><variadic-functions>", "AnswerCount": "13"}, "1658104": {"Id": "1658104", "PostTypeId": "2", "Body": "<p>In C++11 there is a way to do variable argument templates which lead to a really elegant and type safe way to have variable argument functions.  Bjarne himself gives a nice example of <a href=\"http://www.stroustrup.com/C++11FAQ.html#variadic-templates\" rel=\"noreferrer\">printf using variable argument templates</a> in the <a href=\"http://www.stroustrup.com/C++11FAQ.html\" rel=\"noreferrer\">C++11FAQ</a>.</p>\n<p>Personally, I consider this so elegant that I wouldn't even bother with a variable argument function in C++ until that compiler has support for C++11 variable argument templates.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-04-22T20:20:17.753", "Score": "14", "CreationDate": "2009-11-01T19:39:21.983", "ParentId": "1657883", "CommentCount": "0", "OwnerUserId": "167958", "LastEditDate": "2014-04-22T20:20:17.753"}, "1657924": {"Id": "1657924", "PostTypeId": "2", "Body": "<p>You probably shouldn't, and you can probably do what you want to do in a safer  and simpler way.  Technically to use variable number of arguments in C you include stdarg.h.  From that you'll get the <code>va_list</code> type as well as three functions that operate on it called <code>va_start()</code>, <code>va_arg()</code> and <code>va_end()</code>.</p>\n<pre><code>#include&lt;stdarg.h&gt;\n\nint maxof(int n_args, ...)\n{\n    va_list ap;\n    va_start(ap, n_args);\n    int max = va_arg(ap, int);\n    for(int i = 2; i &lt;= n_args; i++) {\n        int a = va_arg(ap, int);\n        if(a &gt; max) max = a;\n    }\n    va_end(ap);\n    return max;\n}\n</code></pre>\n<p>If you ask me, this is a mess.  It looks bad, it's unsafe, and it's full of technical details that have nothing to do with what you're conceptually trying to achieve.  Instead, consider using overloading or inheritance/polymorphism, builder pattern (as in <code>operator&lt;&lt;()</code> in streams) or default arguments etc.  These are all safer:  the compiler gets to know more about what you're trying to do so there are more occasions it can stop you before you blow your leg off.</p>\n", "LastEditorUserId": "456", "LastActivityDate": "2009-11-01T18:47:22.853", "Score": "101", "CreationDate": "2009-11-01T18:38:42.527", "ParentId": "1657883", "CommentCount": "10", "OwnerUserId": "456", "LastEditDate": "2009-11-01T18:47:22.853"}, "bq_ids": {"n4140": {"so_1657883_16338804_1": {"length": 39, "quality": 0.8478260869565217, "section_id": 5994}}, "n3337": {"so_1657883_16338804_1": {"length": 39, "quality": 0.8478260869565217, "section_id": 5762}}, "n4659": {"so_1657883_16338804_1": {"length": 39, "quality": 0.8478260869565217, "section_id": 7496}}}, "46951986": {"Id": "46951986", "PostTypeId": "2", "Body": "<pre><code>int fun(int n_args, ...) {\n   int *p = &amp;n_args; \n   int s = sizeof(int);\n   p += s + s - 1;\n   for(int i = 0; i &lt; n_args; i++) {\n     printf(\"A1 %d!\\n\", *p);\n     p += 2;\n   }\n}\n</code></pre>\n<p>Plain version</p>\n", "LastActivityDate": "2017-10-26T10:27:40.443", "CommentCount": "0", "CreationDate": "2017-10-26T10:27:40.443", "ParentId": "1657883", "Score": "0", "OwnerUserId": "4242614"}, "1657886": {"Id": "1657886", "PostTypeId": "2", "Body": "<p>The only way is through the use of C style variable arguments, as described <a href=\"http://publications.gbdirect.co.uk/c_book/chapter9/stdarg.html\" rel=\"noreferrer\">here</a>. Note that this is not a recommended practice, as it's not typesafe and error-prone.</p>\n", "LastActivityDate": "2009-11-01T18:27:32.113", "CommentCount": "2", "CreationDate": "2009-11-01T18:27:32.113", "ParentId": "1657883", "Score": "9", "OwnerUserId": "455874"}, "1658004": {"Id": "1658004", "PostTypeId": "2", "Body": "<p>If you know the range of number of arguments that will be provided, you can always use some function overloading, like</p>\n<pre><code>f(int a)\n    {int res=a; return res;}\nf(int a, int b)\n    {int res=a+b; return res;}\n</code></pre>\n<p>and so on...</p>\n", "LastActivityDate": "2009-11-01T19:03:39.840", "CommentCount": "0", "CreationDate": "2009-11-01T19:03:39.840", "ParentId": "1657883", "Score": "2", "OwnerUserId": "87557"}, "14634882": {"Id": "14634882", "PostTypeId": "2", "Body": "<p>We could also use an initializer_list if all arguments are const and of the same type</p>\n", "LastActivityDate": "2013-01-31T20:49:30.963", "CommentCount": "1", "CreationDate": "2013-01-31T20:49:30.963", "ParentId": "1657883", "Score": "-1", "OwnerUserId": "1269870"}, "1657896": {"Id": "1657896", "PostTypeId": "2", "Body": "<p>C-style variadic functions are supported in C++.</p>\n<p>However, most C++ libraries use an alternative idiom e.g. whereas the <code>'c' printf</code> function takes variable arguments the <code>c++ cout</code> object uses <code>&lt;&lt;</code> overloading which addresses type safety and ADTs (perhaps at the cost of implementation simplicity).</p>\n", "LastEditorUserId": "15721", "LastActivityDate": "2009-11-01T18:46:50.873", "Score": "16", "CreationDate": "2009-11-01T18:31:21.807", "ParentId": "1657883", "CommentCount": "0", "OwnerUserId": "15721", "LastEditDate": "2009-11-01T18:46:50.873"}, "1658054": {"Id": "1658054", "PostTypeId": "2", "Body": "<p>Apart from varargs or overloading, you could consider to aggregate your arguments in a std::vector or other containers (std::map for example). Something like this:</p>\n<pre><code>template &lt;typename T&gt; void f(std::vector&lt;T&gt; const&amp;);\nstd::vector&lt;int&gt; my_args;\nmy_args.push_back(1);\nmy_args.push_back(2);\nf(my_args);\n</code></pre>\n<p>In this way you would gain type safety and the logical meaning of these variadic arguments would be apparent.</p>\n<p>Surely this approach can have performance issues but you should not worry about them unless you are sure that you cannot pay the price. It is a sort of a a \"Pythonic\" approach to c++ ...</p>\n", "LastActivityDate": "2009-11-01T19:20:39.323", "CommentCount": "2", "CreationDate": "2009-11-01T19:20:39.323", "ParentId": "1657883", "Score": "13", "OwnerUserId": "159684"}, "1658125": {"Id": "1658125", "PostTypeId": "2", "Body": "<p>It's possible you want overloading or default parameters - define the same function with defaulted parameters:</p>\n<pre><code>void doStuff( int a, double termstator = 1.0, bool useFlag = true )\n{\n   // stuff\n}\n\nvoid doStuff( double std_termstator )\n{\n   // assume the user always wants '1' for the a param\n   return doStuff( 1, std_termstator );\n}\n</code></pre>\n<p>This will allow you to call the method with one of four different calls:</p>\n<pre><code>doStuff( 1 );\ndoStuff( 2, 2.5 );\ndoStuff( 1, 1.0, false );\ndoStuff( 6.72 );\n</code></pre>\n<p>...  or you could be looking for the v_args calling conventions from C.</p>\n", "LastActivityDate": "2009-11-01T19:44:34.250", "CommentCount": "0", "CreationDate": "2009-11-01T19:44:34.250", "ParentId": "1657883", "Score": "4", "OwnerUserId": "15852"}, "1657930": {"Id": "1657930", "PostTypeId": "2", "Body": "<p>There is no standard C++ way to do this without resorting to C-style varargs (<code>...</code>).</p>\n<p>There are of course default arguments that sort of \"look\" like variable number of arguments depending on the context:</p>\n<pre><code>void myfunc( int i = 0, int j = 1, int k = 2 );\n\n// other code...\n\nmyfunc();\nmyfunc( 2 );\nmyfunc( 2, 1 );\nmyfunc( 2, 1, 0 );\n</code></pre>\n<p>All four function calls call <code>myfunc</code> with varying number of arguments. If none are given, the default arguments are used. Note however, that you can only omit trailing arguments. There is no way, for example to omit <code>i</code> and give only <code>j</code>.</p>\n", "LastActivityDate": "2009-11-01T18:40:10.590", "CommentCount": "0", "CreationDate": "2009-11-01T18:40:10.590", "ParentId": "1657883", "Score": "9", "OwnerUserId": "1181406"}, "16338804": {"Id": "16338804", "PostTypeId": "2", "Body": "<p>In <em>C++11</em> you have two new options, as the <a href=\"http://en.cppreference.com/w/cpp/utility/variadic\" rel=\"noreferrer\">Variadic functions</a> reference page in the <em>Alternatives section</em> states:</p>\n<blockquote id=\"so_1657883_16338804_0\">\n<ul>\n<li>Variadic templates can also be used to create functions that take variable number of \n  arguments. They are often the better choice because they do not impose restrictions on\n  the types of the arguments, do not perform integral and floating-point promotions, and\n  are type safe. (since C++11)</li>\n<li>If all variable arguments share a common type, a std::initializer_list provides a \n  convenient mechanism (albeit with a different syntax) for accessing variable arguments. </li>\n</ul>\n</blockquote>\n<p>Below is an example showing both alternatives (<em><a href=\"http://coliru.stacked-crooked.com/a/84c7739d7d7e03cc\" rel=\"noreferrer\">see it live</a></em>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;initializer_list&gt;\n\ntemplate &lt;typename T&gt;\nvoid func(T t) \n{\n    std::cout &lt;&lt; t &lt;&lt; std::endl ;\n}\n\ntemplate&lt;typename T, typename... Args&gt;\nvoid func(T t, Args... args) // recursive variadic function\n{\n    std::cout &lt;&lt; t &lt;&lt;std::endl ;\n\n    func(args...) ;\n}\n\ntemplate &lt;class T&gt;\nvoid func2( std::initializer_list&lt;T&gt; list )\n{\n    for( auto elem : list )\n    {\n        std::cout &lt;&lt; elem &lt;&lt; std::endl ;\n    }\n}\n\nint main()\n{\n    std::string\n        str1( \"Hello\" ),\n        str2( \"world\" );\n\n    func(1,2.5,'a',str1);\n\n    func2( {10, 20, 30, 40 }) ;\n    func2( {str1, str2 } ) ;\n} \n</code></pre>\n<p>If you are using <code>gcc</code> or <code>clang</code> we can use the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html\" rel=\"noreferrer\"><strong>PRETTY_FUNCTION</strong> <em>magic variable</em></a> to display the type signature of the function which can be helpful in understanding what is going on. For example using:</p>\n<pre><code>std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \": \" &lt;&lt; t &lt;&lt;std::endl ;\n</code></pre>\n<p>would results int following for variadic functions in the example (<em><a href=\"http://coliru.stacked-crooked.com/a/99bdcbc93e48c922\" rel=\"noreferrer\">see it live</a></em>):</p>\n<pre><code>void func(T, Args...) [T = int, Args = &lt;double, char, std::basic_string&lt;char&gt;&gt;]: 1\nvoid func(T, Args...) [T = double, Args = &lt;char, std::basic_string&lt;char&gt;&gt;]: 2.5\nvoid func(T, Args...) [T = char, Args = &lt;std::basic_string&lt;char&gt;&gt;]: a\nvoid func(T) [T = std::basic_string&lt;char&gt;]: Hello\n</code></pre>\n<p>In Visual Studio you can use <a href=\"https://msdn.microsoft.com/en-us/library/b0084kay.aspx\" rel=\"noreferrer\"><strong>FUNCSIG</strong></a>.</p>\n<p><b>Update Pre C++11</b></p>\n<p>Pre <em>C++11</em> the alternative for <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"noreferrer\">std::initializer_list</a> would be <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"noreferrer\">std::vector</a> or one of the other <a href=\"http://en.cppreference.com/w/cpp/container\" rel=\"noreferrer\">standard containers</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;class T&gt;\nvoid func1( std::vector&lt;T&gt; vec )\n{\n    for( typename std::vector&lt;T&gt;::iterator iter = vec.begin();  iter != vec.end(); ++iter )\n    {\n        std::cout &lt;&lt; *iter &lt;&lt; std::endl ;\n    }\n}\n\nint main()\n{\n    int arr1[] = {10, 20, 30, 40} ;\n    std::string arr2[] = { \"hello\", \"world\" } ; \n    std::vector&lt;int&gt; v1( arr1, arr1+4 ) ;\n    std::vector&lt;std::string&gt; v2( arr2, arr2+2 ) ;\n\n    func1( v1 ) ;\n    func1( v2 ) ;\n}\n</code></pre>\n<p>and the alternative for <em>variadic templates</em> would be <a href=\"http://en.cppreference.com/w/cpp/utility/variadic\" rel=\"noreferrer\">variadic functions</a> although they are not <em>type-safe</em> and in general <a href=\"http://robertseacord.sys-con.com/node/158825/mobile\" rel=\"noreferrer\">error prone and can be unsafe to use</a> but the only other potential alternative would be to use <em>default arguments</em>, although that has limited use. The example below is a modified version of the sample code in the linked reference:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cstdarg&gt;\n\nvoid simple_printf(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n\n    while (*fmt != '\\0') {\n        if (*fmt == 'd') {\n            int i = va_arg(args, int);\n            std::cout &lt;&lt; i &lt;&lt; '\\n';\n        } else if (*fmt == 's') {\n            char * s = va_arg(args, char*);\n            std::cout &lt;&lt; s &lt;&lt; '\\n';\n        }\n        ++fmt;\n    }\n\n    va_end(args);\n}\n\n\nint main()\n{\n    std::string\n        str1( \"Hello\" ),\n        str2( \"world\" );\n\n    simple_printf(\"dddd\", 10, 20, 30, 40 );\n    simple_printf(\"ss\", str1.c_str(), str2.c_str() ); \n\n    return 0 ;\n} \n</code></pre>\n<p>Using <em>variadic functions</em> also comes with restrictions in the arguments you can pass which is detailed in the <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"noreferrer\">draft C++ standard</a> in section <code>5.2.2</code> <em>Function call</em> paragraph <em>7</em>:</p>\n<blockquote>\n<p id=\"so_1657883_16338804_1\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving function can obtain the value of the argument by invoking va_arg (18.7). The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the argument expression. After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed. If the argument has a non-POD class type (clause 9), the behavior is undefined. [...]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-17T19:06:13.780", "Score": "248", "CreationDate": "2013-05-02T13:06:38.097", "ParentId": "1657883", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2015-07-17T19:06:13.780"}, "1657906": {"Id": "1657906", "PostTypeId": "2", "Body": "<p>As others have said, C-style varargs. But you can also do something similar with default arguments.</p>\n", "LastActivityDate": "2009-11-01T18:33:54.050", "CommentCount": "2", "CreationDate": "2009-11-01T18:33:54.050", "ParentId": "1657883", "Score": "2", "OwnerUserId": "15727"}, "44020640": {"Id": "44020640", "PostTypeId": "2", "Body": "<p>in c++11 you can do:</p>\n<pre><code>void foo(const std::list&lt;std::string&gt; &amp; myArguments) {\n   //do whatever you want, with all the convenience of lists\n}\n\nfoo({\"arg1\",\"arg2\"});\n</code></pre>\n<p>list initializer FTW!</p>\n", "LastActivityDate": "2017-05-17T09:21:49.547", "CommentCount": "2", "CreationDate": "2017-05-17T09:21:49.547", "ParentId": "1657883", "Score": "6", "OwnerUserId": "4834987"}});