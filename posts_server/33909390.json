post_cb({"bq_ids": {"n4140": {"so_33909390_33917875_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 4706}}, "n3337": {"so_33909390_33917875_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 4515}}, "n4659": {"so_33909390_33917875_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 6103}}}, "33909390": {"ViewCount": "532", "Body": "<p>Consider following code:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct T {};\n\nstatic_assert(std::is_trivially_destructible&lt; T &gt;{});\nstatic_assert(std::is_trivially_default_constructible&lt; T &gt;{});\n\nstruct N { ~N() { ; } };\n\nstatic_assert(!std::is_trivially_destructible&lt; N &gt;{});\nstatic_assert(!std::is_trivially_default_constructible&lt; N &gt;{});\n</code></pre>\n<p>It compiles fine using <code>clang 3.7.0</code>: <a href=\"http://coliru.stacked-crooked.com/a/d4a7f10e41a44f36\" rel=\"nofollow noreferrer\">live example</a>. But summarizing <a href=\"http://en.cppreference.com/w/cpp/language/default_constructor\" rel=\"nofollow noreferrer\">the Standard</a>:</p>\n<blockquote>\n<p id=\"so_33909390_33909390_0\">The default constructor for class T is trivial (i.e. performs no action) if all of the following is true:</p>\n<ul>\n<li>The constructor is not user-provided (i.e., is implicitly-defined or defaulted)</li>\n<li>T has no virtual member functions</li>\n<li>T has no virtual base classes</li>\n<li>T has no non-static members with default initializers.\n  (since C++11)</li>\n<li>Every direct base of T has a trivial default constructor</li>\n<li>Every non-static member of class type has a trivial default constructor</li>\n</ul>\n</blockquote>\n<p>As I can see there is no dependence on triviality of the destructor.</p>\n<p>I missed something? Is it <code>clang</code> bug?</p>\n<h3>ADDITIONAL</h3>\n<p>I found a workaround: is <code>static_assert(__has_trivial_constructor( N ));</code> built-in type trait. There is support in <a href=\"http://clang.llvm.org/docs/LanguageExtensions.html#checks-for-type-trait-primitives\" rel=\"nofollow noreferrer\"><code>clang</code></a>, <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html\" rel=\"nofollow noreferrer\"><code>gcc</code></a> and <a href=\"https://msdn.microsoft.com/en-us/library/ms177194.aspx\" rel=\"nofollow noreferrer\"><code>MSVC</code></a>.</p>\n<p>For <code>is_noexcept_constructible</code> family of type traits <a href=\"https://gist.github.com/tomilov/c9e743a47b8a79ab8ee4\" rel=\"nofollow noreferrer\">there is workaround</a> too.</p>\n", "AcceptedAnswerId": "33917875", "Title": "Non-trivial destructor make class non-trivially-constructible", "CreationDate": "2015-11-25T05:55:32.050", "Id": "33909390", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-26T07:05:49.687", "LastEditorUserId": "1430927", "LastActivityDate": "2015-11-26T07:05:49.687", "Score": "14", "OwnerUserId": "1430927", "Tags": "<c++><destructor><trivial>", "AnswerCount": "1"}, "33917875": {"Id": "33917875", "PostTypeId": "2", "Body": "<p>This issue is covered in <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2116\" rel=\"nofollow\">LWG issue 2116: std::swap noexcept(what?)</a>, we can see this from the cppreference section for <a href=\"http://en.cppreference.com/w/cpp/types/is_default_constructible\" rel=\"nofollow\">std::is_trivially_default_constructible</a>:</p>\n<blockquote>\n<p id=\"so_33909390_33917875_0\">In many implementations, is_nothrow_default_constructible also checks if the destructor throws because it is effectively noexept(T()): GCC bug 51452 LWG issue 2116</p>\n</blockquote>\n<p>which deceptively only talks about <code>is_nothrow_default_constructible</code> but if we read the issue in detail we see it also applies here as well.</p>\n<p>Perhaps is is easier if we follow the <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452\" rel=\"nofollow\">gcc bug report: [DR 2116] has_nothrow_.*constructor bugs</a> referenced first which says:</p>\n<blockquote>\n<p id=\"so_33909390_33917875_1\">The traits that detect nothrow constructibility are buggy because they are influenced by whether the object has a nothrow dtor; destruction is invoked at the end of evaluation of the full expression in the noexcept( ... ) operator.  They all use the pattern of constructing a temporary inside noexcept, whereas they should be using placement new</p>\n</blockquote>\n<p>this explicitly says what is only really alluded to in the LWG issue which eventually says:</p>\n<blockquote>\n<p id=\"so_33909390_33917875_2\">is_nothrow_constructible is defined in <strong>terms of is_constructible, which is defined by looking at a hypothetical variable and asking whether the variable definition is known not to throw exceptions. The issue claims that this also examines the type's destructor, given the context, and thus will return false if the destructor can potentially throw</strong>. At least one implementation (Howard's) does return false if the constructor is noexcept(true) and the destructor is noexcept(false). So that's not a strained interpretation. The issue is asking for this to be defined in terms of placement new, instead of in terms of a temporary object, to make it clearer that is_nothrow_constructible looks at the noexcept status of only the constructor, and not the destructor. </p>\n</blockquote>\n<p>which also effects <code>std::is_trivially_default_constructible</code> which relies on <a href=\"http://en.cppreference.com/w/cpp/types/is_constructible\" rel=\"nofollow\">std::is_trivially_constructible</a> which does the same as <code>is_constructible</code> but has the further restriction that:</p>\n<blockquote>\n<p id=\"so_33909390_33917875_3\">but the variable definition does not call any operation that is not trivial</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-26T03:06:02.300", "Score": "5", "CreationDate": "2015-11-25T13:34:46.137", "ParentId": "33909390", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-11-26T03:06:02.300"}});