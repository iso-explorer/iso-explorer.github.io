post_cb({"bq_ids": {"n4140": {"so_17508703_17637679_0": {"length": 18, "quality": 0.6923076923076923, "section_id": 378}, "so_17508703_17637679_1": {"length": 19, "quality": 0.95, "section_id": 7230}, "so_17508703_17637679_2": {"length": 4, "quality": 0.8, "section_id": 7230}}, "n3337": {"so_17508703_17637679_1": {"length": 19, "quality": 0.95, "section_id": 6974}, "so_17508703_17637679_2": {"length": 4, "quality": 0.8, "section_id": 6974}, "so_17508703_17637679_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 369}}}, "17508703": {"ViewCount": "396", "Body": "<p>I have the following test program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;typename Ty, std::size_t N&gt;\nvoid foo(Ty (&amp;&amp;)[N])\n{\n    std::cout &lt;&lt; \"Ty (&amp;&amp;)[\" &lt;&lt; N &lt;&lt; \"]\\t\" &lt;&lt; std::is_const&lt;Ty&gt;::value &lt;&lt; '\\n';\n}\n\ntemplate&lt;typename Ty, std::size_t N&gt;\nvoid foo(Ty (&amp;)[N])\n{\n    std::cout &lt;&lt; \"Ty (&amp;)[\" &lt;&lt; N &lt;&lt; \"]\\t\" &lt;&lt; std::is_const&lt;Ty&gt;::value &lt;&lt; '\\n';\n}\n\ntemplate&lt;typename Ty&gt;\nusing id = Ty;\n\nint main()\n{\n    std::cout.setf(std::cout.boolalpha);\n\n    foo(id&lt;int[]&gt;{1, 2, 3, 4, 5});\n    foo(id&lt;int const[]&gt;{1, 2, 3, 4, 5}); // &lt;-- HERE.\n    int xs[]{1, 2, 3, 4, 5};\n    foo(xs);\n    int const ys[]{1, 2, 3, 4, 5};\n    foo(ys);\n    foo(std::move(xs));\n    foo(std::move(ys));\n}\n</code></pre>\n<p>I would expect that the line marked with an arrow would call the rvalue overload like the non-const call just above it but it doesn't.</p>\n<p>Is this just a bug in GCC or is there something in the standard that causes the lvalue overload to be selected?</p>\n", "AcceptedAnswerId": "17637679", "Title": "Temporary const array not binding to rvalue reference", "CreationDate": "2013-07-07T02:19:10.333", "Id": "17508703", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-07-14T08:32:48.750", "Score": "8", "OwnerUserId": "2491746", "Tags": "<c++><arrays><c++11><const><rvalue-reference>", "AnswerCount": "1"}, "17637679": {"Id": "17637679", "PostTypeId": "2", "Body": "<p>According to the standard <code>\u00a712.2 [class.temporary]</code>:</p>\n<blockquote>\n<p id=\"so_17508703_17637679_0\">Temporaries of class type are created in various contexts: binding a\n  reference  to a prvalue (8.5.3), returning a prvalue (6.6.3), a\n  conversion that creates  a prvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing\n  an exception (15.1), entering  a handler (15.3), and in some\n  initializations (8.5).</p>\n</blockquote>\n<p>So <code>id&lt;int const[]&gt;{1, 2, 3, 4, 5}</code> is a temporary and therefore is an prvalue <code>\u00a73.10 [basic.lval]</code>:</p>\n<blockquote>\n<p id=\"so_17508703_17637679_1\">An rvalue (so called, historically, because rvalues could appear on\n  the right-hand side of an assignment expression) is an xvalue, a\n  temporary  object (12.2) or subobject thereof, or a value that is not\n  associated  with an object.</p>\n<p id=\"so_17508703_17637679_2\">A prvalue (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue.</p>\n</blockquote>\n<p>Hence shall be selected overloaded function with rvalue reference argument.</p>\n", "LastEditorUserId": "246886", "LastActivityDate": "2013-07-14T08:32:48.750", "CommentCount": "2", "CreationDate": "2013-07-14T08:15:52.620", "ParentId": "17508703", "Score": "2", "OwnerUserId": "2035105", "LastEditDate": "2013-07-14T08:32:48.750"}});