post_cb({"bq_ids": {"n4140": {"so_47829403_47831065_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 233}, "so_47829403_47829403_0": {"length": 12, "quality": 1.0, "section_id": 234}, "so_47829403_47831065_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 175}}, "n3337": {"so_47829403_47831065_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 226}, "so_47829403_47829403_0": {"length": 12, "quality": 1.0, "section_id": 227}, "so_47829403_47831065_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 169}}, "n4659": {"so_47829403_47831065_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 243}, "so_47829403_47829403_0": {"length": 12, "quality": 1.0, "section_id": 244}, "so_47829403_47831065_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 180}}}, "47829403": {"ViewCount": "160", "Body": "<p>In the snippet below, I'm puzzled about why the definition of <code>Wrapper::f() const</code> does not make my program ill-formed<sup>1</sup> although it calls a non-const member function of a non mutable member variable:</p>\n<pre><code>// well-formed program (???)\n// build with: g++ -std=c++17 -Wall -Wextra -Werror -pedantic\ntemplate&lt;class T&gt; struct Data { void f() {} };\n\ntemplate&lt;class T&gt; struct Wrapper\n{\n    Data&lt;T&gt; _data;\n    void f() const { _data.f(); } // _data.f(): non-const!\n};\n\nint main()\n{\n    Wrapper&lt;void&gt; w; // no error in instantiation point?\n    (void) w;\n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/8cd26e2129d114b5\" rel=\"noreferrer\">demo</a></kbd><sup>2</sup></p>\n<p>On the other hand, if <code>Data</code> is a non template class<sup>3</sup>, a diagnostic is issued by my compiler:</p>\n<pre><code>// ill-formed program (as expected)\n// build with: g++ -std=c++17 -Wall -Wextra -Werror -pedantic\nstruct Data { void f() {} };\n\ntemplate&lt;class T&gt; struct Wrapper\n{\n    Data _data;\n    void f() const { _data.f(); } //error: no matching function for call to 'Data::f() const'\n};\n\nint main()\n{\n    Wrapper&lt;void&gt; w;\n    (void) w;\n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/03742f915020763c\" rel=\"noreferrer\">demo</a></kbd></p>\n<p>I feel like the answer will contain expressions such as \"deduced context\" ... but I really cannot pin down the exact part of the standard scecifying this behaviour.</p>\n<p><strong>Is there a language lawyer to enlighten me on the matter?</strong></p>\n<hr>\n<p>Notes:<br>\n<sup>1)</sup> But I get an error if I try and effectively <em>call</em> <code>Wrapper&lt;T&gt;::f() const</code>.<br>\n<sup>2)</sup> I've compiled with <code>-std=c++17</code> but this is not specific to C++17, hence no specific tag.<br>\n<sup>3)</sup> In <a href=\"https://stackoverflow.com/a/31328843/5470596\">this answer</a>, @Baum mit Augen quotes <code>[N4140, 14.7.1(2)]</code>:</br></br></br></p>\n<blockquote>\n<p id=\"so_47829403_47829403_0\">the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist</p>\n</blockquote>\n<p>but here in the compiling snippet (#2) <code>void f() const { _data.f(); }</code> fails although its <em>\"specialization is <strong>never</strong> referenced in a context that requires the member definition to exist\"</em>.</p>\n</hr>", "AcceptedAnswerId": "47831065", "Title": "Well-formed program containing an ill-formed template member function?", "CreationDate": "2017-12-15T09:34:35.710", "LastActivityDate": "2017-12-15T12:25:00.873", "CommentCount": "9", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-12-15T09:47:30.167", "LastEditorUserId": "5470596", "Id": "47829403", "Score": "8", "OwnerUserId": "5470596", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "1"}, "47831065": {"Id": "47831065", "PostTypeId": "2", "Body": "<p>Snippet #2 is <em>ill-formed</em>.</p>\n<p>As already stated in <a href=\"https://stackoverflow.com/questions/10323980/templates-compilation-gcc-vs-vs2010\">this answer</a>, the template definition of <code>Wrapper::f</code> is well-formed (thus no diagonstics are issued) as long as a valid specialization can be <em>generated</em>.</p>\n<p><a href=\"http://eel.is/c++draft/temp.res#8\" rel=\"nofollow noreferrer\">\u00a717.7/8 [temp.res]</a> states:</p>\n<blockquote>\n<p id=\"so_47829403_47831065_0\">Knowing which names are type names allows the syntax of every template\n  to be checked. The program is ill-formed, no diagnostic required, if:</p>\n<ul>\n<li>no valid specialization can be generated for a template or a substatement of a constexpr if statement within a template and the\n  template is not instantiated, or [...]</li>\n</ul>\n</blockquote>\n<p>In neither of the two code snippets, <code>Wrapper&lt;void&gt;::f</code> is getting instantiated, because of the rules in <a href=\"http://eel.is/c++draft/temp.inst#2\" rel=\"nofollow noreferrer\">\u00a717.7.1/2 [temp.inst]</a>:</p>\n<blockquote>\n<p id=\"so_47829403_47831065_1\">The implicit instantiation of a class template specialization causes\n  the implicit instantiation of the <em>declarations</em>, but not of the\n  definitions, [...].</p>\n</blockquote>\n<p>(emphasizing done by me)</p>\n<p>But now \u00a717.7/8 kicks in: if there is no instantiation and <em>there can be no generated specialization</em> for which the template definition of <code>Wrapper::f</code> is valid (which is the case for snippet #2, as for every generated specialization <code>Wrapper&lt;T&gt;::f</code>, a <code>non-const</code> call inside a <code>const</code> function on a member is would be performed), the program is ill-formed and diagnostics are issued.</p>\n<p>But because the diagnostics are not mandatory (see \u00a717.7/8 above), the GCC can deny snippet #2 while both <a href=\"http://rextester.com/JTBRR73709\" rel=\"nofollow noreferrer\">VS</a> and <a href=\"https://wandbox.org/permlink/tiNxQqc2aGjCHzNd\" rel=\"nofollow noreferrer\">clang</a> compile the same code flawlessly.</p>\n<p>For snippet #1 however you could provide a user-defined specialization for <code>Data</code> where <code>Data::f</code> is <code>const</code> (say <code>Data&lt;void&gt;::f</code>). Therefore, a valid, <em>generated</em> specialization of <code>Wrapper::f</code> is possible, i.e. <code>Wrapper&lt;void&gt;::f</code>. So in conclusion, snippet #1 is well-formed and snippet #2 is invalid; all compilers work in a standard-conforming manner.</p>\n", "LastEditorUserId": "7703564", "LastActivityDate": "2017-12-15T12:25:00.873", "Score": "4", "CreationDate": "2017-12-15T11:06:48.923", "ParentId": "47829403", "CommentCount": "4", "OwnerUserId": "7703564", "LastEditDate": "2017-12-15T12:25:00.873"}});