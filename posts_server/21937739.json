post_cb({"bq_ids": {"n4140": {"so_21937739_21937889_0": {"length": 23, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_21937739_21937889_0": {"length": 23, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_21937739_21937889_0": {"length": 23, "quality": 1.0, "section_id": 7604}}}, "21937739": {"ViewCount": "318", "Body": "<p>I'm playing around with a class hierarchy for file descriptors, where the base class holds an int and calls <code>close</code> on it during destruction and child classes don't add any virtual methods or data members, just differ in their construction (e.g. the <code>named_file_filedes</code> takes a path and initializes the base with <code>open</code> in the ctor) or non-virtual member functions (e.g. you can only call <code>kevent</code> on a <code>kqueue_filedes</code>). Given this, does the base class need a virtual destructor? The size of the child classes is all the same and none of them have custom destruction logic. Tagged <code>c++11</code> as that's the standard version I'm targeting.</p>\n", "AcceptedAnswerId": "21937889", "Title": "Do I need a virtual destructor if descendant classes have no non-static members or destructors?", "CreationDate": "2014-02-21T14:56:30.513", "Id": "21937739", "CommentCount": "0", "PostTypeId": "1", "ClosedDate": "2014-02-21T16:18:37.080", "LastActivityDate": "2014-02-21T15:03:46.597", "Score": "1", "OwnerUserId": "636917", "Tags": "<c++><c++11><virtual-destructor>", "AnswerCount": "2"}, "21937889": {"Id": "21937889", "PostTypeId": "2", "Body": "<p>If you <code>delete</code> derived classes via pointers to base classes then the behavior will be undefined without a virtual destructor, no matter how the derived classes look.</p>\n<p>C++11 Standard, \u00a75.3.5/3:</p>\n<blockquote>\n<p id=\"so_21937739_21937889_0\">If the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>However, if the classes differ only in their constructor, consider using alternatives to derivation, e.g. simple free functions like <code>create_named_file()</code>.</p>\n", "LastActivityDate": "2014-02-21T15:03:46.597", "CommentCount": "0", "CreationDate": "2014-02-21T15:03:46.597", "ParentId": "21937739", "Score": "3", "OwnerUserId": "2128694"}, "21937812": {"Id": "21937812", "PostTypeId": "2", "Body": "<p>You'll need a <code>virtual</code> destructor if you intend to destroy a derived class object by <code>delete</code>ing a base class pointer.  Such as:</p>\n<pre><code>class Foo {};\nclass Bar : public Foo {}\n\nint main()\n{\n  Foo* f = new Bar;\n  delete f; // &lt;&lt; UNDEFINED BEHAVIOR without virtual destructor in base classe\n}\n</code></pre>\n<p>You'll also need at least 1 <code>virtual</code> method in the base if you require the object to be polymorphic -- for instance, if you intend to use <code>dynamic_cast</code> to go from base to derived.  Commonly a virtual destructor is provided in this case.  Having only a virtual destructor is sufficient to ensure the class is polymorphic.</p>\n", "LastActivityDate": "2014-02-21T14:59:43.937", "CommentCount": "0", "CreationDate": "2014-02-21T14:59:43.937", "ParentId": "21937739", "Score": "5", "OwnerUserId": "241536"}});