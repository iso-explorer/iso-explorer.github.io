post_cb({"bq_ids": {"n4140": {"so_11846511_11848142_0": {"length": 18, "quality": 0.782608695652174, "section_id": 6318}}, "n3337": {"so_11846511_11848142_0": {"length": 18, "quality": 0.782608695652174, "section_id": 6075}}, "n4659": {"so_11846511_11848142_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 7828}}}, "11848142": {"Id": "11848142", "PostTypeId": "2", "Body": "<p>Here is what the C++ standard has to say about this, in section 17.6.4.6/3:</p>\n<blockquote>\n<p id=\"so_11846511_11848142_0\">The program's definitions (of the new / delete operators) are used instead of the default versions supplied by the implementation. Such replacement occurs prior to program startup. The program's definitions shall not be specified as <code>inline</code>. No diagnostic is required.</p>\n</blockquote>\n<p>If you read that carefully, it exactly explains the trouble you are having. There is a kind of \"catch 22\" happening here. </p>\n<p>On one hand, you cannot have the definitions of your new/delete operators compiled inside the DLL because the overloaded new/delete cannot be linked dynamically (this is because new/delete might be needed during static initialization, prior to loading the DLL, so you would have inconsistent new/delete operators before and after the loading of the DLL, and that's undefined behavior). </p>\n<p>On the other hand, you cannot just put your new/delete operator definitions in your DLL header files, because they would need to be marked <code>inline</code> in order to satisfy the One Definition Rule (ODR), which, in turn, doesn't satisfy the above clause. The requirement for them to not be marked <code>inline</code> is probably there because a function definition marked <code>inline</code> has \"no linkage\", resulting in each translation unit using its own compiled version of it (or as inline expansions), which, normally is OK, but not for dynamic memory allocation.</p>\n<p>Both of the above catches are motivated by the fact that, for correctness, there generally needs to be a guarantee that memory allocated with <code>new</code> is deallocated with the corresponding <code>delete</code> operator (i.e., \"compiled together\", so to speak, or both defaulted). For example, if your new/delete operators rely on an underlying malloc/free call, you rely on the heap used by the translation unit that called the new/delete operator, between a DLL and an executable, there is no guarantee that this heap will be the same (in fact, in Windows, in particular, it is not, the two modules use two separate heaps for dynamic memory allocations).</p>\n<p>So, the solution to your problem, as Rook puts it, is \"don't do that\". Don't overload the new/delete operators for DLL objects because there is no clean method to correctly do this, whichever way you twist and turn your code, it will always boil down to the same problem stated above. </p>\n<p>What you can and should do instead is to use a factory function pattern for your DLL objects and return a smart pointer (such as a <code>std::shared_ptr</code>) with a custom deleter that relies on a dynamic dispatching of the deletion back to the site where the object was created. This is inspired by a technique from <a href=\"http://chadaustin.me/cppinterface.html\" rel=\"noreferrer\">Chad Austin</a>. I have done something very similar <a href=\"https://github.com/mikael-s-persson/ReaK/blob/master/src/ReaK/core/base/shared_object_base.hpp\" rel=\"noreferrer\">here</a>.</p>\n", "LastActivityDate": "2012-08-07T14:26:45.470", "CommentCount": "2", "CreationDate": "2012-08-07T14:26:45.470", "ParentId": "11846511", "Score": "6", "OwnerUserId": "491645"}, "11846511": {"ViewCount": "1961", "Body": "<p>How to overload <code>new</code> and <code>delete</code> operator for a <code>dll</code>. I have written overloaded operators as part of the dll , but client linking with this <code>dll</code> does not use <code>overloaded new and delete</code></p>\n", "Title": "new and delete operator overloading for dll", "CreationDate": "2012-08-07T12:54:36.030", "LastActivityDate": "2017-10-23T13:36:20.803", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Id": "11846511", "Score": "4", "OwnerUserId": "92568", "Tags": "<c++><window><new-operator>", "AnswerCount": "2"}, "46890756": {"Id": "46890756", "PostTypeId": "2", "Body": "<p>You could try and write your own malloc and delete functions and then create a C definition that basically contains the code to override new and delete and call these custom malloc and delete functions.</p>\n<p>This way you could do something such as</p>\n<pre><code>MODULE_START()\n// CODE HERE\n\nMODULE_END()\n</code></pre>\n<p>and this should work smoothly.</p>\n", "LastActivityDate": "2017-10-23T13:36:20.803", "CommentCount": "0", "CreationDate": "2017-10-23T13:36:20.803", "ParentId": "11846511", "Score": "0", "OwnerUserId": "8567992"}});