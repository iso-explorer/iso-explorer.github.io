post_cb({"28011191": {"ParentId": "28010565", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>When a programming language is created some decisions are made intuitively. </p>\n<p>For instance why not convert int+float to int+int instead of float+float or double+double? Why call int-&gt;float a promotion if it holds the same about of bits? Why not call float-&gt;int a promotion?</p>\n<p>If you rely on implicit type conversions you should know how they work, otherwise just convert manually.</p>\n<p>Some language could have been designed without any automatic type conversions at all. And not every decision during a design phase could have been made logically with a good reason.</p>\n<p>JavaScript with it's duck typing has even more obscure decisions under the hood. Designing an absolutely logical language is impossible, I think it goes to Godel incompleteness theorem. You have to balance logic, intuition, practice and ideals.</p>\n", "OwnerUserId": "1968972", "LastEditorUserId": "2411320", "LastEditDate": "2015-01-18T15:13:39.183", "Id": "28011191", "Score": "3", "CreationDate": "2015-01-18T15:09:08.733", "LastActivityDate": "2015-01-18T15:13:39.183"}, "28010565": {"CommentCount": "11", "AcceptedAnswerId": "28011249", "PostTypeId": "1", "LastEditorUserId": "2411320", "CreationDate": "2015-01-18T14:08:28.217", "LastActivityDate": "2017-08-30T04:52:45.100", "AnswerCount": "9", "LastEditDate": "2017-08-30T04:52:45.100", "ViewCount": "7075", "FavoriteCount": "9", "Title": "Why does C++ promote an int to a float when a float cannot represent all int values?", "Id": "28010565", "Score": "66", "Body": "<p>Say I have the following:</p>\n<pre><code>int i = 23;\nfloat f = 3.14;\nif (i == f) // do something\n</code></pre>\n<p><code>i</code> will be promoted to a <code>float</code> and the two <code>float</code> numbers will be compared, but can a <code>float</code> represent all <code>int</code> values? Why not promote both the <code>int</code> and the <code>float</code> to a <code>double</code>?</p>\n", "Tags": "<c++><types><int><floating-point-conversion><promotions>", "OwnerDisplayName": "user4344762"}, "28010631": {"ParentId": "28010565", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Q1:  Can a float represent all int values?</p>\n<p>IEE754 can represent all integers exactly as floats, up to about 2<sup>23</sup>, as mentioned in this <a href=\"https://stackoverflow.com/a/759034/2411320\">answer</a>.</p>\n<p>Q2: Why not promote both the int and the float to a double?</p>\n<blockquote>\n<p id=\"so_28010565_28010631_0\">The rules in the Standard for these conversions are slight modifications of those in K&amp;R: the modifications accommodate the added types and the value preserving rules. <strong>Explicit license was added to perform calculations in a \u201cwider\u201d type than absolutely necessary, since this can sometimes produce smaller and faster code, not to mention the correct answer more often.</strong> Calculations can also be performed in a \u201cnarrower\u201d type by the as if rule so long as the same end result is obtained. Explicit casting can always be used to obtain a value in a desired type.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/a/24372323/2411320\">Source</a></p>\n<p>Performing calculations in a wider type means that given <code>float f1;</code> and <code>float f2;</code>, <code>f1 + f2</code> might be calculated in <code>double</code> precision. And it means that given <code>int i;</code> and <code>float f;</code>, <code>i == f</code> might be calculated in <code>double</code> precision. But it isn't required to calculate <code>i == f</code> in double precision, as hvd stated in the comment.</p>\n<p>Also C standard says so. These are known as the usual arithmetic conversions . The following description is taken straight from the ANSI C standard.</p>\n<blockquote>\n<p id=\"so_28010565_28010631_1\">...if either operand has type float , the other operand is converted to type float .</p>\n</blockquote>\n<p><a href=\"http://www.tti.unipa.it/~ricrizzo/KS/Data/PBurden/chap4.usual.conversions.html\" rel=\"nofollow noreferrer\">Source</a> and you can see it in the <a href=\"http://en.cppreference.com/w/c/language/usual_arithmetic_conversions\" rel=\"nofollow noreferrer\">ref</a> too.</p>\n<p>A relevant link is this <a href=\"https://stackoverflow.com/a/5563131/2411320\">answer</a>. A more analytic source is <a href=\"https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>Here is another way to explain this: The usual arithmetic conversions are implicitly performed to cast their values in a common type. Compiler first performs integer promotion, if operands still have different types then they are converted to the type that appears highest in the following hierarchy:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/WIGDE.png\"/></p>\n<p><a href=\"http://www.tutorialspoint.com/cprogramming/c_type_casting.htm\" rel=\"nofollow noreferrer\">Source</a>.</p>\n", "OwnerUserId": "2411320", "LastEditorUserId": "2411320", "LastEditDate": "2017-08-30T04:52:01.603", "Id": "28010631", "Score": "5", "CreationDate": "2015-01-18T14:13:29.630", "LastActivityDate": "2017-08-30T04:52:01.603"}, "28010641": {"ParentId": "28010565", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Even <code>double</code> may not be able to represent all <code>int</code> values, depending on how much bits does <code>int</code> contain.</p>\n<p><strong>Why not promote both the int and the float to a double?</strong></p>\n<p>Probably because it's more costly to convert both types to <code>double</code> than use one of the operands, which is already a <code>float</code>, as <code>float</code>. It would also introduce special rules for comparison operators incompatible with rules for arithmetic operators. </p>\n<p>There's also no guarantee how floating point types will be represented, so it would be a blind shot to assume that converting <code>int</code> to <code>double</code> (or even <code>long double</code>) for comparison will solve anything.</p>\n", "OwnerUserId": "205955", "LastEditorUserId": "205955", "LastEditDate": "2015-01-18T15:00:25.643", "Id": "28010641", "Score": "13", "CreationDate": "2015-01-18T14:14:14.623", "LastActivityDate": "2015-01-18T15:00:25.643"}, "28011488": {"ParentId": "28010565", "CommentCount": "0", "Body": "<p>The question is why: Because it is fast, easy to explain, easy to compile, and these were all very important reasons at the time when the C language was developed. </p>\n<p>You could have had a different rule: That for every comparison of arithmetic values, the result is that of comparing the actual numerical values. That would be somewhere between trivial if one of the expressions compared is a constant, one additional instruction when comparing signed and unsigned int, and quite difficult if you compare long long and double and want correct results when the long long cannot be represented as double. (0u &lt; -1 would be false, because it would compare the numerical values 0 and -1 without considering their types).</p>\n<p>In Swift, the problem is solved easily by disallowing operations between different types. </p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "28011488", "Score": "2", "CreationDate": "2015-01-18T15:38:19.070", "LastActivityDate": "2015-01-18T15:38:19.070"}, "28011112": {"ParentId": "28010565", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The type promotion rules are designed to be simple and to work in a predictable manner. The types in C/C++ are naturally \"sorted\" by the <a href=\"http://www.cplusplus.com/forum/beginner/44774/\" rel=\"nofollow\">range of values</a> they can represent. See <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">this</a> for details. Although floating point types cannot represent all integers represented by integral types because they can't represent the same number of significant digits, they might be able to represent a wider range.</p>\n<p>To have predictable behavior, when requiring type promotions, the numeric types are always converted to the type with the <em>larger</em> range to avoid overflow in the smaller one. Imagine this:</p>\n<pre><code>int i = 23464364; // more digits than float can represent!\nfloat f = 123.4212E36f; // larger range than int can represent!\nif (i == f) { /* do something */ }\n</code></pre>\n<p>If the conversion was done towards the integral type, the float <code>f</code> would certainly overflow when converted to int, leading to undefined behavior. On the other hand, converting <code>i</code> to <code>f</code> only causes a loss of precision which is irrelevant since <code>f</code> has the same precision so it's still possible that the comparison succeeds. It's up to the programmer at that point to interpret the result of the comparison according to the application requirements.</p>\n<p>Finally, besides the fact that double precision floating point numbers suffer from the same problem representing integers (limited number of significant digits), using promotion on both types would lead to having a higher precision representation for <code>i</code>, while <code>f</code> is doomed to have the original precision, so the comparison will not succeed if <code>i</code> has a more significant digits than <code>f</code> to begin with. Now that is also undefined behavior: the comparison might succeed for some couples (<code>i</code>,<code>f</code>) but not for others.</p>\n", "OwnerUserId": "1327788", "LastEditorUserId": "1327788", "LastEditDate": "2015-02-14T15:00:52.110", "Id": "28011112", "Score": "10", "CreationDate": "2015-01-18T15:00:59.477", "LastActivityDate": "2015-02-14T15:00:52.110"}, "28011249": {"ParentId": "28010565", "CommentCount": "10", "Body": "<p>When <code>int</code> is promoted to <code>unsigned</code> in the integral promotions, negative values are also lost (which leads to such fun as <code>0u &lt; -1</code> being true).</p>\n<p>Like most mechanisms in C (that are inherited in C++), the usual arithmetic conversions should be understood in terms of hardware operations. The makers of C were very familiar with the assembly language of the machines with which they worked, and they wrote C to make immediate sense to themselves and people like themselves when writing things that would until then have been written in assembly (such as the UNIX kernel).</p>\n<p>Now, processors, as a rule, do not have mixed-type instructions (add float to double, compare int to float, etc.) because it would be a huge waste of real estate on the wafer -- you'd have to implement as many times more opcodes as you want to support different types. That you only have instructions for \"add int to int,\" \"compare float to float\", \"multiply unsigned with unsigned\" etc. makes the usual arithmetic conversions necessary in the first place -- they are a mapping of two types to the instruction family that makes most sense to use with them.</p>\n<p>From the point of view of someone who's used to writing low-level machine code, if you have mixed types, the assembler instructions you're most likely to consider in the general case are those that require the least conversions. This is particularly the case with floating points, where conversions are runtime-expensive, and particularly back in the early 1970s, when C was developed, computers were slow, and when floating point calculations were done in software. This shows in the usual arithmetic conversions -- only one operand is ever converted (with the single exception of <code>long</code>/<code>unsigned int</code>, where the <code>long</code> may be converted to <code>unsigned long</code>, which does not require anything to be done on most machines. Perhaps not on any where the exception applies).</p>\n<p>So, the usual arithmetic conversions are written to do what an assembly coder would do most of the time: you have two types that don't fit, convert one to the other so that it does. This is what you'd do in assembler code unless you had a specific reason to do otherwise, and to people who are used to writing assembler code and <em>do</em> have a specific reason to force a different conversion, explicitly requesting that conversion is natural. After all, you can simply write</p>\n<pre><code>if((double) i &lt; (double) f)\n</code></pre>\n<p>It is interesting to note in this context, by the way, that <code>unsigned</code> is higher in the hierarchy than <code>int</code>, so that comparing <code>int</code> with <code>unsigned</code> will end in an unsigned comparison (hence the <code>0u &lt; -1</code> bit from the beginning). I suspect this to be an indicator that people in olden times considered <code>unsigned</code> less as a restriction on <code>int</code> than as an extension of its value range: We don't need the sign right now, so let's use the extra bit for a larger value range. You'd use it if you had reason to expect that an <code>int</code> would overflow -- a much bigger worry in a world of 16-bit <code>int</code>s.</p>\n", "OwnerUserId": "4301306", "PostTypeId": "2", "Id": "28011249", "Score": "67", "CreationDate": "2015-01-18T15:15:05.713", "LastActivityDate": "2015-01-18T15:15:05.713"}, "28035894": {"ParentId": "28010565", "CommentCount": "5", "Body": "<p>The rules are written for 16 bit ints (smallest required size). Your compiler with 32 bit ints surely converts both sides to double. There are no float registers in modern hardware anyway so it <em>has</em> to convert to double. Now if you have 64 bit ints I'm not too sure what it does. long double would be appropriate (normally 80 bits but it's not even standard).</p>\n", "OwnerUserId": "14768", "PostTypeId": "2", "Id": "28035894", "Score": "2", "CreationDate": "2015-01-20T00:29:48.383", "LastActivityDate": "2015-01-20T00:29:48.383"}, "28012015": {"ParentId": "28010565", "CommentCount": "4", "Body": "<p>It is fascinating that a number of answers here argue from the origin of the C language, explicitly naming K&amp;R and historical baggage as the reason that an int is converted to a float when combined with a float.</p>\n<p>This is pointing the blame to the wrong parties.  In K&amp;R C, there was no such thing as a float calculation.  <em>All</em> floating point operations were done in double precision.  For that reason, an integer (or anything else) was never implicitly converted to a float, but only to a double.  A float also could not be the type of a function argument: you had to pass a pointer to float if you really, really, really wanted to avoid conversion into a double.  For that reason, the functions</p>\n<pre><code>int x(float a)\n{ ... }\n</code></pre>\n<p>and</p>\n<pre><code>int y(a)\nfloat a;\n{ ... }\n</code></pre>\n<p>have different calling conventions.  The first gets a float argument, the second (by now no longer permissable as syntax) gets a double argument.</p>\n<p>Single-precision floating point arithmetic and function arguments were only introduced with ANSI C.  Kernighan/Ritchie is innocent.</p>\n<p>Now with the newly available single float <em>expressions</em> (single float previously was only a storage format), there also had to be new type conversions.  Whatever the ANSI C team picked here (and I would be at a loss for a better choice) is not the fault of K&amp;R.</p>\n", "OwnerUserId": "4467309", "PostTypeId": "2", "Id": "28012015", "Score": "6", "CreationDate": "2015-01-18T16:27:15.000", "LastActivityDate": "2015-01-18T16:27:15.000"}, "bq_ids": {"n4140": {"so_28010565_28018488_0": {"section_id": 22, "quality": 0.8333333333333334, "length": 5}, "so_28010565_28018488_2": {"section_id": 5945, "quality": 0.9444444444444444, "length": 17}, "so_28010565_28010631_1": {"section_id": 5943, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_28010565_28018488_0": {"section_id": 19, "quality": 0.8333333333333334, "length": 5}, "so_28010565_28018488_2": {"section_id": 5716, "quality": 0.9444444444444444, "length": 17}, "so_28010565_28010631_1": {"section_id": 5714, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_28010565_28018488_0": {"section_id": 22, "quality": 0.8333333333333334, "length": 5}, "so_28010565_28018488_2": {"section_id": 7430, "quality": 0.9444444444444444, "length": 17}, "so_28010565_28010631_1": {"section_id": 7428, "quality": 0.7777777777777778, "length": 7}}}, "28018488": {"ParentId": "28010565", "PostTypeId": "2", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_28010565_28018488_0\">can a <code>float</code> represent all <code>int</code> values?</p>\n</blockquote>\n<p>For a typical modern system where both <code>int</code> and <code>float</code> are stored in 32 bits, no. Something's gotta give. 32 bits' worth of integers doesn't map 1-to-1 onto a same-sized set that includes fractions.</p>\n<blockquote>\n<p id=\"so_28010565_28018488_1\">The <code>i</code> will be promoted to a <code>float</code> and the two <code>float</code> numbers will be compared\u2026</p>\n</blockquote>\n<p>Not necessarily. You don't really know what precision will apply. C++14 \u00a75/12:</p>\n<blockquote>\n<p id=\"so_28010565_28018488_2\">The values of the floating operands and the results of floating expressions may be represented in greater precision and range than that required by the type; the types are not changed thereby.</p>\n</blockquote>\n<p>Although <code>i</code> after promotion has nominal type <code>float</code>, the value may be represented using <code>double</code> hardware. C++ doesn't guarantee floating-point precision loss or overflow. (This is not new in C++14; it's inherited from C since olden days.)</p>\n<blockquote>\n<p id=\"so_28010565_28018488_3\">Why not promote both the <code>int</code> and the <code>float</code> to a <code>double</code>?</p>\n</blockquote>\n<p>If you want optimal precision everywhere, use <code>double</code> instead and you'll never see a <code>float</code>. Or <code>long double</code>, but that might run slower. The rules are designed to be relatively sensible for the majority of use-cases of limited-precision types, considering that one machine may offer several alternative precisions.</p>\n<p>Most of the time, fast and loose is good enough, so the machine is free to do whatever is easiest. That might mean a rounded, single-precision comparison, or double precision and no rounding.</p>\n<p>But, such rules are ultimately compromises, and sometimes they fail. To precisely specify arithmetic in C++ (or C), it helps to make conversions and promotions explicit. Many style guides for extra-reliable software prohibit using implicit conversions altogether, and most compilers offer warnings to help you expunge them.</p>\n<p>To learn about how these compromises came about, you can peruse the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow\">C rationale document</a>. (The latest edition covers up to C99.) It is not just senseless baggage from the days of the PDP-11 or K&amp;R.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2015-01-21T23:25:19.270", "Id": "28018488", "Score": "7", "CreationDate": "2015-01-19T05:32:19.327", "LastActivityDate": "2015-01-21T23:25:19.270"}});