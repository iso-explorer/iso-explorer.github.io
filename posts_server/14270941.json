post_cb({"14271402": {"Body": "<p>I guess it's well formed, I've not found a straight statement (the wording sometimes lacks in clarity / illustration for certain situations) but I guess it may be inferred:</p>\n<p><strong>\u00a75.1.2/23:</strong></p>\n<blockquote>\n<p id=\"so_14270941_14271402_0\">A capture <em>followed</em> by an ellipsis is a pack expansion (14.5.3). [ Example:</p>\n</blockquote>\n<pre><code>      template&lt;class... Args&gt;\n      void f(Args... args) {\n        auto lm = [&amp;, args...] { return g(args...); };\n        lm();\n      }\n</code></pre>\n<blockquote>\n<p id=\"so_14270941_14271402_1\">\u2014 end example ]</p>\n</blockquote>\n<ul>\n<li><em>A capture followed by an ellipsis</em>, implies <code>args</code>, in the <em>lambda-capture</em>, is an example of a capture (in this case, explicit), and the notable fact is that <code>args</code> is a parameter pack <em>identifier</em>. This short paragraph has the sole job of describing how <em>lambda-captures</em> hold pack expansions, which demonstrates parameter packs can be captured even though its purpose is not about <em>allowing</em> them to <strong>be captured</strong>.</li>\n</ul>\n<p><strong>\u00a75.1.2/12:</strong></p>\n<blockquote>\n<p id=\"so_14270941_14271402_2\">An <strong>entity is captured</strong> if it is captured <strong>explicitly</strong> or <strong>implicitly</strong>.[...]</p>\n</blockquote>\n<p><strong>\u00a73/3:</strong></p>\n<blockquote>\n<p id=\"so_14270941_14271402_3\">An <strong>entity is a</strong> value, object, reference, function, enumerator, type, class member, template, template specialization, namespace, <strong>parameter pack</strong>, or this.</p>\n</blockquote>\n<p>From this I assume <em>parameter packs are entities that can be captured explicitly or implicitly</em>, and so, the same capturing rules as for ordinary variables shall apply, except that parameter packs shall be expanded accordingly.</p>\n<p>I guess your question (and the same argumentation) could be applied equally well for reference variables for example (<a href=\"http://preney.ca/paul/archives/1051\" rel=\"noreferrer\">It is unspecified whether or not a reference requires storage. \u00a78.3.2/4</a>). It seems you're interested when you're allowed or not to refer to a parameter pack <em>identifier</em> inside a lambda.</p>\n<p>You can think the same about reference variables in the outer scope since you may have access to them but couldn't even be allowed to access the identifier of the original variable.</p>\n<p>They're as ethereal as parameter packs.</p>\n", "CreationDate": "2013-01-11T03:53:12.507", "ParentId": "14270941", "CommentCount": "14", "LastEditDate": "2013-01-15T06:26:57.207", "Id": "14271402", "PostTypeId": "2", "LastActivityDate": "2013-01-15T06:26:57.207", "LastEditorUserId": "1000282", "CommunityOwnedDate": "2013-01-13T00:26:38.577", "Score": "7", "OwnerUserId": "1000282"}, "bq_ids": {"n4140": {"so_14270941_14271402_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 83}, "so_14270941_14271107_0": {"length": 30, "quality": 0.967741935483871, "section_id": 124}, "so_14270941_14271402_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 7026}, "so_14270941_14271402_2": {"length": 4, "quality": 0.8, "section_id": 5972}}, "n3337": {"so_14270941_14271402_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5751}, "so_14270941_14271107_0": {"length": 30, "quality": 0.967741935483871, "section_id": 118}, "so_14270941_14271402_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 6772}, "so_14270941_14271402_2": {"length": 4, "quality": 0.8, "section_id": 5740}}, "n4659": {"so_14270941_14271402_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 86}, "so_14270941_14271107_0": {"length": 30, "quality": 0.967741935483871, "section_id": 128}, "so_14270941_14271402_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 8523}, "so_14270941_14271402_2": {"length": 4, "quality": 0.8, "section_id": 7471}}}, "14271107": {"Id": "14271107", "PostTypeId": "2", "Body": "<p>14.5.3/6:</p>\n<blockquote>\n<p id=\"so_14270941_14271107_0\">The instantiation of a pack expansion that is not a <code>sizeof...</code> expression produces a list E1, E2, ..., EN , where\n  N is the number of elements in the pack expansion parameters. Each Ei is generated by instantiating the pattern and replacing each pack expansion parameter with its ith element. All of the Ei become elements in the enclosing list.</p>\n</blockquote>\n<p>Regardless of whether you're allowed to explicitly capture a pack (you can, using <code>[ts ...]</code>), the general rule of expansion will result in capture of each element of the list.</p>\n", "LastActivityDate": "2013-01-11T03:17:47.997", "CommentCount": "2", "CreationDate": "2013-01-11T03:17:47.997", "ParentId": "14270941", "Score": "12", "OwnerUserId": "153285"}, "14270941": {"ViewCount": "2847", "Body": "<p>Does anyone know if the following implicit capture of 'ts' is well-formed:</p>\n<pre><code>template&lt;class ... Ts&gt; void bar(Ts ... ts) { }\n\ntemplate&lt;class ... Ts&gt; int foo(Ts ... ts) {\n    auto L = [=] () {\n       bar(ts...);\n    };\n    L();\n    return 0;\n}\nint g = foo(1, 2, 3);\n</code></pre>\n<p>Does the standard clearly state anywhere that this should not be well formed?</p>\n", "AcceptedAnswerId": "14271107", "Title": "Can a parameter pack be captured implicitly within C++11 lambdas?", "CreationDate": "2013-01-11T02:57:19.840", "Id": "14270941", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-13T00:20:56.270", "LastEditorUserId": "1000282", "LastActivityDate": "2013-01-15T06:26:57.207", "Score": "22", "OwnerUserId": "51103", "Tags": "<c++><c++11><lambda><language-lawyer><variadic-templates>", "AnswerCount": "2"}});