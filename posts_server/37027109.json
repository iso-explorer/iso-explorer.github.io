post_cb({"bq_ids": {"n4140": {"so_37027109_37028867_0": {"length": 7, "quality": 1.0, "section_id": 7104}}, "n3337": {"so_37027109_37028867_0": {"length": 7, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_37027109_37028867_0": {"length": 7, "quality": 1.0, "section_id": 8605}}}, "37028867": {"Id": "37028867", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/basic.lookup.argdep#2\" rel=\"nofollow\">[basic.lookup.argdep]/2</a>:</p>\n<blockquote>\n<p id=\"so_37027109_37028867_0\">Typedef names and <em>using-declaration</em>s used to specify the types do not\n  contribute to this set.</p>\n</blockquote>\n<p>Neither typedef names nor using-declarations are affiliated with the type they designate. If they were (which would actually be counterintuitive, IMO), things would break very easily; just because I typedef'd some class, all calls are now considering functions added in the vicinity of the typedef, which is practically never desired:</p>\n<pre><code>#include &lt;string&gt;\n\nnamespace A {\n    using str = std::string;\n    int stoi(str); // This will be a candidate in e.g. stoi(std::string{\"0.4\"}),\n                   // leading to potentially different behavior or ambiguity\n\nnamespace B {\n    int stoi(std::string); // This is no candidate, because...?\n}\n</code></pre>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-05-04T13:33:44.833", "Score": "4", "CreationDate": "2016-05-04T13:12:53.280", "ParentId": "37027109", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2016-05-04T13:33:44.833"}, "37027109": {"ViewCount": "75", "Body": "<p>I just ran into some interesting behavior with argument-dependent lookup, which I do not fully understand:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace a {\nstruct Foo {\n  Foo(int v1, int v2) : v1(v1), v2(v2) { }\n  int v1,v2;\n};\n}\n\nnamespace b {\ntemplate &lt;typename T&gt;\nstruct Baz : T {\n  using T::T;\n};\n}\n\nnamespace c {\nusing Foo = ::b::Baz&lt; ::a::Foo&gt;;\n\n// (1) NOT FOUND BY ADL\n// std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Foo&amp; foo)\n// {\n//   return os &lt;&lt; foo.v1 &lt;&lt; \",\" &lt;&lt; foo.v2;\n// }\n}\n\nnamespace b {\n\n// (2) FOUND BY ADL\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const ::c::Foo&amp; foo)\n{\n  return os &lt;&lt; foo.v1 &lt;&lt; \",\" &lt;&lt; foo.v2;\n}\n\n}\n\nint main()\n{\n  c::Foo foo(1,2);\n  // Variant (1): ADL fails: should it not find\n  //   c::operator&lt;&lt;(std::ostream&amp;, const Foo&amp;) ?\n  // Variant (2) compiles\n  std::cout &lt;&lt; \"foo: \" &lt;&lt; foo &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I get that <code>c::Foo</code> is actually <code>b::Baz&lt;...&gt;</code>, so it somewhat makes sense that ADL finds the operator when I define it inside <code>namespace b</code>.  But it seems to defy intuition that defining the operator inside <code>namespace c</code> does not work, since <code>c::Foo</code> <em>should</em> (IMHO) allow the compiler to perform ADL inside <code>namespace c</code> as well.</p>\n<p>Why is that not the case?  What is the rationale behind this?</p>\n", "AcceptedAnswerId": "37028867", "Title": "Argument-dependent lookup behaving unexpectedly on types aliased from another namespace", "CreationDate": "2016-05-04T11:56:22.260", "Id": "37027109", "CommentCount": "2", "LastEditDate": "2016-05-04T12:23:06.063", "PostTypeId": "1", "LastEditorUserId": "3233921", "LastActivityDate": "2016-05-04T13:33:44.833", "Score": "6", "OwnerUserId": "3233921", "Tags": "<c++><language-lawyer><argument-dependent-lookup>", "AnswerCount": "1"}});