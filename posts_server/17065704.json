post_cb({"17066793": {"Id": "17066793", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17065704_17066793_0\">I think about overloading std::is_pointer in C++11 to yield true for std::shared_ptr as well, since the latter behaves very much as a T*.</p>\n</blockquote>\n<p>It does not. Good luck doing <code>++p</code> or <code>p[i]</code> with a <code>shared_ptr</code>.</p>\n<blockquote>\n<p id=\"so_17065704_17066793_1\">I wonder why this overload has not already been included in the standard implementation. Is there a pitfall that I'm overlooking?</p>\n</blockquote>\n<p>It was not included because it would have been simply wrong: <code>is_pointer</code> tells you if a type is a <em>pointer type</em> (\u00a73.9.2). <code>shared_ptr</code> is not a <em>pointer type</em>, so have <code>is_pointer&lt;shared_ptr&lt;int&gt;::value</code> be true would simply be wrong.</p>\n<blockquote>\n<p id=\"so_17065704_17066793_2\">Actually, I tried the following code in the first place:</p>\n<pre><code>template &lt;typename T&gt; \nstruct is_pointer&lt;shared_ptr&lt;typename std::remove_cv&lt;T&gt;::type&gt;&gt;\n  : std::true_type \n{};\n</code></pre>\n</blockquote>\n<p>What the hell is <code>remove_cv</code> doing there? The following \"works\" in GCC.</p>\n<pre><code>template &lt;typename T&gt; \nstruct is_pointer&lt;shared_ptr&lt;T&gt;&gt;\n  : std::true_type \n{};\n</code></pre>\n<p>However, it has undefined behaviour. In general, you are not allowed to add specializations to templates in namespace <code>std</code> if they don't agree with the defined semantics. The semantics for <code>std::is_pointer&lt;T&gt;</code> are such that it only derives from <code>std::true_type</code> if <code>T</code> is a <em>pointer type</em> which <code>std::shared_ptr</code> isn't. That alone would be enough, but in this particular case the standard actually goes to the length of forbidding it explicitly (\u00a720.9.2):</p>\n<blockquote>\n<p id=\"so_17065704_17066793_3\">The behavior of a program that adds specializations for any of the class templates defined in this subclause is undefined unless otherwise specified.</p>\n</blockquote>\n<p>The only template from <code>&lt;type_traits&gt;</code> that a user can add specializations to is <code>std::common_type</code>.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2013-06-12T13:34:49.313", "Score": "8", "CreationDate": "2013-06-12T13:27:38.763", "ParentId": "17065704", "CommentCount": "2", "OwnerUserId": "46642", "LastEditDate": "2013-06-12T13:34:49.313"}, "17065919": {"Id": "17065919", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/types/is_pointer\" rel=\"nofollow\"><code>std::is_pointer</code></a> somehow comes from Boost and is originally meant to detect raw pointers and function pointers only, here is the bottom note you can find in <a href=\"http://live.boost.org/doc/libs/1_58_0/libs/type_traits/doc/html/boost_typetraits/reference/is_pointer.html\" rel=\"nofollow\">Boost documentation</a>:</p>\n<blockquote>\n<p id=\"so_17065704_17065919_0\"><code>is_pointer</code> detects \"real\" pointer types only, and not smart pointers. Users should not specialise is_pointer for smart pointer types, as doing so may cause Boost (and other third party) code to fail to function correctly. Users wanting a trait to detect smart pointers should create their own. However, note that there is no way in general to auto-magically detect smart pointer types, so such a trait would have to be partially specialised for each supported smart pointer type.</p>\n</blockquote>\n<p>They probably just had it behave like that in the standard library for compatibility to keep a low level of surprise for users that already used it. Anyway, as you just demonstrated it, it is easy to create your own trait to detect smart pointers.</p>\n<p>Basically, what you are looking would be a trait that would look for types which implement the <code>Dereferenceable</code> concept (even though this one would also work for <code>std::optional</code> and not only pointers/smart pointers).</p>\n<p>And for the sake of completeness, Boost's <code>is_pointer</code> design is there to detect only raw pointers and not pointer-like classes. But the other answers should already give you some pretty good information about that.</p>\n", "LastEditorUserId": "1364752", "LastActivityDate": "2015-06-19T11:33:24.873", "Score": "10", "CreationDate": "2013-06-12T12:48:00.050", "ParentId": "17065704", "CommentCount": "9", "OwnerUserId": "1364752", "LastEditDate": "2015-06-19T11:33:24.873"}, "17065896": {"Id": "17065896", "PostTypeId": "2", "Body": "<p>While I agree that more general type traits, like <code>behaves_like_pointer</code> (excuse the stupid name), <code>is_callable</code> (for <em>all</em> things having <code>()</code>) or <code>is_indexable</code> (for array-like things) would be very useful, that is certainly not what things like <code>is_pointer</code>, <code>is_function</code> or <code>is_array</code> have been designed for. They are traits identifying actual hard language type categories, much the same like <code>is_integral</code>, <code>is_class</code> or <code>is_rvalue_reference</code>.</p>\n<p>So overlaoding <code>is_pointer</code> for any kind of smart pointer would conradict that original purpose, and that purpose is a clear and unambigous one. But I still agree that additional more general conceptual type categories like <code>is_smart_pointer</code>, <code>is_callable</code>, <code>is_nothrow_swappable</code> or <code>is_hashable</code> would be very useful, too.</p>\n", "LastActivityDate": "2013-06-12T12:47:23.167", "CommentCount": "0", "CreationDate": "2013-06-12T12:47:23.167", "ParentId": "17065704", "Score": "4", "OwnerUserId": "743214"}, "bq_ids": {"n4140": {"so_17065704_17066793_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 4695}}, "n3337": {"so_17065704_17066793_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 4504}}, "n4659": {"so_17065704_17066793_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 6090}}}, "17067040": {"Id": "17067040", "PostTypeId": "2", "Body": "<p>Other answers covered the technical details and some of the background. </p>\n<p>The idea of type_traits in std:: is to provide primitives. You use those out of the box, and do specializations <em>only</em> to cover your self-defined types to follow get reports correctly for the original semantics.</p>\n<p>What you want really (IMO) is not diverting the is_pointer template, but to have a query function that covert <em>your</em> semantics.  So that is what you should do: your own is_maybesmart_pointer&lt;&gt; that reports true for original pointers and whatever else you desire. And use that in your code.   </p>\n<p>Tweaking the original by the original idea would quite possibly lead to ODR violation as how do you know the libs you link did not already use is_pointer with a shared_ptr or something? </p>\n", "LastActivityDate": "2013-06-12T13:38:55.310", "CommentCount": "0", "CreationDate": "2013-06-12T13:38:55.310", "ParentId": "17065704", "Score": "0", "OwnerUserId": "2422194"}, "17065704": {"ViewCount": "2743", "Body": "<p>I think about overloading <a href=\"http://en.cppreference.com/w/cpp/types/is_pointer\" rel=\"nofollow\"><code>std::is_pointer</code></a> in C++11 to yield true for <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\"><code>std::shared_ptr&lt;T&gt;</code></a> as well, since the latter behaves very much as a <code>T*</code>.</p>\n<pre><code>#include &lt;type_traits&gt;\n\nnamespace std {\n\ntemplate &lt;typename T&gt; struct is_pointer&lt;shared_ptr&lt;T&gt;&gt; : std::true_type {};\ntemplate &lt;typename T&gt; struct is_pointer&lt;shared_ptr&lt;T const&gt;&gt; : std::true_type {};\n\n}\n</code></pre>\n<p>I wonder why this overload has not already been included in the standard implementation. Is there a pitfall that I'm overlooking?</p>\n<p>As an alternative one could of course introduce a new trait <code>is_shared_ptr&lt;T&gt;</code>.</p>\n<p>Actually, I tried the following code in the first place:</p>\n<pre><code>template &lt;typename T&gt; \nstruct is_pointer&lt;shared_ptr&lt;typename std::remove_cv&lt;T&gt;::type&gt;&gt;\n  : std::true_type \n{};\n</code></pre>\n<p>which does not compile with GCC 4.7 due to</p>\n<pre><code>error: template parameters not used in partial specialization:\nerror:         \u2018T\u2019\n</code></pre>\n", "AcceptedAnswerId": "17065919", "Title": "C++11: extending std::is_pointer to std::shared_ptr", "CreationDate": "2013-06-12T12:37:44.303", "Id": "17065704", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-01-21T15:40:36.057", "LastEditorUserId": "1364752", "LastActivityDate": "2016-01-21T15:40:36.057", "Score": "10", "OwnerUserId": "1498039", "Tags": "<c++><templates><c++11><shared-ptr><typetraits>", "AnswerCount": "4"}});