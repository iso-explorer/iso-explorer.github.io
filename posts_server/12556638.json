post_cb({"bq_ids": {"n4140": {"so_12556638_12557286_2": {"length": 109, "quality": 0.9159663865546218, "section_id": 4856}}, "n3337": {"so_12556638_12557286_2": {"length": 109, "quality": 0.9159663865546218, "section_id": 4651}}, "n4659": {"so_12556638_12557286_2": {"length": 109, "quality": 0.9159663865546218, "section_id": 5888}}}, "12556638": {"ViewCount": "3128", "Body": "<p>There is a template parameter for STL containers to chose a custom allocator. It took a while, but I think I understand how it works. Somehow it isn't really nice because the given allocator type isn't used directly but it is rebound to the allocator of another type. Finally I can work with it.</p>\n<p>After reading the <a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\" rel=\"noreferrer\">API</a> I recognized that there is also the possibility to give allocators as constructor parameter. But how do I know which kind of allocator the container uses, if it internally rebinds the given allocator from the template parameter?</p>\n<p>Additionally I read that C++11 now uses scoped allocators which allow to reuse the allocator of a container for its containing containers. How does the implementation of a scoped allocator enabled container roughly differs from one that is not aware of scoped containers?</p>\n<p>Unfortunately I wasn't able to find anything that could explain this. Thanks for answers!</p>\n", "AcceptedAnswerId": "12557286", "Title": "STL Container: Constructor's Allocator parameter and scoped allocators", "CreationDate": "2012-09-23T22:01:38.423", "Id": "12556638", "CommentCount": "0", "FavoriteCount": "7", "PostTypeId": "1", "LastActivityDate": "2012-09-23T23:51:00.497", "Score": "14", "OwnerUserId": "1678062", "Tags": "<c++><stl><c++11><containers><allocator>", "AnswerCount": "2"}, "12557286": {"Id": "12557286", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12556638_12557286_0\">But how do I know which kind of allocator the container uses, if it\n  internally rebinds the given allocator from the template parameter?</p>\n</blockquote>\n<p>Always supply an <code>Allocator&lt;T&gt;</code> to the constructor (where <code>T</code> is the <code>value_type</code> of the container).  The container will convert it to an <code>Allocator&lt;U&gt;</code> is necessary where <code>U</code> is some internal data structure of the container.  The <code>Allocator</code> is required to supply such converting constructors, e.g.:</p>\n<pre><code>template &lt;class T&gt; class allocator {\n    ...\n    template &lt;class U&gt; allocator(const allocator&lt;U&gt;&amp;);\n</code></pre>\n<blockquote>\n<p id=\"so_12556638_12557286_1\">Additionally I read that C++11 now uses scoped allocators which allow\n  to reuse the allocator of a container for its containing containers.</p>\n</blockquote>\n<p>Well, to be more precise, C++11 has an <em>allocator adaptor</em> called <code>scoped_allocator_adaptor</code>:</p>\n<pre><code>template &lt;class OuterAlloc, class... InnerAllocs&gt;\nclass scoped_allocator_adaptor : public OuterAlloc\n{\n    ...\n};\n</code></pre>\n<p>From C++11:</p>\n<blockquote>\n<p id=\"so_12556638_12557286_2\">The class template <code>scoped_allocator_adaptor</code> is an allocator template\n  that specifies the memory resource (the outer allocator) to be used by\n  a container (as any other allocator does) and also specifies an inner\n  allocator resource to be passed to the constructor of every element\n  within the container. This adaptor is instantiated with one outer and\n  zero or more inner allocator types. If instantiated with only one\n  alloca- tor type, the inner allocator becomes the\n  <code>scoped_allocator_adaptor</code> itself, thus using the same allocator\n  resource for the container and every element within the container and,\n  if the elements themselves are con- tainers, each of their elements\n  recursively. If instantiated with more than one allocator, the first\n  allocator is the outer allocator for use by the container, the second\n  allocator is passed to the constructors of the container\u2019s elements,\n  and, if the elements themselves are containers, the third allocator is\n  passed to the elements\u2019 elements, and so on. If containers are nested\n  to a depth greater than the number of allocators, the last allocator\n  is used repeatedly, as in the single-allocator case, for any remaining\n  recursions. [<em>Note</em>: The <code>scoped_allocator_adaptor</code> is derived from the\n  outer allocator type so it can be substituted for the outer allocator\n  type in most expressions. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>So you only get the scoped allocators behavior if you specify a <code>scoped_allocator_adaptor</code> as the allocator for your container.</p>\n<blockquote>\n<p id=\"so_12556638_12557286_3\">How does the implementation of a scoped allocator enabled container\n  roughly differs from one that is not aware of scoped containers?</p>\n</blockquote>\n<p>The key is that the container now deals with its allocator via a new class called <code>allocator_traits</code> instead of dealing with the allocator directly.  And the container <strong>must</strong> use <code>allocator_traits</code> for certain operations such as constructing and destructing <code>value_type</code>s in the container.  The container <strong>must not</strong> talk to the allocator directly.</p>\n<p>For example, allocators <em>may</em> provide a member called <code>construct</code> that will construct a type at a certain address using the given arguments:</p>\n<pre><code>template &lt;class T&gt; class Allocator {\n     ...\n    template&lt;class U, class... Args&gt;\n        void construct(U* p, Args&amp;&amp;... args);\n};\n</code></pre>\n<p>If an allocator does not provide this member, <code>allocator_traits</code> will provide a default implementation.  In any event, the container <strong>must</strong> construct all <code>value_type</code>s using this <code>construct</code> function, but using it through <code>allocator_traits</code>, and not using the <code>allocator</code> directly:</p>\n<pre><code>allocator_traits&lt;allocator_type&gt;::construct(the_allocator, *ugly details*);\n</code></pre>\n<p>The <code>scoped_allocator_adaptor</code> provides custom <code>construct</code> functions which <code>allocator_traits</code> will forward to which take advantage of the <code>uses_allocator</code> traits and passes the correct allocator along to the <code>value_type</code> constructor.  The container remains blissfully ignorant of these details.  The container only has to know that it must construct the <code>value_type</code> using the <code>allocator_traits construct</code> function.</p>\n<p>There are more details the container must have to deal with to correctly handle stateful allocators.  Though these details too are dealt with by having the container not make any assumptions but get all properties and behaviors via <code>allocator_traits</code>.  The container can not even assume that <code>pointer</code> is <code>T*</code>.  Rather this type is found by asking <code>allocator_traits</code> what it is.</p>\n<p>In short, to build a C++11 container, study up on <code>allocator_traits</code>.  And then you get scoped allocator behavior for free when your clients use the <code>scoped_allocator_adaptor</code>.</p>\n", "LastActivityDate": "2012-09-23T23:51:00.497", "CommentCount": "0", "CreationDate": "2012-09-23T23:51:00.497", "ParentId": "12556638", "Score": "13", "OwnerUserId": "576911"}, "12556765": {"Id": "12556765", "PostTypeId": "2", "Body": "<p>The type of the allocator used by a container is defined by its constructor argument: it is exactly this type which is expected in the container's constructors. However, any allocator needs to be able to serve different types than the one it is defined for. For example, for a <code>std::list&lt;T, A&gt;</code> the allocator expected is capable to allocate <code>T</code> object but it will never be used to allocate these object because the <code>std::list&lt;T, A&gt;</code> actually needs to allocate nodes. That is, the allocator will be rebound to allocate a different type. Unfortunately, this makes it hard to use an allocator to serve a specific type: You don't know the type the allocator will actually serve.</p>\n<p>With respect to scoped allocators it works quite straight forward: The container determines if it has any member with a constructor taking a matching allocator. If this is the case, it will rebind the allocator it used and passes this allocator to the member. What isn't that straight forward is the logic determining whether an allocator is being used. To determine if a member uses an allocator, the traits <code>std::uses_allocator&lt;T, A&gt;</code> is used: It determines if <code>T</code> has a nested <code>typedef allocator_type</code> which and if <code>A</code> can be converted to this type. The rules for how member objects are constructed are described in 20.6.7.2 [allocator.uses.construction].</p>\n<p>In practice this means that allocators are useful for dealing with a pool used for a container and its members. In some contexts it may also work reasonable when similar sized objects are allocated, e.g. for any of the node based containers, to keep a pool of equal sized objects. However, it isn't necessary clear from the pattern used with allocator if they are, e.g., for the nodes or some strings contained with. Also, since the use of different allocation policies would change the type, it seems most reasonable to either stick with the default allocation or to use an allocator type which is a proxy for a polymorphic allocator actually defining the allocation policy. Of course, the moment you have stateful allocators, you may have objects with different allocators and e.g. <code>swap()</code>ing them might not work.</p>\n", "LastActivityDate": "2012-09-23T22:22:37.817", "CommentCount": "0", "CreationDate": "2012-09-23T22:22:37.817", "ParentId": "12556638", "Score": "4", "OwnerUserId": "1120273"}});