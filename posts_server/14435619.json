post_cb({"14435619": {"CommentCount": "5", "AcceptedAnswerId": "14436738", "PostTypeId": "1", "LastEditorUserId": "179910", "CreationDate": "2013-01-21T09:23:22.953", "LastActivityDate": "2013-03-04T15:08:56.673", "LastEditDate": "2013-03-04T15:08:56.673", "ViewCount": "452", "FavoriteCount": "3", "Title": "Why doesnt this operator usage in the trailing return type compile?", "Id": "14435619", "Score": "18", "Body": "<p>I was trying to reuse the return type of an operator in my trailing return type of another function, but unfortunately clang did not accept it</p>\n<pre><code>struct A {\n  int operator[](int);\n  auto at(int i) -&gt; decltype((*this)[i]);\n};\n</code></pre>\n<p>Clang says that my class does not have a operator[]. Gcc did accept my code. Is my code actually invalid?</p>\n", "Tags": "<c++><c++11><operator-keyword><language-lawyer><trailing-return-type>", "OwnerUserId": "34509", "AnswerCount": "3"}, "14436468": {"ParentId": "14435619", "CommentCount": "2", "Body": "<p>just to re-iterate mine and Stephane's comment:</p>\n<p><strong>This is an obvious bug in clang</strong>, since your class obviously has an <code>operator[](int)</code>. </p>\n<p>Whether or not the code using <code>decltype()</code> is valid, is a subtly different question\n(I would say it is valid, but cannot prove it).</p>\n", "OwnerUserId": "1023390", "PostTypeId": "2", "Id": "14436468", "Score": "2", "CreationDate": "2013-01-21T10:18:02.083", "LastActivityDate": "2013-01-21T10:18:02.083"}, "14435945": {"ParentId": "14435619", "CommentCount": "5", "Body": "<p>It seems, that it's CLang's bug, because the next code</p>\n<pre><code>struct A {\n  int operator[](int);\n  auto at(int i) -&gt; decltype( this-&gt; operator[]( i ) );\n};\n</code></pre>\n<p>compiles by CLang as well - <a href=\"http://liveworkspace.org/code/2Myghk\" rel=\"nofollow\">http://liveworkspace.org/code/2Myghk</a>$6</p>\n", "OwnerUserId": "667266", "PostTypeId": "2", "Id": "14435945", "Score": "3", "CreationDate": "2013-01-21T09:44:40.313", "LastActivityDate": "2013-01-21T09:44:40.313"}, "bq_ids": {"n4140": {"so_14435619_14436738_0": {"section_id": 584, "quality": 0.8857142857142857, "length": 31}}, "n3337": {"so_14435619_14436738_0": {"section_id": 574, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_14435619_14436738_0": {"section_id": 607, "quality": 0.8857142857142857, "length": 31}}}, "14436738": {"ParentId": "14435619", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>I would say that clang is correct, due to 13.3.1.2p3 (1st bullet).</p>\n<blockquote>\n<p id=\"so_14435619_14436738_0\">For a unary operator <code>@</code> with an operand of a type whose cv-unqualified version is <code>T1</code>, and for a binary\n  operator <code>@</code> with a left operand of a type whose cv-unqualified version is <code>T1</code> and a right operand of a type\n  whose cv-unqualified version is <code>T2</code>, three sets of candidate functions, designated member candidates, nonmember\n  candidates and built-in candidates, are constructed as follows:</p>\n<ul>\n<li>If <code>T1</code> is a complete class type, the set of member candidates is the result of the qualified lookup of\n  <code>T1::operator@</code> (13.3.1.1.1); otherwise, <strong><em>the set of member candidates is empty</em></strong>.</li>\n</ul>\n</blockquote>\n<p>(emphasis added by @sehe)</p>\n", "OwnerUserId": "1996715", "LastEditorUserId": "85371", "LastEditDate": "2013-01-21T13:12:52.703", "Id": "14436738", "Score": "3", "CreationDate": "2013-01-21T10:33:57.997", "LastActivityDate": "2013-01-21T13:12:52.703"}});