post_cb({"32326444": {"ViewCount": "51", "Body": "<p>I have defined a class Bar inside a member function (constructor) Foo, that I am trying to use as a template parameter. </p>\n<pre><code>template&lt;typename Ty&gt;\nstruct Spam {\n    template&lt;class U, class D&gt; Spam(U*, D) {}\n};\nstruct Foo {\n    Foo() {\n        struct Bar {};\n        int *ptr = NULL;\n        Spam&lt;int&gt; pSpam(ptr, Bar());\n    }\n};\n</code></pre>\n<p>My guess is that the usage is invalid as the scope of Bar is local to Foo and cannot have a global visibility which is required for template instantiation. But on a second though, I am instantiating the template in the same scope of Bar, and though the template class/struct is global, there should not be any accessibility issues of the template instance.</p>\n<p>I tried across multiple compilers, and each behaves differently. Particularly </p>\n<ul>\n<li><p>clang accepted with warning </p>\n<pre><code>warning: template argument uses local type 'Bar' [-Wlocal-type-template-args]\n</code></pre></li>\n<li><p>VC++ compiled without warning</p></li>\n<li><p>GCC 4.3.4 compilation failed</p>\n<pre><code>10 : error: no matching function for call to 'Spam::Spam(int*&amp;, Foo::Foo()::Bar)'\n3 : note: candidates are: Spam::Spam(const Spam&amp;)\n</code></pre></li>\n<li><p>GCC C++14 compiled successfully</p></li>\n</ul>\n<p>What is the expected behaviour according to the standards?</p>\n", "Title": "Is using inline classes inside a function permitted to be used as template types?", "CreationDate": "2015-09-01T07:59:04.623", "LastActivityDate": "2015-09-01T08:12:05.333", "CommentCount": "3", "PostTypeId": "1", "ClosedDate": "2015-09-01T13:21:38.913", "Id": "32326444", "Score": "3", "OwnerUserId": "977038", "Tags": "<c++><templates><nested-class>", "AnswerCount": "1"}, "32326577": {"Id": "32326577", "PostTypeId": "2", "Body": "<p>C++2003 standard 14.3.1/2 specify that</p>\n<blockquote>\n<p id=\"so_32326444_32326577_0\">A local type, a type with no linkage, an unnamed type or a type\n  compounded from any of these types shall not be used as a\n  template-argument for a template type-parameter.</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; class X { /* ... */ };\nvoid f()\n{\n   struct S { /* ... */ };\n   X&lt;S&gt; x3; // error: local type used as template-argument\n   X&lt;S*&gt; x4;  // error: pointer to local type used as template-argument\n}\n</code></pre>\n<p>But it is allowed in C++11 and higher.</p>\n<p>N3797 14.3.1/2</p>\n<pre><code>template &lt;class T&gt; class X { };\ntemplate &lt;class T&gt; void f(T t) { }\nstruct { } unnamed_obj;\nvoid f() \n{\n   struct A { };\n   enum { e1 };\n   typedef struct { } B;\n   B b;\n   X&lt;A&gt; x1; // OK\n   X&lt;A*&gt; x2; // OK\n   X&lt;B&gt; x3; // OK\n   f(e1); // OK\n   f(unnamed_obj); // OK\n   f(b); // OK\n}\n</code></pre>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2015-09-01T08:12:05.333", "Score": "3", "CreationDate": "2015-09-01T08:06:56.117", "ParentId": "32326444", "CommentCount": "0", "OwnerUserId": "1498580", "LastEditDate": "2015-09-01T08:12:05.333"}, "bq_ids": {"n4140": {"so_32326444_32326577_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 7141}}, "n3337": {"so_32326444_32326577_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6885}}, "n4659": {"so_32326444_32326577_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 8642}}}});