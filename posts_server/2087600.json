post_cb({"2087608": {"Id": "2087608", "PostTypeId": "2", "Body": "<p>The destructor will not be called until the object goes out of scope.</p>\n<p>The <a href=\"http://www.parashift.com/c++-faq-lite/dtors.html\" rel=\"nofollow noreferrer\">C++ faq lite</a> has a good section on dtors</p>\n", "LastActivityDate": "2010-01-18T16:42:30.643", "CommentCount": "1", "CreationDate": "2010-01-18T16:42:30.643", "ParentId": "2087600", "Score": "18", "OwnerUserId": "102371"}, "2088683": {"Id": "2088683", "PostTypeId": "2", "Body": "<p>All of the answers here address what happens with named objects, but for completeness, you probably should know the rule for temporary/anonymous objects too. (e.g. <code>f(SomeObjectConstructor()</code> or <code>f(someFunctionThatReturnsAnObject())</code>)</p>\n<blockquote>\n<p id=\"so_2087600_2088683_0\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true even if that evaluation ends in throwing an exception. (12.2/3 from the ISO C++98 standard)</p>\n</blockquote>\n<p>which basically means that temporarily generated objects persist until the next statement.  Two exceptions are for temporaries generated as part of an object's initialization list (in which case the temporary is destroyed only after the object is fully constructed) and if a reference is made to a temporary (e.g. <code>const Foo&amp; ref = someFunctionThatReturnsAnobject()</code>) (which case the lifetime of the object is the lifetime of the reference).</p>\n", "LastEditorUserId": "179715", "LastActivityDate": "2010-01-18T21:28:05.997", "Score": "2", "CreationDate": "2010-01-18T19:34:34.947", "ParentId": "2087600", "CommentCount": "2", "OwnerUserId": "179715", "LastEditDate": "2010-01-18T21:28:05.997"}, "2087600": {"ViewCount": "5758", "Body": "<p>In the C++ code below, am I guaranteed that the ~obj() destructor will be called <strong>after</strong> the // More code executes? Or is the compiler allowed to destruct the obj object earlier if it detects that it's not used?</p>\n<pre><code>{\n  SomeObject obj;\n  ... // More code\n}\n</code></pre>\n<p>I'd like to use this technique to save me having to remember to reset a flag at the end of the block, but I need the flag to remain set for the whole block.</p>\n", "AcceptedAnswerId": "2087621", "Title": "Is a C++ destructor guaranteed not to be called until the end of the block?", "CreationDate": "2010-01-18T16:41:36.653", "Id": "2087600", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-01-18T16:43:33.043", "LastEditorUserId": "12183", "LastActivityDate": "2010-01-18T21:28:05.997", "Score": "31", "OwnerUserId": "19169", "Tags": "<c++><raii>", "AnswerCount": "8"}, "2087621": {"Id": "2087621", "PostTypeId": "2", "Body": "<p>You are OK with this - it's a very commonly used pattern in C++ programming. From the C++ Standard section 12.4/10, referring to when a destructor is called:</p>\n<blockquote>\n<p id=\"so_2087600_2087621_0\">for a constructed object with\n  automatic storage duration \n  when the block in which the object is\n  created exits</p>\n</blockquote>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2010-01-18T16:43:52.280", "Score": "44", "CreationDate": "2010-01-18T16:43:52.280", "ParentId": "2087600", "CommentCount": "2"}, "2087668": {"Id": "2087668", "PostTypeId": "2", "Body": "<p>Yes, it is guaranteed. </p>\n<p>The lifetime of an object with automatic storage duration ends at the end of its <em>potential scope</em> and not before. For such an object the potential scope begins at the point of declaration and ends at the end of the block in which it is declared. This is the moment when the destructor will be called.</p>\n<p>Note, that very pedantically speaking, even for an automatic object it is not correct to say it is destroyed when it \"goes out of scope\" (as opposed to \"goes out of its <em>potential</em> scope\"). The object can go out of scope and back into scope many times (if even more local objects with the same name are declared within the block), and going out of scope in such fashion does not cause the destruction of the object. It is the \"very final end\" of its scope that kills the automatic object, which is defined as the end of its <em>potential scope</em> as described above.</p>\n<p>In fact, the language standard does not even rely on the notion of <em>scope</em> to describe the lifetime of automatic objects (no need to deal with all these terminological intricacies). It just says that the object is destroyed at the exit of the block in which it is defined :)</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-01-18T19:05:35.933", "Score": "5", "CreationDate": "2010-01-18T16:51:18.550", "ParentId": "2087600", "CommentCount": "1", "OwnerUserId": "187690", "LastEditDate": "2010-01-18T19:05:35.933"}, "2088114": {"Id": "2088114", "PostTypeId": "2", "Body": "<p><em>Actually...</em></p>\n<p>C++ has something called the \"as if\" principle. All the guarentees made referenced in all of these answers only refer to the <em>observable</em> behavior. The compiler is allowed to ellude, reorder, add, etc.. any function call, as long as the observable behavior is as if it had executed as originally written. This also applies to destructors.</p>\n<p>So, technically, your observation is correct: the compiler <em>is</em> allowed to destruct the object earlier, if it detects it is not used, <strong>and</strong> there are no observable side effects from the destructor or any function it calls. But, you are guarenteed to not be able to tell this is happening outside of a debugger, because if you were able to tell, the compiler would no longer be able to do it.</p>\n<p>It's more likely the compiler uses this power to do something useful like completely ellude a trivial destructor rather than actually reorder destructor calls, however.</p>\n<p><strong>Edit:</strong> Someone wanted a reference... 1.9/5, along with footnote 4 of the C++0x draft standard (this isn't a new rule, I just don't have the C++03 standard handy. It's also present in the C standard, AFAIK)</p>\n<p>1.9/5:</p>\n<p>A conforming implementation executing a well-formed program shall produce the same observable behavior\nas one of the possible execution sequences of the corresponding instance of the abstract machine with the\nsame program and the same input. However, if any such execution sequence contains an undefined operation,\nthis International Standard places no requirement on the implementation executing that program with that\ninput (not even with regard to operations preceding the first undefined operation).</p>\n<p>Footnote 4:</p>\n<p>This provision is sometimes called the \u201cas-if\u201d rule, because an implementation is free to disregard any requirement of this\nInternational Standard as long as the result is as if the requirement had been obeyed, as far as can be determined from the\nobservable behavior of the program. For instance, an actual implementation need not evaluate part of an expression if it can\ndeduce that its value is not used and that no side effects affecting the observable behavior of the program are produced.</p>\n<p>My reading (and what I thought was the general understanding) was that this is what enables the compiler free hand to do whatever it wants (ie, enables optimizations), as long as the observable behavior is that of the original written source - including moving around destructors, not destructing objects at all, inventing destructors, etc.</p>\n", "LastEditorUserId": "238128", "LastActivityDate": "2010-01-18T18:16:26.020", "Score": "20", "CreationDate": "2010-01-18T18:01:46.037", "ParentId": "2087600", "CommentCount": "9", "OwnerUserId": "238128", "LastEditDate": "2010-01-18T18:16:26.020"}, "bq_ids": {"n4140": {"so_2087600_2087621_0": {"length": 10, "quality": 1.0, "section_id": 407}, "so_2087600_2088683_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 380}}, "n3337": {"so_2087600_2087621_0": {"length": 9, "quality": 0.9, "section_id": 398}, "so_2087600_2088683_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 371}}, "n4659": {"so_2087600_2087621_0": {"length": 10, "quality": 1.0, "section_id": 425}, "so_2087600_2088683_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 395}}}, "2087650": {"Id": "2087650", "PostTypeId": "2", "Body": "<p>Yes, the C++ standard has very specific requirements about when objects are destroyed (in \u00a712.4/10), and in this case it must not be destroyed until after all the other code in the block has finished executing.</p>\n", "LastActivityDate": "2010-01-18T16:48:19.967", "CommentCount": "0", "CreationDate": "2010-01-18T16:48:19.967", "ParentId": "2087600", "Score": "3", "OwnerUserId": "179910"}, "2087652": {"Id": "2087652", "PostTypeId": "2", "Body": "<p>Destruction in C++ is deterministic - meaning that the compiler is not free to move that code around.  (Of course optimization might inline the destructor, determine that the destructor code does not interact with <code>// More code</code> and do some instruction reordering, but that's another issue)</p>\n<p>If you couldn't depend on the destructors being called when they are supposed to be called, you couldn't use RAII to grab locks (or just about any other RAII construct for that matter):</p>\n<pre><code>{\n    LockClass lock(lockData);\n    // More code\n} // Lock automatically released.\n</code></pre>\n<p>Also, you can depend on destructors running in reverse order of how the objects were constructed.</p>\n", "LastActivityDate": "2010-01-18T16:48:38.150", "CommentCount": "3", "CreationDate": "2010-01-18T16:48:38.150", "ParentId": "2087600", "Score": "9", "OwnerUserId": "8701"}, "2087657": {"Id": "2087657", "PostTypeId": "2", "Body": "<p>A typical example of this, just as your question is the boost::scoped_ptr (or similar std::auto_ptr) :</p>\n<pre><code>{\n    boost::scoped_ptr&lt; MyClass &gt; pMyClass( new MyClass );\n\n    // code using pMyClass here\n\n} // destruction of MyClass and memory freed\n</code></pre>\n", "LastActivityDate": "2010-01-18T16:48:54.560", "CommentCount": "2", "CreationDate": "2010-01-18T16:48:54.560", "ParentId": "2087600", "Score": "1", "OwnerUserId": "233522"}});