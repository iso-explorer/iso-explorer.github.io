post_cb({"46276071": {"ParentId": "46272501", "Score": "8", "CreationDate": "2017-09-18T09:35:56.223", "LastActivityDate": "2017-09-20T05:41:42.560", "LastEditDate": "2017-09-20T05:41:42.560", "OwnerUserId": "2411320", "LastEditorUserId": "2756719", "Body": "<p>For implementing <a href=\"http://eel.is/c++draft/pairs.pair#12\" rel=\"nofollow noreferrer\">[pairs.pair]/12</a>:</p>\n<blockquote>\n<p id=\"so_46272501_46276071_0\">This constructor shall not participate in overload resolution unless <code>is_\u00adconstructible_\u00adv&lt;first_\u00adtype, U1&amp;&amp;&gt;</code> is true and\n  <code>is_\u00adconstructible_\u00adv&lt;second_\u00adtype, U2&amp;&amp;&gt;</code> is true.\n      <em>The constructor is explicit if and only if <code>is_\u00adconvertible_\u00adv&lt;U1&amp;&amp;, first_\u00adtype&gt;</code> is false or\n  <code>is_\u00adconvertible_\u00adv&lt;U2&amp;&amp;, second_\u00adtype&gt;</code> is false.</em></p>\n</blockquote>\n", "Id": "46276071", "PostTypeId": "2", "CommentCount": "2"}, "46287145": {"ParentId": "46272501", "Score": "9", "CreationDate": "2017-09-18T19:51:14.990", "LastActivityDate": "2017-09-18T19:57:23.200", "LastEditDate": "2017-09-18T19:57:23.200", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "Body": "<blockquote>\n<p id=\"so_46272501_46287145_0\">I think <code>is_constructible</code> is enough, why are we using <code>is_convertible</code> here? </p>\n</blockquote>\n<p>The goal here is to properly handle <code>explicit</code> construction. Consider just doing the former and trying to write a wrapper (using <code>REQUIRES</code> here to hide whatever approach to SFINAE you want):</p>\n<pre><code>template &lt;class T&gt;\nclass wrapper {\npublic:\n    template &lt;class U, REQUIRES(std::is_constructible&lt;T, U&amp;&amp;&gt;::value)&gt;\n    wrapper(U&amp;&amp; u) : val(std::forward&lt;U&gt;(u)) { }\nprivate:\n    T val;\n};\n</code></pre>\n<p>If that's all we had, then:</p>\n<pre><code>struct Imp { Imp(int ); };\nstruct Exp { explicit Exp(int ); };\n\nImp i = 0; // ok\nExp e = 0; // error\nwrapper&lt;Imp&gt; wi = 0; // ok\nwrapper&lt;Exp&gt; we = 0; // ok?!?\n</code></pre>\n<p>We definitely don't want that last one to be okay - that breaks the expectation for <code>Exp</code>! </p>\n<p>Now, <code>s_constructible&lt;T, U&amp;&amp;&gt;</code> is true if it's possible to direct-initialize a <code>T</code> from a <code>U&amp;&amp;</code> - if <code>T(std::declval&lt;U&amp;&amp;&gt;())</code>  is a valid expression. </p>\n<p><code>is_convertible&lt;U&amp;&amp;, T&gt;</code>, on the other hand, checks if it is possible to <em>copy</em>-initialize a <code>T</code> from a <code>U&amp;&amp;</code>. That is, if <code>T copy() { return std::declval&lt;U&amp;&amp;&gt;(); }</code> is valid. </p>\n<p>The difference is that the latter does not work if the conversion is <code>explicit</code>:</p>\n<pre><code>+-----+--------------------------+------------------------+\n|     | is_constructible&lt;T, int&gt; | is_convertible&lt;int, T&gt; |\n+-----+--------------------------+------------------------+\n| Imp |        true_type         |       true_type        |\n| Exp |        true_type         |       false_type       |\n+-----+--------------------------+------------------------+\n</code></pre>\n<p>In order to correctly propagate explicitness, we need to use both traits together - and we can create meta-traits out of them:</p>\n<pre><code>template &lt;class T, class From&gt;\nusing is_explicitly_constructible = std::integral_constant&lt;bool,\n    std::is_constructible&lt;T, From&gt;::value &amp;&amp;\n    !std::is_convertible&lt;From, T&gt;::value&gt;;\n\ntemplate &lt;class T, class From&gt;\nusing is_implicitly_constructible = std::integral_constant&lt;bool,\n    std::is_constructible&lt;T, From&gt;::value &amp;&amp;\n    std::is_convertible&lt;From, T&gt;::value&gt;;\n</code></pre>\n<p>These two traits are disjoint, so we can write two constructor templates that are definitely not both viable, where one constructor is explicit and the other is not:</p>\n<pre><code>template &lt;class T&gt;\nclass wrapper {\npublic:\n    template &lt;class U, REQUIRES(is_explicitly_constructible&lt;T, U&amp;&amp;&gt;::value)&gt;\n    explicit wrapper(U&amp;&amp; u) : val(std::forward&lt;U&gt;(u)) { }\n\n    template &lt;class U, REQUIRES(is_implicitly_constructible&lt;T, U&amp;&amp;&gt;::value)&gt;\n    wrapper(U&amp;&amp; u) : val(std::forward&lt;U&gt;(u)) { }\nprivate:\n    T val;\n};\n</code></pre>\n<p>This gives us the desired behavior:</p>\n<pre><code>wrapper&lt;Imp&gt; wi = 0; // okay, calls non-explicit ctor\nwrapper&lt;Exp&gt; we = 0; // error\nwrapper&lt;Exp&gt; we2(0); // ok\n</code></pre>\n<p>This is what the implementation is doing here - except instead of the two meta-traits they have all of the conditions written out <code>explicit</code>ly. </p>\n", "Id": "46287145", "PostTypeId": "2", "CommentCount": "0"}, "46272501": {"Tags": "<c++><c++1z><standard-library>", "ViewCount": "203", "LastEditDate": "2017-09-19T05:00:31.050", "CreationDate": "2017-09-18T06:01:24.880", "LastEditorUserId": "2411320", "Title": "Why 'is_convertible' here in <utility> std::pair (STL)?", "CommentCount": "1", "AcceptedAnswerId": "46287145", "Score": "7", "OwnerUserId": "8624873", "Id": "46272501", "LastActivityDate": "2017-09-20T05:41:42.560", "Body": "<pre><code>    template&lt;class _Other1,\n    class _Other2,\n    class = enable_if_t&lt;is_constructible&lt;_Ty1, _Other1&gt;::value\n                    &amp;&amp; is_constructible&lt;_Ty2, _Other2&gt;::value&gt;,\n    enable_if_t&lt;is_convertible&lt;_Other1, _Ty1&gt;::value\n            &amp;&amp; is_convertible&lt;_Other2, _Ty2&gt;::value, int&gt; = 0&gt;\n    constexpr pair(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right)\n        _NOEXCEPT_OP((is_nothrow_constructible&lt;_Ty1, _Other1&gt;::value\n            &amp;&amp; is_nothrow_constructible&lt;_Ty2, _Other2&gt;::value))\n    : first(_STD forward&lt;_Other1&gt;(_Right.first)),\n        second(_STD forward&lt;_Other2&gt;(_Right.second))\n    {   // construct from moved compatible pair\n    }\n\ntemplate&lt;class _Other1,\n    class _Other2,\n    class = enable_if_t&lt;is_constructible&lt;_Ty1, _Other1&gt;::value\n                    &amp;&amp; is_constructible&lt;_Ty2, _Other2&gt;::value&gt;,\n    enable_if_t&lt;!is_convertible&lt;_Other1, _Ty1&gt;::value\n            || !is_convertible&lt;_Other2, _Ty2&gt;::value, int&gt; = 0&gt;\n    constexpr explicit pair(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right)\n        _NOEXCEPT_OP((is_nothrow_constructible&lt;_Ty1, _Other1&gt;::value\n            &amp;&amp; is_nothrow_constructible&lt;_Ty2, _Other2&gt;::value))\n    : first(_STD forward&lt;_Other1&gt;(_Right.first)),\n        second(_STD forward&lt;_Other2&gt;(_Right.second))\n    {   // construct from moved compatible pair\n    }\n</code></pre>\n<p><em>utility</em> file for VS 2017 line 206,\n_Other1 and _Other2 are parameters, this is <strong>std::pair</strong>'s construction func,\nand we are using Other1 and Other2 to <strong>initialize</strong> \"first\" and \"second\",\n<br/><br/>I think <strong>is_constructible</strong> is enough, why are we using <strong>is_convertible</strong> here? <br/> and by the way, what's the difference between <code>class = enable_if_t&lt; ... ::value&gt;</code> and <code>enable_if_t&lt; ... ::value,int&gt; = 0</code>?</p>\n", "PostTypeId": "1", "AnswerCount": "2"}, "bq_ids": {"n4659": {"so_46272501_46276071_0": {"length": 16, "section_id": 4877, "quality": 0.8888888888888888}}}});