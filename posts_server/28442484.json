post_cb({"28442484": {"ViewCount": "33", "Body": "<p>I have the following code:</p>\n<pre><code>struct type1\n{\n    struct type2\n    {\n\n    };\n    int tyep2; // No conflic with real type name path: type1::type2\n};\n\nstruct type4\n{\n    struct type5\n    {\n\n    };\n    static int type5; // No conflic with real type name path: type4::type5\n\n};\n\nint type4::type5;  // this path name is equal to type name path: struct type4::type5  \n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    type1::type2 var1; // is ok\n    type4::type5 Var2; // is ok\n    type4::type5 = 0; // is ok, but the static variable has obscured my type \n    return 0;\n}\n</code></pre>\n<p>My questions are: </p>\n<ol>\n<li>why the static variable <strong><em>type5</em></strong> hides the type\n<strong><em>type4::type5</em></strong></li>\n<li>Why the compiler does not generate an error when I declare <strong><em>type5</em></strong> variable? </li>\n<li>Where I can read about this behaviour in the C++ standard specification? Please post eventually an extract</li>\n</ol>\n", "AcceptedAnswerId": "28442828", "Title": "the type name path is hidden by a static variable", "CreationDate": "2015-02-10T21:47:55.060", "Id": "28442484", "CommentCount": "2", "LastEditDate": "2015-02-10T22:55:23.763", "PostTypeId": "1", "LastEditorUserId": "845092", "LastActivityDate": "2015-02-10T22:55:23.763", "Score": "-3", "OwnerUserId": "3286797", "Tags": "<c++>", "AnswerCount": "2"}, "28442828": {"Id": "28442828", "PostTypeId": "2", "Body": "<p>Your program is ill-formed because of name ambiguity (ignoring the misspelled \"tyep\" you have scattered around)</p>\n<blockquote>\n<p id=\"so_28442484_28442828_0\"><strong>\u00a7 10.2 Member name lookup</strong></p>\n<p id=\"so_28442484_28442828_1\">Member name lookup determines the meaning of a name (id-expression) in a class scope (3.3.7). Name\n  lookup can result in an ambiguity, in which case the program is ill-formed. For an id-expression, name\n  lookup begins in the class scope of this; for a qualified-id, name lookup begins in the scope of the nestedname-\n  specifier. Name lookup takes place before access control (3.4, Clause 11).</p>\n</blockquote>\n<p>Don't do this:</p>\n<pre><code>struct type5\n{\n   //...\n};\nstatic int type5;\n</code></pre>\n<p>Unsurprisingly, this doesn't compile for me on ideone. <a href=\"http://ideone.com/A7t5O1\" rel=\"nofollow\">Live Demo</a></p>\n", "LastActivityDate": "2015-02-10T22:07:30.380", "CommentCount": "2", "CreationDate": "2015-02-10T22:07:30.380", "ParentId": "28442484", "Score": "2", "OwnerUserId": "27678"}, "28442554": {"Id": "28442554", "PostTypeId": "2", "Body": "<p>1) t<strong>YE</strong>p5 != type5</p>\n<p>2) the same reason</p>\n", "LastActivityDate": "2015-02-10T21:51:49.560", "CommentCount": "1", "CreationDate": "2015-02-10T21:51:49.560", "ParentId": "28442484", "Score": "0", "OwnerUserId": "1554502"}, "bq_ids": {"n4140": {"so_28442484_28442828_1": {"length": 35, "quality": 0.8974358974358975, "section_id": 6989}}, "n3337": {"so_28442484_28442828_1": {"length": 35, "quality": 0.8974358974358975, "section_id": 6735}}, "n4659": {"so_28442484_28442828_1": {"length": 35, "quality": 0.8974358974358975, "section_id": 8487}}}});