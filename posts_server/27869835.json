post_cb({"27870000": {"ParentId": "27869835", "CommentCount": "0", "Body": "<p>When a function is a non-static member function of a class, then it is necessary to use the form <code>&amp;ClassName::functionName</code> when a pointer to the member function is expected in an expression.</p>\n<p>When a function is a static member function of a class, both <code>ClassName::functionName</code> and <code>&amp;ClassName;:functionName</code> can be used when a pointer to a function is expected in an expression.</p>\n<p>When a function is a global, i.e. non-member, function, both <code>functionName</code> and <code>&amp;functionName</code> can be used when a pointer to a function is expected in an expression.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "27870000", "Score": "2", "CreationDate": "2015-01-09T22:05:06.480", "LastActivityDate": "2015-01-09T22:05:06.480"}, "27869835": {"CommentCount": "4", "AcceptedAnswerId": "27869972", "PostTypeId": "1", "LastEditorUserId": "2487152", "CreationDate": "2015-01-09T21:50:46.717", "LastActivityDate": "2015-01-10T02:40:12.870", "LastEditDate": "2015-01-10T02:40:12.870", "ViewCount": "735", "FavoriteCount": "2", "Title": "What is the difference between &foo::function and foo::function?", "Id": "27869835", "Score": "19", "Body": "<p>I am using the gtkmm library on linux to draw a simple menu for my GUI.</p>\n<p>In the below code the compiler complained about unable to resolve address</p>\n<pre><code>        sigc::mem_fun(*this, AppWindow::hide)));\n                                         ^\nappwindow.cpp:15:41: note:   could not resolve address from overloaded function\n</code></pre>\n<p>But when I insert the <code>&amp;</code> it compiles fine</p>\n<pre><code>m_menu_app.items().push_back(MenuElem(\"Quit\",\n    sigc::mem_fun(*this, &amp;AppWindow::hide)));\n</code></pre>\n<p>What difference does it make here? Isn't the <code>hide</code> function just an address in the first place?</p>\n", "Tags": "<c++><function-pointers>", "OwnerUserId": "295128", "AnswerCount": "3"}, "27869976": {"ParentId": "27869835", "CommentCount": "1", "Body": "<p>For global (non-member) functions, the name of the function evaluates to the address of that function except when passed to the <code>&amp;</code> operator, so you can (for example) assign to a pointer to a function either with or without the <code>&amp;</code> equivalently:</p>\n<pre><code>int f() {}\n\nint (*pf1)() = f;\nint (*pf2)() = &amp;f;\n</code></pre>\n<p>So, in this case there's really no difference between the two.</p>\n<p>For <em>member</em> functions<sup>1</sup>, however, the rules are a bit different. In this case, the <code>&amp;</code> is required; if you attempt to omit the <code>&amp;</code>, the code simply won't compile (assuming a properly functioning compiler, anyway).</p>\n<p>There's no particular reason this would have to be the case--it's just how Bjarne decided things should be. If he'd decided he wanted the name of a member function to evaluate to a pointer to a member (equivalent to how things work for non-member functions) he could have done that.</p>\n<hr>\n<p><sup>\n1. Other than static member functions, which mostly act like non-member functions.\n</sup></p>\n</hr>", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "27869976", "Score": "5", "CreationDate": "2015-01-09T22:03:01.443", "LastActivityDate": "2015-01-09T22:03:01.443"}, "bq_ids": {"n4140": {"so_27869835_27869972_1": {"section_id": 12, "quality": 0.9333333333333333, "length": 14}, "so_27869835_27869972_0": {"section_id": 12, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_27869835_27869972_1": {"section_id": 9, "quality": 0.9333333333333333, "length": 14}, "so_27869835_27869972_0": {"section_id": 9, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_27869835_27869972_0": {"section_id": 13, "quality": 0.8333333333333334, "length": 10}, "so_27869835_27869972_1": {"section_id": 13, "quality": 0.9333333333333333, "length": 14}}}, "27869972": {"ParentId": "27869835", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This is the exact definition of the function-to-pointer conversion, [conv.func]:</p>\n<blockquote>\n<p id=\"so_27869835_27869972_0\">An lvalue of function type <code>T</code> can be converted to a prvalue of type\n  \u201cpointer to <code>T</code>.\u201d The result is a pointer to the function.<sup>55</sup></p>\n<hr>\n<p id=\"so_27869835_27869972_1\"><sup>55)</sup> <strong>This conversion never applies to non-static member functions because an lvalue that refers to a non-static member function\n  cannot be obtained</strong>.<sup></sup></p>\n</hr></blockquote>\n<p>Thus the decay that we see with normal, non-member functions<sup>1</sup> doesn't apply and you need to explicitly take the address.</p>\n<p>I.e.</p>\n<pre><code>void f();\n\nstruct A {\n    void f();\n    static void g();\n};\n\n\nauto a = f; // Ok: auto deduced as void(*)()\nauto b = A::f; // Error: A::f not an lvalue, auto cannot be deduced\nauto c = A::g; // Ok: auto deduced as void(*)()\n</code></pre>\n<p><hr>\n<sup>1</sup> Or static member functions.</hr></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-09T22:08:24.443", "Id": "27869972", "Score": "15", "CreationDate": "2015-01-09T22:02:48.050", "LastActivityDate": "2015-01-09T22:08:24.443"}});