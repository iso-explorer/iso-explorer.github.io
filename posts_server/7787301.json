post_cb({"bq_ids": {"n4140": {"so_7787301_7787405_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 233}}, "n3337": {"so_7787301_7787405_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 226}}, "n4659": {"so_7787301_7787405_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 243}}}, "7787405": {"Id": "7787405", "PostTypeId": "2", "Body": "<p>I think so. 14.7.1/1 </p>\n<blockquote>\n<p id=\"so_7787301_7787405_0\">The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but not of the definitions or default arguments, of [...] scoped member enumerations</p>\n</blockquote>\n", "LastActivityDate": "2011-10-16T21:19:02.267", "CommentCount": "1", "CreationDate": "2011-10-16T21:19:02.267", "ParentId": "7787301", "Score": "10", "OwnerUserId": "212870"}, "7787301": {"ViewCount": "334", "Body": "<p>Consider this one</p>\n<pre><code>template&lt;typename T&gt;\nstruct A {\n  enum class X {\n    V = T()\n  };\n};\n</code></pre>\n<p>For member classes and member functions, C++11 (and C++03) won't instantiate their definition unless we use them in a way that requires their definition. Is this true for <code>enum class</code>? </p>\n<pre><code>// valid?\nA&lt;std::string&gt; a;\n</code></pre>\n<p>Unfortunately, I can't check compilers, since C++11 is just out of the door and everything isn't reliable yet, it seems.</p>\n", "AcceptedAnswerId": "7787405", "Title": "Are \"enum class\" members instantiated immediately or later when used?", "CreationDate": "2011-10-16T21:02:07.363", "Id": "7787301", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-10-16T21:19:02.267", "Score": "12", "OwnerUserId": "34509", "Tags": "<c++><c++11>", "AnswerCount": "1"}});