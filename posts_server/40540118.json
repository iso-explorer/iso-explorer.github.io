post_cb({"bq_ids": {"n4140": {"so_40540118_40540130_1": {"length": 6, "quality": 0.75, "section_id": 3321}}, "n3337": {"so_40540118_40540130_1": {"length": 6, "quality": 0.75, "section_id": 3191}}, "n4659": {"so_40540118_40540130_1": {"length": 6, "quality": 0.75, "section_id": 4087}}}, "40540130": {"Id": "40540130", "PostTypeId": "2", "Body": "<p>That's because the language rules are designed this way. You can bind an rvalue to a const lvalue reference (and extend its lifetime to that of the reference), because it is explicitly allowed.</p>\n<p>Assuming C++03 since you're using g++ 4.1.2</p>\n<blockquote>\n<p id=\"so_40540118_40540130_0\">\u00a7 8.5.3 [dcl.init.ref] / 5</p>\n<p id=\"so_40540118_40540130_1\">A reference to type \u201ccv1T1\u201d is initialized by an expression of type\n  \u201ccv2T2\u201d as follows:</p>\n<ul>\n<li>If the initializer expression\n  \n  <ul>\n<li>is an lvalue (but is not a bit-field), and \u201ccv1T1\u201d is reference-compatible with \u201ccv2T2,\u201d or</li>\n<li>has a class type (i.e.,T2is a class type) and can be implicitly converted to an lvalue of type [...]</li>\n</ul></li>\n<li>Otherwise, <em>the reference shall be to a non-volatile const type</em> [...]\n  \n  <ul>\n<li>If the initializer expression is an rvalue, withT2a class type, and \u201ccv1T1\u201d is reference-compatible with \u201ccv2T2,\u201d [...]</li>\n<li>Otherwise, a temporary of type \u201ccv1T1\u201d is created and initialized from the initializer expression using the rules for a non-reference\n  copy initialization (8.5).  <em>The reference is then bound to the\n  temporary.</em></li>\n</ul></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "2456565", "LastActivityDate": "2016-11-11T02:23:57.973", "Score": "3", "CreationDate": "2016-11-11T02:12:28.653", "ParentId": "40540118", "CommentCount": "0", "LastEditDate": "2016-11-11T02:23:57.973", "OwnerUserId": "2456565"}, "40540118": {"ViewCount": "60", "Body": "<p>I am using g++4.1.2 to compile this:</p>\n<pre><code>    cat 1.cpp\n#include&lt;iostream&gt; \n#include&lt;string&gt; \nusing namespace std; \nvoid f(const string&amp; s){} \nvoid g(string&amp; s){} \nvoid h(string s){} \nint main() \n{ \n    string s=\"abc\"; \n    f(\"abc\"); \n    g(\"abc\u201d);//Error \n    h(\"abc\"); \n    return 0; \n} \n</code></pre>\n<p>It failed at line \u201cg();\u201d</p>\n<pre><code>$ g++ 1.cpp \n1.cpp: In function \u2018int main()\u2019: \n    1.cpp:11: error: invalid initialization of non-const reference of type \u2018std::string&amp;\u2019 from a    temporary of type \u2018const char*\u2019 \n1.cpp:5: error: in passing argument 1 of \u2018void g(std::string&amp;)\u2019 \n</code></pre>\n<p>I don\u2019t quite understand that, as long as \u201cabc\u201d could be the constructor parameter for std::string:</p>\n<blockquote>\n<p id=\"so_40540118_40540118_0\">For f()\uff0c\"abc\" can be used to construct a string(const char*), as a const reference to string</p>\n<p id=\"so_40540118_40540118_1\">For h() \u201cabc\u201d can be used to construct a r-value, temporary std::string object.</p>\n</blockquote>\n<p>For g()\uff0cwhy it cannot be used to construct a left-value reference string&amp;, while const reference string&amp; is OK?</p>\n", "AcceptedAnswerId": "40540130", "Title": "C++: Pass string literal as a string& leads to compilation failure, why", "CreationDate": "2016-11-11T02:10:19.847", "Id": "40540118", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-11-11T02:23:57.973", "Score": "0", "OwnerUserId": "6164172", "Tags": "<c++><string><char><const><literals>", "AnswerCount": "1"}});