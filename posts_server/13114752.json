post_cb({"13115617": {"Id": "13115617", "PostTypeId": "2", "Body": "<p>Looking through the standard, I found, in \u00a79.6:</p>\n<blockquote>\n<p id=\"so_13114752_13115617_0\">The constant-expression may be larger than the number of bits in the\n  object representation (3.9) of the bit-field\u2019s type; in such cases the\n  extra bits are used as padding bits and do not participate in the\n  value representation (3.9) of the bit-field.</p>\n</blockquote>\n<p><code>Test</code> is a bit-field, it is not an unsigned char or some other type. This is dangerous, because it assumes an unsigned char can hold 64 or more bits. You should not really be doing this. I haven't memorized all the conversion rules, but a compiler should not convert an 8-byte non-char into a char unless you explicitly tell it to (e.g. using casts).</p>\n<p>...</p>\n<p>Are you looking for <code>uint64_t</code>?</p>\n", "LastActivityDate": "2012-10-29T03:45:44.033", "CommentCount": "0", "CreationDate": "2012-10-29T03:45:44.033", "ParentId": "13114752", "Score": "1", "OwnerUserId": "1088"}, "bq_ids": {"n4140": {"so_13114752_13115617_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5921}}, "n3337": {"so_13114752_13115617_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5693}}, "n4659": {"so_13114752_13115617_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 7395}}}, "13115779": {"Id": "13115779", "PostTypeId": "2", "Body": "<p>The declaration </p>\n<pre><code>struct ByteSize\n{\n   unsigned char Test:64;\n}\n</code></pre>\n<p>is incorrect. Bit fields should only use a naked unsigned type.</p>\n<pre><code>struct ByteSize\n{\n   unsigned Test:64;\n}\n</code></pre>\n<p>The value is unsigned so that there is no confusion about the sign bit. The field is treated as an unsigned integer of the field size selected.</p>\n", "LastActivityDate": "2012-10-29T04:14:32.303", "CommentCount": "0", "CreationDate": "2012-10-29T04:14:32.303", "ParentId": "13114752", "Score": "0", "OwnerUserId": "424780"}, "13114752": {"ViewCount": "138", "Body": "<p>If I write the following code, which compiles on Code::Blocks GCC:</p>\n<pre><code>struct ByteSize\n{\n   unsigned char Test:64;\n};\n</code></pre>\n<p>A ByteSize struct has a sizeof 8. Which makes sense. But when I'm accessing ByteSize's Test, is it still treated as an unsigned char, or some other variable? Is this dangerous? Should I really be doing this? Will the compiler convert an 8 byte variable into a single byte char?</p>\n", "Title": "Bitfield effect on size/type?", "CreationDate": "2012-10-29T01:06:56.420", "LastActivityDate": "2012-10-29T04:14:32.303", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "Id": "13114752", "Score": "2", "OwnerUserId": "1433767", "Tags": "<c++>", "AnswerCount": "3"}, "13114801": {"Id": "13114801", "PostTypeId": "2", "Body": "<p>Clang gives the warning:</p>\n<pre><code>warning: size of bit-field 'Test' (64 bits) exceeds the size of its type;\n         value will be truncated to 8 bits\n</code></pre>\n<p>Also, if a value greater than 255 is tried to stored to it, is gives the warning:</p>\n<pre><code>warning: implicit conversion from 'int' to 'unsigned char' changes \n         value from 256 to 0\n</code></pre>\n<p>Then, trying to read from it produces 0. So, even though <code>sizeof(ByteSize) == 8</code>, it looks like it does just access it as an unsigned char, and it doesn't like you can actually store more than 1 byte in the member.</p>\n", "LastActivityDate": "2012-10-29T01:17:57.617", "CommentCount": "0", "CreationDate": "2012-10-29T01:17:57.617", "ParentId": "13114752", "Score": "1", "OwnerUserId": "57318"}});