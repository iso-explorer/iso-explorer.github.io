post_cb({"34542757": {"ParentId": "34540278", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><em>itsnotmyrealname</em> and <em>rici</em> touch on the hardware drivers for this, but I thought it might help to walk through the simplest possible scenario leading to different pointer sizes...</p>\n<p>Imagine a CPU that can address 32-bit words of memory, and that the C++ <code>int</code> type is also to be 32 bits wide.</p>\n<p>This hypothetical CPU addresses specific words using a numbering: 0 for the first word (bytes 0-3), 1 for the second (bytes 4-7) and so on.  <code>int*{0}</code> is therefore your first word in memory (assuming no bizarre <code>nullptr</code> shenanigans require otherwise), <code>int*{1}</code> the second etc..</p>\n<p>What should the compiler do to support 8-bit <code>char</code> types?  It may have to implement <code>char*</code> support using an <code>int*</code> to identify the word in memory, but still need an extra two bits to store 0, 1, 2 or 3 to say which of the bytes in that word are being pointed to.  It would effectively need to generate machine code much as a C++ program might if using...</p>\n<pre><code>struct __char_ptr\n{\n    unsigned* p_;\n    unsigned byte_ : 2;\n    char get() const { return (*p_ &amp; (0xFF &lt;&lt; (8*byte_)) &gt;&gt; 8*byte_; }\n    void set(char c) { *p_ &amp;= ~(0xFF &lt;&lt; (8*byte_)); *p |= c &lt;&lt; 8*byte_; }\n};\n</code></pre>\n<p>On such a system - <code>sizeof(__char_ptr) &gt; sizeof(int*)</code>.  The C++ Standard's flexibility allows compliant C++ implementations for (and code portability to/from) weird systems with this or similar issues.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2015-12-31T08:56:37.357", "Id": "34542757", "Score": "2", "CreationDate": "2015-12-31T07:22:01.180", "LastActivityDate": "2015-12-31T08:56:37.357"}, "34540278": {"CommentCount": "13", "ViewCount": "349", "PostTypeId": "1", "LastEditorUserId": "207421", "CreationDate": "2015-12-31T02:40:50.900", "LastActivityDate": "2015-12-31T09:34:45.327", "Title": "How to understand \"C++ allows sizeof(char*) != sizeof(int*)\"?", "AcceptedAnswerId": "34540711", "LastEditDate": "2015-12-31T02:50:28.657", "Id": "34540278", "Score": "9", "Body": "<p>I am reading this <a href=\"https://isocpp.org/wiki/faq/intrinsic-types#bytes-review\">post</a> which is related to <code>char</code> and <code>byte</code>, and come across the following words:  </p>\n<blockquote>\n<p id=\"so_34540278_34540278_0\">An <code>int*</code> could still be implemented as a single hardware pointer, since C++ allows <code>sizeof(char*) != sizeof(int*)</code>.</p>\n</blockquote>\n<p>How to understand 'C++ allows <code>sizeof(char*) != sizeof(int*)</code>'?</p>\n", "Tags": "<c++><pointers><language-lawyer>", "OwnerUserId": "2106207", "AnswerCount": "5"}, "34544244": {"ParentId": "34540278", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is also the reason why <a href=\"https://stackoverflow.com/a/29035972/1708801\">we can not forward declare enums without providing the underlying size</a> in my answer I provide several references that cover why this is so. </p>\n<p>in this <a href=\"http://compgroups.net/comp.lang.c++/gcc-and-forward-declaration-of-enum/1005825\" rel=\"nofollow noreferrer\">comp.lang.c++ discussion: GCC and forward declaration of enum</a>:</p>\n<blockquote>\n<p id=\"so_34540278_34544244_0\">[...] While on most architectures it may not be an issue, on some\n  architectures the pointer will have a different size, in case it is a\n  char pointer. [...]</p>\n</blockquote>\n<p>and we can find from this C-Faq entry <a href=\"http://c-faq.com/null/machexamp.html\" rel=\"nofollow noreferrer\">Seriously, have any actual machines really used nonzero null pointers, or different representations for pointers to different types? </a> it says:</p>\n<blockquote>\n<p id=\"so_34540278_34544244_1\">Older, word-addressed Prime machines were also notorious for requiring larger byte pointers (char *'s) than word pointers (int *'s). [...] Some 64-bit Cray machines represent int * in the lower 48 bits of a word; char * additionally uses some of the upper 16 bits to indicate a byte address within a word. [...]</p>\n</blockquote>\n<p>and furthermore:</p>\n<blockquote>\n<p id=\"so_34540278_34544244_2\">[...]The Eclipse MV series from Data General has three architecturally supported pointer formats (word, byte, and bit pointers), two of which are used by C compilers: byte pointers for char * and void *, and word pointers for everything else. For historical reasons during the evolution of the 32-bit MV line from the 16-bit Nova line, word pointers and byte pointers had the offset, indirection, and ring protection bits in different places in the word. Passing a mismatched pointer format to a function resulted in protection faults. Eventually, the MV C compiler added many compatibility options to try to deal with code that had pointer type mismatch errors. [...] The old HP 3000 series uses a different addressing scheme for byte addresses than for word addresses; like several of the machines above it therefore uses different representations for char * and void * pointers than for other pointers. [...]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:07.893", "Id": "34544244", "Score": "2", "CreationDate": "2015-12-31T09:34:45.327", "LastActivityDate": "2015-12-31T09:34:45.327"}, "34540606": {"ParentId": "34540278", "CommentCount": "0", "Body": "<p>There are (or were) machines which could only address entire \"words\", where a word was large enough to hold several characters. For example, the PDP-6/10 had a word-size of 36-bits. On such a machine, you might implement 9-bit bytes and represent a byte pointer as the combination of a word pointer and a bit-index within the word. A na\u00efve implementation would require two words for such a pointer, even though a integer pointer would be just a word pointer, occupying a single word.</p>\n<p>(The real PDP-6/10 allowed for smaller character sizes -- 6- and 7-bit codings were common, depending on use case -- and since a pointer could not occupy a whole word, it was possible to make a character pointer including bit offset and word address fit inside a single word. But a similar architecture these days would not have the draconian restriction on address space, so that wouldn't work anymore.)</p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "34540606", "Score": "3", "CreationDate": "2015-12-31T03:26:06.227", "LastActivityDate": "2015-12-31T03:26:06.227"}, "34540711": {"ParentId": "34540278", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In short, the standard doesn't guarantee it, the result is implementation-defined.</p>\n<p>From the standard about <code>sizeof</code> ($5.3.3/1 Sizeof [expr.sizeof])</p>\n<blockquote>\n<p id=\"so_34540278_34540711_0\">The sizeof operator yields the number of bytes in the object\n  representation of its operand.</p>\n</blockquote>\n<p>and pointer is compound type ($3.9.2/1.3 Compound types [basic.compound])</p>\n<blockquote>\n<p id=\"so_34540278_34540711_1\">pointers to void or objects or functions (including static members of\n  classes) of a given type, 8.3.1;</p>\n</blockquote>\n<p>and ($3.9.2/3 Compound types [basic.compound])</p>\n<blockquote>\n<p id=\"so_34540278_34540711_2\">The value representation of pointer types is <strong>implementation-defined</strong>.</p>\n</blockquote>\n<p>even though ($3.9.2/3 Compound types [basic.compound])</p>\n<blockquote>\n<p id=\"so_34540278_34540711_3\">Pointers to layout-compatible types shall have the same value\n  representation and alignment requirements (3.11).</p>\n</blockquote>\n<p>but <code>char</code> and <code>int</code> don't need to have the same value representation. The starndard only says ($3.9.1/2 Fundamental types [basic.fundamental])</p>\n<blockquote>\n<p id=\"so_34540278_34540711_4\">There are five standard signed integer types : \u201csigned char\u201d, \u201cshort\n  int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong long int\u201d. In this list, each type\n  provides at least as much storage as those preceding it in the list.</p>\n</blockquote>\n<p>and ($3.9.1/3 Fundamental types [basic.fundamental]) etc.</p>\n<blockquote>\n<p id=\"so_34540278_34540711_5\">each signed integer type has the same object representation as its\n  corresponding unsigned integer type.</p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2015-12-31T03:51:21.850", "Id": "34540711", "Score": "2", "CreationDate": "2015-12-31T03:43:08.453", "LastActivityDate": "2015-12-31T03:51:21.850"}, "bq_ids": {"n4140": {"so_34540278_34540711_5": {"section_id": 7212, "quality": 1.0, "length": 12}, "so_34540278_34540711_0": {"section_id": 6076, "quality": 0.9, "length": 9}, "so_34540278_34540711_3": {"section_id": 7223, "quality": 0.9, "length": 9}, "so_34540278_34540325_0": {"section_id": 6076, "quality": 0.75, "length": 12}, "so_34540278_34540711_1": {"section_id": 7221, "quality": 0.8181818181818182, "length": 9}, "so_34540278_34540711_4": {"section_id": 7211, "quality": 1.0, "length": 25}, "so_34540278_34540711_2": {"section_id": 7223, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_34540278_34540711_5": {"section_id": 6956, "quality": 1.0, "length": 12}, "so_34540278_34540711_0": {"section_id": 5844, "quality": 0.9, "length": 9}, "so_34540278_34540711_3": {"section_id": 6967, "quality": 0.9, "length": 9}, "so_34540278_34540325_0": {"section_id": 5844, "quality": 0.75, "length": 12}, "so_34540278_34540711_1": {"section_id": 6965, "quality": 0.8181818181818182, "length": 9}, "so_34540278_34540711_4": {"section_id": 6955, "quality": 1.0, "length": 25}, "so_34540278_34540711_2": {"section_id": 6967, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_34540278_34540711_5": {"section_id": 8721, "quality": 1.0, "length": 12}, "so_34540278_34540711_0": {"section_id": 7572, "quality": 0.9, "length": 9}, "so_34540278_34540711_3": {"section_id": 8732, "quality": 0.9, "length": 9}, "so_34540278_34540325_0": {"section_id": 7572, "quality": 0.75, "length": 12}, "so_34540278_34540711_1": {"section_id": 8730, "quality": 0.8181818181818182, "length": 9}, "so_34540278_34540711_4": {"section_id": 8720, "quality": 0.96, "length": 24}, "so_34540278_34540711_2": {"section_id": 8732, "quality": 0.6666666666666666, "length": 4}}}, "34540325": {"ParentId": "34540278", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The standard says:  </p>\n<blockquote>\n<p id=\"so_34540278_34540325_0\"><strong>5.3.3 Sizeof</strong><br>\n  sizeof(char) , sizeof(signed char) and sizeof(unsigned char) are 1 . \n  The result of sizeof applied to any other fundamental type (\n  3.9.1 ) is implementation-defined.</br></p>\n</blockquote>\n<p>Since pointers are \"compound types\", and the standard makes no mention of byte size consistency between pointers, the compiler writers are free to do as they wish.</p>\n", "OwnerUserId": "908939", "LastEditorUserId": "908939", "LastEditDate": "2015-12-31T03:56:16.843", "Id": "34540325", "Score": "1", "CreationDate": "2015-12-31T02:48:31.787", "LastActivityDate": "2015-12-31T03:56:16.843"}});