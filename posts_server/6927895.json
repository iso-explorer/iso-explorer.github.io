post_cb({"6927895": {"CommentCount": "0", "AcceptedAnswerId": "6928085", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-08-03T14:13:37.043", "LastActivityDate": "2011-08-03T15:47:20.697", "LastEditDate": "2017-05-23T12:16:56.393", "ViewCount": "1798", "FavoriteCount": "1", "Title": "Dynamic downcast on private inheritance within private scope", "Id": "6927895", "Score": "18", "Body": "<p>A tweak on <a href=\"https://stackoverflow.com/questions/844816/c-style-upcast-and-downcast-involving-private-inheritance\">this question</a> that I've run into. Consider:</p>\n<pre><code>class A {};\n\nclass B : private A {\n   static void foo();\n};\n\nvoid B::foo(){\n   B* bPtr1 = new B;\n   A* aPtr1 = dynamic_cast&lt;A*&gt;(bPtr1); // gives pointer\n   B* bPtr2 = dynamic_cast&lt;B*&gt;(aPtr1); // gives NULL\n}\n</code></pre>\n<p>Since <code>aPtr1</code> is, in fact, of type <code>B*</code>, and since we've got full access to <code>B</code> and its inheritance from <code>A</code>, I'd expected both casts to work. But they don't; why? Is there another way to achieve this cast?</p>\n<p>Note that:</p>\n<ul>\n<li>If <code>foo()</code> were not a member of B, both casts would fail.</li>\n<li>If <code>B</code> inherits from <code>A</code> publicly, both casts would work.</li>\n</ul>\n", "Tags": "<c++><casting><private><downcasting>", "OwnerUserId": "299713", "AnswerCount": "2"}, "6928100": {"ParentId": "6927895", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>They don't work because there's no virtual functions in A. When you do the downcast then that's trivial- the compiler probably doesn't even bother making a check. When you make an upcast then the compiler must check, but it's only defined to work when you have virtual functions. When you don't, then the compiler will fail to make the check and the result is <code>NULL</code>.</p>\n<p>The inheritance protection level and other accessibility issues are orthogonal to the problem,  and they only exist at compile-time, if the program compiles then they work fine.</p>\n<blockquote>\n<p id=\"so_6927895_6928100_0\">Note that:</p>\n<p id=\"so_6927895_6928100_1\">If foo() were not a member of B, both casts would fail. </p>\n<p id=\"so_6927895_6928100_2\">If B inherits\n  from A publicly, both casts would work.</p>\n</blockquote>\n<p>That's just not true. <code>foo()</code> has absolutely no bearing on RTTI functionality- it's not virtual and it's not even an instance member. If B inherits from A publicly- then A still has no virtual functions and it still won't work.</p>\n", "OwnerUserId": "298661", "LastEditorUserId": "298661", "LastEditDate": "2011-08-03T14:34:20.693", "Id": "6928100", "Score": "1", "CreationDate": "2011-08-03T14:27:43.103", "LastActivityDate": "2011-08-03T14:34:20.693"}, "6928085": {"ParentId": "6927895", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>5.2.7 (ISO/IEC 14882, 12/29/2003) is pretty explicit on this point:</p>\n<blockquote>\n<p id=\"so_6927895_6928085_0\">[about the expression <code>dynamic_cast&lt;T&gt;(v)</code>]</p>\n<p id=\"so_6927895_6928085_1\">If <code>T</code> is \u201cpointer to <em>cv1</em> <code>B</code>\u201d and <code>v</code> has type \u201cpointer to <em>cv2</em>\n<code>D</code>\u201d such that <code>B</code> is a base class of <code>D</code>, the result is a\n  pointer to the unique <code>B</code> sub-object of the <code>D</code> object pointed to by <code>v</code>.\n  [... bla bla about cv1 and cv2 ...] <strong>and B shall be an accessible unambiguous base class\n  of D</strong> <em>(emphasis mine)</em></p>\n</blockquote>\n<p>(recall 11.2 <em>\"A base class is said to be accessible if an invented public member of the base class is accessible.\"</em>).</p>\n<p>This explains why the first cast works. Now, for the second:</p>\n<blockquote>\n<p id=\"so_6927895_6928085_2\">[...]</p>\n<p id=\"so_6927895_6928085_3\">Otherwise, a run-time check is applied to see if the object pointed or\n  referred to by <code>v</code> can be converted to the type pointed or referred to\n  by <code>T</code>.</p>\n<p id=\"so_6927895_6928085_4\">The run-time check logically executes as follows:</p>\n<ul>\n<li>If, in the most derived object pointed (referred) to by <code>v</code>, <code>v</code> points\n  (refers) to a <code>public</code> base class subobject of a <code>T</code> object, and if only\n  one object of type T is derived from the sub-object pointed (referred)\n  to by <code>v</code>, the result is a pointer (an lvalue referring) to that <code>T</code>\n  object.</li>\n<li>Otherwise, if <code>v</code> points (refers) to a <code>public</code> base class sub-object\n  of the most derived object, and the type of the most derived object\n  has a base class, of type <code>T</code>, that is <strong>unambiguous and <code>public</code></strong>, the\n  result is a pointer (an lvalue referring) to the <code>T</code> sub-object of the\n  most derived object.</li>\n<li>Otherwise, the run-time check fails.</li>\n</ul>\n<p id=\"so_6927895_6928085_5\">The value of a failed cast to pointer type is the null pointer value\n  of the required result type. A failed cast to reference type throws\n  bad_cast (18.5.2).</p>\n</blockquote>\n<p>So it seems that the behavior you observe is due to the <code>private</code> inheritance: even if the base class is accessible, it is not <em>public</em>, and the standard requires <em>public</em>, not accessible.</p>\n<p>Annoying, isn't it ? I don't have the C++0x draft handy, perhaps someone can edit my answer with quotes from it, in case things have changed.</p>\n<blockquote>\n<p id=\"so_6927895_6928085_6\">Is there another way to achieve this cast?</p>\n</blockquote>\n<p>It depends on what you want to do. Basically, private inheritance is just another device for performing composition. If you really are to return a pointer to the private derived instance, then either make the inheritance public, or return a member.</p>\n<p>Anyways, you'll happy to know that <code>static_cast</code> doesn't seem to have this limitation:</p>\n<blockquote>\n<p id=\"so_6927895_6928085_7\">5.2.9. [about <code>static_cast&lt;T&gt;(v)</code>] [...]</p>\n<p id=\"so_6927895_6928085_8\">An rvalue of type \u201cpointer to cv1 B\u201d, where B is a class type, can be converted to an rvalue of type \u201cpointer\n  to cv2 D\u201d, where D is a class derived (clause 10) from B, <strong>if a valid standard conversion from \u201cpointer to D\u201d\n  to \u201cpointer to B\u201d exists</strong> (4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and\n  B is not a virtual base class of D. The null pointer value (4.10) is converted to the null pointer value of the\n  destination type. If the rvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a sub-object of an\n  object of type D, the resulting pointer points to the enclosing object of type D. Otherwise, the result of the\n  cast is undefined.</p>\n</blockquote>\n<p>so if you know for sure what the actual dynamic type of the pointer is, you are allowed to <code>static_cast</code> inside <code>foo</code>.</p>\n<p>I'd be interested in any additional information about <strong>why</strong> this inconsistency exists.</p>\n", "OwnerUserId": "373025", "LastEditorUserId": "373025", "LastEditDate": "2011-08-03T15:47:20.697", "Id": "6928085", "Score": "15", "CreationDate": "2011-08-03T14:26:26.210", "LastActivityDate": "2011-08-03T15:47:20.697"}, "bq_ids": {"n4140": {"so_6927895_6928085_3": {"section_id": 6017, "quality": 1.0, "length": 13}, "so_6927895_6928085_8": {"section_id": 6037, "quality": 0.7777777777777778, "length": 49}, "so_6927895_6928085_4": {"section_id": 6018, "quality": 0.8333333333333334, "length": 5}, "so_6927895_6928085_1": {"section_id": 6015, "quality": 0.56, "length": 14}, "so_6927895_6928085_5": {"section_id": 6019, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_6927895_6928085_3": {"section_id": 5785, "quality": 1.0, "length": 13}, "so_6927895_6928085_8": {"section_id": 5805, "quality": 0.8095238095238095, "length": 51}, "so_6927895_6928085_4": {"section_id": 5786, "quality": 0.8333333333333334, "length": 5}, "so_6927895_6928085_1": {"section_id": 5783, "quality": 0.56, "length": 14}, "so_6927895_6928085_5": {"section_id": 5787, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_6927895_6928085_3": {"section_id": 7516, "quality": 1.0, "length": 13}, "so_6927895_6928085_8": {"section_id": 7536, "quality": 0.6984126984126984, "length": 44}, "so_6927895_6928085_1": {"section_id": 7514, "quality": 0.56, "length": 14}, "so_6927895_6928085_5": {"section_id": 7518, "quality": 0.8421052631578947, "length": 16}, "so_6927895_6928085_4": {"section_id": 7517, "quality": 0.8333333333333334, "length": 5}}}});