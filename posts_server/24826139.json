post_cb({"bq_ids": {"n4140": {"so_24826139_24826604_1": {"length": 16, "quality": 1.0, "section_id": 348}, "so_24826139_24826298_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 91}, "so_24826139_24826298_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}, "so_24826139_24826298_2": {"length": 17, "quality": 1.0, "section_id": 6186}, "so_24826139_24826298_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 3228}, "so_24826139_24826298_4": {"length": 31, "quality": 0.96875, "section_id": 6186}}, "n3337": {"so_24826139_24826298_6": {"length": 27, "quality": 1.0, "section_id": 338}, "so_24826139_24826298_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 86}, "so_24826139_24826298_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 3101}, "so_24826139_24826298_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}, "so_24826139_24826298_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5947}, "so_24826139_24826604_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 338}, "so_24826139_24826298_4": {"length": 27, "quality": 0.84375, "section_id": 5947}}, "n4659": {"so_24826139_24826604_1": {"length": 14, "quality": 0.875, "section_id": 358}, "so_24826139_24826298_5": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}, "so_24826139_24826298_4": {"length": 27, "quality": 0.84375, "section_id": 7689}, "so_24826139_24826298_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3985}, "so_24826139_24826298_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 7688}}}, "24826219": {"Id": "24826219", "PostTypeId": "2", "Body": "<p>The size of C array are compile time constant and are managed by the compiler (there is no info about the size of the C array in runtime), when you instantiate the template, the compiler only check if the real size fit in the template type provided. Example:</p>\n<pre><code>template &lt;typename T, char n &gt; void f(T (&amp;)[n]) {}\n\nint main() { \n  int a[1000];\n  f(a);\n}\n</code></pre>\n<p>This will fail even when <code>int a[20];</code> succeed.</p>\n", "LastEditorUserId": "3837231", "LastActivityDate": "2014-07-18T13:52:06.333", "Score": "0", "CreationDate": "2014-07-18T13:30:00.510", "ParentId": "24826139", "CommentCount": "4", "OwnerUserId": "3837231", "LastEditDate": "2014-07-18T13:52:06.333"}, "24826604": {"Id": "24826604", "PostTypeId": "2", "Body": "<p>This is covered in 14.8.2.5 <strong>[temp.deduct.type]</strong> paragraph 17:</p>\n<blockquote>\n<p id=\"so_24826139_24826604_0\">17 - [...] [The] template-argument type shall match the type of the template-parameter exactly, except that a template-argument deduced from an array bound may be of any integral type.</p>\n</blockquote>\n<p>In <a href=\"http://wg21.cmeerw.net/cwg/issue1770\" rel=\"nofollow\">http://wg21.cmeerw.net/cwg/issue1770</a> this is improved to the more general:</p>\n<blockquote>\n<p id=\"so_24826139_24826604_1\">17 - If <code>P</code> has a form that contains <code>&lt;i&gt;</code>, and if the type of the corresponding value of <code>A</code> differs from the type of <code>i</code>, deduction fails. If <code>P</code> has a form that contains <code>[i]</code>, and if the type of <code>i</code> is not an integral type, deduction fails.</p>\n</blockquote>\n<p>So array bounds can be deduced to any integral type, but non-type template parameters must be deduced to the actual type in the template definition.</p>\n<p>Indeed, there is nowhere in the C++11 version of the Standard that specifies a preferred type for array bounds; an array bound is specified (in <strong>[dcl.array]</strong>) to be \"<em>an integral constant expression and its value shall be greater than zero</em>\". In recent drafts for C++14 this is amended to \"<em>a converted constant expression (5.19) of type <code>std::size_t</code> [...]</em>\"; the changed definition can be traced to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3306.pdf\" rel=\"nofollow\">n3306</a>. Somewhat oddly, the change is presented as a \"<em>consequential adjustment [..] for the sake of consistency</em>\", implying that the editors considered it self-apparent that <code>size_t</code> was the correct type.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-07-18T15:15:52.967", "Score": "4", "CreationDate": "2014-07-18T13:48:35.500", "ParentId": "24826139", "CommentCount": "1", "OwnerUserId": "567292", "LastEditDate": "2014-07-18T15:15:52.967"}, "24826298": {"Id": "24826298", "PostTypeId": "2", "Body": "<p>From \u00a78.3.4  [dcl.array]/1:</p>\n<blockquote>\n<p id=\"so_24826139_24826298_0\">If the constant-expression (5.19)\n  is present, it shall be a converted constant expression of type std::size_t and its value shall be greater than zero. The constant expression specifies the bound of (number of elements in) the array</p>\n</blockquote>\n<p>The type is <code>std::size_t</code>.</p>\n<p>The reason other types work in general is that conversions are done on the type passed in according to \u00a714.3.2  [temp.arg.nontype]/5:</p>\n<blockquote>\n<p id=\"so_24826139_24826298_1\">For a non-type template-parameter of integral or enumeration type, conversions permitted in a converted constant expression (5.19) are applied.</p>\n</blockquote>\n<p>From \u00a75.19 [expr.const]/3:</p>\n<blockquote>\n<p id=\"so_24826139_24826298_2\">An integral constant expression is an expression of integral or unscoped enumeration type, implicitly converted to a prvalue, where the converted expression is a core constant expression.  </p>\n<p id=\"so_24826139_24826298_3\"><em>snip</em> (mentions these can be used as array bounds)   </p>\n<p id=\"so_24826139_24826298_4\">A converted constant expression of type T is an expression, implicitly converted to a prvalue of type T, where the converted expression is a core constant expression and the implicit conversion sequence contains only user-defined conversions, lvalue-to-rvalue conversions (4.1), integral promotions (4.5), and <strong>integral conversions</strong> (4.7) other than narrowing conversions (8.5.4).</p>\n</blockquote>\n<p>Finally, \u00a74.7 [conv.integral]/3:</p>\n<blockquote>\n<p id=\"so_24826139_24826298_5\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>If the value of the bound fits inside of your parameter type, it will be converted successfully. If not, you'll end up with an implementation-defined value for the bound.</p>\n<p>Arrays are a special case, as pointed out in <a href=\"https://stackoverflow.com/a/24826604/962089\">ectamur's answer</a>:</p>\n<p>\u00a714.8.2.5 [temp.deduct.type]/17:</p>\n<blockquote>\n<p id=\"so_24826139_24826298_6\">If, in the declaration of a function template with a non-type template-parameter, the non-type template-parameter is used in an expression in the function parameter-list and, if the corresponding template-argument is deduced, the template-argument type shall match the type of the template-parameter exactly, except that a template-argument deduced from an array bound may be of any integral type.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-18T14:07:31.837", "Score": "6", "CreationDate": "2014-07-18T13:33:30.807", "ParentId": "24826139", "CommentCount": "1", "OwnerUserId": "962089", "LastEditDate": "2017-05-23T11:52:18.833"}, "24826139": {"ViewCount": "348", "Body": "<p>When deducing a non-type template parameter, say <code>n</code>, the types of <code>n</code> must match exactly between the parameter and argument. So the following code will not compile (at least on GCC and clang):</p>\n<pre><code>#include &lt;array&gt;\ntemplate &lt;int n&gt; void f(std::array&lt;int, n&gt; const&amp;) {}\nint main() {\n  std::array&lt;int, 3&gt; arr;\n  f(arr);\n}\n</code></pre>\n<p>This is because <code>std::array</code> is declared as</p>\n<pre><code>template &lt;typename T, std::size_t n&gt; class array;\n</code></pre>\n<p>rather than</p>\n<pre><code>template &lt;typename T, int n&gt; class array;\n</code></pre>\n<p>However, to capture the size of a built-in array, it seems that any integral type does. All of the following work on GCC, clang, and VC++:</p>\n<pre><code>template &lt;typename T, char n &gt; void f(T (&amp;)[n]);\ntemplate &lt;typename T, short n&gt; void f(T (&amp;)[n]);\ntemplate &lt;typename T, int   n&gt; void f(T (&amp;)[n]);\n...\n</code></pre>\n<p>So, seriously, the type of a built-in array's size is overloaded?</p>\n", "AcceptedAnswerId": "24826604", "Title": "What is the type of a built-in array's size?", "CreationDate": "2014-07-18T13:26:27.750", "Id": "24826139", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-07-18T15:15:52.967", "Score": "6", "OwnerUserId": "1348273", "Tags": "<c++><arrays><templates>", "AnswerCount": "3"}});