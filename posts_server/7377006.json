post_cb({"7377096": {"Id": "7377096", "PostTypeId": "2", "Body": "<p>It's because you attempt to <em>explicitly</em> instantiate <code>get</code> function template, by providing <code>0</code> as template argument. In case of templates, ADL works if a function template with that name is visible at the point of the call. This visible function template only helps <em>triggering</em> ADL (it may not be used <em>actually</em>) and then, a best matching can be found in other namespaces. </p>\n<p>Note that the function template which <em>triggers</em> (or enable) ADL, <strong>need not to have definition</strong>:</p>\n<pre><code>namespace M\n{\n    struct S{};\n\n    template&lt;int N, typename T&gt;\n    void get(T) {}     \n}\n\nnamespace N\n{\n   template&lt;typename T&gt;\n   void get(T); //no need to provide definition\n                // as far as enabling ADL is concerned!\n} \n\nvoid f(M::S s)\n{\n   get&lt;0&gt;(s); //doesn't work - name `get` is not visible here \n}\n\nvoid g(M::S s)\n{\n   using N::get; //enable ADL\n   get&lt;0&gt;(s); //calls M::get\n}\n</code></pre>\n<p>In <code>g()</code>, the name <code>N::get</code> triggers ADL when calling <code>get&lt;0&gt;(s)</code>.</p>\n<p>Demo : <a href=\"http://ideone.com/83WOW\" rel=\"nofollow\">http://ideone.com/83WOW</a></p>\n<hr>\n<p>C++ (2003) section \u00a714.8.1/6 reads,</p>\n<blockquote>\n<p id=\"so_7377006_7377096_0\">[Note: For simple function names, argument dependent lookup (3.4.2) applies even when the function name is not visible within the scope of the call. This is because the call still has the syntactic form of a function call (3.4.1). <strong>But when a function template with explicit template arguments is used, the call does not have the correct syntactic form unless there is a function template with that name visible at the point of the call. If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not apply.</strong> If some such name is visible, argument dependent lookup applies and additional function templates may be found in other namespaces.</p>\n<p id=\"so_7377006_7377096_1\">[Example:</p>\n<pre><code>namespace A {\n     struct B { };\n     template&lt;int X&gt; void f(B);\n}\nnamespace C {\n     template&lt;class T&gt; void f(T t);\n}\nvoid g(A::B b) {\n     f&lt;3&gt;(b);    //ill-formed: not a function call\n     A::f&lt;3&gt;(b); //well-formed\n     C::f&lt;3&gt;(b); //ill-formed; argument dependent lookup\n                 // applies only to unqualified names\n\n    using C::f;\n     f&lt;3&gt;(b); //well-formed because C::f is visible; then\n              // A::f is found by argument dependent lookup\n}\n</code></pre>\n<p id=\"so_7377006_7377096_2\">\u2014end example] \u2014end note] </p>\n</blockquote>\n</hr>", "LastEditorUserId": "636019", "LastActivityDate": "2011-09-25T04:18:43.733", "Score": "21", "CreationDate": "2011-09-11T08:16:12.710", "ParentId": "7377006", "CommentCount": "6", "LastEditDate": "2011-09-25T04:18:43.733", "OwnerUserId": "415784"}, "bq_ids": {"n4140": {"so_7377006_7377313_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 291}, "so_7377006_7377096_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 291}}, "n3337": {"so_7377006_7377313_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 282}, "so_7377006_7377096_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 282}}, "n4659": {"so_7377006_7377313_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 298}, "so_7377006_7377096_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 298}}}, "7377006": {"ViewCount": "2188", "Body": "<blockquote>\n<p id=\"so_7377006_7377006_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/2953684/why-doesnt-adl-find-function-templates\">Why doesn't ADL find function templates?</a> </br></p>\n</blockquote>\n<p>Calling <code>get</code> does not seem to invoke argument dependent lookup:</p>\n<pre><code>auto t = std::make_tuple(false, false, true);\nbool a = get&lt;0&gt;(t);        // error\nbool b = std::get&lt;0&gt;(t);   // okay\n</code></pre>\n<p>g++ 4.6.0 says:</p>\n<pre><code>error: 'get' was not declared in this scope\n</code></pre>\n<p>Visual Studio 2010 says:</p>\n<pre><code>error C2065: 'get': undeclared identifier\n</code></pre>\n<p>Why?</p>\n", "AcceptedAnswerId": "7377096", "Title": "getting an element from a tuple", "CreationDate": "2011-09-11T07:55:24.397", "Id": "7377006", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:59:41.393", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-25T04:18:43.733", "ClosedDate": "2011-09-12T02:15:55.140", "Score": "22", "OwnerUserId": "252000", "Tags": "<c++><templates><tuples><c++11><argument-dependent-lookup>", "AnswerCount": "2"}, "7377313": {"Id": "7377313", "PostTypeId": "2", "Body": "<p>ADL doesn't directly apply to <em>template-id</em>'s such as <code>get&lt;0&gt;</code>, so the compiler doesn't really get started down that path. C++11 \u00a714.8.1/8 (in C++03, 14.8.1/6):</p>\n<blockquote>\n<p id=\"so_7377006_7377313_0\">[ Note: For simple function names, argument dependent lookup (3.4.2) applies even when the function name is not visible within the scope of the call. This is because the call still has the syntactic form of a function call (3.4.1). But when a function template with explicit template arguments is used, the call does not have the correct syntactic form unless there is a function template with that name visible at the point of the call. If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not apply. If some such name is visible, argument dependent lookup applies and additional function templates may be found in other namespaces.</p>\n</blockquote>\n<p>It goes on to give a short example. So the workaround is quite easy:</p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate&lt; typename &gt; // BEGIN STUPID BUT HARMLESS HACK\nvoid get( struct not_used_for_anything ); // END STUPIDITY\n\nauto t = std::make_tuple(false, false, true);\nbool a = get&lt;0&gt;(t);        // Now the compiler knows to use ADL!\nbool b = std::get&lt;0&gt;(t);   // okay\n</code></pre>\n<p><a href=\"http://ideone.com/fb8Ai\" rel=\"nofollow\">http://ideone.com/fb8Ai</a></p>\n<p>Note that the <code>not_used_for_anything</code> in the above is merely a safety mechanism. It's intended to be an incomplete type which is never completed. Omitting it works as well, but is unsafe because it could collide with a signature you might want.</p>\n<pre><code>template&lt; typename &gt;\nvoid get() = delete;\n</code></pre>\n<p><a href=\"http://ideone.com/WwF2y\" rel=\"nofollow\">http://ideone.com/WwF2y</a></p>\n<p>Note: the above quote from the Standard is non-normative, meaning that in the opinion of the Committee, we would be able to figure this out without explanation, because it's implied by the rest of the language and grammar, particularly the fact that 3.4.2 says nothing about looking up template-ids. Yeah, right!</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2011-09-11T14:04:16.800", "Score": "13", "CreationDate": "2011-09-11T09:15:35.280", "ParentId": "7377006", "CommentCount": "6", "LastEditDate": "2011-09-11T14:04:16.800", "OwnerUserId": "153285"}});