post_cb({"34108140": {"Id": "34108140", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32719880_34108140_0\">It returns true for both classes and structs. I know that in C++ they are almost the same thing, but I'd like to know why there's not a distinction between them in the type trait.</p>\n</blockquote>\n<p>Unfortunately this is a common misconception in C++. Sometimes it comes from fundamental misunderstanding, but at other times it comes from an ambiguity in English. It can come from inaccurate compiler diagnostics, badly-written books, incorrect SO answers\u2026</p>\n<p>You've probably read something like this:</p>\n<p>\"There is no difference in C++ between a struct and a class except the default visibility of members and bases.\"</p>\n<p>This passage can be interpreted in a sense that is misleading, because the notions of <em>identity</em> and <em>equality</em> are hard to distinguish when using phrases like \"no difference\".</p>\n<p><strong>In fact, C++ has not had structs since 1985. It only has classes.</strong></p>\n<p>The kind of types that you declare with the keyword <code>class</code> and the keyword <code>struct</code> are <em>classes</em>. Period. The keyword <code>struct</code>, and the visibility rules that are the default when defining a class using that keyword, were kept only for backward compatibility with C \u2026 but that's a syntax thing. It doesn't make the resulting types actually be of a different kind.</p>\n<p>The type trait makes no distinction because there literally isn't one to make.</p>\n", "LastActivityDate": "2015-12-05T16:54:58.250", "CommentCount": "43", "CreationDate": "2015-12-05T16:54:58.250", "ParentId": "32719880", "Score": "155", "OwnerUserId": "560648"}, "35698862": {"Id": "35698862", "PostTypeId": "2", "Body": "<p>Others have pointed out correctly that in C++ the keywords <code>struct</code> and <code>class</code> have the same meaning except for the difference in member visibility. </p>\n<p>Whether you call aggregate types thus defined \"structs\" or \"classes\" or \"weiruewzewiruz\" is up to you. In the interest of communication it is generally advisable to follow established conventions, so I would advise against \"weiruewzewiruz\".</p>\n<p>It is also recommended to use semantic differences as a guideline for word choices. The use of <code>struct</code> is more common for simple aggregated data which does not have a lot of internal logic and invariants; a typical use would be <code>struct point { float x; float y; };</code>. Such types are often called \"structs\" or \"structures\" in the literature. It would not be surprising if somebody using <code>fprintf</code> in C++ referred to the first argument as a \"pointer to a FILE struct\". FILE is an example of what Scott Meyers' means in \"More Effective C++\", Item 34:</p>\n<blockquote>\n<p id=\"so_32719880_35698862_0\">It is safe to assume that a structure definition that compiles in both\n  languages [C and C++ -p.a.s] is laid out the same way by both compilers.</p>\n</blockquote>\n<p>Concerning the natural language, the word choice \"structure\" is not coincidental: Meyers is talking about a plain old data aggregate which has identical semantics in both languages, right down to the bit level.</p>\n<p>Concerning programming language, it wouldn't matter if the C++ definition of the data aggregate in question used the keyword <code>struct</code> or <code>class</code> (with a public access specifier). <code>struct</code> is perhaps the more natural choice, because the C++ semantics of the aggregate are the semantics of a C struct. Also, using <code>struct</code> enables both C and C++ sources to easier share one type definition.</p>\n<p>The C++ standard uses \"struct\" and \"structure\" both in natural and programming language, not only in cases of interoperability: 1.7/5: \"A structure declared as\", or 3.2/4 <code>struct X; // declare X as a struct type</code>. Most interesting is 9/8, laying ground for interop-criteria:</p>\n<blockquote>\n<p id=\"so_32719880_35698862_1\">8 A standard-layout struct is a standard-layout class \n  defined with the class-key struct or the class-key \n  class. [...]   </p>\n</blockquote>\n<p>How anybody reading this can claim that there are no structs in C++ is beyond me. This clearly is not an editing error because the terms \"struct\" and \"class\" are explicitly set in relation to each other.</p>\n<hr>\n<p>More interesting than word choices and matters of taste, however, are manifest, testable differences. Under what circumstances is a C++ aggregate comparable to and compatible with a C <code>struct</code>? Perhaps this question was underlying your question? The standard layout mentioned in the quote is the criteria. It is detailed in 9/7 and essentially prescribes that </p>\n<ul>\n<li>only one class in an inheritance hierarchy may have non-static data member definitions (probably because the standard does not want to specify the order of data elements defined at different levels in such a hierarchy);</li>\n<li>no virtual functions or virtual base classes are allowed (because of the additional instance data necessary for the run-time information);</li>\n<li>all members have the same \"access control\" (either public, protected or private; probably because an implementation is free to order by access control).</li>\n</ul>\n<p>The standard then says</p>\n<blockquote>\n<p id=\"so_32719880_35698862_2\">9 [ Note: Standard-layout classes are useful for communicating \n  with code written in other programming languages. \n  Their layout is specified in 9.2.\u2014end note ]</p>\n</blockquote>\n<p>Of course a struct definition which compiles in C fulfills these criteria, hence Scott Meyers' assertion. <code>FILE</code> from stdio.h is a prominent, not-quite-trivial example. Note that the standard doesn't make guarantees because object layout is implementation dependent and may change just with a compiler option.</p>\n<p>Whether a class has standard layout can be tested with the type trait <code>std::is_standard_layout&lt;T&gt;</code>. The following program, which is inspired by <a href=\"http://en.cppreference.com/w/cpp/types/is_standard_layout\" rel=\"noreferrer\">an example on cppreference</a>, checks the main cases laid out in the standard.</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;typeinfo&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\nstruct funcOnlyT // fine\n{\n    int f();\n};\n\nclass podT {   // \"class\" is ok\n    int m1;\n    int m2;\n};\n\nstruct badAccessCtrlT { // bad: public/private\n    int m1;\nprivate:\n    int m2;\n};\n\nstruct polymorphicT {  // bad: polymorphic\n    int m1;\n    int m2;\n    virtual void foo();\n};\n\n\nstruct inheritOkT: podT // ok: inheritance, data only on one level\n{\n    int f();\n};\n\n\nstruct inheritPlusDataT: podT // bad: inheritance, data on 2 levels\n{\n    int m3;\n};\n\ntemplate&lt;typename T1, typename T2&gt;\nstruct templT     // ok with std layout types T1, T2\n{\n    T1 m1;\n    T2 m2;\n};\n\n// print type \"name\" and whether it's std layout\ntemplate&lt;typename T&gt;\nvoid printIsStdLayout()\n{\n    printf(\"%-20s: %s\\n\", \n            typeid(T).name(),\n            std::is_standard_layout&lt;T&gt;::value \n                ? \"is std layout\" \n                : \"is NOT std layout\");\n}\n\nint main()\n{\n    printIsStdLayout&lt;funcOnlyT&gt;();\n    printIsStdLayout&lt;podT&gt;();\n    printIsStdLayout&lt;badAccessCtrlT&gt;();\n    printIsStdLayout&lt;polymorphicT&gt;();\n    printIsStdLayout&lt;inheritOkT&gt;();\n    printIsStdLayout&lt;inheritPlusDataT&gt;();\n    printIsStdLayout&lt;templT&lt;int, float&gt; &gt;();\n    printIsStdLayout&lt;FILE&gt;();\n}\n</code></pre>\n<p>Sample session:</p>\n<pre><code>$ g++ -std=c++11 -Wall -o isstdlayout isstdlayout.cpp &amp;&amp; ./isstdlayout\n9funcOnlyT          : is std layout\n4podT               : is std layout\n14badAccessCtrlT    : is NOT std layout\n12polymorphicT      : is NOT std layout\n10inheritOkT        : is std layout\n16inheritPlusDataT  : is NOT std layout\n6templTIifE         : is std layout\n9__sFILE64          : is std layout\n</code></pre>\n</hr>", "LastEditorUserId": "3150802", "LastActivityDate": "2016-11-10T11:49:00.430", "Score": "12", "CreationDate": "2016-02-29T11:53:46.610", "ParentId": "32719880", "CommentCount": "6", "OwnerUserId": "3150802", "LastEditDate": "2016-11-10T11:49:00.430"}, "41274670": {"Id": "41274670", "PostTypeId": "2", "Body": "<i><b>C++11 \u00a79/8 <sub><sup>([class]/8)</sup></sub>:</b></i>\n<blockquote>\n<p id=\"so_32719880_41274670_0\"><strong>\u201d</strong> A <em>standard-layout struct</em> is a standard-layout class defined with the <em>class-key</em> <code>struct</code> or the <em>class-key</em> <code>class</code>. A <em>standard-layout union</em> is a standard-layout class defined with the <em>class-key</em> <code>union</code>.</p>\n</blockquote>\n<i><b>C++11 \u00a79/10 <sub><sup>([class]/10)</sup></sub>:</b></i>\n<blockquote>\n<p id=\"so_32719880_41274670_1\"><strong>\u201d</strong> A <em>POD struct</em> is a non-union class that is both a trivial class and a standard-layout class, and has no\n  non-static data members of type non-POD struct, non-POD union (or array of such types). [\u2026]</p>\n</blockquote>\n<p>Since a <em>POD struct</em> is a standard-layout class it is a subset of <em>standard-layout struct</em>. As far as I know this is the most general meaning of <strong>struct</strong> in the C++ standard. And so presumably what you're looking for is a type trait or set of type traits that lets you identify a <em>standard-layout struct</em> as such.</p>\n<p>And voil\u00e0, looking at the list of type traits there's <code>is_class</code> and <code>is_standard_layout</code>. When a type satisifies \u00b9both it's a \u201cstruct\u201d. Or more precisely, it's a <em>standard-layout struct</em>, as defined by C++11 \u00a79/8.</p>\n<hr>\n<p>Regarding</p>\n<blockquote>\n<p id=\"so_32719880_41274670_2\"><strong>\u201d</strong> I'd like to know why there's not a distinction between [class and struct] in the type trait</p>\n</blockquote>\n<p>Well, there is. That's the <code>is_standard_layout</code> trait.</p>\n<hr>\n<p>Regarding</p>\n<blockquote>\n<p id=\"so_32719880_41274670_3\"><strong>\u201d</strong> Is it always useless to check this difference, or is there some more reason that I don't understand?</p>\n</blockquote>\n<p>No, it's not useless to check this difference. The standard defines <em>standard-layout</em> for the reason that it's very practically useful. As the standard itself notes,</p>\n<i><b>C++11 \u00a79/9 <sub><sup>([class]/9)</sup></sub>:</b></i>\n<blockquote>\n<p id=\"so_32719880_41274670_4\"><strong>\u201d</strong> [Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.\u2014end note ]</p>\n</blockquote>\n<hr>\n<p><sup>\n<em>Notes:</em><br>\n\u00b9 The <code>is_class</code> trait is true for a <code>class</code> or <code>struct</code>, but not for a <code>union</code>, even though the standard defines that \u201ca union is a class\u201d. I.e. the trait is more specific than the general terminology.\n</br></sup></p>\n</hr></hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2016-12-22T02:31:30.603", "Score": "6", "CreationDate": "2016-12-22T01:51:45.123", "ParentId": "32719880", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2016-12-22T02:31:30.603"}, "bq_ids": {"n4140": {"so_32719880_35698862_1": {"length": 9, "quality": 1.0, "section_id": 5852}, "so_32719880_35698862_2": {"length": 12, "quality": 0.8, "section_id": 5853}, "so_32719880_41274670_0": {"length": 16, "quality": 1.0, "section_id": 5852}, "so_32719880_41274670_1": {"length": 20, "quality": 1.0, "section_id": 5854}, "so_32719880_41274670_4": {"length": 12, "quality": 0.8, "section_id": 5853}}, "n3337": {"so_32719880_35698862_1": {"length": 9, "quality": 1.0, "section_id": 5622}, "so_32719880_35698862_2": {"length": 12, "quality": 0.8, "section_id": 5623}, "so_32719880_41274670_0": {"length": 16, "quality": 1.0, "section_id": 5622}, "so_32719880_41274670_1": {"length": 20, "quality": 1.0, "section_id": 5624}, "so_32719880_41274670_4": {"length": 12, "quality": 0.8, "section_id": 5623}}, "n4659": {"so_32719880_35698862_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7331}, "so_32719880_35698862_2": {"length": 12, "quality": 0.8, "section_id": 7332}, "so_32719880_41274670_0": {"length": 14, "quality": 0.875, "section_id": 7331}, "so_32719880_41274670_1": {"length": 20, "quality": 1.0, "section_id": 7333}, "so_32719880_41274670_4": {"length": 12, "quality": 0.8, "section_id": 7332}}}, "32720236": {"Id": "32720236", "PostTypeId": "2", "Body": "<p>They're the same thing. The only difference (default member visibility) exists only at compile time. There is otherwise no difference at all between <code>struct</code> and <code>class</code>.</p>\n<p><strong>ETA:</strong> What you probably want is <a href=\"http://en.cppreference.com/w/cpp/types/is_pod\"><code>std::is_pod</code></a>, which will tell you if your class is a \"plain old data type\". Much of the discussion and commentary on this question seems to indicate that this is what those who think there should be a distinction actually want.</p>\n", "LastEditorUserId": "53089", "LastActivityDate": "2016-04-01T15:16:13.297", "Score": "22", "CreationDate": "2015-09-22T14:56:29.667", "ParentId": "32719880", "CommentCount": "5", "OwnerUserId": "53089", "LastEditDate": "2016-04-01T15:16:13.297"}, "32720169": {"Id": "32720169", "PostTypeId": "2", "Body": "<p>It is impossible to distinguish a difference in semantics for empty definitions like</p>\n<pre><code>class C {\npublic:\n\n};\n</code></pre>\n<p>from</p>\n<pre><code>struct S {\n\n};\n</code></pre>\n<p>or similarly</p>\n<pre><code>class C {\n\n};\n</code></pre>\n<p>and</p>\n<pre><code>struct S {\nprivate:\n\n};\n</code></pre>\n<p>Apart from the <code>struct</code> vs <code>class</code> keyword, there is no behavioral difference detectable. See also <a href=\"https://stackoverflow.com/q/92859/819272\">this Q&amp;A</a>.</p>\n<p><strong>Note</strong>: As remarked by @KyleStrand, derivation also requires explicit access specifiers, so <code>S : private Base {};</code> and <code>C : Base {};</code> are equivalent, the same as <code>S : Base {};</code> and <code>C : public Base {};</code>, where <code>S</code> is a struct, <code>C</code> is a class, and <code>Base</code> can be either.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-04T21:18:18.293", "Score": "26", "CreationDate": "2015-09-22T14:53:12.773", "ParentId": "32719880", "CommentCount": "3", "OwnerUserId": "819272", "LastEditDate": "2017-05-23T12:02:56.530"}, "32719880": {"ViewCount": "7417", "Body": "<p>I've seen that in order to check if a type <code>T</code> is a class I can use:</p>\n<pre><code>bool isClass = std::is_class&lt;T&gt;::value;\n</code></pre>\n<p>It returns true for both classes and structs. I know that in C++ they are almost the same thing, but I'd like to know why there's not a distinction between them in the type trait. Is it always useless to check this difference, or is there some more reason that I don't understand?</p>\n", "AcceptedAnswerId": "34108140", "Title": "Why is there not an std::is_struct type trait?", "CreationDate": "2015-09-22T14:40:24.783", "Id": "32719880", "CommentCount": "5", "FavoriteCount": "19", "PostTypeId": "1", "LastEditDate": "2016-12-22T00:14:28.263", "LastEditorUserId": "63550", "LastActivityDate": "2017-03-04T21:18:18.293", "Score": "51", "OwnerUserId": "979325", "Tags": "<c++><c++11><typetraits>", "AnswerCount": "5"}});