post_cb({"26633571": {"ParentId": "26626158", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-10-29T14:54:24.433", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:42.603", "Id": "26633571", "OwnerUserId": "2472169", "Body": "<p>The answer given by @user657267 is correct. That is why a small wrapper is needed to convert lambas with capture to gsl_function.</p>\n<p><a href=\"https://stackoverflow.com/a/18413206/2472169\">Here is the wrapper for the f gsl_function</a> and <a href=\"https://stackoverflow.com/a/24602657/2472169\">Here is the wrapper for the fdf gsl_function</a></p>\n<p>You can  convert lambda functions to gsl_function after using the wrapper proposed in these two answers in the following way (I haven't invented the version with std::function, it was a well known answer. The template version I haven't seen before my answer). </p>\n<pre><code>// std::function version\ndouble a = 1;\ngsl_function_pp Fp([=](double x)-&gt;double{return a*x;}); \ngsl_function *F = static_cast&lt;gsl_function*&gt;(&amp;Fp); \n\n//template version\ndouble a = 1;\nauto ptr = [=](double x)-&gt;double{return a*x;};\ngsl_function_pp&lt;decltype(ptr)&gt; Fp(ptr);\ngsl_function *F = static_cast&lt;gsl_function*&gt;(&amp;Fp); \n</code></pre>\n", "LastActivityDate": "2014-10-29T14:54:24.433"}, "26626573": {"ParentId": "26626158", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-10-29T09:21:27.873", "Score": "2", "LastEditorUserId": "657267", "LastEditDate": "2014-10-29T09:33:59.470", "Id": "26626573", "OwnerUserId": "657267", "Body": "<p>Only lambdas without captures can be converted to function pointers.</p>\n<p>[expr.prim.lambda]</p>\n<blockquote>\n<p id=\"so_26626158_26626573_0\">6 The closure type for a non-generic lambda-expression with <strong>no\n  lambda-capture</strong> has a public non-virtual non explicit const <strong>conversion\n  function to pointer to function</strong> with C++ language linkage (7.5) having\n  the same parameter and return types as the closure type\u2019s function\n  call operator.</p>\n</blockquote>\n<p>Essentially what this means is that </p>\n<pre><code>[] (double, void*) {return 2.0;};\n</code></pre>\n<p>acts as though it were defined as</p>\n<pre><code>class Lambda\n{\npublic:\n  double operator()(double, void*);\n  operator double(*)(double, void*)() const;\n};\n</code></pre>\n<p>if the lambda has a capture however the conversion function is not defined, and the lambda cannot be converted to a regular function pointer.</p>\n", "LastActivityDate": "2014-10-29T09:33:59.470"}, "26626158": {"CommentCount": "0", "ViewCount": "642", "CreationDate": "2014-10-29T08:58:42.180", "LastActivityDate": "2014-10-29T14:54:24.433", "Title": "Numerical integration of lambda function with gsl", "AcceptedAnswerId": "26633571", "PostTypeId": "1", "Id": "26626158", "Score": "2", "Body": "<p>I am working with gsl to integrate a function. That function is built in a lambda function that has as input a double and a void *, and as output a double.\nNow, everything works fine if I use the lambda without any variable capture. But if I do variable capturing, it doesn't work any more.</p>\n<p>Could anyone explain me why so?</p>\n<p>Here are two snippets of code that I made up to explain my problem:</p>\n<p>This one works fine:</p>\n<pre><code>int main(int argc, char **argv)\n{\n\n    double beg = 0;\n    double end = 10;\n\n    auto f = [] (double x, void * p) {return 2.0;};\n\n    gsl_integration_workspace * w = gsl_integration_workspace_alloc (GSL_INTEGRATION_WORKSPACE_SIZE);\n\n    double result;\n    double error;\n\n    gsl_function F;\n    F.function = f;\n    F.params = NULL;\n\n    gsl_integration_qags (&amp;F, beg, end, 0, GSL_INTEGRATION_RELATIVE_PRECISION, GSL_INTEGRATION_WORKSPACE_SIZE, w, &amp;result, &amp;error);\n\n    cout&lt;&lt;result&lt;&lt;endl;\n\n}\n</code></pre>\n<p>While this one</p>\n<pre><code>int main(int argc, char **argv)\n{\n\n    double beg = 0;\n    double end = 10;\n\n    double p = 2.0;\n\n    auto f = [&amp;] (double x, void * p) {return p;};\n\n    gsl_integration_workspace * w = gsl_integration_workspace_alloc (GSL_INTEGRATION_WORKSPACE_SIZE);\n\n    double result;\n    double error;\n\n    gsl_function F;\n    F.function = f;\n    F.params = NULL;\n\n    gsl_integration_qags (&amp;F, beg, end, 0, GSL_INTEGRATION_RELATIVE_PRECISION, GSL_INTEGRATION_WORKSPACE_SIZE, w, &amp;result, &amp;error);\n\n    cout&lt;&lt;result&lt;&lt;endl;\n\n}\n</code></pre>\n<p>Yields on the line</p>\n<pre><code>F.function = f;\n</code></pre>\n<p>the following error:</p>\n<pre><code>Assigning to 'double (*)(double, void *)' from incompatible type '&lt;lambda at /[omissis]/main.cpp&gt;'\n</code></pre>\n", "Tags": "<c++><lambda><gsl><numerical-integration>", "OwnerUserId": "774236", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26626158_26626573_0": {"section_id": 5965, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_26626158_26626573_0": {"section_id": 5734, "quality": 0.7777777777777778, "length": 21}}, "n4659": {"so_26626158_26626573_0": {"section_id": 7456, "quality": 0.7777777777777778, "length": 21}}}});