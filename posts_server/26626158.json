post_cb({"26626573": {"Id": "26626573", "PostTypeId": "2", "Body": "<p>Only lambdas without captures can be converted to function pointers.</p>\n<p>[expr.prim.lambda]</p>\n<blockquote>\n<p id=\"so_26626158_26626573_0\">6 The closure type for a non-generic lambda-expression with <strong>no\n  lambda-capture</strong> has a public non-virtual non explicit const <strong>conversion\n  function to pointer to function</strong> with C++ language linkage (7.5) having\n  the same parameter and return types as the closure type\u2019s function\n  call operator.</p>\n</blockquote>\n<p>Essentially what this means is that </p>\n<pre><code>[] (double, void*) {return 2.0;};\n</code></pre>\n<p>acts as though it were defined as</p>\n<pre><code>class Lambda\n{\npublic:\n  double operator()(double, void*);\n  operator double(*)(double, void*)() const;\n};\n</code></pre>\n<p>if the lambda has a capture however the conversion function is not defined, and the lambda cannot be converted to a regular function pointer.</p>\n", "LastEditorUserId": "657267", "LastActivityDate": "2014-10-29T09:33:59.470", "Score": "2", "CreationDate": "2014-10-29T09:21:27.873", "ParentId": "26626158", "CommentCount": "0", "LastEditDate": "2014-10-29T09:33:59.470", "OwnerUserId": "657267"}, "bq_ids": {"n4140": {"so_26626158_26626573_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 5965}}, "n3337": {"so_26626158_26626573_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 5734}}, "n4659": {"so_26626158_26626573_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 7456}}}, "26633571": {"Id": "26633571", "PostTypeId": "2", "Body": "<p>The answer given by @user657267 is correct. That is why a small wrapper is needed to convert lambas with capture to gsl_function.</p>\n<p><a href=\"https://stackoverflow.com/a/18413206/2472169\">Here is the wrapper for the f gsl_function</a> and <a href=\"https://stackoverflow.com/a/24602657/2472169\">Here is the wrapper for the fdf gsl_function</a></p>\n<p>You can  convert lambda functions to gsl_function after using the wrapper proposed in these two answers in the following way (I haven't invented the version with std::function, it was a well known answer. The template version I haven't seen before my answer). </p>\n<pre><code>// std::function version\ndouble a = 1;\ngsl_function_pp Fp([=](double x)-&gt;double{return a*x;}); \ngsl_function *F = static_cast&lt;gsl_function*&gt;(&amp;Fp); \n\n//template version\ndouble a = 1;\nauto ptr = [=](double x)-&gt;double{return a*x;};\ngsl_function_pp&lt;decltype(ptr)&gt; Fp(ptr);\ngsl_function *F = static_cast&lt;gsl_function*&gt;(&amp;Fp); \n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-29T14:54:24.433", "Score": "3", "CreationDate": "2014-10-29T14:54:24.433", "ParentId": "26626158", "CommentCount": "4", "LastEditDate": "2017-05-23T12:22:42.603", "OwnerUserId": "2472169"}, "26626158": {"ViewCount": "642", "Body": "<p>I am working with gsl to integrate a function. That function is built in a lambda function that has as input a double and a void *, and as output a double.\nNow, everything works fine if I use the lambda without any variable capture. But if I do variable capturing, it doesn't work any more.</p>\n<p>Could anyone explain me why so?</p>\n<p>Here are two snippets of code that I made up to explain my problem:</p>\n<p>This one works fine:</p>\n<pre><code>int main(int argc, char **argv)\n{\n\n    double beg = 0;\n    double end = 10;\n\n    auto f = [] (double x, void * p) {return 2.0;};\n\n    gsl_integration_workspace * w = gsl_integration_workspace_alloc (GSL_INTEGRATION_WORKSPACE_SIZE);\n\n    double result;\n    double error;\n\n    gsl_function F;\n    F.function = f;\n    F.params = NULL;\n\n    gsl_integration_qags (&amp;F, beg, end, 0, GSL_INTEGRATION_RELATIVE_PRECISION, GSL_INTEGRATION_WORKSPACE_SIZE, w, &amp;result, &amp;error);\n\n    cout&lt;&lt;result&lt;&lt;endl;\n\n}\n</code></pre>\n<p>While this one</p>\n<pre><code>int main(int argc, char **argv)\n{\n\n    double beg = 0;\n    double end = 10;\n\n    double p = 2.0;\n\n    auto f = [&amp;] (double x, void * p) {return p;};\n\n    gsl_integration_workspace * w = gsl_integration_workspace_alloc (GSL_INTEGRATION_WORKSPACE_SIZE);\n\n    double result;\n    double error;\n\n    gsl_function F;\n    F.function = f;\n    F.params = NULL;\n\n    gsl_integration_qags (&amp;F, beg, end, 0, GSL_INTEGRATION_RELATIVE_PRECISION, GSL_INTEGRATION_WORKSPACE_SIZE, w, &amp;result, &amp;error);\n\n    cout&lt;&lt;result&lt;&lt;endl;\n\n}\n</code></pre>\n<p>Yields on the line</p>\n<pre><code>F.function = f;\n</code></pre>\n<p>the following error:</p>\n<pre><code>Assigning to 'double (*)(double, void *)' from incompatible type '&lt;lambda at /[omissis]/main.cpp&gt;'\n</code></pre>\n", "AcceptedAnswerId": "26633571", "Title": "Numerical integration of lambda function with gsl", "CreationDate": "2014-10-29T08:58:42.180", "Id": "26626158", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-10-29T14:54:24.433", "Score": "2", "OwnerUserId": "774236", "Tags": "<c++><lambda><gsl><numerical-integration>", "AnswerCount": "2"}});