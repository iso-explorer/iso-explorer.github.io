post_cb({"22664296": {"CommentCount": "9", "AcceptedAnswerId": "22665367", "CreationDate": "2014-03-26T14:36:25.897", "LastActivityDate": "2014-03-27T15:13:43.917", "PostTypeId": "1", "ViewCount": "1214", "FavoriteCount": "1", "Title": "Using boost::future with continuations and boost::when_all", "Id": "22664296", "Score": "4", "Body": "<p>I would like to use <code>boost::future</code> with continuations and <code>boost::when_all</code> / <code>boost::when_any</code>.</p>\n<p>Boost <em>trunk</em> - not 1.55 - includes implementations for the latter (modeled after the proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3634.pdf\" rel=\"nofollow\">here</a>, upcoming for C++14/17 and Boost 1.56).</p>\n<p><a href=\"https://gist.github.com/oberstet\" rel=\"nofollow\">This</a> is what I have (and <strong>it does not compile</strong>):</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define BOOST_THREAD_PROVIDES_FUTURE\n#define BOOST_THREAD_PROVIDES_FUTURE_CONTINUATION\n#define BOOST_THREAD_PROVIDES_FUTURE_WHEN_ALL_WHEN_ANY\n#include &lt;boost/thread/future.hpp&gt;\n\nusing namespace boost;\n\nint main() {\n   future&lt;int&gt; f1 = async([]() { return 1; });\n   future&lt;int&gt; f2 = async([]() { return 2; });\n\n   auto f3 = when_all(f1, f2);\n\n   f3.then([](decltype(f3)) {\n      std::cout &lt;&lt; \"done\" &lt;&lt; std::endl;\n   });\n\n   f3.get();\n}\n</code></pre>\n<p>Clang 3.4 bails out with a <a href=\"https://gist.github.com/oberstet/9783364\" rel=\"nofollow\">this</a> - here is an excerpt:</p>\n<pre><code>/usr/include/c++/v1/memory:1685:31: error: call to deleted constructor of 'boost::future&lt;int&gt;'\n::new((void*)__p) _Up(_VSTD::forward&lt;_Args&gt;(__args)...);\n</code></pre>\n<p>Am I doing it wrong or is this a bug?</p>\n", "Tags": "<c++><c++11><boost><future><continuations>", "OwnerUserId": "884770", "AnswerCount": "1"}, "22665367": {"ParentId": "22664296", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The problem is that <code>when_all</code> may only be called with rvalue <code>future</code> or <code>shared_future</code>. From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3857.pdf\" rel=\"nofollow\">N3857</a>:</p>\n<blockquote>\n<pre><code>template &lt;typename... T&gt; \nsee below when_all(T&amp;&amp;... futures); \n</code></pre>\n<p id=\"so_22664296_22665367_0\"><em>Requires:</em> <code>T</code> is of type <code>future&lt;R&gt;</code> or <code>shared_future&lt;R&gt;</code>.</p>\n</blockquote>\n<p>Thanks to the reference-collapsing rules, passing an lvalue results in <code>T</code> being deduced to <code>future&lt;T&gt;&amp;</code> in violation of the stated requirement. The boost implementation doesn't check this precondition so you get an error deep in the template code where what should be a move of an rvalue future turns into an attempted copy of an lvalue future.</p>\n<p>You need to either move the futures into the <code>when_all</code> parameters:</p>\n<pre><code>auto f3 = when_all(std::move(f1), std::move(f2));\n</code></pre>\n<p>or avoid naming them in the first place:</p>\n<pre><code>auto f = when_all(async([]{return 1;}),\n                  async([]{return 2;}));\n</code></pre>\n<p>Also, you must <code>get</code> the future returned from <code>then</code> instead of the intermediate future:</p>\n<pre><code>auto done = f.then([](decltype(f)) {\n  std::cout &lt;&lt; \"done\" &lt;&lt; std::endl;\n});\n\ndone.get();\n</code></pre>\n<p>since the future upon which you call <code>then</code> is moved into the parameter of the continuation. From the description of <code>then</code> in N3857:</p>\n<blockquote>\n<p id=\"so_22664296_22665367_1\">Postcondition: </p>\n<ul>\n<li><p id=\"so_22664296_22665367_2\">The <code>future</code> object is moved to the parameter of the continuation function </p></li>\n<li><p id=\"so_22664296_22665367_3\"><code>valid() == false</code> on original <code>future</code> object immediately after it returns </p></li>\n</ul>\n</blockquote>\n<p>Per 30.6.6 [futures.unique_future]/3:</p>\n<blockquote>\n<p id=\"so_22664296_22665367_4\">The effect of calling any member function other than the destructor, the move-assignment operator, or <code>valid</code> on a <code>future</code> object for which <code>valid() == false</code> is undefined.</p>\n</blockquote>\n<p>You could avoid most of these issues in c++14 by avoiding naming the futures at all:</p>\n<pre><code>when_all(\n  async([]{return 1;}),\n  async([]{return 2;})\n).then([](auto&amp;) {\n  std::cout &lt;&lt; \"done\" &lt;&lt; std::endl;\n}).get();\n</code></pre>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-03-27T15:13:43.917", "Id": "22665367", "Score": "4", "CreationDate": "2014-03-26T15:15:54.770", "LastActivityDate": "2014-03-27T15:13:43.917"}, "bq_ids": {"n4140": {"so_22664296_22665367_2": {"section_id": 3163, "quality": 0.5714285714285714, "length": 4}, "so_22664296_22665367_4": {"section_id": 3107, "quality": 0.9375, "length": 15}}, "n3337": {"so_22664296_22665367_2": {"section_id": 3036, "quality": 0.5714285714285714, "length": 4}, "so_22664296_22665367_4": {"section_id": 2984, "quality": 0.9375, "length": 15}}, "n4659": {"so_22664296_22665367_2": {"section_id": 3925, "quality": 0.5714285714285714, "length": 4}, "so_22664296_22665367_4": {"section_id": 3869, "quality": 0.9375, "length": 15}}}});