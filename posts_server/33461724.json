post_cb({"33461829": {"Id": "33461829", "PostTypeId": "2", "Body": "<p>The problem with your design is that <strong>objects</strong> are derived and polymorphic, but not the arrays of objects.  </p>\n<p>For example,  <code>Electron</code> could have additional data that a <code>Particle</code> doesn't have. Then the size of an <code>Electron</code> object would no longer be the same size as a <code>Particle</code> object.  So  the pointer arithmetic that is needed to access array elements would not work anymore. </p>\n<p>This problem exist for raw pointers to array as well as for <code>unique_ptr</code>to array.  Only the objects themselves are polymorphic.  If you want to use them without the risk of <a href=\"https://en.wikipedia.org/wiki/Object_slicing\">slicing</a>,  you'd need an array of pointers to polymorphic objects.  </p>\n<p>If you look for additional arguments explaining why this design should be avoided, you may have a look at the section of Scott Meyers' book \"More effective C++\" titled \"Item 3: never treat arrays polymorphically\".   </p>\n<h2>Alternative: change your design</h2>\n<p>For example, use a <code>vector</code> of the real type to create your objects.  And use a vector to a polymorphic <code>Particle</code> pointer to use these objects polymorphically:  </p>\n<pre><code>vector&lt;Electron&gt;myelectrons(count);   // my real object store \nvector&lt;Particle*&gt;ve(count, nullptr);  // my adaptor for polymorphic access\ntransform(myelectrons.begin(), myelectrons.end(), ve.begin(), \n                [](Particle&amp;e){return &amp;e;} );  // use algorithm to populate easlily \nfor (auto x: ve)  // make plain use of C++11 to forget about container type and size\n   x-&gt;function(); \n</code></pre>\n<p>Here a <a href=\"http://ideone.com/SdKejD\">live demo</a>: </p>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2015-11-01T12:36:38.070", "Score": "7", "CreationDate": "2015-11-01T11:51:22.897", "ParentId": "33461724", "CommentCount": "0", "OwnerUserId": "3723423", "LastEditDate": "2015-11-01T12:36:38.070"}, "33461724": {"ViewCount": "841", "Body": "<p>In my code for numerical physics, I need to create an array of Derived objects using the <code>unique_ptr</code> with their type being the Base class. Normally, I would have:</p>\n<pre><code>// Header file of the Base class\nclass Particle{\npublic:\n    Particle();             // some constructor\n    virtual ~Particle();    // virtual destructor because of polymorphism\n    virtual function();     // some random function for demonstration\n};\n\n// Header file of the Derived class\nclass Electron : public Particle{\npublic:\n    Electron();\n    // additional things, dynamic_cast&lt;&gt;s, whatever\n};\n</code></pre>\n<p>Later in my code, to create an array of Derived objects with the Base type pointer, I would do</p>\n<pre><code>Particle* electrons = new Electron[count];\n</code></pre>\n<p>The advantage is that I am able to use the array in a really convenient way of <code>electrons[number].function()</code>, because the incremental value in <code>[]</code> is actually the address of the memory that points to the proper instance of the object <code>Electron</code> in the array. However, using raw pointers gets messy, so I decided to use the smart pointers.</p>\n<p>Problem is with the definition of the Derived objects. I can do the following:</p>\n<pre><code>std::unique_ptr&lt;Particle, std::default_delete&lt;Particle[]&gt;&gt; electrons(new Electron[count]);\n</code></pre>\n<p>which creates the array of polymorphic Electrons and uses even the proper call of <code>delete[]</code>. The problem lies in the way of calling the specific objects of the array, as I have to do this:</p>\n<pre><code>electrons.get()[number].function();\n</code></pre>\n<p>and I don't like the <code>get()</code> part, not a little bit.</p>\n<p>I could do the following:</p>\n<pre><code>std::unique_ptr&lt;Particle[]&gt; particles(new Particle[count]);\n</code></pre>\n<p>and yes, call the instances of <code>Particle</code> type in the array with the</p>\n<pre><code>particles[number].function();\n</code></pre>\n<p>and everything would be fine and dandy, except for the part that I am not using the specific details of the class <code>Electron</code>, therefore the code is useless.</p>\n<p>And now for the funny part, let's do one more thing, shall we?</p>\n<pre><code>std::unique_ptr&lt;Particle[]&gt; electrons(new Electron[count]);\n</code></pre>\n<p>BOOM!</p>\n<pre><code>use of deleted function \u2018std::unique_ptr&lt;_Tp [], _Dp&gt;::unique_ptr(_Up*) [with _Up = Electron; &lt;template-\n parameter-2-2&gt; = void; _Tp = Particle; _Dp = std::default_delete&lt;Particle []&gt;]\u2019\n</code></pre>\n<p>What is going on?</p>\n", "AcceptedAnswerId": "33464336", "Title": "std::unique_ptr<T[]> with an array of derived objects, use of deleted function", "CreationDate": "2015-11-01T11:36:51.787", "Id": "33461724", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-11-01T18:02:41.997", "LastEditorUserId": "3204551", "LastActivityDate": "2015-11-01T20:15:21.027", "Score": "12", "OwnerUserId": "1642850", "Tags": "<c++><arrays><c++11><polymorphism><unique-ptr>", "AnswerCount": "5"}, "33461934": {"Id": "33461934", "PostTypeId": "2", "Body": "<p>Use a std::vector or std::array (if you know how many) of std::unique_ptr.  Something like this:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nclass A\n{\npublic:\n\n    A() = default;\n    virtual ~A() = default;\n};\n\nclass B : public A\n{\npublic:\n\n    B() = default;\n    virtual ~B() = default;\n};\n\nint main(void)\n{\n    auto v = std::vector&lt;std::unique_ptr&lt;A&gt;&gt;();\n\n    v.push_back(std::make_unique&lt;A&gt;());\n    v.push_back(std::make_unique&lt;B&gt;());\n\n    return 0;\n}\n</code></pre>\n<p>Edit: In terms of speed I did a quick test with the 3 methods and this is what I found:</p>\n<pre><code>Debug\n\n6.59999430  : std::vector (with reserve, unique_ptr)\n5.68793220  : std::array (unique_ptr)\n4.85969770  : raw array (new())\n\nRelease\n\n4.81274890  : std::vector (with reserve, unique_ptr)\n4.42210580  : std::array (unique_ptr)\n4.12522340  : raw array (new())\n</code></pre>\n<p>Finally, I did a test where I used new() for all 3 versions instead of unique_ptr:</p>\n<pre><code>4.13924640 : std::vector\n4.14430030 : std::array\n4.14081580 : raw array\n</code></pre>\n<p>So you see there's really no difference in a release build, all else being equal.</p>\n", "LastEditorUserId": "416274", "LastActivityDate": "2015-11-01T12:48:45.573", "Score": "4", "CreationDate": "2015-11-01T12:03:52.013", "ParentId": "33461724", "CommentCount": "9", "OwnerUserId": "416274", "LastEditDate": "2015-11-01T12:48:45.573"}, "bq_ids": {"n4140": {"so_33461724_33461842_0": {"length": 37, "quality": 0.7551020408163265, "section_id": 416}, "so_33461724_33461842_1": {"length": 26, "quality": 0.8125, "section_id": 6144}}, "n3337": {"so_33461724_33461842_0": {"length": 47, "quality": 0.9591836734693877, "section_id": 407}}, "n4659": {"so_33461724_33461842_0": {"length": 37, "quality": 0.7551020408163265, "section_id": 434}, "so_33461724_33461842_1": {"length": 27, "quality": 0.84375, "section_id": 7640}}}, "33464336": {"Id": "33464336", "PostTypeId": "2", "Body": "<p>You could use a <code>std::unique_ptr&lt;std::unique_ptr&lt;Particle&gt;[]&gt;</code> if you want to keep close to your current code and are tracking the count separately anyway.</p>\n<p>Be aware that that won't get you around the additionaly indirection though, and if you can, using a <code>std::vector&lt;std::unique_ptr&lt;Particle&gt;&gt;</code> and thus including the length and a judicious use of <code>reserve</code> should not be slower.</p>\n", "LastActivityDate": "2015-11-01T16:21:28.547", "CommentCount": "1", "CreationDate": "2015-11-01T16:21:28.547", "ParentId": "33461724", "Score": "2", "OwnerUserId": "3204551"}, "33465159": {"Id": "33465159", "PostTypeId": "2", "Body": "<p>Amazingly, nobody yet has suggested just using a polymorphic deleter. The default deleter for unique_ptr is just that- a default. You can change it to do whatever you want, including up or down cast.</p>\n<p>It involves some casting, but you can hide that behind a suitable interface if you want.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/35bd4c3674d7df07\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/35bd4c3674d7df07</a></p>\n<p>I would not advise doing pointer indexing with this, though. That would still be totally broken.</p>\n", "LastActivityDate": "2015-11-01T17:43:25.287", "CommentCount": "1", "CreationDate": "2015-11-01T17:43:25.287", "ParentId": "33461724", "Score": "3", "OwnerUserId": "298661"}, "33461842": {"Id": "33461842", "PostTypeId": "2", "Body": "<p><code>std::unique_ptr</code> is preventing from shooting yourself in the foot, as <code>std::default_delete&lt;T[]&gt;</code> calls <code>delete[]</code>, which has the behaviour specified in the standard</p>\n<blockquote>\n<p id=\"so_33461724_33461842_0\">If a delete-expression begins with a unary :: operator, the\n  deallocation function\u2019s name is looked up in global scope. Otherwise,\n  if the delete-expression is used to deallocate a class object whose\n  static type has a virtual destructor, the deallocation function is the\n  one selected at the point of definition of the dynamic type\u2019s virtual\n  destructor (12.4). 117 <strong>Otherwise, if the delete-expression is used to\n  deallocate</strong> an object of class T or <strong>array</strong> thereof, the <strong>static and\n  dynamic types of the object shall be identical</strong> and the deallocation\n  function\u2019s name is looked up in the scope of T.</p>\n</blockquote>\n<p>In other words, code like this:</p>\n<pre><code>Base* p = new Derived[50];\ndelete[] p;\n</code></pre>\n<p>is undefined behaviour.</p>\n<p>It may have seem to work on some implementations - there, the <code>delete[]</code> call looks up the size of the allocated array and calls destructors on the elements - which requires the elements to have a well known size. Since the size of derived objects may differ, the pointer arithmetic goes wrong, and the destructors are called with the wrong address.</p>\n<p>Let's review what you tried:</p>\n<pre><code>std::unique_ptr&lt;Particle[]&gt; electrons(new Electron[count]);\n</code></pre>\n<p>there's a code in <code>std::unique_ptr</code>'s constructor that detects these violations, see <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr\" rel=\"nofollow noreferrer\">cppreference</a>.</p>\n<pre><code>std::unique_ptr&lt;Particle, std::default_delete&lt;Particle[]&gt;&gt; electrons(new Electron[count]);\n</code></pre>\n<p>is undefined behaviour, you essentially tell the compiler that <code>delete[]</code> is a valid way to release the resources you push to the constructor of <code>electrons</code>, which isn't true, as mentioned above.</p>\n<p><a href=\"https://stackoverflow.com/questions/33461724/stdunique-ptrt-with-an-array-of-derived-objects-use-of-deleted-function/33461842?noredirect=1#comment54716534_33461724\">...but wait, there is more (priceless comment by @T.C.):</a></p>\n<blockquote>\n<p id=\"so_33461724_33461842_1\">For addition or subtraction, if the expressions P or Q have type \u201cpointer to cv T\u201d, where T and the array element type are not similar ([conv.qual]), the behavior is undefined. [ Note: In particular, a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type.  \u2014 end note ]</p>\n</blockquote>\n<p>This means not only deleting an array is undefined behaviour, but so is indexing!</p>\n<pre><code>Base* p = new Derived[50]();\np[10].a_function(); // undefined behaviour\n</code></pre>\n<p>What does it mean to you? This means <em>you shouldn't use arrays polymorphically</em>. </p>\n<p>The only safe way with polymorphism is to use <code>std::unique_ptr</code> pointing to derived objects, like <code>std::vector&lt;std::unique_ptr&lt;Particle&gt;&gt;</code> (we don't have polymorphic use of array there, but arrays with polymorphic objects there)</p>\n<p>Since you mention that performance is critical, then dynamically allocating every <code>Particle</code> will be slow - in this case you can:</p>\n<ul>\n<li>use an object pool</li>\n<li>make use of flyweight pattern</li>\n<li>refactor it to avoid inheritance</li>\n<li>use <code>std::vector&lt;Electron&gt;</code> or <code>std::unique_ptr&lt;Electron[]&gt;</code> directly.</li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-01T20:15:21.027", "Score": "10", "CreationDate": "2015-11-01T11:52:30.003", "ParentId": "33461724", "CommentCount": "6", "OwnerUserId": "1012936", "LastEditDate": "2017-05-23T12:08:41.390"}});