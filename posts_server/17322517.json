post_cb({"17322517": {"ViewCount": "512", "Body": "<p>I am currently reading a book about templates and it gives the following example:</p>\n<pre><code>#include &lt;string&gt;\n\n// note: reference parameters\ntemplate &lt;typename T&gt;\ninline T const&amp; max (T const&amp; a, T const&amp; b)\n{\n    return  (a &lt; b)  ?  (b) : (a);\n}\n\nint main()\n{\n    char* a=\"apple\";\n    char* p=\"peach\"; \n    ::max(a,p);   // OK, BUT \n    ::max(\"apple\",\"peach\");//  &lt;&lt;&lt;&lt; ERROR IN VISUAL STUDIO 2012, WHY?\n}\n</code></pre>\n<p>I do not understand why VS2012 says: </p>\n<blockquote>\n<p id=\"so_17322517_17322517_0\">error C2440: 'return' : cannot convert from 'const char *' to 'const char (&amp;)[6]'</p>\n</blockquote>\n<p>Can please someone explain this to me?\nThe book says that this should be ok, but it's an old book, I am still waiting for the new one.</p>\n", "AcceptedAnswerId": "17322890", "Title": "C++ Template issue with visual studio 2012", "CreationDate": "2013-06-26T14:11:28.703", "Id": "17322517", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-06-26T15:04:33.460", "Score": "1", "OwnerUserId": "581637", "Tags": "<c++><templates><visual-studio-2012>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_17322517_17323105_0": {"length": 14, "quality": 1.0, "section_id": 6170}}, "n3337": {"so_17322517_17323105_0": {"length": 14, "quality": 1.0, "section_id": 5931}}, "n4659": {"so_17322517_17323105_0": {"length": 14, "quality": 1.0, "section_id": 7668}}}, "17323105": {"Id": "17323105", "PostTypeId": "2", "Body": "<p>The reason for the error is the following:</p>\n<p>A string literal is of type <code>const char[X]</code>, with X being the length of the string, including the zero delimiter. In your case it's 6, so in total <code>T</code> is <code>const char[6]</code>.<br>\nComparing C-arrays with relational operators is not possible, so the compiler applies the \"array to pointer decay\", meaning in <code>(a &lt; b)</code>, a and b are treated as pointers.<br>\nIt seems as if Visual Studio applies that decay for the whole expression, i.e. it treats a and b as pointers in <code>(b) : (a)</code>, too.<br>\nThe whole expression then has the type <code>char const*</code>, but the return type is <code>T const&amp;</code>, meaning <code>const char(&amp;)[6]</code>, and the pointer is not convertible backwards to that. I believe it to be a bug in VS2012.</br></br></br></p>\n<p><strong>Update:</strong>\nHere's a standard quote to support the claim that this is a bug:<br>\n<strong>\u00a75.16,4:</strong></br></p>\n<blockquote>\n<p id=\"so_17322517_17323105_0\">If the second and third operands are glvalues of the same value category and have the same type, the result is of that type and value category [...]</p>\n</blockquote>\n<p><strong>Sidenote 1</strong>: You include <code>&lt;string&gt;</code>, wich is not possible. Be aware that string literals are not <code>std::string</code>s, mostyl for backward compatibility reasons with C.<br>\n<strong>Sidenote 2</strong>: You assign string literals to <code>char *</code>, wich is deprecated. String literals are of type <code>char const[]</code>, so decaying them to <code>char*</code> is a speciality, again due to backward compatibility reasons. If you indeed treat the string behind that pointer as non-const and write to them, you will get undefined behavior. So prefer <code>char const*</code>, your compiler should warn you about those anyways.<br>\n<strong>Sidenote 3</strong>: In C++, pointers are not totally ordered. So the coparison of the decayed arrays, meaning of the pointers in the max function is implementation defined, wich you will want to avoid in portable programs. It has no meaning anyways, since it copares addresses, not the string literal contents.\n<strong>Sidenote 4</strong>: You got lucky that \"apple\" and \"peach\" are of same length. If they were not, e.g. \"apples\" and \"peaches\", the compiler would see char literals of type <code>const char[7]</code> and <code>const char[8]</code> and would not know what <code>T</code> should be: <a href=\"http://ideone.com/fp2WmJ\" rel=\"nofollow\">http://ideone.com/fp2WmJ</a></br></br></p>\n", "LastEditorUserId": "1838266", "LastActivityDate": "2013-06-26T15:04:33.460", "Score": "1", "CreationDate": "2013-06-26T14:35:49.483", "ParentId": "17322517", "CommentCount": "1", "OwnerUserId": "1838266", "LastEditDate": "2013-06-26T15:04:33.460"}, "17323346": {"Id": "17323346", "PostTypeId": "2", "Body": "<p>While instantiating the function template <code>max</code>, the template parameter <code>T</code> is deduced from the arguments. In your example, it is of type <code>char const [6]</code>, an array of six characters.</p>\n<p>The expression <code>(a &lt; b)  ?  (b) : (a)</code> will convert both <code>(a)</code> and <code>(b)</code> to a pointer (rule 5.16.6, \"array-to-pointer (4.2), [...] standard conversions are performed on the second and third operands\".)</p>\n<p>The compiler will then try to convert the resulting <code>char const *</code> to a <code>T</code> (the return type), which is a <code>char const[6]</code>, hence your error.</p>\n<p>GCC does not exhibit this behavior because it doesn't convert the arrays to a pointer <em>if they are of the same type</em>, that is, an array of char of the same size. The error still appears as long as the two char arrays are of different size.</p>\n<p>Anyway, comparing char arrays probably doesn't work the way you think, so it would be better to just use <a href=\"http://en.cppreference.com/w/cpp/string\" rel=\"nofollow\"><code>std::string</code></a> instead.</p>\n", "LastActivityDate": "2013-06-26T14:45:55.433", "CommentCount": "3", "CreationDate": "2013-06-26T14:45:55.433", "ParentId": "17322517", "Score": "0", "OwnerUserId": "361535"}, "17322890": {"Id": "17322890", "PostTypeId": "2", "Body": "<p>The issue is that in the second case, you <code>T const&amp;</code> is being deduced to <code>const char(&amp;)[6]</code>, which is a reference to an array of 6 characters. </p>\n<p>In VS2012, when you do the comparison using the <code>?:</code>, it's decaying the array references to <code>char*</code>, which is then not able to be returned as a reference.  GCC 4.7.2 doesn't exhibit this decay (See <a href=\"https://ideone.com/yIBZWi\" rel=\"nofollow\">https://ideone.com/yIBZWi</a> ).</p>\n<p>Can you try the less compact version below (I don't have VS2012 on hand)?  It should be able to avoid the decay by not using a and b together in the return.</p>\n<pre><code>template &lt;typename T&gt;\ninline T const&amp; max (T const&amp; a, T const&amp; b)\n{\n    if(a&lt;b)\n       return b;\n    else\n       return a;\n}\n</code></pre>\n", "LastActivityDate": "2013-06-26T14:26:35.833", "CommentCount": "4", "CreationDate": "2013-06-26T14:26:35.833", "ParentId": "17322517", "Score": "3", "OwnerUserId": "862231"}});