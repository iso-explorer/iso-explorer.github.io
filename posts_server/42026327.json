post_cb({"42026327": {"CommentCount": "4", "ViewCount": "119", "CreationDate": "2017-02-03T14:18:08.627", "LastActivityDate": "2017-02-03T15:32:13.947", "Title": "Is std::move(a).m an xvalue or a prvalue?", "AcceptedAnswerId": "42027557", "PostTypeId": "1", "Id": "42026327", "Score": "3", "Body": "<p>Let's say <code>m</code> is a non-static data member of non-reference type (<code>T</code>). According to   <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">cppreference</a>, <code>std::move(a).m</code> is a prvalue until c++11. I guess it should be an xvalue after c++11. Please correct me if I'm wrong. </p>\n<p>But the <code>decltype(std::move(a).m)</code> is still <code>T</code> (not <code>T&amp;&amp;</code>) in c++14 (visual studio, clang, gcc), which suggest <code>std::move(a).m</code> is still a prvalue. So is <code>std::move(a).m</code> an xvalue or a prvalue?</p>\n", "Tags": "<c++11><c++14><decltype><rvalue><xvalue>", "OwnerUserId": "5247961", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42026327_42027557_1": {"section_id": 5940, "quality": 0.8695652173913043, "length": 20}, "so_42026327_42027557_2": {"section_id": 5440, "quality": 0.6607142857142857, "length": 37}}, "n3337": {"so_42026327_42027557_1": {"section_id": 5711, "quality": 0.8695652173913043, "length": 20}, "so_42026327_42027557_2": {"section_id": 5235, "quality": 0.6428571428571429, "length": 36}}, "n4659": {"so_42026327_42027557_0": {"section_id": 8741, "quality": 0.9310344827586207, "length": 27}, "so_42026327_42027557_2": {"section_id": 6867, "quality": 0.8392857142857143, "length": 47}, "so_42026327_42027557_1": {"section_id": 7424, "quality": 0.8695652173913043, "length": 20}}}, "42027557": {"ParentId": "42026327", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><code>std::move(a).m</code> is an xvalue. </p>\n<p>The new wordings make that much clearer, in [basic.lval]:</p>\n<blockquote id=\"so_42026327_42027557_0\">\n<ul>\n<li>A <em>prvalue</em> is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears.  </li>\n<li>An <em>xvalue</em> is a glvalue that denotes an object or bit-field whose resources can be reused (usually because it is near the end of its lifetime).</li>\n</ul>\n</blockquote>\n<p>By those definitions, <code>std::move(a).m</code> is an xvalue and not a prvalue as it denotes an object. </p>\n<p>The way I find best to think about this is that glvalues have identity and rvalues are safe to move from - where lvalues have identity and are not safe to move from, xvalues have identity and are safe to move from, and prvalues do not have identity and are safe to move from. This taxonomy makes these kinds of questions easier to reason about.</p>\n<p>Additionally there is a note in [expr], which is more specific:</p>\n<blockquote>\n<p id=\"so_42026327_42027557_1\">[ Note: An expression is an xvalue if it is: [...]<br>\n  \u2014 a cast to an rvalue reference to object type,<br>\n  \u2014 a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or [...]<br>\n  \u2014end note ]</br></br></br></p>\n</blockquote>\n<p><code>std::move(a)</code> is a cast to rvalue reference, so is an xvalue. <code>std::move(a).m</code> is a class member access of an xvalue, so is an xvalue.</p>\n<hr/>\n<p>As for <code>decltype(std::move(a).m)</code>. Note that the word itself comes from <strong>decl</strong>ared <strong>type</strong>. The rules for what <code>decltype(e)</code> means are complicated, from [dcl.type.simple]:</p>\n<blockquote>\n<p id=\"so_42026327_42027557_2\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:<br>\n  \u2014 if <code>e</code> is an unparenthesized <em>id-expression</em> naming an lvalue or reference introduced from the <em>identifier-list</em> of a decomposition declaration, <code>decltype(e)</code> is the referenced type as given in the specification of the\n  decomposition declaration (8.5);<br>\n  \u2014 <strong>otherwise</strong>, if <code>e</code> is an unparenthesized <em>id-expression</em> <strong>or an unparenthesized class member access (5.2.5),\n  <code>decltype(e)</code> is the type of the entity named by <code>e</code></strong>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;<br>\n  \u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;<br>\n  \u2014 otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;<br>\n  \u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</br></br></br></br></br></p>\n</blockquote>\n<p>In this case, we have a class member access, so you just get the type of <code>m</code> - which is <code>M</code> and not <code>M&amp;&amp;</code>. On some level this makes sense, you're asking for the declared type of <code>m</code> and you got the declared type of <code>m</code>. </p>\n<p>If you want to categorize it properly, you can force that bullet to be ignored with an extra set of parentheses (obviously): <code>decltype((std::move(a).m))</code> would give you <code>M&amp;&amp;</code>.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-02-03T15:32:13.947", "Id": "42027557", "Score": "2", "CreationDate": "2017-02-03T15:24:03.767", "LastActivityDate": "2017-02-03T15:32:13.947"}});