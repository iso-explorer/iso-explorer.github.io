post_cb({"24277379": {"CommentCount": "3", "ViewCount": "191", "PostTypeId": "1", "LastEditorUserId": "1619294", "CreationDate": "2014-06-18T05:02:08.647", "LastActivityDate": "2014-06-18T10:01:34.067", "Title": "When using typeid on a polymorphic object, must it be defined?", "AcceptedAnswerId": "24277450", "LastEditDate": "2014-06-18T05:08:07.047", "Id": "24277379", "Score": "6", "Body": "<p>When using <code>typeid</code> on a polymorphic object, I think the object must be defined (not just a declaration) because <code>typeid</code> operation needs to get the object's information at <strong>runtime</strong>. Here's my code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nclass D {\n    virtual ~D() {}\n};\nextern D d;\n\nint main()\n{\n    std::cout &lt;&lt; typeid(d).name() &lt;&lt; std::endl;\n    std::cout &lt;&lt; sizeof(d) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And with <a href=\"http://rextester.com/JPLNWO25452\" rel=\"nofollow\">clang 3.4</a>, I got the link error:</p>\n<blockquote>\n<p id=\"so_24277379_24277379_0\">undefined reference to `d'</p>\n</blockquote>\n<p>But with <a href=\"http://rextester.com/ZXLKL54821\" rel=\"nofollow\">g++ 4.8.1</a>, it works well and I got the result:</p>\n<blockquote>\n<p id=\"so_24277379_24277379_1\">1D<br>\n  8</br></p>\n</blockquote>\n<p>My question:</p>\n<ol>\n<li>Which one is right?</li>\n<li>How does g++ implement <code>typeid</code>? How can it get the information from a polymorphic object without definition?</li>\n</ol>\n", "Tags": "<c++><g++><language-lawyer><clang++><typeid>", "OwnerUserId": "3309790", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24277379_24277450_1": {"section_id": 6021, "quality": 0.9285714285714286, "length": 39}}, "n3337": {"so_24277379_24277450_1": {"section_id": 5789, "quality": 0.9285714285714286, "length": 39}}, "n4659": {"so_24277379_24277450_1": {"section_id": 7520, "quality": 0.9285714285714286, "length": 39}}}, "24277450": {"ParentId": "24277379", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/typeid\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/typeid</a></p>\n<blockquote>\n<p id=\"so_24277379_24277450_0\">a) If expression is a glvalue expression that identifies an object of a polymorphic type (that is, a class that declares or inherits at least one virtual function), the <code>typeid</code> expression evaluates the expression and then refers to the <code>std::type_info</code> object that represents the dynamic type of the expression. If the result of the evaluated expression is a null pointer, an exception of type <code>std::bad_typeid</code> or a type derived from <code>std::bad_typeid</code> is thrown.</p>\n</blockquote>\n<p>Sounds like clang 3.4 is right.</p>\n<p><strong>Update</strong></p>\n<p>The standard says:</p>\n<blockquote>\n<p id=\"so_24277379_24277450_1\">When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers to a <code>std::type_info</code> object representing the type of the most derived object (1.8) (that is, the dynamic type) to which the glvalue refers. If the glvalue expression is obtained by applying the unary * operator to a pointer and the pointer is a null pointer value (4.10), the typeid expression throws the <code>std::bad_typeid</code>\n  exception (18.7.3).</p>\n</blockquote>\n<p>It is slightly different from the language used by cppreference.com but it still points to clang 3.4 being right.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2014-06-18T05:20:28.020", "Id": "24277450", "Score": "2", "CreationDate": "2014-06-18T05:08:50.463", "LastActivityDate": "2014-06-18T05:20:28.020"}});