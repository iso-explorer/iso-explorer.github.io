post_cb({"30765151": {"CommentCount": "1", "ViewCount": "42", "PostTypeId": "1", "LastEditorUserId": "15055", "CreationDate": "2015-06-10T19:05:53.613", "LastActivityDate": "2015-06-10T19:43:02.440", "Title": "Why can't this metametafunction's template parameter be deduced?", "AcceptedAnswerId": "30765293", "LastEditDate": "2015-06-10T19:33:50.443", "Id": "30765151", "Score": "1", "Body": "<p>I have the following wrapper-maker metametafunction:</p>\n<pre><code>template &lt;class ToWrap&gt;\nstruct wrapper_maker\n{\n    template &lt;bool&gt;\n    struct wrapper\n    {\n        wrapper(ToWrap&amp; a) : a(a) { }\n        ToWrap&amp; a;\n    };\n};\n</code></pre>\n<p>I want to use it in this template function <code>foo</code>:</p>\n<pre><code>template &lt;class ToWrap&gt;\nvoid foo(typename wrapper_maker&lt;ToWrap&gt;::template wrapper&lt;true&gt;&amp; wrapped)\n{\n    cout &lt;&lt; \"foo\" &lt;&lt; endl;\n}\n</code></pre>\n<p>Note: the use case is that <code>foo</code> already exists with different overloads, yet I want this particular overload to be called if the object is a <code>wrapper_maker&lt;ToWrap&gt;::wrapper&lt;bool&gt;</code> instance.</p>\n<p>However, when I write a function that calls <code>foo</code> with such an object:</p>\n<pre><code>template &lt;class ToWrap&gt;\nvoid call_foo(ToWrap&amp; o)\n{\n    typedef typename wrapper_maker&lt;ToWrap&gt;::template wrapper&lt;true&gt; wrapped_t;\n    wrapped_t wrapped(o);\n    foo(wrapped);\n}\n</code></pre>\n<p>Using it as so:</p>\n<pre><code>int to_wrap = 5;\ncall_foo(to_wrap);\n</code></pre>\n<p>I get this error:</p>\n<pre><code>prog.cpp: In instantiation of 'void call_foo(ToWrap&amp;) [with ToWrap = int]':\nprog.cpp:32:18:   required from here\nprog.cpp:27:16: error: no matching function for call to 'foo(wrapped_t&amp;)'\n     foo(wrapped);\n                ^\nprog.cpp:27:16: note: candidate is:\nprog.cpp:17:6: note: template&lt;class ToWrap&gt; void foo(typename wrapper_maker&lt;ToWrap&gt;::wrapper&lt;true&gt;&amp;)\n void foo(typename wrapper_maker&lt;ToWrap&gt;::template wrapper&lt;true&gt;&amp; wrapped)\n      ^\nprog.cpp:17:6: note:   template argument deduction/substitution failed:\nprog.cpp:27:16: note:   couldn't deduce template parameter 'ToWrap'\n     foo(wrapped);\n</code></pre>\n<p>Why is that?</p>\n<p>EDIT: Further, is there any way to define a specialization of <code>foo</code> that will get called on instances of <code>wrapper_maker&lt;T&gt;::wrapper&lt;W&gt;</code>, for any possible <code>T</code>, without having to specify either <code>T</code> or <code>W</code> at the call-site?</p>\n", "Tags": "<c++><templates><template-meta-programming>", "OwnerUserId": "15055", "AnswerCount": "1"}, "30765293": {"ParentId": "30765151", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This:</p>\n<pre><code>template &lt;class ToWrap&gt;\nvoid foo(typename wrapper_maker&lt;ToWrap&gt;::template wrapper&lt;true&gt;&amp; wrapped)\n</code></pre>\n<p>Is a non-deduced context. Specifically, the first one in the list from [temp.deduct.type]4/5:</p>\n<blockquote>\n<p id=\"so_30765151_30765293_0\">If a template parameter is used only in non-deduced\n  contexts and is not explicitly specified, template argument deduction fails.</p>\n<p id=\"so_30765151_30765293_1\">The non-deduced contexts are:<br>\n  (5.1) \u2014 The <em>nested-name-specifier</em> of a type that was specified using a <em>qualified-id</em>.</br></p>\n</blockquote>\n<p>You need to explicitly pass in <code>ToWrap</code> to make that work. </p>\n<p>Let me provide another example as to why this may be the case. Suppose we had:</p>\n<pre><code>template &lt;typename T&gt; struct some_fn;\ntemplate &lt;&gt; struct some_fn&lt;A&gt; { using type = int; };\ntemplate &lt;&gt; struct some_fn&lt;B&gt; { using type = int; };\n\ntemplate &lt;typename T&gt;\nvoid foo (typename some_fn&lt;T&gt;::type);\n\nfoo(0); // what should T be?\n</code></pre>\n<p>In general, in order to implement this, the compiler would have to know every possible specialization of <code>some_fn</code> - even if there were only one for which <code>some_fn&lt;T&gt;::type</code> were <code>int</code>. </p>\n<blockquote>\n<p id=\"so_30765151_30765293_2\">Further, is there any way to define a specialization of foo that will get called on instances of <code>wrapper_maker&lt;T&gt;::wrapper&lt;W&gt;</code>, for any possible <code>T</code>, without having to specify either <code>T</code> or <code>W</code> at the call-site?</p>\n</blockquote>\n<p>In general, no, for the same reasons articulated above. However, you can just add additional info to <code>wrapper</code>:</p>\n<pre><code>template &lt;class ToWrap&gt;\nstruct wrapper_maker\n{\n    template &lt;bool b&gt;\n    struct wrapper\n    {\n        static constexpr bool value = b;\n        using to_wrap = ToWrap;\n\n        // etc.\n    };\n};\n\ntemplate &lt;typename WrapperT&gt;\nvoid foo(WrapperT&amp; wrapped) {\n    // typename WrapperT::to_wrap is your T\n    // WrappedT::value is your W\n}\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-06-10T19:43:02.440", "Id": "30765293", "Score": "3", "CreationDate": "2015-06-10T19:14:09.160", "LastActivityDate": "2015-06-10T19:43:02.440"}, "bq_ids": {"n4140": {"so_30765151_30765293_0": {"section_id": 335, "quality": 1.0, "length": 10}, "so_30765151_30765293_1": {"section_id": 336, "quality": 0.8, "length": 8}}, "n3337": {"so_30765151_30765293_0": {"section_id": 325, "quality": 1.0, "length": 10}, "so_30765151_30765293_1": {"section_id": 326, "quality": 0.8, "length": 8}}, "n4659": {"so_30765151_30765293_0": {"section_id": 344, "quality": 1.0, "length": 10}, "so_30765151_30765293_1": {"section_id": 345, "quality": 0.8, "length": 8}}}});