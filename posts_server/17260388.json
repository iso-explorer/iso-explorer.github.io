post_cb({"bq_ids": {"n4140": {"so_17260388_17260413_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 735}}, "n3337": {"so_17260388_17260413_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 724}}, "n4659": {"so_17260388_17260413_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 764}}}, "17260413": {"Id": "17260413", "PostTypeId": "2", "Body": "<p>Nothing bad will happen, as the vector makes a copy of the pair (and each of the two strings in it).</p>\n<p>To back this up, here is the relevant quote from the Standard (C++11, \u00a723.2.3, in the big table on page 738 of the official edition):</p>\n<blockquote>\n<p id=\"so_17260388_17260413_0\"><code>a.push_back(t)</code> [...] Appends a copy of <code>t</code> // <em>Requires:</em> <code>T</code> shall be <code>CopyInsertable</code> into <code>X</code>.</p>\n</blockquote>\n<p>Here, <code>X</code> stands for the vector type, and <code>t</code> for an lvalue or constant rvalue of type <code>T</code>, which is the type of the member elements. So this applies to your case. (If the pair were to be created on the fly, i.e. inside the <code>push_back(...)</code> function call, you'd have a temporary rvalue, which means a different table row would apply and you'd get a move instead of a copy, but there would still not be any problems.)</p>\n<p>A vector stores copies of its elements. (The only danger exists when you have a vector whose element types are defined as a pointer type, or some struct or class that has pointer members. The vector then, of course, makes copies only of the pointers, not deep copies of the content; or in the case of a struct or class type, it makes copies as defined by the copy constructor of that data type. But for a <code>std::pair</code> of <code>std::string</code>, all will work as expected.)</p>\n", "LastEditorUserId": "777186", "LastActivityDate": "2013-06-23T11:50:53.607", "Score": "2", "CreationDate": "2013-06-23T11:43:03.663", "ParentId": "17260388", "CommentCount": "1", "OwnerUserId": "777186", "LastEditDate": "2013-06-23T11:50:53.607"}, "17260388": {"ViewCount": "150", "Body": "<p>In my class I have a member</p>\n<pre><code>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; mEnvironment;\n</code></pre>\n<p>Now I wrote a function which loads this vector with the process environment as key/value pairs. I don't need to access the members, so I don't use a map, and figured that a vector would be better, as I only iterate over it.</p>\n<pre><code>void Environment::setEnvironment(char const *oEnvironment[])\n{\n    mEnvironment.clear();\n    if(oEnvironment == NULL)\n        return;\n\n    std::string name;\n    std::string value;\n    std::pair&lt;std::string, std::string&gt; entry;\n    for(const char **envp = oEnvironment; *envp != NULL; envp++)\n    {\n        const char *env = *envp;\n        name.clear();\n        value.clear();\n\n        for(env = *envp; *env != 0; env++)\n        {\n            if(*env == '=')\n            {\n                env++;\n                break;\n            }\n\n            name += *env;\n        }\n\n        value = env;\n\n        entry = std::make_pair(name, value);\n        mEnvironment.push_back(entry);\n    }\n}\n</code></pre>\n<p>Since the variable <code>entry</code> is local, I wonder what happens with the <code>push_back(entry)</code> when the function goes out of scope. will the objects, I put into the vector, persist, or will the destructor be called? Or even worse, will it simpley be overwritten or do I have to create a new pair object in the loop instead?</p>\n", "AcceptedAnswerId": "17260413", "Title": "Would this corrupt the stack using a local variable?", "CreationDate": "2013-06-23T11:40:15.493", "Id": "17260388", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-06-23T11:50:53.607", "Score": "4", "OwnerUserId": "2282011", "Tags": "<c++><std>", "AnswerCount": "1"}});