post_cb({"39465725": {"CommentCount": "4", "ViewCount": "266", "PostTypeId": "1", "LastEditorUserId": "1639256", "CreationDate": "2016-09-13T08:43:48.497", "LastActivityDate": "2016-09-13T14:31:24.980", "Title": "Function template modifies parameter declared with top-level const: clang bug?", "AcceptedAnswerId": "39468475", "LastEditDate": "2016-09-13T14:31:24.980", "Id": "39465725", "Score": "8", "Body": "<p>The code below compiles correctly on <code>clang 3.8.1-1</code> on ArchLinux.</p>\n<p>Is this <code>clang</code> bug?</p>\n<p><code>gcc</code> issue correct warning/error on this.</p>\n<pre><code>template &lt;class T&gt;\nstruct BugReproducer{\n    using size_type = typename T::size_type;\n\n    int bug1(size_type count);\n    int bug2(size_type count) const;\n    static int bug3(size_type count);\n};\n\ntemplate &lt;class T&gt;\nint BugReproducer&lt;T&gt;::bug1(size_type const count){\n    // this is a bug. must be not allowed\n    count = 5;\n\n    // return is to use the result...\n    return count;\n}\n\ntemplate &lt;class T&gt;\nint BugReproducer&lt;T&gt;::bug2(size_type const count) const{\n    // same for const method\n    count = 5;\n    return count;\n}\n\ntemplate &lt;class T&gt;\nint BugReproducer&lt;T&gt;::bug3(size_type const count){\n    // same for static method\n    count = 5;\n    return count;\n}\n\n\n\nstruct DummyVector{\n    using size_type = int;\n};\n\n\n\nint main(){\n    using BugRepr = BugReproducer&lt;DummyVector&gt;;\n\n    BugRepr reproducer;\n\n    auto a = reproducer.bug1(1);\n    auto b = reproducer.bug2(1);\n    auto c = BugRepr::bug3(1);\n\n    // return is to use the result...\n    return a + b + c;\n}\n</code></pre>\n<p>Here how I compile:</p>\n<pre><code>[nmmm@zenbook HM3]$ clang x.cc -std=c++11 -lstdc++ -Wall -Wpedantic -Wconversion\n</code></pre>\n<p><code>clang</code> and <code>c++14</code> - same result.</p>\n<pre><code>[nmmm@zenbook HM3]$ clang x.cc -std=c++14 -lstdc++ -Wall -Wpedantic -Wconversion\n</code></pre>\n<p>Here is gcc output:</p>\n<pre><code>[nmmm@zenbook HM3]$ gcc x.cc -std=c++11 -lstdc++ -Wall -Wpedantic -Wconversion\nx.cc: In instantiation of \u2018int BugReproducer&lt;T&gt;::bug1(BugReproducer&lt;T&gt;::size_type) [with T = DummyVector; BugReproducer&lt;T&gt;::size_type = int]\u2019:\nx.cc:46:28:   required from here\nx.cc:13:8: error: assignment of read-only parameter \u2018count\u2019\n  count = 5;\n  ~~~~~~^~~\nx.cc: In instantiation of \u2018int BugReproducer&lt;T&gt;::bug2(BugReproducer&lt;T&gt;::size_type) const [with T = DummyVector; BugReproducer&lt;T&gt;::size_type = int]\u2019:\nx.cc:47:28:   required from here\nx.cc:22:8: error: assignment of read-only parameter \u2018count\u2019\n  count = 5;\n  ~~~~~~^~~\nx.cc: In instantiation of \u2018static int BugReproducer&lt;T&gt;::bug3(BugReproducer&lt;T&gt;::size_type) [with T = DummyVector; BugReproducer&lt;T&gt;::size_type = int]\u2019:\nx.cc:48:20:   required from here\nx.cc:29:8: error: assignment of read-only parameter \u2018count\u2019\n  count = 5;\n  ~~~~~~^~~\n</code></pre>\n", "Tags": "<c++><c++11><clang><c++14>", "OwnerUserId": "964080", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39465725_39468475_0": {"section_id": 3241, "quality": 0.8333333333333334, "length": 20}}, "n3337": {"so_39465725_39468475_0": {"section_id": 3114, "quality": 0.8333333333333334, "length": 20}}, "n4659": {"so_39465725_39468475_0": {"section_id": 3997, "quality": 0.8333333333333334, "length": 20}}}, "39468475": {"ParentId": "39465725", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes, this is a bug in clang; filed at <a href=\"https://llvm.org/bugs/show_bug.cgi?id=30365\" rel=\"nofollow noreferrer\">https://llvm.org/bugs/show_bug.cgi?id=30365</a>.</p>\n<p>The nature of the bug is that in a class template member function definition appearing outside (<strong>[class.mfct]</strong>/1) the class template, with the type of a parameter dependent on the class template parameters, clang uses the parameter type of the declaration rather than the parameter type of the definition where they differ in topmost cv-qualification. Simplified example:</p>\n<pre><code>template&lt;class T&gt; struct A { void f(typename T::U); };\ntemplate&lt;class T&gt; void A&lt;T&gt;::f(typename T::U const i) { i = 1; }\nstruct X { using U = int; };\nint main() { A&lt;X&gt;{}.f(0); }\n</code></pre>\n<p>Per <strong>[dcl.fct]</strong>/5 the type of <code>i</code> within the definition of <code>A&lt;X&gt;::f</code> is <code>int const</code> (<a href=\"https://stackoverflow.com/questions/117293/use-of-const-for-function-parameters\">Use of 'const' for function parameters</a>):</p>\n<blockquote>\n<p id=\"so_39465725_39468475_0\">5 - [...] After producing the list of parameter types, any top-level <em>cv-qualifiers</em> modifying a parameter\n  type are deleted when forming the function type. [...] \n  [ <em>Note:</em> This transformation does not affect the types of the parameters. [...] \u2014 <em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "567292", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:06.200", "Id": "39468475", "Score": "5", "CreationDate": "2016-09-13T11:04:50.133", "LastActivityDate": "2016-09-13T11:15:28.977"}});