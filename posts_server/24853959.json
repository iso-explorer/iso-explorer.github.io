post_cb({"24854152": {"ParentId": "24853959", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>You have a bug, because the call to <code>::operator new()</code> could throw <code>std::bad_alloc</code>, violating the exception-specification of your class-specific allocator (zybox's <a href=\"https://stackoverflow.com/a/24854043/103167\">answer</a> shows how to fix this).  However, that's very unlikely to happen in such a small program.  It's also a bad idea to override <code>operator new()</code> without also providing <code>operator delete()</code>, although I can't find an explicit requirement that both must be found in the same scope.</p>\n<p>Returning a null pointer from your allocator is both legal and the correct way to indicate an allocation failure.  In 3.7.4.1, the Standard says that:</p>\n<blockquote>\n<p id=\"so_24853959_24854152_0\">An  allocation  function  that  fails  to  allocate  storage  can  invoke  the  currently  installed  new-handler  function (18.6.2.3), if any.  [ Note:  A program-supplied allocation function can obtain the address of the currently installed <code>new_handler</code> using the <code>std::get_new_handler</code> function (18.6.2.4).  \u2014 end note ] If an allocation function declared with a non-throwing <em>exception-specification</em> (15.4) fails to allocate storage, it shall return a null pointer. Any other allocation function that fails to allocate storage shall indicate failure only by throwing an exception (15.1) of a type that would match a handler (15.3) of type std::bad_alloc (18.6.2.1).</p>\n</blockquote>\n<p>Then in 5.3.4:</p>\n<blockquote>\n<p id=\"so_24853959_24854152_1\">If the allocation function returns null, initialization shall not be done, the deallocation function shall not be called, and the value of the new-expression shall be null.</p>\n</blockquote>\n<p>The code is legal on the path that <code>::operator new()</code> doesn't throw -- the expression <code>new A()</code> in <code>main()</code> evaluates to a null pointer, which is ok because it never gets dereferenced.</p>\n<p>You shouldn't get a constructor call either.  What you should get is a memory leak, since there is no <code>::operator delete()</code> call corresponding to the <code>::operator new(t)</code> inside your allocator.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:08:13.660", "Id": "24854152", "Score": "5", "CreationDate": "2014-07-20T19:34:29.263", "LastActivityDate": "2014-07-21T19:50:14.033"}, "24853959": {"CommentCount": "7", "AcceptedAnswerId": "24854152", "OwnerDisplayName": "user2953119", "CreationDate": "2014-07-20T19:12:42.057", "LastActivityDate": "2014-07-21T19:50:14.033", "PostTypeId": "1", "ViewCount": "712", "FavoriteCount": "4", "Title": "Segmentation fault instead of constructor call", "Id": "24853959", "Score": "8", "Body": "<p>I'm trying to a bit modified of built-in allocation function:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;new&gt;\n\nstruct A\n{\n    int a;\n    A(){ std::cout &lt;&lt; \"Constructor\\n\"; a = 3; }\n    void* operator new(std::size_t t) noexcept\n    {\n        ::operator new(t);\n        return NULL;\n    }\n};\n\nint main()\n{\n    new A();\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2f3ed02749b8aaa7\">demo</a></p>\n<p>Instead of constructor call I've got <code>segmentation fault</code>. Could you explain that behavior?</p>\n", "Tags": "<c++><constructor>", "AnswerCount": "3"}, "24857719": {"ParentId": "24853959", "CommentCount": "1", "Body": "<p>The original code simply returns <code>NULL</code> from <code>A::operator new</code>, quietly forgetting the return result of <code>::operator new</code> (a memory leak). The reason for the crash is that the pointer returned is then used as the <code>this</code> pointer for the new <code>A</code> object. Since that pointer is <code>NULL</code>, anything the constructor does with the object (assigning <code>a = 3</code>) is dereferencing <code>NULL</code>. That results in a segmentation violation. zyboxinternational's answer above gives a good solution, and the comments of both previous posters are very relevant.</p>\n", "OwnerUserId": "3270517", "PostTypeId": "2", "Id": "24857719", "Score": "0", "CreationDate": "2014-07-21T04:21:04.120", "LastActivityDate": "2014-07-21T04:21:04.120"}, "bq_ids": {"n4140": {"so_24853959_24854152_1": {"section_id": 6096, "quality": 1.0, "length": 12}, "so_24853959_24854152_0": {"section_id": 7178, "quality": 0.8333333333333334, "length": 50}}, "n3337": {"so_24853959_24854152_1": {"section_id": 5862, "quality": 1.0, "length": 12}, "so_24853959_24854152_0": {"section_id": 6922, "quality": 0.8333333333333334, "length": 50}}, "n4659": {"so_24853959_24854152_1": {"section_id": 7593, "quality": 1.0, "length": 12}, "so_24853959_24854152_0": {"section_id": 8686, "quality": 0.8, "length": 48}}}, "24854043": {"ParentId": "24853959", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Your function operator <code>new</code> contains a <code>null</code> pointer, and as such doesn't actually return anything.</p>\n<p>The <code>null</code> function operator is equal to <code>return false;</code>, or just <code>return;</code>, but be warned: duplicating a pointer using the <code>new</code> operator causes memory leaks if you aren't careful. To get around this, just <code>delete(t)</code> when you're done.</p>\n<p>The following code will fix your issue:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;new&gt;\n\nstruct A\n{\n    int a;\n    A(){ std::cout &lt;&lt; \"Constructor\\n\"; a = 3; }\n    void* operator new(std::size_t t) noexcept\n    {\n        return ::operator new(t, std::nothrow);\n    }\n};\n\nint main()\n{\n    new A();\n}\n</code></pre>\n", "OwnerUserId": "2422013", "LastEditorUserId": "2422013", "LastEditDate": "2014-07-20T19:27:40.947", "Id": "24854043", "Score": "1", "CreationDate": "2014-07-20T19:22:07.630", "LastActivityDate": "2014-07-20T19:27:40.947"}});