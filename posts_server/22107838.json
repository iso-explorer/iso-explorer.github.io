post_cb({"22108026": {"ParentId": "22107838", "CommentCount": "3", "CreationDate": "2014-02-28T23:52:27.397", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "22108026", "Score": "0", "Body": "<p><strong>Short answer</strong>: It's well-defined if <code>int</code> is large enough to hold the value. If <code>int</code> isn't large enough to hold the value, then the compiler has to at least issue a warning.</p>\n<p><strong>Details</strong>:</p>\n<p>Section 5.4 discusses C-style cast notation.</p>\n<p>\u00a75.4/4</p>\n<blockquote>\n<p id=\"so_22107838_22108026_0\">The conversions performed by</p>\n<p id=\"so_22107838_22108026_1\">\u2014 a <code>const_cast</code> (5.2.11),</p>\n<p id=\"so_22107838_22108026_2\">\u2014 a <code>static_cast</code> (5.2.9),</p>\n<p id=\"so_22107838_22108026_3\">\u2014 a <code>static_cast</code> followed by a const_cast,</p>\n<p id=\"so_22107838_22108026_4\">\u2014 a <code>reinterpret_cast</code> (5.2.10), or</p>\n<p id=\"so_22107838_22108026_5\">\u2014 a <code>reinterpret_cast</code> followed by a const_cast`,</p>\n<p id=\"so_22107838_22108026_6\">can be performed using the cast notation of explicit type conversion... If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears first in the list is used</p>\n</blockquote>\n<p>The conversion of a function pointer to an integral type requires <code>reinterpret_cast</code> because it cannot be performed by any other cast.</p>\n<p>Section 5.2.10 of the standard discusses <code>reinterpret_cast</code>.</p>\n<p>\u00a75.2.10/4</p>\n<blockquote>\n<p id=\"so_22107838_22108026_7\">A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is\n  implementation-defined. </p>\n</blockquote>\n<p>\u00a75.2.10/5</p>\n<blockquote>\n<p id=\"so_22107838_22108026_8\">A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted\n  to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type\n   will have its original value; mappings between pointers and integers are otherwise implementation-defined. [ <em>Note:</em> Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer\n  value. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>You can go read \u00a73.7.4.3 if you want, but it doesn't apply to function pointers. AFAIK, its main purpose is to allow implementation of garbage collection, which applies only to objects and not functions.</p>\n<p>If <code>int</code> is too small to hold the value, then there is nothing in the standard that allows the conversion. The compiler may still allow the conversion, but it must issue a diagnostic.</p>\n", "LastActivityDate": "2014-02-28T23:52:27.397"}, "22108873": {"ParentId": "22107838", "CommentCount": "1", "CreationDate": "2014-03-01T01:23:10.350", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "22108873", "Score": "3", "Body": "<p>The answer depends on the language (C vs C++), on the version of the language (C++98/03 vs C++11), on other standards (e.g., POSIX), and on the compiler.</p>\n<p>In C99 and earlier, converting a function pointer to/from a <code>void*</code> pointer is undefined behavior. UB can be a huge negative, but in this case it means that an implementation is free to provide the ability to convert between function pointers and pointers with no diagnostic whatsoever.</p>\n<p>In POSIX, converting a function pointer to/from a <code>void*</code> pointer is required behavior. This works nicely with C because no diagnostic is required for undefined behavior.</p>\n<p>In C++98/03, converting a function pointer to/from a <code>void*</code> pointer is illegal behavior. A compliant implementation could generate the code that does what the author wants, but it also has to issue a diagnostic of some sort.</p>\n<p>In C++11, converting a function pointer to/from a <code>void*</code> pointer is conditionally-supported behavior. An implementation that supports these conversions can do so without any diagnostic. An implementation that doesn't (for example, a compiler for a Harvard architecture machine) can reject it out of hand.</p>\n<p><br>\nConverting to/from an int? That's dubious. You should use a type that can handle a <code>void*</code> pointer rather than <code>int</code>.</br></p>\n", "LastActivityDate": "2014-03-01T01:23:10.350"}, "bq_ids": {"n4140": {"so_22107838_22108026_8": {"section_id": 6044, "quality": 0.8888888888888888, "length": 40}, "so_22107838_22108026_6": {"section_id": 6126, "quality": 1.0, "length": 21}, "so_22107838_22108026_7": {"section_id": 6043, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_22107838_22108026_8": {"section_id": 5812, "quality": 0.8888888888888888, "length": 40}, "so_22107838_22108026_6": {"section_id": 5890, "quality": 1.0, "length": 21}, "so_22107838_22108026_7": {"section_id": 5811, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_22107838_22108026_8": {"section_id": 7543, "quality": 0.8888888888888888, "length": 40}, "so_22107838_22108026_6": {"section_id": 7623, "quality": 1.0, "length": 21}, "so_22107838_22108026_7": {"section_id": 7542, "quality": 0.8461538461538461, "length": 11}}}, "22107838": {"CommentCount": "5", "ViewCount": "172", "PostTypeId": "1", "ClosedDate": "2014-03-10T13:36:24.947", "LastEditorUserId": "219159", "CreationDate": "2014-02-28T23:35:36.127", "LastActivityDate": "2015-06-29T18:54:17.257", "Title": "Casting a Thumb function pointer to int and back", "AcceptedAnswerId": "22108026", "LastEditDate": "2015-06-29T18:54:17.257", "Id": "22107838", "Score": "3", "Body": "<p>Is casting a function pointer to int then casting it back and making an indirect call an undefined behavior in C++? Like this:</p>\n<pre><code>void f()\n{\n    puts(\"Hello\\n\");\n}\n\n\nint pf = (int)f;\n//...some time later\ntypedef void (*PVoidFunc)();\n(*(PVoidFunc)pf)();\n</code></pre>\n<p>Assume that int and pointer are the same size.</p>\n<p>EDIT: The architecture is 32-bit - it's vanilla Android.</p>\n<p>It's important, though, that we're talking <strong>function</strong> pointers, not data pointers. The underlying issue has to do with the way Thumb functions have two addresses - their true starting address (2-aligned) and the value you need to BLX to (address OR 1). I think GCC is trying to be smart about that, but it comes out rather bogus.</p>\n<p>Naturally, the issue is that this doesn't work for me in one particular case, but works in a very similar one :) But I'm wondering if this is a compiler bug, compiler's attempt to work around the thorny underlying problem, or undefined behavior being undefined.</p>\n", "Tags": "<c++>", "OwnerUserId": "219159", "AnswerCount": "2"}});