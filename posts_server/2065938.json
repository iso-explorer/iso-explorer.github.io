post_cb({"2066209": {"ParentId": "2065938", "CommentCount": "2", "Body": "<p>The purpose of declaring destructor as virtual is to be able to invoke the derived class's destructor whenever you call delete on a pointer of type Base which is pointing to object of type Derived. Not doing so would result in undefined behavior.</p>\n<p>The assumption that you need not mark destructor as virtual if you are not allocating memory dynamically implies that you do not need to call derived class destructor if you are not allocating memory dynamically, which is wrong. As you may still do several other operations in your derived class's destructor other than just deallocating the dynamically allocated memory. Examples would be closing an open file, logging some information etc.</p>\n", "OwnerUserId": "240857", "PostTypeId": "2", "Id": "2066209", "Score": "0", "CreationDate": "2010-01-14T17:43:05.227", "LastActivityDate": "2010-01-14T17:43:05.227"}, "2065957": {"ParentId": "2065938", "CommentCount": "8", "Body": "<p>Freeing memory is not the only critical function a destructor can perform.  It can also be used to reset global state for instance.  Not doing this won't leak memory but could potentially cause other issues in your program. </p>\n<p>Additionally, even if your destructor doesn't do anything useful today, it may at some point in the future.  There's no real reason to avoid a virtual destructor if you have inheritance so why not just add it and sleep better at night?</p>\n", "OwnerUserId": "23283", "PostTypeId": "2", "Id": "2065957", "Score": "4", "CreationDate": "2010-01-14T17:05:39.607", "LastActivityDate": "2010-01-14T17:05:39.607"}, "2065976": {"ParentId": "2065938", "CommentCount": "2", "Body": "<p>The destructor of the parent class is always automatically called, and the default dtor is always generated if there's no explicit dtor declared. In your example, neither A nor B needs to have a non-trivial dtor. </p>\n<p>If you class has virtual functions, an additional virtual dtor doesn't hurt, and is good practice. In case you class allocates memory or any other resource (like opening a file), a dtor is needed to free that resource again upon destruction. </p>\n", "OwnerUserId": "241871", "PostTypeId": "2", "Id": "2065976", "Score": "0", "CreationDate": "2010-01-14T17:07:42.943", "LastActivityDate": "2010-01-14T17:07:42.943"}, "2066001": {"ParentId": "2065938", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The purpose of <em>virtual</em> destructor (i.e. the purpose of making a destructor <em>virtual</em>) is to facilitate the polymorphic deletion of objects through <em>delete-expression</em>. If your design does not call for polymorphic deletion of objects, you don't need virtual destructors. Referring to your example, if you'll ever have to delete an object of type <code>B</code> through a pointer of type <code>A *</code> (polymorphic deletion), you'll need virtual destructor as high up in the hierarchy as <code>A</code>. That's how it looks from a formal point of view.</p>\n<p>(Note, BTW, as Neil said, that what's important is how you create/delete your class objects, not how classes manage their internal memory.)</p>\n<p>As for the good programming practices... It depends on your intent and your design in the end. If your classes are not designed to be polymorphic at all (no virtual methods whatsoever), then you don't need virtual destructors. If your class is polymorphic (have at least one virtual method), then making the destructor virtual \"just in case\" might be a very good idea, and in this case it bears virtually zero performance/memory penalty with it.</p>\n<p>The latter is usually expressed as a rather well-known good practice guideline: if your class has at least one virtual method, make the destructor virtual as well. Although from the formal point of view a virtual destructor might not be really needed there, it is still a pretty good guideline to follow.</p>\n<p>Classes that have no resources but can form polymorphic hierarchies should always define empty virtual destructors, except that it is perfectly sufficient to define an explicit empty (and even pure) virtual destructor at the very base of the hierarchy. All other destructors will become virtual automatically, even if they are defined implictly by the compiler. I.e. you don't have to explicitly define an empty destructor in every class. Just the base is enough.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "15161", "LastEditDate": "2015-02-13T07:54:52.923", "Id": "2066001", "Score": "19", "CreationDate": "2010-01-14T17:10:40.690", "LastActivityDate": "2015-02-13T07:54:52.923"}, "12292952": {"ParentId": "2065938", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>If your only concern is memory, maybe you should start by protecting base class destructor (and/or maybe others). Then if something does not compile, you'll see why. Ref: boost::any ways.</p>\n", "OwnerUserId": "1650782", "LastEditorUserId": "1490355", "LastEditDate": "2012-09-14T06:10:29.303", "Id": "12292952", "Score": "-1", "CreationDate": "2012-09-06T04:23:01.017", "LastActivityDate": "2012-09-14T06:10:29.303"}, "2065961": {"ParentId": "2065938", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The issue is not whether your classes allocate memory dynamically. It is if a user of the classes allocates a B object via an A pointer and then deletes it:</p>\n<pre><code>A * a = new B;\ndelete a;\n</code></pre>\n<p>In this case, if there is no virtual destructor for A, the C++ Standard says that your program exhibits undefined behaviour. This is not a good thing.</p>\n<p>This behaviour is specified in section 5.3.5/3 of the Standard (here referring to <code>delete</code>):</p>\n<blockquote>\n<p id=\"so_2065938_2065961_0\">if the static type of the operand is\n  different from its dynamic type, the\n  static type shall be a base class of\n  the operand\u2019s dynamic type and the\n  static type shall have a virtual\n  destructor or the behavior is\n  undefined.</p>\n</blockquote>\n", "Id": "2065961", "LastEditDate": "2010-01-14T19:27:58.497", "OwnerDisplayName": "anon", "Score": "32", "CreationDate": "2010-01-14T17:06:12.650", "LastActivityDate": "2010-01-14T19:27:58.497", "LastEditorDisplayName": "anon"}, "2065938": {"CommentCount": "1", "AcceptedAnswerId": "2065961", "PostTypeId": "1", "LastEditorUserId": "569101", "LastEditorDisplayName": "user166390", "CreationDate": "2010-01-14T17:02:56.023", "LastActivityDate": "2015-02-13T07:54:52.923", "LastEditDate": "2013-07-01T14:11:37.663", "ViewCount": "4127", "FavoriteCount": "7", "Title": "Virtual destructor: is it required when not dynamically allocated memory?", "Id": "2065938", "Score": "20", "Body": "<p>Do we need a virtual destructor if my classes do not allocate any memory dynamically ?</p>\n<p>e.g.</p>\n<pre><code>class A\n{\n      private: \n      int a;\n      int b;\n\n      public:\n      A();\n      ~A();\n};\n\nclass B: public A\n{     \n      private:\n      int c;\n      int d;\n\n      public:\n      B();\n      ~B();\n};\n</code></pre>\n<p>In this case do we need to mark A's destructor as virtual ?</p>\n", "Tags": "<c++><virtual-destructor>", "OwnerUserId": "248132", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_2065938_2065961_0": {"section_id": 6107, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_2065938_2065961_0": {"section_id": 5873, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_2065938_2065961_0": {"section_id": 7604, "quality": 0.9047619047619048, "length": 19}}}});