post_cb({"28595084": {"LastEditDate": "2015-02-18T22:37:59.993", "Body": "<p>I implemented a bidirectional iterator, however instead of operating on a data structure, it returns a mathematical series which one can iteratively calculate through in both directions. In fact, I'm iterating through the integers, using ++ and -- on an int. This means that the data is not stored in a different structure, and hence when the iterator goes out of scope, so does the value.</p>\n<p>Nevertheless, I would expect the next code (minimal failing example) sample to work, as the iterator stays in scope the whole time. But it does not work :(</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\n\nclass my_iterator : public std::iterator&lt;std::bidirectional_iterator_tag, int&gt; {\n  int d_val = 12;\npublic:\n  my_iterator  operator--(int) { std::cout &lt;&lt; \"decrement--\\n\"; return my_iterator(); }\n  my_iterator &amp;operator--()    { std::cout &lt;&lt; \"--decrement\\n\"; return *this; }\n  my_iterator  operator++(int) { std::cout &lt;&lt; \"increment++\\n\"; return my_iterator(); }\n  my_iterator &amp;operator++()    { std::cout &lt;&lt; \"++increment\\n\"; return *this; }\n\n  int &amp;operator*() { std::cout &lt;&lt; \"*dereference\\n\"; return d_val; }\n\n  bool operator==(my_iterator const  &amp;o) { return false; }\n  bool operator!=(my_iterator const  &amp;o) { return true ; }\n};\n\n\nint main() {\n  auto it = std::reverse_iterator&lt;my_iterator&gt;();\n  int &amp;i = *it;\n  if (true)\n  {\n    std::cout &lt;&lt; i &lt;&lt; '\\n';\n  }\n  else\n  {\n    std::vector&lt;int&gt; vec;\n    vec.push_back(i);\n    std::cout &lt;&lt; vec[0] &lt;&lt; '\\n';\n  }\n}\n</code></pre>\n<p>source: <a href=\"http://ideone.com/YJKvpl\" rel=\"nofollow\">http://ideone.com/YJKvpl</a></p>\n<p>The if-branch results in memory violations, as properly detected by valgrind:</p>\n<pre><code>--decrement\n*dereference\n==7914== Use of uninitialised value of size 8\n==7914==    at 0x4EC15C3: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4EC16FB: std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; std::num_put&lt;char, std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::_M_insert_int&lt;long&gt;(std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt;, std::ios_base&amp;, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4EC1C7C: std::num_put&lt;char, std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::do_put(std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt;, std::ios_base&amp;, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4ECEFB9: std::ostream&amp; std::ostream::_M_insert&lt;long&gt;(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x40087B: main (divine.cc:25)\n==7914== \n==7914== Conditional jump or move depends on uninitialised value(s)\n==7914==    at 0x4EC15CF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4EC16FB: std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; std::num_put&lt;char, std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::_M_insert_int&lt;long&gt;(std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt;, std::ios_base&amp;, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4EC1C7C: std::num_put&lt;char, std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::do_put(std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt;, std::ios_base&amp;, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4ECEFB9: std::ostream&amp; std::ostream::_M_insert&lt;long&gt;(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x40087B: main (divine.cc:25)\n==7914== \n==7914== Conditional jump or move depends on uninitialised value(s)\n==7914==    at 0x4EC1724: std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; std::num_put&lt;char, std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::_M_insert_int&lt;long&gt;(std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt;, std::ios_base&amp;, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4EC1C7C: std::num_put&lt;char, std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::do_put(std::ostreambuf_iterator&lt;char, std::char_traits&lt;char&gt; &gt;, std::ios_base&amp;, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x4ECEFB9: std::ostream&amp; std::ostream::_M_insert&lt;long&gt;(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.20)\n==7914==    by 0x40087B: main (divine.cc:25)\n==7914== \n12\n==7914== \n==7914== HEAP SUMMARY:\n==7914==     in use at exit: 0 bytes in 0 blocks\n==7914==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated\n==7914== \n==7914== All heap blocks were freed -- no leaks are possible\n==7914== \n==7914== For counts of detected and suppressed errors, rerun with: -v\n==7914== Use --track-origins=yes to see where uninitialised values come from\n==7914== ERROR SUMMARY: 5 errors from 3 contexts (suppressed: 0 from 0)\n</code></pre>\n<p>The else-branch doesn't result in memory violations, or at least as far as my valgrind can detect. However, the value stored in the vector is 'random':</p>\n<pre><code>--decrement\n*dereference\n-16777520\n</code></pre>\n<p>I'm a bit surprised by what happens. The iterator should be in scope all the time, yet the reference seems to get invalidated. Why do I get the memory violations, whilst 12 is printed or why don't I get them whilst something different from 12 is stored?</p>\n", "CreationDate": "2015-02-18T22:21:16.343", "Score": "4", "CommentCount": "14", "OwnerUserId": "853462", "Title": "Reference invalidation after applying reverse_iterator on a custom made iterator", "LastActivityDate": "2015-11-22T05:32:00.340", "PostTypeId": "1", "Tags": "<c++><c++11><c++14><reverse-iterator>", "AnswerCount": "2", "FavoriteCount": "1", "Id": "28595084", "ViewCount": "184", "LastEditorUserId": "853462"}, "28597146": {"PostTypeId": "2", "ParentId": "28595084", "Body": "<p><code>reverse_iterator</code> does not work with so-called \"stashing iterators\", iterators that returns references to things within themselves. The <code>operator*</code> of <code>reverse_iterator</code> makes a copy of the wrapped iterator, decrements it, and returns the result of dereferencing the copy. Hence, if dereferencing iterator returns a reference to something inside itself, the reference will become dangling.</p>\n<p>An attempt was made in the C++11 specification to make it work, but it turns out that it's impossible to implement without adding massive overhead<sup>*</sup> for non-stashing iterators, so <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2360\" rel=\"noreferrer\">the specification was reverted to the C++03 version</a>.</p>\n<hr>\n<p><sub> <sup>*</sup> To support \"stashing iterators\", an additional data member must be added that stores the decremented current iterator, doubling the size of <code>reverse_iterator</code>; and then some form of synchronization must be used since <code>operator *</code> is <code>const</code> - and so must be simultaneously callable from multiple threads without causing a data race - but must modify this additional data member. That's a lot of overhead to add to all <code>reverse_iterator</code>s for such an uncommon use case.</sub></p>\n</hr>", "CreationDate": "2015-02-19T01:20:56.843", "Score": "6", "LastEditDate": "2015-02-19T03:21:44.057", "CommentCount": "4", "Id": "28597146", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastActivityDate": "2015-02-19T03:21:44.057"}, "33851951": {"PostTypeId": "2", "ParentId": "28595084", "Body": "<p>As has been mentioned, the C++03 and C++14 standards define <code>reverse_iterator::operator*</code> in this way:</p>\n<blockquote>\n<p id=\"so_28595084_33851951_0\">24.5.1.3.4 <code>operator*</code> [reverse.iter.op.star]</p>\n<p id=\"so_28595084_33851951_1\"><code>reference operator*() const;</code></p>\n<p id=\"so_28595084_33851951_2\">1 Effects:</p>\n</blockquote>\n<pre><code>Iterator tmp = current;\nreturn *--tmp;\n</code></pre>\n<p><code>tmp</code> is destroyed after <code>operator*</code> returns, so any references to data stored inside of <code>tmp</code> will become invalid. The C++11 standard changed this and added a note:</p>\n<blockquote>\n<p id=\"so_28595084_33851951_3\">24.5.1.3.4 <code>operator*</code> [reverse.iter.op.star]</p>\n<p id=\"so_28595084_33851951_4\"><code>reference operator*() const;</code></p>\n<p id=\"so_28595084_33851951_5\">1 Effects:</p>\n</blockquote>\n<pre><code>deref_tmp = current;\n--deref_tmp;\nreturn *deref_tmp;\n</code></pre>\n<blockquote>\n<p id=\"so_28595084_33851951_6\">2 [ Note: This operation must use an auxiliary member variable rather than\n  a temporary variable to avoid returning a reference that persists beyond\n  the lifetime of its associated iterator. (See 24.2.) \u2014end note ]</p>\n</blockquote>\n<p>This is actually impossible to implement because of the <code>const</code> qualifier on <code>operator*</code>, so the wording was reverted between C++11 and C++14.</p>\n<p>The best solution is probably to just implement your own version of <code>reverse_iterator</code> based on the C++11 wording for whatever version of C++ you are targeting. Fortunately, the specification is very straightforward and easy to follow. As a working example, here's one I wrote for C++14:</p>\n<pre><code>template &lt;class Iterator&gt;\nclass stashing_reverse_iterator :\n  public std::iterator&lt;\n    typename std::iterator_traits&lt;Iterator&gt;::iterator_category,\n    typename std::iterator_traits&lt;Iterator&gt;::value_type,\n    typename std::iterator_traits&lt;Iterator&gt;::difference_type,\n    typename std::iterator_traits&lt;Iterator&gt;::pointer,\n    typename std::iterator_traits&lt;Iterator&gt;::reference\n  &gt; {\n  typedef std::iterator_traits&lt;Iterator&gt; traits_type;\npublic:\n  typedef Iterator iterator_type;\n  typedef typename traits_type::difference_type difference_type;\n  typedef typename traits_type::reference       reference;\n  typedef typename traits_type::pointer         pointer;\n\n  stashing_reverse_iterator() : current() {}\n\n  explicit stashing_reverse_iterator(Iterator x) : current(x) {}\n\n  template &lt;class U&gt;\n  stashing_reverse_iterator(const stashing_reverse_iterator&lt;U&gt;&amp; u) : current(u.current) {}\n\n  template &lt;class U&gt;\n  stashing_reverse_iterator&amp; operator=(const stashing_reverse_iterator&lt;U&gt;&amp; u) {\n    current = u.base();\n    return *this;\n  }\n\n  Iterator base() const {\n    return current;\n  }\n\n  // Differs from reverse_iterator::operator*:\n  // 1. const qualifier removed\n  // 2. current iterator is stored in a member field to ensure references are\n  //    always valid after this function returns\n  reference operator*() {\n    deref_tmp = current;\n    --deref_tmp;\n    return *deref_tmp;\n  }\n\n  pointer operator-&gt;() const {\n    return std::addressof(operator*());\n  }\n\n  stashing_reverse_iterator&amp; operator++() {\n    --current;\n    return *this;\n  }\n\n stashing_reverse_iterator operator++(int) {\n    stashing_reverse_iterator tmp = *this;\n    --current;\n    return tmp;\n  }\n\n  stashing_reverse_iterator&amp; operator--() {\n    ++current;\n    return *this;\n  }\n\n  stashing_reverse_iterator operator--(int) {\n    stashing_reverse_iterator tmp = *this;\n    ++current;\n    return tmp;\n  }\n\n  stashing_reverse_iterator  operator+ (difference_type n) const {\n    return stashing_reverse_iterator(current - n);\n  }\n\n  stashing_reverse_iterator&amp; operator+=(difference_type n) {\n    current -= n;\n    return *this;\n  }\n\n  stashing_reverse_iterator  operator- (difference_type n) const {\n    return stashing_reverse_iterator(current + n);\n  }\n\n  stashing_reverse_iterator&amp; operator-=(difference_type n) {\n    current += n;\n    return *this;\n  }\n\n  // Differs from reverse_iterator::operator[]:\n  // 1. const qualifier removed because this function makes use of operator*\n  reference operator[](difference_type n) {\n    return *(*this + n);\n  }\n\nprotected:\n  Iterator current;\nprivate:\n  Iterator deref_tmp;\n};\n\ntemplate &lt;class Iterator1, class Iterator2&gt;\nbool operator==(\n  const stashing_reverse_iterator&lt;Iterator1&gt;&amp; x,\n  const stashing_reverse_iterator&lt;Iterator2&gt;&amp; y)\n{ return x.base() == y.base(); }\n\ntemplate &lt;class Iterator1, class Iterator2&gt;\nbool operator&lt;(\n  const stashing_reverse_iterator&lt;Iterator1&gt;&amp; x,\n  const stashing_reverse_iterator&lt;Iterator2&gt;&amp; y)\n{ return x.base() &gt; y.base(); }\n\ntemplate &lt;class Iterator1, class Iterator2&gt;\nbool operator!=(\n  const stashing_reverse_iterator&lt;Iterator1&gt;&amp; x,\n  const stashing_reverse_iterator&lt;Iterator2&gt;&amp; y)\n{ return !(x.base() == y.base()); }\n\ntemplate &lt;class Iterator1, class Iterator2&gt;\nbool operator&gt;(\n  const stashing_reverse_iterator&lt;Iterator1&gt;&amp; x,\n  const stashing_reverse_iterator&lt;Iterator2&gt;&amp; y)\n{ return x.base() &lt; y.base(); }\n\ntemplate &lt;class Iterator1, class Iterator2&gt;\nbool operator&gt;=(\n  const stashing_reverse_iterator&lt;Iterator1&gt;&amp; x,\n  const stashing_reverse_iterator&lt;Iterator2&gt;&amp; y)\n{ return x.base() &lt;= y.base(); }\n\ntemplate &lt;class Iterator1, class Iterator2&gt;\nbool operator&lt;=(\n  const stashing_reverse_iterator&lt;Iterator1&gt;&amp; x,\n  const stashing_reverse_iterator&lt;Iterator2&gt;&amp; y)\n{ return x.base() &gt;= y.base(); }\n\ntemplate &lt;class Iterator1, class Iterator2&gt;\nauto operator-(\n  const stashing_reverse_iterator&lt;Iterator1&gt;&amp; x,\n  const stashing_reverse_iterator&lt;Iterator2&gt;&amp; y) -&gt; decltype(y.base() - x.base())\n{ return y.base() - x.base(); }\n\ntemplate &lt;class Iterator&gt;\nstashing_reverse_iterator&lt;Iterator&gt; operator+(\n  typename stashing_reverse_iterator&lt;Iterator&gt;::difference_type n,\n  const stashing_reverse_iterator&lt;Iterator&gt;&amp; x)\n{ return stashing_reverse_iterator&lt;Iterator&gt;(x.base() - n); }\n\ntemplate &lt;class Iterator&gt;\nstashing_reverse_iterator&lt;Iterator&gt; make_stashing_reverse_iterator(Iterator i)\n{ return stashing_reverse_iterator&lt;Iterator&gt;(i); }\n</code></pre>\n<p>Usage is the same as <code>reverse_iterator</code>:</p>\n<pre><code>// prints 5,4,3,2,1, for a sanely implemented number_iterator\nstd::copy(\n  make_stashing_reverse_iterator(number_iterator(5)),\n  make_stashing_reverse_iterator(number_iterator(0)),\n  std::ostream_iterator&lt;int&gt;(std::cout, \",\"));\n</code></pre>\n", "CreationDate": "2015-11-22T05:32:00.340", "Score": "1", "CommentCount": "1", "Id": "33851951", "OwnerUserId": "5588399", "LastActivityDate": "2015-11-22T05:32:00.340"}, "bq_ids": {"n3337": {"so_28595084_33851951_6": {"quality": 0.8, "length": 20, "section_id": 5393}}}});