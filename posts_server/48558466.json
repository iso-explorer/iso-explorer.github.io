post_cb({"bq_ids": {"n4140": {"so_48558466_48558645_0": {"length": 77, "quality": 0.9506172839506173, "section_id": 3241}}, "n3337": {"so_48558466_48558645_0": {"length": 77, "quality": 0.9506172839506173, "section_id": 3114}}, "n4659": {"so_48558466_48558645_0": {"length": 77, "quality": 0.9506172839506173, "section_id": 3997}}}, "48558645": {"Id": "48558645", "PostTypeId": "2", "Body": "<p>From <em>11.3.5 Functions [dcl.fct]</em>:</p>\n<blockquote id=\"so_48558466_48558645_0\">\n<ol start=\"5\">\n<li>A single name can be used for several different functions in a single\n  scope; this is function overloading (Clause 16). All declarations for\n  a function shall agree exactly in both the return type and the\n  parameter-typelist. The type of a function is determined using the\n  following rules. The type of each parameter (including function\n  parameter packs) is determined from its own decl-specifier-seq and\n  declarator. After determining the type of each parameter, any\n  parameter of type \u201carray of T\u201d or of function type T is adjusted to be\n  \u201cpointer to T\u201d. <em>After producing the list of parameter types, any\n  <strong>top-level cv-qualifiers</strong> modifying a parameter type are deleted when\n  forming the function type</em>. The resulting list of transformed parameter\n  types and the presence or absence of the ellipsis or a function\n  parameter pack is the function\u2019s parameter-type-list.</li>\n</ol>\n</blockquote>\n<p>Basically, it means, that <code>const int</code> and <code>int</code> are interchangeable in the context of your question.</p>\n<p>On the other hand, if you add a reference, like <code>const int&amp;</code>, <code>const</code> is not a top level cv-qualifier anymore (it marks the referenced value as <code>const</code>), so the compiler complains.</p>\n<p>Usually, <code>const</code> is added to the definition in order to emphasise that the parameter is not changed inside the function body.</p>\n", "LastActivityDate": "2018-02-01T08:51:08.773", "Score": "5", "CreationDate": "2018-02-01T08:51:08.773", "ParentId": "48558466", "CommentCount": "2", "OwnerUserId": "5507349"}, "48558466": {"ViewCount": "234", "Body": "<p>Code </p>\n<pre><code>class A\n{\n public:\n    void f(const int i);\n};\nvoid A::f(int i)\n{\n    std::cout&lt;&lt;++i&lt;&lt;std::endl;\n}\nint main()\n{\n   A a;\n   a.f(1);\n}\n</code></pre>\n<p>Why compiler does not give an error in this case ? Why the definition overrides the constant argument ?\nAlso, when the argument is of type <code>reference (&amp;)</code> the compiler throws error but why not in this case ?</p>\n<p>Is there any compiler flag to enable warning on these mentioned cases ?</p>\n<p>I am interested more from compiler error POV. Because one can easily put declaration (const) and definition(non-constant) differently and still compiler accepts it. If a mistake can be made it will eventually be made. Why can't compiler complain when there is such difference present.</p>\n", "Title": "Function args declared as consts became non constant with definition", "CreationDate": "2018-02-01T08:39:55.143", "Id": "48558466", "CommentCount": "2", "LastEditDate": "2018-02-01T14:58:53.413", "PostTypeId": "1", "LastEditorUserId": "1382284", "LastActivityDate": "2018-02-01T14:58:53.413", "Tags": "<c++><c++11><c++14><constants>", "Score": "5", "OwnerUserId": "1382284", "ClosedDate": "2018-02-01T08:56:41.143", "AnswerCount": "2"}, "48558517": {"Id": "48558517", "PostTypeId": "2", "Body": "<p>The function declaration</p>\n<pre><code>void f(const T arg);\n</code></pre>\n<p>is same as </p>\n<pre><code>void f(T arg);\n</code></pre>\n<p>However, </p>\n<pre><code>void f(const T&amp; arg);\n</code></pre>\n<p>is not the same as </p>\n<pre><code>void f(T&amp; arg);\n</code></pre>\n<p>and</p>\n<pre><code>void f(const T* arg);\n</code></pre>\n<p>is not the same as </p>\n<pre><code>void f(T* arg);\n</code></pre>\n<hr>\n<pre><code>void f(const T arg);\nvoid f(T arg);\n</code></pre>\n<p>are same because top-level cv-qualifiers are removed for function resolution purposes. There, the <code>const</code>-ness is applied to the top-level type, <code>T</code>.</p>\n<p>OTOH,</p>\n<pre><code>void f(const T&amp; arg);\nvoid f(T&amp; arg);\n</code></pre>\n<p>are not same since the <code>const</code>-ness is applied to the object being referred to by the reference <code>arg</code>, not to <code>arg</code> itself which is just a <em>top-level</em> thing.</p>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2018-02-01T09:07:03.013", "Score": "3", "CreationDate": "2018-02-01T08:43:17.877", "ParentId": "48558466", "CommentCount": "8", "OwnerUserId": "434551", "LastEditDate": "2018-02-01T09:07:03.013"}});