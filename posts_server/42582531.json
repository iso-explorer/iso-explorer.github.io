post_cb({"bq_ids": {"n4140": {"so_42582531_42600027_1": {"length": 19, "quality": 1.0, "section_id": 5972}, "so_42582531_42600027_2": {"length": 30, "quality": 0.9375, "section_id": 7040}, "so_42582531_42582531_0": {"length": 26, "quality": 1.0, "section_id": 5971}}, "n3337": {"so_42582531_42600027_1": {"length": 13, "quality": 0.6842105263157895, "section_id": 5740}}, "n4659": {"so_42582531_42600027_1": {"length": 19, "quality": 1.0, "section_id": 7471}, "so_42582531_42600027_2": {"length": 30, "quality": 0.9375, "section_id": 8537}, "so_42582531_42582531_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 7470}}}, "42600027": {"Id": "42600027", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42582531_42600027_0\">Is this code Standard-compliant? </p>\n</blockquote>\n<p>Yes. The rule is:</p>\n<blockquote>\n<p id=\"so_42582531_42600027_1\">If a <em>lambda-expression</em> or an instantiation of the function call operator template of a generic lambda odr-uses (3.2) <code>this</code> or a variable with\n  automatic storage duration from its reaching scope, that entity shall be captured by the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>Does the lambda odr-use <code>x</code>? No, because of [basic.def.odr]:</p>\n<blockquote>\n<p id=\"so_42582531_42600027_2\">A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is <em>odr-used</em> by <code>ex</code> unless applying the lvalue-to-rvalue conversion (4.1) to <code>x</code> yields a constant expression (5.20) that does not invoke any non-trivial\n  functions and, if <code>x</code> is an object, <code>ex</code> is an element of the set of potential results of an expression <code>e</code>, where either the lvalue-to-rvalue conversion (4.1) is applied to <code>e</code>, or <code>e</code> is a discarded-value expression (Clause 5).</p>\n</blockquote>\n<p><code>x</code> is an integral constant that is used in an expression where the lvalue-to-rvalue conversion is applied, so it is not odr-used. Since it's not odr-used, it's not an error that you aren't capturing it.</p>\n<p>It would be ill-formed if there was an overload of <code>f</code> that took its first argument by reference - that instantiation of the call operator <em>would</em> odr-use <code>x</code>, but it's not captured, making it ill-formed.</p>\n<hr/>\n<p>The section you cite is irrelevant for your modified example. It only refers to \"A <em>lambda-expression</em> <strong>with an associated <em>capture-default</em></strong>\". But your lambda doesn't have a <em>capture-default</em>. A <em>capture-default</em> is either <code>=</code> or <code>&amp;</code>, the introducer <code>[]</code> has no capture-default. However, if we had <code>[=]</code> or <code>[&amp;]</code>, that section would explain why <code>x</code> would be captured. </p>\n", "LastActivityDate": "2017-03-04T18:57:35.573", "CommentCount": "7", "CreationDate": "2017-03-04T18:57:35.573", "ParentId": "42582531", "Score": "2", "OwnerUserId": "2069064"}, "42582531": {"ViewCount": "175", "Body": "<pre><code>   void f(      int , const int (&amp;)[2] = {}) { } // #1 \n   void f(      int , const int (&amp;)[1]     ) { } // #2 \n// void f(const int&amp;, const int (&amp;)[1]     ) { } // #2_original \n\nvoid test() { \n\n    const int x = 17; \n\n    auto g = [](auto a) { \n        f(x); // OK: calls #1, does not capture x \n    }; \n\n    auto g2 = [ /* = */ ](auto a) { \n        int selector[ sizeof(a) == 1 ? 1 : 2 ]{}; \n        f(x, selector); // OK: is a dependent expression, so captures x ??? \n    }; \n} \n</code></pre>\n<p>This is an example from the C++14 Standard (ISO/IEC 14882:2014), Section 5.1.2, Paragraph 12, which I modified in 2 ways: </p>\n<ul>\n<li>First, both versions of function <code>f()</code> have an <code>int</code> as the first argument, so variable <code>x</code> is <strong>not</strong> <em>odr-used</em> in any case. </li>\n<li>Second, I removed (commented out) the <em>capture-default</em> in lambda <code>g2</code>. </li>\n</ul>\n<p>Is this code Standard-compliant? Both clang and gcc compile successfully. However, in the original example lambda <code>g2</code> had a <em>capture-default</em> (<code>[=]</code>), so variable <code>x</code> was implicitly captured because there was a dependent expression (and also because it could be <em>odr-used</em> in function <code>f()  #2_original</code>). Note that in the aforementioned paragraph of the Standard there are 2 conditions to implicitly capture variable <code>x</code> (<em>odr-use</em> OR dependent expression). Now, without <em>capture-default</em> nor <em>odr-use</em>: </p>\n<ul>\n<li><p>Shouldn't this be a compile-time error since there is a dependent expression and no <em>capture-default</em>? That is, variable <code>x</code> needs to be captured but it cannot be (assume <code>g2</code> calls with both kinds of arguments, i.e., ones yielding <code>sizeof(a)=1</code> and others <code>sizeof(a)&gt;1</code>).</p></li>\n<li><p>Or does the condition of the dependent expression to implicitly capture a variable only apply when there is a <em>capture-default</em>? That would mean that, with no <em>odr-use</em> (i.e., without <code>const int&amp;</code> in function <code>f() #2</code>) the program will work in the same way regardless of the <em>capture-default</em>. Therefore, wouldn't the second condition about the dependent expression be useless? </p></li>\n</ul>\n<p>This is the C++14 Standard (ISO/IEC 14882:2014), Section 5.1.2, Paragraph 12 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_42582531_42582531_0\">A <em>lambda-expression</em> <strong>with an associated <em>capture-default</em></strong> that does not explicitly capture <em>this</em> or a variable with automatic storage duration (this excludes any <em>id-expression</em> that has been found to refer to an <em>init-capture</em>\u2019s associated non-static data member), is said to <em>implicitly capture</em> the entity (i.e., <em>this</em> or a variable) if the <em>compound-statement</em>:</p>\n<ul>\n<li>odr-uses (3.2) the entity, <strong>or</strong> </li>\n<li><strong>names the entity in a potentially-evaluated expression (3.2) where the enclosing full-expression depends on a generic lambda parameter declared within the reaching scope of the <em>lambda-expression</em>.</strong></li>\n</ul>\n</blockquote>\n<p>Note: lambda <code>g</code> does not capture variable <code>x</code> because it is not <em>odr-used</em> in <code>f(x)</code> (see C++14 Standard (ISO/IEC 14882:2014), Section 5.1.2, Paragraph 13)</p>\n<p>Links: </p>\n<ul>\n<li><p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3649.html\" rel=\"nofollow noreferrer\">N3649: Generic (Polymorphic) Lambda Expressions (Revision 3)</a></p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/38750777/using-of-not-captured-variable-in-lambda\">Using of not captured variable in lambda</a></p></li>\n</ul>\n", "AcceptedAnswerId": "42600027", "Title": "Dependent Expression and ODR-use in a Generic Lambda in C++14", "CreationDate": "2017-03-03T15:17:54.410", "Id": "42582531", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:02:02.583", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-06T13:05:30.173", "Score": "6", "OwnerUserId": "7325235", "Tags": "<c++><lambda><c++14><auto><one-definition-rule>", "AnswerCount": "1"}});