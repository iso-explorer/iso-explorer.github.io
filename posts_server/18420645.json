post_cb({"18421088": {"ParentId": "18420645", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>There already popped up two good answers while i was writing this, but i submit my anyway because it is written in another style. Maybe this more shallow answer is useful to someone. </p>\n<p>First of all, it is a bit unclear with the <code>copy</code> method being part of an object, taking an object as input, and returning an object. Does it copy from or to the input? Does it return a copy or itself? Is it supposed to be <code>static</code>? </p>\n<p>All of your declarations \"work\" (depending on what you wish to achieve), but not all of them together. </p>\n<p>Edit: I removed the part disputed in the comments, the other answers covers that anyway. But i kept the part giving an example to explain why polymorphism on return type isn't allowed. </p>\n<p>To only use implementations in <code>Derived</code>, you can declare</p>\n<pre><code>class Derived:public Base{\npublic:\n    virtual Derived* copy(Base* b){...}; \n    virtual Derived* copy(Derived* b){}; \n};\n</code></pre>\n<p>or </p>\n<pre><code>class Derived:public Base{\npublic:\n    virtual Base* copy(Base* b){...}; \n    virtual Derived* copy(Derived* b){}; \n};\n</code></pre>\n<p>Polymorphism based on return type is not supported in C++, however. You <strong>cannot</strong> use </p>\n<pre><code>class Derived:public Base{\npublic:\n    virtual Base* copy(Derived* b){...}; \n    virtual Derived* copy(Derived* b){}; \n};\n</code></pre>\n<p>because the compiler will have trouble determining what to do if you do not use the result. Consider: </p>\n<pre><code>Derived * d = new Derived(); \n\nDerived * toCopy = new Derived(); \n\nBase * b2 = toCopy-&gt;copy(d); // Should use use the version returning Base\n\nDerived * d2 = toCopy-&gt;copy(d); // Should use the version returning Derived\n\ntoCopy-&gt;copy(d2); // Which implementation should the compiler pick? It cannot know!\n</code></pre>\n<p>Because the compiler cannot decide on the version to use in the last line above, it is illegal to overload on return type. </p>\n<p>As for the access right, i gladly recommend the other answers. </p>\n", "OwnerUserId": "2380849", "LastEditorUserId": "2380849", "LastEditDate": "2013-08-24T18:20:53.367", "Id": "18421088", "Score": "0", "CreationDate": "2013-08-24T17:12:18.763", "LastActivityDate": "2013-08-24T18:20:53.367"}, "18420809": {"ParentId": "18420645", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>They're all legal declarations, it's just that these two </p>\n<pre><code>virtual Base* copy(Derived* b);\nvirtual Derived* copy(Derived* b);\n</code></pre>\n<p>do not override the <code>copy</code> from the base class, as their signature is different. They just declare new virtual <code>copy</code> that hides the one from base.<br>\nThis one, however</br></p>\n<pre><code>virtual Derived* copy(Base* b);\n</code></pre>\n<p>does override. It's got the same signature and a <a href=\"http://en.wikipedia.org/wiki/Covariant_return_type\" rel=\"nofollow\"><em>covariant return type</em></a>.</p>\n<p>In C++11 you can use <code>override</code> to force the compiler to emit an error if the function does not override anything:</p>\n<pre><code>virtual Derived* copy(Derived*) override { /*...  */} // will produce an error\n</code></pre>\n<p>Access right doesn't make any direct difference - it is checked based on the static type of the object. If the <code>copy</code> in base is public and you call it through a pointer to base class, it'll call the suitable overriding function even if it were private.</p>\n<pre><code>class Base {\npublic:\n    virtual Base* copy(Base* b);\n};\n\nclass Derived : public Base {\nprivate:\n    virtual Base* copy(Base* b);       // Overrides Base::copy\n};\n\nint main()\n{\n    Base* b = new Derived;\n    Base* b2;\n    b-&gt;copy(b2); // calls Derived::copy\n    Derived d;\n    d.copy(b2); // error, as expected\n}\n</code></pre>\n", "OwnerUserId": "947836", "LastEditorUserId": "947836", "LastEditDate": "2013-08-24T16:50:11.570", "Id": "18420809", "Score": "3", "CreationDate": "2013-08-24T16:43:54.027", "LastActivityDate": "2013-08-24T16:50:11.570"}, "18420645": {"CommentCount": "2", "AcceptedAnswerId": "18420809", "PostTypeId": "1", "LastEditorUserId": "735860", "CreationDate": "2013-08-24T16:26:24.287", "LastActivityDate": "2013-08-24T18:20:53.367", "LastEditDate": "2013-08-24T16:41:57.400", "ViewCount": "922", "FavoriteCount": "0", "Title": "About virtual function override in C++", "Id": "18420645", "Score": "0", "Body": "<p>I'm a little confused about the following situations, are they correct ways for the overriding of function <code>copy</code> but not overloading, or all of them are right?</p>\n<pre><code>class Base{\npublic:\n    virtual Base* copy(Base* b){...}\n};\n\nclass Derived:public Base{\npublic:\n    virtual Base* copy(Base* b){...}//I know this should work\n // but how about the followings?\n    //virtual Base* copy(Derived* b){...}\n    //virtual Derived* copy(Base* b){...}\n    //virtual Derived* copy(Derived* b){...}\n};\n</code></pre>\n<p>BTW, does the change of access right make any difference? say, I write the Derived class like this:</p>\n<pre><code>class Derived:public Base{\nprivate://or protected:\n    virtual Base* copy(Base* b){...}\n    ...\n};\n</code></pre>\n", "Tags": "<c++><inheritance><polymorphism><override><virtual>", "OwnerUserId": "735860", "AnswerCount": "3"}, "18420804": {"ParentId": "18420645", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>These are the rules for function overriding:</p>\n<blockquote>\n<p id=\"so_18420645_18420804_0\"><code>[C++11: 10.3/2]:</code> If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with <strong>the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code></strong> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it <em>overrides</em><sup>111</sup> <code>Base::vf</code>. <em>[..]</em></p>\n</blockquote>\n<p>If these rules are not met, then the new function does not <em>override</em> the old function (though it may <em>overload</em> or <em>hide</em> it).</p>\n<p>So:</p>\n<pre><code>class Base\n{\npublic:\n    virtual Base* copy(Base* b);\n};\n\nclass Derived : public Base\n{\npublic:\n    // Overrides Base::copy\n    virtual Base* copy(Base* b);\n\n    // Does NOT override Base::copy (due to different parameter-type-list)\n    virtual Base* copy(Derived* b);\n\n    // Overrides Base::copy (despite different return type)\n    virtual Derived* copy(Base* b);\n\n    // Does NOT override Base::copy (due to different parameter-type-list)\n    virtual Derived* copy(Derived* b);\n\nprivate:\n    // Overrides Base::copy (despite different access specifier)\n    virtual Base* copy(Base* b);\n};\n</code></pre>\n<p>Though, note that the above class <code>Derived</code> is actually ill-formed, due to the end of <code>10.3/2</code> which states:</p>\n<blockquote>\n<p id=\"so_18420645_18420804_1\">In a derived class, if a virtual member function of a base class subobject has more than one final overrider the program is ill-formed.</p>\n</blockquote>\n<p>That means we should only have declared <em>one</em> of those overriding functions. I listed them all inside a single class definition just for the purpose of illustration.</p>\n<p>It may be surprising that <code>virtual Derived* copy(Base* b)</code> overrides <code>Base::copy</code>, because it has a different return type; this is allowed as long as the two return types are <em><a href=\"http://en.wikipedia.org/wiki/Covariant_return_type\" rel=\"nofollow\">covariant</a></em>:</p>\n<blockquote>\n<p id=\"so_18420645_18420804_2\"><code>[C++11: 10.3/7]:</code> <strong>The return type of an overriding function shall be either identical to the return type of the overridden function or <em>covariant</em> with the classes of the functions.</strong> If a function <code>D::f</code> overrides a function <code>B::f</code>, the return types of the functions are covariant if they satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to classes, both are lvalue references to classes, or both are rvalue references to classes</li>\n<li>the class in the return type of <code>B::f</code> is the same class as the class in the return type of <code>D::f</code>, or is an unambiguous and accessible direct or indirect base class of the class in the return type of <code>D::f</code></li>\n<li>both pointers or references have the same cv-qualification and the class type in the return type of <code>D::f</code> has the same cv-qualification as or less cv-qualification than the class type in the return type of <code>B::f</code>.</li>\n</ul>\n</blockquote>\n<p>As for the <code>public</code> vs <code>private</code> question, there is no rule saying that this matters; the situation is clarified by footnote 111 in case there was any doubt:</p>\n<blockquote>\n<p id=\"so_18420645_18420804_3\"><sup>111</sup> A function with the same name but a different parameter list (Clause 13) as a virtual function is not necessarily virtual and does not override. The use of the <code>virtual</code> specifier in the declaration of an overriding function is legal but redundant (has empty semantics). <strong>Access control (Clause 11) is not considered in determining overriding.</strong></p>\n</blockquote>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2013-08-24T16:56:58.230", "Id": "18420804", "Score": "6", "CreationDate": "2013-08-24T16:43:33.453", "LastActivityDate": "2013-08-24T16:56:58.230"}, "bq_ids": {"n4140": {"so_18420645_18420804_2": {"section_id": 7008, "quality": 0.8518518518518519, "length": 23}, "so_18420645_18420804_3": {"section_id": 7003, "quality": 0.9375, "length": 30}, "so_18420645_18420804_0": {"section_id": 7003, "quality": 0.8823529411764706, "length": 30}, "so_18420645_18420804_1": {"section_id": 7003, "quality": 1.0, "length": 14}}, "n3337": {"so_18420645_18420804_2": {"section_id": 6754, "quality": 0.8518518518518519, "length": 23}, "so_18420645_18420804_3": {"section_id": 6749, "quality": 0.9375, "length": 30}, "so_18420645_18420804_0": {"section_id": 6749, "quality": 0.8823529411764706, "length": 30}, "so_18420645_18420804_1": {"section_id": 6749, "quality": 1.0, "length": 14}}, "n4659": {"so_18420645_18420804_2": {"section_id": 8505, "quality": 0.8518518518518519, "length": 23}, "so_18420645_18420804_3": {"section_id": 8500, "quality": 0.9375, "length": 30}, "so_18420645_18420804_0": {"section_id": 8500, "quality": 0.8823529411764706, "length": 30}, "so_18420645_18420804_1": {"section_id": 8500, "quality": 1.0, "length": 14}}}});