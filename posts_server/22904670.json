post_cb({"22904732": {"ParentId": "22904670", "CommentCount": "0", "Body": "<p>It's not \"bizarre\".</p>\n<p>Try printing the number in hex and see if it's any more recognizable:</p>\n<p><code>std::cout &lt;&lt; std::hex &lt;&lt; i &lt;&lt; std::endl;</code></p>\n<p>And always remember to qualify your literals with \"U\", \"L\" and/or \"LL\" as appropriate:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/integer_literal\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/integer_literal</a></p>\n<pre><code>unsigned long long l1 = 18446744073709550592ull;\nunsigned long long l2 = 18'446'744'073'709'550'592llu;\nunsigned long long l3 = 1844'6744'0737'0955'0592uLL;\nunsigned long long l4 = 184467'440737'0'95505'92LLU;\n</code></pre>\n", "OwnerUserId": "3135317", "PostTypeId": "2", "Id": "22904732", "Score": "2", "CreationDate": "2014-04-07T06:08:05.463", "LastActivityDate": "2014-04-07T06:08:05.463"}, "22904734": {"ParentId": "22904670", "CommentCount": "0", "Body": "<p>The literal <code>1</code> with no <code>U</code> is a signed <code>int</code>, so when you shift <code>&lt;&lt; 31</code>,  you get integer overflow, generating a negative number (under the umbrella of undefined behavior).</p>\n<p>Assigning this negative number to an <code>unsigned long</code> causes sign extension, because <code>long</code> has more bits than <code>int</code>, and it translates the negative number into a large positive number by taking its modulus with 2<sup>64</sup>, which is the rule for signed-to-unsigned conversion.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "22904734", "Score": "5", "CreationDate": "2014-04-07T06:08:18.410", "LastActivityDate": "2014-04-07T06:08:18.410"}, "22904670": {"CommentCount": "2", "CreationDate": "2014-04-07T06:03:38.517", "PostTypeId": "1", "AcceptedAnswerId": "22904772", "LastEditorUserId": "3865653", "LastActivityDate": "2016-05-12T01:08:00.250", "LastEditDate": "2016-05-12T01:08:00.250", "ViewCount": "6684", "FavoriteCount": "3", "Title": "c/c++ left shift unsigned vs signed", "Id": "22904670", "Score": "9", "Body": "<p>I have this code.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    unsigned long int i = 1U &lt;&lt; 31;\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n    unsigned long int uwantsum = 1 &lt;&lt; 31;\n    std::cout &lt;&lt; uwantsum &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>It prints out.</p>\n<pre><code>2147483648\n18446744071562067968\n</code></pre>\n<p>on Arch Linux 64 bit, gcc, ivy bridge architecture.</p>\n<p>The first result makes sense, but I don't understand where the second number came from. 1 represented as a 4byte int signed or unsigned is</p>\n<pre><code>00000000000000000000000000000001\n</code></pre>\n<p>When you shift it 31 times to the left, you end up with</p>\n<pre><code>10000000000000000000000000000000\n</code></pre>\n<p>no? I know shifting left for positive numbers is essentially 2^k where k is how many times you shift it, assuming it still fits within bounds. Why is it I get such a bizarre number?</p>\n", "Tags": "<c++><bit-shift>", "OwnerUserId": "1201238", "AnswerCount": "5"}, "22904772": {"ParentId": "22904670", "LastEditDate": "2014-04-07T06:40:57.040", "CommentCount": "7", "CreationDate": "2014-04-07T06:10:37.080", "OwnerUserId": "179910", "LastEditorUserId": "179910", "PostTypeId": "2", "Id": "22904772", "Score": "11", "Body": "<p>Presumably you're interested in why this: <code>unsigned long int uwantsum = 1 &lt;&lt; 31;</code> produces a \"strange\" value.</p>\n<p>The problem is pretty simple: 1 is a plain <code>int</code>, so the shift is done on a plain <code>int</code>, and only after it's complete is the result converted to <code>unsigned long</code>.</p>\n<p>In this case, however, <code>1&lt;&lt;31</code> overflows the range of a 32-bit signed int, so the result is undefined<sup>1</sup>. After conversion to unsigned, the result remains undefined.</p>\n<hr>\n<p><ol>\n<li>\u00a75.8/2: \n<sup></sup></li></ol></p>\n<blockquote>\n<p id=\"so_22904670_22904772_0\">The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has an unsigned type, the value of the result is E1 \u00d7 2E2, reduced modulo one more than the maximum value representable in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1\u00d72E2 is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the resulting value; <strong>otherwise, the behavior is undefined</strong>.\n  </p></blockquote></hr>\n", "LastActivityDate": "2014-04-07T06:40:57.040"}, "22905084": {"ParentId": "22904670", "CommentCount": "0", "Body": "<p>I think it is compiler dependent .<br>\nIt gives same value<br>\n<code>2147483648\n2147483648</code><br>\non my machiene (g++) .<br>\n<strong>Proof</strong> : <a href=\"http://ideone.com/cvYzxN\" rel=\"nofollow\">http://ideone.com/cvYzxN</a> </br></br></br></br></p>\n<p>And if overflow is there , then because <code>uwantsum</code> is <code>unsigned long int</code> and unsigned values are <strong>ALWAYS</strong> positive , conversion is done from signed to unsigned by using <code>(uwantsum)%2^64</code> .</p>\n<p>Hope this helps !</p>\n", "OwnerUserId": "1731863", "PostTypeId": "2", "Id": "22905084", "Score": "1", "CreationDate": "2014-04-07T06:30:44.793", "LastActivityDate": "2014-04-07T06:30:44.793"}, "bq_ids": {"n4140": {"so_22904670_22904772_0": {"section_id": 6147, "quality": 0.9333333333333333, "length": 42}}, "n3337": {"so_22904670_22904772_0": {"section_id": 5910, "quality": 0.7777777777777778, "length": 35}}, "n4659": {"so_22904670_22904772_0": {"section_id": 7643, "quality": 0.9333333333333333, "length": 42}}}, "22907565": {"ParentId": "22904670", "CommentCount": "0", "Body": "<p>Its in the way you printed it out.\nusing formar specifier %lu should represent a proper long int</p>\n", "OwnerUserId": "1508600", "PostTypeId": "2", "Id": "22907565", "Score": "-1", "CreationDate": "2014-04-07T08:44:59.073", "LastActivityDate": "2014-04-07T08:44:59.073"}});