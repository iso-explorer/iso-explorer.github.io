post_cb({"32266959": {"ParentId": "32265938", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-08-28T08:48:12.667", "Score": "0", "LastEditorUserId": "3309790", "LastEditDate": "2015-08-28T09:41:53.123", "Id": "32266959", "OwnerUserId": "3309790", "Body": "<p><code>using directive</code> and <code>using declaration</code> hehaviours differently in this case.</p>\n<p>7.3.4$2 Using directive [namespace.udir]: (bold by me)</p>\n<blockquote>\n<p id=\"so_32265938_32266959_0\">A using-directive specifies that the names in the nominated namespace\n  can be used in the scope in which the using-directive appears after\n  the using-directive. During unqualified name lookup (3.4.1), the names\n  appear as if they were declared in the <strong>nearest enclosing namespace</strong>\n  which contains both the using-directive and the nominated namespace. [\n  Note: In this context, \u201ccontains\u201d means \u201ccontains directly or\n  indirectly\u201d. \u2014end note ]</p>\n</blockquote>\n<p>In this case, the nearest enclosing namespace is the global namaspace, the functions of namespace <code>primerlib</code> appear in the same namespace with other global functions, so after the overloading resolution <code>::compute(int)</code> was called.</p>\n<p>7.3.3$1 The using declaration [namespace.udecl]:</p>\n<blockquote>\n<p id=\"so_32265938_32266959_1\">A using-declaration introduces a name into the declarative region in\n  which the using-declaration appears.</p>\n</blockquote>\n<p>The functions of namespace <code>primerlib</code> will be introduced into the <code>main</code> function scope, and they will be selected at the stage of name lookup with high precedence, and then name lookup will stop. The global functions will not be considered for overloading resolution, so <code>primerlib::compute(const void *p)</code> was called.</p>\n<p>BTW:If you move <code>using primerlib::compute;</code> out of the <code>main</code> function, you will get same result as using <code>using namespace primerlib;</code> in <code>main</code> function.</p>\n<p><a href=\"http://rextester.com/JJQJ95524\" rel=\"nofollow\">LIVE</a></p>\n", "LastActivityDate": "2015-08-28T09:41:53.123"}, "32266399": {"ParentId": "32265938", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-08-28T08:17:00.003", "Score": "1", "LastEditorUserId": "471160", "LastEditDate": "2015-08-28T08:32:36.870", "Id": "32266399", "OwnerUserId": "471160", "Body": "<blockquote>\n<p id=\"so_32265938_32266399_0\">using primerlib::compute;</p>\n</blockquote>\n<p>this is a <code>using</code> declaration. When you use it, it is as if a name is declared at the location of using declaration. You can bring back global <code>foo</code> by adding <code>using ::foo;</code> (or calling it with global scope <code>::foo(0);</code> and you will see <code>::compute(int)</code> in output. </p>\n<p>The fact that in your example compiler is not finding global <code>foo</code> declaration, is because this is how name lookup works - it searches enclosing scopes and stopes once a name was found.</p>\n<p>For more reference on using declaration see: <a href=\"http://en.cppreference.com/w/cpp/language/namespace#Using-declarations\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/namespace#Using-declarations</a></p>\n<p>[edit]</p>\n<p>I misunderstood your question, in line 17 you have 'using directive', it behaves differently from <code>using declaration</code>, it does not introduce name in nearest enclosing declarative region (in your case its main function), but adds names to nearest enclosing namespace - in this cast it is global namespace. For more reference: <a href=\"http://en.cppreference.com/w/cpp/language/namespace#Using-directives\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/namespace#Using-directives</a>:</p>\n<blockquote>\n<p id=\"so_32265938_32266399_1\">Using-directives are allowed only in namespace scope and in block scope. From the point of view of unqualified name lookup of any name after a using-directive and until the end of the scope in which it appears, <strong><em>every name from namespace-name is visible as if it were declared in the nearest enclosing namespace</em></strong> which contains both the using-directive and namespace-name.</p>\n<p id=\"so_32265938_32266399_2\"><strong><em>Using-directive does not add any names to the declarative region in which it appears</em></strong> (unlike the using-declaration), and thus does not prevent identical names from being declared.</p>\n</blockquote>\n", "LastActivityDate": "2015-08-28T08:32:36.870"}, "32266406": {"ParentId": "32265938", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-08-28T08:17:29.150", "Score": "4", "LastEditorUserId": "1490355", "LastEditDate": "2015-08-28T09:51:28.827", "Id": "32266406", "OwnerUserId": "1490355", "Body": "<p>That's because <code>using namespace X</code> and <code>using X::Y</code> work differently. When you use <code>using namespace X</code>, everything that is in that namespace is considered during the name lookup. Consider the following example:</p>\n<pre><code>namespace A\n{\n    void foo(int){}\n}\n\nnamespace B\n{\n    void foo(int){}\n}\n\nusing namespace A;\nusing namespace B;\n\nint main()\n{\n    foo(1);\n}\n</code></pre>\n<p>Here, both <code>A</code> and <code>B</code> members will be considered during the name lookup, and you will have the <code>call of overloaded foo(int) is ambiguous</code> error, because the compiler fails to decide which of the two functions to use, since they are identical. The <code>using X::Y</code> syntax is meant to solve this problem. When you use it, you tell the compiler to only use the <code>Y</code> found in <code>X</code> namespace, without considering anything else. Let's add it to the above example:</p>\n<pre><code>namespace A\n{\n    void foo(int){}\n}\n\nnamespace B\n{\n    void foo(int){}\n}\n\nusing namespace A;\nusing namespace B;\n\n\nint main()\n{\n    using A::foo;  \n    foo(1);\n}\n</code></pre>\n<p>Here we tell the compiler to use the instance of <code>foo</code> found in the <code>A</code> namespace, and ignore any other <code>foo</code>s that are in scope. So, in your example you are telling the compiler to only use <code>primerlib::compute</code>, and you will have to use <code>::compute()</code> if you want to to access the functions from the global scope, and call the <code>compute(int)</code>.</p>\n", "LastActivityDate": "2015-08-28T09:51:28.827"}, "32265938": {"CommentCount": "5", "ViewCount": "366", "PostTypeId": "1", "LastEditorUserId": "3545094", "CreationDate": "2015-08-28T07:49:25.523", "LastActivityDate": "2015-08-28T09:51:28.827", "Title": "c++ using declaration and function overload", "FavoriteCount": "2", "LastEditDate": "2015-08-28T09:49:12.750", "Id": "32265938", "Score": "8", "Body": "<pre><code>  1 #include &lt;iostream&gt;\n  2 \n  3 namespace primerlib {\n  4     void compute() { std::cout &lt;&lt; \"primerlib::print()\" &lt;&lt; std:: endl; }\n  5     void compute(const void *p) { std::cout &lt;&lt; \"primerlib::print(const void *p)\" &lt;&lt; std:: endl; }\n  6 }\n  7 \n  8 //using primerlib::compute;\n  9 //using namespace primerlib;\n 10 void compute(int a) { std::cout &lt;&lt; \"::compute(int)\" &lt;&lt; std:: endl; }\n 11 void compute(double d, double dd=3.4) { std::cout &lt;&lt; \"primerlib::compute(d, d)\" &lt;&lt; std:: endl; }\n 12 void compute(char* p, char* p1 = 0) { std::cout &lt;&lt; \"primerlib::compute(char*, char*)\" &lt;&lt; std:: endl; }\n 13 \n 14 int main(void)\n 15 {\n 16     using primerlib::compute;\n 17     //using namespace primerlib;\n 18     compute(0);\n 19     return 0;\n 20 }\n</code></pre>\n<p>output:</p>\n<p><code>primerlib::print(const void *p)</code></p>\n<p>my question is why it didn't call the global compute(int) one ? If I use using directive in line 17 and it will call the compute(int) one. Your help will be really appreciated.</p>\n", "Tags": "<c++>", "OwnerUserId": "2218931", "AnswerCount": "4"}, "32266427": {"ParentId": "32265938", "CommentCount": "1", "Body": "<p>With the actual using declaration, you are saying that compute is a name that refers only to function defined in namespace primerlib: in fact if you try to call the compute function that accepts a double, you get an error of no matching function.\nWith the commented using declaration, you give all compute functions the \"same importance\": to refer to global ones, you have to use the \"::\" namespace resolution directive, to refer to primer's namespace ones, you have to use the \"primerlib::\" namespace resolution directive.</p>\n", "OwnerUserId": "3441991", "PostTypeId": "2", "Id": "32266427", "Score": "0", "CreationDate": "2015-08-28T08:18:23.683", "LastActivityDate": "2015-08-28T08:18:23.683"}, "bq_ids": {"n4140": {"so_32265938_32266959_0": {"section_id": 5510, "quality": 0.8947368421052632, "length": 34}, "so_32265938_32266959_1": {"section_id": 5490, "quality": 1.0, "length": 8}}, "n3337": {"so_32265938_32266959_0": {"section_id": 5296, "quality": 0.8947368421052632, "length": 34}, "so_32265938_32266959_1": {"section_id": 5276, "quality": 1.0, "length": 8}}, "n4659": {"so_32265938_32266959_1": {"section_id": 6924, "quality": 0.875, "length": 7}, "so_32265938_32266959_0": {"section_id": 6945, "quality": 0.8947368421052632, "length": 34}}}});