post_cb({"9303843": {"CommentCount": "3", "AcceptedAnswerId": "9306682", "CreationDate": "2012-02-16T00:33:03.627", "LastActivityDate": "2012-02-16T13:24:42.060", "PostTypeId": "1", "ViewCount": "2071", "FavoriteCount": "7", "Title": "Clang vs MSVC: Treatment of template function prototypes", "Id": "9303843", "Score": "11", "Body": "<p>The following is a piece of test code, and I'm comparing the result of compiling this with MSVC and Clang respectively. The output of each compiler is shown below. MSVC pretends that the unused template declaration doesn't even exist. Clang produces an error. The question is, which compiler is most standard conformant here? </p>\n<p>I have seen legacy production code that relies on the MSVC behavior, and I'm unsure whether or not it can continue to be relied on.</p>\n<pre><code>class S\n{\n    struct P {};\n};\n\ntemplate&lt;typename T&gt;\nS::P Bat(T);\n</code></pre>\n<p>Compiles cleanly in MSVC10:</p>\n<pre><code>E:\\clangbuild\\bin\\Release&gt;cl /c /nologo test.cpp\ntest.cpp\n</code></pre>\n<p>Produces an error in Clang:</p>\n<pre><code>E:\\clangbuild\\bin\\Release&gt;clang++ test.cpp\ntest.cpp:9:4: error: 'P' is a private member of 'S'\nS::P Bat(T);\n   ^\ntest.cpp:5:9: note: implicitly declared private here\nstruct P {};\n        ^\n1 error generated.\n</code></pre>\n", "Tags": "<c++><templates><visual-c++><clang>", "OwnerUserId": "1072392", "AnswerCount": "2"}, "9304293": {"ParentId": "9303843", "CommentCount": "9", "Body": "<p>The compiler is only really required to check for any malformed syntax of uninstantiated template declarations. Any additional semantic evaluation only needs to be done when the template function is instantiated.</p>\n<p>Since S::P is indeed a type which is valid to be returned from a function, they are both equally conformant.</p>\n", "OwnerUserId": "19404", "PostTypeId": "2", "Id": "9304293", "Score": "3", "CreationDate": "2012-02-16T01:35:18.770", "LastActivityDate": "2012-02-16T01:35:18.770"}, "bq_ids": {"n4140": {"so_9303843_9306682_2": {"section_id": 7083, "quality": 0.8787878787878788, "length": 29}, "so_9303843_9306682_0": {"section_id": 176, "quality": 0.88, "length": 22}, "so_9303843_9306682_1": {"section_id": 177, "quality": 0.9655172413793104, "length": 28}}, "n3337": {"so_9303843_9306682_2": {"section_id": 6827, "quality": 0.8787878787878788, "length": 29}, "so_9303843_9306682_0": {"section_id": 170, "quality": 0.88, "length": 22}, "so_9303843_9306682_1": {"section_id": 171, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_9303843_9306682_0": {"section_id": 181, "quality": 0.88, "length": 22}, "so_9303843_9306682_2": {"section_id": 8584, "quality": 0.8787878787878788, "length": 29}, "so_9303843_9306682_1": {"section_id": 182, "quality": 0.9655172413793104, "length": 28}}}, "9306682": {"ParentId": "9303843", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>This fails because of the two-phase name lookup in C++.</p>\n<p>In phase one, when the template is initially parsed, long before it is instantiated, the compiler parses the template and looks up any non-dependent names. <code>S::P</code> is a non-dependent name, so the compiler tries to look it up, but fails because it is private. </p>\n<p>In phase 2, when the template is instantiated, the compiler will lookup any dependent names, which can vary from template to template. </p>\n<p>Clang is fairly strictly conforming to the two-phase name lookup. However, MSVC has a template parsing model that delays nearly every lookup to instantiation time, which is part of phase 2. This delay is why your example would compile with MSVC(which is non-conforming) and not in clang. Here is a link with more information:</p>\n<p><a href=\"http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html\" rel=\"nofollow\">The Dreaded Two-Phase Name Lookup</a></p>\n<p>Also, here are the sections from the C++ standard where it describes the two-phase lookup.</p>\n<p>14.6.8:</p>\n<blockquote>\n<p id=\"so_9303843_9306682_0\">When looking for the declaration of a name used in a template\n  definition, the usual lookup rules (3.4.1, 3.4.2) are used for\n  non-dependent names. The lookup of names dependent on the template\n  parameters is postponed until the actual template argument is known.</p>\n</blockquote>\n<p>14.6.9:</p>\n<blockquote>\n<p id=\"so_9303843_9306682_1\">If a name does not depend on a template-parameter (as defined in\n  14.6.2), a declaration (or set of declarations) for that name shall be in scope at the point where the name appears in the template\n  definition; the name is bound to the declaration (or declarations)\n  found at that point and this binding is not affected by declarations\n  that are visible at the point of instantiation.</p>\n</blockquote>\n<p>Then the part of 3.4 Name lookup applicable to you:</p>\n<blockquote>\n<p id=\"so_9303843_9306682_2\">The access rules (clause 11) are considered only once name lookup and\n  function overload resolution (if applicable) have succeeded. Only\n  after name lookup, function overload resolution (if applicable) and\n  access checking have succeeded are the attributes introduced by the\n  name\u2019s declaration used further in expression processing (clause 5).</p>\n</blockquote>\n<p>Its clear from reading these parts that your program is ill-formed. The only thing the standard states that should be postponed until instantiation is the lookup of a dependent name.  Non-dependent names go through the usual name lookup, which includes access rules.</p>\n", "OwnerUserId": "375343", "LastEditorUserId": "375343", "LastEditDate": "2012-02-16T13:24:42.060", "Id": "9306682", "Score": "4", "CreationDate": "2012-02-16T06:41:03.923", "LastActivityDate": "2012-02-16T13:24:42.060"}});