post_cb({"4062988": {"Id": "4062988", "PostTypeId": "2", "Body": "<p>The problem that you are facing is that you have declared the specialization of <code>f</code> for <code>char</code> in the <code>Test</code> template, and that is incorrect. The compiler is not detecting the error, but it is getting confused and interpreting that you want to provide the specialization of <code>f</code> for <code>char</code> in <em>all</em> template instantiations:</p>\n<pre><code>template &lt;typename T&gt;\nstruct Test {\n   template &lt;typename U&gt; void f();\n   template &lt;&gt; void f&lt;char&gt;();       // &lt;- Incorrect\n};\n</code></pre>\n<p>When you write <code>Test&lt;int&gt;</code> the compiler instantiates the template and is (mistakenly) accepting it and interepreting that there is an specialization of <code>f</code> for <code>char</code> in <code>Test&lt;int&gt;</code>.</p>\n<p>Just remove the line, and you will get the code to compile. It will use the specialization only for <code>Test&lt;char&gt;::f&lt;char&gt;()</code>, and I am not sure whether that is what you want.</p>\n<p>If your intention is specializing <code>f</code> for <code>char</code> with <em>all</em> instantiating types, that is not allowed. When you define a template specialization, all enclosing templates be specialized. A common work around is not providing an specialization but a different overload of the member function:</p>\n<pre><code>template &lt;typename T&gt;\nstruct Test {\n   template &lt;typename U&gt; void f( U );\n   void f( char );\n};\n</code></pre>\n<p>But that won't help you much there, as you cannot provide different overloads for the same arguments (in your case <em>no</em> arguments). Also, in your case you must explicitly call the template to differentiate, and code that explicitly requests the template would not pick up the overload:</p>\n<pre><code>int main() {\n   Test&lt;int&gt; t;\n   t.f&lt;char&gt;(); // will call template, not \"void f(char)\"!!\n}\n</code></pre>\n<p>Without more details on what you really want to achieve I cannot think on other potential solution to the issue.</p>\n", "LastActivityDate": "2010-10-31T11:59:23.820", "CommentCount": "0", "CreationDate": "2010-10-31T11:59:23.820", "ParentId": "4062388", "Score": "3", "OwnerUserId": "36565"}, "bq_ids": {"n4140": {"so_4062388_4062388_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 45}}, "n3337": {"so_4062388_4062388_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 42}}, "n4659": {"so_4062388_4062388_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 46}}}, "4062421": {"Id": "4062421", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4062388_4062421_0\">My requirement is: I should be able to pass any type to Test class and any type to function f(). I should be able to use all combinations of types like below.</p>\n</blockquote>\n<p>Why do you need an explicit specialization? Why do you unnecessarily want to make your code complex?</p>\n<p>The following works for all combinations that you have listed.</p>\n<pre><code>template &lt;class T&gt;\nclass Test\n{\npublic:\n    template&lt;class U&gt; void f(); \n};\n\ntemplate &lt;class T&gt;\ntemplate&lt;class U&gt;\nvoid Test&lt;T&gt;::f(){}   \n\nint main()\n{\n    Test&lt;char&gt; ob1;\n    ob1.f&lt;char&gt;(); //Works fine. T = char, U = char\n\n    Test&lt;int&gt; ob2;\n    ob2.f&lt;char&gt;();  //Works fine T = int, U = char\n}\n</code></pre>\n", "LastEditorUserId": "165520", "LastActivityDate": "2010-10-31T08:50:51.407", "Score": "0", "CreationDate": "2010-10-31T08:44:46.603", "ParentId": "4062388", "CommentCount": "1", "OwnerUserId": "165520", "LastEditDate": "2010-10-31T08:50:51.407"}, "4062388": {"ViewCount": "320", "Body": "<pre><code>template &lt;class T&gt;\nclass Test\n{\npublic:\n    template&lt;class U&gt; void f(); //generic function\n\n    template&lt;&gt; void f&lt;char&gt;(); //Specialization for char.\n};\n\ntemplate &lt;class T&gt;\ntemplate&lt;class U&gt; \nvoid Test&lt;T&gt;::f()   //Definition of generic function\n{\n}\n\ntemplate&lt;&gt;\ntemplate&lt;&gt; void Test&lt;char&gt;::f&lt;char&gt;(){}  //Definition of specialization.\n\nint main()\n{\n    Test&lt;char&gt; ob1;\n    ob1.f&lt;char&gt;(); //Works fine.\n\n    Test&lt;int&gt; ob2;\n    ob2.f&lt;char&gt;();  //Produces linker error.\n}\n</code></pre>\n<p>Linker error is </p>\n<pre><code>error LNK2019: unresolved external symbol \"public: void __thiscall\nTest&lt;int&gt;::f&lt;char&gt;(void)\"\n</code></pre>\n<p>My requirement is: I should be able to pass any type to Test class and any type to function f(). I should be able to use all combinations of types like below.</p>\n<blockquote id=\"so_4062388_4062388_0\">\n<pre><code>  Test   f()\n  --------------\n  int    char\n  char   int\n  int    int\n</code></pre>\n</blockquote>\n<p>I can solve the error by defining another function like below.</p>\n<pre><code>template&lt;&gt;\ntemplate&lt;&gt; void Test&lt;int&gt;::f&lt;char&gt;(){}\n</code></pre>\n<p>But then what is the use of making Test class as Template ? How to make it work for all combinations ?</p>\n", "AcceptedAnswerId": "4062442", "Title": "Explicit template specialization issue", "CreationDate": "2010-10-31T08:33:09.400", "Id": "4062388", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2010-10-31T12:39:48.603", "Score": "3", "OwnerUserId": "426051", "Tags": "<c++>", "AnswerCount": "3"}, "4062442": {"Id": "4062442", "PostTypeId": "2", "Body": "<p>C++03, \u00a714.7.3/2:</p>\n<p>An explicit specialization shall be declared in the namespace of which the\ntemplate is a member, or, for member templates, in the namespace of which\nthe enclosing class or enclosing class template is a member.\nAn explicit specialization of a member function, member class or static data\nmember of a class template shall be declared in the namespace of which the\nclass template is a member.</p>\n<p>Therefore you should declare your specialization outside of a class, for example:</p>\n<pre><code>template &lt;class T&gt;\nclass Test\n{\npublic:\n    template&lt;class U&gt; void f(); //generic function\n};\n\ntemplate &lt;class T&gt;\ntemplate &lt;class U&gt; \nvoid Test&lt;T&gt;::f() {}  //Definition of generic function\n\ntemplate&lt;&gt;\ntemplate&lt;&gt;\nvoid Test&lt;char&gt;::f&lt;char&gt;(){}  //Specialization.\n\nint main()\n{\n    Test&lt;char&gt; ob1;\n    ob1.f&lt;char&gt;();\n\n    Test&lt;int&gt; ob2;\n    ob2.f&lt;char&gt;();\n}\n</code></pre>\n", "LastEditorUserId": "471164", "LastActivityDate": "2010-10-31T12:39:48.603", "Score": "5", "CreationDate": "2010-10-31T08:51:43.523", "ParentId": "4062388", "CommentCount": "2", "OwnerUserId": "471164", "LastEditDate": "2010-10-31T12:39:48.603"}});