post_cb({"bq_ids": {"n4140": {"so_35273025_35273245_5": {"length": 25, "quality": 1.0, "section_id": 3325}, "so_35273025_35273245_3": {"length": 12, "quality": 0.8, "section_id": 599}, "so_35273025_35273245_2": {"length": 21, "quality": 0.875, "section_id": 3325}, "so_35273025_35273245_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 599}, "so_35273025_35273245_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 3325}, "so_35273025_35273245_1": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_35273025_35273245_0": {"length": 5, "quality": 1.0, "section_id": 3323}}, "n3337": {"so_35273025_35273245_1": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_35273025_35273245_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 3195}, "so_35273025_35273245_3": {"length": 12, "quality": 0.8, "section_id": 589}, "so_35273025_35273245_0": {"length": 5, "quality": 1.0, "section_id": 3193}, "so_35273025_35273245_2": {"length": 21, "quality": 0.875, "section_id": 3195}, "so_35273025_35273245_5": {"length": 19, "quality": 0.76, "section_id": 3195}, "so_35273025_35273245_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 589}}, "n4659": {"so_35273025_35273245_1": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_35273025_35273245_5": {"length": 25, "quality": 1.0, "section_id": 4091}, "so_35273025_35273245_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 4048}, "so_35273025_35273245_3": {"length": 12, "quality": 0.8, "section_id": 622}, "so_35273025_35273245_0": {"length": 4, "quality": 0.8, "section_id": 4089}, "so_35273025_35273245_7": {"length": 14, "quality": 0.7, "section_id": 4091}, "so_35273025_35273245_2": {"length": 21, "quality": 0.875, "section_id": 4091}, "so_35273025_35273245_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 622}}}, "35273245": {"Id": "35273245", "PostTypeId": "2", "Body": "<p><em>As pointed out by Nicol Bolas, the original version of this answer was incorrect: cppreference at the time of writing incorrectly documented the order in which constructors were considered in list-initialization. Below is an answer using the rules as they exist in the n4140 draft of the standard, which is very close to the official C++14 standard.</em></p>\n<p><em>The text of the original answer is still included, for the record.</em></p>\n<hr>\n<h3>Updated Answer</h3>\n<p>Per NathanOliver's comment, gcc and clang produce different outputs in this situation:</p>\n<pre><code>g++ -std=c++14 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\ndefault ctor\ncopy ctor\ncopy ctor\ninitializer list\n\n\nclang++ -std=c++14 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\ndefault ctor\ncopy ctor\ncopy ctor\n</code></pre>\n<p>gcc is correct. </p>\n<p>n4140 [dcl.init.list]/1</p>\n<blockquote>\n<p id=\"so_35273025_35273245_0\">List-initialization is initialization of an object or reference from a braced-init-list.</p>\n</blockquote>\n<p>You're using list-initialization there, and since <code>c</code> is an object, the rules for its list-initialization are defined in [dcl.init.list]/3:</p>\n<p>[dcl.init.list]/3:</p>\n<blockquote>\n<p id=\"so_35273025_35273245_1\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ol>\n<li>If <code>T</code> is an aggregate...</li>\n<li>Otherwise, if the initializer list has no elements...</li>\n<li>Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code>...</li>\n</ol>\n</blockquote>\n<p>going through the list so far:</p>\n<ol>\n<li><code>Foo</code> is not an aggregate.</li>\n<li>It has one element.</li>\n<li><code>Foo</code> is not a specialization of <code>std::initializer_list&lt;E&gt;</code>.</li>\n</ol>\n<p>Then we hit [dcl.init.list]/3.4:</p>\n<blockquote>\n<p id=\"so_35273025_35273245_2\">Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</p>\n</blockquote>\n<p>Now we're getting somewhere. 13.3.1.7 is also known as [over.match.list]:</p>\n<blockquote>\n<p id=\"so_35273025_35273245_3\"><strong>Initialization by list-initialization</strong><br>\n  When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor in two phases:</br></p>\n<ol>\n<li>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.  </li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements of the initializer list.</li>\n</ol>\n</blockquote>\n<p>So the copy constructor will only be considered <em>after</em> the initializer list constructors, in the second phase of overload resolution. The initializer list constructor should be used here.</p>\n<p>It's worth noting that [over.match.list] then continues with:</p>\n<blockquote>\n<p id=\"so_35273025_35273245_4\">If the initializer list has no elements and <code>T</code> has a default constructor, the first phase is omitted. In copy-list initialization, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>and that after [dcl.init.list]/3.<strong>5</strong> deals with single-element list initialization:</p>\n<blockquote>\n<p id=\"so_35273025_35273245_5\">Otherwise, if the initializer list has a single element of type <code>E</code> and either <code>T</code> is not a reference type or its referenced type is reference-related to <code>E</code>, the object or reference is initialized from that element; if a narrowing conversion (see below) is required to convert the element to <code>T</code>, the program is ill-formed.</p>\n</blockquote>\n<p>which explains where cppreference got their special case for single-element list initialization, though they placed it higher in the order than it should be.</p>\n<hr>\n<h3>Original Answer</h3>\n<p>You're encountering an interesting aspect of list initialization, where if the list fulfills certain requirements it may be treated like a copy-initialization rather than a list-initialization.</p>\n<p>from <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\">cppreference</a>: </p>\n<blockquote>\n<p id=\"so_35273025_35273245_6\">The effects of list initialization of an object of type <code>T</code> are: </p>\n<p id=\"so_35273025_35273245_7\">If <code>T</code> is a class type and the initializer list has a single element of\n  the same or derived type (possibly cv-qualified), the object is\n  initialized from that element (by copy-initialization for\n  copy-list-initialization, or by direct-initialization for\n  direct-list-initialization). (since c++14)</p>\n</blockquote>\n<p><code>Foo c{b}</code> fulfills all these requirements.</p>\n</hr></hr>", "LastEditorUserId": "4892076", "LastActivityDate": "2016-12-11T20:59:26.897", "Score": "16", "CreationDate": "2016-02-08T15:28:49.250", "ParentId": "35273025", "CommentCount": "19", "OwnerUserId": "4892076", "LastEditDate": "2016-12-11T20:59:26.897"}, "41088389": {"Id": "41088389", "PostTypeId": "2", "Body": "<p>Let us examine what the C++14 specification says about list initialization here. [dcl.init.list]3 has a sequence of rules which are to be applied in order:</p>\n<p>3.1 does not apply, since <code>Foo</code> is not an aggregate.</p>\n<p>3.2 does not apply, since the list is not empty.</p>\n<p>3.3 does not apply, since <code>Foo</code> is not a specialization of <code>initializer_list</code>.</p>\n<p>3.4 does apply, since <code>Foo</code> is a class type. It says to consider constructors with overload resolution, in accord with [over.match.list]. And that rule says to check <code>initializer_list</code> constructors <em>first</em>. Since your type has an <code>initilaizer_list</code> constructor, the compiler <em>must</em> check to see if an <code>initializer_list</code> matching one of those constructors can be manufactured from the given values. It can, so <strong><em>that is what must be called</em></strong>.</p>\n<p>In short, GCC is right and Clang <em>is wrong</em>.</p>\n<p>It should be noted that the C++17 working draft changes <em>nothing</em> about this. It has a new section 3.1 that has special wording for single-value lists, but that <em>only applies to aggregates</em>. <code>Foo</code> is not an aggregate, so it does not apply.</p>\n", "LastActivityDate": "2016-12-11T16:31:09.473", "CommentCount": "10", "CreationDate": "2016-12-11T16:31:09.473", "ParentId": "35273025", "Score": "5", "OwnerUserId": "734069"}, "35273025": {"ViewCount": "344", "Body": "<p>Based on this code</p>\n<pre><code>struct Foo \n{\n   Foo() \n   {\n       cout &lt;&lt; \"default ctor\" &lt;&lt; endl;\n   }\n\n   Foo(std::initializer_list&lt;Foo&gt; ilist) \n   {\n       cout &lt;&lt; \"initializer list\" &lt;&lt; endl;\n   }\n\n   Foo(const Foo&amp; copy)\n   {\n       cout &lt;&lt; \"copy ctor\" &lt;&lt; endl;\n   }\n};\n\nint main()\n{\n\n   Foo a;\n   Foo b(a); \n\n   // This calls the copy constructor again! \n   //Shouldn't this call the initializer_list constructor?\n   Foo c{b}; \n\n\n\n   _getch();\n   return 0;\n}\n</code></pre>\n<p>The output is:</p>\n<p><strong>default ctor</strong></p>\n<p><strong>copy ctor</strong></p>\n<p><strong>copy ctor</strong></p>\n<p>In the third case, I'm putting b into the brace-initialization which should call the initializer_list&lt;&gt; constructor.</p>\n<p>Instead, the copy constructor takes the lead.</p>\n<p>Will someone of you tell me how this works and why?</p>\n", "AcceptedAnswerId": "35273245", "Title": "C++ Copy constructor gets called instead of initializer_list<>", "CreationDate": "2016-02-08T15:18:00.870", "Id": "35273025", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-12-11T20:59:26.897", "Score": "14", "OwnerUserId": "5406363", "Tags": "<c++><copy-constructor><initializer-list><brace-initialization>", "AnswerCount": "2"}});