post_cb({"bq_ids": {"n4140": {"so_19532448_19535939_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 704}, "so_19532448_19535309_0": {"length": 24, "quality": 1.0, "section_id": 986}, "so_19532448_19535939_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 986}}, "n3337": {"so_19532448_19535939_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 694}, "so_19532448_19535309_0": {"length": 24, "quality": 1.0, "section_id": 971}, "so_19532448_19535939_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 971}}, "n4659": {"so_19532448_19535939_1": {"length": 22, "quality": 0.8461538461538461, "section_id": 733}, "so_19532448_19535309_0": {"length": 24, "quality": 1.0, "section_id": 1049}, "so_19532448_19535939_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 1049}}}, "19535309": {"Id": "19535309", "PostTypeId": "2", "Body": "<p>The exact guarantee is given in C++11 23.3.6.5:</p>\n<blockquote>\n<p id=\"so_19532448_19535309_0\">If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of <code>T</code> or by any <code>InputIterator</code> operation there are no effects. If an exception is thrown by the move constructor of a non-<code>CopyInsertable</code> <code>T</code>, the effects are unspecified.</p>\n</blockquote>\n", "LastActivityDate": "2013-10-23T07:21:26.023", "CommentCount": "4", "CreationDate": "2013-10-23T07:21:26.023", "ParentId": "19532448", "Score": "2", "OwnerUserId": "204847"}, "19532506": {"Id": "19532506", "PostTypeId": "2", "Body": "<p>If the <a href=\"http://www.cplusplus.com/reference/vector/vector/insert/\" rel=\"nofollow\"><code>insert</code></a> method inserts a single element at the end of the list and does not require any memory to be allocated, offers a strong exception guarantee.</p>\n<p>If it has to add more than one element, or has to allocate memory it offers a basic exception guarantee.  <a href=\"http://www.boost.org/community/exception_safety.html\" rel=\"nofollow\">Boost</a> has a good description of the exception guarantees.  </p>\n<blockquote>\n<p id=\"so_19532448_19532506_0\">The basic guarantee: that the invariants of the component are preserved, and no resources are leaked.\n      The strong guarantee: that the operation has either completed successfully or thrown an exception, leaving the program state exactly as it was before the operation started.\n      The no-throw guarantee: that the operation will not throw an exception.</p>\n</blockquote>\n<p>This means that after an exception, you know that the <code>vector</code> will be usable, but it may not have all of the data you had inserted in it.  All of the objects that were successfully inserted will be fully constructed.</p>\n", "LastEditorUserId": "1517648", "LastActivityDate": "2013-10-23T04:05:12.590", "Score": "1", "CreationDate": "2013-10-23T03:58:44.717", "ParentId": "19532448", "CommentCount": "0", "OwnerUserId": "1517648", "LastEditDate": "2013-10-23T04:05:12.590"}, "19532448": {"ViewCount": "871", "Body": "<p>I'm wondering, exactly what is the exception safety guarantee for <code>std::vector::insert</code>? I am interested in both the single-argument and the range overloads of this function.</p>\n", "AcceptedAnswerId": "19535309", "Title": "What is the exception safety guarantee of vector::insert?", "CreationDate": "2013-10-23T03:52:02.380", "Id": "19532448", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-10-23T08:20:08.070", "Score": "10", "OwnerUserId": "298661", "Tags": "<c++>", "AnswerCount": "3"}, "19535939": {"Body": "<p>Generally, the single-element form of <code>insert</code> has a strong exception guarantee for any container as per [container.requirements.general]/10, but <code>vector::insert</code> is an exception to this rule:</p>\n<p>[vector.modifiers]/1 applies to <code>vector::insert</code>; <code>InputIterator</code> here refers to the overload of <code>insert</code> that inserts a range.</p>\n<blockquote>\n<p id=\"so_19532448_19535939_0\">If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of <code>T</code> or by any <code>InputIterator</code> operation there are no effects. If an exception is thrown by the move-constructor of a non-<code>CopyInsertable</code> <code>T</code>, the effects are unspecified.</p>\n</blockquote>\n<hr>\n<p><code>vector</code> is an allocator-aware container, which means that it uses an allocator for memory allocation <em>and</em> construction of its elements [container.requirements.general]/3</p>\n<blockquote>\n<p id=\"so_19532448_19535939_1\">For the components affected by this subclause that declare an <code>allocator_type</code>, objects stored in these components shall be constructed using the <code>allocator_traits&lt;allocator_type&gt;::construct</code> function and destroyed using the <code>allocator_traits&lt;allocator_type&gt;::destroy</code> function. These functions are called only for the container's element type, not for internal types used by the container.</p>\n</blockquote>\n<p>I think this implies that local objects, which are not elements of the container, can be created without using the allocator (e.g. for copy-and-swap). Otherwise, the requirements on the ctors of the value type would be pointless; the allocator's <code>construct</code> function might have different exception guarantees than the value type's ctor.</p>\n<hr>\n<p><code>CopyInsertable</code> is specified in [container.requirements.general]/13 by requiring that</p>\n<pre><code>allocator_traits&lt;A&gt;::construct(m, p, v);\n</code></pre>\n<p>is well-formed; where <code>A</code> is the allocator type, <code>m</code> is of type <code>A</code>, <code>p</code> is a pointer to <code>T</code>, <code>v</code> is an expression of type (<code>const</code>) <code>T</code>, and <code>T</code> is the value type of the container. This is an inplace construction from one argument (copy- or move-construction).</p>\n<p>Similarly, <code>MoveConstructible</code> is specified, but <code>v</code> is (always) an rvalue of type <code>T</code>. <code>EmplaceConstructible</code> follows the same form for zero or more arguments instead of <code>v</code>.</p>\n<p>The <code>insert</code> function for sequence containers imposes different requirements on the value type for its various forms [sequence.reqmts]; here including additional requirements for <code>vector</code>:</p>\n<ul>\n<li>for a single argument that is an lvalue of type (<code>const</code>) <code>T</code> and for the form <em>insert N copies of</em>, <code>T</code> shall be <code>CopyInsertable</code> and <code>CopyAssignable</code></li>\n<li>for a single argument that is an rvalue of type <code>T</code>, <code>T</code> shall be <code>MoveInsertable</code> and <code>MoveAssignable</code></li>\n<li>for the range form, <code>T</code> shall be <code>EmplaceConstructible</code> from the dereferenced iterators (*); additionally, <code>MoveInsertable</code> and <code>MoveAssignable</code> if the iterators of the range are no forward iterators</li>\n</ul>\n<p>(*) Note: <code>EmplaceConstructible</code> only from the dereferenced iterators is not enough if the container has to be resized for the insertion (and, e.g. the <code>*i</code> for such an iterator is not of the value type). It is possible that the specification requires the range form to inherit the requirements of the single-element form, i.e. either <code>MoveAssignable</code> or <code>CopyAssignable</code>.</p>\n<p><em>Side remark:</em> The range form of <code>insert</code> requires that the two iterators do not point in the container in which they are to be inserted.</p>\n<hr>\n<p>I interpret the exception specifications as follows:</p>\n<p>The additional statement about <code>CopyInsertable</code> in the exception specification of <code>vector::insert</code> probably distinguishes between the basic guarantee and no guarantee: The dtor of a container is generally required to call the dtor of all elements and deallocate all memory (in the general container requirements). That is, unless the behaviour is unspecified/undefined, the basic guarantee holds.</p>\n<p>Why there is a requirement that combines <code>CopyInsertable</code> and the move-ctor (instead of <code>allocator::construct</code> with an rvalue), I don't know. The move-ctor is only used directly for objects that are not elements of the container (indirectly possibly via <code>allocator::construct</code>).</p>\n<p>The other remarks about \"no effects\" (-&gt; strong guarantee) are <em>not</em> applied to the allocator operations (<code>construct</code>). The allocator operations obviously do not have to be noexcept. As you can provide a non-default allocator that doesn't use the value type's copy- and move-ctor for <code>construct</code>, <code>insert</code> has to provide the strong exception guarantees even for the <code>construct</code> allocator operations. For example, if the allocator's <code>construct</code> is not noexcept, during a resize, the elements cannot be move-constructed but have to be copied.</p>\n<p>Move- and copy-assignment have to be noexcept for the strong guarantee as the elements might need to be shifted around for <code>insert</code>; copy- and move-ctor might need to be noexcept for the strong guarantee because of local objects created in the algorithm.</p>\n</hr></hr></hr>", "CreationDate": "2013-10-23T07:54:51.697", "ParentId": "19532448", "CommentCount": "2", "LastEditDate": "2013-10-23T08:20:08.070", "Id": "19535939", "PostTypeId": "2", "LastActivityDate": "2013-10-23T08:20:08.070", "LastEditorUserId": "420683", "CommunityOwnedDate": "2013-10-23T07:54:51.697", "Score": "2", "OwnerUserId": "420683"}});