post_cb({"bq_ids": {"n4140": {"so_41746617_41785718_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6310}, "so_41746617_41785718_1": {"length": 14, "quality": 1.0, "section_id": 6304}}, "n3337": {"so_41746617_41785718_1": {"length": 14, "quality": 1.0, "section_id": 6061}, "so_41746617_41785718_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6067}}, "n4659": {"so_41746617_41785718_1": {"length": 14, "quality": 1.0, "section_id": 7814}, "so_41746617_41785718_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7820}}}, "41746617": {"ViewCount": "344", "Body": "<p>Accidentally, I wrote the following interesting snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nsize_t strlen(const char* str) {\n    std::cout &lt;&lt; \"hello\";\n    return 0;\n}\n\nint main() {\n    return std::strlen(\"sdf\");\n}\n</code></pre>\n<p>Unexpectedly for me, the output is \"hello\" in GCC 5.1, which means that my <code>strlen</code> is being called. Even more interesting, if I remove the <code>return</code>, i.e. replace main with just a call of <code>std::strlen(\"sdf\");</code>, nothing gets printed!</p>\n<p>I also tried Clang, for which <code>std::strlen</code> calls the real function which calculates the string length (and nothing gets printed). That's what I expected to see.</p>\n<p>How can this be explained? Is defining my own <code>strlen</code> function considered undefined behavior?</p>\n", "AcceptedAnswerId": "41746770", "Title": "Weird behavior with a manually defined strlen", "CreationDate": "2017-01-19T16:16:04.697", "Id": "41746617", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-01-21T23:31:48.043", "Score": "12", "OwnerUserId": "2604492", "Tags": "<c++><std><language-lawyer><undefined-behavior>", "AnswerCount": "3"}, "41746770": {"Id": "41746770", "PostTypeId": "2", "Body": "<p>There is nothing interesting here, just a function overload and a bit of undefined behavior. You overloaded the library function <code>strlen()</code> with your own version. Since in GCC implementation of <code>std::strlen</code> is nothing but a library function call inside namespace <code>std</code>, you get the result you are seeing.</p>\n<p>Here is relevant extract from <code>cstring</code>:</p>\n<pre><code>namespace std _GLIBCXX_VISIBILITY(default)\n{\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  using ::strlen;\n  ...\n</code></pre>\n<p>And when you remove the return statement, GCC optimizes away the call altogether, as it knows that <code>strlen</code> is function without side-effects, and it is actually a reserved name, which should not be overloaded. I assume, compiler might give you a warning here, but alas, it didn't, as it is not required to.</p>\n", "LastEditorUserId": "5245033", "LastActivityDate": "2017-01-19T16:29:55.017", "Score": "12", "CreationDate": "2017-01-19T16:23:42.353", "ParentId": "41746617", "CommentCount": "4", "OwnerUserId": "5245033", "LastEditDate": "2017-01-19T16:29:55.017"}, "41785718": {"Id": "41785718", "PostTypeId": "2", "Body": "<p>According to C++14 [extern.names]/3, <code>::strlen</code> is reserved:</p>\n<blockquote>\n<p id=\"so_41746617_41785718_0\">Each name from the Standard C library declared with external linkage is reserved to the implementation for use as a name with extern \"C\" linkage, both in namespace std and in the global namespace.</p>\n</blockquote>\n<p>and the effect of using a reserved name, [reserved.names]/2: </p>\n<blockquote>\n<p id=\"so_41746617_41785718_1\">If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by this Clause, its behavior is undefined.</p>\n</blockquote>\n<p>So your program has undefined behaviour.</p>\n", "LastActivityDate": "2017-01-21T23:31:48.043", "CommentCount": "0", "CreationDate": "2017-01-21T23:31:48.043", "ParentId": "41746617", "Score": "4", "OwnerUserId": "1505939"}, "41784872": {"Id": "41784872", "PostTypeId": "2", "Body": "<p>You defined strlen in default std namespace, thus overwriting the standard one.</p>\n<p>The reason why sometimes your strlen is called and sometimes the standard strlen is called, is probably related to the fact that many implementations of strlen are macros instead of functions. It may even be implemented in assembler.</p>\n<p>If it's a macro, the standard one will run.\nAlso, if you remove return, the function call can be removed by the optimizer. You could compare with -O0.</p>\n", "LastActivityDate": "2017-01-21T21:44:14.853", "CommentCount": "0", "CreationDate": "2017-01-21T21:44:14.853", "ParentId": "41746617", "Score": "0", "OwnerUserId": "7208919"}});