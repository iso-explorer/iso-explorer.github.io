post_cb({"bq_ids": {"n4140": {"so_13169344_13169344_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 2350}}, "n3337": {"so_13169344_13169344_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 2335}}, "n4659": {"so_13169344_13169344_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 2625}}}, "13169344": {"ViewCount": "194", "Body": "<p>From my copy of the C++ standard [\u00a727.8.2.1p4]:</p>\n<blockquote>\n<p id=\"so_13169344_13169344_0\">basic_stringbuf(basic_stringbuf&amp;&amp; rhs);</p>\n<p id=\"so_13169344_13169344_1\">Effects: Move constructs from the rvalue rhs. <strong>It is\n  implementation-defined whether the sequence pointers in *this\n  (eback(), gptr(), egptr(), pbase(), pptr(), epptr()) obtain the values\n  which rhs had</strong>. Whether they do or not, *this and rhs reference\n  separate buffers (if any at all) after the construction. The openmode,\n  locale and any other state of rhs is also copied.</p>\n</blockquote>\n<p>A similar sentence is also used for <code>basic_filebuf(basic_filebuf&amp;&amp; rhs);</code>. </p>\n<p><strong>Question</strong></p>\n<p>I was wondering why this is implementation defined? Is there a reason why you might not want to copy over the pointers?</p>\n", "AcceptedAnswerId": "13204075", "Title": "Why basic_stringbuf and basic_filebuf move constructors have implementation defined behavior?", "CreationDate": "2012-11-01T00:25:47.860", "Id": "13169344", "CommentCount": "11", "LastEditDate": "2012-11-01T00:42:03.067", "PostTypeId": "1", "LastEditorUserId": "906773", "LastActivityDate": "2012-11-02T22:48:13.253", "Score": "4", "OwnerUserId": "906773", "Tags": "<c++><c++11><iostream>", "AnswerCount": "1"}, "13204075": {"Id": "13204075", "PostTypeId": "2", "Body": "<p>There are two obvious implementation techniques to cope with the buffer in the standard stream buffers:</p>\n<ol>\n<li>You can embed the buffer into the object, creating a bigger footprint for the object but avoiding a memory allocation for small strings or files.</li>\n<li>You can point to a buffer allocated on the heap and dealing with a potentially large buffer at the cost of a memory allocation.</li>\n</ol>\n<p>Depending on the implementation choice of where the buffer lives you'll want a new set of pointer values or you'll want to carry over the pointers as is is. Neither strategy is \"better\" and I can imagine variations combining the strategies as well. So, instead of making a choice implementations can choose. If your question is why the implementation is supposed to [forget to] document the choice it made: That is distinctly beyond me. My personal guess is that it was assumed that the phase \"is implementation defined\" would provide the freedom of choice and it was ignored that the implications is that the implementation needs to state its choice (since there was a debate about quotes: 1.3.10 [defns.impl.defined] - oddly without a paragraph number).</p>\n", "LastActivityDate": "2012-11-02T22:48:13.253", "Score": "2", "CreationDate": "2012-11-02T22:48:13.253", "ParentId": "13169344", "CommentCount": "2", "OwnerUserId": "1120273"}});