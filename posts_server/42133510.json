post_cb({"bq_ids": {"n4140": {"so_42133510_42133592_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 4341}, "so_42133510_42133592_0": {"length": 7, "quality": 0.875, "section_id": 4321}}, "n3337": {"so_42133510_42133592_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 4182}, "so_42133510_42133592_0": {"length": 6, "quality": 0.75, "section_id": 4162}}, "n4659": {"so_42133510_42133592_1": {"length": 21, "quality": 0.7777777777777778, "section_id": 5598}, "so_42133510_42133592_0": {"length": 7, "quality": 0.875, "section_id": 5578}}}, "42133592": {"Id": "42133592", "PostTypeId": "2", "Body": "<p>I think it's all perfectly safe. When you call the <code>f()</code> function on <code>foo</code>, the move assignment operator of <code>class Foo</code> will invoke <code>std::unique_ptr&lt;Foo&gt;::operator=(std::unique_ptr&lt;Foo&gt;&amp;&amp;)</code>. Now, the C++14 standard, \u00a720.8.1.2.3, comma 2, says:</p>\n<blockquote>\n<p id=\"so_42133510_42133592_0\"><em>Effects:</em> Transfers ownership from <code>u</code> to <code>*this</code> as if by calling <code>reset(u.release())</code> followed by <code>get_deleter() = std::forward&lt;D&gt;(u.get_deleter())</code>.</p>\n</blockquote>\n<p>At \u00a720.8.1.2.5, comma 4, we find the behavior of <code>reset()</code>:</p>\n<blockquote>\n<p id=\"so_42133510_42133592_1\"><em>Effects:</em> assigns <code>p</code> to the stored pointer, and then if the old value of the stored pointer, <code>old_p</code>, was not equal to <code>nullptr</code>, calls <code>get_deleter()(old_p)</code>. [ Note: The order of these operations is significant because the call to <code>get_deleter()</code> may destroy <code>*this</code>. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So, we can argue that the <em>stored pointer</em> will be replaced and <strong>then</strong> the  <em>old stored pointer</em> will be deleted, in this order. Thus, everything is fine and well defined.</p>\n<p>Furthermore, when you will <em>enter</em> into the <code>reset()</code> function, the <code>*foo.next</code> object will already have been <code>release()</code>d, so the pointed object wouldn't be destroyed with it.</p>\n", "LastEditorUserId": "2508150", "LastActivityDate": "2017-02-09T10:13:23.250", "Score": "7", "CreationDate": "2017-02-09T10:04:01.190", "ParentId": "42133510", "CommentCount": "0", "OwnerUserId": "2508150", "LastEditDate": "2017-02-09T10:13:23.250"}, "42133510": {"ViewCount": "282", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;memory&gt;\n\nstruct Foo { std::unique_ptr&lt;Foo&gt; next; };\nvoid f(Foo &amp;foo) { foo = std::move(*foo.next); }\n\nint main() {\n    Foo foo{};\n    foo.next = std::make_unique&lt;Foo&gt;();\n    foo.next-&gt;next = std::make_unique&lt;Foo&gt;();\n    f(foo);\n}\n</code></pre>\n<p>By doing <code>foo = std::move(*foo.next);</code>, <code>foo.next.next</code> is moved to <code>foo.next</code>.<br>\nIf <code>foo.next</code> is invalidated as a first step, the object to which it points could be deleted immediately. This would lead to the deletion of <code>foo.next.next</code>, that is the object that I'm trying to move to <code>foo.next</code>.<br>\nI'm pretty sure I'm missing something in my reasoning, but I can't figure out what's wrong.<br>\nIs it a safe operation? Where does the standard reassure me about that?</br></br></br></p>\n", "AcceptedAnswerId": "42133592", "Title": "About safe operations involving unique pointers", "CreationDate": "2017-02-09T09:59:57.100", "Id": "42133510", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-02-09T10:13:23.250", "Score": "11", "OwnerUserId": "4987285", "Tags": "<c++><c++14><unique-ptr>", "AnswerCount": "1"}});