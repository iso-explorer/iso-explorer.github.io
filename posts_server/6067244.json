post_cb({"6067244": {"ViewCount": "14197", "Body": "<p>As mentioned in the title, I would like to know about the type of <code>'this'</code> pointer. </p>\n<p>I'm working on a project and I observed that the type of <code>'this'</code> pointer is <code>\"ClassName * const this\"</code> on windows using VC++ 2008. Well I would want to know what is the need/requirement to make the this pointer a constant pointer. Thanks.</p>\n", "AcceptedAnswerId": "6067267", "Title": "Type of 'this' pointer", "CreationDate": "2011-05-20T03:44:59.073", "Id": "6067244", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-07-10T17:07:30.890", "Score": "27", "OwnerUserId": "573709", "Tags": "<c++><class><this-pointer>", "AnswerCount": "4"}, "21985364": {"Id": "21985364", "PostTypeId": "2", "Body": "<p>There were a lot of discussions above and main post didn't present correct answer.\nPeople might not dig comments so its better to share as main port (PS).</p>\n<p>I did some investigation on Ubuntu as well as on VC++ but there is no correct output (using <code>typeid(X).name</code> ).</p>\n<hr>\n<p>The type of this pointer for a member function of a class type X, is X* const. If the member function is declared with the const qualifier, the type of the this pointer for that member function for class X, is const X* const.\n<a href=\"http://msdn.microsoft.com/en-us/library/ytk2ae82.aspx\" rel=\"nofollow\">MSDN link</a></p>\n<hr>\n<p>Conceptually this is correct also, for normal member function is \"X* const\" that's why it isn't l-value (as you can't change its contents).</p>\n</hr></hr>", "LastEditorUserId": "2039736", "LastActivityDate": "2014-02-24T11:01:50.640", "Score": "0", "CreationDate": "2014-02-24T10:39:47.813", "ParentId": "6067244", "CommentCount": "0", "OwnerUserId": "3088404", "LastEditDate": "2014-02-24T11:01:50.640"}, "bq_ids": {"n4140": {"so_6067244_6067267_1": {"length": 49, "quality": 0.9245283018867925, "section_id": 5895}}, "n3337": {"so_6067244_6067267_1": {"length": 37, "quality": 0.6981132075471698, "section_id": 5666}}, "n4659": {"so_6067244_6067267_1": {"length": 48, "quality": 0.9056603773584906, "section_id": 7378}}}, "6067263": {"Id": "6067263", "PostTypeId": "2", "Body": "<p>The const means you cannot change what the pointer points to.</p>\n<pre><code>ClassName *const\n</code></pre>\n<p>is much different from</p>\n<pre><code>const ClassName *\n</code></pre>\n<p>The latter is a pointer to an object and the object cannot be modified (using the pointer, anyway).  The former is a pointer which cannot be re-pointed to another object (nor NULL), at least without resorting to nasty casting.</p>\n<p>There is of course also the combination:</p>\n<pre><code>const ClassName *const\n</code></pre>\n<p>This would be a pointer which cannot be changed to point to something else, nor can it be used to change the object it points to.</p>\n<p>As for why your compiler shows <code>this</code> pointers as being const, it does make sense that you are discouraged from making <code>this</code> point to an object other than the one it began with.</p>\n", "LastActivityDate": "2011-05-20T03:49:02.430", "CommentCount": "3", "CreationDate": "2011-05-20T03:49:02.430", "ParentId": "6067244", "Score": "3", "OwnerUserId": "4323"}, "6067267": {"Id": "6067267", "PostTypeId": "2", "Body": "<p>The type of this pointer is either <code>ClassName *</code> or <code>const ClassName *</code>, depending on whether it is inspected inside a non-const or const method of the class <code>ClassName</code>. Pointer <code>this</code> is not an lvalue.</p>\n<pre><code>class ClassName {\n  void foo() {\n    // here `this` has `ClassName *` type\n  }\n\n  void bar() const {\n    // here `this` has `const ClassName *` type\n  }\n};\n</code></pre>\n<p>The observation you mentioned above is misleading. Pointer <code>this</code> is <em>not an lvalue</em>, which means that it cannot possibly have <code>ClassName * const</code> type, i.e. it cannot possible have a <code>const</code> to the right of the <code>*</code>. Non-lvalues of pointer type cannot be const or non-const. There's simply no such concept in C++ language. What you observed must be an internal quirk of the specific compiler. Formally, it is incorrect.</p>\n<p>Here are the relevant quotes from the language specification (emphasis mine)</p>\n<blockquote>\n<p id=\"so_6067244_6067267_0\"><strong>9.3.2 The this pointer</strong></p>\n<p id=\"so_6067244_6067267_1\">In the body of a non-static (9.3) member function, the keyword this is\n  a prvalue expression whose value is the address of the object for\n  which the function is called. <strong>The type of this in a member function of\n  a class X is X*. If the member function is declared const, the type of\n  this is const X*, if the member function is declared volatile, the\n  type of this is volatile X*, and if the member function is declared\n  const volatile, the type of this is const volatile X*.</strong> [ Note: thus in\n  a const member function, the object for which the function is called\n  is accessed through a const access path. \u2014end note ]</p>\n</blockquote>\n<hr>\n<p>It is worth nothing that back in the C++98/C++03 times several compilers used an internal implementational trick: they interpreted their <code>this</code> pointers as constant pointers, e.g. <code>ClassName *const</code> in a non-constant method of class <code>ClassName</code>. This apparently helped them to ensure non-modifiablity of <code>this</code>. GCC and MSVC are known to have used the technique. It was a harmless trick, since at language level <code>this</code> was not an lvalue and its constness was undetectable. That extra <code>const</code> would generally reveal itself only in diagnostic messages issued by the compiler.</p>\n<p>However, with the advent of rvalue references in C++11 it became possible to detect this extra <code>const</code> on the type of <code>this</code>. For example, the following code is valid in C++11</p>\n<pre><code>struct S\n{\n  void foo() { S *&amp;&amp;r = this; }\n};\n</code></pre>\n<p>Yet it will typically fail to compile in implementations that still use the aforementioned trick. GCC has since abandoned the technique. MSVC++ still uses it (as of VS2017), which prevents the above perfectly valid code from compiling in MSVC++.</p>\n</hr>", "LastEditorUserId": "187690", "LastActivityDate": "2017-07-10T17:07:30.890", "Score": "43", "CreationDate": "2011-05-20T03:49:16.207", "ParentId": "6067244", "CommentCount": "12", "OwnerUserId": "187690", "LastEditDate": "2017-07-10T17:07:30.890"}, "6148850": {"Id": "6148850", "PostTypeId": "2", "Body": "<p>An excerpt from C++ Primer 4th ed: \"In an ordinary <code>nonconst</code> member function, the type of <code>this</code> is a <code>const pointer</code> to the <code>class</code> type. We may change the value to which <code>this</code> points but cannot change the address that <code>this</code> holds. In a <code>const</code> member function, the type of <code>this</code> is a <code>const pointer</code> to a <code>const class</code> - type object. We may change neither the object to which <code>this</code> points nor the address that <code>this</code> holds.\" This means whatever VC++ intellisense was displaying is correct. </p>\n", "LastActivityDate": "2011-05-27T06:56:50.800", "CommentCount": "2", "CreationDate": "2011-05-27T06:56:50.800", "ParentId": "6067244", "Score": "-3", "OwnerUserId": "573709"}});