post_cb({"bq_ids": {"n4140": {"so_25921786_25921843_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 7213}, "so_25921786_25921843_0": {"length": 14, "quality": 1.0, "section_id": 7213}}, "n3337": {"so_25921786_25921843_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 6957}, "so_25921786_25921843_0": {"length": 14, "quality": 1.0, "section_id": 6957}}, "n4659": {"so_25921786_25921843_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 8722}, "so_25921786_25921843_0": {"length": 14, "quality": 1.0, "section_id": 8722}}}, "25921786": {"ViewCount": "1307", "Body": "<p>Working on an assignment for class, I ran into this (notice the conditional of the loop)</p>\n<pre><code>// This one works.\nfor (int k = 0; k + negwords[j].length() &lt; comments[i].length(); k++) {\n    if (comments[i].substr(k, negwords[j].length()) == negwords[j]) {\n        negativeScore++;\n    }\n}\n//*/\n\n/*/ This one doesn't: It fails with an out-of-bounds index.\nfor (int k = 0; k &lt; comments[i].length() - negwords[j].length(); k++) {\n    if (comments[i].substr(k, negwords[j].length()) == negwords[j]) {\n        negativeScore++;\n    }\n}\n//*/\n</code></pre>\n<p>Why is it that the first one works but the second one doesn't? Is it something about order of operations, bool coercion to int, operator associativity, or an OBOE?</p>\n", "AcceptedAnswerId": "25921843", "Title": "C++ appears to violate properties of addition", "CreationDate": "2014-09-18T20:30:52.160", "Id": "25921786", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-19T01:28:38.720", "Score": "12", "OwnerUserId": "948176", "Tags": "<c++>", "AnswerCount": "1"}, "25921843": {"Id": "25921843", "PostTypeId": "2", "Body": "<p>If either <code>negwords[j].length()</code> or <code>comments[i].length()</code> return an unsigned integral type at least as large as <code>unsigned int</code>, then <code>k</code> will be promoted to the same unsigned type, and <strong>the rules of modular addition will apply</strong>.</p>\n<p>As an example, this means that <code>1 &lt; 2 - 3</code> is true, because <code>2 - 3</code> wraps around in modular arithmetic, becoming a very large number.</p>\n<p>If you're interested, this behavior is specified in section 3.9.1 of the Standard, which includes the rule:</p>\n<blockquote>\n<p id=\"so_25921786_25921843_0\">Unsigned integers shall obey the laws of arithmetic modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>And a footnote concerning the implications:</p>\n<blockquote>\n<p id=\"so_25921786_25921843_1\"><sup>48</sup> This  implies  that  unsigned  arithmetic  does  not  overflow  because  a  result  that  cannot  be  represented  by  the  resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n<hr>\n<p><strike>Mathematicians know this type of arithmetic as <em>the algebra of Galois fields</em></strike>.  In C++, it's used for unsigned integral types.  Other types don't use modular arithmetic, but they also don't use normal grade-school arithmetic (formally, <em>the algebra of real numbers</em>), because normal arithmetic requires a dense uncountable set of numbers, and <strong>a computer of finite size can't represent members of an infinite set.</strong></p>\n<p>Thanks to Oliver for pointing out my mistake.  GF(2)^n does govern the bitwise operations and a whole bunch of other common calculations done in computer software, such as CRC.  But it doesn't describe unsigned arithmetic of more than 1 bit, since polynomials on Galois fields don't \"carry\".</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2014-09-19T01:28:38.720", "Score": "33", "CreationDate": "2014-09-18T20:34:48.290", "ParentId": "25921786", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2014-09-19T01:28:38.720"}});