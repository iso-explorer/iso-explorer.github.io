post_cb({"30196790": {"CommentCount": "2", "AcceptedAnswerId": "30197397", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-12T16:39:43.147", "LastActivityDate": "2015-05-12T23:43:32.613", "LastEditDate": "2017-05-23T10:26:52.370", "ViewCount": "320", "FavoriteCount": "0", "Title": "Why does std::shared_ptr<T> = std::unique_ptr<T[]> compile, while std::shared_ptr<T[]> = std::unique_ptr<T[]> does not?", "Id": "30196790", "Score": "7", "Body": "<p>I explored this topic in Coliru with the following input command:</p>\n<pre><code>g++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>The test can be found <a href=\"http://coliru.stacked-crooked.com/a/df3c10d6983512f4\" rel=\"nofollow noreferrer\" title=\"Coliru\">here</a>, but I have posted the code below. I used <code>int</code> in my example, as it's a basic type.</p>\n<hr>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nstruct Foo{\n    Foo() :\n    a_{0}, b_{1}, c_{-1}, combination_{0.5} {}\n\n    int\n        a_,\n        b_,\n        c_;\n    double\n        combination_;\n};\n\nint main()\n{\n    //int\n    //    *unManagedArray = new int[16];\n    std::unique_ptr&lt;int[]&gt;\n        uniqueArrayOrigin = std::make_unique&lt;int[]&gt;(16);\n    std::shared_ptr&lt;int&gt;\n            // works but needs call to new\n    //  sharedSingleTest{unManagedArray, std::default_delete&lt;int[]&gt;{}}; \n            // works, does not require call to new\n        sharedSingleUnique = std::make_unique&lt;int[]&gt;(16);       \n            // compilation error (conversion to non-scalar type)\n    //  sharedSingleDerived = uniqueArrayOrigin;                \n\n    //  std::shared_ptr&lt;int[]&gt;\n                // compilation errors\n    //      sharedArrayTest{unManagedArray, std::default_delete&lt;int[]&gt;{}};\n                // compilation error (conversion to non-scalar type)\n    //      sharedArrayUnique = std::make_unique&lt;int[]&gt;(16);\n                // compilation error (conversion to non-scalar type)\n    //      sharedArrayDerived = uniqueArrayOrigin;\n\n    std::shared_ptr&lt;Foo&gt;\n            // works: specified overload of operator= for shared_ptr\n        nonArrayTest = std::make_unique&lt;Foo&gt;(); \n\n    std::cout &lt;&lt; \"done!\\n\";\n}\n</code></pre>\n<hr>\n<p>I have looked around on SO for answers, but only turned up <a href=\"https://stackoverflow.com/questions/8947579/why-isnt-there-a-stdshared-ptrt-specialisation?lq=1\">references</a> to the implementation of <code>std::shared_ptr</code> not having a specialization, and that this largely was because no one bothered to give a proper proposal to the standards committee on the subject.</p>\n<p>I am curious, because I would interpret 4th overload of <code>operator=</code>, <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/operator%3D\" rel=\"nofollow noreferrer\"><code>std::shared_ptr&lt;T[]&gt;.operator=(std::unique_ptr&lt;T[], Deleter&gt;&amp;&amp;)</code></a> on cppreference to indicate that such syntax is legal-- <code>T[]</code> and <code>T[]</code> are the same type regardless of the state of specializations for array types for <code>std::shared_ptr</code>, after all.  </p>\n<p>Furthermore, this syntax only appears to work on the product of <code>std::make_unique&lt;T[]&gt;</code>, and not a unique pointer object, which goes against my understanding of the topic--shouldn't the calls be effectively the same, though one moves an existing object, and the other, well, moves an object that's just been created? I would expect the only difference between them would be the invalid <code>std::unique_ptr&lt;T[]&gt;</code> after the function call in the first case.  </p>\n<p>As a side note, I assume that since there is a way of constructing a dynamically-allocated array into a <code>shared_ptr</code> that does not require the use of <code>new</code>, I should prefer it to the messier and exception-unsafe call to <code>new T[N]</code>?</p>\n<p>tl;dr:</p>\n<ol>\n<li><code>operator=</code> does not work at all between <code>std::shared_ptr&lt;T[]&gt;</code> and <code>std::unique_ptr&lt;T[]&gt;</code> though I would expect it to work. Why?</li>\n<li>If anything, I would expect the type conversion from <code>T[]</code> to <code>T</code> to be a source of compilation errors between the unique and shared pointers. Why does this work?</li>\n<li><code>operator=</code> works between <code>std::shared_ptr&lt;T&gt;</code> and <code>std::make_unique&lt;T[]&gt;</code> but not <code>std::unique_ptr&lt;T[]&gt;</code>. Why?</li>\n<li>am I correct to assume in cases which require a dynamically allocated, shared array, but where I don't want to use either boost or a vector (reasons below) I should call <code>operator= std::make_unique&lt;T[]&gt;(N)</code>?</li>\n</ol>\n<p>Why aren't I using?</p>\n<ul>\n<li><strong>Boost</strong>: is not approved for use yet in my company, and I do not know when or if I will get approval to use it.</li>\n<li><strong>Arrays</strong>: I have to determine the size of this array at runtime.</li>\n<li><strong>Vectors</strong>: I'm working on a real-time signal processing system, and would prefer to avoid the extra pointer dereference. I was also attempting to avoid including extraneous libraries in my header files (this was for communications between reading and writing subsystems) However, I eventually chose to optimize this later, if it matters (premature optimization...) and bite the bullet. The question remains, though.</li>\n</ul>\n</hr></hr>", "Tags": "<c++><stl><g++><c++14>", "OwnerUserId": "4892076", "AnswerCount": "1"}, "30197397": {"ParentId": "30196790", "CommentCount": "10", "Body": "<p>\u00a720.8.2.2.1/28:</p>\n<blockquote>\n<pre><code>template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r); \n</code></pre>\n<p id=\"so_30196790_30197397_0\"><strong>Remark</strong>: This constructor shall not participate in overload resolution\n  unless <code>unique_ptr&lt;Y, D&gt;::pointer</code> is convertible to <code>T*</code>.</p>\n</blockquote>\n<p>However, <code>unique_ptr&lt;U[]&gt;::pointer</code> is actually <code>U*</code>, while <code>shared_ptr&lt;U[]&gt;</code>'s <code>T*</code> is <code>U(*)[]</code>; And <code>U*</code> cannot be converted to <code>U(*)[]</code>, hence the overload is never considered.</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "30197397", "Score": "5", "CreationDate": "2015-05-12T17:12:03.123", "LastActivityDate": "2015-05-12T17:12:03.123"}, "bq_ids": {"n4140": {"so_30196790_30197397_0": {"section_id": 3525, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_30196790_30197397_0": {"section_id": 3390, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_30196790_30197397_0": {"section_id": 5669, "quality": 0.7777777777777778, "length": 7}}}});