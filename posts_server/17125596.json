post_cb({"17125650": {"ParentId": "17125596", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_17125596_17125650_0\">Why do I need to add A(...) in D's initializer list?</p>\n</blockquote>\n<p>That's because virtual base subobjects must be initialized before all other subobjects. Since <code>A</code> does not have a default constructor, you need to initialize the virtual <code>A</code> subobject in <code>D</code> explicitly and specify which argument you want it to be constructed with.</p>\n<p>When the constructors of the <code>B</code> and <code>C</code> base subobjects are executed, they won't have a base <code>A</code> subobject to initialize (that has been done before already). Therefore, the arguments they pass to <code>A</code>'s constructor are irrelevant.</p>\n<blockquote>\n<p id=\"so_17125596_17125650_1\"><code>D(int x):B(x++), C(x++), A(x++){}</code> and <code>D(int x):A(x++), B(x++), C(x++){}</code> both give the same result with <code>cout&lt;&lt;D(10).x</code>, why?</p>\n</blockquote>\n<p>As explained above, that's because virtual base subobjects are initialized first anyway.</p>\n<p>In general, the order of initialization of a class's subobjects never depends on the order in which they appear in your constructor's initialization list. Per paragraph 12.6.2/10 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17125596_17125650_2\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<p id=\"so_17125596_17125650_3\">\u2014 <strong>First</strong>, and only for the constructor of the most derived class (1.8), <strong>virtual base classes are initialized in\n  the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes</strong>,\n  where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</p>\n<p id=\"so_17125596_17125650_4\">\u2014 Then, direct base classes are initialized <em>in declaration order as they appear in the base-specifier-list</em>\n  (regardless of the order of the <em>mem-initializers</em>).</p>\n<p id=\"so_17125596_17125650_5\">\u2014 Then, non-static data members are initialized <em>in the order they were declared in the class definition</em>\n  (again regardless of the order of the <em>mem-initializers</em>).</p>\n<p id=\"so_17125596_17125650_6\">\u2014 Finally, the compound-statement of the constructor body is executed.</p>\n</blockquote>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-06-15T16:38:53.800", "Id": "17125650", "Score": "6", "CreationDate": "2013-06-15T16:25:58.490", "LastActivityDate": "2013-06-15T16:38:53.800"}, "17125646": {"ParentId": "17125596", "CommentCount": "0", "Body": "<p>Virtual base classes are only initialised by the most-derived class. That is, if create an instance of <code>D</code> in your example, <code>A</code> will only be initialised by its occurence in the mem-initialiser list of <code>D</code>. Its occurence in the mem-initialiser lists of <code>B</code> and <code>C</code> is simply ignored.</p>\n<p>That is also why you have to initialise <code>A</code> in <code>D</code>: <code>A</code> doesn't have a default ctor, so <code>D</code> must know how to initialise it.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "17125646", "Score": "1", "CreationDate": "2013-06-15T16:25:36.837", "LastActivityDate": "2013-06-15T16:25:36.837"}, "bq_ids": {"n4140": {"so_17125596_17125650_5": {"section_id": 438, "quality": 1.0, "length": 15}, "so_17125596_17125650_2": {"section_id": 438, "quality": 1.0, "length": 6}, "so_17125596_17125650_4": {"section_id": 438, "quality": 1.0, "length": 13}, "so_17125596_17125650_6": {"section_id": 438, "quality": 1.0, "length": 5}, "so_17125596_17125650_3": {"section_id": 438, "quality": 1.0, "length": 29}}, "n3337": {"so_17125596_17125650_5": {"section_id": 429, "quality": 1.0, "length": 15}, "so_17125596_17125650_2": {"section_id": 429, "quality": 1.0, "length": 6}, "so_17125596_17125650_4": {"section_id": 429, "quality": 1.0, "length": 13}, "so_17125596_17125650_6": {"section_id": 429, "quality": 1.0, "length": 5}, "so_17125596_17125650_3": {"section_id": 429, "quality": 1.0, "length": 29}}, "n4659": {"so_17125596_17125650_2": {"section_id": 458, "quality": 1.0, "length": 6}, "so_17125596_17125650_3": {"section_id": 458, "quality": 1.0, "length": 29}, "so_17125596_17125650_4": {"section_id": 458, "quality": 1.0, "length": 13}, "so_17125596_17125650_5": {"section_id": 458, "quality": 1.0, "length": 15}, "so_17125596_17125650_6": {"section_id": 458, "quality": 1.0, "length": 5}}}, "17125596": {"CommentCount": "0", "AcceptedAnswerId": "17125650", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2013-06-15T16:19:19.897", "LastActivityDate": "2013-06-16T07:19:33.360", "LastEditDate": "2013-06-16T07:19:33.360", "ViewCount": "1279", "FavoriteCount": "1", "Title": "C++ virtual inheritance initializer list", "Id": "17125596", "Score": "7", "Body": "<p>in the following code:</p>\n<pre><code>class A\n{\npublic:\n    int x;\n    A(int x):x(x){}\n};\n\nclass B: public virtual A\n{\npublic:\n    B(int x):A(x){}\n};\nclass C: public virtual A\n{\npublic:\n    C(int x):A(x){}\n};\nclass D: public B, public C\n{\npublic:\n    D(int x):B(x++), C(x++), A(x++){}\n};\n</code></pre>\n<p>two questions: </p>\n<ol>\n<li>Why do I need to add <code>A(...)</code> in D's initializer list?</li>\n<li><code>D(int x):B(x++), C(x++), A(x++){}</code> and <code>D(int x):A(x++), B(x++), C(x++){}</code> both give the same result with <code>cout&lt;&lt;D(10).x</code>, why?</li>\n</ol>\n", "Tags": "<c++><inheritance><constructor><multiple-inheritance><virtual-inheritance>", "OwnerUserId": "459384", "AnswerCount": "2"}});