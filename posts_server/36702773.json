post_cb({"36708283": {"ParentId": "36702773", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_36702773_36708283_0\">Why are types mapped correctly for classes inheriting from <code>BaseVirtual</code></p>\n</blockquote>\n<p>Because the C++ standard says they should:</p>\n<blockquote>\n<p id=\"so_36702773_36708283_1\"><strong>[expr.typeid]/2</strong> When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers to a <code>std::type_info</code> object representing the type of the most derived object (1.8) (that is, the dynamic type) to which the glvalue refers.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_36702773_36708283_2\">How does the compiler do it and how expensive is it?</p>\n</blockquote>\n<p>Irrelevant implementation details. One way is to add a pointer to <code>type_info</code>, or something substantially similar, to the vtable.</p>\n<hr>\n<blockquote>\n<p id=\"so_36702773_36708283_3\">Is it portable?</p>\n</blockquote>\n<p>Yes it is. Again, the behavior you observe is mandated by the C++ standard.</p>\n</hr></hr>", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "36708283", "Score": "1", "CreationDate": "2016-04-19T03:58:10.940", "LastActivityDate": "2016-04-19T03:58:10.940"}, "36702773": {"CommentCount": "2", "ViewCount": "88", "CreationDate": "2016-04-18T19:31:04.463", "LastActivityDate": "2016-04-19T03:58:10.940", "Title": "Resolving types in a hierarchy of classes using std::type_index", "AcceptedAnswerId": "36708283", "PostTypeId": "1", "Id": "36702773", "Score": "0", "Body": "<p>I was looking for an alternative to the <code>Visitor</code> pattern to map behaviour for types in a hierarchy of classes and maybe allow for multiple dispatch. Any time you add a new type to a hierarchy of classes, you have to update all the supporting visitors. So I came across <code>std::type_index</code>, which according to <a href=\"http://en.cppreference.com/w/cpp/types/type_index\" rel=\"nofollow\">cppreference.com</a> might do the trick. I then thought, now I have to implement a <code>get_type_index</code> for every subclass, which would be related to the <code>accept</code> method of the visitor pattern. This would then only be half of the work that\nhas to be done for the <code>Visitor</code> pattern. But then I saw that apparently you only have to implement a (non pure) virtual function in the base class to make the whole thing work. Below is my <a href=\"https://github.com/ToniBig/cpp-type-index\" rel=\"nofollow\">code</a> and I have the following question(s):</p>\n<ul>\n<li>Why are types mapped correctly for classes inheriting from <code>BaseVirtual</code>?</li>\n<li>How does the compiler do it and how expensive is it?</li>\n<li>Is it portable?</li>\n</ul>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;typeindex&gt;\n\nstruct Base\n{\n  std::type_index get_type_index( ) const\n  {\n    return std::type_index( typeid(*this) );\n  }\n};\n\nstruct BaseVirtual\n{\n  virtual std::type_index get_type_index( ) const\n  {\n    return std::type_index( typeid(*this) );\n  }\n};\n\ntemplate&lt;typename BaseType&gt;\nstruct A : public BaseType\n{\n};\n\ntemplate&lt;typename BaseType&gt;\nstruct B : public BaseType\n{\n};\n\ntemplate&lt;typename BaseType&gt;\nstruct C : public BaseType\n{\n};\n\nint main( int argc,\n          char **argv )\n{\n  std::map&lt;std::type_index, std::string&gt; typeToStringMap = { { std::type_index( typeid(Base) ), \"Base\" }, { std::type_index( typeid(A&lt;Base&gt; ) ), \"ABase\" }, { std::type_index( typeid(B&lt;Base&gt; ) ), \"BBase\" }, { std::type_index( typeid(C&lt;Base&gt; ) ), \"CBase\" }, { std::type_index( typeid(BaseVirtual) ),\n      \"BaseVirtual\" }, { std::type_index( typeid(A&lt;BaseVirtual&gt; ) ), \"ABaseVirtual\" }, { std::type_index( typeid(B&lt;BaseVirtual&gt; ) ), \"BBaseVirtual\" }, { std::type_index( typeid(C&lt;BaseVirtual&gt; ) ), \"CBaseVirtual\" } };\n\n  A&lt;Base&gt; a;\n  B&lt;Base&gt; b;\n  C&lt;Base&gt; c;\n\n  A&lt;BaseVirtual&gt; av;\n  B&lt;BaseVirtual&gt; bv;\n  C&lt;BaseVirtual&gt; cv;\n\n  auto asp = std::make_shared&lt;A&lt;Base&gt;&gt;( );\n  auto bsp = std::make_shared&lt;B&lt;Base&gt;&gt;( );\n  auto csp = std::make_shared&lt;C&lt;Base&gt;&gt;( );\n\n  auto avsp = std::make_shared&lt;A&lt;BaseVirtual&gt;&gt;( );\n  auto bvsp = std::make_shared&lt;B&lt;BaseVirtual&gt;&gt;( );\n  auto cvsp = std::make_shared&lt;C&lt;BaseVirtual&gt;&gt;( );\n\n  A&lt;Base&gt;* ap = new A&lt;Base&gt;;\n  B&lt;Base&gt;* bp = new B&lt;Base&gt;;\n  C&lt;Base&gt;* cp = new C&lt;Base&gt;;\n\n  A&lt;BaseVirtual&gt;* avp = new A&lt;BaseVirtual&gt;;\n  B&lt;BaseVirtual&gt;* bvp = new B&lt;BaseVirtual&gt;;\n  C&lt;BaseVirtual&gt;* cvp = new C&lt;BaseVirtual&gt;;\n\n  std::cout &lt;&lt; typeToStringMap[a.get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[b.get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[c.get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[av.get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[bv.get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[cv.get_type_index( )] &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; typeToStringMap[asp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[bsp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[csp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[avsp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[bvsp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[cvsp-&gt;get_type_index( )] &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; typeToStringMap[ap-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[bp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[cp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[avp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[bvp-&gt;get_type_index( )] &lt;&lt; std::endl;\n  std::cout &lt;&lt; typeToStringMap[cvp-&gt;get_type_index( )] &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>Base\nBase\nBase\nABaseVirtual\nBBaseVirtual\nCBaseVirtual\nBase\nBase\nBase\nABaseVirtual\nBBaseVirtual\nCBaseVirtual\nBase\nBase\nBase\nABaseVirtual\nBBaseVirtual\nCBaseVirtual\n</code></pre>\n", "Tags": "<c++11><inheritance><types>", "OwnerUserId": "964590", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36702773_36708283_1": {"section_id": 6021, "quality": 0.92, "length": 23}}, "n3337": {"so_36702773_36708283_1": {"section_id": 5789, "quality": 0.92, "length": 23}}, "n4659": {"so_36702773_36708283_1": {"section_id": 7520, "quality": 0.92, "length": 23}}}});