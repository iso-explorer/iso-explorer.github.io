post_cb({"38563098": {"Id": "38563098", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38562865_38563098_0\">why is the <code>&lt;T&gt;</code> present after <code>==</code>? Clearly the <code>&lt;T&gt;</code> following <code>operator==</code> is necessary, but why?</p>\n</blockquote>\n<p>Because <code>operator==</code> in friend declaration refers to the function template, you have to specify it explicity. Otherwise a non-template function will be declared, but the definition of it can't be found later. It's not the same sceen as invoking (and instantiation) of function template.</p>\n<p>Note <code>T</code> could be omitted but <code>&lt;&gt;</code> is still needed. Such as:</p>\n<pre><code>// refers to a full specialization of operator==\nfriend bool operator== &lt;&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n</code></pre>\n<p>Another candidate way is to <strong>define</strong> the operator inside the class declaration, which will be inline and could be declared as non-template function. Such as:</p>\n<pre><code>template &lt;typename T&gt; class Blob {\n   ...\n   friend bool operator==(const Blob&amp;, const Blob&amp;) { \n       return ...;\n   }\n}\n</code></pre>\n<blockquote>\n<p id=\"so_38562865_38563098_1\">This produces a compilation error around <code>operator&lt;&lt;T&gt;</code></p>\n</blockquote>\n<p>Yes as you said, it should be written as <code>friend bool operator&lt; &lt;T&gt;(...)</code>, or <code>friend bool operator&lt; &lt;&gt;(...)</code>, or see my suggestion about non-template function friend.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-07-25T09:02:50.100", "Score": "2", "CreationDate": "2016-07-25T08:38:42.313", "ParentId": "38562865", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2016-07-25T09:02:50.100"}, "38563405": {"Id": "38563405", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38562865_38563405_0\"><strong>First question:</strong> in the line</p>\n<pre><code>friend bool operator==&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n</code></pre>\n<p id=\"so_38562865_38563405_1\">why is the <code>&lt;T&gt;</code> present after <code>==</code>? Why not simply write</p>\n<pre><code>friend bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n</code></pre>\n</blockquote>\n<p>If you remove the <code>&lt;T&gt;</code>, gcc gives a warning:</p>\n<blockquote>\n<p id=\"so_38562865_38563405_2\">warning: friend declaration '<code>bool operator==(const Blob&lt; &lt;template-parameter-1-1&gt; &gt;&amp;, const Blob&lt; &lt;template-parameter-1-1&gt; &gt;&amp;)</code>' declares a non-template function [-Wnon-template-friend]</p>\n</blockquote>\n<p>Your are making a non-templated function a friend of your class, so the compiler/linker will be looking for a non-templated function, in your case:</p>\n<pre><code>bool operator==(const Blob&lt;int&gt;&amp;, const Blob&lt;int&gt;&amp;);\n</code></pre>\n<p>...which does not exist, thus the linker cannot find it.</p>\n<p>If you do not add <code>&lt;T&gt;</code> (or <code>&lt;&gt;</code> to the <code>friend</code> declaration), you have to define a function for each type, which is probably not what you want.</p>\n<blockquote>\n<p id=\"so_38562865_38563405_3\"><strong>Second question:</strong> If I want to define the relational less than operator &lt; for the same class, I would guess that I should follow the pattern that worked for ==:</p>\n</blockquote>\n<p>This is a simple problem with the way C++ code is parsed, you need to insert a space between <code>operator&lt;</code> and <code>&lt;&lt;</code>. This is the same problem that existed prior to C++11 where you had to use <code>vector&lt;vector&lt;int&gt; &gt;</code> instead of <code>vector&lt;vector&lt;int&gt;&gt;</code> because of the <code>&gt;&gt;</code>.</p>\n", "LastActivityDate": "2016-07-25T08:54:42.253", "CommentCount": "0", "CreationDate": "2016-07-25T08:54:42.253", "ParentId": "38562865", "Score": "0", "OwnerUserId": "2666289"}, "38562865": {"ViewCount": "329", "Body": "<p>From Lippman et al C++Primer 5th edition, section 16.1.2:</p>\n<pre><code>//forward declarations needed for friend declarations in Blob\ntemplate &lt;typename&gt; class BlobPtr;\ntemplate &lt;typename&gt; class Blob;\ntemplate &lt;typename T&gt; bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;)\n\ntemplate &lt;typename T&gt; class Blob {\n   friend class BlobPtr&lt;T&gt;;\n   friend bool operator==&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n}\n</code></pre>\n<p><b>First question</b>:  in the line</p>\n<pre><code>friend bool operator==&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n</code></pre>\n<p>why is the <code>&lt;T&gt;</code> present after <code>==</code>?  Why not simply write</p>\n<pre><code>friend bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n</code></pre>\n<p>I added the following code to define operator== and to instantiate the class template.  It successfully compiles and links:</p>\n<pre><code>template &lt;typename T&gt;\nbool operator==(const Blob&lt;T&gt; &amp;lhs, const Blob&lt;T&gt; &amp;rhs) {return true;}\n\nint main() {\n    Blob&lt;int&gt; a, b;\n    a == b;\n}\n</code></pre>\n<p>If I remove the <code>&lt;T&gt;</code> following <code>operator==</code> in the friend declaration, I get a linker error:</p>\n<pre><code>Undefined symbols for architecture x86_64: \"operator==(Blob&lt;int&gt; const&amp;, Blob&lt;int&gt; const&amp;)\", referenced from: _main in partial_blob-3ccda9.o\n</code></pre>\n<p>Clearly the <code>&lt;T&gt;</code> following <code>operator==</code> is necessary, but why?</p>\n<p><b>Second question</b>: If I want to define the relational less than operator <code>&lt;</code> for the same class, I would guess that I should follow the pattern that worked for <code>==</code>: </p>\n<p>1) forward-declare the operator</p>\n<p>2) declare the operator as a friend, inserting the additional <code>&lt;T&gt;</code> whose function I don't understand</p>\n<p>3) define the operator out-of-class.</p>\n<p>I therefore add the following code:</p>\n<pre><code>template &lt;typename T&gt; bool operator&lt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\ntemplate &lt;typename T&gt; class Blob {\n   //other members as before\n   friend bool operator&lt;&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n}\nbool operator&lt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;) {return true;}\nint main() {\n   //other statements as before\n   a &lt; b;\n}\n</code></pre>\n<p>This produces a compilation error around <code>operator&lt;&lt;T&gt;</code>, I think because the compiler interprets <code>&lt;&lt;</code> as the insertion operator.  But if I rewrite the friend declaration as </p>\n<pre><code>friend bool operator&lt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);\n</code></pre>\n<p>then I get a linker error similar to the earlier linker error with <code>==</code>:</p>\n<pre><code>\"operator&lt;(Blob&lt;int&gt; const&amp;, Blob&lt;int&gt; const&amp;)\", referenced from: _main in partial_blob-a85d5d.o\n</code></pre>\n<p>How can I successfully define operator <code>&lt;</code> for this class?</p>\n<p>(Note:  the operators must be declared as friends because more fully-realized implementations rely on private variables.)</p>\n", "AcceptedAnswerId": "38579114", "Title": "Friend comparison and relational operators in C++ class template", "CreationDate": "2016-07-25T08:25:25.383", "Id": "38562865", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-07-26T00:06:57.443", "Score": "3", "OwnerUserId": "4425924", "Tags": "<c++><templates><operator-overloading><friend>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_38562865_38579114_2": {"length": 15, "quality": 1.0, "section_id": 126}, "so_38562865_38579114_1": {"length": 12, "quality": 1.0, "section_id": 126}, "so_38562865_38579114_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 126}, "so_38562865_38579114_4": {"length": 6, "quality": 1.0, "section_id": 126}, "so_38562865_38579114_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 126}}, "n3337": {"so_38562865_38579114_2": {"length": 15, "quality": 1.0, "section_id": 120}, "so_38562865_38579114_1": {"length": 12, "quality": 1.0, "section_id": 120}, "so_38562865_38579114_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 120}, "so_38562865_38579114_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 120}, "so_38562865_38579114_4": {"length": 6, "quality": 1.0, "section_id": 120}}, "n4659": {"so_38562865_38579114_2": {"length": 15, "quality": 1.0, "section_id": 131}, "so_38562865_38579114_1": {"length": 12, "quality": 1.0, "section_id": 131}, "so_38562865_38579114_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 131}, "so_38562865_38579114_4": {"length": 6, "quality": 1.0, "section_id": 131}, "so_38562865_38579114_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 131}}}, "38579114": {"Id": "38579114", "PostTypeId": "2", "Body": "<p>I am posting my own answer, acknowledging Joachim Pileborg and songyuanyao for direction.</p>\n<p>I have simplified the code to focus on Question 1 only. Pileborg and Holt correctly pointed out that overloading <code>&lt;</code> merely requires a space to help the compiler parse.</p>\n<pre><code>template &lt;typename&gt; class Blob;\ntemplate &lt;typename T&gt; bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;); //line 2\n\ntemplate &lt;typename T&gt; class Blob {\n   friend bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;); //line 5\n};\n\ntemplate &lt;typename T&gt;\nbool operator==(const Blob&lt;T&gt; &amp;lhs, const Blob&lt;T&gt; &amp;rhs) {return true;} //line 9\n\nint main() {\n    Blob&lt;int&gt; a, b; //line 12\n    a == b; //line 13\n}\n</code></pre>\n<p>This code produces an error at link time.  To understand why, we\u2019ll look at relevant language from the standard.  </p>\n<p>From the C++14 Standard n4296, 14.5.4 (See bottom for summary of terminology used here).</p>\n<blockquote>\n<p id=\"so_38562865_38579114_0\">For a friend function declaration that is not a template declaration:</p>\n<p id=\"so_38562865_38579114_1\">(1.1) \u2014 if the name of the friend is a qualified or unqualified template-id, the friend declaration refers to a specialization of a function template, otherwise,</p>\n<p id=\"so_38562865_38579114_2\">(1.2) \u2014 if the name of the friend is a qualified-id and a matching non-template function is found in the specified class or namespace, the friend declaration refers to that function, otherwise,</p>\n<p id=\"so_38562865_38579114_3\">(1.3) \u2014 if the name of the friend is a qualified-id and a matching function template is found in the specified class or namespace, the friend declaration refers to the deduced specialization of that function template (14.8.2.6), otherwise,</p>\n<p id=\"so_38562865_38579114_4\">(1.4) \u2014 the name shall be an unqualified-id that declares (or redeclares) a non-template function.</p>\n</blockquote>\n<p>Now we look at the friend declaration on line 5, determining what it refers to according to the four steps listed above. </p>\n<p>(1.1) <code>==</code> is not a template-id; move on...</p>\n<p>(1.2) <code>==</code> is not a qualified-id; move on...</p>\n<p>(1.3) <code>==</code> is not a qualified-id; move on...</p>\n<p>(1.4) therefore, <code>==</code> is an unqualified-id that declares (or redeclares) a non-template function.</p>\n<p>According to section 7.3.3 of the standard, the friend <code>==</code> is declared in the innermost enclosing namespace -- in this case, the global namespace.</p>\n<p>When we instantiate <code>Blob&lt;int&gt;</code> on line 12, the compiler generates source code by substituting <code>int</code> for all occurrences of <code>T</code> in class Blob.  The friend declaration in the compiler-generated code then reads:</p>\n<pre><code>friend bool operator==(const Blob&lt;int&gt;&amp;, const Blob&lt;int&gt;&amp;);\n</code></pre>\n<p>Thus we have declared a (non-template) overload of <code>operator==</code> in the global namespace, with parameters of type <code>const Blob&lt;int&gt;&amp;</code>.</p>\n<p>When <code>a == b</code> is called on line 12, the compiler begins the overload resolution process.  It first looks for any non-template overloads that match the argument types.  It finds a perfect match in the form of the <code>operator==</code> declared when <code>Blob&lt;int&gt;</code> was instantiated.  The linker then looks for the definition of <code>operator==</code> corresponding to the best-match declaration, but it finds none, because the <code>operator==(const Blob&lt;int&gt;&amp;, const Blob&lt;int&gt;&amp;)</code> was never actually defined!</p>\n<p>The solution is to use a template-id (which is NOT a template declaration) as the name in the friend declaration:</p>\n<pre><code>friend bool operator== &lt;&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;)\n</code></pre>\n<p>or</p>\n<pre><code>friend bool operator== &lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;)\n</code></pre>\n<p>Both <code>operator== &lt;&gt;</code> and <code>operator== &lt;T&gt;</code> are template-id\u2019s (see terminology below); the former has an implicit template parameter list deduced from the function parameter list, and the latter has an explicit template parameter list.</p>\n<p>When <code>Blob&lt;int&gt;</code> is instantiated on line 12, the compiler generates the following code for the friend declaration:</p>\n<pre><code>friend bool operator== &lt;&gt;(const Blob&lt;int&gt;&amp;, const Blob&lt;int&gt;&amp;)\n</code></pre>\n<p>or</p>\n<pre><code>friend bool operator== &lt;int&gt;(const Blob&lt;int&gt;&amp;, const Blob&lt;int&gt;&amp;)\n</code></pre>\n<p>In either case, the name of the friend is an unqualified template-id, so by (1.1) above, the friend declaration refers to a specialization of a function template.  The compiler then finds then finds a best template match for the requested <code>&lt;int&gt;</code> specialization.  The only template it finds is the template declared in line 2 and defined in line 9, which it calls, as desired.</p>\n<p><b>Terminology</b></p>\n<p>qualified-id: an identifier with an attached scoping operator, e.g. <code>std::string</code> or <code>::i</code></p>\n<p>unqualified-id: an identifier without an attached scoping operator, e.g. <code>string</code> or <code>i</code>.</p>\n<p>template-id: the following excerpt (From the C++14 Standard n4296, 14.2) summarizes the structure of template-id\u2019s:</p>\n<blockquote>\n<p id=\"so_38562865_38579114_5\">simple-template-id:</p>\n<pre><code> template-name &lt; template-argument-list (opt)&gt;\n</code></pre>\n<p id=\"so_38562865_38579114_6\">template-id:</p>\n<pre><code> simple-template-id\n\n operator-function-id &lt; template-argument-listopt &gt;\n\n literal-operator-id &lt; template-argument-listopt&gt;\n</code></pre>\n<p id=\"so_38562865_38579114_7\">template-name:</p>\n<pre><code> identifier\n</code></pre>\n</blockquote>\n<p>So some template-id\u2019s would include <code>Foo&lt;T&gt;</code> and <code>==&lt;T&gt;</code>.  (== is an operator-function-id).  Notice that, unlike in a template declaration, <code>template &lt;&gt;</code> is not included in a template-id expression.  </p>\n", "LastEditorUserId": "4425924", "LastActivityDate": "2016-07-26T00:06:57.443", "Score": "0", "CreationDate": "2016-07-25T23:56:47.833", "ParentId": "38562865", "CommentCount": "0", "OwnerUserId": "4425924", "LastEditDate": "2016-07-26T00:06:57.443"}});