post_cb({"bq_ids": {"n4140": {"so_37506417_37506786_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 6044}}, "n3337": {"so_37506417_37506786_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 5812}}, "n4659": {"so_37506417_37506786_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 7543}}}, "37506417": {"ViewCount": "127", "Body": "<p>I need to store a function reference as a char*, and later call that function with only the char*.</p>\n<p>I am looking for something like:</p>\n<pre><code>char* funcRef = (char*)myFunc;\n//...\n(void (*funcRef)())();\n</code></pre>\n<p>How do you do this? (Note: I am not asking how to call a function by reference, just if its possible to store a reference to it as a char* and then convert it back)</p>\n", "AcceptedAnswerId": "37506786", "Title": "Convert function reference to char* and back", "CreationDate": "2016-05-29T05:09:46.267", "Id": "37506417", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2016-05-29T09:24:26.887", "Score": "0", "OwnerUserId": "3019655", "Tags": "<c++><c>", "AnswerCount": "2"}, "37506786": {"Id": "37506786", "PostTypeId": "2", "Body": "<p>This conversion is not allowed. The allowable conversions are given in section <strong>6.3 Conversions</strong>, sub-subsection <strong>6.3.2.3 Pointers</strong>, of which paragraphs (6) and (8) apply to function pointers.</p>\n<blockquote id=\"so_37506417_37506786_0\">\n<ol start=\"6\">\n<li>Any pointer type may be converted to an integer type. Except as previously specified, the result is implementation-defined...</li>\n</ol>\n</blockquote>\n<p>and</p>\n<blockquote id=\"so_37506417_37506786_1\">\n<ol start=\"8\">\n<li>A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the pointed-to type, the behavior is undefined.</li>\n</ol>\n</blockquote>\n<p>Conversion between pointer to function and pointer to object is not on the allowed list; it is therefore disallowed.</p>\n<p>There are systems where pointers to functions and pointers to objects are not interchangeable. The most obvious case is where the size of a function pointer is not the same as the size of an object pointer, such as Harvard architecture, or the 8086 in Compact or Medium model.</p>\n", "LastActivityDate": "2016-05-29T06:09:20.297", "CommentCount": "5", "CreationDate": "2016-05-29T06:09:20.297", "ParentId": "37506417", "Score": "5", "OwnerUserId": "902497"}, "37508207": {"Id": "37508207", "PostTypeId": "2", "Body": "<p>The reason your code isn't working is because a <code>char*</code> pointer is not a function pointer. You cannot call a <code>char*</code> as if it was a function. You need to cast that pointer back to a function pointer prior to using it as a function pointer.</p>\n<p><strong>Note very well: Whether this will work at all is highly compiler and system dependent.</strong></p>\n<p>There is nothing in the C standard that says anything about converting a pointer to a function to a pointer to an object, or vice versa. This is undefined behavior. On the other hand, POSIX standard requires that a compliant implementation must be able to convert a pointer to void to a pointer to a function. (Note: The reverse capability is not required.)</p>\n<p>This question is also tagged as C++. Prior to C++11, converting a pointer to a function to a pointer to an object, or vice versa, was illegal. The compiler had to issue a diagnostic message. On POSIX-compliant systems, the compiler would issue a diagnostic and then generate the POSIXly-compliant object code. In C++11 and later, converting converting between pointers to functions to a pointers to an object, or vice versa, is conditionally-supported.</p>\n<p>With those caveats, the following works on my POSIX-compliant machine, with multiple compilers. Whether it works on a non-POSIX compliant machine with non-POSIX complaint compilers is anyone's guess.</p>\n<p>C++ version:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint sqr (int k) { return k*k; }\n\nint p42 (int k) { return k+42; }\n\nvoid call_callback(void* vptr, int k)\n{   \n    using Fptr = int(*)(int);\n    Fptr fun = reinterpret_cast&lt;Fptr&gt;(vptr);\n    std::cout &lt;&lt; fun(k) &lt;&lt; '\\n';\n}   \n\nint main ()\n{   \n    call_callback(reinterpret_cast&lt;void*&gt;(sqr), 2); \n    call_callback(reinterpret_cast&lt;void*&gt;(p42), 2); \n}   \n</code></pre>\n<p>C version:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint sqr (int k) { return k*k; }\n\nint p42 (int k) { return k+42; }\n\nvoid call_callback(void* vptr, int k)\n{\n    printf (\"%d\\n\", ((int(*)(int))(vptr))(k));\n}\n\nint main ()\n{\n    call_callback((void*)(sqr), 2);\n    call_callback((void*)(p42), 2);\n}\n</code></pre>\n", "LastActivityDate": "2016-05-29T09:24:26.887", "CommentCount": "0", "CreationDate": "2016-05-29T09:24:26.887", "ParentId": "37506417", "Score": "1", "OwnerUserId": "774499"}});