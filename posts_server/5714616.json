post_cb({"5714664": {"ParentId": "5714616", "CommentCount": "0", "Body": "<p>This is normal C++. The <em>scope</em> of <code>struct Object</code> is only the function <code>func</code>. However, you can still use objects of this type without knowing which concrete type they are, since they inherit from <code>IBase</code>. This is used to encapsulate implementation.</p>\n", "OwnerUserId": "623133", "PostTypeId": "2", "Id": "5714664", "Score": "2", "CreationDate": "2011-04-19T10:01:04.973", "LastActivityDate": "2011-04-19T10:01:04.973"}, "5714616": {"CommentCount": "0", "AcceptedAnswerId": "5714720", "PostTypeId": "1", "LastEditorUserId": "610846", "CreationDate": "2011-04-19T09:56:23.940", "LastActivityDate": "2015-08-28T15:23:56.107", "LastEditDate": "2011-10-16T07:12:13.260", "ViewCount": "13966", "FavoriteCount": "13", "Title": "Usage of local class in C++ function", "Id": "5714616", "Score": "32", "Body": "<p>I see some usage of internal struct in c++ function.</p>\n<p>There is a common interface IBase. Here is the draft code.</p>\n<pre><code>class IBase\n{\n    virtual Method()=0;\n}\n\nvector&lt;IBase*&gt; baseList;\n</code></pre>\n<p>Then a function defined an internal class based on that IBase, and then push the internal class object into the baseList.</p>\n<pre><code>void func()\n{\n    struct Object : public IBase\n    {\n        virtual Method()\n        {\n            // Method of Object in func\n        }\n    }\n\n    IBase* base = new Object();\n    baseList-&gt;push(base);\n\n}\n</code></pre>\n<p>It seems a strange usage, but a nice implementation of message/event creation pattern.</p>\n<p>Other threads maybe use this baseList to handle the incoming event.</p>\n<p>What's the scope of internal struct of \"struct Object\"? It's very interesting. Is there some documents talking about this?</p>\n", "Tags": "<c++><design-patterns>", "OwnerUserId": "610846", "AnswerCount": "3"}, "5714720": {"ParentId": "5714616", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2011-04-19T10:06:40.420", "Score": "38", "LastEditorUserId": "2672165", "LastEditDate": "2015-08-28T15:23:56.107", "Id": "5714720", "OwnerUserId": "415784", "Body": "<blockquote>\n<p id=\"so_5714616_5714720_0\">What's the scope of internal struct of \"struct Object\"?</p>\n</blockquote>\n<p>The scope of the local classes is the function in which they're defined.But that isn't interesting in itself.</p>\n<p>What makes local classes interesting is that <strong>if</strong> they implement some interface (like your code does), then you can create instances of it (using <code>new</code>) and return them (for example, as <code>std::vector&lt;IBase*&gt;</code>), thereby making <em>the implementation</em> accessible <strong>through the base class pointer</strong> even outside the function.</p>\n<p>Some other facts about local classes:</p>\n<ul>\n<li><p>They cannot define static member variables.</p></li>\n<li><p>They cannot access nonstatic \"automatic\" local variables of the enclosing function. But they can access the <code>static</code> variables.</p></li>\n<li><p>They can be used in template functions. </p></li>\n<li><p>If they are defined inside a template function, then they can use the template parameters of the enclosing function.</p></li>\n<li><p>Local classes are final, that means users outside the function cannot derive from local class to function. Without local classes, you'd have to add an unnamed namespace in separate translation unit.</p></li>\n<li><p>Local classes are used to create <a href=\"http://en.wikipedia.org/wiki/Trampoline_(computers)\" rel=\"noreferrer\">trampoline functions</a> usually known as <em>thunks</em>.</p></li>\n</ul>\n<hr>\n<p>EDIT</p>\n<p>Some references from the Standard (2003)</p>\n<h1>9.8 Local class declarations [class.local]</h1>\n<blockquote>\n<p id=\"so_5714616_5714720_1\">\\1. A class can be defined within a function definition; such a class is\n  called a local class. The name of a\n  local class is local to its enclosing\n  scope. The local class is in the scope\n  of the enclosing scope, and has the\n  same access to names outside the\n  function as does the enclosing\n  function. Declarations in a local\n  class can use only type names, static\n  variables, extern variables and\n  functions, and enumerators from the\n  enclosing scope.</p>\n</blockquote>\n<pre><code>[Example:\n\nint x;\nvoid f()\n{\n   static int s ;\n   int x;\n   extern int g();\n\n   struct local {\n      int g() { return x; } // error: x is auto\n      int h() { return s; } // OK\n      int k() { return ::x; } // OK\n      int l() { return g(); } // OK\n   };\n// ...\n}\nlocal* p = 0; // error: local not in scope\n\n\u2014end example]\n</code></pre>\n<blockquote>\n<p id=\"so_5714616_5714720_2\">\\2. An enclosing function has no special access to members of the local\n  class; it obeys the usual access rules\n  (clause 11). Member functions of a\n  local class shall be defined within\n  their class definition, if they are\n  defined at all.</p>\n<p id=\"so_5714616_5714720_3\">\\3. If class X is a local class a nested class Y may be declared in\n  class X and later defined in the\n  definition of class X or be later\n  defined in the same scope as the\n  definition of class X. A class nested\n  within a local class is a local class.</p>\n<p id=\"so_5714616_5714720_4\">\\4. A local class shall not have static data members.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2015-08-28T15:23:56.107"}, "bq_ids": {"n4140": {"so_5714616_5714720_3": {"section_id": 5931, "quality": 1.0, "length": 25}, "so_5714616_5714720_4": {"section_id": 5910, "quality": 1.0, "length": 6}, "so_5714616_5714720_1": {"section_id": 5929, "quality": 0.7291666666666666, "length": 35}, "so_5714616_5714720_2": {"section_id": 5930, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_5714616_5714720_3": {"section_id": 5703, "quality": 1.0, "length": 25}, "so_5714616_5714720_4": {"section_id": 5682, "quality": 1.0, "length": 6}, "so_5714616_5714720_1": {"section_id": 5701, "quality": 0.7291666666666666, "length": 35}, "so_5714616_5714720_2": {"section_id": 5702, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_5714616_5714720_3": {"section_id": 7416, "quality": 1.0, "length": 25}, "so_5714616_5714720_4": {"section_id": 7392, "quality": 1.0, "length": 6}, "so_5714616_5714720_1": {"section_id": 7414, "quality": 0.7083333333333334, "length": 34}, "so_5714616_5714720_2": {"section_id": 7415, "quality": 0.9583333333333334, "length": 23}}}, "9913679": {"ParentId": "5714616", "CommentCount": "1", "Body": "<p>\\4. A local class shall not have static data members.</p>\n<p>BUT you can do this, inside of a local class</p>\n<pre><code>int GetCount()\n{\n    class _local\n    {\n    public:\n        static int Count(int count = std::numeric_limits&lt;int&gt;::max())\n        {\n            static int count_ = 0;\n            if (count != std::numeric_limits&lt;int&gt;::max()) count_ = count;\n            return count_;\n        }\n\n        static float Operation(float  a, float  b)\n        {\n            _local::Count(_local::Count() + 1);\n            return a;\n        }\n    };\n   _local::Count(0);\n   CALLBACK( _local::Operation);\n   return _local::Count();\n}\n</code></pre>\n<p>_local::Count can be used to read and write the otherwise static variable</p>\n<p>-aydin</p>\n", "OwnerUserId": "1299001", "PostTypeId": "2", "Id": "9913679", "Score": "3", "CreationDate": "2012-03-28T18:37:44.880", "LastActivityDate": "2012-03-28T18:37:44.880"}});