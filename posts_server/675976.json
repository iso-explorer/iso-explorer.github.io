post_cb({"675993": {"ParentId": "675976", "CommentCount": "0", "Body": "<p>I remember having this problem in 2001. I'm amazed it's still there. Yes, this is a compiler bug.</p>\n<p>The optimiser is seeing </p>\n<pre><code>i + 1 &gt;= 1;\n</code></pre>\n<p>Theoretically, we can optimise this by putting all of the constants on the same side:</p>\n<pre><code>i &gt;= (1-1);\n</code></pre>\n<p>Because <i>i</i> is unsigned, it will always be greater than or equal to zero.</p>\n<p>See this newsgroup discussion <a href=\"http://groups.google.com/group/comp.lang.c++/browse_thread/thread/b1a20c37d5436bbf/729c5184d30299f7?q=%2B%22Andrew+Shepherd%22+%2B%22compiler+bug%22\" rel=\"nofollow noreferrer\">here</a>. </p>\n", "OwnerUserId": "25216", "Id": "675993", "PostTypeId": "2", "OwnerDisplayName": "Andrew Shepherd", "Score": "8", "CreationDate": "2009-03-24T02:44:59.237", "LastActivityDate": "2009-03-24T02:44:59.237"}, "bq_ids": {"n4140": {"so_675976_676008_1": {"section_id": 7213, "quality": 0.875, "length": 14}, "so_675976_676008_0": {"section_id": 5937, "quality": 0.65, "length": 13}, "so_675976_676008_2": {"section_id": 31, "quality": 0.9666666666666667, "length": 29}, "so_675976_676008_3": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_675976_676008_1": {"section_id": 6957, "quality": 1.0, "length": 16}, "so_675976_676008_0": {"section_id": 5709, "quality": 0.65, "length": 13}, "so_675976_676008_3": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}, "so_675976_676008_2": {"section_id": 28, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_675976_676008_1": {"section_id": 8722, "quality": 0.875, "length": 14}, "so_675976_676008_2": {"section_id": 31, "quality": 0.9666666666666667, "length": 29}, "so_675976_676008_0": {"section_id": 7421, "quality": 0.65, "length": 13}, "so_675976_676008_3": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}}}, "675976": {"CommentCount": "0", "AcceptedAnswerId": "675993", "PostTypeId": "1", "LastEditorUserId": "15168", "LastEditorDisplayName": "Jonathan Leffler", "CreationDate": "2009-03-24T02:35:59.693", "LastActivityDate": "2009-03-24T03:51:31.917", "AnswerCount": "4", "LastEditDate": "2009-03-24T02:43:32.390", "ViewCount": "296", "FavoriteCount": "1", "Title": "MSVC++: Strangeness with unsigned ints and overflow", "Id": "675976", "Score": "7", "Body": "<p>I've got the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    string a = \"a\";\n    for(unsigned int i=a.length()-1; i+1 &gt;= 1; --i)\n    {\n        if(i &gt;= a.length())\n        {\n            cerr &lt;&lt; (signed int)i &lt;&lt; \"?\" &lt;&lt; endl;\n            return 0;\n        }\n    }\n}\n</code></pre>\n<p>If I compile in MSVC with full optimizations, the output I get is \"-1?\". If I compile in Debug mode (no optimizations), I get no output (expected.)</p>\n<p>I thought the standard guaranteed that unsigned integers overflowed in a predictable way, so that when i = (unsigned int)(-1), i+1 = 0, and the loop condition i + 1 &gt;= 1 fails. Instead, the test is somehow passing. Is this a compiler bug, or am I doing something undefined somewhere?</p>\n", "Tags": "<c++><standards>", "OwnerDisplayName": "Etienne Vouga"}, "676002": {"ParentId": "675976", "CommentCount": "0", "Body": "<p>I'm not certain, but I think you are probably running foul of a bug.</p>\n<p>I suspect the trouble is in how the compiler is treating the <code>for</code> control.  I could imagine the optimizer doing:</p>\n<pre><code>for(unsigned int i=a.length()-1; i+1 &gt;= 1; --i)   // As written\n\nfor (unsigned int i = a.length()-1; i &gt;= 0; --i) // Noting 1 appears twice\n\nfor (unsigned int i = a.length()-1; ; --i)   // Because i &gt;= 0 at all times\n</code></pre>\n<p>Whether that is what is happening is another matter, but it might be enough to confuse the optimizer.</p>\n<p>You would probably be better off using a more standard loop formulation:</p>\n<pre><code>for (unsigned i = a.length()-1; i-- &gt; 0; )\n</code></pre>\n", "OwnerUserId": "15168", "Id": "676002", "PostTypeId": "2", "OwnerDisplayName": "Jonathan Leffler", "Score": "1", "CreationDate": "2009-03-24T02:50:47.070", "LastActivityDate": "2009-03-24T02:50:47.070"}, "676008": {"CommentCount": "13", "CreationDate": "2009-03-24T02:52:47.610", "CommunityOwnedDate": "2009-03-24T03:52:00.760", "LastEditorUserId": "33345", "LastActivityDate": "2009-03-24T03:51:31.917", "ParentId": "675976", "PostTypeId": "2", "LastEditorDisplayName": "greyfade", "LastEditDate": "2009-03-24T03:51:31.917", "Id": "676008", "Score": "4", "Body": "<p>ISO14882:2003, section 5, paragraph 5:</p>\n<blockquote>\n<p id=\"so_675976_676008_0\">If during the evaluation of an expression, the result is not mathematically defined or <em>not in the range of representable values for its type</em>, the behavior is undefined, unless such an expression is a constant expression (5.19), in which case the program is ill-formed.</p>\n</blockquote>\n<p>(Emphasis mine.) So, yes, the behavior is undefined. The standard makes no guarantees of behavior in the case of integer over/underflow.</p>\n<p>Edit: The standard seems slightly conflicted on the matter elsewhere.</p>\n<p>Section 3.9.1.4 says:</p>\n<blockquote>\n<p id=\"so_675976_676008_1\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2 n where n is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>But section 4.7.2 and .3 says:</p>\n<blockquote>\n<p id=\"so_675976_676008_2\">2) If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2 n where n is the number of bits used to represent the unsigned type). [Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). ]</p>\n<p id=\"so_675976_676008_3\">3) If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); <em>otherwise, the value is implementation-defined.</em></p>\n</blockquote>\n<p>(Emphasis mine.)</p>\n", "OwnerUserId": "33345", "OwnerDisplayName": "greyfade"}, "676018": {"ParentId": "675976", "CommentCount": "0", "Body": "<p>Yup, I just tested this on Visual Studio 2005, it definitely behaves differently in Debug and Release. I wonder if 2008 fixes it.</p>\n<p>Interestingly it complained about your implicit cast from size_t (.length's result) to unsigned int, but has no problem generating bad code.</p>\n", "OwnerUserId": "65000", "Id": "676018", "PostTypeId": "2", "OwnerDisplayName": "JZig", "Score": "0", "CreationDate": "2009-03-24T02:55:23.750", "LastActivityDate": "2009-03-24T02:55:23.750"}});