post_cb({"45364539": {"ViewCount": "222", "Body": "<p>I use two variables in which memory is allocated dynamically, and I print the memory locations, but they are not consecutive.  Why?</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    int *a = malloc(sizeof(int));\n    int *b = malloc(sizeof(int));\n    printf(\"\\n a=%p \\t b=%p  \\n\",a,b);\n}\n</code></pre>\n<p>The answers I get (in Linux) are</p>\n<p>1st time:</p>\n<pre><code> a=0x20a0010     b=0x20a0030\n</code></pre>\n<p>2nd time:</p>\n<pre><code> a=0x657010      b=0x657030\n</code></pre>\n<p>3rd time:</p>\n<pre><code> a=0x139e010     b=0x139e030 \n</code></pre>\n<p>Why is the exact difference between the memory locations of <code>a</code> and <code>b</code> variables the way it is in the 1st, 2nd and 3rd times?</p>\n<p>Is this related to paging memory?</p>\n<p>My processor is 64 bit.</p>\n", "Title": "Why the Memory locations for two variables which is allocated dynamically are not consecutive?", "CreationDate": "2017-07-28T03:47:15.400", "LastActivityDate": "2017-07-28T05:49:59.900", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-07-28T03:59:27.693", "LastEditorUserId": "65863", "Id": "45364539", "ClosedDate": "2017-07-28T10:28:28.790", "Score": "6", "OwnerUserId": "6234260", "Tags": "<c++><c><linux>", "AnswerCount": "4"}, "45365775": {"PostTypeId": "2", "Body": "<p>As note at <a href=\"https://www.gnu.org/software/libc/manual/html_node/Malloc-Examples.html\" rel=\"nofollow noreferrer\">GNU Examples of malloc</a></p>\n<blockquote>\n<p id=\"so_45364539_45365775_0\">Note that the memory located after the end of the block is likely to\n  be in use for something else; perhaps a block already allocated by\n  another call to malloc.</p>\n</blockquote>\n<p>This actually means that, for each call to <code>malloc</code> the OS, depending on its memory management algorithm, finds the most appropriate / proper / suitable / efficient free space for the caller.</p>\n<p>For example:</p>\n<pre><code>void* p_1 = malloc(4);\nvoid* p_2 = malloc(4);\n\n[oooo][xxxx][oooo][oooo]\n^           ^\np_1         p_2\n</code></pre>\n", "LastActivityDate": "2017-07-28T05:49:59.900", "Id": "45365775", "CommentCount": "0", "CreationDate": "2017-07-28T05:49:59.900", "ParentId": "45364539", "Score": "0", "OwnerUserId": "2589553"}, "45364682": {"Id": "45364682", "PostTypeId": "2", "Body": "<p>The operating system handles memory allocation, and there is no guarantee that this memory is contiguous when dynamically allocating two consecutive variables. I should also mention that this is the outcome of a defense mechanism known as <a href=\"https://stackoverflow.com/questions/3605222/what-is-address-space-layout-randomization\">ASLR</a>. ASLR defends against buffer overflows by randomizing the location of a process during its execution, this may include the <a href=\"https://www.howtogeek.com/278056/what-is-aslr-and-how-does-it-keep-your-computer-secure/\" rel=\"nofollow noreferrer\">stack, heap, and libraries</a>. This is why you notice these addresses changing. By the standard, you're only guaranteed the following. </p>\n<blockquote>\n<p id=\"so_45364539_45364682_0\">ISO C11 7.22.3.4 Malloc</p>\n<p id=\"so_45364539_45364682_1\">1) <strong>Synopsis</strong></p>\n</blockquote>\n<pre><code>#include &lt;stdlib.h&gt;\nvoid* malloc(size_t size);\n</code></pre>\n<blockquote>\n<p id=\"so_45364539_45364682_2\">2) <strong>Description</strong> \n  The malloc function allocates space for an object whose size is specified by size and whose value is indeterminate.</p>\n<p id=\"so_45364539_45364682_3\">3) <strong>Return</strong>\n  The malloc function returns either a null pointer or a pointer to the allocated space.</p>\n</blockquote>\n", "LastEditorUserId": "3726902", "LastActivityDate": "2017-07-28T04:20:36.800", "CommentCount": "2", "CreationDate": "2017-07-28T04:03:54.117", "ParentId": "45364539", "Score": "2", "OwnerUserId": "3726902", "LastEditDate": "2017-07-28T04:20:36.800"}, "bq_ids": {"n4140": {"so_45364539_45364781_0": {"length": 16, "quality": 0.5714285714285714, "section_id": 7177}}, "n3337": {"so_45364539_45364781_0": {"length": 16, "quality": 0.5714285714285714, "section_id": 6921}}}, "45364769": {"PostTypeId": "2", "Body": "<p>If you want contiguous memory allocate memory inside and unique_ptr with the size of two arrays, and point your pointers at the end and the center of your pointer you get from the unique pointer. Just remember to not delete your a and b pointers.</p>\n<pre><code>std::unique_ptr&lt;int&gt; a(new int[na+nb])\nint * aptr = a.get();\nInt * bptr = a.get() + na;\n</code></pre>\n", "LastActivityDate": "2017-07-28T04:14:33.310", "Id": "45364769", "CommentCount": "0", "CreationDate": "2017-07-28T04:14:33.310", "ParentId": "45364539", "Score": "-2", "OwnerUserId": "3047822"}, "45364781": {"Id": "45364781", "PostTypeId": "2", "Body": "<p>The gap between two consecutive allocations is not related to paging. Your allocations are so small that they reside in the data segment. Libc handles these internally - the space outside your <code>sizeof int</code> bytes generally contains pointers to the previous and the next block of data and the size of allocation - after all <code>free</code> will just get a pointer and it will need to figure out how much memory it is to deallocate.</p>\n<p>Additionally both of these pointers are aligned to 16-byte boundary. <a href=\"http://port70.net/~nsz/c/c11/n1570.html#7.22.3\" rel=\"noreferrer\">C11 7.22.3</a> says that </p>\n<blockquote>\n<p id=\"so_45364539_45364781_0\">The pointer returned if the allocation succeeds is <strong>suitably aligned</strong> so that it may be assigned to <strong>a pointer to any type of object with a fundamental alignment requirement</strong> and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated).</p>\n</blockquote>\n<p>Thus even though you're using them for <code>int</code> the C standard requires that the pointer returned be aligned for any data type - which on your implementation is 16 bytes.</p>\n<p>If however you allocate an object that is very <em>large</em>, glibc will map entire pages using <code>mmap</code> instead. Then the alignment (on my 64-bit computer) is exactly 16 bytes from the start of a 4K page:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    int *a = malloc(12345678);\n    int *b = malloc(12345678);\n    printf(\"\\n a=%p \\t b=%p  \\n\",a,b);\n}\n</code></pre>\n<p>when run</p>\n<pre><code>% ./a.out  \n\n a=0x7fb65e7b7010     b=0x7fb65dbf0010\n</code></pre>\n<p>One can see the <code>mmap</code> calls with <code>strace ./a.out</code> - there among other system calls there are</p>\n<pre><code>mmap(NULL, 12349440, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb65e7b7000\nmmap(NULL, 12349440, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb65dbf0000\n</code></pre>\n<hr>\n<p>As for why the addresses keep changing from one execution to another - this is due to <a href=\"https://en.wikipedia.org/wiki/Address_space_layout_randomization\" rel=\"noreferrer\">address space layout randomization, or ASLR</a> - a security mechanism which makes it harder for evil crackers to <strong>predictably</strong> exploit <em>undefined behaviour</em> in your code.</p>\n<hr>\n<p>P.S. If you really need to dynamically allocate space for 2 <code>int</code>s at consecutive addresses, allocate an array.</p>\n</hr></hr>", "LastEditorUserId": "918959", "LastActivityDate": "2017-07-28T05:36:15.627", "CommentCount": "5", "CreationDate": "2017-07-28T04:16:18.907", "ParentId": "45364539", "Score": "8", "OwnerUserId": "918959", "LastEditDate": "2017-07-28T05:36:15.627"}});