post_cb({"bq_ids": {"n4140": {"so_45905122_45905608_2": {"section_id": 6323, "quality": 0.92, "length": 23}, "so_45905122_45905608_1": {"section_id": 1395, "quality": 0.8125, "length": 13}, "so_45905122_45905608_0": {"section_id": 1394, "quality": 0.9361702127659575, "length": 44}}, "n3337": {"so_45905122_45905608_2": {"section_id": 6080, "quality": 0.92, "length": 23}, "so_45905122_45905608_1": {"section_id": 1389, "quality": 0.8125, "length": 13}, "so_45905122_45905608_0": {"section_id": 1388, "quality": 0.9148936170212766, "length": 43}}, "n4659": {"so_45905122_45905608_2": {"section_id": 7833, "quality": 0.92, "length": 23}, "so_45905122_45905608_1": {"section_id": 1513, "quality": 0.8125, "length": 13}, "so_45905122_45905608_0": {"section_id": 1512, "quality": 0.9361702127659575, "length": 44}}}, "45905122": {"CommentCount": "3", "AcceptedAnswerId": "45905608", "CreationDate": "2017-08-27T12:49:52.283", "LastActivityDate": "2017-08-27T13:44:54.430", "PostTypeId": "1", "ViewCount": "72", "FavoriteCount": "1", "Title": "Requirement of operator< constness in std::stable_sort", "Id": "45905122", "Score": "0", "Body": "<p>I'm a bit confused about the difference in requirements of <code>operator&lt;</code> <code>const</code> qualifier for std::sort and std::stable_sort. Suppose a simple structure:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nstruct Custom {\n    bool operator&lt;(const Custom&amp; custom) /* const */{\n        return true;\n    };\n};\n</code></pre>\n<p>Everything is ok if we try to compile and run this code:</p>\n<pre><code>int main() {\n    std::vector&lt;Custom&gt; values(3);\n    std::sort(values.begin(), values.end());\n    return 0;\n}\n</code></pre>\n<p>But this code with <code>std::stable_sort</code> failed to compile:</p>\n<pre><code>int main() {\n    std::vector&lt;Custom&gt; values(3);\n    std::sort(values.begin(), values.end());\n    return 0;\n}\n</code></pre>\n<p>Here's an error stack trace:</p>\n<pre><code>In file included from /usr/include/c++/5/bits/stl_algobase.h:71:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from temp.cpp:1:\n/usr/include/c++/5/bits/predefined_ops.h: In instantiation of \u2018bool __gnu_cxx::__ops::_Val_less_iter::operator()(_Value&amp;, _Iterator) const [with _Value = const Custom; _Iterator = __gnu_cxx::__normal_iterator&lt;Custom*, std::vector&lt;Custom&gt; &gt;]\u2019:\n/usr/include/c++/5/bits/stl_algo.h:2050:14:   required from \u2018_ForwardIterator std::__upper_bound(_ForwardIterator, _ForwardIterator, const _Tp&amp;, _Compare) [with _ForwardIterator = __gnu_cxx::__normal_iterator&lt;Custom*, std::vector&lt;Custom&gt; &gt;; _Tp = Custom; _Compare = __gnu_cxx::__ops::_Val_less_iter]\u2019\n/usr/include/c++/5/bits/stl_algo.h:2522:26:   required from \u2018void std::__merge_without_buffer(_BidirectionalIterator, _BidirectionalIterator, _BidirectionalIterator, _Distance, _Distance, _Compare) [with _BidirectionalIterator = __gnu_cxx::__normal_iterator&lt;Custom*, std::vector&lt;Custom&gt; &gt;; _Distance = long int; _Compare = __gnu_cxx::__ops::_Iter_less_iter]\u2019\n/usr/include/c++/5/bits/stl_algo.h:2782:34:   required from \u2018void std::__inplace_stable_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator&lt;Custom*, std::vector&lt;Custom&gt; &gt;; _Compare = __gnu_cxx::__ops::_Iter_less_iter]\u2019\n/usr/include/c++/5/bits/stl_algo.h:4863:28:   required from \u2018void std::__stable_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator&lt;Custom*, std::vector&lt;Custom&gt; &gt;; _Compare = __gnu_cxx::__ops::_Iter_less_iter]\u2019\n/usr/include/c++/5/bits/stl_algo.h:4897:36:   required from \u2018void std::stable_sort(_RAIter, _RAIter) [with _RAIter = __gnu_cxx::__normal_iterator&lt;Custom*, std::vector&lt;Custom&gt; &gt;]\u2019\ntemp.cpp:15:45:   required from here\n/usr/include/c++/5/bits/predefined_ops.h:71:22: error: no match for \u2018operator&lt;\u2019 (operand types are \u2018const Custom\u2019 and \u2018Custom\u2019)\n       { return __val &lt; *__it; }\n</code></pre>\n<p>So my question is:\nIs it just the consequence of technical implementation details or there exists some objective arguments in favor of such behavior?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "4558571", "AnswerCount": "1"}, "45905608": {"ParentId": "45905122", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_45905122_45905608_0\"><strong>[alg.sorting]/2</strong> <code>Compare</code> is a function object type (20.9). The return value of the function call operation applied to an object of type <code>Compare</code>, when contextually converted to <code>bool</code> (Clause 4), yields <code>true</code> if the first argument of the call is less than the second, and <code>false</code> otherwise. <code>Compare comp</code> is used throughout for algorithms assuming an ordering relation. <strong>It is assumed that <code>comp</code> will not apply any non-constant function through the dereferenced iterator.</strong></p>\n<p id=\"so_45905122_45905608_1\"><strong>[alg.sorting]/3</strong> For all algorithms that take <code>Compare</code>, there is a version that uses <code>operator&lt;</code> instead. That is, <code>comp(*i, *j) != false</code> defaults to <code>*i &lt; *j != false</code>.</p>\n<p id=\"so_45905122_45905608_2\"><strong>[res.on.functions]/1</strong> In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ standard library depends on components supplied by a C++ program. If these components do not meet their requirements, the Standard places no requirements on the implementation.</p>\n</blockquote>\n<p>Emphasis mine. Your program exhibits undefined behavior by way of supplying to a standard library function a component that doesn't meet the function's requirements.</p>\n<p>By the way, clang rejects both <code>std::sort</code> and <code>std::stable_sort</code>.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "45905608", "Score": "0", "CreationDate": "2017-08-27T13:44:54.430", "LastActivityDate": "2017-08-27T13:44:54.430"}});