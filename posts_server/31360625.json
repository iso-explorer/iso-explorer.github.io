post_cb({"31360625": {"CommentCount": "3", "ViewCount": "228", "CreationDate": "2015-07-11T18:48:19.917", "LastActivityDate": "2015-07-11T19:26:49.717", "Title": "Order of destruction in unordered_map", "AcceptedAnswerId": "31360942", "PostTypeId": "1", "Id": "31360625", "Score": "1", "Body": "<p>I have an unordered_map of objects. Each object, in its destructor, browses the unordered map to find other objects, and then tweaks these other objects. This will fail if the other objects are zombie objects, but if the other objects are entirely removed from the unordered_map, there is no problem.</p>\n<p>My questions:</p>\n<ol>\n<li>does this work if I erase() an object, and its destructor tries to look for itself in the unordered map? Specifically, is the destructor called first, or is the object removed from the unordered_map first, or is there no guarantee?</li>\n<li>does this work if the unordered_map is destroyed? Specifically, will the unordered_map be in a valid state as each individual destructor is called?</li>\n</ol>\n", "Tags": "<c++><standard-library>", "OwnerUserId": "2024042", "AnswerCount": "1"}, "31360942": {"ParentId": "31360625", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_31360625_31360942_0\">The lifetime of an object of type T ends when [...] if T is a class type with a non-trivial destructor (12.4), the destructor call starts [...]</p>\n<p id=\"so_31360625_31360942_1\">[\u00a7 3.8/1 N4431]</p>\n</blockquote>\n<p>And, further down</p>\n<blockquote>\n<p id=\"so_31360625_31360942_2\">The properties ascribed to objects throughout this International Standard apply for a given object only during its lifetime</p>\n<p id=\"so_31360625_31360942_3\">[\u00a7 3.8/3 N4431]</p>\n</blockquote>\n<p>And finally</p>\n<blockquote>\n<p id=\"so_31360625_31360942_4\">[...] after the lifetime of an object has ended [...] any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. [...] The program has undefined behavior if [...] the pointer is used to access a non-static data member or call a non-static member function of the object [...]</p>\n<p id=\"so_31360625_31360942_5\">[\u00a7 3.8/5 N4431]</p>\n</blockquote>\n<p>So, since you must have some kind of reference (e.g. a pointer, or a real reference, which I'd count as pointer here, too) to the map, and its lifetime has ended, accessing a member function (to get an iterator for example) will - as far as I'd read this part of the standard - lead to undefined behaviour.</p>\n<p>I was also looking at the part of the standard about unordered containers and containers in general, and couldn't find an exception to the above or any clue about the state during destruction.</p>\n<p>So: Don't do this. Neither with unordered containers, nor with any other object.</p>\n<hr>\n<p>BTW: What kind of tweaking makes any sense when you do it on objects that will be destructed moments thereafter?</p>\n</hr>", "OwnerUserId": "1116364", "PostTypeId": "2", "Id": "31360942", "Score": "3", "CreationDate": "2015-07-11T19:26:49.717", "LastActivityDate": "2015-07-11T19:26:49.717"}, "bq_ids": {"n4140": {"so_31360625_31360942_4": {"section_id": 7193, "quality": 0.9666666666666667, "length": 29}, "so_31360625_31360942_0": {"section_id": 7189, "quality": 0.8571428571428571, "length": 12}, "so_31360625_31360942_2": {"section_id": 7191, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_31360625_31360942_4": {"section_id": 6937, "quality": 0.9666666666666667, "length": 29}, "so_31360625_31360942_0": {"section_id": 6933, "quality": 0.8571428571428571, "length": 12}, "so_31360625_31360942_2": {"section_id": 6935, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_31360625_31360942_4": {"section_id": 8702, "quality": 0.9333333333333333, "length": 28}, "so_31360625_31360942_0": {"section_id": 8697, "quality": 0.8571428571428571, "length": 12}, "so_31360625_31360942_2": {"section_id": 8700, "quality": 0.8461538461538461, "length": 11}}}});