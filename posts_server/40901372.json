post_cb({"bq_ids": {"n4140": {"so_40901372_40901430_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5558}}, "n3337": {"so_40901372_40901430_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5340}}, "n4659": {"so_40901372_40901430_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 7003}}}, "40901372": {"ViewCount": "82", "Body": "<p>According to the C++ concepts:</p>\n<blockquote>\n<p id=\"so_40901372_40901372_0\">Any iterator other than input_iterator is an output_iterator.</p>\n</blockquote>\n<p>A <code>vector&lt;int&gt;::const_iterator</code> is a <code>random_access_iterator</code>, and of course that is an <code>output_iterator</code>.</p>\n<p>However, according to <a href=\"http://en.cppreference.com/w/cpp/concept/OutputIterator\" rel=\"nofollow noreferrer\">cppreference.com</a>, an <code>output_iterator</code> must be writable, while a <code>vector&lt;int&gt;::const_iterator</code> is not.</p>\n<p><strong>Is <code>vector&lt;int&gt;::const_iterator</code> an <code>output_iterator</code>?</strong></p>\n<p>See also: <a href=\"https://stackoverflow.com/questions/40901170/\">How to check if an iterator is an output_iterator in c++?</a></p>\n", "AcceptedAnswerId": "40901430", "Title": "Is vector<int>::const_iterator an output_iterator?", "CreationDate": "2016-12-01T01:56:24.160", "Id": "40901372", "CommentCount": "1", "LastEditDate": "2017-05-23T12:30:29.790", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-12-01T02:36:36.983", "Score": "2", "OwnerUserId": "508343", "Tags": "<c++><iterator><language-lawyer><c++-concepts>", "AnswerCount": "3"}, "40901538": {"Id": "40901538", "PostTypeId": "2", "Body": "<p>What your quote apparently means to say is that any iterator that does not satisfy Input iterator requirements is an Output iterator.</p>\n<p>The standard hierarchy of iterator categories defines (see 24.2.1) the following sequence of iterator categories with <em>nested</em> requirements</p>\n<blockquote>\n<p id=\"so_40901372_40901538_0\">Random Access -&gt; Bidirectional -&gt; Forward -&gt; Input</p>\n</blockquote>\n<p>while Output iterator category stands alone. </p>\n<p>This nesting means that every Forward iterator is also Input iterator (i.e. also satisfies the requirements of Input iterator category), every Bidirectional iterator is also Forward and Input iterator at the same time. This is the context in which your quite is supposed to be interpreted.</p>\n<p><code>std::vector::const_iterator</code> is a Random Access iterator, which makes it satisfy the requirements of Bidirectional, Forward and Input iterator as well. I.e. in that sense <code>std::vector::const_iterator</code> <em>is</em> an Input iterator (!). For which reason your quote cannot be used to deduce that it is an Output iterator.</p>\n<p>The further subdivision into <em>mutable</em> iterators and <em>nonmutable</em> (<em>constant</em>) iterators is applied on top of that, but it is not necessary to bring it into the picture in this case.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-12-01T02:36:36.983", "Score": "0", "CreationDate": "2016-12-01T02:15:48.037", "ParentId": "40901372", "CommentCount": "0", "LastEditDate": "2016-12-01T02:36:36.983", "OwnerUserId": "187690"}, "40901430": {"Id": "40901430", "PostTypeId": "2", "Body": "<p>No. <code>vector&lt;int&gt;::const_iterator</code> is a <em>constant iterator</em> (<a href=\"http://eel.is/c++draft/container.requirements.general\" rel=\"nofollow noreferrer\">[container.requirements.general]</a>), which means it does not satisfy the requirements of output iterators. </p>\n<p><a href=\"http://eel.is/c++draft/iterator.requirements.general#4\" rel=\"nofollow noreferrer\">[iterator.requirements.general]/4</a>:</p>\n<blockquote>\n<p id=\"so_40901372_40901430_0\">Iterators that further satisfy the requirements of output iterators are called <em>mutable iterator</em>s. Nonmutable iterators are referred to as <em>constant iterator</em>s.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_40901372_40901430_1\">An vector::const_iterator is a random_access_iterator, and of course is an output_iterator.</p>\n</blockquote>\n<p>This is simply wrong.</p>\n</hr>", "LastEditorUserId": "4672588", "LastActivityDate": "2016-12-01T02:09:07.083", "Score": "4", "CreationDate": "2016-12-01T02:02:54.570", "ParentId": "40901372", "CommentCount": "0", "LastEditDate": "2016-12-01T02:09:07.083", "OwnerUserId": "4672588"}, "40901435": {"Id": "40901435", "PostTypeId": "2", "Body": "<p>Look here: <a href=\"http://en.cppreference.com/w/cpp/concept/OutputIterator\" rel=\"nofollow noreferrer\">Cpp Reference</a></p>\n<blockquote>\n<p id=\"so_40901372_40901435_0\">An OutputIterator is an Iterator that can write to the pointed-to\n  element.</p>\n</blockquote>\n", "LastActivityDate": "2016-12-01T02:03:40.997", "Score": "1", "CreationDate": "2016-12-01T02:03:40.997", "ParentId": "40901372", "CommentCount": "0", "OwnerUserId": "1459996"}});