post_cb({"33872026": {"CommentCount": "0", "AcceptedAnswerId": "33873333", "CreationDate": "2015-11-23T13:15:34.503", "LastActivityDate": "2015-11-23T16:43:57.080", "PostTypeId": "1", "ViewCount": "1381", "FavoriteCount": "1", "Title": "Copy elision for pass-by-value arguments", "Id": "33872026", "Score": "12", "Body": "<p>Given</p>\n<pre><code>struct Range{\n    Range(double from, double to) : from(from), to(to) {}\n    double from;\n    double to;\n};\n\nstruct Box{\n    Box(Range x, Range y) : x(x), y(y) {}\n    Range x;\n    Range y;\n};\n</code></pre>\n<p>suppose we run <code>Box box(Range(0.0,1.0),Range(0.0,2.0))</code>.</p>\n<p>Could a modern compiler with optimizations enabled avoid copying <code>Range</code> objects altogether during this construction? (i.e. construct the <code>Range</code> objects inside <code>box</code> to begin with?)</p>\n", "Tags": "<c++><pass-by-value><copy-elision>", "OwnerUserId": "827280", "AnswerCount": "4"}, "33873333": {"ParentId": "33872026", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>There are actually two copies being performed on each <code>Range</code> object passed to the constructor. The first happens when copying the temporary <code>Range</code> object into the function parameter. This can be elided as per the reference given in 101010's answer. There are <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\">specific circumstances</a> in which copy elision can be performed.</p>\n<p>The second copy happens when copying the function parameter into the member (as specified in the constructor initialization list). This cannot be elided, and this is why you still see a single copy being made for each parameter in YSC's answer.</p>\n<p>When the copy constructor has side-effects (such as the prints in YSC's answer), copy elision can still be performed for the first copy, but the second copy must remain.</p>\n<p>However, the compiler is always free to make changes if they do not alter the observed behavior of the program (this is known as the \"as-if\" rule). This means that if the copy constructor has no side effects and removing the constructor call will not change the result, the compiler is free to remove even the second copy.</p>\n<p>You can see this by analyzing the generated assembly. In <a href=\"http://goo.gl/uQuC64\">this example</a>, the compiler optimizes out not only the copies, but even the construction of the <code>Box</code> object itself:</p>\n<pre><code>Box box(Range(a,b),Range(c,d));\nstd::cout &lt;&lt; box.x.from;\n</code></pre>\n<p>Generates identical assembly as:</p>\n<pre><code>std::cout &lt;&lt; a;\n</code></pre>\n", "OwnerUserId": "189205", "LastEditorUserId": "189205", "LastEditDate": "2015-11-23T15:07:02.087", "Id": "33873333", "Score": "18", "CreationDate": "2015-11-23T14:23:27.370", "LastActivityDate": "2015-11-23T15:07:02.087"}, "33872339": {"ParentId": "33872026", "CommentCount": "3", "Body": "<p>The fact that it can, doesn't mean it most certainly will. See it in this <a href=\"http://coliru.stacked-crooked.com/a/725ac4828594dba2\" rel=\"nofollow\">Demo</a>, it's obvious you are creating two copies. Hint, the output contains twice : </p>\n<blockquote>\n<p id=\"so_33872026_33872339_0\">copy made</p>\n<p id=\"so_33872026_33872339_1\">copy made</p>\n</blockquote>\n", "OwnerUserId": "4224575", "PostTypeId": "2", "Id": "33872339", "Score": "1", "CreationDate": "2015-11-23T13:30:59.600", "LastActivityDate": "2015-11-23T13:30:59.600"}, "33872121": {"ParentId": "33872026", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It should, but <a href=\"http://coliru.stacked-crooked.com/a/0db5834511e9df68\" rel=\"nofollow\">I fail to make it work (live example)</a>. The compiler may detect the side-effect of the constructors and decide not to go with copy elision.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Range{\n    Range(double from, double to) : from(from), to(to) { std::cout &lt;&lt; \"Range(double,double)\" &lt;&lt; std::endl; }\n    Range(const Range&amp; other) : from(other.from), to(other.to) { std::cout &lt;&lt; \"Range(const Range&amp;)\" &lt;&lt; std::endl; }\n    double from;\n    double to;\n};\n\nstruct Box{\n    Box(Range x, Range y) : x(x), y(y) { std::cout &lt;&lt; \"Box(Range,Range)\" &lt;&lt; std::endl; }\n    Box(const Box&amp; other) : x(other.x), y(other.y) { std::cout &lt;&lt; \"Box(const Box&amp;)\" &lt;&lt; std::endl; }\n    Range x;\n    Range y;\n};\n\n\nint main(int argc, char** argv)\n{\n    (void) argv;\n    const Box box(Range(argc, 1.0), Range(0.0, 2.0));\n    std::cout &lt;&lt; box.x.from &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Compile &amp; run:</p>\n<pre><code>clang++ -std=c++14 -O3 -Wall -Wextra -pedantic -Werror -pthread main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>Output:</p>\n<pre><code>Range(double,double)\nRange(double,double)\nRange(const Range&amp;)\nRange(const Range&amp;)\nBox(Range,Range)\n1\n</code></pre>\n", "OwnerUserId": "5470596", "LastEditorUserId": "5470596", "LastEditDate": "2015-11-23T13:30:40.627", "Id": "33872121", "Score": "4", "CreationDate": "2015-11-23T13:19:57.830", "LastActivityDate": "2015-11-23T13:30:40.627"}, "33872152": {"ParentId": "33872026", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes it can, In particular this kind of copy elision context falls under the copy elision criterion specified in <em>12.8/p31.3 Copying and moving class objects [class.copy]</em> of the standard:</p>\n<blockquote>\n<p id=\"so_33872026_33872152_0\">(31.3) -- when a temporary class object that has not been bound to a reference\n  (12.2) would be copied/moved to a class object with the same type\n  (ignoring cv-qualification), the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move.</p>\n</blockquote>\n<p>Any descent compiler apply copy elision in this particular context. However, in the OP example two copies taking place.</p>\n<ol>\n<li>The temporary objects passed in the constructor (That can be elide per standard as mentioned above).</li>\n<li>The copies in the <code>Box</code> constructor's initializer list (That can't be elided).</li>\n</ol>\n<p>You can see it in this <a href=\"http://coliru.stacked-crooked.com/a/4d678c4cdb1465a6\" rel=\"nofollow\">demo</a> where the copy constructor is evoked only 2 times.</p>\n<p>Have also in mind that, because the standard allows in a particular context copy elision optimization, doesn't mean that a compiler vendor is obligated to do it. Copy elision is the only allowed form of optimization that can change the observable side-effects. Consequently, due to the fact that some compilers do not perform copy elision in every situation where it is allowed (e.g., in debug mode), <strong>programs that rely on the side-effects of copy/move constructors and destructors are not portable.</strong></p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2015-11-23T16:43:57.080", "Id": "33872152", "Score": "1", "CreationDate": "2015-11-23T13:21:33.530", "LastActivityDate": "2015-11-23T16:43:57.080"}, "bq_ids": {"n4140": {"so_33872026_33872152_0": {"section_id": 480, "quality": 0.8620689655172413, "length": 25}}, "n3337": {"so_33872026_33872152_0": {"section_id": 471, "quality": 0.8620689655172413, "length": 25}}, "n4659": {"so_33872026_33872152_0": {"section_id": 502, "quality": 0.6551724137931034, "length": 19}}}});