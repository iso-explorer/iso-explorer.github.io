post_cb({"14368416": {"ParentId": "14365595", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Using a raw <code>bool</code> is not sufficient.</p>\n<blockquote>\n<p id=\"so_14365595_14368416_0\">The execution of a program contains a <em>data race</em> if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior. <strong><em>\u00a7 1.10 p21</em></strong></p>\n<p id=\"so_14365595_14368416_1\">Two expression evaluations conflict if one of them modifies a memory location (1.7) and the other one accesses or modifies the same memory location. <strong><em>\u00a7 1.10 p4</em></strong></p>\n</blockquote>\n<p>Your program contains a data race where the worker thread writes to the bool and the main thread reads from it, but there is no formal <em>happens-before</em> relation between the operations.</p>\n<p>There are a number of different ways to avoid the data race, including using <code>std::atomic&lt;bool&gt;</code> with appropriate memory orderings, using a memory barrier, or replacing the bool with a condition variable.</p>\n", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2013-01-16T23:37:34.750", "Id": "14368416", "Score": "6", "CreationDate": "2013-01-16T21:43:04.583", "LastActivityDate": "2013-01-16T23:37:34.750"}, "14365784": {"ParentId": "14365595", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_14365595_14365784_0\">Someone who commented on the accepted answer claims that one cannot use a simple bool variable as a signal, the code was broken without a memory barrier and using std::atomic would be correct.</p>\n</blockquote>\n<p>The commenter is right: a simple <code>bool</code> is insufficient, because non-atomic writes from the thread that sets <code>thread_finished</code> to <code>true</code> can be re-ordered.</p>\n<p>Consider a thread that sets a static variable <code>x</code> to some very important number, and then signals its exit, like this:</p>\n<pre><code>x = 42;\nthread_finished = true;\n</code></pre>\n<p>When your main thread sees <code>thread_finished</code> set to <code>true</code>, it assumes that the worker thread has finished. However, when your main thread examines <code>x</code>, it may find it set to a wrong number, because the two writes above have been re-ordered.</p>\n<p>Of course this is only a simplified example to illustrate the general problem. Using <code>std::atomic</code> for your <code>thread_finished</code> variable adds a <em>memory barrier</em>, making sure that all writes before it are done. This fixes the potential problem of out-of-order writes.</p>\n<p>Another issue is that reads to non-volatile variables can be optimized out<sup><em></em></sup>, so the main thread would never notice the change in the <code>thread_finished</code> flag.\n<hr/>\n<sup></sup></p> Important note: making your <code>thread_finished</code> volatile is <strong>not</strong> going to fix the problem; in fact, volatile should not be used in conjunction with threading - it is intended for working with memory-mapped hardware.\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "14365784", "Score": "21", "CreationDate": "2013-01-16T19:04:05.667", "LastActivityDate": "2013-01-16T19:04:05.667"}, "14365595": {"CommentCount": "7", "AcceptedAnswerId": "14365784", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-01-16T18:52:50.067", "LastActivityDate": "2013-01-16T23:37:34.750", "LastEditDate": "2017-05-23T12:17:54.817", "ViewCount": "2452", "FavoriteCount": "3", "Title": "Is it necessary to use a std::atomic to signal that a thread has finished execution?", "Id": "14365595", "Score": "16", "Body": "<p>I would like to check if a <code>std::thread</code> has finished execution. Searching stackoverflow I found the following <a href=\"https://stackoverflow.com/questions/9094422/how-to-check-if-a-stdthread-is-still-running\">question</a> which addresses this issue. The accepted answer proposes having the worker thread set a variable right before exiting and having the main thread check this variable. Here is a minimal working example of such a solution:</p>\n<pre><code>#include &lt;unistd.h&gt;\n#include &lt;thread&gt;\n\nvoid work( bool* signal_finished ) {\n  sleep( 5 );\n  *signal_finished = true;\n}\n\nint main()\n{\n  bool thread_finished = false;\n  std::thread worker(work, &amp;thread_finished);\n\n  while ( !thread_finished ) {\n    // do some own work until the thread has finished ...\n  }\n\n  worker.join();\n}\n</code></pre>\n<p>Someone who commented on the accepted answer claims that one cannot use a simple <code>bool</code> variable as a signal, the code was broken without a memory barrier and using <code>std::atomic&lt;bool&gt;</code> would be correct. My initial guess is that this is wrong and a simple <code>bool</code> is sufficient, but I want to make sure I'm not missing something. <strong>Does the above code need a <code>std::atomic&lt;bool&gt;</code> in order to be correct?</strong></p>\n<p>Let's assume the main thread and the worker are running on different CPUs in different sockets. What I think would happen is, that the main thread reads <code>thread_finished</code> from its  CPU's cache. When the worker updates it, the cache coherency protocol takes care of writing the workers change to global memory and invalidating the main thread's CPU's cache so it has to read the updated value from global memory. Isn't the whole point of cache coherence to make code like the above just work?</p>\n", "Tags": "<c++><c++11><stdthread><stdatomic>", "OwnerUserId": "1746785", "AnswerCount": "4"}, "14365788": {"ParentId": "14365595", "CommentCount": "0", "Body": "<p>Cache coherency algorithms are not present everywhere, nor are they perfect. The issue surrounding <code>thread_finished</code> is that one thread tries to write a value to it while another thread tries to read it. This is a data race, and if the accesses are not sequenced, it results in undefined behavior.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "14365788", "Score": "2", "CreationDate": "2013-01-16T19:04:16.330", "LastActivityDate": "2013-01-16T19:04:16.330"}, "14365775": {"ParentId": "14365595", "CommentCount": "0", "Body": "<p>It's not ok. Optimizer can optimize</p>\n<pre><code>  while ( !thread_finished ) {\n    // do some own work until the thread has finished ...\n  }\n</code></pre>\n<p>to:</p>\n<pre><code>  if(!thread_finished)\n    while (1) {\n      // do some own work until the thread has finished ...\n    }\n</code></pre>\n<p>assuming it can prove, that \"some own work\" doesn't change <code>thread_finished</code>.</p>\n", "OwnerUserId": "1126943", "PostTypeId": "2", "Id": "14365775", "Score": "2", "CreationDate": "2013-01-16T19:03:44.010", "LastActivityDate": "2013-01-16T19:03:44.010"}, "bq_ids": {"n4140": {"so_14365595_14368416_0": {"section_id": 5834, "quality": 0.7407407407407407, "length": 20}, "so_14365595_14368416_1": {"section_id": 5817, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_14365595_14368416_0": {"section_id": 5605, "quality": 0.8148148148148148, "length": 22}, "so_14365595_14368416_1": {"section_id": 5588, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_14365595_14368416_0": {"section_id": 7296, "quality": 0.7407407407407407, "length": 20}, "so_14365595_14368416_1": {"section_id": 7278, "quality": 0.8235294117647058, "length": 14}}}});