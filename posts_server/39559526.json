post_cb({"39566019": {"Id": "39566019", "PostTypeId": "2", "Body": "<p><code>(a = b) = c</code> is a valid statement in C++. Here '=' is working as an assignment operator. Here, <strong>b</strong>'s value will be assigned to <strong>a</strong> and <strong>c</strong>'s value will be assigned to <strong>a</strong> for Right to Left precedence.</p>\n<p>For example:</p>\n<pre><code>int a = 5;\nint b = 2;\nint c = 7;\nint answer = (a = b) = c;\ncout &lt;&lt; answer &lt;&lt; endl;\n</code></pre>\n<p>Output:</p>\n<pre><code>7\n</code></pre>\n", "LastEditorUserId": "4610541", "LastActivityDate": "2016-09-19T06:59:53.897", "Score": "3", "CreationDate": "2016-09-19T05:36:43.910", "ParentId": "39559526", "CommentCount": "4", "OwnerUserId": "4610541", "LastEditDate": "2016-09-19T06:59:53.897"}, "39559581": {"Id": "39559581", "PostTypeId": "2", "Body": "<p>The assignment expression <code>a = b</code> is not an lvalue in C, but it is in C++:</p>\n<ul>\n<li><p>C11, 6.5.14 (Assignment operators):</p>\n<blockquote>\n<p id=\"so_39559526_39559581_0\">An assignment operator stores a value in the object designated by the left operand. An assignment expression has the value of the left operand after the assignment, <strong>but is not an lvalue</strong>.</p>\n</blockquote></li>\n<li><p>C++14, 5.18 [expr.ass] (Assignment and compound assignment operators):</p>\n<blockquote>\n<p id=\"so_39559526_39559581_1\">The assignment operator (<code>=</code>) and the compound assignment operators all group right-to-left. All require a modifiable lvalue as their left operand <strong>and return an lvalue</strong> referring to the left operand.</p>\n</blockquote></li>\n</ul>\n<p>In the evolution of C++ from C, several expressions were made \"lvalue-aware\", as it were, because lvalues are much more important in C++ than in C. In C, everything is trivial (trivially copyable and trivially destructible, all in the words of C++), so lvalue-to-rvalue conversions (or \"lvalue conversions\", as C calls them) aren't painful. In C++, copying and destruction are non-trivial concepts, and by making expressions preserve lvalue-ness, a lot of copying and destructing can be avoided that was never necessary to begin with.</p>\n<p>Another example is the conditional expression (<code>a ? b : c</code>), which is not an lvalue in C, but can be a lvalue in C++.</p>\n<p>Another interesting artefact of this language evolution is that C has four well-defined storage durations (automatic, static, thread-local, dynamic), but in C++ this becomes more muddled, since temporary objects are a non-trivial concept in C++ that almost calls for its own storage duration. (E.g. Clang internally has a fifth, <a href=\"http://clang.llvm.org/doxygen/namespaceclang.html#a73616c07a633e772603049315dc55554\">\"full expression\" storage duration</a>.) Temporaries are of course the result of lvalue-to-rvalue conversion, so by avoiding the conversion, there's one less thing to worry about.</p>\n<p>(Please note that all of this discussion only applies to the respective core language expressions. C++ also has the separate, unrelated feature of <em>operator overloading</em>, which produces function call expressions, which have all the usual semantics of function calls and have nothing to do with operators except for the syntax. For example, you can define an overloaded <code>operator=</code> that returns a prvalue or <code>void</code> if you so wish.)</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2016-09-19T11:18:31.183", "Score": "56", "CreationDate": "2016-09-18T15:52:06.647", "ParentId": "39559526", "CommentCount": "13", "OwnerUserId": "596781", "LastEditDate": "2016-09-19T11:18:31.183"}, "bq_ids": {"n4140": {"so_39559526_39559581_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6173}}, "n3337": {"so_39559526_39559581_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5934}}, "n4659": {"so_39559526_39559581_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 7675}, "so_39559526_39559581_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 7675}}}, "39577101": {"Id": "39577101", "PostTypeId": "2", "Body": "<p>The following is a little speculation, so please correct me if I am wrong.</p>\n<p>When they invented operator overloading, they had to come up with a standard-looking general form of an assignment operator for any class <code>T</code>. For example:</p>\n<pre><code>T&amp; T::operator=(T);\nT&amp; T::operator=(const T&amp;);\n</code></pre>\n<p>Here, it returns a reference to <code>T</code>, instead of just <code>T</code> to make three-part assignment like <code>x = (y = z)</code> efficient, not requiring a copy.</p>\n<p>It could return a <code>const</code> reference to <code>T</code>, which would make unwanted assignment <code>(a = b) = c</code> an error. I <em>guess</em> that they didn't use this because of two reasons:</p>\n<ol>\n<li>Shorter code - don't need to write all these <code>const</code>s all the time (the fine details of <code>const</code>-correctness were not clear at that time)</li>\n<li>More flexibility - allows code like <code>(a = b).print()</code>, where <code>print</code> is a non-<code>const</code> method (because the programmer was lazy/ignorant of <code>const</code>-correctness)</li>\n</ol>\n<p>The semantics for primitive types (which are not <code>class</code>es) were kind-of extrapolated, to give:</p>\n<pre><code>int&amp; operator=(int&amp;, int); // not real code; just a concept\n</code></pre>\n<p>The \"return type\" is not <code>const int&amp;</code> so it matches the pattern with <code>class</code>es. So, if the buggy <code>(a = b) = c</code> code is valid for user-defined types, it should be valid also for built-in types, as required by <a href=\"https://en.wikipedia.org/wiki/C%2B%2B#Philosophy\" rel=\"nofollow\">C++ design principles</a>. And once you document this kind of stuff, you cannot change it because of backward compatibility.</p>\n", "LastEditorUserId": "509868", "LastActivityDate": "2016-09-19T15:51:21.123", "Score": "1", "CreationDate": "2016-09-19T15:44:21.793", "ParentId": "39559526", "CommentCount": "0", "OwnerUserId": "509868", "LastEditDate": "2016-09-19T15:51:21.123"}, "39559709": {"Id": "39559709", "PostTypeId": "2", "Body": "<p>Informally, in C++, for builtin types, the result of <code>a = b</code> is a reference to <code>a</code>; you can assign a value to that reference, just as with any other reference. So <code>(a = b) = c</code> assigns the value of <code>b</code> to <code>a</code>, and then assigns the value of <code>c</code> to <code>a</code>.</p>\n<p>For user-defined types this may not apply, although the usual idiom is for an assignment operator to return a reference to the left-hand argument, so the behavior of user-defined types mimics the behavior of builtin types:</p>\n<pre><code>struct S {\n    S&amp; operator=(const S&amp; rhs) {\n        return *this;\n    }\n};\n</code></pre>\n<p>Now, <code>S a, b, c; (a = b) = c;</code> means call <code>a.operator=(b)</code>, which returns a reference to <code>a</code>; then call <code>S::operator=</code> on that result and <code>c</code>, effectively calling <code>a.operator=(c)</code>.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2016-09-18T17:04:43.240", "Score": "21", "CreationDate": "2016-09-18T16:03:07.350", "ParentId": "39559526", "CommentCount": "9", "OwnerUserId": "1593860", "LastEditDate": "2016-09-18T17:04:43.240"}, "39559526": {"ViewCount": "4226", "Body": "<p>How does a statement like <code>(a = b) = c;</code> work in C++, assuming <code>a</code>,<code>b</code> and <code>c</code> are <code>int</code>s or any other primitive type?</p>\n", "AcceptedAnswerId": "39559709", "Title": "Why is (a = b) = c legal syntax in C++?", "CreationDate": "2016-09-18T15:46:12.657", "Id": "39559526", "CommentCount": "18", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2016-09-19T13:23:00.440", "LastEditorUserId": "5067077", "LastActivityDate": "2016-09-19T15:51:21.123", "ClosedDate": "2016-09-19T18:14:04.683", "Score": "31", "OwnerUserId": "5067077", "Tags": "<c++><operators>", "AnswerCount": "4"}});