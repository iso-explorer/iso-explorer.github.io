post_cb({"46935513": {"ParentId": "46341681", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard says an interesting thing at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp#inst-9\" rel=\"noreferrer\">[temp.inst]/9</a>:</p>\n<blockquote>\n<p id=\"so_46341681_46935513_0\">An implementation shall not implicitly instantiate a function\n  template, a variable template, a member template, a non-virtual member\n  function, a member class, a static data member of a class template, or\n  a substatement of a constexpr if statement, unless such instantiation\n  is required. It is unspecified whether or not an implementation\n  implicitly instantiates a virtual member function of a class template\n  if the virtual member function would not otherwise be instantiated.</p>\n</blockquote>\n<p>The decision of instantiating a virtual function is up to the implementation, but only if it is not needed otherwise. The question we are faced with is therefore: when is the definition needed according to the standard itself?</p>\n<p>The answer is at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.virtual#11\" rel=\"noreferrer\">[class.virtual]/11</a> and <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp#inst-2\" rel=\"noreferrer\">[temp.inst]/2</a>:</p>\n<blockquote>\n<p id=\"so_46341681_46935513_1\">A virtual function declared in a class shall be defined, or declared pure in that class, or both; no diagnostic is required</p>\n<p id=\"so_46341681_46935513_2\">The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the definitions, default arguments, or noexcept-specifiers of the class member functions</p>\n</blockquote>\n<p>So any instantiation of the class template, will instantiate a declaration of <code>Derived::foo</code>, which by a chain reaction requires a definition. So the definition <em>must be</em> instantiated too, if it is available.</p>\n<p>The only way an implementation can exercise the leeway it is given in the first quoted paragraph, is if <code>Derived::foo</code> is pure virtual too. As an example, both <a href=\"http://coliru.stacked-crooked.com/a/e8affc8edb4c8ceb\" rel=\"noreferrer\">Clang</a> and <a href=\"http://coliru.stacked-crooked.com/a/ef4055621c2623fc\" rel=\"noreferrer\">GCC</a> do just that. That of course is likely to be of limited help to you.</p>\n<p>So to make a long story short, it's a no-starter, so long as the function is virtual (and not pure virtual).</p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-10-25T15:56:07.090", "Id": "46935513", "Score": "10", "CreationDate": "2017-10-25T14:47:28.113", "LastActivityDate": "2017-10-25T15:56:07.090"}, "46341681": {"CommentCount": "9", "AcceptedAnswerId": "46935513", "PostTypeId": "1", "LastEditorUserId": "2352671", "CreationDate": "2017-09-21T10:35:35.557", "LastActivityDate": "2017-10-25T19:30:34.650", "LastEditDate": "2017-10-25T19:30:34.650", "ViewCount": "334", "FavoriteCount": "1", "Title": "How to static assert in a member function only if it is used?", "Id": "46341681", "Score": "11", "Body": "<p>I have the following scheme:</p>\n<pre><code>struct Baz {};\nstruct Qux {};\n\nstruct Base {\n  virtual ~Base() {}\n  virtual void foo() = 0;\n};\n\ntemplate&lt;typename T&gt; struct Identity { static bool const value = false; };\ntemplate&lt;typename T&gt; void bar(T) { static_assert(Identity&lt;T&gt;::value, \"Busted!!!\"); }\ntemplate&lt;&gt; void bar&lt;Baz&gt;(Baz) {}\n\ntemplate&lt;typename T&gt;\nstruct Derived : Base {\n  T m;\n  void foo() { bar(m); }\n};\n\nint main() {\n  Base *b0 = new Derived&lt;Baz&gt;;\n  b0-&gt;foo();\n  Base *b1 = new Derived&lt;Qux&gt;;\n  (void) b1;\n}\n</code></pre>\n<p>That is, I have a pure virtual class <code>Base</code> and a template class <code>Derived</code> that inherits from <code>Base</code> and overrides the pure virtual function <code>foo</code> as required. Now, inside <code>foo</code> I call function template <code>bar</code>. <code>bar</code> has a specialization for class <code>Baz</code> but not for class <code>Qux</code>. When in <code>main</code> I'm trying to materialize an object of <code>Derived&lt;Baz&gt;</code> everything's OK. But when I try to materialize an object of <code>Derived&lt;Qux&gt;</code> compiler hits <code>static_assert</code>.</p>\n<h2>Q:</h2>\n<p>Is there a way to transform my code in such a way that compiler will hit static assert in <code>Derived&lt;Qux&gt;</code> only if <code>Derived&lt;Qux&gt;::foo()</code> is called.</p>\n<p>That is, materializing an object of <code>Derived&lt;Qux&gt;</code> will pass:</p>\n<pre><code>Base *b1 = new Derived&lt;Qux&gt;;\n</code></pre>\n<p>But when later in code the programmer tries to call:</p>\n<pre><code>b1-&gt;foo(); // compile error static assert\n</code></pre>\n", "Tags": "<c++><inheritance><static-assert>", "OwnerUserId": "2352671", "AnswerCount": "2"}, "46940508": {"ParentId": "46341681", "CommentCount": "4", "Body": "<p>@StoryTeller gives a detailed answer referencing the spec, etc. but I'm going to push back on your question and ask what you are really trying to do. As the question is written, it is dead obvious the answer is \"no\" because you are asking for a compile time error on something that is only determinable at runtime. E.g.:</p>\n<pre><code>Base *b;\nif (user_input() == 42) {\n     b = new Derived&lt;Baz&gt;();\n} else {\n     b = new Derived&lt;Qux&gt;();\n}\nb-&gt;foo();\n</code></pre>\n<p>Do you want a compiler error for this case? If so you'll need to define the conditions under which you think <code>Qux::foo</code> should be considered to be \"called.\" At present the compiler is assuming a method defined as virtual in an instantiated class is called. Clearly you want something less conservative, but what?</p>\n<p>If you have more specific compile time type information, it may be possible to catch the error at runtime. E.g.</p>\n<pre><code>Derived&lt;Qux&gt; d = new Derived&lt;Qux&gt;();\nd-&gt;foo();\n</code></pre>\n<p>If <code>foo</code> is a non-virtual templated method, it is possible it could validate the base type at compile time and then dispatch to the virtual method. (It will likely require changing the signature of foo to have the type somehow.)</p>\n<p>A far better solution would be to break different types of functionality in the interface into different classes and introduce a mechanism to get specific interfaces on a given concrete class. This can be checked at compile time if you have the concretely types class in hand and at runtime if doing a dynamic lookup of an interface.</p>\n", "OwnerUserId": "3877787", "PostTypeId": "2", "Id": "46940508", "Score": "1", "CreationDate": "2017-10-25T19:21:05.837", "LastActivityDate": "2017-10-25T19:21:05.837"}, "bq_ids": {"n4140": {"so_46341681_46935513_2": {"section_id": 233, "quality": 0.8888888888888888, "length": 16}, "so_46341681_46935513_0": {"section_id": 243, "quality": 0.8780487804878049, "length": 36}, "so_46341681_46935513_1": {"section_id": 7012, "quality": 1.0, "length": 11}}, "n3337": {"so_46341681_46935513_2": {"section_id": 226, "quality": 0.8888888888888888, "length": 16}, "so_46341681_46935513_0": {"section_id": 235, "quality": 0.8292682926829268, "length": 34}, "so_46341681_46935513_1": {"section_id": 6758, "quality": 1.0, "length": 11}}, "n4659": {"so_46341681_46935513_2": {"section_id": 243, "quality": 0.9444444444444444, "length": 17}, "so_46341681_46935513_0": {"section_id": 250, "quality": 1.0, "length": 41}, "so_46341681_46935513_1": {"section_id": 8509, "quality": 1.0, "length": 11}}}});