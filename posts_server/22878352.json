post_cb({"bq_ids": {"n4140": {"so_22878352_22878981_3": {"length": 6, "quality": 1.0, "section_id": 3906}, "so_22878352_22878981_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6076}}, "n3337": {"so_22878352_22878981_3": {"length": 6, "quality": 1.0, "section_id": 3766}, "so_22878352_22878981_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 5844}}, "n4659": {"so_22878352_22878981_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 4792}, "so_22878352_22878981_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 7572}}}, "22878352": {"ViewCount": "233", "Body": "<p>So C/C++ arrays don't know about their length, right? But then how can the function <code>sizeof(array)</code> work and give us the proper size in bytes when it shouldn't be able to know the number of elements in the array?</p>\n", "AcceptedAnswerId": "22878444", "Title": "sizeof() in C/C++ for arrays", "CreationDate": "2014-04-05T08:15:49.343", "Id": "22878352", "CommentCount": "4", "LastEditDate": "2014-04-05T08:29:44.287", "PostTypeId": "1", "LastEditorUserId": "1009479", "LastActivityDate": "2014-04-05T09:22:22.713", "Score": "1", "OwnerUserId": "1113314", "Tags": "<c++><c><arrays><sizeof>", "AnswerCount": "2"}, "22878981": {"Id": "22878981", "PostTypeId": "2", "Body": "<p>I will quote the relevant portions of C99 standard. \u00a76.5.3.4 \u00b62 says</p>\n<blockquote>\n<p id=\"so_22878352_22878981_0\">The sizeof operator yields the size (in bytes) of its operand, which\n  may be an expression or the parenthesized name of a type. The size is\n  determined from the type of the operand. The result is an integer. If\n  the type of the operand is a variable length array type, the operand\n  is evaluated; otherwise, the operand is not evaluated and the result\n  is an integer constant.</p>\n</blockquote>\n<p>It also says in the same section \u00a76.5.3.4 \u00b61</p>\n<blockquote>\n<p id=\"so_22878352_22878981_1\">The sizeof operator shall not be applied to an expression that has\n  function type or an incomplete type.</p>\n</blockquote>\n<p>About the array type, \u00a76.2.5 \u00b620 says</p>\n<blockquote>\n<p id=\"so_22878352_22878981_2\">An array type describes a contiguously allocated nonempty set of\n  objects with a particular member object type, called the element type.\n  Array types are characterized by their element type and by the number\n  of elements in the array.</p>\n</blockquote>\n<p>It again says in \u00a76.2.5 \u00b622</p>\n<blockquote>\n<p id=\"so_22878352_22878981_3\">An array type of unknown size is an incomplete type.</p>\n</blockquote>\n<hr>\n<p>So to summarize the above, the size of an array is known to the compiler (determined using <code>sizeof</code> operator) when you also specify the size of the array, i.e, when it's a complete type. </p>\n</hr>", "LastActivityDate": "2014-04-05T09:22:22.713", "CommentCount": "0", "CreationDate": "2014-04-05T09:22:22.713", "ParentId": "22878352", "Score": "1", "OwnerUserId": "1809377"}, "22878444": {"Id": "22878444", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22878352_22878444_0\">So C/C++ arrays don't know about their length, right.</p>\n</blockquote>\n<p>Your assumption is wrong. With the exception of variable length arrays introduced in C99, arrays in both C and C++ have a size that is known in compile time. The compiler knows their size.</p>\n<p>Your confusion is probably because there are times when array names decay into a pointer to its first element (like when passed as function argument), it's true that the size information is lost here. </p>\n<p>But when <code>sizeof</code> is used on an array, the array is not converted to a pointer. This is your other confusion: <code>sizeof</code> is <strong>not</strong> a function, it's an operator.</p>\n", "LastActivityDate": "2014-04-05T08:25:11.327", "CommentCount": "72", "CreationDate": "2014-04-05T08:25:11.327", "ParentId": "22878352", "Score": "7", "OwnerUserId": "1009479"}});