post_cb({"10364050": {"CommentCount": "0", "ViewCount": "205", "CreationDate": "2012-04-28T13:43:05.633", "LastActivityDate": "2012-04-28T13:58:50.367", "Title": "what is the type of an iterator in STL?", "AcceptedAnswerId": "10364130", "PostTypeId": "1", "Id": "10364050", "Score": "0", "Body": "<p>Every Variable in c++ has some type like in <code>int i</code> , <code>i</code> has a type <code>int</code> .\nSimilarly we have iterators in STL which we declare say something like this</p>\n<pre><code>       map&lt;string,int&gt;::iterator it .\n</code></pre>\n<p>What is the type of the <code>it</code> over here ? Is it pointer type or is it a pointer type as \nwe gerally deference iterators to fetch values associated or pointed by those itearors in case of vectors which store int or some other type.? Or the operator <code>*</code> is overloaded for iterators in STL ? </p>\n", "Tags": "<c++><stl>", "OwnerUserId": "1103956", "AnswerCount": "2"}, "10364064": {"ParentId": "10364050", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_10364050_10364064_0\">What is the type of the <code>it</code>?</p>\n</blockquote>\n<p>The type of <code>it</code> is <code>map&lt;string,int&gt;::iterator</code>, which is a class with a bunch of operators overloaded.</p>\n<p>For some container types, <code>Container::iterator</code> <em>may</em> be a raw pointer type. For <code>map</code>, it has to be a class.</p>\n", "OwnerUserId": "367273", "LastEditorUserId": "367273", "LastEditDate": "2012-04-28T13:52:53.880", "Id": "10364064", "Score": "6", "CreationDate": "2012-04-28T13:45:09.997", "LastActivityDate": "2012-04-28T13:52:53.880"}, "10364130": {"ParentId": "10364050", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>24.2.1/1 [iterator.requirements.general] sums it up nicely:</p>\n<blockquote>\n<p id=\"so_10364050_10364130_0\">Iterators are a generalization of pointers that allow a C++ program to work with different data structures (containers) in a uniform manner. To be able to construct template algorithms that work correctly and efficiently on different types of data structures, the library formalizes not just the interfaces but also the semantics and complexity assumptions of iterators.</p>\n</blockquote>\n<p>The phrase \"generalization of pointers\" means that pointers <em>are</em> iterators. <code>std::vector&lt;T&gt;::iterator</code> is allowed to be a typedef <code>T *</code>. However, most iterators achieve the interface by operator overloading. (Note that iterators don't need to belong to containers, either.)</p>\n<p>Such language is very typical of the way the C++ standard is written. It describes how things behave, but avoids defining interfaces in terms of base classes. There are various kinds of iterators: input, output, forward, bidirectional, and random-access. Each has a different specification, and although random-access is a strict superset of the bidirectional interface, they are totally unrelated in the C++ type system.</p>\n<p>An iterator can be any class with <code>++</code> and <code>*</code> overloaded, and a valid specialization of <code>std::iterator_traits</code>. There <em>is</em> a base class <code>std::iterator</code> which works with <code>std::iterator_traits</code> to define the necessary interface. It is a good case study in C++ generic programming and traits classes.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2012-04-28T13:58:50.367", "Id": "10364130", "Score": "4", "CreationDate": "2012-04-28T13:51:52.583", "LastActivityDate": "2012-04-28T13:58:50.367"}, "bq_ids": {"n4140": {"so_10364050_10364130_0": {"section_id": 5555, "quality": 1.0, "length": 32}}, "n3337": {"so_10364050_10364130_0": {"section_id": 5337, "quality": 1.0, "length": 32}}, "n4659": {"so_10364050_10364130_0": {"section_id": 7000, "quality": 1.0, "length": 32}}}});