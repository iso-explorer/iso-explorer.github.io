post_cb({"33706588": {"ParentId": "33706528", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In general, don't do that. If you are using user defined types with <em>non-trivial initialization</em>, in case of reallocation-copy-freeing, the <strong>destructor of your objects won't get called</strong> by <code>realloc</code>. The copy <strong>constructor won't be called</strong> too, when copying. This may lead to undefined behavior due to an incorrect use of <em>object lifetime</em> (see <em>C++ Standard \u00a73.8 Object lifetime, [basic.life]</em>).</p>\n<blockquote>\n<p id=\"so_33706528_33706588_0\">1 The lifetime of an object is a runtime property of the object. An object is said to have non-trivial initialization if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial default constructor. [ Note: initialization by a trivial copy/move constructor is non-trivial initialization. \u2014end note ] </p>\n<p id=\"so_33706528_33706588_1\">The lifetime of an object of type T begins when:</p>\n<p id=\"so_33706528_33706588_2\">\u2014 storage with the proper alignment and size for type T is obtained, and</p>\n<p id=\"so_33706528_33706588_3\">\u2014 if the object has non-trivial initialization, its initialization is complete.</p>\n<p id=\"so_33706528_33706588_4\">The lifetime of an object of type T ends when:</p>\n<p id=\"so_33706528_33706588_5\">\u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_33706528_33706588_6\">\u2014 the storage which the object occupies is reused or released.</p>\n</blockquote>\n<p>And later (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33706528_33706588_7\">3 The properties ascribed to objects throughout this International Standard apply for a given object <strong>only during its lifetime</strong>.</p>\n</blockquote>\n<p>So, you really don't want to use an object <strong>out of its lifetime</strong>.</p>\n", "OwnerUserId": "2508150", "LastEditorUserId": "2508150", "LastEditDate": "2015-11-14T08:52:59.973", "Id": "33706588", "Score": "7", "CreationDate": "2015-11-14T08:32:48.447", "LastActivityDate": "2015-11-14T08:52:59.973"}, "33706568": {"ParentId": "33706528", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You can only <code>realloc</code> that which has been allocated via <code>malloc</code> (or family, like <code>calloc</code>).</p>\n<p>That's because the underlying data structures that keep track of free and used areas of memory, can be quite different.</p>\n<p>It's <em>likely</em> but by no means guaranteed that C++ <code>new</code> and C <code>malloc</code> use the same underlying allocator, in which case <code>realloc</code> could work for both. But formally that's in UB-land. And in practice it's just needlessly risky.</p>\n<hr>\n<p>C++ does not offer functionality corresponding to <code>realloc</code>.</p>\n<p>The closest is the automatic reallocation of (the internal buffers of) containers like <code>std::vector</code>.</p>\n<p>The C++ containers suffer from being designed in a way that excludes use of <code>realloc</code>.</p>\n<hr>\n<p>Instead of the presented code</p>\n<pre><code>int* data = new int[3];\n//...\nint* mydata = (int*)realloc(data,6*sizeof(int));\n</code></pre>\n<p>\u2026 do this:</p>\n<pre><code>vector&lt;int&gt; data( 3 );\n//...\ndata.resize( 6 );\n</code></pre>\n<p>However, if you absolutely need the general efficiency of <code>realloc</code>, and if you have to accept <code>new</code> for the original allocation, then your only recourse for efficiency is to use compiler-specific means, knowledge that <code>realloc</code> is safe with this compiler.</p>\n<p>Otherwise, if you absolutely need the general efficiency of <code>realloc</code> but is not forced to accept <code>new</code>, then you can use <code>malloc</code> and <code>realloc</code>. Using smart pointers then lets you get much of the same safety as with C++ containers.</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "343721", "LastEditDate": "2015-11-17T12:54:25.273", "Id": "33706568", "Score": "39", "CreationDate": "2015-11-14T08:30:13.110", "LastActivityDate": "2015-11-17T12:54:25.273"}, "33706528": {"CommentCount": "12", "AcceptedAnswerId": "33706568", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-14T08:25:02.673", "LastActivityDate": "2015-11-17T12:54:25.273", "LastEditDate": "2017-05-23T12:34:05.947", "ViewCount": "4078", "FavoriteCount": "7", "Title": "Is it safe to realloc memory allocated with new?", "Id": "33706528", "Score": "24", "Body": "<p>From what is written <a href=\"https://stackoverflow.com/questions/1350819/c-free-store-vs-heap\">here</a>, <code>new</code> allocates in <em>free store</em> while <code>malloc</code> uses <em>heap</em> and the two terms often mean the same thing.</p>\n<p>From what is written <a href=\"http://www.cplusplus.com/reference/cstdlib/realloc/\" rel=\"nofollow noreferrer\">here</a>, <code>realloc</code> may move the memory block to a new location. If free store and heap are two different memory spaces, does it mean any problem then?</p>\n<p>Specifically I'd like to know if it is safe to use</p>\n<pre><code>int* data = new int[3];\n// ...\nint* mydata = (int*)realloc(data,6*sizeof(int));\n</code></pre>\n<p>If not, is there any other way to <code>realloc</code> memory allocated with <code>new</code> safely? I could allocate new area and <code>memcpy</code> the contents, but from what I understand <code>realloc</code> may use the same area if possible.</p>\n", "Tags": "<c++><memory-management><realloc>", "OwnerUserId": "343721", "AnswerCount": "9"}, "33706603": {"ParentId": "33706528", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You may be able to (not in all cases), but you shouldn't. If you need to resize your data table, you should use <code>std::vector</code> instead.</p>\n<p>Details on how to use it are listed in an other <a href=\"https://stackoverflow.com/questions/3482941/how-do-you-realloc-in-c\">SO question</a>.</p>\n", "OwnerUserId": "3371101", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:10.760", "Id": "33706603", "Score": "3", "CreationDate": "2015-11-14T08:34:28.830", "LastActivityDate": "2015-11-14T08:34:28.830"}, "33706598": {"ParentId": "33706528", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>That is not safe. Firstly the pointer you pass to <code>realloc</code>  must have been obtained from <code>malloc</code> or <code>realloc</code>: <a href=\"http://en.cppreference.com/w/cpp/memory/c/realloc\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/memory/c/realloc</a>.</p>\n<p>Secondly the result of <code>new int [3]</code> need not be the same as the result of the allocation function - extra space may be allocated to store the count of elements.</p>\n<p>(And for more complex types than <code>int</code>, <code>realloc</code> wouldn't be safe since it doesn't call copy or move constructors.)</p>\n", "OwnerUserId": "212870", "LastEditorUserId": "212870", "LastEditDate": "2015-11-14T08:39:46.597", "Id": "33706598", "Score": "4", "CreationDate": "2015-11-14T08:34:02.853", "LastActivityDate": "2015-11-14T08:39:46.597"}, "33707789": {"ParentId": "33706528", "CommentCount": "1", "Body": "<p>These function is mostly used in C.</p>\n<p>memset sets the bytes in a block of memory to a specific value.</p>\n<p>malloc allocates a block of memory.</p>\n<p>calloc, same as malloc. Only difference is that it initializes the bytes to zero.</p>\n<p>In C++ the preferred method to allocate memory is to use new.</p>\n<p>C:\u00a0int\u00a0intArray = (int*) malloc(10 *sizeof(int));\nC++:\u00a0int\u00a0intArray =\u00a0new\u00a0int[10];</p>\n<p>C:\u00a0int\u00a0intArray = (int*) calloc(10 *sizeof(int));\nC++:\u00a0int\u00a0intArray =\u00a0new\u00a0int10;</p>\n", "OwnerUserId": "5480314", "PostTypeId": "2", "Id": "33707789", "Score": "0", "CreationDate": "2015-11-14T11:14:37.760", "LastActivityDate": "2015-11-14T11:14:37.760"}, "33706612": {"ParentId": "33706528", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The only possibly relevant restriction C++ adds to <code>realloc</code> is that C++'s <code>malloc</code>/<code>calloc</code>/<code>realloc</code> must not be implemented in terms of <code>::operator new</code>, and its <code>free</code> must not be implemented in terms of <code>::operator delete</code> (per C++14 [c.malloc]p3-4).</p>\n<p>This means the guarantee you are looking for does not exist in C++. It also means, however, that you can implement <code>::operator new</code> in terms of <code>malloc</code>. And if you do that, then in theory, <code>::operator new</code>'s result can be passed to <code>realloc</code>.</p>\n<p>In practice, you should be concerned about the possibility that <code>new</code>'s result does not match <code>::operator new</code>'s result. C++ compilers may e.g. combine multiple <code>new</code> expressions to use one single <code>::operator new</code> call. This is something compilers already did when the standard didn't allow it, IIRC, and the standard now does allow it (per C++14 [expr.new]p10). That means that even if you go this route, you still don't have a guarantee that passing your <code>new</code> pointers to <code>realloc</code> does anything meaningful, even if it's no longer undefined behaviour.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2015-11-14T08:59:05.747", "Id": "33706612", "Score": "12", "CreationDate": "2015-11-14T08:36:10.103", "LastActivityDate": "2015-11-14T08:59:05.747"}, "33718763": {"ParentId": "33706528", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In general, no.</p>\n<p>There are a slew of things which must hold to make it safe:</p>\n<ol>\n<li>Bitwise copying the type and abandoning the source must be safe.</li>\n<li>The destructor must be trivial, or you must in-place-destruct the elements you want to deallocate.</li>\n<li>Either the constructor is trivial, or you must in-place-construct the new elements.</li>\n</ol>\n<p>Trivial types satisfy the above requirements.</p>\n<p>In addition:</p>\n<ol>\n<li>The <code>new[]</code>-function must pass the request on to <code>malloc</code> without any change, nor do any bookkeeping on the side. You can force this by replacing global new[] and delete[], or the ones in the respective classes.</li>\n<li>The compiler must not ask for more memory in order to save the number of elements allocated, or anything else.<br>\nThere is no way to force that, though a compiler shouldn't save such information if the type has a trivial destructor as a matter of <em>Quality of Implementation</em>.</br></li>\n</ol>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2015-11-15T10:42:55.653", "Id": "33718763", "Score": "3", "CreationDate": "2015-11-15T10:37:10.890", "LastActivityDate": "2015-11-15T10:42:55.653"}, "33706578": {"ParentId": "33706528", "CommentCount": "3", "Body": "<p>It is not safe, and it's not elegant.</p>\n<p>It might be possible to override new/delete to support the reallocation, but then you may as well consider to use the containers.</p>\n", "OwnerUserId": "1094101", "PostTypeId": "2", "Id": "33706578", "Score": "5", "CreationDate": "2015-11-14T08:31:36.067", "LastActivityDate": "2015-11-14T08:31:36.067"}, "bq_ids": {"n4140": {"so_33706528_33706588_7": {"section_id": 7191, "quality": 0.8461538461538461, "length": 11}, "so_33706528_33706588_2": {"section_id": 7189, "quality": 1.0, "length": 6}, "so_33706528_33706588_0": {"section_id": 7189, "quality": 0.8484848484848485, "length": 28}, "so_33706528_33706588_5": {"section_id": 7189, "quality": 0.875, "length": 7}, "so_33706528_33706588_6": {"section_id": 7189, "quality": 1.0, "length": 5}, "so_33706528_33706588_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_33706528_33706588_3": {"section_id": 7189, "quality": 1.0, "length": 6}, "so_33706528_33706588_4": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_33706528_33706588_7": {"section_id": 6935, "quality": 0.8461538461538461, "length": 11}, "so_33706528_33706588_2": {"section_id": 6933, "quality": 1.0, "length": 6}, "so_33706528_33706588_0": {"section_id": 6933, "quality": 0.8484848484848485, "length": 28}, "so_33706528_33706588_5": {"section_id": 6933, "quality": 0.875, "length": 7}, "so_33706528_33706588_6": {"section_id": 6933, "quality": 1.0, "length": 5}, "so_33706528_33706588_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_33706528_33706588_3": {"section_id": 6933, "quality": 1.0, "length": 6}, "so_33706528_33706588_4": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_33706528_33706588_2": {"section_id": 8697, "quality": 1.0, "length": 6}, "so_33706528_33706588_7": {"section_id": 8700, "quality": 0.8461538461538461, "length": 11}, "so_33706528_33706588_3": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_33706528_33706588_5": {"section_id": 8697, "quality": 0.875, "length": 7}, "so_33706528_33706588_6": {"section_id": 8701, "quality": 1.0, "length": 5}, "so_33706528_33706588_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_33706528_33706588_0": {"section_id": 8697, "quality": 0.7272727272727273, "length": 24}, "so_33706528_33706588_4": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}, "33706587": {"ParentId": "33706528", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Yes - if <code>new</code> actually called <code>malloc</code> in the first place (for example, this is how VC++ <code>new</code> works).</p>\n<p>No otherwise. do note that once you decide to reallocate the memory (because <code>new</code> called <code>malloc</code>), your code is compiler specific and not portable between compilers anymore.</p>\n<p>(I know this answer may upset many developers, but I answer depends on real facts, not just idiomaticy).</p>\n", "OwnerUserId": "3613500", "LastEditorUserId": "3613500", "LastEditDate": "2015-11-14T08:39:42.440", "Id": "33706587", "Score": "5", "CreationDate": "2015-11-14T08:32:46.500", "LastActivityDate": "2015-11-14T08:39:42.440"}});