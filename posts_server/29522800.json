post_cb({"29523073": {"Id": "29523073", "PostTypeId": "2", "Body": "<p>The process of determining the function to call based on the arguments is called overload resolution, and the standard lists in which cases it gets used:</p>\n<blockquote>\n<p id=\"so_29522800_29523073_0\"><strong>13.3 Overload resolution [over.match]</strong></p>\n<p id=\"so_29522800_29523073_1\">2 Overload resolution selects the function to call in seven distinct contexts within the language:</p>\n<p id=\"so_29522800_29523073_2\">(2.1) -- invocation of a function named in the function call syntax (13.3.1.1.1);</p>\n<p id=\"so_29522800_29523073_3\">(2.2) -- invocation of a function call operator, a pointer-to-function conversion function, a reference-to-pointer-to-function conversion function, or a reference-to-function conversion function on a class object named\n  in the function call syntax (13.3.1.1.2);</p>\n<p id=\"so_29522800_29523073_4\">(2.3) -- invocation of the operator referenced in an expression (13.3.1.2);</p>\n<p id=\"so_29522800_29523073_5\">(2.4) -- invocation of a constructor for direct-initialization (8.5) of a class object (13.3.1.3);</p>\n<p id=\"so_29522800_29523073_6\">(2.5) -- invocation of a user-defined conversion for copy-initialization (8.5) of a class object (13.3.1.4);</p>\n<p id=\"so_29522800_29523073_7\">(2.6) -- invocation of a conversion function for initialization of an object of a nonclass type from an expression of class type (13.3.1.5); and</p>\n<p id=\"so_29522800_29523073_8\">(2.7) -- invocation of a conversion function for conversion to a glvalue or class prvalue to which a reference (8.5.3) will be directly bound (13.3.1.6).</p>\n</blockquote>\n<p>Of these, the <em>only</em> one that applies to regular functions is 2.1, and that requires a <code>f(args)</code> context which only tells the caller the result.</p>\n<p>So, what you ask for cannot be done. Not exactly, anyway.</p>\n<p>Now, depending on what you want to accomplish, there are some things that <em>are</em> possible:</p>\n<p>It is possible to get a pointer to the function if you know the <em>exact</em> signature: given <code>template &lt;typename T&gt; int hello(A&lt;T&gt; a, A&lt;T&gt; b)</code>, you can obtain the address using that: <code>static_cast&lt;int(*)(A&lt;int&gt;,A&lt;int&gt;)&gt;(hello)</code>. However, for this to work, you need to know the return type (which you might be able to obtain using <code>decltype</code>), and you need to know the parameter types (which may be different from the argument types, and which you aren't able to obtain reliably).</p>\n<p>It is also possible to get a pointer to a function that, when called, will have the same effect as <code>hello</code>:</p>\n<pre><code>auto callable = +[](A&lt;int&gt; a, A&lt;int&gt; b) { return hello(a, b); };\n</code></pre>\n<p>The <code>[](A&lt;int&gt; a, A&lt;int&gt; b) { return hello(a, b); }</code> creates a lambda without any captures, and lambdas without any captures can implicitly be converted to a function pointer of a matching type. The <code>+</code> forces the use of that conversion, without requiring the type to be spelled out.</p>\n<p>However, this will not have the same address as <code>hello</code>, so might not be suitable for subsequent comparisons.</p>\n<p>That's the best you can get.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2015-04-08T19:00:32.077", "Score": "8", "CreationDate": "2015-04-08T18:55:52.887", "ParentId": "29522800", "CommentCount": "4", "OwnerUserId": "743382", "LastEditDate": "2015-04-08T19:00:32.077"}, "29524105": {"Id": "29524105", "PostTypeId": "2", "Body": "<p>I tried this in <a href=\"http://ideone.com/NGknrj\" rel=\"nofollow\">Ideone</a>:</p>\n<pre><code>// A and hello defined as OP\nint main()\n{\n    A&lt;int&gt; a;\n    A&lt;float&gt; b;\n\n    decltype(hello(a,b,3)) (*pf)(decltype(a), decltype(b), decltype(3))=hello;\n    std::cout &lt;&lt; (void*)pf &lt;&lt; \"\\n\";                                                                                                                                                           \n\n    return 0;\n}\n</code></pre>\n<p>It seemed to output a memory address.</p>\n", "LastEditorUserId": "4834", "LastActivityDate": "2015-04-09T09:52:48.263", "Score": "2", "CreationDate": "2015-04-08T19:51:46.317", "ParentId": "29522800", "CommentCount": "3", "OwnerUserId": "4834", "LastEditDate": "2015-04-09T09:52:48.263"}, "29522800": {"ViewCount": "815", "Body": "<p>I would like to know if there is any way to obtain the address of the instantiation of a function template produced by a specific set of arguments.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nclass A {}; \n\ntemplate &lt;typename T, typename T2&gt;\nint hello(A&lt;T&gt; a, A&lt;T2&gt; b, int c)\n{\n    return 69; \n}\n\nint main()\n{\n    A&lt;int&gt; a;\n    A&lt;float&gt; b;\n    std::cout &lt;&lt; (&amp;hello)(a, b, 3) &lt;&lt; \"\\n\";                                                                                                                                                           \n\n    return 0;\n}\n</code></pre>\n<p>This code prints the value returned by the function call. How can I print the address of the version of \"hello\" instantiated for a and b parameters? I would like the types to be inferred by the compiler.</p>\n", "Title": "Is it possible to obtain the address of a implicit instantiation of a function template?", "CreationDate": "2015-04-08T18:39:40.933", "LastActivityDate": "2015-04-09T18:55:37.453", "CommentCount": "18", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-04-08T20:32:10.187", "LastEditorUserId": "845092", "Id": "29522800", "Score": "11", "OwnerUserId": "4765519", "Tags": "<c++><templates><c++11>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29522800_29523073_8": {"length": 11, "quality": 0.8461538461538461, "section_id": 563}, "so_29522800_29523073_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 563}, "so_29522800_29523073_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 563}, "so_29522800_29523073_7": {"length": 10, "quality": 0.9090909090909091, "section_id": 563}, "so_29522800_29523073_4": {"length": 4, "quality": 0.8, "section_id": 563}, "so_29522800_29523073_1": {"length": 10, "quality": 1.0, "section_id": 563}, "so_29522800_29523073_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 563}, "so_29522800_29523073_3": {"length": 19, "quality": 0.95, "section_id": 563}}, "n3337": {"so_29522800_29523073_8": {"length": 11, "quality": 0.8461538461538461, "section_id": 554}, "so_29522800_29523073_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 554}, "so_29522800_29523073_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 554}, "so_29522800_29523073_7": {"length": 10, "quality": 0.9090909090909091, "section_id": 554}, "so_29522800_29523073_4": {"length": 4, "quality": 0.8, "section_id": 554}, "so_29522800_29523073_1": {"length": 10, "quality": 1.0, "section_id": 554}, "so_29522800_29523073_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 554}, "so_29522800_29523073_3": {"length": 19, "quality": 0.95, "section_id": 554}}, "n4659": {"so_29522800_29523073_8": {"length": 11, "quality": 0.8461538461538461, "section_id": 586}, "so_29522800_29523073_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 586}, "so_29522800_29523073_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 586}, "so_29522800_29523073_1": {"length": 10, "quality": 1.0, "section_id": 586}, "so_29522800_29523073_4": {"length": 4, "quality": 0.8, "section_id": 586}, "so_29522800_29523073_7": {"length": 10, "quality": 0.9090909090909091, "section_id": 586}, "so_29522800_29523073_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 586}, "so_29522800_29523073_3": {"length": 19, "quality": 0.95, "section_id": 586}}}, "29538905": {"Id": "29538905", "PostTypeId": "2", "Body": "<p>@hvd: AFAIK, you cannot declare a lambda without knowing the signature of the function you wanna wrap (lambdas cannot be templated). But you can use an intermediate class with a static method instead:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;class A&gt;\nvoid func(A a, int b)\n{\n    std::cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \" b=\" &lt;&lt; b &lt;&lt; \"\\n\";\n}\n\ntemplate&lt;class... A&gt;\nclass proxy_func\n{\npublic:\n    static auto call(A... args) -&gt; decltype(func(args...))\n        {\n            return func(args...);\n        }\n};\n\ntemplate&lt;template&lt;class...&gt; class P, class... User&gt;\nvoid* addr(User... user)\n{\n    return (void*)&amp;P&lt;User...&gt;::call;\n}\n\ntemplate&lt;template&lt;class...&gt; class P, class... User&gt;\nauto call(User... user) -&gt; decltype(P&lt;User...&gt;::call(user...))\n{\n    return P&lt;User...&gt;::call(user...);\n}\n\ntemplate&lt;class T&gt;\nvoid test()\n{\n    T value = 1;\n    printf(\"func &gt; %p\\n\", &amp;func&lt;T&gt;);\n    printf(\"func &gt; \");\n    func(value, 1);\n    printf(\"proxy&gt; %p\\n\", &amp;proxy_func&lt;T, int&gt;::call);\n    printf(\"proxy&gt; \");\n    proxy_func&lt;T, int&gt;::call(value, 1);\n    printf(\"auto &gt; %p\\n\", addr&lt;proxy_func&gt;(value, 1));\n    printf(\"auto &gt; \");\n    call&lt;proxy_func&gt;(value, 1);\n}\n\nint main(int argc, char **argv)\n{\n    printf(\"==int==\\n\");\n    test&lt;int&gt;();\n    printf(\"==long==\\n\");\n    test&lt;long&gt;();\n}\n</code></pre>\n<p>The result is this:</p>\n<pre><code>g++ -std=c++11 -o /tmp/test /tmp/test.cpp &amp;&amp; /tmp/test\n==int==\nfunc &gt; 0x400a8d\nfunc &gt; a=1 b=1\nproxy&gt; 0x400ae6\nproxy&gt; a=1 b=1\nauto &gt; 0x400ae6\nauto &gt; a=1 b=1\n==long==\nfunc &gt; 0x400b35\nfunc &gt; a=1 b=1\nproxy&gt; 0x400b91\nproxy&gt; a=1 b=1\nauto &gt; 0x400b91\nauto &gt; a=1 b=1\n</code></pre>\n<p>Of course, this requires declaring a generic proxy that knows about the <em>name</em> of the target function (nothing else), and that might not be acceptable as a solution for @JavierCabezasRodr\u00edguez.</p>\n<p>PS: Sorry I did not post it as a comment, but I do not have enough reputation for it.</p>\n<p><strong>Edit</strong></p>\n<p>Using a proxy class instead of a lambda forgoes the need to know the number of parameters, so that you can use a hackishly macro approach to wrap any target function:</p>\n<pre><code>#define proxy(f)                                \\\n    template&lt;class... A&gt;                        \\\n    class proxy_ ## f                           \\\n    {                                           \\\n    public:                                                     \\\n        static auto call(A... args) -&gt; decltype(f(args...))     \\\n        {                                                       \\\n            return f(args...);                                  \\\n        }                                                       \\\n    }\n\nproxy(func);\n</code></pre>\n", "LastEditorUserId": "4766202", "LastActivityDate": "2015-04-09T18:55:37.453", "Score": "1", "CreationDate": "2015-04-09T12:45:53.750", "ParentId": "29522800", "CommentCount": "3", "OwnerUserId": "4766202", "LastEditDate": "2015-04-09T18:55:37.453"}});