post_cb({"bq_ids": {"n4140": {"so_42894356_42894356_0": {"length": 79, "quality": 0.8777777777777778, "section_id": 43}}, "n3337": {"so_42894356_42894356_0": {"length": 83, "quality": 0.9222222222222223, "section_id": 40}}, "n4659": {"so_42894356_42894356_0": {"length": 79, "quality": 0.8777777777777778, "section_id": 43}}}, "42894356": {"ViewCount": "64", "Body": "<p>I'm working in some code using the Curiously Recurring Template Pattern, where the derived class is passed up to specialize its own base classes at compile time.</p>\n<p>With this, I run into an annoying problem which I have made a toy example for. I have annotated base::bar with comments describing the expected behavior (and why I expect it). The entire example is intended to be compiled as is, and results in 3 compiler errors (clang-3.9) as noted in the comments. For reference, $4.11/2:</p>\n<blockquote>\n<p id=\"so_42894356_42894356_0\">A prvalue of type \u201cpointer to member of B of type cv T\u201d, where B is a class type, can be converted to a\n  prvalue of type \u201cpointer to member of D of type cv T\u201d, where D is a derived class (Clause 10) of B. If B is\n  an inaccessible (Clause 11), ambiguous (10.2), or virtual (10.1) base class of D, or a base class of a virtual\n  base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion refers\n  to the same member as the pointer to member before the conversion took place, but it refers to the base\n  class member as if it were a member of the derived class. The result refers to the member in D\u2019s instance of B. Since the result has type \u201cpointer to member of D of type cv T\u201d, it can be dereferenced with a D object.\n  The result is the same as if the pointer to member of B were dereferenced with the B subobject of D. The\n  null member pointer value is converted to the null member pointer value of the destination type.57</p>\n</blockquote>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename impl_t&gt;\nstruct super\n{\n        typedef int impl_t::* member_dat_t;\n\n    protected:\n        template&lt;member_dat_t dat&gt;\n        int foo()\n        {\n                return static_cast&lt;impl_t *&gt;(this)-&gt;*dat;\n        }\n};\n\ntemplate&lt;typename impl_t&gt;\nstruct base : super&lt;impl_t&gt;\n{\n        using this_t = base&lt;impl_t&gt;;\n        int base_dat = 0;\n\n        int bar()\n        {\n                // This, of course, succeeds\n                this-&gt; template foo&lt;&amp;impl_t::derived_dat&gt;();\n\n                // This fails during template instantiation, because the compiler knows that the\n                // location of base_dat/base_func is in the base&lt;derived&gt; subobject of a derived\n                // object rather than derived itself.\n                this-&gt; template foo&lt;&amp;impl_t::base_dat&gt;();\n                // (i.e., this succeeds, despite the address being taken on a member resolved off the impl_t)\n                static_assert(std::is_same&lt;int this_t::*, decltype((&amp;impl_t::base_dat))&gt;::value, \"\");\n\n                // But what if we cast, as the standard (N3242) permits in $4.11/2 [conv.mem]\n                // Now, these succeed\n                static_assert(std::is_same&lt;int impl_t::*, decltype((static_cast&lt;int impl_t::*&gt;(&amp;impl_t::base_dat)))&gt;::value, \"\");\n                static_assert(std::is_same&lt;typename super&lt;impl_t&gt;::member_dat_t, decltype((static_cast&lt;int impl_t::*&gt;(&amp;impl_t::base_dat)))&gt;::value, \"\");\n                // But these still fail\n                this-&gt; template foo&lt;static_cast&lt;int impl_t::*&gt;(&amp;impl_t::base_dat)&gt;();\n                this-&gt; template foo&lt;static_cast&lt;typename super&lt;impl_t&gt;::member_dat_t&gt;(&amp;impl_t::base_dat)&gt;();\n                return 1;\n        }\n};\n\nstruct derived : base&lt;derived&gt;\n{\n        int derived_dat;\n};\n\nvoid test()\n{\n        derived d;\n        d.bar();\n}\n</code></pre>\n<p>For the \"why\": the existing code in <code>base</code> only ever instantiates <code>super::foo</code> with members actually defined in <code>derived</code>. It would please me if I could also use members defined in <code>base&lt;derived&gt;</code>, inherited by <code>derived</code>. The actual code is using member functions, but member data sufficed for the example.</p>\n<p>Edit:\nI've technically come up with a solution that should work. Basically, <code>base</code> derives from <code>super&lt;base&lt;impl_t&gt;&gt;</code> instead of <code>super&lt;impl_t&gt;</code>, so now we can invoke <code>foo</code> with members of <code>base&lt;impl_t&gt;</code>, and if we need different behavior from the most-derived classes, we can make the methods in base virtual. But this throws away a little of the benefit of CRTP (we now have VTBL in the objects, and the cost of dynamic polymorphism, even when we know at compile time what we want).</p>\n<p>Thanks</p>\n", "Title": "downcasted pointer to member as template argument", "CreationDate": "2017-03-20T01:07:19.840", "LastActivityDate": "2017-03-20T02:49:41.183", "CommentCount": "0", "LastEditDate": "2017-03-20T02:49:41.183", "PostTypeId": "1", "LastEditorUserId": "4839527", "Id": "42894356", "Score": "2", "OwnerUserId": "4839527", "Tags": "<c++><templates><casting><member-pointers>", "AnswerCount": "0"}});