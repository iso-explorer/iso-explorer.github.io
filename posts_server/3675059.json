post_cb({"3675092": {"Id": "3675092", "PostTypeId": "2", "Body": "<p><a href=\"http://www.stroustrup.com/bs_faq2.html#placement-delete\" rel=\"nofollow noreferrer\">One example</a> is at Stroustrup's FAQ.</p>\n", "LastEditorUserId": "2685386", "LastActivityDate": "2014-08-19T08:42:32.583", "Score": "2", "CreationDate": "2010-09-09T08:52:46.550", "ParentId": "3675059", "CommentCount": "2", "OwnerUserId": "66692", "LastEditDate": "2014-08-19T08:42:32.583"}, "3675394": {"Id": "3675394", "PostTypeId": "2", "Body": "<p>The most obvious override would be to copy this implementation.</p>\n<p>Another sensible one would be to add some checks (for example, verifying that there is no \"bound-marker\" within the request zone).</p>\n<p>I think however that the point is more than you HAVE to override it, as soon as you override the others (for a given class), because of the mechanics of name look up (or not overriding it to prevent its use, that's fine too, but it's a conscious decision).</p>\n", "LastActivityDate": "2010-09-09T09:36:59.787", "CommentCount": "0", "CreationDate": "2010-09-09T09:36:59.787", "ParentId": "3675059", "Score": "1", "OwnerUserId": "147192"}, "28848772": {"Id": "28848772", "PostTypeId": "2", "Body": "<p>To define your own memory management for a prereserved area is one nice use.</p>\n<p>To have different views on the same physical data (no need to move the data) is other interseting use.\nIt also allows you reading a structured file as chars on a buffer and then,  the superimposition of the their logical structure by defining an object of that the class over the buffer. \nThe combination of this thing with the memory mapping of files, can provide big improvements in performance.\nThe memory mapped hardware...\nSo, thousand applications!</p>\n", "LastActivityDate": "2015-03-04T07:29:14.043", "CommentCount": "1", "CreationDate": "2015-03-04T07:29:14.043", "ParentId": "3675059", "Score": "1", "OwnerUserId": "4630988"}, "3677129": {"Id": "3677129", "PostTypeId": "2", "Body": "<p>The correct answer is <strong>you cannot replace operator placement new</strong>.</p>\n<blockquote>\n<p id=\"so_3675059_3677129_0\">\u00a718.4.\u200b1.3 Placement forms<br>\n  These functions are reserved, a C++ program may not define functions that displace the versions in the Standard C++ library.</br></p>\n</blockquote>\n<p>The rationale: The only purpose of the allocation and deallocation operators is to allocate and deallocate memory, so when given memory nothing more should be done. (The standard specifically notes that these functions \"Intentionally perform no other action.\")</p>\n", "LastActivityDate": "2010-09-09T13:45:45.483", "CommentCount": "5", "CreationDate": "2010-09-09T13:45:45.483", "ParentId": "3675059", "Score": "14", "OwnerUserId": "87234"}, "3675168": {"Id": "3675168", "PostTypeId": "2", "Body": "<p>Technically, a placement <code>operator new</code> is any <code>operator new</code> that takes additional arguments besides the size of the memory needed.</p>\n<p>So, <code>new(std::nothrow) X</code> uses a placement <code>operator new</code> and so does <code>new(__FILE__, __LINE__) X</code>.</p>\n<p>The only reason for overriding the <code>operator new(size_t, void*)</code> could be to add tracing information, but I think the need for that will be pretty low.</p>\n", "LastActivityDate": "2010-09-09T09:03:18.500", "CommentCount": "4", "CreationDate": "2010-09-09T09:03:18.500", "ParentId": "3675059", "Score": "3", "OwnerUserId": "430719"}, "26174409": {"Id": "26174409", "PostTypeId": "2", "Body": "<p>The most important extra-functionality for placement new overload would be to check address alignment.</p>\n<p>For example, lets assume some class requires 16-bytes alignment. Developer overloads new, new[], delete and delete[] - just to be sure everything is aligned properly.</p>\n<p>Everything works fine to the moment when he tries to use his class with library which uses placement new... Library has no idea if/what alignment is required for the class and address it tries to \"place\" the object to might not be aligned - big boom.</p>\n<p>The simplest example of such situation - try using std::vector&lt;T&gt; where T requires non-standard alignment.</p>\n<p>Overload for placement new allows to detect if pointer is not aligned - might save hours of debugging.</p>\n", "LastEditorUserId": "479995", "LastActivityDate": "2014-10-03T07:40:58.377", "Score": "0", "CreationDate": "2014-10-03T06:46:39.533", "ParentId": "3675059", "CommentCount": "0", "OwnerUserId": "479995", "LastEditDate": "2014-10-03T07:40:58.377"}, "bq_ids": {"n4140": {"so_3675059_3677129_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 6857}}, "n3337": {"so_3675059_3677129_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 6603}}, "n4659": {"so_3675059_3677129_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 8349}}}, "3675358": {"Id": "3675358", "PostTypeId": "2", "Body": "<p>My primary usage is to create a large array of objects. Its performing much better and has less overhead to allocate the memory in a whole block, i.e. using VirtualAlloc from Win32 (when programming windows). Then you just pass a ptr within that block to each objects placement new such as:</p>\n<pre><code>char *cp = new char[totalSize];\n\nfor(i = 0; i &lt; count; i++, cp += ObjSize)        \n{                                                        \n    myClass *obj = new(cp) myClass;             \n}\n</code></pre>\n", "LastActivityDate": "2010-09-09T09:30:41.997", "CommentCount": "2", "CreationDate": "2010-09-09T09:30:41.997", "ParentId": "3675059", "Score": "-1", "OwnerUserId": "53420"}, "3675704": {"Id": "3675704", "PostTypeId": "2", "Body": "<p>I've seen an example where two-argument new [] was overwritten to return memory blocks pre-filled with the char passed as the additional argument. I don't remember what the original code used (probably memset()), but it was functionally something like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;new&gt;\nvoid* operator new [](size_t n, char c)\n{\n        char* p = new char[n];\n        std::fill(p, p+n, c);\n        return p;\n}\nint main()\n{\n        char* p = new('a') char[10];\n        std::cout &lt;&lt; p[0] &lt;&lt; p[1] &lt;&lt; \"..\" &lt;&lt; p[9] &lt;&lt; '\\n';\n}\n</code></pre>\n<p>although I guess this wouldn't be called \"placement\" new because it does not perform <em>placement</em>. It could probably be useful if templated so that it can build arrays of any type, filled with a copy of the object passed as its second argument... but then, we have containers for that anyway.</p>\n", "LastActivityDate": "2010-09-09T10:25:06.653", "CommentCount": "1", "CreationDate": "2010-09-09T10:25:06.653", "ParentId": "3675059", "Score": "0", "OwnerUserId": "273767"}, "18893694": {"Id": "18893694", "PostTypeId": "2", "Body": "<p>I'm not exactly sure of the question, but the following overrides placement new at the class level:</p>\n<pre><code>struct Bar {\nvoid* operator new(size_t /* ignored */, void* where) throw() { return where; }\n};\n\nint main() {\n  char mem[1];\n  Bar* bar = new(mem) Bar;\n}\n</code></pre>\n<p>I believe this is legal C++ (and compiles and runs fine with gcc 4.4.6). </p>\n<p>You are free to change the implementation of this operator as you see fit (including removing the <code>throw()</code> clause, which will mean the compiler no longer checks the <code>where</code> pointer for null before calling the constructor). Tread carefully though.</p>\n<p>\u00a718.4.\u200b1.3 is interesting. I believe this just applies to the global operator new function, not class specific ones.</p>\n", "LastActivityDate": "2013-09-19T11:43:17.237", "CommentCount": "2", "CreationDate": "2013-09-19T11:43:17.237", "ParentId": "3675059", "Score": "0", "OwnerUserId": "1943413"}, "3675059": {"ViewCount": "7903", "Body": "<p>C++ allows overloading <code>operator new</code> - both global and per-class - usual <code>operator new</code>, <code>operator new[]</code> used with <code>new[]</code> statement and placement <code>operator new</code> separately.</p>\n<p>The former two of those three are usually overloaded for using customized allocators and adding tracing. But placement <code>operator new</code> seems pretty straightforward - it actually does nothing inside. For example, in Visual C++ the default implementation just returns the address passed into the call:</p>\n<pre><code>//from new.h\ninline void* operator new( size_t, void* where )\n{\n   return where;\n}\n</code></pre>\n<p>What else could it do?  Why and how could I sensibly overload placement <code>operator new</code>?</p>\n", "AcceptedAnswerId": "3677129", "Title": "How could I sensibly overload placement operator new?", "CreationDate": "2010-09-09T08:47:45.673", "Id": "3675059", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-03-04T07:29:14.043", "Score": "16", "OwnerUserId": "57428", "Tags": "<c++><visual-c++><memory-management><operator-overloading>", "AnswerCount": "9"}});