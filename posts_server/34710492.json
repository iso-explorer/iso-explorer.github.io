post_cb({"34710865": {"ParentId": "34710492", "CommentCount": "1", "Body": "<p>Section 4.5 explains how a value is converted to it's own type:</p>\n<blockquote>\n<p id=\"so_34710492_34710865_0\">4.5 Integral promotions [conv.prom]</p>\n<ul>\n<li><p id=\"so_34710492_34710865_1\">A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion rank (4.13) is less than the rank of\n  int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be\n  converted to a prvalue of type unsigned int.</p></li>\n<li><p id=\"so_34710492_34710865_2\">A prvalue of type char16_t, char32_t, or wchar_t (3.9.1) can be converted to a prvalue of the first of the following types that can\n  represent all the values of its underlying type: int, unsigned int,\n  long int, unsigned long int, long long int, or unsigned long long int.\n  If none of the types in that list can represent all the values of its\n  underlying type, a prvalue of type char16_t, char32_t, or wchar_t can\n  be converted to a prvalue of its underlying type.</p></li>\n<li><p id=\"so_34710492_34710865_3\">A prvalue of an unscoped enumeration type whose underlying type is not fixed (7.2) can be converted to a prvalue of the first of the\n  following types that can represent all the values of the enumeration\n  (i.e., the values in the range b min to b max as described in 7.2):\n  int, unsigned int, long int, unsigned long int, long long int, or\n  unsigned long long int. If none of the types in that list can\n  represent all the values of the enumeration, a prvalue of an unscoped\n  enumeration type can be converted to a prvalue of the extended integer\n  type with lowest integer conversion rank (4.13) greater than the rank\n  of long long in which all the values of the enumeration can be\n  represented. If there are two such extended types, the signed one is\n  chosen.</p></li>\n<li><p id=\"so_34710492_34710865_4\">A prvalue of an unscoped enumeration type whose underlying type is fixed (7.2) can be converted to a prvalue of its underlying type.\n  Moreover, if integral promotion can be applied to its underlying type,\n  a rvalue of an unscoped enumeration type whose underlying type is\n  fixed can also be converted to a prvalue of the promoted underlying\n  type.</p></li>\n<li><p id=\"so_34710492_34710865_5\">A prvalue for an integral bit-field (9.6) can be converted to a prvalue of type int if int can represent all the values of the\n  bit-field; otherwise, it can be converted to unsigned int if unsigned\n  int can represent all the values of the bit-field. If the bit-field is\n  larger yet, no integral promotion applies to it. If the bit-field has\n  an enumerated type, it is treated as any other value of that type for\n  promotion purposes.</p></li>\n<li>A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true becoming one.</li>\n<li>These conversions are called integral promotions.</li>\n</ul>\n</blockquote>\n<p>Section 5 of the C++ standard explains the promotion within expressions. </p>\n<blockquote>\n<p id=\"so_34710492_34710865_6\">... lots of other things ... </p>\n<ul>\n<li><p id=\"so_34710492_34710865_7\">Otherwise, the integral promotions (4.5) shall be performed on both\n  operands. [59] Then the following rules shall be applied to the\n  promoted operands:</p>\n<ul>\n<li><p id=\"so_34710492_34710865_8\">If both operands have the same type, no further conversion is\n  needed.</p></li>\n<li><p id=\"so_34710492_34710865_9\">Otherwise, if both operands have signed integer types or both have\n  unsigned integer types, the operand with the type of lesser integer\n  conversion rank shall be converted to the type of the operand with\n  greater rank.</p></li>\n<li><p id=\"so_34710492_34710865_10\">Otherwise, if the operand that has unsigned integer type has rank\n  greater than or equal to the rank of the type of the other operand,\n  the operand with signed integer type shall be converted to the type of\n  the operand with unsigned integer type.</p></li>\n<li><p id=\"so_34710492_34710865_11\">Otherwise, if the type of the operand with signed integer type can\n  represent all of the values of the type of the operand with unsigned\n  integer type, the operand with unsigned integer type shall be\n  converted to the type of the operand with signed integer type.</p></li>\n<li><p id=\"so_34710492_34710865_12\">Otherwise, both operands shall be converted to the unsigned\n  integer type corresponding to the type of the operand with signed\n  integer type.</p></li>\n</ul></li>\n</ul>\n<p id=\"so_34710492_34710865_13\">[59] As a consequence, operands of type bool, char16_t, char32_t,\n  wchar_t, or an enumerated type are converted to some integral type.</p>\n</blockquote>\n<p>So, if we take your expression:</p>\n<pre><code>ll_B=((394)-ui_C*(649)+(917)+ll_B-(80));\n</code></pre>\n<p>Remove superfluous parenthesis so to read easier:</p>\n<pre><code>ll_B=394-ui_C*649+917+ll_B-80;\n</code></pre>\n<p>So, we have <code>394</code> - signed integer by section 4.5 rules. Then <code>ui_C*649</code> is an unsigned expression, <code>917</code> is a signed value (but adding it to a unsigned value of equal or greater size and fits in unsigned range), then <code>ll_B</code> is long-long. <code>80</code> is a signed integer. </p>\n<p>As a summary, we should see:</p>\n<ul>\n<li>unsigned multiplication of <code>ui_C</code> with <code>649</code>. </li>\n<li>Subtracting that from 394. </li>\n<li>Adding 917 (unsigned). </li>\n<li>Unsigned extension to 64 bits.</li>\n<li>Adding <code>ll_B</code></li>\n<li>Adding of <code>80</code>. </li>\n</ul>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "34710865", "Score": "0", "CreationDate": "2016-01-10T21:18:35.950", "LastActivityDate": "2016-01-10T21:18:35.950"}, "34710492": {"CommentCount": "3", "ViewCount": "200", "PostTypeId": "1", "LastEditorUserId": "4774918", "CreationDate": "2016-01-10T20:36:52.867", "LastActivityDate": "2016-01-10T21:18:35.950", "Title": "Mathematical Expressions into x86 Assembly Unsigned vs Unsigned", "LastEditDate": "2016-01-10T20:48:23.927", "Id": "34710492", "Score": "-1", "Body": "<p>I am writing an expression evaluator which produces x86 64bit assembly. I choose to mimic the C++ compiler rules for the variable types (char to int promotion etc., and literal values). However, I have an issue which is perplexing. When evaluating a complex mathematical expression, I use a postfix conversion first. Next, while tracking data types internally, the logic tracks data type according to conversion and or input operand types. My question is <strong>when do signed numbers become unsigned and vice versa within intermediate representation by a C++ compiler</strong>? During production of assembly, I noticed that clang assembly will sometimes use a movl when you might think that based upon previous data types the instruction would be to sign extended (movswl). <em>In general it is my desire to mimic the traditions of type conversion of a c++ compiler as well as during intermediate processing.</em></p>\n<p>As an example, consider this input into my program (the data types mimic c++):</p>\n<pre><code>short s_A=658\nlong long ll_B=293\nunsigned int ui_C=94\n\nprint s_A\nprint ll_B\nprint ui_C\nprint \"-------------------------\"\n\nll_B=((394)-ui_C*(649)+(917)+ll_B-(80))\nprint ll_B\n\n\nprint \"-------------------------\"\nprint s_A\nprint ll_B\nprint ui_C\n</code></pre>\n<p><strong>whereas in C++ the same code is produced as:</strong></p>\n<pre><code>include &lt;stdio.h&gt;\n\nint main(void) { \nshort s_A=658;\nlong long ll_B=293;\nunsigned int ui_C=94;\n\nprintf(\"%hi\\n\",s_A);\nprintf(\"%lld\\n\",ll_B);\nprintf(\"%u\\n\",ui_C);\nprintf(\"-------------------------\\n\");\n\nll_B=((394)-ui_C*(649)+(917)+ll_B-(80));\nprintf(\"%lld\\n\",ll_B);\n\n\nprintf(\"-------------------------\\n\");\nprintf(\"%hi\\n\",s_A);\nprintf(\"%lld\\n\",ll_B);\nprintf(\"%u\\n\",ui_C);\n\n}\n</code></pre>\n<p>My logic produces the following assembly:</p>\n<pre><code>.section .data\nLC1:\n    .asciz \"%hi\\n\"\nLC2:\n    .asciz \"%lld\\n\"\nLC5:\n    .asciz \"%s\\n\"\nLC3:\n    .asciz \"%u\\n\"\nLC4:\n    .asciz \"-------------------------\"\nll_B:\n    .quad 293\ns_A:\n    .word 658   # \nui_C:\n    .long 94    # \n.section .text\n.globl _start\n_start:\n    and $0xfffffffffffffff0,%rsp\n    movq    %rsp, %rbp\n    finit\n    mov s_A, %rsi\n    xor %rax, %rax\n    lea LC1, %rdi\n    call printf\n    mov ll_B, %rsi\n    xor %rax, %rax\n    lea LC2, %rdi\n    call printf\n    mov ui_C, %rsi\n    xor %rax, %rax\n    lea LC3, %rdi\n    call printf\n    lea LC4, %rsi\n    xor %rax, %rax\n    lea LC5, %rdi\n    call printf\n# Expression: ((394)-ui_C*(649)+(917)+ll_B-(80))\n# Postfix: 394 ui_C 649 * - 917 + ll_B + 80 - \n# EVAL(1): ui_C*649\n# MOVE ui_C ( UnsignedInt - 32bits ) to ( Int - 32bits  )\n# instructionType=STATE_x86\n    movl ui_C, %eax\n    imull $649, %eax\n# EVAL(2): 394-%eax\n    movl $394, %ebx\n    subl %eax, %ebx\n# free register %eax\n# EVAL(3): %ebx+917\n    addl $917, %ebx\n# EVAL(4): %ebx+ll_B\n# CONVERT %ebx ( Int - 32bits ) to ( LongLong - 64bits  )\n# instructionType=STATE_x86\n    movslq %ebx, %rax  #ISSUE\n    addq ll_B, %rax\n# free register %ebx\n# EVAL(5): %rax-80\n    subq $80, %rax\n# STORE RESULT :  %rax -&gt; ll_B\n# MOVE %rax ( LongLong - 64bits ) to ( LongLong - 64bits  )\n# instructionType=STATE_x86\n    movq %rax, ll_B\n#\n    mov ll_B, %rsi\n    xor %rax, %rax\n    lea LC2, %rdi\n    call printf\n    lea LC4, %rsi\n    xor %rax, %rax\n    lea LC5, %rdi\n    call printf\n    mov s_A, %rsi\n    xor %rax, %rax\n    lea LC1, %rdi\n    call printf\n    mov ll_B, %rsi\n    xor %rax, %rax\n    lea LC2, %rdi\n    call printf\n    mov ui_C, %rsi\n    xor %rax, %rax\n    lea LC3, %rdi\n    call printf\ndone:\n    mov $0, %rdi\n    call exit\n</code></pre>\n<p><strong>while gcc produces</strong></p>\n<pre><code>    .file   \"whole_short_int_longlong_simple_33.cpp\"\n    .section    .rodata\n.LC0:\n    .string \"%hi\\n\"\n.LC1:\n    .string \"%lld\\n\"\n.LC2:\n    .string \"%u\\n\"\n.LC3:\n    .string \"-------------------------\"\n    .text\n    .globl  main\n    .type   main, @function\nmain:\n.LFB0:\n    .cfi_startproc\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    subq    $16, %rsp\n    movw    $658, -14(%rbp)\n    movq    $293, -8(%rbp)\n    movl    $94, -12(%rbp)\n    movswl  -14(%rbp), %eax\n    movl    %eax, %esi\n    movl    $.LC0, %edi\n    movl    $0, %eax\n    call    printf\n    movq    -8(%rbp), %rax\n    movq    %rax, %rsi\n    movl    $.LC1, %edi\n    movl    $0, %eax\n    call    printf\n    movl    -12(%rbp), %eax\n    movl    %eax, %esi\n    movl    $.LC2, %edi\n    movl    $0, %eax\n    call    printf\n    movl    $.LC3, %edi\n    call    puts\n    movl    -12(%rbp), %eax\n    imull   $649, %eax, %eax\n    movl    $1311, %edx\n    subl    %eax, %edx\n    movl    %edx, %eax\n    movl    %eax, %edx\n    movq    -8(%rbp), %rax\n    addq    %rdx, %rax\n    subq    $80, %rax\n    movq    %rax, -8(%rbp)\n    movq    -8(%rbp), %rax\n    movq    %rax, %rsi\n    movl    $.LC1, %edi\n    movl    $0, %eax\n    call    printf\n    movl    $.LC3, %edi\n    call    puts\n    movswl  -14(%rbp), %eax\n    movl    %eax, %esi\n    movl    $.LC0, %edi\n    movl    $0, %eax\n    call    printf\n    movq    -8(%rbp), %rax\n    movq    %rax, %rsi\n    movl    $.LC1, %edi\n    movl    $0, %eax\n    call    printf\n    movl    -12(%rbp), %eax\n    movl    %eax, %esi\n    movl    $.LC2, %edi\n    movl    $0, %eax\n    call    printf\n    movl    $0, %eax\n    leave\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size   main, .-main\n    .ident  \"GCC: (Ubuntu 5.2.1-22ubuntu2) 5.2.1 20151010\"\n    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p><strong>and clang produces:</strong></p>\n<pre><code>.text\n    .file   \"/home/anthony/comptest/simple/whole_short_int_longlong_simple/whole_short_int_longlong_simple_33.cpp\"\n    .globl  main\n    .align  16, 0x90\n    .type   main,@function\nmain:                                   # @main\n    .cfi_startproc\n# BB#0:\n    pushq   %rbp\n.Ltmp0:\n    .cfi_def_cfa_offset 16\n.Ltmp1:\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\n.Ltmp2:\n    .cfi_def_cfa_register %rbp\n    subq    $64, %rsp\n    movabsq $.L.str, %rdi\n    movw    $658, -2(%rbp)          # imm = 0x292\n    movq    $293, -16(%rbp)         # imm = 0x125\n    movl    $94, -20(%rbp)\n    movswl  -2(%rbp), %esi\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str1, %rdi\n    movq    -16(%rbp), %rsi\n    movl    %eax, -24(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str2, %rdi\n    movl    -20(%rbp), %esi\n    movl    %eax, -28(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str3, %rdi\n    movl    %eax, -32(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str1, %rdi\n    movl    $394, %esi              # imm = 0x18A\n    imull   $649, -20(%rbp), %ecx   # imm = 0x289\n    subl    %ecx, %esi\n    addl    $917, %esi              # imm = 0x395\n    movl    %esi, %ecx\n    movl    %ecx, %edx\n    addq    -16(%rbp), %rdx\n    subq    $80, %rdx\n    movq    %rdx, -16(%rbp)\n    movq    -16(%rbp), %rsi\n    movl    %eax, -36(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str3, %rdi\n    movl    %eax, -40(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str, %rdi\n    movswl  -2(%rbp), %esi\n    movl    %eax, -44(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str1, %rdi\n    movq    -16(%rbp), %rsi\n    movl    %eax, -48(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    movabsq $.L.str2, %rdi\n    movl    -20(%rbp), %esi\n    movl    %eax, -52(%rbp)         # 4-byte Spill\n    movb    $0, %al\n    callq   printf\n    xorl    %ecx, %ecx\n    movl    %eax, -56(%rbp)         # 4-byte Spill\n    movl    %ecx, %eax\n    addq    $64, %rsp\n    popq    %rbp\n    retq\n.Ltmp3:\n    .size   main, .Ltmp3-main\n    .cfi_endproc\n\n    .type   .L.str,@object          # @.str\n    .section    .rodata.str1.1,\"aMS\",@progbits,1\n.L.str:\n    .asciz  \"%hi\\n\"\n    .size   .L.str, 5\n\n    .type   .L.str1,@object         # @.str1\n.L.str1:\n    .asciz  \"%lld\\n\"\n    .size   .L.str1, 6\n\n    .type   .L.str2,@object         # @.str2\n.L.str2:\n    .asciz  \"%u\\n\"\n    .size   .L.str2, 4\n\n    .type   .L.str3,@object         # @.str3\n.L.str3:\n    .asciz  \"-------------------------\\n\"\n    .size   .L.str3, 27\n\n\n    .ident  \"Ubuntu clang version 3.6.2-1 (tags/RELEASE_362/final) (based on LLVM 3.6.2)\"\n    .section    \".note.GNU-stack\",\"\",@progbits\n</code></pre>\n<p>Notice that the problem is within the evaluation of the rbx register (EBX=32). Because the last operands were literals, internally my logic notes these values as <strong>signed int</strong> 32bit. Therefore, when widening to 64bits, the <strong>movslq</strong> is emitted to sign extend the value. While gcc (c compiler rules), does a zero extend by moving the 32 bit data into another register (which zero fills the upper half), and then references it as a 64bit numeric.</p>\n<p>There are two other problems which are a little more complex I also want to solve (carry, overflow (integer, SSE and FPU), unsigned/signed etc.), so if you are good in assembly on x86 64, I am a well behaved conversationalist. Researching the Internet does produce some results for issues relating this subject. However, I have not found a definitive encompassing text for these two's compliments comprehensions.</p>\n", "Tags": "<c++><assembly><unsigned><signed>", "OwnerUserId": "5770771", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34710492_34710865_10": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_34710492_34710865_12": {"section_id": 5943, "quality": 1.0, "length": 13}, "so_34710492_34710865_3": {"section_id": 23, "quality": 0.9625, "length": 77}, "so_34710492_34710865_9": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_34710492_34710865_5": {"section_id": 25, "quality": 1.0, "length": 41}, "so_34710492_34710865_4": {"section_id": 24, "quality": 0.972972972972973, "length": 36}, "so_34710492_34710865_11": {"section_id": 5943, "quality": 1.0, "length": 25}, "so_34710492_34710865_7": {"section_id": 5943, "quality": 1.0, "length": 12}, "so_34710492_34710865_1": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_34710492_34710865_13": {"section_id": 5943, "quality": 1.0, "length": 13}, "so_34710492_34710865_8": {"section_id": 5943, "quality": 1.0, "length": 8}, "so_34710492_34710865_2": {"section_id": 22, "quality": 0.9818181818181818, "length": 54}}, "n3337": {"so_34710492_34710865_10": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_34710492_34710865_12": {"section_id": 5714, "quality": 1.0, "length": 13}, "so_34710492_34710865_3": {"section_id": 20, "quality": 0.9625, "length": 77}, "so_34710492_34710865_9": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_34710492_34710865_5": {"section_id": 22, "quality": 1.0, "length": 41}, "so_34710492_34710865_4": {"section_id": 21, "quality": 0.972972972972973, "length": 36}, "so_34710492_34710865_11": {"section_id": 5714, "quality": 1.0, "length": 25}, "so_34710492_34710865_7": {"section_id": 5714, "quality": 1.0, "length": 12}, "so_34710492_34710865_1": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}, "so_34710492_34710865_13": {"section_id": 5714, "quality": 1.0, "length": 13}, "so_34710492_34710865_8": {"section_id": 5714, "quality": 1.0, "length": 8}, "so_34710492_34710865_2": {"section_id": 19, "quality": 0.9818181818181818, "length": 54}}, "n4659": {"so_34710492_34710865_10": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_34710492_34710865_12": {"section_id": 7428, "quality": 1.0, "length": 13}, "so_34710492_34710865_11": {"section_id": 7428, "quality": 1.0, "length": 25}, "so_34710492_34710865_9": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_34710492_34710865_5": {"section_id": 25, "quality": 1.0, "length": 41}, "so_34710492_34710865_4": {"section_id": 24, "quality": 0.972972972972973, "length": 36}, "so_34710492_34710865_7": {"section_id": 7428, "quality": 1.0, "length": 12}, "so_34710492_34710865_3": {"section_id": 23, "quality": 0.9625, "length": 77}, "so_34710492_34710865_1": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_34710492_34710865_13": {"section_id": 7428, "quality": 1.0, "length": 13}, "so_34710492_34710865_8": {"section_id": 7428, "quality": 1.0, "length": 8}, "so_34710492_34710865_2": {"section_id": 22, "quality": 0.9818181818181818, "length": 54}}}});