post_cb({"bq_ids": {"n4140": {"so_30187915_30188026_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1566}, "so_30187915_30188026_2": {"length": 9, "quality": 0.5625, "section_id": 763}}, "n3337": {"so_30187915_30188026_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1561}, "so_30187915_30188026_2": {"length": 9, "quality": 0.5625, "section_id": 750}}, "n4659": {"so_30187915_30188026_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 7005}, "so_30187915_30188026_2": {"length": 13, "quality": 0.8125, "section_id": 743}}}, "30261357": {"Id": "30261357", "PostTypeId": "2", "Body": "<p>The question is whether the code</p>\n<pre><code>std::size_t required_size;\nf( nullptr, &amp;required_size );\nstd::string s;\ns.resize( required_size );\nf( &amp;s[0], &amp;required_size );\n</code></pre>\n<p>is safe.</p>\n<p>That depends on which C++ standard one assumes, but since it's Undefined Behavior for the case of <code>required_size</code> = 0 in C++03 and C++98, the general answer is <strong>no</strong>, it's not safe in general.</p>\n<hr>\n<p>In C++03 <code>std::string</code> was not formally guaranteed to have a contiguous buffer, but in practice all extant implementation did have contiguous buffer. Anyway, now after C++11, where the contiguous buffer guarantee was formally incorporated in the standard, there will not appear any new C++03 implementations with non-contiguous buffer. Hence that isn't a problem.</p>\n<p>The problem is rather that in C++03 <code>std::basic_string::operator[]</code> was defined as follows:</p>\n<b>C++03 \u00a721.3.4/1</b>:\n\n<blockquote>\n<p id=\"so_30187915_30261357_0\"><strong>\u201d</strong> <strong>Returns:</strong> If <code>pos &lt; size()</code>, returns <code>data()[pos]</code>. Otherwise, if <code>pos == size()</code>, the <code>const</code> version returns <code>charT()</code>. Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>So, for a non-<code>const</code> string <code>s</code> of size 0, in C++03 it was Undefined Behavior\u2122 to do the indexing <code>s[0]</code>.</p>\n<p>In C++11 the corresponding paragraph \u00a721.4.3/2 says instead that the result is \u201c<code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an object of type <code>T</code> with value <code>charT()</code>; the referenced value shall not be modified.\u201d</p>\n<hr>\n<p>Here's code that works regardless of which C++ standard the compiler implements:</p>\n<pre><code>std::size_t required_size;\nf( NULL, &amp;required_size );    // Establish required buffer size.\nif( required_size &gt; 0 )\n{\n    std::string s( required_size, '#' );\n    f( &amp;s[0], &amp;required_size );\n    s.resize( strlen( &amp;s[0] ) );\n}\n</code></pre>\n</hr></hr>", "LastActivityDate": "2015-05-15T13:57:38.317", "CommentCount": "0", "CreationDate": "2015-05-15T13:57:38.317", "ParentId": "30187915", "Score": "1", "OwnerUserId": "464581"}, "30188026": {"Id": "30188026", "PostTypeId": "2", "Body": "<p>Yes, it's safe, at least explicitly from C++11. From [string.require], emphasis mine:</p>\n<blockquote>\n<p id=\"so_30187915_30188026_0\">The char-like objects in a <code>basic_string</code> object <strong>shall be stored contiguously</strong>. That is, for any basic_string\n  object s, the identity <code>&amp;*(s.begin() + n) == &amp;*s.begin() + n</code> shall hold for all values of <code>n</code> such that <code>0 &lt;= n &lt; s.size()</code>.</p>\n</blockquote>\n<p>This was the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530\" rel=\"nofollow\">DR 530</a>. Before C++11, this was not explicit in the standard, although it was done in practice anyway. </p>\n<p>In C++14, this requirement got moved to [basic.string]:</p>\n<blockquote>\n<p id=\"so_30187915_30188026_1\">A <code>basic_string</code> is a contiguous container (23.2.1).</p>\n</blockquote>\n<p>where [container.requirements.general]:</p>\n<blockquote>\n<p id=\"so_30187915_30188026_2\">A <em>contiguous container</em> is a container that supports random access iterators (24.2.7) and whose member\n  types <code>iterator</code> and <code>const_iterator</code> are contiguous iterators (24.2.1).</p>\n</blockquote>\n<p>where [iterator.requirements.general]:</p>\n<blockquote>\n<p id=\"so_30187915_30188026_3\">Iterators that further satisfy the requirement that, for integral values <code>n</code> and dereferenceable iterator values\n  <code>a</code> and <code>(a + n)</code>, <code>*(a + n)</code> is equivalent to <code>*(addressof(*a) + n)</code>, are called <em>contiguous iterators</em>.</p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-15T13:25:48.757", "Score": "7", "CreationDate": "2015-05-12T10:22:41.327", "ParentId": "30187915", "CommentCount": "7", "OwnerUserId": "2069064", "LastEditDate": "2015-05-15T13:25:48.757"}, "30187915": {"ViewCount": "117", "Body": "<p>I'm fighting with an old c-style-interface. I have a function with a signature like this:</p>\n<pre><code> /// if return_value == NULL only the length is returned\n void f( char * return_value, size_t * size_only_known_at_runtime); \n</code></pre>\n<p>My question is, is the following code safe?</p>\n<pre><code>std::size required;\nf( NULL, &amp;required );\nstd::string s;\ns.resize(required);\nf( &amp;s[0], &amp;required );\n</code></pre>\n<p>Is there a better way to get the data into the string?</p>\n", "AcceptedAnswerId": "30188026", "Title": "Is it safe to use operator [] for std::string", "CreationDate": "2015-05-12T10:17:48.103", "Id": "30187915", "CommentCount": "9", "LastEditDate": "2015-05-12T10:33:05.650", "PostTypeId": "1", "LastEditorUserId": "3545094", "LastActivityDate": "2015-05-15T13:57:38.317", "Score": "3", "OwnerUserId": "1235183", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});