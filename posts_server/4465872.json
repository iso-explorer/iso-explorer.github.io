post_cb({"4465903": {"Id": "4465903", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4465872_4465903_0\">Is there a way to make it just print</p>\n<p id=\"so_4465872_4465903_1\"><code>Blah</code> or <code>struct Blah</code>?</p>\n</blockquote>\n<p>No. The result of <code>std::typeinfo::name()</code> is unspecified. It might even return the same string for all types (or, indeed, empty strings for all types) and the implementation would still be standard-conforming. You must not rely on its result. Really, the only thing I found it useful for was debugging. </p>\n<p>Tell us what what you need it for. Often traits is what you use instead. </p>\n", "LastActivityDate": "2010-12-16T22:17:38.293", "CommentCount": "2", "CreationDate": "2010-12-16T22:17:38.293", "ParentId": "4465872", "Score": "11", "OwnerUserId": "140719"}, "4465901": {"Id": "4465901", "PostTypeId": "2", "Body": "<p><code>typeid().name()</code> is implementation dependent. It may even return empty string for every type. That would not be very useful implementation, but it would be valid.</p>\n", "LastActivityDate": "2010-12-16T22:17:33.653", "CommentCount": "1", "CreationDate": "2010-12-16T22:17:33.653", "ParentId": "4465872", "Score": "3", "OwnerUserId": "426288"}, "37592129": {"Id": "37592129", "PostTypeId": "2", "Body": "<p>in 4Blah, 4 is the number of letters in your class name. For example if your class name is myEmptyClass then it would print 12myEmptyClass.</p>\n", "LastActivityDate": "2016-06-02T12:38:36.157", "CommentCount": "0", "CreationDate": "2016-06-02T12:38:36.157", "ParentId": "4465872", "Score": "2", "OwnerUserId": "4867626"}, "4465872": {"ViewCount": "24302", "Body": "<p>How come when I run this <code>main.cpp</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nusing namespace std;\n\nstruct Blah {};\n\nint main() {\n  cout &lt;&lt; typeid(Blah).name() &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>By compiling it with GCC version 4.4.4:</p>\n<pre><code>g++ main.cpp\n</code></pre>\n<p>I get this:</p>\n<pre><code>4Blah\n</code></pre>\n<p>On Visual C++ 2008, I would get:</p>\n<pre><code>struct Blah\n</code></pre>\n<p>Is there a way to make it just print <code>Blah</code> or <code>struct Blah</code>?</p>\n", "AcceptedAnswerId": "4465907", "Title": "Why does typeid.name() return weird characters using GCC and how to make it print unmangled names?", "CreationDate": "2010-12-16T22:13:32.503", "Id": "4465872", "CommentCount": "2", "FavoriteCount": "19", "PostTypeId": "1", "LastEditDate": "2015-06-05T13:01:42.227", "LastEditorUserId": "895245", "LastActivityDate": "2016-06-02T12:38:36.157", "Score": "29", "OwnerUserId": "65313", "Tags": "<c++><gcc><g++><rtti>", "AnswerCount": "6"}, "4465965": {"Id": "4465965", "PostTypeId": "2", "Body": "<p>As others have said, the result here is <em>implementation-defined</em>, meaning that the implementation (i.e., the compiler toolchain) is free to define it how it wants, so long as it documents that somewhere.</p>\n<p>From the C++ standard, section 18.5.1/1 [lib.type.info]:</p>\n<blockquote>\n<p id=\"so_4465872_4465965_0\">The class <code>type_info</code> describes type information generated by the implementation. Objects of this class\n  effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for\n  equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified\n  and may differ between programs.</p>\n</blockquote>\n", "LastActivityDate": "2010-12-16T22:24:56.267", "CommentCount": "0", "CreationDate": "2010-12-16T22:24:56.267", "ParentId": "4465872", "Score": "6", "OwnerUserId": "9530"}, "bq_ids": {"n4140": {"so_4465872_4465965_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 6885}}, "n3337": {"so_4465872_4465965_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 6631}}, "n4659": {"so_4465872_4465965_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 8385}}}, "4465926": {"Id": "4465926", "PostTypeId": "2", "Body": "<p>The string returned is implementation defined.</p>\n<p>What gcc is doing is returning the mangled name.<br>\nYou can convert the mangled name into plain text with c++filt</br></p>\n<pre><code>&gt; a.out | c++filt\n</code></pre>\n", "LastEditorUserId": "14065", "LastActivityDate": "2010-12-16T22:31:28.883", "Score": "16", "CreationDate": "2010-12-16T22:20:16.070", "ParentId": "4465872", "CommentCount": "1", "OwnerUserId": "14065", "LastEditDate": "2010-12-16T22:31:28.883"}, "4465907": {"Id": "4465907", "PostTypeId": "2", "Body": "<p>The return of <code>name</code> is implementation defined : an implementation is not even required to return different strings for different types.</p>\n<p>What you get from g++ is a <a href=\"http://en.wikipedia.org/wiki/Name_mangling\" rel=\"noreferrer\">decorated name</a>, that you can \"demangle\" using the <a href=\"http://sourceware.org/binutils/docs-2.16/binutils/c_002b_002bfilt.html\" rel=\"noreferrer\"><code>c++filt</code></a> command or <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html\" rel=\"noreferrer\"><code>__cxa_demangle</code></a>.</p>\n", "LastActivityDate": "2010-12-16T22:18:11.237", "CommentCount": "2", "CreationDate": "2010-12-16T22:18:11.237", "ParentId": "4465872", "Score": "48", "OwnerUserId": "451980"}});