post_cb({"24685720": {"Id": "24685720", "PostTypeId": "2", "Body": "<p>Lock?  No.  But you do need some synchronization mechanism.</p>\n<p>What you're describing sounds an awful like a \"SPSC\" (Single Producer Single Consumer) queue, of which there are tons of lockfree implementations out there including one in the <a href=\"http://www.boost.org/doc/libs/1_55_0/doc/html/lockfree.html\" rel=\"nofollow\">Boost.Lockfree</a></p>\n<p>The general way these work is that underneath the covers you have a circular buffer containing your objects and an index.  The writer knows the last index it wrote to, and if it needs to write new data it (1) writes to the next slot, (2) updates the index by setting the index to the previous slot + 1, and then (3) signals the reader.  The reader then reads until it hits an index that doesn't contain the index it expects and waits for the next signal.  Deletes are implicit since new items in the buffer overwrite previous ones.</p>\n<p>You need a way to atomically update the index, which is provided by atomic&lt;&gt; and has direct hardware support.  You need a way for a writer to signal the reader.  You also might need  memory fences depending on the platform s.t. (1-3) occur in order.  You don't need anything as heavy as a lock.</p>\n", "LastActivityDate": "2014-07-10T20:29:33.987", "Score": "3", "CreationDate": "2014-07-10T20:29:33.987", "ParentId": "24682518", "CommentCount": "1", "OwnerUserId": "459975"}, "24682518": {"ViewCount": "3210", "Body": "<p>I have two threads running. They share an array. One of the threads adds new elements to the array (and removes them) and the other uses this array (read operations only). \nIs it necessary for me to lock the array before I add/remove to/from it or read from it?</p>\n<p>Further details: </p>\n<ul>\n<li>I will need to keep iterating over the entire array in the other thread. No write operations over there as previously mentioned. \"Just scanning something like a fixed-size circular buffer\"</li>\n<li>The easy thing to do in such cases is to use a lock. However locks can be very slow. I did not want to use locks if their use can be avoided. Also, as it came out from the discussions, it might not be necessary (it actually isn't) to lock all operations on the array. Just locking the management of an iterator for the array (count variable that will be used by the other thread) is enough</li>\n</ul>\n<p>I don't think the question is \"too broad\". If it still comes out to be so, please let me know. I know the question isn't perfect. I had to combine at least 3 answers in order to be able to solve the question - which suggests most people were not able to <em>fully</em> understand all the issues and were forced to do some guess work. But most of it came out through the comments which I have tried to incorporate in the question. The answers helped me solve my problem quite objectively and I think the answers provided here are quite a helpful resource for someone starting out with multithreading.   </p>\n", "Title": "Is it necessary to lock an array that is *only written to* from one thread and *only read from* another?", "CreationDate": "2014-07-10T17:11:24.267", "LastActivityDate": "2014-07-14T13:57:49.743", "CommentCount": "25", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2014-07-11T03:52:55.743", "LastEditorUserId": "530340", "Id": "24682518", "Score": "23", "OwnerUserId": "530340", "Tags": "<c++><c><arrays><multithreading>", "AnswerCount": "10"}, "24682568": {"Id": "24682568", "PostTypeId": "2", "Body": "<p>If it's a fixed-size array, and you don't need to communicate anything extra like indices written/updated, then you can avoid mutual exclusion with the caveat that the reader may see:</p>\n<ul>\n<li>no updates at all\n<ul>\n<li>If your memory ordering is relaxed enough that this happens, you need a store fence in the writer and a load fence in the consumer to fix it</li>\n</ul></li>\n<li>partial writes\n<ul>\n<li>if the stored type is not atomic on your platform (int generally should be)</li>\n<li>or your values are un-aligned, and especially if they may span cache lines</li>\n</ul></li>\n</ul>\n<p>This is all dependent on your platform though - hardware, OS and compiler can all affect it. You haven't told us what they are.</p>\n<p>The portable C++11 solution is to use an array of <code>atomic&lt;int&gt;</code>. You still need to decide what memory ordering constraints you require, and what that means for correctness and performance on your platform.</p>\n", "LastEditorUserId": "212858", "LastActivityDate": "2014-07-10T17:33:12.210", "Score": "0", "CreationDate": "2014-07-10T17:15:10.570", "ParentId": "24682518", "CommentCount": "2", "LastEditDate": "2014-07-10T17:33:12.210", "OwnerUserId": "212858"}, "24689063": {"Id": "24689063", "PostTypeId": "2", "Body": "<p>To answer your question: <em>maybe</em>.</p>\n<p>Simply put, the way that the question is framed doesn't provide enough information about whether or not a lock is required.</p>\n<p>In most standard use cases, the answer would be yes. And most of the answers here are covering that case pretty well.</p>\n<p>I'll cover the other case.</p>\n<p>When would you not need a lock given the information you have provided?</p>\n<p>There are some other questions here that would help better define whether you need a lock, whether you can use a lock-free synchronization method, or whether or not you can get away with no explicit synchronization.</p>\n<p><strong>Will writing data ever be non-atomic?</strong> Meaning, will writing data ever result in \"torn data\"? If your data is a single 32 bit value on an x86 system, and your data is aligned, then you would have a case where writing your data is already atomic. It's safe to assume that if your data is of any size larger than the size of a pointer (4 bytes on x86, 8 on x64), then your writes cannot be atomic without a lock.</p>\n<p><strong>Will the size of your array ever change in a way that requires reallocation?</strong> If your reader is walking through your data, will the data suddenly be \"gone\" (memory has been \"delete\"d)? Unless your reader takes this into account (unlikely), you'll need a lock if reallocation is possible.</p>\n<p><strong>When you write data to your array, is it ok if the reader \"sees\" old data?</strong> </p>\n<p><em>If your data can be written atomically, your array won't suddenly not be there, and it's ok for the reader to see old data... then you won't need a lock. Even with those conditions being met, it would be appropriate to use the built in atomic functions for reading and storing. But, that's a case where you wouldn't need a lock :)</em></p>\n<p>Probably safest to use a lock since you were unsure enough to ask this question. But, if you want to play around with the edge case of where you don't need a lock... there you go :)</p>\n", "LastActivityDate": "2014-07-11T01:59:18.820", "Score": "4", "CreationDate": "2014-07-11T01:59:18.820", "ParentId": "24682518", "CommentCount": "1", "OwnerUserId": "3561240"}, "bq_ids": {"n4140": {"so_24682518_24682612_2": {"length": 54, "quality": 0.8852459016393442, "section_id": 5836}, "so_24682518_24682612_1": {"length": 20, "quality": 0.8, "section_id": 5834}, "so_24682518_24682612_0": {"length": 14, "quality": 0.875, "section_id": 5817}}, "n3337": {"so_24682518_24682612_2": {"length": 56, "quality": 0.9180327868852459, "section_id": 5606}, "so_24682518_24682612_1": {"length": 22, "quality": 0.88, "section_id": 5605}, "so_24682518_24682612_0": {"length": 14, "quality": 0.875, "section_id": 5588}}, "n4659": {"so_24682518_24682612_2": {"length": 54, "quality": 0.8852459016393442, "section_id": 7298}, "so_24682518_24682612_1": {"length": 20, "quality": 0.8, "section_id": 7296}, "so_24682518_24682612_0": {"length": 15, "quality": 0.9375, "section_id": 7278}}}, "24686874": {"Id": "24686874", "PostTypeId": "2", "Body": "<p>If you use e.g. <code>vector</code> for your array (so that it can dynamically grow), then reallocation may occur during the writes, you lose.</p>\n<p>If you use data entries larger than is always written and read atomically (virtually any complex data type), you lose.</p>\n<p>If the compiler / optimizer decides to keep certain things in registers (such as the counter holding the number of valid entries in the array) during some operations, you lose.</p>\n<p>Or even if the compiler / optimizer decides to switch order of execution for your array element assignments and counter increments/decrements, you lose.</p>\n<p>So you certianly <em>do</em> need <em>some</em> sort of synchronization. What is the best way to do so (for example it may be worth while to lock only parts of the array), depends on your specifics (how often and in what pattern do the threads access the array).</p>\n", "LastActivityDate": "2014-07-10T21:47:54.290", "Score": "0", "CreationDate": "2014-07-10T21:47:54.290", "ParentId": "24682518", "CommentCount": "0", "OwnerUserId": "1640715"}, "24682584": {"Id": "24682584", "PostTypeId": "2", "Body": "<p>As far as I know, this is exactly the usecase for a lock. Two threads which access one array concurrently must ensure that one thread is ready with its work.\nThread B might read unfinished data if thread A did not finish work.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2014-07-10T23:08:04.940", "Score": "1", "CreationDate": "2014-07-10T17:16:05.960", "ParentId": "24682518", "CommentCount": "0", "LastEditDate": "2014-07-10T23:08:04.940", "OwnerUserId": "2029625"}, "24682619": {"Id": "24682619", "PostTypeId": "2", "Body": "<p>If two threads perform an operation on the same memory location, and at least one operation is a write operation, you have a so-called <em>data race</em>. According to C11 and C++11, the behaviour of programs with <em>data races</em> is undefined.</p>\n<p>So, you have to use some kind of synchronization mechanism, for example:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\">std::atomic</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/thread/mutex\">std::mutex</a></li>\n</ul>\n", "LastEditorUserId": "1305501", "LastActivityDate": "2014-07-10T17:30:08.257", "Score": "18", "CreationDate": "2014-07-10T17:19:01.317", "ParentId": "24682518", "CommentCount": "6", "LastEditDate": "2014-07-10T17:30:08.257", "OwnerUserId": "1305501"}, "24682685": {"Id": "24682685", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24682518_24682685_0\">One of the threads adds new elements to the array [...] and the other [reads] this array</p>\n</blockquote>\n<p>In order to add and remove elements to/from an array, you will need an index that specifies the last place of the array where the valid data is stored. Such index is necessary, because arrays cannot be resized without potential reallocation (which is a different story altogether). You may also need a second index to mark the initial location from which the reading is allowed.</p>\n<p>If you have an index or two like this, and assuming that you never re-allocate the array, it is not necessary to lock when you write to the array itself, as long as you lock the writes of valid indexes.</p>\n<pre><code>int lastValid = 0;\nint shared[MAX];\n...\nint count = toAddCount;\n// Add the new data\nfor (int i = lastValid ; count != 0 ; count--, i++) {\n    shared[i] = new_data(...);\n}\n// Lock a mutex before modifying lastValid\n// You need to use the same mutex to protect the read of lastValid variable\nlock_mutex(lastValid_mutex);\nlastValid += toAddCount;\nunlock_mutex(lastValid_mutex);\n</code></pre>\n<p>The reason this works is that when you perform writes to <code>shared[]</code> outside the locked region, the reader does not \"look\" past the <code>lastValid</code> index. Once the writing is complete, you lock the mutex, which normally causes a flush of the CPU cache, so the writes to <code>shared[]</code> would be complete before the reader is allowed to see the data.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2014-07-10T22:26:39.997", "Score": "4", "CreationDate": "2014-07-10T17:22:32.707", "ParentId": "24682518", "CommentCount": "2", "LastEditDate": "2014-07-10T22:26:39.997", "OwnerUserId": "335858"}, "24682658": {"Id": "24682658", "PostTypeId": "2", "Body": "<p>\"Classical\" POSIX would indeed need a lock for such a situation, but this is overkill. You just have to ensure that the reads and writes are atomic. C and C++ have that in the language since their 2011 versions of their standards. Compilers start to implement it, at least the latest versions of <a href=\"http://en.wikipedia.org/wiki/Clang\" rel=\"nofollow\">Clang</a> and <a href=\"http://en.wikipedia.org/wiki/GNU_Compiler_Collection\" rel=\"nofollow\">GCC</a> have it.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2014-07-10T23:09:33.147", "Score": "2", "CreationDate": "2014-07-10T17:21:20.300", "ParentId": "24682518", "CommentCount": "2", "LastEditDate": "2014-07-10T23:09:33.147", "OwnerUserId": "366377"}, "24682598": {"Id": "24682598", "PostTypeId": "2", "Body": "<p>It depends.  One situation where it could be bad is if you are removing an item in one thread then reading the last item by its index in your read thread.  That read thread would throw an OOB error.</p>\n", "LastActivityDate": "2014-07-10T17:17:06.560", "Score": "1", "CreationDate": "2014-07-10T17:17:06.560", "ParentId": "24682518", "CommentCount": "0", "OwnerUserId": "428916"}, "24682612": {"Id": "24682612", "PostTypeId": "2", "Body": "<p>If you are writing and reading from the same location from multiple threads you will need to to perform locking or use atomics. We can see this by looking at the C11 draft standard(<em>The C++11 standard looks almost identical, the equivalent section would be <code>1.10</code></em>) says the following in section <code>5.1.2.4</code> <em>Multi-threaded executions and data races</em>:</p>\n<blockquote>\n<p id=\"so_24682518_24682612_0\">Two expression evaluations conflict if one of them modifies a memory\n  location and the other one reads or modifies the same memory location.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_24682518_24682612_1\">The execution of a program contains a data race if it contains two\n  conflicting actions in different threads, at least one of which is not\n  atomic, and neither happens before the other. Any such data race\n  results in undefined behavior.</p>\n</blockquote>\n<p>and: </p>\n<blockquote>\n<p id=\"so_24682518_24682612_2\">Compiler transformations that introduce assignments to a potentially\n  shared memory location that would not be modified by the abstract\n  machine are generally precluded by this standard, since such an\n  assignment might overwrite another assignment by a different thread in\n  cases in which an abstract machine execution would not have\n  encountered a data race. This includes implementations of data member\n  assignment that overwrite adjacent members in separate memory\n  locations. We also generally preclude reordering of atomic loads in\n  cases in which the atomics in question may alias, since this may\n  violate the \"visible sequence\" rules.</p>\n</blockquote>\n<p>If you were just adding data to the array then in the C++ world a <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"nofollow\">std::atomic</a> index would be sufficient since you can add more elements and then atomically increment the index. But since you want to grow and shrink the array then you will need to use a mutex, in the C++ world <a href=\"http://en.cppreference.com/w/cpp/thread/lock_guard\" rel=\"nofollow\">std::lock_guard</a> would be a typical choice. </p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-07-14T13:57:49.743", "Score": "8", "CreationDate": "2014-07-10T17:18:26.947", "ParentId": "24682518", "CommentCount": "0", "LastEditDate": "2014-07-14T13:57:49.743", "OwnerUserId": "1708801"}});