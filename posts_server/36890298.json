post_cb({"36900118": {"ParentId": "36890298", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_36890298_36900118_0\">Will these two \"separate\" unnamed namespaces be treated as the same\n  scope within the compilation unit, or will different unique namespaces\n  be generated for each? Does the standard have anything to say about\n  this?</p>\n</blockquote>\n<p>Yes, they will be treated as same within the compilation unit. And the standard does have something to say....</p>\n<p>Quoting the <a href=\"http://eel.is/c++draft/\" rel=\"nofollow\">latest standard draft</a>... (emphasis are mine)</p>\n<blockquote>\n<p id=\"so_36890298_36900118_1\"><strong><a href=\"http://eel.is/c++draft/namespace.unnamed#1\" rel=\"nofollow\">$7.3.1.1</a></strong> An unnamed-namespace-definition behaves as if it were replaced by</p>\n<pre><code>inlineopt namespace unique { /* empty body */ }\nusing namespace unique ;\nnamespace unique { namespace-body }\n</code></pre>\n<p id=\"so_36890298_36900118_2\">where <code>inline</code> appears if and only if it appears in the\n  unnamed-namespace-definition and <strong>all occurrences of</strong> <code>unique</code> <strong>in a\n  translation unit are replaced by the same identifier</strong>, and this\n  identifier differs from all other identifiers in the translation unit</p>\n</blockquote>\n<p>Compile this short program, your compiler should complain of variable redeclaration...</p>\n<pre><code>namespace { int c = 0; }\nnamespace { double c = 8; }\n\nint main(){ ++c; }\n</code></pre>\n<p>However, to access variables in an unnamed namespace, you use the regular way of accessing global variables... Hence this will work.</p>\n<pre><code>namespace { int c = 0; }\nnamespace { void f(){ c = 8; } }\n\nint main(){ ++c; }\n</code></pre>\n", "OwnerUserId": "1621391", "LastEditorUserId": "1621391", "LastEditDate": "2016-04-27T20:31:28.677", "Id": "36900118", "Score": "4", "CreationDate": "2016-04-27T20:22:08.403", "LastActivityDate": "2016-04-27T20:31:28.677"}, "36890403": {"ParentId": "36890298", "CommentCount": "2", "Body": "<p>You can figure out the answer yourself simply by checking if the following code compiles:</p>\n<pre><code>namespace {\n   int a;\n}\n\nnamespace {\n   int *b=&amp;a;\n}\n</code></pre>\n<p>You expect to get a compilation error, if each namespace is unique; and this will compile with no issues if the unnamed namespace is the same one, in both cases.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "36890403", "Score": "-2", "CreationDate": "2016-04-27T12:52:19.547", "LastActivityDate": "2016-04-27T12:52:19.547"}, "36890298": {"CommentCount": "2", "ViewCount": "139", "CreationDate": "2016-04-27T12:47:48.220", "LastActivityDate": "2016-04-27T20:31:28.677", "Title": "Is there only one unnamed namespace per compilation unit?", "AcceptedAnswerId": "36900118", "PostTypeId": "1", "Id": "36890298", "Score": "5", "Body": "<p>I have inherited a horrible bit of legacy code which includes about 1000 lines of utility class definition that needs to appear before the \"real\" code in a source file. To avoid clashes with other modules that might also have associated legacy classes, I have put the utility class into an unnamed namespace:</p>\n<pre><code>namespace {\n    class OldUtils {\n        OldUtils();\n        int foo();\n        double bar();\n    };\n\n    OldUtils::OldUtils() {\n        // hundreds of lines\n    }\n\n    int OldUtils::foo() {\n        // hundreds more lines\n    }\n\n    ...\n}\n\nclass ActuallyInteresting {\n    // uses OldUtils\n};\n</code></pre>\n<p>But I would prefer to have the <code>ActuallyInteresting</code> code that people will be (actually) interested in near the top of the file, e.g. starting on line 50, than right at the bottom e.g. starting on line 1000. Splitting the horrid utility class into a separate compilation unit isn't an option, for higher-level reasons I won't go into!</p>\n<p>So I am wondering if it is possible to put the short class declaration -- without method definitions -- in an unnamed namespace at the top of the file, and the much longer method definitions in another unnamed namespace at the bottom:</p>\n<pre><code>namespace {\n    class OldUtils {\n        OldUtils();\n        int foo();\n        double bar();\n    };\n}\n\nclass ActuallyInteresting {\n    // uses OldUtils\n};\n\nnamespace {\n    OldUtils::OldUtils() {\n        // hundreds of lines\n    }\n\n    int OldUtils::foo() {\n        // hundreds more lines\n    }\n\n    ...\n}\n</code></pre>\n<p>Will these two \"separate\" unnamed namespaces be treated as the same scope within the compilation unit, or will different unique namespaces be generated for each? Does the standard have anything to say about this?</p>\n", "Tags": "<c++><namespaces><refactoring><legacy-code>", "OwnerUserId": "91808", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_36890298_36900118_1": {"section_id": 5482, "quality": 0.8, "length": 4}, "so_36890298_36900118_2": {"section_id": 5482, "quality": 0.95, "length": 19}}, "n3337": {"so_36890298_36900118_1": {"section_id": 5268, "quality": 0.8, "length": 4}, "so_36890298_36900118_2": {"section_id": 5268, "quality": 0.95, "length": 19}}, "n4659": {"so_36890298_36900118_1": {"section_id": 6917, "quality": 0.8, "length": 4}, "so_36890298_36900118_2": {"section_id": 6917, "quality": 0.95, "length": 19}}}});