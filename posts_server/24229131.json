post_cb({"bq_ids": {"n4140": {"so_24229131_24229538_1": {"length": 8, "quality": 1.0, "section_id": 7016}, "so_24229131_24229202_1": {"length": 8, "quality": 1.0, "section_id": 7023}, "so_24229131_24229131_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 405}, "so_24229131_24229131_0": {"length": 6, "quality": 0.75, "section_id": 7019}, "so_24229131_24229538_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 7023}, "so_24229131_24229131_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 7023}, "so_24229131_24229202_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5880}}, "n3337": {"so_24229131_24229538_1": {"length": 8, "quality": 1.0, "section_id": 6762}, "so_24229131_24229202_1": {"length": 8, "quality": 1.0, "section_id": 6769}, "so_24229131_24229131_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 396}, "so_24229131_24229131_0": {"length": 6, "quality": 0.75, "section_id": 6765}, "so_24229131_24229538_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 6769}, "so_24229131_24229131_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 6769}, "so_24229131_24229202_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5651}}, "n4659": {"so_24229131_24229538_1": {"length": 8, "quality": 1.0, "section_id": 8513}, "so_24229131_24229202_1": {"length": 8, "quality": 1.0, "section_id": 8520}, "so_24229131_24229131_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 423}, "so_24229131_24229131_0": {"length": 6, "quality": 0.75, "section_id": 8516}, "so_24229131_24229538_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 8520}, "so_24229131_24229131_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 8520}}}, "24229538": {"Id": "24229538", "PostTypeId": "2", "Body": "<p>UB happens if there is a <em>virtual call</em> (10.3 [class.virtual]).</p>\n<blockquote>\n<p id=\"so_24229131_24229538_0\">the effect of making a virtual call (10.3) to a pure virtual function ... is undefined.</p>\n</blockquote>\n<p>But 10.3 [class.virtual] p15 says that</p>\n<blockquote>\n<p id=\"so_24229131_24229538_1\">Explicit qualification with the scope operator (5.1) suppresses the virtual call mechanism.</p>\n</blockquote>\n<p>It seems that implicit destructor call has an explicit qualification.<br>\nAt least compiler definitely doesn't do a virtual call there.</br></p>\n", "LastActivityDate": "2014-06-15T12:21:52.287", "Score": "-2", "CreationDate": "2014-06-15T12:21:52.287", "ParentId": "24229131", "CommentCount": "0", "OwnerUserId": "343443", "CommunityOwnedDate": "2014-06-15T12:21:52.287"}, "24229131": {"ViewCount": "149", "Body": "<p>It is known that we can use pure virtual destructors, like this:</p>\n<pre><code>struct A {\n    virtual ~A() = 0;\n};\nA::~A() {}\n\nstruct B : A {};\n</code></pre>\n<p>Because the Standard says in <code>10.4 [class.abstract] p2</code></p>\n<blockquote>\n<p id=\"so_24229131_24229131_0\">A pure virtual function need be defined only if called ... with (12.4 [class.dtor])</p>\n</blockquote>\n<p>And later in <code>12.4 [class.dtor] p9</code></p>\n<blockquote>\n<p id=\"so_24229131_24229131_1\">A destructor can be declared virtual (10.3) or pure virtual (10.4); if any objects of that class or any derived class are created in the program, the destructor shall be defined.</p>\n</blockquote>\n<p>What means that the code above is perfectly valid - <code>A::~A</code> may be pure virtual, it is defined, <code>B::~B</code> implicitly calls <code>A::~A</code>.</p>\n<p>So far, so good.<br>\nAnd then I read <code>10.4 [class.abstract] p6</code>:</br></p>\n<blockquote>\n<p id=\"so_24229131_24229131_2\">Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</p>\n</blockquote>\n<p>But that's exactly what we do here - we call a pure virtual function <code>A::~A</code> from a destructor.</p>\n<p>So, isn't there some kind of contradiction?</p>\n", "Title": "If call to a pure virtual function from destructor is UB, why can we use pure virtual desrtuctors?", "CreationDate": "2014-06-15T11:28:42.140", "LastActivityDate": "2014-06-15T12:21:52.287", "CommentCount": "1", "PostTypeId": "1", "Id": "24229131", "Score": "1", "OwnerUserId": "343443", "Tags": "<c++><destructor><undefined-behavior><pure-virtual>", "AnswerCount": "2"}, "24229202": {"Id": "24229202", "PostTypeId": "2", "Body": "<p>There is no contraction.</p>\n<p>You call the virtual destructor of <code>A</code> from the destructor of <code>B</code>.<code>A</code> destructor is not a member of <code>B</code>.</p>\n<p>Standard \u00a7 9.3</p>\n<p><strong>Member Functions</strong></p>\n<blockquote>\n<p id=\"so_24229131_24229202_0\">Functions declared in the definition of a class, excluding those\n  declared with a friend specifier (\n  11.3 ), are called member functions of that class</p>\n</blockquote>\n<p>The standard states that there is undefined behavior when there is a virtual call <strong>from the abstract</strong> class destructor/constructor (which in your case, would be class <code>A</code>) to one of it's own pure virtual member function.</p>\n<blockquote>\n<p id=\"so_24229131_24229202_1\">[...] Member functions can be called from a constructor (or destructor) of an <strong>abstract</strong> class [...]; </p>\n</blockquote>\n<p>Your quote says for destructors:</p>\n<ol>\n<li>You can call member functions from the destructor of an abstract class</li>\n<li>If you call a pure virtual method (with a virtual call) <strong>from</strong> the destructor of this same abstract class, there is undefined behavior.</li>\n</ol>\n", "LastEditorUserId": "3510483", "LastActivityDate": "2014-06-15T12:16:35.287", "Score": "3", "CreationDate": "2014-06-15T11:37:14.457", "ParentId": "24229131", "CommentCount": "2", "OwnerUserId": "3510483", "LastEditDate": "2014-06-15T12:16:35.287"}});