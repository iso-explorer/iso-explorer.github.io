post_cb({"21314793": {"CommentCount": "6", "ViewCount": "145", "PostTypeId": "1", "LastEditorUserId": "1141471", "CreationDate": "2014-01-23T17:05:35.773", "LastActivityDate": "2014-01-23T22:31:18.807", "Title": "Should I assume an object's destructor is called immediately after removal from STL containers?", "LastEditDate": "2014-01-23T18:09:10.850", "Id": "21314793", "Score": "6", "Body": "<p>Consider the following code:</p>\n<pre><code>class T { ... }; // T has a non-trivial destructor\n\nvoid foo() {\n    std::vector&lt;T&gt; v( 5 );\n    v.pop_back();\n\n    ...\n}\n</code></pre>\n<p>After <code>v.pop_back()</code>, does the STL guarantee that <code>T::~T()</code> has been called for <code>v.back()</code>?  Note: The question holds for any method of vector that removes elements (e.g. <code>resize()</code>, <code>erase()</code>, etc...)</p>\n<p>I am writing container classes for my application and I would like them to conform as much as possible to the principles used by the standard library.  If my container class does not make this guarantee, are there any risks?</p>\n", "Tags": "<c++><vector><stl><destructor>", "OwnerUserId": "1303358", "AnswerCount": "2"}, "21319899": {"ParentId": "21314793", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++11 \u00a7 23.2.3 describes the requirements for a sequence container.</p>\n<p>The entry for <code>pop_back()</code> says it \"Destroys the last element.\"</p>\n<p>I suppose you could argue that it doesn't explicitly say immediately. Though, I suspect that was meant to be implied.</p>\n<p>Another requirement of note is in \u00a7 23.2.1. It says about a container's destructor</p>\n<blockquote>\n<p id=\"so_21314793_21319899_0\">note: the destructor is applied to every element of a; all the memory\n  is deallocated.</p>\n</blockquote>\n<p>So I suppose you could defer destroying the removed elements so long as they're destroyed before the container is destroyed.</p>\n<p>That all said if you're truly trying to follow the principles of the standard I can confidently say the standard authors would have expected a removed element to be immediately destroyed.</p>\n", "OwnerUserId": "28817", "LastEditorUserId": "28817", "LastEditDate": "2014-01-23T21:52:20.890", "Id": "21319899", "Score": "2", "CreationDate": "2014-01-23T21:39:34.210", "LastActivityDate": "2014-01-23T21:52:20.890"}, "21314938": {"ParentId": "21314793", "PostTypeId": "2", "CommentCount": "1", "Body": "<pre><code>std::vector::erase\n</code></pre>\n<p>Removes from the vector container and calls destructor on element. The same applies to <code>std::vector::pop_back</code>.</p>\n<pre><code>void pop_back() {\n    --this-&gt;_M_impl._M_finish;\n    this-&gt;_M_impl.destroy(this-&gt;_M_impl._M_finish);\n      }\n</code></pre>\n<p>and destroy is a method of allocator:</p>\n<pre><code>void destroy(pointer __p) { __p-&gt;~_Tp(); }\n                              ^^^\n                            dereference and call destructor\n                            on new_allocator::value_type\n</code></pre>\n<p>on my implementation allocator for <code>vector</code> which is template argument <code>Alloc = std::allocator&lt;_Tp&gt;</code> initializes it's base <code>__glibcxx_base_allocator</code> whith <code>new_allocator</code> due to this definition:</p>\n<pre><code> #define __glibcxx_base_allocator  __gnu_cxx::new_allocator \n\nallocator(const allocator&amp; __a) throw()\n      : __glibcxx_base_allocator&lt;_Tp&gt;(__a) { }\n</code></pre>\n", "OwnerUserId": "1141471", "LastEditorUserId": "1141471", "LastEditDate": "2014-01-23T22:31:18.807", "Id": "21314938", "Score": "2", "CreationDate": "2014-01-23T17:12:18.677", "LastActivityDate": "2014-01-23T22:31:18.807"}, "bq_ids": {"n4140": {"so_21314793_21319899_0": {"section_id": 705, "quality": 0.875, "length": 7}}, "n3337": {"so_21314793_21319899_0": {"section_id": 695, "quality": 1.0, "length": 8}}, "n4659": {"so_21314793_21319899_0": {"section_id": 734, "quality": 0.75, "length": 6}}}});