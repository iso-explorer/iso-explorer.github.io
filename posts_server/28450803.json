post_cb({"28450977": {"CreationDate": "2015-02-11T09:40:10.687", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28450803_28450977_0\">Derived class should inherit all ctors of base except the default ctor</p>\n</blockquote>\n<p>No, that's not true, see <a href=\"https://stackoverflow.com/a/28450893/981959\">T.C.'s answer</a> for the real rule.</p>\n<p>The purpose of inheriting constructors is to say \"the derived type can be created from the same arguments as the base type\", but that isn't relevant for the base class' copy constructor, because a copy constructor is not just a way of saying how to create a type from a given argument.</p>\n<p>A copy constructor is special, it's for copying an object of the same type.</p>\n<p>A constructor <code>D(const C&amp;)</code> would not used be for copying an object of the same type, because <code>C</code> is not the same type as <code>D</code>.</p>\n", "Id": "28450977", "OwnerUserId": "981959", "LastEditDate": "2017-05-23T11:46:14.863", "ParentId": "28450803", "LastActivityDate": "2015-02-11T09:40:10.687", "PostTypeId": "2", "Score": "10", "LastEditorUserId": "-1"}, "28453159": {"CreationDate": "2015-02-11T11:26:06.563", "CommentCount": "0", "Body": "<p>For a moment, we\u2019ll assume \u2018copy constructor inheritance\u2019 is allowed. \nHaving your class structure intact, please consider following code for modified main method.</p>\n<pre><code>int main() {\n    C c;\n    D d;\n    D d_from_d(d);\n    D d_from_c(c); // does not compile, copy ctor is not inherited\n    D d_from_int(1); // compiles, C(int) is inherited\n}  \n</code></pre>\n<p>In <code>D d_from_d(d)</code>, as a normal constructor call, there will be two copy constructor calls. One for C::C(const C&amp;) and the other one is for compiler generated copy constructor for D. Having source object type in D (d in this case), C\u2019s copy constructor can copy d\u2019s C attributes while compiler generated D\u2019s copy constructor can copy d\u2019s D attribute. </p>\n<p>But in <code>D d_from_c(c)</code> case, There is no problem for C\u2019s copy constructor because, c\u2019s C attributes can be copies by C\u2019s copy constructor. But how does the compiler generated D\u2019s copy constructor know the way to copy \u2018D\u2019s attributes from C\u2019s object\u2019. This is a conflict which should be avoided. </p>\n<p>But, if you provide some sort of \u2018weird copy constructor\u2019 (you may need to a default constructor as well) like;</p>\n<pre><code>D(const C &amp; c):C(c){} \n</code></pre>\n<p>Then,\n calling <code>D d_from_c(c);</code>\nis valid. Because, now we have explicitly provided a matching \u2018copy\u2019 constructor. </p>\n<p>So, saying \u2018Inheriting copy constructors are now allowed\u2019 is invalid. </p>\n", "Id": "28453159", "OwnerUserId": "3219193", "LastEditDate": "2015-02-11T11:40:31.570", "ParentId": "28450803", "LastActivityDate": "2015-02-11T11:40:31.570", "PostTypeId": "2", "Score": "0", "LastEditorUserId": "3219193"}, "bq_ids": {"n4140": {"so_28450803_28450893_0": {"length": 40, "quality": 0.975609756097561, "section_id": 484}}, "n3337": {"so_28450803_28450893_0": {"length": 35, "quality": 0.8536585365853658, "section_id": 475}}}, "28450803": {"CreationDate": "2015-02-11T09:31:50.067", "ViewCount": "1564", "Id": "28450803", "AcceptedAnswerId": "28450893", "Score": "9", "Title": "Copy constructor is not inherited", "LastEditorUserId": "-1", "CommentCount": "0", "Body": "<p>I've got the following code:</p>\n<pre><code>class C {\npublic:\n    C(int) {}\n    C(const C&amp;) {}\n    C() {}\n};  \n\nclass D : public C { \npublic:\n    using C::C;\n};  \n\nint main() {\n    C c;\n    D d_from_c(c); // does not compile, copy ctor is not inherited\n    D d_from_int(1); // compiles, C(int) is inherited\n}   \n</code></pre>\n<p>Derived class should inherit all ctors of base except the default ctor (it is explained <a href=\"https://stackoverflow.com/questions/23248597/need-an-example-showing-that-default-constructor-is-not-inherited\" title=\"here\">here</a>). But why copy ctor is not inherited as well? Arguments from the related question are not acceptable here.</p>\n<p>The code is compiled with g++ 4.8.1.</p>\n", "Tags": "<c++><c++11><inheritance><copy-constructor>", "LastEditDate": "2017-05-23T12:17:08.460", "LastActivityDate": "2015-02-11T11:40:31.570", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "2159939"}, "28450893": {"CommentCount": "0", "Body": "<p>Because the standard says so. [class.inhctor]/p3, emphasis mine:</p>\n<blockquote>\n<p id=\"so_28450803_28450893_0\">For each non-template constructor in the candidate set of inherited\n  constructors <strong>other than a constructor having no parameters or a\n  copy/move constructor having a single parameter</strong>, a constructor is\n  implicitly declared with the same constructor characteristics unless\n  there is a user-declared constructor with the same signature in the\n  complete class where the using-declaration appears or the constructor\n  would be a default, copy, or move constructor for that class.</p>\n</blockquote>\n", "CreationDate": "2015-02-11T09:36:08.653", "ParentId": "28450803", "Id": "28450893", "LastActivityDate": "2015-02-11T09:36:08.653", "PostTypeId": "2", "Score": "12", "OwnerUserId": "2756719"}});