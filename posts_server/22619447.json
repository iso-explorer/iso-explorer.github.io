post_cb({"22619655": {"Id": "22619655", "PostTypeId": "2", "Body": "<p>Because </p>\n<pre><code>template&lt;typename T&gt; void _setValueSafeFails(T &amp;value, const T setVal) {\n    value = setVal;\n}\n</code></pre>\n<p>would be instanciated to:</p>\n<pre><code>void _setValueSafeFails(volatile bool &amp;value, const volatile bool setVal)\n</code></pre>\n", "LastActivityDate": "2014-03-24T20:13:30.580", "CommentCount": "0", "CreationDate": "2014-03-24T20:13:30.580", "ParentId": "22619447", "Score": "1", "OwnerUserId": "2293156"}, "22619893": {"Id": "22619893", "PostTypeId": "2", "Body": "<p>The type volatile bool and bool are different types and lead to the mismatch in _setValueSafeFails.</p>\n<p>You may do:</p>\n<pre><code>class Test\n{\npublic:\n  void test();\n  template&lt;typename T, typename U&gt; void _setValueSafeA(T &amp;value, const U setVal) {\n    value = setVal;\n  }\n  template&lt;typename T&gt; void _setValueSafeB(T &amp;value, const T&amp; setVal) {\n    value = setVal;\n  }\n\n  volatile bool _testValue;\n\n};\n\nvoid Test::test() {\n  volatile bool true_value = true;\n  _setValueSafeA(_testValue, true);\n  _setValueSafeB(_testValue, true_value);\n}\n</code></pre>\n", "LastActivityDate": "2014-03-24T20:27:17.477", "CommentCount": "0", "CreationDate": "2014-03-24T20:27:17.477", "ParentId": "22619447", "Score": "0", "OwnerUserId": "2249683"}, "22619447": {"ViewCount": "181", "Body": "<p>In C++03, I have the following code built with gcc v3.4.6 for which I don't understand why calling <code>_setValueSafeFails()</code> get a compiler error where as calling the similar <code>_incrValueSafe()</code> does not.</p>\n<p>Test.h:</p>\n<pre><code>class Test\n{\npublic:\n  void test();\n\n  template&lt;typename T&gt; void _incrValueSafe(T &amp;value) {\n    ++value;\n  }\n\n  template&lt;typename T&gt; void _setValueSafeFails(T &amp;value, const T setVal) {\n    value = setVal;\n  }\n\n  template&lt;typename T&gt; void _setValueSafeWorks(volatile T &amp;value, const T setVal) {\n    value = setVal;\n  }\n\n  volatile bool _testValue;\n\n};\n</code></pre>\n<p>Test.cpp:</p>\n<pre><code>#include \"Test.h\"\n\nvoid Test::test() {\n  _incrValueSafe(_testValue);\n  _setValueSafeFails(_testValue, true);\n  _setValueSafeWorks(_testValue, true);\n}\n\nTest.cpp: In member function `void Test::test()':\nTest.cpp:5: error: no matching function for call to `Test::_setValueSafeFails(volatile bool&amp;, bool)'\n</code></pre>\n<p>Shouldn't <code>_incrValueSafe()</code> get the same error since there is no <code>volatile</code> in its signature either?  How are these two treated differently, or is this just a compiler bug?</p>\n", "AcceptedAnswerId": "22636581", "Title": "Why is volatile required with template argument in one case but not other?", "CreationDate": "2014-03-24T20:00:53.630", "Id": "22619447", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-03-25T13:49:19.603", "Score": "0", "OwnerUserId": "115751", "Tags": "<c++><templates><language-lawyer><volatile>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_22619447_22636581_3": {"length": 10, "quality": 1.0, "section_id": 6307}, "so_22619447_22636581_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6307}, "so_22619447_22636581_1": {"length": 8, "quality": 1.0, "section_id": 6307}}, "n3337": {"so_22619447_22636581_3": {"length": 10, "quality": 1.0, "section_id": 6064}, "so_22619447_22636581_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6064}, "so_22619447_22636581_1": {"length": 8, "quality": 1.0, "section_id": 6064}}, "n4659": {"so_22619447_22636581_3": {"length": 9, "quality": 0.9, "section_id": 6756}, "so_22619447_22636581_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 6756}, "so_22619447_22636581_1": {"length": 5, "quality": 0.625, "section_id": 7844}}}, "22636581": {"Id": "22636581", "PostTypeId": "2", "Body": "<p>As others have explained, binding the first parameter to <code>_testValue</code> implies\nthat <code>T</code> is <code>volatile bool</code>, whereas binding the second parameter to <code>true</code>\nimplies that <code>T</code> is merely <code>bool</code> (without the <code>volatile</code> modifier).  The\n<code>clang</code> compiler gives a nice diagnostic:</p>\n<pre><code>clang++ -o main  -std=c++1y -pedantic -Wall -stdlib=libc++ main.cpp -stdlib=libc++\nmain.cpp:26:5: error: no matching member function for call to '_setValueSafeFails'\n    _setValueSafeFails(_testValue, true);\n    ^~~~~~~~~~~~~~~~~~\nmain.cpp:12:35: note: candidate template ignored: deduced conflicting types for parameter 'T' ('volatile bool' vs. 'bool')\n        template&lt;typename T&gt; void _setValueSafeFails(T &amp;value, const T setVal) {\n                                  ^\nmain.cpp:9:13: warning: incrementing expression of type bool is deprecated [-Wdeprecated-increment-bool]\n            ++value;\n            ^ ~~~~~\nmain.cpp:25:5: note: in instantiation of function template specialization 'Test::_incrValueSafe&lt;volatile bool&gt;' requested here\n    _incrValueSafe(_testValue);\n    ^\n1 warning and 1 error generated.\nmake: *** [main] Error 1\n</code></pre>\n<p>Regarding leading underscores: I just avoid them, partly to avoid debates about\nwhat is or isn't strictly legal.  I prefer the popular convention: prefix\nprivate variables with <code>m_</code>, and don't decorate private function names in any\nspecial way.  (Leading underscores are de rigeur for private members in Python,\nbut of course, C++ is a very different language.) For the record, the holy\nstandard says the following:</p>\n<blockquote>\n<p id=\"so_22619447_22636581_0\"><code>17.6.4.3.2 Global names [global.names]</code></p>\n<hr>\n<ol>\n<li><p id=\"so_22619447_22636581_1\">Certain sets of names and function signatures are always reserved to the\n   implementation:</p>\n<p id=\"so_22619447_22636581_2\">\u2014 Each name that contains a double underscore <code>__</code> or begins with an\n      underscore followed by an uppercase letter (2.12) is reserved to the\n      implementation for any use.</p>\n<p id=\"so_22619447_22636581_3\">\u2014 Each name that begins with an underscore is reserved to the\n      implementation for use as a name in the global namespace.</p></li>\n</ol>\n</hr></blockquote>\n", "LastActivityDate": "2014-03-25T13:49:19.603", "CommentCount": "0", "CreationDate": "2014-03-25T13:49:19.603", "ParentId": "22619447", "Score": "1", "OwnerUserId": "3116635"}, "22619537": {"Id": "22619537", "PostTypeId": "2", "Body": "<p><code>typename T</code> for <code>_incrValueSafe</code> is <code>volatile bool</code> </p>\n", "LastActivityDate": "2014-03-24T20:06:19.230", "CommentCount": "0", "CreationDate": "2014-03-24T20:06:19.230", "ParentId": "22619447", "Score": "1", "OwnerUserId": "1720243"}});