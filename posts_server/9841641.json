post_cb({"9842671": {"ParentId": "9841641", "CommentCount": "2", "Body": "<p>Do not cast the const away, as it will break its meaning! \nThere is a reason why the STL has a const_iterator and iterator class. If you want const correctness you will have to implement two seperate iterator classes. One of the goals of a iterator is to mimic a save pointer. So you do not want to return null if you're beyond the iteration range, you want to raise a debug assertion if this actually happens.</p>\n<p>A const iterator class could look something like this:</p>\n<pre><code>template&lt;class Item&gt;\nclass DFSIteratorConst\n{\npublic:\n    DFSIteratorConst(const Item&amp; node)\n    {\n        m_pCurrentNode = &amp;node;\n    };\n\n    const Item&amp; operator*() const\n    {\n        assert(!IsDone());\n        return *m_pCurrentNode;\n    }\n\n    void operator++()\n    {\n        assert(!IsDone());\n        m_pCurrentNode = m_pCurrentNode-&gt;next;\n    }\n\n    operator bool() const\n    {\n        return !IsDone();\n    }\n\n    bool IsDone() const\n    {\n        return m_pCurrentNode == nullptr;\n    }\n\nprivate:\n    Item const * m_pCurrentNode;\n};\n</code></pre>\n<p>A few things to note:</p>\n<ul>\n<li>consider returning a reference to the node (a const reference). This causes you to not be able to return null if the iterator is past the last element. Dereferencing a past the end iterator is usually bad behaviour and you want to find those issues during debug builds and testing</li>\n<li>the const iterator class has a pointer to a const element. Meaning that it can change the pointer (otherwise you would not be able to iterate) but can <strong><em>not</em></strong> modify the element itself</li>\n<li>the implicit conversion to bool is practical if you want to check the iterator in a while loop. This allows you to write: <code>while(it) { it++; }</code> instead of <code>while(!it.IsDone()) { it++; }</code> again, something that resembles a classic pointer.</li>\n<li>use <a href=\"http://en.wikibooks.org/wiki/More_C++_Idioms/nullptr\" rel=\"nofollow\" title=\"nullptr\">nullptr</a> if available</li>\n</ul>\n<p>As I can see from your use of <code>std::map</code> your are already using the STL. Maybe it would be easier to use exsiting STL iterators?</p>\n", "OwnerUserId": "1288539", "PostTypeId": "2", "Id": "9842671", "Score": "2", "CreationDate": "2012-03-23T16:13:34.587", "LastActivityDate": "2012-03-23T16:13:34.587"}, "9842548": {"ParentId": "9841641", "CommentCount": "1", "Body": "<p>The real problem is that this code/interface is \"lying\".</p>\n<p>The constructor says: I don't change you (the root).\nBut the iterator gives changeable Item away.</p>\n<p>To be \"honest\" either the constructor takes a changeable root, even when it will not changed within this class,\nor this class does not give changeable Item away.</p>\n<p>However, Item itself defines whether it give changeable childs away.\nDepending on that code may not compile. Maybe this is the reason for your construction.</p>\n<p>Long talking, short meaning: this design is poor and should be changed</p>\n<p>Probably you need two templates depending on the \"const\"-ness of given childs away</p>\n", "OwnerUserId": "732454", "PostTypeId": "2", "Id": "9842548", "Score": "1", "CreationDate": "2012-03-23T16:04:27.147", "LastActivityDate": "2012-03-23T16:04:27.147"}, "9842103": {"ParentId": "9841641", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><code>const_cast</code>ing in itself is always safe, but any attempt to write to <code>const_cast</code>ed values who have been declared <code>const</code> is undefined behaviour. </p>\n<p>In this case, if your returned pointer points to a value that is declared <code>const</code> and you attempt to modify it, you'll get undefined behavior.</p>\n<hr>\n<p>Rule of thumb: <strong>If you need to use <code>const_cast</code> for anything but interoperation with const-incorrect code, your design is broken.</strong></p>\n<hr>\n<p>The standard says in <em>7.1.6.1 The cv-qualifiers</em>:</p>\n<blockquote>\n<p id=\"so_9841641_9842103_0\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "76722", "LastEditorUserId": "76722", "LastEditDate": "2012-03-23T15:50:14.093", "Id": "9842103", "Score": "1", "CreationDate": "2012-03-23T15:37:19.573", "LastActivityDate": "2012-03-23T15:50:14.093"}, "9842208": {"ParentId": "9841641", "CommentCount": "2", "Body": "<p>As your constructor uses a <code>const Item</code>, your operator shoud return a const pointer.</p>\n<p>If you want to return a non-const item, you should use a non const parameter for your constructor. A solution is having a base class using const objects, and a subclass working with non-const objects (A bit in a way it is done in Objc, eg NSString and NSMutableString).</p>\n", "OwnerUserId": "754288", "PostTypeId": "2", "Id": "9842208", "Score": "2", "CreationDate": "2012-03-23T15:44:16.063", "LastActivityDate": "2012-03-23T15:44:16.063"}, "9841641": {"CommentCount": "2", "ViewCount": "202", "PostTypeId": "1", "LastEditorUserId": "1284317", "CreationDate": "2012-03-23T15:10:12.333", "LastActivityDate": "2012-03-23T16:13:34.587", "Title": "Is it safe to do a const cast here?", "AcceptedAnswerId": "9842103", "LastEditDate": "2012-03-23T16:10:13.063", "Id": "9841641", "Score": "2", "Body": "<p>I've written my own generic tree implementation, and when writing iterators for it, I am having trouble with const correctness. The issue I am having currently is as follows:</p>\n<p>This is the header file for a DFS iterator I wrote:</p>\n<pre><code>template&lt;class Item&gt;\nclass DFSIterator\n{\npublic:\n    DFSIterator(const Item&amp; rRootNode);\n    ~DFSIterator();\n    DFSIterator* First();\n    DFSIterator* operator++(int rhs);\n    Item* operator*() const;\n    Item* operator-&gt;() const;\n    bool isDone() const;\n\n    template &lt;class Node&gt; friend class Node;\n\nprivate:\n    void initListIterator(const Item* currentNode);\n\n    bool m_bIsDone;\n    const Item* m_pRootNode;\n    const Item* m_pCurrentNode;\n    ListIterator&lt;Item&gt;* m_pCurrentListIter;\n    std::map&lt;const Item*, ListIterator&lt;Item&gt;*&gt;  m_listMap;\n};\n</code></pre>\n<p>So the bit I am concerned about is the dereference operator:</p>\n<pre><code>template&lt;class Item&gt;\nItem* DFSIterator&lt;Item&gt;::operator*() const\n{\n    if(isDone())\n    {\n        return NULL;\n    }\n    else\n    {\n        return const_cast&lt;Item*&gt;(m_pCurrentNode);\n    }\n}\n</code></pre>\n<p>Is it appropriate to do a const_cast there? I'm wondering if this would cause problems if a user put const objects into the container?</p>\n", "Tags": "<c++><iterator><const-cast>", "OwnerUserId": "1284317", "AnswerCount": "5"}, "9842285": {"ParentId": "9841641", "CommentCount": "0", "Body": "<p>Normally, you write two iterators versions, an <code>iterator</code> and a <code>const_iterator</code>.</p>\n<p>There are template tricks to avoid the code duplication that is exposed in the Boost.Iterator library documentation. See how the <a href=\"http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/iterator_adaptor.html\" rel=\"nofollow\">Iterator Adaptor</a> is defined as it is quite long.</p>\n<p>The thing is that you will write a <code>BaseIterator</code> that is <code>const</code> conscious, and then provide aliases:</p>\n<ul>\n<li><code>typedef BaseIterator&lt;Item&gt; Iterator;</code></li>\n<li><code>typedef BaseIterator&lt;Item const&gt; ConstIterator;</code></li>\n</ul>\n<p>The trickery is in how you define the conversion constructor so that <code>Iterator</code> to <code>ConstIterator</code> is possible but the reverse is not.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "9842285", "Score": "1", "CreationDate": "2012-03-23T15:48:55.293", "LastActivityDate": "2012-03-23T15:48:55.293"}, "bq_ids": {"n4140": {"so_9841641_9842103_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_9841641_9842103_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_9841641_9842103_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}});