post_cb({"37788300": {"CommentCount": "4", "ViewCount": "115", "PostTypeId": "1", "LastEditorUserId": "364696", "CreationDate": "2016-06-13T11:12:41.580", "LastActivityDate": "2016-06-13T11:31:45.497", "Title": "Why is explicit specialization of a member not allowed without specializing the class?", "AcceptedAnswerId": "37788664", "LastEditDate": "2016-06-13T11:14:45.103", "Id": "37788300", "Score": "1", "Body": "<p>The C++ standard states the following:</p>\n<blockquote>\n<p id=\"so_37788300_37788300_0\">In an explicit specialization declaration for a member of a class template or a member template that\n  appears in namespace scope, the member template and some of its enclosing class templates may remain\n  unspecialized, except that <strong>the declaration shall not explicitly specialize a class member template if its\n  enclosing class templates are not explicitly specialized as well</strong>. (14.7.3/16 since C++11 and 14.7.3/18 in older standards)</p>\n</blockquote>\n<p>This means that the following is not possible:</p>\n<pre><code>template&lt;typename T&gt;\nclass foo {\n  template&lt;typename U&gt;\n  void bar();\n};\n\ntemplate&lt;typename T&gt;\ntemplate&lt;&gt;\nvoid foo&lt;T&gt;::bar&lt;some_type&gt;(){\n}\n</code></pre>\n<p>There have already been multiple questions of people having problems related to this, which were answered more or less by \"the standard says so\". What I don't really understand is why this restriction exists.</p>\n", "Tags": "<c++><templates><standards><language-lawyer><explicit-specialization>", "OwnerUserId": "3725343", "AnswerCount": "2"}, "37788664": {"ParentId": "37788300", "CommentCount": "0", "Body": "<p>Thanks to JohnB for the answer:</p>\n<p>In the case, where there is one specialization for only the class (e.g. <code>T=int</code>), and another specialization for only the member (e.g. <code>U=int</code>), it would be impossible to decide, which specialization to use.</p>\n<p>Another point by skyjpack:</p>\n<p>There could be a class specialization without the member function.</p>\n", "OwnerUserId": "3725343", "PostTypeId": "2", "Id": "37788664", "Score": "0", "CreationDate": "2016-06-13T11:29:09.510", "LastActivityDate": "2016-06-13T11:29:09.510"}, "37788729": {"ParentId": "37788300", "CommentCount": "2", "Body": "<p>Template function is instantiated when it is first used or when it is specialized.</p>\n<p>When you do partial specialization you can't instantiate function, as it is still template function. So when you do specialization, compiler somehow must understand that you already had partial instantiation and match it to your instantiation, which can lead to difficulties.</p>\n<p>People say in the comments, that it can lead to an ambiguity, but a lot of things can lead to ambiguous things. Think of overloaded functions, for example. If it is ambiguous which overloaded function to call, compiler tells you about it. Same in this case.</p>\n", "OwnerUserId": "5502206", "PostTypeId": "2", "Id": "37788729", "Score": "0", "CreationDate": "2016-06-13T11:31:45.497", "LastActivityDate": "2016-06-13T11:31:45.497"}, "bq_ids": {"n4140": {"so_37788300_37788300_0": {"section_id": 278, "quality": 0.8536585365853658, "length": 35}}, "n3337": {"so_37788300_37788300_0": {"section_id": 269, "quality": 0.8536585365853658, "length": 35}}, "n4659": {"so_37788300_37788300_0": {"section_id": 285, "quality": 0.8536585365853658, "length": 35}}}});