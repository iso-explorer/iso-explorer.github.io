post_cb({"38834149": {"CommentCount": "3", "ViewCount": "182", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-08-08T16:22:16.173", "LastActivityDate": "2016-08-09T14:19:05.513", "Title": "How does using ellipses for SFINAE work?", "AcceptedAnswerId": "38834461", "LastEditDate": "2016-08-08T16:38:22.820", "Id": "38834149", "Score": "5", "Body": "<p>When using SFINAE to select constructor overloads in the past, I have typically used the following:</p>\n<pre><code>template &lt;typename T&gt;\nclass Class {\npublic:\n    template &lt;typename U = T, typename std::enable_if&lt;std::is_void&lt;U&gt;::value, int&gt;::type=0&gt;\n    Class() {\n        std::cout &lt;&lt; \"void\" &lt;&lt; std::endl;\n    }\n\n    template &lt;typename U = T, typename std::enable_if&lt;!std::is_void&lt;U&gt;::value, int&gt;::type=0&gt;\n    Class() {\n        std::cout &lt;&lt; \"not void\" &lt;&lt; std::endl;\n    }\n};\n</code></pre>\n<p>However, I just came across this alternative:</p>\n<pre><code>template &lt;typename U = T, typename std::enable_if&lt;std::is_void&lt;U&gt;::value&gt;::type...&gt;\nClass() {\n    std::cout &lt;&lt; \"void\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Considering that the following is illegal ...</p>\n<pre><code>template &lt;typename U = T, void...&gt; // ERROR!\nClass() { }\n</code></pre>\n<p>... how does the alternative above using ellipses rather than a non-type template argument work?</p>\n<hr>\n<p>Full code: <a href=\"http://coliru.stacked-crooked.com/a/64a1aaf13ce6099b\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/64a1aaf13ce6099b</a></p>\n</hr>", "Tags": "<c++><c++11><variadic-templates><sfinae>", "OwnerUserId": "694509", "AnswerCount": "1"}, "38834461": {"ParentId": "38834149", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>My previous answer was wrong. Sorry. I'm just going to fix it.</p>\n<hr/>\n<p>This declaration:</p>\n<pre><code>template &lt;typename U = T, void...&gt;\nClass() { }\n</code></pre>\n<p>violates [temp.res]/8:</p>\n<blockquote>\n<p id=\"so_38834149_38834461_0\">The program is\n  ill-formed, no diagnostic required, if [...] every valid specialization of a variadic template requires an empty template parameter pack</p>\n</blockquote>\n<p>It's no diagnostic required, but the compiler chooses to issue one anyway. Either way, the code is ill-formed.</p>\n<p>On the other hand</p>\n<pre><code>template &lt;typename U = T, std::enable_if_t&lt;std::is_void&lt;U&gt;::value&gt;...&gt;\nClass() { }\n</code></pre>\n<p>doesn't violate this requirement. We have an empty pack, so we don't run afoul of the fact that you can't use <code>void</code> as a non-type template parameter. Additionally, a hypothetical specialization of <code>enable_if</code> could provide a type that isn't <code>void</code> there so it's not ill-formed due to the above limitation. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-08-09T14:19:05.513", "Id": "38834461", "Score": "1", "CreationDate": "2016-08-08T16:40:33.587", "LastActivityDate": "2016-08-09T14:19:05.513"}, "bq_ids": {"n4140": {"so_38834149_38834461_0": {"section_id": 175, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_38834149_38834461_0": {"section_id": 169, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_38834149_38834461_0": {"section_id": 180, "quality": 0.9285714285714286, "length": 13}}}});