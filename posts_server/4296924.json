post_cb({"4296924": {"CommentCount": "5", "AcceptedAnswerId": "4296938", "CreationDate": "2010-11-28T13:19:41.567", "LastActivityDate": "2010-11-28T20:16:46.497", "PostTypeId": "1", "ViewCount": "7571", "FavoriteCount": "1", "Title": "How to order functions in C++?", "Id": "4296924", "Score": "5", "Body": "<p>I'm not sure how to order my functions in C++. In C, I simply placed a function that uses another function below that function, as closely as possible - that's pretty common. Like this:</p>\n<pre><code>void bar()\n{\n}\n\nvoid foo()\n{\n    bar();\n}\n</code></pre>\n<p>However, in C++, there are several types of functions:</p>\n<ul>\n<li>Free functions</li>\n<li>Private member functions</li>\n<li>Public member functions</li>\n<li>Static member functions</li>\n</ul>\n<p>I'm currently making my function order dependent on how they are ordered in the .hpp file, e.g.:</p>\n<pre><code>class Foo_bar {\npublic:\n    Foo_bar();\n    void foo();\nprivate:\n    int some_member;\n    void bar();\n</code></pre>\n<p>But now, if the constructor uses foo() or bar(), these will be <em>below</em> the constructor in the source file, inconsistent with my usual ordering. I could of course reorder my header to take account of that:</p>\n<pre><code>class Foo_bar {\nprivate:\n    int some_member;\n    void bar();\n\npublic:\n    void foo();\n    Foo_bar();\n</code></pre>\n<p>But I think that's a mess.</p>\n<p>Furthermore, in Java, the opposite to my first example seems to be common:</p>\n<pre><code>void foo()\n{\n    bar();\n}\n\nvoid bar()\n{\n}\n</code></pre>\n<p>That's probably due to the top-down thinking common in OOP, in contrast to the bottom-up thinking common in procedural/functional programming. However, with free functions that don't have prototypes, this top-down style is not possible.</p>\n<p>Is it even possible to order functions in C++ in a consistent way?</p>\n", "Tags": "<c++><function><order>", "OwnerUserId": "499795", "AnswerCount": "6"}, "4298828": {"ParentId": "4296924", "CommentCount": "2", "Body": "<p>It's a pretty good question actually, because readability has a major impact on whoever will read the code after you.</p>\n<p>There are 3 kinds of people who will read the code of a class:</p>\n<ul>\n<li>those who wish to uses it (and don't care much about its internals)</li>\n<li>those who wish to inherit from your class (and don't care much about its internals)</li>\n<li>those who wish to hack on your class, and thus really care of its internals</li>\n</ul>\n<p>For this reason, I try to order the headers so that any user may stop once he got what he was looking for, which means:</p>\n<pre><code>class Foo\n{\npublic:\n  // types\n  // static methods\n  // methods (usually constructors,\n  //          then simple accessors,\n  //          then more complicated stuff)\n\nprotected:\n  // same pattern\n\nprivate:\n  // same pattern\n  // attributes\n};\n\n// Free functions about this class\n\n// Implementation of inline / template methods\n</code></pre>\n<p>Sometimes I need to declare some types beforehand even though they are private, but this is rare. The goal of this ordering is to absolutely minimize the amount of stuff a reader has to read before he gets what he wants (and stops reading and goes back to what he was doing before having to interrupt himself to look at your code).</p>\n<p>Then, regarding \"helper\" methods, it depends on the type of code:</p>\n<ul>\n<li>for template code, I use a \"details\" namespace, it's both clear to the reader that he should not be worried about it and it isolate the names in their own namespace so that they do not pop up in code completion tools</li>\n<li>for regular code, I use an anonymous namespace within the source file, which is even better since then it actually generates invisible symbols and I don't run the risk of violating <strong>ODR</strong>.</li>\n</ul>\n<p>If some code may require a lot of helpers, I tend to create a dedicated header file in the source directory, giving the following structure:</p>\n<pre><code>include/\n  foo.hpp\n\nsrc/\n  fooImpl.hpp --&gt; #include \"foo.hpp\"\n  foo.cpp     --&gt; #include \"fooImpl.hpp\"\n</code></pre>\n<p>in order to provide a list of declarations to the reader, because it's easier to browse a list of declarations than to extract the declarations from a list of definitions, whatever the indentation and style.</p>\n<p>And of course, always to make it easier, I always order the list of declarations and the list of definitions equally...</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "4298828", "Score": "2", "CreationDate": "2010-11-28T20:16:46.497", "LastActivityDate": "2010-11-28T20:16:46.497"}, "4297052": {"ParentId": "4296924", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your concern about reordering the functions in the class definition is not correct as clarified by the following two quotes from the C++03 Standard.</p>\n<blockquote>\n<p id=\"so_4296924_4297052_0\">$9.2/2- \"A class is considered a\n  completely-defined object type (3.9)\n  (or complete type) at the closing } of\n  the class-specifier. <strong>Within the class\n  member-specification, the class is\n  regarded as complete within function\n  bodies, default arguments and\n  constructor ctor-initializers\n  (including such things in nested\n  classes).</strong> Otherwise it is regarded as\n  incomplete within its own class\n  member-specification.\"</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_4296924_4297052_1\">$3.4.1/8 - \"A name used in the\n  definition of a member function (9.3)\n  of class X following the function\u2019s\n  declaratorid29) shall be declared in\n  one of the following ways:</p>\n<p id=\"so_4296924_4297052_2\">\u2014 before its use in the block in which\n  it is used or in an enclosing block\n  (6.3), or</p>\n<p id=\"so_4296924_4297052_3\"><strong>\u2014 shall be a member of class X or be a\n  member of a base class of X (10.2), or</strong></p>\n<p id=\"so_4296924_4297052_4\">\u2014 if X is a nested class of class Y\n  (9.7), shall be a member of Y, or\n  shall be a member of a base class of Y\n  (this lookup applies in turn to Y\u2019s\n  enclosing classes, starting with the\n  innermost enclosing class),30) or</p>\n<p id=\"so_4296924_4297052_5\">\u2014 if X is a local class (9.8) or is a\n  nested class of a local class, before\n  the definition of class X in a block\n  enclosing the definition of class X,\n  or</p>\n<p id=\"so_4296924_4297052_6\">\u2014 if X is a member of namespace N, or\n  is a nested class of a class that is a\n  member of N, or is a local class or a\n  nested class within a local class of a\n  function that is a member of N, before\n  the member function definition, in\n  namespace N or in one of N\u2019s enclosing\n  namespaces.</p>\n</blockquote>\n<p>As a general rule, in C++, function definitions have to be visible at the point of their use. The only exception is the case of class member functions as illustrated by the above quotes. </p>\n<p>Therefore, this means that the class member functions to be called by the constructor need not be defined before the constructor lexically.</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2010-11-28T13:55:56.810", "Id": "4297052", "Score": "1", "CreationDate": "2010-11-28T13:50:33.297", "LastActivityDate": "2010-11-28T13:55:56.810"}, "4296938": {"ParentId": "4296924", "CommentCount": "3", "Body": "<p>It's possible. You have to use <a href=\"http://www-subatech.in2p3.fr/~photons/subatech/soft/carnac/CPP-INC-1.shtml\" rel=\"noreferrer\">forward declaration</a>.</p>\n<p>Declare a function before defining it, and other functions will see it without problem even if they are defined before.</p>\n<p>So, you should be able to do this in C++:</p>\n<pre><code>void bar();  // forward declaration; note that function bar isn't defined yet\n\nvoid foo()\n{\n    bar();   // foo knows that bar is declared, so it will search for bar's definition\n}\n\nvoid bar()   // here bar is defined, so foo will use this when needed\n{\n}\n</code></pre>\n", "OwnerUserId": "489261", "PostTypeId": "2", "Id": "4296938", "Score": "6", "CreationDate": "2010-11-28T13:23:08.893", "LastActivityDate": "2010-11-28T13:23:08.893"}, "4297035": {"ParentId": "4296924", "CommentCount": "1", "Body": "<p>Personally, I like to see things that will be referred to from elsewhere (which people will need to find/read often) near the top of the file. Internals that, once stable, can hopefully be forgotten are left for later.</p>\n<p>There's inconsistencies, though. For example, in a class, it implies putting public stuff first, private internals later. But the default visibility for a class (what you naturally get) is private, and (particularly if I have inline-style methods) I generally put any private data in front. It may even be an error for an inline-style method to reference a member variable before it has been defined - sorry, I'm suffering a temporary memory issue.</p>\n<p>But basically, the main thing is to put things together than are similar or logically related. A begin method will be adjacent to an end method, a Step_To_Next method adjacent to a Step_To_Prev method, etc. Grouping be similar purposes, similar parameters, and commonly being used together are all good.</p>\n<p>What calls what is mostly an implementation detail, so not something you should necessarily emphasise in header files that the user of your library will read - though in implementation code things may be different. As others have pointed out, forward declarations allow some freedom with this.</p>\n<p>Most important (1) adopt a consistent style, and (2) don't worry too much about ambiguous cases.</p>\n", "OwnerUserId": "180247", "PostTypeId": "2", "Id": "4297035", "Score": "0", "CreationDate": "2010-11-28T13:47:43.093", "LastActivityDate": "2010-11-28T13:47:43.093"}, "4296952": {"ParentId": "4296924", "CommentCount": "1", "Body": "<p>You declare the class in a header file, right?  And implement most of it in a separate file?  If you simply implement the constructor in the implementation file and not in the header, I don't think you'll experience the problem you mentioned (because the entire header will be seen before the constructor is seen to call <code>foo()</code> or <code>bar()</code>.</p>\n", "OwnerUserId": "4323", "PostTypeId": "2", "Id": "4296952", "Score": "1", "CreationDate": "2010-11-28T13:26:05.423", "LastActivityDate": "2010-11-28T13:26:05.423"}, "4296965": {"ParentId": "4296924", "CommentCount": "3", "Body": "<p>Ordering free functions in C++ obeys the same rules as you mentioned, but like darioo said, you can forward declare them and order the function definitions any way you want. That is also the preferred way: declare everything in  header, and put ALL definitions in the source file. This is not possible for templates though, without some non-trivial and non-general anti-template workarounds.</p>\n<p>In a class, things are usually different, because there is almost no cases where you fully implement your class in a header, thus the declarations are always read when you're defining the functions in the source file.</p>\n<p>I usually order functions in \"function\", and group eg. getters and setters, constructor/destructor (if possible).</p>\n", "OwnerUserId": "256138", "PostTypeId": "2", "Id": "4296965", "Score": "1", "CreationDate": "2010-11-28T13:28:24.333", "LastActivityDate": "2010-11-28T13:28:24.333"}, "bq_ids": {"n4140": {"so_4296924_4297052_0": {"section_id": 5862, "quality": 0.9142857142857143, "length": 32}, "so_4296924_4297052_2": {"section_id": 7094, "quality": 1.0, "length": 6}, "so_4296924_4297052_1": {"section_id": 7093, "quality": 0.7692307692307693, "length": 10}, "so_4296924_4297052_3": {"section_id": 187, "quality": 0.8333333333333334, "length": 5}, "so_4296924_4297052_5": {"section_id": 7093, "quality": 1.0, "length": 13}, "so_4296924_4297052_4": {"section_id": 7093, "quality": 0.9375, "length": 15}, "so_4296924_4297052_6": {"section_id": 7093, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_4296924_4297052_0": {"section_id": 5632, "quality": 0.9142857142857143, "length": 32}, "so_4296924_4297052_2": {"section_id": 6838, "quality": 1.0, "length": 6}, "so_4296924_4297052_1": {"section_id": 6838, "quality": 0.8461538461538461, "length": 11}, "so_4296924_4297052_3": {"section_id": 181, "quality": 0.8333333333333334, "length": 5}, "so_4296924_4297052_5": {"section_id": 6837, "quality": 1.0, "length": 13}, "so_4296924_4297052_4": {"section_id": 6837, "quality": 0.9375, "length": 15}, "so_4296924_4297052_6": {"section_id": 6837, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_4296924_4297052_0": {"section_id": 7345, "quality": 0.9142857142857143, "length": 32}, "so_4296924_4297052_2": {"section_id": 8595, "quality": 1.0, "length": 6}, "so_4296924_4297052_1": {"section_id": 8594, "quality": 0.7692307692307693, "length": 10}, "so_4296924_4297052_3": {"section_id": 192, "quality": 0.8333333333333334, "length": 5}, "so_4296924_4297052_5": {"section_id": 8594, "quality": 1.0, "length": 13}, "so_4296924_4297052_6": {"section_id": 8594, "quality": 0.9130434782608695, "length": 21}, "so_4296924_4297052_4": {"section_id": 8594, "quality": 0.9375, "length": 15}}}});