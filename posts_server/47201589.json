post_cb({"47201947": {"Id": "47201947", "PostTypeId": "2", "Body": "<p>According to the C++ 2017 Standard (10.1.2 Function specifiers)</p>\n<blockquote>\n<p id=\"so_47201589_47201947_0\">2 The virtual specifier shall be used only in the initial declaration\n  of a non-static class member function; see 13.3.</p>\n</blockquote>\n<p>And (13.3 Virtual functions)</p>\n<blockquote>\n<p id=\"so_47201589_47201947_1\">2 <strong>If a virtual member function vf is declared in a class Base and in\n  a class Derived, derived directly or indirectly from Base, a member\n  function vf with the same name, parameter-type-list (11.3.5),\n  cv-qualification, and ref-qualifier (or absence of same) as Base::vf\n  is declared, then Derived::vf is also virtual (whether or not it is so\n  declared) and it overrides111 Base::vf.</strong> For convenience we say that\n  any virtual function overrides itself. A virtual member function C::vf\n  of a class object S is a final overrider unless the most derived class\n  (4.5) of which S is a base class subobject (if any) declares or\n  inherits another member function that overrides vf. In a derived\n  class, if a virtual member function of a base class subobject has more\n  than one final overrider the program is ill-formed.</p>\n</blockquote>\n<p>Thus the function <code>show</code> in the class <code>B</code> is a virtual function because it has the same signature as the function declared in the class <code>A</code>. </p>\n<p>Consider a more interesting example when in the class <code>B</code> there is added the qualifier <code>const</code> to the member function <code>show</code>.</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    virtual void show(){\n        cout &lt;&lt; \"A \\n\";\n    }\n};\n\nclass B : public A {\npublic:\n    void show() const{\n        cout &lt;&lt; \"B \\n\";\n    }\n};\n\nclass C : public B {\npublic: \n    void show() {\n        cout &lt;&lt; \"C \\n\"; \n    }\n};\n\nint main(){\n\n    A *ab = new B;\n    A *ac = new C;\n    B *bc = new C;\n    ab-&gt;show();\n    ac-&gt;show();\n    bc-&gt;show();\n\n}\n</code></pre>\n<p>In this case the output will look like</p>\n<pre><code>A \nC \nB \n</code></pre>\n<p>In this expression statement</p>\n<pre><code>    ab-&gt;show();\n</code></pre>\n<p>there is called the virtual function <code>show</code> declared in the class <code>A</code>.</p>\n<p>In this statement</p>\n<pre><code>    ac-&gt;show();\n</code></pre>\n<p>there is called the same virtual function that is overridden in the class <code>C</code>. The compier uses the virtual function declaration in the class A because the static type of the pointer <code>ac</code> is <code>A *</code>.</p>\n<p>In this statement</p>\n<pre><code>    bc-&gt;show();\n</code></pre>\n<p>there is called non-virtual member function <code>show</code> with the qualifier <code>const</code> because the static type of the pointer <code>bc</code> is <code>B *</code> and the compiler finds the function in the class <code>B</code> that hides the virtual function declared in the class <code>A</code>..</p>\n<p>For the original program you could use the specifier <code>override</code>  to make the class definitions more clear. For example</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    virtual void show(){\n        cout &lt;&lt; \"A \\n\";\n    }\n};\n\nclass B : public A {\npublic:\n    void show() override{\n        cout &lt;&lt; \"B \\n\";\n    }\n};\n\nclass C : public B {\npublic: \n    void show() override{\n        cout &lt;&lt; \"C \\n\"; \n    }\n};\n\nint main(){\n\n    A *ab = new B;\n    A *ac = new C;\n    B *bc = new C;\n    ab-&gt;show();\n    ac-&gt;show();\n    bc-&gt;show();\n\n}\n</code></pre>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2017-11-09T13:13:13.567", "Score": "7", "CreationDate": "2017-11-09T12:32:15.197", "ParentId": "47201589", "CommentCount": "0", "OwnerUserId": "2877241", "LastEditDate": "2017-11-09T13:13:13.567"}, "47201604": {"Id": "47201604", "PostTypeId": "2", "Body": "<p>You don't need to specify a function as <code>virtual</code> in derived class, if specified in the <code>base</code> class.</p>\n", "LastActivityDate": "2017-11-09T12:15:18.307", "CommentCount": "4", "CreationDate": "2017-11-09T12:15:18.307", "ParentId": "47201589", "Score": "7", "OwnerUserId": "3475381"}, "47201589": {"ViewCount": "279", "Body": "<p>I was studying on effects of <code>virtual</code> keyword in C++ and I came up with this code.</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    virtual void show(){\n        cout &lt;&lt; \"A \\n\";\n    }\n};\n\nclass B : public A {\npublic:\n    void show(){\n        cout &lt;&lt; \"B \\n\";\n    }\n};\n\nclass C : public B {\npublic: \n    void show(){\n        cout &lt;&lt; \"C \\n\"; \n    }\n};\n\nint main(){\n\n    A *ab = new B;\n    A *ac = new C;\n    B *bc = new C;\n    ab-&gt;show();\n    ac-&gt;show();\n    bc-&gt;show();\n\n}\n</code></pre>\n<p>The expected output is: </p>\n<pre><code>B\nC\nB\n</code></pre>\n<p>Since <code>show</code> function in B is non-virtual. But the outcome when you compile this is:</p>\n<pre><code>B\nC\nC\n</code></pre>\n<p>It behaves as if <code>show</code> function in B is virtual. Why is this the case? Does B class gets overridden here? How come I point to the A class if I'm pointing a C class to the B class?</p>\n", "AcceptedAnswerId": "47201947", "Title": "Confusion with virtual keyword in C++", "CreationDate": "2017-11-09T12:14:07.547", "Id": "47201589", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-11-10T10:53:29.983", "LastEditorUserId": "2877241", "LastActivityDate": "2017-11-10T10:53:29.983", "Score": "5", "OwnerUserId": "4709059", "Tags": "<c++><function><c++11><inheritance><virtual>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_47201589_47201947_1": {"length": 69, "quality": 0.9452054794520548, "section_id": 7003}, "so_47201589_47201947_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5405}}, "n3337": {"so_47201589_47201947_1": {"length": 69, "quality": 0.9452054794520548, "section_id": 6749}, "so_47201589_47201947_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5200}}, "n4659": {"so_47201589_47201947_1": {"length": 69, "quality": 0.9452054794520548, "section_id": 8500}, "so_47201589_47201947_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6827}}}, "47201714": {"Id": "47201714", "PostTypeId": "2", "Body": "<p>The behaviour is the correct one. Since the <code>show</code> function is virtual, the version invoked will be the one attached to the instance you're calling it on, rather than the one described by the type of that instance (which can be a base of that instance's real type).</p>\n", "LastActivityDate": "2017-11-09T12:20:30.807", "CommentCount": "0", "CreationDate": "2017-11-09T12:20:30.807", "ParentId": "47201589", "Score": "0", "OwnerUserId": "5910563"}});