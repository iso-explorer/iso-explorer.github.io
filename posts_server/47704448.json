post_cb({"bq_ids": {"n4140": {"so_47704448_47704448_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 157}}, "n4659": {"so_47704448_47704448_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 161}}}, "47704448": {"ViewCount": "130", "FavoriteCount": "1", "Title": "Are those two identically looking C++ function templates functionally equivalent?", "CreationDate": "2017-12-07T21:53:07.973", "LastActivityDate": "2017-12-07T21:58:49.370", "CommentCount": "6", "Body": "<p>Let's say we have a program that defines several function templates:</p>\n<pre><code>template&lt;typename T&gt;\nvoid g(T) {}\n\nstruct A {};\n\n//this template only sees the definition of g above\n//the usage of g does not depend on the parameter of the template\ntemplate&lt;typename T = void&gt;\ndecltype(T(), (g)(A{})) f(A a)\n{\n   return (g)(a);\n}\n\nA g (A a)\n{\n  return a;\n}\n//this template sees both overloads of g\n//and still the usage of g does not depend on the parameter of the template\ntemplate&lt;typename T = void&gt;\ndecltype(T(), (g)(A{})) f(A a)\n{\n  return (g)(a);\n}\n</code></pre>\n<p>This program contains two copies of the code that defines function template <em>f</em>. In general, creating equivalent overloads is forbidden by C++ standard.<br>\nThe question is whether those two templates are equivalent according to the standard? </br></p>\n<p>Had those two templates used <em>g</em> as dependent name they would be considered eqivalent, as the standard explicitly says so:</p>\n<blockquote>\n<p id=\"so_47704448_47704448_0\">For determining whether two dependent names ([temp.dep]) are equivalent, only the name itself is considered, not the result of name lookup in the context of the template. If multiple declarations of the same function template differ in the result of this name lookup, the result for the first declaration is used.</p>\n</blockquote>\n<p>But here the usage of <em>g</em> does not depend on T (while being a part of an expression that depends on T).</p>\n<p>Compilers disagree on whether those two definitions should be allowed: clang accepts it, GCC and Visual C++ does not (See <a href=\"https://godbolt.org/g/LUW1iM\" rel=\"nofollow noreferrer\">https://godbolt.org/g/LUW1iM</a>).</p>\n", "PostTypeId": "1", "Id": "47704448", "Score": "2", "OwnerUserId": "4316978", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "0"}});