post_cb({"29300863": {"ParentId": "29300408", "CommentCount": "6", "Body": "<p>To answer the second question first: the standard explicitly says that the standard library is allowed to assume that when passing something by rvalue reference, that rvalue reference is the <em>only</em> reference to that object. This means that it cannot legally be an element of the vector. The relevant part of C++11 17.6.4.9/1:</p>\n<blockquote id=\"so_29300408_29300863_0\">\n<ul>\n<li>If a function argument binds to an rvalue reference parameter, the implementation may assume that\n  this parameter is a unique reference to this argument. ... [ <em>Note:</em> If a program casts an lvalue to an\n  xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument\n  <code>move(x)</code>), the program is effectively asking that function to treat that lvalue as a temporary. The\n  implementation is free to optimize away aliasing checks which might be needed if the argument was\n  an lvalue. <em>\u2014end note</em> ]</li>\n</ul>\n</blockquote>\n<p>This leaves us just to handle the <code>const T &amp;</code> case. And even though libstdc++ and libc++ differ in this case, their net result is the same\u2014they will correctly copy from the object passed in. And the standard only prescribes behaviour, not implementation. As long as they achieve the correct behaviour, they're fine.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "29300863", "Score": "8", "CreationDate": "2015-03-27T12:37:52.137", "LastActivityDate": "2015-03-27T12:37:52.137"}, "29300408": {"CommentCount": "8", "CreationDate": "2015-03-27T12:13:37.260", "PostTypeId": "1", "AcceptedAnswerId": "29300863", "LastEditorUserId": "865331", "LastActivityDate": "2015-03-28T00:58:42.973", "LastEditDate": "2015-03-27T12:26:51.060", "ViewCount": "466", "FavoriteCount": "1", "Title": "Is inserting an element of a std::vector into the same vector allowed?", "Id": "29300408", "Score": "17", "Body": "<p>Consider the following <code>insert</code> and <code>emplace</code> member functions of <code>std::vector&lt;T&gt;</code>:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);\niterator insert(const_iterator position, const T&amp; x);\niterator insert(const_iterator position, T&amp;&amp; x);\niterator insert(const_iterator position, size_type n, const T&amp; x);\n</code></pre>\n<p>What if one of them is invoked with a reference to an element of the vector itself as an argument? Normally, each of them invalidates references to all elements starting from <code>position</code>, which might include the argument, or if a reallocation happens, references to <em>all</em> elements, which definitely include it, but does this mean such an invocation is invalid or does the insertion (seem to) happen first?</p>\n<p>Looking at some common implementations gives curious results:</p>\n<ul>\n<li><p>libstdc++ copies the argument before moving any elements, but only in the <code>const T&amp;</code> overloads of <code>insert</code>. It contains this comment:</p>\n<blockquote>\n<p id=\"so_29300408_29300408_0\">The order of the three operations is dictated by the C++0x\n  case, where the moves could alter a new element belonging\n  to the existing vector.  This is an issue only for callers\n  taking the element by const lvalue ref (see 23.1/13).</p>\n</blockquote>\n<p>But C++11 \u00a723.1 is just a brief summary of the containers library, and even if we assume this refers to \u00a723.2.1 (which used to be \u00a723.1 in C++03), \u00a723.2.1/13 only gives a definition of allocator-aware containers, which seems to have nothing to do with this. I\u2019ve looked through chapter\u00a023, but I haven\u2019t found anything relevant anywhere.</p></li>\n<li><p>libc++ creates a temporary before moving any elements in <code>emplace</code>, while in <code>insert</code> it moves elements first but converts the argument reference to a pointer and adjusts it to ensure it points to the original element\u2014but again, it does all this only in the <code>const T&amp;</code> overload.</p></li>\n<li><p>Visual C++ creates a copy/temporary before moving any elements in all cases.</p></li>\n</ul>\n<p>Did I miss the place where the standard defines this behaviour? Why do the three C++ libraries I looked at disagree with each other? Why does the libstdc++ comment say it\u2019s only an issue for <code>insert(const_iterator, const T&amp;)</code>? If the standard doesn\u2019t require this to work, why do the libraries ever bother to make it work at all? (Surely this costs some copies and/or moves that could otherwise be avoided.) Finally, if I\u2019m implementing a container that should resemble <code>std::vector</code>, should I make this work?</p>\n", "Tags": "<c++><c++11><vector><stl><stdvector>", "OwnerUserId": "865331", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29300408_29300863_0": {"section_id": 6325, "quality": 0.9130434782608695, "length": 42}}, "n3337": {"so_29300408_29300863_0": {"section_id": 6082, "quality": 0.9130434782608695, "length": 42}}, "n4659": {"so_29300408_29300863_0": {"section_id": 7835, "quality": 0.8913043478260869, "length": 41}}}});