post_cb({"25887448": {"CommentCount": "2", "AcceptedAnswerId": "25887614", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-17T09:55:45.793", "LastActivityDate": "2014-09-17T10:07:56.577", "LastEditDate": "2017-05-23T11:58:59.360", "ViewCount": "841", "FavoriteCount": "1", "Title": "Why calling a non-member function with the same name as a member function generates an error", "Id": "25887448", "Score": "11", "Body": "<p>I have next code:</p>\n<pre><code>void f(int){}\n\nstruct A\n{\n    void f()\n    {\n        f(1);\n    }\n};\n</code></pre>\n<p>This code is not well-formed with the error message (GCC): <code>error: no matching function for call to \u2018A::f(int)\u2019</code> or (clang) <code>Too many arguments to function call, expected 0, have 1; did you mean '::f'?</code></p>\n<p><strong>Why do I need to use <code>::</code> to call the non-member function with the same name as the member function, but with different signature? What is the motivation for this requirement?</strong> </p>\n<p>I think the compiler should be able to figure it out I want to call the non-member function as the signature is different (clang even puts that in the error message!).</p>\n<p>Please don't mark this as duplicate - it is a different question from this <a href=\"https://stackoverflow.com/questions/2207628/calling-in-c-a-non-member-function-inside-a-class-with-a-method-with-the-same\">Calling in C++ a non member function inside a class with a method with the same</a></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "336578", "AnswerCount": "4"}, "25887614": {"ParentId": "25887448", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-09-17T10:02:49.747", "Score": "18", "LastEditorUserId": "204847", "LastEditDate": "2014-09-17T10:07:56.577", "Id": "25887614", "OwnerUserId": "204847", "Body": "<blockquote>\n<p id=\"so_25887448_25887614_0\">Why do I need to use :: to call the non-member function with the same name as the member function, but with different signature</p>\n</blockquote>\n<p>Because those are the rules. Names in a nested scope hide entities with the same name in a wider scope.</p>\n<blockquote>\n<p id=\"so_25887448_25887614_1\">What is the motivation for this requirement?</p>\n</blockquote>\n<p>Consider the case where a member function calls another member with a signature that doesn't quite match:</p>\n<pre><code>struct A {\n    void f(double);\n    void g() {f(42);}  // requires int-&gt;double conversion\n};\n</code></pre>\n<p>Now suppose someone adds an unrelated function in the surrounding namespace</p>\n<pre><code>void f(int);\n</code></pre>\n<p>If this were included in the set of overloads within the scope of <code>A</code>, then suddenly the behaviour of <code>A::g</code> would change: it would call this instead of <code>A::f</code>. Restricting the overload set to names in the narrowest available scope prevents this kind of unexpected breakage.</p>\n<p>As you (and your helpful compiler) say, the outer name is still available (with qualification) if you need it.</p>\n", "LastActivityDate": "2014-09-17T10:07:56.577"}, "25887604": {"ParentId": "25887448", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-17T10:02:26.320", "Score": "1", "LastEditorUserId": "183120", "LastEditDate": "2014-09-17T10:07:26.610", "Id": "25887604", "OwnerUserId": "183120", "Body": "<blockquote>\n<p id=\"so_25887448_25887604_0\">Why do I need to use :: to call the non-member function with the same name as the member function, but with different signature? What is the motivation for this requirement?</p>\n</blockquote>\n<p>That is the whole point of having namespaces. A local (closer-scoped) name is preferred and more visible over a global name. Since a <code>struct</code> is again a scope, its <code>f</code> is shadowing the visibility of <code>::f</code>. When you've to have the global one, you've to say you do. Why?</p>\n<p>This is provided as a feature to make sure you can peacefully call functions you defined assuming they would get called, and when you need one from a different namespace, say the standard library, you'd state that explicitly, like <code>std::</code>. It's just a clean form of disambiguation, without leaving room for chance to play its part.</p>\n", "LastActivityDate": "2014-09-17T10:07:26.610"}, "25887601": {"ParentId": "25887448", "CommentCount": "0", "CreationDate": "2014-09-17T10:02:19.903", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25887601", "Score": "7", "Body": "<p>The compiler performs unqualified name lookup, for <code>f</code>, specified in \u00a73.4.1 [basic.lookup.unqual] (thankfully, there's no ADL here):</p>\n<blockquote>\n<p id=\"so_25887448_25887601_0\">1 In all the cases listed in 3.4.1, the scopes are searched for a\n  declaration in the order listed in each of the respective categories;\n  name lookup ends as soon as a declaration is found for the name. If no\n  declaration is found, the program is ill-formed.</p>\n<p id=\"so_25887448_25887601_1\">8 For the members of a class <code>X</code>, a name used in a member function\n  body, in a default argument, in an <em>exception-specification</em>, in the\n  <em>brace-or-equal-initializer</em> of a non-static data member (9.2), or in the definition of a class member outside of the definition of X,\n  following the member\u2019s <em>declarator-id</em>, shall be declared in one of\n  the following ways:</p>\n<ul>\n<li>before its use in the block in which it is used or in an enclosing block (6.3), or</li>\n<li>shall be a member of class <code>X</code> or be a member of a base class of <code>X</code> (10.2), or</li>\n<li>if <code>X</code> is a nested class of class <code>Y</code> (9.7), shall be a member of <code>Y</code>, or shall be a member of a base class of <code>Y</code> (this lookup applies\n  in turn to <code>Y</code>\u2019s enclosing classes, starting with the innermost\n  enclosing class), or</li>\n<li>if <code>X</code> is a local class (9.8) or is a nested class of a local class, before the definition of class <code>X</code> in a block enclosing the definition\n  of class <code>X</code>, or</li>\n<li>if <code>X</code> is a member of namespace <code>N</code>, or is a nested class of a class that is a member of <code>N</code>, or is a local class or a nested class within\n  a local class of a function that is a member of <code>N</code>, before the use of\n  the name, in namespace <code>N</code> or in one of <code>N</code>\u2019s enclosing namespaces.</li>\n</ul>\n</blockquote>\n<p>Name lookup stops as soon as a declaration is found. So once it finds the member <code>f()</code> at the second bullet point it stops and never searches elsewhere.</p>\n<p>Rejection of nonviable functions are done after name lookup, at overload resolution.</p>\n", "LastActivityDate": "2014-09-17T10:02:19.903"}, "bq_ids": {"n4140": {"so_25887448_25887601_1": {"section_id": 7094, "quality": 0.9615384615384616, "length": 25}, "so_25887448_25887601_0": {"section_id": 7087, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_25887448_25887601_1": {"section_id": 6838, "quality": 0.5384615384615384, "length": 14}, "so_25887448_25887601_0": {"section_id": 6831, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_25887448_25887601_1": {"section_id": 8595, "quality": 0.9230769230769231, "length": 24}, "so_25887448_25887601_0": {"section_id": 8588, "quality": 0.9545454545454546, "length": 21}}}, "25887681": {"ParentId": "25887448", "CommentCount": "0", "CreationDate": "2014-09-17T10:06:14.480", "OwnerUserId": "1629821", "PostTypeId": "2", "Id": "25887681", "Score": "0", "Body": "<p>To understand the reason of your error and why you need to explicitly use the <code>::f()</code> syntax, you may want to consider some aspects of the C++ compiler process:</p>\n<p>The first thing the compiler does is <strong>name lookup</strong>.</p>\n<p>Unqualified name lookup starts from the current scope, and then moves outwards; it stops as soon as it finds a declaration for the name of the function, even if this function will be later determined to not be a viable candidate for the function call.</p>\n<p>Then, <strong>overload resolution</strong> is executed over the set of the functions that name lookup found.</p>\n<p>(And, finally, <strong>access check</strong> is executed on the function that overload resolution picked up.)</p>\n", "LastActivityDate": "2014-09-17T10:06:14.480"}});