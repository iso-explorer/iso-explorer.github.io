post_cb({"bq_ids": {"n4140": {"so_36510053_36510397_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 7041}}, "n3337": {"so_36510053_36510397_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 6786}}, "n4659": {"so_36510053_36510397_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 8538}}}, "36510383": {"Id": "36510383", "PostTypeId": "2", "Body": "<p>Normally, calling a function odr-uses it, with two exceptions: if it is pure virtual, or if it is not potentially evaluated ([basic.def.odr]/5). An expression is potentially evaluated unless it is an unevaluated operand or a subexpression thereof ([basic.def.odr]/2). Unevaluated operands occur in <code>typeid</code>, <code>sizeof</code>, <code>noexcept</code>, and <code>decltype</code>, none of which applies here. Therefore <code>undefinedFunction</code> is odr-used as long as <code>foo</code> is instantiated, which it is. There is no exception for \"statically unreachable\" code.</p>\n", "LastActivityDate": "2016-04-08T22:33:55.063", "CommentCount": "6", "CreationDate": "2016-04-08T22:33:55.063", "ParentId": "36510053", "Score": "7", "OwnerUserId": "481267"}, "36510053": {"ViewCount": "155", "Body": "<p>Consider the following code, which has an unreachable call to <code>undefinedFunction</code>.</p>\n<pre><code>void undefinedFunction();\n\ntemplate &lt;bool b = false&gt;\nvoid foo()\n{\n  static_assert(b == false);\n  if (b)\n    undefinedFunction();\n}\n\nint main()\n{\n  foo();\n}\n</code></pre>\n<p>GCC compiles and links this without complaint.  With the <code>static_assert</code>, it's hard to see how the compiler could do anything different, but does the standard have anything to say about this?  What if the <code>static_assert</code> is removed?  Is the compiler at all obligated to remove the branch or can it actually emit an unreachable call instruction that will cause the linker to complain?</p>\n", "AcceptedAnswerId": "36510397", "Title": "Can statically unreachable calls cause undefined reference errors?", "CreationDate": "2016-04-08T22:03:02.073", "Id": "36510053", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2016-04-08T22:35:10.580", "Score": "4", "OwnerUserId": "4889185", "Tags": "<c++><c++11><c++14><template-meta-programming>", "AnswerCount": "3"}, "36510359": {"Id": "36510359", "PostTypeId": "2", "Body": "<p>As others commented, two separate steps contribute to this. The unreachable code may be erased by the optimizer, so the link for <code>undefinedFunction()</code> is never requested.\nThe compilation step does not care for <code>symbols that are not defined</code> (more information about compilation in <a href=\"https://stackoverflow.com/a/6264256/1941945\">this community answer</a>).</p>\n<p>This is independent of the <code>static_assert</code>. You can have undefined references in template code that never gets initialized, and the compilation succeeds, as the compiler never considers the code, it never emit requirement for the link.</p>\n<p>If the symbol gets through, and is requested in some later step, linkage will fail. This is the same that happens when you compile a library with template classes, and later tries to use a template with argument types for which the class was not explicitly initialized, you will get undefined references to types using a library that compiled fine on it's own.</p>\n<p>If you wish to exam if you compiler is actually eliminating dead code, <a href=\"https://stackoverflow.com/a/10809541/1941945\">this answer</a> details about profiling dead code in GCC.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-08T22:31:43.133", "Score": "1", "CreationDate": "2016-04-08T22:31:43.133", "ParentId": "36510053", "CommentCount": "0", "OwnerUserId": "1941945", "LastEditDate": "2017-05-23T12:15:53.817"}, "36510397": {"Id": "36510397", "PostTypeId": "2", "Body": "<p>According to the C++ standard <em>\u00a73.2/p4 One-definition rule [basic.def.odr] (emphasis mine)</em>:</p>\n<blockquote>\n<p id=\"so_36510053_36510397_0\"><strong>Every program shall contain exactly one definition of every non-inline\n  function or variable that is odr-used in that program; no diagnostic\n  required.</strong> The definition can appear explicitly in the program, it can\n  be found in the standard or a user-defined library, or (when\n  appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). An\n  inline function shall be defined in every translation unit in which it\n  is odr-used.</p>\n</blockquote>\n<p>The template function <code>foo</code> is instantiated <code>undefinedFunction</code> is odr-used (i.e., a definition of <code>undefinedFunction</code> is required). It doesn't matter if <code>if</code> clause is not evaluated. Consequently, the program is ill formed and since no diagnostic is required it may link or it may not.</p>\n", "LastActivityDate": "2016-04-08T22:35:10.580", "CommentCount": "0", "CreationDate": "2016-04-08T22:35:10.580", "ParentId": "36510053", "Score": "4", "OwnerUserId": "2352671"}});