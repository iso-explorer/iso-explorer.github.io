post_cb({"27441561": {"Id": "27441561", "PostTypeId": "2", "Body": "<p>No.  It doesn't work that way.  It doesn't work at all.  Can't do it.  No way no how.</p>\n", "LastActivityDate": "2014-12-12T10:25:09.083", "CommentCount": "2", "CreationDate": "2014-12-12T10:25:09.083", "ParentId": "27441445", "Score": "0", "OwnerUserId": "301883"}, "bq_ids": {"n4140": {"so_27441445_27441622_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5520}, "so_27441445_27441622_0": {"length": 4, "quality": 1.0, "section_id": 5520}}, "n3337": {"so_27441445_27441622_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5306}, "so_27441445_27441622_0": {"length": 4, "quality": 1.0, "section_id": 5306}}, "n4659": {"so_27441445_27441622_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 6955}, "so_27441445_27441622_0": {"length": 4, "quality": 1.0, "section_id": 6955}}}, "27441445": {"ViewCount": "383", "Body": "<p>Consider this in a cpp file:</p>\n<pre><code>struct someStruct{\n    public:\n    extern \"C\"  __declspec(dllexport) int sumup();\n} someStruct;\n\nextern \"C\" __declspec(dllexport) int someStruct::sumup()\n{\n    return 0;\n}\n</code></pre>\n<p>This does not compile: <code>error: expected unqualified-id before string constant</code>\nIs it no possible to export a C++ member method with C linkage?</p>\n", "AcceptedAnswerId": "27441622", "Title": "Is it possible to export a C++ member method with C linkage in a DLL?", "CreationDate": "2014-12-12T10:18:44.930", "Id": "27441445", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-12-12T10:29:04.117", "Score": "-1", "OwnerUserId": "951614", "Tags": "<c++><c><dll><export><linkage>", "AnswerCount": "2"}, "27441622": {"Id": "27441622", "PostTypeId": "2", "Body": "<p>First off, linkage specifications don't apply to member functions; by [dcl.link]/4:</p>\n<blockquote>\n<p id=\"so_27441445_27441622_0\">[...] A linkage-specification shall occur only in namespace scope (3.3). [...]</p>\n</blockquote>\n<p>But there's even an example in the Standard that relates to your question somewhat, in the same paragraph:</p>\n<blockquote>\n<p id=\"so_27441445_27441622_1\">[...] A C language linkage is ignored in determining the language linkage of the names of class members and the function type of class member functions. [<em>Example:</em></p>\n<pre><code>extern \"C\" typedef void FUNC_c();\nclass C {\n  void mf1(FUNC_c*);      // the name of the function mf1 and the member\n                          // function\u2019s type have C ++ language linkage; the\n                          // parameter has type pointer to C function\n  FUNC_c mf2;             // the name of the function mf2 and the member\n                          // function\u2019s type have C ++ language linkage\n  static FUNC_c* q;       // the name of the data member q has C ++ language\n                          // linkage and the data member\u2019s type is pointer to\n                          // C function\n};\n\nextern \"C\" {\n  class X {\n    void mf();            // the name of the function mf and the member\n                          // function\u2019s type have C ++ language linkage\n    void mf2(void(*)());  // the name of the function mf2 has C ++ language\n                          // linkage; the parameter has type pointer to\n                          // C function\n  }\n};\n</code></pre>\n<p id=\"so_27441445_27441622_2\">\u2014 <em>end example</em>]</p>\n</blockquote>\n", "LastActivityDate": "2014-12-12T10:28:39.880", "CommentCount": "1", "CreationDate": "2014-12-12T10:28:39.880", "ParentId": "27441445", "Score": "2", "OwnerUserId": "596781"}});