post_cb({"bq_ids": {"n4140": {"so_7518412_7518775_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7049}}, "n3337": {"so_7518412_7518775_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6794}}, "n4659": {"so_7518412_7518775_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 8546}}}, "7518453": {"Id": "7518453", "PostTypeId": "2", "Body": "<pre><code> test t(t); -- this line gives an error in Visual C++ \n</code></pre>\n<p>Where have you defined t? The compiler is not physic!</p>\n", "LastActivityDate": "2011-09-22T16:46:25.237", "CommentCount": "2", "CreationDate": "2011-09-22T16:46:25.237", "ParentId": "7518412", "Score": "0", "OwnerUserId": "892256"}, "7518412": {"ViewCount": "107", "Body": "<p>I am not asking about the logic of such a call, rather I'm interested in a difference of support b/w Visual C++ and GCC / Clang. Visual C++ will not allow a new instance of an object to be used as the parameter for its own copy constructor. GCC and Clang allow this. Considering that 'int i = i;' is allowed, I'm wondering whether Visual C++ has a bug.</p>\n<pre><code>class test {\nprivate:\n    test() {}\npublic:\n    test(const test&amp; t) {}\n};\n\nint main(void) {\n    int i = i;\n    test t(t); -- this line gives an error in Visual C++\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "7518775", "Title": "Calling a copy constructor with instance being created", "CreationDate": "2011-09-22T16:43:34.157", "Id": "7518412", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-09-22T17:13:27.793", "Score": "3", "OwnerUserId": "832745", "Tags": "<c++><visual-c++>", "AnswerCount": "2"}, "7518775": {"Id": "7518775", "PostTypeId": "2", "Body": "<p>To quote the C++ standard (3.3.2):</p>\n<blockquote>\n<p id=\"so_7518412_7518775_0\">The <em>point of declaration</em> for a name is immediately after its complete declarator and before its <em>initializer</em></p>\n</blockquote>\n<p>In your first statement, the declarator ends after <code>int i</code>, and so the name <code>i</code> is available where it's used in the initializer (<code>= i</code>), so the statement is well-formed, but its behaviour is not defined.</p>\n<p>In your second statement, the declarator ends after <code>test t(t)</code>, and there is no initializer; the name <code>t</code> is <em>not</em> available where you use it, so the statement is ill-formed.</p>\n<p>So the compiler is behaving correctly. I would hope it could be configured to give a warning about the first statement, but it's not required to reject it; it is required to reject the second, as you say it does.</p>\n", "LastActivityDate": "2011-09-22T17:13:27.793", "CommentCount": "0", "CreationDate": "2011-09-22T17:13:27.793", "ParentId": "7518412", "Score": "2", "OwnerUserId": "204847"}});