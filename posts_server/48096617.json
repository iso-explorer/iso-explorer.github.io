post_cb({"bq_ids": {"n4140": {"so_48096617_48096710_2": {"length": 12, "quality": 1.0, "section_id": 214}, "so_48096617_48096710_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 224}}, "n3337": {"so_48096617_48096710_2": {"length": 12, "quality": 1.0, "section_id": 208}, "so_48096617_48096710_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 217}}, "n4659": {"so_48096617_48096710_2": {"length": 12, "quality": 1.0, "section_id": 222}, "so_48096617_48096710_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 6924}, "so_48096617_48096710_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 232}}}, "48096617": {"ViewCount": "59", "Body": "<p>Lengthy explanation first, actual question(s) second:</p>\n<p>In a C++ library, I want to provide points of customization. That is, certain methods can be \"injected\" by the user. Usually, this is done via ADL in the following way:</p>\n<p>File <code>operators.h</code> contains:</p>\n<pre><code>namespace operators\n{\n    namespace print_overloads\n    {\n        void print_value(double x)\n        {\n            cout &lt;&lt; x &lt;&lt; endl;\n        }\n    }\n\n    namespace detail\n    {\n        template &lt;typename Value&gt;\n        void adl_print(Value x)\n        {\n            using print_overloads::print_value;\n            print_value(x);\n        }\n    }\n\n    template &lt;typename Value&gt;\n    void print(Value x)\n    {\n        detail::adl_print(x);\n    }\n}\n</code></pre>\n<p><code>print_value()</code> provides a point of customization via ADL. To use it, one might have in <code>testi.cpp</code>:</p>\n<pre><code>#include \"operator.h\"\nnamespace custom\n{\n    struct A {};\n\n    void print_value(A)\n    {\n        cout &lt;&lt; \"ADL A overload\" &lt;&lt; endl;\n    }\n}\n\n\nint main()\n{\n    operators::print(custom::A{});\n}\n</code></pre>\n<p>This works as intended. However, it is only applicable if it is possible for the user to define a function in the corresponding namespace (<code>namespace custom</code> in this case).</p>\n<p>My idea was to introduce a dedicated overloading namespace, <code>namespace print_overload</code>in the example above. For the user, this should allow:</p>\n<pre><code>#include \"operators.h\"\nnamespace custom_inaccessible\n{\n    struct A {};\n}\n\nnamespace operators::print_overloads\n{\n    void print_value(custom_inaccessible::A)\n    {\n        cout &lt;&lt; \"A overload\" &lt;&lt; endl;\n    }\n}\n\n\nint main()\n{\n    operators::print(custom_inaccessible::A{});\n\n    int pause;\n    std::cin &gt;&gt; pause;\n    return 0;\n}\n</code></pre>\n<p>Unfortunately, this does not work. The current Microsoft Visual Studio 2017 C++ compiler fails with:</p>\n<p><code>error C2664: 'void operators::print_overloads::print_value(double)': cannot convert argument 1 from 'testi::B' to 'double'</code></p>\n<p>It seems, that the overload for <code>print_value(A)</code> is not considered in the overload list. After some tinkering, I found that Conformance mode settings where set to <code>Yes(/permissive-)</code>. If I set it to <code>No</code> everything works just fine.</p>\n<p>Now for the questions:</p>\n<ul>\n<li>Is this behavior defined in the standard?</li>\n<li>If so, what part of the standard is responsible for this result?</li>\n<li>Or is it some bug with the Visual Studio Conformance mode?</li>\n</ul>\n", "AcceptedAnswerId": "48096710", "Title": "Point of customization - namespace injection", "CreationDate": "2018-01-04T13:43:59.693", "Id": "48096617", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2018-01-04T14:16:28.877", "Score": "1", "OwnerUserId": "4747021", "Tags": "<c++><visual-studio-2017><overloading>", "AnswerCount": "1"}, "48096710": {"Id": "48096710", "PostTypeId": "2", "Body": "<p>To answer your query about the standard, the relevant paragraphs are at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.dep.candidate\" rel=\"nofollow noreferrer\">[temp.dep.candidate]</a>:</p>\n<blockquote>\n<p id=\"so_48096617_48096710_0\">For a function call where the postfix-expression is a dependent name,\n  the candidate functions are found using the usual lookup rules\n  ([basic.lookup.unqual], [basic.lookup.argdep]) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup, only function declarations from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces ([basic.lookup.argdep]), only function declarations found in either\n  the template definition context or the template instantiation context\n  are found.</li>\n</ul>\n</blockquote>\n<p>The above means that anything that is found on account of <code>using print_overloads::print_value;</code> (unqualified name lookup, according to the first bullet) has to already be present at the point the template is defined. A user cannot just re-open the namespace and add it afterwards.</p>\n<p>MSVC is very correct to reject it in conformance mode.</p>\n<hr>\n<p>To elaborate, the using declaration introduces names by qualified name lookup, according to <a href=\"https://timsong-cpp.github.io/cppwp/n4659/namespace.udecl#1\" rel=\"nofollow noreferrer\">[namespace.udecl]/1</a>:</p>\n<blockquote>\n<p id=\"so_48096617_48096710_1\">Each using-declarator in a using-declaration introduces a set of\n  declarations into the declarative region in which the\n  using-declaration appears. The set of declarations introduced by the\n  using-declarator is found by performing qualified name lookup for the\n  name in the using-declarator, excluding functions that are hidden as\n  described below.</p>\n</blockquote>\n<p>But, the using declaration is only introducing non-dependent names. And according to <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.nondep#1\" rel=\"nofollow noreferrer\">[temp.nondep]/1</a>:</p>\n<blockquote>\n<p id=\"so_48096617_48096710_2\">Non-dependent names used in a template definition are found using the\n  usual name lookup and bound at the point they are used.</p>\n</blockquote>\n<p>The \"point they are used\" being the point of the template definition.</p>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2018-01-04T14:16:28.877", "Score": "1", "CreationDate": "2018-01-04T13:49:50.057", "ParentId": "48096617", "CommentCount": "2", "OwnerUserId": "817643", "LastEditDate": "2018-01-04T14:16:28.877"}});