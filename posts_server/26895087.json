post_cb({"26895087": {"CommentCount": "10", "ViewCount": "662", "CreationDate": "2014-11-12T19:36:16.480", "LastActivityDate": "2014-11-12T19:47:49.630", "PostTypeId": "1", "AcceptedAnswerId": "26895298", "FavoriteCount": "1", "Title": "Does the C++ standard allow for an implementation to coalesce allocations?", "Id": "26895087", "Score": "4", "Body": "<p>I was watching Jonathan Blow's video <a href=\"http://www.youtube.com/watch?v=TH9VCN6UkyQ&amp;t=65m40s\" rel=\"nofollow\"><em>Ideas about a new programming language for games</em></a> in which he discusses a common pattern in games programming he calls 'joint allocation'. The idea is when you have a class with several members that are dynamically allocated arrays (could be <code>std::vector</code> but since they're fixed size, more like the proposed <code>std::dynarray</code>) you pre-allocate enough memory to store all of the array data and perform only one allocation big enough for all the arrays rather than one for each array.</p>\n<p>He proposes direct language support for this pattern which got me to wondering whether the C++ standard allows for implementations to coalesce allocations in this way? It strikes me that this would require some heroic effort from a compiler to actually implement as an optimization but I don't see an obvious reason why it couldn't be done in principle. Does anyone know if this would not be permitted under the standard, or even if there are already implementations that do this optimization in practice?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "139091", "AnswerCount": "1"}, "26895298": {"ParentId": "26895087", "CommentCount": "5", "CreationDate": "2014-11-12T19:47:49.630", "OwnerUserId": "3204551", "PostTypeId": "2", "Id": "26895298", "Score": "9", "Body": "<p>Yes, the standard allows coalescing allocations (C++14):</p>\n<blockquote>\n<h3>5.3.4 New <code>[expr.new]</code></h3>\n<p id=\"so_26895087_26895298_0\">10 An implementation is allowed to omit a call to a replaceable global allocation function (18.6.1.1, 18.6.1.2).\n  When it does so, the storage is instead provided by the implementation or provided by extending the\n  allocation of another <em>new-expression</em>. The implementation may extend the allocation of a <em>new-expression</em> <code>e1</code>\n  to provide storage for a <em>new-expression</em> <code>e2</code> if the following would be true were the allocation not extended:</p>\n<ul>\n<li>the evaluation of <code>e1</code> is sequenced before the evaluation of <code>e2</code>, and</li>\n<li><code>e2</code> is evaluated whenever e1 obtains storage, and</li>\n<li>both <code>e1</code> and <code>e2</code> invoke the same replaceable global allocation function, and</li>\n<li>if the allocation function invoked by <code>e1</code> and <code>e2</code> is throwing, any exceptions thrown in the evaluation\n  of either <code>e1</code> or <code>e2</code> would be first caught in the same handler, and</li>\n<li>the pointer values produced by <code>e1</code> and <code>e2</code> are operands to evaluated <em>delete-expressions</em>, and</li>\n<li>the evaluation of <code>e2</code> is sequenced before the evaluation of the <em>delete-expression</em> whose operand is the pointer value produced by <code>e1</code>.</li>\n</ul>\n</blockquote>\n<p>C++11 did not allow coalescing or omitting such allocations.</p>\n", "LastActivityDate": "2014-11-12T19:47:49.630"}, "bq_ids": {"n4140": {"so_26895087_26895298_0": {"section_id": 6091, "quality": 0.9166666666666666, "length": 33}}, "n4659": {"so_26895087_26895298_0": {"section_id": 7587, "quality": 0.9166666666666666, "length": 33}}}});