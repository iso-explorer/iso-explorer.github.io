post_cb({"24672097": {"CommentCount": "8", "ViewCount": "124", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2014-07-10T08:46:29.643", "LastActivityDate": "2014-08-03T09:25:40.077", "Title": "Form 16 bit words from a struct", "LastEditDate": "2014-07-10T09:37:01.740", "Id": "24672097", "Score": "0", "Body": "<p>So I'm working on creating a ICMPv4 echo request and decided to roll my own struct to hold the packet. To make identifying the packet easy to identify in wireshark, I decided to put abcde into the data field.</p>\n<pre><code>struct icmpPacket{\n    u_int8_t icmp_type:8, icmp_code:8;\n    u_int16_t icmp_checksum:16, icmp_id:16, icmp_seqnum:16;\n    char icmp_data[6]; //cheat a little bit, set the field just large enough to store \"abcde\";\n    } __attribute__((aligned (16))) icmppckt; // icmp has an 8 byte header + 6 bytes of data\n</code></pre>\n<p>What I'm getting stuck on is how to make the compiler read the struct out as a series of 16 bit word</p>\n", "Tags": "<c++><c><struct>", "OwnerUserId": "1516109", "AnswerCount": "2"}, "24673071": {"ParentId": "24672097", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>The standard-compliant way to do this is via <code>memcpy</code>:</p>\n<pre><code>icmpPacket packet = { /* ... */ };\nuint16_t buf[sizeof(icmpPacket) / sizeof(uint16_t)];\nmemcpy(buf, &amp;packet, sizeof(icmpPacket));\n/* Now use buf */\n</code></pre>\n<p>Modern compilers are clever enough to optimize this appropriately, without actually doing a function call. See examples with <a href=\"http://goo.gl/GcclDC\" rel=\"nofollow noreferrer\">clang</a> and <a href=\"http://goo.gl/tI1ib6\" rel=\"nofollow noreferrer\">g++</a>).</p>\n<p>A common compiler extension allows you to use unions, though this is <a href=\"https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-undefined\">undefined behavior under the C++ standard</a>:</p>\n<pre><code>union packet_view{\n    icmpPacket packet;\n    uint16_t buf[sizeof(icmpPacket) / sizeof(uint16_t)];\n};\nicmpPacket packet = { /* ... */ };\npacket_view view;\nview.packet = packet;\n/* Now read from view.buf. This is technically UB in C++ but most compilers define it. */\n</code></pre>\n<p>Using a <code>reinterpret_cast&lt;uint16_t*&gt;(&amp;packet)</code> or its C equivalent would break strict aliasing rules and result in undefined behavior. \u00a73.10 [basic.lval]/p10 of the C++ standard:</p>\n<blockquote>\n<p id=\"so_24672097_24673071_0\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including,\n  recursively, an element or non-static data member of a subaggregate or\n  contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<p>Similarly, \u00a76.5/p7 of C11 says:</p>\n<blockquote>\n<p id=\"so_24672097_24673071_1\">An object shall have its stored value accessed only by an lvalue\n  expression that has one of the following types:</p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>a qualified version of a type compatible with the effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a\n  subaggregate or contained union), or</li>\n<li>a character type.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "2756719", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:11:02.600", "Id": "24673071", "Score": "1", "CreationDate": "2014-07-10T09:34:31.080", "LastActivityDate": "2014-08-03T09:25:40.077"}, "24673106": {"ParentId": "24672097", "CommentCount": "0", "Body": "<p>you can use 16 bit pointers for that</p>\n<ul>\n<li>but yout need to add <strong>aligning</strong> to <strong>1 Byte</strong> of the structure elements !!!</li>\n<li><p>in C++ you can do it like this:</p>\n<pre><code>#pragma pack(1)\nstruct icmpPacket\n    {\n    u_int8_t icmp_type:8, icmp_code:8;\n    u_int16_t icmp_checksum:16, icmp_id:16, icmp_seqnum:16;\n    char icmp_data[6]; //cheat a little bit, set the field just large enough to store \"abcde\";\n    } icmppckt; // icmp has an 8 byte header + 6 bytes of data\nWORD *picmppckt16=(WORD*)((void*)&amp;icmppckt);\n#pragma pack()\n</code></pre></li>\n<li><p>change WORD to 16 bit data type your compiler knows ...</p></li>\n</ul>\n", "OwnerUserId": "2521214", "PostTypeId": "2", "Id": "24673106", "Score": "0", "CreationDate": "2014-07-10T09:35:40.147", "LastActivityDate": "2014-07-10T09:35:40.147"}, "bq_ids": {"n4140": {"so_24672097_24673071_0": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_24672097_24673071_1": {"section_id": 7230, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_24672097_24673071_0": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_24672097_24673071_1": {"section_id": 6974, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_24672097_24673071_0": {"section_id": 8748, "quality": 1.0, "length": 14}}}});