post_cb({"bq_ids": {"n4140": {"so_18760657_18761525_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 477}, "so_18760657_18761525_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 464}}, "n3337": {"so_18760657_18761525_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 468}, "so_18760657_18761525_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 455}}, "n4659": {"so_18760657_18761525_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 500}, "so_18760657_18761525_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 487}}}, "18760657": {"ViewCount": "1038", "Body": "<p>I have a bunch of questions related to this, I couldn't find exact answers.\nClass A is the main class, and B is a subclass</p>\n<ol>\n<li><p>If A::operator=(const A &amp; other) was defined, does the default implementation of B::operator= copies members of B then calls A::operator= ?</p></li>\n<li><p>If A copy constructor was defined, does the default implementation of the copy constructor for B copy-constructs members of B, then calls A copy constructor?</p></li>\n<li><p>Do I need to define above functions virtual in A to get this behavior? (I suppose yes for operator= and no for the copy constructor, as virtual constructors is a nonsense?)</p></li>\n<li><p>Can I forbid overloading the assignment operator or the copy constructor for subclasses of A, to force the use of default implementations?</p></li>\n</ol>\n<p>The idea behind this, being to offer a plugin API for my users. I need the API to be C++ as scripts are too slow (I'll try JIT compilation one day), but it should be very simple.</p>\n", "AcceptedAnswerId": "18761525", "Title": "Subclassing, assignment operator and copy constructor", "CreationDate": "2013-09-12T09:38:04.150", "Id": "18760657", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-09-12T09:39:53.460", "LastEditorUserId": "188331", "LastActivityDate": "2013-09-12T10:27:33.017", "Score": "1", "OwnerUserId": "2042388", "Tags": "<c++><constructor><copy><operator-keyword><subclassing>", "AnswerCount": "1"}, "18761525": {"Id": "18761525", "PostTypeId": "2", "Body": "<ol>\n<li><p>If the default copy-assignment operator of class <code>B</code> is not deleted, [class.copy]/28</p>\n<blockquote>\n<p id=\"so_18760657_18761525_0\">The implicitly-defined copy/move assignment operator for a non-union class <code>X</code> performs memberwise copy-/move assignment of its subobjects. The direct base classes of <code>X</code> are assigned first, in the order of their declaration in the <em>base-specifier-list</em> [i.e. in the order in which they're listed after <code>class X : /*here*/ {/*...*/};</code>], and then the immediate non-static data members of <code>X</code> are assigned, in the order in which they were declared in the class definition.</p>\n</blockquote></li>\n<li><p>Similarly, [class.copy]/15</p>\n<blockquote>\n<p id=\"so_18760657_18761525_1\">The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move of its bases and members.</p>\n</blockquote>\n<p>The order is: first the base class(es) (base class subobjects), then the direct non-static data members, similarly to 1).</p></li>\n<li><p>For the behaviour described in 1) and 2), <strong>no</strong>. Virtual assignment operators are hardly ever useful. Constructors may not be virtual at all (doesn't make sense).</p>\n<p>In order for a virtual function in a derived class <code>B</code> to override a virtual function in a base class <code>A</code>, it must have the same parameter types. That is, you could have a <code>virtual A&amp; operator=(A const&amp;);</code> in the base class <code>A</code>, but the override in class <code>B</code> had to look like <code>virtual B&amp; operator=(A const&amp;);</code>, which is <strong>not</strong> a copy-assignment operator for <code>B</code>, because of the parameter type.</p></li>\n<li><p>Not without \"hacks\". And you're not actually overloading it, but hiding all base class assignment operators. Otherwise, this would be legal:</p>\n<pre><code>class A {};\nclass B { int i; };\n\nA a;\nB b = a; // using A::operator=(A const&amp;)\n</code></pre></li>\n</ol>\n", "LastEditorUserId": "420683", "LastActivityDate": "2013-09-12T10:27:33.017", "Score": "3", "CreationDate": "2013-09-12T10:17:10.877", "ParentId": "18760657", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2013-09-12T10:27:33.017"}});