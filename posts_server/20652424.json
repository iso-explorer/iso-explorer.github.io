post_cb({"20652665": {"ParentId": "20652424", "LastEditDate": "2017-05-23T11:56:45.393", "CommentCount": "5", "CreationDate": "2013-12-18T08:04:08.117", "OwnerUserId": "493122", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "20652665", "Score": "17", "Body": "<p>The standard (at \u00a7 13.4) defines that:</p>\n<blockquote>\n<p id=\"so_20652424_20652665_0\">A use of an overloaded function name without arguments is resolved in\n  certain contexts to a function, a pointer to function or a pointer to\n  member function for a specific function from the overload set. A\n  function template name is considered to name a set of overloaded\n  functions in such contexts. <strong>The function selected is the one whose\n  type is identical to the function type of the target type required in\n  the context</strong>.</p>\n</blockquote>\n<p>Emphasis mine.</p>\n<p>After the quote, there is an example (at \u00a7 13.4/5) that resembles yours:</p>\n<pre><code>int f(double);\nint f(int);\nint (*pfd)(double) = &amp;f; // selects f(double)\nint (*pfi)(int) = &amp;f; // selects f(int)\n</code></pre>\n<hr>\n<p>As far as the unary <code>&amp;</code> is concerned, the standard specifies that (at \u00a7 5.3.1/6 and thanks to <a href=\"https://stackoverflow.com/users/777186/jogojapan\">jogojapan</a>):</p>\n<blockquote>\n<p id=\"so_20652424_20652665_1\">The address of an overloaded function can be taken only in a context\n  that uniquely determines which version of the overloaded function is\n  referred to.</p>\n</blockquote>\n<p>but can also be omitted (at \u00a7 13.4/1):</p>\n<blockquote>\n<p id=\"so_20652424_20652665_2\">The overloaded function name <strong>can</strong> be preceded by the &amp; operator.</p>\n</blockquote>\n<p>(again, emphasis mine) just like you did, in your example.</p>\n</hr>", "LastActivityDate": "2013-12-18T08:15:47.967"}, "bq_ids": {"n4140": {"so_20652424_20652424_0": {"section_id": 5954, "quality": 0.8, "length": 16}, "so_20652424_20652665_1": {"section_id": 6069, "quality": 0.9230769230769231, "length": 12}, "so_20652424_20652665_2": {"section_id": 641, "quality": 0.8571428571428571, "length": 6}, "so_20652424_20652665_0": {"section_id": 641, "quality": 0.975, "length": 39}}, "n3337": {"so_20652424_20652424_0": {"section_id": 5724, "quality": 0.8, "length": 16}, "so_20652424_20652665_1": {"section_id": 5837, "quality": 0.9230769230769231, "length": 12}, "so_20652424_20652665_2": {"section_id": 631, "quality": 0.8571428571428571, "length": 6}, "so_20652424_20652665_0": {"section_id": 631, "quality": 0.975, "length": 39}}, "n4659": {"so_20652424_20652665_1": {"section_id": 7565, "quality": 0.9230769230769231, "length": 12}, "so_20652424_20652424_0": {"section_id": 7441, "quality": 0.75, "length": 15}, "so_20652424_20652665_2": {"section_id": 669, "quality": 0.8571428571428571, "length": 6}, "so_20652424_20652665_0": {"section_id": 669, "quality": 0.825, "length": 33}}}, "20652424": {"CommentCount": "6", "ViewCount": "227", "CreationDate": "2013-12-18T07:50:42.077", "LastActivityDate": "2013-12-18T08:15:47.967", "PostTypeId": "1", "AcceptedAnswerId": "20652665", "FavoriteCount": "1", "Title": "C++11 initializer with ambiguous function id-expression?", "Id": "20652424", "Score": "18", "Body": "<p>In the following C++11 code:</p>\n<pre><code>void f(int) {}\nvoid f(double) {}\n\nvoid (*p)(int) = f;\n</code></pre>\n<p>There are two functions.</p>\n<p>The third <code>f</code> identifier is an id-expression and the initializer of <code>p</code>.</p>\n<p>In 5.1.1p8 [expr.prim.general]/8 it says:</p>\n<blockquote>\n<p id=\"so_20652424_20652424_0\">The type of the [id-expression] is the type of the identifier.\n  The result is the entity denoted by the identifier. The result is an lvalue if the entity is a function, variable, or data member and a prvalue otherwise.</p>\n</blockquote>\n<p>Given that <code>f</code> could be referring to two different entities with two different types, there is no \"the entity\" or \"the type\".</p>\n<p>Is there some other text in the standard that addresses this situation?</p>\n<p>Do implementations just disambiguate this as an extension or is it required somewhere?  (Without some other text one could argue that an implementation could reject the f id-expression as ambiguous.)</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1131467", "AnswerCount": "1"}});