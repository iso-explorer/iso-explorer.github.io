post_cb({"8067658": {"LastActivityDate": "2011-11-09T16:17:43.763", "CommentCount": "4", "Body": "<p>Just do </p>\n<pre><code>int* x = int();\n</code></pre>\n<p>It still assigns 0 to the pointer making it point to the NULL address since you're defaulting it with the default value of int which is 0 anyway.</p>\n<p>Actually, it works fine for all types:</p>\n<pre><code>double* y = int();\n</code></pre>\n<p>The address is still a 32-bit (or 64-bit depending on platform) integer so I think it should work fine for all types if you do = int().</p>\n", "CreationDate": "2011-11-09T15:53:32.663", "LastEditDate": "2011-11-09T16:17:43.763", "ParentId": "8067568", "Id": "8067658", "LastEditorUserId": "857994", "PostTypeId": "2", "Score": "1", "OwnerUserId": "857994"}, "8067706": {"LastActivityDate": "2011-11-10T02:22:30.047", "CommentCount": "1", "Body": "<p>The reason that doesn't work is because pointers do not have constructors.</p>\n<p>The syntax</p>\n<blockquote>\n<p id=\"so_8067568_8067706_0\"><code>int ()</code></p>\n</blockquote>\n<p>calls (in theory)</p>\n<blockquote>\n<p id=\"so_8067568_8067706_1\"><code>int::int ()</code></p>\n</blockquote>\n<p>which initializes the variable. (More likely, the compiler just zeros the variable, but that's because it \"knows\" about ints).</p>\n<p>In c++11, you can use nullptr</p>\n<blockquote>\n<p id=\"so_8067568_8067706_2\"><code>int *ptr = nullptr;</code></p>\n</blockquote>\n<p>Otherwise, you pretty much have to use NULL:</p>\n<blockquote>\n<p id=\"so_8067568_8067706_3\"><code>int *ptr = NULL;</code></p>\n</blockquote>\n", "CreationDate": "2011-11-09T15:55:45.220", "LastEditDate": "2011-11-10T02:22:30.047", "ParentId": "8067568", "Id": "8067706", "LastEditorUserId": "10936", "PostTypeId": "2", "Score": "0", "OwnerUserId": "992490"}, "8068246": {"LastActivityDate": "2011-11-09T16:41:59.193", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_8067568_8068246_0\">How do I value-initialize a Type* pointer using Type()-like syntax?</p>\n</blockquote>\n<p>You cannot. The syntax <code>T()</code> is defined in 5.2.3/1,2 (C++03, slightly different wording in C++11 FDIS). In particular the second paragraph states:</p>\n<blockquote>\n<p id=\"so_8067568_8068246_1\">The expression T(), where T is a simple-type-specifier (7.1.5.2) for a non-array complete object type or the (possibly cv-qualified) void type, creates an rvalue of the specified type, which is value-initialized (8.5);</p>\n</blockquote>\n<p>That means that <code>int()</code>, will create an rvalue of type int and <em>value-initialize</em> it. Now the problem is that <code>int*</code> is not a simple-type-specifier, but rather an elaborated-type-specifier. The definition of simple-type-specifier in the grammar is:</p>\n<pre><code>  simple-type-specifier:\n    ::opt nested-name-specifieropt type-name\n    ::opt nested-name-specifier template template-id\n    char\n    wchar_t\n    bool\n    short\n    int\n    long\n    signed\n    unsigned\n    float\n    double\n    void\n</code></pre>\n<p>With type-name being defined as:</p>\n<pre><code>  type-name:\n    class-name\n    enum-name\n    typedef-name\n</code></pre>\n<p>This is what makes the proposed solutions work. The creation of the typedef (either directly or through the template) creates a type-name (third type) that can be used as a simple-type-specifier (first type).</p>\n", "CreationDate": "2011-11-09T16:35:33.367", "LastEditDate": "2011-11-09T16:41:59.193", "ParentId": "8067568", "Id": "8068246", "LastEditorUserId": "36565", "PostTypeId": "2", "Score": "4", "OwnerUserId": "36565"}, "8067666": {"CommentCount": "4", "Body": "<p>Use a typedef to make a name for your pointer type:</p>\n<pre><code>typedef int *ip;\n\nip ptr = ip();\n</code></pre>\n<p>The same idea should work for other types that require more than one lexical element (word) to define the name of the type (e.g., <code>unsigned long</code>, <code>long long</code>, <code>unsigned long long *</code>, etc.).</p>\n", "CreationDate": "2011-11-09T15:54:01.633", "ParentId": "8067568", "Id": "8067666", "LastActivityDate": "2011-11-09T15:54:01.633", "PostTypeId": "2", "Score": "9", "OwnerUserId": "179910"}, "8067568": {"CreationDate": "2011-11-09T15:47:25.227", "ViewCount": "1543", "FavoriteCount": "1", "Id": "8067568", "AcceptedAnswerId": "8068246", "Score": "14", "Title": "How do I value-initialize a Type* pointer using Type()-like syntax?", "LastEditorUserId": "-1", "CommentCount": "2", "Body": "<p>Variables of built-in types <a href=\"https://stackoverflow.com/questions/2584213/how-to-default-initialize-local-variables-of-built-in-types-in-c/2584240#2584240\">can be value-initialized like this</a>:</p>\n<pre><code>int var = int();\n</code></pre>\n<p>this way I get the default value of <code>int</code> without hardcoding the zero in my code.</p>\n<p>However if I try to do similar stuff for a pointer:</p>\n<pre><code>int* ptr = int*();\n</code></pre>\n<p>the compiler (Visual C++ 10) refuses to compile that (says <code>type int unexpected</code>).</p>\n<p>How do I value-initialize a pointer in similar manner?</p>\n", "Tags": "<c++><pointers><initialization><local-variables><built-in-types>", "LastEditDate": "2017-05-23T12:16:28.983", "LastActivityDate": "2011-11-10T02:22:30.047", "PostTypeId": "1", "AnswerCount": "7", "OwnerUserId": "57428"}, "8067661": {"CommentCount": "1", "Body": "<p>Here's one way:</p>\n<pre><code>template &lt;typename T&gt;\nT make_default()\n{\n    return T();\n}\n\nint main()\n{\n    int *p = make_default&lt;int*&gt;();\n}\n</code></pre>\n", "CreationDate": "2011-11-09T15:53:37.490", "ParentId": "8067568", "Id": "8067661", "LastActivityDate": "2011-11-09T15:53:37.490", "PostTypeId": "2", "Score": "1", "OwnerUserId": "499449"}, "bq_ids": {"n4140": {"so_8067568_8068246_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6000}}, "n3337": {"so_8067568_8068246_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 5768}}}, "8067680": {"CommentCount": "1", "Body": "<p>This is how you do it\n   int* ptr = new int;</p>\n<p><a href=\"http://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/\" rel=\"nofollow\">Heap pointers</a></p>\n", "CreationDate": "2011-11-09T15:54:41.240", "ParentId": "8067568", "Id": "8067680", "LastActivityDate": "2011-11-09T15:54:41.240", "PostTypeId": "2", "Score": "-1", "OwnerUserId": "1037365"}, "8067877": {"CommentCount": "3", "Body": "<p>Doesn't require the use of <code>typedef</code> (but exclusive to C++11), which can be useful when dealing with several pointer types:</p>\n<pre><code>template&lt;typename T&gt;\nusing alias = T;\n</code></pre>\n<p>then <code>alias&lt;int*&gt;</code> is <code>int*</code>, so you can do <code>int* p = alias&lt;int*&gt;()</code>.</p>\n<p>A similar solution available to C++03, using an identity metafunction:</p>\n<pre><code>template&lt;typename T&gt;\nstruct identity {\n    typedef T type;\n};\n\nint* p = identity&lt;int*&gt;::type();\n</code></pre>\n", "CreationDate": "2011-11-09T16:08:51.980", "ParentId": "8067568", "Id": "8067877", "LastActivityDate": "2011-11-09T16:08:51.980", "PostTypeId": "2", "Score": "3", "OwnerUserId": "726300"}});