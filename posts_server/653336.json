post_cb({"654596": {"ParentId": "653336", "CommentCount": "0", "Body": "<p>If you lie to the compiler, it will punish you.</p>\n<p>If the buffer contains data that is just passing through, and you will not manipulate them in any way, it doesn't matter.</p>\n<p>However, if you have to operate on the buffer contents then the correct type declaration will make your code simpler.  No \"int val = buf[i] &amp; 0xff;\" nonsense.</p>\n<p>So, think about what the data actually is and how you need to use it.</p>\n", "OwnerUserId": "22704", "Id": "654596", "PostTypeId": "2", "OwnerDisplayName": "Darron", "Score": "-1", "CreationDate": "2009-03-17T14:57:30.437", "LastActivityDate": "2009-03-17T14:57:30.437"}, "653780": {"ParentId": "653336", "CommentCount": "0", "Body": "<p>You should use either <em>char</em> or <em>unsigned char</em> but never <em>signed char</em>.  The standard has the following in 3.9/2</p>\n<blockquote>\n<p id=\"so_653336_653780_0\">For any object (other than a\n  base-class subobject) of POD type T,\n  whether or not the object holds a\n  valid value of type T, the underlying\n  bytes (1.7) making up the object can\n  be copied into an array of char or\n  unsigned char.If the content of\n  the array of char or unsigned char is\n  copied back into the object, the\n  object shall subsequently hold its\n  original value.</p>\n</blockquote>\n", "OwnerUserId": "11698", "Id": "653780", "PostTypeId": "2", "OwnerDisplayName": "Richard Corden", "Score": "5", "CreationDate": "2009-03-17T11:08:26.260", "LastActivityDate": "2009-03-17T11:08:26.260"}, "653912": {"CommentCount": "4", "CreationDate": "2009-03-17T11:53:46.650", "LastEditorUserId": "34509", "LastActivityDate": "2009-03-17T13:11:49.507", "ParentId": "653336", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastEditDate": "2009-03-17T13:11:49.507", "Id": "653912", "Score": "44", "Body": "<p>If you intend to store arbitrary binary data, you should use <code>unsigned char</code>. It is the only data type that is guaranteed to have no padding bits by the C Standard. Each other data type may contain padding bits in its object representation (that is the one that contains all bits of an object, instead of only those that determines a value). The padding bits' state is unspecified and are not used to store values. So if you read using <code>char</code> some binary data, things would be cut down to the value range of a char (by interpreting only the value bits), but there may still be bits that are just ignored but still are there and read by <code>memcpy</code>. Much like padding bits in real struct objects. Type <code>unsigned char</code> is guaranteed to not contain those. That follows from <code>5.2.4.2.1/2</code> (C99 TC2, n1124 here):</p>\n<blockquote>\n<p id=\"so_653336_653912_0\">If the value of an object of type char is treated as a signed integer when used in an\n  expression, the value of <code>CHAR_MIN</code> shall be the same as that of <code>SCHAR_MIN</code> and the\n  value of <code>CHAR_MAX</code> shall be the same as that of <code>SCHAR_MAX</code>. Otherwise, the value of\n  <code>CHAR_MIN</code> shall be 0 and the value of <code>CHAR_MAX</code> shall be the same as that of\n  <code>UCHAR_MAX</code>. <em>The value <code>UCHAR_MAX</code> shall equal <code>2^CHAR_BIT \u2212 1</code></em></p>\n</blockquote>\n<p>From the last sentence it follows that there is no space left for any padding bits. If you use <code>char</code> as the type of your buffer, you also have the problem of overflows: Assigning any value explicitly to one such element which is in the range of <code>8</code> bits - so you may expect such assignment to be OK - but not within the range of a <code>char</code>, which is <code>CHAR_MIN</code>..<code>CHAR_MAX</code>, such a conversion overflows and causes implementation defined results, including raise of signals.</p>\n<p>Even if any problems regarding the above would probably not show in real implementations (would be a <em>very</em> poor quality of implementation), you are best to use the right type from the beginning onwards, which is <code>unsigned char</code>. </p>\n<p>For strings, however, the data type of choice is <code>char</code>, which will be understood by string and print functions. Using <code>signed char</code> for these purposes looks like a wrong decision to me. </p>\n<p>For further information, read <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1310.htm\" rel=\"noreferrer\"><code>this proposal</code></a> which contain a fix for a next version of the C Standard which eventually will require <code>signed char</code> not have any padding bits either. It's already incorporated into the <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1362.pdf\" rel=\"noreferrer\">working paper</a>. </p>\n", "OwnerUserId": "34509", "OwnerDisplayName": "litb"}, "653346": {"ParentId": "653336", "CommentCount": "1", "Body": "<p>Should and should ... I tend to <i>prefer</i> unsigned, since it feels more \"raw\", less inviting to say \"hey, that's just a bunch of small <code>ints</code>\", if I want to emphasize the binary-ness of the data.</p>\n<p>I don't think I've ever used an explicit <code>signed char</code> to represent a buffer of bytes.</p>\n<p>Of course, one third option is to represent the buffer as <code>void *</code> as much as possible. Many common I/O functions work with <code>void *</code>, so sometimes the decision of what integer type to use can be fully encapsulated, which is nice.</p>\n", "OwnerUserId": "28169", "Id": "653346", "PostTypeId": "2", "OwnerDisplayName": "unwind", "Score": "0", "CreationDate": "2009-03-17T08:01:02.980", "LastActivityDate": "2009-03-17T08:01:02.980"}, "653336": {"CommentCount": "0", "ViewCount": "20221", "OwnerDisplayName": "Jack", "CreationDate": "2009-03-17T07:52:04.313", "LastActivityDate": "2011-02-20T15:46:53.617", "PostTypeId": "1", "AcceptedAnswerId": "5058059", "FavoriteCount": "19", "Title": "Should a buffer of bytes be signed or unsigned char buffer?", "Id": "653336", "Score": "48", "Body": "<p>Should a buffer of bytes be signed char or unsigned char or simply a char buffer?\nAny differences between C and C++?</p>\n<p>Thanks.</p>\n", "Tags": "<c++><c><char><buffer>", "OwnerUserId": "48461", "AnswerCount": "14"}, "bq_ids": {"n4140": {"so_653336_653780_0": {"section_id": 7200, "quality": 0.925, "length": 37}}, "n3337": {"so_653336_653780_0": {"section_id": 6944, "quality": 0.925, "length": 37}}, "n4659": {"so_653336_653780_0": {"section_id": 8709, "quality": 0.85, "length": 34}}}, "654661": {"ParentId": "653336", "CommentCount": "3", "Body": "<pre><code>typedef char byte;\n</code></pre>\n<p>Now you can make your array be of <code>byte</code>s.  It's obvious to everyone what you meant, and you don't lose any functionality.</p>\n<p>I know it's somewhat silly, but it makes your code read 100% as you intended.</p>\n", "OwnerUserId": "8643", "Id": "654661", "PostTypeId": "2", "OwnerDisplayName": "Matt Cruikshank", "Score": "0", "CreationDate": "2009-03-17T15:10:11.983", "LastActivityDate": "2009-03-17T15:10:11.983"}, "653621": {"ParentId": "653336", "CommentCount": "0", "Body": "<p>For maximum portability always use unsigned char.  There are a couple of instances where this could come into play.  Serialized data shared across systems with different endian type immediately comes to mind.  When performing shift or bit masking the values is another. </p>\n", "OwnerUserId": "67707", "Id": "653621", "PostTypeId": "2", "OwnerDisplayName": "MrEvil", "Score": "3", "CreationDate": "2009-03-17T10:05:31.967", "LastActivityDate": "2009-03-17T10:05:31.967"}, "653570": {"ParentId": "653336", "CommentCount": "2", "Body": "<p>If it actually is a buffer of 8 bit bytes, rather than a string in the machine's default locale, then I'd use <code>uint8_t</code>. Not that there are many machines around where a char is not a byte (or a byte a octet), but making the statement 'this is a buffer of octets' rather than 'this is a string' is often useful documentation.</p>\n", "OwnerUserId": "1527", "Id": "653570", "PostTypeId": "2", "OwnerDisplayName": "Pete Kirkham", "Score": "9", "CreationDate": "2009-03-17T09:49:02.770", "LastActivityDate": "2009-03-17T09:49:02.770"}, "653361": {"ParentId": "653336", "CommentCount": "8", "Body": "<p>Do you really care?  If you don't, just use the default (char) and don't clutter your code with unimportant matter.  Otherwise, future maintainers will be left wondering why did you use signed (or unsigned).  Make their life simpler.</p>\n", "OwnerUserId": "25824", "Id": "653361", "PostTypeId": "2", "OwnerDisplayName": "Gorpik", "Score": "0", "CreationDate": "2009-03-17T08:06:58.803", "LastActivityDate": "2009-03-17T08:06:58.803"}, "5058059": {"ParentId": "653336", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_653336_5058059_0\">Should a buffer of bytes be signed\n  char or unsigned char or simply a char\n  buffer? Any differences between C and\n  C++?</p>\n</blockquote>\n<p>A minor difference in how the language treats it.  A <strong>huge</strong> difference in how convention treats it.</p>\n<ul>\n<li><code>char</code> = ASCII (or UTF-8, but the signedness gets in the way there) <strong>textual</strong> data</li>\n<li><code>unsigned char</code> = byte</li>\n<li><code>signed char</code> = rarely used</li>\n</ul>\n<p>And there is code that <em>relies</em> on such a distinction.  Just a week or two ago I encountered a bug where JPEG data was getting corrupted because it was being passed to the <code>char*</code> version of our Base64 encode function \u2014 which \"helpfully\" replaced all the invalid UTF-8 in the \"string\".  Changing to <code>BYTE</code> aka <code>unsigned char</code> was all it took to fix it.</p>\n", "OwnerUserId": "287586", "PostTypeId": "2", "Id": "5058059", "Score": "25", "CreationDate": "2011-02-20T15:46:53.617", "LastActivityDate": "2011-02-20T15:46:53.617"}, "653355": {"ParentId": "653336", "CommentCount": "0", "Body": "<p>It depends.</p>\n<p>If the buffer is intended to hold text, then it probably makes sense to declare it as an array of <code>char</code> and let the platform decide for you whether that is signed or unsigned by default. That will give you the least trouble passing the data in and out of the implementation's runtime library, for example.</p>\n<p>If the buffer is intended to hold binary data, then it depends on how you intend to use it. For example, if the binary data is really a packed array of data samples that are signed 8-bit fixed point ADC measurements, then <code>signed char</code> would be best. </p>\n<p>In most real-world cases, the buffer is just that, a buffer, and you don't really care about the types of the individual bytes because you filled the buffer in a bulk operation, and you are about to pass it off to a parser to interpret the complex data structure and do something useful. In that case, declare it in the simplest way.</p>\n", "OwnerUserId": "68204", "Id": "653355", "PostTypeId": "2", "OwnerDisplayName": "RBerteig", "Score": "12", "CreationDate": "2009-03-17T08:03:26.253", "LastActivityDate": "2009-03-17T08:03:26.253"}, "653339": {"ParentId": "653336", "CommentCount": "0", "Body": "<p>If you fetch an element into a wider variable, it will of course be sign-extended or not.<br/></p>\n", "OwnerUserId": "10972", "Id": "653339", "PostTypeId": "2", "OwnerDisplayName": "pngaz", "Score": "0", "CreationDate": "2009-03-17T07:55:25.617", "LastActivityDate": "2009-03-17T07:55:25.617"}, "654541": {"ParentId": "653336", "CommentCount": "0", "Body": "<p>The choice of int8_t vs uint8_t is similar to when you are comparing a ptr to be NULL. </p>\n<hr>\n<p>From a functionality point of view, comparing to NULL is the same as comparing to 0 because NULL is a #define for 0.</p>\n<p>But personally, from a coding style point of view, I choose to compare my pointers to NULL because the NULL #define connotes to the person maintaining the code that you are checking for a bad pointer... </p>\n<p>VS</p>\n<p>when someone sees a comparison to 0 it connotes that you are checking for a specific value.</p>\n<hr>\n<p>For the above reason, I would use uint8_t.</p>\n</hr></hr>", "OwnerUserId": "52074", "Id": "654541", "PostTypeId": "2", "OwnerDisplayName": "Trevor Boyd Smith", "Score": "2", "CreationDate": "2009-03-17T14:44:36.193", "LastActivityDate": "2009-03-17T14:44:36.193"}, "653353": {"ParentId": "653336", "CommentCount": "0", "Body": "<p>Several years ago I had a problem with a C++ console application that printed colored chars for ASCII values above 128 and this was solved by switching from char to unsigned char, but I think it had been solveable while keeping char type, too.</p>\n<p>For now, most C/C++ functions use char and I understand both languages much better now, so I use char in most cases.</p>\n", "OwnerUserId": "34065", "Id": "653353", "PostTypeId": "2", "OwnerDisplayName": "schnaader", "Score": "0", "CreationDate": "2009-03-17T08:03:08.467", "LastActivityDate": "2009-03-17T08:03:08.467"}, "653349": {"ParentId": "653336", "CommentCount": "1", "Body": "<p>It is better to define it as unsigned char. Infact Win32 type BYTE is defined as unsigned char. There is no difference between C &amp; C++ between this. </p>\n", "OwnerUserId": "39742", "Id": "653349", "PostTypeId": "2", "OwnerDisplayName": "Naveen", "Score": "4", "CreationDate": "2009-03-17T08:01:18.877", "LastActivityDate": "2009-03-17T08:01:18.877"}});