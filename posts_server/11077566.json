post_cb({"11079613": {"ParentId": "11077566", "CommentCount": "14", "Body": "<p>The const feature merely helps against accidental misuse.  It is not designed to prevent dedicated software hacking.  It is the same as private and protected membership, someone could always take the address of the object and increment along the memory to access class internals, there is no way to stop it.</p>\n<p>So, yes you can get around const.  If nothing else you can simply change the object at the memory level but this does not mean const is broken.</p>\n", "OwnerUserId": "861970", "PostTypeId": "2", "Id": "11079613", "Score": "0", "CreationDate": "2012-06-18T08:56:26.427", "LastActivityDate": "2012-06-18T08:56:26.427"}, "11077782": {"ParentId": "11077566", "PostTypeId": "2", "CommentCount": "31", "Body": "<p>The oops() method isn't allowed to change the constness of the object. Furthermore it doesn't do it. Its your anonymous function that does it. This anonymous function isn't in the context of the object, but in the context of the main() method which is allowed to modify the object.</p>\n<p>Your anonymous function doesn't change the this pointer of oops() (which is defined as const and therefore can't be changed) and also in no way derives some non-const variable from this this-pointer. Itself doesn't have any this-pointer. It just ignores the this-pointer and changes the bc variable of the main context (which is kind of passed as parameter to your closure). This variable is not const and therefore can be changed. You could also pass any anonymous function changing a completely unrelated object. This function doesn't know, that its changing the object that stores it.</p>\n<p>If you would declare it as</p>\n<pre><code>const BreakConst bc = ...\n</code></pre>\n<p>then the main function also would handle it as const object and couldn't change it.</p>\n<p>Edit:\n<strong>In other words: The const attribute is bound to the concrete l-value (reference) accessing the object. It's not bound to the object itself.</strong></p>\n", "OwnerUserId": "829568", "LastEditorUserId": "829568", "LastEditDate": "2012-06-18T06:47:48.067", "Id": "11077782", "Score": "12", "CreationDate": "2012-06-18T06:20:34.007", "LastActivityDate": "2012-06-18T06:47:48.067"}, "11079066": {"ParentId": "11077566", "CommentCount": "0", "Body": "<p>The issue is one of logical const versus bitwise const.  The compiler\ndoesn't know anything about the logical meaning of your program, and\nonly enforces bitwise const.  It's up to you to implement logical const.\nThis means that in cases like you show, if the pointed to memory is\nlogically part of the object, you should refrain from modifying it in a\nconst function, even if the compiler will let you (since it isn't part\nof the bitwise image of the object).  This may also mean that if part of\nthe bitwise image of the object isn't part of the logical value of the\nobject (e.g. an embedded reference count, or cached values), you make it\n<code>mutable</code>, or even cast away const, in cases where you modify it without\nmodifying the logical value of the object. </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "11079066", "Score": "2", "CreationDate": "2012-06-18T08:10:48.483", "LastActivityDate": "2012-06-18T08:10:48.483"}, "11077566": {"CommentCount": "9", "ViewCount": "777", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-06-18T05:57:07.137", "LastActivityDate": "2012-06-18T20:10:43.387", "Title": "Does this code subvert the C++ type system?", "FavoriteCount": "4", "LastEditDate": "2017-05-23T11:49:11.397", "Id": "11077566", "Score": "20", "Body": "<p>I understand that having a <code>const</code> method in C++ means that an object is read-only through that method, but that it may still change otherwise.</p>\n<p>However, this code apparently changes an object through a <code>const</code> reference (i.e. through a <code>const</code> method).</p>\n<p>Is this code legal in C++?</p>\n<p>If so: Is it breaking the <code>const</code>-ness of the type system? Why/why not?</p>\n<p>If not: Why not?</p>\n<h3>Note 1: I have edited the example a bit, so answers might be referring to older examples.</h3>\n<h3>Edit 2: Apparently you don't even need C++11, so I removed that dependency.</h3>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct DoBadThings { int *p; void oops() const { ++*p; } };\n\nstruct BreakConst\n{\n    int n;\n    DoBadThings bad;\n    BreakConst() { n = 0; bad.p = &amp;n; } \n    void oops() const { bad.oops(); }  // can't change itself... or can it?\n};\n\nint main()\n{\n    const BreakConst bc;\n    cout &lt;&lt; bc.n &lt;&lt; endl;   // 0\n    bc.oops();              // O:)\n    cout &lt;&lt; bc.n &lt;&lt; endl;   // 1\n\n    return 0;\n}\n</code></pre>\n<h3>Update:</h3>\n<p>I have migrated the lambda to the constructor's initialization list, since doing so allows me to subsequently say <code>const BreakConst bc;</code>, which -- because <code>bc</code> <em>itself</em> is now const (instead of merely the pointer) -- would seem to imply (<a href=\"https://stackoverflow.com/a/2271055/541686\">by Stroustrup</a>) that modifying <code>bc</code> in any way after construction should result in undefined behavior, even though the constructor and the caller would have no way of knowing this without seeing each others' definitions.</p>\n", "Tags": "<c++><const><const-correctness><aliasing>", "OwnerUserId": "541686", "AnswerCount": "5"}, "11077887": {"ParentId": "11077566", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I already saw something similar. Basically you invoke a cost function that invoke something else that modifies the object without knowing it.</p>\n<p>Consider this as well:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B;\n\nclass A\n{\n    friend class B;\n    B* pb;\n    int val;\npublic:\n    A(B&amp; b); \n    void callinc() const;\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; s, const A&amp; a)\n    { return s &lt;&lt; \"A value is \" &lt;&lt; a.val; }\n};\n\nclass B\n{\n    friend class A;\n    A* pa;\npublic:\n    void incval() const { ++pa-&gt;val; }\n};\n\ninline A::A(B&amp; b) :pb(&amp;b), val() { pb-&gt;pa = this; }\ninline void A::callinc() const { pb-&gt;incval(); }\n\n\nint main()\n{\n    B b;\n    const A a(b);  // EDIT: WAS `A a(b)`\n    cout &lt;&lt; a &lt;&lt; endl;\n    a.callinc();\n    cout &lt;&lt; a &lt;&lt; endl;\n}\n</code></pre>\n<p>This is not C++11, but does the same:\nThe point is that <strong>const is not transitive</strong>. </p>\n<p><code>callinc()</code> doesn't change itself <code>a</code> and <code>incval</code> doesn't change <code>b</code>.\nNote that in <code>main</code> you can even declare <code>const A a(b);</code> instead of <code>A a(b);</code> and everything compile the same.</p>\n<p>This works from decades, and in your sample you're just doing the same: simply you replaced class B with a lambda.</p>\n<p><strong>EDIT</strong></p>\n<p>Changed the main() to reflect the comment.</p>\n", "OwnerUserId": "924727", "LastEditorUserId": "924727", "LastEditDate": "2012-06-18T20:10:43.387", "Id": "11077887", "Score": "3", "CreationDate": "2012-06-18T06:31:17.180", "LastActivityDate": "2012-06-18T20:10:43.387"}, "bq_ids": {"n4140": {"so_11077566_11077786_1": {"section_id": 5433, "quality": 0.8333333333333334, "length": 15}, "so_11077566_11077786_0": {"section_id": 5432, "quality": 0.8709677419354839, "length": 27}}, "n3337": {"so_11077566_11077786_1": {"section_id": 5228, "quality": 0.8333333333333334, "length": 15}, "so_11077566_11077786_0": {"section_id": 5227, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_11077566_11077786_1": {"section_id": 6861, "quality": 0.8333333333333334, "length": 15}, "so_11077566_11077786_0": {"section_id": 6860, "quality": 0.8709677419354839, "length": 27}}}, "11077786": {"ParentId": "11077566", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You code is correct, because you <strong>don't use the const reference to modify the object</strong>. The lambda function uses completely different reference, which just happen to be pointing to the same object.</p>\n<p>In the general, such cases does not subvert the type system, because the type system in C++ does not formally guarantee, that you can't modify the const object or the const reference. However modification of the const object is the undefined behaviour.</p>\n<p><em>From [7.1.6.1] The cv-qualifiers</em>:</p>\n<blockquote>\n<p id=\"so_11077566_11077786_0\">A pointer or reference to a cv-quali\ufb01ed type need not actually point\n  or refer to a cv-quali\ufb01ed object, but it is treated as if it does; a\n  const-quali\ufb01ed access path cannot be used to modify an object even if\n  the object referenced is a non-const object and can be modi\ufb01ed through\n  some other access path.</p>\n<p id=\"so_11077566_11077786_1\">Except that any class member declared mutable (7.1.1) can be modi\ufb01ed,\n  any attempt to modify a const object during its lifetime (3.8) results\n  in unde\ufb01ned behavior.</p>\n</blockquote>\n", "OwnerUserId": "13767", "LastEditorUserId": "13767", "LastEditDate": "2012-06-18T06:45:58.377", "Id": "11077786", "Score": "3", "CreationDate": "2012-06-18T06:20:49.713", "LastActivityDate": "2012-06-18T06:45:58.377"}});