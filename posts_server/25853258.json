post_cb({"25853300": {"Id": "25853300", "PostTypeId": "2", "Body": "<p><code>void</code> is an <em>incomplete</em> type - you can <em>only</em> declare pointers to them and use them in function signatures. Obviously, <code>extern Foo f;</code> <em>is</em> permitted because <code>struct Foo</code> <em>can</em> be defined in another compilation unit (and if it's <em>not</em> the error will be detected by the linker), but <code>void</code> can't ever be \"defined\" (and the compiler knows this, of course) so <code>void</code>'s quite special in this case. </p>\n", "LastEditorUserId": "1312406", "LastActivityDate": "2014-09-15T23:30:21.460", "Score": "2", "CreationDate": "2014-09-15T17:13:12.530", "ParentId": "25853258", "CommentCount": "4", "OwnerUserId": "1312406", "LastEditDate": "2014-09-15T23:30:21.460"}, "25853285": {"Id": "25853285", "PostTypeId": "2", "Body": "<p>\"void type is an incomplete type\"</p>\n<p>You can't create variables of any incomplete type</p>\n<p>\"...that cannot be completed\"</p>\n<p>While your example of <code>extern</code> incomplete struct can be completed at some later point, the compiler knows that any declaration of type <code>void</code> can never be completed.</p>\n", "LastEditorUserId": "637801", "LastActivityDate": "2014-09-15T17:21:10.130", "Score": "9", "CreationDate": "2014-09-15T17:12:12.357", "ParentId": "25853258", "CommentCount": "2", "OwnerUserId": "637801", "LastEditDate": "2014-09-15T17:21:10.130"}, "25853661": {"Id": "25853661", "PostTypeId": "2", "Body": "<p>You cannot declare a variable of type <code>void</code> because variables must have object type or be references, <code>extern void f;</code> doesn't declare a reference, and <code>void</code> is not an <em>object type</em>:</p>\n<p>Section 3 <code>[basic]</code> says that</p>\n<blockquote>\n<p id=\"so_25853258_25853661_0\">A <em>variable</em> is introduced by the declaration of a reference other than a non-static data member or of an object.</p>\n</blockquote>\n<p>Section 3.9 <code>[basic.types]</code> says that</p>\n<blockquote>\n<p id=\"so_25853258_25853661_1\">An <em>object type</em> is a (possibly <em>cv-qualified</em>) type that is not a function type, not a reference type, and not a <code>void</code> type.</p>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-09-15T18:52:55.087", "Score": "20", "CreationDate": "2014-09-15T17:36:25.840", "ParentId": "25853258", "CommentCount": "8", "OwnerUserId": "103167", "LastEditDate": "2014-09-15T18:52:55.087"}, "25854076": {"Id": "25854076", "PostTypeId": "2", "Body": "<p><strong>[edit]</strong> The answer below makes valid observations, but they're contradicting. As these might be valuable, I'll not delete them, but see Ben Voight's answer and the comments there for a more straightforward approach.</p>\n<p>Your observations about <code>extern</code> declarations are specifically allowed by 7.1.1/8: </p>\n<blockquote>\n<p id=\"so_25853258_25854076_0\">The name of a declared but undefined class can be used in an extern declaration. Such a declaration can only be used in ways that do not require a complete class type.</p>\n</blockquote>\n<p><code>void</code> is not a \"declared but undefined class\", and there's no other exception in 7.1.1 which applies.</p>\n<p>Additionally, 3.9/5 is fairly explicit that it is in fact allowed: </p>\n<blockquote>\n<p id=\"so_25853258_25854076_1\">A class that has been <strong>declared but not defined</strong>, an enumeration type in certain contexts (7.2), or an array of unknown size or of incomplete element type, is an incompletely-defined object type. [45] Incompletely defined object types and the void types are incomplete types (3.9.1). Objects shall not be <strong>defined</strong> to have an incomplete type.</p>\n</blockquote>\n<p><em>Emphasis mine</em>. This part of the standard is quite specific about the differences between definitions and declarations, so by omission it specifies that declarations <strong>are</strong> allowed. </p>\n", "LastEditorUserId": "15416", "LastActivityDate": "2014-09-15T20:23:47.543", "Score": "3", "CreationDate": "2014-09-15T18:02:58.570", "ParentId": "25853258", "CommentCount": "4", "OwnerUserId": "15416", "LastEditDate": "2014-09-15T20:23:47.543"}, "bq_ids": {"n4140": {"so_25853258_25853661_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7206}, "so_25853258_25854076_1": {"length": 29, "quality": 0.90625, "section_id": 7203}, "so_25853258_25854076_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5398}, "so_25853258_25853661_0": {"length": 9, "quality": 0.9, "section_id": 7029}, "so_25853258_25853258_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 7218}}, "n3337": {"so_25853258_25853661_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6950}, "so_25853258_25853661_0": {"length": 9, "quality": 0.9, "section_id": 6775}, "so_25853258_25854076_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5193}, "so_25853258_25854076_1": {"length": 25, "quality": 0.78125, "section_id": 6947}, "so_25853258_25853258_0": {"length": 48, "quality": 0.8727272727272727, "section_id": 6962}}, "n4659": {"so_25853258_25853661_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 4058}, "so_25853258_25853661_0": {"length": 9, "quality": 0.9, "section_id": 8526}, "so_25853258_25854076_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6823}, "so_25853258_25853258_0": {"length": 39, "quality": 0.7090909090909091, "section_id": 8727}, "so_25853258_25854076_1": {"length": 24, "quality": 0.75, "section_id": 8712}}}, "25853258": {"ViewCount": "12059", "Body": "<p>I'm looking for a <em>formal</em> explanation of that fact in the Standard.\nI've found what 3.9.1/9 says and trying to give an explanation used that section.</p>\n<p><em>Section 3.9.1/9, N3797</em>:</p>\n<blockquote>\n<p id=\"so_25853258_25853258_0\"><em>The void type has an empty set of values.</em> The void type is an\n  incomplete type that cannot be completed. It is used as the return\n  type for functions that do not return a value. Any expression can be\n  explicitly converted to type cv void (5.4). An expression of type void\n  shall be used only as an expression statement (6.2), as an operand of\n  a comma expression (5.18), as a second or third operand of ?: (5.16),\n  as the operand of typeid, noexcept, or decltype, as the expression in\n  a return statement (6.6.3) for a function with the return type void,\n  or as the operand of an explicit conversion to type cv void.</p>\n</blockquote>\n<p>I don't understand how it implies from the fact that the void type has an empty set of values?</p>\n<p>Suppose that type T has an empty set of values. Why does compiler throw an error when it come across the following line:</p>\n<pre><code>extern T v; \n</code></pre>\n<p>We can decalre a variable of incomplete type in the following way:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nstruct Foo;\n\nextern Foo f; //OK!\n\nint main()\n{\n}\n</code></pre>\n<p>and it works fine</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/81687d46d14e3613\"><strong>DEMO</strong></a></p>\n<p>It cannot be done on a void type</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nextern void f; //compile-time error\n\nint main()\n{\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c4bf9c45ca6cdf7b\"><strong>DEMO</strong></a></p>\n", "AcceptedAnswerId": "25853661", "Title": "Why can't we declare a variable of type void?", "CreationDate": "2014-09-15T17:10:14.473", "LastActivityDate": "2015-04-12T17:03:14.643", "CommentCount": "19", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-09-15T17:30:16.547", "OwnerDisplayName": "user2953119", "LastEditorUserId": "241536", "Id": "25853258", "Score": "33", "Tags": "<c++><language-lawyer><void>", "AnswerCount": "7"}, "25853308": {"Id": "25853308", "PostTypeId": "2", "Body": "<p>If the variable has an empty set of values, it can't be used for anything.</p>\n<p>You can't assign to it, because there are no possible values to assign.</p>\n<p>You can't access it, because you never assigned to it, so it has an indeterminate value.</p>\n<p>Since there are no possible values, there's no size of the variable.</p>\n<p><code>void</code> is just used as a placeholder in variable places. It's used as a return type to indicate that the function doesn't return a value. It's used in <code>C</code> in the argument list to indicate that the function takes no arguments (to resolve an ambiguity from the pre-prototype version of the language). And it's used with pointer declarations to create generic pointers that can be translated to any other pointer type. There's no such analogous use for it in variable declarations.</p>\n", "LastActivityDate": "2014-09-15T17:13:30.357", "CommentCount": "5", "CreationDate": "2014-09-15T17:13:30.357", "ParentId": "25853258", "Score": "2", "OwnerUserId": "1491895"}, "25857507": {"Id": "25857507", "PostTypeId": "2", "Body": "<p>Because C and C++ assume that any objects may be compared for identity by comparing their addresses, they must ensure that all objects have fixed non-zero size.  Were it not for that requirement, there are in fact many cases where it would be somewhat useful to declare zero-sized objects [e.g. in code which uses templates which contain fields that will sometimes be useful and sometimes not, or as a means of forcing a structure to be padded to a certain alignment requiring that it contain an element requiring such alignment].  As it is, however, zero-size types would be inconsistent with fact that the rule specifying that every object has a unique address includes no exception which would allow for the existence of zero-sized objects that could share an address.</p>\n<p>Even if zero-size objects were permissible, however, a \"pointer to unknown object\" should not be the same as a \"pointer to a zero-size object\".  Given that the type <code>void*</code> is used for the former, that would imply that something else should be used for the latter, which would in turn imply that something other than <code>void</code> should be the type of thing to which a zero-sized object points.</p>\n", "LastActivityDate": "2014-09-15T21:52:49.960", "CommentCount": "6", "CreationDate": "2014-09-15T21:52:49.960", "ParentId": "25853258", "Score": "2", "OwnerUserId": "363751"}, "29592081": {"Id": "29592081", "PostTypeId": "2", "Body": "<p>Well - I really don't see the rationale behind this. It's going to be great if this way we can declare a variable with unknown type. Something like 'void *' and arrays of unknown size. Imagine code like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nextern void f;\n\nint main()\n{\n    cout &lt;&lt; (int &amp;)f &lt;&lt; endl; //cout 'f' as it was integer\n}\n\nstruct {\n    int a;\n    double b;\n} f{};\n</code></pre>\n<p>You can now actually do something similar with arrays:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nstruct Foo;\n\nextern int arr[];\n\nint main()\n{\n    cout &lt;&lt; arr[2] &lt;&lt; endl;\n}\n\nint arr[4]{};\n</code></pre>\n<p>Life <a href=\"http://melpon.org/wandbox/permlink/7j0YBa2OyEwqbArh\" rel=\"nofollow\">example</a>.</p>\n", "LastActivityDate": "2015-04-12T17:03:14.643", "CommentCount": "0", "CreationDate": "2015-04-12T17:03:14.643", "ParentId": "25853258", "Score": "0", "OwnerUserId": "4031604"}});