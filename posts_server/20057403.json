post_cb({"20057403": {"ViewCount": "778", "Body": "<p>I am watching Scott Meyer's video \"The Universal Reference/Overloading Collision Conundrum\", where he gives an example of what not to do:</p>\n<pre><code>class MessedUp {\npublic:\n    template&lt;typename T&gt;\n    void doWork(const T&amp; param) { std::cout &lt;&lt; \"doWork(const T&amp; param)\" &lt;&lt; std::endl; }\n\n    template&lt;typename T&gt;\n    void doWork(T&amp;&amp; param) { std::cout &lt;&lt; \"doWork(T&amp;&amp; param)\" &lt;&lt; std::endl; }\n\n};\n\n.... //somewhere in the main\n\nMessedUp m;\nint w = 10;\nconst int cw = 20;\n\nm.doWork(cw); // calls doWork(const T&amp; param) as expected \nm.doWork(std::move(cw)); // Calls doWork(T&amp;&amp; param)\n</code></pre>\n<p>I am curious as to why compiler chose <code>doWork(T&amp;&amp; param)</code> rather than <code>doWork(const T&amp; param)</code> during Template Overload resolution. As far as I know, <code>const</code> objects can't be moved.</p>\n", "AcceptedAnswerId": "20057957", "Title": "Moving const and overloaded Universal Reference in C++", "CreationDate": "2013-11-18T20:38:48.820", "Id": "20057403", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-11-18T21:19:31.613", "Score": "1", "OwnerUserId": "465292", "Tags": "<c++><c++11>", "AnswerCount": "4"}, "20057957": {"Id": "20057957", "PostTypeId": "2", "Body": "<p>After template type deduction and substitution, the two overloads become:</p>\n<pre><code>//template&lt;typename T&gt;\nvoid doWork(const int&amp; param) { std::cout &lt;&lt; \"doWork(const T&amp; param)\" &lt;&lt; std::endl; }\n\n//template&lt;typename T&gt;\nvoid doWork(const int&amp;&amp; param) { std::cout &lt;&lt; \"doWork(T&amp;&amp; param)\" &lt;&lt; std::endl; }\n</code></pre>\n<p>Note how <code>T</code> in the second overload has been deduced to <code>const int</code>.</p>\n<p>Now, what happens is normal overload resolution: We compare the implicit conversion sequences required to convert the argument expression <code>std::move(cw)</code> (which is an xvalue of type <code>const int</code>) to the parameter types. Both rank as Exact Matches, so we have to look at the tie-breakers in [over.ics.rank]/3 and compare the two implicit conversion sequences <code>S1</code> and <code>S2</code> (a reference binding here is a conversion sequence):</p>\n<blockquote>\n<p id=\"so_20057403_20057957_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence <code>S2</code> if\n  [...]</p>\n<ul>\n<li><code>S1</code> and <code>S2</code> are reference bindings [...], and <code>S1</code> binds an rvalue reference to an rvalue and <code>S2</code> binds an lvalue reference.</li>\n</ul>\n</blockquote>\n<p>As an xvalue <em>is</em> an rvalue (and a glvalue), this point applies, and the second overload is chosen.</p>\n", "LastEditorUserId": "420683", "LastActivityDate": "2013-11-18T21:18:06.123", "Score": "4", "CreationDate": "2013-11-18T21:09:49.763", "ParentId": "20057403", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2013-11-18T21:18:06.123"}, "20057914": {"Id": "20057914", "PostTypeId": "2", "Body": "<p>What is happening is that <code>doWork(T&amp;&amp; param)</code> is being called with <code>T = const int</code>, because that is a perfect match (instead of a conversion to lvalue).</p>\n<p>If you had trued to move the object, it would indeed have failed because const objects can't be moved.</p>\n", "LastActivityDate": "2013-11-18T21:07:33.177", "CommentCount": "2", "CreationDate": "2013-11-18T21:07:33.177", "ParentId": "20057403", "Score": "1", "OwnerUserId": "1082038"}, "bq_ids": {"n4140": {"so_20057403_20057957_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_20057403_20057957_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_20057403_20057957_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "20057634": {"Id": "20057634", "PostTypeId": "2", "Body": "<p><code>&amp;&amp;</code> are useful to determine temporary rvalues from non-rvalue. So, you can steal the resource safely.</p>\n<p>When you use <code>std::move</code> it casts the type to a rvalue and compiler will uses <code>&amp;&amp;</code> overload.</p>\n", "LastActivityDate": "2013-11-18T20:51:29.880", "CommentCount": "0", "CreationDate": "2013-11-18T20:51:29.880", "ParentId": "20057403", "Score": "1", "OwnerUserId": "952747"}, "20057502": {"Id": "20057502", "PostTypeId": "2", "Body": "<p><code>&amp;&amp;</code> does not mean move, it means rvalue reference.  rvalue references will only bind to temporary(anonymous) objects, or objects cast to appear to be temporary objects by functions like <code>std::move</code> or <code>std::forward</code>, or objects automatically marked by the compiler to be temporary like locals returned from function on simple <code>return X;</code> lines.</p>\n<p>You can have an rvalue reference to a <code>const</code> object.  When this happens, you cannot move (unless <code>mutable</code> state can be moved), but it is still an rvalue reference.</p>\n<p>Now, <code>T&amp;&amp;</code> can bind to an lvalue reference if <code>T</code> is an lvalue reference, so in type deduction context <code>T&amp;&amp;</code> can be called a universal reference.  So one of the real problems with the above design is that <code>m.doWork(w)</code> will also bind to <code>T&amp;&amp;</code> with <code>T=int&amp;</code>.</p>\n<p>In overload resolution, a function that takes a <code>template&lt;typename T&gt; void foo(T&amp;&amp;)</code> with <code>T=foo&amp;</code> be considered to be a worse match than <code>template&lt;typename T&gt; void foo(T&amp;)</code> with <code>T=foo</code> if everything else is equal: but in your case, there is no <code>T</code> such that <code>foo(T const&amp;)</code> is a <code>foo(T const&amp;&amp;)</code>.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2013-11-18T21:19:31.613", "Score": "4", "CreationDate": "2013-11-18T20:44:12.337", "ParentId": "20057403", "CommentCount": "6", "OwnerUserId": "1774667", "LastEditDate": "2013-11-18T21:19:31.613"}});