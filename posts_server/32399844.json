post_cb({"bq_ids": {"n4140": {"so_32399844_32399993_0": {"length": 22, "quality": 0.88, "section_id": 190}}, "n3337": {"so_32399844_32399993_0": {"length": 22, "quality": 0.88, "section_id": 184}}, "n4659": {"so_32399844_32399993_0": {"length": 24, "quality": 0.96, "section_id": 195}}}, "32399998": {"Id": "32399998", "PostTypeId": "2", "Body": "<p>In the second case, the <code>Base</code> is a template and someone might add specializations for the template, all with different member variables. The compiler cannot know until it sees what <code>T</code> is.</p>\n<p>There might also be a global <code>arr</code> that could fit. You can help the compiler by using <code>this-&gt;arr[0]</code> to indicate that it always is a member variable.</p>\n", "LastActivityDate": "2015-09-04T13:59:31.040", "CommentCount": "0", "CreationDate": "2015-09-04T13:59:31.040", "ParentId": "32399844", "Score": "1", "OwnerUserId": "597607"}, "32399844": {"ViewCount": "88", "Body": "<p>Let's look at this simple code sample including a base class and a class derived from Base, which needs the address of a base class member in its constructor.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;stdio.h&gt;\n\nclass Base\n{\nprotected:\n  std::vector&lt;uint32_t&gt; arr;\npublic:\n  Base(std::vector&lt;uint32_t&gt; arr_in): arr(arr_in) {}\n};\n\nclass Derived: public Base\n{\nprivate:\n  uint32_t *parr;\npublic:\n  Derived(std::vector&lt;uint32_t&gt; arr_in): Base(arr_in)\n  {\n    parr = &amp;arr[0];\n  }\n\n  uint32_t *get_parr();\n};\n\nuint32_t *Derived::get_parr(void)\n{\n  return parr;\n}\n\nint main()\n{\n  std::vector&lt;uint32_t&gt; myarr(3, 1);\n  Derived myderived(myarr);\n  printf(\"myderived.myarr adress = %p\", myderived.get_parr());\n}\n</code></pre>\n<p>Since the constructor of the derived class calls the base class constructor first and only then executes its code block, the members of the base class can already be accessed. So everything works fine.</p>\n<p>Now I change the code sample so that my two classes are templates.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;stdio.h&gt;\n\ntemplate&lt;typename T&gt;\nclass Base\n{\nprotected:\n  std::vector&lt;T&gt; arr;\npublic:\n  Base(std::vector&lt;T&gt; arr_in): arr(arr_in) {}\n};\n\ntemplate&lt;typename T&gt;\nclass Derived: public Base&lt;T&gt;\n{\nprivate:\n  T *parr;\npublic:\n  Derived(std::vector&lt;T&gt; arr_in): Base&lt;T&gt;(arr_in)\n  {\n    parr = &amp;arr[0];\n  }\n\n  T *get_parr();\n};\n\ntemplate&lt;typename T&gt;\nT *Derived&lt;T&gt;::get_parr(void)\n{\n  return parr;\n}\n\nint main()\n{\n  std::vector&lt;uint32_t&gt; myarr(3, 1);\n  Derived&lt;uint32_t&gt; myderived(myarr);\n  printf(\"myderived.myarr adress = %p\", myderived.get_parr() );\n}\n</code></pre>\n<p>But this second sample gives me the following error message upon compiling:</p>\n<pre><code>class_temp.cpp: In constructor \u2018Derived&lt;T&gt;::Derived(std::vector&lt;T&gt;)\u2019:\nclass_temp.cpp:23:13: error: \u2018arr\u2019 was not declared in this scope\n     parr = &amp;arr[0];\n</code></pre>\n<p>So why is it that in the second sample with template classes the derived class constructor doesn't know about the base class member?\nOr am I doing something wrong here?</p>\n<p>Thank you.</p>\n", "AcceptedAnswerId": "32399993", "Title": "Accessing variables from base template class in derived class constructor in C++", "CreationDate": "2015-09-04T13:52:27.353", "Id": "32399844", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-09-04T14:12:21.483", "Score": "2", "OwnerUserId": "4487588", "Tags": "<c++><class><templates><inheritance><constructor>", "AnswerCount": "2"}, "32399993": {"Id": "32399993", "PostTypeId": "2", "Body": "<p><code>arr</code> is a dependent name now. It depends on <code>T</code>. What if there is some <code>T</code> for which <code>Base&lt;T&gt;</code> is specialized to not have an <code>arr</code>? Specifically, from [temp.dep]:</p>\n<blockquote>\n<p id=\"so_32399844_32399993_0\">In the definition of a class or class template, the scope of a dependent base class (14.6.2.1) <strong>is not examined\n  during unqualified name lookup</strong> either at the point of definition of the class template or member or during\n  an instantiation of the class template or member.</p>\n</blockquote>\n<p><code>Base&lt;T&gt;</code> is a dependent base class - it depends on the template parameter <code>T</code>, so its scope is not examined during <em>unqualified</em> name lookup. The way around this is to use <em>qualified</em> name lookup. That is, either the class name:</p>\n<pre><code>parr = &amp;Base&lt;T&gt;::arr[0];\n</code></pre>\n<p>or just with <code>this</code>:</p>\n<pre><code>parr = &amp;this-&gt;arr[0];\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-09-04T14:12:21.483", "Score": "5", "CreationDate": "2015-09-04T13:59:21.673", "ParentId": "32399844", "CommentCount": "3", "OwnerUserId": "2069064", "LastEditDate": "2015-09-04T14:12:21.483"}});