post_cb({"46253990": {"CommentCount": "2", "ViewCount": "387", "PostTypeId": "1", "LastEditorUserId": "4324224", "CreationDate": "2017-09-16T12:37:30.477", "LastActivityDate": "2017-09-18T15:13:41.377", "Title": "If structured bindings cannot be constexpr why can they be used in constexpr function?", "AcceptedAnswerId": "46261649", "LastEditDate": "2017-09-18T15:13:41.377", "Id": "46253990", "Score": "12", "Body": "<p>According to <a href=\"https://stackoverflow.com/a/41623008/4324224\">this answer</a> apparently there is no good reason why structured bindings are not allowed to be constexpr, yet the standard still forbids it. In this case, however, shouldn't the use of the structured bindings inside the constexpr function also be prohibited? Consider a simple snippet:</p>\n<pre><code>#include &lt;utility&gt;\n\nconstexpr int foo(std::pair&lt;int, int&gt; p) {\n    auto [a, b] = p;\n    return a;\n}\n\nint main() {\n    constexpr int a = foo({1, 2});\n    static_assert(a == 1);\n}\n</code></pre>\n<p>Both <a href=\"https://wandbox.org/permlink/LBrfxXKGRyNsotVm\" rel=\"noreferrer\">gcc</a> and <a href=\"https://wandbox.org/permlink/PNVgo770rBe0VlAy\" rel=\"noreferrer\">clang</a> does not cause trouble compiling the code. Is the code ill-formed either way or is this one actually allowed?</p>\n", "Tags": "<c++><language-lawyer><c++1z><constexpr><structured-bindings>", "OwnerUserId": "4324224", "AnswerCount": "2"}, "46261649": {"ParentId": "46253990", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In the case of function declaration, the <code>constexpr</code> specifier is an assertion made to the compiler that the function being declared may be evaluated in a <em>constant expression</em>, i.e. an expression that can be evaluated at compile-time. Nevertheless the object initialization inside a declaration does not need to have <code>constexpr</code> inside its declaration specifier to be a <em>constant expression</em>.</p>\n<p>Shorter: <code>constexpr</code> function may imply <em>constant expression</em> but <em>constant expression</em> initialization does not need that the associated declaration has a <code>constexpr</code> specifier.</p>\n<p>You can check this in the C++ standard [dcl.constexpr]:</p>\n<blockquote>\n<p id=\"so_46253990_46261649_0\">A call to a constexpr function produces the same result as a call to an equivalent non-constexpr function in\n  all respects except that</p>\n<p id=\"so_46253990_46261649_1\">\u2014 a call to a constexpr function can appear in a constant expression[...]</p>\n</blockquote>\n<p>This is the <strong>evaluation</strong> of an expression that determines if an expression is a\nconstant expression [expr.const]:</p>\n<blockquote>\n<p id=\"so_46253990_46261649_2\">An expression <em>e</em> is a core constant expression unless the <strong>evaluation</strong> of <em>e</em> [...] would evaluate one of the following <strong>expression</strong>[...]</p>\n</blockquote>\n<p>A declaration is not an <em>expression</em>, so an initialization of an object being declared is a <em>constant expression</em> irrespective of the presence or not of a <code>constexpr</code> specifier in the declaration. </p>\n<p>Finally, in [dcl.constexpr], it is specified that a <code>constexpr</code> function must be such that there exist parameters for which its body can be evaluated as a <em>constant expression</em>:</p>\n<blockquote>\n<p id=\"so_46253990_46261649_3\">For a constexpr function or constexpr constructor that is neither defaulted nor a template, if no argument\n  values exist such that an invocation of the function or constructor could be an evaluated subexpression of\n  a core constant expression (8.20), or, for a constructor, a constant initializer for some object (6.6.2), the\n  program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>When you declare <code>constexpr int a</code> the compiler expects <code>a</code> to be inialized by a constant expression and the expression <code>foo({1,2})</code> is a constant expression, so your code is well formed.</p>\n<p>PS: Nevertheless, declaration specifiers (static, thread_local=&gt;static) in the the declaration of function local variable implies that the function cannot be declared <code>constexpr</code>.</p>\n", "OwnerUserId": "5632316", "LastEditorUserId": "5632316", "LastEditDate": "2017-09-17T11:00:01.563", "Id": "46261649", "Score": "6", "CreationDate": "2017-09-17T07:20:20.387", "LastActivityDate": "2017-09-17T11:00:01.563"}, "46254087": {"ParentId": "46253990", "CommentCount": "2", "Body": "<p>There are <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow noreferrer\">several requirements that a <code>constexpr</code> function must meet</a>. There are some requirements for the body of a <code>constexpr</code> function, and the shown code does not appear to violate any of them. The key point is that there is no requirement that every statement in a function must be a <code>constexpr</code>. The only interesting requirement in question here, is this one:</p>\n<blockquote>\n<p id=\"so_46253990_46254087_0\">there exists at least one set of argument values such that an\n  invocation of the function could be an evaluated subexpression of a\n  core constant expression (for constructors, use in a constant\n  initializer is sufficient) (since C++14). No diagnostic is required\n  for a violation of this bullet.</p>\n</blockquote>\n<p>Note the last sentence. The compiler may, but is not required to, throw a red flag.</p>\n<p>The key requirement is merely that there is some assortment of parameter values to the function that results in a constant result from the function (and the function body meets the listed requirements). For example, the function might use a structured binding conditionally; but for some set of parameter values do something else, producing a constant result. This would tick this checkbox for a <code>constexpr</code> function.</p>\n<p>But, despite the sophistication of modern C++ compilers, they may not necessarily be capable of reaching this determination in every possible instance, so, in practice, it would be hard to enforce such a requirement, hence the compilers are permitted to just take this for granted.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "46254087", "Score": "1", "CreationDate": "2017-09-16T12:48:15.120", "LastActivityDate": "2017-09-16T12:48:15.120"}, "bq_ids": {"n4140": {"so_46253990_46261649_3": {"section_id": 5421, "quality": 0.625, "length": 20}, "so_46253990_46261649_2": {"section_id": 6185, "quality": 0.8, "length": 8}, "so_46253990_46261649_0": {"section_id": 5423, "quality": 1.0, "length": 13}, "so_46253990_46261649_1": {"section_id": 5423, "quality": 1.0, "length": 7}}, "n3337": {"so_46253990_46261649_0": {"section_id": 5218, "quality": 1.0, "length": 13}, "so_46253990_46261649_1": {"section_id": 5218, "quality": 1.0, "length": 7}}, "n4659": {"so_46253990_46261649_1": {"section_id": 6845, "quality": 1.0, "length": 7}, "so_46253990_46254087_0": {"section_id": 6843, "quality": 0.5555555555555556, "length": 15}, "so_46253990_46261649_0": {"section_id": 6845, "quality": 1.0, "length": 13}, "so_46253990_46261649_3": {"section_id": 6843, "quality": 0.90625, "length": 29}, "so_46253990_46261649_2": {"section_id": 7687, "quality": 0.8, "length": 8}}}});