post_cb({"bq_ids": {"n4140": {"so_33298375_33298417_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 599}, "so_33298375_33298417_2": {"length": 20, "quality": 1.0, "section_id": 599}, "so_33298375_33298417_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}}, "n3337": {"so_33298375_33298417_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 589}, "so_33298375_33298417_2": {"length": 20, "quality": 1.0, "section_id": 589}, "so_33298375_33298417_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}}, "n4659": {"so_33298375_33298417_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 622}, "so_33298375_33298417_2": {"length": 20, "quality": 1.0, "section_id": 622}, "so_33298375_33298417_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}}}, "33298417": {"Id": "33298417", "PostTypeId": "2", "Body": "<p>n3337 13.3.1.7/1</p>\n<blockquote>\n<p id=\"so_33298375_33298417_0\">When objects of non-aggregate class type T are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases:</p>\n<p id=\"so_33298375_33298417_1\">\u2014 Initially, the candidate functions are the initializer-list\n  constructors (8.5.4) of the class T and the argument list consists of\n  the initializer list as a single argument.</p>\n<p id=\"so_33298375_33298417_2\">\u2014 If no viable\n  initializer-list constructor is found, overload resolution is\n  performed again, where the candidate functions are all the\n  constructors of the class T and the argument list consists of the\n  elements of the initializer list.</p>\n</blockquote>\n<p><code>std::string</code> has many <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow\">constructors</a>. One of them, that receives <code>const char*</code>.</p>\n<p>So, firstly compiler will take <code>initializer_list</code> c-tor in overload-resolution, but it's not viable candidate, when <code>string</code> is constructed with <code>const char*</code>, then compiler will look at other constructors and choose the best one, that is </p>\n<pre><code>basic_string( const CharT* s,\n              const Allocator&amp; alloc = Allocator() );\n</code></pre>\n<p>You can check it with just simple example:</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n\nclass String\n{\npublic:\n   String(const std::initializer_list&lt;char&gt;&amp;) { std::cout &lt;&lt; \"init-list c-tor called\" &lt;&lt; std::endl; }\n   String(const char*) { std::cout &lt;&lt; \"const char* c-tor called\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n   String s{\"hello\"};\n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/OGpGFbGV30maokzG\" rel=\"nofollow\">Live version</a></p>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2015-10-23T09:09:50.740", "Score": "5", "CreationDate": "2015-10-23T08:55:01.460", "ParentId": "33298375", "CommentCount": "0", "OwnerUserId": "1498580", "LastEditDate": "2015-10-23T09:09:50.740"}, "33298375": {"ViewCount": "175", "Body": "<p>I can see that std::string has only one CTOR with <code>initializer_list</code>: <code>string (initializer_list&lt;char&gt; il);</code> So initializer list should work with chars, right? Why <code>std::string{\"some_str\"}</code> works, it gets <code>const char*</code>, right?</p>\n", "AcceptedAnswerId": "33298417", "Title": "Why std::string{\"const char ptr\"} works?", "CreationDate": "2015-10-23T08:52:51.823", "Id": "33298375", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-10-23T09:09:50.740", "Score": "0", "OwnerUserId": "163394", "Tags": "<c++><c++11><stdstring><initialization-list><uniform-initialization>", "AnswerCount": "1"}});