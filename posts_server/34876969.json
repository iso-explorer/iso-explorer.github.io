post_cb({"34877072": {"ParentId": "34876969", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The function can be passed as an argument to some other function or for example algorithm. In this case it is enough to specify only the first template argument if the both arguments of the function will have the same type. </p>\n<p>This makes the code more shorter and readable.</p>\n<p>Here is an artificial example.:)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;iterator&gt; \n#include &lt;functional&gt;\n\n\nint main()\n{\n    int a[] = { 1, 2, 3 };\n    int b[] = { 4, 5, 6 };\n\n    std::cout &lt;&lt; \"a: \";\n    for ( int x : a ) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b: \";\n    for ( int x : b ) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n\n    auto sum = std::inner_product( std::begin( a ), std::end( a ),\n                                   std::make_move_iterator( std::begin( b ) ), 0,\n                                   std::plus&lt;int&gt;(), std::exchange&lt;int&gt; );\n\n    std::cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"a: \";\n    for ( int x : a ) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The output is</p>\n<pre><code>a: 1 2 3 \nb: 4 5 6 \nsum = 6\na: 4 5 6 \n</code></pre>\n<p>Or the example could include a conversion </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;iterator&gt; \n#include &lt;functional&gt;\n\n\nint main()\n{\n    int a[] = { 1, 2, 3 };\n    double b[] = { 4.4, 5.5, 6.6 };\n\n    std::cout &lt;&lt; \"a: \";\n    for ( int x : a ) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b: \";\n    for ( double x : b ) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n\n    auto sum = std::inner_product( std::begin( a ), std::end( a ),\n                                   std::make_move_iterator( std::begin( b ) ), 0,\n                                   std::plus&lt;&gt;(), std::exchange&lt;int&gt; );\n\n    std::cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"a: \";\n    for ( int x : a ) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2016-01-19T13:14:59.920", "Id": "34877072", "Score": "9", "CreationDate": "2016-01-19T12:39:51.547", "LastActivityDate": "2016-01-19T13:14:59.920"}, "34876969": {"CommentCount": "0", "AcceptedAnswerId": "34877144", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2016-01-19T12:34:27.373", "LastActivityDate": "2016-01-19T21:57:22.643", "LastEditDate": "2016-01-19T16:01:11.757", "ViewCount": "850", "FavoriteCount": "2", "Title": "In std::exchange, why is the second template parameter defaulted?", "Id": "34876969", "Score": "33", "Body": "<p>The C++14 standard specifies the following declaration for <code>std::exchange</code>:</p>\n<pre><code>template &lt;class T, class U = T&gt;\nT std::exchange(T&amp; obj, U&amp;&amp; new_value);\n</code></pre>\n<p>I am wondering why <code>U</code> is defaulted to <code>T</code> since <code>U</code> can be found thanks to <code>new_value</code>. In what case, this would lead to a different result than:</p>\n<pre><code>template &lt;class T, class U&gt;\nT std::exchange(T&amp; obj, U&amp;&amp; new_value);\n</code></pre>\n", "Tags": "<c++><templates><stl><c++14><default-arguments>", "OwnerUserId": "882932", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34876969_34877144_7": {"section_id": 336, "quality": 0.9166666666666666, "length": 11}, "so_34876969_34877144_4": {"section_id": 335, "quality": 0.9818181818181818, "length": 54}, "so_34876969_34877144_6": {"section_id": 336, "quality": 0.9473684210526315, "length": 18}, "so_34876969_34877144_2": {"section_id": 297, "quality": 0.9772727272727273, "length": 43}}, "n3337": {"so_34876969_34877144_7": {"section_id": 326, "quality": 0.9166666666666666, "length": 11}, "so_34876969_34877144_4": {"section_id": 325, "quality": 0.9818181818181818, "length": 54}, "so_34876969_34877144_6": {"section_id": 326, "quality": 0.9473684210526315, "length": 18}, "so_34876969_34877144_2": {"section_id": 288, "quality": 0.7727272727272727, "length": 34}}, "n4659": {"so_34876969_34877144_7": {"section_id": 345, "quality": 0.9166666666666666, "length": 11}, "so_34876969_34877144_4": {"section_id": 344, "quality": 0.9818181818181818, "length": 54}, "so_34876969_34877144_6": {"section_id": 345, "quality": 0.9473684210526315, "length": 18}, "so_34876969_34877144_2": {"section_id": 304, "quality": 0.9772727272727273, "length": 43}}}, "34877144": {"ParentId": "34876969", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The <code>std::exchange</code> was proposed in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3511.html\"><strong>N3511</strong></a> <em>without</em> default template argument, and later <a href=\"https://isocpp.org/files/papers/n3608.html\"><strong>N3608</strong></a> with a default template argument. Note that in N3608 the following reasoning was provided:</p>\n<blockquote>\n<p id=\"so_34876969_34877144_0\">Giving the second template argument a default value fixes the\n  following two cases:</p>\n<pre><code>DefaultConstructible x = ...;\nif (exchange(x, {})) { ... }\n\nint (*fp)(int);\nint f(int);\ndouble f(double);\n/*...*/ exchange(fp, &amp;f) /*...*/\n</code></pre>\n</blockquote>\n<p>The first example's usefullness is of course that an untyped temporary <code>{}</code> will be deduced to <code>T</code>. The second example is more involved:</p>\n<blockquote>\n<p id=\"so_34876969_34877144_1\"><strong>14.8.2 Template argument deduction [temp.deduct]</strong></p>\n<p id=\"so_34876969_34877144_2\">5 The resulting substituted and adjusted function type is used as the\n  type of the function template for template argument deduction. <strong>If a\n  template argument has not been deduced and its corresponding template\n  parameter has a default argument, the template argument is determined\n  by substituting the template arguments determined for preceding\n  template parameters into the default argument.</strong> If the substitution\n  results in an invalid type, as described above, type deduction fails.</p>\n<p id=\"so_34876969_34877144_3\"><strong>14.8.2.5 Deducing template arguments from a type [temp.deduct.type]</strong></p>\n<p id=\"so_34876969_34877144_4\">4 In most cases, the types, templates, and non-type values that are\n  used to compose P participate in template argument deduction. That is,\n  they may be used to determine the value of a template argument, and\n  the value so determined must be consistent with the values determined\n  elsewhere. In certain contexts, however, the value does not\n  participate in type deduction, but instead uses the values of template\n  arguments that were either deduced elsewhere or explicitly specified.\n  <strong>If a template parameter is used only in non-deduced contexts and is\n  not explicitly specified, template argument deduction fails.</strong></p>\n<p id=\"so_34876969_34877144_5\">5 The non-deduced contexts are: </p>\n<p id=\"so_34876969_34877144_6\">(5.5) \u2014 A function parameter for which argument deduction cannot be\n  done because the associated function argument is a function, or <strong>a set\n  of overloaded functions</strong> (13.4), and one or more of the following\n  apply: </p>\n<p id=\"so_34876969_34877144_7\">(5.5.1) \u2014 <strong>more than one function matches the function parameter\n  type</strong> (resulting in an ambiguous deduction)</p>\n</blockquote>\n<p>In the second example, the template parameter <code>U</code> is only used in a non-deduced context because the two overloads <code>f(int)</code> and <code>f(double)</code> both can be matched to <code>U</code>. Hence, argument deduction does not take place, and <code>U</code> becomes the supplied default value of <code>T</code> (<code>int (*)(int)</code> in this case, so <code>f(int)</code> is selected).</p>\n<p>In addition, as explained by @VladfromMoscow, having a defaulted parameter allows for shorter code when passing <code>std::exchange&lt;T&gt;</code> (to a standard algorithm e.g.). </p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2016-01-19T21:57:22.643", "Id": "34877144", "Score": "36", "CreationDate": "2016-01-19T12:43:51.427", "LastActivityDate": "2016-01-19T21:57:22.643"}});