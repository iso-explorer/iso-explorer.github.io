post_cb({"38615436": {"CommentCount": "16", "ViewCount": "543", "PostTypeId": "1", "ClosedDate": "2016-07-27T14:38:08.667", "LastEditorUserId": "-1", "CreationDate": "2016-07-27T14:11:27.483", "LastActivityDate": "2016-07-27T15:29:50.140", "Title": "C/C++ nullptr dereference", "AcceptedAnswerId": "38615522", "LastEditDate": "2017-05-23T12:32:41.887", "Id": "38615436", "Score": "2", "Body": "<p>Since de-referencing <code>nullptr</code> (<code>NULL</code>) is an undefined behavior both in <code>C</code> and <code>C++</code>, I am wondering if expression <code>&amp;(*ptr)</code> is a valid one if ptr is <code>nullptr</code> (<code>NULL</code>).</p>\n<p>If it is also an undefined behavior, how does <a href=\"https://stackoverflow.com/a/142023\">OFFSETOF</a> macro in the linked answer work?</p>\n<p>I always thought that <code>ptr-&gt;field</code> is a shorthand for <code>(*ptr).field</code></p>\n<p>I think the answer to my question is similar in C and C++.</p>\n", "Tags": "<c++><c><null><nullptr>", "OwnerUserId": "779912", "AnswerCount": "2"}, "38616085": {"ParentId": "38615436", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_38615436_38616085_0\">If it is also an undefined behavior, how does <code>offsetof</code> work?</p>\n</blockquote>\n<p>Prefer using <a href=\"http://en.cppreference.com/w/cpp/types/offsetof\" rel=\"nofollow\">the standard <code>offsetof</code> macro</a>. Home-grown versions result in compiler warnings. Moreover:</p>\n<blockquote>\n<p id=\"so_38615436_38616085_1\"><code>offsetof</code> is required to work as specified above, even if unary <code>operator&amp;</code> is overloaded for any of the types involved. This cannot be implemented in standard C++ and requires compiler support.</p>\n</blockquote>\n<p><code>offsetof</code> is a <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Offsetof.html\" rel=\"nofollow\">built-in function in gcc</a>.</p>\n", "OwnerUserId": "412080", "LastEditorUserId": "412080", "LastEditDate": "2016-07-27T14:41:59.670", "Id": "38616085", "Score": "1", "CreationDate": "2016-07-27T14:37:00.333", "LastActivityDate": "2016-07-27T14:41:59.670"}, "38615522": {"ParentId": "38615436", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>TL;DR <code>&amp;(*(char*)0)</code> is well defined.</p>\n<p>The C++ standard doesn't say that indirection of null pointer by itself has UB. Current standard draft, <a href=\"http://eel.is/c++draft/expr.unary.op\" rel=\"nofollow\">[expr.unary.op]</a></p>\n<blockquote>\n<ol>\n<li><p id=\"so_38615436_38615522_0\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is \u201cpointer to T\u201d, the type of the result is \u201cT\u201d. [snip]</p></li>\n<li><p id=\"so_38615436_38615522_1\">The result of the unary &amp; operator is a pointer to its operand. The operand shall be an lvalue or a qualified-id. [snip]</p></li>\n</ol>\n</blockquote>\n<p>There is no UB unless the lvalue of the indirection expression is converted to an rvalue.</p>\n<hr>\n<p>The C standard is much more explicit. C11 standard draft \u00a76.5.3.2</p>\n<blockquote id=\"so_38615436_38615522_2\">\n<ol start=\"3\">\n<li>The unary &amp; operator yields the address of its operand. If the operand has type \"type\", the  result  has  type  \"pointer to type\". <strong>If the  operand  is  the  result  of  a unary * operator, neither  that  operator  nor  the &amp; operator  is  evaluated  and  the  result  is  as  if  both  were omitted</strong>, except  that  the  constraints  on  the  operators  still  apply  and  the  result  is  not  an lvalue.  Similarly, if the operand is the result of a [] operator, neither the &amp; operator nor the  unary * that  is  implied  by  the [] is  evaluated  and  the  result  is  as  if  the\n  &amp; operator were removed and the [] operator were changed to a + operator. Otherwise, the result is a pointer to the object or function designated by its operand.</li>\n</ol>\n</blockquote>\n</hr>", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-07-27T15:10:18.673", "Id": "38615522", "Score": "2", "CreationDate": "2016-07-27T14:15:30.883", "LastActivityDate": "2016-07-27T15:10:18.673"}, "bq_ids": {"n4140": {"so_38615436_38615522_1": {"section_id": 6066, "quality": 0.75, "length": 9}, "so_38615436_38615522_0": {"section_id": 6064, "quality": 0.8846153846153846, "length": 23}, "so_38615436_38616085_1": {"section_id": 6706, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_38615436_38615522_1": {"section_id": 5834, "quality": 0.75, "length": 9}, "so_38615436_38615522_0": {"section_id": 5832, "quality": 0.8846153846153846, "length": 23}, "so_38615436_38616085_1": {"section_id": 6461, "quality": 0.5882352941176471, "length": 10}}, "n4659": {"so_38615436_38615522_1": {"section_id": 7562, "quality": 0.75, "length": 9}, "so_38615436_38615522_0": {"section_id": 7560, "quality": 0.8846153846153846, "length": 23}, "so_38615436_38616085_1": {"section_id": 8181, "quality": 0.5882352941176471, "length": 10}}}});