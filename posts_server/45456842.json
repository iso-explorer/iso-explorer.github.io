post_cb({"45457872": {"ParentId": "45456842", "CommentCount": "1", "Body": "<p>GCC defaults <code>-std</code> to <code>gnu++14</code> (see <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Standards.html\" rel=\"nofollow noreferrer\">here</a>), which is C++14 with GNU extensions.</p>\n<p>Comparing the two with only <code>NAMEDARGS(...)</code> defined shows how the expansions differ:</p>\n<p><strong>Code</strong></p>\n<pre><code>#define NAMEDARGS(...) GETOVERRIDE(ignored, ##__VA_ARGS__, NAMEDARGS5, NAMEDARGS4, NAMEDARGS3, NAMEDARGS2, NAMEDARGS1, NAMEDARGS0)(__VA_ARGS__)\nNAMEDARGS()\n</code></pre>\n<p><strong>-std=gnu++14 -E</strong></p>\n<pre><code>GETOVERRIDE(ignored, NAMEDARGS5, NAMEDARGS4, NAMEDARGS3, NAMEDARGS2, NAMEDARGS1, NAMEDARGS0)()\n-------------------^\n</code></pre>\n<p><strong>-std=c++14 -E</strong></p>\n<pre><code>GETOVERRIDE(ignored,, NAMEDARGS5, NAMEDARGS4, NAMEDARGS3, NAMEDARGS2, NAMEDARGS1, NAMEDARGS0)()\n-------------------^^\n</code></pre>\n<p>I'm not an experienced standard reader, but I found the following two passages in <strong>[cpp.replace]</strong> which suggest that GCC is correct in both invocations:</p>\n<blockquote>\n<p id=\"so_45456842_45457872_0\">If the identifier-list in the macro definition does not end with an ellipsis, the number of arguments (including those arguments consisting of no preprocessing tokens) in an invocation of a function-like macro shall equal the number of parameters in the macro definition. <strong>Otherwise, there shall be more arguments in the invocation than there are parameters in the macro definition (excluding the ...).</strong> There shall exist a ) preprocessing token that terminates the invocation.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_45456842_45457872_1\">If there is a ... immediately preceding the ) in the function-like macro definition, then the trailing arguments, including any separating comma preprocessing tokens, are merged to form a single item: the variable arguments. <strong>The number of arguments so combined is such that, following merger, the number of arguments is one more than the number of parameters in the macro definition (excluding the ...).</strong></p>\n</blockquote>\n<p>It seems correct then that an empty <code>__VA_ARGS__</code> is expanded to a single empty argument.</p>\n<p>I can't find whether clang's behaviour here is intended.</p>\n", "OwnerUserId": "8274127", "PostTypeId": "2", "Id": "45457872", "Score": "2", "CreationDate": "2017-08-02T10:10:45.607", "LastActivityDate": "2017-08-02T10:10:45.607"}, "45456842": {"CommentCount": "0", "ViewCount": "68", "CreationDate": "2017-08-02T09:28:45.667", "LastActivityDate": "2017-08-02T10:10:45.607", "Title": "Weird behavior of variadic macro expansion with gcc and clang", "PostTypeId": "1", "Id": "45456842", "Score": "3", "Body": "<p>I'm writing a variadic dispatcher macro in C++, to call a different macro based on the number of arguments (from none up to 5) provided to the dispatcher. I came up with this solution:</p>\n<pre><code>#define GETOVERRIDE(_ignored, _1, _2, _3, _4, _5, NAME, ...) NAME\n#define NAMEDARGS(...) GETOVERRIDE(ignored, ##__VA_ARGS__, NAMEDARGS5, NAMEDARGS4, NAMEDARGS3, NAMEDARGS2, NAMEDARGS1, NAMEDARGS0)(__VA_ARGS__)\n</code></pre>\n<p>NAMEDARGS is the dispatcher macro; calling it with 1 argument will result in a call to NAMEDARGS1 which takes 1 argument, and so on (I don't provide the implementations of the various NAMEDARGS# since they are irrelevant in this context).</p>\n<p>I tested the code gcc 7.1.1, and I found a weird behavior of the gcc expansion when using the -std=c++14 flag. With this test code:</p>\n<pre><code>NAMEDARGS()\nNAMEDARGS(int)\nNAMEDARGS(int, float)\n</code></pre>\n<p>I get these expansions:</p>\n<pre><code>$ gcc -E testMacro.cpp\nNAMEDARGS0()\nNAMEDARGS1(int)\nNAMEDARGS2(int, float)\n\n$ gcc -E -std=c++14 testMacro.cpp\nNAMEDARGS1()\nNAMEDARGS1(int)\nNAMEDARGS2(int, float)\n</code></pre>\n<p>It seems that using the -std=c++14 flag the substitution of the zero-argument call fails, resulting in the call of the one-argument macro. I thought that this could be because the ##__VA_ARGS__ syntax is a GNU extension, thus not working with an ISO C++ preprocessor; however, when trying with clang 4.0.1 I obtain the desired expansion:</p>\n<pre><code>$ clang -E -std=c++14 testMacro.cpp\nNAMEDARGS0()\nNAMEDARGS1(int)\nNAMEDARGS2(int, float)\n</code></pre>\n<p>So I don't understand what's going on here. Does clang implement this gnu extension, accepting non-ISO code also with -std==c++14 unlike gcc? Or maybe the problem lies elsewhere? Thanks for the help.</p>\n", "Tags": "<c++><gcc><clang><variadic-macros>", "OwnerUserId": "1131907", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45456842_45457872_0": {"section_id": 514, "quality": 1.0, "length": 39}, "so_45456842_45457872_1": {"section_id": 522, "quality": 0.9459459459459459, "length": 35}}, "n3337": {"so_45456842_45457872_0": {"section_id": 505, "quality": 1.0, "length": 39}, "so_45456842_45457872_1": {"section_id": 513, "quality": 0.8918918918918919, "length": 33}}, "n4659": {"so_45456842_45457872_0": {"section_id": 535, "quality": 1.0, "length": 39}, "so_45456842_45457872_1": {"section_id": 543, "quality": 0.9459459459459459, "length": 35}}}});