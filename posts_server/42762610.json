post_cb({"42762786": {"ParentId": "42762610", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The integer constant <code>0x0FFF</code> is, like all integer constants, at least of type <code>int</code>. But it doesn't matter here.</p>\n<p>In the expression <code>code &amp; 0x0FFF</code>, both operands <code>code</code> and <code>0x0FFF</code> are subject to implicit integer promotion, <em>the integer promotion rules</em>. This applies to <em>small integer types</em>  such as <code>short</code>. So the <code>code</code>operand is always promoted to (at least) <code>int</code> regardless of the type of the other operand.</p>\n<p>Therefore you will get the very same issue if you do this:</p>\n<pre><code>unsigned short code = 0x12E0;\nunsigned short x = 0x0FFF;\ncode = code &amp; x;\n</code></pre>\n<p>The compiler probably suppresses the warnings in the first two rows since it is just simple assignment. But in the last row there's a more complex expression and integer overflow could potentially be an issue. Overall, compilers tend to be inconsistent with these kind of warnings, since they aren't mandatory.</p>\n<p>Pedantic but 100% safe code, free from implicit type conversions, would look like this:</p>\n<pre><code>code = (unsigned short) ((unsigned int)code &amp; 0x0FFFu);\n</code></pre>\n", "OwnerUserId": "584518", "LastEditorUserId": "584518", "LastEditDate": "2017-03-13T11:54:09.753", "Id": "42762786", "Score": "4", "CreationDate": "2017-03-13T11:42:02.957", "LastActivityDate": "2017-03-13T11:54:09.753"}, "42762610": {"CommentCount": "13", "ViewCount": "122", "PostTypeId": "1", "LastEditorUserId": "4774918", "CreationDate": "2017-03-13T11:31:52.710", "LastActivityDate": "2017-03-13T12:39:34.827", "Title": "why sizeof(0xF) is 4 bytes?", "AcceptedAnswerId": "42762786", "LastEditDate": "2017-03-13T12:39:34.827", "Id": "42762610", "Score": "-3", "Body": "<p>I have following code,</p>\n<pre><code>unsigned short code = 0x12E0;\ncode = code &amp; 0x0FFF;\n</code></pre>\n<p>In my CLion IDE, i am getting a warning that </p>\n<blockquote>\n<p id=\"so_42762610_42762610_0\">\"Values of type <code>int</code> may not fit into the receiver type <code>unsigned short</code>\"</p>\n</blockquote>\n<p>If I put it like <code>code &amp;= 0x0FFF;</code>, the warning is gone. </p>\n<p>Why it is taking <code>0x0FFF</code> as <code>int</code>? The <code>sizeof(0xF)</code> is <code>4</code>, can someone explain why?</p>\n", "Tags": "<c++><integer><sizeof>", "OwnerUserId": "3278966", "AnswerCount": "3"}, "42762659": {"ParentId": "42762610", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Without any specific suffix attached, an integer constant like <code>0x12E0</code> or <code>0x0FFF</code> is of type <code>int</code>. They will be categorized as \"hexadecimal constant\" due to the prefix of <code>0x</code>.</p>\n<p>Also, as mentioned in the <a href=\"https://stackoverflow.com/a/42762645/2173917\">other answer</a>, for an integer constant (to be specific, \"<em>Octal or Hexadecimal constant</em>\") with no explicit suffix, the type will be decided on based of the least <em>ranked</em> type in the below list</p>\n<blockquote id=\"so_42762610_42762659_0\">\n<ul>\n<li><code>int</code></li>\n<li><code>unsigned int</code></li>\n<li><code>long int</code></li>\n<li><code>unsigned long int</code></li>\n<li><code>long long int</code></li>\n<li><code>unsigned long long int</code></li>\n</ul>\n</blockquote>\n<p>which can hold (<em>represent</em>) the value.</p>\n<p>Also, for the very reason, <code>sizeof(0xF)</code> is the same as <code>sizeof(int)</code> which happens to produce a result of <code>4</code> in your platform.</p>\n", "OwnerUserId": "2173917", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:16.487", "Id": "42762659", "Score": "1", "CreationDate": "2017-03-13T11:34:32.793", "LastActivityDate": "2017-03-13T11:46:39.657"}, "bq_ids": {"n4140": {"so_42762610_42762659_0": {"section_id": 22, "quality": 1.0, "length": 15}, "so_42762610_42762645_0": {"section_id": 5341, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_42762610_42762659_0": {"section_id": 19, "quality": 1.0, "length": 15}, "so_42762610_42762645_0": {"section_id": 5138, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_42762610_42762659_0": {"section_id": 22, "quality": 1.0, "length": 15}, "so_42762610_42762645_0": {"section_id": 6762, "quality": 0.8181818181818182, "length": 9}}}, "42762645": {"ParentId": "42762610", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Because the type of an integer constant is determined to be the first that can contain it, and short simply isn't in the list of types. <code>int</code> is the first type that fits.</p>\n<p>Quoting <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.4.4.1p5\" rel=\"nofollow noreferrer\">N1570/6.4.4.1p5</a>:</p>\n<blockquote>\n<p id=\"so_42762610_42762645_0\">The type of an integer constant is the first of the corresponding list in which its value can be represented.</p>\n<pre class=\"lang-none prettyprint-override\"><code>Suffix | Decimal Constant | Octal or Hexadecimal Constant\n------ | ---------------- | -----------------------------\nnone   | int              | int \n       | long int         | unsigned int\n       | long long int    | long int\n       |                  | unsigned long int\n       |                  | long long int\n       |                  | unsigned long long int\n</code></pre>\n</blockquote>\n<p>The table clearly specifies int as the first type, and not <code>short</code>.</p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-03-13T11:41:58.367", "Id": "42762645", "Score": "3", "CreationDate": "2017-03-13T11:33:52.933", "LastActivityDate": "2017-03-13T11:41:58.367"}});