post_cb({"bq_ids": {"n4140": {"so_47670775_47671041_1": {"length": 37, "quality": 0.9024390243902439, "section_id": 269}, "so_47670775_47671041_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 268}, "so_47670775_47671391_0": {"length": 27, "quality": 0.9, "section_id": 275}}, "n3337": {"so_47670775_47671041_1": {"length": 37, "quality": 0.9024390243902439, "section_id": 260}, "so_47670775_47671041_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 259}, "so_47670775_47671391_0": {"length": 21, "quality": 0.7, "section_id": 266}}, "n4659": {"so_47670775_47671041_1": {"length": 37, "quality": 0.9024390243902439, "section_id": 276}, "so_47670775_47671041_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 275}, "so_47670775_47671391_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 282}}}, "47670775": {"ViewCount": "66", "Body": "<p>I was working with a template class that contains a static variable. The structure of code is as follows.</p>\n<h1>Header.h</h1>\n<pre><code>template&lt;class T&gt; class Foo\n{\npublic:\n    static int count;\n    Foo() {\n        count++;\n    }\n    void printCount() {\n        cout &lt;&lt; count &lt;&lt; endl;\n    }\n};\ntemplate&lt;class T&gt; int Foo&lt;T&gt;::count;\n</code></pre>\n<h1>Source.cpp</h1>\n<pre><code>#include \"Header.h\"\ntemplate&lt;&gt; int Foo&lt;int&gt;::count = 5;\n</code></pre>\n<h1>main.cpp</h1>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#include \"Header.h\"\nint main()\n{\n    Foo&lt;int&gt; obj1;\n    Foo&lt;int&gt; obj2;\n    obj1.printCount();\n    obj2.printCount();\n    return 0;\n}\n</code></pre>\n<p>the output on xcode8.3.3 is:</p>\n<pre><code> 7\n 7\n</code></pre>\n<p>whereas the output on Visual Studio 2015 is:</p>\n<pre><code>2\n2\n</code></pre>\n<p>i.e. the specific instantiation overrides the generic instantiation in xcode8.3.3 but not in Visual Studio 2015.\nCould someone explain this difference in behavior?\nThanks in advance.</p>\n", "Title": "explicit instantiation of static variable of a template class in different translation units", "CreationDate": "2017-12-06T09:25:13.313", "LastActivityDate": "2017-12-06T09:56:22.970", "CommentCount": "1", "PostTypeId": "1", "Id": "47670775", "Score": "2", "OwnerUserId": "8669160", "Tags": "<c++><templates><static-variables>", "AnswerCount": "3"}, "47671041": {"Id": "47671041", "PostTypeId": "2", "Body": "<p>Your program is not valid:</p>\n<blockquote>\n<p id=\"so_47670775_47671041_0\">[<a href=\"https://timsong-cpp.github.io/cppwp/temp.expl.spec#6\" rel=\"nofollow noreferrer\">temp.expl.spec#6</a>] <strong>If a template, a member template or a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required.</strong></p>\n</blockquote>\n<p>in other words, translation units should agree on what a template name means.</p>\n<p>The next standard paragraph laconically goes on with:</p>\n<blockquote>\n<p id=\"so_47670775_47671041_1\">The placement of explicit specialization declarations for <em>[... basically, any template whatsoever ...]</em>, can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below.\n  When writing a specialization, be careful about its location; <strong>or to make it compile will be such a trial as to kindle its self-immolation</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "8631381", "LastActivityDate": "2017-12-06T09:43:43.567", "Score": "1", "CreationDate": "2017-12-06T09:38:17.533", "ParentId": "47670775", "CommentCount": "2", "OwnerUserId": "8631381", "LastEditDate": "2017-12-06T09:43:43.567"}, "47670953": {"Id": "47670953", "PostTypeId": "2", "Body": "<p>gcc complains about double instances:</p>\n<pre><code>/tmp/ccUEOg7s.o:(.bss._ZN3FooIiE5countE[_ZN3FooIiE5countE]+0x0): multiple definition of `Foo&lt;int&gt;::count'\n/tmp/ccG7CO9C.o:(.data+0x0): first defined here\n</code></pre>\n<p>So having two instances and a linker which is not able to see this, any result can be the effect.</p>\n<p>It is simply a failure to have two instances of your variable here, independent if it is a templated instance or not. You have to remove one of them.</p>\n<p>If using C++17 you can have the var inline in the header.</p>\n", "LastActivityDate": "2017-12-06T09:34:32.797", "Score": "0", "CreationDate": "2017-12-06T09:34:32.797", "ParentId": "47670775", "CommentCount": "0", "OwnerUserId": "878532"}, "47671391": {"Id": "47671391", "PostTypeId": "2", "Body": "<p>While your code contains a constraint violation, it is in fact not too difficult to make it well formed and maintain the one place where the static is initialized. For the C++ standard says at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.spec#temp.expl.spec-13\" rel=\"nofollow noreferrer\">[temp.expl.spec]/13</a>:</p>\n<blockquote>\n<p id=\"so_47670775_47671391_0\">An explicit specialization of a static data member of a template or an\n  explicit specialization of a static data member template is a\n  definition if the declaration includes an initializer; otherwise, it\n  is a declaration. [\u2009Note: The definition of a static data member of a\n  template that requires default-initialization must use a\n  braced-init-list:</p>\n<pre><code>template&lt;&gt; X Q&lt;int&gt;::x;                         // declaration\ntemplate&lt;&gt; X Q&lt;int&gt;::x ();                      // error: declares a function\ntemplate&lt;&gt; X Q&lt;int&gt;::x { };                     // definition\n</code></pre>\n<p id=\"so_47670775_47671391_1\">\u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>The above implies that merely adding this line</p>\n<pre><code>template&lt;&gt; int Foo&lt;int&gt;::count; // declaration\n</code></pre>\n<p>At the bottom of <strong>Header.h</strong> is enough to let all translation units know that the <code>Foo&lt;int&gt;::count</code> exists \"somewhere\". The one true definition may remain in <strong>Source.cpp</strong>.</p>\n", "LastActivityDate": "2017-12-06T09:56:22.970", "Score": "1", "CreationDate": "2017-12-06T09:56:22.970", "ParentId": "47670775", "CommentCount": "0", "OwnerUserId": "817643"}});