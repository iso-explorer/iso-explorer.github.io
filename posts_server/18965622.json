post_cb({"18966321": {"ParentId": "18965622", "CommentCount": "1", "Body": "<p>There's no need for a complete definition when using references, but you\nalso have some pass by value arguments when you instantiation your\ntemplates with <code>VM</code> as <code>lua_State</code>.  And value parameters do require a\ncomplete declaration at the call site and where the function is defined.</p>\n<p>In your code, <code>Vm::push</code> is specialized for <code>lua_State&amp;</code> and <code>double</code>,\nso you get the specialization for <code>Vm::push( *luaState, (double)1.2f );</code>\n(but why <code>(double)1.2f</code>, and not just <code>1.2</code>?), so you get the\nspecialization.  There is no specialization of <code>Vm::pop</code> for\n<code>lua_State&amp;</code> and <code>int</code>, however, so you get an instantiation of the\ntemplate, which uses pass by value.  (I am supposing that <code>Uint32</code> is\n<em>not</em> a typedef for <code>int</code>.) </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "18966321", "Score": "1", "CreationDate": "2013-09-23T18:32:51.483", "LastActivityDate": "2013-09-23T18:32:51.483"}, "18970778": {"ParentId": "18965622", "CommentCount": "0", "Body": "<p>Changing the definition of Vm::pop to have a reference attribute on the VM parameter seems to fix the problem:</p>\n<pre><code>namespace Vm {    \ntemplate&lt;typename VM&gt;\n    void pop( VM&amp; vm, Uint32 nIndices );\n}\n</code></pre>\n<p>It wouldn't make any sense to make copies of the VM each time, unless you're a diehard functional programmer. I still don't get why the call resolved to lua_State and not lua_State&amp;, and properly deduced in Vm::push wrapper function(This one managed to provide more info..somehow..). Oh-well, it's working nicely now.</p>\n<p>Thanks for help!</p>\n", "OwnerUserId": "1884312", "PostTypeId": "2", "Id": "18970778", "Score": "1", "CreationDate": "2013-09-23T23:53:32.913", "LastActivityDate": "2013-09-23T23:53:32.913"}, "18966199": {"ParentId": "18965622", "CommentCount": "1", "Body": "<p>The relevant section is 5.3.1 [expr.unary.op] paragraph 1:</p>\n<blockquote>\n<p id=\"so_18965622_18966199_0\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d [ Note: a pointer to an incomplete type (other than cv void) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue, see 4.1. \u2014end note ]</p>\n</blockquote>\n<p>That is, you can dereference a pointer to an incomplete type to get a reference to the incomplete type. You won't be able to do much with the thus obtained reference. Basically, you won't be able to do anything which requires the definition of the incomplete type.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "18966199", "Score": "1", "CreationDate": "2013-09-23T18:25:21.553", "LastActivityDate": "2013-09-23T18:25:21.553"}, "bq_ids": {"n4140": {"so_18965622_18966199_0": {"section_id": 6064, "quality": 0.8431372549019608, "length": 43}}, "n3337": {"so_18965622_18966199_0": {"section_id": 5832, "quality": 0.8823529411764706, "length": 45}}, "n4659": {"so_18965622_18966199_0": {"section_id": 7560, "quality": 0.8431372549019608, "length": 43}}}, "18965622": {"CommentCount": "12", "ViewCount": "176", "PostTypeId": "1", "LastEditorUserId": "1884312", "CreationDate": "2013-09-23T17:47:04.547", "LastActivityDate": "2013-09-25T18:11:23.693", "Title": "Template expansion fails when passed Reference?", "AcceptedAnswerId": "18970778", "LastEditDate": "2013-09-25T18:11:23.693", "Id": "18965622", "Score": "1", "Body": "<p>I'm writing a simple wrapper around Lua's C Api, and having the functions take in a lua_State&amp; instead of a pointer. However, when I try to pass a lua_State* value, I have to dereference it to pass by reference. The template that is expanded to has func sig that has the vm being passed in by value, not reference.</p>\n<p>Since it is possible to use references and pointers of an object without its full definition, is there a way to convert from a pointer value to a referenced one with just a forward declaration of the type?</p>\n<p>Edit:\nAfter playing around with code a bit more. The dereferencing works for one of the function call but fails on another.</p>\n<pre><code>namespace Vm {\n\ntemplate&lt;typename VM, typename T&gt;\nvoid push( VM vm, T value );\n\n// If this function isn't here, push will fail too.\ntemplate&lt;typename T&gt;\nvoid push( lua_State&amp; luaState, T value ) {\n    Vm::push( luaState, value );\n}\n\ntemplate&lt;&gt;\nvoid push( lua_State&amp; luaState, double value ) {\n    lua_pushnumber( &amp;luaState, value );\n}\n\ntemplate&lt;typename VM&gt;\nvoid pop( VM vm, Uint32 nIndices );\n\ntemplate&lt;&gt;\nvoid pop( lua_State&amp; luaState, Uint32 nIndices ) {\n    lua_pop( &amp;luaState, nIndices );\n}\n\n}\n\n\nint main( int argc, char** argv )\n{\n    lua_State* luaState = luaL_newstate();\n    luaL_openlibs( luaState );\n    Vm::push( *luaState, (double)1.2f ); // This works fine.\n    Vm::pop( *luaState, 1 ); // This generates error.\n}\n</code></pre>\n<p>Compiler Error:</p>\n<pre><code>error: invalid use of incomplete type \u2018struct lua_State\u2019\nerror: forward declaration of \u2018struct lua_State\u2019\nerror:   initializing argument 1 of \u2018void Vm::pop(VM, Uint32) [with VM = lua_State; Uint32 = unsigned int]\u2019\n</code></pre>\n", "Tags": "<c++><templates><lua>", "OwnerUserId": "1884312", "AnswerCount": "3"}});