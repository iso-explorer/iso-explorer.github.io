post_cb({"43172652": {"CommentCount": "6", "AcceptedAnswerId": "43174512", "CreationDate": "2017-04-02T19:33:07.387", "LastActivityDate": "2017-04-02T23:18:20.547", "PostTypeId": "1", "ViewCount": "238", "FavoriteCount": "1", "Title": "Static const declaration, constexpr definition of variable, valid c++?", "Id": "43172652", "Score": "4", "Body": "<p>Example:\nIn header file:</p>\n<pre><code>class Foo\n{\n     static const int IntArray[];                         \n};\n</code></pre>\n<p>In source file:</p>\n<pre><code>constexpr int Foo::IntArray[] = { 1, 2, 3, 4 };\n</code></pre>\n<p>This compiles on g++ and allows me to put the initializer list in the source file in stead of the header. (if it were constexpr in the header the compiler requires immediate initialization in the header). While still allowing the array to be used in constexpr evaluations...</p>\n<p>Is this valid, portable C++ ?</p>\n", "Tags": "<c++>", "OwnerUserId": "1320881", "AnswerCount": "2"}, "43173033": {"ParentId": "43172652", "CommentCount": "0", "Body": "<p>I doubt it's compliant. The declaration and definition are required to be identical AFAIK.</p>\n<p>It's certainly not portable. Although gcc, clang and microsoft cl 2017 accept it,</p>\n<p>ICC reports:</p>\n<pre><code>&lt;source&gt;(6): error: member \"Foo::IntArray\" (declared at line 3) was previously not declared constexpr\n  constexpr int Foo::IntArray[] = { 1, 2, 3, 4 };\n  ^\ncompilation aborted for &lt;source&gt; (code 2)\nCompiler exited with result code 2\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "43173033", "Score": "4", "CreationDate": "2017-04-02T20:10:06.073", "LastActivityDate": "2017-04-02T20:10:06.073"}, "bq_ids": {"n4140": {"so_43172652_43174512_2": {"section_id": 5908, "quality": 0.9354838709677419, "length": 58}, "so_43172652_43174512_1": {"section_id": 5425, "quality": 1.0, "length": 13}, "so_43172652_43174512_0": {"section_id": 5417, "quality": 0.9696969696969697, "length": 32}}, "n3337": {"so_43172652_43174512_2": {"section_id": 5680, "quality": 0.9354838709677419, "length": 58}, "so_43172652_43174512_1": {"section_id": 5220, "quality": 1.0, "length": 13}, "so_43172652_43174512_0": {"section_id": 5212, "quality": 0.8181818181818182, "length": 27}}, "n4659": {"so_43172652_43174512_1": {"section_id": 6847, "quality": 1.0, "length": 13}, "so_43172652_43174512_0": {"section_id": 6839, "quality": 0.7878787878787878, "length": 26}}}, "43174512": {"ParentId": "43172652", "PostTypeId": "2", "CommentCount": "3", "Body": "<h3>The Right Way</h3>\n<p>Before we begin the language-lawyering, the correct approach is to do it the other way around.  In the header file:</p>\n<pre><code>class Foo\n{\n     static constexpr int IntArray[] = { 1, 2, 3, 4 };\n};\n</code></pre>\n<p>And then in a source file:</p>\n<pre><code>constexpr int Foo::IntArray[];\n</code></pre>\n<p>If you declare a <code>static constexpr</code> class data member in the class definition, you must initialize it then and there.  This is optional for <code>static const</code> data members.  If you use the <code>static constexpr</code> data member anywhere in the program, you must give a definition like the one above, in exactly one source file, with no initializer.</p>\n<h3>What the (Draft) Standard Says</h3>\n<p>The example code in the question is bad style, and apparently at least one compiler rejects it, but it does in fact seem to comply with the C++14 draft standard.  [<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf#subsection.7.1.5\" rel=\"nofollow noreferrer\">dcl/constexpr</a>] says:</p>\n<blockquote>\n<p id=\"so_43172652_43174512_0\">The <code>constexpr</code> specifier shall be applied only to the definition of a variable or variable template, the declaration of a function or function template, or the declaration of a <code>static</code> data member of a literal type.  If any declaration of a function, function template, or variable template has a <code>constexpr</code> specifier, then all its declarations shall contain the <code>constexpr</code> specifier.</p>\n</blockquote>\n<p>Notice whose declarations are, by omission, <strong>not</strong> all required to contain the <code>constexpr</code> specifier.</p>\n<p>Later in the same section:</p>\n<blockquote>\n<p id=\"so_43172652_43174512_1\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have literal type and shall be initialized. [...]</p>\n</blockquote>\n<p>But see also [<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf#subsection.9.4.2\" rel=\"nofollow noreferrer\">class.static.data</a>]:</p>\n<blockquote>\n<p id=\"so_43172652_43174512_2\">If a non-<code>volatile</code> <code>const</code> <code>static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. [Note: In both these cases, the member may appear in constant expressions. \u2014 end note ] The member shall still be defined in a namespace scope if it is odr-used in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<p>In this context, the odr in \u201codr-used\u201d stands for the <em>one-definition-rule</em> and means \u201cwhose name appears as a potentially-evaluated expression.\u201d ([basic.def.odr])  The last sentence means that, if you declare, <code>static constexpr int foo = 0;</code> in the class definition, and you will later use it in an expression, such as <code>int x = MyClass::foo;</code>, then one and only one source file needs to have a line like <code>constexpr int MyClass::foo;</code> in it, so the linker knows which object file to put it in.</p>\n", "OwnerUserId": "4474419", "LastEditorUserId": "4474419", "LastEditDate": "2017-04-02T23:18:20.547", "Id": "43174512", "Score": "2", "CreationDate": "2017-04-02T23:08:56.013", "LastActivityDate": "2017-04-02T23:18:20.547"}});