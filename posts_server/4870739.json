post_cb({"bq_ids": {"n4140": {"so_4870739_4870775_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 190}, "so_4870739_4870775_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 176}}, "n3337": {"so_4870739_4870775_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 184}, "so_4870739_4870775_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 170}}, "n4659": {"so_4870739_4870775_1": {"length": 22, "quality": 0.7096774193548387, "section_id": 195}, "so_4870739_4870775_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 181}}}, "4870739": {"ViewCount": "1479", "Body": "<pre><code>template&lt;class T&gt;\nclass base\n{\n    class nestedClass\n    {\n       T pos;\n    };\n   class derivedClass:public base&lt;T&gt;::nestedClass\n     {\n       void fun(){\n         pos = pos +5; // error: pos is not declared in this scope\n        }\n     };   \n\n};\n</code></pre>\n", "AcceptedAnswerId": "4870775", "Title": "nested class inheritance", "CreationDate": "2011-02-02T04:21:01.313", "LastActivityDate": "2016-05-30T14:23:22.033", "CommentCount": "5", "LastEditDate": "2016-05-30T14:23:22.033", "PostTypeId": "1", "Tags": "<c++><templates><class><nested>", "Id": "4870739", "AnswerCount": "3", "Score": "-1", "OwnerUserId": "591506", "ClosedDate": "2015-11-03T03:31:48.947", "LastEditorUserId": "3750257"}, "4870775": {"Id": "4870775", "PostTypeId": "2", "Body": "<p>C++03 [Section 14.6/8] says</p>\n<blockquote>\n<p id=\"so_4870739_4870775_0\">When looking for the declaration of a name used in a template definition, the usual lookup rules (3.4.1, 3.4.2) are used for nondependent names. The lookup of names dependent on the template parameters is postponed until the actual template argument is known (14.6.2).</p>\n</blockquote>\n<p>Section 14.6.2/3 says</p>\n<blockquote>\n<p id=\"so_4870739_4870775_1\">In the definition of a class template or a member of a class template, if a base class of the class template depends on a template-parameter, the base class scope is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member.</p>\n</blockquote>\n<p><code>pos</code> is an non dependent name so the base class is not examined.</p>\n<p>So you have two options.</p>\n<ul>\n<li>Use fully qualified name of Member i.e <code>base&lt;T&gt;::nestedClass::pos</code></li>\n<li>Use <code>this-&gt;pos</code>.</li>\n</ul>\n", "LastActivityDate": "2011-02-02T04:27:53.107", "CommentCount": "0", "CreationDate": "2011-02-02T04:27:53.107", "ParentId": "4870739", "Score": "3", "OwnerUserId": "165520"}, "4870755": {"Id": "4870755", "PostTypeId": "2", "Body": "<p>It has to be explicitly referenced as base::nestedClass::pos  [or use a using statement]</p>\n", "LastActivityDate": "2011-02-02T04:24:03.700", "CommentCount": "2", "CreationDate": "2011-02-02T04:24:03.700", "ParentId": "4870739", "Score": "1", "OwnerUserId": "590042"}, "4870774": {"Id": "4870774", "PostTypeId": "2", "Body": "<p>You're not bringing pos into scope.  You can either use <code>this-&gt;pos += 5;</code> or <code>using nestedclass::pos</code>.</p>\n", "LastActivityDate": "2011-02-02T04:27:48.653", "CommentCount": "2", "CreationDate": "2011-02-02T04:27:48.653", "ParentId": "4870739", "Score": "1", "OwnerUserId": "410767"}});