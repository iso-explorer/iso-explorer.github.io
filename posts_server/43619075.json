post_cb({"43619075": {"ViewCount": "306", "Body": "<p>Consider the <a href=\"https://wandbox.org/permlink/XjObkCwtvrkB3Y7R\" rel=\"nofollow noreferrer\">following code</a>:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;template&lt;class...&gt; class T, class... U&gt;\nstruct is_specialization_of : std::false_type{};\n\ntemplate&lt;template&lt;class...&gt; class T, class... U&gt;\nstruct is_specialization_of&lt;T, T&lt;U...&gt;&gt; : std::true_type{};\n\ntemplate&lt;class T, class U = int&gt;\nstruct test{};\n\n// (1) ok\nstatic_assert(is_specialization_of&lt;test, test&lt;int&gt;&gt;::value, \"1\");\n\ntemplate&lt;class T&gt;\nusing alias = test&lt;T&gt;;\n\n// (2) fails\nstatic_assert(is_specialization_of&lt;alias, alias&lt;int&gt;&gt;::value, \"2\");\n\nint main()\n{\n}\n</code></pre>\n<p>Why does (2), i.e. <code>static_assert</code> that uses alias template, fail?</p>\n<p>How does the template argument deduction process in (2) differ from the one in (1)? </p>\n", "AcceptedAnswerId": "43636262", "Title": "Matching alias template as template argument", "CreationDate": "2017-04-25T19:13:02.893", "Id": "43619075", "CommentCount": "1", "LastEditDate": "2017-04-26T14:59:22.587", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2017-04-26T15:04:28.573", "Score": "8", "OwnerUserId": "759253", "Tags": "<c++><c++11><templates><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_43619075_43636262_1": {"length": 17, "quality": 1.0, "section_id": 166}}, "n3337": {"so_43619075_43636262_1": {"length": 17, "quality": 1.0, "section_id": 160}}, "n4659": {"so_43619075_43636262_1": {"length": 17, "quality": 1.0, "section_id": 170}}}, "43636262": {"Id": "43636262", "PostTypeId": "2", "Body": "<p>This is <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#1286\" rel=\"nofollow noreferrer\">CWG issue 1286</a>. The question is: are <code>alias</code> and <code>test</code> equivalent? There used to be an example in [temp.type] which suggested that <code>y</code> and <code>z</code> have the same type here:</p>\n<blockquote id=\"so_43619075_43636262_0\">\n<pre><code>template&lt;template&lt;class&gt; class TT&gt; struct X { };\ntemplate&lt;class&gt; struct Y { };\ntemplate&lt;class T&gt; using Z = Y&lt;T&gt;;\nX&lt;Y&gt; y;\nX&lt;Z&gt; z;\n</code></pre>\n</blockquote>\n<p>The example was corrected as part of <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1244\" rel=\"nofollow noreferrer\">CWG defect 1244</a> - which indicated correctly that there is no wording in <a href=\"http://eel.is/c++draft/temp.alias\" rel=\"nofollow noreferrer\">[temp.alias]</a> that actually specifies that alias templates are equivalent to the templates they alias. The only wording there refers to equivalence of alias template specializations:</p>\n<blockquote>\n<p id=\"so_43619075_43636262_1\">When a <em>template-id</em> refers to the <strong>specialization of an alias template</strong>, it is equivalent to the associated type obtained by substitution of its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of the alias template.</p>\n</blockquote>\n<p>The intent is apparently that <code>y</code> and <code>z</code> <em>do</em> have the same type in this example, meaning that <code>Z</code> and <code>Y</code> are actually equivalent. But unless and until the wording in the resolution is adopted, they are not. Today, <code>alias</code> and <code>test</code> are <em>not</em> equivalent but <code>alias&lt;int&gt;</code> and <code>test&lt;int&gt;</code> <em>are</em>. This means that <code>is_specialization_of&lt;alias, alias&lt;int&gt;&gt;</code> is <code>is_specialization_of&lt;alias, test&lt;int&gt;&gt;</code>, where <code>alias</code> is unique from <code>test</code>, which would not match your partial specialization and thus be <code>false_type</code>. </p>\n<p>Moreover, even with the adoption of the wording in #1286, <code>test</code> and <code>alias</code> are <em>still not equivalent</em> for the obvious reason that <code>test</code> takes two template parameters and alias takes one template parameter. The example in the resolution wording mimics your example and clarifies the intent here:</p>\n<blockquote id=\"so_43619075_43636262_2\">\n<pre><code>template&lt;typename T, U = T&gt; struct A;\n\n// ...\n\ntemplate&lt;typename V&gt;   \n  using D = A&lt;V&gt;;      // not equivalent to A:\n                       // different number of parameters\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-04-26T15:04:28.573", "Score": "6", "CreationDate": "2017-04-26T13:54:40.867", "ParentId": "43619075", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2017-04-26T15:04:28.573"}, "43619533": {"Id": "43619533", "PostTypeId": "2", "Body": "<p>I think that name of alias template without template arguments list is not equivalent to the name of associated type. Because standard specifies only one such situation:</p>\n<blockquote>\n<p id=\"so_43619075_43619533_0\">14.5.7 Alias templates [temp.alias] </p>\n<ol start=\"2\">\n<li>When a template-id refers to the specialization of an alias template, it is equivalent to the associated type\n  obtained by substitution of its template-arguments for the template-parameters in the type-id of the alias\n  template. [Note: An alias template name is never deduced.\u2014end note ]</li>\n</ol>\n</blockquote>\n<p>and this <a href=\"http://ideone.com/uzkBl6\" rel=\"nofollow noreferrer\">works fine</a>:</p>\n<pre><code>static_assert(is_specialization_of&lt;test, alias&lt;int&gt;&gt;::value, \"2\");\n</code></pre>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2017-04-26T10:43:15.937", "Score": "2", "CreationDate": "2017-04-25T19:39:03.440", "ParentId": "43619075", "CommentCount": "3", "OwnerUserId": "7860670", "LastEditDate": "2017-04-26T10:43:15.937"}});