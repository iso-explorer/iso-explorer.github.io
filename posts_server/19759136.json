post_cb({"19759603": {"ParentId": "19759136", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>During template argument deduction for a function call, the special rules for \"universal references\" only apply if the parameter type is a cv-unqualified template parameter [temp.deduct.call]/3</p>\n<p>[<code>P</code> is the parameter type of the function template, and <code>A</code> is the type of the argument]</p>\n<blockquote>\n<p id=\"so_19759136_19759603_0\">If <code>P</code> is an rvalue reference to a cv-unqualified template parameter and the argument is an lvalue, the type \u201clvalue reference to <code>A</code>\u201d is used in place of <code>A</code> for type deduction. [<em>Example:</em></p>\n<pre><code>template &lt;class T&gt; int f(T&amp;&amp;);\ntemplate &lt;class T&gt; int g(const T&amp;&amp;);\nint i;\nint n1 = f(i); // calls f&lt;int&amp;&gt;(int&amp;)\nint n2 = f(0); // calls f&lt;int&gt;(int&amp;&amp;)\nint n3 = g(i); // error: would call g&lt;int&gt;(const int&amp;&amp;), which\n// would bind an rvalue reference to an lvalue\n</code></pre>\n<p id=\"so_19759136_19759603_1\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Similarly, these rules <em>do not</em> apply to the parameter type <code>A&lt;T&gt;&amp;&amp;</code>. It is not a \"universal reference\" but purely an rvalue-reference type.</p>\n<hr>\n<p>If you want to have a ranking between two constructors, where the <code>A&lt;T&gt;</code>-version shall be more specialized (a better match), you can:</p>\n<ul>\n<li>provide <strike>two</strike>three overloads <code>A&lt;T&gt; const&amp;</code>, <code>A&lt;T&gt;&amp;</code> (thanks, <a href=\"https://stackoverflow.com/users/195873/eric-niebler\">Eric Niebler</a>) and <code>A&lt;T&gt;&amp;&amp;</code> in addition to the <code>T&amp;&amp;</code> generic version</li>\n<li>use SFINAE; provide two overloads with a parameter <code>T&amp;&amp;</code> and check if <code>T</code> is a specialization of <code>A&lt;T&gt;</code></li>\n</ul>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:25.113", "Id": "19759603", "Score": "6", "CreationDate": "2013-11-03T23:41:36.463", "LastActivityDate": "2013-11-05T23:05:27.310"}, "bq_ids": {"n4140": {"so_19759136_19759603_0": {"section_id": 304, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_19759136_19759603_0": {"section_id": 295, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_19759136_19759603_0": {"section_id": 311, "quality": 0.9285714285714286, "length": 13}}}, "19759136": {"CommentCount": "7", "AcceptedAnswerId": "19759603", "PostTypeId": "1", "LastEditorUserId": "2805305", "CreationDate": "2013-11-03T22:47:44.037", "LastActivityDate": "2014-08-02T12:03:02.417", "LastEditDate": "2014-08-02T12:03:02.417", "ViewCount": "223", "FavoriteCount": "2", "Title": "Template type deduction for rvalue arguments", "Id": "19759136", "Score": "4", "Body": "<p>I understand the forwarding method in C++11.</p>\n<pre><code>template &lt;class T&gt; void foo(T &amp;&amp;)\n</code></pre>\n<p>foo will now accept both lvalues and rvalues.</p>\n<p>My problem is when I overload foo furthermore.\nConsider this simple code:</p>\n<pre><code>template &lt;class T&gt; class A {};\n\ntemplate &lt;class T&gt; void foo(T &amp;&amp;obj) {}\ntemplate &lt;class T&gt; void foo(A&lt;T&gt; &amp;&amp;obj) {}\n\nint main() {\n  int i;\n  A&lt;int&gt; a;\n  foo(i); // calls foo(T &amp;&amp;) as I want\n  foo(a); // calls foo(T &amp;&amp;), but I want it to call foo(A&lt;T&gt; &amp;&amp;)\n  return 0;\n}\n</code></pre>\n<p>If I call <code>foo</code> with an <code>A &lt; int &gt; &amp;</code> (lvalue) object, it will call <code>foo(T &amp;&amp;)</code>, and not <code>foo(A &lt; T &gt; &amp;&amp;)</code>. In the definition of <code>foo(T &amp;&amp;obj)</code>, I managed to differentiate with std and custom traits if <code>obj</code> is <code>A&lt;T&gt;</code> or not, but this produces very very messy code, as I must call the <code>A</code> method from <code>obj</code>, and <code>obj</code> is declared as <code>T</code>, and not as <code>A &lt; T &gt;</code>.\nReordering declarations or adding lvalue overloads don't solve the problem.</p>\n<p>Hope I made myself understood.\nI provided a simplified code in order to zone in the problem.\nI am implementing a custom <code>Optional &lt; T &gt;</code> class (similar to <code>boost::optional</code>) and I have this problem at constructors as I need to be able to create (and assign) an <code>Optional &lt; T &gt;</code> object from another <code>Optional &lt; T &gt;</code>, <code>Optional &lt; U &gt;</code>, <code>T</code> or <code>U</code> object. (where <code>T</code> is the type held by the optional object to be created, <code>U</code> is a different type, convertible to <code>T</code>).</p>\n<p>Thank you for your time.</p>\n", "Tags": "<c++><templates><c++11><overloading><rvalue>", "OwnerUserId": "2805305", "AnswerCount": "1"}});