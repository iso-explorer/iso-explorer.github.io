post_cb({"21880669": {"ParentId": "21879331", "CommentCount": "0", "Body": "<p>Those people don't seem to understand either the standard or the instructions.</p>\n<p>First of all, <code>std::atomic_compare_exchange_weak</code> is <strong>not</strong> thread-unsafe by design. That is complete nonsense.\nThe design very clearly defines what the function does and which guarantees (including atomicity and memory ordering) it must provide.<br>\nWhether your program that uses this function is thread-safe as a whole is a different matter, but the function's semantics <em>per se</em> are certainly correct in the sense of an atomic copare-exchange (you can still write thread-unsafe code using any available thread-safe primitive, but that is a totally different story).</br></p>\n<p>This particular function implements the \"weak\" version of a thread-safe compare-exchange operation which differs from the \"non weak\" version in that the implementation is allowed to generate code which may spuriously fail, if that gives a performance benefit (irrelevant on x86). Weak does not mean it's worse, it only means that it is <em>allowable</em> to fail more often on some platforms, if that gives an overall performance benefit.<br>\nThe implementation is of course still required to work <em>correctly</em>. That is, if the compare-exchange fails -- whether by concurrency or spuriously -- it must be correctly reported back as having failed.</br></p>\n<p>Second, the code generated by existing implementations has no bearing for the correctness or thread-safety of <code>std::atomic_compare_exchange_weak</code>. At best, if the generated instructions do not work correctly, this is an implementation issue, but it has nothing to do with the language construct. The language standard defines what behavior an implementation must provide, it is not responsible for implementations acutally doing it correctly.</p>\n<p>Third, there is no problem in the generated code. The x86  <code>CMPXCHG</code> instruction has a well-defined mode of operation. It compares the actual value with the expected value, and if the comparison is successful, it performs the swap. You know whether or not the operation was successful either by looking at EAX (or RAX in x64) or by the state of <code>ZF</code>.<br>\nWhat matters is that the atomic compare-exchange is atomic, and that's the case. Whatever you do with the result <em>afterwards</em> needs not be atomic (in your case, the <code>CMP</code>), since the state does not change any more. Either the swap was successful at that point, or it has failed. In either case, it's already \"history\".</br></p>\n<p><code>std::atomic_compare_exchange_weak</code> has different semantics than the underlying instruction, it returns a <code>bool</code> value. Therefore, you cannot always expect a 1:1 mapping to instructions. The compiler <em>may</em> have to generate additional instructions (and different ones depending on how you consume the result) to implement these semantics, but it really makes no difference for correctness.</p>\n<p>The only thing one could arguably complain about is the fact that instead of directly using the already present state of <code>ZF</code> (with a <code>Jcc</code> or <code>CMOVcc</code>), it performs another comparison. But this is a performance issue (1 cycle wasted), not a correctness issue.</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "21880669", "Score": "1", "CreationDate": "2014-02-19T12:35:28.433", "LastActivityDate": "2014-02-19T12:35:28.433"}, "21883659": {"ParentId": "21879331", "CommentCount": "6", "Body": "<p>I was the one who originally found this bug. For the last few days I have been e-mailing Anthony Williams regarding this issue and vendor implementations. I didn't realize Cubbi had raise a StackOverFlow question. It's not just Clang or GCC it's every vendor that is broken (all that matters anyway). Anthony Williams also author of Just::Thread (a C++11 thread and atomic library) confirmed his library is implemented correctly (only known correct implementation). </p>\n<p>Anthony has raised a GCC bug report <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=60272\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=60272</a></p>\n<p>Simple example:</p>\n<pre><code>   #include &lt;atomic&gt;\n   struct Node { Node* next; };\n   void Push(std::atomic&lt;Node*&gt; head, Node* node)\n   {\n       node-&gt;next = head.load();\n       while(!head.compare_exchange_weak(node-&gt;next, node))\n           ;\n   }\n</code></pre>\n<p>g++ 4.8 [assembler]</p>\n<pre><code>       mov    rdx, rdi\n       mov    rax, QWORD PTR [rdi]\n       mov    QWORD PTR [rsi], rax\n   .L3:\n       mov    rax, QWORD PTR [rsi]\n       lock cmpxchg    QWORD PTR [rdx], rsi\n       mov    QWORD PTR [rsi], rax !!!!!!!!!!!!!!!!!!!!!!!\n       jne    .L3\n       rep; ret\n</code></pre>\n<p>clang 3.3 [assembler]</p>\n<pre><code>       movq    (%rdi), %rcx\n       movq    %rcx, (%rsi)\n   .LBB0_1:\n       movq    %rcx, %rax\n       lock\n       cmpxchgq    %rsi, (%rdi)\n       movq    %rax, (%rsi) !!!!!!!!!!!!!!!!!!!!!!!\n       cmpq    %rcx, %rax !!!!!!!!!!!!!!!!!!!!!!!\n       movq    %rax, %rcx\n       jne    .LBB0_1\n       ret\n</code></pre>\n<p>icc 13.0.1 [assembler]</p>\n<pre><code>       movl      %edx, %ecx\n       movl      (%rsi), %r8d\n       movl      %r8d, %eax\n       lock\n       cmpxchg   %ecx, (%rdi)\n       movl      %eax, (%rsi) !!!!!!!!!!!!!!!!!!!!!!!\n       cmpl      %eax, %r8d !!!!!!!!!!!!!!!!!!!!!!!\n       je        ..B1.7\n   ..B1.4:\n       movl      %edx, %ecx\n       movl      %eax, %r8d\n       lock\n       cmpxchg   %ecx, (%rdi)\n       movl      %eax, (%rsi) !!!!!!!!!!!!!!!!!!!!!!!\n       cmpl      %eax, %r8d !!!!!!!!!!!!!!!!!!!!!!!\n       jne       ..B1.4\n   ..B1.7:\n       ret\n</code></pre>\n<p>Visual Studio 2012 [No need to check assembler, MS uses _InterlockedCompareExchange !!!]</p>\n<pre><code>   inline int _Compare_exchange_seq_cst_4(volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value)\n   {    /* compare and exchange values atomically with\n       sequentially consistent memory order */\n       int _Res;\n       _Uint4_t _Prev = _InterlockedCompareExchange((volatile long\n*)_Tgt, _Value, *_Exp);\n       if (_Prev == *_Exp) !!!!!!!!!!!!!!!!!!!!!!!\n           _Res = 1;\n       else\n       { /* copy old value */\n           _Res = 0;\n           *_Exp = _Prev;\n       }\n       return (_Res);\n   }\n</code></pre>\n", "OwnerUserId": "3318694", "PostTypeId": "2", "Id": "21883659", "Score": "8", "CreationDate": "2014-02-19T14:37:51.150", "LastActivityDate": "2014-02-19T14:37:51.150"}, "21946549": {"ParentId": "21879331", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_21879331_21946549_0\">[...]</p>\n<p id=\"so_21879331_21946549_1\">break CAS loops such as Concurrency in Action's listing 7.2:</p>\n<pre><code>while(!head.compare_exchange_weak(new_node-&gt;next, new_node);\n</code></pre>\n<p id=\"so_21879331_21946549_2\">The specification (29.6.5[atomics.types.operations.req]/21-22) seems to\n  imply that the result of the comparison must be a part of the atomic\n  operation:</p>\n<p id=\"so_21879331_21946549_3\">[...]</p>\n</blockquote>\n<p>The issue with this code and the specification is not whether the atomicity of compare_exchange needs to extend beyond just the comparison and exchange itself to returning the result of the comparison or assigning to the <code>expected</code> parameter. That is, the code may still be correct without the store to <code>expected</code> being atomic.</p>\n<p>What causes the above code to be potentially racy is when implementations write to the <code>expected</code> parameter after a successful exchange may have been observed by other threads. The code is written with the expectation that in the case when the exchange is successful there is no write on <code>expected</code> to produce a race.</p>\n<p>The spec, as written, does appear to guarantee this expected behavior. (And indeed can be read as making the much stronger guarantee you describe, that the entire operation is atomic.) According to the spec, <code>compare_exchange_weak</code>:</p>\n<blockquote>\n<p id=\"so_21879331_21946549_4\">Atomically, compares the contents of the memory pointed to by object\n  or by this for equality with that in expected, and if true, replaces\n  the contents of the memory pointed to by object or by this with that\n  in desired, and if false, updates the contents of the memory in\n  expected with the contents of the memory pointed to by object or by\n  this. [n4140 \u00a7 29.6.5 / 21] <em>(N.B. The wording is unchanged between C++11 and C++14)</em></p>\n</blockquote>\n<p>The problem is that it seems as though the actual language of the standard is stronger than the original intent of the proposal. Herb Sutter <a href=\"http://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15607\" rel=\"nofollow\">is saying</a> that <em>Concurrency in Action</em>'s usage was never really intended to be supported, and that updating <code>expected</code> was only intended to be done on local variables.</p>\n<p>I don't see any current defect report on this. <strong>[See second update below]</strong> If in fact this language is stronger than intended then presumably one will get filed. Either C++11's wording will be updated to guarantee the above code's expected behavior, thus making current implementations non-conformant, or the new wording will not guarantee this behavior, making the above code potentially result in undefined behavior. In that case I guess Anthony's book will need updating. What the committee will do about this, and whether or not actual implementations conform to the original intent (rather than the actual wording of the spec) is still an open question. <strong>[See update below]</strong></p>\n<p>For the purposes of writing code in the meantime, you'll have to take into account the actual behavior of implementation whether it's conformant or not. Existing implementations may be 'buggy' in the sense that they don't implement the the exact wording of the ISO spec, but they do operate as their implementers intended and they can be used to write thread safe code. <strong>[See update below]</strong></p>\n<p>So to answer your questions directly:</p>\n<blockquote>\n<p id=\"so_21879331_21946549_5\">but is it actually implementable?</p>\n</blockquote>\n<p>I believe that the actual wording of the spec is not reasonably implementable (And that the actual wording makes guarantees stronger even than Anthony's <code>just::thread</code> library provides. For example the actual wording appears to require atomic operations on a non-atomic object. Anthony's slightly weaker interpretation, that the assignment to <code>expected</code> need not be atomic but must be conditioned on the failure of the exchange, is obviously implementable. Herb's even <a href=\"http://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/\" rel=\"nofollow\">weaker interpretation</a> is also obviously implementable, as that's what most libraries actually implement. <strong>[See update below]</strong></p>\n<blockquote>\n<p id=\"so_21879331_21946549_6\">Is <code>std::atomic_compare_exchange_weak</code> thread-unsafe by design?</p>\n</blockquote>\n<p>The operation is not thread unsafe no matter whether the operation makes guarantees as strong as the actual wording of the spec or as weak as Herb Sutter indicates. It's simply that correct, thread safe usage of the operation depends on what is guaranteed. The example code from <em>Concurrency in Action</em> is an unsafe usage of a compare_exchange that only offers Herb's weak guarantee, but it could be written to work correctly with Herb's implementation. That could be done like so:</p>\n<pre><code>node *expected_head = head.load();\nwhile(!head.compare_exchange_weak(expected_head, new_node) {\n  new_node-&gt;next = expected_head;\n}\n</code></pre>\n<p>With this change the 'spurious' writes to <code>expected</code> are simply made to a local variable, and no longer produce any races. The write to <code>new_node-&gt;next</code> is now conditional upon the exchange having failed, and thus <code>new_node-&gt;next</code> is not visible to any other thread and may be safely updated. This code sample is safe both under current implementations and under stronger guarantees, so it should be future proof to any updates to C++11's atomics that resolve this issue.</p>\n<hr>\n<p>Update:</p>\n<p>Actual implementations (MSVC, gcc, and clang at least) have been updated to offer the guarantees under Anthony Williams' interpretation; that is, they have stopped inventing writes to <code>expected</code> in the case that the exchange succeeds.</p>\n<p><a href=\"https://llvm.org/bugs/show_bug.cgi?id=18899\" rel=\"nofollow\">https://llvm.org/bugs/show_bug.cgi?id=18899</a></p>\n<p><a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60272\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60272</a></p>\n<p><a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/819819/std-atomic-compare-exchange-weak-has-spurious-write-which-can-cause-race-conditions\" rel=\"nofollow\">https://connect.microsoft.com/VisualStudio/feedback/details/819819/std-atomic-compare-exchange-weak-has-spurious-write-which-can-cause-race-conditions</a></p>\n<p>Update 2:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/types/is_trivially_copyable\" rel=\"nofollow\">This defect report</a> on this issue has been filed with the C++ committee. From the currently proposed resolution the committee does want to make stronger guarantees than provided by the implementations you checked (but not as strong as current wording which appears to guarantee atomic operations on non-atomic objects.) The draft for the next C++ standard (C++1z or 'C++17') has not yet adopted the improved wording.</p>\n</hr>", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2015-11-03T17:08:31.930", "Id": "21946549", "Score": "3", "CreationDate": "2014-02-21T22:34:27.913", "LastActivityDate": "2015-11-03T17:08:31.930"}, "21879713": {"ParentId": "21879331", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Quoting Duncan Forster from the linked page:</p>\n<blockquote>\n<p id=\"so_21879331_21879713_0\">The important thing to remember is that the hardware implementation of CAS only returns 1 value (the old value) not two (old plus boolean)</p>\n</blockquote>\n<p>So there's one instruction - the (atomic) CAS - which actually operates on memory, and then another instruction to convert the (atomically-assigned) result into the expected boolean.</p>\n<p>Since the value in <code>%rax</code> was set atomically and can't then be affected by another thread, there is no race here.</p>\n<p>The quote is anyway false, since ZF is also set depending on the CAS result (ie, it <em>does</em> return both the old value and the boolean). The fact the flag isn't used might be a missed optimisation, or the cmpq might be faster, but it doesn't affect correctness.</p>\n<hr>\n<p>For reference, consider decomposing <code>compare_exchange_weak</code> like this pseudocode:</p>\n<pre><code>T compare_exchange_weak_value(atomic&lt;T&gt; *obj, T *expected, T desired) {\n    // setup ...\n    lock cmpxchgq   %rcx, (%rsp) // actual CAS\n    return %rax; // actual destination value\n}\n\nbool compare_exchange_weak_bool(atomic&lt;T&gt; *obj, T *expected, T desired) {\n    // CAS is atomic\n    T actual = compare_exchange_weak_value(obj, expected, desired);\n    // now we figure out if it worked\n    return actual == *expected;\n}\n</code></pre>\n<p>Do you agree the CAS is properly atomic?</p>\n<hr>\n<p>If the unconditional store to expected is really what you wanted to ask about (instead of the perfectly safe comparison), I agree with Sebastian that it's a bug.</p>\n<p>For reference, you can work around it by forcing the unconditional store into a local, and making the potentially-visible store conditional again:</p>\n<pre><code>struct node {\n  int data;\n  node* next;\n};\n\nstd::atomic&lt;node*&gt; head;\n\nvoid push(int data) {\n  node* new_node = new node{data};\n  node* cur_head = head.load(std::memory_order_relaxed);\n  do {\n    new_node-&gt;next = cur_head;\n  } while (!head.compare_exchange_weak(cur_head, new_node,\n            std::memory_order_release, std::memory_order_relaxed));\n}\n</code></pre>\n</hr></hr>", "OwnerUserId": "212858", "LastEditorUserId": "212858", "LastEditDate": "2014-02-19T13:17:28.067", "Id": "21879713", "Score": "2", "CreationDate": "2014-02-19T11:53:31.967", "LastActivityDate": "2014-02-19T13:17:28.067"}, "21879331": {"CommentCount": "2", "AcceptedAnswerId": "21881095", "PostTypeId": "1", "LastEditorUserId": "273767", "CreationDate": "2014-02-19T11:37:30.977", "LastActivityDate": "2015-11-03T17:08:31.930", "LastEditDate": "2014-02-19T13:55:13.783", "ViewCount": "1261", "FavoriteCount": "5", "Title": "Is std::atomic_compare_exchange_weak thread-unsafe by design?", "Id": "21879331", "Score": "18", "Body": "<p>It was brought up on <a href=\"http://en.cppreference.com/w/Talk%3acpp/atomic/atomic/compare_exchange\">cppreference atomic_compare_exchange Talk page</a> that the existing implementations of <code>std::atomic_compare_exchange_weak</code> <s>compute the boolean result of the CAS with a non-atomic compare instruction, e.g.</s></p>\n<pre><code>    lock\n    cmpxchgq   %rcx, (%rsp)\n    cmpq       %rdx, %rax\n</code></pre>\n<p>which</p> (Edit: apologies for the red herring)\n<p>break CAS loops such as Concurrency in Action's listing 7.2:</p>\n<pre><code>while(!head.compare_exchange_weak(new_node-&gt;next, new_node);\n</code></pre>\n<p>The specification (29.6.5[atomics.types.operations.req]/21-22) seems to imply that the result of the comparison must be a part of the atomic operation: </p>\n<blockquote>\n<p id=\"so_21879331_21879331_0\">Effects: atomically compares ...</p>\n<p id=\"so_21879331_21879331_1\">Returns: the result of the comparison</p>\n</blockquote>\n<p>but is it actually implementable? Should we file bug reports to the vendors or to the LWG?</p>\n", "Tags": "<c++><c++11><atomic>", "OwnerUserId": "273767", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_21879331_21946549_4": {"section_id": 1200, "quality": 0.75, "length": 24}, "so_21879331_21881095_0": {"section_id": 1200, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_21879331_21946549_4": {"section_id": 1198, "quality": 0.75, "length": 24}, "so_21879331_21881095_0": {"section_id": 1198, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_21879331_21946549_4": {"section_id": 1280, "quality": 0.5625, "length": 18}, "so_21879331_21881095_0": {"section_id": 1280, "quality": 0.6666666666666666, "length": 10}}}, "21881095": {"ParentId": "21879331", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>TL;DR: atomic_compare_exchange_weak is safe by design, but actual implementations are buggy.</p>\n<p>Here's the code that Clang actually generates for this little snippet:</p>\n<pre><code>struct node {\n  int data;\n  node* next;\n};\n\nstd::atomic&lt;node*&gt; head;\n\nvoid push(int data) {\n  node* new_node = new node{data};\n  new_node-&gt;next = head.load(std::memory_order_relaxed);\n  while (!head.compare_exchange_weak(new_node-&gt;next, new_node,\n      std::memory_order_release, std::memory_order_relaxed)) {}\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>  movl  %edi, %ebx\n  # Allocate memory\n  movl  $16, %edi\n  callq _Znwm\n  movq  %rax, %rcx\n  # Initialize with data and 0\n  movl  %ebx, (%rcx)\n  movq  $0, 8(%rcx) ; dead store, should have been optimized away\n  # Overwrite next with head.load\n  movq  head(%rip), %rdx\n  movq  %rdx, 8(%rcx)\n  .align  16, 0x90\n.LBB0_1:                                # %while.cond\n                                        # =&gt;This Inner Loop Header: Depth=1\n  # put value of head into comparand/result position\n  movq  %rdx, %rax\n  # atomic operation here, compares second argument to %rax, stores first argument\n  # in second if same, and second in %rax otherwise\n  lock\n  cmpxchgq  %rcx, head(%rip)\n  # unconditionally write old value back to next - wait, what?\n  movq  %rax, 8(%rcx)\n  # check if cmpxchg modified the result position\n  cmpq  %rdx, %rax\n  movq  %rax, %rdx\n  jne .LBB0_1\n</code></pre>\n<p>The comparison is perfectly safe: it's just comparing registers. However, the whole operation is not safe.</p>\n<p>The critical point is this: the description of compare_exchange_(weak|strong) says:</p>\n<blockquote>\n<p id=\"so_21879331_21881095_0\">Atomically [...] if true, replace the contents of the memory point to by this with that in desired, and if false, updates the contents of the memory in expected with the contents of the memory pointed to by this</p>\n</blockquote>\n<p>Or in pseudo-code:</p>\n<pre><code>if (*this == expected)\n  *this = desired;\nelse\n  expected = *this;\n</code></pre>\n<p>Note that <code>expected</code> is only written to <strong>if the comparison is false</strong>, and <code>*this</code> is only written to <strong>if comparison is true</strong>. The abstract model of C++ does not allow an execution where both are written to. This is important for the correctness of <code>push</code> above, because if the write to <code>head</code> happens, suddenly new_node points to a location that is visible to other threads, which means other threads can start reading <code>next</code> (by accessing <code>head-&gt;next</code>), and if the write to <code>expected</code> (which aliases <code>new_node-&gt;next</code>) also happens, that's a race.</p>\n<p>And Clang writes to <code>new_node-&gt;next</code> unconditionally. In the case where the comparison is true, that's an invented write.</p>\n<p><strong>This is a bug in Clang.</strong> I don't know whether GCC does the same thing.</p>\n<p>In addition, the wording of the standard is suboptimal. It claims that the entire operation must happen atomically, but this is impossible, because <code>expected</code> is not an atomic object; writes to there cannot happen atomically. What the standard should say is that the comparison and the write to <code>*this</code> happen atomically, but the write to <code>expected</code> does not. But this isn't that bad, because no one really expects that write to be atomic anyway.</p>\n<p>So there should be a bug report for Clang (and possibly GCC), and a defect report for the standard.</p>\n", "OwnerUserId": "8922", "LastEditorUserId": "8922", "LastEditDate": "2014-02-19T13:22:13.220", "Id": "21881095", "Score": "16", "CreationDate": "2014-02-19T12:54:05.840", "LastActivityDate": "2014-02-19T13:22:13.220"}});