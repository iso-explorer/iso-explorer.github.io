post_cb({"45387203": {"ParentId": "45385433", "CommentCount": "0", "Body": "<h3>Is it safe to make a const reference member to a temporary variable?</h3>\n<p>Yes, as long as the reference is used only while the lifetime of the \"temporary\" variable has not ended. In the code you posted, you are holding on to a reference past the lifetime of the referenced object. (i.e. not good)</p>\n<h3>So, I assume that the compiler automatically generated a code directing the reference to another hidden variable.</h3>\n<p>No, that's not quite what's happening.</p>\n<p>On my machine your print statement in main prints 125 instead of 0, so first let's duplicate your results:</p>\n<pre><code>#include &lt;alloca.h&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nstruct Foo\n{\n  double const&amp; f;\n  Foo(double const&amp; fx) : f(fx)\n  {\n    std::cout &lt;&lt; fx &lt;&lt; \" \" &lt;&lt; this-&gt;f &lt;&lt; std::endl;\n  }\n\n  double GetF() const\n  {\n    return f;\n  }\n};\n\nFoo make_foo()\n{\n  return Foo(123.0 + 2.0);\n}\n\nint main()\n{\n  Foo p = make_foo();\n  void * const stack = alloca(1024);\n  std::memset(stack, 0, 1024);\n  std::cout &lt;&lt; p.GetF() &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>Now it prints 0!</p>\n<hr>\n<p>125.0 and 2.0 are <a href=\"http://en.cppreference.com/w/cpp/language/floating_literal\" rel=\"nofollow noreferrer\">floating point literals</a>. Their sum is a <a href=\"http://en.cppreference.com/w/cpp/language/value_category#prvalue\" rel=\"nofollow noreferrer\">rvalue</a> that is <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Temporary_materialization\" rel=\"nofollow noreferrer\">materialized</a> during the construction of the Foo object, since Foo's constructor requires a reference to a double. That temporary double exists in memory on the stack.</p>\n<p>References are <a href=\"https://stackoverflow.com/questions/3954764/how-is-refere\">usually implemented</a> to hold the machine address of the object they reference, which means Foo's reference member is holding a stack memory address. The object that exists at that address when Foo's constructor is called, does not exist after the constructor completes.</p>\n<p>On my machine, that stack memory is not automatically zeroed when the lifetime of the temporary ends, so in your code the reference returns the (former) object's value. In my code, when I reuse the stack memory previously occupied by the temporary (via alloca and memset), that memory is (correctly) overwritten and future uses of the reference reflect the state of the memory at the address, which no longer has any relationship to the temporary. In both cases the memory address is valid, so no segfault is triggered.</p>\n<hr>\n<p>I added make_foo and used alloca and std::memset because of some compiler-specific behavior and so I could use the intuitive name \"stack\", but I could have just as easily done this instead which achieves similar results:</p>\n<pre><code>Foo p = Foo(123.0 + 2.0);\nstd::vector&lt;unsigned char&gt; v(1024, 0);\nstd::cout &lt;&lt; p.GetF() &lt;&lt; std::endl;\n</code></pre>\n</hr></hr>", "OwnerUserId": "1800880", "PostTypeId": "2", "Id": "45387203", "Score": "1", "CreationDate": "2017-07-29T08:36:42.307", "LastActivityDate": "2017-07-29T08:36:42.307"}, "45385530": {"ParentId": "45385433", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_45385433_45385530_0\">But it doesn't crash at all. I've also used valgrind to test the program but no error or warning occured.</p>\n</blockquote>\n<p>Ah, the joy of debugging undefined behaviour. It's possible that the compiler compiles invalid code to something where tools can no longer detect that it's invalid, and that's what happens here.</p>\n<p>From the OS perspective, and from valgrind's perspective, the memory that <code>f</code> references is still valid, therefore it doesn't crash, and valgrind doesn't report anything wrong. The fact that you see an output value of <code>0</code> means the compiler has, in your case, re-used the memory that was formerly used for the temporary object to store some other unrelated value.</p>\n<p>It should be clear that attempts to access that unrelated value through a reference to an already-deleted object are invalid.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "45385530", "Score": "3", "CreationDate": "2017-07-29T05:11:23.117", "LastActivityDate": "2017-07-29T05:11:23.117"}, "45385452": {"ParentId": "45385433", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, this is not safe. More precisely this is <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">UB</a>, means anything is possible.</p>\n<p>When you pass <code>123.0 + 2.0</code> to the constructor of <code>Foo</code>, a temporary <code>double</code> will be constructed and bound to the parameter <code>fx</code>. The temporary will be destroyed after the full expression (i.e. <code>Foo p(123.0 + 2.0);</code>), then the reference member <code>f</code> will become dangled. </p>\n<p>Note that the <a href=\"http://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary\" rel=\"nofollow noreferrer\">temporary's lifetime</a> won't be extended to the lifetime of the reference member <code>f</code>.</p>\n<blockquote>\n<p id=\"so_45385433_45385452_0\">In general, the lifetime of a temporary cannot be further extended by \"passing it on\": a second reference, initialized from the reference to which the temporary was bound, does not affect its lifetime.</p>\n</blockquote>\n<p>And from the standard, $15.6.2/8 <a href=\"http://eel.is/c++draft/class.base.init#8\" rel=\"nofollow noreferrer\">Initializing bases and members [class.base.init]</a></p>\n<blockquote>\n<p id=\"so_45385433_45385452_1\">A temporary expression bound to a reference member in a\n  mem-initializer is ill-formed. [\u2009Example:</p>\n<pre><code>struct A {\n  A() : v(42) { }   // error\n  const int&amp; v;\n};\n</code></pre>\n<p id=\"so_45385433_45385452_2\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2017-07-29T05:44:55.463", "Id": "45385452", "Score": "4", "CreationDate": "2017-07-29T04:59:10.710", "LastActivityDate": "2017-07-29T05:44:55.463"}, "45385433": {"CommentCount": "2", "ViewCount": "122", "LastEditDate": "2017-07-29T05:44:49.010", "LastEditorUserId": "3309790", "CreationDate": "2017-07-29T04:56:07.477", "LastActivityDate": "2017-08-02T20:41:43.873", "PostTypeId": "1", "Title": "Is it safe to make a const reference member to a temporary variable?", "Id": "45385433", "OwnerUserId": "7472038", "Body": "<p>I've tried to code like this several times:</p>\n<pre><code>struct Foo\n{\n    double const&amp; f;\n    Foo(double const&amp; fx) : f(fx)\n    {\n        printf(\"%f %f\\n\", fx, this-&gt;f); // 125 125\n    }\n\n    double GetF() const\n    {\n        return f;\n    }\n};\nint main()\n{\n    Foo p(123.0 + 2.0);\n    printf(\"%f\\n\", p.GetF()); // 0\n    return 0;\n}\n</code></pre>\n<p>But it doesn't crash at all. I've also used <em>valgrind</em> to test the program but no error or warning occured. So, I assume that the compiler automatically generated a code directing the reference to another hidden variable. But I'm really not sure.</p>\n", "Tags": "<c++><reference><const><temporary>", "Score": "4", "AnswerCount": "5"}, "45385566": {"ParentId": "45385433", "CommentCount": "0", "Body": "<p>If the temporary variable exists at the point where the reference is used, then the behaviour is well defined.</p>\n<p>If the temporary ceases to exist before the reference is used, then the behaviour of using the reference is undefined.</p>\n<p>Unfortunately, your code is an example of the latter.  The temporary which holds the result of <code>123.0 + 2.0</code> ceases to exist when the statement <code>Foo p(123.0 + 2.0)</code> finishes.    The next statement <code>printf(\"%f\\n\", p.GetF())</code> then accesses a reference to that temporary which no longer exists.</p>\n<p>Generally speaking, undefined behaviour is considered unsafe - it means there is no requirement on what the code actually does.   The result you are seeing in testing is not guaranteed.</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "45385566", "Score": "0", "CreationDate": "2017-07-29T05:17:02.583", "LastActivityDate": "2017-07-29T05:17:02.583"}, "45470636": {"ParentId": "45385433", "CommentCount": "0", "Body": "<p>This is indeed unsafe (it has undefined behavior), and the asan <a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterScope\" rel=\"nofollow noreferrer\">AddressSanitizerUseAfterScope</a> will detect this:</p>\n<pre><code>$ g++ -ggdb3 a.cpp -fsanitize=address -fsanitize-address-use-after-scope &amp;&amp; ./a.out\n125.000000 125.000000\n=================================================================\n==11748==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff1bbfdab0 at pc 0x000000400b80 bp 0x7fff1bbfda20 sp 0x7fff1bbfda18\nREAD of size 8 at 0x7fff1bbfdab0 thread T0\n    #0 0x400b7f in Foo::GetF() const a.cpp:12\n    #1 0x4009ca in main a.cpp:18\n    #2 0x7fac0bd05d5c in __libc_start_main (/lib64/libc.so.6+0x1ed5c)\n    #3 0x400808  (a.out+0x400808)\n\nAddress 0x7fff1bbfdab0 is located in stack of thread T0 at offset 96 in frame\n    #0 0x4008e6 in main a.cpp:16\n\n  This frame has 2 object(s):\n    [32, 40) 'p'\n    [96, 104) '&lt;unknown&gt;' &lt;== Memory access at offset 96 is inside this variable\n</code></pre>\n<p>In order to use AddressSanitizerUseAfterScope, you need to run Clang 5.0 or gcc 7.1.</p>\n<p>Valgrind is good at detecting invalid use of heap memory, but because it runs on an unaltered program file it cannot in general detect stack use bugs.</p>\n<p>Your code is unsafe because the parameter <code>double const&amp; fx</code> is bound to a temporary, a materialized prvalue double with value 125.0. This temporary has lifetime terminating at the end of the statement-expression <code>Foo p(123.0 + 2.0)</code>.</p>\n<p>One way to make your code safe is to use aggregate lifetime extension (<a href=\"https://stackoverflow.com/questions/23892018/extending-temporarys-lifetime-through-rvalue-data-member-works-with-aggregate\">Extending temporary's lifetime through rvalue data-member works with aggregate, but not with constructor, why?</a>), by removing the constructor <code>Foo::Foo(double const&amp;)</code>, and changing the initializer of <code>p</code> to use the list-initialization syntax:</p>\n<pre><code>Foo p{123.0 + 2.0};\n//   ^           ^\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "45470636", "Score": "0", "CreationDate": "2017-08-02T20:41:43.873", "LastActivityDate": "2017-08-02T20:41:43.873"}, "bq_ids": {"n4659": {"so_45385433_45385452_1": {"section_id": 453, "quality": 0.875, "length": 7}}}});