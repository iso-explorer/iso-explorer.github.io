post_cb({"26648817": {"CommentCount": "1", "AcceptedAnswerId": "26649961", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-10-30T09:04:11.050", "LastActivityDate": "2017-02-01T11:14:42.783", "LastEditDate": "2014-10-30T17:58:25.327", "ViewCount": "6161", "FavoriteCount": "7", "Title": "What is the correct way to initialize static data members in C++ (98, 11 and 14)", "Id": "26648817", "Score": "20", "Body": "<p>What is the right way to initialize <code>static</code> data members in C++? I'm also interested in how it has changed from C++98, to C++11 to C++14.</p>\n<p>Here is an example:</p>\n<pre><code>// bufferedOutput.h\nclass BufferedOutput\n{\n // Static member declaration.\n static long bytecount;\n};\n\n// bufferedOutput.cpp\nlong BufferedOutput::bytecount = 50;\n</code></pre>\n<p>Are there other ways to initialize <code>static</code> data members?</p>\n", "Tags": "<c++><c++11><static-members><c++14><c++98>", "OwnerUserId": "257942", "AnswerCount": "1"}, "26649961": {"ParentId": "26648817", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>For static data members of non-literal or non-const type, such as <code>vector&lt;int&gt;</code> or <code>bytecount</code> from your example, the definition and not the declaration must provide an initializer (if any). Don't forget that the declaration in class is only a declaration and <em>never</em> a definition*. <br>\nThe interesting cases are the types for which initializers can only or must be in class. The following quotes represent the rules in C++03 and C++11; C++14 took C++11's specifications over without changes. </br></p>\n<p>C++03, [class.static.data]/4:</p>\n<blockquote>\n<p id=\"so_26648817_26649961_0\">If a <code>static</code> data member is of <code>const</code> integral or <code>const</code>\n  enumeration type, its declaration in the class definition <strong>can</strong> specify\n  a <em>constant-initializer</em> which shall be an integral constant\n  expression (5.19). In that case, the member can appear in integral\n  constant expressions. The member shall still be defined in a\n  name-space scope if it is used in the program and the namespace scope\n  definition shall not contain an initializer.</p>\n</blockquote>\n<p>C++11, [class.static.data]/3 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26648817_26649961_1\">If a non-volatile <code>const</code> <code>static</code> data member is of integral or\n  enumeration type, its declaration in the class definition <strong>can</strong> specify\n  a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is\n  an <em>assignment-expression</em> is a constant expression (5.19). A <code>static</code>\n  data member of literal type can be declared in the class definition\n  with the <code>constexpr</code> specifier; if so, its declaration <strong>shall</strong> specify a\n  <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is\n  an <em>assignment-expression</em> is a constant expression. [ <em>Note:</em> In both\n  these cases, the member may appear in constant expressions. <em>\u2014 end note</em>\n  ] The member shall still be defined in a namespace scope if it is\n  odr-used (3.2) in the program and the namespace scope definition shall\n  not contain an initializer.</p>\n</blockquote>\n<p>Ever since C++03, you could only initialize static data members of\n<strong><code>const</code> integral or enumeration type</strong> at their in-class declaration:</p>\n<pre><code>struct A {\n    static const int i = 7;\n};\n\nconst int A::i; // definition\n</code></pre>\n<p>As of C++11, that also applies to variables declared <code>constexpr</code> (which implies <code>const</code>). However, those variables need not have integral type -  the rule applies to <strong>literal types</strong> ([basic.types]/10) in general. Those are defined as follows (the definition was amended several times,  this is C++14's):</p>\n<blockquote>\n<p id=\"so_26648817_26649961_2\">A type is a <em>literal type</em> if it is: <br>\n  \u2014 <code>void</code>; or</br></p>\n<p id=\"so_26648817_26649961_3\">\u2014 a scalar type; or<br/></p>\n<p id=\"so_26648817_26649961_4\">\u2014 a reference type referring to a literal type; or<br/></p>\n<p id=\"so_26648817_26649961_5\">\u2014 an array of literal type; or<br/></p>\n<p id=\"so_26648817_26649961_6\">\u2014 a class type (Clause 9) that has all of the following properties:</p>\n<ul>\n<li><p id=\"so_26648817_26649961_7\">it has a trivial destructor,</p></li>\n<li><p id=\"so_26648817_26649961_8\">it is an aggregate type (8.5.1) or has at least one <code>constexpr</code> constructor or constructor template that is not a copy or move\n  constructor, and</p></li>\n<li><p id=\"so_26648817_26649961_9\">all of its non-static data members and base classes are of non-volatile literal types.</p></li>\n</ul>\n</blockquote>\n<hr>\n<p>To sum up:</p>\n<ul>\n<li>In C++03 and C++11, a <code>const</code> static data member of integral or enumeration type <strong>can</strong> be initialized in class with a constant expression.</li>\n<li>In C++11, a <code>constexpr</code> static data member of literal type <strong>must</strong> be initialized in class with a constant expression.</li>\n<li>In both standards, non-literal entities <strong>can</strong> have an initializer at their outside class definition.</li>\n<li>Such variables are always zero-initialized before any other initialization is done.</li>\n</ul>\n<p>There is really no other way to initialize static data members -- it has to either be inside the class definition at the declaration of the variable, or outside, at its definition (if any). You can omit an initializer but variables with static storage duration get zero-initialized anyway, see [basic.stc.static]/4 and [basic.start.init]/2. So for every static data member there is exactly one way of adding an initializer.</p>\n<p>An example of the aforementioned rules:  </p>\n<pre><code>// A is a literal type:\nstruct A\n{\n    int i;\n    A&amp; a;\n    constexpr A(int i) : i(i), a(*this) {}\n};\n\nstruct StaticDataMembers\n{\n    static constexpr A a = 78;\n    static const A a2; // Can have initializer in definition\n    static constexpr A const&amp; a_ref = a;\n\n    static constexpr int i = 79;\n    static const int i2 = 84; \n    //static const int iarr[] = {i, i2}; // error!\n    static constexpr int iarr[] = {i, i2}; // Okay; Array of literal types is a literal type\n\n    //static const float f = 1.58f; // error!\n    static constexpr float f = 1.58f; // Okay; constexpr\n\n    static const std::string str; // Can have initializer in definition\n    static const int i3; // Only zero initialized.\n    static constexpr int i4; // Error! No initializer.\n};\n</code></pre>\n<p>Note that if you odr-use the member a definition <em>must</em> be in place, even if you provide an initializer in class -- that is because the declaration in class is not a definition*. So if you e.g. pass <code>i2</code> to a function template that does perfect forwarding you'll have to provide a definition like so:</p>\n<pre><code>const int StaticDataMembers::i2; \n</code></pre>\n<p><br>\nIt is also noteworthy that apart from the zero-initialization just mentioned every <code>static</code> data member that can or must have an initializer in class is subject to <em>constant initialization</em>, and every <code>static</code> data member that can have initializers at its definition is subject to <em>dynamic initialization</em> if it's not a literal type. [basic.start.init]/2:</br></p>\n<blockquote>\n<p id=\"so_26648817_26649961_10\"><em>Constant initialization</em> is performed:</p>\n<ul>\n<li><p id=\"so_26648817_26649961_11\">if each full-expression (including implicit conversions) that appears in the initializer of a reference with static or thread\n  storage duration is a constant expression (5.19) and the reference is\n  bound to an lvalue designating an object with static storage duration\n  or to a temporary (see 12.2);</p></li>\n<li><p id=\"so_26648817_26649961_12\">if an object with static or thread storage duration is initialized by a constructor call, if the constructor is a <code>constexpr</code>\n  constructor, if all constructor arguments are constant expressions\n  (including conversions), and if, after function invocation\n  substitution (7.1.5), every constructor call and full-expression in\n  the <em>mem-initializer</em>s and in the <em>brace-or-equal-initializer</em>s for\n  non-static data members is a constant expression;</p></li>\n<li><p id=\"so_26648817_26649961_13\">if an object with static or thread storage duration is not initialized by a constructor call and if every full-expression that\n  appears in its initializer is a constant expression.</p></li>\n</ul>\n<p id=\"so_26648817_26649961_14\">Together, zero-initialization and constant initialization are called\n  <em>static initialization</em>; all other initialization is <em>dynamic initialization</em>. Static initialization shall be performed before any\n  dynamic initialization takes place. </p>\n</blockquote>\n<hr>\n<p>* [basic.def]/2:</p>\n<blockquote>\n<p id=\"so_26648817_26649961_15\">A declaration is a <em>definition</em> unless it [...] it declares a static\n  data member in a class definition [...]</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2017-02-01T11:14:42.783", "Id": "26649961", "Score": "23", "CreationDate": "2014-10-30T09:59:21.757", "LastActivityDate": "2017-02-01T11:14:42.783"}, "bq_ids": {"n4140": {"so_26648817_26649961_9": {"section_id": 7208, "quality": 1.0, "length": 10}, "so_26648817_26649961_2": {"section_id": 4706, "quality": 1.0, "length": 4}, "so_26648817_26649961_6": {"section_id": 7208, "quality": 1.0, "length": 6}, "so_26648817_26649961_1": {"section_id": 5908, "quality": 0.9206349206349206, "length": 58}, "so_26648817_26649961_14": {"section_id": 7151, "quality": 0.9, "length": 18}, "so_26648817_26649961_13": {"section_id": 7151, "quality": 1.0, "length": 15}, "so_26648817_26649961_4": {"section_id": 3285, "quality": 0.8, "length": 4}, "so_26648817_26649961_11": {"section_id": 7151, "quality": 0.9230769230769231, "length": 24}, "so_26648817_26649961_0": {"section_id": 5908, "quality": 0.7567567567567568, "length": 28}, "so_26648817_26649961_8": {"section_id": 7208, "quality": 0.9166666666666666, "length": 11}, "so_26648817_26649961_15": {"section_id": 5907, "quality": 0.875, "length": 7}}, "n3337": {"so_26648817_26649961_2": {"section_id": 4515, "quality": 1.0, "length": 4}, "so_26648817_26649961_1": {"section_id": 5680, "quality": 0.9206349206349206, "length": 58}, "so_26648817_26649961_13": {"section_id": 6895, "quality": 1.0, "length": 15}, "so_26648817_26649961_0": {"section_id": 5680, "quality": 0.7567567567567568, "length": 28}, "so_26648817_26649961_8": {"section_id": 6952, "quality": 0.9166666666666666, "length": 11}, "so_26648817_26649961_14": {"section_id": 6895, "quality": 0.9, "length": 18}, "so_26648817_26649961_6": {"section_id": 6952, "quality": 1.0, "length": 6}, "so_26648817_26649961_11": {"section_id": 6895, "quality": 0.9230769230769231, "length": 24}, "so_26648817_26649961_12": {"section_id": 6895, "quality": 0.9705882352941176, "length": 33}, "so_26648817_26649961_4": {"section_id": 6952, "quality": 1.0, "length": 5}, "so_26648817_26649961_9": {"section_id": 6952, "quality": 0.9, "length": 9}, "so_26648817_26649961_15": {"section_id": 5679, "quality": 0.875, "length": 7}}, "n4659": {"so_26648817_26649961_6": {"section_id": 8717, "quality": 1.0, "length": 6}, "so_26648817_26649961_14": {"section_id": 8652, "quality": 0.7, "length": 14}, "so_26648817_26649961_13": {"section_id": 8652, "quality": 0.5333333333333333, "length": 8}, "so_26648817_26649961_4": {"section_id": 4047, "quality": 0.8, "length": 4}, "so_26648817_26649961_9": {"section_id": 8717, "quality": 1.0, "length": 10}, "so_26648817_26649961_0": {"section_id": 7390, "quality": 0.6486486486486487, "length": 24}, "so_26648817_26649961_8": {"section_id": 8717, "quality": 0.9166666666666666, "length": 11}, "so_26648817_26649961_15": {"section_id": 7389, "quality": 0.875, "length": 7}}}});