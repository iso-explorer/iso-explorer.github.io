post_cb({"34366370": {"ParentId": "34365746", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-12-19T01:39:32.457", "Score": "11", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:56.390", "Id": "34366370", "OwnerUserId": "4345926", "Body": "<p>This question may evidently have different answers on different systems, and in this sense it is ill-posed from the start. For example an i486 has no pipeline and a pentium has no SSE. </p>\n<blockquote>\n<p id=\"so_34365746_34366370_0\">The correct question to ask would be: \" <em>what is the fastest way to\n  convert a <strong>single</strong> char hex to dec in <strong>X</strong> system , e.g. i686</em> \" .</p>\n</blockquote>\n<p>Among approaches herein, the answer to this is actually the same or very very very nearly the same on a system with a multi-stage pipeline. Any system without a pipeline will bend towards the lookup table method (LUT), but if memory access is slow the conditional method (CEV), or the bitwise evaluation method (BEV), may profit depending of the speed of xor vs load for the given CPU. </p>\n<p>(CEV) decomposes into 2 load effective addresses a comparison and a conditional move from registers <a href=\"https://stackoverflow.com/a/14131292/4345926\">which is not prone to mis-prediction</a>. All these commands are pairable in the pentium pipeline. So they actually go in 1-cycle. </p>\n<pre><code>  8d 57 d0                lea    -0x30(%rdi),%edx\n  83 ff 39                cmp    $0x39,%edi\n  8d 47 a9                lea    -0x57(%rdi),%eax\n  0f 4e c2                cmovle %edx,%eax\n</code></pre>\n<p>The (LUT) decomposes into a mov between registers and mov from a data dependent memory location plus some nops for alignment, and should take the minimum of 1-cycle. As the previous there are only data dependencies. </p>\n<pre><code>  48 63 ff                movslq %edi,%rdi\n  8b 04 bd 00 1d 40 00    mov    0x401d00(,%rdi,4),%eax\n</code></pre>\n<p>The (BEV) is a different beast as it actually requires 2 movs + 2 xors + 1 and a conditional mov. These can also be nicely pipelined.</p>\n<pre><code>  89 fa                   mov    %edi,%edx\n  89 f8                   mov    %edi,%eax\n  83 f2 57                xor    $0x57,%edx\n  83 f0 30                xor    $0x30,%eax\n  83 e7 40                and    $0x40,%edi\n  0f 45 c2                cmovne %edx,%eax\n</code></pre>\n<p>Of course, it is a very rare occasion that it is application critical (maybe Mars Pathfinder is a candidate) to convert <strong>just a signle char</strong>. Instead one would expect to convert a larger string by actually making a loop and calling that function.</p>\n<p>Thus on such a scenario the code that is better vectorizable is the winner. The LUT does not vectorize, and BEV and CEV have better behaviour. <em>In general such micro-optimization does not get you anywhere, write your code and let live (i.e. let the compiler run).</em></p>\n<p>So I have actually built some tests in this sense that are <strong>easily reproducible</strong> on any system with a c++11 compiler and a random device source,such as any *nix system. If one does not permit vectorization <code>-O2</code> CEV/LUT are almost equal, but once <code>-O3</code> is set the advantage of writing code that is more decomposable shows the difference.</p>\n<blockquote>\n<p id=\"so_34365746_34366370_1\">To summarised, <strong>if you have an old compiler use LUT, if\n  your system is low-end or old consider BEV, otherwise the compiler\n  will outsmart you and you should use CEV</strong>.</p>\n</blockquote>\n<hr>\n<p><strong>Problem</strong>: in question is to convert from the set of chars {0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f} to the set of {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}. There are no capital letters under consideration.</p>\n<p>The idea is to take advantage of the linearity of the ascii table in segments. </p>\n<p><strong>[Simple and easy]: Conditional evaluation -&gt; CEV</strong></p>\n<pre><code>int decfromhex(int const x)\n{\nreturn x&lt;58?x-48:x-87;\n}\n</code></pre>\n<p><strong>[Dirty and complex]: Bitwise evaluation -&gt; BEV</strong></p>\n<pre><code>int decfromhex(int const x)\n{\nreturn 9*(x&amp;16)+( x &amp; 0xf  );\n}\n</code></pre>\n<p><strong>[compile time]: Template conditional evaluation -&gt; TCV</strong></p>\n<pre><code>template&lt;char n&gt; int decfromhex()\n{\n  int constexpr x = n;\n  return x&lt;58 ? x-48 : x -87;\n}\n</code></pre>\n<p><strong>[Lookup table]: Lookup table -&gt; LUT</strong></p>\n<pre><code>int decfromhex(char n)\n{\nstatic int constexpr x[255]={\n           // fill everything with invalid, e.g. -1 except places\\\n           // 48-57 and 97-102 where you place 0..15 \n           };\nreturn x[n];\n}\n</code></pre>\n<p>Among all , the last seems to be the fastest <strong>at first look</strong>. The second is only at compile time and constant expression. </p>\n<blockquote>\n<p id=\"so_34365746_34366370_2\"><strong>[RESULT]</strong> (<em>Please verify</em>): <strong>*BEV is the fastest among all and handles lower and upper case letter</strong> , but only marginal to <strong>CEV</strong> which does not handle capital letters. LUT becomes slower than both CEV and BEV as the size of the string increases.</p>\n</blockquote>\n<p>An exemplary result for str-sizes 16-12384 can be found below ( <strong>lower is better</strong> )</p>\n<p><a href=\"https://i.stack.imgur.com/2e1Vk.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/2e1Vk.png\"/></a></p>\n<p>The average time (100 runs ) along is show. The size of the bubble is the normal error. </p>\n<p><a href=\"http://pastebin.com/RenzEmE8\" rel=\"nofollow noreferrer\">The script for running the tests is available.</a></p>\n<hr>\n<p>Tests have been performed for the <code>conditional</code> <strong>CEV</strong>, the <code>bitwise</code> <strong>BEV</strong> and the <code>lookup table</code> <strong>LUT</strong> on a set of randomly generated strings. The tests are fairly simple and from:</p>\n<p><a href=\"http://pastebin.com/MJmK8u4P\" rel=\"nofollow noreferrer\">Test source code</a></p>\n<p>these are verifiable:</p>\n<ol>\n<li>A <strong>local copy of the input</strong> string is placed in a local buffer every time.</li>\n<li>A <strong>local copy of the results</strong> is kept that is then copied to the heap for every string test</li>\n<li><strong>Duration</strong> only for the time operating on the string is extracted</li>\n<li><strong>uniform approach</strong>, there is no complicated machinery and wrap/around code that is fitted for other cases.</li>\n<li><strong>no sampling</strong> the entire timing sequence is used</li>\n<li>CPU preheating is executed</li>\n<li><strong>Sleep</strong> between tests occur to permit marshal the code such that one test does not take advantage of the previous test.</li>\n<li><strong>Compilation</strong> is performed with <code>g++ -std=c++11 -O3 -march=native dectohex.cpp -o d2h</code></li>\n<li><strong>Launch</strong> with <code>taskset -c 0 d2h</code></li>\n<li>No thread dependencies or multithreading</li>\n<li>The results are actually being used, to avoid any type of loop optimization</li>\n</ol>\n<p>As a side note I have seen in practice version 3 to be much faster with older c++98 compilers.</p>\n<blockquote>\n<p id=\"so_34365746_34366370_3\"><strong>[BOTTOM LINE]</strong>: use <strong>CEV</strong> without fear, unless you know your variables at compile time where you could use version <strong>TCV</strong>. The <strong>LUT</strong>\n  should only be used after significant performance per use case\n  evaluation, and probably with older compilers. Another case is when\n  your set is larger i.e. {0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,A,B,C,D,E,F}\n  . This can be achieved as well. Finally if you are permormance hungry use <strong>BEV</strong> .</p>\n</blockquote>\n<p>The results with the <em>unordered_map</em> have been removed since they have been just too slow to compare, or at best case may be as fast as the LUT solution.</p>\n<p>Results from my personal pc on strings of size 12384/256 and for 100 strings:</p>\n<pre><code> g++ -DS=2 -DSTR_SIZE=256 -DSET_SIZE=100 -DUNITS=nanoseconds -O3 -std=c++11 -march=native dectohex.cpp -o d2h &amp;&amp; taskset -c 0 ./d2h\nsign: -2709\n-------------------------------------------------------------------\n(CEV) Total: 185568 nanoseconds - mean: 323.98 nanoseconds  error: 88.2699 nanoseconds\n(BEV) Total: 185568 nanoseconds - mean: 337.68 nanoseconds  error: 113.784 nanoseconds\n(LUT) Total: 229612 nanoseconds - mean: 667.89 nanoseconds  error: 441.824 nanoseconds\n-------------------------------------------------------------------\n\n\ng++ -DS=2 -DSTR_SIZE=12384 -DSET_SIZE=100 -DUNITS=nanoseconds -O3 -std=c++11 -march=native hextodec.cpp -o d2h &amp;&amp; taskset -c 0 ./h2d\n\n-------------------------------------------------------------------\n(CEV) Total: 5539902 nanoseconds - mean: 6229.1 nanoseconds error: 1052.45 nanoseconds\n(BEV) Total: 5539902 nanoseconds - mean: 5911.64 nanoseconds    error: 1547.27 nanoseconds\n(LUT) Total: 6346209 nanoseconds - mean: 14384.6 nanoseconds    error: 1795.71 nanoseconds\n-------------------------------------------------------------------\nPrecision: 1 ns\n</code></pre>\n<p>The results from a system with GCC 4.9.3 compiled to the metal without the system being loaded on strings of size 256/12384 and for 100 strings</p>\n<pre><code>g++ -DS=2 -DSTR_SIZE=256 -DSET_SIZE=100 -DUNITS=nanoseconds -O3 -std=c++11 -march=native dectohex.cpp -o d2h &amp;&amp; taskset -c 0 ./d2h\nsign: -2882\n-------------------------------------------------------------------\n(CEV) Total: 237449 nanoseconds - mean: 444.17 nanoseconds  error: 117.337 nanoseconds\n(BEV) Total: 237449 nanoseconds - mean: 413.59 nanoseconds  error: 109.973 nanoseconds\n(LUT) Total: 262469 nanoseconds - mean: 731.61 nanoseconds  error: 11.7507 nanoseconds\n-------------------------------------------------------------------\nPrecision: 1 ns\n\n\ng++ -DS=2 -DSTR_SIZE=12384 -DSET_SIZE=100 -DUNITS=nanoseconds -O3 -std=c++11 -march=native dectohex.cpp -o d2h &amp;&amp; taskset -c 0 ./d2h\nsign: -137532\n-------------------------------------------------------------------\n(CEV) Total: 6834796 nanoseconds - mean: 9138.93 nanoseconds    error: 144.134 nanoseconds\n(BEV) Total: 6834796 nanoseconds - mean: 8588.37 nanoseconds    error: 4479.47 nanoseconds\n(LUT) Total: 8395700 nanoseconds - mean: 24171.1 nanoseconds    error: 1600.46 nanoseconds\n-------------------------------------------------------------------\nPrecision: 1 ns\n</code></pre>\n<p><strong>[HOW TO READ THE RESULTS]</strong></p>\n<p>The mean is shown on microseconds required to compute the string of the given size.</p>\n<p>The total time for each test is given. The mean is computed as the sum/total of timings to compute one string ( no other code in that region but could be vectorized, and that's ok) . The error is the standard deviation of the timings. </p>\n<p>The mean tell us what we should expect on average , and the error how much the timings have been following normality. In this case this is a fair measure of error only when it is small ( otherwise we should use something appropriate for positive distributions ). One usually should expect high errors in case of <em>cache miss</em> , <em>processor scheduling</em>, and many other factors.</p>\n<hr>\n<p>The code has a unique macro defined to run the tests, permits to define compile time variables to set up the tests, and prints complete information such as:</p>\n<pre><code>g++ -DS=2 -DSTR_SIZE=64 -DSET_SIZE=1000 -DUNITS=nanoseconds -O3 -std=c++11 -march=native dectohex.cpp -o d2h &amp;&amp; taskset -c 0 ./d2h\nsign: -6935\n-------------------------------------------------------------------\n(CEV) Total: 947378 nanoseconds - mean: 300.871 nanoseconds error: 442.644 nanoseconds\n(BEV) Total: 947378 nanoseconds - mean: 277.866 nanoseconds error: 43.7235 nanoseconds\n(LUT) Total: 1040307 nanoseconds - mean: 375.877 nanoseconds    error: 14.5706 nanoseconds\n-------------------------------------------------------------------\n</code></pre>\n<p>For example to run the test with a <code>2sec</code> pause on a str of size <code>256</code> for a total of <code>10000</code> different strings, output timings in <code>double precision</code>, and count in <code>nanoseconds</code> the following command compiles and runs the test.</p>\n<pre><code>g++ -DS=2 -DSTR_SIZE=256 -DSET_SIZE=10000 -DUTYPE=double -DUNITS=nanoseconds -O3 -std=c++11 -march=native dectohex.cpp -o d2h &amp;&amp; taskset -c 0 ./d2h\n</code></pre>\n</hr></hr></hr>", "LastActivityDate": "2016-01-05T13:03:27.517"}, "34365746": {"CommentCount": "13", "AcceptedAnswerId": "34365963", "PostTypeId": "1", "LastEditorUserId": "3308310", "CreationDate": "2015-12-19T00:01:04.940", "LastActivityDate": "2016-01-05T13:03:27.517", "LastEditDate": "2015-12-19T00:03:39.157", "ViewCount": "2090", "FavoriteCount": "6", "Title": "What's the fastest way to convert hex to integer in C++?", "Id": "34365746", "Score": "9", "Body": "<p>I'm trying to convert a hex <code>char</code> to integer as fast as possible.</p>\n<p>This is only one line:\n<code>int x = atoi(hex.c_str);</code></p>\n<p>Is there a faster way?</p>\n<p>Here, I have tried a more dynamic approach, and it's slightly faster.</p>\n<pre><code>int hextoint(char number) {\n    if (number == '0') {\n        return 0;\n    }\n    if (number == '1') {\n        return 1;\n    }\n    if (number == '2') {\n        return 2;\n    }\n    /*\n     *  3 through 8\n     */\n    if (number == '9') {\n        return 9;\n    }\n    if (number == 'a') {\n        return 10;\n    }\n    if (number == 'b') {\n        return 11;\n    }\n    if (number == 'c') {\n        return 12;\n    }\n    if (number == 'd') {\n        return 13;\n    }\n    if (number == 'e') {\n        return 14;\n    }\n    if (number == 'f') {\n        return 15;\n    }\n    return -1;\n}\n</code></pre>\n", "Tags": "<c++><performance><parsing><hex><converter>", "OwnerUserId": "3308310", "AnswerCount": "5"}, "34365865": {"ParentId": "34365746", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-12-19T00:16:09.273", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:56.390", "Id": "34365865", "OwnerUserId": "3723423", "Body": "<p>Assuming that your function is called for a valid hex digit, it will cost in average at least 8 comparison operations (and perhap's 7 jumps). Pretty expensive.  </p>\n<p>An alternative would be the more compact:  </p>\n<pre><code>if (number &gt;= '0' &amp;&amp; number&lt;='9') \n    return number-'0';\nelse if (number &gt;= 'a' &amp;&amp; number &lt;='f') \n    return number-'a'+0x0a; \nelse return -1; \n</code></pre>\n<p>Yet another alternative would be to use a <strong>lookup table</strong> (trade space against speed), that you would initialise only once, and then access directly:   </p>\n<pre><code>if (number&gt;=0) \n   return mytable[number]; \nelse return -1;   \n</code></pre>\n<p>If you want to convert more than one digit at a time, you could have a look at <a href=\"https://stackoverflow.com/questions/17261798/converting-a-hex-string-to-byte-array-in-c\">this question</a>)  </p>\n<p><strong>Edit: benchmark</strong></p>\n<p>Following <a href=\"https://stackoverflow.com/users/4842163/ike\">Ike</a>'s observations, Ive written a small informal benchmark (available <strong><a href=\"http://ideone.com/RrgKhd\" rel=\"nofollow noreferrer\">online</a></strong> here), that you can run on your favourite compiler.</p>\n<p>Conclusions: </p>\n<ul>\n<li>The lookup table is always the winner</li>\n<li>The switch better than the if-chain.    </li>\n<li>With msvc2015 (release), the second best is my compact version, surprisingly followed closely by the map version of <a href=\"https://stackoverflow.com/users/2352671/101010\">101010</a>.  </li>\n<li>With gcc on ideone, the second is the switch version followed by the compact version. \n<a href=\"https://i.stack.imgur.com/5DATG.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/5DATG.jpg\"/></a></li>\n</ul>\n", "LastActivityDate": "2015-12-19T11:39:09.070"}, "34365963": {"ParentId": "34365746", "PostTypeId": "2", "CommentCount": "16", "CreationDate": "2015-12-19T00:31:47.813", "Score": "15", "LastEditorUserId": "2352671", "LastEditDate": "2015-12-23T09:07:02.400", "Id": "34365963", "OwnerUserId": "2352671", "Body": "<h2>Proposed Solutions that Render Faster than the OP's if-else:</h2>\n<ul>\n<li><strong>Unordered Map Lookup Table</strong></li>\n</ul>\n<p>Provided that your input strings are always hex numbers you could define a lookup table as an <code>unordered_map</code>:</p>\n<pre><code>std::unordered_map&lt;char, int&gt; table {\n{'0', 0}, {'1', 1}, {'2', 2},\n{'3', 3}, {'4', 4}, {'5', 5},\n{'6', 6}, {'7', 7}, {'8', 8},\n{'9', 9}, {'a', 10}, {'A', 10},\n{'b', 11}, {'B', 11}, {'c', 12},\n{'C', 12}, {'d', 13}, {'D', 13},\n{'e', 14}, {'E', 14}, {'f', 15},\n{'F', 15}, {'x', 0}, {'X', 0}};\n\nint hextoint(char number) {\n  return table[(std::size_t)number];\n}\n</code></pre>\n<ul>\n<li><strong>Lookup Table as user <code>constexpr</code> literal (C++14)</strong></li>\n</ul>\n<p>Or if you want something more faster instead of an <code>unordered_map</code> you could use the new C++14 facilities with user literal types and define your table as a literal type at compile time:</p>\n<pre><code>struct Table {\n  long long tab[128];\n  constexpr Table() : tab {} {\n    tab['1'] = 1;\n    tab['2'] = 2;\n    tab['3'] = 3;\n    tab['4'] = 4;\n    tab['5'] = 5;\n    tab['6'] = 6;\n    tab['7'] = 7;\n    tab['8'] = 8;\n    tab['9'] = 9;\n    tab['a'] = 10;\n    tab['A'] = 10;\n    tab['b'] = 11;\n    tab['B'] = 11;\n    tab['c'] = 12;\n    tab['C'] = 12;\n    tab['d'] = 13;\n    tab['D'] = 13;\n    tab['e'] = 14;\n    tab['E'] = 14;\n    tab['f'] = 15;\n    tab['F'] = 15;\n  }\n  constexpr long long operator[](char const idx) const { return tab[(std::size_t) idx]; } \n} constexpr table;\n\nconstexpr int hextoint(char number) {\n  return table[(std::size_t)number];\n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/MCFhRTU7GteCzcwV\" rel=\"noreferrer\"><strong>Live Demo</strong></a></p>\n<h2>Benchmarks:</h2>\n<p>I ran benchmarks with the code written by Nikos Athanasiou that was posted recently on <a href=\"https://isocpp.org/blog/2015/04/https-ngathanasiou.wordpress.com-2015-04-01-benchmarking-in-c\" rel=\"noreferrer\">isocpp.org</a> as a proposed method for C++ micro-benchmarking.</p>\n<p>The algorithms that were compared are:</p>\n<p><strong>1. OP's original <code>if-else</code>:</strong></p>\n<blockquote id=\"so_34365746_34365963_0\">\n<pre><code>long long hextoint3(char number) {\n  if(number == '0') return 0;\n  if(number == '1') return 1;\n  if(number == '2') return 2;\n  if(number == '3') return 3;\n  if(number == '4') return 4;\n  if(number == '5') return 5;\n  if(number == '6') return 6;\n  if(number == '7') return 7;\n  if(number == '8') return 8;\n  if(number == '9') return 9;\n  if(number == 'a' || number == 'A') return 10;\n  if(number == 'b' || number == 'B') return 11;\n  if(number == 'c' || number == 'C') return 12;\n  if(number == 'd' || number == 'D') return 13;\n  if(number == 'e' || number == 'E') return 14;\n  if(number == 'f' || number == 'F') return 15;\n  return 0;\n}\n</code></pre>\n</blockquote>\n<p><strong>2. Compact if-else, proposed by Christophe:</strong></p>\n<blockquote id=\"so_34365746_34365963_1\">\n<pre><code>long long hextoint(char number) {\n  if (number &gt;= '0' &amp;&amp; number &lt;= '9') return number - '0';\n  else if (number &gt;= 'a' &amp;&amp; number &lt;= 'f') return number - 'a' + 0x0a;\n  else if (number &gt;= 'A' &amp;&amp; number &lt;= 'F') return number - 'A' + 0X0a;\n  else return 0;\n}\n</code></pre>\n</blockquote>\n<p><strong>3. Corrected ternary operator version that handles also capital letter inputs, proposed by g24l:</strong></p>\n<blockquote id=\"so_34365746_34365963_2\">\n<pre><code>long long hextoint(char in) {\n  int const x = in;\n  return (x &lt;= 57)? x - 48 : (x &lt;= 70)? (x - 65) + 0x0a : (x - 97) + 0x0a;\n}\n</code></pre>\n</blockquote>\n<p><strong>4. Lookup Table (<code>unordered_map</code>):</strong></p>\n<blockquote id=\"so_34365746_34365963_3\">\n<pre><code>long long hextoint(char number) {\n  return table[(std::size_t)number];\n}\n</code></pre>\n</blockquote>\n<p>where <code>table</code> is the unordered map shown previously.</p>\n<p><strong>5. Lookup Table (user <code>constexpr</code> literal):</strong></p>\n<blockquote id=\"so_34365746_34365963_4\">\n<pre><code>long long hextoint(char number) {\n  return table[(std::size_t)number];\n}\n</code></pre>\n</blockquote>\n<p>Where table is user defined literal as shown above.</p>\n<p><strong>Experimental Settings</strong></p>\n<p>I defined a function that transforms an input hex string to an integer:</p>\n<blockquote id=\"so_34365746_34365963_5\">\n<pre><code>long long hexstrtoint(std::string const &amp;str, long long(*f)(char)) {\n  long long ret = 0;\n  for(int j(1), i(str.size() - 1); i &gt;= 0; --i, j *= 16) {\n    ret += (j * f(str[i]));\n  }\n  return ret;\n}\n</code></pre>\n</blockquote>\n<p>I also defined a function that populates a vector of strings with random hex strings:</p>\n<blockquote id=\"so_34365746_34365963_6\">\n<pre><code>std::vector&lt;std::string&gt;\npopulate_vec(int const N) {\n  random_device rd;\n  mt19937 eng{ rd() };\n  uniform_int_distribution&lt;long long&gt; distr(0, std::numeric_limits&lt;long long&gt;::max() - 1);\n  std::vector&lt;std::string&gt; out(N);\n  for(int i(0); i &lt; N; ++i) {\n    out[i] = int_to_hex(distr(eng));\n  }\n  return out;\n}\n</code></pre>\n</blockquote>\n<p>I created vectors populated with 50000, 100000, 150000, 200000 and 250000 random hex strings respectively. Then for each algorithm I run 100 experiments and averaged the time results.</p>\n<p>Compiler was GCC version 5.2 with optimization option <code>-O3</code>.</p>\n<p><strong>Results:</strong></p>\n<p><a href=\"https://i.stack.imgur.com/IuuoP.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/IuuoP.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/7dMUM.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/7dMUM.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/2SVkL.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/2SVkL.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/M3GGw.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/M3GGw.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/WQzdE.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/WQzdE.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/Dhnjt.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Dhnjt.png\"/></a></p>\n<p><strong>Discussion</strong></p>\n<p>From the results we can conclude that for these experimental settings the proposed table method out-performs all the other methods. The if-else method is by far the worst where as the <code>unordered_map</code> although it wins the if-else method it is significantly slower than the other proposed methods.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d4c3df15011550a1\" rel=\"noreferrer\">CODE</a></p>\n<h2>Edit:</h2>\n<p>Results for method proposed by stgatilov, with bitwise operations:</p>\n<blockquote id=\"so_34365746_34365963_7\">\n<pre><code>long long hextoint(char x) {\n    int b = uint8_t(x);\n    int maskLetter = (('9' - b) &gt;&gt; 31);\n    int maskSmall = (('Z' - b) &gt;&gt; 31);\n    int offset = '0' + (maskLetter &amp; int('A' - '0' - 10)) + (maskSmall &amp; int('a' - 'A'));\n    return b - offset;\n}\n</code></pre>\n</blockquote>\n<p><a href=\"https://i.stack.imgur.com/qKx7k.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/qKx7k.png\"/></a></p>\n<p><strong>Edit:</strong></p>\n<p>I also tested the original code from g24l against the table method:</p>\n<blockquote id=\"so_34365746_34365963_8\">\n<pre><code>long long hextoint(char in) {\n  long long const x = in;\n  return x &lt; 58? x - 48 : x - 87;\n}\n</code></pre>\n</blockquote>\n<p>Note that this method doesn't handle capital letters <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code> and <code>F</code>.</p>\n<p><strong>Results:</strong></p>\n<p><a href=\"https://i.stack.imgur.com/KSqwu.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/KSqwu.png\"/></a></p>\n<p>Still the table method renders faster.</p>\n", "LastActivityDate": "2015-12-23T09:07:02.400"}, "34384242": {"ParentId": "34365746", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-12-20T18:19:44.250", "Score": "4", "LastEditorUserId": "556899", "LastEditDate": "2015-12-21T06:18:33.373", "Id": "34384242", "OwnerUserId": "556899", "Body": "<p>Well, that's a weird question. Converting a single hex char into an integer is so fast, that it is really hard to tell which is faster, because all methods are almost likely faster than the code you write in order to use them =)</p>\n<p>I'll assume the following things:</p>\n<ol>\n<li>We have a modern x86(64) CPU.</li>\n<li>The input character's ASCII code is stored in a general purpose register, e.g. in <code>eax</code>.</li>\n<li>The output integer must be obtained in a general purpose register.</li>\n<li>The input character is guaranteed to be a valid hex digit (one of 16 cases).</li>\n</ol>\n<h2>Solution</h2>\n<p>Now here are several methods for solving the problem: the first one based on lookup, two based on ternary operator, the last one based on bit operations:</p>\n<pre><code>int hextoint_lut(char x) {\n    static char lut[256] = {???};\n    return lut[uint8_t(x)];\n}\n\nint hextoint_cond(char x) {\n    uint32_t dig = x - '0';\n    uint32_t alp = dig + ('0' - 'a' + 10);\n    return dig &lt;= 9U ? dig : alp;\n}\nint hextoint_cond2(char x) {\n    uint32_t offset = (uint8_t(x) &lt;= uint8_t('9') ? '0' : 'a' - 10);\n    return uint8_t(x) - offset;\n}\n\nint hextoint_bit(char x) {\n    int b = uint8_t(x);\n    int mask = (('9' - b) &gt;&gt; 31);\n    int offset = '0' + (mask &amp; int('a' - '0' - 10));\n    return b - offset;\n}\n</code></pre>\n<p>Here are the corresponding assembly listings generated (only the relevant parts are shown):</p>\n<pre><code>;hextoint_lut;\nmovsx   eax, BYTE PTR [rax+rcx]   ; just load the byte =)\n\n;hextoint_cond;\nsub edx, 48                       ; subtract '0'\ncmp edx, 9                        ; compare to '9'\nlea eax, DWORD PTR [rdx-39]       ; add ('0' - 'a' + 10)\ncmovbe  eax, edx                  ; choose between two cases in branchless way\n\n;hextoint_cond2;                  ; (modified slightly)\nmov eax, 48                       \nmov edx, 87                       ; set two offsets to registers\ncmp ecx, 57                       ; compare with '9'\ncmovbe  edx, eax                  ; choose one offset\nsub ecx, edx                      ; subtract the offset\n\n;hextoint_bit;\nmov ecx, 57                       ; load '9'\nsub ecx, eax                      ; get '9' - x\nsar ecx, 31                       ; convert to mask if negative\nand ecx, 39                       ; set to 39 (for x &gt; '9')\nsub eax, ecx                      ; subtract 39 or 0\nsub eax, 48                       ; subtract '0'\n</code></pre>\n<h2>Analysis</h2>\n<p>I'll try to estimate number of cycles taken by each approach in throughput sense, which is essentially the time spent per one input number when a lot of numbers are processed at once. Consider a Sandy Bridge architecture as an example.</p>\n<p>The <code>hextoint_lut</code> function consists of a single memory load, which takes 1 uop on port 2 or 3. Both of these ports are dedicated to memory loads, and they also have address calculation inside, which are capable of doing <code>rax+rcx</code> with no additional cost. There are two such ports, each can do one uop in a cycle. So supposedly this version would take 0.5 clock time. If we have to load input number from memory, that would require one more memory load per value, so the total cost would be 1 clock.</p>\n<p>The <code>hextoint_cond</code> version has 4 instructions, but <code>cmov</code> is broken into two separate uops. So there are 5 uops in total, each can be processed on any of the three arithmetic ports 0, 1, and 5. So supposedly it would take 5/3 cycles  time. Note that memory load ports are free, so the time would not increase even if you have to load the input value from memory.</p>\n<p>The <code>hextoint_cond2</code> version has 5 instructions. But in a tight loop the constants can be preloaded to registers, so there would be only comparison, cmov and subtraction. They are 4 uops in total, giving 4/3 cycles per value (even with memory read).</p>\n<p>The <code>hextoint_bit</code> version is a solution which is guaranteed to have no branches and lookup, which is handy if you do not want to check always whether your compiler generated a cmov instruction. The first mov is free, since the constant can be preloaded in a tight loop. The rest are 5 arithmetic instructions, which a 5 uops in ports 0, 1, 5. So it should take 5/3 cycles (even with a memory read).</p>\n<h2>Benchmark</h2>\n<p>I have performed a benchmark for the C++ functions described above. In a benchmark, 64 KB of random data is generated, then each function is run many times on this data. All the results are added to checksum to ensure that compiler does not remove the code. Manual 8x unrolling is used. I have tested on a Ivy Bridge 3.4 Ghz core, which is very similar to Sandy Bridge. Each string of output contains: name of function, total time taken by benchmark, number of cycles per input value, sum of all outputs.</p>\n<p><a href=\"http://pastebin.com/9qsVYg8V\" rel=\"nofollow\">Benchmark code</a></p>\n<pre><code>MSVC2013 x64 /O2:\nhextoint_lut: 0.741 sec, 1.2 cycles  (check: -1022918656)\nhextoint_cond: 1.925 sec, 3.0 cycles  (check: -1022918656)\nhextoint_cond2: 1.660 sec, 2.6 cycles  (check: -1022918656)\nhextoint_bit: 1.400 sec, 2.2 cycles  (check: -1022918656)\n\nGCC 4.8.3 x64 -O3 -fno-tree-vectorize\nhextoint_lut: 0.702 sec, 1.1 cycles  (check: -1114112000)\nhextoint_cond: 1.513 sec, 2.4 cycles  (check: -1114112000)\nhextoint_cond2: 2.543 sec, 4.0 cycles  (check: -1114112000)\nhextoint_bit: 1.544 sec, 2.4 cycles  (check: -1114112000)\n\nGCC 4.8.3 x64 -O3\nhextoint_lut: 0.702 sec, 1.1 cycles  (check: -1114112000)\nhextoint_cond: 0.717 sec, 1.1 cycles  (check: -1114112000)\nhextoint_cond2: 0.468 sec, 0.7 cycles  (check: -1114112000)\nhextoint_bit: 0.577 sec, 0.9 cycles  (check: -1114112000)\n</code></pre>\n<p>Clearly, LUT approach takes one cycle per value (as predicted). The other approaches normally take from 2.2 to 2.6 cycles per value. In case of GCC, <code>hextoint_cond2</code> is slow because compiler uses cmp+sbb+and magic instead of desired cmov instructions. Also note that by default GCC vectorizes most of the approaches (last paragraph), which provides expectedly faster results than the unvectorizable LUT approach. Note that manual vectorization would give significantly  greater boost.</p>\n<h2>Discussion</h2>\n<p>Note that <code>hextoint_cond</code> with ordinary conditional jump instead of <code>cmov</code> would have a branch. Assuming random input hex digits, it will be mispredicted almost always. So performance would be terrible, I think.</p>\n<p>I have analysed throughput performance. But if we have to process tons of input values, then we should definitely vectorize the conversion to get better speed. <code>hextoint_cond</code> can be vectorized with SSE in a pretty straightforward way. It allows to process 16 bytes to 16 bytes by using only 4 instructions, taking about 2 cycles I suppose.</p>\n<p>Note that in order to see any performance difference, you must ensure that all the input values fit into cache (L1 is the best case). If you read the input data from main memory, even <code>std::atoi</code> is equally fast with the considered methods =)</p>\n<p>Also, you should unroll your main loop 4x or even 8x for maximum performance (to remove looping overhead).\nAs you might have already noticed, the speed of both methods highly depends on which operations are surrounding the code. E.g. adding a memory load doubles time taken by the first approach, but does not influence the other approaches.</p>\n<p><strong>P.S.</strong> Most likely you don't really need to optimize this.</p>\n", "LastActivityDate": "2015-12-21T06:18:33.373"}, "34573398": {"ParentId": "34365746", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-01-03T04:42:07.503", "Score": "2", "LastEditorUserId": "339937", "LastEditDate": "2016-01-03T05:30:26.773", "Id": "34573398", "OwnerUserId": "339937", "Body": "<p>This is my favorite hex-to-int code:</p>\n<pre><code>inline int htoi(int x) {\n    return 9 * (x &gt;&gt; 6) + (x &amp; 017);\n}\n</code></pre>\n<p>It is case-insensitive for letter, i.e will return correct result for \"a\" and \"A\".</p>\n", "LastActivityDate": "2016-01-03T05:30:26.773"}, "bq_ids": {"n4140": {"so_34365746_34365963_1": {"section_id": 3498, "quality": 0.5454545454545454, "length": 12}, "so_34365746_34365963_8": {"section_id": 2290, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_34365746_34365963_1": {"section_id": 3363, "quality": 0.5454545454545454, "length": 12}, "so_34365746_34365963_8": {"section_id": 2277, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_34365746_34365963_1": {"section_id": 4261, "quality": 0.5454545454545454, "length": 12}, "so_34365746_34365963_8": {"section_id": 2563, "quality": 0.7142857142857143, "length": 5}}}});