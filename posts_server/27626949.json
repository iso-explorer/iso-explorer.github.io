post_cb({"bq_ids": {"n4140": {"so_27626949_27627173_2": {"length": 24, "quality": 1.0, "section_id": 457}, "so_27626949_27627173_0": {"length": 7, "quality": 0.875, "section_id": 457}}, "n3337": {"so_27626949_27627173_2": {"length": 21, "quality": 0.875, "section_id": 448}, "so_27626949_27627173_0": {"length": 7, "quality": 0.875, "section_id": 448}}, "n4659": {"so_27626949_27627173_2": {"length": 24, "quality": 1.0, "section_id": 480}, "so_27626949_27627173_0": {"length": 7, "quality": 0.875, "section_id": 480}}}, "27627173": {"Id": "27627173", "PostTypeId": "2", "Body": "<p><code>std::pair</code> copy constructor is declared as follows:</p>\n<pre><code>pair(const pair&amp;) = default;\n</code></pre>\n<p>By declaring this copy constructor for <code>movable</code>:</p>\n<pre><code>movable(movable&amp;) = delete;\n</code></pre>\n<p>you inhibit implicit creation of <code>movable(const movable&amp;)</code> (so it's not even deleted, there's just no such constructor), thus this is the only copy constructor you have. But <code>std::pair</code> copy constructor requires a copy constructor of its members to take const reference, so you get compile error.</p>\n<p>If you add this:</p>\n<pre><code>movable(movable const&amp;) = delete;\n</code></pre>\n<p>or (better) just remove <code>movable(movable&amp;) = delete;</code> declaration, you now have the <code>movable(movable const&amp;)</code> constructor, and because it's deleted, the <code>std::pair</code> copy constructor also becomes deleted.</p>\n<p><strong>Update</strong>: Let's consider a simpler example demonstrating the same issue. This doesn't compile:</p>\n<pre><code>template &lt;typename T&gt;\nstruct holder {\n    T t;\n    // will compile if you comment the next line\n    holder(holder const&amp;) = default;\n    // adding or removing move constructor changes nothing WRT compile errors\n    // holder(holder&amp;&amp;) = default;\n};\n\nstruct movable {\n    movable() {}\n    movable(movable&amp;&amp;) = default;\n    // will also compile if you uncomment the next line\n    //movable(movable const&amp;) = delete;\n    movable(movable&amp;) = delete;\n};\n\nholder&lt;movable&gt; h{movable()};\n</code></pre>\n<p>It will compile if you comment the copy constructor of <code>holder</code>, because this is how implicit copy constructor generation works (<code>[class.copy]/8</code>:</p>\n<blockquote>\n<p id=\"so_27626949_27627173_0\">The implicitly-declared copy constructor for a class X will have the form</p>\n<p id=\"so_27626949_27627173_1\"><code>X::X(const X&amp;)</code></p>\n<p id=\"so_27626949_27627173_2\">if each potentially constructed subobject of a class type <code>M</code> (or array thereof) has a copy constructor whose first parameter is of type <code>const M&amp;</code> or <code>const volatile M&amp;</code>. Otherwise, the implicitly-declared copy constructor will have the form</p>\n<p id=\"so_27626949_27627173_3\"><code>X::X(X&amp;)</code></p>\n</blockquote>\n<p>That is, when you comment out the declaration <code>holder(holder const&amp;) = default;</code> the implicitly declared copy constructor of <code>holder</code> will have the form <code>holder(holder&amp;)</code>. But if you don't, <code>T</code>'s copy constructor has take <code>const T&amp;</code> (or <code>const volatile T&amp;</code>)  because this is what will be called in memberwise copy procedure described in <code>[class.copy]/15</code>.</p>\n<p>And if <code>holder</code> has a move constructor, it's even easier - if you comment out <code>holder(holder const&amp;) = default;</code>, the implicitly declared copy constructor of <code>holder</code> will be just deleted.</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-12-23T21:52:14.303", "Score": "8", "CreationDate": "2014-12-23T19:58:33.200", "ParentId": "27626949", "CommentCount": "8", "OwnerUserId": "3959454", "LastEditDate": "2014-12-23T21:52:14.303"}, "27626949": {"ViewCount": "1135", "Body": "<p>I'm busy testing an implementation of various generic algorithms and I'm using types with minimal support of provided functions. I came across this weird setup when using a <code>std::pair&lt;T, movable&gt;</code> with some type <code>T</code> (e.g., <code>int</code>) and a <code>movable</code> type defined like this:</p>\n<pre><code>struct movable\n{\n    movable() {}\n    movable(movable&amp;&amp;) = default;\n    // movable(movable const&amp;) = delete;\n    movable(movable&amp;) = delete;\n};\n</code></pre>\n<p>The idea is have a type which is movable but not copyable. That works great, e.g., with expressions like this:</p>\n<pre><code>movable m1 = movable();\nmovable m2 = std::move(m1);\n</code></pre>\n<p>However, when trying to use this type as a member of <code>std::pair&lt;...&gt;</code> it fails! To make get the code to compile it is necessary to add the <code>delete</code>d(!) copy constructor taking a <code>movable const&amp;</code> (or have only that version). The copy constructor taking a non-<code>const</code> reference is insufficient:</p>\n<pre><code>#include &lt;utility&gt;\nauto f() -&gt; std::pair&lt;int, movable&gt; {\n    return std::pair&lt;int, movable&gt;(int(), movable());\n}\n</code></pre>\n<p>What is going on here? Is <code>std::pair&lt;...&gt;</code> overspecified by mandating that <code>std::pair(std::pair const&amp;)</code> is <code>= default</code>ed?</p>\n<p>The problem seems to be down to the specification of <code>std::pair</code>'s copy constructor (in 20.3.2 [pairs.pair] synopsis):</p>\n<blockquote id=\"so_27626949_27626949_0\">\n<pre><code> namespace std {\n     template &lt;class T1, class T2&gt;\n     struct pair {\n         ...\n         pair(const pair&amp;) = default;\n         ...\n     };\n }\n</code></pre>\n</blockquote>\n<p>A quick check with my implementation implies that the obvious implementation copying the two members does <em>not</em> require the <code>const&amp;</code> version of the <code>movable</code> copy constructor. That is, the offensive part is the <code>= default</code> on <code>pair</code>'s copy constructor!</p>\n", "AcceptedAnswerId": "27627173", "Title": "Why does `std::pair<int, movable>` require a [deleted] `const&` copy constructor?", "CreationDate": "2014-12-23T19:39:52.140", "Id": "27626949", "CommentCount": "9", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-12-23T20:06:14.107", "LastEditorUserId": "1120273", "LastActivityDate": "2014-12-23T21:52:14.303", "Score": "18", "OwnerUserId": "1120273", "Tags": "<c++><c++11><stl><c++-standard-library>", "AnswerCount": "1"}});