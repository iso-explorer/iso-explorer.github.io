post_cb({"4173298": {"ParentId": "4173254", "PostTypeId": "2", "CommentCount": "20", "Body": "<p>In short, CRTP is when a class A has a base class which is a template specialization for the class A itself. E.g.</p>\n<pre><code>template &lt;class T&gt; \nclass X{...};\nclass A : public X&lt;A&gt; {...};\n</code></pre>\n<p>It <em>is</em> curiously recurring, isn't it? :)</p>\n<p>Now, what does this give you? This actually gives the X template the ability to be a base class for its specializations.  </p>\n<p>For example, you could make a generic singleton class (simplified version) like this</p>\n<pre><code>template &lt;class ActualClass&gt; \nclass Singleton\n{\n   public:\n     static ActualClass&amp; GetInstance()\n     {\n       if(p == nullptr)\n         p = new ActualClass;\n       return *p; \n     }\n\n   protected:\n     static ActualClass* p;\n   private:\n     Singleton(){}\n     Singleton(Singleton const &amp;);\n     Singleton&amp; operator = (Singleton const &amp;); \n};\ntemplate &lt;class T&gt;\nT* Singleton&lt;T&gt;::p = nullptr;\n</code></pre>\n<p>Now, in order to make an arbitrary class A a singleton you should do this</p>\n<pre><code>class A: public Singleton&lt;A&gt;\n{\n   //Rest of functionality for class A\n};\n</code></pre>\n<p>So you see? The singleton template assumes that its specialization for any type X will be inherited from <code>singleton&lt;X&gt;</code> and thus will have all its(public, protected) members accessible, including the <code>GetInstance</code>! There are other useful uses of CRTP. For example, if you want to count all instances that currently exist for your class, but want to encapsulate this logic in a separate template (the idea for a concrete class is quite simple - have a static variable, increment in ctors, decrement in dtors). Try to do it as an excercise! </p>\n<p>Yet another useful example, for boost(I am not sure how they have implemented it, but CRTP will do too).\nImagine you want to provide only operator &lt; for your classes but automatically operator == for them!</p>\n<p>you could do it like this:</p>\n<pre><code>template&lt;class Derived&gt;\nclass Equality\n{\n};\n\ntemplate &lt;class Derived&gt;\nbool operator == (Equality&lt;Derived&gt; const&amp; op1, Equality&lt;Derived&gt; const &amp; op2)\n{\n    Derived const&amp; d1 = static_cast&lt;Derived const&amp;&gt;(op1);//you assume this works     \n    //because you know that the dynamic type will actually be your template parameter.\n    //wonderful, isnit it?\n    Derived const&amp; d2 = static_cast&lt;Derived const&amp;&gt;(op2); \n    return !(d1 &lt; d2) &amp;&amp; !(d2 &lt; d1);//assuming derived has operator &lt;\n}\n</code></pre>\n<p>Now you can use it like this</p>\n<pre><code>struct Apple:public Equality&lt;Apple&gt; \n{\n    int size;\n};\n\nbool operator &lt; (Apple const &amp; a1, Apple const&amp; a2)\n{\n    return a1.size &lt; a2.size;\n}\n</code></pre>\n<p>now, you haven't provided explicitly operator == for apple? But you have it! You can write </p>\n<pre><code>int main()\n{\n    Apple a1;\n    Apple a2; \n\n    a1.size = 10;\n    a2.size = 10;\n    if(a1 == a2) //the compiler won't complain! \n    {\n    }\n}\n</code></pre>\n<p>This could seem that you would write less if you just wrote operator == for Apple, but imagine that the Equality template would provide not only == but &gt;, &gt;=, &lt;= etc. And you could use these definitions for <em>multiple</em> classes, reusing the code!</p>\n<p>CRTP is a wonderful thing :) HTH</p>\n", "OwnerUserId": "469935", "LastEditorUserId": "4653746", "LastEditDate": "2017-07-14T09:10:35.053", "Id": "4173298", "Score": "199", "CreationDate": "2010-11-13T15:40:00.733", "LastActivityDate": "2017-07-14T09:10:35.053"}, "26718782": {"ParentId": "4173254", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Here you can see a great example. If you use virtual method the program will know what execute in runtime. Implementing CRTP the compiler is which decide in compile time!!! This is a great performance!</p>\n<pre><code>template &lt;class T&gt;\nclass Writer\n{\n  public:\n    Writer()  { }\n    ~Writer()  { }\n\n    void write(const char* str) const\n    {\n      static_cast&lt;const T*&gt;(this)-&gt;writeImpl(str); //here the magic is!!!\n    }\n};\n\n\nclass FileWriter : public Writer&lt;FileWriter&gt;\n{\n  public:\n    FileWriter(FILE* aFile) { mFile = aFile; }\n    ~FileWriter() { fclose(mFile); }\n\n    //here comes the implementation of the write method on the subclass\n    void writeImpl(const char* str) const\n    {\n       fprintf(mFile, \"%s\\n\", str);\n    }\n\n  private:\n    FILE* mFile;\n};\n\n\nclass ConsoleWriter : public Writer&lt;ConsoleWriter&gt;\n{\n  public:\n    ConsoleWriter() { }\n    ~ConsoleWriter() { }\n\n    void writeImpl(const char* str) const\n    {\n      printf(\"%s\\n\", str);\n    }\n};\n</code></pre>\n", "OwnerUserId": "4211031", "LastEditorUserId": "5507349", "LastEditDate": "2016-11-26T21:06:38.297", "Id": "26718782", "Score": "25", "CreationDate": "2014-11-03T16:42:08.080", "LastActivityDate": "2016-11-26T21:06:38.297"}, "47514417": {"ParentId": "4173254", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is not a direct answer, but rather an example of how <em>CRTP</em> can be useful.</p>\n<hr>\n<p>A good concrete example of <em>CRTP</em> is <code>std::enable_shared_from_this</code> from C++11:</p>\n<blockquote>\n<p id=\"so_4173254_47514417_0\"><a href=\"http://eel.is/c++draft/util.smartptr.enab#1\" rel=\"nofollow noreferrer\">[util.smartptr.enab]/1</a></p>\n<p id=\"so_4173254_47514417_1\">A class <code>T</code> can inherit from <code>enable_\u00adshared_\u00adfrom_\u00adthis&lt;T&gt;</code> to inherit the <code>shared_\u00adfrom_\u00adthis</code> member functions that obtain a <code>shared_\u00adptr</code> instance pointing to <code>*this</code>.</p>\n</blockquote>\n<p>That is, inheriting from <code>std::enable_shared_from_this</code> makes it possible to get a shared (or weak) pointer to your instance without access to it (e.g. from a member function where you only know about <code>*this</code>).</p>\n<p>It's useful when you need to give a <code>std::shared_ptr</code> but you only have access to <code>*this</code>:</p>\n<pre><code>struct Node;\n\nvoid process_node(const std::shared_ptr&lt;Node&gt; &amp;);\n\nstruct Node : std::enable_shared_from_this&lt;Node&gt; // CRTP\n{\n    std::weak_ptr&lt;Node&gt; parent;\n    std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children;\n\n    void add_child(std::shared_ptr&lt;Node&gt; child)\n    {\n        process_node(shared_from_this()); // Shouldn't pass `this` directly.\n        child-&gt;parent = weak_from_this(); // Ditto.\n        children.push_back(std::move(child));\n    }\n};\n</code></pre>\n<p>The reason you can't just pass <code>this</code> directly instead of <code>shared_from_this()</code> is that it would break the ownership mechanism:</p>\n<pre><code>struct S\n{\n    std::shared_ptr&lt;S&gt; get_shared() const { return std::shared_ptr&lt;S&gt;(this); }\n};\n\n// Both shared_ptr think they're the only owner of S.\n// This invokes UB (double-free).\nstd::shared_ptr&lt;S&gt; s1 = std::make_shared&lt;S&gt;();\nstd::shared_ptr&lt;S&gt; s2 = s1-&gt;get_shared();\nassert(s2.use_count() == 1);\n</code></pre>\n</hr>", "OwnerUserId": "3646096", "LastEditorUserId": "3646096", "LastEditDate": "2017-12-02T16:37:50.027", "Id": "47514417", "Score": "1", "CreationDate": "2017-11-27T15:26:43.357", "LastActivityDate": "2017-12-02T16:37:50.027"}, "4173254": {"CommentCount": "4", "AcceptedAnswerId": "4173298", "PostTypeId": "1", "LastEditorUserId": "541208", "CreationDate": "2010-11-13T15:30:07.563", "LastActivityDate": "2017-12-02T16:37:50.027", "LastEditDate": "2017-01-04T22:55:53.483", "ViewCount": "28798", "FavoriteCount": "91", "Title": "What is the curiously recurring template pattern (CRTP)?", "Id": "4173254", "Score": "126", "Body": "<p>Without referring to a book, can anyone please provide a good explanation for <code>CRTP</code> with a code example?</p>\n", "Tags": "<c++><templates><c++-faq><crtp>", "OwnerUserId": "452307", "AnswerCount": "4"}, "19311411": {"ParentId": "4173254", "CommentCount": "8", "Body": "<p>Just as note:</p>\n<p>CRTP could be used to implement static polymorphism(which like dynamic polymorphism but without virtual function pointer table).</p>\n<pre><code>#pragma once\n#include &lt;iostream&gt;\ntemplate &lt;typename T&gt;\nclass Base\n{\n    public:\n        void method() {\n            static_cast&lt;T*&gt;(this)-&gt;method();\n        }\n};\n\nclass Derived1 : public Base&lt;Derived1&gt;\n{\n    public:\n        void method() {\n            std::cout &lt;&lt; \"Derived1 method\" &lt;&lt; std::endl;\n        }\n};\n\n\nclass Derived2 : public Base&lt;Derived2&gt;\n{\n    public:\n        void method() {\n            std::cout &lt;&lt; \"Derived2 method\" &lt;&lt; std::endl;\n        }\n};\n\n\n#include \"crtp.h\"\nint main()\n{\n    Derived1 d1;\n    Derived2 d2;\n    d1.method();\n    d2.method();\n    return 0;\n}\n</code></pre>\n<p>The output would be :</p>\n<pre><code>Derived1 method\nDerived2 method\n</code></pre>\n", "OwnerUserId": "193251", "PostTypeId": "2", "Id": "19311411", "Score": "8", "CreationDate": "2013-10-11T06:13:56.693", "LastActivityDate": "2013-10-11T06:13:56.693"}, "bq_ids": {"n4140": {"so_4173254_47514417_1": {"section_id": 4497, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_4173254_47514417_1": {"section_id": 4328, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_4173254_47514417_1": {"section_id": 5760, "quality": 1.0, "length": 12}}}});