post_cb({"32085766": {"ParentId": "32085442", "CommentCount": "5", "CreationDate": "2015-08-19T02:50:06.023", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "32085766", "Score": "3", "Body": "<p>I think both compilers are conforming as the order of initialization of static variables is unspecified. The clearest statement comes from a note in [basic.start.init]:</p>\n<blockquote>\n<p id=\"so_32085442_32085766_0\"><em>[ Note:</em> As a consequence, if the initialization of an object obj1 refers to an object obj2 of namespace scope\n  potentially requiring dynamic initialization and defined later in the same translation unit, it is unspecified\n  whether the value of obj2 used will be the value of the fully initialized obj2 (because obj2 was statically\n  initialized) or will be the value of obj2 merely zero-initialized. For example,</p>\n<pre><code>inline double fd() { return 1.0; }\nextern double d1;\ndouble d2 = d1; // unspecified:\n// may be statically initialized to 0.0 or\n// dynamically initialized to 0.0 if d1 is\n// dynamically initialized, or 1.0 otherwise\ndouble d1 = fd(); // may be initialized statically or dynamically to 1.0\n</code></pre>\n<p id=\"so_32085442_32085766_1\"><em>\u2014end note ]</em></p>\n</blockquote>\n<p>In our case, <code>Builder&lt;start, 1&gt;::value</code> was statically initialized, but everything else is dynamically uninitialized - so it's unspecified as to the fully initialized <code>Builder&lt;start, 1&gt;::value</code> is used or not. </p>\n<p>A workaround is to use the construct on first use idiom and do something like (I took the liberty of pulling out <code>Builder</code> from <code>RecursiveStruct</code> for simplicity - it exhibits the same behavior either way):</p>\n<pre><code>template &lt;std::size_t start, std::size_t length&gt;\nstruct Builder\n{\n    static const size_t mid = start + length / 2;\n    static const size_t end = start + length;    \n\n    static const Builder value() {\n        static const Builder value_{ \n            Builder&lt;start, mid - start&gt;::value(), \n            Builder&lt;mid, end - mid&gt;::value() \n        };\n        return value_;\n    }\n\n    Builder&lt;start, mid - start&gt; left;\n    Builder&lt;mid, end - mid&gt; right;\n};\n\ntemplate &lt;std::size_t start&gt;\nstruct Builder&lt;start, 1&gt; {\n    static const Builder value() {\n        static const Builder value_{5};\n        return value_;\n    }\n\n    int data;\n};\n\ntemplate&lt;std::size_t size&gt;\nstruct RecursiveStruct {\npublic:\n    static const Builder&lt;0, size&gt; result;\n};\n\ntemplate &lt;std::size_t size&gt;\nconst Builder&lt;0, size&gt; RecursiveStruct&lt;size&gt;::result = Builder&lt;0, size&gt;::value();\n</code></pre>\n<p>This prints <code>5</code> on both compilers. </p>\n", "LastActivityDate": "2015-08-19T02:50:06.023"}, "bq_ids": {"n4140": {"so_32085442_32085766_0": {"section_id": 7152, "quality": 0.95, "length": 38}}, "n3337": {"so_32085442_32085766_0": {"section_id": 6896, "quality": 0.95, "length": 38}}, "n4659": {"so_32085442_32085766_0": {"section_id": 8653, "quality": 0.95, "length": 38}}}, "32085442": {"CommentCount": "0", "ViewCount": "78", "CreationDate": "2015-08-19T02:10:15.710", "LastActivityDate": "2015-08-19T02:50:06.023", "Title": "Initializing templated, recursive, POD struct", "AcceptedAnswerId": "32085766", "PostTypeId": "1", "Id": "32085442", "Score": "8", "Body": "<p>I was experimenting with using template recursion to generate a nested POD structs, and I came across some behavior I wasn't expecting. Here's a simplified test case:</p>\n<pre><code>#include &lt;cstddef&gt;\n\ntemplate&lt;std::size_t size&gt;\nstruct RecursiveStruct {\npublic:\n    template &lt;std::size_t start, std::size_t length&gt;\n    struct Builder {\n        static const Builder value;\n        static const size_t mid = start + length / 2;\n        static const size_t end = start + length;\n        Builder&lt;start, mid - start&gt; left;\n        Builder&lt;mid, end - mid&gt; right;\n    };\n\n    template &lt;std::size_t start&gt;\n    struct Builder&lt;start, 1&gt; {\n        static const Builder value;\n        int data;\n    };\n\n    static const Builder&lt;0, size&gt; result;\n};\n\ntemplate&lt;std::size_t size&gt;\nconst typename RecursiveStruct&lt;size&gt;::template Builder&lt;0, size&gt;\n        RecursiveStruct&lt;size&gt;::result = Builder&lt;0, size&gt;::value;\n\ntemplate&lt;std::size_t size&gt;\ntemplate&lt;std::size_t start, std::size_t length&gt;\nconst typename RecursiveStruct&lt;size&gt;::template Builder&lt;start, length&gt;\n        RecursiveStruct&lt;size&gt;::Builder&lt;start, length&gt;::value\n            = { Builder&lt;start, mid - start&gt;::value, Builder&lt;mid, end - mid&gt;::value };\n\ntemplate&lt;std::size_t size&gt;\ntemplate &lt;std::size_t start&gt;\nconst typename RecursiveStruct&lt;size&gt;::template Builder&lt;start, 1&gt;\n        RecursiveStruct&lt;size&gt;::Builder&lt;start, 1&gt;::value = { 5 };\n\n////////////////////////////////////////////////////////\n\n#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\nusing std::size_t;\n\nint main() {\n    cout &lt;&lt; RecursiveStruct&lt;1&gt;::result.data &lt;&lt; endl;\n    cout &lt;&lt; RecursiveStruct&lt;2&gt;::result.left.data &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>I would expect this code to output</p>\n<pre><code>5\n5\n</code></pre>\n<p>Indeed, that it what is generated when I compile with GCC 4.8.4 and 5.1.</p>\n<p>However, compiling either with Clang (3.5 or 3.7) or Visual Studio 2010 instead results in</p>\n<pre><code>5\n0\n</code></pre>\n<p>Is my code or my understanding of it wrong in some way, or do Clang and Visual Studio somehow both have bugs that result in the same erroneous output?</p>\n", "Tags": "<c++><templates><initialization>", "OwnerUserId": "955611", "AnswerCount": "1"}});