post_cb({"40513319": {"ParentId": "40513156", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>According to <a href=\"http://eel.is/c++draft/basic.scope.pdecl#1\" rel=\"nofollow noreferrer\">[basic.scope.pdecl]/1</a>:</p>\n<blockquote>\n<p id=\"so_40513156_40513319_0\">The point of declaration for a name is immediately after its complete\n  <em>declarator</em> (Clause 8) and <strong>before its <em>initializer</em></strong> (if any), except as\n  noted below.</p>\n</blockquote>\n<p>So the parameter is definitely declared at that point. How about using it in <code>decltype</code>? Wording was outdated and inadvertently disallowed it. See <a href=\"http://wg21.link/cwg2082\" rel=\"nofollow noreferrer\">core issue 2082</a>:</p>\n<blockquote>\n<p id=\"so_40513156_40513319_1\">According to 8.3.6 [dcl.fct.default] paragraph 9,</p>\n<blockquote>\n<p id=\"so_40513156_40513319_4\">A default argument is evaluated each time the function is called with\n    no argument for the corresponding parameter. The order of evaluation\n    of function arguments is unspecified. Consequently, parameters of a\n    function shall not be used in a default argument, even if they are not\n    evaluated. This prohibits use of parameters in unevaluated operands,\n    e.g.,</p>\n</blockquote>\n<pre><code>void foo(int a = decltype(a){});\n</code></pre>\n<p id=\"so_40513156_40513319_3\">This wording predates the concept\n  of \u201cunevaluated operands\u201d (the phrase \u201cnot evaluated\u201d refers to calls\n  to the function where an actual argument is supplied and thus the\n  default argument is not used, not to unevaluated operands) and should\n  not apply to such cases.</p>\n</blockquote>\n<p>So the <a href=\"http://eel.is/c++draft/dcl.fct.default#9\" rel=\"nofollow noreferrer\">quoted paragraph</a> was amended to read</p>\n<blockquote>\n<p id=\"so_40513156_40513319_5\">A parameter shall not appear as a potentially-evaluated expression in a default argument.</p>\n</blockquote>\n<p>Since operands of <code>decltype</code> are unevaluated, this is fine now, and GCC is wrong.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2016-11-09T18:08:55.210", "Id": "40513319", "Score": "8", "CreationDate": "2016-11-09T18:05:30.100", "LastActivityDate": "2016-11-09T18:08:55.210"}, "40513156": {"CommentCount": "8", "ViewCount": "150", "PostTypeId": "1", "LastEditorUserId": "3233393", "CreationDate": "2016-11-09T17:53:57.150", "LastActivityDate": "2016-11-09T18:08:55.210", "Title": "Using a parameter's name inside its own default value - is it legal?", "LastEditDate": "2016-11-09T17:58:14.480", "Id": "40513156", "Score": "9", "Body": "<pre><code>enum class E {\n    One,\n    Two\n};\n\nvoid foo(E value = decltype(value)::One) {\n}\n</code></pre>\n<p>It can be compiled with Clang (3.9), but cannot be compiled with GCC 6.1: <code>value was not declared in this scope</code>.</p>\n<p>What compiler is right?</p>\n", "Tags": "<c++><parameters><language-lawyer><default-parameters>", "OwnerUserId": "1555823", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40513156_40513319_2": {"section_id": 3260, "quality": 0.7666666666666667, "length": 23}, "so_40513156_40513319_0": {"section_id": 7049, "quality": 0.875, "length": 14}, "so_40513156_40513319_4": {"section_id": 3260, "quality": 0.7666666666666667, "length": 23}, "so_40513156_40513319_5": {"section_id": 3260, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_40513156_40513319_2": {"section_id": 3132, "quality": 0.6333333333333333, "length": 19}, "so_40513156_40513319_0": {"section_id": 6794, "quality": 0.875, "length": 14}, "so_40513156_40513319_4": {"section_id": 3132, "quality": 0.6333333333333333, "length": 19}}, "n4659": {"so_40513156_40513319_0": {"section_id": 8546, "quality": 0.875, "length": 14}, "so_40513156_40513319_5": {"section_id": 4018, "quality": 1.0, "length": 6}}}});