post_cb({"46188056": {"ParentId": "46187833", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2017-09-13T02:47:45.833", "Score": "6", "LastEditorUserId": "2069064", "LastEditDate": "2017-09-13T03:46:16.003", "Id": "46188056", "OwnerUserId": "2069064", "Body": "<blockquote>\n<p id=\"so_46187833_46188056_0\">Does the following lead to undefined behavior as long as the pointer being used to access the pointer-to-member is of a correct type?</p>\n</blockquote>\n<p>No, it's well formed. The rule, from <a href=\"http://eel.is/c++draft/expr.mptr.oper#4.sentence-2\" rel=\"nofollow noreferrer\">[expr.mptr.oper]</a> is:</p>\n<blockquote>\n<p id=\"so_46187833_46188056_1\">If the dynamic type of E1 does not contain the member to which E2 refers, the behavior is undefined.</p>\n</blockquote>\n<p>The <a href=\"http://eel.is/c++draft/defns.dynamic.type\" rel=\"nofollow noreferrer\">dynamic type</a> of <code>*this</code> is <code>sub</code>, which does contain the member, so this is fine.</p>\n<blockquote>\n<p id=\"so_46187833_46188056_2\">And if so, why do I need the cast?</p>\n</blockquote>\n<p>Because it's an inherently unsafe cast, and the rule of thumb is that inherently unsafe operations should be <em>loud and visible</em>. In this specific case, it's fine, but that's only because you were being careful. Requiring the cast forces you to have to think about it. </p>\n<p>A simpler example might be to look at just the pointers instead of the pointer-to-member. In a simple hierarchy (assuming public, non-ambiguous, etc.), it is always safe to cast a <code>Derived*</code> to a <code>Base*</code>. There's nothing problematic there, so you don't need to write a cast. However, it is not always safe to cast a <code>Base*</code> to a <code>Derived*</code>... you might not have a <code>Derived*</code> there. But, it's not <em>never</em> safe - disallowing that cast entirely would be bad. So the safe cast is implicit, but the unsafe cast must be explicit. </p>\n", "LastActivityDate": "2017-09-13T03:46:16.003"}, "bq_ids": {"n4140": {"so_46187833_46188056_1": {"section_id": 6131, "quality": 1.0, "length": 8}}, "n3337": {"so_46187833_46188056_1": {"section_id": 5895, "quality": 1.0, "length": 8}}, "n4659": {"so_46187833_46188056_1": {"section_id": 7628, "quality": 1.0, "length": 8}}}, "46187833": {"CommentCount": "2", "ViewCount": "132", "PostTypeId": "1", "LastEditorUserId": "6497438", "CreationDate": "2017-09-13T02:20:15.893", "LastActivityDate": "2017-09-13T03:46:16.003", "Title": "Is it legal to cast a pointer-to-derived-class-member-variable to a pointer-to-base-class-member-variable?", "AcceptedAnswerId": "46188056", "LastEditDate": "2017-09-13T02:38:10.903", "Id": "46187833", "Score": "4", "Body": "<p>Does the following lead to undefined behavior as long as the pointer being used to access the pointer-to-member is of a correct type?</p>\n<p>And if so, why do I need the cast? It would look a lot nicer without it (and yes, I know that's just a matter of opinion).</p>\n<pre><code>struct base {\n    int foo(int base::* ptr) {\n        return this-&gt;*ptr;\n    }\n};\n\nstruct sub : base {\n    int blah{ 42 };\n};\n\nint main() {\n    return sub{}.foo(static_cast&lt;int base::*&gt;(&amp;sub::blah));\n}\n</code></pre>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "6497438", "AnswerCount": "1"}});