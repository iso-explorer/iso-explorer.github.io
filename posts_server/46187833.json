post_cb({"bq_ids": {"n4140": {"so_46187833_46188056_1": {"length": 8, "quality": 1.0, "section_id": 6131}}, "n3337": {"so_46187833_46188056_1": {"length": 8, "quality": 1.0, "section_id": 5895}}, "n4659": {"so_46187833_46188056_1": {"length": 8, "quality": 1.0, "section_id": 7628}}}, "46187833": {"ViewCount": "132", "Body": "<p>Does the following lead to undefined behavior as long as the pointer being used to access the pointer-to-member is of a correct type?</p>\n<p>And if so, why do I need the cast? It would look a lot nicer without it (and yes, I know that's just a matter of opinion).</p>\n<pre><code>struct base {\n    int foo(int base::* ptr) {\n        return this-&gt;*ptr;\n    }\n};\n\nstruct sub : base {\n    int blah{ 42 };\n};\n\nint main() {\n    return sub{}.foo(static_cast&lt;int base::*&gt;(&amp;sub::blah));\n}\n</code></pre>\n", "AcceptedAnswerId": "46188056", "Title": "Is it legal to cast a pointer-to-derived-class-member-variable to a pointer-to-base-class-member-variable?", "CreationDate": "2017-09-13T02:20:15.893", "Id": "46187833", "CommentCount": "2", "LastEditDate": "2017-09-13T02:38:10.903", "PostTypeId": "1", "LastEditorUserId": "6497438", "LastActivityDate": "2017-09-13T03:46:16.003", "Score": "4", "OwnerUserId": "6497438", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}, "46188056": {"Id": "46188056", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46187833_46188056_0\">Does the following lead to undefined behavior as long as the pointer being used to access the pointer-to-member is of a correct type?</p>\n</blockquote>\n<p>No, it's well formed. The rule, from <a href=\"http://eel.is/c++draft/expr.mptr.oper#4.sentence-2\" rel=\"nofollow noreferrer\">[expr.mptr.oper]</a> is:</p>\n<blockquote>\n<p id=\"so_46187833_46188056_1\">If the dynamic type of E1 does not contain the member to which E2 refers, the behavior is undefined.</p>\n</blockquote>\n<p>The <a href=\"http://eel.is/c++draft/defns.dynamic.type\" rel=\"nofollow noreferrer\">dynamic type</a> of <code>*this</code> is <code>sub</code>, which does contain the member, so this is fine.</p>\n<blockquote>\n<p id=\"so_46187833_46188056_2\">And if so, why do I need the cast?</p>\n</blockquote>\n<p>Because it's an inherently unsafe cast, and the rule of thumb is that inherently unsafe operations should be <em>loud and visible</em>. In this specific case, it's fine, but that's only because you were being careful. Requiring the cast forces you to have to think about it. </p>\n<p>A simpler example might be to look at just the pointers instead of the pointer-to-member. In a simple hierarchy (assuming public, non-ambiguous, etc.), it is always safe to cast a <code>Derived*</code> to a <code>Base*</code>. There's nothing problematic there, so you don't need to write a cast. However, it is not always safe to cast a <code>Base*</code> to a <code>Derived*</code>... you might not have a <code>Derived*</code> there. But, it's not <em>never</em> safe - disallowing that cast entirely would be bad. So the safe cast is implicit, but the unsafe cast must be explicit. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-09-13T03:46:16.003", "Score": "6", "CreationDate": "2017-09-13T02:47:45.833", "ParentId": "46187833", "CommentCount": "5", "LastEditDate": "2017-09-13T03:46:16.003", "OwnerUserId": "2069064"}});