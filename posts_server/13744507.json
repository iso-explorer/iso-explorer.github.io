post_cb({"bq_ids": {"n4140": {"so_13744507_13744507_0": {"length": 22, "quality": 1.0, "section_id": 5811}, "so_13744507_13745174_1": {"length": 11, "quality": 1.0, "section_id": 5811}, "so_13744507_13745174_0": {"length": 18, "quality": 1.0, "section_id": 5810}, "so_13744507_13745174_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 6009}, "so_13744507_13745174_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5811}}, "n3337": {"so_13744507_13744507_0": {"length": 22, "quality": 1.0, "section_id": 5584}, "so_13744507_13745174_1": {"length": 11, "quality": 1.0, "section_id": 5584}, "so_13744507_13745174_0": {"length": 18, "quality": 1.0, "section_id": 5583}, "so_13744507_13745174_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5584}, "so_13744507_13745174_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 5777}}, "n4659": {"so_13744507_13744507_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 7272}, "so_13744507_13745174_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 7272}, "so_13744507_13745174_0": {"length": 18, "quality": 1.0, "section_id": 7271}, "so_13744507_13745174_1": {"length": 11, "quality": 1.0, "section_id": 7272}, "so_13744507_13745174_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 7508}}}, "13745174": {"Id": "13745174", "PostTypeId": "2", "Body": "<p>You specifically refer to the C++11 standard so I'm going to answer with the C++11 answer. It is, however, very similar to the C++03 answer, but the definition of sequencing is different.</p>\n<p>C++11 defines a <em>sequenced before</em> relation between evaluations on a single thread. It is asymmetric, transitive and pair-wise. If some evaluation A is not sequenced before some evaluation B and B is also not sequenced before A, then the two evaluations are <em>unsequenced</em>.</p>\n<p><em>Evaluating</em> an expression includes both value computations (working out the value of some expression) and side effects. One instance of a <em>side effect</em> is the modification of an object, which is the most important one for answering question. Other things also count as side effects. If a side effect is unsequenced relative to another side effect or value computation on the same object, then your program has undefined behaviour.</p>\n<p>So that's the set up. The first important rule is:</p>\n<blockquote>\n<p id=\"so_13744507_13745174_0\">Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.</p>\n</blockquote>\n<p>So any full expression is fully evaluated before the next full expression. In your question, we're only dealing with one full expression, namely <code>i = v[i++]</code>, so we don't need to worry about this. The next important rule is:</p>\n<blockquote>\n<p id=\"so_13744507_13745174_1\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. </p>\n</blockquote>\n<p>That means that in <code>a + b</code>, for example, the evaluation of <code>a</code> and <code>b</code> are unsequenced (they may be evaluated in any order). Now for our final important rule:</p>\n<blockquote>\n<p id=\"so_13744507_13745174_2\">The value computations of the operands of an operator are sequenced before the value computation of the result of the operator.</p>\n</blockquote>\n<p>So for <code>a + b</code>, the sequenced before relationships can be represented by a tree where a directed arrow represents the sequenced before relationship:</p>\n<pre><code>a + b (value computation)\n^   ^\n|   |\na   b (value computation)\n</code></pre>\n<p>If two evaluations occur in separate branches of the tree, they are unsequenced, so this tree shows that the evaluations of <code>a</code> and <code>b</code> are unsequenced relative to each other.</p>\n<p>Now, let's do the same thing to your <code>i = v[i++]</code> example. We make use of the fact that <code>v[i++]</code> is defined to be equivalent to <code>*(v + (i++))</code>. We also use some extra knowledge about the sequencing of postfix increment:</p>\n<blockquote>\n<p id=\"so_13744507_13745174_3\">The value computation of the <code>++</code> expression is sequenced before the modification of the operand object.</p>\n</blockquote>\n<p>So here we go (a node of the tree is a value computation unless specified as a side effect):</p>\n<pre><code>i = v[i++]\n^     ^\n|     |\ni\u2605  v[i++] = *(v + (i++))\n                  ^\n                  |\n               v + (i++)\n               ^     ^\n               |     |\n               v     ++ (side effect on i)\u2605\n                     ^\n                     |\n                     i\n</code></pre>\n<p>Here you can see that the side effect on <code>i</code>, <code>i++</code>, is in a separate branch to the usage of <code>i</code> in front of the assignment operator (I marked each of these evaluations with a \u2605). So we definitely have undefined behaviour! I highly recommend drawing these diagrams if you ever wonder if your sequencing of evaluations is going to cause you trouble.</p>\n<p>So now we get the question about the fact that the value of <code>i</code> before the assignment operator doesn't matter, because we write over it anyway. But actually, in the general case, that's not true. We can override the assignment operator and make use of the value of the object before the assignment. The standard doesn't care that we don't use that value - the rules are defined such that having any value computation unsequenced with a side effect will be undefined behaviour. No buts. This undefined behaviour is there to allow the compiler to emit more optimized code. If we add sequencing for the assignment operator, this optimization cannot be employed.</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2012-12-06T14:20:42.800", "Score": "9", "CreationDate": "2012-12-06T13:59:35.777", "ParentId": "13744507", "CommentCount": "0", "OwnerUserId": "150634", "LastEditDate": "2012-12-06T14:20:42.800"}, "13744989": {"Id": "13744989", "PostTypeId": "2", "Body": "<p>I'm going to design a pathological computer<sup>1</sup>.  It is a multi-core, high-latency, single-thread system with in-thread joins that operates with byte-level instructions.  So you make a request for something to happen, then the computer runs (in its own \"thread\" or \"task\") a byte-level set of instructions, and a certain number of cycles later the operation is complete.</p>\n<p>Meanwhile, the main thread of execution continues:</p>\n<pre><code>void foo(int v[], int i){\n  i = v[i++];\n}\n</code></pre>\n<p>becomes in pseudo-code:</p>\n<pre><code>input variable i // = 0x00000000\ninput variable v // = &amp;[0xBAADF00D, 0xABABABABAB, 0x10101010]\ntask get_i_value: GET_VAR_VALUE&lt;int&gt;(i)\nreg indx = WAIT(get_i_value)\ntask write_i++_back: WRITE(i, INC(indx))\ntask get_v_value: GET_VAR_VALUE&lt;int*&gt;(v)\nreg arr = WAIT(get_v_value)\ntask get_v[i]_value = CALC(arr + sizeof(int)*indx)\nreg pval = WAIT(get_v[i]_value)\ntask read_v[i]_value = LOAD_VALUE&lt;int&gt;(pval)\nreg got_value = WAIT(read_v[i]_value)\ntask write_i_value_again = WRITE(i, got_value)\n(discard, discard) = WAIT(write_i++_back, write_i_value_again)\n</code></pre>\n<p>So you'll notice that I didn't wait on <code>write_i++_back</code> until the very end, the same time as I was waiting on <code>write_i_value_again</code> (which value I loaded from <code>v[]</code>).  And, in fact, those writes are the only writes back to memory.</p>\n<p>Imagine if write to memory are the really slow part of this computer design, and they get batched up into a queue of things that get processed by a parallel memory modifying unit that does things on a per-byte basis.</p>\n<p>So the <code>write(i, 0x00000001)</code> and <code>write(i, 0xBAADF00D)</code> execute unordered and in parallel.  Each gets turned into byte-level writes, and they are randomly ordered.</p>\n<p>We end up writing <code>0x00</code> then <code>0xBA</code> to the high byte, then <code>0xAD</code> and <code>0x00</code> to the next byte, then <code>0xF0</code> <code>0x00</code> to the next byte, and finally <code>0x0D</code> <code>0x01</code> to the low byte.  The resulting value in i is <code>0xBA000001</code>, which few would expect, yet would be a valid result to your undefined operation.</p>\n<p>Now, all I did there was result in an unspecified value.  We haven't crashed the system.  But the compiler would be free to make it completely undefined -- maybe sending two such requests to the memory controller for the same address in the same batch of instructions actually crashes the system.  That would still be a \"valid\" way to compile C++, and a \"valid\" execution environment.</p>\n<p>Remember, this is a language where restricting the size of pointers to 8 bits is still a valid execution environment.  C++ allows for compiling to rather wonkey targets.</p>\n<p><sup>1</sup>: As noted in @SteveJessop's comment below, the joke is that this pathological computer behaves a lot like a modern desktop computer, until you get down to the byte-level operations.  Non-atomic <code>int</code> writing by a CPU isn't all that rare on some hardware (such as when the <code>int</code> isn't aligned the way the CPU wants it to be aligned).</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2013-02-28T19:33:53.470", "Score": "29", "CreationDate": "2012-12-06T13:50:27.547", "ParentId": "13744507", "CommentCount": "5", "OwnerUserId": "1774667", "LastEditDate": "2013-02-28T19:33:53.470"}, "13744789": {"Id": "13744789", "PostTypeId": "2", "Body": "<p>The reason is not just historical. Example:</p>\n<pre><code>int f(int&amp; i0, int&amp; i1) {\n    return i0 + i1++;\n}\n</code></pre>\n<p>Now, what happens with this call:</p>\n<pre><code>int i = 3;\nint j = f(i, i);\n</code></pre>\n<p>It's certainly possible to put requirements on the code in <code>f</code> so that the result of this call is well defined (Java does this), but C and C++ don't impose constraints; this gives more freedom to optimizers.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2012-12-06T14:21:30.533", "Score": "24", "CreationDate": "2012-12-06T13:37:25.090", "ParentId": "13744507", "CommentCount": "3", "OwnerUserId": "1593860", "LastEditDate": "2012-12-06T14:21:30.533"}, "13744725": {"Id": "13744725", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13744507_13744725_0\">In this example I would think that the subexpression i++ would be completely evaluated before the subexpression v[...] is evaluated, and that the result of evaluation of the subexpression is i (before the increment), but that the value of i is the incremented value after that subexpression has been completely evaluated.</p>\n</blockquote>\n<p>The increment in <code>i++</code> must be evaluated before indexing <code>v</code> and thus before assigning to <code>i</code>, <strong>but</strong> storing the value of that increment back to memory need not happen before. In the statement <code>i = v[i++]</code> there are two suboperations that modify <code>i</code> (i.e. will end up causing a store from a register into the variable <code>i</code>). The expression <code>i++</code> is equivalent to <code>x=i+1</code>, <code>i=x</code>, and there is no requirement that both operations need to take place sequentially:</p>\n<pre><code>x = i+1;\ny = v[i];\ni = y;\ni = x;\n</code></pre>\n<p>With that expansion, the result of <code>i</code> is unrelated to the value in <code>v[i]</code>. On a different expansion, the <code>i = x</code> assignment could take place <em>before</em> the <code>i = y</code> assignment, and the result would be <code>i = v[i]</code></p>\n", "LastActivityDate": "2012-12-06T13:33:35.633", "CommentCount": "0", "CreationDate": "2012-12-06T13:33:35.633", "ParentId": "13744507", "Score": "4", "OwnerUserId": "36565"}, "13744600": {"Id": "13744600", "PostTypeId": "2", "Body": "<p>I would share your arguments if the example were <code>v[++i]</code>, but since <code>i++</code> modifies <code>i</code> as a side-effect, it is undefined as to <em>when</em> the value is modified. The standard could probably mandate a result one way or the other, but there's no <em>true</em> way of knowing what the value of <code>i</code> should be: <code>(i + 1)</code> or <code>(v[i + 1])</code>.</p>\n", "LastActivityDate": "2012-12-06T13:25:53.347", "CommentCount": "10", "CreationDate": "2012-12-06T13:25:53.347", "ParentId": "13744507", "Score": "2", "OwnerUserId": "8368"}, "13744507": {"ViewCount": "2877", "Body": "<p>From the C++ (C++11) standard, \u00a71.9.15 which discusses ordering of evaluation, is the following code example:</p>\n<pre><code>void g(int i, int* v) {\n    i = v[i++]; // the behavior is undefined\n}\n</code></pre>\n<p>As noted in the code sample, the behavior is undefined.</p>\n<p>(Note: The answer to another question with the slightly different construct <code>i + i++</code>, <a href=\"https://stackoverflow.com/questions/12572618/why-is-a-i-i-undefined-and-not-unspecified-behaviour\">Why is a = i + i++ undefined and not unspecified behaviour</a>, <em>might</em> apply here: The answer is essentially that the behavior is undefined for <em>historical</em> reasons, and not out of necessity.  However, the standard seems to imply some <em>justification</em> for this being undefined - see quote immediately below.  Also, that linked question indicates agreement that the behavior should be <em>unspecified</em>, whereas in this question I am asking why the behavior is not <em>well-specified</em>.)</p>\n<p>The reasoning given by the standard for the undefined behavior is as follows:</p>\n<blockquote>\n<p id=\"so_13744507_13744507_0\">If a side effect on a scalar object is unsequenced relative to either\n  another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>In this example I would think that the subexpression <code>i++</code> would be completely evaluated <em>before</em> the subexpression <code>v[...]</code> is evaluated, and that the <em>result</em> of evaluation of the subexpression is <code>i</code> (before the increment), but that the <em>value</em> of <code>i</code> is the incremented value after that subexpression has been completely evaluated.  I would think that at that point (after the subexpression <code>i++</code> has been completely evaluated), the evaluation <code>v[...]</code> takes place, followed by the assignment <code>i = ...</code>.</p>\n<p>Therefore, although the incrementing of <code>i</code> is pointless, I would nonetheless think that this should be <em>defined</em>.</p>\n<p>Why is this undefined behavior?</p>\n", "AcceptedAnswerId": "13744989", "Title": "Why is i = v[i++] undefined?", "CreationDate": "2012-12-06T13:21:00.917", "Id": "13744507", "CommentCount": "15", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:08:41.553", "LastEditorUserId": "-1", "LastActivityDate": "2017-09-29T17:49:28.023", "Score": "41", "OwnerUserId": "368896", "Tags": "<c++><language-lawyer>", "AnswerCount": "7"}, "13744729": {"Id": "13744729", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13744507_13744729_0\">I would think that the subexpression i++ would be completely evaluated before the subexpression v[...] is evaluated</p>\n</blockquote>\n<p>But <em>why</em> would you think that?</p>\n<p>One historical reason for this code being UB is to allow compiler optimizations to move side-effects around anywhere between sequence points. The fewer sequence points, the more potential opportunities to optimize but the more confused programmers. If the code says:</p>\n<pre><code>a = v[i++];\n</code></pre>\n<p>The intention of the standard is that the code emitted can be:</p>\n<pre><code>a = v[i];\n++i;\n</code></pre>\n<p>which might be two instructions where:</p>\n<pre><code>tmp = i;\n++i;\na = v[tmp];\n</code></pre>\n<p>would be more than two.</p>\n<p>The \"optimized code\" breaks when <code>a</code> is <code>i</code>, <em>but the standard permits the optimization anyway</em>, by saying that behavior of the original code is undefined when <code>a</code> is <code>i</code>.</p>\n<p>The standard easily could say that <code>i++</code> must be evaluated before the assignment as you suggest. Then the behavior would be fully defined and the optimization would be forbidden. But that's not how C and C++ do business.</p>\n<p>Also beware that many examples raised in these discussions make it easier to tell that there's UB around than it is in general. This leads to people saying that it's \"obvious\" the behavior should be defined and the optimization forbidden. But consider:</p>\n<pre><code>void g(int *i, int* v, int *dst) {\n    *dst = v[(*i)++];\n}\n</code></pre>\n<p>The behavior of this function is defined when <code>i != dst</code>, and in that case you'd want all the optimization you can get (which is why C99 introduces <code>restrict</code>, to allow more optimizations than C89 or C++ do). In order to give you the optimization, behavior is undefined when <code>i == dst</code>. The C and C++ standards tread a fine line when it comes to aliasing, between undefined behavior that's not expected by the programmer, and forbidding desirable optimizations that fail in certain cases. The number of questions about it on SO suggests that the questioners would prefer a bit less optimization and a bit more defined behavior, but it's still not simple to draw the line.</p>\n<p>Aside from whether the behavior is fully defined is the issue of whether it should be UB, or merely unspecified order of execution of certain well-defined operations corresponding to the sub-expressions. The reason C goes for UB is all to do with the idea of sequence points, and the fact that the compiler need not actually have a notion of <em>the</em> value of a modified object, until the next sequence point. So rather than constrain the optimizer by saying that \"the\" value changes at some unspecified point, the standard just says  (to paraphrase): (1) any code that relies on the value of a modified object prior to the next sequence point, has UB; (2) any code that modifies a modified object has UB. Where a \"modified object\" is any object that <em>would</em> have been modified since the last sequence point in one or more of the legal orders of evaluation of the subexpressions.</p>\n<p>Other languages (e.g. Java) go the whole way and completely define the order of expression side-effects, so there's definitely a case against C's approach. C++ just doesn't accept that case.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-12-06T14:22:35.853", "Score": "42", "CreationDate": "2012-12-06T13:33:43.600", "ParentId": "13744507", "CommentCount": "3", "OwnerUserId": "13005", "LastEditDate": "2012-12-06T14:22:35.853"}, "13753939": {"Id": "13753939", "PostTypeId": "2", "Body": "<p>There two rules.</p>\n<p>The first rule is about multiple writes which give rise to a \"write-write hazard\": <em>the same object cannot be modified more than once between two sequence points.</em></p>\n<p>The second rule is about \"read-write hazards\". It is this: <em>if an object is modified in an expression, and also accessed, then all accesses to its value must be for the purpose of computing the new value.</em></p>\n<p>Expressions like <code>i++ + i++</code> and your expression <code>i = v[i++]</code> violate the first rule. They modify an object twice.</p>\n<p>An expression like <code>i + i++</code> violates the second rule. The subexpression <code>i</code> on the left observes the value of a modified object, without being involved in the calculation of its new value.</p>\n<p>So, <code>i = v[i++]</code> violates a different rule (bad write-write) from <code>i + i++</code> (bad read-write).</p>\n<hr>\n<p>The rules are too simplistic, which gives rise to classes of puzzling expressions.  Consider this:</p>\n<pre><code>p = p-&gt;next = q\n</code></pre>\n<p>This appears to have a sane data flow dependency that is free of hazards: the assignment <code>p =</code> cannot take place until the new value is known. The new value is the result of <code>p-&gt;next = q</code>. The the value <code>q</code> should not \"race ahead\" and get inside <code>p</code>, such that <code>p-&gt;next</code> is affected.</p>\n<p>Yet, this expression breaks the second rule: <code>p</code> is modified, and also used for a purpose not related to computing its new value, namely determining the storage location where the value of <code>q</code> is placed!</p>\n<p>So, perversely, compilers are allowed to partially evaluate <code>p-&gt;next = q</code> to determine that the result is <code>q</code>, and store that into <code>p</code>, and then go back and complete the <code>p-&gt;next =</code> assignment. Or so it would seem.</p>\n<p>A key issue here is, what is the value of an assignment expression? The C standard says that the value of an assignment expression is that of the lvalue, <em>after the assignment</em>. But that is ambiguous: it could be interpreted as meaning \"the value which the lvalue <em>will</em> have, once the assignment takes place\" or as \"the value which can be observed in the lvalue after the assignment has taken place\".  In C++ this is made clear by the wording \"[i]n all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.\", so <code>p = p-&gt;next = q</code> appears to be valid C++, but dubious C.</p>\n</hr>", "LastEditorUserId": "1250772", "LastActivityDate": "2012-12-06T23:59:33.187", "Score": "4", "CreationDate": "2012-12-06T22:41:21.843", "ParentId": "13744507", "CommentCount": "1", "OwnerUserId": "1250772", "LastEditDate": "2012-12-06T23:59:33.187"}});