post_cb({"15015997": {"Id": "15015997", "PostTypeId": "2", "Body": "<p>The call to the assignment operator in</p>\n<pre><code>two = three\n</code></pre>\n<p>returns a temporary object as rvalue. This is of type <code>MyObject</code> and is passed on to the next call of the assignment operator</p>\n<pre><code>one = t\n</code></pre>\n<p>(I use <code>t</code> to refer to the temporary object.)</p>\n<p>Unfortunately, this won't compile because the assignment operator expects a reference <code>MyObject&amp;</code>, and not an rvalue of type <code>MyObject</code>.</p>\n<p>(Your code won't compile for various reasons, including uppercased <code>Class</code> and typos, too.)</p>\n<p>However, if you were to define an assignment operator that takes an rvalue (i.e. takes the argument by value, const-reference, or indeed by rvalue reference <code>MyObject&amp;&amp;</code> if C++11 is used), the call would work and the temporary object would be copied into the function. Internally, assignments would be made and another temporary object would be returned.</p>\n<p>The final temporary object would then go out of scope, i.e. cease to exist. There would be no way to access its contents.</p>\n<hr>\n<p>Thanks for Joachim Pileborg and Benjamin Lindley for the helpful comments.</p>\n<hr>\n<p>To answer the request for more details: <code>MyObject</code> is a class type, and the C++ Standard  includes an entire section on the life cycle of temporary objects of class type (Section 12.2). There are various complex situations that are detailed there in length, and I won't explain them all. But the basic concepts are as follows:</p>\n<ol>\n<li><p>C++ has the notion of <em>expressions.</em> Expressions are, along with declarations and statements, the basic units the code of the program is composed of. For example, a function call <code>f(a,b,c)</code> is an expression, or an assignment like <code>a = b</code>. Expressions may contain other expressions: <code>a = f(b,c)</code>, a function call nested in an assignment expression. C++ also introduces the concept of <em>full-expressions</em>. In the previous example, <code>c</code> is part of the expression <code>f(b,c)</code>, but also of <code>a = f(b,c)</code>, and if that is not nested in another expression, we say that <code>a = f(b,c)</code> is the <em>full-expressions that lexically contains <code>c</code></em>.</p></li>\n<li><p>The Standard defines a variety of situations where temporary objects may be created. One such situation is the returning of an object <em>by value</em> from a function call (aka <em>returning a prvalue</em>, \u00a76.6.3).</p></li>\n<li><p>The Standard states that the life time of such a temporary object ends when the full-expression that contains it has been fully evaluated:</p>\n<blockquote>\n<p id=\"so_15015758_15015997_0\">[...] Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. [...]</p>\n</blockquote>\n<p>(Note. The Standard then goes on to define several exceptions to this rule. The case of the return value of your assignment operator, however, is not such an exception.)</p></li>\n<li><p>Now, <strong>what does it mean that an object (of class type) is destroyed?</strong> It means, first and foremost, that its destructor is called (\u00a712.2/3). It also means that the storage for that object can no longer be safely accessed. So if you somehow managed to store the address of the temporary object in a pointer before the evaluation of the full-expression has ended, then derefencing that pointer after the evaluation has ended generally causes undefined behaviour.</p></li>\n<li><p>In practice, this may in many cases mean the following \u2013 I describe the entire life cycle of the temporary object in one possible scenario:</p>\n<ol>\n<li>To provide for storage for the temporary, the compiler makes sure that sufficient stack space is allocated when the function that contains the full-expression is entered (this happens before the full-expression is actually evaluated).</li>\n<li>During the evaluation of the assignment expression, the temporary is created. The compiler makes sure that its constructor is called to initialise the space that was allocated for it.</li>\n<li>Then the contents of the temporary may be accessed or modified in the course of the evaluation of the full-expression it is part of.</li>\n<li>When the expression has been fully evaluated (in your case, this moment corresponds to the end of the line that contains the assignment expression), the destructor for the temporary is called. After that it is no longer safe to access the memory that was allocated for it, although in reality that space will continue to be part of the current stack frame until the evaluation of the function in which all of this happens has finished.</li>\n</ol></li>\n<li><p>But, again, this is only an example of what <em>may</em> happen. The creation of temporaries is in many situations not actually required. The compiler may perform optimizations that mean the temporary is never actually created. In this case, the compiler must nevertheless ensure that it <em>could have been</em> be created, e.g. it must ensure that the required constructors and destructors exist (they may never be called though).</p></li>\n</ol>\n</hr></hr>", "LastEditorUserId": "777186", "LastActivityDate": "2013-02-22T11:32:24.897", "Score": "4", "CreationDate": "2013-02-22T02:43:46.253", "ParentId": "15015758", "CommentCount": "6", "LastEditDate": "2013-02-22T11:32:24.897", "OwnerUserId": "777186"}, "bq_ids": {"n4140": {"so_15015758_15015997_0": {"length": 14, "quality": 1.0, "section_id": 380}}, "n3337": {"so_15015758_15015997_0": {"length": 14, "quality": 1.0, "section_id": 371}}, "n4659": {"so_15015758_15015997_0": {"length": 14, "quality": 1.0, "section_id": 395}}}, "15015758": {"ViewCount": "266", "Body": "<p>Considering : </p>\n<pre><code>    class MyObject{\n    public:\n     MyObject();\n     MyObject(int,int);\n     int x;\n     int y;\n     MyObject operator =(MyObject rhs);\n    };\n    MyObject::MyObject(int xp, int yp){\n     x = xp;\n     y = yp;\n    }\n    MyObject MyObject::operator =(MyObject rhs){\n     MyObject temp;\n     temp.x = rhs.x;\n     temp.y = rhs.y;\n     return temp;\n    }\n\n    int main(){\n     MyObject one(1,1);\n     MyObject two(2,2);\n     MyObject three(3,3);\n     one = two = three;\n     cout &lt;&lt; one.x &lt;&lt; \", \" &lt;&lt; one.y;\n     cout &lt;&lt; two.x &lt;&lt; \", \" &lt;&lt; two.y;\n     cout &lt;&lt; three.x &lt;&lt; \", \" &lt;&lt; three.y;\n\n    }\n</code></pre>\n<p>By doing this, the variables x and y in one,two and three are unchanged. I know that I should update the member variables for MyObject and use return by reference and return *this for proper behaviour. However, what actually happens to the return values in one = two = three ? Where does the return temp actually end up in the chain, like step by step ? </p>\n", "AcceptedAnswerId": "15015997", "Title": "overlading assignment operator in c++ using return by value", "CreationDate": "2013-02-22T02:15:09.787", "Id": "15015758", "CommentCount": "0", "LastEditDate": "2013-02-22T10:26:41.223", "PostTypeId": "1", "LastEditorUserId": "1511956", "LastActivityDate": "2013-02-22T11:32:24.897", "Score": "1", "OwnerUserId": "1511956", "Tags": "<c++><overloading><operator-keyword>", "AnswerCount": "1"}});