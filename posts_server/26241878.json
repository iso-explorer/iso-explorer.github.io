post_cb({"bq_ids": {"n4140": {"so_26241878_26241878_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 5559}, "so_26241878_26241878_1": {"length": 12, "quality": 1.0, "section_id": 5574}, "so_26241878_26241969_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5694}, "so_26241878_26241969_1": {"length": 19, "quality": 1.0, "section_id": 5695}}, "n3337": {"so_26241878_26241878_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 5341}, "so_26241878_26241969_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5477}, "so_26241878_26241969_1": {"length": 19, "quality": 1.0, "section_id": 5478}}, "n4659": {"so_26241878_26241878_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 7006}, "so_26241878_26241878_1": {"length": 12, "quality": 1.0, "section_id": 7021}, "so_26241878_26241969_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7139}, "so_26241878_26241969_1": {"length": 19, "quality": 1.0, "section_id": 7140}}}, "26241878": {"ViewCount": "211", "Body": "<p>Does the following program invoke undefined behavior?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nint main(int argc, char* argv[])\n{\n    for (auto it = std::istream_iterator&lt;std::string&gt;(std::cin);\n         it != std::istream_iterator&lt;std::string&gt;();\n         ++it)\n    {\n        std::cout &lt;&lt; *it &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre>\n<p>This <a href=\"https://stackoverflow.com/questions/1190112/comparing-default-constructed-iterators-with-operator\">4 year old question</a> says that they can't be compared:</p>\n<blockquote>\n<p id=\"so_26241878_26241878_0\">Iterators can also have singular values that are not associated with\n  any container. [Example: After the declaration of an uninitialized\n  pointer x (as with int* x;), x must always be assumed to have a\n  singular value of a pointer. ] Results of most expressions are\n  undefined for singular values; the only excep- tion is an assignment\n  of a non-singular value to an iterator that holds a singular value.</p>\n</blockquote>\n<p>But another answer for says for the C++14 standard:</p>\n<blockquote>\n<p id=\"so_26241878_26241878_1\">However, value-initialized iterators may be compared and shall compare\n  equal to other value-initialized iterators of the same type.</p>\n</blockquote>\n", "Title": "Is it well-defined to compare with a value-initialized iterator?", "CreationDate": "2014-10-07T17:36:55.480", "LastActivityDate": "2014-10-17T12:45:33.640", "CommentCount": "3", "PostTypeId": "1", "Id": "26241878", "Score": "4", "OwnerUserId": "4118242", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "26241969": {"Id": "26241969", "PostTypeId": "2", "Body": "<p>You are conflating two different issues.</p>\n<p><code>istream_iterator</code> is an input iterator, not a forward iterator, so the C++14 change you cited doesn't apply to it at all. You are allowed to compare <code>istream_iterator</code>s in that manner because they are explicitly specified to allow such comparisons. The standard says that (\u00a724.6.1 [istream.iterator])</p>\n<blockquote>\n<p id=\"so_26241878_26241969_0\">The constructor with no arguments <code>istream_iterator()</code> always\n  constructs an end-of-stream input iterator object, which is the only\n  legitimate iterator to be used for the end condition. [...]</p>\n<p id=\"so_26241878_26241969_1\">Two end-of-stream iterators are always equal. An end-of-stream\n  iterator is not equal to a non-end-of-stream iterator. Two\n  non-end-of-stream iterators are equal when they are constructed from\n  the same stream.</p>\n</blockquote>\n<p>For forward iterators (which also includes bidirectional and random access ones) in general, value-initialized iterators are made comparable to each other in <a href=\"http://www.open-std.org/JTC1/sc22/wg21/docs/papers/2013/n3644.pdf\" rel=\"nofollow\">C++14</a>. If your standard library implements it, then you can compare two value-initialized iterators. This allows you to create an empty range without an underlying container. However, you are still not allowed to compare a non-singular iterator to a value-initialized iterator. The following code has undefined behavior even in C++14:</p>\n<pre><code>std::list&lt;int&gt; l;\n\nif(l.begin() == std::list&lt;int&gt;::iterator())\n    foo();\nelse \n    bar();\n</code></pre>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-10-17T12:45:33.640", "Score": "10", "CreationDate": "2014-10-07T17:43:25.637", "ParentId": "26241878", "CommentCount": "0", "LastEditDate": "2014-10-17T12:45:33.640", "OwnerUserId": "2756719"}});