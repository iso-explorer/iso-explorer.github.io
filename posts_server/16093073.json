post_cb({"16093073": {"CommentCount": "7", "AcceptedAnswerId": "16093692", "PostTypeId": "1", "LastEditorUserId": "499321", "CreationDate": "2013-04-18T21:06:30.743", "LastActivityDate": "2013-04-19T12:05:55.693", "LastEditDate": "2013-04-18T21:44:24.157", "ViewCount": "327", "FavoriteCount": "0", "Title": "template argument for a function in template class", "Id": "16093073", "Score": "1", "Body": "<p>I have situation like this</p>\n<pre><code>template&lt;class T&gt; class Vector {\n  T *data;\n  uint _size, _counter;\npublic:\n  class Iterator;\n  template&lt;template&lt;class&gt; class C&gt; Vector(typename C&lt;T&gt;::Iterator it1,\n                                           typename C&lt;T&gt;::Iterator it2) {\n    data = NULL;\n    _size = _counter = 0;\n    for(typename C&lt;T&gt;::Iterator it = it1; it != it2 &amp;&amp; it != end(); it++)\n      push(*it);\n  }\n};\n</code></pre>\n<p>that is my own Vector class and the constructor mimics behaviour of vector (u can construct it with range of data supplied using interators) but add requirement that the container is to be template of the same type as the one under construction. I get error</p>\n<blockquote>\n<p id=\"so_16093073_16093073_0\">5.cpp:16:36: error: no matching function for call to \u2018Vector::Vector(Vector::Iterator, Vector::Iterator)\u2019\n  5.cpp:16:36: note: candidates are: In file included from 5.cpp:2:0:</p>\n<p id=\"so_16093073_16093073_1\">5.hpp:17:37: note: template class typedef C C&gt; Vector::Vector(typename C::Iterator, typename C::Iterator)</p>\n<p id=\"so_16093073_16093073_2\">5.hpp:17:37: note:   template argument deduction/substitution failed:</p>\n<p id=\"so_16093073_16093073_3\">5.cpp:16:36: note:   couldn't deduce template parameter \u2018template class typedef C C\u2019 In file included from 5.cpp:2:0:</p>\n<p id=\"so_16093073_16093073_4\">5.hpp:11:3: note: Vector::Vector() [with T = int]</p>\n<p id=\"so_16093073_16093073_5\">5.hpp:11:3: note:   candidate expects 0 arguments, 2 provided</p>\n<p id=\"so_16093073_16093073_6\">5.hpp:7:25: note: Vector::Vector(const Vector&amp;)</p>\n<p id=\"so_16093073_16093073_7\">5.hpp:7:25: note:   candidate expects 1 argument, 2 provided</p>\n</blockquote>\n<p>Need some help in here.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "499321", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16093073_16093692_1": {"section_id": 336, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_16093073_16093692_1": {"section_id": 326, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_16093073_16093692_1": {"section_id": 345, "quality": 0.8571428571428571, "length": 6}}}, "16093692": {"ParentId": "16093073", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In:</p>\n<pre><code> template&lt;template&lt;class&gt; class C&gt; Vector(typename C&lt;T&gt;::Iterator it1,\n                                           typename C&lt;T&gt;::Iterator it2) \n</code></pre>\n<p>the compiler does not deduce type <code>C</code> from <code>typename C&lt;T&gt;::Iterator</code> because it is what is called <em>nondeduced context</em>. </p>\n<p>See \u00a714.8.2.4 Deducing template arguments from a type [temp.deduct.type]:</p>\n<blockquote>\n<p id=\"so_16093073_16093692_0\">4 The nondeduced contexts are:</p>\n<p id=\"so_16093073_16093692_1\">\u2014 The nested-name-specifier of a type that was specified using a qualified-id.</p>\n<p id=\"so_16093073_16093692_2\">\u2014 A type that is a template-id in which one or more of the template-arguments is an                         expression that references a template-parameter.</p>\n</blockquote>\n", "OwnerUserId": "412080", "LastEditorUserId": "412080", "LastEditDate": "2013-04-19T12:05:55.693", "Id": "16093692", "Score": "3", "CreationDate": "2013-04-18T21:48:11.407", "LastActivityDate": "2013-04-19T12:05:55.693"}});