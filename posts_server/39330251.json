post_cb({"bq_ids": {"n4140": {"so_39330251_39330368_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6101}, "so_39330251_39330368_1": {"length": 7, "quality": 0.875, "section_id": 6101}, "so_39330251_39330368_2": {"length": 15, "quality": 0.9375, "section_id": 6101}}, "n3337": {"so_39330251_39330368_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 5867}, "so_39330251_39330368_1": {"length": 7, "quality": 0.875, "section_id": 5867}, "so_39330251_39330368_2": {"length": 15, "quality": 0.9375, "section_id": 5867}}, "n4659": {"so_39330251_39330368_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 7598}, "so_39330251_39330368_1": {"length": 7, "quality": 0.875, "section_id": 7598}, "so_39330251_39330368_2": {"length": 15, "quality": 0.9375, "section_id": 7598}}}, "39330368": {"Id": "39330368", "PostTypeId": "2", "Body": "<p>In the current C++ standard (C++14, as well as in the previous versions C++11 and C++03), it is unspecified whether memory is allocated before or after <code>f()</code> is evaluated, but in any case memory will be freed if it has been allocated; <strong>[expr.new]</strong>:</p>\n<blockquote>\n<p id=\"so_39330251_39330368_0\">20 - If any part of the object initialization described above<sup>79</sup> terminates by throwing an exception, storage has\n  been obtained for the object, and a suitable deallocation function can be found, the deallocation function is\n  called to free the memory [...]</p>\n<p id=\"so_39330251_39330368_1\">79) This may include evaluating a <em>new-initializer</em> and/or calling a constructor.</p>\n</blockquote>\n<p>Here the <em>new-initializer</em> is <code>f()</code>, so if the evaluation of <code>f()</code> throws an exception, the deallocation function will be called (if found).</p>\n<p>Since C++17, the allocation of memory is sequenced <em>before</em> the evaluation of <code>f()</code>, so the memory will always be deallocated:</p>\n<blockquote>\n<p id=\"so_39330251_39330368_2\">21 - If any part of the object initialization described above<sup>79</sup> terminates by throwing an exception and a suitable\n  deallocation function can be found, the deallocation function is called [...]</p>\n</blockquote>\n<p>Note though that since memory allocation is elidable, the implementation is in practice free to omit the allocation if it can predict that an exception will be thrown.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2016-09-05T12:27:17.993", "Score": "4", "CreationDate": "2016-09-05T12:12:56.890", "ParentId": "39330251", "CommentCount": "11", "OwnerUserId": "567292", "LastEditDate": "2016-09-05T12:27:17.993"}, "39330251": {"ViewCount": "96", "Body": "<p>I know that an implementation should free any allocated memory if the constructor of an object throws an exception in situation like this:</p>\n<pre><code>new T(); // Suppose that T() throws an exception\n</code></pre>\n<p>but what about the following code?</p>\n<pre><code>new T(f()); // Suppose that T() does NOT throw any exception, but f() does\n</code></pre>\n<p>What should implementation do in this case? Should it free any allocated memory then?</p>\n", "AcceptedAnswerId": "39330368", "Title": "What an implementation should do in case of operator new and \"nested\" initialization", "CreationDate": "2016-09-05T12:06:23.517", "Id": "39330251", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-09-05T12:27:17.993", "Score": "8", "OwnerUserId": "1608835", "Tags": "<c++>", "AnswerCount": "1"}});