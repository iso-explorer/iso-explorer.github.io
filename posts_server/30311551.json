post_cb({"30311551": {"CommentCount": "4", "ViewCount": "311", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-18T19:40:47.587", "LastActivityDate": "2015-05-22T19:59:03.287", "Title": "Is it undefined behavior to #define/#undef an identifier with special meaning?", "LastEditDate": "2017-05-23T10:27:00.070", "Id": "30311551", "Score": "13", "Body": "<p>An answer to the question <a href=\"https://stackoverflow.com/q/30303228/1708801\">Disable check for override in gcc</a> suggested using <code>-Doverride=</code> on the command line to disable errors for erroneous use of <a href=\"http://en.cppreference.com/w/cpp/language/override\" rel=\"nofollow noreferrer\">override</a>, which is effectively the same as adding:</p>\n<pre><code>#define override\n</code></pre>\n<p>to the source file.</p>\n<p>My initial reaction was that this seems like undefined behavior since we are redefining a keyword but looking at the draft C++11 standard section <code>2.12</code> <em>Keywords [lex.key]</em> I was surprised that neither <em>override</em> nor <em>final</em> are keywords. They are covered in the previous section <code>2.11</code> <em>[lex.name]</em> which says they are identifiers with special meaning:</p>\n<blockquote>\n<p id=\"so_30311551_30311551_0\">The identifiers in Table 3 have a special meaning when appearing in a\n  certain context[...]</p>\n</blockquote>\n<p>and <em>Table 3</em> is labelled <em>Identifiers with special meaning</em> and includes both <em>override</em> and <em>final</em>.</p>\n<p>The question is, is it undefined behavior to redefine(<em>using #define</em>) <em>identifiers with special meaning</em>? Are they treated any differently than <em>keywords</em> in this respect?</p>\n", "Tags": "<c++><c++11><language-lawyer><undefined-behavior>", "OwnerUserId": "1708801", "AnswerCount": "2"}, "30311552": {"ParentId": "30311551", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If you are using the C++ standard library it is undefined behavior to redefine <em>identifiers with special meaning</em>, this also applies to <em>keywords</em>. From the draft C++11 standard under section <code>17.6.4</code> <em>[constraints]</em> we have section <code>17.6.4.1</code> <em>[constraints.overview]</em> which says:</p>\n<blockquote>\n<p id=\"so_30311551_30311552_0\">This section describes restrictions on C++ programs that use the\n  facilities of the C++ standard library [...]</p>\n</blockquote>\n<p>and under <code>17.6.4</code> we have section <code>17.6.4.3.1</code> <em>[macro.names]</em> which says:</p>\n<blockquote>\n<p id=\"so_30311551_30311552_1\">A translation unit shall not #define or #undef names lexically\n  identical to keywords, to the identifiers listed in Table 3, or to the\n  attribute-tokens described in 7.6.</p>\n</blockquote>\n<p><em>Table 3</em> list the <em>Identifiers with special meaning</em>. We can see this paragraph also covers <em>keywords</em> and they are treated in the same manner.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-05-19T03:53:25.210", "Id": "30311552", "Score": "12", "CreationDate": "2015-05-18T19:40:47.587", "LastActivityDate": "2015-05-19T03:53:25.210"}, "30312720": {"ParentId": "30311551", "CommentCount": "10", "Body": "<p>Implementations' standard header files are allowed to \"implement\" standard functions using macros in cases where a macro could meet the requirements for the function (including ensuring that arguments are evaluated exactly once).  Further, such macros are allowed to make use of keywords or identifiers whose behavior is specified in in the standard or \"reserved to the implementation\"; use of such macros in contexts where the keywords or identifiers have been redefined could have arbitrary effects.</p>\n<p>That having been said, the historical interpretation of this form of UB would be to say that compilers shouldn't go out of their way to cause wacky behavior, and outside of \"pedantic modes\" should allow user code to assign meanings to reserved identifiers the compiler would otherwise not use. This can be helpful in cases where code should be usable both on compilers which would require a keyword like <code>__packed</code>, and on compilers which neither recognize nor require such a keyword.). Redefining keywords in the fashion you're doing is a bit dodgier; it will probably work, but there's a significant likelihood that that it will disrupt the behavior of a standard-library macro.</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "30312720", "Score": "1", "CreationDate": "2015-05-18T20:58:49.487", "LastActivityDate": "2015-05-18T20:58:49.487"}, "bq_ids": {"n4140": {"so_30311551_30311552_1": {"section_id": 6306, "quality": 0.7692307692307693, "length": 10}, "so_30311551_30311551_0": {"section_id": 5334, "quality": 0.8, "length": 8}, "so_30311551_30311552_0": {"section_id": 6298, "quality": 0.875, "length": 7}}, "n3337": {"so_30311551_30311552_1": {"section_id": 6063, "quality": 0.7692307692307693, "length": 10}, "so_30311551_30311551_0": {"section_id": 5131, "quality": 0.8, "length": 8}, "so_30311551_30311552_0": {"section_id": 6055, "quality": 0.875, "length": 7}}, "n4659": {"so_30311551_30311552_1": {"section_id": 7817, "quality": 0.7692307692307693, "length": 10}, "so_30311551_30311551_0": {"section_id": 6755, "quality": 0.8, "length": 8}, "so_30311551_30311552_0": {"section_id": 7807, "quality": 0.875, "length": 7}}}});