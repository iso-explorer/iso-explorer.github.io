post_cb({"bq_ids": {"n4140": {"so_44067289_44067863_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 3922}, "so_44067289_44067863_0": {"length": 6, "quality": 1.0, "section_id": 3922}}, "n3337": {"so_44067289_44067863_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 3781}}, "n4659": {"so_44067289_44067863_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 4808}, "so_44067289_44067863_0": {"length": 6, "quality": 1.0, "section_id": 4808}}}, "44067863": {"Id": "44067863", "PostTypeId": "2", "Body": "<p>This is a Most Vexing Parse issue. The <a href=\"https://stackoverflow.com/questions/1424510/most-vexing-parse-why-doesnt-a-a-work\">canonical case</a> would be:</p>\n<pre><code>T t( U(x) );\n</code></pre>\n<p>where T and U are previously known to be type names. This could be parsed in two valid ways:</p>\n<ul>\n<li>a declaration of <code>t</code> as an object of type <code>T</code>, with the initializer being the expression <code>U(x)</code>, a function-style cast of the variable <code>x</code> to a temporary <code>U</code></li>\n<li>a declaration of <code>t</code> as a function returning <code>T</code>, with 1 parameter of type <code>U</code> and name <code>x</code>; and there are redundant parentheses around <code>x</code>. (Declarators may be parenthesized).</li>\n</ul>\n<p>The text in the Standard for disambiguating is in [dcl.ambig.res]/1. What it says is that parsing this code hinges on whether <code>U(x)</code> would be a declaration or an expression, and then refers to [stmt.ambig].</p>\n<p>In [stmt.ambig]/2 there is a clarifying example. I won't reproduce the full example here (you can look it up in a standards draft) but the accompanying text is:</p>\n<blockquote>\n<p id=\"so_44067289_44067863_0\">If the statement cannot <strong>syntactically</strong> be a declaration, there is no ambiguity</p>\n<p id=\"so_44067289_44067863_1\">[...] This is of course ill-formed for semantic reasons, but that does not affect the syntactic analysis. In those cases the statement is a declaration.</p>\n</blockquote>\n<p>What this is trying to say is that if the code can be matched to the rules in the language grammar for a declaration, then it is a declaration, even if the code subsequently falls foul of a semantic rule.</p>\n<hr>\n<p>Looking at your variation now, where the inner code is (simplified) <code>U(A::e)</code> where <code>e</code> is an enumerator in the scope of <code>A</code>.</p>\n<p>I believe this code <em>does</em> still match the grammar rule for a declaration. See [dcl.decl]/4 grammar specification (selected parts):</p>\n<blockquote>\n<p id=\"so_44067289_44067863_2\"><em>noptr-declarator: declarator-id attribute-specifier-seq<sub>opt</sub></em></p>\n<p id=\"so_44067289_44067863_3\"><em>declarator-id: ...<sub>opt</sub> id-expression</em></p>\n</blockquote>\n<p>and <em>id-expression</em> can be <em>qualified-id</em> or <em>unqualified-id</em>, and finally, <code>A::e</code> is a <em>qualified-id</em>.</p>\n<p>Even though there is a semantic rule [dcl.meaning]/1 that the <em>declarator-id</em> can only be a <em>qualified-id</em> in certain contexts, excluding this case,  that's not a grammar rule.</p>\n<p>So I would say VC is correct to reject the code.</p>\n<hr>\n<p>To fix the code, assuming the intent is for <code>a2</code> to be an object declaration, you can use the same techniques as mentioned on the canonical MVP thread:</p>\n<pre><code>A a2{A::B(A::eA2)};    // braced initialization\n\nA a2((A::B(A::eA2)));  // function declarations can't have extra parentheses around the entire parameter declaration, so this cannot be a function declaration \n</code></pre>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-19T10:59:13.047", "Score": "2", "CreationDate": "2017-05-19T10:37:19.040", "ParentId": "44067289", "CommentCount": "2", "OwnerUserId": "1505939", "LastEditDate": "2017-05-23T12:18:24.630"}, "44067289": {"ViewCount": "37", "Body": "<p>I'm a little bit supprised as i see this compilation error;</p>\n<p>Here is the example:</p>\n<pre><code>class A\n{\npublic:\n  enum eA { eA1, eA2 };\n\n  class B\n  {\n  public:\n    B(eA e, int i = 0);\n  };\n\n  A(const B &amp;b);\n};\n\nA::A(const B &amp;b)\n{\n}\n\nA::B::B(eA e, int i /*= 0*/)\n{\n}\n\nint main()\n{\n  A::B b(A::eA1);        // OK\n  A a0(b);               // OK\n  A a1(A::B(A::eA1, 0)); // OK\n  A a2(A::B(A::eA2));    //error C2751: 'A::eA2': the name of a function parameter cannot be qualified\n  return 0;\n}\n</code></pre>\n<p>As pointed in comments, <code>A a2(A::B(A::eA2));</code> doesn't compile. Why?\nI'm not asking how to compile it. Why it doesn't compile?</p>\n<p>It compiles, if first parameter type of class-<code>B</code> is not from class-<code>A</code>. for example with <code>int</code> it compiles.</p>\n", "AcceptedAnswerId": "44067863", "Title": "Can not instantiate class as LHS value with qualified enum as argument (C++ VS2015)", "CreationDate": "2017-05-19T10:11:30.687", "Id": "44067289", "CommentCount": "15", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-19T11:06:44.240", "LastEditorUserId": "6690542", "LastActivityDate": "2017-05-19T11:06:44.240", "Score": "3", "OwnerUserId": "6690542", "Tags": "<c++><class><compiler-errors><language-lawyer><most-vexing-parse>", "AnswerCount": "1"}});