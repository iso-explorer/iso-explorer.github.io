post_cb({"27764277": {"CommentCount": "10", "ViewCount": "214", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-01-04T09:47:34.237", "LastActivityDate": "2015-01-04T16:23:16.033", "Title": "why does std::for_each iterator need a copy constructable iterator", "AcceptedAnswerId": "27767611", "LastEditDate": "2017-05-23T10:32:36.533", "Id": "27764277", "Score": "3", "Body": "<p>I noticed that std::for_each requires it's iterators to meet the requirement InputIterator, which in turn requires Iterator and then Copy{Contructable,Assignable}.</p>\n<p>That's not the only thing, std::for_each actually uses the copy constructor (cc) (not assignment as far as my configuration goes). That is, deleting the cc from the iterator will result in:</p>\n<pre><code>error: use of deleted function \u2018some_iterator::some_iterator(const some_iterator&amp;)\u2019\n</code></pre>\n<p>Why does std::for_each need a cc? I found this particularly inconvenient, since I created an iterator which recursively iterates through files in a folder, keeping track of the files and folders on a queue. This means that the iterator has a queue data member, which would also have to be copied if the cc is used: that is unnecessarily inefficient.</p>\n<p>The strange thing is that the cc is not called in this simple example:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n\n\nclass infinite_5_iterator\n:\npublic std::iterator&lt;std::input_iterator_tag, int&gt;\n{\npublic:\n  infinite_5_iterator() = default;\n  infinite_5_iterator(infinite_5_iterator const &amp;) {std::cout &lt;&lt; \"copy constr \"; }\n\n  infinite_5_iterator &amp;operator=(infinite_5_iterator const &amp;) = delete;\n\n\n  int operator*() { return 5; }\n  infinite_5_iterator &amp;operator++() { return *this; }\n  bool operator==(infinite_5_iterator const &amp;) const { return false; }\n  bool operator!=(infinite_5_iterator const &amp;) const { return true; }\n};\n\nint main() {\n  std::for_each(infinite_5_iterator(), infinite_5_iterator(),\n    [](int v) {\n      std::cout &lt;&lt; v &lt;&lt; ' ';\n    }\n  );\n}\n</code></pre>\n<p>source: <a href=\"http://ideone.com/YVHph8\" rel=\"nofollow noreferrer\">http://ideone.com/YVHph8</a></p>\n<p>It however is needed compile time. Why does std::for_each need to copy construct the iterator, and when is this done? Isn't this extremely inefficient?</p>\n<p>NOTE: I'm talking about the cc of the iterator, not of it's elements, as is done here: <a href=\"https://stackoverflow.com/questions/20709342/unexpected-copies-with-foreach-over-a-map\">unexpected copies with foreach over a map</a></p>\n<p>EDIT: Note that the standard does not state the copy-constructor is called at all, it just expresses the amount of times f is called. May I then assume that the cc is not called at all? Why is the use of operator++ and operator* and cc not specified, but the use of f is?</p>\n<p><img alt=\"std::for_each documentation\" src=\"https://i.stack.imgur.com/u8knv.png\"/></p>\n", "Tags": "<c++11><stl><iterator>", "OwnerUserId": "853462", "AnswerCount": "1"}, "27767611": {"ParentId": "27764277", "CommentCount": "5", "Body": "<p>You have simply fallen victim to a specification that has evolved in bits and pieces over decades.  The concept of <code>InputIterator</code> was invented a long time before the notion of move-only types, or movable types was conceived.</p>\n<p>In hindsight I would love to declare that <code>InputIterator</code> need not be copyable.  This would mesh perfectly with its single-pass behavior.  But I also fear that such a change would have overwhelming backwards compatibility problems.</p>\n<p>In addition to the flawed iterator concepts as specified in the standard, about a decade ago, in an attempt to be helpful, the gcc std::lib (libstdc++) started imposing \"concepts\" on things like <code>InputIterator</code> in the std-algorithms.  I.e. because the standard says: </p>\n<blockquote>\n<p id=\"so_27764277_27767611_0\"><em>Requires:</em> <code>InputIterator</code> shall satisfy the requirements of an input iterator (24.2.3).</p>\n</blockquote>\n<p>then \"concept checks\" were inserted into the std-algorithms that require <code>InputIterator</code> to meet all of the requirements of input iterator <em>whether or not the algorithm actually used all of those requirements.</em>  And in this case, it is the concept check, not the actual algorithm, that is requiring your iterator to be <code>CopyConstructible</code>.</p>\n<p>&lt;sigh&gt;</p>\n<p>If you write your own <code>for_each</code> algorithm, it is trivial to do so without requiring your iterators to be <code>CopyConstructible</code> or <code>CopyAssignable</code> (if supplied with rvalue iterator arguments):</p>\n<pre><code>template &lt;class InputIterator, class Function&gt;\ninline\nFunction\nfor_each(InputIterator first, InputIterator last, Function f)\n{\n    for (; first != last; ++first)\n        f(*first);\n    return f;\n}\n</code></pre>\n<p>And for your use case I recommend either doing that, or simply writing your own loop.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "27767611", "Score": "5", "CreationDate": "2015-01-04T16:23:16.033", "LastActivityDate": "2015-01-04T16:23:16.033"}, "bq_ids": {"n4140": {"so_27764277_27767611_0": {"section_id": 1238, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_27764277_27767611_0": {"section_id": 1236, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_27764277_27767611_0": {"section_id": 1326, "quality": 0.7142857142857143, "length": 5}}}});