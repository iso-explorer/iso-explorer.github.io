post_cb({"bq_ids": {"n4140": {"so_7401269_7404946_0": {"length": 21, "quality": 0.5526315789473685, "section_id": 3361}, "so_7401269_7404946_1": {"length": 24, "quality": 0.6153846153846154, "section_id": 3362}}, "n3337": {"so_7401269_7404946_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 3231}, "so_7401269_7404946_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 3232}}, "n4659": {"so_7401269_7404946_0": {"length": 21, "quality": 0.5526315789473685, "section_id": 4127}, "so_7401269_7404946_1": {"length": 24, "quality": 0.6153846153846154, "section_id": 4128}}}, "7401451": {"Id": "7401451", "PostTypeId": "2", "Body": "<p>There might be invisible data associated with your exception, e.g. a <a href=\"http://en.wikipedia.org/wiki/Vtable\" rel=\"nofollow\">vtable</a>.</p>\n<p>The vtable is an invisible data structure that carries information about where certain, polymorphic (i.e. <code>virtual</code>) member functions can be found. This table in the general case costs a bit of memory that is held in the object itself. This may by the size of a pointer into some external table, or even the complete table. As always, it depends.</p>\n", "LastEditorUserId": "76722", "LastActivityDate": "2011-09-13T13:33:42.490", "Score": "1", "CreationDate": "2011-09-13T11:56:42.763", "ParentId": "7401269", "CommentCount": "2", "OwnerUserId": "76722", "LastEditDate": "2011-09-13T13:33:42.490"}, "7401332": {"Id": "7401332", "PostTypeId": "2", "Body": "<p>I would prefer catching by reference. The compiler could discard the exception as an optimization and do no copy, but that's only a <em>possibility</em>. Catching by reference gives you certainties.</p>\n", "LastActivityDate": "2011-09-13T11:47:43.310", "CommentCount": "2", "CreationDate": "2011-09-13T11:47:43.310", "ParentId": "7401269", "Score": "1", "OwnerUserId": "46642"}, "7401269": {"ViewCount": "2473", "Body": "<p>When catching an exception the standard guidance is to throw by value, catch by reference. As I understand it, this is for two reasons:</p>\n<ol>\n<li>If the exception was thrown due to an out of memory exception, we won't call a copy constructor which could potentially terminate the program.</li>\n<li>If the exception is part of an inheritance heirarchy, we may potentially have object slicing on the exception.</li>\n</ol>\n<p>If we have a scenario where we don't define the exception name in the catch block are these concerns (really 1., as slicing won't be an issue if we don't have a name for the variable) still valid?</p>\n<p>For example:</p>\n<pre><code>catch(my_exception)\n{ ... }\n</code></pre>\n<p>or</p>\n<pre><code>catch(my_exception &amp;)\n{ ... }\n</code></pre>\n<p>Is there still the possibility of the program terminating if the exception caught by value in this case? My feeling is that it is technically still possible.</p>\n<p>Note: I am asking this because I have had to review someone's code who put a catch by value in this case. As shown in the question I am not entirely sure on the technical impact of either choice, but I think that in terms of consistancy it is better to catch by reference in this case regardless (there is no downside to catching by reference in any case).</p>\n", "AcceptedAnswerId": "7404946", "Title": "Catch by reference when exception variable is not defined", "CreationDate": "2011-09-13T11:42:10.187", "Id": "7401269", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-09-13T11:50:25.553", "LastEditorUserId": "253902", "LastActivityDate": "2011-09-13T16:42:16.493", "Score": "2", "OwnerUserId": "253902", "Tags": "<c++><exception>", "AnswerCount": "3"}, "7404946": {"Id": "7404946", "PostTypeId": "2", "Body": "<p>The standard does not require special optimization in the case of an unnamed exception object. On the contrary, it then requires an effect as if a temporary is copy-initialized. This copying can result in memory being dynamically allocated.</p>\n<blockquote>\n<p id=\"so_7401269_7404946_0\"><strong>N3290 \u00a715.3/16</strong>:<br>\n  If the <em>exception-declaration</em> specifies a name, it declares a variable which is copy-initialized (8.5) from the\n  exception object. If the <em>exception-declaration</em> denotes an object type but does not specify a name, a temporary (12.2) is copy-initialized (8.5) from the exception object. The lifetime of the variable or temporary\n  ends when the handler exits, after the destruction of any automatic objects initialized within the handler.</br></p>\n</blockquote>\n<p>The paragraph above does not mention catching by reference, and so one might reasonably conclude that it applies whether or not the exception object is caught by reference; that a copy is constructed anyway.</p>\n<p>However, that is contradicted by the next paragraph:</p>\n<blockquote>\n<p id=\"so_7401269_7404946_1\"><strong>N3290 \u00a715.3/17</strong>:<br>\n  When the handler declares a non-constant object, any changes to that object will not affect the temporary\n  object that was initialized by execution of the <em>throw-expression</em>. When the handler declares a reference to\n  a non-constant object, any changes to the referenced object are changes to the temporary object initialized\n  when the <em>throw-expression</em> was executed and will have effect should that object be rethrown.</br></p>\n</blockquote>\n<p>So, declared type <code>T&amp;</code> (with <code>T</code> non-<code>const</code>) is the single case where C++11 requires a reference directly to the thrown object, instead of copying. And it is also that way in C++03, except that C++03 has some additional wording about as-if optimization. So, for the formal the preference should be for</p>\n<pre><code>    catch( T&amp; name )\n</code></pre>\n<p>and</p>\n<pre><code>    catch( T&amp; )\n</code></pre>\n<p>However, I have always caught exceptions like <code>catch( T const&amp; )</code>. From a practical point of view one may assume that the compiler will optimize that to a direct reference to the thrown object, even though it is possible to devise cases where the observed program effect would then be non-standard. For example <code>&lt;evil grin&gt;</code></p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdexcept&gt;\n\nstruct Error\n    : std::runtime_error\n{\npublic:\n    static Error* pThrown;\n\n    char const* pMessage_;\n    Error()\n        : std::runtime_error( \"Base class message\" )\n        , pMessage_( \"Original message.\" )\n    {\n        printf( \"Default-construction of Error object.\\n\" );\n        pThrown = this;\n    }\n\n    Error( Error const&amp; other )\n        : std::runtime_error( other )\n        , pMessage_( other.pMessage_ )\n    {\n        printf( \"Copy-construction of Error obejct.\\n\" );\n    }\n\n    char const* what() const throw() { return pMessage_; }\n};\n\nError*  Error::pThrown  = 0;\n\nint main()\n{\n    printf( \"Testing non-const ref:\\n\" );\n    try\n    {\n        throw Error();\n    }\n    catch( Error&amp; x )\n    {\n        Error::pThrown-&gt;pMessage_ = \"Modified message.\";\n        printf( \"%s\\n\", x.what() );\n    }\n\n    printf( \"\\n\" );\n    printf( \"Testing const ref:\\n\" );\n    try\n    {\n        throw Error();\n    }\n    catch( Error const&amp; x )\n    {\n        Error::pThrown-&gt;pMessage_ = \"Modified message\";\n        printf( \"%s\\n\", x.what() );\n    }\n}\n</code></pre>\n<p>With both MinGW g++ 4.4.1 and Visual C++ 10.0 the output is \u2026</p>\n<pre>\nTesting non-const ref:\nDefault-construction of Error object.\nModified message.\n\nTesting const ref:\nDefault-construction of Error object.\nModified message\n</pre>\n<p>A pedantic formalist might say that both compilers are non-conforming, failing to create a copy for the <code>Error const&amp;</code> case. A purely practical practitioner might say that hey, what else did you <em>expect</em>? And me, I say that the wording in the standard is very far from perfect here, and that if anything, one should expect a clarification to explicitly allow the output above, so that also catching by reference to <code>const</code> is both safe and maximally efficient.</p>\n<p>Summing up wrt. the OP's question:</p>\n<ul>\n<li><p>Catching by reference won\u2019t call a copy constructor which could potentially terminate the program.</p></li>\n<li><p>The standard only guarantees this for reference to non-<code>const</code>.</p></li>\n<li><p>In practice, as shown, it is also guaranteed for reference to <code>const</code>, even when program results are then affected.</p></li>\n</ul>\n<p>Cheers &amp; hth.,</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2011-09-13T16:42:16.493", "Score": "4", "CreationDate": "2011-09-13T16:03:30.303", "ParentId": "7401269", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2011-09-13T16:42:16.493"}});