post_cb({"4294134": {"ParentId": "4294100", "CommentCount": "1", "Body": "<p>The code that you have provided should compile okay (providing the <code>operator</code> is <code>public</code> and you terminate your <code>class</code> declaration with a <code>;</code>). I suspect the compiler error is somewhere else.</p>\n<p>Personally, I would use <code>std::map&lt;std::string, std::string&gt;</code> as the container class.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;assert.h&gt;\n\nint main()\n{\n    std::map&lt;std::string, std::string&gt; m;\n    m[\"Foo\"] = \"Bar\";\n    m[\"Fez\"] = \"Baz\";\n\n    assert(m[\"Foo\"] == \"Bar\");\n    assert(m[\"Fez\"] == \"Baz\");\n}\n</code></pre>\n", "OwnerUserId": "78845", "PostTypeId": "2", "Id": "4294134", "Score": "2", "CreationDate": "2010-11-27T21:58:11.350", "LastActivityDate": "2010-11-27T21:58:11.350"}, "bq_ids": {"n4140": {"so_4294100_4294152_0": {"section_id": 3290, "quality": 1.0, "length": 7}, "so_4294100_4294152_3": {"section_id": 3290, "quality": 1.0, "length": 9}}, "n3337": {"so_4294100_4294152_0": {"section_id": 3160, "quality": 1.0, "length": 7}, "so_4294100_4294152_3": {"section_id": 3160, "quality": 1.0, "length": 9}}, "n4659": {"so_4294100_4294152_0": {"section_id": 4052, "quality": 1.0, "length": 7}, "so_4294100_4294152_3": {"section_id": 4052, "quality": 1.0, "length": 9}}}, "4294100": {"CommentCount": "3", "AcceptedAnswerId": "4294152", "CreationDate": "2010-11-27T21:48:23.947", "LastActivityDate": "2010-11-27T22:36:43.123", "PostTypeId": "1", "ViewCount": "4816", "FavoriteCount": "1", "Title": "Creating a class indexer operator[] allowing string parameter (string index)", "Id": "4294100", "Score": "3", "Body": "<p>I want to create a class in c++. This class must manage with a collection.\nOK, no problem, I would like to use operator[] of course but, in this case, my wish is to index not by position, but by name ==&gt; that means using a string indexer.</p>\n<p>It seems that something of this kind is not so nice to my compiler:</p>\n<pre><code>// In hpp\nclass myclass {\n   ...\n   ...\n   std::string operator[](const std::string&amp; name);\n}\n// In cpp\nstd::string myclass::operator[](const std::string&amp; name) {\n   ...\n}\n// In main\nmyclass m;\nstd::string value = m[\"Name\"];\n</code></pre>\n<p>Compiler tells me that he cannot solve this because operator[const char[5]] does not exists.\nOK OK\nI could figure this...\nCompiler thinks that by calling m[\"Name\"] I'm trying to call an operator admitting a char* and not a string... ok\nLet's change the code with operator[] allowing a char* as parameter... nothing.</p>\n<p>Can somebody tell me how to achieve such a result in c++ in a best practice way? I suppose that is a common problem to index by string and not by integer...\nThank you.</p>\n", "Tags": "<c++><string><indexing><operator-overloading>", "OwnerUserId": "519836", "AnswerCount": "2"}, "4294152": {"ParentId": "4294100", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It should work fine. See this example which compiles and works ok for me:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass MyClass\n{\n    public:\n        std::string operator[] (const std::string&amp; key) { std::cout &lt;&lt; key &lt;&lt; std::endl; return key; }\n};\n\nint main()\n{\n    MyClass obj;\n    std::string s = obj[\"50\"];\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And I see no reason it should not, since std::string has implicit constructor taking <code>const char*</code> so the conversion should be automatic.</p>\n<p>Edit: From the comment it seems your problem was with your main beeing like this:</p>\n<pre><code>int main()\n{\n    MyClass obj();\n    std::string s = obj[\"50\"];\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The reason:</p>\n<blockquote>\n<p id=\"so_4294100_4294152_0\">An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized.</p>\n<p id=\"so_4294100_4294152_1\">[ Note: since () is not permitted by the syntax for initializer,</p>\n<p id=\"so_4294100_4294152_2\">X a ();</p>\n<p id=\"so_4294100_4294152_3\">is not the declaration of an object of class X, but the declaration of a function taking no argument and returning an X.</p>\n<p id=\"so_4294100_4294152_4\">The form () is permitted in certain other initialization contexts (5.3.4, 5.2.3, 12.6.2). \u2014 end note ]</p>\n</blockquote>\n", "OwnerUserId": "366672", "LastEditorUserId": "366672", "LastEditDate": "2010-11-27T22:36:43.123", "Id": "4294152", "Score": "1", "CreationDate": "2010-11-27T22:03:32.187", "LastActivityDate": "2010-11-27T22:36:43.123"}});