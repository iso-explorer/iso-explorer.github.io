post_cb({"3484265": {"Id": "3484265", "PostTypeId": "2", "Body": "<p>You have reached circular dependencies. See <a href=\"http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.11\" rel=\"nofollow noreferrer\">FAQ 39.11</a> And yes, modifying <code>const</code> data is UB even if you have circumvented the compiler. Also, you are severely impairing the compiler's capacity to optimize if you don't keep your promises (read: violate <code>const</code>). </p>\n<p>Why is <code>Questionable</code> <code>const</code> if you know that you will modify it via a call to its owner? Why does the owned object need to know about the owner? If you really really need to do that then <code>mutable</code> is the way to go. That is what it is there for -- logical constness (as opposed to strict bit level constness).</p>\n<p>From my copy of the draft n3090:</p>\n<blockquote>\n<p id=\"so_3484233_3484265_0\"><strong>9.3.2 The this pointer</strong> [class.this]</p>\n<p id=\"so_3484233_3484265_1\"><strong>1</strong> In the body of a non-static (9.3) member function, the keyword this is an rvalue a prvalue expression whose\n  value is the address of the object for which the function is called. The type of this in a member function\n  of a class X is X*. <strong><em>If the member function is declared const, the type of this is const X*</em></strong>, if the member\n  function is declared volatile, the type of this is volatile X*, and if the member function is declared \n  const volatile, the type of this is const volatile X*.</p>\n<p id=\"so_3484233_3484265_2\"><strong>2</strong> In a const member function, the object for which the function is called is accessed through a const access\n  path; therefore, a const member function shall not modify the object and its non-static data members.</p>\n</blockquote>\n<p>[Note emphasis mine].</p>\n<p>On UB:</p>\n<blockquote>\n<p id=\"so_3484233_3484265_3\"><strong>7.1.6.1 The cv-qualifiers</strong></p>\n<p id=\"so_3484233_3484265_4\"><strong>3</strong> A pointer or reference to a cv-qualified type need not actually\n  point or refer to a cv-qualified\n  object, but it is treated as if it\n  does; a const-qualified access path\n  cannot be used to modify an object\n  even if the object referenced is a\n  non-const object and can be modified\n  through some other access path. [\n  Note: cv-qualifiers are supported by\n  the type system so that they cannot be\n  subverted without casting (5.2.11).\n  \u2014end note ] </p>\n<p id=\"so_3484233_3484265_5\"><strong>4</strong> Except that any class\n  member declared mutable (7.1.1) can be\n  modified, any attempt to modify a\n  const object during its lifetime (3.8)\n  results in undefined behavior.</p>\n</blockquote>\n", "LastEditorUserId": "66692", "LastActivityDate": "2010-08-14T21:38:45.563", "Score": "-1", "CreationDate": "2010-08-14T16:57:29.043", "ParentId": "3484233", "CommentCount": "21", "OwnerUserId": "66692", "LastEditDate": "2010-08-14T21:38:45.563"}, "3485393": {"Id": "3485393", "PostTypeId": "2", "Body": "<p>Without actually getting to whether it is/should/could be allowed, I would greatly advice against it. There are mechanisms in the language for what you want to achieve that don't require writing obscure constructs that will most probably confuse other developers.</p>\n<p>Look into the <code>mutable</code> keyword. That keyword can be used to declare members that can be modified within <code>const</code> member methods as they do not affect the perceivable state of the class. Consider class that gets initialized with a set of parameters and performs a complex expensive calculation that may not be needed always:</p>\n<pre><code>class ComplexProcessor\n{\npublic:\n   void setInputs( int a, int b );\n   int getValue() const;\nprivate:\n   int complexCalculation( int a, int b );\n   int result;\n};\n</code></pre>\n<p>A possible implementation is adding the result value as a member and calculating it for each set: </p>\n<pre><code>void ComplexProcessor::setInputs( int a, int b ) {\n   result = complexCalculation( a, b );\n}\n</code></pre>\n<p>But this means that the value is calculated in all sets, whether it is needed or not. If you think on the object as a black box, the interface just defines a method to set the parameters and a method to retrieve the calculated value. The instant when the calculation is performed does not really affect the perceived state of the object --as far as the value returned by the getter is correct. So we can modify the class to store the inputs (instead of the outputs) and calculate the result only when needed:</p>\n<pre><code>class ComplexProcessor2 {\npublic:\n   void setInputs( int a, int b ) {\n      a_ = a; b_ = b;\n   }\n   int getValue() const {\n      return complexCalculation( a_, b_ );\n   }\nprivate:\n   int complexCalculation( int a, int b );\n   int a_,b_;\n};\n</code></pre>\n<p>Semantically the second class and the first class are equivalent, but now we have avoided to perform the complex calculation if the value is not needed, so it is an advantage if the value is only requested in some cases. But at the same time it is a disadvantage if the value is requested many times for the same object: each time the complex calculation will be performed even if the inputs have not changed.</p>\n<p>The solution is caching the result. For that we can the result to the class. When the result is requested, if we have already calculated it, we only need to retrieve it, while if we do not have the value we must calculate it. When the inputs change we invalidate the cache. This is when the <code>mutable</code> keyword comes in handy. It tells the compiler that the member is not part of the perceivable state and as such it can be modified within a constant method:</p>\n<pre><code>class ComplexProcessor3 {\npublic:\n   ComplexProcessor3() : cached_(false) {}\n   void setInputs( int a, int b ) {\n      a_ = a; b_ = b;\n      cached_ = false;\n   }\n   int getValue() const {\n      if ( !cached_ ) {\n         result_ = complexCalculation( a_, b_ );\n         cached_ = true;\n      }\n      return result_;\n   }\nprivate:\n   int complexCalculation( int a, int b );\n   int a_,b_;\n   // This are not part of the perceivable state:\n   mutable int result_;\n   mutable bool cached_;\n};\n</code></pre>\n<p>The third implementation is semantically equivalent to the two previous versions, but avoid having to recalculate the value if the result is already known --and cached.</p>\n<p>The <code>mutable</code> keyword is needed in other places, like in multithreaded applications the mutex in classes are often marked as <code>mutable</code>. Locking and unlocking a mutex are mutating operations for the mutex: its state is clearly changing. Now, a getter method in an object that is shared among different threads does not modify the perceived state but must acquire and release the lock if the operation has to be thread safe:</p>\n<pre><code>template &lt;typename T&gt;\nclass SharedValue {\npublic:\n   void set( T v ) {\n      scoped_lock lock(mutex_);\n      value = v;\n   }\n   T get() const {\n      scoped_lock lock(mutex_);\n      return value;\n   }\nprivate:\n   T value;\n   mutable mutex mutex_;\n};\n</code></pre>\n<p>The getter operation is semantically constant, even if it needs to modify the mutex to ensure single threaded access to the <code>value</code> member.</p>\n", "LastActivityDate": "2010-08-14T22:34:21.617", "CommentCount": "0", "CreationDate": "2010-08-14T22:34:21.617", "ParentId": "3484233", "Score": "1", "OwnerUserId": "36565"}, "3484233": {"ViewCount": "2626", "Body": "<p>The following pattern has arisen in a program I'm writing.  I hope it's not too contrived, but it manages to mutate a <code>Foo</code> object in the const method <code>Foo::Questionable() const</code>, without use of any const_cast or similar.  Basically, <code>Foo</code> stores a reference to <code>FooOwner</code> and vice versa, and in <code>Questionable()</code>, <code>Foo</code> manages to modify itself in a const method by calling <code>mutate_foo()</code> on its owner.  Questions follow the code.</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass FooOwner;\n\nclass Foo {\n    FooOwner&amp; owner;\n    int data;\n\npublic:\n    Foo(FooOwner&amp; owner_, int data_)\n        : owner(owner_),\n          data(data_)\n    {\n    }\n\n    void SetData(int data_)\n    {\n        data = data_;\n    }\n\n    int Questionable() const;       // defined after FooOwner\n};\n\nclass FooOwner {\n    Foo* pFoo;\n\npublic:\n    FooOwner()\n        : pFoo(NULL)\n    {}\n\n    void own(Foo&amp; foo)\n    {\n        pFoo = &amp;foo;\n    }\n\n    void mutate_foo()\n    {\n        if (pFoo != NULL)\n            pFoo-&gt;SetData(0);\n    }\n};\n\nint Foo::Questionable() const\n{\n    owner.mutate_foo();     // point of interest\n    return data;\n}\n\nint main()\n{\n    FooOwner foo_owner;\n    Foo foo(foo_owner, 0);      // foo keeps reference to foo_owner\n    foo_owner.own(foo);         // foo_owner keeps pointer to foo\n\n    cout &lt;&lt; foo.Questionable() &lt;&lt; endl;  // correct?\n\n    return 0;\n}\n</code></pre>\n<p>Is this defined behavior?  Should <code>Foo::data</code> be declared mutable?  Or is this a sign I'm doing things fatally wrong?  I'm trying to implement a kind of lazy-initialised 'data' which is only set when requested, and the following code compiles fine with no warnings, so I'm a little nervous I'm in UB land.</p>\n<p>Edit: the <code>const</code> on Questionable() only makes immediate members const, and not the objects pointed to or referenced by the object.  Does this make the code legal?  I'm confused between the fact that in <code>Questionable()</code>, <code>this</code> has the type <code>const Foo*</code>, and further down the call stack, <code>FooOwner</code> legitimately has a non-const pointer it uses to modify <code>Foo</code>.  Does this mean the <code>Foo</code> object can be modified or not?</p>\n<p>Edit 2: perhaps an even simpler example:</p>\n<pre><code>class X {\n    X* nonconst_this;   // Only turns in to X* const in a const method!\n    int data;\n\npublic:\n    X()\n        : nonconst_this(this),\n          data(0)\n    {\n    }\n\n    int GetData() const\n    {\n        nonconst_this-&gt;data = 5;    // legal??\n        return data;\n    }\n};\n</code></pre>\n", "AcceptedAnswerId": "3485333", "Title": "Const method that modifies *this without const_cast", "CreationDate": "2010-08-14T16:47:48.550", "Id": "3484233", "CommentCount": "3", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2010-08-14T20:57:23.843", "LastEditorUserId": "177222", "LastActivityDate": "2011-11-23T17:15:39.693", "Score": "8", "OwnerUserId": "177222", "Tags": "<c++><const><mutable><const-correctness>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_3484233_3484265_5": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}, "so_3484233_3485333_0": {"length": 38, "quality": 0.926829268292683, "section_id": 5432}, "so_3484233_3484265_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 5895}, "so_3484233_3484265_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 5895}, "so_3484233_3485333_1": {"length": 17, "quality": 0.85, "section_id": 5433}, "so_3484233_3484265_4": {"length": 38, "quality": 0.8837209302325582, "section_id": 5432}}, "n3337": {"so_3484233_3484265_5": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}, "so_3484233_3485333_0": {"length": 38, "quality": 0.926829268292683, "section_id": 5227}, "so_3484233_3484265_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 5666}, "so_3484233_3484265_2": {"length": 21, "quality": 1.0, "section_id": 5667}, "so_3484233_3484265_4": {"length": 38, "quality": 0.8837209302325582, "section_id": 5227}, "so_3484233_3485333_1": {"length": 17, "quality": 0.85, "section_id": 5228}}, "n4659": {"so_3484233_3484265_5": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}, "so_3484233_3485333_0": {"length": 38, "quality": 0.926829268292683, "section_id": 6860}, "so_3484233_3484265_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 7378}, "so_3484233_3484265_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 7378}, "so_3484233_3484265_4": {"length": 38, "quality": 0.8837209302325582, "section_id": 6860}, "so_3484233_3485333_1": {"length": 17, "quality": 0.85, "section_id": 6861}}}, "3484271": {"Id": "3484271", "PostTypeId": "2", "Body": "<p>The <code>const</code> keyword is only considered during compile time checks. C++ provides no facilities to protect your class against any memory access, which is what you are doing with your pointer/reference. Neither the compiler nor the runtime can know if your pointer points to an instance that you declared const somewhere.</p>\n<p>EDIT:</p>\n<p>Short example (might not compile):</p>\n<pre><code>// lets say foo has a member const int Foo::datalength() const {...}\n// and a read only acces method const char data(int idx) const {...}\n\nfor (int i; i &lt; foo.datalength(); ++i)\n{\n     foo.questionable();  // this will most likely mess up foo.datalength !!\n     std::cout &lt;&lt; foo.data(i); // HERE BE DRAGONS\n}\n</code></pre>\n<p>In this case, the compiler might decide, ey, foo.datalength is const, \nand the code inside the loop promised not to change foo, so I have to evaluate\ndatalength only once when I enter the loop. Yippie! \nAnd if you try to debug this error, which will most likely only turn up if you compile with optimizations (not in the debug builds) you will drive yourself crazy.</p>\n<p>Keep the promises! Or use mutable with your braincells on high alert!</p>\n", "LastEditorUserId": "82673", "LastActivityDate": "2010-08-14T17:26:59.757", "Score": "0", "CreationDate": "2010-08-14T16:58:16.317", "ParentId": "3484233", "CommentCount": "2", "OwnerUserId": "82673", "LastEditDate": "2010-08-14T17:26:59.757"}, "3484879": {"Id": "3484879", "PostTypeId": "2", "Body": "<p>IMO, you are not doing anything technically wrong. May-be it would be simpler to understand if the member was a pointer.</p>\n<pre><code>class X\n{\n    Y* m_ptr;\n    void foo() const {\n        m_ptr = NULL; //illegal\n        *m_ptr = 42; //legal\n    }\n};\n</code></pre>\n<p><code>const</code> makes the <em>pointer</em> const, not the <em>pointee</em>.</p>\n<p>Consider the difference between:</p>\n<pre><code>const X* ptr;\nX* const ptr;  //this is what happens in const member functions\n</code></pre>\n<p>As to references, since they can't be reseated anyway, the <code>const</code> keyword on the method has no effect whatsoever on reference members.</p>\n<p>In your example, I don't see any const objects, so you are not doing anything bad, just exploiting a strange loophole in the way const correctness works in C++.</p>\n", "LastActivityDate": "2010-08-14T19:55:29.777", "CommentCount": "14", "CreationDate": "2010-08-14T19:55:29.777", "ParentId": "3484233", "Score": "5", "OwnerUserId": "155693"}, "3485333": {"Id": "3485333", "PostTypeId": "2", "Body": "<p>Consider the following:</p>\n<pre><code>int i = 3;\n</code></pre>\n<p><code>i</code> is an object, and it has the type <code>int</code>. It is not cv-qualified (is not <code>const</code> or <code>volatile</code>, or both.)</p>\n<p>Now we add:</p>\n<pre><code>const int&amp; j = i;\nconst int* k = &amp;i;\n</code></pre>\n<p><code>j</code> is a reference which refers to <code>i</code>, and <code>k</code> is a pointer which points to <code>i</code>. (From now on, we simply combine \"refer to\" and \"points to\" to just \"points to\".)</p>\n<p>At this point, we have two cv-qualified variables, <code>j</code> and <code>k</code>, that point to a non-cv-qualified object. This is mentioned in \u00a77.1.\u200b5.1/3:</p>\n<blockquote>\n<p id=\"so_3484233_3485333_0\">A pointer or reference to a cv-qualified type need not actually point or refer to a cv-qualified object, but it is treated as if it does; a const-qualified access path cannot be used to modify an object even if the object referenced is a non-const object and can be modified through some other access path. [Note: cv-qualifiers are supported by the type system so that they cannot be subverted without casting (5.2.11). ]</p>\n</blockquote>\n<p>What this means is that a compiler must respect that <code>j</code> and <code>k</code> are cv-qualified, even though they point to a non-cv-qualified object. (So <code>j = 5</code> and <code>*k = 5</code> are illegal, even though <code>i = 5</code> is legal.)</p>\n<p>We now consider removing the <code>const</code> from those:</p>\n<pre><code>const_cast&lt;int&amp;&gt;(j) = 5;\n*const_cast&lt;int*&gt;(k) = 5;\n</code></pre>\n<p>This is legal (\u00a7refer to 5.2.11), but is it undefined behavior? <strong>No.</strong> See \u00a77.1.\u200b5.1/4:</p>\n<blockquote>\n<p id=\"so_3484233_3485333_1\">Except that any class member declared mutable (7.1.1) can be modified, <strong>any attempt to modify a const object during its lifetime (3.8) results in undefined behavior</strong>.\n  <sup>Emphasis mine.</sup></p>\n</blockquote>\n<p>Remember that <code>i</code> is <em>not</em> <code>const</code> and that <code>j</code> and <code>k</code> both point to <code>i</code>. All we've done is tell the type system to remove the const-qualifier from the type so we can modify the pointed to object, and then modified <code>i</code> through those variables.</p>\n<p>This is exactly the same as doing:</p>\n<pre><code>int&amp; j = i; // removed const with const_cast...\nint* k = &amp;i; // ..trivially legal code\n\nj = 5;\n*k = 5;\n</code></pre>\n<p>And this is trivially legal. We now consider that <code>i</code> was this instead:</p>\n<pre><code>const int i = 3;\n</code></pre>\n<p>What of our code now?</p>\n<pre><code>const_cast&lt;int&amp;&gt;(j) = 5;\n*const_cast&lt;int*&gt;(k) = 5;\n</code></pre>\n<p>It now leads to <em>undefined behavior</em>, because <code>i</code> is a const-qualified object. We told the type system to remove <code>const</code> so we can modify the pointed to object, <em>and then modified a const-qualified object</em>. This is undefined, as quoted above.</p>\n<p>Again, more apparent as:</p>\n<pre><code>int&amp; j = i; // removed const with const_cast...\nint* k = &amp;i; // ...but this is not legal!\n\nj = 5;\n*k = 5;\n</code></pre>\n<p>Note that simply doing this:</p>\n<pre><code>const_cast&lt;int&amp;&gt;(j);\n*const_cast&lt;int*&gt;(k);\n</code></pre>\n<p>Is perfectly legal and defined, as no const-qualified objects are being modified; we're just messing with the type-system.</p>\n<hr>\n<p>Now consider:</p>\n<pre><code>struct foo\n{\n    foo() :\n    me(this), self(*this), i(3)\n    {}\n\n    void bar() const\n    {\n        me-&gt;i = 5;\n        self.i = 5;\n    }\n\n    foo* me;\n    foo&amp; self;\n    int i;\n};\n</code></pre>\n<p>What does <code>const</code> on <code>bar</code> do to the members? It makes access to them go through something called a <em>cv-qualified access path</em>. (It does this by changing the type of <code>this</code> from <code>T* const</code> to <code>cv T const*</code>, where <code>cv</code> is the cv-qualifiers on the function.)</p>\n<p>So what are the members types during the execution of <code>bar</code>? They are:</p>\n<pre><code>// const-pointer-to-non-const, where the pointer points cannot be changed\nfoo* const me;\n\n// foo&amp; const is ill-formed, cv-qualifiers do nothing to reference types\nfoo&amp; self; \n\n// same as const int\nint const i; \n</code></pre>\n<p>Of course, the types are irrelevant, as the important thing is the const-qualification of the <em>pointed to</em> objects, not the pointers. (Had <code>k</code> above been <code>const int* const</code>, the latter <code>const</code> is irrelevant.) We now consider:</p>\n<pre><code>int main()\n{\n    foo f;\n    f.bar(); // UB?\n}\n</code></pre>\n<p>Within <code>bar</code>, both <code>me</code> and <code>self</code> point to a non-const <code>foo</code>, so just like with <code>int i</code> above we have well-defined behavior. Had we had:</p>\n<pre><code>const foo f;\nf.bar(); // UB!\n</code></pre>\n<p>We would have had UB, just like with <code>const int</code>, because we would be modifying a const-qualified object.</p>\n<p>In your question, you have no const-qualified objects, so you have no undefined behavior.</p>\n<hr>\n<p>And just to add an appeal to authority, consider the <code>const_cast</code> trick by Scott Meyers, used to recycle a const-qualified function in a non-const function:</p>\n<pre><code>struct foo\n{\n    const int&amp; bar() const\n    {\n        int* result = /* complicated process to get the resulting int */\n        return *result; \n    }\n\n    int&amp; bar()\n    {\n        // we wouldn't like to copy-paste a complicated process, what can we do?\n    }\n\n};\n</code></pre>\n<p>He suggests:</p>\n<pre><code>int&amp; bar(void)\n{\n    const foo&amp; self = *this; // add const\n    const int&amp; result = self.bar(); // call const version\n    return const_cast&lt;int&amp;&gt;(result); // take off const\n}\n</code></pre>\n<p>Or how it's usually written:</p>\n<pre><code>int&amp; bar(void)\n{\n    return const_cast&lt;int&amp;&gt;( // (3) remove const from result\n            static_cast&lt;const foo&amp;&gt;(*this) // (1) add const to this\n            .bar() // (2) call const version\n            ); \n}\n</code></pre>\n<p>Note this is, again, perfectly legal and well-defined. Specifically, because this function must be called on a non-const-qualified <code>foo</code>, we are perfectly safe in stripping the const-qualification from the return type of <code>int&amp; boo() const</code>.</p>\n<p>(Unless someone shoots themselves with a <code>const_cast</code> + call in the first place.)</p>\n<hr>\n<p>To summarize:</p>\n<pre><code>struct foo\n{\n    foo(void) :\n    i(),\n    self(*this), me(this),\n    self_2(*this), me_2(this)\n    {}\n\n    const int&amp; bar() const\n    {\n        return i; // always well-formed, always defined\n    }\n\n    int&amp; bar() const\n    {\n        // always well-formed, always well-defined\n        return const_cast&lt;int&amp;&gt;(\n                static_cast&lt;const foo&amp;&gt;(*this).\n                bar()\n                );\n    }\n\n    void baz() const\n    {\n        // always ill-formed, i is a const int in baz\n        i = 5; \n\n        // always ill-formed, me is a foo* const in baz\n        me = 0;\n\n        // always ill-formed, me_2 is a const foo* const in baz\n        me_2 = 0; \n\n        // always well-formed, defined if the foo pointed to is non-const\n        self.i = 5;\n        me-&gt;i = 5; \n\n        // always ill-formed, type points to a const (though the object it \n        // points to may or may not necessarily be const-qualified)\n        self_2.i = 5; \n        me_2-&gt;i = 5; \n\n        // always well-formed, always defined, nothing being modified\n        // (note: if the result/member was not an int and was a user-defined \n        // type, if it had its copy-constructor and/or operator= parameter \n        // as T&amp; instead of const T&amp;, like auto_ptr for example, this would \n        // be defined if the foo self_2/me_2 points to was non-const\n        int r = const_cast&lt;foo&amp;&gt;(self_2).i;\n        r = const_cast&lt;foo* const&gt;(me_2)-&gt;i;\n\n        // always well-formed, always defined, nothing being modified.\n        // (same idea behind the non-const bar, only const qualifications\n        // are being changed, not any objects.)\n        const_cast&lt;foo&amp;&gt;(self_2);\n        const_cast&lt;foo* const&gt;(me_2);\n\n        // always well-formed, defined if the foo pointed to is non-const\n        // (note, equivalent to using self and me)\n        const_cast&lt;foo&amp;&gt;(self_2).i = 5;\n        const_cast&lt;foo* const&gt;(me_2)-&gt;i = 5;\n\n        // always well-formed, defined if the foo pointed to is non-const\n        const_cast&lt;foo&amp;&gt;(*this).i = 5;\n        const_cast&lt;foo* const&gt;(this)-&gt;i = 5;\n    }\n\n    int i;\n\n    foo&amp; self;\n    foo* me;\n    const foo&amp; self_2;\n    const foo* me_2;\n};\n\nint main()\n{\n    int i = 0;\n    {\n        // always well-formed, always defined\n        int&amp; x = i;\n        int* y = &amp;i;\n        const int&amp; z = i;\n        const int* w = &amp;i;\n\n        // always well-formed, always defined\n        // (note, same as using x and y)\n        const_cast&lt;int&amp;&gt;(z) = 5;\n        const_cast&lt;int*&gt;(w) = 5;\n    }\n\n    const int j = 0;\n    {\n        // never well-formed, strips cv-qualifications without a cast\n        int&amp; x = j;\n        int* y = &amp;j;\n\n        // always well-formed, always defined\n        const int&amp; z = i;\n        const int* w = &amp;i;\n\n        // always well-formed, never defined\n        // (note, same as using x and y, but those were ill-formed)\n        const_cast&lt;int&amp;&gt;(z) = 5;\n        const_cast&lt;int*&gt;(w) = 5;\n    }\n\n    foo x;\n    x.bar(); // calls non-const, well-formed, always defined\n    x.bar() = 5; // calls non-const, which calls const, removes const from\n                 // result, and modifies which is defined because the object\n                 // pointed to by the returned reference is non-const,\n                 // because x is non-const.\n\n    x.baz(); // well-formed, always defined\n\n    const foo y;\n    y.bar(); // calls const, well-formed, always defined\n    const_cast&lt;foo&amp;&gt;(y).bar(); // calls non-const, well-formed, \n                               // always defined (nothing being modified)\n    const_cast&lt;foo&amp;&gt;(y).bar() = 5; // calls non-const, which calls const,\n                                   // removes const from result, and\n                                   // modifies which is undefined because \n                                   // the object pointed to by the returned\n                                   // reference is const, because y is const.\n\n    y.baz(); // well-formed, always undefined\n}\n</code></pre>\n<p><sub>I refer to the ISO C++03 standard.</sub></p>\n</hr></hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-11-23T17:15:39.693", "Score": "25", "CreationDate": "2010-08-14T22:16:31.760", "ParentId": "3484233", "CommentCount": "1", "OwnerUserId": "87234", "LastEditDate": "2011-11-23T17:15:39.693"}});