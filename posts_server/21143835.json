post_cb({"21143997": {"Id": "21143997", "PostTypeId": "2", "Body": "<p>You can use a macro instead of a regular class declaration, that will do that for you.</p>\n<pre><code>#define CLASS_WITH_SELF(X) class X { typedef X self;\n</code></pre>\n<p>And then use like </p>\n<pre><code>CLASS_WITH_SELF(Foo) \n};\n</code></pre>\n<p><code>#define END_CLASS };</code> would probably help readability.</p>\n<hr>\n<p>You could also take @Paranaix's <code>Self</code> and use it (it starts to get really hackish)</p>\n<pre><code>#define WITH_SELF(X) X : public Self&lt;X&gt;\n\nclass WITH_SELF(Foo) {\n};\n</code></pre>\n</hr>", "LastEditorUserId": "752976", "LastActivityDate": "2014-01-15T17:23:31.297", "Score": "35", "CreationDate": "2014-01-15T17:16:45.197", "ParentId": "21143835", "CommentCount": "9", "OwnerUserId": "752976", "LastEditDate": "2014-01-15T17:23:31.297"}, "21143918": {"Id": "21143918", "PostTypeId": "2", "Body": "<p>I have no positive evidence but I <em>think</em> it\u2019s impossible. The following fails \u2013 for the same reason as your attempt \u2013 and I think that\u2019s the furthest we can get:</p>\n<pre><code>struct Foo {\n    auto self_() -&gt; decltype(*this) { return *this; }\n\n    using self = decltype(self_());\n};\n</code></pre>\n<p>Essentially, what this demonstrates is that the scope at which we want to declare our typedef simply has <em>no</em> access (be it direct or indirect) to <code>this</code>, and there\u2019s no other (compiler independent) way of getting to the class\u2019 type or name.</p>\n", "LastActivityDate": "2014-01-15T17:12:49.340", "CommentCount": "17", "CreationDate": "2014-01-15T17:12:49.340", "ParentId": "21143835", "Score": "31", "OwnerUserId": "1968"}, "bq_ids": {"n4140": {"so_21143835_26696662_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5949}, "so_21143835_26696662_1": {"length": 17, "quality": 1.0, "section_id": 5950}, "so_21143835_26696662_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 5951}, "so_21143835_21148117_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 577}, "so_21143835_21148117_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 5988}}, "n3337": {"so_21143835_26696662_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5719}, "so_21143835_26696662_1": {"length": 17, "quality": 1.0, "section_id": 5720}, "so_21143835_26696662_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 5721}, "so_21143835_21148117_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 567}, "so_21143835_21148117_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 5756}}, "n4659": {"so_21143835_26696662_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7435}, "so_21143835_26696662_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 7436}, "so_21143835_26696662_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 7437}, "so_21143835_21148117_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 600}, "so_21143835_21148117_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7488}}}, "21144097": {"Id": "21144097", "PostTypeId": "2", "Body": "<p>Unless the type needs to be member type of the enclosing class you could replace the use of <code>self</code> with <code>decltype(*this)</code>. If you use it in many places in your code you can define a macro <code>SELF</code> as follows:</p>\n<pre><code>#define SELF decltype(*this)\n</code></pre>\n", "LastActivityDate": "2014-01-15T17:21:25.033", "CommentCount": "9", "CreationDate": "2014-01-15T17:21:25.033", "ParentId": "21143835", "Score": "4", "OwnerUserId": "581903"}, "21148117": {"Id": "21148117", "PostTypeId": "2", "Body": "<p>What works in both GCC and clang is to create a typedef that refers to <code>this</code> by using <code>this</code> in the trailing-return-type of a function typedef. Since this is not the declaration of a static member function, the use of <code>this</code> is tolerated. You can then use that typedef to define <code>self</code>.</p>\n<pre><code>#define DEFINE_SELF() \\\n    typedef auto _self_fn() -&gt; decltype(*this); \\\n    using self = decltype(((_self_fn*)0)())\n\nstruct Foo {\n    DEFINE_SELF();\n};\n\nstruct Bar {\n    DEFINE_SELF();\n};\n</code></pre>\n<p>Unfortunately, a strict reading of the standard says that even this is not valid. What clang does is check that <code>this</code> is not used in the definition of a static member function. And here, it indeed isn't. GCC doesn't mind if <code>this</code> is used in a trailing-return-type regardless of the sort of function, it allows it even for <code>static</code> member functions. However, what the standard actually requires is that <code>this</code> is not used outside of the definition of a non-static member function (or non-static data member initialiser). Intel gets it right and rejects this.</p>\n<p>Given that:</p>\n<ul>\n<li><code>this</code> is only allowed in non-static data member initialisers and non-static member functions ([expr.prim.general]p5),</li>\n<li>non-static data members cannot have their type deduced from the initialiser ([dcl.spec.auto]p5),</li>\n<li>non-static member functions can only be referred to by an unqualified name in the context of a function call ([expr.ref]p4)</li>\n<li>non-static member functions can only be called by unqualified name, even in unevaluated contexts, when <code>this</code> can be used ([over.call.func]p3),</li>\n<li>a reference to a non-static member function by qualified name or member access requires a reference to the type being defined</li>\n</ul>\n<p>I think I can conclusively say that there is no way at all to implement <code>self</code> without including in some way, somewhere, the type name.</p>\n<p><strong>Edit</strong>: There is a flaw in my earlier reasoning. \"non-static member functions can only be called by unqualified name, even in unevaluated contexts, when this can be used ([over.call.func]p3),\" is incorrect. What it <em>actually</em> says is</p>\n<blockquote>\n<p id=\"so_21143835_21148117_0\">If the keyword <code>this</code> (9.3.2) is in scope and refers to class <code>T</code>, or a derived class of <code>T</code>, then the implied object argument is <code>(*this)</code>. If the keyword <code>this</code> is not in scope or refers to another class, then a contrived object of type <code>T</code> becomes the implied object argument. If the argument list is augmented by a contrived object and overload resolution selects one of the non-static member functions of <code>T</code>, the call is ill-formed.</p>\n</blockquote>\n<p>Inside a static member function, <code>this</code> may not appear, but it still exists.</p>\n<p>However, per the comments, inside a static member function, the transformation of <code>f()</code> to <code>(*this).f()</code> would not be performed, and it that isn't performed, then [expr.call]p1 is violated:</p>\n<blockquote>\n<p id=\"so_21143835_21148117_1\">[...] For a member function call, the postfix expression shall be an implicit (9.3.1, 9.4) or explicit class member access (5.2.5) whose [...]</p>\n</blockquote>\n<p>as there would be no member access. So even that wouldn't work.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2014-01-18T13:58:48.647", "Score": "19", "CreationDate": "2014-01-15T21:02:31.910", "ParentId": "21143835", "CommentCount": "6", "OwnerUserId": "743382", "LastEditDate": "2014-01-18T13:58:48.647"}, "24342374": {"Id": "24342374", "PostTypeId": "2", "Body": "<p>Provide my version. The best thing is that its use is the same as the native class. However, it doesn't work for template classes.</p>\n<pre><code>template&lt;class T&gt; class Self;\n\n#define CLASS(Name) \\\nclass Name##_; \\\ntypedef Self&lt;Name##_&gt; Name; \\\ntemplate&lt;&gt; class Self&lt;Name##_&gt;\n\nCLASS(A)\n{\n    int i;\n    Self* clone() const { return new Self(*this); }\n};\n\nCLASS(B) : public A\n{\n    float f;\n    Self* clone() const { return new Self(*this); }\n};\n</code></pre>\n", "LastEditorUserId": "1899020", "LastActivityDate": "2014-06-30T02:34:06.060", "Score": "1", "CreationDate": "2014-06-21T14:07:10.913", "ParentId": "21143835", "CommentCount": "0", "OwnerUserId": "1899020", "LastEditDate": "2014-06-30T02:34:06.060"}, "21145724": {"Id": "21145724", "PostTypeId": "2", "Body": "<pre><code>#define SELF_CHECK( SELF ) void self_check() { static_assert( std::is_same&lt; typename std::decay&lt;decltype(*this)&gt;::type, SELF &gt;::value, \"self wrong type\" ); }\n#define SELF(T) typedef T self; SELF_CHECK(T)\n\nstruct Foo {\n  SELF(Foo); // works, self is defined as `Foo`\n};\nstruct Bar {\n  SELF(Foo); // fails\n};\n</code></pre>\n<p>this does not work on template types, as <code>self_check</code> is not called, so the <code>static_assert</code> is not evaluated.</p>\n<p>We can do some hacks to make it work for <code>template</code>s as well, but it has a minor run time cost.</p>\n<pre><code>#define TESTER_HELPER_TYPE \\\ntemplate&lt;typename T, std::size_t line&gt; \\\nstruct line_tester_t { \\\n  line_tester_t() { \\\n    static_assert( std::is_same&lt; decltype(T::line_tester), line_tester_t&lt;T,line&gt; &gt;::value, \"test failed\" ); \\\n    static_assert( std::is_same&lt; decltype(&amp;T::static_test_zzz), T*(*)() &gt;::value, \"test 2 failed\" ); \\\n  } \\\n}\n\n#define SELF_CHECK( SELF ) void self_check() { static_assert( std::is_same&lt; typename std::decay&lt;decltype(*this)&gt;::type, SELF &gt;::value, \"self wrong type\" ); }\n\n#define SELF(T) typedef T self; SELF_CHECK(T); static T* static_test_zzz() { return nullptr; }; TESTER_HELPER_TYPE; line_tester_t&lt;T,__LINE__&gt; line_tester\n</code></pre>\n<p>an empty <code>struct</code> of size 1 byte is created in your class.  If your type is instantiated, <code>self</code> is tested against.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2014-01-16T03:48:55.187", "Score": "17", "CreationDate": "2014-01-15T18:45:20.653", "ParentId": "21143835", "CommentCount": "10", "OwnerUserId": "1774667", "LastEditDate": "2014-01-16T03:48:55.187"}, "21149648": {"Id": "21149648", "PostTypeId": "2", "Body": "<p>Here's how you can do it without repeating the type of Foo:</p>\n<pre><code>template &lt;typename...Ts&gt;\nclass Self;\n\ntemplate &lt;typename X, typename...Ts&gt;\nclass Self&lt;X,Ts...&gt; : public Ts...\n{\nprotected:\n    typedef X self;\n};\n\n#define WITH_SELF(X) X : public Self&lt;X&gt;\n#define WITH_SELF_DERIVED(X,...) X : public Self&lt;X,__VA_ARGS__&gt;\n\nclass WITH_SELF(Foo)\n{\n    void test()\n    {\n        self foo;\n    }\n};\n</code></pre>\n<p>If you want to derive from <code>Foo</code> then you should use the macro <code>WITH_SELF_DERIVED</code> in the following way:</p>\n<pre><code>class WITH_SELF_DERIVED(Bar,Foo)\n{\n    /* ... */\n};\n</code></pre>\n<p>You can even do multiple inheritance with as many base classes as you want (thanks to variadic templates and variadic macros):</p>\n<pre><code>class WITH_SELF(Foo2)\n{\n    /* ... */\n};\n\nclass WITH_SELF_DERIVED(Bar2,Foo,Foo2)\n{\n    /* ... */\n};\n</code></pre>\n<p>I have verified this to work on gcc 4.8 and clang 3.4. </p>\n", "LastActivityDate": "2014-01-15T22:30:17.687", "CommentCount": "5", "CreationDate": "2014-01-15T22:30:17.687", "ParentId": "21143835", "Score": "31", "OwnerUserId": "1335865"}, "26696662": {"Id": "26696662", "PostTypeId": "2", "Body": "<p>I recently discovered that <code>*this</code> is allowed in a <em>brace-or-equal-initializer</em>. Described in \u00a7 5.1.1 (<em>from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">n3337 working draft</a></em>):</p>\n<blockquote>\n<p id=\"so_21143835_26696662_0\">3 <em>[..]</em> Unlike the object expression in other contexts, <code>*this</code> is\n  not required to be of complete type for purposes of class member\n  access (5.2.5) outside the member function body. <em>[..]</em></p>\n<p id=\"so_21143835_26696662_1\">4 Otherwise, if a <em>member-declarator</em> declares a non-static data\n  member (9.2) of a class X, the expression <code>this</code> is a prvalue of type\n  \u201cpointer to X\u201d within the optional <em>brace-or-equal-initializer</em>. It\n  shall not appear elsewhere in the <em>member-declarator</em>.</p>\n<p id=\"so_21143835_26696662_2\">5 The expression <code>this</code> shall not appear in any other context. [\n  <em>Example:</em></p>\n<pre><code>class Outer {\n    int a[sizeof(*this)];               // error: not inside a member function\n    unsigned int sz = sizeof(*this);    // OK: in brace-or-equal-initializer\n\n    void f() {\n        int b[sizeof(*this)];           // OK\n        struct Inner {\n            int c[sizeof(*this)];       // error: not inside a member function of Inner\n        };\n    }\n};\n</code></pre>\n<p id=\"so_21143835_26696662_3\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>With that in mind, the following code:</p>\n<pre><code>struct Foo\n{\n    Foo* test = this;\n    using self = decltype(test);\n\n    static void smf()\n    {\n        self foo;\n    }\n};\n\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nint main()\n{\n    static_assert( std::is_same&lt; Foo::self, Foo* &gt;::value, \"\" );\n}\n</code></pre>\n<p>passes <a href=\"https://stackoverflow.com/a/21144038/3920237\">Daniel Frey's</a> <code>static_assert</code>.</p>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/18c96742b4cdf39c\" rel=\"nofollow noreferrer\">Live example</a></kbd></p>\n", "OwnerDisplayName": "user3920237", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-02T06:28:25.167", "Score": "6", "CreationDate": "2014-11-02T06:28:25.167", "ParentId": "21143835", "CommentCount": "3", "LastEditDate": "2017-05-23T10:31:25.977"}, "21143835": {"ViewCount": "8563", "Body": "<p>C++ <a href=\"https://stackoverflow.com/a/21143699/560648\">lacks</a> the equivalent of <a href=\"http://www.php.net/manual/en/language.oop5.properties.php\" rel=\"nofollow noreferrer\">PHP's <code>self</code> keyword</a>, which evaluates to the type of the enclosing class.</p>\n<p>It's easy enough to fake it on a per-class basis:</p>\n<pre><code>struct Foo\n{\n   typedef Foo self;\n};\n</code></pre>\n<p>but I had to write <code>Foo</code> again. Maybe I'll get this wrong one day and cause a silent bug.</p>\n<p>Can I use some combination of <code>decltype</code> and friends to make this work \"autonomously\"? <a href=\"http://coliru.stacked-crooked.com/a/583a8651b5f8a46c\" rel=\"nofollow noreferrer\">I tried the following already</a> but <code>this</code> is not valid in that place:</p>\n<pre><code>struct Foo\n{\n   typedef decltype(*this) self;\n};\n\n// main.cpp:3:22: error: invalid use of 'this' at top level\n//     typedef decltype(*this) self;\n</code></pre>\n<p><sup>(I'm not going to worry about the equivalent of <code>static</code>, which does the same but with late binding.)</sup></p>\n", "AcceptedAnswerId": "21149648", "Title": "Can I implement an autonomous `self` member type in C++?", "CreationDate": "2014-01-15T17:09:26.133", "Id": "21143835", "CommentCount": "18", "FavoriteCount": "24", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:31:25.210", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-17T12:28:27.673", "Score": "89", "OwnerUserId": "560648", "Tags": "<c++><c++11>", "AnswerCount": "11"}, "21162200": {"Id": "21162200", "PostTypeId": "2", "Body": "<p>I will repeat the obvious solution of \"having to do it yourself\". This is the succinct C++11 version of the code, which works with both simple classes and class templates:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#define DECLARE_SELF(Type) \\\n    typedef Type TySelf; /**&lt; @brief type of this class */ \\\n    /** checks the consistency of TySelf type (calling it has no effect) */ \\\n    void self_check() \\\n    { \\\n        static_assert(std::is_same&lt;decltype(*((TySelf*)(0))), \\\n            decltype(*this)&gt;::value, \"TySelf is not what it should be\"); \\\n    } \\\n    enum { static_self_check_token = __LINE__ }; \\\n    static_assert(int(static_self_check_token) == \\\n        int(TySelf::static_self_check_token), \\\n        \"TySelf is not what it should be\")\n</code></pre>\n<p>You can see it in action at <a href=\"http://ideone.com/3N38yJ\" rel=\"nofollow\">ideone</a>. The genesis, leading to this result is below:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#define DECLARE_SELF(Type) typedef Type _TySelf; /**&lt; @brief type of this class */\n\nstruct XYZ {\n    DECLARE_SELF(XYZ)\n};\n</code></pre>\n<p>This has the obvious problem with copy-pasting the code to a different class and forgetting to change XYZ, like here:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct ABC {\n    DECLARE_SELF(XYZ) // !!\n};\n</code></pre>\n<p>My first approach was not very original - making a function, like this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>/**\n *  @brief namespace for checking the _TySelf type consistency\n */\nnamespace __self {\n\n/**\n *  @brief compile-time assertion (_TySelf must be declared the same as the type of class)\n *\n *  @tparam _TySelf is reported self type\n *  @tparam _TyDecltypeThis is type of &lt;tt&gt;*this&lt;/tt&gt;\n */\ntemplate &lt;class _TySelf, class _TyDecltypeThis&gt;\nclass CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE;\n\n/**\n *  @brief compile-time assertion (specialization for assertion passing)\n *  @tparam _TySelf is reported self type (same as type of &lt;tt&gt;*this&lt;/tt&gt;)\n */\ntemplate &lt;class _TySelf&gt;\nclass CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE&lt;_TySelf, _TySelf&gt; {};\n\n/**\n *  @brief static assertion helper type\n *  @tparam n_size is size of object being used as assertion message\n *      (if it's a incomplete type, compiler will display object name in error output)\n */\ntemplate &lt;const size_t n_size&gt;\nclass CStaticAssert {};\n\n/**\n *  @brief helper function for self-check, this is used to derive type of this\n *      in absence of &lt;tt&gt;decltype()&lt;/tt&gt; in older versions of C++\n *\n *  @tparam _TyA is reported self type\n *  @tparam _TyB is type of &lt;tt&gt;*this&lt;/tt&gt;\n */\ntemplate &lt;class _TyA, class _TyB&gt;\ninline void __self_check_helper(_TyB *UNUSED(p_this))\n{\n    typedef CStaticAssert&lt;sizeof(CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE&lt;_TyA, _TyB&gt;)&gt; _TyAssert;\n    // make sure that the type reported as self and type of *this is the same\n}\n\n/**\n *  @def __SELF_CHECK\n *  @brief declares the body of __self_check() function\n */\n#define __SELF_CHECK \\\n    /** checks the consistency of _TySelf type (calling it has no effect) */ \\\n    inline void __self_check() \\\n    { \\\n        __self::__self_check_helper&lt;_TySelf&gt;(this); \\\n    }\n\n/**\n *  @def DECLARE_SELF\n *  @brief declares _TySelf type and adds code to make sure that it is indeed a correct one\n *  @param[in] Type is type of the enclosing class\n */\n#define DECLARE_SELF(Type) \\\n    typedef Type _TySelf; /**&lt; @brief type of this class */ \\\n    __SELF_CHECK\n\n} // ~self\n</code></pre>\n<p>It is kind of lengthy, but please bear with me here. This has the advantage of working in C++03 without <code>decltype</code>, as the <code>__self_check_helper</code> function is employed to deduce type of <code>this</code>. Also, there is no <code>static_assert</code>, but the <code>sizeof()</code> trick is employed instead. You could make it much shorter for C++0x. Now this will not work for templates. Also, there is a minor issue with the macro not expecting semicolon at the end, if compiling with pedantic, it will complain about an extra unnecessary semicolon (or you will be left with an odd looking macro not ending in semicolon in the body of <code>XYZ</code> and <code>ABC</code>).</p>\n<p>Making a check on the <code>Type</code> that is passed to <code>DECLARE_SELF</code> is not an option, as that would only check the <code>XYZ</code> class (which is ok), oblivious to <code>ABC</code> (which has error). And then it hit me. A no-additional storage zero-cost solution that works with templates:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>namespace __self {\n\n/**\n *  @brief compile-time assertion (_TySelf must be declared the same as the type of class)\n *  @tparam b_check is the asserted value\n */\ntemplate &lt;bool b_check&gt;\nclass CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE2;\n\n/**\n *  @brief compile-time assertion (specialization for assertion passing)\n */\ntemplate &lt;&gt;\nclass CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE2&lt;true&gt; {};\n\n/**\n *  @def DECLARE_SELF\n *  @brief declares _TySelf type and adds code to make sure that it is indeed a correct one\n *  @param[in] Type is type of the enclosing class\n */\n#define DECLARE_SELF(Type) \\\n    typedef Type _TySelf; /**&lt; @brief type of this class */ \\\n    __SELF_CHECK \\\n    enum { __static_self_check_token = __LINE__ }; \\\n    typedef __self::CStaticAssert&lt;sizeof(CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE2&lt;int(__static_self_check_token) == int(_TySelf::__static_self_check_token)&gt;)&gt; __static_self_check\n\n} // ~__self \n</code></pre>\n<p>This simply makes static assertion on a unique enum value (or at least unique in case you don't write all of your code on a single line), no type-comparing trickery is employed, and it works as static assert, even in templates. And as a bonus - the final semicolon is now required :).</p>\n<p>I'd like to thank Yakk for giving me a good inspiration. I wouldn't write this without first seeing his answer.</p>\n<p>Tested with VS 2008 and g++ 4.6.3. Indeed, with the <code>XYZ</code> and <code>ABC</code> example, it complains:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>ipolok@ivs:~$ g++ self.cpp -c -o self.o\nself.cpp:91:5: error: invalid application of \u00e2sizeof\u00e2 to incomplete type \u00e2__self::CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE2&lt;false&gt;\u00e2\nself.cpp:91:5: error: template argument 1 is invalid\nself.cpp: In function \u00e2void __self::__self_check_helper(_TyB*) [with _TyA = XYZ, _TyB = ABC]\u00e2:\nself.cpp:91:5:   instantiated from here\nself.cpp:58:87: error: invalid application of \u00e2sizeof\u00e2 to incomplete type \u00e2__self::CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE&lt;XYZ, ABC&gt;\u00e2\n</code></pre>\n<p>Now if we make ABC a template:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template &lt;class X&gt;\nstruct ABC {\n    DECLARE_SELF(XYZ); // line 92\n};\n\nint main(int argc, char **argv)\n{\n    ABC&lt;int&gt; abc;\n    return 0;\n}\n</code></pre>\n<p>We will get:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>ipolok@ivs:~$ g++ self.cpp -c -o self.o\nself.cpp: In instantiation of \u00e2ABC&lt;int&gt;\u00e2:\nself.cpp:97:18:   instantiated from here\nself.cpp:92:9: error: invalid application of \u00e2sizeof\u00e2 to incomplete type \u00e2__self::CSELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE2&lt;false&gt;\u00e2\n</code></pre>\n<p>Only the line-number check triggered, as the function check was not compiled (as expected).</p>\n<p>With C++0x (and without the evil underscores), you would need just:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>namespace self_util {\n\n/**\n *  @brief compile-time assertion (tokens in class and TySelf must match)\n *  @tparam b_check is the asserted value\n */\ntemplate &lt;bool b_check&gt;\nclass SELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE;\n\n/**\n *  @brief compile-time assertion (specialization for assertion passing)\n */\ntemplate &lt;&gt;\nclass SELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE&lt;true&gt; {};\n\n/**\n *  @brief static assertion helper type\n *  @tparam n_size is size of object being used as assertion message\n *      (if it's a incomplete type, compiler will display object name in error output)\n */\ntemplate &lt;const size_t n_size&gt;\nclass CStaticAssert {};\n\n#define SELF_CHECK \\\n    /** checks the consistency of TySelf type (calling it has no effect) */ \\\n    void self_check() \\\n    { \\\n        static_assert(std::is_same&lt;TySelf, decltype(*this)&gt;::value, \"TySelf is not what it should be\"); \\\n    }\n\n#define DECLARE_SELF(Type) \\\n    typedef Type TySelf; /**&lt; @brief type of this class */ \\\n    SELF_CHECK \\\n    enum { static_self_check_token = __LINE__ }; \\\n    typedef self_util::CStaticAssert&lt;sizeof(SELF_TYPE_MUST_BE_THE_SAME_AS_CLASS_TYPE&lt;int(static_self_check_token) == int(TySelf::static_self_check_token)&gt;)&gt; static_self_check\n\n} // ~self_util\n</code></pre>\n<p>I believe that the CStaticAssert bit is regrettably still required as it produces a type, which is typedef-ed in the template body (i suppose the same cannot be done with <code>static_assert</code>). The advantage of this approach is still its zero cost.</p>\n", "LastEditorUserId": "1140976", "LastActivityDate": "2014-12-19T17:23:28.087", "Score": "0", "CreationDate": "2014-01-16T12:46:12.260", "ParentId": "21143835", "CommentCount": "4", "OwnerUserId": "1140976", "LastEditDate": "2014-12-19T17:23:28.087"}, "21143980": {"Id": "21143980", "PostTypeId": "2", "Body": "<p>A possible workaround (as you still have to write the type once):</p>\n<pre><code>template&lt;typename T&gt;\nstruct Self\n{\nprotected:\n    typedef T self;\n};\n\nstruct Foo : public Self&lt;Foo&gt;\n{\n    void test()\n    {\n        self obj;\n    }\n};\n</code></pre>\n<p>For a more safer version we could assure that <code>T</code> actually derives from <code>Self&lt;T&gt;</code>:</p>\n<pre><code>Self()\n{\n    static_assert(std::is_base_of&lt;Self&lt;T&gt;, T&gt;::value, \"Wrong type passed to Self\");\n}\n</code></pre>\n<p>Notice that a <code>static_assert</code> inside a member function is probably the only way to check, as types passed to<code>std::is_base_of</code> have to be complete.</p>\n", "LastEditorUserId": "878307", "LastActivityDate": "2014-01-15T18:54:57.757", "Score": "35", "CreationDate": "2014-01-15T17:15:46.037", "ParentId": "21143835", "CommentCount": "10", "OwnerUserId": "878307", "LastEditDate": "2014-01-15T18:54:57.757"}, "21144038": {"Id": "21144038", "PostTypeId": "2", "Body": "<p>I also think it's impossible, here's another failed but IMHO interesting attempt which avoids the <code>this</code>-access:</p>\n<pre><code>template&lt;typename T&gt;\nstruct class_t;\n\ntemplate&lt;typename T, typename R&gt;\nstruct class_t&lt; R (T::*)() &gt; { using type = T; };\n\nstruct Foo\n{\n   void self_f(); using self = typename class_t&lt;decltype(&amp;self_f)&gt;::type;\n};\n\n#include &lt;type_traits&gt;\n\nint main()\n{\n    static_assert( std::is_same&lt; Foo::self, Foo &gt;::value, \"\" );\n}\n</code></pre>\n<p>which fails because C++ requires you to qualify <code>self_f</code> with the class when you want to take it's address :(</p>\n", "LastActivityDate": "2014-01-15T17:18:51.097", "CommentCount": "1", "CreationDate": "2014-01-15T17:18:51.097", "ParentId": "21143835", "Score": "11", "OwnerUserId": "2073257"}});