post_cb({"12498050": {"ParentId": "12446229", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The relevant clause is the bullet at the end of 14.5.5:8:</p>\n<blockquote>\n<h3>14.5.5 Class template partial specializations [temp.class.spec]</h3>\n<p id=\"so_12446229_12498050_0\">8 - Within the argument list of a class template partial specialization, the following restrictions apply:\n  [...]</p>\n<ul>\n<li>An argument shall not contain an unexpanded parameter pack. If an argument is a pack expansion (14.5.3), it shall be the last argument in the template argument list.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-09-19T15:43:52.067", "Id": "12498050", "Score": "4", "CreationDate": "2012-09-19T15:36:28.693", "LastActivityDate": "2012-09-19T15:43:52.067"}, "12446229": {"CommentCount": "1", "ViewCount": "1579", "PostTypeId": "1", "LastEditorUserId": "1554020", "CreationDate": "2012-09-16T10:35:57.237", "LastActivityDate": "2012-09-19T15:43:52.067", "Title": "Parameter pack argument consumption", "AcceptedAnswerId": "12498050", "LastEditDate": "2012-09-19T15:30:26.007", "Id": "12446229", "Score": "5", "Body": "<p>It is possible to get the <em>first</em> element of the parameter pack like <a href=\"http://liveworkspace.org/code/b4647e5d743523e095a3a86c288d7528\" rel=\"nofollow\">this</a></p>\n<pre><code>template &lt;typename... Elements&gt;\nstruct type_list\n{\n};\n\ntemplate &lt;typename TypeList&gt;\nstruct type_list_first_element\n{\n};\n\ntemplate &lt;typename FirstElement, typename... OtherElements&gt;\nstruct type_list_first_element&lt;type_list&lt;FirstElement, OtherElements...&gt;&gt;\n{\n    typedef FirstElement type;\n};\n\nint main()\n{\n   typedef type_list&lt;int, float, char&gt; list;\n   typedef type_list_first_element&lt;list&gt;::type element;\n   return 0;\n}\n</code></pre>\n<p>but not possible to similary get the <em>last</em> element like <a href=\"http://liveworkspace.org/code/9839be4eb3c2e7d7b12eab8dbd310ab4\" rel=\"nofollow\">this</a></p>\n<pre><code>template &lt;typename... Elements&gt;\nstruct type_list\n{\n};\n\ntemplate &lt;typename TypeList&gt;\nstruct type_list_last_element\n{\n};\n\ntemplate &lt;typename LastElement, typename... OtherElements&gt;\nstruct type_list_last_element&lt;type_list&lt;OtherElements..., LastElement&gt;&gt;\n{\n    typedef LastElement type;\n};\n\nint main()\n{\n   typedef type_list&lt;int, float, char&gt; list;\n   typedef type_list_last_element&lt;list&gt;::type element;\n   return 0;\n}\n</code></pre>\n<p>with gcc 4.7.1 complaining:</p>\n<blockquote>\n<p id=\"so_12446229_12446229_0\">error: 'type' in 'struct type_list_last_element&lt;type_list&lt;int, float, char&gt;&gt;' does not name a type</p>\n</blockquote>\n<p>What paragraps from the standard describe this behaviour?</p>\n<p>It seems to me that template parameter packs are <em>greedy</em> in a sense that they consume all matching arguments, which in this case means that <code>OtherElements</code> consumes  all three arguments (<code>int</code>, <code>float</code> and <code>char</code>) and then there is nothing left for <code>LastElement</code> so the compilation fails. Am i correct in the assumption? </p>\n<p><strong>EDIT:</strong></p>\n<p>To clarify: I am not asking how to extract the last element from the parameter pack, i know how to do that. What i actually want is to pick the pack apart from the back as opposed to the front, and as such recursing all the way to the back for each element would be ineffective. Apparentely reversing the sequence beforehand is the most sensible choice.</p>\n", "Tags": "<c++><variadic-templates>", "OwnerUserId": "1554020", "AnswerCount": "2"}, "12483842": {"ParentId": "12446229", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Observation:</p>\n<ol>\n<li>Last element of <code>&lt;first,...&gt;</code> is the same as last element of <code>&lt;...&gt;</code>\nif only <code>...</code> is not empty. </li>\n<li>Last element of one element list <code>&lt;elem&gt;</code> is <code>elem</code></li>\n</ol>\n<p>So you have to do it recursively, with tail template:</p>\n<p>Recursion:</p>\n<pre><code>template &lt;typename TypeList&gt;\nstruct type_list_last_element;\n\ntemplate &lt;typename FirstElement, typename... OtherElements&gt;\nstruct type_list_last_element&lt;type_list&lt;FirstElement, OtherElements...&gt;&gt;\n{\n    typedef typename type_list_last_element&lt;type_list&lt;OtherElements...&gt;&gt;::type type;\n};\n</code></pre>\n<p>Tail:</p>\n<pre><code>template &lt;typename LastElement&gt;\nstruct type_list_last_element&lt;type_list&lt;LastElement&gt;&gt;\n{\n    typedef LastElement type;\n};\n</code></pre>\n<p><strong>[UPDATE]</strong> And usage:</p>\n<pre><code>int main()\n{\n   typedef type_list&lt;int, float, char&gt; list;\n   typedef type_list_last_element&lt;list&gt;::type last;\n   return 0;\n}\n</code></pre>\n<p><strong>[END UPDATE]</strong></p>\n<p>See <a href=\"http://ideone.com/e8R82\" rel=\"nofollow\">ideone</a></p>\n", "OwnerUserId": "1463922", "LastEditorUserId": "1463922", "LastEditDate": "2012-09-19T15:42:30.720", "Id": "12483842", "Score": "1", "CreationDate": "2012-09-18T19:38:43.677", "LastActivityDate": "2012-09-19T15:42:30.720"}, "bq_ids": {"n4140": {"so_12446229_12498050_0": {"section_id": 142, "quality": 1.0, "length": 10}}, "n3337": {"so_12446229_12498050_0": {"section_id": 136, "quality": 1.0, "length": 10}}, "n4659": {"so_12446229_12498050_0": {"section_id": 146, "quality": 1.0, "length": 10}, "so_12446229_12446229_0": {"section_id": 180, "quality": 0.5555555555555556, "length": 5}}}});