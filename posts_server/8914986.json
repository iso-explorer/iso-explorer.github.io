post_cb({"bq_ids": {"n4140": {"so_8914986_8916460_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 603}, "so_8914986_8917084_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 663}, "so_8914986_8917084_5": {"length": 18, "quality": 0.8571428571428571, "section_id": 603}, "so_8914986_8915746_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 679}, "so_8914986_8917084_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 566}, "so_8914986_8917084_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 567}, "so_8914986_8915746_1": {"length": 117, "quality": 0.9435483870967742, "section_id": 675}, "so_8914986_8917084_6": {"length": 20, "quality": 1.0, "section_id": 604}, "so_8914986_8917084_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 638}}, "n3337": {"so_8914986_8916460_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 593}, "so_8914986_8917084_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 653}, "so_8914986_8917084_5": {"length": 18, "quality": 0.8571428571428571, "section_id": 593}, "so_8914986_8915746_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 669}, "so_8914986_8917084_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 557}, "so_8914986_8917084_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 558}, "so_8914986_8915746_1": {"length": 117, "quality": 0.9435483870967742, "section_id": 665}, "so_8914986_8917084_6": {"length": 20, "quality": 1.0, "section_id": 594}, "so_8914986_8917084_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 628}}, "n4659": {"so_8914986_8916460_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 629}, "so_8914986_8917084_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 691}, "so_8914986_8917084_5": {"length": 18, "quality": 0.8571428571428571, "section_id": 629}, "so_8914986_8915746_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 708}, "so_8914986_8917084_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 589}, "so_8914986_8917084_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 590}, "so_8914986_8915746_1": {"length": 117, "quality": 0.9435483870967742, "section_id": 703}, "so_8914986_8917084_6": {"length": 20, "quality": 1.0, "section_id": 630}, "so_8914986_8917084_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 666}}}, "8914986": {"ViewCount": "1484", "Body": "<p>This example seems to compile with VC10 and gcc (though my version of gcc is very old).</p>\n<p>EDIT: R. Martinho Fernandez tried this on gcc 4.7 and the behaviour is still the same.</p>\n<pre><code>struct Base\n{\n    operator double() const { return 0.0; }\n};\n\nstruct foo\n{\n    foo(const char* c) {}\n};\n\nstruct Something : public Base\n{\n    void operator[](const foo&amp; f) {}\n};\n\nint main()\n{\n    Something d;\n    d[\"32\"];\n\n    return 0;\n}\n</code></pre>\n<p>But clang complains:</p>\n<pre><code>test4.cpp:19:6: error: use of overloaded operator '[]' is ambiguous (with operand types 'Something' and 'const char [3]')\n    d[\"32\"]\n    ~^~~~~\ntest4.cpp:13:10: note: candidate function\n    void operator[](const foo&amp; f) {}\n         ^\ntest4.cpp:19:6: note: built-in candidate operator[](long, const char *)\n    d[\"32\"]\n     ^\ntest4.cpp:19:6: note: built-in candidate operator[](long, const restrict char *)\ntest4.cpp:19:6: note: built-in candidate operator[](long, const volatile char *)\ntest4.cpp:19:6: note: built-in candidate operator[](long, const volatile restrict char *)\n</code></pre>\n<p>The overload resolution is considering two possible functions from looking at this expression:</p>\n<ul>\n<li>calling Something::operator[] (after a user defined conversion)</li>\n<li>calling built in operator for const char* (think \"32\"[d]) (after a user defined conversion and standard conversion double to long).</li>\n</ul>\n<p>If I had written <code>d[\"32\"]</code> as <code>d.operator[](\"32\")</code>, then overload resolution won't even look at option 2, and clang will also compile fine.</p>\n<p>EDIT: (clarification of questions)</p>\n<p>This seems to be a complicated area in overload resolution, and because of that I'd appreciate very much answers that explain in detail the overload resolution in this case, and cite the standard (if there's some obscure/advanced likely to be unknown rule).</p>\n<p>If clang is correct, I'm also interested in knowing why the two are ambiguous / one is not preferred over another. The answer likely would have to explain how overload resolution considers implicit conversions (both user defined and standard conversions) involved on the two candidates and why one is not better than the other.</p>\n<p>Note: if operator double() is changed to operator bool(), all three (clang, vc, gcc) will refuse to compile with similar ambiguous error.</p>\n", "AcceptedAnswerId": "8917084", "Title": "Should this compile? Overload resolution and implicit conversions", "CreationDate": "2012-01-18T17:59:46.127", "Id": "8914986", "CommentCount": "14", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-01-18T19:09:10.860", "LastEditorUserId": "560648", "LastActivityDate": "2012-01-18T22:22:14.077", "Score": "17", "OwnerUserId": "365079", "Tags": "<c++><visual-c++><clang><implicit-conversion><overload-resolution>", "AnswerCount": "3"}, "8916460": {"Id": "8916460", "PostTypeId": "2", "Body": "<p>It seems there is no question that both <code>Something::operator[](const foo&amp; f)</code> and the built-in <code>operator[](long, const char *)</code> are viable candidate functions (13.3.2) for overload resolution. The types of real arguments are <code>Something</code> and <code>const char*</code>, and implicit conversion sequences (ICFs) I think are:</p>\n<ul>\n<li>for <code>Something::operator[](const foo&amp; f)</code>: (1-1) identity conversion, and (1-2) <code>foo(\"32\")</code> through <code>foo::foo(const char*)</code>;</li>\n<li>for <code>operator[](long, const char *)</code>: (2-1) <code>long(double(d))</code> through <code>Something::operator double() const</code> (inherited from Base), and (2-2) identity conversion.</li>\n</ul>\n<p>Now if we rank these ICFs according to (13.3.3.2), we can see that (1-1) is a better conversion than (2-1), and (1-2) is a worse conversion than (2-2). According to the definition in (13.3.3), </p>\n<blockquote>\n<p id=\"so_8914986_8916460_0\">a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), ...</p>\n</blockquote>\n<p>Therefore, neither of the considered two candidate functions is better than the other one, and thus the call is ill-formed. I.e. Clang appears to be correct, and the code should not compile.</p>\n", "LastActivityDate": "2012-01-18T19:51:43.157", "CommentCount": "0", "CreationDate": "2012-01-18T19:51:43.157", "ParentId": "8914986", "Score": "4", "OwnerUserId": "654891"}, "8915746": {"Id": "8915746", "PostTypeId": "2", "Body": "<p>It would seem from 13.6 in the C++11 spec that clang is correct here:</p>\n<blockquote>\n<p id=\"so_8914986_8915746_0\"><strong>13.6\n  Built-in operators\n  [over.built]</strong></p>\n<p id=\"so_8914986_8915746_1\">The candidate operator functions that represent the built-in operators defined in Clause 5 are specified in\n       this subclause. These candidate functions participate in the operator overload resolution process as described\n      in 13.3.1.2 and are used for no other purpose. [ Note: Because built-in operators take only operands with\n     non-class type, and operator overload resolution occurs only when an operand expression originally has class\n    or enumeration type, operator overload resolution can resolve to a built-in operator only when an operand\n   has a class type that has a user-defined conversion to a non-class type appropriate for the operator, or when\n    an operand has an enumeration type that can be converted to a type appropriate for the operator. Also note\n   that some of the candidate operator functions given in this subclause are more permissive than the built-in\n  operators themselves. As described in 13.3.1.2, after a built-in operator is selected by overload resolution\n  the expression is subject to the requirements for the built-in operator given in Clause 5, and therefore to\n  any additional semantic constraints given there. If there is a user-written candidate with the same name\n  and parameter types as a built-in candidate operator function, the built-in operator function is hidden and\n  is not included in the set of candidate functions. \u2014 end note ]</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p id=\"so_8914986_8915746_8\">:</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p id=\"so_8914986_8915746_3\">For every cv-qualified or cv-unqualified object type T there exist candidate operator functions of the form</p>\n<blockquote>\n<p id=\"so_8914986_8915746_9\">T&amp; operator[](T *, std::ptrdiff_t);</p>\n<p id=\"so_8914986_8915746_10\">T&amp; operator[](std::ptrdiff_t, T *);</p>\n</blockquote>\n</blockquote>\n<p><strong>edit</strong></p>\n<p>Once you get past which operator functions exist, this just becomes standard overload resolution as described by section 13.3 of the standard -- about 10 pages of details, but the gist of it is that for a function call to not be ambiguous, there needs to be a single function that is at least as good a match as all the possible, viable functions on every argument, and a better match than the others on at least one argument.  There's a lot of spec detail on exactly what 'better' means, but it boils down to (in this case) a match not requiring any user-defined conversion operator or object constructor is better than one which does.</p>\n<p>So in this case, there are two viable matches:</p>\n<pre><code>void Something::operator[](const foo&amp; f)\noperator[](long, const char *)\n</code></pre>\n<p>The first is a better match for the first argument, while the second is a better match for the second.  So unless there's some other function that is better than both of these, its ambiguous.</p>\n<p>That latter point is a possble workaround -- add:</p>\n<pre><code>void operator[](const char *a) { return (*this)[foo(a)]; }\n</code></pre>\n<p>to class Something</p>\n", "LastEditorUserId": "16406", "LastActivityDate": "2012-01-18T20:02:26.593", "Score": "3", "CreationDate": "2012-01-18T18:59:20.907", "ParentId": "8914986", "CommentCount": "5", "OwnerUserId": "16406", "LastEditDate": "2012-01-18T20:02:26.593"}, "8917084": {"Id": "8917084", "PostTypeId": "2", "Body": "<p>It should be easier to picture why the overload resolution is ambiguous by going through it step-by-step.</p>\n<p><code>\u00a713.5.5 [over.sub]</code></p>\n<blockquote>\n<p id=\"so_8914986_8917084_0\">Thus, a subscripting expression <code>x[y]</code> is interpreted as <code>x.operator[](y)</code> for a class object <code>x</code> of type <code>T</code> if <code>T::operator[](T1)</code> exists and <strong>if the operator is selected as the best match function by the overload resolution mechanism (13.3.3)</strong>.</p>\n</blockquote>\n<p>Now, we first need an overload set. That's constructed according to <code>\u00a713.3.1</code> and contains member aswell as non-member functions. See <a href=\"https://stackoverflow.com/a/8610728/500104\">this answer of mine</a> for a more detailed explanation.</p>\n<p><code>\u00a713.3.1 [over.match.funcs]</code></p>\n<blockquote>\n<p id=\"so_8914986_8917084_1\">p2 The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list. So that argument and parameter lists are comparable within this heterogeneous set, <strong>a member function is considered to have an extra parameter, called the implicit object parameter, which represents the object for which the member function has been called</strong>. [...]</p>\n<p id=\"so_8914986_8917084_2\">p3 Similarly, when appropriate, the context can construct an argument list that contains an <em>implied object argument</em> to denote the object to be operated on.</p>\n</blockquote>\n<pre><code>// abstract overload set (return types omitted since irrelevant)\nf1(Something&amp;, foo const&amp;); // linked to Something::operator[](foo const&amp;)\nf2(std::ptrdiff_t, char const*); // linked to operator[](std::ptrdiff_t, char const*)\nf3(char const*, std::ptrdiff_t); // linked to operator[](char const*, std::ptrdiff_t)\n</code></pre>\n<p>Then, an argument list is constructed:</p>\n<pre><code>// abstract argument list\n(Something&amp;, char const[3]) // 'Something&amp;' is the implied object argument\n</code></pre>\n<p>And then the argument list is tested against every member of the overload set:</p>\n<pre><code>f1 -&gt; identity match on argument 1, conversion required for argument 2\nf2 -&gt; conversion required for argument 1, conversion required for argument 2 (decay)\nf3 -&gt; argument 1 incompatible, argument 2 incompatible, discarded\n</code></pre>\n<p>Then, since we found out that there are implicit conversions required, we take a look at <code>\u00a713.3.3 [over.match.best] p1</code>:</p>\n<blockquote>\n<p id=\"so_8914986_8917084_3\">Define <code>ICSi(F)</code> as follows:</p>\n<ul>\n<li>if <code>F</code> is a static member function, [...]; otherwise,</li>\n<li>let <code>ICSi(F)</code> denote the implicit conversion sequence that converts the <code>i</code>-th argument in the list to the type of the <code>i</code>-th parameter of viable function <code>F</code>. 13.3.3.1 defines the implicit conversion sequences and 13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another.</li>\n</ul>\n</blockquote>\n<p>Now let's construct those implicit conversion sequences for <code>f1</code> and <code>f2</code> in the overload set (<code>\u00a713.3.3.1</code>):</p>\n<pre><code>ICS1(f1): 'Something&amp;' -&gt; 'Someting&amp;', standard conversion sequence\nICS2(f1): 'char const[3]' -&gt; 'foo const&amp;', user-defined conversion sequence\nICS1(f2): 'Something&amp;' -&gt; 'std::ptrdiff_t', user-defined conversion sequence\nICS2(f2): 'char const[3]' -&gt; 'char const*', standard conversion sequence\n</code></pre>\n<p><code>\u00a713.3.3.2 [over.ics.rank] p2</code></p>\n<blockquote>\n<p id=\"so_8914986_8917084_4\">a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence.</p>\n</blockquote>\n<p>So <code>ICS1(f1)</code> is better than <code>ICS1(f2)</code> and <code>ICS2(f1)</code> is worse than <code>ICS2(f2)</code>.<br>\nConversely, <code>ICS1(f2)</code> is worse than <code>ICS1(f1)</code> and <code>ICS2(f2)</code> is better than <code>ICS2(f1)</code>.</br></p>\n<p><code>\u00a713.3.3 [over.match.best]</code></p>\n<blockquote>\n<p id=\"so_8914986_8917084_5\">p1 (cont.) Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function <code>F2</code> <strong>if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code></strong>, and then [...]</p>\n<p id=\"so_8914986_8917084_6\">p2 If there is exactly one viable function that is a better function than all other viable functions, then it is the one selected by overload resolution; otherwise the call is ill-formed.</p>\n</blockquote>\n<p>Well, f*ck. :) As such, Clang is correct in rejecting that code.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-18T22:22:14.077", "Score": "11", "CreationDate": "2012-01-18T20:42:27.743", "ParentId": "8914986", "CommentCount": "0", "OwnerUserId": "500104", "LastEditDate": "2017-05-23T11:52:26.310"}});