post_cb({"4131099": {"ParentId": "4131091", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>dynamic_cast</code> works only on polymorphic types, i.e. classes containing virtual functions.</p>\n<p>In gcc you can <code>dynamic_cast</code> <strong>to</strong> <code>void*</code> but not <strong>from</strong>:</p>\n<pre><code>struct S\n{\n    virtual ~S() {}\n};\n\nint main()\n{\n    S* p = new S();\n    void* v = dynamic_cast&lt;void*&gt;(p);\n    S* p1 = dynamic_cast&lt;S*&gt;(v); // gives an error\n}\n</code></pre>\n", "OwnerUserId": "471164", "LastEditorUserId": "287316", "LastEditDate": "2014-01-07T13:53:17.537", "Id": "4131099", "Score": "33", "CreationDate": "2010-11-09T06:39:30.053", "LastActivityDate": "2014-01-07T13:53:17.537"}, "4131109": {"ParentId": "4131091", "CommentCount": "1", "Body": "<p>I guess you confuse with <code>dynalic_cast</code> <em>to</em> <code>void*</code>. That is legal and obtains the pointer to the most derived class object.</p>\n<p><code>dynamic_cast</code> <em>from</em> <code>void*</code> is illegal - the type casted from must be polymorphic - contain at least one virtual function (virtual destructor counts too).</p>\n", "OwnerUserId": "57428", "PostTypeId": "2", "Id": "4131109", "Score": "0", "CreationDate": "2010-11-09T06:40:49.257", "LastActivityDate": "2010-11-09T06:40:49.257"}, "4131091": {"CommentCount": "0", "AcceptedAnswerId": "4131099", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-11-09T06:36:37.730", "LastActivityDate": "2015-09-03T09:51:15.033", "LastEditDate": "2017-05-23T10:29:28.723", "ViewCount": "21627", "FavoriteCount": "1", "Title": "dynamic_cast from \"void *\"", "Id": "4131091", "Score": "28", "Body": "<p>According to <a href=\"https://stackoverflow.com/questions/3155277/cannot-dynamic-cast-void-to-templated-class\">this</a>, <code>void*</code> has no RTTI information, therefore casting from <code>void*</code> is not legal and it make sense.</p>\n<p>If I remember correctly, <code>dynamic_cast</code> from <code>void*</code> was working on gcc. </p>\n<p>Can you please clarify the issue.</p>\n", "Tags": "<c++><rtti><void-pointers><dynamic-cast>", "OwnerUserId": "135960", "AnswerCount": "5"}, "4131119": {"ParentId": "4131091", "CommentCount": "0", "Body": "<p>You can cast a pointer to polymorphic type to <code>void *</code>, but not vice versa.</p>\n", "OwnerUserId": "182529", "PostTypeId": "2", "Id": "4131119", "Score": "0", "CreationDate": "2010-11-09T06:42:16.360", "LastActivityDate": "2010-11-09T06:42:16.360"}, "4131138": {"ParentId": "4131091", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In <code>5.2.7 - Dynamic cast [expr.dynamic.cast]</code> it says that for <code>dynamic_cast&lt;T&gt;(v)</code>:</p>\n<ul>\n<li>If <code>T</code> is a pointer type, <code>v</code> shall be an rvalue of a pointer to complete class type</li>\n<li>If <code>T</code> is a reference type, <code>v</code> shall be an lvalue of a complete class type (thanks usta for commenting on my missing this)</li>\n</ul>\n<p>...</p>\n<ul>\n<li>Otherwise, <code>v</code> shall be a pointer to or an lvalue of a polymorphic type </li>\n</ul>\n<p>So, no, a <code>(void*)</code> <em>value</em> is not allowed.</p>\n<p>Let's think about what your request might mean: say you've got a pointer that's really to a <code>Derived1*</code>, but the code <code>dynamic_cast</code>-ing only knows it's a <code>void*</code>.  Let's say you're trying to cast it to a <code>Derived2*</code>, where both derived classes have a common base.  Superficially, you might think all the pointers would point to the same <code>Base</code> object, which would contain a pointer to the relevant virtual dispatch table and RTTI, so everything could hang together.  But, consider that derived classes may have multiple base classes, and therefore the needed <code>Base</code> class sub-object might not be the one to which the <code>Derived*</code> - available only as a <code>void*</code> - is pointing.  It wouldn't work.  Conclusion: the compiler needs to know these types so it can perform some adjustment to the pointers based on the types involved.</p>\n<pre>\nDerived1* -----&gt; [AnotherBase]\n                 [[VDT]Base]    &lt;-- but, need a pointer to start of\n                 [extra members]    this sub-object for dynamic_cast\n</pre>\n<p>(Some answers talk about the need for the pointer you're casting from to be of a polymorphic type, having virtual functions.  That's all valid, but a bit misleading.  As you can see above, even if the <code>void*</code> is to such a type it still wouldn't work reliably without the full type information, as the real problem is that <code>void*</code> is presumably pointing to the start of the derived object, whereas you need a pointer to the base class sub-object from which the cast-to type derives.)</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2015-09-03T09:51:15.033", "Id": "4131138", "Score": "11", "CreationDate": "2010-11-09T06:46:31.213", "LastActivityDate": "2015-09-03T09:51:15.033"}, "4131097": {"ParentId": "4131091", "CommentCount": "0", "Body": "<p>It is true that <code>void*</code> can't be <code>dynamically_cast</code>ed from.</p>\n<p>You are probably mis-remembering. \nWith g++ 4.5 and the following code</p>\n<pre><code>struct A {\n    virtual ~A();\n};\n\nint main() {\n    A a;\n    void *p = &amp;a;\n    A* pa = dynamic_cast&lt;A*&gt;(p);\n}\n</code></pre>\n<p>I get the following error:</p>\n<blockquote>\n<p id=\"so_4131091_4131097_0\">cannot dynamic_cast 'p' (of type 'void*') to type 'struct A*' (source is not a pointer to class)</p>\n</blockquote>\n", "OwnerUserId": "3848", "PostTypeId": "2", "Id": "4131097", "Score": "3", "CreationDate": "2010-11-09T06:39:14.327", "LastActivityDate": "2010-11-09T06:39:14.327"}, "bq_ids": {"n4140": {"so_4131091_4131097_0": {"section_id": 300, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_4131091_4131097_0": {"section_id": 291, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_4131091_4131097_0": {"section_id": 307, "quality": 0.5555555555555556, "length": 5}}}});