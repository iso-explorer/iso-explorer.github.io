post_cb({"7158191": {"ParentId": "7157691", "CommentCount": "0", "Body": "<p>Overload resolution is done before access checking, that is why even the protected base class' members are considered.</p>\n<p>Overload resolution is described in chapter 13.3 of the standard. My interpretation is that binding <code>const AutoVector ov</code> to <code>Vector ( const Vector&amp; original );</code> is <em>user defined conversion</em>, a <em>derived-to-base Conversion</em> ([13.3.3.1.4/1]) kind. For <code>Vector ( const gsl_vector_view view );</code>, the conversion sequence is also user defined conversion because it is <em>lvalue-to-rvalue conversion followed by user defined conversion</em>. So, both conversion sequences are considered equal, none is better than the other, and thus you get the ambiguity.</p>\n<p>Now, if you change the ctor to <code>Vector ( const gsl_vector_view&amp; view );</code>, both conversion are <em>lvalue-to-value conversion followed by user defined conversion (derived-to-base Conversion)</em>. Those two can be ordered ([13.3.3.2/4]) and the conversion to <code>const Vector&amp;</code> is considered better and thus there is no ambiguity.</p>\n", "OwnerUserId": "341065", "PostTypeId": "2", "Id": "7158191", "Score": "4", "CreationDate": "2011-08-23T08:30:35.070", "LastActivityDate": "2011-08-23T08:30:35.070"}, "7158915": {"ParentId": "7157691", "CommentCount": "0", "Body": "<p>The question has not to do with <code>protected</code> inheritance or constructor as such. This problem will persist with normal function call also (with whatever inheritance).</p>\n<p>When you are passing by reference in all the overload versions, then the nearest base class is chosen (if there are more than 1 base class which are nearest then it's ill formed). </p>\n<p>In case of pass by value, all the functions are considered equally well candidates. Thus you are getting this compilation error. There is a small passage of quote from standard, which matches somewhat to your question.</p>\n<blockquote>\n<p id=\"so_7157691_7158915_0\"><strong>\u00a7 13.3.1 (5)</strong><br>\n  ... For non-static member functions declared without a\n  ref-qualifier, an additional rule applies: \u2014 even if the implicit\n  object parameter is not const-qualified, an rvalue can be bound to the\n  parameter as long as in all other respects the argument can be\n  converted to the type of the implicit object parameter.</br></p>\n</blockquote>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "7158915", "Score": "1", "CreationDate": "2011-08-23T09:32:40.080", "LastActivityDate": "2011-08-23T09:32:40.080"}, "bq_ids": {"n4140": {"so_7157691_7158915_0": {"section_id": 569, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_7157691_7158915_0": {"section_id": 560, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_7157691_7158915_0": {"section_id": 592, "quality": 0.9333333333333333, "length": 28}}}, "7157691": {"CommentCount": "2", "AcceptedAnswerId": "7158191", "PostTypeId": "1", "LastEditorUserId": "341065", "CreationDate": "2011-08-23T07:39:11.860", "LastActivityDate": "2011-08-23T09:32:40.080", "LastEditDate": "2011-08-23T08:55:27.710", "ViewCount": "1172", "FavoriteCount": "3", "Title": "Ambiguous call of overloaded constructor due to super class (pass by value)", "Id": "7157691", "Score": "5", "Body": "<p>I wrote a little C++ wrapper around some parts of GSL and encounter the following puzzle (for me). The code (reduced to its essentials) is as follows:</p>\n<pre><code>    #include &lt;stdlib.h&gt;\n    struct gsl_vector_view {};\n\n    class Vector : protected gsl_vector_view {\n            public:\n            Vector ( const Vector&amp; original );\n            Vector ( const gsl_vector_view view );\n    };\n\n    class AutoVector : public Vector {\n            public:\n            explicit AutoVector ( const size_t dims );\n    };\n\n    void useVector ( const Vector b ) {}\n\n    void test () {\n            const AutoVector ov( 2 );\n            useVector( ov );\n    }\n</code></pre>\n<p>will not compile using gcc 4.4.5\n        g++ -c v.cpp\nbut yield</p>\n<pre><code>     In function \u2018void test()\u2019:\n    19: error: call of overloaded \u2018Vector(const AutoVector&amp;)\u2019 is ambiguous\n    7: note: candidates are: Vector::Vector(gsl_vector_view)\n    6: note:                 Vector::Vector(const Vector&amp;)\n    19: error:   initializing argument 1 of \u2018void useVector(Vector)\u2019\n</code></pre>\n<p>I am surprised that the <strong>protected</strong> base class gsl_vector_view is taken into consideration by the call of useVector( Vector ). I would have thought that useVector belongs to \"the general public\" in the parlance of \"The C++ Programming Language\", 3rd e., p. 405 and thus does not have access to that protected information and, hence, cannot be confused by it.\nI know that I can get rid of the ambiguity by declaring the constructor as</p>\n<pre><code>    explicit Vector ( const gsl_vector_view view );\n</code></pre>\n<p>What I did not know (and, honestly, do not understand either), is that the ambiguity of the overloaded call disappears when I declare the constructor as</p>\n<pre><code>    Vector ( const gsl_vector_view&amp; view );\n</code></pre>\n<p>i.e. pass the argument by reference (which I would anyway consider the proper way of doing things).</p>\n", "Tags": "<c++><overload-resolution>", "OwnerUserId": "889976", "AnswerCount": "2"}});