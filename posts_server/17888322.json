post_cb({"17888598": {"Id": "17888598", "PostTypeId": "2", "Body": "<p>In both C and C++, the size of an <code>enum</code> type is implementation-defined, and is the same as the size of some integer type.</p>\n<p>A common approach is to make all <code>enum</code> types the same size as <code>int</code>, simply because that's typically the type that makes for the most efficient access. Making it a single byte, for example, would save a very minor amount of space, but could require bigger and slower code to access it, depending on the CPU architecture.</p>\n<p>In C, enumeration <em>constants</em> are by definition of type <code>int</code>. So given:</p>\n<pre><code>enum foo { zero, one, two };\nenum foo obj;\n</code></pre>\n<p>the expression <code>zero</code> is of type <code>int</code>, but <code>obj</code> is of type <code>enum foo</code>, which may or may not have the same size as <code>int</code>. Given that the constants are of type <code>int</code>, it tends to be easier to make the enumerated type the same size.</p>\n<p>In C++, the rules are different; the constants are of the enumerated type. But again, it often makes the most sense for each <code>enum</code> type to be one \"word\", which is typically the size of <code>int</code>, for efficiency reasons.</p>\n<p>And the 2011 ISO C++ standard added the ability to specify the underlying integer type for an <code>enum</code> type. For example, you can now write:</p>\n<pre><code>enum foo: unsigned char { zero, one, two };\n</code></pre>\n<p>which guarantees that both the type <code>foo</code> and the constants <code>zero</code>, <code>one</code>, and <code>two</code> have a size of 1 byte.  C does not have this feature, and it's not supported by older pre-2011 C++ compilers (unless they provide it as a language extension).</p>\n<p>(Digression follows.)</p>\n<p>So what if you have an enumeration constant too big to fit in an <code>int</code>? You don't need 2<sup>31</sup>, or even 2<sup>15</sup>, distinct constants to do this:</p>\n<pre><code>#include &lt;limits.h&gt;\nenum huge { big = INT_MAX, bigger };\n</code></pre>\n<p>The value of <code>big</code> is <code>INT_MAX</code>, which is typically 2<sup>31</sup>-1, but can be as small as 2<sup>15</sup>-1 (32767). The value of <code>bigger</code> is implicitly <code>big + 1</code>.</p>\n<p>In C++, this is ok; the compiler will simply choose an underlying type for <code>huge</code> that's big enough to hold the value <code>INT_MAX + 1</code>. (Assuming there is such a type; if <code>int</code> is 64 bits and there's no integer type bigger than that, that won't be possible.)</p>\n<p>In C, since enumeration constants are of type <code>int</code>, the above is invalid. It violates the constraint stated in <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">N1570</a> 6.7.2.2p2:</p>\n<blockquote>\n<p id=\"so_17888322_17888598_0\">The expression that defines the value of an enumeration constant shall\n  be an integer constant expression that has a value representable as an\n  <strong>int</strong>.</p>\n</blockquote>\n<p>and so a compiler must reject it, or at least warn about it. gcc, for example, says:</p>\n<blockquote>\n<p id=\"so_17888322_17888598_1\">error: overflow in enumeration values</p>\n</blockquote>\n", "LastEditorUserId": "827263", "LastActivityDate": "2015-11-08T23:50:36.033", "Score": "19", "CreationDate": "2013-07-26T18:34:11.537", "ParentId": "17888322", "CommentCount": "2", "OwnerUserId": "827263", "LastEditDate": "2015-11-08T23:50:36.033"}, "17888322": {"ViewCount": "8943", "Body": "<p>Why is the size of an <code>enum</code> always 2 or 4 bytes (on a 16- or 32-bit architecture respectively), regardless of the number of enumerators in the type?</p>\n<p>Does the compiler treat an <code>enum</code> like it does a <code>union</code>?</p>\n", "AcceptedAnswerId": "17888598", "Title": "Constant enum size no matter the number of enumerated values", "CreationDate": "2013-07-26T18:19:13.850", "Id": "17888322", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-01-01T03:44:26.543", "LastEditorUserId": "3185819", "LastActivityDate": "2016-01-01T03:44:26.543", "Score": "11", "OwnerUserId": "2592816", "Tags": "<c++><c><enums>", "AnswerCount": "6"}, "17889485": {"Id": "17889485", "PostTypeId": "2", "Body": "<p>The big problem with making an <code>enum</code> type smaller than <code>int</code> when a smaller type could fit all the values is that it would make the ABI for a translation unit dependent on the number of enumeration constants. For instance, suppose you have a library that uses an <code>enum</code> type with 256 constants as part of its public interface, and the compiler chooses to represent the type as a single byte. Now suppose you add a new feature to the library and now need 257 constants. The compiler would have to switch to a new size/representation, and now all object files compiled for the old interface would be incompatible with your updated library; you would have to recompile everything to make it work again.</p>\n<p>Thus, any sane implementation always uses <code>int</code> for <code>enum</code> types.</p>\n", "LastActivityDate": "2013-07-26T19:29:35.233", "CommentCount": "0", "CreationDate": "2013-07-26T19:29:35.233", "ParentId": "17888322", "Score": "0", "OwnerUserId": "379897"}, "bq_ids": {"n4140": {"so_17888322_17888368_1": {"length": 36, "quality": 0.6428571428571429, "section_id": 5466}, "so_17888322_17888598_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 5464}}, "n3337": {"so_17888322_17888368_1": {"length": 37, "quality": 0.6607142857142857, "section_id": 5252}}, "n4659": {"so_17888322_17888368_1": {"length": 36, "quality": 0.6428571428571429, "section_id": 6900}, "so_17888322_17888598_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 6898}}}, "17888379": {"Id": "17888379", "PostTypeId": "2", "Body": "<p>An enum is not a structure, it's just a way of giving names to a set of integers. The size of a variable with this type is just the size of the underlying integer type.</p>\n", "LastActivityDate": "2013-07-26T18:22:25.007", "CommentCount": "3", "CreationDate": "2013-07-26T18:22:25.007", "ParentId": "17888322", "Score": "9", "OwnerUserId": "1491895"}, "17888368": {"Id": "17888368", "PostTypeId": "2", "Body": "<p>The size of an enum is implementation-defined -- the compiler is allowed to choose whatever size it wants, as long as it's large enough to fit all of the values.  Some compilers choose to use 4-byte enums for all enum types, while some compilers will choose the smallest type (e.g. 1, 2, or 4 bytes) which can fit the enum values.  The C and C++ language standards allow both of these behaviors.</p>\n<p>From C99 \u00a76.7.2.2/4:</p>\n<blockquote>\n<p id=\"so_17888322_17888368_0\">Each enumerated type shall be compatible with <code>char</code>, a signed integer type, or an\n  unsigned integer type. The choice of type is implementation-defined,<sup>110)</sup> but shall be\n  capable of representing the values of all the members of the enumeration.</p>\n</blockquote>\n<p>From C++03 \u00a77.2/5:</p>\n<blockquote>\n<p id=\"so_17888322_17888368_1\">The <em>underlying type</em> of an enumeration is an integral type that can represent all the enumerator values\n  defined in the enumeration. It is implementation-defined which integral type is used as the underlying type\n  for an enumeration except that the underlying type shall not be larger than <code>int</code> unless the value of an enumerator\n  cannot fit in an <code>int</code> or <code>unsigned int</code>. If the <em>enumerator-list</em> is empty, the underlying type is\n  as if the enumeration had a single enumerator with value 0. The value of <code>sizeof()</code> applied to an enumeration\n  type, an object of enumeration type, or an enumerator, is the value of <code>sizeof()</code> applied to the\n  underlying type.</p>\n</blockquote>\n", "LastEditorUserId": "9530", "LastActivityDate": "2013-07-26T18:28:22.533", "Score": "8", "CreationDate": "2013-07-26T18:21:57.583", "ParentId": "17888322", "CommentCount": "5", "OwnerUserId": "9530", "LastEditDate": "2013-07-26T18:28:22.533"}, "17941428": {"Id": "17941428", "PostTypeId": "2", "Body": "<p>It seems to me that the OP has assumed that an enum is some kind of collection which stores the values declared in it. This is incorrect.</p>\n<p>An enumeration in C/C++ is simply a numeric variable with strictly defined value range. The names of the enum are kind of aliases for numbers.</p>\n<p>The storage size is not influenced by the amount of the values in enumeration. The storage size is implementation defined, but mostly it is the <code>sizeof(int)</code>.</p>\n", "LastActivityDate": "2013-07-30T08:02:47.953", "CommentCount": "0", "CreationDate": "2013-07-30T08:02:47.953", "ParentId": "17888322", "Score": "3", "OwnerUserId": "1961634"}, "17888471": {"Id": "17888471", "PostTypeId": "2", "Body": "<p>The size of an <code>enum</code> is \"an integral type at least large enough to contain any of the values specified in the declaration\". Many compilers will just use an <code>int</code> (possibly <code>unsigned</code>), but some will use a <code>char</code> or <code>short</code>, depending on optimization or other factors. An <code>enum</code> with less than 128 possible values would fit in a <code>char</code> (256 for <code>unsigned char</code>), and you would have to have 32768 (or 65536) values to overflow a <code>short</code>, and either 2 or 4 billion values to outgrow an <code>int</code> on most modern systems.</p>\n<p>An <code>enum</code> is essentially just a better way of defining a bunch of different constants. Instead of this:</p>\n<pre><code>#define FIRST 0\n#define SECOND 1\n...\n</code></pre>\n<p>you just:</p>\n<pre><code>enum myenum\n{ FIRST,\n  SECOND,\n  ...\n};\n</code></pre>\n<p>It helps avoid assigning duplicate values by mistake, and removes your need to even care what the particular values are (unless you really need to).</p>\n", "LastEditorUserId": "1253222", "LastActivityDate": "2013-07-26T18:37:14.393", "Score": "1", "CreationDate": "2013-07-26T18:27:07.933", "ParentId": "17888322", "CommentCount": "3", "OwnerUserId": "1253222", "LastEditDate": "2013-07-26T18:37:14.393"}});