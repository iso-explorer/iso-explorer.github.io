post_cb({"26979464": {"CommentCount": "4", "ViewCount": "1140", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2014-11-17T18:33:04.390", "LastActivityDate": "2014-11-17T21:24:02.503", "Title": "How to fail a constructor with new(std::nothrow)?", "AcceptedAnswerId": "26982066", "LastEditDate": "2014-11-17T18:36:39.890", "Id": "26979464", "Score": "3", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;new&gt;\n#include &lt;malloc.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid * operator new(size_t size) {\n    void *res;\n    if (size == 1) {\n        res = NULL;\n    } else {\n        res = malloc(size);\n    }\n    fprintf(stderr, \"%s(%zu) = %p\\n\", __PRETTY_FUNCTION__, size, res);\n    if (res == NULL) throw std::bad_alloc();\n    return res;\n}\n\nvoid * operator new(size_t size, const std::nothrow_t&amp;) {\n    void *res;\n    if (size == 1) {\n        res = NULL;\n    } else {\n        res = malloc(size);\n    }\n    fprintf(stderr, \"%s(%zu) = %p\\n\", __PRETTY_FUNCTION__, size, res);\n    return res;\n}\n\nvoid operator delete(void *ptr) {\n    fprintf(stderr, \"%s(%p)\\n\", __PRETTY_FUNCTION__, ptr);\n    free(ptr);\n}\n\nvoid operator delete(void *ptr, const std::nothrow_t&amp;) {\n    fprintf(stderr, \"%s(%p)\\n\", __PRETTY_FUNCTION__, ptr);\n    free(ptr);\n}\n\nclass Foo { };\n\nclass Bar {\npublic:\n    Bar() : ptr(new Foo()) {\n        fprintf(stderr, \"%s: ptr = %p\\n\", __PRETTY_FUNCTION__, ptr);\n    }\n    Bar(const std::nothrow_t&amp;) noexcept : ptr(new(std::nothrow) Foo()) {\n        fprintf(stderr, \"%s: ptr = %p\\n\", __PRETTY_FUNCTION__, ptr);\n    }\n    ~Bar() noexcept {\n        delete ptr;\n    }\n    Foo *ptr;\n};\n\nclass Baz {\npublic:\n    Baz() : ptr(new Foo()) {\n        fprintf(stderr, \"%s: ptr = %p\\n\", __PRETTY_FUNCTION__, ptr);\n    }\n    ~Baz() {\n        delete ptr;\n    }\n    Foo *ptr;\n};\n\nint main() {\n    Bar *bar = new(std::nothrow) Bar(std::nothrow_t());\n    if (bar != NULL) {\n        delete bar;\n    } else { fprintf(stderr, \"bad alloc on Bar(std::nothrow_t())\\n\"); }\n    fprintf(stderr, \"\\n\");\n    try {\n        bar = new(std::nothrow) Bar();\n        delete bar;\n    } catch (std::bad_alloc) { fprintf(stderr, \"bad alloc on Bar()\\n\"); }\n    fprintf(stderr, \"\\n\");\n    try {\n        Baz *baz = new Baz();\n        delete baz;\n    } catch (std::bad_alloc) { fprintf(stderr, \"bad alloc on Baz()\\n\"); }\n}\n</code></pre>\n<p>This produces the following output:</p>\n<pre><code>void* operator new(size_t, const std::nothrow_t&amp;)(8) = 0x1fed010\nvoid* operator new(size_t, const std::nothrow_t&amp;)(1) = (nil)\nBar::Bar(const std::nothrow_t&amp;): ptr = (nil)\nvoid operator delete(void*)((nil))\nvoid operator delete(void*)(0x1fed010)\n\nvoid* operator new(size_t, const std::nothrow_t&amp;)(8) = 0x1fed010\nvoid* operator new(std::size_t)(1) = (nil)\nvoid operator delete(void*, const std::nothrow_t&amp;)(0x1fed010)\nbad alloc on Bar()\n\nvoid* operator new(std::size_t)(8) = 0x1fed010\nvoid* operator new(std::size_t)(1) = (nil)\nvoid operator delete(void*)(0x1fed010)\nbad alloc on Baz()\n</code></pre>\n<p>As you can see allocating the first Bar succeeds despite the allocation of Foo failing. The second allocation of Bar and alloaction of Baz fail properly through the use of std::bad_alloc.</p>\n<p>Now my question is: How to make \"new(std::nothrow) Bar(std::nothrow_t());\" free the memory for Bar and return NULL when Foo fails to allocate? Is dependency inversion the only solution?</p>\n", "Tags": "<c++><c++11><constructor><new-operator><nothrow>", "OwnerUserId": "4262344", "AnswerCount": "2"}, "26982066": {"ParentId": "26979464", "CommentCount": "2", "Body": "<p>Let's suppose you want to be able to have failed construction without exceptions as a general rule.</p>\n<p>I will sketch such a system.</p>\n<pre><code>template&lt;class Sig&gt;\nstruct has_creator;\ntemplate&lt;class T, class...Args&gt;\nstruct has_creator&lt;T(Args...)&gt;\n</code></pre>\n<p>this is a traits class that descendes from <code>true_type</code> iff your type <code>T</code> has a static method that matches the signature <code>bool T::emplace_create(T*, Args&amp;&amp;...)</code>.</p>\n<p><code>emplace_create</code> returns false on creation failure.  The <code>T*</code> must point to an uninitialized chunk of memory with proper alignment and <code>sizeof(T)</code> or larger.</p>\n<p>We can now write this:</p>\n<pre><code>template&lt;class T, class...Args&gt;\nT* create( Args&amp;&amp;... args )\n</code></pre>\n<p>which is a function that detects if <code>T</code> <code>has_creator</code>, and if so allocates memory, does an <code>emplace_create</code>, and if it fails it cleans up the memory and returns <code>nullptr</code>.  Naturally it uses nothrow <code>new</code>.</p>\n<p>You now use <code>create&lt;T&gt;</code> in place of <code>new</code> everywhere.</p>\n<p>The big downside is that we don't support inheritance very well.  And composition gets tricky: we basically write our constructor in <code>emplace_create</code> and have our actual constructor do next to nothing, and in <code>emplace_create</code> we handle failure cases (like sub objects having a failed <code>create&lt;X&gt;</code> call).</p>\n<p>We also get next to no help with inheritance.  If we want help with inheritance, we can write two different methods -- one for a no-failure initial construction, and the second for failure-prone creation of resources.</p>\n<p>I will note that it gets a touch less annoying if you stop storing raw pointers anywhere.  If you store things in <code>std::unique_ptr</code> everywhere (even to the point of having <code>create&lt;T&gt;</code> returning <code>std::unique_ptr&lt;T&gt;</code>), and throw in a guarded end-of-scope destroyer with abort, and your destructor has to be able to handle \"half-constructed\" objects.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "26982066", "Score": "0", "CreationDate": "2014-11-17T21:13:10.037", "LastActivityDate": "2014-11-17T21:13:10.037"}, "26980546": {"ParentId": "26979464", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>C++11 \u00a75.3.4/18:</p>\n<blockquote>\n<p id=\"so_26979464_26980546_0\"><strong>\u201d</strong> If any part of the object initialization described above terminates by throwing an exception and a suitable\n  deallocation function can be found, the deallocation function is called to free the memory in which the object\n  was being constructed, after which the exception continues to propagate in the context of the <em>new-expression</em>.</p>\n</blockquote>\n<p>So <code>std::nothrow</code> does not guarantee no exception from a <em>new-expression</em>. It\u2019s just an argument passed to the allocation function, selecting the no-throwing one from the standard library. It\u2019s apparently mainly in support of more C-style pre-standard code.</p>\n<p>The whole cleanup mechanism in modern C++ is based on exceptions.</p>\n<p>To work around that \u2013 which I think is silly, not a thing to do, but you\u2019re asking \u2013 do e.g.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;new&gt;\n#include &lt;stdexcept&gt;\n#include &lt;stdlib.h&gt;         // EXIT_FAILURE\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n\nnamespace my { class Foo; }\n\ntemplate&lt; class Type, class... Args &gt;\nauto null_or_new( Args&amp;&amp;... args )\n    -&gt; Type*\n{\n    #ifdef NULLIT\n        if( typeid( Type ) == typeid( my::Foo ) ) { return nullptr; }\n    #endif\n\n    try\n    {\n        return new( std::nothrow ) Type( std::forward&lt;Args&gt;( args )... );\n    }\n    catch( ... )\n    {\n        return nullptr;\n    }\n}\n\nnamespace my\n{\n    using namespace std;\n\n    class Foo {};\n\n    class Bah\n    {\n    private:\n        Foo*    p_;\n\n    public:\n        Bah()\n            : p_( null_or_new&lt;Foo&gt;() )\n        {\n            clog &lt;&lt; \"Bah::&lt;init&gt;() reports: p_ = \" &lt;&lt; p_ &lt;&lt; endl;\n            if( !p_ ) { throw std::runtime_error( \"Bah::&lt;init&gt;()\" ); }\n        }\n    };\n}  // namespace my\n\nauto main() -&gt; int\n{\n    using namespace std;\n    try\n    {\n        auto p = null_or_new&lt;my::Bah&gt;();\n        cout &lt;&lt; p &lt;&lt; endl;\n        return EXIT_SUCCESS;\n    }\n    catch( exception const&amp; x )\n    {\n        cerr &lt;&lt; \"!\" &lt;&lt; x.what() &lt;&lt; endl;\n    }\n    return EXIT_FAILURE;\n}\n</code></pre>\n<hr>\n<p>Why the requested approach IMHO is silly:</p>\n<ul>\n<li><p>It forsakes the safety of exceptions. No guaranteed cleanup on failure propagation. Indeed no guaranteed failure propagation, it\u2019s all very manual.</p></li>\n<li><p>It discards all information about the failure, e.g. exception message. One can add mechanisms to retain some of that, but it gets complicated and inefficient.</p></li>\n<li><p>It has no plausible advantage that I can think of.</p></li>\n</ul>\n<hr>\n<p>In passing, note that format specifier <code>%zu</code> and macro <code>__PRETTY_FUNCTION__</code> don\u2019t work with Visual C++.</p>\n<p>Also note that in order to return a nullpointer, an allocation function must be declared to be non-throwing.</p>\n<hr>\n<p><strong>Addendum</strong></p>\n<p>An example of doing things very very manually, avoiding even internal exceptions. Mainly the cost is that one gives up the usual C++ machinery where only those data members already successfully constructed, are destroyed when failure is detected. Instead everything must be constructed to dummy states, so that one has <strong>zombie objects</strong> temporarily available.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;new&gt;\n#include &lt;stdexcept&gt;\n#include &lt;stdlib.h&gt;         // EXIT_FAILURE\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n\nnamespace my { class Foo; }\n\nstruct Result_code { enum Enum { success, failure }; };\n\ntemplate&lt; class Type, class... Args &gt;\nauto null_or_new( Args&amp;&amp;... args )\n    -&gt; Type*\n{\n    #ifdef NULLIT\n        if( typeid( Type ) == typeid( my::Foo ) ) { return nullptr; }\n    #endif\n\n    auto code = Result_code::Enum();\n    auto const p = new( std::nothrow ) Type( code, std::forward&lt;Args&gt;( args )... );\n    if( p != nullptr &amp;&amp; code != Result_code::success )\n    {\n        p-&gt;Type::~Type();\n        ::operator delete( p, std::nothrow );\n        return nullptr;\n    }\n    return p;\n}\n\nnamespace my\n{\n    using namespace std;\n\n    class Foo { public: Foo( Result_code::Enum&amp; ) {} };\n\n    class Bah\n    {\n    private:\n        Foo*    p_;\n\n    public:\n        Bah( Result_code::Enum&amp; code )\n            : p_( null_or_new&lt;Foo&gt;() )\n        {\n            clog &lt;&lt; \"Bah::&lt;init&gt;() reports: p_ = \" &lt;&lt; p_ &lt;&lt; endl;\n            if( !p_ ) { code = Result_code::failure; }\n        }\n    };\n}  // namespace my\n\nauto main() -&gt; int\n{\n    using namespace std;\n    try\n    {\n        auto p = null_or_new&lt;my::Bah&gt;();\n        cout &lt;&lt; p &lt;&lt; endl;\n        return EXIT_SUCCESS;\n    }\n    catch( exception const&amp; x )\n    {\n        cerr &lt;&lt; \"!\" &lt;&lt; x.what() &lt;&lt; endl;\n    }\n    return EXIT_FAILURE;\n}\n</code></pre>\n</hr></hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2014-11-17T21:24:02.503", "Id": "26980546", "Score": "2", "CreationDate": "2014-11-17T19:37:13.037", "LastActivityDate": "2014-11-17T21:24:02.503"}, "bq_ids": {"n4140": {"so_26979464_26980546_0": {"section_id": 6101, "quality": 1.0, "length": 28}}, "n3337": {"so_26979464_26980546_0": {"section_id": 5867, "quality": 1.0, "length": 28}}, "n4659": {"so_26979464_26980546_0": {"section_id": 7598, "quality": 1.0, "length": 28}}}});