post_cb({"45681513": {"ParentId": "45681363", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><a href=\"http://eel.is/c++draft/expr.prim.id.qual#2\" rel=\"nofollow noreferrer\">[expr.prim.id.qual]</a>:</p>\n<blockquote>\n<p id=\"so_45681363_45681513_0\">A <em>nested-name-specifier</em> that denotes a class, optionally followed by\n  the keyword <code>template</code> ([temp.names]), and then followed by the name of\n  a member of either that class ([class.mem]) or one of its base\n  classes, is a <em>qualified-id</em>; [class.qual] describes name lookup for\n  class members that appear in qualified-ids. The result is the member.\n  The type of the result is the type of the member. <strong>The result is an\n  lvalue if the member is a static member function or a data member and\n  a prvalue otherwise.</strong></p>\n</blockquote>\n<p>That is, creating a pointer-to-member to a non-static member function is applying the <code>&amp;</code> operator to a prvalue.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2017-08-14T19:17:18.727", "Id": "45681513", "Score": "3", "CreationDate": "2017-08-14T19:13:49.227", "LastActivityDate": "2017-08-14T19:17:18.727"}, "bq_ids": {"n4140": {"so_45681363_45681513_0": {"section_id": 5955, "quality": 0.8723404255319149, "length": 41}}, "n3337": {"so_45681363_45681513_0": {"section_id": 5724, "quality": 0.8723404255319149, "length": 41}}, "n4659": {"so_45681363_45681513_0": {"section_id": 7443, "quality": 0.8723404255319149, "length": 41}}}, "45681363": {"CommentCount": "3", "ViewCount": "106", "PostTypeId": "1", "LastEditorUserId": "4751585", "CreationDate": "2017-08-14T19:03:57.233", "LastActivityDate": "2017-08-14T19:17:18.727", "Title": "Is there an rvalue that I can directly take an address of?", "AcceptedAnswerId": "45681513", "LastEditDate": "2017-08-14T19:09:38.653", "Id": "45681363", "Score": "1", "Body": "<p>I can take an address of an rvalue by binding in to a reference (which itself, as I understand, can only be referred to by an lvalue).</p>\n<p>Is there any way to get rvalue that I can directly take an address of (i.e. like <code>&amp;(&lt;rvalue&gt;)</code> would be a valid expression, without overriding <code>operator&amp;()</code>)?</p>\n<p>Or maybe such is at least possible through 'binding' to another rvalue? (This does not seems to be the case as we can only 'bind' to references which are lvalues, see above. But maybe I'm missing some similar concept here.)</p>\n<p>The more general question I'm trying to answer is whether the following is true: rvalues strictly correspond to a set of expressions that one can directly take an address of, except lvalue bitfields and maybe some other such 'special' kinds of lvalues.</p>\n", "Tags": "<c++><c++14><language-lawyer><rvalue><value-categories>", "OwnerUserId": "4751585", "AnswerCount": "1"}});