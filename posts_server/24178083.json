post_cb({"bq_ids": {"n4140": {"so_24178083_24178216_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 72}}, "n3337": {"so_24178083_24178216_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 67}}}, "24178083": {"ViewCount": "753", "Body": "<h2>context/ultimate wish (though barely relevant to the question)</h2>\n<p>do a benchmark for lots of sizes for lots of containers for lots of element types.</p>\n<p>at least I would like to have a template combiner of type-lists to create a foreach(foreach) scheme. (obtain a 16-elements list from two 4-elems lists.)</p>\n<p><strong>I do not have boost mpl, nor C++11.</strong> :'(</p>\n<p>I am trying at first to create a list of pairs with the first element of list1 being repeated all over a new list, where second elements would be copies of elements of list2.\nthat would be the first step. (final goal is to obtain a list of the size of list1, made of list of pairs with all the combinations.)</p>\n<p>anyway I bump into a little practical issue, where I have a Transform meta function that accepts only a Predicate with 1 template argument as the transformer function.</p>\n<p>But I wish to create a closure from a 2 argument metafunction to one that takes 1 argument but has stored the first during typedefing.</p>\n<p>I did that:</p>\n<pre><code>template &lt; template &lt;class&gt; class Principal, typename TypeListN_T &gt;\nstruct Transform\n{\n    typedef typename detail::TransformAux&lt;Principal, TypeListN_T, EmptyT, Length&lt;TypeListN_T&gt;::value - 1 &gt;::Value_t Value_t;\n};\n\n\ntemplate &lt; typename T1, typename T2 &gt;\nstruct Pair\n{\n    typedef T1 First_t;\n    typedef T2 Second_t;\n};\n\ntemplate &lt; typename T1, typename T2 &gt;\nstruct MakePair\n{\n    typedef Pair&lt; T1, T2 &gt; Value_t;\n};\n\ntemplate &lt; template &lt; class, class &gt; class Binary, typename T &gt;\nstruct Unarify\n{\n    template &lt; typename T2 &gt;\n    struct U\n    {\n        typedef Binary&lt; T, T2 &gt; value_t;\n    };\n};\n\n// create a list of \" Pair&lt;Tfirst, List::At&lt; i &gt; &gt; \" for each i in List.\ntemplate &lt; typename TFirst, typename List &gt;\nstruct EmplaceListInSecond\n{\n    typedef typename List::Head_t ToPlaceRightT;\n    typedef TFirst                ToPlaceLeftT;\n\n    template &lt; typename T &gt;\n    struct UnaryPairMaker : Unarify&lt; MakePair, ToPlaceLeftT &gt;::U\n    {\n    };\n\n    typedef typename Transform&lt; UnaryPairMaker, List &gt;::Value_t Value_t;\n};\n</code></pre>\n<h2>The real problem</h2>\n<p>the compiler (visual studio 2012), is giving me:</p>\n<blockquote>\n<p id=\"so_24178083_24178083_0\">1&gt;..\\BenchmarkApp.cpp(648): error C2955: 'Meta::Unarify::U'\n  : use of class template requires template argument list</p>\n</blockquote>\n<p>this happens on the last-fifth line in the code extract.\non this line:</p>\n<pre><code>struct UnaryPairMaker : Unarify&lt; MakePair, ToPlaceLeftT &gt;::U\n</code></pre>\n<p>Which I find super strange, because I am placing a 2-args template class (MakePair) into the template-template parameter of Unarify, where normally it should be accepted.</p>\n<p>It should be accepted because the first template argument of Unarify is supposed to be a template class. And the compiler complains that it .... is a template class....</p>\n<p>what the hell is going on here ?</p>\n<h2>EDIT : Solution</h2>\n<p>Here guys/girls for you future readers, like WhozCraig and Marco A. both mentioned, the problem was <code>::U</code> and not <code>MakePair</code>. Crazy quick code scanning ability guys, respect.</p>\n<pre><code>template &lt; template &lt; class, class &gt; class Binary, typename T &gt;\nstruct Unarify\n{\n    template &lt; typename T2 &gt;\n    struct U\n    {\n        // little fix here compared to previous version ::Value_t wasnt called.\n        typedef typename Binary&lt; T, T2 &gt;::Value_t Value_t;\n    };\n};\n\n// create a list of \" Pair&lt;Tfirst, List::At&lt; i &gt; &gt; \" for each i in List.\ntemplate &lt; typename TFirst, typename List &gt;\nstruct EmplaceListInSecond\n{\n    typedef typename List::Head_t ToPlaceRightT;\n    typedef TFirst                ToPlaceLeftT;\n\n    // big fix here, ::U is a template class that needed an argument (INDEED !!)\n    // I was mistakenly taking the message for a MakePair problem, maybe would\n    // have it been cland I would have seen the column number. well whatever...\n    // T is the actual PLACEHOLDER that will accept the values passed during\n    // visitation by the Transform function, and it is the type we want for U's T2 !    \n    template &lt; typename T &gt;\n    struct UnaryPairMaker : Unarify&lt; MakePair, ToPlaceLeftT &gt;::template U&lt;T&gt;\n    {\n    };\n\n    typedef typename Transform&lt; UnaryPairMaker, List &gt;::Value_t Value_t;\n};\n</code></pre>\n<p>There we go. it IS POSSIBLE MAN ! Yes, it is possible to close a type from a binary metafunction into an unary metafunction passable to a meta-algorithm that takes a unary metafunction as a functor. hehe. C++ just freaking rocks.</p>\n", "AcceptedAnswerId": "24178216", "Title": "\"use of class template requires template argument list\" error, even though template of template is used, therefore template class is expected", "CreationDate": "2014-06-12T06:47:44.360", "Id": "24178083", "CommentCount": "5", "LastEditDate": "2014-06-12T07:26:13.883", "PostTypeId": "1", "LastEditorUserId": "893406", "LastActivityDate": "2014-06-12T07:26:13.883", "Score": "1", "OwnerUserId": "893406", "Tags": "<c++><templates><metaprogramming>", "AnswerCount": "1"}, "24178216": {"PostTypeId": "2", "Body": "<p>U requires an argument (see its declaration)</p>\n<pre><code>template &lt; typename T2 &gt;\n    struct U\n    {\n</code></pre>\n<p>you're not passing any in the line</p>\n<pre><code>template &lt; typename T &gt;\n    struct UnaryPairMaker : Unarify&lt; MakePair, ToPlaceLeftT &gt;::U\n</code></pre>\n<p>A possible solution:</p>\n<pre><code>template &lt; typename T &gt;\n    struct UnaryPairMaker : Unarify&lt; MakePair, ToPlaceLeftT &gt;::template U&lt;T&gt;\n    {\n    };\n</code></pre>\n<p>Also note the <strong>template</strong> keyword: that is not optional if your compiler follows the standard</p>\n<blockquote>\n<p id=\"so_24178083_24178216_0\">When the name of a member template specialization appears after . or\n  -&gt; in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly\n  depends on a template-parameter (14.6.2), the member template name\n  must be prefixed by the keyword template. Otherwise the name is\n  assumed to name a non-template.</p>\n</blockquote>\n", "LastActivityDate": "2014-06-12T06:56:27.070", "Id": "24178216", "CommentCount": "3", "CreationDate": "2014-06-12T06:56:27.070", "ParentId": "24178083", "Score": "2", "OwnerUserId": "1938163"}});