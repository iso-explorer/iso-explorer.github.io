post_cb({"48865769": {"Id": "48865769", "PostTypeId": "2", "Body": "<p>The <code>Base::display</code> that you get via <code>Derived1</code>, and the <code>Base::Display</code> that you get via <code>Derived2</code>, are literally the same function. With no object context to consider (since they are static) there is no ambiguity here.</p>\n", "LastActivityDate": "2018-02-19T12:00:22.280", "Score": "3", "CreationDate": "2018-02-19T12:00:22.280", "ParentId": "48865168", "CommentCount": "0", "OwnerUserId": "560648"}, "48865314": {"Id": "48865314", "PostTypeId": "2", "Body": "<p>Yes. It's inherited because <strong>it's a class member</strong>.</p>\n<p>There's no ambiguity because all that's called with <code>obj.display()</code> is that there's only 1 candidate to be chosen, the ultimate \"source\" <code>Base::display()</code>.</p>\n<p>This code, however, generates an error:</p>\n<pre><code>class SuperBase {\n    public:\n    static void hello() { cout &lt;&lt; \"Super Base\" &lt;&lt; endl; }\n};\n\nclass Base1 : public SuperBase {\n    public:\n    static void foo() { cout &lt;&lt; \"Base 1\" &lt;&lt; endl; }\n};\n\nclass Base2 : public SuperBase {\n    public:\n    static void foo() { cout &lt;&lt; \"Base 2\" &lt;&lt; endl; }\n};\n\nclass Derived : public Base1, public Base2 {\n};\n\nDerived obj;\nobj.foo();  // Error: ambiguous resolution\nobj.hello();  // No error here\n</code></pre>\n", "LastEditorUserId": "5958455", "LastActivityDate": "2018-02-19T11:38:40.663", "Score": "2", "CreationDate": "2018-02-19T11:33:21.123", "ParentId": "48865168", "CommentCount": "0", "OwnerUserId": "5958455", "LastEditDate": "2018-02-19T11:38:40.663"}, "48865168": {"ViewCount": "838", "Body": "<p>I am just starting out with gnu-cpp and would like some help. I have come across the ambigutity error while reading and while self-study I came across this idea that static methods of a class should also be affected by the ambiguous diamond problem, but while running the following code ther is no error. Can anyone please explain why?</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nclass Base\n{\n  public:\n  static void display(){cout&lt;&lt;\"Static\";}\n};\nclass Derived1 : public Base {};\nclass Derived2 : public Base {};\nclass Child : public Derived1, Derived2 {};\nint main(void)\n{\n  Child obj;\n  obj.display();\n}\n</code></pre>\n<p>Thank You for the help and time.</p>\n", "AcceptedAnswerId": "48865340", "Title": "In C++ are static member functions inherited? If yes why ambiguity error does not arise?", "CreationDate": "2018-02-19T11:26:02.120", "LastActivityDate": "2018-02-22T07:27:17.343", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2018-02-22T07:27:17.343", "LastEditorUserId": "8608307", "Id": "48865168", "Score": "9", "OwnerUserId": "8608307", "Tags": "<c++><diamond-problem>", "AnswerCount": "3"}, "48865340": {"Id": "48865340", "PostTypeId": "2", "Body": "<p>It's fine according to the lookup rules. You see, when you write member access (<code>obj.display();</code>), the member <code>display</code> is looked up not just in the scope of the class and its base classes. Base class <em>sub-objects</em> are taken into consideration as well.</p>\n<p>If the member being looked up is <em>not</em> static, since base class sub-objects are part of the consideration, and you have two sub-objects of the same type, there's an ambiguity in the lookup.</p>\n<p>But when they <em>are</em> static, there is no ambiguity. And to make it perfectly clear, the C++ standard even has a (non-normative) example when it describes class member lookup (in the section <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.member.lookup#9\" rel=\"noreferrer\">[class.member.lookup]</a>):</p>\n<blockquote>\n<p id=\"so_48865168_48865340_0\">[\u2009Note: A static member, a nested type or an enumerator defined in a\n  base class T can unambiguously be found even if an object has more\n  than one base class subobject of type T. Two base class subobjects\n  share the non-static member subobjects of their common virtual base\n  classes. \u2009\u2014\u2009end note\u2009] [\u2009Example:</p>\n<pre><code>struct V {\n  int v;\n};\nstruct A {\n  int a;\n  static int   s;\n  enum { e };\n};\nstruct B : A, virtual V { };\nstruct C : A, virtual V { };\nstruct D : B, C { };\n\nvoid f(D* pd) {\n  pd-&gt;v++;          // OK: only one v (virtual)\n  pd-&gt;s++;          // OK: only one s (static)\n  int i = pd-&gt;e;    // OK: only one e (enumerator)\n  pd-&gt;a++;          // error, ambiguous: two as in D\n}\n</code></pre>\n<p id=\"so_48865168_48865340_1\">\u2009\u2014\u2009end example\u2009]</p>\n</blockquote>\n", "LastEditorUserId": "817643", "LastActivityDate": "2018-02-19T11:46:04.897", "Score": "12", "CreationDate": "2018-02-19T11:35:23.987", "ParentId": "48865168", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2018-02-19T11:46:04.897"}, "bq_ids": {"n4140": {"so_48865168_48865340_0": {"length": 33, "quality": 0.8918918918918919, "section_id": 6997}}, "n3337": {"so_48865168_48865340_0": {"length": 33, "quality": 0.8918918918918919, "section_id": 6743}}, "n4659": {"so_48865168_48865340_0": {"length": 33, "quality": 0.8918918918918919, "section_id": 8495}}}});