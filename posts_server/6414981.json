post_cb({"6415164": {"ParentId": "6414981", "CommentCount": "7", "Body": "<p>As mentioned, given the choice between a well-formed constructor and a conversion operator, the compiler will always call the constructor. But you could call the conversion operator directly, if you wish:</p>\n<pre><code>A a = b.operator A();\n</code></pre>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "6415164", "Score": "2", "CreationDate": "2011-06-20T17:38:10.023", "LastActivityDate": "2011-06-20T17:38:10.023"}, "6415142": {"ParentId": "6414981", "CommentCount": "2", "Body": "<p>The reason is <strong>not</strong> only because it thinks <code>(A)b</code> is same as <code>A(b)</code>. The standard says this about explicit type-conversion (5.4):</p>\n<blockquote>\n<p id=\"so_6414981_6415142_0\">The conversions performed by</p>\n<ul>\n<li><p id=\"so_6414981_6415142_1\">a const_cast (5.2.11),</p></li>\n<li><p id=\"so_6414981_6415142_2\">a static_cast (5.2.9),</p></li>\n<li><p id=\"so_6414981_6415142_3\">a static_cast followed by a const_cast,</p></li>\n<li><p id=\"so_6414981_6415142_4\">a reinterpret_cast (5.2.10), or</p></li>\n<li><p id=\"so_6414981_6415142_5\">a reinterpret_cast followed by a const_cast,</p></li>\n</ul>\n<p id=\"so_6414981_6415142_6\">can be performed using the cast\n  notation of explicit type conversion.\n  The same semantic restrictions and\n  behaviors apply.</p>\n</blockquote>\n<p>Essentially this means that even for explicit type-conversion of <code>(A)b</code> (i.e. if you used <code>((A)b);</code> to prevent from it being a variable declaration). it'd use the rules of <code>static_cast</code>. Now let's take a look at what the standard says about <code>static_cast</code> (5.2.9):</p>\n<blockquote>\n<p id=\"so_6414981_6415142_7\">An expression e can be explicitly\n  converted to a type T using a\n  static_cast of the form\n  static_cast(e) if the declaration\n  \u201cT t(e);\u201d is well-formed, for some\n  invented temporary variable t (8.5).\n  The effect of such an explicit\n  conversion is the same as performing\n  the declaration and initialization and\n  then using the temporary variable as\n  the result of the conversion. The\n  result is an lvalue if T is a\n  reference type (8.3.2), and an rvalue\n  otherwise. The expression e is used as\n  an lvalue if and only if the\n  initialization uses it as an lvalue.</p>\n</blockquote>\n<p>If you do <code>static_cast&lt;A&gt;(b)</code>, it basically sees if <code>A(b)</code> is well-formed; and <strong>it is</strong>. Just because the actual instantiation of the template function copy-constructor fails, it doesn't make the actual declaration is ill-formed, hence it uses it and ultimately fails.</p>\n", "OwnerUserId": "197368", "PostTypeId": "2", "Id": "6415142", "Score": "7", "CreationDate": "2011-06-20T17:36:10.437", "LastActivityDate": "2011-06-20T17:36:10.437"}, "6415158": {"ParentId": "6414981", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From 5.4/1 and 5.4/5 the C-cast picks the \"best choice\" C++ cast from a list. In this case, that's a <code>static_cast</code>.</p>\n<p>Then from 5.2.9/2:</p>\n<blockquote>\n<p id=\"so_6414981_6415158_0\">An expression e can be explicitly\n  converted to a type T using a\n  static_cast of the form\n  static_cast(e) if the declaration\n  \u201cT t(e);\u201d is well formed, for some\n  invented temporary variable t (8.5).\n  The effect of such an explicit\n  conversion is the same as performing\n  the declaration and initialization and\n  then using the temporary variable as\n  the result of the conversion. The\n  result is an lvalue if T is a\n  reference type (8.3.2), and an rvalue\n  otherwise. The expression e is used as\n  an lvalue if and only if the\n  initialization uses it as an lvalue.</p>\n</blockquote>\n<p>So it picks the constructor before even attempting any other option.</p>\n<p>In this case you've defined two conversions to get to the same end result, but the language has specific rules dictating that it will always use the available constructor. You should probably leave the constructor and change the operator to an explicit <code>as</code>-type function instead.</p>\n<p>EDIT for OP's edit:\nI don't think you'll be able to use the vector <code>iter, iter</code> constructor. You'll need to start with an empty vector and either use a for loop with <code>push_back</code> or use <code>std::transform</code>.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2011-06-20T17:57:02.323", "Id": "6415158", "Score": "5", "CreationDate": "2011-06-20T17:37:07.083", "LastActivityDate": "2011-06-20T17:57:02.323"}, "6415056": {"ParentId": "6414981", "CommentCount": "6", "Body": "<p>The syntax <code>(A)b</code> is the same as <code>A(b)</code>, which is a construction. If you want a cast, then you must explicitly use <code>static_cast</code>, for example.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6415056", "Score": "-2", "CreationDate": "2011-06-20T17:26:20.823", "LastActivityDate": "2011-06-20T17:26:20.823"}, "6423032": {"ParentId": "6414981", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As for the second part of your question on how to make it working, I would use <code>std::transform</code> instead of modifying/adding something in the 3rd-party library namespace, unless only this library is well documented and it is intended that you should specialize this constructor:</p>\n<pre><code>a_vector.reserve( b_vector.size() );\nstd::transform( b_vector.begin(), b_vector.end(), \n  std::back_inserter( a_vector ), boost::bind( &amp;B::operator A, _1 ) );\n</code></pre>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2011-06-21T09:32:40.843", "Id": "6423032", "Score": "1", "CreationDate": "2011-06-21T09:22:28.290", "LastActivityDate": "2011-06-21T09:32:40.843"}, "bq_ids": {"n4140": {"so_6414981_6415142_6": {"section_id": 6126, "quality": 0.9285714285714286, "length": 13}, "so_6414981_6415158_0": {"section_id": 6030, "quality": 0.6666666666666666, "length": 30}, "so_6414981_6415142_7": {"section_id": 6030, "quality": 0.7045454545454546, "length": 31}}, "n3337": {"so_6414981_6415142_6": {"section_id": 5890, "quality": 0.9285714285714286, "length": 13}, "so_6414981_6415158_0": {"section_id": 2, "quality": 0.6666666666666666, "length": 30}, "so_6414981_6415142_7": {"section_id": 2, "quality": 0.7045454545454546, "length": 31}}, "n4659": {"so_6414981_6415142_6": {"section_id": 7623, "quality": 0.9285714285714286, "length": 13}}}, "6414981": {"CommentCount": "1", "ViewCount": "1470", "PostTypeId": "1", "LastEditorUserId": "752318", "CreationDate": "2011-06-20T17:19:03.113", "LastActivityDate": "2011-06-21T09:32:40.843", "Title": "prefer conversion operator over conversion constructor", "FavoriteCount": "1", "LastEditDate": "2011-06-20T18:02:57.113", "Id": "6414981", "Score": "9", "Body": "<p>I have the following code snippet:</p>\n<pre><code>class A\n{\npublic:\n  A() : x_(0), y_(0) {}\n\n  A(int x, int y) : x_(x), y_(y) {}\n\n  template&lt;class T&gt;\n  A(const T &amp;rhs) : x_(rhs.x_), y_(rhs.y_)\n  {\n  }\n\n  int x_, y_;\n};\n\nclass B\n{\npublic:\n  B() {}\n\n  operator A() const { return A(c[0],c[1]); }\n  int c[2];\n};\n\nvoid f()\n{\n  B b;\n  (A)b; // &lt;&lt; here the error appears, compiler tries to use \n        //         template&lt;class T&gt; A(const T &amp;rhs)\n}\n</code></pre>\n<p>Why compiler uses <code>A</code>'s constructor? How can I make it use <code>B</code>'s conversion operator to <code>A</code>?</p>\n<p>I use MSVS2010 compiler. It gives me these errors:</p>\n<pre><code>main.cpp(9): error C2039: 'x_' : is not a member of 'B'\n          main.cpp(17) : see declaration of 'B'\n          main.cpp(28) : see reference to function template instantiation 'A::A&lt;B&gt;(const T &amp;)' being compiled\n          with\n          [\n              T=B\n          ]\nmain.cpp(9): error C2039: 'y_' : is not a member of 'B'\n          main.cpp(17) : see declaration of 'B'\n</code></pre>\n<p><strong>UPD</strong>:\nAll right, implicit convert as Nawaz said really works. Let's make it more complicated, how make the following code work?</p>\n<pre><code>void f()\n{\n  std::vector&lt;B&gt; b_vector(4);\n  std::vector&lt;A&gt; a_vector( b_vector.begin(), b_vector.end() );\n}\n</code></pre>\n<p><strong>UPD</strong>: <code>A</code> is the class in 3rd party lib which code I can't edit, so I can't remove <code>A</code>'s converting constructor.</p>\n<p><strong>UPD</strong>: the simplest solution I've found for the moment is to define specialization of converting constructor for <code>B</code>. It can be done outside of 3rd party lib:</p>\n<pre><code>template&lt;&gt; A::A( const B &amp;rhs ) : x_(rhs.c[0]), y_(rhs.c[1]) {}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "752318", "AnswerCount": "6"}, "6415024": {"ParentId": "6414981", "PostTypeId": "2", "CommentCount": "5", "Body": "<pre><code>(A)b; // &lt;&lt; here the error appears, compiler tries to use \n</code></pre>\n<p>This is <em>explicit</em>  casting to <code>A</code>. Hence the constructor of <code>A</code> gets invoked to convert <code>b</code> to <code>A</code>.</p>\n<pre><code>A a(1,2);\na = b ; //this will invoke user-defined conversion of B (implicit conversion)\n</code></pre>\n<p>Demo : <a href=\"http://www.ideone.com/K9IxT\" rel=\"nofollow\">http://www.ideone.com/K9IxT</a></p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-06-20T17:41:48.277", "Id": "6415024", "Score": "3", "CreationDate": "2011-06-20T17:22:58.707", "LastActivityDate": "2011-06-20T17:41:48.277"}});