post_cb({"27227781": {"Id": "27227781", "PostTypeId": "2", "Body": "<p>After some research, I have found the answer myself and want to provide it.</p>\n<p>For the first issue (using <code>Allocator::rebind&lt;T&gt;::other::construct</code> instead of <code>Allocator::construct</code>), my first allocator implementation (second one is OK) doesn't satisfy <code>Allocator</code> requirements in part of <code>rebind</code>, see 17.6.3.5 Table 28:</p>\n<blockquote id=\"so_26852381_27227781_0\">\n<pre>\n+------------------+-------------+-------------------------------------+\n|    Expression    | Return type | Assertion/note pre-/post- condition |\n+------------------+-------------+-------------------------------------+\n| typename         | Y           | For all U (including T),            |\n| X::template      |             | Y::template rebind&lt;T&gt;::other is X.  |\n| rebind&lt;U&gt;::other |             |                                     |\n+------------------+-------------+-------------------------------------+\n</pre>\n</blockquote>\n<p>For the second issue: GCC has old, pre-C++11 implementation of std::list, which will be fixed only in GCC 5.0, because this change breaks ABI (see <a href=\"https://stackoverflow.com/questions/19154205/should-stdlistsize-have-constant-complexity-in-c11\">Should std::list::size have constant complexity in C++11?</a> for more info)</p>\n<p>However, the quoted standard requirement, that container must call <code>construct</code> function for <strong>exactly</strong> <code>allocator_type</code> and not for some rebinded type seems like a standard defect (<a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2218\" rel=\"nofollow noreferrer\">http://cplusplus.github.io/LWG/lwg-active.html#2218</a>). Libstdc++ implementations of <code>std::set</code>, <code>multiset</code>, <code>map</code> and <code>multimap</code> rely on this fact and use rebinded allocator for construct (<a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64096\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64096</a>).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-01T11:49:06.440", "Score": "0", "CreationDate": "2014-12-01T11:49:06.440", "ParentId": "26852381", "CommentCount": "0", "OwnerUserId": "4140624", "LastEditDate": "2017-05-23T12:27:28.057"}, "26852381": {"ViewCount": "372", "Body": "<p>In 23.2.1p3 C++11 Standart we can read:</p>\n<blockquote>\n<p id=\"so_26852381_26852381_0\">For the components affected by this subclause that declare an <code>allocator_type</code>, objects stored in these components shall be constructed using the <code>allocator_traits&lt;allocator_type&gt;::construct</code> function and destroyed using the <code>allocator_traits&lt;allocator_type&gt;::destroy</code> function (20.6.8.2). These functions are called only for the container\u2019s element type, not for internal types used by the container. [ <em>Note</em>: This means, for example, that a node-based container might need to construct nodes containing aligned buffers and call <code>construct</code> to place the element into the buffer. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p><br/>\n<code>allocator_traits&lt;allocator_type&gt;::construct</code> just call passed allocator's <code>construct</code> method, if allocator defines one. I tried to use this and create allocator, which use list-initialization for construction, so I can utilize <code>emplace</code> for aggregate initialization:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\ntemplate&lt;typename T&gt;\nstruct init_list_allocator : public std::allocator&lt;T&gt; {\n    template&lt;typename... Args&gt;\n    void construct(T* p, Args&amp;&amp;... args)\n        { ::new((void *)p) T{std::forward&lt;Args&gt;(args)...}; }\n\n    // Fix copy-constructors usage for aggregates\n    void construct(T* p, T&amp; copy_construct_arg)\n        { std::allocator&lt;T&gt;::construct(p, copy_construct_arg); }\n\n    void construct(T* p, const T&amp; copy_construct_arg)\n        { std::allocator&lt;T&gt;::construct(p, copy_construct_arg); }\n\n    void construct(T* p, const T&amp;&amp; copy_construct_arg)\n        { std::allocator&lt;T&gt;::construct(p, std::move(copy_construct_arg)); }\n\n    void construct(T *p, T&amp;&amp; move_construct_arg)\n        { std::allocator&lt;T&gt;::construct(p, std::move(move_construct_arg)); }\n};\n\ntemplate&lt;class T&gt;\nusing improved_vector = std::vector&lt;T, init_list_allocator&lt;T&gt;&gt;;\n\nstruct A {\n    int x;\n    double y;\n    const char* z;\n};\n\nint main()\n{\n    using namespace std;\n    vector&lt;string&gt; strings;\n    improved_vector&lt;A&gt; v;\n    for (int i = 0; i &lt; 21; ++i) {\n        strings.emplace_back(to_string(i*i));\n        v.emplace_back(i, sqrt(i), strings.back().c_str());\n    };\n    for (const auto&amp; elem : v)\n        cout &lt;&lt; elem.x &lt;&lt; ' ' &lt;&lt; elem.y &lt;&lt; ' ' &lt;&lt; elem.z &lt;&lt; '\\n';\n}\n</code></pre>\n<p><br/>\nHowever, at least in gcc and clang, this doesn't work. The problem is, that their implementations of <code>vector</code> use <code>Allocator::rebind&lt;T&gt;::other::construct</code> instead of <code>Allocator::construct</code>. And, because of our inheritance from <code>std::allocator</code>, this <code>rebind</code> gives <code>std::allocator&lt;T&gt;::construct</code>. Ok, no problem, just add</p>\n<pre><code>template&lt;typename U&gt;\nstruct rebind {\n    using other = init_list_allocator&lt;U&gt;;\n};\n</code></pre>\n<p>in our allocator's definition and this code will work. Great, now let's change <code>vector</code> to <code>list</code>. Here we have the unsolvable problem, because instead of <code>Allocator::construct</code> object is initialized inside <code>std::_List_node&lt;_Tp&gt;</code> constuctor in direct-initialization form (form with brackets).</p>\n<p>Are this 2 issues a standard violations or I miss something?</p>\n", "AcceptedAnswerId": "27227781", "Title": "Do gcc and clang STL implementations violate rules about allocator?", "CreationDate": "2014-11-10T20:24:15.860", "Id": "26852381", "CommentCount": "4", "LastEditDate": "2014-11-10T20:55:21.673", "PostTypeId": "1", "LastEditorUserId": "4140624", "LastActivityDate": "2014-12-01T11:49:06.440", "Score": "2", "OwnerUserId": "4140624", "Tags": "<c++><gcc><clang>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26852381_26852381_0": {"length": 41, "quality": 0.8541666666666666, "section_id": 704}, "so_26852381_26852607_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 704}}, "n3337": {"so_26852381_26852381_0": {"length": 41, "quality": 0.8541666666666666, "section_id": 694}, "so_26852381_26852607_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 694}}, "n4659": {"so_26852381_26852381_0": {"length": 39, "quality": 0.8125, "section_id": 733}, "so_26852381_26852607_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 733}}}, "26852607": {"Id": "26852607", "PostTypeId": "2", "Body": "<p>To my understanding, libstdc++ and MSVC++ are correct here. The point of <code>rebind</code> is, as the note indicates, that containers may be required to construct things that are not <code>T</code>. For example, <code>std::list&lt;T&gt;</code> needs to construct a list node containing <code>T</code>, not <code>T</code>. Similar cases exist for the associative and unordered containers. That's why the <code>rebind</code> structure exists in the first place. Your allocator was nonconforming before that was in place.</p>\n<hr>\n<p>For the second issue, your reference</p>\n<blockquote>\n<p id=\"so_26852381_26852607_0\">These functions are called only for the container\u2019s element type, not for internal types used by the container.</p>\n</blockquote>\n<p>seems to indicate that standard library implementations aren't allowed to call <code>construct</code> for rebound allocators, however. This may be a bug in libstdc++.</p>\n<hr>\n<p>As for the actual solution to this problem, give <code>A</code> a constructor that has the behavior you want, and don't bother with allocators for this purpose. People may want to create instances of <code>A</code> outside of a container with the special allocator:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct A {\n    int x;\n    double y;\n    const char* z;\n    A() = default; // This allows A to still be a POD because the default constructor\n                   // is not \"user-provided\", see 8.4.2 [dcl.fct.def.default]/4\n    A(int x_, double y_, char const* z_) : x(x_), y(y_), z(z_) {}\n\n};\n\nint main()\n{\n    using namespace std;\n    vector&lt;string&gt; strings;\n    vector&lt;A&gt; v;\n    for (int i = 0; i &lt; 21; ++i) {\n        strings.emplace_back(to_string(i*i));\n        v.emplace_back(i, sqrt(i), strings.back().c_str());\n    };\n    for (const auto&amp; elem : v)\n        cout &lt;&lt; elem.x &lt;&lt; ' ' &lt;&lt; elem.y &lt;&lt; ' ' &lt;&lt; elem.z &lt;&lt; '\\n';\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "82320", "LastActivityDate": "2014-11-10T21:12:52.590", "Score": "1", "CreationDate": "2014-11-10T20:40:49.160", "ParentId": "26852381", "CommentCount": "3", "OwnerUserId": "82320", "LastEditDate": "2014-11-10T21:12:52.590"}});