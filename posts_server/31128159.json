post_cb({"31128268": {"ParentId": "31128159", "PostTypeId": "2", "CommentCount": "5", "Body": "\n<p>[temp.expl.spec]/p15 prohibits explicit specializating a member template without explicitly specializing each enclosing template as well:</p>\n<blockquote>\n<p id=\"so_31128159_31128268_0\">A member or a member template may be nested within many enclosing class templates. In an explicit specialization for such a member, the member declaration shall be preceded by a <code>template&lt;&gt;</code> for each enclosing class template that is explicitly specialized. <em>[ Example:</em></p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;class T1&gt; class A {\n    template&lt;class T2&gt; class B {\n        void mf();\n    };\n};\ntemplate&lt;&gt; template&lt;&gt; class A&lt;int&gt;::B&lt;double&gt;;\ntemplate&lt;&gt; template&lt;&gt; void A&lt;char&gt;::B&lt;char&gt;::mf();\n</code></pre>\n<p id=\"so_31128159_31128268_1\"><em>\u2014 end example ]</em></p>\n</blockquote>\n<p>For example, this code compiles:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template &lt;&gt;\ntemplate &lt;&gt;\nstruct A&lt;&gt;::B&lt;&gt; {\n    static void execute() {}  // End of recursion\n};\n</code></pre>\n<p>But it does not allow you to use the template parameters from the enclosing class template. A better way to do this would be to use a pack expansion \"trick\" in the primary template:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template &lt;typename... Ts&gt;\ntemplate &lt;typename... Args&gt;\nstruct A&lt;Ts...&gt;::B {\n    static void execute() {\n        using unpack = int[];\n        (void)unpack{((std::cout &lt;&lt; typeid(Args).name() &lt;&lt; ' '), 0)...};\n    }\n};\n</code></pre>\n", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2015-06-30T02:00:17.810", "Id": "31128268", "Score": "2", "CreationDate": "2015-06-30T01:48:13.087", "LastActivityDate": "2015-06-30T02:00:17.810"}, "31128159": {"CommentCount": "0", "ViewCount": "133", "PostTypeId": "1", "LastEditorUserId": "3089350", "CreationDate": "2015-06-30T01:34:58.513", "LastActivityDate": "2015-06-30T02:00:35.153", "Title": "End of recursion specialization of inner template class", "AcceptedAnswerId": "31128268", "LastEditDate": "2015-06-30T02:00:35.153", "Id": "31128159", "Score": "0", "Body": "<p>Consider this working code: </p>\n<pre><code>#include &lt;typeinfo&gt;\n\ntemplate &lt;typename ...&gt; struct A;\n\ntemplate &lt;typename First, typename... Rest&gt;\nstruct A&lt;First, Rest...&gt; {\n    static void execute() {\n        std::cout &lt;&lt; typeid(First).name() &lt;&lt; ' ';\n        A&lt;Rest...&gt;::execute();\n    }\n};\n\ntemplate &lt;&gt;\nstruct A&lt;&gt; {\n    static void execute() {}  // End of recursion.\n};\n\nint main() {\n    A&lt;char, bool, int&gt;::execute();  // char bool int\n}\n</code></pre>\n<p>So why does the end of recursion below not compile (error statements provided in comments):</p>\n<pre><code>#include &lt;typeinfo&gt;\n\ntemplate &lt;typename ...&gt; struct A;\n\ntemplate &lt;typename... Ts&gt;\nstruct A {\n    template &lt;typename...&gt; struct B;\n    template &lt;typename...&gt; static void execute();\n};\n\ntemplate &lt;typename... Ts&gt;\ntemplate &lt;typename First, typename... Rest&gt;\nstruct A&lt;Ts...&gt;::B&lt;First, Rest...&gt; {\n    static void execute() {\n        std::cout &lt;&lt; typeid(First).name() &lt;&lt; ' ';\n        B&lt;Rest...&gt;::execute();\n    }\n};\n\ntemplate &lt;typename... Ts&gt;\ntemplate &lt;&gt; // invalid explicit specialization before '&gt;' token\nstruct A&lt;Ts...&gt;::B&lt;&gt; {  // template parameters not used in partial specialization: Ts\n    static void execute() {}  // End of recursion\n};\n\ntemplate &lt;typename... Ts&gt;\ntemplate &lt;typename... Us&gt;\nvoid A&lt;Ts...&gt;::execute() {\n    B&lt;Ts..., Us...&gt;::execute();\n}\n\nint main() {\n    A&lt;char, bool, int&gt;::execute&lt;double, short, float&gt;();\n}\n</code></pre>\n<p>It does work when I use this end of recursion instead of above:</p>\n<pre><code>template &lt;typename... Ts&gt;\ntemplate &lt;typename Last&gt;\nstruct A&lt;Ts...&gt;::B&lt;Last&gt; {\n    static void execute() {std::cout &lt;&lt; typeid(Last).name();}\n};\n</code></pre>\n<p>But I just want to know what's wrong with the original attempt.  Furthermore, I have to repeat the body of the execute() function using this second way (which of course leads to more maintenance responsibilities).</p>\n<p>GCC 4.9.2 states that <code>A&lt;char, bool, int&gt;::B&lt;&gt;</code> is an incomplete type.  But I defined it.</p>\n", "Tags": "<c++><templates><c++11><specialization>", "OwnerUserId": "3089350", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31128159_31128268_0": {"section_id": 277, "quality": 0.96, "length": 24}}, "n3337": {"so_31128159_31128268_0": {"section_id": 268, "quality": 0.96, "length": 24}}, "n4659": {"so_31128159_31128268_0": {"section_id": 284, "quality": 0.96, "length": 24}}}});