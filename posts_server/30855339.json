post_cb({"30855547": {"Id": "30855547", "PostTypeId": "2", "Body": "<p>In your failing example, the template parameter <code>VectorType</code> has already been determined by the time get is being resolved.  To make SFINAE work, you need to make the template parameters you are using for SFINAE resolve at that method call.  The following is a modification of your first example to work like you want to:</p>\n<pre><code>template&lt;int I&gt; struct rank : rank&lt;I-1&gt; { static_assert(I &gt; 0, \"\"); };\ntemplate&lt;&gt; struct rank&lt;0&gt; {};\n\ntemplate&lt;typename VectorType&gt;\nstruct VectorWrapper\n{\n    auto get(int i) const\n    {\n        return get(v, i, rank&lt;5&gt;());\n    }\n\n    template&lt;typename V=VectorType, typename = std::enable_if_t&lt;has_bracket_operator&lt;const V&gt;::value&gt; &gt;\n    auto get(int i, rank&lt;2&gt;) const\n    {\n        return v[i];\n    }\n\n    template&lt;typename V=VectorType, typename = std::enable_if_t&lt;has_parenthesis_operator&lt;const V&gt;::value&gt; &gt;\n    auto get(int i, rank&lt;1&gt;) const\n    {\n        return v(i);\n    }\n\n    VectorType v;\n};\n</code></pre>\n<p>This way, <code>V</code> is resolved when <code>get</code> is called, and it will correctly use SFINAE.</p>\n", "LastEditorUserId": "823682", "LastActivityDate": "2015-06-15T22:54:34.747", "Score": "4", "CreationDate": "2015-06-15T21:49:34.300", "ParentId": "30855339", "CommentCount": "1", "OwnerUserId": "823682", "LastEditDate": "2015-06-15T22:54:34.747"}, "30855339": {"ViewCount": "486", "Body": "<p>I'm using SFINAE in the style of <a href=\"https://stackoverflow.com/a/30767152/2412846\">this answer</a> in order to call a generic vector object by using an appropriate member function. For example, the following code calls <code>operator[](int) const</code> first, and if that doesn't exist then <code>operator()(int) const</code>:</p>\n<pre><code>template&lt;int I&gt; struct rank : rank&lt;I-1&gt; { static_assert(I &gt; 0, \"\"); };\ntemplate&lt;&gt; struct rank&lt;0&gt; {};\n\ntemplate&lt;typename VectorType&gt;\nstruct VectorWrapper\n{\n    auto get(int i) const\n    {\n        return get(v, i, rank&lt;5&gt;());\n    }\n\n    template&lt;typename V, typename = std::enable_if_t&lt;has_bracket_operator&lt;const V&gt;::value&gt; &gt;\n    auto get(V const&amp; v, int i, rank&lt;2&gt;) const\n    {\n        return v[i];\n    }\n\n    template&lt;typename V, typename = std::enable_if_t&lt;has_parenthesis_operator&lt;const V&gt;::value&gt; &gt;\n    auto get(V const&amp; v, int i, rank&lt;1&gt;) const\n    {\n        return v(i);\n    }\n\n    VectorType v;\n};\n</code></pre>\n<p>With the <code>has_bracket_operator</code> and <code>has_parenthesis_operator</code> traits set up as suggested in <a href=\"https://stackoverflow.com/questions/26366205/using-void-t-to-check-if-a-class-has-a-method-with-a-specific-signature\">this thread</a>, the whole compiles and <a href=\"http://coliru.stacked-crooked.com/a/d0bdd6f850209000\" rel=\"nofollow noreferrer\">seems to work</a>. </p>\n<p>However, passing the member vector to the overloaded class templates seems unnecessary from the first, so I tried to set up the same without passing it. For this, I replaced the template parameter <code>V</code> with the <code>VectorType</code> parameter used to set up the class template:</p>\n<pre><code>    template&lt;typename = std::enable_if_t&lt;has_bracket_operator&lt;VectorType&gt;::value&gt; &gt;\n    auto get(int i, rank&lt;2&gt;) const\n    {\n        return v[i];\n    }\n\n    template&lt;typename = std::enable_if_t&lt;has_parenthesis_operator&lt;VectorType&gt;::value&gt; &gt;\n    auto get(int i, rank&lt;1&gt;) const\n    {\n        return v(i);\n    }\n</code></pre>\n<p>Now, however, the compilation fails (in gcc 5.1.0) with the following error message:</p>\n<pre><code>/usr/local/include/c++/5.1.0/type_traits: In substitution of 'template&lt;bool _Cond, class _Tp&gt; using enable_if_t = typename std::enable_if::type [with bool _Cond = has_parenthesis_operator&lt;std::vector&lt;int&gt; &gt;::value; _Tp = void]':\nmain.cpp:46:10:   required from 'struct VectorWrapper&lt;std::vector&lt;int&gt; &gt;'\nmain.cpp:59:38:   required from here\n/usr/local/include/c++/5.1.0/type_traits:2388:61: error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'\n     using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f1b574b26c7a5e30\" rel=\"nofollow noreferrer\">DEMO</a></p>\n<p><strong>Questions:</strong></p>\n<ul>\n<li>What is the reason for this compilation error?</li>\n<li>Is there an appropriate workaround other than that of my first code block? (That is, one that retains the usual coding style -- where one does not have to pass members).</li>\n</ul>\n", "AcceptedAnswerId": "30855588", "Title": "C++ why does SFINAE fail with only a class template parameter?", "CreationDate": "2015-06-15T21:34:12.183", "Id": "30855339", "CommentCount": "0", "LastEditDate": "2017-05-23T12:29:50.037", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-15T22:54:34.747", "Score": "7", "OwnerUserId": "2412846", "Tags": "<c++><templates><c++11><sfinae>", "AnswerCount": "3"}, "30855588": {"Id": "30855588", "PostTypeId": "2", "Body": "<p>SFINAE comes to us from [temp.deduct]/8, emphasis mine:</p>\n<blockquote>\n<p id=\"so_30855339_30855588_0\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is\n  one that would be ill-formed, with a diagnostic required, if written using the substituted arguments. [ Note:\n  If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution\n  process. \u2014end note ] <strong>Only invalid types and expressions in the immediate context</strong> of the function type and\n  its template parameter types can result in a deduction failure.</p>\n</blockquote>\n<p>The immediate context is what's in the template declaration. In your initial example:</p>\n<pre><code>template&lt;typename V, typename = std::enable_if_t&lt;has_bracket_operator&lt;const V&gt;::value&gt; &gt;\nauto get(V const&amp; v, int i, rank&lt;2&gt;) const\n</code></pre>\n<p><code>V</code> is in the immediate context, so a substitution failure on the <code>enable_if</code> is just a deduction failure. </p>\n<p>However, in your second example:</p>\n<pre><code>template&lt;typename = std::enable_if_t&lt;has_bracket_operator&lt;VectorType&gt;::value&gt; &gt;\nauto get(int i, rank&lt;2&gt;) const\n</code></pre>\n<p><code>VectorType</code> is not in the immediate context of <code>get</code>, so a failure here would not be a deduction failure, it would be a hard error. </p>\n<p>Unless <code>VectorType</code> happens to have all of these operators.</p>\n<p>The solution to any template problem is to just add more template. In this case, force <code>VectorType</code> to be in the immediate context by introducing another type:</p>\n<pre><code>template&lt;typename T=VectorType, typename = std::enable_if_t&lt;has_bracket_operator&lt;T&gt;::value&gt; &gt;\nauto get(int i, rank&lt;2&gt;) const\n</code></pre>\n<p>And call <code>get&lt;&gt;()</code>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-06-15T22:37:33.687", "Score": "3", "CreationDate": "2015-06-15T21:51:21.223", "ParentId": "30855339", "CommentCount": "3", "OwnerUserId": "2069064", "LastEditDate": "2015-06-15T22:37:33.687"}, "bq_ids": {"n4140": {"so_30855339_30855588_0": {"length": 45, "quality": 0.9183673469387755, "section_id": 300}}, "n3337": {"so_30855339_30855588_0": {"length": 39, "quality": 0.7959183673469388, "section_id": 291}}, "n4659": {"so_30855339_30855588_0": {"length": 45, "quality": 0.9183673469387755, "section_id": 307}}}, "30855624": {"Id": "30855624", "PostTypeId": "2", "Body": "<p>Or you can just use <em>tag-dispatching</em>:</p>\n<pre><code>auto get(int i) const\n{\n    return get(i, has_bracket_operator&lt;VectorType&gt;(), has_parenthesis_operator&lt;VectorType&gt;());\n}\n\nauto get(int i, std::true_type /*brackets*/, std::false_type /*parenthesis*/) const\n{\n    return v[i];\n}\n\nauto get(int i, std::false_type /*brackets*/, std::true_type /*parenthesis*/) const\n{\n    return v(i);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/deed3260cdbe45dd\" rel=\"nofollow\">demo</a></p>\n", "LastActivityDate": "2015-06-15T21:54:33.737", "CommentCount": "5", "CreationDate": "2015-06-15T21:54:33.737", "ParentId": "30855339", "Score": "3", "OwnerUserId": "2451677"}});