post_cb({"15244094": {"ViewCount": "32807", "Body": "<p>Can we overload <code>operator++</code> for pre-increment and post-increment?  i.e. calling <code>SampleObject++</code> and <code>++SampleObject</code> results correctly.</p>\n<pre><code>class CSample {\n public:\n   int m_iValue;     // just to directly fetch inside main()\n   CSample() : m_iValue(0) {}\n   CSample(int val) : m_iValue(val) {}\n   // Overloading ++ for Pre-Increment\n   int /*CSample&amp; */ operator++() { // can also adopt to return CSample&amp;\n      ++(*this).m_iValue;\n      return m_iValue; /*(*this); */\n   }\n\n  // Overloading ++ for Post-Increment\n /* int operator++() {\n        CSample temp = *this;\n        ++(*this).m_iValue;\n        return temp.m_iValue; /* temp; */\n    } */\n};\n</code></pre>\n<p>We can't overload a function based only on return type, and also even if we take it as permitted, it doesn't solve the problem because of the ambiguity in call resolution.</p>\n<p>Since operator overloading is provided to make built-in types behave like as user-defined types, why we can't avail both pre and post increment for our own types at the same time.</p>\n", "Title": "C++: overloading ++ for both pre and post increment", "CreationDate": "2013-03-06T09:58:53.727", "LastActivityDate": "2017-11-25T07:08:42.473", "CommentCount": "4", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2015-09-04T05:40:09.557", "LastEditorUserId": "224132", "Id": "15244094", "Score": "26", "OwnerUserId": "1999454", "Tags": "<c++><operator-overloading>", "AnswerCount": "4"}, "15247402": {"Id": "15247402", "PostTypeId": "2", "Body": "<p>The standard pattern for pre-increment and post-increment for type T</p>\n<pre><code>T&amp; T::operator++() // pre-increment, return *this by reference\n{\n // perform operation\n\n\n return *this;\n}\n\nT T::operator++(int) // post-increment, return unmodified copy by value\n{\n     T copy(*this);\n     ++(*this); // or operator++();\n     return copy;\n}\n</code></pre>\n<p>(You can also call a common function for performing the increment, or if it's a simple one-liner like ++ on a member, just do it in both)</p>\n", "LastEditorUserId": "442284", "LastActivityDate": "2013-03-07T10:43:09.283", "Score": "10", "CreationDate": "2013-03-06T12:29:10.133", "ParentId": "15244094", "CommentCount": "0", "LastEditDate": "2013-03-07T10:43:09.283", "OwnerUserId": "442284"}, "bq_ids": {"n4140": {"so_15244094_47483493_0": {"length": 57, "quality": 0.9661016949152542, "section_id": 665}}, "n3337": {"so_15244094_47483493_0": {"length": 55, "quality": 0.9322033898305084, "section_id": 655}}, "n4659": {"so_15244094_47483493_0": {"length": 57, "quality": 0.9661016949152542, "section_id": 693}}}, "15244264": {"Id": "15244264", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15244094_15244264_0\">why we can't avail both pre and post increment for our own types at the same time.</p>\n</blockquote>\n<p>You can:</p>\n<pre><code>class CSample {\npublic:\n\n     int m_iValue;\n     CSample() : m_iValue(0) {}\n     CSample(int val) : m_iValue(val) {}\n\n     // Overloading ++ for Pre-Increment\n     int /*CSample&amp; */ operator++() {\n        ++m_iValue;\n        return m_iValue;\n     }\n\n    // Overloading ++ for Post-Increment\n    int operator++(int) {\n          int value = m_iValue;\n          ++m_iValue;\n          return value;\n      }\n  };\n\n  #include &lt;iostream&gt;\n\n  int main()\n  {\n      CSample s;\n      int i = ++s;\n      std::cout &lt;&lt; i &lt;&lt; std::endl; // Prints 1\n      int j = s++;\n      std::cout &lt;&lt; j &lt;&lt; std::endl; // Prints 1\n  }\n</code></pre>\n", "LastActivityDate": "2013-03-06T10:06:06.163", "Score": "10", "CreationDate": "2013-03-06T10:06:06.163", "ParentId": "15244094", "CommentCount": "0", "OwnerUserId": "1932150"}, "47483493": {"Id": "47483493", "PostTypeId": "2", "Body": "<p><strong>[N4687]</strong></p>\n<h3>16.5.7</h3>\n<blockquote>\n<p id=\"so_15244094_47483493_0\">The user-defined function called operator++ implements the prefix and postfix ++ operator. If this function is a non-static member function with no parameters, or a non-member function with one parameter, it defines the prefix increment operator++ for objects of that type. If the function is a non-static member function with one parameter (which shall be of type int) or a non-member function with two parameters (the second of which shall be of type int), it defines the postfix increment operator ++ for objects of that type. When the postfix increment is called as a result of using the ++ operator, the int argument will have value zero\n  <em>[Example:</em></p>\n</blockquote>\n<pre><code>struct X {\nX&amp;   operator++(); // prefix ++a\nX    operator++(int); // postfix a++\n};\nstruct Y { };\nY&amp;   operator++(Y&amp;); // prefix ++b\nY    operator++(Y&amp;, int); // postfix b++\nvoid f(X a, Y b) {\n++a;   // a.operator++();\na++; // a.operator++(0);\n++b; // operator++(b);\nb++; // operator++(b, 0);\na.operator++();     // explicit call: like ++a;\na.operator++(0);    // explicit call: like a++;\noperator++(b);    // explicit call: like   ++b;\noperator++(b, 0);    // explicit call: like b++;\n}\n</code></pre>\n", "LastActivityDate": "2017-11-25T07:08:42.473", "Score": "0", "CreationDate": "2017-11-25T07:08:42.473", "ParentId": "15244094", "CommentCount": "0", "OwnerUserId": "6949852"}, "15244185": {"Id": "15244185", "PostTypeId": "2", "Body": "<p>The postfix version of the increment operator takes a dummy <code>int</code> parameter in order to disambiguate:</p>\n<pre><code>// prefix\nCSample&amp; operator++()\n{\n  // implement increment logic on this instance, return reference to it.\n  return *this;\n}\n\n// postfix\nCSample operator++(int)\n{\n  CSample tmp(*this);\n  operator++(); // prefix-increment this instance\n  return tmp;   // return value before increment\n}\n</code></pre>\n", "LastEditorUserId": "661519", "LastActivityDate": "2013-03-06T13:05:51.783", "Score": "48", "CreationDate": "2013-03-06T10:02:44.200", "ParentId": "15244094", "CommentCount": "5", "LastEditDate": "2013-03-06T13:05:51.783", "OwnerUserId": "661519"}});