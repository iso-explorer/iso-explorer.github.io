post_cb({"19528691": {"CommentCount": "0", "ViewCount": "430", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2013-10-22T21:27:28.453", "LastActivityDate": "2013-10-23T00:17:22.427", "Title": "Why do the std smart pointer type destructors not inherit the noexcept dtor status of the pointed to object", "AcceptedAnswerId": "19528917", "LastEditDate": "2013-10-23T00:17:22.427", "Id": "19528691", "Score": "6", "Body": "<p>In C++11, my understanding is that by default destructors are implicitly <code>noexcept(true)</code>, except that:</p>\n<p>If I have a class <code>C</code> that has a destructor explicitly marked <code>noexcept(false)</code> (presumably because it throws for some odd reason, and I'm aware that you shouldn't, and why) then the destructor of any class that derives from <code>C</code> or contains a member of type <code>C</code> also becomes <code>noexcept(false)</code>.</p>\n<p>However, a class which contains a <code>std::shared_ptr&lt;C&gt;</code> apparently does not automatically have its destructor toggled to <code>noexcept(false)</code>, and the same is true for containing a <code>std::weak_ptr&lt;C&gt;</code>, <code>std::unique_ptr&lt;C&gt;</code>, etc.</p>\n<p>Here is a complete example:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;memory&gt;\n\nstruct Normal {\n    ~Normal() {\n    }\n};\n\nstruct ThrowsInDtor {\n    ~ThrowsInDtor() noexcept(false) {\n        throw 42;\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct Wrapper {\n    T t;\n};\n\ntemplate&lt;typename T&gt;\nstruct UniquePtrWrapper {\n    std::unique_ptr&lt;T&gt; t;\n};\n\ntemplate&lt;typename T&gt;\nstruct SharedPtrWrapper {\n    std::shared_ptr&lt;T&gt; t;\n};\n\nstatic_assert(std::is_nothrow_destructible&lt;Normal&gt;::value, \"A\"); // OK\nstatic_assert(!std::is_nothrow_destructible&lt;ThrowsInDtor&gt;::value, \"B\"); // OK\n\nstatic_assert(std::is_nothrow_destructible&lt;Wrapper&lt;Normal&gt;&gt;::value, \"C\"); // OK\nstatic_assert(!std::is_nothrow_destructible&lt;Wrapper&lt;ThrowsInDtor&gt;&gt;::value, \"D\"); // OK\n\nstatic_assert(std::is_nothrow_destructible&lt;UniquePtrWrapper&lt;Normal&gt;&gt;::value, \"E\"); // OK\nstatic_assert(!std::is_nothrow_destructible&lt;UniquePtrWrapper&lt;ThrowsInDtor&gt;&gt;::value, \"F\"); // FAILS\n\nstatic_assert(std::is_nothrow_destructible&lt;SharedPtrWrapper&lt;Normal&gt;&gt;::value, \"G\"); // OK\nstatic_assert(!std::is_nothrow_destructible&lt;SharedPtrWrapper&lt;ThrowsInDtor&gt;&gt;::value, \"H\"); // FAILS\n</code></pre>\n<p>It seems odd to me that F and H fail. I had expected that the noexcept status of the destructor of the owned/referenced type would propagate to the smart pointer destructor, presumably by way of a noexcept expression like <code>noexcept(std::is_nothrow_destructible&lt;T&gt;::value)</code> on the smart pointer destructor declaration.</p>\n<p>However the standard makes no mention of this, and the standard library code I've looked at doesn't do this.</p>\n<p>Does anyone know why it is that the standard smart pointers don't propagate the noexcept destructor status of the instantiating type to the smart pointer destructor?</p>\n", "Tags": "<c++><c++11><destructor><smart-pointers><noexcept>", "OwnerUserId": "776473", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19528691_19528917_1": {"section_id": 4318, "quality": 0.7368421052631579, "length": 14}}, "n3337": {"so_19528691_19528917_1": {"section_id": 4159, "quality": 0.7368421052631579, "length": 14}}, "n4659": {"so_19528691_19528917_1": {"section_id": 5575, "quality": 0.7368421052631579, "length": 14}}}, "19528917": {"ParentId": "19528691", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2013-10-22T21:41:52.893", "Score": "6", "LastEditorUserId": "2073257", "LastEditDate": "2013-10-22T23:59:26.647", "Id": "19528917", "OwnerUserId": "2073257", "Body": "<p><code>std::shared_ptr&lt;T&gt;</code> is designed to be usable with an incomplete <code>T</code>, hence there is no way to get the information you are asking for when declaring its destructor. Also, you can do this:</p>\n<pre><code>std::shared_ptr&lt;void&gt; dummy = std::make_shared&lt;T&gt;(); // for some complete T\n</code></pre>\n<p>Now what should <code>noexcept</code> say for <code>std::shared_ptr&lt;void&gt;</code>? It's a run-time-information from <code>std::shared_ptr</code>'s POV.</p>\n<p>For <code>std::unique_ptr</code>, there is</p>\n<blockquote>\n<h3>20.7.1.2.2 unique_ptr destructor [unique.ptr.single.dtor]</h3>\n<p id=\"so_19528691_19528917_0\"><sup>1</sup> <code>~unique_ptr();</code></p>\n<p id=\"so_19528691_19528917_1\"><em>Requires:</em> The expression <code>get_deleter()(get())</code> shall be well formed, shall have well-defined behavior, and shall not throw exceptions. [ <em>Note:</em> The use of <code>default_delete</code> requires <code>T</code> to be a complete type. <em>\u2014endnote</em>]</p>\n</blockquote>\n<p>Which means that the deleter needs to make sure that it doesn't throw - which does <em>not</em> necessarily depend on the destructor of <code>T</code>, i.e., when you use a null-deleter.</p>\n", "LastActivityDate": "2013-10-22T23:59:26.647"}});