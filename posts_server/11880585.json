post_cb({"11880585": {"ViewCount": "421", "Body": "<p>Why are the following overloaded function calls ambiguous?? With the compile error:</p>\n<blockquote>\n<p id=\"so_11880585_11880585_0\">call of overloaded 'test(long int)' is ambiguous,candidates are: void test(A)|\n  void test(B)|</p>\n</blockquote>\n<p>The code:</p>\n<pre><code>class A\n{\n    public:\n        A(int){}\n        A(){}\n};\n\nclass B: public A\n{\n    public:\n        B(long){}\n        B(){}\n};\n\nvoid test(A a)\n{\n}\n\nvoid test(B b)\n{\n}\n\nvoid main()\n{\n    test(0L);\n    return;\n}\n</code></pre>\n", "AcceptedAnswerId": "11880679", "Title": "Why are these overloaded function calls ambiguous?", "CreationDate": "2012-08-09T09:41:58.200", "Id": "11880585", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-08-19T16:29:14.587", "LastEditorUserId": "63550", "LastActivityDate": "2016-08-19T16:29:14.587", "Score": "1", "OwnerUserId": "1567318", "Tags": "<c++><implicit-conversion><overload-resolution>", "AnswerCount": "5"}, "11880722": {"Id": "11880722", "PostTypeId": "2", "Body": "<p>Function overloading consider exact argument types or implicit conversions.\nIn your example both alternatives A(0L) and B(0L) are same from overload point of view, because require the implicit constructor call.</p>\n", "LastActivityDate": "2012-08-09T09:49:20.883", "CommentCount": "0", "CreationDate": "2012-08-09T09:49:20.883", "ParentId": "11880585", "Score": "1", "OwnerUserId": "1454243"}, "11880815": {"Id": "11880815", "PostTypeId": "2", "Body": "<p>You are calling test with a parameter of type long.</p>\n<p>There is no test(long).</p>\n<p>The compiler has to choose between test(A) and test(B).</p>\n<p>To call test(A) it has a conversion sequence of long -&gt; int -&gt; A.</p>\n<p>To call test(B) it has a conversion sequence of long -&gt; B.</p>\n<p>Depending on the ranking rules of the standard it will either pick one if one is ranked better than the other - or it will fail with ambiguity.</p>\n<p>In this specific case the two conversion sequences are ranked equally.</p>\n<p>There is a long list of rules in the standard about how it calculates the ranking of conversion sequences in section <strong>13.3.3 Best viable function\"</strong></p>\n", "LastEditorUserId": "1131467", "LastActivityDate": "2012-08-09T10:14:06.180", "Score": "1", "CreationDate": "2012-08-09T09:54:28.953", "ParentId": "11880585", "CommentCount": "4", "OwnerUserId": "1131467", "LastEditDate": "2012-08-09T10:14:06.180"}, "bq_ids": {"n4140": {"so_11880585_11880679_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 639}}, "n3337": {"so_11880585_11880679_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 629}}, "n4659": {"so_11880585_11880679_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 667}}}, "11881043": {"Id": "11881043", "PostTypeId": "2", "Body": "<p>Compiler is allowed to do only one implicit conversion to user type. If this also involves conversions between primitive types, they do not count. Even though you in case of <code>test(B)</code> you have two conversions in place, but the following will not compile:</p>\n<pre><code>class B\n{\npublic:\n    B(int) {}\n};\n\nclass A\n{\npublic:\n    A(const B&amp;) {}\n};\n\nvoid test(const A&amp;) {}\n\n....\n\ntest(5);\n</code></pre>\n<p>To disable compiler doing implicit conversion you should use <code>explicit</code> keyword with constructor</p>\n", "LastActivityDate": "2012-08-09T10:07:36.063", "CommentCount": "0", "CreationDate": "2012-08-09T10:07:36.063", "ParentId": "11880585", "Score": "0", "OwnerUserId": "1560833"}, "11880679": {"Id": "11880679", "PostTypeId": "2", "Body": "<p>You got an error because overload resolution has to choose from two equally viable functions (both have user-defined conversions). Function overload resolution is a very complicated subject. For more details on the overload resolution see e.g. this <a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-Cpp-3-of-n\" rel=\"nofollow\">recent lecture</a> by Stephan T. Lavavej. It's generally best to make single-argument constructors <code>explicit</code>, and then to call your function with an explicit constructor argument.</p>\n<p><code>test(0L)</code> is not an exact match to any overload because there is no overload <code>test(long)</code>. The two overloads you provided both have user-defined conversions on their arguments, but the compiler considers them equally viable. The <code>A</code> overload has to do a standard conversion (long to int) followed by a user-defined conversion (int to A), and the <code>B</code> overload a user-defined conversion (long to B). But both are <strong>implicit user-defined conversion sequences</strong>.</p>\n<p>How are these ranked? The Standard says in <strong>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</strong> </p>\n<blockquote>\n<p id=\"so_11880585_11880679_0\">Standard conversion sequence S1 is a better conversion sequence than\n  standard conversion sequence S2 if S1 is a proper subsequence of S2</p>\n</blockquote>\n<p>These type of tie-breaking e.g. apply if A would be a derived class from B (or vice versa). But here neither conversion sequence is a subsequence of the other. Therefore they are equally viable and the compiler cannot resolve the call.</p>\n<pre><code>class A\n{\npublic:\n    explicit A(int){}\n    A(){}\n};\n\nclass B: public A\n{\npublic:\n    explicit B(long){}\n    B(){}\n};\n\nvoid test(A a)\n{}\n\nvoid test(B b)\n{}\n\nint main()\n{\n    test(A(0L));  // call first overload\n    test(B(0L)); // call second overload\n    return 0;\n}\n</code></pre>\n<p>NOTE: it's <code>int main()</code>, not <code>void main()</code>.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2012-08-09T10:12:42.887", "Score": "5", "CreationDate": "2012-08-09T09:47:20.480", "ParentId": "11880585", "CommentCount": "5", "OwnerUserId": "819272", "LastEditDate": "2012-08-09T10:12:42.887"}, "11880688": {"Id": "11880688", "PostTypeId": "2", "Body": "<p>Try this:</p>\n<pre><code>class A\n{\n  public:\n  explicit A(int){}\n  A(){}\n};\n</code></pre>\n<p>Keyword explicit stops the compiler doing implicit conversions.</p>\n", "LastActivityDate": "2012-08-09T09:47:42.290", "CommentCount": "0", "CreationDate": "2012-08-09T09:47:42.290", "ParentId": "11880585", "Score": "0", "OwnerUserId": "1213473"}});