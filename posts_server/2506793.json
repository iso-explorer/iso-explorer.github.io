post_cb({"2506811": {"ParentId": "2506793", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard does indeed offer guarantees - from section 12.2/5:</p>\n<blockquote>\n<p id=\"so_2506793_2506811_0\">A temporary bound to a reference\n  parameter in a function call (5.2.2)\n  persists until the completion of the\n  full expression containing the call</p>\n</blockquote>\n<p>However, in your code it is not clear if the parameter is being passed by reference or by value, though at some point a copy constructor which does take a reference will be used.</p>\n", "Id": "2506811", "LastEditDate": "2010-03-24T10:28:38.280", "OwnerDisplayName": "anon", "Score": "9", "CreationDate": "2010-03-24T10:22:20.260", "LastActivityDate": "2010-03-24T10:28:38.280", "LastEditorDisplayName": "anon"}, "2507225": {"ParentId": "2506793", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Everyone has rightly cited 12.2/3 or similar, which answers your question:</p>\n<blockquote>\n<p id=\"so_2506793_2507225_0\">Temporary objects are destroyed as the\n  last step in evaluating the\n  full-expression that (lexically)\n  contains the point where they were\n  created.</p>\n</blockquote>\n<p>I find it amusing that <em>over the next page</em> in my printing of the standard, 12.2/4 says:</p>\n<blockquote>\n<p id=\"so_2506793_2507225_1\">There are two contexts in which\n  temporaries are destroyed at a\n  different point than the end of the\n  full-expression.</p>\n</blockquote>\n<p>Neither of them applies to your example, they both relate to the use of temporaries in initializers. But it does go to show that you have to keep your wits about you when dealing with a tricky beast like the C++ standard.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2014-03-04T14:53:58.350", "Id": "2507225", "Score": "22", "CreationDate": "2010-03-24T11:32:24.540", "LastActivityDate": "2014-03-04T14:53:58.350"}, "2506839": {"ParentId": "2506793", "CommentCount": "1", "Body": "<p>In section 12.2, Temporary Objects, clause 3, the ANSI/ISO C standard states: \"... Temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created.\"</p>\n<p>This is closely related to the concept of <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">Sequence Points</a>.  When a sequence point is reached, all side-effects of expressions are guaranteed to have taken place.</p>\n", "OwnerUserId": "99032", "PostTypeId": "2", "Id": "2506839", "Score": "2", "CreationDate": "2010-03-24T10:26:24.777", "LastActivityDate": "2010-03-24T10:26:24.777"}, "2506800": {"ParentId": "2506793", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Temporary objects are destroyed at the end of the full expression they're part of. </p>\n<p>A full expression is an expression that isn't a sub-expression of some other expression. Usually this means it ends at the <code>;</code> (or <code>)</code> for <code>if</code>, <code>while</code>, <code>switch</code> etc.) denoting the end of the statement. In your example, it's the end of the function call. </p>\n<p>Note that you can extend the lifetime of temporaries by binding them to a <code>const</code> reference. Doing so extends their lifetime to the reference's lifetime: </p>\n<pre><code>MyClass getMyClass();\n\n{\n  const MyClass&amp; r = getMyClass(); // full expression ends here\n  ...\n} // object returned by getMyClass() is destroyed here\n</code></pre>\n<p>If you don't plan to change the returned object, then this is a nice trick to save a copy constructor call (compared to <code>MyClass obj = getMyClass();</code>), in case return value optimization was not being applied. Unfortunately it isn't very well known. (I suppose C++11's move semantics will render it less useful, though.)</p>\n", "OwnerUserId": "140719", "LastEditorUserId": "140719", "LastEditDate": "2016-04-15T08:25:51.887", "Id": "2506800", "Score": "85", "CreationDate": "2010-03-24T10:20:30.953", "LastActivityDate": "2016-04-15T08:25:51.887"}, "2506793": {"CommentCount": "1", "AcceptedAnswerId": "2506800", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2010-03-24T10:18:55.917", "LastActivityDate": "2016-04-15T08:25:51.887", "LastEditDate": "2011-11-15T15:27:59.690", "ViewCount": "9073", "FavoriteCount": "17", "Title": "C++: Life span of temporary arguments?", "Id": "2506793", "Score": "54", "Body": "<p>When creating a new instance of a <code>MyClass</code> as an argument to a function like so:</p>\n<pre><code>class MyClass\n{\n  MyClass(int a);\n};    \n\nmyFunction(MyClass(42));\n</code></pre>\n<p>does the standard make any grantees on the timing of the destructor?<br>\nSpecifically, can I assume that the it is going to be called before the next statement after the call to <code>myFunction()</code> ?</br></p>\n", "Tags": "<c++><destructor>", "OwnerUserId": "9611", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_2506793_2506811_0": {"section_id": 382, "quality": 0.8571428571428571, "length": 12}, "so_2506793_2507225_1": {"section_id": 381, "quality": 1.0, "length": 10}, "so_2506793_2507225_0": {"section_id": 380, "quality": 1.0, "length": 14}}, "n3337": {"so_2506793_2507225_0": {"section_id": 371, "quality": 1.0, "length": 14}, "so_2506793_2506811_0": {"section_id": 373, "quality": 0.8571428571428571, "length": 12}, "so_2506793_2507225_1": {"section_id": 372, "quality": 1.0, "length": 10}}, "n4659": {"so_2506793_2507225_0": {"section_id": 395, "quality": 1.0, "length": 14}, "so_2506793_2506811_0": {"section_id": 397, "quality": 0.7857142857142857, "length": 11}, "so_2506793_2507225_1": {"section_id": 396, "quality": 0.9, "length": 9}}}});