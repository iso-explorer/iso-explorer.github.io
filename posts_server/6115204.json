post_cb({"6115204": {"ViewCount": "1184", "Body": "<p>Couple of questions on <code>boost::swap</code>. Please refer to the code below which is basically a cut-paste from <code>boost/swap.hpp</code>. I am referring to library version 1.43.0.</p>\n<pre><code>namespace boost_swap_impl\n    {\n      template&lt;class T&gt;\n      void swap_impl(T&amp; left, T&amp; right)\n      {\n        using namespace std;//use std::swap if argument dependent lookup fails\n        swap(left,right);\n      }\n\n  template&lt;class T, std::size_t N&gt;\n  void swap_impl(T (&amp; left)[N], T (&amp; right)[N])\n  {\n    for (std::size_t i = 0; i &lt; N; ++i)\n    {\n      ::boost_swap_impl::swap_impl(left[i], right[i]);\n    }\n  }\n}\n\nnamespace boost\n{\n  template&lt;class T1, class T2&gt;\n  void swap(T1&amp; left, T2&amp; right)\n  {\n    ::boost_swap_impl::swap_impl(left, right);\n  }\n}\n</code></pre>\n<ol>\n<li>Why is <code>boost::swap</code> declared as <code>template &lt;typename T1, typename T2&gt;</code> when in the rest of the code it is all dealing with the same type? </li>\n<li>If I define my own global function <code>void swap(T&amp;, T&amp;)</code> I see that it is the global function that gets called from <code>swap_impl(T&amp; left, T&amp; right)</code>. Is this not a conflict and hence an error condition since <code>swap_impl</code> also uses <code>namespace std</code> which has swap defined? </li>\n</ol>\n", "AcceptedAnswerId": "6115281", "Title": "Question on boost::swap", "CreationDate": "2011-05-24T18:39:19.400", "Id": "6115204", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-05-24T18:47:57.693", "LastEditorUserId": "560648", "LastActivityDate": "2015-09-10T03:44:51.370", "Score": "13", "OwnerUserId": "350810", "Tags": "<c++><boost>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_6115204_6115281_1": {"length": 18, "quality": 0.9, "section_id": 603}}, "n3337": {"so_6115204_6115281_1": {"length": 18, "quality": 0.9, "section_id": 593}}, "n4659": {"so_6115204_6115281_1": {"length": 18, "quality": 0.9, "section_id": 629}}}, "6115281": {"Id": "6115281", "PostTypeId": "2", "Body": "<ol>\n<li>This makes it less specialized than <code>std::swap</code> so you don't get overload ambiguity errors when both <code>std::swap</code> and <code>boost::swap</code> are in scope (<code>std::swap</code> will take precedence).</li>\n<li>No, non-templates always have precedence over templates during overload resolution, so a namespace-scoped non-template <code>swap</code> will take precedence over both <code>boost::swap</code> and <code>std::swap</code> (as will a namespace-scoped template <code>swap</code> overloaded for a UDT \u2013 think partially-specialized, but not really..). Note that unlike <code>std::swap</code>, <code>boost::swap</code> is written explicitly to take advantage of <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow noreferrer\">ADL</a>.</li>\n</ol>\n<p>Here's what the C++03 standard has to say regarding both points \u2013 [over.match.best] (\u00a713.3.3/1):</p>\n<blockquote>\n<p id=\"so_6115204_6115281_0\">Define ICS<i>i</i>(<code>F</code>) as follows:</p>\n<ul>\n<li>if <code>F</code> is a static member function, ICS<i>1</i>(<code>F</code>) is defined such that ICS<i>1</i>(<code>F</code>) is neither better nor worse than ICS<i>1</i>(<code>G</code>) for any function <code>G</code>, and, symmetrically, ICS<i>1</i>(<code>G</code>) is neither better nor worse than ICS<i>1</i>(<code>F</code>); otherwise,</li>\n<li>let ICS<i>i</i>(<code>F</code>) denote the implicit conversion sequence that converts the <em>i</em>-th argument in the list to the type of the <em>i</em>-th parameter of viable function <code>F</code>. 13.3.3.1 defines the implicit conversion sequences and 13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another.</li>\n</ul>\n<p id=\"so_6115204_6115281_1\">Given these definitions, a viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function <code>F2</code> if for all arguments <em>i</em>, ICS<i>i</i>(<code>F1</code>) is not a worse conversion sequence than ICS<i>i</i>(<code>F2</code>), and then</p>\n<ul>\n<li>for some argument <em>j</em>, ICS<i>j</i>(<code>F1</code>) is a better conversion sequence than ICS<i>j</i>(<code>F2</code>), or, if not that,</li>\n<li><code>F1</code> is a non-template function and <code>F2</code> is a function template specialization, or, if not that,</li>\n<li><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized than the template for <code>F2</code> according to the partial ordering rules described in 14.5.5.2, or, if not that,</li>\n<li>the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of <code>F2</code> to the destination type.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "636019", "LastActivityDate": "2015-09-10T03:44:51.370", "Score": "19", "CreationDate": "2011-05-24T18:45:48.707", "ParentId": "6115204", "CommentCount": "4", "OwnerUserId": "636019", "LastEditDate": "2015-09-10T03:44:51.370"}});