post_cb({"bq_ids": {"n4140": {"so_36167764_36168037_1": {"length": 18, "quality": 0.6, "section_id": 764}, "so_36167764_36168090_0": {"length": 24, "quality": 0.8, "section_id": 764}}, "n3337": {"so_36167764_36168037_1": {"length": 18, "quality": 0.6, "section_id": 751}, "so_36167764_36168090_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 751}}, "n4659": {"so_36167764_36168037_1": {"length": 17, "quality": 0.5666666666666667, "section_id": 824}, "so_36167764_36168090_0": {"length": 24, "quality": 0.8, "section_id": 824}}}, "36168037": {"Id": "36168037", "PostTypeId": "2", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/container/unordered_set/operator_cmp\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/unordered_set/operator_cmp</a> you do in fact need the <code>operator==</code> for comparison (I don't have access to the standard right now - I'll try to update with the specific quote sometime tomorrow):</p>\n<blockquote>\n<p id=\"so_36167764_36168037_0\">The behavior is undefined if Key is not EqualityComparable.</p>\n<p id=\"so_36167764_36168037_1\">The behavior is also undefined if Hash and KeyEqual do not have the\n  same behavior on lhs and rhs or if the equality comparison operator\n  for Key is not a refinement of the partition into equivalent-key\n  groups introduced by KeyEqual (that is, if two keys that compare equal\n  fall into different partitions)</p>\n</blockquote>\n", "LastActivityDate": "2016-03-23T01:05:59.463", "CommentCount": "0", "CreationDate": "2016-03-23T01:05:59.463", "ParentId": "36167764", "Score": "3", "OwnerUserId": "251738"}, "36168090": {"Id": "36168090", "PostTypeId": "2", "Body": "<p>\"23.2.5 Unordered associative containers\" states:</p>\n<blockquote>\n<p id=\"so_36167764_36168090_0\">Two unordered containers a and b compare equal if a.size() == b.size()\n  and, for every equivalent=key group [Ea1,Ea2) obtained from\n  a.equal_range(Ea1), there exists an equivalent-key group [Eb1,Eb2)\n  obtained from b.equal_range(Ea1), such that distance(Ea1, Ea2) ==\n  distance(Eb1, Eb2) and is_permutation(Ea1, Ea2, Eb1) returns true.</p>\n</blockquote>\n<p>Stripping this down, it all comes down to the equality of unordered containers being defined in terms of <code>std::is_permutation()</code>.</p>\n<p>The important part is that this references the three argument form of <code>std::is_permutation</code>(), and not the four argument form!</p>\n<p>In other words, the whole house of cards ends up being reduced to the default <code>operator==</code>, for the contents of the unordered container, rather than the container's official comparison function.</p>\n<p>That's my read on this.</p>\n", "LastActivityDate": "2016-03-23T01:11:29.600", "CommentCount": "0", "CreationDate": "2016-03-23T01:11:29.600", "ParentId": "36167764", "Score": "2", "OwnerUserId": "3943312"}, "36167764": {"ViewCount": "139", "Body": "<p>The following program does not compile. But If I do not comment out <code>operator==</code>, it compiles. Why <code>operator==</code> is still needed when I already provide <code>FooEqual</code> </p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;unordered_set&gt;\n\nstruct Foo {\n};\n\nstruct FooHasher {\n  size_t operator()(const Foo&amp;) const {\n    return 1;\n  }\n};\n\nstruct FooEqual {\n  bool operator()(const Foo&amp; lhs, const Foo&amp; rhs) const {\n    return true;\n  }\n};\n\n// bool operator==(const Foo&amp; lhs, const Foo&amp; rhs) {\n//   return true;\n// }\n\nint main() {\n  std::unordered_set&lt;Foo, FooHasher, FooEqual&gt; s1;\n  std::unordered_set&lt;Foo, FooHasher, FooEqual&gt; s2;\n  (void)(s1 == s2);\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "36168090", "Title": "Can not compare std::unorded_set with custom KeyEqual", "CreationDate": "2016-03-23T00:32:16.997", "Id": "36167764", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-03-23T01:11:29.600", "Score": "7", "OwnerUserId": "700650", "Tags": "<c++><c++11><unordered-set>", "AnswerCount": "2"}});