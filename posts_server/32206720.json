post_cb({"32206720": {"CommentCount": "5", "ViewCount": "118", "PostTypeId": "1", "LastEditorUserId": "4498952", "CreationDate": "2015-08-25T14:26:25.740", "LastActivityDate": "2015-08-27T14:54:42.080", "Title": "Function pointer, which can point to every thing?", "FavoriteCount": "0", "LastEditDate": "2015-08-25T15:58:56.353", "Id": "32206720", "Score": "-3", "Body": "<p>I am working with function pointer in c++ , and i am wonderring if any function pointer type which can use for every function, dont care about return value, list argument or how many argument.\nIf it is possible, how is it work?</p>\n<p>example:</p>\n<p>I have some functions:</p>\n<p>void F1(void);</p>\n<p>void F2(int);</p>\n<p>int F3(int, char*);</p>\n<p>float F4(int, float);</p>\n<p>int F5(MyClass);</p>\n<p>....</p>\n<p>if:\n  i have </p>\n<p>typedef (void) (*fp1)(void); \n  i can call : fp1 x = &amp;F1;</p>\n<p>if:\n  i have </p>\n<p>typdef (float) (*fp2)(int, float);\n  i can call : fp2 x = &amp;F4;</p>\n<p>now I need some kind of function pointer to store all of them.</p>\n<p>something like this:</p>\n<p>typedef void(<em>function_pointer)(void</em>)</p>\n<p>or typedef void(<em>function_pointer)(void</em>, ...) // but both dont work.</p>\n<p>And one more infomation: i have tried to use template, but it didn't solve my problem\nThanks.</p>\n", "Tags": "<c++><function><pointers>", "OwnerUserId": "4498952", "AnswerCount": "1"}, "32252780": {"ParentId": "32206720", "CommentCount": "1", "Body": "<p>The standard promises that you can use <code>reinterpret_cast</code> to convert one function pointer type to another, and this conversion is reversible. However, it also requires that you cast the function pointer back to its original type before using it.</p>\n<blockquote>\n<p id=\"so_32206720_32252780_0\"><strong>[expr.reinterpret.cast]</strong></p>\n<p id=\"so_32206720_32252780_1\">A pointer to a function can be explicitly converted to a pointer to a function of a different type. <strong>The effect of calling a function through a pointer to a function type that is not the same as the type used in the de\ufb01nition of the function is unde\ufb01ned</strong>. Except that converting an rvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are function types) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspeci\ufb01ed.</p>\n</blockquote>\n<p>Therefore, you need to keep track somewhere else what kind of function you put in the variable, so you can cast it back to the correct type before you use it. As a result, the ability to cast function types to each other is of only marginal value; you could have used a union to achieve the same effect.</p>\n", "OwnerUserId": "902497", "PostTypeId": "2", "Id": "32252780", "Score": "2", "CreationDate": "2015-08-27T14:54:42.080", "LastActivityDate": "2015-08-27T14:54:42.080"}, "bq_ids": {"n4140": {"so_32206720_32252780_1": {"section_id": 6045, "quality": 0.8444444444444444, "length": 38}}, "n3337": {"so_32206720_32252780_1": {"section_id": 5813, "quality": 0.8444444444444444, "length": 38}}, "n4659": {"so_32206720_32252780_1": {"section_id": 7544, "quality": 0.8444444444444444, "length": 38}}}});