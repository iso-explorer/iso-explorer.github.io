post_cb({"33617421": {"CommentCount": "6", "AcceptedAnswerId": "33617530", "CreationDate": "2015-11-09T20:13:41.737", "LastActivityDate": "2015-11-10T01:24:47.833", "PostTypeId": "1", "ViewCount": "779", "FavoriteCount": "1", "Title": "Write concurrently vector<bool>", "Id": "33617421", "Score": "5", "Body": "<p>I know that is possible to read concurrently from a <code>std::vector</code> without \"bad\" consequences because this operation can be considered thread-safe.</p>\n<p>But the same cannot be said for writing operations. But, I am wondering if this is not always true, for example considering my particular scenario.</p>\n<p>I have a <code>std::vector&lt;bool&gt;</code>, where all the elements are initialized to <code>false</code>, and, given an array of indices, I need to change the value of these elements (<code>vector[index]</code> for each index) from <code>false</code> to <code>true</code>.</p>\n<p>If I use a different thread for each index (and there is the possibility that some indices have the same value), can this operation be considered thread-safe?</p>\n<p>If the vector is a <code>std::vector&lt;int&gt;</code> (or any primitive type) and the value assigned is always the same (for example 1) can this operation still be considered thread-safe?</p>\n", "Tags": "<c++><multithreading><c++11><vector>", "OwnerUserId": "1395740", "AnswerCount": "2"}, "33617530": {"ParentId": "33617421", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-11-09T20:19:29.323", "Score": "8", "LastEditorUserId": "481061", "LastEditDate": "2015-11-10T01:24:47.833", "Id": "33617530", "OwnerUserId": "481061", "Body": "<p>Concurrent writes to <code>vector&lt;bool&gt;</code> are never ok, because the underlying implementation relies on a proxy object of type <code>vector&lt;bool&gt;::reference</code> which acts as if it was a reference to bool, but in reality will fetch and update the bitfield bytes as needed. </p>\n<p>When using multiple threads without synchronization, the following might happen: Thread 1 is supposed to update a bit, and reads the byte containing it. Then thread 2 reads the same byte, then thread 1 updates a bit and writes the byte back, and then thread 2 updates another bit and writes the byte back, overwriting the edit of thread 1.</p>\n<p>This is just one possible scenario, there are others that would lead to the same kind of data corruption.</p>\n<hr>\n<p>In the <code>vector&lt;int&gt;</code> situation, if you are absolutely <em>sure</em> that all threads write the same value into the vector, then this operation will never lead to data corruption. But as soon as you do any other operation on the same element from two different threads, you will have a race condition and need proper synchronization.</p>\n</hr>", "LastActivityDate": "2015-11-10T01:24:47.833"}, "bq_ids": {"n4140": {"so_33617421_33618459_0": {"section_id": 718, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_33617421_33618459_0": {"section_id": 707, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_33617421_33618459_0": {"section_id": 749, "quality": 0.9473684210526315, "length": 18}}}, "33618459": {"ParentId": "33617421", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-11-09T21:17:47.020", "Score": "6", "LastEditorUserId": "923854", "LastEditDate": "2015-11-09T21:59:22.053", "Id": "33618459", "OwnerUserId": "923854", "Body": "<p>[container.requirements.dataraces]/2 says:</p>\n<blockquote>\n<p id=\"so_33617421_33618459_0\">Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same container, <strong>excepting <code>vector&lt;bool&gt;</code></strong>, are modified concurrently.</p>\n</blockquote>\n<p>So you can safely modify distinct elements of the same standard library container from distinct threads, <strong>except</strong> when that container is <code>vector&lt;bool&gt;</code>.</p>\n", "LastActivityDate": "2015-11-09T21:59:22.053"}});