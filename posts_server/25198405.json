post_cb({"25198649": {"Id": "25198649", "PostTypeId": "2", "Body": "<p>In this particular case, the answer is <strong>YES</strong> because of <a href=\"http://en.cppreference.com/w/cpp/container/vector/resize\" rel=\"nofollow\"><code>std::vector::resize()</code></a>'s properties:</p>\n<pre><code>If the current size is less than count, additional elements are appended and initialized with copies of value.      (until C++11)\n\nIf the current size is less than count,  (since C++11)\n    1) additional value-initialized elements are appended\n    2) additional copies of value are appended\n</code></pre>\n<p>The answer will be <strong>NO</strong> for normal cases, e.g. <code>myStruct s</code>, this will leave them (<code>s.i, s.bool, s.myobj</code>) with <strong>indeterminate values</strong>.</p>\n<p>If you still want them to be initialized as expected, create a constructor for the struct:</p>\n<pre><code>struct myStruct {\n    int i;\n    bool b;\n    MyClass *myobj;\n\n    myStruct():i(0),b(false),myobj(NULL) { }  // &lt;- set them here by default\n};\n</code></pre>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-17T08:25:29.107", "Score": "5", "CreationDate": "2014-08-08T08:01:38.133", "ParentId": "25198405", "CommentCount": "1", "OwnerUserId": "2589776", "LastEditDate": "2014-08-17T08:25:29.107"}, "25198451": {"Id": "25198451", "PostTypeId": "2", "Body": "<p>The ctor for the struct is called.  Since you don't specify one (and you can, even for a struct), a default, do-nothing ctor is used.  The default ctor does not clear the members.</p>\n", "LastActivityDate": "2014-08-08T07:49:09.743", "CommentCount": "1", "CreationDate": "2014-08-08T07:49:09.743", "ParentId": "25198405", "Score": "0", "OwnerUserId": "12725"}, "bq_ids": {"n4140": {"so_25198405_25198802_0": {"length": 4, "quality": 0.8, "section_id": 715}, "so_25198405_25198802_3": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_25198405_25198802_1": {"length": 7, "quality": 1.0, "section_id": 715}}, "n3337": {"so_25198405_25198802_3": {"length": 4, "quality": 1.0, "section_id": 3157}}, "n4659": {"so_25198405_25198802_0": {"length": 4, "quality": 0.8, "section_id": 745}, "so_25198405_25198802_1": {"length": 7, "quality": 1.0, "section_id": 745}}}, "25198802": {"Id": "25198802", "PostTypeId": "2", "Body": "<p>I actually beg to differ. <strong>In this particular case</strong>, the standard appears to guarantee that the objects will be zero-initialized. (All standard references below are to N3936.)</p>\n<p><code>vector::resize</code> in this case is specified to append 10 \"default-inserted elements to the sequence\" (\u00a723.3.6.3 [vector.capacity]/p12).</p>\n<p>Default-insertion is in turn defined as (\u00a723.2.1 [container.requirements.general]/p14; <code>X</code> is the container's type; <code>m</code> is an lvalue of type <code>A</code>, which is the container's <code>allocator_type</code>):</p>\n<blockquote>\n<p id=\"so_25198405_25198802_0\">An element of <code>X</code> is default-inserted if it is initialized by evaluation\n  of the expression</p>\n<pre><code>allocator_traits&lt;A&gt;::construct(m, p)\n</code></pre>\n<p id=\"so_25198405_25198802_1\">where <code>p</code> is the address of the uninitialized storage for the element allocated within <code>X</code>.</p>\n</blockquote>\n<p>Since as written the code uses the default allocator, the <code>allocator_traits::construct</code> call simply calls <code>construct(p)</code> on an instance of <code>std::allocator&lt;myStruct&gt;</code> (\u00a720.7.8.2 [allocator.traits.members]/p5), which is specified as (\u00a720.7.9.1 [allocator.members]/p12)</p>\n<blockquote>\n<pre><code>template &lt;class U, class... Args&gt;\nvoid construct(U* p, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_25198405_25198802_2\">12 <em>Effects</em>: <code>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</code></p>\n</blockquote>\n<p>Since the parameter pack is empty for <code>construct(p)</code>, the effect of the <code>construct()</code> call is<code>::new((void *)p) myStruct()</code>.</p>\n<p>The standard provides that <em>new-initializers</em>, like the <code>()</code> in the placement new expression above, are to be interpreted \"according to the initialization rules of 8.5 for direct initialization\" (\u00a75.3.4 [expr.new]/p17). In turn, \u00a78.5 [dcl.init]/p11 specifies that \"An object whose initializer is an empty set of parentheses, i.e., <code>()</code>, shall be value-initialized.\"</p>\n<p>Value-initialization is specified as (\u00a78.5 [dcl.init]/p8)</p>\n<blockquote>\n<p id=\"so_25198405_25198802_3\">To value-initialize an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is\n  user-provided or deleted, then the object is default-initialized;</li>\n<li>if <code>T</code> is a (possibly cv-qualified) class type without a user-provided or deleted default \n  constructor, then the object is zero-initialized and the semantic constraints for\n  default-initialization are checked, and if T has a non-trivial default\n  constructor, the object is default-initialized;</li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>In this case, <code>myStruct</code> is a \"class type without a user-provided or deleted default constructor\", which means it matches the second bullet point, which performs zero-initialization. Thus, value-initialization for an object of type <code>myStruct</code> means the object will be zero-initialized.</p>\n<p>However, note that the rules here are quite convoluted, and the path to automatic zero-initialization is quite fragile. For example, if you give <code>myStruct</code> a default constructor like <code>myStruct() { }</code>, then that's a user-provided default constructor, which means that it will match the first bullet point for value initialization instead of the second, which in turn means that it won't be zero-initialized. Moreover, this may also not work if your <code>vector</code> uses a custom allocator, as its <code>construct()</code> might have different semantics than that of the default allocator.</p>\n<p>Therefore, it is probably better to give <code>myStruct</code> a default constructor that explicitly zeroes its members.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-09T02:51:22.570", "Score": "4", "CreationDate": "2014-08-08T08:11:11.750", "ParentId": "25198405", "CommentCount": "1", "OwnerUserId": "2756719", "LastEditDate": "2014-08-09T02:51:22.570"}, "25198461": {"Id": "25198461", "PostTypeId": "2", "Body": "<p>The values in the <code>vector</code> are initialised with the default constructor (or value initialised) of the <code>struct</code>, in this case <code>myStruct</code>.</p>\n<p>The <code>struct</code> has no default constructor, so the compiler generated one will be used. In this case it leaves the objects of <code>myStruct</code> uninitialised.</p>\n<p>No, in general, you cannot assume the data will be zero initialised.</p>\n<p>This particular case (the <code>.resize()</code>) is picking at a situation where there is value initialisation and there has been some change from C++03 and C++11 (other answers provide more detail).</p>\n<p><strong>Best advice remains</strong>, thing to do is add the default constructor that initialises the <code>struct</code> appropriately.</p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2014-08-08T08:43:29.917", "Score": "1", "CreationDate": "2014-08-08T07:49:38.773", "ParentId": "25198405", "CommentCount": "0", "OwnerUserId": "3747990", "LastEditDate": "2014-08-08T08:43:29.917"}, "25198953": {"Id": "25198953", "PostTypeId": "2", "Body": "<p>Yes the structs will be initialised to zero IN THIS PARTICULAR CASE. The reason is the implementation of the <code>resize()</code> method in the STL. New elements are default-constructed:</p>\n<pre><code>void resize(size_type __new_size) {\n    resize(__new_size, value_type());\n}\n</code></pre>\n<p><code>value_type()</code> results in zero initialisation.</p>\n<h2>test evidence</h2>\n<pre><code>#include &lt;cstdio&gt;\n\nstruct foo {\n  int i;\n  int j;\n  void *k;\n};\n\nvoid test(const foo&amp; fooinst) {\n  printf(\"%d\\n\",fooinst.i);\n}\n\nmain() {\n  test(foo());\n}\n</code></pre>\n<p>Here's the relevant part of the resulting g++ disassembly. Note the explicit zero initialisation of the struct members before the call.</p>\n<pre><code>test.cpp      ****   test(foo());\n  56                            .loc 1 14 0\n  57 002d C745F000              movl    $0, -16(%rbp)\n  57      000000\n  58 0034 C745F400              movl    $0, -12(%rbp)\n  58      000000\n  59 003b 48C745F8              movq    $0, -8(%rbp)\n  59      00000000 \n  60 0043 488D45F0              leaq    -16(%rbp), %rax\n  61 0047 4889C7                movq    %rax, %rdi\n  62 004a E8000000              call    _Z4testRK3foo\n</code></pre>\n", "LastActivityDate": "2014-08-08T08:20:16.523", "CommentCount": "0", "CreationDate": "2014-08-08T08:20:16.523", "ParentId": "25198405", "Score": "2", "OwnerUserId": "1763035"}, "25198405": {"ViewCount": "1121", "Body": "<p>In C++, when I have a struct like</p>\n<pre><code>struct myStruct\n{\n  int i;\n  bool b;\n  MyClass *myobj;\n};\n</code></pre>\n<p>and I then make a vector of this</p>\n<pre><code>std::vector&lt;myStruct&gt; myVector;\n</code></pre>\n<p>and I resize the vector with</p>\n<pre><code>myVector.resize(10);\n</code></pre>\n<p>Will the struct's members be initialized with zero's (including the pointer)? Can I not assume that and might there be random data in the struct's members?</p>\n", "AcceptedAnswerId": "25198649", "Title": "Are members of structs in a vector initialized with zero in C++?", "CreationDate": "2014-08-08T07:46:29.907", "Id": "25198405", "CommentCount": "1", "LastEditDate": "2014-08-08T07:59:50.133", "PostTypeId": "1", "LastEditorUserId": "3747990", "LastActivityDate": "2014-08-17T08:25:29.107", "Score": "3", "OwnerUserId": "2163014", "Tags": "<c++><vector><struct>", "AnswerCount": "5"}});