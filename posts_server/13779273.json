post_cb({"13779273": {"CommentCount": "3", "AcceptedAnswerId": "13779331", "PostTypeId": "1", "LastEditorUserId": "368896", "CreationDate": "2012-12-08T16:16:15.627", "LastActivityDate": "2012-12-10T12:41:00.270", "LastEditDate": "2012-12-10T12:25:43.540", "ViewCount": "592", "FavoriteCount": "7", "Title": "In the standard, what is \"derived-declarator-type\"?", "Id": "13779273", "Score": "12", "Body": "<p>In different places in the C++ (C++11) standard, declarations are described in terms of <em>derived-declarator-type-list</em>.  I am studying rvalue references and the use of this term is critical in that context (\u00a78.3.2):</p>\n<blockquote>\n<p id=\"so_13779273_13779273_0\">In a declaration <strong>T D</strong> where <strong>D</strong> has either of the forms<br>\n  \u00a0\u00a0\u00a0\u00a0&amp; <em>attribute-specifier-seq<sub>opt</sub></em> <strong>D1</strong><br>\n  \u00a0\u00a0\u00a0\u00a0&amp;&amp; <em>attribute-specifier-seq</em><sub>opt</sub> <strong>D1</strong><br>and the type of the identifier in the declaration <strong>T D1</strong> is\n  \u201c<em>derived-declarator-type-list</em> <strong>T</strong>,\u201d then the type of the identifier of <strong>D</strong>\n  is \u201c<em>derived-declarator-type-list</em> reference to <strong>T</strong>.\u201d</br></br></br></p>\n</blockquote>\n<p>Unfortunately, the category \"<em>derived-declarator-type</em>\" is never defined in the standard.  (I looked through every use of the word \"derived\", and in addition this is possibly confirmed <a href=\"http://www.cpptalk.net/defect-report-derived-declarator-type-list-undefined-vt23643.html\" rel=\"noreferrer\">here</a> and <a href=\"https://groups.google.com/d/topic/comp.std.c/gIEwLcEhCHE/discussion\" rel=\"noreferrer\">here</a>.)</p>\n<p>Because \"<em>derived-declarator-type-list</em>\" is italicized, I assume it refers to a category, and not to a variable label such as <strong><code>T</code></strong> (and therefore, I disagree with Doug Gwyn's assessment in the second link I just gave that \"we could have used <strong><code>X</code></strong> instead of '<em>derived-declarator-type-list</em>' \").</p>\n<p>What is the definition of <em>derived-declarator-type</em> in the C++11 standard?</p>\n", "Tags": "<c++><c++11><standards>", "OwnerUserId": "368896", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13779273_13779331_0": {"section_id": 3222, "quality": 1.0, "length": 7}, "so_13779273_13779273_0": {"section_id": 3218, "quality": 0.6875, "length": 11}}, "n3337": {"so_13779273_13779331_0": {"section_id": 3096, "quality": 1.0, "length": 7}, "so_13779273_13779273_0": {"section_id": 3092, "quality": 0.6875, "length": 11}}, "n4659": {"so_13779273_13779331_0": {"section_id": 3979, "quality": 1.0, "length": 7}, "so_13779273_13779273_0": {"section_id": 3975, "quality": 0.6875, "length": 11}}}, "13779331": {"ParentId": "13779273", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>It's being defined right there and then. It's a way of carrying whatever comes before <code>T</code> across to the next type, similar to:</p>\n<pre><code>&lt;some stuff&gt; T\n&lt;some stuff&gt; reference to T\n</code></pre>\n<p>It's just whatever comes before <code>T</code> in the type of <code>T D1</code>.</p>\n<p>For example, if you have the declaration <code>int&amp; (*const * p)[30]</code>, <code>T</code> is <code>int</code>, <code>D</code> is <code>&amp; (*const * p)[30]</code> and <code>D1</code> is <code>(*const * p)[30]</code>. The type of <code>T D1</code> is \"pointer to const pointer to array of 30 int\". And so, according to the rule you quoted, the type of <code>p</code> is \"pointer to const pointer to array of 30 reference to int\".</p>\n<p>Of course, this declaration is then disallowed by \u00a73.4.2/5:</p>\n<blockquote>\n<p id=\"so_13779273_13779331_0\">There shall be no references to references, no arrays of references, and no pointers to references.</p>\n</blockquote>\n<p>I think the informal terminology of it being a <em>derived</em> declarator type list comes from the C standard's definition of a <em>derived type</em> (similar to a compound type in C++):</p>\n<blockquote>\n<p id=\"so_13779273_13779331_1\">Any number of <em>derived types</em> can be constructed from the object, function, and\n  incomplete types, as follows:</p>\n<ul>\n<li>An <em>array type</em> [...]</li>\n<li>An <em>structure type</em> [...]</li>\n<li>An <em>union type</em> [...]</li>\n<li>An <em>function type</em> [...]</li>\n<li>An <em>pointer type</em> [...]</li>\n</ul>\n</blockquote>\n<hr>\n<p>In response to the comments: It seems you're getting confused between the type and the declarator. For example, if <code>int* p</code> is the declarator, then the type of <code>p</code> is \"pointer to int\". The type is expressed as these English-like sentences.</p>\n<p><strong>Example 1</strong>: <code>int *(&amp;p)[30]</code></p>\n<p>This is a declaration <code>T D</code> where (\u00a78.3.1 Pointers):</p>\n<ul>\n<li><code>T</code> -&gt; <code>int</code></li>\n<li><code>D</code> -&gt; <code>*(&amp;p)[3]</code></li>\n</ul>\n<p><code>D</code> has the form:</p>\n<blockquote>\n<p id=\"so_13779273_13779331_2\"><code>*</code> <em>attribute-specifier-seq<sub>opt</sub></em> <em>cv-qualifier-seq<sub>opt</sub></em> <code>D1</code></p>\n</blockquote>\n<p>where <code>D1</code> is <code>(&amp;p)[3]</code>. That means <code>T D1</code> is of the form <code>int (&amp;p)[3]</code> which has type \"reference to array of 3 <code>int</code>\" (you work this out recursively, next step using \u00a78.3.4 Arrays and so on). Everything before the <code>int</code> is the <em>derived-declarator-type-list</em>. So we can infer that <code>p</code> in our original declaration has type \"reference to array of 3 pointer to <code>int</code>\". Magic!</p>\n<p><strong>Example 2</strong>: <code>float (*(*(&amp;e)[10])())[5]</code></p>\n<p>This is a declaration <code>T D</code> where (\u00a78.3.4 Arrays):</p>\n<ul>\n<li><code>T</code> -&gt; <code>float</code></li>\n<li><code>D</code> -&gt; <code>(*(*(&amp;e)[10])())[5]</code></li>\n</ul>\n<p><code>D</code> is of the form:</p>\n<blockquote>\n<p id=\"so_13779273_13779331_3\"><code>D1 [</code> <em>constant-expression<sub>opt</sub></em> <code>]</code> <em>attribute-specifier-seq<sub>opt</sub></em></p>\n</blockquote>\n<p>where <code>D1</code> is <code>(*(*(&amp;e)[10])())</code>. This means <code>T D1</code> is of the form <code>float (*(*(&amp;e)[10])())</code> which has type \"reference to array of 10 pointer to function of () returning pointer to float\" (which you work out by applying \u00a78.3/6 and then \u00a78.3.1 Pointers and so on). Everything before the <code>float</code> is the <em>derived-declarator-type-list</em>. So we can infer that <code>p</code> in our original declaration has type \"reference to array of 10 pointer to function of () returning pointer to array of 5 float\". Magic again!</p>\n</hr>", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2012-12-10T12:41:00.270", "Id": "13779331", "Score": "11", "CreationDate": "2012-12-08T16:22:45.327", "LastActivityDate": "2012-12-10T12:41:00.270"}});