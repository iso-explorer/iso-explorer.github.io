post_cb({"9169978": {"ParentId": "9169453", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-02-07T01:49:38.477", "Score": "2", "LastEditorUserId": "15168", "LastEditDate": "2012-02-07T03:46:40.383", "Id": "9169978", "OwnerUserId": "15168", "Body": "<h3>Standards</h3>\n<p>In the C++98 standard, there's some information in </p>\n<blockquote>\n<p id=\"so_9169453_9169978_0\">C.2.4.1 Macro <code>offsetof</code>(<em>type</em>, <em>memberdesignator</em>)             [diff.offsetof]</p>\n<p id=\"so_9169453_9169978_1\">The macro <code>offsetof</code>, defined in <code>&lt;cstddef&gt;</code>, accepts a restricted set of type arguments in this International\n  Standard. \u00a718.1 describes the change.</p>\n</blockquote>\n<p>(C.2.4.1 showed up with <code>offsetof</code> in the contents, so I went there first.)  And:</p>\n<blockquote>\n<p id=\"so_9169453_9169978_2\">\u00a718.1 Types 18 Language support library</p>\n<p id=\"so_9169453_9169978_3\">\u00b65 The macro <code>offsetof</code> accepts a restricted set of type arguments in this International Standard. <em>type</em>\n  shall be a POD structure or a POD union (clause 9). The result of applying the offsetof macro to a field that\n  is a static data member or a function member is undefined.</p>\n</blockquote>\n<p>For comparison, the C99 standard says:</p>\n<blockquote>\n<pre><code> offsetof(type, member-designator)\n</code></pre>\n<p id=\"so_9169453_9169978_4\">which expands to an integer constant expression that has type <code>size_t</code>, the value of\n  which is the offset in bytes, to the structure member (designated by <em>member-designator</em>),\n  from the beginning of its structure (designated by <em>type</em>). The <em>type</em> and <em>member designator</em>\n  shall be such that given</p>\n<pre><code>static type t;\n</code></pre>\n<p id=\"so_9169453_9169978_5\">then the expression <code>&amp;(t.member-designator)</code> evaluates to an address constant. (If the\n  specified member is a bit-field, the behavior is undefined.)</p>\n</blockquote>\n<hr>\n<h3>Your code</h3>\n<p>Your code meets the requirements of both the C++ and C standards, it seems to me.</p>\n<p>When I use G++ 4.1.2 and GCC 4.5.1 on RedHat (RHEL 5), this code compiles without complaint with the <code>-Wall -Wextra</code> options:</p>\n<pre><code>#include &lt;cstddef&gt;\n\nstruct SomeType {\n    int m_member;\n};\n\nstatic const int memberOffset = offsetof(SomeType, m_member);\n</code></pre>\n<p>It also compiles without complaint with <code>#include &lt;stddef.h&gt;</code> and with the GCC compilers (if I use <code>struct SomeType</code> in the macro invocation).</p>\n<p>I wonder - I got errors until I included <code>&lt;cstddef&gt;</code>...did you include that?  I also added the type <code>int</code> to the declaration, of course.</p>\n<p>Assuming that you haven't made any bloopers in your code, it seems to me that you probably have found a bug in the <code>&lt;cstddef&gt;</code> (or <code>&lt;stddef.h&gt;</code>) header on your platform.  You should not be getting the error, and the Linux-based G++ appears to confirm that.</p>\n<h3>Workarounds?</h3>\n<p>You will need to review how <code>offsetof()</code> is defined in your system headers.  You will then probably redefine it in such a way as not to run into the problem.</p>\n<p>You might be able to use something like this, assuming you identify your broken system somehow and execute <code>#define BROKEN_OFFSETOF_MACRO</code> (or add <code>-DBROKEN_OFFSETOF_MACRO</code> to the command line).</p>\n<pre><code>#include &lt;cstddef&gt;\n\n#ifdef BROKEN_OFFSETOF_MACRO\n#undef offsetof\n#define offsetof(type, member)   ((size_t)((char *)&amp;(*(type *)0).member - \\\n                                           (char *)&amp;(*(type *)0)))\n#endif /* BROKEN_OFFSETOF_MACRO */\n\nstruct SomeType {\n    int m_member;\n};\n\nstatic const int memberOffset = offsetof(SomeType, m_member);\n</code></pre>\n<p>The <code>size_t</code> cast is present since the difference between two addresses is a <code>ptrdiff_t</code> and the <code>offset()</code> macro is defined to return <code>size_t</code>.  The macro is nothing other than ugly, but that's why it is normally hidden in a system header where you don't have to look at it in all its ghastliness.  But when all else fails, you must do whatever is necessary.</p>\n<p>I know that once, circa 1990, I encountered a C compiler that would not allow 0 but it would allow 1024 instead.  The distributed <code>&lt;stddef.h&gt;</code> header, of course, used <code>0</code>, so I 'fixed' it by changing the 0 to 1024 (twice) for the duration (until I got a better compiler on a better machine).</p>\n</hr>", "LastActivityDate": "2012-02-07T03:46:40.383"}, "9169545": {"ParentId": "9169453", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-02-07T00:42:07.160", "Score": "2", "LastEditorUserId": "916657", "LastEditDate": "2012-02-07T00:51:15.517", "Id": "9169545", "OwnerUserId": "857132", "Body": "<p><code>offsetof()</code> must be defined using pointer arithmetic.\nGCC probably doesn't like that in constant expressions because in theory the pointers could change and so it is non-<code>const</code>.\nWorkaround might be make it a <code>static int</code> without <code>const</code>?</p>\n", "LastActivityDate": "2012-02-07T00:51:15.517"}, "9169453": {"CommentCount": "5", "ViewCount": "831", "PostTypeId": "1", "LastEditorUserId": "348121", "CreationDate": "2012-02-07T00:32:43.143", "LastActivityDate": "2012-02-07T03:46:40.383", "Title": "GCC 4.4.3 offsetof constant expression bug. How should I work around this?", "AcceptedAnswerId": "9169978", "LastEditDate": "2012-02-07T01:21:06.187", "Id": "9169453", "Score": "1", "Body": "<p>I have a struct that contains a static constant expression that uses the offset macro defined in stddef.h</p>\n<pre><code>\nstruct SomeType {\n\n    int m_member;\n};\n\nstatic const size_t memberOffset = offsetof(SomeType, m_member);\n</code></pre>\n<p>in GCC 4.4.3 (I'm using Androids NDK r7) this generates the following error:</p>\n<pre><code>\narm-linux-androideabi-g++ -MMD -MP -MF ./obj/local/armeabi-v7a/... -fpic -ffunction-sections -funwind-tables -fstack-protector -D__ARM_ARCH_5__ -D__ARM_ARCH_5T__ -D__ARM_ARCH_5E__ -D__ARM_ARCH_5TE__  -Wno-psabi -march=armv7-a -mfloat-abi=softfp -mfpu=vfp -fno-exceptions -fno-rtti -O2 -fomit-frame-pointer -fstrict-aliasing -funswitch-loops -finline-limit=300 - -I/Users/Byron/bin/android-ndk-r7/sources/cxx-stl/system/include -\n -Wa,--noexecstack   -O0 -g -w -D_ANDROID   -I/blah/bin/android-ndk-r7/platforms/android-14/arch-arm/usr/include -c  \n/MyFile.h:330: error: '-&gt;' cannot appear in a constant-expression\n/MyFile.h:330: error: '&amp;' cannot appear in a constant-expression\n</code></pre>\n<p>This seems like a compiler bug. Does anyone have a good workaround for this? I found references to a bug of this nature on GCC 3.4 but not later versions. hmmm</p>\n", "Tags": "<android><c++><gcc>", "OwnerUserId": "348121", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_9169453_9169978_1": {"section_id": 2519, "quality": 0.8, "length": 12}, "so_9169453_9169978_3": {"section_id": 6706, "quality": 0.6428571428571429, "length": 18}}, "n3337": {"so_9169453_9169978_3": {"section_id": 6461, "quality": 0.6428571428571429, "length": 18}}, "n4659": {"so_9169453_9169978_5": {"section_id": 7709, "quality": 0.5454545454545454, "length": 6}, "so_9169453_9169978_1": {"section_id": 3255, "quality": 0.7333333333333333, "length": 11}, "so_9169453_9169978_3": {"section_id": 8181, "quality": 0.6071428571428571, "length": 17}}}});