post_cb({"868306": {"ViewCount": "6123", "Body": "<p>What is implicit_cast? when should I prefer implicit_cast rather than static_cast?</p>\n", "AcceptedAnswerId": "869597", "Title": "What is the difference between static_cast and Implicit_cast?", "CreationDate": "2009-05-15T12:09:20.963", "Id": "868306", "CommentCount": "5", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2009-05-15T14:40:13.877", "LastEditorDisplayName": "anon", "LastActivityDate": "2016-04-06T19:59:12.493", "Score": "11", "OwnerUserId": "22076", "Tags": "<c++><boost><implicit-cast><static-cast>", "AnswerCount": "4"}, "868434": {"Id": "868434", "PostTypeId": "2", "Body": "<p><strong>implicit_cast</strong> transforms one type to another, and can be extended by writing implicit cast functions, to cast from one type to another.</p>\n<p>e.g. </p>\n<pre><code>int i = 100;\nlong l = i;\n</code></pre>\n<p>and </p>\n<pre><code>int i = 100;\nlong l = implicit_cast&lt;long&gt;(i);\n</code></pre>\n<p>are exactly the same code</p>\n<p>however you can provide your own implicit casts for your own types, by overloading <strong>implicit_cast</strong> like the following</p>\n<pre><code>template &lt;typename T&gt;\ninline T implicit_cast (typename mpl::identity&lt;T&gt;::type x) \n{\n    return x;\n}\n</code></pre>\n<p>See here <a href=\"http://www.boost.org/doc/libs/1_39_0/boost/implicit_cast.hpp\" rel=\"nofollow noreferrer\">boost/implicit_cast.hpp</a> for more </p>\n<p>Hope this helps</p>\n<p><strong>EDIT</strong></p>\n<p>This page also talks about implicit_cast <a href=\"http://www.freshsources.com/newcpp.html\" rel=\"nofollow noreferrer\">New C++</a></p>\n<p>Also, the primary function of <strong>static_cast</strong> is to perform an non changing or semantic transformation from one type to another. The type changes but the values remain identical e.g. </p>\n<pre><code>void *voidPtr = . . .\nint* intPtr = static_cast&lt;int*&gt;(voidPtr);\n</code></pre>\n<p>I want to look at this void pointer, as if it was an int pointer, the pointer doesn't change, and under the covers voidPtr has exactly the same value as intPtr.\nAn <strong>implicit_cast</strong>, the type changes but the values after the transformation can be differnet too.</p>\n", "LastEditorUserId": "18797", "LastActivityDate": "2009-05-15T12:43:27.607", "Score": "1", "CreationDate": "2009-05-15T12:34:24.443", "ParentId": "868306", "CommentCount": "1", "OwnerUserId": "18797", "LastEditDate": "2009-05-15T12:43:27.607"}, "bq_ids": {"n4140": {"so_868306_868470_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6030}}, "n3337": {"so_868306_868470_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 5798}}, "n4659": {"so_868306_868470_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 2}}}, "869597": {"Id": "869597", "PostTypeId": "2", "Body": "<p>I'm copying over from a comment i made to <a href=\"https://stackoverflow.com/questions/385556/how-does-c-pick-which-overloaded-function-to-call/394742#394742\">answer this comment</a> at another place.</p>\n<blockquote>\n<p id=\"so_868306_869597_0\">You can down-cast with <code>static_cast</code>. Not so with <code>implicit_cast</code>. <code>static_cast</code> basically allows you to do any implicit conversion, and in addition the reverse of any implicit conversion (up to some limits. you can't downcast if there is a virtual base-class involved). But <code>implicit_cast</code> will <em>only</em> accept implicit conversions. no down-cast, no <code>void*-&gt;T*</code>, no <code>U-&gt;T</code> if T has only explicit constructors for U.</p>\n</blockquote>\n<p>Note that it's important to note the difference between a cast and a conversion. In the following no cast is going on</p>\n<pre><code>int a = 3.4;\n</code></pre>\n<p>But an implicit conversion happens from double to int. Things like an \"implicit cast\" don't exist, since a cast is always an explicit conversion request. The name construct for <code>boost::implicit_cast</code> is a lovely combination of \"cast using implicit conversions\". Now the whole implementation of <code>boost::implicit_cast</code> is this (explained <a href=\"https://stackoverflow.com/questions/862858/what-other-useful-casts-can-be-used-in-c/863761#863761\">here</a>):</p>\n<pre><code>template&lt;typename T&gt; struct identity { typedef T type; };\ntemplate&lt;typename Dst&gt; Dst implicit_cast(typename identity&lt;Dst&gt;::type t)\n{ return t; }\n</code></pre>\n<p>The idea is to use a non-deduced context for the parameter <code>t</code>. That will avoid pitfalls like the following:</p>\n<pre><code>call_const_version(implicit_cast(this)); // oops, wrong!\n</code></pre>\n<p>What was desired is to write it out like this</p>\n<pre><code>call_const_version(implicit_cast&lt;MyClass const*&gt;(this)); // right!\n</code></pre>\n<p>The compiler can't deduce what type the template parameter <code>Dst</code> should name, because it first must know what <code>identity&lt;Dst&gt;</code> is, since it is part of the parameter used for deduction. But it in turn depends on the parameter <code>Dst</code> (<code>identity</code> could be explicitly specialized for some types). Now, we got a circular dependency, for which the Standard just says such a parameter is a non-deduced context, and an explicit template-argument must be provided. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-05-15T16:14:16.037", "Score": "18", "CreationDate": "2009-05-15T16:14:16.037", "ParentId": "868306", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2017-05-23T12:33:10.147"}, "868470": {"Id": "868470", "PostTypeId": "2", "Body": "<p>Implicit conversions, explicit conversions and static_cast are all different things. however, if you can convert implicitly, you can convert explicitly, and if you can convert explicitly, you can cast statically. The same in the other direction is not true, however. There is a perfectly reasonable relationship between implicit casts and \nstatic casts. The former is a subset of the the latter.</p>\n<p>See section 5.2.9.3 of the C++ Standard for details</p>\n<blockquote>\n<p id=\"so_868306_868470_0\">Otherwise, an expression e can be\n  explicitly converted to a type T using\n  a static_cast of the form static_-\n  cast(e) if the declaration T t(e);\n  is well-formed, for some invented\n  temporary variable t (8.5).</p>\n</blockquote>\n<p>C++ encourages use of static_casts because it makes the conversion 'visible' in the program. Usage of casts itself indicates some programmer enforced rule which is worth a look so better use static_cast.</p>\n", "LastEditorUserId": "79298", "LastActivityDate": "2009-05-15T12:48:56.187", "Score": "1", "CreationDate": "2009-05-15T12:43:49.057", "ParentId": "868306", "CommentCount": "0", "OwnerUserId": "79298", "LastEditDate": "2009-05-15T12:48:56.187"}, "869100": {"Id": "869100", "PostTypeId": "2", "Body": "<p>Prefer implcit_cast if it is enough in your situation. implicit_cast is less powerful and safer than static_cast.</p>\n<p>For example, downcasting from a base pointer to a derived pointer is possible with static_cast but not with implicit_cast.  The other way around is possible with both casts. Then, when casting from a base to a derived class, use implicit_cast, because it keeps you safe if you confuse both classes.</p>\n<p>Also keep in mind that implicit_cast is often not needed.  Using no cast at all works most of the time when implicit_cast does, that's where 'implicit' comes from.  implicit_cast is only needed in special circumstances in which the type of an expression must be exactly controlled, to avoid an overload, for example.</p>\n", "LastEditorUserId": "65569", "LastActivityDate": "2016-04-06T19:59:12.493", "Score": "4", "CreationDate": "2009-05-15T14:38:21.683", "ParentId": "868306", "CommentCount": "2", "OwnerUserId": "65569", "LastEditDate": "2016-04-06T19:59:12.493"}});