post_cb({"21004879": {"CommentCount": "4", "ViewCount": "272", "PostTypeId": "1", "ClosedDate": "2014-01-08T20:04:25.200", "LastEditorUserId": "1499972", "CreationDate": "2014-01-08T19:33:01.873", "LastActivityDate": "2014-01-08T19:58:40.440", "LastEditDate": "2014-01-08T19:44:07.660", "AcceptedAnswerId": "21005208", "Title": "Why is std::move used when returning in this function", "Id": "21004879", "Score": "2", "Body": "<p>I am just reading into the algorithm.h header of the visual studio implementation of the stl and I found the following code:</p>\n<pre><code>template&lt;class _InIt,\n    class _Fn1&gt; inline\n    _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)\n    {   // perform function for each element\n    _DEBUG_RANGE(_First, _Last);\n    _DEBUG_POINTER(_Func);\n    _For_each(_Unchecked(_First), _Unchecked(_Last), _Func);\n\n    return (_STD move(_Func));\n    }\n</code></pre>\n<p>... the important part of the code is the following:</p>\n<pre><code> template&lt;class _InIt, class _Fn1&gt; \n inline _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)\n {  // perform function for each element\n    _For_each(_Unchecked(_First), _Unchecked(_Last), _Func);\n    return (std::move(_Func));\n }\n</code></pre>\n<p>... and here is the signature of the <code>_For_each</code> function</p>\n<pre><code>template&lt;class _InIt,\n    class _Fn1&gt; inline\n    void _For_each(_InIt _First, _InIt _Last, _Fn1&amp; _Func)\n</code></pre>\n<p>And my question is why is the <code>std::move</code> required when returning in this case ?\nAnd for completing the question: In what cases is required to use <code>std::move</code> when returning out of a function ? I think could be useful to have this information in a pragmatic way.</p>\n", "Tags": "<c++><c++11><stl>", "OwnerUserId": "1499972", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21004879_21005208_2": {"section_id": 1252, "quality": 0.6, "length": 9}, "so_21004879_21005208_1": {"section_id": 807, "quality": 0.5714285714285714, "length": 4}, "so_21004879_21005208_5": {"section_id": 1255, "quality": 0.8333333333333334, "length": 5}, "so_21004879_21005208_6": {"section_id": 1256, "quality": 0.8, "length": 4}, "so_21004879_21005208_3": {"section_id": 1253, "quality": 0.7857142857142857, "length": 22}}, "n3337": {"so_21004879_21005208_2": {"section_id": 1250, "quality": 0.6, "length": 9}, "so_21004879_21005208_1": {"section_id": 796, "quality": 0.5714285714285714, "length": 4}, "so_21004879_21005208_5": {"section_id": 1253, "quality": 0.8333333333333334, "length": 5}, "so_21004879_21005208_6": {"section_id": 1254, "quality": 0.8, "length": 4}, "so_21004879_21005208_3": {"section_id": 1251, "quality": 0.7857142857142857, "length": 22}}, "n4659": {"so_21004879_21005208_2": {"section_id": 1357, "quality": 0.6, "length": 9}, "so_21004879_21005208_1": {"section_id": 865, "quality": 0.5714285714285714, "length": 4}, "so_21004879_21005208_3": {"section_id": 1358, "quality": 0.7857142857142857, "length": 22}, "so_21004879_21005208_6": {"section_id": 1361, "quality": 0.8, "length": 4}, "so_21004879_21005208_5": {"section_id": 1360, "quality": 0.8333333333333334, "length": 5}}}, "21005208": {"ParentId": "21004879", "LastEditDate": "2014-01-08T19:58:40.440", "CommentCount": "0", "CreationDate": "2014-01-08T19:51:50.787", "OwnerUserId": "529761", "LastEditorUserId": "529761", "PostTypeId": "2", "Id": "21005208", "Score": "3", "Body": "<p>The short answer to your question is the C++11 standard says so.  The implementation of <code>for_each</code> is required to return a move-constructable function object/pointer.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_21004879_21005208_0\">25.2.4 For each [alg.foreach] </p>\n<p id=\"so_21004879_21005208_1\">template Function for_each(InputIterator first, InputIterator last,\n  Function f);</p>\n<p id=\"so_21004879_21005208_2\">1 Requires: Function shall meet the requirements of MoveConstructible\n  (Table 20). [ Note: Function need not meet the requirements of\n  CopyConstructible (Table 21). \u2014 end note ]</p>\n<p id=\"so_21004879_21005208_3\">2 E\ufb00ects: Applies f to the result of dereferencing every iterator in\n  the range [first,last), starting from first and proceeding to last -\n  1. [ Note: If the type of first satis\ufb01es the requirements of a mutable iterator, f may apply nonconstant functions through the dereferenced\n  iterator.\u2014 end note ]</p>\n<p id=\"so_21004879_21005208_4\">3 Returns: std::move(f).</p>\n<p id=\"so_21004879_21005208_5\">4 Complexity: Applies f exactly last - first times.</p>\n<p id=\"so_21004879_21005208_6\">5 Remarks: If f returns a result, the result is ignored.</p>\n</blockquote>\n<p>Item #3 requires <code>std::for_each</code> to return <code>std::move(fn)</code>.</p>\n<blockquote>\n<p id=\"so_21004879_21005208_7\">And my question is why is the std::move required when returning in\n  this case?</p>\n</blockquote>\n<p>The reason the standard requires it is so that the return value is guaranteed to be a move-constructable function object.</p>\n<blockquote>\n<p id=\"so_21004879_21005208_8\">And for completing the question: In what cases is required to use\n  std::move when returning out of a function?</p>\n</blockquote>\n<p>If you need to, or desire, a function's return value to be move-constructable, you would use <code>return std::move(...)</code>.  This allows you to access the state of the return value (in the <code>for_each</code> example, the state of a function object/pointer) once the function exits).</p>\n<p>For reference, Table 20 of the standard reads:</p>\n<pre><code>Table 20 \u2014 MoveConstructible requirements [moveconstructible]\nExpression           Post-condition\nT u = rv;            u is equivalent to the value of rv before the construction\nT(rv)                T(rv) is equivalent to the value of rv before the construction\n[ Note: rv remains a valid object. Its state is unspeci\ufb01ed \u2014 end note ]\n</code></pre>\n", "LastActivityDate": "2014-01-08T19:58:40.440"}});