post_cb({"29868986": {"ParentId": "29868792", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2015-04-25T18:23:53.473", "Score": "5", "LastEditorUserId": "3093378", "LastEditDate": "2015-04-25T19:17:14.777", "Id": "29868986", "OwnerUserId": "3093378", "Body": "<p>The struct version will be optimized out probably, as the compiler realizes that there's no side effects (no read or write into the variable <code>a</code>), regardless of the <code>volatile</code>. You basically have a no-op, <code>a;</code>, so the compiler can do whatever it pleases it; it is not forced to unroll the loop or to optimize it out, so the <code>volatile</code> doesn't really matter here. In the case of <code>int</code>s, there seems to be no optimizations, but this is consistent with the use case of <code>volatile</code>: you should expect non-optimizations <strong>only</strong> when you have a possible \"access to an object\" (i.e. read or write) in the loop. However what constitutes \"access to an object\" is implementation-defined (although most of the time it follows common-sense), see <strong>EDIT 3</strong> at the bottom. </p>\n<p>Toy example here:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n\nint main()\n{\n    volatile int a = 0;\n\n    const std::size_t N = 100000000;\n\n    // side effects, never optimized\n    auto start = std::chrono::steady_clock::now();\n    for (std::size_t i = 0 ; i &lt; N; ++i)\n        ++a; // side effect (write)\n    auto end = std::chrono::steady_clock::now();\n    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count()\n              &lt;&lt;  \" ms\" &lt;&lt; std::endl;\n\n    // no side effects, may or may not be optimized out\n    start = std::chrono::steady_clock::now();\n    for (std::size_t i = 0 ; i &lt; N; ++i)\n        a; // no side effect, this is a no-op\n    end = std::chrono::steady_clock::now();\n    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count()\n              &lt;&lt;  \" ms\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>EDIT</strong></p>\n<p>The no-op is not actually optimized out for scalar types, as you can see in <a href=\"http://ideone.com/PLSHrM\" rel=\"nofollow\">this minimal example</a>. For <code>struct</code>'s though, <strong>it is</strong> optimized out. In the example I linked, <code>clang</code> doesn't optimize the code with no optimization, but optimizes both loops with <code>-O3</code>. <code>gcc</code> doesn't optimize out the loops either with no optimizations, but optimizes only the first loop with optimizations on. </p>\n<p><strong>EDIT 2</strong></p>\n<p><code>clang</code> spits out an warning: <code>warning: expression result unused; assign into a variable to force a volatile load [-Wunused-volatile-lvalue]</code>. So my initial guess was correct, the compiler can optimize out no-ops, but it is not forced. Why does it do it for <code>struct</code>s and not scalar types is something that I don't understand, but it is the compiler's choice, and it is standard compliant. For some reason it gives this warning only when the no-op is a <code>struct</code>, and doesn't give the warning when it's a scalar type.</p>\n<p>Also note that you don't have a \"read/write\", you only have a no-op, so you shouldn't expect anything from <code>volatile</code>.</p>\n<p><strong>EDIT 3</strong></p>\n<p>From the golden book (C++ standard)</p>\n<p><strong>7.1.6.1/8 The cv-qualifiers [dcl.type.cv]</strong> </p>\n<blockquote>\n<p id=\"so_29868792_29868986_0\">What constitutes an access to an object that has volatile-qualified\n  type is implementation-defined. ...</p>\n</blockquote>\n<p>So it is up to the compiler to decide when to optimize out the loops. In most cases, it follows the common sense: when reading or writing into the object.</p>\n", "LastActivityDate": "2015-04-25T19:17:14.777"}, "29873914": {"ParentId": "29868792", "CommentCount": "1", "CreationDate": "2015-04-26T04:53:20.930", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "29873914", "Score": "2", "Body": "<p>This question is a lot more interesting than it first appears (for some definition of \"interesting\"). It looks like you've found a compiler bug (or intentional nonconformance), but it isn't quite the one you are expecting.</p>\n<p>According to the standard, one of your <code>foo</code> calls has undefined behavior, and the other two are ill-formed. I'll first explain what should happen; the relevant standard quotes can be found after the break. For our purposes, we can just analyze the simple expression statement <code>a, a, a;</code> given <code>volatile T a;</code>.</p>\n<p><code>a, a, a</code> in this expression statement is a discarded-value expression ([stmt.expr]/p1). The type of the expression <code>a, a, a</code> is the type of the right operand, which is the <em>id-expression</em> <code>a</code>, or <code>volatile T</code>; since <code>a</code> is an lvalue, so is the expression <code>a, a, a</code> ([expr.comma]/p1). Thus, this expression is an lvalue of a volatile-qualified type, and it is a \"comma expression where the right operand is one of these expressions\" - in particular, an <em>id-expression</em> - and therefore [expr]/p11 requires the lvalue-to-rvalue conversion be applied to the expression <code>a, a, a</code>. Similarly, inside <code>a, a, a</code>, the left expression <code>a, a</code> is also a discarded-value expression, and inside this expression the left expression <code>a</code> is also a discarded-value expression; similar logic shows that [expr]/p11 requires the lvalue-to-rvalue conversion be applied to both the result of the expression <code>a, a</code> and the result of the expression <code>a</code> (the leftmost one).</p>\n<p>If <code>T</code> is a class type (either <code>threeBytes</code> or <code>fourBytes</code>), applying the lvalue-to-rvalue conversion entails creating a temporary by copy-initialization from the volatile lvalue <code>a</code> ([conv.lval]/p2). However, the implicitly declared copy constructor always takes its argument by a non-volatile reference ([class.copy]/p8); such a reference cannot bind to a volatile object. Therefore, the program is ill-formed.</p>\n<p>If <code>T</code> is <code>int</code>, then applying the lvalue-to-rvalue conversion yields the value contained in <code>a</code>. However, in your code, <code>a</code> is never initialized; this evaluation therefore produces an indeterminate value, and per [dcl.init]/p12, results in undefined behavior.</p>\n<hr>\n<p>Standard quotes follows. All are from C++14:</p>\n<p>[expr]/p11:</p>\n<blockquote>\n<p id=\"so_29868792_29873914_0\">In some contexts, an expression only appears for its side effects.\n  Such an expression is called a <em>discarded-value expression</em>. The\n  expression is evaluated and its value is discarded. The\n  array-to-pointer (4.2) and function-to- pointer (4.3) standard\n  conversions are not applied. The lvalue-to-rvalue conversion (4.1) is\n  applied if and only if the expression is a glvalue of\n  volatile-qualified type and it is one of the following:</p>\n<ul>\n<li>( <em>expression</em> ), where <em>expression</em> is one of these expressions,</li>\n<li><em>id-expression</em> (5.1.1),</li>\n<li>[several inapplicable bullets omitted], or</li>\n<li>comma expression (5.18) where the right operand is one of these expressions.</li>\n</ul>\n<p id=\"so_29868792_29873914_1\">[ <em>Note</em>: Using an overloaded operator causes a function call; the\n  above covers only operators with built-in meaning. If the lvalue is of\n  class type, it must have a volatile copy constructor to initialize the\n  temporary that is the result of the lvalue-to-rvalue conversion. \u2014<em>end\n  note</em> ]</p>\n</blockquote>\n<p>[expr.comma]/p1:</p>\n<blockquote>\n<p id=\"so_29868792_29873914_2\">A pair of expressions separated by a comma is evaluated left-to-right;\n  the left expression is a discarded-value expression (Clause 5) [...] The type \n  and value of the result are the type and value of the right operand;\n  the result is of the same value category as its right operand [...].</p>\n</blockquote>\n<p>[stmt.expr]/p1:</p>\n<blockquote>\n<p id=\"so_29868792_29873914_3\">Expression statements have the form</p>\n<pre><code>expression-statement:\n    expression_opt;\n</code></pre>\n<p id=\"so_29868792_29873914_4\">The expression is a discarded-value expression (Clause 5).</p>\n</blockquote>\n<p>[conv.lval]/p1-2:</p>\n<blockquote>\n<p id=\"so_29868792_29873914_5\">1 A glvalue (3.10) of a non-function, non-array type <code>T</code> can be\n  converted to a prvalue. If <code>T</code> is an incomplete type, a program that\n  necessitates this conversion is ill-formed. If <code>T</code> is a non-class\n  type, the type of the prvalue is the cv-unqualified version of <code>T</code>.\n  Otherwise, the type of the prvalue is T.</p>\n<p id=\"so_29868792_29873914_6\">2 [some special rules not relevant here] In all other cases, the\n  result of the conversion is determined according to the following\n  rules:</p>\n<ul>\n<li>[inapplicable bullet omitted]</li>\n<li>Otherwise, if <code>T</code> has a class type, the conversion copy-initializes a temporary of type <code>T</code> from the glvalue and the result of the\n  conversion is a prvalue for the temporary.</li>\n<li>[inapplicable bullet omitted]</li>\n<li>Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</li>\n</ul>\n</blockquote>\n<p>[dcl.init]/p12:</p>\n<blockquote>\n<p id=\"so_29868792_29873914_7\">If no initializer is specified for an object, the object is\n  default-initialized. When storage for an object with automatic or\n  dynamic storage duration is obtained, the object has an indeterminate\n  value, and if no initialization is performed for the object, that\n  object retains an indeterminate value until that value is replaced\n  (5.17). [...] If an indeterminate value is produced by an evaluation,\n  the behavior is undefined except in the following cases: [certain\n  inapplicable exceptions related to unsigned narrow character types]</p>\n</blockquote>\n<p>[class.copy]/p8:</p>\n<blockquote>\n<p id=\"so_29868792_29873914_8\">The implicitly-declared copy constructor for a class <code>X</code> will have the\n  form</p>\n<pre><code>X::X(const X&amp;)\n</code></pre>\n<p id=\"so_29868792_29873914_9\">if each potentially constructed subobject of a class type <code>M</code> (or\n  array thereof) has a copy constructor whose first parameter is of type\n  <code>const M&amp;</code> or <code>const volatile M&amp;</code>. Otherwise, the implicitly-declared\n  copy constructor will have the form</p>\n<pre><code>X::X(X&amp;)\n</code></pre>\n</blockquote>\n</hr>", "LastActivityDate": "2015-04-26T04:53:20.930"}, "29869063": {"ParentId": "29868792", "CommentCount": "2", "CreationDate": "2015-04-25T18:31:54.257", "OwnerUserId": "4756299", "PostTypeId": "2", "Id": "29869063", "Score": "0", "Body": "<p><code>volatile</code> doesn't do what you think it does.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html</a></p>\n<p>If you're relying on <code>volatile</code> outside of the three very specific uses Boehm mentions on the page I linked, you're going to get unexpected results.</p>\n", "LastActivityDate": "2015-04-25T18:31:54.257"}, "29868792": {"CommentCount": "12", "ViewCount": "185", "PostTypeId": "1", "LastEditorUserId": "2294360", "CreationDate": "2015-04-25T18:03:06.790", "LastActivityDate": "2015-04-27T05:17:52.670", "Title": "Volatile specifier ignored in C++", "AcceptedAnswerId": "29868986", "LastEditDate": "2015-04-27T05:17:52.670", "Id": "29868792", "Score": "1", "Body": "<p>I'm pretty new to C++ and recently I ran across some info on what it means for a variable to be <code>volatile</code>.As far as I understood, it means a read or write to the variable can <em>never</em> be optimized out of existence. </p>\n<p>However a weird situation arises when I declare a <code>volatile</code> variable that isn't 1, 2, 4, 8 bytes large: the compiler(gnu with C++11 enabled) seemingly ignores the <code>volatile</code> specifier. Code kinda looks like this:</p>\n<pre><code>#define expand1 a, a, a, a, a, a, a, a, a, a\n#define expand2 //ten expand1 here, expand3 to expand5 follows\n//expand5 is the equivalent of 1e+005 a, a, ....\nstruct threeBytes{char x,y,z;};\nstruct fourBytes{char w,x,y,z;};\nint main()\n{\n   //reads int 1e+010 times, requires ~1.5sec\n   foo&lt;int&gt;();\n   //reads threeBytes 1e+010 times, doesn't take time, probably means didn't read\n   foo&lt;threeBytes&gt;();\n   //reads fourBytes 1e+010 times, requires ~1.5sec\n   foo&lt;fourBytes&gt;();\n}\ntemplate&lt;typename T&gt;\nvoid foo()\n{\n   volatile T a;\n   //time an empty for loop\n   //for my settings, it does indeed take time and isn't optimized out\n   clock_t start = clock();\n   for(int i = 0; i &lt; 100000; i++);\n   clock_t end = clock();\n   int interval = end - start;\n\n   //run expand5 for 1e+005 times\n   start = clock();\n   for(int i = 0; i &lt; 100000; i++) expand5;\n   end = clock();\n\n   //compare time difference and print result\n   cout &lt;&lt; end - start - interval &lt;&lt; endl;\n}\n</code></pre>\n<p>The result is the <code>int</code> version will give me ~1.5 seconds while the <code>threeBytes</code> version will give exactly 0. I've tested it with different variables(user-defined or not) that is 1 to 8 bytes and only 1, 2, 4, 8 takes time to run. Is this a bug only existing on my PC or is <code>volatile</code> a request to the compiler and not something absolute?</p>\n<p>PS the four byte versions always take half the time as others on my PC and is also a source of confusion</p>\n", "Tags": "<c++><templates><c++11><volatile>", "OwnerUserId": "4832499", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29868792_29873914_0": {"section_id": 5944, "quality": 0.8235294117647058, "length": 28}, "so_29868792_29873914_8": {"section_id": 457, "quality": 0.875, "length": 7}, "so_29868792_29873914_2": {"section_id": 6182, "quality": 0.9615384615384616, "length": 25}, "so_29868792_29873914_4": {"section_id": 3880, "quality": 0.8, "length": 4}, "so_29868792_29873914_1": {"section_id": 5944, "quality": 0.8888888888888888, "length": 24}, "so_29868792_29873914_5": {"section_id": 8, "quality": 0.9545454545454546, "length": 21}, "so_29868792_29873914_7": {"section_id": 3291, "quality": 0.8409090909090909, "length": 37}, "so_29868792_29873914_6": {"section_id": 9, "quality": 0.6428571428571429, "length": 9}, "so_29868792_29868986_0": {"section_id": 5435, "quality": 1.0, "length": 7}, "so_29868792_29873914_3": {"section_id": 3880, "quality": 1.0, "length": 4}, "so_29868792_29873914_9": {"section_id": 457, "quality": 1.0, "length": 24}}, "n3337": {"so_29868792_29873914_8": {"section_id": 448, "quality": 0.875, "length": 7}, "so_29868792_29873914_2": {"section_id": 5943, "quality": 0.9615384615384616, "length": 25}, "so_29868792_29873914_0": {"section_id": 5715, "quality": 0.7941176470588235, "length": 27}, "so_29868792_29873914_5": {"section_id": 5, "quality": 0.9545454545454546, "length": 21}, "so_29868792_29873914_4": {"section_id": 3740, "quality": 0.8, "length": 4}, "so_29868792_29873914_3": {"section_id": 3740, "quality": 1.0, "length": 4}, "so_29868792_29873914_9": {"section_id": 448, "quality": 0.875, "length": 21}}, "n4659": {"so_29868792_29873914_8": {"section_id": 480, "quality": 0.875, "length": 7}, "so_29868792_29873914_2": {"section_id": 7684, "quality": 0.9615384615384616, "length": 25}, "so_29868792_29873914_0": {"section_id": 7429, "quality": 0.6764705882352942, "length": 23}, "so_29868792_29873914_7": {"section_id": 4053, "quality": 0.8409090909090909, "length": 37}, "so_29868792_29873914_4": {"section_id": 4769, "quality": 0.8, "length": 4}, "so_29868792_29873914_5": {"section_id": 8, "quality": 0.9545454545454546, "length": 21}, "so_29868792_29868986_0": {"section_id": 6862, "quality": 0.5714285714285714, "length": 4}, "so_29868792_29873914_1": {"section_id": 7429, "quality": 0.8518518518518519, "length": 23}, "so_29868792_29873914_3": {"section_id": 4769, "quality": 1.0, "length": 4}, "so_29868792_29873914_9": {"section_id": 480, "quality": 1.0, "length": 24}}}});