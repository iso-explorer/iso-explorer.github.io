post_cb({"8762706": {"Id": "8762706", "PostTypeId": "2", "Body": "<p>It's tightly coupled as per standard. It's a wrapper around a compiler-constructed array (though the standard doesn't say how precisely \u2014 GCC uses constructor with pointer and size, MSVC uses constructor with two points). And yes, it's required to be in namespace <code>std</code>, and in header <code>&lt;initializer_list&gt;</code>.</p>\n<p>You'd have to see what constructors they use in each compiler you want to support and replicate that in your version, but TBH, I fail to see the point.</p>\n<blockquote>\n<p id=\"so_8762459_8762706_0\">The template <code>std::initializer_list</code> is not prede\ufb01ned; if the header <code>&lt;initializer_list&gt;</code> is not included prior to a use of <code>std::initializer_list</code> \u2014 even an implicit use in which the type is not named (7.1.6.4) \u2014 the program is ill-formed.</p>\n<p id=\"so_8762459_8762706_1\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated an array of N elements of type E, where N is the number of elements in the initializer list.\n  Each element of that array is copy-initialized with the corresponding element of the initializer list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array.</p>\n</blockquote>\n", "LastActivityDate": "2012-01-06T18:35:35.883", "CommentCount": "2", "CreationDate": "2012-01-06T18:35:35.883", "ParentId": "8762459", "Score": "4", "OwnerUserId": "16102"}, "bq_ids": {"n4140": {"so_8762459_8762706_1": {"length": 29, "quality": 1.0, "section_id": 3327}, "so_8762459_8762706_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 3324}}, "n3337": {"so_8762459_8762706_1": {"length": 29, "quality": 1.0, "section_id": 3197}, "so_8762459_8762706_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 3194}}, "n4659": {"so_8762459_8762706_1": {"length": 26, "quality": 0.896551724137931, "section_id": 4093}, "so_8762459_8762706_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 4090}}}, "8762459": {"ViewCount": "495", "Body": "<p>Can I achieve the same effects without the C++ header <code>&lt;initializer_list&gt;</code>?</p>\n<p>Does <code>class initializer_list</code> have to live in <code>namespace std</code> (does the compiler require this)?</p>\n<p>I'm fine with a solution that works on the big five (GCC, MSVC, Intel, Clang, Comeau)</p>\n", "AcceptedAnswerId": "8762706", "Title": "How tightly coupled is the compiler's brace-initializer-list to the type `std::initializer_list`?", "CreationDate": "2012-01-06T18:14:13.860", "Id": "8762459", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-01-06T18:20:34.553", "LastEditorUserId": "440119", "LastActivityDate": "2012-01-06T18:35:35.883", "Score": "2", "OwnerUserId": "256138", "Tags": "<c++><c++11><initializer-list>", "AnswerCount": "1"}});