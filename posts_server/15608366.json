post_cb({"bq_ids": {"n4140": {"so_15608366_15608422_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}}, "n3337": {"so_15608366_15608422_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}}}, "15608422": {"LastActivityDate": "2013-08-02T19:59:13.707", "CommentCount": "5", "Body": "<p>Pointer arithmetic on a pointer not pointing to an array is Undefined behavior.<br>\nAlso, Dereferencing a NULL pointer is undefined behavior.     </br></p>\n<pre><code>char *c = NULL;\nc--;\n</code></pre>\n<p>is Undefined defined behavior because <code>c</code> does not point to an array.</p>\n<p><strong>C++11 Standard 5.7.5:</strong></p>\n<blockquote>\n<p id=\"so_15608366_15608422_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. In other words, if the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N (where N has the value n) point to, respectively, the i + n-th and i \u2212 n-th elements of the array object, provided they exist. Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n", "CreationDate": "2013-03-25T05:45:12.670", "LastEditDate": "2013-08-02T19:59:13.707", "ParentId": "15608366", "Id": "15608422", "LastEditorUserId": "90002", "PostTypeId": "2", "Score": "19", "OwnerUserId": "452307"}, "17979772": {"CommentCount": "6", "Body": "<p>Yes, this is undefined behavior, and is something that <code>-fsanitize=undefined</code> should have caught; it's already on my TODO list to add a check for this.</p>\n<p>FWIW, the C and C++ rules here are slightly different: adding <code>0</code> to a null pointer and subtracting one null pointer from another have undefined behavior in C but not in C++. All other arithmetic on null pointers has undefined behavior in both languages.</p>\n", "CreationDate": "2013-07-31T19:59:02.813", "ParentId": "15608366", "Id": "17979772", "LastActivityDate": "2013-07-31T19:59:02.813", "PostTypeId": "2", "Score": "14", "OwnerUserId": "1041090"}, "15608366": {"CreationDate": "2013-03-25T05:41:05.323", "ViewCount": "2139", "FavoriteCount": "1", "Id": "15608366", "AcceptedAnswerId": "15608422", "Score": "14", "Title": "Is performing arithmetic on a null pointer undefined behavior?", "LastEditorUserId": "90002", "CommentCount": "16", "Body": "<p>It looks to me like the following program computes an invalid pointer, since <code>NULL</code> is no good for anything but assignment and comparison for equality:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n\n  char *c = NULL;\n  c--;\n\n  printf(\"c: %p\\n\", c);\n\n  return 0;\n}\n</code></pre>\n<p>However, it seems like none of the warnings or instrumentations in GCC or Clang targeted at undefined behavior say that this is in fact UB. Is that arithmetic actually valid and I'm being too pedantic, or is this a deficiency in their checking mechanisms that I should report?</p>\n<p>Tested:</p>\n<pre><code>$ clang-3.3 -Weverything -g -O0 -fsanitize=undefined -fsanitize=null -fsanitize=address offsetnull.c -o offsetnull\n$ ./offsetnull\nc: 0xffffffffffffffff\n\n$ gcc-4.8 -g -O0 -fsanitize=address offsetnull.c -o offsetnull\n$ ./offsetnull \nc: 0xffffffffffffffff\n</code></pre>\n<p>It seems to be pretty well documented that AddressSanitizer as used by Clang and GCC is  more focused on dereference of bad pointers, so that's fair enough. But the other checks don't catch it either :-/</p>\n<p><strong>Edit</strong>: part of the reason that I asked this question is that the <code>-fsanitize</code> flags enable <em>dynamic</em> checks of well-definedness in the generated code. Is this something they should have caught?</p>\n", "Tags": "<c++><c><language-lawyer><undefined-behavior><null-pointer>", "LastEditDate": "2015-08-04T20:25:09.043", "LastActivityDate": "2015-11-12T17:23:08.673", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "90002"}, "31819281": {"LastActivityDate": "2015-11-12T17:23:08.673", "CommentCount": "0", "Body": "<p>Not only is arithmetic on a null pointer forbidden, but the failure of implementations which trap attempted dereferences to also trap arithmetic on null pointers greatly degrades the benefit of null-pointer traps.</p>\n<p>There is never any situation defined by the Standard where adding anything to a null pointer can yield a legitimate pointer value; further, situations in which implementations could define any useful behavior for such actions are rare and could generally better be handled via compiler intrinsics(*).  On many implementations, however, if null-pointer arithmetic isn't trapped, adding an offset to a null pointer can yield a pointer which, while not valid, is no longer <em>recognizable</em> as a null pointer.  An attempt to dereference such a pointer would not be trapped, but could trigger arbitrary effects.</p>\n<p>Trapping pointer computations of the form (null+offset) and (null-offset) would eliminate this danger.  Note that protection would not necessarily require trapping (pointer-null), (null-pointer), or (null-null), while the values returned by the first two expressions would be unlikely to have any usefulness [if an implementation were to specify that null-null would yield zero, code which targeted that particular implementation might sometimes be more efficient than code which had to special-case <code>null</code>] they would not generate invalid pointers.  Further, having (null+0) and (null-0) either yield null pointers rather than trapping would not jeopardize safety and may avoid the need to have user code special-case null pointers, but the advantages would be less compelling since the compiler would have to add extra code to make that happen.</p>\n<p>(*) Such an intrinsic on an 8086 compilers, for example, might accept an unsigned 16-bit integers \"seg\" and \"ofs\", and read the word at address seg:ofs without a null trap even when address happened to be zero.  Address (0x0000:0x0000) on the 8086 is an interrupt vector which some programs may need to access, and while address (0xFFFF:0x0010) accesses the same physical location as (0x0000:0x0000) on older processors with only 20 address lines, it accesses physical location 0x100000 on processors with 24 or more address lines).  In some cases an alternative would be to have a special designation for pointers which are <em>expected</em> to point to things not recognized by the C standard (things like the interrupt vectors would qualify) and refrain from null-trapping those, or else to specify that <code>volatile</code> pointers will be treated in such fashion.  I've seen the first behavior in at least one compiler, but don't think I've seen the second.</p>\n", "CreationDate": "2015-08-04T21:03:35.387", "LastEditDate": "2015-11-12T17:23:08.673", "ParentId": "15608366", "Id": "31819281", "LastEditorUserId": "363751", "PostTypeId": "2", "Score": "6", "OwnerUserId": "363751"}});