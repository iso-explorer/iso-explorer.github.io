post_cb({"bq_ids": {"n4140": {"so_16776444_16776444_2": {"length": 5, "quality": 0.625, "section_id": 5356}}, "n3337": {"so_16776444_16776444_2": {"length": 5, "quality": 0.625, "section_id": 5153}}, "n4659": {"so_16776444_16776444_2": {"length": 5, "quality": 0.625, "section_id": 6781}}}, "16776649": {"Id": "16776649", "PostTypeId": "2", "Body": "<p>The answer below is based on explanation from <code>C++ Templates: The complete guide  pp57: Using String literals as Arguments for Function templates</code>.</p>\n<pre><code>template &lt;class T&gt;\nint compare(const T&amp; v1, const T&amp; v2) {\n    if(v1&lt;v2) return -1;\n    if(v2&lt;v1) return 1;\n    return 0;\n}\n</code></pre>\n<p>This requires that both parameters <code>v1</code> and <code>v2</code> have the same type.</p>\n<pre><code>template &lt;&gt;\nint compare&lt;const char*&gt;(const char* const &amp;v1, const char* const &amp;v2){\n    return strcmp(v1,v2);\n}\n</code></pre>\n<p>This requires that you have parameters with <code>const char *</code> type.</p>\n<p>However, <code>\"abc\"</code> has type <code>char const[4]</code> whereas <code>\"defg\"</code> has type <code>char const[5]</code>. They are different types. Since both the specialized and templated version required reference parameters, there is no array-to-pointer decay during argument deduction. Therefore, you cannot pass different length string literals to both of them to find a match. If you provide a regular function, which does not require any argument deduction, the compiler will find a match.</p>\n<p>If you declare non-reference parameters, you can substitute them with string literals of different length. The reason for this behavior is that during argument deduction <code>array-to-pointer</code> conversion (often called decay) occurs only if the paramter does not have a reference type.</p>\n", "LastEditorUserId": "1760345", "LastActivityDate": "2013-05-27T16:01:20.900", "Score": "5", "CreationDate": "2013-05-27T15:49:16.767", "ParentId": "16776444", "CommentCount": "1", "OwnerUserId": "1760345", "LastEditDate": "2013-05-27T16:01:20.900"}, "16776976": {"Id": "16776976", "PostTypeId": "2", "Body": "<p>Template specializations do not participate in <em>overload resolution</em> process. Only the primary template is considered by overload resolution. </p>\n<p>Template specializations come into play only later and only if their primary template \"wins\" overload resolution. I.e. template specializations are used in the process of <em>specialization</em> (as the name suggests), they are completely invisible during overload resolution.</p>\n<p>For this reason, in your first example, you have only one candidate considered by overload resolution</p>\n<pre><code>template &lt;class T&gt; int compare(const T&amp; v1, const T&amp; v2);\n</code></pre>\n<p>In order to succeed, this candidate should pass through template argument deduction for your set of arguments. (Template argument deduction process does not care about any additional specializations either.) Template argument deduction fails in this case, since for argument of array type template parameter <code>T</code> is deduced as an array. And you get incompatible deductions for two arguments. The compiler gave you the error message that describes the problem. In other words, in your first example the specialized version of the template never has a chance to come into play.</p>\n<p>In your second example, where you replaced specialization with overloading, you provided a second candidate for overload resolution. Now the compiler sees both</p>\n<pre><code>template &lt;class T&gt; int compare(const T&amp; v1, const T&amp; v2);\nint compare(const char* const&amp; v1, const char* const&amp; v2);\n</code></pre>\n<p>The template candidate fails just like it did before, while the overloaded candidate succeeds.</p>\n<p>To better illustrate the how template specializations work in this case, we can take your original code and change the primary template in order to help it to pass through overload resolution by decoupling the parameters from each other. If in your first example you change the template declaration to</p>\n<pre><code>template &lt;class T1, class T2&gt;\nint compare(const T1&amp; v1, const T2&amp; v2) {\n  ...\n</code></pre>\n<p>leaving everything else unchanged, the code will compile <strike>and it will use your specialization</strike>. But even in that case the primary template with deduced parameters will be seen as a better match to your arguments (immediate reference binding with no conversions).</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-05-27T17:16:52.440", "Score": "2", "CreationDate": "2013-05-27T16:11:10.333", "ParentId": "16776444", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2013-05-27T17:16:52.440"}, "16776444": {"ViewCount": "2564", "Body": "<p>This is an example from <em>C++ Primer, 4th edition, Chapter 16</em> and it's about <strong>template specialization</strong>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\ntemplate &lt;class T&gt;\nint compare(const T&amp; v1, const T&amp; v2) {\n    if(v1&lt;v2) return -1;\n    if(v2&lt;v1) return 1;\n    return 0;\n}\n\ntemplate &lt;&gt;\nint compare&lt;const char*&gt;(const char* const &amp;v1, const char* const &amp;v2){\n    return strcmp(v1,v2);\n}\n\nint main(int argc, const char *argv[])\n{\n    cout &lt;&lt; compare(\"abc\",\"defg\") &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>I expect <code>compare(\"abc\",\"defg\")</code> will call the specialized version of the template.\nBut the fact is, g++ 4.6.3 won't compile this code and give the follow error:</p>\n<blockquote>\n<p id=\"so_16776444_16776444_0\">error: no matching function for call to 'compare(const char [4], const\n  char [5])'</p>\n<p id=\"so_16776444_16776444_1\">note: candidate is:\u3000template int compare(const T&amp;,\n  const T&amp;)</p>\n</blockquote>\n<p>Now given the following facts:</p>\n<blockquote>\n<p id=\"so_16776444_16776444_2\">I. string literals, or C-style string in C++ is actually a <strong>const\n  char array</strong>.</p>\n<p id=\"so_16776444_16776444_3\">II. If passed as plain, non-reference types, an array will be\n  converted to a pointer to its first element quietly.</p>\n</blockquote>\n<p>Here I just pass string literals \"abc\" and \"defg\" as <strong>reference to</strong> <code>const char*</code>, and I expect they will be converted to <code>const char*</code> first and then passed <strong>by reference</strong>.\nBut it seems that g++ disagree with me and refuse to compile the code.</p>\n<p>But if I replace template specialization with function overloading, that is, replace</p>\n<pre><code>template &lt;&gt;\nint compare&lt;const char*&gt;(const char* const &amp;v1, const char* const &amp;v2){\n    return strcmp(v1,v2);\n}\n</code></pre>\n<p>with </p>\n<pre><code>int compare(const char* const&amp; v1, const char* const&amp; v2){\n    return strcmp(v1,v2);\n}\n</code></pre>\n<p>then g++ will be happy to compile it.</p>\n<p>So where on earth does the problem lie? Why I cannot pass string literals by parameter type  <code>const char* const&amp;</code> in the template specialization version ?</p>\n", "AcceptedAnswerId": "16776649", "Title": "Passing string literals by reference to const char* fails to compile with g++ 4.6.3", "CreationDate": "2013-05-27T15:37:18.747", "Id": "16776444", "CommentCount": "6", "LastEditDate": "2013-05-27T16:06:49.033", "PostTypeId": "1", "LastEditorUserId": "2128733", "LastActivityDate": "2013-05-27T17:16:52.440", "Score": "5", "OwnerUserId": "2128733", "Tags": "<c++><templates><pointers>", "AnswerCount": "2"}});