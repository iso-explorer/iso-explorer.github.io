post_cb({"12628843": {"Id": "12628843", "PostTypeId": "2", "Body": "<p>This is standard conforming C++.</p>\n<p>A reasonable application of nested classes (through scope resolution) is the pImpl design pattern (though you can implement it in a way that will not demonstrate nested classes, but here I choose to demonstrate nested classes).\nNote: Inheritance is one of the facets that can be confusing but the real concept is the scope resolution of a nested class.</p>\n<pre><code>//ExposedClass in Exposed.h\n\nclass CExposedClass\n{\npublic:\nCExposedClass();\n~CExposedClass();\nvoid doThis();\nvoid doThat();\n\nprivate:\nclass CXImpl;\nCXImpl *pImpl;\n\n};\n\n//ExposedClass Impl in Exposed.cpp\n\n#include \"Exposed.h\"\n\nclass CExposedClass::CXImpl\n{\n int someData;\n};\n\nCExposedClass::CExposedClass():pImpl(new CXImpl()){}\nCExposedClass::~CExposedClass(){delete pImpl;}\nvoid CExposedClass::doThis(){}\nvoid CExposedClass::doThat(){}\n</code></pre>\n<p>class defined within the scope of one class is addressed from another scope using scope resolution.</p>\n", "LastEditorUserId": "1201507", "LastActivityDate": "2012-09-27T19:43:56.383", "Score": "0", "CreationDate": "2012-09-27T19:38:05.247", "ParentId": "12628725", "CommentCount": "0", "OwnerUserId": "1201507", "LastEditDate": "2012-09-27T19:43:56.383"}, "12628725": {"ViewCount": "195", "Body": "<p>Is the following code valid with C++ standard? It's strange that C::B would work because struct B is in A's namespace. But it does compile fine with gcc.</p>\n<pre><code>struct A { struct B {}; };\nstruct C : public A::B {};\nstruct D : public C::B {};\n</code></pre>\n<p>If this is standard conforming C++, what are reasonable applications for this construct?\nThanks.</p>\n", "AcceptedAnswerId": "12628805", "Title": "Unintuitive nested class inheritance", "CreationDate": "2012-09-27T19:29:22.380", "Id": "12628725", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-09-27T19:43:56.383", "Score": "2", "OwnerUserId": "1704403", "Tags": "<c++><inheritance><gcc>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12628725_12628805_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5846}}, "n3337": {"so_12628725_12628805_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5616}}, "n4659": {"so_12628725_12628805_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 7325}}}, "12628805": {"Id": "12628805", "PostTypeId": "2", "Body": "<p>Yes, it's valid C++.  A class in its own scope (so both <code>B</code> and <code>B::B</code> refer to the same class <code>B</code>), and a class's parent class is in its own scope.  So since <code>B</code> is in <code>C</code>'s scope and <code>B</code> is in its own scope, <code>C::B</code> refers to <code>B</code> which is <code>A::B</code>.</p>\n<p>(Side note: do not confuse a <em>namespace</em> with a <em>scope</em>.)</p>\n<p>C++03 \u00a79 paragraph 2 says:</p>\n<blockquote>\n<p id=\"so_12628725_12628805_0\">A <em>class-name</em> is inserted into the scope in which it is declared immediately after the <em>class-name</em> is seen.\n  The <em>class-name</em> is also inserted into the scope of the class itself; this is known as the <em>injected-class-name</em>.\n  For purposes of access checking, the <em>injected-class-name</em> is treated as if it were a public member name.</p>\n</blockquote>\n", "LastEditorUserId": "9530", "LastActivityDate": "2012-09-27T19:40:41.033", "Score": "3", "CreationDate": "2012-09-27T19:34:55.700", "ParentId": "12628725", "CommentCount": "1", "OwnerUserId": "9530", "LastEditDate": "2012-09-27T19:40:41.033"}});