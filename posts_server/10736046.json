post_cb({"10736409": {"Id": "10736409", "PostTypeId": "2", "Body": "<p>I think <a href=\"https://stackoverflow.com/questions/7095556/how-to-handle-evolving-c-std-namespace-e-g-stdtr1shared-ptr-vs-std\">this question</a> is very similar to what you are asking about.</p>\n<p>In particular, I like the answer which says \"use autoconf to detect symbols availability and then use conditional defines to alias the right namespace with a given name\".</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-05-24T11:15:27.880", "Score": "3", "CreationDate": "2012-05-24T11:15:27.880", "ParentId": "10736046", "CommentCount": "0", "OwnerUserId": "69178", "LastEditDate": "2017-05-23T12:11:28.667"}, "10736714": {"Id": "10736714", "PostTypeId": "2", "Body": "<p>This kind of portability should only be attempted if you have a proof that you cannot support a particular library in a clearer way, and ideally you should surround it with <code>#ifdef</code>s specific to that particular environment.</p>\n<p>The point of <code>tr1</code> was to isolate your <code>std</code> from the stuff in <code>tr1</code>.</p>\n", "LastActivityDate": "2012-05-24T11:35:59.837", "CommentCount": "0", "CreationDate": "2012-05-24T11:35:59.837", "ParentId": "10736046", "Score": "1", "OwnerUserId": "1235565"}, "bq_ids": {"n4140": {"so_10736046_10736392_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6299}, "so_10736046_10736099_0": {"length": 26, "quality": 0.6046511627906976, "section_id": 6299}}, "n3337": {"so_10736046_10736099_0": {"length": 26, "quality": 0.6046511627906976, "section_id": 6056}, "so_10736046_10736392_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6056}}, "n4659": {"so_10736046_10736099_0": {"length": 26, "quality": 0.6046511627906976, "section_id": 7808}, "so_10736046_10736392_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7808}}}, "10736392": {"Id": "10736392", "PostTypeId": "2", "Body": "<p>Importing stuff into <code>::std</code> is forbidden by C++11 17.6.4.2.1:</p>\n<blockquote>\n<p id=\"so_10736046_10736392_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace <code>std</code> unless otherwise specified.</p>\n</blockquote>\n", "LastActivityDate": "2012-05-24T11:13:51.943", "CommentCount": "0", "CreationDate": "2012-05-24T11:13:51.943", "ParentId": "10736046", "Score": "7", "OwnerUserId": "204847"}, "10736099": {"Id": "10736099", "PostTypeId": "2", "Body": "<p>You should not touch the <code>std</code> namespace: even if it works now, it can cause severe headaches later (with a new version of the compiler, on a different compiler, etc).</p>\n<p>Update: Quote from the standard (C++ 2003, Section 17.4.3.1 \"Reserved names\") (found <a href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/MSC34-CPP.+Do+not+modify+the+standard+namespace\" rel=\"noreferrer\">here</a>):</p>\n<blockquote>\n<p id=\"so_10736046_10736099_0\">It is <strong>undefined</strong> for a C++ program to <strong>add declarations or definitions to namespace std</strong> or namespaces within namespace std unless otherwise specified. A program may add template specializations for any standard library template to namespace std. Such a specialization (complete or partial) of a standard library template results in undefined behavior unless the declaration depends on a user-defined type of external linkage and unless the specialization meets the standard library requirements for the original template. [emphasis mine]</p>\n</blockquote>\n", "LastEditorUserId": "20322", "LastActivityDate": "2012-05-24T11:14:48.177", "Score": "16", "CreationDate": "2012-05-24T10:55:53.020", "ParentId": "10736046", "CommentCount": "8", "OwnerUserId": "20322", "LastEditDate": "2012-05-24T11:14:48.177"}, "10736046": {"ViewCount": "695", "Body": "<p>I have C++03 code that looks like this:</p>\n<pre><code>#include &lt;boost/tr1/unordered_map.hpp&gt;\n...\nstd::tr1::unordered_map&lt;std::string, int&gt; mystuff;\n...\n</code></pre>\n<p>I started to wonder that i would suffer later if/when i convert my code to C++11, which (i guess) doesn't have <code>std::tr1::unordered_map</code> but has <code>std::unordered_map</code> instead. So i came up with the following hack:</p>\n<pre><code>namespace std\n{\n    using namespace ::std::tr1;\n}\n...\nstd::unordered_map&lt;std::string, int&gt; mystuff; // no tr1 now!\n...\n</code></pre>\n<p>Is it legal (maybe importing stuff into <code>std</code> is forbidden)? Will it make it easier to port/interoperate with C++11 code?</p>\n", "AcceptedAnswerId": "10736099", "Title": "Importing std::tr1 into std - is it legal? Does it improve portability?", "CreationDate": "2012-05-24T10:52:11.617", "Id": "10736046", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-05-24T11:35:59.837", "Score": "14", "OwnerUserId": "509868", "Tags": "<c++><compatibility><tr1>", "AnswerCount": "4"}});