post_cb({"19250874": {"ParentId": "121162", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This answer is about object creation with/without an explicit constructor since it is not covered in the other answers.</p>\n<p>Consider the following class without an explicit constructor:</p>\n<pre><code>class Foo\n{\npublic:\n    Foo(int x) : m_x(x)\n    {\n    }\n\nprivate:\n    int m_x;\n};\n</code></pre>\n<p>Objects of class Foo can be created in 2 ways:</p>\n<pre><code>Foo bar1(10);\n\nFoo bar2 = 20;\n</code></pre>\n<p>Depending upon the implementation, the second manner of instantiating class Foo may be confusing, or not what the programmer intended. Prefixing the <code>explicit</code> keyword to the constructor would generate a compiler error at <code>Foo bar2 = 20;</code>.</p>\n<p>It is <em>usually</em> good practice to declare single-argument constructors as <code>explicit</code>, unless your implementation specifically prohibits it.</p>\n<p>Note also that constructors with</p>\n<ul>\n<li>default arguments for all parameters, or</li>\n<li>default arguments for the second parameter onwards</li>\n</ul>\n<p>can both be used as single-argument constructors. So you may want to make these also <code>explicit</code>.</p>\n<p>An example when you would deliberately <strong><em>not</em></strong> want to make your single-argument constructor explicit is if you're creating a functor (look at the 'add_x' struct declared in <a href=\"https://stackoverflow.com/a/356993/793930\">this</a> answer). In such a case, creating an object as <code>add_x add30 = 30;</code> would probably make sense.</p>\n<p><a href=\"http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx\" rel=\"nofollow noreferrer\">Here</a> is a good write-up on explicit constructors.</p>\n", "OwnerUserId": "793930", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:32.423", "Id": "19250874", "Score": "30", "CreationDate": "2013-10-08T14:43:46.483", "LastActivityDate": "2013-10-09T13:19:37.913"}, "31351956": {"ParentId": "121162", "PostTypeId": "2", "CommentCount": "0", "Body": "<h3>The keyword <code>explicit</code> accompanies either</h3>\n<ul>\n<li><strong>a constructor of class X that cannot be used to implicitly convert the first (any only) parameter to type X</strong></li>\n</ul>\n<blockquote>\n<p id=\"so_121162_31351956_0\"><strong>C++ [class.conv.ctor]</strong></p>\n<p id=\"so_121162_31351956_1\">1) A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</p>\n<p id=\"so_121162_31351956_2\">2) An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization\n  (8.5).</p>\n</blockquote>\n<ul>\n<li><strong>or a conversion function that is only considered for direct initialization and explicit conversion.</strong></li>\n</ul>\n<blockquote>\n<p id=\"so_121162_31351956_3\"><strong>C++ [class.conv.fct]</strong></p>\n<p id=\"so_121162_31351956_4\">2) A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments\n  and initializations.</p>\n</blockquote>\n<h3>Overview</h3>\n<p>Explicit conversion functions and constructors can only be used for explicit conversions (direct initialization or explicit cast operation) while non-explicit constructors and conversion functions can be used for implicit as well as explicit conversions.</p>\n<pre><code>/*\n                                 explicit conversion          implicit conversion\n\n explicit constructor                    yes                          no\n\n constructor                             yes                          yes\n\n explicit conversion function            yes                          no\n\n conversion function                     yes                          yes\n\n*/\n</code></pre>\n<h3>Example using structures <code>X, Y, Z</code> and functions <code>foo, bar, baz</code>:</h3>\n<p>Let's look at a small setup of structures and functions to see the difference between <code>explicit</code> and non-<code>explicit</code> conversions.</p>\n<pre><code>struct Z { };\n\nstruct X { \n  explicit X(int a); // X can be constructed from int explicitly\n  explicit operator Z (); // X can be converted to Z explicitly\n};\n\nstruct Y{\n  Y(int a); // int can be implicitly converted to Y\n  operator Z (); // Y can be implicitly converted to Z\n};\n\nvoid foo(X x) { }\nvoid bar(Y y) { }\nvoid baz(Z z) { }\n</code></pre>\n<h3>Examples regarding constructor:</h3>\n<p>Conversion of a function argument:</p>\n<pre><code>foo(2);                     // error: no implicit conversion int to X possible\nfoo(X(2));                  // OK: direct initialization: explicit conversion\nfoo(static_cast&lt;X&gt;(2));     // OK: explicit conversion\n\nbar(2);                     // OK: implicit conversion via Y(int) \nbar(Y(2));                  // OK: direct initialization\nbar(static_cast&lt;Y&gt;(2));     // OK: explicit conversion\n</code></pre>\n<p>Object initialization:</p>\n<pre><code>X x2 = 2;                   // error: no implicit conversion int to X possible\nX x3(2);                    // OK: direct initialization\nX x4 = X(2);                // OK: direct initialization\nX x5 = static_cast&lt;X&gt;(2);   // OK: explicit conversion \n\nY y2 = 2;                   // OK: implicit conversion via Y(int)\nY y3(2);                    // OK: direct initialization\nY y4 = Y(2);                // OK: direct initialization\nY y5 = static_cast&lt;Y&gt;(2);   // OK: explicit conversion\n</code></pre>\n<h3>Examples regarding conversion functions:</h3>\n<pre><code>X x1{ 0 };\nY y1{ 0 };\n</code></pre>\n<p>Conversion of a function argument:</p>\n<pre><code>baz(x1);                    // error: X not implicitly convertible to Z\nbaz(Z(x1));                 // OK: explicit initialization\nbaz(static_cast&lt;Z&gt;(x1));    // OK: explicit conversion\n\nbaz(y1);                    // OK: implicit conversion via Y::operator Z()\nbaz(Z(y1));                 // OK: direct initialization\nbaz(static_cast&lt;Z&gt;(y1));    // OK: explicit conversion\n</code></pre>\n<p>Object initialization:</p>\n<pre><code>Z z1 = x1;                  // error: X not implicitly convertible to Z\nZ z2(x1);                   // OK: explicit initialization\nZ z3 = Z(x1);               // OK: explicit initialization\nZ z4 = static_cast&lt;Z&gt;(x1);  // OK: explicit conversion\n\nZ z1 = y1;                  // OK: implicit conversion via Y::operator Z()\nZ z2(y1);                   // OK: direct initialization\nZ z3 = Z(y1);               // OK: direct initialization\nZ z4 = static_cast&lt;Z&gt;(y1);  // OK: explicit conversion\n</code></pre>\n<h3>Why use <code>explicit</code> conversion functions or constructors?</h3>\n<p><strong>Conversion constructors and non-explicit conversion functions may introduce ambiguity.</strong></p>\n<p>Consider a structure <code>V</code>, convertible to <code>int</code>, a structure <code>U</code> implicitly constructible from <code>V</code> and a function <code>f</code> overloaded for <code>U</code> and <code>bool</code> respectively.</p>\n<pre><code>struct V {\n  operator bool() const { return true; }\n};\n\nstruct U { U(V) { } };\n\nvoid f(U) { }\nvoid f(bool) {  }\n</code></pre>\n<p>A call to <code>f</code> is ambiguous if passing an object of type <code>V</code>.</p>\n<pre><code>V x;\nf(x);  // error: call of overloaded 'f(V&amp;)' is ambiguous\n</code></pre>\n<p>The compiler does not know wether to use the constructor of <code>U</code> or the conversion function to convert the <code>V</code> object into a type for passing to <code>f</code>. </p>\n<p>If either the constructor of <code>U</code> or the conversion function of <code>V</code> would be <code>explicit</code>, there would be no ambiguity since only the non-explicit conversion would be considered. If both are explicit the call to <code>f</code> using an object of type <code>V</code> would have to be done using an explicit conversion or cast operation.</p>\n<p><strong>Conversion constructors and non-explicit conversion functions may lead to unexpected behaviour.</strong></p>\n<p>Consider a function printing some vector:</p>\n<pre><code>void print_intvector(std::vector&lt;int&gt; const &amp;v) { for (int x : v) std::cout &lt;&lt; x &lt;&lt; '\\n'; }\n</code></pre>\n<p>If the size-constructor of the vector would not be explicit it would be possible to call the function like this:</p>\n<pre><code>print_intvector(3);\n</code></pre>\n<p>What would one expect from such a call? One line containing <code>3</code> or three lines containing <code>0</code>? (Where the second one is what happens.)</p>\n<h3>Using the explicit keyword in a class interface enforces the user of the interface to be explicit about a desired conversion.</h3>\n<p>As Bjarne Stroustrup  puts it (in \"The C++ Programming Language\", 4th Ed., 35.2.1, pp. 1011) on the question why <code>std::duration</code> cannot be implicitly constructed from a plain number:</p>\n<blockquote>\n<p id=\"so_121162_31351956_5\">If you know what you mean, be explicit about it.</p>\n</blockquote>\n", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2015-07-12T11:29:40.527", "Id": "31351956", "Score": "29", "CreationDate": "2015-07-10T23:48:58.157", "LastActivityDate": "2015-07-12T11:29:40.527"}, "39054305": {"ParentId": "121162", "CommentCount": "0", "Body": "<p>Cpp Reference is always helpful!!! Details about explicit specifier can be found <a href=\"http://en.cppreference.com/w/cpp/language/explicit\">here</a>.  You may need to look at <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\">implicit conversions</a> and <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\">copy-initialization</a> too.</p>\n<p>Quick look</p>\n<blockquote>\n<p id=\"so_121162_39054305_0\">The explicit specifier specifies that a constructor or conversion function (since C++11) doesn't allow implicit conversions or copy-initialization. </p>\n</blockquote>\n<p>Example as follows:</p>\n<pre><code>struct A\n{\n    A(int) { }      // converting constructor\n    A(int, int) { } // converting constructor (C++11)\n    operator bool() const { return true; }\n};\n\nstruct B\n{\n    explicit B(int) { }\n    explicit B(int, int) { }\n    explicit operator bool() const { return true; }\n};\n\nint main()\n{\n    A a1 = 1;      // OK: copy-initialization selects A::A(int)\n    A a2(2);       // OK: direct-initialization selects A::A(int)\n    A a3 {4, 5};   // OK: direct-list-initialization selects A::A(int, int)\n    A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)\n    A a5 = (A)1;   // OK: explicit cast performs static_cast\n    if (a1) cout &lt;&lt; \"true\" &lt;&lt; endl; // OK: A::operator bool()\n    bool na1 = a1; // OK: copy-initialization selects A::operator bool()\n    bool na2 = static_cast&lt;bool&gt;(a1); // OK: static_cast performs direct-initialization\n\n//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)\n    B b2(2);       // OK: direct-initialization selects B::B(int)\n    B b3 {4, 5};   // OK: direct-list-initialization selects B::B(int, int)\n//  B b4 = {4, 5}; // error: copy-list-initialization does not consider B::B(int,int)\n    B b5 = (B)1;   // OK: explicit cast performs static_cast\n    if (b5) cout &lt;&lt; \"true\" &lt;&lt; endl; // OK: B::operator bool()\n//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()\n    bool nb2 = static_cast&lt;bool&gt;(b2); // OK: static_cast performs direct-initialization\n}\n</code></pre>\n", "OwnerUserId": "1380954", "PostTypeId": "2", "Id": "39054305", "Score": "9", "CreationDate": "2016-08-20T12:45:16.803", "LastActivityDate": "2016-08-20T12:45:16.803"}, "121216": {"ParentId": "121162", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Suppose you have a class String:</p>\n<pre><code>class String {\npublic:\n    String(int n); // allocate n bytes to the String object\n    String(const char *p); // initializes object with char *p\n};\n</code></pre>\n<p>Now if you try</p>\n<pre><code>String mystring = 'x';\n</code></pre>\n<p>the char 'x' will be implicitly converted to int and then will call the String(int) constructor. But this is not what the user might have intended. So to prevent such conditions, we shall define the constructor as <code>explicit</code>:</p>\n<pre><code>class String {\npublic:\n    explicit String (int n); //allocate n bytes\n    String(const char *p); // initialize sobject with string p\n};\n</code></pre>\n", "OwnerUserId": "21116", "LastEditorUserId": "2326961", "LastEditDate": "2015-08-11T20:28:29.163", "Id": "121216", "Score": "903", "CreationDate": "2008-09-23T14:09:06.917", "LastActivityDate": "2015-08-11T20:28:29.163"}, "121163": {"CommentCount": "23", "CreationDate": "2008-09-23T13:59:04.413", "CommunityOwnedDate": "2013-04-28T16:58:05.857", "LastEditorUserId": "1025376", "LastActivityDate": "2017-06-24T18:46:20.927", "ParentId": "121162", "PostTypeId": "2", "OwnerDisplayName": "Skizz", "LastEditDate": "2017-06-24T18:46:20.927", "Id": "121163", "Score": "2510", "Body": "<p>The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a <strong>single parameter</strong> to convert from one type to another in order to get the right type for a parameter. </p>\n<p>Here's an example class with a constructor that can be used for implicit conversions:</p>\n<pre><code>class Foo\n{\npublic:\n  // single parameter constructor, can be used as an implicit conversion\n  Foo (int foo) : m_foo (foo) \n  {\n  }\n\n  int GetFoo () { return m_foo; }\n\nprivate:\n  int m_foo;\n};\n</code></pre>\n<p>Here's a simple function that takes a <code>Foo</code> object:</p>\n<pre><code>void DoBar (Foo foo)\n{\n  int i = foo.GetFoo ();\n}\n</code></pre>\n<p>and here's where the <code>DoBar</code> function is called.</p>\n<pre><code>int main ()\n{\n  DoBar (42);\n}\n</code></pre>\n<p>The argument is not a <code>Foo</code> object, but an <code>int</code>. However, there exists a constructor for <code>Foo</code> that takes an <code>int</code> so this constructor can be used to convert the parameter to the correct type.</p>\n<p>The compiler is allowed to do this once for each parameter.</p>\n<p>Prefixing the <code>explicit</code> keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call <code>DoBar (42)</code>.  It is now necessary to call for conversion explicitly with  <code>DoBar (Foo (42))</code></p>\n<p>The reason you might want to do this is to avoid accidental construction that can hide bugs.  Contrived example:</p>\n<ul>\n<li>You have a <code>MyString(int size)</code> class with a constructor that constructs a string of the given size.  You have a function <code>print(const MyString&amp;)</code>, and you call <code>print(3)</code> (when you <em>actually</em> intended to call <code>print(\"3\")</code>).  You expect it to print \"3\", but it prints an empty string of length 3 instead.</li>\n</ul>\n", "OwnerUserId": "1898"}, "bq_ids": {"n4140": {"so_121162_31351956_2": {"section_id": 389, "quality": 0.9642857142857143, "length": 27}, "so_121162_31351956_4": {"section_id": 392, "quality": 0.9375, "length": 15}, "so_121162_31351956_1": {"section_id": 388, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_121162_31351956_2": {"section_id": 380, "quality": 0.9642857142857143, "length": 27}, "so_121162_31351956_4": {"section_id": 383, "quality": 0.9375, "length": 15}, "so_121162_31351956_1": {"section_id": 379, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_121162_31351956_2": {"section_id": 406, "quality": 0.9642857142857143, "length": 27}, "so_121162_31351956_4": {"section_id": 409, "quality": 0.9375, "length": 15}, "so_121162_31351956_1": {"section_id": 405, "quality": 0.9411764705882353, "length": 16}}}, "13485522": {"ParentId": "121162", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The <code>explicit</code> keyword makes a conversion constructor to non-conversion constructor. As a result, the code is less error prone. </p>\n", "OwnerUserId": "1840657", "LastEditorUserId": "1438397", "LastEditDate": "2013-02-14T16:40:06.237", "Id": "13485522", "Score": "30", "CreationDate": "2012-11-21T02:36:55.113", "LastActivityDate": "2013-02-14T16:40:06.237"}, "1506749": {"ParentId": "121162", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This has already been discussed (<a href=\"https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319\">what is explicit constructor</a>). But I must say, that it lacks the detailed descriptions found here.</p>\n<p>Besides, it is always a good coding practice to make your one argument constructors (including those with default values for arg2,arg3,...) as already stated. \nLike always with C++: if you don't - you'll wish you did...</p>\n<p>Another good practice for classes is to make copy construction and assignment private (a.k.a. disable it) unless you really need to implement it. This avoids having eventual copies of pointers when using the methods that C++ will create for you by default. An other way to do this is derive from boost::noncopyable.</p>\n", "OwnerUserId": "105643", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:28.387", "Id": "1506749", "Score": "15", "CreationDate": "2009-10-01T22:00:21.310", "LastActivityDate": "2009-10-03T08:57:26.697"}, "122174": {"ParentId": "121162", "CommentCount": "1", "Body": "<p>In C++, a constructor with only one required parameter is considered an implicit conversion function.  It converts the parameter type to the class type.  Whether this is a good thing or not depends on the semantics of the constructor.</p>\n<p>For example, if you have a string class with constructor <code>String(const char* s)</code>, that's probably exactly what you want.  You can pass a <code>const char*</code> to a function expecting a <code>String</code>, and the compiler will automatically construct a temporary <code>String</code> object for you.</p>\n<p>On the other hand, if you have a buffer class whose constructor <code>Buffer(int size)</code> takes the size of the buffer in bytes, you probably don't want the compiler to quietly turn <code>int</code>s into <code>Buffer</code>s.  To prevent that, you declare the constructor with the <code>explicit</code> keyword:</p>\n<pre><code>class Buffer { explicit Buffer(int size); ... }\n</code></pre>\n<p>That way,</p>\n<pre><code>void useBuffer(Buffer&amp; buf);\nuseBuffer(4);\n</code></pre>\n<p>becomes a compile-time error.  If you want to pass a temporary <code>Buffer</code> object, you have to do so explicitly:</p>\n<pre><code>useBuffer(Buffer(4));\n</code></pre>\n<p>In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don't want to use the <code>explicit</code> keyword.  But if you have a constructor that simply happens to take a single parameter, you should declare it as <code>explicit</code> to prevent the compiler from surprising you with unexpected conversions.</p>\n", "OwnerUserId": "8355", "Id": "122174", "PostTypeId": "2", "OwnerDisplayName": "cjm", "Score": "117", "CreationDate": "2008-09-23T16:37:12.770", "LastActivityDate": "2008-09-23T16:37:12.770"}, "28106689": {"ParentId": "121162", "CommentCount": "0", "Body": "<p>Constructors append implicit conversion. To suppress this implicit conversion it is required to declare a constructor with a parameter explicit.</p>\n<p>In C++11 you can also specify an \"operator type()\" with such keyword <a href=\"http://en.cppreference.com/w/cpp/language/explicit\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/explicit</a> With such specification you can use operator in terms of explicit conversions, and direct initialization of object.</p>\n<p>P.S. When using transformations defined BY USER (via constructors and type conversion operator) it is allowed only one level of implicit conversions used.\nBut you can combine this conversions with other language conversions</p>\n<ul>\n<li>up integral ranks (char to int, float to double); </li>\n<li>standart conversions (int to double); </li>\n<li>convert pointers of objects to base class and to void*;</li>\n</ul>\n", "OwnerUserId": "1154447", "PostTypeId": "2", "Id": "28106689", "Score": "4", "CreationDate": "2015-01-23T09:26:52.817", "LastActivityDate": "2015-01-23T09:26:52.817"}, "16539571": {"ParentId": "121162", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The <code>explicit</code>-keyword can be used to enforce a constructor to be called <em>explicitly</em>.</p>\n<pre><code>class C{\npublic:\n    explicit C(void) = default;\n};\n\nint main(void){\n    C c();\n    return 0;\n}\n</code></pre>\n<p>the <code>explicit</code>-keyword in front of the constructor <code>C(void)</code> tells the compiler that only explicit call to this constructor is allowed.</p>\n<p>The <code>explicit</code>-keyword can also be used in user-defined type cast operators:</p>\n<pre><code>class C{\npublic:\n    explicit inline operator bool(void) const{\n        return true;\n    }\n};\n\nint main(void){\n    C c;\n    bool b = static_cast&lt;bool&gt;(c);\n    return 0;\n}\n</code></pre>\n<p>Here, <code>explicit</code>-keyword enforces only explicit casts to be valid, so <code>bool b = c;</code> would be an invalid cast in this case. In situations like these <code>explicit</code>-keyword can help programmer to avoid implicit, unintended casts. This usage has been standardized in <a href=\"http://en.cppreference.com/w/cpp/language/cast_operator\">C++11</a>.</p>\n", "OwnerUserId": "2028887", "LastEditorUserId": "2932052", "LastEditDate": "2016-04-13T09:08:04.863", "Id": "16539571", "Score": "23", "CreationDate": "2013-05-14T09:28:39.317", "LastActivityDate": "2016-04-13T09:08:04.863"}, "121162": {"CommentCount": "4", "AcceptedAnswerId": "121163", "PostTypeId": "1", "LastEditorUserId": "3980929", "LastEditorDisplayName": "Dima", "CreationDate": "2008-09-23T13:58:45.630", "LastActivityDate": "2017-08-18T03:20:05.243", "AnswerCount": "10", "LastEditDate": "2017-05-28T16:07:00.200", "ViewCount": "610095", "FavoriteCount": "704", "Title": "What does the explicit keyword mean?", "Id": "121162", "Score": "2125", "Body": "<p>Someone posted in a comment to another question about the meaning of the <code>explicit</code> keyword in C++. So, what does it mean?</p>\n", "Tags": "<c++><constructor><explicit><c++-faq><explicit-constructor>", "OwnerUserId": "1898", "OwnerDisplayName": "Skizz"}});