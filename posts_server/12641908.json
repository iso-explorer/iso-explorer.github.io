post_cb({"12641908": {"CommentCount": "0", "ViewCount": "664", "PostTypeId": "1", "LastEditorUserId": "903234", "CreationDate": "2012-09-28T14:23:46.833", "LastActivityDate": "2012-09-28T14:51:56.750", "Title": "Endianness of string literals and usage of strings in case statements", "AcceptedAnswerId": "12642132", "LastEditDate": "2012-09-28T14:42:25.187", "Id": "12641908", "Score": "0", "Body": "<p>On my machine, the following program writes 1234 to it's output.</p>\n<pre><code>const char str[] = \"1234\";\nprintf(\"%c%c%c%c\\n\",\n    (int) (0xff &amp; (*(uint32_t*) str) &gt;&gt; 0),\n    (int) (0xff &amp; (*(uint32_t*) str) &gt;&gt; 8),\n    (int) (0xff &amp; (*(uint32_t*) str) &gt;&gt; 16),\n    (int) (0xff &amp; (*(uint32_t*) str) &gt;&gt; 24));\n</code></pre>\n<p>This implies that <code>str</code> is internally represented as <code>0x34333231</code>, and the first byte <code>str[0]</code> represents the least significant 8 bits.</p>\n<p>Does this mean <code>str</code> is encoded in little endian? And is the output of this program platform-dependent?</p>\n<p>Also, is there a convenient way to use 1, 2, 4 and 8 character string literals in switch case statements? I can't find any way to convert the strings to integers, as <code>*(const uint32_t* const) \"1234\"</code> is not a constant expression, and <code>0x34333231</code>/<code>0x31323334</code> might be platform dependent and must be notated in hexadecimal.</p>\n<p><strong>edit:</strong></p>\n<p>In other words, is <code>0xff &amp; *(uint32_t*) str</code> always equal to <code>str[0]</code>?</p>\n<p>Eh, never mind, just realized it is and also why.</p>\n", "Tags": "<c++><string><endianness><literals><string-literals>", "OwnerUserId": "903234", "AnswerCount": "3"}, "12641944": {"ParentId": "12641908", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You're confusing endianness of a string (which doesn't exists so long as we're talking about ASCII strings) with the endianness of an integer. The integer on your system is little endian.</p>\n<p>To answer your second question, no you can't switch on strings. If you're really desperate for the increase in speed you could make one for little endian systems and one for big endian systems.</p>\n", "OwnerUserId": "1695766", "LastEditorUserId": "1695766", "LastEditDate": "2012-09-28T14:35:31.427", "Id": "12641944", "Score": "4", "CreationDate": "2012-09-28T14:25:45.220", "LastActivityDate": "2012-09-28T14:35:31.427"}, "12642132": {"ParentId": "12641908", "CommentCount": "2", "Body": "<p>Endianness refers to the order of bytes in a larger value. Strings are (at least in C and C++) an array of bytes so endianness doesn't apply.</p>\n<p>You actually can do what you mention in the last paragraph using multicharacter literals, though it's implementation defined exactly how it works and the string must be no longer than <code>sizeof(int)</code>.</p>\n<blockquote>\n<p id=\"so_12641908_12642132_0\">C++ standard, \u00a72.14.3/1 - Character literals</p>\n<p id=\"so_12641908_12642132_1\">(...) An ordinary character literal that contains more than one c-char is a multicharacter literal . A multicharacter literal has type int and implementation-de\ufb01ned value.</p>\n</blockquote>\n<p>For instance, <code>'abcd'</code> is a value of type <code>int</code> with an implementation-defined value. This value probably would depend on endianness. Since it is an integer, you are allowed to switch on it. </p>\n", "OwnerUserId": "1568792", "PostTypeId": "2", "Id": "12642132", "Score": "2", "CreationDate": "2012-09-28T14:37:37.400", "LastActivityDate": "2012-09-28T14:37:37.400"}, "bq_ids": {"n4140": {"so_12641908_12642132_1": {"section_id": 5343, "quality": 0.875, "length": 14}}, "n3337": {"so_12641908_12642132_1": {"section_id": 5140, "quality": 0.875, "length": 14}}, "n4659": {"so_12641908_12642132_1": {"section_id": 6765, "quality": 0.875, "length": 14}}}, "12642358": {"ParentId": "12641908", "CommentCount": "0", "Body": "<p>The bytes are layed out as at increasing memory addresses as 0x31, 0x32, 0x33, 0x34.</p>\n<p>In a 32-bit integer is little endian you've got 0x34333231. If big endian 0x31323334.</p>\n<p>(Also in general integers are aligned on even or 4-fold addresses.)</p>\n", "OwnerUserId": "984823", "PostTypeId": "2", "Id": "12642358", "Score": "0", "CreationDate": "2012-09-28T14:51:56.750", "LastActivityDate": "2012-09-28T14:51:56.750"}});