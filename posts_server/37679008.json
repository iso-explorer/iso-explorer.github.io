post_cb({"37679008": {"CommentCount": "1", "ViewCount": "328", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2016-06-07T12:10:16.553", "LastActivityDate": "2016-06-08T03:25:32.650", "Title": "Returning nullptr for unique_ptr with custom deleter fails", "AcceptedAnswerId": "37679220", "LastEditDate": "2016-06-08T03:25:32.650", "Id": "37679008", "Score": "0", "Body": "<p>When I attempt to compile this code it fails saying:\n\" error: static assertion failed: constructed with null function pointer deleter\". The line that it's complaining about is the \"return nullptr\". Returning nullptr works with other functions I've written which return a unique_ptr. Why is this so different and fails to even compile?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\ntemplate&lt;typename ArrayType&gt;\nvoid deleter(ArrayType* array) noexcept\n{\n    if (array)\n    {\n        delete[] array;\n        array = nullptr;\n        std::cout &lt;&lt; \"Freed array.\" &lt;&lt; std::endl;\n    }\n}\ntemplate&lt;typename ArrayType&gt;\nstd::unique_ptr&lt;ArrayType[], decltype(&amp;deleter&lt;ArrayType&gt;)&gt; makeArray(const std::size_t size)\n{\n    return std::unique_ptr&lt;ArrayType[], decltype(&amp;deleter&lt;ArrayType&gt;)&gt;{\n        new ArrayType[size],\n        deleter&lt;ArrayType&gt;\n    };\n}\n\nstd::unique_ptr&lt;int[], decltype(&amp;deleter&lt;int&gt;)&gt; createInt(int s)\n{\n    if (s == 3)\n        return makeArray&lt;int&gt;(3);\n    else\n        return nullptr;\n}\n\nvoid testArr(int arr[])\n{\n    if (arr != nullptr)\n    {\n        arr[0] = 1;\n        arr[1] = 2;\n        arr[2] = 3;\n        std::cout &lt;&lt; \"Value 2 is \" &lt;&lt; arr[1] &lt;&lt; std::endl;\n    }\n    else\n        std::cout &lt;&lt; \"Array is empty.\" &lt;&lt; std::endl;\n}\n\nint main() {\n    auto arr0{createInt(4)}, arr1{createInt(3)};\n    std::cout &lt;&lt; \"\\tTesting arr0:\\n\";\n    testArr(arr0.get());\n    std::cout &lt;&lt; \"\\tTesting arr1:\\n\";\n    testArr(arr1.get());\n    std::cout &lt;&lt; \"\\tFinished testing\\n\";\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><compiler-errors><c++14>", "OwnerUserId": "241060", "AnswerCount": "1"}, "37679220": {"ParentId": "37679008", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-06-07T12:19:47.880", "Score": "1", "LastEditorUserId": "471160", "LastEditDate": "2016-06-07T12:30:41.510", "Id": "37679220", "OwnerUserId": "471160", "Body": "<p>It appears you need to use a function object, like:</p>\n<pre><code>template&lt;typename ArrayType&gt;\nstruct deleter {\n    void operator()(ArrayType* array) {\n    if (array)\n    {\n        delete[] array;\n        array = nullptr;\n        std::cout &lt;&lt; \"Freed array.\" &lt;&lt; std::endl;\n    }\n    }\n};\n</code></pre>\n<p>see here example:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/172693cdc5704531\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/172693cdc5704531</a></p>\n<p>I think the relevant part from standard is in 20.8.1.2.1 [unique.ptr.single.ctor]</p>\n<p>returning nullptr you call : <code>unique_ptr&amp; operator=(nullptr_t) noexcept;</code> which calls <code>constexpr unique_ptr() noexcept;</code>, which in turn has in remarks:</p>\n<blockquote>\n<p id=\"so_37679008_37679220_0\">Remarks: If this constructor is instantiated with a pointer type or\n  reference type for the template argument D, the program is ill-formed.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-07T12:30:41.510"}, "bq_ids": {"n4140": {"so_37679008_37679220_0": {"section_id": 4297, "quality": 0.9, "length": 9}}, "n3337": {"so_37679008_37679220_0": {"section_id": 4138, "quality": 0.9, "length": 9}}, "n4659": {"so_37679008_37679220_0": {"section_id": 4090, "quality": 0.6, "length": 6}}}});