post_cb({"39642224": {"ParentId": "39641843", "CommentCount": "0", "Body": "<p>You haven't said what properties, if any, you need to be assured <code>m_count</code> has after the process has completed, or whether it matters what its value happens to be at any stage during the processing. In the absence of such properties, you might as well not assign it a value at all. If you do need the value of <code>m_count</code> to be anything other than undefined at any point in your processing, you <em>assuredly</em> must use synchronization to ensure that the sequence of actions taken in relation to that variable remains consistent.</p>\n<p>If <code>m_count</code> is only written in the -1 case, and the variable is shared by all threads, you would be vastly better off moving that initialization outside of the parallel part of your program. You could thus eliminate any data races and avoid unnecessarily calling you expensive function.</p>\n", "OwnerUserId": "847269", "PostTypeId": "2", "Id": "39642224", "Score": "0", "CreationDate": "2016-09-22T14:45:12.183", "LastActivityDate": "2016-09-22T14:45:12.183"}, "39641843": {"CommentCount": "6", "ViewCount": "72", "PostTypeId": "1", "LastEditorUserId": "2050788", "CreationDate": "2016-09-22T14:27:47.247", "LastActivityDate": "2016-09-22T14:49:27.747", "Title": "possible concurrent write of *same* value to an integer. Do I need an atomic variable?", "LastEditDate": "2016-09-22T14:30:21.860", "Id": "39641843", "Score": "0", "Body": "<p>I want to introduce an optimization into some legacy code. The optimization boils down to the following simple example:</p>\n<pre><code>class Foo{\n        static int m_count;   // allocated and initialized to -1 to indicate it's uninitialized.\n        void fun(){\n            if (m_count ==-1)\n                m_count = execute_db_call(); // return a val &gt; 0.\n            if (m_count == 1) {\n                 // call special == 1 optimized code.\n            } else {\n                 // call expensive code.\n            }\n       }\n   }\n</code></pre>\n<ol>\n<li><code>fun()</code> will be called millions of times on hundreds of threads, all running concurrently on a 256 core server.   </li>\n<li><code>execute_db_call</code> is expensive, and the return value is constant for the lifetime of the application.</li>\n</ol>\n<p>Do I need or want to make <code>m_count</code> atomic?  In the worst case multiple threads might call <code>execute_db_call</code>, and get the same value, and then write this value to the same location in memory.  Is that a race condition even when both threads attempt to write the same integer value?</p>\n<p>If I did make the member atomic, what kind of performance overhead am I looking at for the subsequent read only behavior?</p>\n", "Tags": "<c++><concurrency><atomic>", "OwnerUserId": "2050788", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_39641843_39642112_0": {"section_id": 5834, "quality": 0.8, "length": 20}}, "n3337": {"so_39641843_39642112_0": {"section_id": 5605, "quality": 0.88, "length": 22}}, "n4659": {"so_39641843_39642112_0": {"section_id": 7296, "quality": 0.8, "length": 20}}}, "39642308": {"ParentId": "39641843", "CommentCount": "2", "Body": "<p>Which C++ version you are using? If you compiler support C++ 0x11, why dont you use the std::call_once??</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/thread/call_once\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/thread/call_once</a></p>\n<p>Actually the static local variable may also help your case</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables</a></p>\n", "OwnerUserId": "5405790", "PostTypeId": "2", "Id": "39642308", "Score": "-1", "CreationDate": "2016-09-22T14:49:27.747", "LastActivityDate": "2016-09-22T14:49:27.747"}, "39642112": {"ParentId": "39641843", "CommentCount": "5", "Body": "<p>Per standard \u00a71.10/21:</p>\n<blockquote>\n<p id=\"so_39641843_39642112_0\">The execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.</p>\n</blockquote>\n<p>It looks like your code matches this definition, so you will get UB. Now, even assuming your application will never crush (oh well...) you might get unnecessary <code>execute_db_call</code> calls, and you have explicitly stated that \"<em>execute_db_call is expensive</em>\", so it's still bad.</p>\n", "OwnerUserId": "1490355", "PostTypeId": "2", "Id": "39642112", "Score": "1", "CreationDate": "2016-09-22T14:39:40.223", "LastActivityDate": "2016-09-22T14:39:40.223"}});