post_cb({"bq_ids": {"n4140": {"so_42799268_42799405_1": {"length": 15, "quality": 0.9375, "section_id": 6185}, "so_42799268_42799405_0": {"length": 40, "quality": 0.975609756097561, "section_id": 5908}}, "n3337": {"so_42799268_42799405_0": {"length": 40, "quality": 0.975609756097561, "section_id": 5680}}, "n4659": {"so_42799268_42799405_1": {"length": 12, "quality": 0.75, "section_id": 7687}, "so_42799268_42799405_0": {"length": 29, "quality": 0.7073170731707317, "section_id": 7390}}}, "42799268": {"ViewCount": "51", "Body": "<p>The following code does not compile:</p>\n<pre><code>struct object \n{\n    static constexpr auto f;\n};\n\nconstexpr auto object::f = [](auto&amp;&amp; x){x += 1;};\n</code></pre>\n<p>neither this one:</p>\n<pre><code>struct object \n{\n    static constexpr auto f = [](auto&amp;&amp; x){x += 1;};\n};\n</code></pre>\n<p>but this does (when <code>f</code> is not a member):</p>\n<pre><code>static constexpr auto f = [](auto&amp;&amp; x){x += 1;};\n</code></pre>\n<p>Is there a way to declare and define a static constexpr data member lambda in C++14?</p>\n", "AcceptedAnswerId": "42799405", "Title": "Static (possibly constexpr) data member lambda", "CreationDate": "2017-03-15T00:50:29.980", "Id": "42799268", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-03-15T01:06:15.193", "Score": "2", "OwnerUserId": "882932", "Tags": "<c++><lambda><static><c++14><data-members>", "AnswerCount": "1"}, "42799405": {"Id": "42799405", "PostTypeId": "2", "Body": "<p>The rule on static data members is in [class.static.data]:</p>\n<blockquote>\n<p id=\"so_42799268_42799405_0\">If a non-volatile <code>const</code> <code>static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression (5.19). A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em>\n  in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression.</p>\n</blockquote>\n<p>Only <code>static const</code> integral/enumeration types or <code>constexpr</code> members can be defined within the class definition. C++14 disallowed <code>constexpr</code> lambdas period. The wording in [expr.const] used to read:</p>\n<blockquote>\n<p id=\"so_42799268_42799405_1\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:<br>\n  \u2014 [...]<br>\n  \u2014 a <em>lambda-expression</em> (5.1.2);<br>\n  \u2014 [...]  </br></br></br></p>\n</blockquote>\n<p>So in C++14, you just can't have a static lambda data member - you can't define it inline and you can't define it out of line because you have no way of declaring it (variables declared with <code>auto</code> require an initializer). You're out of luck.</p>\n<hr/>\n<p>In C++17, we can have <code>constexpr</code> lambdas thanks to <a href=\"http://wg21.link/p0170\" rel=\"nofollow noreferrer\">p0170</a>, at which point your second option is fine:</p>\n<pre><code>struct object \n{\n    static constexpr auto f = [](auto&amp;&amp; x){x += 1;};\n};\n</code></pre>\n", "LastActivityDate": "2017-03-15T01:06:15.193", "CommentCount": "0", "CreationDate": "2017-03-15T01:06:15.193", "ParentId": "42799268", "Score": "3", "OwnerUserId": "2069064"}});