post_cb({"44543581": {"ParentId": "44543380", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-06-14T11:32:23.103", "Score": "0", "LastEditorUserId": "2079303", "LastEditDate": "2017-06-14T11:36:07.347", "Id": "44543581", "OwnerUserId": "2079303", "Body": "<blockquote>\n<p id=\"so_44543380_44543581_0\">how can be a class be defined by restricting \"the interface\" to a base?</p>\n</blockquote>\n<p>By making the inheritance private. When the inheritance is private, the interface of the base class is restricted to the member functions and not available outside. The access specifier can be given in the list of bases:</p>\n<pre><code>class A : private B\n//        ^^^^^^^\n</code></pre>\n<blockquote>\n<p id=\"so_44543380_44543581_1\">What does he mean by \"stronger guarantees\"?</p>\n</blockquote>\n<p>Any guarantee that is not given by the base, or is a superset of a guarantee given by the base.</p>\n<p>For example, the guarantee that <em>\"behaviour is always well defined\"</em> is stronger than <em>\"Behaviour is well defined only if input is not null\"</em>. Another example: <em>\"The function does not throw\"</em> is stronger than <em>\"The function will not throw unless the copy constructor throws\"</em>.</p>\n", "LastActivityDate": "2017-06-14T11:36:07.347"}, "44544912": {"ParentId": "44543380", "CommentCount": "0", "CreationDate": "2017-06-14T12:32:06.737", "OwnerUserId": "6387170", "PostTypeId": "2", "Id": "44544912", "Score": "0", "Body": "<p>Allow us to look at a possible situation with interfaces to help build up the picture.</p>\n<pre><code>class poison {\n  public:\n    virtual void used() = 0;\n};\n\nclass food {\n  public:\n    virtual void eat();\n  protected:\n    void poisonConsumed(poison&amp; p);\n}\n\nclass cheese : public food, private poison {\n  public:\n    virtual void eat() override {\n      poisonConsumed(*this);\n    }\n  private:\n    void used() override;\n}\n</code></pre>\n<p>This presents cheese to the outside world as 'not a poison' - ie nothing outside the class can know that it's a poison, and it could be made 'not a poison' to no impact on anything using it.</p>\n<p>The cheese however, can pass itself to anything expecting a poison which is then free to call used(); even though it's private in cheese.</p>\n", "LastActivityDate": "2017-06-14T12:32:06.737"}, "44543568": {"ParentId": "44543380", "CommentCount": "0", "CreationDate": "2017-06-14T11:31:29.387", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "44543568", "Score": "3", "Body": "<p>Lets take a very simple example:</p>\n<pre><code>// A simple class with a *public* member\nclass A\n{\npublic:\n    int a;\n};\n\n// Use private inheritance\nclass B : private A\n{\npublic:\n    int b;\n};\n\n// Use public inheritance\nclass C : public A\n{\npublic:\n    int c;\n};\n\n// ...\n\nB my_b;\nmy_b.a = 0;  // Invalid, the member a is private due to the private inhericance\n\nC my_c;\nmy_c.a = 0;  // Valid, because the inheritance is public\n</code></pre>\n<p>The <code>private</code> inheritance <em>restricts</em> access to the members of the base class. Even if the <code>A::a</code> member variable is <code>public</code>, due to the <code>private</code> inheritance it becomes <code>private</code> in the sub-class <code>B</code>.</p>\n", "LastActivityDate": "2017-06-14T11:31:29.387"}, "44543749": {"ParentId": "44543380", "CommentCount": "0", "CreationDate": "2017-06-14T11:39:44.743", "OwnerUserId": "577603", "PostTypeId": "2", "Id": "44543749", "Score": "1", "Body": "<p>Let's stay with the example of the vector. A vector is just a container of <code>T</code>s. Now let's say you want to build a type that behaves just like a vector, but adds some additional runtime checks. I don't have my copy of TC++PL at hand right now, so let's just make up a constraint: For example, let's say your vector is only allowed to hold even numbers. Attempting to insert an odd number will result in a runtime error. Let's call this new class <code>even_vector</code> and the version without the runtime checks <code>base_vector</code>.</p>\n<p><code>even_vector</code> provides stronger runtime guarantees than <code>base_vector</code>: It is guaranteed that all of its elements are even.</p>\n<p>Assuming that your <code>base_vector</code> is designed to work nice as a base class (which <code>std::vector</code> typically does not), you might now be tempted to use public inheritance to implement <code>even_vector</code> in terms of <code>base_vector</code>. After all, the functionality is the same, you simply have some additional runtime checks in the <code>even_vector</code> case on top of the functionality provided by <code>base_vector</code>. However, if you were to use public inheritance here, you would violate the <a href=\"https://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle\">Liskov Substitution Principle</a>: You cannot use an <code>even_vector</code> wherever you use a <code>base_vector</code>. In particular, the <code>even_vector</code> will break in cases where you are inserting odd numbers into a <code>base_vector</code>. This is bad, as now all code that is written for <code>base_vector</code> must account for the fact that some of the <code>base_vector</code>s cannot deal with odd numbers.</p>\n<p>With private inheritance you do not have this problem: Here the fact that <code>even_vector</code> inherits from <code>base_vector</code> is a detail of the implementation. Clients cannot use <code>even_vector</code> where a <code>base_vector</code> is expected, so the problem from above does not occur, but we still get the benefits of code reuse.</p>\n<p>That being said, using private inheritance for code reuse is a practice that is discouraged by many. An arguably better way would be to <a href=\"https://en.wikipedia.org/wiki/Composition_over_inheritance\" rel=\"nofollow noreferrer\">use composition here instead</a>, that is, add a private <code>base_vector</code> member to <code>even_vector</code> instead. The advantage of that approach is that it severely reduces coupling between the two classes, as <code>even_vector</code> is no longer able to access any non-public parts of <code>base_vector</code>.</p>\n", "LastActivityDate": "2017-06-14T11:39:44.743"}, "bq_ids": {"n4140": {"so_44543380_44543581_0": {"section_id": 369, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_44543380_44543581_0": {"section_id": 359, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_44543380_44543581_0": {"section_id": 423, "quality": 0.5714285714285714, "length": 4}}}, "44543380": {"CommentCount": "0", "ViewCount": "72", "PostTypeId": "1", "LastEditorUserId": "366904", "CreationDate": "2017-06-14T11:23:16.197", "LastActivityDate": "2017-06-14T12:32:06.737", "Title": "Private inheritance usage as described in \"The C++ Programming Language\"", "LastEditDate": "2017-06-14T11:46:49.067", "Id": "44543380", "Score": "0", "Body": "<p>In <em>The C++ Programming Language</em>, 4th Edition, at \u00a720.5.2 \"Access to Base Class\" (page 605), it says (regarding private inheritance): </p>\n<blockquote>\n<p id=\"so_44543380_44543380_0\"><strong>private</strong> bases are most useful when defining a class by restricting\n  the interface to a base so that stronger guarantees can be\n  provided.For example, B is an implementation detail of Z .The Vector\n  of pointers template that adds type checking to its Vector base\n  from \u00a725.3 is a good example.</p>\n</blockquote>\n<p>It's not clear what Bjarne Stroustrup is trying to say here. How can be a class be defined by restricting \"the interface\" to a base? What does he mean by \"stronger guarantees\"?</p>\n", "Tags": "<c++><inheritance><private-inheritance>", "OwnerUserId": "1135950", "AnswerCount": "4"}});