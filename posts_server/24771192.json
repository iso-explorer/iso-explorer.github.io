post_cb({"24771913": {"ParentId": "24771192", "CommentCount": "1", "CreationDate": "2014-07-16T03:50:41.667", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "24771913", "Score": "2", "Body": "<p>3.5/6</p>\n<blockquote>\n<p id=\"so_24771192_24771913_0\">The name of a function declared in block scope and the name of a variable declared by a block scope <code>extern</code> declaration have linkage. If there is a visible declaration of an entity with linkage having the same name and type, ignoring entities declared outside the innermost enclosing namespace scope, the block scope declaration declares that same entity and receives the linkage of the previous declaration. If there is more than one such matching entity, the program is ill-formed. Otherwise, if no matching entity is found, the block scope entity receives external linkage.</p>\n</blockquote>\n<p>8.5/5</p>\n<blockquote>\n<p id=\"so_24771192_24771913_1\">A declaration of a block-scope variable with external or internal linkage that has an <em>initializer</em> is ill-formed.</p>\n</blockquote>\n<p>As @Praetorian pointed out, you can move the variable definition outside of the function definition.  Or if you don't actually need to use the name <code>x</code> anywhere outside that one function, change <code>extern</code> to <code>static</code>, and <code>x</code> will have no linkage.</p>\n", "LastActivityDate": "2014-07-16T03:50:41.667"}, "bq_ids": {"n4140": {"so_24771192_24771554_0": {"section_id": 7034, "quality": 0.875, "length": 14}, "so_24771192_24771913_1": {"section_id": 3284, "quality": 1.0, "length": 8}, "so_24771192_24771913_0": {"section_id": 7139, "quality": 0.9833333333333333, "length": 59}}, "n3337": {"so_24771192_24771554_0": {"section_id": 6780, "quality": 0.875, "length": 14}, "so_24771192_24771913_0": {"section_id": 6883, "quality": 0.9833333333333333, "length": 59}}, "n4659": {"so_24771192_24771554_0": {"section_id": 8531, "quality": 0.875, "length": 14}, "so_24771192_24771913_1": {"section_id": 4046, "quality": 1.0, "length": 8}, "so_24771192_24771913_0": {"section_id": 8640, "quality": 0.9833333333333333, "length": 59}}}, "24771192": {"CommentCount": "3", "ViewCount": "279", "CreationDate": "2014-07-16T02:20:43.463", "LastActivityDate": "2014-07-16T03:50:41.667", "Title": "Initialization of variable with external linkage inside unnamed namespace", "PostTypeId": "1", "Id": "24771192", "Score": "1", "Body": "<p>I would like to provide a definition for 'x'. I tried using \"extern int x = 42\". However, g++ complains that 'x' has both extern and an initializer. I tried to find the relevant part of the c++11 spec that disallows this, but I could not find any such clause. Is this indeed disallowed by the spec? If so, please cite the relevant section.</p>\n<pre><code>namespace {\n    int f() { \n        extern int x;\n        return x;\n    }\n}\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1091581", "AnswerCount": "2"}, "24771554": {"ParentId": "24771192", "CommentCount": "5", "CreationDate": "2014-07-16T03:04:35.983", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "24771554", "Score": "3", "Body": "<p>By providing an initializer you'll turn the declaration into a definition with external linkage</p>\n<p>From <em>\u00a73.1/2 [basic.def]</em></p>\n<blockquote>\n<p id=\"so_24771192_24771554_0\"><strong>A declaration is a <em>definition</em> unless</strong> it declares a function without specifying the function\u2019s body (8.4), <strong>it contains the <code>extern</code> specifier</strong> (7.1.1) or a <em>linkage-specification</em> (7.5) <strong>and neither an <em>initializer</em></strong> nor a <em>function-body</em>, <code>...</code></p>\n</blockquote>\n<p>But variables with external linkage cannot be defined within functions, only at namespace scope, which is why gcc rejects your code. So provide the definition at namespace scope.</p>\n<pre><code>namespace {\n    extern int x = 0;\n    int f() { \n        // no need for extern declaration here, name lookup will find x\n        return x;\n    }\n}\n</code></pre>\n<p>That'll work, but giving external linkage to a name defined within an unnamed namespace is certainly strange, if not useless.</p>\n<hr>\n<p>Note that gcc still issues a warning for the code above</p>\n<blockquote>\n<p id=\"so_24771192_24771554_1\">warning: 'x' initialized and declared 'extern'</p>\n</blockquote>\n<p>however, from this <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=45977\" rel=\"nofollow\">gcc bug report</a> regarding the warning:</p>\n<blockquote>\n<p id=\"so_24771192_24771554_2\">This is a coding style warning - the code is valid, but extremely \n  unidiomatic for C since \"extern\" is generally expected to mean that the \n  declaration is not providing a definition of the object.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2014-07-16T03:04:35.983"}});