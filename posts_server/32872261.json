post_cb({"bq_ids": {"n4140": {"so_32872261_32872261_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3919}}, "n3337": {"so_32872261_32872261_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3779}}, "n4659": {"so_32872261_32872261_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 4805}}}, "32872261": {"ViewCount": "139", "Body": "<p><strong>Context:</strong>\nI am writing a specific communication protocol to be used between TLM models (HW blocks described with SystemC and thus C++).\nTLM notion is not important, just note that this communication is mimicked by allocating objects, the generic payloads (gps), that are passed between these C++ models of HW blocks.</p>\n<p><strong>Aim:</strong>\nTogether with the protocol, I want to provide a memory manager that should be able to efficiently handle the gps; this is quite important since in one simulation lots of gps are <em>constructed, used and destroyed</em> and this can slow down things a lot.\nMy goal is also to create something simple that could be used by others without efforts.</p>\n<p><strong>Issues:</strong></p>\n<ol>\n<li><p>The first issue I had was in creating a single shared pool for all the blocks communicating with that protocol. I thought about creating a static member in the mm class, but then I realized that:</p>\n<ul>\n<li>Static members require a definition in the cpp. This makes the mm class less intuitive to use (with different people using this, some will forget to do so) and I would prefer to avoid that.</li>\n<li>Depending on where (and in which?) in the cpp file the static variable definition is done, the pool might not have wet the parameters needed to be initialized (i.e., the number of mm instances created).</li>\n</ul></li>\n<li><p>The second issue is similar to the first one. I want to count the number of instances and thus instead of a pool I need to create a shared counter to be used then by the pool to initialize itself. Again, I wanted to avoid static variable definitions in a cpp file and to guarantee the order of initialization.</p></li>\n</ol>\n<p>I have considered mainly:</p>\n<ul>\n<li>static members (discarded for the reasons above)</li>\n<li>Singletons (discarded because I don't need to create a whole class for the pool to make it visible by others and single-instanced)</li>\n<li>static methods (the approaches I finally picked and that is not far from a complete Singleton)</li>\n</ul>\n<p>This is the code I produced (only relevant part included):</p>\n<pre><code>/**\n* Helper class to count another class' number of instances.\n*/\nclass counter {\npublic:\n  // Constructor\n  counter() : count(0) {}\n\n  //Destructor\n  virtual ~counter() {}\n\nprivate:\n  unsigned int count;\n\npublic:\n  unsigned int get_count() {return count;}\n  void incr_count() {count++;}\n  void decr_count() {count--;}\n};\n\n\ntemplate &lt;unsigned int MAX = 1&gt;\nclass mm: public tlm::tlm_mm_interface {\n//////////////////////////////TYPEDEFS AND ENUMS/////////////////////////////\npublic:\n  typedef tlm::tlm_generic_payload gp_t;\n\n///////////////////////////CLASS (CON/DE)STRUCTOR////////////////////////////\npublic:\n  // Constructor\n  mm() {inst_count().incr_count();}\n\n  // Copy constructor\n  mm(const mm&amp;) {inst_count().incr_count();}\n\n  // Destructor\n  virtual ~mm() {}  // no need to decrease instance count in our case\n\n////////////////////////////////CLASS METHODS////////////////////////////////\npublic:\n  // Counter for number of isntances.\n  static counter&amp; inst_count() {\n    static counter cnt;\n    return cnt;\n  }\n\n  /* This pattern makes sure that:\n  -- 1. The pool is created only when the first alloc appears\n  -- 2. All instances of mm have been already created (known instance sequence)\n  -- 3. Only one pool exists */\n  static boost::object_pool&lt;gp_t&gt;&amp; get_pool() {\n    static boost::object_pool&lt;gp_t&gt; p(\n      mm&lt;MAX&gt;::inst_count().get_count() * MAX / 2, // creation size\n      mm&lt;MAX&gt;::inst_count().get_count() * MAX      // max size used\n    );\n    return p;\n  }\n\n  // Allocate\n  virtual gp_t* allocate() {\n    //...\n    return gp;\n  }\n\n  // Free the generic payload and data_ptr\n  virtual void free(gp_t* gp) {\n     //...\n     get_pool().destroy(gp);\n  }\n}\n</code></pre>\n<p>Now, the initiator block class header should have a member:</p>\n<pre><code>mm m_mm;\n</code></pre>\n<p>And the initiator block class cpp should use this like:</p>\n<pre><code>tlm_generic_payload* gp;\ngp = m_mm.allocate();\n//...\nm_mm.free(gp); // In truth this is called by gp-&gt;release()...\n               // ...not important here\n</code></pre>\n<p>Having an electronic HW background, I am mainly trying to improve coding style, learn new approaches and optimize speed/memory allocation.</p>\n<p>Is there a better way to achieve this? In particular considering my doubts:</p>\n<ul>\n<li>It seems to me a not optimal workaround to encapsulate the counter in a class, put it locally (but static) in a static method and then do the same for the pool.</li>\n<li>even though SystemC \"simulation kernel\" is single-threaded, I need to consider a multithread case...I am not sure that the relationship between those two static methods is safe even thou independently they should be safe...with C++03 g++ adds code to guarantee it and with C++11:</li>\n</ul>\n<blockquote>\n<p id=\"so_32872261_32872261_0\">\u00a76.7 [stmt.dcl] p4 If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>Thanks in advance.</p>\n", "Title": "SystemC/TLM (C++) sharing memory pool; static members, static methods, Singleton or?", "CreationDate": "2015-09-30T17:27:37.473", "LastActivityDate": "2015-09-30T17:27:37.473", "CommentCount": "0", "PostTypeId": "1", "Id": "32872261", "Score": "1", "OwnerUserId": "1134337", "Tags": "<c++><memory-management><coding-style><singleton><systemc>", "AnswerCount": "0"}});