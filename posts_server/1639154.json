post_cb({"1639297": {"Id": "1639297", "PostTypeId": "2", "Body": "<p>To answer the OP's question about why it is only allowed with integral types.</p>\n<p>When an object is used as an lvalue (i.e. as something that has address in storage), it has to satisfy the \"one definition rule\" (ODR), i.e it has to be defined in one and only one translation unit. The compiler cannot and will not decide which translation unit to define that object in. This is your responsibility. By <em>defining</em> that object somewhere you are not just defining it, you are actually telling the compiler that you want to define it <em>here</em>, in <em>this</em> specific translation unit.</p>\n<p>Meanwhile, in C++ language integral constants have special status. They can form integral constant expressions (ICEs). In ICEs integral constants are used as ordinary <em>values</em>, not as <em>objects</em> (i.e. it is not relevant whether such integral value has address in the storage or not). In fact, ICEs are evaluated at compile time. In order to facilitate such a use of integral constants their values have to be visible globally. And the constant itself don't really need an actual place in the storage. Because of this integral constants received special treatment: it was allowed to include their initializers in the header file, and the requirement to provide a definition was relaxed (first de facto, then de jure).</p>\n<p>Other constant types has no such properties. Other constant types are virtually always used as lvalues (or at least can't participate in ICEs or anything similar to ICE), meaning that they require a definition. The rest follows.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2009-10-28T20:18:28.623", "Score": "24", "CreationDate": "2009-10-28T18:46:10.183", "ParentId": "1639154", "CommentCount": "3", "OwnerUserId": "187690", "LastEditDate": "2009-10-28T20:18:28.623"}, "1639194": {"Id": "1639194", "PostTypeId": "2", "Body": "<p>Constant initializer allowed by C++ Standard only for integral or enumeration types. See 9.4.2/4 for details:</p>\n<blockquote>\n<p id=\"so_1639154_1639194_0\">If a static data member is of const integral or const enumeration type, its declaration in the class\n  definition can specify a constant-initializer which shall be an integral constant expression (5.19).  In that\n  case, the member can appear in integral constant expressions.  The member shall still be defined in a name-\n  space scope if it is used in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<p>And 9.4.2/7:</p>\n<blockquote>\n<p id=\"so_1639154_1639194_1\">Static data members are initialized and destroyed exactly like non-local objects (3.6.2, 3.6.3).</p>\n</blockquote>\n<p>So you should write somewhere in cpp file:</p>\n<pre><code>const char* SomeClass::SOMETHING = \"sommething\";\n</code></pre>\n", "LastEditorUserId": "123111", "LastActivityDate": "2009-10-28T18:36:22.573", "Score": "1", "CreationDate": "2009-10-28T18:30:32.930", "ParentId": "1639154", "CommentCount": "0", "OwnerUserId": "123111", "LastEditDate": "2009-10-28T18:36:22.573"}, "1639184": {"Id": "1639184", "PostTypeId": "2", "Body": "<p>The error is that you cannot initialize a <code>static const char*</code> within the class. You can only initialize integer variables there.</p>\n<p>You need to declare the member variable in the class, and then initialize it outside the class:</p>\n<p>// header file</p>\n<pre><code>class Foo {\n    static const char *SOMETHING;\n    // rest of class\n};\n</code></pre>\n<p>// cpp file</p>\n<pre><code>const char *Foo::SOMETHING = \"sommething\";\n</code></pre>\n<p>If this seems annoying, think of it as being because the initialization can only appear in one translation unit. If it was in the class definition, that would usually be included by multiple files. Constant integers are a special case (which means the error message perhaps isn't as clear as it might be), and compilers can effectively replace uses of the variable with the integer value.</p>\n<p>In contrast, a <code>char*</code> variable points to an actual object in memory, which is required to really exist, and it's the definition (including initialization) which makes the object exist. The \"one definition rule\" means you therefore don't want to put it in a header, because then all translation units including that header would contain the definition. They could not be linked together, even though the string contains the same characters in both, because under current C++ rules you've defined two different objects with the same name, and that's not legal. The fact that they happen to have the same characters in them doesn't make it legal.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2016-02-24T00:26:52.687", "Score": "15", "CreationDate": "2009-10-28T18:29:24.693", "ParentId": "1639154", "CommentCount": "1", "OwnerUserId": "13005", "LastEditDate": "2016-02-24T00:26:52.687"}, "1639164": {"Id": "1639164", "PostTypeId": "2", "Body": "<p>You need to define static variables in a translation unit, unless they are of integral types.</p>\n<p>In your header:</p>\n<pre><code>private:\n    static const char *SOMETHING;\n    static const int MyInt = 8; // would be ok\n</code></pre>\n<p>In the .cpp file:    </p>\n<pre><code>const char *YourClass::SOMETHING = \"something\";\n</code></pre>\n<p>C++ standard, 9.4.2/4:</p>\n<blockquote>\n<p id=\"so_1639154_1639164_0\">If a static data member is of const\n  integral or const enumeration type,\n  its declaration in the class\n  definition can specify a\n  constant-initializer which shall be an\n  integral constant expression. In that\n  case, the member can appear in\n  integral constant expressions within\n  its scope. The member shall still be\n  defined in a namespace scope if it is\n  used in the program and the namespace\n  scope definition shall not contain an\n  initializer.</p>\n</blockquote>\n", "LastEditorUserId": "191367", "LastActivityDate": "2014-07-25T07:32:28.847", "Score": "55", "CreationDate": "2009-10-28T18:27:03.577", "ParentId": "1639154", "CommentCount": "6", "OwnerUserId": "191367", "LastEditDate": "2014-07-25T07:32:28.847"}, "1642353": {"Id": "1642353", "PostTypeId": "2", "Body": "<pre><code>class A{\npublic:\n   static const char* SOMETHING() { return \"something\"; }\n};\n</code></pre>\n<p>I do it all the time - especially for expensive const default parameters.</p>\n<pre><code>class A{\n   static\n   const expensive_to_construct&amp;\n   default_expensive_to_construct(){\n      static const expensive_to_construct xp2c(whatever is needed);\n      return xp2c;\n   }\n};\n</code></pre>\n", "LastActivityDate": "2009-10-29T08:47:51.320", "CommentCount": "0", "CreationDate": "2009-10-29T08:47:51.320", "ParentId": "1639154", "Score": "9", "OwnerUserId": "145011"}, "bq_ids": {"n4140": {"so_1639154_1639194_0": {"length": 27, "quality": 0.7105263157894737, "section_id": 5908}, "so_1639154_1639164_0": {"length": 28, "quality": 0.717948717948718, "section_id": 5908}, "so_1639154_1639194_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5911}}, "n3337": {"so_1639154_1639194_0": {"length": 27, "quality": 0.7105263157894737, "section_id": 5680}, "so_1639154_1639164_0": {"length": 28, "quality": 0.717948717948718, "section_id": 5680}, "so_1639154_1639194_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5683}}, "n4659": {"so_1639154_1639194_0": {"length": 23, "quality": 0.6052631578947368, "section_id": 7390}, "so_1639154_1639164_0": {"length": 24, "quality": 0.6153846153846154, "section_id": 7390}, "so_1639154_1639194_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 7393}}}, "1639409": {"Id": "1639409", "PostTypeId": "2", "Body": "<p>To answer the <em>why</em> question, integral types are special in that they are not a reference to an allocated object but rather values that are duplicated and copied. It's just an implementation decision made when the language was defined, which was to handle values outside the object system and in as efficient and \"inline\" a fashion as possible.</p>\n<p>This doesn't exactly explain why they are allowed as initializors in a type, but think of it as essentially a <code>#define</code> and then it will make sense as part of the type and not part of the object.</p>\n", "LastActivityDate": "2009-10-28T19:05:35.667", "CommentCount": "0", "CreationDate": "2009-10-28T19:05:35.667", "ParentId": "1639154", "Score": "0", "OwnerUserId": "140740"}, "1639154": {"ViewCount": "80076", "Body": "<p>I'd like to define a constant char* in my header file for my .cpp file to use.  So I've tried this:</p>\n<pre><code>private:\n    static const char *SOMETHING = \"sommething\";\n</code></pre>\n<p>Which brings me with the following compiler error:</p>\n<blockquote>\n<p id=\"so_1639154_1639154_0\">error C2864: 'SomeClass::SOMETHING' :\n  only static const integral data\n  members can be initialized within a\n  class</p>\n</blockquote>\n<p>I'm new to C++.  What is going on here?  Why is this illegal?  And how can you do it alternatively?</p>\n", "AcceptedAnswerId": "1639164", "Title": "How to declare a static const char* in your header file?", "CreationDate": "2009-10-28T18:24:33.500", "Id": "1639154", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-02-24T00:26:52.687", "Score": "46", "OwnerUserId": "184685", "Tags": "<c++><constants>", "AnswerCount": "9"}, "1639223": {"Id": "1639223", "PostTypeId": "2", "Body": "<p>If you're using Visual C++, you can non-portably do this using hints to the linker...</p>\n<pre><code>// In foo.h...\n\nclass Foo\n{\npublic:\n   static const char *Bar;\n};\n\n// Still in foo.h; doesn't need to be in a .cpp file...\n\n__declspec(selectany)\nconst char *Foo::Bar = \"Blah\";\n</code></pre>\n<p><code>__declspec(selectany)</code> means that even though <code>Foo::Bar</code> will get declared in multiple object files, the linker will only pick up one.</p>\n<p>Keep in mind this will only work with the Microsoft toolchain.  Don't expect this to be portable.</p>\n", "LastActivityDate": "2009-10-28T18:33:33.577", "CommentCount": "0", "CreationDate": "2009-10-28T18:33:33.577", "ParentId": "1639154", "Score": "3", "OwnerUserId": "182748"}, "1639243": {"Id": "1639243", "PostTypeId": "2", "Body": "<p>There is a trick you can use with templates to provide H file only constants.</p>\n<p>(note, this is an ugly example, but works verbatim in at least in g++ 4.6.1.)</p>\n<p>(values.hpp file)</p>\n<pre><code>#include &lt;string&gt;\n\ntemplate&lt;int dummy&gt;\nclass tValues\n{\npublic:\n   static const char* myValue;\n};\n\ntemplate &lt;int dummy&gt; const char* tValues&lt;dummy&gt;::myValue = \"This is a value\";\n\ntypedef tValues&lt;0&gt; Values;\n\nstd::string otherCompUnit(); // test from other compilation unit\n</code></pre>\n<p>(main.cpp)</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"values.hpp\"\n\nint main()\n{\n   std::cout &lt;&lt; \"from main: \" &lt;&lt; Values::myValue &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"from other: \" &lt;&lt; otherCompUnit() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>(other.cpp)</p>\n<pre><code>#include \"values.hpp\"\n\nstd::string otherCompUnit () {\n   return std::string(Values::myValue);\n}\n</code></pre>\n<p>Compile (e.g. g++ -o main main.cpp other.cpp &amp;&amp; ./main) and see two compilation units referencing the same constant declared in a header:</p>\n<pre><code>from main: This is a value\nfrom other: This is a value\n</code></pre>\n<hr>\n<p>In MSVC, you may instead be able to use __declspec(selectany)</p>\n<p>For example:</p>\n<pre><code>__declspec(selectany) const char* data = \"My data\";\n</code></pre>\n</hr>", "LastEditorUserId": "1243605", "LastActivityDate": "2012-03-02T00:04:38.060", "Score": "3", "CreationDate": "2009-10-28T18:36:43.677", "ParentId": "1639154", "CommentCount": "9", "OwnerUserId": "5243", "LastEditDate": "2012-03-02T00:04:38.060"}, "25323360": {"Id": "25323360", "PostTypeId": "2", "Body": "<p>With C++11 you can use the <code>constexpr</code> keyword and write in your header:</p>\n<pre><code>private:\n    static constexpr const char* SOMETHING = \"something\";\n</code></pre>\n<p><br/>\n<strong>Notes:</strong></p>\n<ul>\n<li><p><code>constexpr</code> makes <code>SOMETHING</code> a constant pointer so you cannot write</p>\n<pre><code>SOMETHING = \"something different\";\n</code></pre>\n<p>later on.</p></li>\n<li><p>Depending on your compiler, you might also need to write an explicit definition in the .cpp file:</p>\n<pre><code>constexpr const char* MyClass::SOMETHING;\n</code></pre></li>\n</ul>\n", "LastEditorUserId": "490560", "LastActivityDate": "2014-08-28T12:13:21.553", "Score": "6", "CreationDate": "2014-08-15T08:24:20.830", "ParentId": "1639154", "CommentCount": "0", "OwnerUserId": "490560", "LastEditDate": "2014-08-28T12:13:21.553"}});