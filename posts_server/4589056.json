post_cb({"4589056": {"CommentCount": "5", "ViewCount": "718", "PostTypeId": "1", "LastEditorUserId": "3848", "CreationDate": "2011-01-03T22:36:07.523", "LastActivityDate": "2011-01-04T12:22:29.333", "Title": "templates, typename, lambda -> dependent names not dependent?", "AcceptedAnswerId": "4593286", "LastEditDate": "2011-01-04T08:08:27.860", "Id": "4589056", "Score": "3", "Body": "<p>Consider:</p>\n<pre><code>template &lt; typename Something &gt;\nboost::function&lt;void()&gt; f()\n{\n  typedef typename Something::what type;\n  return [](){};\n}\n</code></pre>\n<p>In this code you need the typename because 'what' is a dependent name.  But consider this:</p>\n<pre><code>template &lt; typename Something &gt;\nboost::function&lt;void()&gt; f()\n{\n  return []()\n  { \n    typedef typename Something::what type;\n  };\n}\n</code></pre>\n<p>Compiler bitches: \"typename cannot be used outside a template declaration\"</p>\n<p>WTF?</p>\n<p>THIS works:</p>\n<pre><code>template &lt; typename Something &gt;\nboost::function&lt;void()&gt; f()\n{\n  return []()\n  { \n    typedef Something::what type;\n  };\n}\n</code></pre>\n<p>What is it about the creation of a lambda that means \"what\" is not a dependent name anymore?  Or is this just a bug?</p>\n<p>Heh...correction.  The latter doesn't work.  It says that \"Something\" doesn't exist.  This modified version DOES work though and still unintuitively doesn't need and won't accept \"typename\".</p>\n<pre><code>template &lt; typename T &gt; struct wtf { typedef typename T::what type; };\n\ntemplate &lt; typename Something &gt;\nboost::function&lt;void()&gt; f()\n{\n  return []() { typedef wtf&lt;Something&gt;::type type; };\n}\n</code></pre>\n<p>Of course, now I have TWO questions: the original and, WTF doesn't it find \"Something\" unless it's used as a template parameter??</p>\n", "Tags": "<c++><templates><lambda><c++11><typename>", "OwnerUserId": "301883", "AnswerCount": "2"}, "4591656": {"ParentId": "4589056", "CommentCount": "0", "Body": "<p>It's because the lambda is actually a class defined by the compiler, it doesn't share the template arguments of the outer function, the lambda type is defined when the template is instantiated so the template argument is no longer dependant and <code>typename</code> isn't needed. </p>\n", "OwnerUserId": "3848", "PostTypeId": "2", "Id": "4591656", "Score": "0", "CreationDate": "2011-01-04T08:10:14.460", "LastActivityDate": "2011-01-04T08:10:14.460"}, "bq_ids": {"n4140": {"so_4589056_4593286_0": {"section_id": 5966, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_4589056_4593286_0": {"section_id": 5735, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_4589056_4593286_0": {"section_id": 7460, "quality": 0.9666666666666667, "length": 29}}}, "4593286": {"ParentId": "4589056", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>That's a very interesting question. From my understanding, the first 'WTF' (the one with <code>typename</code> in the lambda body) should be the correct according to N3225 5.1.2/7 :</p>\n<blockquote>\n<p id=\"so_4589056_4593286_0\">The <em>lambda-expression</em>\u2019s <em>compound-statement</em> yields the <em>function-body</em> of the function call operator,\n  <strong>but for purposes of name lookup</strong>, determining the type and value of this and transforming <em>id-expressions</em>\n  referring to non-static class members into class member access expressions using (*this),\n  <strong>the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em></strong>.</p>\n</blockquote>\n<p>As <code>Something</code> is a dependent-name in the context of the lambda expression, it should <em>also</em> be a dependent name in the context of the lambda function body according to this quote.</p>\n", "OwnerUserId": "451980", "LastEditorUserId": "451980", "LastEditDate": "2011-01-04T12:22:29.333", "Id": "4593286", "Score": "3", "CreationDate": "2011-01-04T11:54:34.440", "LastActivityDate": "2011-01-04T12:22:29.333"}});