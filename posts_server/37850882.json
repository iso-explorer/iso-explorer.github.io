post_cb({"37851163": {"ParentId": "37850882", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Standard has nice paragraph (10.3/9):</p>\n<blockquote>\n<p id=\"so_37850882_37851163_0\">[ Note: The interpretation of the call of a virtual function depends on the type of the object for which it is\n  called (the dynamic type), whereas the interpretation of a call of a non-virtual member function depends\n  only on the type of the pointer or reference denoting that object (the static type) (5.2.2). \u2014 end note ]</p>\n</blockquote>\n<p><code>print()</code> is called on implicit <code>this</code> whose (when dereferenced) dynamic type is <code>Bar</code>, however inside <code>callPrint()</code> it's static type is <code>Foo</code>.</p>\n", "OwnerUserId": "4932834", "LastEditorUserId": "4932834", "LastEditDate": "2016-06-16T06:16:58.263", "Id": "37851163", "Score": "7", "CreationDate": "2016-06-16T06:10:14.787", "LastActivityDate": "2016-06-16T06:16:58.263"}, "37851144": {"ParentId": "37850882", "CommentCount": "4", "Body": "<p>When you call <code>b.callPrint();</code>, control transfers to function <code>callPrint</code> in base class. Now the type of <code>this</code> is <code>Foo *</code> which points to an object of <code>Bar *</code>. Now when you call <code>print()</code> or <code>this-&gt;print()</code></p>\n<ol>\n<li><p>In case of non virtual function, the called function is decided at compile time on basis of type of <code>this</code> and thus <code>Foo::print</code> is invoked.</p></li>\n<li><p>In case of virtual function, the called function is decided at run times based on the type of pointed object, and thus <code>Bar::print</code> is invoked.</p></li>\n</ol>\n<hr>\n<p>Do you want to add more fun? Make the function <code>Foo::print()</code> a <code>virtual</code> function and call it from the constructor of <code>Foo</code> and create an object of <code>Bar</code>.</p>\n</hr>", "OwnerUserId": "2659313", "PostTypeId": "2", "Id": "37851144", "Score": "12", "CreationDate": "2016-06-16T06:07:52.830", "LastActivityDate": "2016-06-16T06:07:52.830"}, "bq_ids": {"n4140": {"so_37850882_37851163_0": {"section_id": 7010, "quality": 0.8275862068965517, "length": 24}}, "n3337": {"so_37850882_37851163_0": {"section_id": 6756, "quality": 0.8275862068965517, "length": 24}}, "n4659": {"so_37850882_37851163_0": {"section_id": 8507, "quality": 0.8275862068965517, "length": 24}}}, "37851139": {"ParentId": "37850882", "PostTypeId": "2", "CommentCount": "2", "Body": "<ol>\n<li><p>When it is non virtual the call to <code>print</code> is not overridden by the subclass and thus prints \"Foo\".</p></li>\n<li><p>When it is virtual the call to print is overridden by the subclass and thus the prints \"Bar\".</p></li>\n</ol>\n<p>This is expected behaviour. When you declare a method as virtual then you are saying that the behaviour of the class depends on its subclasses and can (has to) be overridden. You cannot understand the behaviour of a virtual class without knowing all its subclasses.</p>\n", "OwnerUserId": "1566187", "LastEditorUserId": "1566187", "LastEditDate": "2016-06-16T10:45:46.253", "Id": "37851139", "Score": "1", "CreationDate": "2016-06-16T06:07:25.663", "LastActivityDate": "2016-06-16T10:45:46.253"}, "37850882": {"CommentCount": "3", "CreationDate": "2016-06-16T05:51:41.640", "PostTypeId": "1", "AcceptedAnswerId": "37851144", "LastEditorUserId": "2659313", "LastActivityDate": "2016-06-16T10:45:46.253", "LastEditDate": "2016-06-16T06:12:10.940", "ViewCount": "981", "FavoriteCount": "2", "Title": "A counter-intuitive function call in C++", "Id": "37850882", "Score": "9", "Body": "<p>A quite simple C++ code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Foo {\npublic:\n    void callPrint() {\n        print();\n    }\n    void print() {\n        cout &lt;&lt; \"Foo\" &lt;&lt; endl;\n    }\n};\n\nclass Bar : public Foo {\npublic:\n    void print() {\n        cout &lt;&lt; \"Bar\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Bar b;\n    b.callPrint();\n\n    return 0;\n}\n</code></pre>\n<p>Here the output is \"Foo\". And if I make the \"Foo::print()\" virtual, the output will be \"Bar\". My questions are:</p>\n<ol>\n<li><p>When the <code>Foo::print()</code> is non-virtual, why is it called when a <code>Bar</code> object is passed to <code>Foo::callPrint()</code>, is there type (both static and dynamic) mismatch?</p></li>\n<li><p>When <code>Foo:callPrint()</code> is virtual, the call <code>b.callPrint()</code> is not via reference or pointer, however <code>Bar::print()</code> is called. This is not so-called polymorphism, then how to explain this behavior, according to either language definition or compiler implementation?</p></li>\n</ol>\n", "Tags": "<c++>", "OwnerUserId": "6459005", "AnswerCount": "3"}});