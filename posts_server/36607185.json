post_cb({"bq_ids": {"n4140": {"so_36607185_36607185_1": {"length": 30, "quality": 1.0, "section_id": 7043}, "so_36607185_36607185_0": {"length": 48, "quality": 0.9230769230769231, "section_id": 7043}, "so_36607185_36608602_0": {"length": 8, "quality": 1.0, "section_id": 7043}}, "n3337": {"so_36607185_36607185_1": {"length": 30, "quality": 1.0, "section_id": 6788}, "so_36607185_36607185_0": {"length": 46, "quality": 0.8846153846153846, "section_id": 6788}, "so_36607185_36608602_0": {"length": 8, "quality": 1.0, "section_id": 6788}}, "n4659": {"so_36607185_36607185_1": {"length": 28, "quality": 0.9333333333333333, "section_id": 8540}, "so_36607185_36607185_0": {"length": 43, "quality": 0.8269230769230769, "section_id": 8540}, "so_36607185_36608602_0": {"length": 8, "quality": 1.0, "section_id": 8540}}}, "36608602": {"Id": "36608602", "PostTypeId": "2", "Body": "<h2>Explanation and first example</h2>\n<p>Take the following example</p>\n<pre><code>class Z { char c; };\n\nclass X {\npublic: \n    using Y = Z;  // Z refers to an entity outside definition of D\n    Y f();        // Y refers to an entity within definition of D\n};\n</code></pre>\n<p>The wording </p>\n<blockquote>\n<p id=\"so_36607185_36608602_0\">shall refer to an entity defined within the definition of D, <strong>or</strong>\n  shall refer to the same entity</p>\n</blockquote>\n<p>means that: </p>\n<ul>\n<li>either you refer to a an entity defined in X (example of <code>Y</code> in the declaration of <code>f()</code>), </li>\n<li>or you refer to an entity not in X (example of <code>Z</code> used to define <code>Y</code>) but it should refer to the <strong>same</strong> entity <strong>in all the compilation unit</strong> in which you define X.  </li>\n</ul>\n<p>In fact, this complex wording just means that if you define the same class (with the same sequence of tokens, as required in the dash above the one that you quote) in different compilation units, it should have the same meaning.  The purpose is to allow to define a class in a header and include the same header in several cpp files.  </p>\n<h2>How could you break this rule ?</h2>\n<p>Just use the same include with the same class X, but use different versions of class Z.  This would not be odr coompliant: </p>\n<p><strong><em>File X.h:</em></strong></p>\n<pre><code>class X {\npublic: \n    using Y = Z;  // Z refers to an entity outside definition of D\n    Y f();        // Y refers to an entity within definition of D\nprivate: \n    Y yes; \n};\n</code></pre>\n<p><strong><em>File Z1.h:</em></strong> </p>\n<pre><code>class Z { char c; };\n</code></pre>\n<p><strong><em>File Z2.h:</em></strong> </p>\n<pre><code>class Z { int c; char d; };  ///  OOPS !! same class, not same token \n</code></pre>\n<p><strong><em>File a.cpp</em></strong></p>\n<pre><code>#include \"Z1.h\"\n#include \"X.h\"   // X is defined with one meaning for Z \n\nvoid myfunc (X a) { ... } \n</code></pre>\n<p><strong><em>File b.cpp</em></strong> </p>\n<pre><code>#include \"Z2.h\"\n#include \"X.h\"   // ouch X is defined but using another layout for Z !!\nextern void myfunc (X a); \nint main() { X oops;  myfunc(oops); }   // ==&gt; what will happen here ?  \n</code></pre>\n<p>Depending on your C++ implementation, this could fail in multiple ways: linker errors (because the name mangling algorithm could be defeated), memory/stack corruption (because myfunc expects and object of a certain size on the stack, but main is pushing an object of a different size on stack), etc...  </p>\n<h2>Edit: default values</h2>\n<p>In a class function you can define default values for the parameters.  Your additional quote just says that the rule that applies to items of D also applies to expressions used as default parameter. Example:  </p>\n<pre><code>const int I_HATE_GLOBALS=sizeof(int)*3; \n\nstruct T {\n   void show (size_t a=I_HATE_GLOBALS); \n};     \n</code></pre>\n<p>In this example, if <code>I_HATE_GLOBALS</code> is always defined in the same manner, you could have the same definition of T appearing in several translation units.  However, if you'd use the same definition of T in several cpp files, but if you'd manage with the magic of includes and conditional compilation to get a  <code>I_HATE_GLOBAL</code> defined differently, then you'd break the ODR rule.  </p>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2016-04-14T18:39:02.050", "Score": "2", "CreationDate": "2016-04-13T20:09:58.630", "ParentId": "36607185", "CommentCount": "4", "OwnerUserId": "3723423", "LastEditDate": "2016-04-14T18:39:02.050"}, "36607185": {"ViewCount": "143", "Body": "<p>I have few doubts in C++ standard section 3.2 [basic-def-odr] bullet point 6   ( i.e -3.2.6).</p>\n<p>There couple of conditions are specified that tells if a class can be defined multiple times having each definition in separate Translation unit.</p>\n<p>I an not able to find an example of the emphasized part below in this bullet:</p>\n<blockquote>\n<p id=\"so_36607185_36607185_0\">in each definition of D, corresponding names, looked up according to\n  [basic.lookup], <strong>shall refer to an entity defined within the\n  definition of D, or shall refer to the same entity</strong>, after overload\n  resolution ([over.match]) and after matching of partial template\n  specialization ([temp.over]), except that a name can refer to a\n  non-volatile const object with internal or no linkage if the object\n  has the same literal type in all definitions of D, and the object is\n  initialized with a constant expression ([expr.const]), and the object\n  is not odr-used, and the object has the same value in all definitions\n  of D .</p>\n</blockquote>\n<p>Can anyone please give an example where <strong>\"shall refer to an entity defined within the definition of D\"</strong> comes out to be false and makes multiple defintion as an error...</p>\n<p>It would be more helpful if example can be provided to explain the below bullet in the same section as well..</p>\n<blockquote>\n<p id=\"so_36607185_36607185_1\"><em>in each definition of D, a default argument used by an (implicit or explicit) function call is treated as if its token sequence were\n  present in the definition of D; that is, the default argument is\n  subject to the three requirements described above (and, if the default\n  argument has sub-expressions with default arguments, this requirement\n  applies recursively</em></p>\n</blockquote>\n<p>Thanks in Advance </p>\n", "Title": "Multiple Definition of Class in Different Translation unit", "CreationDate": "2016-04-13T18:56:08.617", "LastActivityDate": "2016-04-14T18:39:02.050", "CommentCount": "0", "PostTypeId": "1", "Id": "36607185", "Score": "2", "OwnerUserId": "4279701", "Tags": "<c++><language-lawyer><one-definition-rule>", "AnswerCount": "1"}});