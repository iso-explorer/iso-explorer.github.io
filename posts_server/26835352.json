post_cb({"bq_ids": {"n4140": {"so_26835352_26835352_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 224}, "so_26835352_26835352_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 224}}, "n3337": {"so_26835352_26835352_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 217}, "so_26835352_26835352_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 217}}, "n4659": {"so_26835352_26835352_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 232}, "so_26835352_26835352_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 232}}}, "26835352": {"ViewCount": "177", "Body": "<p>This is about dependent name lookup in a template function, for example:</p>\n<pre><code>template&lt;class T&gt;\nvoid foo(T const &amp;t)\n{\n    ::func(t);\n}\n</code></pre>\n<p>In this code, <code>func</code> is a dependent name because it has a type-dependent expression as argument to a function call. In C++11 the lookup for <code>func</code> was covered by [temp.dep.candidate]/1:</p>\n<blockquote>\n<p id=\"so_26835352_26835352_0\">For a function call that depends on a template parameter, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2, 3.4.3) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only function declarations from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n</blockquote>\n<p>[Note: 3.4.1 is \"ordinary\" unqualified-id lookup, and 3.4.2 is unqualified-id lookup for function names, aka. ADL, and 3.4.3 is qualified-id lookup].</p>\n<p>However in C++14 (N3936) the parts about <em>qualified-id</em> lookup were removed:</p>\n<blockquote>\n<p id=\"so_26835352_26835352_1\">For a function call where the <em>postfix-expression</em> is a dependent name, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1), only function declarations from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n</blockquote>\n<p>Assuming that this change was done on purpose; which clauses now cover the finding of candidate functions for a function call where the postfix-expression is a dependent name and a qualified-id ?</p>\n<p>(Background: I am looking for confirmation that qualified name lookup still only looks in the template definition context, not the instantiation context).</p>\n", "AcceptedAnswerId": "26835622", "Title": "Dependent qualified name lookup in C++14", "CreationDate": "2014-11-10T01:19:57.943", "Id": "26835352", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-11-10T02:24:36.847", "LastEditorUserId": "1505939", "LastActivityDate": "2014-11-10T02:24:36.847", "Score": "4", "OwnerUserId": "1505939", "Tags": "<c++><templates><language-lawyer><c++14><overload-resolution>", "AnswerCount": "1"}, "26835622": {"Id": "26835622", "PostTypeId": "2", "Body": "<p>Defect report <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3367.html#1321\" rel=\"nofollow\">1321</a> has been accepted into the latest C++14 draft (N4140). This defect report clarifies the equivalency of dependent names, and at the same time clarifies that a dependent name must be an <em>unqualified-id</em>. Formerly, in C++11, dependent names could be arbitrary <em>id-expression</em>s.</p>\n<p>This means that <em>qualified-id</em> names are no longer dependent names, and are therefore looked up according to \u00a714.6.3 [temp.nondep]. This doesn't actually affect program behaviour from C++11, since dependent names only affect whether ADL (\u00a73.4.2) is performed with the template instantiation context, and only <em>unqualified-id</em>s are eligible for ADL anyway.</p>\n", "LastEditorUserId": "1204143", "LastActivityDate": "2014-11-10T02:03:51.370", "Score": "2", "CreationDate": "2014-11-10T01:57:39.853", "ParentId": "26835352", "CommentCount": "2", "LastEditDate": "2014-11-10T02:03:51.370", "OwnerUserId": "1204143"}});