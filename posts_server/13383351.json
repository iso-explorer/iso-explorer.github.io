post_cb({"13383351": {"CommentCount": "1", "ViewCount": "330", "PostTypeId": "1", "LastEditorUserId": "211160", "CreationDate": "2012-11-14T16:50:54.313", "LastActivityDate": "2013-04-25T16:55:52.620", "Title": "Is it legal in C++11 to inherit from private nested type?", "AcceptedAnswerId": "13384445", "LastEditDate": "2012-11-14T17:24:37.513", "Id": "13383351", "Score": "3", "Body": "<p>What I am trying to do is to have a variable-size POD as a Pimpl in my library class:</p>\n<pre><code>// header file\nclass foo {\npublic:\n    // ctors, copy, move, dtor, etc.\n\nprivate:\n    struct impl; // forward-declared\n    impl* pimpl; // pointer to private implementation\n};\n</code></pre>\n<p>Then define several fixed-size implementations like this:</p>\n<pre><code>// .cpp implementation file\nstruct foo::impl {\n    uint32_t refs;\n    uint32_t size;\n    uint32_t len;\n    uint32_t data;\n};\n\nstatic_assert( sizeof( typename foo::impl ) == 16, \"paranoia\" );\n\nnamespace { // anonymous\n    typedef typename foo::impl base;\n\n    template &lt;size_t S&gt;\n    struct block : base {\n        static_assert( S &gt; 16, \"invalid block size\" );\n        static_assert((( S - 1 ) &amp; S ) == 0, \"block size must be power of 2\" );\n\n        uint8_t pad[S - 16];\n    };\n\n    typedef block&lt;64&gt;  block64;\n    typedef block&lt;128&gt; block128;\n    // ...\n}\n\n// foo implementation using the above PODs\n</code></pre>\n<p>GCC versions 4.6 and 4.7 have no issues compiling this with <code>-std=c++0x -Wall -pedantic</code>, but I am still fuzzy about legality of using private nested type name like that. Wading through my [maybe outdated draft] copy of C++11 standard did not give me any better clues.</p>\n<p>If anybody can point me to anything (preferably a section in the standard) that proves this one way or the other (legal or not) I would be eternally grateful.</p>\n", "Tags": "<c++><c++11><language-lawyer><pimpl-idiom>", "OwnerUserId": "106671", "AnswerCount": "2"}, "13384405": {"ParentId": "13383351", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I think that this isn't allowed. Although there's a note in the standard that</p>\n<blockquote>\n<p id=\"so_13383351_13384405_0\">Because access control applies to names, if access control is applied to a typedef name, only the accessibility of the typedef name itself is considered. The accessibility of the entity referred to by the typedef is not considered.</p>\n</blockquote>\n<p>So in</p>\n<pre><code>struct block : base\n</code></pre>\n<p>the name <code>base</code> is accessible. However the typedef itself uses the name <code>foo::impl</code>, which is private and therefore inaccessible. The name also would be inaccessible in the static_assert.</p>\n<p>I don't see any exceptions that would allow the name to be accessed in these contexts.</p>\n<p>My compiler produces these errors for this code:</p>\n<pre><code>main.cpp:16:27: error: 'impl' is a private member of 'foo'\nstatic_assert(sizeof(foo::impl) == 16, \"paranoia\");\n                          ^\nmain.cpp:4:12: note: declared private here\n    struct impl; // forward-declared\n           ^\nmain.cpp:19:27: error: 'impl' is a private member of 'foo'\n    typedef typename foo::impl base;\n                          ^\nmain.cpp:4:12: note: declared private here\n    struct impl; // forward-declared\n           ^\n</code></pre>\n<hr>\n<p>One option might be to include a public friend in <code>foo</code>, which will have access to the private names inside <code>foo</code>. Then you can place the definition of that friend type in the cpp file so that the names it exposes are exposed only in that one file:</p>\n<pre><code>// header\nstruct foo {\n    struct private_public_access;\nprivate:\n    struct impl;\n};\n\n// cpp\nstruct foo::impl {};\n\nstruct private_public_access {\n    typedef foo::impl foo_impl;\n};\n\ntypedef private_public_access::foo_impl base;\n</code></pre>\n<p>Anyone will be able to use the name <code>private_public_access</code>, but they won't have the definition and so won't be able to access <code>private_public_access::foo_impl</code> (although they could define it themselves to gain access...). Although if this is acceptable then maybe it'd be just as acceptable to leave the name <code>foo::impl</code> public and its definition hidden like it already is (and like <code>private_public_access</code>'s definition is hidden).</p>\n</hr>", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2013-04-25T16:55:52.620", "Id": "13384405", "Score": "3", "CreationDate": "2012-11-14T17:53:52.443", "LastActivityDate": "2013-04-25T16:55:52.620"}, "13384445": {"ParentId": "13383351", "CommentCount": "2", "Body": "<p>The implementation you have is not legal: Access to <code>foo::impl</code> is private, i.e., only the definition of <code>foo</code> or its members can reference it. In the implementation file you reference the name at namespace scope.</p>\n<p>The relevant part of the standard is 11 [class.access] paragraph 1 and paragraph 4.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "13384445", "Score": "3", "CreationDate": "2012-11-14T17:55:53.407", "LastActivityDate": "2012-11-14T17:55:53.407"}, "bq_ids": {"n4140": {"so_13383351_13384405_0": {"section_id": 6667, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_13383351_13384405_0": {"section_id": 6422, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_13383351_13384405_0": {"section_id": 8142, "quality": 0.9473684210526315, "length": 18}}}});