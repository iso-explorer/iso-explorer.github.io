post_cb({"25596656": {"CommentCount": "0", "ViewCount": "391", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2014-08-31T21:55:01.650", "LastActivityDate": "2014-08-31T23:08:50.133", "Title": "Global overload delete[] not called in third-party libraries", "AcceptedAnswerId": "25596789", "LastEditDate": "2014-08-31T21:57:43.577", "Id": "25596656", "Score": "6", "Body": "<p>I'm trying to learn about memory pools in <a href=\"http://en.wikipedia.org/wiki/C%2B%2B\">C++</a> for better speed and debugging capabilities. I've been following the approach found here: <a href=\"http://oroboro.com/overloading-operator-new/\">http://oroboro.com/overloading-operator-new/</a>. So I've overloaded <code>new</code>, <code>new[]</code>, <code>delete</code>, and <code>delete[]</code> like this:</p>\n<pre><code>inline void* operator new     ( size_t size ) { return myAlloc( size ); }\ninline void* operator new[]   ( size_t size ) { return myAlloc( size ); }\ninline void  operator delete  ( void* ptr   ) { myFree( ptr ); }\ninline void  operator delete[]( void* ptr   ) { myFree( ptr ); }\n</code></pre>\n<p>I like that third-party libraries are directed to this version of <code>new</code>, but I ran into a problem. I am making a <a href=\"http://en.wikipedia.org/wiki/DirectX\">DirectX</a> application that uses DXUT. I compile DXUT separately from my project. Eventually it calls:</p>\n<pre><code>std::unique_ptr&lt;D3D11_SUBRESOURCE_DATA[]&gt; initData( new (std::nothrow) D3D11_SUBRESOURCE_DATA[ mipCount * arraySize ] );\n</code></pre>\n<p>Once this unique pointer goes out of scope, it crashes on a call to  <code>delete[] _Ptr</code>, which did not go through my overloaded operator. I tried debugging my memory pool implementation by adding a <code>int* dummy = new int[10]; delete[] dummy;</code> in my <code>main</code>. Building the project gave an error, but clean-building worked fine. To my surprise, everything worked, including the DXUT line that was crashing!</p>\n<p>Question 1: What exactly happened when I added the debugging line that fixed the issue? I guess for some reason my operator delete[] was not known until I called it in my own application code? Is this guaranteed to fix the problem or is it just dumb luck?</p>\n<p>Question 2: I noticed that the <code>new (std::nothrow) D3D11_SUBRESOURCE_DATA[ mipCount * arraySize ]</code> did not call my <code>operator new[]</code> directly, but eventually called my <code>operator new</code> (no brackets). It still calls operator <code>delete[]</code> on the pointer. Does this pose an issue? Do I have to add the appropriate overload such that my <code>operator new[]</code> is called or is this behavior fine?</p>\n<p>For reference, the <code>operator new[]</code> overload that was called was:</p>\n<pre><code>void * __CRTDECL operator new[](::size_t count, const std::nothrow_t&amp; x)\n_THROW0()\n{ // Try to allocate count bytes for an array\n    return (operator new(count, x));\n}\n</code></pre>\n", "Tags": "<c++><memory-management>", "OwnerUserId": "2766893", "AnswerCount": "1"}, "25596789": {"ParentId": "25596656", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-08-31T22:13:52.937", "Score": "4", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-31T23:08:50.133", "Id": "25596789", "OwnerUserId": "2756719", "Body": "<blockquote>\n<p id=\"so_25596656_25596789_0\">Question 1: What exactly happened when I added the debugging line that\n  fixed the issue? I guess for some reason my operator delete[] was not\n  known until I called it in my own application code? Is this guaranteed\n  to fix the problem or is it just dumb luck?</p>\n</blockquote>\n<p>\u00a73.2 [basic.def.odr]/p4:</p>\n<blockquote>\n<p id=\"so_25596656_25596789_1\">An inline function shall be defined in every translation unit in which\n  it is odr-used.</p>\n</blockquote>\n<p>It sounds like that your compiler didn't generate code for global <code>operator delete[]</code> since it's not used in your main translation unit and is marked <code>inline</code> (meaning that the compiler can assume that any translation unit that uses them will have a definition of them). However, your separately compiled library doesn't have a definition of those functions, and you end up using the default ones from the standard library. Making them non-<code>inline</code> should fix the problem.</p>\n<blockquote>\n<p id=\"so_25596656_25596789_2\">Question 2: I noticed that the <code>new (std::nothrow) D3D11_SUBRESOURCE_DATA[ mipCount * arraySize ]</code> did not call my\n  <code>operator new[]</code> directly, but eventually called my <code>operator new</code> (no\n  brackets). It still calls operator <code>delete[]</code> on the pointer. Does\n  this pose an issue? Do I have to add the appropriate overload such\n  that my <code>operator new[]</code> is called or is this behavior fine?</p>\n</blockquote>\n<p>The default versions of both throwing and nonthrowing versions of <code>operator new []</code>, as well as the nonthrowing version of <code>operator new</code>, are specified to call the throwing version of <code>operator new</code> to obtain memory. So you are safe there. However, your <code>operator new</code>'s definitions are likely wrong. They must return a valid pointer or throw an exception. Returning a null pointer is not allowed.</p>\n", "LastActivityDate": "2014-08-31T23:08:50.133"}, "bq_ids": {"n4140": {"so_25596656_25596789_1": {"section_id": 5404, "quality": 1.0, "length": 7}}, "n3337": {"so_25596656_25596789_1": {"section_id": 5199, "quality": 1.0, "length": 7}}, "n4659": {"so_25596656_25596789_1": {"section_id": 6853, "quality": 1.0, "length": 7}}}});