post_cb({"2204202": {"ParentId": "2204176", "CommentCount": "0", "Body": "<p>Typically for dynamic lists of items, you use a <code>std::vector</code>.</p>\n<p>Generally I use memset or a loop for raw memory dynamic allocation, depending on how variable I anticipate that area of code to be in the future.</p>\n", "OwnerUserId": "26227", "PostTypeId": "2", "Id": "2204202", "Score": "0", "CreationDate": "2010-02-05T00:12:32.400", "LastActivityDate": "2010-02-05T00:12:32.400"}, "2204325": {"ParentId": "2204176", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There is number of methods to allocate an array of intrinsic type and all of these method are correct, though which one to choose, depends...</p>\n<p>Manual initialisation of all elements in loop</p>\n<pre><code>int* p = new int[10];\nfor (int i = 0; i &lt; 10; i++)\n{\n    p[i] = 0;\n}\n</code></pre>\n<p>Using <a href=\"http://en.cppreference.com/w/cpp/string/byte/memset\" rel=\"nofollow noreferrer\"><code>std::memset</code></a> function from <code>&lt;cstring&gt;</code></p>\n<pre><code>int* p = new int[10];\nstd::memset(p, 0, 10);\n</code></pre>\n<p>Using <a href=\"http://en.cppreference.com/w/cpp/algorithm/fill_n\" rel=\"nofollow noreferrer\"><code>std::fill_n</code></a> algorithm from <code>&lt;algorithm&gt;</code></p>\n<pre><code>int* p = new int[10];\nstd::fill_n(p, 10, 0);\n</code></pre>\n<p>Using <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow noreferrer\"><code>std::vector</code></a> container</p>\n<pre><code>std::vector&lt;int&gt; v(10); // elements zero'ed\n</code></pre>\n<p>If <a href=\"http://www2.research.att.com/~bs/C++0xFAQ.html\" rel=\"nofollow noreferrer\">C++0x</a> available, using <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow noreferrer\">initializer list</a> features </p>\n<pre><code>int a[] = { 1, 2, 3 }; // 3-element static size array\nvector&lt;int&gt; v = { 1, 2, 3 }; // 3-element array but vector is resizeable in runtime\n</code></pre>\n", "OwnerUserId": "151641", "LastEditorUserId": "151641", "LastEditDate": "2017-01-20T12:55:22.830", "Id": "2204325", "Score": "17", "CreationDate": "2010-02-05T00:42:29.767", "LastActivityDate": "2017-01-20T12:55:22.830"}, "2204194": {"ParentId": "2204176", "CommentCount": "0", "Body": "<p><code>std::fill</code> is one way. Takes two iterators and a value to fill the region with. That, or the for loop, would (I suppose) be the more C++ way.</p>\n<p>For setting an array of primitive integer types to 0 specifically, <code>memset</code> is fine, though it may raise eyebrows. Consider also <code>calloc</code>, though it's a bit inconvenient to use from C++ because of the cast.</p>\n<p>For my part, I pretty much always use a loop.</p>\n<p>(I don't like to second-guess people's intentions, but it is true that <code>std::vector</code> is, all things being equal, preferable to using <code>new[]</code>.)</p>\n", "Id": "2204194", "PostTypeId": "2", "OwnerDisplayName": "please delete me", "Score": "2", "CreationDate": "2010-02-05T00:10:23.220", "LastActivityDate": "2010-02-05T00:10:23.220"}, "2204209": {"ParentId": "2204176", "CommentCount": "7", "Body": "<p>you can always use memset:</p>\n<pre><code>int myArray[10];\nmemset( myArray, 0, 10 * sizeof( int ));\n</code></pre>\n", "OwnerUserId": "62488", "PostTypeId": "2", "Id": "2204209", "Score": "1", "CreationDate": "2010-02-05T00:14:41.547", "LastActivityDate": "2010-02-05T00:14:41.547"}, "2204208": {"ParentId": "2204176", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If the memory you are allocating is a class with a constructor that does something useful, the operator new will call that constructor and leave your object initialized.</p>\n<p>But if you're allocating a <a href=\"https://stackoverflow.com/questions/146452/what-are-pod-types-in-c\">POD</a> or something that doesn't have a constructor that initializes the object's state, then you cannot allocate memory and initialize that memory with operator new in one operation.  However, you have several options:</p>\n<p>1) Use a stack variable instead.  You can allocate and <a href=\"https://stackoverflow.com/questions/1065774/c-c-initialization-of-a-normal-array-with-one-default-value\">default-initialize</a> in one step, like this:</p>\n<pre><code>int vals[100] = {0};  // first element is a matter of style\n</code></pre>\n<p>2) use <code>memset()</code>.  Note that if the object you are allocating is not a <a href=\"https://stackoverflow.com/questions/146452/what-are-pod-types-in-c\">POD</a>, memsetting it is a bad idea.  One specific example is if you memset a class that has virtual functions, you will blow away the vtable and leave your object in an unusable state.</p>\n<p>3) Many operating systems have calls that do what you want - allocate on a heap and initialize the data to something.  A Windows example would be <a href=\"http://msdn.microsoft.com/en-us/library/aa366887(VS.85).aspx\" rel=\"nofollow noreferrer\"><code>VirtualAlloc()</code></a></p>\n<p>4) This is usually the best option.  Avoid having to manage the memory yourself at all.  You can use STL containers to do just about anything you would do with raw memory, including allocating and initializing all in one fell swoop:</p>\n<pre><code>std::vector&lt;int&gt; myInts(100, 0);  // creates a vector of 100 ints, all set to zero\n</code></pre>\n", "OwnerUserId": "241536", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:15.357", "Id": "2204208", "Score": "7", "CreationDate": "2010-02-05T00:14:19.590", "LastActivityDate": "2010-02-05T00:24:25.310"}, "2204176": {"CommentCount": "4", "AcceptedAnswerId": "2204380", "CreationDate": "2010-02-05T00:06:19.800", "LastActivityDate": "2017-01-20T12:55:22.830", "PostTypeId": "1", "ViewCount": "86658", "FavoriteCount": "50", "Title": "How to initialise memory with new operator in C++?", "Id": "2204176", "Score": "123", "Body": "<p>I'm just beginning to get into C++ and I want to pick up some good habits. If I have just allocated an array of type <code>int</code> with the <code>new</code> operator, how can I initialise them all to 0 without looping through them all myself? Should I just use <code>memset</code>? Is there a \u201cC++\u201d way to do it?</p>\n", "Tags": "<c++><initialization><memory-management><new-operator>", "OwnerUserId": "10320", "AnswerCount": "8"}, "2204182": {"ParentId": "2204176", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>Yes there is:</p>\n<pre><code>std::vector&lt;int&gt; vec(SIZE, 0);\n</code></pre>\n<p>Use a vector instead of a dynamically allocated array. Benefits include not having to bother with explicitely deleting the array (it is deleted when the vector goes out of scope) and also that the memory is automatically deleted even if there is an exception thrown.</p>\n<p>Edit: To avoid further drive-by downvotes from people that do not bother to read the comments below, I should make it more clear that this answer does not say that vector is <em>always</em> the right answer. But it sure is a more C++ way than \"manually\" making sure to delete an array.</p>\n<p>Now with C++11, there is also std::array that models a constant size array (vs vector that is able to grow). There is also std::unique_ptr that manages a dynamically allocated array (that can be combined with initialization as answered in other answers to this question). Any of those are a more C++ way than manually handling the pointer to the array, IMHO.</p>\n", "OwnerUserId": "227322", "LastEditorUserId": "227322", "LastEditDate": "2014-02-08T18:55:50.720", "Id": "2204182", "Score": "6", "CreationDate": "2010-02-05T00:08:19.993", "LastActivityDate": "2014-02-08T18:55:50.720"}, "2204189": {"ParentId": "2204176", "CommentCount": "3", "Body": "<p>Assuming that you really do want an array and not a std::vector, the \"C++ way\" would be this</p>\n<pre><code>#include &lt;algorithm&gt; \n\nint* array = new int[n]; // Assuming \"n\" is a pre-existing variable\n\nstd::fill_n(array, n, 0); \n</code></pre>\n<p>But be aware that under the hood this is still actually just a loop that assigns each element to 0 (there's really not another way to do it, barring a special architecture with hardware-level support).</p>\n", "OwnerUserId": "39375", "PostTypeId": "2", "Id": "2204189", "Score": "23", "CreationDate": "2010-02-05T00:09:45.410", "LastActivityDate": "2010-02-05T00:09:45.410"}, "bq_ids": {"n4140": {"so_2204176_2204380_0": {"section_id": 6098, "quality": 1.0, "length": 7}}, "n3337": {"so_2204176_2204380_0": {"section_id": 5864, "quality": 1.0, "length": 7}}, "n4659": {"so_2204176_2204380_0": {"section_id": 7595, "quality": 1.0, "length": 7}}}, "2204380": {"ParentId": "2204176", "CommentCount": "5", "Body": "<p>It's a surprisingly little-known feature of C++ (as evidenced by the fact that no-one has given this as an answer yet), but it actually has special syntax for default-initializing an array (well, technically, it's called \"value-initialize\" in the Standard):</p>\n<pre><code>new int[10]();\n</code></pre>\n<p>Note that you <em>must</em> use the empty parentheses - you cannot, for example, use <code>(0)</code> or any other expression (which is why this is only useful for default initialization). </p>\n<p>This is explicitly permitted by ISO C++03 5.3.4[expr.new]/15, which says:</p>\n<blockquote>\n<p id=\"so_2204176_2204380_0\">A new-expression that creates an object of type T initializes that object as follows:</p>\n<p id=\"so_2204176_2204380_1\">...</p>\n<ul>\n<li>If the new-initializer is of the form (), the item is value-initialized (8.5);</li>\n</ul>\n</blockquote>\n<p>and does not restrict the types for which this is allowed, whereas the <code>(expression-list)</code> form is explicitly restricted by further rules in the same section such that it does not allow array types.</p>\n", "OwnerUserId": "111335", "PostTypeId": "2", "Id": "2204380", "Score": "295", "CreationDate": "2010-02-05T00:57:46.283", "LastActivityDate": "2010-02-05T00:57:46.283"}});