post_cb({"6246561": {"Id": "6246561", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6246365_6246561_0\">I'm actually implementing a generic base class that takes a template parameter class and derives from it, and adds a \"safe bool\" conversion based on the result of a function call on the derived type. I'd like to avoid using virtual functions, if possible, because <s>I'm a serial premature optimiser</s> I really do care about performance in some of the places I'd like to use this. \u2013 Autopulated 37 mins ago</p>\n</blockquote>\n<p>You don't need a reference to the Derived class. Your class is deriving from a template parameter. Just use the common method.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nclass Base : public T\n{\npublic:\n    bool operator!() const \n    {\n        return !this-&gt;isOk();\n    }\n};\n\nclass TemplateClass\n{\n\npublic:\n    bool isOk() const\n    {\n        return true;\n    }\n};\n\nint main (int argc, char* argv[])\n{\n    Base&lt;TemplateClass&gt; myClass;\n\n    if (!!myClass)\n    {\n        std::cout &lt;&lt; \"ok\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; \"not ok\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>You can even use template specialization if you know ahead of time of derived classes that don't implement a common bool check.</p>\n", "LastActivityDate": "2011-06-05T23:14:43.467", "CommentCount": "0", "CreationDate": "2011-06-05T23:14:43.467", "ParentId": "6246365", "Score": "0", "OwnerUserId": "553308"}, "6246403": {"Id": "6246403", "PostTypeId": "2", "Body": "<p>I think in general you're OK doing this, but be very careful in constructors and destructors. In particular, in <code>Base::~Base</code>, the <code>Derived</code> part of the object has already been destroyed so don't use <code>m_ref</code> there.</p>\n", "LastActivityDate": "2011-06-05T22:44:33.203", "CommentCount": "3", "CreationDate": "2011-06-05T22:44:33.203", "ParentId": "6246365", "Score": "2", "OwnerUserId": "1821"}, "6246667": {"Id": "6246667", "PostTypeId": "2", "Body": "<p>3.8/6 says what you can do with a pointer/reference to memory for an object that has been allocated but not yet constructed. Your code doesn't provoke an lvalue-to-rvalue conversion, or otherwise break the rules, so I'd think that you're fine. Since you're observing bad values, though, I may well have missed something. Or your code might be otherwise bad.</p>\n<p>Even if you did break those rules, 12.6.2 and 12.7 list additional things that you can do <em>during</em> construction and destruction.</p>\n<p>Edit: ah, 8.3.2/4: \"A reference shall be initialized to refer to a valid object\nor function.\" You initialize <code>m_ref</code> to refer to an object whose constructor hasn't even been entered yet. I don't know without further research whether an object under construction is \"valid\" or not, and in particular whether the object of most-derived type is \"valid\" at the time of construction of the base class. This could perhaps be the problem, though.</p>\n<p>You might think that no unconstructed object is \"valid\", but then this would be invalid:</p>\n<pre><code>class Foo {\n    Foo() {\n        Foo &amp;self = *this; // reference initialized to refer to unconstructed object!\n    }\n};\n</code></pre>\n<p>So, is that invalid? If not, does the most-derived object become valid somewhere between the start of the base class constructor call and the start of the derived class constructor call? I dunno, sorry.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-06-06T00:07:58.977", "Score": "2", "CreationDate": "2011-06-05T23:39:59.743", "ParentId": "6246365", "CommentCount": "0", "OwnerUserId": "13005", "LastEditDate": "2011-06-06T00:07:58.977"}, "6246365": {"ViewCount": "489", "Body": "<p>I'd like to do this:</p>\n<pre><code>struct Derived;\n\nstruct Base{\n    Derived const&amp; m_ref;\n    Base(Derived const&amp; ref) : m_ref(ref){}\n};\n\nstruct Derived: Base{\n    Derived(): Base(*this){}\n};\n</code></pre>\n<p>But I seem to get unreliable behaviour (when used later on, <code>m_ref</code> points to things that aren't valid Derived).</p>\n<p>Is it permissible to construct a reference to Derived from <code>*this</code> before the class has been initialised?</p>\n<p>I appreciate that it is not valid to <em>use</em> such a reference until it has been initialised, but I don't see how changes to the initialisation of a class can affect references to it (since initialising it doesn't move it around in memory...).</p>\n<p>I'm not sure what to call what I'm trying to do, so my search for information on this has drawn a blank...</p>\n<p><br>\n<br>\n<strong>Update:</strong>\nI can't reproduce my problems with a simple test case, so it looks like it is <em>probably</em> okay (though I can't prove it, and would still welcome a definitive answer).\nSuspect my problems arose from a broken copy-assignment operator. That's another matter altogether though!</br></br></p>\n<p><strong>Update 2</strong>\nMy copy constructor and copy-assignment operators were indeed to blame, and now this seems to work reliably. Still interested in whether or not it is well-defined behaviour though.</p>\n", "AcceptedAnswerId": "6258431", "Title": "Base class holding a reference to Derived", "CreationDate": "2011-06-05T22:34:35.410", "Id": "6246365", "CommentCount": "17", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-06-06T12:01:36.573", "LastEditorUserId": "233201", "LastActivityDate": "2011-06-06T22:44:22.060", "Score": "4", "OwnerUserId": "233201", "Tags": "<c++>", "AnswerCount": "5"}, "6246417": {"Id": "6246417", "PostTypeId": "2", "Body": "<p>I think the big problem in this is that you think you want to do one thing, when in reality you actually want to do something else. Strange, huh?</p>\n<blockquote>\n<p id=\"so_6246365_6246417_0\">Is it permissible to construct a reference to Derived from *this before the class has been initialised?</p>\n</blockquote>\n<p>Yes, as long as you don't <strong>use</strong> it (for anything but storing a reference to it) in the scope of the Base constructor and remember in ~Base that Derived is destroyed before Base.</p>\n<p>But why on earth do you think that Base wants to know of Derived? If it's static polymorphism you are after, then the <a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow\">curiously recurring template pattern</a> is what you want:</p>\n<pre><code>template &lt;typename T&gt;\nclass Base {};\n\nclass Derived : public Base&lt;Derived&gt; {};\n</code></pre>\n<p>But I don't really think that's what you're aiming at.</p>\n<p>Maybe you want a way for Base to communicate with a client and think that should be done with inheritance? If so, then this observer-ish idiom is what you need:</p>\n<pre><code>class Client\n{\npublic: \n    virtual void Behavior() = 0;\n\nprotected:\n    ~Client() {}\n};\n\nclass Base\n{\n    Client&amp; client_;\n\npublic:\n    Base(Client&amp; client) : client_(client) {}\n};\n\nclass Implementor : public Client\n{\npublic:\n    Implementor() : Base(*this) {}\n\n    virtual void Behavior() { ... }\n};\n</code></pre>\n<p>If not even that is what you want, then you need to rethink your design.</p>\n", "LastEditorUserId": "6345", "LastActivityDate": "2011-06-06T10:37:59.760", "Score": "1", "CreationDate": "2011-06-05T22:48:14.917", "ParentId": "6246365", "CommentCount": "4", "OwnerUserId": "6345", "LastEditDate": "2011-06-06T10:37:59.760"}, "bq_ids": {"n4140": {"so_6246365_6258431_3": {"length": 6, "quality": 1.0, "section_id": 3222}, "so_6246365_6258431_1": {"length": 55, "quality": 0.9166666666666666, "section_id": 7193}, "so_6246365_6258431_0": {"length": 15, "quality": 0.75, "section_id": 7189}, "so_6246365_6258431_4": {"length": 13, "quality": 0.8125, "section_id": 7193}, "so_6246365_6258431_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 7194}}, "n3337": {"so_6246365_6258431_3": {"length": 6, "quality": 1.0, "section_id": 3096}, "so_6246365_6258431_1": {"length": 58, "quality": 0.9666666666666667, "section_id": 6937}, "so_6246365_6258431_0": {"length": 15, "quality": 0.75, "section_id": 6933}, "so_6246365_6258431_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 6938}, "so_6246365_6258431_4": {"length": 14, "quality": 0.875, "section_id": 6937}}, "n4659": {"so_6246365_6258431_3": {"length": 6, "quality": 1.0, "section_id": 3979}, "so_6246365_6258431_1": {"length": 54, "quality": 0.9, "section_id": 8702}, "so_6246365_6258431_0": {"length": 15, "quality": 0.75, "section_id": 8697}, "so_6246365_6258431_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 8703}, "so_6246365_6258431_4": {"length": 13, "quality": 0.8125, "section_id": 8702}}}, "6258431": {"Id": "6258431", "PostTypeId": "2", "Body": "<p>3.8/1 says:</p>\n<blockquote>\n<p id=\"so_6246365_6258431_0\"><strong>The lifetime of an object of type T\n  begins when</strong>: \u2014 storage with the proper\n  alignment and size for type T is\n  obtained, and \u2014 if T is a class type\n  with a non-trivial constructor (12.1),\n  <strong>the constructor call has completed</strong>.</p>\n</blockquote>\n<p>3.8/5 says:</p>\n<blockquote>\n<p id=\"so_6246365_6258431_1\"><strong>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated</strong>\n  or, after the lifetime of an object has ended and before the storage which the object occupied is\n  reused or released, <strong>any pointer that refers to the storage location where the object will be or was located\n  may be used but only in limited ways</strong>. Such a pointer refers to allocated storage (3.7.3.2), and using the\n  pointer as if the pointer were of type void*, is well-defined. <strong>Such a pointer may be dereferenced but the\n  resulting lvalue may only be used in limited ways, as described below.</strong></p>\n</blockquote>\n<p>\"Below\" is 3.8/6:</p>\n<blockquote>\n<p id=\"so_6246365_6258431_2\">Such an lvalue refers to allocated storage (3.7.3.2), and using the properties of the lvalue which do not\n  depend on its value is well-defined.</p>\n</blockquote>\n<p>...and then a list of things you can't do. Binding to a reference to the same, derived type is not among them.</p>\n<p>I can't find anything elsewhere that might make your code invalid. Notably, despite the following phrase in 8.3.2/4:</p>\n<blockquote>\n<p id=\"so_6246365_6258431_3\">A reference shall be initialized to\n  refer to a valid object or function.</p>\n</blockquote>\n<p>there doesn't seem to be any definition of \"valid object\" to speak of.</p>\n<p>So, after much to-ing and fro-ing, <strong>I must conclude that it is legal</strong>.</p>\n<hr>\n<p><em>Of course, that's not to say that it's in any way a good idea!</em> <strong>It still looks like a bad design.</strong></p>\n<p>For example, if you later change your base constructor and any of the following become relevant (again from 3.8/6):</p>\n<ul>\n<li>the lvalue is used to access a non-static data member or call a non-static member function of the object</li>\n<li>the lvalue is implicitly converted (4.10) to a reference to a base class type</li>\n<li>the lvalue is used as the operand of a <code>static_cast</code> (5.2.9) (except when the conversion is ultimately to <code>char&amp;</code> or <code>unsigned char&amp;</code></li>\n<li>the lvalue is used as the operand of a <code>dynamic_cast</code> (5.2.7) or as the operand of <code>typeid</code>.</li>\n</ul>\n<p>...then your program will be undefined, and the compiler may emit no diagnostic for this!</p>\n<hr>\n<p><strong>Random other observations</strong></p>\n<p>I notice a couple of other <em>interesting</em> things whilst compiling this answer, and this is as good a place as any to share them.</p>\n<p>First, 9.3.2 appears to leave the type of <code>this</code> in a <em>ctor-initializer</em> accidentally unspecified. Bizarre!</p>\n<p>Second, the criteria set on a pointer by 3.8/5 (not the same list that I quoted from 3.8/6) include:</p>\n<blockquote>\n<p id=\"so_6246365_6258431_4\">If the object will be or was of a\n  non-POD class type, the program has\n  undefined behavior if [..] the\n  pointer is implicitly converted (4.10)\n  to a pointer to a base class type.</p>\n</blockquote>\n<p>I believe that this renders the following innocuous-looking code undefined:</p>\n<pre><code>struct A {\n   A(A* ptr) {}\n};\n\nstruct B : A {\n   B() : A(this) {}\n};\n\nint main() {\n   B b;\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-06-06T22:44:22.060", "Score": "2", "CreationDate": "2011-06-06T21:49:06.463", "ParentId": "6246365", "CommentCount": "0", "OwnerUserId": "560648", "LastEditDate": "2011-06-06T22:44:22.060"}});