post_cb({"5927749": {"PostTypeId": "2", "ParentId": "5927586", "Body": "<p>You can only do this safely if your class is plain old data (POD).\nFrom <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow\">Wikipedia</a>:</p>\n<blockquote>\n<p id=\"so_5927586_5927749_0\">A POD type in C++ is defined as either a scalar type or a POD class. A POD class has no user-defined copy assignment operator, no user-defined destructor, and no non-static data members that are not themselves PODs. Moreover, a POD class must be an aggregate, meaning it has no user-declared constructors, no private nor protected non-static data, no base classes and no virtual functions. The standard includes statements about how PODs must behave in C++.</p>\n</blockquote>\n<p>See <a href=\"http://www.fnal.gov/docs/working-groups/fpcltf/Pkg/ISOcxx/doc/POD.html\" rel=\"nofollow\">this page for many details on POD types</a>. In particular,</p>\n<blockquote>\n<p id=\"so_5927586_5927749_1\">\"A pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member ... and vice versa\" [\u00a79.2, \u00b617].</p>\n</blockquote>\n", "CreationDate": "2011-05-08T13:36:14.350", "Score": "3", "LastEditDate": "2011-05-08T13:42:09.417", "CommentCount": "1", "Id": "5927749", "OwnerUserId": "98117", "LastEditorUserId": "98117", "LastActivityDate": "2011-05-08T13:42:09.417"}, "5927586": {"LastEditDate": "2011-05-08T13:15:47.040", "Body": "<p>It is usually allowed to do something like that (no comments on the code please :-))</p>\n<pre><code>class SimpleClass {\n    int member;\n};\n\nSimpleClass instance;\nint* pointer = (int*) &amp;instance;\n</code></pre>\n<p>However, if I define my class as:</p>\n<pre><code>class SimpleClass {\n    virtual void foo();\n    int member;\n};\n</code></pre>\n<p>I can't do that anymore. Well, I guess I can, of course; it's just more complex.</p>\n<p>So I was wondering: is it somewhere specified, or the only way to know when I can do that is just to use some common sense? Not counting alignment issues, which can usually be solved</p>\n", "CreationDate": "2011-05-08T13:01:15.890", "Score": "2", "AcceptedAnswerId": "5927749", "CommentCount": "0", "OwnerUserId": "743889", "Title": "When can I access an object member directly in memory? No getters called", "LastActivityDate": "2011-05-08T13:42:09.417", "PostTypeId": "1", "Tags": "<c++>", "AnswerCount": "4", "FavoriteCount": "2", "Id": "5927586", "ViewCount": "117", "LastEditorUserId": "743889"}, "5927616": {"PostTypeId": "2", "ParentId": "5927586", "Body": "<p>Generally you want to keep the innards of a class of closed off from the outside world as you can, but if you do need to access a member directly simply specify it as public and take a pointer directly to it.</p>\n<pre><code>class SimpleClass {\npublic:\n  int member;\n};\n\nSimpleClass instance;\nint* pointer = &amp;instance.member;\n</code></pre>\n<p>I would avoid accessing the members in the way you describe because as you noted small changes in the class can mess it up, which may be fine whilst you are writing the code but when you come back to it much later you will probably overlook such subtleties. Also unless the class is constructed entirely of native data types, I believe the compiler's implementation will affect the required offset as well.</p>\n", "CreationDate": "2011-05-08T13:07:57.343", "Score": "4", "CommentCount": "5", "Id": "5927616", "OwnerUserId": "735744", "LastActivityDate": "2011-05-08T13:07:57.343"}, "bq_ids": {"n3337": {"so_5927586_5927749_1": {"quality": 0.9230769230769231, "length": 12, "section_id": 5650}}}, "5927760": {"PostTypeId": "2", "ParentId": "5927586", "Body": "<p>All right, several things.</p>\n<p>Your first code example won't compile because you can't have a pointer to a class. I think you meant this:</p>\n<pre><code>SimpleClass instance;\nint* pointer = (int*) &amp;instance;\n</code></pre>\n<p>(Please don't code you haven't tried compiling.)</p>\n<p>This kind of casting is powerful and dangerous. You could just as well cast to a pointer to some type (say, <code>char*</code>) and as long as it was a type no larger than int, the code would compile and run. This kind of reinterpretation is like a fire axe, to be used only when you have no better choice.</p>\n<p>As it is, <code>pointer</code> points to the beginning of 'instance', and <code>instance</code> begins with <code>instance.member</code> (like every instance of <code>SimpleClass</code>), so you really can manipulate that member with it. As soon as you add another field to <code>SimpleClass</code> before <code>member</code>, you mess up this scheme.</p>\n<p>In your second code example, you <em>can</em> still use pointer to store and retrieve an <code>int</code>, but you're doing so across boundaries within the memory structure of <code>instance</code>, which will damage <code>instance</code> beyond repair. I can't think of a good metaphor for how bad this is.</p>\n<p>In answer to your questions: yes, this is specified somewhere, and no, common sense isn't good enough, you'll need insight into how the language works (which comes from playing around with questions like this).</p>\n", "CreationDate": "2011-05-08T13:39:54.767", "Score": "0", "CommentCount": "0", "Id": "5927760", "OwnerUserId": "128940", "LastActivityDate": "2011-05-08T13:39:54.767"}, "5927663": {"PostTypeId": "2", "ParentId": "5927586", "Body": "<pre><code>class SimpleClass {\n    int member;\n};\n\nSimpleClass instance;\nint* pointer = (int*) &amp;SimpleClass;\n</code></pre>\n<p>In the above code <code>pointer</code> points to <code>SimpleClass::member</code> and hence you can access <code>SimpleClass::member</code> in this way.</p>\n<p>Once you add an <code>virtual</code> method to the class SimpleClass, the memory map of the object changes. </p>\n<pre><code>class SimpleClass {\n    virtual void foo();\n    int member;\n};\n</code></pre>\n<p>Every object of <code>SimpleClass</code> now contains a special pointer called as <code>vptr</code> which points to a <code>vtable</code> which is a table of addresses of all virtual functions in <code>SimpleClass</code>. The first 4 bytes of every object of <code>SimpleClass</code> now point to the <code>vptr</code> and not <code>SimpleClass::member</code> and that is the reason you cannot access <code>member</code> in the same way as first case. </p>\n<p>Ofcourse, virtual behavior is implementation detail of compilers and <code>vptr</code> nor <code>vtable</code> are specified in the standard but the way i mentioned is how most compilers would implement it.</p>\n<p>Since the implementation detail might be different for each compiler you should rely on accessing class members through pointers to class(especially polymorphic classes). Also, doing so defeats the entire purpose of <code>Abstraction</code> through <code>Access Specifiers</code>.</p>\n", "CreationDate": "2011-05-08T13:18:13.217", "Score": "2", "CommentCount": "3", "Id": "5927663", "OwnerUserId": "452307", "LastActivityDate": "2011-05-08T13:18:13.217"}});