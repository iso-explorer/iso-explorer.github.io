post_cb({"29997331": {"ParentId": "29997142", "LastEditDate": "2017-05-23T10:28:05.137", "CommentCount": "23", "CreationDate": "2015-05-02T01:20:06.187", "Score": "10", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "29997331", "OwnerUserId": "420683", "Body": "<p>I'm using a recent github draft based on N4296. The actual C++14 International Standard does not contain this example, nor the numbering of bullet points. The specification relevant here is effectively the same.</p>\n<p>We decompose the expression in the initializer: <code>b ? (1, S::x) : f(S::x)</code></p>\n<p>The expression <code>(1, S::x)</code> is an lvalue of type <code>int const</code>.\nThe expression <code>f(S::x)</code> is a postfix-expression, an lvalue of type <code>int const</code>.</p>\n<p>Hence the expression <code>b ? (1, S::x) : f(S::x)</code> is an lvalue of type <code>int const</code>. It therefore fulfils [basic.def.odr]p2.5, and the set of potential results is the union of the sets of potential results of the sub-expressions <code>(1, S::x)</code> and <code>f(S::x)</code>.</p>\n<p>For the first sub-expression <code>(1, S::x)</code>, we strip the parentheses via p2.4. The result <code>1, S::x</code> is a comma expression. We apply p2.6 and get <code>S::x</code>. Now, p2.1 applies and tells us that this first occurrence is part of the set of potential results of the initializer.</p>\n<p>For the second sub-expression <code>f(S::x)</code>, only p2.7 applies. Its set of potential results is empty, so it doesn't add anything to the set of potential results of the initializer.</p>\n<hr>\n<p>As for the odr-use of <code>S::x</code>, [basic.def.odr]p3</p>\n<blockquote>\n<p id=\"so_29997142_29997331_0\">A variable <code>x</code> whose name appears as a potentially-evaluated expression\n  <code>ex</code> is odr-used by <code>ex</code> unless applying the lvalue-to-rvalue conversion\n  to <code>x</code> yields a constant expression that does not invoke\n  any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of\n  the set of potential results of an expression <code>e</code>, where either the\n  lvalue-to-rvalue conversion is applied to <code>e</code>, or <code>e</code> is a\n  discarded-value expression.</p>\n</blockquote>\n<p>Let's split this into steps: The occurrence of a variable <code>x</code> in an expression <code>ex</code> constitutes an odr-use unless:</p>\n<ol>\n<li><b>Either</b> <code>ex</code> is not potentially evaluated, <b>or</b></li>\n<li><b>All of the following must be fulfilled:</b>\n<ol>\n<li><i>\"applying the lvalue-to-rvalue conversion to <code>x</code> yields a constant expression that does not invoke any non-trivial functions\"</i> <b>and</b></li>\n<li><i>\"<code>ex</code> is an element of the set of potential results of an expression <code>e</code>\"</i> <b>and either of the following holds</b>:\n         <ol>\n<li><i>\"<b>either</b> the lvalue-to-rvalue conversion is applied to <code>e</code>\"</i></li>\n<li><i>\"<b>or</b> <code>e</code> is a discarded-value expression\"</i></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>Note that point 2 means \"is an element of the set of potential results of ANY expression <code>e</code> [where <code>e</code> fulfils certain requirements]\", rather than \"all expressions <code>e</code> it is part of\". Further discussion can be found on the <a href=\"https://groups.google.com/a/isocpp.org/d/topic/std-discussion/rmJL-TzjlVY/discussion\" rel=\"nofollow noreferrer\">std-discussion mailing list</a>.</p>\n<h3>Applying the steps to the second occurrence of `S::x`</h3>\n<p>It is part of the expressions <code>S::x</code>, <code>f(S::x)</code>, <code>b ? (1, S::x) : f(S::x)</code>.</p>\n<ol>\n<li><b>False</b> (since all of these expressions are potentially evaluated), <b>or</b></li>\n<li><b>All of the following must be fulfilled:</b>\n<ol>\n<li><b>True</b> (since applying the l-t-r conversion to <code>S::x</code> yields a constant expression that does not invoke <i>any</i> functions) <b>and</b></li>\n<li>The only expression where the second occurrence of <code>S::x</code> is an element of the set of potential results is <code>S::x</code> itself. It is not part of the potential results of <code>f(S::x)</code>. <b>Either of the following must hold</b>:\n         <ol>\n<li><b>either false</b> (since the lvalue-to-rvalue conversion is not applied when binding <code>S::x</code> to the function parameter of <code>f</code>)</li>\n<li><b>or false</b> (since <code>S::x</code> is not a discarded-value expression)</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>The exception does not apply, <code>S::x</code> is odr-used via its second occurrence.</p>\n<h3>Applying the steps to the first occurrence of `S::x`</h3>\n<p>It is part of the expressions <code>S::x</code>, <code>1, S::x</code>, <code>(1, S::x)</code>, <code>b ? (1, S::x) : f(S::x)</code>.</p>\n<ol>\n<li><b>False</b> (since all of these expressions are potentially evaluated), <b>or</b></li>\n<li><b>All of the following must be fulfilled:</b>\n<ol>\n<li><b>True</b> (since applying the l-t-r conversion to <code>S::x</code> yields a constant expression that does not invoke <i>any</i> functions) <b>and</b></li>\n<li>The first occurrence of <code>S::x</code> is an element of the set of potential results of all the expressions it is part of within the initializer. <b>Either of the following must hold</b>:\n         <ol>\n<li><b>true</b> - The lvalue-to-rvalue conversion is certainly not applied to the expressions <code>S::x</code>, <code>1, S::x</code>, <code>(1, S::x)</code>. It can be argued that it is applied to <code>b ? (1, S::x) : f(S::x)</code> (see below)</li>\n<li><b>or false</b> (none of those expressions are discarded-value expressions)</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>It is unclear whether or not initialization applies the lvalue-to-rvalue conversion. One can argue that the \"value of the lvalue-expression\" must be read in order to initialize the <code>int</code> from an expression of type <code>int const</code>. If we follow this assumption, then the lvalue-to-rvalue conversion is applied to <code>b ? (1, S::x) : f(S::X)</code>. The first occurrence of <code>S::x</code> is an element of the set of potential results of that expression (see the first part of this answer). Hence, Bullet point 3.0 of the above applies, and <code>S::x</code> is <em>not</em> odr-used through the first occurrence.</p>\n<p>You can find a lot of information on lvalue-to-rvalue conversion in initializations in the Q&amp;A <a href=\"https://stackoverflow.com/q/14935722\">Does initialization entail lvalue-to-rvalue conversion? Is <code>int x = x;</code> UB?</a>. The situation might be a bit easier here, since the rhs has type <code>int const</code>. This might require a qualification conversion, which expects a prvalue operand (this probably invokes the lvalue-to-rvalue conversion implicitly).</p>\n</hr>", "LastActivityDate": "2015-05-15T19:29:54.793"}, "29997142": {"CommentCount": "11", "ViewCount": "207", "PostTypeId": "1", "LastEditorUserId": "4470935", "CreationDate": "2015-05-02T00:51:55.900", "LastActivityDate": "2015-05-15T19:29:54.793", "LastEditDate": "2015-05-02T01:12:35.450", "AcceptedAnswerId": "29997331", "FavoriteCount": "1", "Title": "Trying to understand [basic.def.odr]/2 in C++14 (N4140)", "Id": "29997142", "Score": "2", "Body": "<p>The Example in [basic.def.odr]/2 starts with the following sentence:</p>\n<blockquote>\n<p id=\"so_29997142_29997142_0\">In the following example, the set of potential results of the\n  initializer of n contains the first S::x subexpression, but not the\n  second S::x subexpression.</p>\n</blockquote>\n<p>From the definitions in this paragraph, how can we deduce that the initializer of n contains the first S::x subexpression, but not the second S::x subexpression?</p>\n<p><strong>Edit</strong>\nSee below the remaining part of the Example referred above:  </p>\n<pre><code>struct S { static const int x = 0; };\nconst int &amp;f(const int &amp;r);\nint n = b ? (1, S::x) // S::x is not odr-used here\n          : f(S::x); // S::x is odr-used here, so\n                     // a definition is required\n</code></pre>\n", "Tags": "<c++><language-lawyer><c++14>", "OwnerUserId": "4470935", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29997142_29997331_0": {"section_id": 7040, "quality": 0.9666666666666667, "length": 29}, "so_29997142_29997142_0": {"section_id": 7039, "quality": 1.0, "length": 12}}, "n4659": {"so_29997142_29997331_0": {"section_id": 8537, "quality": 0.9666666666666667, "length": 29}, "so_29997142_29997142_0": {"section_id": 8536, "quality": 1.0, "length": 12}}}});