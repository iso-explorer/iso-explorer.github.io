post_cb({"bq_ids": {"n4140": {"so_9191876_9191876_5": {"length": 38, "quality": 0.926829268292683, "section_id": 2239}}, "n3337": {"so_9191876_9191876_5": {"length": 38, "quality": 0.926829268292683, "section_id": 2227}}, "n4659": {"so_9191876_9191876_5": {"length": 37, "quality": 0.9024390243902439, "section_id": 2512}}}, "9297839": {"Id": "9297839", "PostTypeId": "2", "Body": "<p>I think this is a customization point, not really used by the default stream implementations.</p>\n<p><code>in_avail()</code> returns the number of chars it can see in the internal buffer, if any. Otherwise it calls <code>showmanyc()</code> to try to detect if chars are known to be available elsewhere, so a buffer fill request is guaranteed to succeed.</p>\n<p>In turn, <code>showmanyc()</code> will return the number of chars it knows about, if any, or -1 if it <em>knows</em> that a read will fail, or 0 if it doesn't have a clue.</p>\n<p>The default implementation (<code>basic_streambuf</code>) always returns 0, so that is what you get unless you have a stream with some other streambuf overriding <code>showmanyc</code>.</p>\n<p>Your loop is essentially read-as-many-chars-as-you-know-is-safe, and it gets stuck when that is zero (meaning \"not sure\").</p>\n", "LastActivityDate": "2012-02-15T17:06:58.423", "CommentCount": "1", "CreationDate": "2012-02-15T17:06:58.423", "ParentId": "9191876", "Score": "4", "OwnerUserId": "597607"}, "9191876": {"ViewCount": "2029", "Body": "<p>This code loops forever:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n\nint main(int argc, char *argv[])\n{\n    std::ifstream f(argv[1]);\n    std::ostringstream ostr;\n\n    while(f &amp;&amp; !f.eof())\n    {\n        char b[5000];\n        std::size_t read = f.readsome(b, sizeof b);\n        std::cerr &lt;&lt; \"Read: \" &lt;&lt; read &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n        ostr.write(b, read);\n    }\n}\n</code></pre>\n<p>It's because <code>readsome</code> is never setting <code>eofbit</code>.</p>\n<p><a href=\"http://www.cplusplus.com/reference/iostream/istream/readsome/\" rel=\"nofollow noreferrer\">cplusplus.com</a> says:</p>\n<blockquote>\n<p id=\"so_9191876_9191876_0\">Errors are signaled by modifying the internal state flags:</p>\n<p id=\"so_9191876_9191876_1\"><code>eofbit</code>    The get pointer is at the end of the stream buffer's internal input\n  array when the function is called, meaning that there are no positions to be\n  read in the internal buffer (which may or not be the end of the input\n  sequence). This happens when <code>rdbuf()-&gt;in_avail()</code> would return <code>-1</code> before the\n  first character is extracted.</p>\n<p id=\"so_9191876_9191876_2\"><code>failbit</code>    The stream was at the end of the source of characters before the\n  function was called.</p>\n<p id=\"so_9191876_9191876_3\"><code>badbit</code>    An error other than the above happened.</p>\n</blockquote>\n<p>Almost the same, the standard says:</p>\n<blockquote>\n<p id=\"so_9191876_9191876_4\"><code>[C++11: 27.7.2.3]:</code> <code>streamsize readsome(char_type* s, streamsize n);</code></p>\n<p id=\"so_9191876_9191876_5\"><strong>32. Effects:</strong> Behaves as an unformatted input function (as described in\n  27.7.2.3, paragraph 1). After constructing a sentry object, if <code>!good()</code> calls\n  <code>setstate(failbit)</code> which may throw an exception, and return. Otherwise extracts\n  characters and stores them into successive locations of an array whose first\n  element is designated by <code>s</code>. If <code>rdbuf()-&gt;in_avail() == -1</code>, calls\n  <code>setstate(eofbit)</code> (which may throw <code>ios_base::failure</code> (27.5.5.4)), and extracts\n  no characters;</p>\n<ul>\n<li>If <code>rdbuf()-&gt;in_avail() == 0</code>, extracts no characters</li>\n<li>If <code>rdbuf()-&gt;in_avail() &gt; 0</code>, extracts <code>min(rdbuf()-&gt;in_avail(),n))</code>.</li>\n</ul>\n<p id=\"so_9191876_9191876_6\"><strong>33. Returns:</strong> The number of characters extracted.</p>\n</blockquote>\n<p>That the <code>in_avail() == 0</code> condition is a no-op implies that <code>ifstream::readsome</code> itself is a no-op if the stream buffer is empty, but the <code>in_avail() == -1</code> condition implies that it <em>will</em> set <code>eofbit</code> when <em>some other operation</em> has led to <code>in_avail() == -1</code>.</p>\n<p>This seems like an inconsistency, even despite the \"some\" nature of <code>readsome</code>.</p>\n<p>So what <em>are</em> the semantics of <code>readsome</code> and <code>eof</code>? Have I interpreted them correctly? Are they an example of poor design in the streams library?</p>\n<hr>\n<p><sup>(Stolen from the [IMO] invalid <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52169\" rel=\"nofollow noreferrer\">libstdc++ bug 52169</a>.)</sup></p>\n</hr>", "AcceptedAnswerId": "9297839", "Title": "When does `ifstream::readsome` set `eofbit`?", "CreationDate": "2012-02-08T10:52:19.633", "Id": "9191876", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-07-10T13:11:48.320", "LastEditorUserId": "560648", "LastActivityDate": "2017-07-10T13:11:48.320", "Score": "9", "OwnerUserId": "560648", "Tags": "<c++><iostream>", "AnswerCount": "3"}, "9192217": {"Id": "9192217", "PostTypeId": "2", "Body": "<p>If no character is available (i.e. <code>gptr() == egptr()</code> for the <code>std:streambuf</code>) the virtual member function <code>showhowmanyc()</code> is called. I could have an implementation of <code>showmanyc()</code> which returns an error code. Why that may be useful is a different question. However, this could set <code>eof()</code>. Of course, <code>in_avail()</code> is meant not to fail and not to block and just return the characters known to be available. That is, the loop you have above is essentially guaranteed to be an infinite loop unless you have a rather odd stream buffer.</p>\n", "LastActivityDate": "2012-02-08T11:13:18.493", "CommentCount": "1", "CreationDate": "2012-02-08T11:13:18.493", "ParentId": "9191876", "Score": "1", "OwnerUserId": "1120273"}, "9369785": {"Id": "9369785", "PostTypeId": "2", "Body": "<p>I don't think that readsome() is meant for what you're trying to do (read from a file on disk)... from cplusplus.com:</p>\n<blockquote>\n<p id=\"so_9191876_9369785_0\">The function is intended to be used to read binary data from certain\n  types of asynchronic sources that may wait for more characters, since\n  it stops reading when the local buffer exhausts, avoiding potential\n  unexpected delays.</p>\n</blockquote>\n<p>So it sounds like readsome() is intended for streams from a network socket or something like that, and you probably want to just use read().</p>\n", "LastActivityDate": "2012-02-20T23:06:16.587", "CommentCount": "7", "CreationDate": "2012-02-20T23:06:16.587", "ParentId": "9191876", "Score": "0", "OwnerUserId": "1221969"}});