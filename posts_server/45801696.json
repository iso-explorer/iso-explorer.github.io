post_cb({"bq_ids": {"n4140": {"so_45801696_45801696_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 3487}}, "n3337": {"so_45801696_45801696_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 3352}}, "n4659": {"so_45801696_45801696_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4250}}}, "45801893": {"Id": "45801893", "PostTypeId": "2", "Body": "<p>When the line </p>\n<pre><code>using Ftype = typename Functor::type;\n</code></pre>\n<p>is processed in the base class, the definition of <code>Functor</code> is not available. Hence, you can't use <code>Functor::type</code>.</p>\n<p>One way to get around this limitation is to define a traits class.</p>\n<pre><code>// Declare a traits class.\ntemplate &lt;typename T&gt; struct FunctorTraits;\n\ntemplate&lt;class Functor&gt;\nclass FunctorInterface_2 {\n   private:\n      const Functor &amp;f_cref;\n   public:\n\n      // Use the traits class to define Ftype\n      using Ftype = typename FunctorTraits&lt;Functor&gt;::type;\n\n      FunctorInterface_2() : f_cref(static_cast&lt;const Functor&amp;&gt;(*this)) {}\n      Ftype operator() ( Ftype val ) const { return f_cref(val); }\n}; // FunctorInterface_2 (no type in Functor!)\n\n// Forward declare Cube to specialize FunctorTraits\ntemplate&lt;class T&gt; struct Cube;\n\n// Specialize FunctorTraits for Cube\ntemplate &lt;typename T&gt; struct FunctorTraits&lt;Cube&lt;T&gt;&gt;\n{\n   using type = T; \n};\n\ntemplate&lt;class T&gt;\nstruct Cube : public FunctorInterface_2&lt;Cube&lt;T&gt;&gt; {\n   using type = T; \n   T operator() ( T val ) const { return val*val*val; }\n}; // Cube\n</code></pre>\n<p>Working code: <a href=\"https://ideone.com/C1L4YW\" rel=\"nofollow noreferrer\">https://ideone.com/C1L4YW</a></p>\n", "LastActivityDate": "2017-08-21T16:32:45.923", "CommentCount": "4", "CreationDate": "2017-08-21T16:32:45.923", "ParentId": "45801696", "Score": "3", "OwnerUserId": "434551"}, "45801696": {"ViewCount": "109", "Body": "<p>I've been experimenting with the <a href=\"https://en.wikipedia.org/wiki/Curiously_recurring_template_patternhttp://\" rel=\"noreferrer\">Curiously Recurring Template Pattern</a> for a generic single-argument functor and have two implementations: one using a template template parameter which works and a second where I try to access the derived Functor::type in the interface class. In the latter example, the compiler (gcc 5.4.0) reports </p>\n<blockquote>\n<p id=\"so_45801696_45801696_0\"><strong>error</strong>: no type named '<strong>type</strong>' in 'struct Cube&lt; double &gt;'</p>\n</blockquote>\n<pre><code>template&lt;class T, template&lt;class&gt; class Functor&gt;\nclass FunctorInterface_1 {\nprivate:\n  const Functor&lt;T&gt; &amp;f_cref;\npublic:\n  FunctorInterface_1() : f_cref(static_cast&lt;const Functor&lt;T&gt;&amp;&gt;(*this)) {}\n  T operator() ( T val ) const { return f_cref(val); }\n}; // FunctorInterface_1 (works)\n\ntemplate&lt;class Functor&gt;\nclass FunctorInterface_2 {\nprivate:\n  const Functor &amp;f_cref;\npublic:\n  using Ftype = typename Functor::type;\n  FunctorInterface_2() : f_cref(static_cast&lt;const Functor&amp;&gt;(*this)) {}\n  Ftype operator() ( Ftype val ) const { return f_cref(val); }\n}; // FunctorInterface_2 (no type in Functor!)\n</code></pre>\n<p>I then try to compile with T=double in main() of the following two classes:</p>\n<pre><code>template&lt;class T&gt; \nstruct Square : public FunctorInterface_1&lt;T,Square&gt; {\n  T operator()( T val ) const { return val*val; }\n}; // Square\n\n\ntemplate&lt;class T&gt;\nstruct Cube : public FunctorInterface_2&lt;Cube&lt;T&gt;&gt; {\n  using type = T; \n  T operator() ( T val ) const { return val*val*val; }\n}; // Cube\n</code></pre>\n<p>Can the FunctorInterface_2/Cube example be modified to work, or \nis it necessary for the interface class to be templated on T as \nin the first example? Thanks!</p>\n<p>EDIT: Using gcc -std=c++14, I can get the second example to compile and run\nby using auto return and argument types in FunctorInterface_1::operator(), however, as I understand, auto argument types are not part of the C++14 standard. </p>\n<p>EDIT 2: Well I feel a bit thick. I just realized that I could template FunctorInterface_1::operator() on a new parameter, however, for the application I have in mind, I would really like my base class to be able to access types defined in the derived class. </p>\n", "AcceptedAnswerId": "45801893", "Title": "No type named 'type' in CTRP derived class", "CreationDate": "2017-08-21T16:18:37.623", "Id": "45801696", "CommentCount": "0", "LastEditDate": "2017-08-21T16:25:18.100", "PostTypeId": "1", "LastEditorUserId": "2308288", "LastActivityDate": "2017-08-21T16:44:24.207", "Score": "7", "OwnerUserId": "2308288", "Tags": "<c++><templates><non-virtual-interface>", "AnswerCount": "3"}, "45802014": {"Id": "45802014", "PostTypeId": "2", "Body": "<p>You have to understand that when you instantiate <code>Cube&lt;T&gt;</code> <code>FunctionInterface_2&lt;Cube&lt;T&gt;&gt;</code> gets instantiated first. This means that <code>Cube&lt;T&gt;</code> is an incomplete type while this is happening.<br>\nSo when the compiler gets to the line using <code>Ftype = typename Functor::type;</code> <code>Functor</code> is incomplete and you cannot access any of its nested types.</br></p>\n<p>In your case you can change <code>FunctionInterface_2</code> to:</p>\n<pre><code>template&lt;class Functor&gt;\nclass FunctorInterface_2 {\nprivate:\n    const Functor &amp;f_cref;\npublic:\n    FunctorInterface_2() : f_cref(static_cast&lt;const Functor&amp;&gt;(*this)) {}\n    template &lt;class TT&gt;\n    auto operator() ( TT &amp;&amp; val ) -&gt; decltype(f_cref(val)) const { return f_cref(val); }\n};\n</code></pre>\n<p>So now accessing information about <code>Functor</code> is delayed until you call the <code>operator()</code> from <code>FunctionInterface_2</code> at which point <code>FunctionInterface_2</code> and <code>Cube</code> are fully instantiated.</p>\n", "LastActivityDate": "2017-08-21T16:40:00.907", "CommentCount": "0", "CreationDate": "2017-08-21T16:40:00.907", "ParentId": "45801696", "Score": "1", "OwnerUserId": "1277769"}, "45801889": {"Id": "45801889", "PostTypeId": "2", "Body": "<p>Your code could be simplified to </p>\n<pre><code>template&lt;typename TDerived&gt; class\nBase\n{\n    using Ftype = typename TDerived::type;\n};\n\ntemplate&lt;typename T&gt; class\nDerived: public Base&lt;Derived&lt;T&gt;&gt;\n{\n    using type = T;\n};\n\nDerived&lt;int&gt; wat;\n</code></pre>\n<p>It does not work because at the point of <code>Base</code> instantiation <code>Derived</code> class is not complete, and compiler is not aware of <code>Derived::type</code> existence yet.</p>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2017-08-21T16:44:24.207", "Score": "2", "CreationDate": "2017-08-21T16:32:26.117", "ParentId": "45801696", "CommentCount": "0", "OwnerUserId": "7860670", "LastEditDate": "2017-08-21T16:44:24.207"}});