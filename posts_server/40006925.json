post_cb({"40007311": {"ParentId": "40006925", "LastEditDate": "2016-10-12T20:05:24.130", "CommentCount": "3", "CreationDate": "2016-10-12T19:59:52.713", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "40007311", "Score": "4", "Body": "<p>I think this is a clang bug. </p>\n<p>We start with [over.match.ctor]:</p>\n<blockquote>\n<p id=\"so_40006925_40007311_0\">When objects of class type are direct-initialized (8.6), copy-initialized from an expression of the same or a\n  derived class type (8.6), or default-initialized (8.6), overload resolution selects the constructor. For direct-initialization\n  or default-initialization that is not in the context of copy-initialization, the candidate functions\n  are all the constructors of the class of the object being initialized.</p>\n</blockquote>\n<p>So we consider, for instance, the copy constructor. Is the copy constructor viable? </p>\n<p>From [dcl.init.ref]:</p>\n<blockquote>\n<p id=\"so_40006925_40007311_1\">\u2014 If the initializer expression [...] has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be\n  converted to an rvalue of type \u201ccv3 T3\u201d, where \u201ccv1 T1\u201d is reference-compatible with \u201ccv3\n  T3\u201d (see 13.3.1.6) then the reference is bound to the value of the initializer expression in the first case and to\n  the result of the conversion in the second case.</p>\n</blockquote>\n<p>Those candidate functions in [over.match.ref] are:</p>\n<blockquote>\n<p id=\"so_40006925_40007311_2\">For direct-initialization, those explicit conversion functions that\n  are not hidden within S and yield type \u201clvalue reference to cv2 T2\u201d or \u201ccv2 T2\u201d or \u201crvalue reference to\n  cv2 T2\u201d, respectively, where T2 is the same type as T or can be converted to type T with a qualification\n  conversion (4.5), are also candidate functions.</p>\n</blockquote>\n<p>Which includes our <code>operator const Y()</code>. Hence the copy constructor <em>is</em> viable. The move constructor is not (since you can't bind a non-<code>const</code> rvalue reference to a <code>const</code> rvalue), so we have exactly one viable candidate, which makes the program well-formed. </p>\n<hr/>\n<p>Er, as a followup, this is <a href=\"https://llvm.org/bugs/show_bug.cgi?id=16682\" rel=\"nofollow\">LLVM bug 16682</a>, which makes it seem much more complicated than what I've initially laid out. </p>\n", "LastActivityDate": "2016-10-12T20:05:24.130"}, "40006925": {"CommentCount": "2", "ViewCount": "171", "LastActivityDate": "2016-10-13T09:24:32.040", "Body": "<p>The latest version of clang (3.9) rejects this code on the second line of <code>f</code>; the latest version of gcc (6.2) accepts it:</p>\n<pre><code>struct Y {\n    Y();\n    Y(const Y&amp;);\n    Y(Y&amp;&amp;);\n};\n\nstruct X {\n    operator const Y();\n};\n\nvoid f() {\n    X x;\n    Y y(x);\n}\n</code></pre>\n<p>If any of these changes are made, clang will then accept the code:</p>\n<ul>\n<li>Remove <code>Y</code>'s move constructor</li>\n<li>Remove <code>const</code> from the conversion operator</li>\n<li>Replace <code>Y y(x)</code> with <code>Y y = x</code></li>\n</ul>\n<p>Is the original example legal? Which compiler is wrong? After checking the sections about conversion functions and overload resolution in the standard I have not been able to find a clear answer.</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "40010380", "FavoriteCount": "2", "Title": "Clang and GCC disagree on legality of direct initialization with conversion operator", "Id": "40006925", "Score": "12", "CreationDate": "2016-10-12T19:34:48.440", "Tags": "<c++><initialization><type-conversion><language-lawyer><conversion-operator>", "OwnerUserId": "839932", "AnswerCount": "3"}, "40015888": {"ParentId": "40006925", "CommentCount": "2", "Body": "<p>When you write code where two decent compilers disagree whether it is legal or not, you are programming too close to the edge. Let's say I'm a maintenance programmer supporting that code. How do you expect me to know whether this is legal, and what exactly the semantics of this code are, if even gcc and clang cannot agree? </p>\n<p>Change your code. Make it simpler so that both less \"clever\" programmers and compilers understand it without problems. There are no prizes for being the most \"clever\" programmer around. </p>\n<p>Look at Columbo's answer: I have no doubt that his analysis of the situation is perfectly fine and correct. But I wouldn't want to support code that requires a very clever 50 line analysis to demonstrate that it is correct. If you are writing C++ compilers, you should carefully study his answer. If you are writing application code, you should never write code that requires looking at his answer. </p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "40015888", "Score": "-1", "CreationDate": "2016-10-13T08:26:42.803", "LastActivityDate": "2016-10-13T08:26:42.803"}, "40010380": {"ParentId": "40006925", "LastEditDate": "2016-10-13T09:24:32.040", "CommentCount": "3", "CreationDate": "2016-10-13T00:21:38.173", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "40010380", "Score": "4", "Body": "<p>When we're enumerating the constructors and check their viability - i.e. whether there is an implicit conversion sequence - for the move constructor, <a href=\"http://eel.is/c++draft/dcl.init.ref#5\" rel=\"nofollow\">[dcl.init.ref]/5</a> falls through to the last bullet point (5.2.2), which was modified by core issues <a href=\"http://wg21.link/cwg1604\" rel=\"nofollow\">1604</a> and <a href=\"http://wg21.link/cwg1571\" rel=\"nofollow\">1571</a> (in that order).</p>\n<p>The bottom line of these resolutions is that</p>\n<blockquote>\n<p id=\"so_40006925_40010380_0\">If <code>T1</code> or <code>T2</code> is a class type and <code>T1</code> is not reference-related to <code>T2</code>, user-defined conversions are\n  considered using the rules for copy-initialization of an object of type \u201c<em>cv1</em> <code>T1</code>\u201d by user-defined conversion (8.6, 13.3.1.4, 13.3.1.5); the program is ill-formed if the corresponding non-reference copy-initialization would be ill-formed. <strong>The result of the call to the conversion function, as described for the non-reference copy-initialization, is then used to direct-initialize the reference.</strong></p>\n</blockquote>\n<p>The first part just causes the conversion operator to be selected. So, according to the boldfaced part, we use <code>const Y</code> to direct-initialize <code>Y&amp;&amp;</code>. Again, we fall through until the last bullet point, which fails due to (5.2.2.3): </p>\n<blockquote>\n<p id=\"so_40006925_40010380_1\">If <code>T1</code> is reference-related to <code>T2</code>:<br> \u2014 <em>cv1</em> shall be the same\n  cv-qualification as, or greater cv-qualification than, <em>cv2</em> ; and</br></p>\n</blockquote>\n<p>However, this does not appertain to our original overload resolution anymore, which only sees that the conversion operator shall be used to direct-initialize the reference. In your example, overload resolution selects the move constructor because <a href=\"http://eel.is/c++draft/over.ics.rank#3\" rel=\"nofollow\">[over.ics.rank]/(3.2.5)</a>, and then the above paragraph makes the program ill-formed. This is a defect and has been filed as <a href=\"http://wg21.link/cwg2077\" rel=\"nofollow\">core issue 2077</a>. A sensible solution would discard the move constructor during overload resolution.</p>\n<p>All this makes sense wrt to your fixes: removing <code>const</code> would prevent the fall-through since the types are now reference-compatible, and removing the move constructor leaves the copy constructor, which has a const reference (i.e. works as well). Finally, when we write <code>Y y = x;</code>, instead of [dcl.init]/(17.6.2), (17.6.3) applies;</p>\n<blockquote>\n<p id=\"so_40006925_40010380_2\">Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). [...]. <strong>The call is used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization.</strong></p>\n</blockquote>\n<p>I.e. the initialization is effectively the same as <code>Y y(x.operator const Y());</code>, which succeeds, because the move constructor is not viable (<code>Y&amp;&amp; y = const Y</code> fails shallowly enough) and the copy constructor is selected.</p>\n", "LastActivityDate": "2016-10-13T09:24:32.040"}, "bq_ids": {"n4140": {"so_40006925_40010380_0": {"section_id": 3321, "quality": 0.875, "length": 28}, "so_40006925_40010380_1": {"section_id": 3320, "quality": 0.75, "length": 6}, "so_40006925_40007311_1": {"section_id": 3321, "quality": 0.8709677419354839, "length": 27}, "so_40006925_40007311_2": {"section_id": 597, "quality": 0.8620689655172413, "length": 25}, "so_40006925_40007311_0": {"section_id": 592, "quality": 0.8275862068965517, "length": 24}, "so_40006925_40010380_2": {"section_id": 3296, "quality": 0.9210526315789473, "length": 35}}, "n3337": {"so_40006925_40007311_1": {"section_id": 3191, "quality": 0.8387096774193549, "length": 26}, "so_40006925_40010380_1": {"section_id": 3190, "quality": 0.75, "length": 6}, "so_40006925_40007311_0": {"section_id": 582, "quality": 0.8275862068965517, "length": 24}, "so_40006925_40010380_2": {"section_id": 3166, "quality": 0.9210526315789473, "length": 35}, "so_40006925_40007311_2": {"section_id": 585, "quality": 0.5862068965517241, "length": 17}}, "n4659": {"so_40006925_40010380_0": {"section_id": 4087, "quality": 0.875, "length": 28}, "so_40006925_40007311_2": {"section_id": 620, "quality": 0.8620689655172413, "length": 25}, "so_40006925_40007311_1": {"section_id": 4087, "quality": 0.8064516129032258, "length": 25}, "so_40006925_40010380_1": {"section_id": 4086, "quality": 0.75, "length": 6}, "so_40006925_40007311_0": {"section_id": 615, "quality": 0.9655172413793104, "length": 28}, "so_40006925_40010380_2": {"section_id": 4058, "quality": 0.9210526315789473, "length": 35}}}});