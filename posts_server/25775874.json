post_cb({"25888855": {"ParentId": "25775874", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The discrepancy between the compilers is caused by the definition of <code>void_t</code>:\n<a href=\"https://stackoverflow.com/questions/25833356/is-there-a-compiler-bug-exposed-by-my-implementation-of-an-is-complete-type-trai/25833474#25833474\">Is there a compiler bug exposed by my implementation of an is_complete type trait?</a> \nIn short, the standard was unclear whether unused arguments in alias template specializations could result in substitution failure or are simply ignored. The resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1558\" rel=\"nofollow noreferrer\">CWG issue 1558</a> clarifies that the shorter definition of <code>void_t</code> in the question should work. </p>\n<p>With that issue worked around using </p>\n<pre><code>template&lt;typename... Ts&gt;\nstruct make_void { typedef void type;};\n\ntemplate&lt;typename... Ts&gt;\nusing void_t = typename make_void&lt;Ts...&gt;::type;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/85471986c42f1629\" rel=\"nofollow noreferrer\">both compilers produce <code>10</code></a>.</p>\n<p>\u00a714.6.4.2 [temp.dep.candidate]:</p>\n<blockquote>\n<p id=\"so_25775874_25888855_0\">For a function call that depends on a template parameter, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2, 3.4.3) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only function declarations from the\n  template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context\n  or the template instantiation context are found.</li>\n</ul>\n<p id=\"so_25775874_25888855_1\">If the function name is an <em>unqualified-id</em> and the call would be\n  ill-formed or would find a better match had the lookup within the\n  associated namespaces considered all the function declarations with\n  external linkage introduced in those namespaces in all translation\n  units, not just considering those declarations found in the template\n  definition and template instantiation contexts, then the program has\n  undefined behavior.</p>\n</blockquote>\n<p>Unqualified lookup for <code>Serialize</code> is performed in template definition context and will not find <code>Serialize(int &amp;)</code>, and there's no ADL for an argument of type <code>int&amp;</code>, so <code>10</code> is the correct output.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:21:40.517", "Id": "25888855", "Score": "4", "CreationDate": "2014-09-17T11:03:02.340", "LastActivityDate": "2015-01-22T02:18:38.493"}, "25775874": {"CommentCount": "5", "AcceptedAnswerId": "25888855", "PostTypeId": "1", "LastEditorUserId": "336578", "CreationDate": "2014-09-10T22:07:43.273", "LastActivityDate": "2015-01-22T02:18:38.493", "LastEditDate": "2014-09-10T22:44:41.560", "ViewCount": "484", "FavoriteCount": "1", "Title": "Checking if non-member function that accepts T param exists", "Id": "25775874", "Score": "14", "Body": "<p>I want to check if a non-member function that accepts a T parameter type exists. To do so I used <code>void_t</code> \"trick\" presented by Mr. Walter E. Brown at cppcon(same trick works without any problems to check if a member type or member function exists). </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename...&gt;\nusing void_t = void;\n\nvoid Serialize(float&amp;)\n{\n}\n\ntemplate&lt;typename T, typename = void&gt;\nstruct has_external_serialize : std::false_type\n{\n};\n\ntemplate&lt;typename T&gt;\nstruct has_external_serialize&lt;T, void_t&lt;decltype(Serialize(std::declval&lt;T&amp;&gt;()))&gt;&gt; : std::true_type\n{\n};\n\nvoid Serialize(int&amp;)\n{\n}\n\nint main(int argc, const char * argv[])\n{\n    std::cout&lt;&lt;has_external_serialize&lt;float&gt;::value&lt;&lt;has_external_serialize&lt;int&gt;::value;\n}\n</code></pre>\n<p>This code prints <code>11</code> when compiled using GCC and <code>10</code> when compiled with clang(xcode 5.1.1). </p>\n<p>My questions is - is this code correct? If yes, is there a bug in clang or a bug in GCC or the code is in some \"implementation defined\" area and I can't assume it will have same behaviour on all platforms? </p>\n", "Tags": "<c++><c++11><sfinae>", "OwnerUserId": "336578", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25775874_25888855_0": {"section_id": 224, "quality": 0.5882352941176471, "length": 10}, "so_25775874_25888855_1": {"section_id": 224, "quality": 0.9487179487179487, "length": 37}}, "n3337": {"so_25775874_25888855_0": {"section_id": 217, "quality": 0.7647058823529411, "length": 13}, "so_25775874_25888855_1": {"section_id": 217, "quality": 1.0, "length": 39}}, "n4659": {"so_25775874_25888855_0": {"section_id": 232, "quality": 0.5882352941176471, "length": 10}, "so_25775874_25888855_1": {"section_id": 232, "quality": 0.9487179487179487, "length": 37}}}});