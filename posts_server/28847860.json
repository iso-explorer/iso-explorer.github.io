post_cb({"28848091": {"Id": "28848091", "PostTypeId": "2", "Body": "<ul>\n<li><p>your allocation may not have the alignment needed by <code>VARIABLE_SIZE_STRUCT</code></p></li>\n<li><p>the allocated memory has not had an object of VARIABLE_SIZE_STRUCT placement-<code>new</code>ed in it - assuming you take care of that, the <code>unique_ptr</code>'s default destructor logic should find the expected object instance to destruct, but the deallocation itself would then not be done with <code>delete []</code> on a <code>BYTE*</code> - to have defined behaviour you'd have to customise the deleter to invoke first <code>~VARIABLE_SIZE_STRUCT()</code> then <code>delete[]</code>...</p></li>\n</ul>\n<p>If you're concerned about \"thunking\", you could do a check at run-time:</p>\n<pre><code>BYTE* p;\nv.reset(reinterpret_cast&lt;VARIABLE_SIZE_STRUCT*&gt;(p = new BYTE[bytesRequired]));\nassert(reinterpret_cast&lt;BYTE*&gt;(v.get()) == p);\n</code></pre>\n<p>The background on that - 5.2.10/7:</p>\n<blockquote>\n<p id=\"so_28847860_28848091_0\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of object pointer type is converted to the object pointer type \u201cpointer to cv T\u201d, the result is <code>static_cast&lt;cvT*&gt;(static_cast&lt;cv void*&gt;(v))</code>. Converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than\n  those of T1) and back to its original type yields the original pointer value.</p>\n</blockquote>\n<p>So, if the alignment requirements for <code>VARIABLE_SIZE_STRUCT</code> are stricter than for <code>BYTE</code>, you're not <em>guaranteed</em> to retrieve the original pointer using <code>reinterpret_cast&lt;BYTE*&gt;</code>.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2015-03-04T07:15:31.840", "Score": "5", "CreationDate": "2015-03-04T06:41:34.470", "ParentId": "28847860", "CommentCount": "4", "OwnerUserId": "410767", "LastEditDate": "2015-03-04T07:15:31.840"}, "bq_ids": {"n4140": {"so_28847860_28848091_0": {"length": 44, "quality": 0.9777777777777777, "section_id": 6046}}, "n3337": {"so_28847860_28848091_0": {"length": 40, "quality": 0.8888888888888888, "section_id": 5814}}, "n4659": {"so_28847860_28848091_0": {"length": 43, "quality": 0.9555555555555556, "section_id": 7545}}}, "28847860": {"ViewCount": "1138", "Body": "<p>When using various API's that have variable size structures (structures that must be allocated as byte[] and then cast into the struct), it would be nice if the unique_ptr holder could point to the structure, since that's what we'll be using.</p>\n<p>Example:</p>\n<pre><code>std::unique_ptr&lt;VARIABLE_SIZE_STRUCT[]&gt; v; \nv.reset(reinterpret_cast&lt;VARIABLE_SIZE_STRUCT*&gt;(new BYTE[bytesRequired]));\n</code></pre>\n<p>This allowed `v to provide the view to the structure itself, which is preferable because that we don't need a second variable and we don't care about the byte pointer except for deletion.</p>\n<p>The problem comes in with the possibility of thunking the pointer on the cast (making it unsafe to free). I see no reasonable reason why the compiler would change the pointer value on cast (since there's no inheritance), but I hear that the standard reserves the right to thunk any pointer on any cast, so as far as standard-compliant coding goes, this approach is out the window, right? Or is there some reason it is safe? Is there a way to at least static_assert this, or some other way to make it safe or cleanly deal with this type of structure?</p>\n", "AcceptedAnswerId": "28848091", "Title": "Is it never truly safe to reinterpret_cast input into std::unique_ptr?", "CreationDate": "2015-03-04T06:22:23.227", "Id": "28847860", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-03-04T19:21:10.560", "LastEditorUserId": "981367", "LastActivityDate": "2015-03-04T19:21:10.560", "Score": "11", "OwnerUserId": "981367", "Tags": "<c++><pointers><c++11><unique-ptr><reinterpret-cast>", "AnswerCount": "2"}, "28848068": {"Id": "28848068", "PostTypeId": "2", "Body": "<p>You're correct, this is unsafe. It is possible to make it safe, however.</p>\n<p>The standard guarantees that if you <code>reinterpret_cast</code> to a different type, then back to the original type, you get back the original value.</p>\n<p>You can use this along with a custom deleter, to ensure your internal pointer is cast back to the type it was allocated as before releasing it.</p>\n<pre><code>auto deleter = [](VARIABLE_SIZE_STRUCT* ptr) \n{ \n    delete[] reinterpret_cast&lt;uint8_t*&gt;(ptr); \n}; \n\nstd::unique_ptr&lt;VARIABLE_SIZE_STRUCT, decltype(deleter)&gt; v\n    (reinterpret_cast&lt;VARIABLE_SIZE_STRUCT*&gt;(new uint8_t[256]), deleter);\n</code></pre>\n<p>At this point, you're probably better off creating your own wrapper and not using <code>unique_ptr</code>.</p>\n", "LastActivityDate": "2015-03-04T06:39:35.013", "CommentCount": "3", "CreationDate": "2015-03-04T06:39:35.013", "ParentId": "28847860", "Score": "5", "OwnerUserId": "214796"}});