post_cb({"25976267": {"CommentCount": "0", "AcceptedAnswerId": "25976453", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-09-22T14:14:54.130", "LastActivityDate": "2015-01-30T14:32:00.300", "LastEditDate": "2014-09-23T21:17:19.000", "ViewCount": "1127", "FavoriteCount": "7", "Title": "Interesting behavior of compiler with namespaces", "Id": "25976267", "Score": "31", "Body": "<p>Assume the following code:  </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace X\n{\n  class A{};\n\n  void f(A a){}\n\n  void g(int a){}\n}\n\nint main()\n{\n  X::A a;\n  f(a);\n  g(5);\n}\n</code></pre>\n<p>When I compile the code, the following compile error occurs:</p>\n<blockquote>\n<p id=\"so_25976267_25976267_0\">main.cpp: In function 'int main()':<br>\n  main.cpp: error: 'g' was not declared in this scope</br></p>\n</blockquote>\n<p>So the function <code>f</code> is compiled perfectly, but <code>g</code> isn't. How? Both of them belong to the same namespace. Does the compiler deduce that function <code>f</code> belongs to the <code>X</code> namespace from the argument of type <code>X::A</code>? How does compiler behave in such cases?</p>\n", "Tags": "<c++><compiler-errors><namespaces><argument-dependent-lookup>", "OwnerUserId": "1856429", "AnswerCount": "3"}, "25976453": {"ParentId": "25976267", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This works for the function call expression:</p>\n<pre><code>f(a);\n</code></pre>\n<p>because the namespace that <code>X::A</code> belongs to is included in the lookup for the function <code>f</code> due to <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow\">argument dependent lookup(<em>ADL</em>)</a>, cppreference explains <em>ADL</em> as follows:</p>\n<blockquote>\n<p id=\"so_25976267_25976453_0\">Argument-dependent lookup, also known as ADL, or Koenig lookup, is the\n  set of rules for looking up the unqualified function names in\n  function-call expressions, including implicit function calls to\n  overloaded operators. These function names are looked up in the\n  namespaces of their arguments in addition to the scopes and namespaces\n  considered by the usual unqualified name lookup.</p>\n<p id=\"so_25976267_25976453_1\">Argument-dependent lookup makes it possible to use operators defined\n  in a different namespace</p>\n</blockquote>\n<p>This is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>3.4.2</code> <em>Argument-dependent name lookup</em>:</p>\n<blockquote>\n<p id=\"so_25976267_25976453_2\">When the postfix-expression in a <strong>function call (5.2.2) is an unqualified-id, other namespaces not considered\n  during the usual unqualified lookup (3.4.1) may be searched,</strong> and in those namespaces, namespace-scope\n  friend function or function template declarations (11.3) not otherwise visible may be found</p>\n</blockquote>\n<p>and goes on to say:</p>\n<blockquote>\n<p id=\"so_25976267_25976453_3\">For each <strong>argument type T in the function call, there is a set of zero or more associated namespaces</strong> and a\n  set of zero or more associated classes to be considered. The sets of namespaces and classes is determined\n  entirely by the types of the function arguments (and the namespace of any template template argument).</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<p id=\"so_25976267_25976453_4\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a\n  member, if any; and its direct and indirect base classes. <strong>Its associated namespaces are the namespaces\n  of which its associated classes are members</strong>.[...]</p>\n</blockquote>\n<p>and further down provides a similar example to your problem:</p>\n<pre><code>namespace NS {\n  class T { };\n  void f(T);\n  void g(T, int);\n}\n\nNS::T parm;\nvoid g(NS::T, float);\n\nint main() {\n  f(parm); // OK: calls NS::f\n  extern void g(NS::T, float);\n  g(parm, 1); // OK: calls g(NS::T, float)\n}\n</code></pre>\n<p>The function call expression:</p>\n<pre><code>g(5);\n</code></pre>\n<p>does not work because <em>ADL</em> does not add any namespaces for arguments that are fundamental types.</p>\n<p>Herb Sutter covers ADL in <a href=\"http://www.gotw.ca/gotw/030.htm\" rel=\"nofollow\">Gotw #30</a> and in <a href=\"http://www.gotw.ca/publications/mill02.htm\" rel=\"nofollow\">What's In a Class? - The Interface Principle</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-01-30T14:32:00.300", "Id": "25976453", "Score": "18", "CreationDate": "2014-09-22T14:24:16.953", "LastActivityDate": "2015-01-30T14:32:00.300"}, "25976320": {"ParentId": "25976267", "CommentCount": "1", "Body": "<pre><code>X::A a;\nf(a);\n</code></pre>\n<p>works because of <strong>Argument-Dependent Lookup</strong> (Also known as Koenig Lookup). <code>a</code> is an object of class <code>A</code> inside namespace <code>X</code>, when compiler searches a match-able function <code>f</code>, it will look into namespace <code>X</code> in this case.  See <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"noreferrer\">Argument Dependent Lookup</a> for more information.</p>\n", "OwnerUserId": "1760345", "PostTypeId": "2", "Id": "25976320", "Score": "27", "CreationDate": "2014-09-22T14:17:50.667", "LastActivityDate": "2014-09-22T14:17:50.667"}, "bq_ids": {"n4140": {"so_25976267_25976453_2": {"section_id": 7103, "quality": 0.8928571428571429, "length": 25}, "so_25976267_25976453_4": {"section_id": 7104, "quality": 1.0, "length": 24}, "so_25976267_25976453_3": {"section_id": 7104, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_25976267_25976453_2": {"section_id": 6847, "quality": 0.8214285714285714, "length": 23}, "so_25976267_25976453_4": {"section_id": 6848, "quality": 1.0, "length": 24}, "so_25976267_25976453_3": {"section_id": 6848, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_25976267_25976453_2": {"section_id": 8604, "quality": 0.8928571428571429, "length": 25}, "so_25976267_25976453_4": {"section_id": 8605, "quality": 1.0, "length": 24}, "so_25976267_25976453_3": {"section_id": 8605, "quality": 0.8, "length": 24}}}, "25976293": {"ParentId": "25976267", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>When the code <code>f(a)</code>, the compiler finds the function <code>void f(A a){}</code> in the <code>namespace X</code> because of the <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow\">ADL</a> (argument dependent lookup, also known as <a href=\"http://www.drdobbs.com/cpp/a-personal-note-about-argument-dependent/232901443\" rel=\"nofollow\">Koenig</a> lookup).</p>\n<p><code>A</code> is declared in the namespace <code>X</code>, hence when the compiler needs to look up the definition of <code>f</code>, it includes possibilities from that namespace because the object <code>a</code> of type <code>A</code> is in that namespace (as declared <code>X::A a;</code>).</p>\n<p>On the other hand, <code>int</code> is not declared in the <code>namespace X</code>, so the <code>namespace X</code> is not included in the lookup. Since no corresponding function for <code>f</code> is found, it fails to compile.</p>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2014-09-23T05:32:43.483", "Id": "25976293", "Score": "6", "CreationDate": "2014-09-22T14:16:24.720", "LastActivityDate": "2014-09-23T05:32:43.483"}});