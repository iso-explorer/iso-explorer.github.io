post_cb({"28408758": {"PostTypeId": "2", "Body": "<p>This is undefined behavior, which means anything could happen, including segfault, or what you have experienced, or anything else. Basically, you were just lucky it didn't crash (or unlucky, based on the point of view).</p>\n<p>The language does not require iterator accesses to be checked, as that would require a run-time check. C++ usually tries to avoid unnecessary run-time overhead, leaving the programmer to perform whatever checks are necessary.</p>\n<p>Most modern platforms use paged virtual memory, providing memory protection with a granularity of a few kilobytes. This means that there is often accessible memory after an allocated block (such as the one managed by std::vector), in which case out-of-range accesses will simply stomp on that memory.</p>\n<p>Visual Studio is trying to aid in removing dangerous code. In principle a pointer could point anywhere if you didn't dereference it, but iterators are a higher level abstraction and have the ability to detect whether dereference would be valid and thus raise runtime errors. Visual Studio has done this with <code>vector&lt;T&gt;::iterator</code> at least since VS 2007.</p>\n", "LastActivityDate": "2015-02-09T11:47:26.753", "LastEditorUserId": "3095460", "Id": "28408758", "CommentCount": "4", "CreationDate": "2015-02-09T11:32:20.993", "ParentId": "28408649", "Score": "2", "OwnerUserId": "3095460", "LastEditDate": "2015-02-09T11:47:26.753"}, "bq_ids": {"n4140": {"so_28408649_28408967_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}}, "n3337": {"so_28408649_28408967_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}}}, "28408967": {"PostTypeId": "2", "Body": "<p>It's undefined behavior.  Both with iterators and with pointers.  With\niterators, you'll probable get an assertion failure, at least with\niterator debugging turned on.  With pointers, it will probably do\nnothing in most modern architectures, but there have been machines on\nwhich it could trigger at trap.  You don't have to access the memory\nlocation itself, just create the pointer, for undefined behavior to\noccur.</p>\n<p>EDIT:</p>\n<p>From the standard (\u00a75.7/5, emphesis added):</p>\n<blockquote>\n<p id=\"so_28408649_28408967_0\">When an expression that has integral type is added to or subtracted from\n  a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integral expression. In\n  other words, if the expression P points to the i-th element of an array\n  object, the expressions (P)+N (equivalently, N+(P)) and (P)-N (where N\n  has the value n) point to, respectively, the i + n-th and i \u2212 n-th\n  elements of the array object, provided they exist. Moreover, if the\n  expression P points to the last element of an array object, the\n  expression (P)+1 points one past the last element of the array object,\n  and if the expression Q points one past the last element of an array\n  object, the expression (Q)-1 points to the last element of the array\n  object. If both the pointer operand and the result point to elements of\n  the same array object, or one past the last element of the array object,\n  the evaluation shall not produce an overflow; otherwise, <em>the behavior\n  is undefined</em>.</p>\n</blockquote>\n<p>The corresponding rule for random access iterators (the only ones which\nsupport addition) is spread-out over several sections: the <code>+=</code> operator\nis defined in terms of repeated <code>++</code> (for the semantics\u2014it is\nrequired to have constant time complexity), and <code>++</code> has the requirement\nthat \u201cpre: r is dereferenceable. post: r is dereferenceable or r\nis past-the-end.\u201d (from the definition of input iterators, which\nis inherited by forward iterators, which is inherited by bidirectional\niterators, which is inherited by random access iterators).</p>\n", "LastActivityDate": "2015-02-09T12:02:39.393", "LastEditorUserId": "649665", "Id": "28408967", "CommentCount": "0", "CreationDate": "2015-02-09T11:43:07.273", "ParentId": "28408649", "Score": "3", "OwnerUserId": "649665", "LastEditDate": "2015-02-09T12:02:39.393"}, "28408649": {"ViewCount": "652", "Body": "<p>Is it illegal to increment random access iterator out of range?\nIt turns out that Visual C++ implementation of vector triggers debug assertion.</p>\n<pre><code>std::vector&lt;int&gt; foo(5);\nauto iter = foo.begin();\niter += 10;\n</code></pre>\n<p>This should be legal with pointers as long as memory location is not assessed.</p>\n<p>Edit: apparently it is illegal even with pointers.</p>\n", "Title": "Incrementing iterator out of range", "CreationDate": "2015-02-09T11:26:54.323", "LastActivityDate": "2015-02-27T17:11:04.497", "CommentCount": "7", "LastEditDate": "2015-02-27T17:11:04.497", "PostTypeId": "1", "LastEditorUserId": "3237841", "Id": "28408649", "Score": "5", "OwnerUserId": "3237841", "Tags": "<c++>", "AnswerCount": "2"}});