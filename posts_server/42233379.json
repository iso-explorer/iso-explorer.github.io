post_cb({"42233761": {"ParentId": "42233379", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>One of the behaviours of <code>volatile</code> for plain old data type like <code>int *</code> is to prevent the compiler from optimizing away the reading and writing to the variable. Please notice that <code>int *</code> here could be whatever like <code>float</code> or <code>int</code>.</p>\n<p>So <code>(void)x</code> is meaning \"read x and do nothing with the result\" because <code>x</code> is <code>volatile</code>. If you read <code>x</code> and it's not pinned to a fixed position in memory (which the compiler might not know, only the linker does), then you're actually using it <em>uninitialized</em>.</p>\n<p>If it's not volatile, although the compiler might read <code>x</code> anyway, it will likely avoid/optimize this (since it's a no-op), and silent the warning.</p>\n<p>clang takes the safe road here, and since the linker directive could pin the variable x to some position (without clang knowing about it), consider that it's not worth triggering a warning without more evidence it's an issue.</p>\n", "OwnerUserId": "1469714", "LastEditorUserId": "1469714", "LastEditDate": "2017-02-14T18:42:30.787", "Id": "42233761", "Score": "4", "CreationDate": "2017-02-14T18:36:11.830", "LastActivityDate": "2017-02-14T18:42:30.787"}, "42233379": {"CommentCount": "17", "ViewCount": "194", "PostTypeId": "1", "LastEditorUserId": "2752075", "CreationDate": "2017-02-14T18:13:40.207", "LastActivityDate": "2017-02-18T15:42:27.540", "Title": "Why GCC warns when casting an uninitialized volatile pointer to `void`?", "AcceptedAnswerId": "42317212", "LastEditDate": "2017-02-14T18:23:37.817", "Id": "42233379", "Score": "3", "Body": "<p>Consider following:</p>\n<pre><code>int *volatile x;\n(void)x;\n</code></pre>\n<p>GCC (from 5.x to 7.x) complains about it when <code>-Wall</code> is enabled:</p>\n<blockquote>\n<p id=\"so_42233379_42233379_0\">warning: 'x' is used uninitialized in this function [-Wuninitialized]</p>\n</blockquote>\n<p>The clang is silent about it.</p>\n<p>For some reason, removing the <code>volatile</code> eliminates the warning.</p>\n<p>Does the standard say that casting a <code>volatile</code> pointer even to <code>void</code> is undefined, while casting a normal pointer is fine? Or is that a GCC bug?</p>\n<hr>\n<p><strong>Disclaimer:</strong> The question is tagged as C/C++ on purpose. The GCC gives the same warning for both languages, and I'm interested of there is any difference.</p>\n</hr>", "Tags": "<c++><c><gcc><warnings><language-lawyer>", "OwnerUserId": "2752075", "AnswerCount": "5"}, "42317212": {"ParentId": "42233379", "CommentCount": "6", "Body": "<p>For C++, this is controlled by <a href=\"https://timsong-cpp.github.io/cppwp/expr#12\" rel=\"nofollow noreferrer\">[expr]/12</a>, which says that <code>(void) x</code> applies the lvalue-to-rvalue conversion to <code>x</code> (i.e., reads the value of <code>x</code>) only if <code>x</code> is a glvalue of volatile-qualified type. Therefore, if <code>x</code> is volatile-qualified, then <code>(void) x</code> reads its value (which yields an indeterminate value and triggers undefined behavior). If <code>x</code> isn't volatile-qualified, then  <code>(void) x</code> doesn't apply the lvalue-to-rvalue conversion and the behavior is well-defined.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "42317212", "Score": "1", "CreationDate": "2017-02-18T15:42:27.540", "LastActivityDate": "2017-02-18T15:42:27.540"}, "42233848": {"ParentId": "42233379", "CommentCount": "1", "Body": "<p>If the variable is declared <code>volatile</code> then to cast away the <code>volatile</code>, just as it is undefined behaviour to cast away the const from a variable declared const. See <code>Annex J.2</code> of the <code>C Standard</code>:</p>\n<blockquote>\n<p id=\"so_42233379_42233848_0\">The behavior is undefined in the following circumstances:</p>\n<p id=\"so_42233379_42233848_1\">\u2014 An attempt is made to refer to an object defined with a volatile-qualified type through\n  use of an lvalue with non-volatile-qualified type (6.7.3).</p>\n</blockquote>\n<p>Somewhere I have read and noted down about rules of using <code>volatile</code> are:</p>\n<ul>\n<li><p>Use volatile for variables that might change \"unexpectedly\".</p></li>\n<li><p>Use volatile for automatic variables in routines that use setjmp().</p></li>\n<li><p>To force volatile semantics on a particular access, take the address of the variable and cast it to (volatile WHATEVER *), dereferencing the cast expression to get the value.</p></li>\n<li><p>Sometimes volatile is a reasonable way to get around problems with code generation in compilers that have conformance problems in some areas, eg, the gcc compiler on x86 with semantics of assigning or casting to double. Don't do this just haphazardly, since if it's unnecessary code quality will very likely go down.</p></li>\n<li><p>Unless you really know what you're doing and why you're doing it, if you're using volatile you're likely doing something wrong. Try to find another way to solve the problem, and if you still have to use volatile code\nup a nice small example and post to comp.lang.c and ask for helpful suggestions.</p></li>\n</ul>\n", "OwnerUserId": "743290", "PostTypeId": "2", "Id": "42233848", "Score": "2", "CreationDate": "2017-02-14T18:41:29.930", "LastActivityDate": "2017-02-14T18:41:29.930"}, "42234118": {"ParentId": "42233379", "CommentCount": "1", "Body": "<p>If the misaligned pointer is dereferenced, the program may terminate abnormally. On some architectures, the cast alone may cause a loss of information even if the value is not dereferenced if the types involved have differing alignment requirements.</p>\n<p>The C Standard, 6.3.2.3, paragraph 7 say's:</p>\n<blockquote>\n<p id=\"so_42233379_42234118_0\">A pointer to an object or incomplete type may be converted to a\n  pointer to a different object or incomplete type. If the resulting\n  pointer is not correctly aligned for the referenced type, the behavior\n  is undefined.</p>\n</blockquote>\n", "OwnerUserId": "6935629", "PostTypeId": "2", "Id": "42234118", "Score": "1", "CreationDate": "2017-02-14T18:57:18.013", "LastActivityDate": "2017-02-14T18:57:18.013"}, "42234277": {"ParentId": "42233379", "CommentCount": "2", "Body": "<p>Any access to a volatile object is part of your program's <em>observable behavior</em> in both C and C++. <em>Observable behavior</em> is an important concept in both C and C++.</p>\n<p>Your code formally reads a volatile pointer <code>x</code>. I would guess that GCC considers it a rather serious issue when part of program observable behavior involves an uninitialized value.</p>\n<p>The moment you remove <code>volatile</code>, reading of <code>x</code> ceases to be a part of observable behavior. Hence the warning disappears as well.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "42234277", "Score": "2", "CreationDate": "2017-02-14T19:06:19.490", "LastActivityDate": "2017-02-14T19:06:19.490"}, "bq_ids": {"n4140": {"so_42233379_42233848_1": {"section_id": 5435, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_42233379_42233848_1": {"section_id": 5230, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_42233379_42233848_1": {"section_id": 6862, "quality": 0.6153846153846154, "length": 8}}}});