post_cb({"27483231": {"ParentId": "27481905", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>When <code>WORKS=0</code>, the program can be made to compile in Clang by qualifying the call to <code>fFooBar</code> with <code>::</code>. The standard requires that name lookup behaves differently when an unqualified name is used in a function call.</p>\n<blockquote>\n<p id=\"so_27481905_27483231_0\">[basic.lookup.argdep]/1</p>\n<p id=\"so_27481905_27483231_1\">When the postfix-expression in a function call (5.2.2) is an unqualified-id, other namespaces not considered\n  during the usual unqualified lookup (3.4.1) may be searched, and in those namespaces, namespace-scope\n  friend function declarations (11.3) not otherwise visible may be found.</p>\n</blockquote>\n<p>Examining the (somewhat complex) rules for the Argument Dependent Lookup process suggests that it can only be implemented correctly in a way that would require the instantiation of template specialisations in the types of the arguments to the call.</p>\n<blockquote>\n<p id=\"so_27481905_27483231_2\">[basic.lookup.argdep]/2</p>\n<p id=\"so_27481905_27483231_3\">For each argument type T in the function call, there is a set of zero or more associated namespaces and a\n  set of zero or more associated classes to be considered. The sets of namespaces and classes is determined\n  entirely by the types of the function arguments [...]</p>\n<ul>\n<li>If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a\n  member, if any; and its direct and indirect base classes.</li>\n</ul>\n</blockquote>\n<p>One interpretation of this is that a class is required to be complete if it is used in the type of an argument to an unqualified function call. An alternative interpretation is that ADL should only cause instantiation of templates that are complete.</p>\n<p>Either behaviour is compliant with the standard according to Working Draft N3337</p>\n<blockquote>\n<p id=\"so_27481905_27483231_4\">[temp.inst]/6</p>\n<p id=\"so_27481905_27483231_5\">If the overload resolution process can determine the correct function to call without instantiating a class\n  template definition, it is unspecified whether that instantiation actually takes place.</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; struct S {\n    operator int();\n};\n\nvoid f(int);\nvoid f(S&lt;int&gt;&amp;);\nvoid f(S&lt;float&gt;);\nvoid g(S&lt;int&gt;&amp; sr) {\n    f(sr); // instantiation of S&lt;int&gt; allowed but not required\n           // instantiation of S&lt;float&gt; allowed but not required\n};\n</code></pre>\n<blockquote>\n<p id=\"so_27481905_27483231_6\">[temp.inst]/7</p>\n<p id=\"so_27481905_27483231_7\">If an implicit instantiation of a class template specialization is required and the template is declared but not\n  defined, the program is ill-formed.</p>\n</blockquote>\n", "OwnerUserId": "1690864", "LastEditorUserId": "1690864", "LastEditDate": "2014-12-15T12:05:29.713", "Id": "27483231", "Score": "5", "CreationDate": "2014-12-15T11:40:49.770", "LastActivityDate": "2014-12-15T12:05:29.713"}, "bq_ids": {"n4140": {"so_27481905_27483231_5": {"section_id": 239, "quality": 1.0, "length": 18}, "so_27481905_27483231_3": {"section_id": 7104, "quality": 0.9230769230769231, "length": 24}, "so_27481905_27483231_1": {"section_id": 7103, "quality": 0.8846153846153846, "length": 23}, "so_27481905_27483231_7": {"section_id": 240, "quality": 1.0, "length": 11}}, "n3337": {"so_27481905_27483231_3": {"section_id": 6848, "quality": 0.9230769230769231, "length": 24}, "so_27481905_27483231_5": {"section_id": 231, "quality": 1.0, "length": 18}, "so_27481905_27483231_1": {"section_id": 6847, "quality": 0.8846153846153846, "length": 23}, "so_27481905_27483231_7": {"section_id": 232, "quality": 1.0, "length": 11}}, "n4659": {"so_27481905_27483231_5": {"section_id": 248, "quality": 0.7222222222222222, "length": 13}, "so_27481905_27483231_3": {"section_id": 8605, "quality": 0.7692307692307693, "length": 20}, "so_27481905_27483231_1": {"section_id": 8604, "quality": 0.8846153846153846, "length": 23}, "so_27481905_27483231_7": {"section_id": 242, "quality": 0.7272727272727273, "length": 8}}}, "27481905": {"CommentCount": "5", "AcceptedAnswerId": "27483231", "CreationDate": "2014-12-15T10:24:10.207", "LastActivityDate": "2014-12-15T12:05:29.713", "PostTypeId": "1", "ViewCount": "206", "FavoriteCount": "1", "Title": "Why does the following code cause the template instantiation?", "Id": "27481905", "Score": "11", "Body": "<p>I have the following C++ code:</p>\n<pre><code>//Define to 1 to make it work\n#define WORKS 0\n\n#if WORKS\n    template&lt; typename T &gt; struct Foo;\n#else\n    template&lt; typename T &gt;\n    struct Foo {\n        T t;\n    };\n#endif\n\nclass Bar;  //Incomplete type\n\nvoid fFooBar(Foo&lt;Bar&gt; const &amp; foobar) { }\n\nvoid f(Foo&lt;Bar&gt; const &amp; foobar) {\n    fFooBar(foobar);\n}\n\nint main() {\n    return 0;\n}\n</code></pre>\n<p>If WORKS is defined as 0 (the struct template is defined) the code doesn't compile, because it tries to instantiate it at <code>fFooBar(foobar);</code> and fails, because <code>Bar</code> is incomplete.</p>\n<p>If WORKS is defined as 1 (the struct template is undefined) the code compiles.</p>\n<p>According to the standard, a template should not be instatiated, unless a complete type is required (which is not the case for <code>const&amp;</code>) or it would alter the semantics of the code (which again isn't the case, and againt, the same should happen if the template was undefined).</p>\n<p>Also, it's weird that the program can be made to compile by removing information from the compilation unit. But the fact that <em>MSVC, gcc, and clang all do the same</em> makes me think there must be a reason behind this.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "2653222", "AnswerCount": "1"}});