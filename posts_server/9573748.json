post_cb({"bq_ids": {"n4140": {"so_9573748_9573748_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 3228}}, "n3337": {"so_9573748_9573748_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 3101}}, "n4659": {"so_9573748_9573748_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 3985}}}, "9573802": {"Id": "9573802", "PostTypeId": "2", "Body": "<p>The struct hack was never standard. This should be a standard viable replacement:</p>\n<pre><code>struct MyStruct {\n    uint size;\n    int32 buf[1];\n};\n</code></pre>\n", "LastActivityDate": "2012-03-05T20:51:48.010", "CommentCount": "22", "CreationDate": "2012-03-05T20:51:48.010", "ParentId": "9573748", "Score": "1", "OwnerUserId": "476681"}, "9573807": {"Id": "9573807", "PostTypeId": "2", "Body": "<p>No, <a href=\"https://stackoverflow.com/questions/3711233/is-the-struct-hack-technically-undefined-behavior/\">you cannot do it compliantly</a> *.</p>\n<p>Use a <code>std::vector</code>.</p>\n<p><sup>* I'm assuming that C++ doesn't add any rules that contradict C in this area. IMO it's <em>highly unlikely</em>, though I don't have time to verify that at the minute.</sup></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-05T20:58:06.180", "Score": "6", "CreationDate": "2012-03-05T20:52:01.550", "ParentId": "9573748", "CommentCount": "7", "OwnerUserId": "560648", "LastEditDate": "2017-05-23T12:04:02.513"}, "9573748": {"ViewCount": "2227", "Body": "<blockquote>\n<p id=\"so_9573748_9573748_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/3711233/is-the-struct-hack-technically-undefined-behavior\">Is the \u201cstruct hack\u201d technically undefined behavior?</a> </br></p>\n</blockquote>\n<p>I checked if zero length arrays were allowed in C++11. It appeared they aren't. From <code>8.3.4 Arrays [dcl.array]</code></p>\n<blockquote>\n<p id=\"so_9573748_9573748_1\">If the constant-expression (5.19) is present, it shall be an integral constant expression and its value shall be greater than zero.</p>\n</blockquote>\n<p>Since i cant use zero length arrays Is it possible to use variable length structs while being standard/Well Defined? For example I'd want to do something like the below. How do I make it well defined and standard when the buffer MAY BE EMPTY.</p>\n<p>-edit- related: <a href=\"https://stackoverflow.com/questions/295027/array-of-zero-length\">Array of zero length</a></p>\n<pre><code>struct MyStruct {\n    uint size;\n    int32 buf[0];//&lt;-- NonStandard!\n};\n...\nauto len=GetLength();\nauto ptr=GetPtr();\nauto bytelen=len*sizeof(int32);\nvar p = reinterpret_cast&lt;MyStruct*&gt;(malloc(bytelen))\np-&gt;size=len\nmemcpy(p-&gt;buf, ptr, bytelen)\nreturn p;\n</code></pre>\n", "Title": "Variable length Struct NonStandard in C++11?", "CreationDate": "2012-03-05T20:47:36.017", "LastActivityDate": "2012-03-06T14:07:16.523", "CommentCount": "2", "LastEditDate": "2017-05-23T10:28:21.150", "PostTypeId": "1", "OwnerDisplayName": "user34537", "LastEditorUserId": "-1", "Id": "9573748", "ClosedDate": "2012-03-08T07:59:20.150", "Score": "4", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "9574147": {"Id": "9574147", "PostTypeId": "2", "Body": "<p>This is C++, not C. You don't need this flexible array member hack in C++, because you can easily make a template class which can endow any struct with a flexible array past the end and encapsulate the pointer arithmetic calculation and the memory allocation to make it work. Watch:</p>\n<pre><code>#include &lt;cstring&gt;\n\ntemplate &lt;typename STRUCT, typename TYPE&gt; class flex_struct {\npublic:\n  TYPE *tail()\n  {\n    return (TYPE *) ((char *) this + padded_size());\n  }\n\n  // substitute malloc/free here for new[]/delete[] if you want\n  void *operator new(size_t size, size_t tail)\n  {\n    size_t total = padded_size() + sizeof (TYPE) * tail;\n    return new char[total];\n  }\n\n  void operator delete(void *mem)\n  {\n    delete [] (char *) mem;\n  }\nprivate:\n  static size_t padded_size() {\n    size_t padded = sizeof (flex_struct&lt;STRUCT, TYPE&gt;);\n    if(padded % alignof(TYPE) != 0) {\n         padded = padded &amp; ~(alignof(TYPE)-1) + alignof(TYPE);\n    }\n    return padded;\n  }\n};\n\nstruct mystruct : public flex_struct&lt;mystruct, char&gt; {\n  int regular_member;\n};\n\nint main()\n{\n  mystruct *s = new (100) mystruct; // mystruct with 100 chars extra\n  char *ptr = s-&gt;tail();            // get pointer to those 100 chars\n  memset(ptr, 0, 100);              // fill them\n  delete s;                         // blow off struct and 100 chars\n}\n</code></pre>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-03-06T14:07:16.523", "Score": "6", "CreationDate": "2012-03-05T21:19:35.093", "ParentId": "9573748", "CommentCount": "13", "OwnerUserId": "1250772", "LastEditDate": "2012-03-06T14:07:16.523"}});