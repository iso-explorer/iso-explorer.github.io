post_cb({"22453111": {"CommentCount": "7", "AcceptedAnswerId": "22461577", "CreationDate": "2014-03-17T11:27:11.843", "LastActivityDate": "2014-03-17T17:46:53.597", "PostTypeId": "1", "ViewCount": "552", "FavoriteCount": "1", "Title": "Forward-declare a member enumeration of a class template", "Id": "22453111", "Score": "8", "Body": "<p>With C++11's strongly typed <code>enum</code>s, it is possible to declare a member enumeration of a class like so:\n</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class X {\npublic:\n    enum class E;\n};\n\nenum class X::E { a, b };\n</code></pre>\n<p>However, when making <code>X</code> a class template:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template &lt;typename T&gt;\nclass X {\npublic:\n    enum class E;\n};\n\ntemplate &lt;typename T&gt;\nenum class X&lt;T&gt;::E { a, b };\n</code></pre>\n<p>gcc 4.7.2 and clang 3.0 both complain with \"error: \u2018enum X::E\u2019 is an enumeration template [-pedantic]\" and \"error: enumeration cannot be a template\", respectively. The section of the standard I think is relevant (and which, in fact, this question originated from) is \u00a714 Templates, the first paragraph of which states:</p>\n<blockquote>\n<p id=\"so_22453111_22453111_0\">The <em>declaration</em> in a <em>template-declaration</em> shall</p>\n<ul>\n<li>declare or define a function or a class, or</li>\n<li><strong>define</strong> a member function, a member class, <strong>a member enumeration</strong>, or a static data member <strong>of a class template</strong> or of a class nested within a class template, or</li>\n<li>define a member template of a class or class template, or</li>\n<li>be an <em>alias-declaration</em>.</li>\n</ul>\n</blockquote>\n<p>(emphasis mine). So is this a compiler bug, or am I mis-interpreting the statement entirely?</p>\n", "Tags": "<c++><templates><c++11><enums><forward-declaration>", "OwnerUserId": "2039839", "AnswerCount": "1"}, "22461577": {"ParentId": "22453111", "CommentCount": "1", "Body": "<p>I have been asked for creating this answer. See paragraph [temp.mem.enum] 14.5.1.4/1 of the C++ standard:</p>\n<blockquote>\n<p id=\"so_22453111_22461577_0\">An enumeration member of a class template may be defined outside the\n  class template definition. [ <em>Example:</em></p>\n<pre><code>template&lt;class T&gt; struct A {\n  enum E : T;\n};\nA&lt;int&gt; a;\ntemplate&lt;class T&gt; enum A&lt;T&gt;::E : T { e1, e2 };\nA&lt;int&gt;::E e = A&lt;int&gt;::e1;\n</code></pre>\n<p id=\"so_22453111_22461577_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>Newer version of <em>clang</em> (3.4) <a href=\"http://rextester.com/UIZ27560\" rel=\"nofollow\">compiles your code successfully</a> with flag <code>-pedantic-errors</code> whereas <em>gcc</em> 4.8.1 <a href=\"http://rextester.com/BATQ56315\" rel=\"nofollow\">still considers it is an error</a>. I think it is a <em>gcc</em> bug.</p>\n", "OwnerUserId": "3043539", "PostTypeId": "2", "Id": "22461577", "Score": "3", "CreationDate": "2014-03-17T17:46:53.597", "LastActivityDate": "2014-03-17T17:46:53.597"}, "bq_ids": {"n4140": {"so_22453111_22461577_0": {"section_id": 109, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_22453111_22461577_0": {"section_id": 104, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_22453111_22461577_0": {"section_id": 113, "quality": 0.9090909090909091, "length": 10}}}});