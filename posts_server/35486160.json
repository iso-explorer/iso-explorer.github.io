post_cb({"bq_ids": {"n4140": {"so_35486160_35486160_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 143}, "so_35486160_35486160_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 142}, "so_35486160_35486160_1": {"length": 7, "quality": 1.0, "section_id": 340}}, "n3337": {"so_35486160_35486160_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 137}, "so_35486160_35486160_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 137}, "so_35486160_35486160_1": {"length": 7, "quality": 1.0, "section_id": 330}}, "n4659": {"so_35486160_35486160_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 147}, "so_35486160_35486160_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 146}, "so_35486160_35486160_1": {"length": 7, "quality": 1.0, "section_id": 349}}}, "35486160": {"ViewCount": "46", "Body": "<p>My GCC 4.9.1 does not give an error about this:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename _Tp, typename... _Args&gt;\n  struct IsCble { };\n\ntemplate&lt;typename _Tp&gt;\n  struct IsCble&lt;_Tp&gt; { static constexpr int value {4}; };\n\nint main()\n{\n    std::cout &lt;&lt; IsCble&lt;int&gt;::value &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The same with GCC 5.1. But they should according to:</p>\n<p><strong>[temp.class.spec] 14.5.5\\8.4</strong></p>\n<blockquote>\n<p id=\"so_35486160_35486160_0\">\u2014 The specialization shall be more specialized than the primary\n  template.</p>\n</blockquote>\n<p>I think, in the code above the partial specialization <strong>is not</strong> more specialized than the primary template, because of:</p>\n<p><strong>[temp.deduct.type] 14.8.2.5\\9.1</strong></p>\n<blockquote>\n<p id=\"so_35486160_35486160_1\">\u2014 if P does not contain a template argument corresponding to\n  A<sub>i</sub> then A<sub>i</sub> is ignored;</p>\n</blockquote>\n<p>So it seems, they ignore 14.5.5\\8.4 and resolve the ambiguity by:</p>\n<p><strong>[temp.class.spec.match] 14.5.5.1\\1</strong></p>\n<blockquote>\n<p id=\"so_35486160_35486160_2\">This is done by matching the template arguments of the class template\n  specialization with the template argument lists <strong>of the partial\n  specializations</strong>.</p>\n</blockquote>\n<p>Is it a conforming implementation (1.4\\8)?</p>\n", "AcceptedAnswerId": "35486511", "Title": "Is there a GCC 4.9.1 (5.1) bug in the restrictions for the argument list of a class template partial specialization?", "CreationDate": "2016-02-18T15:52:16.613", "Id": "35486160", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-02-18T16:06:58.087", "Score": "1", "OwnerUserId": "5181494", "Tags": "<c++><gcc><language-lawyer>", "AnswerCount": "1"}, "35486511": {"Id": "35486511", "PostTypeId": "2", "Body": "<p>An omitted parameter is supposed to be more specialised than an empty parameter pack. The same question in a different context is the subject of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1395\" rel=\"nofollow\">an open issue</a>:</p>\n<blockquote>\n<p id=\"so_35486160_35486511_0\">CWG agreed that the example should be accepted, handling this case as a late tiebreaker, preferring an omitted parameter over a parameter pack.</p>\n</blockquote>\n<p>So you're right based on the current text of the standard, but there's little point in compilers being adjusted to follow the current rules when those rules are expected to change.</p>\n", "LastActivityDate": "2016-02-18T16:06:58.087", "CommentCount": "1", "CreationDate": "2016-02-18T16:06:58.087", "ParentId": "35486160", "Score": "1", "OwnerUserId": "743382"}});