post_cb({"9888102": {"CommentCount": "2", "ViewCount": "334", "PostTypeId": "1", "LastEditorUserId": "181783", "CreationDate": "2012-03-27T10:47:35.640", "LastActivityDate": "2012-03-27T11:01:25.337", "Title": "reinterpret_cast and virtual between unrelated types", "AcceptedAnswerId": "9888184", "LastEditDate": "2012-03-27T11:01:25.337", "Id": "9888102", "Score": "1", "Body": "<p>Would someone kindly explain why the following bit of code works, I've tested it on Visual Studio .NET 2008, g++ on Cygwin and <a href=\"http://ideone.com/GbXoc\" rel=\"nofollow\">ideone.com</a>. More important I'd like to know if its valid. Note that <code>A</code> and <code>B</code> are unrelated types.</p>\n<p>Edit: following @leftaroundabout's comment I made the following change to my code</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nclass A\n{\npublic:\n    virtual void Bar()\n    {\n        std::cout &lt;&lt; \"A::Bar() -&gt; \" &lt;&lt; this &lt;&lt; std::endl;\n    }\n\n    virtual void Foo()\n    {\n        std::cout &lt;&lt; \"A::Foo() -&gt; \" &lt;&lt; this &lt;&lt; std::endl;\n    }   \n};\n\nclass B\n{\npublic:\n    virtual void Foo()\n    {\n        std::cout &lt;&lt; \"B::Foo() -&gt; \" &lt;&lt; this &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    B* b = reinterpret_cast&lt;B*&gt;( new A );\n    b-&gt;Foo();   \n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>The program outputs the message:</p>\n<pre><code>A::Bar() -&gt; 0x9806008\n</code></pre>\n<p>Basically the first virtual method is called regardless of what it is called.</p>\n", "Tags": "<c++><virtual><reinterpret-cast>", "OwnerUserId": "181783", "AnswerCount": "4"}, "9888173": {"ParentId": "9888102", "CommentCount": "3", "CreationDate": "2012-03-27T10:52:57.193", "OwnerUserId": "477878", "PostTypeId": "2", "Id": "9888173", "Score": "1", "Body": "<p><code>reinterpret_cast&lt;&gt;</code> basically turns off any type safety checks and tells the compiler \"don't check this, I know what I'm doing.\"</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/e0w9f63b(v=vs.80).aspx\" rel=\"nofollow\">Microsoft's page on reinterpret_cast</a> tells it as well as anyone;</p>\n<blockquote>\n<p id=\"so_9888102_9888173_0\">The result of a reinterpret_cast cannot safely be used for anything\n  other than being cast back to its original type. Other uses are, at\n  best, nonportable.</p>\n</blockquote>\n", "LastActivityDate": "2012-03-27T10:52:57.193"}, "9888201": {"ParentId": "9888102", "CommentCount": "0", "CreationDate": "2012-03-27T10:54:53.057", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "9888201", "Score": "0", "Body": "<p>It is not valid; dereferencing a pointer that's been cast to the wrong type gives undefined behaviour.</p>\n<p>In this case, it appears to work because both objects have matching virtual functions, and the compiler happens to lay out the virtual dispatch metadata in the same way for each object. While it's likely that most compilers will do that, it's not specified and cannot be relied on.</p>\n", "LastActivityDate": "2012-03-27T10:54:53.057"}, "9888184": {"ParentId": "9888102", "CommentCount": "0", "CreationDate": "2012-03-27T10:53:48.383", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "9888184", "Score": "3", "Body": "<p>It only woks by luck, nothing in the standard says it should work - the cast is invalid. The compiler is likely to lay out both classes exactly the same way in memory, but there is no such obligation AFAIK.</p>\n<p>Try adding:</p>\n<pre><code>virtual void Bar()\n{\n    std::cout &lt;&lt; \"A::Bar() -&gt; \" &lt;&lt; this &lt;&lt; std::endl;\n}\n</code></pre>\n<p>before <code>Foo</code> in <code>A</code> and see what happens - chances are <code>Bar</code> will be called when <code>b-&gt;Foo()</code> is run.</p>\n", "LastActivityDate": "2012-03-27T10:53:48.383"}, "9888219": {"ParentId": "9888102", "CommentCount": "0", "CreationDate": "2012-03-27T10:56:19.750", "OwnerUserId": "125672", "PostTypeId": "2", "Id": "9888219", "Score": "0", "Body": "<p>From the standard 5.2.10/7</p>\n<blockquote>\n<p id=\"so_9888102_9888219_0\">A pointer to an object can be explicitly converted to a pointer to an\n  object of different type.65) Except that converting an rvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and back to its original type yields the\n  original pointer value, the result of such a pointer conversion is\n  unspecified.</p>\n</blockquote>\n<p>What this means is that the only thing that's guaranteed is that if you cast A to B and then back to A you get the original pointer back:</p>\n<pre><code>  A* a = reinterpret_cast&lt;A*&gt;(reinterpret_cast&lt;B*&gt;( new A ));\n  a-&gt;Foo();  //Ok\n</code></pre>\n<p>All other uses are unspecified.</p>\n", "LastActivityDate": "2012-03-27T10:56:19.750"}, "bq_ids": {"n4140": {"so_9888102_9888219_0": {"section_id": 6045, "quality": 0.7105263157894737, "length": 27}}, "n3337": {"so_9888102_9888219_0": {"section_id": 5814, "quality": 0.8421052631578947, "length": 32}}, "n4659": {"so_9888102_9888219_0": {"section_id": 7544, "quality": 0.7105263157894737, "length": 27}}}});