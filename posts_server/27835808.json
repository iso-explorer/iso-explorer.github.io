post_cb({"27835808": {"CommentCount": "26", "ViewCount": "5526", "PostTypeId": "1", "LastEditorUserId": "717732", "CreationDate": "2015-01-08T08:29:17.120", "LastActivityDate": "2015-01-17T20:48:02.243", "Title": "Is ++x %= 10 well-defined in C++?", "FavoriteCount": "7", "LastEditDate": "2015-01-08T15:45:24.740", "Id": "27835808", "Score": "56", "Body": "<p>While browsing the code of some project I came across the following statement:</p>\n<pre><code>++x %= 10;\n</code></pre>\n<p>Is this statement well defined in C++ or does it fall into the same category as</p>\n<pre><code>a[i] = i++\n</code></pre>\n<p>?</p>\n", "Tags": "<c++><language-lawyer><undefined-behavior><evaluation>", "OwnerUserId": "70514", "AnswerCount": "7"}, "27836620": {"ParentId": "27835808", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Well, it is <em>defined</em>.  As undefined behavior:</p>\n<blockquote>\n<p id=\"so_27835808_27836620_0\">\u00a71.9/15:<br>\n  If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</br></p>\n</blockquote>\n<p>There are two unsequenced side-effects here.</p>\n<p>Given the expression <code>++x %= 10;</code> moving from left-to-right, we have:</p>\n<ol>\n<li>a <em>value computation</em> <code>(x+1)</code></li>\n<li><em>modifying an object</em> ( <code>=</code>, as in <code>x = x + 1</code>), e.g. a <em>side effect</em> per \u00a71.9/12</li>\n<li>an <em>indeterminately sequenced</em> operation (<code>%=</code>) that itself has both a value computation ('<code>%</code>') and an object-modification <em>side-effect</em> ('<code>=</code>') (<em>ibid from 1,2</em>) on the <em>same scalar object</em> ('<code>x</code>').</li>\n</ol>\n<p>The two sub-expressions in the full-expression are unsequenced <em>relative to each other</em>.  Although we started by reading it from left to right, these are <em>indeterminately sequenced</em>, so there is explicitly no partial-ordering bailout from \u00a71.9/13:</p>\n<blockquote>\n<p id=\"so_27835808_27836620_1\">Given any two evaluations <em>A</em> and <em>B</em>, if <em>A</em> is sequenced before <em>B</em>, then the execution of <em>A</em> shall precede the execution of <em>B</em>. If <em>A</em> is not sequenced before <em>B</em> and <em>B</em> is not sequenced before <em>A</em>, then <em>A</em> and <em>B</em> are <em>unsequenced</em>.</p>\n</blockquote>\n<p>So, UDB.</p>\n", "OwnerUserId": "4257674", "LastEditorUserId": "4257674", "LastEditDate": "2015-01-08T10:58:17.783", "Id": "27836620", "Score": "4", "CreationDate": "2015-01-08T09:20:14.597", "LastActivityDate": "2015-01-08T10:58:17.783"}, "27848818": {"ParentId": "27835808", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>In the expression  </p>\n<pre><code>++x %= 10;  \n</code></pre>\n<p>the most confusing part is that <code>x</code> is modifying twice between two sequence points, once by prefix <code>++</code> and once by assignment of result. This makes an impression that the above expression invokes undefined behavior as once we learned in old C++ that  </p>\n<blockquote>\n<p id=\"so_27835808_27848818_0\">Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.  </p>\n</blockquote>\n<p>In C++11, the rule is different (it is about <em>sequencing</em> instead of <em>sequence points</em>!):    </p>\n<blockquote>\n<p id=\"so_27835808_27848818_1\">If a side effect on a scalar object is <strong>unsequenced</strong> relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>As we already know that <code>++x</code> is the above expression will be evaluated only once (and will give a lvalue), because</p>\n<h3>C++11: 5.17</h3>\n<blockquote>\n<p id=\"so_27835808_27848818_2\">The behavior of an expression of the form <code>E1 op = E2</code> is equivalent to <code>E1 = E1 op E2</code> <strong>except that <code>E1</code> is evaluated only once</strong>.  </p>\n</blockquote>\n<p>and also know that evaluation of operands <code>++x</code> and <code>10</code> will take place before computation of result of <code>%=</code> operator as by standard:</p>\n<blockquote>\n<p id=\"so_27835808_27848818_3\">The value computations of the operands of an operator are sequenced before the value computation of the result of the operator.  </p>\n</blockquote>\n<p><strong>Conclusion:</strong> </p>\n<p><code>++x</code> will be evaluated only once giving an lvalue and only after that <code>%=</code> operation will be performed.\nThis means that, both modifications to <code>x</code> is sequenced and the above expression is well defined.</p>\n", "OwnerUserId": "2455888", "LastEditorUserId": "2455888", "LastEditDate": "2015-01-09T08:58:14.393", "Id": "27848818", "Score": "5", "CreationDate": "2015-01-08T20:19:00.573", "LastActivityDate": "2015-01-09T08:58:14.393"}, "27845666": {"ParentId": "27835808", "CommentCount": "3", "Body": "<p>I'm going to offer an alternative answer, without quoting the good book, as I think re-writing it slightly makes it obvious.</p>\n<pre><code>++x %= 10;       // as stated\nx += 1 %= 10;    // re-write the 'sugared' ++x\n</code></pre>\n<p>This makes it clear enough in my eyes. As we know, the result of the assignment (which if we really want, the still 'sugared' <code>+=</code> reduces to) is itself an lvalue, so there should be no doubt that by further reduction the expression is:</p>\n<pre><code>(x = x+1) %= 10  // += -&gt; =1+\nx = (x+1) % 10   // assignment returns reference to incremented x\n</code></pre>\n", "OwnerUserId": "1446048", "PostTypeId": "2", "Id": "27845666", "Score": "5", "CreationDate": "2015-01-08T17:06:04.903", "LastActivityDate": "2015-01-08T17:06:04.903"}, "27839451": {"ParentId": "27835808", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>TL;DR</strong>: It is well-defined because <code>x</code> is guaranteed to be incremented before the assignment.</p>\n<hr>\n<h2>Some C++11 standardese</h2>\n<p>[intro.execution]/15:</p>\n<blockquote>\n<p id=\"so_27835808_27839451_0\"><strong>Except where noted</strong>, evaluations of operands of individual operators\n  and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>However, [expr.ass]/1 does note something:</p>\n<blockquote>\n<p id=\"so_27835808_27839451_1\"><strong>In all cases, the assignment is sequenced after the value computation\n  of the right and left operands</strong>, and before the value computation of\n  the assignment expression.</p>\n</blockquote>\n<p>So this does constitute an exception to the first quote. Moreover, as stated in [expr.pre.incr]<sup>1</sup>, <code>++x</code> is equivalent to <code>x += 1</code>, which is also covered by the above quote: The assignment is sequenced before the value computation. Thus <strong>for <code>++x</code> the increment is sequenced before the value computation.</strong></p>\n<p>Taking that into account it is not hard to see that in <code>++x %= 10</code>, the increment is done before the assignment is.<br>\nSo the increment side-effect is sequenced before the assignment side-effect, and thus all involved side-effects are sequenced.  </br></p>\n<p>To put it in another way, the standard imposes the following sequencing:</p>\n<ul>\n<li><code>++x</code> and <code>10</code> are evaluated - the order of which is unsequenced, but <code>10</code> is just a literal so that's not relevant here.\n<ul>\n<li><code>++x</code> is evaluated:\n<ul>\n<li>First, the value of <code>x</code> is incremented.</li>\n<li>Then the value computation is done, and we get an lvalue referring to <code>x</code>.<br/></li>\n</ul></li>\n</ul></li>\n<li>The assignment is done. The updated value of <code>x</code> is taken modulo <code>10</code> and assigned to <code>x</code>.</li>\n<li>The value computation of the assignment might follow, which is clearly sequenced after the assignment.</li>\n</ul>\n<p>Hence</p>\n<blockquote>\n<p id=\"so_27835808_27839451_2\">If a side effect on a scalar object is unsequenced relative to either\n  another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>doesn't apply as <strong>the side-effects and value-computations are sequenced</strong>.</p>\n<hr>\n<p><sup>1</sup> Not [expr.post.incr] which would be for the postfix increment!</p>\n</hr></hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-08T12:42:29.023", "Id": "27839451", "Score": "22", "CreationDate": "2015-01-08T11:49:28.403", "LastActivityDate": "2015-01-08T12:42:29.023"}, "28004164": {"ParentId": "27835808", "CommentCount": "0", "Body": "<p>The Prefix increment (++x) has highest precedence by the Modulus assignment (%= ). The statement: ++x %= 10; can be expressed as:</p>\n<pre><code>++x;\nx%= 10;\n</code></pre>\n", "OwnerUserId": "4276132", "PostTypeId": "2", "Id": "28004164", "Score": "1", "CreationDate": "2015-01-17T20:48:02.243", "LastActivityDate": "2015-01-17T20:48:02.243"}, "27836016": {"ParentId": "27835808", "PostTypeId": "2", "CommentCount": "30", "Body": "<p>As per C++11 <code>1.9 Program execution /15</code>:</p>\n<blockquote>\n<p id=\"so_27835808_27836016_0\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</p>\n<p id=\"so_27835808_27836016_1\">If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>In this case, I believe <code>++x</code> is a side effect and <code>x %= 10</code> is a value computation so you'd think it would be undefined behaviour. However, the <em>assignment</em> section (<code>5.17 /1</code>) has this to say (my bold):</p>\n<blockquote>\n<p id=\"so_27835808_27836016_2\">In all cases, the assignment is sequenced <strong>after the value computation of the right and left operands,</strong> and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>Hence that means that both sides are sequenced before the assignment and before the result of the assignment is made available. And since the standard also states (<code>5.17 /7</code>) that <code>x OP = y</code> is identical to <code>x = x OP y</code> but with <code>x</code> only being evaluated once, it turns out this <em>is</em> well defined behaviour, as it's equivalent to:</p>\n<pre><code>++x = Q % 10; // where Q is the value from ++x, not evaluated again.\n</code></pre>\n<p>The only question then remains is which <em>side</em> of the assignment is evaluated since <em>they're</em> not sequenced. However, I don't think it matters in this case since both these will have the same effect:</p>\n<pre><code>++x = Q % 10; // LHS evaluated first\nQ = ++x % 10; // RHS evaluated first\n</code></pre>\n<p>Now, that's <em>my</em> reading of the standard. While I have a fair amount of experience in decoding complex documents, there <em>may</em> be something I've missed - I don't think so because we've all had a lively discussion here in getting to this point :-) and I think we've all established the relevant sections.</p>\n<p>But, regardless of whether it's wel defined or not, decent coders <em>shouldn't</em> be writing code like that. It's been a long time since the low-memory/small-storage days of the PDP minis, it's about time we wrote our code to be <em>readable.</em></p>\n<p>If you want to increment then take the modulo, use <code>x = (x + 1) % 10</code>, if only to make it easier to understand for the next poor Joe reading that code.</p>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2015-01-09T03:25:09.793", "Id": "27836016", "Score": "62", "CreationDate": "2015-01-08T08:45:05.087", "LastActivityDate": "2015-01-09T03:25:09.793"}, "27838583": {"ParentId": "27835808", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Let's look at the unary increment operator:</p>\n<blockquote>\n<h3>5.3.2 Increment and decrement [expr.pre.incr]</h3>\n<p id=\"so_27835808_27838583_0\">1 The operand of prefix <code>++</code> is modified by adding 1, or set to <code>true</code> if it is <code>bool</code> (this use is deprecated). The operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to a completely-defined object type. <strong>The result is the updated operand; it is an lvalue</strong>, and it is a bit-field if the operand is a bit-field. If <code>x</code> is not of type <code>bool</code>, the expression <code>++x</code> is equivalent to <code>x+=1</code>.<br>\n  [...]</br></p>\n</blockquote>\n<p>Thus, all evaluations and side-effects pertaining to that unary operator are scheduled before its value, and thus cannot cause havoc.</p>\n<p>All that's left is evaluating <code>%= 10</code> on that lvalue. Only evaluating the constant might be concurrent (which could not possibly do any harm), the rest is strictly sequenced after everything else.</p>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2015-01-09T11:57:21.970", "Id": "27838583", "Score": "20", "CreationDate": "2015-01-08T11:04:52.680", "LastActivityDate": "2015-01-09T11:57:21.970"}, "bq_ids": {"n4140": {"so_27835808_27836620_1": {"section_id": 5809, "quality": 1.0, "length": 15}, "so_27835808_27839451_1": {"section_id": 6173, "quality": 1.0, "length": 15}, "so_27835808_27836016_0": {"section_id": 5811, "quality": 1.0, "length": 11}, "so_27835808_27836016_2": {"section_id": 6173, "quality": 1.0, "length": 15}, "so_27835808_27839451_0": {"section_id": 5811, "quality": 1.0, "length": 11}, "so_27835808_27836016_1": {"section_id": 5811, "quality": 1.0, "length": 22}, "so_27835808_27848818_3": {"section_id": 5811, "quality": 0.9090909090909091, "length": 10}, "so_27835808_27848818_1": {"section_id": 5811, "quality": 1.0, "length": 22}, "so_27835808_27848818_2": {"section_id": 6179, "quality": 0.875, "length": 7}, "so_27835808_27836620_0": {"section_id": 5811, "quality": 0.9565217391304348, "length": 22}, "so_27835808_27839451_2": {"section_id": 5811, "quality": 1.0, "length": 22}, "so_27835808_27838583_0": {"section_id": 6074, "quality": 0.8857142857142857, "length": 31}}, "n3337": {"so_27835808_27836620_1": {"section_id": 5582, "quality": 1.0, "length": 15}, "so_27835808_27839451_1": {"section_id": 5934, "quality": 1.0, "length": 15}, "so_27835808_27836016_0": {"section_id": 5584, "quality": 1.0, "length": 11}, "so_27835808_27836016_2": {"section_id": 5934, "quality": 1.0, "length": 15}, "so_27835808_27839451_0": {"section_id": 5584, "quality": 1.0, "length": 11}, "so_27835808_27836016_1": {"section_id": 5584, "quality": 1.0, "length": 22}, "so_27835808_27848818_3": {"section_id": 5584, "quality": 0.9090909090909091, "length": 10}, "so_27835808_27848818_1": {"section_id": 5584, "quality": 1.0, "length": 22}, "so_27835808_27848818_2": {"section_id": 5940, "quality": 0.875, "length": 7}, "so_27835808_27836620_0": {"section_id": 5584, "quality": 0.9565217391304348, "length": 22}, "so_27835808_27839451_2": {"section_id": 5584, "quality": 1.0, "length": 22}, "so_27835808_27838583_0": {"section_id": 5842, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_27835808_27836620_1": {"section_id": 7270, "quality": 1.0, "length": 15}, "so_27835808_27836016_0": {"section_id": 7272, "quality": 1.0, "length": 11}, "so_27835808_27839451_1": {"section_id": 7675, "quality": 1.0, "length": 15}, "so_27835808_27836016_2": {"section_id": 7675, "quality": 1.0, "length": 15}, "so_27835808_27839451_0": {"section_id": 7272, "quality": 1.0, "length": 11}, "so_27835808_27836016_1": {"section_id": 7272, "quality": 0.7272727272727273, "length": 16}, "so_27835808_27848818_3": {"section_id": 7272, "quality": 0.9090909090909091, "length": 10}, "so_27835808_27848818_1": {"section_id": 7272, "quality": 0.7272727272727273, "length": 16}, "so_27835808_27836620_0": {"section_id": 7272, "quality": 0.6956521739130435, "length": 16}, "so_27835808_27848818_2": {"section_id": 7681, "quality": 0.875, "length": 7}, "so_27835808_27839451_2": {"section_id": 7272, "quality": 0.7272727272727273, "length": 16}, "so_27835808_27838583_0": {"section_id": 7570, "quality": 0.6857142857142857, "length": 24}}}});