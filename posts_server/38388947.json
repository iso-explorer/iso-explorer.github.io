post_cb({"bq_ids": {"n4140": {"so_38388947_38394333_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 504}, "so_38388947_38394333_1": {"length": 31, "quality": 0.8611111111111112, "section_id": 505}}, "n3337": {"so_38388947_38394333_1": {"length": 31, "quality": 0.8611111111111112, "section_id": 496}, "so_38388947_38394333_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 495}}, "n4659": {"so_38388947_38394333_1": {"length": 31, "quality": 0.8611111111111112, "section_id": 526}, "so_38388947_38394333_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 525}}}, "38390529": {"Id": "38390529", "PostTypeId": "2", "Body": "<p>To expand on H. Gujit's answer, neither the C or C++ language standards provide any guarantees here, but the <em>POSIX</em> standard does provide some additional guarantees about how <code>cpp</code> (the <strong>C</strong> <strong>P</strong>re<strong>p</strong>rocessor) shall function. <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/utilities/c99.html#tag_20_11_04\" rel=\"nofollow\">For instance, in the description of the <code>-I</code> command line option</a>:</p>\n<blockquote>\n<p id=\"so_38388947_38390529_0\">Thus, headers whose names are enclosed in double-quotes ( <code>\"\"</code> ) shall be searched for first in the directory of the file with the <code>#include</code> line, then in directories named in <code>-I</code> options, and last in the usual places. For headers whose names are enclosed in angle brackets ( \"<code>&lt;&gt;</code>\" ), the header shall be searched for only in directories named in <code>-I</code> options and then in the usual places.</p>\n</blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/POSIX#POSIX-oriented_operating_systems\" rel=\"nofollow\">So any UNIX-like platforms attempting POSIX compliance will behave in this way.</a></p>\n", "LastEditorUserId": "1171191", "LastActivityDate": "2016-07-15T08:59:29.817", "Score": "2", "CreationDate": "2016-07-15T07:42:12.367", "ParentId": "38388947", "CommentCount": "0", "LastEditDate": "2016-07-15T08:59:29.817", "OwnerUserId": "1171191"}, "38394333": {"Id": "38394333", "PostTypeId": "2", "Body": "<p>According to the standard (16.2 [cpp.include]/2), <code>#include &lt;...&gt;</code></p>\n<blockquote>\n<p id=\"so_38388947_38394333_0\">searches a sequence of implementation-defined places for <strong>a header</strong>\n  identified uniquely by the specified sequence between the <code>&lt;</code> and <code>&gt;</code>\n  delimiters. How the places are specified or the header identified is\n  implementation-defined. [emphasis added]</p>\n</blockquote>\n<p>In contrast (16.2 [cpp.include]/3), <code>#include \"...\"</code></p>\n<blockquote>\n<p id=\"so_38388947_38394333_1\">causes the replacement of that directive by the entire contents of\n  <strong>the source file</strong> identified by the specified sequence between the <code>\"</code> delimiters. The named source file is searched for in an\n  implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read\n  <code>#include &lt;...&gt;</code>\n  with the identical contained sequence (including <code>&gt;</code> characters, if any) from the original directive. [emphasis added]</p>\n</blockquote>\n<p>So the locations and techniques are <strong>entirely</strong> implementation defined, except that <code>#include \"...\"</code> falls back on <code>#include &lt;...&gt;</code> if no source file is found in the initial search.</p>\n<p>The difference in wording is important: <code>#include &lt;...&gt;</code> does <strong>not</strong> require a source file; it's entirely up to the implementation how it handles standard headers. User-written header files should <strong>only</strong> be pulled in with <code>#include \"...\"</code>, since that's the one that's required to handle source files.</p>\n<p>For the most part, compilers implement these things in the way that you'd expect. The critical difference that you're seeing with MSVC is that for <code>#include \"...\"</code> it searches first in the directory of the top-level source file that's being compiled, while other compilers search first in the directory of the source file that's currently being compiled. This matters when a header file has a <code>#include \"...\"</code> directive: most compilers search in the directory where the header file lives, but MSVC searches as if the <code>#include \"...\"</code> directive was in the top-level source file. Both are valid, and there are arguments for both approaches, although I personally find searching the directory where the header lives more intuitive and easier to work with.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2016-07-15T11:00:06.620", "Score": "1", "CreationDate": "2016-07-15T10:52:54.983", "ParentId": "38388947", "CommentCount": "0", "LastEditDate": "2016-07-15T11:00:06.620", "OwnerUserId": "1593860"}, "38388947": {"ViewCount": "104", "Body": "<p>Recently <a href=\"https://github.com/Dobiasd/FunctionalPlus/issues/22#issuecomment-229999265\" rel=\"nofollow\">I learned</a> that gnu cpp and msvc cl treat <code>#include</code> files differently.  The common behavior is to look inside the directory of next to the includ_ing_ file, and then iterate over the include path (which is obviously set using <code>-I</code> or <code>/I</code> compiler arguments.)</p>\n<p>But now I wonder: did I learn correctly, or is there actually a standard for the preprocessor, too?</p>\n", "AcceptedAnswerId": "38389758", "Title": "Is there any standard requirement for C++ #include lookup?", "CreationDate": "2016-07-15T06:08:04.353", "Id": "38388947", "CommentCount": "4", "LastEditDate": "2016-07-16T17:33:08.417", "PostTypeId": "1", "LastEditorUserId": "4370109", "LastActivityDate": "2016-07-16T17:33:08.417", "Score": "2", "OwnerUserId": "6610", "Tags": "<c++><c-preprocessor><include-path>", "AnswerCount": "3"}, "38389758": {"Id": "38389758", "PostTypeId": "2", "Body": "<p>According to the standard, both <code>#include &lt;...&gt;</code> and <code>#include \"...\"</code> shall search an implementation defined set of places. There is not even a requirement that  the name provided between <code>&lt;&gt;</code> or <code>\"\"</code> is a file name, just that it allows unique identification of a header.</p>\n<p>Having said that, if an implementation wants to have any hope of compiling existing source, it had better follow the same conventions as the rest: <code>&lt;...&gt;</code> refers to a system include file, and <code>\"...\"</code> refers to your own include files (and the directory containing the source file should be searched first). None of these are requirements from the standard, but without them you have no way to compile pretty much any existing code out there. </p>\n<p>The standard is a little schizophrenic in places - in one place it will give you tools to deal with files and directory (the filesystem extension in C++17), while in others it refuses to acknowledge that such things as files and directories even exist. Presumably this is because the authors do not want to mess with ancient text too much, since it works fine now and might just accidentally break stuff, but it does look a bit funny.</p>\n", "LastEditorUserId": "1171191", "LastActivityDate": "2016-07-15T08:01:08.800", "Score": "3", "CreationDate": "2016-07-15T06:59:56.440", "ParentId": "38388947", "CommentCount": "6", "LastEditDate": "2016-07-15T08:01:08.800", "OwnerUserId": "4566726"}});