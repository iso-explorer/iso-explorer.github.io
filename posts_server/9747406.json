post_cb({"9747406": {"ViewCount": "398", "Body": "<p>This question comes from issues raised by <a href=\"https://stackoverflow.com/a/9746772/734069\">this answer</a>.</p>\n<p>Normally, we define copy assignment operators for type <code>T</code> as <code>T&amp; operator=(const T&amp;)</code>, and move assignment operators for type <code>T</code> as <code>T&amp; operator=(T&amp;&amp;)</code>.</p>\n<p>However, what happens when we use a value parameter rather than a reference?</p>\n<pre><code>class T\n{\npublic:\n  T&amp; operator=(T t);\n};\n</code></pre>\n<p>This should make T both copy and move assignable. However, what I want to know is what are the language ramifications for <code>T</code>?</p>\n<p>Specifically:</p>\n<ol>\n<li>Does this count as a copy assignment operator for <code>T</code>, according to the specification?</li>\n<li>Does this count as a move assignment operator for <code>T</code>, according to the specification?</li>\n<li>Will <code>T</code> have a compiler-generated copy assignment operator?</li>\n<li>Will <code>T</code> have a compiler-generated move assignment operator?</li>\n<li>How does this affect traits classes like <code>std::is_move_assignable</code>?</li>\n</ol>\n", "AcceptedAnswerId": "9747527", "Title": "Ramification of assignment operators with values instead of references", "CreationDate": "2012-03-17T05:00:07.587", "Id": "9747406", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:20:14.883", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-17T05:48:28.653", "Score": "14", "OwnerUserId": "734069", "Tags": "<c++><c++11><language-lawyer><move-semantics>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9747406_9747527_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 467}, "so_9747406_9747527_3": {"length": 19, "quality": 1.0, "section_id": 469}, "so_9747406_9747527_0": {"length": 18, "quality": 1.0, "section_id": 466}, "so_9747406_9747527_1": {"length": 18, "quality": 1.0, "section_id": 468}, "so_9747406_9747527_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 4706}}, "n3337": {"so_9747406_9747527_1": {"length": 18, "quality": 1.0, "section_id": 459}, "so_9747406_9747527_3": {"length": 19, "quality": 1.0, "section_id": 460}, "so_9747406_9747527_0": {"length": 18, "quality": 1.0, "section_id": 457}, "so_9747406_9747527_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 458}, "so_9747406_9747527_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 4515}}, "n4659": {"so_9747406_9747527_1": {"length": 18, "quality": 1.0, "section_id": 491}, "so_9747406_9747527_3": {"length": 19, "quality": 1.0, "section_id": 492}, "so_9747406_9747527_0": {"length": 18, "quality": 1.0, "section_id": 489}, "so_9747406_9747527_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 490}, "so_9747406_9747527_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 6103}}}, "9747527": {"Id": "9747527", "PostTypeId": "2", "Body": "<p>Most of this is described in \u00a712.8. Paragraph 17 defines what counts as user-declared copy assignment operators:</p>\n<blockquote>\n<p id=\"so_9747406_9747527_0\">A user-declared copy assignment operator <code>X::operator=</code> is a non-static non-template member function of class <code>X</code> with exactly one parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code>, or <code>const volatile X&amp;</code>.</p>\n</blockquote>\n<p>Paragraph 19 defines what counts as user-declared move assignment operators:</p>\n<blockquote>\n<p id=\"so_9747406_9747527_1\">A user-declared move assignment operator <code>X::operator=</code> is a non-static\n  non-template member function of class <code>X</code> with exactly one parameter of\n  type <code>X&amp;&amp;</code>, <code>const X&amp;&amp;</code>, <code>volatile X&amp;&amp;</code>, or <code>const volatile X&amp;&amp;</code>.</p>\n</blockquote>\n<p>So, it counts as a copy assignment operator, but not as a move assignment operator.</p>\n<p>Paragraph 18 tells when the compiler generates copy assignment operators:</p>\n<blockquote>\n<p id=\"so_9747406_9747527_2\">If the class definition does not explicitly declare a copy assignment\n  operator, one is declared implicitly. If the class definition declares\n  a move constructor or move assignment operator, the implicitly\n  declared copy assignment operator is defined as deleted; otherwise, it\n  is defined as defaulted (8.4). The latter case is deprecated if the\n  class has a user-declared copy constructor or a user-declared\n  destructor.</p>\n</blockquote>\n<p>Paragraph 20 tells us when the compiler generates move assignment operators:</p>\n<blockquote>\n<p id=\"so_9747406_9747527_3\">If the definition of a class X does not explicitly declare a move\n  assignment operator, one will be implicitly declared as defaulted if\n  and only if<br>\n  [...]<br>\n  \u2014 X does not have a user-declared copy assignment operator,<br>\n  [...]</br></br></br></p>\n</blockquote>\n<p>Since the class has a user-declared copy assignment operator, neither of the implicit ones will be generated by the compiler.</p>\n<p><code>std::is_copy_assignable</code> and <code>std::is_move_assignable</code> are described in table 49 as having the same value as, respectively <code>is_assignable&lt;T&amp;,T const&amp;&gt;::value</code> and <code>is_assignable&lt;T&amp;,T&amp;&amp;&gt;::value</code>. That table tells us that <code>is_assignable&lt;T,U&gt;::value</code> is <code>true</code> when:</p>\n<blockquote>\n<p id=\"so_9747406_9747527_4\">The expression <code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> is well-formed when treated\n  as an unevaluated operand (Clause 5). Access checking is performed as\n  if in a context unrelated to <code>T</code> and <code>U</code>. Only the validity of the\n  immediate context of the assignment expression is considered. </p>\n</blockquote>\n<p>Since both <code>declval&lt;T&amp;&gt;() = declval&lt;T const&amp;&gt;()</code> and <code>declval&lt;T&amp;&gt;() = declval&lt;T&amp;&amp;&gt;()</code> are well-formed for that class, it still counts as copy assignable and move assignable.</p>\n<p>As I mentioned in the comments, what's curious about all this is that, in the presence of a move constructor, that <code>operator=</code> will correctly perform moves, but technically not count as a move assignment operator. It's even stranger if the class has no copy constructor: it will have a copy assignment operator that doesn't do copies, but only moves.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-03-17T05:48:28.653", "Score": "14", "CreationDate": "2012-03-17T05:24:09.640", "ParentId": "9747406", "CommentCount": "0", "OwnerUserId": "46642", "LastEditDate": "2012-03-17T05:48:28.653"}});