post_cb({"39813123": {"CommentCount": "1", "CreationDate": "2016-10-02T01:50:56.977", "PostTypeId": "1", "AcceptedAnswerId": "39813678", "LastEditorUserId": "819272", "LastActivityDate": "2016-10-04T19:31:05.477", "LastEditDate": "2016-10-04T19:31:05.477", "ViewCount": "283", "FavoriteCount": "1", "Title": "Can C++17's deduced `auto` non-type `template` parameters pattern-match templates with explicit non-type parameters?", "Id": "39813123", "Score": "10", "Body": "<p>Consider this example <em>(<a href=\"http://melpon.org/wandbox/permlink/XI9W2GQa7DFLffOt\">also available on wandbox</a>)</em>: </p>\n<pre><code>template &lt;template &lt;auto&gt; class&gt;\nvoid test() { }\n\ntemplate &lt;int&gt; \nstruct X { };\n</code></pre>\n<p>Trying to instantiate <code>test&lt;X&gt;()</code> on <code>clang++</code> 4.0 <em>(trunk)</em> results in a compilation error:</p>\n<pre><code>error: no matching function for call to 'test'\n     test&lt;X&gt;();\n     ^~~~~~~\n\nnote: candidate template ignored: \n      invalid explicitly-specified argument for 1st template parameter\nvoid test() { }\n</code></pre>\n<p>My initial assumption/intuition was that <code>test</code> could be used to match any <code>template</code> having a non-type parameter.</p>\n<hr>\n<p>However, the following code snippet successfully compiles: </p>\n<pre><code>template &lt;template &lt;auto&gt; class&gt;\nvoid test() { }\n\n//        vvvv\ntemplate &lt;auto&gt; \nstruct X { };\n</code></pre>\n<p>Is this intended? Could not find anything conclusive in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0127r2.html\">P0127R2</a>.</p>\n</hr>", "Tags": "<c++><templates><auto><c++1z>", "OwnerUserId": "598696", "AnswerCount": "2"}, "39813678": {"ParentId": "39813123", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It's definitely intended. Template-template parameters can only match templates which take the same kinds of arguments. This:</p>\n<pre><code>template &lt;template &lt;auto&gt; class&gt;\nvoid test() { }\n</code></pre>\n<p>can only be instantiated with a class template that can take <em>any</em> kind of non-type parameter. But this:</p>\n<pre><code>template &lt;int&gt; \nstruct X { };\n</code></pre>\n<p>is not such a class template. <code>X</code> can only be instantiated with an <code>int</code>. It simply does not match the specification for the template template parameter, hence the error. What if <code>test</code> wanted to instantiate its class template with a pointer type? Or pointer to function or pointer to member? That would be impossible. </p>\n<p>Your second attempt, with <code>template &lt;auto&gt; struct X { };</code> <em>does</em> match the template-template parameter, hence is well-formed. Note also that the reverse, having <code>test</code> take a <code>template &lt;int&gt; class</code> parameter and passing in <code>template &lt;auto&gt; struct X { };</code> is also well-formed as the argument is more general than the parameter. </p>\n<hr/>\n<p>The relevant wording is in [temp.arg.template]:</p>\n<blockquote>\n<p id=\"so_39813123_39813678_0\">A <em>template-argument</em> matches a template <em>template-parameter</em> <code>P</code> when each of the template parameters in the <em>template-parameter-list</em> of the <em>template-argument</em>\u2019s corresponding class template or alias template <code>A</code> matches\n  the corresponding template parameter in the <em>template-parameter-list</em> of <code>P</code>. Two template parameters match if they are of the same kind (type, non-type, template), for non-type <em>template-parameters</em>, their types are\n  equivalent (14.5.6.1), and for template <em>template-parameters</em>, each of their corresponding <em>template-parameters</em> matches, recursively.</p>\n</blockquote>\n<hr/>\n<p>Note: the equivalence wording accepts the <code>auto</code> - <code>auto</code> case and rejects the <code>auto</code> - <code>int</code> case, but also seems to reject the <code>int</code> - <code>auto</code> case (based on my reading). I'm going to try to get some clarification on it. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-10-02T04:03:35.937", "Id": "39813678", "Score": "9", "CreationDate": "2016-10-02T03:51:35.663", "LastActivityDate": "2016-10-02T04:03:35.937"}, "39815951": {"ParentId": "39813123", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In addition to Barry's answer, which made me curious, here are the four possible combinations and results using Clang 4.0 (SVN), <a href=\"http://melpon.org/wandbox/permlink/gCk2Dny2LraYJYIZ\" rel=\"nofollow\"><em>see also on wandbox</em></a>:</p>\n<pre><code>template &lt;bool&gt; struct obj_bool { };  // object taking a value of boolean type\ntemplate &lt;auto&gt; struct obj_auto { };  // object taking a value of deduced type\n//       ^^^^^^ Note: this is a template value argument (non-type template argument)\n\ntemplate &lt;template &lt;auto&gt; typename&gt; void fn_auto() { }\ntemplate &lt;template &lt;bool&gt; typename&gt; void fn_bool() { }\n//        ^^^^^^^^^^^^^^^^^^^^^^^^ Note: this is a template type argument\n//                 ^^^^^^                taking a template value argument\n\nint main() {     \n    fn_bool&lt;obj_bool&gt;();    // #1 bool-&gt;bool OK (exact match)\n    fn_auto&lt;obj_auto&gt;();    // #2 auto-&gt;auto OK (exact match)\n    fn_bool&lt;obj_auto&gt;();    // #3 bool-&gt;auto OK (sub-set)\n    //fn_auto&lt;obj_bool&gt;();  // #4 auto-&gt;bool Error: no matching function.\n}\n</code></pre>\n<p>From that, #1 and #2 are obviously exact matches and are working as expected. #3 would invoke the bool implementation on a template that can handle not only bool but all types, whereas #4 would try to invoke a definition expecting a generalized object (auto) with an object providing only a sub-set (bool) of possibilities.</p>\n<p>The templated function <code>fn_auto</code> promises possible instantiations for templates taking any value type (auto). Thus giving it only a sub-set of possibilities (bool) violates this promise. </p>\n<p>Though not immediately obvious, the restriction makes sense. And sorry for my wording not being C++ Standard compliant.</p>\n", "OwnerUserId": "5294141", "LastEditorUserId": "5294141", "LastEditDate": "2016-10-02T10:29:13.730", "Id": "39815951", "Score": "2", "CreationDate": "2016-10-02T10:15:10.420", "LastActivityDate": "2016-10-02T10:29:13.730"}, "bq_ids": {"n4140": {"so_39813123_39813678_0": {"section_id": 94, "quality": 0.9772727272727273, "length": 43}}, "n3337": {"so_39813123_39813678_0": {"section_id": 89, "quality": 0.5909090909090909, "length": 26}}, "n4659": {"so_39813123_39813678_0": {"section_id": 97, "quality": 0.8181818181818182, "length": 36}}}});