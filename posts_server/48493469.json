post_cb({"bq_ids": {"n4140": {"so_48493469_48493469_0": {"length": 12, "quality": 1.0, "section_id": 9}}, "n3337": {"so_48493469_48493469_0": {"length": 12, "quality": 1.0, "section_id": 6}}, "n4659": {"so_48493469_48493469_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 4087}}}, "48493469": {"ViewCount": "46", "Body": "<p>(I asked this question before but didn't give a viable example so I deleted previous one. I hope on this one I got the example right.)</p>\n<p>Case:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct S\n{\n    S() = default;\n\n    S(const S &amp;)\n    {\n        std::cout &lt;&lt; \"Copying\" &lt;&lt; std::endl;\n    }\n\n    S&amp; operator=(const S &amp;)\n    {\n        std::cout &lt;&lt; \"Copy assignment\" &lt;&lt; std::endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    S s{};\n    S s2{};\n    S &amp;ref = s;\n    ref = s2;\n}\n</code></pre>\n<p>As I understand, <code>ref = s2;</code> includes l2r conversion as it is a 'builtin direct assignment' that per cppreference expects and rvalue as its right argument.</p>\n<p>I've read some of the SO questions regarding lvalue-to-rvalue conversion, but I'm still not sure if it involved copying of objects, and if it does, what kind of copying is it.</p>\n<p>Let's say we're talking about class types.</p>\n<p>From [conv.lval]/2:</p>\n<blockquote>\n<p id=\"so_48493469_48493469_0\">Otherwise, if T has a class type, the conversion copy-initializes a temporary of type T from the glvalue and the result of the conversion is a prvalue for the temporary.</p>\n</blockquote>\n<p>So, there is copy-initialization involved as a part of lvalue-to-rvalue conversion.</p>\n<p>So taking an example of <code>ref = s2;</code>, with user-defined copy constructor that e.g. prints 'Copying', will that 'Copying' be printed during the execution of the aforementioned statement?</p>\n<p>Well, obviously it won't. But that means I'm misunderstanding something here.</p>\n<p>Is the copy-initialization during lvalue-to-rvalue conversion something like plain memcpy and not a copy-initialization in its full sense?</p>\n<p>How all of this works? :)</p>\n", "Title": "Lvalue-to-rvalue conversion for class types: is there copying involved?", "CreationDate": "2018-01-29T02:13:06.550", "LastActivityDate": "2018-01-29T02:44:42.860", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2018-01-29T02:36:21.387", "LastEditorUserId": "4751585", "Id": "48493469", "Score": "0", "OwnerUserId": "4751585", "Tags": "<c++><c++14><copy-constructor><lvalue-to-rvalue><value-categories>", "AnswerCount": "1"}, "48493693": {"Id": "48493693", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48493469_48493693_0\">As I understand, <code>ref = s2</code>; includes l2r conversion as it is a 'builtin direct assignment' that per cppreference expects and rvalue as its right argument.</p>\n</blockquote>\n<p>Your mistake is in interpreting the assignment operator here is a built-in. It is not. The only types that have a built-in assignment operator are the fundamental types (pointers, <code>char</code>, <code>int</code>, etc.) What you have is a class type, which has an overloaded assignment operator (whether user-provided or implicitly generated by the compiler).</p>\n<p><code>ref = s2;</code> simply invokes <code>S::operator=(S const&amp;)</code>. It behaves as if you just typed <code>ref.operator=(s2)</code>. There is no lvalue-to-rvalue conversion in that function's implementation, so no other copy is made. All that happens is that the line gets printed. No additional copy initialiation, etc.</p>\n<p>If you implemented your assignment operator differently, as:</p>\n<pre><code>S&amp; operator=(S /* no ref */) { return *this; }\n</code></pre>\n<p>Then an lvalue-to-rvalue conversion would happen in order actually invoke this function, and you would see your copy constructor get called. </p>\n", "LastActivityDate": "2018-01-29T02:44:42.860", "CommentCount": "2", "CreationDate": "2018-01-29T02:44:42.860", "ParentId": "48493469", "Score": "1", "OwnerUserId": "2069064"}});