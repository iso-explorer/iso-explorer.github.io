post_cb({"30424903": {"ParentId": "26559758", "CommentCount": "0", "CreationDate": "2015-05-24T14:59:28.730", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "30424903", "Score": "8", "Body": "<p>There are three conversions that are considered lvalue transformations: lvalue-to-rvalue, array-to-pointer, and function-to-pointer. You can call this \"decay\" since that's what <code>std::decay</code> will do to these types, but the standard just calls this a function-to-pointer conversion [conv.func]:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_0\">An lvalue of function type <code>T</code> can be converted to a prvalue of type \u201cpointer to <code>T</code>.\u201d The result is a pointer to the function.</p>\n</blockquote>\n<p>If you're asking for what the cases are for when a function-to-pointer conversion happens, they are basically the same as when the other two lvalue transformations would happen. If we just go through the standard in order, the following is an exhaustive list of cases where function-to-pointer conversion happens:</p>\n<p>Using a function as an operand, [expr]/9:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_1\">Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand,\n  the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are applied\n  to convert the expression to a prvalue.</p>\n</blockquote>\n<p>Using a function as an argument to a varargs function, [expr.call]/7:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_2\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving function can obtain the value of the argument by invoking <code>va_arg</code> (18.10)... The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the argument expression.</p>\n</blockquote>\n<p>You can <code>static_cast</code> away this conversion, [expr.static.cast]/7:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_3\">The inverse of any standard conversion sequence (Clause 4) not containing an lvalue-to-rvalue (4.1), arrayto-\n  pointer (4.2), function-to-pointer (4.3), null pointer (4.10), null member pointer (4.11), or boolean (4.12)\n  conversion, can be performed explicitly using <code>static_cast</code>.</p>\n</blockquote>\n<p>Though otherwise, the operand you pass in will get converted, [expr.static.cast]/8:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_4\">The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) conversions are applied to\n  the operand.</p>\n</blockquote>\n<p>Using <code>reinterpret_cast</code>, [expr.reinterpret.cast]/1:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_5\">The result of the expression <code>reinterpret_cast&lt;T&gt;(v)</code> is the result of converting the expression <code>v</code> to type\n  <code>T</code>. If <code>T</code> is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; if <code>T</code> is an\n  rvalue reference to object type, the result is an xvalue; otherwise, the result is a prvalue and the lvalue-torvalue\n  (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the\n  expression <code>v</code>.</p>\n</blockquote>\n<p>Using <code>const_cast</code>, [expr.const.cast], with basically identical wording to the above. Using the conditional operator, [expr.cond]:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_6\">Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed\n  on the second and third operands.</p>\n</blockquote>\n<p>Notice in all of the above cases, it's always <em>all</em> of the lvalue transformations. </p>\n<p>Function-to-pointer conversions also occur when in templates. Passing a function as a non-type parameter, [temp.arg.nontype]/5.4:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_7\">For a non-type <em>template-parameter</em> of type pointer to function, the function-to-pointer conversion (4.3)\n  is applied</p>\n</blockquote>\n<p>Or type deduction, [temp.deduct.call]/2:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_8\">If <code>P</code> is not a reference type:  </p>\n<ul>\n<li>\u2014 If <code>A</code> is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is\n  used in place of <code>A</code> for type deduction; otherwise,</li>\n<li>\u2014 If <code>A</code> is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3)\n  is used in place of <code>A</code> for type deduction; otherwise,</li>\n</ul>\n</blockquote>\n<p>Or conversion function template deduction, with roughly the same wording. </p>\n<p>And lastly, of course, <code>std::decay</code> itself, defined in [meta.trans.other], emphasis mine:</p>\n<blockquote>\n<p id=\"so_26559758_30424903_9\">Let <code>U</code> be <code>remove_reference_t&lt;T&gt;</code>. If <code>is_array&lt;U&gt;::value</code> is true, the\n  member typedef type shall equal <code>remove_extent_t&lt;U&gt;*</code>. <strong>If <code>is_function&lt;U&gt;::value</code> is true, the member typedef type shall equal\n  <code>add_pointer_t&lt;U&gt;</code></strong>. Otherwise the member typedef type equals\n  <code>remove_cv_t&lt;U&gt;</code>. [ Note: This behavior is similar to the\n  lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) conversions applied when an lvalue expression is used as an rvalue, but also strips <em>cv</em>-qualifiers from class types in order to more closely model by-value\n  argument passing. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2015-05-24T14:59:28.730"}, "26559936": {"ParentId": "26559758", "CommentCount": "0", "Body": "<p>Another obvious similarity between arrays and functions would be the following:</p>\n<pre><code>void bar(string message) \n{\n    cout &lt;&lt; message &lt;&lt; endl;\n}\n\nvoid main()\n{\n    int myArray[10];\n    int* p = myArray; //array to pointer to array\n\n    void (*f)(string);\n    f = bar; //function to function pointer decay\n}\n</code></pre>\n", "Id": "26559936", "PostTypeId": "2", "OwnerDisplayName": "user955279", "Score": "0", "CreationDate": "2014-10-25T06:36:18.340", "LastActivityDate": "2014-10-25T06:36:18.340"}, "26559758": {"CommentCount": "15", "ViewCount": "831", "PostTypeId": "1", "LastEditorUserId": "4179986", "CreationDate": "2014-10-25T06:03:39.813", "LastActivityDate": "2015-05-24T14:59:28.730", "Title": "Function-to-function-pointer \"decay\"", "LastEditDate": "2014-10-25T06:41:12.640", "Id": "26559758", "Score": "13", "Body": "<p>As we know a parameter that looks like <code>void()</code> will be rewritten as <code>void(*)()</code>. This is similar to array-to-pointer decay where <code>int[]</code> becomes <code>int*</code>. There are many cases where using an array will decay it to a pointer. Are there cases other than parameters where functions \"decay\"?</p>\n<p>The C++ standard states:</p>\n<p>\u00a78.3.5/5</p>\n<blockquote>\n<p id=\"so_26559758_26559758_0\">... After determining the type of each parameter, any parameter of\n  type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer\n  to T\u201d or \u201cpointer to function returning T,\u201d respectively...</p>\n</blockquote>\n<p>Since the commenter below doesn't seem to believe me..here's what my compiler shows.</p>\n<pre><code>void handler(void func())\n{\n    func(42);\n}\n\nmain.cpp: In function 'void handler(void (*)())':\nmain.cpp:5:12: error: too many arguments to function\n     func(42);\n        ^\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "4179986", "AnswerCount": "4"}, "30380608": {"ParentId": "26559758", "CommentCount": "0", "CreationDate": "2015-05-21T17:31:13.203", "OwnerUserId": "4265352", "PostTypeId": "2", "Id": "30380608", "Score": "3", "Body": "<p>When it's about data types, functions are not first class citizens in C and C++ (the question is about C++ but the behaviour is inherited from C). They are code, not data and they cannot be copied, passed as arguments to functions or returned by functions (but all these can happen to pointers to functions.)</p>\n<p>This is why a function name is treated like a pointer to that function and not like the function body itself.</p>\n<p>The possibility to use a function (name) instead of a pointer to the function is just a courtesy the language makes to the programmer, and not a \"decay\".</p>\n<p>The same for arrays: they are not copied, not passed as function arguments and not returned by functions. The address of their first element is used instead (copied, passed as function argument or returned by functions). This is why the array name can be used instead of the address of its first element and again, this is just a way to write less (and less obfuscated) code.</p>\n<p>For the compiler, a function is a block of memory (that contains code to be executed at some time) that does not move and is identified by its address, i.e. the pointer to the function. An array is also a block of data\nthat does not move and is identified by its address (which is also the address of its first element). Again, this is a pointer.</p>\n<p>The concepts of <code>function</code> and <code>array</code> at higher levels (C, C++) are translated by the compiler to primitive values (pointers) that are understood by the lower levels (assembler, machine code).</p>\n", "LastActivityDate": "2015-05-21T17:31:13.203"}, "bq_ids": {"n4140": {"so_26559758_30424903_2": {"section_id": 5994, "quality": 0.9230769230769231, "length": 24}, "so_26559758_30424903_1": {"section_id": 5942, "quality": 1.0, "length": 17}, "so_26559758_30424903_6": {"section_id": 6172, "quality": 1.0, "length": 8}, "so_26559758_30424903_5": {"section_id": 6040, "quality": 0.96875, "length": 31}, "so_26559758_30424903_7": {"section_id": 91, "quality": 0.8888888888888888, "length": 8}, "so_26559758_30424903_3": {"section_id": 6033, "quality": 0.76, "length": 19}, "so_26559758_30424903_4": {"section_id": 6034, "quality": 0.8571428571428571, "length": 6}, "so_26559758_30424903_0": {"section_id": 12, "quality": 0.9166666666666666, "length": 11}, "so_26559758_26559758_0": {"section_id": 3241, "quality": 1.0, "length": 16}}, "n3337": {"so_26559758_30424903_2": {"section_id": 5762, "quality": 0.9230769230769231, "length": 24}, "so_26559758_30424903_1": {"section_id": 5713, "quality": 1.0, "length": 17}, "so_26559758_30424903_6": {"section_id": 5933, "quality": 1.0, "length": 8}, "so_26559758_30424903_5": {"section_id": 5808, "quality": 0.96875, "length": 31}, "so_26559758_30424903_7": {"section_id": 86, "quality": 0.8888888888888888, "length": 8}, "so_26559758_30424903_3": {"section_id": 5801, "quality": 0.76, "length": 19}, "so_26559758_30424903_4": {"section_id": 5802, "quality": 0.8571428571428571, "length": 6}, "so_26559758_30424903_0": {"section_id": 9, "quality": 0.9166666666666666, "length": 11}, "so_26559758_26559758_0": {"section_id": 3114, "quality": 1.0, "length": 16}}, "n4659": {"so_26559758_30424903_7": {"section_id": 59, "quality": 0.5555555555555556, "length": 5}, "so_26559758_30424903_1": {"section_id": 7426, "quality": 1.0, "length": 17}, "so_26559758_30424903_6": {"section_id": 7670, "quality": 1.0, "length": 8}, "so_26559758_30424903_2": {"section_id": 7496, "quality": 0.9230769230769231, "length": 24}, "so_26559758_30424903_0": {"section_id": 13, "quality": 0.9166666666666666, "length": 11}, "so_26559758_30424903_5": {"section_id": 7539, "quality": 0.96875, "length": 31}, "so_26559758_30424903_4": {"section_id": 7533, "quality": 0.8571428571428571, "length": 6}, "so_26559758_30424903_3": {"section_id": 7532, "quality": 0.76, "length": 19}, "so_26559758_26559758_0": {"section_id": 3997, "quality": 0.75, "length": 12}}}, "26559785": {"ParentId": "26559758", "CommentCount": "0", "CreationDate": "2014-10-25T06:10:52.587", "OwnerUserId": "4167677", "PostTypeId": "2", "Id": "26559785", "Score": "-1", "Body": "<p>yes they are both pointers, first is a function pointer, second is a pointer to a block of ints.  * looks like a point.</p>\n", "LastActivityDate": "2014-10-25T06:10:52.587"}});