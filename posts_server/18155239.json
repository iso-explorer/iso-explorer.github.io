post_cb({"18155239": {"CommentCount": "3", "ViewCount": "458", "PostTypeId": "1", "LastEditorUserId": "815724", "CreationDate": "2013-08-09T20:37:09.207", "LastActivityDate": "2013-08-10T02:40:28.820", "Title": "Design decision regarding std::array fill", "FavoriteCount": "0", "LastEditDate": "2013-08-10T02:40:28.820", "Id": "18155239", "Score": "11", "Body": "<p><code>std::array</code> in C++11 is a useful class that provides a C++ Container interface over a C stack array.</p>\n<p>But why does <code>std::array</code> not have the typical fill constructor that most containers have? Instead, it has a method <code>fill</code>.</p>\n<p>Is there some reason why <code>std::array</code> is unique among STL containers in this regard?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "469408", "AnswerCount": "3"}, "18155370": {"ParentId": "18155239", "CommentCount": "0", "Body": "<p>From section 23.3.2.1:</p>\n<blockquote>\n<p id=\"so_18155239_18155370_0\">An array is an aggregate (8.5.1) that can be initialized with the syntax\n  array a = { initializer-list };</p>\n</blockquote>\n<p>If it worked like <code>std::vector</code> it wouldn't be a POD anymore. Additionally from the same section:</p>\n<blockquote>\n<p id=\"so_18155239_18155370_1\">The conditions for an aggregate (8.5.1) shall be met.</p>\n</blockquote>\n<p>These conditions are:</p>\n<blockquote>\n<p id=\"so_18155239_18155370_2\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equalinitializers\n  for non-static data members (9.2), no private or protected non-static data members (Clause 11),\n  no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n", "OwnerUserId": "583833", "PostTypeId": "2", "Id": "18155370", "Score": "6", "CreationDate": "2013-08-09T20:45:29.147", "LastActivityDate": "2013-08-09T20:45:29.147"}, "18155352": {"ParentId": "18155239", "CommentCount": "0", "Body": "<p>Yes; <code>std::array</code> is meant to be an aggregate (C++11 \u00a78.5.1) so that at can be used in as many contexts as possible where a plain array can be used. An aggregate can have no explicit constructors or destructor.</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "18155352", "Score": "5", "CreationDate": "2013-08-09T20:44:26.530", "LastActivityDate": "2013-08-09T20:44:26.530"}, "bq_ids": {"n4140": {"so_18155239_18155370_0": {"section_id": 775, "quality": 0.625, "length": 5}, "so_18155239_18155370_2": {"section_id": 3298, "quality": 0.6956521739130435, "length": 16}}, "n3337": {"so_18155239_18155370_0": {"section_id": 762, "quality": 0.625, "length": 5}, "so_18155239_18155370_2": {"section_id": 3168, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_18155239_18155370_2": {"section_id": 4063, "quality": 0.5217391304347826, "length": 12}}}, "18155463": {"ParentId": "18155239", "CommentCount": "5", "Body": "<p>Everybody's explained the \"why\" pretty well I think, so I'll just put up a workaround suggestion, which should compile to be just as good as a native constructor:</p>\n<pre><code>template&lt; typename T, std::size_t n &gt; std::array&lt;T,n&gt; filledArray( const T&amp; v ) {\n    std::array&lt;T,n&gt; r;\n    r.fill( v );\n    return r;\n}\n\nauto arr = filledArray&lt;int,4&gt;( 7 );\n</code></pre>\n", "OwnerUserId": "1180785", "PostTypeId": "2", "Id": "18155463", "Score": "3", "CreationDate": "2013-08-09T20:51:23.460", "LastActivityDate": "2013-08-09T20:51:23.460"}});