post_cb({"bq_ids": {"n4140": {"so_18155239_18155370_2": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}, "so_18155239_18155370_0": {"length": 5, "quality": 0.625, "section_id": 775}}, "n3337": {"so_18155239_18155370_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}, "so_18155239_18155370_0": {"length": 5, "quality": 0.625, "section_id": 762}}, "n4659": {"so_18155239_18155370_2": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}}}, "18155352": {"Id": "18155352", "PostTypeId": "2", "Body": "<p>Yes; <code>std::array</code> is meant to be an aggregate (C++11 \u00a78.5.1) so that at can be used in as many contexts as possible where a plain array can be used. An aggregate can have no explicit constructors or destructor.</p>\n", "LastActivityDate": "2013-08-09T20:44:26.530", "CommentCount": "0", "CreationDate": "2013-08-09T20:44:26.530", "ParentId": "18155239", "Score": "5", "OwnerUserId": "923854"}, "18155370": {"Id": "18155370", "PostTypeId": "2", "Body": "<p>From section 23.3.2.1:</p>\n<blockquote>\n<p id=\"so_18155239_18155370_0\">An array is an aggregate (8.5.1) that can be initialized with the syntax\n  array a = { initializer-list };</p>\n</blockquote>\n<p>If it worked like <code>std::vector</code> it wouldn't be a POD anymore. Additionally from the same section:</p>\n<blockquote>\n<p id=\"so_18155239_18155370_1\">The conditions for an aggregate (8.5.1) shall be met.</p>\n</blockquote>\n<p>These conditions are:</p>\n<blockquote>\n<p id=\"so_18155239_18155370_2\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equalinitializers\n  for non-static data members (9.2), no private or protected non-static data members (Clause 11),\n  no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n", "LastActivityDate": "2013-08-09T20:45:29.147", "CommentCount": "0", "CreationDate": "2013-08-09T20:45:29.147", "ParentId": "18155239", "Score": "6", "OwnerUserId": "583833"}, "18155239": {"ViewCount": "458", "Body": "<p><code>std::array</code> in C++11 is a useful class that provides a C++ Container interface over a C stack array.</p>\n<p>But why does <code>std::array</code> not have the typical fill constructor that most containers have? Instead, it has a method <code>fill</code>.</p>\n<p>Is there some reason why <code>std::array</code> is unique among STL containers in this regard?</p>\n", "Title": "Design decision regarding std::array fill", "CreationDate": "2013-08-09T20:37:09.207", "LastActivityDate": "2013-08-10T02:40:28.820", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-08-10T02:40:28.820", "LastEditorUserId": "815724", "Id": "18155239", "Score": "11", "OwnerUserId": "469408", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "18155463": {"Id": "18155463", "PostTypeId": "2", "Body": "<p>Everybody's explained the \"why\" pretty well I think, so I'll just put up a workaround suggestion, which should compile to be just as good as a native constructor:</p>\n<pre><code>template&lt; typename T, std::size_t n &gt; std::array&lt;T,n&gt; filledArray( const T&amp; v ) {\n    std::array&lt;T,n&gt; r;\n    r.fill( v );\n    return r;\n}\n\nauto arr = filledArray&lt;int,4&gt;( 7 );\n</code></pre>\n", "LastActivityDate": "2013-08-09T20:51:23.460", "CommentCount": "5", "CreationDate": "2013-08-09T20:51:23.460", "ParentId": "18155239", "Score": "3", "OwnerUserId": "1180785"}});