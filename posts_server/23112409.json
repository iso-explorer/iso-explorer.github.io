post_cb({"bq_ids": {"n4140": {"so_23112409_23114645_1": {"length": 10, "quality": 1.0, "section_id": 51}}, "n3337": {"so_23112409_23114645_1": {"length": 10, "quality": 1.0, "section_id": 46}}, "n4659": {"so_23112409_23114645_1": {"length": 10, "quality": 1.0, "section_id": 52}}}, "23114645": {"Id": "23114645", "PostTypeId": "2", "Body": "<p>This cannot be done portably:</p>\n<blockquote>\n<p id=\"so_23112409_23114645_0\"><strong>[temp]/4</strong></p>\n<p id=\"so_23112409_23114645_1\">A template, a template explicit specialization, and a class template partial specialization shall not have C linkage.</p>\n</blockquote>\n<p>Note that this also prevents you from taking a pointer to that function letting Haskell call the function via this pointer: It is not guaranteed that e.g. the calling convention of a C++ function (in the C++ program) is the same that Haskell assumes for the function pointer it gets.</p>\n<p>What can be done portably is to export a single <code>extern \"C\"</code> function that translates between C and C++ language linkage. You can pass function pointers or other kinds of identifiers to Haskell, and Haskell calls this single C function passing the identifier of the function it actually wants to call:</p>\n<pre><code>std::map&lt;int, void(*)(int32_t)&gt; functions;\n\nextern \"C\" interface_fct(int id, int32_t arg)\n{\n    functions[id](arg);\n}\n</code></pre>\n<p>This of course is not very useful for functions with different parameter sets.</p>\n<p>You could write something similar to <code>va_args</code> (but safer) to pass arbitrary arguments, but it might be more useful to write something nonportable.</p>\n", "LastActivityDate": "2014-04-16T16:06:41.087", "CommentCount": "1", "CreationDate": "2014-04-16T16:06:41.087", "ParentId": "23112409", "Score": "2", "OwnerUserId": "420683"}, "23112409": {"ViewCount": "142", "Body": "<p>I'm creating Haskell bindings for a C library. However, I want to adapt the calling conventions of the library to something more appropriate for Haskell so I've created a template class which has a static method that invokes the correct method when you use it the following way:</p>\n<pre><code>Wrap&lt;decltype(&amp;libraryFunction), &amp;libraryFunction&gt;::call(...);\n</code></pre>\n<p>Where <code>...</code> denotes the arguments. This is great, the compiler has generated the wrapper code for me apparently. I can even take the address of this function using the <code>&amp;</code> operator so it's apparently just a regular function.</p>\n<p>However, Haskell cannot use C++ templates so what I'd like to do is to explicitly instantiate this template for the required functions and export them as regular C function which I can reference from Haskell. I know I could just make stubs that manually invoke this static member function but let's say I don't really feel like it.</p>\n<p>Any ideas on how to do this? Portable or non-portable, I'd like to know if it's possible.</p>\n", "Title": "Export template instantiation as C function", "CreationDate": "2014-04-16T14:29:40.560", "LastActivityDate": "2014-04-16T16:06:41.087", "CommentCount": "8", "PostTypeId": "1", "Id": "23112409", "Score": "0", "OwnerUserId": "436418", "Tags": "<c++><c><templates><c++11><shared-libraries>", "AnswerCount": "1"}});