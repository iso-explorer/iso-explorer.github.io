post_cb({"16428234": {"CommentCount": "5", "AcceptedAnswerId": "16428253", "ClosedDate": "2013-05-07T21:04:34.330", "CreationDate": "2013-05-07T20:44:35.113", "LastActivityDate": "2013-05-07T21:06:35.850", "PostTypeId": "1", "ViewCount": "196", "FavoriteCount": "1", "Title": "Why does this not produce a segmentation fault", "Id": "16428234", "Score": "-1", "Body": "<p>This is a for loop in c++. I dont understand why it does not give a segmentation fault on execution.</p>\n<pre><code>int main() \n{\n   int arr[5];\n   for (int x = 0; x &lt;= 5; x++)\n       {\n           arr[x] = x;\n       }\n   return 0; \n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "2359861", "AnswerCount": "3"}, "16428358": {"ParentId": "16428234", "CommentCount": "0", "Body": "<p>I think Andy Prowl has already answered best in saying that it's undefined behaviour.</p>\n<p>But if you're interested in the specifics of why it doesn't crash, on my compiler at least, the variable <code>x</code> is allocated in the position on the stack immediately following the array. When you assign <code>x</code> to <code>arr[5]</code>, you're really just assigning <code>x</code> back to itself.</p>\n<p>Obviously this may be different from one compiler to the next. Just thought you might be interested to know at least what one particular compiler is doing.</p>\n", "OwnerUserId": "2334192", "PostTypeId": "2", "Id": "16428358", "Score": "1", "CreationDate": "2013-05-07T20:53:04.853", "LastActivityDate": "2013-05-07T20:53:04.853"}, "16428253": {"ParentId": "16428234", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>This is <strong>undefined behavior</strong>. Undefined behavior means that <em>anything</em> can happen, including:</p>\n<ul>\n<li>segmentation fault</li>\n<li>no error at all</li>\n<li>inconsistent output</li>\n<li>formatting of hard drive</li>\n<li>... (whatever)</li>\n</ul>\n<p>To get a bit more formal, this is how the C++11 Standard defines undefined behavior:</p>\n<blockquote>\n<p id=\"so_16428234_16428253_0\">behavior for which this International Standard imposes no requirements\n  [ <em>Note</em>: Undefined behavior may be expected when this International Standard omits any explicit definition of\n  behavior or when a program uses an erroneous construct or erroneous data. <strong>Permissible undefined behavior\n  ranges from ignoring the situation completely with unpredictable results, to behaving during translation or\n  program execution in a documented manner characteristic of the environment</strong> (with or without the issuance of\n  a diagnostic message), <strong>to terminating a translation or execution</strong> (with the issuance of a diagnostic message).\n  Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed.\n  \u2014end note ]</p>\n</blockquote>\n<p>Concerning the reason why doing <code>x[5]</code> is indeed undefined behavior, that's because <code>x[5]</code> is equivalent to <code>*(x + 5)</code> (see paragraph 8.3.4/6), and paragraph 5.3.1/1 about the unary operator <code>*</code> specifies:</p>\n<blockquote>\n<p id=\"so_16428234_16428253_1\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an\n  object type, or a pointer to a function type and <strong>the result is an lvalue referring to the object or function\n  to which the expression points</strong>. If the type of the expression is \u201cpointer to T,\u201d the type of the result is\n  \u201cT.\u201d [...]</p>\n</blockquote>\n<p>But since <code>x + 5</code> does not point to any object, and the above paragraph does not specify what the result of dereferencing such a pointer should be, the previously quoted sentence applies:</p>\n<blockquote>\n<p id=\"so_16428234_16428253_2\">[...] Undefined behavior may be expected when this International Standard omits any explicit definition of behavior [...]</p>\n</blockquote>\n<p>Which means that <code>x[5]</code> is undefined behavior.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-05-07T21:06:35.850", "Id": "16428253", "Score": "18", "CreationDate": "2013-05-07T20:45:30.743", "LastActivityDate": "2013-05-07T21:06:35.850"}, "bq_ids": {"n4140": {"so_16428234_16428253_0": {"section_id": 5768, "quality": 0.9166666666666666, "length": 55}, "so_16428234_16428253_1": {"section_id": 6064, "quality": 0.92, "length": 23}, "so_16428234_16428253_2": {"section_id": 5768, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_16428234_16428253_0": {"section_id": 5541, "quality": 0.9166666666666666, "length": 55}, "so_16428234_16428253_1": {"section_id": 5832, "quality": 0.92, "length": 23}, "so_16428234_16428253_2": {"section_id": 5541, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_16428234_16428253_0": {"section_id": 7225, "quality": 0.9166666666666666, "length": 55}, "so_16428234_16428253_2": {"section_id": 7225, "quality": 0.9090909090909091, "length": 10}, "so_16428234_16428253_1": {"section_id": 7560, "quality": 0.92, "length": 23}}}, "16428332": {"ParentId": "16428234", "CommentCount": "2", "Body": "<p>A segmentation fault occurs when a user program attempts to do one of :</p>\n<ul>\n<li>Access a part of the memory it is not allowed to, such as system memory</li>\n<li>Access a part of the memory which does not exist (aka out of bounds)</li>\n</ul>\n<p>So you are correct in realizing that you are reaching out of bounds in your array, and on the last loop iteration you are accessing something outside of your program's allocated memory. It just so happens that the piece of memory is not system memory and it exists, so it lets you read it.</p>\n<p>If you ran this bit of code enough times you should eventually get a segmentation fault because it will happen to be placed right up against system memory or at the end of memory.</p>\n", "OwnerUserId": "1937630", "PostTypeId": "2", "Id": "16428332", "Score": "3", "CreationDate": "2013-05-07T20:51:31.203", "LastActivityDate": "2013-05-07T20:51:31.203"}});