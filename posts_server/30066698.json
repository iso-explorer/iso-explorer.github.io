post_cb({"bq_ids": {"n4140": {"so_30066698_30066794_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 188}, "so_30066698_30066794_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 215}}, "n3337": {"so_30066698_30066794_1": {"length": 9, "quality": 0.75, "section_id": 182}, "so_30066698_30066794_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 209}}, "n4659": {"so_30066698_30066794_1": {"length": 9, "quality": 0.75, "section_id": 193}, "so_30066698_30066794_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 223}}}, "30066794": {"Id": "30066794", "PostTypeId": "2", "Body": "<p>Within the variadic function template <code>f()</code>, the <code>f</code> in the recursive call is a dependent name due to [temp.dep], emphasis mine:</p>\n<blockquote>\n<p id=\"so_30066698_30066794_0\">In an expression of the\n  form:</p>\n<pre><code>postfix-expression ( expression-listopt)\n</code></pre>\n<p id=\"so_30066698_30066794_1\">where the <em>postfix-expression</em> is an <em>unqualified-id</em>, the <em>unqualified-id</em> denotes a dependent name if<br>\n  (1.1) \u2014 any of the expressions in the <em>expression-list</em> is <strong>a pack expansion</strong> (14.5.3),</br></p>\n</blockquote>\n<p>And, according to [temp.dep.res], emphasis mine:</p>\n<blockquote>\n<p id=\"so_30066698_30066794_2\">In resolving dependent names, names from the following sources are considered:<br>\n  (1.1) \u2014 Declarations that are visible at the <strong>point of definition</strong> of the template.<br>\n  (1.2) \u2014 Declarations from namespaces associated with the types of the function arguments both from the\n  instantiation context (14.6.4.1) and from the definition context.</br></br></p>\n</blockquote>\n<p>There is only one declaration of <code>f</code> that is visible at the point of definition of <code>template &lt;typename... Args&gt; void f(int, int, Args...)</code> and that is itself. The second point doesn't apply here because all of your arguments are <code>int</code>s and there's no associated namespaces for fundamental types. Since that function template cannot be called with a single argument, you get a compile error.</p>\n<p>The solution is to restructure your code so that your base case is visible at the point of definition, that is:</p>\n<pre><code>// this can be just the declaration\nvoid f(int, int ) { /* ... */ } \n\ntemplate &lt;typename... Args&gt;\nvoid f(int a, int b, Args... args) \n{ \n    std::cout &lt;&lt; b &lt;&lt; '\\n';\n    f(a, args...); // now this will call f(int, int) \n                   // if sizeof...(Args) == 1\n}\n</code></pre>\n<p>An example in which (1.2) applies would be the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename A, typename... Args&gt;\nvoid f(A a, int b, Args... args) { \n    std::cout &lt;&lt; b &lt;&lt; '\\n';\n    f(a, args...);\n}\n\ntemplate &lt;typename A&gt;\nvoid f(A a, int b) {\n    std::cout &lt;&lt; b &lt;&lt; '\\n';     \n}\n\nstruct bar {};\n\nint main() {\n    //f(1,2,3);     // still doesn't compile, same reasoning\n    f(bar{}, 2, 3); // OK. bar is in the global namespace, so declarations\n                    // from the global namespace in both instantiation \n                    // and definition context are considered, which includes\n                    // the second `f`.\n}\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-06T11:19:19.440", "Score": "3", "CreationDate": "2015-05-06T03:10:50.600", "ParentId": "30066698", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2015-05-06T11:19:19.440"}, "30066698": {"ViewCount": "89", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename... Args&gt;\nvoid f(int a, int b, Args... args) { \n    std::cout &lt;&lt; b &lt;&lt; '\\n';\n    f(a, args...);\n}\nvoid f(int, int b) {\n    std::cout &lt;&lt; b &lt;&lt; '\\n';     \n}\n\nint main() {\n  f(1, 2);\n  //f(1, 2, 3);\n}\n</code></pre>\n<p>While <code>f(1, 2)</code> compiles, <code>f(1, 2, 3)</code> does not. From the error message produced by the compiler, I see that <code>f&lt;&gt;</code> is being instantiated somehow. Within the instantiation, the call <code>f(a)</code> is made and thus the error. What makes the compiler not to use <code>f(int, int)</code> but try to instantiate <code>f&lt;&gt;(int, int)</code> during the process of parsing the call <code>f(1, 2, 3)</code>?</p>\n", "AcceptedAnswerId": "30066794", "Title": "Weird overload resolution with variadic function templates", "CreationDate": "2015-05-06T03:01:33.123", "Id": "30066698", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-05-06T11:19:19.440", "Score": "3", "OwnerUserId": "1348273", "Tags": "<c++><c++11><language-lawyer><variadic-templates><overload-resolution>", "AnswerCount": "1"}});