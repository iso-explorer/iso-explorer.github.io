post_cb({"3859517": {"CommentCount": "4", "AcceptedAnswerId": "3859819", "CreationDate": "2010-10-04T22:07:08.490", "LastActivityDate": "2010-10-05T03:08:04.667", "PostTypeId": "1", "ViewCount": "524", "FavoriteCount": "2", "Title": "Type of pointer to member from base class", "Id": "3859517", "Score": "3", "Body": "<p>I have a problem regarding member pointers. The following code fails to compile using both Oracle Solaris Studio 12.2's CC and cygwin GCC 4.3.4 but works with Microsoft Visual C++ 2010:</p>\n<pre><code>struct A {\n  int x;\n};\n\nstruct B : public A {\n};\n\ntemplate&lt;typename T&gt; class Bar {\npublic:\n  template&lt;typename M&gt; void foo(M T::*p);\n};\n\nint main(int, char *[]) {\n    Bar&lt;B&gt; bbar;\n    bbar.foo(&amp;B::x);\n    return 0;\n}\n</code></pre>\n<p>At the next to last line both compilers mentioned above fail to find a match for <code>Bar&lt;B&gt;::foo(int A::*)</code>. I wrote a simple test to confirm that the type of the expression <code>&amp;B::x</code> is actually <code>int A::*</code>:</p>\n<pre><code>// ...\n\nstatic void foo(int A::*p) {\n  std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\n\nstatic void foo(int B::*p) {\n  std::cout &lt;&lt; \"B\" &lt;&lt; std::endl;\n}\n\nint main(int, char *[]) {\n    foo(&amp;B::x);  // prints \"A\", even on MS VC++ 2010 \n    return 0;\n}\n</code></pre>\n<p>The following workaround works with GCC (not tested with Oracle CC yet) but fails with VC++ due to ambiguity:</p>\n<pre><code>template&lt;typename T&gt; class Bar {\npublic:\n  template&lt;typename M&gt; void foo(M T::*p);\n  template&lt;typename M, typename _T_base&gt; inline void foo(M _T_base::*p) {\n      foo(static_cast&lt;M T::*&gt;(p));\n  }\n};\n</code></pre>\n<p>\n<em>My question:\nWhich behavior is correct? Apparently VC++ does an implicit upcast from <code>int A::*</code> to <code>int B::*</code> to satisfy the call to the member function template, shouldn't the other two compilers consider doing the same?</em></p>\n", "Tags": "<c++><member-pointers>", "OwnerUserId": "466263", "AnswerCount": "1"}, "3859819": {"ParentId": "3859517", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A conversion from <code>int A::*</code> to <code>int B::*</code> is allowed, and that's not the problem.  The problem is in template argument deduction, as you can see if you try the following program which supplies a template argument <code>&lt;int&gt;</code> for <code>B::foo</code> and compiles, and a non-member function <code>foo2</code> which produces the same error as <code>B::foo</code> did before.</p>\n<pre><code>struct A {\n  int x;\n};\n\nstruct B : public A {\n};\n\ntemplate &lt;typename T&gt; class Bar {\npublic:\n  template&lt;typename M&gt; void foo(M T::*p);\n};\n\ntemplate&lt;typename M&gt; void foo2(M B::*p);\n\nint main(int, char*[]) {\n  Bar&lt;B&gt; bbar;\n  bbar.foo&lt;int&gt;(&amp;B::x);\n  foo2(&amp;B::x); // error, but foo2&lt;int&gt;(&amp;B::x) would work.\n  return 0;\n}\n</code></pre>\n<p>I think this situation is not covered by the cases where the compiler is supposed to deduce the template argument <code>&lt;int&gt;</code> on its own.  14.8.2.1p3:</p>\n<blockquote>\n<p id=\"so_3859517_3859819_0\">In general, the deduction process attempts to find template argument values that will make the deduced A identical to A (after the type A is transformed as described above). However, there are three cases that allow a difference:</p>\n</blockquote>\n<ul>\n<li>If the original P is a reference type, the deduced A (i.e., the type referred to by the reference) can be more cv-qualified than A. </li>\n<li>A can be another pointer or pointer to member type that can be converted to the deduced A via a qualification conversion (conv.qual). </li>\n<li>If P is a class, and P has the form template-id, then A can be a derived class of the deduced A. Likewise, if P is a pointer to a class of the form template-id, A can be a pointer to a derived class pointed to by the deduced A.</li>\n</ul>\n<p>Here \"P\" is the template function's argument type: <code>M B::*p</code>, where template type parameter <code>M</code> is to be determined.  \"A\" is the type of the actual argument: <code>int A::*</code>.  P and A are certainly not a reference or a class, and the sort of pointer-to-member conversion we would need for this to work is not a qualification conversion (which describes only const/volatile manipulations like <code>X*</code> to <code>const X*</code> or <code>int X::*</code> to <code>const int X::*</code>).</p>\n<p>So the template argument cannot be deduced, and you should add the <code>&lt;int&gt;</code> explicit template parameter to your code.</p>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2010-10-04T23:57:43.747", "Id": "3859819", "Score": "5", "CreationDate": "2010-10-04T23:11:48.150", "LastActivityDate": "2010-10-04T23:57:43.747"}, "bq_ids": {"n4140": {"so_3859517_3859819_0": {"section_id": 305, "quality": 1.0, "length": 23}}, "n3337": {"so_3859517_3859819_0": {"section_id": 296, "quality": 1.0, "length": 23}}, "n4659": {"so_3859517_3859819_0": {"section_id": 312, "quality": 1.0, "length": 23}}}});