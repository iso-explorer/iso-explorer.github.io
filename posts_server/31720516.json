post_cb({"31720516": {"ViewCount": "885", "Body": "<p>I have a compile-time counter that I used for years, inspired by <a href=\"https://stackoverflow.com/questions/6166337/does-c-support-compile-time-counters\">these answers</a>. It works in C++03/11, and as far as I tested, relatively well on major compilers:</p>\n<pre><code>namespace meta\n{\n    template&lt;unsigned int n&gt; struct Count { char data[n]; };\n    template&lt;int n&gt; struct ICount : public ICount&lt;n-1&gt; {};\n    template&lt;&gt; struct ICount&lt;0&gt; {};\n\n    #define MAX_COUNT 64\n    #define MAKE_COUNTER( _tag_ ) \\\n        static ::meta::Count&lt;1&gt; _counter ## _tag_ (::meta::ICount&lt;1&gt;)\n    #define GET_COUNT( _tag_ ) \\\n        (sizeof(_counter ## _tag_ (::meta::ICount&lt;MAX_COUNT + 1&gt;())) - 1)\n    #define INC_COUNT( _tag_ ) \\\n        static ::meta::Count&lt;GET_COUNT(_tag_) + 2&gt; _counter ## _tag_ (::meta::ICount&lt;2 + GET_COUNT(_tag_)&gt;)\n}\n</code></pre>\n<p>The following test <a href=\"http://coliru.stacked-crooked.com/a/54c87634a8886a75\" rel=\"nofollow noreferrer\">compiles and runs perfectly</a> (expected output is <code>0 1 2 3</code>):</p>\n<pre><code>struct Test\n{\n    MAKE_COUNTER( uu );\n\n    static const unsigned int a = GET_COUNT( uu );\n    INC_COUNT( uu );\n    static const unsigned int b = GET_COUNT( uu );\n    INC_COUNT( uu );\n    static const unsigned int c = GET_COUNT( uu );\n    INC_COUNT( uu );\n    static const unsigned int d = GET_COUNT( uu );\n\n};\n\ntemplate&lt;typename T&gt;\nvoid test()\n{\n    std::cout &lt;&lt; T::a &lt;&lt; \" \" &lt;&lt; T::b &lt;&lt; \" \" &lt;&lt; T::c &lt;&lt; \" \" &lt;&lt; T::d &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    test&lt;Test&gt;();\n}\n</code></pre>\n<p>However, I found a case were I see a very strange behavior happening with clang and gcc. If you change <code>Test</code> to be a template struct, taking an int for example (<code>template&lt;int&gt; struct Test</code>, and <code>test&lt;Test&lt;42&gt; &gt;()</code> in <code>main</code>), <a href=\"http://coliru.stacked-crooked.com/a/66cbfeaf3669fef5\" rel=\"nofollow noreferrer\">clang and gcc both fail to compile</a>, complaining that I am redefining the counter function (while msvc compiles it without problems). For some reason the compiler fails to compute a sizeof in a template class.</p>\n<p>clang find the error at the third <code>INC_COUNT</code>, while gcc find it at the second one.</p>\n<p>I manually expanded this macro, and:</p>\n<ul>\n<li><p>for clang, it gives</p>\n<pre><code>static ::meta::Count&lt;GET_COUNT(uu)+2&gt; _counteruu(::meta::ICount&lt;(sizeof(_counteruu(::meta::ICount&lt;65&gt;())) - 1)+2&gt;);\n//                                                              ^                                            ^\n</code></pre>\n<p>removing the underlined parentheses solves the issue.</p></li>\n<li><p>for gcc: moving the <code>+2</code> before the <code>sizeof</code> is the only work-around</p></li>\n</ul>\n<p>The sad note is that these workarounds seem not to work when included in the macros. It's like the compiler just forgets how to compute the result of sizeof after some time...</p>\n<p>Why is this happening ? Am I doing something wrong, or is it just compiler bugs (since clang and gcc don't even report the same line) ?</p>\n<p><em>Note: I know <a href=\"https://stackoverflow.com/questions/23525701/template-vs-non-template-class-different-behavior-across-compilers\">there is a gcc bug about this counter</a>. The question is not about this bug.</em></p>\n", "Title": "Compile-time counter in template class", "CreationDate": "2015-07-30T09:52:14.250", "LastActivityDate": "2015-07-30T12:14:47.277", "CommentCount": "1", "LastEditDate": "2017-05-23T11:53:35.837", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "31720516", "Score": "5", "OwnerUserId": "1261432", "Tags": "<c++><templates><gcc><clang>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31720516_31723214_0": {"length": 15, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_31720516_31723214_0": {"length": 15, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_31720516_31723214_0": {"length": 15, "quality": 1.0, "section_id": 8568}}}, "31723214": {"Id": "31723214", "PostTypeId": "2", "Body": "<p>Your code is ill-formed, no diagnostic required. \u00a73.3.7/1, second bullet point<sup>1</sup>:</p>\n<blockquote>\n<p id=\"so_31720516_31723214_0\">A name <code>N</code> used in a class <code>S</code> shall refer to the same declaration in its\n  context and when re-evaluated in the completed scope of <code>S</code>. No\n  diagnostic is required for a violation of this rule.</p>\n</blockquote>\n<p>You use overload resolution to select the appropriate overload of <code>_counteruu</code>. However, in the initializer of e.g. <code>a</code>, an overload (=declaration) is selected that wouldn't be selected if we were to perform overload resolution at the end of <code>Test</code>, such as in the initializer of <code>d</code>. Hence <code>_counteruu</code> refers to another, distinct declaration when re-evaluated in the completed scope of <code>Test</code>.</p>\n<p>To show up which calls exactly I'm referring to, consider the preprocessed definition of <code>Test</code>:</p>\n<pre><code>struct Test\n{\n    // (1)\n    static ::meta::Count&lt;1&gt; _counteruu (::meta::ICount&lt;1&gt;);\n    static const unsigned int a = (sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1);\n    // (2)\n    static ::meta::Count&lt;(sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1) + 2&gt; _counteruu (::meta::ICount&lt;(sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1) + 2&gt;);\n    static const unsigned int b = (sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1);\n    // (3)\n    static ::meta::Count&lt;(sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1) + 2&gt; _counteruu (::meta::ICount&lt;(sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1) + 2&gt;);\n    static const unsigned int c = (sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1);\n    // (4)\n    static ::meta::Count&lt;(sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1) + 2&gt; _counteruu (::meta::ICount&lt;(sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1) + 2&gt;);\n    static const unsigned int d = (sizeof(_counteruu (::meta::ICount&lt;64 + 1&gt;())) - 1);\n\n};\n</code></pre>\n<p>Simplification yields</p>\n<pre><code>struct Test\n{\n    // (1)\n    static ::meta::Count&lt;1&gt; _counteruu (::meta::ICount&lt;1&gt;);\n    static const unsigned int a = (sizeof(_counteruu (::meta::ICount&lt;65&gt;())) - 1);\n    // (2)\n    static ::meta::Count&lt;2&gt; _counteruu (::meta::ICount&lt;2&gt;);\n    static const unsigned int b = (sizeof(_counteruu (::meta::ICount&lt;65&gt;())) - 1);\n    // (3)\n    static ::meta::Count&lt;3&gt; _counteruu (::meta::ICount&lt;3&gt;);\n    static const unsigned int c = (sizeof(_counteruu (::meta::ICount&lt;65&gt;())) - 1);\n    // (4)\n    static ::meta::Count&lt;4&gt; _counteruu (::meta::ICount&lt;4&gt;);\n    static const unsigned int d = (sizeof(_counteruu (::meta::ICount&lt;65&gt;())) - 1);\n};\n</code></pre>\n<p>We can clearly see how the mechanism works now: Overload resolution will prefer the last added overload when <code>ICount&lt;</code><em>some sufficiently large number</em><code>&gt;</code> is passed due to the way derived-to-base conversions are ranked. However, the call in the initializer of <code>a</code> will select the first overload; But re-evaluating this initializer would select the last one. </p>\n<hr>\n<p><sup>1</sup> This bullet point existed in C++03 as well, but in \u00a73.3.6.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-07-30T12:14:47.277", "Score": "6", "CreationDate": "2015-07-30T12:00:07.623", "ParentId": "31720516", "CommentCount": "1", "OwnerUserId": "3647361", "LastEditDate": "2015-07-30T12:14:47.277"}});