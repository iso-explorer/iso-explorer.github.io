post_cb({"bq_ids": {"n4140": {"so_19069681_19069981_4": {"length": 18, "quality": 1.0, "section_id": 6182}, "so_19069681_19069981_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 6009}, "so_19069681_19069981_1": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_19069681_19069981_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 5811}}, "n3337": {"so_19069681_19069981_4": {"length": 18, "quality": 1.0, "section_id": 5943}, "so_19069681_19069981_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 5777}, "so_19069681_19069981_1": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_19069681_19069981_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 5584}}, "n4659": {"so_19069681_19069981_4": {"length": 18, "quality": 1.0, "section_id": 7684}, "so_19069681_19069981_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 7508}, "so_19069681_19069981_1": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_19069681_19069981_0": {"length": 37, "quality": 0.8409090909090909, "section_id": 7272}}}, "19069896": {"Id": "19069896", "PostTypeId": "2", "Body": "<p>I don't think sequencing is relevant to your situation. The expression <code>++i++</code> is grouped as <code>++(i++)</code>, so:</p>\n<ul>\n<li><p>If <code>i</code> is a built-in type, then this is invalid, since <code>i++</code> is an rvalue.</p></li>\n<li><p>If <code>i</code> is of user-defined type and the operators are overloaded, this is a nested function call, such as <code>T::operator++(T::operator++(i), 0)</code>, and function arguments are evaluated before the function call is evaluated.</p></li>\n</ul>\n", "LastActivityDate": "2013-09-28T17:46:01.423", "CommentCount": "5", "CreationDate": "2013-09-28T17:46:01.423", "ParentId": "19069681", "Score": "3", "OwnerUserId": "596781"}, "19069981": {"Id": "19069981", "PostTypeId": "2", "Body": "<p>The UB in those cases is based on [intro.execution]/15</p>\n<blockquote>\n<p id=\"so_19069681_19069981_0\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [...] The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>For <code>++(++i)</code>: [expr.pre.incr]/1 states that <code>++i</code> is defined as <code>i+=1</code>. This leads to [expr.ass]/1, which says</p>\n<blockquote>\n<p id=\"so_19069681_19069981_1\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>Therefore, for <code>++(++i)</code>, equivalent to <code>(i+=1)+=1</code>, the inner assignment is sequenced before the outer assignment, and we have no UB.</p>\n<hr>\n<p>[intro.execution]/15 has an example of UB:</p>\n<blockquote id=\"so_19069681_19069981_2\">\n<pre><code>i = i++ + 1; // the behavior is undefined\n</code></pre>\n</blockquote>\n<p>The case here is a bit different (thanks to <a href=\"https://stackoverflow.com/users/1639256/oktalist\">Oktalist</a> for pointing out a pre/postfix mistake here). [expr.post.incr]/1 describes the effects of <em>postfix</em> increment. It states:</p>\n<blockquote>\n<p id=\"so_19069681_19069981_3\">The value computation of the <code>++</code> expression is sequenced before the modification of the operand object.</p>\n</blockquote>\n<p>However, there is no requirement on the sequencing of the <em>side effect</em> (the modification of <code>i</code>). Such a requirement could also be imposed by the assignment-expression. But the assignment-expression only requires the <em>value computations</em> (but not the side effects) of the operands to be sequenced before the assignment. Therefore, the two modifications via <code>i = ..</code> and <code>i++</code> are unsequenced, and we get undefined behaviour.</p>\n<p>N.B. <code>i = (i = 1);</code> does <em>not</em> have the same problem: The inner assignment guarantees the side effect of <code>i = 1</code> is sequenced before the value computation of the same expression. And the value is required for the outer assignment, which guarantees that it (the value computation of the right operand <code>(i = 1)</code>) is sequenced before the side effect of the outer assignment. Similarly, <code>i = ++i + 1;</code> (equivalent to <code>i = (i+=1) + 1;</code>) has defined behaviour.</p>\n<hr>\n<p>The comma operator is an example where the side effects are sequenced; [expr.comma]/1</p>\n<blockquote>\n<p id=\"so_19069681_19069981_4\">Every value computation and side effect associated with the left expression is sequenced before every value computation and side effect associated with the right expression.</p>\n</blockquote>\n<p>[intro.execution]/15 includes the example <code>i = 7, i++, i++;</code> (read: <code>(i=7), i++, i++;</code>), which is defined behaviour (<code>i</code> becomes <code>9</code>).</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-28T23:50:29.973", "Score": "6", "CreationDate": "2013-09-28T17:55:45.313", "ParentId": "19069681", "CommentCount": "6", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T10:26:36.733"}, "19069681": {"ViewCount": "397", "Body": "<p>With the new college year upon us.<br>\nWe have started to receive the standard why does <code>++ i ++</code> not work as expected questions.</br></p>\n<p>After just answering one of these type of questions I was told that the new C++11 standard has changed and this is no longer undefined behavior. I have heard that <code>sequence points</code> have been replaced by <code>sequenced before</code> and <code>sequenced after</code> but have not read deep (or at all) into the subject.</p>\n<p>So the question I was just answering had:</p>\n<pre><code>int i = 12;\nk = ++ (++ i);\n</code></pre>\n<p>So the question is:</p>\n<p>How has the sequence points changes in C++11 and how does it affect questions like the above. Is it still undefined behavior or is this now well defined?</p>\n", "Title": "New Sequence Points in C++11", "CreationDate": "2013-09-28T17:23:27.203", "LastActivityDate": "2013-09-28T23:50:29.973", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-09-28T17:49:55.570", "LastEditorUserId": "14065", "Id": "19069681", "Score": "5", "OwnerUserId": "14065", "Tags": "<c++><c++11>", "AnswerCount": "2"}});