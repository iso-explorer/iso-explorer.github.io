post_cb({"46331733": {"Id": "46331733", "PostTypeId": "2", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator\" rel=\"noreferrer\">comma operator</a> (<a href=\"http://en.cppreference.com/w/c/language/operator_other#Comma_operator\" rel=\"noreferrer\">C documentation</a>, says something very similar) has no such guarantees.</p>\n<blockquote>\n<p id=\"so_46331625_46331733_0\">In a comma expression <code>E1, E2</code>, the expression E1 is evaluated, its result is discarded ..., and its side effects are completed before evaluation of the expression E2 begins</p>\n</blockquote>\n<p><sup>irrelevant information omitted</sup></p>\n<p>To put it simply, <code>E1</code> will be evaluated, although the compiler might optimize it away by the as-if rule if it is able to determine that there are no side-effects.</p>\n", "LastEditorUserId": "1896169", "LastActivityDate": "2017-09-20T21:17:21.443", "Score": "12", "CreationDate": "2017-09-20T21:04:09.573", "ParentId": "46331625", "CommentCount": "0", "LastEditDate": "2017-09-20T21:17:21.443", "OwnerUserId": "1896169"}, "46331907": {"Id": "46331907", "PostTypeId": "2", "Body": "<p>The left operand of the comma operator is a <em>discarded-value expression</em></p>\n<blockquote>\n<p id=\"so_46331625_46331907_0\"><strong>5 Expressions</strong><br>\n  11 In some contexts, an expression only appears for its side effects. Such an expression is called a discarded-value\n  expression. The expression is evaluated and its value is discarded.\n  [...]</br></p>\n</blockquote>\n<p>There are also <em>unevaluated operands</em> which, as the name implies, are not evaluated.</p>\n<blockquote>\n<p id=\"so_46331625_46331907_1\">8  In some contexts, unevaluated operands appear (5.2.8, 5.3.3, 5.3.7,\n  7.1.6.2). An unevaluated operand is not evaluated. An unevaluated operand is considered a full-expression. [...]</p>\n</blockquote>\n<p>Using a discarded-value expression in your use case is undefined behavior, but using an unevaluated operand is not.</p>\n<p>Using <code>sizeof</code> for example would not cause UB because it takes an unevaluated operand.</p>\n<pre><code>#define STR_MEMBER(S,X) (sizeof(S::X), #X)\n</code></pre>\n<p><code>sizeof</code> is preferable to <code>offsetof</code>, because <code>offsetof</code> can't be used for static members and classes that are not standard-layout:</p>\n<blockquote>\n<p id=\"so_46331625_46331907_2\"><strong>18 Language support library</strong><br>\n  4  The macro offsetof(type, member-designator) accepts a restricted\n  set of type arguments in this International Standard. If type is not a\n  standard-layout class (Clause 9), the results are undefined. [...] The result of applying the offsetof macro to a field that\n  is a static data member or a function member is undefined. [...]</br></p>\n</blockquote>\n", "LastEditorUserId": "3435400", "LastActivityDate": "2017-09-20T21:58:12.007", "Score": "2", "CreationDate": "2017-09-20T21:16:36.940", "ParentId": "46331625", "CommentCount": "5", "LastEditDate": "2017-09-20T21:58:12.007", "OwnerUserId": "3435400"}, "46331805": {"Id": "46331805", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46331625_46331805_0\">Gcc/g++ 6.3 and 4.9.2 never produced that dangerous code, even with -O0, as if they were always able to \u201csee\u201d that the evaluation hasn't side effects and so it can be skipped.</p>\n</blockquote>\n<p>clang will produce code which raises an error if you pass it the <code>-fsanitize=undefined</code> option. Which should answer your question: at least one major implementation's developers clearly consider the code as having undefined behaviour. And they are correct.</p>\n<blockquote>\n<p id=\"so_46331625_46331805_1\">Suggestions about other possible \u201cfixes\u201d are welcome, too.</p>\n</blockquote>\n<p>I would look for something which is guaranteed not to evaluate the expression. Your suggestion of <code>offsetof</code> does the job, but may occasionally cause code to be rejected that would otherwise be accepted, such as when <code>X</code> is <code>a.b</code>. If you want that to be accepted, my thought would be to use <code>sizeof</code> to force an expression to remain unevaluated.</p>\n", "LastActivityDate": "2017-09-20T21:08:34.740", "Score": "3", "CreationDate": "2017-09-20T21:08:34.740", "ParentId": "46331625", "CommentCount": "1", "OwnerUserId": "743382"}, "bq_ids": {"n4140": {"so_46331625_46331907_1": {"length": 9, "quality": 0.6, "section_id": 5941}, "so_46331625_46331907_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 5944}, "so_46331625_46331907_2": {"length": 23, "quality": 0.71875, "section_id": 6706}, "so_46331625_46331733_0": {"length": 9, "quality": 0.6, "section_id": 5811}}, "n3337": {"so_46331625_46331733_0": {"length": 9, "quality": 0.6, "section_id": 5584}, "so_46331625_46331907_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 5715}, "so_46331625_46331907_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 5712}, "so_46331625_46331907_2": {"length": 23, "quality": 0.71875, "section_id": 6461}}, "n4659": {"so_46331625_46331907_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 7429}, "so_46331625_46331907_1": {"length": 9, "quality": 0.6, "section_id": 7425}, "so_46331625_46331907_2": {"length": 19, "quality": 0.59375, "section_id": 8181}}}, "46331742": {"Id": "46331742", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46331625_46331742_0\">Is there anything in the C and C++ languages standard which guarantees that compilers will always avoid actual evaluation of the left operand of the comma operator ?</p>\n</blockquote>\n<p>It's the opposite. The standard guarantees that the left operand IS evaluated (really it does, there aren't any exceptions). The result is discarded.</p>\n<hr>\n<p><em>Note:</em> for lvalue expressions, \"evaluate\" does not mean \"access the stored value\".  Instead, it means to work out where the designated memory location is.  The other code encompassing the lvalue expression may or may not then go on to access the memory location.   The process of reading from the memory location is known as \"lvalue conversion\" in C, or \"lvalue to rvalue conversion\" in C++.</p>\n<p>In C++ a discarded-value expression (such as the left operand of the comma operator) only has lvalue to rvalue conversion performed on it if it is <code>volatile</code> and also meets some other criteria (see C++14 [expr]/11 for detail). In C lvalue conversion <em>does</em> occur for expressions whose result is not used (C11 6.3.2.1/2).</p>\n<p>In your example, it is moot whether or not lvalue conversion happens. In both languages <code>X-&gt;Y</code>, where <code>X</code> is a pointer, is defined as <code>(*X).Y</code>; in C the act of applying <code>*</code> to a null pointer already causes undefined behaviour (C11 6.5.3/3), and in C++ the <code>.</code> operator is only defined for the case when the left operand actually designates an object (C++14 [expr.ref]/4.2).  </p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2017-09-20T22:29:30.740", "Score": "17", "CreationDate": "2017-09-20T21:04:31.173", "ParentId": "46331625", "CommentCount": "11", "LastEditDate": "2017-09-20T22:29:30.740", "OwnerUserId": "1505939"}, "46333895": {"Id": "46333895", "PostTypeId": "2", "Body": "<p>The language doesn't need to say anything about \"actual execution\" because of the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow noreferrer\">as-if rule</a>.  After all, with no side effects how could you tell whether the expression is evaluated?  (Looking at the assembly or setting breakpoints doesn't count; that's not part of execution of the program, which is all the language describes.)</p>\n<p>On the other hand, dereferencing a null pointer is undefined behavior, so the language says nothing at all about what happens.  You can't expect as-if to save you: as-if is a <em>relaxation</em> of otherwise-plausible restrictions on the implementation, and undefined behavior is a relaxation of <em>all</em> restrictions on the implementation.  There is therefore no \"conflict\" between \"this doesn't have side effects, so we can ignore it\" and \"this is undefined behavior, so nasal demons\"; they're on the same side!</p>\n", "LastActivityDate": "2017-09-21T01:15:16.770", "Score": "2", "CreationDate": "2017-09-21T01:15:16.770", "ParentId": "46331625", "CommentCount": "3", "OwnerUserId": "8586227"}, "46331625": {"ViewCount": "1628", "Body": "<p>To show the topic I'm going to use C, but the same macro can be used also in C++ (with or without <code>struct</code>), raising the same question.</p>\n<p>I came up with this macro</p>\n<pre><code>#define STR_MEMBER(S,X) (((struct S*)NULL)-&gt;X, #X)\n</code></pre>\n<p>Its purpose is to have strings (<code>const char*</code>) of an existing member of a <code>struct</code>, so that if the member doesn't exist, the compilation fails. A minimal usage example:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct a\n{\n    int value;\n};\n\nint main(void)\n{\n    printf(\"a.%s member really exists\\n\", STR_MEMBER(a, value));\n    return 0;\n}\n</code></pre>\n<p>If <code>value</code> weren't a member of <code>struct a</code>, the code wouldn't compile, and this is what I wanted.</p>\n<p>The comma operator should evaluate the left operand and then discard the result of the expression (if there is one), so that my understanding is that usually this operator is used when the evaluation of the left operand has side effects.</p>\n<p>In this case, however, there aren't (intended) side effects, but of course it works <em>iff</em> the compiler doesn't actually produce the code which evaluates the expression, for otherwise it would access to a <code>struct</code> located at <code>NULL</code> and a <em>segmentation fault</em> would occur.</p>\n<p>Gcc/g++ 6.3 and 4.9.2 never produced that dangerous code, even with <code>-O0</code>, as if they were always able to \u201csee\u201d that the evaluation hasn't side effects and so it can be skipped.</p>\n<p>Adding <code>volatile</code> in the macro (e.g. because accessing that memory address <em>is</em> the desired side effect) was so far the only way to trigger the segmentation fault.</p>\n<p>So the question: <strong>is there anything in the C and C++ languages standard which guarantees that compilers will always avoid actual evaluation of the left operand of the comma operator when the compiler can be sure that the evaluation hasn't side effects?</strong></p>\n<h2>Notes and fixing</h2>\n<p>I am not asking for a judgment about the macro <em>as it is</em> and the opportunity to use it or make it better. For the purpose of this question, the macro is bad <em>if and only if</em> it evokes undefined behaviour \u2014 i.e., <em>if and only if</em> it is risky because compilers are allowed to generate the \u201cevaluation code\u201d even when this hasn't side effects.</p>\n<p>I have already two obvious fixes in mind: \u201creifying\u201d the <code>struct</code> and using <code>offsetof</code>. The former needs an accessible memory area as big as the biggest <code>struct</code> we use as first argument of <code>STR_MEMBER</code> (e.g. maybe a static union could do\u2026). The latter should work flawlessly: it gives an offset we aren't interested in and avoids the access problem \u2014 indeed I'm assuming <em>gcc</em>, because it's the compiler I use (hence the tag), and that its <code>offsetof</code> built-in behaves.</p>\n<p>With the <code>offsetof</code> fix the macro becomes</p>\n<pre><code>#define STR_MEMBER(S,X) (offsetof(struct S,X), #X)\n</code></pre>\n<p>Writing <code>volatile struct S</code> instead of <code>struct S</code> doesn't cause the segfault.</p>\n<p>Suggestions about other possible \u201cfixes\u201d are welcome, too.</p>\n<h2>Added note</h2>\n<p>Actually, the real usage case was in C++ in a static storage <code>struct</code>. This seems to be fine in C++, but as soon as I tried C with a code closer to the original instead of the one boiled for this question, I realized that C isn't happy at all with that:</p>\n<pre><code>error: initializer element is not constant\n</code></pre>\n<p>C wants the struct to be initializable at compile time, instead C++ it's fine with that.</p>\n", "AcceptedAnswerId": "46331733", "Title": "In the comma operator, is the left operand guaranteed not to be actually executed if it hasn't side effects?", "CreationDate": "2017-09-20T20:56:21.680", "Id": "46331625", "CommentCount": "29", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-09-20T22:14:29.603", "LastEditorUserId": "354803", "LastActivityDate": "2017-09-21T01:15:16.770", "Score": "30", "OwnerUserId": "354803", "Tags": "<c++><c><gcc><standards>", "AnswerCount": "6"}, "46332639": {"Id": "46332639", "PostTypeId": "2", "Body": "<p>You ask,</p>\n<blockquote>\n<p id=\"so_46331625_46332639_0\">is there anything in the C and C++ languages standard which guarantees\n  that compilers will always avoid actual evaluation of the left operand\n  of the comma operator when the compiler can be sure that the\n  evaluation hasn't side effects?</p>\n</blockquote>\n<p>As others have remarked, the answer is \"no\".  On the contrary, the standards both unconditionally state that the left-hand operand of the comma operator <strong>is</strong> evaluated, and that the result is discarded.</p>\n<p>This is of course a description of the execution model of an abstract machine; implementations are permitted to work differently, so long as the observable behavior is the same as the abstract machine behavior would produce.  If indeed evaluation of the left-hand expression produces no side effects, then that would <em>permit</em> skipping it altogether, but there is nothing in either standard that provides for <em>requiring</em> that it be skipped.</p>\n<p>As for fixing it, you have various options, some of which apply only to one or the other of the two languages you have named.  I tend to like your <code>offsetof()</code> alternative, but others have noted that in C++, there are types to which <code>offsetof</code> cannot be applied.  In C, on the other hand, the standard specifically describes its application to <em>structure</em> types, but says nothing about union types.  Its behavior on union types, though very likely to be consistent and natural, as technically undefined.</p>\n<p>In C only, you could use a compound literal to avoid the undefined behavior in your approach:</p>\n<pre><code>#define HAS_MEMBER(T,X) (((T){0}).X, #X)\n</code></pre>\n<p>That works equally well on structure and union types (though you need to provide a full type name for this version, not just a tag).  Its behavior is well defined when the given type does have such a member.  The expansion violates a language constraint -- thus requiring a diagnostic to be emitted -- when the type does not have such a member, including when it is neither a structure type nor a union type.</p>\n<p>You might also use <code>sizeof</code>, as @alain suggested, because although the <code>sizeof</code> expression will be evaluated, <em>its</em> operand will not be evaluated (except, in C, when its operand has variably-modified type, which will not apply to your use).  I think this variation will work in both C and C++ without introducing any undefined behavior:</p>\n<pre><code>#define HAS_MEMBER(T,X) (sizeof(((T *)NULL)-&gt;X), #X)\n</code></pre>\n<p>I have again written it so that it works for both structs and unions.</p>\n", "LastActivityDate": "2017-09-20T22:25:04.793", "Score": "3", "CreationDate": "2017-09-20T22:25:04.793", "ParentId": "46331625", "CommentCount": "0", "OwnerUserId": "2402272"}});