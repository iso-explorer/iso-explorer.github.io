post_cb({"bq_ids": {"n4140": {"so_46421139_46428235_3": {"length": 13, "quality": 0.65, "section_id": 5975}, "so_46421139_46428235_1": {"length": 4, "quality": 0.8, "section_id": 5962}, "so_46421139_46428235_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5962}, "so_46421139_46428235_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5974}}, "n3337": {"so_46421139_46428235_3": {"length": 13, "quality": 0.65, "section_id": 5743}, "so_46421139_46428235_1": {"length": 4, "quality": 0.8, "section_id": 5731}, "so_46421139_46428235_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5731}, "so_46421139_46428235_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5742}}, "n4659": {"so_46421139_46428235_3": {"length": 20, "quality": 1.0, "section_id": 7475}, "so_46421139_46428235_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7451}, "so_46421139_46428235_1": {"length": 4, "quality": 0.8, "section_id": 7452}, "so_46421139_46428235_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 7473}}}, "46421139": {"ViewCount": "107", "Body": "<p><strong>Before you throw a rotten tomato</strong></p>\n<p>I know the practical application of lambda decomposition is currently limited \nas one wouldn't be able to find substitution-failure-friendly way to check \nthe number of lambda captures hidden in decomposed variables. This is just a theoretical question as I failed to find any standard part covering the capture member variable access modifiers.</p>\n<p><strong>Example</strong></p>\n<pre><code>int main() {\n    int a;\n    auto [x] = [a]{};\n    static_cast&lt;void&gt;(a);\n    static_cast&lt;void&gt;(x);\n    return 0;\n}\n</code></pre>\n<p><strong>Standard reference</strong></p>\n<p>The standard section about <a href=\"http://eel.is/c++draft/expr.prim.lambda.capture\" rel=\"nofollow noreferrer\">lambda capture</a> is quite long so I might have missed the relevant fragment. What I noticed is that there is an emphasis on that the non-static members which corresponds to the captures are/have to be unnamed.</p>\n", "AcceptedAnswerId": "46428235", "Title": "Why lambda expression's capture list cannot be decomposed using structured bindings", "CreationDate": "2017-09-26T08:13:53.957", "Id": "46421139", "CommentCount": "16", "LastEditDate": "2017-09-26T09:31:19.463", "PostTypeId": "1", "LastEditorUserId": "4324224", "LastActivityDate": "2017-09-26T13:45:55.037", "Score": "3", "OwnerUserId": "4324224", "Tags": "<c++><lambda><language-lawyer><c++1z><structured-bindings>", "AnswerCount": "1"}, "46428235": {"Id": "46428235", "PostTypeId": "2", "Body": "<p>I'd say this is unspecified by the Standard, but certainly intended to not work. What we know about lambda structure is that, from [expr.prim.lambda.closure]:</p>\n<blockquote>\n<p id=\"so_46421139_46428235_0\">The type of a lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_46421139_46428235_1\">The closure type is not an aggregate type</p>\n</blockquote>\n<p>and, from [expr.prim.lambda.capture]:</p>\n<blockquote>\n<p id=\"so_46421139_46428235_2\">For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. </p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_46421139_46428235_3\">It is unspecified whether additional unnamed non-static data members are declared in the closure type for entities captured by reference. If declared, such non-static data members shall be of literal type.</p>\n</blockquote>\n<p>The intent of having unnamed members is to avoid having them being accessed outside of the lambda's body. The consequence of these members additionally being in unspecified order means as soon as you have more than one capture by copy, you wouldn't even be able to know what your structured binding did. </p>\n<pre><code>int a=1, b=2;\nauto [x, y] = [a, b]{}; // x==1 or x==2??\n</code></pre>\n<p>The consequence of captures by reference not necessarily naming members means that you wouldn't even know how many identifiers to list in your structured binding declaration.</p>\n<p>Since the access of the non-static data members is unspecified, it's possible to have a conforming implementation make them all public, which would satisfy case 3 of structured bindings. But that very much goes against the intent of both the way lambdas are structured and how structured bindings are supposed to work, so I'd be surprised if any implementation knowingly did this. gcc, for instance, <a href=\"https://gcc.gnu.org/ml/gcc-patches/2017-01/msg01993.html\" rel=\"nofollow noreferrer\">explicitly patched</a> to disallow it. </p>\n", "LastActivityDate": "2017-09-26T13:45:55.037", "CommentCount": "0", "CreationDate": "2017-09-26T13:45:55.037", "ParentId": "46421139", "Score": "3", "OwnerUserId": "2069064"}});