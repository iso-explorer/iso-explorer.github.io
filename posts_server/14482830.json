post_cb({"14485302": {"Id": "14485302", "PostTypeId": "2", "Body": "<p>What you're reading isn't meaning what you think it means.  First of all, try the msdn page for <a href=\"http://msdn.microsoft.com/en-us/library/bb982026%28v=vs.110%29.aspx\" rel=\"noreferrer\">shared_ptr</a> itself.</p>\n<p>Scroll down into the \"Remarks\" section and you'll get to the meat of the issue.  Basically, a <code>shared_ptr&lt;&gt;</code> points to a \"control block\" which is how it keeps track of how many <code>shared_ptr&lt;&gt;</code> objects are actually pointing to the \"Real\" object.  So when you do this:</p>\n<pre><code>shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;();\n</code></pre>\n<p>While there is only 1 call to allocate memory here via <code>make_shared</code>, there are two \"logical\" blocks that you should not treat the same.  One is the <code>int</code> which stores the actual value, and the other is the control block, which stores all the <code>shared_ptr&lt;&gt;</code> \"magic\" that makes it work.</p>\n<p><strong>It is only the control block itself which is thread-safe.</strong></p>\n<p>I put that on its own line for emphasis.  The <em>contents</em> of the <code>shared_ptr</code> are not thread-safe, nor is writing to the same <code>shared_ptr</code> instance.  Here's something to demonstrate what I mean:</p>\n<pre><code>// In main()\nshared_ptr&lt;myClass&gt; global_instance = make_shared&lt;myClass&gt;();\n// (launch all other threads AFTER global_instance is fully constructed)\n\n//In thread 1\nshared_ptr&lt;myClass&gt; local_instance = global_instance;\n</code></pre>\n<p>This is fine, in fact you can do this in all threads as much as you want.  And then when <code>local_instance</code> is destructed (by going out of scope), it is also thread-safe.  Somebody can be accessing <code>global_instance</code> and it won't make a difference.  The snippet you pulled from msdn basically means \"access to the control block is thread-safe\" so other <code>shared_ptr&lt;&gt;</code> instances can be created and destroyed on different threads as much as necessary.</p>\n<pre><code>//In thread 1\nlocal_instance = make_shared&lt;myClass&gt;();\n</code></pre>\n<p>This is fine.  It <em>will</em> affect the <code>global_instance</code> object, but only indirectly.  The control block it points to will be decremented, but done in a thread-safe way.  <code>local_instance</code> will no longer point to the same object (or control block) as <code>global_instance</code> does.</p>\n<pre><code>//In thread 2\nglobal_instance = make_shared&lt;myClass&gt;();\n</code></pre>\n<p>This is almost certainly not fine if <code>global_instance</code> is accessed from any other threads (which you say you're doing).  It needs a lock if you're doing this because you're writing to wherever <code>global_instance</code> lives, not just reading from it.  So writing to an object from multiple threads is bad unless it's you have guarded it through a lock.  So you can read from <code>global_instance</code> the object by assigning new <code>shared_ptr&lt;&gt;</code> objects from it but you can't write to it.</p>\n<pre><code>// In thread 3\n*global_instance = 3;\nint a = *global_instance;\n\n// In thread 4\n*global_instance = 7;\n</code></pre>\n<p>The value of <code>a</code> is undefined.  It might be 7, or it might be 3, or it might be anything else as well.  The thread-safety of the <code>shared_ptr&lt;&gt;</code> instances only applies to managing <code>shared_ptr&lt;&gt;</code> instances which were initialized from each other, not what they're pointing to.</p>\n<p>To emphasize what I mean, look at this:</p>\n<pre><code>shared_ptr&lt;int&gt; global_instance = make_shared&lt;int&gt;(0);\n\nvoid thread_fcn();\n\nint main(int argc, char** argv)\n{\n    thread thread1(thread_fcn);\n    thread thread2(thread_fcn);\n    ...\n    thread thread10(thread_fcn);\n\n    chrono::milliseconds duration(10000);\n    this_thread::sleep_for(duration);\n\n    return;\n}\n\nvoid thread_fcn()\n{\n    // This is thread-safe and will work fine, though it's useless.  Many\n    // short-lived pointers will be created and destroyed.\n    for(int i = 0; i &lt; 10000; i++)\n    {\n        shared_ptr&lt;int&gt; temp = global_instance;\n    }\n\n    // This is not thread-safe.  While all the threads are the same, the\n    // \"final\" value of this is almost certainly NOT going to be\n    // number_of_threads*10000 = 100,000.  It'll be something else.\n    for(int i = 0; i &lt; 10000; i++)\n    {\n        *global_instance = *global_instance + 1;\n    }\n}\n</code></pre>\n<p>A <code>shared_ptr&lt;&gt;</code> is a mechanism to ensure that multiple object <em>owners</em> ensure an object is destructed, not a mechanism to ensure multiple <em>threads</em> can access an object correctly. You still need a separate synchronization mechanism to use it safely in multiple threads (like <a href=\"http://en.cppreference.com/w/cpp/thread/mutex\" rel=\"noreferrer\">std::mutex</a>).</p>\n<p>The best way to think about it IMO is that <code>shared_ptr&lt;&gt;</code> makes sure that multiple copies pointing to the same memory don't have synchronization issues for <em>itself</em>, but doesn't do anything for the object pointed to.  Treat it like that.</p>\n", "LastEditorUserId": "83839", "LastActivityDate": "2017-08-24T18:09:13.373", "Score": "59", "CreationDate": "2013-01-23T17:05:54.887", "ParentId": "14482830", "CommentCount": "10", "OwnerUserId": "83839", "LastEditDate": "2017-08-24T18:09:13.373"}, "14482830": {"ViewCount": "29731", "Body": "<p>I've read that </p>\n<blockquote>\n<p id=\"so_14482830_14482830_0\">\"Multiple threads can simultaneously read and write different\n  shared_ptr objects, even when the objects are copies that share\n  ownership.\" (<a href=\"http://msdn.microsoft.com/en-us/library/c9ceah3b%28v=vs.100%29.aspx\" rel=\"noreferrer\">MSDN: Thread Safety in the Standard C++ Library</a>)</p>\n</blockquote>\n<p>Does that mean that changing shared_ptr object is safe ?<br>\nFor an instance, is the next code considered safe:</br></p>\n<pre><code>shared_ptr&lt;myClass&gt; global = make_shared&lt;myClass&gt;();\n...\n\n//In thread 1\nshared_ptr&lt;myClass&gt; private = global;\n...\n\n//In thread 2\nglobal = make_shared&lt;myClass&gt;();\n...\n</code></pre>\n<p>Can I be sure in that case that thread 1 <code>private</code> will have the original value of <code>global</code> or the new value which thread 2 assigned but either way it will have a valid shared_ptr to myClass?</p>\n<p>==EDIT==<br>\nJust to explain my motivation. I want to have a shared pointer to hold my configuration and I have a thread pool to handle requests.<br>\nso <code>global</code> is the global configuration.<br>\n<code>thread 1</code> is taking the current configuration as it start to handle a request.<br>\n<code>thread 2</code> is updating the configuration. (only apply to future requests)  </br></br></br></br></p>\n<p>If it's work, I can update the configuration that way without breaking it in the middle of a request handling.</p>\n", "AcceptedAnswerId": "14485302", "Title": "std::shared_ptr thread safety", "CreationDate": "2013-01-23T15:09:04.067", "Id": "14482830", "CommentCount": "7", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2013-01-23T15:23:46.223", "LastEditorUserId": "672689", "LastActivityDate": "2017-08-24T18:09:13.373", "Score": "30", "OwnerUserId": "672689", "Tags": "<c++><std><shared-ptr>", "AnswerCount": "4"}, "14482884": {"Id": "14482884", "PostTypeId": "2", "Body": "<p>It means you will have a valid shared_ptr, and valid reference counting.</p>\n<p>You're describing a race condition between 2 threads that are trying to read/assign to the same variable.</p>\n<p>because this is undefined behavior in general (it only makes sense in the context and timing of the individual program) shared_ptr doesn't handle that.</p>\n", "LastActivityDate": "2013-01-23T15:12:24.963", "CommentCount": "0", "CreationDate": "2013-01-23T15:12:24.963", "ParentId": "14482830", "Score": "3", "OwnerUserId": "536086"}, "bq_ids": {"n4140": {"so_14482830_29045211_1": {"length": 21, "quality": 1.0, "section_id": 4508}}, "n3337": {"so_14482830_29045211_1": {"length": 21, "quality": 1.0, "section_id": 4339}}, "n4659": {"so_14482830_29045211_1": {"length": 21, "quality": 1.0, "section_id": 5768}}}, "29045211": {"Id": "29045211", "PostTypeId": "2", "Body": "<p>To add to what Kevin wrote, the C++14 spec has additional support for atomic access to shared_ptr objects themselves:</p>\n<blockquote>\n<p id=\"so_14482830_29045211_0\"><strong>20.8.2.6 <code>shared_ptr</code> atomic access  [util.smartptr.shared.atomic]</strong></p>\n<p id=\"so_14482830_29045211_1\">Concurrent access to a <code>shared_ptr</code> object from multiple threads does not introduce a data race if the access is done exclusively via the functions in this section and the instance is passed as their first argument.</p>\n</blockquote>\n<p>So if you do:</p>\n<pre><code>//In thread 1\nshared_ptr&lt;myClass&gt; private = atomic_load(&amp;global);\n...\n\n//In thread 2\natomic_store(&amp;global, make_shared&lt;myClass&gt;());\n...\n</code></pre>\n<p>it will be thread safe.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2016-03-02T04:50:02.107", "Score": "18", "CreationDate": "2015-03-14T03:45:11.900", "ParentId": "14482830", "CommentCount": "3", "OwnerUserId": "16406", "LastEditDate": "2016-03-02T04:50:02.107"}, "37624601": {"Id": "37624601", "PostTypeId": "2", "Body": "<p>Read operations are not subject to data races among themselves, hence it is safe to share the same instance of the shared_ptr between threads as long as all threads use <em>const methods only</em> (this includes creating copies of it). As soon as one thread uses non-const method (as in \"point it to another object\") such use is no longer thread safe.</p>\n<p>The OP example is not thread safe and would require the use of atomic load in thread 1. and atomic store in thread 2 (section 2.7.2.5 in C++11) to make it thread safe.</p>\n<p>The key word in MSDN text is indeed <em>different shared_ptr objects</em>, as already stated in previous answers.</p>\n", "LastActivityDate": "2016-06-03T22:59:06.457", "CommentCount": "0", "CreationDate": "2016-06-03T22:59:06.457", "ParentId": "14482830", "Score": "2", "OwnerUserId": "5264626"}});