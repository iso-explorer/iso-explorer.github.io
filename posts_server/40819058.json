post_cb({"40819058": {"CommentCount": "1", "AcceptedAnswerId": "40819119", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2016-11-26T13:54:14.717", "LastActivityDate": "2016-11-29T09:29:29.697", "LastEditDate": "2016-11-26T17:41:03.380", "ViewCount": "1107", "FavoriteCount": "0", "Title": "Is this a forwarding reference?", "Id": "40819058", "Score": "17", "Body": "<p>The distinction between rvalue references and forwarding references was made clear enough in this example by Scott Meyers: </p>\n<pre><code>Widget&amp;&amp; var1 = someWidget;     // here, \u201c&amp;&amp;\u201d means rvalue reference (1)\n\nauto&amp;&amp; var2 = var1;             // here, \u201c&amp;&amp;\u201d does not mean rvalue reference (2)\n\ntemplate&lt;typename T&gt;\nvoid f(std::vector&lt;T&gt;&amp;&amp; param); // here, \u201c&amp;&amp;\u201d means rvalue reference (3)\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp; param);              // here, \u201c&amp;&amp;\u201ddoes not mean rvalue reference (4)\n</code></pre>\n<p>Essentially the distinction happens when we have a <strong>deducible context</strong>, hence case (3) explicitly states that we have a <code>vector&lt;...&gt;&amp;&amp;</code> whereas the <code>T</code> in case (4) is to be deduced and (after applying reference collapsing rules) categorized in terms of \"value category\". </p>\n<p><strong>But what happens with a bit more complex pattern matching?</strong> Take the following case for example : </p>\n<pre><code>template &lt;template &lt;class...&gt; class Tuple, class... Ts&gt;\nvoid f(Tuple&lt;Ts...&gt;&amp;&amp; arg)\n{\n\n}\n</code></pre>\n<p>What does <code>&amp;&amp;</code> mean here ? </p>\n", "Tags": "<c++><c++11><perfect-forwarding><forwarding-reference>", "OwnerUserId": "4224575", "AnswerCount": "3"}, "40819119": {"ParentId": "40819058", "CommentCount": "0", "Body": "<p>In your last example, <code>arg</code> is an rvalue reference.</p>\n<blockquote>\n<p id=\"so_40819058_40819119_0\">A <em>forwarding reference</em> is an rvalue reference to a cv-unqualified template parameter</p>\n</blockquote>\n<p>and <code>Tuple&lt;Ts...&gt;</code> is not a template parameter.</p>\n<p>(Citation from [temp.deduct.call].)</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "40819119", "Score": "14", "CreationDate": "2016-11-26T14:00:29.117", "LastActivityDate": "2016-11-26T14:00:29.117"}, "40819128": {"ParentId": "40819058", "CommentCount": "0", "Body": "<p>It is a rvalue reference, not a forwarding reference.</p>\n<p>The easiest way to be sure is to try to pass an lvalue, if it fails, then it is a rvalue reference, if not, then a forwarding reference:</p>\n<pre><code>template&lt;typename... Ts&gt;\nstruct foo {};\n\n//f function definition\n\nint main() {\n    foo&lt;int, double&gt; bar;\n    f(bar); // fails! Cannot bind lvalue to rvalue reference\n    f(foo&lt;int, double&gt;{}); // ok, rvalue is passed\n}\n</code></pre>\n", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "40819128", "Score": "8", "CreationDate": "2016-11-26T14:01:15.937", "LastActivityDate": "2016-11-26T14:01:15.937"}, "bq_ids": {"n4140": {"so_40819058_40819119_0": {"section_id": 304, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_40819058_40819119_0": {"section_id": 295, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_40819058_40819119_0": {"section_id": 311, "quality": 0.8571428571428571, "length": 6}}}, "40835219": {"ParentId": "40819058", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The concept forwarding reference is not a standard concept, it is usefull de recognize it when you see it, but if you want to understand and deal with it correctly you must understand reference arithmetics. (I believe Meyer's book has also a chapter about it)</p>\n<p>What is behind the concept of a forwarding reference is the reference arithmetic:</p>\n<ul>\n<li>&amp;&amp; &amp;&amp; = &amp;&amp;</li>\n<li>&amp;&amp; &amp; = &amp;</li>\n<li>&amp; &amp;&amp; = &amp;</li>\n<li>&amp; &amp;  = &amp;</li>\n</ul>\n<p>Let's simulate compiler template type deduction with a forwarding reference</p>\n<pre><code>template&lt;class T&gt;\nvoid foo(T&amp;&amp;);\n//...\nconst int i=42;\nfoo(i); // the compiler will defines T = const int &amp;\n         //          T&amp;&amp;  = const int &amp; &amp;&amp; = const int &amp;\n         // =&gt; the compiler instantiates void foo&lt;const int &amp;&gt;(const int &amp;);\nfoo(6*7);// the compiler will defines T = int\n         //          T&amp;&amp;  = int &amp;&amp;\n         // the compiler instantiates  void foo&lt;int&gt;(int &amp;&amp;);\n</code></pre>\n<p>in such a situation, the instantiation of the template foo can produces\na function wich takes argument by lvalue reference or functions which takes arguments rvalue reference: a forwarding reference is either\na rvalue reference or a lvalue reference, depending on template type deduction. It is named like this, because in such a situation, the parameter shall be passed either as an lvalue or as an xvalue, and this is the job of <code>T&amp;&amp; std::forward&lt;T&gt;(T&amp;&amp; a)</code></p>\n<p>If you declare a function has:</p>\n<pre><code> template&lt;class T&gt;\n void foo(ATemplateClass&lt;T&gt; &amp;&amp; a);\n</code></pre>\n<p>whatever the type deduced for T by the compiler, you'll get a rvalue reference paramater.</p>\n", "OwnerUserId": "5632316", "LastEditorUserId": "5632316", "LastEditDate": "2016-11-29T09:29:29.697", "Id": "40835219", "Score": "1", "CreationDate": "2016-11-27T23:41:43.093", "LastActivityDate": "2016-11-29T09:29:29.697"}});