post_cb({"bq_ids": {"n4140": {"so_11336173_11336240_0": {"section_id": 5908, "quality": 0.9354838709677419, "length": 58}, "so_11336173_11336240_1": {"section_id": 7040, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_11336173_11336240_0": {"section_id": 5680, "quality": 0.9354838709677419, "length": 58}, "so_11336173_11336240_1": {"section_id": 6785, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_11336173_11336240_1": {"section_id": 8537, "quality": 0.5882352941176471, "length": 10}}}, "11336240": {"ParentId": "11336173", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It will compile without a definition.</p>\n<p>The definition is needed at link time, if the static member variable is <em>odr-used</em>.  (It wouldn't be <em>odr-used</em> if the compiler managed to substitute its actual value every time it was referenced.  On the other hand, taking its address is sure to make it <em>odr-used</em>)</p>\n<p>This is the complete rule (section 9.4.2 <code>[class.static.data]</code>):</p>\n<blockquote>\n<p id=\"so_11336173_11336240_0\">If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em>  that is an <em>assignment-expression</em> is a constant expression.  A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression.  [ Note:  In both these cases, the member may appear in constant expressions.  \u2014 end note ] <strong>The member shall still be defined in a namespace scope if it is odr-used in the program and the namespace scope definition shall not contain an <em>initializer</em>.</strong></p>\n</blockquote>\n<p>and from section 3.2 <code>[basic.def.odr]</code>:</p>\n<blockquote>\n<p id=\"so_11336173_11336240_1\">A variable whose name appears as a potentially-evaluated expression is <em>odr-used</em> unless it is an\n  object that satisfies the requirements for appearing in a constant expression and the lvalue-to-rvalue conversion is immediately applied.</p>\n</blockquote>\n<p>The requirements for appearing in a constant expression ARE satisfied, so everything depends on whether it is used as an <em>lvalue</em> or <em>rvalue</em>.</p>\n<p><code>std::max</code> takes an lvalue reference, so there is not an immediate lvalue-to-rvalue conversion.</p>\n<hr>\n<p>The only interaction with templates is that there could be multiple equivalent definitions and the linker will pick any one.  In your case, there is no template, so multiple definitions would produce a \"symbol multiply defined\" type of error.</p>\n<p>When you forget to provide a definition, both cases (member of template class and member of ordinary class) will give the same error: \"undefined symbol\".</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-07-05T14:52:14.573", "Id": "11336240", "Score": "3", "CreationDate": "2012-07-04T23:06:50.890", "LastActivityDate": "2012-07-05T14:52:14.573"}, "11336272": {"ParentId": "11336173", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Let's take your first example:</p>\n<pre><code>std::cout &lt;&lt; A::X &lt;&lt; std::endl;\n</code></pre>\n<p>Because <code>A::X</code> is of type <code>const int</code>, this calls <code>cout.operator&lt;&lt;(int value)</code>. Notice that in this call <code>int value</code> is taken by <em>value</em>. I believe the compiler performs <a href=\"http://en.wikipedia.org/wiki/Constant_folding\" rel=\"nofollow\">constant folding</a> and just replaces the <code>A::X</code> with the value. However, it is <em>not required</em> to do this in C++03. However, in C++11 the rules have changed and this has become required by this quote: <code>unless it is an object that satisfies the requirements for appearing in a constant expression and the lvalue-to-rvalue conversion is immediately applied.</code> (As mentioned by Ben Voigt).</p>\n<p>Now let's look at the definition for <code>std::max(1, A::X)</code>:</p>\n<pre><code>template&lt; class T &gt;\nconst T&amp; max( const T&amp; a, const T&amp; b ); \n</code></pre>\n<p>The <code>std::max</code> function takes it's arguments by <em>reference</em>, in other words, the address of <code>A::X</code> has to be known in order to complete the call. The address of <code>A::x</code> must be known which requires a definition.</p>\n", "OwnerUserId": "906773", "LastEditorUserId": "906773", "LastEditDate": "2012-07-05T00:37:31.493", "Id": "11336272", "Score": "2", "CreationDate": "2012-07-04T23:12:33.903", "LastActivityDate": "2012-07-05T00:37:31.493"}, "11336173": {"CommentCount": "3", "ViewCount": "445", "PostTypeId": "1", "LastEditorUserId": "630588", "CreationDate": "2012-07-04T22:55:27.033", "LastActivityDate": "2012-07-05T14:52:14.573", "Title": "Static Const Member Initialization and Templates (vs Static Function) - How does this work?", "AcceptedAnswerId": "11336240", "LastEditDate": "2012-07-05T13:42:56.417", "Id": "11336173", "Score": "3", "Body": "<p>I know that the C++ standard says (sec 9.4.2 paragraph 4) that a static member variable of integral or enum type can provide an initializer inside the class, but that this requires a definition of that member outside the class (in a compilation unit).  I.e., you need to do something like this:</p>\n<pre><code>class A\n{\npublic:\n    static const int X = 10;\n};\n\n// this is required by the standard\nconst int A::X;\n</code></pre>\n<p>I've seen (and I've seen it said other places) that some compilers will let you get away without the outside-of-class definition.  This works on gcc 4.2.1 on OS X:</p>\n<pre><code>#include &lt;iostream&gt;    \n\nclass A\n{\npublic:\n    static const int X = 10;\n};\n\nint main(int argc, char** argv)\n{\n    std::cout &lt;&lt; A::X &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>I recently encountered a bug where someone had done this, but they were using the member variable inside a templated function (<code>std::max</code> to be exact), and it would NOT compile, complaining about the undefined symbol A::X.  I.e., this doesn't work:</p>\n<pre><code>#include &lt;iostream&gt; \n#include &lt;algorithm&gt;   \n\nclass A\n{\npublic:\n    static const int X = 10;\n};\n\nint main(int argc, char** argv)\n{\n    std::cout &lt;&lt; std::max(1, A::X) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Adding back in the outside-of-class definition makes it work.</p>\n<p>This is sort of an academic question, but I'd like to know <em>why</em> this happens.  Especially in relation to the fact that if we replace the static member variable with a static function (<code>static const int X = 10;</code> becomes <code>static int X()</code>, <code>A::X</code> becomes <code>A::X()</code>), then it will compile without the outside-of-class definition.  The reason I mention templates is because <code>std::max</code> is templated, and other templated functions reproduce the same behavior.  It may not be specifically related to templates, but I'd like to understand why it is that templates cause the behavior that they do.  I assume this must have to do with the way that templates and static members get compiled/implemented?</p>\n<p>PS - I posted some minimal code on <a href=\"http://github.com/dantswain/StaticConstUndefinedSymbol\" rel=\"nofollow\">github</a></p>\n", "Tags": "<c++><compilation><static-members>", "OwnerUserId": "630588", "AnswerCount": "2"}});