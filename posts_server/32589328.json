post_cb({"32594605": {"ParentId": "32589328", "CommentCount": "0", "Body": "<p>All of your quotes are about the pointer value, not the act of dereferencing.</p>\n<p>5.2.10, paragraph 7 says that, assuming <code>int</code> has a stricter alignment than <code>char</code>, then the round trip of <code>char*</code> to <code>int*</code> to <code>char*</code> generates an unspecified value for the resulting <code>char*</code>.</p>\n<p>On the other hand, if you convert <code>int*</code> to <code>char*</code> to <code>int*</code>, you are guaranteed to get back <em>the exact same pointer</em> as you started with.</p>\n<p>It doesn't talk about what you get when you dereference said pointer.  It simply states that in one case, you must be able to round trip.  It washes its hands of the other way around.</p>\n<hr>\n<p>Suppose you have some ints, and <code>alignof(int) &gt; 1</code>:</p>\n<pre><code>int some_ints[3] ={0};\n</code></pre>\n<p>then you have an int pointer that is offset:</p>\n<pre><code>int* some_ptr = (int*)(((char*)&amp;some_ints[0])+1);\n</code></pre>\n<p>We'll presume that copying this misaligned pointer doesn't cause undefined behavior for now.</p>\n<p>The value of <code>some_ptr</code> is not specified by the standard.  We'll be generous and presume it actually points to some chunk of bytes within <code>some_bytes</code>.</p>\n<p>Now we have a <code>int*</code> that points to somewhere an <code>int</code> cannot be allocated (3.11/1).  Under (3.8) the use of a pointer to an <code>int</code> is restricted in a number of ways.  Usual use is restricted to a pointer to an <code>T</code> whose lifetime has begun allocated properly (/3).  Some limited use is permitted on a pointer to a <code>T</code> which has been allocated properly, but whose lifetime has not begun (/5 and /6).  </p>\n<p>There is no way to create an <code>int</code> object that does not obey the alignment restrictions of <code>int</code> in the standard.</p>\n<p>So the theoretical <code>int*</code> which claims to point to a misaligned int <em>does not point to an int</em>.  No restrictions are placed on the behavior of said pointer when dereferenced; usual dereferencing rules provide behavior of a valid pointer to an object (including an <code>int</code>) and how it behaves.</p>\n<hr>\n<p>And now our other assumptions.  No restrictions on the value of <code>some_ptr</code> here are made by the standard: <code>int* some_ptr = (int*)(((char*)&amp;some_ints[0])+1);</code>.</p>\n<p>It is not a pointer to an <code>int</code>, much like <code>(int*)nullptr</code> is not a pointer to an <code>int</code>.  Round tripping it back to a <code>char*</code> results in a pointer with unspecified value (it could be <code>0xbaadf00d</code> or <code>nullptr</code>) explicitly in the standard.</p>\n<p>The standard defines what you must do.  There are (nearly?  I guess evaluating it in a boolean context must return a bool) no requirements placed on the behavior of <code>some_ptr</code> by the standard, other than converting it back to <code>char*</code> results in an unspecified value (of the pointer).</p>\n</hr></hr>", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "32594605", "Score": "0", "CreationDate": "2015-09-15T19:59:36.893", "LastActivityDate": "2015-09-15T19:59:36.893"}, "32589710": {"ParentId": "32589328", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-09-15T15:16:36.570", "Score": "2", "LastEditorUserId": "1774667", "LastEditDate": "2015-09-15T19:39:34.040", "Id": "32589710", "OwnerUserId": "1774667", "Body": "<p><strong>EDIT</strong> This answers the OP's original question, which was \"is accessing a misaligned pointer safe\".  The OP has since edited their question to \"is dereferencing a misaligned pointer safe\", a far more practical and less interesting question.</p>\n<hr>\n<p>The round-trip cast result of the <em>pointer value</em> is unspecified under those circumstances.  Under certain limited circumstances (involving alignment), converting a pointer to A to a pointer to B, <em>and then back again</em>, results in the original pointer, <em>even if you didn't have a B in that location</em>.</p>\n<p>If the alignment requirements are not met, than that round trip -- the pointer-to-A to pointer-to-B to pointer-to-A results in a pointer with an <em>unspecified</em> value.</p>\n<p>As there are invalid pointer values, dereferencing a pointer with an unspecified value can result in undefined behavior.  It is no different than <code>*(int*)0xDEADBEEF</code> in a sense.</p>\n<p>Simply storing that pointer is not, however, undefined behavior.</p>\n<p>None of the above C++ quotes talk about actually using a pointer-to-A as a pointer-to-B.  Using a pointer to the \"wrong type\" in all but a very limited number of circumstances is undefined behavior, period.</p>\n<p>An example of this involves creating a <code>std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;</code>.  You can construct your <code>T</code> in that spot, and it will live their happily, even though it \"actually\" is an <code>aligned_storage_t&lt;sizeof(T), alignof(T)&gt;</code>.  (You may, however, have to use the pointer returned from the placement <code>new</code> for full standard compliance; I am uncertain.  See strict aliasing.)</p>\n<p>Sadly, the standard is a bit lacking in terms of what object lifetime is.  It refers to it, but does not define it well enough last I checked.  You can only use a <code>T</code> at a particular location while a <code>T</code> lives there, but what that means is not made clear in all circumstances.</p>\n</hr>", "LastActivityDate": "2015-09-15T19:39:34.040"}, "32589328": {"CommentCount": "12", "AcceptedAnswerId": "32590117", "PostTypeId": "1", "LastEditorUserId": "501126", "CreationDate": "2015-09-15T14:58:52.977", "LastActivityDate": "2015-09-15T19:59:36.893", "LastEditDate": "2015-09-15T15:42:03.427", "ViewCount": "972", "FavoriteCount": "2", "Title": "Unaligned access through reinterpret_cast", "Id": "32589328", "Score": "12", "Body": "<p>I'm in the middle of a discussion trying to figure out whether unaligned access is allowable in C++ through <code>reinterpret_cast</code>.  I think not, but I'm having trouble finding the right part(s) of the standard which confirm or refute that.  I have been looking at C++11, but I would be okay with another version if it is more clear.</p>\n<p>Unaligned access is undefined in C11.  The relevant part of <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">the C11 standard</a> (\u00a7 6.3.2.3, paragraph 7):</p>\n<blockquote>\n<p id=\"so_32589328_32589328_0\">A pointer to an object type may be converted to a pointer to a different object type.  If the resulting pointer is not correctly aligned for the referenced type, the behavior is undefined.</p>\n</blockquote>\n<p>Since the behavior of an unaligned access is undefined, some compilers (at least GCC) take that to mean that it is okay to generate instructions which require aligned data.  Most of the time the code still works for unaligned data because most x86 and ARM instructions these days work with unaligned data, but some don't.  In particular, some vector instructions don't, which means that as the compiler gets better at generating optimized instructions code which worked with older versions of the compiler may not work with newer versions.  And, of course, some architectures (<a href=\"https://www.linux-mips.org/wiki/Alignment\">like MIPS</a>) don't do as well with unaligned data.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">C++11</a> is, of course, more complicated.  \u00a7 5.2.10, paragraph 7 says:</p>\n<blockquote>\n<p id=\"so_32589328_32589328_1\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to cv <code>T2</code>\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>Note that the last word is \"unspecified\", not \"undefined\".  \u00a7 1.3.25 defines \"unspecified behavior\" as:</p>\n<blockquote>\n<p id=\"so_32589328_32589328_2\">behavior, for a well-formed program construct and correct data, that depends on the implementation</p>\n<p id=\"so_32589328_32589328_3\">[<em>Note</em>: The implementation is not required to document which behavior occurs.  The range of possible behaviors is usually delineated by this International Standard. \u2014 <em>end note</em>]</p>\n</blockquote>\n<p>Unless I'm missing something, the standard doesn't actually delineate the range of possible behaviors in this case, which seems to indicate to me that one very reasonable behavior is that which is implemented for C (at least by GCC): not supporting them.  That would mean the compiler is free to assume unaligned accesses do not occur and emit instructions which may not work with unaligned memory, just like it does for C.</p>\n<p>The person I'm discussing this with, however, has a different interpretation.  They cite \u00a7 1.9, paragraph 5:</p>\n<blockquote>\n<p id=\"so_32589328_32589328_4\">A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this International Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation).</p>\n</blockquote>\n<p>Since there is no <em>undefined</em> behavior, they argue that the C++ compiler has no right to assume unaligned access don't occur.</p>\n<p>So, are unaligned accesses through <code>reinterpret_cast</code> safe in C++?  Where in the specification (any version) does it say?</p>\n<p><strong>Edit</strong>: By \"access\", I mean actually loading and storing.  Something like</p>\n<pre><code>void unaligned_cp(void* a, void* b) {\n  *reinterpret_cast&lt;volatile uint32_t*&gt;(a) =\n    *reinterpret_cast&lt;volatile uint32_t*&gt;(b);\n}\n</code></pre>\n<p>How the memory is allocated is actually outside my scope (it is for a library which can be called with data from anywhere), but <code>malloc</code> and an array on the stack are both likely candidates.  I don't want to place any restrictions on how the memory is allocated.</p>\n<p><strong>Edit 2</strong>: <em>Please</em> cite sources (<em>i.e.</em>, the C++ standard, section and paragraph) in answers.</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "501126", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32589328_32589328_2": {"section_id": 5768, "quality": 1.0, "length": 7}, "so_32589328_32590117_0": {"section_id": 7240, "quality": 0.7857142857142857, "length": 11}, "so_32589328_32589328_0": {"section_id": 6037, "quality": 0.5294117647058824, "length": 9}, "so_32589328_32589328_3": {"section_id": 5768, "quality": 0.6470588235294118, "length": 11}, "so_32589328_32589328_4": {"section_id": 5801, "quality": 0.9736842105263158, "length": 37}, "so_32589328_32589328_1": {"section_id": 6046, "quality": 0.6557377049180327, "length": 40}}, "n3337": {"so_32589328_32589328_2": {"section_id": 5541, "quality": 1.0, "length": 7}, "so_32589328_32590117_0": {"section_id": 6984, "quality": 0.7857142857142857, "length": 11}, "so_32589328_32589328_0": {"section_id": 5890, "quality": 0.5294117647058824, "length": 9}, "so_32589328_32589328_3": {"section_id": 5541, "quality": 0.6470588235294118, "length": 11}, "so_32589328_32589328_4": {"section_id": 5574, "quality": 0.9736842105263158, "length": 37}, "so_32589328_32589328_1": {"section_id": 5814, "quality": 0.9508196721311475, "length": 58}}, "n4659": {"so_32589328_32589328_2": {"section_id": 7225, "quality": 1.0, "length": 7}, "so_32589328_32590117_0": {"section_id": 8749, "quality": 0.7142857142857143, "length": 10}, "so_32589328_32589328_0": {"section_id": 7536, "quality": 0.5294117647058824, "length": 9}, "so_32589328_32589328_3": {"section_id": 7225, "quality": 0.6470588235294118, "length": 11}, "so_32589328_32589328_4": {"section_id": 7260, "quality": 0.9736842105263158, "length": 37}, "so_32589328_32589328_1": {"section_id": 7545, "quality": 0.639344262295082, "length": 39}}}, "32590117": {"ParentId": "32589328", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-09-15T15:34:41.150", "Score": "5", "LastEditorUserId": "3647361", "LastEditDate": "2015-09-15T15:38:22.710", "Id": "32590117", "OwnerUserId": "1505939", "Body": "<p>Looking at 3.11/1:</p>\n<blockquote>\n<p id=\"so_32589328_32590117_0\">Object types have alignment requirements (3.9.1, 3.9.2) which place restrictions on the addresses at which an object of that type may be allocated. </p>\n</blockquote>\n<p>There's some debate in comments about exactly what constitutes allocating an object of a type. However I believe the following argument works regardless of how that discussion is resolved:</p>\n<p>Take <code>*reinterpret_cast&lt;uint32_t*&gt;(a)</code> for example. If this expression does not cause UB, then (according to the strict aliasing rule) there must be an object of type <code>uint32_t</code> (or <code>int32_t</code>) at the given location after this statement. Whether the object was already there, or this write created it, does not matter.</p>\n<p>According to the above Standard quote, objects with alignment requirement can only exist in a correctly aligned state.</p>\n<p>Therefore any attempt to create or write an object that is not correctly aligned causes UB.</p>\n", "LastActivityDate": "2015-09-15T15:38:22.710"}});