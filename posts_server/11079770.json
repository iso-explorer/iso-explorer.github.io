post_cb({"11080241": {"Id": "11080241", "PostTypeId": "2", "Body": "<p>I can't find anything in the standard (well, the final draft) that specifically rules it out. The closest I can find is a note in <code>20.9.11.2.10 shared_ptr casts</code></p>\n<blockquote>\n<p id=\"so_11079770_11080241_0\">5 [ Note: The seemingly equivalent expression\n  shared_ptr(static_cast(r.get())) will eventually result in\n  undefined behavior, attempting to delete the same object twice. \u2014end\n  note ]</p>\n</blockquote>\n<p>which actually seems to forget about your case with a custom deleter.</p>\n", "LastActivityDate": "2012-06-18T09:37:06.100", "Score": "2", "CreationDate": "2012-06-18T09:37:06.100", "ParentId": "11079770", "CommentCount": "0", "OwnerUserId": "1171191"}, "bq_ids": {"n4140": {"so_11079770_11080241_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 4458}}, "n3337": {"so_11079770_11080241_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 4295}}, "n4659": {"so_11079770_11080241_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 5722}}}, "11079833": {"Id": "11079833", "PostTypeId": "2", "Body": "<p>If the first shared_ptr object is destroyed, then you get UB because objects using the second might access released object.</p>\n<p>Since you made sure that your first shared_ptr object lives longer then the second, you do not get UB.</p>\n", "LastActivityDate": "2012-06-18T09:11:59.773", "Score": "5", "CreationDate": "2012-06-18T09:11:59.773", "ParentId": "11079770", "CommentCount": "0", "OwnerUserId": "476681"}, "11079770": {"ViewCount": "252", "Body": "<p>Suppose I have the need to do the following (This is just some imaginative code for discussion of the C++ standard, thus I won't discuss why I design it this way, so don't bother me with something like: your design is wrong.)</p>\n<pre><code>T* ptr = new T;\nshared_ptr&lt;T&gt; p(ptr);\nshared_ptr&lt;T&gt; q(ptr, SomeDeleterThatDoesnotDeleteButDoSomeOtherStuff());\n</code></pre>\n<p>Suppose the logic guarantees that <code>p</code> or some of its copies lives longer than all copies of <code>q</code>, so practically there won't be any problem.  My question is, is it forbidden by C++ standard, e.g. explicitly stated as UB by C++ standard, for different shared_ptr counters to share the same address?</p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "11080241", "Title": "Same address, multiple shared_ptr counters, is it forbidden by C++ standard?", "CreationDate": "2012-06-18T09:07:27.200", "Id": "11079770", "CommentCount": "6", "LastEditDate": "2012-07-29T02:32:32.543", "PostTypeId": "1", "LastEditorUserId": "963864", "LastActivityDate": "2012-07-29T02:32:32.543", "Score": "5", "OwnerUserId": "875044", "Tags": "<c++><c++11><shared-ptr><language-lawyer>", "AnswerCount": "2"}});