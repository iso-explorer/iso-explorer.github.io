post_cb({"bq_ids": {"n4140": {"so_29455791_29455791_2": {"length": 7, "quality": 0.875, "section_id": 6156}, "so_29455791_29455791_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 5888}}, "n3337": {"so_29455791_29455791_1": {"length": 9, "quality": 1.0, "section_id": 5917}, "so_29455791_29455791_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 5659}, "so_29455791_29455791_2": {"length": 8, "quality": 1.0, "section_id": 5918}}, "n4659": {"so_29455791_29455791_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 7667}, "so_29455791_29455791_2": {"length": 7, "quality": 0.875, "section_id": 7653}, "so_29455791_29455791_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 7371}}}, "29455791": {"ViewCount": "214", "Body": "<p>I read <a href=\"http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible\" rel=\"nofollow\">an article</a> saying</p>\n<blockquote>\n<p id=\"so_29455791_29455791_0\">A member function pointer can be set to 0, and provides the operators\n  == and !=, but only for member function pointers of the same class.</p>\n</blockquote>\n<p>I'm trying to understand C++11, \u00a75.10.</p>\n<p>In <strong>\u00a75.10/1</strong> it says</p>\n<blockquote>\n<p id=\"so_29455791_29455791_1\">Pointers of the same type (after pointer conversions) can be compared\n  for equality.</p>\n</blockquote>\n<p>In <strong>\u00a75.10/2</strong> it says</p>\n<blockquote>\n<p id=\"so_29455791_29455791_2\">Otherwise if either is a pointer to a virtual member function, the\n  result is unspecified.</p>\n</blockquote>\n<p>Now consider the following test program.</p>\n<pre><code>#include &lt;cassert&gt;\n\nclass ISomeClass\n{\npublic:\n   virtual ~ISomeClass() {}\n\n   virtual void a() = 0;\n   virtual void b() = 0;\n};\n\nint main()\n{\n   typedef void(ISomeClass::*MemberPtr)();\n\n   MemberPtr mp = &amp;ISomeClass::a;\n\n   assert( mp == &amp;ISomeClass::a );\n   assert( mp != &amp;ISomeClass::b );\n\n   return 0;\n}\n</code></pre>\n<p>Are the asserts true or unspecified according to the standard? </p>\n", "Title": "Are pointers to virtual member functions comparable?", "CreationDate": "2015-04-05T09:11:33.133", "LastActivityDate": "2015-04-05T11:11:41.863", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "Id": "29455791", "Score": "4", "OwnerUserId": "4477348", "Tags": "<c++><member-function-pointers>", "AnswerCount": "1"}, "29456659": {"Id": "29456659", "PostTypeId": "2", "Body": "<p>I think general pointer-to-member is a shift over object address. In the case of pointers to virtual methods, I think the details depends on implementation. In general case, I think is a bad idea to do that, but if pointer is solved to the correct override during asignation, it must work as a standard pointer to member function, and comparison is shift comparison plus method signature comparison. Check reinterpret_cast to long to see what happens.</p>\n", "LastActivityDate": "2015-04-05T11:11:41.863", "CommentCount": "3", "CreationDate": "2015-04-05T11:11:41.863", "ParentId": "29455791", "Score": "1", "OwnerUserId": "4575304"}});