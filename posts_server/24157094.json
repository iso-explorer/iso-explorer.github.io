post_cb({"24157568": {"ParentId": "24157094", "CommentCount": "1", "Body": "<h3>C++ says almost nothing about the representation of floating point types.</h3>\n<p><code>[basic.fundamental]/8</code> says (Emphasis mine):</p>\n<blockquote>\n<p id=\"so_24157094_24157568_0\">There are three floating point types: <code>float</code>, <code>double</code>, and <code>long double</code>. The type <code>double</code> provides at least as much precision as <code>float</code>, and the type <code>long double</code> provides at least as much precision as double. The set of values of the type <code>float</code> is a subset of the set of values of the type <code>double</code>; the set of values of the type <code>double</code> is a subset of the set of values of the type <code>long double</code>. <strong>The value representation of floating-point types is implementation-defined</strong>. Integral and floating types are collectively called arithmetic types. Specializations of the standard template <code>std::numeric_limits</code> (18.3) shall specify the maximum and minimum values of each arithmetic type for an implementation.</p>\n</blockquote>\n<p>If you just write C++ code using <code>float</code>, <code>double</code> and <code>long double</code>, you have virtually no guarantees, apart from those given in the documentation for your particular compiler, and those that can be implied from <code>std::numeric_limits</code>.</p>\n<p>On the other hand, IEEE 754 provides exact definitions of the behaviour and binary representation of its floating point types. These definitions are not <em>quite</em> enough to guarantee identical behaviour on all IEEE 754 platforms, since (for example) IEEE 754 sometimes allows multiple operations to be folded together when the result would be more precise than performing the two operations separately. This is likely to be unimportant to your specific case, since you just want the files to be portable, and probably do not care quite as much about identical queries creating identical changes to the files on different platforms as you do about identical files being loaded in identical ways on different platforms.</p>\n<h3>So the question is: \"how do I get a portable IEEE 754 implementation for C++?\".</h3>\n<p>The answer to this question is somewhat tricky. Most C++ compilers for reasonable platforms will provide at least <code>float</code> and <code>double</code> that approximately match IEEE 754's <code>binary32</code> and <code>binary64</code> specifications (although you will need to read the documentation for each individual compiler to be sure).</p>\n<p>Alternatively, you can use a software floating point implementation or wrapper such as <a href=\"http://flip.gforge.inria.fr/\">FLIP</a>, <a href=\"https://gcc.gnu.org/onlinedocs/gccint/Soft-float-library-routines.html\">libgcc's soft-float</a>, <a href=\"http://www.jhauser.us/arithmetic/SoftFloat.html\">SoftFloat</a>, or <a href=\"http://nicolas.brodu.net/en/programmation/streflop/\">STREFLOP</a>. These libraries sometimes still make assumptions about the implementation that are not completely portable according to the C++ standard, so use at your own risk.</p>\n", "OwnerUserId": "485561", "PostTypeId": "2", "Id": "24157568", "Score": "6", "CreationDate": "2014-06-11T07:59:39.577", "LastActivityDate": "2014-06-11T07:59:39.577"}, "24157180": {"ParentId": "24157094", "CommentCount": "3", "Body": "<p>They are. \"float\" will be 32 bits, \"double\" will be 64 bits. The byte ordering might be different; it's exactly the same as with 32 bit and 64 bit integers. </p>\n<p>If you need extended precision: That may or may not be available as \"long double\". And extended precision uses 80 bits, but \"long double\" may have additional padding bits. </p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "24157180", "Score": "0", "CreationDate": "2014-06-11T07:37:23.260", "LastActivityDate": "2014-06-11T07:37:23.260"}, "24157094": {"CommentCount": "7", "ViewCount": "458", "PostTypeId": "1", "OwnerDisplayName": "user152949", "CreationDate": "2014-06-11T07:32:37.517", "LastActivityDate": "2016-05-10T06:34:17.873", "LastEditDate": "2014-06-11T07:53:20.013", "AcceptedAnswerId": "24157568", "LastEditorDisplayName": "user152949", "Title": "IEEE float and double's guaranteed to be the same size on any OS?", "Id": "24157094", "Score": "2", "Body": "<p>I'm working on a OS portable database system. I want our database files to be OS portable so that customers can move their database files to other kinds of OS's at their discretion. Because of this use case I need my data types to be consistent across OS's, and I'm wondering if IEEE float's and double's are guaranteed to be the same byte size on any OS? </p>\n", "Tags": "<c++><floating-point><posix><portability>", "AnswerCount": "4"}, "37130892": {"ParentId": "24157094", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong><code>std::numeric_limits&lt;T&gt;::is_iec559</code></strong></p>\n<p>Determines if a given type follows IEC 559, which is another name for IEEE 754.</p>\n<p>This serves as further evidence that IEEE is optional, and offers a way for you to check if it is used or not.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++11 N3337 standard draft</a> <em>18.3.2.4 numeric_limits members</em>:</p>\n<blockquote>\n<p id=\"so_24157094_37130892_0\">static constexpr bool is_iec559;</p>\n<p id=\"so_24157094_37130892_1\">56 True if and only if the type adheres to IEC 559 standard. (217)</p>\n<p id=\"so_24157094_37130892_2\">57 Meaningful for all floating point types.</p>\n<p id=\"so_24157094_37130892_3\">(217) International Electrotechnical Commission standard 559 is the same as IEEE 754.</p>\n</blockquote>\n<p>Sample code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main() {\n    std::cout &lt;&lt; std::numeric_limits&lt;float&gt;::is_iec559 &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::numeric_limits&lt;double&gt;::is_iec559 &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::numeric_limits&lt;long double&gt;::is_iec559 &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Outputs:</p>\n<pre><code>1\n1\n1\n</code></pre>\n<p>on Ubuntu 16.04 x86-64.</p>\n<p><code>__STDC_IEC_559__</code> is an analogous macro for C: <a href=\"https://stackoverflow.com/a/31967139/895245\">https://stackoverflow.com/a/31967139/895245</a></p>\n", "OwnerUserId": "895245", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:33.107", "Id": "37130892", "Score": "0", "CreationDate": "2016-05-10T06:34:17.873", "LastActivityDate": "2016-05-10T06:34:17.873"}, "bq_ids": {"n4140": {"so_24157094_24157568_0": {"section_id": 7217, "quality": 0.8857142857142857, "length": 62}, "so_24157094_37130892_2": {"section_id": 6732, "quality": 1.0, "length": 5}, "so_24157094_37130892_0": {"section_id": 6773, "quality": 1.0, "length": 4}, "so_24157094_37130892_1": {"section_id": 6774, "quality": 0.8333333333333334, "length": 5}, "so_24157094_37130892_3": {"section_id": 6774, "quality": 0.75, "length": 6}}, "n3337": {"so_24157094_24157568_0": {"section_id": 6961, "quality": 0.8714285714285714, "length": 61}, "so_24157094_37130892_2": {"section_id": 6487, "quality": 1.0, "length": 5}, "so_24157094_37130892_0": {"section_id": 6528, "quality": 1.0, "length": 4}, "so_24157094_37130892_1": {"section_id": 6529, "quality": 0.8333333333333334, "length": 5}, "so_24157094_37130892_3": {"section_id": 6529, "quality": 0.75, "length": 6}}, "n4659": {"so_24157094_24157568_0": {"section_id": 8726, "quality": 0.9, "length": 63}, "so_24157094_37130892_0": {"section_id": 8267, "quality": 1.0, "length": 4}}}, "24157211": {"ParentId": "24157094", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>--cut-- Nevermind <a href=\"https://stackoverflow.com/a/24157568/2422450\">https://stackoverflow.com/a/24157568/2422450</a> provides a better explanation for the float sizes.</p>\n<p>If you're however thinking about storing these floats in binary data files, do make sure you don't mess up the byte order or <a href=\"http://en.wikipedia.org/wiki/Endianness\" rel=\"nofollow noreferrer\">endianness</a>. If you're dumping raw floats, some systems store the bytes in a different order, so casting the 4 bytes you just read to a double might give some surprising results.</p>\n", "OwnerUserId": "2422450", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:08:09.300", "Id": "24157211", "Score": "2", "CreationDate": "2014-06-11T07:39:04.293", "LastActivityDate": "2014-06-11T08:04:21.923"}});