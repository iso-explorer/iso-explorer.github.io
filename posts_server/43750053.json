post_cb({"43750942": {"Id": "43750942", "PostTypeId": "2", "Body": "<p>You don't state this explicitly, but I'd guess in your actual code you were failing to declare the specialization in <code>A</code>'s .h file. So when <code>A.h</code> was included in a separate compilation unit, the compiler was unaware of the specializatoin of <code>WriteNative()</code>. Adding a declaration of the specialization should fix the issue without having to include the definition in the same file (i.e., not having to inline it):</p>\n<pre><code>class A {\n    public:\n    template&lt;typename T&gt; int WriteNative(const T) { \n      printf(\"here?\\n\")\n      return 0; \n    }\n\n    template&lt;typename D&gt; \n        void doit() {\n        if (WriteNative&lt;double&gt;(1)) {\n            printf(\"A\\n\");\n        } else {\n            printf(\"B\\n\");\n        }\n    }\n};\ntemplate&lt;&gt; int A::WriteNative(const double);\n</code></pre>\n<p>You can reproduce your issue by using three files <code>A.h</code>, <code>A.cpp</code>, and <code>main.cpp</code>, where <code>A.cpp</code> contains the definition of the specialization, so that when <code>main.cpp</code> includes <code>A.h</code>, it is unaware of the specialization when inlining happens during optimization, and when compiled with <code>-O0</code>, no inlining occurs, so <code>WriteNative()</code> gets linked against the definition in <code>A.cpp</code>.</p>\n<p>Edit:\nSee this <a href=\"https://stackoverflow.com/questions/7190424/c-linking-and-template-specializations#7190915\">answer</a> which cites the spec to explain why this is correct behavior.</p>\n<p>14.7.3 [temp.expl.spec]:</p>\n<blockquote>\n<p id=\"so_43750053_43750942_0\">6/ If a template, a member template or a member of a class template is\n  explicitly specialized then that specialization shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs; no diagnostic is required. If the program\n  does not provide a definition for an explicit specialization and\n  either the specialization is used in a way that would cause an\n  implicit instantiation to take place or the member is a virtual member\n  function, the program is ill-formed, no diagnostic required. An\n  implicit instantiation is never generated for an explicit\n  specialization that is declared but not defined.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-03T17:08:31.563", "Score": "2", "CreationDate": "2017-05-03T04:13:56.597", "ParentId": "43750053", "CommentCount": "6", "OwnerUserId": "2638548", "LastEditDate": "2017-05-23T12:34:25.273"}, "bq_ids": {"n4140": {"so_43750053_43750942_0": {"length": 59, "quality": 1.0, "section_id": 268}}, "n3337": {"so_43750053_43750942_0": {"length": 59, "quality": 1.0, "section_id": 259}}, "n4659": {"so_43750053_43750942_0": {"length": 59, "quality": 1.0, "section_id": 275}}}, "43750053": {"ViewCount": "86", "Body": "<p>I doubt if gcc 4.8.3 inlines incorrect template functions... This problem does not occur in debug mode, but only in optimized mode. However this happens in a complicated code base, I am not able to reproduce the issue in a simple test case. </p>\n<p>My code is like the following</p>\n<pre><code>#include \"stdio.h\"\n\nclass A {\n public:\n\n    template&lt;typename T&gt; int WriteNative(const T) { \n      printf(\"here?\\n\")\n      return 0; \n    }\n\n    template&lt;typename D&gt; \n        void doit() {\n        if (WriteNative&lt;double&gt;(1)) {\n            printf(\"A\\n\");\n        } else {\n            printf(\"B\\n\");\n        }\n    }\n\n};\n\n// in my real code, this definition is in a different cpp file\ntemplate&lt;&gt; int A::WriteNative&lt;double&gt;(const double) { \n  return 1; \n}\n\nint main() {\n    A a;\n    a.doit&lt;float&gt;();\n}\n</code></pre>\n<p>In debug build, it prints out A, while in optimized build, it prints out here?\\nB</p>\n<p>I guess any inliner uses the generic template function definition but not the specialized one. But <strong>attribute</strong> ((noinline)) does not help.</p>\n<p>Does anyone if my code has a defined behavior of C++? and how to fix this issue? </p>\n", "Title": "gcc inline the generic template function with a specialized definition", "CreationDate": "2017-05-03T02:22:37.993", "LastActivityDate": "2017-05-03T17:08:31.563", "CommentCount": "1", "LastEditDate": "2017-05-03T02:35:09.227", "PostTypeId": "1", "LastEditorUserId": "2220174", "Id": "43750053", "Score": "0", "OwnerUserId": "2220174", "Tags": "<c++><templates><gcc><inline><compiler-optimization>", "AnswerCount": "1"}});