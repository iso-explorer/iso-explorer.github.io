post_cb({"bq_ids": {"n4140": {"so_49049496_49065801_1": {"length": 35, "quality": 1.0, "section_id": 480}, "so_49049496_49065801_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}}, "n3337": {"so_49049496_49065801_1": {"length": 35, "quality": 1.0, "section_id": 471}, "so_49049496_49065801_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}}, "n4659": {"so_49049496_49065801_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}, "so_49049496_49065801_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}}}, "49065801": {"Id": "49065801", "PostTypeId": "2", "Body": "<p>Before C++17<sup>1</sup>, the semantic of <code>const auto value = Get(\"key\");</code> is copy-initializing a temporary object from the returned expression <code>variableIt-&gt;second</code>, then copy-initializing <code>value</code> from the temporary object. So there are basically two copies/moves originally.</p>\n<p>The copy/move from the temporary object can be elided by directly constructing <code>value</code> from <code>variableIt-&gt;second</code> according to <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">N3797</a> [class.copy] paragraph 31 bullet 3:</p>\n<blockquote id=\"so_49049496_49065801_0\">\n<ul>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move.</li>\n</ul>\n</blockquote>\n<p>This copy is guaranteed since C++17 by preventing the temporary object from being materialized in semantic. The new semantic of <code>const auto value = Get(\"key\");</code> becomes copy-initializing <code>value</code> from <code>variableIt-&gt;second</code><sup>2</sup>.</p>\n<p>The copy from <code>variableIt-&gt;second</code> <strong>cannot</strong> be elided because it does not meet the requirement of copy elision appearing in a <code>return</code> statement, i.e. <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">N3797</a> [class.copy] paragraph 31 bullet 1<sup>3</sup>:</p>\n<blockquote id=\"so_49049496_49065801_1\">\n<ul>\n<li>in a <code>return</code> statement in a function with a class return type, when the expression is <strong>the name of a non-volatile automatic object</strong> (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</li>\n</ul>\n</blockquote>\n<p>This is reasonable because the lifetime of <code>variableIt-&gt;second</code> does not end and may be used in future, so <code>value</code> cannot be optimized as an alias to <code>variableIt-&gt;second</code>, thus a copy is necessary.</p>\n<hr>\n<p><sub><sup>1</sup>The only difference since C++17 is the guaranteed copy elision mentioned in the third paragraph. It is more straightaway (in my opinion) to begin the analysis from the semantic before C++17.</sub></p>\n<p><sub><sup>2</sup>There are several rules combined to conclude this conclusion in C++17, and it is not important for this question, so I emit the quote of corresponding rules from the standard.</sub></p>\n<p><sub><sup>3</sup>The wording of this rule is changed a little in C++17, while the rule is essentially the same.</sub></p>\n</hr>", "LastActivityDate": "2018-03-02T09:02:49.603", "Score": "0", "CreationDate": "2018-03-02T09:02:49.603", "ParentId": "49049496", "CommentCount": "0", "OwnerUserId": "5376789"}, "49049964": {"Id": "49049964", "PostTypeId": "2", "Body": "<p>I suggest that you have a play on <a href=\"https://godbolt.org\" rel=\"nofollow noreferrer\">Compiler Explorer</a>.</p>\n<p>What I see with GCC trunk is that pretty much all of the map and string functions get inlined and the only remaining function calls are to <code>memcmp</code> (for the inlined find and string comparison) and to <code>new</code> and <code>memcpy</code> (for the returned copy).</p>\n<p>clang trunk doesn't seem to inline as much. <code>map::find</code> is still there but still just one call to <code>new</code> and <code>memcpy</code>.</p>\n", "LastActivityDate": "2018-03-01T12:41:51.973", "Score": "0", "CreationDate": "2018-03-01T12:41:51.973", "ParentId": "49049496", "CommentCount": "0", "OwnerUserId": "6594576"}, "49049496": {"ViewCount": "56", "Body": "<p>In the following MVE, does the return value of the <code>Get</code> function qualify for copy elision? </p>\n<p><strong>EDIT</strong></p>\n<p>I've change the example somewhat. With Visual Studio 2017 in both Debug and Release builds I see a copy construction on the return statement. Hopefully this is just because I've messed up my <code>Type</code> that is assisting me with the debugging.</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;ostream&gt;\n\nstruct Type\n{\n    Type()\n    {\n        std::cout &lt;&lt; \"Default construction\\n\";\n    };\n\n    explicit Type(std::string obj) : obj(std::move(obj))\n    {\n        std::cout &lt;&lt; \"Other construction\\n\";\n    }\n    ~Type() = default;\n\n    Type(const Type&amp; other) : obj{other.obj}\n    {\n        std::cout &lt;&lt; \"Copy construction\\n\";\n    }\n\n    Type(Type&amp;&amp; other) noexcept : obj{std::move(other.obj)}\n    {\n        std::cout &lt;&lt; \"Move constructor\\n\";\n    }\n\n    Type&amp; operator=(const Type&amp; other)\n    {\n        std::cout &lt;&lt; \"Copy assignment\\n\";\n        if (this == &amp;other)\n            return *this;\n        obj = other.obj;\n        return *this;\n    }\n\n    Type&amp; operator=(Type&amp;&amp; other) noexcept\n    {\n        std::cout &lt;&lt; \"Move assignment\\n\";\n        if (this == &amp;other)\n            return *this;\n        obj = std::move(other.obj);\n        return *this;\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Type&amp; obj1)\n    {\n        return os &lt;&lt; obj1.obj;\n    }\n\n    std::string obj;\n};\n\n\nstd::map&lt;std::string, Type&gt; mVariables;\n\nType Get(const std::string&amp; variableName)\n{\n    const auto variableIt = mVariables.find(variableName);\n    if(variableIt==std::end(mVariables)) {\n        throw std::runtime_error(\"Unknown variable requested.\");\n    }\n    return variableIt-&gt;second;\n}\n\nint main()\n{\n    mVariables.emplace(std::make_pair(\"key\", Type(\"value\")));\n    const auto value = Get(\"key\");  \n    std::cout &lt;&lt; value;\n    return 0;\n}\n</code></pre>\n<p>The above example provides the following output, which raises a few questions about <code>make_pair</code>, but that is not a discussion for here. I guess my confusion is, what in this example prevent the copy elision occurring?</p>\n<pre><code>Other construction\nMove constructor\nMove constructor\nCopy construction\nvalue\n</code></pre>\n", "AcceptedAnswerId": "49065801", "Title": "Copy elision of map iterator pair value", "CreationDate": "2018-03-01T12:11:52.033", "LastActivityDate": "2018-03-02T09:02:49.603", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-03-01T12:40:35.233", "LastEditorUserId": "3288751", "Id": "49049496", "Score": "1", "OwnerUserId": "3288751", "Tags": "<c++><c++11><copy-elision>", "AnswerCount": "2"}});