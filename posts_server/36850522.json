post_cb({"36850960": {"ParentId": "36850522", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2016-04-25T20:59:39.083", "Score": "14", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:32.633", "Id": "36850960", "OwnerUserId": "6253369", "Body": "<p>The problem is libstdc++'s implementation of <code>unique_ptr</code>. This is from their 4.9.2 branch:</p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.2/libstdc++/api/a01298_source.html#l00339\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/onlinedocs/gcc-4.9.2/libstdc++/api/a01298_source.html#l00339</a></p>\n<pre><code>  338       void\n  339       reset(pointer __p = pointer()) noexcept\n  340       {\n  341     using std::swap;\n  342     swap(std::get&lt;0&gt;(_M_t), __p);\n  343     if (__p != pointer())\n  344       get_deleter()(__p);\n  345       }\n</code></pre>\n<p>As you can see, there is an unqualified swap call. Now let's see libcxx (libc++)'s implementation:</p>\n<p><a href=\"https://git.io/vKzhF\" rel=\"nofollow noreferrer\">https://git.io/vKzhF</a></p>\n<pre><code>_LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n{\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = __p;\n    if (__tmp)\n        __ptr_.second()(__tmp);\n}\n\n_LIBCPP_INLINE_VISIBILITY void swap(unique_ptr&amp; __u) _NOEXCEPT\n    {__ptr_.swap(__u.__ptr_);}\n</code></pre>\n<p>They don't call <code>swap</code> inside <code>reset</code> nor do they use an unqualified swap call. </p>\n<hr>\n<p><a href=\"https://stackoverflow.com/a/36851037/6253369\">Dyp's answer</a> provides a pretty solid breakdown on why <code>libstdc++</code> is conforming but also why your code will break whenever <code>swap</code> is required to be called by the standard library. To quote <a href=\"https://stackoverflow.com/users/819272/templaterex\">TemplateRex</a>:</p>\n<blockquote>\n<p id=\"so_36850522_36850960_0\">You should have no reason to define such a general <code>swap</code> template in\n  a very specific namespace containing only specific types. Just define\n  a non-template <code>swap</code> overload for <code>foo::bar</code>. Leave general swapping\n  to <code>std::swap</code>, and only provide specific overloads. <a href=\"https://stackoverflow.com/questions/36850522/is-it-okay-to-define-a-totally-general-swap-function/36851037?noredirect=1#comment61271635_36850522\">source</a></p>\n</blockquote>\n<p>As an example, this won't compile:</p>\n<pre><code>std::vector&lt;foo::bar&gt; v;\nstd::vector&lt;foo::bar&gt;().swap(v);\n</code></pre>\n<p>If you're targeting a platform with an old standard library/GCC (like CentOS), I would recommend using Boost instead of reinventing the wheel to avoid pitfalls like this.</p>\n</hr>", "LastActivityDate": "2016-07-16T17:22:31.647"}, "36850873": {"ParentId": "36850522", "CommentCount": "3", "CreationDate": "2016-04-25T20:54:19.153", "OwnerUserId": "502399", "PostTypeId": "2", "Id": "36850873", "Score": "12", "Body": "<p>This technique can be used to avoid <code>foo::swap()</code> getting found by ADL:</p>\n<pre><code>namespace foo\n{\n    namespace adl_barrier\n    {\n        template &lt;typename T&gt;\n        void swap(T&amp; a, T&amp; b)\n        {\n            T tmp = std::move(a);\n            a = std::move(b);\n            b = std::move(tmp);\n        }\n    }\n\n    using namespace adl_barrier;\n}\n</code></pre>\n<p>This is how Boost.Range's free-standing <code>begin()</code>/<code>end()</code> functions are defined.  I tried something similar before asking the question, but did <code>using adl_barrier::swap;</code> instead, which doesn't work.</p>\n<p>As for whether the snippet in the question should work as-is, I'm not sure.  One complication I can see is that <code>unique_ptr</code> can have custom <code>pointer</code> types from the <code>Deleter</code>, which should be swapped with the usual <code>using std::swap; swap(a, b);</code> idiom.  That idiom is clearly broken for <code>foo::bar*</code> in the question.</p>\n", "LastActivityDate": "2016-04-25T20:54:19.153"}, "36851037": {"ParentId": "36850522", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-04-25T21:04:02.760", "Score": "25", "LastEditorUserId": "420683", "LastEditDate": "2016-04-25T21:16:19.593", "Id": "36851037", "OwnerUserId": "420683", "Body": "<ul>\n<li><code>unique_ptr&lt;T&gt;</code> requires <code>T*</code> to be a <code>NullablePointer</code> [unique.ptr]p3</li>\n<li><code>NullablePointer</code> requires lvalues of <code>T*</code> to be <code>Swappable</code> [nullablepointer.requirements]p1</li>\n<li><code>Swappable</code> essentially requires <code>using std::swap; swap(x, y);</code> to select an overload for <code>x</code>, <code>y</code> being lvalues of type <code>T*</code> [swappable.requirements]p3</li>\n</ul>\n<p>In the last step, your type <code>foo::bar</code> produces an ambiguity and therefore violates the requirements of <code>unique_ptr</code>. libstdc++'s implementation is conforming, although I'd say this is rather surprising.</p>\n<hr>\n<p>The wording is of course a bit more convoluted, because it is generic.</p>\n<blockquote>\n<p id=\"so_36850522_36851037_0\"><em>[unique.ptr]p3</em></p>\n<p id=\"so_36850522_36851037_1\">If the type <code>remove_reference_t&lt;D&gt;::pointer</code> exists,\n  then <code>unique_ptr&lt;T, D&gt;::pointer</code> shall be a synonym for\n  <code>remove_reference_t&lt;D&gt;::pointer</code>. Otherwise <code>unique_ptr&lt;T,\n  D&gt;::pointer</code> shall be a synonym for <code>T*</code>. <strong>The type <code>unique_ptr&lt;T,\n  D&gt;::pointer</code> shall satisfy the requirements of <code>NullablePointer</code>.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_36850522_36851037_2\"><em>[nullablepointer.requirements]p1</em></p>\n<p id=\"so_36850522_36851037_3\">A <code>NullablePointer</code> type is a pointer-like type that supports null\n  values. A type <code>P</code> meets the requirements of <code>NullablePointer</code> if:</p>\n<ul>\n<li>[...]</li>\n<li>lvalues of type <code>P</code> are swappable (17.6.3.2),</li>\n<li>[...]</li>\n</ul>\n<p id=\"so_36850522_36851037_4\"><em>[swappable.requirements]p2</em></p>\n<p id=\"so_36850522_36851037_5\">An object <code>t</code> is swappable with an object <code>u</code> if and only if:</p>\n<ul>\n<li>the expressions <code>swap(t, u)</code> and <code>swap(u, t)</code> are valid when evaluated in the context described below, and</li>\n<li>[...]</li>\n</ul>\n<p id=\"so_36850522_36851037_6\"><em>[swappable.requirements]p3</em></p>\n<p id=\"so_36850522_36851037_7\">The context in which <code>swap(t, u)</code> and <code>swap(u, t)</code> are evaluated shall\n  ensure that a binary non-member function named \u201cswap\u201d is selected via\n  overload resolution on a candidate set that includes:</p>\n<ul>\n<li>the two <code>swap</code> function templates defined in <code>&lt;utility&gt;</code> and</li>\n<li>the lookup set produced by argument-dependent lookup.</li>\n</ul>\n</blockquote>\n<p>Note that for a pointer type <code>T*</code>, for purposes of ADL, the associated namespaces and classes are derived from the type <code>T</code>. Hence, <code>foo::bar*</code> has <code>foo</code> as an associated namespace. ADL for <code>swap(x, y)</code> where either <code>x</code> or <code>y</code> is a <code>foo::bar*</code> will therefore find <code>foo::swap</code>.</p>\n</hr>", "LastActivityDate": "2016-04-25T21:16:19.593"}, "36850522": {"CommentCount": "6", "AcceptedAnswerId": "36851037", "PostTypeId": "1", "LastEditorUserId": "502399", "CreationDate": "2016-04-25T20:32:43.840", "LastActivityDate": "2016-07-16T17:22:31.647", "LastEditDate": "2016-04-25T21:08:15.233", "ViewCount": "1980", "FavoriteCount": "7", "Title": "Is it okay to define a totally general swap() function?", "Id": "36850522", "Score": "39", "Body": "<p>The following snippet:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;utility&gt;\n\nnamespace foo\n{\n    template &lt;typename T&gt;\n    void swap(T&amp; a, T&amp; b)\n    {\n        T tmp = std::move(a);\n        a = std::move(b);\n        b = std::move(tmp);\n    }\n\n    struct bar { };\n}\n\nvoid baz()\n{\n    std::unique_ptr&lt;foo::bar&gt; ptr;\n    ptr.reset();\n}\n</code></pre>\n<p>does not compile for me:</p>\n<pre><code>$ g++ -std=c++11 -c foo.cpp\nIn file included from /usr/include/c++/5.3.0/memory:81:0,\n                 from foo.cpp:1:\n/usr/include/c++/5.3.0/bits/unique_ptr.h: In instantiation of \u2018void std::unique_ptr&lt;_Tp, _Dp&gt;::reset(std::unique_ptr&lt;_Tp, _Dp&gt;::pointer) [with _Tp = foo::bar; _Dp = std::default_delete&lt;foo::bar&gt;; std::unique_ptr&lt;_Tp, _Dp&gt;::pointer = foo::bar*]\u2019:\nfoo.cpp:20:15:   required from here\n/usr/include/c++/5.3.0/bits/unique_ptr.h:342:6: error: call of overloaded \u2018swap(foo::bar*&amp;, foo::bar*&amp;)\u2019 is ambiguous\n  swap(std::get&lt;0&gt;(_M_t), __p);\n      ^\nIn file included from /usr/include/c++/5.3.0/bits/stl_pair.h:59:0,\n                 from /usr/include/c++/5.3.0/bits/stl_algobase.h:64,\n                 from /usr/include/c++/5.3.0/memory:62,\n                 from foo.cpp:1:\n/usr/include/c++/5.3.0/bits/move.h:176:5: note: candidate: void std::swap(_Tp&amp;, _Tp&amp;) [with _Tp = foo::bar*]\n     swap(_Tp&amp; __a, _Tp&amp; __b)\n     ^\nfoo.cpp:7:10: note: candidate: void foo::swap(T&amp;, T&amp;) [with T = foo::bar*]\n     void swap(T&amp; a, T&amp; b)\n</code></pre>\n<p>Is this my fault for declaring a <code>swap()</code> function so general that it conflicts with <code>std::swap</code>?</p>\n<p>If so, is there a way to define <code>foo::swap()</code> so that it doesn't get hauled in by Koenig lookup?</p>\n", "Tags": "<c++><c++11><gcc><libstdc++><argument-dependent-lookup>", "OwnerUserId": "502399", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_36850522_36851037_1": {"section_id": 4292, "quality": 0.9473684210526315, "length": 18}, "so_36850522_36851037_7": {"section_id": 6279, "quality": 0.9444444444444444, "length": 17}, "so_36850522_36851037_3": {"section_id": 6282, "quality": 1.0, "length": 11}}, "n3337": {"so_36850522_36851037_1": {"section_id": 4133, "quality": 0.8421052631578947, "length": 16}, "so_36850522_36851037_7": {"section_id": 6039, "quality": 0.9444444444444444, "length": 17}, "so_36850522_36851037_3": {"section_id": 6042, "quality": 1.0, "length": 11}}, "n4659": {"so_36850522_36851037_7": {"section_id": 7786, "quality": 0.9444444444444444, "length": 17}, "so_36850522_36851037_1": {"section_id": 5550, "quality": 0.8421052631578947, "length": 16}, "so_36850522_36851037_3": {"section_id": 7789, "quality": 1.0, "length": 11}}}});