post_cb({"13750296": {"CommentCount": "0", "AcceptedAnswerId": "13750503", "PostTypeId": "1", "LastEditorUserId": "1774667", "CreationDate": "2012-12-06T18:40:25.947", "LastActivityDate": "2012-12-06T18:53:30.867", "LastEditDate": "2012-12-06T18:49:03.673", "ViewCount": "1640", "FavoriteCount": "1", "Title": "std::less on enums", "Id": "13750296", "Score": "3", "Body": "<p>Does the standard guarantee that <code>std::less&lt;MyEnumType&gt;</code> will order <code>MyEnumType</code> as if a value of <code>MyEnumType</code> was cast to an appropriately sized integer type?</p>\n<pre><code>enum MyEnumType { E1 = 0, E2 = 6, E3 = 3 };\n</code></pre>\n", "Tags": "<c++><enums><language-lawyer>", "OwnerUserId": "239916", "AnswerCount": "2"}, "13750495": {"ParentId": "13750296", "CommentCount": "0", "Body": "<p>The type of an enum is defined as some integral type that is large enough to hold all of the values of the enum. The compiler is allowed to decide what the concrete type is (although there is now a <a href=\"https://en.wikipedia.org/wiki/C%2B%2B11#Strongly_typed_enumerations\" rel=\"nofollow\">way to control this</a>). But the type is definitely some integral type, which means that comparison operators on two values of the same enum type will behave pretty much as you'd expect.</p>\n", "OwnerUserId": "582", "PostTypeId": "2", "Id": "13750495", "Score": "2", "CreationDate": "2012-12-06T18:53:01.853", "LastActivityDate": "2012-12-06T18:53:01.853"}, "13750503": {"ParentId": "13750296", "CommentCount": "0", "Body": "<p>Yes, <code>std::less::operator()</code> is defined as (\u00a720.8.5/5):</p>\n<blockquote>\n<p id=\"so_13750296_13750503_0\"><code>operator()</code> returns <code>x &lt; y</code></p>\n</blockquote>\n<p>For using relational operators on enumeration types, the following is stated (\u00a75.9/2):</p>\n<blockquote>\n<p id=\"so_13750296_13750503_1\">The usual arithmetic conversions are performed on operands of arithmetic or enumeration type.</p>\n</blockquote>\n<p>For unscoped enumeration types, the <em>usual arithmetic conversions</em> are defined as doing integral promotion. Integral promotion for unscoped enumeration types is defined as (\u00a75/9):</p>\n<blockquote>\n<p id=\"so_13750296_13750503_2\">A prvalue of an unscoped enumeration type whose underlying type is not fixed (7.2) can be converted to a prvalue of the first of the following types that can represent all the values of the enumeration (i.e., the values in the range b<sub>min</sub> to b<sub>max</sub> as described in 7.2): <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>, <code>long long int</code>, or <code>unsigned long long int</code>.</p>\n</blockquote>\n<p>An extended integer type will be used if available and required.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "13750503", "Score": "3", "CreationDate": "2012-12-06T18:53:30.867", "LastActivityDate": "2012-12-06T18:53:30.867"}, "bq_ids": {"n4140": {"so_13750296_13750503_2": {"section_id": 23, "quality": 0.9487179487179487, "length": 37}, "so_13750296_13750503_1": {"section_id": 6138, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_13750296_13750503_2": {"section_id": 20, "quality": 0.9487179487179487, "length": 37}, "so_13750296_13750503_1": {"section_id": 5902, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_13750296_13750503_2": {"section_id": 23, "quality": 0.9487179487179487, "length": 37}, "so_13750296_13750503_1": {"section_id": 7635, "quality": 0.8888888888888888, "length": 8}}}});