post_cb({"bq_ids": {"n4140": {"so_30530364_30530378_0": {"length": 59, "quality": 1.0, "section_id": 268}, "so_30530364_30530378_1": {"length": 48, "quality": 0.9795918367346939, "section_id": 269}}, "n3337": {"so_30530364_30530378_0": {"length": 59, "quality": 1.0, "section_id": 259}, "so_30530364_30530378_1": {"length": 47, "quality": 0.9591836734693877, "section_id": 260}}, "n4659": {"so_30530364_30530378_0": {"length": 59, "quality": 1.0, "section_id": 275}, "so_30530364_30530378_1": {"length": 48, "quality": 0.9795918367346939, "section_id": 276}}}, "30530378": {"Id": "30530378", "PostTypeId": "2", "Body": "<p>Declaring specializations in a source file and can cause all sorts of subtle issues that are very difficult to diagnose. The compiler isn't obligated to help you in any regard here either. The standard <strong>strongly encourages you not to do this</strong>, with the help of a limerick, in [temp.expl.spec]/6-7:</p>\n<blockquote>\n<p id=\"so_30530364_30530378_0\">If a template, a member template or a member of a class template is explicitly specialized then that specialization\n  shall be declared before the first use of that specialization that would cause an implicit instantiation\n  to take place, <strong>in every translation unit in which such a use occurs; no diagnostic is required</strong>. If the program\n  does not provide a definition for an explicit specialization and either the specialization is used in a way\n  that would cause an implicit instantiation to take place or the member is a virtual member function, the\n  program is ill-formed, no diagnostic required. An implicit instantiation is never generated for an explicit\n  specialization that is declared but not defined.</p>\n<p id=\"so_30530364_30530378_1\">The placement of explicit specialization declarations for function templates, class templates, variable templates,\n  member functions of class templates, [...], etc., can affect whether a program is well-formed according\n  to the relative positioning of the explicit specialization declarations and their points of instantiation\n  in the translation unit as specified above and below. <strong>When writing a specialization, be careful about its\n  location; or to make it compile will be such a trial as to kindle its self-immolation</strong>.</p>\n</blockquote>\n<p>It's likely that in some translation units, the specialization happened to be declared before the first use - and in some translation units it hasn't been. It's better to avoid all such issues entirely by simply declaring your specialization in your header:</p>\n<pre><code>// writer.h\nclass Writer {\npublic:\n    ...\n    template &lt;typename T, typename V&gt;\n    void addField(const std::string&amp; name, V v) \n    { /* ... */ }\n};\n\n// still writer.h\ntemplate &lt;&gt;\ninline void Writer::addField&lt;some_type, int&gt;(const std::string&amp; name, int v)\n{ /* ... */ }\n</code></pre>\n<p>You can also just <em>declare</em> it in the header (no longer needs to be inline), and still define it in the source.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-29T13:39:01.290", "Score": "6", "CreationDate": "2015-05-29T13:03:39.907", "ParentId": "30530364", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2015-05-29T13:39:01.290"}, "30530364": {"ViewCount": "4812", "Body": "<p>I have a class with a member template function:</p>\n<pre><code>// writer.h\nclass Writer {\npublic:\n    ...\n    template &lt;typename T, typename V&gt;\n    void addField(const std::string&amp; name, V v) \n    {\n        // write something\n    }\n};\n</code></pre>\n<p>And in Writer's source file, I added explicit specializations for <code>some_type</code>:</p>\n<pre><code>// writer.cpp\ntemplate &lt;&gt;\nvoid Writer::addField&lt;some_type, int&gt;(const std::string&amp; name, int v)\n{\n    // specific some_type writing logic\n}\n</code></pre>\n<p>This works... sometimes. Even if I definitely make sure that I have the right types:</p>\n<pre><code>writer.addField&lt;some_type&gt;(\"name\", static_cast&lt;int&gt;(some_value));\n</code></pre>\n<p>Sometimes the explicit specialization gets called, and sometimes the primary gets called. What gives?</p>\n", "Title": "Explicit specialization of member function template in source file", "CreationDate": "2015-05-29T13:02:55.030", "LastActivityDate": "2015-05-29T13:39:01.290", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "Id": "30530364", "Score": "4", "OwnerUserId": "2069064", "Tags": "<c++><templates><explicit-specialization>", "AnswerCount": "1"}});