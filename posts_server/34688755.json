post_cb({"34689060": {"Id": "34689060", "PostTypeId": "2", "Body": "<p>All the 6 expressions are valid according to the standard:  </p>\n<blockquote>\n<p id=\"so_34688755_34689060_0\"><strong>5.2.1/1</strong> A postfix expression followed by an expression in square brackets is a postfix expression. One of the ex- pressions shall have\n  the type \u201carray of T\u201d or \u201cpointer to T\u201d and the other shall have\n  unscoped enumeration or integral type. The result is of type \u201cT.\u201d The\n  type \u201cT\u201d shall be a completely-defined object type. <strong>The expression\n  E1[E2] is identical (by definition) to *((E1)+(E2))</strong></p>\n</blockquote>\n<p>All the subscipting expressions (i.e. those followed by a square brackets, that is 1,2,4 and 5) are integers obtained by dereferencing a pointer obtained by pointer arithmetic.</p>\n<p>For example:</p>\n<ul>\n<li><p><code>p[2]</code> is equivalent to <code>*(p+2)</code>.  As p is a pointer to an integer, this will return the 3rd integer in the array (subscripts start with 0), thus 3.  </p></li>\n<li><p><code>2[p]</code> looks strange.  I don't recommend this notation,  but it is also equivalent to <code>*(2+p)</code>.  As p is a pointer to integer, 2+p also will refer to the 3rd integer in the array.  </p></li>\n</ul>\n<p>The two remaining expressions (i.e. 3 and 6) return pointers to integers using pointer arithmetic. They both will return the address of the 3rd element in the array.   </p>\n<p>Here an <a href=\"http://ideone.com/QsuJcT\" rel=\"nofollow\">online demo</a>. </p>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2016-01-09T02:29:24.440", "Score": "4", "CreationDate": "2016-01-09T02:24:01.040", "ParentId": "34688755", "CommentCount": "4", "OwnerUserId": "3723423", "LastEditDate": "2016-01-09T02:29:24.440"}, "bq_ids": {"n4140": {"so_34688755_34689060_0": {"length": 30, "quality": 0.8571428571428571, "section_id": 5986}}, "n3337": {"so_34688755_34689060_0": {"length": 29, "quality": 0.8285714285714286, "section_id": 5754}}, "n4659": {"so_34688755_34689060_0": {"length": 28, "quality": 0.8, "section_id": 7486}}}, "34689099": {"Id": "34689099", "PostTypeId": "2", "Body": "<p>As has been described in the comments, <code>p[i]</code> and <code>*(p + i)</code> mean the same thing. This is sometimes called the \"array-pointer duality\".</p>\n<p>All six expressions are valid, but two of them have different meanings from the other four.</p>\n<blockquote id=\"so_34688755_34689099_0\">\n<pre><code>int arr[] = {1, 2, 3, 4, 5};\nint *p = arr;\n</code></pre>\n</blockquote>\n<p>We start with an array arr. The label <code>arr</code> points to the memory address of the first element in the array. (* actually, it is more complicated that that, but that's not important for this discussion.)</p>\n<p>Then, we set p (an int*, thus, an address) equal to arr. So p and arr are pointing to the same memory location.</p>\n<blockquote id=\"so_34688755_34689099_1\">\n<pre><code> 1. p[2]\n 2. 2[p]\n 4. arr[2]\n 5. 2[arr]\n</code></pre>\n</blockquote>\n<p>These four represent an array value (pointer dereference), and they all represent the same value: <code>*(p + 2)</code>. (For 1 and 2, since p == arr, they give the same value as 1 and 2.)</p>\n<blockquote id=\"so_34688755_34689099_2\">\n<pre><code>3. p + 2\n6. arr + 2\n</code></pre>\n</blockquote>\n<p>These two represent specifically pointer arithmetic. But because you're not dereferencing anything, you get a memory address, rather than a value.</p>\n<p>You can see that a little more clearly if you attempt to compile this program:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n\nint main(void)\n{\n    int arr[] = { 1, 2, 3, 4, 5 };\n    int *p = arr;\n\n    printf(\"1: %d\\n\", p[2]);\n    printf(\"2: %d\\n\", 2[p]);\n    printf(\"3: %d\\n\", p + 2);\n    printf(\"4: %d\\n\", arr[2]);\n    printf(\"5: %d\\n\", 2[arr]);\n    printf(\"6: %d\\n\", arr + 2);\n}\n</code></pre>\n<p>You get these warnings:</p>\n<pre><code>foo.c:11:20: warning: format specifies type 'int' but the argument has type 'int *' [-Wformat]\n        printf(\"3: %d\\n\", p + 2);\n                   ~~     ^~~~~\nfoo.c:14:20: warning: format specifies type 'int' but the argument has type 'int *' [-Wformat]\n        printf(\"6: %d\\n\", arr + 2);\n                   ~~     ^~~~~~~\n2 warnings generated.\n</code></pre>\n<p>And this output:</p>\n<pre><code>1: 3\n2: 3\n3: 1499322968\n4: 3\n5: 3\n6: 1499322968\n</code></pre>\n<p>Note the warnings (and resulting values for 3 and 6): the pointer arithmetic results in a pointer, not a value. Also note that it's the same memory address. If you instead attempted to access *(p + 2) or *(arr + 2), you would get 3.</p>\n<p>Now, as a matter of practice, you probably don't want to write 2[arr] or 2[p]. While it's syntactically legal, it's semantically very confusing, especially to people who don't have a complete grasp on pointers.</p>\n", "LastActivityDate": "2016-01-09T02:31:01.247", "CommentCount": "0", "CreationDate": "2016-01-09T02:31:01.247", "ParentId": "34688755", "Score": "0", "OwnerUserId": "5760706"}, "34688755": {"ViewCount": "100", "Body": "<p>I'm learning C++ and I came across this question (it is really bothering me)...</p>\n<p>Assume:</p>\n<pre><code>int arr[] = {1, 2, 3, 4, 5};\nint *p = arr;\n</code></pre>\n<p>Which ones are legal, which are illegal &amp; what do they mean?</p>\n<ol>\n<li><code>p[2]</code></li>\n<li><code>2[p]</code></li>\n<li><code>p + 2</code></li>\n<li><code>arr[2]</code></li>\n<li><code>2[arr]</code></li>\n<li><code>arr + 2</code></li>\n</ol>\n<p>I am not sure what the answers are and not sure what they mean. Would appreciate it if someone could explain it to me</p>\n<p>Thanks</p>\n", "Title": "C++ Pointers - Which ones are valid", "CreationDate": "2016-01-09T01:35:54.523", "LastActivityDate": "2016-01-09T13:14:46.437", "CommentCount": "4", "LastEditDate": "2016-01-09T13:14:46.437", "PostTypeId": "1", "LastEditorUserId": "3723423", "Id": "34688755", "Score": "-1", "OwnerUserId": "5765433", "Tags": "<c++><arrays><pointers>", "AnswerCount": "2"}});