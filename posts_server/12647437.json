post_cb({"12647642": {"Id": "12647642", "PostTypeId": "2", "Body": "<p>According to <a href=\"http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx\" rel=\"noreferrer\">this blog post</a>, VC++ 2012 currently implements <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html\" rel=\"noreferrer\">N2844</a> + <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1138\" rel=\"noreferrer\">DR1138</a>, but not <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html\" rel=\"noreferrer\">N3053</a>. As a result, the compiler is <em>not</em> implicitly generating move constructors or assignment operators for you. If you add explicit default and move constructors to <code>B</code> then you will get the output you expect.</p>\n", "LastActivityDate": "2012-09-28T21:30:24.603", "CommentCount": "3", "CreationDate": "2012-09-28T21:30:24.603", "ParentId": "12647437", "Score": "14", "OwnerUserId": "636019"}, "bq_ids": {"n4140": {"so_12647437_12647564_0": {"length": 27, "quality": 1.0, "section_id": 456}}, "n3337": {"so_12647437_12647564_0": {"length": 27, "quality": 1.0, "section_id": 447}}, "n4659": {"so_12647437_12647564_0": {"length": 27, "quality": 1.0, "section_id": 479}}}, "12647564": {"Id": "12647564", "PostTypeId": "2", "Body": "<p>I don't think generation of the copy ctor is prevented by the declaration of the move constructor. ... and it seems the compiler prefers the copy constructor over the move constructor.</p>\n<p>Actually, according to 12.8 [class.copy] paragraph 7 the presence of a move constructor should prevent the copy constructor:</p>\n<blockquote>\n<p id=\"so_12647437_12647564_0\">If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4).</p>\n</blockquote>\n<p>However, the details of move construction were changed until late in the process and it seems VC++ doesn't implement the actual standard but an earlier revision.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-09-28T21:36:08.593", "Score": "1", "CreationDate": "2012-09-28T21:23:35.383", "ParentId": "12647437", "CommentCount": "2", "OwnerUserId": "1120273", "LastEditDate": "2012-09-28T21:36:08.593"}, "12647674": {"Id": "12647674", "PostTypeId": "2", "Body": "<p>Visual C++ 2012 does not implement the final C++11 specification for rvalue references and move operations (the specification changed several times during the standardization process).  You can find out more information in the Visual C++ Team Blog post, <a href=\"http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx\" rel=\"noreferrer\">\"C++11 Features in Visual C++ 11\"</a>, under <em>rvalue references</em>.</p>\n<p>In your example specifically, this manifests itself in two ways:</p>\n<ul>\n<li><p>the definition of the user-defined move operations in <code>A</code> do not suppress the implicitly-declared copy operations.</p></li>\n<li><p>there are no implicitly defined move operations for <code>B</code>.</p></li>\n</ul>\n", "LastActivityDate": "2012-09-28T21:33:21.983", "CommentCount": "0", "CreationDate": "2012-09-28T21:33:21.983", "ParentId": "12647437", "Score": "7", "OwnerUserId": "151292"}, "12647437": {"ViewCount": "2810", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct A\n{\n    A()\n    {\n        cout &lt;&lt; \"A()\" &lt;&lt; endl;\n    }\n\n    ~A()\n    {\n        cout &lt;&lt; \"~A()\" &lt;&lt; endl;\n    }\n\n    A(A&amp;&amp;)\n    {\n        cout &lt;&lt; \"A(A&amp;&amp;)\" &lt;&lt; endl;\n    }\n\n    A&amp; operator =(A&amp;&amp;)\n    {\n        cout &lt;&lt; \"A&amp; operator =(A&amp;&amp;)\" &lt;&lt; endl;\n        return *this;\n    }\n};\n\nstruct B\n{\n    // According to the C++11, the move ctor/assignment operator\n    // should be implicitly declared and defined. The move ctor\n    // /assignment operator should implicitly call class A's move\n    // ctor/assignment operator to move member a.\n    A a;\n};\n\nB f()\n{\n    B b;\n\n    // The compiler knows b is a temporary object, so implicitly \n    // defined move ctor/assignment operator of class B should be\n    // called here. Which will cause A's move ctor is called.\n    return b; \n}\n\nint main()\n{\n    f();\n    return 0;\n}\n</code></pre>\n<p>My expected output should be:</p>\n<pre><code>A()\nA(A&amp;&amp;)\n~A()\n~A()\n</code></pre>\n<p>However, the actual output is: (The C++ compiler is: Visual Studio 2012)</p>\n<pre><code>A()\n~A()\n~A()\n</code></pre>\n<p>Is this a bug of VC++? or just my misunderstanding?</p>\n", "AcceptedAnswerId": "12647642", "Title": "Why do not C++11's move constructor/assignment operator act as expected", "CreationDate": "2012-09-28T21:11:06.280", "Id": "12647437", "CommentCount": "6", "LastEditDate": "2012-09-28T21:33:13.120", "PostTypeId": "1", "LastEditorUserId": "636019", "LastActivityDate": "2012-09-28T21:36:08.593", "Score": "8", "OwnerUserId": "508343", "Tags": "<c++><visual-c++><c++11><visual-studio-2012><move-semantics>", "AnswerCount": "3"}});