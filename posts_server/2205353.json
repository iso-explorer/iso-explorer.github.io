post_cb({"2205421": {"Id": "2205421", "PostTypeId": "2", "Body": "<p>reinterpret_cast is not a general cast.  According to the C++03 spec section 5.2.10.1:</p>\n<blockquote>\n<p id=\"so_2205353_2205421_0\">Conversions that can be performed explicitly using reinterpret_cast are listed below. No other conversion can be performed explicitly using reinterpret_cast.</p>\n</blockquote>\n<p>And there is nothing listed that describes converting between integral and floating point types (or between integral types, even this is illegal <code>reinterpret_cast&lt;long&gt;(int(3));</code>)</p>\n", "LastEditorUserId": "29809", "LastActivityDate": "2010-02-05T06:42:24.207", "Score": "11", "CreationDate": "2010-02-05T06:32:46.180", "ParentId": "2205353", "CommentCount": "0", "LastEditDate": "2010-02-05T06:42:24.207", "OwnerUserId": "29809"}, "2206087": {"Id": "2206087", "PostTypeId": "2", "Body": "<p>Reinterpret cast allows you to reinterpret a block of memory as a different type. This has to be performed on pointers <em>or references</em>:</p>\n<pre><code>int x = 1;\nfloat &amp; f = reinterpret_cast&lt;float&amp;&gt;(x);\nassert( static_cast&lt;float&gt;(x) != f );   // !!\n</code></pre>\n<p>The other thing is that it is in fact a quite dangerous cast, not only due to strange values coming out as results, or the assert above not failing, but because if the types are of different sizes, and you reinterpret from 'source' to 'destination' types, any operation on the reinterpreted reference/pointer will access <code>sizeof(destination)</code> bytes. If <code>sizeof(destination)&gt;sizeof(source)</code> then that will step beyond the actual variable memory, potentially killing your application or overwritting other variables other than the source or destination:</p>\n<pre><code>struct test {\n   int x;\n   int y;\n};\ntest t = { 10, 20 };\ndouble &amp; d = reinterpret_cast&lt;double&amp;&gt;( t.x );\nd = 1.0/3.0;\nassert( t.x != 10 ); // most probably at least.\nasswet( t.y != 20 );\n</code></pre>\n", "LastActivityDate": "2010-02-05T09:11:59.230", "Score": "2", "CreationDate": "2010-02-05T09:11:59.230", "ParentId": "2205353", "CommentCount": "0", "OwnerUserId": "36565"}, "2205394": {"Id": "2205394", "PostTypeId": "2", "Body": "<p>By assigning y to the value returned by the cast you're not really casting the value <code>x</code>, you're converting it.  That is, <code>y</code> doesn't point to <code>x</code> and pretend that it points to a float.  Conversion constructs a new value of type <code>float</code> and assigns it the value from <code>x</code>.  There are several ways to do this conversion in C++, among them:</p>\n<pre><code>int main()\n{\n    int x = 42;\n    float f = static_cast&lt;float&gt;(x);\n    float f2 = (float)x;\n    float f3 = float(x);\n    float f4 = x;\n    return 0;\n}\n</code></pre>\n<p>The only real difference being the last one (an implicit conversion) will generate a compiler diagnostic on higher warning levels.  But they all do functionally the same thing -- and in many case <em>actually</em> the same thing, as in the same machine code.</p>\n<p>Now if you really do want to pretend that <code>x</code> is a float, then you really do want to cast <code>x</code>, by doing this:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int x = 42;\n    float* pf = reinterpret_cast&lt;float*&gt;(&amp;x);\n    (*pf)++;\n    cout &lt;&lt; *pf;\n    return 0;\n}\n</code></pre>\n<p>You can see how dangerous this is.  In fact, the output when I run this on my machine is <code>1</code>, which is decidedly not 42+1.</p>\n", "LastActivityDate": "2010-02-05T06:24:29.080", "Score": "33", "CreationDate": "2010-02-05T06:24:29.080", "ParentId": "2205353", "CommentCount": "3", "OwnerUserId": "241536"}, "2205393": {"Id": "2205393", "PostTypeId": "2", "Body": "<p>The compiler rejects what you wrote as nonsense because <code>int</code> and <code>double</code> may be objects with different sizes. You could achieve the same effect this way, although it is certainly dangerous:</p>\n<pre><code>int x = 0;\ndouble y = *reinterpret_cast&lt;double*&gt;(&amp;x);\n</code></pre>\n<p>This is potentially dangerous because if <code>x</code> and <code>y</code> are diffrent sizes (let's say <code>int</code> is four bytes and <code>double</code> is eight bytes) then when you dereference the eight bytes of memory at <code>&amp;x</code> to fill in <code>y</code> you will access four bytes of <code>x</code> and four bytes of ... whatever comes next in memory (possibly the start of <code>y</code>, or garbage, or something else entirely.)</p>\n<p>If you want to convert a integer to a double, use a <code>static_cast</code> and it will perform conversion.</p>\n<p>If you want to access the bit-pattern of <code>x</code>, cast to some convenient pointer type (say, <code>byte*</code>) and access up to <code>sizeof(int) / sizeof(byte)</code>:</p>\n<pre><code>byte* p = reinterpret_cast&lt;byte*&gt;(&amp;x);\nfor (size_t i = 0; i &lt; sizeof(int); i++) {\n  // do something with p[i]\n}\n</code></pre>\n", "LastActivityDate": "2010-02-05T06:24:05.440", "Score": "3", "CreationDate": "2010-02-05T06:24:05.440", "ParentId": "2205353", "CommentCount": "1", "OwnerUserId": "878"}, "bq_ids": {"n4140": {"so_2205353_2205421_0": {"length": 15, "quality": 1.0, "section_id": 6040}}, "n3337": {"so_2205353_2205421_0": {"length": 15, "quality": 1.0, "section_id": 5808}}, "n4659": {"so_2205353_2205421_0": {"length": 15, "quality": 1.0, "section_id": 7539}}}, "2205360": {"Id": "2205360", "PostTypeId": "2", "Body": "<p><code>reinterpret_cast</code> is best used for pointers.   So a pointer to one object can be turned into a \"submarine\".</p>\n<p>From <a href=\"http://msdn.microsoft.com/en-us/library/e0w9f63b(VS.80).aspx\" rel=\"nofollow noreferrer\">msdn</a>:</p>\n<blockquote>\n<p id=\"so_2205353_2205360_0\">The reinterpret_cast operator can be\n  used for conversions such as char* to\n  int*, or One_class* to\n  Unrelated_class*, which are inherently\n  unsafe.</p>\n<p id=\"so_2205353_2205360_1\">The result of a reinterpret_cast\n  cannot safely be used for anything\n  other than being cast back to its\n  original type. Other uses are, at\n  best, nonportable.</p>\n</blockquote>\n", "LastActivityDate": "2010-02-05T06:12:04.973", "Score": "1", "CreationDate": "2010-02-05T06:12:04.973", "ParentId": "2205353", "CommentCount": "0", "OwnerUserId": "6180"}, "2205381": {"Id": "2205381", "PostTypeId": "2", "Body": "<p>That's interesting.  Maybe it's doing an implicit conversion from int to float before it attempts the cast to double.  int and float types tend to be the same size in bytes (depending on your system of course).</p>\n", "LastActivityDate": "2010-02-05T06:19:15.700", "Score": "0", "CreationDate": "2010-02-05T06:19:15.700", "ParentId": "2205353", "CommentCount": "0", "OwnerUserId": "60096"}, "2205378": {"Id": "2205378", "PostTypeId": "2", "Body": "<p>If you are trying to convert the bits of your <code>int</code> to a the representation of a <code>double</code>, you need to cast the <em>address</em> not the value.  You must also make sure the sizes match:</p>\n<pre><code>uint64_t x = 0x4045000000000000;\ndouble y = *reinterpret_cast&lt;double *&gt;(&amp;x);\n</code></pre>\n", "LastActivityDate": "2010-02-05T06:18:22.657", "Score": "7", "CreationDate": "2010-02-05T06:18:22.657", "ParentId": "2205353", "CommentCount": "0", "OwnerUserId": "12048"}, "2205353": {"ViewCount": "25333", "Body": "<p>I understand that reinterpret_cast is dangerous, I'm just doing this to test it. I have the following code:</p>\n<pre><code>int x = 0;\ndouble y = reinterpret_cast&lt;double&gt;(x);\n</code></pre>\n<p>When I try to compile the program, it gives me an error saying</p>\n<pre><code>invalid cast from type 'float' to type 'double\n</code></pre>\n<p>What's going on? I thought reinterpret_cast was the rogue cast that you could use to convert apples to submarines, why won't this simple cast compile?</p>\n", "AcceptedAnswerId": "2205394", "Title": "Why doesn't this reinterpret_cast compile?", "CreationDate": "2010-02-05T06:10:04.383", "Id": "2205353", "CommentCount": "4", "FavoriteCount": "10", "PostTypeId": "1", "LastActivityDate": "2015-07-04T07:18:38.270", "Score": "44", "OwnerUserId": "139117", "Tags": "<c++><casting><reinterpret-cast>", "AnswerCount": "9"}, "2206177": {"Id": "2206177", "PostTypeId": "2", "Body": "<p>In C++ <code>reinterpret_cast</code> can only perform a specific set of conversions, explicitly listed in the language specification. In short, <code>reinterpret_cast</code> can only perform pointer-to-pointer conversions and reference-to-reference conversions (plus pointer-to-integer and integer-to-pointer conversions). This is consistent with the intent expressed in the very name of the cast: it is intended to be used for pointer/reference reinterpretation.</p>\n<p>What you are trying to do is not reinterpretation. If you want to reinterpret an <code>int</code> as a <code>double</code> you'd have to convert it to a reference type</p>\n<pre><code>double y = reinterpret_cast&lt;double&amp;&gt;(x); \n</code></pre>\n<p>although the equivalent pointer-based reinterpretation is probably more explicit</p>\n<pre><code>double y = *reinterpret_cast&lt;double*&gt;(&amp;x); // same as above\n</code></pre>\n<p>Note though, that while <code>reinterpret_cast</code> can convert the reference/pointer types, the actual attempt to read the data through the resultant reference/pointer produces undefined behavior. </p>\n<p>And in any case this, of course, can't make much sense on a platform with <code>int</code> and <code>double</code> of different size (since in case of larger <code>double</code> you will read beyond the memory occupied by <code>x</code>).</p>\n<p>So, in the end it all boils down to what you were trying to achieve. Memory reinterpretation? See above. Some kind of more meaningful <code>int</code> to <code>double</code> conversion? If so, <code>reinterpret_cast</code> won't help you here.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2015-07-04T07:18:38.270", "Score": "31", "CreationDate": "2010-02-05T09:30:04.600", "ParentId": "2205353", "CommentCount": "1", "LastEditDate": "2015-07-04T07:18:38.270", "OwnerUserId": "187690"}, "2205368": {"Id": "2205368", "PostTypeId": "2", "Body": "<p>Casting an int to a double doesn't require a cast.  The compiler will perform the assignment implicitly.</p>\n<p>The reinterpret_cast is used with pointers and references, e.g., casting an <code>int *</code> to a <code>double *</code>.</p>\n", "LastActivityDate": "2010-02-05T06:13:15.367", "Score": "0", "CreationDate": "2010-02-05T06:13:15.367", "ParentId": "2205353", "CommentCount": "0", "OwnerUserId": "51170"}});