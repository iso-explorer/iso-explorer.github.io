post_cb({"1635966": {"ParentId": "1635897", "CommentCount": "0", "Body": "<p>C++ Standard in 5.4/2 says that:</p>\n<blockquote>\n<p id=\"so_1635897_1635966_0\">An explicit type conversion can be expressed using functional notation (5.2.3), a type conversion operator (<code>dynamic_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code>, <code>const_cast</code>), or the <em>cast</em> notation.</p>\n<pre><code>   cast-expression:  \n      unary-expression  \n      ( type-id ) cast-expression  \n</code></pre>\n</blockquote>\n<p>You have cast expression here, which calls user defined cast operator.</p>\n", "OwnerUserId": "123111", "PostTypeId": "2", "Id": "1635966", "Score": "2", "CreationDate": "2009-10-28T08:59:48.537", "LastActivityDate": "2009-10-28T08:59:48.537"}, "1635915": {"ParentId": "1635897", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In C++, a C-style cast decides between <code>static_cast</code>, <code>const_cast</code> or <code>reinterpret_cast</code> depending on the type of the argument and the target type.</p>\n<p><strike>if you want a C cast, you need to use <code>reinterpret_cast</code> explicitly.</strike></p>\n<p>If you don't want the default behavior, specitfy the type of cast you want explicitely.</p>\n", "OwnerUserId": "31317", "LastEditorUserId": "31317", "LastEditDate": "2009-10-28T08:53:49.573", "Id": "1635915", "Score": "2", "CreationDate": "2009-10-28T08:48:02.037", "LastActivityDate": "2009-10-28T08:53:49.573"}, "1635928": {"ParentId": "1635897", "CommentCount": "0", "Body": "<p>If you had done <code>(char *)(&amp;b)</code> it would have been C style cast and <code>operator char*</code> will not be called. Here you are trying to cast an object into char*. Since there is no automatic conversion compiler looks for operator char* provided by you. If you had not provided it, you'll get a compiler error saying that <code>Buffer</code> can not be converted into <code>char*</code></p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "1635928", "Score": "4", "CreationDate": "2009-10-28T08:50:48.397", "LastActivityDate": "2009-10-28T08:50:48.397"}, "1636014": {"ParentId": "1635897", "CommentCount": "0", "Body": "<p>C-style casts in C++ really mean: Hey compiler, why don't you help me out here and figure out how best to convert to the target type? And, the compiler obliges. Here you have a conversion operator specified, which gets called because that's what the compiler thinks is best. </p>\n<p>Note, that this neat little trick (of using C-style casts) should not be used until and unless you are absolutely sure of what you are trying to achieve.</p>\n", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "1636014", "Score": "0", "CreationDate": "2009-10-28T09:10:01.710", "LastActivityDate": "2009-10-28T09:10:01.710"}, "1635897": {"CommentCount": "1", "ViewCount": "503", "CreationDate": "2009-10-28T08:43:27.277", "LastActivityDate": "2009-10-28T09:16:21.790", "Title": "C++ object and C style cast question", "AcceptedAnswerId": "1635928", "PostTypeId": "1", "Id": "1635897", "Score": "0", "Body": "<p>I have the following code compiled by gcc:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n\nclass Buffer {\npublic:\n   operator char *() { cout &lt;&lt; \"operator const * called\" &lt;&lt; endl; return buff; }\nprivate:\n    char buff[1024];\n};\n\n\nint main(int, char**) {\n    Buffer b;\n    (char *)b;  // Buffer::operator char * is called here\n\n    return 0;\n}\n</code></pre>\n<p>What I see is that Buffer::operator char * is called on line:</p>\n<pre><code>(char *)b; \n</code></pre>\n<p>Why C style cast calls Buffer::operator char * is called here? </p>\n<p>I though that </p>\n<pre><code>static_cast&lt;char *&gt;(b);\n</code></pre>\n<p>should be used in order to invoke explicitly Buffer::operator char *.</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "135960", "AnswerCount": "5"}, "1636040": {"ParentId": "1635897", "CommentCount": "0", "Body": "<p>C-style casts makes compiler performs <code>static_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code> or some combination of them. To be more precise:</p>\n<blockquote>\n<p id=\"so_1635897_1636040_0\">The conversions performed by</p>\n<pre><code>* a const_cast (expr.const.cast), \n\n* a static_cast (expr.static.cast), \n\n* a static_cast followed by a const_cast, \n\n* a reinterpret_cast (expr.reinterpret.cast), or \n\n* a reinterpret_cast followed by a const_cast, \n</code></pre>\n<p id=\"so_1635897_1636040_1\">can be performed using the cast\n  notation of explicit type conversion.\n  The same semantic restrictions and\n  behaviors apply. If a conversion can\n  be interpreted in more than one of the\n  ways listed above, the interpretation\n  that appears first in the list is\n  used, even if a cast resulting from\n  that interpretation is ill-formed. If\n  a conversion can be interpreted in\n  more than one way as a static_cast\n  followed by a const_cast, the\n  conversion is ill-formed</p>\n</blockquote>\n<p>As the rules are bit complicated it's better to avoid C-style casts in order to be sure what exactly is done.</p>\n", "OwnerUserId": "113662", "PostTypeId": "2", "Id": "1636040", "Score": "2", "CreationDate": "2009-10-28T09:16:21.790", "LastActivityDate": "2009-10-28T09:16:21.790"}, "bq_ids": {"n4140": {"so_1635897_1635966_0": {"section_id": 6124, "quality": 0.8888888888888888, "length": 16}, "so_1635897_1636040_1": {"section_id": 6126, "quality": 0.9772727272727273, "length": 43}}, "n3337": {"so_1635897_1635966_0": {"section_id": 5888, "quality": 0.8888888888888888, "length": 16}, "so_1635897_1636040_1": {"section_id": 5890, "quality": 0.9772727272727273, "length": 43}}, "n4659": {"so_1635897_1635966_0": {"section_id": 7621, "quality": 0.8888888888888888, "length": 16}, "so_1635897_1636040_1": {"section_id": 7623, "quality": 0.9772727272727273, "length": 43}}}});