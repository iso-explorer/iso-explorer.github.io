post_cb({"16637132": {"ParentId": "16637074", "CommentCount": "7", "CreationDate": "2013-05-19T16:59:30.283", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "16637132", "Score": "7", "Body": "<p>The reason it's undefined is because there's no guarantee what exactly the value representations of <code>int</code> and <code>float</code> are. The C++ standard doesn't say that a <code>float</code> is stored as an IEEE 754 single-precision floating point number. What exactly should the standard say about you treating an <code>int</code> object with value <code>0xffff</code> as a <code>float</code>? It doesn't say anything other than the fact it is undefined.</p>\n<p>Practically, however, this is the purpose of <code>reinterpret_cast</code> - to tell the compiler to ignore everything it knows about the types of objects and trust you that this <code>int</code> is actually a <code>float</code>. It's almost always used for machine-specific bit-level jiggery-pokery. The C++ standard just doesn't guarantee you anything once you do it. At that point, it's up to you to understand exactly what your compiler and machine do in this situation.</p>\n<p>This is true for both the <code>union</code> and <code>reinterpret_cast</code> approaches. I suggest that <code>reinterpret_cast</code> is \"better\" for this task, since it makes the intent clearer. However, keeping your code well-defined is always the best approach.</p>\n", "LastActivityDate": "2013-05-19T16:59:30.283"}, "16637183": {"ParentId": "16637074", "CommentCount": "0", "CreationDate": "2013-05-19T17:04:49.387", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "16637183", "Score": "2", "Body": "<p>Undefined behavior does not mean bad things must happen. It means <strong>only</strong> that the language definition doesn't tell you what happens. This kind of type pun has been part of C and C++ programming since time immemorial (i.e., since 1969); it would take a particularly perverse implementor to write a compiler where this didn't work.</p>\n", "LastActivityDate": "2013-05-19T17:04:49.387"}, "16637074": {"CommentCount": "1", "AcceptedAnswerId": "16637132", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-05-19T16:52:37.163", "LastActivityDate": "2013-05-19T17:34:34.813", "LastEditDate": "2017-05-23T12:34:27.913", "ViewCount": "3653", "FavoriteCount": "3", "Title": "C++ unions vs. reinterpret_cast", "Id": "16637074", "Score": "16", "Body": "<p>It appears from <a href=\"https://stackoverflow.com/questions/6136010/is-using-an-union-in-place-of-a-cast-well-defined\">other StackOverflow questions</a> and reading \u00a79.5.1 of the <a href=\"https://github.com/cplusplus/draft\" rel=\"nofollow noreferrer\">ISO/IEC draft C++ standard</a> standard that the use of unions to do a literal <code>reinterpret_cast</code> of data is undefined behavior.</p>\n<p>Consider the code below.  The goal is to take the integer value of <code>0xffff</code> and literally interpret it as a series of bits in IEEE 754 floating point.  (<a href=\"http://www.binaryconvert.com/result_float.html?hexadecimal=0000FFFF\" rel=\"nofollow noreferrer\">Binary convert shows visually how this is done.</a>)</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nunion unionType {\n    int myInt;\n    float myFloat;\n};\n\nint main() {\n\n    int i = 0xffff;\n\n    unionType u;\n    u.myInt = i;\n\n    cout &lt;&lt; \"size of int    \" &lt;&lt; sizeof(int) &lt;&lt; endl;\n    cout &lt;&lt; \"size of float  \" &lt;&lt; sizeof(float) &lt;&lt; endl;\n\n    cout &lt;&lt; \"myInt          \" &lt;&lt; u.myInt &lt;&lt; endl;\n    cout &lt;&lt; \"myFloat        \" &lt;&lt; u.myFloat &lt;&lt; endl;\n\n    float theFloat = *reinterpret_cast&lt;float*&gt;(&amp;i);\n    cout &lt;&lt; \"theFloat       \" &lt;&lt; theFloat &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>The output of this code, using both GCC and clang compilers is expected.</p>\n<pre><code>size of int    4\nsize of float  4\nmyInt          65535\nmyFloat        9.18341e-41\ntheFloat       9.18341e-41\n</code></pre>\n<p>My question is, does the standard actually preclude the value of <code>myFloat</code> from being deterministic?  Is the use of a <code>reinterpret_cast</code> <em>better</em> in any way to perform this type of conversion?</p>\n<p>The standard states the following in \u00a79.5.1:</p>\n<blockquote>\n<p id=\"so_16637074_16637074_0\">In a union, <strong>at most one of the non-static data members can be active at any time, that is, the value of at most one of the non-static data members can be stored in a union at any time.</strong> [...] The size of a union is sufficient to contain the largest of its non-static data members. Each non-static data member is allocated as if it were the sole member of a struct. <strong>All non-static data members of a union object have the same address.</strong></p>\n</blockquote>\n<p>The last sentence, guaranteeing that all non-static members have the same address, seems to indicate the use of a union is <em>guaranteed</em> to be identical to the use of a <code>reinterpret_cast</code>, but the earlier statement about active data members seems to preclude this guarantee.</p>\n<p>So which construct is more correct?</p>\n<p><strong>Edit:</strong>\nUsing Intel's <code>icpc</code> compiler, the above code produces even more interesting results:</p>\n<pre><code>$ icpc union.cpp\n$ ./a.out\nsize of int    4\nsize of float  4\nmyInt          65535\nmyFloat        0\ntheFloat       0\n</code></pre>\n", "Tags": "<c++><unions><reinterpret-cast>", "OwnerUserId": "2350293", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_16637074_16637074_0": {"section_id": 5913, "quality": 0.9787234042553191, "length": 46}}, "n3337": {"so_16637074_16637074_0": {"section_id": 5685, "quality": 0.7872340425531915, "length": 37}}, "n4659": {"so_16637074_16637074_0": {"section_id": 7405, "quality": 0.5531914893617021, "length": 26}}}, "16637489": {"ParentId": "16637074", "CommentCount": "4", "CreationDate": "2013-05-19T17:34:34.813", "OwnerUserId": "2355605", "PostTypeId": "2", "Id": "16637489", "Score": "4", "Body": "<p>It's not undefined behavior.  It's implementation defined behavior.  The first does mean that bad things can happen.  The other means that what will happen has to be defined by the implementation.</p>\n<p>The reinterpret_cast violates the strict aliasing rule.  So I do not think it will work reliably.  The union trick is what people call <code>type-punning</code> and is usually allowed by compilers.  The gcc folks document the behavior of the compiler: <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Structures-unions-enumerations-and-bit_002dfields-implementation.html#Structures-unions-enumerations-and-bit_002dfields-implementation\" rel=\"nofollow\">http://gcc.gnu.org/onlinedocs/gcc/Structures-unions-enumerations-and-bit_002dfields-implementation.html#Structures-unions-enumerations-and-bit_002dfields-implementation</a></p>\n<p>I think this should work with icpc as well (but they do not appear to document how they implemented that).  But when I looked the assembly, it looks like icc tries to cheat with float and use higher precision floating point stuff.  Passing <code>-fp-model source</code> to the compiler fixed that.  With that option, I get the same results as with gcc.\nI do not think you want to use this flag in general, this is just a test to verify my theory.</p>\n<p>So for icpc, I think if you switch your code from int/float to long/double, type-punning will work on icpc as well.</p>\n", "LastActivityDate": "2013-05-19T17:34:34.813"}});