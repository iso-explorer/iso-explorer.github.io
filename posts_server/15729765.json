post_cb({"15733718": {"Id": "15733718", "PostTypeId": "2", "Body": "<p>The rule in C and C++ is that the result of a right-shift of a negative value is implementation defined. So read your compiler's documentation. The various explanations you've gotten are valid approaches, but none of these is mandated by the language definition.</p>\n", "LastActivityDate": "2013-03-31T19:43:54.893", "Score": "0", "CreationDate": "2013-03-31T19:43:54.893", "ParentId": "15729765", "CommentCount": "0", "OwnerUserId": "1593860"}, "15729765": {"ViewCount": "1484", "Body": "<p>following <a href=\"https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array\">this</a> Q&amp;A I tried to exam the answer so I wrote:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main ()\n{\n\n        int t;int i;\n        for (i=120;i&lt;140;i++){\n                t = (i - 128) &gt;&gt; 31;\n                printf (\"t = %X , i-128 = %X ,  ~t &amp; i = %X , ~t = %X \\n\", t, i-128 , (~t &amp;i), ~t);\n        }\n\n        return 0;\n}\n</code></pre>\n<p>and the Output is:</p>\n<pre><code>t = FFFFFFFF , i-128 = FFFFFFF8 ,  ~t &amp; i = 0 , ~t = 0 \nt = FFFFFFFF , i-128 = FFFFFFF9 ,  ~t &amp; i = 0 , ~t = 0 \nt = FFFFFFFF , i-128 = FFFFFFFA ,  ~t &amp; i = 0 , ~t = 0 \nt = FFFFFFFF , i-128 = FFFFFFFB ,  ~t &amp; i = 0 , ~t = 0 \nt = FFFFFFFF , i-128 = FFFFFFFC ,  ~t &amp; i = 0 , ~t = 0 \nt = FFFFFFFF , i-128 = FFFFFFFD ,  ~t &amp; i = 0 , ~t = 0 \nt = FFFFFFFF , i-128 = FFFFFFFE ,  ~t &amp; i = 0 , ~t = 0 \nt = FFFFFFFF , i-128 = FFFFFFFF ,  ~t &amp; i = 0 , ~t = 0 \nt = 0 , i-128 = 0 ,  ~t &amp; i = 80 , ~t = FFFFFFFF \nt = 0 , i-128 = 1 ,  ~t &amp; i = 81 , ~t = FFFFFFFF \nt = 0 , i-128 = 2 ,  ~t &amp; i = 82 , ~t = FFFFFFFF \nt = 0 , i-128 = 3 ,  ~t &amp; i = 83 , ~t = FFFFFFFF \nt = 0 , i-128 = 4 ,  ~t &amp; i = 84 , ~t = FFFFFFFF \nt = 0 , i-128 = 5 ,  ~t &amp; i = 85 , ~t = FFFFFFFF \nt = 0 , i-128 = 6 ,  ~t &amp; i = 86 , ~t = FFFFFFFF \nt = 0 , i-128 = 7 ,  ~t &amp; i = 87 , ~t = FFFFFFFF \nt = 0 , i-128 = 8 ,  ~t &amp; i = 88 , ~t = FFFFFFFF \nt = 0 , i-128 = 9 ,  ~t &amp; i = 89 , ~t = FFFFFFFF \nt = 0 , i-128 = A ,  ~t &amp; i = 8A , ~t = FFFFFFFF \nt = 0 , i-128 = B ,  ~t &amp; i = 8B , ~t = FFFFFFFF \n</code></pre>\n<p>Why does <code>~t</code> of any negative number is <code>-1 == 0xFFFFFFFF</code> if <code>t</code> declared as integer ?</p>\n", "AcceptedAnswerId": "15730750", "Title": "Sign extension with bitwise shift operation", "CreationDate": "2013-03-31T13:19:39.483", "Id": "15729765", "CommentCount": "13", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:36.900", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-21T09:37:26.090", "Score": "5", "OwnerUserId": "1031417", "Tags": "<c++><c><bit-manipulation>", "AnswerCount": "5"}, "15730750": {"Id": "15730750", "PostTypeId": "2", "Body": "<p>From: <a href=\"https://stackoverflow.com/questions/1857928/right-shifting-negative-numbers-in-c\">Right shifting negative numbers in C</a></p>\n<p><strong>Edit:</strong>  According to the Section 6.5.7 of the latest <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1336.pdf\" rel=\"nofollow noreferrer\">draft standard</a>, this behavior on negative numbers is implementation dependent:<blockquote id=\"so_15729765_15730750_0\">The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2<sup>E2</sup>. If E1 has a signed type and a negative value, the resulting value is implementation-defined.</blockquote></p>\n<p>And, your implementation is probably doing an Arithmetic Shift with two's complement numbers</p>\n<hr>\n<p>Operator <code>&gt;&gt;</code> as  <strong>Signed right shift</strong> or <strong>arithmetic right shift</strong>, shift all the bits to right a specified number of times. Important is <code>&gt;&gt;</code>  fills leftmost sign bit (Most Significant Bit MSB) to leftmost bit the after shift. This is called <em>sign extension</em> and serves to <em>preserve the sign</em> of negative numbers when you shift them right.    </p>\n<p>Below is my diagrammatic representation with an example to show how this works (for one byte):<br>\nExample: </br></p>\n<pre><code>i = -5 &gt;&gt; 3;  shift bits right three time \n</code></pre>\n<p>Five in two's complement form is <code>1111 1011</code>  Memory Representation:  </p>\n<pre><code> MSB\n+----+----+----+---+---+---+---+---+\n|  1 |  1 | 1  | 1 | 1 | 0 | 1 | 1 |   \n+----+----+----+---+---+---+---+---+\n   7    6   5    4   3   2   1   0  \n  ^  This seventh, the left most bit is SIGN bit  \n</code></pre>\n<p>And below is, how <code>&gt;&gt;</code> works? When you do <code>-5 &gt;&gt; 3</code> </p>\n<pre><code>                        this 3 bits are shifted \n                         out and loss\n MSB                   (___________)      \n+----+----+----+---+---+---+---+---+\n|  1 |  1 | 1  | 1 | 1 | 0 | 1 | 1 |   \n+----+----+----+---+---+---+---+---+\n  | \\                 \\  \n  |  ------------|     ----------|\n  |              |               |\n  \u25bc              \u25bc               \u25bc\n+----+----+----+---+---+---+---+---+\n|  1 |  1 | 1  | 1 | 1 | 1 | 1 | 1 |\n+----+----+----+---+---+---+---+---+\n(______________)\n The sign is        \n propagated\n</code></pre>\n<p>Notice: the left most three bits are one because on each shift sign bit is preserved and each bit is right too. I have written <em>The sign is propagated</em> because all this three bits are because of sign(but not data).   </p>\n<p><strong>[ANSWER]</strong><br>\nIn your output in   </br></p>\n<p><strong>first Eight  lines</strong> </p>\n<pre><code>      ~t is 0\n==&gt;    t is FFFFFFFF \n==&gt;    t is -1\n</code></pre>\n<p>(Note: <em>2's complement of -1 is <code>FFFFFFFF</code>, because <code>1 = 00000001</code>, 1's complement of 1 is <code>FFFFFFFE</code>, and 2's complement = 1's complement  + 1 that is: <code>FFFFFFFE</code> + <code>00000001</code> =  <code>FFFFFFFF</code></em>)</p>\n<p>So <code>t</code> is always evaluated <code>-1</code> in first eight times in loop. <strong>Yes</strong>, How ? </p>\n<p>In for loop </p>\n<pre><code>for (i=120;i&lt;140;i++){\n     t = (i - 128) &gt;&gt; 31;\n</code></pre>\n<p>values of <code>i</code> for first eight time is <code>i = 120, 121, 122, 123, 124, 125, 126 ,127</code> all eight values are <em>less then 128</em>. So return of  <code>(i - 128) = -8, -7, -6, -5, -4, -3, -2, -1</code>. hence in first eight times expression  <code>t = (i - 128) &gt;&gt; 31</code> shift-rights a negative number. </p>\n<pre><code>t =   (i - 128)  &gt;&gt; 31\nt =  -ve number  &gt;&gt; 31\n</code></pre>\n<p>Because in your system int is of 4 bytes = 32 bits, all right most <code>31</code> bits are shift-out and loss and <em>due to propagation of sign bit that is <code>1</code> for negative number all bits value becomes <code>1</code></em>. (as I have shown in above figure for one byte)</p>\n<p>So for fist eight times: </p>\n<pre><code>    t =  -ve number  &gt;&gt; 31 ==  -1 \n    t = -1\n  and this gives \n    ~t = 0\n</code></pre>\n<p>Hence output of fist eight times for ~t is 0. </p>\n<p><strong>For remaining last lines</strong> </p>\n<pre><code>      ~t is FFFFFFFF\n==&gt;   ~t is -1   \n==&gt;    t is 0 \n</code></pre>\n<p>For remaining last lines, in for loop </p>\n<pre><code>for (i=120;i&lt;140;i++){\n     t = (i - 128) &gt;&gt; 31;\n</code></pre>\n<p>i values are <code>128, 129, 130, 132, 133, 134, 135, 136, 137, 138, 139,</code> <em>all are greater then or equals to</em> 128. and sign bit is <code>0</code>. </p>\n<p>So (i - 128) for remaining last lines is <code>&gt;=0</code> and for all this MSB sign bit = <code>0</code>. And because again you shifts right 31 times all bits excepts then sigh bit shift-out and sign bit <code>0</code> propagates and fills all bits with <code>0</code> and magnitude becomes <code>0</code>. </p>\n<p>I think it would be good if I write an example for a positive number too. So we take an example  <code>5 &gt;&gt; 3</code> and five is one byte is <code>0000 0101</code> </p>\n<pre><code>                        this 3 bits are shifted \n                         out and loss\n MSB                   (___________)      \n+----+----+----+---+---+---+---+---+\n|  0 |  0 | 0  | 0 | 0 | 1 | 0 | 1 |   \n+----+----+----+---+---+---+---+---+\n  | \\                 \\  \n  |  ------------|     ----------|\n  |              |               |\n  \u25bc              \u25bc               \u25bc\n+----+----+----+---+---+---+---+---+\n|  0 |  0 | 0  | 0 | 0 | 0 | 0 | 0 |\n+----+----+----+---+---+---+---+---+\n(______________)\n The sign is        \n propagated\n</code></pre>\n<p>See again I writes <em>The sign is propagated</em>, So leftmost three zeros are due to sign bit. </p>\n<p>So this is what operator <code>&gt;&gt;</code> <strong>Signed right shift</strong> do, and <strong>preserves the sign</strong> of left operand.   </p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-02T16:13:01.433", "Score": "3", "CreationDate": "2013-03-31T15:00:27.543", "ParentId": "15729765", "CommentCount": "5", "LastEditDate": "2017-05-23T11:44:16.657", "OwnerUserId": "1673391"}, "bq_ids": {"n4140": {"so_15729765_15730750_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 6148}, "so_15729765_15730055_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4856}}, "n3337": {"so_15729765_15730750_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5911}, "so_15729765_15730055_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4651}}, "n4659": {"so_15729765_15730750_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7644}, "so_15729765_15730055_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5888}}}, "15729847": {"Id": "15729847", "PostTypeId": "2", "Body": "<p>Becaue <code>t</code> is either 0 or -1, ~t is also always -1 or 0. </p>\n<p>This is due to the (implementation defined) behaviour or <code>(i - 128) &gt;&gt; 31</code>, which essentially copies the top bit of (i-128) [assuming 32-bit integers]. If <code>i</code> is &gt; 128, it will result in a zero in the top bit. If <code>i</code> is less than 128, the result is negative, so the top bit is set. </p>\n<p>Since <code>~t</code> is \"all bits opposite of <code>t</code>\", you can expect that <code>t</code> is always 0xffffffff if <code>t</code> is zero. </p>\n", "LastActivityDate": "2013-03-31T13:29:06.427", "Score": "2", "CreationDate": "2013-03-31T13:29:06.427", "ParentId": "15729765", "CommentCount": "1", "OwnerUserId": "1919155"}, "15730055": {"Id": "15730055", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15729765_15730055_0\">Why does t = (i - 128) &gt;&gt; 31 gives zero or -1 for each number?</p>\n</blockquote>\n<p>When a non-negative 32-bit integer is shifted right 31 positions, all non-zero bits get shifted out and the most significant bits get filled with 0, so you end up with 0.</p>\n<p>Usually, when a negative 32-bit integer is shifted right 31 positions, the most significant bits don't get filled with 0, instead they get set to the sign of the number and so the sign propagates into all bits and in 2's complement representation all bits set to 1 amount to -1. The net effect is as if you repeatedly divided the number by 2, but with a little twist... The result is rounded towards -infinity instead of towards 0. For example <code>-2&gt;&gt;1==-1</code> but <code>-3&gt;&gt;1==-2</code> and <code>-5&gt;&gt;1==-3</code>. This is called <em>arithmetic right shift</em>.</p>\n<p>When I say \"usually\", I mean the fact that the C standard allows several different behaviors for right shifts of negative values. On top of that, it allows non-2's complement representations of signed integers. Usually, however, you have the 2's complement representation and the behavior that I've showed/explained above.</p>\n", "LastActivityDate": "2013-03-31T13:48:18.757", "Score": "4", "CreationDate": "2013-03-31T13:48:18.757", "ParentId": "15729765", "CommentCount": "0", "OwnerUserId": "968261"}, "15730463": {"Id": "15730463", "PostTypeId": "2", "Body": "<p>The <code>&gt;&gt;</code> operator, right shift, is arithmetic right shift in most compilers, meaning divide-by-2.</p>\n<p>So, if, e.g. <code>int i ==-4</code> (0xfffffffc), then <code>i&gt;&gt;1 == -2</code> (0xfffffffe).</p>\n<p>Having said this, I would recommend you to check the assembly of your code.<br/>\ne.g. x86 has 2 separate instructions - <code>shr</code> &amp; <code>sar</code>, denoting logical shift &amp; arithmetic shift respectively.<br/>\nGenerally, compilers use <code>shr</code> (logical shift) for unsigned variables &amp; <code>sar</code> (arithmetic shift) for signed variables.</p>\n<hr>\n<p>Below is the C code &amp; corresponding assembly, generated with <code>gcc -S</code>:</p>\n<p>a.c:</p>\n<pre><code>int x=10;\nunsigned int y=10;\n\nint main(){\n    unsigned int z=(x&gt;&gt;1)+(y&gt;&gt;1);\n    return 0;\n}\n</code></pre>\n<p>a.s:</p>\n<pre><code>    .file   \"a.c\"\n.globl x\n    .data\n    .align 4\n    .type   x, @object\n    .size   x, 4\nx:\n    .long   10\n.globl y\n    .align 4\n    .type   y, @object\n    .size   y, 4\ny:\n    .long   10\n    .text\n.globl main\n    .type   main, @function\nmain:\n    pushl   %ebp\n    movl    %esp, %ebp\n    subl    $16, %esp\n    movl    x, %eax\n    sarl    %eax ; &lt;~~~~~~~~~~~~~~~~ Arithmetic shift, for signed int\n    movl    y, %edx\n    shrl    %edx ; &lt;~~~~~~~~~~~~~~~~ Logical shift, for unsigned int\n    addl    %edx, %eax\n    movl    %eax, -4(%ebp)\n    movl    $0, %eax\n    leave\n    ret\n    .size   main, .-main\n    .ident  \"GCC: (Ubuntu/Linaro 4.5.2-8ubuntu4) 4.5.2\"\n    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n</hr>", "LastEditorUserId": "793796", "LastActivityDate": "2013-03-31T14:36:52.627", "Score": "1", "CreationDate": "2013-03-31T14:30:41.210", "ParentId": "15729765", "CommentCount": "0", "LastEditDate": "2013-03-31T14:36:52.627", "OwnerUserId": "793796"}});