post_cb({"43607151": {"ParentId": "43606777", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>While this is indeed a valid copy constructor, the <code>is_copy_constructible</code> type-trait is defined to give the same result as <code>is_constructible_v&lt;T, const T&amp;&gt;</code>, because it is intended to correspond to the <code>CopyConstructible</code> concept that is also defined by the standard. </p>\n<p>In <a href=\"http://eel.is/c++draft/utility.arg.requirements#1\" rel=\"nofollow noreferrer\">[utility.arg.requirements]/1</a> it says</p>\n<blockquote>\n<p id=\"so_43606777_43607151_0\">The template definitions in the C++ standard library refer to various named requirements whose details are set out in Tables 20\u201327. In these tables, <code>T</code> is an object or reference type to be supplied by a C++ program instantiating a template;[...] and v is an lvalue of type (<strong>possibly const</strong>) T or an rvalue of type const T.</p>\n</blockquote>\n<p>The CopyConstructible concept is defined in <a href=\"http://eel.is/c++draft/utility.arg.requirements#tab:copyconstructible\" rel=\"nofollow noreferrer\">Table 24</a> as</p>\n<blockquote>\n<p id=\"so_43606777_43607151_1\">Table 24 \u2014 CopyConstructible requirements (in addition to MoveConstructible)<br>\n  Expression \u00a0\u00a0\u00a0    Post-condition <br>\n  T u = v;    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 the value of v is unchanged and is equivalent to u <br>\n  T(v)    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the value of v is unchanged and is equivalent to T(v)</br></br></br></p>\n</blockquote>\n<p>Therefore, since your object is not constructible from a <code>const Foo</code> lvalue, which is one of the requirements of <code>CopyConstructible</code>, it is not regarded as such.</p>\n", "OwnerUserId": "3601321", "LastEditorUserId": "3601321", "LastEditDate": "2017-04-25T10:11:33.880", "Id": "43607151", "Score": "3", "CreationDate": "2017-04-25T09:47:05.853", "LastActivityDate": "2017-04-25T10:11:33.880"}, "bq_ids": {"n4140": {"so_43606777_43607151_1": {"section_id": 6276, "quality": 0.7692307692307693, "length": 10}, "so_43606777_43607151_0": {"section_id": 6275, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_43606777_43607151_1": {"section_id": 6036, "quality": 0.7692307692307693, "length": 10}, "so_43606777_43607151_0": {"section_id": 6035, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_43606777_43607151_1": {"section_id": 7783, "quality": 0.6153846153846154, "length": 8}, "so_43606777_43607151_0": {"section_id": 7782, "quality": 0.9285714285714286, "length": 26}}}, "43606777": {"CommentCount": "5", "AcceptedAnswerId": "43607151", "CreationDate": "2017-04-25T09:30:47.740", "LastActivityDate": "2017-04-25T10:11:33.880", "PostTypeId": "1", "ViewCount": "107", "FavoriteCount": "1", "Title": "Why is class with non-const copy constructor not treated as copy constructible?", "Id": "43606777", "Score": "4", "Body": "<p>Given </p>\n<pre><code>struct Foo \n{\n    Foo(Foo&amp;) {} \n};\n</code></pre>\n<p><code>std::is_copy_constructible&lt;Foo&gt;::value</code> is <code>false</code></p>\n<p>Foo has valid copy-constructor: From draft n4659:</p>\n<pre><code>15.8.1 Copy/move constructors [class.copy.ctor]\n1\nA non-template constructor for class X is a copy constructor if its first parameter is of type X&amp; , const X&amp; ,\nvolatile X&amp; or const volatile X&amp; , and either there are no other parameters or else all other parameters\nhave default arguments (11.3.6). [Example: X::X(const X&amp;) and X::X(X&amp;,int=1) are copy constructors.\n</code></pre>\n<p>but <code>is_copy_constructible</code> tests <code>is_constructible_v&lt;T, const T&amp;&gt;</code> (<strong>const</strong>) according to the standard.</p>\n<p>Why is class with non-const copy constructor not  treated as copy constructible?</p>\n", "Tags": "<c++><copy-constructor>", "OwnerUserId": "680031", "AnswerCount": "1"}});