post_cb({"bq_ids": {"n4140": {"so_36532687_36532978_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 5768}, "so_36532687_36532978_1": {"length": 76, "quality": 0.9047619047619048, "section_id": 3241}}, "n3337": {"so_36532687_36532978_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 5541}, "so_36532687_36532978_1": {"length": 76, "quality": 0.9047619047619048, "section_id": 3114}}, "n4659": {"so_36532687_36532978_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 7225}, "so_36532687_36532978_1": {"length": 70, "quality": 0.8333333333333334, "section_id": 3997}}}, "36532978": {"Id": "36532978", "PostTypeId": "2", "Body": "<p>The top-level const and volatile qualifiers should be ignored for the purposes of name mangling.  This can be determined from two things in the standard.  The first, is that a function's signature is used for name mangling.</p>\n<p>In the C++14 standard, section 1.3.17 defines a signature:</p>\n<blockquote>\n<p id=\"so_36532687_36532978_0\"> name, <strong>parameter type list (8.3.5)</strong>, and enclosing namespace (if any) [ <strong>Note: Signatures are used as a basis for name mangling and linking.</strong> \u2014 end note ]</p>\n</blockquote>\n<p>To get the definition of a parameter type list, we then refer to section 8.3.5/5:</p>\n<blockquote>\n<p id=\"so_36532687_36532978_1\">The type of a function is determined using the following rules. The type of each parameter\n  (including function parameter packs) is determined from its own decl-specifier-seq and declarator. After\n  determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is\n  adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively. After producing the list\n  of parameter types, <strong>any top-level cv-qualifiers modifying a parameter type are deleted when forming the\n  function type</strong>. The resulting list of transformed parameter types and the presence or absence of the ellipsis\n  or a function parameter pack is the function\u2019s <strong>parameter-type-list</strong>. [ Note: This transformation does not\n  affect the types of the parameters. For example, int(<em>)(const int p, decltype(p)</em>) and int(<em>)(int,\n  const int</em>) are identical types. \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "951890", "LastActivityDate": "2016-04-10T17:37:41.943", "Score": "3", "CreationDate": "2016-04-10T17:20:55.103", "ParentId": "36532687", "CommentCount": "0", "LastEditDate": "2016-04-10T17:37:41.943", "OwnerUserId": "951890"}, "36532687": {"ViewCount": "90", "Body": "<p>Regarding <a href=\"https://stackoverflow.com/questions/117293/use-of-const-for-function-parameters\">using <code>const</code> function parameters</a> I've heard that on some OS X systems the constness of a parameter is mangled into the function signature. For example, if one would have the following declaration in an interface header file:</p>\n<pre><code>int f(int argument);\n</code></pre>\n<p>but if one would only implement this function:</p>\n<pre><code>int f(int const argument);\n</code></pre>\n<p>then this might lead to a linking failures on OS X (but not on Linux) because the OS X way to mangle C++ function signatures includes the constness of the parameters.</p>\n<p>Which is the correct mangling behaviour? Does the C++ standard have a say on this?</p>\n", "AcceptedAnswerId": "36532978", "Title": "Is function parameter constness mismatch allowed?", "CreationDate": "2016-04-10T16:55:56.787", "Id": "36532687", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2016-04-10T17:37:41.943", "Score": "3", "OwnerUserId": "3919155", "Tags": "<c++><osx><abi><name-mangling>", "AnswerCount": "1"}});