post_cb({"bq_ids": {"n4140": {"so_31800065_31800404_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3481}, "so_31800065_31800404_1": {"length": 38, "quality": 0.926829268292683, "section_id": 4907}}, "n3337": {"so_31800065_31800404_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3346}, "so_31800065_31800404_1": {"length": 38, "quality": 0.926829268292683, "section_id": 4702}}, "n4659": {"so_31800065_31800404_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6309}, "so_31800065_31800404_1": {"length": 38, "quality": 0.926829268292683, "section_id": 6316}}}, "31800404": {"Id": "31800404", "PostTypeId": "2", "Body": "<p><code>&lt;complex.h&gt;</code> is a C header and it is not compatible with C++.</p>\n<p>C++ defines C library compatibility through headers named in the pattern <code>&lt;c***&gt;</code>. So, the C++ counterpart to <code>&lt;complex.h&gt;</code> is named <code>&lt;ccomplex&gt;</code>. Here's what the C++ standard has to say about that:</p>\n<blockquote>\n<h3>Header <code>&lt;ccomplex&gt;</code></h3>\n<p id=\"so_31800065_31800404_0\">The header behaves as if it simply includes the header <code>&lt;complex&gt;</code>.</p>\n</blockquote>\n<p>If you attempt to use the C complex number library, you just get the C++ one instead.</p>\n<p>Bottom line: you simply cannot run C complex math through a C++ compiler. At best, you can use the preprocessor to generate equivalent programs depending on <code>__cplusplus</code>.</p>\n<p>For example,</p>\n<pre><code>#if __cplusplus\n#   include &lt;complex&gt;\n    typedef std::complex&lt; double &gt; cdouble;\n#else\n#   include &lt;complex.h&gt;\n    typedef double complex cdouble;\n#endif\n</code></pre>\n<p>Note, <code>std::complex&lt; double &gt;</code> and <code>double complex</code> are layout-compatible per C++14 [complex.numbers] \u00a726.4/4 and C11 \u00a76.2.5/13. The intent seems to be that you can use <code>cdouble</code> for cross-language function prototypes, although strictly speaking it depends on the ABI.</p>\n<hr>\n<p>Incidentally, the C++ standard does define what happens when you <code>#include &lt;complex.h&gt;</code>, but it doesn't make any sense:</p>\n<blockquote>\n<p id=\"so_31800065_31800404_1\">Every C header, each of which has a name of the form <code>name.h</code>, behaves as if each name placed in the standard library namespace by the corresponding <em><code>cname</code></em> header is placed within the global namespace scope. It is unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace <code>std</code> and are then injected into the global namespace scope by explicit <em>using-declarations</em> (7.3.3).</p>\n</blockquote>\n<p>So, <code>#include &lt;complex.h&gt;</code> should give you a global <code>::complex&lt;T&gt;</code>. This is a defect in the standard.</p>\n</hr>", "LastEditorUserId": "153285", "LastActivityDate": "2015-08-05T08:30:49.923", "Score": "2", "CreationDate": "2015-08-04T03:54:00.880", "ParentId": "31800065", "CommentCount": "3", "OwnerUserId": "153285", "LastEditDate": "2015-08-05T08:30:49.923"}, "31800065": {"ViewCount": "507", "Body": "<h3>Notes:</h3>\n<p>I am compiling on OSX using Apple LLVM version 6.0 (clang-600.0.56) (based on LLVM 3.5svn)</p>\n<p>Specifically, I am trying to compile a monolithic source from LibIIR, a filter library maintained <a href=\"http://www.lwithers.me.uk/usr/src/libiir/\" rel=\"nofollow noreferrer\">here</a> by Laurence Withers.</p>\n<p>I've already looked at this answer <a href=\"https://stackoverflow.com/questions/23414270/c-complex-and-complex-h-in-the-same-file\">here</a> about using both <code>&lt;complex&gt;</code> and <code>&lt;complex.h&gt;</code> in the <em>same file</em>.</p>\n<hr>\n<h3>Setup:</h3>\n<p>I have a file <code>iir.h</code> like so:</p>\n<pre><code>#include &lt;complex.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n...\n</code></pre>\n<p>I have C++ source and header files <code>libiir++.cpp</code> and <code>iir++.h</code> like so:</p>\n<pre><code>/*** libiir++.cpp ***/\n// we need to include \"iir.h\" first, as it pulls in &lt;complex.h&gt;, which we need\n// to take effect before \"iir++.h\" pulls in &lt;complex&gt;\n#include \"iir.h\"\n\n// now remove the preprocessor definition of complex to _Complex, which is fine\n// for the C header but not good for the C++ header\n#undef complex\n\n#include \"iir++.h\"\n\nnamespace IIR {\n\n...\n</code></pre>\n<p>-</p>\n<pre><code>/*** iir++.h ***/\n#include &lt;complex&gt;\n\nnamespace IIR {\n\n...\n</code></pre>\n<h3>Problem:</h3>\n<p>clang gives me the following error when compiling:</p>\n<pre><code>./iir.h:570:15: error: expected ';' after top level declarator\ndouble complex iir_response_c(const struct iir_coeff_t* coeff, double freq);\n              ^\n              ;\n</code></pre>\n<p>Evidently, the new <code>&lt;complex&gt;</code> import is not happening--or <code>#undef complex</code> is happening again--but I don't see how. Any advice on what might be going wrong, or what to check?</p>\n</hr>", "AcceptedAnswerId": "31800404", "Title": "c++ and <complex.h> with <complex> in separate files", "CreationDate": "2015-08-04T03:15:27.053", "Id": "31800065", "CommentCount": "0", "LastEditDate": "2017-05-23T12:07:55.597", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-05T08:30:49.923", "Score": "1", "OwnerUserId": "1131073", "Tags": "<c++><c><complex-numbers>", "AnswerCount": "1"}});