post_cb({"24342841": {"ParentId": "24342455", "PostTypeId": "2", "CommentCount": "0", "Body": "<h3>Introduction</h3>\n<p>The snippet is legal <em>C++11</em>, and there is no change in <em>C++14</em>.</p>\n<blockquote>\n<p id=\"so_24342455_24342841_0\"><sup> <strong>Note</strong>: <em><code>gcc 4.9.0</code></em> correctly accepts the snippet, ie. rejecting the snippet was a bug in previous versions of the compiler.</sup></p>\n</blockquote>\n<hr>\n<h3>Explanation</h3>\n<p>The <em>constexpr</em> specifier certainly affects the object being defined (it will be declared <em>const</em>), but in particular the specifier mandates that the object declared;</p>\n<ul>\n<li>is a <em>literal type</em>, and;</li>\n<li>has an initializer, and;</li>\n<li>that the initializer is a <em>constant expression</em>.</li>\n</ul>\n<p><br/></p>\n<pre><code>struct Thing {\n  int value;\n  static const Thing thing;       // (A)\n};\n\nconstexpr Thing Thing::thing {3}; // (B)\n</code></pre>\n<p>This means that the definition (B) refers to an object of type <code>Thing const</code> named <em>thing</em>, which is the same as (A), hence; the snippet is legal.</p>\n<p><br/></p>\n<blockquote>\n<p id=\"so_24342455_24342841_1\"><code>7.1.5p9</code> <strong>The <code>constexpr</code> specifier</strong> <code>[dcl.constexpr]</code> (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\"><strong>n3337</strong></a>)</p>\n<blockquote>\n<p id=\"so_24342455_24342841_3\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const.</code> Such an object shall have literal type and shall be initialized.</p>\n</blockquote>\n</blockquote>\n</hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-21T15:06:15.413", "Id": "24342841", "Score": "6", "CreationDate": "2014-06-21T15:00:34.507", "LastActivityDate": "2014-06-21T15:06:15.413"}, "bq_ids": {"n4140": {"so_24342455_24342841_3": {"section_id": 5425, "quality": 1.0, "length": 13}, "so_24342455_24342841_2": {"section_id": 5425, "quality": 1.0, "length": 13}}, "n3337": {"so_24342455_24342841_3": {"section_id": 5220, "quality": 1.0, "length": 13}, "so_24342455_24342841_2": {"section_id": 5220, "quality": 1.0, "length": 13}}, "n4659": {"so_24342455_24342841_3": {"section_id": 6847, "quality": 1.0, "length": 13}, "so_24342455_24342841_2": {"section_id": 6847, "quality": 1.0, "length": 13}}}, "24342455": {"CommentCount": "1", "ViewCount": "214", "PostTypeId": "1", "LastEditorUserId": "1090079", "CreationDate": "2014-06-21T14:18:23.543", "LastActivityDate": "2014-06-21T15:08:53.077", "LastEditDate": "2014-06-21T15:08:53.077", "AcceptedAnswerId": "24342841", "OwnerDisplayName": "user3490189", "Title": "Nested static constexpr of incomplete type. Valid C++ or not?", "Id": "24342455", "Score": "6", "Body": "<p>Clang and GCC disagree on whether the following code is valid <code>C++11</code> or not:  </p>\n<pre><code>struct Thing {\n    int value;\n    static const Thing thing;\n};\n\nconstexpr Thing Thing::thing {3};\n</code></pre>\n<p>Clang compiles it and <code>GNU GCC version 4.7.2</code> says:<br>\n<code>error: redeclaration \u2018Thing::thing\u2019 differs in \u2018constexpr\u2019\nconstexpr Thing Thing::thing {3};</code></br></p>\n<p>Which compiler's interpretation of the standard is correct? And does it seem like the <code>C++14</code> standard is going to have something new to say relating to this matter?</p>\n", "Tags": "<c++><language-lawyer><static-members><constexpr>", "AnswerCount": "1"}});