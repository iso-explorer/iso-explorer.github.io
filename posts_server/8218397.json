post_cb({"8218460": {"ParentId": "8218397", "PostTypeId": "2", "CommentCount": "8", "Body": "<p><strong>It isn't shadowy after all, see highlighted parts of the standards excerpt:</strong></p>\n<p>The section on defaulted copy/move constructors (\u00a7 12.8) is a bit too lengthy to quote in it's entirety. The low-down is that non-static member fields with initializers are still simply copied by the defaulted copy/move constructor</p>\n<p>\u00a7 12.8:</p>\n<blockquote>\n<p id=\"so_8218397_8218460_0\">-6. The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move\n  of its bases and members. <strong><code>[ Note: brace-or-equal-initializers of non-static data members are ignored. See\n  also the example in 12.6.2. \u2014end note ]</code></strong> The order of initialization is the same as the order of initialization\n  of bases and members in a user-defined constructor (see 12.6.2). Let x be either the parameter of the\n  constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data\n  member is copied/moved in the manner appropriate to its type:</p>\n<ul>\n<li>if the member is an array, each element is direct-initialized with the corresponding subobject of x;</li>\n<li>if a member m has rvalue reference type T&amp;&amp;, it is direct-initialized with static_cast(x.m);</li>\n<li>otherwise, the base or member is direct-initialized with the corresponding base or member of x.<br/>\n  Virtual base class subobjects shall be initialized only once by the implicitly-defined copy/move constructor</li>\n</ul>\n</blockquote>\n<p>This is the sample referred to:</p>\n<blockquote>\n<pre><code>struct A {\n    int i = /* some integer expression with side effects */;\n    A(int arg) : i(arg) { }\n    // ...\n};\n</code></pre>\n<p id=\"so_8218397_8218460_1\">The A(int) constructor will simply initialize i to the value of arg, and the side effects in i\u2019s brace-or-equalinitializer will not take place. <code>\u2014end example ]</code></p>\n</blockquote>\n<hr>\n<p>For completeness, the corresponding section on the defaulted default constructor:</p>\n<p>\u00a7 12.1</p>\n<blockquote>\n<p id=\"so_8218397_8218460_2\">-6. A default constructor that is defaulted and not defined as deleted is implicitly defined when it is <em>odr-used</em> (3.2) to create an object of its class type (1.8) or when it is explicitly defaulted after its first declaration.<br/>\n<strong>The implicitly-defined default constructor performs the set of initializations of the class that would be performed by a user-written default constructor for that class with no ctor-initializer (12.6.2) and an empty\n  compound-statement</strong>. If that user-written default constructor would be ill-formed, the program is ill-formed.<br/>\n  If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),\n  the implicitly-defined default constructor is constexpr. Before the defaulted default constructor for a\n  class is implicitly defined, all the non-user-provided default constructors for its base classes <strong>and its nonstatic\n  data members</strong> shall have been implicitly defined. [ Note: An implicitly-declared default constructor\n  has an exception-specification (15.4). <br/>An explicitly-defaulted definition might have an implicit exception-specification,\n  see 8.4. <code>\u2014end note ]</code></p>\n</blockquote>\n</hr>", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2011-11-21T21:11:26.713", "Id": "8218460", "Score": "10", "CreationDate": "2011-11-21T20:58:40.787", "LastActivityDate": "2011-11-21T21:11:26.713"}, "8218397": {"CommentCount": "1", "AcceptedAnswerId": "8218460", "PostTypeId": "1", "LastEditorUserId": "334908", "CreationDate": "2011-11-21T20:53:00.077", "LastActivityDate": "2012-03-03T21:40:59.590", "LastEditDate": "2012-03-03T21:40:59.590", "ViewCount": "3498", "FavoriteCount": "3", "Title": "In C++0x, do non-static data member initializers override the implicit copy constructor?", "Id": "8218397", "Score": "14", "Body": "<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2628.html\" rel=\"nofollow\">N2628</a> related to <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b0x\" rel=\"tag\" title=\"show questions tagged 'c++0x'\">c++0x</a>, non-static data member initializers can be overridden by explicitly defined constructors, but it appears to be slightly nebulous about the implicitly defined copy constructor.</p>\n<p>In particular, I've noticed that with Apple clang version 3.0, the behavior varies depending on whether the struct (or class) is a POD.</p>\n<p>The following program returns output \"1\", which indicates that the copy-constructor is ignoring the right-hand-side, and instead substituting the new non-static data member initializer (in this example, the boolean true value for X::a). </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct X\n{\n    std::string string1;\n    bool a = true;\n};\n\nint main(int argc, char *argv[])\n{\n    X x;\n    x.a = false;\n    X y(x);\n    std::cout &lt;&lt; y.a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>However, confusingly, if you comment out string1:</p>\n<pre><code>    // std::string string1;  \n</code></pre>\n<p>then the behavior works as I expected (the output is \"0\"), presumably because there is no implicitly generated copy-constructor, and therefore the data is <em>copied</em>.</p>\n<p>Does the C++0x specification really suggest that it is a good idea to allow the implicitly defined copy-constructor to <em>not</em> copy the contents of the right-hand side?  Isn't that less useful and unintuitive?  I find the non-static member initializer functionality to be quite convenient, but if this is the correct behavior, then I will explicitly avoid the feature due to its tricky and unintuitive behavior.</p>\n<p>Please tell me I'm wrong?</p>\n<p>UPDATE: This bug has been fixed in the Clang source repository.  See this <a href=\"http://llvm.org/viewvc/llvm-project?view=rev&amp;sortby=rev&amp;revision=145269\" rel=\"nofollow\">revision</a>.</p>\n<p>UPDATE: This bug appears fixed in Apple clang version 3.1 (tags/Apple/clang-318.0.45) (based on LLVM 3.1svn).  This version of clang was distributed as part of Xcode 4.3 for Lion.</p>\n", "Tags": "<c++><c++11><clang><default-copy-constructor>", "OwnerUserId": "334908", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8218397_8218460_0": {"section_id": 464, "quality": 0.8727272727272727, "length": 48}, "so_8218397_8218460_1": {"section_id": 436, "quality": 0.8125, "length": 13}, "so_8218397_8218460_2": {"section_id": 370, "quality": 0.9157894736842105, "length": 87}}, "n3337": {"so_8218397_8218460_0": {"section_id": 455, "quality": 0.8727272727272727, "length": 48}, "so_8218397_8218460_1": {"section_id": 428, "quality": 0.8125, "length": 13}, "so_8218397_8218460_2": {"section_id": 360, "quality": 0.9157894736842105, "length": 87}}, "n4659": {"so_8218397_8218460_0": {"section_id": 487, "quality": 0.8545454545454545, "length": 47}, "so_8218397_8218460_1": {"section_id": 455, "quality": 0.75, "length": 12}, "so_8218397_8218460_2": {"section_id": 384, "quality": 0.8947368421052632, "length": 85}}}});