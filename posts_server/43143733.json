post_cb({"43143733": {"ViewCount": "550", "Body": "<p>Let us suppose that we have an abstract class <code>NonEditableSuperBase</code> from which we create another abstract class <code>MyBase</code>.</p>\n<p>The first class <code>NonEditableSuperBase</code> has a virtual function (non pure virtual). However, I want to force that if someone creates a class that derives from <code>MyBase</code>, he/she must provide an implementation to the mentioned function.</p>\n<p>Hence, my idea is to define the function as pure virtual in <code>MyBase</code>.</p>\n<p>My question: <strong>Is it a bad idea</strong> given that it was just virtual in <code>NonEditableSuperBase</code>?</p>\n<p><strong>Example:</strong></p>\n<pre><code>//NonEditableSuperBase.h\nclass NonEditableSuperBase\n{\n  ...\n  public:\n    virtual int someMethod(); //It has an implementation, suppose {return 42;}\n};\n\n//MyBase.h\nclass MyBase: public NonEditableSuperBase\n{\n  public:\n     explicit MyBase();       \n     virtual ~MyBase() = default;       \n     virtual int someMethod() = 0;  //I make it pure virtual\n};\n\n//MyBase.cpp\nMyBase::MyBase() : NonEditableSuperBase() { }\n\n//Now someone creates a derived class from MyBase.\nclass SuperDerived : public MyBase\n{\n  public:\n    explicit SuperDerived();\n    int someMethod(); //The user must create an implementation of the function\n};\n</code></pre>\n<p>Update:\nAs an example, in my case I want to create some derived classes from the <a href=\"http://doc.qt.io/qt-5/qabstracttablemodel.html#index\" rel=\"nofollow noreferrer\">QAbstractTableModel</a> class of the Qt framework. To reuse some code I want to create an intermediate abstract class.</p>\n<pre><code>QAbstractTableModel &lt;- MyAbstractModel &lt;- MyModelA (or MyModelB ... etc).\n</code></pre>\n<p>However, I want to ensure that the models (MyModelA, MyModelB) re-implement some of the virtual functions of QAbstractTableModel (like the ::index() function) because some of the additional methods of MyAbstractModel requires specific implementations of the primer functions. </p>\n", "AcceptedAnswerId": "43145252", "Title": "Is it dangerous to create pure virtual function of a virtual function?", "CreationDate": "2017-03-31T14:55:38.527", "Id": "43143733", "CommentCount": "6", "LastEditDate": "2017-05-03T14:32:30.150", "PostTypeId": "1", "LastEditorUserId": "6281575", "LastActivityDate": "2017-08-10T00:11:55.823", "Score": "11", "OwnerUserId": "6281575", "Tags": "<c++><pure-virtual>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_43143733_43145252_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7022}}, "n3337": {"so_43143733_43145252_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 6768}}, "n4659": {"so_43143733_43145252_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 8519}}}, "43145252": {"Id": "43145252", "PostTypeId": "2", "Body": "<p>From <a href=\"https://www.iso.org/obp/ui/#iso:std:iso-iec:14882:ed-4:v1:en\" rel=\"nofollow noreferrer\">ISO IEC 14882 2014</a>:</p>\n<blockquote>\n<p id=\"so_43143733_43145252_0\">\u00a7 10.4 says:</p>\n<p id=\"so_43143733_43145252_1\">5  [ Note: An abstract class can be derived from a class that is not abstract, and a pure virtual function may\n  override a virtual function which is not pure. \u2014end note ]</p>\n</blockquote>\n<p>So It's perfectly possible to do that.</p>\n<p><strong>Example of use case:</strong></p>\n<p>You can have a basic type, that is implemented as a concrete type (base class). Now, for subtypes, we might be in a need of further additional information. So, we can have an abstract intermediate object to meet our needs.</p>\n", "LastEditorUserId": "5377805", "LastActivityDate": "2017-08-10T00:11:55.823", "Score": "11", "CreationDate": "2017-03-31T16:13:15.757", "ParentId": "43143733", "CommentCount": "0", "OwnerUserId": "5377805", "LastEditDate": "2017-08-10T00:11:55.823"}, "43145312": {"Id": "43145312", "PostTypeId": "2", "Body": "<p>[I'm assuming that the intent was for MyBase to publicly derive from NonEditableSuperBase, which is not what the code sample in the question actually does.]</p>\n<p>It doesn't seem inherently dangerous, but consider that a class like SuperDerived that derives from MyBase could explicitly choose to use the NonEditableSuperBase implementation.</p>\n<pre><code>class SuperDerived : public MyBase {\n  public:\n    using NonEditableSuperBase::someMethod;\n    // Or, explicitly:\n    // int someMethod() override { return NonEditableSuperBase::someMethod(); }\n};\n</code></pre>\n<p>This satisfies the pure-virtual requirement imposed by MyBase but acts exactly as if MyBase didn't have that requirement.  You've made the author of SuperDerived do <em>something</em>, but you haven't actually prevented them from using the ultimate base class's implementation.</p>\n", "LastActivityDate": "2017-03-31T16:16:09.930", "CommentCount": "2", "CreationDate": "2017-03-31T16:16:09.930", "ParentId": "43143733", "Score": "2", "OwnerUserId": "1386054"}});