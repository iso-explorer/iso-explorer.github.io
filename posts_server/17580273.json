post_cb({"bq_ids": {"n4140": {"so_17580273_17580390_2": {"length": 5, "quality": 1.0, "section_id": 263}, "so_17580273_17580390_4": {"length": 20, "quality": 0.9523809523809523, "section_id": 135}}, "n3337": {"so_17580273_17580390_2": {"length": 5, "quality": 1.0, "section_id": 254}, "so_17580273_17580390_4": {"length": 20, "quality": 0.9523809523809523, "section_id": 129}}, "n4659": {"so_17580273_17580390_2": {"length": 5, "quality": 1.0, "section_id": 270}, "so_17580273_17580390_4": {"length": 18, "quality": 0.8571428571428571, "section_id": 139}}}, "17580273": {"ViewCount": "183", "Body": "<p>This is from the C++ Standard Library xutility header that ships with VS2012.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;class _Elem1,\n    class _Elem2&gt;\n    struct _Ptr_cat_helper\n    {   // determines pointer category, nonscalar by default\n    typedef _Nonscalar_ptr_iterator_tag type;\n    };\n\ntemplate&lt;class _Elem&gt;\n    struct _Ptr_cat_helper&lt;_Elem, _Elem&gt;\n    {   // determines pointer category, common type\n    typedef typename _If&lt;is_scalar&lt;_Elem&gt;::value,\n        _Scalar_ptr_iterator_tag,\n        _Nonscalar_ptr_iterator_tag&gt;::type type;\n    };\n</code></pre>\n<p>Specifically what is the nature of the second _Ptr_cat_helper declaration? The angle brackets after the declarator _Ptr_cat_helper make it look like a specialization. But instead of specifying full or partial types by which to specialize the template it instead just repeats the template argument multiple times.</p>\n<p>I don't think I've seen that before. What is it?</p>\n<p>UPDATE</p>\n<p>We are all clear that the specialization applies to an instantiation of the template where both template arguments are of the same type, but I'm not clear on whether this constitutes a full or a partial specialization, or why.</p>\n<p>I thought a specialization was a full specialization when all the template arguments are either explicitly supplied or are supplied by default arguments, and are used exactly as supplied to instantiate the template, and that conversely a specialization was partial either, if not all the template parameters were required due to the specialization supplying one or more (but not all) of them, and/or if the template arguments were used in a form that was modified by the specialization pattern. E.g.</p>\n<p>A specialization that is partial because the specialization is supplying at least one, but not all, of the template arguments.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;typename T, typename U&gt;\nclass G { public: T Foo(T a, U b){ return a + b; }};\n\ntemplate&lt;typename T&gt;\nclass G&lt;T, bool&gt; { public: T Foo(T a, bool b){ return b ? ++a : a; }};\n</code></pre>\n<p>A specialization that is partial because the specialization is causing the supplied template argument to be used only partially.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;typename T&gt;\nclass F { public: T Foo(T a){ return ++a; }};\n\ntemplate&lt;typename T&gt;\nclass F&lt;T*&gt; { public: T Foo(T* a){ return ++*a; }};\n</code></pre>\n<p>In this second example if the template were instantiated using A&lt;char*&amp;GT; then T within the template would actually be of type char, i.e. the template argument as supplied is used only partially due to the application of the specialization pattern.</p>\n<p>If that is correct then wouldn't that make the template in the original question a full specialization rather than a partial specialization, and if that is not so then where is my misunderstanding?</p>\n", "AcceptedAnswerId": "17580390", "Title": "What is this template construct?", "CreationDate": "2013-07-10T20:27:36.777", "Id": "17580273", "CommentCount": "6", "LastEditDate": "2013-07-10T23:31:41.303", "PostTypeId": "1", "LastEditorUserId": "954927", "LastActivityDate": "2013-07-11T10:34:26.553", "Score": "4", "OwnerUserId": "954927", "Tags": "<c++><template-specialization>", "AnswerCount": "2"}, "17580390": {"Id": "17580390", "PostTypeId": "2", "Body": "<p>It is a partial class template specialization for the case when the same type is passed for both parameters.</p>\n<p>Maybe this will be easier to read:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nstruct is_same : std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct is_same&lt;T,T&gt; : std::true_type {};\n</code></pre>\n<p><strong>EDIT:</strong></p>\n<p>When in doubt whether a specialization is an explicit (full) specialization or a partial specialization, you can refer to the standard which is pretty clear on this matter:</p>\n<p>n3337, 14.7.3./1</p>\n<blockquote>\n<p id=\"so_17580273_17580390_0\">An explicit specialization of any of the following:  </p>\n<p id=\"so_17580273_17580390_1\">[...]  </p>\n<p id=\"so_17580273_17580390_2\">can be declared by a declaration introduced by <code>template&lt;&gt;</code>; that is:</p>\n<p id=\"so_17580273_17580390_3\"><em>explicit-specialization:</em><br>\n<strong><code>template &lt; &gt;</code></strong> <em>declaration</em></br></p>\n</blockquote>\n<p>and n3337, 14.5.5/1</p>\n<blockquote>\n<p id=\"so_17580273_17580390_4\">A primary class template declaration is one in which the class\n  template name is an identi\ufb01er. A template declaration in which the\n  class template name is a <em>simple-template-id</em> is a partial\n  specialization of the class template named in the <em>simple-template-id.</em> [...]</p>\n</blockquote>\n<p>Where <em>simple-template-id</em> is defined in the grammar like this:</p>\n<blockquote>\n<p id=\"so_17580273_17580390_5\"><em>simple-template-id:</em></p>\n<blockquote>\n<p id=\"so_17580273_17580390_9\"><em>template-name &lt; template-argument-list opt &gt;</em></p>\n</blockquote>\n<p id=\"so_17580273_17580390_7\"><em>template-name</em></p>\n<blockquote>\n<p id=\"so_17580273_17580390_10\"><em>identifier</em></p>\n</blockquote>\n</blockquote>\n<p>So, wherever there's <code>template&lt;&gt;</code>, it's a full specialization, anything else is a partial specialization.</p>\n<p>You can also think about it this way: Full template specialization specializes for <em>exactly one</em> possible instantiation of the primary template. Anything else is a partial specialization. Example in your question is a partial specialization because while it limits the arguments to be of the same type, it still allows for indifinitely many distinct arguments the template can be instantiated with.</p>\n<p>A specialization like this, for example</p>\n<pre><code>template&lt;&gt;\nvector&lt;bool&gt; { /* ... */ };\n</code></pre>\n<p>is a full specialization because it kicks in when the type is <code>bool</code> and only <code>bool</code>.</p>\n<p>Hope that helps.</p>\n<hr>\n<p>And just a note I feel it's worth mentioning. I guess you already know - function templates can't be partialy specialized. While this</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T);\n\ntemplate&lt;typename T&gt;\nvoid foo(T*);\n</code></pre>\n<p>might looks like a partial specialization of <code>foo</code> for pointers on the first glance, it is not - it's an overload.</p>\n</hr>", "LastEditorUserId": "947836", "LastActivityDate": "2013-07-11T10:34:26.553", "Score": "11", "CreationDate": "2013-07-10T20:35:37.047", "ParentId": "17580273", "CommentCount": "2", "OwnerUserId": "947836", "LastEditDate": "2013-07-11T10:34:26.553"}, "17580589": {"Id": "17580589", "PostTypeId": "2", "Body": "<p>You mention specifying \"full or <em>partial</em> types\" when performing specialization of a template, which suggests that you are aware of such language feature as <em>partial specialization</em> of class templates.</p>\n<p>Partial specialization has rather extensive functionality. It is not limited to simply specifying concrete arguments for some of the template parameters. It also allows defining a dedicated version of template for a certain groups of argument types, based on their cv-qualifications or levels of indirection, as in the following example</p>\n<pre><code>template &lt;typename A, typename B&gt; struct S {}; \n// Main template\n\ntemplate &lt;typename A, typename B&gt; struct S&lt;A *, B *&gt; {}; \n// Specialization for two pointer types\n\ntemplate &lt;typename A, typename B&gt; struct S&lt;const A, volatile B&gt; {}; \n// Specialization for const-qualified type `A` and volatile-qualified type `B`\n</code></pre>\n<p>And it also covers specializations based on whether some template arguments are identical or different</p>\n<pre><code>template &lt;typename A&gt; struct S&lt;A, A&gt; {}; \n// Specialization for two identical arguments\n\ntemplate &lt;typename A&gt; struct S&lt;A, A *&gt; {}; \n// Specialization for when the second type is a pointer to the first one\n</code></pre>\n<p>As another, rather curios example, partial specialization of a multi-argument template can be used to fully override the main template</p>\n<pre><code>template &lt;typename A, typename B&gt; struct S&lt;B, A&gt; {}; \n// Specialization for all arguments\n</code></pre>\n<p>Now, returning to your code sample, partial specialization for two identical arguments is exactly what is used in the code you posted.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-07-10T22:09:48.983", "Score": "5", "CreationDate": "2013-07-10T20:49:07.810", "ParentId": "17580273", "CommentCount": "1", "OwnerUserId": "187690", "LastEditDate": "2013-07-10T22:09:48.983"}});