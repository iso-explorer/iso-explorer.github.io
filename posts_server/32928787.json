post_cb({"32929099": {"Id": "32929099", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32928787_32929099_0\">I am attempting to destruct a shared_ptr one-by-one,</p>\n</blockquote>\n<p>I have no idea what that means, but ...</p>\n<pre><code>myPtr.~__shared_ptr();\n</code></pre>\n<p>Never, ever, ever do this.</p>\n<p>You are running the destructor for an automatic object, i.e. one that lives on the stack and will be destroyed automatically by the compiler when it goes out of scope. By destroying it manually you cause it to be destroyed twice. You cannot end an object's lifetime twice, it is not James Bond, it only lives once.</p>\n<p>Destroying the same object twice is undefined behaviour. That means weird things can happen. Asking why you get weird results from a program with undefined behaviour is a waste of time. Weird things happen when you have undefined behaviour <strong>because you have undefined behaviour</strong>. Anything can happen. You should be thankful it's only weird, and not catastrophic.</p>\n<p>The standard specifically points out this exact scenario is undefined behaviour, in 12.4 [class.dtor]:</p>\n<blockquote>\n<p id=\"so_32928787_32929099_1\">Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the\n  destructor is invoked for an object whose lifetime has ended (3.8). <em>[Example:</em> if the destructor for an\n  automatic object is explicitly invoked, and the block is subsequently left in a manner that would ordinarily\n  invoke implicit destruction of the object, the behavior is undefined. <em>\u2014 end example]</em></p>\n</blockquote>\n<p>Even worse, you are running the destructor for a base class of <code>myPtr</code> so you are only destroying <em>part</em> of the object. That means you have an object where part of it is dead and part of it is alive, and then at the end of the scope part of it gets killed again. Under no circumstances can that ever be the right thing to do. Ever.</p>\n<blockquote>\n<p id=\"so_32928787_32929099_2\">I was hoping on the final destruction it would set the use_count() to 0 and deallocate the memory for the integer. It appears none of this is happening.</p>\n</blockquote>\n<p>Your conclusion is wrong. It probably is happening, but if the object is destroyed and the memory is deallocated then trying to look at it produces nonsense results. You can't ask a zombie what its name is, it will reply \"BRAINZZZZ!\" instead of telling you anything useful. And eat your brains. Now you are dead. Don't play with zombies.</p>\n<p>Also, as Neil Kirk comments above, this is also wrong:</p>\n<pre><code>int * val = new int(5);\nstd::shared_ptr&lt;int&gt; myPtr = std::make_shared&lt;int&gt;(*val);\n</code></pre>\n<p>You create an <code>int</code> on the heap, then you create <em>copy</em> of it on the heap that will be managed by a <code>shared_ptr</code>. The <code>shared_ptr</code> owns an <code>int</code> which has the same value as <code>*val</code> but nothing owns <code>val</code> so that will be a memory leak. You probably meant to do either this:</p>\n<pre><code>int * val = new int(5);\nstd::shared_ptr&lt;int&gt; myPtr(val);\n</code></pre>\n<p>or more likely this:</p>\n<pre><code>int val = 5;\nstd::shared_ptr&lt;int&gt; myPtr = std::make_shared&lt;int&gt;(val);\n</code></pre>\n", "LastEditorUserId": "981959", "LastActivityDate": "2015-10-04T11:58:20.740", "Score": "2", "CreationDate": "2015-10-04T01:15:21.297", "ParentId": "32928787", "CommentCount": "0", "LastEditDate": "2015-10-04T11:58:20.740", "OwnerUserId": "981959"}, "bq_ids": {"n4140": {"so_32928787_32929099_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 411}}, "n3337": {"so_32928787_32929099_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 402}}, "n4659": {"so_32928787_32929099_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 429}}}, "32929132": {"Id": "32929132", "PostTypeId": "2", "Body": "<p>I think I figured out what you are after. You want to detect when the use count of the shared object is zero.</p>\n<p>The way this is done is using a <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr\" rel=\"nofollow\">std::weak_ptr</a> that is designed to work <em>with</em> the <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\">std::shared_ptr</a> so you can keep track of whether or not the object has been destroyed.</p>\n<p>Here:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    // weak_ptr is only convertable to a shared_ptr if the shared_ptr\n    // usage count is &gt; 0\n    std::weak_ptr&lt;int&gt; wp;\n\n    {\n        std::shared_ptr&lt;int&gt; ptr = std::make_shared&lt;int&gt;(5);\n        wp = ptr; // link weak_ptr to shared_ptr\n\n        if(auto sp = wp.lock()) // try to convert weak_ptr to shared_ptr\n        {\n            // if we get here use_count was &gt; 0\n            std::cout &lt;&lt; \"Before: use count &gt; 0: \"\n                &lt;&lt; std::boolalpha &lt;&lt; (sp.use_count() &gt; 0) &lt;&lt; '\\n';\n        }\n        else\n        {\n            // if we get here use_count was == 0\n            std::cout &lt;&lt; \"Before: Destroyed\\n\";\n        }\n        // ptr goes out of scope here\n    }\n\n    if(auto sp = wp.lock()) // try to convert weak_ptr to shared_ptr\n    {\n        // if we get here use_count was &gt; 0\n        std::cout &lt;&lt; \"After: use count &gt; 0: \"\n            &lt;&lt; std::boolalpha &lt;&lt; (sp.use_count() &gt; 0) &lt;&lt; '\\n';\n    }\n    else\n    {\n        // if we get here use_count was == 0\n        std::cout &lt;&lt; \"After: Destroyed\\n\";\n    }\n}\n</code></pre>\n<p>Basically, if the linked <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\">std::shared_ptr</a> still holds a reference to the object then the <em>associated</em> <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr\" rel=\"nofollow\">std::weak_ptr</a> can be converted to a <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\">std::shared_ptr</a> using <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr/lock\" rel=\"nofollow\">std::weak_ptr::lock</a>. If that fails then the <em>associated</em> <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\">std::shared_ptr</a> is no longer pointing at the shared object - it has been destroyed.</p>\n", "LastEditorUserId": "3807729", "LastActivityDate": "2015-10-04T01:33:29.157", "Score": "2", "CreationDate": "2015-10-04T01:21:01.597", "ParentId": "32928787", "CommentCount": "0", "LastEditDate": "2015-10-04T01:33:29.157", "OwnerUserId": "3807729"}, "32928787": {"ViewCount": "79", "Body": "<p>I am attempting to destruct a shared_ptr one-by-one, yet when I destruct the last pointer, the use_count() goes nuts. Observe my code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\n\nint main() {\n\n    int * val = new int(5);\n    std::shared_ptr&lt;int&gt; myPtr = std::make_shared&lt;int&gt;(*val);\n\n    myPtr.~__shared_ptr();\n\n}\n</code></pre>\n<p>Will produce the following output in the debugger:</p>\n<pre><code>myPtr value: 5  myPtr.use_count():8787448 // Or some other large int\n</code></pre>\n<p>I was hoping on the final destruction it would set the use_count() to 0 and deallocate the memory for the integer. It appears none of this is happening.</p>\n<p>I could if() statement this when the use_count() == 1, but this seems very inelegant. Does anyone know of another solution? </p>\n", "AcceptedAnswerId": "32929132", "Title": "Destructing a Single shared_ptr One-by-One", "CreationDate": "2015-10-04T00:15:47.983", "Id": "32928787", "CommentCount": "15", "LastEditDate": "2015-10-04T00:55:01.673", "PostTypeId": "1", "LastEditorUserId": "4690968", "LastActivityDate": "2015-10-04T11:58:20.740", "Score": "-2", "OwnerUserId": "4690968", "Tags": "<c++><pointers><shared-ptr><smart-pointers><explicit-destructor-call>", "AnswerCount": "2"}});