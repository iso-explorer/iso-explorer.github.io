post_cb({"bq_ids": {"n4140": {"so_26949290_26949793_0": {"length": 18, "quality": 1.0, "section_id": 300}}, "n3337": {"so_26949290_26949793_0": {"length": 18, "quality": 1.0, "section_id": 291}}, "n4659": {"so_26949290_26949793_0": {"length": 18, "quality": 1.0, "section_id": 307}}}, "26949793": {"Id": "26949793", "PostTypeId": "2", "Body": "<p>Use</p>\n<pre><code>template &lt;class...&gt; struct null_v : std::integral_constant&lt;int, 0&gt; {};\n</code></pre>\n<p>and define the constructors as</p>\n<pre><code>template &lt;typename T2,\n          long = null_v&lt;enable_if_t&lt;SCheckEnable&lt;U&gt;::value, T2&gt;&gt;::value&gt;\nconstexpr CClass(T2 v) : val(v) {};\n\ntemplate &lt;typename T2,\n          int = null_v&lt;disable_if_t&lt;SCheckEnable&lt;U&gt;::value, T2&gt;&gt;::value&gt;\nexplicit constexpr CClass(T2 v) : val(v) {};\n</code></pre>\n<p>Making the argument dependent and actually instantiated. \n<a href=\"http://coliru.stacked-crooked.com/a/60aa171e1d2627ba\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n<p>[temp.deduct]/8:</p>\n<blockquote>\n<p id=\"so_26949290_26949793_0\">If <strong>a substitution</strong> results in an invalid type or expression, type\n  deduction fails. An invalid type or expression is one that would be\n  ill-formed if written <strong>using the substituted arguments</strong>.</p>\n</blockquote>\n<p>In your case the error occurs outside of any substitution, so that's not causing a deduction failure but rather makes your code ill-formed.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-15T20:04:02.147", "Score": "3", "CreationDate": "2014-11-15T19:28:24.290", "ParentId": "26949290", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2014-11-15T20:04:02.147"}, "26949290": {"ViewCount": "542", "Body": "<p>I'm trying to switch between an explicit and an implicit conversion constructor via <code>enable_if</code>.</p>\n<p>My code currently looks like</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;cstdint&gt;\n\nenum class enabled {};\n\ntemplate &lt;bool B, typename T = void&gt; using enable_if_t = typename std::enable_if&lt;B, T&gt;::type;\ntemplate &lt;bool B, typename T = void&gt; using disable_if_t = typename std::enable_if&lt;!B, T&gt;::type;\n\ntemplate &lt;std::intmax_t A&gt; struct SStruct\n{\n    static constexpr std::intmax_t a = A;\n};\n\ntemplate &lt;typename T&gt; struct SCheckEnable : std::integral_constant&lt;bool, T::a == 0&gt;\n{\n};\n\ntemplate &lt;typename U, typename T&gt; class CClass\n{\n    public:\n        template &lt;typename T2, enable_if_t&lt;SCheckEnable&lt;U&gt;::value, enabled&gt;...&gt; constexpr CClass(T2 v) : val(v) {};\n        template &lt;typename T2, disable_if_t&lt;SCheckEnable&lt;U&gt;::value, enabled&gt;...&gt; explicit constexpr CClass(T2 v) : val(v) {};\n\n    private:\n        T val;\n};\n\nint main()\n{\n    CClass&lt;SStruct&lt;0&gt;, double&gt; a = 1;                             // should use implicit constructor\n    CClass&lt;SStruct&lt;1&gt;, double&gt; b = CClass&lt;SStruct&lt;1&gt;, double&gt;(1); // should use explicit constructor\n}\n</code></pre>\n<p>The <code>true</code> in the <code>enable_if</code>s is dependent of the template parameter <code>U</code></p>\n<p>If I try to compile this minimal example with <code>g++ 4.9.1</code> and <code>--std=c++11</code> enabled I get the following errors</p>\n<pre><code>sfinae.cpp: In substitution of \u2018template&lt;bool B, class T&gt; using disable_if_t = typename std::enable_if&lt;(! B), T&gt;::type [with bool B = true; T = enabled]\u2019:\nsfinae.cpp:13:52:   required from here\nsfinae.cpp:7:95: error: no type named \u2018type\u2019 in \u2018struct std::enable_if&lt;false, enabled&gt;\u2019\n template &lt;bool B, typename T = void&gt; using disable_if_t = typename std::enable_if&lt;!B, T&gt;::type;\n                                                                                               ^\nsfinae.cpp:19:68: error: prototype for \u2018constexpr CClass&lt;U, T&gt;::CClass(T2)\u2019 does not match any in class \u2018CClass&lt;U, T&gt;\u2019\n template &lt;typename U, typename T&gt; template &lt;typename T2&gt; constexpr CClass&lt;U, T&gt;::CClass(T2 v) : val(v)\n                                                                    ^\nsfinae.cpp:13:77: error: candidates are: template&lt;class U, class T&gt; template&lt;class T2, int ...&lt;anonymous&gt; &gt; constexpr CClass&lt;U, T&gt;::CClass(T2)\n   template &lt;typename T2, disable_if_t&lt;true, enabled&gt;...&gt; explicit constexpr CClass(T2 v);\n                                                                             ^\nsfinae.cpp:12:67: error:                 template&lt;class U, class T&gt; template&lt;class T2, enabled ...&lt;anonymous&gt; &gt; constexpr CClass&lt;U, T&gt;::CClass(T2)\n   template &lt;typename T2, enable_if_t&lt;true, enabled&gt;...&gt; constexpr CClass(T2 v);\n                                                                   ^\n</code></pre>\n<p>Any idea how to select between explicit and implicit construction based on parameter <code>U</code> here?</p>\n", "AcceptedAnswerId": "26949793", "Title": "SFINAE enable_if explicit constructor", "CreationDate": "2014-11-15T18:35:58.123", "Id": "26949290", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-11-15T19:20:25.797", "LastEditorUserId": "1857229", "LastActivityDate": "2014-11-15T20:04:02.147", "Score": "7", "OwnerUserId": "1857229", "Tags": "<c++><templates><c++11><sfinae><enable-if>", "AnswerCount": "1"}});