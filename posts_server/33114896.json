post_cb({"bq_ids": {"n4140": {"so_33114896_33115014_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 3919}}, "n3337": {"so_33114896_33115014_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 3779}}, "n4659": {"so_33114896_33115014_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 4805}}}, "33115014": {"Id": "33115014", "PostTypeId": "2", "Body": "<p>The standard says that:</p>\n<blockquote>\n<p id=\"so_33114896_33115014_0\">If control enters the declaration concurrently while the [block-scope variable with static or thread storage duration] is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p>\n</blockquote>\n<p>([stmt.dcl]/4)</p>\n<p>The change made in C++11 is that initialization of local static variables is required to be thread-safe. The standard disallows recursion that would pass through the declaration again <em>during</em> the initialization, and the UB that results is manifesting as deadlock in your case---which makes perfect sense, since the second pass through the declaration is waiting forever for the first one to complete.</p>\n<p>Now, this was undefined behavior in C++03 as well, but in a C++03 implementation, the initialization is not required to be thread-safe, so what probably happens is this: on the first pass through the declaration, a flag is set and then the constructor is called; the second pass sees the flag, assumes the variable is already initialized, and then returns a reference to it. Then the initialization completes.</p>\n<p>You should rewrite your code, obviously, to avoid this recursive initialization.</p>\n", "LastActivityDate": "2015-10-14T01:06:06.417", "CommentCount": "3", "CreationDate": "2015-10-14T01:06:06.417", "ParentId": "33114896", "Score": "6", "OwnerUserId": "481267"}, "33114896": {"ViewCount": "441", "Body": "<p>Recently my company has begun the process of upgrading to Visual Studio 2015 from Visual Studio 2010.  The problem we're currently running into apparently seems to stem from a change in the behavior of the compiler.  We can build and run our solution, but it seems to deadlock (it seems to just idle: CPU usage is nearly 0).</p>\n<p>Stepping through with the debugger we've discovered an issue where a singleton object depends on itself during initialization.  Here's an extremely stripped down version:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Singleton\n{\n    Singleton( int n )\n    {\n        cout &lt;&lt; \"Singleton( \" &lt;&lt; n &lt;&lt; \" )\" &lt;&lt; endl;\n        cout &lt;&lt; Singleton::Instance().mN &lt;&lt; endl;\n        mN = n;\n    }\n\n    static Singleton&amp; Instance()\n    {\n        static Singleton instance( 5 );\n        return instance;\n    }\n\n    int mN;\n};\n\nint main() {\n    cout &lt;&lt; Singleton::Instance().mN &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Naturally in our code there's a lot of other things going on, but this code exhibits the same behavior that we're seeing in the main project.  In VS2010, this builds, runs, and terminates \"normally\".  In VS2015 it deadlocks.  </p>\n<p>I've also tried this in ideone.com with various versions of C++ and all of those reproduce the deadlocking behavior.  It makes sense to me that this doesn't work (nor should it work), because the object shouldn't depend on itself.</p>\n<p>What I'm more curious about is why did this \"work\" in VS2010?  What does the standard have to say about static variable initialization?  Was this just a VS2010 (and possibly earlier) compiler bug?</p>\n", "AcceptedAnswerId": "33115014", "Title": "Reentrancy in static method with static variable", "CreationDate": "2015-10-14T00:49:08.737", "Id": "33114896", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-10-14T01:06:06.417", "Score": "3", "OwnerUserId": "2779530", "Tags": "<c++><visual-c++>", "AnswerCount": "1"}});