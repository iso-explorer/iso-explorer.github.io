post_cb({"bq_ids": {"n4140": {"so_36370180_36370180_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4432}}, "n3337": {"so_36370180_36370180_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4269}}, "n4659": {"so_36370180_36370180_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5696}}}, "36370224": {"Id": "36370224", "PostTypeId": "2", "Body": "<p>The reason is that the most appropriate type for a counter of this kind is a regular <code>signed</code> integer, even if this counter is never going to get below 0.</p>\n<p>Why a counter should be <code>unsigned</code>? The fact that it cannot become negative is not a valid excuse at all given current <strong>real meaning</strong> of <code>unsigned</code> for the language.</p>\n<p><code>unsigned</code> for C++ doesn't mean an \"integer number that cannot be negative\". To understand why this definition simply doesn't make sense consider that</p>\n<ul>\n<li>The difference of two <code>unsigned</code> is <code>unsigned</code></li>\n<li>The addition of an <code>unsigned</code> with a <code>signed</code> is <code>unsigned</code></li>\n<li>An <code>unsigned</code> value is never bigger than -1</li>\n</ul>\n<p>None of the above makes any sense if you consider <code>unsigned</code> to mean \"non-negative\".</p>\n<p>Using <code>unsigned</code> for <code>size_t</code> was a mistake (see for example <a href=\"https://stackoverflow.com/q/10168079/320726\">Why is size_t unsigned?</a>), only partially* excusable because in the 16-bit era one extra bit was considered worth the wrong semantics that <code>unsigned</code> types have in C++ for this kind of use.</p>\n<p>Unfortunately now the <code>size_t</code> mistake cannot be fixed (because of backward compatibility) but why repeating the same mistake in another unrelated area?</p>\n<p>Please note that probably the big mistake made was just the choice of the name <code>unsigned</code> (given its real meaning). If that type would have been named (more appropriately) <code>modulo</code> then probably it would be more evident why using a <code>modulo int</code> for the size of a string doesn't make any sense at all.</p>\n<p>The name is irrelevant, what it counts is the semantic and <code>unsigned</code> simply has the wrong semantic for a counter or a size.</p>\n<p>(*) I personally don't think it was a good enough reason even back then. If 32767 is not enough for a size now, then 65535 won't be enough really soon. Just a single bit (twice the value) was not, in my opinion, an acceptable price for such a bending of the semantic.</p>\n<h2>EDIT</h2>\n<p>I've published a <a href=\"https://youtu.be/4afySnY-XgY\" rel=\"nofollow noreferrer\">video</a> in which I'm discussing in more details why I think that using and unsigned type for <code>size_t</code> was a design mistake in C++.</p>\n<p>Slides can be downloaded from <a href=\"http://raksy.dyndns.org/unsigned.pdf\" rel=\"nofollow noreferrer\">http://raksy.dyndns.org/unsigned.pdf</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-04T06:37:28.540", "Score": "17", "CreationDate": "2016-04-02T06:57:41.420", "ParentId": "36370180", "CommentCount": "27", "OwnerUserId": "320726", "LastEditDate": "2017-05-23T10:28:11.830"}, "36370180": {"ViewCount": "641", "Body": "<p>shared_ptr observers 20.8.2.2.5 C++14 Final Draft (n4296)</p>\n<blockquote>\n<pre><code>   long use_count() const noexcept;\n</code></pre>\n<p id=\"so_36370180_36370180_0\">Returns: the number of <code>shared_ptr</code> objects, <code>*this</code> included, that share ownership with <code>*this</code>, or 0 when <code>*this</code> is empty.</p>\n<p id=\"so_36370180_36370180_1\">[Note: <code>use_count()</code> is not necessarily efficient. \u2014 end note]</p>\n</blockquote>\n", "AcceptedAnswerId": "36370832", "Title": "Why does shared_ptr<T>::use_count() return a long instead of an unsigned type?", "CreationDate": "2016-04-02T06:51:16.590", "Id": "36370180", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2016-04-02T08:49:06.237", "LastEditorUserId": "6091491", "LastActivityDate": "2016-04-04T06:37:28.540", "Score": "22", "OwnerUserId": "6091491", "Tags": "<c++><c++14><shared-ptr>", "AnswerCount": "2"}, "36370832": {"Id": "36370832", "PostTypeId": "2", "Body": "<p>According to this page</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1450.html\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1450.html</a></p>\n<blockquote>\n<p id=\"so_36370180_36370832_0\">The return type of use_count is signed to avoid pitfalls such as\n  p.use_count() &gt; -1 evaluating to false.</p>\n</blockquote>\n<p>with a reference to</p>\n<blockquote>\n<p id=\"so_36370180_36370832_1\">John Lakos, Large-Scale C++ Software Design, section 9.2.2, page 637, Addison-Wesley, July 1996, ISBN 0-201-63362-0.</p>\n</blockquote>\n<p>Basically, it looks like a nanny-grade decision, tailored for freshman year software developers.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-04-02T08:09:34.423", "Score": "19", "CreationDate": "2016-04-02T08:08:03.627", "ParentId": "36370180", "CommentCount": "4", "OwnerUserId": "187690", "LastEditDate": "2016-04-02T08:09:34.423"}});