post_cb({"4125031": {"Id": "4125031", "PostTypeId": "2", "Body": "<p><a href=\"http://www.cplusplus.com/reference/stl/vector/swap/\" rel=\"nofollow\">All iterators that refer to the elements of the containers remain valid</a></p>\n", "LastEditorUserId": "59379", "LastActivityDate": "2012-08-10T11:16:50.433", "Score": "3", "CreationDate": "2010-11-08T15:04:22.763", "ParentId": "4124989", "CommentCount": "1", "OwnerUserId": "77673", "LastEditDate": "2012-08-10T11:16:50.433"}, "4125186": {"Id": "4125186", "PostTypeId": "2", "Body": "<p>The behavior of swap has been clarified considerably in C++11, in large part to permit the Standard Library algorithms to use argument dependent lookup (ADL) to find swap functions for user-defined types.  C++11 adds a <em>swappable</em> concept (C++11 \u00a717.6.3.2[swappable.requirements]) to make this legal (and required).</p>\n<p>The text in the C++11 language standard that addresses your question is the following text from the container requirements (\u00a723.2.1[container.requirements.general]/8), which defines the behavior of the <code>swap</code> member function of a container:</p>\n<blockquote>\n<p id=\"so_4124989_4125186_0\">Every iterator referring to an element in one container before the swap shall refer to the same element in the other container after the swap.</p>\n<p id=\"so_4124989_4125186_1\">It is unspecified whether an iterator with value <code>a.end()</code> before the swap will have value <code>b.end()</code> after the swap.</p>\n</blockquote>\n<p>In your example, <code>a</code> is guaranteed to be valid after the swap, but <code>b</code> is not because it is an end iterator.  The reason end iterators are not guaranteed to be valid is explained in a note at \u00a723.2.1/10:</p>\n<blockquote>\n<p id=\"so_4124989_4125186_2\">[Note: the <code>end()</code> iterator does not refer to any element, so it may be\n  invalidated. --end note]</p>\n</blockquote>\n<p>This is the same behavior that is defined in C++03, just substantially clarified.  The original language from C++03 is at C++03 \u00a723.1/10:</p>\n<blockquote>\n<p id=\"so_4124989_4125186_3\">no <code>swap()</code> function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped.</p>\n</blockquote>\n<p>It's not immediately obvious in the original text, but the phrase \"to the elements of the containers\" is extremely important, because <code>end()</code> iterators do not point to elements.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2012-08-10T16:43:44.583", "Score": "28", "CreationDate": "2010-11-08T15:23:20.970", "ParentId": "4124989", "CommentCount": "7", "OwnerUserId": "151292", "LastEditDate": "2012-08-10T16:43:44.583"}, "4124989": {"ViewCount": "3388", "Body": "<p>If I swap two vectors, will their iterators remain valid, now just pointing to the \"other\" container, or will the iterator be invalidated?</p>\n<p>That is, given:</p>\n<pre><code>using namespace std;\nvector&lt;int&gt; x(42, 42);\nvector&lt;int&gt; y;\nvector&lt;int&gt;::iterator a = x.begin(); \nvector&lt;int&gt;::iterator b = x.end();\n\nx.swap(y);\n\n// a and b still valid? Pointing to x or y?\n</code></pre>\n<p>It seems the std mentions nothing about this:</p>\n<blockquote>\n<p id=\"so_4124989_4124989_0\">[n3092 - 23.3.6.2] </p>\n<p id=\"so_4124989_4124989_1\"><code>void swap(vector&lt;T,Allocator&gt;&amp; x);</code></p>\n<p id=\"so_4124989_4124989_2\">Effects:\n  Exchanges the contents and capacity()\n  of *this with that of x.</p>\n</blockquote>\n<p>Note that since I'm on VS 2005 I'm also interested in the effects of iterator debug checks etc. (_SECURE_SCL)</p>\n", "AcceptedAnswerId": "4125186", "Title": "Does std::vector::swap invalidate iterators?", "CreationDate": "2010-11-08T14:58:56.997", "Id": "4124989", "CommentCount": "2", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2010-11-08T16:37:05.350", "LastEditorUserId": "321013", "LastActivityDate": "2012-08-10T16:43:44.583", "Score": "39", "OwnerUserId": "321013", "Tags": "<c++><visual-c++><stl><iterator>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_4124989_4125060_0": {"length": 15, "quality": 1.0, "section_id": 710}, "so_4124989_4125186_2": {"length": 7, "quality": 0.7, "section_id": 712}, "so_4124989_4125186_1": {"length": 13, "quality": 1.0, "section_id": 710}, "so_4124989_4125186_3": {"length": 11, "quality": 1.0, "section_id": 712}, "so_4124989_4125186_0": {"length": 15, "quality": 1.0, "section_id": 710}}, "n3337": {"so_4124989_4125186_2": {"length": 7, "quality": 0.7, "section_id": 701}, "so_4124989_4125186_1": {"length": 13, "quality": 1.0, "section_id": 699}, "so_4124989_4125186_0": {"length": 15, "quality": 1.0, "section_id": 699}, "so_4124989_4125186_3": {"length": 11, "quality": 1.0, "section_id": 701}, "so_4124989_4125060_0": {"length": 15, "quality": 1.0, "section_id": 699}}, "n4659": {"so_4124989_4125186_2": {"length": 7, "quality": 0.7, "section_id": 741}, "so_4124989_4125186_1": {"length": 13, "quality": 1.0, "section_id": 739}, "so_4124989_4125186_0": {"length": 15, "quality": 1.0, "section_id": 739}, "so_4124989_4125186_3": {"length": 11, "quality": 1.0, "section_id": 741}, "so_4124989_4125060_0": {"length": 15, "quality": 1.0, "section_id": 739}}}, "4125017": {"Id": "4125017", "PostTypeId": "2", "Body": "<p>Swapping two vectors does not invalidate the iterators, pointers, and references to its elements (C++03, 23.1.11).</p>\n<p>Typically the iterator would contain knowledge of its container, and the swap operation maintains this for a given iterator.</p>\n<p>In VC++ 10 the vector container is managed using this structure in <code>&lt;xutility&gt;</code>, for example:</p>\n<pre><code>struct _Container_proxy\n{   // store head of iterator chain and back pointer\n    _Container_proxy()\n    : _Mycont(0), _Myfirstiter(0)\n    {   // construct from pointers\n    }\n\n    const _Container_base12 *_Mycont;\n    _Iterator_base12 *_Myfirstiter;\n};\n</code></pre>\n", "LastEditorUserId": "210102", "LastActivityDate": "2010-11-08T15:38:33.220", "Score": "13", "CreationDate": "2010-11-08T15:02:47.227", "ParentId": "4124989", "CommentCount": "6", "OwnerUserId": "210102", "LastEditDate": "2010-11-08T15:38:33.220"}, "4125060": {"Id": "4125060", "PostTypeId": "2", "Body": "<p>As for Visual Studio 2005, I have just tested it.\nI think it should always work, as the vector::swap function even contains an explicit step to swap everything:</p>\n<pre><code> // vector-header\n    void swap(_Myt&amp; _Right)\n        {   // exchange contents with _Right\n        if (this-&gt;_Alval == _Right._Alval)\n            {   // same allocator, swap control information\n\n #if _HAS_ITERATOR_DEBUGGING\n            this-&gt;_Swap_all(_Right);\n #endif /* _HAS_ITERATOR_DEBUGGING */\n ...\n</code></pre>\n<p>The iterators point to their original elements in the now-swapped vector object. (I.e. w/rg to the OP, they first pointed to elements in <code>x</code>, after the swap they point to elements in <code>y</code>.) </p>\n<p>Note that in the n3092 draft the requirement is laid out in \u00a723.2.1/9 :</p>\n<blockquote>\n<p id=\"so_4124989_4125060_0\">Every iterator referring to an\n  element in one container before the\n  swap shall refer to the same element\n  in the other container after the swap.</p>\n</blockquote>\n", "LastActivityDate": "2010-11-08T15:07:57.493", "CommentCount": "1", "CreationDate": "2010-11-08T15:07:57.493", "ParentId": "4124989", "Score": "1", "OwnerUserId": "321013"}});