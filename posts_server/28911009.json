post_cb({"bq_ids": {"n4140": {"so_28911009_28911018_1": {"length": 5, "quality": 1.0, "section_id": 6324}, "so_28911009_28911018_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6323}}, "n3337": {"so_28911009_28911018_1": {"length": 5, "quality": 1.0, "section_id": 6081}, "so_28911009_28911018_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6080}}, "n4659": {"so_28911009_28911018_1": {"length": 5, "quality": 1.0, "section_id": 7834}, "so_28911009_28911018_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 7833}}}, "28911018": {"Id": "28911018", "PostTypeId": "2", "Body": "<p>It is undefined behavior to instantiate a standard library container with an incomplete type. [res.on.functions]/1, 2.5:</p>\n<blockquote>\n<p id=\"so_28911009_28911018_0\">1 In certain cases (replacement functions, handler functions,\n  operations on types used to instantiate standard library template\n  components), the C++ standard library depends on components supplied\n  by a C++ program. If these components do not meet their requirements,\n  the Standard places no requirements on the implementation.</p>\n<p id=\"so_28911009_28911018_1\">2 In particular, the effects are undefined in the following cases:</p>\n<ul>\n<li>[...]</li>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for\n  that component.</li>\n</ul>\n</blockquote>\n<p>Both implementations are correct.</p>\n<p>There is currently a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html\" rel=\"nofollow\">proposal</a> to add incomplete type support to some containers, but it is limited to <code>vector</code>, <code>list</code> and <code>forward_list</code>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-03-07T03:35:41.630", "Score": "8", "CreationDate": "2015-03-07T03:21:35.353", "ParentId": "28911009", "CommentCount": "8", "OwnerUserId": "2756719", "LastEditDate": "2015-03-07T03:35:41.630"}, "28911009": {"ViewCount": "220", "Body": "<p>Consider the code related to a previous SO question <a href=\"https://stackoverflow.com/q/28910892/3093378\">C++ cyclic dependency confusion with adjacency list representation</a></p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;unordered_set&gt;\n\nclass Node;\n\nclass Hash {\npublic:\n    std::size_t operator()(const Node &amp;node) const;\n};\n\nclass Node {\npublic:\n    int data;\n    std::unordered_set&lt;Node, Hash&gt; links;\n};\n\ninline size_t Hash::operator()(const Node &amp;node) const {\n    return node.data;\n}\n\nint main()\n{\n\n}\n</code></pre>\n<p>This code does not compile when using g++4.9.2 or g++5, however compiles with clang++3.5.</p>\n<p>The error spit out by g++ starts with</p>\n<blockquote>\n<p id=\"so_28911009_28911009_0\"><code>error: invalid application of 'sizeof' to incomplete type 'Node'</code>\n<code>: std::aligned_storage&lt;sizeof(_Tp), std::alignment_of&lt;_Tp&gt;::value&gt;</code></p>\n</blockquote>\n<p><strong>Question:</strong> Does <code>Node</code> have to be a complete type when declaring an <code>std::unordered_set</code>? Looks like either g++ or clang++ is wrong in this case.</p>\n<p>PS: I know this situation can be avoided by using a <code>std::shared_ptr&lt;Node&gt;</code> instead, however would like to understand the behaviour in the code above.</p>\n", "AcceptedAnswerId": "28911018", "Title": "incomplete type for std::unordered_set compiling error in g++5, compiles in clang++", "CreationDate": "2015-03-07T03:19:57.003", "Id": "28911009", "CommentCount": "0", "LastEditDate": "2017-05-23T12:12:52.353", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-07T03:35:41.630", "Score": "1", "OwnerUserId": "3093378", "Tags": "<c++><c++11><clang><incomplete-type><gcc5>", "AnswerCount": "1"}});