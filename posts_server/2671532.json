post_cb({"2671694": {"ParentId": "2671532", "CommentCount": "1", "Body": "<p>There's \u00a712.8/14:</p>\n<blockquote>\n<p id=\"so_2671532_2671694_0\">A program is ill-formed if the copy constructor or the copy assignment operator for an object is implicitly used and the special member function is not accessible.</p>\n</blockquote>\n<p>And then there's \u00a712.8/15:</p>\n<blockquote>\n<p id=\"so_2671532_2671694_1\">When certain criteria are met, an implementation is allowed to omit the copy construction of a class object, even if the copy constructor and/or destructor for the object have side effects. </p>\n</blockquote>\n<p>So, the question is really, if the implementation omits the call to the copy constructor (which it is clearly allowed to do), is the copy constructor actually <em>used</em>?  </p>\n<p>And, the answer to that is yes, per \u00a73.2/2:</p>\n<blockquote>\n<p id=\"so_2671532_2671694_2\">A copy constructor is used even if the call is actually elided by the implementation.</p>\n</blockquote>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "2671694", "Score": "3", "CreationDate": "2010-04-19T23:59:27.140", "LastActivityDate": "2010-04-19T23:59:27.140"}, "2671960": {"ParentId": "2671532", "CommentCount": "4", "Body": "<p>I don't think template metaprogamming is needed.  Try</p>\n<pre><code>template &lt;class T&gt;\nvoid doit()\n{\n    struct initer { T t; initer() : t() {} } inited;\n    T&amp; t = inited.t;\n    ...\n}\n</code></pre>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "2671960", "Score": "5", "CreationDate": "2010-04-20T01:22:02.933", "LastActivityDate": "2010-04-20T01:22:02.933"}, "2671648": {"ParentId": "2671532", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The behavior you're seeing in MSVC is an extension, though it's documented as such in a roundabout way on the following page (emphasis mine) <a href=\"http://msdn.microsoft.com/en-us/library/0yw5843c.aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/0yw5843c.aspx</a>:</p>\n<blockquote>\n<p id=\"so_2671532_2671648_0\">The equal-sign initialization syntax is different from the function-style syntax, even though the generated code is identical in most cases. The difference is that when the equal-sign syntax is used, the compiler has to behave as if the following sequence of events were taking place:</p>\n<ul>\n<li>Creating a temporary object of the same type as the object being initialized.</li>\n<li>Copying the temporary object to the object.</li>\n</ul>\n<p id=\"so_2671532_2671648_1\">The constructor must be accessible before the compiler can perform these steps. Even though the compiler can eliminate the temporary creation and copy steps in most cases, an inaccessible copy constructor causes equal-sign initialization to fail (<strong>under /Za, /Ze (Disable Language Extensions)</strong>). </p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/2671532/non-copyable-objects-and-value-initialization-g-vs-msvc/2671960#2671960\">See Ben Voigt's answer</a> for a workaround which is a simplified version of <a href=\"http://www.boost.org/doc/libs/1_41_0/libs/utility/value_init.htm\" rel=\"nofollow noreferrer\"><code>boost::value_initialized</code></a>, as pointed out by litb in a comment to Ben's answer.  The docs for <code>boost::value_initalized</code> has a great discussion of the problem, the workaround, and some of the pitfalls of various compiler issues.</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:32:33.850", "Id": "2671648", "Score": "8", "CreationDate": "2010-04-19T23:45:37.617", "LastActivityDate": "2010-04-20T17:49:16.330"}, "2671760": {"ParentId": "2671532", "CommentCount": "9", "Body": "<p>Have you seen what happens when you compile using /Wall with MSVC?  It states the following about your class:</p>\n<pre><code>nocopy.cc(21) : warning C4625: 'noncopyable' : copy constructor could not be\ngenerated because a base class copy constructor is inaccessible\nnocopy.cc(21) : warning C4626: 'noncopyable' : assignment operator could not be\ngenerated because a base class assignment operator is inaccessible\n</code></pre>\n<p>GCC remedy:\ncreate a copy constructor for <code>noncopyable</code> (and an assignment operator ideally!) that does what it can to copy the information from <code>noncopyable_base</code>, namely invoking the constructor for <code>noncopyable_base</code> that has no parameters (since that is the only one accessible by <code>noncopyable</code>) and then copying any data from <code>noncopyable_base</code>.  Given the definition of <code>noncopyable_base</code>, however, it seems there is no data to copy, so the simple addition of <code>noncopyable_base()</code> to the initializer list of a new <code>noncopyable(const noncopyable &amp;)</code> function should work.</p>\n<p>Take note of what MSVC said about your program though.  Also note that if you use <code>T t()</code> rather than <code>T t = T()</code>, <a href=\"http://msdn.microsoft.com/en-us/library/4ddd21xh.aspx\" rel=\"nofollow noreferrer\">another warning (C4930)</a> is generated by MSVC, though GCC happily accepts it either way without any warning issued.</p>\n", "OwnerUserId": "233239", "PostTypeId": "2", "Id": "2671760", "Score": "0", "CreationDate": "2010-04-20T00:21:17.977", "LastActivityDate": "2010-04-20T00:21:17.977"}, "bq_ids": {"n4140": {"so_2671532_2671694_2": {"section_id": 7040, "quality": 0.8571428571428571, "length": 6}, "so_2671532_2671694_1": {"section_id": 480, "quality": 0.9, "length": 18}, "so_2671532_2671694_0": {"section_id": 479, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_2671532_2671694_2": {"section_id": 6785, "quality": 1.0, "length": 7}, "so_2671532_2671694_1": {"section_id": 471, "quality": 0.9, "length": 18}, "so_2671532_2671694_0": {"section_id": 470, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_2671532_2671694_2": {"section_id": 8537, "quality": 0.8571428571428571, "length": 6}, "so_2671532_2671694_1": {"section_id": 502, "quality": 0.9, "length": 18}, "so_2671532_2671694_0": {"section_id": 473, "quality": 0.8333333333333334, "length": 10}}}, "2671532": {"CommentCount": "7", "AcceptedAnswerId": "2671648", "CreationDate": "2010-04-19T23:11:23.447", "LastActivityDate": "2010-04-20T17:49:16.330", "PostTypeId": "1", "ViewCount": "1296", "FavoriteCount": "2", "Title": "non-copyable objects and value initialization: g++ vs msvc", "Id": "2671532", "Score": "4", "Body": "<p>I'm seeing some different behavior between g++ and msvc around value initializing non-copyable objects.  Consider a class that is non-copyable:</p>\n<pre><code>class noncopyable_base\n{\npublic:\n    noncopyable_base() {}\n\nprivate:\n    noncopyable_base(const noncopyable_base &amp;);\n    noncopyable_base &amp;operator=(const noncopyable_base &amp;);\n};\n\nclass noncopyable : private noncopyable_base\n{\npublic:\n    noncopyable() : x_(0) {}\n    noncopyable(int x) : x_(x) {}\n\nprivate:\n    int x_;\n};\n</code></pre>\n<p>and a template that uses value initialization so that the value will get a known value even when the type is POD:</p>\n<pre><code>template &lt;class T&gt;\nvoid doit()\n{\n    T t = T();\n    ...\n}\n</code></pre>\n<p>and trying to use those together:</p>\n<pre><code>doit&lt;noncopyable&gt;();\n</code></pre>\n<p>This works fine on msvc as of VC++ 9.0 but fails on every version of g++ I tested this with (including version 4.5.0) because the copy constructor is private.</p>\n<p>Two questions:</p>\n<ol>\n<li>Which behavior is standards compliant?</li>\n<li>Any suggestion of how to work around this in gcc (and to be clear, changing that to <code>T t;</code> is not an acceptable solution as this breaks POD types).</li>\n</ol>\n<p>P.S. I see the same problem with boost::noncopyable.</p>\n", "Tags": "<c++><gcc><visual-c++><value-initialization>", "OwnerUserId": "29809", "AnswerCount": "4"}});