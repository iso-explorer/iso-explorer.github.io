post_cb({"11545508": {"ParentId": "11545316", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Your code is ambiguous and should not compile (it is <em>ill-formed</em> per 13.3.3:2).</p>\n<p>lvalue-to-rvalue conversion has the same rank as identity conversion, so (per 13.3.3:1) there is no way to choose between them.</p>\n<p><a href=\"http://www.comeaucomputing.com/tryitout\" rel=\"nofollow\">Comeau C++</a> (probably the most standards-compliant compiler) gives the following error:</p>\n<pre><code>\"ComeauTest.c\", line 11: error: more than one user-defined conversion from \"B\" to\n          \"A\" applies:\n            function \"B::operator A()\"\n            function \"B::operator A &amp;()\"\n    (A) b;\n        ^\n</code></pre>\n<p>Here's the relevant text from the standard:</p>\n<blockquote>\n<p id=\"so_11545316_11545508_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>13.3.3 Best viable function [over.match.best]</h3>\n<p id=\"so_11545316_11545508_1\">[...] Given these de\ufb01nitions, a viable function F1 is de\ufb01ned to be a better function than another viable function F2 [...]</p>\n<p id=\"so_11545316_11545508_2\">2 - \n  If there is exactly one viable function that is a better function than all other viable functions, then it is the\n  one selected by overload resolution; otherwise the call is ill-formed.</p>\n</blockquote>\n<p>The definitions themselves are complicated, but there's two things to note with user-defined conversions:</p>\n<p>First, the application of user-defined conversion as a conversion sequence is specified to decompose into a sequence <code>S_a - U - S_b</code> of a standard conversion sequence followed by a user-defined conversion followed by another standard conversion sequence.  This covers all the cases; you can't have more than one user-defined conversion in a conversion sequence, and a standard conversion sequence can be the \"identity conversion\" i.e. no conversion required.</p>\n<p>Second, when comparing user-defined conversion sequences the only part that matters is the second standard conversion sequence.  This is in 13.3.3:</p>\n<blockquote>\n<p id=\"so_11545316_11545508_3\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>13.3.3 Best viable function [over.match.best]</h3>\n<p id=\"so_11545316_11545508_4\">[...] a viable function F1 is de\ufb01ned to be a better function than another viable function\n  F2 if [...]</p>\n<ul>\n<li>the context is an initialization by user-de\ufb01ned conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type.</li>\n</ul>\n</blockquote>\n<p>and in 13.3.3.2:</p>\n<blockquote>\n<p id=\"so_11545316_11545508_5\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</h3>\n<p id=\"so_11545316_11545508_6\">3 - Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of\n  the following rules applies: [...]</p>\n<ul>\n<li>User-de\ufb01ned conversion sequence U1 is a better conversion sequence than another user-de\ufb01ned conversion sequence U2 if they contain the same user-de\ufb01ned conversion function or constructor or aggregate\n  initialization and the second standard conversion sequence of U1 is better than the second standard\n  conversion sequence of U2.</li>\n</ul>\n</blockquote>\n<p>So when comparing conversion sequences <code>U1 = (S1_a - U'1 - S1_b)</code> and <code>U2 = (S2_a - U'2 - S2_b)</code> the only thing that matters is the relative rank of <code>S1_b</code> and <code>S2_b</code>; the standard conversion sequences required to arrive at the parameter of the user-defined conversions do not matter.</p>\n<p>So the possible conversion sequences for <code>(A) b</code>, requiring a conversion sequence yielding <code>B -&gt; A</code>, are:</p>\n<pre><code>U1: B -&gt; B [identity], B::operator A() [user-defined], A -&gt; A [identity]\nU2: B -&gt; B [identity], B::operator A &amp;() [user-defined], A &amp; -&gt; A [rvalue-to-lvalue]\n</code></pre>\n<p>Now, how do we rank standard conversion sequences?  The place to look is table 12 in 13.3.3.1.1, which specifies that lvalue-to-rvalue conversion has the same rank (\"Exact Match\") as identity conversion. So the two user-defined conversion sequences cannot be distinguished, and the program is ill-formed.</p>\n<hr/>\n<h2>Sidebar</h2>\n<p>What's the difference between 13.3.3 and 13.3.3.2 as regards ranking user-defined conversion sequences?</p>\n<p>13.3.3 allows the compiler to distinguish between <em>different user-defined conversion operators</em>; 13.3.3.2 allows the compiler to distinguish between <em>different functions</em> that each require a user-defined conversion in their arguments.</p>\n<p>So, in the code</p>\n<pre><code>struct A {\n    operator int();\n    operator float();\n} a;\nvoid f(int);\nf(a);\n</code></pre>\n<p>13.3.3 applies and <code>A::operator int()</code> is selected over <code>A::operator float()</code>; in the code</p>\n<pre><code>struct A {\n    operator int();\n} a;\nvoid f(int);\nvoid f(double);\nf(a);\n</code></pre>\n<p>13.3.3.2 applies and <code>void f(int)</code> is selected over <code>void f(double)</code>.  However in the code</p>\n<pre><code>struct A {\n    operator int();\n    operator float();\n} a;\nvoid f(int);\nvoid f(double);\nf(a);\n</code></pre>\n<p>even though 13.3.3 prefers <code>A::operator int() -&gt; void f(int)</code> over <code>A::operator float() -&gt; void f(int)</code> and <code>float -&gt; double</code> over <code>int -&gt; double</code>, and 13.3.3.2 prefers <code>int -&gt; int</code> over <code>int -&gt; double</code> and <code>float -&gt; double</code> over <code>float -&gt; int</code>, there is no way to distinguish between the <code>int -&gt; int</code> and <code>float -&gt; double</code> conversion sequences (because they contain neither the same user-defined conversion operator nor the same overload of <code>f</code>), and so the code is ill-formed.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-07-18T18:51:38.140", "Id": "11545508", "Score": "8", "CreationDate": "2012-07-18T15:59:11.213", "LastActivityDate": "2012-07-18T18:51:38.140"}, "11545316": {"CommentCount": "3", "AcceptedAnswerId": "11545508", "PostTypeId": "1", "LastEditorUserId": "673730", "CreationDate": "2012-07-18T15:49:42.273", "LastActivityDate": "2012-07-18T18:51:38.140", "LastEditDate": "2012-07-18T15:59:24.380", "ViewCount": "200", "FavoriteCount": "2", "Title": "Given the following code (in GCC 4.3) , why is the conversion to reference called twice?", "Id": "11545316", "Score": "3", "Body": "<p>Given the following code (in GCC 4.3) , why is the conversion to reference called in both cases?</p>\n<pre><code>class A { };\n\nclass B {\npublic:\n  operator A() {}\n  operator A&amp;() {}\n};\n\nint main() {\n  B b;\n  (A) b;\n  (A&amp;) b;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/d6iF8\" rel=\"nofollow\">http://ideone.com/d6iF8</a></p>\n", "Tags": "<c++>", "OwnerUserId": "602372", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11545316_11545508_1": {"section_id": 603, "quality": 0.7272727272727273, "length": 8}, "so_11545316_11545508_4": {"section_id": 603, "quality": 0.7777777777777778, "length": 7}, "so_11545316_11545508_6": {"section_id": 639, "quality": 1.0, "length": 13}, "so_11545316_11545508_2": {"section_id": 604, "quality": 1.0, "length": 20}}, "n3337": {"so_11545316_11545508_1": {"section_id": 593, "quality": 0.7272727272727273, "length": 8}, "so_11545316_11545508_4": {"section_id": 593, "quality": 0.7777777777777778, "length": 7}, "so_11545316_11545508_6": {"section_id": 629, "quality": 1.0, "length": 13}, "so_11545316_11545508_2": {"section_id": 594, "quality": 1.0, "length": 20}}, "n4659": {"so_11545316_11545508_1": {"section_id": 629, "quality": 0.7272727272727273, "length": 8}, "so_11545316_11545508_4": {"section_id": 629, "quality": 0.7777777777777778, "length": 7}, "so_11545316_11545508_6": {"section_id": 667, "quality": 1.0, "length": 13}, "so_11545316_11545508_2": {"section_id": 630, "quality": 1.0, "length": 20}}}});