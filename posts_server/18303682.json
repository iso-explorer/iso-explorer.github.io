post_cb({"18303778": {"Id": "18303778", "PostTypeId": "2", "Body": "<p>Yes. See C11 6.3.1.3 Signed and unsigned integers:</p>\n<blockquote>\n<p id=\"so_18303682_18303778_0\">1 When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.</p>\n<p id=\"so_18303682_18303778_1\">2 Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.<sup>60)</sup></p>\n<p id=\"so_18303682_18303778_2\">3 Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.</p>\n<p id=\"so_18303682_18303778_3\"><sup>60)</sup> The rules describe arithmetic on the mathematical value, not the value of a given type of expression.</p>\n</blockquote>\n<p>Case 2 applies, so -1 is reduced modulo 0x10000000000000000 to yield 0xffffffffffffffff.</p>\n", "LastEditorUserId": "15168", "LastActivityDate": "2013-08-18T21:34:52.277", "Score": "14", "CreationDate": "2013-08-18T21:19:04.270", "ParentId": "18303682", "CommentCount": "2", "OwnerUserId": "379897", "LastEditDate": "2013-08-18T21:34:52.277"}, "18303824": {"Id": "18303824", "PostTypeId": "2", "Body": "<p>This is a question that can be answered with a few lines of code.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nmain()\n{\n    int          x;\n    unsigned int y;\n\n    x = -1;\n    printf(\"\\n0x%08x\", x);\n\n    y = (unsigned int) -1;\n    printf(\"\\n0x%08x\", y);\n\n}\n</code></pre>\n<p>Running this code on Eclipse/Microsoft C compiler produces:</p>\n<pre><code>0xffffffff\n0xffffffff\n</code></pre>\n<p>A similar program can show you what <code>uint64_t</code> produces.  </p>\n<p>Finally, if you understand how computers use 2's complement numbers to add numbers, then you will understand that -1 for words of any number of bits (8, 32, 64, etc.) is always all ff's for every byte in the word/double word, etc.</p>\n", "LastActivityDate": "2013-08-18T21:24:21.107", "CommentCount": "6", "CreationDate": "2013-08-18T21:24:21.107", "ParentId": "18303682", "Score": "-5", "OwnerUserId": "2612271"}, "31889511": {"Id": "31889511", "PostTypeId": "2", "Body": "<p>I'm guessing you're writing <code>(uint64_t)-1</code> instead of <code>-1ULL</code> because you don't want to make assumptions about the size of <code>unsigned long long</code>? If so, that's good. However, there is an alternative which hasn't been mentioned yet (and doesn't actually answer your question) but can save a lot of worry by side-stepping the question:</p>\n<h2>An alternative</h2>\n<p>A good habit to be in is to always use <code>UINT64_C(x)</code> instead of <code>(uint64_t)x</code>.  This is a macro defined in <code>&lt;stdint.h&gt;</code> which automatically appends <code>U</code>, <code>UL</code>, or <code>ULL</code> as needed. Thus, <code>UINT64_C(-1)</code> resolves to either <code>-1U</code>, <code>-1UL</code>, or <code>-1ULL</code>, depending on your target.  This is guaranteed to always work correctly.</p>\n<h2>Perils of type-casting</h2>\n<p>Note that <code>(uint64_t)x</code> actually does not even work correctly in general. For example,</p>\n<pre><code>(uint64_t)2147483648                // RISKY\n</code></pre>\n<p>generates a warning on some compilers because the value 2147483648 (2^31) is too big to \ufb01t into a 32-bit integer, and the following does not even remotely work:</p>\n<pre><code>(uint64_t)1000000000000000000       // RISKY\n</code></pre>\n<p>However, if you use <code>UINT64_C()</code> instead, then everything is golden:</p>\n<pre><code>UINT64_C(2147483648)                // GOOD\n\nUINT64_C(1000000000000000000)       // GOOD\n\nUINT64_C(-1)                        // GOOD\n</code></pre>\n<p>Notes:</p>\n<ul>\n<li>The <code>_C</code> suffix stands for \u201cconstant.\u201d</li>\n<li>In <code>&lt;stdint.h&gt;</code> there are also 8-, 16-, and 32-bit versions for both signed and unsigned values.</li>\n<li>For the special case of \u20131, you could also just write <code>UINT64_MAX</code>.</li>\n</ul>\n", "LastEditorUserId": "267551", "LastActivityDate": "2015-08-08T18:07:02.550", "Score": "2", "CreationDate": "2015-08-08T04:01:56.133", "ParentId": "18303682", "CommentCount": "1", "OwnerUserId": "267551", "LastEditDate": "2015-08-08T18:07:02.550"}, "bq_ids": {"n4140": {"so_18303682_18303778_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 6035}}, "n3337": {"so_18303682_18303778_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 5930}}, "n4659": {"so_18303682_18303778_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 7534}}}, "18303731": {"Id": "18303731", "PostTypeId": "2", "Body": "<p>The expressions <code>1</code> and <code>-1</code> have type <code>int</code>. When converted to <code>uint64_t</code>, the principle that 2<sup>n</sup> is added or subtracted until the value is in range applies, so the result is always 2<sup>n</sup>-1, in this case with n=64. Therefore, <code>(uint64_t)-1</code> is always 2<sup>64</sup>-1..</p>\n<p>The expression <code>(int64_t)-1</code> evaluates to -1, so the same reasoning applies to the expression <code>(uint64_t)(int64_t)-1</code>, which too always evaluates to 2<sup>64</sup>-1.</p>\n<p>On the other hand, <code>(unsigned)-1</code> is a positive value of type <code>unsigned int</code> that may be 2<sup>16</sup>-1, 2<sup>32</sup>-1, 2<sup>64</sup>-1 or various other values depending on the compilation platform. These values may not yield 2<sup>64</sup>-1 when converted to <code>uint64_t</code>.</p>\n", "LastEditorUserId": "139746", "LastActivityDate": "2013-08-18T21:19:14.030", "Score": "5", "CreationDate": "2013-08-18T21:13:37.600", "ParentId": "18303682", "CommentCount": "11", "OwnerUserId": "139746", "LastEditDate": "2013-08-18T21:19:14.030"}, "18303682": {"ViewCount": "3502", "Body": "<p>I know, that it is well defined by the C standard that <code>(unsigned)-1</code> must yield 2^n-1, i. e. an unsigned integer with all its bits set. The same goes for <code>(uint64_t)-1ll</code>. However, I cannot find something in the C11 standard that specifies how <code>(uint64_t)-1</code> is interpreted.</p>\n<p>So, the question is: Is there any guarantee in the C standard, which of the following holds true?</p>\n<pre><code>(uint64_t)-1 == (uint64_t)(unsigned)-1   //0x00000000ffffffff\n(uint64_t)-1 == (uint64_t)(int64_t)-1    //0xffffffffffffffff\n</code></pre>\n", "AcceptedAnswerId": "18303778", "Title": "Is (uint64_t)-1 guaranteed to yield 0xffffffffffffffff?", "CreationDate": "2013-08-18T21:08:13.590", "Id": "18303682", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-08-08T18:07:02.550", "Score": "13", "OwnerUserId": "2445184", "Tags": "<c++><c><standards><c11>", "AnswerCount": "4"}});