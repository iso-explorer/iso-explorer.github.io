post_cb({"35553018": {"Id": "35553018", "PostTypeId": "2", "Body": "<p>This is ill-formed in C++14 and earlier:</p>\n<pre><code>using fp2_type = void(*)() noexcept;\n</code></pre>\n<p>due to N4140 [except.spec]/2:</p>\n<blockquote>\n<p id=\"so_35551197_35553018_0\">An <em>exception-specification</em> shall not appear in a typedef declaration or <em>alias-declaration</em>.</p>\n</blockquote>\n<p>So I'm going to assume that the question is for C++1z, where exception specification is part of the type system.</p>\n<hr>\n<p><a href=\"http://eel.is/c++draft/conv.fctptr\" rel=\"nofollow\">[conv.fctptr]/1</a>:</p>\n<blockquote>\n<p id=\"so_35551197_35553018_1\">A prvalue of type \u201cpointer to <code>noexcept</code> function\u201d can be converted to\n  a prvalue of type \u201cpointer to function\u201d. The result is a pointer to\n  the function. </p>\n</blockquote>\n<p>Thus, <code>void (*)() noexcept</code> can be (implicitly) converted to <code>void (*)()</code>.</p>\n<p><a href=\"http://eel.is/c++draft/expr.static.cast#7\" rel=\"nofollow\">[expr.static.cast]/7</a>:</p>\n<blockquote>\n<p id=\"so_35551197_35553018_2\">The inverse of any standard conversion sequence (Clause [conv]) not\n  containing a [(various other cases omitted)] function pointer ([conv.fctptr]) conversion, can be performed\n  explicitly using <code>static_cast</code>.</p>\n</blockquote>\n<p>Nothing else in [expr.static.cast] allows converting <code>void (*)()</code> to <code>void (*)() noexcept</code> either, so this is not a conversion that can be performed by a <code>static_cast</code>.</p>\n<p><a href=\"http://eel.is/c++draft/expr.reinterpret.cast#6\" rel=\"nofollow\">[expr.reinterpret.cast]/6</a>:</p>\n<blockquote>\n<p id=\"so_35551197_35553018_3\">A function pointer can be explicitly converted to a function pointer\n  of a different type. The effect of calling a function through a\n  pointer to a function type ([dcl.fct]) that is not the same as the\n  type used in the definition of the function is undefined. Except that\n  converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to\n  <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are function types) and back to its original type\n  yields the original pointer value, the result of such a pointer\n  conversion is unspecified. [ Note: see also [conv.ptr] for more\n  details of pointer conversions.  \u2014 end note ]</p>\n</blockquote>\n<p>So <code>reinterpret_cast</code> can perform this conversion.</p>\n<p>Since <code>fp2_type(fp)</code> is equivalent to the C-style cast <code>(fp2_type) fp</code> (<a href=\"http://eel.is/c++draft/expr.type.conv\" rel=\"nofollow\">[expr.type.conv]/1</a>), and <a href=\"http://eel.is/c++draft/expr.cast#4\" rel=\"nofollow\">since C-style casts do a <code>reinterpret_cast</code> when <code>static_cast</code> is not possible</a> (ignoring <code>const_cast</code> for simplicity, as it's not relevant here), <code>fp2_type(fp)</code> is a well-formed <code>reinterpret_cast</code>. The result of such a cast cannot be used except to cast it back, however.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2016-04-29T11:05:07.950", "Score": "3", "CreationDate": "2016-02-22T11:56:46.900", "ParentId": "35551197", "CommentCount": "2", "LastEditDate": "2016-04-29T11:05:07.950", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_35551197_35553018_1": {"length": 12, "quality": 0.8, "section_id": 6049}, "so_35551197_35553018_2": {"length": 12, "quality": 0.6, "section_id": 6033}, "so_35551197_35553018_0": {"length": 5, "quality": 1.0, "section_id": 3364}, "so_35551197_35553018_3": {"length": 50, "quality": 0.8928571428571429, "section_id": 6045}}, "n3337": {"so_35551197_35553018_1": {"length": 12, "quality": 0.8, "section_id": 5817}, "so_35551197_35553018_2": {"length": 12, "quality": 0.6, "section_id": 5801}, "so_35551197_35553018_0": {"length": 5, "quality": 1.0, "section_id": 3234}, "so_35551197_35553018_3": {"length": 50, "quality": 0.8928571428571429, "section_id": 5813}}, "n4659": {"so_35551197_35553018_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 44}, "so_35551197_35553018_2": {"length": 13, "quality": 0.65, "section_id": 7532}, "so_35551197_35553018_0": {"length": 4, "quality": 0.8, "section_id": 3998}, "so_35551197_35553018_3": {"length": 49, "quality": 0.875, "section_id": 7544}}}, "35551197": {"ViewCount": "171", "Body": "<p>Say I have these declarations:</p>\n<pre><code>using fp_type = void(*)();\nusing fp2_type = void(*)() noexcept;\n</code></pre>\n<p>and</p>\n<pre><code>void func(){}\nfp_type fp(func);\n</code></pre>\n<p>Is the cast <code>fp2_type(fp)</code> well-formed? The other way around (casting a noexcept-specified function pointer into a function pointer without a noexcept specifier)?</p>\n", "AcceptedAnswerId": "35553018", "Title": "Casting a function pointer into a noexcept specified function pointer", "CreationDate": "2016-02-22T10:25:49.547", "Id": "35551197", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-02-22T10:31:30.470", "LastEditorUserId": "3747990", "LastActivityDate": "2016-04-29T11:05:07.950", "Score": "6", "OwnerUserId": "1095108", "Tags": "<c++><function-pointers><noexcept>", "AnswerCount": "1"}});