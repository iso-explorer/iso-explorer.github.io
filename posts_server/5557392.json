post_cb({"5557453": {"ParentId": "5557392", "CommentCount": "0", "Body": "<p>Like any overloaded operator, <code>operator()</code> is a strange-looking name of a function.  It must be a member function of a class or struct, but there are no restrictions on its arguments other than the usual rules for all functions.</p>\n<p>To evaluate the expression <code>x(</code><em>args</em><code>)</code> when the type of <code>x</code> is a class type, C++ will attempt to call <code>x.operator()(</code><em>args</em><code>)</code>, where <em>args</em> can be the empty string or any number of function arguments.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "5557453", "Score": "1", "CreationDate": "2011-04-05T19:34:46.957", "LastActivityDate": "2011-04-05T19:34:46.957"}, "5557422": {"ParentId": "5557392", "CommentCount": "0", "Body": "<p>If you implement <code>operator()</code> for a class <code>C</code>, then if <code>c</code> is an object of type <code>C</code> you can write <code>c()</code>, which invokes <code>c.operator()()</code>. You can have as many parameters to <code>operator()</code> as you like.</p>\n<p>For one good example of when <code>operator()</code> is useful, see here:</p>\n<p><a href=\"http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.10\" rel=\"nofollow\">http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.10</a></p>\n", "OwnerUserId": "499449", "PostTypeId": "2", "Id": "5557422", "Score": "3", "CreationDate": "2011-04-05T19:32:25.937", "LastActivityDate": "2011-04-05T19:32:25.937"}, "5557392": {"CommentCount": "0", "ViewCount": "873", "PostTypeId": "1", "LastEditorUserId": "3885376", "CreationDate": "2011-04-05T19:29:56.840", "LastActivityDate": "2017-10-20T22:14:18.673", "Title": "Meaning of operator()?", "AcceptedAnswerId": "5557436", "LastEditDate": "2017-10-20T22:14:18.673", "Id": "5557392", "Score": "2", "Body": "<p>What is the meaning of operator() in C++? I see that is often used for \"functors,\" or function objects such as comparators. But then how are such functions called? Is it useful in other situations? And how many parameters can I declare for such an operator? E.g., is the following acceptable?</p>\n<pre><code>bool operator() (Foo f, Baz b, Quz q, Oik o) {...}\n</code></pre>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "250096", "AnswerCount": "5"}, "5557414": {"ParentId": "5557392", "CommentCount": "2", "Body": "<p>It's just a normal function that gets called when you apply function-call syntax to a user-defined type.</p>\n<p>So it has all the restrictions and features of a regular member function. It can be a template, it can take as many parameters as you want, it needs a return type, it can be <code>const</code>, etc.</p>\n", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "5557414", "Score": "0", "CreationDate": "2011-04-05T19:31:31.830", "LastActivityDate": "2011-04-05T19:31:31.830"}, "5559047": {"ParentId": "5557392", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>One point which I didn't see mentioned, was that although in syntax its invocation looks very similar to that of a regular non-member (dare I say, C-style) function. One difference is that since a functor/function-object is an instance of a class/struct, it can have an associated state.</p>\n<p>For non-member functions this could usually mean, either static locals(often times not the best or most useful way to maintain state) or globals(often undesirable). Whereas functors/function objects tie in nicely with C++'s notions on encapsulation where in the state/data is closely tied to the functions that operate on it.</p>\n<p>An instructive example of this is:</p>\n<pre><code>//Declaration\nstruct instructive_example\n{\n  instructive_example()\n: _invocation_count(0) {};\n\n  uint get_invocation_count() const\n  { return _invocation_count; }\n\n  void operator()()\n  {\n    //Do something\n\n    //And/or operate on the state associated with this function object\n    //In this case it is a simple increment of _invocation_count\n    ++_invocation_count;\n  }\nprivate:\n  uint _invocation_count;\n};\n\n//Instantiation &amp; invocation:\ninstructive_example eg;\n\neg();\n</code></pre>\n", "OwnerUserId": "391113", "LastEditorUserId": "391113", "LastEditDate": "2013-02-16T22:48:38.090", "Id": "5559047", "Score": "3", "CreationDate": "2011-04-05T21:57:15.690", "LastActivityDate": "2013-02-16T22:48:38.090"}, "bq_ids": {"n4140": {"so_5557392_5557436_0": {"section_id": 578, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_5557392_5557436_0": {"section_id": 568, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_5557392_5557436_0": {"section_id": 601, "quality": 0.9642857142857143, "length": 27}}}, "5557436": {"ParentId": "5557392", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Let's say you have a function object class, <code>Func</code>, with <code>operator()</code> defined. If you have an instance of that class, you can simply place parentheses after the expression referring to that instance:</p>\n<pre><code>Func myFunc;\nmyFunc(); // Calls the operator() member function\n</code></pre>\n<p>As an example from the standard library, we can look at <code>std::less</code> which is a binary function object:</p>\n<pre><code>std::less&lt;int&gt; myLess; // Create an instance of the function object\nstd::cout &lt;&lt; myLess(5, 6) &lt;&lt; std::endl; // Is 5 less than 6?\n</code></pre>\n<p>Another common use for <code>operator()</code> is when creating a Matrix class. You may define <code>T&amp; Matrix::operator()(int,int)</code> to retrieve an element from the matrix like <code>myMatrix(1,2)</code>.</p>\n<p>The number of parameters that <code>operator()</code> can take is the same as any other function. This is implementation-defined though. The recommended <em>minimum</em> number of arguments that your implementation should allow is 256 (given in Annex B of the standard).</p>\n<hr>\n<p><code>operator()</code>'s lookup is defined in the standard (ISO/IEC 14882:2003 \u00a713.3.1.1.2) by:</p>\n<blockquote>\n<p id=\"so_5557392_5557436_0\">If the <em>primary-expression</em> <code>E</code> in the function call syntax evaluates to a class object of type \"<code>cv T</code>\", then the set of candidate functions includes at least the function call operators of <code>T</code>. The function call operators of <code>T</code> are obtained by ordinary lookup of the name <code>operator()</code> in the context of <code>(E).operator()</code>.</p>\n</blockquote>\n<p>Translation: If you make a function call using the syntax <code>expression()</code> and the expression before the parentheses evaluates to an instance of a class, then add the objects <code>operator()</code> member function to the list of candidate functions that may be called.</p>\n</hr>", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2011-04-05T20:27:25.580", "Id": "5557436", "Score": "4", "CreationDate": "2011-04-05T19:33:02.533", "LastActivityDate": "2011-04-05T20:27:25.580"}});