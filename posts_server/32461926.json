post_cb({"bq_ids": {"n4140": {"so_32461926_32462236_1": {"length": 17, "quality": 0.85, "section_id": 718}, "so_32461926_32462236_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 717}}, "n3337": {"so_32461926_32462236_1": {"length": 16, "quality": 0.8, "section_id": 707}, "so_32461926_32462236_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 706}}, "n4659": {"so_32461926_32462236_1": {"length": 17, "quality": 0.85, "section_id": 749}, "so_32461926_32462236_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 748}}}, "32462236": {"Id": "32462236", "PostTypeId": "2", "Body": "<p>First, it's important to note that you <a href=\"https://stackoverflow.com/questions/13193484/how-to-declare-a-vector-of-atomic-in-c\">can't have a vector of atomic ints</a> without some shenanigans.</p>\n<p>Ignoring that, according to [container.requirements.dataraces] if you only access the vector to modify its content, then this seems to be thread-safe.</p>\n<blockquote>\n<p id=\"so_32461926_32462236_0\">For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be\n  const: begin, end, rbegin, rend, front, back, data, find, lower_bound, upper_bound, equal_range, at\n  and, except in associative or unordered associative containers, operator[].</p>\n<p id=\"so_32461926_32462236_1\">Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the con-\n  tained object in different elements in the same container, excepting vector&lt;bool&gt;, are modified concurrently.</p>\n</blockquote>\n<p>The wording isn't extremely clear on whether <code>operator[]</code> could possibly be non thread-safe in this case, but in practice no reasonable implementation should violate this. </p>\n<p>If you want more guarantees, and since the vector doesn't change size, you could replace the <code>vector&lt;T&gt;</code> with a <code>unique_ptr&lt;T[]&gt;</code>, which is trivially thread-safe in this case.<br>\nAdditionally, you should use a memory order that guarantees safe synchronization and ordering (unless you have a very good reason), instead of <code>memory_order_relaxed</code>. Not specifying a memory order at all, or using a <code>memory_order_acquire</code>/<code>memory_order_release</code> pair does this.<br>\nThis results in the following very similar code:</br></br></p>\n<pre><code>class MyList\n{\n    std::unique_ptr&lt; std::atomic_int[] &gt; collection_;\n\n    static MyList myList_;\n\npublic:\n\n    MyList() : collection_( new atomic_int[MAX_SIZE] ) {}\n\n    static MyList&amp; getMyList() { return myList_; }\n\n    void set( size_t idx, int val )\n    {\n        collection_[idx].store( val, std::memory_order_release );\n    }\n\n    int get( size_t idx ) const\n    {\n        return collection_[idx].load( std::memory_order_acquire );\n    }\n};\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-08T21:52:24.230", "Score": "3", "CreationDate": "2015-09-08T15:54:42.807", "ParentId": "32461926", "CommentCount": "6", "LastEditDate": "2017-05-23T11:44:43.653", "OwnerUserId": "1401962"}, "32461926": {"ViewCount": "172", "Body": "<p>I have the following class wrapping a vector of atomic ints ( <code>std::vector&lt; std::atomic_int &gt;</code> )</p>\n<p>The vector is sized correctly at object construction and doesn't change size. There are the usual accessors and mutators for getting, setting the atomic ints, but no guards / mutex.</p>\n<pre><code>class MyList\n{\n    std::vector&lt; std::atomic_int &gt; collection_;\n\n    static MyList myList_;\n\npublic:\n\n    MyList() : collection_( MAX_SIZE, 0 ) {}\n\n    static MyList&amp; getMyList() { return myList_; }\n\n    void set( size_t idx, int val )\n    {\n        collection_[idx].store( val, std::memory_order_relaxed );\n    }\n\n    int get( size_t idx ) const\n    {\n        return collection_[idx].load( std::memory_order_relaxed );\n    }\n};\n</code></pre>\n<p>I'm minded to suspect that this might not be thread-safe (it is currently running in a single-threaded model without problem), but would appreciate any views. My main concern is with the thread-safety of the unguarded collection, I suppose, rather than the elements of it.</p>\n", "AcceptedAnswerId": "32462236", "Title": "Threadsafety of atomic int collection", "CreationDate": "2015-09-08T15:40:11.563", "Id": "32461926", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-09-08T21:52:24.230", "Score": "1", "OwnerUserId": "258009", "Tags": "<c++><multithreading><c++11><stdatomic>", "AnswerCount": "1"}});