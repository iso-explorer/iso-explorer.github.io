post_cb({"47473986": {"CommentCount": "6", "ViewCount": "162", "LastActivityDate": "2017-11-24T17:48:11.570", "Body": "<p>Consider the following code:</p>\n<pre><code>template &lt;class&gt;\nstruct Foo_s {\n    using type = void();\n};\n\ntemplate &lt;class&gt;\nusing Foo_u = void();\n\ntemplate &lt;class T&gt;\nstruct Bar {\n             Foo_u&lt;void&gt;       foo1; // OK\n    typename Foo_s&lt;void&gt;::type foo2; // OK\n             Foo_u&lt;T&gt;          foo3; // OK\n    typename Foo_s&lt;T&gt;::type    foo4; // Boom.\n};\n\ntemplate struct Bar&lt;void&gt;;\n</code></pre>\n<p>The declaration of <code>foo4</code> fails on GCC 7.2, Clang 5.0.0 and MSVC 19.10.25017.</p>\n<p>GCC:</p>\n<pre><code>&lt;source&gt;: In instantiation of 'struct Bar&lt;void&gt;':\n18 : &lt;source&gt;:18:17:   required from here\n15 : &lt;source&gt;:15:29: error: field 'Bar&lt;void&gt;::foo4' invalidly declared function type\n     typename Foo_s&lt;T&gt;::type foo4;\n                             ^~~~\n</code></pre>\n<p>Clang:</p>\n<pre><code>15 : &lt;source&gt;:15:29: error: data member instantiated with function type 'typename Foo_s&lt;void&gt;::type' (aka 'void ()')\n    typename Foo_s&lt;T&gt;::type foo4;\n                            ^\n18 : &lt;source&gt;:18:17: note: in instantiation of template class 'Bar&lt;void&gt;' requested here\ntemplate struct Bar&lt;void&gt;;\n                ^\n</code></pre>\n<p>MSVC:</p>\n<pre><code>15 : &lt;source&gt;(15): error C2207: 'Bar&lt;T&gt;::foo4': a member of a class template cannot acquire a function type\n18 : &lt;source&gt;(18): note: see reference to class template instantiation 'Bar&lt;void&gt;' being compiled\n</code></pre>\n<p>All of them seem to think that I am trying to declare a data member with a function type. As you can see, this only happens when the type is nested (not a <code>using</code> template), and is dependent on the parameter of the class. This looks like a bug, but the fact that for once all of these three compilers agree has me doubting.</p>\n<p>Is this standard behaviour? If so, is there a rationale behind disallowing this, and is there a way to declare a member function whose type is computed with a metaprogram?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "47478004", "FavoriteCount": "2", "Title": "Declaring a member function with a typedef coming from a metafunction", "Id": "47473986", "Score": "6", "CreationDate": "2017-11-24T13:06:15.010", "Tags": "<c++><language-lawyer><c++1z>", "OwnerUserId": "3233393", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47473986_47478004_1": {"section_id": 3246, "quality": 1.0, "length": 9}, "so_47473986_47478004_2": {"section_id": 166, "quality": 1.0, "length": 17}, "so_47473986_47478004_0": {"section_id": 86, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_47473986_47478004_1": {"section_id": 3119, "quality": 1.0, "length": 9}, "so_47473986_47478004_2": {"section_id": 160, "quality": 1.0, "length": 17}, "so_47473986_47478004_0": {"section_id": 81, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_47473986_47478004_1": {"section_id": 4004, "quality": 1.0, "length": 9}, "so_47473986_47478004_2": {"section_id": 170, "quality": 1.0, "length": 17}, "so_47473986_47478004_0": {"section_id": 241, "quality": 1.0, "length": 15}}}, "47478004": {"ParentId": "47473986", "LastEditDate": "2017-11-24T17:48:11.570", "CommentCount": "0", "CreationDate": "2017-11-24T17:42:01.603", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "47478004", "Score": "4", "Body": "<p><a href=\"https://timsong-cpp.github.io/cppwp/temp#spec-8\" rel=\"nofollow noreferrer\">[temp.spec]/8</a>:</p>\n<blockquote>\n<p id=\"so_47473986_47478004_0\">If a function declaration acquired its function type through a dependent type without using the syntactic form of a function declarator, the program is ill-formed.</p>\n</blockquote>\n<p>This makes your last line decidedly ill-formed. Which makes sense, since, as in other cases of dependent constructs, we don't want the meaning of a phrase to depend too strongly on template arguments.</p>\n<p>However, <a href=\"http://eel.is/c++draft/dcl.decl#dcl.fct-13\" rel=\"nofollow noreferrer\">[dcl.fct]/13</a>:</p>\n<blockquote>\n<p id=\"so_47473986_47478004_1\">A typedef of function type may be used to declare a function but shall\n  not be used to define a function.</p>\n</blockquote>\n<p>This makes your first three lines well-formed---the first two directly, and for the third one, note that </p>\n<blockquote>\n<p id=\"so_47473986_47478004_2\">When a <em>template-id</em> refers to the specialization of an alias template,\n  it is equivalent to the associated type obtained by substitution of\n  its <em>template-argument</em>s for the <em>template-parameter</em>s in the <em>type-id</em> of\n  the alias template.</p>\n</blockquote>\n<p>by <a href=\"https://timsong-cpp.github.io/cppwp/temp.alias#2\" rel=\"nofollow noreferrer\">[temp.alias]</a>.</p>\n", "LastActivityDate": "2017-11-24T17:48:11.570"}});