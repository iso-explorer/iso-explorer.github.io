post_cb({"13014192": {"CommentCount": "4", "ViewCount": "723", "PostTypeId": "1", "LastEditorUserId": "882932", "CreationDate": "2012-10-22T15:02:31.613", "LastActivityDate": "2012-10-22T15:33:48.213", "Title": "std::ifstream::read or std::ofstream::write with a zero parameter?", "AcceptedAnswerId": "13014542", "LastEditDate": "2012-10-22T15:14:28.113", "Id": "13014192", "Score": "6", "Body": "<p>Is it perfectly ok (= well defined behaviour according to the standard) to call :</p>\n<pre><code>mystream.read(buffer, 0);\n</code></pre>\n<p>or</p>\n<pre><code>mystream.write(buffer, 0);\n</code></pre>\n<p>(and of course nothing will be read or written). \nI would like to know if I have to test if the provided size is null before calling one of these two functions.</p>\n", "Tags": "<c++><file><stream><zero><standards-compliance>", "OwnerUserId": "882932", "AnswerCount": "2"}, "13014761": {"ParentId": "13014192", "CommentCount": "0", "Body": "<p>Another extraction from <code>27.7.2.3 Unformatted input functions/1</code> gives us a clue that zero-size input buffers are valid case:</p>\n<blockquote>\n<p id=\"so_13014192_13014761_0\">unformatted input functions taking a character array of <strong>non-zero size</strong> as an argument shall also store a null character (using charT()) in the first location of the array.</p>\n</blockquote>\n", "OwnerUserId": "1599260", "PostTypeId": "2", "Id": "13014761", "Score": "0", "CreationDate": "2012-10-22T15:33:48.213", "LastActivityDate": "2012-10-22T15:33:48.213"}, "bq_ids": {"n4140": {"so_13014192_13014542_2": {"section_id": 2312, "quality": 1.0, "length": 6}, "so_13014192_13014542_0": {"section_id": 2237, "quality": 1.0, "length": 7}, "so_13014192_13014761_0": {"section_id": 2208, "quality": 1.0, "length": 18}}, "n3337": {"so_13014192_13014542_2": {"section_id": 2300, "quality": 1.0, "length": 6}, "so_13014192_13014542_0": {"section_id": 2225, "quality": 1.0, "length": 7}, "so_13014192_13014761_0": {"section_id": 2196, "quality": 1.0, "length": 18}}, "n4659": {"so_13014192_13014761_0": {"section_id": 2481, "quality": 1.0, "length": 18}, "so_13014192_13014542_0": {"section_id": 2510, "quality": 1.0, "length": 7}, "so_13014192_13014542_2": {"section_id": 2586, "quality": 1.0, "length": 6}}}, "13014542": {"ParentId": "13014192", "LastEditDate": "2012-10-22T15:28:25.670", "CommentCount": "0", "CreationDate": "2012-10-22T15:21:25.753", "OwnerUserId": "273767", "LastEditorUserId": "273767", "PostTypeId": "2", "Id": "13014542", "Score": "8", "Body": "<p>Yes, the behavior is well-defined: both functions will go through the motions for unformatted input/output functions (constructing the sentry, setting failbit if eofbit is set, flushing the tied stream if necessary), and then they will get to this clause:</p>\n<p>\u00a727.7.2.3[istream.unformatted]/30</p>\n<blockquote>\n<p id=\"so_13014192_13014542_0\">Characters are extracted and stored until either of the following occurs:</p>\n<p id=\"so_13014192_13014542_1\">\u2014 n characters are stored;</p>\n</blockquote>\n<p>\u00a727.7.3.7[ostream.unformatted]/5</p>\n<blockquote>\n<p id=\"so_13014192_13014542_2\">Characters are inserted until either of the following occurs</p>\n<p id=\"so_13014192_13014542_3\">\u2014 n characters are inserted;</p>\n</blockquote>\n<p>\"zero characters are stored/inserted\" is true before anything is stored or extracted. </p>\n<p>Looking at actual implementations, I see <code>for (; gcount &lt; n; ++gcount)</code> <a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/include/istream\" rel=\"noreferrer\">in libc++</a> or <code>sgetn(buffer, n);</code> <a href=\"http://gcc.gnu.org/viewcvs/trunk/libstdc++-v3/include/bits/istream.tcc?view=markup\" rel=\"noreferrer\">in stdlibc++</a> which has the <a href=\"http://gcc.gnu.org/viewcvs/trunk/libstdc++-v3/include/bits/streambuf.tcc?view=markup\" rel=\"noreferrer\">equivalent loop</a> </p>\n", "LastActivityDate": "2012-10-22T15:28:25.670"}});