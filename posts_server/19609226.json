post_cb({"19609226": {"ViewCount": "556", "Body": "<p>Whenever we create an object from a class, it is created on the heap occupying more space as compared to a a struct variable which occupies its memory on stack. If i create a class of Person and a struct P, having same attributes, then it should justify what I just said. Please examine the following 2 fragments of code:   </p>\n<pre><code>#include &lt;iostream.h&gt;\n#include &lt;conio.h&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass Person{\n\n      int age;\n      string hair_color;\n      float height;\n\n      public:\n      Person::Person(int n)\n      {\n       age = n;\n      }\n\n      int Person::getAge()\n      {\n        return age;    \n      }\n\n\n\n      };\n\nstruct P{\n\n       int age;\n\n\n       };      \n\nmain()\n{\n\n     Person person(45);\n\n     //Person *person = new Person(45);\n\n\n     P myPerson;\n\n     cout&lt;&lt;sizeof(person)&lt;&lt;endl;\n     cout&lt;&lt;sizeof(myPerson)&lt;&lt;endl;\n\n     //cout&lt;&lt;\"Age: \"&lt;&lt;person-&gt;getAge(); \n    getch();  \n}\n</code></pre>\n<p>And when i write this code:</p>\n<pre><code>#include &lt;iostream.h&gt;\n#include &lt;conio.h&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass Person{\n\n      int age;\n      string hair_color;\n      float height;\n\n      public:\n      Person::Person(int n)\n      {\n       age = n;\n      }\n\n      int Person::getAge()\n      {\n        return age;    \n      }\n\n\n\n      };\n\nstruct P{\n\n       int age;\n\n\n       };      \n\nmain()\n{\n\n    // Person person(45);\n\n     Person *person = new Person(45);\n\n\n     P myPerson;\n\n     cout&lt;&lt;sizeof(person)&lt;&lt;endl;\n     cout&lt;&lt;sizeof(myPerson)&lt;&lt;endl;\n\n\n    getch();  \n}\n</code></pre>\n<p>Please correct me if I am wrong here about objects and refernces. I want to know from my code what occupies more space: Object or Struct?</p>\n", "AcceptedAnswerId": "19609262", "Title": "What occupies more space: Object or Struct?", "CreationDate": "2013-10-26T16:46:23.757", "Id": "19609226", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-10-26T18:41:48.543", "Score": "-3", "OwnerUserId": "2355649", "Tags": "<c++><c><oop>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_19609226_19610062_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 6679}}, "n3337": {"so_19609226_19610062_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 6434}}, "n4659": {"so_19609226_19610062_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 8154}, "so_19609226_19610062_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6103}}}, "19610062": {"Id": "19610062", "PostTypeId": "2", "Body": "<p>Please keep in mind that in C++ a struct and a class are not different kinds of things. They are the <em>same thing</em>, with a <code>struct</code> being <strong>syntactic sugar</strong> for creating a <code>class</code> with public members and methods, and defaulting to public inheritance.</p>\n<p>Specifically:</p>\n<p>Section 10.2.8 of the book \"The C++ Programming Language\", Bjarne Stroustrup states:</p>\n<blockquote>\n<p id=\"so_19609226_19610062_0\">By definition a struct is a class in which members are public by\n  default; that is</p>\n<pre><code>struct s { ...  \n</code></pre>\n<p id=\"so_19609226_19610062_1\">is simply shorthand for</p>\n<pre><code>class s { public:...\n</code></pre>\n</blockquote>\n<p>And the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow\">C++ Standard</a> states (Section 11.2, Item 2):</p>\n<blockquote>\n<p id=\"so_19609226_19610062_2\">In the absence of an access-speci\ufb01er for a base class, <code>public</code> is\n  assumed when the derived class is declared <code>struct</code> and <code>private</code> is\n  assumed when the class is declared <code>class</code>.</p>\n</blockquote>\n", "LastEditorUserId": "104427", "LastActivityDate": "2013-10-26T18:41:48.543", "Score": "1", "CreationDate": "2013-10-26T18:03:18.870", "ParentId": "19609226", "CommentCount": "2", "LastEditDate": "2013-10-26T18:41:48.543", "OwnerUserId": "104427"}, "19609262": {"Id": "19609262", "PostTypeId": "2", "Body": "<p>In some languages (C#), <code>struct</code> is used to define types that can be stack-allocated, while <code>class</code> instances have to be allocated on the heap.</p>\n<p>In <code>C++</code>, there is no such difference and it is up to the instantiator to determine whether to allocate the object on the heap or the stack. For example</p>\n<pre><code>Person* person = new Person(45);\n</code></pre>\n<p>allocates the <code>Person</code> instance on the heap, while</p>\n<pre><code>Person person(45);\n</code></pre>\n<p>allocates a similar instance on the stack.</p>\n<p>Additionally, there is nothing in general to support the statement \"created on the heap occupying more space as compared to a a struct variable which occupies its memory on stack\". It is often true that heap allocation comes with some overhead (memory-wise and in processing time), but stack space is often much more limited (usually a fixed stack size per thread).</p>\n<p>There are lots of documentation on when to use what, and even <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap\">dicussions here on SO</a>. In short, the stack is to be used for small, short-lived objects (temporary objects within the scope of a function or similar).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-26T16:56:20.117", "Score": "5", "CreationDate": "2013-10-26T16:50:00.557", "ParentId": "19609226", "CommentCount": "3", "LastEditDate": "2017-05-23T10:27:33.513", "OwnerUserId": "292477"}, "19610430": {"Id": "19610430", "PostTypeId": "2", "Body": "<p>In addition to the other answers, a <code>struct</code> and <code>class</code> are stencils telling the compiler <em>how</em> something is organized.  A <code>struct</code> and <code>class</code> do not take up any room in the executable since they are only used during compilation.  </p>\n<p>An object is commonly referred to as an <em>instance</em> of a <code>class</code> or <code>struct</code>.  The object occupies memory.  The amount of memory occupied depends of the definition of the <code>struct</code> or <code>class</code> that it was instantiated from.  </p>\n<p>So in answering the title of your question, <code>Which occupies more space: Object or Struct?</code>, the object does since a <code>struct</code> is only a stencil and the object is the instantiation. </p>\n", "LastActivityDate": "2013-10-26T18:38:06.387", "Score": "1", "CreationDate": "2013-10-26T18:38:06.387", "ParentId": "19609226", "CommentCount": "1", "OwnerUserId": "225074"}, "19609325": {"Id": "19609325", "PostTypeId": "2", "Body": "<p>In C++, a <code>struct</code> and a <code>class</code> are exactly the same thing with regards to how they are allocated and how much space they occupy - the main difference is that the default for a <code>class</code> is that data is private, and you need to add <code>public:</code> for any group of members that you want to expose to the outside of the class, where a <code>struct</code> has public members by default, and if you want to have private members, you need to add <code>private:</code>. </p>\n<p>Whether something is allocated on the heap, the stack or in global memory is entirely up to how the code using the class/struct is written (e.g. call to <code>new</code> will allocate on the stack, not calling new will allocate either global space or on the stack) and it makes absolutely no difference if the object is a <code>struct</code> or a <code>class</code> - they take up the same size if they have the same content. </p>\n<p>It is OFTEN the convention that <code>struct</code> is used when the data in the structure is \"plain data\" and there is no constructor or member functions, where <code>class</code> is used when there are member functions and/or constructor involved. This is however a convention, and there is absolutely no TECHNICAL difference between:</p>\n<pre><code> struct Coord3D\n {\n    float x, y, z;\n };\n</code></pre>\n<p>and </p>\n<pre><code> class Coord3D\n {\n    public:\n      float x, y, z;\n };\n</code></pre>\n<p>or between </p>\n<pre><code>struct Person\n{\n  private:\n     int age; \n     std::string name;\n  public:\n     int getAge() { return age; }\n     std::string getName() { return name; }\n};\n</code></pre>\n<p>and</p>\n<pre><code>class Person\n{\n  // no need to have private:, but most people add it just to be perfectly clear\n     int age; \n     std::string name;\n  public:\n     int getAge() { return age; }\n     std::string getName() { return name; }\n};\n</code></pre>\n<p>(Compiling code that uses either of the two alternative forms, and it would be completely impossible to tell from the binary code generated whether it is the first or second for)</p>\n", "LastActivityDate": "2013-10-26T16:56:25.570", "Score": "5", "CreationDate": "2013-10-26T16:56:25.570", "ParentId": "19609226", "CommentCount": "0", "OwnerUserId": "1919155"}});