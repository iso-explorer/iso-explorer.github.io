post_cb({"22504862": {"ParentId": "22504496", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>your code has <strong>undefined behavior</strong></p>\n<p><strong>\u00a7 5.2.10 Reinterpret cast</strong></p>\n<blockquote>\n<p id=\"so_22504496_22504862_0\">7 Converting a prvalue of type \u201cpointer to T1\u201d to the\n  type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value. <strong>The result of any other such pointer conversion is unspecified.</strong></p>\n</blockquote>\n", "OwnerUserId": "951757", "LastEditorUserId": "2380830", "LastEditDate": "2014-03-19T11:55:45.797", "Id": "22504862", "Score": "8", "CreationDate": "2014-03-19T11:47:34.080", "LastActivityDate": "2014-03-19T11:55:45.797"}, "22504496": {"CommentCount": "6", "AcceptedAnswerId": "22504676", "CreationDate": "2014-03-19T11:32:18.977", "LastActivityDate": "2014-03-19T17:47:48.347", "PostTypeId": "1", "ViewCount": "1416", "FavoriteCount": "2", "Title": "C++ Will virtual functions still work if I upcast a derived object to its base type", "Id": "22504496", "Score": "12", "Body": "<p>Consider the following:</p>\n<ul>\n<li>B inherits from A and overrides the print function.</li>\n<li>A has a static function which takes a void*, casts it to A and calls the virtual print function.</li>\n<li><p>If the void* was originally a B will it call A::print or B::print?</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\npublic:\n        static void w(void *p) {\n\n                A *a = reinterpret_cast&lt;A*&gt;(p);\n                a-&gt;print();\n        }\n\n        virtual void print() {\n           std::cout &lt;&lt; \"A\"  &lt;&lt; std::endl;\n        }\n};\n\nclass B : public A {\n\npublic:\n        void print() {\n           std::cout &lt;&lt; \"B\"  &lt;&lt; std::endl;\n        }\n};\n\nint main () {\n        B b;\n        A::w(&amp;b);\n}\n</code></pre></li>\n</ul>\n<p>This prints B for me.</p>\n<p>It seems that the void* which has been casted to an A still knows about B's overridden print function. The reason why is not immediately clear.</p>\n<p>Can someone explain to me if this is behavior that I can rely on or if it is just some fluke that works because it is a small example (like how returning a reference to a local variable won't always segfault in small programs).</p>\n", "Tags": "<c++>", "OwnerUserId": "2675345", "AnswerCount": "4"}, "22514078": {"ParentId": "22504496", "CommentCount": "0", "Body": "<p>reinterpret_cast cannot work, if you consider how multiple inheritance is implemented in C++.</p>\n<p>Basically, when casting around between related types, with multiple inheritance, a cast might involve adding an offset. Hence without knowing the source and destination type, the compiler cannot emit the correct instructions.</p>\n<p>So, reinterpret casts are undoable for at least this usecase, hence they are defined as undefined.</p>\n<p>The dangerous part here, even if you do not do multiple inheritance, is that modern compilers start to interpret this \"undefined\" behaviour as meaning that they can optimize the thing, it's containing block and so on away. Which is almost certainly valid by the C++ standard (undefined means exactly that, anything is fine), but can be a surprise to the developer, who tended to understand \"undefined\" as \"the code output might not work in general\".</p>\n", "OwnerUserId": "3364423", "PostTypeId": "2", "Id": "22514078", "Score": "0", "CreationDate": "2014-03-19T17:47:48.347", "LastActivityDate": "2014-03-19T17:47:48.347"}, "22504676": {"ParentId": "22504496", "CommentCount": "2", "Body": "<p>Virtual functions are usually resolved by an implicit <code>vtable</code>. This is basically an array of function pointers for every virtual function in the class hierarchy. The compiler adds it as a \"hidden member\" to your class. When calling a virtual function, the corresponding entry in the vtable is called.</p>\n<p>Now, when you create a class of type <code>B</code>, it implicitly has the B-vtable stored in the object. Casts do not affect this table.</p>\n<p>Hence, when you cast your <code>void *</code> to <code>A</code>, the original vtable (of class <code>B</code>) is present, which points to <code>B::print</code>.</p>\n<p>Note that this is implementation defined behaviour, and the standard does not guarantee anything about this. But most compilers will act like this</p>\n", "OwnerUserId": "345027", "PostTypeId": "2", "Id": "22504676", "Score": "5", "CreationDate": "2014-03-19T11:40:17.433", "LastActivityDate": "2014-03-19T11:40:17.433"}, "22507780": {"ParentId": "22504496", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>First of all your <code>reinterpret_cast</code> is undefined.\nIf you pass a <code>A*</code> to <code>w</code> it will be defined.</p>\n<pre><code>A * p = new B;\nA::w(p);\ndelete p;\n</code></pre>\n<p>I suggest to use <code>static_cast&lt;A*&gt;(p)</code> instead, if <code>w</code> is always called using <code>A*</code>.</p>\n<p>If you have a defined cast to <code>void*</code> and back the memory address stays constant.\nSo <code>a</code> inside your <code>w</code> will be a valid <code>A*</code> if you pass a valid <code>A*</code> to <code>w</code> first.</p>\n<p>The question why the program knows how to handle the call is related to a mechanic called \"Virtual Table\".</p>\n<p><em>Note: This may be different for different compilers. I'll talk about how Visual Studio seems to handle it.</em></p>\n<p>To give you a somewhat rough idea for simple inheritance:</p>\n<p>The compiler will compile 2 <code>print</code> functions in your code: \n<code>A::print</code> (<strong>i.e. at address <code>X</code></strong>) and <code>B::print</code> (<strong>i.e. at address <code>Y</code></strong>). </p>\n<p>The <em>real</em> memory footprint of a class containing virtual function (i.e.</p>\n<pre><code>struct A\n{\n  void print (void);\n  size_t x;\n};\nstruct B : A\n{\n  void print (void);\n  size_t y;\n};\n</code></pre>\n<p>) will be somewhat like</p>\n<pre><code>struct Real_A\n{\n  void * vtable;\n  size_t x;\n};\nstruct Real_B : Real_A\n{\n  size_t y;\n};\n</code></pre>\n<p>Furthermore there will be two so called virtual tables, one for each class containing virtual functions or having a base class with virtual functions.</p>\n<p>You can think of the vtable as a structure holding the \"real\" address for each function.</p>\n<p>Upon compilation the compiler will create Vtables for each class (<code>A</code> and <code>B</code>):\nEach instance of A will have <code>vtable = &lt;Address of A Vtable&gt;</code> while each instance of <code>B</code> will have <code>vtable = &lt;Address of B Vtable&gt;</code>.</p>\n<p>At runtime if a virtual function is called the program will look up the \"real\" address for the function from the Vtable which is stored at the address which is first element to each object of <code>A</code> or <code>B</code></p>\n<p><strong>The following code is non-standard and not sane</strong>\n... but it may give you an idea though...</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A \n{\n  virtual void print (void) { std::cout &lt;&lt; \"A called.\" &lt;&lt; std::endl; }\n  size_t x;\n};\n\nstruct B : A \n{\n  void print (void) { std::cout &lt;&lt; \"B called.\" &lt;&lt; std::endl; }\n};\n// \"Real\" memory layout of A\nstruct Real_A\n{\n  void * vtable;\n  size_t x_value;\n};\n// \"Real\" memory layout of B\nstruct Real_B : Real_A\n{\n  size_t y_value;\n};\n// \"Pseudo virtual table structure for classes with 1 virtual function\"\nstruct VT\n{\n  void * func_addr;\n};\n\nint main (void) \n{\n  A * pa = new A;\n  pa-&gt;x = 15;\n  B * pb = new B;\n  pb-&gt;x = 20;\n  A * pa_b = new B;\n  pa_b-&gt;x = 25;\n  // reinterpret addrress of A and B objects as Real_A and Real_B\n  Real_A&amp; ra(*(Real_A*)pa);\n  Real_B&amp; rb(*(Real_B*)pb);\n  // reinterpret addrress of B object through pointer to A as Real_B\n  Real_B&amp; rb_a(*(Real_B*)pa_b);\n  // Print x_values to know whether we meet the class layout\n  std::cout &lt;&lt; \"Value of ra.x_value = \" &lt;&lt; ra.x_value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Value of rb.x_value = \" &lt;&lt; rb.x_value &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Value of rb.x_value = \" &lt;&lt; rb_a.x_value &lt;&lt; std::endl;\n  // Print vtable addresses\n  std::cout &lt;&lt; \"VT of A through A*: \" &lt;&lt; ra.vtable &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"VT of B through B*: \" &lt;&lt; rb.vtable &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"VT of B through A*: \" &lt;&lt; rb_a.vtable &lt;&lt; std::endl;\n  // Reinterpret memory pointed to by the vtable address as VT objects\n  VT&amp; va(*(VT*)ra.vtable);\n  VT&amp; vb(*(VT*)rb.vtable);\n  VT&amp; vb_a(*(VT*)rb_a.vtable);\n  // Print addresses of functions in the vtable\n  std::cout &lt;&lt; \"FA of A through A*: \" &lt;&lt; va.func_addr &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"FA of B through B*: \" &lt;&lt; vb.func_addr &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"FA of B through A*: \" &lt;&lt; vb_a.func_addr &lt;&lt; std::endl;\n\n  delete pa;\n  delete pb;\n  delete pa_b;\n\n  return 0;\n}\n</code></pre>\n<p>Visual Studio 2013 output:</p>\n<pre> Value of ra.x_value = 15\nValue of rb.x_value = 20\nValue of rb.x_value = 25\nVT of A through A*: 00D9DC80\nVT of B through B*: 00D9DCA0\nVT of B through A*: 00D9DCA0\nFA of A through A*: 00D914B0\nFA of B through B*: 00D914AB\nFA of B through A*: 00D914AB</pre>\n<p>gcc-4.8.1 output:</p>\n<pre>Value of ra.x_value = 15\nValue of rb.x_value = 20\nValue of rb.x_value = 25\nVT of A through A*: 0x8048f38\nVT of B through B*: 0x8048f48\nVT of B through A*: 0x8048f48\nFA of A through A*: 0x8048d40\nFA of B through B*: 0x8048cc0\nFA of B through A*: 0x8048cc0</pre>\n<p><a href=\"https://ideone.com/iKyBB3\" rel=\"nofollow\">https://ideone.com/iKyBB3</a></p>\n<p>Note: No matter whether you access a B object through <code>A*</code> or <code>B*</code>, you'll find the same vtable address first and you'll find the same address contained in the vtable as well.</p>\n", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2014-03-19T13:48:52.627", "Id": "22507780", "Score": "2", "CreationDate": "2014-03-19T13:42:05.323", "LastActivityDate": "2014-03-19T13:48:52.627"}, "bq_ids": {"n4140": {"so_22504496_22504862_0": {"section_id": 6046, "quality": 0.7666666666666667, "length": 23}}, "n3337": {"so_22504496_22504862_0": {"section_id": 5814, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_22504496_22504862_0": {"section_id": 7545, "quality": 0.7666666666666667, "length": 23}}}});