post_cb({"1622698": {"ParentId": "1622694", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The pattern you use is widely known as the \"<a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow noreferrer\">Curiously Recurring Template Pattern</a>\". so, yes, you can do that.<br>\nI can't think of a reason why it does not compile.</br></p>\n", "OwnerUserId": "157274", "LastEditorUserId": "157274", "LastEditDate": "2009-10-26T01:26:26.007", "Id": "1622698", "Score": "2", "CreationDate": "2009-10-26T01:15:08.837", "LastActivityDate": "2009-10-26T01:26:26.007"}, "1625024": {"ParentId": "1622694", "CommentCount": "0", "Body": "<p>litb found the solution on ##c++ last night.</p>\n<p>The issue was I was passing a NoopCommand to a function like this:</p>\n<pre><code>void SendCommand(Command&lt;T&gt; command);\n</code></pre>\n<p>When I should have made the signature this:</p>\n<pre><code>void SendCommand(Command&lt;T&gt;&amp; command);\n</code></pre>\n<p>Making that change allows everything to compile.</p>\n", "OwnerUserId": "135655", "PostTypeId": "2", "Id": "1625024", "Score": "-1", "CreationDate": "2009-10-26T14:10:39.150", "LastActivityDate": "2009-10-26T14:10:39.150"}, "1622694": {"CommentCount": "4", "AcceptedAnswerId": "1625024", "PostTypeId": "1", "LastEditorUserId": "135655", "CreationDate": "2009-10-26T01:11:19.157", "LastActivityDate": "2010-02-27T02:22:42.680", "LastEditDate": "2009-10-26T14:11:00.587", "ViewCount": "5191", "FavoriteCount": "1", "Title": "Is it possible to have a non-template class subclass a template class?", "Id": "1622694", "Score": "2", "Body": "<p>I have a template class defined like so:</p>\n<pre><code>template &lt;class T&gt;\nclass Command {\npublic:\n    virtual T HandleSuccess(std::string response) = 0;\n    virtual std::string FullCommand() const = 0;\n    // ... other methods here ...\n};\n</code></pre>\n<p>Will C++ allow me to create a non-template subclass of a template class? What I mean is can I do something like this:</p>\n<pre><code>class NoopCommand : public Command&lt;NoopResult&gt; {\npublic:\n    NoopResult HandleSuccess(std::string response);\n    std::string FullCommand() const;\n    // ... other methods here ...\n};\n</code></pre>\n<p>As is that is not working for me because it says the following virtual functions are undefined:</p>\n<pre><code>T admix::Command&lt;T&gt;::HandleSuccess(std::string) [with T = admix::NoopResult]\nstd::string admix::Command&lt;T&gt;::FullCommand() const [with T = admix::NoopResult]\n</code></pre>\n<p>How can I specifically define them for the given T?</p>\n", "Tags": "<c++><templates><subclass>", "OwnerUserId": "135655", "AnswerCount": "5"}, "1622721": {"ParentId": "1622694", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>As we figured out in IRC, that was because you have </p>\n<ol>\n<li>Made your functions non-pure </li>\n<li>Sliced the derived object part. So the base class functions were called because the object wasn't a complete derived object anymore.</li>\n</ol>\n<p>(Below follows my suspicion on earlier versions of your question - i keep it for further consideration and to keep the comments meaningful)</p>\n<hr>\n<p><sub>\nI think the issue here is that the compiler is free to instantiate any virtual function member of a class template even if it's not used (i.e not called). Instantiating a function will need a function definition to be provided. Try to add this in the header, where the compiler will find them and instantiate a definition from:</sub></p>\n<pre><code>template&lt;typename T&gt;\nT Command&lt;T&gt;::HandleSuccess(std::string response) { /* put some default action ... */ }\n\ntemplate&lt;typename T&gt;\nstd::string Command&lt;T&gt;::FullCommand() const { /* put some default action ... */ }\n</code></pre>\n<p>C++ Standard <code>14.7.1/9</code>:</p>\n<blockquote>\n<p id=\"so_1622694_1622721_0\">An implementation shall not implicitly instantiate a function template, a member template, a non-virtual\n  member function, a member class or a static data member of a class template that does not require instantiation. It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated. \n  </p></blockquote></hr>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-02-27T02:22:42.680", "Id": "1622721", "Score": "4", "CreationDate": "2009-10-26T01:29:50.970", "LastActivityDate": "2010-02-27T02:22:42.680"}, "1622733": {"ParentId": "1622694", "CommentCount": "2", "Body": "<p>\"virtual functions are undefined\" means you have not defined the function bodies of NoopCommand::HandleSuccess and NoopCommand::FullCommand.</p>\n<p>The following should solve your problem.</p>\n<pre><code>class NoopCommand : public Command&lt;NoopResult&gt; {\npublic:\n    NoopResult HandleSuccess(std::string response) {}\n    std::string FullCommand() const {}\n    // ... other methods here ...\n};\n</code></pre>\n<p>Or you you have a NoopCommand.cpp, make sure it's included in your build process.</p>\n", "OwnerUserId": "83458", "PostTypeId": "2", "Id": "1622733", "Score": "3", "CreationDate": "2009-10-26T01:34:34.563", "LastActivityDate": "2009-10-26T01:34:34.563"}, "bq_ids": {"n4140": {"so_1622694_1622721_0": {"section_id": 243, "quality": 1.0, "length": 36}}, "n3337": {"so_1622694_1622721_0": {"section_id": 235, "quality": 1.0, "length": 36}}, "n4659": {"so_1622694_1622721_0": {"section_id": 250, "quality": 0.9444444444444444, "length": 34}}}, "1622717": {"ParentId": "1622694", "CommentCount": "2", "Body": "<p>The code you gave compiles for me, without errors (after adding a <code>struct NoopResult { };</code>). Maybe there's a problem in the code you left out?</p>\n", "OwnerUserId": "36723", "PostTypeId": "2", "Id": "1622717", "Score": "0", "CreationDate": "2009-10-26T01:28:45.060", "LastActivityDate": "2009-10-26T01:28:45.060"}});