post_cb({"bq_ids": {"n4140": {"so_28688522_28688663_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 6001}, "so_28688522_28688663_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 6000}}, "n3337": {"so_28688522_28688663_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5769}, "so_28688522_28688663_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 5768}}}, "28688663": {"PostTypeId": "2", "Body": "<p>It's an expression. [expr.type.conv]/p2-3:</p>\n<blockquote>\n<p id=\"so_28688522_28688663_0\">The expression <code>T()</code>, where <code>T</code> is a <em>simple-type-specifier</em> or\n  <em>typename-specifier</em> for a non-array complete object type or the\n  (possibly cv-qualified) <code>void</code> type, creates a prvalue of the\n  specified type, whose value is that produced by value-initializing\n  (8.5) an object of type <code>T</code>; no initialization is done for the\n  <code>void()</code> case. [<em>Note</em>: ... - <em>end note</em>]</p>\n<p id=\"so_28688522_28688663_1\">Similarly, a <em>simple-type-specifier</em> or <em>typename-specifier</em> followed by a\n  <em>braced-init-list</em> creates a temporary object of the specified type\n  <em>direct-list-initialized</em> (8.5.4) with the specified <em>braced-init-list</em>,\n  and its value is that temporary object as a prvalue.</p>\n</blockquote>\n<p>You can't create a temporary object of type <code>void</code>. <code>void()</code> is a special exception that allows you to make a <code>void</code> prvalue.</p>\n", "LastActivityDate": "2015-02-24T05:20:48.477", "Id": "28688663", "CommentCount": "3", "CreationDate": "2015-02-24T05:20:48.477", "ParentId": "28688522", "Score": "8", "OwnerUserId": "2756719"}, "28688522": {"ViewCount": "249", "Body": "<p>I have recently seen some SFINAE-based code that looks like this:</p>\n<pre><code>template &lt;typename T&gt;\nauto test(T &amp;myclass) -&gt; decltype(myclass.f(), void()) \n{\n    // do something here, don't return anything (void)\n}\n</code></pre>\n<p>Basically the function above uses SFINAE to reject all parameters of type <code>T</code> that don't have <code>f()</code> as a member function. The SFINAE takes place in the <code>decltype</code>, where we have 2 expressions separated by the comma operator. If the first expression cannot be evaluated, SFINAE kicks in and rejects the overload. If the expression can be evaluated, then, because of the comma operator, <code>void</code> is being returned from the function.</p>\n<p>As far as I understand, <code>void()</code> \"constructs\" a <code>void</code> object in an un-evaluated context (yes, this is legal), which is then picked by the <code>decltype</code> so <code>void</code> is the return type of the function. </p>\n<p>My question is: <strong>why cannot we use <code>void{}</code> instead?</strong> Doesn't it have the same effect of \"constructing\" a <code>void</code> object in an un-evaluated context? My compiler(s) (g++/clang++) don't accept the <code>void{}</code> code</p>\n<blockquote>\n<p id=\"so_28688522_28688522_0\"><code>error: compound literal of non-object type 'void'</code> (g++4.9/g++5)</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_28688522_28688522_1\"><code>error: illegal initializer type 'void'</code> (clang++ 3.5)</p>\n</blockquote>\n", "AcceptedAnswerId": "28688663", "Title": "Why cannot we use brace initializer in an un-evaluated context?", "CreationDate": "2015-02-24T05:06:58.643", "Id": "28688522", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-02-24T05:16:12.777", "LastEditorUserId": "3093378", "LastActivityDate": "2015-02-24T05:20:48.477", "Score": "9", "OwnerUserId": "3093378", "Tags": "<c++><c++11><sfinae><decltype>", "AnswerCount": "1"}});