post_cb({"9220007": {"ParentId": "9219898", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-02-09T22:39:01.780", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:14.630", "Id": "9220007", "OwnerUserId": "240980", "Body": "<p>The <code>static const int</code> declaration is legal because you're declaring a constant, not a variable. <code>a</code> doesn't exist as a variable - the compiler is free to optimize it out, replacing it with the declared value <code>3</code> anywhere a reference to <code>Gone::a</code> appears. C++ allows the static initialization in this restricted case where it's an integer constant. </p>\n<p>You can find more details, including an ISO C++ standard citation <a href=\"https://stackoverflow.com/questions/2605520/c-where-to-initialize-static-const\">here</a>. </p>\n", "LastActivityDate": "2012-02-09T22:44:07.783"}, "9220067": {"ParentId": "9219898", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-02-09T22:43:36.893", "OwnerDisplayName": "user405725", "LastEditDate": "2017-03-25T11:13:29.960", "Id": "9220067", "Score": "6", "Body": "<p>This trick works only for constant compile-time expressions. Consider the following simple example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo {\npublic:\n    static const int bar = 0;\n};\n\nint main()\n{\n    std::cout &lt;&lt; Foo::bar &lt;&lt; endl;\n}\n</code></pre>\n<p>It works just fine, because compiler knows that <code>Foo::bar</code> is 0 and never changes. Thus, it optimizes the whole thing away.</p>\n<p>However, the whole thing breaks once you take the address of that variable like this:</p>\n<pre><code>int main()\n{\n    std::cout &lt;&lt; Foo::bar &lt;&lt; \" (\" &lt;&lt; &amp;Foo::bar &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Linker sends you to fix the program because compile-time constants don't have addresses.</p>\n<p>Now, the second case in your example doesn't work simply because a non-constant variable cannot be a constant compile-time expression. Thus, you have to define it somewhere and cannot assign any values in initialization.</p>\n<p>C++11, by the way, has <code>constexpr</code>. You can check <a href=\"https://en.wikipedia.org/wiki/C++11#constexpr_.E2.80.93_Generalized_constant_expressions\" rel=\"nofollow noreferrer\">Generalized constant expressions</a> wiki (or C++11 standard :-)) for more info.</p>\n<p>Also, be careful - with some toolchains you will never be able to link program as listed in your first example when optimizations are turned off, even if you never take an address of those variables. I think there is a <code>BOOST_STATIC_CONSTANT</code> macro in Boost to work around this problem (not sure if it works though because I reckon seeing linkage failures with some old gcc even with that macro).</p>\n", "LastActivityDate": "2017-03-25T11:13:29.960", "LastEditorUserId": "1377706"}, "9219987": {"ParentId": "9219898", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-02-09T22:37:50.387", "Score": "0", "LastEditorUserId": "540026", "LastEditDate": "2012-02-09T22:47:50.483", "Id": "9219987", "OwnerUserId": "540026", "Body": "<p>I seem to recall that originally (ARM) it was not allowed, and we used to use <code>enum</code> to define constants in class declarations.</p>\n<p>The const case was explicitly introduced so as to support availability of the value in headers for use in constant expressions, such as array sizes. </p>\n<p>I <em>think</em> (and please comment if I have this wrong) that strictly you still need to define the value:</p>\n<p><code>const int Gone::a;</code></p>\n<p>to comply with the One Definition Rule. However, in practice, you might find that the compiler optimises away the need for an address for <code>Gone::a</code> and you get away without it.</p>\n<p>If you take:</p>\n<p><code>const int* b = &amp;Gone::a;</code></p>\n<p>then you might find you do need the definition.</p>\n<p>See the standard, $9.4.2:</p>\n<p>ISO 1998:</p>\n<blockquote>\n<p id=\"so_9219898_9219987_0\">\"4 If a static data member is of const integral or const enumeration\n  type, its declaration in the class definition can specify a\n  constantinitializer which shall be an integral constant expression\n  (5.19). In that case, the member can appear in integral constant\n  expressions within its scope. The member shall still be defined in a\n  namespace scope if it is used in the program and the namespace scope\n  definition shall not contain an initializer.\"</p>\n</blockquote>\n<p>Draft for c++11:</p>\n<blockquote>\n<p id=\"so_9219898_9219987_1\">\"3 If a static data member is of const effective literal type, its\n  declaration in the class definition can specify a constant-initializer\n  brace-or-equal-initializer with an initializer-clause that is an\n  integral constant expression. A static data member of effective\n  literal type can be declared in the class definition with the\n  constexpr specifier; if so, its declaration shall specify a\n  constant-initializer brace-or-equal-initializer with an\n  initializerclause that is an integral constant expression. In both\n  these cases, the member may appear in integral constant expressions.\n  The member shall still be defined in a namespace scope if it is used\n  in the program and the namespace scope definition shall not contain an\n  initializer.\"</p>\n</blockquote>\n<p>I am not sure entirely what this covers, but I think it means that we can now use the same idiom for floating point and possibly string literals.</p>\n", "LastActivityDate": "2012-02-09T22:47:50.483"}, "9219898": {"CommentCount": "3", "AcceptedAnswerId": "9220067", "CreationDate": "2012-02-09T22:32:16.823", "LastActivityDate": "2017-03-25T11:13:29.960", "PostTypeId": "1", "ViewCount": "4698", "FavoriteCount": "1", "Title": "Why can you initialize a static const variable inline but not a plain static (C++)", "Id": "9219898", "Score": "6", "Body": "<p>If I were to do this</p>\n<pre><code>class Gone\n{\n    public:\n    static const int a = 3;\n}\n</code></pre>\n<p>it works but if do</p>\n<pre><code>class Gone\n{\n    public:\n    static int a = 3;\n}\n</code></pre>\n<p>it gives a compile error. Now I know why the second one doesn't work, I just don't know why the first one does.</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++>", "OwnerUserId": "654928", "AnswerCount": "5"}, "9220076": {"ParentId": "9219898", "CommentCount": "3", "CreationDate": "2012-02-09T22:44:10.083", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "9220076", "Score": "2", "Body": "<p>Initialization of variables has to be done at the point of <em>definition</em>, not the point of <em>declaration</em> in the general case. Inside the class brackets you only have a <em>declaration</em> and you need to provide a <em>definition</em> in a single translation unit<sup>*</sup>:</p>\n<pre><code>// can be in multiple translation units (i.e. a header included in different .cpp's)\nstruct test {\n   static int x;    // declaration\n   static double d; // declaration\n};\n// in a single translation unit in your program (i.e. a single .cpp file)\nint test::x = 5;       // definition, can have initialization\ndouble test::d = 5.0;  // definition\n</code></pre>\n<p>That being said, there is an exception for <code>static</code> integral constants (and only integral constants) where you can provide the value of the constant in the <em>declaration</em>. The reason for the exception is that it can be used as a <em>compile-time</em> constant (i.e. to define the size of an array), and that is only possible if the compiler <em>sees</em> the value of the constant in all translation units where it is needed.</p>\n<pre><code>struct test {\n   static const int x = 5;  // declaration with initialization\n};\nconst int test::x;          // definition, cannot have initialization\n</code></pre>\n<p>Going back to the original question:</p>\n<ul>\n<li>Why is it not allowed for non-const integers?</li>\n<li>because initialization happens in the <em>definition</em> and not <em>declaration</em>.</li>\n<li>Why is it allowed for integral constants?</li>\n<li>so that it can be used as a <em>compile-time constant</em> in all translation units</li>\n</ul>\n<hr>\n<p><sup>*</sup> The actual rules require the definition whenever the member attribute is <em>used</em> in the program. Now the definition of <em>used</em> is a bit tricky in C++03 as it might not be all that intuitive, for example the use of that constant as an <em>rvalue</em> does not constitute <em>use</em> according to the standard. In C++11 the term <em>used</em> has been replaced with <em>odr-used</em> in an attempt to avoid confusion.</p>\n</hr>", "LastActivityDate": "2012-02-09T22:44:10.083"}, "bq_ids": {"n4140": {"so_9219898_9219987_0": {"section_id": 5908, "quality": 0.7, "length": 28}, "so_9219898_9219987_1": {"section_id": 5908, "quality": 0.8305084745762712, "length": 49}}, "n3337": {"so_9219898_9219987_0": {"section_id": 5680, "quality": 0.7, "length": 28}, "so_9219898_9219987_1": {"section_id": 5680, "quality": 0.8305084745762712, "length": 49}}, "n4659": {"so_9219898_9219987_0": {"section_id": 7390, "quality": 0.6, "length": 24}}}, "9220029": {"ParentId": "9219898", "CommentCount": "0", "CreationDate": "2012-02-09T22:40:35.520", "OwnerUserId": "677004", "PostTypeId": "2", "Id": "9220029", "Score": "0", "Body": "<p>A static const is defined in the class definition since everybody that uses the code need to know the value at compile time, not link time. An ordinary static is actually only declared in the class definition, but defined once, in one translation unit.</p>\n", "LastActivityDate": "2012-02-09T22:40:35.520"}});