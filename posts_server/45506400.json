post_cb({"45506783": {"Id": "45506783", "PostTypeId": "2", "Body": "<p>From the page you referenced: assigning from an indeterminate value is undefined behavior <em>except</em></p>\n<blockquote>\n<p id=\"so_45506400_45506783_0\">If the indeterminate value of unsigned narrow character type or std::byte is assigned to another variable with unsigned narrow character type or std::byte (the value of the variable becomes indeterminate, but the behavior is not undefined)</p>\n</blockquote>\n<p>I believe this is because default initialization may place any combination of bits into the variable and while the standard guarantees that an unsigned narrow character type may take on values represented by every possible bit pattern, there is no such guarantee for other types. </p>\n", "LastActivityDate": "2017-08-04T12:23:17.600", "CommentCount": "2", "CreationDate": "2017-08-04T12:23:17.600", "ParentId": "45506400", "Score": "18", "OwnerUserId": "7619380"}, "45507183": {"Id": "45507183", "PostTypeId": "2", "Body": "<p>Online references like <a href=\"http://en.cppreference.com/w/cpp/language/default_initialization\" rel=\"noreferrer\">cppreference.com</a> are good up to a point. But it is known that sometimes errors or misinterpretations do occasionally slip through. So when dealing with such oddities, it is always a good thing to go to the official C++ standard.</p>\n<blockquote>\n<p id=\"so_45506400_45507183_0\">N3936</p>\n<h3>\u00a78.5 Initializers [dcl.init]</h3>\n<p id=\"so_45506400_45507183_1\">12 [...] When storage for an object with automatic or dynamic storage\n  duration is obtained, the object has an indeterminate value , and if\n  no initialization is performed for the object, that object retains an\n  indeterminate value until that value is replaced (5.17). [...] If an\n  indeterminate value is produced by an evaluation, the behavior is\n  undefined except in the following cases:</p>\n<ul>\n<li><p id=\"so_45506400_45507183_2\">If an indeterminate value of unsigned narrow character type (3.9.1) is produced by the evaluation of</p>\n<ul>\n<li><p id=\"so_45506400_45507183_3\">[...]</p></li>\n<li><p id=\"so_45506400_45507183_4\">the operand of a cast or conversion to an unsigned narrow character type (4.7, 5.2.3, 5.2.9, 5.4)</p></li>\n<li><p id=\"so_45506400_45507183_5\">[...]</p></li>\n</ul>\n<p id=\"so_45506400_45507183_6\">then the result of the operation is an indeterminate value.</p></li>\n<li><p id=\"so_45506400_45507183_7\">If an indeterminate value of unsigned narrow character type is produced by the evaluation of the right operand of a simple assignment\n  operator (5.17) whose first operand is an lvalue of unsigned narrow\n  character type, an indeterminate value replaces the value of the\n  object referred to by the left operand</p></li>\n<li><p id=\"so_45506400_45507183_8\">If an indeterminate value of unsigned narrow character type is produced by the evaluation of the initialization expression when\n  initializing an object of unsigned narrow character type, that object\n  is initialized to an indeterminate value.</p></li>\n</ul>\n<p id=\"so_45506400_45507183_9\">Example:</p>\n<pre><code>int f(bool b) {\n  unsigned char c;\n  unsigned char d = c; // OK, d has an indeterminate value\n  int e = d; // undefined behavior\n  return b ? d : 0; // undefined behavior if b is true\n}\n</code></pre>\n</blockquote>\n<p>So (to my big surprise) the standard backs this up.</p>\n<p>As for why, the most likely reason can be also found in the standard:</p>\n<blockquote>\n<h3>\u00a73.9.1 Fundamental types [basic.fundamental]</h3>\n<p id=\"so_45506400_45507183_10\">1 [...] For unsigned narrow character types, all possible bit patterns\n  of the value representation represent numbers. <strong>These requirements do\n  not hold for other types</strong></p>\n</blockquote>\n<hr>\n<p>As a side note, I just realized this can be used by an evil interviewer:</p>\n<p>Q. Can you in a well-defined behavior change the valid value of an object to an undetermined value? If yes, how?</p>\n<p>A.</p>\n<pre><code>unsigned char ind;\nunsigned char x = 24;\nx = ind; // x had a valid value, now x has an indetermined value\n</code></pre>\n</hr>", "LastEditorUserId": "2805305", "LastActivityDate": "2017-08-04T13:10:02.520", "Score": "24", "CreationDate": "2017-08-04T12:44:02.303", "ParentId": "45506400", "CommentCount": "8", "OwnerUserId": "2805305", "LastEditDate": "2017-08-04T13:10:02.520"}, "45506714": {"Id": "45506714", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/default_initialization\" rel=\"nofollow noreferrer\">the linked page</a>:</p>\n<blockquote>\n<p id=\"so_45506400_45506714_0\">Use of an indeterminate value obtained by default-initializing a non-class variable of any type is undefined behavior [...] except in the following cases:</p>\n<p id=\"so_45506400_45506714_1\">...</p>\n<p id=\"so_45506400_45506714_2\">if the indeterminate value of unsigned narrow character type or std::byte is used to initialize another variable with unsigned narrow character type or std::byte; </p>\n</blockquote>\n<p><code>unsigned char</code> is an unsigned narrow character, so this is one of the exceptions where UB does not occur.</p>\n", "LastActivityDate": "2017-08-04T12:20:13.030", "CommentCount": "1", "CreationDate": "2017-08-04T12:20:13.030", "ParentId": "45506400", "Score": "1", "OwnerUserId": "2201041"}, "bq_ids": {"n4140": {"so_45506400_45507183_1": {"length": 30, "quality": 0.967741935483871, "section_id": 3291}, "so_45506400_45507183_7": {"length": 29, "quality": 0.9666666666666667, "section_id": 3291}, "so_45506400_45507183_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 3291}, "so_45506400_45507183_10": {"length": 16, "quality": 0.8888888888888888, "section_id": 7210}, "so_45506400_45507183_6": {"length": 5, "quality": 1.0, "section_id": 3291}, "so_45506400_45506783_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 3291}, "so_45506400_45506714_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 3291}, "so_45506400_45507183_8": {"length": 21, "quality": 1.0, "section_id": 3291}, "so_45506400_45507183_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 3291}}, "n3337": {"so_45506400_45507183_10": {"length": 15, "quality": 0.8333333333333334, "section_id": 6954}}, "n4659": {"so_45506400_45507183_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 4053}, "so_45506400_45507183_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 4053}, "so_45506400_45507183_8": {"length": 21, "quality": 1.0, "section_id": 4053}, "so_45506400_45507183_1": {"length": 30, "quality": 0.967741935483871, "section_id": 4053}, "so_45506400_45507183_6": {"length": 5, "quality": 1.0, "section_id": 4053}, "so_45506400_45507183_7": {"length": 29, "quality": 0.9666666666666667, "section_id": 4053}, "so_45506400_45506714_2": {"length": 12, "quality": 0.8, "section_id": 4053}, "so_45506400_45507183_10": {"length": 13, "quality": 0.7222222222222222, "section_id": 8719}, "so_45506400_45506783_0": {"length": 14, "quality": 0.6363636363636364, "section_id": 4053}}}, "45537022": {"Id": "45537022", "PostTypeId": "2", "Body": "<p>Two related useful features of C, which carried into C++, are:</p>\n<ol>\n<li><p>Objects can be copied by copying all of the individual bytes contained therein.</p></li>\n<li><p>Structure-type objects can be safely copied in their entirety even when some of the objects therein do not hold defined values, provided that no attempt is made to read the undefined portions or copies thereof outside the context of whole-structure copying or individual-byte access.</p></li>\n</ol>\n<p>On most platforms, there's no particular reason why the same guarantees could not and should not be extended to other types as well, but the authors of the C Standard only sought to define guarantees that should be applicable on all platforms, and the authors of the C++ Standards have simply followed the C++ behaviors.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2017-08-07T20:44:11.200", "Score": "0", "CreationDate": "2017-08-06T22:00:04.983", "ParentId": "45506400", "CommentCount": "2", "OwnerUserId": "363751", "LastEditDate": "2017-08-07T20:44:11.200"}, "45506400": {"ViewCount": "1453", "Body": "<p>I saw the following example on <a href=\"http://en.cppreference.com/w/cpp/language/default_initialization\" rel=\"nofollow noreferrer\">cppreference.com</a></p>\n<pre><code>int x;     // OK: the value of x is indeterminate\nint y = x; // undefined behavior\n</code></pre>\n<p>Here, <code>int y = x;</code> is <strong>undefined behavior</strong> because <code>x</code> is uninitialized.</p>\n<p>But, </p>\n<pre><code>unsigned char c;     // OK: the value of c is indeterminate\nunsigned char d = c; // OK: the value of d is indeterminate\n</code></pre>\n<p>Here, <code>unsigned char d = c;</code> is <strong>indeterminate behavior</strong>, but <code>unsigned char c;</code> is also an uninitialized variable. </p>\n<p>So, <strong>Why is the value of <code>unsigned char d</code> indeterminate?</strong></p>\n", "AcceptedAnswerId": "45507183", "Title": "Consequences of uninitialised variables: int vs unsigned char", "CreationDate": "2017-08-04T12:04:45.720", "Id": "45506400", "CommentCount": "20", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-09-14T06:05:39.747", "LastEditorUserId": "6935629", "LastActivityDate": "2017-09-14T06:05:39.747", "Score": "24", "OwnerUserId": "6935629", "Tags": "<c++><initialization><language-lawyer><value><undefined-behavior>", "AnswerCount": "4"}});