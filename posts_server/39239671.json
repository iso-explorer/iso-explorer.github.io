post_cb({"39248589": {"ParentId": "39239671", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>AFAICS, the code is fine (also supported by the fact that both <a href=\"http://rextester.com/HFZ4995\" rel=\"nofollow\">VC++</a> and <a href=\"https://godbolt.org/g/RAQmeU\" rel=\"nofollow\">ICC</a> compile it). After all, template argument deduction seems to work with function types just as it does with function pointer or reference types; <a href=\"http://eel.is/c++draft/temp.deduct.type#18\" rel=\"nofollow\">[temp.deduct.type]/18</a>: </p>\n<blockquote>\n<p id=\"so_39239671_39248589_0\">A <em>template-argument</em> can be deduced from a function [\u2026] type.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/temp.deduct.call#1\" rel=\"nofollow\">[temp.deduct.call]/1</a>:</p>\n<blockquote>\n<p id=\"so_39239671_39248589_1\">For a function parameter pack that occurs at the end of the <em>parameter-declaration-list</em>,\n  deduction is performed for each remaining argument of the call, taking the type <code>P</code> of the <em>declarator-id</em> of the\n  function parameter pack as the corresponding function template parameter type. Each deduction deduces\n  template arguments for subsequent positions in the template parameter packs expanded by the function\n  parameter pack.</p>\n</blockquote>\n<p>In particular the latter paragraph confirms that there is some inconcistency, since the (unsuccessful) deduction of the pack <code>T</code> in the second case reduces to the (successful) deduction in case 1.</p>\n<p>My guess is that Clang and GCC decay the parameter types for function templates right at declaration time, but refuse to do so when the parameter is a pack expansion (and then fail to deduce). Clang's error message when we alter the sample call to <code>f(f1)</code> is </p>\n<blockquote>\n<p id=\"so_39239671_39248589_2\">note: candidate template ignored: could not match <code>'void (T)'</code> against <code>'void (*)(int)'</code></p>\n</blockquote>\n<p>So the argument is in fact decayed before deduction. </p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2016-08-31T11:52:49.050", "Id": "39248589", "Score": "3", "CreationDate": "2016-08-31T11:37:05.570", "LastActivityDate": "2016-08-31T11:52:49.050"}, "39240142": {"ParentId": "39239671", "CommentCount": "5", "Body": "<p>Does this explains?</p>\n<pre><code>template&lt;class... T&gt;\nvoid f(void(*...t)(T)) {\n  std::cout &lt;&lt; \"Ptr to functions\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;class... T&gt;\nvoid g(void(&amp;...t)(T)) {\n  std::cout &lt;&lt; \"Ref to functions\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;class... T&gt;\nvoid h(void(...t)(T)) {\n  std::cout &lt;&lt; \"Mmmm... potential of confusion\" &lt;&lt; std::endl;\n}\n\nvoid s1(int) {\n\n}\n\nvoid s2(long) {\n\n}\n\n\n#include &lt;type_traits&gt;\nint main() {\n  // this compiles Ok. The compiler knows\n  //    pointer to functions will be passed\n  //    and can infer their correspondent T\n  f(s1,s2);\n\n  // this compiles Ok. The compiler knows that\n  //   reference to functions will be passed\n  //   and can infer their correspondent T\n  g(s1,s2);\n\n     h(s1,s2);\n  // ^^^^^^^^^ this will cause a compilation error telling:\n  //   template argument deduction/substitution failed:\n  //   mismatched types \u2018void(T)\u2019 and \u2018void (*)(int)\u2019\n  // The compiler can't decide how the function-type parameters are passed\n  //  by ptr, by ref, one by ref other by ptr? As such\n  //  cannot deduce their correspondent T in the argpack \n\n\n  // however, this will compile OK!!!\n  // The s1/s2 correspondent T-es in argpack are clearly specified, \n  // not a problem.\n  h&lt;int,long&gt;(s1,s2);\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "620908", "PostTypeId": "2", "Id": "39240142", "Score": "0", "CreationDate": "2016-08-31T03:09:44.080", "LastActivityDate": "2016-08-31T03:09:44.080"}, "39239671": {"CommentCount": "1", "AcceptedAnswerId": "39248589", "PostTypeId": "1", "LastEditorUserId": "2969631", "CreationDate": "2016-08-31T02:09:23.517", "LastActivityDate": "2016-08-31T11:52:49.050", "LastEditDate": "2016-08-31T06:26:06.690", "ViewCount": "143", "FavoriteCount": "0", "Title": "Inconsistency in function type decay between variadic/non-variadic templates?", "Id": "39239671", "Score": "6", "Body": "<p>Given a non-variadic function template:</p>\n<pre><code>template&lt;class T&gt;\nvoid f(void(t)(T));\n</code></pre>\n<p>And some plain functions:</p>\n<pre><code>void f1(int);\nvoid f2(char);\n</code></pre>\n<p>This works:</p>\n<pre><code>f(f1);\n</code></pre>\n<p>The type of <code>t</code> becomes <code>void (*)(int)</code>.</p>\n<p>However, the variadic counterpart:</p>\n<pre><code>template&lt;class... T&gt;\nvoid f(void(...t)(T));\n\n// call\nf(f1, f2);\n</code></pre>\n<p>does not work. The compilers (gcc &amp; clang) complain about mismatched types <code>void(T)</code> and <code>void (*)(int)</code>. See <a href=\"http://coliru.stacked-crooked.com/a/034ca8f08b9826a4\" rel=\"nofollow\">DEMO</a>.</p>\n<p>Note that if <code>*</code> is added explicitly, it works as it should:</p>\n<pre><code>template&lt;class... T&gt;\nvoid f(void(*...t)(T));\n</code></pre>\n<p>So, why the non-variadic one can decay the function type while the variadic one cannot?</p>\n", "Tags": "<c++><c++11><language-lawyer><variadic-templates><function-templates>", "OwnerUserId": "2969631", "AnswerCount": "3"}, "39239721": {"ParentId": "39239671", "CommentCount": "2", "Body": "<p>Because your syntax is not quite right.</p>\n<pre><code>template&lt;class... T&gt;\nvoid f(void(t)(T...));\n\nvoid f1(int);\n\nvoid foo()\n{\n    f(f1);\n}\n</code></pre>\n<p>Tested with gcc 6.1.1. Compiles without errors.</p>\n<p>In the non-variadic version, you are using the template parameter as the parameter to the arguments to the passed function parameter.</p>\n<p>Therefore, for the variadic version, that's where the parameter pack gets expanded.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "39239721", "Score": "0", "CreationDate": "2016-08-31T02:16:47.153", "LastActivityDate": "2016-08-31T02:16:47.153"}, "bq_ids": {"n4140": {"so_39239671_39248589_0": {"section_id": 272, "quality": 1.0, "length": 5}, "so_39239671_39248589_1": {"section_id": 302, "quality": 0.7368421052631579, "length": 28}}, "n3337": {"so_39239671_39248589_0": {"section_id": 263, "quality": 1.0, "length": 5}, "so_39239671_39248589_1": {"section_id": 293, "quality": 0.7368421052631579, "length": 28}}, "n4659": {"so_39239671_39248589_0": {"section_id": 279, "quality": 1.0, "length": 5}, "so_39239671_39248589_1": {"section_id": 309, "quality": 0.9736842105263158, "length": 37}}}});