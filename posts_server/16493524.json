post_cb({"16493524": {"CommentCount": "5", "AcceptedAnswerId": "16495384", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-05-11T03:44:24.713", "LastActivityDate": "2013-05-11T11:50:14.643", "LastEditDate": "2017-05-23T12:33:10.933", "ViewCount": "1321", "FavoriteCount": "1", "Title": "Is it valid to bind non-const lvalue-references to rvalues in C++ 11?(modified)", "Id": "16493524", "Score": "6", "Body": "<p>I know in c++03, an an non-const reference cannot be bound to rvalues.</p>\n<p><code>T&amp; t = getT();</code> is invalid, and in c++11, we can do this: <code>T&amp;&amp; t = getT();</code>  but what about the above code, should that work in c++11?</p>\n<p>I tested the codes below with vs11:</p>\n<pre><code> Foo getFoo() {\n  return Foo();\n}\n\nvoid fz(Foo&amp; f) {\n}\n\nint getInt() {\n  return int();\n}\n\nvoid iz(int&amp; i) {\n}\n\nint main() {\n  {\n    Foo&amp; z = getFoo(); //ok\n    fz(getFoo()); //ok\n\n    int&amp; z2 = getInt(); //error: initial value of reference to non-const must be an lvalue\n    iz(getInt()); //same as above\n  }\n}\n</code></pre>\n<p><code>Foo</code> is a custom class, I don't understand why the first two line compiles.The temporary referenced by <code>z</code> is destructed at the end of the inner scope of main. Does the standard say anything about this?</p>\n<pre><code>class Foo {\npublic:\n  Foo() {\n    std::cout &lt;&lt; \"constructed\\n\";\n  }\n  ~Foo() {\n    std::cout &lt;&lt; \"destructed\\n\";\n  }\n};\n</code></pre>\n<p>I just saw a similar question: <a href=\"https://stackoverflow.com/questions/7189420/one-vs2010-bug-allowing-binding-non-const-reference-to-rvalue-without-even-a-w?rq=1\">One VS2010 bug ? Allowing binding non-const reference to rvalue WITHOUT EVEN a warning?</a></p>\n", "Tags": "<c++><visual-studio-2012><c++11><lvalue><rvalue>", "OwnerUserId": "1971684", "AnswerCount": "2"}, "16494069": {"ParentId": "16493524", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No you can't bind a temporary to a non-const lvalue reference.</p>\n<pre><code>T f();\n\nT&amp; t1 = f(); // won't compile\nconst T&amp; t2 = f(); // OK\nT&amp;&amp; t3 = f(); // OK\n</code></pre>\n<p>This is a safety feature.  Mutating a temporary by an lvalue that is about to die anyway is most likely a logic error, so it isn't allowed by the language.</p>\n<p>Note that due to the RVO than in practice:</p>\n<pre><code>T&amp;&amp; t3 = f();\n</code></pre>\n<p>and</p>\n<pre><code>T t3 = f();\n</code></pre>\n<p>are equivilent.</p>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2013-05-11T05:36:37.550", "Id": "16494069", "Score": "0", "CreationDate": "2013-05-11T05:27:57.143", "LastActivityDate": "2013-05-11T05:36:37.550"}, "bq_ids": {"n4140": {"so_16493524_16495384_11": {"section_id": 3321, "quality": 0.6666666666666666, "length": 4}, "so_16493524_16495384_7": {"section_id": 3321, "quality": 1.0, "length": 20}, "so_16493524_16495384_3": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_16493524_16495384_5": {"section_id": 3321, "quality": 0.6666666666666666, "length": 4}, "so_16493524_16495384_12": {"section_id": 3321, "quality": 0.75, "length": 12}, "so_16493524_16495384_6": {"section_id": 3321, "quality": 0.75, "length": 12}, "so_16493524_16495384_9": {"section_id": 3321, "quality": 0.8461538461538461, "length": 11}, "so_16493524_16495384_4": {"section_id": 3321, "quality": 1.0, "length": 5}}, "n3337": {"so_16493524_16495384_11": {"section_id": 3191, "quality": 0.6666666666666666, "length": 4}, "so_16493524_16495384_7": {"section_id": 3191, "quality": 1.0, "length": 20}, "so_16493524_16495384_3": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_16493524_16495384_5": {"section_id": 3191, "quality": 0.6666666666666666, "length": 4}, "so_16493524_16495384_12": {"section_id": 3191, "quality": 0.8125, "length": 13}, "so_16493524_16495384_6": {"section_id": 3191, "quality": 0.8125, "length": 13}, "so_16493524_16495384_9": {"section_id": 3191, "quality": 0.8461538461538461, "length": 11}, "so_16493524_16495384_4": {"section_id": 3191, "quality": 1.0, "length": 5}}, "n4659": {"so_16493524_16495384_11": {"section_id": 4087, "quality": 0.6666666666666666, "length": 4}, "so_16493524_16495384_7": {"section_id": 4087, "quality": 1.0, "length": 20}, "so_16493524_16495384_9": {"section_id": 4087, "quality": 0.8461538461538461, "length": 11}, "so_16493524_16495384_3": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_16493524_16495384_5": {"section_id": 4087, "quality": 0.6666666666666666, "length": 4}, "so_16493524_16495384_6": {"section_id": 4087, "quality": 0.75, "length": 12}, "so_16493524_16495384_12": {"section_id": 4087, "quality": 0.75, "length": 12}, "so_16493524_16495384_4": {"section_id": 4087, "quality": 1.0, "length": 5}}}, "16495384": {"ParentId": "16493524", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_16493524_16495384_0\">should that work in c++11?</p>\n</blockquote>\n<p>No, it should not. </p>\n<blockquote>\n<p id=\"so_16493524_16495384_1\"><code>Foo</code> is a custom class, I don't understand why the first two line compiles</p>\n</blockquote>\n<p>It compiles only with MSVC. MSVC has an (arguably useful) <em>compiler extension</em> that allows binding lvalues of user-defined types to rvalues, but the Standard itself forbids this. See, for instance, <a href=\"http://ideone.com/TzGfy7\" rel=\"noreferrer\">this live example</a> where GCC 4.7.2 refuses to compile your code.</p>\n<blockquote>\n<p id=\"so_16493524_16495384_2\">Does the standard say anything about this?</p>\n</blockquote>\n<p>Indeed it does. Per paragraph 8.5.3/5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16493524_16495384_3\">A reference to type \u201c<code>cv1 T1</code>\u201d is initialized by an expression of type \u201c<code>cv2 T2</code>\u201d as follows:</p>\n<p id=\"so_16493524_16495384_4\">\u2014 If the reference is an lvalue reference and the initializer expression</p>\n<blockquote>\n<p id=\"so_16493524_16495384_11\">\u2014 is an lvalue (but is not a bit-field), and \u201c<code>cv1 T1</code>\u201d is reference-compatible with \u201c<code>cv2 T2</code>,\u201d or</p>\n<p id=\"so_16493524_16495384_12\">\u2014 has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be\n    implicitly converted to an lvalue of type \u201c<code>cv3 T3</code>,\u201d where \u201c<code>cv1 T1</code>\u201d is reference-compatible with \u201c<code>cv3\n    T3</code>\u201d [...],</p>\n</blockquote>\n<p id=\"so_16493524_16495384_7\">then the reference is bound to the initializer expression lvalue in the first case and to the lvalue result\n  of the conversion in the second case (or, in either case, to the appropriate base class subobject of\n  the object). [...]</p>\n<p id=\"so_16493524_16495384_8\">[ ...]</p>\n<p id=\"so_16493524_16495384_9\">\u2014 <strong>Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be\n  const), or the reference shall be an rvalue reference</strong>. [ <em>Example:</em></p>\n<pre><code>double&amp; rd2 = 2.0; // error: not an lvalue and reference not const\nint i = 2;\ndouble&amp; rd3 = i; // error: type mismatch and reference not const\n</code></pre>\n<p id=\"so_16493524_16495384_10\"><em>\u2014end example</em> ]</p>\n</blockquote>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-05-11T08:51:35.853", "Id": "16495384", "Score": "5", "CreationDate": "2013-05-11T08:46:34.547", "LastActivityDate": "2013-05-11T08:51:35.853"}});