post_cb({"15004242": {"CommentCount": "1", "ViewCount": "151", "CreationDate": "2013-02-21T14:05:45.563", "LastActivityDate": "2013-02-21T18:48:32.593", "Title": "Functions returning a collection of objects in C++", "PostTypeId": "1", "Id": "15004242", "Score": "2", "Body": "<p>In my current project I need to implement quite a few functions/methods that take some parameters and generate a collection of results (rather large). So in order to return this collection without copying, I can either create a new collection and return a smart pointer:</p>\n<pre><code>boost::shared_ptr&lt;std::vector&lt;Stuff&gt; &gt; generate();\n</code></pre>\n<p>or take a reference to a vector which will be populated:</p>\n<pre><code>void generate(std::vector&lt;Stuff&gt; &amp;output);\n</code></pre>\n<p>Both approaches have benefits. The first clearly shows that the vector is the output of the function, it is trivial to use in a parallelized scenario, etc. The second might be more efficient when called in a loop (because we don't allocate memory every time), but then it is not that obvious that the parameter is the output, and someone needs to clean the old data from the vector...</p>\n<p>Which would be more customary in real life (i.e. what is the best practise)? In C#/java I would argue that the first one, what is the case in C++?</p>\n<p>Also, is it possible to effectively return a vector by value using C++11? What would the pitfalls be?</p>\n", "Tags": "<c++><design-patterns>", "OwnerUserId": "5363", "AnswerCount": "5"}, "15004351": {"ParentId": "15004242", "CommentCount": "0", "CreationDate": "2013-02-21T14:10:45.923", "OwnerUserId": "160206", "PostTypeId": "2", "Id": "15004351", "Score": "1", "Body": "<p>There is an alternative approach. If you can make your functions template, make them take an output iterator (whose type is a template argument) as argument:</p>\n<pre><code>tempalte&lt;class OutputIterator&gt;\nvoid your_algorithm(OutputIterator out) {\n    for(/*condition*/) {\n        ++out = /* calculation */;\n    }\n}\n</code></pre>\n<p>This has the advantage that the caller can decide in what kind of collection he wants to store the result (the output iterator could for instance write directly to a file, or store the result in a <code>std::vector</code>, or filter it, etc.).</p>\n", "LastActivityDate": "2013-02-21T14:10:45.923"}, "15010017": {"ParentId": "15004242", "CommentCount": "1", "CreationDate": "2013-02-21T18:48:32.593", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "15010017", "Score": "1", "Body": "<p>Believe it or not, I'm going to suggest that instead of either of those approaches just take the obvious implementation and return by value! Compilers are very often able to optimize away the notional copy that would be induced, removing it completely. By writing the code in the most obvious manner you make it very clear to future maintainers what the intent is.</p>\n<p>But let's say you try return by value and your program runs too slow <em>and</em> let's further suppose that your profiler shows that the return by value is in fact your bottleneck. In this case I would allocate the container on the heap and return as an <code>auto_ptr</code> in C++03 or a <code>unique_ptr</code> in C++11 to clearly indicate that ownership is being transferred and that the generate isn't keeping a copy of that <code>shared_ptr</code> for its own purposes later.</p>\n<p>Finally, the series at <a href=\"http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/\" rel=\"nofollow\">http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/</a> provides a great perspective on almost the exact same question.</p>\n", "LastActivityDate": "2013-02-21T18:48:32.593"}, "15004336": {"ParentId": "15004242", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2013-02-21T14:10:05.727", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:56:25.503", "Id": "15004336", "OwnerUserId": "1932150", "Body": "<p>You should <strong>return by value.</strong></p>\n<blockquote>\n<p id=\"so_15004242_15004336_0\">is it possible to effectively return a vector by value using C++11? </p>\n</blockquote>\n<p>Yes, C++11 supports <a href=\"http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html\" rel=\"nofollow noreferrer\"><em>move semantics</em></a>. You return a value, but the compiler knows it's a temporary, and therefore can invoke a special constructor (move constructor) that is especially designed to simply \"steal the guts\" of the returned object. After all, you won't use that temporary object anymore, so why copying it when you can just move its content?</p>\n<p>Apart from this, it may be worth mentioning that most C++ compilers, even pre-C++11, implement <a href=\"http://www.google.com/url?sa=t&amp;rct=j&amp;q=nrvo%20wikipedia&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CDEQFjAA&amp;url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FReturn_value_optimization&amp;ei=1yomUezgDYmM4gTWnIC4Cw&amp;usg=AFQjCNE4f004wOvYKvcVgvTdGsT2QuMjsw&amp;bvm=bv.42661473,d.Yms\" rel=\"nofollow noreferrer\">(Named) Return Value Optimization</a>, which would elide the copy anyway, incurring in no overhead. Thus, you may want to actually measure the performance penalty you (possibly) get before optimizing.</p>\n<p>I think you should pass by reference, or return a shared pointer, only when you need <a href=\"https://stackoverflow.com/questions/14539624/memory-management-patterns-in-c/14539873#14539873\"><em>reference semantics</em></a>. This does not seem to be your case.</p>\n", "LastActivityDate": "2013-02-21T14:15:06.870"}, "15004366": {"ParentId": "15004242", "CommentCount": "1", "CreationDate": "2013-02-21T14:11:15.740", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "15004366", "Score": "1", "Body": "<p>The best practise will probably be surprising to you. I would recommend returning by value in both C++03 and C++11.</p>\n<ul>\n<li><p>In C++03, if you create a <code>std::vector</code> local to <code>generate</code> and return it, the copy may be elided by the compiler (and almost certainly will be). See C++03 \u00a712.8/15:</p>\n<blockquote>\n<p id=\"so_15004242_15004366_0\">in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object with the same cv-unqualified type as the function return type, the copy operation can be omitted by constructing the automatic object directly into the function's return value</p>\n</blockquote></li>\n<li><p>In C++11, if you create a <code>std::vector</code> local to <code>generate</code> and return it, the copy will first be considered as a move first (which will already be very fast) and then <em>that</em> may be elided (and almost certainly will be). See C++11 \u00a712.8/31:</p>\n<blockquote>\n<p id=\"so_15004242_15004366_1\">in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</p>\n</blockquote>\n<p>And \u00a712.8/32:</p>\n<blockquote>\n<p id=\"so_15004242_15004366_2\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote></li>\n</ul>\n<p>So return by value!</p>\n", "LastActivityDate": "2013-02-21T14:11:15.740"}, "15004328": {"ParentId": "15004242", "CommentCount": "1", "CreationDate": "2013-02-21T14:09:49.713", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "15004328", "Score": "4", "Body": "<p>do correctness first, <em>then</em> optimize if necessary</p>\n<p>with both move semantics and Return Value Optimization conspiring to make an ordinary function result non-copying, you would probably have to work at it to make it sufficiently inefficient to be worth optimization work</p>\n<p>so, just return the collection as a function result, then <strong>MEASURE</strong> if you feel that it's too slow</p>\n", "LastActivityDate": "2013-02-21T14:09:49.713"}, "bq_ids": {"n4140": {"so_15004242_15004366_2": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}, "so_15004242_15004366_1": {"section_id": 480, "quality": 1.0, "length": 35}, "so_15004242_15004366_0": {"section_id": 480, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_15004242_15004366_2": {"section_id": 472, "quality": 1.0, "length": 29}, "so_15004242_15004366_1": {"section_id": 471, "quality": 1.0, "length": 35}, "so_15004242_15004366_0": {"section_id": 471, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_15004242_15004366_2": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}, "so_15004242_15004366_0": {"section_id": 502, "quality": 0.8666666666666667, "length": 26}, "so_15004242_15004366_1": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}}}});