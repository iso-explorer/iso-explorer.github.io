post_cb({"31127551": {"ParentId": "31120621", "CommentCount": "1", "Body": "<p>Here is what the standard says about <code>std::basic_istream&lt;...&gt;::read()</code> in 27.7.2.3 [istream.unformatted] paragraphs 30 and 31 (emphasis is mine):</p>\n<blockquote>\n<pre><code>basic_istream&lt;charT,traits&gt;&amp; read(char_type* s, streamsize n);\n</code></pre>\n<p id=\"so_31120621_31127551_0\"><em>Effects</em>: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After constructing a <code>sentry</code> object, if <code>!good()</code> calls <code>setstate(failbit)</code> which may throw an exception, and return. Otherwise extracts characters and stores them into successive locations of an <strong>array whose first element is designated by</strong> <code>s</code>. Characters are extracted and stored until either of the following occurs:</p>\n<ul>\n<li><code>n</code> characters are stored;</li>\n<li>end-of-file occurs on the input sequence (in which case the function calls <code>setstate(failbit | eofbit)</code>, which may throw <code>ios_base::failure</code>).</li>\n</ul>\n<p id=\"so_31120621_31127551_1\"><em>Returns</em>: <code>*this</code>.</p>\n</blockquote>\n<p>When a function is described as taking array as argument, there are some constraints on what can be passed according to 17.6.4.9 [res.on.arguments] paragraph 1 (elided text applies to other entities):</p>\n<blockquote>\n<p id=\"so_31120621_31127551_2\">Each of the following applies to all arguments to functions defined in the C++ standard library, unless explicitly stated otherwise.</p>\n<ul>\n<li>If an argument to a function has an invalid value (such as a value outside the domain of the function or a pointer invalid for its intended use), the behavior is undefined.</li>\n<li>If a function argument is described as being an array, the pointer actually passed to the function shall have a value such that all address computations and accesses to objects (<strong>that would be valid if the pointer did point to the first element of such an array</strong>) are in fact valid.</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>Actual arrays cannot be empty according to 8.3.4 [dcl.array] paragraph 1 (note that the case where the constant expression is absent yields an array of unspecified size which still gets a non-zero size eventually):</p>\n<blockquote>\n<p id=\"so_31120621_31127551_3\">... If the constant-expression is present, it shall be a converted constant expression of type std::size_t and its value shall be greater\n  than zero. ...</p>\n</blockquote>\n<p>Since a null pointer cannot point to a non-empty array functions expecting an array being passed do expect a non-null pointer. Put differently, I think the assertion you observed is entirely in order, giving defined behavior to a use which has undefined behavior according to the standard: a null pointer even with a zero size passed to <code>read()</code> yield undefined behavior according to the standard.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "31127551", "Score": "1", "CreationDate": "2015-06-30T00:13:03.160", "LastActivityDate": "2015-06-30T00:13:03.160"}, "bq_ids": {"n4140": {"so_31120621_31127551_3": {"section_id": 3228, "quality": 0.9166666666666666, "length": 11}, "so_31120621_31127551_2": {"section_id": 6325, "quality": 1.0, "length": 11}, "so_31120621_31127551_0": {"section_id": 2237, "quality": 0.9487179487179487, "length": 37}}, "n3337": {"so_31120621_31127551_3": {"section_id": 3101, "quality": 0.75, "length": 9}, "so_31120621_31127551_2": {"section_id": 6082, "quality": 1.0, "length": 11}, "so_31120621_31127551_0": {"section_id": 2225, "quality": 0.9487179487179487, "length": 37}}, "n4659": {"so_31120621_31127551_3": {"section_id": 3985, "quality": 1.0, "length": 12}, "so_31120621_31127551_2": {"section_id": 7835, "quality": 1.0, "length": 11}, "so_31120621_31127551_0": {"section_id": 2510, "quality": 0.9230769230769231, "length": 36}}}, "31120621": {"CommentCount": "11", "ViewCount": "152", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-06-29T16:15:36.183", "LastActivityDate": "2015-06-30T00:13:03.160", "Title": "std::iostream read or write with count zero and invalid buffer", "AcceptedAnswerId": "31127551", "LastEditDate": "2017-05-23T11:58:35.740", "Id": "31120621", "Score": "2", "Body": "<p>The following code reads a file containing some value that represents the length of more following data.</p>\n<pre><code>auto file = std::ifstream(filename, std::ios::in | std::ios::binary);\n// dataLen = Read some header field containing a length of following data.\nstd::vector&lt;unsigned char&gt; data;\ndata.resize(dataLen);\nfile.read((char*)data.data(), dataLen);\n</code></pre>\n<p>It fails with the MSVC 2013 compiler if <code>dataLen = 0</code>. It causes an abort with the message <code>Expression: invalid null pointer</code>, because <code>data.data()</code> returns a null pointer.</p>\n<p><a href=\"https://stackoverflow.com/questions/13014192/stdifstreamread-or-stdofstreamwrite-with-a-zero-parameter\">This question </a> suggests that a <code>count</code> of 0 is valid for <code>std::basic_istream::read</code>, but the third comment on the question seems to point out my issue.</p>\n<p>Is it valid C++ to pass an invalid pointer to <code>std::basic_istream::read</code> (or <code>std::basic_ostream::write</code>) with a size of 0? It would seem logical to me, because the call should not touch the buffer anyway.</p>\n<p>The obvious solution is to deal with this special case with an if clause, but I am wondering if MSVC is wrong once again.</p>\n<p>Here is a compiled example of clang running the program fine: <a href=\"http://coliru.stacked-crooked.com/a/c036ec31abd80f22\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/c036ec31abd80f22</a></p>\n", "Tags": "<c++><c++11><iostream><ostream><istream>", "OwnerUserId": "2040925", "AnswerCount": "1"}});