post_cb({"2955921": {"FavoriteCount": "8", "ViewCount": "6040", "Id": "2955921", "AcceptedAnswerId": "3090741", "Score": "19", "Title": "Thread-safe initialization of function-local static const objects", "LastEditorUserId": "-1", "CommentCount": "2", "Body": "<p><a href=\"https://stackoverflow.com/questions/2955797/how-to-address-thread-safety-of-service-data-used-for-maintaining-static-local-v\">This question</a> made me question a practice I had been following for years. </p>\n<p>For <em>thread-safe initialization</em> of function-local static const objects I protect the actual <em>construction</em> of the object, but not the <em>initialization of the function-local reference</em> referring to it. Something like this: </p>\n<pre><code>namespace {\n  const some_type&amp; create_const_thingy()\n  {\n     lock my_lock(some_mutex);\n     static const some_type the_const_thingy;\n     return the_const_thingy;\n  }\n}\n\nvoid use_const_thingy()\n{\n  static const some_type&amp; the_const_thingy = create_const_thingy();\n\n  // use the_const_thingy\n\n}\n</code></pre>\n<p>The idea is that locking takes time, and if the reference is overwritten by several threads, it won't matter. </p>\n<p>I'd be interested if this is </p>\n<ol>\n<li>safe enough in practice? </li>\n<li>safe according to The Rules? (I know, the current standard doesn't even know what \"concurrency\" is, but what about trampling over an already initialized reference? And do other standards, like POSIX, have something to say that's relevant to this?)</li>\n</ol>\n<p><em>The reason I want to know this is that I want to know whether I can leave the code as it is or whether I need to go back and fix this.</em> </p>\n<hr>\n<p>For the inquiring minds: </p>\n<p>Many such function-local static const objects I used are maps which are initialized from const arrays upon first use and used for lookup. For example, I have a few XML parsers where tag name strings are mapped to <code>enum</code> values, so I could later <code>switch</code> over the tags' <code>enum</code> values. </p>\n<hr>\n<p>Since I got some answers as to what to do instead, but haven't got an answer to my actual questions (see 1. and 2. above), I'll start a bounty on this. Again:<br>\n<strong>I am not interested in what I could do <em>instead</em>, I do really want to know about <em>this</em></strong>. </br></p>\n</hr></hr>", "Tags": "<c++><concurrency><multithreading><static-initialization>", "CreationDate": "2010-06-02T08:04:00.133", "LastEditDate": "2017-05-23T11:53:55.947", "LastActivityDate": "2013-04-23T21:05:03.793", "PostTypeId": "1", "AnswerCount": "7", "OwnerUserId": "140719"}, "3082861": {"CommentCount": "3", "Body": "<p>Just call the function before you start creating threads, thus guaranteeing the reference and the object. Alternatively, don't use such a truly terrible design pattern. I mean, why on earth have a static reference to a static object? Why even have static objects? There's no benefit to this. Singletons are a terrible idea.</p>\n", "CreationDate": "2010-06-21T07:44:02.047", "ParentId": "2955921", "Id": "3082861", "LastActivityDate": "2010-06-21T07:44:02.047", "PostTypeId": "2", "Score": "-1", "OwnerUserId": "298661"}, "3082618": {"CreationDate": "2010-06-21T06:53:14.750", "CommentCount": "0", "Body": "<p>In brief, I think that:</p>\n<ul>\n<li><p>The object initialization is thread-safe, assuming that \"some_mutex\" is fully constructed when entering \"create_const_thingy\".</p></li>\n<li><p>The initialization of the object reference inside \"use_const_thingy\" is not guaranteed to be thread-safe; it might (as you say) be subject of getting initialized multiple times (which is less of a problem), <em>but it might also be subject to word tearing</em> which could result in undefined behaviour.</p></li>\n</ul>\n<p>[I assume that the C++ reference is implemented as a reference to the actual object using a pointer value, which could in theory be read when partially written to].</p>\n<p>So, to try and answer your question:</p>\n<ol>\n<li><p>Safe enough in practice: Very likely, but ultimately depends on pointer size,  processor architecture and code generated by the compiler. The crux here is likely to be whether a pointer-sized write/read is atomic or not.</p></li>\n<li><p>Safe according to the rule: Well, there are no such rules in C++98, sorry (but you knew that already).</p></li>\n</ol>\n<hr>\n<p><strong>Update:</strong> After posting this answer I realized that it only focuses on a small, esoteric part of the real problem, and because of this decided to post another answer instead of editing the contents. I'm leaving the contents \"as-is\" as it has some relevance to the question (and also to humble myself, reminding me to think through things a bit more before answering).</p>\n</hr>", "Id": "3082618", "OwnerUserId": "81588", "LastEditDate": "2010-06-22T07:00:31.467", "ParentId": "2955921", "LastActivityDate": "2010-06-22T07:00:31.467", "PostTypeId": "2", "Score": "0", "LastEditorUserId": "81588"}, "3082613": {"CreationDate": "2010-06-21T06:51:13.657", "CommentCount": "4", "Body": "<p>So, the relevant part of the spec is 6.7/4:</p>\n<blockquote>\n<p id=\"so_2955921_3082613_0\">An implementation is permitted to perform early initialization of other local objects with static storage duration under the same conditions that an implementation is permitted to statically initialize an object with static storage duration in namespace scope (3.6.2). Otherwise such an object is initialized the first time control passes through its declaration; such an object is considered initialized upon the completion of its initialization.</p>\n</blockquote>\n<p>Assuming the second part holds (<code>object is initialized the first time control passes through its declaration</code>), your code can be considered thread safe.</p>\n<p>Reading through 3.6.2, it appears the early initialization permitted is converting <em>dynamic-initialization</em> to <em>static-initialization</em>.  Since <em>static-initialization</em> must happen before any <em>dynamic-initialization</em> and since I can't think of any way to create a thread until you get to <em>dynamic-initialization</em>, such an early initialization would also guarantee the constructor would get called a single time.</p>\n<p><strong>Update</strong></p>\n<p>So, in respect to calling the <code>some_type</code> constructor for <code>the_const_thingy</code>, your code is correct according to the rules.</p>\n<p>This leaves the issue about overwriting the reference which is definitely not covered by the spec.  That said, if you are willing to assume that references are implemented via pointers (which I believe is the most common way to do that), then all you are going to do is overwrite a pointer with the value that it already holds.  So my take is that this should be safe in practice.</p>\n", "Id": "3082613", "OwnerUserId": "29809", "LastEditDate": "2010-06-22T07:08:35.007", "ParentId": "2955921", "LastActivityDate": "2010-06-22T07:08:35.007", "PostTypeId": "2", "Score": "3", "LastEditorUserId": "29809"}, "2956395": {"CommentCount": "2", "Body": "<p>I am not standardista...</p>\n<p>But for the use you mention, why not simply initialize them before any thread is created ? Many Singletons issues are caused because people use the idiomatic \"single thread\" lazy initialization while they could simply instantiate the value when the library is loaded (like a typical global).</p>\n<p>The lazy fashion only makes sense if you use this value from another 'global'.</p>\n<p>On the other hand, another method I've seen was to use some kind of coordination:</p>\n<ul>\n<li>'Singleton' to be register their initialization method in a 'GlobalInitializer' object during library load time</li>\n<li>'GlobalInitializer' to be called in 'main' before any thread is launched</li>\n</ul>\n<p>though I may not be describing it accurately.</p>\n", "CreationDate": "2010-06-02T09:29:04.087", "ParentId": "2955921", "Id": "2956395", "LastActivityDate": "2010-06-02T09:29:04.087", "PostTypeId": "2", "Score": "0", "OwnerUserId": "147192"}, "3090741": {"CommentCount": "4", "Body": "<p>This is my second attempt at an answer. I'll only answer the first of your questions:</p>\n<blockquote id=\"so_2955921_3090741_0\">\n<ol>\n<li>safe enough in practice?</li>\n</ol>\n</blockquote>\n<p>No. As you're stating yourself you're only ensuring that the object creation is protected, not the initialization of the reference to the object.</p>\n<p>In absence of a C++98 memory model and no explicit statements from the compiler vendor, there are no guarantees that writing to the memory representing the actual reference and the writing to the memory that holds the value of the initialization flag (if that is how it is implemented) for the reference are seen in the same order from multiple threads.</p>\n<p>As you also say, overwriting the reference several times with the same value should make no semantic difference (even in the presence of word tearing, which is generally unlikely and perhaps even impossible on your processor architecture) but there's one case where it matters: <em>When more than one thread races to call the function for the first time during program execution</em>. In this case it is possible for one or more of these threads to see the initialization flag being set before the actual reference is initialized.</p>\n<p>You have a latent bug in your program and you need to fix it. As for optimizations I'm sure there are many besides using the double-checked locking pattern.</p>\n", "CreationDate": "2010-06-22T06:23:51.983", "ParentId": "2955921", "Id": "3090741", "LastActivityDate": "2010-06-22T06:23:51.983", "PostTypeId": "2", "Score": "13", "OwnerUserId": "81588"}, "2956314": {"CreationDate": "2010-06-02T09:14:00.303", "CommentCount": "3", "Body": "<p>Here is my take (if really you can't initialize it before threads are launched):</p>\n<p>I've seen (and used) something like this to protect static initialization, using boost::once</p>\n<pre><code>#include &lt;boost/thread/once.hpp&gt;\n\nboost::once_flag flag;\n\n// get thingy\nconst Thingy &amp; get()\n{\n    static Thingy thingy;\n\n    return thingy;\n}\n\n// create function\nvoid create()\n{\n     get();\n}\n\nvoid use()\n{\n    // Ensure only one thread get to create first before all other\n    boost::call_once( &amp;create, flag );\n\n    // get a constructed thingy\n    const Thingy &amp; thingy = get(); \n\n    // use it\n    thingy.etc..()          \n}\n</code></pre>\n<p>In my understanding, this way all threads wait on boost::call_once except one that will create the static variable. It will be created only once and then will never be called again. And then you have no lock any more.</p>\n", "Id": "2956314", "OwnerUserId": "329564", "LastEditDate": "2010-06-02T09:40:39.707", "ParentId": "2955921", "LastActivityDate": "2010-06-22T07:08:35.007", "PostTypeId": "2", "Score": "5", "LastEditorUserId": "329564"}, "11004074": {"CommentCount": "3", "Body": "<p>This seems to be the easiest/cleanest approach I can think of without needing all of the mutex shananigans:</p>\n<pre><code>static My_object My_object_instance()\n{\n    static My_object  object;\n    return object;\n}\n\n// Ensures that the instance is created before main starts and creates any threads\n// thereby guaranteeing serialization of static instance creation.\n__attribute__((constructor))\nvoid construct_my_object()\n{\n    My_object_instance();\n}\n</code></pre>\n", "CreationDate": "2012-06-12T20:10:50.687", "ParentId": "2955921", "Id": "11004074", "LastActivityDate": "2012-06-12T20:10:50.687", "PostTypeId": "2", "Score": "-1", "OwnerUserId": "888749"}, "bq_ids": {"n4140": {"so_2955921_3082613_0": {"length": 37, "quality": 0.8604651162790697, "section_id": 3919}}, "n3337": {"so_2955921_3082613_0": {"length": 37, "quality": 0.8604651162790697, "section_id": 3779}}}});