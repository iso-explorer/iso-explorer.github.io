post_cb({"32031589": {"ParentId": "32031406", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>According to C++14 (N3936) [basic.def.odr]/3:</p>\n<blockquote>\n<p id=\"so_32031406_32031589_0\">A virtual member function is odr-used if it is not pure.</p>\n</blockquote>\n<p>So <code>my_exc1::what()</code> and <code>my_exc2::what()</code> are <em>odr-used</em>, even though they are never called. Then we have [basic.def.odr]/4:</p>\n<blockquote>\n<p id=\"so_32031406_32031589_1\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required.</p>\n</blockquote>\n<p>So this whole program has undefined behaviour, but the compiler/linker is not required to diagnose it.</p>\n<p>The rationale for this lax requirement is to make a linker's job easier: if the linker happens to be able link without including a call to this function or whatever, then it can do so; the C++ standard does not require the linker to do some sort of whole program analysis to determine whether all <em>odr-used</em> functions have bodies.</p>\n<hr>\n<p>So this code is bugged and it should have bodies for both of those functions. It also should have <code>#include &lt;exception&gt;</code>.  For the people who compiled and executed this code; their <code>iostream</code> included <code>exception</code> (which is permitted but not required), and their linker manifested the undefined behaviour as appearing to link correctly.</p>\n<hr>\n<p>To provide a body it is as simple as:</p>\n<pre><code>char const *what() const throw() { return \"\"; }\n</code></pre>\n<p>(assuming you're fine doing it inline). Of course you could return some other fixed string such as <code>\"my_exc1\"</code>. Note that if you only want to return <code>\"\"</code> then you do not need to re-declare <code>what()</code> at all.</p>\n</hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2015-08-16T04:47:11.557", "Id": "32031589", "Score": "1", "CreationDate": "2015-08-16T03:42:29.233", "LastActivityDate": "2015-08-16T04:47:11.557"}, "32031406": {"CommentCount": "0", "ViewCount": "78", "CreationDate": "2015-08-16T03:02:35.967", "LastActivityDate": "2015-08-16T04:47:11.557", "Title": "Boost example code inheriting from std::exception doesn't link", "AcceptedAnswerId": "32031589", "PostTypeId": "1", "Id": "32031406", "Score": "2", "Body": "<p>This article from <a href=\"http://www.boost.org/community/error_handling.html\" rel=\"nofollow\">boost: Error and Exception Handling</a> puts forth the following program code:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct my_exc1 : std::exception {\n  char const* what() const throw();\n};\nstruct my_exc2 : std::exception {\n  char const* what() const throw();\n};\nstruct your_exc3 : my_exc1, my_exc2 {};\n\nint main() {\n  try {\n    throw your_exc3();\n  } catch(std::exception const&amp; e) {}\n  catch(...) {\n    std::cout &lt;&lt; \"whoops!\" &lt;&lt; std::endl;\n  }\n}\n</code></pre>\n<p>When compiling with g++ (GCC) 5.2.0, I get the following</p>\n<pre><code>&gt; g++ -std=c++11 custom_exception.cpp\n/tmp/ccmbzPOk.o: In function `my_exc1::my_exc1()':\ncustom_exception.cpp:(.text._ZN7my_exc1C2Ev[_ZN7my_exc1C5Ev]+0x19): undefined reference to `vtable for my_exc1'\n/tmp/ccmbzPOk.o: In function `my_exc1::~my_exc1()':\ncustom_exception.cpp:(.text._ZN7my_exc1D2Ev[_ZN7my_exc1D5Ev]+0xd): undefined reference to `vtable for my_exc1'\n/tmp/ccmbzPOk.o: In function `my_exc2::my_exc2()':\ncustom_exception.cpp:(.text._ZN7my_exc2C2Ev[_ZN7my_exc2C5Ev]+0x19): undefined reference to `vtable for my_exc2'\n/tmp/ccmbzPOk.o: In function `my_exc2::~my_exc2()':\ncustom_exception.cpp:(.text._ZN7my_exc2D2Ev[_ZN7my_exc2D5Ev]+0xd): undefined reference to `vtable for my_exc2'\n/tmp/ccmbzPOk.o:(.rodata._ZTV9your_exc3[_ZTV9your_exc3]+0x20): undefined reference to `my_exc1::what() const'\n/tmp/ccmbzPOk.o:(.rodata._ZTV9your_exc3[_ZTV9your_exc3]+0x48): undefined reference to `my_exc2::what() const'\n/tmp/ccmbzPOk.o:(.rodata._ZTI9your_exc3[_ZTI9your_exc3]+0x18): undefined reference to `typeinfo for my_exc1'\n/tmp/ccmbzPOk.o:(.rodata._ZTI9your_exc3[_ZTI9your_exc3]+0x28): undefined reference to `typeinfo for my_exc2'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>I have seen the identical technique used elsewhere, suggesting to me that this should compile (and link) silently. (As an example, I cite Anthony Williams <em>C++ Concurrency in Action</em> p. 45 where he inherits from <code>std::exception</code> to make <code>empty_stack</code> for the thread-safe stack example.)</p>\n<p>I have tried to <code>#include &lt;exception&gt;</code> and despite the fact that this isn't a C++ library problem, I even tried the <code>-lstdc++</code> flag on the advice of people with similar problems---out of desperation.</p>\n<p>I understand that in <code>std::exception</code>, <code>what()</code> is virtual, meaning I should define it---so I'm not sure why it should compile in the first place, but I'm frustrated that it apparently does for other people.</p>\n<p>My questions are two: (1) What is the problem, and why does it work for others? (2, conditionally) New to C++, I should also ask what is a good way to implement <code>what()</code> (assuming I will have to) in the most minimal way, since I don't actually want to pass a string with my exception. I don't need to inherit from deeper in the hierarchy, such as <code>std::runtime_error</code>.</p>\n", "Tags": "<c++><linker-errors><custom-exceptions>", "OwnerUserId": "1827360", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32031406_32031589_1": {"section_id": 7041, "quality": 1.0, "length": 12}, "so_32031406_32031589_0": {"section_id": 7040, "quality": 1.0, "length": 5}}, "n3337": {"so_32031406_32031589_1": {"section_id": 6786, "quality": 1.0, "length": 12}, "so_32031406_32031589_0": {"section_id": 6785, "quality": 1.0, "length": 5}}, "n4659": {"so_32031406_32031589_1": {"section_id": 8538, "quality": 1.0, "length": 12}, "so_32031406_32031589_0": {"section_id": 8537, "quality": 1.0, "length": 5}}}});