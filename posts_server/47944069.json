post_cb({"bq_ids": {"n4140": {"so_47944069_47944152_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_47944069_47944152_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}, "n3337": {"so_47944069_47944152_1": {"length": 29, "quality": 0.90625, "section_id": 28}, "so_47944069_47944152_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 29}}, "n4659": {"so_47944069_47944152_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_47944069_47944152_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}}, "47944069": {"ViewCount": "54", "Body": "<pre><code>   double d=0;\n   while(cin&gt;&gt;d){\n       int i=d;    \n       char c=i;   \n       int i2=c;  \n       cout&lt;&lt;\"d==\"&lt;&lt;d\n           &lt;&lt;\"i==\"&lt;&lt;i\n           &lt;&lt;\"i2==\"&lt;&lt;i2\n           &lt;&lt;\" char(\"&lt;&lt;c&lt;&lt;\")\\n\";\n}\n</code></pre>\n<p>I am reading Programming Principles and Practice Using C++ 2nd Edition. I am at Safe and Unsafe Conversions topic. The code given is an exercise, when ran, I input 1000, then it output</p>\n<pre><code>d==1000i==1000i2==-24 char(\u03a6)\n</code></pre>\n<p>i would like to know what the machine do when the int is too large for char to store like that 1000 became -24.</p>\n", "Title": "During int to char conversion where int is to large to be stored in char, what will be the values that will be stored in char if int is too large?", "CreationDate": "2017-12-22T15:44:55.433", "LastActivityDate": "2017-12-22T16:30:19.860", "CommentCount": "9", "PostTypeId": "1", "Id": "47944069", "Score": "0", "OwnerUserId": "7589208", "Tags": "<c++>", "AnswerCount": "1"}, "47944152": {"Id": "47944152", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47944069_47944152_0\">During int to char conversion where int is to large to be stored in char, what will be the values that will be stored in char</p>\n</blockquote>\n<p>It depends.</p>\n<p>In particular, it depends on whether <code>char</code> type is signed or unsigned. Whether <code>char</code> is signed, is implementation defined.</p>\n<p>If <code>char</code> is unsigned, then the resulting value is the smallest unsigned value equal to the source value modulo 2<sup>n</sup> where n is the number of bits in <code>char</code>.</p>\n<p>If <code>char</code> is signed, then the resulting value is implementation defined. Which means that the value can be any value representable by <code>char</code>. In <em>practice</em>, on systems that represent negative numbers as two's complement (and most processors do use two's complement), it is typical that the same modulo relation applies to signed types as well. But this is not guaranteed by the C++ standard.</p>\n<p>From this, we can deduce that <code>char</code> is signed on your system, because -24 is not representable by an unsigned type. -24 is indeed congruent with 1000 modulo 2<sup>8</sup></p>\n<hr>\n<p>Standard reference: <a href=\"http://eel.is/c++draft/conv.integral\" rel=\"nofollow noreferrer\">[conv.integral]</a></p>\n<blockquote>\n<p id=\"so_47944069_47944152_1\">2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2n where n is the number of bits used to represent the unsigned type).\n  [\u2009Note: In a two's complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation).\n  \u2014\u2009end note]</p>\n<p id=\"so_47944069_47944152_2\">3 If the destination type is signed, the value is unchanged if it can be represented in the destination type; otherwise, the value is implementation-defined.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2017-12-22T16:30:19.860", "Score": "5", "CreationDate": "2017-12-22T15:52:25.917", "ParentId": "47944069", "CommentCount": "3", "OwnerUserId": "2079303", "LastEditDate": "2017-12-22T16:30:19.860"}});