post_cb({"bq_ids": {"n4140": {"so_20421300_20421399_1": {"length": 26, "quality": 0.8125, "section_id": 37}}, "n3337": {"so_20421300_20421399_1": {"length": 26, "quality": 0.8125, "section_id": 34}}, "n4659": {"so_20421300_20421399_1": {"length": 24, "quality": 0.75, "section_id": 37}}}, "20421300": {"ViewCount": "161", "Body": "<p>Recently I had to perform some data type conversions from <code>float</code> to 16 bit integer. Essentially my code reduces to the following</p>\n<pre><code>float f_val = 99999.0;\nshort int si_val = static_cast&lt;short int&gt;(f_val);\n\n// si_val is now -32768\n</code></pre>\n<p>This input value was a problem and in my code I had neglected to check the limits of the float value so I can see my fault, but it made me wonder about the exact rules of the language when one has to do this kind of ungainly cast. I was slightly surprised to find that value of the cast was -32768. Furthermore, this is the value I get whenever the value of the float exceeds the limits of a 16 bit integer. I have googled this but found a surprising lack of detailed info about it. The best I could find was the following from cplusplus.com</p>\n<blockquote>\n<p id=\"so_20421300_20421300_0\">Converting to int from some smaller integer type, or to double from\n  float is known as promotion, and is guaranteed to produce the exact\n  same value in the destination type. Other conversions between\n  arithmetic types may not always be able to represent the same value\n  exactly:</p>\n<pre><code>If the conversion is from a floating-point type to an integer type, the value \nis truncated (the decimal part is removed).\nThe conversions from/to bool consider false equivalent to zero (for numeric \ntypes) and to null pointer (for pointer types); and true equivalent to all \nother values.\nOtherwise, when the destination type cannot represent the value, the conversion \nis valid between numerical types, but the value is\nimplementation-specific (and may not be portable).\n</code></pre>\n</blockquote>\n<p>This suggestion that the results are implementation defined does not surprise me, but I have heard that cplusplus.com is not always reliable. </p>\n<p>Finally, when performing the same cast from a 32 bit integer to 16 bit integer (again with a value outisde of 16 bit range) I saw results clearly indicating integer overflow. Although I was not surprised by this it has added to my confusion due to the inconsistency with the cast from <code>float</code> type.</p>\n<p>I have no access to the C++ standard, but a lot of C++ people here do so I was wondering what the standard says on this issue? Just for completeness, I am using g++ version 4.6.3. </p>\n", "AcceptedAnswerId": "20421399", "Title": "What does the C++ standard say about results of casting value of a type that lies outside the range of the target type?", "CreationDate": "2013-12-06T10:14:18.447", "Id": "20421300", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-12-06T10:19:11.710", "Score": "4", "OwnerUserId": "1342730", "Tags": "<c++><c++11><casting>", "AnswerCount": "1"}, "20421399": {"Id": "20421399", "PostTypeId": "2", "Body": "<p>You're right to question what you've read. The conversion has no defined behaviour, which contradicts what you quoted in your question.</p>\n<blockquote>\n<p id=\"so_20421300_20421399_0\"><strong>4.9 Floating-integral conversions [conv.fpint]</strong></p>\n<p id=\"so_20421300_20421399_1\">1 A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates;\n  that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be\n  represented in the destination type. [ <em>Note:</em> If the destination type is <code>bool</code>, see 4.12. -- <em>end note</em> ]</p>\n</blockquote>\n<p>One potentially useful permitted result that you might get is a crash.</p>\n", "LastActivityDate": "2013-12-06T10:19:11.710", "CommentCount": "4", "CreationDate": "2013-12-06T10:19:11.710", "ParentId": "20421300", "Score": "8", "OwnerUserId": "743382"}});