post_cb({"9570823": {"CommentCount": "16", "AcceptedAnswerId": "9570831", "PostTypeId": "1", "LastEditorUserId": "76722", "CreationDate": "2012-03-05T17:07:19.333", "LastActivityDate": "2012-07-23T15:17:15.187", "LastEditDate": "2012-03-05T17:38:34.203", "ViewCount": "1203", "FavoriteCount": "1", "Title": "\"missing return statement\", but I know it is there", "Id": "9570823", "Score": "3", "Body": "<p>Assume I have the following function:</p>\n<pre><code>// Precondition:  foo is '0' or 'MAGIC_NUMBER_4711'\n// Returns:       -1 if foo is '0'\n//                 1 if foo is 'MAGIC_NUMBER_4711'\nint transmogrify(int foo) {\n    if (foo == 0) {\n        return -1;\n    } else if (foo == MAGIC_NUMBER_4711) {\n        return 1;\n    }\n}\n</code></pre>\n<p>The compiler complains \"missing return statement\", but I know that <code>foo</code> never has different values than <code>0</code> or <code>MAGIC_NUMBER_4711</code>, or else my function shall have no defined semantics. </p>\n<p>What are preferable solutions to this? \nIs this really an issue, i.e. what does the standard say?</p>\n", "Tags": "<c++>", "OwnerUserId": "76722", "AnswerCount": "4"}, "9572028": {"ParentId": "9570823", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Just because you can tell that the input will only have one of two values doesn't mean the compiler can, so it's expected that it will generate such a warning.</p>\n<p>You have a couple options for helping the compiler figure this out.</p>\n<ul>\n<li><p>You could use an enumerated type for which the two values are the only valid enumerated values. Then the compiler can tell immediately that one of the two branches has to execute and there's no missing return.</p></li>\n<li><p>You could <code>abort</code> at the end of the function.</p></li>\n<li><p>You could <code>throw</code> an appropriate exception at the end of the function.</p></li>\n</ul>\n<p>Note that the latter two options are better than silencing the warning because it predictably shows you when the pre-conditions are violated rather than allowing undefined behavior. Since the function takes an <code>int</code> and not a class or enumerated type, it's only a matter of time before someone calls it with a value other than the two allowed values and you want to catch those as early in the development cycle as possible rather than pushing them off as undefined behavior because it violated the function's requirements.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2012-03-06T14:33:36.567", "Id": "9572028", "Score": "2", "CreationDate": "2012-03-05T18:39:37.010", "LastActivityDate": "2012-03-06T14:33:36.567"}, "9570905": {"ParentId": "9570823", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In C89 and in C99, the return statement is never required. Even if it is a function that has a return different than <code>void</code>.</p>\n<p>C99 only says:</p>\n<blockquote>\n<p id=\"so_9570823_9570905_0\">(C99, 6.9.1p12 \"If the } that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.\"</p>\n</blockquote>\n<p>In C++11, the Standard says:</p>\n<blockquote>\n<p id=\"so_9570823_9570905_1\">(C++11, 6.6.3p2) \"Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function\"</p>\n</blockquote>\n", "OwnerUserId": "1119701", "LastEditorUserId": "1119701", "LastEditDate": "2012-03-05T17:18:46.373", "Id": "9570905", "Score": "2", "CreationDate": "2012-03-05T17:13:15.470", "LastActivityDate": "2012-03-05T17:18:46.373"}, "9570831": {"ParentId": "9570823", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Sometimes, your compiler is not able to deduce that your function actually has <em>no</em> missing return. In such cases, several solutions exist:</p>\n<p>Assume the following simplified code (though modern compilers will see that there is no path leak, just exemplary):</p>\n<pre><code>if (foo == 0) {\n    return bar;\n} else {\n    return frob;\n}\n</code></pre>\n<h2>Restructure your code</h2>\n<pre><code>if (foo == 0) {\n    return bar;\n}\nreturn frob;\n</code></pre>\n<p>This works good if you can interpret the if-statement as a kind of firewall or precondition.</p>\n<h2>abort()</h2>\n<pre><code>if (foo == 0) {\n    return bar;\n} else {\n    return frob;\n}\nabort(); return -1; // unreachable\n</code></pre>\n<p>Return something else accordingly. The comment tells fellow programmers and yourself why this is there.</p>\n<h2>throw</h2>\n<pre><code>#include &lt;stdexcept&gt;\n\nif (foo == 0) {\n    return bar;\n} else {\n    return frob;\n}\n\nthrow std::runtime_error (\"impossible\");\n</code></pre>\n<h2>Disadvantages of Single Function Exit Point</h2>\n<h3>flow of control control</h3>\n<p>Some fall back to <a href=\"http://c2.com/cgi/wiki?SingleFunctionExitPoint\" rel=\"nofollow\">one-return-per-function a.k.a. single-function-exit-point</a> as a workaround. This might be seen as obsolete in C++ because you almost never know where the function will really exit:</p>\n<pre><code>void foo(int&amp;);\n\nint bar () {\n    int ret = -1;\n    foo (ret);\n    return ret;\n}\n</code></pre>\n<p>Looks nice and looks like SFEP, but reverse engineering the 3rd party proprietary <code>libfoo</code> reveals:</p>\n<pre><code>void foo (int &amp;) {\n    if (rand()%2) throw \":P\";\n}\n</code></pre>\n<p>This argument does not hold true if <code>bar()</code> is <code>nothrow</code> and so can only call <code>nothrow</code> functions.</p>\n<h3>complexity</h3>\n<p>Every mutable variable increases the complexity of your code and puts a higher burden on the cerebral capacity on your code's maintainer. It means more code and more state to test and verify, in turn means that you suck off more state from the maintainers brain, in turn means less maintainer's brain capacity left for the important stuff.</p>\n<h3>missing default constructor</h3>\n<p>Some classes have no default construction and you would have to write really bogus code, if possible at all:</p>\n<pre><code>File mogrify() {\n    File f (\"/dev/random\"); // need bogus init because it requires readable stream\n    ...\n}\n</code></pre>\n<p>That's quite a hack just to get it declared.</p>\n", "OwnerUserId": "76722", "LastEditorUserId": "76722", "LastEditDate": "2012-07-23T15:17:15.187", "Id": "9570831", "Score": "9", "CreationDate": "2012-03-05T17:07:52.487", "LastActivityDate": "2012-07-23T15:17:15.187"}, "10784272": {"ParentId": "9570823", "CommentCount": "1", "Body": "<p>Actually the compiler is doing exactly what it should.</p>\n<pre><code>int transmogrify(int foo) {\n    if (foo == 0) {\n        return -1;\n    } else if (foo == MAGIC_NUMBER_4711) {\n        return 1;\n    }\n    // you know you shouldn't get here, but the compiler has\n    // NO WAY of knowing that.  In addition, you are putting\n    // great potential for the caller to create a nice bug.\n    // Why don't you catch the error using an ELSE clause?\n    else {\n        error( \"transmorgify had invalid value %d\", foo ) ;\n        return 0 ;\n    } \n}\n</code></pre>\n", "OwnerUserId": "111307", "PostTypeId": "2", "Id": "10784272", "Score": "0", "CreationDate": "2012-05-28T11:55:48.770", "LastActivityDate": "2012-05-28T11:55:48.770"}, "bq_ids": {"n4140": {"so_9570823_9570905_1": {"section_id": 3913, "quality": 0.8571428571428571, "length": 12}, "so_9570823_9570905_0": {"section_id": 7182, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_9570823_9570905_1": {"section_id": 3773, "quality": 0.8571428571428571, "length": 12}, "so_9570823_9570905_0": {"section_id": 6926, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_9570823_9570905_1": {"section_id": 4799, "quality": 0.6428571428571429, "length": 9}, "so_9570823_9570905_0": {"section_id": 3923, "quality": 0.5454545454545454, "length": 6}}}});