post_cb({"33847735": {"ParentId": "33847651", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes, if the compiler can determine that the cast will always succeed, then it will omit the runtime check. And in your case, since the cast is trivial it cannot fail.</p>\n<p>If the types are the same no conversion is done at all. In C++ standard, 5.2.7:</p>\n<blockquote>\n<p id=\"so_33847651_33847735_0\"><code>dynamic_cast&lt;T&gt;(v)</code></p>\n<p id=\"so_33847651_33847735_1\">If the type of v is the same as T, or it is the same as T except that the class object type in T is more  cv-qualified than the class object type in v, the result is v (converted if necessary)</p>\n</blockquote>\n<p>And if the type to be convertred to is a pointer or reference to a subclass, no runtime check either:</p>\n<blockquote>\n<p id=\"so_33847651_33847735_2\">If T is \u201cpointer to cv1 B\u201d and v has type \u201cpointer to cv2 D\u201d such that B is a base class of D, the result is a pointer to the unique B subobject of the D object pointed to by v.</p>\n</blockquote>\n<p>That you have written a template and not simple code does not change the optimization decisions. Your code is equivalent to this one:</p>\n<pre><code>struct S {};\nS *foo(S *a)\n{\n    return dynamic_cast&lt;S*&gt;(a);\n}\n</code></pre>\n<p>That with basic optimizations (<code>g++ -O1</code>) will compile identically to:</p>\n<pre><code>S *foo2(S *a)\n{\n    return a;\n}\n</code></pre>\n", "OwnerUserId": "865874", "LastEditorUserId": "865874", "LastEditDate": "2015-11-21T19:53:01.860", "Id": "33847735", "Score": "4", "CreationDate": "2015-11-21T19:37:06.823", "LastActivityDate": "2015-11-21T19:53:01.860"}, "33847651": {"CommentCount": "5", "AcceptedAnswerId": "33847735", "CreationDate": "2015-11-21T19:30:27.090", "LastActivityDate": "2015-11-21T19:53:01.860", "PostTypeId": "1", "ViewCount": "88", "FavoriteCount": "1", "Title": "Does the compiler eliminate unnecessary `dynamic_cast`s?", "Id": "33847651", "Score": "2", "Body": "<p>I am writing a heavy-templatized application. Somewhere inside it, there is some code like that:</p>\n<pre><code>class TA {  };\n\nclass TX {\n\npublic:\n\n    template &lt;typename T&gt;\n    T &amp;Foo(int a) {\n        TA *pta;\n        // here somehow initialize pta\n        return *(dynamic_cast&lt;T*&gt;(pta));\n    }\n\n};\n</code></pre>\n<p>If I call <code>Foo</code> template member function with <code>T = TA</code>, will the dynamic cast <code>dynamic_cast&lt;TA*&gt;(pta)</code> [where <code>pta</code> is of type <code>TA*</code>] eliminated or optimized by the compiler? Or should I make some <code>type_traits</code> magic to eliminate it manually?</p>\n", "Tags": "<c++>", "OwnerUserId": "2604712", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33847651_33847735_1": {"section_id": 6013, "quality": 1.0, "length": 16}, "so_33847651_33847735_2": {"section_id": 6015, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_33847651_33847735_1": {"section_id": 5781, "quality": 1.0, "length": 16}, "so_33847651_33847735_2": {"section_id": 5783, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_33847651_33847735_1": {"section_id": 7512, "quality": 1.0, "length": 16}, "so_33847651_33847735_2": {"section_id": 7514, "quality": 0.8571428571428571, "length": 12}}}});