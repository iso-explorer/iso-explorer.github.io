post_cb({"13097367": {"ParentId": "13097167", "CommentCount": "0", "Body": "<p>Unfortunately this is not possible, the C standard says:</p>\n<blockquote>\n<p id=\"so_13097167_13097367_0\">A function may be called with a variable number of arguments of varying types. As\n  described in 6.9.1, its parameter list contains one or more parameters.</p>\n</blockquote>\n<p>And the <code>...</code> doesn't count as the \"one or more parameters\". Further,</p>\n<blockquote>\n<p id=\"so_13097167_13097367_1\">The <code>va_start</code> macro shall be invoked before any access to the unnamed arguments.</p>\n</blockquote>\n<p>That it should be called like</p>\n<pre><code>va_start(va_list, parmN)\n</code></pre>\n<p>And that</p>\n<blockquote>\n<p id=\"so_13097167_13097367_2\">The parameter <code>parmN</code> is the identifier of the rightmost parameter in the variable\n  parameter list in the function definition (the one just before the <code>, ...</code>).</p>\n</blockquote>\n<p>So as you can see, you cannot have a variadic function without at least one parameter before the ellipsis in standard C++. The non-portable assembly trick is the closest you can come.</p>\n", "OwnerUserId": "726361", "PostTypeId": "2", "Id": "13097367", "Score": "2", "CreationDate": "2012-10-27T04:55:35.760", "LastActivityDate": "2012-10-27T04:55:35.760"}, "13097167": {"CommentCount": "11", "AcceptedAnswerId": "13097367", "PostTypeId": "1", "LastEditorUserId": "3366929", "CreationDate": "2012-10-27T04:10:51.317", "LastActivityDate": "2014-08-30T20:07:42.487", "LastEditDate": "2014-08-30T20:07:42.487", "ViewCount": "601", "FavoriteCount": "1", "Title": "Getting ellipses function parameters without an initial argument", "Id": "13097167", "Score": "2", "Body": "<p>So I've been making a custom parser for a scripting language, and I wanted to be able to pass only ellipses arguments. I don't need or want an initial variable, however Microsoft and C seem to want something else. FYI, see bottom for info.</p>\n<p>I've looked at the va_* definitions</p>\n<pre><code>#define _crt_va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )\n#define _crt_va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )\n#define _crt_va_end(ap)      ( ap = (va_list)0 )\n</code></pre>\n<p>and the part I don't want is the v in va_start. As a little background I'm competent in goasm and I know how the stack works so I know what's happening here. I was wondering if there is a way to get the function stack base without having to use inline assembly.</p>\n<p>Ideas I've had:</p>\n<pre><code>#define im_va_start(ap) (__asm { mov [ap], ebp })\n</code></pre>\n<p>and etc... but really I feel like that's messy and I'm doing it wrong.</p>\n<pre><code>struct function_table {\n    const char* fname;\n    (void)(*fptr)(...);\n    unsigned char maxArgs;\n};\nfunction_table mytable[] = {\n{ \"MessageBox\", &amp;tMessageBoxA, 4 } };\n</code></pre>\n<p>... some function that sorts through a const char* passed to it to find the matching function in mytable and calls tMessageBoxA with the params. Also, the maxArgs argument is just so I can check that a valid number of parameters is being sent. I have personal reasons for not wanting to send it in the function, but in the meantime we can just say it's because I'm curious.</p>\n<p>This is just an example; custom libraries are what I would be implementing so it wouldn't just be calling WinAPI stuff.</p>\n<pre><code>void tMessageBoxA(...) {\n// stuff to load args passed\nMessageBoxA(arg1, arg2, arg3, arg4);\n}\n</code></pre>\n<p>I'm using the __cdecl calling convention and I've looked up ways to reliably get a pointer to the base of the stack (not the top) but I can't seem to find any. Also, I'm not worried about function security or typechecking.</p>\n<hr>\n<p>edit: Thanks for input, it appears it wasn't possible.</p>\n<p>My fix has ended up being</p>\n<pre><code>    #define im_va_start(ap) {\\\n        __asm push eax\\\n        __asm mov eax, ebp\\\n        __asm add eax, 8h\\\n        __asm mov ap, eax\\\n        __asm pop eax\\\n    }\n</code></pre>\n<p>And then I can continue as normal. </p>\n<p>As for why I require it, I'm doing some (unique) read: unsafe tricks and using a struct array with a pointer to the function as defined above. Since each function is unique, and most are from my custom library, they have... different behaviors. I don't really know how to explain it, but I'll release the source when I finish the POC.</p>\n<p>I'm not really worried about portability so that'll have to work. Also, for counting the args I did: </p>\n<pre><code>#define im_va_count(ap, num, t) {\\\nfor(num = 0; *(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) &gt; 0; ++num){ }\\\n--num;\\\nim_va_start(argptr);\\\n}\n</code></pre>\n<p>which works for me. If anyone's interested...</p>\n</hr>", "Tags": "<c++><parsing><variadic-functions>", "OwnerUserId": "1270680", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13097167_13097367_2": {"section_id": 6966, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_13097167_13097367_2": {"section_id": 6713, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_13097167_13097367_2": {"section_id": 8465, "quality": 0.8571428571428571, "length": 12}}}});