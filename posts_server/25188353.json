post_cb({"25189247": {"Id": "25189247", "PostTypeId": "2", "Body": "<p>The call to <code>f_helper(typename T::tag_type{});</code> is dependent on the template parameter <code>T</code>, so the name <code>f_helper</code> need not be visible until the point of instantiation of <code>f&lt;T&gt;</code> (due to two phase name lookup).</p>\n<p>I believe the code works because implementations are allowed to delay the point of instantiation of function templates until the end of the translation unit, at which time the definitions for <code>f_helper</code> are available.</p>\n<p>N3936 <em>\u00a714.6.4.1/8 [temp.point]</em></p>\n<blockquote>\n<p id=\"so_25188353_25189247_0\">A specialization for a function template, a member function template, or of a member function or static data member of a class template may have multiple points of instantiations within a translation unit, and in addition to the points of instantiation described above, <strong>for any such specialization that has a point of instantiation within the translation unit, the end of the translation unit is also considered a point of instantiation</strong>. A specialization for a class template has at most one point of instantiation within a translation unit. A specialization for any template may have points of instantiation in multiple translation units. If two different points of instantiation give a template specialization different meanings according to the one\n  definition rule (3.2), the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n", "LastActivityDate": "2014-08-07T18:08:35.793", "CommentCount": "9", "CreationDate": "2014-08-07T18:08:35.793", "ParentId": "25188353", "Score": "3", "OwnerUserId": "241631"}, "bq_ids": {"n4140": {"so_25188353_25188640_7": {"length": 12, "quality": 0.6666666666666666, "section_id": 224}, "so_25188353_25188640_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 188}, "so_25188353_25188521_3": {"length": 37, "quality": 0.9487179487179487, "section_id": 224}, "so_25188353_25188640_5": {"length": 19, "quality": 0.95, "section_id": 222}, "so_25188353_25189247_0": {"length": 74, "quality": 1.0, "section_id": 223}, "so_25188353_25188521_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 224}, "so_25188353_25188640_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 215}, "so_25188353_25188640_3": {"length": 5, "quality": 1.0, "section_id": 215}, "so_25188353_25188640_6": {"length": 10, "quality": 0.5882352941176471, "section_id": 224}, "so_25188353_25188521_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 224}, "so_25188353_25188640_2": {"length": 6, "quality": 1.0, "section_id": 215}, "so_25188353_25188521_1": {"length": 12, "quality": 0.6666666666666666, "section_id": 224}, "so_25188353_25188640_8": {"length": 16, "quality": 0.8888888888888888, "section_id": 224}}, "n3337": {"so_25188353_25188640_7": {"length": 15, "quality": 0.8333333333333334, "section_id": 217}, "so_25188353_25188640_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 182}, "so_25188353_25188521_3": {"length": 39, "quality": 1.0, "section_id": 217}, "so_25188353_25188640_5": {"length": 19, "quality": 0.95, "section_id": 215}, "so_25188353_25189247_0": {"length": 74, "quality": 1.0, "section_id": 216}, "so_25188353_25188521_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 217}, "so_25188353_25188640_6": {"length": 13, "quality": 0.7647058823529411, "section_id": 217}, "so_25188353_25188640_3": {"length": 5, "quality": 1.0, "section_id": 209}, "so_25188353_25188640_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 209}, "so_25188353_25188521_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 217}, "so_25188353_25188640_8": {"length": 16, "quality": 0.8888888888888888, "section_id": 217}, "so_25188353_25188521_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 217}, "so_25188353_25188640_2": {"length": 6, "quality": 1.0, "section_id": 209}}, "n4659": {"so_25188353_25188640_7": {"length": 12, "quality": 0.6666666666666666, "section_id": 232}, "so_25188353_25188640_1": {"length": 27, "quality": 0.7714285714285715, "section_id": 193}, "so_25188353_25188521_3": {"length": 37, "quality": 0.9487179487179487, "section_id": 232}, "so_25188353_25188640_5": {"length": 19, "quality": 0.95, "section_id": 230}, "so_25188353_25189247_0": {"length": 72, "quality": 0.972972972972973, "section_id": 231}, "so_25188353_25188521_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 232}, "so_25188353_25188640_6": {"length": 10, "quality": 0.5882352941176471, "section_id": 232}, "so_25188353_25188640_3": {"length": 5, "quality": 1.0, "section_id": 223}, "so_25188353_25188640_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 223}, "so_25188353_25188521_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 232}, "so_25188353_25188640_8": {"length": 16, "quality": 0.8888888888888888, "section_id": 232}, "so_25188353_25188521_1": {"length": 12, "quality": 0.6666666666666666, "section_id": 232}, "so_25188353_25188640_2": {"length": 6, "quality": 1.0, "section_id": 223}}}, "25188353": {"ViewCount": "479", "Body": "<p>I am playing a bit with static polymorphism, I'm calling a function which internally calls the \"right\" specialized function depending on the type of the initial argument (basically I'm doing tagging). Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// tags\nstruct tag1{}; \nstruct tag2{}; \n\n// the compliant types, all should typedef tag_type\nstruct my_type1\n{\n    using tag_type = tag1;\n};\nstruct my_type2\n{\n    using tag_type = tag2;\n};\n\n// static dispatch via tagging\ntemplate &lt;typename T&gt;\nvoid f(T) \n{\n    cout &lt;&lt; \"In void f&lt;typename T&gt;(T)\" &lt;&lt; endl;\n\n    // why can I call f_helper without forward definition?!?        \n    f_helper(typename T::tag_type{}); \n}\n\nint main()\n{\n    my_type1 type1;\n    my_type2 type2;\n\n    // how does f below knows about f_helper ?!?!\n    // even after instantiation f_helper shouldn't be visible!\n\n    f(type1); \n    f(type2);\n}\n\n// helper functions\nvoid f_helper(tag1) \n{\n    cout &lt;&lt; \"f called with my_type1\" &lt;&lt; endl;\n}\nvoid f_helper(tag2)\n{\n    cout &lt;&lt; \"f called with my_type2\" &lt;&lt; endl;\n}\n</code></pre>\n<p>So, <code>f(T)</code> is called with a parameter <code>my_type1</code> or <code>my_type2</code> that internally must typedef <code>tag_type</code> with the appropriate tag <code>tag1</code>/<code>tag2</code>. Depending on this internal <code>tag_type</code>, the \"right\" wrapper is then called, and this decision is made of course at compile time. Now I really don't understand why this code IS working? Why don't we need to forward-declare <code>f_helper</code>? I first had the wrappers defined before <code>main</code> (and after <code>f</code>), and I though ok, this makes sense, you don't need to forward declare because the compiler instantiate the template only when <code>f(type1);</code> is called (in <code>main()</code>), before it doesn't know the type <code>T</code>, so at the time of instantiation the compiler knows <code>f_wrapper</code>. </p>\n<p>But as you see, even if I declare the wrappers AFTER <code>main()</code>, the code still works. Why is this happening? I guess the question is a bit strange, asking why a code works :)</p>\n<hr>\n<p><strong>EDIT</strong></p>\n<p>The code continues to compile even in gcc5 and gcc HEAD 6.0.0.</p>\n</hr>", "AcceptedAnswerId": "25188521", "Title": "why no need of forward declaration in static dispatching via templates?", "CreationDate": "2014-08-07T17:10:23.517", "Id": "25188353", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-04-25T00:50:59.177", "LastEditorUserId": "3093378", "LastActivityDate": "2015-04-25T00:50:59.177", "Score": "15", "OwnerUserId": "3093378", "Tags": "<c++><templates><static-polymorphism>", "AnswerCount": "3"}, "25188521": {"Id": "25188521", "PostTypeId": "2", "Body": "<p><code>f_helper(typename T::tag_type{})</code> is a type-dependent expression because <code>T::tag_type</code> is a dependent type. This means that <code>f_helper</code> doesn't need to be visible until <code>f&lt;T&gt;</code> is instantiated due to two phase lookup.</p>\n<p>EDIT: I'm pretty sure that this is actually undefined behaviour. If we look at 14.6.4.2 [temp.dep.candidate] we see this passage:</p>\n<blockquote>\n<p id=\"so_25188353_25188521_0\">For a function call that depends on a template parameter, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2, 3.4.3) except that:</p>\n<p id=\"so_25188353_25188521_1\">\u2014 For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only\n  function declarations from the template definition context are found.</p>\n<p id=\"so_25188353_25188521_2\">\u2014 For the part of the lookup using associated namespaces (3.4.2), only\n  function declarations found in either the template definition context\n  or the template instantiation context are found.</p>\n<p id=\"so_25188353_25188521_3\">If the function name\n  is an unqualified-id and the call would be ill-formed or would find a\n  better match had the lookup within the associated namespaces\n  considered all the function declarations with external linkage\n  introduced in those namespaces in all translation units, not just\n  considering those declarations found in the template definition and\n  template instantiation contexts, then the program has undefined\n  behavior.</p>\n</blockquote>\n<p>The last paragraph to me indicates this is undefined behaviour. The <code>function call that depends on a template parameter</code> here is <code>f_helper(typename T::tag_type{})</code>. <code>f_helper</code> isn't visible when <code>f</code> is instantiated, but it would be if we performed name lookup after all translation units have been compiled.</p>\n", "LastEditorUserId": "2491746", "LastActivityDate": "2014-08-07T17:43:57.167", "Score": "9", "CreationDate": "2014-08-07T17:21:26.680", "ParentId": "25188353", "CommentCount": "9", "OwnerUserId": "2491746", "LastEditDate": "2014-08-07T17:43:57.167"}, "25188640": {"Id": "25188640", "PostTypeId": "2", "Body": "<p>I agree, the code is ill-formed.  I'm surprised neither g++ nor clang++ has even a warning about this.</p>\n<p>14.6.2/1:</p>\n<blockquote>\n<p id=\"so_25188353_25188640_0\">In an expression of the form:</p>\n<ul>\n<li><em>postfix-expression</em> <code>(</code> <em>expression-list</em> [<em>opt</em>] <code>)</code></li>\n</ul>\n<p id=\"so_25188353_25188640_1\">where the <em>postfix-expression</em> is an <em>id-expression</em>, the <em>id-expression</em> denotes a <em>dependent name</em> if any of the expressions in the <em>expression-list</em> is a type-dependent expression (14.6.2.2) or if the <em>unqualified-id</em> of the <em>id-expression</em> is a <em>template-id</em> in which any of the template arguments depends on a template parameter.  ...  Such names are unbound and are looked up at the point of the template instantiation (14.6.4.1) in both the context of the template definition and the context of the point of instantiation.</p>\n</blockquote>\n<p>[<code>f_helper</code> is a <em>postfix-expression</em> and <em>id-expression</em>, and <code>typename T::tag_type{}</code> is type-dependent, so <code>f_helper</code> is a dependent name.]</p>\n<p>14.6.4/1:</p>\n<blockquote>\n<p id=\"so_25188353_25188640_2\">In resolving dependent names, names from the following sources are considered:</p>\n<ul>\n<li><p id=\"so_25188353_25188640_3\">Declarations that are visible at the point of definition of the template.</p></li>\n<li><p id=\"so_25188353_25188640_4\">Declarations from namespaces associated with the types of the function arguments both from the instantiation context (14.6.4.1) and from the definition context.</p></li>\n</ul>\n</blockquote>\n<p>14.6.4.1/6:</p>\n<blockquote>\n<p id=\"so_25188353_25188640_5\">The instantiation context of an expression that depends on the template arguments is the set of declarations with external linkage declared prior to the point of instantiation of the template specialization in the same translation unit.</p>\n</blockquote>\n<p>14.6.4.2/1:</p>\n<blockquote>\n<p id=\"so_25188353_25188640_6\">For a function call that depends on a template parameter, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2, 3.4.3) except that:</p>\n<ul>\n<li><p id=\"so_25188353_25188640_7\">For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only function declarations from the template definition context are found.</p></li>\n<li><p id=\"so_25188353_25188640_8\">For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</p></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "459640", "LastActivityDate": "2014-08-07T17:56:41.973", "Score": "4", "CreationDate": "2014-08-07T17:29:54.523", "ParentId": "25188353", "CommentCount": "4", "OwnerUserId": "459640", "LastEditDate": "2014-08-07T17:56:41.973"}});