post_cb({"32238645": {"CommentCount": "2", "ViewCount": "30", "CreationDate": "2015-08-27T00:08:00.320", "LastActivityDate": "2015-08-27T01:04:58.977", "Title": "MSVC++ 2013 seems to allow assignments to temporary objects, effectively treating them as lvalues", "AcceptedAnswerId": "32239072", "PostTypeId": "1", "Id": "32238645", "Score": "0", "Body": "<p>I've come across this \"feature\" in MSVC++ and I'm now not sure if it's a bug or my understanding of lvalues/rvalues in C++ is just plain wrong.</p>\n<p>I've added some seriously dumbed-down code to illustrate, but basically the issue is that MSVC++ 2013 (both base and NOV 2013 CTP compilers) allows assignment to temporary objects, which should really be rvalues and hence disallow any assignment attempts at compile time.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct account {\n    int value;\n\n    explicit account(int v) : value{ v } { \n        std::cout &lt;&lt; \"account ctor: \" &lt;&lt; value &lt;&lt; std::endl; \n    }\n    account(const account &amp; acc) : value{ acc.value } { \n        std::cout &lt;&lt; \"account copy ctor\" &lt;&lt; std::endl; \n    }\n    account(account &amp;&amp; acc) : value{ acc.value } { \n        std::cout &lt;&lt; \"account move ctor\" &lt;&lt; std::endl; \n    }\n    account &amp; operator=(const account &amp; acc) {\n        value = acc.value;\n        std::cout &lt;&lt; \"account copy assign\" &lt;&lt; std::endl;\n        return *this;\n    }\n    account &amp; operator=(account &amp;&amp; acc) {\n        value = acc.value;\n        std::cout &lt;&lt; \"account move assign\" &lt;&lt; std::endl;\n        return *this;\n    }   \n};\n\nint get_int() { return 42; }\n\naccount get_account() {\n    return account(123);\n}\n\nint main() {\n    //get_int() = 5;    // this predictably fails to compile\n                        // with '=' : left operand must be l-value\n\n    // everything below succeeds\n    get_account() = account(42);    // console trace for this \n                                    // account ctor: 42\n                                    // account ctor: 123\n                                    // account move assign\n\n    account(123) = account(42);     // console trace same as above\n\n    account acc(0);                 // account ctor: 0\n    account(42) = acc;              // account ctor: 42\n                                    // account copy assign\n\n    get_account() = acc;            // console trace same as above\n}\n</code></pre>\n<p>Surely <code>get_account() = acc;</code> or <code>account(42) = acc;</code> is not C++ Standard's prescribed behaviour?! Both <code>get_account()</code> &amp; <code>account(42)</code> should result in rvalues, which by definition do not allow assignments.</p>\n<p>Incidentally, overloading member functions based on lvalue/rvalue qualifiers</p>\n<pre><code>...\nvoid memberFn() const &amp;;\nvoid memberFn() &amp;&amp;;\n...\n</code></pre>\n<p>which is supported in NOV 2013 CTP is not working properly or at all. I assume this is a result of failing to recognise rvalues, so that <code>this</code> is always an lvalue.</p>\n<p>PS Unfortunately, I do not have an opportunity to test this with other compilers.</p>\n", "Tags": "<c++11><visual-studio-2013><rvalue-reference><lvalue>", "OwnerUserId": "3726713", "AnswerCount": "1"}, "32239072": {"ParentId": "32238645", "CommentCount": "1", "Body": "<p>According to my understanding, this is perfectly valid C++11.</p>\n<p>Only <strong>built-in assignment</strong> to prvalues is prohibited.</p>\n<p>From [5, expr]:</p>\n<blockquote>\n<p id=\"so_32238645_32239072_0\">Note: Operators can be overloaded, that is, given meaning when applied to expressions of class type (Clause\n  9) or enumeration type (7.2). Uses of overloaded operators are transformed into function calls as described\n  in 13.5. Overloaded operators obey the rules for syntax specified in Clause 5, but the requirements of\n  operand type, <strong>value category</strong>, and evaluation order are replaced by the rules for function call.</p>\n</blockquote>\n<p>So the requirements on</p>\n<pre><code>get_account() = account(42);\n</code></pre>\n<p>are the same as on any other member-function call</p>\n<pre><code>get_account().foo_bar(account(42));\n</code></pre>\n<p>which makes sense since it is just a nicer syntax for</p>\n<pre><code>get_account().operator=(account(42));\n</code></pre>\n<p>The section 3.10 on Lvalues and rvalues makes this as clear well [basic.lval]:</p>\n<blockquote>\n<p id=\"so_32238645_32239072_1\">For example, the built-in assignment operators expect that the left operand is an lvalue and that the right operand is a prvalue and yield an lvalue as the result. User-defined operators are functions, and the categories of values they expect and yield are determined by their parameter and return\n  types.</p>\n</blockquote>\n", "OwnerUserId": "1743220", "PostTypeId": "2", "Id": "32239072", "Score": "1", "CreationDate": "2015-08-27T01:04:58.977", "LastActivityDate": "2015-08-27T01:04:58.977"}, "bq_ids": {"n4140": {"so_32238645_32239072_0": {"section_id": 5935, "quality": 0.9047619047619048, "length": 38}, "so_32238645_32239072_1": {"section_id": 7230, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_32238645_32239072_0": {"section_id": 5707, "quality": 0.9047619047619048, "length": 38}, "so_32238645_32239072_1": {"section_id": 6974, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_32238645_32239072_0": {"section_id": 7419, "quality": 0.8571428571428571, "length": 36}, "so_32238645_32239072_1": {"section_id": 8741, "quality": 0.9642857142857143, "length": 27}}}});