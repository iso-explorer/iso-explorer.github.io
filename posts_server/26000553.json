post_cb({"26000553": {"CommentCount": "0", "ViewCount": "141", "PostTypeId": "1", "LastEditorUserId": "1639256", "CreationDate": "2014-09-23T16:52:05.560", "LastActivityDate": "2014-09-23T18:15:37.630", "Title": "How should ADL work for this?", "AcceptedAnswerId": "26001996", "LastEditDate": "2014-09-23T17:14:54.697", "Id": "26000553", "Score": "2", "Body": "<p><br>\nRecently I came over an issue with clang++ 5.0.0 compiler where via ADL it was not picking up the correct function on Mac (but g++ did it correctly on Linux). I would like to know whether its a compiler issue OR poor class design in general. <br>\nHere is an example code (purely for illustration purpose): <br/></br></br></p>\n<pre><code>namespace test {\n    class Ops {\n      public:\n        Ops():val_(0){}\n        template&lt;typename T&gt;\n        Ops&amp; operator&lt;&lt; (const T&amp; val) {\n            std::cout &lt;&lt; \"Called member function\" &lt;&lt; std::endl;\n            this-&gt;val_ = val;\n            return *this;\n        }\n      private:\n        int val_;\n    };\n\n    template&lt;typename T&gt;\n    struct Any {\n        T val_;\n    };\n\n    template &lt;template&lt;typename&gt; class E,  typename T&gt;\n    Ops&amp; operator&lt;&lt; (Ops&amp; op, const E&lt;T&gt;&amp; val) {\n        std::cout &lt;&lt; \"Global function\" &lt;&lt; std::endl;\n        return op;\n    }\n}\n\nint main() {\n    test::Ops op;\n    int k = 9;\n    test::Any&lt;int&gt; a;\n    op &lt;&lt; a;\n\n    return 0;\n}\n</code></pre>\n<p>I would like to know how ADL and template argument deduction wouldwork in step wise manner to find the best match ?<br>\nWould there be any situation for the same 'main body' the member function would be preferred in place of the free function ? (This is what is happening in the product build) <br/></br></p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><clang><argument-dependent-lookup>", "OwnerUserId": "434233", "AnswerCount": "2"}, "26001503": {"ParentId": "26000553", "CommentCount": "1", "Body": "<p>These two candidate functions are in the overload set:</p>\n<pre><code>// member function template, found by qualified lookup\ntemplate &lt;typename T&gt;\ntest::Ops::operator&lt;&lt;(const T&amp;)\n\n// non-member function template, found by ADL\ntemplate &lt;template &lt;typename&gt; class E, typename T&gt;\ntest::operator&lt;&lt;(test::Ops&amp;, const E&lt;T&gt;&amp;)\n</code></pre>\n<p>In operator lookup, no preference is given to members versus non-members. After template argument substitution, both function template specializations <em>exactly match</em> (with qualification conversions) the supplied argument types. But the function taking <code>E&lt;T&gt;</code> is <em>more specialized</em> than the one taking <code>T</code>, so the non-member function is chosen for this reason.</p>\n<p>Apple clang 5.0.0 is based on LLVM clang 3.3svn. I can't find any version of LLVM clang which selects the member function. It could be a bug in Apple's code, but IMHO it's more likely to be some subtle difference in the code you are actually compiling or your environment. Have you tried compiling your example code with the suspect compiler?</p>\n", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "26001503", "Score": "1", "CreationDate": "2014-09-23T17:46:54.827", "LastActivityDate": "2014-09-23T17:46:54.827"}, "26001996": {"ParentId": "26000553", "CommentCount": "1", "Body": "<p>This is what happens in detail and what every compiler should do: a candidate template function is found by qualified lookup </p>\n<pre><code>template &lt;typename T&gt;\ntest::Ops::operator&lt;&lt;(const T&amp;)\n</code></pre>\n<p>while the second candidate is generated via ADL using template argument deduction (cfr. temp.deduct.conv)</p>\n<pre><code>template &lt;template &lt;typename&gt; class E, typename T&gt;\ntest::operator&lt;&lt;(test::Ops&amp;, const E&lt;T&gt;&amp;)\n</code></pre>\n<p>Afterwards overload resolution kicks in (cfr. 13.3.3) and the non-member one (F1) is preferred to the member (F2) one since</p>\n<blockquote id=\"so_26000553_26001996_0\">\n<ul>\n<li>F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2.</li>\n</ul>\n</blockquote>\n<p>and thus selected as the function to be called.</p>\n<p>To answer your question: it depends on the overload resolution rules. Being a member function or in an inner scope doesn't affect the result and something like</p>\n<pre><code>namespace test {\n    class Ops {\n      public:\n        Ops():val_(0){}\n\n        template&lt;typename T&gt;\n        Ops&amp; operator&lt;&lt; (const T&amp; val) {\n            std::cout &lt;&lt; \"Called member function\" &lt;&lt; std::endl;\n            this-&gt;val_ = val;\n            return *this;\n        }\n\n      private:\n        int val_;\n    };\n\n    template&lt;typename T&gt;\n    struct Any {\n        T val_;\n    };\n\n    template &lt;typename E&gt;\n    Ops&amp; operator&lt;&lt; (Ops&amp; op, const E&amp; val) {\n        std::cout &lt;&lt; \"Global function\" &lt;&lt; std::endl;\n        return op;\n    }\n}\n</code></pre>\n<p>would just trigger an overload resolution error '<code>use of overloaded operator '&lt;&lt;' is ambiguous</code>'.</p>\n<p>As a plus: the member function is wrong even if it were chosen: <code>this-&gt;val</code> is assigned a non-integer type.</p>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26001996", "Score": "2", "CreationDate": "2014-09-23T18:15:37.630", "LastActivityDate": "2014-09-23T18:15:37.630"}, "bq_ids": {"n4140": {"so_26000553_26001996_0": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_26000553_26001996_0": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_26000553_26001996_0": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}}}});