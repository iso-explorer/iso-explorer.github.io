post_cb({"22609240": {"ParentId": "22609067", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-03-24T12:21:00.920", "Score": "1", "LastEditorUserId": "1600898", "LastEditDate": "2017-10-16T08:20:32.600", "Id": "22609240", "OwnerUserId": "1600898", "Body": "<p>According to \u00a76.5.16 (3) of C99:</p>\n<blockquote>\n<p id=\"so_22609067_22609240_0\">An assignment expression has the value of the left operand after the assignment, [...]</p>\n</blockquote>\n<p>Together with right-associativity of evaluation, and assuming non-volatile <code>a</code>, <code>b</code>, and <code>c</code>, it means that <code>a = b = c</code> is equivalent to <code>a = (b = c)</code>, and again equivalent to <code>b = c; a = b</code>.</p>\n", "LastActivityDate": "2017-10-16T08:20:32.600"}, "22609145": {"ParentId": "22609067", "CommentCount": "0", "CreationDate": "2014-03-24T12:16:51.613", "OwnerUserId": "1145666", "PostTypeId": "2", "Id": "22609145", "Score": "1", "Body": "<p>It is all about associativity. You can rewrite <code>a=b=c</code> as <code>a=(b=c)</code>. And the result of an assignment (<code>b=c</code>) is the value of the last assigned variable (<code>b</code>). </p>\n", "LastActivityDate": "2014-03-24T12:16:51.613"}, "22609197": {"ParentId": "22609067", "CommentCount": "1", "CreationDate": "2014-03-24T12:18:49.323", "OwnerUserId": "26095", "PostTypeId": "2", "Id": "22609197", "Score": "1", "Body": "<p>It C, and C++, assignment is right associative and also an expression, so</p>\n<pre><code>a=b=c;\n</code></pre>\n<p>Is treated as:</p>\n<pre><code>a=(b=c);\n</code></pre>\n<p>Where the expression <code>b=c</code> evaluates to whatever is in <code>b</code> after the assignment. Note that I say \"whatever` as it's possible (but not advisable) in C++ to provide an assigment function that does something other that assignment!</p>\n", "LastActivityDate": "2014-03-24T12:18:49.323"}, "22609067": {"CommentCount": "3", "ViewCount": "1543", "CreationDate": "2014-03-24T12:12:41.100", "LastActivityDate": "2017-10-16T08:20:32.600", "Title": "Is chained assignment in C/C++ undefined behavior?", "AcceptedAnswerId": "22609184", "PostTypeId": "1", "Id": "22609067", "Score": "0", "Body": "<p>Ignoring the types of variables, is expression like <code>a=b=c</code> has defined behavior in both C and C++?</p>\n<p>If so, can any one give me official evidence, like quotes from the standard, please?</p>\n<p>P.S. I searched the chained assignment but everything I got is associativity, but I didn't find any text about that in the C99 standard. Maybe I did it wrong? hoping anyone can help me.</p>\n", "Tags": "<c++><c><variable-assignment>", "OwnerUserId": "3243067", "AnswerCount": "4"}, "22609184": {"ParentId": "22609067", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-03-24T12:18:27.840", "Score": "2", "LastEditorUserId": "2877241", "LastEditDate": "2014-03-24T12:24:55.663", "Id": "22609184", "OwnerUserId": "2877241", "Body": "<p>From the C++ Standard</p>\n<blockquote>\n<p id=\"so_22609067_22609184_0\">5.17 Assignment and compound assignment operators [expr.ass] 1 The assignment operator (=) and the compound assignment operators all\n  group right-to-left. All require a modifiable lvalue as their left\n  operand and <strong>return an lvalue referring to the left operand</strong>. The result\n  in all cases is a bit-field if the left operand is a bit-field. In all\n  cases, the assignment is sequenced after the value computation of the\n  right and left operands, and before the value computation of the\n  assignment expression.</p>\n</blockquote>\n<p>And an example from there</p>\n<pre><code>int a, b;\na = b = { 1 }; // meaning a=b=1;\n</code></pre>\n<p>From the C Standard</p>\n<blockquote>\n<p id=\"so_22609067_22609184_1\">6.5.16 Assignment operators Semantics 3 An assignment operator stores a value in the object designated by the left operand. An assignment\n  expression has the value of the left operand after the assignment,111)\n  <strong>but is not an lvalue</strong>. The type of an assignment expression is the type\n  the left operand would have after lvalue conversion. The side effect\n  of updating the stored value of the left operand is sequenced after\n  the value computations of the left and right operands. The evaluations\n  of the operands are unsequenced.</p>\n</blockquote>\n<p>As you see there is a difference. In C++ the assignment operator returns <strong>an lvalue referring to the left operand</strong> while in C it returns the value of the left operand after the assignment,111)\n<strong>but is not an lvalue</strong>.</p>\n<p>It means that in C++ the following code is valid</p>\n<pre><code>int a, b = 20;\n\n( a = 10 ) = b;\n</code></pre>\n<p>while in C the compiler shall issue an error.</p>\n", "LastActivityDate": "2014-03-24T12:24:55.663"}, "bq_ids": {"n4140": {"so_22609067_22609184_0": {"section_id": 6173, "quality": 0.84, "length": 42}, "so_22609067_22609240_0": {"section_id": 6173, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_22609067_22609184_0": {"section_id": 5934, "quality": 0.84, "length": 42}, "so_22609067_22609240_0": {"section_id": 5934, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_22609067_22609184_0": {"section_id": 7675, "quality": 0.84, "length": 42}, "so_22609067_22609240_0": {"section_id": 7408, "quality": 0.7142857142857143, "length": 5}}}});