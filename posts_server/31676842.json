post_cb({"31677623": {"ParentId": "31676842", "CommentCount": "0", "Body": "<p>N4527 \u00a71.3.19 [defns.signature.templ]</p>\n<blockquote>\n<p id=\"so_31676842_31677623_0\"><strong>signature</strong></p>\n<p id=\"so_31676842_31677623_1\">&lt;function template&gt; name, parameter type list (8.3.5), enclosing namespace (if any), return type, and\n  template parameter list</p>\n</blockquote>\n<p>The default template argument is <em>not</em> part of the signature of a function template.</p>\n", "OwnerUserId": "4672588", "PostTypeId": "2", "Id": "31677623", "Score": "5", "CreationDate": "2015-07-28T13:22:48.577", "LastActivityDate": "2015-07-28T13:22:48.577"}, "31677067": {"ParentId": "31676842", "CommentCount": "1", "Body": "<p>You can change <code>std::enable_if&lt;...&gt;::type</code> as the return type of the function.  As far as I know you cannot pass it to the type of another template parameter.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename Float&gt; \ntypename std::enable_if&lt;std::is_floating_point&lt;Float&gt;::value&gt;::type\nfunc(Float floatVal)\n{\n    std::cerr &lt;&lt; \"float: \" &lt;&lt; floatVal &lt;&lt; \"\\n\";\n}\n\ntemplate&lt;typename Integer&gt;\ntypename std::enable_if&lt;std::is_integral&lt;Integer&gt;::value&gt;::type\nfunc(Integer integer)\n{\n    std::cerr &lt;&lt; \"integral: \" &lt;&lt; integer &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    func(32.4246);\n    func(144532);\n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/7fa29f4e6f06da7b\" rel=\"nofollow\">Live Example</a></kbd></p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "31677067", "Score": "4", "CreationDate": "2015-07-28T12:59:26.493", "LastActivityDate": "2015-07-28T12:59:26.493"}, "31676842": {"CommentCount": "2", "AcceptedAnswerId": "31677623", "PostTypeId": "1", "ClosedDate": "2015-07-28T21:04:21.523", "LastEditorUserId": "673852", "CreationDate": "2015-07-28T12:49:52.880", "LastActivityDate": "2015-07-28T13:22:48.577", "LastEditDate": "2015-07-28T13:09:30.560", "ViewCount": "158", "FavoriteCount": "1", "Title": "Why can't this function be overloaded with one of clearly different signature?", "Id": "31676842", "Score": "6", "Body": "<p>The following code fails to compile because of <code>error: redefinition of \u2018template&lt;class Integer, class&gt; void func(Integer)\u2019</code></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename Float, typename = typename \nstd::enable_if&lt;std::is_floating_point&lt;Float&gt;::value&gt;::type&gt;\nvoid func(Float floatVal)\n{\n    std::cerr &lt;&lt; \"float: \" &lt;&lt; floatVal &lt;&lt; \"\\n\";\n}\n\ntemplate&lt;typename Integer, typename = typename \nstd::enable_if&lt;std::is_integral&lt;Integer&gt;::value&gt;::type&gt;\nvoid func(Integer integer)\n{\n    std::cerr &lt;&lt; \"integral: \" &lt;&lt; integer &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    func(32.4246);\n    func(144532);\n}\n</code></pre>\n<p>But the two functions will clearly have different signatures on template instantiation. So why is can't this compile?</p>\n<p><strong>Please note</strong>: I <em>do</em> know how to fix this: just adding another dummy template parameter to one of the functions, e.g. <code>typename=void</code>, will work, like here</p>\n<pre><code>template&lt;typename Integer, typename dummy=void, typename = typename \nstd::enable_if&lt;std::is_integral&lt;Integer&gt;::value&gt;::type&gt;\nvoid func(Integer integer){}\n</code></pre>\n<p>But the question is <em>why</em> do I have to do this?</p>\n", "Tags": "<c++><templates><function-overloading>", "OwnerUserId": "673852", "AnswerCount": "3"}, "31677082": {"ParentId": "31676842", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Alternatively to overloading on return type like <a href=\"https://stackoverflow.com/a/31677067/27678\">NathanOliver</a> did, you can be a little more complicated in the template types:</p>\n<pre><code>template&lt;typename Float, typename std::enable_if&lt;std::is_floating_point&lt;Float&gt;::value&gt;::type* = nullptr&gt;\nvoid func(Float floatVal)\n{\n    std::cerr &lt;&lt; \"float: \" &lt;&lt; floatVal &lt;&lt; \"\\n\";\n}\n\ntemplate&lt;typename Integer, typename std::enable_if&lt;!std::is_floating_point&lt;Integer&gt;::value &amp;&amp; std::is_integral&lt;Integer&gt;::value&gt;::type* = nullptr&gt;\nvoid func(Integer integer)\n{\n    std::cerr &lt;&lt; \"integral: \" &lt;&lt; integer &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ca7a83b1774cca47\" rel=\"nofollow noreferrer\">Live Demo</a><br>\nNotice that the second <code>enable_if</code> for <code>Integer</code> explicitly negates the <code>enable_if</code> condition for <code>Float</code></br></p>\n<p>The benefit of this approach is that your functions still return <code>void</code></p>\n<p>And test it:</p>\n<pre><code>int main()\n{\n    func(32.4246);\n    func(144532);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>float: 32.4246\nintegral: 144532\n</code></pre>\n", "OwnerUserId": "27678", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:52.500", "Id": "31677082", "Score": "2", "CreationDate": "2015-07-28T13:00:26.417", "LastActivityDate": "2015-07-28T13:00:26.417"}, "bq_ids": {"n4140": {"so_31676842_31677623_1": {"section_id": 5768, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_31676842_31677623_1": {"section_id": 5541, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_31676842_31677623_1": {"section_id": 7225, "quality": 0.9285714285714286, "length": 13}}}});