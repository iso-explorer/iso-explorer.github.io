post_cb({"48608770": {"Id": "48608770", "PostTypeId": "2", "Body": "<p>This is a GCC bug. </p>\n<p>First, braces around scalar initializer (list-initialization for scalar type) are permitted according to <a href=\"http://www.eel.is/c++draft/dcl.init.list#3.9\" rel=\"nofollow noreferrer\">[dcl.init.list]/3.9</a>:</p>\n<blockquote>\n<p id=\"so_48600267_48608770_0\">Otherwise, if the initializer list has a single element of type E and either T is not a reference type or its referenced type is reference-related to E, the object or reference is initialized from that element (by copy-initialization for copy-list-initialization, or by direct-initialization for direct-list-initialization); if a narrowing conversion (see below) is required to convert the element to T, the program is ill-formed.\n  [\u2009Example:</p>\n<pre><code>int x1 {2};                         // OK\nint x2 {2.0};                       // error: narrowing\n</code></pre>\n<p id=\"so_48600267_48608770_1\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n<p>Second, <code>Node&lt;int&gt;</code> is an aggregate according to <a href=\"http://www.eel.is/c++draft/dcl.init.aggr#1\" rel=\"nofollow noreferrer\">[dcl.init.aggr]/1</a>:</p>\n<blockquote>\n<p id=\"so_48600267_48608770_2\">An aggregate is an array or a class with</p>\n<ul>\n<li><p id=\"so_48600267_48608770_3\">no user-provided, explicit, or inherited constructors ([class.ctor]),</p></li>\n<li><p id=\"so_48600267_48608770_4\">no private or protected non-static data members ([class.access]),</p></li>\n<li><p id=\"so_48600267_48608770_5\">no virtual functions, and</p></li>\n<li><p id=\"so_48600267_48608770_6\">no virtual, private, or protected base classes ([class.mi]).</p></li>\n</ul>\n</blockquote>\n<p>So aggregate initialization is performed and <code>val</code> is list-initialized with <code>{args...}</code> recursively according to <a href=\"http://www.eel.is/c++draft/dcl.init.aggr#4.2\" rel=\"nofollow noreferrer\">[dcl.init.aggr]/4.2</a>:</p>\n<blockquote>\n<p id=\"so_48600267_48608770_7\">Otherwise, the element is copy-initialized from the corresponding <em>initializer-clause</em> or the <em>brace-or-equal-initializer</em> of the corresponding <em>designated-initializer-clause</em>. If that initializer is of the form <em>assignment-expression</em> or = <em>assignment-expression</em> and a narrowing conversion is required to convert the expression, the program is ill-formed. [\u2009Note: <strong>If an initializer is itself an initializer list, the element is list-initialized</strong>, which will result in a recursive application of the rules in this subclause if the element is an aggregate. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Then <a href=\"http://www.eel.is/c++draft/dcl.init.list#3.9\" rel=\"nofollow noreferrer\">[dcl.init.list]/3.9</a> applies again. </p>\n<p>As a conclusion, this initialization is well-defined.</p>\n", "LastEditorUserId": "5376789", "LastActivityDate": "2018-02-04T16:51:43.480", "Score": "3", "CreationDate": "2018-02-04T13:53:03.733", "ParentId": "48600267", "CommentCount": "0", "OwnerUserId": "5376789", "LastEditDate": "2018-02-04T16:51:43.480"}, "bq_ids": {"n4140": {"so_48600267_48608770_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 3298}, "so_48600267_48608770_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 3325}, "so_48600267_48608770_7": {"length": 19, "quality": 0.5428571428571428, "section_id": 3299}, "so_48600267_48608770_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 3298}}, "n3337": {"so_48600267_48608770_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 3168}, "so_48600267_48608770_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 3195}, "so_48600267_48608770_7": {"length": 19, "quality": 0.5428571428571428, "section_id": 3169}, "so_48600267_48608770_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 3168}}, "n4659": {"so_48600267_48608770_3": {"length": 4, "quality": 0.8, "section_id": 4063}, "so_48600267_48608770_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 4063}, "so_48600267_48608770_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 4091}, "so_48600267_48608770_7": {"length": 22, "quality": 0.6285714285714286, "section_id": 4065}, "so_48600267_48608770_6": {"length": 5, "quality": 0.8333333333333334, "section_id": 4063}}}, "48600267": {"ViewCount": "118", "Body": "<p>I am trying to create a linked list template and it works fine for user defined types, but for fundamental types like int behaviour of gcc and clang differ. </p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;class T&gt;\nstruct Node {\n  Node* next;\n  T val;\n};\n\ntemplate&lt;class T, class... Args&gt;\nNode&lt;T&gt; create(Args... args) {\n  return {nullptr, {args...}};\n}\n\nint main() {\n  create&lt;int&gt;(0);\n}\n</code></pre>\n<p>While clang compiles that code without problems, gcc generates the following error message.</p>\n<blockquote>\n<p id=\"so_48600267_48600267_0\">error: could not convert \u2018{nullptr, {args#0}}\u2019 from \u2018&lt;brace-enclosed initializer list&gt;\u2019 to \u2018Node&lt;int&gt;\u2019</p>\n</blockquote>\n<p>While I know how to solve this problem, I am still interested whether clang is too permissive and I can't rely on portability of this code, or it is a gcc bug which should be resolved sometime.</p>\n<p>Example: <a href=\"https://godbolt.org/g/9gnvNQ\" rel=\"nofollow noreferrer\">https://godbolt.org/g/9gnvNQ</a></p>\n", "AcceptedAnswerId": "48608770", "Title": "Brace initialization of template struct", "CreationDate": "2018-02-03T17:53:36.657", "LastActivityDate": "2018-02-27T20:07:51.127", "CommentCount": "6", "LastEditDate": "2018-02-27T20:07:51.127", "PostTypeId": "1", "LastEditorUserId": "1463336", "Id": "48600267", "Score": "10", "OwnerUserId": "3054156", "Tags": "<c++><gcc><clang><language-lawyer>", "AnswerCount": "2"}, "48601701": {"Id": "48601701", "PostTypeId": "2", "Body": "<p>I believe you want something like this:</p>\n<pre><code>return {nullptr, T{args...}};\n</code></pre>\n<p>This explicitly constructs an object <code>T</code> using the arguments provided and works with any user defined type as well, shown in the following</p>\n<pre><code>template&lt;class T&gt;\nstruct Node {\n    Node* next;\n    T val;\n};\n\ntemplate&lt;class T, class... Args&gt;\nNode&lt;T&gt; create(Args... args) {\n    return {nullptr, T{args...}};\n}\n\nstruct Foo {\n    string s;\n    int i;\n};\n\nint main() {\n    auto n = create&lt;Foo&gt;(\"foo\", 42);\n    cout &lt;&lt; n.val.s &lt;&lt; ' ' &lt;&lt; n.val.i &lt;&lt; endl;\n}\n</code></pre>\n", "LastActivityDate": "2018-02-03T20:30:10.607", "Score": "1", "CreationDate": "2018-02-03T20:30:10.607", "ParentId": "48600267", "CommentCount": "0", "OwnerUserId": "9277318"}});