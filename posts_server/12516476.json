post_cb({"12516476": {"CommentCount": "11", "ViewCount": "620", "PostTypeId": "1", "LastEditorUserId": "540815", "CreationDate": "2012-09-20T16:01:49.320", "LastActivityDate": "2012-09-21T23:14:39.890", "Title": "Scope of the c++ using directive", "AcceptedAnswerId": "12531683", "LastEditDate": "2012-09-21T13:04:15.737", "Id": "12516476", "Score": "3", "Body": "<p>From section 7.3.4.2 of the c++11 standard:</p>\n<blockquote>\n<p id=\"so_12516476_12516476_0\">A <em>using-directive</em> specifies that the names in the nominated namespace\n  can be used in the scope in which the <em>using-directive</em> appears after\n  the <em>using-directive</em>. During unqualified name lookup (3.4.1), the names\n  appear as if they were declared in the nearest enclosing namespace\n  which contains both the <em>using-directive</em> and the nominated namespace. [\n  Note: In this context, \u201ccontains\u201d means \u201ccontains directly or\n  indirectly\u201d. \u2014end note ]</p>\n</blockquote>\n<p>What do the second and third sentences mean exactly? Please give example.</p>\n<p>Here is the code I am attempting to understand:</p>\n<pre><code>namespace A\n{\n    int i = 7;\n}\nnamespace B\n{\n    using namespace A;\n    int i = i + 11;\n}\nint main(int argc, char * argv[])\n{\n    std::cout &lt;&lt; A::i &lt;&lt; \" \" &lt;&lt; B::i &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p><strike>It print \"7 7\" and not \"7 18\" as I would expect.</strike></p>\n<p>Sorry for the typo, the program actually prints \"7 11\".</p>\n", "Tags": "<c++><namespaces><c++11><standards><using-directives>", "OwnerUserId": "540815", "AnswerCount": "2"}, "12521719": {"ParentId": "12516476", "CommentCount": "0", "Body": "<p>The <code>using</code> statement in your code is irrelevant. <code>B::i</code> is already in scope when the initializer for <code>B::i</code> is evaluated. You can trivially prove this by deleting the <code>using</code> statement; your code should compile and run just the same. In any case, the value of <code>B::i</code> ends up being undefined because it depends on an uninitialized value (i.e. the value that <code>B::i</code> had when the initializer was evaluated).</p>\n", "OwnerUserId": "582", "PostTypeId": "2", "Id": "12521719", "Score": "4", "CreationDate": "2012-09-20T22:17:38.917", "LastActivityDate": "2012-09-20T22:17:38.917"}, "12531683": {"ParentId": "12516476", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Eliminating the undefined behaviour:</p>\n<pre><code>namespace A\n{\n    int i = 7;\n}\nnamespace B\n{\n    using namespace A;\n    int tmp = i + 11;\n    int i = tmp;\n}\n#include &lt;iostream&gt;\nint main()\n{\n    std::cout &lt;&lt; A::i &lt;&lt; \" \" &lt;&lt; B::i &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>The meaning of the standard is that at the line</p>\n<pre><code>    int tmp = i + 11;\n</code></pre>\n<p>the name <code>i</code> appears in the \"<em>nearest enclosing namespace which contains both the using-directive and the nominated namespace</em>\"; the <em>using-directive</em> appears in <code>namespace B</code> while the nominated namespace is <code>namespace A</code>; the nearest enclosing namespace is the <em>global namespace</em>, so <code>i</code> appears as <code>::i</code>.  This means that if a name <code>i</code> is already present in the global namespace the code is ambiguous.</p>\n<p>For a more complex example:</p>\n<pre><code>namespace A {\n    namespace B {\n        namespace C {\n            int i = 4;\n        }\n    }\n    namespace D {\n        using namespace B::C;\n        namespace E {\n            int j = i;\n        }\n    }\n}\n</code></pre>\n<p>At the line <code>int j = i</code>, <code>i</code> appears in the nearest enclosing namespace of the using-directive (i.e., <code>A::D</code>) and the nominated namespace (<code>A::B::C</code>), which is <code>A</code>.  So, within <code>A::D</code> after the using-directive, and so also within <code>A::D::E</code>, the unqualified name <code>i</code> can refer to <code>A::B::C::i</code> appearing as <code>A::i</code>, shadowing any <code>::i</code>, conflicting with any <code>A::i</code>, and being shadowed by any <code>A::D::i</code> or <code>A::D::E::i</code> (within <code>A::D::E</code>):</p>\n<pre><code>int i = 1;                // shadowed by A::B::C::i appearing as A::i\nnamespace A {\n    int i = 2;            // conflicts with A::B::C::i appearing as A::i\n    namespace B {\n        int i = 3;        // irrelevant\n        namespace C {\n            int i = 4;    // nominated; appears as A::i\n        }\n    }\n    namespace D {\n        int i = 5;        // shadows A::B::C::i appearing as A::i\n        using namespace B::C;\n        namespace E {\n            int i = 6;    // shadows A::B::C::i appearing as A::i\n            int j = i;\n        }\n    }\n}\n</code></pre>\n<p>Note that just because the name <em>appears as</em> <code>A::i</code> during unqualified name lookup, that does not mean that it actually <em>is</em> there; the qualified name <code>A::i</code> will continue to refer only to an actual name <code>A::i</code> (if any exists).</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-09-21T13:42:35.217", "Id": "12531683", "Score": "2", "CreationDate": "2012-09-21T13:37:06.727", "LastActivityDate": "2012-09-21T13:42:35.217"}, "bq_ids": {"n4140": {"so_12516476_12516476_0": {"section_id": 5510, "quality": 0.8947368421052632, "length": 34}}, "n3337": {"so_12516476_12516476_0": {"section_id": 5296, "quality": 0.8947368421052632, "length": 34}}, "n4659": {"so_12516476_12516476_0": {"section_id": 6945, "quality": 0.8947368421052632, "length": 34}}}});