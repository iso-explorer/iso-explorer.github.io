post_cb({"bq_ids": {"n4140": {"so_48454596_48454893_0": {"length": 13, "quality": 1.0, "section_id": 460}}, "n3337": {"so_48454596_48454893_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 3260}}, "n4659": {"so_48454596_48454893_0": {"length": 13, "quality": 1.0, "section_id": 483}}}, "48454596": {"ViewCount": "59", "Body": "<p>I'm looking for a way to initialize non-moveable members in a structure through a factory function return value. Specifically, the language admits the case of initializing a non-moveable member through aggregate initialization, but there are scenarios in which this kind of initialization is not possible. I wonder if there is still a way to initialize non-moveable members directly (in-place) in cases where aggregate initialization is not permitted.</p>\n<p>This is a <a href=\"https://stackoverflow.com/q/11069605/259543\">similar question</a>, although it deals with the case of initializing a <strong>non-static</strong> member from a function returning a non-copyable/moveable type.</p>\n<p>An example is in order. Consider the following:</p>\n<pre><code>struct S { S(S&amp;&amp;) = delete; };       // Non-moveable type.\nS F() { return {}; }\n</code></pre>\n<p>Now, consider the following initialization of a member in an aggregate from a return value.</p>\n<pre><code>struct T { S s; };\nvoid G() { T t{F()}; }               // OK (in-place construction of t).\n</code></pre>\n<p>The above works because <code>t</code> is being initialized through aggregate initialization. <code>S::S(S&amp;&amp;)</code> is not involved. [Note: this excerpt works only in GCC-7, not in GCC-6 or older versions.]</p>\n<p>But what if aggregate initialization is not possible at all?</p>\n<pre><code>struct X {};\nstruct U: virtual X                  // Not an aggregate anymore.\n    { S s; U(S&amp;&amp; s): s{(S&amp;&amp;)s} {} }; // Needs an explicit constructor.\nvoid H() { U u{F()}; }               // Doesn't work (S::S(S&amp;&amp;) is deleted).\n</code></pre>\n<p>...or simply inconvenient?</p>\n<pre><code>struct A {}; struct B {}; struct C {};\nstruct V: A, B, C { S s; };          // Still an aggregate.\n\nvoid I() { V v{F()}; }               // No chance.\nvoid J() { V v{{}, {}, {}, F()}; }   // Kinda works, but ugly.\n</code></pre>\n<p>The point here is that, although <code>S</code> in non-moveable, it would be nice if it could be used as a member object subject to in-place construction in situations similar to the above.</p>\n<p>Is it possible?</p>\n", "AcceptedAnswerId": "48454916", "Title": "Initialization of non-moveable member objects", "CreationDate": "2018-01-26T01:29:40.513", "LastActivityDate": "2018-01-26T02:33:22.907", "CommentCount": "0", "LastEditDate": "2018-01-26T02:23:04.813", "PostTypeId": "1", "LastEditorUserId": "259543", "Id": "48454596", "Score": "-2", "OwnerUserId": "259543", "Tags": "<c++><c++17>", "AnswerCount": "2"}, "48454916": {"Id": "48454916", "PostTypeId": "2", "Body": "<p>When you make a class immobile, you've made it <em>immobile</em>. Which means that you have to construct it in place, either from a prvalue, direct use of a constructor call, or direct use of a braced-init-list.</p>\n<p>You cannot pass an object of that type through to someone else. If you want <code>U</code> to be able to construct an <code>S</code> member, you need to have <code>U</code>'s constructor either directly or indirectly provide the parameters used to initialize the <code>S</code> object in-situ. For example:</p>\n<pre><code>struct U        // Constructors mean that it's not an aggregate.\n{\n  S s;\n  template&lt;typename ...Args&gt;\n  U(Args &amp;&amp;...args)\n   : s(std::forward&lt;Args&gt;(args)...) {}\n};\n\nvoid H() { U u{}; } //Passes no parameters to `S`'s construction.\n</code></pre>\n<p>If you know exactly what constructors of the member to use in a constructor, then you don't need to use forwarding like this.</p>\n<hr>\n<blockquote>\n<p id=\"so_48454596_48454916_0\">The above works because t is being initialized through aggregate initialization. S::S(S&amp;&amp;) is not involved. [Note: this excerpt works only in GCC-7, not in GCC-6 or older versions.]</p>\n</blockquote>\n<p>Correction: the above works in GCC-7 because that supports guaranteed elision, which makes that possible. Without guaranteed elision, a prvalue would represent a temporary that gets copied/moved from. Even if the compiler elides it, the compiler still has to make sure that the code would have worked if it had copied/moved it.</p>\n<blockquote>\n<p id=\"so_48454596_48454916_1\">I'm looking for a way to initialize non-moveable members in a structure through a factory function return value.</p>\n</blockquote>\n<p>That's a rather different question, but guaranteed elision makes it work well enough. Simply pass a function to the constructor:</p>\n<pre><code>struct U\n{\n  S s;\n  template&lt;typename Func&gt;\n  U(Func f) : s(f()) {}\n};\n</code></pre>\n<p>If your factory function takes parameters, then you need to pass a lambda that captures those parameters and passes the captured values to the factory function.</p>\n</hr>", "LastEditorUserId": "734069", "LastActivityDate": "2018-01-26T02:33:22.907", "Score": "4", "CreationDate": "2018-01-26T02:18:53.730", "ParentId": "48454596", "CommentCount": "6", "OwnerUserId": "734069", "LastEditDate": "2018-01-26T02:33:22.907"}, "48454893": {"Id": "48454893", "PostTypeId": "2", "Body": "<p>When you return a S instance local variable, it is turned into an r-xvalue which would look first for the move constructor. If it is deleted, then it will not work.</p>\n<p>Also from the standard:\nN4659 15.8.1/(10.4) Copy/move constructors [class.copy.ctor]</p>\n<blockquote>\n<p id=\"so_48454596_48454893_0\">A deleted move constructor would otherwise interfere with\n  initialization from an rvalue which can use the copy constructor instead</p>\n</blockquote>\n", "LastActivityDate": "2018-01-26T02:14:18.350", "Score": "0", "CreationDate": "2018-01-26T02:14:18.350", "ParentId": "48454596", "CommentCount": "0", "OwnerUserId": "5352221"}});