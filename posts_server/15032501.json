post_cb({"bq_ids": {"n4140": {"so_15032501_15032693_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3299}}, "n3337": {"so_15032501_15032693_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3169}}, "n4659": {"so_15032501_15032693_0": {"length": 16, "quality": 0.6956521739130435, "section_id": 4065}}}, "15034408": {"Id": "15034408", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15032501_15034408_0\">the mechanics behind the scenes that yields a deleted fcxn;</p>\n</blockquote>\n<p>Arrays can only be initialized like that if the type is copyable or movable, and <code>unique_ptr</code> is not copyable, so a class with a <code>unique_ptr</code> member is not copyable by default, and your type has a user-defined destructor, which inhibits the implicit move constructor, so your type is not movable either.</p>\n<blockquote>\n<p id=\"so_15032501_15034408_1\">or more simply, why the expressiveness of <code>std::unique_ptr&lt;&gt;</code> appears to be restricted compared w/ a naked ptr.</p>\n</blockquote>\n<p><code>unique_ptr</code> is saving you from a serious bug. With the naked pointer your type is massively unsafe and will result in undefined behaviour, because you don't have a copy constructor so the pointer gets copied and then deleted twice by two different objects. Boom, your program has undefined behaviour.  <code>unique_ptr</code> fixes your class by preventing it from being copied, which is safe and correct.</p>\n<p>You can make it work in several ways, the easiest is to remove the user-defined destructor, which makes your class movable, and the array initialization will compile.</p>\n<p>Or if you need a user-defined destructor for some other reason, you can still make it work by writing a user-defined move constructor to explicitly move the <code>_w</code> member.</p>\n<p>If for some reason that isn't possible, you can make it work by adding a default constructor, so the array elements can be default constructed, and then move-assigning to them:</p>\n<pre><code>class WFactory\n{\npublic:\n    WFactory() = default;\n    WFactory(const int i)   : _w(new W1()) {}\n    WFactory(const char* s) : _w(new W2()) {}\n\nprivate:\n    std::unique_ptr&lt;Widget&gt;  _w; \n};\n\nint main()\n{  \n    WFactory wf[2];\n    wf[0] = WFactory(4);\n    wf[1] = WFactory(\"msg\");\n}\n</code></pre>\n<p>Your edited version is immoral and highly dubious, you should not cast away <code>const</code> like that and you should not move from an lvalue, especially not a <code>const</code> lvalue. Do not go there. Instead change how you use the class to avoid needing to copy it, <strong>or</strong> write a valid copy constructor that does a deep copy of the owned object:</p>\n<pre><code>class Widget\n{\npublic:\n    Widget() {}\n    virtual std::unique_ptr&lt;Widget&gt; clone() const = 0;\n};\n\nclass W1 : public Widget\n{\npublic:\n    W1() {}\n    virtual std::unique_ptr&lt;Widget&gt; clone() const\n    { return std::unique_ptr&lt;Widget&gt;(new W1(*this)); }\n};\n\nclass W2 : public Widget\n{\npublic:\n    W2() {}\n    virtual std::unique_ptr&lt;Widget&gt; clone() const\n    { return std::unique_ptr&lt;Widget&gt;(new W2(*this)); }\n};\n\nclass WFactory\n{\npublic:\n    WFactory(const int i)   : _w(new W1()) {}\n    WFactory(const char* s) : _w(new W2()) {}\n    WFactory(const WFactory&amp; w) : _w(w._w-&gt;clone()) {}\n    // ...\n</code></pre>\n<p>The best approach is to make the class movable, and a good way to do that is to follow the <a href=\"http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html\" rel=\"nofollow\">rule of zero</a></p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-02-23T00:34:06.957", "Score": "4", "CreationDate": "2013-02-22T22:39:30.340", "ParentId": "15032501", "CommentCount": "5", "OwnerUserId": "981959", "LastEditDate": "2013-02-23T00:34:06.957"}, "15032501": {"ViewCount": "12505", "Body": "<p>All, </p>\n<p>When I instantiate a widgets array using an initializer-list format, a naked pointer that points to a member-variable widget instance compiles but after change to std::unique_ptr&lt;&gt; gcc gives a compilation error regarding a deleted function. </p>\n<p>$ uname -a </p>\n<p>Linux .. 3.5.0-21-generic #32-Ubuntu SMP Tue Dec 11 18:51:59 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux</p>\n<p>$ g++ --version</p>\n<p>g++ (Ubuntu/Linaro 4.7.2-5ubuntu1) 4.7.2</p>\n<p>This code gives the following compiler error:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;memory&gt;\n\nclass Widget\n{\npublic:\n    Widget() {}\n};\n\nclass W1 : public Widget\n{\npublic:\n    W1() {}\n};\n\nclass W2 : public Widget\n{\npublic:\n    W2() {}\n};\n\nclass WFactory\n{\npublic:\n    WFactory(const int i)   : _w(new W1()) {}\n    WFactory(const char* s) : _w(new W2()) {}\n\n    ~WFactory() { _w.reset(nullptr); }\n    // ~WFactory() { delete _w; }  &lt;--- for naked ptr\n\nprivate:\n    // NOTE: does not compile\n    std::unique_ptr&lt;Widget&gt;  _w; \n    // NOTE: does compile\n    // Widget* _w;\n};\n\nint main()\n{\n    std::unique_ptr&lt;Widget&gt; a(new W1()); // &lt;--- compiles fine\n\n    WFactory wf[] { 4, \"msg\" };          // &lt;--- compiler error using unique_ptr&lt;&gt;\n}\n</code></pre>\n<p>error:</p>\n<pre><code>$ g++ -o unique_ptr  -std=c++11 -Wall  unique_ptr.cpp \nunique_ptr.cpp: In function \u2018int main()\u2019:\nunique_ptr.cpp:36:30: error: use of deleted function \u2018WFactory::WFactory(const WFactory&amp;)\u2019\nunique_ptr.cpp:22:7: note: \u2018WFactory::WFactory(const WFactory&amp;)\u2019 is implicitly deleted because the default definition would be ill-formed:\nunique_ptr.cpp:22:7: error: use of deleted function \u2018std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = Widget; _Dp = std::default_delete&lt;Widget&gt;; std::unique_ptr&lt;_Tp, _Dp&gt; = std::unique_ptr&lt;Widget&gt;]\u2019\nIn file included from /usr/include/c++/4.7/memory:86:0,\n             from unique_ptr.cpp:2:\n/usr/include/c++/4.7/bits/unique_ptr.h:262:7: error: declared here\nunique_ptr.cpp:36:30: error: use of deleted function \u2018WFactory::WFactory(const WFactory&amp;)\u2019\nunique_ptr.cpp:36:14: warning: unused variable \u2018wf\u2019 [-Wunused-variable]\n</code></pre>\n<p>I'm at a loss as to either: the mechanics behind the scenes that yields a deleted fcxn; or more simply, why the expressiveness of std::unique_ptr&lt;&gt; appears to be restricted compared w/ a naked ptr.</p>\n<p>My question is:</p>\n<ul>\n<li>pilot error?</li>\n<li>compiler error? </li>\n<li>can I get my intended code to work w/ some change?</li>\n</ul>\n<p>Thank you.</p>\n<p><strong>Edit 1</strong></p>\n<p>Based on your answers, which I appreciate, I can make the following change to WFactory:</p>\n<p>(<strong>flagged as immoral code</strong>)</p>\n<pre><code>class WFactory\n{\npublic:\n    WFactory(const WFactory&amp; wf)\n    {\n        (const_cast&lt;WFactory&amp;&gt;(wf)).moveto(_w);\n    }\n\n    WFactory(const int i)   : _w(new W1()) {}\n    WFactory(const char* s) : _w(new W2()) {}\n\n    ~WFactory() { _w.reset(nullptr); }\n\n    void moveto(std::unique_ptr&lt;Widget&gt;&amp; w)\n    {\n        w = std::move(_w);\n    }\nprivate:\n    std::unique_ptr&lt;Widget&gt;  _w; \n};\n</code></pre>\n<p>and now the program compiles and runs. I appreciate that the standards folks wrote the specification for a reason, so I post my result as a good-faith specialization for my case at hand, where I really would like to emphasize the uniqueness of the ptr. </p>\n<p><strong>Edit 2</strong></p>\n<p>Based on Jonathan's replies, the following code does not suppress the implicit move ctor:</p>\n<pre><code>class WFactory\n{\npublic:\n    WFactory(const int i)   : _w(new W1()) {}\n    WFactory(const char* s) : _w(new W2()) {}\n\nprivate:\n    std::unique_ptr&lt;Widget&gt;  _w; \n};\n</code></pre>\n<p>Note that there is no <code>~WFactory() {..}</code> at all. </p>\n<p>Perhaps there's ya-ans, but I have found that using a c++11-style iteration over wf[] in Main() brings back the no-copy-ctor-for-WFactory error. That is:</p>\n<pre><code>int Main()\n..\n    WFactory wf[] { 4, \"msg\" };\n\n    for ( WFactory iwf : wf )    &lt;---- compiler error again\n        // ..\n\n    for (unsigned i = 0; i &lt; 2; ++i)  &lt;--- gcc happy\n        wf[i] //  ..\n}\n</code></pre>\n<p>I guess it's self-evident that the new c++11-style iteration is doing an object copy. </p>\n", "AcceptedAnswerId": "15032693", "Title": "std::unique_ptr deleted function, initializer_list - driven allocation", "CreationDate": "2013-02-22T20:17:03.137", "Id": "15032501", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-02-23T00:58:09.517", "LastEditorUserId": "1879153", "LastActivityDate": "2013-02-23T00:58:09.517", "Score": "6", "OwnerUserId": "1879153", "Tags": "<c++><c++11><unique-ptr><initializer-list>", "AnswerCount": "2"}, "15032693": {"Id": "15032693", "PostTypeId": "2", "Body": "<p>According to Paragraph 8.5.1/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15032501_15032693_0\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer listare taken as initializers for the members of the aggregate, in increasing subscript or member order. Each member is <strong>copy-initialized</strong> from the corresponding initializer-clause. [...]</p>\n</blockquote>\n<p>For each element, then, copy-initialization involves the creation of a temporary of the destination type, which is then use to copy-construct the element of the array.</p>\n<p>However, your class contains a member whose type is an instance of <code>unique_ptr</code>, which is non-copyable. That makes your class non-copyable as well. </p>\n<p>Moreover, although <code>unique_ptr</code> is <em>moveable</em>, your class is not, because the implicit generation of a move constructor by the compiler is suppressed by the presence of an explicitly defined destructor. If that were not the case (i.e., if you explicitly defined a move constructor for your class), copy-initialization would work (see 8.5/15).</p>\n<p>Try changing the definition of <code>WFactory</code> as follows to see that:</p>\n<pre><code>class WFactory\n{\npublic:\n    WFactory(const int i)   : _w(new W1()) {}\n    WFactory(const char* s) : _w(new W2()) {}\n    WFactory(WFactory&amp;&amp; f) : _w(std::move(f._w)) {}\n    ~WFactory() { _w.reset(nullptr); }\nprivate:\n    std::unique_ptr&lt;Widget&gt; _w;\n};\n\nint main()\n{\n    std::unique_ptr&lt;Widget&gt; a(new W1());\n    WFactory wf[] { 4, \"msg\" };          // OK\n}\n</code></pre>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-23T00:41:38.630", "Score": "8", "CreationDate": "2013-02-22T20:29:43.767", "ParentId": "15032501", "CommentCount": "6", "OwnerUserId": "1932150", "LastEditDate": "2013-02-23T00:41:38.630"}});