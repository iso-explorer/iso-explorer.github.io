post_cb({"1354336": {"ParentId": "1353407", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2009-08-30T17:09:53.530", "Score": "2", "LastEditorUserId": "33006", "LastEditDate": "2009-08-30T17:22:14.240", "Id": "1354336", "OwnerUserId": "33006", "Body": "<p>I found another relevant quote, <a href=\"http://www.dinkumware.com/manuals/?manual=compleat&amp;page=stdarg.html\" rel=\"nofollow noreferrer\">from Dinkumware</a>.</p>\n<blockquote>\n<p id=\"so_1353407_1354336_0\">The last parameter must not have\n  register storage class, and it must\n  have a type that is not changed by the\n  translator. It cannot have:</p>\n<pre><code>* an array type\n* a function type\n* type float\n* any integer type that changes when promoted\n* a reference type [C++ only]\n</code></pre>\n</blockquote>\n<p>So apparently, the problem is precisely that the parameter gets passed in a way different from how it is declared. Interestingly enough, they also ban float and short, even though those should be supported by the standard.</p>\n<p>As a hypothesis, it could be that some compilers have problems doing <code>sizeof</code> correctly on such parameters. E.g. it might be that, for</p>\n<pre><code>int f(int x[10])\n{\n        return sizeof(x);\n}\n</code></pre>\n<p>some (buggy) compiler will return <code>10*sizeof(int)</code>, thus breaking the <code>va_start</code> implementation.</p>\n", "LastActivityDate": "2009-08-30T17:22:14.240"}, "1353637": {"ParentId": "1353407", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2009-08-30T11:00:16.183", "Score": "6", "LastEditorUserId": "12711", "LastEditDate": "2009-08-30T11:31:55.260", "Id": "1353637", "OwnerUserId": "12711", "Body": "<p>The restriction against register parameters or function parameters are probably something like:</p>\n<ul>\n<li>you are not allowed to take the address of a variable with the <code>register</code> storage class.</li>\n<li>function pointers are sometimes quite different than pointers to objects.  For example, they might be larger than pointers to objects (you can't reliably convert a function pointer to an object pointer and back again), so adding some fixed number to the address of a function pointer might not get you to the next parameter. If <code>va_start()</code> and/or <code>va_arg()</code> were implemented by adding some fixed amount to the address of <code>paramN</code> and function pointers were larger than object pointers the calculation would end up with the wrong address for the object <code>va_arg()</code> returns.  This might not seem to be a great way to implement these macros, but there might be platforms that have (or even need) this type of implementation.</li>\n</ul>\n<p>I can't think of what the problem would be to prevent allowing array parameters, but PJ Plauger says this in his book \"The Standard C Library\":</p>\n<blockquote>\n<p id=\"so_1353407_1353637_0\">Some of the restrictions imposed on the macros defined in <code>&lt;stdarg.h&gt;</code> seem unnecessarily severe. For some implementations, they are. Each was introduced, however, to meet the needs of at least one serious C implementation.</p>\n</blockquote>\n<p>And I imagine that there are few people who know more about the ins and outs of the C library than Plauger. I hope someone can answer this specific question with an actual example; I think it would be an interesting bit of trivia.</p>\n<p>New info:</p>\n<hr>\n<p>The \"Rationale for International Standard - Programming Languages - C\" says this about <code>va_start()</code>:</p>\n<blockquote>\n<p id=\"so_1353407_1353637_1\">The <code>parmN</code> argument to <code>va_start</code> was intended to be an aid to implementors writing the \n  definition of a conforming <code>va_start</code> macro entirely in C, even using pre-C89 compilers (for example, by taking the address of the parameter).  The restrictions on the declaration of the <code>parmN</code> parameter follow from the intent to allow this kind of implementation, as applying the &amp; operator to a parameter name might not produce the intended result if the parameter\u2019s declaration did not meet these restrictions. </p>\n</blockquote>\n<p>Not that that helps me with the restriction on array parameters.</p>\n</hr>", "LastActivityDate": "2009-08-30T11:31:55.260"}, "1353407": {"CommentCount": "6", "ViewCount": "1031", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2009-08-30T08:10:34.467", "LastActivityDate": "2011-11-12T23:23:51.567", "Title": "Last named parameter not function or array?", "FavoriteCount": "4", "LastEditDate": "2011-11-12T23:04:43.863", "Id": "1353407", "Score": "16", "Body": "<p>This question is about vararg functions, and the last named parameter of them, before the ellipsis:</p>\n<pre><code>void f(Type paramN, ...) {\n  va_list ap;\n  va_start(ap, paramN);\n  va_end(ap);\n}\n</code></pre>\n<p>I was reading in the C Standard, and found the following restriction for the <code>va_start</code> macro:</p>\n<blockquote>\n<p id=\"so_1353407_1353407_0\">The parameter parmN is the identi\ufb01er of the rightmost parameter in the variable parameter list in the function de\ufb01nition (the one just before the , ...). If the parameter parmN is declared with the register storage class, with a function or array type, or with a type that is not compatible with the type that results after application of the default argument promotions, the behavior is unde\ufb01ned.</p>\n</blockquote>\n<p>I wonder why the behavior is undefined for the following code</p>\n<pre><code>void f(int paramN[], ...) {\n  va_list ap;\n  va_start(ap, paramN);\n  va_end(ap);\n}\n</code></pre>\n<p>and not undefined for the following</p>\n<pre><code>void f(int *paramN, ...) {\n  va_list ap;\n  va_start(ap, paramN);\n  va_end(ap);\n}\n</code></pre>\n<p>The macros are intended to be implementable by pure C code. But pure C code cannot find out whether or not <code>paramN</code> was declared as an array or as a pointer. In both cases, the type of the parameter is adjusted to be a pointer. The same is true for function type parameters. </p>\n<p>I wonder: What is the rationale of this restriction? Do some compilers have problems with implementing this when these parameter adjustments are in place internally? (The same undefined behavior is stated for C++ - so my question is about C++ aswell).</p>\n", "Tags": "<c++><c><arrays><variadic-functions>", "OwnerUserId": "34509", "AnswerCount": "5"}, "8108285": {"ParentId": "1353407", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-11-12T23:15:18.370", "Score": "1", "LastEditorUserId": "560648", "LastEditDate": "2011-11-12T23:23:51.567", "Id": "8108285", "OwnerUserId": "560648", "Body": "<p>C++11 says:</p>\n<blockquote>\n<p id=\"so_1353407_8108285_0\"><code>[n3290: 13.1/3]:</code> [..] Parameter declarations that differ only in a\n  pointer * versus an array [] are equivalent. That is, the array\n  declaration is adjusted to become a pointer declaration. [..]</p>\n</blockquote>\n<p>and C99 too:</p>\n<blockquote>\n<p id=\"so_1353407_8108285_1\"><code>[C99: 6.7.5.3/7]:</code> A declaration of a parameter as \u2018\u2018array of type\u2019\u2019 shall be adjusted to \u2018\u2018qualified pointer to\n  type\u2019\u2019, where the type qualifiers (if any) are those specified within the [ and ] of the\n  array type derivation. [..]</p>\n</blockquote>\n<p>And you said:</p>\n<blockquote>\n<p id=\"so_1353407_8108285_2\">But pure C code cannot find out whether or not <code>paramN</code> was declared as an array or as a pointer. In both cases, the type of the parameter is adjusted to be a pointer.</p>\n</blockquote>\n<p>Right, so there's no difference between the two pieces of code you showed us. Both have <code>paramN</code> declared as a pointer; there is actually no array type there at all.</p>\n<p>So why would there be a difference between the two when it comes to the UB?</p>\n<p>The passage you quoted...</p>\n<blockquote>\n<p id=\"so_1353407_8108285_3\">The parameter parmN is the identi\ufb01er of the rightmost parameter in the variable parameter list in the function de\ufb01nition (the one just before the , ...). <strong>If the parameter parmN is declared with the register storage class, with a function or array type, or with a type that is not compatible with the type that results after application of the default argument promotions, the behavior is undefined.</strong></p>\n</blockquote>\n<p>...applies to <em>neither</em>, as would be expected.</p>\n", "LastActivityDate": "2011-11-12T23:23:51.567"}, "1353539": {"ParentId": "1353407", "CommentCount": "4", "CreationDate": "2009-08-30T10:04:01.227", "OwnerUserId": "47984", "PostTypeId": "2", "Id": "1353539", "Score": "1", "Body": "<p>I can only guess that the <code>register</code> restriction is there to ease library/compiler implementation -- it eliminates a special case for them to worry about.</p>\n<p>But I have no clue about the array/function restriction.  If it were in the C++ standard only, I would hazard a guess that there is some obscure template matching scenario where the difference between a parameter of type <code>T[]</code> and of type <code>T*</code> makes a difference, correct handling of which would complicate <code>va_start</code> etc.  But since this clause appears in the C standard too, obviously that explanation is ruled out.</p>\n<p>My conclusion: an oversight in the standards.  Possible scenario: some pre-standard C compiler implemented parameters of type <code>T[]</code> and <code>T*</code> differently, and the spokesperson for that compiler on the C standards committee had the above restrictions added to the standard; that compiler later became obsolete, but no-one felt the restrictions were compelling enough to update the standard.</p>\n", "LastActivityDate": "2009-08-30T10:04:01.227"}, "1353460": {"ParentId": "1353407", "CommentCount": "2", "CreationDate": "2009-08-30T08:58:41.873", "OwnerUserId": "111335", "PostTypeId": "2", "Id": "1353460", "Score": "3", "Body": "<p>It's not undefined. Keep in mind that when parameter is declared as <code>int paramN[]</code>, the actual parameter type will still decay to <code>int* paramN</code> immediately (which is visible in C++, for example, if you apply <code>typeid</code> to <code>paramN</code>).</p>\n<p>I must admit that I'm not sure what this bit in the spec is even for, considering that you cannot have parameters of function or array types in the first place (since they will pointer-decay).</p>\n", "LastActivityDate": "2009-08-30T08:58:41.873"}, "bq_ids": {"n4140": {"so_1353407_8108285_0": {"section_id": 558, "quality": 0.8125, "length": 13}, "so_1353407_1353407_0": {"section_id": 6966, "quality": 0.5882352941176471, "length": 20}, "so_1353407_8108285_3": {"section_id": 6966, "quality": 0.6176470588235294, "length": 21}}, "n3337": {"so_1353407_8108285_0": {"section_id": 549, "quality": 0.8125, "length": 13}, "so_1353407_1353407_0": {"section_id": 6713, "quality": 0.6764705882352942, "length": 23}, "so_1353407_8108285_3": {"section_id": 6713, "quality": 0.7058823529411765, "length": 24}}, "n4659": {"so_1353407_8108285_0": {"section_id": 581, "quality": 0.8125, "length": 13}, "so_1353407_1353407_0": {"section_id": 8465, "quality": 0.5882352941176471, "length": 20}, "so_1353407_8108285_3": {"section_id": 8465, "quality": 0.6176470588235294, "length": 21}}}});