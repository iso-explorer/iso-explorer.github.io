post_cb({"7118395": {"Id": "7118395", "PostTypeId": "2", "Body": "<p>The <code>Test</code> instance lives until the <code>;</code> there. Whether the <code>buffer</code> reuses the storage used for the <code>Test</code> instance is unspecified. AFAIK, there is nothing in the standard preventing the compiler from reusing the space.</p>\n", "LastActivityDate": "2011-08-19T07:39:41.240", "CommentCount": "0", "CreationDate": "2011-08-19T07:39:41.240", "ParentId": "7118323", "Score": "1", "OwnerUserId": "341065"}, "7118323": {"ViewCount": "151", "Body": "<p>Consider the following code:</p>\n<pre><code>class Test() {\npublic:\n    Test()\n    {\n       memset( buffer, 0, sizeof( buffer ) );\n    }\n    void Process()\n    {\n       printf( buffer );\n    }\nprivate:\n    char buffer[1000];\n};\n\nint main()\n{\n    Test().Process();\n    char buffer[1000] = {};\n    print( buffer );\n    return 0;      \n}\n</code></pre>\n<p>I can't deduce whether <code>buffer</code> in main is allowed to reuse the memory previously occupied by the temporary object of <code>class Test</code>. According to The Standard automatic storage (3.7.2/1) <a href=\"https://stackoverflow.com/q/7103145/57428\">must persist for at least until the block ends</a>.</p>\n<p>I can't find phrasing that would force a temporary object to use automatic storage except 6.6/2 where a jump statement is described and says that <em>on exit from a scope [...], destructors (12.4) are called for all constructed objects with automatic storage duration (3.7.2) (named objects or temporaries)</em> which seems to imply that temporaries use automatic storage.</p>\n<p>Are temporaries required to use automatic storage? Is the local variable in <code>main</code> in code above allowed to reuse the memory previously occupied by the temporary or should it use distinct storage?</p>\n", "AcceptedAnswerId": "7118360", "Title": "What's the requirement for storage duration of temporaries?", "CreationDate": "2011-08-19T07:31:36.447", "Id": "7118323", "CommentCount": "3", "LastEditDate": "2017-05-23T12:19:52.960", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-19T08:47:59.910", "Score": "3", "OwnerUserId": "57428", "Tags": "<c++><memory><memory-management><duration>", "AnswerCount": "5"}, "7118513": {"Id": "7118513", "PostTypeId": "2", "Body": "<p>3.7.2/1 specifically discusses <em>block-scope variables</em>. Those do have storage that must last the block. However, as you discovered, temporaries <em>do</em> have automatic storage duration, but are not <em>block-scope variables</em>. (See 3.3.3, block scope is associated with names).</p>\n", "LastActivityDate": "2011-08-19T07:53:22.257", "CommentCount": "3", "CreationDate": "2011-08-19T07:53:22.257", "ParentId": "7118323", "Score": "3", "OwnerUserId": "15416"}, "7118423": {"Id": "7118423", "PostTypeId": "2", "Body": "<p>It's implementation defined. A smart compiler may optimize the code by aligning the stack pointer so that the memory can be reused by <code>buffer</code>.</p>\n", "LastActivityDate": "2011-08-19T07:43:19.083", "CommentCount": "0", "CreationDate": "2011-08-19T07:43:19.083", "ParentId": "7118323", "Score": "0", "OwnerUserId": "419391"}, "bq_ids": {"n4140": {"so_7118323_7118360_1": {"length": 14, "quality": 1.0, "section_id": 380}, "so_7118323_7118360_2": {"length": 12, "quality": 0.5714285714285714, "section_id": 381}, "so_7118323_7118360_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 382}}, "n3337": {"so_7118323_7118360_1": {"length": 14, "quality": 1.0, "section_id": 371}, "so_7118323_7118360_2": {"length": 12, "quality": 0.5714285714285714, "section_id": 372}, "so_7118323_7118360_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 373}}, "n4659": {"so_7118323_7118360_1": {"length": 14, "quality": 1.0, "section_id": 395}, "so_7118323_7118360_2": {"length": 12, "quality": 0.5714285714285714, "section_id": 396}, "so_7118323_7118360_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 397}}}, "7118369": {"Id": "7118369", "PostTypeId": "2", "Body": "<p>The syntax <code>Test()</code> creates a temporary. This is different from an object that is named:</p>\n<pre><code>Test iHaveAName;\n</code></pre>\n<p>A named object has block duration; it will live until the block ends. A temporary has expression duration; it will be destroyed when the expression it is on ends.</p>\n<p>So, if you do <code>Test().Process()</code>, the <code>Test()</code> temporary will live long enough for <code>Process()</code> to finish.</p>\n", "LastActivityDate": "2011-08-19T07:36:44.567", "CommentCount": "1", "CreationDate": "2011-08-19T07:36:44.567", "ParentId": "7118323", "Score": "2", "OwnerUserId": "734069"}, "7118360": {"Id": "7118360", "PostTypeId": "2", "Body": "<p>The lifetime of the temporary (unless bound to a <code>const&amp;</code>) extends to the end of the full expression. In your case the first line in <code>main</code>. The compiler is allowed to reuse the same memory, but whether it does or not is an implementation detail (i.e. <em>quality of implementation</em>)</p>\n<blockquote>\n<p id=\"so_7118323_7118360_0\">12.2 [class.temporary]</p>\n<p id=\"so_7118323_7118360_1\">/3 [...] Temporary objects are destroyed as the last step in evaluating\n  the full-expression (1.9) that (lexically) contains the point where they were created.[...]</p>\n<p id=\"so_7118323_7118360_2\">/4 There are two contexts in which temporaries are destroyed at a different point than the end of the full expression. The first context is when an expression appears as an initializer for a declarator defining an object. [...]</p>\n<p id=\"so_7118323_7118360_3\">/5 The second context is when a reference is bound to a temporary.</p>\n</blockquote>\n<p>Since you are in neither exception, the <code>Test</code> temporary falls into the first category and is <em>destroyed</em> as the last step of the evaluation of that first line.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-08-19T08:47:59.910", "Score": "6", "CreationDate": "2011-08-19T07:36:02.803", "ParentId": "7118323", "CommentCount": "14", "OwnerUserId": "36565", "LastEditDate": "2011-08-19T08:47:59.910"}});