post_cb({"bq_ids": {"n4140": {"so_34696351_34732843_0": {"length": 7, "quality": 1.0, "section_id": 200}, "so_34696351_34732843_3": {"length": 7, "quality": 1.0, "section_id": 200}, "so_34696351_34732843_10": {"length": 8, "quality": 0.5714285714285714, "section_id": 7027}, "so_34696351_34732843_4": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}, "so_34696351_34732843_1": {"length": 17, "quality": 1.0, "section_id": 194}, "so_34696351_34732843_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 204}}, "n3337": {"so_34696351_34732843_0": {"length": 7, "quality": 1.0, "section_id": 194}, "so_34696351_34732843_3": {"length": 7, "quality": 1.0, "section_id": 194}, "so_34696351_34732843_10": {"length": 8, "quality": 0.5714285714285714, "section_id": 6773}, "so_34696351_34732843_4": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}, "so_34696351_34732843_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 188}, "so_34696351_34732843_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 198}}, "n4659": {"so_34696351_34732843_0": {"length": 7, "quality": 1.0, "section_id": 206}, "so_34696351_34732843_3": {"length": 7, "quality": 1.0, "section_id": 206}, "so_34696351_34732843_10": {"length": 8, "quality": 0.5714285714285714, "section_id": 8524}, "so_34696351_34732843_1": {"length": 17, "quality": 1.0, "section_id": 200}, "so_34696351_34732843_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 210}}}, "34696351": {"ViewCount": "425", "Body": "<p>Consider the following code:</p>\n<pre><code>struct bar\n{\n  template &lt;typename U&gt;\n  void fun0() const {}\n};\n\ntemplate &lt;typename T&gt;\nstruct foo\n{\n  void\n  fun1(const bar&amp; d)\n  {\n    // (1) KO\n    fun2(d).fun0&lt;int&gt;();\n    // (2) OK\n    fun2(d).template fun0&lt;int&gt;();\n    // (3) OK        \n    d.fun0&lt;int&gt;();\n  }\n\n  bar\n  fun2(const bar&amp; d)\n  {\n    return d;\n  }\n};\n</code></pre>\n<p>Lines (2) and (3) compile, but (1) fails with: </p>\n<pre><code>error: use 'template' keyword to treat 'fun0' as a dependent template name\n    fun2(d).fun0&lt;int&gt;();\n\n            ^\n            template \n</code></pre>\n<p>(As expected, if <code>foo</code> is no longer a template struct, (1) compiles as well)</p>\n<p>Why is <code>bar::fun0</code> a dependent template name here? <code>bar</code> doesn't depend on the template parameter <code>T</code> of <code>foo</code>.</p>\n<p>Edit:</p>\n<p>Clearly, <code>bar::fun2</code> is responsible for the ambiguity that the <code>.template</code> deal with. For instance, let's add the 2 following free functions:</p>\n<pre><code>bar\nfun3(const bar&amp; d)\n{\n  return d;\n}\n\ntemplate &lt;typename T&gt;\nT\nfun4(const T&amp; d)\n{\n  return d;\n}\n</code></pre>\n<p><code>fun3(d).fun0&lt;int&gt;()</code> and <code>fun4(d).fun0&lt;int&gt;()</code>) also compile in the context of <code>foo::fun1</code>. So the ambiguity is caused by the template parameter of <code>foo</code>.</p>\n<p>Why is <code>fun2(d).fun0&lt;int&gt;()</code> not parsed as a call to a member function template?</p>\n", "AcceptedAnswerId": "34732843", "Title": "Template dependent typename", "CreationDate": "2016-01-09T17:03:31.230", "Id": "34696351", "CommentCount": "10", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2016-01-12T06:25:04.613", "LastEditorUserId": "21584", "LastActivityDate": "2016-01-12T06:36:30.573", "Score": "15", "OwnerUserId": "21584", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "1"}, "34732843": {"Id": "34732843", "PostTypeId": "2", "Body": "<p>I think this comes down to the rules in section <code>14.6.2</code> of the standard. Basically, I think the rules err on the side of caution in requiring you to use <code>template</code> and <code>typename</code> -- once you form an expression which might potentially be dependent, sometimes it will be declared so according to the rules, even though a human can plainly see that it isn't actually dependent. Then, there is a general rule <code>14.6.2.2.1</code> which states</p>\n<blockquote>\n<p id=\"so_34696351_34732843_0\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n</blockquote>\n<p>What I think is happening is that the expression <code>fun2(d)</code> is declared to be type-dependent by the rules, <em>even though</em> that type is in fact the same in every instantiation of this (primary) template, as you and I can see -- this is why it's surprising that <code>template</code> is required.</p>\n<p>Under <code>14.6.2.1.4</code> in the C++11 (or C++14) standard,</p>\n<blockquote>\n<p id=\"so_34696351_34732843_1\">A name is a <em>dependent member of the current instantiation</em> if it is a member of the current instantiation\n  that, when looked up, refers to at least one member of a class that is the current instantiation.</p>\n</blockquote>\n<p>That means, the name <code>fun2</code> is a <em>dependent name</em>, even though <code>fun2</code> does not refer to <code>T</code> or anything that explicitly depends on <code>T</code>.</p>\n<p>Thus when we consider the expression you gave <code>fun2(d).fun0&lt;int&gt;()</code>, and consider the \"member access subexpression\", that is, <code>fun2(d)</code> <strong><code>.</code></strong> <code>fun0&lt;int&gt;</code> -- intuitively we want to say that this is not dependent, as <code>fun2(d)</code> is always of type <code>bar</code> and <code>fun0&lt;int&gt;</code> doesn't depend on <code>T</code> either. There is rule <code>14.6.2.2.5</code> which states</p>\n<blockquote>\n<p id=\"so_34696351_34732843_2\">A class member access expression (5.2.5) is type-dependent if the expression refers to a member of the current\n  instantiation and the type of the referenced member is dependent, or the class member access expression\n  refers to a member of an unknown specialization.</p>\n</blockquote>\n<p>Neither of these conditions applies literally, since <code>bar</code> is not the same type as the current instantiation (<code>foo&lt;T&gt;</code>), and neither is <code>fun0&lt;int&gt;</code> a member of an unknown specialization of the <code>foo</code> template. This is why the expression <code>d.fun0&lt;int&gt;()</code> is well-formed.</p>\n<p>However, note clearly that this rule <code>14.6.2.2.5</code> comes after <code>14.6.2.2.1</code> which sets up the meaning of this entire section:</p>\n<blockquote>\n<p id=\"so_34696351_34732843_3\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n</blockquote>\n<p>Thus if any subexpression, such as <code>fun2</code>, is formally \"type-dependent\", it poisons the entire expression, and causes similar rules to apply as if we were looking up members of template parameters or unknown specializations, etc. etc.</p>\n<p>Specifically, the <code>type-dependent</code> condition means that you need the <code>template</code> prefix, because of rule 14.2.4:</p>\n<blockquote>\n<p id=\"so_34696351_34732843_4\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a postfix-expression or after a\n  nested-name-specifier in a qualified-id, and the object expression of the postfix-expression is type-dependent\n  or the nested-name-specifier in the qualified-id refers to a dependent type, but the name is not a member of\n  the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword template.\n  Otherwise the name is assumed to name a non-template.</p>\n<p id=\"so_34696351_34732843_5\">Example:  </p>\n</blockquote>\n<pre><code>struct X {\n  template&lt;std::size_t&gt; X* alloc();\n  template&lt;std::size_t&gt; static X* adjust();\n};\ntemplate&lt;class T&gt; void f(T* p) {\n  T* p1 = p-&gt;alloc&lt;200&gt;();          // ill-formed: &lt; means less than\n  T* p2 = p-&gt;template alloc&lt;200&gt;(); // OK: &lt; starts template argument list\n  T::adjust&lt;100&gt;();                 // ill-formed: &lt; means less than\n  T::template adjust&lt;100&gt;();        // OK: &lt; starts template argument list\n}  \n</code></pre>\n<blockquote>\n<p id=\"so_34696351_34732843_6\">\u2014 end example ]</p>\n</blockquote>\n<p>Now very concretely:</p>\n<ol>\n<li><p>By [14.2.4], in the postfix expression <code>fun2(d)</code> <code>.</code> <code>fun0&lt;int&gt;</code>, if the object expression <code>fun2(d)</code> is <em>type-dependent</em>, then you have to use <code>template</code> prefix to call the member template.</p></li>\n<li><p>Under [14.6.2.2.1], if <code>fun2</code> is <em>type-dependent</em> then that forces <code>fun2(d)</code> to be also.</p></li>\n<li><p>And under [14.6.2.1.4], since <code>fun2</code> when looked up refers to a member of the <code>foo</code> class template, that alone is enough to make it a <em>dependent member of the current instantiation</em>.</p></li>\n</ol>\n<p>I don't have a totally clear argument from any of the rules that if a name refers to a <em>dependent member of the current instantiation</em>, then that implies that the expression corresponding to the name is <code>type-dependent</code>... and I have searched a few times now.</p>\n<p>However, this viewpoint is advocated in @Johannes Schaub - litb's <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords\">highly up-voted (but simplified, and non-normative) exposition of the rules</a>:</p>\n<blockquote>\n<p id=\"so_34696351_34732843_7\"><strong>Dependent names</strong></p>\n<p id=\"so_34696351_34732843_8\">The Standard is a bit unclear about what exactly is a dependent name. On a simple read (you know, the principle of least surprise), all it defines as a dependent name is the special case for function names below. But since clearly T::x also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</p>\n<p id=\"so_34696351_34732843_9\">To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore \"dependent names\". A name can take different forms - the Standard says:</p>\n<p id=\"so_34696351_34732843_10\">A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</p>\n<p id=\"so_34696351_34732843_11\">An identifier is just a plain sequence of characters / digits, while the next two are the operator + and operator type form. The last form is template-name . All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</p>\n</blockquote>\n<p>Would be great to get a more concrete explanation of that last part.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-12T06:36:30.573", "Score": "4", "CreationDate": "2016-01-11T23:09:47.357", "ParentId": "34696351", "CommentCount": "2", "OwnerUserId": "3598119", "LastEditDate": "2017-05-23T11:45:14.343"}});