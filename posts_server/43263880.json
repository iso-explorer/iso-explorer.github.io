post_cb({"43264189": {"Id": "43264189", "PostTypeId": "2", "Body": "<p>I've noticed the following inside <code>&lt;cstdlib&gt;</code>:  </p>\n<pre><code>#ifndef __CORRECT_ISO_CPP_STDLIB_H_PROTO\n  inline long\n  abs(long __i) { return __builtin_labs(__i); }\n  //...\n</code></pre>\n<p>When I try your example using <code>long</code>,  </p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nlong abs(long n) {\n    return n &gt; 0 ? n : -n;\n}\n\nusing namespace std;\n\nint main() {\n    long k;\n\n    cin &gt;&gt; k;\n\n    cout &lt;&lt; abs(k) &lt;&lt; endl;\n}\n</code></pre>\n<p>I get the expected error: </p>\n<pre><code>error: call of overloaded 'abs(long int&amp;)' is ambiguous\n</code></pre>\n<p>Maybe your implementation is doing something similar.</p>\n", "LastEditorUserId": "908939", "LastActivityDate": "2017-04-06T19:35:10.047", "Score": "-1", "CreationDate": "2017-04-06T19:29:26.723", "ParentId": "43263880", "CommentCount": "5", "OwnerUserId": "908939", "LastEditDate": "2017-04-06T19:35:10.047"}, "43264411": {"Id": "43264411", "PostTypeId": "2", "Body": "<p>Let's modify this code to this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nint abs(int n) {\n    std::cout &lt;&lt; \"default abs\\n\";\n    return n &gt; 0 ? n : -n;\n}\n\n//using namespace std;\n\nint main() {\n    int k;\n\n    std::cin &gt;&gt; k;\n\n    std::cout &lt;&lt; std::abs(k) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It STILL will call your abs. Strange , huh? Ok, actually there is no <code>int abs(int)</code> function in std namespace. There is no ambiguous call here, depending on used platform, because actual abs defined as equal to this:</p>\n<pre><code>std::intmax_t abs( std::intmax_t n );\n</code></pre>\n<p>But actual implementation may vary, depending on a number of factors.\nWhat you've did is that you had either had overload the function or a template. As long as you won't hit the exact definition in header file, your function will be used if it matches better to arguments. It may be tried as candidate by std templates instead of std::abs() function if std namespace is used globally. That's one of caveats behind using namespace std in global scope.</p>\n<p>in fact, on my system std::abs defined as an abs from global scope:\n Of course, you have a function from global scope with such prototype, defined by yourself, so std::abs call in my case is equal to ::abs call. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nint abs( long n ) {\n    std::cout &lt;&lt; \"default abs\\n\";\n    return n &gt; 0 ? n : -n;\n}\n\n//using namespace std;\n\nint main() {\n    int k;\n\n    std::cin &gt;&gt; k;\n\n    std::cout &lt;&lt; std::abs(k) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Now it uses standard library function and outputs absolute value of k. </p>\n<p>Let's see what cstdlib header contains in particular case:</p>\n<pre><code>_STD_BEGIN\nusing _CSTD size_t; using _CSTD div_t; using _CSTD ldiv_t;   \nusing _CSTD abort; using _CSTD abs; using _CSTD atexit;\n// and so on..\n_STD_END\n</code></pre>\n<p>_STD_BEGIN defined as</p>\n<pre><code>#define _STD_BEGIN  namespace std {\n</code></pre>\n<p>Effectively we have</p>\n<pre><code>namespace std {\n     using ::abs;\n}\n</code></pre>\n<p><strong>This way anything that got identifier abs in global scope becomes  std::abs</strong> This got force of forward declaration, so abs() defined after this definition is  the subject. Because language syntax allows that, redefining library identifiers in global scope might result in ill-formed program or to UB,  which in this case comes down to which declarations are active in header.</p>\n<blockquote>\n<p id=\"so_43263880_43264411_0\">The C++ standard library reserves the following kinds of names: </p>\n<ul>\n<li>macros </li>\n<li>global names </li>\n<li>names with external linkage </li>\n</ul>\n<p id=\"so_43263880_43264411_1\">If a program declares or defines a name in a context where it is\n  reserved, other than as explicitly allowed by this Clause, its\n  behavior is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "2742717", "LastActivityDate": "2017-04-06T21:22:00.043", "Score": "-1", "CreationDate": "2017-04-06T19:42:25.910", "ParentId": "43263880", "CommentCount": "13", "OwnerUserId": "2742717", "LastEditDate": "2017-04-06T21:22:00.043"}, "43263880": {"ViewCount": "412", "Body": "<p>The following code generates <code>call of overloaded \u2018bar()\u2019 is ambiguous</code> error which it should be as I have a function <code>bar</code> in both global and <code>foo</code> namespace and I have called <code>using namespace foo</code> directive.</p>\n<pre><code>namespace foo {\n    void bar() {}\n}\n\nvoid bar() {}\n\nusing namespace foo;\n\nint main() {\n    bar();\n}\n</code></pre>\n<p>I was expecting the same error with the following code too:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nint abs(int n) {\n    return n &gt; 0 ? n : -n;\n}\n\nusing namespace std;\n\nint main() {\n    int k;\n\n    cin &gt;&gt; k;\n\n    cout &lt;&lt; abs(k) &lt;&lt; endl;\n}\n</code></pre>\n<p>I have defined a function <code>int abs(int n)</code> like the one present in <a href=\"http://en.cppreference.com/w/cpp/numeric/math/abs\" rel=\"noreferrer\">cstlib</a> and I have called <code>using namespace std</code> directive. So there should have been an error like the first example. But there is none. </p>\n<p>My question is how the compiler is resolving this ambiguity? Which function will be called in such cases, mine or <code>std</code>'s one? Is there any UB involved here?</p>\n<p><strong>Update</strong>: From comments and answers it seems that different compilers are behaving differently. So is this behavior undefined or implementation defined?</p>\n<p>I have tested it with <code>g++ 4.8.4</code> on <code>Ubuntu 14.04</code> with <code>-std=c++11</code> flag.</p>\n<p>[Please note that I do understand that <code>using namespace std</code> is bad and my <code>abs</code> function is no better or even worse than <code>std</code> one. My question is different.]</p>\n", "AcceptedAnswerId": "43264471", "Title": "No ambiguous reference error even after using namespace directive", "CreationDate": "2017-04-06T19:12:05.693", "Id": "43263880", "CommentCount": "14", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-04-06T19:53:01.593", "LastEditorUserId": "377953", "LastActivityDate": "2017-04-08T13:38:08.123", "Score": "10", "OwnerUserId": "377953", "Tags": "<c++><c++11><namespaces>", "AnswerCount": "5"}, "43294812": {"Id": "43294812", "PostTypeId": "2", "Body": "<p>If <code>abs</code> function is declared in following way: </p>\n<p><code>void abs(int n) {\n    return n &gt; 0 ? n : -n;\n}\n</code>\n(return type is changed from <code>int</code> to <code>void</code>)</p>\n<p>this will raise <code>error: ambiguating new declaration of 'void abs(int)'</code></p>\n<p>Because in <code>stdlib</code> it it declared as <code>int abs(int n)</code> but we're defining it now with another return type.</p>\n<p><strong>So why it is not complaining when I defining it with correct return type?</strong></p>\n<p>First of all, implementation of <code>int abs(int k)</code> resides in compiled form (standard library) not in source form. So it is not possible to to tell (before linking) if any <code>int abs(int k)</code> is already defined or not. So compiler is happy with declaration in <code>cstdlib</code> and definition in our provided source. And when it starts linking it only search for function's which is declared but not defined yet(so that it can copy the definition (assumed linking against a static library)). So linker won't search for another definition of <code>int abs(int k)</code>. Finally our given definition is included in resulting binary.</p>\n", "LastActivityDate": "2017-04-08T13:38:08.123", "CommentCount": "0", "CreationDate": "2017-04-08T13:38:08.123", "ParentId": "43263880", "Score": "1", "OwnerUserId": "5765771"}, "43266024": {"Id": "43266024", "PostTypeId": "2", "Body": "<p>The problem is that <a href=\"https://developers.redhat.com/blog/2016/02/29/why-cstdlib-is-more-complicated-than-you-might-think/\" rel=\"noreferrer\"><code>&lt;cstdlib&gt;</code> is really complicated</a> due to the interactions between the C headers and the C++ headers. In libstdc++, it's not implemented as:</p>\n<pre><code>namespace std {\n    int abs(int );\n}\n</code></pre>\n<p>If that were the case, then your sample program with <code>std::abs</code> would match your expectation about your sample program with <code>foo::bar</code>, for precisely the same reasons. But instead, it's declared as something like:</p>\n<pre><code>// from &lt;stdlib.h&gt;\nextern int abs(int );\n\n// from &lt;cstdlib&gt;\n#include &lt;stdlib.h&gt;\n\nnamespace std {\n    using ::abs;\n}\n</code></pre>\n<p>When you declared and defined your own <code>::abs(int )</code>, that is simply a redeclaration of the previously declared <code>int ::abs(int )</code>. You're not overloading anything - there is just one <code>int ::abs(int)</code> in this translation unit! You could see that if you tried to declare something like <code>long abs(int )</code> - you'd get an error about redeclaration with a different return type.</p>\n<p>This works because <code>::abs</code> in the C header isn't defined (otherwise you'd get a compile error on a redefinition) - you bring that definition in through the shared library. And so you end up with an ODR violation because you have your definition in the TU and the shared library definition in GLIBC, and hence, undefined behavior. I'm not sure why the linker doesn't catch it. </p>\n", "LastActivityDate": "2017-04-06T21:25:21.567", "CommentCount": "3", "CreationDate": "2017-04-06T21:25:21.567", "ParentId": "43263880", "Score": "5", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_43263880_43264471_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6310}, "so_43263880_43264411_1": {"length": 14, "quality": 1.0, "section_id": 6304}, "so_43263880_43264411_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6303}, "so_43263880_43264471_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 6259}}, "n3337": {"so_43263880_43264471_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6067}, "so_43263880_43264411_1": {"length": 14, "quality": 1.0, "section_id": 6061}, "so_43263880_43264411_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6060}, "so_43263880_43264471_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 6019}}, "n4659": {"so_43263880_43264471_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7820}, "so_43263880_43264411_1": {"length": 14, "quality": 1.0, "section_id": 7814}, "so_43263880_43264411_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7813}, "so_43263880_43264471_0": {"length": 41, "quality": 0.8541666666666666, "section_id": 7763}}}, "43264471": {"Id": "43264471", "PostTypeId": "2", "Body": "<p>In the C++ standard section <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf#subsection.17.6.1\" rel=\"nofollow noreferrer\"><strong>17.6.1 Library contents and organization</strong></a>, we read in 17.6.1.2:</p>\n<blockquote>\n<p id=\"so_43263880_43264471_0\">Except as noted in Clauses 18 through 30 and Annex D, the contents of\n  each header cname shall be the same as that of the corresponding\n  header name.h , as specified in the C standard library (1.2) or the C\n  Unicode TR, as appropriate, as if by inclusion. In the C\n  ++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope (3.3.6) of the\n  namespace std. <strong>It is unspecified whether these names are first\n  declared within the global namespace scope and are then injected into\n  namespace std by explicit using-declarations (7.3.3).</strong></p>\n</blockquote>\n<p><sup>emphasis added</sup></p>\n<p>Additionally, in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf#subsection.17.6.4\" rel=\"nofollow noreferrer\"><strong>17.6.4.3.2 External linkage</strong></a> we read</p>\n<blockquote>\n<p id=\"so_43263880_43264471_1\">Each name from the Standard C library declared with external linkage\n  is reserved to the implementation for use as a name with extern \"C\"\n  linkage, both in namespace std and in the global namespace</p>\n</blockquote>\n<p>In plain English from this section and similar, C standard library names are reserved, but C standard library names are only in the global namespace scope.</p>\n<p>What GLIBCXX is doing here is perfectly valid; it's declaring an <code>abs</code> in the global namespace scope and injecting it into <code>std</code> using using-declarations.</p>\n<p>Indeed, in the standard library that my system / g++ 4.8.5 and 6.3.0 use (6.3.0 I checked on coliru), <code>&lt;cstdlib&gt;</code> looks something like this:</p>\n<pre><code>// &lt;stdlib.h&gt;:\n\nextern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;\n</code></pre>\n<pre><code>// &lt;cstdlib&gt;\n\n#include &lt;stdlib.h&gt;\n\nnamespace std\n{\n    using ::abs;\n}\n</code></pre>\n<p>It's that <code>using ::abs</code> which makes <code>std::abs</code> call your function.</p>\n<p>You violate the ODR because the GLIBC is a shared library and it also provides an implementation for <code>int abs(int)</code>.</p>\n<p>That you don't get a \"multiple definition of <code>abs(int)</code>\" linker error is arguably a bug in the compilers; it would be nice if they warned as about this undefined behavior.</p>\n<hr>\n<p>This can be reproduced with this example:</p>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nint myabs(int);\n\nnamespace foo {\n    int myabs(int n) {\n        return ::myabs(n);\n    }\n}\n\nint myabs(int n) {\n    std::cout &lt;&lt; \"myabs inside main.cpp\\n\";\n    return n &gt; 0 ? n : -n;\n}\n\nusing namespace foo;\n\nint main() {\n    int k = -1;\n\n    std::cout &lt;&lt; foo::myabs(k) &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>myabs.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nint myabs(int n) {\n    std::cout &lt;&lt; \"myabs inside myabs.cpp\\n\";\n    return n &gt; 0 ? n : -n;\n}\n</code></pre>\n<p>Then on the commandline:</p>\n<pre><code>g++ -fPIC -c myabs.cpp\ng++ -shared myabs.o -o libmyabs.so\ng++ -L. main.cpp -lmyabs\n</code></pre>\n<p>Running <code>./a.out</code> calls the <code>myabs</code> defined inside <strong>main.cpp</strong>, whereas if you comment out the <code>myabs</code> in <strong>main.cpp</strong>, it calls the one from <strong>myabs.cpp</strong></p>\n<hr>\n<h2>How to avoid this problem</h2>\n<p>If you avoid declaring functions in the global namespace, you should mostly avoid this problem.</p>\n<p>For your example, if we instead write:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nnamespace {\n    int abs(int n) {\n        return n &gt; 0 ? n : -n;\n    }\n}\n\nusing namespace std;\n\nint main() {\n    int k;\n\n    cin &gt;&gt; k;\n\n    cout &lt;&lt; abs(k) &lt;&lt; endl;\n}\n</code></pre>\n<p>We get the expected error warning about the call being ambiguous. However, be warned that this doesn't solve the problem if the standard library declares <code>abs</code> in the global namespace:</p>\n<pre><code>int main() {\n    int k;\n\n    cin &gt;&gt; k;\n\n    cout &lt;&lt; ::abs(k) &lt;&lt; endl;\n}\n</code></pre>\n<p>That seems to just call the standard library version. Naturally, this problem can be avoided by avoiding <code>using namespace std</code></p>\n</hr></hr>", "LastEditorUserId": "1896169", "LastActivityDate": "2017-04-06T21:43:22.453", "Score": "6", "CreationDate": "2017-04-06T19:46:02.243", "ParentId": "43263880", "CommentCount": "2", "OwnerUserId": "1896169", "LastEditDate": "2017-04-06T21:43:22.453"}});