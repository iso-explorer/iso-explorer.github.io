post_cb({"14085620": {"CommentCount": "2", "AcceptedAnswerId": "14085710", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-29T20:23:48.380", "LastActivityDate": "2012-12-30T14:44:56.200", "LastEditDate": "2017-05-23T11:45:35.777", "ViewCount": "4614", "FavoriteCount": "18", "Title": "Why do C++11-deleted functions participate in overload resolution?", "Id": "14085620", "Score": "78", "Body": "<p>Why does C++11 make <a href=\"https://stackoverflow.com/a/13951621/541686\">\"<code>delete</code>d\" functions participate in overload resolution</a>?<br>\nWhy is this useful? Or in other words, why are they hidden instead of being deleted entirely?</br></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "541686", "AnswerCount": "2"}, "14086455": {"ParentId": "14085620", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The C++ Working Draft 2012-11-02 doesn't provide a rationale behind this rule, just some examples</p>\n<blockquote>\n<p id=\"so_14085620_14086455_0\"><strong>8.4.3 Deleted definitions [dcl.fct.def.delete]</strong><br>\n  ...<br>\n  3 [ <em>Example</em>: One can enforce non-default initialization and non-integral initialization with  </br></br></p>\n</blockquote>\n<pre><code>struct onlydouble {  \n  onlydouble() = delete; // OK, but redundant  \n  onlydouble(std::intmax_t) = delete;  \n  onlydouble(double);  \n};  \n</code></pre>\n<blockquote>\n<p id=\"so_14085620_14086455_1\">\u2014 <em>end example</em> ]<br>\n  [ <em>Example</em>: One can prevent use of a class in certain new expressions by using deleted definitions of a\n  user-declared operator new for that class.  </br></p>\n</blockquote>\n<pre><code>struct sometype {  \n  void *operator new(std::size_t) = delete;  \n  void *operator new[](std::size_t) = delete;  \n};  \nsometype *p = new sometype; // error, deleted class operator new  \nsometype *q = new sometype[3]; // error, deleted class operator new[]  \n</code></pre>\n<blockquote>\n<p id=\"so_14085620_14086455_2\">\u2014 <em>end example</em> ]<br>\n  [ <em>Example</em>: One can make a class uncopyable, i.e. move-only, by using deleted definitions of the copy\n  constructor and copy assignment operator, and then providing defaulted definitions of the move constructor\n  and move assignment operator.  </br></p>\n</blockquote>\n<pre><code>struct moveonly {  \n  moveonly() = default;  \n  moveonly(const moveonly&amp;) = delete;  \n  moveonly(moveonly&amp;&amp;) = default;  \n  moveonly&amp; operator=(const moveonly&amp;) = delete;  \n  moveonly&amp; operator=(moveonly&amp;&amp;) = default;  \n  ~moveonly() = default;  \n};  \nmoveonly *p;  \nmoveonly q(*p); // error, deleted copy constructor  \n</code></pre>\n<blockquote>\n<p id=\"so_14085620_14086455_3\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n", "OwnerUserId": "1741542", "LastEditorUserId": "1741542", "LastEditDate": "2012-12-29T23:24:17.710", "Id": "14086455", "Score": "9", "CreationDate": "2012-12-29T22:25:46.693", "LastActivityDate": "2012-12-29T23:24:17.710"}, "14085710": {"ParentId": "14085620", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>Half of the purpose of the <code>= delete</code> syntax is to be able to prevent people from calling certain functions with certain parameters. This is mainly to prevent implicit conversions in certain specific scenarios. In order to forbid a particular overload, it has to participate in overload resolution.</p>\n<p>The answer you cite gives you a perfect example:</p>\n<pre><code>struct onlydouble {\n  onlydouble(std::intmax_t) = delete;\n  onlydouble(double);\n};\n</code></pre>\n<p>If <code>delete</code> removed the function entirely, that would make the <code>= delete</code> syntax equivalent to this:</p>\n<pre><code>struct onlydouble2 {\n  onlydouble2(double);\n};\n</code></pre>\n<p>You could do this:</p>\n<pre><code>onlydouble2 val(20);\n</code></pre>\n<p>This is legal C++. The compiler will look at all constructors; none of them take an integer type directly. But one of them can take it after an implicit conversion. So it'll call that.</p>\n<pre><code>onlydouble val(20);\n</code></pre>\n<p>This is <em>not</em> legal C++. The compiler will look at all constructors, including the <code>delete</code>d ones. It will see an exact match, via <code>std::intmax_t</code> (which will exactly match any integer literal). So the compiler will select it and then immediately issue an error, because it selected a <code>delete</code>d function.</p>\n<p><code>= delete</code> means \"I forbid this,\" not merely, \"This does not exist.\" It's a much stronger statement.</p>\n<blockquote>\n<p id=\"so_14085620_14085710_0\">I was asking why the C++ standard says = delete means \"I forbid this\" instead of \"this does not exist\"</p>\n</blockquote>\n<p>It's because we don't need special grammar to say \"this does not exist.\" We get this implicitly by simply not declaring the particular \"this\" in question. \"I forbid this\" represents a construct that <em>cannot</em> be achieved without special grammar. So we get special grammar to say \"I forbid this\" and not the other thing.</p>\n<p>The only functionality you would gain by having an explicit \"this does not exist\" grammar would be to prevent someone from later declaring it to exist. And that's just not useful enough to need its own grammar.</p>\n<blockquote>\n<p id=\"so_14085620_14085710_1\">there is otherwise no way to declare that the copy constructor does not exist, and its existence can cause nonsensical ambiguities.</p>\n</blockquote>\n<p>The copy constructor is a special member function. Every class <em>always</em> has a copy constructor. Just as they always have a copy assignment operator, move constructor, etc.</p>\n<p>These functions exist; the question is only whether it is legal to call them. If you tried to say that <code>= delete</code> meant that they didn't exist, then the specification would have to explain what it means for a function to not exist. This is not a concept that the specification handles.</p>\n<p>If you attempt to call a function that hasn't been declared/defined yet, then the compiler will error. But it will error because of an <em>undefined identifier</em>, not because of a \"function doesn't exist\" error (even if your compiler reports it that way). Various constructors are all called by overload resolution, so their \"existence\" is handled in that regard.</p>\n<p>In every case, there is either a function declared via identifier, or a constructor/destructor (also declared via identifier, just a type-identifier). Operator overloading hides the identifier behind syntactic sugar, but it's still there.</p>\n<p>The C++ specification cannot handle the concept of a \"function that does not exist.\" It can handle an overload mismatch. It can handle an overload ambiguity. But it doesn't know about what isn't there. So <code>= delete</code> is defined in terms of the far more useful \"attempts to call this fail\" rather than the less useful \"pretend I never wrote this line.\"</p>\n<p>And again, re-read the first part. You <em>cannot do that</em> with \"function doesn't exist.\" That's another reason why it's defined that way: because one of the main use cases of the <code>= delete</code> syntax is to be able to force the user to use certain parameter types, to explicitly cast, and so forth. Basically, to foil implicit type conversions.</p>\n<p>Your suggestion would not do that.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2012-12-30T14:44:56.200", "Id": "14085710", "Score": "100", "CreationDate": "2012-12-29T20:37:14.683", "LastActivityDate": "2012-12-30T14:44:56.200"}, "bq_ids": {"n4140": {"so_14085620_14086455_2": {"section_id": 3278, "quality": 0.8846153846153846, "length": 23}, "so_14085620_14086455_1": {"section_id": 3278, "quality": 0.8333333333333334, "length": 15}, "so_14085620_14086455_0": {"section_id": 3278, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_14085620_14086455_2": {"section_id": 3149, "quality": 0.8846153846153846, "length": 23}, "so_14085620_14086455_1": {"section_id": 3149, "quality": 0.8333333333333334, "length": 15}, "so_14085620_14086455_0": {"section_id": 3149, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_14085620_14086455_2": {"section_id": 4036, "quality": 0.8846153846153846, "length": 23}, "so_14085620_14086455_1": {"section_id": 4036, "quality": 0.7222222222222222, "length": 13}}}});