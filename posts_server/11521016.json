post_cb({"11521016": {"CommentCount": "6", "AcceptedAnswerId": "11521166", "CreationDate": "2012-07-17T10:54:01.757", "LastActivityDate": "2012-07-17T11:02:12.570", "PostTypeId": "1", "ViewCount": "4447", "FavoriteCount": "3", "Title": "narrowing conversion from unsigned to double", "Id": "11521016", "Score": "24", "Body": "<pre><code>static_assert(sizeof(unsigned) == 4, \":(\");\nstatic_assert(sizeof(double) == 8 ,\":(\");\nunsigned u{42};\ndouble x{u};\n</code></pre>\n<p>g++ 4.7.1 complains about this code:</p>\n<pre><code>warning: narrowing conversion of 'u' from 'unsigned int' to 'double' inside { }\n</code></pre>\n<p>Why is this a narrowing conversion? Isn't every <code>unsigned</code> perfectly representable as a <code>double</code>? </p>\n", "Tags": "<c++><c++11><warnings><double><type-conversion>", "OwnerUserId": "252000", "AnswerCount": "3"}, "11521159": {"ParentId": "11521016", "CommentCount": "0", "Body": "<p>(Let's try:) <code>double</code> has exactly 52 bits of significant (binary) digits (according to ieee standard), whereas <code>unsigned int</code> may have good 64 bits on some other system. So the actual <code>unsigned int</code>'s width on your system may be of no value for this check.</p>\n", "OwnerUserId": "276994", "PostTypeId": "2", "Id": "11521159", "Score": "0", "CreationDate": "2012-07-17T11:01:41.933", "LastActivityDate": "2012-07-17T11:01:41.933"}, "11521154": {"ParentId": "11521016", "CommentCount": "0", "Body": "<p>The warning you have because you initialize x with non-constant expression</p>\n<pre><code>Ilyas-iMac:TestC++11 sandye51$ cat main.cpp                   \nint main()\n{\n    static_assert(sizeof(unsigned) == 4, \":(\");\n    static_assert(sizeof(double) == 8 ,\":(\");\n    constexpr unsigned u{42};\n    double x{u};\n\n    return 0;\n}Ilyas-iMac:TestC++11 sandye51$ gcc -o main main.cpp -std=c++11\nIlyas-iMac:TestC++11 sandye51$ \n</code></pre>\n<p>As you can see the code above works without any warning or errors</p>\n", "OwnerUserId": "1528866", "PostTypeId": "2", "Id": "11521154", "Score": "3", "CreationDate": "2012-07-17T11:01:37.467", "LastActivityDate": "2012-07-17T11:01:37.467"}, "bq_ids": {"n4140": {"so_11521016_11521166_1": {"section_id": 3329, "quality": 0.9090909090909091, "length": 30}}, "n3337": {"so_11521016_11521166_1": {"section_id": 3199, "quality": 0.9090909090909091, "length": 30}}, "n4659": {"so_11521016_11521166_1": {"section_id": 4095, "quality": 0.9090909090909091, "length": 30}}}, "11521166": {"ParentId": "11521016", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_11521016_11521166_0\">Why is this a narrowing conversion? </p>\n</blockquote>\n<p>Because the definition includes (with my emphasis):</p>\n<blockquote>\n<p id=\"so_11521016_11521166_1\"><strong>C++11 8.5.4/7</strong> A <em>narrowing conversion</em> is an implicit conversion\n  [...] from an integer type [...] to a floating-point type, <strong>except where the source is a constant expression</strong> and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type.</p>\n</blockquote>\n<p><code>u</code> is not a constant expression, so it's a narrowing conversion whether or not all possible values of the source type might be representable in the target type.</p>\n<blockquote>\n<p id=\"so_11521016_11521166_2\">Isn't every <code>unsigned</code> perfectly representable as a <code>double</code>? </p>\n</blockquote>\n<p>That's implementation defined. In the common case of 32-bit <code>unsigned</code> and <code>double</code> with a 52-bit mantissa, that is the case; but some implementations have larger <code>unsigned</code> and/or smaller <code>double</code> representations, so code that depends on that assumption is not portable.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "11521166", "Score": "28", "CreationDate": "2012-07-17T11:02:12.570", "LastActivityDate": "2012-07-17T11:02:12.570"}});