post_cb({"7291874": {"CommentCount": "13", "ViewCount": "624", "PostTypeId": "1", "LastEditorUserId": "366904", "CreationDate": "2011-09-03T07:52:27.850", "LastActivityDate": "2012-07-22T10:51:46.273", "Title": "Is strict aliasing is c or c++ thing?", "AcceptedAnswerId": "7291895", "LastEditDate": "2012-07-22T10:51:46.273", "Id": "7291874", "Score": "6", "Body": "<p>In ISO/IEC 9899:TC2, the standard says following</p>\n<blockquote>\n<p id=\"so_7291874_7291874_0\"><strong>6.3.2.3 Pointers</strong></p>\n<ol>\n<li>A pointer to an object or incomplete type may be converted to a pointer to a different\n  object or incomplete type. If the resulting pointer is not correctly aligned for the pointed-to type, the behavior is unde\ufb01ned. Otherwise, when converted back again, the result shall compare equal to the original pointer. When a pointer to an object is converted to a pointer to a character type, the result points to the lowest addressed byte of\n  the object. Successive increments of the result, up to the size of the object, yield pointers to the remaining bytes of the object.</li>\n</ol>\n</blockquote>\n<p>So, it is not clear from the standard that a pointer of one type can be casted to pointer of another type.</p>\n", "Tags": "<c++><c><casting><strict-aliasing>", "OwnerUserId": "39615", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_7291874_7291895_2": {"section_id": 6046, "quality": 0.6557377049180327, "length": 40}, "so_7291874_7291895_0": {"section_id": 7230, "quality": 0.5454545454545454, "length": 6}, "so_7291874_7291895_1": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_7291874_7291895_2": {"section_id": 5814, "quality": 0.9508196721311475, "length": 58}, "so_7291874_7291895_0": {"section_id": 6974, "quality": 0.5454545454545454, "length": 6}, "so_7291874_7291895_1": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_7291874_7291895_2": {"section_id": 7545, "quality": 0.639344262295082, "length": 39}, "so_7291874_7291895_1": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}}}, "7291895": {"ParentId": "7291874", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Strict aliasing rule is defined somewhere else. This is the wording:</p>\n<p>C (ISO/IEC 9899:1999 6.5/7):</p>\n<blockquote>\n<p id=\"so_7291874_7291895_0\">An object shall have its stored value accessed only by an lvalue\n  expression that has one of the following types:</p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>a quali\ufb01ed version of a type compatible with the effective type of\n  the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the\n  effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a\n  quali\ufb01ed version of the effective type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned\n  types among its members (including, recursively, a member of a\n  subaggregate or contained union), or</li>\n<li>a character type.</li>\n</ul>\n</blockquote>\n<p>C++ (ISO/IEC 14882:2011 3.10 [basicl.lval] / 15):</p>\n<blockquote>\n<p id=\"so_7291874_7291895_1\">If a program attempts to access the stored value of an object through\n  an lvalue of other than one of the following types the behavior is\n  undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the\n  dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a\n  cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned\n  types among its elements or non-static data members (including,\n  recursively, an element or non-static data member of a subaggregate\n  or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the\n  dynamic type of the object,</li>\n<li>a <code>char</code> or <code>unsigned char</code> type.</li>\n</ul>\n</blockquote>\n<hr>\n<p>The C standard doesn't prohibit you from casting the pointer to an unrelated type, provided there are no allignment problems. However, due to the strict aliasing rule, you basically can't dereference a pointer obtained from such a cast. So the only useful thing to do with such \"invalid\" pointer is to cast it back to the correct type (or a compatible type). </p>\n<p>It's mostly the same in C++ with reinterpret_cast (5.2.10 [expr.reinterpret.cast] / 7):</p>\n<blockquote>\n<p id=\"so_7291874_7291895_2\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n</hr>", "OwnerUserId": "399317", "LastEditorUserId": "399317", "LastEditDate": "2012-07-22T09:44:25.973", "Id": "7291895", "Score": "14", "CreationDate": "2011-09-03T07:58:32.217", "LastActivityDate": "2012-07-22T09:44:25.973"}});