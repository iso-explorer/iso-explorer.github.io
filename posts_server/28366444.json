post_cb({"28368013": {"ParentId": "28366444", "CommentCount": "9", "Body": "<p>Here's all the evidence I could find on the matter (quoting N4140):</p>\n<p><strong>13.5</strong></p>\n<blockquote>\n<p id=\"so_28366444_28368013_0\">1 A function declaration having one of the following <em>operator-function-ids</em> as its name declares an <em>operator function.</em> A function template declaration having one of the following <em>operator-function-ids</em> as its name declares an <em>operator function template.</em> A specialization of an operator function template is also an operator function. An operator function is said to <em>implement</em> the operator named in its <em>operator-function-id.</em></p>\n<p id=\"so_28366444_28368013_1\"><em>operator-function-id:</em></p>\n<p id=\"so_28366444_28368013_2\">\u00a0\u00a0<code>operator</code> <em>operator</em></p>\n<p id=\"so_28366444_28368013_3\"><em>operator:</em> one of</p>\n<pre><code> new delete new[] delete[]\n + - * / % \u02c6 &amp; | ~\n ! = &lt; &gt; += -= *= /= %=\n \u02c6= &amp;= |= &lt;&lt; &gt;&gt; &gt;&gt;= &lt;&lt;= == !=\n &lt;= &gt;= &amp;&amp; || ++ -- , -&gt;* -&gt;\n ( ) [ ]\n</code></pre>\n<p id=\"so_28366444_28368013_4\">[ <em>Note:</em> The last two operators are function call (5.2.2) and subscripting (5.2.1). The operators <code>new[]</code>, <code>delete[]</code>, <code>()</code>, and <code>[]</code> are formed from more than one token. <em>\u2014end note</em> ]</p>\n<p id=\"so_28366444_28368013_5\">6 An operator function shall either be a non-static member function or be a non-member function that has\n  at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an\n  enumeration. ...</p>\n</blockquote>\n<p><strong>13.5.2</strong></p>\n<blockquote>\n<p id=\"so_28366444_28368013_6\">1 A binary operator shall be implemented either by a non-static member function (9.3) with one parameter\n  or by a non-member function with two parameters. Thus, for any binary operator <code>@</code>, <code>x@y</code> can be interpreted\n  as either <code>x.operator@(y)</code> or <code>operator@(x,y)</code>. If both forms of the operator function have been declared,\n  the rules in 13.3.1.2 determine which, if any, interpretation is used.</p>\n</blockquote>\n<p>Nowhere does the standard prohibit specifying classes from <code>std</code> as parameter types of operator functions (or any functions, for that matter).</p>\n<p>Notice the presence of <code>&lt;&lt;</code> and <code>&gt;&gt;</code> in the table in 13.5/1. These imply it's legal to overload <code>operator &lt;&lt;</code> for any two types where at least one conforms to the conditions listed in 13.5/6. <code>std::ostream</code> is a typedef for <code>std::basic_ostream&lt;char&gt;</code>, which is a class. So overloading <code>operator&lt;&lt; (std::ostream&amp;, T)</code> is valid for any type <code>T</code>.</p>\n<p>That's all the standard has to say about it. There are no special rules for overloading <code>&lt;&lt;</code> to mean stream insertion\u2014there don't <em>have to</em> be. It's just normal application of operator overloading. If you really wanted, you could overload <code>%</code> for that purpose instead.</p>\n<p>The only other places in the standard which touch on <code>&lt;&lt;</code> with streams I can think of are:</p>\n<ul>\n<li><p>27.7.3.9/1, the <code>operator&lt;&lt;</code> overload for rvalue reference to output streams, which lists its effect as:</p>\n<blockquote>\n<p id=\"so_28366444_28368013_7\">1 <em>Effects:</em> <code>os &lt;&lt; x</code></p>\n</blockquote>\n<p>So if you overload <code>&lt;&lt;</code> for your class, the standard library inserter for output stream rvalues will invoke it for your class.</p></li>\n<li><p>Stream iterators (24.6). For example, 24.6.2/1 says that:</p>\n<blockquote>\n<p id=\"so_28366444_28368013_8\">1 <code>ostream_iterator</code> writes (using <code>operator&lt;&lt;</code>) successive elements onto the output stream from which it\n  was constructed. ...</p>\n</blockquote></li>\n</ul>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "28368013", "Score": "3", "CreationDate": "2015-02-06T14:31:09.780", "LastActivityDate": "2015-02-06T14:31:09.780"}, "bq_ids": {"n4140": {"so_28366444_28368013_8": {"section_id": 5712, "quality": 1.0, "length": 11}, "so_28366444_28368013_5": {"section_id": 653, "quality": 1.0, "length": 19}, "so_28366444_28368013_6": {"section_id": 659, "quality": 0.9375, "length": 30}, "so_28366444_28368013_0": {"section_id": 648, "quality": 0.9230769230769231, "length": 36}, "so_28366444_28368013_4": {"section_id": 648, "quality": 0.6666666666666666, "length": 14}}, "n3337": {"so_28366444_28368013_8": {"section_id": 5495, "quality": 1.0, "length": 11}, "so_28366444_28368013_5": {"section_id": 643, "quality": 1.0, "length": 19}, "so_28366444_28368013_6": {"section_id": 649, "quality": 0.9375, "length": 30}, "so_28366444_28368013_0": {"section_id": 638, "quality": 0.9230769230769231, "length": 36}, "so_28366444_28368013_4": {"section_id": 638, "quality": 0.6666666666666666, "length": 14}}, "n4659": {"so_28366444_28368013_8": {"section_id": 7157, "quality": 1.0, "length": 11}, "so_28366444_28368013_5": {"section_id": 681, "quality": 1.0, "length": 19}, "so_28366444_28368013_6": {"section_id": 687, "quality": 0.9375, "length": 30}, "so_28366444_28368013_0": {"section_id": 676, "quality": 0.9230769230769231, "length": 36}, "so_28366444_28368013_4": {"section_id": 676, "quality": 0.6666666666666666, "length": 14}}}, "28366444": {"CommentCount": "7", "ViewCount": "111", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2015-02-06T13:03:17.283", "LastActivityDate": "2015-02-06T17:03:49.703", "Title": "Where in the C++ Standard does it document I/O of user-defined types?", "AcceptedAnswerId": "28368013", "LastEditDate": "2015-02-06T17:03:49.703", "Id": "28366444", "Score": "1", "Body": "<p>I looked into N4140 for something like this, but couldn't find it:</p>\n<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const T&amp; obj)\n{\n  // write obj to stream\n  return os;\n}\n</code></pre>\n<p>Shouldn't this be documented in the Standard?</p>\n", "Tags": "<c++><c++11><language-lawyer><c++14>", "OwnerUserId": "411165", "AnswerCount": "1"}});