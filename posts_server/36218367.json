post_cb({"bq_ids": {"n4140": {"so_36218367_36219717_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 3396}}, "n3337": {"so_36218367_36219717_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 3265}}, "n4659": {"so_36218367_36219717_5": {"length": 6, "quality": 0.6666666666666666, "section_id": 8287}}}, "36218367": {"ViewCount": "193", "Body": "<p>Reading a bug report for <a href=\"https://llvm.org/bugs/show_bug.cgi?id=8100\" rel=\"nofollow\">clang not supporting FENV_ACCESS pragma</a> I've come across a <a href=\"https://llvm.org/bugs/show_bug.cgi?id=8100#c15\" rel=\"nofollow\">comment</a>:</p>\n<blockquote>\n<p id=\"so_36218367_36218367_0\">Setting the rounding mode without using <code>#pragma STDC FENV_ACCESS ON</code> invokes undefined behavior. See C11 7.6.1/2. (This pragma does not exist in C++, so &lt;cfenv&gt; is unusable, but that's not our fault...)</p>\n</blockquote>\n<p>Does this pragma really not exist in C++, rendering <code>&lt;cfenv&gt;</code> unusable? I've tried to search for it in the C++11 standard, but it really isn't mentioned at all. Are pragmas inherited from C along with function prototypes? Or are they actually not needed to avoid UB, since the C++ standard doesn't say anything about behavior being undefined when the pragma is not used (due to not mentioning the pragma at all)?</p>\n", "AcceptedAnswerId": "36219717", "Title": "Does FENV_ACCESS pragma exist in C++11 and higher?", "CreationDate": "2016-03-25T10:40:53.950", "Id": "36218367", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-03-25T12:22:36.383", "Score": "2", "OwnerUserId": "673852", "Tags": "<c++><pragma><fenv>", "AnswerCount": "1"}, "36219717": {"Id": "36219717", "PostTypeId": "2", "Body": "<p>I searched the 2015 standard draft text and found no occurrences of FENV_ACCESS. <a href=\"http://cppreference.com\" rel=\"nofollow\">http://cppreference.com</a> also has nothing about it.</p>\n<p>However, <a href=\"http://cplusplus.com\" rel=\"nofollow\">http://cplusplus.com</a> does mention it (since it is not in the standard I think we must assume that this is advisory information at best):</p>\n<p><a href=\"http://www.cplusplus.com/reference/cfenv/FENV_ACCESS/\" rel=\"nofollow\">http://www.cplusplus.com/reference/cfenv/FENV_ACCESS/</a></p>\n<p>Quoting from cplusplus.com: (emphasis mine)</p>\n<blockquote>\n<p id=\"so_36218367_36219717_0\">If set to on, the program informs the compiler that it might access the floating-point environment to test its status flags (exceptions) or run under control modes other than the one by default.</p>\n<p id=\"so_36218367_36219717_1\">If set to off, the compiler may perform certain optimizations that can subvert these tests and mode changes, <em>and thus accessing the floating-point environment in the cases described above, causes undefined behavior</em>.</p>\n<p id=\"so_36218367_36219717_2\"><strong>Whether the state of this pragma by default is on or off depends on the compiler settings and library implementation.</strong></p>\n</blockquote>\n<p>Given the unsettling lack of clarity, I would want to avoid its use if at all possible.</p>\n<p>As ever, if the use was unavoidable I'd want to encapsulate it into one class that I can specialise and test for each architecture.</p>\n<p>And then document the existence of this class and the trouble it may cause if the compiler, environment or library implementation is upgraded.</p>\n<p>Update:</p>\n<p>There is a very brief mention of the header in the c++ standard:</p>\n<blockquote>\n<p id=\"so_36218367_36219717_3\">\u00a7 26.3 The floating-point environment [cfenv] </p>\n<p id=\"so_36218367_36219717_4\">...</p>\n<p id=\"so_36218367_36219717_5\">2 The header defines all functions, types, and macros the same as Clause 7.6 of the C standard.</p>\n</blockquote>\n<p>Update:</p>\n<p>Further information here: <a href=\"http://en.cppreference.com/w/cpp/preprocessor/impl\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/preprocessor/impl</a></p>\n<p>My reading of this is that the pragma is defined by the C11 standard, not the C++11 standard. Therefore use in a c++ program is strictly implementation/un-defined.</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2016-03-25T12:22:36.383", "Score": "1", "CreationDate": "2016-03-25T12:12:59.870", "ParentId": "36218367", "CommentCount": "8", "OwnerUserId": "2015579", "LastEditDate": "2016-03-25T12:22:36.383"}});