post_cb({"7080177": {"Id": "7080177", "PostTypeId": "2", "Body": "<p>You cannot inherit assignment operators as a special case, if memory correctly serves. I believe that they can be explicitly <code>using</code>'d in if you need.</p>\n<p>Also, be careful about over use of copy-and-swap. It produces non-ideal results where the original has resources that could be re-used to make the copy, such as containers. Safety is guaranteed but optimum performance is not.</p>\n", "LastActivityDate": "2011-08-16T14:50:52.177", "Score": "1", "CreationDate": "2011-08-16T14:50:52.177", "ParentId": "7080137", "CommentCount": "1", "OwnerUserId": "298661"}, "7080233": {"Id": "7080233", "PostTypeId": "2", "Body": "<p>The compiler automatically generates a copy assignment operator for Foo, since there is none.\nIf you add a</p>\n<pre><code>    using copy_and_swap&lt;Foo&gt;::operator=;\n</code></pre>\n<p>to Foo you will see an error telling you about the ambiguity on g++.</p>\n", "LastEditorUserId": "44086", "LastActivityDate": "2011-08-16T15:06:21.453", "Score": "0", "CreationDate": "2011-08-16T14:54:27.267", "ParentId": "7080137", "CommentCount": "2", "LastEditDate": "2011-08-16T15:06:21.453", "OwnerUserId": "44086"}, "7080137": {"ViewCount": "763", "Body": "<p>I'm trying to put the copy-and-swap idiom into a reusable mixin:</p>\n<pre><code>template&lt;typename Derived&gt;\nstruct copy_and_swap\n{\n    Derived&amp; operator=(Derived copy)\n    {\n        Derived* derived = static_cast&lt;Derived*&gt;(this);\n        derived-&gt;swap(copy);\n        return *derived;\n    }\n};\n</code></pre>\n<p>I intend it to be mixed in via CRTP:</p>\n<pre><code>struct Foo : copy_and_swap&lt;Foo&gt;\n{\n    Foo()\n    {\n        std::cout &lt;&lt; \"default\\n\";\n    }\n\n    Foo(const Foo&amp; other)\n    {\n        std::cout &lt;&lt; \"copy\\n\";\n    }\n\n    void swap(Foo&amp; other)\n    {\n        std::cout &lt;&lt; \"swap\\n\";\n    }\n};\n</code></pre>\n<p>However, a simple test shows that it is not working:</p>\n<pre><code>Foo x;\nFoo y;\nx = y;\n</code></pre>\n<p>This only prints \"default\" twice, neither \"copy\" nor \"swap\" is printed. What am I missing here?</p>\n", "AcceptedAnswerId": "7081061", "Title": "reusing the copy-and-swap idiom", "CreationDate": "2011-08-16T14:48:07.337", "Id": "7080137", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2011-08-16T15:56:06.827", "Score": "11", "OwnerUserId": "252000", "Tags": "<c++><assignment-operator><mixins><crtp><copy-and-swap>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_7080137_7080212_0": {"length": 49, "quality": 0.9074074074074074, "section_id": 466}}, "n3337": {"so_7080137_7080212_0": {"length": 49, "quality": 0.9074074074074074, "section_id": 457}}, "n4659": {"so_7080137_7080212_0": {"length": 49, "quality": 0.9074074074074074, "section_id": 489}}}, "7081061": {"Id": "7081061", "PostTypeId": "2", "Body": "<p>I am afraid this is one area where a macro is necessary, because of the complex rules about automatically generated copy and assignment operators.</p>\n<p>No matter what you do, you are in either of two cases:</p>\n<ul>\n<li>You have provided (explicitly) a declaration of the assignment operator, in which case you are expected to provide a definition too</li>\n<li>You have not provided (explicitly) a declaration of the assignment operator, in which case the compiler will generate one if the base classes <em>and</em> non-static members have one available.</li>\n</ul>\n<p>The next question, therefore, is: <em>Is it worth it to automate such writing ?</em></p>\n<p>Copy-And-Swap is only used for very specific classes. I do not think it's worth it.</p>\n", "LastActivityDate": "2011-08-16T15:50:24.610", "Score": "0", "CreationDate": "2011-08-16T15:50:24.610", "ParentId": "7080137", "CommentCount": "0", "OwnerUserId": "147192"}, "7080212": {"Id": "7080212", "PostTypeId": "2", "Body": "<p>This:</p>\n<pre><code> Derived&amp; operator=(Derived copy)\n</code></pre>\n<p><strong>doesn't</strong> declare a copy assignment operator for the base class (it has the wrong signature). So the default generated assignment operator in <code>Foo</code> will not use this operator.</p>\n<p>Remember 12.8:</p>\n<blockquote>\n<p id=\"so_7080137_7080212_0\">A user-declared copy assignment operator X::operator= is a non-static\n  non-template member function of class X with exactly one parameter of\n  type X, X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;.) [Note: an\n  overloaded assignment operator must be declared to have only one\n  parameter; see 13.5.3. ] [Note: more than one form of copy assignment\n  operator may be declared for a class. ] [Note: if a class X only has a\n  copy assignment operator with a parameter of type X&amp;, an expression of\n  type const X cannot be assigned to an object of type X.</p>\n</blockquote>\n<p><strong>EDIT</strong> don't do this (can you see why ?):</p>\n<p><strike>You can do:</strike></p>\n<pre><code>template&lt;typename Derived&gt;\nstruct copy_and_swap\n{\n    void operator=(const copy_and_swap&amp; copy)\n    {\n        Derived copy(static_cast&lt;const Derived&amp;&gt;(copy));\n        copy.swap(static_cast&lt;Derived&amp;&gt;(*this));\n    }\n};\n</code></pre>\n<p>but you lose the potential copy elision optimization.</p>\n<p>Indeed, this would assign twice the members of derived classes: once via <code>copy_and_swap&lt;Derived&gt;</code> assignment operator, and once via the derived class' generated assignment operator. To correct the situation, you'd have to do (and <em>not forget to do</em>):</p>\n<pre><code>struct Foo : copy_and_swap&lt;Foo&gt;\n{\n\n    Foo&amp; operator=(const Foo&amp; x)\n    {\n        static_cast&lt;copy_and_swap&lt;Foo&gt;&amp;&gt;(*this) = x;\n        return *this;\n    }\n\nprivate:\n    // Some stateful members here\n}\n</code></pre>\n<p>The moral of the story: <em>don't write a CRTP class for the copy and swap idiom</em>.</p>\n", "LastEditorUserId": "373025", "LastActivityDate": "2011-08-16T15:52:13.160", "Score": "7", "CreationDate": "2011-08-16T14:53:02.740", "ParentId": "7080137", "CommentCount": "5", "LastEditDate": "2011-08-16T15:52:13.160", "OwnerUserId": "373025"}, "7081133": {"Id": "7081133", "PostTypeId": "2", "Body": "<p>This does not really answer the question (<a href=\"https://stackoverflow.com/questions/7080137/reusing-the-copy-and-swap-idiom/7080212#7080212\">@Alexandre C. already did</a>), but if you reverse the inheritance, you could make it work:</p>\n<pre><code>template&lt;typename Base&gt;\nstruct copy_and_swap : Base\n{\n    copy_and_swap&amp; operator=(copy_and_swap copy)\n    {\n        swap(copy);\n        return *this;\n    }\n};\n\nstruct Foo_\n{\n    Foo_()\n    {\n        std::cout &lt;&lt; \"default\\n\";\n    }\n\n    Foo_(const Foo_&amp; other)\n    {\n        std::cout &lt;&lt; \"copy\\n\";\n    }\n\n    void swap(Foo_&amp; other)\n    {\n        std::cout &lt;&lt; \"swap\\n\";\n    }\n};\n\ntypedef copy_and_swap&lt;Foo_&gt; Foo;\n\nint main()\n{\n    Foo x;\n    Foo y;\n    x = y;\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-16T15:56:06.827", "Score": "0", "CreationDate": "2011-08-16T15:56:06.827", "ParentId": "7080137", "CommentCount": "0", "LastEditDate": "2017-05-23T12:04:18.710", "OwnerUserId": "20984"}, "7080553": {"Id": "7080553", "PostTypeId": "2", "Body": "<p>Maybe you could rewrite it so it looks like so:</p>\n<pre><code>template&lt;class Derived&gt;\nstruct CopySwap\n{\n  Dervied &amp;operator=(Derived const &amp;other)\n  {\n    return AssignImpl(other);\n  }\n\n  Derived &amp;operator=(Dervied &amp;&amp;other)\n  {\n    return AssignImpl(std::move(other));\n  }\n\nprivate:\n  Derived &amp;AssignImpl(Derived other)\n  {\n    auto self(static_cast&lt;Derived*&gt;(this));\n    self-&gt;swap(other);\n    return *self;\n  }\n};\n</code></pre>\n<p>It'll probably all get inlined and likely won't be any slower than the original code.</p>\n", "LastEditorDisplayName": "user802003", "OwnerDisplayName": "user802003", "LastActivityDate": "2011-08-16T15:24:57.100", "Score": "0", "CreationDate": "2011-08-16T15:12:57.127", "ParentId": "7080137", "CommentCount": "0", "LastEditDate": "2011-08-16T15:24:57.100"}});