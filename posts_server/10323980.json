post_cb({"bq_ids": {"n4140": {"so_10323980_10324234_0": {"length": 64, "quality": 0.9014084507042254, "section_id": 175}}, "n3337": {"so_10323980_10324234_0": {"length": 68, "quality": 0.9577464788732394, "section_id": 169}}, "n4659": {"so_10323980_10324234_0": {"length": 48, "quality": 0.676056338028169, "section_id": 180}}}, "10324234": {"Id": "10324234", "PostTypeId": "2", "Body": "<p>The program in question is ill-formed, but the C++ standard does not require a diagnostic in this case, so both Visual Studio and GCC are behaving in a compliant fashion.  From \u00a714.6/7 of the C++03 standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_10323980_10324234_0\">Knowing which names are type names allows the syntax of every template definition to be checked. No\n  diagnostic shall be issued for a template definition for which a valid specialization can be generated. <strong>If no\n  valid specialization can be generated for a template definition, and that template is not instantiated, the template\n  definition is ill-formed, no diagnostic required.</strong> If a type used in a non-dependent name is incomplete\n  at the point at which a template is defined but is complete at the point at which an instantiation is done, and\n  if the completeness of that type affects whether or not the program is well-formed or affects the semantics\n  of the program, the program is ill-formed; no diagnostic is required. [<em>Note:</em> if a template is instantiated,\n  errors will be diagnosed according to the other rules in this Standard. Exactly when these errors are diagnosed\n  is a quality of implementation issue. ] [<em>Example:</em></p>\n<pre><code>int j;\ntemplate&lt;class T&gt; class X {\n    // ...\n    void f(T t, int i, char* p)\n    {\n        t = i; // diagnosed if X::f is instantiated\n               // and the assignment to t is an error\n        p = i; // may be diagnosed even if X::f is\n               // not instantiated\n        p = j; // may be diagnosed even if X::f is\n               // not instantiated\n    }\n    void g(T t) {\n        +; //may be diagnosed even if X::g is\n           // not instantiated\n    }\n};\n</code></pre>\n<p id=\"so_10323980_10324234_1\">\u2014<em>end example</em>]</p>\n</blockquote>\n", "LastActivityDate": "2012-04-25T21:41:28.070", "CommentCount": "0", "CreationDate": "2012-04-25T21:41:28.070", "ParentId": "10323980", "Score": "7", "OwnerUserId": "9530"}, "10323980": {"ViewCount": "308", "Body": "<p>From the book - C++ Templates: The Complete Guide by David, Nicolai</p>\n<blockquote>\n<p id=\"so_10323980_10323980_0\">Thus, templates are compiled twice:</p>\n<ol>\n<li>Without instantiation, the template code itself is checked for correct syntax. Syntax errors are discovered, such as missing\n  semicolons.</li>\n<li>At the time of instantiation, the template code is checked to ensure that all calls are valid. Invalid calls are discovered, such as\n  unsupported function calls.</li>\n</ol>\n</blockquote>\n<p>Keeping the first point, I wrote -</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo( T x)\n{\n   some illegal text\n}\n\nint main()\n{\n   return 0;\n}\n</code></pre>\n<p>It build fine on Visual Studio 2010 with out any warnings with optimizations turned off. How ever, <a href=\"http://ideone.com/TJK6y\" rel=\"nofollow\">it failed on gcc-4.3.4</a>. Which one is complying to the C++ standard ? Is it mandatory for template code to get compiled even with out template instantiation ?</p>\n", "AcceptedAnswerId": "10324234", "Title": "Templates compilation: gcc vs VS2010", "CreationDate": "2012-04-25T21:20:21.133", "Id": "10323980", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-04-25T21:23:30.860", "LastEditorUserId": "636019", "LastActivityDate": "2012-04-25T22:04:34.257", "Score": "1", "OwnerUserId": "528724", "Tags": "<c++><visual-studio-2010><templates><visual-c++><gcc>", "AnswerCount": "2"}, "10324190": {"Id": "10324190", "PostTypeId": "2", "Body": "<p>The book you're looking at seems to reflect (mostly) that author's observations about how compilers really work, not the requirement(s) of the standard. The standard doesn't really say much to give extra leniency to a compiler about ill-formed code inside a template, just because it's not instantiated.</p>\n<p>At the same time, the book is correct that there are some things a compiler really can't do much about checking until it's instantiated. For example, you might use a dependent name as the name of a function (or invoke it like a function, anyway -- if it's functor instead that would be fine too). If you instantiate that template over a class where it <em>is</em> a function, fine and well. If you instantiate it over a class where it's really an <code>int</code>, attempting to call it will undoubtedly fail. Until you've instantiated it, the compiler can't tell which is which though.</p>\n<p>This is a large part of what <code>concepts</code> were really intended to add to C++. You could directly specify (for example) that template X will invoke <code>T::y</code> like a function. Then the compiler could compare the content of the template with the declarations in the concept, and determine whether the body of the template fit with the declaration in the concept or not. In the other direction, the compiler only needed to compare a class (or whatever) to the <em>concept</em> to determine whether instantiating that template would work. If it wasn't going to work, it could report the error directly as a violation of the relevant concept (as it is now, it tries to instantiate the template, and you frequently get some strange error message that indicates the real problem poorly, if at all).</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2012-04-25T22:04:34.257", "Score": "0", "CreationDate": "2012-04-25T21:38:15.767", "ParentId": "10323980", "CommentCount": "0", "OwnerUserId": "179910", "LastEditDate": "2012-04-25T22:04:34.257"}});