post_cb({"bq_ids": {"n4140": {"so_937744_937762_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 111}}, "n3337": {"so_937744_937762_0": {"length": 50, "quality": 0.9803921568627451, "section_id": 106}}, "n4659": {"so_937744_937762_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 115}}}, "937762": {"Id": "937762", "PostTypeId": "2", "Body": "<p>I've looked it up, and found that it is specified by 14.5.2/2:</p>\n<blockquote>\n<p id=\"so_937744_937762_0\">A local class shall not have member templates. Access control rules (clause 11) apply to member template names. A destructor shall not be a member template. A normal (non-template) member function with a given name and type and a member function template of the same name, which could be used to generate a specialization of the same type, can both be declared in a class. When both exist, a use of that name and type refers to the non-template member unless an explicit template argument list is supplied.</p>\n</blockquote>\n<p>And it provides an example:</p>\n<pre><code>template &lt;class T&gt; struct A {\n    void f(int);\n    template &lt;class T2&gt; void f(T2);\n};\n\ntemplate &lt;&gt; void A&lt;int&gt;::f(int) { } // non-template member\ntemplate &lt;&gt; template &lt;&gt; void A&lt;int&gt;::f&lt;&gt;(int) { } // template member\n\nint main()\n{\n    A&lt;char&gt; ac;\n    ac.f(1); //non-template\n    ac.f(\u2019c\u2019); //template\n    ac.f&lt;&gt;(1); //template\n}\n</code></pre>\n<p>Note that in Standard terms, <code>specialization</code> refers to the function you write using an explicit specialization and to the function generated using instantiation, in which case we have to do with a generated specialization. <code>specialization</code> does not only refer to functions you create using explicitly specializing a template, for which it is often only used. </p>\n<p>Conclusion: GCC gets it wrong. Comeau, with which i also tested the code, gets it right and issues a diagnostic:</p>\n<blockquote>\n<p id=\"so_937744_937762_1\"><code>\"ComeauTest.c\"</code>, line 16: error: <code>\"void doh::operator()(bool)\"</code> is not an entity that\n            can be explicitly specialized\n    <code>template&lt;&gt; void doh::operator()(bool i)</code></p>\n</blockquote>\n<p>Note that it isn't complaining about the specialization of the template for <code>int</code> (only for <code>bool</code>), since it doesn't refer to the same name <em>and</em> type: The function type that specialization would have is <code>void(int)</code>, which is distinct from the function type of the non-template member function, which is <code>void(bool)</code>. </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2009-06-02T03:13:38.927", "Score": "31", "CreationDate": "2009-06-02T03:06:24.993", "ParentId": "937744", "CommentCount": "6", "OwnerUserId": "34509", "LastEditDate": "2009-06-02T03:13:38.927"}, "937744": {"ViewCount": "34193", "Body": "<p>What is the reason for the second brackets &lt;&gt; in the following function template:</p>\n<pre><code>template&lt;&gt; void doh::operator()&lt;&gt;(int i)\n</code></pre>\n<p>This came up in <a href=\"https://stackoverflow.com/questions/937107/do-template-specializations-require-template-syntax\">SO question</a> where it was suggested that there are brackets missing after <code>operator()</code>, however I could not find the explanation.</p>\n<p>I understand the meaning if it was a type specialization (full specialization) of the form:</p>\n<pre><code>template&lt; typename A &gt; struct AA {};\ntemplate&lt;&gt; struct AA&lt;int&gt; {};         // hope this is correct, specialize for int\n</code></pre>\n<p>However for function templates:</p>\n<pre><code>template&lt; typename A &gt; void f( A );\ntemplate&lt; typename A &gt; void f( A* ); // overload of the above for pointers\ntemplate&lt;&gt; void f&lt;int&gt;(int);         // full specialization for int\n</code></pre>\n<p>Where does this fit into this scenarion?:</p>\n<pre><code>template&lt;&gt; void doh::operator()&lt;&gt;(bool b) {}\n</code></pre>\n<p>Example code that seems to work and does not give any warnings/error (gcc 3.3.3 used):</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct doh\n{\n    void operator()(bool b)\n    {\n        cout &lt;&lt; \"operator()(bool b)\" &lt;&lt; endl;\n    }\n\n    template&lt; typename T &gt; void operator()(T t)\n    {\n        cout &lt;&lt; \"template &lt;typename T&gt; void operator()(T t)\" &lt;&lt; endl;\n    }\n};\n// note can't specialize inline, have to declare outside of the class body\ntemplate&lt;&gt; void doh::operator()(int i)\n{\n    cout &lt;&lt; \"template &lt;&gt; void operator()(int i)\" &lt;&lt; endl;\n}\ntemplate&lt;&gt; void doh::operator()(bool b)\n{\n    cout &lt;&lt; \"template &lt;&gt; void operator()(bool b)\" &lt;&lt; endl;\n}\n\nint main()\n{\n    doh d;\n    int i;\n    bool b;\n    d(b);\n    d(i);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>operator()(bool b)\ntemplate &lt;&gt; void operator()(int i)\n</code></pre>\n", "AcceptedAnswerId": "937762", "Title": "Function template specialization format", "CreationDate": "2009-06-02T02:59:26.383", "Id": "937744", "CommentCount": "2", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:45:49.133", "LastEditorUserId": "-1", "LastActivityDate": "2009-06-02T03:13:38.927", "Score": "30", "OwnerUserId": "45654", "Tags": "<c++><templates><syntax><template-specialization>", "AnswerCount": "1"}});