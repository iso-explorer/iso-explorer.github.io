post_cb({"bq_ids": {"n4140": {"so_24933592_24934001_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 175}}, "n3337": {"so_24933592_24934001_0": {"length": 21, "quality": 1.0, "section_id": 169}}}, "24934224": {"PostTypeId": "2", "Body": "<p>It's not possible in general to tell whether <code>a.foo();</code> or <code>A::bar();</code> are an error at template definition time, even for those specific definitions of <code>A::foo</code> and <code>A::bar</code>.</p>\n<p>Generally speaking, <code>a.foo();</code> could be valid if <code>A</code> had some specialisations of <code>B&lt;T&gt;</code> as a friend, but not others, which would make the validity dependent on the template argument.</p>\n<p>Generally speaking, <code>A::bar();</code> could be valid if <code>B&lt;T&gt;</code> had <code>A</code> as a base class, directly or indirectly, and template classes do not generally know their base class yet at template definition time.</p>\n<p>Even though it's possible to detect that neither of these is possible <em>here</em> (<code>A</code> has no friends, and <code>B&lt;T&gt;</code> has no base), it requires significant effort for little benefit. Because of this, it makes sense to simply always perform such checks at instantiation time, and that's the approach GCC has taken.</p>\n<p>There is actually no rule in C++ that <em>requires</em> this to be diagnosed at template definition time (as Marco A.'s answer rightly points out). It's only when a template is instantiated that any errors in the template definition render the program ill-formed with a requirement for a diagnostic, per 2.2p1 bullet point 8:</p>\n<blockquote>\n<p id=\"so_24933592_24934224_0\">The program is ill-formed if any instantiation fails.</p>\n</blockquote>\n<p>In your program, there is no instantiation, so there is no instantiation that fails.</p>\n", "LastActivityDate": "2014-07-24T13:26:50.017", "LastEditorUserId": "743382", "Id": "24934224", "CommentCount": "2", "CreationDate": "2014-07-24T12:52:03.667", "ParentId": "24933592", "Score": "7", "OwnerUserId": "743382", "LastEditDate": "2014-07-24T13:26:50.017"}, "24933592": {"ViewCount": "393", "Body": "<p>Consider this example:</p>\n<pre><code>class A\n{\n  void foo();\n  public:\n  void bar();\n};\n\ntemplate &lt;class&gt; class B\n{\n  B()\n  {\n    A a;\n    a.foo();    // 1\n    A::bar();   // 2\n    a.bar(1);   // 3\n  }\n};\n</code></pre>\n<p>Note <code>B</code> is never instantiated.</p>\n<p><code>clang++</code> reports all three marked lines as erroneous. <code>g++</code> (4.8.3) accepts lines <code>1</code> and <code>2</code> and only reports line <code>3</code>.</p>\n<p>If <code>B</code> is instantiated, <code>g++</code> happily reports all three lines as erroneous.</p>\n<p>Is this a <code>g++</code> bug? One would think so. <code>A</code> is not a dependent name and its members should be checked normally at template definition time. Are there nuances I don't see?</p>\n", "AcceptedAnswerId": "24934001", "Title": "Certain errors in uninstantiated template not reported by g++", "CreationDate": "2014-07-24T12:22:29.530", "Id": "24933592", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-07-24T13:26:50.017", "Score": "12", "OwnerUserId": "775806", "Tags": "<c++><templates><g++>", "AnswerCount": "2"}, "24934001": {"PostTypeId": "2", "Body": "<p>Those pre-instantiation messages aren't enforced by the standard and are up to the compiler</p>\n<p>n3337 \u00a7 14.6 - 8</p>\n<blockquote>\n<p id=\"so_24933592_24934001_0\">No diagnostic shall be issued for a template definition for which a\n  valid specialization can be generated. If no valid specialization can\n  be generated for a template definition, and that template is not\n  instantiated, the template definition is ill-formed, <strong>no diagnostic\n  required.</strong></p>\n</blockquote>\n<p>emphasis mine</p>\n", "LastActivityDate": "2014-07-24T12:42:36.197", "Id": "24934001", "CommentCount": "1", "CreationDate": "2014-07-24T12:42:36.197", "ParentId": "24933592", "Score": "19", "OwnerUserId": "1938163"}});