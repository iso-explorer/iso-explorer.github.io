post_cb({"17511382": {"ParentId": "17511269", "CommentCount": "0", "Body": "<p>The standard is pretty clear on that:</p>\n<blockquote>\n<p id=\"so_17511269_17511382_0\"><strong>[cpp.pragma]</strong> A preprocessing directive of the form</p>\n<pre><code>#pragma pp-tokensopt new-line\n</code></pre>\n<p id=\"so_17511269_17511382_1\">causes the implementation <strong>to behave in an implementation-defined manner</strong>. The behavior might cause translation to fail <strong>or cause the translator or the resulting program to behave in a non-conforming manner</strong>. Any pragma that is not recognized by the implementation is ignored.</p>\n</blockquote>\n<p>The compiler can thus do pretty much whatever it wants on seeing a <code>#pragma</code>.</p>\n", "OwnerUserId": "542190", "PostTypeId": "2", "Id": "17511382", "Score": "5", "CreationDate": "2013-07-07T10:36:28.370", "LastActivityDate": "2013-07-07T10:36:28.370"}, "17511376": {"ParentId": "17511269", "CommentCount": "4", "Body": "<p>The compiler is allowed to do absolutely everything, as long as it is documented. A really old version of gcc, upon seeing <em>any</em> pragma, used to stop compilation and attempted to locate and launch one of the text-mode games that existed back then. Which was perfectly standard conforming because there was a section about it in the user guide.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "17511376", "Score": "1", "CreationDate": "2013-07-07T10:35:20.610", "LastActivityDate": "2013-07-07T10:35:20.610"}, "17511269": {"CommentCount": "2", "ViewCount": "339", "CreationDate": "2013-07-07T10:21:42.080", "LastActivityDate": "2016-01-11T23:05:25.547", "Title": "What does the standard allow #pragma to do?", "AcceptedAnswerId": "17511382", "PostTypeId": "1", "Id": "17511269", "Score": "5", "Body": "<p>In C++ (and C) we have the <code>#pragma</code> directive which basically has implementation defined effects. However, are there any limits of what the directive may do? (Note that I'm asking about what the standard allows, not about what real compilers actually do.)</p>\n<p>What I'm certain <code>#pragma</code> may do:</p>\n<ul>\n<li>Allow to select one of several compilation options which all result in valid C++- For example, select one of several available ABIs, or switch certain implementation defined options.</li>\n</ul>\n<p>What I would guess is allowed, but am not sure:</p>\n<ul>\n<li><p>Allow the compiler to accept otherwise illegal code without issuing a diagnostic (for example, a compiler might decide to support a new built-in type <code>long long long</code>, but any code using that would have to issue a diagnostic; this diagnostic could then be suppressed with e.g. <code>#pragma long long long</code>.</p></li>\n<li><p>Allow the compiler to reject otherwise legal code, for example there could be a <code>#pragma strict</code> which causes the compiler to flag as error the use of certain library functions and/or language constructs which are considered unsafe.</p></li>\n</ul>\n<p>What I actually doubt is allowed, but am not sure either:</p>\n<ul>\n<li>Allow the compiler to change the semantics of legal code to something different (for example, assume that a compiler vendor considered it a good idea if the <code>for</code> condition were a postcondition (as in <code>do</code> \u2026 <code>while</code>), and defined <code>#pragma for postcondion</code> to switch the meaning of <code>for</code> accordingly.</li>\n</ul>\n<p>The reason why I doubt the latter is that the compiler is allowed to ignore any pragma it doesn't recognize, and therefore a change in semantics by a pragma would cause the same program to have different semantics on different compilers.</p>\n<p>However, what does the standard actually allow? And are there things which are allowed, but which are not covered by my list above?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "1032073", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_17511269_17511382_1": {"section_id": 548, "quality": 0.8636363636363636, "length": 19}, "so_17511269_17511426_0": {"section_id": 548, "quality": 0.7857142857142857, "length": 22}}, "n3337": {"so_17511269_17511382_1": {"section_id": 539, "quality": 0.8636363636363636, "length": 19}, "so_17511269_17511426_0": {"section_id": 539, "quality": 0.7857142857142857, "length": 22}}, "n4659": {"so_17511269_17511382_1": {"section_id": 569, "quality": 0.8636363636363636, "length": 19}, "so_17511269_17511426_0": {"section_id": 569, "quality": 0.7857142857142857, "length": 22}}}, "17511426": {"ParentId": "17511269", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The n3337 version of C++ standard says</p>\n<blockquote>\n<p id=\"so_17511269_17511426_0\">A preprocessing directive of the form\n  <code>#pragma pp-tokens<sub>opt</sub> new-line</code>\n   causes the implementation to behave in an implementation-defined manner.\n  The behavior might cause translation to fail or cause the translator or\n  the resulting program to behave in a non-conforming manner. Any pragma that is not recognized by the implementation is ignored.</p>\n</blockquote>\n<p>I think that allows the compiler to do almost anything it would like to do in case of a <code>#pragma</code>. Both the \"translation to fail\" and \"translator or resulting program to behave in non-conforming manner\" covers a great range of options. </p>\n<p>That, of course, doesn't mean that it's a wise thing to allow the compiler to do \"crazy\" things - it may \"upset\" people, but it's perfectly valid from the standard's perspective. </p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2016-01-11T23:05:25.547", "Id": "17511426", "Score": "3", "CreationDate": "2013-07-07T10:40:50.960", "LastActivityDate": "2016-01-11T23:05:25.547"}});