post_cb({"31563235": {"CommentCount": "9", "AcceptedAnswerId": "31886631", "PostTypeId": "1", "LastEditorUserId": "5168225", "CreationDate": "2015-07-22T12:30:27.530", "LastActivityDate": "2015-08-14T05:05:00.470", "LastEditDate": "2015-08-14T05:05:00.470", "ViewCount": "677", "FavoriteCount": "3", "Title": "GCC 4.9 ambiguous overload template specialization", "Id": "31563235", "Score": "16", "Body": "<p>I'm running into an issue with <code>gcc 4.9.2</code> (with -std=c++11) not compiling a piece of code with the error message being </p>\n<blockquote>\n<p id=\"so_31563235_31563235_0\">call of overloaded 'InsertDataIntoInputMap(int&amp;, boost::shared_ptr&amp;)' is ambiguous</p>\n</blockquote>\n<p>The code does compile with msvc 2013</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;boost/shared_ptr.hpp&gt;\n\nstruct Proxy\n{\n    typedef std::map&lt;int, int&gt; InputDataMap;    \n    int a;\n};\n\ntemplate&lt;class C, class D&gt;\nvoid InsertDataIntoInputMap(\n    const typename C::InputDataMap::key_type&amp; key,\n    const D val)\n{\n    std::cout &lt;&lt; \"Not shared\\n\";\n}\n\ntemplate&lt;class C, class D&gt;\nvoid InsertDataIntoInputMap(\n    const typename C::InputDataMap::key_type&amp; key,\n    const boost::shared_ptr&lt;D&gt; val)\n{\n    if (val)\n    {\n        std::cout &lt;&lt; \"Shared\\n\";\n    }\n}\n\nint main() {\n    int a;\n    boost::shared_ptr&lt;double&gt; x(new double(4.5));\n\n    InsertDataIntoInputMap&lt;Proxy&gt;(a, x);\n}\n</code></pre>\n<p>while the following does actually compile with both gcc and msvc:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/shared_ptr.hpp&gt;\n\ntemplate&lt;class C, class D&gt;\nvoid InsertDataIntoInputMap(\n    const C&amp; key,\n    const D val)\n{\n    std::cout &lt;&lt; \"Not shared\\n\";\n}\n\ntemplate&lt;class C, class D&gt;\nvoid InsertDataIntoInputMap(\n    const C&amp; key,\n    const boost::shared_ptr&lt;D&gt; val)\n{\n    if (val)\n    {\n        std::cout &lt;&lt; \"Shared\\n\";\n    }\n}\n\nint main() {\n    int a = 0;\n    boost::shared_ptr&lt;double&gt; x(new double(4.5));\n\n    InsertDataIntoInputMap&lt;int&gt;(a, x);\n\n    return 0;\n}\n</code></pre>\n<p>I would have thought that the compiler should take the function with the boost::shared_ptr argument in both cases? </p>\n", "Tags": "<c++><c++11><gcc>", "OwnerUserId": "677188", "AnswerCount": "2"}, "31856974": {"ParentId": "31563235", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A simple alias can make that code work:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;boost/shared_ptr.hpp&gt;\n\nstruct Proxy\n{\n    typedef std::map&lt;int, int&gt; InputDataMap;    \n    int a;\n};\n\ntemplate&lt;class C, class D, class F = typename C::InputDataMap::key_type&gt;\nvoid InsertDataIntoInputMap(\n    const F&amp; key,\n    const D val)\n{\n    std::cout &lt;&lt; \"Not shared\\n\";\n}\n\ntemplate&lt;class C, class D, class F = typename C::InputDataMap::key_type&gt;\nvoid InsertDataIntoInputMap(\n    const F&amp; key,\n    const boost::shared_ptr&lt;D&gt; val)\n{\n    if (val)\n    {\n        std::cout &lt;&lt; \"Shared\\n\";\n    }\n}\n\nint main() {\n    int a;\n    boost::shared_ptr&lt;double&gt; x(new double(4.5));\n\n    InsertDataIntoInputMap&lt;Proxy&gt;(a, x);\n}\n</code></pre>\n<p>But imo. this shouldn't work, cause I thought, the draft says, the compiler will not consider the C::InputDataMap - Namespace in </p>\n<pre><code>class F = typename C::InputDataMap::key_type\n</code></pre>\n<p>and F will be a non-deduced context (like key_type).</p>\n", "OwnerUserId": "4043866", "LastEditorUserId": "4043866", "LastEditDate": "2015-08-06T17:21:23.950", "Id": "31856974", "Score": "1", "CreationDate": "2015-08-06T13:21:52.070", "LastActivityDate": "2015-08-06T17:21:23.950"}, "bq_ids": {"n4140": {"so_31563235_31886631_1": {"section_id": 323, "quality": 0.55, "length": 11}}, "n3337": {"so_31563235_31886631_1": {"section_id": 313, "quality": 0.55, "length": 11}}, "n4659": {"so_31563235_31886631_1": {"section_id": 331, "quality": 1.0, "length": 20}}}, "31886631": {"ParentId": "31563235", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This problem can be reduced to an imprecision in partial ordering: Pairs in which no template-parameters appear that are involved in deduction are still considered and compaired. That issue was addressed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#455\" rel=\"nofollow\">CWG #455</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#885\" rel=\"nofollow\">#885</a> as well.</p>\n<p>In your example, overload resolution isn't able to distinguish the overloads. Hence partial ordering is necessary. And partial ordering will try to perform deduction twice, with the parameter type <code>P</code> being <code>typename C::InputDataMap::key_type</code>.<br>\nHowever, that deduction is doomed to fail, since <code>C</code> solely appears in a non-deduced context. I.e. the type from both templates (for that particular pair) is not at least as specialized as the type from the respective other template - and that, in turn, implies that neither of the templates is more specialized than the other. </br></p>\n<p>As noted by @T.C., the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1391\" rel=\"nofollow\">CWG #1391</a> helps. This part in particular:</p>\n<blockquote>\n<p id=\"so_31563235_31886631_0\">Change 14.8.2.4 [temp.deduct.partial] paragraph 4 as follows:</p>\n<p id=\"so_31563235_31886631_1\">Each type nominated above from the parameter template and the corresponding type from the argument template are used as the types of <code>P</code> and <code>A</code>. <strong><em>If a particular <code>P</code> contains no template-parameters that participate in template argument deduction, that <code>P</code> is not used to determine the ordering.</em></strong> </p>\n</blockquote>\n<p>Now, the first parameter pair is entirely ignored in both ways (as the types of <code>C</code> are solely determined from the explicit argument list), and the second overload is found to be more specialized.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-08-07T21:40:20.153", "Id": "31886631", "Score": "3", "CreationDate": "2015-08-07T21:05:05.580", "LastActivityDate": "2015-08-07T21:40:20.153"}});