post_cb({"20706737": {"ParentId": "20705304", "CommentCount": "5", "CreationDate": "2013-12-20T15:18:47.130", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "20706737", "Score": "1", "Body": "<p><code>shared_ptr</code> and <code>weak_ptr</code> fall under the same blanket threadsafety requirements as all other standard library types: simultaneous calls to member functions must be threadsafe if those member functions are non-modifying (<code>const</code>) (Detailed in C++11 \u00a717.6.5.9 Data Race Avoidance [res.data.races]). Assignment operators are notably <em>not</em> <code>const</code>.</p>\n", "LastActivityDate": "2013-12-20T15:18:47.130"}, "20705304": {"CommentCount": "3", "ViewCount": "4077", "PostTypeId": "1", "LastEditorUserId": "1094609", "CreationDate": "2013-12-20T14:01:22.190", "LastActivityDate": "2015-09-17T01:48:54.070", "Title": "About thread-safety of weak_ptr", "FavoriteCount": "2", "LastEditDate": "2015-09-17T01:48:54.070", "Id": "20705304", "Score": "8", "Body": "<pre><code>std::shared_ptr&lt;int&gt; g_s = std::make_shared&lt;int&gt;(1);\nvoid f1()\n{\n    std::shared_ptr&lt;int&gt;l_s1 = g_s; // read g_s\n}\n\nvoid f2()\n{\n    std::shared_ptr&lt;int&gt; l_s2 = std::make_shared&lt;int&gt;(3);\n    std::thread th(f1);\n    th.detach();\n    g_s = l_s2; // write g_s\n}\n</code></pre>\n<p>Regarding the code above, I know different threads reading and writing the same <code>shared_ptr</code> leads to race conditions. But how about <code>weak_ptr</code>? Is there any race condition in the code below? (My platform is Microsoft VS2013.)</p>\n<pre><code>std::weak_ptr&lt;int&gt; g_w;\n\nvoid f3()\n{\n    std::shared_ptr&lt;int&gt;l_s3 = g_w.lock(); //2. here will read g_w\n    if (l_s3)\n    {\n        ;/.....\n    }\n}\n\nvoid f4()\n{\n    std::shared_ptr&lt;int&gt; p_s = std::make_shared&lt;int&gt;(1);\n    g_w = p_s;\n\n    std::thread th(f3);\n    th.detach();\n    // 1. p_s destory will motify g_w (write g_w)\n}\n</code></pre>\n", "Tags": "<c++><multithreading><c++11><weak-ptr>", "OwnerUserId": "1442372", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20705304_30085310_0": {"section_id": 4492, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_20705304_30085310_0": {"section_id": 5755, "quality": 0.7142857142857143, "length": 5}}}, "30085310": {"ParentId": "20705304", "LastEditDate": "2017-05-23T11:47:24.667", "CommentCount": "2", "CreationDate": "2015-05-06T18:56:12.090", "Score": "17", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "30085310", "OwnerUserId": "25097", "Body": "<p>I know I'm late, but this comes up when searching for \"weak_ptr thread\", and Casey's answer just isn't the whole truth. <strong>Both <code>shared_ptr</code> and <code>weak_ptr</code> can be used from threads without further synchronization.</strong></p>\n<p>For <code>shared_ptr</code>, there's a lot of documentation (e.g. on <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow noreferrer\">cppreference.com</a> or on <a href=\"https://stackoverflow.com/questions/9127816\">stackoverflow</a>). You can safely access <code>shared_ptr</code>'s that point to the same object from different threads. You just can't bang on the same pointer from two threads. In other words:</p>\n<pre><code>// Using p and p_copy from two threads is fine.\n// Using p from two threads or p and p_ref from two threads is illegal.\nstd::shared_ptr&lt;A&gt; p = std::make_shared&lt;A&gt;();\nstd::shared_ptr&lt;A&gt; &amp;p_ref = p;\nstd::shared_ptr&lt;A&gt; p_copy = p;\n</code></pre>\n<p>To solve that problem in your code, pass <code>g_s</code> as parameter (by value)* to <code>f1()</code>.</p>\n<p>For weak pointers, the safety guarantee is hidden in the documentation for <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr/lock\" rel=\"nofollow noreferrer\">weak_ptr::lock</a>:</p>\n<blockquote>\n<p id=\"so_20705304_30085310_0\">Effectively returns <code>expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this)</code>, executed atomically. </p>\n</blockquote>\n<p>You can use <code>weak_ptr::lock()</code> to get a <code>shared_ptr</code> from other threads without further synchronization. This is also confirmed <a href=\"http://www.boost.org/doc/libs/1_58_0/libs/smart_ptr/weak_ptr.htm\" rel=\"nofollow noreferrer\">here</a> for Boost and in <a href=\"https://stackoverflow.com/a/2160422/25097\">this SO answer</a> by Chris Jester-Young.</p>\n<p>Again, you have to make sure not to modify the same <code>weak_ptr</code> from one thread while accessing it from another, so pass <code>g_w</code> into <code>f3()</code> by value as well.</p>\n", "LastActivityDate": "2015-05-15T20:36:32.093"}});