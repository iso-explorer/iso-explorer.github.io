post_cb({"14866429": {"ParentId": "14866360", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><code>basic_ostream</code> has an overload of <code>operator&lt;&lt;</code> that looks like this:</p>\n<pre><code>template &lt;typename Elem, typename Traits, typename T&gt;\nbasic_ostream&lt;Elem, Traits&gt;&amp;\n    operator&lt;&lt;(basic_ostream&lt;Elem, Traits&gt;&amp;&amp; sink, const T&amp; val)\n{\n    return sink &lt;&lt; val;\n}\n</code></pre>\n<p>This is called \"Rvalue stream insertion\" in the standard, at \u00a727.7.3.9 [ostream.rvalue].</p>\n<p>It allows implicit conversion (of sorts) from an rvalue <code>basic_ostream</code> to an lvalue.  It was introduced specifically to allow <a href=\"https://stackoverflow.com/questions/5179522/why-does-writing-to-temporary-stream-fail\">temporary streams to be usable without resorting to tricks</a>.</p>\n<hr>\n<p>As for why the compile fails when you omit the move:</p>\n<p>When <code>Stream&amp; operator&lt;&lt;(Stream&amp; s, Dummy)</code> is called <em>without</em> the move, <code>Stream</code> will be <code>std::fstream</code> which inherits from <code>std::ostream</code> (i.e. <code>basic_ostream&lt;char&gt;</code>).</p>\n<p>It will use the <code>basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp;, const char*)</code> overload to insert your string, then try to return the result of that expression <em>which will be an <code>ostream</code></em>. You cannot implicitly downcast from <code>std::ostream&amp;</code> to <code>std::fstream&amp;</code>, so you get an error.</p>\n<p>You can fix this by returning <code>s</code> on it's own line (where it won't have been implicitly upcasted.)</p>\n<p>This isn't a problem <em>with</em> move because you go through that rvalue-to-lvalue insertion operator we just discovered first. Inside that function, the stream is a <code>basic_ostream</code> and so <code>Stream</code> is as well, and the return types will match.</p>\n</hr>", "OwnerUserId": "87234", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:56:24.047", "Id": "14866429", "Score": "10", "CreationDate": "2013-02-14T01:36:36.643", "LastActivityDate": "2013-02-14T01:52:53.343"}, "14866360": {"CommentCount": "0", "AcceptedAnswerId": "14866429", "CreationDate": "2013-02-14T01:26:33.767", "LastActivityDate": "2013-02-14T01:52:53.343", "PostTypeId": "1", "ViewCount": "846", "FavoriteCount": "1", "Title": "Why can I std::move a stream rvalue ref into an lvalue ref?", "Id": "14866360", "Score": "5", "Body": "<p>As far as I understand C++11 references, I should not be able to bind an rvalue reference to a (non-const) lvalue reference as the former might be bound to a temporary and the latter must never be bound to a temporary.</p>\n<p>However I found this odd behaviour in conjunction temporary stream objects (which I reduced as far as I could)</p>\n<pre><code>struct Dummy {};\ntemplate &lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; s, Dummy) {\n  return s &lt;&lt; \".\";          // &lt;- (A)\n}\n\ntemplate &lt;typename Stream&gt;\nvoid pass(Stream&amp;&amp; s) {\n  std::move(s) &lt;&lt; Dummy();  // &lt;- (X)   rvalue-&gt;lvalue conversion?\n}\n\n#include &lt;fstream&gt;\nint main() {\n  pass(std::fstream(\"test\",std::ios::out));\n}\n</code></pre>\n<p>If I write <code>s &lt;&lt; Dummy()</code> in line <code>(X)</code>, C++ complains in line <code>(A)</code>, saying</p>\n<blockquote>\n<p id=\"so_14866360_14866360_0\"><code>error: invalid initialization of reference of type \u2018std::basic_fstream&lt;char&gt;&amp;\u2019 from expression of type \u2018std::basic_ostream&lt;char&gt;\u2019</code></p>\n</blockquote>\n<p>However, why does the code (as shown above) compiles <em>and works as expected</em>? The rvalue reference returned by <code>std::move</code> should just be as unable to being bound to an lvalue reference as the expression <code>s</code> is, but both <code>gcc 4.6.1</code> and <code>gcc 4.7.2</code> react identically.</p>\n<p>And why does this phenomenon only appear to work with streams? When directly passing a <code>Dummy&amp;&amp;</code> to a function that expects a <code>T&amp;</code> fails both with and without <code>std::move</code>.</p>\n", "Tags": "<c++><c++11><iostream><move-semantics><rvalue-reference>", "OwnerUserId": "430766", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14866360_14866360_0": {"section_id": 300, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_14866360_14866360_0": {"section_id": 291, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_14866360_14866360_0": {"section_id": 307, "quality": 0.5555555555555556, "length": 5}}}});