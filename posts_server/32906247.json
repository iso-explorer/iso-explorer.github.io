post_cb({"bq_ids": {"n4140": {"so_32906247_32906350_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 6142}, "so_32906247_32906350_1": {"length": 24, "quality": 0.96, "section_id": 6064}, "so_32906247_32906349_1": {"length": 24, "quality": 0.96, "section_id": 6064}, "so_32906247_32906349_2": {"length": 29, "quality": 0.9354838709677419, "section_id": 6142}, "so_32906247_32906349_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 5986}, "so_32906247_32906350_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5986}}, "n3337": {"so_32906247_32906349_0": {"length": 28, "quality": 0.8235294117647058, "section_id": 5754}, "so_32906247_32906350_1": {"length": 24, "quality": 0.96, "section_id": 5832}, "so_32906247_32906349_1": {"length": 24, "quality": 0.96, "section_id": 5832}, "so_32906247_32906349_2": {"length": 29, "quality": 0.9354838709677419, "section_id": 5906}, "so_32906247_32906350_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 5906}, "so_32906247_32906350_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5754}}, "n4659": {"so_32906247_32906349_1": {"length": 23, "quality": 0.92, "section_id": 7560}, "so_32906247_32906349_0": {"length": 27, "quality": 0.7941176470588235, "section_id": 7486}, "so_32906247_32906349_2": {"length": 20, "quality": 0.6451612903225806, "section_id": 7638}, "so_32906247_32906350_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7486}, "so_32906247_32906350_1": {"length": 23, "quality": 0.92, "section_id": 7560}}}, "32906350": {"Id": "32906350", "PostTypeId": "2", "Body": "<p>C++14:</p>\n<p><strong>5.2.1 Subscripting</strong></p>\n<p>The relevant part:</p>\n<blockquote>\n<p id=\"so_32906247_32906350_0\">1 ... The\n  expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code> ...</p>\n</blockquote>\n<p><strong>5.3.1 Unary operators</strong></p>\n<p>The relevant part:</p>\n<blockquote>\n<p id=\"so_32906247_32906350_1\">1 The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a pointer to an\n  object type, or a pointer to a function type and the result is an lvalue referring to the object or function\n  to which the expression points. If the type of the expression is \u201cpointer to <code>T</code>,\u201d the type of the result is\n  \u201c<code>T</code>.\u201d ...</p>\n</blockquote>\n<p><strong>5.7 Additive operators</strong></p>\n<p>The relevant part:</p>\n<blockquote>\n<p id=\"so_32906247_32906350_2\">5 ... In other words, if\n  the expression <code>P</code> points to the <em>i</em>-th element of an array object, the expressions <code>(P)+N</code> (equivalently, <code>N+(P)</code>)\n  and <code>(P)-N</code> (where <code>N</code> has the value <em>n</em>) point to, respectively, the <em>i + n</em>-th and <em>i \u2212 n</em>-th elements of the array\n  object, provided they exist. ...</p>\n</blockquote>\n", "LastActivityDate": "2015-10-02T11:37:26.983", "CommentCount": "1", "CreationDate": "2015-10-02T11:37:26.983", "ParentId": "32906247", "Score": "2", "OwnerUserId": "1782465"}, "32906349": {"Id": "32906349", "PostTypeId": "2", "Body": "<p>This is covered in the draft C++14 standard section 5.2.1 Subscripting [expr.sub] (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_32906247_32906349_0\">A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions\n  shall have the type \u201carray of T\u201d or \u201cpointer to T\u201d and the other shall have unscoped enumeration\n  or integral type.[...] <strong>The expression E1[E2] is identical (by definition) to *((E1)+(E2))</strong> [ Note: see 5.3 and 5.7 for details of * and\n  + and 8.3.4 for details of arrays. \u2014end note ],</p>\n</blockquote>\n<p>This paragraph references section <code>5.3</code> for <code>*</code> which says:</p>\n<blockquote>\n<p id=\"so_32906247_32906349_1\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an\n  object type, or a pointer to a function type and the result is an lvalue referring to the object or function\n  to which the expression points. If the type of the expression is \u201cpointer to T,\u201d the type of the result is\n  \u201cT.\u201d[...]</p>\n</blockquote>\n<p>and section <code>5.7</code> for <code>+</code> which says:</p>\n<blockquote>\n<p id=\"so_32906247_32906349_2\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. [...] if\n  the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P))\n  and (P)-N (where N has the value n) point to, respectively, the i + n-th and i \u2212 n-th elements of the array\n  object, provided they exist[ ...]</p>\n</blockquote>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2015-10-02T11:49:33.693", "Score": "2", "CreationDate": "2015-10-02T11:37:22.840", "ParentId": "32906247", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2015-10-02T11:49:33.693"}, "32906247": {"ViewCount": "65", "Body": "<p>In the snippet below, the notation <code>*p</code> is equivalent to <code>p[0]</code>, <code>*(p + 1)</code> is equivalent to <code>p[1]</code>, and so on.</p>\n<pre><code>int* p = new int[3] { 1, 2, 3};\ncout &lt;&lt; *p &lt;&lt; ' ' &lt;&lt; *(p + 1) &lt;&lt; ' ' &lt;&lt; *(p + 2) &lt;&lt; '\\n';\ncout &lt;&lt; p[0] &lt;&lt; ' ' &lt;&lt; p[1] &lt;&lt; ' ' &lt;&lt; p[2] &lt;&lt; '\\n';\n</code></pre>\n<p>Where in the Standard can I find some reference to this equivalence?</p>\n", "AcceptedAnswerId": "32906349", "Title": "Where can I find in the Standard a reference to the equivalence between *p and p[0], *(p+1) and p[1], ...?", "CreationDate": "2015-10-02T11:31:28.040", "Id": "32906247", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-10-02T11:49:33.693", "Score": "0", "OwnerUserId": "4470210", "Tags": "<c++><language-lawyer><c++14>", "AnswerCount": "2"}});