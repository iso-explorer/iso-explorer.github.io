post_cb({"47556024": {"CommentCount": "4", "ViewCount": "65", "CreationDate": "2017-11-29T15:14:23.450", "LastActivityDate": "2017-11-29T16:10:59.523", "Title": "How many bits are needed for signed int and behavior at bitwise shift to the left of a number that is a limit of his type", "AcceptedAnswerId": "47556329", "PostTypeId": "1", "Id": "47556024", "Score": "1", "Body": "<p><strong>Question \u2116 1:</strong>\n<em>how many bits are needed for <code>signed int</code>?</em></p>\n<p>I know that <code>int</code> requires 4 bytes or 32 bits (it depends on architecture, but usually it is so), and i also know that there one bit for sign of a number.</p>\n<p>2147483647 is only 31 bits, not 32. So, one bit for a sign?<br/>\n4294967295 is 32 bits. There no one bit for a sign (because <code>unsigned</code>).</p>\n<p>Why specify that <code>signed int</code> have 32 bits, when in fact its value can has only 31? Why not specify that one bit is given for a sign?</p>\n<p><br/>\n<strong>Question \u2116 2:</strong>\n<em>behavior at bitwise shift to the left of a number that is a limit of his type?</em></p>\n<p>What will be the value of a and b?</p>\n<pre><code>int a = 2147483647;\na &lt;&lt;= 1;\n\nunsigned int b = 4294967295;\nb &lt;&lt;= 1;\n</code></pre>\n<p>How does the value change when the number reached the limit of its type?<br/>\nSomewhere write that the behavior will be like a \u2116 1, and somewhere write, that the behavior will be like a \u2116 2.</p>\n<pre><code>1111111111111111111111111111111 &lt;&lt; 1 = 1111111111111111111111111111110; // \u2116 1.\n1111111111111111111111111111111 &lt;&lt; 1 = 10; // \u2116 2.\n</code></pre>\n", "Tags": "<c++><binary>", "OwnerUserId": "8445442", "AnswerCount": "1"}, "47556329": {"ParentId": "47556024", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The relevant rule here is <a href=\"http://eel.is/c++draft/expr.shift#2\" rel=\"nofollow noreferrer\">[expr.shift]/2</a>:</p>\n<blockquote>\n<p id=\"so_47556024_47556329_0\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. If <code>E1</code> has an unsigned type, the value of the result is E1 \u00d7 2<sup>E2</sup>, reduced modulo one more than the maximum value representable in the result type. Otherwise, if <code>E1</code> has a signed type and non-negative value, and E1 \u00d7 2<sup>E2</sup> is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>So, assuming you're on a platform with 32-bit 2s complement <code>int</code>, this:</p>\n<pre><code>int a = 2147483647;\na &lt;&lt;= 1;\n</code></pre>\n<p><code>a</code> has a signed type and <code>2147483647 x 2</code> is representable in <code>unsigned int</code>, so we get <code>0xfffffffe</code> as an <code>int</code>, which is <code>-2</code>.</p>\n<p>And this:</p>\n<pre><code>unsigned int b = 4294967295;\nb &lt;&lt;= 1;\n</code></pre>\n<p>is just modular arithmetic. We start with <code>0xffffffff</code>. Shift by one would give you <code>0x1fffffffe</code>, but then modulo 2<sup>32</sup> and get back <code>0xfffffffe</code>, which is <code>4294967294</code>.</p>\n<p>Both are well-defined behavior. However, note that <code>a &lt;&lt; 2</code> would be undefined behavior because <code>2147483647 x 4</code> is not representable in <code>unsigned int</code>. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-11-29T16:10:59.523", "Id": "47556329", "Score": "2", "CreationDate": "2017-11-29T15:29:23.210", "LastActivityDate": "2017-11-29T16:10:59.523"}, "bq_ids": {"n4140": {"so_47556024_47556329_0": {"section_id": 6147, "quality": 0.9333333333333333, "length": 42}}, "n3337": {"so_47556024_47556329_0": {"section_id": 5910, "quality": 0.7777777777777778, "length": 35}}, "n4659": {"so_47556024_47556329_0": {"section_id": 7643, "quality": 0.9333333333333333, "length": 42}}}});