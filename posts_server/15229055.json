post_cb({"15229573": {"ParentId": "15229055", "CommentCount": "1", "Body": "<p>You appear to have a misunderstanding about arrays and pointers in C++.</p>\n<h3>The array</h3>\n<pre><code>int A[512];\n</code></pre>\n<p>This declaration gets you an array of 512 <code>int</code>s. Nothing else. No pointer, no nothing. Just an array of <code>int</code>s. The size of the array will be <code>512 * sizeof(int)</code>.</p>\n<h3>The name</h3>\n<p>The name <code>A</code> refers to that array. It's not of pointer type. It's of array type. It is a name and it refers to the array. Names are simply compile-time constructs for telling the compiler what object you're talking about. Names don't exist at run-time.</p>\n<h3>The conversion</h3>\n<p>There is a conversion called array-to-pointer conversion that may occur <em>in some circumstances</em>. The conversion takes an expression which is of array type (such as the simple expression <code>A</code>) and converts it to a pointer to its first element. That is, in some situations, the expression <code>A</code> (which denotes the array) may be converted to an <code>int*</code> (which points at the first element in the array).</p>\n<h3>The pointer</h3>\n<p>The pointer that is created by array-to-pointer conversion exists for the duration of the expression it is part of. It is just a temporary object that appears in those particular circumstances.</p>\n<h3>The circumstances</h3>\n<p>An array-to-pointer conversion is a standard conversion and circumstances in which it may occur include:</p>\n<ul>\n<li><p>When casting from an array to a pointer. For example, <code>(int*)A</code>.</p></li>\n<li><p>When initialising an object of pointer type, e.g. <code>int* = A;</code>.</p></li>\n<li><p>Whenever glvalue referring to an array appears as the operand of an expression that expects a prvalue.</p>\n<p>This is what happens when you subscript an array, such as with <code>A[20]</code>. The subscript operator expects a prvalue of pointer type, so <code>A</code> undergoes array-to-pointer conversion.</p></li>\n</ul>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "15229573", "Score": "1", "CreationDate": "2013-03-05T16:52:27.843", "LastActivityDate": "2013-03-05T16:52:27.843"}, "15229184": {"ParentId": "15229055", "CommentCount": "15", "Body": "<p>I think you're confusing an array and pointer in C++.</p>\n<p>An array of <code>int</code> is just that, it's an array of locations in memory, each taking up <code>sizeof(int)</code> in which you can store N-1 <code>int</code>s.</p>\n<p>A pointer is a type which can point to a memory location, and takes up CPU register size in memory, so on a 32 bit machine, <code>sizeof(int*)</code> would be 32 bits.</p>\n<p>If you want to have a pointer into your array, you do this: <code>int * ptr = &amp;A[0];</code>  This points to the first element in the array.  Now you have the pointer taking up memory (CPU word size) and you have your array of <code>int</code>s. </p>\n<p>When you pass an array to a function in C or C++, it <em>decays</em> to a pointer to the first element in the array.  That doesn't say that a pointer is an array, it says there is a <em>decay</em> from an array to a pointer.</p>\n<p>In C# your array is a reference type, and you do not have pointers, so you don't worry about it. It just takes up the size of your array.</p>\n", "OwnerUserId": "174614", "PostTypeId": "2", "Id": "15229184", "Score": "0", "CreationDate": "2013-03-05T16:33:44.467", "LastActivityDate": "2013-03-05T16:33:44.467"}, "15229169": {"ParentId": "15229055", "CommentCount": "0", "Body": "<p>No, the objects in CLR does <em>not</em> map to the \"simple\" memory mapping of <code>C++</code> (I immagine) you refer too. Remember that you can operate over objects in <code>CLR</code> using reflection, that means that <em>every</em> object has to have additional information (<em>manifest</em>) inside it. This already adds more memory that just plain content of the object, add to this also a <em>pointer</em> for <code>locking</code> management in multithreaded environment and you go far away in terms of <em>expected</em> memory allocation for <code>CLR</code> object. </p>\n<p>Also remember that pointer size defers between <code>32</code> and <code>64</code> bit machines. </p>\n", "OwnerUserId": "156695", "PostTypeId": "2", "Id": "15229169", "Score": "0", "CreationDate": "2013-03-05T16:33:05.357", "LastActivityDate": "2013-03-05T16:33:05.357"}, "15229055": {"CommentCount": "11", "ViewCount": "615", "PostTypeId": "1", "LastEditorUserId": "1950197", "CreationDate": "2013-03-05T16:27:52.970", "LastActivityDate": "2013-03-05T17:30:47.350", "Title": "Does an array or object's pointer/reference handle affect its size?", "AcceptedAnswerId": "15229984", "LastEditDate": "2013-03-05T17:00:12.163", "Id": "15229055", "Score": "4", "Body": "<p>I know that if I have an array <code>int A[512]</code> that the reference A can point to the first element.  In pointer arithmetic, the memory is referenced as <code>A + index</code>.</p>\n<p>But if I'm not mistaken, the pointer/reference also takes up a machine word of space.  Assuming an int takes up a machine word, does that mean that the 512 integers of the above array take up 513 words of space?</p>\n<p>Is the same true/false for objects and their data members in C++ or C#?</p>\n<p><em>Update</em>: Wow you guys are fast.  To clarify, I'm interested in how C++ and C# <em>differ</em> in how they handle this, and how I can size objects to fit in a cache line (if possible).</p>\n<p><em>Update</em>: I have been made aware of the distinction between pointers and arrays.  I understand that arrays are not pointers, and that the pointer arithmetic I referenced above is only valid after the array has been converted to a pointer.  I don't think this distinction is relevant to the overall question however.  I'm interested in how both arrays and other objects are stored in memory in both C++ and C#.</p>\n", "Tags": "<c#><c++><arrays><memory-management><size>", "OwnerUserId": "1950197", "AnswerCount": "7"}, "15229984": {"ParentId": "15229055", "CommentCount": "1", "Body": "<p>Note that when you're talking about fitting data into a cache line, the variable containing the reference and the actual data it refers to are not going to be located in near proximity.  The reference is going to wind up in a register (eventually), but it's probably originally stored as part of another object somewhere else in memory, or as a local variable on the stack.  The array contents themselves can still fit in cache lines when being operated on, regardless of whatever other overhead is associated with the 'object'.  If you're curious about how this works in C#, Visual Studio has a Disassembler view that shows the actual x86 or x64 assembly generated for your code.</p>\n<p>Array references have special baked-in support at the IL (intermediate language) level, so you'll find that the way memory is loaded/used is essentially the same as using an array in C++.  Under the hood, indexing into an array is exactly the same operation.  Where you'll start to notice differences is if you index through arrays using 'foreach' or start having to 'unbox' references when the array is an array of object types.</p>\n<p>Note that one difference as far as memory locality between C++ and C# can show up when you instantiate objects locally in a method.  C++ allows you to instantiate arrays on the stack, which creates a special case where the array memory is actually stored in close proximity to the 'reference' and other local variables.  In C#, a (managed) array's contents will always wind up being allocated on the heap.</p>\n<p>On the other hand, when referring to heap-allocated objects, C# can sometimes have better locality of memory than C++, especially for short-lived objects.  This is due to the way that the GC stores objects by their 'generation' (how long they've been alive) and the heap compaction it does.  Short-lived objects are allocated quickly on a growing heap; when collected, the heap is also compacted, preventing the 'fragmentation' that can cause subsequent allocations in a non-compacted heap to be scattered in memory.</p>\n<p>You can get similar memory locality benefits in C++ using an 'object pooling' technique (or by avoiding frequent small short-lived objects), but that takes a bit of extra work and design.  The cost for this, of course, is that GC has to run, with thread hijacking, promoting generations, compacting and reassigning references causing a measurable overhead at somewhat unpredictable times.  In practice, the overhead is rarely a problem, especially with Gen0 collection, which is highly optimized for a usage pattern of frequently allocated short-lived objects.</p>\n", "OwnerUserId": "206394", "PostTypeId": "2", "Id": "15229984", "Score": "1", "CreationDate": "2013-03-05T17:12:32.780", "LastActivityDate": "2013-03-05T17:12:32.780"}, "15230331": {"ParentId": "15229055", "CommentCount": "0", "Body": "<p>We have multiple different examples here, given that we even have several languages to discuss.</p>\n<p>Let's start with the simple example, a simple array in C++:</p>\n<pre><code>int array[512];\n</code></pre>\n<p>What happens in terms of memory allocation here?  512 words of memory are allocated on the stack for the array.  No heap memory is allocated.  There is no overhead of any kind; no pointers to the array, no nothing, just the 512 words of memory.</p>\n<p>Here is an alternate method of creating an array in C++:</p>\n<pre><code>int * array = new int[512];\n</code></pre>\n<p>Here we're creating an array on the heap.  It will allocate 512 words of memory with no additional memory allocated on the heap.  Then, once that is done, an address to the start of that array will be placed in a variable on the stack, taking up an additional word of memory.  If you look at the total memory footprint for the entire application, yes it will be 513, but it's worth noting that one is on the stack and the rest is on the heap (stack memory is much cheaper to allocate, and doesn't cause fragmentation, but if you overuse it or mis-use it you can run out more easily.</p>\n<p>Now onto C#.  In C# we don't have the two different syntaxes, all you have is:</p>\n<pre><code>int[] array = new int[512];\n</code></pre>\n<p>This will create a new array object on the heap.  It will contain 512 words of memory for the data in the array, as well as a bit of extra memory for the overhead of the array object.  It will need 4 bytes to hold onto the count of the array, a synchronization object, and a few other bits of overhead that we don't really need to think about.  That overhead is small, and not dependent on the size of the array.  </p>\n<p>There will also be a pointer (or \"reference\", as would be more appropriate to use in C#) to that array that is placed on the stack, which will take up a word of memory.  Like C++, the stack memory can be allocated/deallocated very quickly, and without fragmenting memory, so when considering the memory footprint of your program it often makes sense to separate it.</p>\n", "OwnerUserId": "1159478", "PostTypeId": "2", "Id": "15230331", "Score": "0", "CreationDate": "2013-03-05T17:30:47.350", "LastActivityDate": "2013-03-05T17:30:47.350"}, "15229287": {"ParentId": "15229055", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Concerning <strong>native C++</strong>:</p>\n<blockquote>\n<p id=\"so_15229055_15229287_0\">But if I'm not mistaken, the pointer/reference also takes up a machine word of space</p>\n</blockquote>\n<p>A reference does not necessarily take space in memory. Per Paragraph 8.3.2/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15229055_15229287_1\">It is unspecified whether or not a reference requires storage (3.7).</p>\n</blockquote>\n<p>In this case, you can <em>use</em> <code>A</code> like a pointer, and indeed it does <em>decay</em> to a pointer when necessary (e.g. when passing it as an argument to functions), but the type of <code>A</code> is <code>int[512]</code>, not <code>int*</code>: therefore, <code>A</code> is <strong>not a pointer</strong>. For instance, you cannot do this:</p>\n<pre><code>int A[512];\nint B;\nA = &amp;B;\n</code></pre>\n<p>There doesn't need to be any memory location used to store <code>A</code> (i.e. used to store the memory address where the array begins), so most likely your compiler will not allocate any extra bytes of memory for holding the address of <code>A</code>.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-03-05T17:15:07.103", "Id": "15229287", "Score": "0", "CreationDate": "2013-03-05T16:38:33.940", "LastActivityDate": "2013-03-05T17:15:07.103"}, "bq_ids": {"n4140": {"so_15229055_15229287_1": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_15229055_15229287_1": {"section_id": 3095, "quality": 1.0, "length": 5}}, "n4659": {"so_15229055_15229287_1": {"section_id": 3978, "quality": 1.0, "length": 5}}}, "15229182": {"ParentId": "15229055", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>An array, <code>int A[512]</code> takes up 512 * sizeof(int) (+ any padding the compiler decides to add - in this particularly instance, very likely no padding). </p>\n<p>The fact that the array <code>A</code> can be converted to a pointer to int <code>A</code> and used with <code>A + index</code> uses the fact that in the implementation <code>A[index]</code> is almost always exactly the same instructions as <code>A + index</code>. The conversion to pointer happens in both cases, because to get to <code>A[index]</code>, we have to take the first address of the array A, and add <code>index</code> times <code>sizeof(int)</code> - whether you write that as <code>A[index]</code> or <code>A + index</code> doesn't make any difference. In both cases, <code>A</code> is referring to the first address in the array, and <code>index</code> the number of elements into it. </p>\n<p>There is no extra space used here. </p>\n<p>The above applies to C and C++. </p>\n<p>In C# and other languages that use \"managed memory\", there is extra overhead to track each variable. This does not impact the size of the variable <code>A</code> itself, but it does of course have to be stored somewhere, and thus every variable, whether it's a single integer or a very large array, will have some overhead, stored somewhere, including the size of the variable and some sort of \"reference count\" (how many places the variable is used, and if it can be removed). </p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2013-03-05T16:40:15.707", "Id": "15229182", "Score": "0", "CreationDate": "2013-03-05T16:33:38.207", "LastActivityDate": "2013-03-05T16:40:15.707"}});