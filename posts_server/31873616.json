post_cb({"31873942": {"ParentId": "31873616", "CommentCount": "8", "Body": "<p>The worst that can happen in your snippet is that <code>new</code> throws <code>std::bad_alloc</code>, which is unhandled. What happens then is implementation-defined.</p>\n<p>With the best case being a no-op and the worst case not being defined, the compiler is allowed to factor them into non-existence. Now, if you actually try and catch the possible exception :</p>\n<pre><code>int main() try {\n    int* mem = new int[100];\n    return 0;\n} catch(...) {\n  return 1;\n}\n</code></pre>\n<p>... then <a href=\"https://goo.gl/lBBF5l\" rel=\"nofollow\">the call to <code>operator new</code> is kept</a>.</p>\n", "OwnerUserId": "3233393", "PostTypeId": "2", "Id": "31873942", "Score": "2", "CreationDate": "2015-08-07T09:13:48.023", "LastActivityDate": "2015-08-07T09:13:48.023"}, "31877074": {"ParentId": "31873616", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The history seems to be that clang is following the rules laid out in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html\" rel=\"noreferrer\">N3664: Clarifying Memory Allocation</a> which allows the compiler to optimize around memory allocations but as <a href=\"https://stackoverflow.com/a/25708984/1708801\">Nick Lewycky points out</a> :</p>\n<blockquote>\n<p id=\"so_31873616_31877074_0\">Shafik pointed out that seems to violate causality but N3664 started life as N3433, and I'm pretty sure we wrote the optimization first and wrote the paper afterwards anyway.</p>\n</blockquote>\n<p>So clang implemented the optimization which later on became a proposal that was implemented as part of C++14.</p>\n<p>The base question is whether this is a valid optimization prior to <code>N3664</code>, that is a tough question. We would have to go to the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"noreferrer\">as-if rule</a> covered in the draft C++ standard section <code>1.9</code> <em>Program execution</em> which says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_31873616_31877074_1\">The semantic descriptions in this International Standard define a\n  parameterized nondeterministic abstract machine. This International\n  Standard places no requirement on the structure of conforming\n  implementations. In particular, they need not copy or emulate the\n  structure of the abstract machine. Rather, <strong>conforming implementations\n  are required to emulate (only) the observable behavior of the abstract\n  machine</strong> as explained below.<sup>5</sup></p>\n</blockquote>\n<p>where note <code>5</code> says:</p>\n<blockquote>\n<p id=\"so_31873616_31877074_2\">This provision is sometimes called the <strong>\u201cas-if\u201d rule</strong>, because an\n  implementation is free to disregard any requirement of this\n  International Standard as long as the result is as if the requirement\n  had been obeyed, as far as can be determined from the observable\n  behavior of the program. For instance, an actual implementation need\n  not evaluate part of an expression if it can deduce that its value is\n  not used and that no side effects affecting the observable behavior of\n  the program are produced.</p>\n</blockquote>\n<p>Since <code>new</code> could throw an exception which would have observable behavior since it would alter the return value of the program, that would seem to argue against it being allowed by the <em>as-if rule</em>. </p>\n<p>Although, it could be argued it is implementation detail when to throw an exception and therefore clang could decide even in this scenario it would not cause an exception and therefore eliding the <code>new</code> call would not violate the <em>as-if rule</em>. </p>\n<p>It also seems valid under the <em>as-if rule</em> to optimize away the call to the non-throwing version as well.</p>\n<p>But we could have a replacement global operator new in a different translation unit which could cause this to affect observable behavior, so the compiler would have to have some way a proving this was not the case, otherwise it would not be able to perform this optimization without violating the <em>as-if rule</em>. Previous versions of clang did indeed optimize in this case as <a href=\"http://goo.gl/Ug58DC\" rel=\"noreferrer\">this godbolt example shows</a> which was provided via <a href=\"https://stackoverflow.com/questions/25668420/clang-vs-gcc-optimization-including-operator-new#comment40118998_25669763\">Casey here</a>, taking this code:</p>\n<pre><code>#include &lt;cstddef&gt;\n\nextern void* operator new(std::size_t n);\n\ntemplate&lt;typename T&gt;\nT* create() { return new T(); }\n\nint main() {\n    auto result = 0;\n    for (auto i = 0; i &lt; 1000000; ++i) {\n        result += (create&lt;int&gt;() != nullptr);\n    }\n\n    return result;\n}\n</code></pre>\n<p>and optimizing it to this:</p>\n<pre><code>main:                                   # @main\n    movl    $1000000, %eax          # imm = 0xF4240\n    ret\n</code></pre>\n<p>This indeed seems way too aggressive but later versions do not seem to do this.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:40.460", "Id": "31877074", "Score": "35", "CreationDate": "2015-08-07T11:51:52.493", "LastActivityDate": "2015-08-11T14:21:36.653"}, "31875487": {"ParentId": "31873616", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is allowed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html\" rel=\"noreferrer\">N3664</a>. </p>\n<blockquote>\n<p id=\"so_31873616_31875487_0\">An implementation is allowed to omit a call to a replaceable global allocation function (18.6.1.1, 18.6.1.2). When it does so, the storage is instead provided by the implementation or provided by extending the allocation of another new-expression.</p>\n</blockquote>\n<p>This proposal is part of the C++14 standard, so in C++14 the compiler <em>is</em> allowed to optimize out a <code>new</code> expression (even if it might throw).</p>\n<p>If you take a look at the <a href=\"http://clang.llvm.org/cxx_status.html\" rel=\"noreferrer\">Clang implementation status</a> it clearly states that they do implement N3664.</p>\n<p>If you observe this behavior while compiling in C++11 or C++03 you should fill a bug.</p>\n<p>Notice that before C++14 dynamic memory allocations <em>are part of the observable status</em> of the program (although I can not find a reference for that at the moment), so a conformant implementation was not allowed to apply the <em>as-if</em> rule in this case.</p>\n", "OwnerUserId": "666785", "LastEditorUserId": "666785", "LastEditDate": "2015-08-07T10:45:32.030", "Id": "31875487", "Score": "15", "CreationDate": "2015-08-07T10:24:58.030", "LastActivityDate": "2015-08-07T10:45:32.030"}, "31873884": {"ParentId": "31873616", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Bear in mind the C++ standard tells what a correct program should do, not how it should do it. It can't tell the later at all since new architectures can and do arise after the standard is written and the standard has to be of use to them. </p>\n<p><code>new</code> does not have to be a system call under the hood. There are computers usable without operating systems and without a concept of system call.</p>\n<p>Hence, as long as the end behaviour does not change, the compiler can optimize any and everything away. Including that <code>new</code></p>\n<p>There is one caveat.<br>\nA replacement global operator new could have been defined in a different translation unit<br>\nIn that case the side effects of new could be such that can't be optimized away. But if the compiler can guarantee that the new operator has no side effects, as would be the case if the posted code is the whole code, then the optimization is valid.<br>\nThat new can throw std::bad_alloc is not a requirement. In this case, when new is optimized, the compiler can guarantee that no exception will be thrown and no side effect will happen.</br></br></br></p>\n", "OwnerUserId": "956880", "LastEditorUserId": "956880", "LastEditDate": "2015-08-07T10:57:30.327", "Id": "31873884", "Score": "10", "CreationDate": "2015-08-07T09:11:06.263", "LastActivityDate": "2015-08-07T10:57:30.327"}, "31873616": {"CommentCount": "0", "AcceptedAnswerId": "31877074", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-08-07T08:57:24.933", "LastActivityDate": "2015-10-30T03:20:43.207", "LastEditDate": "2015-10-30T03:20:43.207", "ViewCount": "3077", "FavoriteCount": "5", "Title": "Is the compiler allowed to optimize out heap memory allocations?", "Id": "31873616", "Score": "52", "Body": "<p>Consider the following simple code that makes use of <code>new</code> (I am aware there is no <code>delete[]</code>, but it does not pertain to this question):</p>\n<pre><code>int main()\n{\n    int* mem = new int[100];\n\n    return 0;\n}\n</code></pre>\n<p>Is the compiler allowed to optimize out the <code>new</code> call?</p>\n<p>In my research, <a href=\"https://goo.gl/bMyi5Q\">g++ (5.2.0)</a> and Visual Studio 2015 do not optimize out the <code>new</code> call, <a href=\"https://goo.gl/VmHLSL\">while clang (3.0+) does</a>. All tests have been made with full optimizations enabled (-O3 for g++ and clang, Release mode for Visual Studio).</p>\n<p>Isn't <code>new</code> making a system call under the hood, making it impossible (and illegal) for a compiler to optimize that out?</p>\n<p><strong>EDIT</strong>: I have now excluded undefined behaviour from the program:</p>\n<pre><code>#include &lt;new&gt;  \n\nint main()\n{\n    int* mem = new (std::nothrow) int[100];\n    return 0;\n}\n</code></pre>\n<p><a href=\"https://goo.gl/Bwfn07\">clang 3.0 does not optimize that out</a> anymore, but <a href=\"https://goo.gl/6ai43G\">later versions do</a>.</p>\n<p><strong>EDIT2</strong>: </p>\n<pre><code>#include &lt;new&gt;  \n\nint main()\n{\n    int* mem = new (std::nothrow) int[1000];\n\n    if (mem != 0)\n      return 1;\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"https://goo.gl/L9NuaZ\">clang always returns 1</a>.</p>\n", "Tags": "<c++><gcc><optimization><clang><language-lawyer>", "OwnerUserId": "2676096", "AnswerCount": "5"}, "31875379": {"ParentId": "31873616", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>It is perfectly allowable (but <em>not required</em>) for a compiler to optimize out the allocations in your original example, and even more so in the EDIT1 example per \u00a71.9 of the standard, which is usually referred to as the <em>as-if rule</em>:</p>\n<blockquote>\n<p id=\"so_31873616_31875379_0\">Conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below:<br>\n  [3 pages of conditions]</br></p>\n</blockquote>\n<p>A more human-readable representation is available at <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow\">cppreference.com</a>.</p>\n<p>The relevant points are:</p>\n<ul>\n<li>You have no volatiles, so 1) and 2) do not apply.</li>\n<li>You do not output/write any data or prompt the user, so 3) and 4) do not apply. But even if you did, they would clearly be satisfied in EDIT1 (arguably <em>also</em> in the original example, although from a purely theoretical point of view, it is illegal since the program flow and output -- theoretically -- differs, but see two paragraphs below).</li>\n</ul>\n<p>An exception, even an uncaught one, is well-defined (not undefined!) behavior. However, strictly speaking, in case that <code>new</code> throws (not going to happen, see also next paragraph), the observable behavior would be different, both by the program's exit code and by any output that might follow later in the program.</p>\n<p>Now, in the particular case of a singular small allocation, you can give the compiler the <em>\"benefit of doubt\"</em> that it can <strong>guarantee</strong> that the allocation will not fail.<br>\nEven on a system under very heavy memory pressure, it is not possible to even start a process when you have less than the minimum allocation granularity available, and the heap will have been set up prior to calling <code>main</code>, too. So, if this allocation was to fail, the program would never start or would already have met an ungraceful end before <code>main</code> is even called.<br>\nInsofar, assuming that the compiler knows this, even though the allocation <em>could in theory throw</em>, it is legal to even optimize the original example, since the compiler can <em>practically</em> guarantee that it will not happen.</br></br></p>\n<p>&lt;slightly undecided&gt;<br>\nOn the other hand, it is <strong>not</strong> allowable (and as you can observe, a compiler bug) to optimize out the allocation in your EDIT2 example. The value is consumed to produce an externally observable effect (the return code).<br>\nNote that if you replace <code>new (std::nothrow) int[1000]</code> with <code>new (std::nothrow) int[1024*1024*1024*1024ll]</code> (that's a 4TiB allocation!), which is -- on present day computers -- guaranteed to fail, it still optimizes out the call. In other words, it returns 1 although you wrote code that must output 0.</br></br></p>\n<p>@Yakk brought up a good argument against this: As long as the memory is never touched, a pointer can be returned, and not actual RAM is needed. Insofar it would even be legitimate to optimize out the allocation in EDIT2. I am unsure who is right and who is wrong here.</p>\n<p>Doing a 4TiB allocation is pretty much guaranteed to fail on a machine that doesn't have at least something like a two-digit gigabyte amount of RAM simply because the OS needs to create page tables. Now of course, the C++ standard does not care about page tables or about what the OS is doing to provide memory, that is true.</p>\n<p>But on the other hand, the assumption \"this will work if memory is not touched\" <em>does rely</em> on exactly such a detail and on something that the OS provides. The assumption that if RAM that is not touched it is actually not needed is only true <em>because</em> the OS provides virtual memory. And that implies that the OS needs to create page tables (I can pretend that I don't know about it, but that doesn't change the fact that I rely on it anyway).</p>\n<p>Therefore, I think it is not 100% correct to first assume one and then say \"but we don't care about the other\".</p>\n<p>So, yes, the compiler <em>can</em> assume that a 4TiB allocation is in general perfectly possible as long as memory is not touched, and it <em>can</em> assume that it is generally possible to succeed. It might even assume that it's likely to succeed (even when it's not). But I think that in any case, you are never allowed to assume that something <strong>must</strong> work when there is a possibility of a failure. And not only is there a possibility of failure, in that example, failure is even the <em>more likely</em> possibility.<br>\n&lt;/slightly undecided&gt;</br></p>\n", "OwnerUserId": "572743", "LastEditorUserId": "572743", "LastEditDate": "2015-08-07T11:07:33.017", "Id": "31875379", "Score": "6", "CreationDate": "2015-08-07T10:18:56.573", "LastActivityDate": "2015-08-07T11:07:33.017"}, "bq_ids": {"n4140": {"so_31873616_31875487_0": {"section_id": 6091, "quality": 0.9047619047619048, "length": 19}, "so_31873616_31877074_2": {"section_id": 5797, "quality": 0.9285714285714286, "length": 39}, "so_31873616_31875379_0": {"section_id": 5797, "quality": 0.75, "length": 9}, "so_31873616_31877074_1": {"section_id": 5797, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_31873616_31877074_2": {"section_id": 5570, "quality": 0.9285714285714286, "length": 39}, "so_31873616_31875379_0": {"section_id": 5570, "quality": 0.75, "length": 9}, "so_31873616_31877074_1": {"section_id": 5570, "quality": 0.8648648648648649, "length": 32}}, "n4659": {"so_31873616_31877074_1": {"section_id": 7256, "quality": 0.8648648648648649, "length": 32}, "so_31873616_31877074_2": {"section_id": 7256, "quality": 0.9285714285714286, "length": 39}, "so_31873616_31875379_0": {"section_id": 7256, "quality": 0.75, "length": 9}, "so_31873616_31875487_0": {"section_id": 7587, "quality": 0.9047619047619048, "length": 19}}}});