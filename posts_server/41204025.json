post_cb({"bq_ids": {"n4140": {"so_41204025_41881445_4": {"length": 8, "quality": 0.8, "section_id": 467}}, "n3337": {"so_41204025_41881445_4": {"length": 8, "quality": 0.8, "section_id": 458}}, "n4659": {"so_41204025_41881445_4": {"length": 8, "quality": 0.8, "section_id": 490}}}, "41882611": {"Id": "41882611", "PostTypeId": "2", "Body": "<p>There's no warning because a <code>const T&amp;</code> is just as likely to be a reference to an lvalue as it is to be a reference to an rvalue.</p>\n<pre><code>void func() {\n    MyType mt;\n    const MyType&amp; l = getref(mt);\n    const MyType&amp; r = getref(MyType{});\n}\n</code></pre>\n<p>Considering that <code>getref(mt)</code> is entirely valid, this leaves us with three options:</p>\n<ul>\n<li>Emit a warning for any function that both takes and returns a <code>(cv) T&amp;</code>, regardless of whether it was called with an lvalue or an rvalue.  This penalises legal code, so it's not a good option.  [While this would be better served by only emitting a warning if the function specifically returns its parameter, this is infeasible for the reason mentioned below.  Thus, the compiler would emit an error if the parameter and return value are the same type.]<br>\n[Note that this could cause problems with perfect forwarding.  For example, <code>std::move()</code> uses perfect forwarding to take a parameter by reference or rvalue reference, then return an rvalue reference to that parameter.  Any algorithm that doesn't account for this would see it as both taking and returning a <code>T&amp;&amp;</code>.]</br></li>\n<li>Emit a warning when <code>getref()</code> is passed an rvalue.  This requires that the compiler keep the information \"<code>getref()</code> is a potential source of UB if passed an rvalue\" in memory at all times, and that it examine every call.  Not only does this cause additional overhead, it effectively requires <code>getref()</code> to be <code>inline</code> (due to compilers typically being designed to only operate on a single translation unit at a time, <code>getref()</code> must be defined in every module where it's used for the compiler to retain this information).  This is infeasible at the moment, but may become more practical with future compilers (such as if cross-module optimisation becomes standard).</li>\n<li>Never emit a warning, on the assumption that the programmer either is wise enough to never pass <code>getref()</code> an rvalue, or specifically intends for <code>getref()</code> to be a potential source of UB.  This is the most viable option, as it neither penalises legal code, nor requires a compiler capable of cross-module optimisation.</li>\n</ul>\n<p>Thus, most compilers will typically choose not to emit a warning, on the assumption that the programmer knows what they're doing.  Even with <code>-Wall</code> specified, Clang, GCC, ICC, and MSVC won't emit any warnings for this.</p>\n", "LastActivityDate": "2017-01-26T20:41:20.207", "CommentCount": "0", "CreationDate": "2017-01-26T20:41:20.207", "ParentId": "41204025", "Score": "1", "OwnerUserId": "5386374"}, "41881445": {"Id": "41881445", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41204025_41881445_0\">No matter how hard I tried allocating other things on the stack before the print, I couldn't get it to print the wrong thing without making the destructor explicitly change the data. Why is this?</p>\n</blockquote>\n<p>You're invoking undefined behaviour; anything could happen at this point!</p>\n<blockquote>\n<p id=\"so_41204025_41881445_1\">Why isn't there a clang warning for this? There is a warning for returning a ref to a local variable.</p>\n<p id=\"so_41204025_41881445_2\">Are there any valid (safe) use cases of returning a reference to an argument?</p>\n</blockquote>\n<p><strong>std::max</strong></p>\n<p>Suppose you want the max of two values:</p>\n<pre><code>auto foo = std::max(x, y); // foo is a copy of the result\n</code></pre>\n<p>You might not want a copy to be returned (for performance or semantic reasons). Luckily, <code>std::max</code> returns a reference, allowing for both use cases:</p>\n<pre><code>auto  foo = std::max(x, y); // foo is a copy of the result\nauto&amp; bar = std::max(x, y); // bar is a reference to the result\n</code></pre>\n<p>An example of where it matters for semantics reasons is when used in conjunction with <code>std::swap</code>:</p>\n<pre><code>std::swap(x, std::max(y, z));\n</code></pre>\n<p>Imagine that <code>std::max</code> returned a copy of <code>y</code>. Rather than swapping with <code>x</code> with <code>y</code>, <code>x</code> would we swapped with a copy of <code>y</code>. In other words, <code>y</code> would remain unchanged.</p>\n<p><strong>Assignment</strong></p>\n<p>A common use case of this is the assignment operator. Take this for example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass T {\npublic:\n    T(int _x) : x(_x) { }\n    T&amp; operator=(const T&amp; rhs) { x = rhs.x; return *this; }\n    int getX() const { return x; }\n\nprivate:\n    int x = 0;\n};\n\nint main() {\n    T instanceA(42);\n    T instanceB(180);\n\n    std::cout &lt;&lt; (instanceA = instanceB).getX() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>You can think of the hidden <code>this</code> parameter as a non-null pointer (so close enough to a reference for the purposes of this question).</p>\n<p>Defining a copy-assignment operator as such is generally considered idomatic. One of the reasons this is so is because the automatically generated copy-assignment operator has that signature:</p>\n<blockquote>\n<p id=\"so_41204025_41881445_3\"><strong>N4618 12.8.2.2 Copy/move assignment operator [class.copy.assign]</strong></p>\n<p id=\"so_41204025_41881445_4\">The implicitly-declared copy assignment operator for a class will have the form <code>X&amp; X::operator=(const X&amp;)</code></p>\n</blockquote>\n<p>Making this a warning would penalize canonical code! As for why one might want to do such a thing (aside from it being canonical), that's another topic...</p>\n", "LastEditorUserId": "1816262", "LastActivityDate": "2017-01-26T21:56:09.537", "Score": "3", "CreationDate": "2017-01-26T19:30:24.743", "ParentId": "41204025", "CommentCount": "2", "OwnerUserId": "1816262", "LastEditDate": "2017-01-26T21:56:09.537"}, "41204025": {"ViewCount": "96", "Body": "<p>I understand that returning a reference to a function argument could invoke undefined behaviour as in the below example. The first 'MyType' created goes out of scope after the function call and is destroyed, leading to a dangling reference.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct MyType {\n    std::string data;\n    inline ~MyType() {\n        data = \"Destroyed!!\";\n    }\n};\n\nconst MyType&amp; getref(const MyType&amp; x) {\n    return x;\n}\n\nint main(int argc, char *argv[]) {\n    const MyType&amp; test = getref(MyType {\"test\"});\n    std::cout &lt;&lt; test.data &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>My questions are:</p>\n<ul>\n<li>Why isn't there a clang warning for this? There is a warning for returning a ref to a local variable.</li>\n<li>No matter how hard I tried allocating other things on the stack before the print, I couldn't get it to print the wrong thing without making the destructor explicitly change the data. Why is this?</li>\n<li>Are there any valid (safe) use cases of returning a reference to an argument?</li>\n</ul>\n", "AcceptedAnswerId": "41881445", "Title": "No clang warning for returning a reference to function argument", "CreationDate": "2016-12-17T23:23:56.353", "Id": "41204025", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2017-01-26T21:56:09.537", "Score": "3", "OwnerUserId": "3640643", "Tags": "<c++><c++11><clang>", "AnswerCount": "2"}});