post_cb({"12259895": {"ParentId": "12259771", "LastEditDate": "2012-09-04T08:55:39.353", "CommentCount": "3", "CreationDate": "2012-09-04T08:50:34.300", "Score": "0", "LastEditorUserId": "476681", "PostTypeId": "2", "Id": "12259895", "OwnerUserId": "476681", "Body": "<p>In your example, when you call vector::resize() method,  the constructor is called instead of the copy constructor. That is why you do not see assert being triggered.</p>\n<p>As for why you need the copy-constructor (and move constructor, which you haven't defined and declared), is that the template types have to be Copy-constructable and move-constructable. [container.requirements.general]/15 defines the requirements for container's type :</p>\n<pre><code>\u2014 T is DefaultInsertable into X means that the following expression is well-formed: allocator_traits&lt;A&gt;::construct(m, p);\n\u2014 An element of X is default-inserted if it is initialized by evaluation of the expression allocator_traits&lt;A&gt;::construct(m, p);\nwhere p is the address of the uninitialized storage for the element allocated within X.\n\u2014 T is CopyInsertable into X means that the following expression is well-formed: allocator_traits&lt;A&gt;::construct(m, p, v);\n\u2014 T is MoveInsertable into X means that the following expression is well-formed: allocator_traits&lt;A&gt;::construct(m, p, rv);\n\u2014 T is EmplaceConstructible into X from args , for zero or more arguments args, means that the following expression is well-formed: allocator_traits&lt;A&gt;::construct(m, p, args);\n\u2014 T is Erasable from X means that the following expression is well-formed: allocator_traits&lt;A&gt;::destroy(m, p);\n</code></pre>\n", "LastActivityDate": "2012-09-04T08:55:39.353"}, "12259886": {"ParentId": "12259771", "CommentCount": "0", "CreationDate": "2012-09-04T08:50:10.680", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "12259886", "Score": "4", "Body": "<p>The latest revision of the standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow\">n3376</a>) says:</p>\n<blockquote>\n<p id=\"so_12259771_12259886_0\">12 - If <code>size() &lt; sz</code>,\n  appends <code>sz - size()</code> default-inserted elements to the sequence.<br/>\n  13 - Requires: <code>T</code> shall be <code>MoveInsertable</code> and <code>DefaultInsertable</code> into <code>*this</code>.</p>\n</blockquote>\n<p>The implication is that <code>MoveInsertable</code> is required for any reallocation that might occur, while <code>DefaultInsertable</code> is required for the actual appending.  So your copy or move constructor will fire only if your vector already contains elements and needs to be reallocated.</p>\n<p>Indeed, if we write:</p>\n<pre><code>std::vector&lt;A&gt; a;\na.resize(1);\nassert(!a.empty() &amp;&amp; a.capacity() &lt; 4);\na.resize(4);\n</code></pre>\n<p>then the copy- or move-constructor of <code>A</code> is called, and your assert is triggered.</p>\n", "LastActivityDate": "2012-09-04T08:50:10.680"}, "12259864": {"ParentId": "12259771", "CommentCount": "1", "CreationDate": "2012-09-04T08:48:40.020", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "12259864", "Score": "3", "Body": "<p>In order to <code>resize</code> a vector, existing elements must be placed into the newly-allocated chunk of memory if the vector didn't have enough space to hold the elements required by the new size. This is done by copy-constructing them. So you must have a copy constructor to resize a vector. In this case, there are no existing elements, so the copy constructor is not called. But it still must be present.</p>\n", "LastActivityDate": "2012-09-04T08:48:40.020"}, "bq_ids": {"n4140": {"so_12259771_12259886_0": {"section_id": 810, "quality": 0.6, "length": 6}}, "n4659": {"so_12259771_12259886_0": {"section_id": 868, "quality": 0.6, "length": 6}}}, "12259771": {"CommentCount": "2", "ViewCount": "289", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-09-04T08:41:25.460", "LastActivityDate": "2012-09-04T08:55:39.353", "Title": "strange behaviour of std::vector::resize() with gcc 4.7.0", "AcceptedAnswerId": "12259886", "LastEditDate": "2017-05-23T12:27:36.510", "Id": "12259771", "Score": "2", "Body": "<p>I'm still confused about the behaviour of <code>std::vector::resize()</code>. Consider the following code (see also <a href=\"https://stackoverflow.com/questions/12251368/type-requirements-for-stdvectortype\">type requirements for std::vector&lt;type&gt;</a>)</p>\n<pre><code>struct A {\n  A() : X(0) { std::cerr&lt;&lt;\" A::A(); this=\"&lt;&lt;this&lt;&lt;'\\n'; }\n  A(A const&amp;) { assert(0); }  // is required but doesn't fire in vector::resize\n  int X;\n};\n\nint main()\n{\n  std::vector&lt;A&gt; a;\n  a.resize(4);        // would not compile without A::A(A const&amp;) or A::A(A&amp;&amp;)\n}\n</code></pre>\n<p>Without <code>A::A(A const&amp;)</code> or <code>A::A(A&amp;&amp;)</code>, the line with <code>a.resize(4);</code> doesn't compile. However, that constructor is never called: the <code>assert(0)</code> doesn't fire! Can somebody explain that to me?</p>\n<p>My interpretation is that the presence of either of these constructors is required by the template magic of <code>allocator_traits&lt;&gt;</code> (used by <code>std::vector::resize()</code>), but is actually never called. However, why would you require the presence of a method if you're not calling it?</p>\n", "Tags": "<c++><constructor><c++11><allocation><stdvector>", "OwnerUserId": "1023390", "AnswerCount": "3"}});