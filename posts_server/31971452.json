post_cb({"31971452": {"ViewCount": "138", "Body": "<p>Is it a bad practice to rely on local objects get destructed in the reverse order of construction in C++, or should I explicitly delete them in the reverse order in the destructor to make sure it follows that order?</p>\n<hr>\n<p>yup, you guys are right, the question itself is bad.</p>\n<p>So basically this is the scenario:</p>\n<pre><code>  class A {\n  private:\n    unique_ptr&lt;Something&gt; firstP;\n    unique_ptr&lt;Something&gt; secondP;\n  };\n</code></pre>\n<p>At certain point firstP and secondP will both get Something they need to own. And what I need is to make sure that when A gets destructed, firstP will be destructed later than second P, so the Something firstP owns lives longer than the Something secondP owns.</p>\n<p>Apparently if I can rely on the fact that secondP will be destrctued earlier than firstP, then I don't have to do anything here. But if I cannot rely on that, I would need to explicitly reset them in the order I want in the destructor of A.</p>\n<p>Ye, the design could have been better than this.. </p>\n</hr>", "AcceptedAnswerId": "31971497", "Title": "Is it a bad practice to rely on local objects get destructed in the reverse order of construction in c++", "CreationDate": "2015-08-12T17:09:48.237", "Id": "31971452", "CommentCount": "4", "LastEditDate": "2015-08-12T17:27:33.700", "PostTypeId": "1", "LastEditorUserId": "830828", "LastActivityDate": "2015-08-12T17:45:05.190", "Score": "2", "OwnerUserId": "830828", "Tags": "<c++>", "AnswerCount": "5"}, "31972038": {"Id": "31972038", "PostTypeId": "2", "Body": "<p>12.4.8 of the C++11 standard has</p>\n<blockquote>\n<p id=\"so_31971452_31972038_0\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a\n  destructor for class X calls the destructors for X\u2019s direct non-variant non-static data members, the destructors\n  for X\u2019s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the\n  destructors for X\u2019s virtual base classes. All destructors are called as if they were referenced with a qualified\n  name, that is, ignoring any possible virtual overriding destructors in more derived classes. <strong>Bases and\n  members are destroyed in the reverse order of the completion of their constructor</strong> (see 12.6.2).</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Now since you do not have a constructor one is provided for you by the compiler.  The provided constructor will construct the class members in the order they are declared in the class.  So in</p>\n<pre><code>class A {\nprivate:\n    unique_ptr&lt;Something&gt; firstP;\n    unique_ptr&lt;Something&gt; secondP;\n  };\n</code></pre>\n<p><code>secondP</code> will be constructed last and destroyed first.</p>\n", "LastActivityDate": "2015-08-12T17:45:05.190", "CommentCount": "0", "CreationDate": "2015-08-12T17:45:05.190", "ParentId": "31971452", "Score": "1", "OwnerUserId": "4342498"}, "bq_ids": {"n4140": {"so_31971452_31972038_0": {"length": 59, "quality": 0.9672131147540983, "section_id": 404}}, "n3337": {"so_31971452_31972038_0": {"length": 59, "quality": 0.9672131147540983, "section_id": 395}}, "n4659": {"so_31971452_31972038_0": {"length": 59, "quality": 0.9672131147540983, "section_id": 422}}}, "31971520": {"Id": "31971520", "PostTypeId": "2", "Body": "<p>You shouldn't call <code>delete</code> on objects allocated on the local stack, nor should you call destructors explicitly.<br>\nThese are called as soon the scope is left.</br></p>\n<p>And yes, you can rely on the destructors will be called in reverse order of construction in a local scope.</p>\n<hr>\n<p>As for your edits with the sample. The same statement about construction and destructor calls holds true for class member variables as well. You can rely on destructors will be called in reverse order of their declaration in this case.</p>\n</hr>", "LastEditorUserId": "1413395", "LastActivityDate": "2015-08-12T17:34:47.650", "Score": "2", "CreationDate": "2015-08-12T17:13:10.920", "ParentId": "31971452", "CommentCount": "2", "OwnerUserId": "1413395", "LastEditDate": "2015-08-12T17:34:47.650"}, "31971497": {"Id": "31971497", "PostTypeId": "2", "Body": "<p>Reverse order of destruction is guaranteed for automatic variables. Same guarantee is there for destruction order of class member variables. Use it to your advantage.</p>\n", "LastEditorUserId": "341065", "LastActivityDate": "2015-08-12T17:38:08.367", "Score": "6", "CreationDate": "2015-08-12T17:12:13.603", "ParentId": "31971452", "CommentCount": "4", "OwnerUserId": "341065", "LastEditDate": "2015-08-12T17:38:08.367"}, "31971615": {"Id": "31971615", "PostTypeId": "2", "Body": "<p>It is good practice to rely on the compiler to follow the rules of the language and destroy objects in the reverse order to the order they were constructed.</p>\n<p>It would be <em>extremely bad</em> practice to try and do this manually in the destructor yourself. For one, it is rarely correct to explicitly call a destructor unless you are writing an allocator of some kind or writing your own container class (and even then it often isn't necessary). </p>\n<p>Even if that was not the case, it would still be bad practice to manually write code that the compiler is guaranteed to generate for you anyway - not only is it bad practice in general to write unnecessary code but in this case manually written code is much more prone to mistakes, particularly under maintenance when members are added, removed or moved around.</p>\n", "LastActivityDate": "2015-08-12T17:20:04.520", "CommentCount": "0", "CreationDate": "2015-08-12T17:20:04.520", "ParentId": "31971452", "Score": "2", "OwnerUserId": "139091"}, "31971743": {"Id": "31971743", "PostTypeId": "2", "Body": "<p>Reverse order is guaranteed for local variables and for class fields. It is a highly usefull feature of C++ and you definitely should use it when appropriate. There is a widespread idiom called <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">RAII</a> that uses this feature.</p>\n<p>You should <strong>not</strong> explicitly delete them in the destructor, whatever it means.</p>\n<p>If you are talking about calling destructors manually (like <code>x.~T();</code>, it is almost always unnecessary: the compiler will generate destructor calls for object fields in the reverse order of their declarations. So, calling destructors manually will be needless, and may lead to errors if your objects are not ready to being deleted twice.</p>\n<p>If you meant calling <code>delete x;</code>, then it is also bad practice in modern C++. Unless you <em>really</em> need a raw pointer, either use smart pointers (<a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow\"><code>std::unique_ptr</code></a> or <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\"><code>std::shared_ptr</code></a>) or store the object simply by value, without pointers.</p>\n", "LastActivityDate": "2015-08-12T17:27:33.040", "CommentCount": "0", "CreationDate": "2015-08-12T17:27:33.040", "ParentId": "31971452", "Score": "0", "OwnerUserId": "2315602"}});