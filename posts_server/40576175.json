post_cb({"40576175": {"ViewCount": "52", "Body": "<p>I was just modifying an old example of my code by adding a <em>digit separator</em> to a user-defined literal, parsed by a variadic template:</p>\n<pre><code>namespace lits {\n  // helper for 1 arg\n  template&lt;char C&gt; int bin();  // common\n  template&lt;&gt;       int bin&lt;'1'&gt;() { return 1; } // spec.\n  template&lt;&gt;       int bin&lt;'0'&gt;() { return 0; } // spec.\n  // helper 2 or more args\n  template&lt;char C, char D, char... ES&gt;\n  int bin() {\n    return bin&lt;C&gt;() &lt;&lt; (sizeof...(ES)+1) | bin&lt;D,ES...&gt;() ;\n  }\n  // operator\"\" _bin\n  template&lt;char...CS&gt; int operator\"\" _bin()\n    { return bin&lt;CS...&gt;(); };\n}\nint main() {\n  using namespace lits;\n  int number = 1000'0000_bin; // &lt;&lt;&lt; I added a ' here\n}\n</code></pre>\n<p>Boy, was I surprised when by <em>g++6.2.0</em> tried to instantiate <code>bin&lt;'\\''&gt;</code>. It tried to pass the <code>'</code> as a <code>char</code> to my template <code>template&lt;char...CS&gt; int operator\"\" _bin()</code>! I tried it with <em>clang++-3.9</em> and <em>msvc++-19.00</em>, same complaint, which really makes me sceptical.</p>\n<p>I have the feeling that that may not the right behavior. I would have understood it if my literal was in quotes, say <code>\"1000'0000\"_bin</code>, but this form does not exist for template operator\"\", right?</p>\n<p>Am I to expect the digit separator <code>'</code> in my template user-literal operators, too, now? </p>\n<p><strong>Update 1:</strong> in case the <code>'</code> is ok:</p>\n<p>One could use the digit-sep as a sep for all sort of things, say, complex numbers. Would the behavior of `52.84'67.12_i' for <em>52.84+67.12i</em> be well defined?'</p>\n<p><strong>Udpdate 2:</strong> As reaction some of the comments. The following compiles:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing std::string;\n\nnamespace lits {\n  // helper\n  template&lt;char C&gt; string sx() { return string{}+C; }\n  // helper 2 or more args\n  template&lt;char C, char D, char... ES&gt;\n  string sx() {\n    return sx&lt;C&gt;() + sx&lt;D,ES...&gt;();\n  }\n  // operator\"\" _sx\n  template&lt;char...CS&gt; string operator\"\" _sx()\n  { return sx&lt;CS...&gt;(); };\n}\nint main() {\n  using namespace lits;\n  std::cout &lt;&lt; 10000000_sx &lt;&lt; '\\n';\n  std::cout &lt;&lt; 10'000'000_sx &lt;&lt; '\\n';\n  std::cout &lt;&lt; 0x00af_sx &lt;&lt; '\\n';\n  std::cout &lt;&lt; 0x0'c'0'a'f_sx &lt;&lt; '\\n';\n  std::cout &lt;&lt; 007_sx &lt;&lt; '\\n';\n  std::cout &lt;&lt; 0b01_sx &lt;&lt; '\\n';\n  // the following do not work:\n  //std::cout &lt;&lt; 0b0a8sh3s1_sx &lt;&lt; '\\n';\n  //std::cout &lt;&lt; \"abcde\"_sx &lt;&lt; '\\n';\n}\n</code></pre>\n<p>And the output is:</p>\n<pre><code>10000000\n10'000'000\n0x00af\n0x0'c'0'a'f\n007\n0b01\n</code></pre>\n<p>Which means that the template gets <em>all</em> the characters: prefixes and digit separators -- all of them. (g++-6.2.0)</p>\n<p>As @krzaq's answer suggests, it seems this is the plan of the Std, so one can rely on it.</p>\n", "AcceptedAnswerId": "40576294", "Title": "How do user-defined literals play together with digit separator?", "CreationDate": "2016-11-13T16:33:11.177", "Id": "40576175", "CommentCount": "1", "LastEditDate": "2016-11-13T20:04:14.203", "PostTypeId": "1", "LastEditorUserId": "472245", "LastActivityDate": "2016-11-13T20:04:14.203", "Score": "3", "OwnerUserId": "472245", "Tags": "<c++><variadic-templates><user-defined-literals><digit-separator>", "AnswerCount": "2"}, "40576337": {"Id": "40576337", "PostTypeId": "2", "Body": "<p>As much as I read <a href=\"http://en.cppreference.com/w/cpp/language/user_literal\" rel=\"nofollow noreferrer\">here</a> the separator is allowed only when you get the literal as a number, not when the operator is a raw literal. That means you will get rid of the separator by the compiler if the operator parameter type is <code>unsigned long long</code>, not if it's one of the raw ones that get C-string or char.</p>\n", "LastActivityDate": "2016-11-13T16:47:55.013", "CommentCount": "3", "CreationDate": "2016-11-13T16:47:55.013", "ParentId": "40576175", "Score": "0", "OwnerUserId": "4299382"}, "40576294": {"Id": "40576294", "PostTypeId": "2", "Body": "<p>As far as I can tell, yes. As explained <a href=\"https://stackoverflow.com/a/40262320/2456565\">here</a>, digit separators are legal members of user defined integer literals.</p>\n<p>And the template integer literal is defined as:</p>\n<blockquote>\n<p id=\"so_40576175_40576294_0\">N4140 \u00a7 2.13.8 [lex.ext] / 3</p>\n<p id=\"so_40576175_40576294_1\">Otherwise (<em>S</em> contains a literal operator template), <em>L</em> is treated\n  as a call of the form</p>\n<pre><code>operator \"\" X &lt;\u2019c1\u2019, \u2019c2\u2019, ... \u2019ck\u2019&gt;()\n</code></pre>\n<p id=\"so_40576175_40576294_2\">where <em>n</em> is the source character sequence c<sub>1</sub>c<sub>2</sub>...c<sub>k</sub>. [ <em>Note:</em> The sequence\n  c<sub>1</sub>c<sub>2</sub>...c<sub>k</sub> can only contain characters\n  from the basic source character set. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>There's not a word about removing separators.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-13T16:43:06.187", "Score": "4", "CreationDate": "2016-11-13T16:43:06.187", "ParentId": "40576175", "CommentCount": "0", "OwnerUserId": "2456565", "LastEditDate": "2017-05-23T11:53:35.590"}, "bq_ids": {"n4140": {"so_40576175_40576294_2": {"length": 12, "quality": 0.6666666666666666, "section_id": 5369}, "so_40576175_40576294_1": {"length": 8, "quality": 1.0, "section_id": 5369}}, "n3337": {"so_40576175_40576294_2": {"length": 12, "quality": 0.6666666666666666, "section_id": 5165}, "so_40576175_40576294_1": {"length": 8, "quality": 1.0, "section_id": 5165}}, "n4659": {"so_40576175_40576294_2": {"length": 12, "quality": 0.6666666666666666, "section_id": 6794}, "so_40576175_40576294_1": {"length": 8, "quality": 1.0, "section_id": 6794}}}});