post_cb({"43266676": {"Id": "43266676", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43265448_43266676_0\">I simply want to know if this is defined\\undefined behavior in C++ (11 for that matter)</p>\n</blockquote>\n<p>Ta-da (from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">N3337</a>, \"quasi C++11\")</p>\n<blockquote>\n<p id=\"so_43265448_43266676_1\">Two expression evaluations conflict if one of them modifies a memory location [..] and the other one accesses or modifies the same memory location.</p>\n<p id=\"so_43265448_43266676_2\">\u00a71.10/4</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_43265448_43266676_3\">The execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior. [..]</p>\n<p id=\"so_43265448_43266676_4\">\u00a71.10/21</p>\n</blockquote>\n<p>You're accessing the (memory location of) object <code>stop</code> from different threads, both accesses are not atomic, thus also in no \"happens before\" relation. Simply put, <strong>you have a data race and thus undefined behavior</strong>.</p>\n<blockquote>\n<p id=\"so_43265448_43266676_5\">I am not interested in knowing what better ways there are to solve the real reason that is behind this sort of hack.</p>\n</blockquote>\n<p>Atomic operations (as defined by the C++ standard) are the <em>only</em> way to (reliably) solve this.</p>\n", "LastActivityDate": "2017-04-06T22:20:52.923", "CommentCount": "7", "CreationDate": "2017-04-06T22:20:52.923", "ParentId": "43265448", "Score": "7", "OwnerUserId": "1116364"}, "43265726": {"Id": "43265726", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43265448_43265726_0\">So, is it required to mark the pointer as volatile in such a case?</p>\n</blockquote>\n<p>No. It's not required, principally because volatile doesn't even remotely cover what you need it to do in this case. You must use an actual synchronization primitive, like an atomic operation or mutex. Using <code>volatile</code> here is undefined behaviour and your program will explode.</p>\n<p><code>volatile</code> is NOT useful for concurrency. It may be useful for implementing concurrent primitives but it is far from sufficient.</p>\n<p>Frankly, whether or not you want to use actual synchronization primitives is irrelevant. If you want to write correct code, <em>you have no choice</em>.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2017-04-06T21:10:21.447", "Score": "4", "CreationDate": "2017-04-06T21:04:20.420", "ParentId": "43265448", "CommentCount": "4", "OwnerUserId": "298661", "LastEditDate": "2017-04-06T21:10:21.447"}, "bq_ids": {"n4140": {"so_43265448_43266676_3": {"length": 20, "quality": 0.8, "section_id": 5834}, "so_43265448_43266676_1": {"length": 15, "quality": 0.9375, "section_id": 5817}}, "n3337": {"so_43265448_43266676_3": {"length": 22, "quality": 0.88, "section_id": 5605}, "so_43265448_43266676_1": {"length": 15, "quality": 0.9375, "section_id": 5588}}, "n4659": {"so_43265448_43266676_3": {"length": 20, "quality": 0.8, "section_id": 7296}, "so_43265448_43266676_1": {"length": 14, "quality": 0.875, "section_id": 7278}}}, "43265448": {"ViewCount": "145", "Body": "<p>I know that I should use the <code>volatile</code> keyword to tell the compiler not to optimize memory read\\write to variables. I also know that in most cases it <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rconc-volatile2\" rel=\"nofollow noreferrer\">should only be used to talk to non-C++ memory</a>.</p>\n<p>However, I would like to know if I have to use <code>volatile</code> when holding a pointer to some local (stack) variable.</p>\n<p>For example:</p>\n<pre><code>//global or member variable\n/* volatile? */bool* p_stop;\n\nvoid worker()\n{\n    /* volatile? */ bool stop = false;\n    p_stop = &amp;stop;\n    while(!stop)\n    {\n        //Do some work\n        //No usage of \"stop\" or p_stop\" here\n    }\n}\n\nvoid stop_worker()\n{\n    *p_stop = true;\n}\n</code></pre>\n<p>It looks to me like a compiler with some optimization level might see that <code>stop</code> is a local variable, that is never changed and could replace <code>while(!stop)</code> with a <code>while(true)</code> and thus changing <code>*p_stop</code> while do nothing.</p>\n<p>So, is it required to mark the pointer as volatile in such a case? </p>\n<p>P.S: Please do not lecture me on why not to use this, the real code that uses this hack does so for a (complex-to-explain) reason.</p>\n<p>EDIT:</p>\n<ol>\n<li><p>I failed to mention that these two functions run on different threads.\nThe <code>worker()</code> is a function of the first thread, and it should be stopped from another thread using the <code>p_stop</code> pointer.</p></li>\n<li><p>I am not interested in knowing what better ways there are to solve the real reason that is behind this sort of hack. I simply want to know if this is defined\\undefined behavior in C++ (11 for that matter), and also if this is compiler\\platform\\etc dependent. So far I see @Puppy saying that everyone is wrong and that this is wrong, but without referencing a specific standard that denoted this. </p></li>\n</ol>\n<p>I understand that some of you are offended by the \"don't lecture me\" part, but please stick to the real question - Should I use <code>volatile</code> or not? or is this UB? and if you can please help me (and others) learn something new by providing a complete answer.</p>\n", "AcceptedAnswerId": "43266676", "Title": "Should a pointer to stack variable be volatile?", "CreationDate": "2017-04-06T20:46:34.277", "Id": "43265448", "CommentCount": "21", "LastEditDate": "2017-04-06T22:02:08.487", "PostTypeId": "1", "LastEditorUserId": "2523211", "LastActivityDate": "2017-04-06T22:20:52.923", "Score": "-1", "OwnerUserId": "2523211", "Tags": "<c++><compiler-optimization><volatile>", "AnswerCount": "4"}, "43265787": {"Id": "43265787", "PostTypeId": "2", "Body": "<p>This question simply cannot be answered from the details provided.</p>\n<p>As is stated in the question this is an entirely unsupported way of communicating between threads.</p>\n<p>So the only answer is: </p>\n<p>Specify the compiler versions you're using and hope someone knows its darkest secrets or refer to your documentation. All the C++ standard will tell you is this won't work and all anyone can tell you is \"might work but don't\".</p>\n<p>There isn't a \"oh, come on guys everyone knows it pretty much works what do I do as the workaround? <em>wink</em> <em>wink</em>\" answer. </p>\n<p>Unless your compiler doesn't support atomics or suitably concurrent mechanisms there is no justifiable reason for doing this.\n\"It's not supported\" isn't \"complex-to-explain\" so I'd be fascinated based on that code fragment to understand what possible reason there is for not doing this properly (other than ancient compiler).</p>\n", "LastActivityDate": "2017-04-06T21:08:29.147", "CommentCount": "13", "CreationDate": "2017-04-06T21:08:29.147", "ParentId": "43265448", "Score": "1", "OwnerUserId": "4213662"}, "43265557": {"Id": "43265557", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43265448_43265557_0\">P.S: Please do not lecture me on why not to use this,</p>\n</blockquote>\n<p>I am not sure what we are supposed to say. The compiler manages the stack, so anything you are doing with it is technically undefined behavior and may not work when you upgrade to the next version of the compiler.</p>\n<p>You are also making assumptions that may be different than the compiler's assumptions when it optimizes. This is the real reason to use (or not use) <code>volatile</code>; you give guidance to the compiler that helps it decide whether optimizations are safe. The use of <code>volatile</code> tells the compiler that it should assume that these variables may change due to external influences (other threads or special hardware behavior).</p>\n<p>So yes, in this case, it looks like you would need to mark <em>both</em> <code>p_stop</code> and <code>stop</code> with a <code>volatile</code> qualifier.</p>\n<p>(Note: this is necessary but not sufficient, as it does not cause the appropriate behaviors to happen in a language implementation with a relaxed memory model that requires barriers to ensure correctness. See <a href=\"https://en.wikipedia.org/wiki/Memory_ordering#Runtime_memory_ordering\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Memory_ordering#Runtime_memory_ordering</a> )</p>\n", "LastEditorUserId": "44330", "LastActivityDate": "2017-04-06T21:04:46.907", "Score": "2", "CreationDate": "2017-04-06T20:53:18.377", "ParentId": "43265448", "CommentCount": "14", "OwnerUserId": "44330", "LastEditDate": "2017-04-06T21:04:46.907"}});