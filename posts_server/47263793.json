post_cb({"47275827": {"ParentId": "47263793", "PostTypeId": "2", "CommentCount": "13", "Body": "<blockquote>\n<p id=\"so_47263793_47275827_0\">Is there some ambiguity I'm missing?</p>\n</blockquote>\n<p>I don't think so. It's probably more that there was a definite need to evaluate non-static data members and not so much for non-static member functions.</p>\n<p>However, this:</p>\n<pre><code>static_assert(std::is_same&lt;decltype(bar::foo), func&gt;::value, \"No Symmetry!\");\n</code></pre>\n<p>doesn't make much sense. The type of <code>&amp;bar::foo</code> is not <code>func*</code>, it's <code>func bar::*</code>. And there isn't a way to spell that without a pointer, so having to be able to evaluate <code>decltype(bar::foo)</code> means introducing whole new type syntax? Doesn't seem worth it.</p>\n<p>Note that <code>decltype(bar::foo)</code> cannot be <code>func</code> because <code>func</code> is a function type, but <code>bar::foo</code> is a member function.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-11-14T01:51:36.347", "Id": "47275827", "Score": "0", "CreationDate": "2017-11-14T00:36:39.047", "LastActivityDate": "2017-11-14T01:51:36.347"}, "47263793": {"CommentCount": "0", "ViewCount": "239", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2017-11-13T11:55:56.020", "LastActivityDate": "2017-11-23T13:24:36.613", "Title": "Is there a reason we cannot name a non-static member function in an unevaluated context?", "FavoriteCount": "1", "LastEditDate": "2017-11-14T00:36:53.427", "Id": "47263793", "Score": "7", "Body": "<p>When reading <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.prim.id\" rel=\"nofollow noreferrer\">[expr.prim.id]</a>, one will see that</p>\n<blockquote>\n<p id=\"so_47263793_47263793_0\">An id-expression that denotes a non-static data member or non-static\n  member function of a class can only be used:</p>\n<ul>\n<li>if that id-expression denotes a non-static data member and it appears in an unevaluated operand.</li>\n</ul>\n</blockquote>\n<p>The fact that the bullet above applies only to data members is unclear to me. Intuitively I'd expect the following to be well formed:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nusing func = int();\n\nclass bar {\n  func foo; // This is valid, and not the subject of the question\n};\n\nstatic_assert(std::is_same&lt;decltype(bar::foo), func&gt;::value, \"No Symmetry!\");\n</code></pre>\n<p>But the <code>decltype()</code> is ill-formed even before the static assertion is checked. </p>\n<p>Is there some ambiguity I'm missing?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "817643", "AnswerCount": "3"}, "47263794": {"ParentId": "47263793", "PostTypeId": "2", "CommentCount": "18", "Body": "<blockquote>\n<p id=\"so_47263793_47263794_0\">Is there some ambiguity I'm missing?</p>\n</blockquote>\n<p>The fact there's a whole lot of type information that is added as part of that member function declaration.</p>\n<p>While <code>func</code> may certainly be used to declare that member, the story doesn't end here. Once the member is declared, it's type is completed. That involves adding a couple of other things, like <em>cv-qualifers</em> and <em>ref-qualifiers</em>. In the case of <code>foo</code>, all the default implicit ones are determined, and they become part of <code>bar::foo</code>'s type. As specified by <a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.fct#8\" rel=\"nofollow noreferrer\">[dcl.fct]/8</a>:</p>\n<blockquote>\n<p id=\"so_47263793_47263794_1\">The return type, the parameter-type-list, the ref-qualifier, the\n  cv-qualifier-seq, and the exception specification, but not the default\n  arguments, are part of the function type.</p>\n</blockquote>\n<p>There's no way to specify them explicitly in the above declaration of <code>foo</code> (though they may be added to <code>func</code>), but they may be added in general:</p>\n<pre><code>class bar {\n  int foo() const volatile &amp;&amp;;\n};\n</code></pre>\n<p>They are part of the function type, and <code>decltype(bar::foo)</code> should address them if they appear (and if I gather correctly, even if they don't).</p>\n<p>Where does the <code>const volatile &amp;&amp;</code> go when we attempt to evaluate <code>decltype(bar::foo)</code>?</p>\n<ul>\n<li>Should it be ignored? That can be done. But losing type information is rarely a good thing.</li>\n<li>Should we retain it, and the type <code>decltype</code> evaluates to be a pointer to a member function, instead?<br>\nThat too would work, but now it's different from how data members would behave when named in an unevaluated context. We introduce a discrepancy.</br></li>\n<li>Should it be retained, and the type resolved to something else? Perhaps something like <code>int(foo const volatile&amp;&amp;)</code> or <code>int() const volatile &amp;&amp;</code> (another form of function type)? That breaks the symmetry one would expect to have, and is again a discrepancy to data members. </li>\n</ul>\n<p>There is no easy or obvious way in which allowing it would always work well. So rather than complicate matters for a feature that would see limited use, it's better to regard it as ill-formed.</p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-11-13T14:12:30.200", "Id": "47263794", "Score": "1", "CreationDate": "2017-11-13T11:55:56.020", "LastActivityDate": "2017-11-13T14:12:30.200"}, "bq_ids": {"n4140": {"so_47263793_47263793_0": {"section_id": 5959, "quality": 1.0, "length": 10}, "so_47263793_47263794_1": {"section_id": 3242, "quality": 0.7142857142857143, "length": 10}, "so_47263793_47268577_0": {"section_id": 5871, "quality": 0.8461538461538461, "length": 22}}, "n3337": {"so_47263793_47263793_0": {"section_id": 5728, "quality": 1.0, "length": 10}, "so_47263793_47263794_1": {"section_id": 3115, "quality": 0.7142857142857143, "length": 10}, "so_47263793_47268577_0": {"section_id": 5642, "quality": 0.8461538461538461, "length": 22}}, "n4659": {"so_47263793_47263793_0": {"section_id": 7440, "quality": 1.0, "length": 10}, "so_47263793_47263794_1": {"section_id": 4000, "quality": 0.9285714285714286, "length": 13}, "so_47263793_47268577_0": {"section_id": 7354, "quality": 0.8461538461538461, "length": 22}}}, "47268577": {"ParentId": "47263793", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>I don't see any reason.</p>\n<p>Look at this:</p>\n<pre><code>typedef void Func();\n\nFunc freeFunction;\n\nstruct Foo {\n    Func memberFunction;\n};\n</code></pre>\n<p><code>freeFunction</code>'s declaration is <code>Func freeFunction;</code>. So, <code>decltype(freeFunction)</code> is <code>void()</code>, i.e. <code>Func</code>.</p>\n<p>Using the same logic, As <code>Foo::memberFunction</code> is declared as <code>Func</code> too, I'd expect <code>decltype(Foo::memberFunction)</code> to be <code>Func</code> too. But that's not the case, as this doesn't compile.</p>\n<p>Just like a <code>int a; decltype(a)</code> resolves to <code>int</code>, even if <code>int a;</code> is a member, <code>decltype(Foo::memberFunction)</code> should be OK.</p>\n<p>Note, that qualifiers can be handled too, there is nothing special about them (of course, in this case, <code>Func</code> can only be used for declaring non-static member functions):</p>\n<pre><code>typedef void Func() const volatile &amp;&amp;;\n\nstruct Foo {\n    Func memberFunction;\n};\n</code></pre>\n<p>Here, I'd expect that <code>decltype(Foo::memberFunction)</code> to be <code>void() const volatile &amp;&amp;</code>, so I can copy its declaration:</p>\n<pre><code>struct Bar {\n    decltype(Foo::memberFunction) myMemFn;\n};\n</code></pre>\n<hr>\n<p>Quote from the C++14 standard (9.2/11):</p>\n<blockquote>\n<p id=\"so_47263793_47268577_0\">[ Note: The type of a non-static member function is an ordinary\n  function type, and the type of a non-static data member is an ordinary\n  object type. There are no special member function types or data member\n  types. \u2014 end note ]</p>\n</blockquote>\n<p>This quote means that it would be sensible, if <code>decltype(&lt;member_function&gt;)</code> returned a type of ordinary function.</p>\n</hr>", "OwnerUserId": "8157187", "LastEditorUserId": "8157187", "LastEditDate": "2017-11-23T13:24:36.613", "Id": "47268577", "Score": "-1", "CreationDate": "2017-11-13T16:04:47.280", "LastActivityDate": "2017-11-23T13:24:36.613"}});