post_cb({"bq_ids": {"n4140": {"so_28351017_28351453_1": {"length": 15, "quality": 0.9375, "section_id": 5347}, "so_28351017_28351114_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5364}, "so_28351017_28351114_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5347}, "so_28351017_28351114_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5364}}, "n3337": {"so_28351017_28351453_1": {"length": 15, "quality": 0.9375, "section_id": 5144}, "so_28351017_28351114_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5160}, "so_28351017_28351114_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5144}, "so_28351017_28351114_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5160}}, "n4659": {"so_28351017_28351453_1": {"length": 15, "quality": 0.9375, "section_id": 6772}, "so_28351017_28351114_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6788}, "so_28351017_28351114_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 6772}, "so_28351017_28351114_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6788}}}, "28351453": {"Id": "28351453", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28351017_28351453_0\">What does it mean when I type in an escaped Unicode string literal in my C++ program?</p>\n</blockquote>\n<p>To quote the standard:</p>\n<blockquote>\n<p id=\"so_28351017_28351453_1\">A universal-character-name is translated to the encoding, in the appropriate execution character set, of the character named. If there is no such encoding, the universal-character-name is translated to an implementation-defined encoding.</p>\n</blockquote>\n<p>Typically, the execution character set will be ASCII, which contains a character with value 1. So <code>\\u0001</code> will be translated into a single character with value 1.</p>\n<p>If you were to specify non-ASCII characters, like <code>\\u263A</code>, you might see more than one byte per character.</p>\n<blockquote>\n<p id=\"so_28351017_28351453_2\">Shouldn't it take 4 bytes for 2 characters? (assuming utf-16)</p>\n</blockquote>\n<p>If it were UTF-16, yes. But <code>string</code> can't be encoded with UTF-16, unless <code>char</code> has 16 bits, which it usually doesn't. UTF-8 is a more likely encoding, in which characters with values up to 127 (that is, the whole ASCII set) are encoded with a single byte.</p>\n<blockquote>\n<p id=\"so_28351017_28351453_3\">Why are the first two characters of s (first two bytes) equal?</p>\n</blockquote>\n<p>With the above assumptions, they are both the character with value 1.</p>\n", "LastActivityDate": "2015-02-05T18:32:30.910", "CommentCount": "8", "CreationDate": "2015-02-05T18:32:30.910", "ParentId": "28351017", "Score": "1", "OwnerUserId": "204847"}, "28351114": {"Id": "28351114", "PostTypeId": "2", "Body": "<p>So the draft C++11 standard says the following about universal characters in narrow string literals (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_28351017_28351114_0\">Escape sequences and universal-character-names in non-raw string literals have the same meaning as in\n  character literals (2.14.3), except that the single quote [...] In a narrow string literal, a universal-charactername\n  <strong>may map to more than one char element</strong> due to multibyte encoding</p>\n</blockquote>\n<p>and includes the following note:</p>\n<blockquote>\n<p id=\"so_28351017_28351114_1\">The size of a narrow string literal is the total\n  number of escape sequences and other characters, <strong>plus at least one for the multibyte encoding</strong> of each\n  universal-character-name, plus one for the terminating \u2019\\0\u2019.</p>\n</blockquote>\n<p>Section <code>2.14.3</code> referred to above says:</p>\n<blockquote>\n<p id=\"so_28351017_28351114_2\">A universal-character-name is translated to the encoding, in the appropriate execution character set, of the\n  character named. If there is no such encoding, the universal-character-name is translated to an implementation defined\n  encoding.</p>\n</blockquote>\n<p>if I try this example (<em><a href=\"http://melpon.org/wandbox/permlink/VydzXDy4NBE7aWpS\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>string s = \"\\u0F01\\u0001\";\n</code></pre>\n<p>The first universal character does map to multiple characters.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-02-05T18:31:34.013", "Score": "3", "CreationDate": "2015-02-05T18:14:34.593", "ParentId": "28351017", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-02-05T18:31:34.013"}, "28351017": {"ViewCount": "431", "Body": "<p>Here's an Ideone: <a href=\"http://ideone.com/vjByty\" rel=\"nofollow\">http://ideone.com/vjByty</a>.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;string&gt;\n\nint main() {\n    string s = \"\\u0001\\u0001\";\n    cout &lt;&lt; s.length() &lt;&lt; endl;\n    if (s[0] == s[1]) {\n        cout &lt;&lt; \"equal\\n\";\n    }\n    return 0;\n}\n</code></pre>\n<p>I'm confused on so many levels.</p>\n<p>What does it mean when I type in an escaped Unicode string literal in my C++ program?</p>\n<p>Shouldn't it take 4 bytes for 2 characters? (assuming utf-16)</p>\n<p>Why are the first two characters of <code>s</code> (first two bytes) equal?</p>\n", "AcceptedAnswerId": "28351114", "Title": "Why are unicode characters treated the same in C++ std::string?", "CreationDate": "2015-02-05T18:07:49.667", "Id": "28351017", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2015-02-05T18:32:30.910", "Score": "1", "OwnerUserId": "1418853", "Tags": "<c++><unicode>", "AnswerCount": "2"}});