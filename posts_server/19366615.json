post_cb({"19367047": {"ParentId": "19366615", "CommentCount": "0", "Body": "<p>[basic.def.odr]/6 explicitly allows multiple definitions of \"static data members of a class template\" (alongside other exceptions) under some circumstances.</p>\n<p>It then continues for such an entity <code>D</code>:</p>\n<blockquote>\n<p id=\"so_19366615_19367047_0\">If the definitions of <code>D</code> satisfy all these requirements, then the program shall behave as if there were a single definition of <code>D</code>. If the definitions of <code>D</code> do not satisfy\n  these requirements, then the behavior is undefined.</p>\n</blockquote>\n<p>Therefore the address of a static data member of a template instantiated in one TU compares equal to the address of the same static data member instantiated in another TU.</p>\n<hr>\n<p>The complete quote, passages mentioned above emphasized by me:</p>\n<blockquote>\n<p id=\"so_19366615_19367047_1\">There can be more than one definition of a class type, enumeration type, inline function with external linkage, class template, non-static function template, <strong>static data member\n  of a class template</strong>, member function of a class template, or template specialization for\n  which some template parameters are not specified in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named <code>D</code> defined in more than one translation unit, then</p>\n<ul>\n<li>each definition of <code>D</code> shall consist of the same sequence of tokens; and</li>\n<li>in each definition of <code>D</code>, corresponding names, looked up according to 3.4, shall refer to an entity defined within the definition of <code>D</code>, or shall refer to the same entity, after overload resolution and after matching of partial template specialization, except that a name can refer to a <code>const</code> object with internal or no linkage if the object has the same literal type in all definitions of <code>D</code>, and the object is initialized with a constant expression, and the value (but not the address) of the object is used, and the object has the same value in all definitions of <code>D</code>; and</li>\n<li>in each definition of <code>D</code>, corresponding entities shall have the same language linkage; and</li>\n<li>in each definition of <code>D</code>, the overloaded operators referred to, the implicit calls to conversion functions, constructors, operator new functions and operator delete functions, shall refer to the same function, or to a function defined within the definition of <code>D</code>; and</li>\n<li>in each definition of <code>D</code>, a default argument used by an (implicit or explicit) function call is treated as if its token sequence were present in the definition of <code>D</code>; that is, the default argument is subject to the three requirements described above (and, if the default argument has sub-expressions with default arguments, this requirement applies recursively).</li>\n<li>if <code>D</code> is a class with an implicitly-declared constructor, it is as if the constructor was implicitly defined in every translation unit where it is odr-used, and the implicit definition in every translation unit shall call the same constructor for a base class or a class member of <code>D</code>.</li>\n</ul>\n<p id=\"so_19366615_19367047_2\">If <code>D</code> is a template and is defined in more than one translation unit, then the preceding requirements shall apply both to names from the template\u2019s enclosing scope used in the template definition, and also to dependent names at the point of instantiation. <strong>If the definitions of <code>D</code> satisfy all these requirements, then the program shall behave as if there were a single definition of <code>D</code>.</strong> If the definitions of <code>D</code> do not satisfy\n  these requirements, then the behavior is undefined.</p>\n</blockquote>\n</hr>", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "19367047", "Score": "1", "CreationDate": "2013-10-14T18:46:32.180", "LastActivityDate": "2013-10-14T18:46:32.180"}, "24495429": {"ParentId": "19366615", "CommentCount": "0", "Body": "<p>Your question is perfectly answered by 14.4 in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_19366615_24495429_0\">A template name has linkage (3.5). A non-member function template can have internal linkage; any other template name shall have external linkage...</p>\n</blockquote>\n<p>Therefore, a class template will always have external linkage and so are its static data members (const or not). So, <code>Foo&lt;int&gt;::x</code> will always refer to the same entity in memory regardless of which translation units this expression appears in. The linker makes this happen.</p>\n", "OwnerUserId": "1348273", "PostTypeId": "2", "Id": "24495429", "Score": "1", "CreationDate": "2014-06-30T17:12:13.530", "LastActivityDate": "2014-06-30T17:12:13.530"}, "19367075": {"ParentId": "19366615", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is perfectly fine, in this case of defining it in the header the compiler will insure there is only one instance, if we see the draft C++ standard section <code>3.2</code> <em>One definition rule</em> paragraph <em>6</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19366615_19367075_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), <strong>static data member of a class template (14.5.1.3)</strong>, member function</p>\n</blockquote>\n<p>we can then go to section <code>14.5.1.3</code> <em>Static data members of class templates</em> paragraph <em>1</em> says:</p>\n<blockquote>\n<p id=\"so_19366615_19367075_1\">A definition for a static data member may be provided in a namespace scope enclosing the definition of the static member\u2019s class template. </p>\n</blockquote>\n<p>and provides the following example:</p>\n<pre><code>template&lt;class T&gt; class X {\n  static T s;\n};\ntemplate&lt;class T&gt; T X&lt;T&gt;::s = 0;\n</code></pre>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-10-14T18:53:28.457", "Id": "19367075", "Score": "3", "CreationDate": "2013-10-14T18:47:39.977", "LastActivityDate": "2013-10-14T18:53:28.457"}, "19366615": {"CommentCount": "2", "ViewCount": "662", "CreationDate": "2013-10-14T18:21:41.703", "LastActivityDate": "2014-06-30T17:12:13.530", "Title": "static member variable in class template", "AcceptedAnswerId": "19367075", "PostTypeId": "1", "Id": "19366615", "Score": "4", "Body": "<p>When you have a (non-templated) class that contains a static member, like:</p>\n<pre><code>class Foo\n{\n   public:\n\n   static int x;\n};\n</code></pre>\n<p>Then <code>Foo::x</code> must be defined in one and only one translation unit, or the compiler will complain of multiple definitions.  So in <code>somefile.cpp</code> you'd have to define it:</p>\n<pre><code>int Foo::x = 10;\n</code></pre>\n<p>This way, any translation unit that accesses <code>Foo::x</code> is accessing the same memory address.</p>\n<p>But what if <code>Foo</code> is a class template?</p>\n<pre><code>template &lt;class T&gt;\nclass Foo\n{\n   public:\n\n   static int x;\n};\n</code></pre>\n<p>Now, <code>Foo&lt;T&gt;::x</code> can be defined in a header file, by saying:</p>\n<pre><code>template &lt;class T&gt;\nint Foo&lt;T&gt;::x = 10;\n</code></pre>\n<p>So, if class template <code>Foo</code> is defined in <code>foo.hpp</code>, and <code>translation_unit1.cpp</code> and <code>translation_unit2.cpp</code> both include <code>foo.hpp</code>, will the memory address of <code>Foo&lt;T&gt;::x</code> for some instantiation of template class Foo, (such as <code>Foo&lt;int&gt;::x</code> for example) be different for each translation unit?</p>\n", "Tags": "<c++>", "OwnerUserId": "469408", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_19366615_19367047_1": {"section_id": 7043, "quality": 1.0, "length": 57}, "so_19366615_24495429_0": {"section_id": 51, "quality": 1.0, "length": 16}, "so_19366615_19367075_1": {"section_id": 107, "quality": 1.0, "length": 14}, "so_19366615_19367047_0": {"section_id": 7043, "quality": 0.9375, "length": 15}, "so_19366615_19367047_2": {"section_id": 7043, "quality": 0.9743589743589743, "length": 38}, "so_19366615_19367075_0": {"section_id": 7043, "quality": 0.9032258064516129, "length": 28}}, "n3337": {"so_19366615_19367047_1": {"section_id": 6788, "quality": 1.0, "length": 57}, "so_19366615_24495429_0": {"section_id": 46, "quality": 1.0, "length": 16}, "so_19366615_19367075_1": {"section_id": 102, "quality": 1.0, "length": 14}, "so_19366615_19367047_0": {"section_id": 6788, "quality": 1.0, "length": 16}, "so_19366615_19367047_2": {"section_id": 6788, "quality": 1.0, "length": 39}, "so_19366615_19367075_0": {"section_id": 6788, "quality": 0.9032258064516129, "length": 28}}, "n4659": {"so_19366615_19367047_1": {"section_id": 8540, "quality": 1.0, "length": 57}, "so_19366615_24495429_0": {"section_id": 52, "quality": 0.625, "length": 10}, "so_19366615_19367075_1": {"section_id": 111, "quality": 1.0, "length": 14}, "so_19366615_19367047_0": {"section_id": 8540, "quality": 0.9375, "length": 15}, "so_19366615_19367047_2": {"section_id": 8540, "quality": 0.9743589743589743, "length": 38}, "so_19366615_19367075_0": {"section_id": 8540, "quality": 0.9032258064516129, "length": 28}}}});