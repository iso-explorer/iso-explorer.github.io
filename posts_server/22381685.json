post_cb({"bq_ids": {"n4140": {"so_22381685_22408491_0": {"length": 33, "quality": 1.0, "section_id": 257}}, "n3337": {"so_22381685_22408491_0": {"length": 33, "quality": 1.0, "section_id": 248}}, "n4659": {"so_22381685_22408491_0": {"length": 33, "quality": 1.0, "section_id": 264}}}, "22381685": {"ViewCount": "419", "Body": "<p>I want to use new C++11 feature 'extern template class' with STL-container of movable objects (NOT copyable) and get compiler errors.</p>\n<p>Example:\n<code>MyFile.hpp</code></p>\n<pre><code>#pragma once\n\n#include &lt;cstdio&gt;\n\nclass MyFile\n{\n    std::FILE * handle;\n\npublic:\n    MyFile(const char * filename);\n\n    ~MyFile();\n\n    MyFile(MyFile &amp;&amp; that);\n\n    MyFile &amp; operator=(MyFile &amp;&amp; that);\n\n    MyFile(const MyFile&amp;) = delete;\n    void operator=(const MyFile&amp;) = delete;\n\n    std::FILE const * getFile() const;\n};\n</code></pre>\n<p><code>MyFile.cpp</code>:</p>\n<pre><code>#include \"MyFile.hpp\"\n\n#include &lt;iostream&gt;\n\nMyFile::MyFile(const char * filename)\n    : handle{nullptr}\n{\n    if (!(handle = fopen(filename, \"r\")))\n        throw std::runtime_error(\"blah blah blah\");\n}\n\nMyFile::~MyFile()\n{\n    std::cout &lt;&lt; \"File::~File()\" &lt;&lt; std::endl;\n    if (handle)\n        fclose(handle);\n}\n\nMyFile::MyFile(MyFile &amp;&amp; that)\n    : handle{nullptr}\n{\n    *this = std::move(that);\n}\n\nMyFile &amp; MyFile::operator =(MyFile &amp;&amp; that)\n{\n    std::swap(handle, that.handle);\n    return *this;\n}\n\nconst std::FILE * MyFile::getFile() const\n{\n    return handle;\n}\n</code></pre>\n<p><code>FileDeque.hpp</code>:</p>\n<pre><code>#pragma once\n\n#include &lt;deque&gt;\n\n#include \"MyFile.hpp\"\n\nextern template class std::deque&lt;MyFile&gt;;\nusing FileDeque = std::deque&lt;MyFile&gt;;\n</code></pre>\n<p><code>FileDeque.cpp</code>:</p>\n<pre><code>#include \"FileDeque.hpp\"\n\ntemplate class std::deque&lt;MyFile&gt;;\n</code></pre>\n<p>And the test program:\n    #include </p>\n<pre><code>using namespace std;\n\n#include \"MyFile.hpp\"\n#include \"FileDeque.hpp\"\n\nint main()\n{\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n\n    {\n        FileDeque files;\n        files.emplace_back(\"C:/eula.1028.txt\");\n        files.emplace_back(\"C:/eula.1031.txt\");\n        files.emplace_back(\"C:/eula.2052.txt\");\n    }\n\n    return 0;\n}\n</code></pre>\n<p>With Visual Studio 2013 I get the following error:</p>\n<blockquote>\n<p id=\"so_22381685_22381685_0\">D:\\WinPrograms\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\deque(1714) : error C2280: 'MyFile::MyFile(const MyFile &amp;)' : attempting to reference a deleted function</p>\n<p id=\"so_22381685_22381685_1\">d:\\devel\\unique_ptr3\\MyFile.hpp(18) : see declaration of 'MyFile::MyFile'</p>\n<p id=\"so_22381685_22381685_2\">D:\\WinPrograms\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\deque(1682) : while compiling class template member function 'void std::deque&gt;::_Insert_n(std::_Deque_const_iterator&gt;&gt;,unsigned int,const MyFile &amp;)'\n          with\n          [\n              _Ty=MyFile\n          ]</p>\n<p id=\"so_22381685_22381685_3\">D:\\WinPrograms\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\deque(1510) : see reference to function template instantiation 'void std::deque&gt;::_Insert_n(std::_Deque_const_iterator&gt;&gt;,unsigned int,const MyFile &amp;)' being compiled\n          with\n          [\n              _Ty=MyFile\n          ]</p>\n<p id=\"so_22381685_22381685_4\">d:\\devel\\unique_ptr3\\FileDeque.hpp(7) : see reference to class template instantiation 'std::deque&gt;' being compiled\n          with\n          [\n              _Ty=MyFile\n          ]</p>\n<p id=\"so_22381685_22381685_5\">Generating Code...</p>\n</blockquote>\n<p>It is clear that compiler tries to instantiate std::deque&gt;::_Insert_n function that uses copying of objects, but why?</p>\n<p>If std::deque is used directly in main.cpp I get no errrors:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include &lt;deque&gt;\n\nusing namespace std;\n\n#include \"MyFile.hpp\"\n\nusing FileDeque = std::deque&lt;MyFile&gt;;\n\nint main()\n{\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n\n    {\n        FileDeque files;\n        files.emplace_back(\"C:/eula.1028.txt\");\n        files.emplace_back(\"C:/eula.1031.txt\");\n        files.emplace_back(\"C:/eula.2052.txt\");\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Also tried with clang and gcc and get similiar errrors.</p>\n<p>So my questions:</p>\n<ol>\n<li>Is it possible to make compiler not to instantiate container's class of movable objects? Why compiler tryies to  instantiate methods that require copying support?</li>\n<li>Do I want something wrong?</li>\n</ol>\n", "AcceptedAnswerId": "22408491", "Title": "extern template class std::container of movable objects", "CreationDate": "2014-03-13T14:26:51.853", "Id": "22381685", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2014-03-14T14:55:24.240", "Score": "2", "OwnerUserId": "1758733", "Tags": "<c++><templates><c++11><stl><visual-studio-2013>", "AnswerCount": "1"}, "22408491": {"Id": "22408491", "PostTypeId": "2", "Body": "<p>C++11 [temp.explicit]/8 states:</p>\n<blockquote>\n<p id=\"so_22381685_22408491_0\">An explicit instantiation that names a class template specialization is also an explicit instantiation of the same kind (declaration or definition) of each of its members (not including members inherited from base classes) that has not been previously explicitly specialized in the translation unit containing the explicit instantiation, except as described below.</p>\n</blockquote>\n<p>Since some of the members of <code>std::deque&lt;foo&gt;</code> require a copyable type <code>foo</code> - at the very least, the copy constructor - instantiating them is ill-formed. This is the cause of the errors you observe.</p>\n<p>The workaround for this is to explicitly instantiate only the well-formed members that your program uses, something like:</p>\n<pre><code>// in FileDeque.hpp:\n// Uncomment this to get linker errors suggesting\n// other members to explicitly instantiate:\n// extern template class std::deque&lt;MyFile&gt;;\nextern template std::deque&lt;MyFile&gt;::deque();\nextern template std::deque&lt;MyFile&gt;::~deque();\nextern template auto std::deque&lt;MyFile&gt;::begin() -&gt; iterator;\nextern template auto std::deque&lt;MyFile&gt;::end() -&gt; iterator;\n// ...\n\n// in FileDeque.cpp:\ntemplate std::deque&lt;MyFile&gt;::deque();\ntemplate std::deque&lt;MyFile&gt;::~deque();\ntemplate auto std::deque&lt;MyFile&gt;::begin() -&gt; iterator;\ntemplate auto std::deque&lt;MyFile&gt;::end() -&gt; iterator;\n// ...\n</code></pre>\n", "LastActivityDate": "2014-03-14T14:55:24.240", "CommentCount": "1", "CreationDate": "2014-03-14T14:55:24.240", "ParentId": "22381685", "Score": "5", "OwnerUserId": "923854"}});