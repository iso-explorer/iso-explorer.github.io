post_cb({"9563641": {"Id": "9563641", "PostTypeId": "2", "Body": "<h3>1.9.6</h3>\n<blockquote>\n<p id=\"so_9563600_9563641_0\">The observable behavior of the abstract machine is its sequence of\n  reads and writes to <code>volatile</code> data and calls to library I/O\n  functions.</p>\n</blockquote>\n<p>A side-effect is anything that affects observable behavior.</p>\n<p>Note that there are exceptions specified by the standard, where observable behavior doesn't have to conform to that of the abstract machine - see return value optimization, temporary copy elision. </p>\n", "LastActivityDate": "2012-03-05T08:32:43.457", "CommentCount": "3", "CreationDate": "2012-03-05T08:32:43.457", "ParentId": "9563600", "Score": "1", "OwnerUserId": "673730"}, "9565169": {"Id": "9565169", "PostTypeId": "2", "Body": "<p>The term \"side-effect\" arises from the distinction between imperative languages and pure functional languages. A C++ expression can do three things:</p>\n<ol>\n<li>compute a result (or compute \"no result\" in the case of a <code>void</code> expression),</li>\n<li>raise an exception instead of evaluating to a result,</li>\n<li>in addition to 1 or 2, otherwise alter the state of the abstract machine on which the program is nominally running.</li>\n</ol>\n<p>(3) are side-effects, the \"main effect\" being to evaluate the result of the expression. Exceptions are a slightly awkward special case, in that altering the flow of control <em>does</em> change the state of the abstract machine (by changing the current point of execution), but isn't a side-effect. The code to construct, handle and destroy the exception may have its own side-effects, of course.</p>\n<p>The same principles apply to functions, with the return value in place of the result of the expression.</p>\n<p>So, <code>int foo(int a, int b) { return a + b; }</code> just computes a return value, it doesn't alter anything else. Therefore it has no side-effects, which sometimes is an interesting property of a function when it comes to reasoning about your program (e.g. to prove that it is correct, or by the compiler when it optimizes). <code>int bar(int &amp;a, int &amp;b) { return ++a + b; }</code> does have a side-effect, since modifying the caller's object <code>a</code> is an additional effect of the function beyond simply computing a return value. It would not be permitted in a pure functional language.</p>\n<p>The stuff in your quote about \"has finished being evaluated\" refers to the fact that the result of an expression (or return value of a function) can be a \"temporary object\", which is destroyed at the end of the full expression in which it occurs. So creating a temporary isn't a \"side-effect\" by that definition: other changes are.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-03-05T11:47:29.037", "Score": "6", "CreationDate": "2012-03-05T10:35:09.493", "ParentId": "9563600", "CommentCount": "0", "OwnerUserId": "13005", "LastEditDate": "2012-03-05T11:47:29.037"}, "bq_ids": {"n4140": {"so_9563600_9563914_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 6182}, "so_9563600_9563669_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 5808}, "so_9563600_9563914_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 480}}, "n3337": {"so_9563600_9563914_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 5943}, "so_9563600_9563669_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 5581}, "so_9563600_9563914_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 471}}, "n4659": {"so_9563600_9563914_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 7684}, "so_9563600_9563669_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 7269}, "so_9563600_9563914_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 502}}}, "9563914": {"Id": "9563914", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9563600_9563914_0\">What exactly is a 'side-effect' in C++? Is it a standard term which is well defined...</p>\n</blockquote>\n<p>c++11 draft - 1.9.12: Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment. Evaluation of an expression (or a sub-expression) in general includes both value computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation) and initiation of side effects. When a call to a library I/O function returns or an access to a volatile object is evaluated the side effect is considered complete, even though some external actions implied by the call (such as the I/O itself) or by the volatile access may not have completed yet.</p>\n<blockquote>\n<p id=\"so_9563600_9563914_1\">I found one definition here, but doesn't this make each and every statement of code a side effect?</p>\n<p id=\"so_9563600_9563914_2\">A side effect is a result of an operator, expression, statement, or function that persists even after the operator, expression, statement, or function has finished being evaluated.</p>\n<p id=\"so_9563600_9563914_3\">Can someone please explain what the term 'side effect' formally means in C++, and what is its significance?</p>\n</blockquote>\n<p>The significance is that, as expressions are being evaluated they can modify the program state and/or perform I/O.  Expressions are allowed in myriad places in C++: variable assignments, <code>if</code>/<code>else</code>/<code>while</code> conditions, <code>for</code> loop setup/test/modify steps, function parameters etc....  A couple examples: <code>++x</code> and <code>strcat(buffer, \"append this\")</code>.</p>\n<p>In a C++ program, the Standard grants the optimiser the right to generate code representing the program operations, but requires that all the operations associated with steps before a sequence point appear before any operations related to steps after the sequence point.</p>\n<p>The reason C++ programmers tend to have to care about sequence points and side effects is that there aren't as many sequence points as you might expect.  For example: given <code>x = 1; f(++x, ++x);</code>, you may expect a call to <code>f(2, 3)</code> but it's actually undefined behaviour.  This behaviour is left undefined so the compiler's optimiser has more freedom to arrange operations with side effects to run in the most efficient order possible - perhaps even in parallel.  It also avoid burdening compiler writers with detecting such conditions.</p>\n<blockquote>\n<p id=\"so_9563600_9563914_4\">1.Is comma operator free from side effect?</p>\n</blockquote>\n<p>Yes - a comma operator introduces a sequence point: the steps on the left must be complete before those on the right execute.  There are a list of sequence points at <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Sequence_point</a> - you should read this!  (If you have to ask about side effects, then be careful in interpreting this answer - the \"comma operator\" is NOT invoked between function arguments, array initialisation elements etc..  The comma operator is relatively rarely used and somewhat obscure.  Do some reading if you're not sure what the comma operator really is.)</p>\n<blockquote>\n<p id=\"so_9563600_9563914_5\">2.Force compiler to not optimize side-effect-less statements</p>\n</blockquote>\n<p>I assume you mean \"side-effect-ful\" statements.  Compiler's are not obliged to support any such option.  What behaviour would they exhibit if they tried? - the Standard doesn't define what they should do in such situations.  Sometimes a majority of programmers might share an intuitive expectation, but other times it's really arbitary.</p>\n<blockquote>\n<p id=\"so_9563600_9563914_6\">3.Side effects when passing objects to function in C++</p>\n</blockquote>\n<p>When calling a function, all the parameters must have been completely evaluated - and their side effects triggered - before the function call takes place.  BUT, there are no restrictions on the compiler related to evaluating specific parameter expressions before any other.  They can be overlapping, in parallel etc..  So, in <code>f(expr1, expr2)</code> - some of the steps in evaluating expr2 might run before anything from expr1, but expr1 might still complete first - it's <em>undefined</em>.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2012-03-06T01:43:05.073", "Score": "8", "CreationDate": "2012-03-05T08:57:43.110", "ParentId": "9563600", "CommentCount": "0", "OwnerUserId": "410767", "LastEditDate": "2012-03-06T01:43:05.073"}, "9563669": {"Id": "9563669", "PostTypeId": "2", "Body": "<p>A \"side effect\" is defined by the C++ standard in <code>[intro.execution]</code>, by:</p>\n<blockquote>\n<p id=\"so_9563600_9563669_0\">Reading an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment.</p>\n</blockquote>\n", "LastEditorUserId": "485561", "LastActivityDate": "2016-12-21T12:17:02.400", "Score": "13", "CreationDate": "2012-03-05T08:34:39.760", "ParentId": "9563600", "CommentCount": "7", "OwnerUserId": "485561", "LastEditDate": "2016-12-21T12:17:02.400"}, "9563600": {"ViewCount": "10727", "Body": "<p>Is it a standard term which is well defined, or just a term coined by developers to explain a concept (.. and what is the concept)? As I understand this has something to do with the all-confusing <a href=\"https://stackoverflow.com/questions/9562562/in-c11-how-to-determine-what-is-sequenced-before-others\">sequence points</a>, but am not sure.</p>\n<p>I found one definition <a href=\"http://www.learncpp.com/cpp-tutorial/33-incrementdecrement-operators-and-side-effects/\" rel=\"nofollow noreferrer\">here</a>, but doesn't this make each and every statement of code a side effect?</p>\n<blockquote>\n<p id=\"so_9563600_9563600_0\">A side effect is a result of an operator, expression, statement, or function that persists even after the operator, expression, statement, or function has finished being evaluated.</p>\n</blockquote>\n<p><strong>Can someone please explain what the term 'side effect' formally means in C++, and what is its significance?</strong></p>\n<p>For reference, some questions talking about side effects:</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/7784774/is-comma-operator-free-from-side-effect\">Is comma operator free from side effect?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1152333/force-compiler-to-not-optimize-side-effect-less-statements\">Force compiler to not optimize side-effect-less statements</a></li>\n<li><a href=\"https://stackoverflow.com/questions/7762988/side-effects-when-passing-objects-to-function-in-c\">Side effects when passing objects to function in C++</a></li>\n</ol>\n", "Title": "What exactly is a 'side-effect' in C++?", "CreationDate": "2012-03-05T08:27:38.520", "LastActivityDate": "2016-12-21T12:17:02.400", "CommentCount": "7", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:26:27.013", "LastEditorUserId": "-1", "Id": "9563600", "Score": "23", "OwnerUserId": "113124", "Tags": "<c++><c++11>", "AnswerCount": "4"}});