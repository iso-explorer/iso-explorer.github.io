post_cb({"29993038": {"ParentId": "15752910", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>While <a href=\"https://stackoverflow.com/a/15753237/8701\">Sean's answer</a> is true of the standard, individual implementation may fall short.  VC++ 2013, at least, looks like it has <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/1253646/std-regex-copy-constructor-is-not-thread-safe\" rel=\"nofollow noreferrer\">race conditions</a> in its copy constructor and in a lazily evaluated variable.</p>\n", "OwnerUserId": "8701", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:27:14.437", "Id": "29993038", "Score": "1", "CreationDate": "2015-05-01T18:44:09.637", "LastActivityDate": "2015-05-01T18:44:09.637"}, "15753237": {"ParentId": "15752910", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Claiming that <a href=\"http://en.cppreference.com/w/cpp/regex/basic_regex\" rel=\"nofollow noreferrer\"><code>std::regex</code></a> is thread-safe in every respect is a pretty bold statement. The C++11 standard does not make such guarantees for the regex library.</p>\n<p>However, looking at the prototype of <a href=\"http://en.cppreference.com/w/cpp/regex/regex_search\" rel=\"nofollow noreferrer\"><code>std::regex_search</code></a> shows that it it takes the <code>basic_regex</code> object as a const argument. This means that it is protected by the standard library's guarantee that the const modifier <a href=\"https://stackoverflow.com/questions/14127379/does-const-mean-thread-safe-in-c11\">implies thread-safety</a> of the function with respect to that argument.</p>\n<p>In standardese, that is:</p>\n<blockquote>\n<p id=\"so_15752910_15753237_0\"><strong>[17.6.5.9/1]</strong>\n  This section specifies requirements that implementations shall meet to prevent data races (1.10). Every standard library function shall meet each requirement unless otherwise specified. Implementations may prevent data races in cases other than those specified below.</p>\n<p id=\"so_15752910_15753237_1\"><strong>[17.6.5.9/3]</strong>\n  A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s <em>non-const</em> arguments, including <code>this</code>.</p>\n</blockquote>\n<p>So, barring a bug in the implementation of the standard library that you use, it appears that calls to <code>std::regex_search</code> are thread-safe with respect to the <code>regex</code> object that is passed in.</p>\n<hr>\n<p><strong>Other thoughts:</strong></p>\n<p>Just because <code>std::regex_search</code> is re-entrant with respect to its <code>regex</code> argument does not mean that you are completely out of the water. Performing an operation that modifies a <code>regex</code> in a non-thread-safe manner at the same time as a thread-safe call such as <code>std::regex_search</code> is still undefined behaviour. <code>basic_regex</code>'s <a href=\"http://en.cppreference.com/w/cpp/regex/basic_regex/operator%3D\" rel=\"nofollow noreferrer\">assignment operator</a>, <a href=\"http://en.cppreference.com/w/cpp/regex/basic_regex/swap\" rel=\"nofollow noreferrer\">std::swap</a>, and <a href=\"http://en.cppreference.com/w/cpp/regex/basic_regex/imbue\" rel=\"nofollow noreferrer\"><code>basic_regex::imbue</code></a> come to mind as non-thread-safe functions with respect to the <code>basic_regex</code> they operate on. Knowing this, it might be better for you to make a copy of the <code>regex</code> object, which should come at a minimal performance cost, for each thread to use/modify at its leisure.</p>\n</hr>", "OwnerUserId": "1020072", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:58.880", "Id": "15753237", "Score": "14", "CreationDate": "2013-04-01T22:46:43.157", "LastActivityDate": "2013-04-01T23:16:20.613"}, "bq_ids": {"n4140": {"so_15752910_15753237_1": {"section_id": 6348, "quality": 0.9130434782608695, "length": 21}, "so_15752910_15753237_0": {"section_id": 6346, "quality": 0.9, "length": 27}}, "n3337": {"so_15752910_15753237_1": {"section_id": 6105, "quality": 0.9130434782608695, "length": 21}, "so_15752910_15753237_0": {"section_id": 6103, "quality": 0.9, "length": 27}}, "n4659": {"so_15752910_15753237_1": {"section_id": 7857, "quality": 0.9130434782608695, "length": 21}, "so_15752910_15753237_0": {"section_id": 7855, "quality": 0.9, "length": 27}}}, "15752910": {"CommentCount": "0", "AcceptedAnswerId": "15753237", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-01T22:17:43.367", "LastActivityDate": "2015-05-01T18:44:09.637", "LastEditDate": "2017-05-23T11:59:19.773", "ViewCount": "1273", "FavoriteCount": "1", "Title": "Is std::regex thread safe?", "Id": "15752910", "Score": "7", "Body": "<p>Related to <a href=\"https://stackoverflow.com/questions/12263013/is-a-static-boostwregex-instance-thread-safe\">Is a static boost::wregex instance thread-safe?</a> but for the standarized version.  Can I call regex_search from several threads with the same regex object?</p>\n", "Tags": "<c++><regex><thread-safety><std>", "OwnerUserId": "65569", "AnswerCount": "2"}});