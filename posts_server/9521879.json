post_cb({"9522168": {"Id": "9522168", "PostTypeId": "2", "Body": "<p>As you may have already figured, there is not going to be an easy yes or no answer. However, I think this may help:</p>\n<p><a href=\"http://www.cs.huji.ac.il/~etsman/Docs/gcc-3.4-base/libstdc++/html/faq/index.html#5_6\" rel=\"nofollow\">http://www.cs.huji.ac.il/~etsman/Docs/gcc-3.4-base/libstdc++/html/faq/index.html#5_6</a></p>\n<p>I quote verbatim:</p>\n<blockquote>\n<p id=\"so_9521879_9522168_0\">5.6 Is libstdc++-v3 thread-safe?</p>\n<p id=\"so_9521879_9522168_1\">libstdc++-v3 strives to be thread-safe when all of the following\n  conditions are met:</p>\n<p id=\"so_9521879_9522168_2\">The system's libc is itself thread-safe,\n  gcc -v reports a thread model other than 'single',\n  [pre-3.3 only] a non-generic implementation of atomicity.h exists for the architecture in question.</p>\n</blockquote>\n", "LastEditorUserId": "415784", "LastActivityDate": "2012-03-01T18:55:10.443", "Score": "3", "CreationDate": "2012-03-01T18:52:33.680", "ParentId": "9521879", "CommentCount": "2", "OwnerUserId": "559095", "LastEditDate": "2012-03-01T18:55:10.443"}, "bq_ids": {"n4140": {"so_9521879_9522018_1": {"length": 16, "quality": 0.5161290322580645, "section_id": 6869}, "so_9521879_9522152_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 4235}, "so_9521879_9522018_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 4240}}, "n3337": {"so_9521879_9522018_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 4081}, "so_9521879_9522152_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 4076}}, "n4659": {"so_9521879_9522018_1": {"length": 16, "quality": 0.5161290322580645, "section_id": 8361}, "so_9521879_9522152_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 5497}, "so_9521879_9522018_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6399}}}, "9522018": {"Id": "9522018", "PostTypeId": "2", "Body": "<p>In C++11, <code>std::allocator</code> is thread safe. From its definition:</p>\n<blockquote>\n<p id=\"so_9521879_9522018_0\">20.6.9.1/6: <em>Remark:</em> the storage is obtained by calling <code>::operator new(std::size_t)</code></p>\n</blockquote>\n<p>and from the definition of <code>::operator new</code>:</p>\n<blockquote>\n<p id=\"so_9521879_9522018_1\">18.6.1.4: The library versions of <code>operator new</code> and <code>operator delete</code>, user replacement versions of global <code>operator new</code> and <code>operator delete</code>, and the C standard library functions <code>calloc</code>, <code>malloc</code>, <code>realloc</code>, and <code>free</code> shall\n  not introduce data races (1.10) as a result of concurrent calls from different threads.</p>\n</blockquote>\n<p>C++03 had no concept of threads, so any thread safety was implementation-specific; you'd have to refer to your implementation's documentation to see what guarantees it offered, if any. Since you're using Microsoft's implementation, <a href=\"http://msdn.microsoft.com/en-us/library/c9ceah3b%28v=vs.71%29.aspx\" rel=\"noreferrer\">this page</a> says that it is safe to write to multiple container objects of the same class from many threads, which implies that <code>std::allocator</code> is thread-safe.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2012-03-01T19:11:41.497", "Score": "7", "CreationDate": "2012-03-01T18:41:39.160", "ParentId": "9521879", "CommentCount": "8", "OwnerUserId": "204847", "LastEditDate": "2012-03-01T19:11:41.497"}, "9522152": {"Id": "9522152", "PostTypeId": "2", "Body": "<p>In C++11 this would be addressed for the default allocator in:</p>\n<blockquote>\n<p id=\"so_9521879_9522152_0\">20.6.9.1 allocator members [allocator.members]</p>\n<p id=\"so_9521879_9522152_1\">Except for the destructor, member functions of the default allocator\n  shall not introduce data races (1.10) as a result of concurrent calls\n  to those member functions from different threads. Calls to these\n  functions that allocate or deallocate a particular unit of storage\n  shall occur in a single total order, and each such deallocation call\n  shall happen before the next allocation (if any) in this order.</p>\n</blockquote>\n<p>Any user-provided allocator would have to hold to the same constraints if it were going to be used  across different threads.</p>\n<p>Of course, for earlier versions of the standard, nothing is said about this since they didn't talk about multithreading.  If an implementation were to support multithreading (as many or most do), it would be responsible for taking care of those issues.  Similar to the way implementations provide a thread-safe <code>malloc()</code> (and other library functions) for C and C++ even though the standards prior to very recently said nothing about that.</p>\n", "LastActivityDate": "2012-03-01T18:50:51.083", "CommentCount": "0", "CreationDate": "2012-03-01T18:50:51.083", "ParentId": "9521879", "Score": "5", "OwnerUserId": "12711"}, "9521879": {"ViewCount": "737", "Body": "<p>I'm aware of the fact that the containers from standard library are not thread-safe. By that I used to think that a container, say of type <code>std::list</code>, cannot be accessed by more than one thread concurrently (some of which may modify the container). But now it seems that there is more to it than meets the eye; something more subtle, something not so obvious, well at least to me.</p>\n<p>For example, consider this function which accepts the first argument <em>by value</em>:</p>\n<pre><code>void log(std::string msg, severity s, /*...*/) \n{\n   return; //no code!\n}\n</code></pre>\n<p>Is this thread-safe? </p>\n<p>At first, it seems that it is thread-safe, as the function body accesses no shared <em>modifiable</em> resources, hence thread-safe. On second thought, it comes to me that when invoking such a function, an object of type <code>std::string</code> will be created, which is the first argument, and I think that construction of this object isn't thread-safe, as it internally uses <code>std::allocator</code>, which I believe isn't thread-safe. Hence invoking such a function isn't thread-safe either. But if it is correct, then what about this:</p>\n<pre><code>void f()\n{\n   std::string msg = \"message\"; //is it thread-safe? it doesn't seem so!\n}\n</code></pre>\n<p>Am I going right? Can we use <code>std::string</code> (or any container which uses <code>std::allocator</code> internally) in multi-threaded program?</p>\n<p><strong>I'm specifically talking about containers as local variables, as opposed to shared objects.</strong></p>\n<p>I searched google and found many similar doubts, with no concrete answer. I face similar problem as his:</p>\n<ul>\n<li><a href=\"http://www.codeguru.com/forum/showthread.php?t=466708\" rel=\"noreferrer\"> c++ allocators thread-safe?</a></li>\n</ul>\n<p>Please consider C++03 and C++11, both.</p>\n", "AcceptedAnswerId": "9522018", "Title": "standard containers as local variables in multi-threaded application", "CreationDate": "2012-03-01T18:32:17.210", "Id": "9521879", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-03-01T19:01:02.577", "LastEditorUserId": "415784", "LastActivityDate": "2012-03-01T19:53:29.440", "Score": "12", "OwnerUserId": "415784", "Tags": "<c++><multithreading><string><vector><allocator>", "AnswerCount": "4"}, "9523002": {"Id": "9523002", "PostTypeId": "2", "Body": "<p>When an <code>std::string</code> is copied during call to <code>log</code>, the allocator <em>may</em> be thread-safe (mandatory in C++11), but the <strong>copy itself</strong> isn't. So if there is another thread mutating the source string while copy is taking place, this is not thread safe.</p>\n<p>You may end-up with half the string as it was before mutation and another half after, or may even end-up accessing deallocated memory if the mutating thread reallocated (e.g. by appending new characters) or deleted the string, while the copy was still taking place.</p>\n<hr>\n<p>OTOH, the...</p>\n<pre><code>std::string msg = \"message\";\n</code></pre>\n<p>...is thread safe provided your allocator is thread safe.</p>\n</hr>", "LastActivityDate": "2012-03-01T19:53:29.440", "CommentCount": "2", "CreationDate": "2012-03-01T19:53:29.440", "ParentId": "9521879", "Score": "2", "OwnerUserId": "533120"}});