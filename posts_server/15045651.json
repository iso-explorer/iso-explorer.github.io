post_cb({"15045715": {"Id": "15045715", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15045651_15045715_0\">Why for using vector class I should write namespace specifier std::vector but for std::find function I can omit std:: ?</p>\n</blockquote>\n<p>In general, that is not true.</p>\n<blockquote>\n<p id=\"so_15045651_15045715_1\">What is the difference. Both are defined in std namespace, right?</p>\n</blockquote>\n<p>Yes, and there is no difference in principle. Per Paragraph 17.6.1.1/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15045651_15045715_2\"><strong>All library entities except macros, operator new and operator delete are defined within the namespace <code>std</code> or namespaces nested within namespace <code>std</code>.</strong> [...]</p>\n</blockquote>\n<p>However, you must keep in mind that exceptions are allowed by the rule of <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow\">Argument-Dependent Lookup</a>: thanks to this lookup technique, it is not necessary to explicitly specify the namespace of a function, because the name will be looked up in the namespace of the <em>arguments</em> you are supplying to that function.</p>\n<p>Thus, if the function happens to be defined in the same namespace as any of its arguments, it will be found by the compiler even though its name is not qualified with the namespace it belongs to:</p>\n<pre><code>namespace N\n{\n    struct X { };\n\n    void foo(X) { }\n}\n\nint main()\n{\n    N::X x;\n    foo(x); // OK\n}\n</code></pre>\n<p>Thus, if you are calling <code>std::find()</code> with some arguments that are instances of types defined in the <code>std</code> namespace, you won't need to qualify the call to <code>find()</code> with <code>std::</code>. For instance:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; v { 1, 2, 3 };\n    auto i = find(v.begin(), v.end(), 2); // ADL applies if the result of\n                                          // v.begin() and v.end() is an\n                                          // iterator whose type is defined \n                                          // in the std namespace!\n    std::cout &lt;&lt; *i;\n}\n</code></pre>\n<p>Obviously, this can't apply to functions that accept <em>no</em> argument. In that case, the namespace qualification is always necessary, unless of course the point of invocation is inside that namespace (although you can't <em>add</em> anything to the <code>std</code> namespace, some templates from the <code>std</code> namespace can be specialized).</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-23T21:24:03.833", "Score": "4", "CreationDate": "2013-02-23T21:08:37.620", "ParentId": "15045651", "CommentCount": "0", "LastEditDate": "2013-02-23T21:24:03.833", "OwnerUserId": "1932150"}, "15045651": {"ViewCount": "105", "Body": "<p>Why for using vector class I should write namespace specifier <code>std::vector</code> but for <code>std::find</code> function I can omit <code>std::</code> ? What is the difference? Both are defined in <code>std</code> namespace, right?</p>\n", "AcceptedAnswerId": "15045715", "Title": "C++: namespace specifier for classes and functions", "CreationDate": "2013-02-23T21:03:42.493", "Id": "15045651", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-02-23T21:24:03.833", "Score": "0", "OwnerUserId": "1356110", "Tags": "<c++><namespaces>", "AnswerCount": "4"}, "15045719": {"Id": "15045719", "PostTypeId": "2", "Body": "<p>It depends on how you call <code>std::find</code>... for example if you pass some iterators from std container, this function will be found by <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow\">ADL</a>, otherwise you have to add <code>std::</code> to call it.</p>\n", "LastActivityDate": "2013-02-23T21:09:09.463", "Score": "1", "CreationDate": "2013-02-23T21:09:09.463", "ParentId": "15045651", "CommentCount": "0", "OwnerUserId": "1655064"}, "15045713": {"Id": "15045713", "PostTypeId": "2", "Body": "<p>at the start you include librairie to your program (std namespace)\nthen afther you dont need to used all the time the std word \nbut in real all the object are like std::cout std::cin </p>\n<p>std are one of fundamental librairie of c++ </p>\n<p>soorry for my english need correction ;)</p>\n", "LastActivityDate": "2013-02-23T21:08:29.247", "Score": "0", "CreationDate": "2013-02-23T21:08:29.247", "ParentId": "15045651", "CommentCount": "0", "OwnerUserId": "1313915"}, "bq_ids": {"n4140": {"so_15045651_15045715_2": {"length": 18, "quality": 1.0, "section_id": 6254}}, "n3337": {"so_15045651_15045715_2": {"length": 18, "quality": 1.0, "section_id": 6014}}, "n4659": {"so_15045651_15045715_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 7758}}}, "15045801": {"Id": "15045801", "PostTypeId": "2", "Body": "<p>For some reason the STL chose to expose many of the algorithms (in ) in the global namespace. that is why you can just write find(...) or transform(...). Vectors are not exposed so you must either do <code>std::vector&lt;&gt;()</code>. Or you can just put using <code>std::vector;</code> at the top of your file</p>\n", "LastActivityDate": "2013-02-23T21:16:19.483", "Score": "0", "CreationDate": "2013-02-23T21:16:19.483", "ParentId": "15045651", "CommentCount": "1", "OwnerUserId": "1348795"}});