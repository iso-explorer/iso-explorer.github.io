post_cb({"bq_ids": {"n4140": {"so_15310989_15310989_5": {"length": 4, "quality": 1.0, "section_id": 4560}, "so_15310989_15310989_1": {"length": 15, "quality": 1.0, "section_id": 4560}, "so_15310989_15310989_4": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_15310989_15311159_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 792}, "so_15310989_15311159_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 792}, "so_15310989_15310989_2": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_15310989_15311159_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 4634}, "so_15310989_15310989_3": {"length": 15, "quality": 1.0, "section_id": 4560}}, "n3337": {"so_15310989_15310989_5": {"length": 4, "quality": 1.0, "section_id": 4390}, "so_15310989_15310989_1": {"length": 15, "quality": 1.0, "section_id": 4390}, "so_15310989_15311159_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3802}, "so_15310989_15310989_4": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_15310989_15311159_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3802}, "so_15310989_15310989_2": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_15310989_15311159_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 4445}, "so_15310989_15310989_3": {"length": 15, "quality": 1.0, "section_id": 4390}}, "n4659": {"so_15310989_15310989_5": {"length": 4, "quality": 1.0, "section_id": 5932}, "so_15310989_15310989_1": {"length": 9, "quality": 0.6, "section_id": 7709}, "so_15310989_15311159_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 853}, "so_15310989_15310989_4": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_15310989_15311159_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 853}, "so_15310989_15310989_2": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_15310989_15310989_3": {"length": 9, "quality": 0.6, "section_id": 7709}}}, "15310989": {"ViewCount": "165", "Body": "<p>This question is basically an aftermath of <a href=\"https://stackoverflow.com/a/15264126/2073257\">this</a> answer I gave. I just realized that the wording in the standard seems to omit a few cases. Consider this piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct foo\n{\n  void f(int v) { std::cout &lt;&lt; v &lt;&lt; std::endl; }\n};\n\nstruct bar : foo {};\n\nint main()\n{\n  bar obj;\n  std::bind(&amp;foo::f, obj, 1)();\n}\n</code></pre>\n<p>The standard describes in 20.8.9.1.2 the effect of <code>std::bind</code> and what happens when it is invoked. It forwards to 20.8.2, the relevant part is:</p>\n<blockquote>\n<h3>20.8.2 Requirements [func.require]</h3>\n<p id=\"so_15310989_15310989_0\"><sup>1</sup> Define <em>INVOKE</em><code>(f, t1, t2, ..., tN)</code> as follows:</p>\n<p id=\"so_15310989_15310989_1\">\u2014 <code>(t1.*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</p>\n<p id=\"so_15310989_15310989_2\">\u2014 <code>((*t1).*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;</p>\n<p id=\"so_15310989_15310989_3\">\u2014 <code>t1.*f</code> when <code>N == 1</code> and <code>f</code> is a pointer to member data of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</p>\n<p id=\"so_15310989_15310989_4\">\u2014 <code>(*t1).*f</code> when <code>N == 1</code> and <code>f</code> is a pointer to member data of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;</p>\n<p id=\"so_15310989_15310989_5\">\u2014 <code>f(t1, t2, ..., tN)</code> in all other cases.</p>\n</blockquote>\n<p>Reading this, it seems to allow three cases for the first list item:</p>\n<ul>\n<li><code>t1</code> is an object of type <code>T</code></li>\n<li>or a reference to an object of type <code>T</code></li>\n<li>or a reference to an object of a type derived from <code>T</code></li>\n</ul>\n<p>but in my example, it is neither. It's a type derived from <code>T</code>, but without a reference. Shouldn't the above listed cases be:</p>\n<ul>\n<li><code>t1</code> is an object of type <code>T</code></li>\n<li>or an object of a type derived from <code>T</code></li>\n<li>or a reference to an object of type <code>T</code></li>\n<li>or a reference to an object of a type derived from <code>T</code></li>\n</ul>\n<p>Of course, the same applies to the third list item in 20.8.2.</p>\n<p><strong>Question 1:</strong> As both GCC and Clang accept my code, I wonder if this is a defect report against the standard or if I'm just reading it wrong.</p>\n<p><strong>Question 2:</strong> With multiple/virtual inheritance, even if a type is derived from <code>T</code>, it might not simply be possible to call <code>(t1.*f)(...)</code> on it, right? Is that also something I should be concerned about or does the standard define \"derived from\" clearly in the given context?</p>\n", "AcceptedAnswerId": "15311159", "Title": "Conformance of std::bind when providing a method pointer and an object of derived type", "CreationDate": "2013-03-09T13:02:46.790", "Id": "15310989", "CommentCount": "1", "LastEditDate": "2017-05-23T10:32:02.930", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-09T13:22:17.907", "Score": "4", "OwnerUserId": "2073257", "Tags": "<c++><c++11><language-lawyer><stdbind>", "AnswerCount": "1"}, "15311159": {"Id": "15311159", "PostTypeId": "2", "Body": "<p>Paragraph 20.8.9.1.3 of the C++11 Standard defines the effects of calling <code>std::bind()</code> in terms of the <code>INVOKE()</code> <em>pseudo-function</em> this way:</p>\n<blockquote>\n<p id=\"so_15310989_15311159_0\"><em>Returns</em>: A forwarding call wrapper <code>g</code> with a weak result type (20.8.2). The effect of <code>g(u1, u2, ..., uM)</code> shall be <code>INVOKE (fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN),\n  result_of&lt;FD cv &amp; (V1, V2, ..., VN)&gt;::type)</code></p>\n</blockquote>\n<p>Notice that the call to <code>std::forward&lt;&gt;</code> will always return a <strong>reference type</strong>, be it an lvalue reference or an rvalue reference. Per Paragraphs 20.2.3/1-2, in fact:</p>\n<blockquote>\n<p id=\"so_15310989_15311159_1\"><code>template &lt;class T&gt; constexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; t) noexcept;</code></p>\n<p id=\"so_15310989_15311159_2\"><code>template &lt;class T&gt; constexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept;</code></p>\n<p id=\"so_15310989_15311159_3\"><em>Returns</em>: <code>static_cast&lt;T&amp;&amp;&gt;(t)</code></p>\n</blockquote>\n<p>Therefore, the <code>INVOKE</code> pseudo-function (watch out: not the <code>bind()</code> function!) will be invoked with references here, and this is supported by the definition you quoted.</p>\n<p>I believe the Standard itself never makes use of the <code>INVOKE()</code> pseudo-function (which is just some internal formalism) with objects (not references to object) of a type derived from <code>T</code>. </p>\n<p>However, this doesn't meant that you cannot invoke <code>std::bind()</code> or other functions whose definition is in turn given in terms of <code>INVOKE()</code> with an object (not a reference to an object) of a type derived from <code>T</code>.</p>\n", "LastActivityDate": "2013-03-09T13:22:17.907", "Score": "3", "CreationDate": "2013-03-09T13:22:17.907", "ParentId": "15310989", "CommentCount": "1", "OwnerUserId": "1932150"}});