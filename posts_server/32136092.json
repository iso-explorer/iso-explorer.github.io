post_cb({"32144010": {"Id": "32144010", "PostTypeId": "2", "Body": "<p>Back in the day, STRATUS computers had null pointers as 1 in all languages.</p>\n<p>This caused issues for C, so their C compiler would allow pointer comparison of 0 and 1 to return true</p>\n<p>This would allow:</p>\n<pre><code>void * ptr=some_func();\nif (!ptr)\n{\n    return;\n}\n</code></pre>\n<p>To <code>return</code> on a null ptr even though you could see that <code>ptr</code> had a value of 1 in the debugger</p>\n<pre><code>if ((void *)0 == (void *)1)\n{\n    printf(\"Welcome to STRATUS\\n\");\n}\n</code></pre>\n<p>Would in fact print \"Welcome to STRATUS\"</p>\n", "LastActivityDate": "2015-08-21T15:21:10.797", "CommentCount": "11", "CreationDate": "2015-08-21T15:21:10.797", "ParentId": "32136092", "Score": "7", "OwnerUserId": "2963099"}, "32136092": {"ViewCount": "4108", "Body": "<p>As the <a href=\"http://c-faq.com/null/machexamp.html\" rel=\"noreferrer\">comp.lang.c FAQ</a> says, there are architectures where the null pointer is not all bits zero. So the question is what actually checks the following construction:</p>\n<pre><code>void* p = get_some_pointer();\nif (!p)\n    return;\n</code></pre>\n<p>Am I comparing <code>p</code> with machine dependent null pointer or I'm comparing <code>p</code> with arithmetic zero?</p>\n<p>Should I write</p>\n<pre><code>void* p = get_some_pointer();\nif (NULL == p)\n    return;\n</code></pre>\n<p>instead to be ready for such architectures or is it just my paranoia?</p>\n", "AcceptedAnswerId": "32137530", "Title": "How to write C/C++ code correctly when null pointer is not all bits zero", "CreationDate": "2015-08-21T08:47:24.003", "Id": "32136092", "CommentCount": "17", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2015-08-22T19:27:21.350", "LastEditorUserId": "63550", "LastActivityDate": "2015-08-24T12:13:17.697", "Score": "65", "OwnerUserId": "1282773", "Tags": "<c++><c><computer-architecture>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_32136092_32136460_4": {"length": 4, "quality": 0.8, "section_id": 2515}, "so_32136092_32137530_3": {"length": 29, "quality": 0.8055555555555556, "section_id": 39}, "so_32136092_32137530_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 39}, "so_32136092_32137530_6": {"length": 11, "quality": 1.0, "section_id": 44}, "so_32136092_32137530_5": {"length": 18, "quality": 0.8571428571428571, "section_id": 6072}}, "n3337": {"so_32136092_32136460_4": {"length": 4, "quality": 0.8, "section_id": 6460}, "so_32136092_32137530_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5913}, "so_32136092_32137530_4": {"length": 55, "quality": 0.9322033898305084, "section_id": 5918}, "so_32136092_32136460_0": {"length": 16, "quality": 0.5333333333333333, "section_id": 36}, "so_32136092_32137530_3": {"length": 35, "quality": 0.9722222222222222, "section_id": 36}, "so_32136092_32137530_5": {"length": 18, "quality": 0.8571428571428571, "section_id": 5840}, "so_32136092_32137530_6": {"length": 11, "quality": 1.0, "section_id": 41}, "so_32136092_32137530_0": {"length": 16, "quality": 0.5333333333333333, "section_id": 36}}, "n4659": {"so_32136092_32137530_5": {"length": 18, "quality": 0.8571428571428571, "section_id": 7568}, "so_32136092_32137530_3": {"length": 29, "quality": 0.8055555555555556, "section_id": 39}, "so_32136092_32137530_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 39}, "so_32136092_32137530_6": {"length": 11, "quality": 1.0, "section_id": 45}}}, "32136460": {"Id": "32136460", "PostTypeId": "2", "Body": "<p>This answer applies to C.</p>\n<p>Don't mix up <code>NULL</code> with null pointers. <code>NULL</code> is just a macro guaranteed to be a <em>null pointer constant</em>. A null pointer constant is guaranteed to be either <code>0</code> or <code>(void*)0</code>. </p>\n<p>From C11 6.3.2.3:</p>\n<blockquote>\n<p id=\"so_32136092_32136460_0\">An integer constant expression with the value 0, or such an expression\n  cast to type void *, is called a null pointer constant 66). If a null\n  pointer constant is converted to a pointer type, the resulting\n  pointer, called a null pointer, is guaranteed to compare unequal to a\n  pointer to any object or function.</p>\n<p id=\"so_32136092_32136460_1\">66) The macro NULL is defined in &lt;stddef.h&gt; (and other headers) as a null pointer constant; see 7.19.</p>\n</blockquote>\n<p>7.19:</p>\n<blockquote>\n<p id=\"so_32136092_32136460_2\">The macros are</p>\n<p id=\"so_32136092_32136460_3\">NULL</p>\n<p id=\"so_32136092_32136460_4\">which expands to an implementation-defined null pointer constant;</p>\n</blockquote>\n<p>Implementation-defined in the case of <code>NULL</code>, is either <code>0</code> or <code>(void*)0</code>. <code>NULL</code> cannot be anything else.</p>\n<p>However, when a null pointer constant is cast to a pointer, you get a <em>null pointer</em>, which may not have the value zero, even though it compares equal to a null pointer constant. The code <code>if (!p)</code> has nothing to do with the <code>NULL</code> macro, you are comparing a null pointer against the arithmetic value zero.</p>\n<p>So in theory, code like <code>int* p = NULL</code> may result in a null pointer <code>p</code> which is different from zero. </p>\n", "LastEditorUserId": "584518", "LastActivityDate": "2015-08-24T06:00:46.613", "Score": "9", "CreationDate": "2015-08-21T09:04:28.947", "ParentId": "32136092", "CommentCount": "9", "OwnerUserId": "584518", "LastEditDate": "2015-08-24T06:00:46.613"}, "32136181": {"Id": "32136181", "PostTypeId": "2", "Body": "<p>It doesn't matter if null pointer is all-bits zero or not in the actual machine. Assuming <code>p</code> is a pointer:</p>\n<pre><code>if (!p) \n</code></pre>\n<p>is always a legal way to test if <code>p</code> is a null pointer, and it's always equivalent to:</p>\n<pre><code>if (p == NULL)\n</code></pre>\n<p>You may be interested in another C-FAQ article: <a href=\"http://c-faq.com/null/varieties.html\" rel=\"noreferrer\">This is strange. NULL is guaranteed to be 0, but the null pointer is not?</a></p>\n<hr>\n<p>Above is true for both C and C++. Note that in C++(11), it's preferred to use <code>nullptr</code> for null pointer literal.</p>\n</hr>", "LastEditorUserId": "1009479", "LastActivityDate": "2015-08-22T01:03:51.977", "Score": "32", "CreationDate": "2015-08-21T08:51:45.463", "ParentId": "32136092", "CommentCount": "2", "OwnerUserId": "1009479", "LastEditDate": "2015-08-22T01:03:51.977"}, "32137530": {"Id": "32137530", "PostTypeId": "2", "Body": "<p>According to the C spec:</p>\n<blockquote>\n<p id=\"so_32136092_32137530_0\">An integer constant expression with the value 0, or such an expression\n  cast to type void *, is called a null pointer constant. 55) If a null\n  pointer constant is converted to a pointer type, the resulting\n  pointer, called a null pointer, is guaranteed to compare unequal to a\n  pointer to any object or function.</p>\n</blockquote>\n<p>So <code>0</code> is a null pointer constant. And if we convert it to a pointer type we will get a null pointer that might be non-all-bits-zero for some architectures. Next let's see what the spec says about comparing pointers and a null pointer constant:</p>\n<blockquote>\n<p id=\"so_32136092_32137530_1\">If one operand is a\n  pointer and the other is a null pointer constant, the null pointer\n  constant is converted to the type of the pointer.</p>\n</blockquote>\n<p>Let's consider <code>(p == 0)</code>: first <code>0</code> is converted to a null pointer, and then <code>p</code> is compared with a null pointer constant whose actual bit values are architecture-dependent.</p>\n<p>Next, see what the spec says about the negation operator:</p>\n<blockquote>\n<p id=\"so_32136092_32137530_2\">The result of the logical negation operator ! is 0 if the value of its\n  operand compares unequal to 0, 1 if the value of its operand compares\n  equal to 0. The result has type int. The expression !E is equivalent\n  to (0==E).</p>\n</blockquote>\n<p>This means that <code>(!p)</code> is equivalent to <code>(p == 0)</code> which is, according to the spec, testing <code>p</code> against the machine-defined null pointer constant.</p>\n<p>Thus, you may safely write <code>if (!p)</code> even on architectures where the null pointer constant is not all-bits-zero.</p>\n<p>As for C++, a null pointer constant is defined as:</p>\n<blockquote>\n<p id=\"so_32136092_32137530_3\">A null pointer constant is an integral constant expression (5.19)\n  prvalue of integer type that evaluates to zero or a prvalue of type\n  std::nullptr_t. A null pointer constant can be converted to a pointer\n  type; the result is the null pointer value of that type and is\n  distinguishable from every other value of object pointer or function\n  pointer type.</p>\n</blockquote>\n<p>Which is close to what we have for C, plus the <code>nullptr</code> syntax sugar. The behavior of operator <code>==</code> is defined by:</p>\n<blockquote>\n<p id=\"so_32136092_32137530_4\">In addition, pointers to members can be compared, or a pointer to\n  member and a null pointer constant. Pointer to member conversions\n  (4.11) and qualification conversions (4.4) are performed to bring them\n  to a common type. If one operand is a null pointer constant, the\n  common type is the type of the other operand. Otherwise, the common\n  type is a pointer to member type similar (4.4) to the type of one of\n  the operands, with a cv-qualification signature (4.4) that is the\n  union of the cv-qualification signatures of the operand types. [ Note:\n  this implies that any pointer to member can be compared to a null\n  pointer constant. \u2014 end note ]</p>\n</blockquote>\n<p>That leads to conversion of <code>0</code> to a pointer type (as for C). For the negation operator:</p>\n<blockquote>\n<p id=\"so_32136092_32137530_5\">The operand of the logical negation operator ! is contextually\n  converted to bool (Clause 4); its value is true if the converted\n  operand is true and false otherwise. The type of the result is bool.</p>\n</blockquote>\n<p>That means that result of <code>!p</code> depends on how conversion from pointer to <code>bool</code> is performed. The standard says:</p>\n<blockquote>\n<p id=\"so_32136092_32137530_6\">A zero value, null pointer value, or null member pointer value is\n  converted to false;</p>\n</blockquote>\n<p>So <code>if (p==NULL)</code> and <code>if (!p)</code> does the same things in C++ too.</p>\n", "LastEditorUserId": "768469", "LastActivityDate": "2015-08-24T12:13:17.697", "Score": "95", "CreationDate": "2015-08-21T09:57:28.470", "ParentId": "32136092", "CommentCount": "5", "OwnerUserId": "1282773", "LastEditDate": "2015-08-24T12:13:17.697"}, "32149428": {"Id": "32149428", "PostTypeId": "2", "Body": "<p>If your compiler is any good there are two things (and only two things) to watch out for.</p>\n<p>1: Static default initialized (that is, not assigned) pointers won't have NULL in them.</p>\n<p>2: memset() on a struct or array or by extension calloc() won't set pointers to NULL.</p>\n", "LastActivityDate": "2015-08-21T21:22:25.000", "CommentCount": "9", "CreationDate": "2015-08-21T21:22:25.000", "ParentId": "32136092", "Score": "1", "OwnerUserId": "14768"}});