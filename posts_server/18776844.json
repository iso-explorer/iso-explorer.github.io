post_cb({"bq_ids": {"n4140": {"so_18776844_18776892_2": {"length": 26, "quality": 1.0, "section_id": 53}}, "n3337": {"so_18776844_18776892_2": {"length": 26, "quality": 1.0, "section_id": 48}}, "n4659": {"so_18776844_18776892_2": {"length": 26, "quality": 1.0, "section_id": 55}}}, "18776892": {"Id": "18776892", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18776844_18776892_0\">Is the reason that there are some special ways in using template while I misuse it?</p>\n</blockquote>\n<p>Precisely. The definition of a template class/function must be accessible on every translation unit where it's used, in other words, you can't separate its declaration from its definition like you did. To workaround this limitation, just define the templates inline, that is, on the header file.</p>\n<p>Quoting draft n3485</p>\n<blockquote>\n<p id=\"so_18776844_18776892_1\"><strong>[temp] paragraph 1</strong></p>\n<p id=\"so_18776844_18776892_2\">A function template, member function of a class template, or static\n  data member of a class template shall be defined in every translation\n  unit in which it is implicitly instantiated [...] unless the\n  corresponding specialization is explicitly instantiated [...] in\n  some translation unit; no diagnostic is required.</p>\n</blockquote>\n", "LastActivityDate": "2013-09-13T01:36:24.510", "CommentCount": "0", "CreationDate": "2013-09-13T01:36:24.510", "ParentId": "18776844", "Score": "2", "OwnerUserId": "801438"}, "18776910": {"Id": "18776910", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18776844_18776910_0\">A template is not a class or a function. A template is a \"pattern\"\n  that the compiler uses to generate a family of classes or functions.</p>\n<p id=\"so_18776844_18776910_1\">In order for the compiler to generate the code, it must see both the\n  template definition (not just declaration) and the specific\n  types/whatever used to \"fill in\" the template. For example, if you're\n  trying to use a Foo, the compiler must see both the Foo template\n  and the fact that you're trying to make a specific Foo.</p>\n<p id=\"so_18776844_18776910_2\">Your compiler probably doesn't remember the details of one .cpp file\n  while it is compiling another .cpp file. It could, but most do not and\n  if you are reading this FAQ, it almost definitely does not. BTW this\n  is called the \"separate compilation model.\"</p>\n</blockquote>\n<ul>\n<li><p>You may read this <a href=\"http://www.parashift.com/c++-faq/templates-defn-vs-decl.html\" rel=\"nofollow\">FAQ</a>, and here is the <a href=\"http://www.sunistudio.com/cppfaq/templates.html#faq-35.12\" rel=\"nofollow\">Chinese version</a></p></li>\n<li><p>Don't write <code>using namespace std;</code> in your head files, when you want \nto use <code>string</code> from std, write <code>std::string</code> instead.</p></li>\n<li>For constructors just have one parameter, you may use the <code>explicit</code>\nkeyword to avoid implicit conversion.</li>\n</ul>\n", "LastEditorUserId": "1292791", "LastActivityDate": "2013-09-13T01:50:30.230", "Score": "1", "CreationDate": "2013-09-13T01:38:44.233", "ParentId": "18776844", "CommentCount": "0", "OwnerUserId": "1292791", "LastEditDate": "2013-09-13T01:50:30.230"}, "18776844": {"ViewCount": "430", "Body": "<p><strong>About this program:</strong></p>\n<p>The program is for achieving HashTable.</p>\n<p><strong>The problem is as follows:</strong></p>\n<p>1&gt;\u6b63\u5728\u94fe\u63a5...\n1&gt;HashTable.obj : error LNK2019: \u65e0\u6cd5\u89e3\u6790\u7684\u5916\u90e8\u7b26\u53f7 \"public: int __thiscall HashTable::remove(class Employee const &amp;)\" (?remove@?$HashTable@VEmployee@@@@QAEHABVEmployee@@@Z)\uff0c\u8be5\u7b26\u53f7\u5728\u51fd\u6570 _wmain \u4e2d\u88ab\u5f15\u7528</p>\n<p>1&gt;HashTable.obj : error LNK2019: \u65e0\u6cd5\u89e3\u6790\u7684\u5916\u90e8\u7b26\u53f7 \"public: int __thiscall HashTable::contains(class Employee const &amp;)\" (?contains@?$HashTable@VEmployee@@@@QAEHABVEmployee@@@Z)\uff0c\u8be5\u7b26\u53f7\u5728\u51fd\u6570 _wmain \u4e2d\u88ab\u5f15\u7528</p>\n<p>1&gt;HashTable.obj : error LNK2019: \u65e0\u6cd5\u89e3\u6790\u7684\u5916\u90e8\u7b26\u53f7 \"public: void __thiscall HashTable::display(void)const \" (?display@?$HashTable@VEmployee@@@@QBEXXZ)\uff0c\u8be5\u7b26\u53f7\u5728\u51fd\u6570 _wmain \u4e2d\u88ab\u5f15\u7528\n1&gt;HashTable.obj : error LNK2019: \u65e0\u6cd5\u89e3\u6790\u7684\u5916\u90e8\u7b26\u53f7 \"public: int __thiscall HashTable::insert(class Employee const &amp;)\" (?insert@?$HashTable@VEmployee@@@@QAEHABVEmployee@@@Z)\uff0c\u8be5\u7b26\u53f7\u5728\u51fd\u6570 _wmain \u4e2d\u88ab\u5f15\u7528</p>\n<p>1&gt;HashTable.obj : error LNK2019: \u65e0\u6cd5\u89e3\u6790\u7684\u5916\u90e8\u7b26\u53f7 \"public: __thiscall HashTable::HashTable(int)\" (??0?$HashTable@VEmployee@@@@QAE@H@Z)\uff0c\u8be5\u7b26\u53f7\u5728\u51fd\u6570 _wmain \u4e2d\u88ab\u5f15\u7528</p>\n<p><strong>QUESTION:</strong></p>\n<p>I do not know why this happens since I have given declaration in Hash.h and definition in Hash.cpp.Before this question is posted,I have searched answer through the Internet but no answers are what i want.Is the reason that there are some special ways in using template while I misuse it?</p>\n<p>Hash.h:</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate &lt;class T&gt;\nclass HashTable\n{\n    public:\n        HashTable(int size = 101);\n        int insert(const T&amp; x);\n        int remove(const T&amp; x);\n        int contains(const T&amp; x);\n        void make_empty();\n        void display()const;\n    private:\n        vector&lt;list&lt;T&gt; &gt; lists;\n        int currentSize;\n        int hash(const string&amp; key);\n        int myhash(const T&amp; x);\n        void rehash();\n};\n\nclass Employee\n{\n    public:\n        Employee(){}\n        Employee(const string n,int s=0):name(n),salary(s){ }\n        const string &amp; getName()const { return name; } \n\n        bool operator == (const Employee &amp;rhs) const\n        {\n            return getName() == rhs.getName();\n        }\n\n        bool operator != (const Employee &amp;rhs) const\n        {\n            return !(*this == rhs);\n        }\n\n        friend ostream&amp; operator &lt;&lt;(ostream&amp; out,const Employee&amp; e)\n        {\n            out&lt;&lt;\"(\"&lt;&lt;e.name&lt;&lt;\",\"&lt;&lt;e.salary&lt;&lt;\") \";\n            return out;\n        }\n\n    private:\n        string name;\n        int salary;\n};\n</code></pre>\n<p>Hash.cpp </p>\n<pre><code>#include \"stdafx.h\"\n#include \"Hash.h\"\n\nint nextPrime(const int n);\n\ntemplate &lt;class T&gt; HashTable&lt;T&gt;::HashTable(int size)\n{\n    lists = vector&lt;list&lt;T&gt; &gt;(size);\n    currentSize = 0;\n}\n\ntemplate &lt;class T&gt; int HashTable&lt;T&gt;::hash(const string&amp; key)\n{ \n    int hashVal = 0;\n    int tableSize = lists.size();\n    for(int i=0;i&lt;key.length();i++)\n        hashVal = 37*hashVal+key[i];\n    hashVal %= tableSize;\n    if(hashVal &lt; 0)\n        hashVal += tableSize;\n    return hashVal;\n}\n\ntemplate &lt;class T&gt; int HashTable&lt;T&gt;:: myhash(const T&amp; x)\n{\n    string key = x.getName();\n    return hash(key);\n}\n\ntemplate &lt;class T&gt; int HashTable&lt;T&gt;::insert(const T&amp; x)\n{\n    list&lt;T&gt; &amp;whichlist = lists[myhash(x)];\n    if(find(whichlist.begin(),whichlist.end(),x) != whichlist.end())\n        return 0;\n    whichlist.push_back(x);\n    currentSize = currentSize + 1;\n    if(currentSize &gt; lists.size())\n        rehash();\n    return 1;\n}\n\ntemplate &lt;class T&gt; int HashTable&lt;T&gt;::remove(const T&amp; x)\n{\n    typename std::list&lt;T&gt;::iterator iter; list&lt;T&gt; &amp;whichlist = lists[myhash(x)];\n    iter = find(whichlist.begin(),whichlist.end(),x);\n    if( iter != whichlist.end())\n    {\n        whichlist.erase(iter); \n        currentSize--;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate &lt;class T&gt; int HashTable&lt;T&gt;::contains(const T&amp; x)\n{\n    list&lt;T&gt; whichlist;\n    typename std::list&lt;T&gt;::iterator iter;\n    whichlist = lists[myhash(x)];\n    iter = find(whichlist.begin(),whichlist.end(),x);\n    if ( iter != whichlist.end())\n        return 1;\n    return 0;\n}\n\ntemplate &lt;class T&gt; void HashTable&lt;T&gt;::make_empty()\n{\n    for(int i=0;i&lt;lists.size();i++)\n        lists[i].clear();\n    currentSize = 0;\n    return 0;\n}\n\ntemplate &lt; class T &gt; void HashTable &lt; T &gt;::rehash()\n{\n    vector &lt; list &lt; T &gt; &gt;oldLists = lists;\n    lists.resize(nextPrime(2 * lists.size()));\n    for (int i = 0; i &lt; lists.size(); i++)\n    lists[i].clear();\n    currentSize = 0;\n    for (int i = 0; i &lt; oldLists.size(); i++) {\n    typename std::list &lt; T &gt;::iterator iter = oldLists[i].begin();\n    while (iter != oldLists[i].end())\n        insert(*iter++);\n    }\n}\n\ntemplate &lt; class T &gt; void HashTable &lt; T &gt;::display() const const\n{\n    for (int i = 0; i &lt; lists.size(); i++) {\n    cout &lt;&lt; i &lt;&lt; \": \";\n    typename std::list &lt; T &gt;::const_iterator iter = lists[i].begin();\n    while (iter != lists[i].end()) {\n        cout &lt;&lt; *iter &lt;&lt; \" \";\n        ++iter;\n    }\n    cout &lt;&lt; endl;\n    }\n}\n\nint nextPrime(const int n)\n{\n    int ret, i;\n    ret = n;\n    while (1) {\n    int flag = 1;\n    for (i = 2; i &lt; sqrt((float) ret); i++)\n        if (ret % i == 0) {\n        flag = 0;\n        break;\n        }\n    if (flag == 1)\n        break;\n    else {\n        ret = ret + 1;\n        continue;\n    }\n    }\n    return ret;\n}\n</code></pre>\n<p><strong>Hashtable.cpp:</strong></p>\n<pre><code>// HashTable.cpp :\n// #include \"stdafx.h\"\n\n#include \"Hash.h\"\nint _tmain(int argc, _TCHAR * argv[])\n{\n    Employee e1(\"Tom\", 6000);\n    Employee e2(\"Anker\", 7000);\n    Employee e3(\"Jermey\", 8000);\n    Employee e4(\"Lucy\", 7500);\n    HashTable &lt; Employee &gt; emp_table(13);\n    emp_table.insert(e1);\n    emp_table.insert(e2);\n    emp_table.insert(e3);\n    emp_table.insert(e4);\n    cout &lt;&lt; \"Hash table is: \" &lt;&lt; endl;\n    emp_table.display();\n    if (emp_table.contains(e4) == 1)\n    cout &lt;&lt; \"Tom is exist in hash table\" &lt;&lt; endl;\n    if (emp_table.remove(e1) == 1)\n    cout &lt;&lt; \"Removing Tom form the hash table successfully\" &lt;&lt; endl;\n    if (emp_table.contains(e1) == 1)\n    cout &lt;&lt; \"Tom is exist in hash table\" &lt;&lt; endl;\n    else\n    cout &lt;&lt; \"Tom is not exist in hash table\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<hr>\n</hr>", "Title": "error LNK2019: link error", "CreationDate": "2013-09-13T01:30:30.157", "LastActivityDate": "2013-09-13T01:50:30.230", "CommentCount": "1", "PostTypeId": "1", "ClosedDate": "2013-09-13T02:22:07.827", "Id": "18776844", "Score": "-1", "OwnerUserId": "2771115", "Tags": "<c++><data-structures>", "AnswerCount": "2"}});