post_cb({"bq_ids": {"n4140": {"so_38494276_38494477_1": {"length": 10, "quality": 1.0, "section_id": 92}}, "n3337": {"so_38494276_38494477_1": {"length": 10, "quality": 1.0, "section_id": 87}}, "n4659": {"so_38494276_38494477_1": {"length": 10, "quality": 1.0, "section_id": 95}}}, "38494477": {"Id": "38494477", "PostTypeId": "2", "Body": "<p>What you are trying to accomplish with</p>\n<pre><code>void testAcrossTypes(SomeType f) {\n  f&lt;int&gt; ();\n  f&lt;bool&gt; ();\n  f&lt;char&gt; ();\n  f&lt;double&gt; ();\n}\n</code></pre>\n<p>would be possible if <code>SomeType</code> could be a template template argument. However, the standard does not allow function templates as template template argument.</p>\n<p>From the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_38494276_38494477_0\"><strong>14.3.3 Template template arguments</strong></p>\n<p id=\"so_38494276_38494477_1\">1 A <em>template-argument</em> for a template template-parameter shall be the name of a class template or an alias template, expressed as id-expression.</p>\n</blockquote>\n<p>Your best option is to use functors instead of functions. Example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct function1\n{\n   void operator()() {\n      return;\n   }\n};\n\ntemplate&lt;typename T&gt;\nstruct function2\n{\n   void operator()() {\n      return;\n   }\n};\n\ntemplate &lt; template &lt;typename&gt; class F&gt;\nvoid testAcrossTypes() {\n  F&lt;int&gt;()();\n  F&lt;bool&gt;()();\n  F&lt;char&gt;()();\n  F&lt;double&gt;()();\n}\n\nint main()\n{\n   testAcrossTypes&lt;function1&gt;();\n   testAcrossTypes&lt;function2&gt;();\n}\n</code></pre>\n", "LastActivityDate": "2016-07-21T03:40:30.900", "CommentCount": "0", "CreationDate": "2016-07-21T03:40:30.900", "ParentId": "38494276", "Score": "5", "OwnerUserId": "434551"}, "38495600": {"Id": "38495600", "PostTypeId": "2", "Body": "<p>You can accomplish it by means of a type-erased functor, like the one in the following example:</p>\n<pre><code>#include&lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nvoid function1() { }\n\ntemplate&lt;typename T&gt;\nvoid function2() { }\n\ntemplate&lt;typename T&gt;\nvoid function3() { }\n\nstruct Test {\n    template&lt;typename T&gt;\n    static void proto() {\n        function1&lt;T&gt;();\n        function2&lt;T&gt;();\n        function3&lt;T&gt;();\n    }\n\n    void operator()() {\n        for(auto &amp;f: vec) f();\n    }\n\n    template&lt;typename... T&gt;\n    static Test create() {\n        Test test;\n        int arr[] = { (test.vec.emplace_back(&amp;proto&lt;T&gt;), 0)... };\n        (void)arr;\n        return test;\n    }\n\n    using func = void(*)(void);\n    std::vector&lt;func&gt; vec;\n};\n\nvoid testAcrossTypes(Test test) {\n    test();\n}\n\nint main() {\n    testAcrossTypes(Test::create&lt;int, bool, char, double&gt;());\n}\n</code></pre>\n<p>It's easy to modify in both cases:</p>\n<ul>\n<li><p>New functions require to be added to the <code>proto</code> static member method and that's all</p></li>\n<li><p>Adding a new type is a matter of using it when call <code>create</code>, as shown in the above example</p></li>\n</ul>\n<p>The functor will keep in charge of creating the N*M calls to be executed.<br>\nMoreover, you don't need to move your functions in a bunch of structs to be able to use them.</br></p>\n", "LastActivityDate": "2016-07-21T05:33:46.217", "CommentCount": "3", "CreationDate": "2016-07-21T05:33:46.217", "ParentId": "38494276", "Score": "3", "OwnerUserId": "4987285"}, "38494276": {"ViewCount": "97", "Body": "<p>Is there a concise way to point to all instances of a templated function without using macros?</p>\n<p>I have several templated functions that I want to test across a variety of types:</p>\n<pre><code>template&lt;typename T&gt;\nvoid function1() {\n  return;\n}\n\ntemplate&lt;typename T&gt;\nvoid function2() {\n  return;\n}\n\ntemplate&lt;typename T&gt;\nvoid function3() {\n  return;\n}\n</code></pre>\n<p>I can do this with a macro:</p>\n<pre><code>#define TEST_ACROSS_TYPES(fn) \\\nfn&lt;int&gt;();  \\\nfn&lt;bool&gt;(); \\\nfn&lt;char&gt;(); \\\nfn&lt;double&gt;(); \\\n\nTEST_ACROSS_TYPES(function1);\nTEST_ACROSS_TYPES(function2);\n</code></pre>\n<p>But, (1) Macros are ugly and hard for others to follow, and (2) I'm using <code>CATCH</code>, which doesn't play nice when using macros to set up test cases.</p>\n<p>Is there a way to do something like this:</p>\n<pre><code>void testAcrossTypes(SomeType f) {\n  f&lt;int&gt; ();\n  f&lt;bool&gt; ();\n  f&lt;char&gt; ();\n  f&lt;double&gt; ();\n}\n</code></pre>\n<p>which seems much cleaner, except for the problem of defining <code>SomeType</code>.  This question (<a href=\"https://stackoverflow.com/questions/14848924/how-to-define-typedef-of-function-pointer-which-has-template-arguments\">How to define typedef of function pointer which has template arguments</a>) explains how to define a pointer to a templated function; but, requires that the template arguments be specified.</p>\n<hr>\n<p>For clarification:  Imagine <code>function1</code>, <code>function2</code>, and <code>function3</code> each test a different templated function.  Each function needs to be tested for <code>int</code>, <code>byte</code>, <code>char</code>, <code>double</code>, etc.  I want to avoid having to explicitly set up many (i.e. num_functions * num_types) tests for each function.  Instead, I want to have a single method that points to the test function (<code>function1</code>, <code>function2</code>, etc.) and runs it for each template type, thus consolidating</p>\n<pre><code>function1&lt;int&gt;();\nfunction1&lt;byte&gt;();\nfunction1&lt;char&gt;();\nfunction1&lt;double();\n...\nfunction2&lt;int&gt;();\nfunction2&lt;byte&gt;();\nfunction2&lt;char&gt;();\nfunction2&lt;double();\n...\nfunction3&lt;int&gt;();\nfunction3&lt;byte&gt;();\nfunction3&lt;char&gt;();\nfunction3&lt;double();\n...\n</code></pre>\n<p>into just one call per test function</p>\n<pre><code>testAcrossTypes(function1);\ntestAcrossTypes(function2);\ntestAcrossTypes(function3);\n</code></pre>\n</hr>", "AcceptedAnswerId": "38494477", "Title": "C++ Single function pointer for all template instances", "CreationDate": "2016-07-21T03:13:30.327", "Id": "38494276", "CommentCount": "3", "LastEditDate": "2017-05-23T10:28:50.087", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-21T05:33:46.217", "Score": "2", "OwnerUserId": "920599", "Tags": "<c++><templates><macros><function-pointers>", "AnswerCount": "2"}});