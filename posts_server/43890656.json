post_cb({"43890820": {"ParentId": "43890656", "CommentCount": "0", "Body": "<p>You use a virtual destructor because you want all the destructor in your inheritance to get called. That exactly what you get. The private does not apply as you don't call the destructor explicitly.</p>\n<p>If your destructor was not virtual you will get only <code>Base::~Base()</code> called. Usually that's not what you want when you have polymorphism.</p>\n", "OwnerUserId": "135549", "PostTypeId": "2", "Id": "43890820", "Score": "0", "CreationDate": "2017-05-10T11:12:35.397", "LastActivityDate": "2017-05-10T11:12:35.397"}, "43890685": {"ParentId": "43890656", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It is, but you're not calling <code>~Derived()</code> directly. If you were to use</p>\n<pre><code>Derived *p = new Derived();\ndelete p;\n</code></pre>\n<p>then you'd get the error. But when you access <code>~Derived()</code> indirectly via polymorphism (e.g. by calling <code>~Base()</code>), then the access specifier <code>private</code> does not apply.</p>\n<p>According to <a href=\"http://eel.is/c++draft/class.access.virt#1\" rel=\"nofollow noreferrer\">[class.access.virt#1]</a>:</p>\n<blockquote>\n<p id=\"so_43890656_43890685_0\">The access rules (Clause [class.access]) for a virtual function are determined by its declaration and are not affected by the rules for a function that later overrides it. [\u2009Example:</p>\n<pre><code>class B {\npublic:\n  virtual int f();\n};\n\nclass D : public B {\nprivate:\n  int f();\n};\n\nvoid f() {\n  D d;\n  B* pb = &amp;d;\n  D* pd = &amp;d;\n\n  pb-&gt;f();                      // OK: B\u200b::\u200bf() is public, D\u200b::\u200bf() is invoked\n  pd-&gt;f();                      // error: D\u200b::\u200bf() is private\n}\n</code></pre>\n<p id=\"so_43890656_43890685_1\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n<p>And again in <a href=\"http://eel.is/c++draft/class.virtual#footnote-111\" rel=\"nofollow noreferrer\">footnote 111 in [class.virtual]</a>:</p>\n<blockquote>\n<p id=\"so_43890656_43890685_2\">Access control is not considered in determining overriding.</p>\n</blockquote>\n", "OwnerUserId": "3919155", "LastEditorUserId": "3919155", "LastEditDate": "2017-05-10T11:22:06.380", "Id": "43890685", "Score": "1", "CreationDate": "2017-05-10T11:06:34.217", "LastActivityDate": "2017-05-10T11:22:06.380"}, "43892484": {"ParentId": "43890656", "CommentCount": "0", "Body": "<p>You delete the derived class through the base class pointer. With the help of the virtual destructor you start the delete at the derived class. Because that class can access its private members, it call the private destructor. After that the base class is calling the public destructor. </p>\n<p>Note that you call <strong>delete</strong> and not calling de destructor Derived::~Derived() direct!</p>\n", "OwnerUserId": "7573808", "PostTypeId": "2", "Id": "43892484", "Score": "0", "CreationDate": "2017-05-10T12:25:52.373", "LastActivityDate": "2017-05-10T12:25:52.373"}, "43890656": {"CommentCount": "1", "AcceptedAnswerId": "43890796", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2017-05-10T11:05:03.367", "LastActivityDate": "2017-05-10T12:25:52.373", "LastEditDate": "2017-05-10T11:12:55.760", "ViewCount": "102", "FavoriteCount": "0", "Title": "Private Derived Destructor", "Id": "43890656", "Score": "-1", "Body": "<p>When I am trying to delete the derived object polymorphically (that is: base class has <strong>public virtual destructor</strong>) why derived class <strong>private destructor</strong> is still being called? Why the scope resolution <strong>private</strong> is not working here.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Base\n{\nprotected:\n    Base() { cout &lt;&lt; \"Base constructor.\\n\"; }\npublic:\n    virtual ~Base() { cout &lt;&lt; \"Base destructor.\\n\"; }\n};\n\nclass Derived :public Base\n{\npublic:\n    Derived() { cout &lt;&lt; \"Derived constructor.\\n\"; }\nprivate:\n   ~Derived() { cout &lt;&lt; \"Derived destructor.\\n\"; }\n};\n\nint main()\n{\n    Base *p = new Derived();\n    delete p;\n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Base constructor.\nDerived constructor.\nDerived destructor.\nBase destructor.\n</code></pre>\n", "Tags": "<c++><oop><virtual-destructor><scope-resolution>", "OwnerUserId": "2949645", "AnswerCount": "5"}, "43890978": {"ParentId": "43890656", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can call the destructor through a pointer to <code>B</code>, because it's already public there. It's the static type of the pointer which is used to determine that access in this case.</p>\n<p><a href=\"http://eel.is/c++draft/class.access.virt#1\" rel=\"nofollow noreferrer\">[class.access.virt/1]</a></p>\n<blockquote>\n<p id=\"so_43890656_43890978_0\">The access rules (Clause [class.access]) for a virtual function are\n  determined by its declaration and are not affected by the rules for a\n  function that later overrides it. [\u2009Example:</p>\n<pre><code>class B {\npublic:\n  virtual int f();\n};\n\nclass D : public B {\nprivate:\n  int f();\n};\n\nvoid f() {\n  D d;\n  B* pb = &amp;d;\n  D* pd = &amp;d;\n\n  pb-&gt;f();                      // OK: B\u200b::\u200bf() is public, D\u200b::\u200bf() is invoked\n  pd-&gt;f();                      // error: D\u200b::\u200bf() is private\n}\n</code></pre>\n<p id=\"so_43890656_43890978_1\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n<p>This keeps virtual functions in line with the <a href=\"https://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle\">Liskov Substitution Principle</a></p>\n", "OwnerUserId": "817643", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:11.627", "Id": "43890978", "Score": "0", "CreationDate": "2017-05-10T11:20:08.977", "LastActivityDate": "2017-05-10T11:20:08.977"}, "43890796": {"ParentId": "43890656", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Because destructors are called in reversed order of constructors and virtual destructor will always be called.</p>\n<p><code>private</code> has nothing to do if a virtual function is going to be called.</p>\n<p>As I pointed here out:</p>\n<p><a href=\"https://stackoverflow.com/questions/1133955/why-would-a-virtual-function-be-private/1134198#1134198\">Why would a virtual function be private?</a></p>\n<p>ISO C++ 1998 Standard onwards explicitly states:</p>\n<blockquote>\n<p id=\"so_43890656_43890796_0\">\u00a710.3 [...] Access control (clause 11) is not considered in determining overriding.</p>\n</blockquote>\n<hr>\n<p>A bit philosophical offtopic:</p>\n<p>Going further this is what STL does for <code>iostreams</code>: Definition of <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface\" rel=\"nofollow noreferrer\">Non-Virtual Interface</a>, i.e. all public functions (with exception of destructors) are non-virtual and all virtual functions are either <code>protected</code> or <code>private</code>. Public functions call virtual protected or private ones. This gives a very clear entry point into the entire hierarchy.</p>\n</hr>", "OwnerUserId": "98693", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:41.457", "Id": "43890796", "Score": "3", "CreationDate": "2017-05-10T11:11:43.223", "LastActivityDate": "2017-05-10T11:16:43.907"}, "bq_ids": {"n4140": {"so_43890656_43890978_0": {"section_id": 6696, "quality": 0.8125, "length": 13}, "so_43890656_43890796_0": {"section_id": 7003, "quality": 0.6666666666666666, "length": 4}, "so_43890656_43890685_2": {"section_id": 7003, "quality": 1.0, "length": 4}, "so_43890656_43890685_0": {"section_id": 6696, "quality": 0.8125, "length": 13}}, "n3337": {"so_43890656_43890978_0": {"section_id": 6451, "quality": 0.8125, "length": 13}, "so_43890656_43890796_0": {"section_id": 6749, "quality": 0.6666666666666666, "length": 4}, "so_43890656_43890685_2": {"section_id": 6749, "quality": 1.0, "length": 4}, "so_43890656_43890685_0": {"section_id": 6451, "quality": 0.8125, "length": 13}}, "n4659": {"so_43890656_43890978_0": {"section_id": 8171, "quality": 0.8125, "length": 13}, "so_43890656_43890796_0": {"section_id": 8500, "quality": 0.6666666666666666, "length": 4}, "so_43890656_43890685_2": {"section_id": 8500, "quality": 1.0, "length": 4}, "so_43890656_43890685_0": {"section_id": 8171, "quality": 0.8125, "length": 13}}}});