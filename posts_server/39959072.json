post_cb({"39959791": {"ParentId": "39959072", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>\"In 1985, the first edition of The C++ Programming Language was released, which became the definitive reference for the language, as <strong>there was not yet an official standard</strong>.\" <a href=\"https://en.wikipedia.org/wiki/C%2B%2B#History\" rel=\"noreferrer\">wiki C++ History</a> So it didn't change between C++11 and C++14. I can assume (and please take this with a grain of salt) it changed between \"pre-standardization\" and standardization. Maybe someone who knows better the history of C++ can shed more light here.</p>\n<p>As for what actually happens:</p>\n<hr>\n<p>First let's get out of the way the simple one:</p>\n<pre><code>extern g(double);\n</code></pre>\n<p>This is invalid C++. Historically, unfortunately C allowed omission of type. In C++ you have to write <code>extern void g(double)</code>.</p>\n<hr>\n<p>Next, let's ignore the <code>g(double)</code> overload to answer your first question:</p>\n<pre><code>template &lt;class T&gt;\nvoid f(T value)\n{\n    g(value);\n}\n\nvoid g(int v);\n\nint main()\n{\n    f(2);\n}\n</code></pre>\n<p>In C++ there is the infamous two phase name lookup:</p>\n<ul>\n<li>In the first phase, at the template definition, all <a href=\"http://en.cppreference.com/w/cpp/language/dependent_name\" rel=\"noreferrer\">non-dependent names</a> are resolved. Failure to do so is a hard error;</li>\n<li>Dependent names are resolved in phase two, at the template instantiation.</li>\n</ul>\n<p>The rules are a bit more complicated, but that is the gist of it.</p>\n<p><code>g</code> is dependent on template parameter <code>T</code> so it passes the first phase. That means that if you never instantiate <code>f</code>, the code compiles just fine. At the second phase <code>f</code> is instantiated with <code>T = int</code>. <code>g(int)</code> is now searched, but not found:</p>\n<blockquote id=\"so_39959072_39959791_0\">\n<pre><code>17 : error: call to function 'g' that is neither visible in the template definition nor found by argument-dependent lookup\ng(value);\n^\n24 : note: in instantiation of function template specialization 'f&lt;int&gt;' requested here\nf(2);\n^\n20 : note: 'g' should be declared prior to the call site\nvoid g(int v);\n</code></pre>\n</blockquote>\n<p>In order for an arbitrary name <code>g</code> to pass with flying colors we have a few options:</p>\n<ol>\n<li>Declare <code>g</code> previously:</li>\n</ol>\n<pre><code>void g(int);\n\ntemplate &lt;class T&gt;\nvoid f(T value)\n{\n    g(value);\n}\n</code></pre>\n<ol start=\"2\">\n<li>bring <code>g</code> in with <code>T</code>:</li>\n</ol>\n<pre><code>template &lt;class T&gt;\nvoid f(T)\n{\n    T::g();\n}\n\nstruct X {\n   static void g();\n};\n\nint main()\n{\n    X x;\n    f(x);\n}\n</code></pre>\n<ol start=\"3\">\n<li>Bring <code>g</code> in with <code>T</code> via ADL:</li>\n</ol>\n<pre><code>template &lt;class T&gt;\nvoid f(T value)\n{\n    g(value);\n}\n\nstruct X {};\n\nvoid g(X);\n\nint main()\n{\n    X x;\n    f(x);\n}\n</code></pre>\n<p>These of course change the semantics of the program. They are meant to illustrate what you can and cannot have in a template.</p>\n<hr>\n<p>As for why doesn't ADL find <code>g(int)</code>, but finds <code>g(X)</code>:</p>\n<blockquote>\n<p id=\"so_39959072_39959791_1\">\u00a7 3.4.2 Argument-dependent name lookup [basic.lookup.argdep]</p>\n<ol start=\"3\">\n<li><p id=\"so_39959072_39959791_2\">For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero or more\n  associated classes to be considered [...]:</p>\n<ul>\n<li><p id=\"so_39959072_39959791_3\">If T is a fundamental type, its associated sets of namespaces and classes are both empty.</p></li>\n<li><p id=\"so_39959072_39959791_4\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and\n  its direct and indirect base classes. Its associated namespaces are\n  the namespaces of which its associated classes are members. [...]</p></li>\n</ul></li>\n</ol>\n</blockquote>\n<hr>\n<p>And finally we get to why <code>extern void g(double);</code> inside main is not found: first of all we showed that <code>g(fundamental_type)</code> is found <a href=\"https://en.wikipedia.org/wiki/If_and_only_if\" rel=\"noreferrer\">iff</a> it is declared prior to the <code>f</code> definition. So let's make it <code>void g(X)</code> inside <code>main</code>. Does ADL find it?</p>\n<pre><code>template &lt;class T&gt;\nvoid f(T value)\n{\n    g(value);\n}\n\nstruct X{};\n\n\nint main()\n{\n  X x;\n  void g(X);\n\n  f(x);\n}\n</code></pre>\n<p>No. Because it does not reside in the same namespace as <code>X</code> (i.e. global namespace) ADL can't find it.</p>\n<p>Proof that <code>g</code> is not in global </p>\n<pre><code>int main()\n{\n  void g(X);\n\n  X x;\n  g(x); // OK\n  ::g(x); // ERROR\n}\n</code></pre>\n<blockquote>\n<p id=\"so_39959072_39959791_5\">34 : error: no member named 'g' in the global namespace; did you mean\n  simply 'g'?</p>\n</blockquote>\n</hr></hr></hr></hr>", "OwnerUserId": "2805305", "LastEditorUserId": "2805305", "LastEditDate": "2016-10-10T17:31:30.380", "Id": "39959791", "Score": "13", "CreationDate": "2016-10-10T13:45:39.767", "LastActivityDate": "2016-10-10T17:31:30.380"}, "39959072": {"CommentCount": "4", "AcceptedAnswerId": "39959791", "PostTypeId": "1", "LastEditorUserId": "4326278", "CreationDate": "2016-10-10T13:09:16.657", "LastActivityDate": "2016-11-27T15:07:15.980", "LastEditDate": "2016-11-27T15:07:15.980", "ViewCount": "420", "FavoriteCount": "2", "Title": "At which point occurs template Instantiation binding?", "Id": "39959072", "Score": "20", "Body": "<p>This code is from \"C++ programming language\" by Bjarne Stroustrup (C.13.8.3 Point of Instantiation Binding)</p>\n<pre><code>template &lt;class T&gt;\nvoid f(T value)\n{\n    g(value);\n}\n\nvoid g(int v);\n\nvoid h()\n{\n    extern g(double);\n    f(2);\n}\n</code></pre>\n<p>And he mentions:</p>\n<blockquote>\n<p id=\"so_39959072_39959072_0\">Here, the point of instantiation for f() is just before h(), so\n  the g() called in f() is the global g(int) rather than the local\n  g(double). The definition of \u2018\u2018instantiation point\u2019\u2019 implies that a\n  template parameter can never be bound to a local name or a class\n  member.</p>\n</blockquote>\n<pre><code>void h()\n{\n    struct X {}; // local structure\n    std::vector&lt;X&gt; v; // error: can't use local structure as template parameter\n}\n</code></pre>\n<p>My questions are:</p>\n<ol>\n<li><p>Why should the first code work? <code>g()</code> is declared later, and I really get an error with G++ 4.9.2 that <code>g</code> isn't declared at that point.</p></li>\n<li><p><em>extern g(double)</em> - how this works? since return value doesn't matter in case of function overloading, then we can miss it in forward declarations?</p></li>\n<li><p><em>the point of instantiation for f() is just before h()</em> - why? isn't it logical that it'll get instantiated when <code>f(2)</code> is being called? Right where we call it, whence <code>g(double)</code> will be in scope already.</p></li>\n<li><p><em>The definition of \u2018\u2018instantiation point\u2019\u2019 implies that a template parameter can never be bound to a local name or a class member</em> - Has this changed in C++14? I'm getting error with C++(G++ 4.9.2), but don't get error with C++14(G++ 4.9.2).</p></li>\n</ol>\n", "Tags": "<c++><templates><c++14><name-binding><template-instantiation>", "OwnerUserId": "4808130", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39959072_39959791_3": {"section_id": 7104, "quality": 1.0, "length": 9}, "so_39959072_39959791_2": {"section_id": 7104, "quality": 0.9411764705882353, "length": 16}, "so_39959072_39959791_4": {"section_id": 7104, "quality": 1.0, "length": 24}}, "n3337": {"so_39959072_39959791_3": {"section_id": 6848, "quality": 1.0, "length": 9}, "so_39959072_39959791_2": {"section_id": 6848, "quality": 0.9411764705882353, "length": 16}, "so_39959072_39959791_4": {"section_id": 6848, "quality": 1.0, "length": 24}}, "n4659": {"so_39959072_39959791_3": {"section_id": 8605, "quality": 1.0, "length": 9}, "so_39959072_39959791_2": {"section_id": 8605, "quality": 0.7058823529411765, "length": 12}, "so_39959072_39959791_4": {"section_id": 8605, "quality": 1.0, "length": 24}}}});