post_cb({"39914347": {"ParentId": "39914051", "CommentCount": "0", "Body": "<p>It is <strong>not</strong> a compiler bug. This is due to the fact that converting 0 to a pointer type has \"Conversion rank\". </p>\n<p>C++11 \u00a74.10 (Conversion rank)</p>\n<blockquote>\n<p id=\"so_39914051_39914347_0\">A null pointer constant is an integer literal (2.13.2) with value zero\n  or a prvalue of type std::nullptr_t. A null pointer constant can be\n  converted to a pointer type; the result is the null pointer value of\n  that type and is distinguishable from every other value of object\n  pointer or function pointer type. Such a conversion is called a null\n  pointer conversion.</p>\n</blockquote>\n<p>So when you write a 0 literal, and a <em>conversion</em> is necessary, the compiler encounters two overloads of similar rank - one a non-pointer type, and the other a pointer type.</p>\n<p>Some more examples:</p>\n<pre><code> foo&lt;short&gt;((short)0); // No conversion necessary: allowed\n foo&lt;nullptr_t&gt;(nullptr); // No conversion necessary: allowed\n foo&lt;nullptr_t&gt;(0); // ambiguous\n foo&lt;nullptr_t&gt;(NULL); // ambigious - another reason to stop using NULL\n</code></pre>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "39914347", "Score": "3", "CreationDate": "2016-10-07T09:50:52.667", "LastActivityDate": "2016-10-07T09:50:52.667"}, "39914051": {"CommentCount": "0", "ViewCount": "70", "PostTypeId": "1", "LastEditorUserId": "4324224", "CreationDate": "2016-10-07T09:35:13.387", "LastActivityDate": "2016-10-07T09:55:03.410", "Title": "Template function ambiguous parameter deduction for 0", "LastEditDate": "2016-10-07T09:55:03.410", "Id": "39914051", "Score": "3", "Body": "<p>I have a strange issue while compiling following example.</p>\n<pre><code>template&lt;typename T&gt;\nstruct identity {\n    typedef T type;\n};\n\ntemplate&lt;typename T&gt;\nvoid foo(typename identity&lt;T&gt;::type v) {}\n\ntemplate&lt;typename T&gt;\nvoid foo(typename identity&lt;T&gt;::type* v) {}\n\nint main() {\n    foo&lt;int&gt;(0);\n    foo&lt;short&gt;(0);\n    return 0;\n}\n</code></pre>\n<p>Calling <code>foo&lt;int&gt;(0)</code> compiles, but, when I call <code>foo&lt;short&gt;(0)</code>, compiler can't deduce if 0 is a value or a pointer. I use identity to force explicit specification of template parameter. Compiler(msvc) error message:</p>\n<pre><code>error C2668: 'foo': ambiguous call to overloaded function\n</code></pre>\n<p>Is it compiler bug?</p>\n", "Tags": "<c++><templates><template-deduction>", "OwnerUserId": "3554063", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39914051_39914347_0": {"section_id": 39, "quality": 0.9210526315789473, "length": 35}}, "n3337": {"so_39914051_39914347_0": {"section_id": 36, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_39914051_39914347_0": {"section_id": 39, "quality": 0.9210526315789473, "length": 35}}}});