post_cb({"31037764": {"CommentCount": "0", "ViewCount": "347", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2015-06-24T21:51:44.053", "LastActivityDate": "2015-06-24T22:16:34.340", "Title": "Are the fixed width integer types guaranteed to be typedefs for the standard built in types?", "AcceptedAnswerId": "31037997", "LastEditDate": "2015-06-24T21:58:02.340", "Id": "31037764", "Score": "7", "Body": "<p>Are the types from <code>&lt;cstdint&gt;</code> (like e.g. <code>int16_t</code>, <code>uint_fast64_t</code>, <code>int_least8_t</code>) guaranteed to be <code>typedef</code>s for one of the built in types like <code>short</code>, <code>unsigned long</code> etc.?</p>\n<p>Or is an implementation allowed to use types that are non of the usual built in ones to implement the fixed width types?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "3002139", "AnswerCount": "4"}, "31037955": {"ParentId": "31037764", "CommentCount": "5", "Body": "<p>From the C++ standard: \"There may also be implementation-defined extended signed integer types. The standard and extended signed integer types are collectively called signed integer types. \". (I think there is a similar line about extended unsigned integer types) Nothing is said how you would use these extended integer types, they are obviously non-portable and implementation defined. </p>\n<p>However, int16_t etc. can be typedefs for extended integer types. </p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "31037955", "Score": "1", "CreationDate": "2015-06-24T22:04:47.053", "LastActivityDate": "2015-06-24T22:04:47.053"}, "31037997": {"ParentId": "31037764", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>These are specified by the C standard (and incorporated by reference by the C++ standard), which requires each to be a typedef for a <em>signed integer type</em> or <em>unsigned integer type</em>, as the case may be.</p>\n<p><em>signed integer type</em> is in turn defined by the core language to consist of the <em>standard signed integer types</em> (which are <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code> and <code>long long int</code>) and any implementation-defined <em>extended signed integer types</em>.</p>\n<p>Similarly, <em>unsigned integer type</em> is defined by the core language to consist of the <em>standard unsigned integer types</em> (which are <code>unsigned char</code>, <code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code> and <code>unsigned long long int</code>) and any implementation-defined <em>extended unsigned integer types</em> corresponding to the extended signed integer types.</p>\n<p>In short, each of those typedefs may be one of the usual built-in types or an implementation-defined extended integer type. Most compilers do not support extended integer types, so on those compilers they must be built-in types.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-06-24T22:15:44.500", "Id": "31037997", "Score": "2", "CreationDate": "2015-06-24T22:08:00.383", "LastActivityDate": "2015-06-24T22:15:44.500"}, "31038099": {"ParentId": "31037764", "CommentCount": "2", "Body": "<p>No, at least not for types <code>intN_t</code>. These types are guaranteed to have two\u2019s complement representation (as per C99 7.18.1.1 which C++11 and C++14 reference). And standard integer types don't have to be two's complement.</p>\n<p>C11 also has important change over C99 (which is actually just bugfix), emphasizing the point above:</p>\n<p>7.20.1.1/3:</p>\n<blockquote>\n<p id=\"so_31037764_31038099_0\">However, if an implementation provides integer types with\n  widths of 8, 16, 32, or 64 bits, no padding bits, <strong>and (for the signed types) that have a\n  two\u2019s complement representation</strong>, it shall define the corresponding typedef names.</p>\n</blockquote>\n", "OwnerUserId": "3959454", "PostTypeId": "2", "Id": "31038099", "Score": "2", "CreationDate": "2015-06-24T22:16:34.340", "LastActivityDate": "2015-06-24T22:16:34.340"}, "31037977": {"ParentId": "31037764", "CommentCount": "1", "Body": "<p>I have a draft version of the C99 spec in front of me and a draft of the C++14 spec as well. Since these are drafts, this information might be incorrect, but I believe that the wording is the same in the final version.</p>\n<p>In the C++14 spec, \u00a718.4.1 has this to say about <code>&lt;cstdint&gt;</code>:</p>\n<pre><code>namespace std {\n   typedef signed-integer-type int8_t; // optional\n   typedef signed-integer-type int16_t; // optional\n   typedef signed-integer-type int32_t; // optional\n   typedef signed-integer-type int64_t; // optional\n\n   [ etc. ]\n}\n</code></pre>\n<p>It then says</p>\n<blockquote>\n<p id=\"so_31037764_31037977_0\">The header defines all functions, types, and macros the same as 7.18 in the C standard.</p>\n</blockquote>\n<p>I went to the draft C99 standard, \u00a77.18, and saw nothing that required the types defined to actually be aliases for built-in types like <code>int</code>, <code>long int</code>, etc. It just said that if these types exist, they have to meet certain constraints about their ranges, sizes, and memory layouts.</p>\n<p>Overall, I strongly suspect that the answer is \"no,\" but if I'm mistaken, I'm interested to see where I misread the spec. :-)</p>\n<p>Hope this helps!</p>\n", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "31037977", "Score": "2", "CreationDate": "2015-06-24T22:07:05.770", "LastActivityDate": "2015-06-24T22:07:05.770"}, "bq_ids": {"n4140": {"so_31037764_31037977_0": {"section_id": 6797, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_31037764_31037977_0": {"section_id": 6552, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_31037764_31037977_0": {"section_id": 8287, "quality": 0.6666666666666666, "length": 6}}}});