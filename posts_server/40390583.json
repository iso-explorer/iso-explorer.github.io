post_cb({"40390760": {"ParentId": "40390583", "CommentCount": "9", "Body": "<p>From <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.0.2/gcc/Other-Builtins.html#index-g_t_005f_005fbuiltin_005fexpect-2284\" rel=\"nofollow noreferrer\">the docs</a>:</p>\n<blockquote>\n<p id=\"so_40390583_40390760_0\">The return value is the value of <em>exp</em>, which should be an integral expression.</p>\n</blockquote>\n<p>So the logical semantics of:</p>\n<pre><code>if(__builtin_expect(num,4)) { ... }\n</code></pre>\n<p>are:</p>\n<pre><code>if (num) { ... }\n</code></pre>\n<p>which is different than what you say you want. If you want to write that you expect that <code>num == 4</code> to be very likely, you want:</p>\n<pre><code>if (__builtin_expect(num == 4, 1)) { ... }\n</code></pre>\n<p>Commonly, you'd just wrap these in macros:</p>\n<pre><code>#define likely(expr)   __builtin_expect((expr), 1)\n#define unlikely(expr) __builtin_expect((expr), 0)\n</code></pre>\n<p>and then the usage becomes more natural:</p>\n<pre><code>if (likely(num == 4)) { ... }\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "40390760", "Score": "5", "CreationDate": "2016-11-02T22:18:22.020", "LastActivityDate": "2016-11-02T22:18:22.020"}, "40390583": {"CommentCount": "0", "ViewCount": "78", "PostTypeId": "1", "LastEditorUserId": "802302", "CreationDate": "2016-11-02T22:02:25.107", "LastActivityDate": "2016-11-02T22:18:26.490", "Title": "GCC's __builtin_expect assembly dump seems to always go down branch", "AcceptedAnswerId": "40390760", "LastEditDate": "2016-11-02T22:18:26.490", "Id": "40390583", "Score": "3", "Body": "<p>Ok so I have been playing around with __builtin_expect a bit and I just created a simple test program that I put through godbolt.org to get the assembly output (<a href=\"https://godbolt.org/g/FZo5fP\" rel=\"nofollow noreferrer\">https://godbolt.org/g/FZo5fP</a>)</p>\n<pre><code>int main(){\n  volatile int num = 4;\n  //if(num == 4){\n  if(__builtin_expect(num,4)){\n    return num*800;\n  }else{\n    return num*500;\n  }\n}\n</code></pre>\n<p>When compiled with -O1 or greater produces:</p>\n<pre><code>main:\n        mov     DWORD PTR [rsp-4], 4\n        mov     eax, DWORD PTR [rsp-4]\n        test    eax, eax\n        mov     eax, DWORD PTR [rsp-4]\n        je      .L2\n        imul    eax, eax, 800\n        ret\n.L2:\n        imul    eax, eax, 500\n        ret\n</code></pre>\n<p>It seems as though the part that says <code>test eax,eax</code> would always set zero flag to 0 unless <code>num</code> was equal to 0. So it seems as though if <code>num</code> is not set to 0 it will always multiply by 800 instead of only when <code>num=4</code>. My understanding of __builtin_expect is that while it will  optimize to assume that it will go to that branch it should still be comparing to ensure that it should use that branch.</p>\n<p>If I switch __builtin_expect to just == it produces </p>\n<pre><code>main:\n        mov     DWORD PTR [rsp-4], 2\n        mov     eax, DWORD PTR [rsp-4]\n        cmp     eax, 4\n        mov     eax, DWORD PTR [rsp-4]\n        je      .L5\n        imul    eax, eax, 500\n        ret\n.L5:\n        imul    eax, eax, 800\n        ret\n</code></pre>\n<p>Which makes much more sense to me in that it actually compares against 4. Is my understanding of __builtin_expect wrong? Does __builtin_expect actually only work with 0 or 1 even though it specifies that it takes a long?</p>\n", "Tags": "<c++><c><gcc><assembly>", "OwnerUserId": "802302", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40390583_40390760_0": {"section_id": 3885, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_40390583_40390760_0": {"section_id": 3745, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_40390583_40390760_0": {"section_id": 4764, "quality": 0.5714285714285714, "length": 4}}}});