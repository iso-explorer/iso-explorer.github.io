post_cb({"47510004": {"Id": "47510004", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47508477_47510004_0\">Why is an object's destructor not called when an exception is thrown from its constructor?</p>\n</blockquote>\n<ul>\n<li><p>Logically: because it was never constructed, so there's nothing to destroy.</p>\n<p>An object's lifetime only begins when the constructor completes successfully.</p></li>\n<li><p>Practically: if you throw an exception part-way through construction, how would a destructor know which parts of the object were created (and should be destroyed), and which are just un-initialized memory? This scheme could not possibly work.</p></li>\n</ul>\n<p>So, the destructor can't be used to \"undo\" a failed constructor; it's automatically handled as part of stack unwinding instead. For example, consider:</p>\n<pre><code>class A;\nclass B;\nclass C;\nclass D : public A, B {\n  C m_c;\n  D() : A(), B(), m_c() {}\n};\n</code></pre>\n<ol>\n<li>first, storage is allocated for <code>D</code>. If this step is dynamic, and fails, <code>std::bad_alloc</code> is thrown (and the D instance never started existing)</li>\n<li>then <code>A::A()</code> initializes the first (A) base-class subobject. If this fails, the subobject never started existing, the storage allocation is unwound, etc.</li>\n<li>if <code>A::A()</code> succeeds, <code>B::B()</code> initializes the second base-class subobject. If <em>this</em> throws, <code>A::~A()</code> is automatically used to destroy the A subobject.</li>\n<li>if both base-class subobjects succeed, <code>C::C()</code> is used to initialize the member object: if <em>this</em> throws, <em>both</em> the A and B base-class subobjects are destroyed in reverse order</li>\n<li>if all the A, B and C subobjects were constructed normally, only then is the body of <code>D::D()</code> (the part inside the <code>{}</code>, after the initializer list) entered. If <em>this</em> throws, the C, B and A objects are destroyed (in that order: it's always reverse order of construction)</li>\n<li>only if <em>all</em> those steps succeed, a new instance of <code>D</code> has started its lifetime. This will be destroyed with <code>D::~D()</code> when its lifetime ends.</li>\n</ol>\n", "LastActivityDate": "2017-11-27T11:33:23.653", "CommentCount": "2", "CreationDate": "2017-11-27T11:33:23.653", "ParentId": "47508477", "Score": "2", "OwnerUserId": "212858"}, "bq_ids": {"n4140": {"so_47508477_47508870_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 3287}, "so_47508477_47510004_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 480}}, "n3337": {"so_47508477_47508870_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 3157}}, "n4659": {"so_47508477_47508870_0": {"length": 12, "quality": 1.0, "section_id": 4061}}}, "47508477": {"ViewCount": "62", "Body": "<p>Can anyone explain me why the output of the below snippet is :<br/></p>\n<blockquote id=\"so_47508477_47508477_0\">\n<pre><code>MyClass constructor\ncatch block\n</code></pre>\n</blockquote>\n<p>Why is the destructor of object <code>m</code> not been called as the scope of it is within try block?<br>\nWhen it comes to catch block with <code>throw 0;</code> statement, the object <code>m</code> of <code>MyClass</code> is out of scope and its destructor should have been invoked right?</br></p>\n<p>Am i missing some kind of concept hear?</p>\n<pre><code>class MyClass {                                                                 \npublic:                                                                     \n    MyClass() {                                                                 \n        std::cout &lt;&lt; \"\\nMyClass constructor\" ;                                  \n        throw 0;                                                                \n    }                                                                           \n    ~MyClass() {                                                                      \n        std::cout &lt;&lt; \"\\nMyClass destructor\" &lt;&lt; std::endl;                       \n    }                                                                           \n};                                                                              \n\nint main(void)                                                                  \n{                                                                               \n    try {                                                                       \n        MyClass m;                                                            \n    } catch(int e) {                                                            \n        std::cout &lt;&lt; \"\\ncatch block\" &lt;&lt; std::endl;                              \n    }                                                                           \n\n    return 0;                                                                   \n}    \n</code></pre>\n", "Title": "Why is an object's destructor not called when an exception is thrown from its constructor?", "CreationDate": "2017-11-27T10:15:10.827", "LastActivityDate": "2017-11-27T13:15:43.230", "CommentCount": "2", "LastEditDate": "2017-11-27T10:50:02.110", "PostTypeId": "1", "LastEditorUserId": "5470596", "Id": "47508477", "Score": "2", "OwnerUserId": "9013880", "Tags": "<c++><c++11><constructor><try-catch>", "AnswerCount": "3"}, "47508870": {"Id": "47508870", "PostTypeId": "2", "Body": "<p>According to</p>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/dcl.init#21\" rel=\"nofollow noreferrer\"><code>[dcl.init]/21</code></a></h3>\n<p id=\"so_47508477_47508870_0\">An object whose initialization has completed is deemed to be constructed, even if no constructor of the object\u2019s class is invoked for the initialization.</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/class.dtor#12\" rel=\"nofollow noreferrer\"><code>[class.dtor]/12</code></a></h3>\n<p id=\"so_47508477_47508870_1\">A destructor is invoked implicitly</p>\n<ul>\n<li>for a constructed object with static storage duration (6.7.1) at program termination (6.6.4),</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>When an exception is thrown from a constructor, the object's initialization is not completed, the object is not deemed <em>constructed</em> and no destructor is called since there is infact no object.</p>\n", "LastActivityDate": "2017-11-27T10:35:21.243", "CommentCount": "1", "CreationDate": "2017-11-27T10:35:21.243", "ParentId": "47508477", "Score": "4", "OwnerUserId": "5470596"}, "47508597": {"Id": "47508597", "PostTypeId": "2", "Body": "<p><code>UKMonkey</code> is right. See his comment.\nAs you raised an exception in constructor, it could not instantiate the object m. As no object exist so no call to destructor. That is the reason we must be very careful while throwing exception from a constructor. Just comment out <code>throw 0;</code> and check. You will understand it. </p>\n", "LastActivityDate": "2017-11-27T10:20:47.880", "CommentCount": "1", "CreationDate": "2017-11-27T10:20:47.880", "ParentId": "47508477", "Score": "1", "OwnerUserId": "8405835"}});