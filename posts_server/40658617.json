post_cb({"40658617": {"ViewCount": "1258", "Body": "<p>Are static variables inlined by default inside templates in C++17? Here's an example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct SomeClass {\n    static T test;\n};\n\nstruct SomeClass2 {\n    static constexpr int test = 9;\n};\n</code></pre>\n<p>Are those variables inlined or still need an out of line definition to be ODR used?</p>\n", "AcceptedAnswerId": "40658932", "Title": "Are static variables inlined by default inside templates in C++17?", "CreationDate": "2016-11-17T15:19:44.310", "Id": "40658617", "CommentCount": "0", "LastEditDate": "2016-11-19T22:36:32.013", "PostTypeId": "1", "LastEditorUserId": "2104697", "LastActivityDate": "2016-11-19T22:36:32.013", "Score": "21", "OwnerUserId": "2104697", "Tags": "<c++><templates><inline><c++1z>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40658617_40658995_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5402}}, "n3337": {"so_40658617_40658995_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5197}}, "n4659": {"so_40658617_40658995_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 6839}, "so_40658617_40658932_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6305}, "so_40658617_40658932_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 6839}, "so_40658617_40658995_1": {"length": 7, "quality": 1.0, "section_id": 6850}}}, "40658995": {"Id": "40658995", "PostTypeId": "2", "Body": "<p>From [dcl.constexpr]:</p>\n<blockquote>\n<p id=\"so_40658617_40658995_0\">A function or static data member declared with the <code>constexpr</code>\n  specifier is implicitly an inline function or variable (7.1.6).</p>\n</blockquote>\n<p>There is no such implicit <code>inline</code> for static (non-<code>constexpr</code>) data members of class templates. However, in C++17, we can now mark variables themselves as <code>inline</code>, [dcl.inline]:</p>\n<blockquote>\n<p id=\"so_40658617_40658995_1\">A variable declaration with an <code>inline</code> specifier declares an inline variable.</p>\n</blockquote>\n", "LastActivityDate": "2016-11-17T15:36:29.753", "Score": "11", "CreationDate": "2016-11-17T15:36:29.753", "ParentId": "40658617", "CommentCount": "0", "OwnerUserId": "2069064"}, "40658932": {"Id": "40658932", "PostTypeId": "2", "Body": "<p>A <code>static constexpr</code> will implicitly also be <code>inline</code>, otherwise you will need to mark it as <code>inline</code></p>\n<pre><code>template&lt;typename T&gt;\nstruct SomeClass {\n    inline static T test; // Now inline\n};\n\nstruct SomeClass2 {\n    static constexpr int test = 9; // inline\n};\n</code></pre>\n<p>Cfr. from n4606 <code>[depr.static_constexpr]</code></p>\n<blockquote>\n<p id=\"so_40658617_40658932_0\">For compatibility with prior C++ International Standards, a constexpr static data member may be redundantly redeclared outside the class with no initializer. This usage is deprecated.</p>\n<p id=\"so_40658617_40658932_1\">Example:</p>\n<pre><code>struct A {\n  static constexpr int n = 5; // definition (declaration in C++ 2014)\n};\nconst int A::n; // redundant declaration (definition in C++ 2014)\n</code></pre>\n</blockquote>\n<p>and <code>[dcl.constexpr]</code> (Barry beat me to it)</p>\n<blockquote>\n<p id=\"so_40658617_40658932_2\">A function or static data member declared with the constexpr specifier is implicitly an inline function or variable (7.1.6).</p>\n</blockquote>\n", "LastEditorUserId": "369450", "LastActivityDate": "2016-11-17T16:47:23.610", "Score": "21", "CreationDate": "2016-11-17T15:33:26.787", "ParentId": "40658617", "CommentCount": "0", "LastEditDate": "2016-11-17T16:47:23.610", "OwnerUserId": "1938163"}});