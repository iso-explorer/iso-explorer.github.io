post_cb({"19178785": {"ParentId": "19178647", "CommentCount": "1", "Body": "<p>Yes, it is possible. Just make it comply to the requirements of a uniform random number generator (\u00a726.5.1.3 paragraphs 2 and 3):</p>\n<blockquote>\n<p id=\"so_19178647_19178785_0\">2 A class <code>G</code> satisfies the requirements of a uniform random number\n  generator if the expressions shown in Table 116 are valid and have the\n  indicated semantics, and if <code>G</code> also satisfies all other requirements\n  of this section. In that Table and throughout this section:</p>\n<p id=\"so_19178647_19178785_1\">a) <code>T</code> is the type named by <code>G\u2019s associated</code>result_type`, and</p>\n<p id=\"so_19178647_19178785_2\">b) <code>g</code> is a value of <code>G</code>.</p>\n<p id=\"so_19178647_19178785_3\">Table 116 \u2014 Uniform random number generator requirements</p>\n<pre><code>Expression     | Return type | Pre/post-condition         | Complexity\n----------------------------------------------------------------------\nG::result_type |    T        | T is an unsigned integer   | compile-time\n               |             | type (\u00a73.9.1).             |\n----------------------------------------------------------------------\ng()            |    T        | Returns a value in the     | amortized constant\n               |             | closed interval            |\n               |             | [G::min(), G::max()].      |\n----------------------------------------------------------------------\nG::min()       |    T        | Denotes the least value    | compile-time\n               |             | potentially returned by    |\n               |             | operator().                |\n----------------------------------------------------------------------\nG::max()       |    T        | Denotes the greatest value | compile-time\n               |             | potentially returned by    |\n               |             | operator().                |\n</code></pre>\n<p id=\"so_19178647_19178785_4\">3 The following relation shall hold: <code>G::min() &lt; G::max()</code>.</p>\n</blockquote>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "19178785", "Score": "5", "CreationDate": "2013-10-04T10:17:19.293", "LastActivityDate": "2013-10-04T10:17:19.293"}, "41535186": {"ParentId": "19178647", "CommentCount": "0", "Body": "<p>A word of caution here - I came across a big gotcha when I implemented this. It seems that if the return types of max()/min()/operator() are not 64 bit then the distribution will resample. My (unsigned) 32 bit Sobol implementation was getting sampled twice per deviate thus destroying the properties of the numbers. This code reproduces:</p>\n<pre><code>#include &lt;random&gt;\n#include &lt;limits&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\ntypedef uint32_t rng_int_t;\n\nint requested = 0;\nint sampled = 0;\n\nstruct Quasi\n{\n  rng_int_t operator()()\n  {\n    ++sampled;\n    return 0;\n  }\n\n  rng_int_t min() const \n  {\n    return 0;\n  }\n\n  rng_int_t max() const\n  {\n    return std::numeric_limits&lt;rng_int_t&gt;::max();\n  }\n};\n\nint main()\n{\n  std::uniform_real_distribution&lt;double&gt; dist(0.0,1.0);\n\n  Quasi q;\n\n  double total = 0.0;\n  for (size_t i = 0; i &lt; 10; ++i)\n  {\n    dist(q);\n    ++requested;\n  }\n  std::cout &lt;&lt; \"requested: \" &lt;&lt; requested &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"sampled: \" &lt;&lt; sampled &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output (using g++ 5.4):</p>\n<pre><code>requested: 10\nsampled: 20\n</code></pre>\n<p>and even when compiled with -m32. If you change rng_int_t to 64bit the problem goes away. My workaround is to stick the 32 bit value into the most significant bits of the return value, e.g</p>\n<pre><code>return uint64_t(val) &lt;&lt; 32;\n</code></pre>\n", "OwnerUserId": "6672815", "PostTypeId": "2", "Id": "41535186", "Score": "1", "CreationDate": "2017-01-08T16:52:22.217", "LastActivityDate": "2017-01-08T16:52:22.217"}, "19178647": {"CommentCount": "0", "ViewCount": "383", "CreationDate": "2013-10-04T10:10:26.320", "LastActivityDate": "2017-01-08T16:52:22.217", "Title": "Running std::normal_distribution with user-defined random generator", "AcceptedAnswerId": "19178785", "PostTypeId": "1", "Id": "19178647", "Score": "1", "Body": "<p>I am about to generate an array of normally distributed pseudo-random numbers. As I know the std library offers the following code for that: </p>\n<pre><code>std::random_device rd;\nstd::mt19937 gen(rd());\nstd::normal_distribution&lt;&gt; d(mean,std);\n...\ndouble number = d(gen);\n</code></pre>\n<p>The problem is that I want to use a Sobol' quasi-random sequence instead of Mersenne \nTwister pseudo-random generator. So, my question is:\n<strong>Is it possible to run the std::normal_distribution with a user-defined random generator (with a Sobol' quasi-random sequence generator in my case)?</strong></p>\n<hr>\n<p>More details: I have a class called RandomGenerators, which is used to generate a Sobol' quasi-random numbers:</p>\n<pre><code>RandomGenerator randgen;\ndouble number = randgen.sobol(0,1);\n</code></pre>\n</hr>", "Tags": "<c++><visual-c++><c++11><random>", "OwnerUserId": "1765820", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_19178647_19178785_0": {"section_id": 3498, "quality": 0.875, "length": 21}, "so_19178647_19178785_4": {"section_id": 3494, "quality": 0.8333333333333334, "length": 5}, "so_19178647_19178785_3": {"section_id": 3493, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_19178647_19178785_0": {"section_id": 3363, "quality": 0.875, "length": 21}, "so_19178647_19178785_4": {"section_id": 3359, "quality": 0.8333333333333334, "length": 5}, "so_19178647_19178785_3": {"section_id": 3358, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_19178647_19178785_0": {"section_id": 4261, "quality": 0.8333333333333334, "length": 20}, "so_19178647_19178785_4": {"section_id": 4257, "quality": 0.8333333333333334, "length": 5}, "so_19178647_19178785_3": {"section_id": 4256, "quality": 0.5714285714285714, "length": 4}}}});