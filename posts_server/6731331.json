post_cb({"6731808": {"ParentId": "6731331", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_6731331_6731808_0\">On the other hand, the fact that deleting the null pointer is required to have no effect implies an additional run-time check.</p>\n</blockquote>\n<p>The new wording does not remove that run-time check for a null pointer. The other way around: draft standard comes even closer to saying that an implementation <em>must</em> make a null pointer test to be compliant.</p>\n<p>Also noteworthy: The old standard contradicted itself in that it said (5.3.5/2) that \"if the value of the operand of delete is the null pointer the operation has no effect\" but later said that (5.3.5/7) the \"delete-expression will call a deallocation function.\" Calling a function is an effect. This is particularly so since the function that is called might well be an overridden <code>operator delete</code>.</p>\n<p>The new wording removes that contradiction, explicitly leaving it up to the implementation whether the deallocation function is called in the case of deleting a null pointer.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "6731808", "Score": "5", "CreationDate": "2011-07-18T10:52:36.677", "LastActivityDate": "2011-07-18T10:52:36.677"}, "6731484": {"ParentId": "6731331", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>5.3.5/7 says:</p>\n<blockquote>\n<p id=\"so_6731331_6731484_0\">If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will call a deallocation function (3.7.4.2). Otherwise, it is unspeci\ufb01ed whether the deallocation function will be called.</p>\n</blockquote>\n<p>And 3.7.4.2/3 says:</p>\n<blockquote>\n<p id=\"so_6731331_6731484_1\">The value of the \ufb01rst argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect.</p>\n</blockquote>\n<p>So the behavior is well defined, as long as the standard deallocation function is used, or a user-provided deallocation function handles null pointers correctly.</p>\n", "OwnerUserId": "189205", "LastEditorUserId": "189205", "LastEditDate": "2011-07-18T10:38:31.050", "Id": "6731484", "Score": "71", "CreationDate": "2011-07-18T10:21:50.603", "LastActivityDate": "2011-07-18T10:38:31.050"}, "bq_ids": {"n4140": {"so_6731331_6731484_1": {"section_id": 7182, "quality": 0.8888888888888888, "length": 16}, "so_6731331_6731331_0": {"section_id": 6106, "quality": 0.6666666666666666, "length": 6}, "so_6731331_6731331_2": {"section_id": 6106, "quality": 0.9090909090909091, "length": 10}, "so_6731331_6731331_1": {"section_id": 6106, "quality": 1.0, "length": 11}, "so_6731331_6731484_0": {"section_id": 6111, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_6731331_6731484_1": {"section_id": 6926, "quality": 0.8888888888888888, "length": 16}, "so_6731331_6731484_0": {"section_id": 5877, "quality": 0.8421052631578947, "length": 16}, "so_6731331_6731331_2": {"section_id": 5872, "quality": 0.9090909090909091, "length": 10}, "so_6731331_6731331_1": {"section_id": 5872, "quality": 1.0, "length": 11}, "so_6731331_6731331_0": {"section_id": 5872, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_6731331_6731484_1": {"section_id": 8690, "quality": 0.8888888888888888, "length": 16}, "so_6731331_6731484_0": {"section_id": 7608, "quality": 0.8421052631578947, "length": 16}, "so_6731331_6731331_0": {"section_id": 7603, "quality": 0.6666666666666666, "length": 6}, "so_6731331_6731331_1": {"section_id": 7603, "quality": 1.0, "length": 11}, "so_6731331_6731331_2": {"section_id": 7603, "quality": 0.9090909090909091, "length": 10}}}, "6731331": {"CommentCount": "0", "AcceptedAnswerId": "6731484", "PostTypeId": "1", "LastEditorUserId": "1530549", "CreationDate": "2011-07-18T10:09:08.130", "LastActivityDate": "2014-11-30T02:58:59.493", "LastEditDate": "2014-11-30T02:58:59.493", "ViewCount": "24951", "FavoriteCount": "8", "Title": "Is it still safe to delete nullptr in c++0x?", "Id": "6731331", "Score": "56", "Body": "<p>In <code>c++03</code> it is pretty clear that deleting a null pointer has no effect. Indeed, it is explicitly stated in <code>\u00a75.3.5/2</code> that:</p>\n<blockquote>\n<p id=\"so_6731331_6731331_0\">In either alternative, if the value of the operand of delete is the null pointer the operation has no effect.</p>\n</blockquote>\n<p>However, in the current <a href=\"http://www.open-std.org/jtc1/sc22/WG21/prot/14882fdis/n3291.pdf\">draft</a> for <code>c++0x</code> this sentence seems to be missing. In the rest of the draft I could only find sentences stating what happens if the operand of the <em>delete-expression</em> is not the null pointer constant. Is deleting the null pointer still defined in <code>c++0x</code>, and if so, where?</p>\n<p><strong>Notes:</strong></p>\n<p>There is significant circumstantial evidence to suggest that it is still well defined. </p>\n<p>First, there are the two sentences in <code>\u00a75.3.5/2</code> stating that </p>\n<blockquote>\n<p id=\"so_6731331_6731331_1\">In the first alternative (delete object), the value of the operand of delete may be a null pointer value, ...</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_6731331_6731331_2\">In the second alternative (delete array), the value of the operand of delete may be a null pointer value or ...</p>\n</blockquote>\n<p>These say that the operand is allowed to be null, but on their own do not actually define what happens if it is.</p>\n<p>Second, changing the meaning of <code>delete 0</code> is a major breaking change, and the standards committee would be very unlikely make this particular change. Furthermore there is no mention of this being a breaking change in the Compatibility Annex (Annex C) of the <code>c++0x</code> draft. Annex C is however an Informative section, so this has no bearing no the interpretation of the standard.</p>\n<p>On the other hand, the fact that deleting the null pointer is required to have no effect implies an additional run-time check. In a lot of code the operand can never be null, so this runtime check is in conflict with the zero overhead principle. Maybe the committee just decided to change the behaviour to bring standard c++ more in line with the stated design goals of the language.</p>\n", "Tags": "<c++><null><language-lawyer><delete-operator>", "OwnerUserId": "485561", "AnswerCount": "2"}});