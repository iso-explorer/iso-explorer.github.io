post_cb({"bq_ids": {"n4140": {"so_26947599_26947994_0": {"length": 13, "quality": 1.0, "section_id": 582}}, "n3337": {"so_26947599_26947994_0": {"length": 13, "quality": 1.0, "section_id": 572}}, "n4659": {"so_26947599_26947994_0": {"length": 13, "quality": 1.0, "section_id": 605}}}, "26947599": {"ViewCount": "297", "Body": "<p><code>p1</code> and <code>p2</code> point to the same string content, the following codes compare their addresses which are different.</p>\n<pre><code>const char *p1 = \"abc\";\nconst char p2[] = {'a', 'b', 'c', '\\0'};\ncout &lt;&lt; (p1 == p2) &lt;&lt; endl;                   // 0  (false)\n</code></pre>\n<p>But when I construct a string variable based on <code>p2</code>, then comparing <code>p1</code> and the string variable yields <code>1</code> instead of <code>0</code>.</p>\n<pre><code>string s1(p2);\ncout &lt;&lt; (p1 == s1) &lt;&lt; endl;                  //  1  (true)\n</code></pre>\n<p>My question is : the string class has constructor that takes a <code>const char*</code> as its <strong>only</strong> argument, which tells the compiler to <strong>convert</strong> a <code>const char*</code> to string when possible:</p>\n<pre><code>string (const char* s);\n</code></pre>\n<p>Why doesn't the compiler convert <code>p2</code> to a temporary string variable, and then compare it to <code>p1</code> using the operator defined in string class:</p>\n<pre><code>bool operator== (const char*   lhs, const string&amp; rhs);\n</code></pre>\n", "AcceptedAnswerId": "26947680", "Title": "string class relational operator overload", "CreationDate": "2014-11-15T15:49:44.283", "Id": "26947599", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-11-15T16:28:57.557", "Score": "0", "OwnerUserId": "1822803", "Tags": "<c++><operator-overloading>", "AnswerCount": "2"}, "26947680": {"Id": "26947680", "PostTypeId": "2", "Body": "<p>That's because c++ can compare two <code>const char*</code> variable <code>p1</code> and <code>p2</code> (in other words, <code>p1==p2</code> is a valid c++ statement without any to string conversion), and the semantic is see whether they are the same physical address or not (in your example, they are not, and therefore a <code>false</code> is returned).</p>\n", "LastActivityDate": "2014-11-15T15:57:10.760", "CommentCount": "0", "CreationDate": "2014-11-15T15:57:10.760", "ParentId": "26947599", "Score": "2", "OwnerUserId": "4195568"}, "26947994": {"Id": "26947994", "PostTypeId": "2", "Body": "<p>The compiler doesn't call that <code>operator==</code> overload because it can't - overload resolution for operators only kicks in if at least one of the types in the expression has class or enumeration type.</p>\n<p>From C++11 draft n3290 \u00a713.3.1.2 <em>Operator expressions</em>:</p>\n<blockquote>\n<p id=\"so_26947599_26947994_0\">If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator and interpreted according to Clause 5.</p>\n</blockquote>\n<p>(And clause 5 defines <code>==</code> in section \u00a75.10, with the usual pointer comparison semantics among other things.)</p>\n<p>So that overload is not even considered. You simply can't overload operators on only built-in types.</p>\n", "LastActivityDate": "2014-11-15T16:28:57.557", "CommentCount": "0", "CreationDate": "2014-11-15T16:28:57.557", "ParentId": "26947599", "Score": "1", "OwnerUserId": "635608"}});