post_cb({"5749961": {"ParentId": "5749892", "CommentCount": "2", "Body": "<p>This is a feature of C++ that's used to resolve ambiguity between a variable and type with the same name. I believe they're called 'elaborate type specifiers.'</p>\n<p>You can use a keyword to tell the compiler exactly what you mean, when there would normally be ambiguity.</p>\n<p>Take this for example:</p>\n<pre><code>int x = 0;\nclass x { };\n\n// Compiler error! Am I refering to the variable or class x?\nx y;\n\n// This is okay, I'm telling the compiler which x I'm referring to.\nclass x y;\n</code></pre>\n<p>This can also be used to specify enums and unions, not just structs and classes, though you can only have one user-defined type with the same name.</p>\n", "OwnerUserId": "214796", "PostTypeId": "2", "Id": "5749961", "Score": "2", "CreationDate": "2011-04-21T21:26:19.830", "LastActivityDate": "2011-04-21T21:26:19.830"}, "5749892": {"CommentCount": "2", "ViewCount": "225", "PostTypeId": "1", "LastEditorUserId": "238671", "CreationDate": "2011-04-21T21:19:22.313", "LastActivityDate": "2011-04-21T22:26:34.343", "Title": "struct vector works", "AcceptedAnswerId": "5749947", "LastEditDate": "2011-04-21T21:27:40.483", "Id": "5749892", "Score": "2", "Body": "<p>I did a mistake in my program, I wrote</p>\n<pre><code>struct vector&lt;int&gt; v;\n</code></pre>\n<p>instead of</p>\n<pre><code>vector&lt;int&gt; v;\n</code></pre>\n<p>but it seems that the compiler doesn't care: <a href=\"http://codepad.org/TCPb8p2u\" rel=\"nofollow\">http://codepad.org/TCPb8p2u</a></p>\n<p>Why does it work? Is there some differencies with or without <code>struct</code>?</p>\n", "Tags": "<c++><struct>", "OwnerUserId": "238671", "AnswerCount": "3"}, "5749947": {"ParentId": "5749892", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If you write <code>class</code>, it would also work.</p>\n<pre><code>class vector&lt;int&gt; v;\n</code></pre>\n<p>See this: <a href=\"http://www.ideone.com/EoJxk\" rel=\"nofollow\">http://www.ideone.com/EoJxk</a></p>\n<p>This is actually old C style. The C++ Standard calls it <strong>elaborated-type-specifier</strong> in section \u00a73.4.4.</p>\n<p>The keyword <code>struct</code> (or <code>class</code>, <code>enum</code>) is sometimes used to <strong>remove</strong> ambiguities, or to make <strong>hidden</strong> names <em>visible</em> to the compiler. Consider the following example from the Standard itself (from section \u00a79.1/2). Please notice that there exists a <code>struct</code> with name <code>stat</code> and with exactly same also exists a <em>function</em>:</p>\n<pre><code>struct stat {\n    // ...\n};\nstat gstat; // use plain stat to define variable\n\nint stat(struct stat*); // redeclare stat as function\n\nvoid f()\n{\n    struct stat* ps; // struct prefix needed to name struct stat\n    // ...\n    stat(ps); //call stat()\n    // ...\n}\n</code></pre>\n<p>\u00a79.1/2 says,</p>\n<blockquote>\n<p id=\"so_5749892_5749947_0\">A class definition introduces the\n  class name into the scope where it is\n  defined and <strong>hides any class, object,\n  function, or other declaration of that\n  name in an enclosing scope (3.3)</strong>. If a\n  class name is declared in a scope\n  where an object, function, or\n  enumerator of the same name is also\n  declared, <strong>then when both declarations\n  are in scope, the class can be\n  referred to only using an\n  elaborated-type-specifier (3.4.4)</strong>.</p>\n</blockquote>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-04-21T21:50:33.257", "Id": "5749947", "Score": "6", "CreationDate": "2011-04-21T21:24:52.250", "LastActivityDate": "2011-04-21T21:50:33.257"}, "bq_ids": {"n4140": {"so_5749892_5749947_0": {"section_id": 5857, "quality": 0.8780487804878049, "length": 36}}, "n3337": {"so_5749892_5749947_0": {"section_id": 5627, "quality": 0.8780487804878049, "length": 36}}, "n4659": {"so_5749892_5749947_0": {"section_id": 7336, "quality": 0.8780487804878049, "length": 36}}}, "5750163": {"ParentId": "5749892", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The others have already explained it that what you uses is called <em>elaborated type specifier</em>, which can be used for name unhiding and ambiguity resolution.</p>\n<p>However, what also works here is one curious feature of C++ language, which states that <em>class-key</em> (i.e. <code>class</code> or <code>struct</code> keyword) used in class declaration is not required to agree with the <em>class-key</em> used in the elaborated type specifier. E.g. you can declare your class with <code>class</code> keyword and then later refer to it with <code>struct</code> keyword (and vice versa). There's no error in it</p>\n<pre><code>class S {};\n\nint main() {\n  struct S s; // OK, 's' has type `S` (i.e. `class S`)\n}\n</code></pre>\n<p>Standard <code>std::vector</code> template class is declared with keyword <code>class</code>, but there's no error in referring to it as <code>struct std::vector</code>, which is what you did in your example.</p>\n<p>And no, it makes no difference whether in your declaration of <code>v</code> you use <code>class</code>, <code>struct</code> or nothing at all.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2011-04-21T22:26:34.343", "Id": "5750163", "Score": "2", "CreationDate": "2011-04-21T21:51:08.713", "LastActivityDate": "2011-04-21T22:26:34.343"}});