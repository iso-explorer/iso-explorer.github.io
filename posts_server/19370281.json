post_cb({"19370281": {"CommentCount": "1", "ViewCount": "1172", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-10-14T22:25:00.283", "LastActivityDate": "2013-10-19T08:58:41.153", "Title": "error in derived class 'no type named my_data in <base class>'", "AcceptedAnswerId": "19372824", "LastEditDate": "2013-10-18T21:59:37.507", "Id": "19370281", "Score": "1", "Body": "<p>In my code I use a templated multi-dimensional container class <code>array_dyn&lt;T&gt;</code>, which has a property <code>my_data</code> that is a <code>std::vector&lt;T&gt;</code>. </p>\n<p>To keep things separable I use my own class <code>bisArray&lt;T&gt;</code> that inherits from <code>array_dyn</code>: </p>\n<pre><code>typedef array_dyn&lt;T&gt;                   super_type;\ntypedef typename super_type::index_t   index_t;\n\ntemplate &lt; typename Sizes &gt;\nbisArray( dirs a_dir, Sizes const&amp; a_sizes={} ): \n        super_type ( a_dir, a_sizes ),   super_type::my_data( super_type::size()) {}\ntemplate &lt; typename Sizes &gt;\nbisArray( Sizes const&amp; a_sizes={} ): \n        super_type ( dir_fwd, a_sizes ), super_type::my_data( super_type::size()) {}\n</code></pre>\n<p>Here, <code>dir_fwd</code> (and <code>dir_rev</code>) represents c (and fortran) storage order.\nThe array_dyn class is here [ <a href=\"https://svn.boost.org/svn/boost/sandbox/variadic_templates/sandbox/array_dyn\" rel=\"nofollow\">https://svn.boost.org/svn/boost/sandbox/variadic_templates/sandbox/array_dyn</a> ].</p>\n<p>Happy to provide more code, but I think the problem that I get is caused here: when I use </p>\n<pre><code>std::vector&lt;size_t&gt; newsizes({2,3});\nbisArray&lt;int&gt;       newarray(newsizes); // using constructor #2\n</code></pre>\n<p>Then there is an error message</p>\n<pre><code>no type named my_data in struct 'array_dyn&lt;int&gt;' \n</code></pre>\n<p>Previous StackOverflow posts about this error mentioned circular definitions and forward declarations; but that is not what I am doing here. I just inherit from <code>array_dyn</code>, which has a property <code>my_data</code>, but when I create an object with the derived class bisArray, it says that its base class does not have this property.</p>\n<p>Am I using the wrong inheritance mechanism? Or the wrong access method?</p>\n", "Tags": "<c++><inheritance><boost><constructor><composition>", "OwnerUserId": "1793968", "AnswerCount": "2"}, "19458944": {"ParentId": "19370281", "PostTypeId": "2", "CommentCount": "4", "Body": "<h2>You probably shouldn't be (ab)using inheritance...</h2>\n<p><strong>Question</strong>: why do you use inheritance for <code>bisArray&lt;T&gt;</code>? </p>\n<p>Is it to add extra functionality to <code>array_dyn&lt;T&gt;</code> that can entirely be written in the public interface of <code>array_dyn&lt;T&gt;</code>? In that case, add non-member functions to provide that functionality instead of inheriting and adding member functions. So instead of</p>\n<pre><code>template&lt;class T&gt;\nclass bisArray: public array_dyn&lt;T&gt;\n{\npublic:\n     void doCoolStuffThatBoostDoesNotProvide() const;\n};\n</code></pre>\n<p>write a <strong>non-member function</strong></p>\n<pre><code>template&lt;class T&gt;\nvoid doCoolStuffThatBoostDoesNotProvide(array_dyn&lt;T&gt; const&amp; s);\n</code></pre>\n<p>If you need to add functionality that requires extra state to a <code>array_dyn&lt;T&gt;</code>, use <strong>composition</strong></p>\n<pre><code>template&lt;class T&gt;\nclass bisArray\n{\npublic: \n     void doCoolStuffThatBoostCannotImplement() const;\nprivate:\n     some_fancy_type s_;\n     array_dyn&lt;T&gt; a_;\n};\n</code></pre>\n<p><code>array_dyn&lt;T&gt;</code> was never designed to be a base class. For one, it doesn't have a <strong>virtual destructor</strong>. Second, the designers of <code>array_dyn&lt;T&gt;</code> also composed a <code>std::vector&lt;T&gt;</code>, and did not inherit from it, for exactly those reasons. </p>\n<p>Of course, when using composition, <code>bisArray&lt;T&gt;</code> will have to redefine the entire interface (members and constructors) that it wants to keep. However, in the words of <a href=\"http://rads.stackoverflow.com/amzn/click/0321113586\" rel=\"nofollow\"><strong>Alexandrescu and Sutter</strong></a>:</p>\n<blockquote>\n<p id=\"so_19370281_19458944_0\">Admittedly, it's tedious to have to write passthrough functions for\n  the member functions you want to keep, but such an implementation is\n  vastly better and safer than using public or nonpublic inheritance.</p>\n</blockquote>\n<h2>... but use the base constructors if you do...</h2>\n<p>OK, you absolutely-positively-definitely want to use inheritance. Well that's easy: just delegate all work to the <code>array_dyn&lt;T&gt;</code> base class constructor:</p>\n<pre><code>template\n  &lt; typename Sizes\n  &gt;\narray_dyn( dirs a_dir, Sizes const&amp; a_sizes={})\n: super_t( a_dir, a_sizes)\n, my_data( super_t::size())\n{\n}\n</code></pre>\n<p>Your two requested constructors can then be gotten from your current version minus the initialization of <code>my_data</code> because the <code>array_dyn&lt;T&gt;</code> constructor already does the exact same amount of work </p>\n<pre><code>// note use explicit keyword for single-argument constructors\ntemplate&lt;typename Sizes&gt;\nexplicit bisArray( dirs a_dir, Sizes const&amp; a_sizes={} )\n: super_type(a_dir, a_sizes) \n{}\n\ntemplate &lt; typename Sizes &gt;\nbisArray( Sizes const&amp; a_sizes={} )\n: super_type(dir_fwd, a_sizes)\n{}     \n</code></pre>\n<p>In case you want to set <code>super_type::my_data</code> to another value than what the <code>super_type</code> constructor does, just put such a statement in the body of the constructor. But from the Boost code and your code alone that doesn't seem to be required here. </p>\n<h2>... or use factory functions to get the best of both worlds</h2>\n<p>Still, if all that <code>bisArray&lt;T&gt;</code> does is create a default constructor that takes the C-array style parameter <code>dir_fwd</code>, why not drop the inheritance, and write two non-member factory functions that return a <code>array_dyn&lt;T&gt;</code> with the corresponding constructor arguments</p>\n<pre><code>template&lt;typename T, typename Sizes&gt;\nmake_fortran_array_dyn(Sizes const&amp; a_sizes={} )\n{\n    return array_dyn&lt;T&gt;(dir_rev, a_sizes);\n}\n\ntemplate &lt;typename T, typename Sizes &gt;\nmake_c_array_dyn( Sizes const&amp; a_sizes={} )\n{\n     return array_dyn&lt;T&gt;(dir_fwd, a_sizes);\n}     \n</code></pre>\n<p>which you can call like this:</p>\n<pre><code>auto c = make_c_array_dyn&lt;double&gt;(your_sizes);\nauto f = make_fortran_array_dyn&lt;double&gt;(your_sizes);\n</code></pre>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-10-19T08:58:41.153", "Id": "19458944", "Score": "1", "CreationDate": "2013-10-18T20:58:38.110", "LastActivityDate": "2013-10-19T08:58:41.153"}, "19372824": {"ParentId": "19370281", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Short answer:\nYou can't initialize base class members in the constructor of a derived class.</p>\n<p>You may want to try something like this instead (assuming that my_data has a suitable setter method):</p>\n<pre><code>template &lt; typename Sizes &gt;\nbisArray( dirs a_dir, Sizes const&amp; a_sizes={} ): \n    super_type ( a_dir, a_sizes ) {\n    super_type::my_data.set_size( super_type::size());\n}\n</code></pre>\n<p>Longer version, the best explanation I could find from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow\">C++ standard</a> is in paragraph 12.6.1.10:</p>\n<blockquote>\n<p id=\"so_19370281_19372824_0\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<p id=\"so_19370281_19372824_1\">\u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-\ufb01rst left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-speci\ufb01er-list.</p>\n<p id=\"so_19370281_19372824_2\">\u2014 Then, direct base classes are initialized in declaration order as they appear in the base-speci\ufb01er-list (regardless of the order of the mem-initializers).</p>\n<p id=\"so_19370281_19372824_3\">\u2014 Then, non-static data members are initialized in the order they were declared in the class de\ufb01nition (again regardless of the order of the mem-initializers).</p>\n<p id=\"so_19370281_19372824_4\">\u2014 Finally, the compound-statement of the constructor body is executed</p>\n</blockquote>\n<p>Now, this may sound a bit round-about, but the constraint that non-static data members are initialized in the order in which they were declared in the class definition implies that you can't initialize base-class members in a derived class.</p>\n", "OwnerUserId": "2715219", "LastEditorUserId": "2715219", "LastEditDate": "2013-10-19T06:40:46.943", "Id": "19372824", "Score": "1", "CreationDate": "2013-10-15T03:29:54.943", "LastActivityDate": "2013-10-19T06:40:46.943"}, "bq_ids": {"n4140": {"so_19370281_19372824_3": {"section_id": 438, "quality": 0.9333333333333333, "length": 14}, "so_19370281_19372824_4": {"section_id": 438, "quality": 1.0, "length": 5}, "so_19370281_19372824_0": {"section_id": 438, "quality": 1.0, "length": 6}, "so_19370281_19372824_2": {"section_id": 438, "quality": 0.9230769230769231, "length": 12}, "so_19370281_19372824_1": {"section_id": 438, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_19370281_19372824_3": {"section_id": 429, "quality": 0.9333333333333333, "length": 14}, "so_19370281_19372824_4": {"section_id": 429, "quality": 1.0, "length": 5}, "so_19370281_19372824_0": {"section_id": 429, "quality": 1.0, "length": 6}, "so_19370281_19372824_2": {"section_id": 429, "quality": 0.9230769230769231, "length": 12}, "so_19370281_19372824_1": {"section_id": 429, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_19370281_19372824_3": {"section_id": 458, "quality": 0.9333333333333333, "length": 14}, "so_19370281_19372824_1": {"section_id": 458, "quality": 0.9310344827586207, "length": 27}, "so_19370281_19372824_0": {"section_id": 458, "quality": 1.0, "length": 6}, "so_19370281_19372824_2": {"section_id": 458, "quality": 0.9230769230769231, "length": 12}, "so_19370281_19372824_4": {"section_id": 458, "quality": 1.0, "length": 5}}}});