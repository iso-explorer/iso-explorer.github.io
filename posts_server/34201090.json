post_cb({"34201090": {"CommentCount": "3", "ViewCount": "123", "PostTypeId": "1", "LastEditorUserId": "3726169", "CreationDate": "2015-12-10T11:47:48.080", "LastActivityDate": "2015-12-10T14:23:38.060", "Title": "When does a non-member function template have internal linkage?", "AcceptedAnswerId": "34203040", "LastEditDate": "2015-12-10T14:23:38.060", "Id": "34201090", "Score": "3", "Body": "<p>C++11 draft, 14.0.4:</p>\n<blockquote>\n<p id=\"so_34201090_34201090_0\">A non-member function template can have internal linkage; any other\n  template name shall have external linkage.</p>\n</blockquote>\n<p>This query is a consequence of separating template declaration and definition. For example, we can write the following in a header file.</p>\n<pre><code>template &lt;typename T&gt;\nbool operator==(T const &amp; l, T const &amp; r);\n</code></pre>\n<p>In a single source file, destined to become a single translation unit, we write the definition. We also instantiate it, either implicitly or explicitly, in the same translation unit, for type <code>foo</code>.</p>\n<pre><code>template &lt;typename T&gt;\nbool operator==(T const &amp; l, T const &amp; r)\n{\n  return extract(l) == extract(r); // extract is uninteresting\n}\n</code></pre>\n<p>In a second translation unit, which can only see the definition from the header, we attempt to use <code>foo{} == foo{}</code>, that is, to call the <code>operator==</code> which is instantiated elsewhere.</p>\n<p>Currently, this \"works\". The linker patches the two translation units as I hoped it would.</p>\n<p>However, if the function template has internal linkage, the link can fail. For example, we can force this by instantiating within an anonymous namespace.</p>\n<p>Does the \"can\" in the spec indicate that the source code controls the linkage (e.g. by <code>namespace {}</code>) or that the compiler is permitted to choose whether the instantiation will have internal or external linkage?</p>\n<p>I don't believe there is any undefined behaviour here, but I am struggling to convince myself that the linkage chosen is not an implementation detail. Can I rely on the symbol being visible from other translation units, if it has been instantiated in at least one TU in a context that suggests it will be external?</p>\n<p>edit: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1603\" rel=\"nofollow\">DR1603</a> (thanks Eugene Zavidovsky!) contains a recommendation to erase exactly the sentence quoted above, alongside general rationalisation of linkage rules.</p>\n", "Tags": "<c++><templates><c++11><language-lawyer>", "OwnerUserId": "3726169", "AnswerCount": "1"}, "34203040": {"ParentId": "34201090", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_34201090_34203040_0\">Does the \"can\" in the spec indicate that the source code controls the linkage (e.g. by namespace {}) or that the compiler is permitted to choose whether the instantiation will have internal or external linkage?</p>\n</blockquote>\n<p>This is the code that controls the linkage. A function generated from function template has external linkage, unless it is a <code>static</code> function template or the template is in unnamed namespace (since C++11).</p>\n<p>In other words, one would have to explicitly ask for internal linkage.</p>\n", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "34203040", "Score": "4", "CreationDate": "2015-12-10T13:22:10.507", "LastActivityDate": "2015-12-10T13:22:10.507"}, "bq_ids": {"n4140": {"so_34201090_34201090_0": {"section_id": 51, "quality": 1.0, "length": 13}}, "n3337": {"so_34201090_34201090_0": {"section_id": 46, "quality": 1.0, "length": 13}}, "n4659": {"so_34201090_34201090_0": {"section_id": 52, "quality": 0.5384615384615384, "length": 7}}}});