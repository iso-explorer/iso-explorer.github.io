post_cb({"19955954": {"CommentCount": "6", "ViewCount": "309", "LastActivityDate": "2013-11-13T15:45:09.893", "Body": "<p>When trying out clang-3.4 (compiled from git), it failed to compile one of my projects complaining about ambiguity while resolving overloaded operators.\nI turned out that there were two templated operators, one of which was declared as a member function, other as a non-member one, which both seems equally good match.</p>\n<p>Following SSCCE demonstrates the situation:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct ostr {\n        std::ostream&amp; s;\n\n        template&lt;class T&gt;\n        ostr&amp; operator&lt;&lt;(const T&amp; x) { s &lt;&lt; x; return *this; }\n};\n\nstruct xy {\n        double x, y;\n};\n\ntemplate&lt;class Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; s, const xy&amp; x) {\n        s &lt;&lt; \"[\" &lt;&lt; x.x &lt;&lt; \", \" &lt;&lt; x.y &lt;&lt; \"]\";\n        return s;\n}\n\nint main() {\n        ostr os{std::cout};\n        xy x{4, 5};\n        os &lt;&lt; \"Value is: \" &lt;&lt; x &lt;&lt;\"\\n\";\n}\n</code></pre>\n<p>The project compiled fine before and I checked again this SSCCE with several compilers (<code>gcc 4.5</code>, <code>4.6</code>, <code>4.7</code>, <code>4.8</code> and <code>clang 3.3</code>) and all of them compiled it without any warning (with <code>-Wall -Wextra -pedantic</code>). All compilers were set to C++11/C++0x standard.\nAfter adding ctor to <code>ostr</code>, it compiled fine even on <code>MSVC 2012</code> and <code>2010</code>)</p>\n<p>Making both <code>operator&lt;&lt;</code>s non-member exhibits the ambiguity in all compilers (as expected)</p>\n<p>After looking through the standard drafts (<code>N3242</code> and <code>N3690</code>) I failed to find anything making member functions/operators better match than non-member ones. </p>\n<p>So I failed to prove <code>clang-3.4</code> is wrong and I wonder who's right.\nThus my question is:</p>\n<ul>\n<li>Is this code valid? Should member operators/functions be better match than non-member ones and it's a bug in clang-3.4? </li>\n<li>Or are all the other compilers wrong/too permissive?</li>\n</ul>\n<p><em>I am aware that changing the second <code>operator&lt;&lt;</code> to non-templated function (with <code>std::ostream</code> instead of template parameter) would resolve the the ambiguity and work as expected, but that's not the point here.</em></p>\n", "PostTypeId": "1", "AcceptedAnswerId": "19958120", "FavoriteCount": "3", "Title": "Templated operator overload resolution, member vs non-member function", "Id": "19955954", "Score": "6", "CreationDate": "2013-11-13T14:11:49.350", "Tags": "<c++><templates><clang++>", "OwnerUserId": "1259400", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19955954_19958120_2": {"section_id": 568, "quality": 1.0, "length": 6}, "so_19955954_19958120_1": {"section_id": 568, "quality": 0.875, "length": 7}, "so_19955954_19958120_0": {"section_id": 566, "quality": 0.9459459459459459, "length": 35}, "so_19955954_19958120_3": {"section_id": 568, "quality": 1.0, "length": 5}, "so_19955954_19958120_4": {"section_id": 568, "quality": 1.0, "length": 8}}, "n3337": {"so_19955954_19958120_2": {"section_id": 559, "quality": 1.0, "length": 6}, "so_19955954_19958120_1": {"section_id": 559, "quality": 0.875, "length": 7}, "so_19955954_19958120_0": {"section_id": 557, "quality": 0.9459459459459459, "length": 35}, "so_19955954_19958120_3": {"section_id": 559, "quality": 1.0, "length": 5}, "so_19955954_19958120_4": {"section_id": 559, "quality": 1.0, "length": 8}}, "n4659": {"so_19955954_19958120_2": {"section_id": 591, "quality": 1.0, "length": 6}, "so_19955954_19958120_1": {"section_id": 591, "quality": 0.875, "length": 7}, "so_19955954_19958120_0": {"section_id": 589, "quality": 0.9459459459459459, "length": 35}, "so_19955954_19958120_3": {"section_id": 591, "quality": 1.0, "length": 5}, "so_19955954_19958120_4": {"section_id": 591, "quality": 1.0, "length": 8}}}, "19958120": {"ParentId": "19955954", "CommentCount": "2", "Body": "<p>Overload resolution adds an additional parameter to a member function just for the purpose of overload resolution:</p>\n<p>[over.match.funcs]/2</p>\n<blockquote>\n<p id=\"so_19955954_19958120_0\">The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list. So that argument and parameter lists are comparable within this heterogeneous set, a member function is considered to have an extra parameter, called the <em>implicit object parameter</em>, which represents the object for which the member function has been called.</p>\n</blockquote>\n<p>/4</p>\n<blockquote>\n<p id=\"so_19955954_19958120_1\">For non-static member functions, the type of the implicit object parameter is</p>\n<p id=\"so_19955954_19958120_2\">\u2014 \u201clvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared without a <em>ref-qualifier</em> or with the <code>&amp;</code> <em>ref-qualifier</em></p>\n<p id=\"so_19955954_19958120_3\">\u2014 \u201crvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared with the <code>&amp;&amp;</code> <em>ref-qualifier</em></p>\n<p id=\"so_19955954_19958120_4\">where <code>X</code> is the class of which the function is a member and <em>cv</em> is the <em>cv</em>-qualification on the member function declaration.</p>\n</blockquote>\n<p>Some special rules follow, for example to allow binding an rvalue to this implicit object parameter (for calling member functions w/o ref-qualifier on rvalues, e.g. <code>ostr{std::cout}&lt;&lt;\"hello\"</code>).</p>\n<hr>\n<p>The function signatures <em>including</em> the implicit object parameter we need to compare for overload resolution are:</p>\n<pre><code>template&lt;class T&gt;\nostr&amp; ostr::operator&lt;&lt;(ostr&amp;, const T&amp;);    // F1\n\ntemplate&lt;class Stream&gt;\nStream&amp; ::operator&lt;&lt;(Stream&amp;, const xy&amp;);    // F2\n</code></pre>\n<p>After substitution for <code>os &lt;&lt; x</code>, we get the <em>same</em> signature:</p>\n<pre><code>ostr&amp; ostr::operator&lt;&lt;(ostr&amp;, const xy&amp;);\nostr&amp; ::    operator&lt;&lt;(ostr&amp;, const xy&amp;);\n</code></pre>\n<p>So only one of the \"tie-breakers\" in [over.match.best]/1 could resolve the ambiguity. Indeed, one could apply, namely the \"<code>F1</code> is more specialized than <code>F2</code>\" (or vice versa): partial ordering of function templates.</p>\n<p>N.B. The procedure of adding an implicit object parameter is specified <em>again</em> in the description of partial ordering [temp.func.order]/3.</p>\n<hr>\n<p>For partial ordering of <code>F1</code> and <code>F2</code> (as defined above), we first create two unique types:</p>\n<pre><code>struct unique_T {};\nstruct unique_Stream {};\n</code></pre>\n<p>Then we transform <code>F1</code> into <code>F1'</code> by replacing the template parameter <code>T</code> with the unique type <code>unique_T</code> (and similarly for <code>F2</code>):</p>\n<pre><code>ostr&amp; ostr::operator&lt;&lt;(ostr&amp;, const unique_T&amp;);\nostr&amp; ::    operator&lt;&lt;(unique_Stream&amp;, const xy&amp;);\n</code></pre>\n<p>The parameters of the transformed function <code>F1'</code> are now used to try to deduce the template parameters of the untransformed <code>F2</code>:</p>\n<pre><code>ostr a0;\nunique_T a1; // no reference, no cv-qualifier\n::operator&lt;&lt;(a0, a1) // does template argument deduction succeed?\n\n// reminder: signature of ::operator&lt;&lt;\ntemplate&lt;class Stream&gt;\nStream&amp; ::operator&lt;&lt;(Stream&amp;, const xy&amp;);\n</code></pre>\n<p>The deduction succeeds for <code>a0</code> [with <code>Stream</code> = <code>ostr</code>], therefore the type <code>ostr&amp;</code> from <code>F1</code> is considered to be at least as specialized as type of the corresponding first parameter of <code>F2</code> (<code>Stream&amp;</code>, with <code>Stream</code> being a template parameter). I'm not sure what happens to the second argument <code>a1</code>, since no deduction takes place for the second parameter of <code>::operator&lt;&lt;</code> (it is of type <code>const xy&amp;</code>).</p>\n<p>Now we repeat the process with arguments from <code>F2'</code> and try to deduce the template parameters of <code>F1</code>:</p>\n<pre><code>unique_Stream a0;\nxy a1;\nostr::operator&lt;&lt;(a0, a1);\n\n// reminder: signature of ostr::operator&lt;&lt;\ntemplate&lt;class T&gt;\nostr&amp; ostr::operator&lt;&lt;(ostr&amp;, const T&amp;);\n</code></pre>\n<p>Here, no deduction occurs for the first argument, but it occurs and succeeds for the second argument [with <code>T</code> = <code>xy</code>].</p>\n<p>I conclude no function template is more specialized. Therefore overload resolution <em>should fail</em> due to ambiguity.</p>\n</hr></hr>", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "19958120", "Score": "2", "CreationDate": "2013-11-13T15:45:09.893", "LastActivityDate": "2013-11-13T15:45:09.893"}});