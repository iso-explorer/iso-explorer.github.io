post_cb({"17239040": {"ParentId": "17238906", "CommentCount": "0", "CreationDate": "2013-06-21T15:31:23.843", "OwnerUserId": "1204348", "PostTypeId": "2", "Id": "17239040", "Score": "1", "Body": "<p>You may want to have a look at <a href=\"http://en.cppreference.com/w/cpp/algorithm/generate\" rel=\"nofollow\">std::generate</a> combined with an appropriate generator functor. Your generator can do the hard work of initializing the data you want, keeping your class's interface relatively clean (you may need to have your generator as a friend of your class if you want to keep things private).</p>\n", "LastActivityDate": "2013-06-21T15:31:23.843"}, "17239223": {"ParentId": "17238906", "CommentCount": "0", "CreationDate": "2013-06-21T15:41:53.520", "OwnerUserId": "814628", "PostTypeId": "2", "Id": "17239223", "Score": "2", "Body": "<p>Would you be ok with making user have to initialize it?</p>\n<pre><code>struct Base{\n std::vector&lt;int&gt; data;\n int minDefaultSize;\n Base(const int defaultSize = 50): minDefaultSize(defaultSize), data(std::vector&lt;int&gt;(defaultSize,0))  {\n }\n virtual void initialize(){ \n   for(int i = 0; i &lt; data.size(); ++i){ data[i] = i; }\n }\n ~virtual Base(){};\n};\n\nstruct D1: Base{\n D1(): Base(100){}\n virtual void initialize(){ \n   for(int i = 0; i &lt; data.size(); ++i){ data[i] = i*i; }\n }\n};\n\nstd::shared_ptr&lt;Base&gt; createIt(const int type){\n type % 2 == 0 ? return std::shared_ptr&lt;Base&gt;(new Base()) : return std::shared_ptr&lt;Base&gt;(new D1());\n}\nint main(){\n std::vector&lt; std::shared_ptr&lt;Base&gt; &gt; polyType;\n for(int i = 0; i &lt; 5; ++i){ \n  polyType.push_back(createIt(i) ); \n  polyType.back()-&gt;initialize();\n }\n}\n</code></pre>\n", "LastActivityDate": "2013-06-21T15:41:53.520"}, "17238906": {"CommentCount": "5", "ViewCount": "104", "PostTypeId": "1", "LastEditorUserId": "1790399", "CreationDate": "2013-06-21T15:24:30.600", "LastActivityDate": "2013-06-23T21:46:57.457", "Title": "C++ Would using an \"initializer\" class inside a constructor be appropriate/sensible?", "LastEditDate": "2013-06-23T21:46:57.457", "Id": "17238906", "Score": "0", "Body": "<p>I have a class that has several derived classes, each with their own constructor.</p>\n<pre><code>class A\n    {\n    public:\n       static A *create_new_A(int child_ID);\n\n       member_data;\n       void method();\n    };\n\nclass A_child_0 : public A\n    {\n    A_child_0(int child_ID);\n    //stuff\n    };\n\nclass A_child_1 : public A\n    {\n    A_child_1(int child_ID);\n    //stuff\n    };\n    etc...\n</code></pre>\n<p>and in the main file these get called with something like:</p>\n<pre><code>A **array;\narray = new A *[nchildren];\nfor (int i = 0 ; i &lt; nchildren ; i++) \n    {\n    array[i] = A-&gt;create_new_A( i );\n    }\n</code></pre>\n<p>where A is a factory that looks something like:</p>\n<pre><code>A* A::create_new_A(int child_ID)\n   {\n   if (child_ID == 0) \n       {\n       return new A_child_0(child_ID);\n       }\n   if (child_ID == 1)\n       {\n       return new A_child_1(child_ID);\n       }  \n   }\n</code></pre>\n<p>Now when the constructor to A_child_n is called, right now I have a bunch of procedural commands inside the initialization for the member_data values that differ slightly among derived classes, e.g.,</p>\n<pre><code>A_child_0(int child_ID)\n    {\n    member_data.vector1[0] = 0;\n    for (i = 0; i &lt; 200; i++)\n         member_data.vector2[0] = i;\n    read_in_conf_file(\"conf.txt\") \n    // etc....\n    }\n\nA_child_1(int child_ID)\n    {\n    member_data.vector1[0] = 0;\n    for (i = 0; i &lt; 50; i++)\n      member_data.vector2[0] = i*i;\n    read_in_conf_file(\"conf.txt\") \n     // etc....\n    }\n</code></pre>\n<p>What I am curious about is whether there is a better way to go about this. Right now I'm thinking of encapsulating a lot of these procudral steps so it reads like </p>\n<pre><code>A_child_0(int child_ID)\n    {\n    initializer_class *intializer;\n    initializer-&gt;initialize(child_ID);\n    }\n\nA_child_1(int child_ID)\n   {\n   initializer_class *intializer;\n   initializer-&gt;initialize(child_ID);\n   }\n</code></pre>\n<p>and have a class initializer() that implements the initialization steps for the different classes. I guess this is loosely inspired by the strategy pattern. Does anybody have any suggestions on whether this approach is appropriate or sensible? Or does it just relegate the problem to the initializer class and introduce an added layer of complexity. If doing something like this is a bad idea, what could be done to try to avoid having the constructor be one long C program?</p>\n<p>edit: as some pointed out the factory was specified incorrectly. It's still not really polished in the example I give but it isn't as off the mark as what was there before.</p>\n", "Tags": "<c++><constructor><initialization>", "OwnerUserId": "1790399", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_17238906_17239100_0": {"section_id": 373, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_17238906_17239100_0": {"section_id": 364, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_17238906_17239100_0": {"section_id": 387, "quality": 0.5882352941176471, "length": 10}}}, "17239100": {"ParentId": "17238906", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-06-21T15:33:59.087", "Score": "0", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:05:38.443", "Id": "17239100", "OwnerUserId": "951423", "Body": "<p>The standard says your current \"solution\" is ill-formed:</p>\n<blockquote>\n<h3>ISO IEC 14882:2011, \u00a712.1/10</h3>\n<p id=\"so_17238906_17239100_0\">No return type (not even void) shall be specified for a constructor. A return statement in the body of a constructor shall not specify a return value. The address of a constructor shall not be taken.</p>\n</blockquote>\n<p>You want to have another factory pattern.</p>\n<p>Perhaps you can use something from here: <a href=\"https://stackoverflow.com/questions/333400/how-to-design-a-simple-c-object-factory\">How to design a simple C++ object factory?</a></p>\n", "LastActivityDate": "2013-06-21T15:33:59.087"}});