post_cb({"28912679": {"CommentCount": "2", "ViewCount": "119", "PostTypeId": "1", "LastEditorUserId": "4643522", "CreationDate": "2015-03-07T07:56:16.700", "LastActivityDate": "2015-03-07T08:49:42.870", "Title": "Why do MSVC optimizations break SSE code when function arguments are const refs to temporaries or temporaries copied by value?", "AcceptedAnswerId": "28913072", "LastEditDate": "2015-03-07T08:31:21.740", "Id": "28912679", "Score": "-1", "Body": "<p>Ran into this yesterday, I will try to give clear and simple examples which fail for me with <strong>MSVC12 (VS2013, 120)</strong> and <strong>MSVC14 (VS2015, 140)</strong>. <strong>Everything is implicitly /arch:SSE+ with x64.</strong></p>\n<p><em>I will trivialize the issue to a simple matrix transpose example using defined macros _MM_TRANSPOSE4_PS for illustration purposes. This one is implemented in terms of shuffles, rather than moving L/H 8 byte blocks around.</em></p>\n<pre><code>float4x4 Transpose(const float4x4&amp; m) {\n\n    matrix4x4 n = LoadMatrix(m);\n    _MM_TRANSPOSE4_PS(n.row[0], n.row[1], n.row[2], n.row[3]);\n    return StoreMatrix(n);\n\n}\n</code></pre>\n<p>The <code>matrix4x4</code> is merely a POD struct containing four <code>__m128</code> members, everything is tidily aligned on a 16-byte boundary, even though it is somewhat implicit:</p>\n<pre><code>__declspec(align(16)) struct matrix4x4 {\n\n    __m128 row[4];\n\n};\n</code></pre>\n<p>All of this fails on /O1, /O2 and /Ox:</p>\n<pre><code>// Doesn't work.\nfloat4x4 resultsPlx = Transpose( GiveMeATemporary() );\n\n// Changing Transpose to take float4x4, or copy a temporary\nfloat4x4 Transpose(float4x4 m) { ... }\n\n// Trying again, doesn't work.\nfloat4x4 resultsPlx = Transpose( GiveMeATemporary() );\n</code></pre>\n<p>Curiously enough, this works:</p>\n<pre><code>// A constant reference to an rvalue, a temporary\nconst float4x4&amp; temporary = GiveMeATemporary();\nfloat4x4 resultsPlx = Transpose(temporary);\n</code></pre>\n<p>Same goes for pointer-based transfers, which is logical as the underlying mechanisms are the same. The relevant part of the C++11 specification is \u00a712.2/5:</p>\n<blockquote>\n<p id=\"so_28912679_28912679_0\">The second context is when a reference is bound to a temporary. The\n  temporary to which the reference is bound or the temporary that is the\n  complete object to a subobject of which the temporary is bound\n  persists for the lifetime of the reference except as specified below.\n  A temporary bound to a reference member in a constructor\u2019s\n  ctor-initializer (\u00a712.6.2 [class.base.init]) persists until the\n  constructor exits. <strong>A temporary bound to a reference parameter in a\n  function call (\u00a75.2.2 [expr.call]) persists until the completion of\n  the full expression containing the call.</strong></p>\n</blockquote>\n<p>This implies it should survive until the calling environment goes out of scope, which is far after the function returns. So, what gives? In all other cases, the variables get \"optimized away\", with the following exception:</p>\n<pre><code>Access violation reading location 0xFFFFFFFFFFFFFFFF\n</code></pre>\n<p>While the solution is obvious, prevent the user from passing temporaries directly with pointer-based transfers like some other libraries, I had hoped to actually make it a little bit more elegant without &amp;s clogging the view.</p>\n", "Tags": "<c++><c++11><visual-c++><sse><msvc12>", "OwnerUserId": "4643522", "AnswerCount": "1"}, "28913072": {"ParentId": "28912679", "CommentCount": "3", "CreationDate": "2015-03-07T08:49:42.870", "OwnerUserId": "658087", "PostTypeId": "2", "Id": "28913072", "Score": "0", "Body": "<p>You can add (non-virtual) member functions to a struct without really affecting the layout. So add destructor to print \"I'm here %p\" when the structure is destroyed, and print \"I'm there\" in your function. (Include the this address you you can make sense of other temporary copies being used).</p>\n<p>Then you can observe the lifetime in the optimized code.  See if that is your problem: I am suspicious that bad lifetime actually means anything because the place it was is still valid address in your stack frame.</p>\n<p>Furthermore, changing the bits where a floatnis supposed to live might at worst give you a not-a-number or special value, and the vector processing does not throw or fault in that case, but puts a flag value as the result for that bad element.  <em>There is no pointer</em>, so why is it dereferencing \u22121 ?</p>\n<p>I think the misfire is caused by something more interesting.</p>\n<p>Run it in the debugger and see what instruction causes that.</p>\n", "LastActivityDate": "2015-03-07T08:49:42.870"}, "bq_ids": {"n4140": {"so_28912679_28912679_0": {"section_id": 382, "quality": 0.8, "length": 40}}, "n3337": {"so_28912679_28912679_0": {"section_id": 373, "quality": 0.8, "length": 40}}, "n4659": {"so_28912679_28912679_0": {"section_id": 397, "quality": 0.58, "length": 29}}}});