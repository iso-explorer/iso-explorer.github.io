post_cb({"39025342": {"CommentCount": "5", "AcceptedAnswerId": "39025722", "PostTypeId": "1", "LastEditorUserId": "5769463", "CreationDate": "2016-08-18T18:39:52.723", "LastActivityDate": "2017-08-08T14:09:37.423", "LastEditDate": "2016-09-08T07:01:50.847", "ViewCount": "728", "FavoriteCount": "8", "Title": "Lifetime of temporary objects during list-initialization", "Id": "39025342", "Score": "38", "Body": "<p>I always assumed, that temporary objects live until the end of a full-expression. Here is however a curious difference between initializations  of a <code>std::vector</code> and an array.</p>\n<p>Please consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct ID{ \n  static int cnt;\n  // the number of living object of class ID at the moment of creation:  \n  int id;\n\n  ID():id(++cnt){}\n\n  ~ID(){\n     cnt--;\n  }\n};\n\nint ID::cnt=0;\n\nint main(){\n\n  int arr[]{ID().id, ID().id};\n  std::vector&lt;int&gt; vec{ID().id, ID().id};\n\n  std::cout&lt;&lt;\" Array: \"&lt;&lt;arr[0]&lt;&lt;\", \"&lt;&lt;arr[1]&lt;&lt;\"\\n\";\n  std::cout&lt;&lt;\" Vector: \"&lt;&lt;vec[0]&lt;&lt;\", \"&lt;&lt;vec[1]&lt;&lt;\"\\n\";\n}\n</code></pre>\n<p>The output of this program is a little bit (at least for me) unexpected:</p>\n<pre><code> Array: 1, 1\n Vector: 1, 2\n</code></pre>\n<p>That means, the temporary objects are alive during the whole initialization of the <code>std::vector</code> but they are created and destructed one after each other in the case of an array. I would expect the temporaries to live until the full-expression <code>int arr[]{ID().id, ID().id};</code> is completed.</p>\n<p>The standard mentions one exception concerning the lifetime of temporary objects and initialization of arrays (12.2). However I don't get its meaning and don't know why it is applied in this particular case:</p>\n<blockquote>\n<p id=\"so_39025342_39025342_0\">There are two contexts in which temporaries are destroyed at a\n  different point than the end of the full-expression. The first context\n  is when a default constructor is called to initialize an element of an\n  array. If the constructor has one or more default arguments, the\n  destruction of every temporary created in a default argument is\n  sequenced before the construction of the next array element, if any.</p>\n</blockquote>\n<hr>\n<p>Overview of the results with different compilers (MSVS result is a curtesy of NathanOliver):</p>\n<pre><code>             Array    Vector\nclang 3.8    1, 2      1, 2\ng++ 6.1      1, 1      1, 2\nicpc 16      1, 1      1, 2\nMSVS 2015    1, 1      1, 2\n</code></pre>\n<hr>\n<p>As ecatmur pointed out, for aggregate initialization every element of the braced-init-list is a full-expression, thus the following code </p>\n<pre><code>  struct S{\n      int a;\n      int b;\n  } s{ID().id, ID().id};\n  std::cout&lt;&lt;\" Struct: \"&lt;&lt;s.a&lt;&lt;\", \"&lt;&lt;s.b&lt;&lt;\"\\n\";\n</code></pre>\n<p>should print <code>Struct 1, 1</code> to the console. That is exactly what the program compiled by g++ does. However, clang seems to have a bug - the resulting program prints <code>Struct 1, 2</code>.</p>\n<hr>\n<p>A bug has been reported to clang: <a href=\"https://llvm.org/bugs/show_bug.cgi?id=29080\" rel=\"nofollow\">https://llvm.org/bugs/show_bug.cgi?id=29080</a></p>\n</hr></hr></hr>", "Tags": "<c++><c++11><g++><clang>", "OwnerUserId": "5769463", "AnswerCount": "1"}, "39025722": {"ParentId": "39025342", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>This is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1343\" rel=\"nofollow noreferrer\">core issue 1343 \"Sequencing of non-class initialization\"</a>, which was accepted as a Defect Report in November 2016 by paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0507r0.html\" rel=\"nofollow noreferrer\">P0570R0</a>.  The resolution proposed is part of C++17 but not therefore part of C++14, so (unless the committee decide to publish a corrigendum to C++14) this is a point of difference between C++17 and C++14. </p>\n<h2>C++14</h2>\n<p>The correct output according to the rules of the C++14 Standard is <code>1, 1</code> for the array and <code>1, 2</code> for the vector; this is because constructing a vector (including from a <em>braced-init-list</em>) requires a call to a constructor while constructing an array does not.</p>\n<p>The language that governs this is in <strong>[intro.execution]</strong>:</p>\n<blockquote>\n<p id=\"so_39025342_39025722_0\">10 - A <em>full-expression</em> is an expression that is not a subexpression of another expression. [...] If a language construct is defined to produce an implicit call of a function, a use of the language construct is considered to be an expression for the purposes of this definition. [...]</p>\n</blockquote>\n<p>This is fine as a top-level overview, but it leaves unanswered some questions:</p>\n<ul>\n<li>Precisely <em>which</em> language construct counts as the construct producing an implicit call of a function;</li>\n<li>What actually counts as an implicit call of a function; presumably a call to a user-defined constructor is a call of a function, but what about a constructor that is defaulted or defined as defaulted?</li>\n</ul>\n<p>An array is an aggregate so is initialized from a <em>braced-init-list</em> according to <strong>[dcl.init.aggr]</strong>; this says that each element is initialized directly from the corresponding element of the list, so there is no implicit function call (at least not corresponding to the overall initialization). At a syntax level, within an <em>initializer</em> (<strong>[dcl.init]</strong>/1) using a <em>braced-init-list</em> as the <em>brace-or-equal-initializer</em>, the full-expressions are the expressions contained within braces and separated by commas. At the end of each full-expression, the destructors of temporaries are required to run as none of the three contexts mentioned in <strong>[class.temporary]</strong> are the case here.</p>\n<p>The case for the initialization of a vector is different, since you are using the <code>initializer_list</code> constructor, so an implicit call of a function (i.e. the <code>initializer_list</code> constructor) occurs; this means that there is an implicit full-expression surrounding the whole initialization, so the temporaries are destroyed only when the initialization of the vector completes.</p>\n<p>Confusingly, <strong>[dcl.init.list]</strong> says that your code is \"roughly equivalent\" to:</p>\n<pre><code>const int __a[2] = {int{ID().id}, int{ID().id}};  // #1\nstd::vector&lt;int&gt; vec(std::initializer_list&lt;int&gt;(__a, __a + 2));\n</code></pre>\n<p>However, this has to be read in context - for example, the array backing the <code>initializer_list</code> has lifetime bounded by the initialization of the vector.</p>\n<p>This was a lot clearer in C++03, which had in <strong>[intro.execution]</strong>:</p>\n<blockquote>\n<p id=\"so_39025342_39025722_1\">13 - [<em>Note:</em> certain contexts in C++ cause the evaluation of a <em>full-expression</em> that results from a syntactic construct\n  other than <em>expression</em> (5.18). For example, in 8.5 one syntax for <em>initializer</em> is\n  <code>( expression-list )</code>\n  but the resulting construct is a function call upon a constructor function with <em>expression-list</em> as an argument\n  list; such a function call is a full-expression. For example, in 8.5, another syntax for <em>initializer</em> is\n  <code>= initializer-clause</code>\n  but again the resulting construct might be a function call upon a constructor function with one <em>assignment-expression</em>\n  as an argument; again, the function call is a full-expression. ]</p>\n</blockquote>\n<p>This paragraph is struck in its entirety from C++11; this was per the resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#392\" rel=\"nofollow noreferrer\">CWG 392</a>. The resulting confusion was presumably not intended.</p>\n<h2>C++17</h2>\n<p>After P0570R0, <strong>[intro.execution]</strong> states that a <em>full-expression</em> is: [...]</p>\n<blockquote id=\"so_39025342_39025722_2\">\n<ul>\n<li>an <em>init-declarator</em> ([dcl.decl]) [...] including the constituent expressions of the initializer, or [...]</li>\n<li>an expression that is not a subexpression of another expression and that is not otherwise part of a full-expression.</li>\n</ul>\n</blockquote>\n<p>So in C++17, the full-expression is <code>arr[]{ID().id, ID().id}</code> and <code>vec{ID().id, ID().id}</code> respectively, and the correct output is <code>1, 2</code> in each case, since the destruction of the first temporary <code>ID</code> is deferred to the end of the full-expression.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2017-08-08T14:09:37.423", "Id": "39025722", "Score": "16", "CreationDate": "2016-08-18T19:03:54.467", "LastActivityDate": "2017-08-08T14:09:37.423"}, "bq_ids": {"n4140": {"so_39025342_39025722_0": {"section_id": 5806, "quality": 0.9444444444444444, "length": 17}, "so_39025342_39025342_0": {"section_id": 381, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_39025342_39025722_0": {"section_id": 5579, "quality": 0.9444444444444444, "length": 17}, "so_39025342_39025342_0": {"section_id": 372, "quality": 0.972972972972973, "length": 36}}, "n4659": {"so_39025342_39025722_2": {"section_id": 7267, "quality": 0.9230769230769231, "length": 12}, "so_39025342_39025722_0": {"section_id": 7267, "quality": 0.9444444444444444, "length": 17}, "so_39025342_39025342_0": {"section_id": 396, "quality": 0.9459459459459459, "length": 35}}}});