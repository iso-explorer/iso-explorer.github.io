post_cb({"5559932": {"ParentId": "5559525", "CommentCount": "4", "Body": "<p>There's an irritating logic problem in your code:</p>\n<p>The new expression:</p>\n<pre><code>T* a = new(100, T(7)) T[0];\n</code></pre>\n<p>Calls T's deleted default constructor [expr.new]/17. ;-(</p>\n<p><code>std::vector&lt;T&gt;</code> is sure looking good about now... :-)</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "5559932", "Score": "3", "CreationDate": "2011-04-05T23:47:03.490", "LastActivityDate": "2011-04-05T23:47:03.490"}, "5559525": {"CommentCount": "4", "AcceptedAnswerId": "5559932", "CreationDate": "2011-04-05T22:54:58.443", "LastActivityDate": "2011-04-05T23:47:03.490", "PostTypeId": "1", "ViewCount": "178", "FavoriteCount": "0", "Title": "would the pointer returned by new(size, value) Type[0] be legal and could it be used to build an array?", "Id": "5559525", "Score": "1", "Body": "<p>The standard says, in <code>5.3.4[expr.new]/7</code></p>\n<blockquote>\n<p id=\"so_5559525_5559525_0\">When the value of the expression in a direct-new-declarator is zero, the allocation function is called to allocate an array with no elements.</p>\n</blockquote>\n<p>and in <code>3.7.3.1[basic.stc.dynamic.allocation]/2</code></p>\n<blockquote>\n<p id=\"so_5559525_5559525_1\">The effect of dereferencing a pointer returned as a request for zero size is undefined.</p>\n</blockquote>\n<p>But if the allocation function is user-defined and it knows it returned a valid pointer, would it still be undefined behavior to dereference it? Can the standard mandate undefined behavior of user code?</p>\n<p>The reason I ask is yet another meaningless attempt to initialize a dynamic array of objects of non-default-constructible type. What problems does it have, besides the obvious lack of <code>delete[]</code> and that it can only be called with <code>[0]</code>? Did I even use <code>aligned_storage</code> correctly?</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;stdexcept&gt;\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nstruct T {\n   int val;\n   T() = delete;\n   T(int i) : val(i) {}\n   void* operator new[](std::size_t, std::size_t cnt, const T&amp; t)\n   {\n       typedef std::aligned_storage&lt;sizeof(t),\n                    std::alignment_of&lt;T&gt;::value&gt;::type buf;\n       T* ptr = reinterpret_cast&lt;T*&gt;(new buf[cnt]);\n       std::uninitialized_fill_n(ptr, cnt, t);\n       return ptr;\n    }\n};\n\nint main()\n{\n    T* a = new(100, T(7)) T[0]; // using zero is legal per 5.3.4/7\n\n    std::cout &lt;&lt; \"a[0] = \" &lt;&lt; a[0].val &lt;&lt; '\\n' // but is this legal?\n              &lt;&lt; \"a[1] = \" &lt;&lt; a[1].val &lt;&lt; '\\n'\n              &lt;&lt; \"a[98] = \" &lt;&lt; a[98].val &lt;&lt; '\\n'\n              &lt;&lt; \"a[99] = \" &lt;&lt; a[99].val &lt;&lt; '\\n';\n    delete[] a; // free the 100 aligned_storages\n}\n</code></pre>\n<p>test run: <a href=\"http://ideone.com/iBW0z\" rel=\"nofollow\">http://ideone.com/iBW0z</a></p>\n<p>also compiles and runs as expected with  with MSVC++ 2010 EE</p>\n", "Tags": "<c++><c++11><standards-compliance><array-initialization>", "OwnerUserId": "273767", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5559525_5559525_0": {"section_id": 6088, "quality": 0.7272727272727273, "length": 8}, "so_5559525_5559525_1": {"section_id": 7177, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_5559525_5559525_0": {"section_id": 5856, "quality": 0.9090909090909091, "length": 10}, "so_5559525_5559525_1": {"section_id": 6921, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_5559525_5559525_0": {"section_id": 7584, "quality": 0.7272727272727273, "length": 8}, "so_5559525_5559525_1": {"section_id": 8685, "quality": 0.7777777777777778, "length": 7}}}, "5559770": {"ParentId": "5559525", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The only non-undefined behavior of the use of the result of a <code>reinterpret_cast</code> is when the cast is back to its original type, so you already have UB there even if everything else was ok.</p>\n<p>If you really need this, why don't you just make a function that allocates a large enough block of contiguous memory and then placement <code>new</code>s a bunch of <code>T</code> into that memory?</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2011-04-05T23:35:46.643", "Id": "5559770", "Score": "1", "CreationDate": "2011-04-05T23:25:59.620", "LastActivityDate": "2011-04-05T23:35:46.643"}});