post_cb({"71436": {"CommentCount": "0", "CreationDate": "2008-09-16T11:39:27.563", "LastEditorUserId": "10682", "LastActivityDate": "2008-09-16T12:03:40.953", "ParentId": "71416", "PostTypeId": "2", "LastEditorDisplayName": "Alexey Feldgendler", "LastEditDate": "2008-09-16T12:03:40.953", "Id": "71436", "Score": "7", "Body": "<p>There is indeed no such thing as a forward declaration of enum. As an enum's definition doesn't contain any code that could depend on other code using the enum, it's usually not a problem to define the enum completely when you're first declaring it.</p>\n<p>If the only use of your enum is by private member functions, you can implement encapsulation by having the enum itself as a private member of that class. The enum still has to be fully defined at the point of declaration, that is, within the class definition. However, this is not a bigger problem as declaring private member functions there, and is not a worse exposal of implementation internals than that.</p>\n<p>If you need a deeper degree of concealment for your implementation details, you can break it into an abstract interface, only consisting of pure virtual functions, and a concrete, completely concealed, class implementing (inheriting) the interface. Creation of class instances can be handled by a factory or a static member function of the interface. That way, even the real class name, let alone its private functions, won't be exposed.</p>\n", "OwnerUserId": "10682", "OwnerDisplayName": "Alexey Feldgendler"}, "78426": {"ParentId": "71416", "CommentCount": "0", "Body": "<p>My solution to your problem would be to either:</p>\n<p>1 - use int instead of enums: Declare your ints in an anonymous namespace in your CPP file (not in the header):</p>\n<pre><code>namespace\n{\n   const int FUNCTIONALITY_NORMAL = 0 ;\n   const int FUNCTIONALITY_RESTRICTED = 1 ;\n   const int FUNCTIONALITY_FOR_PROJECT_X = 2 ;\n}\n</code></pre>\n<p>As your methods are private, no one will mess with the data. You could even go further to test if someone sends you an invalid data:</p>\n<pre><code>namespace\n{\n   const int FUNCTIONALITY_begin = 0 ;\n   const int FUNCTIONALITY_NORMAL = 0 ;\n   const int FUNCTIONALITY_RESTRICTED = 1 ;\n   const int FUNCTIONALITY_FOR_PROJECT_X = 2 ;\n   const int FUNCTIONALITY_end = 3 ;\n\n   bool isFunctionalityCorrect(int i)\n   {\n      return (i &gt;= FUNCTIONALITY_begin) &amp;&amp; (i &lt; FUNCTIONALITY_end) ;\n   }\n}\n</code></pre>\n<p>2 : create a full class with limited const instantiations, like done in Java. Forward declare the class, and then define it in the CPP file, and instanciate only the enum-like values. I did something like that in C++, and the result was not as satisfying as desired, as it needed some code to simulate an enum (copy construction, operator =, etc.).</p>\n<p>3 : As proposed before, use the privately declared enum. Despite the fact an user will see its full definition, it won't be able to use it, nor use the private methods. So you'll usually be able to modify the enum and the content of the existing methods without needing recompiling of code using your class.</p>\n<p>My guess would be either the solution 3 or 1.</p>\n", "OwnerUserId": "14089", "PostTypeId": "2", "Id": "78426", "Score": "1", "CreationDate": "2008-09-16T23:46:03.917", "LastActivityDate": "2008-09-16T23:46:03.917"}, "11632184": {"ParentId": "71416", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I'm adding an up-to-date answer here, given recent developments.</p>\n<p>You can forward-declare an enum in C++11, so long as you declare its storage type at the same time.  The syntax looks like this:</p>\n<pre><code>enum E : short;\nvoid foo(E e);\n\n....\n\nenum E : short\n{\n    VALUE_1,\n    VALUE_2,\n    ....\n}\n</code></pre>\n<p>In fact, if the function never refers to the values of the enumeration, you don't need the complete declaration at all at that point.</p>\n<p>This is supported by G++ 4.6 and onwards (<code>-std=c++0x</code> or <code>-std=c++11</code> in more recent versions).  Visual C++ 2013 supports this; in earlier versions it has some sort of non-standard support that I haven't figured out yet - I found some suggestion that a simple forward declaration is legal, but YMMV.</p>\n", "OwnerUserId": "274460", "LastEditorUserId": "274460", "LastEditDate": "2014-08-04T05:13:51.693", "Id": "11632184", "Score": "56", "CreationDate": "2012-07-24T13:42:53.053", "LastActivityDate": "2014-08-04T05:13:51.693"}, "78448": {"CommentCount": "1", "CreationDate": "2008-09-16T23:51:45.837", "LastEditorUserId": "268", "LastActivityDate": "2008-09-16T23:58:21.623", "ParentId": "71416", "PostTypeId": "2", "LastEditorDisplayName": "Vincent Robert", "LastEditDate": "2008-09-16T23:58:21.623", "Id": "78448", "Score": "2", "Body": "<p>If you really don't want your enum to appear in your header file AND ensure that it is only used by private methods, then one solution can be to go with the pimpl principle.</p>\n<p>It's a technique that ensure to hide the class internals in the headers by just declaring:</p>\n<pre><code>class A \n{\npublic:\n    ...\nprivate:\n    void* pImpl;\n};\n</code></pre>\n<p>Then in your implementation file (cpp), you declare a class that will be the representation of the internals.</p>\n<pre><code>class AImpl\n{\npublic:\n    AImpl(A* pThis): m_pThis(pThis) {}\n\n    ... all private methods here ...\nprivate:\n    A* m_pThis;\n};\n</code></pre>\n<p>You must dynamically create the implementation in the class constructor and delete it in the destructor and when implementing public method, you must use:</p>\n<pre><code>((AImpl*)pImpl)-&gt;PrivateMethod();\n</code></pre>\n<p>There are pros for using pimpl, one is that it decouple your class header from its implementation, no need to recompile other classes when changing one class implementation. Another is that is speeds up your compilation time because your headers are so simple.</p>\n<p>But it's a pain to use, so you should really ask yourself if just declaring your enum as private in the header is that much a trouble.</p>\n", "OwnerUserId": "268", "OwnerDisplayName": "Vincent Robert"}, "71581": {"ParentId": "71416", "CommentCount": "0", "Body": "<p>In answer to the clarification: If you use the <code>enum</code> internally only, why not declare it inside the class as <code>private</code>?</p>\n", "OwnerUserId": "1968", "Id": "71581", "PostTypeId": "2", "OwnerDisplayName": "Konrad Rudolph", "Score": "0", "CreationDate": "2008-09-16T12:07:32.067", "LastActivityDate": "2008-09-16T12:07:32.067"}, "686303": {"CommentCount": "0", "CreationDate": "2009-03-26T15:36:00.040", "LastEditorUserId": "34509", "LastActivityDate": "2009-03-26T15:54:43.083", "ParentId": "71416", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastEditDate": "2009-03-26T15:54:43.083", "Id": "686303", "Score": "5", "Body": "<p>Just noting that the reason actually <em>is</em> that the size of the enum is not yet known after forward declaration. Well, you use forward declaration of a struct to be able to pass a pointer around or refer to an object from a place that's refered to in the forward declared struct definition itself too. </p>\n<p>Forward declaring an enum would not be too useful, because one would wish to be able to pass around the enum by-value. You couldn't even have a pointer to it, because i recently got told some platforms use pointers of different size for char than for int or long. So it all depends on the content of the enum. </p>\n<p>The current C++ Standard explicitly disallows doing something like </p>\n<pre><code>enum X;\n</code></pre>\n<p>(in <code>7.1.5.3/1</code>). But the next C++ Standard due to next year allows the following, which convinced me the problem actually <em>has</em> to do with the underlying type:</p>\n<pre><code>enum X : int;\n</code></pre>\n<p>It's known as a \"opaque\" enum declaration. You can even use X <em>by value</em> in the following code. And its enumerators can later be defined in a later redeclaration of the enumeration. See <code>7.2</code> in the current working draft. </p>\n", "OwnerUserId": "34509", "OwnerDisplayName": "litb"}, "71428": {"ParentId": "71416", "CommentCount": "0", "Body": "<p>Seems it can not be forward-declared in GCC!</p>\n<p>Interesting discussion <a href=\"http://bytes.com/forum/thread62285.html\" rel=\"nofollow noreferrer\">here</a></p>\n", "OwnerUserId": "123", "Id": "71428", "PostTypeId": "2", "OwnerDisplayName": "Prakash", "Score": "2", "CreationDate": "2008-09-16T11:37:29.173", "LastActivityDate": "2008-09-16T11:37:29.173"}, "483320": {"ParentId": "71416", "CommentCount": "2", "Body": "<p>You define an enumeration to restrict the possible values of elements of the type to a limited set.  This restriction is to be enforced at compile time.</p>\n<p>When forward declaring the fact that you will use a 'limited set' later on doesn't add any value: subsequent code needs to know the possible values in order to benefit from it.</p>\n<p>Although the compiler <em>is</em> concerned about the size of the enumerated type, the <em>intent</em> of the enumeration gets lost when you forward declare it.</p>\n", "OwnerUserId": "6610", "Id": "483320", "PostTypeId": "2", "OwnerDisplayName": "xtofl", "Score": "0", "CreationDate": "2009-01-27T13:05:06.963", "LastActivityDate": "2009-01-27T13:05:06.963"}, "71495": {"ParentId": "71416", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>[My answer is wrong, but I've left it here because the comments are useful].</p>\n<p>Forward declaring enums is non-standard, because pointers to different enum types are not guaranteed to be the same size. The compiler may need to see the definition to know what size pointers can be used with this type.</p>\n<p>In practice, at least on all the popular compilers, pointers to enums are a consistent size. Forward declaration of enums is provided as a language extension by Visual C++, for example.</p>\n", "OwnerUserId": "11828", "LastEditorUserId": "11828", "LastEditDate": "2013-12-09T11:32:25.227", "Id": "71495", "Score": "13", "CreationDate": "2008-09-16T11:48:52.110", "LastActivityDate": "2013-12-09T11:32:25.227"}, "685239": {"ParentId": "71416", "CommentCount": "6", "Body": "<p>There's some dissent since this got bumped (sort of), so here's some relevant bits from the standard.  Research shows that the standard doesn't really define forward declaration, nor does it explicitly state that enums can or can't be forward declared.</p>\n<p>First, from dcl.enum, section 7.2:</p>\n<blockquote>\n<p id=\"so_71416_685239_0\">The underlying type of an enumeration\n  is an integral type that can represent\n  all the enumerator values defined in\n  the enumeration. It is\n  implementation-defined which integral\n  type is used as the underlying type\n  for an enumeration except that the\n  underlying type shall not be larger\n  than int unless the value of an\n  enumerator cannot fit in an int or\n  unsigned int. If the enumerator-list\n  is empty, the underlying type is as if\n  the enumeration had a single\n  enumerator with value 0. The value of\n  sizeof() applied to an enumeration\n  type, an object of enumeration type,\n  or an enumerator, is the value of\n  sizeof() applied to the underlying\n  type.</p>\n</blockquote>\n<p>So the underlying type of an enum is implementation-defined, with one minor restriction.</p>\n<p>Next we flip to the section on \"incomplete types\" (3.9), which is about as close as we come to any standard on forward declarations:</p>\n<blockquote>\n<p id=\"so_71416_685239_1\">A class that has been declared but not defined, or an array of unknown size or of \n  incomplete element type, is an incompletely-defined object type.</p>\n<p id=\"so_71416_685239_2\">A class type (such as \"class X\") might be incomplete at one point in a translation \n  unit and complete later on; the type \"class X\" is the same type at both points. The \n  declared type of an array object might be an array of incomplete class type and \n  therefore incomplete; if the class type is completed later on in the translation unit, \n  the array type becomes complete; the array type at those two points is the same type. \n  The declared type of an array object might be an array of unknown size and therefore be \n  incomplete at one point in a translation unit and complete later on; the array types at \n  those two points (\"array of unknown bound of T\" and \"array of N T\") are different \n  types. The type of a pointer to array of unknown size, or of a type defined by a typedef \n  declaration to be an array of unknown size, cannot be completed. </p>\n</blockquote>\n<p>So there, the standard pretty much laid out the types that can be forward declared.  Enum wasn't there, so compiler authors generally regard forward declaring as disallowed by the standard due to the variable size of its underlying type.</p>\n<p>It makes sense, too.  Enums are usually referenced in by-value situations, and the compiler would indeed need to know the storage size in those situations.  Since the storage size is implementation defined, many compilers may just choose to use 32 bit values for the underlying type of every enum, at which point it becomes possible to forward declare them.  An interesting experiment might be to try forward declaring an enum in visual studio, then forcing it to use an underlying type greater than sizeof(int) as explained above to see what happens.</p>\n", "OwnerUserId": "69283", "Id": "685239", "PostTypeId": "2", "OwnerDisplayName": "Dan Olson", "Score": "1", "CreationDate": "2009-03-26T10:41:55.767", "LastActivityDate": "2009-03-26T10:41:55.767"}, "71448": {"ParentId": "71416", "CommentCount": "0", "Body": "<p>Because the enum can be an integral size of varying size (the compiler decides which size a given enum has), the pointer to the enum can also have varying size, since it's an integral type (chars have pointers of a different size on some platforms for instance).</p>\n<p>So the compiler can't even let you forward-declare the enum and user a pointer to it, because even there, it needs the size of the enum.</p>\n", "OwnerUserId": "2095", "Id": "71448", "PostTypeId": "2", "OwnerDisplayName": "Carl Seleborg", "Score": "0", "CreationDate": "2008-09-16T11:41:55.653", "LastActivityDate": "2008-09-16T11:41:55.653"}, "11382046": {"ParentId": "71416", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can wrap the enum in a struct, adding in some constructors and type conversions, and forward declare the struct instead.</p>\n<pre><code>#define ENUM_CLASS(NAME, TYPE, VALUES...) \\\nstruct NAME { \\\n    enum e { VALUES }; \\\n    explicit NAME(TYPE v) : val(v) {} \\\n    NAME(e v) : val(v) {} \\\n    operator e() const { return e(val); } \\\n    private:\\\n        TYPE val; \\\n}\n</code></pre>\n<p>This appears to work:\n<a href=\"http://ideone.com/TYtP2\" rel=\"nofollow\">http://ideone.com/TYtP2</a></p>\n", "OwnerUserId": "1509804", "LastEditorUserId": "1509804", "LastEditDate": "2012-07-08T09:40:35.410", "Id": "11382046", "Score": "2", "CreationDate": "2012-07-08T09:26:54.833", "LastActivityDate": "2012-07-08T09:40:35.410"}, "72599": {"CommentCount": "22", "CreationDate": "2008-09-16T14:02:47.297", "LastEditorUserId": "12302", "LastActivityDate": "2010-04-09T04:13:05.290", "ParentId": "71416", "PostTypeId": "2", "LastEditorDisplayName": "KJAWolf", "LastEditDate": "2010-04-09T04:13:05.290", "Id": "72599", "Score": "181", "Body": "<p>The reason the enum can't be forward declared is that without knowing the values, the compiler can't know the storage required for the enum variable.  C++ Compiler's are allowed to specify the actual storage space based on the size necessary to contain all the values specified.  If all that is visible is the forward declaration, the translation unit can't know what storage size will have been chosen - it could be a char or an int, or something else.</p>\n<hr>\n<p>From Section 7.2.5 of the ISO C++ Standard:</p>\n<blockquote>\n<p id=\"so_71416_72599_0\">The <em>underlying type</em> of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. It is implementation-defined which integral type is used as the underlying type for an enumeration except that the underlying type shall not be larger than <code>int</code> unless the value of an enumerator cannot fit in an <code>int</code> or <code>unsigned int</code>. If the <em>enumerator-list</em> is empty, the underlying type is as if the enumeration had a single enumerator with value 0. The value of <code>sizeof()</code> applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of <code>sizeof()</code> applied to the underlying type.</p>\n</blockquote>\n<p>Since the <em>caller</em> to the function must know the sizes of the parameters to correctly setup the call stack, the number of enumerations in an enumeration list must be known before the function prototype.</p>\n<p>Update:\nIn C++0X a syntax for foreward declaring enum types has been proposed and accepted.  You can see the proposal at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf</a> </p>\n</hr>", "OwnerUserId": "12302", "OwnerDisplayName": "KJAWolf"}, "bq_ids": {"n4140": {"so_71416_685239_2": {"section_id": 7204, "quality": 0.9666666666666667, "length": 87}, "so_71416_685239_1": {"section_id": 7203, "quality": 1.0, "length": 14}, "so_71416_72599_0": {"section_id": 5466, "quality": 0.6428571428571429, "length": 36}, "so_71416_1932119_0": {"section_id": 5466, "quality": 0.6428571428571429, "length": 36}, "so_71416_685239_0": {"section_id": 5466, "quality": 0.6428571428571429, "length": 36}}, "n3337": {"so_71416_685239_2": {"section_id": 6948, "quality": 0.9666666666666667, "length": 87}, "so_71416_685239_1": {"section_id": 6947, "quality": 1.0, "length": 14}, "so_71416_72599_0": {"section_id": 5252, "quality": 0.6607142857142857, "length": 37}, "so_71416_1932119_0": {"section_id": 5252, "quality": 0.6607142857142857, "length": 37}, "so_71416_685239_0": {"section_id": 5252, "quality": 0.6607142857142857, "length": 37}}, "n4659": {"so_71416_72599_0": {"section_id": 6900, "quality": 0.6428571428571429, "length": 36}, "so_71416_685239_1": {"section_id": 8712, "quality": 0.9285714285714286, "length": 13}, "so_71416_1932119_0": {"section_id": 6900, "quality": 0.6428571428571429, "length": 36}, "so_71416_685239_2": {"section_id": 8713, "quality": 0.9333333333333333, "length": 84}, "so_71416_685239_0": {"section_id": 6900, "quality": 0.6428571428571429, "length": 36}}}, "71416": {"CommentCount": "1", "AcceptedAnswerId": "72599", "PostTypeId": "1", "LastEditorUserId": "719034", "LastEditorDisplayName": "szevvy", "CreationDate": "2008-09-16T11:34:53.283", "LastActivityDate": "2015-07-23T20:16:33.510", "AnswerCount": "18", "LastEditDate": "2011-09-15T18:43:24.457", "ViewCount": "136267", "FavoriteCount": "48", "Title": "Forward declaring an enum in c++", "Id": "71416", "Score": "211", "Body": "<p>I'm trying to do something like the following:</p>\n<pre><code>enum E;\n\nvoid Foo(E e);\n\nenum E {A, B, C};\n</code></pre>\n<p>which the compiler rejects.  I've had a quick look on Google and the consensus seems to be \"you can't do it\", but I can't understand why.  Can anyone explain?  Many thanks.</p>\n<p>Clarification 2: I'm doing this as I have private methods in a class that take said enum, and I do not want the enum's values exposed - so, for example, I do not want anyone to know that E is defined as</p>\n<pre><code>enum E {\n    FUNCTIONALITY_NORMAL, FUNCTIONALITY_RESTRICTED, FUNCTIONALITY_FOR_PROJECT_X\n}\n</code></pre>\n<p>as project X is not something I want my users to know about.</p>\n<p>So, I wanted to forward declare the enum so I could put the private methods in the header file, declare the enum internally in the cpp, and distribute the built library file and header to people.</p>\n<p>As for the compiler - it's GCC.</p>\n", "Tags": "<c++><enums>", "OwnerUserId": "11437", "OwnerDisplayName": "szevvy"}, "990983": {"ParentId": "71416", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In my projects, I adopted the <a href=\"http://www.ddj.com/cpp/184403894\" rel=\"nofollow noreferrer\">Namespace-Bound Enumeration</a> technique to deal with <code>enum</code>s from legacy and 3rd-party components. Here is an example:</p>\n<h3>forward.h:</h3>\n<pre><code>namespace type\n{\n    class legacy_type;\n    typedef const legacy_type&amp; type;\n}\n</code></pre>\n<h3>enum.h:</h3>\n<pre><code>// May be defined here or pulled in via #include.\nnamespace legacy\n{\n    enum evil { x , y, z };\n}\n\n\nnamespace type\n{\n    using legacy::evil;\n\n    class legacy_type\n    {\n    public:\n        legacy_type(evil e)\n            : e_(e)\n        {}\n\n        operator evil() const\n        {\n            return e_;\n        }\n\n    private:\n        evil e_;\n    };\n}\n</code></pre>\n<h3>foo.h:</h3>\n<pre><code>#include \"forward.h\"\n\nclass foo\n{\npublic:\n    void f(type::type t);\n};\n</code></pre>\n<h3>foo.cc:</h3>\n<pre><code>#include \"foo.h\"\n\n#include &lt;iostream&gt;\n#include \"enum.h\"\n\nvoid foo::f(type::type t)\n{\n    switch (t)\n    {\n        case legacy::x:\n            std::cout &lt;&lt; \"x\" &lt;&lt; std::endl;\n            break;\n        case legacy::y:\n            std::cout &lt;&lt; \"y\" &lt;&lt; std::endl;\n            break;\n        case legacy::z:\n            std::cout &lt;&lt; \"z\" &lt;&lt; std::endl;\n            break;\n        default:\n            std::cout &lt;&lt; \"default\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<h3>main.cc:</h3>\n<pre><code>#include \"foo.h\"\n#include \"enum.h\"\n\nint main()\n{\n    foo fu;\n    fu.f(legacy::x);\n\n    return 0;\n}\n</code></pre>\n<p>Note that the <code>foo.h</code> header does not have to know anything about <code>legacy::evil</code>. Only the files that use the legacy type <code>legacy::evil</code> (here: main.cc) need to include <code>enum.h</code>.</p>\n", "OwnerUserId": "1170277", "LastEditorUserId": "1170277", "LastEditDate": "2009-06-13T16:41:01.427", "Id": "990983", "Score": "1", "CreationDate": "2009-06-13T16:32:48.280", "LastActivityDate": "2009-06-13T16:41:01.427"}, "1280969": {"ParentId": "71416", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Forward declaration of enums is also possible in C++0x. Previously, the reason enum types could not be forward declared is because the size of the enumeration depends on its contents. As long as the size of the enumeration is specified by the application, it can be forward declared:</p>\n<pre><code>enum Enum1;                   //Illegal in C++ and C++0x; no size is explicitly specified.\nenum Enum2 : unsigned int;    //Legal in C++0x.\nenum class Enum3;             //Legal in C++0x, because enum class declarations have a default type of \"int\".\nenum class Enum4: unsigned int; //Legal C++0x.\nenum Enum2 : unsigned short;  //Illegal in C++0x, because Enum2 was previously declared with a different type.\n</code></pre>\n", "OwnerUserId": "119017", "LastEditorUserId": "895245", "LastEditDate": "2015-05-28T07:28:02.503", "Id": "1280969", "Score": "151", "CreationDate": "2009-08-15T02:09:24.483", "LastActivityDate": "2015-05-28T07:28:02.503"}, "717633": {"ParentId": "71416", "CommentCount": "0", "Body": "<p>For VC, here's the test about forward declaration and specifying underlying type:</p>\n<ol>\n<li>the following code is compiled ok.</li>\n</ol>\n<pre>\n    typedef int myint;\n    enum T ;\n    void foo(T * tp )\n    {\n        * tp = (T)0x12345678;\n    }\n    enum T : char\n    {\n        A\n    };\n</pre>\n<p>But got the warning for /W4(/W3 not incur this warning)</p>\n<p>warning C4480: nonstandard extension used: specifying underlying type for enum 'T'</p>\n<ol start=\"2\">\n<li><p>VC(Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 15.00.30729.01 for 80x86)\nlooks buggy in the above case:</p>\n<ul>\n<li>when seeing enum T; VC assumes the enum type T uses default 4 bytes int as underlying type, so the generated assembly code is:</li>\n</ul></li>\n</ol>\n<pre>\n    ?foo@@YAXPAW4T@@@Z PROC                 ; foo\n    ; File e:\\work\\c_cpp\\cpp_snippet.cpp\n    ; Line 13\n        push    ebp\n        mov ebp, esp\n    ; Line 14\n        mov eax, DWORD PTR _tp$[ebp]\n        mov DWORD PTR [eax], 305419896      ; 12345678H\n    ; Line 15\n        pop ebp\n        ret 0\n    ?foo@@YAXPAW4T@@@Z ENDP                 ; foo\n</pre>\n<p>The above assembly code is extracted from /Fatest.asm directly, not my personal guess.\nDo you see the \nmov DWORD PTR[eax], 305419896       ; 12345678H\nline?</p>\n<p>the following code snippet proves it:</p>\n<pre>\n    int main(int argc, char *argv)\n    {\n        union {\n            char ca[4];\n            T t;\n        }a;\n        a.ca[0] = a.ca[1] = a.[ca[2] = a.ca[3] = 1;\n        foo( &amp;a.t;) ;\n        printf(\"%#x, %#x, %#x, %#x\\n\",  a.ca[0], a.ca[1], a.ca[2], a.ca[3] );\n        return 0;\n    }\n</pre>\n<p>the result is:\n0x78, 0x56, 0x34, 0x12</p>\n<ul>\n<li>after remove the forward declaration of enum T and move the definition of function foo after the enum T's definition: the result is OK:</li>\n</ul>\n<p>the above key instruction becomes:</p>\n<p>mov BYTE PTR [eax], 120         ; 00000078H</p>\n<p>the final result is:\n0x78, 0x1, 0x1, 0x1</p>\n<p>Note the value is not being overwritten</p>\n<p>So using of the forward-declaration of enum in VC is considered harmful.</p>\n<p>BTW, to not surprise, the syntax for declaration of the underlying type is same as its in C#. In pratice I found it's worth to save 3 bytes by specifying the underlying type as char when talk to the embedded system, which is memory limited.</p>\n", "OwnerUserId": "64469", "Id": "717633", "PostTypeId": "2", "OwnerDisplayName": "\u8d75\u5982\u98de", "Score": "1", "CreationDate": "2009-04-04T19:15:45.657", "LastActivityDate": "2009-04-04T19:15:45.657"}, "1932119": {"ParentId": "71416", "CommentCount": "1", "Body": "<p>Forward declaring things in C++ is very useful because it <a href=\"http://brianbondy.com/blog/id/5/slow-compilation-time\" rel=\"noreferrer\">dramatically speeds up compilation time</a>.  You can forward declare several things in C++ including: <code>struct</code>, <code>class</code>, <code>function</code>, etc...</p>\n<p>But can you forward declare an <code>enum</code> in C++?</p>\n<p>No you can't.  </p>\n<p>But why not allow it?  If it were allowed you could define your <code>enum</code> type in your header file, and your <code>enum</code> values in your source file.  Sounds like it should be allowed right?</p>\n<p>Wrong.</p>\n<p>In C++ there is no default type for <code>enum</code> like there is in C# (int).  In C++ your <code>enum</code> type will be determined by the compiler to be any type that will fit the range of values you have for your <code>enum</code>. </p>\n<p>What does that mean? </p>\n<p>It means that your <code>enum</code>'s underlying type cannot be fully determined until you have all of the values of the <code>enum</code> defined.  Which mans you cannot separate the declaration and definition of your <code>enum</code>.  And therefore you cannot forward declare an <code>enum</code> in C++.</p>\n<p>The ISO C++ standard S7.2.5:</p>\n<blockquote>\n<p id=\"so_71416_1932119_0\">The underlying type of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. It is implementation-defined which integral type is used as the underlying type for an enumeration except that the underlying type shall not be larger than <code>int</code> unless the value of an enumerator cannot fit in an <code>int</code> or <code>unsigned int</code>. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0. The value of <code>sizeof()</code> applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of <code>sizeof()</code> applied to the underlying type.</p>\n</blockquote>\n<p>You can determine the size of an enumerated type in C++ by using the <code>sizeof</code> operator.  The size of the enumerated type is the size of its underlying type.   In this way you can guess which type your compiler is using for your <code>enum</code>.   </p>\n<p>What if you specify the type of your <code>enum</code> explicitly like this:</p>\n<pre><code>enum Color : char { Red=0, Green=1, Blue=2};\nassert(sizeof Color == 1);\n</code></pre>\n<p>Can you then forward declare your <code>enum</code>? </p>\n<p>No.  But why not?</p>\n<p>Specifying the type of an <code>enum</code> is not actually part of the current C++ standard.  It is a VC++ extension.   It will be part of C++0x though.</p>\n<p><a href=\"http://brianbondy.com/blog/id/93/forward-declaring-enums-in-c\" rel=\"noreferrer\">Source</a></p>\n", "OwnerUserId": "3153", "PostTypeId": "2", "Id": "1932119", "Score": "29", "CreationDate": "2009-12-19T06:01:43.683", "LastActivityDate": "2009-12-19T06:01:43.683"}, "71961": {"ParentId": "71416", "CommentCount": "1", "Body": "<p>I'd do it this way:</p>\n<p>[in the public header]</p>\n<pre><code>typedef unsigned long E;\n\nvoid Foo(E e);\n</code></pre>\n<p>[in the internal header]</p>\n<pre><code>enum Econtent { FUNCTIONALITY_NORMAL, FUNCTIONALITY_RESTRICTED, FUNCTIONALITY_FOR_PROJECT_X,\n  FORCE_32BIT = 0xFFFFFFFF };\n</code></pre>\n<p>By adding FORCE_32BIT we ensure that Econtent compiles to a long, so it's interchangeable with E.</p>\n", "OwnerUserId": "12066", "PostTypeId": "2", "Id": "71961", "Score": "5", "CreationDate": "2008-09-16T13:04:33.520", "LastActivityDate": "2008-09-16T13:04:33.520"}});