post_cb({"24436336": {"ParentId": "24435954", "CommentCount": "0", "Body": "<p>Honestly, I haven't thought about this in terms of expressions. But the way I think about it - <code>std::sort</code> wants an object for it's third parameter. <code>std::less&lt;int&gt;</code> is just a type declaration. <code>std::less&lt;int&gt;()</code> creates the object that <code>std::sort</code> requires.</p>\n", "OwnerUserId": "2286830", "PostTypeId": "2", "Id": "24436336", "Score": "0", "CreationDate": "2014-06-26T17:02:30.500", "LastActivityDate": "2014-06-26T17:02:30.500"}, "24435954": {"CommentCount": "6", "AcceptedAnswerId": "24436551", "PostTypeId": "1", "LastEditorUserId": "1986903", "CreationDate": "2014-06-26T16:41:53.387", "LastActivityDate": "2014-06-27T01:17:00.967", "LastEditDate": "2014-06-27T01:17:00.967", "ViewCount": "124", "FavoriteCount": "1", "Title": "why primary expression don't include template_id", "Id": "24435954", "Score": "3", "Body": "<p>I have such code, compile with \"g++ -Wall -g -std=c++11 test.cpp \",which doesn't compile because error: expected primary-expression before \u2018)\u2019 token</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main()\n{\n  std::vector&lt;int&gt; vec;\n  for(int i=0;i&lt;10;++i)\n    {\n      vec.push_back(i);\n    }\n  std::sort(vec.begin(),vec.end(),std::less&lt;int&gt;);  //should be std::less&lt;int&gt;()\n}\n</code></pre>\n<p>But the standard says:</p>\n<pre><code>primary-expression:\n  literal\n  this\n  ( expression )\n  id-expression\n  lambda-expression\n\nid-expression:\n  unqualified-id\n  qualified-id\n\nunqualified-id:\n  identifier\n  operator-function-id\n  conversion-function-id\n  literal-operator-id\n  ~ class-name\n  ~ decltype-specifier\n template-id\n\ntemplate-id\n  simple-template-id\n\nsimple-template-id\n  template-name &lt;template-argument-list&gt; \n</code></pre>\n<p>So it seems std::less is a template-id, so it's a primary-expression.</p>\n", "Tags": "<c++><bnf>", "OwnerUserId": "1986903", "AnswerCount": "3"}, "24436482": {"ParentId": "24435954", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is the difference between the parser and the semantic analyzer. C++'s grammar tells you only what is grammatical -- what will pass through the parser. For example, the grammar would also allow you to do something like:</p>\n<pre><code>std::sort(vec.begin(), vec.end(), ~MyClass);\n</code></pre>\n<p>for the same reason -- because <code>~ class-name</code> is an <code>unqualified-id</code>. You need to look at the semantic rules of the language to determine if a program is well formed, not just look at the grammar, and the semantic rules of the language require a value here, rather than a type.</p>\n<hr>\n<p>Specifically, I believe the standard says this via the rules for the function call operator (<code>()</code>) at C++11 5.2.2 [expr.call]/4: (emphasis mine)</p>\n<blockquote>\n<p id=\"so_24435954_24436482_0\">When a function is called, <strong>each parameter</strong> (8.3.5) <strong>shall be initialized</strong> (<strong>8.5</strong>, 12.8, 12.1) with its corresponding argument.</p>\n</blockquote>\n<p>8.5 [dcl.init]/1: (emphasis mine)</p>\n<blockquote>\n<p id=\"so_24435954_24436482_1\">A declarator can specify an initial value for the identifier being declared. <strong>The identifier designates a variable being initialized</strong>.</p>\n</blockquote>\n<p>But I'm no standards scholar and I'm not on the committee, so YMMV.</p>\n</hr>", "OwnerUserId": "82320", "LastEditorUserId": "82320", "LastEditDate": "2014-06-26T17:20:05.183", "Id": "24436482", "Score": "2", "CreationDate": "2014-06-26T17:11:03.453", "LastActivityDate": "2014-06-26T17:20:05.183"}, "bq_ids": {"n4140": {"so_24435954_24436482_0": {"section_id": 5991, "quality": 0.75, "length": 9}, "so_24435954_24436482_1": {"section_id": 3280, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_24435954_24436482_0": {"section_id": 5759, "quality": 0.75, "length": 9}, "so_24435954_24436482_1": {"section_id": 3151, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_24435954_24436482_0": {"section_id": 7491, "quality": 0.75, "length": 9}, "so_24435954_24436482_1": {"section_id": 4042, "quality": 0.9285714285714286, "length": 13}}}, "24436551": {"ParentId": "24435954", "CommentCount": "2", "Body": "<p>Being grammatically correct doesn't necessarily make the program <em>semantically</em> correct. The grammar production from primary-expression -&gt; template-id is there to allow use of a specialization of a function template as an expression, e.g, this is valid:</p>\n<pre><code>template &lt;typename T&gt;\nbool less(const T&amp; a, const T&amp; b) { return a &lt; b; }\n\nint main() {\n  std::vector&lt;int&gt; vec;\n  std::sort(vec.begin(), vec.end(), less&lt;int&gt;);\n}\n</code></pre>\n<p>A template-id that refers to a class template, however, is not usable as an expression.</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "24436551", "Score": "4", "CreationDate": "2014-06-26T17:15:01.327", "LastActivityDate": "2014-06-26T17:15:01.327"}});