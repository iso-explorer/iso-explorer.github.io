post_cb({"bq_ids": {"n4140": {"so_30691551_30691660_1": {"length": 55, "quality": 0.8333333333333334, "section_id": 5809}}, "n3337": {"so_30691551_30691660_1": {"length": 55, "quality": 0.8333333333333334, "section_id": 5582}}, "n4659": {"so_30691551_30691660_1": {"length": 55, "quality": 0.8333333333333334, "section_id": 7270}}}, "30691551": {"ViewCount": "168", "Body": "<p>I'll skip the headers</p>\n<pre><code>class X {\n    int i;\n    static int j;\n\npublic:\n    X(int ii = 1) : i(ii) {\n        j = i;\n    }\n    static int incr() {\n        return ++j;\n    }\n    static int f() {\n        return incr();\n    }\n};\n\nint _tmain(int argc, _TCHAR* argv[]) {\n    X x;\n    X* xp = &amp;x;\n    cout &lt;&lt; x.f() &lt;&lt; xp-&gt;f() &lt;&lt; X::f();\n\n    return 1;\n}\n</code></pre>\n<p>This sequence prints 432 but at first view one might think it will print 234.</p>\n<p>How could the exact order of the function calls be determined? What am I missing?</p>\n", "AcceptedAnswerId": "30691660", "Title": "How to determine C++ function call order?", "CreationDate": "2015-06-07T08:31:48.980", "Id": "30691551", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-06-07T08:54:44.930", "Score": "2", "OwnerUserId": "1109883", "Tags": "<c++>", "AnswerCount": "3"}, "30691666": {"Id": "30691666", "PostTypeId": "2", "Body": "<p>This statement</p>\n<pre><code>cout &lt;&lt; x.f() &lt;&lt; xp-&gt;f() &lt;&lt; X::f();\n</code></pre>\n<p>can be rewritten like</p>\n<pre><code>cout.operator &lt;&lt;( x.f() ).operator &lt;&lt;( xp-&gt;f() ).operator &lt;&lt;( X::f() );\n</code></pre>\n<p>The order of evaluations of expressions used as arguments in this statement is unspecified. So the compiler can evaluates them for example from left to right or from right to left. Thus using different compilers you can get different results.:)</p>\n<p>To get a deterministic result you should rewrite statement</p>\n<pre><code>cout &lt;&lt; x.f() &lt;&lt; xp-&gt;f() &lt;&lt; X::f();\n</code></pre>\n<p>for example like</p>\n<pre><code>cout &lt;&lt; x.f();\ncout &lt;&lt; xp-&gt;f();\ncoit &lt;&lt; X::f();\n</code></pre>\n", "LastActivityDate": "2015-06-07T08:48:03.193", "CommentCount": "0", "CreationDate": "2015-06-07T08:48:03.193", "ParentId": "30691551", "Score": "1", "OwnerUserId": "2877241"}, "30691660": {"Id": "30691660", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30691551_30691660_0\">\u00a7 1.9.13</p>\n<p id=\"so_30691551_30691660_1\">Sequenced before is an asymmetric, transitive, pair-wise relation between evaluations executed by a single\n      thread (1.10), which induces a partial order among those evaluations. Given any two evaluations A and B, if\n      A is sequenced before B, then the execution of A shall precede the execution of B. If A is not sequenced before\n      B and B is not sequenced before A, then A and B are unsequenced. [ Note: The execution of unsequenced\n      evaluations can overlap. \u2014end note ] Evaluations A and B are indeterminately sequenced when either A\n      is sequenced before B or B is sequenced before A, but it is unspecified which. [ Note: Indeterminately\n      sequenced evaluations cannot overlap, but either could be executed first. \u2014end note ]</p>\n</blockquote>\n<p>In other words, the order the functions are called is Undefined. That doesn't mean \"we don't know\", it doesn't mean \"you can't work it out\" - it means that it is defined as having no definition; the compiler and cpu are free to complete them in any order.</p>\n<p>Consider the following:</p>\n<pre><code>int a[3];\n\nvoid f1() { a[0] = 1; }\nvoid f2() { a[1] = 2; }\nvoid f3() { a[2] = 3; }\n\nint main() {\n    f1(), f2(), f3();\n}\n</code></pre>\n<p>Basically the language asserts no requirement for ordering on a statement like</p>\n<pre><code>std::cout &lt;&lt; f1() &lt;&lt; f2() &lt;&lt; f3();\n</code></pre>\n<p>Your code has no sequence points (<a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Sequence_point</a>) between the function calls; you could figure out the order your compiler generates, but it might behave differently on a different CPU or a different optimization level.</p>\n<p>If you have mutable function calls like that, you'll need to manually hoist or add breaks:</p>\n<pre><code>std::cout &lt;&lt; f1();\nstd::cout &lt;&lt; f2();\nstd::cout &lt;&lt; f3();\n</code></pre>\n<p>or</p>\n<pre><code>auto a1 = f1();\nauto a2 = f2();\nauto a3 = f3();\nstd::cout &lt;&lt; a1 &lt;&lt; a2 &lt;&lt; a3;\n</code></pre>\n", "LastEditorUserId": "257645", "LastActivityDate": "2015-06-07T08:54:44.930", "Score": "2", "CreationDate": "2015-06-07T08:47:16.353", "ParentId": "30691551", "CommentCount": "1", "OwnerUserId": "257645", "LastEditDate": "2015-06-07T08:54:44.930"}, "30691659": {"Id": "30691659", "PostTypeId": "2", "Body": "<p>The stream operator is simply an operator. <a href=\"http://en.wikibooks.org/wiki/C%2B%2B_Programming/Operators/Operator_Overloading\" rel=\"nofollow\">C++ allows operators to be defined a multitude of ways.</a> What you're seeing is the &lt;&lt; operator for strings. What you're doing is the same thing as:</p>\n<pre><code>cout &lt;&lt; \"word1\" &lt;&lt; \"word2\" &lt;&lt; \"word3\";\n</code></pre>\n<p>The expect output for that is:</p>\n<pre><code>\"word1word2word3\"\n</code></pre>\n<p>However, the evaluation order is determined by the implementation of the &lt;&lt; operator. Usually the above is equivalent to:</p>\n<pre><code>   (((cout &lt;&lt; \"word1\") &lt;&lt; \"word2\") &lt;&lt; \"word3\");\n</code></pre>\n<p>Replace the strings with functions instead and you see the first one evaluated is actually \"word3\". This is not strictly the case, just what you'll usually see. </p>\n<pre><code>   (((cout &lt;&lt; func1()) &lt;&lt; func2()) &lt;&lt; func3());\n</code></pre>\n<p>Evaluation order would be func3, func2, func1, with print order the return of func1, func2, func3.</p>\n", "LastActivityDate": "2015-06-07T08:47:04.327", "CommentCount": "1", "CreationDate": "2015-06-07T08:47:04.327", "ParentId": "30691551", "Score": "2", "OwnerUserId": "781162"}});