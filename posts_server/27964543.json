post_cb({"27964658": {"ParentId": "27964543", "LastEditDate": "2015-01-18T19:22:47.607", "CommentCount": "4", "CreationDate": "2015-01-15T13:35:12.340", "OwnerUserId": "2139223", "LastEditorUserId": "2139223", "PostTypeId": "2", "Id": "27964658", "Score": "-2", "Body": "<p>In C++ static object are guarantee to initialize just if a code from the file that the instance is defined has been called (The order of the initialization is not guarantee).</p>\n<p>because of this it better do instance the object inside a function and than call the function</p>\n<pre><code>class A{\npublic:\n    static A&amp; getInstance(){\n       static A a;\n       return a;\n    }\nprotected:\n    A(){\n    }\n};\n</code></pre>\n", "LastActivityDate": "2015-01-18T19:22:47.607"}, "27965601": {"ParentId": "27964543", "CommentCount": "2", "Body": "<p>it's done this way:</p>\n<pre><code>template &lt;class T&gt; class Singleton {\nprotected:\n  Singleton();\n\n  // note: static function contains static variable\n  static T&amp; instance() {\n    static T _t; // c++11 guarantees that this is thread-safe\n    return _t;\n  }\n}\n\nclass ConcreteA : public Singleton&lt;ConcreteA&gt;\n{\n  ...\n};\n\nauto&amp; myA = ConcreteA::instance();\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "27965601", "Score": "0", "CreationDate": "2015-01-15T14:26:20.410", "LastActivityDate": "2015-01-15T14:26:20.410"}, "27965993": {"ParentId": "27964543", "LastEditDate": "2015-01-15T14:56:41.897", "CommentCount": "5", "CreationDate": "2015-01-15T14:45:46.913", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "PostTypeId": "2", "Id": "27965993", "Score": "4", "Body": "<p>Building upon your own \"dirty trick\", this works in all the compilers I tested, and doesn't require any code in the derived class constructor:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; class Singleton {\nprotected:\n  Singleton() { instptr_ = &amp;instance_; }\n  static T instance_;\nprivate:\n  static T* instptr_;\n};\n\ntemplate&lt;class T&gt; T Singleton&lt;T&gt;::instance_;\ntemplate&lt;class T&gt; T* Singleton&lt;T&gt;::instptr_;\n\nclass ConcreteA : public Singleton&lt;ConcreteA&gt; {\npublic:\n  ConcreteA() { std::cout &lt;&lt; \"ConcreteA constructed.\\n\"; }\n  void foo();\n};\n\nint main() {\n  //Prints 'ConcreteA constructed.'.\n  return 0;\n}\n</code></pre>\n<p>My understanding of it is that taking the address of <code>instance_</code> <em>odr-uses</em> it, forcing it into existence. I must say I'm not 100% sure this is guaranteed not to be optimized away in future versions of some compiler (I tested it with <code>-O2</code> everywhere).</p>\n<p>EDIT: Looks like even writing the base class constructor like this</p>\n<pre><code>Singleton() { (void)&amp;instance_; }\n</code></pre>\n<p>is enough, which gets rid of <code>instptr_</code> altogether.</p>\n", "LastActivityDate": "2015-01-15T14:56:41.897"}, "27964543": {"CommentCount": "0", "ViewCount": "721", "PostTypeId": "1", "LastEditorUserId": "2020827", "CreationDate": "2015-01-15T13:29:12.273", "LastActivityDate": "2015-08-09T10:24:32.940", "Title": "Explicit template static member instantiation in a derived class", "AcceptedAnswerId": "27965993", "LastEditDate": "2015-08-09T10:24:32.940", "Id": "27964543", "Score": "6", "Body": "<p>I am trying to implement a template class with a static member. Classes that are derived from the template class shall be instantiated without the need to write extra code.</p>\n<p>Here is my naive (and not successful) approach:</p>\n<p><em>Singleton.h:</em></p>\n<pre><code>template &lt;class T&gt; class Singleton {\nprotected:\n  Singleton();\n  static T instance_;\n}\n\n// explicit instantiation of 'instance_' ???, \n// where 'instance_' is an instance of the derived class\ntemplate &lt;class T&gt; T Singleton&lt;T&gt;::instance_;\n</code></pre>\n<p><em>ConcreteA.h:</em></p>\n<pre><code>class ConcreteA : public Singleton&lt;ConcreteA&gt; {\npublic:\n  ConcreteA();\n  void foo();\n}\n</code></pre>\n<p><em>main.c:</em></p>\n<pre><code>int main() {\n  // an instance of ConcreteA should have been created (no extra code)!!!\n  return 0;\n}\n</code></pre>\n<p><strong>Is there a way to force the instantiation of <code>ConcreteA</code> by just deriving <code>ConcreteA</code> from <code>Singleton</code>, without writing extra instantiation code?</strong></p>\n<p>A <em>dirty workaround</em> is to call an method on <code>instance_</code> in the <code>ConcreteA</code> constructor, for example:</p>\n<p><em>ConcreteA.c</em></p>\n<pre><code>ConcrereA::ConcreteA { instance_.foo(); }\n</code></pre>\n<p><strong>Are there better workarounds?</strong></p>\n", "Tags": "<c++><templates><c++11><inheritance><singleton>", "OwnerUserId": "2020827", "AnswerCount": "4"}, "27964716": {"ParentId": "27964543", "CommentCount": "0", "Body": "<p>Unfortunately, that is not possible. Quoting C++11 14.7.1/2 (talking about implicit instantiation of templates):</p>\n<blockquote>\n<p id=\"so_27964543_27964716_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly\n  specialized, the specialization of the member is implicitly instantiated when the specialization is referenced\n  in a context that requires the member definition to exist; <strong>in particular, the initialization (and any associated\n  side-effects) of a static data member does not occur unless the static data member is itself used in a way\n  that requires the definition of the static data member to exist.</strong></p>\n</blockquote>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "27964716", "Score": "2", "CreationDate": "2015-01-15T13:37:48.423", "LastActivityDate": "2015-01-15T13:37:48.423"}, "bq_ids": {"n4140": {"so_27964543_27964716_0": {"section_id": 234, "quality": 0.9767441860465116, "length": 42}}, "n3337": {"so_27964543_27964716_0": {"section_id": 227, "quality": 0.9767441860465116, "length": 42}}, "n4659": {"so_27964543_27964716_0": {"section_id": 244, "quality": 0.9534883720930233, "length": 41}}}});