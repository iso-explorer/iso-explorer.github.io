post_cb({"39044176": {"Id": "39044176", "PostTypeId": "2", "Body": "<p>How about </p>\n<pre><code>holder(const holder&amp; b) = delete;\n</code></pre>\n<p>?</p>\n<p>That solved the compilation problem., at least.</p>\n", "LastActivityDate": "2016-08-19T16:50:29.943", "CommentCount": "0", "CreationDate": "2016-08-19T16:50:29.943", "ParentId": "39040609", "Score": "-1", "OwnerUserId": "3458"}, "39044185": {"Id": "39044185", "PostTypeId": "2", "Body": "<p>Short answer: It's a bug in libstdc++. According to the allocator-aware container requirements table in [container.requirements.general] in the Standard (hasn't changed since C++11), container move assignment:</p>\n<blockquote>\n<p id=\"so_39040609_39044185_0\"><em>Requires:</em> If <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code>\n  is <code>false</code>, <code>T</code> is <code>MoveInsertable</code> into <code>X</code> and <code>MoveAssignable</code>.\n  [...]</p>\n</blockquote>\n<p>(<code>X</code> is the container type and <code>T</code> is its <code>value_type</code>)</p>\n<p>You're using the default allocator, which has <code>using propagate_on_container_move_assignment = true_type;</code>, so the above requirement doesn't apply; there should be no special requirements on the <code>value_type</code>.</p>\n<p>Quick fix: If you cannot touch <code>holder</code>, one solution is to change <code>y_u_no_elision</code>, adding</p>\n<pre><code>y_u_no_elision(const y_u_no_elision&amp;) = delete;\ny_u_no_elision(y_u_no_elision&amp;&amp;) = default;\n</code></pre>\n<hr>\n<p>Long story: The bug is essentially caused by <a href=\"https://github.com/gcc-mirror/gcc/blob/b3f70025e3cec069bc6d06ba6a23bcc74f40aabd/libstdc%2B%2B-v3/include/bits/stl_tree.h#L1389\" rel=\"nofollow\">this line in stl_tree.h</a>. </p>\n<p><code>_Rb_tree</code> is the underlying implementation of <code>std::map</code> and that line in its move assignment operator definition basically does the check specified by the Standard quote above. However, it does it using a simple <code>if</code>, which means that, even if the condition is satisfied, the other branch has to compile as well, even though it won't be executed at runtime. Lacking the shiny new C++17 <code>if constexpr</code>, this should be implemented using something like tag dispatching (for the first two conditions - the third one is a true runtime check), in order to avoid instantiating the code outside the taken branch.</p>\n<p>The error is then caused by <a href=\"https://github.com/gcc-mirror/gcc/blob/b3f70025e3cec069bc6d06ba6a23bcc74f40aabd/libstdc%2B%2B-v3/include/bits/stl_tree.h#L1411\" rel=\"nofollow\">this line</a>, which uses <code>std::move_if_noexcept</code> on <code>value_type</code>. And here comes the long story.</p>\n<p><code>value_type</code> is <code>std::pair&lt;const std::string, y_u_no_elision&gt;</code>. </p>\n<p>In your initial code:</p>\n<ul>\n<li><code>holder</code> has non-deleted, non-noexcept copy and move constructors.</li>\n<li>This means the corresponding implicitly-declared constructors of <code>y_u_no_elision</code> will also be non-deleted and non-noexcept. </li>\n<li>These characteristics propagate to the constructors of <code>value_type</code>.</li>\n<li>This results in <code>std::move_if_noexcept</code> returning <code>const value_type&amp;</code> instead of <code>value_type&amp;&amp;</code> (it falls back to copy if it can - see <a href=\"http://en.cppreference.com/w/cpp/utility/move_if_noexcept\" rel=\"nofollow\">these docs</a>).</li>\n<li>That eventually causes the copy constructor of <code>y_u_no_elision</code> to be called, which will cause <code>holder&lt;ptrwrap&gt;</code>'s copy constructor definition to be instantiated, which tries to copy a <code>std::unique_ptr</code>.</li>\n</ul>\n<p>Now, if you remove the user-declared copy and move constructors <em>and assignment operators</em> from <code>holder</code>:</p>\n<ul>\n<li><code>holder</code> will get the implicitly-declared ones. The copy constructor will be deleted and the move constructor will be defaulted, not deleted and <code>noexcept</code>. </li>\n<li>This propagates up to <code>value_type</code>, with one exception unrelated to <code>holder</code>: <code>value_type</code>'s move constructor will try to move from a <code>const std::string</code>; this will not call <code>string</code>'s move constructor (which is <code>noexcept</code> in this case), but rather its copy constructor, as <code>string&amp;&amp;</code> cannot bind to an rvalue of type <code>const string</code>. </li>\n<li><code>string</code>'s copy constructor is not <code>noexcept</code> (it may have to allocate memory), so <code>value_type</code>'s move constructor won't be either. </li>\n<li>So, why does the code compile? Because of the logic behind <code>std::move_if_noexcept</code>: it returns an rvalue reference even if the argument's move constructor isn't <code>noexcept</code>, as long as the argument is not copy-constructible (it falls back to non-noexcept move if it cannot fall back to copy); and <code>value_type</code> isn't, because of <code>holder's</code> deleted copy constructor.</li>\n</ul>\n<p>This is the logic behind the quick fix above: you have to do something to make <code>value_type</code> have a valid move constructor and a deleted copy constructor, in order to get an rvalue reference from <code>move_if_noexcept</code>. This is because you won't be able to make <code>value_type</code> have a <code>noexcept</code> move constructor due to the <code>const std::string</code>, as explained above.</p>\n</hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2016-08-21T11:34:26.230", "Score": "8", "CreationDate": "2016-08-19T16:51:41.217", "ParentId": "39040609", "CommentCount": "0", "OwnerUserId": "4326278", "LastEditDate": "2016-08-21T11:34:26.230"}, "39040825": {"Id": "39040825", "PostTypeId": "2", "Body": "<p>The <code>holder</code> copy constructor invokes <code>t</code> copy constructor:</p>\n<pre><code>holder(const holder&amp; b)\n    : t(b.t)\n{\n}\n</code></pre>\n<p>If <code>t</code> is a <code>unique_ptr</code> then it doesn't support a construction by copy.</p>\n", "LastActivityDate": "2016-08-19T13:53:39.827", "CommentCount": "5", "CreationDate": "2016-08-19T13:53:39.827", "ParentId": "39040609", "Score": "-1", "OwnerUserId": "6040181"}, "bq_ids": {"n4140": {"so_39040609_39044185_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 716}}, "n3337": {"so_39040609_39044185_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 705}}, "n4659": {"so_39040609_39044185_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 746}}}, "39040609": {"ViewCount": "170", "Body": "<p>I get this strange compilation error on new versions of gcc (4.9+).</p>\n<p>Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nstruct ptrwrap\n{\n    unique_ptr&lt;int&gt; foo;\n};\n\ntemplate &lt;typename T&gt;\nstruct holder\n{\n    holder() = default;\n\n    holder(const holder&amp; b)\n        : t(b.t)\n    {\n    }\n\n    holder(holder&amp;&amp; b)\n        : t(std::move(b.t))\n    {\n    }\n\n    holder&amp; operator=(const holder&amp; h)\n    {\n        t = h.t;\n        return *this;\n    }\n\n    holder&amp; operator=(holder&amp;&amp; h)\n    {\n        t = std::move(h.t);\n        return *this;\n    }\n\n    T t;\n};\n\nstruct y_u_no_elision\n{\n    holder&lt;ptrwrap&gt; elem;\n};\n\ntypedef map&lt;std::string, y_u_no_elision&gt; mymap;\n\nmymap foo();\n\nint main()\n{\n    auto m = foo();\n    m = foo();\n    return 0;\n}\n</code></pre>\n<p><a href=\"https://ideone.com/XaxBVv\" rel=\"noreferrer\">Here</a> it is on ideone too with the actual error. Basically it boils down to using the deleted copy constructor of ptrwrap. Which... shouldn't happen. The map is returned by value (ie moved), so no copies can exist. </p>\n<p>Now the same code is compiled with no problems on older versions of gcc (I tried 4.2 and 4.3), all versions of clang I tried, and also Visual Studio 2015.</p>\n<p>Curiously if I remove the explicit copy and move constructors of the holder template, it also compiles on gcc 4.9+. If I change the <code>map</code> to a <code>vector</code> or an <code>unordered_map</code> it also compiles fine (<a href=\"https://ideone.com/xx7Uni\" rel=\"noreferrer\">here</a> is a link to a compiling version of the code with <code>unordered_map</code>)</p>\n<p>So... is this a gcc 4.9 bug or are the other compilers being permissive of something I can't see? Is there anything I can do about this which doesn't involve changing the <code>holder</code> class?</p>\n", "AcceptedAnswerId": "39044185", "Title": "Compilation error when returning an std::map of implicitly non-copyable structs on new versions of gcc", "CreationDate": "2016-08-19T13:44:20.537", "Id": "39040609", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-08-19T14:19:02.000", "LastEditorUserId": "1453047", "LastActivityDate": "2016-08-21T11:34:26.230", "Score": "9", "OwnerUserId": "1453047", "Tags": "<c++><c++11><gcc>", "AnswerCount": "3"}});