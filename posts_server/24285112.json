post_cb({"24285274": {"ParentId": "24285112", "CommentCount": "3", "Body": "<p>The warning is trying to prevent situations where you might be relying on the wrong ordering of the data members. Say you think B is initialized before A, and then you do something like this:</p>\n<pre><code>myClass::myClass() :\nB(42), A(B) {}\n</code></pre>\n<p>Here, you have undefined behaviour because you are reading from an uninitialized <code>B</code>.</p>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "24285274", "Score": "13", "CreationDate": "2014-06-18T12:12:23.953", "LastActivityDate": "2014-06-18T12:12:23.953"}, "24285227": {"ParentId": "24285112", "CommentCount": "7", "Body": "<p>The order of the initializer list does <strong>NOT</strong> matter.\nThe declaration of your members in the class header defines the initialization order.</p>\n<p>This is by design and required as you could have multiple ctors having totally different init list orders.</p>\n<p>So your members will <strong>ALWAYS</strong> be initialized in the order of declaration.</p>\n", "OwnerUserId": "2416394", "PostTypeId": "2", "Id": "24285227", "Score": "2", "CreationDate": "2014-06-18T12:10:18.667", "LastActivityDate": "2014-06-18T12:10:18.667"}, "24287946": {"ParentId": "24285112", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The warning is indicating that regardless of the order you use in the constructor initialization list the standard requires that non-static data members be initialized in the order they were declared. We can see this by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"noreferrer\">draft C++ standard</a> section <code>12.6.2</code> <em>Initializing bases and members</em> paragraph <em>10</em> which says:</p>\n<blockquote>\n<p id=\"so_24285112_24287946_0\">In a non-delegating constructor, initialization proceeds in the\n  following order:</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote>\n<p id=\"so_24285112_24287946_1\">Then, non-static data members are initialized in the order they were\n  declared in the class definition (again regardless of the order of the\n  mem-initializers).</p>\n</blockquote>\n<p>Why does the standard require this? We can find a rationale for this in paper <a href=\"https://www.usenix.org/legacy/publications/compsystems/1989/sum_stroustrup.pdf\" rel=\"noreferrer\">The Evolution of C++: 1985 to 1989</a> by Bjarne Stroustrup in section <code>6</code> it says:</p>\n<blockquote>\n<p id=\"so_24285112_24287946_2\">The initialization takes place in the order of declaration in the\n  class with base classes initialized before members,</p>\n<p id=\"so_24285112_24287946_3\">[...]</p>\n<p id=\"so_24285112_24287946_4\">The reason for ignoring the order of initializers is to preserve the\n  usual FIFO ordering of constructor and destructor calls. Allowing two\n  constructors to use different orders of initialization of bases and\n  members would constrain implementations to use more dynamic and more\n  expensive strategies</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-06-18T19:53:10.767", "Id": "24287946", "Score": "13", "CreationDate": "2014-06-18T14:15:09.440", "LastActivityDate": "2014-06-18T19:53:10.767"}, "bq_ids": {"n4140": {"so_24285112_24287946_0": {"section_id": 438, "quality": 1.0, "length": 6}, "so_24285112_24287946_2": {"section_id": 438, "quality": 0.5833333333333334, "length": 7}, "so_24285112_24287946_1": {"section_id": 438, "quality": 1.0, "length": 15}}, "n3337": {"so_24285112_24287946_0": {"section_id": 429, "quality": 1.0, "length": 6}, "so_24285112_24287946_2": {"section_id": 429, "quality": 0.5833333333333334, "length": 7}, "so_24285112_24287946_1": {"section_id": 429, "quality": 1.0, "length": 15}}, "n4659": {"so_24285112_24287946_0": {"section_id": 458, "quality": 1.0, "length": 6}, "so_24285112_24287946_1": {"section_id": 458, "quality": 1.0, "length": 15}, "so_24285112_24287946_2": {"section_id": 458, "quality": 0.5833333333333334, "length": 7}}}, "24285112": {"CommentCount": "11", "CreationDate": "2014-06-18T12:04:23.207", "PostTypeId": "1", "AcceptedAnswerId": "24285274", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-18T19:53:10.767", "LastEditDate": "2017-05-23T11:54:48.670", "ViewCount": "3859", "FavoriteCount": "1", "Title": "Why must initializer list order match member declaration order?", "Id": "24285112", "Score": "14", "Body": "<p>Why does gcc throw a hissy fit if the initializer list order doesn't match variable order in the class?</p>\n<pre><code>class myClass\n{\npublic:\n   int A;\n   int B;\n   myClass();\n};\n\nmyClass::myClass() :\nB(1),\nA(2)\n{}\n</code></pre>\n<p>will result in:    </p>\n<pre><code>file.h:274: warning: 'myClass::A' will be initialized after\nfile.h:273: warning:   'int myClass::B\nfile.cpp:581: warning:   when initialized here\n</code></pre>\n<p>Is there any specific reason why this kind of warning is issued? Are there any risks associated with initializing variables of a class in order different than they are defined within the class?</p>\n<p>(note, there is <a href=\"https://stackoverflow.com/questions/1242830/constructor-initialization-list-evaluation-order\">a question</a> which touches the subject, but the answers are pretty much \"because it should be so\" without giving any rationale as to <em>why</em> it should be ordered, or what's wrong with this being out of order - I'd like to know why such a restriction exists - could someone give an example where it may backfire maybe?)</p>\n", "Tags": "<c++><constructor><initializer-list>", "OwnerUserId": "249618", "AnswerCount": "3"}});