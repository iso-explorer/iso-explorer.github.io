post_cb({"25676435": {"Id": "25676435", "PostTypeId": "2", "Body": "<p>This quote is not as precisely worded as it could be:</p>\n<blockquote>\n<p id=\"so_25674834_25676435_0\">An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.</p>\n</blockquote>\n<p>An rvalue is an <em>expression</em> , so it cannot <em>be</em> an object (temporary or otherwise). The intent of the section of this quote talking about temporary objects is to say that value resulting from evaluating the rvalue is a temporary object, and so on.</p>\n<p>This is a common shortcut, e.g. with <code>int x;</code> we would casually say \"x is in int\" , when in fact <code>x</code> is an identifier; and the expression <code>x</code> has type <code>int</code> and designates an int.</p>\n<p>Anyway, it divides possible rvalues up into three categories:</p>\n<ul>\n<li>xvalue</li>\n<li>temporary object</li>\n<li>value not associated with an object</li>\n</ul>\n<p>The definition of <em>temporary object</em> includes being an object of class type, so it seems to me that \"value not associated with an object\" should be any non-xvalue of non-class type. For example <code>1 + 1</code>.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2014-09-04T23:40:30.727", "Score": "1", "CreationDate": "2014-09-04T23:22:10.850", "ParentId": "25674834", "CommentCount": "7", "OwnerUserId": "1505939", "LastEditDate": "2014-09-04T23:40:30.727"}, "25693147": {"Id": "25693147", "PostTypeId": "2", "Body": "<p>Examples for such values are all non-array, non-class non-temporary prvalues (a temporary prvalue corresponds to a temporary object). Examples include <code>2.0</code> and <code>1</code>. Counterexamples include <code>\"hello\"</code> (which is an array), <code>std::string(\"haha\")</code> (which is a class object) or the <code>float</code> prvalue temporary initialized from <code>2</code> that is bound to the reference in <code>(const float&amp;){2}</code> (the reference itself is an lvalue!). I <em>think</em> that this simple rule covers the rules accurately. </p>\n<p>A C++ Standard's footnote on the lvalue to rvalue conversion says (a little bit outdated, because it was not amended to mention array types)</p>\n<blockquote>\n<p id=\"so_25674834_25693147_0\">In C ++ class prvalues can have cv-qualified types (because they are objects). This differs from ISO C, in which non-lvalues never have cv-qualified types.</p>\n</blockquote>\n<p>So the deeper reason that <code>decltype((const int)0)</code> <em>still</em> is type <code>int</code> is that it does not refer to an object. So because there is no object, there is nothing to make const, and consequently the expression will never be const either.</p>\n", "LastActivityDate": "2014-09-05T19:59:17.470", "CommentCount": "0", "CreationDate": "2014-09-05T19:59:17.470", "ParentId": "25674834", "Score": "2", "OwnerUserId": "34509"}, "25675061": {"Id": "25675061", "PostTypeId": "2", "Body": "<p><code>[intro.object]</code>:</p>\n<blockquote>\n<p id=\"so_25674834_25675061_0\">The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. \u2014end note ] An object is created by a definition (3.1), by a new-expression (5.3.4) or by the implementation (12.2) when needed.</p>\n</blockquote>\n<p>So \"a value not associated with an object\" is something created not by definition or with new-expression, which also means that it doesn't have corresponding region of storage, like for example a literal.</p>\n<p><strong>Edit:</strong> Except string literals (see comments)</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-09-04T22:00:31.550", "Score": "4", "CreationDate": "2014-09-04T21:12:06.953", "ParentId": "25674834", "CommentCount": "10", "OwnerUserId": "3959454", "LastEditDate": "2014-09-04T22:00:31.550"}, "bq_ids": {"n4140": {"so_25674834_25676435_0": {"length": 19, "quality": 0.95, "section_id": 7230}, "so_25674834_25693147_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 8}, "so_25674834_25674834_0": {"length": 20, "quality": 0.8, "section_id": 7230}, "so_25674834_25674834_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 3317}, "so_25674834_25674834_2": {"length": 6, "quality": 1.0, "section_id": 3222}, "so_25674834_25674834_1": {"length": 19, "quality": 0.95, "section_id": 7230}, "so_25674834_25675061_0": {"length": 24, "quality": 0.7741935483870968, "section_id": 5790}}, "n3337": {"so_25674834_25674834_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 3187}, "so_25674834_25693147_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5}, "so_25674834_25674834_0": {"length": 20, "quality": 0.8, "section_id": 6974}, "so_25674834_25676435_0": {"length": 19, "quality": 0.95, "section_id": 6974}, "so_25674834_25674834_2": {"length": 6, "quality": 1.0, "section_id": 3096}, "so_25674834_25674834_1": {"length": 19, "quality": 0.95, "section_id": 6974}, "so_25674834_25675061_0": {"length": 24, "quality": 0.7741935483870968, "section_id": 5563}}, "n4659": {"so_25674834_25674834_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 502}, "so_25674834_25693147_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 8}, "so_25674834_25674834_2": {"length": 6, "quality": 1.0, "section_id": 3979}, "so_25674834_25675061_0": {"length": 21, "quality": 0.6774193548387096, "section_id": 7247}}}, "25674834": {"ViewCount": "355", "Body": "<p>The C++11 and C++14 standard (and working draft, respectively) say in \u00a73.10.1:</p>\n<blockquote>\n<p id=\"so_25674834_25674834_0\">A prvalue (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue. [Example: The result of calling a function\n  whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is\n  also a prvalue. \u2014end example ]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_25674834_25674834_1\">An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment\n  expression) is an xvalue, a temporary object (12.2) or subobject thereof, or <strong>a value that is not associated\n  with an object</strong>.</p>\n</blockquote>\n<p>Which leads me to the question: How can an expression be \"a value not associated with an object\"?</p>\n<p>I was under the impression, that it is the purpose of expressions to return objects or <code>void</code> (which I do not expect to be a value either).</p>\n<p>Is there some simple and common example for such expressions?</p>\n<p><strong>Edit 1</strong></p>\n<p>To further complicate things, consider the following:</p>\n<pre><code>int const&amp; x = 3;\nint&amp;&amp; y = 4;\n</code></pre>\n<p>In context of \u00a78.3.2.5, which contains the most interesting snippet:</p>\n<blockquote>\n<p id=\"so_25674834_25674834_2\">[...] A reference shall be initialized to refer to a valid object or\n  function [...]</p>\n</blockquote>\n<p>Which is reinforced by \u00a78.5.3.1:</p>\n<blockquote>\n<p id=\"so_25674834_25674834_3\">A variable declared to be a T&amp; or T&amp;&amp;, that is, \u201creference to type T\u201d (8.3.2), shall be initialized by an object,\n  or function, of type T or by an object that can be converted into a T. [...]</p>\n</blockquote>\n", "AcceptedAnswerId": "25693147", "Title": "What is \"a value not associated with an object\"?", "CreationDate": "2014-09-04T20:54:29.857", "Id": "25674834", "CommentCount": "8", "LastEditDate": "2014-09-04T22:19:58.230", "PostTypeId": "1", "LastEditorUserId": "65678", "LastActivityDate": "2014-09-05T19:59:17.470", "Score": "9", "OwnerUserId": "65678", "Tags": "<c++><c++11><language-lawyer><c++14>", "AnswerCount": "3"}});