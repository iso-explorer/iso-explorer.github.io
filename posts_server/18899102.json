post_cb({"bq_ids": {"n4140": {"so_18899102_18899585_1": {"length": 5, "quality": 1.0, "section_id": 7040}, "so_18899102_18899585_0": {"length": 12, "quality": 1.0, "section_id": 234}, "so_18899102_18899102_0": {"length": 58, "quality": 0.9666666666666667, "section_id": 268}}, "n3337": {"so_18899102_18899585_1": {"length": 5, "quality": 1.0, "section_id": 6785}, "so_18899102_18899585_0": {"length": 12, "quality": 1.0, "section_id": 227}, "so_18899102_18899102_0": {"length": 58, "quality": 0.9666666666666667, "section_id": 259}}, "n4659": {"so_18899102_18899585_1": {"length": 5, "quality": 1.0, "section_id": 8537}, "so_18899102_18899585_0": {"length": 12, "quality": 1.0, "section_id": 244}, "so_18899102_18899102_0": {"length": 58, "quality": 0.9666666666666667, "section_id": 275}}}, "18899102": {"ViewCount": "224", "Body": "<p>Does the C++ standard say anything about the exact point in time, when the code for the virtual methods of class templates is generated?</p>\n<p>Consider the following example:</p>\n<pre><code>class Interface\n{\n  public:\n    virtual void f() = 0;\n};\n\ntemplate &lt;unsigned int V&gt;\nclass A : public Interface\n{\n  public:\n    virtual void f()\n    {\n    }\n};\n\nInterface* instantiate()\n{\n  // class template instantiation with argument V=0\n  return new A&lt;0&gt;();\n}\n\n// specialization of f() for template argument V=0\ntemplate &lt;&gt; void A&lt;0&gt;::f()\n{\n  cout &lt;&lt; \"Output from A&lt;0&gt;::f()\" &lt;&lt; endl;\n};\n\nint main() \n{\n  Interface* i = instantiate();\n  i-&gt;f();\n  return 0;\n}\n</code></pre>\n<p>The class template A declares a virtual method f(). In our example the function instantiate() implicitly instantiates the class template A, before any explicitly specialization of A&lt;0&gt;::f() has been done. In the above example, the specialization is done after implicit instantiation of class template A has happened. Now, at least my ARM-Compiler and g++ pick the specialized version of A&lt;0&gt;::f(), i. e. the main() program prints \u201cOutput from A&lt;0&gt;::f()\u201d to the screen.</p>\n<p>Can I always be sure, that it is sufficient to define the specialization of a virtual method of a class template after this class template has been implicitly instantiated? I would feel better, if the observed behaviour was backed by the C++ standard. I did not find any clear statement about this topic. The closest part would be 14.7.3/6, which is somewhat unspecific when it comes to virtual methods:</p>\n<blockquote>\n<p id=\"so_18899102_18899102_0\">If a template, a member template or the member of a class template is explicitly specialized then that\n  specialization shall be declared before the first use of that specialization that would cause an implicit instan-\n  tiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. If the\n  program does not provide a definition for an explicit specialization and either the specialization is used in a\n  way that would cause an implicit instantiation to take place or the member is a virtual member function,\n  the program is ill-formed, no diagnostic required. An implicit instantiation is never generated for an explicit\n  specialization that is declared but not defined</p>\n</blockquote>\n", "AcceptedAnswerId": "18900490", "Title": "When are vitual methods of a class template instantiated?", "CreationDate": "2013-09-19T15:37:36.690", "Id": "18899102", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-09-19T16:49:24.323", "Score": "2", "OwnerUserId": "1132251", "Tags": "<c++><templates><c++11><g++>", "AnswerCount": "2"}, "18899585": {"Id": "18899585", "PostTypeId": "2", "Body": "<p>The standard is pretty unclear on this. The relevant section on implicit instantiation is 14.7.1p2:</p>\n<blockquote>\n<p id=\"so_18899102_18899585_0\">[...] the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist;</p>\n</blockquote>\n<p>\"requires the definition to exist\" is unfortunately a completely undefined term, but I think a good argument can be made that \"odr-used\" is at least a subset thereof. For \"odr-used\", the big wall of text in 3.2p2 says:</p>\n<blockquote>\n<p id=\"so_18899102_18899585_1\">A virtual member function is odr-used if it is not pure.</p>\n</blockquote>\n<p>In other words, virtual members are required by virtue (no pun intended) of their mere existence.</p>\n<p>So I think an argument can be made that the compiler is at least allowed to try to instantiate all virtual functions the moment it instantiates the containing class. I don't know of any compiler that does that (AFAIK, they all delay instantiation until the end of the translation unit unless forced not to), but I think your code is strictly non-conforming.</p>\n", "LastActivityDate": "2013-09-19T15:58:42.733", "CommentCount": "7", "CreationDate": "2013-09-19T15:58:42.733", "ParentId": "18899102", "Score": "0", "OwnerUserId": "8922"}, "18900490": {"Id": "18900490", "PostTypeId": "2", "Body": "<p>We're pretty sure it's UB.</p>\n<p>In practice:</p>\n<pre><code>new A&lt;0&gt;()\n</code></pre>\n<p>will generate a call to the constructor, and the compiler requires a definition of it to be available. If you try to specialize <code>A&lt;0&gt;::A()</code> after this call gcc will error:</p>\n<pre><code>error: specialization of \u2018A&lt;V&gt;::A() [with V = 0]\u2019 after instantiation\n</code></pre>\n<p>The constructor will have the code to set up the polymorphic header of the class, which will contain a pointer to a vtable.  In that vtable will be the entry for <code>Interface::f</code>, but it doesn't even have declared at this point the symbol that will eventually fill out that slot, your explicit specialization <code>A&lt;0&gt;::f</code> - so it comes down to a quality-of-implementation issue- does the compiler design the vtable at the same time it completes the class type - and if so is it capable of fixing up a newly declared member of that vtable later in the TU.</p>\n", "LastEditorUserId": "1131467", "LastActivityDate": "2013-09-19T16:49:24.323", "Score": "2", "CreationDate": "2013-09-19T16:43:27.490", "ParentId": "18899102", "CommentCount": "10", "OwnerUserId": "1131467", "LastEditDate": "2013-09-19T16:49:24.323"}});