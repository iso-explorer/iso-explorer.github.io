post_cb({"bq_ids": {"n4140": {"so_28111666_28115927_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5838}}, "n3337": {"so_28111666_28115927_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5608}}, "n4659": {"so_28111666_28115927_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 7300}}}, "28111666": {"ViewCount": "696", "Body": "<p>In the following code, <code>while ( !Ref.expired() );</code> is joyfully optimized into an infinite loop. If the line of code is changed to <code>while ( !Ref.lock() );</code>. everything works as expected. So two questions really:</p>\n<p>1) How can the compiler optimize away expired when <code>std::weak_ptr::expired()</code> accesses a memory-fenced counter?</p>\n<p>2) Is <code>Ref.lock()</code> actually safe, or could this too be optimized away?</p>\n<p>Sample code below.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n\nclass A\n{\npublic:\n\n    A() \n    { \n        m_SomePtr = std::make_shared&lt;bool&gt;( false );\n    }\n\n    virtual ~A()\n    {\n        std::weak_ptr&lt;bool&gt; Ref = m_SomePtr;\n        m_SomePtr.reset();\n\n        // Spin (will be optimised into an infinite loop in release builds)\n        while ( !Ref.expired() );\n    }\n\n    std::shared_ptr&lt;bool&gt; GetPtr() const { return m_SomePtr; }\n\nprivate:\n    std::shared_ptr&lt;bool&gt; m_SomePtr;\n};\n\nclass B\n{\npublic:\n    B( std::shared_ptr&lt;bool&gt; SomePtr ) : m_Ref( SomePtr ) {}\n\n    void LockPtr() { m_SomePtr = m_Ref.lock(); }\n    void UnLockPtr() { m_SomePtr.reset(); }\n\nprivate:\n    std::shared_ptr&lt;bool&gt; m_SomePtr;\n    std::weak_ptr&lt;bool&gt; m_Ref;\n};\n\nint main()\n{\n    std::unique_ptr&lt;A&gt; a( new A() );\n    std::unique_ptr&lt;B&gt; b( new B( a-&gt;GetPtr() ) );\n\n    b-&gt;LockPtr();\n\n    std::cout &lt;&lt; \"Starting \" &lt;&lt; std::endl;\n\n    std::thread first( [&amp;]()\n    {\n        std::this_thread::sleep_for( std::chrono::seconds( 5 ) );\n        b-&gt;UnLockPtr();\n    } );\n\n    std::thread second( [&amp;]()\n    {\n        a.reset( nullptr );\n    } );\n\n    first.join();\n    second.join();\n\n    std::cout &lt;&lt; \"Complete\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "Title": "Why is std::weak_ptr::expired optimized away?", "CreationDate": "2015-01-23T14:05:22.373", "LastActivityDate": "2015-08-03T18:42:46.110", "CommentCount": "24", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-08-02T04:06:47.570", "LastEditorUserId": "963864", "Id": "28111666", "Score": "32", "OwnerUserId": "4484040", "Tags": "<c++><multithreading><c++11><visual-c++><shared-ptr>", "AnswerCount": "1"}, "28115927": {"Id": "28115927", "PostTypeId": "2", "Body": "<p>Your program is incorrect; the shared-ownership pointer facilities are not intended to be used for synchronization.</p>\n<p><strong>[intro.multithread]</strong>/24:</p>\n<blockquote>\n<p id=\"so_28111666_28115927_0\">The implementation may assume that any thread will eventually do one of the following:<br/>\n  \u2014 terminate,<br/>\n  \u2014 make a call to a library I/O function,<br/>\n  \u2014 access or modify a volatile object, or<br/>\n  \u2014 perform a synchronization operation or an atomic operation.</p>\n</blockquote>\n<p><code>std::weak_ptr::expired()</code> is not a synchronization operation or an atomic operation; all the Standard says is that it does not introduce a data race. Since the resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3893.html#2316\" rel=\"nofollow\">Library defect 2316</a>, <code>std::weak_ptr::lock()</code> is considered an atomic operation, so to answer 2) your code using <code>Ref.lock()</code> is valid as of C++14.</p>\n<p>Now, it's true that if you were to attempt to create your own library implementation of <code>weak_ptr</code> using the language and library facilities, it would necessarily use the synchronization and/or atomic operation facilities, so a user-provided <code>weak_ptr::expired()</code> would be OK to spin on (the implementation would be obliged to ensure that the thread eventually made progress, per <strong>[intro.multithread]</strong>/2 and /25). But an implementation is not obliged to restrict its own library to the language and library facilities.</p>\n<p>I'm not entirely sure how the compiler is optimizing away the access to <code>expired()</code>. I'd guess that the MSVC library is exploiting aspects of the x86 memory model that the compiler/optimizer observes are not guaranteed by the C++ memory model.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2015-08-03T18:42:46.110", "Score": "8", "CreationDate": "2015-01-23T18:00:29.757", "ParentId": "28111666", "CommentCount": "13", "OwnerUserId": "567292", "LastEditDate": "2015-08-03T18:42:46.110"}});