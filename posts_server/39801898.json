post_cb({"39801988": {"ParentId": "39801898", "CommentCount": "2", "Body": "<p>From [vector.overview]/1</p>\n<blockquote>\n<p id=\"so_39801898_39801988_0\">A <code>vector</code> is a sequence container that supports random access iterators. In addition, it supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, though hints can be given to improve efficiency. <strong>The  elements of a vector are stored contiguously, meaning that if v is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code>.</strong></p>\n</blockquote>\n<p><sup>Emphasis mine</sup></p>\n<p>So since <code>&amp;v[n]</code> is valid for for all <code>n</code> in <code>[0, size())</code> then ever element in the vector has its own unique address.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "39801988", "Score": "1", "CreationDate": "2016-10-01T01:01:35.827", "LastActivityDate": "2016-10-01T01:01:35.827"}, "39801982": {"ParentId": "39801898", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Each element does indeed have a unique address in memory. Basically, let's look at this sample vector:</p>\n<pre><code>template &lt;class T&gt;\nclass vec\n{\npublic:\n vec() ;\n ~vec() ;\n T * elements;\n} \n</code></pre>\n<p>You can see here is just an example of a vector. So what the iterators do is point to each pointer in the element. They may not have a unique address themselves, but they point to each element in the vector. So each iterator has <strong>UNIQUE</strong> memory addresses. </p>\n<p>And like I said in my comments, they can't work differently since the Vectors and their iterators are libraries made by people like you, using C++.  They can't work differently from pointers which are built in the C++ language. </p>\n<p>Also from references: (draft of C++0x):</p>\n<blockquote>\n<p id=\"so_39801898_39801982_0\"><strong>23.2.6 Class template vector [vector]</strong></p>\n<p id=\"so_39801898_39801982_1\">1 A vector is a sequence container that supports random access iterators. In addition, it supports (amortized)\n  constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage\n  management is handled automatically, though hints can be given to improve efficiency. The elements of a\n  <strong>vector are stored contiguously</strong>, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other\n  than bool, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code>.</p>\n</blockquote>\n", "OwnerUserId": "5768335", "LastEditorUserId": "5827958", "LastEditDate": "2016-10-01T01:27:51.100", "Id": "39801982", "Score": "2", "CreationDate": "2016-10-01T01:00:28.287", "LastActivityDate": "2016-10-01T01:27:51.100"}, "39801922": {"ParentId": "39801898", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Although iterators are not necessarily pointers (although for <code>std::vector</code>s most non-debug implementations implement them as thin wrappers around pointers), <code>std::vector</code> is <a href=\"https://stackoverflow.com/q/849168/3093378\"><strong>guaranteed</strong></a> to have its elements contiguous in memory. Which implies that <strong>YES</strong>, every element has a distinct memory location.</p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:33:14.563", "Id": "39801922", "Score": "6", "CreationDate": "2016-10-01T00:47:06.163", "LastActivityDate": "2016-10-01T00:56:50.737"}, "39802132": {"ParentId": "39801898", "CommentCount": "1", "Body": "<p><em>Every</em> object (that exists at a particular time) has a unique address. The elements of a vector are objects <em>(with the exception of the abomination which is the <code>std::vector&lt;bool&gt;</code> specialization)</em>. So yes, they all have unique addresses. Keep in mind though, that when you add elements to a vector, it may reallocate. And when it reallocates, all the old objects are destroyed and moved to new objects with different addresses, and the old memory is free to be reused, perhaps by further reallocations of the same vector. The following is possible, for example:</p>\n<pre><code>std::vector&lt;int&gt; v;\nv.push_back(0);\nstd::intptr_t a0 = (std::intptr_t)&amp;v[0];\n\nv.push_back(1); // a reallocation may happen here\nv.push_back(2); // and perhaps another one here\n\nstd::intptr_t a2 = (std::intptr_t)&amp;v[2];\n\nif (a0 == a2) {\n    std::cout &lt;&lt; \"This code is unlikely to be executed, but technically possible.\";\n}\n</code></pre>\n", "OwnerUserId": "440119", "PostTypeId": "2", "Id": "39802132", "Score": "2", "CreationDate": "2016-10-01T01:26:55.590", "LastActivityDate": "2016-10-01T01:26:55.590"}, "bq_ids": {"n4140": {"so_39801898_39801982_1": {"section_id": 955, "quality": 0.9803921568627451, "length": 50}, "so_39801898_39801988_0": {"section_id": 955, "quality": 0.9803921568627451, "length": 50}}, "n3337": {"so_39801898_39801982_1": {"section_id": 943, "quality": 0.9803921568627451, "length": 50}, "so_39801898_39801988_0": {"section_id": 943, "quality": 0.9803921568627451, "length": 50}}, "n4659": {"so_39801898_39801982_1": {"section_id": 1016, "quality": 0.5294117647058824, "length": 27}, "so_39801898_39801988_0": {"section_id": 1016, "quality": 0.5294117647058824, "length": 27}}}, "39801898": {"CommentCount": "6", "ViewCount": "97", "CreationDate": "2016-10-01T00:42:38.387", "LastActivityDate": "2016-10-01T01:27:51.100", "Title": "Does each element in a vector have a unique memory address?", "AcceptedAnswerId": "39801922", "PostTypeId": "1", "Id": "39801898", "Score": "3", "Body": "<p>Fairly new to C++. Referring to this snippet of code:</p>\n<pre><code>for (std::vector&lt;int&gt;::iterator it = myvector.begin() ; it != myvector.end(); ++it)\nstd::cout &lt;&lt; ' ' &lt;&lt; *it;\nstd::cout &lt;&lt; '\\n';\n</code></pre>\n<p>In particular when initializing the iterator and the end condition. Does each element in the vector have a unique memory address to point to? Or do iterators work differently than pointers?</p>\n", "Tags": "<c++><vector>", "OwnerUserId": "6823864", "AnswerCount": "4"}});