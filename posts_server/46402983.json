post_cb({"bq_ids": {"n4140": {"so_46402983_46403511_1": {"length": 38, "quality": 0.7450980392156863, "section_id": 361}, "so_46402983_46403511_3": {"length": 71, "quality": 0.8452380952380952, "section_id": 460}, "so_46402983_46403511_4": {"length": 49, "quality": 0.8448275862068966, "section_id": 472}, "so_46402983_46403511_2": {"length": 86, "quality": 0.7350427350427351, "section_id": 369}, "so_46402983_46403511_5": {"length": 37, "quality": 1.0, "section_id": 401}, "so_46402983_46403511_0": {"length": 29, "quality": 0.6744186046511628, "section_id": 5914}}, "n3337": {"so_46402983_46403511_1": {"length": 38, "quality": 0.7450980392156863, "section_id": 351}, "so_46402983_46403511_3": {"length": 48, "quality": 0.5714285714285714, "section_id": 451}, "so_46402983_46403511_4": {"length": 55, "quality": 0.9482758620689655, "section_id": 463}, "so_46402983_46403511_2": {"length": 79, "quality": 0.6752136752136753, "section_id": 359}, "so_46402983_46403511_5": {"length": 34, "quality": 0.918918918918919, "section_id": 392}, "so_46402983_46403511_0": {"length": 29, "quality": 0.6744186046511628, "section_id": 5686}}, "n4659": {"so_46402983_46403511_1": {"length": 38, "quality": 0.7450980392156863, "section_id": 373}, "so_46402983_46403511_3": {"length": 72, "quality": 0.8571428571428571, "section_id": 483}, "so_46402983_46403511_4": {"length": 57, "quality": 0.9827586206896551, "section_id": 495}, "so_46402983_46403511_2": {"length": 111, "quality": 0.9487179487179487, "section_id": 382}, "so_46402983_46403511_5": {"length": 37, "quality": 1.0, "section_id": 418}, "so_46402983_46403511_0": {"length": 32, "quality": 0.7441860465116279, "section_id": 7406}}}, "46402983": {"ViewCount": "94", "Body": "<p>For my understanding, the rule of five is a guidelince rule. Altough, I've seen that the compiler in some scenarios may delete functions, implicitly. For example, when defining a move-ctor', the copy assignment/ copy ctor' will be deleted.</p>\n<p>I'd like to know if there are more scenario as the one mentioned. In other words, in which scenarios does user-defined function may delete implicitly other functions?</p>\n<p>Thanks</p>\n<p><strong>EDIT:</strong><br>\na reference to some source which covers the subject would be fine too!</br></p>\n", "AcceptedAnswerId": "46403511", "Title": "rule of five and implicitly deleted functions", "CreationDate": "2017-09-25T10:27:01.943", "LastActivityDate": "2017-09-25T11:05:36.743", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "Tags": "<c++><c++11><rule-of-three>", "Id": "46402983", "Score": "3", "OwnerUserId": "3880275", "ClosedDate": "2017-09-25T11:18:38.023", "AnswerCount": "1"}, "46403511": {"Id": "46403511", "PostTypeId": "2", "Body": "<p>For all of the \"five\", the standard defines the circumstances under which they will be implicitly declared as deleted. I have named and quoted the relevant sections for you from the C++ Standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">N4659</a>:</p>\n<ul>\n<li>(12.3.3) When defining a union, some of the five can be implicitly deleted:\n\n<blockquote>\n<p id=\"so_46402983_46403511_0\">[..] [ Note: Absent default member\n  initializers (12.2), if any non-static data member of a union has a non-trivial default constructor (15.1), copy\n  constructor (15.8), move constructor (15.8), copy assignment operator (15.8), move assignment operator (15.8),\n  or destructor (15.4), the corresponding member function of the union must be user-provided or it will be\n  implicitly deleted (11.4.3) for the union \u2014 end note ]</p>\n</blockquote></li>\n<li>(15.1) The \"five\" are implicitly declared when there is no user defined alternative:\n\n<blockquote>\n<p id=\"so_46402983_46403511_1\">The default constructor (15.1), copy constructor and copy assignment operator (15.8), move constructor\n  and move assignment operator (15.8), and destructor (15.4) are\n  special member functions\n  . [\n  Note:\n  The\n  implementation will implicitly declare these member functions for some class types when the program <strong>does not\n  explicitly declare them</strong>. The implementation will implicitly define them if they are odr-used (6.2). See 15.1,\n  15.4 and 15.8.\n  \u2014 end note\n  ]</p>\n</blockquote></li>\n<li>(15.1.1) Implicit deletion of the constructor:\n\n<blockquote>\n<p id=\"so_46402983_46403511_2\">A defaulted default constructor for class X is defined as deleted if:<br>\n  \u2014 (5.1) X is a union that has a variant member with a non-trivial default constructor and no variant member of X has a default member initializer,<br>\n  \u2014 (5.2) X is a non-union class that has a variant member M with a non-trivial default constructor and no variant member of the anonymous union containing M has a default member initializer,<br>\n  \u2014 (5.3) any non-static data member with no default member initializer (12.2) is of reference type,<br>\n  \u2014 (5.4) any non-variant non-static data member of const-qualified type (or array thereof) with no brace-or- equal-initializer does not have a user-provided default constructor,<br>\n  \u2014 (5.5) X is a union and all of its variant members are of const-qualified type (or array thereof),<br>\n  \u2014 (5.6) X is a non-union class and all members of any anonymous union member are of const-qualified type (or array thereof),<br>\n  \u2014 (5.7) any potentially constructed subobject, except for a non-static data member with a brace-or-equal- initializer , has class type M (or array thereof) and either M has no default constructor or overload resolution (16.3) as applied to find M \u2019s corresponding constructor results in an ambiguity or in a function that is deleted or inaccessible from the defaulted default constructor, or<br>\n  \u2014 (5.8) any potentially constructed subobject has a type with a destructor that is deleted or inaccessible from the defaulted default constructor</br></br></br></br></br></br></br></br></p>\n</blockquote></li>\n<li>(15.8.1.10) Implicit deletion of the copy/move constructor:\n\n<blockquote>\n<p id=\"so_46402983_46403511_3\">A defaulted copy/move constructor for a class X is defined as deleted (11.4.3) if X has:<br>\n  \u2014 (10.1) a variant member with a non-trivial corresponding constructor and X is a union-like class,<br>\n  \u2014 (10.2) a potentially constructed subobject type M (or array thereof) that cannot be copied/moved because overload resolution (16.3), as applied to find M \u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,<br>\n  \u2014 (10.3) any potentially constructed subobject of a type with a destructor that is deleted or inaccessible from the defaulted constructor, or,<br>\n  \u2014 (10.4) for the copy constructor, a non-static data member of rvalue reference type.  A defaulted move constructor that is defined as deleted is ignored by overload resolution (16.3, 16.4). [ Note: A deleted move constructor would otherwise interfere with initialization from an rvalue which can use the copy constructor instead.  \u2014 end note ]  </br></br></br></br></p>\n</blockquote></li>\n<li>(15.8.2) Implicit deletion of copy/move assignment operator:\n\n<blockquote>\n<p id=\"so_46402983_46403511_4\">A defaulted copy/move assignment operator for class X is defined as deleted if X has:<br>\n  \u2014 (7.1) a variant member with a non-trivial corresponding assignment operator and X is a union-like class, or<br>\n  \u2014 (7.2) a non-static data member of const non-class type (or array thereof), or<br>\n  \u2014 (7.3) a non-static data member of reference type, or<br>\n  \u2014 (7.4) a direct non-static data member of class type M (or array thereof) or a direct base class M that cannot be copied/moved because overload resolution (16.3), as applied to find M \u2019s corresponding assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator.  </br></br></br></br></p>\n</blockquote></li>\n<li>(15.4.5) Implicit deletion of the destructor:\n\n<blockquote>\n<p id=\"so_46402983_46403511_5\">A defaulted destructor for a class X is defined as deleted if:<br>\n  \u2014 (5.1) X is a union-like class that has a variant member with a non-trivial destructor,<br>\n  \u2014 (5.2) any potentially constructed subobject has class type M (or array thereof) and M has a deleted destructor or a destructor that is inaccessible from the defaulted destructor,<br>\n  \u2014 (5.3) or, for a virtual destructor, lookup of the non-array deallocation function results in an ambiguity or in a function that is deleted or inaccessible from the defaulted destructor.  </br></br></br></p>\n</blockquote></li>\n</ul>\n", "LastEditorUserId": "8602872", "LastActivityDate": "2017-09-25T11:05:36.743", "Score": "1", "CreationDate": "2017-09-25T10:55:49.710", "ParentId": "46402983", "CommentCount": "1", "LastEditDate": "2017-09-25T11:05:36.743", "OwnerUserId": "8602872"}});