post_cb({"33088812": {"ParentId": "33088586", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Maybe 2 functions instead of a template assignment:</p>\n<pre><code>X&amp; operator=(double that) { d = that; return *this; }\nX&amp; operator=(int that) { d = that; return *this; }\n</code></pre>\n<p>In C++11 there is also <code>std::is_same</code>, see: <a href=\"https://stackoverflow.com/questions/13636540/how-to-check-for-the-type-of-a-template-parameter\">How to check for the type of a template parameter?</a></p>\n", "OwnerUserId": "5438128", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:28.763", "Id": "33088812", "Score": "-1", "CreationDate": "2015-10-12T19:29:29.257", "LastActivityDate": "2015-10-12T20:49:09.377"}, "33088586": {"CommentCount": "7", "ViewCount": "95", "CreationDate": "2015-10-12T19:15:42.823", "LastActivityDate": "2015-10-12T20:49:09.377", "Title": "Template assignment type distinctions", "AcceptedAnswerId": "33088753", "PostTypeId": "1", "Id": "33088586", "Score": "1", "Body": "<p>Class X contains 2 pieces of data. The templated assignment operator accepts any type and assigns it to member 'd'. However I still want copy assignment to work properly. In MSVC 2010 the line 'b = a;' calls the template assignment operator not the copy assignment. How can I overload assignment to distinguish properly or have the template assignment distinguish internally?</p>\n<pre><code>class X\n{\npublic:\n    X() : x(0), d(0.0) {}\n    X(X const &amp; that) { x = that.x; d = that.d; } \n\n    X&amp; operator=(X const &amp; that) { x = that.x; d = that.d; }\n\n    template&lt;typename T&gt;\n    X&amp; operator=(T &amp;&amp; y) {\n        //if (T is X&amp;)\n        //  operator=(static_cast&lt;X const &amp;&gt;(that));\n        //else\n        //  d = y;\n        return *this;\n    }\n\n    int x;\n    double d;\n};\n\nvoid f()\n{\n    X a;\n    X b;\n\n    a = 5;\n    a = 3.2;\n    b = static_cast&lt;X const &amp;&gt;(a);   // calls copy assignment\n    b = a;                           // calls template assignment\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "4581804", "AnswerCount": "2"}, "33088753": {"ParentId": "33088586", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_33088586_33088753_0\">In MSVC 2010 the line 'b = a;' calls the template assignment operator not the copy assignment</p>\n</blockquote>\n<p>It <em>should</em> call the assignment operator template. We have two viable overloads:</p>\n<pre><code>X&amp; operator=(X const &amp;);\nX&amp; operator=(X&amp; ); // [T = X&amp;]\n</code></pre>\n<p>And one of the ways of ordering conversion sequences is, from [over.ics.rank]:</p>\n<blockquote>\n<p id=\"so_33088586_33088753_1\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence\n  S2 if [...]\n  S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same\n  type except for top-level <em>cv</em>-qualifiers, and the type to which the reference initialized by S2 refers is more <em>cv</em>-qualified than the type to which the reference initialized by S1 refers.</p>\n</blockquote>\n<p>The copy assignment operator references a type that is more <em>cv</em>-qualified than the assignment operator template, so the assignment operator template is preferred. The reason your adding the <code>static_cast</code> forces the compiler to select the copy assignment operator is that now both functions take the exact same argument (<code>X const&amp;</code>), and we simply prefer the function that isn't a function template specialization over the one that is. </p>\n<p>The simple way to avoid this is to SFINAE out the operator template so that it doesn't apply to an <code>X</code> or something that derives from <code>X</code>:</p>\n<pre><code>template &lt;typename T,\n          typename = std::enable_if_t&lt;\n              !std::is_base_of&lt;X, std::decay_t&lt;T&gt;&gt;::value\n          &gt;&gt;\nX&amp; operator=(T&amp;&amp; );\n</code></pre>\n<p>This would make the assignment operator template no longer a viable candidate for <code>b=a;</code>, hence the copy assignment operator becomes trivially the best candidate.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "33088753", "Score": "3", "CreationDate": "2015-10-12T19:25:52.150", "LastActivityDate": "2015-10-12T19:25:52.150"}, "bq_ids": {"n4140": {"so_33088586_33088753_0": {"section_id": 466, "quality": 0.5555555555555556, "length": 5}, "so_33088586_33088753_1": {"section_id": 639, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_33088586_33088753_0": {"section_id": 457, "quality": 0.5555555555555556, "length": 5}, "so_33088586_33088753_1": {"section_id": 629, "quality": 0.9354838709677419, "length": 29}}, "n4659": {"so_33088586_33088753_0": {"section_id": 489, "quality": 0.5555555555555556, "length": 5}, "so_33088586_33088753_1": {"section_id": 667, "quality": 0.9354838709677419, "length": 29}}}});