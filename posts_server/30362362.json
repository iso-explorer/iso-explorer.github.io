post_cb({"bq_ids": {"n4140": {"so_30362362_30362664_1": {"length": 14, "quality": 1.0, "section_id": 599}, "so_30362362_30362664_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 599}}, "n3337": {"so_30362362_30362664_1": {"length": 14, "quality": 1.0, "section_id": 589}, "so_30362362_30362664_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 589}}, "n4659": {"so_30362362_30362664_1": {"length": 14, "quality": 1.0, "section_id": 622}, "so_30362362_30362664_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 622}}}, "30362664": {"Id": "30362664", "PostTypeId": "2", "Body": "<pre><code>c.AddString({ {\"1\",1}, {\"2\", 2}, {\"3\", 3} });\n</code></pre>\n<p>You're passing a <em>braced-init-list</em>, which itself contains nested <em>brace-init-list</em>s to <code>AddString</code>. The argument can match the <code>std::initializer_list&lt;std::pair&lt;const char*,int&gt;&gt;</code> parameter if the inner <em>braced-init-list</em>s can be converted to <code>std::pair&lt;const char*,int&gt;</code>. </p>\n<p>This process of overload resolution occurs in two steps; first an attempt is made to match constructors of <code>std::pair</code> that take an <code>std::initializer_list</code> argument. Since <a href=\"http://en.cppreference.com/w/cpp/utility/pair/pair\"><code>std::pair</code></a> has no such constructor, the second step occurs, where the other constructors of <code>std::pair&lt;const char*,int&gt;</code> are enumerated with <code>char const[2]</code> and <code>int</code> as the arguments. This will match the following <code>pair</code> constructor because <code>char const[2]</code> is implicitly convertible to <code>char const *</code> and the constructor itself is not <code>explicit</code>.</p>\n<pre><code>template&lt; class U1, class U2 &gt;\nconstexpr pair( U1&amp;&amp; x, U2&amp;&amp; y );\n</code></pre>\n<hr>\n<p>Quoting N3337 <em>\u00a713.3.1.7/1 [over.match.list]</em></p>\n<blockquote>\n<p id=\"so_30362362_30362664_0\">When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor in two phases:<br/>\n  \u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.<br/>\n  \u2014 <strong>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code></strong> and the argument list consists of the elements of the initializer list. <br/></p>\n<p id=\"so_30362362_30362664_1\">If the initializer list has no elements and <code>T</code> has a default constructor, the first phase is omitted. <strong>In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed</strong>.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2015-05-21T00:37:32.383", "CommentCount": "3", "CreationDate": "2015-05-21T00:37:32.383", "ParentId": "30362362", "Score": "9", "OwnerUserId": "241631"}, "30362362": {"ViewCount": "388", "Body": "<p>Recently I wrote a very simple class.</p>\n<pre><code>class C\n{\npublic:\n    void AddString(std::initializer_list&lt;std::pair&lt;const char*,int&gt;&gt; x)\n    {\n          //irrelevant\n    }\n};\n\nint main()\n {\n           C c;\n           c.AddString({ {\"1\",1}, {\"2\", 2}, {\"3\", 3} });\n           .... //other unimportant stuff\n           return 0;\n }\n</code></pre>\n<p>To my pleasant surprise it compiled and worked correctly.  Can someone please explain to me how the compiler was able to deduce the nested braced initializers were for a <code>std::pair</code>? I am using MSVS 2013.</p>\n", "Title": "std::initializer_list type deduction", "CreationDate": "2015-05-21T00:02:05.833", "LastActivityDate": "2015-05-21T00:50:54.457", "CommentCount": "0", "LastEditDate": "2015-05-21T00:50:54.457", "PostTypeId": "1", "LastEditorUserId": "241631", "Id": "30362362", "Score": "8", "OwnerUserId": "4922543", "Tags": "<c++><c++11><initializer-list><type-deduction><list-initialization>", "AnswerCount": "1"}});