post_cb({"bq_ids": {"n4140": {"so_28928590_28930230_0": {"length": 66, "quality": 0.9565217391304348, "section_id": 6037}, "so_28928590_28930230_1": {"length": 7, "quality": 1.0, "section_id": 411}, "so_28928590_28929939_0": {"length": 11, "quality": 0.6875, "section_id": 404}, "so_28928590_28930230_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_28928590_28929939_2": {"length": 38, "quality": 0.95, "section_id": 7193}, "so_28928590_28929939_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 438}}, "n3337": {"so_28928590_28930230_0": {"length": 65, "quality": 0.9420289855072463, "section_id": 5805}, "so_28928590_28930230_1": {"length": 7, "quality": 1.0, "section_id": 402}, "so_28928590_28929939_0": {"length": 11, "quality": 0.6875, "section_id": 395}, "so_28928590_28930230_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_28928590_28929939_2": {"length": 38, "quality": 0.95, "section_id": 6937}, "so_28928590_28929939_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 429}}, "n4659": {"so_28928590_28930230_0": {"length": 59, "quality": 0.855072463768116, "section_id": 7536}, "so_28928590_28930230_1": {"length": 7, "quality": 1.0, "section_id": 429}, "so_28928590_28929939_0": {"length": 11, "quality": 0.6875, "section_id": 422}, "so_28928590_28930230_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_28928590_28929939_2": {"length": 37, "quality": 0.925, "section_id": 8702}, "so_28928590_28929939_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 458}}}, "28930292": {"Id": "28930292", "PostTypeId": "2", "Body": "<p>Apparently your co-worker is under the impression that as long as you do not dereference an invalid pointer, you are fine.</p>\n<p>He is <strong>wrong</strong>.</p>\n<p>Merely evaluating such a pointer has undefined behaviour. This code is obviously broken.</p>\n", "LastActivityDate": "2015-03-08T18:33:39.133", "CommentCount": "1", "CreationDate": "2015-03-08T18:33:39.133", "ParentId": "28928590", "Score": "2", "OwnerUserId": "560648"}, "28929939": {"Id": "28929939", "PostTypeId": "2", "Body": "<p>You should definitively tell him that it's UB !  !  </p>\n<p><strong>Why ?</strong> </p>\n<blockquote>\n<p id=\"so_28928590_28929939_0\"><strong>12.4/7:</strong> Bases and members are destroyed in the reverse order of the completion of their constructor The objects are detroyed in the\n  reverse order of their constuction.</p>\n<p id=\"so_28928590_28929939_1\"><strong>12.6.2/10:</strong> First (...) virtual base classes are initialized (...) then, direct base classes are initialized</p>\n</blockquote>\n<p>So when destructing a D, first the D members are destructed and then the D sub object, and only then will B be destructed.   </p>\n<p>This code makes sure that <code>f()</code> is called when the B object is destroyed:  </p>\n<pre><code> ~B() { f(this); } \n</code></pre>\n<p>So when a D object is destroyed,  the D suboject is destroyed first, and then ~B() is executed, calling <code>f()</code>.  </p>\n<p>In <code>f()</code> you cast the pointer to a B as pointer to a D. <strong>This is UB:</strong> </p>\n<blockquote>\n<p id=\"so_28928590_28929939_2\"><strong>3.8/5:</strong> (...) after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any\n  pointer that refers to the storage location where the object will be\n  or was located\n  <strong>may be used but only in limited ways</strong>.\n  (...) The program has <strong>undefined behavior</strong> if the pointer is used to access a non-static data member or call a non-static member function of the\n  object, or (...) <strong>the pointer is used as the operand of a static_cast</strong>. </p>\n</blockquote>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2015-03-08T18:31:48.387", "Score": "0", "CreationDate": "2015-03-08T18:02:15.320", "ParentId": "28928590", "CommentCount": "14", "OwnerUserId": "3723423", "LastEditDate": "2015-03-08T18:31:48.387"}, "28930230": {"Id": "28930230", "PostTypeId": "2", "Body": "<p>[expr.static.cast]/p11:</p>\n<blockquote>\n<p id=\"so_28928590_28930230_0\">A prvalue of type \u201cpointer to <em>cv1</em> <code>B</code>,\u201d where B is a class type, can\n  be converted to a prvalue of type \u201cpointer to <em>cv2</em> <code>D</code>,\u201d where <code>D</code> is a\n  class derived (Clause 10) from <code>B</code>, if a valid standard conversion\n  from \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists (4.10), <em>cv2</em> is the\n  same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and\n  <code>B</code> is neither a virtual base class of <code>D</code> nor a base class of a\n  virtual base class of <code>D</code>. The null pointer value (4.10) is converted\n  to the null pointer value of the destination type. If the prvalue of\n  type \u201cpointer to <em>cv1</em> <code>B</code>\u201d points to a <code>B</code> that is actually a subobject\n  of an object of type <code>D</code>, the resulting pointer points to the\n  enclosing object of type <code>D</code>. Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>The question, then, is whether, at the time of the <code>static_cast</code>, the pointer actually points to \"a <code>B</code> that is actually a subobject of an object of type <code>D</code>\". If so, there is no UB; if not, then the behavior is undefined <strong>whether or not the resulting pointer is dereferenced or otherwise used</strong>.</p>\n<p>[class.dtor]/p15 says that (emphasis mine)</p>\n<blockquote>\n<p id=\"so_28928590_28930230_1\">Once a destructor is invoked for an object, the object <strong>no longer\n  exists</strong></p>\n</blockquote>\n<p>and [basic.life]/p1 says that</p>\n<blockquote>\n<p id=\"so_28928590_28930230_2\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>From this, then, the <code>D</code> object's lifetime has ended as soon as its destructor is invoked, and certainly by the time <code>B</code>'s destructor began to execute - which is after <code>D</code>'s destructor body has finished execution. At this point, there is no \"object of type <code>D</code>\" left that this <code>B</code> can be a subobject of - it \"no longer exists\". Thus, you have UB.</p>\n<p>Clang with UBsan will <a href=\"http://coliru.stacked-crooked.com/a/df0100a0248695a4\" rel=\"noreferrer\">report an error</a> on this code if <code>B</code> is made polymorphic (given a virtual function), which supports this reading.</p>\n", "LastActivityDate": "2015-03-08T18:27:44.740", "CommentCount": "6", "CreationDate": "2015-03-08T18:27:44.740", "ParentId": "28928590", "Score": "5", "OwnerUserId": "2756719"}, "28928590": {"ViewCount": "872", "Body": "<p>This is a variant of the questions <a href=\"https://stackoverflow.com/questions/6322949/downcasting-using-the-static-cast-in-c\">Downcasting using the Static_cast in C++</a> and <a href=\"https://stackoverflow.com/questions/21372117/safety-of-invalid-downcast-using-static-cast-or-reinterpret-cast-for-inheritan?rq=1\">Safety of invalid downcast using static_cast (or reinterpret_cast) for inheritance without added members</a> </p>\n<p>I am not clear on the phrase in the standard \"B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object of type D\" with respect to behavior in ~B. If you cast to D in ~B, is it still a subobject at that point ?\nThe following simple example shows the question:</p>\n<pre><code>void f(B* b);\n\nclass B {\npublic:\n  B() {}\n  ~B() { f(this); }\n};\n\nclass D : public B { public: D() {} };\n\nstd::set&lt;D*&gt; ds;\n\nvoid f(B* b) {\n  D* d = static_cast&lt;D*&gt;(b);  // UB or subobject of type D?\n  ds.erase(d);\n}\n</code></pre>\n<p>I know that the cast is an open door to disaster, and doing anything like this from the dtor is a bad idea, but a co-worker claims \"The code is valid and works correctly. That cast is perfectly valid. The comment clearly states that it should not be dereferenced\".</p>\n<p>I pointed out that the cast is unnecessary and we should prefer the protection provided by the type system to comments. The sad part is that he is one of the senior/lead developers and a supposed c++ \"expert\".</p>\n<p>Can I tell him the cast is UB ?</p>\n", "AcceptedAnswerId": "28930230", "Title": "Safety of static_cast to pointer-to-derived class from base destructor", "CreationDate": "2015-03-08T16:02:55.517", "Id": "28928590", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:31:03.237", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-08T18:33:39.133", "Score": "6", "OwnerUserId": "36034", "Tags": "<c++><casting><language-lawyer><static-cast>", "AnswerCount": "3"}});