post_cb({"32795127": {"Id": "32795127", "PostTypeId": "2", "Body": "<p>You just use std::function for callbacks, you can use a simple template helper function that forwards its arguments to the handler if it is not empty:</p>\n<pre><code>template &lt;typename Callback, typename... Ts&gt;\nvoid SendNotification(const Callback &amp; callback, Ts&amp;&amp;... vs)\n{\n    if (callback)\n    {\n        callback(std::forward&lt;Ts&gt;(vs)...);\n    }\n}\n</code></pre>\n<p>And use it in the following way:</p>\n<pre><code>std::function&lt;void(int, double&gt;&gt; myHandler;\n...\nSendNotification(myHandler, 42, 3.15);\n</code></pre>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2015-09-29T19:44:50.087", "Score": "0", "CreationDate": "2015-09-26T08:25:50.263", "ParentId": "7526853", "CommentCount": "0", "LastEditDate": "2015-09-29T19:44:50.087", "OwnerUserId": "809861"}, "7527143": {"Id": "7527143", "PostTypeId": "2", "Body": "<p>In the same way that you can add a nullstate to a functor type that doesn't have one, you can wrap a functor with a class that does not admit a nullstate. The former requires adding state, the latter does not require new state (only a restriction). Thus, while i don't know the rationale of the <code>std::function</code> design, it supports the most lean &amp; mean usage, no matter what you want.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2011-09-23T09:50:10.303", "Score": "0", "CreationDate": "2011-09-23T09:50:10.303", "ParentId": "7526853", "CommentCount": "0", "OwnerUserId": "464581"}, "7527079": {"Id": "7527079", "PostTypeId": "2", "Body": "<p>The answer is probably historical: <code>std::function</code> is meant as a replacement for function pointers, and function pointers had the capability to be <code>NULL</code>. So, when you want to offer easy compatibility to function pointers, you need to offer an invalid state.</p>\n<p>The identifiable invalid state is not really necessary since, as you mentioned, <code>boost::optional</code> does that job just fine. So I'd say that <code>std::function</code>'s are just there for the sake of history.</p>\n", "LastEditorUserId": "225186", "LastActivityDate": "2016-05-10T08:51:11.630", "Score": "5", "CreationDate": "2011-09-23T09:44:16.333", "ParentId": "7526853", "CommentCount": "0", "LastEditDate": "2016-05-10T08:51:11.630", "OwnerUserId": "847601"}, "7526932": {"Id": "7526932", "PostTypeId": "2", "Body": "<p>One of the most common use cases for <code>std::function</code> is to register callbacks, to be called when certain conditions are met. Allowing for uninitialized instances makes it possible to register callbacks only when needed, otherwise you would be forced to always pass at least some sort of no-op function.</p>\n", "LastActivityDate": "2011-09-23T09:31:56.203", "Score": "5", "CreationDate": "2011-09-23T09:31:56.203", "ParentId": "7526853", "CommentCount": "2", "OwnerUserId": "838975"}, "7526853": {"ViewCount": "9390", "Body": "<p>This is probably a philosophical question, but I ran into the following problem:</p>\n<p>If you define an std::function, and you don't initialize it correctly, your application will crash, like this:</p>\n<pre><code>typedef std::function&lt;void(void)&gt; MyFunctionType;\nMyFunctionType myFunction;\nmyFunction();\n</code></pre>\n<p>If the function is passed as an argument, like this:</p>\n<pre><code>void DoSomething (MyFunctionType myFunction)\n   {\n   myFunction();\n   }\n</code></pre>\n<p>Then, of course, it also crashes.  This means that I am forced to add checking code like this:</p>\n<pre><code>void DoSomething (MyFunctionType myFunction)\n   {\n   if (!myFunction) return;\n   myFunction();\n   }\n</code></pre>\n<p>Requiring these checks gives me a flash-back to the old C days, where you also had to check all pointer arguments explicitly:</p>\n<pre><code>void DoSomething (Car *car, Person *person)\n   {\n   if (!car) return;      // In real applications, this would be an assert of course\n   if (!person) return;   // In real applications, this would be an assert of course\n   ...\n   }\n</code></pre>\n<p>Luckily, we can use references in C++, which prevents me from writing these checks (assuming that the caller didn't pass the contents of a nullptr to the function:</p>\n<pre><code>void DoSomething (Car &amp;car, Person &amp;person)\n   {\n   // I can assume that car and person are valid\n   }\n</code></pre>\n<p>So, why do std::function instances have a default constructor?  Without default constructor you wouldn't have to add checks, just like for other, normal arguments of a function.\nAnd in those 'rare' cases where you want to pass an 'optional' std::function, you can still pass a pointer to it (or use boost::optional).</p>\n", "AcceptedAnswerId": "7527145", "Title": "Why do std::function instances have a default constructor?", "CreationDate": "2011-09-23T09:24:41.713", "Id": "7526853", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-04-29T15:57:13.720", "LastEditorUserId": "50776", "LastActivityDate": "2016-05-10T08:51:11.630", "Score": "13", "OwnerUserId": "163551", "Tags": "<c++><std-function>", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_7526853_7527115_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 4648}}, "n3337": {"so_7526853_7527115_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 4459}}, "n4659": {"so_7526853_7527115_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6016}}}, "7527145": {"Id": "7527145", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7526853_7527145_0\">True, but this is also true for other types. E.g. if I want my class to have an optional Person, then I make my data member a Person-pointer. Why not do the same for std::functions? What is so special about std::function that it can have an 'invalid' state?</p>\n</blockquote>\n<p>It does not have an \"invalid\" state. It is no more invalid than this:</p>\n<pre><code>std::vector&lt;int&gt; aVector;\naVector[0] = 5;\n</code></pre>\n<p>What you have is an <em>empty</em> <code>function</code>, just like <code>aVector</code> is an empty <code>vector</code>. The object is in a very well-defined state: the state of not having data.</p>\n<p>Now, let's consider your \"pointer to function\" suggestion:</p>\n<pre><code>void CallbackRegistrar(..., std::function&lt;void()&gt; *pFunc);\n</code></pre>\n<p>How do you have to call that? Well, here's one thing you <em>cannot</em> do:</p>\n<pre><code>void CallbackFunc();\nCallbackRegistrar(..., CallbackFunc);\n</code></pre>\n<p>That's not allowed because <code>CallbackFunc</code> is a function, while the parameter type is a <code>std::function&lt;void()&gt;*</code>. Those two are not convertible, so the compiler will complain. So in order to do the call, you have to do this:</p>\n<pre><code>void CallbackFunc();\nCallbackRegistrar(..., new std::function&lt;void()&gt;(CallbackFunc));\n</code></pre>\n<p>You have just introduced <code>new</code> into the picture. You have allocated a resource; who is going to be responsible for it? <code>CallbackRegistrar</code>? Obviously, you might want to use some kind of smart pointer, so you clutter the interface even more with:</p>\n<pre><code>void CallbackRegistrar(..., std::shared_ptr&lt;std::function&lt;void()&gt;&gt; pFunc);\n</code></pre>\n<p>That's a lot of API annoyance and cruft, just to pass a function around. The simplest way to avoid this is to allow <code>std::function</code> to be <em>empty</em>. Just like we allow <code>std::vector</code> to be empty. Just like we allow <code>std::string</code> to be empty. Just like we allow <code>std::shared_ptr</code> to be empty. And so on.</p>\n<p>To put it simply: <code>std::function</code> <em>contains</em> a function. It is a holder for a callable type. Therefore, there is the possibility that it contains no callable type.</p>\n", "LastActivityDate": "2011-09-23T09:50:14.400", "Score": "13", "CreationDate": "2011-09-23T09:50:14.400", "ParentId": "7526853", "CommentCount": "4", "OwnerUserId": "734069"}, "7526945": {"Id": "7526945", "PostTypeId": "2", "Body": "<p>There are cases where you cannot initialize everything at construction (for example, when a parameter depends on the effect on another construction that in turn depends on the effect on the first ...).</p>\n<p>In this cases, you have necessarily to break the loop, admitting an identifiable invalid state to be corrected later.\nSo you construct the first as \"null\", construct the second element, and reassign the first.</p>\n<p>You can, actually, avoid checks, if -where a function is used- you grant that inside the constructor of the object that embeds it, you will always return after a valid reassignment.</p>\n", "LastActivityDate": "2011-09-23T09:32:50.043", "Score": "1", "CreationDate": "2011-09-23T09:32:50.043", "ParentId": "7526853", "CommentCount": "0", "OwnerUserId": "924727"}, "7527115": {"Id": "7527115", "PostTypeId": "2", "Body": "<p>Actually, your application should not crash.</p>\n<blockquote>\n<p id=\"so_7526853_7527115_0\"><strong>\u00a7 20.8.11.1 Class bad_function_call [func.wrap.badcall]</strong></p>\n<p id=\"so_7526853_7527115_1\"><strong>1/</strong> An exception of type <code>bad_function_call</code> is thrown by <code>function::operator()</code> (20.8.11.2.4) when the function wrapper object has no target.</p>\n</blockquote>\n<p>The behavior is perfectly specified.</p>\n", "LastActivityDate": "2011-09-23T09:48:02.247", "Score": "9", "CreationDate": "2011-09-23T09:48:02.247", "ParentId": "7526853", "CommentCount": "2", "OwnerUserId": "147192"}});