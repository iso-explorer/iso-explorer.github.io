post_cb({"6415754": {"Id": "6415754", "PostTypeId": "2", "Body": "<p>Explicit specialization and explicit instantiation do not declare a template. They declare a <em>template-id</em> which refers to a specialization, which is a class.</p>\n<p>However, this doesn't validate my example. The problem is that <em>everything</em> declared following <code>template</code> or <code>template&lt;&gt;</code> is part of the explicit instantiation or specialization, respectively. Only certain types of entities may be specialized or instantiated, and previously-undeclared names aren't one of them.</p>\n<p>Consider these examples making gratuitous, but legal use of elaborated-type-specifiers (\u00a77.1.5.3):</p>\n<pre><code>template&lt; typename T &gt; struct s;\ntemplate&lt; typename T &gt; s&lt; int &gt; *f() {}\n\ntemplate&lt;&gt; struct u *f&lt; char &gt;(); // struct u is declared\nu *p = 0; // see, we can use its name now.\ntemplate&lt;&gt; struct s&lt; int &gt; *f&lt; int &gt;(); // s&lt;int&gt; declared but not specialized\ntemplate struct s&lt; int &gt; *f&lt; long &gt;(); // s&lt;int&gt; declared but not instantiated\n</code></pre>\n<p>As far as I can tell, the Standard is fuzzy about specifying which declared name is the one specialized. The language does weakly imply that each such declaration applies to only one template: \u00a714.7.2/2</p>\n<blockquote>\n<p id=\"so_6304259_6415754_0\">If the explicit instantiation is for a class, a function or a member template specialization\u2026</p>\n</blockquote>\n<p>and \u00a714.7.3/2</p>\n<blockquote>\n<p id=\"so_6304259_6415754_1\">An explicit specialization shall be declared in the namespace of which the template is a member\u2026</p>\n</blockquote>\n<p>The only way to resolve this is to ignore the type declaration if the declarator also specifies a legal instantiation/specialization.</p>\n<p>Getting to the point, the examples in the question specify <em>illegal</em> specializations in the declarator and then expect the compiler to backtrack and specialize the type instead. Given the explicit lists of what specializations and declarations are allowed to do in \u00a714.7.2/1 and \u00a714.7.3/1, it seems more reasonable to complain about <code>template&lt;&gt; struct t&lt; int &gt; {} r;</code> that <code>r</code> is not a function template, member function template, static data member of a class template, etc.</p>\n", "LastActivityDate": "2011-06-20T18:30:52.393", "CommentCount": "0", "CreationDate": "2011-06-20T18:30:52.393", "ParentId": "6304259", "Score": "1", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_6304259_6415754_0": {"length": 7, "quality": 1.0, "section_id": 252}, "so_6304259_6304259_1": {"length": 12, "quality": 1.0, "section_id": 135}, "so_6304259_6304259_0": {"length": 18, "quality": 0.9, "section_id": 50}, "so_6304259_6415754_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 255}}, "n3337": {"so_6304259_6415754_0": {"length": 7, "quality": 1.0, "section_id": 243}, "so_6304259_6304259_1": {"length": 12, "quality": 1.0, "section_id": 129}, "so_6304259_6304259_0": {"length": 18, "quality": 0.9, "section_id": 45}, "so_6304259_6415754_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 246}}, "n4659": {"so_6304259_6415754_0": {"length": 7, "quality": 1.0, "section_id": 259}, "so_6304259_6304259_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 139}, "so_6304259_6304259_0": {"length": 18, "quality": 0.9, "section_id": 51}, "so_6304259_6415754_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 262}}}, "6304619": {"Id": "6304619", "PostTypeId": "2", "Body": "<p>Several points: first, explicit specializations are not in a nether\nregion between templates and classes; an explicit specialization is a\nclass, period.  The only relation is has with templates (except for the\nfunny name) is that it will be used instead of a template instantiation\nif the template is to be instantiated on the specialization type.</p>\n<p>Secondly, if there is a problem with the paragraph in \u00a714/3 that you\ncite, it is that it includes explicit instantiation; an explicit\ninstantiation is a class definition, and if</p>\n<pre><code>struct S {} s, *p;\n</code></pre>\n<p>is legal,</p>\n<pre><code>template&lt;&gt; struct T&lt;int&gt; {} s, *p;\n</code></pre>\n<p>should be too.  (I would argue against allowing either, but that train\nhas already left the station, and since C allows the first, we're stuck\nwith it.)</p>\n<p>Otherwise, the statement in \u00a714/3 is a bit irrelevant.  A function\ntemplate must have exactly one declarator, and a class template exactly\nzero; there's no need to try to englobe them both in some \"at most one\"\ngobbledygook.  (If I were designing the language from scratch, I'd not\nallow any declarator in a declaration which defined a class or enum\ntype.  But again, it's too late for that.)</p>\n<p>And I agree that it's a bother:</p>\n<pre><code>template&lt;&gt; struct T&lt;int&gt; {};    //  Requires a ';'\ntemplate&lt;&gt; void f&lt;int&gt;() {}     //  ';' forbidden\n</code></pre>\n<p>(At least C++11 will allow a semicolon after the function definition.)</p>\n", "LastActivityDate": "2011-06-10T09:43:10.453", "CommentCount": "8", "CreationDate": "2011-06-10T09:43:10.453", "ParentId": "6304259", "Score": "13", "OwnerUserId": "649665"}, "6304259": {"ViewCount": "3412", "Body": "<p>It would be nice if this code were invalid. But it's conceptually sound, and GCC <a href=\"http://ideone.com/kO2aC\" rel=\"nofollow\">accepts it</a> although Comeau doesn't:</p>\n<pre><code>template&lt; typename &gt; struct t;\n\ntemplate&lt;&gt; struct t&lt; int &gt; {} r; // Bad declarator! Don't pee on the carpet!\n</code></pre>\n<p>(<strong>Edit:</strong> the above compiles but <code>r</code> seems no to be declared <a href=\"http://ideone.com/KkV1n\" rel=\"nofollow\">into any scope</a>, so it is essentially ignored.)</p>\n<p>Explicit specializations populate a kind of nether region between templates and classes. The type declared by an explicit specialization is complete once it is defined. From the compiler's standpoint, it is not a template. If it were a parameterized template, declaring an object would be impossible. Consider \u00a714/3:</p>\n<blockquote>\n<p id=\"so_6304259_6304259_0\">In a template-declaration, explicit specialization, or explicit instantiation the init-declarator-list in the dec- laration shall contain at most one declarator. When such a declaration is used to declare a class template, no declarator is permitted.</p>\n</blockquote>\n<p>What does \"is used to declare a class template\" mean? Clearly a primary template declares a class template. And a partial specialization does too, according to \u00a714.5.5/1 (FDIS numbers):</p>\n<blockquote>\n<p id=\"so_6304259_6304259_1\">A template declaration in which the class template name is a simple-template-id is a partial specialization of the class template named in the simple-template-id.</p>\n</blockquote>\n<p>When it comes to explicit specializations, though, the Standard speaks in terms of a declaration preceded by the token sequence <code>template&lt;&gt;</code>. It <em>looks</em> like a template and it names a template-name, but it doesn't seem to declare a template.</p>\n<p>The really bizarre thing is that \u00a714/3 restricts the number of declarators to \"at most one.\" A function template declaration, explicit specialization or instantiation must have exactly one declarator. Any declaration involving a class template must have exactly zero\u2026 except explicit specialization, which seems to fall through the cracks. Faithfully, GCC <a href=\"http://ideone.com/G5ZEg\" rel=\"nofollow\">refuses to allow</a> </p>\n<pre><code>template&lt;&gt; struct t&lt; int &gt; {} r, s; // Offer valid one per specialization.\n</code></pre>\n<p>I tend to agree with GCC's interpretation, nonsense as it may be. Unfortunately, it may be <a href=\"http://gcc.gnu.org/bugzil\" rel=\"nofollow\">inhibiting</a> its ability to detect missing semicolons. Please, let the number of allowed declarators be exactly zero!</p>\n", "AcceptedAnswerId": "6415754", "Title": "Can a class template explicit specialization also declare something else?", "CreationDate": "2011-06-10T09:09:09.000", "Id": "6304259", "CommentCount": "2", "LastEditDate": "2011-06-20T19:08:39.593", "PostTypeId": "1", "LastEditorUserId": "153285", "LastActivityDate": "2011-06-20T19:08:39.593", "Score": "11", "OwnerUserId": "153285", "Tags": "<c++><templates><explicit-specialization>", "AnswerCount": "2"}});