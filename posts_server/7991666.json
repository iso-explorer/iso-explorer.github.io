post_cb({"7991666": {"CommentCount": "2", "ViewCount": "961", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-11-03T07:52:50.887", "LastActivityDate": "2014-11-27T13:59:08.183", "Title": "What is hidden slicing copy constructor?", "AcceptedAnswerId": "7991919", "LastEditDate": "2017-05-23T10:34:45.073", "Id": "7991666", "Score": "0", "Body": "<p>This question is because of <a href=\"https://stackoverflow.com/questions/7981845/c-nested-try-catch-tricky\">this question and the comments</a>.</p>\n<p>This example :  </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    A(int value) : m_value(value) { }\n    int m_value;\n};\n\nstruct B : A {\n    B(int value) : A (value) { }\n};\n\nint main()\n{\n    try {\n        throw B(5);\n    }\n    catch(A) {\n        std::cout &lt;&lt; \"A catch\" &lt;&lt; std::endl;\n    }\n    catch(B) {\n        std::cout &lt;&lt; \"B catch\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>when compiled using g++ 4.6.1 like this :  </p>\n<pre><code>g++ exception_slicing.cpp -ansi -pedantic -Wall -Wextra\n</code></pre>\n<p>produces next output :  </p>\n<pre><code>exception_slicing.cpp: In function 'int main()':\nexception_slicing.cpp:20:5: warning: exception of type 'B' will be caught [enabled by default]\nexception_slicing.cpp:17:5: warning:    by earlier handler for 'A' [enabled by default]\n</code></pre>\n<p>and the output is <code>A catch</code>.</p>\n<p>I understand that the 1st catch block triggered because of <a href=\"https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c\">the slicing problem</a>.  </p>\n<ol>\n<li>Where does it say about hidden copy constructor in the base class?  </li>\n<li>Where does it say about this behaviour?  </li>\n</ol>\n<p>PS1 Please provide answers with quote from the standard.<br>\nPS2 And I am aware that the exceptions should be handled by const reference.</br></p>\n", "Tags": "<c++><language-lawyer><copy-constructor><object-slicing>", "OwnerUserId": "476681", "AnswerCount": "4"}, "7991832": {"ParentId": "7991666", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_7991666_7991832_0\">Where does it say about hidden copy constructor in the base class? </p>\n</blockquote>\n<p>The standard says nothing about a \"hidden copy constructor.\" It does say stuff about an implicitly-defined copy constructor.</p>\n<p>If you must have a quote:</p>\n<blockquote>\n<p id=\"so_7991666_7991832_1\">If the class definition does not explicitly declare a copy constructor, there is no user-declared move constructor, one is declared implicitly.</p>\n</blockquote>\n<p>In C++11, this can be declared <code>default</code> or <code>delete</code>, depending on the contents of the class in question. I'm not going to copy and paste the full list of reasons why a class might not be copyable. But suffice it to say, your class will get a <code>default</code> copy constructor.</p>\n<blockquote>\n<p id=\"so_7991666_7991832_2\">Where does it say about this behaviour? </p>\n</blockquote>\n<p>About what behavior? The behavior you see is exactly what you would expect to see in the following case:</p>\n<pre><code>void foo(A) {}\n\nvoid main() {\n  foo(B());\n}\n</code></pre>\n<p>You get slicing, because the parameter is taken by value. Which requires a copy.</p>\n<p>Exception handlers are not like function calls; C++ will not choose the closest match. It will choose the <em>first</em> valid match. And since <code>B</code> <strong>is an</strong> <code>A</code>, it therefore matches <code>catch(A)</code>.</p>\n<p>Again, if you need some kind of quote (though I don't know why; any basic C++ book that describes exception handling will tell you this):</p>\n<blockquote>\n<p id=\"so_7991666_7991832_3\">The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that can never be executed, for example by placing a handler for a derived class after a handler for a corresponding base class.</p>\n</blockquote>\n<p>Note that they even give an example that is exactly your example.</p>\n<blockquote>\n<p id=\"so_7991666_7991832_4\">And I am aware that the exceptions should be handled by const reference.</p>\n</blockquote>\n<p>And this is <em>why</em> you take exceptions by reference.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "7991832", "Score": "0", "CreationDate": "2011-11-03T08:16:11.293", "LastActivityDate": "2011-11-03T08:16:11.293"}, "7991919": {"ParentId": "7991666", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_7991666_7991919_0\">1 Where does it say about hidden copy constructor in the base class?</p>\n</blockquote>\n<p>It's not hidden as much as it is implicit.</p>\n<p>Using <code>n3290</code>:</p>\n<blockquote>\n<p id=\"so_7991666_7991919_1\"><strong>\u00a7 12 Special member functions</strong></p>\n<p id=\"so_7991666_7991919_2\"><strong>1/</strong> The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor and move assignment operator (12.8), and destructor (12.4) are special member functions. [ Note: The implementation will implicitly declare these member functions for some class types when the program does not explicitly declare them. The implementation will implicitly define them if they are odr-used (3.2). See 12.1, 12.4 and 12.8. \u2014end note ]</p>\n</blockquote>\n<p>So, let us follow the pointer:</p>\n<blockquote>\n<p id=\"so_7991666_7991919_3\"><strong>\u00a7 12.8 Copying and moving class objects</strong></p>\n<p id=\"so_7991666_7991919_4\"><strong>7/</strong> If the class definition does not explicitly declare a copy constructor, one is declared implicitly. [...]</p>\n<p id=\"so_7991666_7991919_5\"><strong>8/</strong> The implicitly-declared copy constructor for a class X will have the form</p>\n<p id=\"so_7991666_7991919_6\"><code>X::X(const X&amp;)</code></p>\n<p id=\"so_7991666_7991919_7\">if<br>\n  \u2014 each direct or virtual base class B of X has a copy constructor whose first parameter is of type <code>const B&amp;</code> or <code>const volatile B&amp;</code>, and<br>\n  \u2014 for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a copy constructor whose first parameter is of type <code>const M&amp;</code> or const volatile <code>M&amp;</code>.  </br></br></p>\n<p id=\"so_7991666_7991919_8\">Otherwise, the implicitly-declared copy constructor will have the form</p>\n<p id=\"so_7991666_7991919_9\"><code>X::X(X&amp;)</code></p>\n</blockquote>\n<p>And there you have it. In your case, there is a copy constructor <code>A::A(A const&amp;)</code> implicitly defined for you.</p>\n<hr>\n<blockquote>\n<p id=\"so_7991666_7991919_10\">2 Where does it say about this behaviour?</p>\n</blockquote>\n<p>Unsuprisingly, in the part devoted to exception handling.</p>\n<blockquote>\n<p id=\"so_7991666_7991919_11\"><strong>\u00a7 15.3 Handling an exception</strong></p>\n<p id=\"so_7991666_7991919_12\"><strong>3/</strong> A handler is a match for an exception object of type E if</p>\n<p id=\"so_7991666_7991919_13\">[...]</p>\n<p id=\"so_7991666_7991919_14\">\u2014 the handler is of type cv <code>T</code> or cv <code>T&amp;</code> and <code>T</code> is an unambiguous public base class of <code>E</code>, or</p>\n<p id=\"so_7991666_7991919_15\">[...]</p>\n</blockquote>\n<p>It is very similar to parameter passing in functions. Because <code>B</code> publicly inherits from <code>A</code>, an instance of <code>B</code> can be passed as a <code>A const&amp;</code>. Since a copy constructor is not explicit (hum...), <code>B</code> is convertible into a <code>A</code>, and therefore, as for functions, a <code>B</code> can be passed where a <code>A</code> (no reference) is expected.</p>\n<p>The Standard goes on:</p>\n<blockquote>\n<p id=\"so_7991666_7991919_16\"><strong>4/</strong> The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that can never be executed, for example by placing a handler for a derived class after a handler for a corresponding base class.</p>\n</blockquote>\n<p>Which is really what this warning is all about.</p>\n</hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "7991919", "Score": "1", "CreationDate": "2011-11-03T08:24:30.370", "LastActivityDate": "2011-11-03T08:24:30.370"}, "7991695": {"ParentId": "7991666", "LastEditDate": "2011-11-03T08:04:32.437", "CommentCount": "2", "CreationDate": "2011-11-03T07:57:35.593", "OwnerUserId": "469220", "LastEditorUserId": "514235", "PostTypeId": "2", "Id": "7991695", "Score": "3", "Body": "<p>In your case, same warning pops up even if you catch by const reference, where no slicing occurs. Your problem is that since <code>B</code> is a <strong>public</strong> subclass of <code>A</code> ==&gt; every <code>B</code> is-a <code>A</code>, so it can be caught by the first handler. You should probably order handlers from most specific to least specific.</p>\n<p>Also, you're printing <code>\"A\"</code> in both <code>catch</code> blocks.</p>\n", "LastActivityDate": "2011-11-03T08:04:32.437"}, "bq_ids": {"n4140": {"so_7991666_7991919_4": {"section_id": 456, "quality": 1.0, "length": 10}, "so_7991666_7991832_1": {"section_id": 456, "quality": 0.7142857142857143, "length": 10}, "so_7991666_7991832_3": {"section_id": 3349, "quality": 0.92, "length": 23}, "so_7991666_7991919_14": {"section_id": 3348, "quality": 0.8333333333333334, "length": 5}, "so_7991666_7991919_16": {"section_id": 3349, "quality": 0.92, "length": 23}, "so_7991666_7991919_0": {"section_id": 467, "quality": 0.5555555555555556, "length": 5}, "so_7991666_7991919_8": {"section_id": 457, "quality": 1.0, "length": 7}, "so_7991666_7991919_12": {"section_id": 3348, "quality": 0.8, "length": 4}, "so_7991666_7991919_2": {"section_id": 361, "quality": 0.7254901960784313, "length": 37}, "so_7991666_7991832_0": {"section_id": 467, "quality": 0.5555555555555556, "length": 5}, "so_7991666_7991919_7": {"section_id": 467, "quality": 0.8571428571428571, "length": 30}, "so_7991666_7991919_5": {"section_id": 457, "quality": 0.875, "length": 7}}, "n3337": {"so_7991666_7991919_4": {"section_id": 447, "quality": 1.0, "length": 10}, "so_7991666_7991832_1": {"section_id": 447, "quality": 0.7142857142857143, "length": 10}, "so_7991666_7991832_3": {"section_id": 3219, "quality": 0.92, "length": 23}, "so_7991666_7991919_14": {"section_id": 3218, "quality": 0.8333333333333334, "length": 5}, "so_7991666_7991919_16": {"section_id": 3219, "quality": 0.92, "length": 23}, "so_7991666_7991919_12": {"section_id": 3218, "quality": 0.8, "length": 4}, "so_7991666_7991919_0": {"section_id": 458, "quality": 0.5555555555555556, "length": 5}, "so_7991666_7991919_8": {"section_id": 448, "quality": 1.0, "length": 7}, "so_7991666_7991832_0": {"section_id": 458, "quality": 0.5555555555555556, "length": 5}, "so_7991666_7991919_2": {"section_id": 351, "quality": 0.7254901960784313, "length": 37}, "so_7991666_7991919_7": {"section_id": 448, "quality": 1.0, "length": 35}, "so_7991666_7991919_5": {"section_id": 448, "quality": 0.875, "length": 7}}, "n4659": {"so_7991666_7991832_1": {"section_id": 479, "quality": 0.7142857142857143, "length": 10}, "so_7991666_7991832_3": {"section_id": 4116, "quality": 0.92, "length": 23}, "so_7991666_7991919_14": {"section_id": 4115, "quality": 1.0, "length": 6}, "so_7991666_7991919_16": {"section_id": 4116, "quality": 0.92, "length": 23}, "so_7991666_7991919_12": {"section_id": 4115, "quality": 1.0, "length": 5}, "so_7991666_7991919_0": {"section_id": 490, "quality": 0.5555555555555556, "length": 5}, "so_7991666_7991919_8": {"section_id": 480, "quality": 1.0, "length": 7}, "so_7991666_7991919_4": {"section_id": 479, "quality": 1.0, "length": 10}, "so_7991666_7991919_2": {"section_id": 373, "quality": 0.7254901960784313, "length": 37}, "so_7991666_7991832_0": {"section_id": 490, "quality": 0.5555555555555556, "length": 5}, "so_7991666_7991919_7": {"section_id": 490, "quality": 0.8571428571428571, "length": 30}, "so_7991666_7991919_5": {"section_id": 480, "quality": 0.875, "length": 7}}}, "7991762": {"ParentId": "7991666", "LastEditDate": "2011-11-03T08:31:02.027", "CommentCount": "4", "CreationDate": "2011-11-03T08:06:21.673", "OwnerUserId": "694509", "LastEditorUserId": "694509", "PostTypeId": "2", "Id": "7991762", "Score": "1", "Body": "<p>The example you give doesn't really demonstrate slicing, it's simply warning you that since B is-a A, the catch(A) effectively hides the catch(B).</p>\n<p>To see the effects of slicing, you would have to do something with the A in the catch:</p>\n<pre><code>catch(A a) {\n    // Will always print class A, even when B is thrown.\n    std::cout &lt;&lt; typeid(a).name() &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2011-11-03T08:31:02.027"}});