post_cb({"bq_ids": {"n4140": {"so_25836109_25836942_0": {"length": 18, "quality": 0.9, "section_id": 603}, "so_25836109_25836942_1": {"length": 6, "quality": 0.75, "section_id": 603}, "so_25836109_25836942_3": {"length": 5, "quality": 1.0, "section_id": 111}, "so_25836109_25836942_4": {"length": 49, "quality": 0.8596491228070176, "section_id": 571}}, "n3337": {"so_25836109_25836942_0": {"length": 18, "quality": 0.9, "section_id": 593}, "so_25836109_25836942_1": {"length": 6, "quality": 0.75, "section_id": 593}, "so_25836109_25836942_3": {"length": 5, "quality": 1.0, "section_id": 106}, "so_25836109_25836942_4": {"length": 49, "quality": 0.8596491228070176, "section_id": 562}}, "n4659": {"so_25836109_25836942_0": {"length": 18, "quality": 0.9, "section_id": 629}, "so_25836109_25836942_1": {"length": 6, "quality": 0.75, "section_id": 629}, "so_25836109_25836942_3": {"length": 5, "quality": 1.0, "section_id": 115}, "so_25836109_25836942_4": {"length": 49, "quality": 0.8596491228070176, "section_id": 594}}}, "25836800": {"Id": "25836800", "PostTypeId": "2", "Body": "<p>As a general rule, if a template and a non-template function are otherwise equally good matches, the non-template version is chosen over the template version. Since your <code>any</code> copy/move constructors are non-template, for rvalues or constant lvalues they take precedence over the template constructors.</p>\n<p><strong>However</strong> thanks due the special rules for rvalue reference templates, the deduced type for <code>template&lt;typename ValueType&gt; any(ValueType &amp;&amp;);</code> will be <code>any&amp;</code> which is a <em>better</em> match. Therefore when copying a non-const lvalue, you'll call the templated constructor.</p>\n<p>Therefore you need an SFINAE rule for that templated constructor, but not for the templated constructor taking an lvalue reference to const.</p>\n", "LastEditorUserId": "1032073", "LastActivityDate": "2014-09-14T19:04:34.937", "Score": "3", "CreationDate": "2014-09-14T18:48:23.837", "ParentId": "25836109", "CommentCount": "3", "OwnerUserId": "1032073", "LastEditDate": "2014-09-14T19:04:34.937"}, "25836109": {"ViewCount": "673", "Body": "<p>Imagine writing something like <a href=\"http://www.boost.org/doc/libs/1_56_0/doc/html/boost/any.html\" rel=\"nofollow\"><code>boost::any</code></a>:</p>\n<pre><code>class any {\npublic:\n  any();\n  any(const any &amp;);\n  any(any &amp;&amp;);\n  template&lt;typename ValueType&gt; any(const ValueType &amp;);\n  template&lt;typename ValueType&gt; any(ValueType &amp;&amp;);\n</code></pre>\n<p>Will the appropriate (copy/move) constructor be called for any possible <code>any</code>? Or does it have to be written with SFINAE e.g. like this:</p>\n<pre><code>template&lt;typename ValueType,\n  typename = typename std::enable_if&lt;\n    !std::is_same&lt;any, typename std::decay&lt;ValueType&gt;::type&gt;::value\n  &gt;::type&gt;\n  any(const ValueType&amp; value)\ntemplate&lt;typename ValueType,\n  typename = typename std::enable_if&lt;\n    !std::is_same&lt;any, typename std::decay&lt;ValueType&gt;::type&gt;::value\n  &gt;::type&gt;\n  any(ValueType&amp;&amp; value)\n</code></pre>\n<p><strong>The question is:</strong> Do I need to protect the templated constructor (to construct <code>any</code> from some value) or I can leave it, because the non-template (copy/move) constructor will always be matched for <code>any</code>? What about <code>volatile</code> modifier or some strange <code>std::move((const any&amp;)it)</code> if that is possible?</p>\n<p>Answer describing the search for the constructor will be most appriciated, thank you.</p>\n<p><strong>EDIT:</strong> Constructing <code>any</code> containing another <code>any</code> would be a problem, I definitelly want to avoid that (the SFINAE makes sure it cannot happen).</p>\n", "AcceptedAnswerId": "25836942", "Title": "Template constructor vs. non-template constructor in class any", "CreationDate": "2014-09-14T17:40:53.037", "Id": "25836109", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-09-14T17:51:18.563", "LastEditorUserId": "1722660", "LastActivityDate": "2014-09-15T09:57:40.450", "Score": "3", "OwnerUserId": "1722660", "Tags": "<c++>", "AnswerCount": "2"}, "25836942": {"Id": "25836942", "PostTypeId": "2", "Body": "<p>With C++11 and the introduction of <em>Universal Reference</em> (and a constructor with such parameter) the rules of overload resolution will choose the templated version.</p>\n<p>The truth is that if the compiler can choose between templated and non-templated function, it will go with the non-template. But it will do so <strong>only if they are equally good</strong>:</p>\n<blockquote>\n<h3>\u00a7 13.3.3 Best viable function <code>[over.match.best]</code></h3>\n<ol>\n<li><p id=\"so_25836109_25836942_0\">[...] Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments <em>i</em>, ICS<sub><em>i</em></sub>(F1) is <strong>not a worse</strong> conversion sequence than ICS<sub><em>i</em></sub>(F2), and then</p>\n<p id=\"so_25836109_25836942_1\">\u2014 for some argument <em>j</em>, ICS<sub><em>j</em></sub>(F1) is a <strong>better conversion</strong> sequence than ICS<sub><em>j</em></sub>(F2), or, <strong>if not that</strong>,</p>\n<p id=\"so_25836109_25836942_2\">[...]</p>\n<p id=\"so_25836109_25836942_3\">\u2014 F1 is a non-template function and F2 is a function template specialization, [...]</p></li>\n</ol>\n</blockquote>\n<p>That said, having two constructors declared like below:</p>\n<pre><code>any(const any &amp;);\n\ntemplate &lt;typename ValueType&gt;\nany(const ValueType &amp;);\n</code></pre>\n<p>the compiler will choose the <strong>non-templated</strong> version, as <em>instantiating</em> the templated one would result with <strong>exactly same declaration</strong>.</p>\n<p>However, with the constructor taking <em>Unviersal Reference</em> the situation changes radically:</p>\n<pre><code>any(const any &amp;);\n\ntemplate &lt;typename ValueType&gt;\nany(ValueType &amp;&amp;);\n</code></pre>\n<p>In the context of to copying an instance with regular <em>direct-initialization</em> syntax:</p>\n<pre><code>any a;\nany b{a};\n</code></pre>\n<p>the evaluated type of <code>a</code> is an lvalue <code>any &amp;</code> <strong>without</strong> the <code>const</code> modifier. After generating the set of candidate constructors for overload resolution the compiler ends up with following signatures:</p>\n<pre><code>any(const any &amp;); // non-template\n\nany(any &amp;); // instantiated template\n</code></pre>\n<p>And then:</p>\n<blockquote id=\"so_25836109_25836942_4\">\n<h3>\u00a7 13.3.1 Candidate functions and argument lists <code>[over.match.funcs]</code></h3>\n<ol start=\"7\">\n<li>In each case where a candidate is a function template, candidate function template specializations are generated using template argument deduction (14.8.3, 14.8.2). <strong>Those candidates are then handled as candidate functions in the usual way.</strong> A given name can refer to one or more function templates and also to a set of overloaded non-template functions. In such a case, the candidate functions generated from each function template are combined with the set of non-template candidate functions.</li>\n</ol>\n</blockquote>\n<p>That is, the <strong>template version is a better match</strong>, and this is what the compiler chooses.</p>\n<p>However, if one had:</p>\n<pre><code>const any a; // const!\nany b{a};\n</code></pre>\n<p>Then this time the constructor signature generated from constructor taking <em>Universal Reference</em> would be the same as the non-template version of copy-constructor, so only then the <strong>non-template</strong> version is called.</p>\n<blockquote>\n<p id=\"so_25836109_25836942_5\"><em>What about volatile modifier or some strange std::move((const any&amp;)it) if that is possible?</em></p>\n</blockquote>\n<p>Exactly the same happens. The <em>Universal Reference</em> constructor is <strong>a better match.</strong></p>\n<p>That is, <code>std::move((const any&amp;)it)</code> evaluates to expression of <code>const any &amp;&amp;</code> type.</p>\n<p>The parameter of non-template move constructor can take <em>non-const rvalue reference</em> (so does not match at all, since it lacks <code>const</code> modifier).</p>\n<p>The parameter of non-template copy constructor can take the <em>const lvalue reference</em> (that is fine, const rvalue can be bound by const lvalue reference, but is <strong>not an exact match</strong>).</p>\n<p>Then, the instantiated template taking <em>Universal Reference</em> is <strong>again a better match that will be invoked.</strong></p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2014-09-15T09:57:40.450", "Score": "6", "CreationDate": "2014-09-14T19:02:50.253", "ParentId": "25836109", "CommentCount": "1", "OwnerUserId": "3953764", "LastEditDate": "2014-09-15T09:57:40.450"}});