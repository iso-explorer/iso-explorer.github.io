post_cb({"bq_ids": {"n4140": {"so_21689626_21689662_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7213}}, "n3337": {"so_21689626_21689662_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 6957}}, "n4659": {"so_21689626_21689662_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 8722}}}, "21689626": {"ViewCount": "76", "Body": "<p>I want to implement a Handletype like in this <a href=\"http://molecularmusings.wordpress.com/2013/05/17/adventures-in-data-oriented-design-part-3b-internal-references/\" rel=\"nofollow\">example</a>.</p>\n<p>(Long story short: the structure <code>Handle</code> holds an <code>index</code>-member to an array with elements. Its other member <code>count</code> validates if the <code>index</code> is up to date, corresponding to the datas <code>countArray</code>. <code>count</code> and <code>countArray</code> are with a fixed size of a type/bitfield( u32 : 20bits))</p>\n<p>To avoid being restricted to the 20bits of the generation/counter size, the following came into my mind: Why not let the <code>unsigned char count/countArray</code> overflow on purpose?\nI could also do the same with the modulo method <code>( counter = ++counter % 0xff )</code>, but that is another additional operation then..\nSo let the count grow upto <code>0xff</code> and overflow will set it again to <code>0</code> when <code>0xff + 1</code> happens.\nIs this legitime?</p>\n<p>Here is my pseudo implementation (C++):</p>\n<pre><code>struct Handle\n{\n        unsigned short index;\n        unsigned char count;\n};\n\nstruct myData\n{\n        unsigned short curIndex;\n        int* dataArray;\n        unsigned char* countArray;\n\n        Handle create()\n        {\n            // check if index not already used\n            // create object at dataArray[handle.index]\n            Handle handle;\n            handle.index = curIndex;\n            handle.count = countArray[curIndex]; \n            return handle;\n        }\n\n        void destroy( const Handle&amp; handle )\n        {\n            // delete object at dataArray[handle.index]\n            countArray[handle.index]++; // &lt;-- overflow here?\n        }\n\n        bool isValid( const Handle&amp; handle ) const\n        {\n            return handle.count == countArray[handle.index];\n        }\n};\n</code></pre>\n<p>EDIT #1: Yes, these integral types should all be unsigned (as indexes are)</p>\n", "AcceptedAnswerId": "21689662", "Title": "Is a forced integer buffer overflow legitime?", "CreationDate": "2014-02-10T22:55:10.990", "Id": "21689626", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-02-10T22:57:38.130", "Score": "0", "OwnerUserId": "3087952", "Tags": "<c++><c><design><overflow>", "AnswerCount": "1"}, "21689662": {"Id": "21689662", "PostTypeId": "2", "Body": "<p>As long as you're not using <code>signed</code> types, you're safe.</p>\n<p>Technically, <code>unsigned</code> types don't overflow:</p>\n<h3>3.9.1 Fundamental types [basic.fundamental]</h3>\n<blockquote>\n<p id=\"so_21689626_21689662_0\">46)This implies that unsigned arithmetic does not overflow because a\n  result that cannot be represented by the resulting unsigned integer\n  type is reduced modulo the number that is one greater than the largest\n  value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n", "LastActivityDate": "2014-02-10T22:57:38.130", "CommentCount": "1", "CreationDate": "2014-02-10T22:57:38.130", "ParentId": "21689626", "Score": "1", "OwnerUserId": "673730"}});