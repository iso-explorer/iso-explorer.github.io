post_cb({"bq_ids": {"n4140": {"so_32972132_32973315_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 336}}, "n3337": {"so_32972132_32973315_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 326}}, "n4659": {"so_32972132_32973315_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 345}}}, "32972132": {"ViewCount": "357", "Body": "<p>I have a <code>std::unordered_map&lt;string, std::array&lt;int, 2&gt;&gt;</code>. What is the syntax of <code>emplace</code>ing a value into the map?</p>\n<pre><code>unordered_map&lt;string, array&lt;int, 2&gt;&gt; contig_sizes;\nstring key{\"key\"};\narray&lt;int, 2&gt; value{1, 2};\n\n// OK ---1\ncontig_sizes.emplace(key, value);\n\n// OK --- 2\ncontig_sizes.emplace(key, std::array&lt;int, 2&gt;{1, 2});\n\n// compile error --3\n//contig_sizes.emplace(key, {{1,2}});\n\n// OK --4 (Nathan Oliver)\n// Very inefficient results in two!!! extra copy c'tor\ncontig_sizes.insert({key, {1,2}});\n\n// OK --5\n// One extra move c'tor followed by one extra copy c'tor\ncontig_sizes.insert({key, std::array&lt;int, 2&gt;{1,2}});\n\n// OK --6 \n// Two extra move constructors\ncontig_sizes.insert(pair&lt;const string, array&lt;int, 2&gt;&gt;{key, array&lt;int, 2&gt;{1, 2}});\n</code></pre>\n<p>I am using <code>clang++ -c  -x c++ -std=c++14</code> and clang 3.6.0</p>\n<p>I tested the code in <a href=\"http://ideone.com/pp72yR\" rel=\"nofollow\">http://ideone.com/pp72yR</a></p>\n<p>Addendum:\n(4) was suggested by Nathan Oliver in the answer below</p>\n", "Title": "emplace and unordered_map<?, std::array<?, N>>", "CreationDate": "2015-10-06T14:08:33.133", "LastActivityDate": "2015-10-22T13:29:25.923", "CommentCount": "1", "LastEditDate": "2015-10-22T13:17:16.027", "PostTypeId": "1", "LastEditorUserId": "579584", "Id": "32972132", "Score": "2", "OwnerUserId": "579584", "Tags": "<c++><dictionary><unordered-map><stdarray><emplace>", "AnswerCount": "1"}, "32973315": {"Id": "32973315", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/\" rel=\"nofollow\">cppreference</a> <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map/emplace\" rel=\"nofollow\"><code>std::unordered_map::emplace</code></a> is declared as</p>\n<pre><code>template&lt; class... Args &gt;\nstd::pair&lt;iterator,bool&gt; emplace( Args&amp;&amp;... args );\n</code></pre>\n<p>So it tries to deduce the types passed to it.  This brings into play [temp.deduct.type] \u00a7 14.8.2.5</p>\n<blockquote>\n<p id=\"so_32972132_32973315_0\">\u2014 A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter does not have a type for which deduction from an initializer list is specified (14.8.2.1). [ Example:</p>\n<pre><code>template&lt;class T&gt; void g(T);  \ng({1,2,3}); // error: no argument deduced for T\n</code></pre>\n<p id=\"so_32972132_32973315_1\">\u2014end example ]</p>\n</blockquote>\n<p>So no type is able to be deduced.</p>\n<p>If you want to create objects on the fly then you would use the form:</p>\n<pre><code>contig_sizes.emplace(key, std::array&lt;int, 2&gt;{1, 2});\n</code></pre>\n<p>Or we can create a <code>typedef</code></p>\n<pre><code>typedef pair&lt;const string, array&lt;my_class, 2&gt;&gt; pair_type;\n</code></pre>\n<p>And then we can have</p>\n<pre><code>contig_sizes.emplace(pair_type{key, {1, 2}});\n</code></pre>\n<p>You could also use <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map/insert\" rel=\"nofollow\"><code>std::unordered_map::insert</code></a> which takes a <code>pair</code> of the key/value which can be constructed from a braced initializer list.</p>\n<pre><code>contig_sizes.insert({key, {1, 2}});\n</code></pre>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2015-10-22T13:29:25.923", "Score": "4", "CreationDate": "2015-10-06T15:03:04.583", "ParentId": "32972132", "CommentCount": "7", "OwnerUserId": "4342498", "LastEditDate": "2015-10-22T13:29:25.923"}});