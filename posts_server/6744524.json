post_cb({"6746173": {"ParentId": "6744524", "CommentCount": "5", "CreationDate": "2011-07-19T11:07:02.940", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "6746173", "Score": "5", "Body": "<p>Pursuant to N3291, the Working Draft from April 5, 2011, there has been a few changes to initializer lists, so Scott Meyer's slides may be from old data.</p>\n<p>According to section 13.3.1.7 (so close to 1337):</p>\n<blockquote id=\"so_6744524_6746173_0\">\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the argument list consists of the initializer list as a single argument</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</li>\n</ul>\n</blockquote>\n<p>So it does prefer initailizer lists. But if the initializer list doesn't match, then it will check the regular constructors to see if they match.</p>\n<p>It goes on to say that if the initializer list is empty, then the default constructor is used.</p>\n", "LastActivityDate": "2011-07-19T11:07:02.940"}, "6744524": {"CommentCount": "4", "ViewCount": "223", "PostTypeId": "1", "LastEditorUserId": "472245", "CreationDate": "2011-07-19T08:51:39.980", "LastActivityDate": "2011-11-29T09:33:53.767", "Title": "C++0x: Overload Resolution", "AcceptedAnswerId": "6746173", "LastEditDate": "2011-11-29T09:33:53.767", "Id": "6744524", "Score": "3", "Body": "<p>In the Standard-Text there is an example in <em>8.5.4 (3) List-initialization [dcl.init.list]</em></p>\n<pre><code>struct S {\n    S(std::initializer_list&lt;double&gt;);  // #1\n    S(const std::string&amp;);             // #2\n};\nconst S&amp; r1 = { 1, 2, 3.0 };  // OK: invoke #1\nconst S&amp; r2 { \"Spinach\" };    // OK: invoke #2 !!!\n</code></pre>\n<p>(the example is about the ref-to-temp, but I refer to the overload resolution here).</p>\n<p>Whereas Scott Meyers in his talk/slides tells a different story:</p>\n<blockquote>\n<p id=\"so_6744524_6744524_0\">std::initializer_list parameters are always preferred over other types:</p>\n</blockquote>\n<pre><code>class Widget {\npublic:\n    Widget(double value, double uncertainty);           // #1\n    Widget(std::initializer_list&lt;std::string&gt; values);  // #2\n};\ndouble d1, d2;\nWidget w1 { d1, d2 }; // tries to call #2; fails because\n                      // no double \u21d2 string conversion\n</code></pre>\n<p>The examples are slightly different, but aren't those about the same thing? When and how overload resolution with <code>initializer_list</code>-constructors happens? Or is there a different issue here?</p>\n<p><strong>How is the overloading decided in both cases? If both are correct, what do I miss here?</strong></p>\n<p><strong>Edit/Clarification</strong> upon <em>Keric's</em> Comment: My feeling ist, that the two examples contradict each other:</p>\n<ul>\n<li>The Std gives an example where a <code>const char*</code> is converted to a <code>string</code>, which does not match the provided <code>initializer_list&lt;int&gt;</code> and therefore the provided \"normal\" <code>const string&amp;</code>-c'tor is used.</li>\n<li>Scott's example initializes with <code>{double, double}</code> when an <code>intializer_list&lt;int&gt;</code>-c'tor is available and therefore chosen, because the list, he argues, is preferred. Thus the also provided <code>(double, double)</code>-c'tor is never chosen when initialized this way.</li>\n</ul>\n<p>Of course, the Std is always right, but maybe I apply the example wrongly. The Std example has <code>&amp;</code> in it, that I don't think are relevant for my question, but maybe I am wrong.</p>\n<p>Scott's slides are quite recent, and I can not see that the relevant section(s) in the Std have changed to that respect (although, it's difficult to get everything into scope, because it's somewhat \"widely spread\" :-)</p>\n<p><strong>Edit-2</strong>: I got a mail from Scott himself that there was a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1151\" rel=\"nofollow\">late change in the Standard</a> that had not been incorporated into the slides.</p>\n", "Tags": "<c++11><overloading><initializer-list>", "OwnerUserId": "472245", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_6744524_6746173_0": {"section_id": 599, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_6744524_6746173_0": {"section_id": 589, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_6744524_6746173_0": {"section_id": 622, "quality": 0.9705882352941176, "length": 33}}}});