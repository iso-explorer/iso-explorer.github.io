post_cb({"8587027": {"Id": "8587027", "PostTypeId": "2", "Body": "<blockquote id=\"so_8585924_8587027_0\">\n<ol>\n<li>Do constants constitute RValues? const int x = 0; is maniputable at\n  least one time.</li>\n</ol>\n</blockquote>\n<p>In your declaration, <code>x</code> is neither an rvalue or lvalue, it is called a <em>declarator-id</em>. (See grammar of 8/4 in C++03) When it is used in a (sub-)expression it is a non-modifiable lvalue which can be initialized to any <em>constant expression</em>.</p>\n<blockquote>\n<p id=\"so_8585924_8587027_1\">2.Now, the temporary objects created by the compiler are also RValues even when they have maniputable memory regions. Why is that so? \n  Because they cannot be modified by \"users\"? Is this the reason?</p>\n</blockquote>\n<p>Rvalue of a class type can either be modifiable or non-modifiable but rvalues of built-in types are always cv-unqualified.</p>\n<blockquote>\n<p id=\"so_8585924_8587027_2\">\u00a7 3.10/9 Class rvalues can have cv-qualified types; non-class rvalues\n  always have cv-unqualified types.</p>\n</blockquote>\n<p>Consider this example:</p>\n<pre><code>struct S {\n     int x;\n     void f(int s) { x = s; }\n};\n\n// ill-formed: Cannot assign to an rvalue of built-in type.\nS().x = 42;\n\n// Valid: A member function can be used to modify the referent of rvalue.\nS().f(42);\n</code></pre>\n<p>The sub-expression <code>S()</code> creates an rvalue of class type whose lifetime is the end of ; <em>full-expression.</em></p>\n", "LastActivityDate": "2011-12-21T08:40:52.873", "CommentCount": "7", "CreationDate": "2011-12-21T08:40:52.873", "ParentId": "8585924", "Score": "3", "OwnerUserId": "187543"}, "8586124": {"Id": "8586124", "PostTypeId": "2", "Body": "<ol>\n<li><p>All variables, including nonmodifiable (const) variables, are lvalues. So x is an lvalue whereas 0 is an rvalue.</p></li>\n<li><p>Temporary objects are made rvalues since they do not exist beyond that particular statement. </p></li>\n</ol>\n<p>You can read more <a href=\"http://msdn.microsoft.com/en-us/library/f90831hc.aspx\" rel=\"nofollow\">here</a></p>\n", "LastActivityDate": "2011-12-21T06:58:40.920", "CommentCount": "1", "CreationDate": "2011-12-21T06:58:40.920", "ParentId": "8585924", "Score": "0", "OwnerUserId": "141282"}, "8586115": {"Id": "8586115", "PostTypeId": "2", "Body": "<p>An <code>lvalue</code> refers to a memory location and we can take the address of that memory location using the <code>&amp;</code> operator. An <code>rvalue</code> is an expression which is not an <code>lvalue</code>.</p>\n<p><code>1. Do constants constitute RValues? const int x = 0; is maniputable at least one time.</code></p>\n<p>No, because you an do this - <code>const int *p = &amp;x</code></p>\n", "LastActivityDate": "2011-12-21T06:56:06.567", "CommentCount": "2", "CreationDate": "2011-12-21T06:56:06.567", "ParentId": "8585924", "Score": "1", "OwnerUserId": "790713"}, "8587847": {"Id": "8587847", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8585924_8587847_0\">RValues are things which are not maniputable regions of memory</p>\n</blockquote>\n<p><strong>rvalues are expressions, not \"things\".</strong></p>\n<p>rvalues <em>can</em> refer to objects (\"maniputable regions of memory\").</p>\n<blockquote>\n<p id=\"so_8585924_8587847_1\">so literals like integers are considered RValues.</p>\n</blockquote>\n<p>Literals are rvalue (not \"considered\" rvalues) <em>because C++ is defined that way</em>.</p>\n<blockquote>\n<p id=\"so_8585924_8587847_2\">Do constants constitute RValues? </p>\n</blockquote>\n<pre><code>const int x = 0;\n</code></pre>\n<p>Actually, <strong><code>x</code> is a variable</strong> of type <code>const int</code>.</p>\n<p>Given the above definition of <code>x</code>, the expression <code>x</code> is a lvalue.</p>\n<blockquote>\n<p id=\"so_8585924_8587847_3\">Now, the temporary objects created by the compiler are also RValues </p>\n</blockquote>\n<p>No, rvalues are expressions, <strong>not objects</strong>.</p>\n<blockquote>\n<p id=\"so_8585924_8587847_4\">even when they have maniputable memory regions. Why is that so?</p>\n</blockquote>\n<p>It isn't so.</p>\n<blockquote>\n<p id=\"so_8585924_8587847_5\">Because they cannot be modified by \"users\"? Is this the reason?</p>\n</blockquote>\n<p>rvalues are rvalues because the language is defined this way.</p>\n<blockquote>\n<p id=\"so_8585924_8587847_6\">So, a memory region which is NOT maniputable by the \"users\" is called RValue?</p>\n</blockquote>\n<p>No, rvalue only designate expressions, not things that exist at runtime like memory.</p>\n<p>A rvalue can sometimes refer to an object, which is a \"memory region\" that the user can manipulate.</p>\n<blockquote>\n<p id=\"so_8585924_8587847_7\">memory region which is NOT maniputable by the \"users\" </p>\n</blockquote>\n<p>It isn't clear what you mean here; do you mean read-only memory, or something else?</p>\n", "LastEditorUserId": "963864", "LastActivityDate": "2011-12-21T10:03:50.337", "Score": "0", "CreationDate": "2011-12-21T09:48:28.083", "ParentId": "8585924", "CommentCount": "0", "OwnerUserId": "963864", "LastEditDate": "2011-12-21T10:03:50.337"}, "bq_ids": {"n4140": {"so_8585924_8587027_2": {"length": 8, "quality": 0.6153846153846154, "section_id": 7233}}, "n3337": {"so_8585924_8587027_2": {"length": 10, "quality": 0.7692307692307693, "section_id": 6977}}, "n4659": {"so_8585924_8587027_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 8746}}}, "8586112": {"Id": "8586112", "PostTypeId": "2", "Body": "<p>Scalar rvalues are expressions that evaluate to scalar values like <code>42</code> or <code>i + k</code> (whereas scalar lvalues are expressions that evaluate to scalar objects like <code>i</code> or <code>*int_ptr</code> or <code>numbers[0]</code>).</p>\n<p>rvalues of class type are expressions that evaluate to temporary objects. The most prominent example is the call of a function that returns a class object by value:</p>\n<pre><code>std::string foo()\n{\n    return \"hello world\";\n}\n</code></pre>\n<p>Given the above function definition, the expression <code>foo()</code> is an rvalue. Note that I'm not talking about the <em>result</em> (which is a temporary object) but the <em>expression</em> <code>foo()</code> whose evaluation yields that result.</p>\n", "LastActivityDate": "2011-12-21T06:55:43.830", "CommentCount": "1", "CreationDate": "2011-12-21T06:55:43.830", "ParentId": "8585924", "Score": "3", "OwnerUserId": "252000"}, "8594654": {"Id": "8594654", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8585924_8594654_0\">RValues are things which are not maniputable regions of memory</p>\n</blockquote>\n<p>Wrong. Rvalues absolutely are mutable. In C++03 doing this is a headache, but can be done legally- in C++11 it's extremely common.</p>\n<p>Rvalues are expressions that yield things which are about to die. That's their defining property. Therefore, you can steal their resources without worrying about it, using C++11's rvalue references, or if you're desperate, \"swaptimizing\" in C++03. This makes them more correct in many situations, and much faster in <em>many, many</em> circumstances.</p>\n", "LastActivityDate": "2011-12-21T18:35:28.180", "CommentCount": "0", "CreationDate": "2011-12-21T18:35:28.180", "ParentId": "8585924", "Score": "0", "OwnerUserId": "298661"}, "8586974": {"Id": "8586974", "PostTypeId": "2", "Body": "<p>first of all - lval and rval are properties of expressions - an expression is either an rval or an lval. </p>\n<p>To answer your other question, <strong>temporaries</strong> created by rvals can be modified by having a rval reference - this feature is added in c++11</p>\n<p>This feature is very useful for 1) applying move semantics 2 ) perfect forwarding.</p>\n<p>Read more about it at <a href=\"http://blogs.msdn.com/b/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx\" rel=\"nofollow\">http://blogs.msdn.com/b/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx</a></p>\n", "LastEditorUserId": "1104674", "LastActivityDate": "2011-12-21T12:41:39.650", "Score": "0", "CreationDate": "2011-12-21T08:35:58.957", "ParentId": "8585924", "CommentCount": "14", "OwnerUserId": "1104674", "LastEditDate": "2011-12-21T12:41:39.650"}, "8585924": {"ViewCount": "194", "Body": "<p>RValues are things which are not maniputable regions of memory, so literals like integers are considered RValues.</p>\n<ol>\n<li>Do constants constitute RValues? <code>const int x = 0;</code> is maniputable at least one time.</li>\n<li>Now, the temporary objects created by the compiler are also RValues even when they have maniputable memory regions. Why is that so?<br>\nBecause they cannot be modified by \"users\"? Is this the reason?</br></li>\n</ol>\n<p>So, a memory region which is NOT maniputable by the \"users\" is called RValue?</p>\n", "Title": "What constitutes of RValues?", "CreationDate": "2011-12-21T06:34:11.613", "LastActivityDate": "2011-12-21T18:35:28.180", "CommentCount": "0", "LastEditDate": "2011-12-21T09:39:23.610", "PostTypeId": "1", "LastEditorUserId": "963864", "Id": "8585924", "Score": "0", "OwnerUserId": "462608", "Tags": "<c++><const><lvalue><rvalue><temporary-objects>", "AnswerCount": "7"}});