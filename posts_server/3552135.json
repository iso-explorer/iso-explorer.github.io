post_cb({"3552135": {"CommentCount": "4", "AcceptedAnswerId": "3552210", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-08-23T22:16:12.070", "LastActivityDate": "2012-11-19T15:32:31.907", "LastEditDate": "2017-05-23T11:58:46.867", "ViewCount": "4122", "FavoriteCount": "1", "Title": "Does C++11 provide hashing functions for std::type_info?", "Id": "3552135", "Score": "7", "Body": "<p>I'm still working on a good solution to my <a href=\"https://stackoverflow.com/questions/3221501/oneofatype-container-storing-one-each-of-a-given-type-in-a-container-am-i-o\">One-Of-A-Type Container Problem</a> -- and upon reflection I think it would be nice to be able to just use something like a <code>std::map&lt;std::type_info, boost::any&gt;</code>. Unfortunately, <code>std::type_info</code> does not define an <code>operator&lt;</code>, and I think it'd be unreasonable for it to define one.</p>\n<p>However, it does seem reasonable to define a hash function for it, because you could simply use the singleton address of the <code>std::type_info</code> object as a reasonable \"hash\". Therefore, you'd be able to put a <code>std::type_info</code> into a <code>std::unordered_map</code> as the key.</p>\n<p>Does C++11 provide such a hash function? Would using the memory address of the <code>std::type_info</code> singleton be a bad hash strategy?</p>\n", "Tags": "<c++><c++11><rtti><unordered-map><typeinfo>", "OwnerUserId": "82320", "AnswerCount": "2"}, "13456987": {"ParentId": "3552135", "CommentCount": "0", "Body": "<p>You could also use <a href=\"http://en.cppreference.com/w/cpp/types/type_index\">type_index</a>, it safely holds a pointer to a type_info, it's copyable, comparable and a hash function is provided for standard containers.</p>\n", "OwnerUserId": "1029901", "PostTypeId": "2", "Id": "13456987", "Score": "10", "CreationDate": "2012-11-19T15:32:31.907", "LastActivityDate": "2012-11-19T15:32:31.907"}, "3552210": {"ParentId": "3552135", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>The fact that <code>type_info</code> is not less-than comparable isn't as much a problem for using it as a map key as the fact that <code>type_info</code> is non-copyable.  :-)</p>\n<p>In C++03, <code>type_info</code> has a <code>before()</code> member function that provides an ordering of <code>type_info</code> objects.</p>\n<p>In C++11, <code>type_info</code> has a <code>hash_code()</code> member function (C++11 \u00a718.7.1/7):</p>\n<blockquote>\n<pre><code>size_t hash_code() const throw();\n</code></pre>\n<p id=\"so_3552135_3552210_0\"><em>Returns:</em> an unspeci\ufb01ed value, except that within a single execution of the program, it shall return the same value for any two <code>type_info</code> objects which compare equal.</p>\n<p id=\"so_3552135_3552210_1\"><em>Remark:</em> an implementation should return different values for two <code>type_info</code> objects which do not compare equal.</p>\n</blockquote>\n<p><code>type_info</code> objects resulting from the <code>typeid</code> operator exist until the end of the program, so it is safe to use a <code>type_info*</code> as a map key.  However, to the best of my knowledge, there is no guarantee that if you apply <code>typeid</code> to two objects of the same type you will get two references to the same <code>type_info</code> object.  </p>\n<p>If you do use <code>type_info*</code> as a map key, I'd use a custom comparator that dereferences the pointers and compares the <code>type_info</code> objects themselves (using the aforementioned <code>before()</code> or <code>hash_code()</code> for ordering).</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2012-03-10T03:44:34.020", "Id": "3552210", "Score": "9", "CreationDate": "2010-08-23T22:32:31.010", "LastActivityDate": "2012-03-10T03:44:34.020"}, "bq_ids": {"n4140": {"so_3552135_3552210_1": {"section_id": 6892, "quality": 0.9, "length": 9}, "so_3552135_3552210_0": {"section_id": 6891, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_3552135_3552210_1": {"section_id": 6638, "quality": 0.9, "length": 9}, "so_3552135_3552210_0": {"section_id": 6637, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_3552135_3552210_0": {"section_id": 8391, "quality": 0.8666666666666667, "length": 13}, "so_3552135_3552210_1": {"section_id": 8392, "quality": 0.9, "length": 9}}}});