post_cb({"26471364": {"Id": "26471364", "PostTypeId": "2", "Body": "<p><strong>That call is ambiguos</strong>. GCC is right.  </p>\n<blockquote>\n<p id=\"so_26470503_26471364_0\">\u00a713.5.2/1<br>\n  Thus, for any binary operator @, x@y can be interpas either\n  x.operator@(y) or operator@(x,y). If both forms of the operator\n  function have been declthe rules in 13.3.1.2 determine which, if any,\n  interpretation is used.</br></p>\n</blockquote>\n<p>And in this case, we do have both the member and nonmember function. The built-in version is not included because the left hand operator has class type.  </p>\n<p>If you called the operator explicitly, there would be no ambiguity. However, when the call is done through an operator (thus implicitly) <strong>there is nothing which can distinguish between member and nonmember</strong>, therefore they're both viable functions which, in this case, leads to an ambiguous function call.</p>\n<p>Previous versions of clang report it as ambiguous as well: <a href=\"http://goo.gl/OWsJUv\" rel=\"nofollow\">http://goo.gl/OWsJUv</a> </p>\n", "LastEditorUserId": "2692339", "LastActivityDate": "2014-10-20T17:31:58.347", "Score": "0", "CreationDate": "2014-10-20T17:23:52.100", "ParentId": "26470503", "CommentCount": "5", "OwnerUserId": "2692339", "LastEditDate": "2014-10-20T17:31:58.347"}, "26471077": {"Id": "26471077", "PostTypeId": "2", "Body": "<p>This example is taken from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">standard</a> (this is the draft for c++11).</p>\n<p><strong>14.5.6.2 Partial ordering of function templates</strong> paragraph 3 example:</p>\n<pre><code>struct A { };\ntemplate&lt;class T&gt; struct B {\n  template&lt;class R&gt; int operator*(R&amp;); // #1\n};\ntemplate&lt;class T, class R&gt; int operator*(T&amp;, R&amp;); // #2\n// The declaration of B::operator* is transformed into the equivalent of\n// template&lt;class R&gt; int operator*(B&lt;A&gt;&amp;, R&amp;); // #1a\nint main() {\n  A a;\n  B&lt;A&gt; b;\n  b * a; // calls #1a\n}\n</code></pre>\n<p>So, the standard itself pretty much say this is legal code. I could copy-paste rules, but one might as well click link and jump to the relevant place. My point is only to prove this is a proper compilable code as defined by the standard.</p>\n<p>For what it's worth on my debian <code>clang 3.5.0</code> compiled it right away, <code>clang 3.4.2</code> had to be executed with <code>-std=c++11</code>, <code>g++ 4.9.1</code> reported ambiguity in all cases (I even tried 1y).</p>\n<p>I am puzzled by <code>clang</code> behaviour, though. I thought it might have been ambiguous in earlier versions of c++, the rule to disambiguate was added as a part of c++11 and <code>g++</code> didn't keep up. But <code>clang 3.5</code> compiles it even with <code>-std=c++98</code>.</p>\n", "LastEditorUserId": "1133179", "LastActivityDate": "2014-10-20T17:23:12.680", "Score": "10", "CreationDate": "2014-10-20T17:05:09.063", "ParentId": "26470503", "CommentCount": "11", "OwnerUserId": "1133179", "LastEditDate": "2014-10-20T17:23:12.680"}, "bq_ids": {"n4140": {"so_26470503_26471364_0": {"length": 15, "quality": 0.75, "section_id": 659}}, "n3337": {"so_26470503_26471364_0": {"length": 15, "quality": 0.75, "section_id": 649}}, "n4659": {"so_26470503_26471364_0": {"length": 15, "quality": 0.75, "section_id": 687}}}, "26470503": {"ViewCount": "524", "Body": "<p>I took the following example from <a href=\"http://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading</a>\nand clang (3.4) seems to be handling it just fine, while g++ (4.8.3) gives an 'ambiguous overload' error:</p>\n<pre><code>struct A {};\ntemplate&lt;class T&gt; struct B {\n  template&lt;class R&gt; void operator*(R&amp;){ cout &lt;&lt; \"1\" &lt;&lt; endl; }             // #1\n};\ntemplate&lt;class T, class R&gt; void operator*(T&amp;, R&amp;) { cout &lt;&lt; \"2\" &lt;&lt; endl;}  // #2\nint main() {\n  A a;\n  B&lt;A&gt; b;\n  b * a; //prints 1\n}\n</code></pre>\n<p>clang correctly prints 1 (as expected according to cppreference), while g++ gives this error:</p>\n<pre><code>test_templates.cpp: In function \u2018int main()\u2019:\ntest_templates.cpp:13:5: error: ambiguous overload for \u2018operator*\u2019 (operand types are \u2018B&lt;A&gt;\u2019 and \u2018A\u2019)\n   b * a; //prints 1\n     ^\ntest_templates.cpp:13:5: note: candidates are:\ntest_templates.cpp:7:26: note: void B&lt;T&gt;::operator*(R&amp;) [with R = A; T = A]\n   template&lt;class R&gt; void operator*(R&amp;){ cout &lt;&lt; \"1\" &lt;&lt; endl; }            // #1\n                          ^\ntest_templates.cpp:9:33: note: void operator*(T&amp;, R&amp;) [with T = B&lt;A&gt;; R = A]\n template&lt;class T, class R&gt; void operator*(T&amp;, R&amp;) { cout &lt;&lt; \"2\" &lt;&lt; endl;}  // #2\n</code></pre>\n<p>Is g++ actually misbehaving here?</p>\n", "AcceptedAnswerId": "26471077", "Title": "Is g++ misbehaving with function template overloading?", "CreationDate": "2014-10-20T16:31:46.277", "Id": "26470503", "CommentCount": "4", "LastEditDate": "2014-10-20T17:14:01.647", "PostTypeId": "1", "LastEditorUserId": "3204551", "LastActivityDate": "2014-10-20T17:31:58.347", "Score": "10", "OwnerUserId": "3272850", "Tags": "<c++><templates><g++><clang>", "AnswerCount": "2"}});