post_cb({"24333458": {"CommentCount": "8", "ViewCount": "925", "PostTypeId": "1", "LastEditorUserId": "1609356", "CreationDate": "2014-06-20T18:24:49.123", "LastActivityDate": "2014-06-21T06:32:07.550", "Title": "Constexpr class: Inheritance?", "AcceptedAnswerId": "24333884", "LastEditDate": "2014-06-20T18:55:29.670", "Id": "24333458", "Score": "3", "Body": "<p>First of all, I'm working with Clang 3.4.1</p>\n<p>I'm writting a global variable which has to serve as a placeholder on compile-time contexts (Primarily as value template parameter). For that purpose, I have written a constexpr class named <code>chameleon</code> (It mimics the behaviour of any runtime value):</p>\n<pre><code>struct chameleon\n{\n    template&lt;typename T&gt;\n    constexpr operator T() const\n    {\n        return T{};\n    }\n\n    constexpr chameleon() = default;\n};\n</code></pre>\n<p>Since both the conversion operator and the constructor are specified as <code>constexpr</code>, I'm able to make instances of that class at compile-time. <a href=\"https://ideone.com/KhAN6R\" rel=\"nofollow\">For example</a>:</p>\n<pre><code>template&lt;int foo&gt;\nstruct bar\n{};\n\nusing mytype = bar&lt;chameleon{}&gt;;\n</code></pre>\n<p>Since this works, and I use it in other places, I decided to write such placeholder type \njust inheriting from <code>chameleon</code>:</p>\n<pre><code>template&lt;std::size_t I&gt;\nstruct placeholder : public chameleon\n{\n    using chameleon::chameleon;\n};\n</code></pre>\n<p>I'm using C++11, so I just used the \"new\" (C++11 has three years...) inheriting constructors feature.</p>\n<p>When declaring the placeholder variable:</p>\n<pre><code>constexpr const placeholder&lt;0&gt; _1;\n</code></pre>\n<p>The compiler rejects the code saying it expects an user-defined default ctor for initialization. So <em>\"Well, inheriting ctors doesn't propagate constexpr, or something like that\"</em> is what I though. Then I changed the using to a default ctor declaration:</p>\n<pre><code>template&lt;std::size_t I&gt;\nstruct placeholder : public chameleon\n{\n    constexpr placeholder() = default;\n};\n</code></pre>\n<p>Now the compiler says:</p>\n<blockquote>\n<p id=\"so_24333458_24333458_0\">error: default initialization of an object of const type 'const placeholder&lt;0&gt;' requires a user-provided default constructor</p>\n</blockquote>\n<p>If I change the <code>= default</code> to a manually defined empty constructor (<code>constexpr placeholder() {}</code>) then it works, but the constructor is not evaluated as <code>constexpr</code> and the usage of the\n<code>_</code> placeholder in compile-time contexts is invalid (The common <code>is not a constant expression</code> error). The same for manually calling the base ctor.</p>\n<p>My question is: <strong>Whats wrong with inheritance and <code>constexpr</code>constructors? Is there any way to use inheritance when writting <code>constexpr</code> classes?</strong></p>\n<p><strong>EDIT:</strong> I have a division-by-zero bug, the code using the manually written ctor works perfectly. On the other hand, I don't understand why neither the inheriting constructor or the default constructor declaration worked. The question remains there.</p>\n", "Tags": "<c++><inheritance><c++11><constexpr>", "OwnerUserId": "1609356", "AnswerCount": "1"}, "24333884": {"ParentId": "24333458", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-06-20T18:54:56.370", "Score": "4", "LastEditorUserId": "241631", "LastEditDate": "2014-06-21T06:32:07.550", "Id": "24333884", "OwnerUserId": "241631", "Body": "<blockquote>\n<p id=\"so_24333458_24333884_0\">So \"Well, inheriting ctors doesn't propagate constexpr, or something like that\" is what I thought</p>\n</blockquote>\n<p>That's not the issue; default and copy/move constructors cannot be inherited. If you don't explicitly define or default them, they'll be implicitly defined following the usual rules.</p>\n<p><em>\u00a712.9 [class.inhctor]</em></p>\n<blockquote>\n<p id=\"so_24333458_24333884_1\">3 \u00a0\u00a0\u00a0\u00a0 For each non-template constructor in the candidate set of inherited constructors <strong>other than a constructor having no parameters or a copy/move constructor having a single parameter</strong>, a constructor is implicitly declared with the same constructor characteristics unless there is a user-declared constructor with the same\n  signature in the complete class where the <em>using-declaration</em> appears or the constructor would be a default, copy, or move constructor for that class. ...</p>\n<p id=\"so_24333458_24333884_2\">5 \u00a0\u00a0\u00a0\u00a0 [ <em>Note:</em> Default and copy/move constructors may be implicitly declared as specified in 12.1 and 12.8. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Consequently, <code>placeholder</code>, with or without the using declaration for inheriting <code>chameleon</code>'s constructors, will have a default constructor implicitly defined, and this constructor will be <code>constexpr</code>.</p>\n<p><em>\u00a712.1/5 [class.ctor]</em></p>\n<blockquote>\n<p id=\"so_24333458_24333884_3\">... If that user-written default constructor would satisfy the requirements of a <code>constexpr</code> constructor (7.1.5), the implicitly-defined default constructor is <code>constexpr</code>. ...</p>\n</blockquote>\n<p>Your class, with a user provided default constructor, satisfies the requirements in \u00a77.1.5/4 for a <code>constexpr</code> constructor. The error you saw was because of the next part.</p>\n<hr>\n<p>As for why you must provide a constructor definition for a <code>const</code> object, let's take a look at your class.</p>\n<pre><code>struct chameleon\n{\n    template&lt;typename T&gt;\n    constexpr operator T() const\n    {\n        return T{};\n    }\n\n    constexpr chameleon() = default;\n};\n</code></pre>\n<p>This class is both trivial (9/6) and standard layout (9/7), hence it is a POD (9/10). A POD is uninitialized by default, so a <code>const</code> POD without an initializer would be uninitialized, and immutable, making it pretty much worthless (or I'm not able to think of any use cases, at least). </p>\n<p>By providing a default constructor, the class is no longer a POD, and will be default initialized.</p>\n<p>As @Casey points out in the <a href=\"https://stackoverflow.com/questions/24333458/constexpr-class-inheritance#comment37616985_24333884\">comments</a>, this requirement is listed in \u00a78.5/7</p>\n<blockquote>\n<p id=\"so_24333458_24333884_4\">If a program calls for the default initialization of an object of a const-qualified type <code>T</code>, <code>T</code> shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2014-06-21T06:32:07.550"}, "bq_ids": {"n4140": {"so_24333458_24333458_0": {"section_id": 3286, "quality": 0.5833333333333334, "length": 7}, "so_24333458_24333884_1": {"section_id": 484, "quality": 0.975609756097561, "length": 40}, "so_24333458_24333884_2": {"section_id": 486, "quality": 0.5833333333333334, "length": 7}, "so_24333458_24333884_4": {"section_id": 3286, "quality": 1.0, "length": 11}, "so_24333458_24333884_3": {"section_id": 370, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_24333458_24333884_3": {"section_id": 360, "quality": 0.9230769230769231, "length": 12}, "so_24333458_24333884_1": {"section_id": 475, "quality": 0.8536585365853658, "length": 35}, "so_24333458_24333884_4": {"section_id": 3156, "quality": 1.0, "length": 11}, "so_24333458_24333458_0": {"section_id": 3156, "quality": 0.5833333333333334, "length": 7}, "so_24333458_24333884_2": {"section_id": 477, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_24333458_24333884_3": {"section_id": 384, "quality": 0.9230769230769231, "length": 12}, "so_24333458_24333884_4": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}}}});