post_cb({"23163804": {"Id": "23163804", "PostTypeId": "2", "Body": "<p>If the program reaches a statement that invokes undefined behavior, no requirements are placed on any of the program's output/behavior whatsoever; it doesn't matter whether they would take place \"before\" or \"after\" undefined behavior is invoked.</p>\n<p>Your reasoning about all three code snippets is correct. In particular, a compiler may treat any statement which unconditionally invokes undefined behavior the way GCC treats <code>__builtin_unreachable()</code>: as an optimization hint that the statement is unreachable (and thereby, that all code paths leading unconditionally to it are also unreachable). Other similar optimizations are of course possible.</p>\n", "LastActivityDate": "2014-04-18T23:15:13.573", "CommentCount": "8", "CreationDate": "2014-04-18T23:15:13.573", "ParentId": "23153445", "Score": "1", "OwnerUserId": "379897"}, "23153722": {"Id": "23153722", "PostTypeId": "2", "Body": "<p>The current C++ working draft says in 1.9.4 that</p>\n<blockquote>\n<p id=\"so_23153445_23153722_0\">This International Standard imposes no requirements on the behavior of programs that contain unde\ufb01ned behavior.</p>\n</blockquote>\n<p>Based on this, I would say that a program containing undefined behavior on any execution path can do anything at every time of its execution.</p>\n<p>There are two really good articles on undefined behavior and what compilers usually do:</p>\n<ul>\n<li><a href=\"http://blog.regehr.org/archives/213\" rel=\"nofollow\">A Guide to Undefined Behavior in C and C++</a></li>\n<li><a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" rel=\"nofollow\">What Every C Programmer Should Know About Undefined Behavior</a></li>\n</ul>\n", "LastEditorUserId": "866022", "LastActivityDate": "2014-04-18T13:14:20.327", "Score": "3", "CreationDate": "2014-04-18T12:02:47.467", "ParentId": "23153445", "CommentCount": "12", "OwnerUserId": "2169853", "LastEditDate": "2014-04-18T13:14:20.327"}, "23153445": {"ViewCount": "2630", "Body": "<p>Consider the following statement:</p>\n<pre><code>*((char*)NULL) = 0; //undefined behavior\n</code></pre>\n<p>It clearly invokes undefined behavior. Does the existence of such a statement in a given program mean that the whole program is undefined or that behavior only becomes undefined once control flow hits this statement?</p>\n<p>Would the following program be well-defined in case the user never enters the number <code>3</code>?</p>\n<pre><code>while (true) {\n int num = ReadNumberFromConsole();\n if (num == 3)\n  *((char*)NULL) = 0; //undefined behavior\n}\n</code></pre>\n<p>Or is it entirely undefined behavior no matter what the user enters?</p>\n<p>Also, can the compiler assume that undefined behavior will never be executed at runtime? That would allow for reasoning backwards in time:</p>\n<pre><code>int num = ReadNumberFromConsole();\n\nif (num == 3) {\n PrintToConsole(num);\n *((char*)NULL) = 0; //undefined behavior\n}\n</code></pre>\n<p>Here, the compiler could reason that in case <code>num == 3</code> we will always invoke undefined behavior. Therefore, this case must be impossible and the number does not need to be printed. The entire <code>if</code> statement could be optimized out. Is this kind of backwards reasoning allowed according to the standard?</p>\n", "AcceptedAnswerId": "23154502", "Title": "Can branches with undefined behavior be assumed unreachable and optimized as dead code?", "CreationDate": "2014-04-18T11:44:22.867", "Id": "23153445", "CommentCount": "11", "FavoriteCount": "19", "PostTypeId": "1", "LastEditDate": "2017-05-11T16:06:14.663", "LastEditorUserId": "72178", "LastActivityDate": "2017-05-12T21:54:35.070", "Score": "72", "OwnerUserId": "122718", "Tags": "<c++><language-lawyer><undefined-behavior><dead-code><unreachable-code>", "AnswerCount": "8"}, "23155101": {"Id": "23155101", "PostTypeId": "2", "Body": "<p>The word \"behavior\" means something is being <em>done</em>. A statemenr that is never executed is not \"behavior\".</p>\n<p>An illustration:</p>\n<pre><code>*ptr = 0;\n</code></pre>\n<p>Is that undefined behavior? Suppose we are 100% certain <code>ptr == nullptr</code> at least once during program execution. The answer should be yes.</p>\n<p>What about this?</p>\n<pre><code> if (ptr) *ptr = 0;\n</code></pre>\n<p>Is that undefined? (Remember <code>ptr == nullptr</code> at least once?) I sure hope not, otherwise you won't be able to write any useful program at all.</p>\n<p>No srandardese was harmed in the making of this answer.</p>\n", "LastActivityDate": "2014-04-18T13:24:16.713", "CommentCount": "0", "CreationDate": "2014-04-18T13:24:16.713", "ParentId": "23153445", "Score": "3", "OwnerUserId": "775806"}, "bq_ids": {"n4140": {"so_23153445_23154502_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5801}, "so_23153445_23154502_2": {"length": 5, "quality": 0.625, "section_id": 5768}, "so_23153445_23153722_0": {"length": 7, "quality": 0.7, "section_id": 5800}, "so_23153445_23153645_1": {"length": 19, "quality": 0.95, "section_id": 5801}, "so_23153445_23153645_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 5800}}, "n3337": {"so_23153445_23154502_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5574}, "so_23153445_23153645_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 5573}, "so_23153445_23153722_0": {"length": 7, "quality": 0.7, "section_id": 5573}, "so_23153445_23153645_1": {"length": 19, "quality": 0.95, "section_id": 5574}, "so_23153445_23154502_2": {"length": 5, "quality": 0.625, "section_id": 5541}}, "n4659": {"so_23153445_23154502_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 7260}, "so_23153445_23153645_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 7259}, "so_23153445_23153722_0": {"length": 7, "quality": 0.7, "section_id": 7259}, "so_23153445_23153645_1": {"length": 19, "quality": 0.95, "section_id": 7260}, "so_23153445_23154502_2": {"length": 5, "quality": 0.625, "section_id": 7225}}}, "23165207": {"Id": "23165207", "PostTypeId": "2", "Body": "<p>An instructive example is</p>\n<pre><code>int foo(int x)\n{\n    int a;\n    if (x)\n        return a;\n    return 0;\n}\n</code></pre>\n<p>Both current GCC and current Clang will optimize this (on x86) to</p>\n<pre><code>xorl %eax,%eax\nret\n</code></pre>\n<p>because they <em>deduce that <code>x</code> is always zero</em> from the UB in the <code>if (x)</code> control path. GCC won't even give you a use-of-uninitialized-value warning!  (because the pass that applies the above logic runs before the pass that generates uninitialized-value warnings)</p>\n", "LastActivityDate": "2014-04-19T02:46:38.410", "CommentCount": "13", "CreationDate": "2014-04-19T02:46:38.410", "ParentId": "23153445", "Score": "5", "OwnerUserId": "388520"}, "43946985": {"Id": "43946985", "PostTypeId": "2", "Body": "<p>Many standards for many kinds of things expend a lot of effort on describing things which implementations SHOULD or SHOULD NOT do, using nomenclature similar to that defined in <a href=\"https://tools.ietf.org/html/rfc2119\" rel=\"nofollow noreferrer\">IETF RFC 2119</a> (though not necessarily citing the definitions in that document).  In many cases, descriptions of things that implementations should do <em>except in cases where they would be useless or impractical</em> are more important than the requirements to which <em>all</em> conforming implementations must conform.</p>\n<p>Unfortunately, C and C++ Standards tend to eschew descriptions of things which, while not 100% required, should nonetheless be expected of quality implementations which don't document contrary behavior.  A suggestion that implementations should do something might be seen as implying that those which don't are inferior, and in cases where it would generally be obvious which behaviors would be useful or practical, versus impractical and useless, on a given implementation, there was little perceived need for the Standard to interfere with such judgments.</p>\n<p>A clever compiler could conform to the Standard while eliminating any code that would have no effect except when code receives inputs that would inevitably cause Undefined Behavior, but \"clever\" and \"dumb\" are not antonyms.  The fact that the authors of the Standard decided that there might be some kinds of implementations where behaving usefully in a given situation would be useless and impractical does not imply any judgment as to whether such behaviors should be considered practical and useful on others.  If an implementation could uphold a behavioral guarantee for no cost beyond the loss of a \"dead-branch\" pruning opportunity, almost any value user code could receive from that guarantee would exceed the cost of providing it.  Dead-branch elimination may be fine in cases where it wouldn't require giving up <em>anything</em>, but if in a given situation user code could have handled almost any possible behavior <em>other</em> than dead-branch elimination, any effort user code would have to expend to avoid UB would likely exceed the value achieved from DBE.</p>\n", "LastActivityDate": "2017-05-12T21:54:35.070", "CommentCount": "5", "CreationDate": "2017-05-12T21:54:35.070", "ParentId": "23153445", "Score": "1", "OwnerUserId": "363751"}, "23154502": {"Id": "23154502", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23153445_23154502_0\">Does the existence of such a statement in a given program mean that\n  the whole program is undefined or that behavior only becomes undefined\n  once control flow hits this statement?</p>\n</blockquote>\n<p>Neither. The first condition is too strong and the second is too weak.</p>\n<p>Object access are sometimes sequenced, but the standard describes the behavior of the program outside of time. Danvil already quoted:</p>\n<blockquote>\n<p id=\"so_23153445_23154502_1\">if any such execution contains an undefined operation, this\n  International Standard places no requirement on the implementation\n  executing that program with that input (not even with regard to\n  operations preceding the first undefined operation)</p>\n</blockquote>\n<p>This can be interpreted:</p>\n<blockquote>\n<p id=\"so_23153445_23154502_2\">If the execution of the program yields undefined behavior, then the whole program has \n  undefined behavior.</p>\n</blockquote>\n<p>So, an unreachable statement with UB doesn't give the program UB. A reachable statement that (because of the values of inputs) is never reached, doesn't give the program UB. That's why your first condition is too strong.</p>\n<p>Now, the compiler cannot in general tell what has UB. So to allow the optimizer to re-order statements with potential UB that would be re-orderable should their behavior be defined, it's necessary to permit UB to \"reach back in time\" and go wrong prior to the preceding sequence point (or in C++11 terminology, for the UB to affect things that are sequenced before the UB thing). Therefore your second condition is too weak.</p>\n<p>A major example of this is when the optimizer relies on strict aliasing. The whole point of the strict aliasing rules is to allow the compiler to re-order operations that could not validly be re-ordered if it were possible that the pointers in question alias the same memory. So if you use illegally aliasing pointers, and UB does occur, then it can easily affect a statement \"before\" the UB statement. As far as the abstract machine is concerned the UB statement has not been executed yet. As far as the actual object code is concerned, it has been partly or fully executed. But the standard doesn't try to get into detail about what it means for the optimizer to re-order statements, or what the implications of that are for UB. It just gives the implementation license to go wrong as soon as it pleases.</p>\n<p>You can think of this as, \"UB has a time machine\".</p>\n<p>Specifically to answer your examples:</p>\n<ul>\n<li>Behavior is only undefined if 3 is read.</li>\n<li>Compilers can and do eliminate code as dead if a basic block contains an operation certain to be undefined. They're permitted (and I'm guessing do) in cases which aren't a basic block but where all branches lead to UB. This example isn't a candidate unless <code>PrintToConsole(3)</code> is somehow known to be sure to return. It could throw an exception or whatever.</li>\n</ul>\n<p>A similar example to your second is the gcc option <code>-fdelete-null-pointer-checks</code>, which can take code like this (I haven't checked this specific example, consider it illustrative of the general idea):</p>\n<pre><code>void foo(int *p) {\n    if (p) *p = 3;\n    std::cout &lt;&lt; *p &lt;&lt; '\\n';\n}\n</code></pre>\n<p>and change it to:</p>\n<pre><code>*p = 3;\nstd::cout &lt;&lt; \"3\\n\";\n</code></pre>\n<p>Why? Because if <code>p</code> is null then the code has UB anyway, so the compiler may assume it is not null and optimize accordingly. The linux kernel tripped over this (<a href=\"https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-1897\" rel=\"noreferrer\">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-1897</a>) essentially because it operates in a mode where dereferencing a null pointer <em>isn't</em> supposed to be UB, it's expected to result in a defined hardware exception that the kernel can handle. When optimization is enabled, gcc requires the use of <code>-fno-delete-null-pointer-checks</code> in order to provide that beyond-standard guarantee.</p>\n<p>P.S. The practical answer to the question \"when does undefined behavior strike?\" is \"10 minutes before you were planning to leave for the day\".</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2014-04-19T02:41:22.640", "Score": "52", "CreationDate": "2014-04-18T12:48:19.520", "ParentId": "23153445", "CommentCount": "5", "OwnerUserId": "13005", "LastEditDate": "2014-04-19T02:41:22.640"}, "23153645": {"Id": "23153645", "PostTypeId": "2", "Body": "<p>The standard states at 1.9/4</p>\n<blockquote>\n<p id=\"so_23153445_23153645_0\">[ Note: This International Standard imposes no requirements on the\n  behavior of programs that contain undefined behavior. \u2014 end note ]</p>\n</blockquote>\n<p>The interesting point is probably what \"contain\" means. A little later at 1.9/5 it states:</p>\n<blockquote>\n<p id=\"so_23153445_23153645_1\">However, if any such execution contains an undefined operation, this\n  International Standard places no requirement on the implementation\n  executing that program with that input (not even with regard to\n  operations preceding the first undefined operation)</p>\n</blockquote>\n<p>Here it specifically mentions \"execution ... with that input\". I would interpret that as, undefined behaviour in one possible branch which is not executed right now does not influence the current branch of execution.</p>\n<p>A different issue however are assumptions based on undefined behaviour during code generation. See the answer of Steve Jessop for more details about that.</p>\n", "LastEditorUserId": "316448", "LastActivityDate": "2014-04-18T15:17:42.480", "Score": "9", "CreationDate": "2014-04-18T11:57:47.610", "ParentId": "23153445", "CommentCount": "4", "OwnerUserId": "316448", "LastEditDate": "2014-04-18T15:17:42.480"}, "23721532": {"Id": "23721532", "PostTypeId": "2", "Body": "<p>The undefined behavior strikes when the program will cause undefined behavior no matter what happens next. However, you gave the following example.</p>\n<pre><code>int num = ReadNumberFromConsole();\n\nif (num == 3) {\n PrintToConsole(num);\n *((char*)NULL) = 0; //undefined behavior\n}\n</code></pre>\n<p>Unless the compiler knows definition of <code>PrintToConsole</code>, it cannot remove <code>if (num == 3)</code> conditional. Let's assume that you have <code>LongAndCamelCaseStdio.h</code> system header with the following declaration of <code>PrintToConsole</code>.</p>\n<pre><code>void PrintToConsole(int);\n</code></pre>\n<p>Nothing too helpful, all right. Now, let's see how evil (or perhaps not so evil, undefined behavior could have been worse) the vendor is, by checking actual definition of this function.</p>\n<pre><code>int printf(const char *, ...);\nvoid exit(int);\n\nvoid PrintToConsole(int num) {\n    printf(\"%d\\n\", num);\n    exit(0);\n}\n</code></pre>\n<p>The compiler actually has to assume that any arbitrary function the compiler doesn't know what does it do may exit or throw an exception (in case of C++). You can notice that <code>*((char*)NULL) = 0;</code> won't be executed, as the execution won't continue after <code>PrintToConsole</code> call.</p>\n<p>The undefined behavior strikes when <code>PrintToConsole</code> actually returns. The compiler expects this not to happen (as this would cause the program to execute undefined behavior no matter what), therefore anything can happen.</p>\n<p>However, let's consider something else. Let's say we are doing null check, and use the variable after null check.</p>\n<pre><code>int putchar(int);\n\nconst char *warning;\n\nvoid lol_null_check(const char *pointer) {\n    if (!pointer) {\n        warning = \"pointer is null\";\n    }\n    putchar(*pointer);\n}\n</code></pre>\n<p>In this case, it's easy to notice that <code>lol_null_check</code> requires a non-NULL pointer. Assigning to the global non-volatile <code>warning</code> variable is not something that could exit the program or throw any exception. The <code>pointer</code> is also non-volatile, so it cannot magically change its value in middle of function (if it does, it's undefined behavior). Calling <code>lol_null_check(NULL)</code> will cause undefined behavior which may cause the variable to not be assigned (because at this point, the fact that the program executes the undefined behavior is known).</p>\n<p>However, the undefined behavior means the program can do anything. Therefore, nothing stops the undefined behavior from going back in the time, and crashing your program before first line of <code>int main()</code> executes. It's undefined behavior, it doesn't have to make sense. It may as well crash after typing 3, but the undefined behavior will go back in time, and crash before you even type 3. And who knows, perhaps undefined behavior will overwrite your system RAM, and cause your system to crash 2 weeks later, while your undefined program is not running.</p>\n", "LastActivityDate": "2014-05-18T11:47:01.617", "CommentCount": "3", "CreationDate": "2014-05-18T11:47:01.617", "ParentId": "23153445", "Score": "1", "OwnerUserId": "736054"}});