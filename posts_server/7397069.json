post_cb({"7397149": {"Id": "7397149", "PostTypeId": "2", "Body": "<p>The thing to think about is, which parts of the object are constructed at the time when you call show()?  </p>\n<p>Since you call show() from within your constructor's body (and not e.g. from within the constructor's initializer list) you can rest assured that all of the A object's member variables have already been constructed (since that happens before the constructor body is executed).</p>\n<p>What might trip you up would be if show() was a virtual method, and A::A() was being called from the constructor of a subclass of A.  In that case, you might want show() to call B::show(), but that won't happen because the vtable for B hasn't been set up yet (you would end up calling A::show() instead, or crashing the program if A::show() was a pure-virtual method)</p>\n", "LastActivityDate": "2011-09-13T05:17:23.987", "CommentCount": "2", "CreationDate": "2011-09-13T05:17:23.987", "ParentId": "7397069", "Score": "1", "OwnerUserId": "131930"}, "7397127": {"Id": "7397127", "PostTypeId": "2", "Body": "<p>Consider a class as 2 separate parts: The object containing fields (variables) and the methods (functions). The methods of a given class exist independent of any particular instance, so it can be called at any time by a valid instance, even mid-construction.</p>\n<p>The fields are \"created\" when the object is instantiated, before the constructor is run. However, they have no values set to them. So, if your constructor calls any methods BEFORE the fields are initialised to sensible values, then you're going to experience some undefined behaviour.</p>\n<p>Whenever possible, if you must call a method inside a constructor, be sure to initialise as many fields as possible to sensible values.</p>\n", "LastActivityDate": "2011-09-13T05:15:36.033", "CommentCount": "0", "CreationDate": "2011-09-13T05:15:36.033", "ParentId": "7397069", "Score": "0", "OwnerUserId": "672149"}, "7397210": {"Id": "7397210", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7397069_7397210_0\">my doubt is that when i am creating an object using constructor then how i am able to call object function while object is not fully constructed?</p>\n</blockquote>\n<p>what happens in your example is fine, as long as you initialize where you are supposed to (the initialization list). you are using static dispatch on an object which has initialized members (specifically, <code>A</code> has no such variables to initialize).</p>\n<p>what then is invalid?</p>\n<ul>\n<li>not initializing your members correctly, or using them before they are really initialized. favor the initialization list without using <code>this</code>.</li>\n<li>using dynamic dispatch from within your constructor's body (or initializer). your object is not fully constructed.</li>\n<li>unusually, you could also attempt to typecast it to a subclass from the constructor.</li>\n</ul>\n", "LastActivityDate": "2011-09-13T05:25:59.887", "CommentCount": "0", "CreationDate": "2011-09-13T05:25:59.887", "ParentId": "7397069", "Score": "0", "OwnerUserId": "191596"}, "bq_ids": {"n4140": {"so_7397069_7397317_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 444}, "so_7397069_7397317_1": {"length": 26, "quality": 0.5416666666666666, "section_id": 447}, "so_7397069_7397317_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 447}}, "n3337": {"so_7397069_7397317_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 435}, "so_7397069_7397317_1": {"length": 26, "quality": 0.5416666666666666, "section_id": 438}, "so_7397069_7397317_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 438}}, "n4659": {"so_7397069_7397317_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 467}, "so_7397069_7397317_1": {"length": 26, "quality": 0.5416666666666666, "section_id": 469}, "so_7397069_7397317_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 469}}}, "7397091": {"Id": "7397091", "PostTypeId": "2", "Body": "<p>You are calling a function in an partially constructed object, which may result in erroneous behavior if such function deals with class members and such. I am not sure whether its invoking undefined behaviour or not, but I don't think its a good practice. And the situation gets worse with inheritance and virtual functions!</p>\n<p>In your example, show could be declared static and there will be no risk in calling it.</p>\n", "LastActivityDate": "2011-09-13T05:10:18.530", "CommentCount": "4", "CreationDate": "2011-09-13T05:10:18.530", "ParentId": "7397069", "Score": "0", "OwnerUserId": "927034"}, "7397069": {"ViewCount": "748", "Body": "<p>creating an object using a constructor and along with that calling functions of object which is being constructed:</p>\n<pre><code>class A\n{\n  public:\n        A()\n        {\n        this-&gt;show();\n        }   \n\n        void show()\n        {\n        cout&lt;&lt;\"show called!\";\n        }\n};\n</code></pre>\n<p>and now i m creating object in <code>main()</code> as below:</p>\n<pre><code>int main()\n{\n    A a;\n    int xy;\n    cin&gt;&gt;xy;\n    return 0;\n}\n</code></pre>\n<p>my doubt is that when i am creating an object using constructor then how i am able to call object function while object is not fully constructed?</p>\n<p>virtual function calls:</p>\n<pre><code>class A\n{\n  public:\n        A()\n        {\n\n        }   \n\n       virtual void show()\n        {\n        cout&lt;&lt;\"show called!\";\n        }\n};\nclass B:public A\n{\n      public: \n              B()\n              {\n                    A *a=this;\n                    a-&gt;show();\n\n                    }\n             void show()\n             {\n                  cout&lt;&lt;\"derived show\";\n                  }\n\n      };\n\n\nint main()\n{\n    A a;\n    B b;\n    int xy;\n    cin&gt;&gt;xy;\n    return 0;\n}\n</code></pre>\n<p>working fine with output: <code>derived show</code></p>\n", "Title": "how functions of a not fully constructed objects are called?", "CreationDate": "2011-09-13T05:06:47.817", "LastActivityDate": "2011-09-13T05:48:28.823", "CommentCount": "0", "LastEditDate": "2011-09-13T05:28:29.990", "PostTypeId": "1", "LastEditorUserId": "1633728", "Id": "7397069", "Score": "2", "OwnerUserId": "1633728", "Tags": "<c++><constructor>", "AnswerCount": "6"}, "7397317": {"Id": "7397317", "PostTypeId": "2", "Body": "<p>It's fine to call virtual functions and non-static member functions:</p>\n<p>See section 12.7 of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a>:</p>\n<blockquote>\n<p id=\"so_7397069_7397317_0\">4 Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2).</p>\n</blockquote>\n<p>However when using virtual functions in a constructor there are some restrictions. It's a bit of a mouthful:</p>\n<blockquote>\n<p id=\"so_7397069_7397317_1\">When a virtual function is called directly or indirectly from a\n  constructor (including the mem-initializer or\n  brace-or-equal-initializer for a non-static data member) or from a\n  destructor, and the object to which the call applies is the object\n  under construction or destruction, the function called is the one\n  defined in the constructor or destructor\u2019s own class or in one of its\n  bases, but not a function overriding it in a class derived from the\n  constructor or destructor\u2019s class, or overriding it in one of the\n  other base classes of the most derived object (1.8).</p>\n</blockquote>\n<p>I interpret the above paragraph as saying the virtual functions called will not be in any derived class. This makes sense because at this point in the execution phase any constructor in a derived class will not have begun execution.</p>\n<p>Additionally part 1 places a restriction that use of non-static members should occur after the construction begins. In your example the members are being invoked after the construction begins, so you're not violating part 1:</p>\n<blockquote>\n<p id=\"so_7397069_7397317_2\">1 For an object with a non-trivial constructor, referring to any\n  non-static member or base class of the object before the constructor\n  begins execution results in undefined behavior.</p>\n</blockquote>\n", "LastEditorUserId": "366817", "LastActivityDate": "2011-09-13T05:48:28.823", "Score": "4", "CreationDate": "2011-09-13T05:41:56.677", "ParentId": "7397069", "CommentCount": "1", "OwnerUserId": "366817", "LastEditDate": "2011-09-13T05:48:28.823"}, "7397132": {"Id": "7397132", "PostTypeId": "2", "Body": "<p>This code is completely legal. You can call methods\nin the class constructor.</p>\n<p>All constants (from the initialization list) are already  initialized and all base class constructors are called.</p>\n<p>However, You should not call virtual methods in the constructor. See <a href=\"http://www.artima.com/cppsource/nevercall.html\" rel=\"nofollow\">Scott Meyers</a> explanation for this restriction.</p>\n", "LastActivityDate": "2011-09-13T05:16:07.937", "CommentCount": "3", "CreationDate": "2011-09-13T05:16:07.937", "ParentId": "7397069", "Score": "1", "OwnerUserId": "25234"}});