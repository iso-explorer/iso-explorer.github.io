post_cb({"25312375": {"Id": "25312375", "PostTypeId": "2", "Body": "<p><code>decltype</code> deduces the type of <strong>expression</strong>, unless it is applied to a variable, in which case it deduces the type of that variable:</p>\n<blockquote>\n<p id=\"so_25312225_25312375_0\">The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_25312225_25312375_1\">\u2014 if e is an unparenthesized id-expression or an unparenthesized class member access, <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</p>\n<p id=\"so_25312225_25312375_2\">\u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_25312225_25312375_3\">\u2014 otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_25312225_25312375_4\">\u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n<p id=\"so_25312225_25312375_5\">\u00a77.1.6.2 [dcl.type.simple]</p>\n</blockquote>\n<p>Dereferencing a pointer yields an lvalue, and therefore <code>decltype</code> will deduce an lvalue reference to the type of the pointee:</p>\n<blockquote>\n<p id=\"so_25312225_25312375_6\">The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.</p>\n<p id=\"so_25312225_25312375_7\">\u00a75.3.1 [expr.unary.op]</p>\n</blockquote>\n<p>Therefore <code>decltype(*p)</code>, for some pointer <code>p</code>, deduces an lvalue reference to the type of the pointee.</p>\n<p>If you wish to get the type of the pointee from some pointer <code>p</code>, you can use:</p>\n<pre><code>std::remove_pointer&lt;decltype(p)&gt;::type\n</code></pre>\n<p>Or:</p>\n<pre><code>std::remove_reference&lt;decltype(*p)&gt;::type\n</code></pre>\n<p>Or, in your example, you can simply say <code>foo</code>, type deduction is not required.</p>\n", "LastEditorUserId": "1007504", "LastActivityDate": "2014-08-14T15:58:17.897", "Score": "11", "CreationDate": "2014-08-14T15:52:36.450", "ParentId": "25312225", "CommentCount": "1", "LastEditDate": "2014-08-14T15:58:17.897", "OwnerUserId": "1007504"}, "bq_ids": {"n4140": {"so_25312225_25312375_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}, "so_25312225_25312375_2": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_25312225_25312375_6": {"length": 19, "quality": 0.95, "section_id": 6064}, "so_25312225_25312375_3": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_25312225_25312375_1": {"length": 18, "quality": 1.0, "section_id": 5440}}, "n3337": {"so_25312225_25312375_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}, "so_25312225_25312375_2": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_25312225_25312375_6": {"length": 19, "quality": 0.95, "section_id": 5832}, "so_25312225_25312375_3": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_25312225_25312375_1": {"length": 18, "quality": 1.0, "section_id": 5235}}, "n4659": {"so_25312225_25312375_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}, "so_25312225_25312375_2": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_25312225_25312375_6": {"length": 18, "quality": 0.9, "section_id": 7560}, "so_25312225_25312375_3": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_25312225_25312375_1": {"length": 18, "quality": 1.0, "section_id": 6867}}}, "25312225": {"ViewCount": "2067", "Body": "<pre><code>template&lt;typename T&gt;\nstruct foo{\n    void f(){\n        decltype(*this) a(*this);\n        do_some_test(a);\n    }\n    T data;\n};\n//compiler won't accept this\n</code></pre>\n<p>In my interpretation, <code>decltype</code> should return the a type so that we can use it in declaration. But google says that in <code>decltype(x)</code>,if <code>x</code> is a lvalue, it will return <code>T&amp;</code> where <code>T</code> is the type of x.</p>\n<p>But what they designed it to return a reference for? Furthermore, what should I do to create a instance of the class that has the same type as <code>*this</code> in a template?</p>\n<p>So much thanks for tolerating my pure English. ;-)</p>\n", "AcceptedAnswerId": "25312375", "Title": "C++: Why decltype (*this) returns a reference?", "CreationDate": "2014-08-14T15:45:25.440", "Id": "25312225", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-08-14T15:58:17.897", "Score": "5", "OwnerUserId": "3262785", "Tags": "<c++><templates><generic-programming>", "AnswerCount": "1"}});