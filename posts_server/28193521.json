post_cb({"bq_ids": {"n4140": {"so_28193521_29545974_0": {"section_id": 149, "quality": 0.9333333333333333, "length": 14}, "so_28193521_29545974_1": {"section_id": 277, "quality": 1.0, "length": 24}}, "n3337": {"so_28193521_29545974_0": {"section_id": 143, "quality": 0.9333333333333333, "length": 14}, "so_28193521_29545974_1": {"section_id": 268, "quality": 1.0, "length": 24}}, "n4659": {"so_28193521_29545974_0": {"section_id": 153, "quality": 0.9333333333333333, "length": 14}, "so_28193521_29545974_1": {"section_id": 284, "quality": 1.0, "length": 24}}}, "29545974": {"ParentId": "28193521", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your first implementation is not directly possible, because:</p>\n<p>Paragraph 14.5.5.3/1 of the C++11 Standard</p>\n<blockquote>\n<p id=\"so_28193521_29545974_0\">[...] class template specialization is a distinct template. The members of the class template partial specialization <strong>are unrelated to the members of the primary template</strong>. [...]</p>\n</blockquote>\n<p>This means that the member <code>struct Vertex</code> need not to exist in the partial template specialization of the class <code>Graph</code> and can thus not be defined directly, without specializing the whole class.</p>\n<p>So, you can not do something like:</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nclass Graph { struct Vertex; };\n\ntemplate&lt;typename T2&gt; \nstruct Graph&lt;double, T2&gt;::Vertex { };\n</code></pre>\n<p>(see also <a href=\"https://stackoverflow.com/questions/13923684/template-class-incomplete-specialization\">Template class incomplete specialization</a>)</p>\n<p>Paragraph 14.7.3/15 of the C++11 Standard</p>\n<blockquote>\n<p id=\"so_28193521_29545974_1\">A member or a member template may be nested within many enclosing class templates.  In an explicit specialization for such a member, the member declaration <strong>shall be preceded by a</strong> <code>template&lt;&gt;</code> <strong>for each enclosing class template that is explicitly specialized</strong></p>\n</blockquote>\n<p>(see also <a href=\"https://stackoverflow.com/questions/17129543/specializing-inner-template-with-default-parameters\">Specializing inner template with default parameters</a> as indicated by IdeaHat)</p>\n<p>This means:</p>\n<pre><code>template&lt;typename VertexValue = void, bool directed = false&gt;\nstruct Graph {\n    struct Vertex;\n};\n\n// template implementation\ntemplate&lt;typename VertexValue, bool directed&gt;\nstruct Graph&lt;VertexValue, directed&gt;::Vertex {\n    using ValueType = VertexValue;\n};\n\n// full specialization\ntemplate&lt;&gt;\nstruct Graph&lt;void, false&gt;::Vertex {\n    using ValueType = void;\n};\n</code></pre>\n<p>works fine.</p>\n<h2>Workaround</h2>\n<p>A possible solution could be to put all the types you want to specialize into a base class of <code>Graph</code> and then specialize this base class completely:</p>\n<pre><code>template&lt;typename VertexValue, bool directed&gt;\nstruct BaseGraph;\n\ntemplate&lt;typename VertexValue = void, bool directed = false, \n        typename Base = BaseGraph&lt;VertexValue, directed&gt; &gt;\nstruct Graph : public Base {\n    using Vertex = typename Base::Vertex;\n};\n\n// Directed, with value\ntemplate&lt;typename VertexValue, bool directed&gt;\nstruct BaseGraph {\n    struct Vertex {\n        using ValueType = VertexValue;\n    };\n};\n\n// Directed, without value\ntemplate&lt;bool directed&gt;\nstruct BaseGraph&lt;void, directed&gt; {\n    struct Vertex {\n        using ValueType = void;\n    };\n};\n\n// Undirected, with value\ntemplate&lt;typename VertexValue&gt;\nstruct BaseGraph&lt;VertexValue, false&gt; {\n    struct Vertex {\n        using ValueType = VertexValue;\n    };\n};\n\n// Undirected, without value\ntemplate&lt;&gt;\nstruct BaseGraph&lt;void, false&gt; {\n    struct Vertex {\n        using ValueType = void;\n    };\n};\n</code></pre>\n<p>But this is very similar to your approach with an external GraphVertex class, that I would prefer.</p>\n", "OwnerUserId": "2708773", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:50:44.460", "Id": "29545974", "Score": "0", "CreationDate": "2015-04-09T18:15:34.560", "LastActivityDate": "2015-04-09T18:15:34.560"}, "28193521": {"CommentCount": "2", "ViewCount": "373", "CreationDate": "2015-01-28T13:30:25.390", "LastActivityDate": "2015-04-09T18:15:34.560", "Title": "Nested class specialization in terms of outer class template arguments", "PostTypeId": "1", "Id": "28193521", "Score": "2", "Body": "<p>I am writing a Graph class and I want to provide multiple types of graphs with the same class. More specifically, I want to consider directed or undirected graphs, as well as the possibility for vertices (and edges) to have values.</p>\n<p>Right now, my class looks something like that.</p>\n<pre><code>template&lt;typename VertexValue = void, typename EdgeValue = void, bool directed = false&gt;\nclass Graph {\npublic:\n    struct Vertex;\n    using Edge = Vertex::Edge;\n\n    Graph() = default;\n    //void addVertex(const VertexValue&amp; vertex);\n\nprivate:\n    std::vector&lt;Vertex&gt; m_vertices;\n};\n</code></pre>\n<p>For convenience, I will skip anything related to edges implementation.</p>\n<p>What I want to do now is to \"specialize\" the Vertex class to provide - or not - a value, and different methods depending on whether the graph is directed or not. I would like to be able to do something like the following (note : Vertex methods are only for illustrating purposes, directed and undirected versions of Vertex having different methods).</p>\n<pre><code>template&lt;typename VertexValue = void, bool directed = false&gt;\nclass Graph {\npublic:\n    struct Vertex;\n\nprivate:\n    std::vector&lt;Vertex&gt; m_vertices;\n};\n\n// Directed, with value\ntemplate&lt;typename VertexValue, bool directed&gt;\nstruct Graph&lt;VertexValue, directed&gt;::Vertex {\n    using ValueType = VertexValue;\n\n    EdgeIterator inEdges();\n    EdgeIterator outEdges();\n\n    ValueType value;\n};\n\n// Directed, without value\ntemplate&lt;bool directed&gt;\nstruct Graph&lt;void, directed&gt;::Vertex {\n    using ValueType = void;\n\n    EdgeIterator inEdges();\n    EdgeIterator outEdges();\n};\n\n// Undirected, with value\ntemplate&lt;typename VertexValue&gt;\nstruct Graph&lt;VertexValue, false&gt;::Vertex {\n    using ValueType = VertexValue;\n\n    EdgeIterator edges();\n\n    ValueType value;\n};\n\n// Undirected, without value\ntemplate&lt;&gt;\nstruct Graph&lt;void, false&gt;::Vertex {\n    using ValueType = void;\n\n    EdgeIterator edges();\n};\n</code></pre>\n<p>Unfortunately, I would have to specialize the whole Graph class in order to do that. So I tried something else : having the Vertex class being a template, and forwarding the outer template arguments.</p>\n<pre><code>template&lt;typename VertexValue = void, bool directed = false&gt;\nclass Graph {\npublic:\n    template&lt;typename Value, bool, typename dummy = void&gt;\n    struct Vertex;\n\nprivate:\n    std::vector&lt;Vertex&lt;VertexValue, directed&gt;&gt; m_vertices;\n};\n\n// Directed, with value\ntemplate&lt;typename VertexValue, bool directed&gt;\ntemplate&lt;typename Value, bool, typename dummy&gt;\nstruct Graph&lt;VertexValue, directed&gt;::Vertex {\n    using ValueType = Value;\n\n    EdgeIterator inEdges();\n    EdgeIterator outEdges();\n\n    ValueType value;\n};\n\n// Directed, without value\ntemplate&lt;typename VertexValue, bool directed&gt;\ntemplate&lt;bool directed_, typename dummy&gt;\nstruct Graph&lt;VertexValue, directed&gt;::Vertex&lt;void, directed_, dummy&gt; {\n    using ValueType = void;\n\n    EdgeIterator inEdges();\n    EdgeIterator outEdges();\n};\n\n// Undirected, with value\ntemplate&lt;typename VertexValue, bool directed&gt;\ntemplate&lt;typename Value, typename dummy&gt;\nstruct Graph&lt;VertexValue, directed&gt;::Vertex&lt;Value, false, dummy&gt; {\n    using ValueType = Value;\n\n    EdgeIterator edges();\n\n    ValueType value;\n};\n\n// Undirected, without value\ntemplate&lt;typename VertexValue, bool directed&gt;\ntemplate&lt;typename dummy&gt;\nstruct Graph&lt;VertexValue, directed&gt;::Vertex&lt;void, false, dummy&gt; {\n    using ValueType = void;\n\n    EdgeIterator edges();\n};\n</code></pre>\n<p>This would work ; however, I do not like the idea of forwarding the template arguments, and it also introduces a burden, the dummy template parameter. I have also thought about defining the Vertex class outside of the Graph class, like so :</p>\n<pre><code>template&lt;typename ValueType, bool directed&gt;\nclass GraphVertex {\n    EdgeIterator inEdges();\n    EdgeIterator outEdges();\n\n    ValueType value;\n};\n\n// Specializations...\n\ntemplate&lt;typename Vertex = GraphVertex&lt;void, false&gt;&gt;\nclass Graph {\npublic:\n    // ...\nprivate:\n    std::vector&lt;Vertex&gt; m_vertices;\n};\n</code></pre>\n<p>...or even like that :</p>\n<pre><code>template&lt;typename ValueType, bool directed&gt;\nclass GraphVertex {\n    EdgeIterator inEdges();\n    EdgeIterator outEdges();\n\n    ValueType value;\n};\n\n// Specializations...\n\ntemplate&lt;typename VertexValue = void, bool directed = false&gt;\nclass Graph {\npublic:\n    // ...\nprivate:\n    std::vector&lt;GraphVertex&lt;VertexValue, directed&gt;&gt; m_vertices;\n};\n</code></pre>\n<p>...but I prefer the idea of nested class, where the Vertex class really is a property of the Graph class. Plus, even if this solution, out of the three, would still have my preference, I do not find any other name for \"GraphVertex\". And it bothers me.</p>\n<p>In the end, here is my question. Is there any other way to do what I want (namely, provide different Vertex classes - or <em>features</em> - depending on the Graph template arguments) ? If so, how to and what would be the advantages ; if not, what should I prefer and why ?</p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "3854570", "AnswerCount": "1"}});