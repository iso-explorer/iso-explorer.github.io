post_cb({"bq_ids": {"n4140": {"so_43028532_43061457_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 514}, "so_43028532_43061457_2": {"length": 8, "quality": 1.0, "section_id": 523}, "so_43028532_43061457_3": {"length": 19, "quality": 0.9047619047619048, "section_id": 523}, "so_43028532_43061457_4": {"length": 24, "quality": 0.8888888888888888, "section_id": 530}}, "n3337": {"so_43028532_43061457_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 505}, "so_43028532_43061457_2": {"length": 8, "quality": 1.0, "section_id": 514}, "so_43028532_43061457_3": {"length": 19, "quality": 0.9047619047619048, "section_id": 514}, "so_43028532_43061457_4": {"length": 24, "quality": 0.8888888888888888, "section_id": 521}}, "n4659": {"so_43028532_43061457_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 535}, "so_43028532_43061457_2": {"length": 8, "quality": 1.0, "section_id": 544}, "so_43028532_43061457_3": {"length": 19, "quality": 0.9047619047619048, "section_id": 544}, "so_43028532_43061457_4": {"length": 24, "quality": 0.8888888888888888, "section_id": 551}}}, "43061457": {"Id": "43061457", "PostTypeId": "2", "Body": "<p><em>I've done a test with VC++2010...</em></p>\n<p>MS's preprocessor was never made standard.  <a href=\"https://msdn.microsoft.com/en-us/library/hh567368.aspx\" rel=\"nofollow noreferrer\">They phrase it this odd way</a>:</p>\n<blockquote id=\"so_43028532_43061457_0\"><b>C99 __func__ and Preprocessor Rules</b> ...  For C99 preprocessor rules, \"Partial\" is listed because variadic macros are supported.</blockquote>\n<p>In other words, \"we support variadic macros; therefore we qualify as partially compliant\".  AFAIK standard compliance for the preprocessor is considered very low priority by the MS team.  So I wouldn't tend to use VC or VC++ as a model of the standard preprocessor.  gcc's a better model of the standard preprocessor here.</p>\n<p>Since this is about the preprocessor I'm going to focus the story on just this snippet:</p>\n<pre><code>#define AA for, S\n#define VALUE_TO_STRING(x) ^x!\n#define VALUE(x) VALUE_TO_STRING(x)\nVALUE(AA)\n</code></pre>\n<p>I'll be referencing ISO-14882 2011 here, which uses different numbers than 1998/2003.  Using those numbers, here's what happens starting at the expansion step, step by step... except for steps not relevant here which I'll skip.</p>\n<p>The preprocessor sees <code>VALUE(AA)</code>, which is a function-like invocation of a previously defined function-like macro.  So the first thing it does is argument identification, referencing 16.3 paragraph 4:</p>\n<blockquote id=\"so_43028532_43061457_1\">[if not variadic] the number of arguments (including those arguments consisting of no preprocessing tokens) in an invocation of a function-like macro shall equal the number of parameters in the macro definition</blockquote>\n<p>...and a portion of 16.3.1 paragraph 1:</p>\n<blockquote id=\"so_43028532_43061457_2\">After the arguments for the invocation of a function-like macro have been identified,</blockquote>\n<p>At this step, the preprocessor identifies that there is indeed one argument, that the macro was defined with one argument, and that the parameter <code>x</code> matches the invocation argument <code>AA</code>.  So far, argument matching and <code>x is AA</code> is all that happened.</p>\n<p>Then we get to the next step, which is <em>argument</em> expansion.  With respect to this step, the only thing about the replacement list that really matters is where the parameters are in it, and whether or not the parameters are part of stringification (<code># x</code>) or pasting (<code>x ## ...</code> or <code>... ## x</code>).  If there are arguments in the replacement list that are neither, <em>then</em> those arguments are expanded (stringified or pasted versions of the arguments don't count during this step).  This expansion happens first, before anything else interesting goes on in the invocation, and it occurs just as if the preprocessor were only expanding the invocation parameter.</p>\n<p>In this case, the replacement list is <code>VALUE_TO_STRING(x)</code>.  Again, <code>VALUE_TO_STRING</code> might be a function-like macro, but since we're doing argument expansion right now we really don't care.  The only thing we care about is that <code>x</code> is there, and it's not being stringified or pasted.  <code>x</code> is being invoked with <code>AA</code>, so the preprocessor evaluates <code>AA</code> as if <code>AA</code> were on a line instead of <code>VALUE(AA)</code>.  <code>AA</code> is an object-like macro that expands to <code>for, S</code>.  So the replacement list transforms into <code>VALUE_TO_STRING(for, S)</code>.</p>\n<p>This is the rest of 16.3.1 paragraph 1 in action:</p>\n<blockquote id=\"so_43028532_43061457_3\">A parameter in the replacement list, unless [stringified or pasted] is replaced by the corresponding argument after all macros contained therein have been expanded [...] as if they formed the rest of the preprocessing file</blockquote>\n<p>So far so good.  But now we reach the next part, in 16.3.4:</p>\n<blockquote id=\"so_43028532_43061457_4\">After all parameters in the replacement list have been substituted and [stuff not happening here] the resulting preprocessing token sequence\nis rescanned, along with all subsequent preprocessing tokens of the source file, for more macro names to replace.</blockquote>\n<p>This part evaluates <code>VALUE_TO_STRING(for, S)</code>, as if that were the preprocessing token set (except that it also temporarily forgets that <code>VALUE</code> is a macro per 16.3.4p2, but that doesn't come into play here).  That evaluation recognizes VALUE_TO_STRING as a function-like macro, being invoked like one, so argument identification begins again.  Only here, VALUE_TO_STRING was defined to take one argument, but is invoked with two.  That fails 16.3 p 4.</p>\n", "LastEditorUserId": "3936002", "LastActivityDate": "2017-03-29T15:11:55.493", "Score": "2", "CreationDate": "2017-03-28T05:45:08.983", "ParentId": "43028532", "CommentCount": "0", "OwnerUserId": "3936002", "LastEditDate": "2017-03-29T15:11:55.493"}, "43028532": {"ViewCount": "91", "Body": "<p>How should we interpret the following macro definition using the C++ standard? Notice the main issue is that replacement-list for <code>AA</code> contains embedded comma (<code>for, S</code>)</p>\n<pre><code>#define AA for, S    //&lt;---note the embedded comma\n#define VALUE_TO_STRING(x) ^x!\n#define VALUE(x) VALUE_TO_STRING(x)\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    VALUE(AA)\n    return 0;\n}\n</code></pre>\n<p>I've done a test with VC++2010 and the final result of the above looks like the following without any error but I've problem interpreting the steps that it took to come up with the result using C++03 (or C++11) standard:</p>\n<pre><code>int wmain(int argc, _TCHAR* argv[])\n{\n    ^for, S!\n    return 0;\n}\n</code></pre>\n<p>I've done some step by step tests with VC++2010. First I commented out the 2nd macro to see what was happening in the first step:</p>\n<pre><code>#define AA for, S\n//#define VALUE_TO_STRING(x) ^x!\n#define VALUE(x) VALUE_TO_STRING(x)\n</code></pre>\n<p>The macro replacement is straight forward and yielded a sequence that looks like another function-like macro having TWO arguments:</p>\n<pre><code>int wmain(int argc, _TCHAR* argv[])\n{\n    VALUE_TO_STRING(for, S)\n    return 0;\n}\n</code></pre>\n<p>According to [cpp.rescan] the next step is to re-scan this for more macro names. The question here is should this new macro be interpreted as a function-like macro with 2 arguments or 1 argument \"<code>for, S</code>\". </p>\n<p>The normal interpretation is to consider VALUE_TO_STRING() is given 2 arguments which is invalid and hence a preprocessor error is resulted. But how come the VC++ came up with a result without any error? Obviously, the second step VC++ took was to consider the <code>for, S</code> as 1 single argument which doesn't make sense and isn't defined by the C++ standard.</p>\n", "AcceptedAnswerId": "43061457", "Title": "How Should We Interpret a Macro with an Embedded Comma", "CreationDate": "2017-03-26T12:12:42.663", "Id": "43028532", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-03-26T12:14:42.067", "LastEditorUserId": "817643", "LastActivityDate": "2017-03-29T15:11:55.493", "Score": "0", "OwnerUserId": "237575", "Tags": "<c++><c-preprocessor><language-lawyer>", "AnswerCount": "2"}, "43029735": {"Id": "43029735", "PostTypeId": "2", "Body": "<p>I think the answer is in order of expanding.</p>\n<p>Your simulation of preprocessor expanding, i.e. your choice of which macro to expand first, does in my opinion not match what the preprocessor does.</p>\n<p>I, acting as a preprocessor (according to standard I believed at first; but a comment contradicts), would expand your code in this order:</p>\n<pre><code>VALUE(AA)\nVALUE_TO_STRING(AA)\n^AA!\n^for, S!\n</code></pre>\n<p>This matches the result of the preprocessor for the original code.\nNote that by this order it never sees the code <code>VALUE_TO_STRING(for, S)</code>, the closest it gets is <code>VALUE_TO_STRING(AA)</code>. That code does not cause the question concerning the number of arguments.</p>\n<p>I did not quote anything from the standard, I think your quotes are sufficient.</p>\n<p>As mentioned in a comment below, my answer is now an attempt how the result could be explained, without assuming conforming preprocessor. Any answer explaining with conforming behaviour is definitely better.</p>\n<p>By the way, acting as a compiler, I would probably not understand the<br>\n<code>^anything!</code> as a way to make a string from a value either. But that is not the question and I assume that the meaning was lost, when you prepared the minimal example. That is of course perfectly allright. It might however influence the expansion, if it ever expands to a quoted macro name, e.g. <code>\"AA\"</code>. That would stop expanding and the result could unveil what happened.</br></p>\n", "LastEditorUserId": "995714", "LastActivityDate": "2017-03-28T05:52:54.810", "Score": "0", "CreationDate": "2017-03-26T14:05:45.100", "ParentId": "43028532", "CommentCount": "6", "OwnerUserId": "7733418", "LastEditDate": "2017-03-28T05:52:54.810"}});