post_cb({"bq_ids": {"n4140": {"so_48372792_48372826_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_48372792_48372826_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 6138}}, "n3337": {"so_48372792_48372826_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}, "so_48372792_48372826_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5902}}, "n4659": {"so_48372792_48372826_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_48372792_48372826_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7635}}}, "48372792": {"ViewCount": "143", "Body": "<p>I'm trying to understand the implicit conversion rules in C++ and I understood that when there are one operation between two primary types the \"lower type\" is promoted to the \"higher type\", so let say for:</p>\n<pre><code>int a = 5;\nfloat b = 0.5;\n\nstd::cout &lt;&lt; a + b &lt;&lt; \"\\n\";\n</code></pre>\n<p>should print 5.5 because 'a' gets promoted to float type. I also understood that unsigned types are \"higher types\" than the signed counter parts so:</p>\n<pre><code>int c = 5;\nunsigned int d = 10;\n\nstd::cout &lt;&lt; c - d &lt;&lt; \"\\n\";\n</code></pre>\n<p>prints 4294967291 because 'c' gets promoted to a unsigned int and since unsigned types wraps around when less than zero we get that big number.</p>\n<p>However for the following case I don't understand why I am getting -105 instead of a positive number.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n    unsigned char a = 150;\n    std::cout &lt;&lt; static_cast&lt;int&gt;(a - static_cast&lt;unsigned char&gt;(255)) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>I guess that this code:</p>\n<pre><code>a - static_cast&lt;unsigned char&gt;(255)\n</code></pre>\n<p>should result in a positive number so the final cast (to int) shouldn't affect the final result right?</p>\n", "AcceptedAnswerId": "48372826", "Title": "Why does C++ prints unsigned char value as negative?", "CreationDate": "2018-01-21T23:23:24.793", "LastActivityDate": "2018-01-21T23:39:17.237", "CommentCount": "4", "LastEditDate": "2018-01-21T23:38:47.553", "PostTypeId": "1", "LastEditorUserId": "2173917", "Id": "48372792", "Score": "3", "OwnerUserId": "1499019", "Tags": "<c++><char><unsigned><type-promotion>", "AnswerCount": "3"}, "48372826": {"Id": "48372826", "PostTypeId": "2", "Body": "<p>Quoting from <code>C++14</code>, chapter \u00a7 5.7</p>\n<blockquote>\n<p id=\"so_48372792_48372826_0\">The additive operators <code>+</code> and <code>-</code> group left-to-right. The usual arithmetic conversions are performed for\n  operands of arithmetic or enumeration type.</p>\n</blockquote>\n<p>and for <em>usual arithmetic conversions</em>, (specific for this case)</p>\n<blockquote>\n<p id=\"so_48372792_48372826_1\">....</p>\n<ul>\n<li>Otherwise, the integral promotions (4.5) shall be performed on both operands</li>\n</ul>\n</blockquote>\n<p>and, finally, for <em>integral promotions</em>, chapter \u00a7 4.5</p>\n<blockquote>\n<p id=\"so_48372792_48372826_2\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion\n  rank (4.13) is less than the rank of int can be converted to a prvalue of type <code>int</code> if int can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned\n  int.</code></p>\n</blockquote>\n<p>Hence, the <code>unsigned char</code> operands are promoted to <code>int</code> and then , the result is calculated.</p>\n", "LastEditorUserId": "2173917", "LastActivityDate": "2018-01-21T23:33:26.070", "Score": "2", "CreationDate": "2018-01-21T23:27:53.440", "ParentId": "48372792", "CommentCount": "4", "OwnerUserId": "2173917", "LastEditDate": "2018-01-21T23:33:26.070"}, "48372885": {"Id": "48372885", "PostTypeId": "2", "Body": "<p>There are answers here showing what is happening. I won't repeat. I am going to give you a simple tool to help you.</p>\n<p>Here is a trick you can do to <strong>quickly</strong> find the type of an expression:</p>\n<pre><code>template &lt;class&gt; struct Name; // purposely no definition given\n\nName&lt;decltype(your_expression)&gt; n;\n</code></pre>\n<p>This will generate a compiler error for undefined template 'Name', but what we are really interested in is the type of the template argument which will appear in the error message.</p>\n<p>E.g. if you want to see what type you get when you do arithmetic between two <code>unsigned char</code>:</p>\n<pre><code>#include &lt;utility&gt;\ntemplate &lt;class&gt; struct Name;\n\nauto test()\n{\n    Name&lt;decltype(std::declval&lt;unsigned char&gt;() - std::declval&lt;unsigned char&gt;())&gt; n;\n\n   // or\n   unsigned char a{};\n   Name&lt;decltype(a - a)&gt; n2;\n}\n</code></pre>\n<p>will get you</p>\n<blockquote id=\"so_48372792_48372885_0\">\n<pre><code>error: implicit instantiation of undefined template 'Name&lt;int&gt;'\n</code></pre>\n</blockquote>\n<p>which will show you that the type of the expression is <code>int</code></p>\n<p>Of course this won't tell you the rules involved, but it is a quick starting point to see the type of the expression or to verify your assumption of the type of the expression.</p>\n", "LastActivityDate": "2018-01-21T23:39:17.237", "Score": "2", "CreationDate": "2018-01-21T23:39:17.237", "ParentId": "48372792", "CommentCount": "1", "OwnerUserId": "2805305"}, "48372813": {"Id": "48372813", "PostTypeId": "2", "Body": "<p>You're missing the (implicit) conversion from <code>unsigned char</code> to <code>int</code> that happens to perform the <code>-</code> (subtract) operation.  This integer promotion happens any time you try to apply any integer operation to a value of some integral type smaller than <code>int</code>.</p>\n", "LastActivityDate": "2018-01-21T23:26:13.973", "Score": "4", "CreationDate": "2018-01-21T23:26:13.973", "ParentId": "48372792", "CommentCount": "6", "OwnerUserId": "16406"}});