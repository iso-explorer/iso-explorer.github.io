post_cb({"bq_ids": {"n4140": {"so_15885492_15885633_0": {"length": 29, "quality": 1.0, "section_id": 268}}, "n3337": {"so_15885492_15885633_0": {"length": 29, "quality": 1.0, "section_id": 259}}, "n4659": {"so_15885492_15885633_0": {"length": 29, "quality": 1.0, "section_id": 275}}}, "15885633": {"Id": "15885633", "PostTypeId": "2", "Body": "<p>The problem is most likely in the fact that you relegated the specializations of your member function <code>runFFT()</code> for <code>int16_t</code> and <code>Ipp32f</code> in a separate <code>.cpp</code> file without providing a corresponding declaration after the primary template, so the compiler at the point of instantiation (which likely belongs to another translation unit that <code>#include</code>s only the header file containing the definition of <code>Client</code>) doesn't know about the existence of those explicit specializations.</p>\n<p>Put a <em>declaration</em> for those specializations in the same header file that contains the definition of your class template:</p>\n<pre><code>template&lt;typename T&gt; \ninline void UnusedParameter( T const&amp; ) { }\n\nclass Client\n{\npublic:\n    template&lt;class T&gt;\n    void runFFT(T *wSamples, float const &amp;fMult)\n    {\n        std::cout &lt;&lt; \"INSIDE RUNFFT : : :\" &lt;&lt; std::endl;\n        UnusedParameter(wSamples);\n        UnusedParameter(fMult);\n    }\n};\n\n// DECLARE YOUR EXPLICIT SPECIALIZATIONS HERE\n\ntemplate&lt;&gt;\nvoid Client::runFFT&lt;int16_t&gt;(int16_t *wSamples, float const &amp;fMult);\n\ntemplate&lt;&gt;\nvoid Client::runFFT&lt;Ipp32f&gt;(Ipp32f *wSamples, float const &amp;fMult);\n</code></pre>\n<p>Per Paragraph 14.7.3/6 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15885492_15885633_0\">If a template, a member template or a <strong>member of a class template</strong> is explicitly specialized then that specialization\n  shall be <strong>declared before the first use of that specialization that would cause an implicit instantiation\n  to take place</strong>, in every translation unit in which such a use occurs; <strong>no diagnostic is required</strong>. [...]</p>\n</blockquote>\n<p>The \"<em>no diagnostic is required</em>\" part means that if you don't follow this rule, your program will be ill-formed, but your compiler/linker is not required to tell you. This normally results in the kind of undefined behavior you are observing.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-04-08T18:06:27.417", "Score": "3", "CreationDate": "2013-04-08T17:51:15.643", "ParentId": "15885492", "CommentCount": "4", "OwnerUserId": "1932150", "LastEditDate": "2013-04-08T18:06:27.417"}, "15885492": {"ViewCount": "73", "Body": "<p>I have an object like the following </p>\n<pre><code>template&lt;typename T&gt; \ninline void UnusedParameter( T const&amp; )\n{\n\n}\n\nclass Client\n{\npublic:\n  template&lt;class T&gt;\n  void runFFT(T *wSamples, float const &amp;fMult)\n  {\n    std::cout &lt;&lt; \"INSIDE RUNFFT : : :\" &lt;&lt; std::endl;\n    UnusedParameter(wSamples);\n    UnusedParameter(fMult);\n  }\n};\n</code></pre>\n<p>And in my CPP I have the following:</p>\n<pre><code>#include \"object.hpp\"\n\ntemplate&lt;&gt;\nvoid Client::runFFT&lt;int16_t&gt;(int16_t *wSamples, float const &amp;fMult)\n{\n  std::cout &lt;&lt; \"INSIDE INT16_T version: : :\" &lt;&lt; std::endl;\n  UnusedParameter(wSamples);\n  UnusedParameter(fMult);\n}\n\ntemplate&lt;&gt;\nvoid Client::runFFT&lt;Ipp32f&gt;(Ipp32f *wSamples, float const &amp;fMult)\n{\n  std::cout &lt;&lt; \"INSIDE IPP32F version: : :\" &lt;&lt; std::endl;\n  UnusedParameter(wSamples);\n  UnusedParameter(fMult);\n}\n</code></pre>\n<p>Both these implementation run without any problem in my Debug Code. It enters the int16_t version without problem and the Ipp32f version also without problem.</p>\n<p>But when I try the Run version it only enters the Template, like the compiler only compiles the Template implementation in the header.</p>\n<p>How do I prevent this from happenning? Shall I remove this and just create two different methods? I love my templates but these Heisenberg bugs are frustating.</p>\n<p>Thanks for any input. </p>\n<p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</p>\n<p>Andy Prowl answered this question and it is solved doing the following in the HPP:</p>\n<pre><code>template&lt;typename T&gt; \ninline void UnusedParameter( T const&amp; )\n{\n\n}\n\nclass Client\n{\npublic:\n  template&lt;class T&gt;\n  void runFFT(T *, float const &amp;)\n  {\n    // Thanks for Joachim for removing my Unused Parameter crap\n    std::cout &lt;&lt; \"INSIDE RUNFFT : : :\" &lt;&lt; std::endl;\n  }\n};\n\ntemplate&lt;&gt;\nvoid Client::runFFT&lt;int16_t&gt;(int16_t *wSamples, float const &amp;fMult);\n\ntemplate&lt;&gt;\nvoid Client::runFFT&lt;Ipp32f&gt;(Ipp32f *wSamples, float const &amp;fMult);\n</code></pre>\n<p>And now it works in runtime as well. The CPP stays the same.</p>\n", "AcceptedAnswerId": "15885633", "Title": "Template Run version Different from Debug", "CreationDate": "2013-04-08T17:42:17.323", "Id": "15885492", "CommentCount": "4", "LastEditDate": "2013-04-08T18:08:19.590", "PostTypeId": "1", "LastEditorUserId": "1963929", "LastActivityDate": "2013-04-08T18:08:19.590", "Score": "1", "OwnerUserId": "1963929", "Tags": "<c++><templates><runtime-error>", "AnswerCount": "1"}});