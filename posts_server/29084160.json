post_cb({"29084412": {"ParentId": "29084160", "CommentCount": "1", "Body": "<p>Good question! This is actually specifically addressed by clause 25 in \u00a71.10 of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_29084160_29084412_0\">An implementation should ensure that the last value (in modification order) assigned by an atomic or\n  synchronization operation will become visible to all other threads in a finite period of time.</p>\n</blockquote>\n<p>So the answer is yes, the value is guaranteed to eventually propagate to the other thread, even with relaxed memory ordering.</p>\n", "OwnerUserId": "21475", "PostTypeId": "2", "Id": "29084412", "Score": "4", "CreationDate": "2015-03-16T18:34:42.890", "LastActivityDate": "2015-03-16T18:34:42.890"}, "29084160": {"CommentCount": "0", "ViewCount": "138", "CreationDate": "2015-03-16T18:19:52.907", "LastActivityDate": "2015-03-16T18:34:42.890", "Title": "What guarantees that a weak relaxed uncontended CAS loop terminates?", "AcceptedAnswerId": "29084412", "PostTypeId": "1", "Id": "29084160", "Score": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange\" rel=\"nofollow\">cppreference's page on compare_exchange</a> gives the following example code (paraphrased snippet):</p>\n<pre><code>while(!head.compare_exchange_weak(new_node-&gt;next,\n                                  new_node,\n                                  std::memory_order_release,\n                                  std::memory_order_relaxed))\n      ; // empty body\n</code></pre>\n<p>Suppose you run this once on thread A, and once on thread B. Nothing else is touching <code>head</code> or its associated data. Thread B's invocation happens to start after thread A's has happened (in real time), but A's changes have not yet propagated to the cache of the CPU running Thread B.</p>\n<p>What forces A's changes to get to B? That is to say, why is the execution where B's weak compare exchange simply fails indefinitely and the CPU cache remains stale not allowed? Or is it allowed?</p>\n<p>It seems like the CPU running B is not being forced to go out and sync in the changes made by A, because the failure memory ordering is relaxed. So why does the hardware ever do so? Is this an implicit guarantee of the C++ spec, or of the hardware, or is bounded-staleness-of-memory a standard documented guarantee?</p>\n", "Tags": "<c++><concurrency><atomic>", "OwnerUserId": "52239", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29084160_29084412_0": {"section_id": 5839, "quality": 1.0, "length": 19}}, "n3337": {"so_29084160_29084412_0": {"section_id": 5609, "quality": 1.0, "length": 19}}, "n4659": {"so_29084160_29084412_0": {"section_id": 7317, "quality": 1.0, "length": 19}}}});