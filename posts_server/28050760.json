post_cb({"28051249": {"ParentId": "28050760", "CommentCount": "4", "Body": "<p>The usual implementation of a deque is basically a vector of pointers to fixed-sized nodes.</p>\n<p>Allocating the fixed-size node clearly has constant complexity, so that's pretty easy to handle--you just amortize the cost of allocating a single node across the number of items in that node to get a constant complexity for each.</p>\n<p>The vector of pointers part is what's (marginally) more interesting. When we allocate enough of the fixed-size nodes that the vector of pointers is full, we need to increase the size of the vector. Like <code>std::vector</code>, we need to copy its contents to the newly allocated vector, so its growth must follow a geometric (rather than arithmetic) progression. This means that we have more pointers to copy we do the copying less and less frequently, so the total time devoted to copying pointers remains constant.</p>\n<p>As a side note: the \"vector\" part is normally treated as a circular buffer, so if you're using your deque as a queue, constantly adding to one end and removing from the other does not result in re-allocating the vector--it just means moving the head and tail pointers that keep track of which of the pointers are \"active\" at a given time.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "28051249", "Score": "9", "CreationDate": "2015-01-20T17:12:19.983", "LastActivityDate": "2015-01-20T17:12:19.983"}, "28050760": {"CommentCount": "3", "AcceptedAnswerId": "28051249", "PostTypeId": "1", "LastEditorUserId": "4832300", "CreationDate": "2015-01-20T16:46:08.377", "LastActivityDate": "2017-11-01T18:29:18.830", "LastEditDate": "2017-11-01T18:29:18.830", "ViewCount": "746", "FavoriteCount": "2", "Title": "How does deque have an amortized constant Time Complexity", "Id": "28050760", "Score": "6", "Body": "<p>I read <a href=\"https://stackoverflow.com/questions/22306949/does-deque-provide-o1-complexity-when-inserting-on-top\">here</a> from the accepted answer that a std::deque has the following characteristic</p>\n<pre><code>1- Random access - constant O(1)\n2- Insertion or removal of elements at the end or beginning - amortized constant O(1)\n3- Insertion or removal of elements - linear O(n)\n</code></pre>\n<p>My question is about point 2. How can a deque have an amortized constant insertion at the end or beginning?</p>\n<p>I understand that a <code>std::vector</code> has an amortized constant time complexity for insertions at the end. This is because a vector is continguous and is a dynamic array. So when it runs out of memory for a <code>push_back</code> at the end, it would allocate a whole new block of memory, copy existing items from the old location to the new location and then delete items from the old location. This operation I understand is amortized constant. How does this apply to a deque ? How can insertions at the top and bottom of a deque be amortized constant. I was under the impression that it was supposed to be constant O(1). I know that a deque is composed of memory chunks.</p>\n", "Tags": "<c++><deque><c++03>", "OwnerUserId": "1305891", "AnswerCount": "2"}, "28052844": {"ParentId": "28050760", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The (profane) answer lies in containers.requirements.general, 23.2.1/2:</p>\n<blockquote>\n<p id=\"so_28050760_28052844_0\">All of the complexity requirements in this Clause are stated solely in\n  terms of the number of operations on the contained objects.</p>\n</blockquote>\n<p>Reallocating the array of pointers is hence not covered by the complexity guarantee of the standard and may take arbitrarily long. As mentioned before, it likely adds an amortized constant overhead to each <code>push_front()</code>/<code>push_back()</code> call (or an equivalent modifier) in any \"sane\" implementation. I would not recommend using <code>deque</code> in RT-critical code though. Typically, in an RT scenario, you don't want to have unbounded queues or stacks (which in C++ by default use <code>deque</code> as the underlying container) anyway, neither memory allocations that could fail, so you will be most likely using a preallocated ring buffer (e.g. Boost's <code>circular_buffer</code>) instead.</p>\n", "OwnerUserId": "4083309", "LastEditorUserId": "4083309", "LastEditDate": "2015-01-20T18:48:42.280", "Id": "28052844", "Score": "1", "CreationDate": "2015-01-20T18:42:42.457", "LastActivityDate": "2015-01-20T18:48:42.280"}, "bq_ids": {"n4140": {"so_28050760_28052844_0": {"section_id": 703, "quality": 1.0, "length": 11}}, "n3337": {"so_28050760_28052844_0": {"section_id": 693, "quality": 1.0, "length": 11}}, "n4659": {"so_28050760_28052844_0": {"section_id": 732, "quality": 1.0, "length": 11}}}});